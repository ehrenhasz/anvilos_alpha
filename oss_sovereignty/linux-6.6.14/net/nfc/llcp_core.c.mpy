{
  "module_name": "llcp_core.c",
  "hash_id": "cd9332fd4d6aaab6b6861cbc5de9ab62d8b2bef888e16fc10f2e11631eb46c69",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/llcp_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic u8 llcp_magic[3] = {0x46, 0x66, 0x6d};\n\nstatic LIST_HEAD(llcp_devices);\n \nstatic DEFINE_SPINLOCK(llcp_devices_lock);\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb);\n\nvoid nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock)\n{\n\tsock->remote_rw = LLCP_DEFAULT_RW;\n\tsock->remote_miu = LLCP_MAX_MIU + 1;\n}\n\nstatic void nfc_llcp_socket_purge(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local = sock->local;\n\tstruct sk_buff *s, *tmp;\n\n\tskb_queue_purge(&sock->tx_queue);\n\tskb_queue_purge(&sock->tx_pending_queue);\n\n\tif (local == NULL)\n\t\treturn;\n\n\t \n\tskb_queue_walk_safe(&local->tx_queue, s, tmp) {\n\t\tif (s->sk != &sock->sk)\n\t\t\tcontinue;\n\n\t\tskb_unlink(s, &local->tx_queue);\n\t\tkfree_skb(s);\n\t}\n}\n\nstatic void nfc_llcp_socket_release(struct nfc_llcp_local *local, bool device,\n\t\t\t\t    int err)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *tmp;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb_queue_purge(&local->tx_queue);\n\n\twrite_lock(&local->sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (sk->sk_state == LLCP_CONNECTED)\n\t\t\tnfc_put_device(llcp_sock->dev);\n\n\t\tif (sk->sk_state == LLCP_LISTEN) {\n\t\t\tstruct nfc_llcp_sock *lsk, *n;\n\t\t\tstruct sock *accept_sk;\n\n\t\t\tlist_for_each_entry_safe(lsk, n,\n\t\t\t\t\t\t &llcp_sock->accept_queue,\n\t\t\t\t\t\t accept_queue) {\n\t\t\t\taccept_sk = &lsk->sk;\n\t\t\t\tbh_lock_sock(accept_sk);\n\n\t\t\t\tnfc_llcp_accept_unlink(accept_sk);\n\n\t\t\t\tif (err)\n\t\t\t\t\taccept_sk->sk_err = err;\n\t\t\t\taccept_sk->sk_state = LLCP_CLOSED;\n\t\t\t\taccept_sk->sk_state_change(sk);\n\n\t\t\t\tbh_unlock_sock(accept_sk);\n\t\t\t}\n\t\t}\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->sockets.lock);\n\n\t \n\tif (device == true)\n\t\treturn;\n\n\twrite_lock(&local->raw_sockets.lock);\n\n\tsk_for_each_safe(sk, tmp, &local->raw_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tbh_lock_sock(sk);\n\n\t\tnfc_llcp_socket_purge(llcp_sock);\n\n\t\tif (err)\n\t\t\tsk->sk_err = err;\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\n\t\tbh_unlock_sock(sk);\n\n\t\tsk_del_node_init(sk);\n\t}\n\n\twrite_unlock(&local->raw_sockets.lock);\n}\n\nstatic struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\t \n\tif (!nfc_get_device(local->dev->idx))\n\t\treturn NULL;\n\n\tkref_get(&local->ref);\n\n\treturn local;\n}\n\nstatic void local_cleanup(struct nfc_llcp_local *local)\n{\n\tnfc_llcp_socket_release(local, false, ENXIO);\n\tdel_timer_sync(&local->link_timer);\n\tskb_queue_purge(&local->tx_queue);\n\tcancel_work_sync(&local->tx_work);\n\tcancel_work_sync(&local->rx_work);\n\tcancel_work_sync(&local->timeout_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n\tdel_timer_sync(&local->sdreq_timer);\n\tcancel_work_sync(&local->sdreq_timeout_work);\n\tnfc_llcp_free_sdp_tlv_list(&local->pending_sdreqs);\n}\n\nstatic void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\n\tlocal_cleanup(local);\n\tkfree(local);\n}\n\nint nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tstruct nfc_dev *dev;\n\tint ret;\n\n\tif (local == NULL)\n\t\treturn 0;\n\n\tdev = local->dev;\n\n\tret = kref_put(&local->ref, local_release);\n\tnfc_put_device(dev);\n\n\treturn ret;\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t       u8 ssap, u8 dsap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"ssap dsap %d %d\\n\", ssap, dsap);\n\n\tif (ssap == 0 && dsap == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tif (tmp_sock->ssap == ssap && tmp_sock->dsap == dsap) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\treturn llcp_sock;\n}\n\nstatic void nfc_llcp_sock_put(struct nfc_llcp_sock *sock)\n{\n\tsock_put(&sock->sk);\n}\n\nstatic void nfc_llcp_timeout_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    timeout_work);\n\n\tnfc_dep_link_down(local->dev);\n}\n\nstatic void nfc_llcp_symm_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, link_timer);\n\n\tpr_err(\"SYMM timeout\\n\");\n\n\tschedule_work(&local->timeout_work);\n}\n\nstatic void nfc_llcp_sdreq_timeout_work(struct work_struct *work)\n{\n\tunsigned long time;\n\tHLIST_HEAD(nl_sdres_list);\n\tstruct hlist_node *n;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    sdreq_timeout_work);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\ttime = jiffies - msecs_to_jiffies(3 * local->remote_lto);\n\n\thlist_for_each_entry_safe(sdp, n, &local->pending_sdreqs, node) {\n\t\tif (time_after(sdp->time, time))\n\t\t\tcontinue;\n\n\t\tsdp->sap = LLCP_SDP_UNBOUND;\n\n\t\thlist_del(&sdp->node);\n\n\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\t}\n\n\tif (!hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n}\n\nstatic void nfc_llcp_sdreq_timer(struct timer_list *t)\n{\n\tstruct nfc_llcp_local *local = from_timer(local, t, sdreq_timer);\n\n\tschedule_work(&local->sdreq_timeout_work);\n}\n\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_llcp_local *res = NULL;\n\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tres = nfc_llcp_local_get(local);\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\n\treturn res;\n}\n\nstatic struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\n\tpr_warn(\"Shutting down device not found\\n\");\n\n\treturn NULL;\n}\n\nstatic char *wks[] = {\n\tNULL,\n\tNULL,  \n\t\"urn:nfc:sn:ip\",\n\t\"urn:nfc:sn:obex\",\n\t\"urn:nfc:sn:snep\",\n};\n\nstatic int nfc_llcp_wks_sap(const char *service_name, size_t service_name_len)\n{\n\tint sap, num_wks;\n\n\tpr_debug(\"%s\\n\", service_name);\n\n\tif (service_name == NULL)\n\t\treturn -EINVAL;\n\n\tnum_wks = ARRAY_SIZE(wks);\n\n\tfor (sap = 0; sap < num_wks; sap++) {\n\t\tif (wks[sap] == NULL)\n\t\t\tcontinue;\n\n\t\tif (strncmp(wks[sap], service_name, service_name_len) == 0)\n\t\t\treturn sap;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic\nstruct nfc_llcp_sock *nfc_llcp_sock_from_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t    const u8 *sn, size_t sn_len,\n\t\t\t\t\t    bool needref)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\n\n\tpr_debug(\"sn %zd %p\\n\", sn_len, sn);\n\n\tif (sn == NULL || sn_len == 0)\n\t\treturn NULL;\n\n\tread_lock(&local->sockets.lock);\n\n\tllcp_sock = NULL;\n\n\tsk_for_each(sk, &local->sockets.head) {\n\t\ttmp_sock = nfc_llcp_sock(sk);\n\n\t\tpr_debug(\"llcp sock %p\\n\", tmp_sock);\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_STREAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->sk.sk_type == SOCK_DGRAM &&\n\t\t    tmp_sock->sk.sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name == NULL ||\n\t\t    tmp_sock->service_name_len == 0)\n\t\t\tcontinue;\n\n\t\tif (tmp_sock->service_name_len != sn_len)\n\t\t\tcontinue;\n\n\t\tif (memcmp(sn, tmp_sock->service_name, sn_len) == 0) {\n\t\t\tllcp_sock = tmp_sock;\n\t\t\tif (needref)\n\t\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&local->sockets.lock);\n\n\tpr_debug(\"Found llcp sock %p\\n\", llcp_sock);\n\n\treturn llcp_sock;\n}\n\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\n\t\t\t struct nfc_llcp_sock *sock)\n{\n\tmutex_lock(&local->sdp_lock);\n\n\tif (sock->service_name != NULL && sock->service_name_len > 0) {\n\t\tint ssap = nfc_llcp_wks_sap(sock->service_name,\n\t\t\t\t\t    sock->service_name_len);\n\n\t\tif (ssap > 0) {\n\t\t\tpr_debug(\"WKS %d\\n\", ssap);\n\n\t\t\t \n\t\t\tif (test_bit(ssap, &local->local_wks)) {\n\t\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\t\treturn LLCP_SAP_MAX;\n\t\t\t}\n\n\t\t\tset_bit(ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn ssap;\n\t\t}\n\n\t\t \n\t\tif (nfc_llcp_sock_from_sn(local, sock->service_name,\n\t\t\t\t\t  sock->service_name_len,\n\t\t\t\t\t  false) != NULL) {\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn LLCP_SAP_MAX;\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SDP_UNBOUND;\n\n\t} else if (sock->ssap != 0 && sock->ssap < LLCP_WKS_NUM_SAP) {\n\t\tif (!test_bit(sock->ssap, &local->local_wks)) {\n\t\t\tset_bit(sock->ssap, &local->local_wks);\n\t\t\tmutex_unlock(&local->sdp_lock);\n\n\t\t\treturn sock->ssap;\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_SAP_MAX;\n}\n\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local)\n{\n\tu8 local_ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tlocal_ssap = find_first_zero_bit(&local->local_sap, LLCP_LOCAL_NUM_SAP);\n\tif (local_ssap == LLCP_LOCAL_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tset_bit(local_ssap, &local->local_sap);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn local_ssap + LLCP_LOCAL_SAP_OFFSET;\n}\n\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap)\n{\n\tu8 local_ssap;\n\tunsigned long *sdp;\n\n\tif (ssap < LLCP_WKS_NUM_SAP) {\n\t\tlocal_ssap = ssap;\n\t\tsdp = &local->local_wks;\n\t} else if (ssap < LLCP_LOCAL_NUM_SAP) {\n\t\tatomic_t *client_cnt;\n\n\t\tlocal_ssap = ssap - LLCP_WKS_NUM_SAP;\n\t\tsdp = &local->local_sdp;\n\t\tclient_cnt = &local->local_sdp_cnt[local_ssap];\n\n\t\tpr_debug(\"%d clients\\n\", atomic_read(client_cnt));\n\n\t\tmutex_lock(&local->sdp_lock);\n\n\t\tif (atomic_dec_and_test(client_cnt)) {\n\t\t\tstruct nfc_llcp_sock *l_sock;\n\n\t\t\tpr_debug(\"No more clients for SAP %d\\n\", ssap);\n\n\t\t\tclear_bit(local_ssap, sdp);\n\n\t\t\t \n\t\t\tl_sock = nfc_llcp_sock_get(local, ssap, LLCP_SAP_SDP);\n\t\t\tif (l_sock) {\n\t\t\t\tl_sock->ssap = LLCP_SDP_UNBOUND;\n\t\t\t\tnfc_llcp_sock_put(l_sock);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn;\n\t} else if (ssap < LLCP_MAX_SAP) {\n\t\tlocal_ssap = ssap - LLCP_LOCAL_NUM_SAP;\n\t\tsdp = &local->local_sap;\n\t} else {\n\t\treturn;\n\t}\n\n\tmutex_lock(&local->sdp_lock);\n\n\tclear_bit(local_ssap, sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n}\n\nstatic u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n{\n\tu8 ssap;\n\n\tmutex_lock(&local->sdp_lock);\n\n\tssap = find_first_zero_bit(&local->local_sdp, LLCP_SDP_NUM_SAP);\n\tif (ssap == LLCP_SDP_NUM_SAP) {\n\t\tmutex_unlock(&local->sdp_lock);\n\n\t\treturn LLCP_SAP_MAX;\n\t}\n\n\tpr_debug(\"SDP ssap %d\\n\", LLCP_WKS_NUM_SAP + ssap);\n\n\tset_bit(ssap, &local->local_sdp);\n\n\tmutex_unlock(&local->sdp_lock);\n\n\treturn LLCP_WKS_NUM_SAP + ssap;\n}\n\nstatic int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, version, version_length;\n\tu8 lto_length, wks_length, miux_length;\n\tconst u8 *version_tlv = NULL, *lto_tlv = NULL,\n\t   *wks_tlv = NULL, *miux_tlv = NULL;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tif (!version_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += version_length;\n\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tif (!lto_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += lto_length;\n\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tif (!wks_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += wks_length;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tif (!miux_tlv) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tgb_len += miux_length;\n\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgb_cur = local->gb;\n\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\n\tlocal->gb_len = gb_len;\n\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\n\treturn ret;\n}\n\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\n\tnfc_llcp_build_gb(local);\n\n\t*general_bytes_len = local->gb_len;\n\n\tnfc_llcp_local_put(local);\n\n\treturn local->gb;\n}\n\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tint err;\n\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\nout:\n\tnfc_llcp_local_put(local);\n\treturn err;\n}\n\nstatic u8 nfc_llcp_dsap(const struct sk_buff *pdu)\n{\n\treturn (pdu->data[0] & 0xfc) >> 2;\n}\n\nstatic u8 nfc_llcp_ptype(const struct sk_buff *pdu)\n{\n\treturn ((pdu->data[0] & 0x03) << 2) | ((pdu->data[1] & 0xc0) >> 6);\n}\n\nstatic u8 nfc_llcp_ssap(const struct sk_buff *pdu)\n{\n\treturn pdu->data[1] & 0x3f;\n}\n\nstatic u8 nfc_llcp_ns(const struct sk_buff *pdu)\n{\n\treturn pdu->data[2] >> 4;\n}\n\nstatic u8 nfc_llcp_nr(const struct sk_buff *pdu)\n{\n\treturn pdu->data[2] & 0xf;\n}\n\nstatic void nfc_llcp_set_nrns(struct nfc_llcp_sock *sock, struct sk_buff *pdu)\n{\n\tpdu->data[2] = (sock->send_n << 4) | (sock->recv_n);\n\tsock->send_n = (sock->send_n + 1) % 16;\n\tsock->recv_ack_n = (sock->recv_n - 1) % 16;\n}\n\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&local->raw_sockets.lock);\n\n\tsk_for_each(sk, &local->raw_sockets.head) {\n\t\tif (sk->sk_state != LLCP_BOUND)\n\t\t\tcontinue;\n\n\t\tif (skb_copy == NULL) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\n\t\t\tif (skb_copy == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = local->dev ? local->dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (RAW_PAYLOAD_LLCP << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&local->raw_sockets.lock);\n\n\tkfree_skb(skb_copy);\n}\n\nstatic void nfc_llcp_tx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    tx_work);\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tskb = skb_dequeue(&local->tx_queue);\n\tif (skb != NULL) {\n\t\tsk = skb->sk;\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock == NULL && nfc_llcp_ptype(skb) == LLCP_PDU_I) {\n\t\t\tkfree_skb(skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else if (llcp_sock && !llcp_sock->remote_ready) {\n\t\t\tskb_queue_head(&local->tx_queue, skb);\n\t\t\tnfc_llcp_send_symm(local->dev);\n\t\t} else {\n\t\t\tstruct sk_buff *copy_skb = NULL;\n\t\t\tu8 ptype = nfc_llcp_ptype(skb);\n\t\t\tint ret;\n\n\t\t\tpr_debug(\"Sending pending skb\\n\");\n\t\t\tprint_hex_dump_debug(\"LLCP Tx: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t\t     16, 1, skb->data, skb->len, true);\n\n\t\t\tif (ptype == LLCP_PDU_I)\n\t\t\t\tcopy_skb = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\t__net_timestamp(skb);\n\n\t\t\tnfc_llcp_send_to_raw_sock(local, skb,\n\t\t\t\t\t\t  NFC_DIRECTION_TX);\n\n\t\t\tret = nfc_data_exchange(local->dev, local->target_idx,\n\t\t\t\t\t\tskb, nfc_llcp_recv, local);\n\n\t\t\tif (ret) {\n\t\t\t\tkfree_skb(copy_skb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ptype == LLCP_PDU_I && copy_skb)\n\t\t\t\tskb_queue_tail(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t       copy_skb);\n\t\t}\n\t} else {\n\t\tnfc_llcp_send_symm(local->dev);\n\t}\n\nout:\n\tmod_timer(&local->link_timer,\n\t\t  jiffies + msecs_to_jiffies(2 * local->remote_lto));\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_connecting_sock_get(struct nfc_llcp_local *local,\n\t\t\t\t\t\t\t  u8 ssap)\n{\n\tstruct sock *sk;\n\tstruct nfc_llcp_sock *llcp_sock;\n\n\tread_lock(&local->connecting_sockets.lock);\n\n\tsk_for_each(sk, &local->connecting_sockets.head) {\n\t\tllcp_sock = nfc_llcp_sock(sk);\n\n\t\tif (llcp_sock->ssap == ssap) {\n\t\t\tsock_hold(&llcp_sock->sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tllcp_sock = NULL;\n\nout:\n\tread_unlock(&local->connecting_sockets.lock);\n\n\treturn llcp_sock;\n}\n\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get_sn(struct nfc_llcp_local *local,\n\t\t\t\t\t\t  const u8 *sn, size_t sn_len)\n{\n\treturn nfc_llcp_sock_from_sn(local, sn, sn_len, true);\n}\n\nstatic const u8 *nfc_llcp_connect_sn(const struct sk_buff *skb, size_t *sn_len)\n{\n\tu8 type, length;\n\tconst u8 *tlv = &skb->data[2];\n\tsize_t tlv_array_len = skb->len - LLCP_HEADER_SIZE, offset = 0;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tif (type == LLCP_TLV_SN) {\n\t\t\t*sn_len = length;\n\t\t\treturn &tlv[2];\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\treturn NULL;\n}\n\nstatic void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct nfc_llcp_ui_cb *ui_cb;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tui_cb = nfc_llcp_ui_skb_cb(skb);\n\tui_cb->dsap = dsap;\n\tui_cb->ssap = ssap;\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\t \n\tllcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\tif (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\n\t\treturn;\n\n\t \n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t \n\t\tskb_get(skb);\n\t} else {\n\t\tpr_err(\"Receive queue is full\\n\");\n\t}\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_connect(struct nfc_llcp_local *local,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct sock *new_sk, *parent;\n\tstruct nfc_llcp_sock *sock, *new_sock;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP) {\n\t\tsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n\t\tif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tconst u8 *sn;\n\t\tsize_t sn_len;\n\n\t\tsn = nfc_llcp_connect_sn(skb, &sn_len);\n\t\tif (sn == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tpr_debug(\"Service name length %zu\\n\", sn_len);\n\n\t\tsock = nfc_llcp_sock_get_sn(local, sn, sn_len);\n\t\tif (sock == NULL) {\n\t\t\treason = LLCP_DM_NOBOUND;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlock_sock(&sock->sk);\n\n\tparent = &sock->sk;\n\n\tif (sk_acceptq_is_full(parent)) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tif (sock->ssap == LLCP_SDP_UNBOUND) {\n\t\tu8 ssap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\tpr_debug(\"First client, reserving %d\\n\", ssap);\n\n\t\tif (ssap == LLCP_SAP_MAX) {\n\t\t\treason = LLCP_DM_REJ;\n\t\t\trelease_sock(&sock->sk);\n\t\t\tsock_put(&sock->sk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsock->ssap = ssap;\n\t}\n\n\tnew_sk = nfc_llcp_sock_alloc(NULL, parent->sk_type, GFP_ATOMIC, 0);\n\tif (new_sk == NULL) {\n\t\treason = LLCP_DM_REJ;\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tnew_sock = nfc_llcp_sock(new_sk);\n\n\tnew_sock->local = nfc_llcp_local_get(local);\n\tif (!new_sock->local) {\n\t\treason = LLCP_DM_REJ;\n\t\tsock_put(&new_sock->sk);\n\t\trelease_sock(&sock->sk);\n\t\tsock_put(&sock->sk);\n\t\tgoto fail;\n\t}\n\n\tnew_sock->dev = local->dev;\n\tnew_sock->rw = sock->rw;\n\tnew_sock->miux = sock->miux;\n\tnew_sock->nfc_protocol = sock->nfc_protocol;\n\tnew_sock->dsap = ssap;\n\tnew_sock->target_idx = local->target_idx;\n\tnew_sock->parent = parent;\n\tnew_sock->ssap = sock->ssap;\n\tif (sock->ssap < LLCP_LOCAL_NUM_SAP && sock->ssap >= LLCP_WKS_NUM_SAP) {\n\t\tatomic_t *client_count;\n\n\t\tpr_debug(\"reserved_ssap %d for %p\\n\", sock->ssap, new_sock);\n\n\t\tclient_count =\n\t\t\t&local->local_sdp_cnt[sock->ssap - LLCP_WKS_NUM_SAP];\n\n\t\tatomic_inc(client_count);\n\t\tnew_sock->reserved_ssap = sock->ssap;\n\t}\n\n\tnfc_llcp_parse_connection_tlv(new_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tpr_debug(\"new sock %p sk %p\\n\", new_sock, &new_sock->sk);\n\n\tnfc_llcp_sock_link(&local->sockets, new_sk);\n\n\tnfc_llcp_accept_enqueue(&sock->sk, new_sk);\n\n\tnfc_get_device(local->dev->idx);\n\n\tnew_sk->sk_state = LLCP_CONNECTED;\n\n\t \n\tparent->sk_data_ready(parent);\n\n\t \n\tnfc_llcp_send_cc(new_sock);\n\n\trelease_sock(&sock->sk);\n\tsock_put(&sock->sk);\n\n\treturn;\n\nfail:\n\t \n\tnfc_llcp_send_dm(local, dsap, ssap, reason);\n}\n\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock)\n{\n\tint nr_frames = 0;\n\tstruct nfc_llcp_local *local = sock->local;\n\n\tpr_debug(\"Remote ready %d tx queue len %d remote rw %d\",\n\t\t sock->remote_ready, skb_queue_len(&sock->tx_pending_queue),\n\t\t sock->remote_rw);\n\n\t \n\twhile (sock->remote_ready &&\n\t       skb_queue_len(&sock->tx_pending_queue) < sock->remote_rw) {\n\t\tstruct sk_buff *pdu;\n\n\t\tpdu = skb_dequeue(&sock->tx_queue);\n\t\tif (pdu == NULL)\n\t\t\tbreak;\n\n\t\t \n\t\tnfc_llcp_set_nrns(sock, pdu);\n\n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\t\tnr_frames++;\n\t}\n\n\treturn nr_frames;\n}\n\nstatic void nfc_llcp_recv_hdlc(struct nfc_llcp_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, ptype, ns, nr;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\tns = nfc_llcp_ns(skb);\n\tnr = nfc_llcp_nr(skb);\n\n\tpr_debug(\"%d %d R %d S %d\\n\", dsap, ssap, nr, ns);\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\t \n\tif (ptype == LLCP_PDU_I) {\n\t\tpr_debug(\"I frame, queueing on %p\\n\", &llcp_sock->sk);\n\n\t\tif (ns == llcp_sock->recv_n)\n\t\t\tllcp_sock->recv_n = (llcp_sock->recv_n + 1) % 16;\n\t\telse\n\t\t\tpr_err(\"Received out of sequence I PDU\\n\");\n\n\t\tskb_pull(skb, LLCP_HEADER_SIZE + LLCP_SEQUENCE_SIZE);\n\t\tif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n\t\t\t \n\t\t\tskb_get(skb);\n\t\t} else {\n\t\t\tpr_err(\"Receive queue is full\\n\");\n\t\t}\n\t}\n\n\t \n\tif (llcp_sock->send_ack_n != nr) {\n\t\tstruct sk_buff *s, *tmp;\n\t\tu8 n;\n\n\t\tllcp_sock->send_ack_n = nr;\n\n\t\t \n\t\tskb_queue_walk_safe(&llcp_sock->tx_pending_queue, s, tmp) {\n\t\t\tn = nfc_llcp_ns(s);\n\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tkfree_skb(s);\n\n\t\t\tif (n == nr)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tskb_queue_reverse_walk_safe(&llcp_sock->tx_pending_queue,\n\t\t\t\t\t    s, tmp) {\n\t\t\tskb_unlink(s, &llcp_sock->tx_pending_queue);\n\t\t\tskb_queue_head(&local->tx_queue, s);\n\t\t}\n\t}\n\n\tif (ptype == LLCP_PDU_RR)\n\t\tllcp_sock->remote_ready = true;\n\telse if (ptype == LLCP_PDU_RNR)\n\t\tllcp_sock->remote_ready = false;\n\n\tif (nfc_llcp_queue_i_frames(llcp_sock) == 0 && ptype == LLCP_PDU_I)\n\t\tnfc_llcp_send_rr(llcp_sock);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_disc(struct nfc_llcp_local *local,\n\t\t\t       const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tif ((dsap == 0) && (ssap == 0)) {\n\t\tpr_debug(\"Connection termination\");\n\t\tnfc_dep_link_down(local->dev);\n\t\treturn;\n\t}\n\n\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\tif (llcp_sock == NULL) {\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\tlock_sock(sk);\n\n\tnfc_llcp_socket_purge(llcp_sock);\n\n\tif (sk->sk_state == LLCP_CLOSED) {\n\t\trelease_sock(sk);\n\t\tnfc_llcp_sock_put(llcp_sock);\n\t}\n\n\tif (sk->sk_state == LLCP_CONNECTED) {\n\t\tnfc_put_device(local->dev);\n\t\tsk->sk_state = LLCP_CLOSED;\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_DISC);\n\n\trelease_sock(sk);\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_cc(struct nfc_llcp_local *local,\n\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\tif (llcp_sock == NULL) {\n\t\tpr_err(\"Invalid CC\\n\");\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\t \n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tllcp_sock->dsap = ssap;\n\n\tnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tsk->sk_state = LLCP_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_dm(struct nfc_llcp_local *local,\n\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap, reason;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\treason = skb->data[2];\n\n\tpr_debug(\"%d %d reason %d\\n\", ssap, dsap, reason);\n\n\tswitch (reason) {\n\tcase LLCP_DM_NOBOUND:\n\tcase LLCP_DM_REJ:\n\t\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\t\tbreak;\n\n\tdefault:\n\t\tllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\n\t\tbreak;\n\t}\n\n\tif (llcp_sock == NULL) {\n\t\tpr_debug(\"Already closed\\n\");\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\tsk->sk_err = ENXIO;\n\tsk->sk_state = LLCP_CLOSED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n\nstatic void nfc_llcp_recv_snl(struct nfc_llcp_local *local,\n\t\t\t      const struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tu8 dsap, ssap, type, length, tid, sap;\n\tconst u8 *tlv;\n\tu16 tlv_len, offset;\n\tconst char *service_name;\n\tsize_t service_name_len;\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tHLIST_HEAD(llc_sdres_list);\n\tsize_t sdres_tlvs_len;\n\tHLIST_HEAD(nl_sdres_list);\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"%d %d\\n\", dsap, ssap);\n\n\tif (dsap != LLCP_SAP_SDP || ssap != LLCP_SAP_SDP) {\n\t\tpr_err(\"Wrong SNL SAP\\n\");\n\t\treturn;\n\t}\n\n\ttlv = &skb->data[LLCP_HEADER_SIZE];\n\ttlv_len = skb->len - LLCP_HEADER_SIZE;\n\toffset = 0;\n\tsdres_tlvs_len = 0;\n\n\twhile (offset < tlv_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_SDREQ:\n\t\t\ttid = tlv[2];\n\t\t\tservice_name = (char *) &tlv[3];\n\t\t\tservice_name_len = length - 1;\n\n\t\t\tpr_debug(\"Looking for %.16s\\n\", service_name);\n\n\t\t\tif (service_name_len == strlen(\"urn:nfc:sn:sdp\") &&\n\t\t\t    !strncmp(service_name, \"urn:nfc:sn:sdp\",\n\t\t\t\t     service_name_len)) {\n\t\t\t\tsap = 1;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\tllcp_sock = nfc_llcp_sock_from_sn(local, service_name,\n\t\t\t\t\t\t\t  service_name_len,\n\t\t\t\t\t\t\t  true);\n\t\t\tif (!llcp_sock) {\n\t\t\t\tsap = 0;\n\t\t\t\tgoto add_snl;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (llcp_sock->ssap == LLCP_SDP_UNBOUND) {\n\t\t\t\tatomic_t *client_count;\n\n\t\t\t\tsap = nfc_llcp_reserve_sdp_ssap(local);\n\n\t\t\t\tpr_debug(\"Reserving %d\\n\", sap);\n\n\t\t\t\tif (sap == LLCP_SAP_MAX) {\n\t\t\t\t\tsap = 0;\n\t\t\t\t\tnfc_llcp_sock_put(llcp_sock);\n\t\t\t\t\tgoto add_snl;\n\t\t\t\t}\n\n\t\t\t\tclient_count =\n\t\t\t\t\t&local->local_sdp_cnt[sap -\n\t\t\t\t\t\t\t      LLCP_WKS_NUM_SAP];\n\n\t\t\t\tatomic_inc(client_count);\n\n\t\t\t\tllcp_sock->ssap = sap;\n\t\t\t\tllcp_sock->reserved_ssap = sap;\n\t\t\t} else {\n\t\t\t\tsap = llcp_sock->ssap;\n\t\t\t}\n\n\t\t\tpr_debug(\"%p %d\\n\", llcp_sock, sap);\n\n\t\t\tnfc_llcp_sock_put(llcp_sock);\nadd_snl:\n\t\t\tsdp = nfc_llcp_build_sdres_tlv(tid, sap);\n\t\t\tif (sdp == NULL)\n\t\t\t\tgoto exit;\n\n\t\t\tsdres_tlvs_len += sdp->tlv_len;\n\t\t\thlist_add_head(&sdp->node, &llc_sdres_list);\n\t\t\tbreak;\n\n\t\tcase LLCP_TLV_SDRES:\n\t\t\tmutex_lock(&local->sdreq_lock);\n\n\t\t\tpr_debug(\"LLCP_TLV_SDRES: searching tid %d\\n\", tlv[2]);\n\n\t\t\thlist_for_each_entry(sdp, &local->pending_sdreqs, node) {\n\t\t\t\tif (sdp->tid != tlv[2])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsdp->sap = tlv[3];\n\n\t\t\t\tpr_debug(\"Found: uri=%s, sap=%d\\n\",\n\t\t\t\t\t sdp->uri, sdp->sap);\n\n\t\t\t\thlist_del(&sdp->node);\n\n\t\t\t\thlist_add_head(&sdp->node, &nl_sdres_list);\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&local->sdreq_lock);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Invalid SNL tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\nexit:\n\tif (!hlist_empty(&nl_sdres_list))\n\t\tnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\n\n\tif (!hlist_empty(&llc_sdres_list))\n\t\tnfc_llcp_send_snl_sdres(local, &llc_sdres_list, sdres_tlvs_len);\n}\n\nstatic void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 ptype;\n\tu16 pdu_len;\n\tstruct sk_buff *new_skb;\n\n\tif (skb->len <= LLCP_HEADER_SIZE) {\n\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\treturn;\n\t}\n\n\tskb_pull(skb, LLCP_HEADER_SIZE);\n\n\twhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\n\t\tpdu_len = skb->data[0] << 8 | skb->data[1];\n\n\t\tskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\n\n\t\tif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\n\t\t\tpr_err(\"Malformed AGF PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tptype = nfc_llcp_ptype(skb);\n\n\t\tif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\n\t\t\tgoto next;\n\n\t\tnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\n\t\tif (new_skb == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_data(new_skb, skb->data, pdu_len);\n\n\t\tnfc_llcp_rx_skb(local, new_skb);\n\n\t\tkfree_skb(new_skb);\nnext:\n\t\tskb_pull(skb, pdu_len);\n\t}\n}\n\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tu8 dsap, ssap, ptype;\n\n\tptype = nfc_llcp_ptype(skb);\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\tif (ptype != LLCP_PDU_SYMM)\n\t\tprint_hex_dump_debug(\"LLCP Rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t     skb->data, skb->len, true);\n\n\tswitch (ptype) {\n\tcase LLCP_PDU_SYMM:\n\t\tpr_debug(\"SYMM\\n\");\n\t\tbreak;\n\n\tcase LLCP_PDU_UI:\n\t\tpr_debug(\"UI\\n\");\n\t\tnfc_llcp_recv_ui(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CONNECT:\n\t\tpr_debug(\"CONNECT\\n\");\n\t\tnfc_llcp_recv_connect(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DISC:\n\t\tpr_debug(\"DISC\\n\");\n\t\tnfc_llcp_recv_disc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_CC:\n\t\tpr_debug(\"CC\\n\");\n\t\tnfc_llcp_recv_cc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_DM:\n\t\tpr_debug(\"DM\\n\");\n\t\tnfc_llcp_recv_dm(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_SNL:\n\t\tpr_debug(\"SNL\\n\");\n\t\tnfc_llcp_recv_snl(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_I:\n\tcase LLCP_PDU_RR:\n\tcase LLCP_PDU_RNR:\n\t\tpr_debug(\"I frame\\n\");\n\t\tnfc_llcp_recv_hdlc(local, skb);\n\t\tbreak;\n\n\tcase LLCP_PDU_AGF:\n\t\tpr_debug(\"AGF frame\\n\");\n\t\tnfc_llcp_recv_agf(local, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void nfc_llcp_rx_work(struct work_struct *work)\n{\n\tstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\n\t\t\t\t\t\t    rx_work);\n\tstruct sk_buff *skb;\n\n\tskb = local->rx_pending;\n\tif (skb == NULL) {\n\t\tpr_debug(\"No pending SKB\\n\");\n\t\treturn;\n\t}\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_RX);\n\n\tnfc_llcp_rx_skb(local, skb);\n\n\tschedule_work(&local->tx_work);\n\tkfree_skb(local->rx_pending);\n\tlocal->rx_pending = NULL;\n}\n\nstatic void __nfc_llcp_recv(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tlocal->rx_pending = skb;\n\tdel_timer(&local->link_timer);\n\tschedule_work(&local->rx_work);\n}\n\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err)\n{\n\tstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\n\n\tif (err < 0) {\n\t\tpr_err(\"LLCP PDU receive err %d\\n\", err);\n\t\treturn;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n}\n\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t__nfc_llcp_recv(local, skb);\n\n\tnfc_llcp_local_put(local);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\t \n\tnfc_llcp_socket_release(local, true, 0);\n\n\tnfc_llcp_local_put(local);\n}\n\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n\n\tnfc_llcp_local_put(local);\n}\n\nint nfc_llcp_register_device(struct nfc_dev *ndev)\n{\n\tstruct nfc_llcp_local *local;\n\n\tlocal = kzalloc(sizeof(struct nfc_llcp_local), GFP_KERNEL);\n\tif (local == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tlocal->dev = nfc_get_device(ndev->idx);\n\tif (!local->dev) {\n\t\tkfree(local);\n\t\treturn -ENODEV;\n\t}\n\n\tINIT_LIST_HEAD(&local->list);\n\tkref_init(&local->ref);\n\tmutex_init(&local->sdp_lock);\n\ttimer_setup(&local->link_timer, nfc_llcp_symm_timer, 0);\n\n\tskb_queue_head_init(&local->tx_queue);\n\tINIT_WORK(&local->tx_work, nfc_llcp_tx_work);\n\n\tlocal->rx_pending = NULL;\n\tINIT_WORK(&local->rx_work, nfc_llcp_rx_work);\n\n\tINIT_WORK(&local->timeout_work, nfc_llcp_timeout_work);\n\n\trwlock_init(&local->sockets.lock);\n\trwlock_init(&local->connecting_sockets.lock);\n\trwlock_init(&local->raw_sockets.lock);\n\n\tlocal->lto = 150;  \n\tlocal->rw = LLCP_MAX_RW;\n\tlocal->miux = cpu_to_be16(LLCP_MAX_MIUX);\n\tlocal->local_wks = 0x1;  \n\n\tnfc_llcp_build_gb(local);\n\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\n\tmutex_init(&local->sdreq_lock);\n\tINIT_HLIST_HEAD(&local->pending_sdreqs);\n\ttimer_setup(&local->sdreq_timer, nfc_llcp_sdreq_timer, 0);\n\tINIT_WORK(&local->sdreq_timeout_work, nfc_llcp_sdreq_timeout_work);\n\n\tspin_lock(&llcp_devices_lock);\n\tlist_add(&local->list, &llcp_devices);\n\tspin_unlock(&llcp_devices_lock);\n\n\treturn 0;\n}\n\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_remove_local(dev);\n\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\n\tlocal_cleanup(local);\n\n\tnfc_llcp_local_put(local);\n}\n\nint __init nfc_llcp_init(void)\n{\n\treturn nfc_llcp_sock_init();\n}\n\nvoid nfc_llcp_exit(void)\n{\n\tnfc_llcp_sock_exit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}