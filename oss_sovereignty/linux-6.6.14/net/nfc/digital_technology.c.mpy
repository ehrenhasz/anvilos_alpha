{
  "module_name": "digital_technology.c",
  "hash_id": "1f07566b9249ae3ca762a52d3afd4fedd399fe8946f4fcad77b3ff64bcbc82e6",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/digital_technology.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"digital: %s: \" fmt, __func__\n\n#include \"digital.h\"\n\n#define DIGITAL_CMD_SENS_REQ    0x26\n#define DIGITAL_CMD_ALL_REQ     0x52\n#define DIGITAL_CMD_SEL_REQ_CL1 0x93\n#define DIGITAL_CMD_SEL_REQ_CL2 0x95\n#define DIGITAL_CMD_SEL_REQ_CL3 0x97\n\n#define DIGITAL_SDD_REQ_SEL_PAR 0x20\n\n#define DIGITAL_SDD_RES_CT  0x88\n#define DIGITAL_SDD_RES_LEN 5\n#define DIGITAL_SEL_RES_LEN 1\n\n#define DIGITAL_SEL_RES_NFCID1_COMPLETE(sel_res) (!((sel_res) & 0x04))\n#define DIGITAL_SEL_RES_IS_T2T(sel_res) (!((sel_res) & 0x60))\n#define DIGITAL_SEL_RES_IS_T4T(sel_res) ((sel_res) & 0x20)\n#define DIGITAL_SEL_RES_IS_NFC_DEP(sel_res) ((sel_res) & 0x40)\n\n#define DIGITAL_SENS_RES_IS_T1T(sens_res) (((sens_res) & 0x0C00) == 0x0C00)\n#define DIGITAL_SENS_RES_IS_VALID(sens_res) \\\n\t((!((sens_res) & 0x001F) && (((sens_res) & 0x0C00) == 0x0C00)) || \\\n\t(((sens_res) & 0x001F) && ((sens_res) & 0x0C00) != 0x0C00))\n\n#define DIGITAL_MIFARE_READ_RES_LEN 16\n#define DIGITAL_MIFARE_ACK_RES\t0x0A\n\n#define DIGITAL_CMD_SENSB_REQ\t\t\t0x05\n#define DIGITAL_SENSB_ADVANCED\t\t\tBIT(5)\n#define DIGITAL_SENSB_EXTENDED\t\t\tBIT(4)\n#define DIGITAL_SENSB_ALLB_REQ\t\t\tBIT(3)\n#define DIGITAL_SENSB_N(n)\t\t\t((n) & 0x7)\n\n#define DIGITAL_CMD_SENSB_RES\t\t\t0x50\n\n#define DIGITAL_CMD_ATTRIB_REQ\t\t\t0x1D\n#define DIGITAL_ATTRIB_P1_TR0_DEFAULT\t\t(0x0 << 6)\n#define DIGITAL_ATTRIB_P1_TR1_DEFAULT\t\t(0x0 << 4)\n#define DIGITAL_ATTRIB_P1_SUPRESS_EOS\t\tBIT(3)\n#define DIGITAL_ATTRIB_P1_SUPRESS_SOS\t\tBIT(2)\n#define DIGITAL_ATTRIB_P2_LISTEN_POLL_1\t\t(0x0 << 6)\n#define DIGITAL_ATTRIB_P2_POLL_LISTEN_1\t\t(0x0 << 4)\n#define DIGITAL_ATTRIB_P2_MAX_FRAME_256\t\t0x8\n#define DIGITAL_ATTRIB_P4_DID(n)\t\t((n) & 0xf)\n\n#define DIGITAL_CMD_SENSF_REQ\t0x00\n#define DIGITAL_CMD_SENSF_RES\t0x01\n\n#define DIGITAL_SENSF_RES_MIN_LENGTH 17\n#define DIGITAL_SENSF_RES_RD_AP_B1   0x00\n#define DIGITAL_SENSF_RES_RD_AP_B2   0x8F\n\n#define DIGITAL_SENSF_REQ_RC_NONE 0\n#define DIGITAL_SENSF_REQ_RC_SC   1\n#define DIGITAL_SENSF_REQ_RC_AP   2\n\n#define DIGITAL_CMD_ISO15693_INVENTORY_REQ\t0x01\n\n#define DIGITAL_ISO15693_REQ_FLAG_DATA_RATE\tBIT(1)\n#define DIGITAL_ISO15693_REQ_FLAG_INVENTORY\tBIT(2)\n#define DIGITAL_ISO15693_REQ_FLAG_NB_SLOTS\tBIT(5)\n#define DIGITAL_ISO15693_RES_FLAG_ERROR\t\tBIT(0)\n#define DIGITAL_ISO15693_RES_IS_VALID(flags) \\\n\t(!((flags) & DIGITAL_ISO15693_RES_FLAG_ERROR))\n\n#define DIGITAL_ISO_DEP_I_PCB\t 0x02\n#define DIGITAL_ISO_DEP_PNI(pni) ((pni) & 0x01)\n\n#define DIGITAL_ISO_DEP_PCB_TYPE(pcb) ((pcb) & 0xC0)\n\n#define DIGITAL_ISO_DEP_I_BLOCK 0x00\n\n#define DIGITAL_ISO_DEP_BLOCK_HAS_DID(pcb) ((pcb) & 0x08)\n\nstatic const u8 digital_ats_fsc[] = {\n\t 16,  24,  32,  40,  48,  64,  96, 128,\n};\n\n#define DIGITAL_ATS_FSCI(t0) ((t0) & 0x0F)\n#define DIGITAL_SENSB_FSCI(pi2) (((pi2) & 0xF0) >> 4)\n#define DIGITAL_ATS_MAX_FSC  256\n\n#define DIGITAL_RATS_BYTE1 0xE0\n#define DIGITAL_RATS_PARAM 0x80\n\nstruct digital_sdd_res {\n\tu8 nfcid1[4];\n\tu8 bcc;\n} __packed;\n\nstruct digital_sel_req {\n\tu8 sel_cmd;\n\tu8 b2;\n\tu8 nfcid1[4];\n\tu8 bcc;\n} __packed;\n\nstruct digital_sensb_req {\n\tu8 cmd;\n\tu8 afi;\n\tu8 param;\n} __packed;\n\nstruct digital_sensb_res {\n\tu8 cmd;\n\tu8 nfcid0[4];\n\tu8 app_data[4];\n\tu8 proto_info[3];\n} __packed;\n\nstruct digital_attrib_req {\n\tu8 cmd;\n\tu8 nfcid0[4];\n\tu8 param1;\n\tu8 param2;\n\tu8 param3;\n\tu8 param4;\n} __packed;\n\nstruct digital_attrib_res {\n\tu8 mbli_did;\n} __packed;\n\nstruct digital_sensf_req {\n\tu8 cmd;\n\tu8 sc1;\n\tu8 sc2;\n\tu8 rc;\n\tu8 tsn;\n} __packed;\n\nstruct digital_sensf_res {\n\tu8 cmd;\n\tu8 nfcid2[8];\n\tu8 pad0[2];\n\tu8 pad1[3];\n\tu8 mrti_check;\n\tu8 mrti_update;\n\tu8 pad2;\n\tu8 rd[2];\n} __packed;\n\nstruct digital_iso15693_inv_req {\n\tu8 flags;\n\tu8 cmd;\n\tu8 mask_len;\n\tu64 mask;\n} __packed;\n\nstruct digital_iso15693_inv_res {\n\tu8 flags;\n\tu8 dsfid;\n\tu64 uid;\n} __packed;\n\nstatic int digital_in_send_sdd_req(struct nfc_digital_dev *ddev,\n\t\t\t\t   struct nfc_target *target);\n\nint digital_in_iso_dep_pull_sod(struct nfc_digital_dev *ddev,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tu8 pcb;\n\tu8 block_type;\n\n\tif (skb->len < 1)\n\t\treturn -EIO;\n\n\tpcb = *skb->data;\n\tblock_type = DIGITAL_ISO_DEP_PCB_TYPE(pcb);\n\n\t \n\tif (block_type != DIGITAL_ISO_DEP_I_BLOCK) {\n\t\tpr_err(\"ISO_DEP R-block and S-block not supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (DIGITAL_ISO_DEP_BLOCK_HAS_DID(pcb)) {\n\t\tpr_err(\"DID field in ISO_DEP PCB not supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tskb_pull(skb, 1);\n\n\treturn 0;\n}\n\nint digital_in_iso_dep_push_sod(struct nfc_digital_dev *ddev,\n\t\t\t\tstruct sk_buff *skb)\n{\n\t \n\tif (skb->len + 3 > ddev->target_fsc)\n\t\treturn -EIO;\n\n\tskb_push(skb, 1);\n\n\t*skb->data = DIGITAL_ISO_DEP_I_PCB | ddev->curr_nfc_dep_pni;\n\n\tddev->curr_nfc_dep_pni =\n\t\tDIGITAL_ISO_DEP_PNI(ddev->curr_nfc_dep_pni + 1);\n\n\treturn 0;\n}\n\nstatic void digital_in_recv_ats(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\tstruct sk_buff *resp)\n{\n\tstruct nfc_target *target = arg;\n\tu8 fsdi;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (resp->len < 2) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tfsdi = DIGITAL_ATS_FSCI(resp->data[1]);\n\tif (fsdi >= 8)\n\t\tddev->target_fsc = DIGITAL_ATS_MAX_FSC;\n\telse\n\t\tddev->target_fsc = digital_ats_fsc[fsdi];\n\n\tddev->curr_nfc_dep_pni = 0;\n\n\trc = digital_target_found(ddev, target, NFC_PROTO_ISO14443);\n\nexit:\n\tdev_kfree_skb(resp);\n\tkfree(target);\n\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n}\n\nstatic int digital_in_send_rats(struct nfc_digital_dev *ddev,\n\t\t\t\tstruct nfc_target *target)\n{\n\tint rc;\n\tstruct sk_buff *skb;\n\n\tskb = digital_skb_alloc(ddev, 2);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, DIGITAL_RATS_BYTE1);\n\tskb_put_u8(skb, DIGITAL_RATS_PARAM);\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_ats,\n\t\t\t\t target);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_in_recv_sel_res(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t    struct sk_buff *resp)\n{\n\tstruct nfc_target *target = arg;\n\tint rc;\n\tu8 sel_res;\n\tu8 nfc_proto;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (!DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\n\t\trc = digital_skb_check_crc_a(resp);\n\t\tif (rc) {\n\t\t\tPROTOCOL_ERR(\"4.4.1.3\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (resp->len != DIGITAL_SEL_RES_LEN) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tsel_res = resp->data[0];\n\n\tif (!DIGITAL_SEL_RES_NFCID1_COMPLETE(sel_res)) {\n\t\trc = digital_in_send_sdd_req(ddev, target);\n\t\tif (rc)\n\t\t\tgoto exit;\n\n\t\tgoto exit_free_skb;\n\t}\n\n\ttarget->sel_res = sel_res;\n\n\tif (DIGITAL_SEL_RES_IS_T2T(sel_res)) {\n\t\tnfc_proto = NFC_PROTO_MIFARE;\n\t} else if (DIGITAL_SEL_RES_IS_NFC_DEP(sel_res)) {\n\t\tnfc_proto = NFC_PROTO_NFC_DEP;\n\t} else if (DIGITAL_SEL_RES_IS_T4T(sel_res)) {\n\t\trc = digital_in_send_rats(ddev, target);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t\t \n\t\tgoto exit_free_skb;\n\t} else {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\n\trc = digital_target_found(ddev, target, nfc_proto);\n\nexit:\n\tkfree(target);\n\nexit_free_skb:\n\tdev_kfree_skb(resp);\n\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n}\n\nstatic int digital_in_send_sel_req(struct nfc_digital_dev *ddev,\n\t\t\t\t   struct nfc_target *target,\n\t\t\t\t   struct digital_sdd_res *sdd_res)\n{\n\tstruct sk_buff *skb;\n\tstruct digital_sel_req *sel_req;\n\tu8 sel_cmd;\n\tint rc;\n\n\tskb = digital_skb_alloc(ddev, sizeof(struct digital_sel_req));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sizeof(struct digital_sel_req));\n\tsel_req = (struct digital_sel_req *)skb->data;\n\n\tif (target->nfcid1_len <= 4)\n\t\tsel_cmd = DIGITAL_CMD_SEL_REQ_CL1;\n\telse if (target->nfcid1_len < 10)\n\t\tsel_cmd = DIGITAL_CMD_SEL_REQ_CL2;\n\telse\n\t\tsel_cmd = DIGITAL_CMD_SEL_REQ_CL3;\n\n\tsel_req->sel_cmd = sel_cmd;\n\tsel_req->b2 = 0x70;\n\tmemcpy(sel_req->nfcid1, sdd_res->nfcid1, 4);\n\tsel_req->bcc = sdd_res->bcc;\n\n\tif (DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\n\t\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\tNFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t} else {\n\t\tdigital_skb_add_crc_a(skb);\n\t}\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sel_res,\n\t\t\t\t target);\nexit:\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_in_recv_sdd_res(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t    struct sk_buff *resp)\n{\n\tstruct nfc_target *target = arg;\n\tstruct digital_sdd_res *sdd_res;\n\tint rc;\n\tu8 offset, size;\n\tu8 i, bcc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (resp->len < DIGITAL_SDD_RES_LEN) {\n\t\tPROTOCOL_ERR(\"4.7.2.8\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tsdd_res = (struct digital_sdd_res *)resp->data;\n\n\tfor (i = 0, bcc = 0; i < 4; i++)\n\t\tbcc ^= sdd_res->nfcid1[i];\n\n\tif (bcc != sdd_res->bcc) {\n\t\tPROTOCOL_ERR(\"4.7.2.6\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (sdd_res->nfcid1[0] == DIGITAL_SDD_RES_CT) {\n\t\toffset = 1;\n\t\tsize = 3;\n\t} else {\n\t\toffset = 0;\n\t\tsize = 4;\n\t}\n\n\tmemcpy(target->nfcid1 + target->nfcid1_len, sdd_res->nfcid1 + offset,\n\t       size);\n\ttarget->nfcid1_len += size;\n\n\trc = digital_in_send_sel_req(ddev, target, sdd_res);\n\nexit:\n\tdev_kfree_skb(resp);\n\n\tif (rc) {\n\t\tkfree(target);\n\t\tdigital_poll_next_tech(ddev);\n\t}\n}\n\nstatic int digital_in_send_sdd_req(struct nfc_digital_dev *ddev,\n\t\t\t\t   struct nfc_target *target)\n{\n\tint rc;\n\tstruct sk_buff *skb;\n\tu8 sel_cmd;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCA_STANDARD);\n\tif (rc)\n\t\treturn rc;\n\n\tskb = digital_skb_alloc(ddev, 2);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (target->nfcid1_len == 0)\n\t\tsel_cmd = DIGITAL_CMD_SEL_REQ_CL1;\n\telse if (target->nfcid1_len == 3)\n\t\tsel_cmd = DIGITAL_CMD_SEL_REQ_CL2;\n\telse\n\t\tsel_cmd = DIGITAL_CMD_SEL_REQ_CL3;\n\n\tskb_put_u8(skb, sel_cmd);\n\tskb_put_u8(skb, DIGITAL_SDD_REQ_SEL_PAR);\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sdd_res,\n\t\t\t\t target);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_in_recv_sens_res(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t     struct sk_buff *resp)\n{\n\tstruct nfc_target *target = NULL;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (resp->len < sizeof(u16)) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\ttarget = kzalloc(sizeof(struct nfc_target), GFP_KERNEL);\n\tif (!target) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\ttarget->sens_res = __le16_to_cpu(*(__le16 *)resp->data);\n\n\tif (!DIGITAL_SENS_RES_IS_VALID(target->sens_res)) {\n\t\tPROTOCOL_ERR(\"4.6.3.3\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (DIGITAL_SENS_RES_IS_T1T(target->sens_res))\n\t\trc = digital_target_found(ddev, target, NFC_PROTO_JEWEL);\n\telse\n\t\trc = digital_in_send_sdd_req(ddev, target);\n\nexit:\n\tdev_kfree_skb(resp);\n\n\tif (rc) {\n\t\tkfree(target);\n\t\tdigital_poll_next_tech(ddev);\n\t}\n}\n\nint digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\n\t\t\t\t     NFC_DIGITAL_RF_TECH_106A);\n\tif (rc)\n\t\treturn rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCA_SHORT);\n\tif (rc)\n\t\treturn rc;\n\n\tskb = digital_skb_alloc(ddev, 1);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, DIGITAL_CMD_SENS_REQ);\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sens_res, NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nint digital_in_recv_mifare_res(struct sk_buff *resp)\n{\n\t \n\tif (resp->len == DIGITAL_MIFARE_READ_RES_LEN + DIGITAL_CRC_LEN) {\n\t\tif (digital_skb_check_crc_a(resp)) {\n\t\t\tPROTOCOL_ERR(\"9.4.1.2\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (resp->len == 1 && resp->data[0] == DIGITAL_MIFARE_ACK_RES) {\n\t\tresp->data[0] = 0;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EIO;\n}\n\nstatic void digital_in_recv_attrib_res(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t       struct sk_buff *resp)\n{\n\tstruct nfc_target *target = arg;\n\tstruct digital_attrib_res *attrib_res;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (resp->len < sizeof(*attrib_res)) {\n\t\tPROTOCOL_ERR(\"12.6.2\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tattrib_res = (struct digital_attrib_res *)resp->data;\n\n\tif (attrib_res->mbli_did & 0x0f) {\n\t\tPROTOCOL_ERR(\"12.6.2.1\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\trc = digital_target_found(ddev, target, NFC_PROTO_ISO14443_B);\n\nexit:\n\tdev_kfree_skb(resp);\n\tkfree(target);\n\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n}\n\nstatic int digital_in_send_attrib_req(struct nfc_digital_dev *ddev,\n\t\t\t       struct nfc_target *target,\n\t\t\t       struct digital_sensb_res *sensb_res)\n{\n\tstruct digital_attrib_req *attrib_req;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = digital_skb_alloc(ddev, sizeof(*attrib_req));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tattrib_req = skb_put(skb, sizeof(*attrib_req));\n\n\tattrib_req->cmd = DIGITAL_CMD_ATTRIB_REQ;\n\tmemcpy(attrib_req->nfcid0, sensb_res->nfcid0,\n\t       sizeof(attrib_req->nfcid0));\n\tattrib_req->param1 = DIGITAL_ATTRIB_P1_TR0_DEFAULT |\n\t\t\t     DIGITAL_ATTRIB_P1_TR1_DEFAULT;\n\tattrib_req->param2 = DIGITAL_ATTRIB_P2_LISTEN_POLL_1 |\n\t\t\t     DIGITAL_ATTRIB_P2_POLL_LISTEN_1 |\n\t\t\t     DIGITAL_ATTRIB_P2_MAX_FRAME_256;\n\tattrib_req->param3 = sensb_res->proto_info[1] & 0x07;\n\tattrib_req->param4 = DIGITAL_ATTRIB_P4_DID(0);\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_attrib_res,\n\t\t\t\t target);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_in_recv_sensb_res(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t      struct sk_buff *resp)\n{\n\tstruct nfc_target *target = NULL;\n\tstruct digital_sensb_res *sensb_res;\n\tu8 fsci;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (resp->len != sizeof(*sensb_res)) {\n\t\tPROTOCOL_ERR(\"5.6.2.1\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tsensb_res = (struct digital_sensb_res *)resp->data;\n\n\tif (sensb_res->cmd != DIGITAL_CMD_SENSB_RES) {\n\t\tPROTOCOL_ERR(\"5.6.2\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (!(sensb_res->proto_info[1] & BIT(0))) {\n\t\tPROTOCOL_ERR(\"5.6.2.12\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (sensb_res->proto_info[1] & BIT(3)) {\n\t\tPROTOCOL_ERR(\"5.6.2.16\");\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tfsci = DIGITAL_SENSB_FSCI(sensb_res->proto_info[1]);\n\tif (fsci >= 8)\n\t\tddev->target_fsc = DIGITAL_ATS_MAX_FSC;\n\telse\n\t\tddev->target_fsc = digital_ats_fsc[fsci];\n\n\ttarget = kzalloc(sizeof(struct nfc_target), GFP_KERNEL);\n\tif (!target) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\trc = digital_in_send_attrib_req(ddev, target, sensb_res);\n\nexit:\n\tdev_kfree_skb(resp);\n\n\tif (rc) {\n\t\tkfree(target);\n\t\tdigital_poll_next_tech(ddev);\n\t}\n}\n\nint digital_in_send_sensb_req(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tstruct digital_sensb_req *sensb_req;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\n\t\t\t\t     NFC_DIGITAL_RF_TECH_106B);\n\tif (rc)\n\t\treturn rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCB);\n\tif (rc)\n\t\treturn rc;\n\n\tskb = digital_skb_alloc(ddev, sizeof(*sensb_req));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsensb_req = skb_put(skb, sizeof(*sensb_req));\n\n\tsensb_req->cmd = DIGITAL_CMD_SENSB_REQ;\n\tsensb_req->afi = 0x00;  \n\tsensb_req->param = DIGITAL_SENSB_N(0);\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sensb_res,\n\t\t\t\t NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_in_recv_sensf_res(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t   struct sk_buff *resp)\n{\n\tint rc;\n\tu8 proto;\n\tstruct nfc_target target;\n\tstruct digital_sensf_res *sensf_res;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (resp->len < DIGITAL_SENSF_RES_MIN_LENGTH) {\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (!DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\n\t\trc = digital_skb_check_crc_f(resp);\n\t\tif (rc) {\n\t\t\tPROTOCOL_ERR(\"6.4.1.8\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tskb_pull(resp, 1);\n\n\tmemset(&target, 0, sizeof(struct nfc_target));\n\n\tsensf_res = (struct digital_sensf_res *)resp->data;\n\n\tmemcpy(target.sensf_res, sensf_res, resp->len);\n\ttarget.sensf_res_len = resp->len;\n\n\tmemcpy(target.nfcid2, sensf_res->nfcid2, NFC_NFCID2_MAXSIZE);\n\ttarget.nfcid2_len = NFC_NFCID2_MAXSIZE;\n\n\tif (target.nfcid2[0] == DIGITAL_SENSF_NFCID2_NFC_DEP_B1 &&\n\t    target.nfcid2[1] == DIGITAL_SENSF_NFCID2_NFC_DEP_B2)\n\t\tproto = NFC_PROTO_NFC_DEP;\n\telse\n\t\tproto = NFC_PROTO_FELICA;\n\n\trc = digital_target_found(ddev, &target, proto);\n\nexit:\n\tdev_kfree_skb(resp);\n\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n}\n\nint digital_in_send_sensf_req(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tstruct digital_sensf_req *sensf_req;\n\tstruct sk_buff *skb;\n\tint rc;\n\tu8 size;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH, rf_tech);\n\tif (rc)\n\t\treturn rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCF);\n\tif (rc)\n\t\treturn rc;\n\n\tsize = sizeof(struct digital_sensf_req);\n\n\tskb = digital_skb_alloc(ddev, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, size);\n\n\tsensf_req = (struct digital_sensf_req *)skb->data;\n\tsensf_req->cmd = DIGITAL_CMD_SENSF_REQ;\n\tsensf_req->sc1 = 0xFF;\n\tsensf_req->sc2 = 0xFF;\n\tsensf_req->rc = 0;\n\tsensf_req->tsn = 0;\n\n\t*(u8 *)skb_push(skb, 1) = size + 1;\n\n\tif (!DIGITAL_DRV_CAPS_IN_CRC(ddev))\n\t\tdigital_skb_add_crc_f(skb);\n\n\trc = digital_in_send_cmd(ddev, skb, 30, digital_in_recv_sensf_res,\n\t\t\t\t NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_in_recv_iso15693_inv_res(struct nfc_digital_dev *ddev,\n\t\tvoid *arg, struct sk_buff *resp)\n{\n\tstruct digital_iso15693_inv_res *res;\n\tstruct nfc_target *target = NULL;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto out_free_skb;\n\t}\n\n\tif (resp->len != sizeof(*res)) {\n\t\trc = -EIO;\n\t\tgoto out_free_skb;\n\t}\n\n\tres = (struct digital_iso15693_inv_res *)resp->data;\n\n\tif (!DIGITAL_ISO15693_RES_IS_VALID(res->flags)) {\n\t\tPROTOCOL_ERR(\"ISO15693 - 10.3.1\");\n\t\trc = -EINVAL;\n\t\tgoto out_free_skb;\n\t}\n\n\ttarget = kzalloc(sizeof(*target), GFP_KERNEL);\n\tif (!target) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_skb;\n\t}\n\n\ttarget->is_iso15693 = 1;\n\ttarget->iso15693_dsfid = res->dsfid;\n\tmemcpy(target->iso15693_uid, &res->uid, sizeof(target->iso15693_uid));\n\n\trc = digital_target_found(ddev, target, NFC_PROTO_ISO15693);\n\n\tkfree(target);\n\nout_free_skb:\n\tdev_kfree_skb(resp);\n\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n}\n\nint digital_in_send_iso15693_inv_req(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tstruct digital_iso15693_inv_req *req;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\n\t\t\t\t     NFC_DIGITAL_RF_TECH_ISO15693);\n\tif (rc)\n\t\treturn rc;\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_ISO15693_INVENTORY);\n\tif (rc)\n\t\treturn rc;\n\n\tskb = digital_skb_alloc(ddev, sizeof(*req));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sizeof(*req) - sizeof(req->mask));  \n\treq = (struct digital_iso15693_inv_req *)skb->data;\n\n\t \n\treq->flags = DIGITAL_ISO15693_REQ_FLAG_DATA_RATE |\n\t\t     DIGITAL_ISO15693_REQ_FLAG_INVENTORY |\n\t\t     DIGITAL_ISO15693_REQ_FLAG_NB_SLOTS;\n\treq->cmd = DIGITAL_CMD_ISO15693_INVENTORY_REQ;\n\treq->mask_len = 0;\n\n\trc = digital_in_send_cmd(ddev, skb, 30,\n\t\t\t\t digital_in_recv_iso15693_inv_res, NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic int digital_tg_send_sel_res(struct nfc_digital_dev *ddev)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = digital_skb_alloc(ddev, 1);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, DIGITAL_SEL_RES_NFC_DEP);\n\n\tif (!DIGITAL_DRV_CAPS_TG_CRC(ddev))\n\t\tdigital_skb_add_crc_a(skb);\n\n\trc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCA_ANTICOL_COMPLETE);\n\tif (rc) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\trc = digital_tg_send_cmd(ddev, skb, 300, digital_tg_recv_atr_req,\n\t\t\t\t NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_tg_recv_sel_req(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t    struct sk_buff *resp)\n{\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (!DIGITAL_DRV_CAPS_TG_CRC(ddev)) {\n\t\trc = digital_skb_check_crc_a(resp);\n\t\tif (rc) {\n\t\t\tPROTOCOL_ERR(\"4.4.1.3\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\n\trc = digital_tg_send_sel_res(ddev);\n\nexit:\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n\n\tdev_kfree_skb(resp);\n}\n\nstatic int digital_tg_send_sdd_res(struct nfc_digital_dev *ddev)\n{\n\tstruct sk_buff *skb;\n\tstruct digital_sdd_res *sdd_res;\n\tint rc, i;\n\n\tskb = digital_skb_alloc(ddev, sizeof(struct digital_sdd_res));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sizeof(struct digital_sdd_res));\n\tsdd_res = (struct digital_sdd_res *)skb->data;\n\n\tsdd_res->nfcid1[0] = 0x08;\n\tget_random_bytes(sdd_res->nfcid1 + 1, 3);\n\n\tsdd_res->bcc = 0;\n\tfor (i = 0; i < 4; i++)\n\t\tsdd_res->bcc ^= sdd_res->nfcid1[i];\n\n\trc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\tNFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A);\n\tif (rc) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\trc = digital_tg_send_cmd(ddev, skb, 300, digital_tg_recv_sel_req,\n\t\t\t\t NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic void digital_tg_recv_sdd_req(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t    struct sk_buff *resp)\n{\n\tu8 *sdd_req;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tsdd_req = resp->data;\n\n\tif (resp->len < 2 || sdd_req[0] != DIGITAL_CMD_SEL_REQ_CL1 ||\n\t    sdd_req[1] != DIGITAL_SDD_REQ_SEL_PAR) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = digital_tg_send_sdd_res(ddev);\n\nexit:\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n\n\tdev_kfree_skb(resp);\n}\n\nstatic int digital_tg_send_sens_res(struct nfc_digital_dev *ddev)\n{\n\tstruct sk_buff *skb;\n\tu8 *sens_res;\n\tint rc;\n\n\tskb = digital_skb_alloc(ddev, 2);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsens_res = skb_put(skb, 2);\n\n\tsens_res[0] = (DIGITAL_SENS_RES_NFC_DEP >> 8) & 0xFF;\n\tsens_res[1] = DIGITAL_SENS_RES_NFC_DEP & 0xFF;\n\n\trc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCA_STANDARD);\n\tif (rc) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\trc = digital_tg_send_cmd(ddev, skb, 300, digital_tg_recv_sdd_req,\n\t\t\t\t NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nvoid digital_tg_recv_sens_req(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t      struct sk_buff *resp)\n{\n\tu8 sens_req;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tsens_req = resp->data[0];\n\n\tif (!resp->len || (sens_req != DIGITAL_CMD_SENS_REQ &&\n\t    sens_req != DIGITAL_CMD_ALL_REQ)) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = digital_tg_send_sens_res(ddev);\n\nexit:\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n\n\tdev_kfree_skb(resp);\n}\n\nstatic void digital_tg_recv_atr_or_sensf_req(struct nfc_digital_dev *ddev,\n\t\tvoid *arg, struct sk_buff *resp)\n{\n\tif (!IS_ERR(resp) && (resp->len >= 2) &&\n\t\t\t(resp->data[1] == DIGITAL_CMD_SENSF_REQ))\n\t\tdigital_tg_recv_sensf_req(ddev, arg, resp);\n\telse\n\t\tdigital_tg_recv_atr_req(ddev, arg, resp);\n\n\treturn;\n}\n\nstatic int digital_tg_send_sensf_res(struct nfc_digital_dev *ddev,\n\t\t\t      struct digital_sensf_req *sensf_req)\n{\n\tstruct sk_buff *skb;\n\tu8 size;\n\tint rc;\n\tstruct digital_sensf_res *sensf_res;\n\n\tsize = sizeof(struct digital_sensf_res);\n\n\tif (sensf_req->rc == DIGITAL_SENSF_REQ_RC_NONE)\n\t\tsize -= sizeof(sensf_res->rd);\n\n\tskb = digital_skb_alloc(ddev, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, size);\n\n\tsensf_res = (struct digital_sensf_res *)skb->data;\n\n\tmemset(sensf_res, 0, size);\n\n\tsensf_res->cmd = DIGITAL_CMD_SENSF_RES;\n\tsensf_res->nfcid2[0] = DIGITAL_SENSF_NFCID2_NFC_DEP_B1;\n\tsensf_res->nfcid2[1] = DIGITAL_SENSF_NFCID2_NFC_DEP_B2;\n\tget_random_bytes(&sensf_res->nfcid2[2], 6);\n\n\tswitch (sensf_req->rc) {\n\tcase DIGITAL_SENSF_REQ_RC_SC:\n\t\tsensf_res->rd[0] = sensf_req->sc1;\n\t\tsensf_res->rd[1] = sensf_req->sc2;\n\t\tbreak;\n\tcase DIGITAL_SENSF_REQ_RC_AP:\n\t\tsensf_res->rd[0] = DIGITAL_SENSF_RES_RD_AP_B1;\n\t\tsensf_res->rd[1] = DIGITAL_SENSF_RES_RD_AP_B2;\n\t\tbreak;\n\t}\n\n\t*(u8 *)skb_push(skb, sizeof(u8)) = size + 1;\n\n\tif (!DIGITAL_DRV_CAPS_TG_CRC(ddev))\n\t\tdigital_skb_add_crc_f(skb);\n\n\trc = digital_tg_send_cmd(ddev, skb, 300,\n\t\t\t\t digital_tg_recv_atr_or_sensf_req, NULL);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nvoid digital_tg_recv_sensf_req(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t       struct sk_buff *resp)\n{\n\tstruct digital_sensf_req *sensf_req;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto exit;\n\t}\n\n\tif (!DIGITAL_DRV_CAPS_TG_CRC(ddev)) {\n\t\trc = digital_skb_check_crc_f(resp);\n\t\tif (rc) {\n\t\t\tPROTOCOL_ERR(\"6.4.1.8\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (resp->len != sizeof(struct digital_sensf_req) + 1) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tskb_pull(resp, 1);\n\tsensf_req = (struct digital_sensf_req *)resp->data;\n\n\tif (sensf_req->cmd != DIGITAL_CMD_SENSF_REQ) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = digital_tg_send_sensf_res(ddev, sensf_req);\n\nexit:\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n\n\tdev_kfree_skb(resp);\n}\n\nstatic int digital_tg_config_nfca(struct nfc_digital_dev *ddev)\n{\n\tint rc;\n\n\trc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\n\t\t\t\t     NFC_DIGITAL_RF_TECH_106A);\n\tif (rc)\n\t\treturn rc;\n\n\treturn digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t       NFC_DIGITAL_FRAMING_NFCA_NFC_DEP);\n}\n\nint digital_tg_listen_nfca(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tint rc;\n\n\trc = digital_tg_config_nfca(ddev);\n\tif (rc)\n\t\treturn rc;\n\n\treturn digital_tg_listen(ddev, 300, digital_tg_recv_sens_req, NULL);\n}\n\nstatic int digital_tg_config_nfcf(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tint rc;\n\n\trc = digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH, rf_tech);\n\tif (rc)\n\t\treturn rc;\n\n\treturn digital_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t       NFC_DIGITAL_FRAMING_NFCF_NFC_DEP);\n}\n\nint digital_tg_listen_nfcf(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tint rc;\n\n\trc = digital_tg_config_nfcf(ddev, rf_tech);\n\tif (rc)\n\t\treturn rc;\n\n\treturn digital_tg_listen(ddev, 300, digital_tg_recv_sensf_req, NULL);\n}\n\nvoid digital_tg_recv_md_req(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t    struct sk_buff *resp)\n{\n\tu8 rf_tech;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\tresp = NULL;\n\t\tgoto exit_free_skb;\n\t}\n\n\trc = ddev->ops->tg_get_rf_tech(ddev, &rf_tech);\n\tif (rc)\n\t\tgoto exit_free_skb;\n\n\tswitch (rf_tech) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\trc = digital_tg_config_nfca(ddev);\n\t\tif (rc)\n\t\t\tgoto exit_free_skb;\n\t\tdigital_tg_recv_sens_req(ddev, arg, resp);\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_212F:\n\tcase NFC_DIGITAL_RF_TECH_424F:\n\t\trc = digital_tg_config_nfcf(ddev, rf_tech);\n\t\tif (rc)\n\t\t\tgoto exit_free_skb;\n\t\tdigital_tg_recv_sensf_req(ddev, arg, resp);\n\t\tbreak;\n\tdefault:\n\t\tgoto exit_free_skb;\n\t}\n\n\treturn;\n\nexit_free_skb:\n\tdigital_poll_next_tech(ddev);\n\tdev_kfree_skb(resp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}