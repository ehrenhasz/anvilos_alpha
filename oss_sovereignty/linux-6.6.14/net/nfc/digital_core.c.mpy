{
  "module_name": "digital_core.c",
  "hash_id": "30c01a1a04cd09511714f6b5d5a72dfd5c51b132a222faf426f341e7f6e4ac41",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/digital_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"digital: %s: \" fmt, __func__\n\n#include <linux/module.h>\n\n#include \"digital.h\"\n\n#define DIGITAL_PROTO_NFCA_RF_TECH \\\n\t(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK | \\\n\tNFC_PROTO_NFC_DEP_MASK | NFC_PROTO_ISO14443_MASK)\n\n#define DIGITAL_PROTO_NFCB_RF_TECH\tNFC_PROTO_ISO14443_B_MASK\n\n#define DIGITAL_PROTO_NFCF_RF_TECH \\\n\t(NFC_PROTO_FELICA_MASK | NFC_PROTO_NFC_DEP_MASK)\n\n#define DIGITAL_PROTO_ISO15693_RF_TECH\tNFC_PROTO_ISO15693_MASK\n\n \n#define DIGITAL_POLL_INTERVAL 10\n\nstruct digital_cmd {\n\tstruct list_head queue;\n\n\tu8 type;\n\tu8 pending;\n\n\tu16 timeout;\n\tstruct sk_buff *req;\n\tstruct sk_buff *resp;\n\tstruct digital_tg_mdaa_params *mdaa_params;\n\n\tnfc_digital_cmd_complete_t cmd_cb;\n\tvoid *cb_context;\n};\n\nstruct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,\n\t\t\t\t  unsigned int len)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len + ddev->tx_headroom + ddev->tx_tailroom,\n\t\t\tGFP_KERNEL);\n\tif (skb)\n\t\tskb_reserve(skb, ddev->tx_headroom);\n\n\treturn skb;\n}\n\nvoid digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,\n\t\t\t u8 bitwise_inv, u8 msb_first)\n{\n\tu16 crc;\n\n\tcrc = crc_func(init, skb->data, skb->len);\n\n\tif (bitwise_inv)\n\t\tcrc = ~crc;\n\n\tif (msb_first)\n\t\tcrc = __fswab16(crc);\n\n\tskb_put_u8(skb, crc & 0xFF);\n\tskb_put_u8(skb, (crc >> 8) & 0xFF);\n}\n\nint digital_skb_check_crc(struct sk_buff *skb, crc_func_t crc_func,\n\t\t\t  u16 crc_init, u8 bitwise_inv, u8 msb_first)\n{\n\tint rc;\n\tu16 crc;\n\n\tif (skb->len <= 2)\n\t\treturn -EIO;\n\n\tcrc = crc_func(crc_init, skb->data, skb->len - 2);\n\n\tif (bitwise_inv)\n\t\tcrc = ~crc;\n\n\tif (msb_first)\n\t\tcrc = __swab16(crc);\n\n\trc = (skb->data[skb->len - 2] - (crc & 0xFF)) +\n\t     (skb->data[skb->len - 1] - ((crc >> 8) & 0xFF));\n\n\tif (rc)\n\t\treturn -EIO;\n\n\tskb_trim(skb, skb->len - 2);\n\n\treturn 0;\n}\n\nstatic inline void digital_switch_rf(struct nfc_digital_dev *ddev, bool on)\n{\n\tddev->ops->switch_rf(ddev, on);\n}\n\nstatic inline void digital_abort_cmd(struct nfc_digital_dev *ddev)\n{\n\tddev->ops->abort_cmd(ddev);\n}\n\nstatic void digital_wq_cmd_complete(struct work_struct *work)\n{\n\tstruct digital_cmd *cmd;\n\tstruct nfc_digital_dev *ddev = container_of(work,\n\t\t\t\t\t\t    struct nfc_digital_dev,\n\t\t\t\t\t\t    cmd_complete_work);\n\n\tmutex_lock(&ddev->cmd_lock);\n\n\tcmd = list_first_entry_or_null(&ddev->cmd_queue, struct digital_cmd,\n\t\t\t\t       queue);\n\tif (!cmd) {\n\t\tmutex_unlock(&ddev->cmd_lock);\n\t\treturn;\n\t}\n\n\tlist_del(&cmd->queue);\n\n\tmutex_unlock(&ddev->cmd_lock);\n\n\tif (!IS_ERR(cmd->resp))\n\t\tprint_hex_dump_debug(\"DIGITAL RX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t\t     cmd->resp->data, cmd->resp->len, false);\n\n\tcmd->cmd_cb(ddev, cmd->cb_context, cmd->resp);\n\n\tkfree(cmd->mdaa_params);\n\tkfree(cmd);\n\n\tschedule_work(&ddev->cmd_work);\n}\n\nstatic void digital_send_cmd_complete(struct nfc_digital_dev *ddev,\n\t\t\t\t      void *arg, struct sk_buff *resp)\n{\n\tstruct digital_cmd *cmd = arg;\n\n\tcmd->resp = resp;\n\n\tschedule_work(&ddev->cmd_complete_work);\n}\n\nstatic void digital_wq_cmd(struct work_struct *work)\n{\n\tint rc;\n\tstruct digital_cmd *cmd;\n\tstruct digital_tg_mdaa_params *params;\n\tstruct nfc_digital_dev *ddev = container_of(work,\n\t\t\t\t\t\t    struct nfc_digital_dev,\n\t\t\t\t\t\t    cmd_work);\n\n\tmutex_lock(&ddev->cmd_lock);\n\n\tcmd = list_first_entry_or_null(&ddev->cmd_queue, struct digital_cmd,\n\t\t\t\t       queue);\n\tif (!cmd || cmd->pending) {\n\t\tmutex_unlock(&ddev->cmd_lock);\n\t\treturn;\n\t}\n\n\tcmd->pending = 1;\n\n\tmutex_unlock(&ddev->cmd_lock);\n\n\tif (cmd->req)\n\t\tprint_hex_dump_debug(\"DIGITAL TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t\t     cmd->req->data, cmd->req->len, false);\n\n\tswitch (cmd->type) {\n\tcase DIGITAL_CMD_IN_SEND:\n\t\trc = ddev->ops->in_send_cmd(ddev, cmd->req, cmd->timeout,\n\t\t\t\t\t    digital_send_cmd_complete, cmd);\n\t\tbreak;\n\n\tcase DIGITAL_CMD_TG_SEND:\n\t\trc = ddev->ops->tg_send_cmd(ddev, cmd->req, cmd->timeout,\n\t\t\t\t\t    digital_send_cmd_complete, cmd);\n\t\tbreak;\n\n\tcase DIGITAL_CMD_TG_LISTEN:\n\t\trc = ddev->ops->tg_listen(ddev, cmd->timeout,\n\t\t\t\t\t  digital_send_cmd_complete, cmd);\n\t\tbreak;\n\n\tcase DIGITAL_CMD_TG_LISTEN_MDAA:\n\t\tparams = cmd->mdaa_params;\n\n\t\trc = ddev->ops->tg_listen_mdaa(ddev, params, cmd->timeout,\n\t\t\t\t\t       digital_send_cmd_complete, cmd);\n\t\tbreak;\n\n\tcase DIGITAL_CMD_TG_LISTEN_MD:\n\t\trc = ddev->ops->tg_listen_md(ddev, cmd->timeout,\n\t\t\t\t\t       digital_send_cmd_complete, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unknown cmd type %d\\n\", cmd->type);\n\t\treturn;\n\t}\n\n\tif (!rc)\n\t\treturn;\n\n\tpr_err(\"in_send_command returned err %d\\n\", rc);\n\n\tmutex_lock(&ddev->cmd_lock);\n\tlist_del(&cmd->queue);\n\tmutex_unlock(&ddev->cmd_lock);\n\n\tkfree_skb(cmd->req);\n\tkfree(cmd->mdaa_params);\n\tkfree(cmd);\n\n\tschedule_work(&ddev->cmd_work);\n}\n\nint digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,\n\t\t     struct sk_buff *skb, struct digital_tg_mdaa_params *params,\n\t\t     u16 timeout, nfc_digital_cmd_complete_t cmd_cb,\n\t\t     void *cb_context)\n{\n\tstruct digital_cmd *cmd;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->type = cmd_type;\n\tcmd->timeout = timeout;\n\tcmd->req = skb;\n\tcmd->mdaa_params = params;\n\tcmd->cmd_cb = cmd_cb;\n\tcmd->cb_context = cb_context;\n\tINIT_LIST_HEAD(&cmd->queue);\n\n\tmutex_lock(&ddev->cmd_lock);\n\tlist_add_tail(&cmd->queue, &ddev->cmd_queue);\n\tmutex_unlock(&ddev->cmd_lock);\n\n\tschedule_work(&ddev->cmd_work);\n\n\treturn 0;\n}\n\nint digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)\n{\n\tint rc;\n\n\trc = ddev->ops->in_configure_hw(ddev, type, param);\n\tif (rc)\n\t\tpr_err(\"in_configure_hw failed: %d\\n\", rc);\n\n\treturn rc;\n}\n\nint digital_tg_configure_hw(struct nfc_digital_dev *ddev, int type, int param)\n{\n\tint rc;\n\n\trc = ddev->ops->tg_configure_hw(ddev, type, param);\n\tif (rc)\n\t\tpr_err(\"tg_configure_hw failed: %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int digital_tg_listen_mdaa(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\tstruct digital_tg_mdaa_params *params;\n\tint rc;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tparams->sens_res = DIGITAL_SENS_RES_NFC_DEP;\n\tget_random_bytes(params->nfcid1, sizeof(params->nfcid1));\n\tparams->sel_res = DIGITAL_SEL_RES_NFC_DEP;\n\n\tparams->nfcid2[0] = DIGITAL_SENSF_NFCID2_NFC_DEP_B1;\n\tparams->nfcid2[1] = DIGITAL_SENSF_NFCID2_NFC_DEP_B2;\n\tget_random_bytes(params->nfcid2 + 2, NFC_NFCID2_MAXSIZE - 2);\n\tparams->sc = DIGITAL_SENSF_FELICA_SC;\n\n\trc = digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN_MDAA, NULL, params,\n\t\t\t      500, digital_tg_recv_atr_req, NULL);\n\tif (rc)\n\t\tkfree(params);\n\n\treturn rc;\n}\n\nstatic int digital_tg_listen_md(struct nfc_digital_dev *ddev, u8 rf_tech)\n{\n\treturn digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN_MD, NULL, NULL, 500,\n\t\t\t\tdigital_tg_recv_md_req, NULL);\n}\n\nint digital_target_found(struct nfc_digital_dev *ddev,\n\t\t\t struct nfc_target *target, u8 protocol)\n{\n\tint rc;\n\tu8 framing;\n\tu8 rf_tech;\n\tu8 poll_tech_count;\n\tint (*check_crc)(struct sk_buff *skb);\n\tvoid (*add_crc)(struct sk_buff *skb);\n\n\trf_tech = ddev->poll_techs[ddev->poll_tech_index].rf_tech;\n\n\tswitch (protocol) {\n\tcase NFC_PROTO_JEWEL:\n\t\tframing = NFC_DIGITAL_FRAMING_NFCA_T1T;\n\t\tcheck_crc = digital_skb_check_crc_b;\n\t\tadd_crc = digital_skb_add_crc_b;\n\t\tbreak;\n\n\tcase NFC_PROTO_MIFARE:\n\t\tframing = NFC_DIGITAL_FRAMING_NFCA_T2T;\n\t\tcheck_crc = digital_skb_check_crc_a;\n\t\tadd_crc = digital_skb_add_crc_a;\n\t\tbreak;\n\n\tcase NFC_PROTO_FELICA:\n\t\tframing = NFC_DIGITAL_FRAMING_NFCF_T3T;\n\t\tcheck_crc = digital_skb_check_crc_f;\n\t\tadd_crc = digital_skb_add_crc_f;\n\t\tbreak;\n\n\tcase NFC_PROTO_NFC_DEP:\n\t\tif (rf_tech == NFC_DIGITAL_RF_TECH_106A) {\n\t\t\tframing = NFC_DIGITAL_FRAMING_NFCA_NFC_DEP;\n\t\t\tcheck_crc = digital_skb_check_crc_a;\n\t\t\tadd_crc = digital_skb_add_crc_a;\n\t\t} else {\n\t\t\tframing = NFC_DIGITAL_FRAMING_NFCF_NFC_DEP;\n\t\t\tcheck_crc = digital_skb_check_crc_f;\n\t\t\tadd_crc = digital_skb_add_crc_f;\n\t\t}\n\t\tbreak;\n\n\tcase NFC_PROTO_ISO15693:\n\t\tframing = NFC_DIGITAL_FRAMING_ISO15693_T5T;\n\t\tcheck_crc = digital_skb_check_crc_b;\n\t\tadd_crc = digital_skb_add_crc_b;\n\t\tbreak;\n\n\tcase NFC_PROTO_ISO14443:\n\t\tframing = NFC_DIGITAL_FRAMING_NFCA_T4T;\n\t\tcheck_crc = digital_skb_check_crc_a;\n\t\tadd_crc = digital_skb_add_crc_a;\n\t\tbreak;\n\n\tcase NFC_PROTO_ISO14443_B:\n\t\tframing = NFC_DIGITAL_FRAMING_NFCB_T4T;\n\t\tcheck_crc = digital_skb_check_crc_b;\n\t\tadd_crc = digital_skb_add_crc_b;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Invalid protocol %d\\n\", protocol);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"rf_tech=%d, protocol=%d\\n\", rf_tech, protocol);\n\n\tddev->curr_rf_tech = rf_tech;\n\n\tif (DIGITAL_DRV_CAPS_IN_CRC(ddev)) {\n\t\tddev->skb_add_crc = digital_skb_add_crc_none;\n\t\tddev->skb_check_crc = digital_skb_check_crc_none;\n\t} else {\n\t\tddev->skb_add_crc = add_crc;\n\t\tddev->skb_check_crc = check_crc;\n\t}\n\n\trc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING, framing);\n\tif (rc)\n\t\treturn rc;\n\n\ttarget->supported_protocols = (1 << protocol);\n\n\tpoll_tech_count = ddev->poll_tech_count;\n\tddev->poll_tech_count = 0;\n\n\trc = nfc_targets_found(ddev->nfc_dev, target, 1);\n\tif (rc) {\n\t\tddev->poll_tech_count = poll_tech_count;\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nvoid digital_poll_next_tech(struct nfc_digital_dev *ddev)\n{\n\tu8 rand_mod;\n\n\tdigital_switch_rf(ddev, 0);\n\n\tmutex_lock(&ddev->poll_lock);\n\n\tif (!ddev->poll_tech_count) {\n\t\tmutex_unlock(&ddev->poll_lock);\n\t\treturn;\n\t}\n\n\tget_random_bytes(&rand_mod, sizeof(rand_mod));\n\tddev->poll_tech_index = rand_mod % ddev->poll_tech_count;\n\n\tmutex_unlock(&ddev->poll_lock);\n\n\tschedule_delayed_work(&ddev->poll_work,\n\t\t\t      msecs_to_jiffies(DIGITAL_POLL_INTERVAL));\n}\n\nstatic void digital_wq_poll(struct work_struct *work)\n{\n\tint rc;\n\tstruct digital_poll_tech *poll_tech;\n\tstruct nfc_digital_dev *ddev = container_of(work,\n\t\t\t\t\t\t    struct nfc_digital_dev,\n\t\t\t\t\t\t    poll_work.work);\n\tmutex_lock(&ddev->poll_lock);\n\n\tif (!ddev->poll_tech_count) {\n\t\tmutex_unlock(&ddev->poll_lock);\n\t\treturn;\n\t}\n\n\tpoll_tech = &ddev->poll_techs[ddev->poll_tech_index];\n\n\tmutex_unlock(&ddev->poll_lock);\n\n\trc = poll_tech->poll_func(ddev, poll_tech->rf_tech);\n\tif (rc)\n\t\tdigital_poll_next_tech(ddev);\n}\n\nstatic void digital_add_poll_tech(struct nfc_digital_dev *ddev, u8 rf_tech,\n\t\t\t\t  digital_poll_t poll_func)\n{\n\tstruct digital_poll_tech *poll_tech;\n\n\tif (ddev->poll_tech_count >= NFC_DIGITAL_POLL_MODE_COUNT_MAX)\n\t\treturn;\n\n\tpoll_tech = &ddev->poll_techs[ddev->poll_tech_count++];\n\n\tpoll_tech->rf_tech = rf_tech;\n\tpoll_tech->poll_func = poll_func;\n}\n\n \nstatic int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,\n\t\t\t      __u32 tm_protocols)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\tu32 matching_im_protocols, matching_tm_protocols;\n\n\tpr_debug(\"protocols: im 0x%x, tm 0x%x, supported 0x%x\\n\", im_protocols,\n\t\t tm_protocols, ddev->protocols);\n\n\tmatching_im_protocols = ddev->protocols & im_protocols;\n\tmatching_tm_protocols = ddev->protocols & tm_protocols;\n\n\tif (!matching_im_protocols && !matching_tm_protocols) {\n\t\tpr_err(\"Unknown protocol\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ddev->poll_tech_count) {\n\t\tpr_err(\"Already polling\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (ddev->curr_protocol) {\n\t\tpr_err(\"A target is already active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tddev->poll_tech_count = 0;\n\tddev->poll_tech_index = 0;\n\n\tif (matching_im_protocols & DIGITAL_PROTO_NFCA_RF_TECH)\n\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,\n\t\t\t\t      digital_in_send_sens_req);\n\n\tif (matching_im_protocols & DIGITAL_PROTO_NFCB_RF_TECH)\n\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106B,\n\t\t\t\t      digital_in_send_sensb_req);\n\n\tif (matching_im_protocols & DIGITAL_PROTO_NFCF_RF_TECH) {\n\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,\n\t\t\t\t      digital_in_send_sensf_req);\n\n\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_424F,\n\t\t\t\t      digital_in_send_sensf_req);\n\t}\n\n\tif (matching_im_protocols & DIGITAL_PROTO_ISO15693_RF_TECH)\n\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_ISO15693,\n\t\t\t\t      digital_in_send_iso15693_inv_req);\n\n\tif (matching_tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tif (ddev->ops->tg_listen_mdaa) {\n\t\t\tdigital_add_poll_tech(ddev, 0,\n\t\t\t\t\t      digital_tg_listen_mdaa);\n\t\t} else if (ddev->ops->tg_listen_md) {\n\t\t\tdigital_add_poll_tech(ddev, 0,\n\t\t\t\t\t      digital_tg_listen_md);\n\t\t} else {\n\t\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,\n\t\t\t\t\t      digital_tg_listen_nfca);\n\n\t\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,\n\t\t\t\t\t      digital_tg_listen_nfcf);\n\n\t\t\tdigital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_424F,\n\t\t\t\t\t      digital_tg_listen_nfcf);\n\t\t}\n\t}\n\n\tif (!ddev->poll_tech_count) {\n\t\tpr_err(\"Unsupported protocols: im=0x%x, tm=0x%x\\n\",\n\t\t       matching_im_protocols, matching_tm_protocols);\n\t\treturn -EINVAL;\n\t}\n\n\tschedule_delayed_work(&ddev->poll_work, 0);\n\n\treturn 0;\n}\n\nstatic void digital_stop_poll(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\n\tmutex_lock(&ddev->poll_lock);\n\n\tif (!ddev->poll_tech_count) {\n\t\tpr_err(\"Polling operation was not running\\n\");\n\t\tmutex_unlock(&ddev->poll_lock);\n\t\treturn;\n\t}\n\n\tddev->poll_tech_count = 0;\n\n\tmutex_unlock(&ddev->poll_lock);\n\n\tcancel_delayed_work_sync(&ddev->poll_work);\n\n\tdigital_abort_cmd(ddev);\n}\n\nstatic int digital_dev_up(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\n\tdigital_switch_rf(ddev, 1);\n\n\treturn 0;\n}\n\nstatic int digital_dev_down(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\n\tdigital_switch_rf(ddev, 0);\n\n\treturn 0;\n}\n\nstatic int digital_dep_link_up(struct nfc_dev *nfc_dev,\n\t\t\t       struct nfc_target *target,\n\t\t\t       __u8 comm_mode, __u8 *gb, size_t gb_len)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\trc = digital_in_send_atr_req(ddev, target, comm_mode, gb, gb_len);\n\n\tif (!rc)\n\t\tddev->curr_protocol = NFC_PROTO_NFC_DEP;\n\n\treturn rc;\n}\n\nstatic int digital_dep_link_down(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\n\tdigital_abort_cmd(ddev);\n\n\tddev->curr_protocol = 0;\n\n\treturn 0;\n}\n\nstatic int digital_activate_target(struct nfc_dev *nfc_dev,\n\t\t\t\t   struct nfc_target *target, __u32 protocol)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\n\tif (ddev->poll_tech_count) {\n\t\tpr_err(\"Can't activate a target while polling\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (ddev->curr_protocol) {\n\t\tpr_err(\"A target is already active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tddev->curr_protocol = protocol;\n\n\treturn 0;\n}\n\nstatic void digital_deactivate_target(struct nfc_dev *nfc_dev,\n\t\t\t\t      struct nfc_target *target,\n\t\t\t\t      u8 mode)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\n\tif (!ddev->curr_protocol) {\n\t\tpr_err(\"No active target\\n\");\n\t\treturn;\n\t}\n\n\tdigital_abort_cmd(ddev);\n\tddev->curr_protocol = 0;\n}\n\nstatic int digital_tg_send(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(dev);\n\n\treturn digital_tg_send_dep_res(ddev, skb);\n}\n\nstatic void digital_in_send_complete(struct nfc_digital_dev *ddev, void *arg,\n\t\t\t\t     struct sk_buff *resp)\n{\n\tstruct digital_data_exch *data_exch = arg;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tresp = NULL;\n\t\tgoto done;\n\t}\n\n\tif (ddev->curr_protocol == NFC_PROTO_MIFARE) {\n\t\trc = digital_in_recv_mifare_res(resp);\n\t\t \n\t\tgoto done;\n\t}\n\n\tif ((ddev->curr_protocol == NFC_PROTO_ISO14443) ||\n\t    (ddev->curr_protocol == NFC_PROTO_ISO14443_B)) {\n\t\trc = digital_in_iso_dep_pull_sod(ddev, resp);\n\t\tif (rc)\n\t\t\tgoto done;\n\t}\n\n\trc = ddev->skb_check_crc(resp);\n\ndone:\n\tif (rc) {\n\t\tkfree_skb(resp);\n\t\tresp = NULL;\n\t}\n\n\tdata_exch->cb(data_exch->cb_context, resp, rc);\n\n\tkfree(data_exch);\n}\n\nstatic int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,\n\t\t\t   struct sk_buff *skb, data_exchange_cb_t cb,\n\t\t\t   void *cb_context)\n{\n\tstruct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);\n\tstruct digital_data_exch *data_exch;\n\tint rc;\n\n\tdata_exch = kzalloc(sizeof(*data_exch), GFP_KERNEL);\n\tif (!data_exch)\n\t\treturn -ENOMEM;\n\n\tdata_exch->cb = cb;\n\tdata_exch->cb_context = cb_context;\n\n\tif (ddev->curr_protocol == NFC_PROTO_NFC_DEP) {\n\t\trc = digital_in_send_dep_req(ddev, target, skb, data_exch);\n\t\tgoto exit;\n\t}\n\n\tif ((ddev->curr_protocol == NFC_PROTO_ISO14443) ||\n\t    (ddev->curr_protocol == NFC_PROTO_ISO14443_B)) {\n\t\trc = digital_in_iso_dep_push_sod(ddev, skb);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t}\n\n\tddev->skb_add_crc(skb);\n\n\trc = digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,\n\t\t\t\t data_exch);\n\nexit:\n\tif (rc)\n\t\tkfree(data_exch);\n\n\treturn rc;\n}\n\nstatic const struct nfc_ops digital_nfc_ops = {\n\t.dev_up = digital_dev_up,\n\t.dev_down = digital_dev_down,\n\t.start_poll = digital_start_poll,\n\t.stop_poll = digital_stop_poll,\n\t.dep_link_up = digital_dep_link_up,\n\t.dep_link_down = digital_dep_link_down,\n\t.activate_target = digital_activate_target,\n\t.deactivate_target = digital_deactivate_target,\n\t.tm_send = digital_tg_send,\n\t.im_transceive = digital_in_send,\n};\n\nstruct nfc_digital_dev *nfc_digital_allocate_device(const struct nfc_digital_ops *ops,\n\t\t\t\t\t    __u32 supported_protocols,\n\t\t\t\t\t    __u32 driver_capabilities,\n\t\t\t\t\t    int tx_headroom, int tx_tailroom)\n{\n\tstruct nfc_digital_dev *ddev;\n\n\tif (!ops->in_configure_hw || !ops->in_send_cmd || !ops->tg_listen ||\n\t    !ops->tg_configure_hw || !ops->tg_send_cmd || !ops->abort_cmd ||\n\t    !ops->switch_rf || (ops->tg_listen_md && !ops->tg_get_rf_tech))\n\t\treturn NULL;\n\n\tddev = kzalloc(sizeof(*ddev), GFP_KERNEL);\n\tif (!ddev)\n\t\treturn NULL;\n\n\tddev->driver_capabilities = driver_capabilities;\n\tddev->ops = ops;\n\n\tmutex_init(&ddev->cmd_lock);\n\tINIT_LIST_HEAD(&ddev->cmd_queue);\n\n\tINIT_WORK(&ddev->cmd_work, digital_wq_cmd);\n\tINIT_WORK(&ddev->cmd_complete_work, digital_wq_cmd_complete);\n\n\tmutex_init(&ddev->poll_lock);\n\tINIT_DELAYED_WORK(&ddev->poll_work, digital_wq_poll);\n\n\tif (supported_protocols & NFC_PROTO_JEWEL_MASK)\n\t\tddev->protocols |= NFC_PROTO_JEWEL_MASK;\n\tif (supported_protocols & NFC_PROTO_MIFARE_MASK)\n\t\tddev->protocols |= NFC_PROTO_MIFARE_MASK;\n\tif (supported_protocols & NFC_PROTO_FELICA_MASK)\n\t\tddev->protocols |= NFC_PROTO_FELICA_MASK;\n\tif (supported_protocols & NFC_PROTO_NFC_DEP_MASK)\n\t\tddev->protocols |= NFC_PROTO_NFC_DEP_MASK;\n\tif (supported_protocols & NFC_PROTO_ISO15693_MASK)\n\t\tddev->protocols |= NFC_PROTO_ISO15693_MASK;\n\tif (supported_protocols & NFC_PROTO_ISO14443_MASK)\n\t\tddev->protocols |= NFC_PROTO_ISO14443_MASK;\n\tif (supported_protocols & NFC_PROTO_ISO14443_B_MASK)\n\t\tddev->protocols |= NFC_PROTO_ISO14443_B_MASK;\n\n\tddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;\n\tddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;\n\n\tddev->nfc_dev = nfc_allocate_device(&digital_nfc_ops, ddev->protocols,\n\t\t\t\t\t    ddev->tx_headroom,\n\t\t\t\t\t    ddev->tx_tailroom);\n\tif (!ddev->nfc_dev) {\n\t\tpr_err(\"nfc_allocate_device failed\\n\");\n\t\tgoto free_dev;\n\t}\n\n\tnfc_set_drvdata(ddev->nfc_dev, ddev);\n\n\treturn ddev;\n\nfree_dev:\n\tkfree(ddev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nfc_digital_allocate_device);\n\nvoid nfc_digital_free_device(struct nfc_digital_dev *ddev)\n{\n\tnfc_free_device(ddev->nfc_dev);\n\tkfree(ddev);\n}\nEXPORT_SYMBOL(nfc_digital_free_device);\n\nint nfc_digital_register_device(struct nfc_digital_dev *ddev)\n{\n\treturn nfc_register_device(ddev->nfc_dev);\n}\nEXPORT_SYMBOL(nfc_digital_register_device);\n\nvoid nfc_digital_unregister_device(struct nfc_digital_dev *ddev)\n{\n\tstruct digital_cmd *cmd, *n;\n\n\tnfc_unregister_device(ddev->nfc_dev);\n\n\tmutex_lock(&ddev->poll_lock);\n\tddev->poll_tech_count = 0;\n\tmutex_unlock(&ddev->poll_lock);\n\n\tcancel_delayed_work_sync(&ddev->poll_work);\n\tcancel_work_sync(&ddev->cmd_work);\n\tcancel_work_sync(&ddev->cmd_complete_work);\n\n\tlist_for_each_entry_safe(cmd, n, &ddev->cmd_queue, queue) {\n\t\tlist_del(&cmd->queue);\n\n\t\t \n\t\tif (cmd->cmd_cb)\n\t\t\tcmd->cmd_cb(ddev, cmd->cb_context, ERR_PTR(-ENODEV));\n\n\t\tkfree(cmd->mdaa_params);\n\t\tkfree(cmd);\n\t}\n}\nEXPORT_SYMBOL(nfc_digital_unregister_device);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}