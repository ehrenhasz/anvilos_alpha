{
  "module_name": "rsp.c",
  "hash_id": "5c8c63da78753f0279113bebecf385e813fc1a1523df0e0a7169ae2219908b5e",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/rsp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n\n#include \"../nfc.h\"\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n\n \n\nstatic void nci_core_reset_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n{\n\tconst struct nci_core_reset_rsp *rsp = (void *)skb->data;\n\n\tpr_debug(\"status 0x%x\\n\", rsp->status);\n\n\t \n\tif (skb->len != 1) {\n\t\tif (rsp->status == NCI_STATUS_OK) {\n\t\t\tndev->nci_ver = rsp->nci_ver;\n\t\t\tpr_debug(\"nci_ver 0x%x, config_status 0x%x\\n\",\n\t\t\t\t rsp->nci_ver, rsp->config_status);\n\t\t}\n\n\t\tnci_req_complete(ndev, rsp->status);\n\t}\n}\n\nstatic u8 nci_core_init_rsp_packet_v1(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n{\n\tconst struct nci_core_init_rsp_1 *rsp_1 = (void *)skb->data;\n\tconst struct nci_core_init_rsp_2 *rsp_2;\n\n\tpr_debug(\"status 0x%x\\n\", rsp_1->status);\n\n\tif (rsp_1->status != NCI_STATUS_OK)\n\t\treturn rsp_1->status;\n\n\tndev->nfcc_features = __le32_to_cpu(rsp_1->nfcc_features);\n\tndev->num_supported_rf_interfaces = rsp_1->num_supported_rf_interfaces;\n\n\tndev->num_supported_rf_interfaces =\n\t\tmin((int)ndev->num_supported_rf_interfaces,\n\t\t    NCI_MAX_SUPPORTED_RF_INTERFACES);\n\n\tmemcpy(ndev->supported_rf_interfaces,\n\t       rsp_1->supported_rf_interfaces,\n\t       ndev->num_supported_rf_interfaces);\n\n\trsp_2 = (void *) (skb->data + 6 + rsp_1->num_supported_rf_interfaces);\n\n\tndev->max_logical_connections = rsp_2->max_logical_connections;\n\tndev->max_routing_table_size =\n\t\t__le16_to_cpu(rsp_2->max_routing_table_size);\n\tndev->max_ctrl_pkt_payload_len =\n\t\trsp_2->max_ctrl_pkt_payload_len;\n\tndev->max_size_for_large_params =\n\t\t__le16_to_cpu(rsp_2->max_size_for_large_params);\n\tndev->manufact_id =\n\t\trsp_2->manufact_id;\n\tndev->manufact_specific_info =\n\t\t__le32_to_cpu(rsp_2->manufact_specific_info);\n\n\treturn NCI_STATUS_OK;\n}\n\nstatic u8 nci_core_init_rsp_packet_v2(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n{\n\tconst struct nci_core_init_rsp_nci_ver2 *rsp = (void *)skb->data;\n\tconst u8 *supported_rf_interface = rsp->supported_rf_interfaces;\n\tu8 rf_interface_idx = 0;\n\tu8 rf_extension_cnt = 0;\n\n\tpr_debug(\"status %x\\n\", rsp->status);\n\n\tif (rsp->status != NCI_STATUS_OK)\n\t\treturn rsp->status;\n\n\tndev->nfcc_features = __le32_to_cpu(rsp->nfcc_features);\n\tndev->num_supported_rf_interfaces = rsp->num_supported_rf_interfaces;\n\n\tndev->num_supported_rf_interfaces =\n\t\tmin((int)ndev->num_supported_rf_interfaces,\n\t\t    NCI_MAX_SUPPORTED_RF_INTERFACES);\n\n\twhile (rf_interface_idx < ndev->num_supported_rf_interfaces) {\n\t\tndev->supported_rf_interfaces[rf_interface_idx++] = *supported_rf_interface++;\n\n\t\t \n\t\trf_extension_cnt = *supported_rf_interface++;\n\t\tsupported_rf_interface += rf_extension_cnt;\n\t}\n\n\tndev->max_logical_connections = rsp->max_logical_connections;\n\tndev->max_routing_table_size =\n\t\t\t__le16_to_cpu(rsp->max_routing_table_size);\n\tndev->max_ctrl_pkt_payload_len =\n\t\t\trsp->max_ctrl_pkt_payload_len;\n\tndev->max_size_for_large_params = NCI_MAX_LARGE_PARAMS_NCI_v2;\n\n\treturn NCI_STATUS_OK;\n}\n\nstatic void nci_core_init_rsp_packet(struct nci_dev *ndev, const struct sk_buff *skb)\n{\n\tu8 status = 0;\n\n\tif (!(ndev->nci_ver & NCI_VER_2_MASK))\n\t\tstatus = nci_core_init_rsp_packet_v1(ndev, skb);\n\telse\n\t\tstatus = nci_core_init_rsp_packet_v2(ndev, skb);\n\n\tif (status != NCI_STATUS_OK)\n\t\tgoto exit;\n\n\tpr_debug(\"nfcc_features 0x%x\\n\",\n\t\t ndev->nfcc_features);\n\tpr_debug(\"num_supported_rf_interfaces %d\\n\",\n\t\t ndev->num_supported_rf_interfaces);\n\tpr_debug(\"supported_rf_interfaces[0] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[0]);\n\tpr_debug(\"supported_rf_interfaces[1] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[1]);\n\tpr_debug(\"supported_rf_interfaces[2] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[2]);\n\tpr_debug(\"supported_rf_interfaces[3] 0x%x\\n\",\n\t\t ndev->supported_rf_interfaces[3]);\n\tpr_debug(\"max_logical_connections %d\\n\",\n\t\t ndev->max_logical_connections);\n\tpr_debug(\"max_routing_table_size %d\\n\",\n\t\t ndev->max_routing_table_size);\n\tpr_debug(\"max_ctrl_pkt_payload_len %d\\n\",\n\t\t ndev->max_ctrl_pkt_payload_len);\n\tpr_debug(\"max_size_for_large_params %d\\n\",\n\t\t ndev->max_size_for_large_params);\n\tpr_debug(\"manufact_id 0x%x\\n\",\n\t\t ndev->manufact_id);\n\tpr_debug(\"manufact_specific_info 0x%x\\n\",\n\t\t ndev->manufact_specific_info);\n\nexit:\n\tnci_req_complete(ndev, status);\n}\n\nstatic void nci_core_set_config_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t   const struct sk_buff *skb)\n{\n\tconst struct nci_core_set_config_rsp *rsp = (void *)skb->data;\n\n\tpr_debug(\"status 0x%x\\n\", rsp->status);\n\n\tnci_req_complete(ndev, rsp->status);\n}\n\nstatic void nci_rf_disc_map_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\n\tnci_req_complete(ndev, status);\n}\n\nstatic void nci_rf_disc_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\tstruct nci_conn_info *conn_info;\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\n\tif (status == NCI_STATUS_OK) {\n\t\tatomic_set(&ndev->state, NCI_DISCOVERY);\n\n\t\tconn_info = ndev->rf_conn_info;\n\t\tif (!conn_info) {\n\t\t\tconn_info = devm_kzalloc(&ndev->nfc_dev->dev,\n\t\t\t\t\t\t sizeof(struct nci_conn_info),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!conn_info) {\n\t\t\t\tstatus = NCI_STATUS_REJECTED;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tconn_info->conn_id = NCI_STATIC_RF_CONN_ID;\n\t\t\tINIT_LIST_HEAD(&conn_info->list);\n\t\t\tlist_add(&conn_info->list, &ndev->conn_info_list);\n\t\t\tndev->rf_conn_info = conn_info;\n\t\t}\n\t}\n\nexit:\n\tnci_req_complete(ndev, status);\n}\n\nstatic void nci_rf_disc_select_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\n\t \n\tif (status != NCI_STATUS_OK)\n\t\tnci_req_complete(ndev, status);\n}\n\nstatic void nci_rf_deactivate_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\n\t \n\tif ((status != NCI_STATUS_OK) ||\n\t    (atomic_read(&ndev->state) != NCI_POLL_ACTIVE)) {\n\t\tnci_clear_target_list(ndev);\n\t\tatomic_set(&ndev->state, NCI_IDLE);\n\t\tnci_req_complete(ndev, status);\n\t}\n}\n\nstatic void nci_nfcee_discover_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tconst struct nci_nfcee_discover_rsp *discover_rsp;\n\n\tif (skb->len != 2) {\n\t\tnci_req_complete(ndev, NCI_STATUS_NFCEE_PROTOCOL_ERROR);\n\t\treturn;\n\t}\n\n\tdiscover_rsp = (struct nci_nfcee_discover_rsp *)skb->data;\n\n\tif (discover_rsp->status != NCI_STATUS_OK ||\n\t    discover_rsp->num_nfcee == 0)\n\t\tnci_req_complete(ndev, discover_rsp->status);\n}\n\nstatic void nci_nfcee_mode_set_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\tnci_req_complete(ndev, status);\n}\n\nstatic void nci_core_conn_create_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t    const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\tstruct nci_conn_info *conn_info = NULL;\n\tconst struct nci_core_conn_create_rsp *rsp;\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\n\tif (status == NCI_STATUS_OK) {\n\t\trsp = (struct nci_core_conn_create_rsp *)skb->data;\n\n\t\tconn_info = devm_kzalloc(&ndev->nfc_dev->dev,\n\t\t\t\t\t sizeof(*conn_info), GFP_KERNEL);\n\t\tif (!conn_info) {\n\t\t\tstatus = NCI_STATUS_REJECTED;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tconn_info->dest_params = devm_kzalloc(&ndev->nfc_dev->dev,\n\t\t\t\t\t\tsizeof(struct dest_spec_params),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!conn_info->dest_params) {\n\t\t\tstatus = NCI_STATUS_REJECTED;\n\t\t\tgoto free_conn_info;\n\t\t}\n\n\t\tconn_info->dest_type = ndev->cur_dest_type;\n\t\tconn_info->dest_params->id = ndev->cur_params.id;\n\t\tconn_info->dest_params->protocol = ndev->cur_params.protocol;\n\t\tconn_info->conn_id = rsp->conn_id;\n\n\t\t \n\n\t\tINIT_LIST_HEAD(&conn_info->list);\n\t\tlist_add(&conn_info->list, &ndev->conn_info_list);\n\n\t\tif (ndev->cur_params.id == ndev->hci_dev->nfcee_id)\n\t\t\tndev->hci_dev->conn_info = conn_info;\n\n\t\tconn_info->conn_id = rsp->conn_id;\n\t\tconn_info->max_pkt_payload_len = rsp->max_ctrl_pkt_payload_len;\n\t\tatomic_set(&conn_info->credits_cnt, rsp->credits_cnt);\n\t}\n\nfree_conn_info:\n\tif (status == NCI_STATUS_REJECTED)\n\t\tdevm_kfree(&ndev->nfc_dev->dev, conn_info);\nexit:\n\n\tnci_req_complete(ndev, status);\n}\n\nstatic void nci_core_conn_close_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t   const struct sk_buff *skb)\n{\n\tstruct nci_conn_info *conn_info;\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\tif (status == NCI_STATUS_OK) {\n\t\tconn_info = nci_get_conn_info_by_conn_id(ndev,\n\t\t\t\t\t\t\t ndev->cur_conn_id);\n\t\tif (conn_info) {\n\t\t\tlist_del(&conn_info->list);\n\t\t\tif (conn_info == ndev->rf_conn_info)\n\t\t\t\tndev->rf_conn_info = NULL;\n\t\t\tdevm_kfree(&ndev->nfc_dev->dev, conn_info);\n\t\t}\n\t}\n\tnci_req_complete(ndev, status);\n}\n\nvoid nci_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\t__u16 rsp_opcode = nci_opcode(skb->data);\n\n\t \n\tdel_timer(&ndev->cmd_timer);\n\n\tpr_debug(\"NCI RX: MT=rsp, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\\n\",\n\t\t nci_pbf(skb->data),\n\t\t nci_opcode_gid(rsp_opcode),\n\t\t nci_opcode_oid(rsp_opcode),\n\t\t nci_plen(skb->data));\n\n\t \n\tskb_pull(skb, NCI_CTRL_HDR_SIZE);\n\n\tif (nci_opcode_gid(rsp_opcode) == NCI_GID_PROPRIETARY) {\n\t\tif (nci_prop_rsp_packet(ndev, rsp_opcode, skb) == -ENOTSUPP) {\n\t\t\tpr_err(\"unsupported rsp opcode 0x%x\\n\",\n\t\t\t       rsp_opcode);\n\t\t}\n\n\t\tgoto end;\n\t}\n\n\tswitch (rsp_opcode) {\n\tcase NCI_OP_CORE_RESET_RSP:\n\t\tnci_core_reset_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_INIT_RSP:\n\t\tnci_core_init_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_SET_CONFIG_RSP:\n\t\tnci_core_set_config_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_CONN_CREATE_RSP:\n\t\tnci_core_conn_create_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_CONN_CLOSE_RSP:\n\t\tnci_core_conn_close_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_DISCOVER_MAP_RSP:\n\t\tnci_rf_disc_map_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_DISCOVER_RSP:\n\t\tnci_rf_disc_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_DISCOVER_SELECT_RSP:\n\t\tnci_rf_disc_select_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_DEACTIVATE_RSP:\n\t\tnci_rf_deactivate_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_NFCEE_DISCOVER_RSP:\n\t\tnci_nfcee_discover_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_NFCEE_MODE_SET_RSP:\n\t\tnci_nfcee_mode_set_rsp_packet(ndev, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unknown rsp opcode 0x%x\\n\", rsp_opcode);\n\t\tbreak;\n\t}\n\n\tnci_core_rsp_packet(ndev, rsp_opcode, skb);\nend:\n\tkfree_skb(skb);\n\n\t \n\tatomic_set(&ndev->cmd_cnt, 1);\n\tif (!skb_queue_empty(&ndev->cmd_q))\n\t\tqueue_work(ndev->cmd_wq, &ndev->cmd_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}