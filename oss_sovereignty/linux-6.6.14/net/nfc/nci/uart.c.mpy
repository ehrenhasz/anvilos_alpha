{
  "module_name": "uart.c",
  "hash_id": "fbee1d895b2dd37ce13843d79174f24710f6002fc9df40a2f5e891193a5b2c87",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/uart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n\n \n#define NCI_UART_SENDING\t1\n#define NCI_UART_TX_WAKEUP\t2\n\nstatic struct nci_uart *nci_uart_drivers[NCI_UART_DRIVER_MAX];\n\nstatic inline struct sk_buff *nci_uart_dequeue(struct nci_uart *nu)\n{\n\tstruct sk_buff *skb = nu->tx_skb;\n\n\tif (!skb)\n\t\tskb = skb_dequeue(&nu->tx_q);\n\telse\n\t\tnu->tx_skb = NULL;\n\n\treturn skb;\n}\n\nstatic inline int nci_uart_queue_empty(struct nci_uart *nu)\n{\n\tif (nu->tx_skb)\n\t\treturn 0;\n\n\treturn skb_queue_empty(&nu->tx_q);\n}\n\nstatic int nci_uart_tx_wakeup(struct nci_uart *nu)\n{\n\tif (test_and_set_bit(NCI_UART_SENDING, &nu->tx_state)) {\n\t\tset_bit(NCI_UART_TX_WAKEUP, &nu->tx_state);\n\t\treturn 0;\n\t}\n\n\tschedule_work(&nu->write_work);\n\n\treturn 0;\n}\n\nstatic void nci_uart_write_work(struct work_struct *work)\n{\n\tstruct nci_uart *nu = container_of(work, struct nci_uart, write_work);\n\tstruct tty_struct *tty = nu->tty;\n\tstruct sk_buff *skb;\n\nrestart:\n\tclear_bit(NCI_UART_TX_WAKEUP, &nu->tx_state);\n\n\tif (nu->ops.tx_start)\n\t\tnu->ops.tx_start(nu);\n\n\twhile ((skb = nci_uart_dequeue(nu))) {\n\t\tint len;\n\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tlen = tty->ops->write(tty, skb->data, skb->len);\n\t\tskb_pull(skb, len);\n\t\tif (skb->len) {\n\t\t\tnu->tx_skb = skb;\n\t\t\tbreak;\n\t\t}\n\t\tkfree_skb(skb);\n\t}\n\n\tif (test_bit(NCI_UART_TX_WAKEUP, &nu->tx_state))\n\t\tgoto restart;\n\n\tif (nu->ops.tx_done && nci_uart_queue_empty(nu))\n\t\tnu->ops.tx_done(nu);\n\n\tclear_bit(NCI_UART_SENDING, &nu->tx_state);\n}\n\nstatic int nci_uart_set_driver(struct tty_struct *tty, unsigned int driver)\n{\n\tstruct nci_uart *nu = NULL;\n\tint ret;\n\n\tif (driver >= NCI_UART_DRIVER_MAX)\n\t\treturn -EINVAL;\n\n\tif (!nci_uart_drivers[driver])\n\t\treturn -ENOENT;\n\n\tnu = kzalloc(sizeof(*nu), GFP_KERNEL);\n\tif (!nu)\n\t\treturn -ENOMEM;\n\n\tmemcpy(nu, nci_uart_drivers[driver], sizeof(struct nci_uart));\n\tnu->tty = tty;\n\ttty->disc_data = nu;\n\tskb_queue_head_init(&nu->tx_q);\n\tINIT_WORK(&nu->write_work, nci_uart_write_work);\n\tspin_lock_init(&nu->rx_lock);\n\n\tret = nu->ops.open(nu);\n\tif (ret) {\n\t\ttty->disc_data = NULL;\n\t\tkfree(nu);\n\t} else if (!try_module_get(nu->owner)) {\n\t\tnu->ops.close(nu);\n\t\ttty->disc_data = NULL;\n\t\tkfree(nu);\n\t\treturn -ENOENT;\n\t}\n\treturn ret;\n}\n\n \n\n \nstatic int nci_uart_tty_open(struct tty_struct *tty)\n{\n\t \n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\ttty->disc_data = NULL;\n\ttty->receive_room = 65536;\n\n\t \n\ttty_driver_flush_buffer(tty);\n\n\treturn 0;\n}\n\n \nstatic void nci_uart_tty_close(struct tty_struct *tty)\n{\n\tstruct nci_uart *nu = tty->disc_data;\n\n\t \n\ttty->disc_data = NULL;\n\n\tif (!nu)\n\t\treturn;\n\n\tkfree_skb(nu->tx_skb);\n\tkfree_skb(nu->rx_skb);\n\n\tskb_queue_purge(&nu->tx_q);\n\n\tnu->ops.close(nu);\n\tnu->tty = NULL;\n\tmodule_put(nu->owner);\n\n\tcancel_work_sync(&nu->write_work);\n\n\tkfree(nu);\n}\n\n \nstatic void nci_uart_tty_wakeup(struct tty_struct *tty)\n{\n\tstruct nci_uart *nu = tty->disc_data;\n\n\tif (!nu)\n\t\treturn;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\tif (tty != nu->tty)\n\t\treturn;\n\n\tnci_uart_tx_wakeup(nu);\n}\n\n \nstatic int nci_uart_default_recv_buf(struct nci_uart *nu, const u8 *data,\n\t\t\t\t     int count)\n{\n\tint chunk_len;\n\n\tif (!nu->ndev) {\n\t\tnfc_err(nu->tty->dev,\n\t\t\t\"receive data from tty but no NCI dev is attached yet, drop buffer\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\twhile (count > 0) {\n\t\t \n\t\tif (!nu->rx_skb) {\n\t\t\tnu->rx_packet_len = -1;\n\t\t\tnu->rx_skb = nci_skb_alloc(nu->ndev,\n\t\t\t\t\t\t   NCI_MAX_PACKET_SIZE,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\tif (!nu->rx_skb)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tif (nu->rx_skb->len < NCI_CTRL_HDR_SIZE) {\n\t\t\tskb_put_u8(nu->rx_skb, *data++);\n\t\t\t--count;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (nu->rx_packet_len < 0)\n\t\t\tnu->rx_packet_len = NCI_CTRL_HDR_SIZE +\n\t\t\t\tnci_plen(nu->rx_skb->data);\n\n\t\t \n\t\tchunk_len = nu->rx_packet_len - nu->rx_skb->len;\n\t\tif (count < chunk_len)\n\t\t\tchunk_len = count;\n\t\tskb_put_data(nu->rx_skb, data, chunk_len);\n\t\tdata += chunk_len;\n\t\tcount -= chunk_len;\n\n\t\t \n\t\tif (nu->rx_packet_len == nu->rx_skb->len) {\n\t\t\t \n\t\t\tif (nu->ops.recv(nu, nu->rx_skb) != 0)\n\t\t\t\tnfc_err(nu->tty->dev, \"corrupted RX packet\\n\");\n\t\t\t \n\t\t\tnu->rx_skb = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void nci_uart_tty_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t\t const u8 *flags, size_t count)\n{\n\tstruct nci_uart *nu = tty->disc_data;\n\n\tif (!nu || tty != nu->tty)\n\t\treturn;\n\n\tspin_lock(&nu->rx_lock);\n\tnci_uart_default_recv_buf(nu, data, count);\n\tspin_unlock(&nu->rx_lock);\n\n\ttty_unthrottle(tty);\n}\n\n \nstatic int nci_uart_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct nci_uart *nu = tty->disc_data;\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase NCIUARTSETDRIVER:\n\t\tif (!nu)\n\t\t\treturn nci_uart_set_driver(tty, (unsigned int)arg);\n\t\telse\n\t\t\treturn -EBUSY;\n\t\tbreak;\n\tdefault:\n\t\terr = n_tty_ioctl_helper(tty, cmd, arg);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic ssize_t nci_uart_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t\t u8 *buf, size_t nr, void **cookie,\n\t\t\t\t unsigned long offset)\n{\n\treturn 0;\n}\n\nstatic ssize_t nci_uart_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t\t  const u8 *data, size_t count)\n{\n\treturn 0;\n}\n\nstatic int nci_uart_send(struct nci_uart *nu, struct sk_buff *skb)\n{\n\t \n\tskb_queue_tail(&nu->tx_q, skb);\n\n\t \n\tnci_uart_tx_wakeup(nu);\n\n\treturn 0;\n}\n\nint nci_uart_register(struct nci_uart *nu)\n{\n\tif (!nu || !nu->ops.open ||\n\t    !nu->ops.recv || !nu->ops.close)\n\t\treturn -EINVAL;\n\n\t \n\tnu->ops.send = nci_uart_send;\n\n\t \n\tif (nci_uart_drivers[nu->driver]) {\n\t\tpr_err(\"driver %d is already registered\\n\", nu->driver);\n\t\treturn -EBUSY;\n\t}\n\tnci_uart_drivers[nu->driver] = nu;\n\n\tpr_info(\"NCI uart driver '%s [%d]' registered\\n\", nu->name, nu->driver);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nci_uart_register);\n\nvoid nci_uart_unregister(struct nci_uart *nu)\n{\n\tpr_info(\"NCI uart driver '%s [%d]' unregistered\\n\", nu->name,\n\t\tnu->driver);\n\n\t \n\tnci_uart_drivers[nu->driver] = NULL;\n}\nEXPORT_SYMBOL_GPL(nci_uart_unregister);\n\nvoid nci_uart_set_config(struct nci_uart *nu, int baudrate, int flow_ctrl)\n{\n\tstruct ktermios new_termios;\n\n\tif (!nu->tty)\n\t\treturn;\n\n\tdown_read(&nu->tty->termios_rwsem);\n\tnew_termios = nu->tty->termios;\n\tup_read(&nu->tty->termios_rwsem);\n\ttty_termios_encode_baud_rate(&new_termios, baudrate, baudrate);\n\n\tif (flow_ctrl)\n\t\tnew_termios.c_cflag |= CRTSCTS;\n\telse\n\t\tnew_termios.c_cflag &= ~CRTSCTS;\n\n\ttty_set_termios(nu->tty, &new_termios);\n}\nEXPORT_SYMBOL_GPL(nci_uart_set_config);\n\nstatic struct tty_ldisc_ops nci_uart_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_NCI,\n\t.name\t\t= \"n_nci\",\n\t.open\t\t= nci_uart_tty_open,\n\t.close\t\t= nci_uart_tty_close,\n\t.read\t\t= nci_uart_tty_read,\n\t.write\t\t= nci_uart_tty_write,\n\t.receive_buf\t= nci_uart_tty_receive,\n\t.write_wakeup\t= nci_uart_tty_wakeup,\n\t.ioctl\t\t= nci_uart_tty_ioctl,\n\t.compat_ioctl\t= nci_uart_tty_ioctl,\n};\n\nstatic int __init nci_uart_init(void)\n{\n\treturn tty_register_ldisc(&nci_uart_ldisc);\n}\n\nstatic void __exit nci_uart_exit(void)\n{\n\ttty_unregister_ldisc(&nci_uart_ldisc);\n}\n\nmodule_init(nci_uart_init);\nmodule_exit(nci_uart_exit);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"NFC NCI UART driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_NCI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}