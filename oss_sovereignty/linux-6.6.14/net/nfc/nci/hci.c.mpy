{
  "module_name": "hci.c",
  "hash_id": "e786d4c402531ff6cca9eceaf7cec7060643a6a0d05d59c580dad8b271cf86b6",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/hci.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n\n#include \"../nfc.h\"\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include <linux/nfc.h>\n#include <linux/kcov.h>\n\nstruct nci_data {\n\tu8 conn_id;\n\tu8 pipe;\n\tu8 cmd;\n\tconst u8 *data;\n\tu32 data_len;\n} __packed;\n\nstruct nci_hci_create_pipe_params {\n\tu8 src_gate;\n\tu8 dest_host;\n\tu8 dest_gate;\n} __packed;\n\nstruct nci_hci_create_pipe_resp {\n\tu8 src_host;\n\tu8 src_gate;\n\tu8 dest_host;\n\tu8 dest_gate;\n\tu8 pipe;\n} __packed;\n\nstruct nci_hci_delete_pipe_noti {\n\tu8 pipe;\n} __packed;\n\nstruct nci_hci_all_pipe_cleared_noti {\n\tu8 host;\n} __packed;\n\nstruct nci_hcp_message {\n\tu8 header;       \n\tu8 data[];\n} __packed;\n\nstruct nci_hcp_packet {\n\tu8 header;       \n\tstruct nci_hcp_message message;\n} __packed;\n\n#define NCI_HCI_ANY_SET_PARAMETER  0x01\n#define NCI_HCI_ANY_GET_PARAMETER  0x02\n#define NCI_HCI_ANY_CLOSE_PIPE     0x04\n#define NCI_HCI_ADM_CLEAR_ALL_PIPE 0x14\n\n#define NCI_HFP_NO_CHAINING        0x80\n\n#define NCI_NFCEE_ID_HCI                0x80\n\n#define NCI_EVT_HOT_PLUG           0x03\n\n#define NCI_HCI_ADMIN_PARAM_SESSION_IDENTITY       0x01\n#define NCI_HCI_ADM_CREATE_PIPE\t\t\t0x10\n#define NCI_HCI_ADM_DELETE_PIPE\t\t\t0x11\n\n \n#define NCI_HCI_HCP_PACKET_HEADER_LEN      1\n#define NCI_HCI_HCP_MESSAGE_HEADER_LEN     1\n#define NCI_HCI_HCP_HEADER_LEN             2\n\n \n#define NCI_HCI_HCP_COMMAND        0x00\n#define NCI_HCI_HCP_EVENT          0x01\n#define NCI_HCI_HCP_RESPONSE       0x02\n\n#define NCI_HCI_ADM_NOTIFY_PIPE_CREATED     0x12\n#define NCI_HCI_ADM_NOTIFY_PIPE_DELETED     0x13\n#define NCI_HCI_ADM_NOTIFY_ALL_PIPE_CLEARED 0x15\n\n#define NCI_HCI_FRAGMENT           0x7f\n#define NCI_HCP_HEADER(type, instr) ((((type) & 0x03) << 6) |\\\n\t\t\t\t      ((instr) & 0x3f))\n\n#define NCI_HCP_MSG_GET_TYPE(header) ((header & 0xc0) >> 6)\n#define NCI_HCP_MSG_GET_CMD(header)  (header & 0x3f)\n#define NCI_HCP_MSG_GET_PIPE(header) (header & 0x7f)\n\nstatic int nci_hci_result_to_errno(u8 result)\n{\n\tswitch (result) {\n\tcase NCI_HCI_ANY_OK:\n\t\treturn 0;\n\tcase NCI_HCI_ANY_E_REG_PAR_UNKNOWN:\n\t\treturn -EOPNOTSUPP;\n\tcase NCI_HCI_ANY_E_TIMEOUT:\n\t\treturn -ETIME;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nstatic void nci_hci_reset_pipes(struct nci_hci_dev *hdev)\n{\n\tint i;\n\n\tfor (i = 0; i < NCI_HCI_MAX_PIPES; i++) {\n\t\thdev->pipes[i].gate = NCI_HCI_INVALID_GATE;\n\t\thdev->pipes[i].host = NCI_HCI_INVALID_HOST;\n\t}\n\tmemset(hdev->gate2pipe, NCI_HCI_INVALID_PIPE, sizeof(hdev->gate2pipe));\n}\n\nstatic void nci_hci_reset_pipes_per_host(struct nci_dev *ndev, u8 host)\n{\n\tint i;\n\n\tfor (i = 0; i < NCI_HCI_MAX_PIPES; i++) {\n\t\tif (ndev->hci_dev->pipes[i].host == host) {\n\t\t\tndev->hci_dev->pipes[i].gate = NCI_HCI_INVALID_GATE;\n\t\t\tndev->hci_dev->pipes[i].host = NCI_HCI_INVALID_HOST;\n\t\t}\n\t}\n}\n\n \nstatic int nci_hci_send_data(struct nci_dev *ndev, u8 pipe,\n\t\t\t     const u8 data_type, const u8 *data,\n\t\t\t     size_t data_len)\n{\n\tconst struct nci_conn_info *conn_info;\n\tstruct sk_buff *skb;\n\tint len, i, r;\n\tu8 cb = pipe;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\ti = 0;\n\tskb = nci_skb_alloc(ndev, conn_info->max_pkt_payload_len +\n\t\t\t    NCI_DATA_HDR_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, NCI_DATA_HDR_SIZE + 2);\n\t*(u8 *)skb_push(skb, 1) = data_type;\n\n\tdo {\n\t\t \n\t\tif (i + conn_info->max_pkt_payload_len -\n\t\t    (skb->len + 1) >= data_len) {\n\t\t\tcb |= NCI_HFP_NO_CHAINING;\n\t\t\tlen = data_len - i;\n\t\t} else {\n\t\t\tlen = conn_info->max_pkt_payload_len - skb->len - 1;\n\t\t}\n\n\t\t*(u8 *)skb_push(skb, 1) = cb;\n\n\t\tif (len > 0)\n\t\t\tskb_put_data(skb, data + i, len);\n\n\t\tr = nci_send_data(ndev, conn_info->conn_id, skb);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\ti += len;\n\n\t\tif (i < data_len) {\n\t\t\tskb = nci_skb_alloc(ndev,\n\t\t\t\t\t    conn_info->max_pkt_payload_len +\n\t\t\t\t\t    NCI_DATA_HDR_SIZE, GFP_ATOMIC);\n\t\t\tif (!skb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tskb_reserve(skb, NCI_DATA_HDR_SIZE + 1);\n\t\t}\n\t} while (i < data_len);\n\n\treturn i;\n}\n\nstatic void nci_hci_send_data_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_data *data = opt;\n\n\tnci_hci_send_data(ndev, data->pipe, data->cmd,\n\t\t\t  data->data, data->data_len);\n}\n\nint nci_hci_send_event(struct nci_dev *ndev, u8 gate, u8 event,\n\t\t       const u8 *param, size_t param_len)\n{\n\tu8 pipe = ndev->hci_dev->gate2pipe[gate];\n\n\tif (pipe == NCI_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn nci_hci_send_data(ndev, pipe,\n\t\t\tNCI_HCP_HEADER(NCI_HCI_HCP_EVENT, event),\n\t\t\tparam, param_len);\n}\nEXPORT_SYMBOL(nci_hci_send_event);\n\nint nci_hci_send_cmd(struct nci_dev *ndev, u8 gate, u8 cmd,\n\t\t     const u8 *param, size_t param_len,\n\t\t     struct sk_buff **skb)\n{\n\tconst struct nci_hcp_message *message;\n\tconst struct nci_conn_info *conn_info;\n\tstruct nci_data data;\n\tint r;\n\tu8 pipe = ndev->hci_dev->gate2pipe[gate];\n\n\tif (pipe == NCI_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\tdata.conn_id = conn_info->conn_id;\n\tdata.pipe = pipe;\n\tdata.cmd = NCI_HCP_HEADER(NCI_HCI_HCP_COMMAND, cmd);\n\tdata.data = param;\n\tdata.data_len = param_len;\n\n\tr = nci_request(ndev, nci_hci_send_data_req, &data,\n\t\t\tmsecs_to_jiffies(NCI_DATA_TIMEOUT));\n\tif (r == NCI_STATUS_OK) {\n\t\tmessage = (struct nci_hcp_message *)conn_info->rx_skb->data;\n\t\tr = nci_hci_result_to_errno(\n\t\t\tNCI_HCP_MSG_GET_CMD(message->header));\n\t\tskb_pull(conn_info->rx_skb, NCI_HCI_HCP_MESSAGE_HEADER_LEN);\n\n\t\tif (!r && skb)\n\t\t\t*skb = conn_info->rx_skb;\n\t}\n\n\treturn r;\n}\nEXPORT_SYMBOL(nci_hci_send_cmd);\n\nint nci_hci_clear_all_pipes(struct nci_dev *ndev)\n{\n\tint r;\n\n\tr = nci_hci_send_cmd(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\t     NCI_HCI_ADM_CLEAR_ALL_PIPE, NULL, 0, NULL);\n\tif (r < 0)\n\t\treturn r;\n\n\tnci_hci_reset_pipes(ndev->hci_dev);\n\treturn r;\n}\nEXPORT_SYMBOL(nci_hci_clear_all_pipes);\n\nstatic void nci_hci_event_received(struct nci_dev *ndev, u8 pipe,\n\t\t\t\t   u8 event, struct sk_buff *skb)\n{\n\tif (ndev->ops->hci_event_received)\n\t\tndev->ops->hci_event_received(ndev, pipe, event, skb);\n}\n\nstatic void nci_hci_cmd_received(struct nci_dev *ndev, u8 pipe,\n\t\t\t\t u8 cmd, struct sk_buff *skb)\n{\n\tu8 gate = ndev->hci_dev->pipes[pipe].gate;\n\tu8 status = NCI_HCI_ANY_OK | ~NCI_HCI_FRAGMENT;\n\tu8 dest_gate, new_pipe;\n\tstruct nci_hci_create_pipe_resp *create_info;\n\tstruct nci_hci_delete_pipe_noti *delete_info;\n\tstruct nci_hci_all_pipe_cleared_noti *cleared_info;\n\n\tpr_debug(\"from gate %x pipe %x cmd %x\\n\", gate, pipe, cmd);\n\n\tswitch (cmd) {\n\tcase NCI_HCI_ADM_NOTIFY_PIPE_CREATED:\n\t\tif (skb->len != 5) {\n\t\t\tstatus = NCI_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tcreate_info = (struct nci_hci_create_pipe_resp *)skb->data;\n\t\tdest_gate = create_info->dest_gate;\n\t\tnew_pipe = create_info->pipe;\n\t\tif (new_pipe >= NCI_HCI_MAX_PIPES) {\n\t\t\tstatus = NCI_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tndev->hci_dev->gate2pipe[dest_gate] = new_pipe;\n\t\tndev->hci_dev->pipes[new_pipe].gate = dest_gate;\n\t\tndev->hci_dev->pipes[new_pipe].host =\n\t\t\t\t\t\tcreate_info->src_host;\n\t\tbreak;\n\tcase NCI_HCI_ANY_OPEN_PIPE:\n\t\t \n\t\tif (gate == NCI_HCI_INVALID_GATE) {\n\t\t\tstatus = NCI_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase NCI_HCI_ADM_NOTIFY_PIPE_DELETED:\n\t\tif (skb->len != 1) {\n\t\t\tstatus = NCI_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tdelete_info = (struct nci_hci_delete_pipe_noti *)skb->data;\n\t\tif (delete_info->pipe >= NCI_HCI_MAX_PIPES) {\n\t\t\tstatus = NCI_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tndev->hci_dev->pipes[delete_info->pipe].gate =\n\t\t\t\t\t\tNCI_HCI_INVALID_GATE;\n\t\tndev->hci_dev->pipes[delete_info->pipe].host =\n\t\t\t\t\t\tNCI_HCI_INVALID_HOST;\n\t\tbreak;\n\tcase NCI_HCI_ADM_NOTIFY_ALL_PIPE_CLEARED:\n\t\tif (skb->len != 1) {\n\t\t\tstatus = NCI_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tcleared_info =\n\t\t\t(struct nci_hci_all_pipe_cleared_noti *)skb->data;\n\t\tnci_hci_reset_pipes_per_host(ndev, cleared_info->host);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Discarded unknown cmd %x to gate %x\\n\", cmd, gate);\n\t\tbreak;\n\t}\n\n\tif (ndev->ops->hci_cmd_received)\n\t\tndev->ops->hci_cmd_received(ndev, pipe, cmd, skb);\n\nexit:\n\tnci_hci_send_data(ndev, pipe, status, NULL, 0);\n\n\tkfree_skb(skb);\n}\n\nstatic void nci_hci_resp_received(struct nci_dev *ndev, u8 pipe,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct nci_conn_info *conn_info;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\tgoto exit;\n\n\tconn_info->rx_skb = skb;\n\nexit:\n\tnci_req_complete(ndev, NCI_STATUS_OK);\n}\n\n \nstatic void nci_hci_hcp_message_rx(struct nci_dev *ndev, u8 pipe,\n\t\t\t\t   u8 type, u8 instruction, struct sk_buff *skb)\n{\n\tswitch (type) {\n\tcase NCI_HCI_HCP_RESPONSE:\n\t\tnci_hci_resp_received(ndev, pipe, skb);\n\t\tbreak;\n\tcase NCI_HCI_HCP_COMMAND:\n\t\tnci_hci_cmd_received(ndev, pipe, instruction, skb);\n\t\tbreak;\n\tcase NCI_HCI_HCP_EVENT:\n\t\tnci_hci_event_received(ndev, pipe, instruction, skb);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"UNKNOWN MSG Type %d, instruction=%d\\n\",\n\t\t       type, instruction);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tnci_req_complete(ndev, NCI_STATUS_OK);\n}\n\nstatic void nci_hci_msg_rx_work(struct work_struct *work)\n{\n\tstruct nci_hci_dev *hdev =\n\t\tcontainer_of(work, struct nci_hci_dev, msg_rx_work);\n\tstruct sk_buff *skb;\n\tconst struct nci_hcp_message *message;\n\tu8 pipe, type, instruction;\n\n\tfor (; (skb = skb_dequeue(&hdev->msg_rx_queue)); kcov_remote_stop()) {\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\t\tpipe = NCI_HCP_MSG_GET_PIPE(skb->data[0]);\n\t\tskb_pull(skb, NCI_HCI_HCP_PACKET_HEADER_LEN);\n\t\tmessage = (struct nci_hcp_message *)skb->data;\n\t\ttype = NCI_HCP_MSG_GET_TYPE(message->header);\n\t\tinstruction = NCI_HCP_MSG_GET_CMD(message->header);\n\t\tskb_pull(skb, NCI_HCI_HCP_MESSAGE_HEADER_LEN);\n\n\t\tnci_hci_hcp_message_rx(hdev->ndev, pipe,\n\t\t\t\t       type, instruction, skb);\n\t}\n}\n\nvoid nci_hci_data_received_cb(void *context,\n\t\t\t      struct sk_buff *skb, int err)\n{\n\tstruct nci_dev *ndev = (struct nci_dev *)context;\n\tstruct nci_hcp_packet *packet;\n\tu8 pipe, type;\n\tstruct sk_buff *hcp_skb;\n\tstruct sk_buff *frag_skb;\n\tint msg_len;\n\n\tif (err) {\n\t\tnci_req_complete(ndev, err);\n\t\treturn;\n\t}\n\n\tpacket = (struct nci_hcp_packet *)skb->data;\n\tif ((packet->header & ~NCI_HCI_FRAGMENT) == 0) {\n\t\tskb_queue_tail(&ndev->hci_dev->rx_hcp_frags, skb);\n\t\treturn;\n\t}\n\n\t \n\tif (skb_queue_len(&ndev->hci_dev->rx_hcp_frags)) {\n\t\tpipe = NCI_HCP_MSG_GET_PIPE(packet->header);\n\t\tskb_queue_tail(&ndev->hci_dev->rx_hcp_frags, skb);\n\n\t\tmsg_len = 0;\n\t\tskb_queue_walk(&ndev->hci_dev->rx_hcp_frags, frag_skb) {\n\t\t\tmsg_len += (frag_skb->len -\n\t\t\t\t    NCI_HCI_HCP_PACKET_HEADER_LEN);\n\t\t}\n\n\t\thcp_skb = nfc_alloc_recv_skb(NCI_HCI_HCP_PACKET_HEADER_LEN +\n\t\t\t\t\t     msg_len, GFP_KERNEL);\n\t\tif (!hcp_skb) {\n\t\t\tnci_req_complete(ndev, -ENOMEM);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_u8(hcp_skb, pipe);\n\n\t\tskb_queue_walk(&ndev->hci_dev->rx_hcp_frags, frag_skb) {\n\t\t\tmsg_len = frag_skb->len - NCI_HCI_HCP_PACKET_HEADER_LEN;\n\t\t\tskb_put_data(hcp_skb,\n\t\t\t\t     frag_skb->data + NCI_HCI_HCP_PACKET_HEADER_LEN,\n\t\t\t\t     msg_len);\n\t\t}\n\n\t\tskb_queue_purge(&ndev->hci_dev->rx_hcp_frags);\n\t} else {\n\t\tpacket->header &= NCI_HCI_FRAGMENT;\n\t\thcp_skb = skb;\n\t}\n\n\t \n\tpacket = (struct nci_hcp_packet *)hcp_skb->data;\n\ttype = NCI_HCP_MSG_GET_TYPE(packet->message.header);\n\tif (type == NCI_HCI_HCP_RESPONSE) {\n\t\tpipe = NCI_HCP_MSG_GET_PIPE(packet->header);\n\t\tskb_pull(hcp_skb, NCI_HCI_HCP_PACKET_HEADER_LEN);\n\t\tnci_hci_hcp_message_rx(ndev, pipe, type,\n\t\t\t\t       NCI_STATUS_OK, hcp_skb);\n\t} else {\n\t\tskb_queue_tail(&ndev->hci_dev->msg_rx_queue, hcp_skb);\n\t\tschedule_work(&ndev->hci_dev->msg_rx_work);\n\t}\n}\n\nint nci_hci_open_pipe(struct nci_dev *ndev, u8 pipe)\n{\n\tstruct nci_data data;\n\tconst struct nci_conn_info *conn_info;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\tdata.conn_id = conn_info->conn_id;\n\tdata.pipe = pipe;\n\tdata.cmd = NCI_HCP_HEADER(NCI_HCI_HCP_COMMAND,\n\t\t\t\t       NCI_HCI_ANY_OPEN_PIPE);\n\tdata.data = NULL;\n\tdata.data_len = 0;\n\n\treturn nci_request(ndev, nci_hci_send_data_req, &data,\n\t\t\t   msecs_to_jiffies(NCI_DATA_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_hci_open_pipe);\n\nstatic u8 nci_hci_create_pipe(struct nci_dev *ndev, u8 dest_host,\n\t\t\t      u8 dest_gate, int *result)\n{\n\tu8 pipe;\n\tstruct sk_buff *skb;\n\tstruct nci_hci_create_pipe_params params;\n\tconst struct nci_hci_create_pipe_resp *resp;\n\n\tpr_debug(\"gate=%d\\n\", dest_gate);\n\n\tparams.src_gate = NCI_HCI_ADMIN_GATE;\n\tparams.dest_host = dest_host;\n\tparams.dest_gate = dest_gate;\n\n\t*result = nci_hci_send_cmd(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\t\t   NCI_HCI_ADM_CREATE_PIPE,\n\t\t\t\t   (u8 *)&params, sizeof(params), &skb);\n\tif (*result < 0)\n\t\treturn NCI_HCI_INVALID_PIPE;\n\n\tresp = (struct nci_hci_create_pipe_resp *)skb->data;\n\tpipe = resp->pipe;\n\tkfree_skb(skb);\n\n\tpr_debug(\"pipe created=%d\\n\", pipe);\n\n\treturn pipe;\n}\n\nstatic int nci_hci_delete_pipe(struct nci_dev *ndev, u8 pipe)\n{\n\treturn nci_hci_send_cmd(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\t\tNCI_HCI_ADM_DELETE_PIPE, &pipe, 1, NULL);\n}\n\nint nci_hci_set_param(struct nci_dev *ndev, u8 gate, u8 idx,\n\t\t      const u8 *param, size_t param_len)\n{\n\tconst struct nci_hcp_message *message;\n\tconst struct nci_conn_info *conn_info;\n\tstruct nci_data data;\n\tint r;\n\tu8 *tmp;\n\tu8 pipe = ndev->hci_dev->gate2pipe[gate];\n\n\tpr_debug(\"idx=%d to gate %d\\n\", idx, gate);\n\n\tif (pipe == NCI_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\ttmp = kmalloc(1 + param_len, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t*tmp = idx;\n\tmemcpy(tmp + 1, param, param_len);\n\n\tdata.conn_id = conn_info->conn_id;\n\tdata.pipe = pipe;\n\tdata.cmd = NCI_HCP_HEADER(NCI_HCI_HCP_COMMAND,\n\t\t\t\t       NCI_HCI_ANY_SET_PARAMETER);\n\tdata.data = tmp;\n\tdata.data_len = param_len + 1;\n\n\tr = nci_request(ndev, nci_hci_send_data_req, &data,\n\t\t\tmsecs_to_jiffies(NCI_DATA_TIMEOUT));\n\tif (r == NCI_STATUS_OK) {\n\t\tmessage = (struct nci_hcp_message *)conn_info->rx_skb->data;\n\t\tr = nci_hci_result_to_errno(\n\t\t\tNCI_HCP_MSG_GET_CMD(message->header));\n\t\tskb_pull(conn_info->rx_skb, NCI_HCI_HCP_MESSAGE_HEADER_LEN);\n\t}\n\n\tkfree(tmp);\n\treturn r;\n}\nEXPORT_SYMBOL(nci_hci_set_param);\n\nint nci_hci_get_param(struct nci_dev *ndev, u8 gate, u8 idx,\n\t\t      struct sk_buff **skb)\n{\n\tconst struct nci_hcp_message *message;\n\tconst struct nci_conn_info *conn_info;\n\tstruct nci_data data;\n\tint r;\n\tu8 pipe = ndev->hci_dev->gate2pipe[gate];\n\n\tpr_debug(\"idx=%d to gate %d\\n\", idx, gate);\n\n\tif (pipe == NCI_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\tdata.conn_id = conn_info->conn_id;\n\tdata.pipe = pipe;\n\tdata.cmd = NCI_HCP_HEADER(NCI_HCI_HCP_COMMAND,\n\t\t\t\t  NCI_HCI_ANY_GET_PARAMETER);\n\tdata.data = &idx;\n\tdata.data_len = 1;\n\n\tr = nci_request(ndev, nci_hci_send_data_req, &data,\n\t\t\tmsecs_to_jiffies(NCI_DATA_TIMEOUT));\n\n\tif (r == NCI_STATUS_OK) {\n\t\tmessage = (struct nci_hcp_message *)conn_info->rx_skb->data;\n\t\tr = nci_hci_result_to_errno(\n\t\t\tNCI_HCP_MSG_GET_CMD(message->header));\n\t\tskb_pull(conn_info->rx_skb, NCI_HCI_HCP_MESSAGE_HEADER_LEN);\n\n\t\tif (!r && skb)\n\t\t\t*skb = conn_info->rx_skb;\n\t}\n\n\treturn r;\n}\nEXPORT_SYMBOL(nci_hci_get_param);\n\nint nci_hci_connect_gate(struct nci_dev *ndev,\n\t\t\t u8 dest_host, u8 dest_gate, u8 pipe)\n{\n\tbool pipe_created = false;\n\tint r;\n\n\tif (pipe == NCI_HCI_DO_NOT_OPEN_PIPE)\n\t\treturn 0;\n\n\tif (ndev->hci_dev->gate2pipe[dest_gate] != NCI_HCI_INVALID_PIPE)\n\t\treturn -EADDRINUSE;\n\n\tif (pipe != NCI_HCI_INVALID_PIPE)\n\t\tgoto open_pipe;\n\n\tswitch (dest_gate) {\n\tcase NCI_HCI_LINK_MGMT_GATE:\n\t\tpipe = NCI_HCI_LINK_MGMT_PIPE;\n\tbreak;\n\tcase NCI_HCI_ADMIN_GATE:\n\t\tpipe = NCI_HCI_ADMIN_PIPE;\n\tbreak;\n\tdefault:\n\t\tpipe = nci_hci_create_pipe(ndev, dest_host, dest_gate, &r);\n\t\tif (pipe == NCI_HCI_INVALID_PIPE)\n\t\t\treturn r;\n\t\tpipe_created = true;\n\t\tbreak;\n\t}\n\nopen_pipe:\n\tr = nci_hci_open_pipe(ndev, pipe);\n\tif (r < 0) {\n\t\tif (pipe_created) {\n\t\t\tif (nci_hci_delete_pipe(ndev, pipe) < 0) {\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tndev->hci_dev->pipes[pipe].gate = dest_gate;\n\tndev->hci_dev->pipes[pipe].host = dest_host;\n\tndev->hci_dev->gate2pipe[dest_gate] = pipe;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nci_hci_connect_gate);\n\nstatic int nci_hci_dev_connect_gates(struct nci_dev *ndev,\n\t\t\t\t     u8 gate_count,\n\t\t\t\t     const struct nci_hci_gate *gates)\n{\n\tint r;\n\n\twhile (gate_count--) {\n\t\tr = nci_hci_connect_gate(ndev, gates->dest_host,\n\t\t\t\t\t gates->gate, gates->pipe);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tgates++;\n\t}\n\n\treturn 0;\n}\n\nint nci_hci_dev_session_init(struct nci_dev *ndev)\n{\n\tstruct nci_conn_info *conn_info;\n\tstruct sk_buff *skb;\n\tint r;\n\n\tndev->hci_dev->count_pipes = 0;\n\tndev->hci_dev->expected_pipes = 0;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\tconn_info->data_exchange_cb = nci_hci_data_received_cb;\n\tconn_info->data_exchange_cb_context = ndev;\n\n\tnci_hci_reset_pipes(ndev->hci_dev);\n\n\tif (ndev->hci_dev->init_data.gates[0].gate != NCI_HCI_ADMIN_GATE)\n\t\treturn -EPROTO;\n\n\tr = nci_hci_connect_gate(ndev,\n\t\t\t\t ndev->hci_dev->init_data.gates[0].dest_host,\n\t\t\t\t ndev->hci_dev->init_data.gates[0].gate,\n\t\t\t\t ndev->hci_dev->init_data.gates[0].pipe);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = nci_hci_get_param(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\t      NCI_HCI_ADMIN_PARAM_SESSION_IDENTITY, &skb);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (skb->len &&\n\t    skb->len == strlen(ndev->hci_dev->init_data.session_id) &&\n\t    !memcmp(ndev->hci_dev->init_data.session_id, skb->data, skb->len) &&\n\t    ndev->ops->hci_load_session) {\n\t\t \n\t\tr = ndev->ops->hci_load_session(ndev);\n\t} else {\n\t\tr = nci_hci_clear_all_pipes(ndev);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tr = nci_hci_dev_connect_gates(ndev,\n\t\t\t\t\t      ndev->hci_dev->init_data.gate_count,\n\t\t\t\t\t      ndev->hci_dev->init_data.gates);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tr = nci_hci_set_param(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\t\t      NCI_HCI_ADMIN_PARAM_SESSION_IDENTITY,\n\t\t\t\t      ndev->hci_dev->init_data.session_id,\n\t\t\t\t      strlen(ndev->hci_dev->init_data.session_id));\n\t}\n\nexit:\n\tkfree_skb(skb);\n\n\treturn r;\n}\nEXPORT_SYMBOL(nci_hci_dev_session_init);\n\nstruct nci_hci_dev *nci_hci_allocate(struct nci_dev *ndev)\n{\n\tstruct nci_hci_dev *hdev;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn NULL;\n\n\tskb_queue_head_init(&hdev->rx_hcp_frags);\n\tINIT_WORK(&hdev->msg_rx_work, nci_hci_msg_rx_work);\n\tskb_queue_head_init(&hdev->msg_rx_queue);\n\thdev->ndev = ndev;\n\n\treturn hdev;\n}\n\nvoid nci_hci_deallocate(struct nci_dev *ndev)\n{\n\tkfree(ndev->hci_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}