{
  "module_name": "ntf.c",
  "hash_id": "925bbf85d5a9a03a14837275330e84d0dfd8f1b3ae5c68da15925661c894563f",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/ntf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n\n#include \"../nfc.h\"\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include <linux/nfc.h>\n\n \n\nstatic void nci_core_reset_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t      const struct sk_buff *skb)\n{\n\t \n\tconst struct nci_core_reset_ntf *ntf = (void *)skb->data;\n\n\tndev->nci_ver = ntf->nci_ver;\n\tpr_debug(\"nci_ver 0x%x, config_status 0x%x\\n\",\n\t\t ntf->nci_ver, ntf->config_status);\n\n\tndev->manufact_id = ntf->manufact_id;\n\tndev->manufact_specific_info =\n\t\t__le32_to_cpu(ntf->manufact_specific_info);\n\n\tnci_req_complete(ndev, NCI_STATUS_OK);\n}\n\nstatic void nci_core_conn_credits_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct nci_core_conn_credit_ntf *ntf = (void *) skb->data;\n\tstruct nci_conn_info *conn_info;\n\tint i;\n\n\tpr_debug(\"num_entries %d\\n\", ntf->num_entries);\n\n\tif (ntf->num_entries > NCI_MAX_NUM_CONN)\n\t\tntf->num_entries = NCI_MAX_NUM_CONN;\n\n\t \n\tfor (i = 0; i < ntf->num_entries; i++) {\n\t\tntf->conn_entries[i].conn_id =\n\t\t\tnci_conn_id(&ntf->conn_entries[i].conn_id);\n\n\t\tpr_debug(\"entry[%d]: conn_id %d, credits %d\\n\",\n\t\t\t i, ntf->conn_entries[i].conn_id,\n\t\t\t ntf->conn_entries[i].credits);\n\n\t\tconn_info = nci_get_conn_info_by_conn_id(ndev,\n\t\t\t\t\t\t\t ntf->conn_entries[i].conn_id);\n\t\tif (!conn_info)\n\t\t\treturn;\n\n\t\tatomic_add(ntf->conn_entries[i].credits,\n\t\t\t   &conn_info->credits_cnt);\n\t}\n\n\t \n\tif (!skb_queue_empty(&ndev->tx_q))\n\t\tqueue_work(ndev->tx_wq, &ndev->tx_work);\n}\n\nstatic void nci_core_generic_error_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t      const struct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\n\tpr_debug(\"status 0x%x\\n\", status);\n\n\tif (atomic_read(&ndev->state) == NCI_W4_HOST_SELECT) {\n\t\t \n\t\tnci_req_complete(ndev, status);\n\t}\n}\n\nstatic void nci_core_conn_intf_error_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nci_core_intf_error_ntf *ntf = (void *) skb->data;\n\n\tntf->conn_id = nci_conn_id(&ntf->conn_id);\n\n\tpr_debug(\"status 0x%x, conn_id %d\\n\", ntf->status, ntf->conn_id);\n\n\t \n\tif (test_bit(NCI_DATA_EXCHANGE, &ndev->flags))\n\t\tnci_data_exchange_complete(ndev, NULL, ntf->conn_id, -EIO);\n}\n\nstatic const __u8 *\nnci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\tconst __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__le16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}\n\nstatic const __u8 *\nnci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\tconst __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}\n\nstatic const __u8 *\nnci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\tconst __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}\n\nstatic const __u8 *\nnci_extract_rf_params_nfcv_passive_poll(struct nci_dev *ndev,\n\t\t\t\t\tstruct rf_tech_specific_params_nfcv_poll *nfcv_poll,\n\t\t\t\t\tconst __u8 *data)\n{\n\t++data;\n\tnfcv_poll->dsfid = *data++;\n\tmemcpy(nfcv_poll->uid, data, NFC_ISO15693_UID_MAXSIZE);\n\tdata += NFC_ISO15693_UID_MAXSIZE;\n\treturn data;\n}\n\nstatic const __u8 *\nnci_extract_rf_params_nfcf_passive_listen(struct nci_dev *ndev,\n\t\t\t\t\t  struct rf_tech_specific_params_nfcf_listen *nfcf_listen,\n\t\t\t\t\t  const __u8 *data)\n{\n\tnfcf_listen->local_nfcid2_len = min_t(__u8, *data++,\n\t\t\t\t\t      NFC_NFCID2_MAXSIZE);\n\tmemcpy(nfcf_listen->local_nfcid2, data, nfcf_listen->local_nfcid2_len);\n\tdata += nfcf_listen->local_nfcid2_len;\n\n\treturn data;\n}\n\nstatic __u32 nci_get_prop_rf_protocol(struct nci_dev *ndev, __u8 rf_protocol)\n{\n\tif (ndev->ops->get_rfprotocol)\n\t\treturn ndev->ops->get_rfprotocol(ndev, rf_protocol);\n\treturn 0;\n}\n\nstatic int nci_add_new_protocol(struct nci_dev *ndev,\n\t\t\t\tstruct nfc_target *target,\n\t\t\t\t__u8 rf_protocol,\n\t\t\t\t__u8 rf_tech_and_mode,\n\t\t\t\tconst void *params)\n{\n\tconst struct rf_tech_specific_params_nfca_poll *nfca_poll;\n\tconst struct rf_tech_specific_params_nfcb_poll *nfcb_poll;\n\tconst struct rf_tech_specific_params_nfcf_poll *nfcf_poll;\n\tconst struct rf_tech_specific_params_nfcv_poll *nfcv_poll;\n\t__u32 protocol;\n\n\tif (rf_protocol == NCI_RF_PROTOCOL_T1T)\n\t\tprotocol = NFC_PROTO_JEWEL_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_T2T)\n\t\tprotocol = NFC_PROTO_MIFARE_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_ISO_DEP)\n\t\tif (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE)\n\t\t\tprotocol = NFC_PROTO_ISO14443_MASK;\n\t\telse\n\t\t\tprotocol = NFC_PROTO_ISO14443_B_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_T3T)\n\t\tprotocol = NFC_PROTO_FELICA_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_NFC_DEP)\n\t\tprotocol = NFC_PROTO_NFC_DEP_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_T5T)\n\t\tprotocol = NFC_PROTO_ISO15693_MASK;\n\telse\n\t\tprotocol = nci_get_prop_rf_protocol(ndev, rf_protocol);\n\n\tif (!(protocol & ndev->poll_prots)) {\n\t\tpr_err(\"the target found does not have the desired protocol\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE) {\n\t\tnfca_poll = (struct rf_tech_specific_params_nfca_poll *)params;\n\n\t\ttarget->sens_res = nfca_poll->sens_res;\n\t\ttarget->sel_res = nfca_poll->sel_res;\n\t\ttarget->nfcid1_len = nfca_poll->nfcid1_len;\n\t\tif (target->nfcid1_len > ARRAY_SIZE(target->nfcid1))\n\t\t\treturn -EPROTO;\n\t\tif (target->nfcid1_len > 0) {\n\t\t\tmemcpy(target->nfcid1, nfca_poll->nfcid1,\n\t\t\t       target->nfcid1_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_B_PASSIVE_POLL_MODE) {\n\t\tnfcb_poll = (struct rf_tech_specific_params_nfcb_poll *)params;\n\n\t\ttarget->sensb_res_len = nfcb_poll->sensb_res_len;\n\t\tif (target->sensb_res_len > ARRAY_SIZE(target->sensb_res))\n\t\t\treturn -EPROTO;\n\t\tif (target->sensb_res_len > 0) {\n\t\t\tmemcpy(target->sensb_res, nfcb_poll->sensb_res,\n\t\t\t       target->sensb_res_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_F_PASSIVE_POLL_MODE) {\n\t\tnfcf_poll = (struct rf_tech_specific_params_nfcf_poll *)params;\n\n\t\ttarget->sensf_res_len = nfcf_poll->sensf_res_len;\n\t\tif (target->sensf_res_len > ARRAY_SIZE(target->sensf_res))\n\t\t\treturn -EPROTO;\n\t\tif (target->sensf_res_len > 0) {\n\t\t\tmemcpy(target->sensf_res, nfcf_poll->sensf_res,\n\t\t\t       target->sensf_res_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_V_PASSIVE_POLL_MODE) {\n\t\tnfcv_poll = (struct rf_tech_specific_params_nfcv_poll *)params;\n\n\t\ttarget->is_iso15693 = 1;\n\t\ttarget->iso15693_dsfid = nfcv_poll->dsfid;\n\t\tmemcpy(target->iso15693_uid, nfcv_poll->uid, NFC_ISO15693_UID_MAXSIZE);\n\t} else {\n\t\tpr_err(\"unsupported rf_tech_and_mode 0x%x\\n\", rf_tech_and_mode);\n\t\treturn -EPROTO;\n\t}\n\n\ttarget->supported_protocols |= protocol;\n\n\tpr_debug(\"protocol 0x%x\\n\", protocol);\n\n\treturn 0;\n}\n\nstatic void nci_add_new_target(struct nci_dev *ndev,\n\t\t\t       const struct nci_rf_discover_ntf *ntf)\n{\n\tstruct nfc_target *target;\n\tint i, rc;\n\n\tfor (i = 0; i < ndev->n_targets; i++) {\n\t\ttarget = &ndev->targets[i];\n\t\tif (target->logical_idx == ntf->rf_discovery_id) {\n\t\t\t \n\t\t\tnci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t\t     ntf->rf_tech_and_mode,\n\t\t\t\t\t     &ntf->rf_tech_specific_params);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (ndev->n_targets == NCI_MAX_DISCOVERED_TARGETS) {\n\t\tpr_debug(\"not enough room, ignoring new target...\\n\");\n\t\treturn;\n\t}\n\n\ttarget = &ndev->targets[ndev->n_targets];\n\n\trc = nci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t  ntf->rf_tech_and_mode,\n\t\t\t\t  &ntf->rf_tech_specific_params);\n\tif (!rc) {\n\t\ttarget->logical_idx = ntf->rf_discovery_id;\n\t\tndev->n_targets++;\n\n\t\tpr_debug(\"logical idx %d, n_targets %d\\n\", target->logical_idx,\n\t\t\t ndev->n_targets);\n\t}\n}\n\nvoid nci_clear_target_list(struct nci_dev *ndev)\n{\n\tmemset(ndev->targets, 0,\n\t       (sizeof(struct nfc_target)*NCI_MAX_DISCOVERED_TARGETS));\n\n\tndev->n_targets = 0;\n}\n\nstatic void nci_rf_discover_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\tstruct nci_rf_discover_ntf ntf;\n\tconst __u8 *data = skb->data;\n\tbool add_target = true;\n\n\tntf.rf_discovery_id = *data++;\n\tntf.rf_protocol = *data++;\n\tntf.rf_tech_and_mode = *data++;\n\tntf.rf_tech_specific_params_len = *data++;\n\n\tpr_debug(\"rf_discovery_id %d\\n\", ntf.rf_discovery_id);\n\tpr_debug(\"rf_protocol 0x%x\\n\", ntf.rf_protocol);\n\tpr_debug(\"rf_tech_and_mode 0x%x\\n\", ntf.rf_tech_and_mode);\n\tpr_debug(\"rf_tech_specific_params_len %d\\n\",\n\t\t ntf.rf_tech_specific_params_len);\n\n\tif (ntf.rf_tech_specific_params_len > 0) {\n\t\tswitch (ntf.rf_tech_and_mode) {\n\t\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfca_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfca_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcb_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcb_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_F_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcf_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcf_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_V_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcv_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcv_poll), data);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"unsupported rf_tech_and_mode 0x%x\\n\",\n\t\t\t       ntf.rf_tech_and_mode);\n\t\t\tdata += ntf.rf_tech_specific_params_len;\n\t\t\tadd_target = false;\n\t\t}\n\t}\n\n\tntf.ntf_type = *data++;\n\tpr_debug(\"ntf_type %d\\n\", ntf.ntf_type);\n\n\tif (add_target == true)\n\t\tnci_add_new_target(ndev, &ntf);\n\n\tif (ntf.ntf_type == NCI_DISCOVER_NTF_TYPE_MORE) {\n\t\tatomic_set(&ndev->state, NCI_W4_ALL_DISCOVERIES);\n\t} else {\n\t\tatomic_set(&ndev->state, NCI_W4_HOST_SELECT);\n\t\tnfc_targets_found(ndev->nfc_dev, ndev->targets,\n\t\t\t\t  ndev->n_targets);\n\t}\n}\n\nstatic int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\t\t\t\t struct nci_rf_intf_activated_ntf *ntf,\n\t\t\t\t\t\t const __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = min_t(__u8, *data++, 20);\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = min_t(__u8, *data++, 50);\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\n\treturn NCI_STATUS_OK;\n}\n\nstatic int nci_extract_activation_params_nfc_dep(struct nci_dev *ndev,\n\t\t\t\t\t\t struct nci_rf_intf_activated_ntf *ntf,\n\t\t\t\t\t\t const __u8 *data)\n{\n\tstruct activation_params_poll_nfc_dep *poll;\n\tstruct activation_params_listen_nfc_dep *listen;\n\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\tcase NCI_NFC_F_PASSIVE_POLL_MODE:\n\t\tpoll = &ntf->activation_params.poll_nfc_dep;\n\t\tpoll->atr_res_len = min_t(__u8, *data++,\n\t\t\t\t\t  NFC_ATR_RES_MAXSIZE - 2);\n\t\tpr_debug(\"atr_res_len %d\\n\", poll->atr_res_len);\n\t\tif (poll->atr_res_len > 0)\n\t\t\tmemcpy(poll->atr_res, data, poll->atr_res_len);\n\t\tbreak;\n\n\tcase NCI_NFC_A_PASSIVE_LISTEN_MODE:\n\tcase NCI_NFC_F_PASSIVE_LISTEN_MODE:\n\t\tlisten = &ntf->activation_params.listen_nfc_dep;\n\t\tlisten->atr_req_len = min_t(__u8, *data++,\n\t\t\t\t\t    NFC_ATR_REQ_MAXSIZE - 2);\n\t\tpr_debug(\"atr_req_len %d\\n\", listen->atr_req_len);\n\t\tif (listen->atr_req_len > 0)\n\t\t\tmemcpy(listen->atr_req, data, listen->atr_req_len);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\n\treturn NCI_STATUS_OK;\n}\n\nstatic void nci_target_auto_activated(struct nci_dev *ndev,\n\t\t\t\t      const struct nci_rf_intf_activated_ntf *ntf)\n{\n\tstruct nfc_target *target;\n\tint rc;\n\n\ttarget = &ndev->targets[ndev->n_targets];\n\n\trc = nci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t  ntf->activation_rf_tech_and_mode,\n\t\t\t\t  &ntf->rf_tech_specific_params);\n\tif (rc)\n\t\treturn;\n\n\ttarget->logical_idx = ntf->rf_discovery_id;\n\tndev->n_targets++;\n\n\tpr_debug(\"logical idx %d, n_targets %d\\n\",\n\t\t target->logical_idx, ndev->n_targets);\n\n\tnfc_targets_found(ndev->nfc_dev, ndev->targets, ndev->n_targets);\n}\n\nstatic int nci_store_general_bytes_nfc_dep(struct nci_dev *ndev,\n\t\t\t\t\t   const struct nci_rf_intf_activated_ntf *ntf)\n{\n\tndev->remote_gb_len = 0;\n\n\tif (ntf->activation_params_len <= 0)\n\t\treturn NCI_STATUS_OK;\n\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\tcase NCI_NFC_F_PASSIVE_POLL_MODE:\n\t\tndev->remote_gb_len = min_t(__u8,\n\t\t\t(ntf->activation_params.poll_nfc_dep.atr_res_len\n\t\t\t\t\t\t- NFC_ATR_RES_GT_OFFSET),\n\t\t\tNFC_ATR_RES_GB_MAXSIZE);\n\t\tmemcpy(ndev->remote_gb,\n\t\t       (ntf->activation_params.poll_nfc_dep.atr_res\n\t\t\t\t\t\t+ NFC_ATR_RES_GT_OFFSET),\n\t\t       ndev->remote_gb_len);\n\t\tbreak;\n\n\tcase NCI_NFC_A_PASSIVE_LISTEN_MODE:\n\tcase NCI_NFC_F_PASSIVE_LISTEN_MODE:\n\t\tndev->remote_gb_len = min_t(__u8,\n\t\t\t(ntf->activation_params.listen_nfc_dep.atr_req_len\n\t\t\t\t\t\t- NFC_ATR_REQ_GT_OFFSET),\n\t\t\tNFC_ATR_REQ_GB_MAXSIZE);\n\t\tmemcpy(ndev->remote_gb,\n\t\t       (ntf->activation_params.listen_nfc_dep.atr_req\n\t\t\t\t\t\t+ NFC_ATR_REQ_GT_OFFSET),\n\t\t       ndev->remote_gb_len);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\n\treturn NCI_STATUS_OK;\n}\n\nstatic void nci_rf_intf_activated_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t     const struct sk_buff *skb)\n{\n\tstruct nci_conn_info *conn_info;\n\tstruct nci_rf_intf_activated_ntf ntf;\n\tconst __u8 *data = skb->data;\n\tint err = NCI_STATUS_OK;\n\n\tntf.rf_discovery_id = *data++;\n\tntf.rf_interface = *data++;\n\tntf.rf_protocol = *data++;\n\tntf.activation_rf_tech_and_mode = *data++;\n\tntf.max_data_pkt_payload_size = *data++;\n\tntf.initial_num_credits = *data++;\n\tntf.rf_tech_specific_params_len = *data++;\n\n\tpr_debug(\"rf_discovery_id %d\\n\", ntf.rf_discovery_id);\n\tpr_debug(\"rf_interface 0x%x\\n\", ntf.rf_interface);\n\tpr_debug(\"rf_protocol 0x%x\\n\", ntf.rf_protocol);\n\tpr_debug(\"activation_rf_tech_and_mode 0x%x\\n\",\n\t\t ntf.activation_rf_tech_and_mode);\n\tpr_debug(\"max_data_pkt_payload_size 0x%x\\n\",\n\t\t ntf.max_data_pkt_payload_size);\n\tpr_debug(\"initial_num_credits 0x%x\\n\",\n\t\t ntf.initial_num_credits);\n\tpr_debug(\"rf_tech_specific_params_len %d\\n\",\n\t\t ntf.rf_tech_specific_params_len);\n\n\t \n\tif (ntf.rf_interface == NCI_RF_INTERFACE_NFCEE_DIRECT)\n\t\tgoto listen;\n\n\tif (ntf.rf_tech_specific_params_len > 0) {\n\t\tswitch (ntf.activation_rf_tech_and_mode) {\n\t\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfca_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfca_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcb_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcb_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_F_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcf_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcf_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_V_PASSIVE_POLL_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcv_passive_poll(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcv_poll), data);\n\t\t\tbreak;\n\n\t\tcase NCI_NFC_A_PASSIVE_LISTEN_MODE:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase NCI_NFC_F_PASSIVE_LISTEN_MODE:\n\t\t\tdata = nci_extract_rf_params_nfcf_passive_listen(ndev,\n\t\t\t\t&(ntf.rf_tech_specific_params.nfcf_listen),\n\t\t\t\tdata);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t\t       ntf.activation_rf_tech_and_mode);\n\t\t\terr = NCI_STATUS_RF_PROTOCOL_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tntf.data_exch_rf_tech_and_mode = *data++;\n\tntf.data_exch_tx_bit_rate = *data++;\n\tntf.data_exch_rx_bit_rate = *data++;\n\tntf.activation_params_len = *data++;\n\n\tpr_debug(\"data_exch_rf_tech_and_mode 0x%x\\n\",\n\t\t ntf.data_exch_rf_tech_and_mode);\n\tpr_debug(\"data_exch_tx_bit_rate 0x%x\\n\", ntf.data_exch_tx_bit_rate);\n\tpr_debug(\"data_exch_rx_bit_rate 0x%x\\n\", ntf.data_exch_rx_bit_rate);\n\tpr_debug(\"activation_params_len %d\\n\", ntf.activation_params_len);\n\n\tif (ntf.activation_params_len > 0) {\n\t\tswitch (ntf.rf_interface) {\n\t\tcase NCI_RF_INTERFACE_ISO_DEP:\n\t\t\terr = nci_extract_activation_params_iso_dep(ndev,\n\t\t\t\t\t\t\t\t    &ntf, data);\n\t\t\tbreak;\n\n\t\tcase NCI_RF_INTERFACE_NFC_DEP:\n\t\t\terr = nci_extract_activation_params_nfc_dep(ndev,\n\t\t\t\t\t\t\t\t    &ntf, data);\n\t\t\tbreak;\n\n\t\tcase NCI_RF_INTERFACE_FRAME:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"unsupported rf_interface 0x%x\\n\",\n\t\t\t       ntf.rf_interface);\n\t\t\terr = NCI_STATUS_RF_PROTOCOL_ERROR;\n\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tif (err == NCI_STATUS_OK) {\n\t\tconn_info = ndev->rf_conn_info;\n\t\tif (!conn_info)\n\t\t\treturn;\n\n\t\tconn_info->max_pkt_payload_len = ntf.max_data_pkt_payload_size;\n\t\tconn_info->initial_num_credits = ntf.initial_num_credits;\n\n\t\t \n\t\tatomic_set(&conn_info->credits_cnt,\n\t\t\t   conn_info->initial_num_credits);\n\n\t\t \n\t\tif (ntf.rf_interface == NCI_RF_INTERFACE_NFC_DEP) {\n\t\t\terr = nci_store_general_bytes_nfc_dep(ndev, &ntf);\n\t\t\tif (err != NCI_STATUS_OK)\n\t\t\t\tpr_err(\"unable to store general bytes\\n\");\n\t\t}\n\t}\n\n\tif (!(ntf.activation_rf_tech_and_mode & NCI_RF_TECH_MODE_LISTEN_MASK)) {\n\t\t \n\t\tif (atomic_read(&ndev->state) == NCI_DISCOVERY) {\n\t\t\t \n\t\t\tatomic_set(&ndev->state, NCI_POLL_ACTIVE);\n\t\t\tif (err == NCI_STATUS_OK)\n\t\t\t\tnci_target_auto_activated(ndev, &ntf);\n\t\t} else {\t \n\t\t\t \n\t\t\tatomic_set(&ndev->state, NCI_POLL_ACTIVE);\n\t\t\tnci_req_complete(ndev, err);\n\t\t}\n\t} else {\nlisten:\n\t\t \n\t\tatomic_set(&ndev->state, NCI_LISTEN_ACTIVE);\n\t\tif (err == NCI_STATUS_OK &&\n\t\t    ntf.rf_protocol == NCI_RF_PROTOCOL_NFC_DEP) {\n\t\t\terr = nfc_tm_activated(ndev->nfc_dev,\n\t\t\t\t\t       NFC_PROTO_NFC_DEP_MASK,\n\t\t\t\t\t       NFC_COMM_PASSIVE,\n\t\t\t\t\t       ndev->remote_gb,\n\t\t\t\t\t       ndev->remote_gb_len);\n\t\t\tif (err != NCI_STATUS_OK)\n\t\t\t\tpr_err(\"error when signaling tm activation\\n\");\n\t\t}\n\t}\n}\n\nstatic void nci_rf_deactivate_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t const struct sk_buff *skb)\n{\n\tconst struct nci_conn_info *conn_info;\n\tconst struct nci_rf_deactivate_ntf *ntf = (void *)skb->data;\n\n\tpr_debug(\"entry, type 0x%x, reason 0x%x\\n\", ntf->type, ntf->reason);\n\n\tconn_info = ndev->rf_conn_info;\n\tif (!conn_info)\n\t\treturn;\n\n\t \n\tskb_queue_purge(&ndev->tx_q);\n\n\t \n\tif (ndev->rx_data_reassembly) {\n\t\tkfree_skb(ndev->rx_data_reassembly);\n\t\tndev->rx_data_reassembly = NULL;\n\t}\n\n\t \n\tif (test_bit(NCI_DATA_EXCHANGE, &ndev->flags))\n\t\tnci_data_exchange_complete(ndev, NULL, NCI_STATIC_RF_CONN_ID,\n\t\t\t\t\t   -EIO);\n\n\tswitch (ntf->type) {\n\tcase NCI_DEACTIVATE_TYPE_IDLE_MODE:\n\t\tnci_clear_target_list(ndev);\n\t\tatomic_set(&ndev->state, NCI_IDLE);\n\t\tbreak;\n\tcase NCI_DEACTIVATE_TYPE_SLEEP_MODE:\n\tcase NCI_DEACTIVATE_TYPE_SLEEP_AF_MODE:\n\t\tatomic_set(&ndev->state, NCI_W4_HOST_SELECT);\n\t\tbreak;\n\tcase NCI_DEACTIVATE_TYPE_DISCOVERY:\n\t\tnci_clear_target_list(ndev);\n\t\tatomic_set(&ndev->state, NCI_DISCOVERY);\n\t\tbreak;\n\t}\n\n\tnci_req_complete(ndev, NCI_STATUS_OK);\n}\n\nstatic void nci_nfcee_discover_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tu8 status = NCI_STATUS_OK;\n\tconst struct nci_nfcee_discover_ntf *nfcee_ntf =\n\t\t\t\t(struct nci_nfcee_discover_ntf *)skb->data;\n\n\t \n\tndev->hci_dev->nfcee_id = nfcee_ntf->nfcee_id;\n\tndev->cur_params.id = nfcee_ntf->nfcee_id;\n\n\tnci_req_complete(ndev, status);\n}\n\nvoid nci_ntf_packet(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\t__u16 ntf_opcode = nci_opcode(skb->data);\n\n\tpr_debug(\"NCI RX: MT=ntf, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\\n\",\n\t\t nci_pbf(skb->data),\n\t\t nci_opcode_gid(ntf_opcode),\n\t\t nci_opcode_oid(ntf_opcode),\n\t\t nci_plen(skb->data));\n\n\t \n\tskb_pull(skb, NCI_CTRL_HDR_SIZE);\n\n\tif (nci_opcode_gid(ntf_opcode) == NCI_GID_PROPRIETARY) {\n\t\tif (nci_prop_ntf_packet(ndev, ntf_opcode, skb) == -ENOTSUPP) {\n\t\t\tpr_err(\"unsupported ntf opcode 0x%x\\n\",\n\t\t\t       ntf_opcode);\n\t\t}\n\n\t\tgoto end;\n\t}\n\n\tswitch (ntf_opcode) {\n\tcase NCI_OP_CORE_RESET_NTF:\n\t\tnci_core_reset_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_CONN_CREDITS_NTF:\n\t\tnci_core_conn_credits_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_GENERIC_ERROR_NTF:\n\t\tnci_core_generic_error_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_CORE_INTF_ERROR_NTF:\n\t\tnci_core_conn_intf_error_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_DISCOVER_NTF:\n\t\tnci_rf_discover_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_INTF_ACTIVATED_NTF:\n\t\tnci_rf_intf_activated_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_DEACTIVATE_NTF:\n\t\tnci_rf_deactivate_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_NFCEE_DISCOVER_NTF:\n\t\tnci_nfcee_discover_ntf_packet(ndev, skb);\n\t\tbreak;\n\n\tcase NCI_OP_RF_NFCEE_ACTION_NTF:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"unknown ntf opcode 0x%x\\n\", ntf_opcode);\n\t\tbreak;\n\t}\n\n\tnci_core_ntf_packet(ndev, ntf_opcode, skb);\nend:\n\tkfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}