{
  "module_name": "spi.c",
  "hash_id": "a29d6a7e33abd45e223dbcbe2499707887273462c9fd087d326c0a71450aa530",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/spi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"nci_spi: %s: \" fmt, __func__\n\n#include <linux/module.h>\n\n#include <linux/export.h>\n#include <linux/spi/spi.h>\n#include <linux/crc-ccitt.h>\n#include <net/nfc/nci_core.h>\n\n#define NCI_SPI_ACK_SHIFT\t\t6\n#define NCI_SPI_MSB_PAYLOAD_MASK\t0x3F\n\n#define NCI_SPI_SEND_TIMEOUT\t(NCI_CMD_TIMEOUT > NCI_DATA_TIMEOUT ? \\\n\t\t\t\t\tNCI_CMD_TIMEOUT : NCI_DATA_TIMEOUT)\n\n#define NCI_SPI_DIRECT_WRITE\t0x01\n#define NCI_SPI_DIRECT_READ\t0x02\n\n#define ACKNOWLEDGE_NONE\t0\n#define ACKNOWLEDGE_ACK\t\t1\n#define ACKNOWLEDGE_NACK\t2\n\n#define CRC_INIT\t\t0xFFFF\n\nstatic int __nci_spi_send(struct nci_spi *nspi, const struct sk_buff *skb,\n\t\t\t  int cs_change)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\n\tmemset(&t, 0, sizeof(struct spi_transfer));\n\t \n\tif (skb) {\n\t\tt.tx_buf = skb->data;\n\t\tt.len = skb->len;\n\t} else {\n\t\t \n\t\tt.tx_buf = &t;\n\t\tt.len = 0;\n\t}\n\tt.cs_change = cs_change;\n\tt.delay.value = nspi->xfer_udelay;\n\tt.delay.unit = SPI_DELAY_UNIT_USECS;\n\tt.speed_hz = nspi->xfer_speed_hz;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\n\treturn spi_sync(nspi->spi, &m);\n}\n\nint nci_spi_send(struct nci_spi *nspi,\n\t\t struct completion *write_handshake_completion,\n\t\t struct sk_buff *skb)\n{\n\tunsigned int payload_len = skb->len;\n\tunsigned char *hdr;\n\tint ret;\n\tlong completion_rc;\n\n\t \n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = nspi->acknowledge_mode;\n\thdr[2] = payload_len >> 8;\n\thdr[3] = payload_len & 0xFF;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tu16 crc;\n\n\t\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\t\tskb_put_u8(skb, crc >> 8);\n\t\tskb_put_u8(skb, crc & 0xFF);\n\t}\n\n\tif (write_handshake_completion)\t{\n\t\t \n\t\tret = __nci_spi_send(nspi, NULL, 1);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\t \n\t\tif (wait_for_completion_timeout(write_handshake_completion,\n\t\t\t\t\t\tmsecs_to_jiffies(1000)) == 0) {\n\t\t\tret = -ETIME;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\tif (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)\n\t\tgoto done;\n\n\treinit_completion(&nspi->req_completion);\n\tcompletion_rc =\twait_for_completion_interruptible_timeout(\n\t\t\t\t\t\t\t&nspi->req_completion,\n\t\t\t\t\t\t\tNCI_SPI_SEND_TIMEOUT);\n\n\tif (completion_rc <= 0 || nspi->req_result == ACKNOWLEDGE_NACK)\n\t\tret = -EIO;\n\ndone:\n\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nci_spi_send);\n\n \n\n \nstruct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,\n\t\t\t\t     u8 acknowledge_mode, unsigned int delay,\n\t\t\t\t     struct nci_dev *ndev)\n{\n\tstruct nci_spi *nspi;\n\n\tnspi = devm_kzalloc(&spi->dev, sizeof(struct nci_spi), GFP_KERNEL);\n\tif (!nspi)\n\t\treturn NULL;\n\n\tnspi->acknowledge_mode = acknowledge_mode;\n\tnspi->xfer_udelay = delay;\n\t \n\tnspi->xfer_speed_hz = 0;\n\tnspi->spi = spi;\n\tnspi->ndev = ndev;\n\tinit_completion(&nspi->req_completion);\n\n\treturn nspi;\n}\nEXPORT_SYMBOL_GPL(nci_spi_allocate_spi);\n\nstatic int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\n\tret = __nci_spi_send(nspi, skb, 0);\n\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic struct sk_buff *__nci_spi_read(struct nci_spi *nspi)\n{\n\tstruct sk_buff *skb;\n\tstruct spi_message m;\n\tunsigned char req[2], resp_hdr[2];\n\tstruct spi_transfer tx, rx;\n\tunsigned short rx_len = 0;\n\tint ret;\n\n\tspi_message_init(&m);\n\n\tmemset(&tx, 0, sizeof(struct spi_transfer));\n\treq[0] = NCI_SPI_DIRECT_READ;\n\treq[1] = nspi->acknowledge_mode;\n\ttx.tx_buf = req;\n\ttx.len = 2;\n\ttx.cs_change = 0;\n\ttx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&tx, &m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = resp_hdr;\n\trx.len = 2;\n\trx.cs_change = 1;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\treturn NULL;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\trx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +\n\t\t\t\tresp_hdr[1] + NCI_SPI_CRC_LEN;\n\telse\n\t\trx_len = (resp_hdr[0] << 8) | resp_hdr[1];\n\n\tskb = nci_skb_alloc(nspi->ndev, rx_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tspi_message_init(&m);\n\n\tmemset(&rx, 0, sizeof(struct spi_transfer));\n\trx.rx_buf = skb_put(skb, rx_len);\n\trx.len = rx_len;\n\trx.cs_change = 0;\n\trx.delay.value = nspi->xfer_udelay;\n\trx.delay.unit = SPI_DELAY_UNIT_USECS;\n\trx.speed_hz = nspi->xfer_speed_hz;\n\tspi_message_add_tail(&rx, &m);\n\n\tret = spi_sync(nspi->spi, &m);\n\tif (ret)\n\t\tgoto receive_error;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\t*(u8 *)skb_push(skb, 1) = resp_hdr[1];\n\t\t*(u8 *)skb_push(skb, 1) = resp_hdr[0];\n\t}\n\n\treturn skb;\n\nreceive_error:\n\tkfree_skb(skb);\n\n\treturn NULL;\n}\n\nstatic int nci_spi_check_crc(struct sk_buff *skb)\n{\n\tu16 crc_data = (skb->data[skb->len - 2] << 8) |\n\t\t\tskb->data[skb->len - 1];\n\tint ret;\n\n\tret = (crc_ccitt(CRC_INIT, skb->data, skb->len - NCI_SPI_CRC_LEN)\n\t\t\t== crc_data);\n\n\tskb_trim(skb, skb->len - NCI_SPI_CRC_LEN);\n\n\treturn ret;\n}\n\nstatic u8 nci_spi_get_ack(struct sk_buff *skb)\n{\n\tu8 ret;\n\n\tret = skb->data[0] >> NCI_SPI_ACK_SHIFT;\n\n\t \n\tskb_pull(skb, 2);\n\n\treturn ret;\n}\n\n \nstruct sk_buff *nci_spi_read(struct nci_spi *nspi)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __nci_spi_read(nspi);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {\n\t\tif (!nci_spi_check_crc(skb)) {\n\t\t\tsend_acknowledge(nspi, ACKNOWLEDGE_NACK);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tnspi->req_result = nci_spi_get_ack(skb);\n\t\tif (nspi->req_result)\n\t\t\tcomplete(&nspi->req_completion);\n\t}\n\n\t \n\tif (!skb->len) {\n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t\tgoto done;\n\t}\n\n\tif (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)\n\t\tsend_acknowledge(nspi, ACKNOWLEDGE_ACK);\n\ndone:\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(nci_spi_read);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}