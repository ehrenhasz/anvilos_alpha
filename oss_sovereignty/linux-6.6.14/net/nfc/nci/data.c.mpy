{
  "module_name": "data.c",
  "hash_id": "99438c135a8546f145b3db6934e280303fc46a0d6ae685e63859391ec21de436",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/data.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n\n#include \"../nfc.h\"\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include <linux/nfc.h>\n\n \nvoid nci_data_exchange_complete(struct nci_dev *ndev, struct sk_buff *skb,\n\t\t\t\t__u8 conn_id, int err)\n{\n\tconst struct nci_conn_info *conn_info;\n\tdata_exchange_cb_t cb;\n\tvoid *cb_context;\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, conn_id);\n\tif (!conn_info) {\n\t\tkfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tcb = conn_info->data_exchange_cb;\n\tcb_context = conn_info->data_exchange_cb_context;\n\n\tpr_debug(\"len %d, err %d\\n\", skb ? skb->len : 0, err);\n\n\t \n\tdel_timer_sync(&ndev->data_timer);\n\tclear_bit(NCI_DATA_EXCHANGE_TO, &ndev->flags);\n\n\tif (cb) {\n\t\t \n\t\tcb(cb_context, skb, err);\n\t} else if (skb) {\n\t\tpr_err(\"no rx callback, dropping rx data...\\n\");\n\n\t\t \n\t\tkfree_skb(skb);\n\t}\n\nexit:\n\tclear_bit(NCI_DATA_EXCHANGE, &ndev->flags);\n}\n\n \n\nstatic inline void nci_push_data_hdr(struct nci_dev *ndev,\n\t\t\t\t     __u8 conn_id,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     __u8 pbf)\n{\n\tstruct nci_data_hdr *hdr;\n\tint plen = skb->len;\n\n\thdr = skb_push(skb, NCI_DATA_HDR_SIZE);\n\thdr->conn_id = conn_id;\n\thdr->rfu = 0;\n\thdr->plen = plen;\n\n\tnci_mt_set((__u8 *)hdr, NCI_MT_DATA_PKT);\n\tnci_pbf_set((__u8 *)hdr, pbf);\n}\n\nint nci_conn_max_data_pkt_payload_size(struct nci_dev *ndev, __u8 conn_id)\n{\n\tconst struct nci_conn_info *conn_info;\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, conn_id);\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\treturn conn_info->max_pkt_payload_len;\n}\nEXPORT_SYMBOL(nci_conn_max_data_pkt_payload_size);\n\nstatic int nci_queue_tx_data_frags(struct nci_dev *ndev,\n\t\t\t\t   __u8 conn_id,\n\t\t\t\t   struct sk_buff *skb) {\n\tconst struct nci_conn_info *conn_info;\n\tint total_len = skb->len;\n\tconst unsigned char *data = skb->data;\n\tunsigned long flags;\n\tstruct sk_buff_head frags_q;\n\tstruct sk_buff *skb_frag;\n\tint frag_len;\n\tint rc = 0;\n\n\tpr_debug(\"conn_id 0x%x, total_len %d\\n\", conn_id, total_len);\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, conn_id);\n\tif (!conn_info) {\n\t\trc = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\t__skb_queue_head_init(&frags_q);\n\n\twhile (total_len) {\n\t\tfrag_len =\n\t\t\tmin_t(int, total_len, conn_info->max_pkt_payload_len);\n\n\t\tskb_frag = nci_skb_alloc(ndev,\n\t\t\t\t\t (NCI_DATA_HDR_SIZE + frag_len),\n\t\t\t\t\t GFP_ATOMIC);\n\t\tif (skb_frag == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_exit;\n\t\t}\n\t\tskb_reserve(skb_frag, NCI_DATA_HDR_SIZE);\n\n\t\t \n\t\tskb_put_data(skb_frag, data, frag_len);\n\n\t\t \n\t\tnci_push_data_hdr(ndev, conn_id, skb_frag,\n\t\t\t\t  ((total_len == frag_len) ?\n\t\t\t\t   (NCI_PBF_LAST) : (NCI_PBF_CONT)));\n\n\t\t__skb_queue_tail(&frags_q, skb_frag);\n\n\t\tdata += frag_len;\n\t\ttotal_len -= frag_len;\n\n\t\tpr_debug(\"frag_len %d, remaining total_len %d\\n\",\n\t\t\t frag_len, total_len);\n\t}\n\n\t \n\tspin_lock_irqsave(&ndev->tx_q.lock, flags);\n\n\twhile ((skb_frag = __skb_dequeue(&frags_q)) != NULL)\n\t\t__skb_queue_tail(&ndev->tx_q, skb_frag);\n\n\tspin_unlock_irqrestore(&ndev->tx_q.lock, flags);\n\n\t \n\tkfree_skb(skb);\n\n\tgoto exit;\n\nfree_exit:\n\twhile ((skb_frag = __skb_dequeue(&frags_q)) != NULL)\n\t\tkfree_skb(skb_frag);\n\nexit:\n\treturn rc;\n}\n\n \nint nci_send_data(struct nci_dev *ndev, __u8 conn_id, struct sk_buff *skb)\n{\n\tconst struct nci_conn_info *conn_info;\n\tint rc = 0;\n\n\tpr_debug(\"conn_id 0x%x, plen %d\\n\", conn_id, skb->len);\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, conn_id);\n\tif (!conn_info) {\n\t\trc = -EPROTO;\n\t\tgoto free_exit;\n\t}\n\n\t \n\tif (skb->len <= conn_info->max_pkt_payload_len) {\n\t\t \n\t\tnci_push_data_hdr(ndev, conn_id, skb, NCI_PBF_LAST);\n\n\t\tskb_queue_tail(&ndev->tx_q, skb);\n\t} else {\n\t\t \n\t\trc = nci_queue_tx_data_frags(ndev, conn_id, skb);\n\t\tif (rc) {\n\t\t\tpr_err(\"failed to fragment tx data packet\\n\");\n\t\t\tgoto free_exit;\n\t\t}\n\t}\n\n\tndev->cur_conn_id = conn_id;\n\tqueue_work(ndev->tx_wq, &ndev->tx_work);\n\n\tgoto exit;\n\nfree_exit:\n\tkfree_skb(skb);\n\nexit:\n\treturn rc;\n}\nEXPORT_SYMBOL(nci_send_data);\n\n \n\nstatic void nci_add_rx_data_frag(struct nci_dev *ndev,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t __u8 pbf, __u8 conn_id, __u8 status)\n{\n\tint reassembly_len;\n\tint err = 0;\n\n\tif (status) {\n\t\terr = status;\n\t\tgoto exit;\n\t}\n\n\tif (ndev->rx_data_reassembly) {\n\t\treassembly_len = ndev->rx_data_reassembly->len;\n\n\t\t \n\t\tif (skb_cow_head(skb, reassembly_len)) {\n\t\t\tpr_err(\"error adding room for accumulated rx data\\n\");\n\n\t\t\tkfree_skb(skb);\n\t\t\tskb = NULL;\n\n\t\t\tkfree_skb(ndev->rx_data_reassembly);\n\t\t\tndev->rx_data_reassembly = NULL;\n\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tmemcpy(skb_push(skb, reassembly_len),\n\t\t       ndev->rx_data_reassembly->data,\n\t\t       reassembly_len);\n\n\t\t \n\t\tkfree_skb(ndev->rx_data_reassembly);\n\t\tndev->rx_data_reassembly = NULL;\n\t}\n\n\tif (pbf == NCI_PBF_CONT) {\n\t\t \n\t\tndev->rx_data_reassembly = skb;\n\t\treturn;\n\t}\n\nexit:\n\tif (ndev->nfc_dev->rf_mode == NFC_RF_TARGET) {\n\t\t \n\t\terr = nfc_tm_data_received(ndev->nfc_dev, skb);\n\t\tif (err)\n\t\t\tpr_err(\"unable to handle received data\\n\");\n\t} else {\n\t\tnci_data_exchange_complete(ndev, skb, conn_id, err);\n\t}\n}\n\n \nvoid nci_rx_data_packet(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\t__u8 pbf = nci_pbf(skb->data);\n\t__u8 status = 0;\n\t__u8 conn_id = nci_conn_id(skb->data);\n\tconst struct nci_conn_info *conn_info;\n\n\tpr_debug(\"len %d\\n\", skb->len);\n\n\tpr_debug(\"NCI RX: MT=data, PBF=%d, conn_id=%d, plen=%d\\n\",\n\t\t nci_pbf(skb->data),\n\t\t nci_conn_id(skb->data),\n\t\t nci_plen(skb->data));\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, nci_conn_id(skb->data));\n\tif (!conn_info) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tskb_pull(skb, NCI_DATA_HDR_SIZE);\n\n\tif (ndev->target_active_prot == NFC_PROTO_MIFARE ||\n\t    ndev->target_active_prot == NFC_PROTO_JEWEL ||\n\t    ndev->target_active_prot == NFC_PROTO_FELICA ||\n\t    ndev->target_active_prot == NFC_PROTO_ISO15693) {\n\t\t \n\t\tpr_debug(\"frame I/F => remove the status byte\\n\");\n\t\tstatus = skb->data[skb->len - 1];\n\t\tskb_trim(skb, (skb->len - 1));\n\t}\n\n\tnci_add_rx_data_frag(ndev, skb, pbf, conn_id, nci_to_errno(status));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}