{
  "module_name": "core.c",
  "hash_id": "d00e9dae1ea91a0821eec5a0777f29c3731bcc1437f0df423c8a1baa75db100f",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/nci/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/skbuff.h>\n#include <linux/kcov.h>\n\n#include \"../nfc.h\"\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include <linux/nfc.h>\n\nstruct core_conn_create_data {\n\tint length;\n\tstruct nci_core_conn_create_cmd *cmd;\n};\n\nstatic void nci_cmd_work(struct work_struct *work);\nstatic void nci_rx_work(struct work_struct *work);\nstatic void nci_tx_work(struct work_struct *work);\n\nstruct nci_conn_info *nci_get_conn_info_by_conn_id(struct nci_dev *ndev,\n\t\t\t\t\t\t   int conn_id)\n{\n\tstruct nci_conn_info *conn_info;\n\n\tlist_for_each_entry(conn_info, &ndev->conn_info_list, list) {\n\t\tif (conn_info->conn_id == conn_id)\n\t\t\treturn conn_info;\n\t}\n\n\treturn NULL;\n}\n\nint nci_get_conn_info_by_dest_type_params(struct nci_dev *ndev, u8 dest_type,\n\t\t\t\t\t  const struct dest_spec_params *params)\n{\n\tconst struct nci_conn_info *conn_info;\n\n\tlist_for_each_entry(conn_info, &ndev->conn_info_list, list) {\n\t\tif (conn_info->dest_type == dest_type) {\n\t\t\tif (!params)\n\t\t\t\treturn conn_info->conn_id;\n\n\t\t\tif (params->id == conn_info->dest_params->id &&\n\t\t\t    params->protocol == conn_info->dest_params->protocol)\n\t\t\t\treturn conn_info->conn_id;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(nci_get_conn_info_by_dest_type_params);\n\n \n\nvoid nci_req_complete(struct nci_dev *ndev, int result)\n{\n\tif (ndev->req_status == NCI_REQ_PEND) {\n\t\tndev->req_result = result;\n\t\tndev->req_status = NCI_REQ_DONE;\n\t\tcomplete(&ndev->req_completion);\n\t}\n}\nEXPORT_SYMBOL(nci_req_complete);\n\nstatic void nci_req_cancel(struct nci_dev *ndev, int err)\n{\n\tif (ndev->req_status == NCI_REQ_PEND) {\n\t\tndev->req_result = err;\n\t\tndev->req_status = NCI_REQ_CANCELED;\n\t\tcomplete(&ndev->req_completion);\n\t}\n}\n\n \nstatic int __nci_request(struct nci_dev *ndev,\n\t\t\t void (*req)(struct nci_dev *ndev, const void *opt),\n\t\t\t const void *opt, __u32 timeout)\n{\n\tint rc = 0;\n\tlong completion_rc;\n\n\tndev->req_status = NCI_REQ_PEND;\n\n\treinit_completion(&ndev->req_completion);\n\treq(ndev, opt);\n\tcompletion_rc =\n\t\twait_for_completion_interruptible_timeout(&ndev->req_completion,\n\t\t\t\t\t\t\t  timeout);\n\n\tpr_debug(\"wait_for_completion return %ld\\n\", completion_rc);\n\n\tif (completion_rc > 0) {\n\t\tswitch (ndev->req_status) {\n\t\tcase NCI_REQ_DONE:\n\t\t\trc = nci_to_errno(ndev->req_result);\n\t\t\tbreak;\n\n\t\tcase NCI_REQ_CANCELED:\n\t\t\trc = -ndev->req_result;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tpr_err(\"wait_for_completion_interruptible_timeout failed %ld\\n\",\n\t\t       completion_rc);\n\n\t\trc = ((completion_rc == 0) ? (-ETIMEDOUT) : (completion_rc));\n\t}\n\n\tndev->req_status = ndev->req_result = 0;\n\n\treturn rc;\n}\n\ninline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\n\t \n\tmutex_lock(&ndev->req_lock);\n\t \n\tif (test_bit(NCI_UP, &ndev->flags))\n\t\trc = __nci_request(ndev, req, opt, timeout);\n\telse\n\t\trc = -ENETDOWN;\n\tmutex_unlock(&ndev->req_lock);\n\n\treturn rc;\n}\n\nstatic void nci_reset_req(struct nci_dev *ndev, const void *opt)\n{\n\tstruct nci_core_reset_cmd cmd;\n\n\tcmd.reset_type = NCI_RESET_TYPE_RESET_CONFIG;\n\tnci_send_cmd(ndev, NCI_OP_CORE_RESET_CMD, 1, &cmd);\n}\n\nstatic void nci_init_req(struct nci_dev *ndev, const void *opt)\n{\n\tu8 plen = 0;\n\n\tif (opt)\n\t\tplen = sizeof(struct nci_core_init_v2_cmd);\n\n\tnci_send_cmd(ndev, NCI_OP_CORE_INIT_CMD, plen, opt);\n}\n\nstatic void nci_init_complete_req(struct nci_dev *ndev, const void *opt)\n{\n\tstruct nci_rf_disc_map_cmd cmd;\n\tstruct disc_map_config *cfg = cmd.mapping_configs;\n\t__u8 *num = &cmd.num_mapping_configs;\n\tint i;\n\n\t \n\t*num = 0;\n\n\t \n\tfor (i = 0; i < ndev->num_supported_rf_interfaces; i++) {\n\t\tif (ndev->supported_rf_interfaces[i] ==\n\t\t    NCI_RF_INTERFACE_ISO_DEP) {\n\t\t\tcfg[*num].rf_protocol = NCI_RF_PROTOCOL_ISO_DEP;\n\t\t\tcfg[*num].mode = NCI_DISC_MAP_MODE_POLL |\n\t\t\t\tNCI_DISC_MAP_MODE_LISTEN;\n\t\t\tcfg[*num].rf_interface = NCI_RF_INTERFACE_ISO_DEP;\n\t\t\t(*num)++;\n\t\t} else if (ndev->supported_rf_interfaces[i] ==\n\t\t\t   NCI_RF_INTERFACE_NFC_DEP) {\n\t\t\tcfg[*num].rf_protocol = NCI_RF_PROTOCOL_NFC_DEP;\n\t\t\tcfg[*num].mode = NCI_DISC_MAP_MODE_POLL |\n\t\t\t\tNCI_DISC_MAP_MODE_LISTEN;\n\t\t\tcfg[*num].rf_interface = NCI_RF_INTERFACE_NFC_DEP;\n\t\t\t(*num)++;\n\t\t}\n\n\t\tif (*num == NCI_MAX_NUM_MAPPING_CONFIGS)\n\t\t\tbreak;\n\t}\n\n\tnci_send_cmd(ndev, NCI_OP_RF_DISCOVER_MAP_CMD,\n\t\t     (1 + ((*num) * sizeof(struct disc_map_config))), &cmd);\n}\n\nstruct nci_set_config_param {\n\t__u8\t\tid;\n\tsize_t\t\tlen;\n\tconst __u8\t*val;\n};\n\nstatic void nci_set_config_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_set_config_param *param = opt;\n\tstruct nci_core_set_config_cmd cmd;\n\n\tBUG_ON(param->len > NCI_MAX_PARAM_LEN);\n\n\tcmd.num_params = 1;\n\tcmd.param.id = param->id;\n\tcmd.param.len = param->len;\n\tmemcpy(cmd.param.val, param->val, param->len);\n\n\tnci_send_cmd(ndev, NCI_OP_CORE_SET_CONFIG_CMD, (3 + param->len), &cmd);\n}\n\nstruct nci_rf_discover_param {\n\t__u32\tim_protocols;\n\t__u32\ttm_protocols;\n};\n\nstatic void nci_rf_discover_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_rf_discover_param *param = opt;\n\tstruct nci_rf_disc_cmd cmd;\n\n\tcmd.num_disc_configs = 0;\n\n\tif ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&\n\t    (param->im_protocols & NFC_PROTO_JEWEL_MASK ||\n\t     param->im_protocols & NFC_PROTO_MIFARE_MASK ||\n\t     param->im_protocols & NFC_PROTO_ISO14443_MASK ||\n\t     param->im_protocols & NFC_PROTO_NFC_DEP_MASK)) {\n\t\tcmd.disc_configs[cmd.num_disc_configs].rf_tech_and_mode =\n\t\t\tNCI_NFC_A_PASSIVE_POLL_MODE;\n\t\tcmd.disc_configs[cmd.num_disc_configs].frequency = 1;\n\t\tcmd.num_disc_configs++;\n\t}\n\n\tif ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&\n\t    (param->im_protocols & NFC_PROTO_ISO14443_B_MASK)) {\n\t\tcmd.disc_configs[cmd.num_disc_configs].rf_tech_and_mode =\n\t\t\tNCI_NFC_B_PASSIVE_POLL_MODE;\n\t\tcmd.disc_configs[cmd.num_disc_configs].frequency = 1;\n\t\tcmd.num_disc_configs++;\n\t}\n\n\tif ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&\n\t    (param->im_protocols & NFC_PROTO_FELICA_MASK ||\n\t     param->im_protocols & NFC_PROTO_NFC_DEP_MASK)) {\n\t\tcmd.disc_configs[cmd.num_disc_configs].rf_tech_and_mode =\n\t\t\tNCI_NFC_F_PASSIVE_POLL_MODE;\n\t\tcmd.disc_configs[cmd.num_disc_configs].frequency = 1;\n\t\tcmd.num_disc_configs++;\n\t}\n\n\tif ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&\n\t    (param->im_protocols & NFC_PROTO_ISO15693_MASK)) {\n\t\tcmd.disc_configs[cmd.num_disc_configs].rf_tech_and_mode =\n\t\t\tNCI_NFC_V_PASSIVE_POLL_MODE;\n\t\tcmd.disc_configs[cmd.num_disc_configs].frequency = 1;\n\t\tcmd.num_disc_configs++;\n\t}\n\n\tif ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS - 1) &&\n\t    (param->tm_protocols & NFC_PROTO_NFC_DEP_MASK)) {\n\t\tcmd.disc_configs[cmd.num_disc_configs].rf_tech_and_mode =\n\t\t\tNCI_NFC_A_PASSIVE_LISTEN_MODE;\n\t\tcmd.disc_configs[cmd.num_disc_configs].frequency = 1;\n\t\tcmd.num_disc_configs++;\n\t\tcmd.disc_configs[cmd.num_disc_configs].rf_tech_and_mode =\n\t\t\tNCI_NFC_F_PASSIVE_LISTEN_MODE;\n\t\tcmd.disc_configs[cmd.num_disc_configs].frequency = 1;\n\t\tcmd.num_disc_configs++;\n\t}\n\n\tnci_send_cmd(ndev, NCI_OP_RF_DISCOVER_CMD,\n\t\t     (1 + (cmd.num_disc_configs * sizeof(struct disc_config))),\n\t\t     &cmd);\n}\n\nstruct nci_rf_discover_select_param {\n\t__u8\trf_discovery_id;\n\t__u8\trf_protocol;\n};\n\nstatic void nci_rf_discover_select_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_rf_discover_select_param *param = opt;\n\tstruct nci_rf_discover_select_cmd cmd;\n\n\tcmd.rf_discovery_id = param->rf_discovery_id;\n\tcmd.rf_protocol = param->rf_protocol;\n\n\tswitch (cmd.rf_protocol) {\n\tcase NCI_RF_PROTOCOL_ISO_DEP:\n\t\tcmd.rf_interface = NCI_RF_INTERFACE_ISO_DEP;\n\t\tbreak;\n\n\tcase NCI_RF_PROTOCOL_NFC_DEP:\n\t\tcmd.rf_interface = NCI_RF_INTERFACE_NFC_DEP;\n\t\tbreak;\n\n\tdefault:\n\t\tcmd.rf_interface = NCI_RF_INTERFACE_FRAME;\n\t\tbreak;\n\t}\n\n\tnci_send_cmd(ndev, NCI_OP_RF_DISCOVER_SELECT_CMD,\n\t\t     sizeof(struct nci_rf_discover_select_cmd), &cmd);\n}\n\nstatic void nci_rf_deactivate_req(struct nci_dev *ndev, const void *opt)\n{\n\tstruct nci_rf_deactivate_cmd cmd;\n\n\tcmd.type = (unsigned long)opt;\n\n\tnci_send_cmd(ndev, NCI_OP_RF_DEACTIVATE_CMD,\n\t\t     sizeof(struct nci_rf_deactivate_cmd), &cmd);\n}\n\nstruct nci_cmd_param {\n\t__u16 opcode;\n\tsize_t len;\n\tconst __u8 *payload;\n};\n\nstatic void nci_generic_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_cmd_param *param = opt;\n\n\tnci_send_cmd(ndev, param->opcode, param->len, param->payload);\n}\n\nint nci_prop_cmd(struct nci_dev *ndev, __u8 oid, size_t len, const __u8 *payload)\n{\n\tstruct nci_cmd_param param;\n\n\tparam.opcode = nci_opcode_pack(NCI_GID_PROPRIETARY, oid);\n\tparam.len = len;\n\tparam.payload = payload;\n\n\treturn __nci_request(ndev, nci_generic_req, &param,\n\t\t\t     msecs_to_jiffies(NCI_CMD_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_prop_cmd);\n\nint nci_core_cmd(struct nci_dev *ndev, __u16 opcode, size_t len,\n\t\t const __u8 *payload)\n{\n\tstruct nci_cmd_param param;\n\n\tparam.opcode = opcode;\n\tparam.len = len;\n\tparam.payload = payload;\n\n\treturn __nci_request(ndev, nci_generic_req, &param,\n\t\t\t     msecs_to_jiffies(NCI_CMD_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_core_cmd);\n\nint nci_core_reset(struct nci_dev *ndev)\n{\n\treturn __nci_request(ndev, nci_reset_req, (void *)0,\n\t\t\t     msecs_to_jiffies(NCI_RESET_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_core_reset);\n\nint nci_core_init(struct nci_dev *ndev)\n{\n\treturn __nci_request(ndev, nci_init_req, (void *)0,\n\t\t\t     msecs_to_jiffies(NCI_INIT_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_core_init);\n\nstruct nci_loopback_data {\n\tu8 conn_id;\n\tstruct sk_buff *data;\n};\n\nstatic void nci_send_data_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_loopback_data *data = opt;\n\n\tnci_send_data(ndev, data->conn_id, data->data);\n}\n\nstatic void nci_nfcc_loopback_cb(void *context, struct sk_buff *skb, int err)\n{\n\tstruct nci_dev *ndev = (struct nci_dev *)context;\n\tstruct nci_conn_info *conn_info;\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, ndev->cur_conn_id);\n\tif (!conn_info) {\n\t\tnci_req_complete(ndev, NCI_STATUS_REJECTED);\n\t\treturn;\n\t}\n\n\tconn_info->rx_skb = skb;\n\n\tnci_req_complete(ndev, NCI_STATUS_OK);\n}\n\nint nci_nfcc_loopback(struct nci_dev *ndev, const void *data, size_t data_len,\n\t\t      struct sk_buff **resp)\n{\n\tint r;\n\tstruct nci_loopback_data loopback_data;\n\tstruct nci_conn_info *conn_info;\n\tstruct sk_buff *skb;\n\tint conn_id = nci_get_conn_info_by_dest_type_params(ndev,\n\t\t\t\t\tNCI_DESTINATION_NFCC_LOOPBACK, NULL);\n\n\tif (conn_id < 0) {\n\t\tr = nci_core_conn_create(ndev, NCI_DESTINATION_NFCC_LOOPBACK,\n\t\t\t\t\t 0, 0, NULL);\n\t\tif (r != NCI_STATUS_OK)\n\t\t\treturn r;\n\n\t\tconn_id = nci_get_conn_info_by_dest_type_params(ndev,\n\t\t\t\t\tNCI_DESTINATION_NFCC_LOOPBACK,\n\t\t\t\t\tNULL);\n\t}\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, conn_id);\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\t \n\tconn_info->data_exchange_cb = nci_nfcc_loopback_cb;\n\tconn_info->data_exchange_cb_context = ndev;\n\n\tskb = nci_skb_alloc(ndev, NCI_DATA_HDR_SIZE + data_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, NCI_DATA_HDR_SIZE);\n\tskb_put_data(skb, data, data_len);\n\n\tloopback_data.conn_id = conn_id;\n\tloopback_data.data = skb;\n\n\tndev->cur_conn_id = conn_id;\n\tr = nci_request(ndev, nci_send_data_req, &loopback_data,\n\t\t\tmsecs_to_jiffies(NCI_DATA_TIMEOUT));\n\tif (r == NCI_STATUS_OK && resp)\n\t\t*resp = conn_info->rx_skb;\n\n\treturn r;\n}\nEXPORT_SYMBOL(nci_nfcc_loopback);\n\nstatic int nci_open_device(struct nci_dev *ndev)\n{\n\tint rc = 0;\n\n\tmutex_lock(&ndev->req_lock);\n\n\tif (test_bit(NCI_UNREG, &ndev->flags)) {\n\t\trc = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (test_bit(NCI_UP, &ndev->flags)) {\n\t\trc = -EALREADY;\n\t\tgoto done;\n\t}\n\n\tif (ndev->ops->open(ndev)) {\n\t\trc = -EIO;\n\t\tgoto done;\n\t}\n\n\tatomic_set(&ndev->cmd_cnt, 1);\n\n\tset_bit(NCI_INIT, &ndev->flags);\n\n\tif (ndev->ops->init)\n\t\trc = ndev->ops->init(ndev);\n\n\tif (!rc) {\n\t\trc = __nci_request(ndev, nci_reset_req, (void *)0,\n\t\t\t\t   msecs_to_jiffies(NCI_RESET_TIMEOUT));\n\t}\n\n\tif (!rc && ndev->ops->setup) {\n\t\trc = ndev->ops->setup(ndev);\n\t}\n\n\tif (!rc) {\n\t\tstruct nci_core_init_v2_cmd nci_init_v2_cmd = {\n\t\t\t.feature1 = NCI_FEATURE_DISABLE,\n\t\t\t.feature2 = NCI_FEATURE_DISABLE\n\t\t};\n\t\tconst void *opt = NULL;\n\n\t\tif (ndev->nci_ver & NCI_VER_2_MASK)\n\t\t\topt = &nci_init_v2_cmd;\n\n\t\trc = __nci_request(ndev, nci_init_req, opt,\n\t\t\t\t   msecs_to_jiffies(NCI_INIT_TIMEOUT));\n\t}\n\n\tif (!rc && ndev->ops->post_setup)\n\t\trc = ndev->ops->post_setup(ndev);\n\n\tif (!rc) {\n\t\trc = __nci_request(ndev, nci_init_complete_req, (void *)0,\n\t\t\t\t   msecs_to_jiffies(NCI_INIT_TIMEOUT));\n\t}\n\n\tclear_bit(NCI_INIT, &ndev->flags);\n\n\tif (!rc) {\n\t\tset_bit(NCI_UP, &ndev->flags);\n\t\tnci_clear_target_list(ndev);\n\t\tatomic_set(&ndev->state, NCI_IDLE);\n\t} else {\n\t\t \n\t\tskb_queue_purge(&ndev->cmd_q);\n\t\tskb_queue_purge(&ndev->rx_q);\n\t\tskb_queue_purge(&ndev->tx_q);\n\n\t\tndev->ops->close(ndev);\n\t\tndev->flags &= BIT(NCI_UNREG);\n\t}\n\ndone:\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}\n\nstatic int nci_close_device(struct nci_dev *ndev)\n{\n\tnci_req_cancel(ndev, ENODEV);\n\n\t \n\tmutex_lock(&ndev->req_lock);\n\n\tif (!test_and_clear_bit(NCI_UP, &ndev->flags)) {\n\t\t \n\t\tflush_workqueue(ndev->cmd_wq);\n\t\tdel_timer_sync(&ndev->cmd_timer);\n\t\tdel_timer_sync(&ndev->data_timer);\n\t\tmutex_unlock(&ndev->req_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tskb_queue_purge(&ndev->rx_q);\n\tskb_queue_purge(&ndev->tx_q);\n\n\t \n\tflush_workqueue(ndev->rx_wq);\n\tflush_workqueue(ndev->tx_wq);\n\n\t \n\tskb_queue_purge(&ndev->cmd_q);\n\tatomic_set(&ndev->cmd_cnt, 1);\n\n\tset_bit(NCI_INIT, &ndev->flags);\n\t__nci_request(ndev, nci_reset_req, (void *)0,\n\t\t      msecs_to_jiffies(NCI_RESET_TIMEOUT));\n\n\t \n\tndev->ops->close(ndev);\n\n\tclear_bit(NCI_INIT, &ndev->flags);\n\n\t \n\tflush_workqueue(ndev->cmd_wq);\n\n\tdel_timer_sync(&ndev->cmd_timer);\n\n\t \n\tndev->flags &= BIT(NCI_UNREG);\n\n\tmutex_unlock(&ndev->req_lock);\n\n\treturn 0;\n}\n\n \nstatic void nci_cmd_timer(struct timer_list *t)\n{\n\tstruct nci_dev *ndev = from_timer(ndev, t, cmd_timer);\n\n\tatomic_set(&ndev->cmd_cnt, 1);\n\tqueue_work(ndev->cmd_wq, &ndev->cmd_work);\n}\n\n \nstatic void nci_data_timer(struct timer_list *t)\n{\n\tstruct nci_dev *ndev = from_timer(ndev, t, data_timer);\n\n\tset_bit(NCI_DATA_EXCHANGE_TO, &ndev->flags);\n\tqueue_work(ndev->rx_wq, &ndev->rx_work);\n}\n\nstatic int nci_dev_up(struct nfc_dev *nfc_dev)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\treturn nci_open_device(ndev);\n}\n\nstatic int nci_dev_down(struct nfc_dev *nfc_dev)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\treturn nci_close_device(ndev);\n}\n\nint nci_set_config(struct nci_dev *ndev, __u8 id, size_t len, const __u8 *val)\n{\n\tstruct nci_set_config_param param;\n\n\tif (!val || !len)\n\t\treturn 0;\n\n\tparam.id = id;\n\tparam.len = len;\n\tparam.val = val;\n\n\treturn __nci_request(ndev, nci_set_config_req, &param,\n\t\t\t     msecs_to_jiffies(NCI_SET_CONFIG_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_set_config);\n\nstatic void nci_nfcee_discover_req(struct nci_dev *ndev, const void *opt)\n{\n\tstruct nci_nfcee_discover_cmd cmd;\n\t__u8 action = (unsigned long)opt;\n\n\tcmd.discovery_action = action;\n\n\tnci_send_cmd(ndev, NCI_OP_NFCEE_DISCOVER_CMD, 1, &cmd);\n}\n\nint nci_nfcee_discover(struct nci_dev *ndev, u8 action)\n{\n\tunsigned long opt = action;\n\n\treturn __nci_request(ndev, nci_nfcee_discover_req, (void *)opt,\n\t\t\t\tmsecs_to_jiffies(NCI_CMD_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_nfcee_discover);\n\nstatic void nci_nfcee_mode_set_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct nci_nfcee_mode_set_cmd *cmd = opt;\n\n\tnci_send_cmd(ndev, NCI_OP_NFCEE_MODE_SET_CMD,\n\t\t     sizeof(struct nci_nfcee_mode_set_cmd), cmd);\n}\n\nint nci_nfcee_mode_set(struct nci_dev *ndev, u8 nfcee_id, u8 nfcee_mode)\n{\n\tstruct nci_nfcee_mode_set_cmd cmd;\n\n\tcmd.nfcee_id = nfcee_id;\n\tcmd.nfcee_mode = nfcee_mode;\n\n\treturn __nci_request(ndev, nci_nfcee_mode_set_req, &cmd,\n\t\t\t     msecs_to_jiffies(NCI_CMD_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_nfcee_mode_set);\n\nstatic void nci_core_conn_create_req(struct nci_dev *ndev, const void *opt)\n{\n\tconst struct core_conn_create_data *data = opt;\n\n\tnci_send_cmd(ndev, NCI_OP_CORE_CONN_CREATE_CMD, data->length, data->cmd);\n}\n\nint nci_core_conn_create(struct nci_dev *ndev, u8 destination_type,\n\t\t\t u8 number_destination_params,\n\t\t\t size_t params_len,\n\t\t\t const struct core_conn_create_dest_spec_params *params)\n{\n\tint r;\n\tstruct nci_core_conn_create_cmd *cmd;\n\tstruct core_conn_create_data data;\n\n\tdata.length = params_len + sizeof(struct nci_core_conn_create_cmd);\n\tcmd = kzalloc(data.length, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->destination_type = destination_type;\n\tcmd->number_destination_params = number_destination_params;\n\n\tdata.cmd = cmd;\n\n\tif (params) {\n\t\tmemcpy(cmd->params, params, params_len);\n\t\tif (params->length > 0)\n\t\t\tmemcpy(&ndev->cur_params,\n\t\t\t       &params->value[DEST_SPEC_PARAMS_ID_INDEX],\n\t\t\t       sizeof(struct dest_spec_params));\n\t\telse\n\t\t\tndev->cur_params.id = 0;\n\t} else {\n\t\tndev->cur_params.id = 0;\n\t}\n\tndev->cur_dest_type = destination_type;\n\n\tr = __nci_request(ndev, nci_core_conn_create_req, &data,\n\t\t\t  msecs_to_jiffies(NCI_CMD_TIMEOUT));\n\tkfree(cmd);\n\treturn r;\n}\nEXPORT_SYMBOL(nci_core_conn_create);\n\nstatic void nci_core_conn_close_req(struct nci_dev *ndev, const void *opt)\n{\n\t__u8 conn_id = (unsigned long)opt;\n\n\tnci_send_cmd(ndev, NCI_OP_CORE_CONN_CLOSE_CMD, 1, &conn_id);\n}\n\nint nci_core_conn_close(struct nci_dev *ndev, u8 conn_id)\n{\n\tunsigned long opt = conn_id;\n\n\tndev->cur_conn_id = conn_id;\n\treturn __nci_request(ndev, nci_core_conn_close_req, (void *)opt,\n\t\t\t     msecs_to_jiffies(NCI_CMD_TIMEOUT));\n}\nEXPORT_SYMBOL(nci_core_conn_close);\n\nstatic int nci_set_local_general_bytes(struct nfc_dev *nfc_dev)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tstruct nci_set_config_param param;\n\tint rc;\n\n\tparam.val = nfc_get_local_general_bytes(nfc_dev, &param.len);\n\tif ((param.val == NULL) || (param.len == 0))\n\t\treturn 0;\n\n\tif (param.len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\n\tparam.id = NCI_PN_ATR_REQ_GEN_BYTES;\n\n\trc = nci_request(ndev, nci_set_config_req, &param,\n\t\t\t msecs_to_jiffies(NCI_SET_CONFIG_TIMEOUT));\n\tif (rc)\n\t\treturn rc;\n\n\tparam.id = NCI_LN_ATR_RES_GEN_BYTES;\n\n\treturn nci_request(ndev, nci_set_config_req, &param,\n\t\t\t   msecs_to_jiffies(NCI_SET_CONFIG_TIMEOUT));\n}\n\nstatic int nci_set_listen_parameters(struct nfc_dev *nfc_dev)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\t__u8 val;\n\n\tval = NCI_LA_SEL_INFO_NFC_DEP_MASK;\n\n\trc = nci_set_config(ndev, NCI_LA_SEL_INFO, 1, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tval = NCI_LF_PROTOCOL_TYPE_NFC_DEP_MASK;\n\n\trc = nci_set_config(ndev, NCI_LF_PROTOCOL_TYPE, 1, &val);\n\tif (rc)\n\t\treturn rc;\n\n\tval = NCI_LF_CON_BITR_F_212 | NCI_LF_CON_BITR_F_424;\n\n\treturn nci_set_config(ndev, NCI_LF_CON_BITR_F, 1, &val);\n}\n\nstatic int nci_start_poll(struct nfc_dev *nfc_dev,\n\t\t\t  __u32 im_protocols, __u32 tm_protocols)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tstruct nci_rf_discover_param param;\n\tint rc;\n\n\tif ((atomic_read(&ndev->state) == NCI_DISCOVERY) ||\n\t    (atomic_read(&ndev->state) == NCI_W4_ALL_DISCOVERIES)) {\n\t\tpr_err(\"unable to start poll, since poll is already active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (ndev->target_active_prot) {\n\t\tpr_err(\"there is an active target\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif ((atomic_read(&ndev->state) == NCI_W4_HOST_SELECT) ||\n\t    (atomic_read(&ndev->state) == NCI_POLL_ACTIVE)) {\n\t\tpr_debug(\"target active or w4 select, implicitly deactivate\\n\");\n\n\t\trc = nci_request(ndev, nci_rf_deactivate_req,\n\t\t\t\t (void *)NCI_DEACTIVATE_TYPE_IDLE_MODE,\n\t\t\t\t msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));\n\t\tif (rc)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif ((im_protocols | tm_protocols) & NFC_PROTO_NFC_DEP_MASK) {\n\t\trc = nci_set_local_general_bytes(nfc_dev);\n\t\tif (rc) {\n\t\t\tpr_err(\"failed to set local general bytes\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\trc = nci_set_listen_parameters(nfc_dev);\n\t\tif (rc)\n\t\t\tpr_err(\"failed to set listen parameters\\n\");\n\t}\n\n\tparam.im_protocols = im_protocols;\n\tparam.tm_protocols = tm_protocols;\n\trc = nci_request(ndev, nci_rf_discover_req, &param,\n\t\t\t msecs_to_jiffies(NCI_RF_DISC_TIMEOUT));\n\n\tif (!rc)\n\t\tndev->poll_prots = im_protocols;\n\n\treturn rc;\n}\n\nstatic void nci_stop_poll(struct nfc_dev *nfc_dev)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\tif ((atomic_read(&ndev->state) != NCI_DISCOVERY) &&\n\t    (atomic_read(&ndev->state) != NCI_W4_ALL_DISCOVERIES)) {\n\t\tpr_err(\"unable to stop poll, since poll is not active\\n\");\n\t\treturn;\n\t}\n\n\tnci_request(ndev, nci_rf_deactivate_req,\n\t\t    (void *)NCI_DEACTIVATE_TYPE_IDLE_MODE,\n\t\t    msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));\n}\n\nstatic int nci_activate_target(struct nfc_dev *nfc_dev,\n\t\t\t       struct nfc_target *target, __u32 protocol)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tstruct nci_rf_discover_select_param param;\n\tconst struct nfc_target *nci_target = NULL;\n\tint i;\n\tint rc = 0;\n\n\tpr_debug(\"target_idx %d, protocol 0x%x\\n\", target->idx, protocol);\n\n\tif ((atomic_read(&ndev->state) != NCI_W4_HOST_SELECT) &&\n\t    (atomic_read(&ndev->state) != NCI_POLL_ACTIVE)) {\n\t\tpr_err(\"there is no available target to activate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ndev->target_active_prot) {\n\t\tpr_err(\"there is already an active target\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < ndev->n_targets; i++) {\n\t\tif (ndev->targets[i].idx == target->idx) {\n\t\t\tnci_target = &ndev->targets[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nci_target) {\n\t\tpr_err(\"unable to find the selected target\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (protocol >= NFC_PROTO_MAX) {\n\t\tpr_err(\"the requested nfc protocol is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(nci_target->supported_protocols & (1 << protocol))) {\n\t\tpr_err(\"target does not support the requested protocol 0x%x\\n\",\n\t\t       protocol);\n\t\treturn -EINVAL;\n\t}\n\n\tif (atomic_read(&ndev->state) == NCI_W4_HOST_SELECT) {\n\t\tparam.rf_discovery_id = nci_target->logical_idx;\n\n\t\tif (protocol == NFC_PROTO_JEWEL)\n\t\t\tparam.rf_protocol = NCI_RF_PROTOCOL_T1T;\n\t\telse if (protocol == NFC_PROTO_MIFARE)\n\t\t\tparam.rf_protocol = NCI_RF_PROTOCOL_T2T;\n\t\telse if (protocol == NFC_PROTO_FELICA)\n\t\t\tparam.rf_protocol = NCI_RF_PROTOCOL_T3T;\n\t\telse if (protocol == NFC_PROTO_ISO14443 ||\n\t\t\t protocol == NFC_PROTO_ISO14443_B)\n\t\t\tparam.rf_protocol = NCI_RF_PROTOCOL_ISO_DEP;\n\t\telse\n\t\t\tparam.rf_protocol = NCI_RF_PROTOCOL_NFC_DEP;\n\n\t\trc = nci_request(ndev, nci_rf_discover_select_req, &param,\n\t\t\t\t msecs_to_jiffies(NCI_RF_DISC_SELECT_TIMEOUT));\n\t}\n\n\tif (!rc)\n\t\tndev->target_active_prot = protocol;\n\n\treturn rc;\n}\n\nstatic void nci_deactivate_target(struct nfc_dev *nfc_dev,\n\t\t\t\t  struct nfc_target *target,\n\t\t\t\t  __u8 mode)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tunsigned long nci_mode = NCI_DEACTIVATE_TYPE_IDLE_MODE;\n\n\tif (!ndev->target_active_prot) {\n\t\tpr_err(\"unable to deactivate target, no active target\\n\");\n\t\treturn;\n\t}\n\n\tndev->target_active_prot = 0;\n\n\tswitch (mode) {\n\tcase NFC_TARGET_MODE_SLEEP:\n\t\tnci_mode = NCI_DEACTIVATE_TYPE_SLEEP_MODE;\n\t\tbreak;\n\t}\n\n\tif (atomic_read(&ndev->state) == NCI_POLL_ACTIVE) {\n\t\tnci_request(ndev, nci_rf_deactivate_req, (void *)nci_mode,\n\t\t\t    msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));\n\t}\n}\n\nstatic int nci_dep_link_up(struct nfc_dev *nfc_dev, struct nfc_target *target,\n\t\t\t   __u8 comm_mode, __u8 *gb, size_t gb_len)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\tpr_debug(\"target_idx %d, comm_mode %d\\n\", target->idx, comm_mode);\n\n\trc = nci_activate_target(nfc_dev, target, NFC_PROTO_NFC_DEP);\n\tif (rc)\n\t\treturn rc;\n\n\trc = nfc_set_remote_general_bytes(nfc_dev, ndev->remote_gb,\n\t\t\t\t\t  ndev->remote_gb_len);\n\tif (!rc)\n\t\trc = nfc_dep_link_is_up(nfc_dev, target->idx, NFC_COMM_PASSIVE,\n\t\t\t\t\tNFC_RF_INITIATOR);\n\n\treturn rc;\n}\n\nstatic int nci_dep_link_down(struct nfc_dev *nfc_dev)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\tif (nfc_dev->rf_mode == NFC_RF_INITIATOR) {\n\t\tnci_deactivate_target(nfc_dev, NULL, NCI_DEACTIVATE_TYPE_IDLE_MODE);\n\t} else {\n\t\tif (atomic_read(&ndev->state) == NCI_LISTEN_ACTIVE ||\n\t\t    atomic_read(&ndev->state) == NCI_DISCOVERY) {\n\t\t\tnci_request(ndev, nci_rf_deactivate_req, (void *)0,\n\t\t\t\t    msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));\n\t\t}\n\n\t\trc = nfc_tm_deactivated(nfc_dev);\n\t\tif (rc)\n\t\t\tpr_err(\"error when signaling tm deactivation\\n\");\n\t}\n\n\treturn 0;\n}\n\n\nstatic int nci_transceive(struct nfc_dev *nfc_dev, struct nfc_target *target,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  data_exchange_cb_t cb, void *cb_context)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\tstruct nci_conn_info *conn_info;\n\n\tconn_info = ndev->rf_conn_info;\n\tif (!conn_info)\n\t\treturn -EPROTO;\n\n\tpr_debug(\"target_idx %d, len %d\\n\", target->idx, skb->len);\n\n\tif (!ndev->target_active_prot) {\n\t\tpr_err(\"unable to exchange data, no active target\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_and_set_bit(NCI_DATA_EXCHANGE, &ndev->flags))\n\t\treturn -EBUSY;\n\n\t \n\tconn_info->data_exchange_cb = cb;\n\tconn_info->data_exchange_cb_context = cb_context;\n\n\trc = nci_send_data(ndev, NCI_STATIC_RF_CONN_ID, skb);\n\tif (rc)\n\t\tclear_bit(NCI_DATA_EXCHANGE, &ndev->flags);\n\n\treturn rc;\n}\n\nstatic int nci_tm_send(struct nfc_dev *nfc_dev, struct sk_buff *skb)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\trc = nci_send_data(ndev, NCI_STATIC_RF_CONN_ID, skb);\n\tif (rc)\n\t\tpr_err(\"unable to send data\\n\");\n\n\treturn rc;\n}\n\nstatic int nci_enable_se(struct nfc_dev *nfc_dev, u32 se_idx)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\tif (ndev->ops->enable_se)\n\t\treturn ndev->ops->enable_se(ndev, se_idx);\n\n\treturn 0;\n}\n\nstatic int nci_disable_se(struct nfc_dev *nfc_dev, u32 se_idx)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\tif (ndev->ops->disable_se)\n\t\treturn ndev->ops->disable_se(ndev, se_idx);\n\n\treturn 0;\n}\n\nstatic int nci_discover_se(struct nfc_dev *nfc_dev)\n{\n\tint r;\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\tif (ndev->ops->discover_se) {\n\t\tr = nci_nfcee_discover(ndev, NCI_NFCEE_DISCOVERY_ACTION_ENABLE);\n\t\tif (r != NCI_STATUS_OK)\n\t\t\treturn -EPROTO;\n\n\t\treturn ndev->ops->discover_se(ndev);\n\t}\n\n\treturn 0;\n}\n\nstatic int nci_se_io(struct nfc_dev *nfc_dev, u32 se_idx,\n\t\t     u8 *apdu, size_t apdu_length,\n\t\t     se_io_cb_t cb, void *cb_context)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\tif (ndev->ops->se_io)\n\t\treturn ndev->ops->se_io(ndev, se_idx, apdu,\n\t\t\t\tapdu_length, cb, cb_context);\n\n\treturn 0;\n}\n\nstatic int nci_fw_download(struct nfc_dev *nfc_dev, const char *firmware_name)\n{\n\tstruct nci_dev *ndev = nfc_get_drvdata(nfc_dev);\n\n\tif (!ndev->ops->fw_download)\n\t\treturn -ENOTSUPP;\n\n\treturn ndev->ops->fw_download(ndev, firmware_name);\n}\n\nstatic const struct nfc_ops nci_nfc_ops = {\n\t.dev_up = nci_dev_up,\n\t.dev_down = nci_dev_down,\n\t.start_poll = nci_start_poll,\n\t.stop_poll = nci_stop_poll,\n\t.dep_link_up = nci_dep_link_up,\n\t.dep_link_down = nci_dep_link_down,\n\t.activate_target = nci_activate_target,\n\t.deactivate_target = nci_deactivate_target,\n\t.im_transceive = nci_transceive,\n\t.tm_send = nci_tm_send,\n\t.enable_se = nci_enable_se,\n\t.disable_se = nci_disable_se,\n\t.discover_se = nci_discover_se,\n\t.se_io = nci_se_io,\n\t.fw_download = nci_fw_download,\n};\n\n \n \nstruct nci_dev *nci_allocate_device(const struct nci_ops *ops,\n\t\t\t\t    __u32 supported_protocols,\n\t\t\t\t    int tx_headroom, int tx_tailroom)\n{\n\tstruct nci_dev *ndev;\n\n\tpr_debug(\"supported_protocols 0x%x\\n\", supported_protocols);\n\n\tif (!ops->open || !ops->close || !ops->send)\n\t\treturn NULL;\n\n\tif (!supported_protocols)\n\t\treturn NULL;\n\n\tndev = kzalloc(sizeof(struct nci_dev), GFP_KERNEL);\n\tif (!ndev)\n\t\treturn NULL;\n\n\tndev->ops = ops;\n\n\tif (ops->n_prop_ops > NCI_MAX_PROPRIETARY_CMD) {\n\t\tpr_err(\"Too many proprietary commands: %zd\\n\",\n\t\t       ops->n_prop_ops);\n\t\tgoto free_nci;\n\t}\n\n\tndev->tx_headroom = tx_headroom;\n\tndev->tx_tailroom = tx_tailroom;\n\tinit_completion(&ndev->req_completion);\n\n\tndev->nfc_dev = nfc_allocate_device(&nci_nfc_ops,\n\t\t\t\t\t    supported_protocols,\n\t\t\t\t\t    tx_headroom + NCI_DATA_HDR_SIZE,\n\t\t\t\t\t    tx_tailroom);\n\tif (!ndev->nfc_dev)\n\t\tgoto free_nci;\n\n\tndev->hci_dev = nci_hci_allocate(ndev);\n\tif (!ndev->hci_dev)\n\t\tgoto free_nfc;\n\n\tnfc_set_drvdata(ndev->nfc_dev, ndev);\n\n\treturn ndev;\n\nfree_nfc:\n\tnfc_free_device(ndev->nfc_dev);\nfree_nci:\n\tkfree(ndev);\n\treturn NULL;\n}\nEXPORT_SYMBOL(nci_allocate_device);\n\n \nvoid nci_free_device(struct nci_dev *ndev)\n{\n\tnfc_free_device(ndev->nfc_dev);\n\tnci_hci_deallocate(ndev);\n\tkfree(ndev);\n}\nEXPORT_SYMBOL(nci_free_device);\n\n \nint nci_register_device(struct nci_dev *ndev)\n{\n\tint rc;\n\tstruct device *dev = &ndev->nfc_dev->dev;\n\tchar name[32];\n\n\tndev->flags = 0;\n\n\tINIT_WORK(&ndev->cmd_work, nci_cmd_work);\n\tsnprintf(name, sizeof(name), \"%s_nci_cmd_wq\", dev_name(dev));\n\tndev->cmd_wq = create_singlethread_workqueue(name);\n\tif (!ndev->cmd_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tINIT_WORK(&ndev->rx_work, nci_rx_work);\n\tsnprintf(name, sizeof(name), \"%s_nci_rx_wq\", dev_name(dev));\n\tndev->rx_wq = create_singlethread_workqueue(name);\n\tif (!ndev->rx_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto destroy_cmd_wq_exit;\n\t}\n\n\tINIT_WORK(&ndev->tx_work, nci_tx_work);\n\tsnprintf(name, sizeof(name), \"%s_nci_tx_wq\", dev_name(dev));\n\tndev->tx_wq = create_singlethread_workqueue(name);\n\tif (!ndev->tx_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto destroy_rx_wq_exit;\n\t}\n\n\tskb_queue_head_init(&ndev->cmd_q);\n\tskb_queue_head_init(&ndev->rx_q);\n\tskb_queue_head_init(&ndev->tx_q);\n\n\ttimer_setup(&ndev->cmd_timer, nci_cmd_timer, 0);\n\ttimer_setup(&ndev->data_timer, nci_data_timer, 0);\n\n\tmutex_init(&ndev->req_lock);\n\tINIT_LIST_HEAD(&ndev->conn_info_list);\n\n\trc = nfc_register_device(ndev->nfc_dev);\n\tif (rc)\n\t\tgoto destroy_tx_wq_exit;\n\n\tgoto exit;\n\ndestroy_tx_wq_exit:\n\tdestroy_workqueue(ndev->tx_wq);\n\ndestroy_rx_wq_exit:\n\tdestroy_workqueue(ndev->rx_wq);\n\ndestroy_cmd_wq_exit:\n\tdestroy_workqueue(ndev->cmd_wq);\n\nexit:\n\treturn rc;\n}\nEXPORT_SYMBOL(nci_register_device);\n\n \nvoid nci_unregister_device(struct nci_dev *ndev)\n{\n\tstruct nci_conn_info *conn_info, *n;\n\n\t \n\tset_bit(NCI_UNREG, &ndev->flags);\n\n\tnci_close_device(ndev);\n\n\tdestroy_workqueue(ndev->cmd_wq);\n\tdestroy_workqueue(ndev->rx_wq);\n\tdestroy_workqueue(ndev->tx_wq);\n\n\tlist_for_each_entry_safe(conn_info, n, &ndev->conn_info_list, list) {\n\t\tlist_del(&conn_info->list);\n\t\t \n\t}\n\n\tnfc_unregister_device(ndev->nfc_dev);\n}\nEXPORT_SYMBOL(nci_unregister_device);\n\n \nint nci_recv_frame(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tpr_debug(\"len %d\\n\", skb->len);\n\n\tif (!ndev || (!test_bit(NCI_UP, &ndev->flags) &&\n\t    !test_bit(NCI_INIT, &ndev->flags))) {\n\t\tkfree_skb(skb);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tskb_queue_tail(&ndev->rx_q, skb);\n\tqueue_work(ndev->rx_wq, &ndev->rx_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nci_recv_frame);\n\nint nci_send_frame(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tpr_debug(\"len %d\\n\", skb->len);\n\n\tif (!ndev) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tskb_orphan(skb);\n\n\t \n\tnfc_send_to_raw_sock(ndev->nfc_dev, skb,\n\t\t\t     RAW_PAYLOAD_NCI, NFC_DIRECTION_TX);\n\n\treturn ndev->ops->send(ndev, skb);\n}\nEXPORT_SYMBOL(nci_send_frame);\n\n \nint nci_send_cmd(struct nci_dev *ndev, __u16 opcode, __u8 plen, const void *payload)\n{\n\tstruct nci_ctrl_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"opcode 0x%x, plen %d\\n\", opcode, plen);\n\n\tskb = nci_skb_alloc(ndev, (NCI_CTRL_HDR_SIZE + plen), GFP_KERNEL);\n\tif (!skb) {\n\t\tpr_err(\"no memory for command\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thdr = skb_put(skb, NCI_CTRL_HDR_SIZE);\n\thdr->gid = nci_opcode_gid(opcode);\n\thdr->oid = nci_opcode_oid(opcode);\n\thdr->plen = plen;\n\n\tnci_mt_set((__u8 *)hdr, NCI_MT_CMD_PKT);\n\tnci_pbf_set((__u8 *)hdr, NCI_PBF_LAST);\n\n\tif (plen)\n\t\tskb_put_data(skb, payload, plen);\n\n\tskb_queue_tail(&ndev->cmd_q, skb);\n\tqueue_work(ndev->cmd_wq, &ndev->cmd_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nci_send_cmd);\n\n \nstatic const struct nci_driver_ops *ops_cmd_lookup(const struct nci_driver_ops *ops,\n\t\t\t\t\t\t   size_t n_ops,\n\t\t\t\t\t\t   __u16 opcode)\n{\n\tsize_t i;\n\tconst struct nci_driver_ops *op;\n\n\tif (!ops || !n_ops)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_ops; i++) {\n\t\top = &ops[i];\n\t\tif (op->opcode == opcode)\n\t\t\treturn op;\n\t}\n\n\treturn NULL;\n}\n\nstatic int nci_op_rsp_packet(struct nci_dev *ndev, __u16 rsp_opcode,\n\t\t\t     struct sk_buff *skb, const struct nci_driver_ops *ops,\n\t\t\t     size_t n_ops)\n{\n\tconst struct nci_driver_ops *op;\n\n\top = ops_cmd_lookup(ops, n_ops, rsp_opcode);\n\tif (!op || !op->rsp)\n\t\treturn -ENOTSUPP;\n\n\treturn op->rsp(ndev, skb);\n}\n\nstatic int nci_op_ntf_packet(struct nci_dev *ndev, __u16 ntf_opcode,\n\t\t\t     struct sk_buff *skb, const struct nci_driver_ops *ops,\n\t\t\t     size_t n_ops)\n{\n\tconst struct nci_driver_ops *op;\n\n\top = ops_cmd_lookup(ops, n_ops, ntf_opcode);\n\tif (!op || !op->ntf)\n\t\treturn -ENOTSUPP;\n\n\treturn op->ntf(ndev, skb);\n}\n\nint nci_prop_rsp_packet(struct nci_dev *ndev, __u16 opcode,\n\t\t\tstruct sk_buff *skb)\n{\n\treturn nci_op_rsp_packet(ndev, opcode, skb, ndev->ops->prop_ops,\n\t\t\t\t ndev->ops->n_prop_ops);\n}\n\nint nci_prop_ntf_packet(struct nci_dev *ndev, __u16 opcode,\n\t\t\tstruct sk_buff *skb)\n{\n\treturn nci_op_ntf_packet(ndev, opcode, skb, ndev->ops->prop_ops,\n\t\t\t\t ndev->ops->n_prop_ops);\n}\n\nint nci_core_rsp_packet(struct nci_dev *ndev, __u16 opcode,\n\t\t\tstruct sk_buff *skb)\n{\n\treturn nci_op_rsp_packet(ndev, opcode, skb, ndev->ops->core_ops,\n\t\t\t\t  ndev->ops->n_core_ops);\n}\n\nint nci_core_ntf_packet(struct nci_dev *ndev, __u16 opcode,\n\t\t\tstruct sk_buff *skb)\n{\n\treturn nci_op_ntf_packet(ndev, opcode, skb, ndev->ops->core_ops,\n\t\t\t\t ndev->ops->n_core_ops);\n}\n\n \n\nstatic void nci_tx_work(struct work_struct *work)\n{\n\tstruct nci_dev *ndev = container_of(work, struct nci_dev, tx_work);\n\tstruct nci_conn_info *conn_info;\n\tstruct sk_buff *skb;\n\n\tconn_info = nci_get_conn_info_by_conn_id(ndev, ndev->cur_conn_id);\n\tif (!conn_info)\n\t\treturn;\n\n\tpr_debug(\"credits_cnt %d\\n\", atomic_read(&conn_info->credits_cnt));\n\n\t \n\twhile (atomic_read(&conn_info->credits_cnt)) {\n\t\tskb = skb_dequeue(&ndev->tx_q);\n\t\tif (!skb)\n\t\t\treturn;\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\t\t \n\t\tif (atomic_read(&conn_info->credits_cnt) !=\n\t\t    NCI_DATA_FLOW_CONTROL_NOT_USED)\n\t\t\tatomic_dec(&conn_info->credits_cnt);\n\n\t\tpr_debug(\"NCI TX: MT=data, PBF=%d, conn_id=%d, plen=%d\\n\",\n\t\t\t nci_pbf(skb->data),\n\t\t\t nci_conn_id(skb->data),\n\t\t\t nci_plen(skb->data));\n\n\t\tnci_send_frame(ndev, skb);\n\n\t\tmod_timer(&ndev->data_timer,\n\t\t\t  jiffies + msecs_to_jiffies(NCI_DATA_TIMEOUT));\n\t\tkcov_remote_stop();\n\t}\n}\n\n \n\nstatic void nci_rx_work(struct work_struct *work)\n{\n\tstruct nci_dev *ndev = container_of(work, struct nci_dev, rx_work);\n\tstruct sk_buff *skb;\n\n\tfor (; (skb = skb_dequeue(&ndev->rx_q)); kcov_remote_stop()) {\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\t\t \n\t\tnfc_send_to_raw_sock(ndev->nfc_dev, skb,\n\t\t\t\t     RAW_PAYLOAD_NCI, NFC_DIRECTION_RX);\n\n\t\t \n\t\tswitch (nci_mt(skb->data)) {\n\t\tcase NCI_MT_RSP_PKT:\n\t\t\tnci_rsp_packet(ndev, skb);\n\t\t\tbreak;\n\n\t\tcase NCI_MT_NTF_PKT:\n\t\t\tnci_ntf_packet(ndev, skb);\n\t\t\tbreak;\n\n\t\tcase NCI_MT_DATA_PKT:\n\t\t\tnci_rx_data_packet(ndev, skb);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"unknown MT 0x%x\\n\", nci_mt(skb->data));\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(NCI_DATA_EXCHANGE_TO, &ndev->flags)) {\n\t\t \n\t\tif (test_bit(NCI_DATA_EXCHANGE, &ndev->flags))\n\t\t\tnci_data_exchange_complete(ndev, NULL,\n\t\t\t\t\t\t   ndev->cur_conn_id,\n\t\t\t\t\t\t   -ETIMEDOUT);\n\n\t\tclear_bit(NCI_DATA_EXCHANGE_TO, &ndev->flags);\n\t}\n}\n\n \n\nstatic void nci_cmd_work(struct work_struct *work)\n{\n\tstruct nci_dev *ndev = container_of(work, struct nci_dev, cmd_work);\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"cmd_cnt %d\\n\", atomic_read(&ndev->cmd_cnt));\n\n\t \n\tif (atomic_read(&ndev->cmd_cnt)) {\n\t\tskb = skb_dequeue(&ndev->cmd_q);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\t\tatomic_dec(&ndev->cmd_cnt);\n\n\t\tpr_debug(\"NCI TX: MT=cmd, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\\n\",\n\t\t\t nci_pbf(skb->data),\n\t\t\t nci_opcode_gid(nci_opcode(skb->data)),\n\t\t\t nci_opcode_oid(nci_opcode(skb->data)),\n\t\t\t nci_plen(skb->data));\n\n\t\tnci_send_frame(ndev, skb);\n\n\t\tmod_timer(&ndev->cmd_timer,\n\t\t\t  jiffies + msecs_to_jiffies(NCI_CMD_TIMEOUT));\n\t\tkcov_remote_stop();\n\t}\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}