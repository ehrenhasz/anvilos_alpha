{
  "module_name": "llcp_commands.c",
  "hash_id": "bb5f98f3a81cc0eba9731aabac4a3f305bb84347ffefcde1bbe3836a4d619c2b",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/llcp_commands.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"llcp: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const u8 llcp_tlv_length[LLCP_TLV_MAX] = {\n\t0,\n\t1,  \n\t2,  \n\t2,  \n\t1,  \n\t1,  \n\t0,  \n\t1,  \n\t0,  \n\t2,  \n\n};\n\nstatic u8 llcp_tlv8(const u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn tlv[2];\n}\n\nstatic u16 llcp_tlv16(const u8 *tlv, u8 type)\n{\n\tif (tlv[0] != type || tlv[1] != llcp_tlv_length[tlv[0]])\n\t\treturn 0;\n\n\treturn be16_to_cpu(*((__be16 *)(tlv + 2)));\n}\n\n\nstatic u8 llcp_tlv_version(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_VERSION);\n}\n\nstatic u16 llcp_tlv_miux(const u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n\nstatic u16 llcp_tlv_wks(const u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_WKS);\n}\n\nstatic u16 llcp_tlv_lto(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_LTO);\n}\n\nstatic u8 llcp_tlv_opt(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_OPT);\n}\n\nstatic u8 llcp_tlv_rw(const u8 *tlv)\n{\n\treturn llcp_tlv8(tlv, LLCP_TLV_RW) & 0xf;\n}\n\nu8 *nfc_llcp_build_tlv(u8 type, const u8 *value, u8 value_length, u8 *tlv_length)\n{\n\tu8 *tlv, length;\n\n\tpr_debug(\"type %d\\n\", type);\n\n\tif (type >= LLCP_TLV_MAX)\n\t\treturn NULL;\n\n\tlength = llcp_tlv_length[type];\n\tif (length == 0 && value_length == 0)\n\t\treturn NULL;\n\telse if (length == 0)\n\t\tlength = value_length;\n\n\t*tlv_length = 2 + length;\n\ttlv = kzalloc(2 + length, GFP_KERNEL);\n\tif (tlv == NULL)\n\t\treturn tlv;\n\n\ttlv[0] = type;\n\ttlv[1] = length;\n\tmemcpy(tlv + 2, value, length);\n\n\treturn tlv;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdres_tlv(u8 tid, u8 sap)\n{\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tu8 value[2];\n\n\tsdres = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdres == NULL)\n\t\treturn NULL;\n\n\tvalue[0] = tid;\n\tvalue[1] = sap;\n\n\tsdres->tlv = nfc_llcp_build_tlv(LLCP_TLV_SDRES, value, 2,\n\t\t\t\t\t&sdres->tlv_len);\n\tif (sdres->tlv == NULL) {\n\t\tkfree(sdres);\n\t\treturn NULL;\n\t}\n\n\tsdres->tid = tid;\n\tsdres->sap = sap;\n\n\tINIT_HLIST_NODE(&sdres->node);\n\n\treturn sdres;\n}\n\nstruct nfc_llcp_sdp_tlv *nfc_llcp_build_sdreq_tlv(u8 tid, const char *uri,\n\t\t\t\t\t\t  size_t uri_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tpr_debug(\"uri: %s, len: %zu\\n\", uri, uri_len);\n\n\t \n\tif (WARN_ON_ONCE(uri_len > U8_MAX - 4))\n\t\treturn NULL;\n\n\tsdreq = kzalloc(sizeof(struct nfc_llcp_sdp_tlv), GFP_KERNEL);\n\tif (sdreq == NULL)\n\t\treturn NULL;\n\n\tsdreq->tlv_len = uri_len + 3;\n\n\tif (uri[uri_len - 1] == 0)\n\t\tsdreq->tlv_len--;\n\n\tsdreq->tlv = kzalloc(sdreq->tlv_len + 1, GFP_KERNEL);\n\tif (sdreq->tlv == NULL) {\n\t\tkfree(sdreq);\n\t\treturn NULL;\n\t}\n\n\tsdreq->tlv[0] = LLCP_TLV_SDREQ;\n\tsdreq->tlv[1] = sdreq->tlv_len - 2;\n\tsdreq->tlv[2] = tid;\n\n\tsdreq->tid = tid;\n\tsdreq->uri = sdreq->tlv + 3;\n\tmemcpy(sdreq->uri, uri, uri_len);\n\n\tsdreq->time = jiffies;\n\n\tINIT_HLIST_NODE(&sdreq->node);\n\n\treturn sdreq;\n}\n\nvoid nfc_llcp_free_sdp_tlv(struct nfc_llcp_sdp_tlv *sdp)\n{\n\tkfree(sdp->tlv);\n\tkfree(sdp);\n}\n\nvoid nfc_llcp_free_sdp_tlv_list(struct hlist_head *head)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_safe(sdp, n, head, node) {\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n}\n\nint nfc_llcp_parse_gb_tlv(struct nfc_llcp_local *local,\n\t\t\t  const u8 *tlv_array, u16 tlv_array_len)\n{\n\tconst u8 *tlv = tlv_array;\n\tu8 type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_VERSION:\n\t\t\tlocal->remote_version = llcp_tlv_version(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tlocal->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_WKS:\n\t\t\tlocal->remote_wks = llcp_tlv_wks(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_LTO:\n\t\t\tlocal->remote_lto = llcp_tlv_lto(tlv) * 10;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_OPT:\n\t\t\tlocal->remote_opt = llcp_tlv_opt(tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"version 0x%x miu %d lto %d opt 0x%x wks 0x%x\\n\",\n\t\t local->remote_version, local->remote_miu,\n\t\t local->remote_lto, local->remote_opt,\n\t\t local->remote_wks);\n\n\treturn 0;\n}\n\nint nfc_llcp_parse_connection_tlv(struct nfc_llcp_sock *sock,\n\t\t\t\t  const u8 *tlv_array, u16 tlv_array_len)\n{\n\tconst u8 *tlv = tlv_array;\n\tu8 type, length, offset = 0;\n\n\tpr_debug(\"TLV array length %d\\n\", tlv_array_len);\n\n\tif (sock == NULL)\n\t\treturn -ENOTCONN;\n\n\twhile (offset < tlv_array_len) {\n\t\ttype = tlv[0];\n\t\tlength = tlv[1];\n\n\t\tpr_debug(\"type 0x%x length %d\\n\", type, length);\n\n\t\tswitch (type) {\n\t\tcase LLCP_TLV_MIUX:\n\t\t\tsock->remote_miu = llcp_tlv_miux(tlv) + 128;\n\t\t\tbreak;\n\t\tcase LLCP_TLV_RW:\n\t\t\tsock->remote_rw = llcp_tlv_rw(tlv);\n\t\t\tbreak;\n\t\tcase LLCP_TLV_SN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid gt tlv value 0x%x\\n\", type);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += length + 2;\n\t\ttlv += length + 2;\n\t}\n\n\tpr_debug(\"sock %p rw %d miu %d\\n\", sock,\n\t\t sock->remote_rw, sock->remote_miu);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *llcp_add_header(struct sk_buff *pdu,\n\t\t\t\t       u8 dsap, u8 ssap, u8 ptype)\n{\n\tu8 header[2];\n\n\tpr_debug(\"ptype 0x%x dsap 0x%x ssap 0x%x\\n\", ptype, dsap, ssap);\n\n\theader[0] = (u8)((dsap << 2) | (ptype >> 2));\n\theader[1] = (u8)((ptype << 6) | ssap);\n\n\tpr_debug(\"header 0x%x 0x%x\\n\", header[0], header[1]);\n\n\tskb_put_data(pdu, header, LLCP_HEADER_SIZE);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_add_tlv(struct sk_buff *pdu, const u8 *tlv,\n\t\t\t\t    u8 tlv_length)\n{\n\t \n\n\tif (tlv == NULL)\n\t\treturn NULL;\n\n\tskb_put_data(pdu, tlv, tlv_length);\n\n\treturn pdu;\n}\n\nstatic struct sk_buff *llcp_allocate_pdu(struct nfc_llcp_sock *sock,\n\t\t\t\t\t u8 cmd, u16 size)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (sock->ssap == 0)\n\t\treturn NULL;\n\n\tskb = nfc_alloc_send_skb(sock->dev, &sock->sk, MSG_DONTWAIT,\n\t\t\t\t size + LLCP_HEADER_SIZE, &err);\n\tif (skb == NULL) {\n\t\tpr_err(\"Could not allocate PDU\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = llcp_add_header(skb, sock->dsap, sock->ssap, cmd);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_disconnect(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = sock->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_DISC, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tint err;\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\n\t__net_timestamp(skb);\n\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\n\terr = nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\nout:\n\tnfc_llcp_local_put(local);\n\treturn err;\n}\n\nint nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tconst u8 *service_name_tlv = NULL;\n\tconst u8 *miux_tlv = NULL;\n\tconst u8 *rw_tlv = NULL;\n\tu8 service_name_tlv_length = 0;\n\tu8 miux_tlv_length,  rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tif (sock->service_name != NULL) {\n\t\tservice_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,\n\t\t\t\t\t\t      sock->service_name,\n\t\t\t\t\t\t      sock->service_name_len,\n\t\t\t\t\t\t      &service_name_tlv_length);\n\t\tif (!service_name_tlv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_tlv;\n\t\t}\n\t\tsize += service_name_tlv_length;\n\t}\n\n\t \n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(service_name_tlv);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nint nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tconst u8 *miux_tlv = NULL;\n\tconst u8 *rw_tlv = NULL;\n\tu8 miux_tlv_length, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n\nstatic struct sk_buff *nfc_llcp_allocate_snl(struct nfc_llcp_local *local,\n\t\t\t\t\t     size_t tlv_length)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 0;\n\n\tif (local == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tsize += tlv_length;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, LLCP_SAP_SDP, LLCP_SAP_SDP, LLCP_PDU_SNL);\n\n\treturn skb;\n}\n\nint nfc_llcp_send_snl_sdres(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdp;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\thlist_for_each_entry_safe(sdp, n, tlv_list, node) {\n\t\tskb_put_data(skb, sdp->tlv, sdp->tlv_len);\n\n\t\thlist_del(&sdp->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdp);\n\t}\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_snl_sdreq(struct nfc_llcp_local *local,\n\t\t\t    struct hlist_head *tlv_list, size_t tlvs_len)\n{\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\tstruct hlist_node *n;\n\tstruct sk_buff *skb;\n\n\tskb = nfc_llcp_allocate_snl(local, tlvs_len);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tmutex_lock(&local->sdreq_lock);\n\n\tif (hlist_empty(&local->pending_sdreqs))\n\t\tmod_timer(&local->sdreq_timer,\n\t\t\t  jiffies + msecs_to_jiffies(3 * local->remote_lto));\n\n\thlist_for_each_entry_safe(sdreq, n, tlv_list, node) {\n\t\tpr_debug(\"tid %d for %s\\n\", sdreq->tid, sdreq->uri);\n\n\t\tskb_put_data(skb, sdreq->tlv, sdreq->tlv_len);\n\n\t\thlist_del(&sdreq->node);\n\n\t\thlist_add_head(&sdreq->node, &local->pending_sdreqs);\n\t}\n\n\tmutex_unlock(&local->sdreq_lock);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 1;  \n\n\tpr_debug(\"Sending DM reason 0x%x\\n\", reason);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\n\n\tskb_put_data(skb, &reason, 1);\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n\nint nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,\n\t\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct sock *sk = &sock->sk;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_data, *msg_ptr;\n\tu16 remote_miu;\n\n\tpr_debug(\"Send I frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif((sock->remote_ready &&\n\t    skb_queue_len(&sock->tx_pending_queue) >= sock->remote_rw &&\n\t    skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Pending queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_pending_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\t \n\tif ((!sock->remote_ready &&\n\t     skb_queue_len(&sock->tx_queue) >= 2 * sock->remote_rw)) {\n\t\tpr_err(\"Tx queue is full %d frames\\n\",\n\t\t       skb_queue_len(&sock->tx_queue));\n\t\treturn -ENOBUFS;\n\t}\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tLLCP_DEFAULT_MIU : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = llcp_allocate_pdu(sock, LLCP_PDU_I,\n\t\t\t\t\tfrag_len + LLCP_SEQUENCE_SIZE);\n\t\tif (pdu == NULL) {\n\t\t\tkfree(msg_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_put(pdu, LLCP_SEQUENCE_SIZE);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\tskb_queue_tail(&sock->tx_queue, pdu);\n\n\t\tlock_sock(sk);\n\n\t\tnfc_llcp_queue_i_frames(sock);\n\n\t\trelease_sock(sk);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *pdu;\n\tstruct nfc_llcp_local *local;\n\tsize_t frag_len = 0, remaining_len;\n\tu8 *msg_ptr, *msg_data;\n\tu16 remote_miu;\n\tint err;\n\n\tpr_debug(\"Send UI frame len %zd\\n\", len);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tmsg_data = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (msg_data == NULL)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(msg_data, msg, len)) {\n\t\tkfree(msg_data);\n\t\treturn -EFAULT;\n\t}\n\n\tremaining_len = len;\n\tmsg_ptr = msg_data;\n\n\tdo {\n\t\tremote_miu = sock->remote_miu > LLCP_MAX_MIU ?\n\t\t\t\tlocal->remote_miu : sock->remote_miu;\n\n\t\tfrag_len = min_t(size_t, remote_miu, remaining_len);\n\n\t\tpr_debug(\"Fragment %zd bytes remaining %zd\",\n\t\t\t frag_len, remaining_len);\n\n\t\tpdu = nfc_alloc_send_skb(sock->dev, &sock->sk, 0,\n\t\t\t\t\t frag_len + LLCP_HEADER_SIZE, &err);\n\t\tif (pdu == NULL) {\n\t\t\tpr_err(\"Could not allocate PDU (error=%d)\\n\", err);\n\t\t\tlen -= remaining_len;\n\t\t\tif (len == 0)\n\t\t\t\tlen = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tpdu = llcp_add_header(pdu, dsap, ssap, LLCP_PDU_UI);\n\n\t\tif (likely(frag_len > 0))\n\t\t\tskb_put_data(pdu, msg_ptr, frag_len);\n\n\t\t \n\t\tskb_queue_tail(&local->tx_queue, pdu);\n\n\t\tremaining_len -= frag_len;\n\t\tmsg_ptr += frag_len;\n\t} while (remaining_len > 0);\n\n\tkfree(msg_data);\n\n\treturn len;\n}\n\nint nfc_llcp_send_rr(struct nfc_llcp_sock *sock)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\n\tpr_debug(\"Send rr nr %d\\n\", sock->recv_n);\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_RR, LLCP_SEQUENCE_SIZE);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, LLCP_SEQUENCE_SIZE);\n\n\tskb->data[2] = sock->recv_n;\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}