{
  "module_name": "core.c",
  "hash_id": "3a038f25b82ea3f1432c0842001b31ea556f79014cbe7fea2bc2f27193fad492",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/hci/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"hci: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n\n#include <net/nfc/nfc.h>\n#include <net/nfc/hci.h>\n#include <net/nfc/llc.h>\n\n#include \"hci.h\"\n\n \n#define HCI_CMDS_HEADROOM 1\n\nint nfc_hci_result_to_errno(u8 result)\n{\n\tswitch (result) {\n\tcase NFC_HCI_ANY_OK:\n\t\treturn 0;\n\tcase NFC_HCI_ANY_E_REG_PAR_UNKNOWN:\n\t\treturn -EOPNOTSUPP;\n\tcase NFC_HCI_ANY_E_TIMEOUT:\n\t\treturn -ETIME;\n\tdefault:\n\t\treturn -1;\n\t}\n}\nEXPORT_SYMBOL(nfc_hci_result_to_errno);\n\nvoid nfc_hci_reset_pipes(struct nfc_hci_dev *hdev)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < NFC_HCI_MAX_PIPES; i++) {\n\t\thdev->pipes[i].gate = NFC_HCI_INVALID_GATE;\n\t\thdev->pipes[i].dest_host = NFC_HCI_INVALID_HOST;\n\t}\n\tmemset(hdev->gate2pipe, NFC_HCI_INVALID_PIPE, sizeof(hdev->gate2pipe));\n}\nEXPORT_SYMBOL(nfc_hci_reset_pipes);\n\nvoid nfc_hci_reset_pipes_per_host(struct nfc_hci_dev *hdev, u8 host)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < NFC_HCI_MAX_PIPES; i++) {\n\t\tif (hdev->pipes[i].dest_host != host)\n\t\t\tcontinue;\n\n\t\thdev->pipes[i].gate = NFC_HCI_INVALID_GATE;\n\t\thdev->pipes[i].dest_host = NFC_HCI_INVALID_HOST;\n\t}\n}\nEXPORT_SYMBOL(nfc_hci_reset_pipes_per_host);\n\nstatic void nfc_hci_msg_tx_work(struct work_struct *work)\n{\n\tstruct nfc_hci_dev *hdev = container_of(work, struct nfc_hci_dev,\n\t\t\t\t\t\tmsg_tx_work);\n\tstruct hci_msg *msg;\n\tstruct sk_buff *skb;\n\tint r = 0;\n\n\tmutex_lock(&hdev->msg_tx_mutex);\n\tif (hdev->shutting_down)\n\t\tgoto exit;\n\n\tif (hdev->cmd_pending_msg) {\n\t\tif (timer_pending(&hdev->cmd_timer) == 0) {\n\t\t\tif (hdev->cmd_pending_msg->cb)\n\t\t\t\thdev->cmd_pending_msg->cb(hdev->\n\t\t\t\t\t\t\t  cmd_pending_msg->\n\t\t\t\t\t\t\t  cb_context,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  -ETIME);\n\t\t\tkfree(hdev->cmd_pending_msg);\n\t\t\thdev->cmd_pending_msg = NULL;\n\t\t} else {\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nnext_msg:\n\tif (list_empty(&hdev->msg_tx_queue))\n\t\tgoto exit;\n\n\tmsg = list_first_entry(&hdev->msg_tx_queue, struct hci_msg, msg_l);\n\tlist_del(&msg->msg_l);\n\n\tpr_debug(\"msg_tx_queue has a cmd to send\\n\");\n\twhile ((skb = skb_dequeue(&msg->msg_frags)) != NULL) {\n\t\tr = nfc_llc_xmit_from_hci(hdev->llc, skb);\n\t\tif (r < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tskb_queue_purge(&msg->msg_frags);\n\t\t\tif (msg->cb)\n\t\t\t\tmsg->cb(msg->cb_context, NULL, r);\n\t\t\tkfree(msg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (r)\n\t\tgoto next_msg;\n\n\tif (msg->wait_response == false) {\n\t\tkfree(msg);\n\t\tgoto next_msg;\n\t}\n\n\thdev->cmd_pending_msg = msg;\n\tmod_timer(&hdev->cmd_timer, jiffies +\n\t\t  msecs_to_jiffies(hdev->cmd_pending_msg->completion_delay));\n\nexit:\n\tmutex_unlock(&hdev->msg_tx_mutex);\n}\n\nstatic void nfc_hci_msg_rx_work(struct work_struct *work)\n{\n\tstruct nfc_hci_dev *hdev = container_of(work, struct nfc_hci_dev,\n\t\t\t\t\t\tmsg_rx_work);\n\tstruct sk_buff *skb;\n\tconst struct hcp_message *message;\n\tu8 pipe;\n\tu8 type;\n\tu8 instruction;\n\n\twhile ((skb = skb_dequeue(&hdev->msg_rx_queue)) != NULL) {\n\t\tpipe = skb->data[0];\n\t\tskb_pull(skb, NFC_HCI_HCP_PACKET_HEADER_LEN);\n\t\tmessage = (struct hcp_message *)skb->data;\n\t\ttype = HCP_MSG_GET_TYPE(message->header);\n\t\tinstruction = HCP_MSG_GET_CMD(message->header);\n\t\tskb_pull(skb, NFC_HCI_HCP_MESSAGE_HEADER_LEN);\n\n\t\tnfc_hci_hcp_message_rx(hdev, pipe, type, instruction, skb);\n\t}\n}\n\nstatic void __nfc_hci_cmd_completion(struct nfc_hci_dev *hdev, int err,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tdel_timer_sync(&hdev->cmd_timer);\n\n\tif (hdev->cmd_pending_msg->cb)\n\t\thdev->cmd_pending_msg->cb(hdev->cmd_pending_msg->cb_context,\n\t\t\t\t\t  skb, err);\n\telse\n\t\tkfree_skb(skb);\n\n\tkfree(hdev->cmd_pending_msg);\n\thdev->cmd_pending_msg = NULL;\n\n\tschedule_work(&hdev->msg_tx_work);\n}\n\nvoid nfc_hci_resp_received(struct nfc_hci_dev *hdev, u8 result,\n\t\t\t   struct sk_buff *skb)\n{\n\tmutex_lock(&hdev->msg_tx_mutex);\n\n\tif (hdev->cmd_pending_msg == NULL) {\n\t\tkfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\t__nfc_hci_cmd_completion(hdev, nfc_hci_result_to_errno(result), skb);\n\nexit:\n\tmutex_unlock(&hdev->msg_tx_mutex);\n}\n\nvoid nfc_hci_cmd_received(struct nfc_hci_dev *hdev, u8 pipe, u8 cmd,\n\t\t\t  struct sk_buff *skb)\n{\n\tu8 status = NFC_HCI_ANY_OK;\n\tconst struct hci_create_pipe_resp *create_info;\n\tconst struct hci_delete_pipe_noti *delete_info;\n\tconst struct hci_all_pipe_cleared_noti *cleared_info;\n\tu8 gate;\n\n\tpr_debug(\"from pipe %x cmd %x\\n\", pipe, cmd);\n\n\tif (pipe >= NFC_HCI_MAX_PIPES) {\n\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\tgoto exit;\n\t}\n\n\tgate = hdev->pipes[pipe].gate;\n\n\tswitch (cmd) {\n\tcase NFC_HCI_ADM_NOTIFY_PIPE_CREATED:\n\t\tif (skb->len != 5) {\n\t\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tcreate_info = (struct hci_create_pipe_resp *)skb->data;\n\n\t\tif (create_info->pipe >= NFC_HCI_MAX_PIPES) {\n\t\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\thdev->gate2pipe[create_info->dest_gate] = create_info->pipe;\n\t\thdev->pipes[create_info->pipe].gate = create_info->dest_gate;\n\t\thdev->pipes[create_info->pipe].dest_host =\n\t\t\t\t\t\t\tcreate_info->src_host;\n\t\tbreak;\n\tcase NFC_HCI_ANY_OPEN_PIPE:\n\t\tif (gate == NFC_HCI_INVALID_GATE) {\n\t\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase NFC_HCI_ADM_NOTIFY_PIPE_DELETED:\n\t\tif (skb->len != 1) {\n\t\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tdelete_info = (struct hci_delete_pipe_noti *)skb->data;\n\n\t\tif (delete_info->pipe >= NFC_HCI_MAX_PIPES) {\n\t\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\n\t\thdev->pipes[delete_info->pipe].gate = NFC_HCI_INVALID_GATE;\n\t\thdev->pipes[delete_info->pipe].dest_host = NFC_HCI_INVALID_HOST;\n\t\tbreak;\n\tcase NFC_HCI_ADM_NOTIFY_ALL_PIPE_CLEARED:\n\t\tif (skb->len != 1) {\n\t\t\tstatus = NFC_HCI_ANY_E_NOK;\n\t\t\tgoto exit;\n\t\t}\n\t\tcleared_info = (struct hci_all_pipe_cleared_noti *)skb->data;\n\n\t\tnfc_hci_reset_pipes_per_host(hdev, cleared_info->host);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Discarded unknown cmd %x to gate %x\\n\", cmd, gate);\n\t\tbreak;\n\t}\n\n\tif (hdev->ops->cmd_received)\n\t\thdev->ops->cmd_received(hdev, pipe, cmd, skb);\n\nexit:\n\tnfc_hci_hcp_message_tx(hdev, pipe, NFC_HCI_HCP_RESPONSE,\n\t\t\t       status, NULL, 0, NULL, NULL, 0);\n\n\tkfree_skb(skb);\n}\n\nu32 nfc_hci_sak_to_protocol(u8 sak)\n{\n\tswitch (NFC_HCI_TYPE_A_SEL_PROT(sak)) {\n\tcase NFC_HCI_TYPE_A_SEL_PROT_MIFARE:\n\t\treturn NFC_PROTO_MIFARE_MASK;\n\tcase NFC_HCI_TYPE_A_SEL_PROT_ISO14443:\n\t\treturn NFC_PROTO_ISO14443_MASK;\n\tcase NFC_HCI_TYPE_A_SEL_PROT_DEP:\n\t\treturn NFC_PROTO_NFC_DEP_MASK;\n\tcase NFC_HCI_TYPE_A_SEL_PROT_ISO14443_DEP:\n\t\treturn NFC_PROTO_ISO14443_MASK | NFC_PROTO_NFC_DEP_MASK;\n\tdefault:\n\t\treturn 0xffffffff;\n\t}\n}\nEXPORT_SYMBOL(nfc_hci_sak_to_protocol);\n\nint nfc_hci_target_discovered(struct nfc_hci_dev *hdev, u8 gate)\n{\n\tstruct nfc_target *targets;\n\tstruct sk_buff *atqa_skb = NULL;\n\tstruct sk_buff *sak_skb = NULL;\n\tstruct sk_buff *uid_skb = NULL;\n\tint r;\n\n\tpr_debug(\"from gate %d\\n\", gate);\n\n\ttargets = kzalloc(sizeof(struct nfc_target), GFP_KERNEL);\n\tif (targets == NULL)\n\t\treturn -ENOMEM;\n\n\tswitch (gate) {\n\tcase NFC_HCI_RF_READER_A_GATE:\n\t\tr = nfc_hci_get_param(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t      NFC_HCI_RF_READER_A_ATQA, &atqa_skb);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tr = nfc_hci_get_param(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t      NFC_HCI_RF_READER_A_SAK, &sak_skb);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tif (atqa_skb->len != 2 || sak_skb->len != 1) {\n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttargets->supported_protocols =\n\t\t\t\tnfc_hci_sak_to_protocol(sak_skb->data[0]);\n\t\tif (targets->supported_protocols == 0xffffffff) {\n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttargets->sens_res = be16_to_cpu(*(__be16 *)atqa_skb->data);\n\t\ttargets->sel_res = sak_skb->data[0];\n\n\t\tr = nfc_hci_get_param(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t      NFC_HCI_RF_READER_A_UID, &uid_skb);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tif (uid_skb->len == 0 || uid_skb->len > NFC_NFCID1_MAXSIZE) {\n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmemcpy(targets->nfcid1, uid_skb->data, uid_skb->len);\n\t\ttargets->nfcid1_len = uid_skb->len;\n\n\t\tif (hdev->ops->complete_target_discovered) {\n\t\t\tr = hdev->ops->complete_target_discovered(hdev, gate,\n\t\t\t\t\t\t\t\t  targets);\n\t\t\tif (r < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase NFC_HCI_RF_READER_B_GATE:\n\t\ttargets->supported_protocols = NFC_PROTO_ISO14443_B_MASK;\n\t\tbreak;\n\tdefault:\n\t\tif (hdev->ops->target_from_gate)\n\t\t\tr = hdev->ops->target_from_gate(hdev, gate, targets);\n\t\telse\n\t\t\tr = -EPROTO;\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tif (hdev->ops->complete_target_discovered) {\n\t\t\tr = hdev->ops->complete_target_discovered(hdev, gate,\n\t\t\t\t\t\t\t\t  targets);\n\t\t\tif (r < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (targets->hci_reader_gate == 0x00)\n\t\ttargets->hci_reader_gate = gate;\n\n\tr = nfc_targets_found(hdev->ndev, targets, 1);\n\nexit:\n\tkfree(targets);\n\tkfree_skb(atqa_skb);\n\tkfree_skb(sak_skb);\n\tkfree_skb(uid_skb);\n\n\treturn r;\n}\nEXPORT_SYMBOL(nfc_hci_target_discovered);\n\nvoid nfc_hci_event_received(struct nfc_hci_dev *hdev, u8 pipe, u8 event,\n\t\t\t    struct sk_buff *skb)\n{\n\tint r = 0;\n\tu8 gate;\n\n\tif (pipe >= NFC_HCI_MAX_PIPES) {\n\t\tpr_err(\"Discarded event %x to invalid pipe %x\\n\", event, pipe);\n\t\tgoto exit;\n\t}\n\n\tgate = hdev->pipes[pipe].gate;\n\tif (gate == NFC_HCI_INVALID_GATE) {\n\t\tpr_err(\"Discarded event %x to unopened pipe %x\\n\", event, pipe);\n\t\tgoto exit;\n\t}\n\n\tif (hdev->ops->event_received) {\n\t\tr = hdev->ops->event_received(hdev, pipe, event, skb);\n\t\tif (r <= 0)\n\t\t\tgoto exit_noskb;\n\t}\n\n\tswitch (event) {\n\tcase NFC_HCI_EVT_TARGET_DISCOVERED:\n\t\tif (skb->len < 1) {\t \n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (skb->data[0] == 3) {\n\t\t\t \n\t\t}\n\n\t\tif (skb->data[0] != 0) {\n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tr = nfc_hci_target_discovered(hdev, gate);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Discarded unknown event %x to gate %x\\n\", event, gate);\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\nexit:\n\tkfree_skb(skb);\n\nexit_noskb:\n\tif (r)\n\t\tnfc_hci_driver_failure(hdev, r);\n}\n\nstatic void nfc_hci_cmd_timeout(struct timer_list *t)\n{\n\tstruct nfc_hci_dev *hdev = from_timer(hdev, t, cmd_timer);\n\n\tschedule_work(&hdev->msg_tx_work);\n}\n\nstatic int hci_dev_connect_gates(struct nfc_hci_dev *hdev, u8 gate_count,\n\t\t\t\t const struct nfc_hci_gate *gates)\n{\n\tint r;\n\twhile (gate_count--) {\n\t\tr = nfc_hci_connect_gate(hdev, NFC_HCI_HOST_CONTROLLER_ID,\n\t\t\t\t\t gates->gate, gates->pipe);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tgates++;\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_dev_session_init(struct nfc_hci_dev *hdev)\n{\n\tstruct sk_buff *skb = NULL;\n\tint r;\n\n\tif (hdev->init_data.gates[0].gate != NFC_HCI_ADMIN_GATE)\n\t\treturn -EPROTO;\n\n\tr = nfc_hci_connect_gate(hdev, NFC_HCI_HOST_CONTROLLER_ID,\n\t\t\t\t hdev->init_data.gates[0].gate,\n\t\t\t\t hdev->init_data.gates[0].pipe);\n\tif (r < 0)\n\t\tgoto exit;\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\t      NFC_HCI_ADMIN_SESSION_IDENTITY, &skb);\n\tif (r < 0)\n\t\tgoto disconnect_all;\n\n\tif (skb->len && skb->len == strlen(hdev->init_data.session_id) &&\n\t\t(memcmp(hdev->init_data.session_id, skb->data,\n\t\t\t   skb->len) == 0) && hdev->ops->load_session) {\n\t\t \n\n\t\tr = hdev->ops->load_session(hdev);\n\n\t\tif (r < 0)\n\t\t\tgoto disconnect_all;\n\t} else {\n\n\t\tr = nfc_hci_disconnect_all_gates(hdev);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tr = hci_dev_connect_gates(hdev, hdev->init_data.gate_count,\n\t\t\t\t\t  hdev->init_data.gates);\n\t\tif (r < 0)\n\t\t\tgoto disconnect_all;\n\n\t\tr = nfc_hci_set_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\t\tNFC_HCI_ADMIN_SESSION_IDENTITY,\n\t\t\t\thdev->init_data.session_id,\n\t\t\t\tstrlen(hdev->init_data.session_id));\n\t}\n\tif (r == 0)\n\t\tgoto exit;\n\ndisconnect_all:\n\tnfc_hci_disconnect_all_gates(hdev);\n\nexit:\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\nstatic int hci_dev_version(struct nfc_hci_dev *hdev)\n{\n\tint r;\n\tstruct sk_buff *skb;\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ID_MGMT_GATE,\n\t\t\t      NFC_HCI_ID_MGMT_VERSION_SW, &skb);\n\tif (r == -EOPNOTSUPP) {\n\t\tpr_info(\"Software/Hardware info not available\\n\");\n\t\treturn 0;\n\t}\n\tif (r < 0)\n\t\treturn r;\n\n\tif (skb->len != 3) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\thdev->sw_romlib = (skb->data[0] & 0xf0) >> 4;\n\thdev->sw_patch = skb->data[0] & 0x0f;\n\thdev->sw_flashlib_major = skb->data[1];\n\thdev->sw_flashlib_minor = skb->data[2];\n\n\tkfree_skb(skb);\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ID_MGMT_GATE,\n\t\t\t      NFC_HCI_ID_MGMT_VERSION_HW, &skb);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (skb->len != 3) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\thdev->hw_derivative = (skb->data[0] & 0xe0) >> 5;\n\thdev->hw_version = skb->data[0] & 0x1f;\n\thdev->hw_mpw = (skb->data[1] & 0xc0) >> 6;\n\thdev->hw_software = skb->data[1] & 0x3f;\n\thdev->hw_bsid = skb->data[2];\n\n\tkfree_skb(skb);\n\n\tpr_info(\"SOFTWARE INFO:\\n\");\n\tpr_info(\"RomLib         : %d\\n\", hdev->sw_romlib);\n\tpr_info(\"Patch          : %d\\n\", hdev->sw_patch);\n\tpr_info(\"FlashLib Major : %d\\n\", hdev->sw_flashlib_major);\n\tpr_info(\"FlashLib Minor : %d\\n\", hdev->sw_flashlib_minor);\n\tpr_info(\"HARDWARE INFO:\\n\");\n\tpr_info(\"Derivative     : %d\\n\", hdev->hw_derivative);\n\tpr_info(\"HW Version     : %d\\n\", hdev->hw_version);\n\tpr_info(\"#MPW           : %d\\n\", hdev->hw_mpw);\n\tpr_info(\"Software       : %d\\n\", hdev->hw_software);\n\tpr_info(\"BSID Version   : %d\\n\", hdev->hw_bsid);\n\n\treturn 0;\n}\n\nstatic int hci_dev_up(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\tint r = 0;\n\n\tif (hdev->ops->open) {\n\t\tr = hdev->ops->open(hdev);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = nfc_llc_start(hdev->llc);\n\tif (r < 0)\n\t\tgoto exit_close;\n\n\tr = hci_dev_session_init(hdev);\n\tif (r < 0)\n\t\tgoto exit_llc;\n\n\tr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t       NFC_HCI_EVT_END_OPERATION, NULL, 0);\n\tif (r < 0)\n\t\tgoto exit_llc;\n\n\tif (hdev->ops->hci_ready) {\n\t\tr = hdev->ops->hci_ready(hdev);\n\t\tif (r < 0)\n\t\t\tgoto exit_llc;\n\t}\n\n\tr = hci_dev_version(hdev);\n\tif (r < 0)\n\t\tgoto exit_llc;\n\n\treturn 0;\n\nexit_llc:\n\tnfc_llc_stop(hdev->llc);\n\nexit_close:\n\tif (hdev->ops->close)\n\t\thdev->ops->close(hdev);\n\n\treturn r;\n}\n\nstatic int hci_dev_down(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tnfc_llc_stop(hdev->llc);\n\n\tif (hdev->ops->close)\n\t\thdev->ops->close(hdev);\n\n\tnfc_hci_reset_pipes(hdev);\n\n\treturn 0;\n}\n\nstatic int hci_start_poll(struct nfc_dev *nfc_dev,\n\t\t\t  u32 im_protocols, u32 tm_protocols)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (hdev->ops->start_poll)\n\t\treturn hdev->ops->start_poll(hdev, im_protocols, tm_protocols);\n\telse\n\t\treturn nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t\t  NFC_HCI_EVT_READER_REQUESTED,\n\t\t\t\t\t  NULL, 0);\n}\n\nstatic void hci_stop_poll(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (hdev->ops->stop_poll)\n\t\thdev->ops->stop_poll(hdev);\n\telse\n\t\tnfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t   NFC_HCI_EVT_END_OPERATION, NULL, 0);\n}\n\nstatic int hci_dep_link_up(struct nfc_dev *nfc_dev, struct nfc_target *target,\n\t\t\t\t__u8 comm_mode, __u8 *gb, size_t gb_len)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (!hdev->ops->dep_link_up)\n\t\treturn 0;\n\n\treturn hdev->ops->dep_link_up(hdev, target, comm_mode,\n\t\t\t\t      gb, gb_len);\n}\n\nstatic int hci_dep_link_down(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (!hdev->ops->dep_link_down)\n\t\treturn 0;\n\n\treturn hdev->ops->dep_link_down(hdev);\n}\n\nstatic int hci_activate_target(struct nfc_dev *nfc_dev,\n\t\t\t       struct nfc_target *target, u32 protocol)\n{\n\treturn 0;\n}\n\nstatic void hci_deactivate_target(struct nfc_dev *nfc_dev,\n\t\t\t\t  struct nfc_target *target,\n\t\t\t\t  u8 mode)\n{\n}\n\n#define HCI_CB_TYPE_TRANSCEIVE 1\n\nstatic void hci_transceive_cb(void *context, struct sk_buff *skb, int err)\n{\n\tstruct nfc_hci_dev *hdev = context;\n\n\tswitch (hdev->async_cb_type) {\n\tcase HCI_CB_TYPE_TRANSCEIVE:\n\t\t \n\t\tif (err == 0)\n\t\t\tskb_trim(skb, skb->len - 1);  \n\n\t\thdev->async_cb(hdev->async_cb_context, skb, err);\n\t\tbreak;\n\tdefault:\n\t\tif (err == 0)\n\t\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nstatic int hci_transceive(struct nfc_dev *nfc_dev, struct nfc_target *target,\n\t\t\t  struct sk_buff *skb, data_exchange_cb_t cb,\n\t\t\t  void *cb_context)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\tint r;\n\n\tpr_debug(\"target_idx=%d\\n\", target->idx);\n\n\tswitch (target->hci_reader_gate) {\n\tcase NFC_HCI_RF_READER_A_GATE:\n\tcase NFC_HCI_RF_READER_B_GATE:\n\t\tif (hdev->ops->im_transceive) {\n\t\t\tr = hdev->ops->im_transceive(hdev, target, skb, cb,\n\t\t\t\t\t\t     cb_context);\n\t\t\tif (r <= 0)\t \n\t\t\t\tbreak;\n\t\t}\n\n\t\t*(u8 *)skb_push(skb, 1) = 0;\t \n\n\t\thdev->async_cb_type = HCI_CB_TYPE_TRANSCEIVE;\n\t\thdev->async_cb = cb;\n\t\thdev->async_cb_context = cb_context;\n\n\t\tr = nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\n\t\t\t\t\t   NFC_HCI_WR_XCHG_DATA, skb->data,\n\t\t\t\t\t   skb->len, hci_transceive_cb, hdev);\n\t\tbreak;\n\tdefault:\n\t\tif (hdev->ops->im_transceive) {\n\t\t\tr = hdev->ops->im_transceive(hdev, target, skb, cb,\n\t\t\t\t\t\t     cb_context);\n\t\t\tif (r == 1)\n\t\t\t\tr = -ENOTSUPP;\n\t\t} else {\n\t\t\tr = -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\nstatic int hci_tm_send(struct nfc_dev *nfc_dev, struct sk_buff *skb)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (!hdev->ops->tm_send) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn hdev->ops->tm_send(hdev, skb);\n}\n\nstatic int hci_check_presence(struct nfc_dev *nfc_dev,\n\t\t\t      struct nfc_target *target)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (!hdev->ops->check_presence)\n\t\treturn 0;\n\n\treturn hdev->ops->check_presence(hdev, target);\n}\n\nstatic int hci_discover_se(struct nfc_dev *nfc_dev)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (hdev->ops->discover_se)\n\t\treturn hdev->ops->discover_se(hdev);\n\n\treturn 0;\n}\n\nstatic int hci_enable_se(struct nfc_dev *nfc_dev, u32 se_idx)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (hdev->ops->enable_se)\n\t\treturn hdev->ops->enable_se(hdev, se_idx);\n\n\treturn 0;\n}\n\nstatic int hci_disable_se(struct nfc_dev *nfc_dev, u32 se_idx)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (hdev->ops->disable_se)\n\t\treturn hdev->ops->disable_se(hdev, se_idx);\n\n\treturn 0;\n}\n\nstatic int hci_se_io(struct nfc_dev *nfc_dev, u32 se_idx,\n\t\t     u8 *apdu, size_t apdu_length,\n\t\t     se_io_cb_t cb, void *cb_context)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (hdev->ops->se_io)\n\t\treturn hdev->ops->se_io(hdev, se_idx, apdu,\n\t\t\t\t\tapdu_length, cb, cb_context);\n\n\treturn 0;\n}\n\nstatic void nfc_hci_failure(struct nfc_hci_dev *hdev, int err)\n{\n\tmutex_lock(&hdev->msg_tx_mutex);\n\n\tif (hdev->cmd_pending_msg == NULL) {\n\t\tnfc_driver_failure(hdev->ndev, err);\n\t\tgoto exit;\n\t}\n\n\t__nfc_hci_cmd_completion(hdev, err, NULL);\n\nexit:\n\tmutex_unlock(&hdev->msg_tx_mutex);\n}\n\nstatic void nfc_hci_llc_failure(struct nfc_hci_dev *hdev, int err)\n{\n\tnfc_hci_failure(hdev, err);\n}\n\nstatic void nfc_hci_recv_from_llc(struct nfc_hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hcp_packet *packet;\n\tu8 type;\n\tu8 instruction;\n\tstruct sk_buff *hcp_skb;\n\tu8 pipe;\n\tstruct sk_buff *frag_skb;\n\tint msg_len;\n\n\tpacket = (struct hcp_packet *)skb->data;\n\tif ((packet->header & ~NFC_HCI_FRAGMENT) == 0) {\n\t\tskb_queue_tail(&hdev->rx_hcp_frags, skb);\n\t\treturn;\n\t}\n\n\t \n\tif (skb_queue_len(&hdev->rx_hcp_frags)) {\n\t\tpipe = packet->header & NFC_HCI_FRAGMENT;\n\t\tskb_queue_tail(&hdev->rx_hcp_frags, skb);\n\n\t\tmsg_len = 0;\n\t\tskb_queue_walk(&hdev->rx_hcp_frags, frag_skb) {\n\t\t\tmsg_len += (frag_skb->len -\n\t\t\t\t    NFC_HCI_HCP_PACKET_HEADER_LEN);\n\t\t}\n\n\t\thcp_skb = nfc_alloc_recv_skb(NFC_HCI_HCP_PACKET_HEADER_LEN +\n\t\t\t\t\t     msg_len, GFP_KERNEL);\n\t\tif (hcp_skb == NULL) {\n\t\t\tnfc_hci_failure(hdev, -ENOMEM);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_put_u8(hcp_skb, pipe);\n\n\t\tskb_queue_walk(&hdev->rx_hcp_frags, frag_skb) {\n\t\t\tmsg_len = frag_skb->len - NFC_HCI_HCP_PACKET_HEADER_LEN;\n\t\t\tskb_put_data(hcp_skb,\n\t\t\t\t     frag_skb->data + NFC_HCI_HCP_PACKET_HEADER_LEN,\n\t\t\t\t     msg_len);\n\t\t}\n\n\t\tskb_queue_purge(&hdev->rx_hcp_frags);\n\t} else {\n\t\tpacket->header &= NFC_HCI_FRAGMENT;\n\t\thcp_skb = skb;\n\t}\n\n\t \n\tpacket = (struct hcp_packet *)hcp_skb->data;\n\ttype = HCP_MSG_GET_TYPE(packet->message.header);\n\tif (type == NFC_HCI_HCP_RESPONSE) {\n\t\tpipe = packet->header;\n\t\tinstruction = HCP_MSG_GET_CMD(packet->message.header);\n\t\tskb_pull(hcp_skb, NFC_HCI_HCP_PACKET_HEADER_LEN +\n\t\t\t NFC_HCI_HCP_MESSAGE_HEADER_LEN);\n\t\tnfc_hci_hcp_message_rx(hdev, pipe, type, instruction, hcp_skb);\n\t} else {\n\t\tskb_queue_tail(&hdev->msg_rx_queue, hcp_skb);\n\t\tschedule_work(&hdev->msg_rx_work);\n\t}\n}\n\nstatic int hci_fw_download(struct nfc_dev *nfc_dev, const char *firmware_name)\n{\n\tstruct nfc_hci_dev *hdev = nfc_get_drvdata(nfc_dev);\n\n\tif (!hdev->ops->fw_download)\n\t\treturn -ENOTSUPP;\n\n\treturn hdev->ops->fw_download(hdev, firmware_name);\n}\n\nstatic const struct nfc_ops hci_nfc_ops = {\n\t.dev_up = hci_dev_up,\n\t.dev_down = hci_dev_down,\n\t.start_poll = hci_start_poll,\n\t.stop_poll = hci_stop_poll,\n\t.dep_link_up = hci_dep_link_up,\n\t.dep_link_down = hci_dep_link_down,\n\t.activate_target = hci_activate_target,\n\t.deactivate_target = hci_deactivate_target,\n\t.im_transceive = hci_transceive,\n\t.tm_send = hci_tm_send,\n\t.check_presence = hci_check_presence,\n\t.fw_download = hci_fw_download,\n\t.discover_se = hci_discover_se,\n\t.enable_se = hci_enable_se,\n\t.disable_se = hci_disable_se,\n\t.se_io = hci_se_io,\n};\n\nstruct nfc_hci_dev *nfc_hci_allocate_device(const struct nfc_hci_ops *ops,\n\t\t\t\t\t    struct nfc_hci_init_data *init_data,\n\t\t\t\t\t    unsigned long quirks,\n\t\t\t\t\t    u32 protocols,\n\t\t\t\t\t    const char *llc_name,\n\t\t\t\t\t    int tx_headroom,\n\t\t\t\t\t    int tx_tailroom,\n\t\t\t\t\t    int max_link_payload)\n{\n\tstruct nfc_hci_dev *hdev;\n\n\tif (ops->xmit == NULL)\n\t\treturn NULL;\n\n\tif (protocols == 0)\n\t\treturn NULL;\n\n\thdev = kzalloc(sizeof(struct nfc_hci_dev), GFP_KERNEL);\n\tif (hdev == NULL)\n\t\treturn NULL;\n\n\thdev->llc = nfc_llc_allocate(llc_name, hdev, ops->xmit,\n\t\t\t\t     nfc_hci_recv_from_llc, tx_headroom,\n\t\t\t\t     tx_tailroom, nfc_hci_llc_failure);\n\tif (hdev->llc == NULL) {\n\t\tkfree(hdev);\n\t\treturn NULL;\n\t}\n\n\thdev->ndev = nfc_allocate_device(&hci_nfc_ops, protocols,\n\t\t\t\t\t tx_headroom + HCI_CMDS_HEADROOM,\n\t\t\t\t\t tx_tailroom);\n\tif (!hdev->ndev) {\n\t\tnfc_llc_free(hdev->llc);\n\t\tkfree(hdev);\n\t\treturn NULL;\n\t}\n\n\thdev->ops = ops;\n\thdev->max_data_link_payload = max_link_payload;\n\thdev->init_data = *init_data;\n\n\tnfc_set_drvdata(hdev->ndev, hdev);\n\n\tnfc_hci_reset_pipes(hdev);\n\n\thdev->quirks = quirks;\n\n\treturn hdev;\n}\nEXPORT_SYMBOL(nfc_hci_allocate_device);\n\nvoid nfc_hci_free_device(struct nfc_hci_dev *hdev)\n{\n\tnfc_free_device(hdev->ndev);\n\tnfc_llc_free(hdev->llc);\n\tkfree(hdev);\n}\nEXPORT_SYMBOL(nfc_hci_free_device);\n\nint nfc_hci_register_device(struct nfc_hci_dev *hdev)\n{\n\tmutex_init(&hdev->msg_tx_mutex);\n\n\tINIT_LIST_HEAD(&hdev->msg_tx_queue);\n\n\tINIT_WORK(&hdev->msg_tx_work, nfc_hci_msg_tx_work);\n\n\ttimer_setup(&hdev->cmd_timer, nfc_hci_cmd_timeout, 0);\n\n\tskb_queue_head_init(&hdev->rx_hcp_frags);\n\n\tINIT_WORK(&hdev->msg_rx_work, nfc_hci_msg_rx_work);\n\n\tskb_queue_head_init(&hdev->msg_rx_queue);\n\n\treturn nfc_register_device(hdev->ndev);\n}\nEXPORT_SYMBOL(nfc_hci_register_device);\n\nvoid nfc_hci_unregister_device(struct nfc_hci_dev *hdev)\n{\n\tstruct hci_msg *msg, *n;\n\n\tmutex_lock(&hdev->msg_tx_mutex);\n\n\tif (hdev->cmd_pending_msg) {\n\t\tif (hdev->cmd_pending_msg->cb)\n\t\t\thdev->cmd_pending_msg->cb(\n\t\t\t\t\t     hdev->cmd_pending_msg->cb_context,\n\t\t\t\t\t     NULL, -ESHUTDOWN);\n\t\tkfree(hdev->cmd_pending_msg);\n\t\thdev->cmd_pending_msg = NULL;\n\t}\n\n\thdev->shutting_down = true;\n\n\tmutex_unlock(&hdev->msg_tx_mutex);\n\n\tdel_timer_sync(&hdev->cmd_timer);\n\tcancel_work_sync(&hdev->msg_tx_work);\n\n\tcancel_work_sync(&hdev->msg_rx_work);\n\n\tnfc_unregister_device(hdev->ndev);\n\n\tskb_queue_purge(&hdev->rx_hcp_frags);\n\tskb_queue_purge(&hdev->msg_rx_queue);\n\n\tlist_for_each_entry_safe(msg, n, &hdev->msg_tx_queue, msg_l) {\n\t\tlist_del(&msg->msg_l);\n\t\tskb_queue_purge(&msg->msg_frags);\n\t\tkfree(msg);\n\t}\n}\nEXPORT_SYMBOL(nfc_hci_unregister_device);\n\nvoid nfc_hci_set_clientdata(struct nfc_hci_dev *hdev, void *clientdata)\n{\n\thdev->clientdata = clientdata;\n}\nEXPORT_SYMBOL(nfc_hci_set_clientdata);\n\nvoid *nfc_hci_get_clientdata(struct nfc_hci_dev *hdev)\n{\n\treturn hdev->clientdata;\n}\nEXPORT_SYMBOL(nfc_hci_get_clientdata);\n\nvoid nfc_hci_driver_failure(struct nfc_hci_dev *hdev, int err)\n{\n\tnfc_hci_failure(hdev, err);\n}\nEXPORT_SYMBOL(nfc_hci_driver_failure);\n\nvoid nfc_hci_recv_frame(struct nfc_hci_dev *hdev, struct sk_buff *skb)\n{\n\tnfc_llc_rcv_from_drv(hdev->llc, skb);\n}\nEXPORT_SYMBOL(nfc_hci_recv_frame);\n\nstatic int __init nfc_hci_init(void)\n{\n\treturn nfc_llc_init();\n}\n\nstatic void __exit nfc_hci_exit(void)\n{\n\tnfc_llc_exit();\n}\n\nsubsys_initcall(nfc_hci_init);\nmodule_exit(nfc_hci_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"NFC HCI Core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}