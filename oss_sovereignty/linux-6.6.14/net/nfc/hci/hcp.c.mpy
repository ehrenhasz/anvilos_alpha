{
  "module_name": "hcp.c",
  "hash_id": "e0ebf61ad8216f5ae145426af9aee3ab3479d2a0251c061d0496cc84142e6a90",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/hci/hcp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"hci: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <net/nfc/hci.h>\n\n#include \"hci.h\"\n\n \nint nfc_hci_hcp_message_tx(struct nfc_hci_dev *hdev, u8 pipe,\n\t\t\t   u8 type, u8 instruction,\n\t\t\t   const u8 *payload, size_t payload_len,\n\t\t\t   data_exchange_cb_t cb, void *cb_context,\n\t\t\t   unsigned long completion_delay)\n{\n\tstruct nfc_dev *ndev = hdev->ndev;\n\tstruct hci_msg *cmd;\n\tconst u8 *ptr = payload;\n\tint hci_len, err;\n\tbool firstfrag = true;\n\n\tcmd = kzalloc(sizeof(struct hci_msg), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cmd->msg_l);\n\tskb_queue_head_init(&cmd->msg_frags);\n\tcmd->wait_response = (type == NFC_HCI_HCP_COMMAND) ? true : false;\n\tcmd->cb = cb;\n\tcmd->cb_context = cb_context;\n\tcmd->completion_delay = completion_delay;\n\n\thci_len = payload_len + 1;\n\twhile (hci_len > 0) {\n\t\tstruct sk_buff *skb;\n\t\tint skb_len, data_link_len;\n\t\tstruct hcp_packet *packet;\n\n\t\tif (NFC_HCI_HCP_PACKET_HEADER_LEN + hci_len <=\n\t\t    hdev->max_data_link_payload)\n\t\t\tdata_link_len = hci_len;\n\t\telse\n\t\t\tdata_link_len = hdev->max_data_link_payload -\n\t\t\t\t\tNFC_HCI_HCP_PACKET_HEADER_LEN;\n\n\t\tskb_len = ndev->tx_headroom + NFC_HCI_HCP_PACKET_HEADER_LEN +\n\t\t\t  data_link_len + ndev->tx_tailroom;\n\t\thci_len -= data_link_len;\n\n\t\tskb = alloc_skb(skb_len, GFP_KERNEL);\n\t\tif (skb == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_skb_err;\n\t\t}\n\t\tskb_reserve(skb, ndev->tx_headroom);\n\n\t\tskb_put(skb, NFC_HCI_HCP_PACKET_HEADER_LEN + data_link_len);\n\n\t\t \n\t\tpacket = (struct hcp_packet *)skb->data;\n\t\tpacket->header = pipe;\n\t\tif (firstfrag) {\n\t\t\tfirstfrag = false;\n\t\t\tpacket->message.header = HCP_HEADER(type, instruction);\n\t\t} else {\n\t\t\tpacket->message.header = *ptr++;\n\t\t}\n\t\tif (ptr) {\n\t\t\tmemcpy(packet->message.data, ptr, data_link_len - 1);\n\t\t\tptr += data_link_len - 1;\n\t\t}\n\n\t\t \n\t\tif (hci_len == 0)\n\t\t\tpacket->header |= ~NFC_HCI_FRAGMENT;\n\n\t\tskb_queue_tail(&cmd->msg_frags, skb);\n\t}\n\n\tmutex_lock(&hdev->msg_tx_mutex);\n\n\tif (hdev->shutting_down) {\n\t\terr = -ESHUTDOWN;\n\t\tmutex_unlock(&hdev->msg_tx_mutex);\n\t\tgoto out_skb_err;\n\t}\n\n\tlist_add_tail(&cmd->msg_l, &hdev->msg_tx_queue);\n\tmutex_unlock(&hdev->msg_tx_mutex);\n\n\tschedule_work(&hdev->msg_tx_work);\n\n\treturn 0;\n\nout_skb_err:\n\tskb_queue_purge(&cmd->msg_frags);\n\tkfree(cmd);\n\n\treturn err;\n}\n\n \nvoid nfc_hci_hcp_message_rx(struct nfc_hci_dev *hdev, u8 pipe, u8 type,\n\t\t\t    u8 instruction, struct sk_buff *skb)\n{\n\tswitch (type) {\n\tcase NFC_HCI_HCP_RESPONSE:\n\t\tnfc_hci_resp_received(hdev, instruction, skb);\n\t\tbreak;\n\tcase NFC_HCI_HCP_COMMAND:\n\t\tnfc_hci_cmd_received(hdev, pipe, instruction, skb);\n\t\tbreak;\n\tcase NFC_HCI_HCP_EVENT:\n\t\tnfc_hci_event_received(hdev, pipe, instruction, skb);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"UNKNOWN MSG Type %d, instruction=%d\\n\",\n\t\t       type, instruction);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}