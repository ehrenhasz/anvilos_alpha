{
  "module_name": "llc_shdlc.c",
  "hash_id": "f5e0a0418bdc993e8e0861fc978fdcace423f3f4072451d65c6d83cdd022e825",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/hci/llc_shdlc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"shdlc: %s: \" fmt, __func__\n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n\n#include \"llc.h\"\n\nenum shdlc_state {\n\tSHDLC_DISCONNECTED = 0,\n\tSHDLC_CONNECTING = 1,\n\tSHDLC_NEGOTIATING = 2,\n\tSHDLC_HALF_CONNECTED = 3,\n\tSHDLC_CONNECTED = 4\n};\n\nstruct llc_shdlc {\n\tstruct nfc_hci_dev *hdev;\n\txmit_to_drv_t xmit_to_drv;\n\trcv_to_hci_t rcv_to_hci;\n\n\tstruct mutex state_mutex;\n\tenum shdlc_state state;\n\tint hard_fault;\n\n\twait_queue_head_t *connect_wq;\n\tint connect_tries;\n\tint connect_result;\n\tstruct timer_list connect_timer; \n\n\tu8 w;\t\t\t\t \n\tbool srej_support;\n\n\tstruct timer_list t1_timer;\t \n\tbool t1_active;\n\n\tstruct timer_list t2_timer;\t \n\tbool t2_active;\n\n\tint ns;\t\t\t\t \n\tint nr;\t\t\t\t \n\tint dnr;\t\t\t \n\n\tstruct sk_buff_head rcv_q;\n\n\tstruct sk_buff_head send_q;\n\tbool rnr;\t\t\t \n\n\tstruct sk_buff_head ack_pending_q;\n\n\tstruct work_struct sm_work;\n\n\tint tx_headroom;\n\tint tx_tailroom;\n\n\tllc_failure_t llc_failure;\n};\n\n#define SHDLC_LLC_HEAD_ROOM\t2\n\n#define SHDLC_MAX_WINDOW\t4\n#define SHDLC_SREJ_SUPPORT\tfalse\n\n#define SHDLC_CONTROL_HEAD_MASK\t0xe0\n#define SHDLC_CONTROL_HEAD_I\t0x80\n#define SHDLC_CONTROL_HEAD_I2\t0xa0\n#define SHDLC_CONTROL_HEAD_S\t0xc0\n#define SHDLC_CONTROL_HEAD_U\t0xe0\n\n#define SHDLC_CONTROL_NS_MASK\t0x38\n#define SHDLC_CONTROL_NR_MASK\t0x07\n#define SHDLC_CONTROL_TYPE_MASK\t0x18\n\n#define SHDLC_CONTROL_M_MASK\t0x1f\n\nenum sframe_type {\n\tS_FRAME_RR = 0x00,\n\tS_FRAME_REJ = 0x01,\n\tS_FRAME_RNR = 0x02,\n\tS_FRAME_SREJ = 0x03\n};\n\nenum uframe_modifier {\n\tU_FRAME_UA = 0x06,\n\tU_FRAME_RSET = 0x19\n};\n\n#define SHDLC_CONNECT_VALUE_MS\t5\n#define SHDLC_T1_VALUE_MS(w)\t((5 * w) / 4)\n#define SHDLC_T2_VALUE_MS\t300\n\n#define SHDLC_DUMP_SKB(info, skb)\t\t\t\t  \\\ndo {\t\t\t\t\t\t\t\t  \\\n\tpr_debug(\"%s:\\n\", info);\t\t\t\t  \\\n\tprint_hex_dump(KERN_DEBUG, \"shdlc: \", DUMP_PREFIX_OFFSET, \\\n\t\t       16, 1, skb->data, skb->len, 0);\t\t  \\\n} while (0)\n\n \nstatic bool llc_shdlc_x_lt_y_lteq_z(int x, int y, int z)\n{\n\tif (x < z)\n\t\treturn ((x < y) && (y <= z)) ? true : false;\n\telse\n\t\treturn ((y > x) || (y <= z)) ? true : false;\n}\n\n \nstatic bool llc_shdlc_x_lteq_y_lt_z(int x, int y, int z)\n{\n\tif (x <= z)\n\t\treturn ((x <= y) && (y < z)) ? true : false;\n\telse\t\t\t \n\t\treturn ((y >= x) || (y < z)) ? true : false;\n}\n\nstatic struct sk_buff *llc_shdlc_alloc_skb(const struct llc_shdlc *shdlc,\n\t\t\t\t\t   int payload_len)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(shdlc->tx_headroom + SHDLC_LLC_HEAD_ROOM +\n\t\t\tshdlc->tx_tailroom + payload_len, GFP_KERNEL);\n\tif (skb)\n\t\tskb_reserve(skb, shdlc->tx_headroom + SHDLC_LLC_HEAD_ROOM);\n\n\treturn skb;\n}\n\n \nstatic int llc_shdlc_send_s_frame(const struct llc_shdlc *shdlc,\n\t\t\t\t  enum sframe_type sframe_type, int nr)\n{\n\tint r;\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"sframe_type=%d nr=%d\\n\", sframe_type, nr);\n\n\tskb = llc_shdlc_alloc_skb(shdlc, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t*(u8 *)skb_push(skb, 1) = SHDLC_CONTROL_HEAD_S | (sframe_type << 3) | nr;\n\n\tr = shdlc->xmit_to_drv(shdlc->hdev, skb);\n\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\n \nstatic int llc_shdlc_send_u_frame(const struct llc_shdlc *shdlc,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  enum uframe_modifier uframe_modifier)\n{\n\tint r;\n\n\tpr_debug(\"uframe_modifier=%d\\n\", uframe_modifier);\n\n\t*(u8 *)skb_push(skb, 1) = SHDLC_CONTROL_HEAD_U | uframe_modifier;\n\n\tr = shdlc->xmit_to_drv(shdlc->hdev, skb);\n\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\n \nstatic void llc_shdlc_reset_t2(struct llc_shdlc *shdlc, int y_nr)\n{\n\tstruct sk_buff *skb;\n\tint dnr = shdlc->dnr;\t \n\n\tpr_debug(\"release ack pending up to frame %d excluded\\n\", y_nr);\n\n\twhile (dnr != y_nr) {\n\t\tpr_debug(\"release ack pending frame %d\\n\", dnr);\n\n\t\tskb = skb_dequeue(&shdlc->ack_pending_q);\n\t\tkfree_skb(skb);\n\n\t\tdnr = (dnr + 1) % 8;\n\t}\n\n\tif (skb_queue_empty(&shdlc->ack_pending_q)) {\n\t\tif (shdlc->t2_active) {\n\t\t\tdel_timer_sync(&shdlc->t2_timer);\n\t\t\tshdlc->t2_active = false;\n\n\t\t\tpr_debug(\"All sent frames acked. Stopped T2(retransmit)\\n\");\n\t\t}\n\t} else {\n\t\tskb = skb_peek(&shdlc->ack_pending_q);\n\n\t\tmod_timer(&shdlc->t2_timer, *(unsigned long *)skb->cb +\n\t\t\t  msecs_to_jiffies(SHDLC_T2_VALUE_MS));\n\t\tshdlc->t2_active = true;\n\n\t\tpr_debug(\"Start T2(retransmit) for remaining unacked sent frames\\n\");\n\t}\n}\n\n \nstatic void llc_shdlc_rcv_i_frame(struct llc_shdlc *shdlc,\n\t\t\t\t  struct sk_buff *skb, int ns, int nr)\n{\n\tint x_ns = ns;\n\tint y_nr = nr;\n\n\tpr_debug(\"recvd I-frame %d, remote waiting frame %d\\n\", ns, nr);\n\n\tif (shdlc->state != SHDLC_CONNECTED)\n\t\tgoto exit;\n\n\tif (x_ns != shdlc->nr) {\n\t\tllc_shdlc_send_s_frame(shdlc, S_FRAME_REJ, shdlc->nr);\n\t\tgoto exit;\n\t}\n\n\tif (!shdlc->t1_active) {\n\t\tshdlc->t1_active = true;\n\t\tmod_timer(&shdlc->t1_timer, jiffies +\n\t\t\t  msecs_to_jiffies(SHDLC_T1_VALUE_MS(shdlc->w)));\n\t\tpr_debug(\"(re)Start T1(send ack)\\n\");\n\t}\n\n\tif (skb->len) {\n\t\tshdlc->rcv_to_hci(shdlc->hdev, skb);\n\t\tskb = NULL;\n\t}\n\n\tshdlc->nr = (shdlc->nr + 1) % 8;\n\n\tif (llc_shdlc_x_lt_y_lteq_z(shdlc->dnr, y_nr, shdlc->ns)) {\n\t\tllc_shdlc_reset_t2(shdlc, y_nr);\n\n\t\tshdlc->dnr = y_nr;\n\t}\n\nexit:\n\tkfree_skb(skb);\n}\n\nstatic void llc_shdlc_rcv_ack(struct llc_shdlc *shdlc, int y_nr)\n{\n\tpr_debug(\"remote acked up to frame %d excluded\\n\", y_nr);\n\n\tif (llc_shdlc_x_lt_y_lteq_z(shdlc->dnr, y_nr, shdlc->ns)) {\n\t\tllc_shdlc_reset_t2(shdlc, y_nr);\n\t\tshdlc->dnr = y_nr;\n\t}\n}\n\nstatic void llc_shdlc_requeue_ack_pending(struct llc_shdlc *shdlc)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"ns reset to %d\\n\", shdlc->dnr);\n\n\twhile ((skb = skb_dequeue_tail(&shdlc->ack_pending_q))) {\n\t\tskb_pull(skb, 1);\t \n\t\tskb_queue_head(&shdlc->send_q, skb);\n\t}\n\tshdlc->ns = shdlc->dnr;\n}\n\nstatic void llc_shdlc_rcv_rej(struct llc_shdlc *shdlc, int y_nr)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"remote asks retransmission from frame %d\\n\", y_nr);\n\n\tif (llc_shdlc_x_lteq_y_lt_z(shdlc->dnr, y_nr, shdlc->ns)) {\n\t\tif (shdlc->t2_active) {\n\t\t\tdel_timer_sync(&shdlc->t2_timer);\n\t\t\tshdlc->t2_active = false;\n\t\t\tpr_debug(\"Stopped T2(retransmit)\\n\");\n\t\t}\n\n\t\tif (shdlc->dnr != y_nr) {\n\t\t\twhile ((shdlc->dnr = ((shdlc->dnr + 1) % 8)) != y_nr) {\n\t\t\t\tskb = skb_dequeue(&shdlc->ack_pending_q);\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tllc_shdlc_requeue_ack_pending(shdlc);\n\t}\n}\n\n \nstatic void llc_shdlc_rcv_s_frame(struct llc_shdlc *shdlc,\n\t\t\t\t  enum sframe_type s_frame_type, int nr)\n{\n\tstruct sk_buff *skb;\n\n\tif (shdlc->state != SHDLC_CONNECTED)\n\t\treturn;\n\n\tswitch (s_frame_type) {\n\tcase S_FRAME_RR:\n\t\tllc_shdlc_rcv_ack(shdlc, nr);\n\t\tif (shdlc->rnr == true) {\t \n\t\t\tshdlc->rnr = false;\n\t\t\tif (shdlc->send_q.qlen == 0) {\n\t\t\t\tskb = llc_shdlc_alloc_skb(shdlc, 0);\n\t\t\t\tif (skb)\n\t\t\t\t\tskb_queue_tail(&shdlc->send_q, skb);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase S_FRAME_REJ:\n\t\tllc_shdlc_rcv_rej(shdlc, nr);\n\t\tbreak;\n\tcase S_FRAME_RNR:\n\t\tllc_shdlc_rcv_ack(shdlc, nr);\n\t\tshdlc->rnr = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void llc_shdlc_connect_complete(struct llc_shdlc *shdlc, int r)\n{\n\tpr_debug(\"result=%d\\n\", r);\n\n\tdel_timer_sync(&shdlc->connect_timer);\n\n\tif (r == 0) {\n\t\tshdlc->ns = 0;\n\t\tshdlc->nr = 0;\n\t\tshdlc->dnr = 0;\n\n\t\tshdlc->state = SHDLC_HALF_CONNECTED;\n\t} else {\n\t\tshdlc->state = SHDLC_DISCONNECTED;\n\t}\n\n\tshdlc->connect_result = r;\n\n\twake_up(shdlc->connect_wq);\n}\n\nstatic int llc_shdlc_connect_initiate(const struct llc_shdlc *shdlc)\n{\n\tstruct sk_buff *skb;\n\n\tskb = llc_shdlc_alloc_skb(shdlc, 2);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, SHDLC_MAX_WINDOW);\n\tskb_put_u8(skb, SHDLC_SREJ_SUPPORT ? 1 : 0);\n\n\treturn llc_shdlc_send_u_frame(shdlc, skb, U_FRAME_RSET);\n}\n\nstatic int llc_shdlc_connect_send_ua(const struct llc_shdlc *shdlc)\n{\n\tstruct sk_buff *skb;\n\n\tskb = llc_shdlc_alloc_skb(shdlc, 0);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\treturn llc_shdlc_send_u_frame(shdlc, skb, U_FRAME_UA);\n}\n\nstatic void llc_shdlc_rcv_u_frame(struct llc_shdlc *shdlc,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  enum uframe_modifier u_frame_modifier)\n{\n\tu8 w = SHDLC_MAX_WINDOW;\n\tbool srej_support = SHDLC_SREJ_SUPPORT;\n\tint r;\n\n\tpr_debug(\"u_frame_modifier=%d\\n\", u_frame_modifier);\n\n\tswitch (u_frame_modifier) {\n\tcase U_FRAME_RSET:\n\t\tswitch (shdlc->state) {\n\t\tcase SHDLC_NEGOTIATING:\n\t\tcase SHDLC_CONNECTING:\n\t\t\t \n\t\t\tif (skb->len > 0)\n\t\t\t\tw = skb->data[0];\n\n\t\t\tif (skb->len > 1)\n\t\t\t\tsrej_support = skb->data[1] & 0x01 ? true :\n\t\t\t\t\t       false;\n\n\t\t\tif ((w <= SHDLC_MAX_WINDOW) &&\n\t\t\t    (SHDLC_SREJ_SUPPORT || (srej_support == false))) {\n\t\t\t\tshdlc->w = w;\n\t\t\t\tshdlc->srej_support = srej_support;\n\t\t\t\tr = llc_shdlc_connect_send_ua(shdlc);\n\t\t\t\tllc_shdlc_connect_complete(shdlc, r);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SHDLC_HALF_CONNECTED:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SHDLC_CONNECTED:\n\t\t\t \n\t\t\tshdlc->hard_fault = -ECONNRESET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase U_FRAME_UA:\n\t\tif ((shdlc->state == SHDLC_CONNECTING &&\n\t\t     shdlc->connect_tries > 0) ||\n\t\t    (shdlc->state == SHDLC_NEGOTIATING)) {\n\t\t\tllc_shdlc_connect_complete(shdlc, 0);\n\t\t\tshdlc->state = SHDLC_CONNECTED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic void llc_shdlc_handle_rcv_queue(struct llc_shdlc *shdlc)\n{\n\tstruct sk_buff *skb;\n\tu8 control;\n\tint nr;\n\tint ns;\n\tenum sframe_type s_frame_type;\n\tenum uframe_modifier u_frame_modifier;\n\n\tif (shdlc->rcv_q.qlen)\n\t\tpr_debug(\"rcvQlen=%d\\n\", shdlc->rcv_q.qlen);\n\n\twhile ((skb = skb_dequeue(&shdlc->rcv_q)) != NULL) {\n\t\tcontrol = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t\tswitch (control & SHDLC_CONTROL_HEAD_MASK) {\n\t\tcase SHDLC_CONTROL_HEAD_I:\n\t\tcase SHDLC_CONTROL_HEAD_I2:\n\t\t\tif (shdlc->state == SHDLC_HALF_CONNECTED)\n\t\t\t\tshdlc->state = SHDLC_CONNECTED;\n\n\t\t\tns = (control & SHDLC_CONTROL_NS_MASK) >> 3;\n\t\t\tnr = control & SHDLC_CONTROL_NR_MASK;\n\t\t\tllc_shdlc_rcv_i_frame(shdlc, skb, ns, nr);\n\t\t\tbreak;\n\t\tcase SHDLC_CONTROL_HEAD_S:\n\t\t\tif (shdlc->state == SHDLC_HALF_CONNECTED)\n\t\t\t\tshdlc->state = SHDLC_CONNECTED;\n\n\t\t\ts_frame_type = (control & SHDLC_CONTROL_TYPE_MASK) >> 3;\n\t\t\tnr = control & SHDLC_CONTROL_NR_MASK;\n\t\t\tllc_shdlc_rcv_s_frame(shdlc, s_frame_type, nr);\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\tcase SHDLC_CONTROL_HEAD_U:\n\t\t\tu_frame_modifier = control & SHDLC_CONTROL_M_MASK;\n\t\t\tllc_shdlc_rcv_u_frame(shdlc, skb, u_frame_modifier);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"UNKNOWN Control=%d\\n\", control);\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int llc_shdlc_w_used(int ns, int dnr)\n{\n\tint unack_count;\n\n\tif (dnr <= ns)\n\t\tunack_count = ns - dnr;\n\telse\n\t\tunack_count = 8 - dnr + ns;\n\n\treturn unack_count;\n}\n\n \nstatic void llc_shdlc_handle_send_queue(struct llc_shdlc *shdlc)\n{\n\tstruct sk_buff *skb;\n\tint r;\n\tunsigned long time_sent;\n\n\tif (shdlc->send_q.qlen)\n\t\tpr_debug(\"sendQlen=%d ns=%d dnr=%d rnr=%s w_room=%d unackQlen=%d\\n\",\n\t\t\t shdlc->send_q.qlen, shdlc->ns, shdlc->dnr,\n\t\t\t shdlc->rnr == false ? \"false\" : \"true\",\n\t\t\t shdlc->w - llc_shdlc_w_used(shdlc->ns, shdlc->dnr),\n\t\t\t shdlc->ack_pending_q.qlen);\n\n\twhile (shdlc->send_q.qlen && shdlc->ack_pending_q.qlen < shdlc->w &&\n\t       (shdlc->rnr == false)) {\n\n\t\tif (shdlc->t1_active) {\n\t\t\tdel_timer_sync(&shdlc->t1_timer);\n\t\t\tshdlc->t1_active = false;\n\t\t\tpr_debug(\"Stopped T1(send ack)\\n\");\n\t\t}\n\n\t\tskb = skb_dequeue(&shdlc->send_q);\n\n\t\t*(u8 *)skb_push(skb, 1) = SHDLC_CONTROL_HEAD_I | (shdlc->ns << 3) |\n\t\t\t\t\tshdlc->nr;\n\n\t\tpr_debug(\"Sending I-Frame %d, waiting to rcv %d\\n\", shdlc->ns,\n\t\t\t shdlc->nr);\n\t\tSHDLC_DUMP_SKB(\"shdlc frame written\", skb);\n\n\t\tr = shdlc->xmit_to_drv(shdlc->hdev, skb);\n\t\tif (r < 0) {\n\t\t\tshdlc->hard_fault = r;\n\t\t\tbreak;\n\t\t}\n\n\t\tshdlc->ns = (shdlc->ns + 1) % 8;\n\n\t\ttime_sent = jiffies;\n\t\t*(unsigned long *)skb->cb = time_sent;\n\n\t\tskb_queue_tail(&shdlc->ack_pending_q, skb);\n\n\t\tif (shdlc->t2_active == false) {\n\t\t\tshdlc->t2_active = true;\n\t\t\tmod_timer(&shdlc->t2_timer, time_sent +\n\t\t\t\t  msecs_to_jiffies(SHDLC_T2_VALUE_MS));\n\t\t\tpr_debug(\"Started T2 (retransmit)\\n\");\n\t\t}\n\t}\n}\n\nstatic void llc_shdlc_connect_timeout(struct timer_list *t)\n{\n\tstruct llc_shdlc *shdlc = from_timer(shdlc, t, connect_timer);\n\n\tschedule_work(&shdlc->sm_work);\n}\n\nstatic void llc_shdlc_t1_timeout(struct timer_list *t)\n{\n\tstruct llc_shdlc *shdlc = from_timer(shdlc, t, t1_timer);\n\n\tpr_debug(\"SoftIRQ: need to send ack\\n\");\n\n\tschedule_work(&shdlc->sm_work);\n}\n\nstatic void llc_shdlc_t2_timeout(struct timer_list *t)\n{\n\tstruct llc_shdlc *shdlc = from_timer(shdlc, t, t2_timer);\n\n\tpr_debug(\"SoftIRQ: need to retransmit\\n\");\n\n\tschedule_work(&shdlc->sm_work);\n}\n\nstatic void llc_shdlc_sm_work(struct work_struct *work)\n{\n\tstruct llc_shdlc *shdlc = container_of(work, struct llc_shdlc, sm_work);\n\tint r;\n\n\tmutex_lock(&shdlc->state_mutex);\n\n\tswitch (shdlc->state) {\n\tcase SHDLC_DISCONNECTED:\n\t\tskb_queue_purge(&shdlc->rcv_q);\n\t\tskb_queue_purge(&shdlc->send_q);\n\t\tskb_queue_purge(&shdlc->ack_pending_q);\n\t\tbreak;\n\tcase SHDLC_CONNECTING:\n\t\tif (shdlc->hard_fault) {\n\t\t\tllc_shdlc_connect_complete(shdlc, shdlc->hard_fault);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (shdlc->connect_tries++ < 5)\n\t\t\tr = llc_shdlc_connect_initiate(shdlc);\n\t\telse\n\t\t\tr = -ETIME;\n\t\tif (r < 0) {\n\t\t\tllc_shdlc_connect_complete(shdlc, r);\n\t\t} else {\n\t\t\tmod_timer(&shdlc->connect_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(SHDLC_CONNECT_VALUE_MS));\n\n\t\t\tshdlc->state = SHDLC_NEGOTIATING;\n\t\t}\n\t\tbreak;\n\tcase SHDLC_NEGOTIATING:\n\t\tif (timer_pending(&shdlc->connect_timer) == 0) {\n\t\t\tshdlc->state = SHDLC_CONNECTING;\n\t\t\tschedule_work(&shdlc->sm_work);\n\t\t}\n\n\t\tllc_shdlc_handle_rcv_queue(shdlc);\n\n\t\tif (shdlc->hard_fault) {\n\t\t\tllc_shdlc_connect_complete(shdlc, shdlc->hard_fault);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SHDLC_HALF_CONNECTED:\n\tcase SHDLC_CONNECTED:\n\t\tllc_shdlc_handle_rcv_queue(shdlc);\n\t\tllc_shdlc_handle_send_queue(shdlc);\n\n\t\tif (shdlc->t1_active && timer_pending(&shdlc->t1_timer) == 0) {\n\t\t\tpr_debug(\"Handle T1(send ack) elapsed (T1 now inactive)\\n\");\n\n\t\t\tshdlc->t1_active = false;\n\t\t\tr = llc_shdlc_send_s_frame(shdlc, S_FRAME_RR,\n\t\t\t\t\t\t   shdlc->nr);\n\t\t\tif (r < 0)\n\t\t\t\tshdlc->hard_fault = r;\n\t\t}\n\n\t\tif (shdlc->t2_active && timer_pending(&shdlc->t2_timer) == 0) {\n\t\t\tpr_debug(\"Handle T2(retransmit) elapsed (T2 inactive)\\n\");\n\n\t\t\tshdlc->t2_active = false;\n\n\t\t\tllc_shdlc_requeue_ack_pending(shdlc);\n\t\t\tllc_shdlc_handle_send_queue(shdlc);\n\t\t}\n\n\t\tif (shdlc->hard_fault)\n\t\t\tshdlc->llc_failure(shdlc->hdev, shdlc->hard_fault);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&shdlc->state_mutex);\n}\n\n \nstatic int llc_shdlc_connect(struct llc_shdlc *shdlc)\n{\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(connect_wq);\n\n\tmutex_lock(&shdlc->state_mutex);\n\n\tshdlc->state = SHDLC_CONNECTING;\n\tshdlc->connect_wq = &connect_wq;\n\tshdlc->connect_tries = 0;\n\tshdlc->connect_result = 1;\n\n\tmutex_unlock(&shdlc->state_mutex);\n\n\tschedule_work(&shdlc->sm_work);\n\n\twait_event(connect_wq, shdlc->connect_result != 1);\n\n\treturn shdlc->connect_result;\n}\n\nstatic void llc_shdlc_disconnect(struct llc_shdlc *shdlc)\n{\n\tmutex_lock(&shdlc->state_mutex);\n\n\tshdlc->state = SHDLC_DISCONNECTED;\n\n\tmutex_unlock(&shdlc->state_mutex);\n\n\tschedule_work(&shdlc->sm_work);\n}\n\n \nstatic void llc_shdlc_recv_frame(struct llc_shdlc *shdlc, struct sk_buff *skb)\n{\n\tif (skb == NULL) {\n\t\tpr_err(\"NULL Frame -> link is dead\\n\");\n\t\tshdlc->hard_fault = -EREMOTEIO;\n\t} else {\n\t\tSHDLC_DUMP_SKB(\"incoming frame\", skb);\n\t\tskb_queue_tail(&shdlc->rcv_q, skb);\n\t}\n\n\tschedule_work(&shdlc->sm_work);\n}\n\nstatic void *llc_shdlc_init(struct nfc_hci_dev *hdev, xmit_to_drv_t xmit_to_drv,\n\t\t\t    rcv_to_hci_t rcv_to_hci, int tx_headroom,\n\t\t\t    int tx_tailroom, int *rx_headroom, int *rx_tailroom,\n\t\t\t    llc_failure_t llc_failure)\n{\n\tstruct llc_shdlc *shdlc;\n\n\t*rx_headroom = SHDLC_LLC_HEAD_ROOM;\n\t*rx_tailroom = 0;\n\n\tshdlc = kzalloc(sizeof(struct llc_shdlc), GFP_KERNEL);\n\tif (shdlc == NULL)\n\t\treturn NULL;\n\n\tmutex_init(&shdlc->state_mutex);\n\tshdlc->state = SHDLC_DISCONNECTED;\n\n\ttimer_setup(&shdlc->connect_timer, llc_shdlc_connect_timeout, 0);\n\ttimer_setup(&shdlc->t1_timer, llc_shdlc_t1_timeout, 0);\n\ttimer_setup(&shdlc->t2_timer, llc_shdlc_t2_timeout, 0);\n\n\tshdlc->w = SHDLC_MAX_WINDOW;\n\tshdlc->srej_support = SHDLC_SREJ_SUPPORT;\n\n\tskb_queue_head_init(&shdlc->rcv_q);\n\tskb_queue_head_init(&shdlc->send_q);\n\tskb_queue_head_init(&shdlc->ack_pending_q);\n\n\tINIT_WORK(&shdlc->sm_work, llc_shdlc_sm_work);\n\n\tshdlc->hdev = hdev;\n\tshdlc->xmit_to_drv = xmit_to_drv;\n\tshdlc->rcv_to_hci = rcv_to_hci;\n\tshdlc->tx_headroom = tx_headroom;\n\tshdlc->tx_tailroom = tx_tailroom;\n\tshdlc->llc_failure = llc_failure;\n\n\treturn shdlc;\n}\n\nstatic void llc_shdlc_deinit(struct nfc_llc *llc)\n{\n\tstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\n\n\tskb_queue_purge(&shdlc->rcv_q);\n\tskb_queue_purge(&shdlc->send_q);\n\tskb_queue_purge(&shdlc->ack_pending_q);\n\n\tkfree(shdlc);\n}\n\nstatic int llc_shdlc_start(struct nfc_llc *llc)\n{\n\tstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\n\n\treturn llc_shdlc_connect(shdlc);\n}\n\nstatic int llc_shdlc_stop(struct nfc_llc *llc)\n{\n\tstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\n\n\tllc_shdlc_disconnect(shdlc);\n\n\treturn 0;\n}\n\nstatic void llc_shdlc_rcv_from_drv(struct nfc_llc *llc, struct sk_buff *skb)\n{\n\tstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\n\n\tllc_shdlc_recv_frame(shdlc, skb);\n}\n\nstatic int llc_shdlc_xmit_from_hci(struct nfc_llc *llc, struct sk_buff *skb)\n{\n\tstruct llc_shdlc *shdlc = nfc_llc_get_data(llc);\n\n\tskb_queue_tail(&shdlc->send_q, skb);\n\n\tschedule_work(&shdlc->sm_work);\n\n\treturn 0;\n}\n\nstatic const struct nfc_llc_ops llc_shdlc_ops = {\n\t.init = llc_shdlc_init,\n\t.deinit = llc_shdlc_deinit,\n\t.start = llc_shdlc_start,\n\t.stop = llc_shdlc_stop,\n\t.rcv_from_drv = llc_shdlc_rcv_from_drv,\n\t.xmit_from_hci = llc_shdlc_xmit_from_hci,\n};\n\nint nfc_llc_shdlc_register(void)\n{\n\treturn nfc_llc_register(LLC_SHDLC_NAME, &llc_shdlc_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}