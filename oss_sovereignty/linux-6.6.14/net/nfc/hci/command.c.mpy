{
  "module_name": "command.c",
  "hash_id": "1a7ee8636045121544a6208568f89e827278ee2f770a0a62e9f2676d30befdb2",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/hci/command.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"hci: %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#include <net/nfc/hci.h>\n\n#include \"hci.h\"\n\n#define MAX_FWI 4949\n\nstatic int nfc_hci_execute_cmd_async(struct nfc_hci_dev *hdev, u8 pipe, u8 cmd,\n\t\t\t       const u8 *param, size_t param_len,\n\t\t\t       data_exchange_cb_t cb, void *cb_context)\n{\n\tpr_debug(\"exec cmd async through pipe=%d, cmd=%d, plen=%zd\\n\", pipe,\n\t\t cmd, param_len);\n\n\t \n\treturn nfc_hci_hcp_message_tx(hdev, pipe, NFC_HCI_HCP_COMMAND, cmd,\n\t\t\t\t      param, param_len, cb, cb_context, MAX_FWI);\n}\n\n \nstatic void nfc_hci_execute_cb(void *context, struct sk_buff *skb, int err)\n{\n\tstruct hcp_exec_waiter *hcp_ew = (struct hcp_exec_waiter *)context;\n\n\tpr_debug(\"HCI Cmd completed with result=%d\\n\", err);\n\n\thcp_ew->exec_result = err;\n\tif (hcp_ew->exec_result == 0)\n\t\thcp_ew->result_skb = skb;\n\telse\n\t\tkfree_skb(skb);\n\thcp_ew->exec_complete = true;\n\n\twake_up(hcp_ew->wq);\n}\n\nstatic int nfc_hci_execute_cmd(struct nfc_hci_dev *hdev, u8 pipe, u8 cmd,\n\t\t\t       const u8 *param, size_t param_len,\n\t\t\t       struct sk_buff **skb)\n{\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(ew_wq);\n\tstruct hcp_exec_waiter hcp_ew;\n\thcp_ew.wq = &ew_wq;\n\thcp_ew.exec_complete = false;\n\thcp_ew.result_skb = NULL;\n\n\tpr_debug(\"exec cmd sync through pipe=%d, cmd=%d, plen=%zd\\n\", pipe,\n\t\t cmd, param_len);\n\n\t \n\thcp_ew.exec_result = nfc_hci_hcp_message_tx(hdev, pipe,\n\t\t\t\t\t\t    NFC_HCI_HCP_COMMAND, cmd,\n\t\t\t\t\t\t    param, param_len,\n\t\t\t\t\t\t    nfc_hci_execute_cb, &hcp_ew,\n\t\t\t\t\t\t    MAX_FWI);\n\tif (hcp_ew.exec_result < 0)\n\t\treturn hcp_ew.exec_result;\n\n\twait_event(ew_wq, hcp_ew.exec_complete == true);\n\n\tif (hcp_ew.exec_result == 0) {\n\t\tif (skb)\n\t\t\t*skb = hcp_ew.result_skb;\n\t\telse\n\t\t\tkfree_skb(hcp_ew.result_skb);\n\t}\n\n\treturn hcp_ew.exec_result;\n}\n\nint nfc_hci_send_event(struct nfc_hci_dev *hdev, u8 gate, u8 event,\n\t\t       const u8 *param, size_t param_len)\n{\n\tu8 pipe;\n\n\tpr_debug(\"%d to gate %d\\n\", event, gate);\n\n\tpipe = hdev->gate2pipe[gate];\n\tif (pipe == NFC_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn nfc_hci_hcp_message_tx(hdev, pipe, NFC_HCI_HCP_EVENT, event,\n\t\t\t\t      param, param_len, NULL, NULL, 0);\n}\nEXPORT_SYMBOL(nfc_hci_send_event);\n\n \nint nfc_hci_send_cmd(struct nfc_hci_dev *hdev, u8 gate, u8 cmd,\n\t\t     const u8 *param, size_t param_len, struct sk_buff **skb)\n{\n\tu8 pipe;\n\n\tpipe = hdev->gate2pipe[gate];\n\tif (pipe == NFC_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn nfc_hci_execute_cmd(hdev, pipe, cmd, param, param_len, skb);\n}\nEXPORT_SYMBOL(nfc_hci_send_cmd);\n\nint nfc_hci_send_cmd_async(struct nfc_hci_dev *hdev, u8 gate, u8 cmd,\n\t\t\t   const u8 *param, size_t param_len,\n\t\t\t   data_exchange_cb_t cb, void *cb_context)\n{\n\tu8 pipe;\n\n\tpipe = hdev->gate2pipe[gate];\n\tif (pipe == NFC_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn nfc_hci_execute_cmd_async(hdev, pipe, cmd, param, param_len,\n\t\t\t\t\t cb, cb_context);\n}\nEXPORT_SYMBOL(nfc_hci_send_cmd_async);\n\nint nfc_hci_set_param(struct nfc_hci_dev *hdev, u8 gate, u8 idx,\n\t\t      const u8 *param, size_t param_len)\n{\n\tint r;\n\tu8 *tmp;\n\n\t \n\n\tpr_debug(\"idx=%d to gate %d\\n\", idx, gate);\n\n\ttmp = kmalloc(1 + param_len, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\treturn -ENOMEM;\n\n\t*tmp = idx;\n\tmemcpy(tmp + 1, param, param_len);\n\n\tr = nfc_hci_send_cmd(hdev, gate, NFC_HCI_ANY_SET_PARAMETER,\n\t\t\t     tmp, param_len + 1, NULL);\n\n\tkfree(tmp);\n\n\treturn r;\n}\nEXPORT_SYMBOL(nfc_hci_set_param);\n\nint nfc_hci_get_param(struct nfc_hci_dev *hdev, u8 gate, u8 idx,\n\t\t      struct sk_buff **skb)\n{\n\tpr_debug(\"gate=%d regidx=%d\\n\", gate, idx);\n\n\treturn nfc_hci_send_cmd(hdev, gate, NFC_HCI_ANY_GET_PARAMETER,\n\t\t\t\t&idx, 1, skb);\n}\nEXPORT_SYMBOL(nfc_hci_get_param);\n\nstatic int nfc_hci_open_pipe(struct nfc_hci_dev *hdev, u8 pipe)\n{\n\tstruct sk_buff *skb;\n\tint r;\n\n\tpr_debug(\"pipe=%d\\n\", pipe);\n\n\tr = nfc_hci_execute_cmd(hdev, pipe, NFC_HCI_ANY_OPEN_PIPE,\n\t\t\t\tNULL, 0, &skb);\n\tif (r == 0) {\n\t\t \n\t\tkfree_skb(skb);\n\t}\n\n\treturn r;\n}\n\nstatic int nfc_hci_close_pipe(struct nfc_hci_dev *hdev, u8 pipe)\n{\n\treturn nfc_hci_execute_cmd(hdev, pipe, NFC_HCI_ANY_CLOSE_PIPE,\n\t\t\t\t   NULL, 0, NULL);\n}\n\nstatic u8 nfc_hci_create_pipe(struct nfc_hci_dev *hdev, u8 dest_host,\n\t\t\t      u8 dest_gate, int *result)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_create_pipe_params params;\n\tstruct hci_create_pipe_resp *resp;\n\tu8 pipe;\n\n\tpr_debug(\"gate=%d\\n\", dest_gate);\n\n\tparams.src_gate = NFC_HCI_ADMIN_GATE;\n\tparams.dest_host = dest_host;\n\tparams.dest_gate = dest_gate;\n\n\t*result = nfc_hci_execute_cmd(hdev, NFC_HCI_ADMIN_PIPE,\n\t\t\t\t      NFC_HCI_ADM_CREATE_PIPE,\n\t\t\t\t      (u8 *) &params, sizeof(params), &skb);\n\tif (*result < 0)\n\t\treturn NFC_HCI_INVALID_PIPE;\n\n\tresp = (struct hci_create_pipe_resp *)skb->data;\n\tpipe = resp->pipe;\n\tkfree_skb(skb);\n\n\tpr_debug(\"pipe created=%d\\n\", pipe);\n\n\treturn pipe;\n}\n\nstatic int nfc_hci_delete_pipe(struct nfc_hci_dev *hdev, u8 pipe)\n{\n\treturn nfc_hci_execute_cmd(hdev, NFC_HCI_ADMIN_PIPE,\n\t\t\t\t   NFC_HCI_ADM_DELETE_PIPE, &pipe, 1, NULL);\n}\n\nstatic int nfc_hci_clear_all_pipes(struct nfc_hci_dev *hdev)\n{\n\tu8 param[2];\n\tsize_t param_len = 2;\n\n\t \n\n\tif (test_bit(NFC_HCI_QUIRK_SHORT_CLEAR, &hdev->quirks))\n\t\tparam_len = 0;\n\n\treturn nfc_hci_execute_cmd(hdev, NFC_HCI_ADMIN_PIPE,\n\t\t\t\t   NFC_HCI_ADM_CLEAR_ALL_PIPE, param, param_len,\n\t\t\t\t   NULL);\n}\n\nint nfc_hci_disconnect_gate(struct nfc_hci_dev *hdev, u8 gate)\n{\n\tint r;\n\tu8 pipe = hdev->gate2pipe[gate];\n\n\tif (pipe == NFC_HCI_INVALID_PIPE)\n\t\treturn -EADDRNOTAVAIL;\n\n\tr = nfc_hci_close_pipe(hdev, pipe);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (pipe != NFC_HCI_LINK_MGMT_PIPE && pipe != NFC_HCI_ADMIN_PIPE) {\n\t\tr = nfc_hci_delete_pipe(hdev, pipe);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\thdev->gate2pipe[gate] = NFC_HCI_INVALID_PIPE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_hci_disconnect_gate);\n\nint nfc_hci_disconnect_all_gates(struct nfc_hci_dev *hdev)\n{\n\tint r;\n\n\tr = nfc_hci_clear_all_pipes(hdev);\n\tif (r < 0)\n\t\treturn r;\n\n\tnfc_hci_reset_pipes(hdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_hci_disconnect_all_gates);\n\nint nfc_hci_connect_gate(struct nfc_hci_dev *hdev, u8 dest_host, u8 dest_gate,\n\t\t\t u8 pipe)\n{\n\tbool pipe_created = false;\n\tint r;\n\n\tif (pipe == NFC_HCI_DO_NOT_CREATE_PIPE)\n\t\treturn 0;\n\n\tif (hdev->gate2pipe[dest_gate] != NFC_HCI_INVALID_PIPE)\n\t\treturn -EADDRINUSE;\n\n\tif (pipe != NFC_HCI_INVALID_PIPE)\n\t\tgoto open_pipe;\n\n\tswitch (dest_gate) {\n\tcase NFC_HCI_LINK_MGMT_GATE:\n\t\tpipe = NFC_HCI_LINK_MGMT_PIPE;\n\t\tbreak;\n\tcase NFC_HCI_ADMIN_GATE:\n\t\tpipe = NFC_HCI_ADMIN_PIPE;\n\t\tbreak;\n\tdefault:\n\t\tpipe = nfc_hci_create_pipe(hdev, dest_host, dest_gate, &r);\n\t\tif (pipe == NFC_HCI_INVALID_PIPE)\n\t\t\treturn r;\n\t\tpipe_created = true;\n\t\tbreak;\n\t}\n\nopen_pipe:\n\tr = nfc_hci_open_pipe(hdev, pipe);\n\tif (r < 0) {\n\t\tif (pipe_created)\n\t\t\tif (nfc_hci_delete_pipe(hdev, pipe) < 0) {\n\t\t\t\t \n\t\t\t}\n\t\treturn r;\n\t}\n\n\thdev->pipes[pipe].gate = dest_gate;\n\thdev->pipes[pipe].dest_host = dest_host;\n\thdev->gate2pipe[dest_gate] = pipe;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nfc_hci_connect_gate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}