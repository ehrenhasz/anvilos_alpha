{
  "module_name": "rawsock.c",
  "hash_id": "5ceb99b931be5649942de5d86bef0db1524afe08319a8acc79ad1f3126861398",
  "original_prompt": "Ingested from linux-6.6.14/net/nfc/rawsock.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/tcp_states.h>\n#include <linux/nfc.h>\n#include <linux/export.h>\n#include <linux/kcov.h>\n\n#include \"nfc.h\"\n\nstatic struct nfc_sock_list raw_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_sk_list.lock)\n};\n\nstatic void nfc_sock_link(struct nfc_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_add_node(sk, &l->head);\n\twrite_unlock(&l->lock);\n}\n\nstatic void nfc_sock_unlink(struct nfc_sock_list *l, struct sock *sk)\n{\n\twrite_lock(&l->lock);\n\tsk_del_node_init(sk);\n\twrite_unlock(&l->lock);\n}\n\nstatic void rawsock_write_queue_purge(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n}\n\nstatic void rawsock_report_error(struct sock *sk, int err)\n{\n\tpr_debug(\"sk=%p err=%d\\n\", sk, err);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_err = -err;\n\tsk_error_report(sk);\n\n\trawsock_write_queue_purge(sk);\n}\n\nstatic int rawsock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tpr_debug(\"sock=%p sk=%p\\n\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_unlink(&raw_sk_list, sk);\n\n\tsock_orphan(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int rawsock_connect(struct socket *sock, struct sockaddr *_addr,\n\t\t\t   int len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_nfc *addr = (struct sockaddr_nfc *)_addr;\n\tstruct nfc_dev *dev;\n\tint rc = 0;\n\n\tpr_debug(\"sock=%p sk=%p flags=%d\\n\", sock, sk, flags);\n\n\tif (!addr || len < sizeof(struct sockaddr_nfc) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"addr dev_idx=%u target_idx=%u protocol=%u\\n\",\n\t\t addr->dev_idx, addr->target_idx, addr->nfc_protocol);\n\n\tlock_sock(sk);\n\n\tif (sock->state == SS_CONNECTED) {\n\t\trc = -EISCONN;\n\t\tgoto error;\n\t}\n\n\tdev = nfc_get_device(addr->dev_idx);\n\tif (!dev) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (addr->target_idx > dev->target_next_idx - 1 ||\n\t    addr->target_idx < dev->target_next_idx - dev->n_targets) {\n\t\trc = -EINVAL;\n\t\tgoto put_dev;\n\t}\n\n\trc = nfc_activate_target(dev, addr->target_idx, addr->nfc_protocol);\n\tif (rc)\n\t\tgoto put_dev;\n\n\tnfc_rawsock(sk)->dev = dev;\n\tnfc_rawsock(sk)->target_idx = addr->target_idx;\n\tsock->state = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n\n\trelease_sock(sk);\n\treturn 0;\n\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int rawsock_add_header(struct sk_buff *skb)\n{\n\t*(u8 *)skb_push(skb, NFC_HEADER_SIZE) = 0;\n\n\treturn 0;\n}\n\nstatic void rawsock_data_exchange_complete(void *context, struct sk_buff *skb,\n\t\t\t\t\t   int err)\n{\n\tstruct sock *sk = (struct sock *) context;\n\n\tBUG_ON(in_hardirq());\n\n\tpr_debug(\"sk=%p err=%d\\n\", sk, err);\n\n\tif (err)\n\t\tgoto error;\n\n\terr = rawsock_add_header(skb);\n\tif (err)\n\t\tgoto error_skb;\n\n\terr = sock_queue_rcv_skb(sk, skb);\n\tif (err)\n\t\tgoto error_skb;\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\tif (!skb_queue_empty(&sk->sk_write_queue))\n\t\tschedule_work(&nfc_rawsock(sk)->tx_work);\n\telse\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\n\tsock_put(sk);\n\treturn;\n\nerror_skb:\n\tkfree_skb(skb);\n\nerror:\n\trawsock_report_error(sk, err);\n\tsock_put(sk);\n}\n\nstatic void rawsock_tx_work(struct work_struct *work)\n{\n\tstruct sock *sk = to_rawsock_sk(work);\n\tstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\n\tu32 target_idx = nfc_rawsock(sk)->target_idx;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tpr_debug(\"sk=%p target_idx=%u\\n\", sk, target_idx);\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\trawsock_write_queue_purge(sk);\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&sk->sk_write_queue);\n\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\tsock_hold(sk);\n\trc = nfc_data_exchange(dev, target_idx, skb,\n\t\t\t       rawsock_data_exchange_complete, sk);\n\tif (rc) {\n\t\trawsock_report_error(sk, rc);\n\t\tsock_put(sk);\n\t}\n\tkcov_remote_stop();\n}\n\nstatic int rawsock_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_dev *dev = nfc_rawsock(sk)->dev;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu\\n\", sock, sk, len);\n\n\tif (msg->msg_namelen)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sock->state != SS_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tskb = nfc_alloc_send_skb(dev, sk, msg->msg_flags, len, &rc);\n\tif (skb == NULL)\n\t\treturn rc;\n\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\tif (!nfc_rawsock(sk)->tx_work_scheduled) {\n\t\tschedule_work(&nfc_rawsock(sk)->tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = true;\n\t}\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\n\treturn len;\n}\n\nstatic int rawsock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t   int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\n\tskb = skb_recv_datagram(sk, flags, &rc);\n\tif (!skb)\n\t\treturn rc;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn rc ? : copied;\n}\n\nstatic const struct proto_ops rawsock_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.release        = rawsock_release,\n\t.bind           = sock_no_bind,\n\t.connect        = rawsock_connect,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = sock_no_getname,\n\t.poll           = datagram_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = rawsock_sendmsg,\n\t.recvmsg        = rawsock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic const struct proto_ops rawsock_raw_ops = {\n\t.family         = PF_NFC,\n\t.owner          = THIS_MODULE,\n\t.release        = rawsock_release,\n\t.bind           = sock_no_bind,\n\t.connect        = sock_no_connect,\n\t.socketpair     = sock_no_socketpair,\n\t.accept         = sock_no_accept,\n\t.getname        = sock_no_getname,\n\t.poll           = datagram_poll,\n\t.ioctl          = sock_no_ioctl,\n\t.listen         = sock_no_listen,\n\t.shutdown       = sock_no_shutdown,\n\t.sendmsg        = sock_no_sendmsg,\n\t.recvmsg        = rawsock_recvmsg,\n\t.mmap           = sock_no_mmap,\n};\n\nstatic void rawsock_destruct(struct sock *sk)\n{\n\tpr_debug(\"sk=%p\\n\", sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\tnfc_deactivate_target(nfc_rawsock(sk)->dev,\n\t\t\t\t      nfc_rawsock(sk)->target_idx,\n\t\t\t\t      NFC_TARGET_MODE_IDLE);\n\t\tnfc_put_device(nfc_rawsock(sk)->dev);\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC raw socket %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\nstatic int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}\n\nvoid nfc_send_to_raw_sock(struct nfc_dev *dev, struct sk_buff *skb,\n\t\t\t  u8 payload_type, u8 direction)\n{\n\tstruct sk_buff *skb_copy = NULL, *nskb;\n\tstruct sock *sk;\n\tu8 *data;\n\n\tread_lock(&raw_sk_list.lock);\n\n\tsk_for_each(sk, &raw_sk_list.head) {\n\t\tif (!skb_copy) {\n\t\t\tskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\n\t\t\t\t\t\t      GFP_ATOMIC, true);\n\t\t\tif (!skb_copy)\n\t\t\t\tcontinue;\n\n\t\t\tdata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\n\n\t\t\tdata[0] = dev ? dev->idx : 0xFF;\n\t\t\tdata[1] = direction & 0x01;\n\t\t\tdata[1] |= (payload_type << 1);\n\t\t}\n\n\t\tnskb = skb_clone(skb_copy, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\n\t\tif (sock_queue_rcv_skb(sk, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tread_unlock(&raw_sk_list.lock);\n\n\tkfree_skb(skb_copy);\n}\nEXPORT_SYMBOL(nfc_send_to_raw_sock);\n\nstatic struct proto rawsock_proto = {\n\t.name     = \"NFC_RAW\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct nfc_rawsock),\n};\n\nstatic const struct nfc_protocol rawsock_nfc_proto = {\n\t.id\t  = NFC_SOCKPROTO_RAW,\n\t.proto    = &rawsock_proto,\n\t.owner    = THIS_MODULE,\n\t.create   = rawsock_create\n};\n\nint __init rawsock_init(void)\n{\n\tint rc;\n\n\trc = nfc_proto_register(&rawsock_nfc_proto);\n\n\treturn rc;\n}\n\nvoid rawsock_exit(void)\n{\n\tnfc_proto_unregister(&rawsock_nfc_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}