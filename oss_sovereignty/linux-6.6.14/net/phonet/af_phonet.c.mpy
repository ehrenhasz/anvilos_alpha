{
  "module_name": "af_phonet.c",
  "hash_id": "1374d9bd1b64dbbba9ba1fd1591a068443077fd0a4791d8f7e2d67bd5c623489",
  "original_prompt": "Ingested from linux-6.6.14/net/phonet/af_phonet.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\n#include <linux/if_phonet.h>\n#include <linux/phonet.h>\n#include <net/phonet/phonet.h>\n#include <net/phonet/pn_dev.h>\n\n \nstatic const struct phonet_protocol *proto_tab[PHONET_NPROTO] __read_mostly;\n\nstatic const struct phonet_protocol *phonet_proto_get(unsigned int protocol)\n{\n\tconst struct phonet_protocol *pp;\n\n\tif (protocol >= PHONET_NPROTO)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tpp = rcu_dereference(proto_tab[protocol]);\n\tif (pp && !try_module_get(pp->prot->owner))\n\t\tpp = NULL;\n\trcu_read_unlock();\n\n\treturn pp;\n}\n\nstatic inline void phonet_proto_put(const struct phonet_protocol *pp)\n{\n\tmodule_put(pp->prot->owner);\n}\n\n \n\nstatic int pn_socket_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t    int kern)\n{\n\tstruct sock *sk;\n\tstruct pn_sock *pn;\n\tconst struct phonet_protocol *pnp;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (protocol == 0) {\n\t\t \n\t\tswitch (sock->type) {\n\t\tcase SOCK_DGRAM:\n\t\t\tprotocol = PN_PROTO_PHONET;\n\t\t\tbreak;\n\t\tcase SOCK_SEQPACKET:\n\t\t\tprotocol = PN_PROTO_PIPE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPROTONOSUPPORT;\n\t\t}\n\t}\n\n\tpnp = phonet_proto_get(protocol);\n\tif (pnp == NULL &&\n\t    request_module(\"net-pf-%d-proto-%d\", PF_PHONET, protocol) == 0)\n\t\tpnp = phonet_proto_get(protocol);\n\n\tif (pnp == NULL)\n\t\treturn -EPROTONOSUPPORT;\n\tif (sock->type != pnp->sock_type) {\n\t\terr = -EPROTONOSUPPORT;\n\t\tgoto out;\n\t}\n\n\tsk = sk_alloc(net, PF_PHONET, GFP_KERNEL, pnp->prot, kern);\n\tif (sk == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsock_init_data(sock, sk);\n\tsock->state = SS_UNCONNECTED;\n\tsock->ops = pnp->ops;\n\tsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\tsk->sk_protocol = protocol;\n\tpn = pn_sk(sk);\n\tpn->sobject = 0;\n\tpn->dobject = 0;\n\tpn->resource = 0;\n\tsk->sk_prot->init(sk);\n\terr = 0;\n\nout:\n\tphonet_proto_put(pnp);\n\treturn err;\n}\n\nstatic const struct net_proto_family phonet_proto_family = {\n\t.family = PF_PHONET,\n\t.create = pn_socket_create,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int pn_header_create(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\tunsigned short type, const void *daddr,\n\t\t\t\tconst void *saddr, unsigned int len)\n{\n\tu8 *media = skb_push(skb, 1);\n\n\tif (type != ETH_P_PHONET)\n\t\treturn -1;\n\n\tif (!saddr)\n\t\tsaddr = dev->dev_addr;\n\t*media = *(const u8 *)saddr;\n\treturn 1;\n}\n\nstatic int pn_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tconst u8 *media = skb_mac_header(skb);\n\t*haddr = *media;\n\treturn 1;\n}\n\nconst struct header_ops phonet_header_ops = {\n\t.create = pn_header_create,\n\t.parse = pn_header_parse,\n};\nEXPORT_SYMBOL(phonet_header_ops);\n\n \nstatic int pn_send(struct sk_buff *skb, struct net_device *dev,\n\t\t\tu16 dst, u16 src, u8 res)\n{\n\tstruct phonethdr *ph;\n\tint err;\n\n\tif (skb->len + 2 > 0xffff   ||\n\t    skb->len + sizeof(struct phonethdr) > dev->mtu) {\n\t\terr = -EMSGSIZE;\n\t\tgoto drop;\n\t}\n\n\t \n\tif (pn_addr(dst) == PNADDR_BROADCAST) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto drop;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tWARN_ON(skb_headroom(skb) & 1);  \n\tskb_push(skb, sizeof(struct phonethdr));\n\tskb_reset_network_header(skb);\n\tph = pn_hdr(skb);\n\tph->pn_rdev = pn_dev(dst);\n\tph->pn_sdev = pn_dev(src);\n\tph->pn_res = res;\n\tph->pn_length = __cpu_to_be16(skb->len + 2 - sizeof(*ph));\n\tph->pn_robj = pn_obj(dst);\n\tph->pn_sobj = pn_obj(src);\n\n\tskb->protocol = htons(ETH_P_PHONET);\n\tskb->priority = 0;\n\tskb->dev = dev;\n\n\tif (skb->pkt_type == PACKET_LOOPBACK) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb_orphan(skb);\n\t\terr = netif_rx(skb) ? -ENOBUFS : 0;\n\t} else {\n\t\terr = dev_hard_header(skb, dev, ntohs(skb->protocol),\n\t\t\t\t\tNULL, NULL, skb->len);\n\t\tif (err < 0) {\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto drop;\n\t\t}\n\t\terr = dev_queue_xmit(skb);\n\t\tif (unlikely(err > 0))\n\t\t\terr = net_xmit_errno(err);\n\t}\n\n\treturn err;\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int pn_raw_send(const void *data, int len, struct net_device *dev,\n\t\t\tu16 dst, u16 src, u8 res)\n{\n\tstruct sk_buff *skb = alloc_skb(MAX_PHONET_HEADER + len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (phonet_address_lookup(dev_net(dev), pn_addr(dst)) == 0)\n\t\tskb->pkt_type = PACKET_LOOPBACK;\n\n\tskb_reserve(skb, MAX_PHONET_HEADER);\n\t__skb_put(skb, len);\n\tskb_copy_to_linear_data(skb, data, len);\n\treturn pn_send(skb, dev, dst, src, res);\n}\n\n \nint pn_skb_send(struct sock *sk, struct sk_buff *skb,\n\t\tconst struct sockaddr_pn *target)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct net_device *dev;\n\tstruct pn_sock *pn = pn_sk(sk);\n\tint err;\n\tu16 src, dst;\n\tu8 daddr, saddr, res;\n\n\tsrc = pn->sobject;\n\tif (target != NULL) {\n\t\tdst = pn_sockaddr_get_object(target);\n\t\tres = pn_sockaddr_get_resource(target);\n\t} else {\n\t\tdst = pn->dobject;\n\t\tres = pn->resource;\n\t}\n\tdaddr = pn_addr(dst);\n\n\terr = -EHOSTUNREACH;\n\tif (sk->sk_bound_dev_if)\n\t\tdev = dev_get_by_index(net, sk->sk_bound_dev_if);\n\telse if (phonet_address_lookup(net, daddr) == 0) {\n\t\tdev = phonet_device_get(net);\n\t\tskb->pkt_type = PACKET_LOOPBACK;\n\t} else if (dst == 0) {\n\t\t \n\t\tstruct sock *sk = pn_find_sock_by_res(net, res);\n\t\tif (sk)\t{\n\t\t\tsock_put(sk);\n\t\t\tdev = phonet_device_get(net);\n\t\t\tskb->pkt_type = PACKET_LOOPBACK;\n\t\t} else\n\t\t\tdev = phonet_route_output(net, daddr);\n\t} else\n\t\tdev = phonet_route_output(net, daddr);\n\n\tif (!dev || !(dev->flags & IFF_UP))\n\t\tgoto drop;\n\n\tsaddr = phonet_address_get(dev, daddr);\n\tif (saddr == PN_NO_ADDR)\n\t\tgoto drop;\n\n\tif (!pn_addr(src))\n\t\tsrc = pn_object(saddr, pn_obj(src));\n\n\terr = pn_send(skb, dev, dst, src, res);\n\tdev_put(dev);\n\treturn err;\n\ndrop:\n\tkfree_skb(skb);\n\tdev_put(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(pn_skb_send);\n\n \nstatic inline int can_respond(struct sk_buff *skb)\n{\n\tconst struct phonethdr *ph;\n\tconst struct phonetmsg *pm;\n\tu8 submsg_id;\n\n\tif (!pskb_may_pull(skb, 3))\n\t\treturn 0;\n\n\tph = pn_hdr(skb);\n\tif (ph->pn_res == PN_PREFIX && !pskb_may_pull(skb, 5))\n\t\treturn 0;\n\tif (ph->pn_res == PN_COMMGR)  \n\t\treturn 0;\n\n\tph = pn_hdr(skb);  \n\tpm = pn_msg(skb);\n\tif (pm->pn_msg_id != PN_COMMON_MESSAGE)\n\t\treturn 1;\n\tsubmsg_id = (ph->pn_res == PN_PREFIX)\n\t\t? pm->pn_e_submsg_id : pm->pn_submsg_id;\n\tif (submsg_id != PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP &&\n\t\tpm->pn_e_submsg_id != PN_COMM_SERVICE_NOT_IDENTIFIED_RESP)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int send_obj_unreachable(struct sk_buff *rskb)\n{\n\tconst struct phonethdr *oph = pn_hdr(rskb);\n\tconst struct phonetmsg *opm = pn_msg(rskb);\n\tstruct phonetmsg resp;\n\n\tmemset(&resp, 0, sizeof(resp));\n\tresp.pn_trans_id = opm->pn_trans_id;\n\tresp.pn_msg_id = PN_COMMON_MESSAGE;\n\tif (oph->pn_res == PN_PREFIX) {\n\t\tresp.pn_e_res_id = opm->pn_e_res_id;\n\t\tresp.pn_e_submsg_id = PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP;\n\t\tresp.pn_e_orig_msg_id = opm->pn_msg_id;\n\t\tresp.pn_e_status = 0;\n\t} else {\n\t\tresp.pn_submsg_id = PN_COMM_ISA_ENTITY_NOT_REACHABLE_RESP;\n\t\tresp.pn_orig_msg_id = opm->pn_msg_id;\n\t\tresp.pn_status = 0;\n\t}\n\treturn pn_raw_send(&resp, sizeof(resp), rskb->dev,\n\t\t\t\tpn_object(oph->pn_sdev, oph->pn_sobj),\n\t\t\t\tpn_object(oph->pn_rdev, oph->pn_robj),\n\t\t\t\toph->pn_res);\n}\n\nstatic int send_reset_indications(struct sk_buff *rskb)\n{\n\tstruct phonethdr *oph = pn_hdr(rskb);\n\tstatic const u8 data[4] = {\n\t\t0x00  , 0x10  ,\n\t\t0x00  , 0x00  \n\t};\n\n\treturn pn_raw_send(data, sizeof(data), rskb->dev,\n\t\t\t\tpn_object(oph->pn_sdev, 0x00),\n\t\t\t\tpn_object(oph->pn_rdev, oph->pn_robj),\n\t\t\t\tPN_COMMGR);\n}\n\n\n \n\n \nstatic int phonet_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pkttype,\n\t\t\tstruct net_device *orig_dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct phonethdr *ph;\n\tstruct sockaddr_pn sa;\n\tu16 len;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\t \n\tif (!pskb_pull(skb, sizeof(struct phonethdr)))\n\t\tgoto out;\n\n\t \n\tph = pn_hdr(skb);\n\tlen = get_unaligned_be16(&ph->pn_length);\n\tif (len < 2)\n\t\tgoto out;\n\tlen -= 2;\n\tif ((len > skb->len) || pskb_trim(skb, len))\n\t\tgoto out;\n\tskb_reset_transport_header(skb);\n\n\tpn_skb_get_dst_sockaddr(skb, &sa);\n\n\t \n\tif (pn_sockaddr_get_addr(&sa) == PNADDR_BROADCAST) {\n\t\tpn_deliver_sock_broadcast(net, skb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (pn_sockaddr_get_object(&sa) == 0) {\n\t\tstruct sock *sk = pn_find_sock_by_res(net, sa.spn_resource);\n\t\tif (sk)\n\t\t\treturn sk_receive_skb(sk, skb, 0);\n\t}\n\n\t \n\tif (phonet_address_lookup(net, pn_sockaddr_get_addr(&sa)) == 0) {\n\t\t \n\t\tstruct sock *sk = pn_find_sock_by_sa(net, &sa);\n\n\t\tif (sk)\n\t\t\treturn sk_receive_skb(sk, skb, 0);\n\n\t\tif (can_respond(skb)) {\n\t\t\tsend_obj_unreachable(skb);\n\t\t\tsend_reset_indications(skb);\n\t\t}\n\t} else if (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\tgoto out;  \n\telse {\n\t\t \n\t\tstruct net_device *out_dev;\n\n\t\tout_dev = phonet_route_output(net, pn_sockaddr_get_addr(&sa));\n\t\tif (!out_dev) {\n\t\t\tnet_dbg_ratelimited(\"No Phonet route to %02X\\n\",\n\t\t\t\t\t    pn_sockaddr_get_addr(&sa));\n\t\t\tgoto out;\n\t\t}\n\n\t\t__skb_push(skb, sizeof(struct phonethdr));\n\t\tskb->dev = out_dev;\n\t\tif (out_dev == dev) {\n\t\t\tnet_dbg_ratelimited(\"Phonet loop to %02X on %s\\n\",\n\t\t\t\t\t    pn_sockaddr_get_addr(&sa),\n\t\t\t\t\t    dev->name);\n\t\t\tgoto out_dev;\n\t\t}\n\t\t \n\t\tif (skb_cow_head(skb, out_dev->hard_header_len))\n\t\t\tgoto out_dev;\n\n\t\tif (dev_hard_header(skb, out_dev, ETH_P_PHONET, NULL, NULL,\n\t\t\t\t\tskb->len) < 0)\n\t\t\tgoto out_dev;\n\t\tdev_queue_xmit(skb);\n\t\tdev_put(out_dev);\n\t\treturn NET_RX_SUCCESS;\nout_dev:\n\t\tdev_put(out_dev);\n\t}\n\nout:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic struct packet_type phonet_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_PHONET),\n\t.func = phonet_rcv,\n};\n\nstatic DEFINE_MUTEX(proto_tab_lock);\n\nint __init_or_module phonet_proto_register(unsigned int protocol,\n\t\t\t\tconst struct phonet_protocol *pp)\n{\n\tint err = 0;\n\n\tif (protocol >= PHONET_NPROTO)\n\t\treturn -EINVAL;\n\n\terr = proto_register(pp->prot, 1);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&proto_tab_lock);\n\tif (proto_tab[protocol])\n\t\terr = -EBUSY;\n\telse\n\t\trcu_assign_pointer(proto_tab[protocol], pp);\n\tmutex_unlock(&proto_tab_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(phonet_proto_register);\n\nvoid phonet_proto_unregister(unsigned int protocol,\n\t\t\tconst struct phonet_protocol *pp)\n{\n\tmutex_lock(&proto_tab_lock);\n\tBUG_ON(proto_tab[protocol] != pp);\n\tRCU_INIT_POINTER(proto_tab[protocol], NULL);\n\tmutex_unlock(&proto_tab_lock);\n\tsynchronize_rcu();\n\tproto_unregister(pp->prot);\n}\nEXPORT_SYMBOL(phonet_proto_unregister);\n\n \nstatic int __init phonet_init(void)\n{\n\tint err;\n\n\terr = phonet_device_init();\n\tif (err)\n\t\treturn err;\n\n\tpn_sock_init();\n\terr = sock_register(&phonet_proto_family);\n\tif (err) {\n\t\tprintk(KERN_ALERT\n\t\t\t\"phonet protocol family initialization failed\\n\");\n\t\tgoto err_sock;\n\t}\n\n\tdev_add_pack(&phonet_packet_type);\n\tphonet_sysctl_init();\n\n\terr = isi_register();\n\tif (err)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tphonet_sysctl_exit();\n\tsock_unregister(PF_PHONET);\n\tdev_remove_pack(&phonet_packet_type);\nerr_sock:\n\tphonet_device_exit();\n\treturn err;\n}\n\nstatic void __exit phonet_exit(void)\n{\n\tisi_unregister();\n\tphonet_sysctl_exit();\n\tsock_unregister(PF_PHONET);\n\tdev_remove_pack(&phonet_packet_type);\n\tphonet_device_exit();\n}\n\nmodule_init(phonet_init);\nmodule_exit(phonet_exit);\nMODULE_DESCRIPTION(\"Phonet protocol stack for Linux\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_PHONET);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}