{
  "module_name": "pep-gprs.c",
  "hash_id": "4c245240a9af7bf30664adfae4c04d4ad6e0dca682c42ccbac2d7125b042fec7",
  "original_prompt": "Ingested from linux-6.6.14/net/phonet/pep-gprs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <net/sock.h>\n\n#include <linux/if_phonet.h>\n#include <net/tcp_states.h>\n#include <net/phonet/gprs.h>\n\n#include <trace/events/sock.h>\n\n#define GPRS_DEFAULT_MTU 1400\n\nstruct gprs_dev {\n\tstruct sock\t\t*sk;\n\tvoid\t\t\t(*old_state_change)(struct sock *);\n\tvoid\t\t\t(*old_data_ready)(struct sock *);\n\tvoid\t\t\t(*old_write_space)(struct sock *);\n\n\tstruct net_device\t*dev;\n};\n\nstatic __be16 gprs_type_trans(struct sk_buff *skb)\n{\n\tconst u8 *pvfc;\n\tu8 buf;\n\n\tpvfc = skb_header_pointer(skb, 0, 1, &buf);\n\tif (!pvfc)\n\t\treturn htons(0);\n\t \n\tswitch (*pvfc >> 4) {\n\tcase 4:\n\t\treturn htons(ETH_P_IP);\n\tcase 6:\n\t\treturn htons(ETH_P_IPV6);\n\t}\n\treturn htons(0);\n}\n\nstatic void gprs_writeable(struct gprs_dev *gp)\n{\n\tstruct net_device *dev = gp->dev;\n\n\tif (pep_writeable(gp->sk))\n\t\tnetif_wake_queue(dev);\n}\n\n \n\nstatic void gprs_state_change(struct sock *sk)\n{\n\tstruct gprs_dev *gp = sk->sk_user_data;\n\n\tif (sk->sk_state == TCP_CLOSE_WAIT) {\n\t\tstruct net_device *dev = gp->dev;\n\n\t\tnetif_stop_queue(dev);\n\t\tnetif_carrier_off(dev);\n\t}\n}\n\nstatic int gprs_recv(struct gprs_dev *gp, struct sk_buff *skb)\n{\n\tstruct net_device *dev = gp->dev;\n\tint err = 0;\n\t__be16 protocol = gprs_type_trans(skb);\n\n\tif (!protocol) {\n\t\terr = -EINVAL;\n\t\tgoto drop;\n\t}\n\n\tif (skb_headroom(skb) & 3) {\n\t\tstruct sk_buff *rskb, *fs;\n\t\tint flen = 0;\n\n\t\t \n\t\trskb = netdev_alloc_skb(dev, 0);\n\t\tif (!rskb) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto drop;\n\t\t}\n\t\tskb_shinfo(rskb)->frag_list = skb;\n\t\trskb->len += skb->len;\n\t\trskb->data_len += rskb->len;\n\t\trskb->truesize += rskb->len;\n\n\t\t \n\t\tskb_walk_frags(skb, fs)\n\t\t\tflen += fs->len;\n\t\tskb->next = skb_shinfo(skb)->frag_list;\n\t\tskb_frag_list_init(skb);\n\t\tskb->len -= flen;\n\t\tskb->data_len -= flen;\n\t\tskb->truesize -= flen;\n\n\t\tskb = rskb;\n\t}\n\n\tskb->protocol = protocol;\n\tskb_reset_mac_header(skb);\n\tskb->dev = dev;\n\n\tif (likely(dev->flags & IFF_UP)) {\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tnetif_rx(skb);\n\t\tskb = NULL;\n\t} else\n\t\terr = -ENODEV;\n\ndrop:\n\tif (skb) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.rx_dropped++;\n\t}\n\treturn err;\n}\n\nstatic void gprs_data_ready(struct sock *sk)\n{\n\tstruct gprs_dev *gp = sk->sk_user_data;\n\tstruct sk_buff *skb;\n\n\ttrace_sk_data_ready(sk);\n\n\twhile ((skb = pep_read(sk)) != NULL) {\n\t\tskb_orphan(skb);\n\t\tgprs_recv(gp, skb);\n\t}\n}\n\nstatic void gprs_write_space(struct sock *sk)\n{\n\tstruct gprs_dev *gp = sk->sk_user_data;\n\n\tif (netif_running(gp->dev))\n\t\tgprs_writeable(gp);\n}\n\n \n\nstatic int gprs_open(struct net_device *dev)\n{\n\tstruct gprs_dev *gp = netdev_priv(dev);\n\n\tgprs_writeable(gp);\n\treturn 0;\n}\n\nstatic int gprs_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t gprs_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct gprs_dev *gp = netdev_priv(dev);\n\tstruct sock *sk = gp->sk;\n\tint len, err;\n\n\tswitch (skb->protocol) {\n\tcase  htons(ETH_P_IP):\n\tcase  htons(ETH_P_IPV6):\n\t\tbreak;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tskb_orphan(skb);\n\tskb_set_owner_w(skb, sk);\n\tlen = skb->len;\n\terr = pep_write(sk, skb);\n\tif (err) {\n\t\tnet_dbg_ratelimited(\"%s: TX error (%d)\\n\", dev->name, err);\n\t\tdev->stats.tx_aborted_errors++;\n\t\tdev->stats.tx_errors++;\n\t} else {\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += len;\n\t}\n\n\tnetif_stop_queue(dev);\n\tif (pep_writeable(sk))\n\t\tnetif_wake_queue(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops gprs_netdev_ops = {\n\t.ndo_open\t= gprs_open,\n\t.ndo_stop\t= gprs_close,\n\t.ndo_start_xmit\t= gprs_xmit,\n};\n\nstatic void gprs_setup(struct net_device *dev)\n{\n\tdev->features\t\t= NETIF_F_FRAGLIST;\n\tdev->type\t\t= ARPHRD_PHONET_PIPE;\n\tdev->flags\t\t= IFF_POINTOPOINT | IFF_NOARP;\n\tdev->mtu\t\t= GPRS_DEFAULT_MTU;\n\tdev->min_mtu\t\t= 576;\n\tdev->max_mtu\t\t= (PHONET_MAX_MTU - 11);\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 10;\n\n\tdev->netdev_ops\t\t= &gprs_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n}\n\n \n\n \nint gprs_attach(struct sock *sk)\n{\n\tstatic const char ifname[] = \"gprs%d\";\n\tstruct gprs_dev *gp;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (unlikely(sk->sk_type == SOCK_STREAM))\n\t\treturn -EINVAL;  \n\n\t \n\tdev = alloc_netdev(sizeof(*gp), ifname, NET_NAME_UNKNOWN, gprs_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgp = netdev_priv(dev);\n\tgp->sk = sk;\n\tgp->dev = dev;\n\n\tnetif_stop_queue(dev);\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn err;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_user_data)) {\n\t\terr = -EBUSY;\n\t\tgoto out_rel;\n\t}\n\tif (unlikely((1 << sk->sk_state & (TCPF_CLOSE|TCPF_LISTEN)) ||\n\t\t\tsock_flag(sk, SOCK_DEAD))) {\n\t\terr = -EINVAL;\n\t\tgoto out_rel;\n\t}\n\tsk->sk_user_data\t= gp;\n\tgp->old_state_change\t= sk->sk_state_change;\n\tgp->old_data_ready\t= sk->sk_data_ready;\n\tgp->old_write_space\t= sk->sk_write_space;\n\tsk->sk_state_change\t= gprs_state_change;\n\tsk->sk_data_ready\t= gprs_data_ready;\n\tsk->sk_write_space\t= gprs_write_space;\n\trelease_sock(sk);\n\tsock_hold(sk);\n\n\tprintk(KERN_DEBUG\"%s: attached\\n\", dev->name);\n\treturn dev->ifindex;\n\nout_rel:\n\trelease_sock(sk);\n\tunregister_netdev(dev);\n\treturn err;\n}\n\nvoid gprs_detach(struct sock *sk)\n{\n\tstruct gprs_dev *gp = sk->sk_user_data;\n\tstruct net_device *dev = gp->dev;\n\n\tlock_sock(sk);\n\tsk->sk_user_data\t= NULL;\n\tsk->sk_state_change\t= gp->old_state_change;\n\tsk->sk_data_ready\t= gp->old_data_ready;\n\tsk->sk_write_space\t= gp->old_write_space;\n\trelease_sock(sk);\n\n\tprintk(KERN_DEBUG\"%s: detached\\n\", dev->name);\n\tunregister_netdev(dev);\n\tsock_put(sk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}