{
  "module_name": "pn_netlink.c",
  "hash_id": "3d0c0a503f2b1b68012d38d5640d4f2e5c80af11e735a48071ecca80e41c111b",
  "original_prompt": "Ingested from linux-6.6.14/net/phonet/pn_netlink.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/phonet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/phonet/pn_dev.h>\n\n \n\nstatic int fill_addr(struct sk_buff *skb, struct net_device *dev, u8 addr,\n\t\t     u32 portid, u32 seq, int event);\n\nvoid phonet_address_notify(int event, struct net_device *dev, u8 addr)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(NLMSG_ALIGN(sizeof(struct ifaddrmsg)) +\n\t\t\tnla_total_size(1), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = fill_addr(skb, dev, addr, 0, 0, event);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, dev_net(dev), 0,\n\t\t    RTNLGRP_PHONET_IFADDR, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\trtnl_set_sk_err(dev_net(dev), RTNLGRP_PHONET_IFADDR, err);\n}\n\nstatic const struct nla_policy ifa_phonet_policy[IFA_MAX+1] = {\n\t[IFA_LOCAL] = { .type = NLA_U8 },\n};\n\nstatic int addr_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct net_device *dev;\n\tstruct ifaddrmsg *ifm;\n\tint err;\n\tu8 pnaddr;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tASSERT_RTNL();\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t     ifa_phonet_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tifm = nlmsg_data(nlh);\n\tif (tb[IFA_LOCAL] == NULL)\n\t\treturn -EINVAL;\n\tpnaddr = nla_get_u8(tb[IFA_LOCAL]);\n\tif (pnaddr & 3)\n\t\t \n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tif (nlh->nlmsg_type == RTM_NEWADDR)\n\t\terr = phonet_address_add(dev, pnaddr);\n\telse\n\t\terr = phonet_address_del(dev, pnaddr);\n\tif (!err)\n\t\tphonet_address_notify(nlh->nlmsg_type, dev, pnaddr);\n\treturn err;\n}\n\nstatic int fill_addr(struct sk_buff *skb, struct net_device *dev, u8 addr,\n\t\t\tu32 portid, u32 seq, int event)\n{\n\tstruct ifaddrmsg *ifm;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*ifm), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifa_family = AF_PHONET;\n\tifm->ifa_prefixlen = 0;\n\tifm->ifa_flags = IFA_F_PERMANENT;\n\tifm->ifa_scope = RT_SCOPE_LINK;\n\tifm->ifa_index = dev->ifindex;\n\tif (nla_put_u8(skb, IFA_LOCAL, addr))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int getaddr_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct phonet_device_list *pndevs;\n\tstruct phonet_device *pnd;\n\tint dev_idx = 0, dev_start_idx = cb->args[0];\n\tint addr_idx = 0, addr_start_idx = cb->args[1];\n\n\tpndevs = phonet_device_list(sock_net(skb->sk));\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pnd, &pndevs->list, list) {\n\t\tu8 addr;\n\n\t\tif (dev_idx > dev_start_idx)\n\t\t\taddr_start_idx = 0;\n\t\tif (dev_idx++ < dev_start_idx)\n\t\t\tcontinue;\n\n\t\taddr_idx = 0;\n\t\tfor_each_set_bit(addr, pnd->addrs, 64) {\n\t\t\tif (addr_idx++ < addr_start_idx)\n\t\t\t\tcontinue;\n\n\t\t\tif (fill_addr(skb, pnd->netdev, addr << 2,\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_NEWADDR) < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\tcb->args[0] = dev_idx;\n\tcb->args[1] = addr_idx;\n\n\treturn skb->len;\n}\n\n \n\nstatic int fill_route(struct sk_buff *skb, struct net_device *dev, u8 dst,\n\t\t\tu32 portid, u32 seq, int event)\n{\n\tstruct rtmsg *rtm;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family = AF_PHONET;\n\trtm->rtm_dst_len = 6;\n\trtm->rtm_src_len = 0;\n\trtm->rtm_tos = 0;\n\trtm->rtm_table = RT_TABLE_MAIN;\n\trtm->rtm_protocol = RTPROT_STATIC;\n\trtm->rtm_scope = RT_SCOPE_UNIVERSE;\n\trtm->rtm_type = RTN_UNICAST;\n\trtm->rtm_flags = 0;\n\tif (nla_put_u8(skb, RTA_DST, dst) ||\n\t    nla_put_u32(skb, RTA_OIF, dev->ifindex))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nvoid rtm_phonet_notify(int event, struct net_device *dev, u8 dst)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(NLMSG_ALIGN(sizeof(struct ifaddrmsg)) +\n\t\t\tnla_total_size(1) + nla_total_size(4), GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = fill_route(skb, dev, dst, 0, 0, event);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, dev_net(dev), 0,\n\t\t\t  RTNLGRP_PHONET_ROUTE, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\trtnl_set_sk_err(dev_net(dev), RTNLGRP_PHONET_ROUTE, err);\n}\n\nstatic const struct nla_policy rtm_phonet_policy[RTA_MAX+1] = {\n\t[RTA_DST] = { .type = NLA_U8 },\n\t[RTA_OIF] = { .type = NLA_U32 },\n};\n\nstatic int route_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct net_device *dev;\n\tstruct rtmsg *rtm;\n\tint err;\n\tu8 dst;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tASSERT_RTNL();\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t     rtm_phonet_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\trtm = nlmsg_data(nlh);\n\tif (rtm->rtm_table != RT_TABLE_MAIN || rtm->rtm_type != RTN_UNICAST)\n\t\treturn -EINVAL;\n\tif (tb[RTA_DST] == NULL || tb[RTA_OIF] == NULL)\n\t\treturn -EINVAL;\n\tdst = nla_get_u8(tb[RTA_DST]);\n\tif (dst & 3)  \n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_index(net, nla_get_u32(tb[RTA_OIF]));\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tif (nlh->nlmsg_type == RTM_NEWROUTE)\n\t\terr = phonet_route_add(dev, dst);\n\telse\n\t\terr = phonet_route_del(dev, dst);\n\tif (!err)\n\t\trtm_phonet_notify(nlh->nlmsg_type, dev, dst);\n\treturn err;\n}\n\nstatic int route_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu8 addr;\n\n\trcu_read_lock();\n\tfor (addr = cb->args[0]; addr < 64; addr++) {\n\t\tstruct net_device *dev = phonet_route_get_rcu(net, addr << 2);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tif (fill_route(skb, dev, addr << 2, NETLINK_CB(cb->skb).portid,\n\t\t\t       cb->nlh->nlmsg_seq, RTM_NEWROUTE) < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\trcu_read_unlock();\n\tcb->args[0] = addr;\n\n\treturn skb->len;\n}\n\nint __init phonet_netlink_register(void)\n{\n\tint err = rtnl_register_module(THIS_MODULE, PF_PHONET, RTM_NEWADDR,\n\t\t\t\t       addr_doit, NULL, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\trtnl_register_module(THIS_MODULE, PF_PHONET, RTM_DELADDR,\n\t\t\t     addr_doit, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_PHONET, RTM_GETADDR,\n\t\t\t     NULL, getaddr_dumpit, 0);\n\trtnl_register_module(THIS_MODULE, PF_PHONET, RTM_NEWROUTE,\n\t\t\t     route_doit, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_PHONET, RTM_DELROUTE,\n\t\t\t     route_doit, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_PHONET, RTM_GETROUTE,\n\t\t\t     NULL, route_dumpit, 0);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}