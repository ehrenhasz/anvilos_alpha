{
  "module_name": "datagram.c",
  "hash_id": "81171e6b4722512f7b844835bb6f9f17edf90b37d5aa6367fe298088267fa533",
  "original_prompt": "Ingested from linux-6.6.14/net/phonet/datagram.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <asm/ioctls.h>\n#include <net/sock.h>\n\n#include <linux/phonet.h>\n#include <linux/export.h>\n#include <net/phonet/phonet.h>\n\nstatic int pn_backlog_rcv(struct sock *sk, struct sk_buff *skb);\n\n \nstatic void pn_sock_close(struct sock *sk, long timeout)\n{\n\tsk_common_release(sk);\n}\n\nstatic int pn_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tstruct sk_buff *skb;\n\n\tswitch (cmd) {\n\tcase SIOCINQ:\n\t\tlock_sock(sk);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\t*karg = skb ? skb->len : 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\n\tcase SIOCPNADDRESOURCE:\n\tcase SIOCPNDELRESOURCE: {\n\t\t\tu32 res = *karg;\n\t\t\tif (res >= 256)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cmd == SIOCPNADDRESOURCE)\n\t\t\t\treturn pn_sock_bind_res(sk, res);\n\t\t\telse\n\t\t\t\treturn pn_sock_unbind_res(sk, res);\n\t\t}\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\n \nstatic void pn_destruct(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_receive_queue);\n}\n\nstatic int pn_init(struct sock *sk)\n{\n\tsk->sk_destruct = pn_destruct;\n\treturn 0;\n}\n\nstatic int pn_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_pn *, target, msg->msg_name);\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_NOSIGNAL|\n\t\t\t\tMSG_CMSG_COMPAT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (target == NULL)\n\t\treturn -EDESTADDRREQ;\n\n\tif (msg->msg_namelen < sizeof(struct sockaddr_pn))\n\t\treturn -EINVAL;\n\n\tif (target->spn_family != AF_PHONET)\n\t\treturn -EAFNOSUPPORT;\n\n\tskb = sock_alloc_send_skb(sk, MAX_PHONET_HEADER + len,\n\t\t\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\treturn err;\n\tskb_reserve(skb, MAX_PHONET_HEADER);\n\n\terr = memcpy_from_msg((void *)skb_put(skb, len), msg, len);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\t \n\terr = pn_skb_send(sk, skb, target);\n\n\t \n\treturn (err >= 0) ? len : err;\n}\n\nstatic int pn_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t      int flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n\t\t\tMSG_CMSG_COMPAT))\n\t\tgoto out_nofree;\n\n\tskb = skb_recv_datagram(sk, flags, &rval);\n\tif (skb == NULL)\n\t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_msg(skb, 0, msg, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n\n\tif (msg->msg_name != NULL) {\n\t\t__sockaddr_check_size(sizeof(sa));\n\t\tmemcpy(msg->msg_name, &sa, sizeof(sa));\n\t\t*addr_len = sizeof(sa);\n\t}\n\nout:\n\tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n\n \nstatic int pn_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = sock_queue_rcv_skb(sk, skb);\n\n\tif (err < 0)\n\t\tkfree_skb(skb);\n\treturn err ? NET_RX_DROP : NET_RX_SUCCESS;\n}\n\n \nstatic struct proto pn_proto = {\n\t.close\t\t= pn_sock_close,\n\t.ioctl\t\t= pn_ioctl,\n\t.init\t\t= pn_init,\n\t.sendmsg\t= pn_sendmsg,\n\t.recvmsg\t= pn_recvmsg,\n\t.backlog_rcv\t= pn_backlog_rcv,\n\t.hash\t\t= pn_sock_hash,\n\t.unhash\t\t= pn_sock_unhash,\n\t.get_port\t= pn_sock_get_port,\n\t.obj_size\t= sizeof(struct pn_sock),\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"PHONET\",\n};\n\nstatic const struct phonet_protocol pn_dgram_proto = {\n\t.ops\t\t= &phonet_dgram_ops,\n\t.prot\t\t= &pn_proto,\n\t.sock_type\t= SOCK_DGRAM,\n};\n\nint __init isi_register(void)\n{\n\treturn phonet_proto_register(PN_PROTO_PHONET, &pn_dgram_proto);\n}\n\nvoid __exit isi_unregister(void)\n{\n\tphonet_proto_unregister(PN_PROTO_PHONET, &pn_dgram_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}