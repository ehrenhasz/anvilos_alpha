{
  "module_name": "pn_dev.c",
  "hash_id": "c46bf21cbb7229c11bd722a12785bfeede6a89138a1846af49d8326b8deaa9e8",
  "original_prompt": "Ingested from linux-6.6.14/net/phonet/pn_dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/phonet.h>\n#include <linux/proc_fs.h>\n#include <linux/if_arp.h>\n#include <net/sock.h>\n#include <net/netns/generic.h>\n#include <net/phonet/pn_dev.h>\n\nstruct phonet_routes {\n\tstruct mutex\t\tlock;\n\tstruct net_device __rcu\t*table[64];\n};\n\nstruct phonet_net {\n\tstruct phonet_device_list pndevs;\n\tstruct phonet_routes routes;\n};\n\nstatic unsigned int phonet_net_id __read_mostly;\n\nstatic struct phonet_net *phonet_pernet(struct net *net)\n{\n\treturn net_generic(net, phonet_net_id);\n}\n\nstruct phonet_device_list *phonet_device_list(struct net *net)\n{\n\tstruct phonet_net *pnn = phonet_pernet(net);\n\treturn &pnn->pndevs;\n}\n\n \nstatic struct phonet_device *__phonet_device_alloc(struct net_device *dev)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));\n\tstruct phonet_device *pnd = kmalloc(sizeof(*pnd), GFP_ATOMIC);\n\tif (pnd == NULL)\n\t\treturn NULL;\n\tpnd->netdev = dev;\n\tbitmap_zero(pnd->addrs, 64);\n\n\tBUG_ON(!mutex_is_locked(&pndevs->lock));\n\tlist_add_rcu(&pnd->list, &pndevs->list);\n\treturn pnd;\n}\n\nstatic struct phonet_device *__phonet_get(struct net_device *dev)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));\n\tstruct phonet_device *pnd;\n\n\tBUG_ON(!mutex_is_locked(&pndevs->lock));\n\tlist_for_each_entry(pnd, &pndevs->list, list) {\n\t\tif (pnd->netdev == dev)\n\t\t\treturn pnd;\n\t}\n\treturn NULL;\n}\n\nstatic struct phonet_device *__phonet_get_rcu(struct net_device *dev)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));\n\tstruct phonet_device *pnd;\n\n\tlist_for_each_entry_rcu(pnd, &pndevs->list, list) {\n\t\tif (pnd->netdev == dev)\n\t\t\treturn pnd;\n\t}\n\treturn NULL;\n}\n\nstatic void phonet_device_destroy(struct net_device *dev)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));\n\tstruct phonet_device *pnd;\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&pndevs->lock);\n\tpnd = __phonet_get(dev);\n\tif (pnd)\n\t\tlist_del_rcu(&pnd->list);\n\tmutex_unlock(&pndevs->lock);\n\n\tif (pnd) {\n\t\tu8 addr;\n\n\t\tfor_each_set_bit(addr, pnd->addrs, 64)\n\t\t\tphonet_address_notify(RTM_DELADDR, dev, addr);\n\t\tkfree(pnd);\n\t}\n}\n\nstruct net_device *phonet_device_get(struct net *net)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(net);\n\tstruct phonet_device *pnd;\n\tstruct net_device *dev = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pnd, &pndevs->list, list) {\n\t\tdev = pnd->netdev;\n\t\tBUG_ON(!dev);\n\n\t\tif ((dev->reg_state == NETREG_REGISTERED) &&\n\t\t\t((pnd->netdev->flags & IFF_UP)) == IFF_UP)\n\t\t\tbreak;\n\t\tdev = NULL;\n\t}\n\tdev_hold(dev);\n\trcu_read_unlock();\n\treturn dev;\n}\n\nint phonet_address_add(struct net_device *dev, u8 addr)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));\n\tstruct phonet_device *pnd;\n\tint err = 0;\n\n\tmutex_lock(&pndevs->lock);\n\t \n\tpnd = __phonet_get(dev);\n\tif (pnd == NULL)\n\t\tpnd = __phonet_device_alloc(dev);\n\tif (unlikely(pnd == NULL))\n\t\terr = -ENOMEM;\n\telse if (test_and_set_bit(addr >> 2, pnd->addrs))\n\t\terr = -EEXIST;\n\tmutex_unlock(&pndevs->lock);\n\treturn err;\n}\n\nint phonet_address_del(struct net_device *dev, u8 addr)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(dev_net(dev));\n\tstruct phonet_device *pnd;\n\tint err = 0;\n\n\tmutex_lock(&pndevs->lock);\n\tpnd = __phonet_get(dev);\n\tif (!pnd || !test_and_clear_bit(addr >> 2, pnd->addrs)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tpnd = NULL;\n\t} else if (bitmap_empty(pnd->addrs, 64))\n\t\tlist_del_rcu(&pnd->list);\n\telse\n\t\tpnd = NULL;\n\tmutex_unlock(&pndevs->lock);\n\n\tif (pnd)\n\t\tkfree_rcu(pnd, rcu);\n\n\treturn err;\n}\n\n \nu8 phonet_address_get(struct net_device *dev, u8 daddr)\n{\n\tstruct phonet_device *pnd;\n\tu8 saddr;\n\n\trcu_read_lock();\n\tpnd = __phonet_get_rcu(dev);\n\tif (pnd) {\n\t\tBUG_ON(bitmap_empty(pnd->addrs, 64));\n\n\t\t \n\t\tif (test_bit(daddr >> 2, pnd->addrs))\n\t\t\tsaddr = daddr;\n\t\telse\n\t\t\tsaddr = find_first_bit(pnd->addrs, 64) << 2;\n\t} else\n\t\tsaddr = PN_NO_ADDR;\n\trcu_read_unlock();\n\n\tif (saddr == PN_NO_ADDR) {\n\t\t \n\t\tstruct net_device *def_dev;\n\n\t\tdef_dev = phonet_device_get(dev_net(dev));\n\t\tif (def_dev) {\n\t\t\tif (def_dev != dev)\n\t\t\t\tsaddr = phonet_address_get(def_dev, daddr);\n\t\t\tdev_put(def_dev);\n\t\t}\n\t}\n\treturn saddr;\n}\n\nint phonet_address_lookup(struct net *net, u8 addr)\n{\n\tstruct phonet_device_list *pndevs = phonet_device_list(net);\n\tstruct phonet_device *pnd;\n\tint err = -EADDRNOTAVAIL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pnd, &pndevs->list, list) {\n\t\t \n\t\tif ((pnd->netdev->reg_state != NETREG_REGISTERED) ||\n\t\t\t\t((pnd->netdev->flags & IFF_UP)) != IFF_UP)\n\t\t\tcontinue;\n\n\t\tif (test_bit(addr >> 2, pnd->addrs)) {\n\t\t\terr = 0;\n\t\t\tgoto found;\n\t\t}\n\t}\nfound:\n\trcu_read_unlock();\n\treturn err;\n}\n\n \nstatic int phonet_device_autoconf(struct net_device *dev)\n{\n\tstruct if_phonet_req req;\n\tint ret;\n\n\tif (!dev->netdev_ops->ndo_siocdevprivate)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev->netdev_ops->ndo_siocdevprivate(dev, (struct ifreq *)&req,\n\t\t\t\t\t\t  NULL, SIOCPNGAUTOCONF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tASSERT_RTNL();\n\tret = phonet_address_add(dev, req.ifr_phonet_autoconf.device);\n\tif (ret)\n\t\treturn ret;\n\tphonet_address_notify(RTM_NEWADDR, dev,\n\t\t\t\treq.ifr_phonet_autoconf.device);\n\treturn 0;\n}\n\nstatic void phonet_route_autodel(struct net_device *dev)\n{\n\tstruct phonet_net *pnn = phonet_pernet(dev_net(dev));\n\tunsigned int i;\n\tDECLARE_BITMAP(deleted, 64);\n\n\t \n\tbitmap_zero(deleted, 64);\n\tmutex_lock(&pnn->routes.lock);\n\tfor (i = 0; i < 64; i++)\n\t\tif (rcu_access_pointer(pnn->routes.table[i]) == dev) {\n\t\t\tRCU_INIT_POINTER(pnn->routes.table[i], NULL);\n\t\t\tset_bit(i, deleted);\n\t\t}\n\tmutex_unlock(&pnn->routes.lock);\n\n\tif (bitmap_empty(deleted, 64))\n\t\treturn;  \n\tsynchronize_rcu();\n\tfor_each_set_bit(i, deleted, 64) {\n\t\trtm_phonet_notify(RTM_DELROUTE, dev, i);\n\t\tdev_put(dev);\n\t}\n}\n\n \nstatic int phonet_device_notify(struct notifier_block *me, unsigned long what,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (what) {\n\tcase NETDEV_REGISTER:\n\t\tif (dev->type == ARPHRD_PHONET)\n\t\t\tphonet_device_autoconf(dev);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tphonet_device_destroy(dev);\n\t\tphonet_route_autodel(dev);\n\t\tbreak;\n\t}\n\treturn 0;\n\n}\n\nstatic struct notifier_block phonet_device_notifier = {\n\t.notifier_call = phonet_device_notify,\n\t.priority = 0,\n};\n\n \nstatic int __net_init phonet_init_net(struct net *net)\n{\n\tstruct phonet_net *pnn = phonet_pernet(net);\n\n\tif (!proc_create_net(\"phonet\", 0, net->proc_net, &pn_sock_seq_ops,\n\t\t\tsizeof(struct seq_net_private)))\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pnn->pndevs.list);\n\tmutex_init(&pnn->pndevs.lock);\n\tmutex_init(&pnn->routes.lock);\n\treturn 0;\n}\n\nstatic void __net_exit phonet_exit_net(struct net *net)\n{\n\tstruct phonet_net *pnn = phonet_pernet(net);\n\n\tremove_proc_entry(\"phonet\", net->proc_net);\n\tWARN_ON_ONCE(!list_empty(&pnn->pndevs.list));\n}\n\nstatic struct pernet_operations phonet_net_ops = {\n\t.init = phonet_init_net,\n\t.exit = phonet_exit_net,\n\t.id   = &phonet_net_id,\n\t.size = sizeof(struct phonet_net),\n};\n\n \nint __init phonet_device_init(void)\n{\n\tint err = register_pernet_subsys(&phonet_net_ops);\n\tif (err)\n\t\treturn err;\n\n\tproc_create_net(\"pnresource\", 0, init_net.proc_net, &pn_res_seq_ops,\n\t\t\tsizeof(struct seq_net_private));\n\tregister_netdevice_notifier(&phonet_device_notifier);\n\terr = phonet_netlink_register();\n\tif (err)\n\t\tphonet_device_exit();\n\treturn err;\n}\n\nvoid phonet_device_exit(void)\n{\n\trtnl_unregister_all(PF_PHONET);\n\tunregister_netdevice_notifier(&phonet_device_notifier);\n\tunregister_pernet_subsys(&phonet_net_ops);\n\tremove_proc_entry(\"pnresource\", init_net.proc_net);\n}\n\nint phonet_route_add(struct net_device *dev, u8 daddr)\n{\n\tstruct phonet_net *pnn = phonet_pernet(dev_net(dev));\n\tstruct phonet_routes *routes = &pnn->routes;\n\tint err = -EEXIST;\n\n\tdaddr = daddr >> 2;\n\tmutex_lock(&routes->lock);\n\tif (routes->table[daddr] == NULL) {\n\t\trcu_assign_pointer(routes->table[daddr], dev);\n\t\tdev_hold(dev);\n\t\terr = 0;\n\t}\n\tmutex_unlock(&routes->lock);\n\treturn err;\n}\n\nint phonet_route_del(struct net_device *dev, u8 daddr)\n{\n\tstruct phonet_net *pnn = phonet_pernet(dev_net(dev));\n\tstruct phonet_routes *routes = &pnn->routes;\n\n\tdaddr = daddr >> 2;\n\tmutex_lock(&routes->lock);\n\tif (rcu_access_pointer(routes->table[daddr]) == dev)\n\t\tRCU_INIT_POINTER(routes->table[daddr], NULL);\n\telse\n\t\tdev = NULL;\n\tmutex_unlock(&routes->lock);\n\n\tif (!dev)\n\t\treturn -ENOENT;\n\tsynchronize_rcu();\n\tdev_put(dev);\n\treturn 0;\n}\n\nstruct net_device *phonet_route_get_rcu(struct net *net, u8 daddr)\n{\n\tstruct phonet_net *pnn = phonet_pernet(net);\n\tstruct phonet_routes *routes = &pnn->routes;\n\tstruct net_device *dev;\n\n\tdaddr >>= 2;\n\tdev = rcu_dereference(routes->table[daddr]);\n\treturn dev;\n}\n\nstruct net_device *phonet_route_output(struct net *net, u8 daddr)\n{\n\tstruct phonet_net *pnn = phonet_pernet(net);\n\tstruct phonet_routes *routes = &pnn->routes;\n\tstruct net_device *dev;\n\n\tdaddr >>= 2;\n\trcu_read_lock();\n\tdev = rcu_dereference(routes->table[daddr]);\n\tdev_hold(dev);\n\trcu_read_unlock();\n\n\tif (!dev)\n\t\tdev = phonet_device_get(net);  \n\treturn dev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}