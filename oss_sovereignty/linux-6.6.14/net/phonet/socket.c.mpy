{
  "module_name": "socket.c",
  "hash_id": "4dc99020fd6ddf40e6bfc534c9e05421ebc17a1a66d8c520a2146ee93bab18ec",
  "original_prompt": "Ingested from linux-6.6.14/net/phonet/socket.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/poll.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include <net/tcp_states.h>\n\n#include <linux/phonet.h>\n#include <linux/export.h>\n#include <net/phonet/phonet.h>\n#include <net/phonet/pep.h>\n#include <net/phonet/pn_dev.h>\n\nstatic int pn_socket_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tsock->sk = NULL;\n\t\tsk->sk_prot->close(sk, 0);\n\t}\n\treturn 0;\n}\n\n#define PN_HASHSIZE\t16\n#define PN_HASHMASK\t(PN_HASHSIZE-1)\n\n\nstatic struct  {\n\tstruct hlist_head hlist[PN_HASHSIZE];\n\tstruct mutex lock;\n} pnsocks;\n\nvoid __init pn_sock_init(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < PN_HASHSIZE; i++)\n\t\tINIT_HLIST_HEAD(pnsocks.hlist + i);\n\tmutex_init(&pnsocks.lock);\n}\n\nstatic struct hlist_head *pn_hash_list(u16 obj)\n{\n\treturn pnsocks.hlist + (obj & PN_HASHMASK);\n}\n\n \nstruct sock *pn_find_sock_by_sa(struct net *net, const struct sockaddr_pn *spn)\n{\n\tstruct sock *sknode;\n\tstruct sock *rval = NULL;\n\tu16 obj = pn_sockaddr_get_object(spn);\n\tu8 res = spn->spn_resource;\n\tstruct hlist_head *hlist = pn_hash_list(obj);\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sknode, hlist) {\n\t\tstruct pn_sock *pn = pn_sk(sknode);\n\t\tBUG_ON(!pn->sobject);  \n\n\t\tif (!net_eq(sock_net(sknode), net))\n\t\t\tcontinue;\n\t\tif (pn_port(obj)) {\n\t\t\t \n\t\t\tif (pn_port(pn->sobject) != pn_port(obj))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (pn->resource != res)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (pn_addr(pn->sobject) &&\n\t\t    pn_addr(pn->sobject) != pn_addr(obj))\n\t\t\tcontinue;\n\n\t\trval = sknode;\n\t\tsock_hold(sknode);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn rval;\n}\n\n \nvoid pn_deliver_sock_broadcast(struct net *net, struct sk_buff *skb)\n{\n\tstruct hlist_head *hlist = pnsocks.hlist;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < PN_HASHSIZE; h++) {\n\t\tstruct sock *sknode;\n\n\t\tsk_for_each(sknode, hlist) {\n\t\t\tstruct sk_buff *clone;\n\n\t\t\tif (!net_eq(sock_net(sknode), net))\n\t\t\t\tcontinue;\n\t\t\tif (!sock_flag(sknode, SOCK_BROADCAST))\n\t\t\t\tcontinue;\n\n\t\t\tclone = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (clone) {\n\t\t\t\tsock_hold(sknode);\n\t\t\t\tsk_receive_skb(sknode, clone, 0);\n\t\t\t}\n\t\t}\n\t\thlist++;\n\t}\n\trcu_read_unlock();\n}\n\nint pn_sock_hash(struct sock *sk)\n{\n\tstruct hlist_head *hlist = pn_hash_list(pn_sk(sk)->sobject);\n\n\tmutex_lock(&pnsocks.lock);\n\tsk_add_node_rcu(sk, hlist);\n\tmutex_unlock(&pnsocks.lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pn_sock_hash);\n\nvoid pn_sock_unhash(struct sock *sk)\n{\n\tmutex_lock(&pnsocks.lock);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&pnsocks.lock);\n\tpn_sock_unbind_all_res(sk);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(pn_sock_unhash);\n\nstatic DEFINE_MUTEX(port_mutex);\n\nstatic int pn_socket_bind(struct socket *sock, struct sockaddr *addr, int len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pn_sock *pn = pn_sk(sk);\n\tstruct sockaddr_pn *spn = (struct sockaddr_pn *)addr;\n\tint err;\n\tu16 handle;\n\tu8 saddr;\n\n\tif (sk->sk_prot->bind)\n\t\treturn sk->sk_prot->bind(sk, addr, len);\n\n\tif (len < sizeof(struct sockaddr_pn))\n\t\treturn -EINVAL;\n\tif (spn->spn_family != AF_PHONET)\n\t\treturn -EAFNOSUPPORT;\n\n\thandle = pn_sockaddr_get_object((struct sockaddr_pn *)addr);\n\tsaddr = pn_addr(handle);\n\tif (saddr && phonet_address_lookup(sock_net(sk), saddr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || pn_port(pn->sobject)) {\n\t\terr = -EINVAL;  \n\t\tgoto out;\n\t}\n\tWARN_ON(sk_hashed(sk));\n\tmutex_lock(&port_mutex);\n\terr = sk->sk_prot->get_port(sk, pn_port(handle));\n\tif (err)\n\t\tgoto out_port;\n\n\t \n\tpn->sobject = pn_object(saddr, pn_port(pn->sobject));\n\tpn->resource = spn->spn_resource;\n\n\t \n\terr = sk->sk_prot->hash(sk);\nout_port:\n\tmutex_unlock(&port_mutex);\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int pn_socket_autobind(struct socket *sock)\n{\n\tstruct sockaddr_pn sa;\n\tint err;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.spn_family = AF_PHONET;\n\terr = pn_socket_bind(sock, (struct sockaddr *)&sa,\n\t\t\t\tsizeof(struct sockaddr_pn));\n\tif (err != -EINVAL)\n\t\treturn err;\n\tBUG_ON(!pn_port(pn_sk(sock->sk)->sobject));\n\treturn 0;  \n}\n\nstatic int pn_socket_connect(struct socket *sock, struct sockaddr *addr,\n\t\tint len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pn_sock *pn = pn_sk(sk);\n\tstruct sockaddr_pn *spn = (struct sockaddr_pn *)addr;\n\tstruct task_struct *tsk = current;\n\tlong timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\tint err;\n\n\tif (pn_socket_autobind(sock))\n\t\treturn -ENOBUFS;\n\tif (len < sizeof(struct sockaddr_pn))\n\t\treturn -EINVAL;\n\tif (spn->spn_family != AF_PHONET)\n\t\treturn -EAFNOSUPPORT;\n\n\tlock_sock(sk);\n\n\tswitch (sock->state) {\n\tcase SS_UNCONNECTED:\n\t\tif (sk->sk_state != TCP_CLOSE) {\n\t\t\terr = -EISCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SS_CONNECTING:\n\t\terr = -EALREADY;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EISCONN;\n\t\tgoto out;\n\t}\n\n\tpn->dobject = pn_sockaddr_get_object(spn);\n\tpn->resource = pn_sockaddr_get_resource(spn);\n\tsock->state = SS_CONNECTING;\n\n\terr = sk->sk_prot->connect(sk, addr, len);\n\tif (err) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tpn->dobject = 0;\n\t\tgoto out;\n\t}\n\n\twhile (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tif (!timeo) {\n\t\t\terr = -EINPROGRESS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (signal_pending(tsk)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tgoto out;\n\t\t}\n\n\t\tprepare_to_wait_exclusive(sk_sleep(sk), &wait,\n\t\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\t}\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_RECV|TCPF_ESTABLISHED))\n\t\terr = 0;\n\telse if (sk->sk_state == TCP_CLOSE_WAIT)\n\t\terr = -ECONNRESET;\n\telse\n\t\terr = -ECONNREFUSED;\n\tsock->state = err ? SS_UNCONNECTED : SS_CONNECTED;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int pn_socket_accept(struct socket *sock, struct socket *newsock,\n\t\t\t    int flags, bool kern)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *newsk;\n\tint err;\n\n\tif (unlikely(sk->sk_state != TCP_LISTEN))\n\t\treturn -EINVAL;\n\n\tnewsk = sk->sk_prot->accept(sk, flags, &err, kern);\n\tif (!newsk)\n\t\treturn err;\n\n\tlock_sock(newsk);\n\tsock_graft(newsk, newsock);\n\tnewsock->state = SS_CONNECTED;\n\trelease_sock(newsk);\n\treturn 0;\n}\n\nstatic int pn_socket_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t\tint peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pn_sock *pn = pn_sk(sk);\n\n\tmemset(addr, 0, sizeof(struct sockaddr_pn));\n\taddr->sa_family = AF_PHONET;\n\tif (!peer)  \n\t\tpn_sockaddr_set_object((struct sockaddr_pn *)addr,\n\t\t\t\t\tpn->sobject);\n\n\treturn sizeof(struct sockaddr_pn);\n}\n\nstatic __poll_t pn_socket_poll(struct file *file, struct socket *sock,\n\t\t\t\t\tpoll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pep_sock *pn = pep_sk(sk);\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\treturn EPOLLERR;\n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (!skb_queue_empty_lockless(&pn->ctrlreq_queue))\n\t\tmask |= EPOLLPRI;\n\tif (!mask && sk->sk_state == TCP_CLOSE_WAIT)\n\t\treturn EPOLLHUP;\n\n\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\trefcount_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf &&\n\t\tatomic_read(&pn->tx_credits))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND;\n\n\treturn mask;\n}\n\nstatic int pn_socket_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pn_sock *pn = pn_sk(sk);\n\n\tif (cmd == SIOCPNGETOBJECT) {\n\t\tstruct net_device *dev;\n\t\tu16 handle;\n\t\tu8 saddr;\n\n\t\tif (get_user(handle, (__u16 __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tdev = dev_get_by_index(sock_net(sk),\n\t\t\t\t\t\tsk->sk_bound_dev_if);\n\t\telse\n\t\t\tdev = phonet_device_get(sock_net(sk));\n\t\tif (dev && (dev->flags & IFF_UP))\n\t\t\tsaddr = phonet_address_get(dev, pn_addr(handle));\n\t\telse\n\t\t\tsaddr = PN_NO_ADDR;\n\t\trelease_sock(sk);\n\n\t\tdev_put(dev);\n\t\tif (saddr == PN_NO_ADDR)\n\t\t\treturn -EHOSTUNREACH;\n\n\t\thandle = pn_object(saddr, pn_port(pn->sobject));\n\t\treturn put_user(handle, (__u16 __user *)arg);\n\t}\n\n\treturn sk_ioctl(sk, cmd, (void __user *)arg);\n}\n\nstatic int pn_socket_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tif (pn_socket_autobind(sock))\n\t\treturn -ENOBUFS;\n\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tsk->sk_state = TCP_LISTEN;\n\t\tsk->sk_ack_backlog = 0;\n\t}\n\tsk->sk_max_ack_backlog = backlog;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int pn_socket_sendmsg(struct socket *sock, struct msghdr *m,\n\t\t\t     size_t total_len)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (pn_socket_autobind(sock))\n\t\treturn -EAGAIN;\n\n\treturn sk->sk_prot->sendmsg(sk, m, total_len);\n}\n\nconst struct proto_ops phonet_dgram_ops = {\n\t.family\t\t= AF_PHONET,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= pn_socket_release,\n\t.bind\t\t= pn_socket_bind,\n\t.connect\t= sock_no_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= pn_socket_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= pn_socket_ioctl,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.sendmsg\t= pn_socket_sendmsg,\n\t.recvmsg\t= sock_common_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\n\nconst struct proto_ops phonet_stream_ops = {\n\t.family\t\t= AF_PHONET,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= pn_socket_release,\n\t.bind\t\t= pn_socket_bind,\n\t.connect\t= pn_socket_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= pn_socket_accept,\n\t.getname\t= pn_socket_getname,\n\t.poll\t\t= pn_socket_poll,\n\t.ioctl\t\t= pn_socket_ioctl,\n\t.listen\t\t= pn_socket_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= sock_common_setsockopt,\n\t.getsockopt\t= sock_common_getsockopt,\n\t.sendmsg\t= pn_socket_sendmsg,\n\t.recvmsg\t= sock_common_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\nEXPORT_SYMBOL(phonet_stream_ops);\n\n \nint pn_sock_get_port(struct sock *sk, unsigned short sport)\n{\n\tstatic int port_cur;\n\tstruct net *net = sock_net(sk);\n\tstruct pn_sock *pn = pn_sk(sk);\n\tstruct sockaddr_pn try_sa;\n\tstruct sock *tmpsk;\n\n\tmemset(&try_sa, 0, sizeof(struct sockaddr_pn));\n\ttry_sa.spn_family = AF_PHONET;\n\tWARN_ON(!mutex_is_locked(&port_mutex));\n\tif (!sport) {\n\t\t \n\t\tint port, pmin, pmax;\n\n\t\tphonet_get_local_port_range(&pmin, &pmax);\n\t\tfor (port = pmin; port <= pmax; port++) {\n\t\t\tport_cur++;\n\t\t\tif (port_cur < pmin || port_cur > pmax)\n\t\t\t\tport_cur = pmin;\n\n\t\t\tpn_sockaddr_set_port(&try_sa, port_cur);\n\t\t\ttmpsk = pn_find_sock_by_sa(net, &try_sa);\n\t\t\tif (tmpsk == NULL) {\n\t\t\t\tsport = port_cur;\n\t\t\t\tgoto found;\n\t\t\t} else\n\t\t\t\tsock_put(tmpsk);\n\t\t}\n\t} else {\n\t\t \n\t\tpn_sockaddr_set_port(&try_sa, sport);\n\t\ttmpsk = pn_find_sock_by_sa(net, &try_sa);\n\t\tif (tmpsk == NULL)\n\t\t\t \n\t\t\tgoto found;\n\t\telse\n\t\t\tsock_put(tmpsk);\n\t}\n\t \n\treturn -EADDRINUSE;\n\nfound:\n\tpn->sobject = pn_object(pn_addr(pn->sobject), sport);\n\treturn 0;\n}\nEXPORT_SYMBOL(pn_sock_get_port);\n\n#ifdef CONFIG_PROC_FS\nstatic struct sock *pn_sock_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct hlist_head *hlist = pnsocks.hlist;\n\tstruct sock *sknode;\n\tunsigned int h;\n\n\tfor (h = 0; h < PN_HASHSIZE; h++) {\n\t\tsk_for_each_rcu(sknode, hlist) {\n\t\t\tif (!net_eq(net, sock_net(sknode)))\n\t\t\t\tcontinue;\n\t\t\tif (!pos)\n\t\t\t\treturn sknode;\n\t\t\tpos--;\n\t\t}\n\t\thlist++;\n\t}\n\treturn NULL;\n}\n\nstatic struct sock *pn_sock_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct net *net = seq_file_net(seq);\n\n\tdo\n\t\tsk = sk_next(sk);\n\twhile (sk && !net_eq(net, sock_net(sk)));\n\n\treturn sk;\n}\n\nstatic void *pn_sock_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? pn_sock_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *pn_sock_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = pn_sock_get_idx(seq, 0);\n\telse\n\t\tsk = pn_sock_get_next(seq, v);\n\t(*pos)++;\n\treturn sk;\n}\n\nstatic void pn_sock_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic int pn_sock_seq_show(struct seq_file *seq, void *v)\n{\n\tseq_setwidth(seq, 127);\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"pt  loc  rem rs st tx_queue rx_queue \"\n\t\t\t\"  uid inode ref pointer drops\");\n\telse {\n\t\tstruct sock *sk = v;\n\t\tstruct pn_sock *pn = pn_sk(sk);\n\n\t\tseq_printf(seq, \"%2d %04X:%04X:%02X %02X %08X:%08X %5d %lu \"\n\t\t\t\"%d %pK %u\",\n\t\t\tsk->sk_protocol, pn->sobject, pn->dobject,\n\t\t\tpn->resource, sk->sk_state,\n\t\t\tsk_wmem_alloc_get(sk), sk_rmem_alloc_get(sk),\n\t\t\tfrom_kuid_munged(seq_user_ns(seq), sock_i_uid(sk)),\n\t\t\tsock_i_ino(sk),\n\t\t\trefcount_read(&sk->sk_refcnt), sk,\n\t\t\tatomic_read(&sk->sk_drops));\n\t}\n\tseq_pad(seq, '\\n');\n\treturn 0;\n}\n\nconst struct seq_operations pn_sock_seq_ops = {\n\t.start = pn_sock_seq_start,\n\t.next = pn_sock_seq_next,\n\t.stop = pn_sock_seq_stop,\n\t.show = pn_sock_seq_show,\n};\n#endif\n\nstatic struct  {\n\tstruct sock *sk[256];\n} pnres;\n\n \nstruct sock *pn_find_sock_by_res(struct net *net, u8 res)\n{\n\tstruct sock *sk;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tsk = rcu_dereference(pnres.sk[res]);\n\tif (sk)\n\t\tsock_hold(sk);\n\trcu_read_unlock();\n\treturn sk;\n}\n\nstatic DEFINE_MUTEX(resource_mutex);\n\nint pn_sock_bind_res(struct sock *sk, u8 res)\n{\n\tint ret = -EADDRINUSE;\n\n\tif (!net_eq(sock_net(sk), &init_net))\n\t\treturn -ENOIOCTLCMD;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (pn_socket_autobind(sk->sk_socket))\n\t\treturn -EAGAIN;\n\n\tmutex_lock(&resource_mutex);\n\tif (pnres.sk[res] == NULL) {\n\t\tsock_hold(sk);\n\t\trcu_assign_pointer(pnres.sk[res], sk);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&resource_mutex);\n\treturn ret;\n}\n\nint pn_sock_unbind_res(struct sock *sk, u8 res)\n{\n\tint ret = -ENOENT;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&resource_mutex);\n\tif (pnres.sk[res] == sk) {\n\t\tRCU_INIT_POINTER(pnres.sk[res], NULL);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&resource_mutex);\n\n\tif (ret == 0) {\n\t\tsynchronize_rcu();\n\t\tsock_put(sk);\n\t}\n\treturn ret;\n}\n\nvoid pn_sock_unbind_all_res(struct sock *sk)\n{\n\tunsigned int res, match = 0;\n\n\tmutex_lock(&resource_mutex);\n\tfor (res = 0; res < 256; res++) {\n\t\tif (pnres.sk[res] == sk) {\n\t\t\tRCU_INIT_POINTER(pnres.sk[res], NULL);\n\t\t\tmatch++;\n\t\t}\n\t}\n\tmutex_unlock(&resource_mutex);\n\n\twhile (match > 0) {\n\t\t__sock_put(sk);\n\t\tmatch--;\n\t}\n\t \n}\n\n#ifdef CONFIG_PROC_FS\nstatic struct sock **pn_res_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tunsigned int i;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn NULL;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (pnres.sk[i] == NULL)\n\t\t\tcontinue;\n\t\tif (!pos)\n\t\t\treturn pnres.sk + i;\n\t\tpos--;\n\t}\n\treturn NULL;\n}\n\nstatic struct sock **pn_res_get_next(struct seq_file *seq, struct sock **sk)\n{\n\tstruct net *net = seq_file_net(seq);\n\tunsigned int i;\n\n\tBUG_ON(!net_eq(net, &init_net));\n\n\tfor (i = (sk - pnres.sk) + 1; i < 256; i++)\n\t\tif (pnres.sk[i])\n\t\t\treturn pnres.sk + i;\n\treturn NULL;\n}\n\nstatic void *pn_res_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(resource_mutex)\n{\n\tmutex_lock(&resource_mutex);\n\treturn *pos ? pn_res_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *pn_res_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock **sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = pn_res_get_idx(seq, 0);\n\telse\n\t\tsk = pn_res_get_next(seq, v);\n\t(*pos)++;\n\treturn sk;\n}\n\nstatic void pn_res_seq_stop(struct seq_file *seq, void *v)\n\t__releases(resource_mutex)\n{\n\tmutex_unlock(&resource_mutex);\n}\n\nstatic int pn_res_seq_show(struct seq_file *seq, void *v)\n{\n\tseq_setwidth(seq, 63);\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"rs   uid inode\");\n\telse {\n\t\tstruct sock **psk = v;\n\t\tstruct sock *sk = *psk;\n\n\t\tseq_printf(seq, \"%02X %5u %lu\",\n\t\t\t   (int) (psk - pnres.sk),\n\t\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sk)),\n\t\t\t   sock_i_ino(sk));\n\t}\n\tseq_pad(seq, '\\n');\n\treturn 0;\n}\n\nconst struct seq_operations pn_res_seq_ops = {\n\t.start = pn_res_seq_start,\n\t.next = pn_res_seq_next,\n\t.stop = pn_res_seq_stop,\n\t.show = pn_res_seq_show,\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}