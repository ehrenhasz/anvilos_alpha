{
  "module_name": "ns.c",
  "hash_id": "e0bc3131a9b257662d5a697f9ed621e02b8a08b683bba6d83e97a20efbc6b7e0",
  "original_prompt": "Ingested from linux-6.6.14/net/qrtr/ns.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/qrtr.h>\n#include <linux/workqueue.h>\n#include <net/sock.h>\n\n#include \"qrtr.h\"\n\n#include <trace/events/sock.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/qrtr.h>\n\nstatic DEFINE_XARRAY(nodes);\n\nstatic struct {\n\tstruct socket *sock;\n\tstruct sockaddr_qrtr bcast_sq;\n\tstruct list_head lookups;\n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct work;\n\tint local_node;\n} qrtr_ns;\n\nstatic const char * const qrtr_ctrl_pkt_strings[] = {\n\t[QRTR_TYPE_HELLO]\t= \"hello\",\n\t[QRTR_TYPE_BYE]\t\t= \"bye\",\n\t[QRTR_TYPE_NEW_SERVER]\t= \"new-server\",\n\t[QRTR_TYPE_DEL_SERVER]\t= \"del-server\",\n\t[QRTR_TYPE_DEL_CLIENT]\t= \"del-client\",\n\t[QRTR_TYPE_RESUME_TX]\t= \"resume-tx\",\n\t[QRTR_TYPE_EXIT]\t= \"exit\",\n\t[QRTR_TYPE_PING]\t= \"ping\",\n\t[QRTR_TYPE_NEW_LOOKUP]\t= \"new-lookup\",\n\t[QRTR_TYPE_DEL_LOOKUP]\t= \"del-lookup\",\n};\n\nstruct qrtr_server_filter {\n\tunsigned int service;\n\tunsigned int instance;\n\tunsigned int ifilter;\n};\n\nstruct qrtr_lookup {\n\tunsigned int service;\n\tunsigned int instance;\n\n\tstruct sockaddr_qrtr sq;\n\tstruct list_head li;\n};\n\nstruct qrtr_server {\n\tunsigned int service;\n\tunsigned int instance;\n\n\tunsigned int node;\n\tunsigned int port;\n\n\tstruct list_head qli;\n};\n\nstruct qrtr_node {\n\tunsigned int id;\n\tstruct xarray servers;\n};\n\nstatic struct qrtr_node *node_get(unsigned int node_id)\n{\n\tstruct qrtr_node *node;\n\n\tnode = xa_load(&nodes, node_id);\n\tif (node)\n\t\treturn node;\n\n\t \n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->id = node_id;\n\txa_init(&node->servers);\n\n\tif (xa_store(&nodes, node_id, node, GFP_KERNEL)) {\n\t\tkfree(node);\n\t\treturn NULL;\n\t}\n\n\treturn node;\n}\n\nstatic int server_match(const struct qrtr_server *srv,\n\t\t\tconst struct qrtr_server_filter *f)\n{\n\tunsigned int ifilter = f->ifilter;\n\n\tif (f->service != 0 && srv->service != f->service)\n\t\treturn 0;\n\tif (!ifilter && f->instance)\n\t\tifilter = ~0;\n\n\treturn (srv->instance & ifilter) == f->instance;\n}\n\nstatic int service_announce_new(struct sockaddr_qrtr *dest,\n\t\t\t\tstruct qrtr_server *srv)\n{\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct msghdr msg = { };\n\tstruct kvec iv;\n\n\ttrace_qrtr_ns_service_announce_new(srv->service, srv->instance,\n\t\t\t\t\t   srv->node, srv->port);\n\n\tiv.iov_base = &pkt;\n\tiv.iov_len = sizeof(pkt);\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_NEW_SERVER);\n\tpkt.server.service = cpu_to_le32(srv->service);\n\tpkt.server.instance = cpu_to_le32(srv->instance);\n\tpkt.server.node = cpu_to_le32(srv->node);\n\tpkt.server.port = cpu_to_le32(srv->port);\n\n\tmsg.msg_name = (struct sockaddr *)dest;\n\tmsg.msg_namelen = sizeof(*dest);\n\n\treturn kernel_sendmsg(qrtr_ns.sock, &msg, &iv, 1, sizeof(pkt));\n}\n\nstatic int service_announce_del(struct sockaddr_qrtr *dest,\n\t\t\t\tstruct qrtr_server *srv)\n{\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct msghdr msg = { };\n\tstruct kvec iv;\n\tint ret;\n\n\ttrace_qrtr_ns_service_announce_del(srv->service, srv->instance,\n\t\t\t\t\t   srv->node, srv->port);\n\n\tiv.iov_base = &pkt;\n\tiv.iov_len = sizeof(pkt);\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_DEL_SERVER);\n\tpkt.server.service = cpu_to_le32(srv->service);\n\tpkt.server.instance = cpu_to_le32(srv->instance);\n\tpkt.server.node = cpu_to_le32(srv->node);\n\tpkt.server.port = cpu_to_le32(srv->port);\n\n\tmsg.msg_name = (struct sockaddr *)dest;\n\tmsg.msg_namelen = sizeof(*dest);\n\n\tret = kernel_sendmsg(qrtr_ns.sock, &msg, &iv, 1, sizeof(pkt));\n\tif (ret < 0)\n\t\tpr_err(\"failed to announce del service\\n\");\n\n\treturn ret;\n}\n\nstatic void lookup_notify(struct sockaddr_qrtr *to, struct qrtr_server *srv,\n\t\t\t  bool new)\n{\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct msghdr msg = { };\n\tstruct kvec iv;\n\tint ret;\n\n\tiv.iov_base = &pkt;\n\tiv.iov_len = sizeof(pkt);\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = new ? cpu_to_le32(QRTR_TYPE_NEW_SERVER) :\n\t\t\tcpu_to_le32(QRTR_TYPE_DEL_SERVER);\n\tif (srv) {\n\t\tpkt.server.service = cpu_to_le32(srv->service);\n\t\tpkt.server.instance = cpu_to_le32(srv->instance);\n\t\tpkt.server.node = cpu_to_le32(srv->node);\n\t\tpkt.server.port = cpu_to_le32(srv->port);\n\t}\n\n\tmsg.msg_name = (struct sockaddr *)to;\n\tmsg.msg_namelen = sizeof(*to);\n\n\tret = kernel_sendmsg(qrtr_ns.sock, &msg, &iv, 1, sizeof(pkt));\n\tif (ret < 0)\n\t\tpr_err(\"failed to send lookup notification\\n\");\n}\n\nstatic int announce_servers(struct sockaddr_qrtr *sq)\n{\n\tstruct qrtr_server *srv;\n\tstruct qrtr_node *node;\n\tunsigned long index;\n\tint ret;\n\n\tnode = node_get(qrtr_ns.local_node);\n\tif (!node)\n\t\treturn 0;\n\n\t \n\txa_for_each(&node->servers, index, srv) {\n\t\tret = service_announce_new(sq, srv);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"failed to announce new service\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct qrtr_server *server_add(unsigned int service,\n\t\t\t\t      unsigned int instance,\n\t\t\t\t      unsigned int node_id,\n\t\t\t\t      unsigned int port)\n{\n\tstruct qrtr_server *srv;\n\tstruct qrtr_server *old;\n\tstruct qrtr_node *node;\n\n\tif (!service || !port)\n\t\treturn NULL;\n\n\tsrv = kzalloc(sizeof(*srv), GFP_KERNEL);\n\tif (!srv)\n\t\treturn NULL;\n\n\tsrv->service = service;\n\tsrv->instance = instance;\n\tsrv->node = node_id;\n\tsrv->port = port;\n\n\tnode = node_get(node_id);\n\tif (!node)\n\t\tgoto err;\n\n\t \n\told = xa_store(&node->servers, port, srv, GFP_KERNEL);\n\tif (old) {\n\t\tif (xa_is_err(old)) {\n\t\t\tpr_err(\"failed to add server [0x%x:0x%x] ret:%d\\n\",\n\t\t\t       srv->service, srv->instance, xa_err(old));\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tkfree(old);\n\t\t}\n\t}\n\n\ttrace_qrtr_ns_server_add(srv->service, srv->instance,\n\t\t\t\t srv->node, srv->port);\n\n\treturn srv;\n\nerr:\n\tkfree(srv);\n\treturn NULL;\n}\n\nstatic int server_del(struct qrtr_node *node, unsigned int port, bool bcast)\n{\n\tstruct qrtr_lookup *lookup;\n\tstruct qrtr_server *srv;\n\tstruct list_head *li;\n\n\tsrv = xa_load(&node->servers, port);\n\tif (!srv)\n\t\treturn -ENOENT;\n\n\txa_erase(&node->servers, port);\n\n\t \n\tif (srv->node == qrtr_ns.local_node && bcast)\n\t\tservice_announce_del(&qrtr_ns.bcast_sq, srv);\n\n\t \n\tlist_for_each(li, &qrtr_ns.lookups) {\n\t\tlookup = container_of(li, struct qrtr_lookup, li);\n\t\tif (lookup->service && lookup->service != srv->service)\n\t\t\tcontinue;\n\t\tif (lookup->instance && lookup->instance != srv->instance)\n\t\t\tcontinue;\n\n\t\tlookup_notify(&lookup->sq, srv, false);\n\t}\n\n\tkfree(srv);\n\n\treturn 0;\n}\n\nstatic int say_hello(struct sockaddr_qrtr *dest)\n{\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct msghdr msg = { };\n\tstruct kvec iv;\n\tint ret;\n\n\tiv.iov_base = &pkt;\n\tiv.iov_len = sizeof(pkt);\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_HELLO);\n\n\tmsg.msg_name = (struct sockaddr *)dest;\n\tmsg.msg_namelen = sizeof(*dest);\n\n\tret = kernel_sendmsg(qrtr_ns.sock, &msg, &iv, 1, sizeof(pkt));\n\tif (ret < 0)\n\t\tpr_err(\"failed to send hello msg\\n\");\n\n\treturn ret;\n}\n\n \nstatic int ctrl_cmd_hello(struct sockaddr_qrtr *sq)\n{\n\tint ret;\n\n\tret = say_hello(sq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn announce_servers(sq);\n}\n\nstatic int ctrl_cmd_bye(struct sockaddr_qrtr *from)\n{\n\tstruct qrtr_node *local_node;\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct qrtr_server *srv;\n\tstruct sockaddr_qrtr sq;\n\tstruct msghdr msg = { };\n\tstruct qrtr_node *node;\n\tunsigned long index;\n\tstruct kvec iv;\n\tint ret;\n\n\tiv.iov_base = &pkt;\n\tiv.iov_len = sizeof(pkt);\n\n\tnode = node_get(from->sq_node);\n\tif (!node)\n\t\treturn 0;\n\n\t \n\txa_for_each(&node->servers, index, srv)\n\t\tserver_del(node, srv->port, true);\n\n\t \n\tlocal_node = node_get(qrtr_ns.local_node);\n\tif (!local_node)\n\t\treturn 0;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_BYE);\n\tpkt.client.node = cpu_to_le32(from->sq_node);\n\n\txa_for_each(&local_node->servers, index, srv) {\n\t\tsq.sq_family = AF_QIPCRTR;\n\t\tsq.sq_node = srv->node;\n\t\tsq.sq_port = srv->port;\n\n\t\tmsg.msg_name = (struct sockaddr *)&sq;\n\t\tmsg.msg_namelen = sizeof(sq);\n\n\t\tret = kernel_sendmsg(qrtr_ns.sock, &msg, &iv, 1, sizeof(pkt));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"failed to send bye cmd\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_cmd_del_client(struct sockaddr_qrtr *from,\n\t\t\t       unsigned int node_id, unsigned int port)\n{\n\tstruct qrtr_node *local_node;\n\tstruct qrtr_lookup *lookup;\n\tstruct qrtr_ctrl_pkt pkt;\n\tstruct msghdr msg = { };\n\tstruct qrtr_server *srv;\n\tstruct sockaddr_qrtr sq;\n\tstruct qrtr_node *node;\n\tstruct list_head *tmp;\n\tstruct list_head *li;\n\tunsigned long index;\n\tstruct kvec iv;\n\tint ret;\n\n\tiv.iov_base = &pkt;\n\tiv.iov_len = sizeof(pkt);\n\n\t \n\tif (from->sq_node != node_id)\n\t\treturn -EINVAL;\n\n\t \n\tif (from->sq_node == qrtr_ns.local_node && from->sq_port != port)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_safe(li, tmp, &qrtr_ns.lookups) {\n\t\tlookup = container_of(li, struct qrtr_lookup, li);\n\t\tif (lookup->sq.sq_node != node_id)\n\t\t\tcontinue;\n\t\tif (lookup->sq.sq_port != port)\n\t\t\tcontinue;\n\n\t\tlist_del(&lookup->li);\n\t\tkfree(lookup);\n\t}\n\n\t \n\tnode = node_get(node_id);\n\tif (node)\n\t\tserver_del(node, port, false);\n\n\t \n\tlocal_node = node_get(qrtr_ns.local_node);\n\tif (!local_node)\n\t\treturn 0;\n\n\tmemset(&pkt, 0, sizeof(pkt));\n\tpkt.cmd = cpu_to_le32(QRTR_TYPE_DEL_CLIENT);\n\tpkt.client.node = cpu_to_le32(node_id);\n\tpkt.client.port = cpu_to_le32(port);\n\n\txa_for_each(&local_node->servers, index, srv) {\n\t\tsq.sq_family = AF_QIPCRTR;\n\t\tsq.sq_node = srv->node;\n\t\tsq.sq_port = srv->port;\n\n\t\tmsg.msg_name = (struct sockaddr *)&sq;\n\t\tmsg.msg_namelen = sizeof(sq);\n\n\t\tret = kernel_sendmsg(qrtr_ns.sock, &msg, &iv, 1, sizeof(pkt));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"failed to send del client cmd\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ctrl_cmd_new_server(struct sockaddr_qrtr *from,\n\t\t\t       unsigned int service, unsigned int instance,\n\t\t\t       unsigned int node_id, unsigned int port)\n{\n\tstruct qrtr_lookup *lookup;\n\tstruct qrtr_server *srv;\n\tstruct list_head *li;\n\tint ret = 0;\n\n\t \n\tif (from->sq_node == qrtr_ns.local_node) {\n\t\tnode_id = from->sq_node;\n\t\tport = from->sq_port;\n\t}\n\n\tsrv = server_add(service, instance, node_id, port);\n\tif (!srv)\n\t\treturn -EINVAL;\n\n\tif (srv->node == qrtr_ns.local_node) {\n\t\tret = service_announce_new(&qrtr_ns.bcast_sq, srv);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"failed to announce new service\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlist_for_each(li, &qrtr_ns.lookups) {\n\t\tlookup = container_of(li, struct qrtr_lookup, li);\n\t\tif (lookup->service && lookup->service != service)\n\t\t\tcontinue;\n\t\tif (lookup->instance && lookup->instance != instance)\n\t\t\tcontinue;\n\n\t\tlookup_notify(&lookup->sq, srv, true);\n\t}\n\n\treturn ret;\n}\n\nstatic int ctrl_cmd_del_server(struct sockaddr_qrtr *from,\n\t\t\t       unsigned int service, unsigned int instance,\n\t\t\t       unsigned int node_id, unsigned int port)\n{\n\tstruct qrtr_node *node;\n\n\t \n\tif (from->sq_node == qrtr_ns.local_node) {\n\t\tnode_id = from->sq_node;\n\t\tport = from->sq_port;\n\t}\n\n\t \n\tif (from->sq_node == qrtr_ns.local_node && from->sq_port != port)\n\t\treturn -EINVAL;\n\n\tnode = node_get(node_id);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tserver_del(node, port, true);\n\n\treturn 0;\n}\n\nstatic int ctrl_cmd_new_lookup(struct sockaddr_qrtr *from,\n\t\t\t       unsigned int service, unsigned int instance)\n{\n\tstruct qrtr_server_filter filter;\n\tstruct qrtr_lookup *lookup;\n\tstruct qrtr_server *srv;\n\tstruct qrtr_node *node;\n\tunsigned long node_idx;\n\tunsigned long srv_idx;\n\n\t \n\tif (from->sq_node != qrtr_ns.local_node)\n\t\treturn -EINVAL;\n\n\tlookup = kzalloc(sizeof(*lookup), GFP_KERNEL);\n\tif (!lookup)\n\t\treturn -ENOMEM;\n\n\tlookup->sq = *from;\n\tlookup->service = service;\n\tlookup->instance = instance;\n\tlist_add_tail(&lookup->li, &qrtr_ns.lookups);\n\n\tmemset(&filter, 0, sizeof(filter));\n\tfilter.service = service;\n\tfilter.instance = instance;\n\n\txa_for_each(&nodes, node_idx, node) {\n\t\txa_for_each(&node->servers, srv_idx, srv) {\n\t\t\tif (!server_match(srv, &filter))\n\t\t\t\tcontinue;\n\n\t\t\tlookup_notify(from, srv, true);\n\t\t}\n\t}\n\n\t \n\tlookup_notify(from, NULL, true);\n\n\treturn 0;\n}\n\nstatic void ctrl_cmd_del_lookup(struct sockaddr_qrtr *from,\n\t\t\t\tunsigned int service, unsigned int instance)\n{\n\tstruct qrtr_lookup *lookup;\n\tstruct list_head *tmp;\n\tstruct list_head *li;\n\n\tlist_for_each_safe(li, tmp, &qrtr_ns.lookups) {\n\t\tlookup = container_of(li, struct qrtr_lookup, li);\n\t\tif (lookup->sq.sq_node != from->sq_node)\n\t\t\tcontinue;\n\t\tif (lookup->sq.sq_port != from->sq_port)\n\t\t\tcontinue;\n\t\tif (lookup->service != service)\n\t\t\tcontinue;\n\t\tif (lookup->instance && lookup->instance != instance)\n\t\t\tcontinue;\n\n\t\tlist_del(&lookup->li);\n\t\tkfree(lookup);\n\t}\n}\n\nstatic void qrtr_ns_worker(struct work_struct *work)\n{\n\tconst struct qrtr_ctrl_pkt *pkt;\n\tsize_t recv_buf_size = 4096;\n\tstruct sockaddr_qrtr sq;\n\tstruct msghdr msg = { };\n\tunsigned int cmd;\n\tssize_t msglen;\n\tvoid *recv_buf;\n\tstruct kvec iv;\n\tint ret;\n\n\tmsg.msg_name = (struct sockaddr *)&sq;\n\tmsg.msg_namelen = sizeof(sq);\n\n\trecv_buf = kzalloc(recv_buf_size, GFP_KERNEL);\n\tif (!recv_buf)\n\t\treturn;\n\n\tfor (;;) {\n\t\tiv.iov_base = recv_buf;\n\t\tiv.iov_len = recv_buf_size;\n\n\t\tmsglen = kernel_recvmsg(qrtr_ns.sock, &msg, &iv, 1,\n\t\t\t\t\tiv.iov_len, MSG_DONTWAIT);\n\n\t\tif (msglen == -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (msglen < 0) {\n\t\t\tpr_err(\"error receiving packet: %zd\\n\", msglen);\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt = recv_buf;\n\t\tcmd = le32_to_cpu(pkt->cmd);\n\t\tif (cmd < ARRAY_SIZE(qrtr_ctrl_pkt_strings) &&\n\t\t    qrtr_ctrl_pkt_strings[cmd])\n\t\t\ttrace_qrtr_ns_message(qrtr_ctrl_pkt_strings[cmd],\n\t\t\t\t\t      sq.sq_node, sq.sq_port);\n\n\t\tret = 0;\n\t\tswitch (cmd) {\n\t\tcase QRTR_TYPE_HELLO:\n\t\t\tret = ctrl_cmd_hello(&sq);\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_BYE:\n\t\t\tret = ctrl_cmd_bye(&sq);\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_DEL_CLIENT:\n\t\t\tret = ctrl_cmd_del_client(&sq,\n\t\t\t\t\tle32_to_cpu(pkt->client.node),\n\t\t\t\t\tle32_to_cpu(pkt->client.port));\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_NEW_SERVER:\n\t\t\tret = ctrl_cmd_new_server(&sq,\n\t\t\t\t\tle32_to_cpu(pkt->server.service),\n\t\t\t\t\tle32_to_cpu(pkt->server.instance),\n\t\t\t\t\tle32_to_cpu(pkt->server.node),\n\t\t\t\t\tle32_to_cpu(pkt->server.port));\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_DEL_SERVER:\n\t\t\tret = ctrl_cmd_del_server(&sq,\n\t\t\t\t\t le32_to_cpu(pkt->server.service),\n\t\t\t\t\t le32_to_cpu(pkt->server.instance),\n\t\t\t\t\t le32_to_cpu(pkt->server.node),\n\t\t\t\t\t le32_to_cpu(pkt->server.port));\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_EXIT:\n\t\tcase QRTR_TYPE_PING:\n\t\tcase QRTR_TYPE_RESUME_TX:\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_NEW_LOOKUP:\n\t\t\tret = ctrl_cmd_new_lookup(&sq,\n\t\t\t\t\t le32_to_cpu(pkt->server.service),\n\t\t\t\t\t le32_to_cpu(pkt->server.instance));\n\t\t\tbreak;\n\t\tcase QRTR_TYPE_DEL_LOOKUP:\n\t\t\tctrl_cmd_del_lookup(&sq,\n\t\t\t\t    le32_to_cpu(pkt->server.service),\n\t\t\t\t    le32_to_cpu(pkt->server.instance));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tpr_err(\"failed while handling packet from %d:%d\",\n\t\t\t       sq.sq_node, sq.sq_port);\n\t}\n\n\tkfree(recv_buf);\n}\n\nstatic void qrtr_ns_data_ready(struct sock *sk)\n{\n\ttrace_sk_data_ready(sk);\n\n\tqueue_work(qrtr_ns.workqueue, &qrtr_ns.work);\n}\n\nint qrtr_ns_init(void)\n{\n\tstruct sockaddr_qrtr sq;\n\tint ret;\n\n\tINIT_LIST_HEAD(&qrtr_ns.lookups);\n\tINIT_WORK(&qrtr_ns.work, qrtr_ns_worker);\n\n\tret = sock_create_kern(&init_net, AF_QIPCRTR, SOCK_DGRAM,\n\t\t\t       PF_QIPCRTR, &qrtr_ns.sock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kernel_getsockname(qrtr_ns.sock, (struct sockaddr *)&sq);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to get socket name\\n\");\n\t\tgoto err_sock;\n\t}\n\n\tqrtr_ns.workqueue = alloc_ordered_workqueue(\"qrtr_ns_handler\", 0);\n\tif (!qrtr_ns.workqueue) {\n\t\tret = -ENOMEM;\n\t\tgoto err_sock;\n\t}\n\n\tqrtr_ns.sock->sk->sk_data_ready = qrtr_ns_data_ready;\n\n\tsq.sq_port = QRTR_PORT_CTRL;\n\tqrtr_ns.local_node = sq.sq_node;\n\n\tret = kernel_bind(qrtr_ns.sock, (struct sockaddr *)&sq, sizeof(sq));\n\tif (ret < 0) {\n\t\tpr_err(\"failed to bind to socket\\n\");\n\t\tgoto err_wq;\n\t}\n\n\tqrtr_ns.bcast_sq.sq_family = AF_QIPCRTR;\n\tqrtr_ns.bcast_sq.sq_node = QRTR_NODE_BCAST;\n\tqrtr_ns.bcast_sq.sq_port = QRTR_PORT_CTRL;\n\n\tret = say_hello(&qrtr_ns.bcast_sq);\n\tif (ret < 0)\n\t\tgoto err_wq;\n\n\treturn 0;\n\nerr_wq:\n\tdestroy_workqueue(qrtr_ns.workqueue);\nerr_sock:\n\tsock_release(qrtr_ns.sock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qrtr_ns_init);\n\nvoid qrtr_ns_remove(void)\n{\n\tcancel_work_sync(&qrtr_ns.work);\n\tdestroy_workqueue(qrtr_ns.workqueue);\n\tsock_release(qrtr_ns.sock);\n}\nEXPORT_SYMBOL_GPL(qrtr_ns_remove);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm IPC Router Nameservice\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}