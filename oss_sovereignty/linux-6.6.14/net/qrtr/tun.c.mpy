{
  "module_name": "tun.c",
  "hash_id": "83e4726cd3c5c90430bb522cd50eab4da0362658fdddcd6e63ead1f9cdbc8f2b",
  "original_prompt": "Ingested from linux-6.6.14/net/qrtr/tun.c",
  "human_readable_source": "\n \n\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n\n#include \"qrtr.h\"\n\nstruct qrtr_tun {\n\tstruct qrtr_endpoint ep;\n\n\tstruct sk_buff_head queue;\n\twait_queue_head_t readq;\n};\n\nstatic int qrtr_tun_send(struct qrtr_endpoint *ep, struct sk_buff *skb)\n{\n\tstruct qrtr_tun *tun = container_of(ep, struct qrtr_tun, ep);\n\n\tskb_queue_tail(&tun->queue, skb);\n\n\t \n\twake_up_interruptible(&tun->readq);\n\n\treturn 0;\n}\n\nstatic int qrtr_tun_open(struct inode *inode, struct file *filp)\n{\n\tstruct qrtr_tun *tun;\n\tint ret;\n\n\ttun = kzalloc(sizeof(*tun), GFP_KERNEL);\n\tif (!tun)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&tun->queue);\n\tinit_waitqueue_head(&tun->readq);\n\n\ttun->ep.xmit = qrtr_tun_send;\n\n\tfilp->private_data = tun;\n\n\tret = qrtr_endpoint_register(&tun->ep, QRTR_EP_NID_AUTO);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tfilp->private_data = NULL;\n\tkfree(tun);\n\treturn ret;\n}\n\nstatic ssize_t qrtr_tun_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tstruct sk_buff *skb;\n\tint count;\n\n\twhile (!(skb = skb_dequeue(&tun->queue))) {\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tif (wait_event_interruptible(tun->readq,\n\t\t\t\t\t     !skb_queue_empty(&tun->queue)))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tcount = min_t(size_t, iov_iter_count(to), skb->len);\n\tif (copy_to_iter(skb->data, count, to) != count)\n\t\tcount = -EFAULT;\n\n\tkfree_skb(skb);\n\n\treturn count;\n}\n\nstatic ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (len > KMALLOC_MAX_SIZE)\n\t\treturn -ENOMEM;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tkfree(kbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}\n\nstatic __poll_t qrtr_tun_poll(struct file *filp, poll_table *wait)\n{\n\tstruct qrtr_tun *tun = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &tun->readq, wait);\n\n\tif (!skb_queue_empty(&tun->queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic int qrtr_tun_release(struct inode *inode, struct file *filp)\n{\n\tstruct qrtr_tun *tun = filp->private_data;\n\n\tqrtr_endpoint_unregister(&tun->ep);\n\n\t \n\tskb_queue_purge(&tun->queue);\n\n\tkfree(tun);\n\n\treturn 0;\n}\n\nstatic const struct file_operations qrtr_tun_ops = {\n\t.owner = THIS_MODULE,\n\t.open = qrtr_tun_open,\n\t.poll = qrtr_tun_poll,\n\t.read_iter = qrtr_tun_read_iter,\n\t.write_iter = qrtr_tun_write_iter,\n\t.release = qrtr_tun_release,\n};\n\nstatic struct miscdevice qrtr_tun_miscdev = {\n\tMISC_DYNAMIC_MINOR,\n\t\"qrtr-tun\",\n\t&qrtr_tun_ops,\n};\n\nstatic int __init qrtr_tun_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&qrtr_tun_miscdev);\n\tif (ret)\n\t\tpr_err(\"failed to register Qualcomm IPC Router tun device\\n\");\n\n\treturn ret;\n}\n\nstatic void __exit qrtr_tun_exit(void)\n{\n\tmisc_deregister(&qrtr_tun_miscdev);\n}\n\nmodule_init(qrtr_tun_init);\nmodule_exit(qrtr_tun_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm IPC Router TUN device\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}