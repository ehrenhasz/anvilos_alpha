{
  "module_name": "mhi.c",
  "hash_id": "c49d89f711969e790ed78206527a527c80365a2d5154a7cc871886b6b076c122",
  "original_prompt": "Ingested from linux-6.6.14/net/qrtr/mhi.c",
  "human_readable_source": "\n \n\n#include <linux/mhi.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n\n#include \"qrtr.h\"\n\nstruct qrtr_mhi_dev {\n\tstruct qrtr_endpoint ep;\n\tstruct mhi_device *mhi_dev;\n\tstruct device *dev;\n};\n\n \nstatic void qcom_mhi_qrtr_dl_callback(struct mhi_device *mhi_dev,\n\t\t\t\t      struct mhi_result *mhi_res)\n{\n\tstruct qrtr_mhi_dev *qdev = dev_get_drvdata(&mhi_dev->dev);\n\tint rc;\n\n\tif (!qdev || mhi_res->transaction_status)\n\t\treturn;\n\n\trc = qrtr_endpoint_post(&qdev->ep, mhi_res->buf_addr,\n\t\t\t\tmhi_res->bytes_xferd);\n\tif (rc == -EINVAL)\n\t\tdev_err(qdev->dev, \"invalid ipcrouter packet\\n\");\n}\n\n \nstatic void qcom_mhi_qrtr_ul_callback(struct mhi_device *mhi_dev,\n\t\t\t\t      struct mhi_result *mhi_res)\n{\n\tstruct sk_buff *skb = mhi_res->buf_addr;\n\n\tif (skb->sk)\n\t\tsock_put(skb->sk);\n\tconsume_skb(skb);\n}\n\n \nstatic int qcom_mhi_qrtr_send(struct qrtr_endpoint *ep, struct sk_buff *skb)\n{\n\tstruct qrtr_mhi_dev *qdev = container_of(ep, struct qrtr_mhi_dev, ep);\n\tint rc;\n\n\tif (skb->sk)\n\t\tsock_hold(skb->sk);\n\n\trc = skb_linearize(skb);\n\tif (rc)\n\t\tgoto free_skb;\n\n\trc = mhi_queue_skb(qdev->mhi_dev, DMA_TO_DEVICE, skb, skb->len,\n\t\t\t   MHI_EOT);\n\tif (rc)\n\t\tgoto free_skb;\n\n\treturn rc;\n\nfree_skb:\n\tif (skb->sk)\n\t\tsock_put(skb->sk);\n\tkfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic int qcom_mhi_qrtr_probe(struct mhi_device *mhi_dev,\n\t\t\t       const struct mhi_device_id *id)\n{\n\tstruct qrtr_mhi_dev *qdev;\n\tint rc;\n\n\tqdev = devm_kzalloc(&mhi_dev->dev, sizeof(*qdev), GFP_KERNEL);\n\tif (!qdev)\n\t\treturn -ENOMEM;\n\n\tqdev->mhi_dev = mhi_dev;\n\tqdev->dev = &mhi_dev->dev;\n\tqdev->ep.xmit = qcom_mhi_qrtr_send;\n\n\tdev_set_drvdata(&mhi_dev->dev, qdev);\n\trc = qrtr_endpoint_register(&qdev->ep, QRTR_EP_NID_AUTO);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = mhi_prepare_for_transfer_autoqueue(mhi_dev);\n\tif (rc) {\n\t\tqrtr_endpoint_unregister(&qdev->ep);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(qdev->dev, \"Qualcomm MHI QRTR driver probed\\n\");\n\n\treturn 0;\n}\n\nstatic void qcom_mhi_qrtr_remove(struct mhi_device *mhi_dev)\n{\n\tstruct qrtr_mhi_dev *qdev = dev_get_drvdata(&mhi_dev->dev);\n\n\tqrtr_endpoint_unregister(&qdev->ep);\n\tmhi_unprepare_from_transfer(mhi_dev);\n\tdev_set_drvdata(&mhi_dev->dev, NULL);\n}\n\nstatic const struct mhi_device_id qcom_mhi_qrtr_id_table[] = {\n\t{ .chan = \"IPCR\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(mhi, qcom_mhi_qrtr_id_table);\n\nstatic struct mhi_driver qcom_mhi_qrtr_driver = {\n\t.probe = qcom_mhi_qrtr_probe,\n\t.remove = qcom_mhi_qrtr_remove,\n\t.dl_xfer_cb = qcom_mhi_qrtr_dl_callback,\n\t.ul_xfer_cb = qcom_mhi_qrtr_ul_callback,\n\t.id_table = qcom_mhi_qrtr_id_table,\n\t.driver = {\n\t\t.name = \"qcom_mhi_qrtr\",\n\t},\n};\n\nmodule_mhi_driver(qcom_mhi_qrtr_driver);\n\nMODULE_AUTHOR(\"Chris Lew <clew@codeaurora.org>\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm IPC-Router MHI interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}