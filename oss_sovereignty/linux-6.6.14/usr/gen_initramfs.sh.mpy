{
  "module_name": "gen_initramfs.sh",
  "hash_id": "a3cf8ccffd72d8087904aece0cde4883c13912a6f4eb958c185fa9eda65bedf0",
  "original_prompt": "Ingested from linux-6.6.14/usr/gen_initramfs.sh",
  "human_readable_source": "#!/bin/sh\n# Copyright (C) Martin Schlemmer <azarah@nosferatu.za.org>\n# Copyright (C) 2006 Sam Ravnborg <sam@ravnborg.org>\n#\n# Released under the terms of the GNU GPL\n#\n# Generate a cpio packed initramfs. It uses gen_init_cpio to generate\n# the cpio archive.\n# This script assumes that gen_init_cpio is located in usr/ directory\n\n# error out on errors\nset -e\n\nusage() {\ncat << EOF\nUsage:\n$0 [-o <file>] [-l <dep_list>] [-u <uid>] [-g <gid>] {-d | <cpio_source>} ...\n\t-o <file>      Create initramfs file named <file> by using gen_init_cpio\n\t-l <dep_list>  Create dependency list named <dep_list>\n\t-u <uid>       User ID to map to user ID 0 (root).\n\t\t       <uid> is only meaningful if <cpio_source> is a\n\t\t       directory.  \"squash\" forces all files to uid 0.\n\t-g <gid>       Group ID to map to group ID 0 (root).\n\t\t       <gid> is only meaningful if <cpio_source> is a\n\t\t       directory.  \"squash\" forces all files to gid 0.\n\t-d <date>      Use date for all file mtime values\n\t<cpio_source>  File list or directory for cpio archive.\n\t\t       If <cpio_source> is a .cpio file it will be used\n\t\t       as direct input to initramfs.\n\nAll options except -o and -l may be repeated and are interpreted\nsequentially and immediately.  -u and -g states are preserved across\n<cpio_source> options so an explicit \"-u 0 -g 0\" is required\nto reset the root/group mapping.\nEOF\n}\n\n# awk style field access\n# $1 - field number; rest is argument string\nfield() {\n\tshift $1 ; echo $1\n}\n\nfiletype() {\n\tlocal argv1=\"$1\"\n\n\t# symlink test must come before file test\n\tif [ -L \"${argv1}\" ]; then\n\t\techo \"slink\"\n\telif [ -f \"${argv1}\" ]; then\n\t\techo \"file\"\n\telif [ -d \"${argv1}\" ]; then\n\t\techo \"dir\"\n\telif [ -b \"${argv1}\" -o -c \"${argv1}\" ]; then\n\t\techo \"nod\"\n\telif [ -p \"${argv1}\" ]; then\n\t\techo \"pipe\"\n\telif [ -S \"${argv1}\" ]; then\n\t\techo \"sock\"\n\telse\n\t\techo \"invalid\"\n\tfi\n\treturn 0\n}\n\nprint_mtime() {\n\tlocal my_mtime=\"0\"\n\n\tif [ -e \"$1\" ]; then\n\t\tmy_mtime=$(find \"$1\" -printf \"%T@\\n\" | sort -r | head -n 1)\n\tfi\n\n\techo \"# Last modified: ${my_mtime}\" >> $cpio_list\n\techo \"\" >> $cpio_list\n}\n\nlist_parse() {\n\tif [ -z \"$dep_list\" -o -L \"$1\" ]; then\n\t\treturn\n\tfi\n\techo \"$1\" | sed 's/:/\\\\:/g; s/$/ \\\\/' >> $dep_list\n}\n\n# for each file print a line in following format\n# <filetype> <name> <path to file> <octal mode> <uid> <gid>\n# for links, devices etc the format differs. See gen_init_cpio for details\nparse() {\n\tlocal location=\"$1\"\n\tlocal name=\"/${location#${srcdir}}\"\n\t# change '//' into '/'\n\tname=$(echo \"$name\" | sed -e 's://*:/:g')\n\tlocal mode=\"$2\"\n\tlocal uid=\"$3\"\n\tlocal gid=\"$4\"\n\tlocal ftype=$(filetype \"${location}\")\n\t# remap uid/gid to 0 if necessary\n\t[ \"$root_uid\" = \"squash\" ] && uid=0 || [ \"$uid\" -eq \"$root_uid\" ] && uid=0\n\t[ \"$root_gid\" = \"squash\" ] && gid=0 || [ \"$gid\" -eq \"$root_gid\" ] && gid=0\n\tlocal str=\"${mode} ${uid} ${gid}\"\n\n\t[ \"${ftype}\" = \"invalid\" ] && return 0\n\t[ \"${location}\" = \"${srcdir}\" ] && return 0\n\n\tcase \"${ftype}\" in\n\t\t\"file\")\n\t\t\tstr=\"${ftype} ${name} ${location} ${str}\"\n\t\t\t;;\n\t\t\"nod\")\n\t\t\tlocal dev=\"`LC_ALL=C ls -l \"${location}\"`\"\n\t\t\tlocal maj=`field 5 ${dev}`\n\t\t\tlocal min=`field 6 ${dev}`\n\t\t\tmaj=${maj%,}\n\n\t\t\t[ -b \"${location}\" ] && dev=\"b\" || dev=\"c\"\n\n\t\t\tstr=\"${ftype} ${name} ${str} ${dev} ${maj} ${min}\"\n\t\t\t;;\n\t\t\"slink\")\n\t\t\tlocal target=`readlink \"${location}\"`\n\t\t\tstr=\"${ftype} ${name} ${target} ${str}\"\n\t\t\t;;\n\t\t*)\n\t\t\tstr=\"${ftype} ${name} ${str}\"\n\t\t\t;;\n\tesac\n\n\techo \"${str}\" >> $cpio_list\n\n\treturn 0\n}\n\nunknown_option() {\n\tprintf \"ERROR: unknown option \\\"$arg\\\"\\n\" >&2\n\tprintf \"If the filename validly begins with '-', \" >&2\n\tprintf \"then it must be prefixed\\n\" >&2\n\tprintf \"by './' so that it won't be interpreted as an option.\" >&2\n\tprintf \"\\n\" >&2\n\tusage >&2\n\texit 1\n}\n\nheader() {\n\tprintf \"\\n#####################\\n# $1\\n\" >> $cpio_list\n}\n\n# process one directory (incl sub-directories)\ndir_filelist() {\n\theader \"$1\"\n\n\tsrcdir=$(echo \"$1\" | sed -e 's://*:/:g')\n\tdirlist=$(find \"${srcdir}\" -printf \"%p %m %U %G\\n\" | LC_ALL=C sort)\n\n\t# If $dirlist is only one line, then the directory is empty\n\tif [  \"$(echo \"${dirlist}\" | wc -l)\" -gt 1 ]; then\n\t\tprint_mtime \"$1\"\n\n\t\techo \"${dirlist}\" | \\\n\t\twhile read x; do\n\t\t\tlist_parse $x\n\t\t\tparse $x\n\t\tdone\n\tfi\n}\n\ninput_file() {\n\tsource=\"$1\"\n\tif [ -f \"$1\" ]; then\n\t\t# If a regular file is specified, assume it is in\n\t\t# gen_init_cpio format\n\t\theader \"$1\"\n\t\tprint_mtime \"$1\" >> $cpio_list\n\t\tcat \"$1\"         >> $cpio_list\n\t\tif [ -n \"$dep_list\" ]; then\n\t\t        echo \"$1 \\\\\"  >> $dep_list\n\t\t\tcat \"$1\" | while read type dir file perm ; do\n\t\t\t\tif [ \"$type\" = \"file\" ]; then\n\t\t\t\t\techo \"$file \\\\\" >> $dep_list\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\telif [ -d \"$1\" ]; then\n\t\t# If a directory is specified then add all files in it to fs\n\t\tdir_filelist \"$1\"\n\telse\n\t\techo \"  ${prog}: Cannot open '$1'\" >&2\n\t\texit 1\n\tfi\n}\n\nprog=$0\nroot_uid=0\nroot_gid=0\ndep_list=\ntimestamp=\ncpio_list=$(mktemp ${TMPDIR:-/tmp}/cpiolist.XXXXXX)\noutput=\"/dev/stdout\"\n\ntrap \"rm -f $cpio_list\" EXIT\n\nwhile [ $# -gt 0 ]; do\n\targ=\"$1\"\n\tshift\n\tcase \"$arg\" in\n\t\t\"-l\")\t# files included in initramfs - used by kbuild\n\t\t\tdep_list=\"$1\"\n\t\t\techo \"deps_initramfs := \\\\\" > $dep_list\n\t\t\tshift\n\t\t\t;;\n\t\t\"-o\")\t# generate cpio image named $1\n\t\t\toutput=\"$1\"\n\t\t\tshift\n\t\t\t;;\n\t\t\"-u\")\t# map $1 to uid=0 (root)\n\t\t\troot_uid=\"$1\"\n\t\t\t[ \"$root_uid\" = \"-1\" ] && root_uid=$(id -u || echo 0)\n\t\t\tshift\n\t\t\t;;\n\t\t\"-g\")\t# map $1 to gid=0 (root)\n\t\t\troot_gid=\"$1\"\n\t\t\t[ \"$root_gid\" = \"-1\" ] && root_gid=$(id -g || echo 0)\n\t\t\tshift\n\t\t\t;;\n\t\t\"-d\")\t# date for file mtimes\n\t\t\ttimestamp=\"$(date -d\"$1\" +%s || :)\"\n\t\t\tif test -n \"$timestamp\"; then\n\t\t\t\ttimestamp=\"-t $timestamp\"\n\t\t\tfi\n\t\t\tshift\n\t\t\t;;\n\t\t\"-h\")\n\t\t\tusage\n\t\t\texit 0\n\t\t\t;;\n\t\t*)\n\t\t\tcase \"$arg\" in\n\t\t\t\t\"-\"*)\n\t\t\t\t\tunknown_option\n\t\t\t\t\t;;\n\t\t\t\t*)\t# input file/dir - process it\n\t\t\t\t\tinput_file \"$arg\"\n\t\t\t\t\t;;\n\t\t\tesac\n\t\t\t;;\n\tesac\ndone\n\n# If output_file is set we will generate cpio archive\n# we are careful to delete tmp files\nusr/gen_init_cpio $timestamp $cpio_list > $output\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}