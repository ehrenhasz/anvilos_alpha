{
  "module_name": "gen_init_cpio.c",
  "hash_id": "d5758e30576fd999cbf8a5e277c5002b57a3afd9db35d796107dc4f9e16286e7",
  "original_prompt": "Ingested from linux-6.6.14/usr/gen_init_cpio.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <limits.h>\n\n \n\n#define xstr(s) #s\n#define str(s) xstr(s)\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nstatic unsigned int offset;\nstatic unsigned int ino = 721;\nstatic time_t default_mtime;\nstatic bool do_csum = false;\n\nstruct file_handler {\n\tconst char *type;\n\tint (*handler)(const char *line);\n};\n\nstatic void push_string(const char *name)\n{\n\tunsigned int name_len = strlen(name) + 1;\n\n\tfputs(name, stdout);\n\tputchar(0);\n\toffset += name_len;\n}\n\nstatic void push_pad (void)\n{\n\twhile (offset & 3) {\n\t\tputchar(0);\n\t\toffset++;\n\t}\n}\n\nstatic void push_rest(const char *name)\n{\n\tunsigned int name_len = strlen(name) + 1;\n\tunsigned int tmp_ofs;\n\n\tfputs(name, stdout);\n\tputchar(0);\n\toffset += name_len;\n\n\ttmp_ofs = name_len + 110;\n\twhile (tmp_ofs & 3) {\n\t\tputchar(0);\n\t\toffset++;\n\t\ttmp_ofs++;\n\t}\n}\n\nstatic void push_hdr(const char *s)\n{\n\tfputs(s, stdout);\n\toffset += 110;\n}\n\nstatic void cpio_trailer(void)\n{\n\tchar s[256];\n\tconst char name[] = \"TRAILER!!!\";\n\n\tsprintf(s, \"%s%08X%08X%08lX%08lX%08X%08lX\"\n\t       \"%08X%08X%08X%08X%08X%08X%08X\",\n\t\tdo_csum ? \"070702\" : \"070701\",  \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t(long) 0,\t\t \n\t\t(long) 0,\t\t \n\t\t1,\t\t\t \n\t\t(long) 0,\t\t \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t(unsigned)strlen(name)+1,  \n\t\t0);\t\t\t \n\tpush_hdr(s);\n\tpush_rest(name);\n\n\twhile (offset % 512) {\n\t\tputchar(0);\n\t\toffset++;\n\t}\n}\n\nstatic int cpio_mkslink(const char *name, const char *target,\n\t\t\t unsigned int mode, uid_t uid, gid_t gid)\n{\n\tchar s[256];\n\n\tif (name[0] == '/')\n\t\tname++;\n\tsprintf(s,\"%s%08X%08X%08lX%08lX%08X%08lX\"\n\t       \"%08X%08X%08X%08X%08X%08X%08X\",\n\t\tdo_csum ? \"070702\" : \"070701\",  \n\t\tino++,\t\t\t \n\t\tS_IFLNK | mode,\t\t \n\t\t(long) uid,\t\t \n\t\t(long) gid,\t\t \n\t\t1,\t\t\t \n\t\t(long) default_mtime,\t \n\t\t(unsigned)strlen(target)+1,  \n\t\t3,\t\t\t \n\t\t1,\t\t\t \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t(unsigned)strlen(name) + 1, \n\t\t0);\t\t\t \n\tpush_hdr(s);\n\tpush_string(name);\n\tpush_pad();\n\tpush_string(target);\n\tpush_pad();\n\treturn 0;\n}\n\nstatic int cpio_mkslink_line(const char *line)\n{\n\tchar name[PATH_MAX + 1];\n\tchar target[PATH_MAX + 1];\n\tunsigned int mode;\n\tint uid;\n\tint gid;\n\tint rc = -1;\n\n\tif (5 != sscanf(line, \"%\" str(PATH_MAX) \"s %\" str(PATH_MAX) \"s %o %d %d\", name, target, &mode, &uid, &gid)) {\n\t\tfprintf(stderr, \"Unrecognized dir format '%s'\", line);\n\t\tgoto fail;\n\t}\n\trc = cpio_mkslink(name, target, mode, uid, gid);\n fail:\n\treturn rc;\n}\n\nstatic int cpio_mkgeneric(const char *name, unsigned int mode,\n\t\t       uid_t uid, gid_t gid)\n{\n\tchar s[256];\n\n\tif (name[0] == '/')\n\t\tname++;\n\tsprintf(s,\"%s%08X%08X%08lX%08lX%08X%08lX\"\n\t       \"%08X%08X%08X%08X%08X%08X%08X\",\n\t\tdo_csum ? \"070702\" : \"070701\",  \n\t\tino++,\t\t\t \n\t\tmode,\t\t\t \n\t\t(long) uid,\t\t \n\t\t(long) gid,\t\t \n\t\t2,\t\t\t \n\t\t(long) default_mtime,\t \n\t\t0,\t\t\t \n\t\t3,\t\t\t \n\t\t1,\t\t\t \n\t\t0,\t\t\t \n\t\t0,\t\t\t \n\t\t(unsigned)strlen(name) + 1, \n\t\t0);\t\t\t \n\tpush_hdr(s);\n\tpush_rest(name);\n\treturn 0;\n}\n\nenum generic_types {\n\tGT_DIR,\n\tGT_PIPE,\n\tGT_SOCK\n};\n\nstruct generic_type {\n\tconst char *type;\n\tmode_t mode;\n};\n\nstatic const struct generic_type generic_type_table[] = {\n\t[GT_DIR] = {\n\t\t.type = \"dir\",\n\t\t.mode = S_IFDIR\n\t},\n\t[GT_PIPE] = {\n\t\t.type = \"pipe\",\n\t\t.mode = S_IFIFO\n\t},\n\t[GT_SOCK] = {\n\t\t.type = \"sock\",\n\t\t.mode = S_IFSOCK\n\t}\n};\n\nstatic int cpio_mkgeneric_line(const char *line, enum generic_types gt)\n{\n\tchar name[PATH_MAX + 1];\n\tunsigned int mode;\n\tint uid;\n\tint gid;\n\tint rc = -1;\n\n\tif (4 != sscanf(line, \"%\" str(PATH_MAX) \"s %o %d %d\", name, &mode, &uid, &gid)) {\n\t\tfprintf(stderr, \"Unrecognized %s format '%s'\",\n\t\t\tline, generic_type_table[gt].type);\n\t\tgoto fail;\n\t}\n\tmode |= generic_type_table[gt].mode;\n\trc = cpio_mkgeneric(name, mode, uid, gid);\n fail:\n\treturn rc;\n}\n\nstatic int cpio_mkdir_line(const char *line)\n{\n\treturn cpio_mkgeneric_line(line, GT_DIR);\n}\n\nstatic int cpio_mkpipe_line(const char *line)\n{\n\treturn cpio_mkgeneric_line(line, GT_PIPE);\n}\n\nstatic int cpio_mksock_line(const char *line)\n{\n\treturn cpio_mkgeneric_line(line, GT_SOCK);\n}\n\nstatic int cpio_mknod(const char *name, unsigned int mode,\n\t\t       uid_t uid, gid_t gid, char dev_type,\n\t\t       unsigned int maj, unsigned int min)\n{\n\tchar s[256];\n\n\tif (dev_type == 'b')\n\t\tmode |= S_IFBLK;\n\telse\n\t\tmode |= S_IFCHR;\n\n\tif (name[0] == '/')\n\t\tname++;\n\tsprintf(s,\"%s%08X%08X%08lX%08lX%08X%08lX\"\n\t       \"%08X%08X%08X%08X%08X%08X%08X\",\n\t\tdo_csum ? \"070702\" : \"070701\",  \n\t\tino++,\t\t\t \n\t\tmode,\t\t\t \n\t\t(long) uid,\t\t \n\t\t(long) gid,\t\t \n\t\t1,\t\t\t \n\t\t(long) default_mtime,\t \n\t\t0,\t\t\t \n\t\t3,\t\t\t \n\t\t1,\t\t\t \n\t\tmaj,\t\t\t \n\t\tmin,\t\t\t \n\t\t(unsigned)strlen(name) + 1, \n\t\t0);\t\t\t \n\tpush_hdr(s);\n\tpush_rest(name);\n\treturn 0;\n}\n\nstatic int cpio_mknod_line(const char *line)\n{\n\tchar name[PATH_MAX + 1];\n\tunsigned int mode;\n\tint uid;\n\tint gid;\n\tchar dev_type;\n\tunsigned int maj;\n\tunsigned int min;\n\tint rc = -1;\n\n\tif (7 != sscanf(line, \"%\" str(PATH_MAX) \"s %o %d %d %c %u %u\",\n\t\t\t name, &mode, &uid, &gid, &dev_type, &maj, &min)) {\n\t\tfprintf(stderr, \"Unrecognized nod format '%s'\", line);\n\t\tgoto fail;\n\t}\n\trc = cpio_mknod(name, mode, uid, gid, dev_type, maj, min);\n fail:\n\treturn rc;\n}\n\nstatic int cpio_mkfile_csum(int fd, unsigned long size, uint32_t *csum)\n{\n\twhile (size) {\n\t\tunsigned char filebuf[65536];\n\t\tssize_t this_read;\n\t\tsize_t i, this_size = MIN(size, sizeof(filebuf));\n\n\t\tthis_read = read(fd, filebuf, this_size);\n\t\tif (this_read <= 0 || this_read > this_size)\n\t\t\treturn -1;\n\n\t\tfor (i = 0; i < this_read; i++)\n\t\t\t*csum += filebuf[i];\n\n\t\tsize -= this_read;\n\t}\n\t \n\tif (lseek(fd, 0, SEEK_SET) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int cpio_mkfile(const char *name, const char *location,\n\t\t\tunsigned int mode, uid_t uid, gid_t gid,\n\t\t\tunsigned int nlinks)\n{\n\tchar s[256];\n\tstruct stat buf;\n\tunsigned long size;\n\tint file;\n\tint retval;\n\tint rc = -1;\n\tint namesize;\n\tunsigned int i;\n\tuint32_t csum = 0;\n\n\tmode |= S_IFREG;\n\n\tfile = open (location, O_RDONLY);\n\tif (file < 0) {\n\t\tfprintf (stderr, \"File %s could not be opened for reading\\n\", location);\n\t\tgoto error;\n\t}\n\n\tretval = fstat(file, &buf);\n\tif (retval) {\n\t\tfprintf(stderr, \"File %s could not be stat()'ed\\n\", location);\n\t\tgoto error;\n\t}\n\n\tif (buf.st_mtime > 0xffffffff) {\n\t\tfprintf(stderr, \"%s: Timestamp exceeds maximum cpio timestamp, clipping.\\n\",\n\t\t\tlocation);\n\t\tbuf.st_mtime = 0xffffffff;\n\t}\n\n\tif (buf.st_mtime < 0) {\n\t\tfprintf(stderr, \"%s: Timestamp negative, clipping.\\n\",\n\t\t\tlocation);\n\t\tbuf.st_mtime = 0;\n\t}\n\n\tif (buf.st_size > 0xffffffff) {\n\t\tfprintf(stderr, \"%s: Size exceeds maximum cpio file size\\n\",\n\t\t\tlocation);\n\t\tgoto error;\n\t}\n\n\tif (do_csum && cpio_mkfile_csum(file, buf.st_size, &csum) < 0) {\n\t\tfprintf(stderr, \"Failed to checksum file %s\\n\", location);\n\t\tgoto error;\n\t}\n\n\tsize = 0;\n\tfor (i = 1; i <= nlinks; i++) {\n\t\t \n\t\tif (i == nlinks)\n\t\t\tsize = buf.st_size;\n\n\t\tif (name[0] == '/')\n\t\t\tname++;\n\t\tnamesize = strlen(name) + 1;\n\t\tsprintf(s,\"%s%08X%08X%08lX%08lX%08X%08lX\"\n\t\t       \"%08lX%08X%08X%08X%08X%08X%08X\",\n\t\t\tdo_csum ? \"070702\" : \"070701\",  \n\t\t\tino,\t\t\t \n\t\t\tmode,\t\t\t \n\t\t\t(long) uid,\t\t \n\t\t\t(long) gid,\t\t \n\t\t\tnlinks,\t\t\t \n\t\t\t(long) buf.st_mtime,\t \n\t\t\tsize,\t\t\t \n\t\t\t3,\t\t\t \n\t\t\t1,\t\t\t \n\t\t\t0,\t\t\t \n\t\t\t0,\t\t\t \n\t\t\tnamesize,\t\t \n\t\t\tsize ? csum : 0);\t \n\t\tpush_hdr(s);\n\t\tpush_string(name);\n\t\tpush_pad();\n\n\t\twhile (size) {\n\t\t\tunsigned char filebuf[65536];\n\t\t\tssize_t this_read;\n\t\t\tsize_t this_size = MIN(size, sizeof(filebuf));\n\n\t\t\tthis_read = read(file, filebuf, this_size);\n\t\t\tif (this_read <= 0 || this_read > this_size) {\n\t\t\t\tfprintf(stderr, \"Can not read %s file\\n\", location);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (fwrite(filebuf, this_read, 1, stdout) != 1) {\n\t\t\t\tfprintf(stderr, \"writing filebuf failed\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\toffset += this_read;\n\t\t\tsize -= this_read;\n\t\t}\n\t\tpush_pad();\n\n\t\tname += namesize;\n\t}\n\tino++;\n\trc = 0;\n\nerror:\n\tif (file >= 0)\n\t\tclose(file);\n\treturn rc;\n}\n\nstatic char *cpio_replace_env(char *new_location)\n{\n\tchar expanded[PATH_MAX + 1];\n\tchar *start, *end, *var;\n\n\twhile ((start = strstr(new_location, \"${\")) &&\n\t       (end = strchr(start + 2, '}'))) {\n\t\t*start = *end = 0;\n\t\tvar = getenv(start + 2);\n\t\tsnprintf(expanded, sizeof expanded, \"%s%s%s\",\n\t\t\t new_location, var ? var : \"\", end + 1);\n\t\tstrcpy(new_location, expanded);\n\t}\n\n\treturn new_location;\n}\n\nstatic int cpio_mkfile_line(const char *line)\n{\n\tchar name[PATH_MAX + 1];\n\tchar *dname = NULL;  \n\tchar location[PATH_MAX + 1];\n\tunsigned int mode;\n\tint uid;\n\tint gid;\n\tint nlinks = 1;\n\tint end = 0, dname_len = 0;\n\tint rc = -1;\n\n\tif (5 > sscanf(line, \"%\" str(PATH_MAX) \"s %\" str(PATH_MAX)\n\t\t\t\t\"s %o %d %d %n\",\n\t\t\t\tname, location, &mode, &uid, &gid, &end)) {\n\t\tfprintf(stderr, \"Unrecognized file format '%s'\", line);\n\t\tgoto fail;\n\t}\n\tif (end && isgraph(line[end])) {\n\t\tint len;\n\t\tint nend;\n\n\t\tdname = malloc(strlen(line));\n\t\tif (!dname) {\n\t\t\tfprintf (stderr, \"out of memory (%d)\\n\", dname_len);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdname_len = strlen(name) + 1;\n\t\tmemcpy(dname, name, dname_len);\n\n\t\tdo {\n\t\t\tnend = 0;\n\t\t\tif (sscanf(line + end, \"%\" str(PATH_MAX) \"s %n\",\n\t\t\t\t\tname, &nend) < 1)\n\t\t\t\tbreak;\n\t\t\tlen = strlen(name) + 1;\n\t\t\tmemcpy(dname + dname_len, name, len);\n\t\t\tdname_len += len;\n\t\t\tnlinks++;\n\t\t\tend += nend;\n\t\t} while (isgraph(line[end]));\n\t} else {\n\t\tdname = name;\n\t}\n\trc = cpio_mkfile(dname, cpio_replace_env(location),\n\t                 mode, uid, gid, nlinks);\n fail:\n\tif (dname_len) free(dname);\n\treturn rc;\n}\n\nstatic void usage(const char *prog)\n{\n\tfprintf(stderr, \"Usage:\\n\"\n\t\t\"\\t%s [-t <timestamp>] [-c] <cpio_list>\\n\"\n\t\t\"\\n\"\n\t\t\"<cpio_list> is a file containing newline separated entries that\\n\"\n\t\t\"describe the files to be included in the initramfs archive:\\n\"\n\t\t\"\\n\"\n\t\t\"# a comment\\n\"\n\t\t\"file <name> <location> <mode> <uid> <gid> [<hard links>]\\n\"\n\t\t\"dir <name> <mode> <uid> <gid>\\n\"\n\t\t\"nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>\\n\"\n\t\t\"slink <name> <target> <mode> <uid> <gid>\\n\"\n\t\t\"pipe <name> <mode> <uid> <gid>\\n\"\n\t\t\"sock <name> <mode> <uid> <gid>\\n\"\n\t\t\"\\n\"\n\t\t\"<name>       name of the file/dir/nod/etc in the archive\\n\"\n\t\t\"<location>   location of the file in the current filesystem\\n\"\n\t\t\"             expands shell variables quoted with ${}\\n\"\n\t\t\"<target>     link target\\n\"\n\t\t\"<mode>       mode/permissions of the file\\n\"\n\t\t\"<uid>        user id (0=root)\\n\"\n\t\t\"<gid>        group id (0=root)\\n\"\n\t\t\"<dev_type>   device type (b=block, c=character)\\n\"\n\t\t\"<maj>        major number of nod\\n\"\n\t\t\"<min>        minor number of nod\\n\"\n\t\t\"<hard links> space separated list of other links to file\\n\"\n\t\t\"\\n\"\n\t\t\"example:\\n\"\n\t\t\"# A simple initramfs\\n\"\n\t\t\"dir /dev 0755 0 0\\n\"\n\t\t\"nod /dev/console 0600 0 0 c 5 1\\n\"\n\t\t\"dir /root 0700 0 0\\n\"\n\t\t\"dir /sbin 0755 0 0\\n\"\n\t\t\"file /sbin/kinit /usr/src/klibc/kinit/kinit 0755 0 0\\n\"\n\t\t\"\\n\"\n\t\t\"<timestamp> is time in seconds since Epoch that will be used\\n\"\n\t\t\"as mtime for symlinks, special files and directories. The default\\n\"\n\t\t\"is to use the current time for these entries.\\n\"\n\t\t\"-c: calculate and store 32-bit checksums for file data.\\n\",\n\t\tprog);\n}\n\nstatic const struct file_handler file_handler_table[] = {\n\t{\n\t\t.type    = \"file\",\n\t\t.handler = cpio_mkfile_line,\n\t}, {\n\t\t.type    = \"nod\",\n\t\t.handler = cpio_mknod_line,\n\t}, {\n\t\t.type    = \"dir\",\n\t\t.handler = cpio_mkdir_line,\n\t}, {\n\t\t.type    = \"slink\",\n\t\t.handler = cpio_mkslink_line,\n\t}, {\n\t\t.type    = \"pipe\",\n\t\t.handler = cpio_mkpipe_line,\n\t}, {\n\t\t.type    = \"sock\",\n\t\t.handler = cpio_mksock_line,\n\t}, {\n\t\t.type    = NULL,\n\t\t.handler = NULL,\n\t}\n};\n\n#define LINE_SIZE (2 * PATH_MAX + 50)\n\nint main (int argc, char *argv[])\n{\n\tFILE *cpio_list;\n\tchar line[LINE_SIZE];\n\tchar *args, *type;\n\tint ec = 0;\n\tint line_nr = 0;\n\tconst char *filename;\n\n\tdefault_mtime = time(NULL);\n\twhile (1) {\n\t\tint opt = getopt(argc, argv, \"t:ch\");\n\t\tchar *invalid;\n\n\t\tif (opt == -1)\n\t\t\tbreak;\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\tdefault_mtime = strtol(optarg, &invalid, 10);\n\t\t\tif (!*optarg || *invalid) {\n\t\t\t\tfprintf(stderr, \"Invalid timestamp: %s\\n\",\n\t\t\t\t\t\toptarg);\n\t\t\t\tusage(argv[0]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tdo_csum = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase '?':\n\t\t\tusage(argv[0]);\n\t\t\texit(opt == 'h' ? 0 : 1);\n\t\t}\n\t}\n\n\t \n\tif (default_mtime > 0xffffffff || default_mtime < 0) {\n\t\tfprintf(stderr, \"ERROR: Timestamp out of range for cpio format\\n\");\n\t\texit(1);\n\t}\n\n\tif (argc - optind != 1) {\n\t\tusage(argv[0]);\n\t\texit(1);\n\t}\n\tfilename = argv[optind];\n\tif (!strcmp(filename, \"-\"))\n\t\tcpio_list = stdin;\n\telse if (!(cpio_list = fopen(filename, \"r\"))) {\n\t\tfprintf(stderr, \"ERROR: unable to open '%s': %s\\n\\n\",\n\t\t\tfilename, strerror(errno));\n\t\tusage(argv[0]);\n\t\texit(1);\n\t}\n\n\twhile (fgets(line, LINE_SIZE, cpio_list)) {\n\t\tint type_idx;\n\t\tsize_t slen = strlen(line);\n\n\t\tline_nr++;\n\n\t\tif ('#' == *line) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (! (type = strtok(line, \" \\t\"))) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"ERROR: incorrect format, could not locate file type line %d: '%s'\\n\",\n\t\t\t\tline_nr, line);\n\t\t\tec = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ('\\n' == *type) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (slen == strlen(type)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (! (args = strtok(NULL, \"\\n\"))) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"ERROR: incorrect format, newline required line %d: '%s'\\n\",\n\t\t\t\tline_nr, line);\n\t\t\tec = -1;\n\t\t}\n\n\t\tfor (type_idx = 0; file_handler_table[type_idx].type; type_idx++) {\n\t\t\tint rc;\n\t\t\tif (! strcmp(line, file_handler_table[type_idx].type)) {\n\t\t\t\tif ((rc = file_handler_table[type_idx].handler(args))) {\n\t\t\t\t\tec = rc;\n\t\t\t\t\tfprintf(stderr, \" line %d\\n\", line_nr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (NULL == file_handler_table[type_idx].type) {\n\t\t\tfprintf(stderr, \"unknown file type line %d: '%s'\\n\",\n\t\t\t\tline_nr, line);\n\t\t}\n\t}\n\tif (ec == 0)\n\t\tcpio_trailer();\n\n\texit(ec);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}