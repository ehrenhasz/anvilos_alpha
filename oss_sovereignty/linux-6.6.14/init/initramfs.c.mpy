{
  "module_name": "initramfs.c",
  "hash_id": "6ab17589840819e8f7ea1e7162f394385adaf25f3abb4382abf34824eee19801",
  "original_prompt": "Ingested from linux-6.6.14/init/initramfs.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/async.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/dirent.h>\n#include <linux/syscalls.h>\n#include <linux/utime.h>\n#include <linux/file.h>\n#include <linux/kstrtox.h>\n#include <linux/memblock.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/init_syscalls.h>\n#include <linux/task_work.h>\n#include <linux/umh.h>\n\nstatic __initdata bool csum_present;\nstatic __initdata u32 io_csum;\n\nstatic ssize_t __init xwrite(struct file *file, const unsigned char *p,\n\t\tsize_t count, loff_t *pos)\n{\n\tssize_t out = 0;\n\n\t \n\twhile (count) {\n\t\tssize_t rv = kernel_write(file, p, count, pos);\n\n\t\tif (rv < 0) {\n\t\t\tif (rv == -EINTR || rv == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\treturn out ? out : rv;\n\t\t} else if (rv == 0)\n\t\t\tbreak;\n\n\t\tif (csum_present) {\n\t\t\tssize_t i;\n\n\t\t\tfor (i = 0; i < rv; i++)\n\t\t\t\tio_csum += p[i];\n\t\t}\n\n\t\tp += rv;\n\t\tout += rv;\n\t\tcount -= rv;\n\t}\n\n\treturn out;\n}\n\nstatic __initdata char *message;\nstatic void __init error(char *x)\n{\n\tif (!message)\n\t\tmessage = x;\n}\n\n#define panic_show_mem(fmt, ...) \\\n\t({ show_mem(); panic(fmt, ##__VA_ARGS__); })\n\n \n\n#define N_ALIGN(len) ((((len) + 1) & ~3) + 2)\n\nstatic __initdata struct hash {\n\tint ino, minor, major;\n\tumode_t mode;\n\tstruct hash *next;\n\tchar name[N_ALIGN(PATH_MAX)];\n} *head[32];\n\nstatic inline int hash(int major, int minor, int ino)\n{\n\tunsigned long tmp = ino + minor + (major << 3);\n\ttmp += tmp >> 5;\n\treturn tmp & 31;\n}\n\nstatic char __init *find_link(int major, int minor, int ino,\n\t\t\t      umode_t mode, char *name)\n{\n\tstruct hash **p, *q;\n\tfor (p = head + hash(major, minor, ino); *p; p = &(*p)->next) {\n\t\tif ((*p)->ino != ino)\n\t\t\tcontinue;\n\t\tif ((*p)->minor != minor)\n\t\t\tcontinue;\n\t\tif ((*p)->major != major)\n\t\t\tcontinue;\n\t\tif (((*p)->mode ^ mode) & S_IFMT)\n\t\t\tcontinue;\n\t\treturn (*p)->name;\n\t}\n\tq = kmalloc(sizeof(struct hash), GFP_KERNEL);\n\tif (!q)\n\t\tpanic_show_mem(\"can't allocate link hash entry\");\n\tq->major = major;\n\tq->minor = minor;\n\tq->ino = ino;\n\tq->mode = mode;\n\tstrcpy(q->name, name);\n\tq->next = NULL;\n\t*p = q;\n\treturn NULL;\n}\n\nstatic void __init free_hash(void)\n{\n\tstruct hash **p, *q;\n\tfor (p = head; p < head + 32; p++) {\n\t\twhile (*p) {\n\t\t\tq = *p;\n\t\t\t*p = q->next;\n\t\t\tkfree(q);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_INITRAMFS_PRESERVE_MTIME\nstatic void __init do_utime(char *filename, time64_t mtime)\n{\n\tstruct timespec64 t[2] = { { .tv_sec = mtime }, { .tv_sec = mtime } };\n\tinit_utimes(filename, t);\n}\n\nstatic void __init do_utime_path(const struct path *path, time64_t mtime)\n{\n\tstruct timespec64 t[2] = { { .tv_sec = mtime }, { .tv_sec = mtime } };\n\tvfs_utimes(path, t);\n}\n\nstatic __initdata LIST_HEAD(dir_list);\nstruct dir_entry {\n\tstruct list_head list;\n\ttime64_t mtime;\n\tchar name[];\n};\n\nstatic void __init dir_add(const char *name, time64_t mtime)\n{\n\tsize_t nlen = strlen(name) + 1;\n\tstruct dir_entry *de;\n\n\tde = kmalloc(sizeof(struct dir_entry) + nlen, GFP_KERNEL);\n\tif (!de)\n\t\tpanic_show_mem(\"can't allocate dir_entry buffer\");\n\tINIT_LIST_HEAD(&de->list);\n\tstrscpy(de->name, name, nlen);\n\tde->mtime = mtime;\n\tlist_add(&de->list, &dir_list);\n}\n\nstatic void __init dir_utime(void)\n{\n\tstruct dir_entry *de, *tmp;\n\tlist_for_each_entry_safe(de, tmp, &dir_list, list) {\n\t\tlist_del(&de->list);\n\t\tdo_utime(de->name, de->mtime);\n\t\tkfree(de);\n\t}\n}\n#else\nstatic void __init do_utime(char *filename, time64_t mtime) {}\nstatic void __init do_utime_path(const struct path *path, time64_t mtime) {}\nstatic void __init dir_add(const char *name, time64_t mtime) {}\nstatic void __init dir_utime(void) {}\n#endif\n\nstatic __initdata time64_t mtime;\n\n \n\nstatic __initdata unsigned long ino, major, minor, nlink;\nstatic __initdata umode_t mode;\nstatic __initdata unsigned long body_len, name_len;\nstatic __initdata uid_t uid;\nstatic __initdata gid_t gid;\nstatic __initdata unsigned rdev;\nstatic __initdata u32 hdr_csum;\n\nstatic void __init parse_header(char *s)\n{\n\tunsigned long parsed[13];\n\tchar buf[9];\n\tint i;\n\n\tbuf[8] = '\\0';\n\tfor (i = 0, s += 6; i < 13; i++, s += 8) {\n\t\tmemcpy(buf, s, 8);\n\t\tparsed[i] = simple_strtoul(buf, NULL, 16);\n\t}\n\tino = parsed[0];\n\tmode = parsed[1];\n\tuid = parsed[2];\n\tgid = parsed[3];\n\tnlink = parsed[4];\n\tmtime = parsed[5];  \n\tbody_len = parsed[6];\n\tmajor = parsed[7];\n\tminor = parsed[8];\n\trdev = new_encode_dev(MKDEV(parsed[9], parsed[10]));\n\tname_len = parsed[11];\n\thdr_csum = parsed[12];\n}\n\n \n\nstatic __initdata enum state {\n\tStart,\n\tCollect,\n\tGotHeader,\n\tSkipIt,\n\tGotName,\n\tCopyFile,\n\tGotSymlink,\n\tReset\n} state, next_state;\n\nstatic __initdata char *victim;\nstatic unsigned long byte_count __initdata;\nstatic __initdata loff_t this_header, next_header;\n\nstatic inline void __init eat(unsigned n)\n{\n\tvictim += n;\n\tthis_header += n;\n\tbyte_count -= n;\n}\n\nstatic __initdata char *collected;\nstatic long remains __initdata;\nstatic __initdata char *collect;\n\nstatic void __init read_into(char *buf, unsigned size, enum state next)\n{\n\tif (byte_count >= size) {\n\t\tcollected = victim;\n\t\teat(size);\n\t\tstate = next;\n\t} else {\n\t\tcollect = collected = buf;\n\t\tremains = size;\n\t\tnext_state = next;\n\t\tstate = Collect;\n\t}\n}\n\nstatic __initdata char *header_buf, *symlink_buf, *name_buf;\n\nstatic int __init do_start(void)\n{\n\tread_into(header_buf, 110, GotHeader);\n\treturn 0;\n}\n\nstatic int __init do_collect(void)\n{\n\tunsigned long n = remains;\n\tif (byte_count < n)\n\t\tn = byte_count;\n\tmemcpy(collect, victim, n);\n\teat(n);\n\tcollect += n;\n\tif ((remains -= n) != 0)\n\t\treturn 1;\n\tstate = next_state;\n\treturn 0;\n}\n\nstatic int __init do_header(void)\n{\n\tif (!memcmp(collected, \"070701\", 6)) {\n\t\tcsum_present = false;\n\t} else if (!memcmp(collected, \"070702\", 6)) {\n\t\tcsum_present = true;\n\t} else {\n\t\tif (memcmp(collected, \"070707\", 6) == 0)\n\t\t\terror(\"incorrect cpio method used: use -H newc option\");\n\t\telse\n\t\t\terror(\"no cpio magic\");\n\t\treturn 1;\n\t}\n\tparse_header(collected);\n\tnext_header = this_header + N_ALIGN(name_len) + body_len;\n\tnext_header = (next_header + 3) & ~3;\n\tstate = SkipIt;\n\tif (name_len <= 0 || name_len > PATH_MAX)\n\t\treturn 0;\n\tif (S_ISLNK(mode)) {\n\t\tif (body_len > PATH_MAX)\n\t\t\treturn 0;\n\t\tcollect = collected = symlink_buf;\n\t\tremains = N_ALIGN(name_len) + body_len;\n\t\tnext_state = GotSymlink;\n\t\tstate = Collect;\n\t\treturn 0;\n\t}\n\tif (S_ISREG(mode) || !body_len)\n\t\tread_into(name_buf, N_ALIGN(name_len), GotName);\n\treturn 0;\n}\n\nstatic int __init do_skip(void)\n{\n\tif (this_header + byte_count < next_header) {\n\t\teat(byte_count);\n\t\treturn 1;\n\t} else {\n\t\teat(next_header - this_header);\n\t\tstate = next_state;\n\t\treturn 0;\n\t}\n}\n\nstatic int __init do_reset(void)\n{\n\twhile (byte_count && *victim == '\\0')\n\t\teat(1);\n\tif (byte_count && (this_header & 3))\n\t\terror(\"broken padding\");\n\treturn 1;\n}\n\nstatic void __init clean_path(char *path, umode_t fmode)\n{\n\tstruct kstat st;\n\n\tif (!init_stat(path, &st, AT_SYMLINK_NOFOLLOW) &&\n\t    (st.mode ^ fmode) & S_IFMT) {\n\t\tif (S_ISDIR(st.mode))\n\t\t\tinit_rmdir(path);\n\t\telse\n\t\t\tinit_unlink(path);\n\t}\n}\n\nstatic int __init maybe_link(void)\n{\n\tif (nlink >= 2) {\n\t\tchar *old = find_link(major, minor, ino, mode, collected);\n\t\tif (old) {\n\t\t\tclean_path(collected, 0);\n\t\t\treturn (init_link(old, collected) < 0) ? -1 : 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic __initdata struct file *wfile;\nstatic __initdata loff_t wfile_pos;\n\nstatic int __init do_name(void)\n{\n\tstate = SkipIt;\n\tnext_state = Reset;\n\tif (strcmp(collected, \"TRAILER!!!\") == 0) {\n\t\tfree_hash();\n\t\treturn 0;\n\t}\n\tclean_path(collected, mode);\n\tif (S_ISREG(mode)) {\n\t\tint ml = maybe_link();\n\t\tif (ml >= 0) {\n\t\t\tint openflags = O_WRONLY|O_CREAT;\n\t\t\tif (ml != 1)\n\t\t\t\topenflags |= O_TRUNC;\n\t\t\twfile = filp_open(collected, openflags, mode);\n\t\t\tif (IS_ERR(wfile))\n\t\t\t\treturn 0;\n\t\t\twfile_pos = 0;\n\t\t\tio_csum = 0;\n\n\t\t\tvfs_fchown(wfile, uid, gid);\n\t\t\tvfs_fchmod(wfile, mode);\n\t\t\tif (body_len)\n\t\t\t\tvfs_truncate(&wfile->f_path, body_len);\n\t\t\tstate = CopyFile;\n\t\t}\n\t} else if (S_ISDIR(mode)) {\n\t\tinit_mkdir(collected, mode);\n\t\tinit_chown(collected, uid, gid, 0);\n\t\tinit_chmod(collected, mode);\n\t\tdir_add(collected, mtime);\n\t} else if (S_ISBLK(mode) || S_ISCHR(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tif (maybe_link() == 0) {\n\t\t\tinit_mknod(collected, mode, rdev);\n\t\t\tinit_chown(collected, uid, gid, 0);\n\t\t\tinit_chmod(collected, mode);\n\t\t\tdo_utime(collected, mtime);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __init do_copy(void)\n{\n\tif (byte_count >= body_len) {\n\t\tif (xwrite(wfile, victim, body_len, &wfile_pos) != body_len)\n\t\t\terror(\"write error\");\n\n\t\tdo_utime_path(&wfile->f_path, mtime);\n\t\tfput(wfile);\n\t\tif (csum_present && io_csum != hdr_csum)\n\t\t\terror(\"bad data checksum\");\n\t\teat(body_len);\n\t\tstate = SkipIt;\n\t\treturn 0;\n\t} else {\n\t\tif (xwrite(wfile, victim, byte_count, &wfile_pos) != byte_count)\n\t\t\terror(\"write error\");\n\t\tbody_len -= byte_count;\n\t\teat(byte_count);\n\t\treturn 1;\n\t}\n}\n\nstatic int __init do_symlink(void)\n{\n\tcollected[N_ALIGN(name_len) + body_len] = '\\0';\n\tclean_path(collected, 0);\n\tinit_symlink(collected + N_ALIGN(name_len), collected);\n\tinit_chown(collected, uid, gid, AT_SYMLINK_NOFOLLOW);\n\tdo_utime(collected, mtime);\n\tstate = SkipIt;\n\tnext_state = Reset;\n\treturn 0;\n}\n\nstatic __initdata int (*actions[])(void) = {\n\t[Start]\t\t= do_start,\n\t[Collect]\t= do_collect,\n\t[GotHeader]\t= do_header,\n\t[SkipIt]\t= do_skip,\n\t[GotName]\t= do_name,\n\t[CopyFile]\t= do_copy,\n\t[GotSymlink]\t= do_symlink,\n\t[Reset]\t\t= do_reset,\n};\n\nstatic long __init write_buffer(char *buf, unsigned long len)\n{\n\tbyte_count = len;\n\tvictim = buf;\n\n\twhile (!actions[state]())\n\t\t;\n\treturn len - byte_count;\n}\n\nstatic long __init flush_buffer(void *bufv, unsigned long len)\n{\n\tchar *buf = bufv;\n\tlong written;\n\tlong origLen = len;\n\tif (message)\n\t\treturn -1;\n\twhile ((written = write_buffer(buf, len)) < len && !message) {\n\t\tchar c = buf[written];\n\t\tif (c == '0') {\n\t\t\tbuf += written;\n\t\t\tlen -= written;\n\t\t\tstate = Start;\n\t\t} else if (c == 0) {\n\t\t\tbuf += written;\n\t\t\tlen -= written;\n\t\t\tstate = Reset;\n\t\t} else\n\t\t\terror(\"junk within compressed archive\");\n\t}\n\treturn origLen;\n}\n\nstatic unsigned long my_inptr __initdata;  \n\n#include <linux/decompress/generic.h>\n\nstatic char * __init unpack_to_rootfs(char *buf, unsigned long len)\n{\n\tlong written;\n\tdecompress_fn decompress;\n\tconst char *compress_name;\n\tstatic __initdata char msg_buf[64];\n\n\theader_buf = kmalloc(110, GFP_KERNEL);\n\tsymlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);\n\tname_buf = kmalloc(N_ALIGN(PATH_MAX), GFP_KERNEL);\n\n\tif (!header_buf || !symlink_buf || !name_buf)\n\t\tpanic_show_mem(\"can't allocate buffers\");\n\n\tstate = Start;\n\tthis_header = 0;\n\tmessage = NULL;\n\twhile (!message && len) {\n\t\tloff_t saved_offset = this_header;\n\t\tif (*buf == '0' && !(this_header & 3)) {\n\t\t\tstate = Start;\n\t\t\twritten = write_buffer(buf, len);\n\t\t\tbuf += written;\n\t\t\tlen -= written;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!*buf) {\n\t\t\tbuf++;\n\t\t\tlen--;\n\t\t\tthis_header++;\n\t\t\tcontinue;\n\t\t}\n\t\tthis_header = 0;\n\t\tdecompress = decompress_method(buf, len, &compress_name);\n\t\tpr_debug(\"Detected %s compressed data\\n\", compress_name);\n\t\tif (decompress) {\n\t\t\tint res = decompress(buf, len, NULL, flush_buffer, NULL,\n\t\t\t\t   &my_inptr, error);\n\t\t\tif (res)\n\t\t\t\terror(\"decompressor failed\");\n\t\t} else if (compress_name) {\n\t\t\tif (!message) {\n\t\t\t\tsnprintf(msg_buf, sizeof msg_buf,\n\t\t\t\t\t \"compression method %s not configured\",\n\t\t\t\t\t compress_name);\n\t\t\t\tmessage = msg_buf;\n\t\t\t}\n\t\t} else\n\t\t\terror(\"invalid magic at start of compressed archive\");\n\t\tif (state != Reset)\n\t\t\terror(\"junk at the end of compressed archive\");\n\t\tthis_header = saved_offset + my_inptr;\n\t\tbuf += my_inptr;\n\t\tlen -= my_inptr;\n\t}\n\tdir_utime();\n\tkfree(name_buf);\n\tkfree(symlink_buf);\n\tkfree(header_buf);\n\treturn message;\n}\n\nstatic int __initdata do_retain_initrd;\n\nstatic int __init retain_initrd_param(char *str)\n{\n\tif (*str)\n\t\treturn 0;\n\tdo_retain_initrd = 1;\n\treturn 1;\n}\n__setup(\"retain_initrd\", retain_initrd_param);\n\n#ifdef CONFIG_ARCH_HAS_KEEPINITRD\nstatic int __init keepinitrd_setup(char *__unused)\n{\n\tdo_retain_initrd = 1;\n\treturn 1;\n}\n__setup(\"keepinitrd\", keepinitrd_setup);\n#endif\n\nstatic bool __initdata initramfs_async = true;\nstatic int __init initramfs_async_setup(char *str)\n{\n\treturn kstrtobool(str, &initramfs_async) == 0;\n}\n__setup(\"initramfs_async=\", initramfs_async_setup);\n\nextern char __initramfs_start[];\nextern unsigned long __initramfs_size;\n#include <linux/initrd.h>\n#include <linux/kexec.h>\n\nvoid __init reserve_initrd_mem(void)\n{\n\tphys_addr_t start;\n\tunsigned long size;\n\n\t \n\tinitrd_start = initrd_end = 0;\n\n\tif (!phys_initrd_size)\n\t\treturn;\n\t \n\tstart = round_down(phys_initrd_start, PAGE_SIZE);\n\tsize = phys_initrd_size + (phys_initrd_start - start);\n\tsize = round_up(size, PAGE_SIZE);\n\n\tif (!memblock_is_region_memory(start, size)) {\n\t\tpr_err(\"INITRD: 0x%08llx+0x%08lx is not a memory region\",\n\t\t       (u64)start, size);\n\t\tgoto disable;\n\t}\n\n\tif (memblock_is_region_reserved(start, size)) {\n\t\tpr_err(\"INITRD: 0x%08llx+0x%08lx overlaps in-use memory region\\n\",\n\t\t       (u64)start, size);\n\t\tgoto disable;\n\t}\n\n\tmemblock_reserve(start, size);\n\t \n\tinitrd_start = (unsigned long)__va(phys_initrd_start);\n\tinitrd_end = initrd_start + phys_initrd_size;\n\tinitrd_below_start_ok = 1;\n\n\treturn;\ndisable:\n\tpr_cont(\" - disabling initrd\\n\");\n\tinitrd_start = 0;\n\tinitrd_end = 0;\n}\n\nvoid __weak __init free_initrd_mem(unsigned long start, unsigned long end)\n{\n#ifdef CONFIG_ARCH_KEEP_MEMBLOCK\n\tunsigned long aligned_start = ALIGN_DOWN(start, PAGE_SIZE);\n\tunsigned long aligned_end = ALIGN(end, PAGE_SIZE);\n\n\tmemblock_free((void *)aligned_start, aligned_end - aligned_start);\n#endif\n\n\tfree_reserved_area((void *)start, (void *)end, POISON_FREE_INITMEM,\n\t\t\t\"initrd\");\n}\n\n#ifdef CONFIG_KEXEC_CORE\nstatic bool __init kexec_free_initrd(void)\n{\n\tunsigned long crashk_start = (unsigned long)__va(crashk_res.start);\n\tunsigned long crashk_end   = (unsigned long)__va(crashk_res.end);\n\n\t \n\tif (initrd_start >= crashk_end || initrd_end <= crashk_start)\n\t\treturn false;\n\n\t \n\tmemset((void *)initrd_start, 0, initrd_end - initrd_start);\n\tif (initrd_start < crashk_start)\n\t\tfree_initrd_mem(initrd_start, crashk_start);\n\tif (initrd_end > crashk_end)\n\t\tfree_initrd_mem(crashk_end, initrd_end);\n\treturn true;\n}\n#else\nstatic inline bool kexec_free_initrd(void)\n{\n\treturn false;\n}\n#endif  \n\n#ifdef CONFIG_BLK_DEV_RAM\nstatic void __init populate_initrd_image(char *err)\n{\n\tssize_t written;\n\tstruct file *file;\n\tloff_t pos = 0;\n\n\tunpack_to_rootfs(__initramfs_start, __initramfs_size);\n\n\tprintk(KERN_INFO \"rootfs image is not initramfs (%s); looks like an initrd\\n\",\n\t\t\terr);\n\tfile = filp_open(\"/initrd.image\", O_WRONLY | O_CREAT, 0700);\n\tif (IS_ERR(file))\n\t\treturn;\n\n\twritten = xwrite(file, (char *)initrd_start, initrd_end - initrd_start,\n\t\t\t&pos);\n\tif (written != initrd_end - initrd_start)\n\t\tpr_err(\"/initrd.image: incomplete write (%zd != %ld)\\n\",\n\t\t       written, initrd_end - initrd_start);\n\tfput(file);\n}\n#endif  \n\nstatic void __init do_populate_rootfs(void *unused, async_cookie_t cookie)\n{\n\t \n\tchar *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);\n\tif (err)\n\t\tpanic_show_mem(\"%s\", err);  \n\n\tif (!initrd_start || IS_ENABLED(CONFIG_INITRAMFS_FORCE))\n\t\tgoto done;\n\n\tif (IS_ENABLED(CONFIG_BLK_DEV_RAM))\n\t\tprintk(KERN_INFO \"Trying to unpack rootfs image as initramfs...\\n\");\n\telse\n\t\tprintk(KERN_INFO \"Unpacking initramfs...\\n\");\n\n\terr = unpack_to_rootfs((char *)initrd_start, initrd_end - initrd_start);\n\tif (err) {\n#ifdef CONFIG_BLK_DEV_RAM\n\t\tpopulate_initrd_image(err);\n#else\n\t\tprintk(KERN_EMERG \"Initramfs unpacking failed: %s\\n\", err);\n#endif\n\t}\n\ndone:\n\t \n\tif (!do_retain_initrd && initrd_start && !kexec_free_initrd())\n\t\tfree_initrd_mem(initrd_start, initrd_end);\n\tinitrd_start = 0;\n\tinitrd_end = 0;\n\n\tflush_delayed_fput();\n\ttask_work_run();\n}\n\nstatic ASYNC_DOMAIN_EXCLUSIVE(initramfs_domain);\nstatic async_cookie_t initramfs_cookie;\n\nvoid wait_for_initramfs(void)\n{\n\tif (!initramfs_cookie) {\n\t\t \n\t\tpr_warn_once(\"wait_for_initramfs() called before rootfs_initcalls\\n\");\n\t\treturn;\n\t}\n\tasync_synchronize_cookie_domain(initramfs_cookie + 1, &initramfs_domain);\n}\nEXPORT_SYMBOL_GPL(wait_for_initramfs);\n\nstatic int __init populate_rootfs(void)\n{\n\tinitramfs_cookie = async_schedule_domain(do_populate_rootfs, NULL,\n\t\t\t\t\t\t &initramfs_domain);\n\tusermodehelper_enable();\n\tif (!initramfs_async)\n\t\twait_for_initramfs();\n\treturn 0;\n}\nrootfs_initcall(populate_rootfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}