{
  "module_name": "Kconfig",
  "hash_id": "6c5442c33760782fce0b93126f5a6966cf9fe3dab3d109827f473e7ddcc5ca7a",
  "original_prompt": "Ingested from linux-6.6.14/init/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nconfig CC_VERSION_TEXT\n\tstring\n\tdefault \"$(CC_VERSION_TEXT)\"\n\thelp\n\t  This is used in unclear ways:\n\n\t  - Re-run Kconfig when the compiler is updated\n\t    The 'default' property references the environment variable,\n\t    CC_VERSION_TEXT so it is recorded in include/config/auto.conf.cmd.\n\t    When the compiler is updated, Kconfig will be invoked.\n\n\t  - Ensure full rebuild when the compiler is updated\n\t    include/linux/compiler-version.h contains this option in the comment\n\t    line so fixdep adds include/config/CC_VERSION_TEXT into the\n\t    auto-generated dependency. When the compiler is updated, syncconfig\n\t    will touch it and then every file will be rebuilt.\n\nconfig CC_IS_GCC\n\tdef_bool $(success,test \"$(cc-name)\" = GCC)\n\nconfig GCC_VERSION\n\tint\n\tdefault $(cc-version) if CC_IS_GCC\n\tdefault 0\n\nconfig CC_IS_CLANG\n\tdef_bool $(success,test \"$(cc-name)\" = Clang)\n\nconfig CLANG_VERSION\n\tint\n\tdefault $(cc-version) if CC_IS_CLANG\n\tdefault 0\n\nconfig AS_IS_GNU\n\tdef_bool $(success,test \"$(as-name)\" = GNU)\n\nconfig AS_IS_LLVM\n\tdef_bool $(success,test \"$(as-name)\" = LLVM)\n\nconfig AS_VERSION\n\tint\n\t# Use clang version if this is the integrated assembler\n\tdefault CLANG_VERSION if AS_IS_LLVM\n\tdefault $(as-version)\n\nconfig LD_IS_BFD\n\tdef_bool $(success,test \"$(ld-name)\" = BFD)\n\nconfig LD_VERSION\n\tint\n\tdefault $(ld-version) if LD_IS_BFD\n\tdefault 0\n\nconfig LD_IS_LLD\n\tdef_bool $(success,test \"$(ld-name)\" = LLD)\n\nconfig LLD_VERSION\n\tint\n\tdefault $(ld-version) if LD_IS_LLD\n\tdefault 0\n\nconfig RUST_IS_AVAILABLE\n\tdef_bool $(success,$(srctree)/scripts/rust_is_available.sh)\n\thelp\n\t  This shows whether a suitable Rust toolchain is available (found).\n\n\t  Please see Documentation/rust/quick-start.rst for instructions on how\n\t  to satisfy the build requirements of Rust support.\n\n\t  In particular, the Makefile target 'rustavailable' is useful to check\n\t  why the Rust toolchain is not being detected.\n\nconfig CC_CAN_LINK\n\tbool\n\tdefault $(success,$(srctree)/scripts/cc-can-link.sh $(CC) $(CLANG_FLAGS) $(USERCFLAGS) $(USERLDFLAGS) $(m64-flag)) if 64BIT\n\tdefault $(success,$(srctree)/scripts/cc-can-link.sh $(CC) $(CLANG_FLAGS) $(USERCFLAGS) $(USERLDFLAGS) $(m32-flag))\n\nconfig CC_CAN_LINK_STATIC\n\tbool\n\tdefault $(success,$(srctree)/scripts/cc-can-link.sh $(CC) $(CLANG_FLAGS) $(USERCFLAGS) $(USERLDFLAGS) $(m64-flag) -static) if 64BIT\n\tdefault $(success,$(srctree)/scripts/cc-can-link.sh $(CC) $(CLANG_FLAGS) $(USERCFLAGS) $(USERLDFLAGS) $(m32-flag) -static)\n\nconfig CC_HAS_ASM_GOTO_OUTPUT\n\tdef_bool $(success,echo 'int foo(int x) { asm goto (\"\": \"=r\"(x) ::: bar); return x; bar: return 0; }' | $(CC) -x c - -c -o /dev/null)\n\nconfig CC_HAS_ASM_GOTO_TIED_OUTPUT\n\tdepends on CC_HAS_ASM_GOTO_OUTPUT\n\t# Detect buggy gcc and clang, fixed in gcc-11 clang-14.\n\tdef_bool $(success,echo 'int foo(int *x) { asm goto (\".long (%l[bar]) - .\": \"+m\"(*x) ::: bar); return *x; bar: return 0; }' | $CC -x c - -c -o /dev/null)\n\nconfig TOOLS_SUPPORT_RELR\n\tdef_bool $(success,env \"CC=$(CC)\" \"LD=$(LD)\" \"NM=$(NM)\" \"OBJCOPY=$(OBJCOPY)\" $(srctree)/scripts/tools-support-relr.sh)\n\nconfig CC_HAS_ASM_INLINE\n\tdef_bool $(success,echo 'void foo(void) { asm inline (\"\"); }' | $(CC) -x c - -c -o /dev/null)\n\nconfig CC_HAS_NO_PROFILE_FN_ATTR\n\tdef_bool $(success,echo '__attribute__((no_profile_instrument_function)) int x();' | $(CC) -x c - -c -o /dev/null -Werror)\n\nconfig PAHOLE_VERSION\n\tint\n\tdefault $(shell,$(srctree)/scripts/pahole-version.sh $(PAHOLE))\n\nconfig CONSTRUCTORS\n\tbool\n\nconfig IRQ_WORK\n\tbool\n\nconfig BUILDTIME_TABLE_SORT\n\tbool\n\nconfig THREAD_INFO_IN_TASK\n\tbool\n\thelp\n\t  Select this to move thread_info off the stack into task_struct.  To\n\t  make this work, an arch will need to remove all thread_info fields\n\t  except flags and fix any runtime bugs.\n\n\t  One subtle change that will be needed is to use try_get_task_stack()\n\t  and put_task_stack() in save_thread_stack_tsk() and get_wchan().\n\nmenu \"General setup\"\n\nconfig BROKEN\n\tbool\n\nconfig BROKEN_ON_SMP\n\tbool\n\tdepends on BROKEN || !SMP\n\tdefault y\n\nconfig INIT_ENV_ARG_LIMIT\n\tint\n\tdefault 32 if !UML\n\tdefault 128 if UML\n\thelp\n\t  Maximum of each of the number of arguments and environment\n\t  variables passed to init from the kernel command line.\n\nconfig COMPILE_TEST\n\tbool \"Compile also drivers which will not load\"\n\tdepends on HAS_IOMEM\n\thelp\n\t  Some drivers can be compiled on a different platform than they are\n\t  intended to be run on. Despite they cannot be loaded there (or even\n\t  when they load they cannot be used due to missing HW support),\n\t  developers still, opposing to distributors, might want to build such\n\t  drivers to compile-test them.\n\n\t  If you are a developer and want to build everything available, say Y\n\t  here. If you are a user/distributor, say N here to exclude useless\n\t  drivers to be distributed.\n\nconfig WERROR\n\tbool \"Compile the kernel with warnings as errors\"\n\tdefault COMPILE_TEST\n\thelp\n\t  A kernel build should not cause any compiler warnings, and this\n\t  enables the '-Werror' (for C) and '-Dwarnings' (for Rust) flags\n\t  to enforce that rule by default. Certain warnings from other tools\n\t  such as the linker may be upgraded to errors with this option as\n\t  well.\n\n\t  However, if you have a new (or very old) compiler or linker with odd\n\t  and unusual warnings, or you have some architecture with problems,\n\t  you may need to disable this config option in order to\n\t  successfully build the kernel.\n\n\t  If in doubt, say Y.\n\nconfig UAPI_HEADER_TEST\n\tbool \"Compile test UAPI headers\"\n\tdepends on HEADERS_INSTALL && CC_CAN_LINK\n\thelp\n\t  Compile test headers exported to user-space to ensure they are\n\t  self-contained, i.e. compilable as standalone units.\n\n\t  If you are a developer or tester and want to ensure the exported\n\t  headers are self-contained, say Y here. Otherwise, choose N.\n\nconfig LOCALVERSION\n\tstring \"Local version - append to kernel release\"\n\thelp\n\t  Append an extra string to the end of your kernel version.\n\t  This will show up when you type uname, for example.\n\t  The string you set here will be appended after the contents of\n\t  any files with a filename matching localversion* in your\n\t  object and source tree, in that order.  Your total string can\n\t  be a maximum of 64 characters.\n\nconfig LOCALVERSION_AUTO\n\tbool \"Automatically append version information to the version string\"\n\tdefault y\n\tdepends on !COMPILE_TEST\n\thelp\n\t  This will try to automatically determine if the current tree is a\n\t  release tree by looking for git tags that belong to the current\n\t  top of tree revision.\n\n\t  A string of the format -gxxxxxxxx will be added to the localversion\n\t  if a git-based tree is found.  The string generated by this will be\n\t  appended after any matching localversion* files, and after the value\n\t  set in CONFIG_LOCALVERSION.\n\n\t  (The actual string used here is the first 12 characters produced\n\t  by running the command:\n\n\t    $ git rev-parse --verify HEAD\n\n\t  which is done within the script \"scripts/setlocalversion\".)\n\nconfig BUILD_SALT\n\tstring \"Build ID Salt\"\n\tdefault \"\"\n\thelp\n\t  The build ID is used to link binaries and their debug info. Setting\n\t  this option will use the value in the calculation of the build id.\n\t  This is mostly useful for distributions which want to ensure the\n\t  build is unique between builds. It's safe to leave the default.\n\nconfig HAVE_KERNEL_GZIP\n\tbool\n\nconfig HAVE_KERNEL_BZIP2\n\tbool\n\nconfig HAVE_KERNEL_LZMA\n\tbool\n\nconfig HAVE_KERNEL_XZ\n\tbool\n\nconfig HAVE_KERNEL_LZO\n\tbool\n\nconfig HAVE_KERNEL_LZ4\n\tbool\n\nconfig HAVE_KERNEL_ZSTD\n\tbool\n\nconfig HAVE_KERNEL_UNCOMPRESSED\n\tbool\n\nchoice\n\tprompt \"Kernel compression mode\"\n\tdefault KERNEL_GZIP\n\tdepends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO || HAVE_KERNEL_LZ4 || HAVE_KERNEL_ZSTD || HAVE_KERNEL_UNCOMPRESSED\n\thelp\n\t  The linux kernel is a kind of self-extracting executable.\n\t  Several compression algorithms are available, which differ\n\t  in efficiency, compression and decompression speed.\n\t  Compression speed is only relevant when building a kernel.\n\t  Decompression speed is relevant at each boot.\n\n\t  If you have any problems with bzip2 or lzma compressed\n\t  kernels, mail me (Alain Knaff) <alain@knaff.lu>. (An older\n\t  version of this functionality (bzip2 only), for 2.4, was\n\t  supplied by Christian Ludwig)\n\n\t  High compression options are mostly useful for users, who\n\t  are low on disk space (embedded systems), but for whom ram\n\t  size matters less.\n\n\t  If in doubt, select 'gzip'\n\nconfig KERNEL_GZIP\n\tbool \"Gzip\"\n\tdepends on HAVE_KERNEL_GZIP\n\thelp\n\t  The old and tried gzip compression. It provides a good balance\n\t  between compression ratio and decompression speed.\n\nconfig KERNEL_BZIP2\n\tbool \"Bzip2\"\n\tdepends on HAVE_KERNEL_BZIP2\n\thelp\n\t  Its compression ratio and speed is intermediate.\n\t  Decompression speed is slowest among the choices.  The kernel\n\t  size is about 10% smaller with bzip2, in comparison to gzip.\n\t  Bzip2 uses a large amount of memory. For modern kernels you\n\t  will need at least 8MB RAM or more for booting.\n\nconfig KERNEL_LZMA\n\tbool \"LZMA\"\n\tdepends on HAVE_KERNEL_LZMA\n\thelp\n\t  This compression algorithm's ratio is best.  Decompression speed\n\t  is between gzip and bzip2.  Compression is slowest.\n\t  The kernel size is about 33% smaller with LZMA in comparison to gzip.\n\nconfig KERNEL_XZ\n\tbool \"XZ\"\n\tdepends on HAVE_KERNEL_XZ\n\thelp\n\t  XZ uses the LZMA2 algorithm and instruction set specific\n\t  BCJ filters which can improve compression ratio of executable\n\t  code. The size of the kernel is about 30% smaller with XZ in\n\t  comparison to gzip. On architectures for which there is a BCJ\n\t  filter (i386, x86_64, ARM, IA-64, PowerPC, and SPARC), XZ\n\t  will create a few percent smaller kernel than plain LZMA.\n\n\t  The speed is about the same as with LZMA: The decompression\n\t  speed of XZ is better than that of bzip2 but worse than gzip\n\t  and LZO. Compression is slow.\n\nconfig KERNEL_LZO\n\tbool \"LZO\"\n\tdepends on HAVE_KERNEL_LZO\n\thelp\n\t  Its compression ratio is the poorest among the choices. The kernel\n\t  size is about 10% bigger than gzip; however its speed\n\t  (both compression and decompression) is the fastest.\n\nconfig KERNEL_LZ4\n\tbool \"LZ4\"\n\tdepends on HAVE_KERNEL_LZ4\n\thelp\n\t  LZ4 is an LZ77-type compressor with a fixed, byte-oriented encoding.\n\t  A preliminary version of LZ4 de/compression tool is available at\n\t  <https://code.google.com/p/lz4/>.\n\n\t  Its compression ratio is worse than LZO. The size of the kernel\n\t  is about 8% bigger than LZO. But the decompression speed is\n\t  faster than LZO.\n\nconfig KERNEL_ZSTD\n\tbool \"ZSTD\"\n\tdepends on HAVE_KERNEL_ZSTD\n\thelp\n\t  ZSTD is a compression algorithm targeting intermediate compression\n\t  with fast decompression speed. It will compress better than GZIP and\n\t  decompress around the same speed as LZO, but slower than LZ4. You\n\t  will need at least 192 KB RAM or more for booting. The zstd command\n\t  line tool is required for compression.\n\nconfig KERNEL_UNCOMPRESSED\n\tbool \"None\"\n\tdepends on HAVE_KERNEL_UNCOMPRESSED\n\thelp\n\t  Produce uncompressed kernel image. This option is usually not what\n\t  you want. It is useful for debugging the kernel in slow simulation\n\t  environments, where decompressing and moving the kernel is awfully\n\t  slow. This option allows early boot code to skip the decompressor\n\t  and jump right at uncompressed kernel image.\n\nendchoice\n\nconfig DEFAULT_INIT\n\tstring \"Default init path\"\n\tdefault \"\"\n\thelp\n\t  This option determines the default init for the system if no init=\n\t  option is passed on the kernel command line. If the requested path is\n\t  not present, we will still then move on to attempting further\n\t  locations (e.g. /sbin/init, etc). If this is empty, we will just use\n\t  the fallback list when init= is not passed.\n\nconfig DEFAULT_HOSTNAME\n\tstring \"Default hostname\"\n\tdefault \"(none)\"\n\thelp\n\t  This option determines the default system hostname before userspace\n\t  calls sethostname(2). The kernel traditionally uses \"(none)\" here,\n\t  but you may wish to use a different default here to make a minimal\n\t  system more usable with less configuration.\n\nconfig SYSVIPC\n\tbool \"System V IPC\"\n\thelp\n\t  Inter Process Communication is a suite of library functions and\n\t  system calls which let processes (running programs) synchronize and\n\t  exchange information. It is generally considered to be a good thing,\n\t  and some programs won't run unless you say Y here. In particular, if\n\t  you want to run the DOS emulator dosemu under Linux (read the\n\t  DOSEMU-HOWTO, available from <http://www.tldp.org/docs.html#howto>),\n\t  you'll need to say Y here.\n\n\t  You can find documentation about IPC with \"info ipc\" and also in\n\t  section 6.4 of the Linux Programmer's Guide, available from\n\t  <http://www.tldp.org/guides.html>.\n\nconfig SYSVIPC_SYSCTL\n\tbool\n\tdepends on SYSVIPC\n\tdepends on SYSCTL\n\tdefault y\n\nconfig SYSVIPC_COMPAT\n\tdef_bool y\n\tdepends on COMPAT && SYSVIPC\n\nconfig POSIX_MQUEUE\n\tbool \"POSIX Message Queues\"\n\tdepends on NET\n\thelp\n\t  POSIX variant of message queues is a part of IPC. In POSIX message\n\t  queues every message has a priority which decides about succession\n\t  of receiving it by a process. If you want to compile and run\n\t  programs written e.g. for Solaris with use of its POSIX message\n\t  queues (functions mq_*) say Y here.\n\n\t  POSIX message queues are visible as a filesystem called 'mqueue'\n\t  and can be mounted somewhere if you want to do filesystem\n\t  operations on message queues.\n\n\t  If unsure, say Y.\n\nconfig POSIX_MQUEUE_SYSCTL\n\tbool\n\tdepends on POSIX_MQUEUE\n\tdepends on SYSCTL\n\tdefault y\n\nconfig WATCH_QUEUE\n\tbool \"General notification queue\"\n\tdefault n\n\thelp\n\n\t  This is a general notification queue for the kernel to pass events to\n\t  userspace by splicing them into pipes.  It can be used in conjunction\n\t  with watches for key/keyring change notifications and device\n\t  notifications.\n\n\t  See Documentation/core-api/watch_queue.rst\n\nconfig CROSS_MEMORY_ATTACH\n\tbool \"Enable process_vm_readv/writev syscalls\"\n\tdepends on MMU\n\tdefault y\n\thelp\n\t  Enabling this option adds the system calls process_vm_readv and\n\t  process_vm_writev which allow a process with the correct privileges\n\t  to directly read from or write to another process' address space.\n\t  See the man page for more details.\n\nconfig USELIB\n\tbool \"uselib syscall (for libc5 and earlier)\"\n\tdefault ALPHA || M68K || SPARC\n\thelp\n\t  This option enables the uselib syscall, a system call used in the\n\t  dynamic linker from libc5 and earlier.  glibc does not use this\n\t  system call.  If you intend to run programs built on libc5 or\n\t  earlier, you may need to enable this syscall.  Current systems\n\t  running glibc can safely disable this.\n\nconfig AUDIT\n\tbool \"Auditing support\"\n\tdepends on NET\n\thelp\n\t  Enable auditing infrastructure that can be used with another\n\t  kernel subsystem, such as SELinux (which requires this for\n\t  logging of avc messages output).  System call auditing is included\n\t  on architectures which support it.\n\nconfig HAVE_ARCH_AUDITSYSCALL\n\tbool\n\nconfig AUDITSYSCALL\n\tdef_bool y\n\tdepends on AUDIT && HAVE_ARCH_AUDITSYSCALL\n\tselect FSNOTIFY\n\nsource \"kernel/irq/Kconfig\"\nsource \"kernel/time/Kconfig\"\nsource \"kernel/bpf/Kconfig\"\nsource \"kernel/Kconfig.preempt\"\n\nmenu \"CPU/Task time and stats accounting\"\n\nconfig VIRT_CPU_ACCOUNTING\n\tbool\n\nchoice\n\tprompt \"Cputime accounting\"\n\tdefault TICK_CPU_ACCOUNTING\n\n# Kind of a stub config for the pure tick based cputime accounting\nconfig TICK_CPU_ACCOUNTING\n\tbool \"Simple tick based cputime accounting\"\n\tdepends on !S390 && !NO_HZ_FULL\n\thelp\n\t  This is the basic tick based cputime accounting that maintains\n\t  statistics about user, system and idle time spent on per jiffies\n\t  granularity.\n\n\t  If unsure, say Y.\n\nconfig VIRT_CPU_ACCOUNTING_NATIVE\n\tbool \"Deterministic task and CPU time accounting\"\n\tdepends on HAVE_VIRT_CPU_ACCOUNTING && !NO_HZ_FULL\n\tselect VIRT_CPU_ACCOUNTING\n\thelp\n\t  Select this option to enable more accurate task and CPU time\n\t  accounting.  This is done by reading a CPU counter on each\n\t  kernel entry and exit and on transitions within the kernel\n\t  between system, softirq and hardirq state, so there is a\n\t  small performance impact.  In the case of s390 or IBM POWER > 5,\n\t  this also enables accounting of stolen time on logically-partitioned\n\t  systems.\n\nconfig VIRT_CPU_ACCOUNTING_GEN\n\tbool \"Full dynticks CPU time accounting\"\n\tdepends on HAVE_CONTEXT_TRACKING_USER\n\tdepends on HAVE_VIRT_CPU_ACCOUNTING_GEN\n\tdepends on GENERIC_CLOCKEVENTS\n\tselect VIRT_CPU_ACCOUNTING\n\tselect CONTEXT_TRACKING_USER\n\thelp\n\t  Select this option to enable task and CPU time accounting on full\n\t  dynticks systems. This accounting is implemented by watching every\n\t  kernel-user boundaries using the context tracking subsystem.\n\t  The accounting is thus performed at the expense of some significant\n\t  overhead.\n\n\t  For now this is only useful if you are working on the full\n\t  dynticks subsystem development.\n\n\t  If unsure, say N.\n\nendchoice\n\nconfig IRQ_TIME_ACCOUNTING\n\tbool \"Fine granularity task level IRQ time accounting\"\n\tdepends on HAVE_IRQ_TIME_ACCOUNTING && !VIRT_CPU_ACCOUNTING_NATIVE\n\thelp\n\t  Select this option to enable fine granularity task irq time\n\t  accounting. This is done by reading a timestamp on each\n\t  transitions between softirq and hardirq state, so there can be a\n\t  small performance impact.\n\n\t  If in doubt, say N here.\n\nconfig HAVE_SCHED_AVG_IRQ\n\tdef_bool y\n\tdepends on IRQ_TIME_ACCOUNTING || PARAVIRT_TIME_ACCOUNTING\n\tdepends on SMP\n\nconfig SCHED_THERMAL_PRESSURE\n\tbool\n\tdefault y if ARM && ARM_CPU_TOPOLOGY\n\tdefault y if ARM64\n\tdepends on SMP\n\tdepends on CPU_FREQ_THERMAL\n\thelp\n\t  Select this option to enable thermal pressure accounting in the\n\t  scheduler. Thermal pressure is the value conveyed to the scheduler\n\t  that reflects the reduction in CPU compute capacity resulted from\n\t  thermal throttling. Thermal throttling occurs when the performance of\n\t  a CPU is capped due to high operating temperatures.\n\n\t  If selected, the scheduler will be able to balance tasks accordingly,\n\t  i.e. put less load on throttled CPUs than on non/less throttled ones.\n\n\t  This requires the architecture to implement\n\t  arch_update_thermal_pressure() and arch_scale_thermal_pressure().\n\nconfig BSD_PROCESS_ACCT\n\tbool \"BSD Process Accounting\"\n\tdepends on MULTIUSER\n\thelp\n\t  If you say Y here, a user level program will be able to instruct the\n\t  kernel (via a special system call) to write process accounting\n\t  information to a file: whenever a process exits, information about\n\t  that process will be appended to the file by the kernel.  The\n\t  information includes things such as creation time, owning user,\n\t  command name, memory usage, controlling terminal etc. (the complete\n\t  list is in the struct acct in <file:include/linux/acct.h>).  It is\n\t  up to the user level program to do useful things with this\n\t  information.  This is generally a good idea, so say Y.\n\nconfig BSD_PROCESS_ACCT_V3\n\tbool \"BSD Process Accounting version 3 file format\"\n\tdepends on BSD_PROCESS_ACCT\n\tdefault n\n\thelp\n\t  If you say Y here, the process accounting information is written\n\t  in a new file format that also logs the process IDs of each\n\t  process and its parent. Note that this file format is incompatible\n\t  with previous v0/v1/v2 file formats, so you will need updated tools\n\t  for processing it. A preliminary version of these tools is available\n\t  at <http://www.gnu.org/software/acct/>.\n\nconfig TASKSTATS\n\tbool \"Export task/process statistics through netlink\"\n\tdepends on NET\n\tdepends on MULTIUSER\n\tdefault n\n\thelp\n\t  Export selected statistics for tasks/processes through the\n\t  generic netlink interface. Unlike BSD process accounting, the\n\t  statistics are available during the lifetime of tasks/processes as\n\t  responses to commands. Like BSD accounting, they are sent to user\n\t  space on task exit.\n\n\t  Say N if unsure.\n\nconfig TASK_DELAY_ACCT\n\tbool \"Enable per-task delay accounting\"\n\tdepends on TASKSTATS\n\tselect SCHED_INFO\n\thelp\n\t  Collect information on time spent by a task waiting for system\n\t  resources like cpu, synchronous block I/O completion and swapping\n\t  in pages. Such statistics can help in setting a task's priorities\n\t  relative to other tasks for cpu, io, rss limits etc.\n\n\t  Say N if unsure.\n\nconfig TASK_XACCT\n\tbool \"Enable extended accounting over taskstats\"\n\tdepends on TASKSTATS\n\thelp\n\t  Collect extended task accounting data and send the data\n\t  to userland for processing over the taskstats interface.\n\n\t  Say N if unsure.\n\nconfig TASK_IO_ACCOUNTING\n\tbool \"Enable per-task storage I/O accounting\"\n\tdepends on TASK_XACCT\n\thelp\n\t  Collect information on the number of bytes of storage I/O which this\n\t  task has caused.\n\n\t  Say N if unsure.\n\nconfig PSI\n\tbool \"Pressure stall information tracking\"\n\tselect KERNFS\n\thelp\n\t  Collect metrics that indicate how overcommitted the CPU, memory,\n\t  and IO capacity are in the system.\n\n\t  If you say Y here, the kernel will create /proc/pressure/ with the\n\t  pressure statistics files cpu, memory, and io. These will indicate\n\t  the share of walltime in which some or all tasks in the system are\n\t  delayed due to contention of the respective resource.\n\n\t  In kernels with cgroup support, cgroups (cgroup2 only) will\n\t  have cpu.pressure, memory.pressure, and io.pressure files,\n\t  which aggregate pressure stalls for the grouped tasks only.\n\n\t  For more details see Documentation/accounting/psi.rst.\n\n\t  Say N if unsure.\n\nconfig PSI_DEFAULT_DISABLED\n\tbool \"Require boot parameter to enable pressure stall information tracking\"\n\tdefault n\n\tdepends on PSI\n\thelp\n\t  If set, pressure stall information tracking will be disabled\n\t  per default but can be enabled through passing psi=1 on the\n\t  kernel commandline during boot.\n\n\t  This feature adds some code to the task wakeup and sleep\n\t  paths of the scheduler. The overhead is too low to affect\n\t  common scheduling-intense workloads in practice (such as\n\t  webservers, memcache), but it does show up in artificial\n\t  scheduler stress tests, such as hackbench.\n\n\t  If you are paranoid and not sure what the kernel will be\n\t  used for, say Y.\n\n\t  Say N if unsure.\n\nendmenu # \"CPU/Task time and stats accounting\"\n\nconfig CPU_ISOLATION\n\tbool \"CPU isolation\"\n\tdepends on SMP || COMPILE_TEST\n\tdefault y\n\thelp\n\t  Make sure that CPUs running critical tasks are not disturbed by\n\t  any source of \"noise\" such as unbound workqueues, timers, kthreads...\n\t  Unbound jobs get offloaded to housekeeping CPUs. This is driven by\n\t  the \"isolcpus=\" boot parameter.\n\n\t  Say Y if unsure.\n\nsource \"kernel/rcu/Kconfig\"\n\nconfig IKCONFIG\n\ttristate \"Kernel .config support\"\n\thelp\n\t  This option enables the complete Linux kernel \".config\" file\n\t  contents to be saved in the kernel. It provides documentation\n\t  of which kernel options are used in a running kernel or in an\n\t  on-disk kernel.  This information can be extracted from the kernel\n\t  image file with the script scripts/extract-ikconfig and used as\n\t  input to rebuild the current kernel or to build another kernel.\n\t  It can also be extracted from a running kernel by reading\n\t  /proc/config.gz if enabled (below).\n\nconfig IKCONFIG_PROC\n\tbool \"Enable access to .config through /proc/config.gz\"\n\tdepends on IKCONFIG && PROC_FS\n\thelp\n\t  This option enables access to the kernel configuration file\n\t  through /proc/config.gz.\n\nconfig IKHEADERS\n\ttristate \"Enable kernel headers through /sys/kernel/kheaders.tar.xz\"\n\tdepends on SYSFS\n\thelp\n\t  This option enables access to the in-kernel headers that are generated during\n\t  the build process. These can be used to build eBPF tracing programs,\n\t  or similar programs.  If you build the headers as a module, a module called\n\t  kheaders.ko is built which can be loaded on-demand to get access to headers.\n\nconfig LOG_BUF_SHIFT\n\tint \"Kernel log buffer size (16 => 64KB, 17 => 128KB)\"\n\trange 12 25\n\tdefault 17\n\tdepends on PRINTK\n\thelp\n\t  Select the minimal kernel log buffer size as a power of 2.\n\t  The final size is affected by LOG_CPU_MAX_BUF_SHIFT config\n\t  parameter, see below. Any higher size also might be forced\n\t  by \"log_buf_len\" boot parameter.\n\n\t  Examples:\n\t\t     17 => 128 KB\n\t\t     16 => 64 KB\n\t\t     15 => 32 KB\n\t\t     14 => 16 KB\n\t\t     13 =>  8 KB\n\t\t     12 =>  4 KB\n\nconfig LOG_CPU_MAX_BUF_SHIFT\n\tint \"CPU kernel log buffer size contribution (13 => 8 KB, 17 => 128KB)\"\n\tdepends on SMP\n\trange 0 21\n\tdefault 12 if !BASE_SMALL\n\tdefault 0 if BASE_SMALL\n\tdepends on PRINTK\n\thelp\n\t  This option allows to increase the default ring buffer size\n\t  according to the number of CPUs. The value defines the contribution\n\t  of each CPU as a power of 2. The used space is typically only few\n\t  lines however it might be much more when problems are reported,\n\t  e.g. backtraces.\n\n\t  The increased size means that a new buffer has to be allocated and\n\t  the original static one is unused. It makes sense only on systems\n\t  with more CPUs. Therefore this value is used only when the sum of\n\t  contributions is greater than the half of the default kernel ring\n\t  buffer as defined by LOG_BUF_SHIFT. The default values are set\n\t  so that more than 16 CPUs are needed to trigger the allocation.\n\n\t  Also this option is ignored when \"log_buf_len\" kernel parameter is\n\t  used as it forces an exact (power of two) size of the ring buffer.\n\n\t  The number of possible CPUs is used for this computation ignoring\n\t  hotplugging making the computation optimal for the worst case\n\t  scenario while allowing a simple algorithm to be used from bootup.\n\n\t  Examples shift values and their meaning:\n\t\t     17 => 128 KB for each CPU\n\t\t     16 =>  64 KB for each CPU\n\t\t     15 =>  32 KB for each CPU\n\t\t     14 =>  16 KB for each CPU\n\t\t     13 =>   8 KB for each CPU\n\t\t     12 =>   4 KB for each CPU\n\nconfig PRINTK_INDEX\n\tbool \"Printk indexing debugfs interface\"\n\tdepends on PRINTK && DEBUG_FS\n\thelp\n\t  Add support for indexing of all printk formats known at compile time\n\t  at <debugfs>/printk/index/<module>.\n\n\t  This can be used as part of maintaining daemons which monitor\n\t  /dev/kmsg, as it permits auditing the printk formats present in a\n\t  kernel, allowing detection of cases where monitored printks are\n\t  changed or no longer present.\n\n\t  There is no additional runtime cost to printk with this enabled.\n\n#\n# Architectures with an unreliable sched_clock() should select this:\n#\nconfig HAVE_UNSTABLE_SCHED_CLOCK\n\tbool\n\nconfig GENERIC_SCHED_CLOCK\n\tbool\n\nmenu \"Scheduler features\"\n\nconfig UCLAMP_TASK\n\tbool \"Enable utilization clamping for RT/FAIR tasks\"\n\tdepends on CPU_FREQ_GOV_SCHEDUTIL\n\thelp\n\t  This feature enables the scheduler to track the clamped utilization\n\t  of each CPU based on RUNNABLE tasks scheduled on that CPU.\n\n\t  With this option, the user can specify the min and max CPU\n\t  utilization allowed for RUNNABLE tasks. The max utilization defines\n\t  the maximum frequency a task should use while the min utilization\n\t  defines the minimum frequency it should use.\n\n\t  Both min and max utilization clamp values are hints to the scheduler,\n\t  aiming at improving its frequency selection policy, but they do not\n\t  enforce or grant any specific bandwidth for tasks.\n\n\t  If in doubt, say N.\n\nconfig UCLAMP_BUCKETS_COUNT\n\tint \"Number of supported utilization clamp buckets\"\n\trange 5 20\n\tdefault 5\n\tdepends on UCLAMP_TASK\n\thelp\n\t  Defines the number of clamp buckets to use. The range of each bucket\n\t  will be SCHED_CAPACITY_SCALE/UCLAMP_BUCKETS_COUNT. The higher the\n\t  number of clamp buckets the finer their granularity and the higher\n\t  the precision of clamping aggregation and tracking at run-time.\n\n\t  For example, with the minimum configuration value we will have 5\n\t  clamp buckets tracking 20% utilization each. A 25% boosted tasks will\n\t  be refcounted in the [20..39]% bucket and will set the bucket clamp\n\t  effective value to 25%.\n\t  If a second 30% boosted task should be co-scheduled on the same CPU,\n\t  that task will be refcounted in the same bucket of the first task and\n\t  it will boost the bucket clamp effective value to 30%.\n\t  The clamp effective value of a bucket is reset to its nominal value\n\t  (20% in the example above) when there are no more tasks refcounted in\n\t  that bucket.\n\n\t  An additional boost/capping margin can be added to some tasks. In the\n\t  example above the 25% task will be boosted to 30% until it exits the\n\t  CPU. If that should be considered not acceptable on certain systems,\n\t  it's always possible to reduce the margin by increasing the number of\n\t  clamp buckets to trade off used memory for run-time tracking\n\t  precision.\n\n\t  If in doubt, use the default value.\n\nendmenu\n\n#\n# For architectures that want to enable the support for NUMA-affine scheduler\n# balancing logic:\n#\nconfig ARCH_SUPPORTS_NUMA_BALANCING\n\tbool\n\n#\n# For architectures that prefer to flush all TLBs after a number of pages\n# are unmapped instead of sending one IPI per page to flush. The architecture\n# must provide guarantees on what happens if a clean TLB cache entry is\n# written after the unmap. Details are in mm/rmap.c near the check for\n# should_defer_flush. The architecture should also consider if the full flush\n# and the refill costs are offset by the savings of sending fewer IPIs.\nconfig ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH\n\tbool\n\nconfig CC_HAS_INT128\n\tdef_bool !$(cc-option,$(m64-flag) -D__SIZEOF_INT128__=0) && 64BIT\n\nconfig CC_IMPLICIT_FALLTHROUGH\n\tstring\n\tdefault \"-Wimplicit-fallthrough=5\" if CC_IS_GCC && $(cc-option,-Wimplicit-fallthrough=5)\n\tdefault \"-Wimplicit-fallthrough\" if CC_IS_CLANG && $(cc-option,-Wunreachable-code-fallthrough)\n\n# Currently, disable gcc-11+ array-bounds globally.\n# It's still broken in gcc-13, so no upper bound yet.\nconfig GCC11_NO_ARRAY_BOUNDS\n\tdef_bool y\n\nconfig CC_NO_ARRAY_BOUNDS\n\tbool\n\tdefault y if CC_IS_GCC && GCC_VERSION >= 110000 && GCC11_NO_ARRAY_BOUNDS\n\n#\n# For architectures that know their GCC __int128 support is sound\n#\nconfig ARCH_SUPPORTS_INT128\n\tbool\n\n# For architectures that (ab)use NUMA to represent different memory regions\n# all cpu-local but of different latencies, such as SuperH.\n#\nconfig ARCH_WANT_NUMA_VARIABLE_LOCALITY\n\tbool\n\nconfig NUMA_BALANCING\n\tbool \"Memory placement aware NUMA scheduler\"\n\tdepends on ARCH_SUPPORTS_NUMA_BALANCING\n\tdepends on !ARCH_WANT_NUMA_VARIABLE_LOCALITY\n\tdepends on SMP && NUMA && MIGRATION && !PREEMPT_RT\n\thelp\n\t  This option adds support for automatic NUMA aware memory/task placement.\n\t  The mechanism is quite primitive and is based on migrating memory when\n\t  it has references to the node the task is running on.\n\n\t  This system will be inactive on UMA systems.\n\nconfig NUMA_BALANCING_DEFAULT_ENABLED\n\tbool \"Automatically enable NUMA aware memory/task placement\"\n\tdefault y\n\tdepends on NUMA_BALANCING\n\thelp\n\t  If set, automatic NUMA balancing will be enabled if running on a NUMA\n\t  machine.\n\nmenuconfig CGROUPS\n\tbool \"Control Group support\"\n\tselect KERNFS\n\thelp\n\t  This option adds support for grouping sets of processes together, for\n\t  use with process control subsystems such as Cpusets, CFS, memory\n\t  controls or device isolation.\n\t  See\n\t\t- Documentation/scheduler/sched-design-CFS.rst\t(CFS)\n\t\t- Documentation/admin-guide/cgroup-v1/ (features for grouping, isolation\n\t\t\t\t\t  and resource control)\n\n\t  Say N if unsure.\n\nif CGROUPS\n\nconfig PAGE_COUNTER\n\tbool\n\nconfig CGROUP_FAVOR_DYNMODS\n        bool \"Favor dynamic modification latency reduction by default\"\n        help\n          This option enables the \"favordynmods\" mount option by default\n          which reduces the latencies of dynamic cgroup modifications such\n          as task migrations and controller on/offs at the cost of making\n          hot path operations such as forks and exits more expensive.\n\n          Say N if unsure.\n\nconfig MEMCG\n\tbool \"Memory controller\"\n\tselect PAGE_COUNTER\n\tselect EVENTFD\n\thelp\n\t  Provides control over the memory footprint of tasks in a cgroup.\n\nconfig MEMCG_KMEM\n\tbool\n\tdepends on MEMCG\n\tdefault y\n\nconfig BLK_CGROUP\n\tbool \"IO controller\"\n\tdepends on BLOCK\n\tdefault n\n\thelp\n\tGeneric block IO controller cgroup interface. This is the common\n\tcgroup interface which should be used by various IO controlling\n\tpolicies.\n\n\tCurrently, CFQ IO scheduler uses it to recognize task groups and\n\tcontrol disk bandwidth allocation (proportional time slice allocation)\n\tto such task groups. It is also used by bio throttling logic in\n\tblock layer to implement upper limit in IO rates on a device.\n\n\tThis option only enables generic Block IO controller infrastructure.\n\tOne needs to also enable actual IO controlling logic/policy. For\n\tenabling proportional weight division of disk bandwidth in CFQ, set\n\tCONFIG_BFQ_GROUP_IOSCHED=y; for enabling throttling policy, set\n\tCONFIG_BLK_DEV_THROTTLING=y.\n\n\tSee Documentation/admin-guide/cgroup-v1/blkio-controller.rst for more information.\n\nconfig CGROUP_WRITEBACK\n\tbool\n\tdepends on MEMCG && BLK_CGROUP\n\tdefault y\n\nmenuconfig CGROUP_SCHED\n\tbool \"CPU controller\"\n\tdefault n\n\thelp\n\t  This feature lets CPU scheduler recognize task groups and control CPU\n\t  bandwidth allocation to such task groups. It uses cgroups to group\n\t  tasks.\n\nif CGROUP_SCHED\nconfig FAIR_GROUP_SCHED\n\tbool \"Group scheduling for SCHED_OTHER\"\n\tdepends on CGROUP_SCHED\n\tdefault CGROUP_SCHED\n\nconfig CFS_BANDWIDTH\n\tbool \"CPU bandwidth provisioning for FAIR_GROUP_SCHED\"\n\tdepends on FAIR_GROUP_SCHED\n\tdefault n\n\thelp\n\t  This option allows users to define CPU bandwidth rates (limits) for\n\t  tasks running within the fair group scheduler.  Groups with no limit\n\t  set are considered to be unconstrained and will run with no\n\t  restriction.\n\t  See Documentation/scheduler/sched-bwc.rst for more information.\n\nconfig RT_GROUP_SCHED\n\tbool \"Group scheduling for SCHED_RR/FIFO\"\n\tdepends on CGROUP_SCHED\n\tdefault n\n\thelp\n\t  This feature lets you explicitly allocate real CPU bandwidth\n\t  to task groups. If enabled, it will also make it impossible to\n\t  schedule realtime tasks for non-root users until you allocate\n\t  realtime bandwidth for them.\n\t  See Documentation/scheduler/sched-rt-group.rst for more information.\n\nendif #CGROUP_SCHED\n\nconfig SCHED_MM_CID\n\tdef_bool y\n\tdepends on SMP && RSEQ\n\nconfig UCLAMP_TASK_GROUP\n\tbool \"Utilization clamping per group of tasks\"\n\tdepends on CGROUP_SCHED\n\tdepends on UCLAMP_TASK\n\tdefault n\n\thelp\n\t  This feature enables the scheduler to track the clamped utilization\n\t  of each CPU based on RUNNABLE tasks currently scheduled on that CPU.\n\n\t  When this option is enabled, the user can specify a min and max\n\t  CPU bandwidth which is allowed for each single task in a group.\n\t  The max bandwidth allows to clamp the maximum frequency a task\n\t  can use, while the min bandwidth allows to define a minimum\n\t  frequency a task will always use.\n\n\t  When task group based utilization clamping is enabled, an eventually\n\t  specified task-specific clamp value is constrained by the cgroup\n\t  specified clamp value. Both minimum and maximum task clamping cannot\n\t  be bigger than the corresponding clamping defined at task group level.\n\n\t  If in doubt, say N.\n\nconfig CGROUP_PIDS\n\tbool \"PIDs controller\"\n\thelp\n\t  Provides enforcement of process number limits in the scope of a\n\t  cgroup. Any attempt to fork more processes than is allowed in the\n\t  cgroup will fail. PIDs are fundamentally a global resource because it\n\t  is fairly trivial to reach PID exhaustion before you reach even a\n\t  conservative kmemcg limit. As a result, it is possible to grind a\n\t  system to halt without being limited by other cgroup policies. The\n\t  PIDs controller is designed to stop this from happening.\n\n\t  It should be noted that organisational operations (such as attaching\n\t  to a cgroup hierarchy) will *not* be blocked by the PIDs controller,\n\t  since the PIDs limit only affects a process's ability to fork, not to\n\t  attach to a cgroup.\n\nconfig CGROUP_RDMA\n\tbool \"RDMA controller\"\n\thelp\n\t  Provides enforcement of RDMA resources defined by IB stack.\n\t  It is fairly easy for consumers to exhaust RDMA resources, which\n\t  can result into resource unavailability to other consumers.\n\t  RDMA controller is designed to stop this from happening.\n\t  Attaching processes with active RDMA resources to the cgroup\n\t  hierarchy is allowed even if can cross the hierarchy's limit.\n\nconfig CGROUP_FREEZER\n\tbool \"Freezer controller\"\n\thelp\n\t  Provides a way to freeze and unfreeze all tasks in a\n\t  cgroup.\n\n\t  This option affects the ORIGINAL cgroup interface. The cgroup2 memory\n\t  controller includes important in-kernel memory consumers per default.\n\n\t  If you're using cgroup2, say N.\n\nconfig CGROUP_HUGETLB\n\tbool \"HugeTLB controller\"\n\tdepends on HUGETLB_PAGE\n\tselect PAGE_COUNTER\n\tdefault n\n\thelp\n\t  Provides a cgroup controller for HugeTLB pages.\n\t  When you enable this, you can put a per cgroup limit on HugeTLB usage.\n\t  The limit is enforced during page fault. Since HugeTLB doesn't\n\t  support page reclaim, enforcing the limit at page fault time implies\n\t  that, the application will get SIGBUS signal if it tries to access\n\t  HugeTLB pages beyond its limit. This requires the application to know\n\t  beforehand how much HugeTLB pages it would require for its use. The\n\t  control group is tracked in the third page lru pointer. This means\n\t  that we cannot use the controller with huge page less than 3 pages.\n\nconfig CPUSETS\n\tbool \"Cpuset controller\"\n\tdepends on SMP\n\thelp\n\t  This option will let you create and manage CPUSETs which\n\t  allow dynamically partitioning a system into sets of CPUs and\n\t  Memory Nodes and assigning tasks to run only within those sets.\n\t  This is primarily useful on large SMP or NUMA systems.\n\n\t  Say N if unsure.\n\nconfig PROC_PID_CPUSET\n\tbool \"Include legacy /proc/<pid>/cpuset file\"\n\tdepends on CPUSETS\n\tdefault y\n\nconfig CGROUP_DEVICE\n\tbool \"Device controller\"\n\thelp\n\t  Provides a cgroup controller implementing whitelists for\n\t  devices which a process in the cgroup can mknod or open.\n\nconfig CGROUP_CPUACCT\n\tbool \"Simple CPU accounting controller\"\n\thelp\n\t  Provides a simple controller for monitoring the\n\t  total CPU consumed by the tasks in a cgroup.\n\nconfig CGROUP_PERF\n\tbool \"Perf controller\"\n\tdepends on PERF_EVENTS\n\thelp\n\t  This option extends the perf per-cpu mode to restrict monitoring\n\t  to threads which belong to the cgroup specified and run on the\n\t  designated cpu.  Or this can be used to have cgroup ID in samples\n\t  so that it can monitor performance events among cgroups.\n\n\t  Say N if unsure.\n\nconfig CGROUP_BPF\n\tbool \"Support for eBPF programs attached to cgroups\"\n\tdepends on BPF_SYSCALL\n\tselect SOCK_CGROUP_DATA\n\thelp\n\t  Allow attaching eBPF programs to a cgroup using the bpf(2)\n\t  syscall command BPF_PROG_ATTACH.\n\n\t  In which context these programs are accessed depends on the type\n\t  of attachment. For instance, programs that are attached using\n\t  BPF_CGROUP_INET_INGRESS will be executed on the ingress path of\n\t  inet sockets.\n\nconfig CGROUP_MISC\n\tbool \"Misc resource controller\"\n\tdefault n\n\thelp\n\t  Provides a controller for miscellaneous resources on a host.\n\n\t  Miscellaneous scalar resources are the resources on the host system\n\t  which cannot be abstracted like the other cgroups. This controller\n\t  tracks and limits the miscellaneous resources used by a process\n\t  attached to a cgroup hierarchy.\n\n\t  For more information, please check misc cgroup section in\n\t  /Documentation/admin-guide/cgroup-v2.rst.\n\nconfig CGROUP_DEBUG\n\tbool \"Debug controller\"\n\tdefault n\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  This option enables a simple controller that exports\n\t  debugging information about the cgroups framework. This\n\t  controller is for control cgroup debugging only. Its\n\t  interfaces are not stable.\n\n\t  Say N.\n\nconfig SOCK_CGROUP_DATA\n\tbool\n\tdefault n\n\nendif # CGROUPS\n\nmenuconfig NAMESPACES\n\tbool \"Namespaces support\" if EXPERT\n\tdepends on MULTIUSER\n\tdefault !EXPERT\n\thelp\n\t  Provides the way to make tasks work with different objects using\n\t  the same id. For example same IPC id may refer to different objects\n\t  or same user id or pid may refer to different tasks when used in\n\t  different namespaces.\n\nif NAMESPACES\n\nconfig UTS_NS\n\tbool \"UTS namespace\"\n\tdefault y\n\thelp\n\t  In this namespace tasks see different info provided with the\n\t  uname() system call\n\nconfig TIME_NS\n\tbool \"TIME namespace\"\n\tdepends on GENERIC_VDSO_TIME_NS\n\tdefault y\n\thelp\n\t  In this namespace boottime and monotonic clocks can be set.\n\t  The time will keep going with the same pace.\n\nconfig IPC_NS\n\tbool \"IPC namespace\"\n\tdepends on (SYSVIPC || POSIX_MQUEUE)\n\tdefault y\n\thelp\n\t  In this namespace tasks work with IPC ids which correspond to\n\t  different IPC objects in different namespaces.\n\nconfig USER_NS\n\tbool \"User namespace\"\n\tdefault n\n\thelp\n\t  This allows containers, i.e. vservers, to use user namespaces\n\t  to provide different user info for different servers.\n\n\t  When user namespaces are enabled in the kernel it is\n\t  recommended that the MEMCG option also be enabled and that\n\t  user-space use the memory control groups to limit the amount\n\t  of memory a memory unprivileged users can use.\n\n\t  If unsure, say N.\n\nconfig PID_NS\n\tbool \"PID Namespaces\"\n\tdefault y\n\thelp\n\t  Support process id namespaces.  This allows having multiple\n\t  processes with the same pid as long as they are in different\n\t  pid namespaces.  This is a building block of containers.\n\nconfig NET_NS\n\tbool \"Network namespace\"\n\tdepends on NET\n\tdefault y\n\thelp\n\t  Allow user space to create what appear to be multiple instances\n\t  of the network stack.\n\nendif # NAMESPACES\n\nconfig CHECKPOINT_RESTORE\n\tbool \"Checkpoint/restore support\"\n\tdepends on PROC_FS\n\tselect PROC_CHILDREN\n\tselect KCMP\n\tdefault n\n\thelp\n\t  Enables additional kernel features in a sake of checkpoint/restore.\n\t  In particular it adds auxiliary prctl codes to setup process text,\n\t  data and heap segment sizes, and a few additional /proc filesystem\n\t  entries.\n\n\t  If unsure, say N here.\n\nconfig SCHED_AUTOGROUP\n\tbool \"Automatic process group scheduling\"\n\tselect CGROUPS\n\tselect CGROUP_SCHED\n\tselect FAIR_GROUP_SCHED\n\thelp\n\t  This option optimizes the scheduler for common desktop workloads by\n\t  automatically creating and populating task groups.  This separation\n\t  of workloads isolates aggressive CPU burners (like build jobs) from\n\t  desktop applications.  Task group autogeneration is currently based\n\t  upon task session.\n\nconfig RELAY\n\tbool \"Kernel->user space relay support (formerly relayfs)\"\n\tselect IRQ_WORK\n\thelp\n\t  This option enables support for relay interface support in\n\t  certain file systems (such as debugfs).\n\t  It is designed to provide an efficient mechanism for tools and\n\t  facilities to relay large amounts of data from kernel space to\n\t  user space.\n\n\t  If unsure, say N.\n\nconfig BLK_DEV_INITRD\n\tbool \"Initial RAM filesystem and RAM disk (initramfs/initrd) support\"\n\thelp\n\t  The initial RAM filesystem is a ramfs which is loaded by the\n\t  boot loader (loadlin or lilo) and that is mounted as root\n\t  before the normal boot procedure. It is typically used to\n\t  load modules needed to mount the \"real\" root file system,\n\t  etc. See <file:Documentation/admin-guide/initrd.rst> for details.\n\n\t  If RAM disk support (BLK_DEV_RAM) is also included, this\n\t  also enables initial RAM disk (initrd) support and adds\n\t  15 Kbytes (more on some other architectures) to the kernel size.\n\n\t  If unsure say Y.\n\nif BLK_DEV_INITRD\n\nsource \"usr/Kconfig\"\n\nendif\n\nconfig BOOT_CONFIG\n\tbool \"Boot config support\"\n\tselect BLK_DEV_INITRD if !BOOT_CONFIG_EMBED\n\thelp\n\t  Extra boot config allows system admin to pass a config file as\n\t  complemental extension of kernel cmdline when booting.\n\t  The boot config file must be attached at the end of initramfs\n\t  with checksum, size and magic word.\n\t  See <file:Documentation/admin-guide/bootconfig.rst> for details.\n\n\t  If unsure, say Y.\n\nconfig BOOT_CONFIG_FORCE\n\tbool \"Force unconditional bootconfig processing\"\n\tdepends on BOOT_CONFIG\n\tdefault y if BOOT_CONFIG_EMBED\n\thelp\n\t  With this Kconfig option set, BOOT_CONFIG processing is carried\n\t  out even when the \"bootconfig\" kernel-boot parameter is omitted.\n\t  In fact, with this Kconfig option set, there is no way to\n\t  make the kernel ignore the BOOT_CONFIG-supplied kernel-boot\n\t  parameters.\n\n\t  If unsure, say N.\n\nconfig BOOT_CONFIG_EMBED\n\tbool \"Embed bootconfig file in the kernel\"\n\tdepends on BOOT_CONFIG\n\thelp\n\t  Embed a bootconfig file given by BOOT_CONFIG_EMBED_FILE in the\n\t  kernel. Usually, the bootconfig file is loaded with the initrd\n\t  image. But if the system doesn't support initrd, this option will\n\t  help you by embedding a bootconfig file while building the kernel.\n\n\t  If unsure, say N.\n\nconfig BOOT_CONFIG_EMBED_FILE\n\tstring \"Embedded bootconfig file path\"\n\tdepends on BOOT_CONFIG_EMBED\n\thelp\n\t  Specify a bootconfig file which will be embedded to the kernel.\n\t  This bootconfig will be used if there is no initrd or no other\n\t  bootconfig in the initrd.\n\nconfig INITRAMFS_PRESERVE_MTIME\n\tbool \"Preserve cpio archive mtimes in initramfs\"\n\tdefault y\n\thelp\n\t  Each entry in an initramfs cpio archive carries an mtime value. When\n\t  enabled, extracted cpio items take this mtime, with directory mtime\n\t  setting deferred until after creation of any child entries.\n\n\t  If unsure, say Y.\n\nchoice\n\tprompt \"Compiler optimization level\"\n\tdefault CC_OPTIMIZE_FOR_PERFORMANCE\n\nconfig CC_OPTIMIZE_FOR_PERFORMANCE\n\tbool \"Optimize for performance (-O2)\"\n\thelp\n\t  This is the default optimization level for the kernel, building\n\t  with the \"-O2\" compiler flag for best performance and most\n\t  helpful compile-time warnings.\n\nconfig CC_OPTIMIZE_FOR_SIZE\n\tbool \"Optimize for size (-Os)\"\n\thelp\n\t  Choosing this option will pass \"-Os\" to your compiler resulting\n\t  in a smaller kernel.\n\nendchoice\n\nconfig HAVE_LD_DEAD_CODE_DATA_ELIMINATION\n\tbool\n\thelp\n\t  This requires that the arch annotates or otherwise protects\n\t  its external entry points from being discarded. Linker scripts\n\t  must also merge .text.*, .data.*, and .bss.* correctly into\n\t  output sections. Care must be taken not to pull in unrelated\n\t  sections (e.g., '.text.init'). Typically '.' in section names\n\t  is used to distinguish them from label names / C identifiers.\n\nconfig LD_DEAD_CODE_DATA_ELIMINATION\n\tbool \"Dead code and data elimination (EXPERIMENTAL)\"\n\tdepends on HAVE_LD_DEAD_CODE_DATA_ELIMINATION\n\tdepends on EXPERT\n\tdepends on $(cc-option,-ffunction-sections -fdata-sections)\n\tdepends on $(ld-option,--gc-sections)\n\thelp\n\t  Enable this if you want to do dead code and data elimination with\n\t  the linker by compiling with -ffunction-sections -fdata-sections,\n\t  and linking with --gc-sections.\n\n\t  This can reduce on disk and in-memory size of the kernel\n\t  code and static data, particularly for small configs and\n\t  on small systems. This has the possibility of introducing\n\t  silently broken kernel if the required annotations are not\n\t  present. This option is not well tested yet, so use at your\n\t  own risk.\n\nconfig LD_ORPHAN_WARN\n\tdef_bool y\n\tdepends on ARCH_WANT_LD_ORPHAN_WARN\n\tdepends on $(ld-option,--orphan-handling=warn)\n\tdepends on $(ld-option,--orphan-handling=error)\n\nconfig LD_ORPHAN_WARN_LEVEL\n        string\n        depends on LD_ORPHAN_WARN\n        default \"error\" if WERROR\n        default \"warn\"\n\nconfig SYSCTL\n\tbool\n\nconfig HAVE_UID16\n\tbool\n\nconfig SYSCTL_EXCEPTION_TRACE\n\tbool\n\thelp\n\t  Enable support for /proc/sys/debug/exception-trace.\n\nconfig SYSCTL_ARCH_UNALIGN_NO_WARN\n\tbool\n\thelp\n\t  Enable support for /proc/sys/kernel/ignore-unaligned-usertrap\n\t  Allows arch to define/use @no_unaligned_warning to possibly warn\n\t  about unaligned access emulation going on under the hood.\n\nconfig SYSCTL_ARCH_UNALIGN_ALLOW\n\tbool\n\thelp\n\t  Enable support for /proc/sys/kernel/unaligned-trap\n\t  Allows arches to define/use @unaligned_enabled to runtime toggle\n\t  the unaligned access emulation.\n\t  see arch/parisc/kernel/unaligned.c for reference\n\nconfig HAVE_PCSPKR_PLATFORM\n\tbool\n\n# interpreter that classic socket filters depend on\nconfig BPF\n\tbool\n\tselect CRYPTO_LIB_SHA1\n\nmenuconfig EXPERT\n\tbool \"Configure standard kernel features (expert users)\"\n\t# Unhide debug options, to make the on-by-default options visible\n\tselect DEBUG_KERNEL\n\thelp\n\t  This option allows certain base kernel options and settings\n\t  to be disabled or tweaked. This is for specialized\n\t  environments which can tolerate a \"non-standard\" kernel.\n\t  Only use this if you really know what you are doing.\n\nconfig UID16\n\tbool \"Enable 16-bit UID system calls\" if EXPERT\n\tdepends on HAVE_UID16 && MULTIUSER\n\tdefault y\n\thelp\n\t  This enables the legacy 16-bit UID syscall wrappers.\n\nconfig MULTIUSER\n\tbool \"Multiple users, groups and capabilities support\" if EXPERT\n\tdefault y\n\thelp\n\t  This option enables support for non-root users, groups and\n\t  capabilities.\n\n\t  If you say N here, all processes will run with UID 0, GID 0, and all\n\t  possible capabilities.  Saying N here also compiles out support for\n\t  system calls related to UIDs, GIDs, and capabilities, such as setuid,\n\t  setgid, and capset.\n\n\t  If unsure, say Y here.\n\nconfig SGETMASK_SYSCALL\n\tbool \"sgetmask/ssetmask syscalls support\" if EXPERT\n\tdef_bool PARISC || M68K || PPC || MIPS || X86 || SPARC || MICROBLAZE || SUPERH\n\thelp\n\t  sys_sgetmask and sys_ssetmask are obsolete system calls\n\t  no longer supported in libc but still enabled by default in some\n\t  architectures.\n\n\t  If unsure, leave the default option here.\n\nconfig SYSFS_SYSCALL\n\tbool \"Sysfs syscall support\" if EXPERT\n\tdefault y\n\thelp\n\t  sys_sysfs is an obsolete system call no longer supported in libc.\n\t  Note that disabling this option is more secure but might break\n\t  compatibility with some systems.\n\n\t  If unsure say Y here.\n\nconfig FHANDLE\n\tbool \"open by fhandle syscalls\" if EXPERT\n\tselect EXPORTFS\n\tdefault y\n\thelp\n\t  If you say Y here, a user level program will be able to map\n\t  file names to handle and then later use the handle for\n\t  different file system operations. This is useful in implementing\n\t  userspace file servers, which now track files using handles instead\n\t  of names. The handle would remain the same even if file names\n\t  get renamed. Enables open_by_handle_at(2) and name_to_handle_at(2)\n\t  syscalls.\n\nconfig POSIX_TIMERS\n\tbool \"Posix Clocks & timers\" if EXPERT\n\tdefault y\n\thelp\n\t  This includes native support for POSIX timers to the kernel.\n\t  Some embedded systems have no use for them and therefore they\n\t  can be configured out to reduce the size of the kernel image.\n\n\t  When this option is disabled, the following syscalls won't be\n\t  available: timer_create, timer_gettime: timer_getoverrun,\n\t  timer_settime, timer_delete, clock_adjtime, getitimer,\n\t  setitimer, alarm. Furthermore, the clock_settime, clock_gettime,\n\t  clock_getres and clock_nanosleep syscalls will be limited to\n\t  CLOCK_REALTIME, CLOCK_MONOTONIC and CLOCK_BOOTTIME only.\n\n\t  If unsure say y.\n\nconfig PRINTK\n\tdefault y\n\tbool \"Enable support for printk\" if EXPERT\n\tselect IRQ_WORK\n\thelp\n\t  This option enables normal printk support. Removing it\n\t  eliminates most of the message strings from the kernel image\n\t  and makes the kernel more or less silent. As this makes it\n\t  very difficult to diagnose system problems, saying N here is\n\t  strongly discouraged.\n\nconfig BUG\n\tbool \"BUG() support\" if EXPERT\n\tdefault y\n\thelp\n\t  Disabling this option eliminates support for BUG and WARN, reducing\n\t  the size of your kernel image and potentially quietly ignoring\n\t  numerous fatal conditions. You should only consider disabling this\n\t  option for embedded systems with no facilities for reporting errors.\n\t  Just say Y.\n\nconfig ELF_CORE\n\tdepends on COREDUMP\n\tdefault y\n\tbool \"Enable ELF core dumps\" if EXPERT\n\thelp\n\t  Enable support for generating core dumps. Disabling saves about 4k.\n\n\nconfig PCSPKR_PLATFORM\n\tbool \"Enable PC-Speaker support\" if EXPERT\n\tdepends on HAVE_PCSPKR_PLATFORM\n\tselect I8253_LOCK\n\tdefault y\n\thelp\n\t  This option allows to disable the internal PC-Speaker\n\t  support, saving some memory.\n\nconfig BASE_FULL\n\tdefault y\n\tbool \"Enable full-sized data structures for core\" if EXPERT\n\thelp\n\t  Disabling this option reduces the size of miscellaneous core\n\t  kernel data structures. This saves memory on small machines,\n\t  but may reduce performance.\n\nconfig FUTEX\n\tbool \"Enable futex support\" if EXPERT\n\tdepends on !(SPARC32 && SMP)\n\tdefault y\n\timply RT_MUTEXES\n\thelp\n\t  Disabling this option will cause the kernel to be built without\n\t  support for \"fast userspace mutexes\".  The resulting kernel may not\n\t  run glibc-based applications correctly.\n\nconfig FUTEX_PI\n\tbool\n\tdepends on FUTEX && RT_MUTEXES\n\tdefault y\n\nconfig EPOLL\n\tbool \"Enable eventpoll support\" if EXPERT\n\tdefault y\n\thelp\n\t  Disabling this option will cause the kernel to be built without\n\t  support for epoll family of system calls.\n\nconfig SIGNALFD\n\tbool \"Enable signalfd() system call\" if EXPERT\n\tdefault y\n\thelp\n\t  Enable the signalfd() system call that allows to receive signals\n\t  on a file descriptor.\n\n\t  If unsure, say Y.\n\nconfig TIMERFD\n\tbool \"Enable timerfd() system call\" if EXPERT\n\tdefault y\n\thelp\n\t  Enable the timerfd() system call that allows to receive timer\n\t  events on a file descriptor.\n\n\t  If unsure, say Y.\n\nconfig EVENTFD\n\tbool \"Enable eventfd() system call\" if EXPERT\n\tdefault y\n\thelp\n\t  Enable the eventfd() system call that allows to receive both\n\t  kernel notification (ie. KAIO) or userspace notifications.\n\n\t  If unsure, say Y.\n\nconfig SHMEM\n\tbool \"Use full shmem filesystem\" if EXPERT\n\tdefault y\n\tdepends on MMU\n\thelp\n\t  The shmem is an internal filesystem used to manage shared memory.\n\t  It is backed by swap and manages resource limits. It is also exported\n\t  to userspace as tmpfs if TMPFS is enabled. Disabling this\n\t  option replaces shmem and tmpfs with the much simpler ramfs code,\n\t  which may be appropriate on small systems without swap.\n\nconfig AIO\n\tbool \"Enable AIO support\" if EXPERT\n\tdefault y\n\thelp\n\t  This option enables POSIX asynchronous I/O which may by used\n\t  by some high performance threaded applications. Disabling\n\t  this option saves about 7k.\n\nconfig IO_URING\n\tbool \"Enable IO uring support\" if EXPERT\n\tselect IO_WQ\n\tdefault y\n\thelp\n\t  This option enables support for the io_uring interface, enabling\n\t  applications to submit and complete IO through submission and\n\t  completion rings that are shared between the kernel and application.\n\nconfig ADVISE_SYSCALLS\n\tbool \"Enable madvise/fadvise syscalls\" if EXPERT\n\tdefault y\n\thelp\n\t  This option enables the madvise and fadvise syscalls, used by\n\t  applications to advise the kernel about their future memory or file\n\t  usage, improving performance. If building an embedded system where no\n\t  applications use these syscalls, you can disable this option to save\n\t  space.\n\nconfig MEMBARRIER\n\tbool \"Enable membarrier() system call\" if EXPERT\n\tdefault y\n\thelp\n\t  Enable the membarrier() system call that allows issuing memory\n\t  barriers across all running threads, which can be used to distribute\n\t  the cost of user-space memory barriers asymmetrically by transforming\n\t  pairs of memory barriers into pairs consisting of membarrier() and a\n\t  compiler barrier.\n\n\t  If unsure, say Y.\n\nconfig KALLSYMS\n\tbool \"Load all symbols for debugging/ksymoops\" if EXPERT\n\tdefault y\n\thelp\n\t  Say Y here to let the kernel print out symbolic crash information and\n\t  symbolic stack backtraces. This increases the size of the kernel\n\t  somewhat, as all symbols have to be loaded into the kernel image.\n\nconfig KALLSYMS_SELFTEST\n\tbool \"Test the basic functions and performance of kallsyms\"\n\tdepends on KALLSYMS\n\tdefault n\n\thelp\n\t  Test the basic functions and performance of some interfaces, such as\n\t  kallsyms_lookup_name. It also calculates the compression rate of the\n\t  kallsyms compression algorithm for the current symbol set.\n\n\t  Start self-test automatically after system startup. Suggest executing\n\t  \"dmesg | grep kallsyms_selftest\" to collect test results. \"finish\" is\n\t  displayed in the last line, indicating that the test is complete.\n\nconfig KALLSYMS_ALL\n\tbool \"Include all symbols in kallsyms\"\n\tdepends on DEBUG_KERNEL && KALLSYMS\n\thelp\n\t  Normally kallsyms only contains the symbols of functions for nicer\n\t  OOPS messages and backtraces (i.e., symbols from the text and inittext\n\t  sections). This is sufficient for most cases. And only if you want to\n\t  enable kernel live patching, or other less common use cases (e.g.,\n\t  when a debugger is used) all symbols are required (i.e., names of\n\t  variables from the data sections, etc).\n\n\t  This option makes sure that all symbols are loaded into the kernel\n\t  image (i.e., symbols from all sections) in cost of increased kernel\n\t  size (depending on the kernel configuration, it may be 300KiB or\n\t  something like this).\n\n\t  Say N unless you really need all symbols, or kernel live patching.\n\nconfig KALLSYMS_ABSOLUTE_PERCPU\n\tbool\n\tdepends on KALLSYMS\n\tdefault X86_64 && SMP\n\nconfig KALLSYMS_BASE_RELATIVE\n\tbool\n\tdepends on KALLSYMS\n\tdefault !IA64\n\thelp\n\t  Instead of emitting them as absolute values in the native word size,\n\t  emit the symbol references in the kallsyms table as 32-bit entries,\n\t  each containing a relative value in the range [base, base + U32_MAX]\n\t  or, when KALLSYMS_ABSOLUTE_PERCPU is in effect, each containing either\n\t  an absolute value in the range [0, S32_MAX] or a relative value in the\n\t  range [base, base + S32_MAX], where base is the lowest relative symbol\n\t  address encountered in the image.\n\n\t  On 64-bit builds, this reduces the size of the address table by 50%,\n\t  but more importantly, it results in entries whose values are build\n\t  time constants, and no relocation pass is required at runtime to fix\n\t  up the entries based on the runtime load address of the kernel.\n\n# end of the \"standard kernel features (expert users)\" menu\n\n# syscall, maps, verifier\n\nconfig ARCH_HAS_MEMBARRIER_CALLBACKS\n\tbool\n\nconfig ARCH_HAS_MEMBARRIER_SYNC_CORE\n\tbool\n\nconfig KCMP\n\tbool \"Enable kcmp() system call\" if EXPERT\n\thelp\n\t  Enable the kernel resource comparison system call. It provides\n\t  user-space with the ability to compare two processes to see if they\n\t  share a common resource, such as a file descriptor or even virtual\n\t  memory space.\n\n\t  If unsure, say N.\n\nconfig RSEQ\n\tbool \"Enable rseq() system call\" if EXPERT\n\tdefault y\n\tdepends on HAVE_RSEQ\n\tselect MEMBARRIER\n\thelp\n\t  Enable the restartable sequences system call. It provides a\n\t  user-space cache for the current CPU number value, which\n\t  speeds up getting the current CPU number from user-space,\n\t  as well as an ABI to speed up user-space operations on\n\t  per-CPU data.\n\n\t  If unsure, say Y.\n\nconfig CACHESTAT_SYSCALL\n\tbool \"Enable cachestat() system call\" if EXPERT\n\tdefault y\n\thelp\n\t  Enable the cachestat system call, which queries the page cache\n\t  statistics of a file (number of cached pages, dirty pages,\n\t  pages marked for writeback, (recently) evicted pages).\n\n\t  If unsure say Y here.\n\nconfig DEBUG_RSEQ\n\tdefault n\n\tbool \"Enabled debugging of rseq() system call\" if EXPERT\n\tdepends on RSEQ && DEBUG_KERNEL\n\thelp\n\t  Enable extra debugging checks for the rseq system call.\n\n\t  If unsure, say N.\n\nconfig HAVE_PERF_EVENTS\n\tbool\n\thelp\n\t  See tools/perf/design.txt for details.\n\nconfig GUEST_PERF_EVENTS\n\tbool\n\tdepends on HAVE_PERF_EVENTS\n\nconfig PERF_USE_VMALLOC\n\tbool\n\thelp\n\t  See tools/perf/design.txt for details\n\nconfig PC104\n\tbool \"PC/104 support\" if EXPERT\n\thelp\n\t  Expose PC/104 form factor device drivers and options available for\n\t  selection and configuration. Enable this option if your target\n\t  machine has a PC/104 bus.\n\nmenu \"Kernel Performance Events And Counters\"\n\nconfig PERF_EVENTS\n\tbool \"Kernel performance events and counters\"\n\tdefault y if PROFILING\n\tdepends on HAVE_PERF_EVENTS\n\tselect IRQ_WORK\n\thelp\n\t  Enable kernel support for various performance events provided\n\t  by software and hardware.\n\n\t  Software events are supported either built-in or via the\n\t  use of generic tracepoints.\n\n\t  Most modern CPUs support performance events via performance\n\t  counter registers. These registers count the number of certain\n\t  types of hw events: such as instructions executed, cachemisses\n\t  suffered, or branches mis-predicted - without slowing down the\n\t  kernel or applications. These registers can also trigger interrupts\n\t  when a threshold number of events have passed - and can thus be\n\t  used to profile the code that runs on that CPU.\n\n\t  The Linux Performance Event subsystem provides an abstraction of\n\t  these software and hardware event capabilities, available via a\n\t  system call and used by the \"perf\" utility in tools/perf/. It\n\t  provides per task and per CPU counters, and it provides event\n\t  capabilities on top of those.\n\n\t  Say Y if unsure.\n\nconfig DEBUG_PERF_USE_VMALLOC\n\tdefault n\n\tbool \"Debug: use vmalloc to back perf mmap() buffers\"\n\tdepends on PERF_EVENTS && DEBUG_KERNEL && !PPC\n\tselect PERF_USE_VMALLOC\n\thelp\n\t  Use vmalloc memory to back perf mmap() buffers.\n\n\t  Mostly useful for debugging the vmalloc code on platforms\n\t  that don't require it.\n\n\t  Say N if unsure.\n\nendmenu\n\nconfig SYSTEM_DATA_VERIFICATION\n\tdef_bool n\n\tselect SYSTEM_TRUSTED_KEYRING\n\tselect KEYS\n\tselect CRYPTO\n\tselect CRYPTO_RSA\n\tselect ASYMMETRIC_KEY_TYPE\n\tselect ASYMMETRIC_PUBLIC_KEY_SUBTYPE\n\tselect ASN1\n\tselect OID_REGISTRY\n\tselect X509_CERTIFICATE_PARSER\n\tselect PKCS7_MESSAGE_PARSER\n\thelp\n\t  Provide PKCS#7 message verification using the contents of the system\n\t  trusted keyring to provide public keys.  This then can be used for\n\t  module verification, kexec image verification and firmware blob\n\t  verification.\n\nconfig PROFILING\n\tbool \"Profiling support\"\n\thelp\n\t  Say Y here to enable the extended profiling support mechanisms used\n\t  by profilers.\n\nconfig RUST\n\tbool \"Rust support\"\n\tdepends on HAVE_RUST\n\tdepends on RUST_IS_AVAILABLE\n\tdepends on !MODVERSIONS\n\tdepends on !GCC_PLUGINS\n\tdepends on !RANDSTRUCT\n\tdepends on !DEBUG_INFO_BTF || PAHOLE_HAS_LANG_EXCLUDE\n\tselect CONSTRUCTORS\n\thelp\n\t  Enables Rust support in the kernel.\n\n\t  This allows other Rust-related options, like drivers written in Rust,\n\t  to be selected.\n\n\t  It is also required to be able to load external kernel modules\n\t  written in Rust.\n\n\t  See Documentation/rust/ for more information.\n\n\t  If unsure, say N.\n\nconfig RUSTC_VERSION_TEXT\n\tstring\n\tdepends on RUST\n\tdefault $(shell,command -v $(RUSTC) >/dev/null 2>&1 && $(RUSTC) --version || echo n)\n\nconfig BINDGEN_VERSION_TEXT\n\tstring\n\tdepends on RUST\n\tdefault $(shell,command -v $(BINDGEN) >/dev/null 2>&1 && $(BINDGEN) --version || echo n)\n\n#\n# Place an empty function call at each tracepoint site. Can be\n# dynamically changed for a probe function.\n#\nconfig TRACEPOINTS\n\tbool\n\nsource \"kernel/Kconfig.kexec\"\n\nendmenu\t\t# General setup\n\nsource \"arch/Kconfig\"\n\nconfig RT_MUTEXES\n\tbool\n\tdefault y if PREEMPT_RT\n\nconfig BASE_SMALL\n\tint\n\tdefault 0 if BASE_FULL\n\tdefault 1 if !BASE_FULL\n\nconfig MODULE_SIG_FORMAT\n\tdef_bool n\n\tselect SYSTEM_DATA_VERIFICATION\n\nsource \"kernel/module/Kconfig\"\n\nconfig INIT_ALL_POSSIBLE\n\tbool\n\thelp\n\t  Back when each arch used to define their own cpu_online_mask and\n\t  cpu_possible_mask, some of them chose to initialize cpu_possible_mask\n\t  with all 1s, and others with all 0s.  When they were centralised,\n\t  it was better to provide this option than to break all the archs\n\t  and have several arch maintainers pursuing me down dark alleys.\n\nsource \"block/Kconfig\"\n\nconfig PREEMPT_NOTIFIERS\n\tbool\n\nconfig PADATA\n\tdepends on SMP\n\tbool\n\nconfig ASN1\n\ttristate\n\thelp\n\t  Build a simple ASN.1 grammar compiler that produces a bytecode output\n\t  that can be interpreted by the ASN.1 stream decoder and used to\n\t  inform it as to what tags are to be expected in a stream and what\n\t  functions to call on what tags.\n\nsource \"kernel/Kconfig.locks\"\n\nconfig ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tbool\n\nconfig ARCH_HAS_SYNC_CORE_BEFORE_USERMODE\n\tbool\n\n# It may be useful for an architecture to override the definitions of the\n# SYSCALL_DEFINE() and __SYSCALL_DEFINEx() macros in <linux/syscalls.h>\n# and the COMPAT_ variants in <linux/compat.h>, in particular to use a\n# different calling convention for syscalls. They can also override the\n# macros for not-implemented syscalls in kernel/sys_ni.c and\n# kernel/time/posix-stubs.c. All these overrides need to be available in\n# <asm/syscall_wrapper.h>.\nconfig ARCH_HAS_SYSCALL_WRAPPER\n\tdef_bool n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}