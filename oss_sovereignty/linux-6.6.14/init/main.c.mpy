{
  "module_name": "main.c",
  "hash_id": "e570e78d1edf493cd2e774ca35e0a71929e5fe5c667fc54c0b492b3601604984",
  "original_prompt": "Ingested from linux-6.6.14/init/main.c",
  "human_readable_source": "\n \n\n#define DEBUG\t\t \n\n#include <linux/types.h>\n#include <linux/extable.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/binfmts.h>\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n#include <linux/stackprotector.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/initrd.h>\n#include <linux/memblock.h>\n#include <linux/acpi.h>\n#include <linux/bootconfig.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kmod.h>\n#include <linux/kprobes.h>\n#include <linux/kmsan.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel_stat.h>\n#include <linux/start_kernel.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/profile.h>\n#include <linux/kfence.h>\n#include <linux/rcupdate.h>\n#include <linux/srcu.h>\n#include <linux/moduleparam.h>\n#include <linux/kallsyms.h>\n#include <linux/buildid.h>\n#include <linux/writeback.h>\n#include <linux/cpu.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/efi.h>\n#include <linux/tick.h>\n#include <linux/sched/isolation.h>\n#include <linux/interrupt.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/unistd.h>\n#include <linux/utsname.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/key.h>\n#include <linux/debug_locks.h>\n#include <linux/debugobjects.h>\n#include <linux/lockdep.h>\n#include <linux/kmemleak.h>\n#include <linux/padata.h>\n#include <linux/pid_namespace.h>\n#include <linux/device/driver.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/sched/init.h>\n#include <linux/signal.h>\n#include <linux/idr.h>\n#include <linux/kgdb.h>\n#include <linux/ftrace.h>\n#include <linux/async.h>\n#include <linux/shmem_fs.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/pti.h>\n#include <linux/blkdev.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/context_tracking.h>\n#include <linux/random.h>\n#include <linux/list.h>\n#include <linux/integrity.h>\n#include <linux/proc_ns.h>\n#include <linux/io.h>\n#include <linux/cache.h>\n#include <linux/rodata_test.h>\n#include <linux/jump_label.h>\n#include <linux/kcsan.h>\n#include <linux/init_syscalls.h>\n#include <linux/stackdepot.h>\n#include <linux/randomize_kstack.h>\n#include <net/net_namespace.h>\n\n#include <asm/io.h>\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/initcall.h>\n\n#include <kunit/test.h>\n\nstatic int kernel_init(void *);\n\n \nbool early_boot_irqs_disabled __read_mostly;\n\nenum system_states system_state __read_mostly;\nEXPORT_SYMBOL(system_state);\n\n \n#define MAX_INIT_ARGS CONFIG_INIT_ENV_ARG_LIMIT\n#define MAX_INIT_ENVS CONFIG_INIT_ENV_ARG_LIMIT\n\n \nvoid (*__initdata late_time_init)(void);\n\n \nchar __initdata boot_command_line[COMMAND_LINE_SIZE];\n \nchar *saved_command_line __ro_after_init;\nunsigned int saved_command_line_len __ro_after_init;\n \nstatic char *static_command_line;\n \nstatic char *extra_command_line;\n \nstatic char *extra_init_args;\n\n#ifdef CONFIG_BOOT_CONFIG\n \nstatic bool bootconfig_found;\nstatic size_t initargs_offs;\n#else\n# define bootconfig_found false\n# define initargs_offs 0\n#endif\n\nstatic char *execute_command;\nstatic char *ramdisk_execute_command = \"/init\";\n\n \nbool static_key_initialized __read_mostly;\nEXPORT_SYMBOL_GPL(static_key_initialized);\n\n \nunsigned int reset_devices;\nEXPORT_SYMBOL(reset_devices);\n\nstatic int __init set_reset_devices(char *str)\n{\n\treset_devices = 1;\n\treturn 1;\n}\n\n__setup(\"reset_devices\", set_reset_devices);\n\nstatic const char *argv_init[MAX_INIT_ARGS+2] = { \"init\", NULL, };\nconst char *envp_init[MAX_INIT_ENVS+2] = { \"HOME=/\", \"TERM=linux\", NULL, };\nstatic const char *panic_later, *panic_param;\n\nstatic bool __init obsolete_checksetup(char *line)\n{\n\tconst struct obs_kernel_param *p;\n\tbool had_early_param = false;\n\n\tp = __setup_start;\n\tdo {\n\t\tint n = strlen(p->str);\n\t\tif (parameqn(line, p->str, n)) {\n\t\t\tif (p->early) {\n\t\t\t\t \n\t\t\t\tif (line[n] == '\\0' || line[n] == '=')\n\t\t\t\t\thad_early_param = true;\n\t\t\t} else if (!p->setup_func) {\n\t\t\t\tpr_warn(\"Parameter %s is obsolete, ignored\\n\",\n\t\t\t\t\tp->str);\n\t\t\t\treturn true;\n\t\t\t} else if (p->setup_func(line + n))\n\t\t\t\treturn true;\n\t\t}\n\t\tp++;\n\t} while (p < __setup_end);\n\n\treturn had_early_param;\n}\n\n \nunsigned long loops_per_jiffy = (1<<12);\nEXPORT_SYMBOL(loops_per_jiffy);\n\nstatic int __init debug_kernel(char *str)\n{\n\tconsole_loglevel = CONSOLE_LOGLEVEL_DEBUG;\n\treturn 0;\n}\n\nstatic int __init quiet_kernel(char *str)\n{\n\tconsole_loglevel = CONSOLE_LOGLEVEL_QUIET;\n\treturn 0;\n}\n\nearly_param(\"debug\", debug_kernel);\nearly_param(\"quiet\", quiet_kernel);\n\nstatic int __init loglevel(char *str)\n{\n\tint newlevel;\n\n\t \n\tif (get_option(&str, &newlevel)) {\n\t\tconsole_loglevel = newlevel;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nearly_param(\"loglevel\", loglevel);\n\n#ifdef CONFIG_BLK_DEV_INITRD\nstatic void * __init get_boot_config_from_initrd(size_t *_size)\n{\n\tu32 size, csum;\n\tchar *data;\n\tu32 *hdr;\n\tint i;\n\n\tif (!initrd_end)\n\t\treturn NULL;\n\n\tdata = (char *)initrd_end - BOOTCONFIG_MAGIC_LEN;\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!memcmp(data, BOOTCONFIG_MAGIC, BOOTCONFIG_MAGIC_LEN))\n\t\t\tgoto found;\n\t\tdata--;\n\t}\n\treturn NULL;\n\nfound:\n\thdr = (u32 *)(data - 8);\n\tsize = le32_to_cpu(hdr[0]);\n\tcsum = le32_to_cpu(hdr[1]);\n\n\tdata = ((void *)hdr) - size;\n\tif ((unsigned long)data < initrd_start) {\n\t\tpr_err(\"bootconfig size %d is greater than initrd size %ld\\n\",\n\t\t\tsize, initrd_end - initrd_start);\n\t\treturn NULL;\n\t}\n\n\tif (xbc_calc_checksum(data, size) != csum) {\n\t\tpr_err(\"bootconfig checksum failed\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tinitrd_end = (unsigned long)data;\n\tif (_size)\n\t\t*_size = size;\n\n\treturn data;\n}\n#else\nstatic void * __init get_boot_config_from_initrd(size_t *_size)\n{\n\treturn NULL;\n}\n#endif\n\n#ifdef CONFIG_BOOT_CONFIG\n\nstatic char xbc_namebuf[XBC_KEYLEN_MAX] __initdata;\n\n#define rest(dst, end) ((end) > (dst) ? (end) - (dst) : 0)\n\nstatic int __init xbc_snprint_cmdline(char *buf, size_t size,\n\t\t\t\t      struct xbc_node *root)\n{\n\tstruct xbc_node *knode, *vnode;\n\tchar *end = buf + size;\n\tconst char *val;\n\tint ret;\n\n\txbc_node_for_each_key_value(root, knode, val) {\n\t\tret = xbc_node_compose_key_after(root, knode,\n\t\t\t\t\txbc_namebuf, XBC_KEYLEN_MAX);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tvnode = xbc_node_get_child(knode);\n\t\tif (!vnode) {\n\t\t\tret = snprintf(buf, rest(buf, end), \"%s \", xbc_namebuf);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbuf += ret;\n\t\t\tcontinue;\n\t\t}\n\t\txbc_array_for_each_value(vnode, val) {\n\t\t\tret = snprintf(buf, rest(buf, end), \"%s=\\\"%s\\\" \",\n\t\t\t\t       xbc_namebuf, val);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbuf += ret;\n\t\t}\n\t}\n\n\treturn buf - (end - size);\n}\n#undef rest\n\n \nstatic char * __init xbc_make_cmdline(const char *key)\n{\n\tstruct xbc_node *root;\n\tchar *new_cmdline;\n\tint ret, len = 0;\n\n\troot = xbc_find_node(key);\n\tif (!root)\n\t\treturn NULL;\n\n\t \n\tlen = xbc_snprint_cmdline(NULL, 0, root);\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tnew_cmdline = memblock_alloc(len + 1, SMP_CACHE_BYTES);\n\tif (!new_cmdline) {\n\t\tpr_err(\"Failed to allocate memory for extra kernel cmdline.\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = xbc_snprint_cmdline(new_cmdline, len + 1, root);\n\tif (ret < 0 || ret > len) {\n\t\tpr_err(\"Failed to print extra kernel cmdline.\\n\");\n\t\tmemblock_free(new_cmdline, len + 1);\n\t\treturn NULL;\n\t}\n\n\treturn new_cmdline;\n}\n\nstatic int __init bootconfig_params(char *param, char *val,\n\t\t\t\t    const char *unused, void *arg)\n{\n\tif (strcmp(param, \"bootconfig\") == 0) {\n\t\tbootconfig_found = true;\n\t}\n\treturn 0;\n}\n\nstatic int __init warn_bootconfig(char *str)\n{\n\t \n\treturn 0;\n}\n\nstatic void __init setup_boot_config(void)\n{\n\tstatic char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;\n\tconst char *msg, *data;\n\tint pos, ret;\n\tsize_t size;\n\tchar *err;\n\n\t \n\tdata = get_boot_config_from_initrd(&size);\n\t \n\tif (!data)\n\t\tdata = xbc_get_embedded_bootconfig(&size);\n\n\tstrscpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);\n\terr = parse_args(\"bootconfig\", tmp_cmdline, NULL, 0, 0, 0, NULL,\n\t\t\t bootconfig_params);\n\n\tif (IS_ERR(err) || !(bootconfig_found || IS_ENABLED(CONFIG_BOOT_CONFIG_FORCE)))\n\t\treturn;\n\n\t \n\tif (err)\n\t\tinitargs_offs = err - tmp_cmdline;\n\n\tif (!data) {\n\t\t \n\t\tif (bootconfig_found)\n\t\t\tpr_err(\"'bootconfig' found on command line, but no bootconfig found\\n\");\n\t\telse\n\t\t\tpr_info(\"No bootconfig data provided, so skipping bootconfig\");\n\t\treturn;\n\t}\n\n\tif (size >= XBC_DATA_MAX) {\n\t\tpr_err(\"bootconfig size %ld greater than max size %d\\n\",\n\t\t\t(long)size, XBC_DATA_MAX);\n\t\treturn;\n\t}\n\n\tret = xbc_init(data, size, &msg, &pos);\n\tif (ret < 0) {\n\t\tif (pos < 0)\n\t\t\tpr_err(\"Failed to init bootconfig: %s.\\n\", msg);\n\t\telse\n\t\t\tpr_err(\"Failed to parse bootconfig: %s at %d.\\n\",\n\t\t\t\tmsg, pos);\n\t} else {\n\t\txbc_get_info(&ret, NULL);\n\t\tpr_info(\"Load bootconfig: %ld bytes %d nodes\\n\", (long)size, ret);\n\t\t \n\t\textra_command_line = xbc_make_cmdline(\"kernel\");\n\t\t \n\t\textra_init_args = xbc_make_cmdline(\"init\");\n\t}\n\treturn;\n}\n\nstatic void __init exit_boot_config(void)\n{\n\txbc_exit();\n}\n\n#else\t \n\nstatic void __init setup_boot_config(void)\n{\n\t \n\tget_boot_config_from_initrd(NULL);\n}\n\nstatic int __init warn_bootconfig(char *str)\n{\n\tpr_warn(\"WARNING: 'bootconfig' found on the kernel command line but CONFIG_BOOT_CONFIG is not set.\\n\");\n\treturn 0;\n}\n\n#define exit_boot_config()\tdo {} while (0)\n\n#endif\t \n\nearly_param(\"bootconfig\", warn_bootconfig);\n\n \nstatic void __init repair_env_string(char *param, char *val)\n{\n\tif (val) {\n\t\t \n\t\tif (val == param+strlen(param)+1)\n\t\t\tval[-1] = '=';\n\t\telse if (val == param+strlen(param)+2) {\n\t\t\tval[-2] = '=';\n\t\t\tmemmove(val-1, val, strlen(val)+1);\n\t\t} else\n\t\t\tBUG();\n\t}\n}\n\n \nstatic int __init set_init_arg(char *param, char *val,\n\t\t\t       const char *unused, void *arg)\n{\n\tunsigned int i;\n\n\tif (panic_later)\n\t\treturn 0;\n\n\trepair_env_string(param, val);\n\n\tfor (i = 0; argv_init[i]; i++) {\n\t\tif (i == MAX_INIT_ARGS) {\n\t\t\tpanic_later = \"init\";\n\t\t\tpanic_param = param;\n\t\t\treturn 0;\n\t\t}\n\t}\n\targv_init[i] = param;\n\treturn 0;\n}\n\n \nstatic int __init unknown_bootoption(char *param, char *val,\n\t\t\t\t     const char *unused, void *arg)\n{\n\tsize_t len = strlen(param);\n\n\t \n\tif (sysctl_is_alias(param))\n\t\treturn 0;\n\n\trepair_env_string(param, val);\n\n\t \n\tif (obsolete_checksetup(param))\n\t\treturn 0;\n\n\t \n\tif (strnchr(param, len, '.'))\n\t\treturn 0;\n\n\tif (panic_later)\n\t\treturn 0;\n\n\tif (val) {\n\t\t \n\t\tunsigned int i;\n\t\tfor (i = 0; envp_init[i]; i++) {\n\t\t\tif (i == MAX_INIT_ENVS) {\n\t\t\t\tpanic_later = \"env\";\n\t\t\t\tpanic_param = param;\n\t\t\t}\n\t\t\tif (!strncmp(param, envp_init[i], len+1))\n\t\t\t\tbreak;\n\t\t}\n\t\tenvp_init[i] = param;\n\t} else {\n\t\t \n\t\tunsigned int i;\n\t\tfor (i = 0; argv_init[i]; i++) {\n\t\t\tif (i == MAX_INIT_ARGS) {\n\t\t\t\tpanic_later = \"init\";\n\t\t\t\tpanic_param = param;\n\t\t\t}\n\t\t}\n\t\targv_init[i] = param;\n\t}\n\treturn 0;\n}\n\nstatic int __init init_setup(char *str)\n{\n\tunsigned int i;\n\n\texecute_command = str;\n\t \n\tfor (i = 1; i < MAX_INIT_ARGS; i++)\n\t\targv_init[i] = NULL;\n\treturn 1;\n}\n__setup(\"init=\", init_setup);\n\nstatic int __init rdinit_setup(char *str)\n{\n\tunsigned int i;\n\n\tramdisk_execute_command = str;\n\t \n\tfor (i = 1; i < MAX_INIT_ARGS; i++)\n\t\targv_init[i] = NULL;\n\treturn 1;\n}\n__setup(\"rdinit=\", rdinit_setup);\n\n#ifndef CONFIG_SMP\nstatic const unsigned int setup_max_cpus = NR_CPUS;\nstatic inline void setup_nr_cpu_ids(void) { }\nstatic inline void smp_prepare_cpus(unsigned int maxcpus) { }\n#endif\n\n \nstatic void __init setup_command_line(char *command_line)\n{\n\tsize_t len, xlen = 0, ilen = 0;\n\n\tif (extra_command_line)\n\t\txlen = strlen(extra_command_line);\n\tif (extra_init_args)\n\t\tilen = strlen(extra_init_args) + 4;  \n\n\tlen = xlen + strlen(boot_command_line) + 1;\n\n\tsaved_command_line = memblock_alloc(len + ilen, SMP_CACHE_BYTES);\n\tif (!saved_command_line)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__, len + ilen);\n\n\tstatic_command_line = memblock_alloc(len, SMP_CACHE_BYTES);\n\tif (!static_command_line)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__, len);\n\n\tif (xlen) {\n\t\t \n\t\tstrcpy(saved_command_line, extra_command_line);\n\t\tstrcpy(static_command_line, extra_command_line);\n\t}\n\tstrcpy(saved_command_line + xlen, boot_command_line);\n\tstrcpy(static_command_line + xlen, command_line);\n\n\tif (ilen) {\n\t\t \n\t\tif (initargs_offs) {\n\t\t\tlen = xlen + initargs_offs;\n\t\t\tstrcpy(saved_command_line + len, extra_init_args);\n\t\t\tlen += ilen - 4;\t \n\t\t\tstrcpy(saved_command_line + len,\n\t\t\t\tboot_command_line + initargs_offs - 1);\n\t\t} else {\n\t\t\tlen = strlen(saved_command_line);\n\t\t\tstrcpy(saved_command_line + len, \" -- \");\n\t\t\tlen += 4;\n\t\t\tstrcpy(saved_command_line + len, extra_init_args);\n\t\t}\n\t}\n\n\tsaved_command_line_len = strlen(saved_command_line);\n}\n\n \n\nstatic __initdata DECLARE_COMPLETION(kthreadd_done);\n\nnoinline void __ref __noreturn rest_init(void)\n{\n\tstruct task_struct *tsk;\n\tint pid;\n\n\trcu_scheduler_starting();\n\t \n\tpid = user_mode_thread(kernel_init, NULL, CLONE_FS);\n\t \n\trcu_read_lock();\n\ttsk = find_task_by_pid_ns(pid, &init_pid_ns);\n\ttsk->flags |= PF_NO_SETAFFINITY;\n\tset_cpus_allowed_ptr(tsk, cpumask_of(smp_processor_id()));\n\trcu_read_unlock();\n\n\tnuma_default_policy();\n\tpid = kernel_thread(kthreadd, NULL, NULL, CLONE_FS | CLONE_FILES);\n\trcu_read_lock();\n\tkthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n\trcu_read_unlock();\n\n\t \n\tsystem_state = SYSTEM_SCHEDULING;\n\n\tcomplete(&kthreadd_done);\n\n\t \n\tschedule_preempt_disabled();\n\t \n\tcpu_startup_entry(CPUHP_ONLINE);\n}\n\n \nstatic int __init do_early_param(char *param, char *val,\n\t\t\t\t const char *unused, void *arg)\n{\n\tconst struct obs_kernel_param *p;\n\n\tfor (p = __setup_start; p < __setup_end; p++) {\n\t\tif ((p->early && parameq(param, p->str)) ||\n\t\t    (strcmp(param, \"console\") == 0 &&\n\t\t     strcmp(p->str, \"earlycon\") == 0)\n\t\t) {\n\t\t\tif (p->setup_func(val) != 0)\n\t\t\t\tpr_warn(\"Malformed early option '%s'\\n\", param);\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\nvoid __init parse_early_options(char *cmdline)\n{\n\tparse_args(\"early options\", cmdline, NULL, 0, 0, 0, NULL,\n\t\t   do_early_param);\n}\n\n \nvoid __init parse_early_param(void)\n{\n\tstatic int done __initdata;\n\tstatic char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;\n\n\tif (done)\n\t\treturn;\n\n\t \n\tstrscpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);\n\tparse_early_options(tmp_cmdline);\n\tdone = 1;\n}\n\nvoid __init __weak arch_post_acpi_subsys_init(void) { }\n\nvoid __init __weak smp_setup_processor_id(void)\n{\n}\n\n# if THREAD_SIZE >= PAGE_SIZE\nvoid __init __weak thread_stack_cache_init(void)\n{\n}\n#endif\n\nvoid __init __weak poking_init(void) { }\n\nvoid __init __weak pgtable_cache_init(void) { }\n\nvoid __init __weak trap_init(void) { }\n\nbool initcall_debug;\ncore_param(initcall_debug, initcall_debug, bool, 0644);\n\n#ifdef TRACEPOINTS_ENABLED\nstatic void __init initcall_debug_enable(void);\n#else\nstatic inline void initcall_debug_enable(void)\n{\n}\n#endif\n\n#ifdef CONFIG_RANDOMIZE_KSTACK_OFFSET\nDEFINE_STATIC_KEY_MAYBE_RO(CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT,\n\t\t\t   randomize_kstack_offset);\nDEFINE_PER_CPU(u32, kstack_offset);\n\nstatic int __init early_randomize_kstack_offset(char *buf)\n{\n\tint ret;\n\tbool bool_result;\n\n\tret = kstrtobool(buf, &bool_result);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bool_result)\n\t\tstatic_branch_enable(&randomize_kstack_offset);\n\telse\n\t\tstatic_branch_disable(&randomize_kstack_offset);\n\treturn 0;\n}\nearly_param(\"randomize_kstack_offset\", early_randomize_kstack_offset);\n#endif\n\nvoid __init __weak __noreturn arch_call_rest_init(void)\n{\n\trest_init();\n}\n\nstatic void __init print_unknown_bootoptions(void)\n{\n\tchar *unknown_options;\n\tchar *end;\n\tconst char *const *p;\n\tsize_t len;\n\n\tif (panic_later || (!argv_init[1] && !envp_init[2]))\n\t\treturn;\n\n\t \n\tlen = 1;  \n\tfor (p = &argv_init[1]; *p; p++) {\n\t\tlen++;\n\t\tlen += strlen(*p);\n\t}\n\tfor (p = &envp_init[2]; *p; p++) {\n\t\tlen++;\n\t\tlen += strlen(*p);\n\t}\n\n\tunknown_options = memblock_alloc(len, SMP_CACHE_BYTES);\n\tif (!unknown_options) {\n\t\tpr_err(\"%s: Failed to allocate %zu bytes\\n\",\n\t\t\t__func__, len);\n\t\treturn;\n\t}\n\tend = unknown_options;\n\n\tfor (p = &argv_init[1]; *p; p++)\n\t\tend += sprintf(end, \" %s\", *p);\n\tfor (p = &envp_init[2]; *p; p++)\n\t\tend += sprintf(end, \" %s\", *p);\n\n\t \n\tpr_notice(\"Unknown kernel command line parameters \\\"%s\\\", will be passed to user space.\\n\",\n\t\t&unknown_options[1]);\n\tmemblock_free(unknown_options, len);\n}\n\nasmlinkage __visible __init __no_sanitize_address __noreturn __no_stack_protector\nvoid start_kernel(void)\n{\n\tchar *command_line;\n\tchar *after_dashes;\n\n\tset_task_stack_end_magic(&init_task);\n\tsmp_setup_processor_id();\n\tdebug_objects_early_init();\n\tinit_vmlinux_build_id();\n\n\tcgroup_init_early();\n\n\tlocal_irq_disable();\n\tearly_boot_irqs_disabled = true;\n\n\t \n\tboot_cpu_init();\n\tpage_address_init();\n\tpr_notice(\"%s\", linux_banner);\n\tearly_security_init();\n\tsetup_arch(&command_line);\n\tsetup_boot_config();\n\tsetup_command_line(command_line);\n\tsetup_nr_cpu_ids();\n\tsetup_per_cpu_areas();\n\tsmp_prepare_boot_cpu();\t \n\tboot_cpu_hotplug_init();\n\n\tpr_notice(\"Kernel command line: %s\\n\", saved_command_line);\n\t \n\tjump_label_init();\n\tparse_early_param();\n\tafter_dashes = parse_args(\"Booting kernel\",\n\t\t\t\t  static_command_line, __start___param,\n\t\t\t\t  __stop___param - __start___param,\n\t\t\t\t  -1, -1, NULL, &unknown_bootoption);\n\tprint_unknown_bootoptions();\n\tif (!IS_ERR_OR_NULL(after_dashes))\n\t\tparse_args(\"Setting init args\", after_dashes, NULL, 0, -1, -1,\n\t\t\t   NULL, set_init_arg);\n\tif (extra_init_args)\n\t\tparse_args(\"Setting extra init args\", extra_init_args,\n\t\t\t   NULL, 0, -1, -1, NULL, set_init_arg);\n\n\t \n\trandom_init_early(command_line);\n\n\t \n\tsetup_log_buf(0);\n\tvfs_caches_init_early();\n\tsort_main_extable();\n\ttrap_init();\n\tmm_core_init();\n\tpoking_init();\n\tftrace_init();\n\n\t \n\tearly_trace_init();\n\n\t \n\tsched_init();\n\n\tif (WARN(!irqs_disabled(),\n\t\t \"Interrupts were enabled *very* early, fixing it\\n\"))\n\t\tlocal_irq_disable();\n\tradix_tree_init();\n\tmaple_tree_init();\n\n\t \n\thousekeeping_init();\n\n\t \n\tworkqueue_init_early();\n\n\trcu_init();\n\n\t \n\ttrace_init();\n\n\tif (initcall_debug)\n\t\tinitcall_debug_enable();\n\n\tcontext_tracking_init();\n\t \n\tearly_irq_init();\n\tinit_IRQ();\n\ttick_init();\n\trcu_init_nohz();\n\tinit_timers();\n\tsrcu_init();\n\thrtimers_init();\n\tsoftirq_init();\n\ttimekeeping_init();\n\ttime_init();\n\n\t \n\trandom_init();\n\n\t \n\tkfence_init();\n\tboot_init_stack_canary();\n\n\tperf_event_init();\n\tprofile_init();\n\tcall_function_init();\n\tWARN(!irqs_disabled(), \"Interrupts were enabled early\\n\");\n\n\tearly_boot_irqs_disabled = false;\n\tlocal_irq_enable();\n\n\tkmem_cache_init_late();\n\n\t \n\tconsole_init();\n\tif (panic_later)\n\t\tpanic(\"Too many boot %s vars at `%s'\", panic_later,\n\t\t      panic_param);\n\n\tlockdep_init();\n\n\t \n\tlocking_selftest();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (initrd_start && !initrd_below_start_ok &&\n\t    page_to_pfn(virt_to_page((void *)initrd_start)) < min_low_pfn) {\n\t\tpr_crit(\"initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\\n\",\n\t\t    page_to_pfn(virt_to_page((void *)initrd_start)),\n\t\t    min_low_pfn);\n\t\tinitrd_start = 0;\n\t}\n#endif\n\tsetup_per_cpu_pageset();\n\tnuma_policy_init();\n\tacpi_early_init();\n\tif (late_time_init)\n\t\tlate_time_init();\n\tsched_clock_init();\n\tcalibrate_delay();\n\n\tarch_cpu_finalize_init();\n\n\tpid_idr_init();\n\tanon_vma_init();\n#ifdef CONFIG_X86\n\tif (efi_enabled(EFI_RUNTIME_SERVICES))\n\t\tefi_enter_virtual_mode();\n#endif\n\tthread_stack_cache_init();\n\tcred_init();\n\tfork_init();\n\tproc_caches_init();\n\tuts_ns_init();\n\tkey_init();\n\tsecurity_init();\n\tdbg_late_init();\n\tnet_ns_init();\n\tvfs_caches_init();\n\tpagecache_init();\n\tsignals_init();\n\tseq_file_init();\n\tproc_root_init();\n\tnsfs_init();\n\tcpuset_init();\n\tcgroup_init();\n\ttaskstats_init_early();\n\tdelayacct_init();\n\n\tacpi_subsystem_init();\n\tarch_post_acpi_subsys_init();\n\tkcsan_init();\n\n\t \n\tarch_call_rest_init();\n\n\t \n#if !__has_attribute(__no_stack_protector__)\n\tprevent_tail_call_optimization();\n#endif\n}\n\n \nstatic void __init do_ctors(void)\n{\n \n#if defined(CONFIG_CONSTRUCTORS) && !defined(CONFIG_UML)\n\tctor_fn_t *fn = (ctor_fn_t *) __ctors_start;\n\n\tfor (; fn < (ctor_fn_t *) __ctors_end; fn++)\n\t\t(*fn)();\n#endif\n}\n\n#ifdef CONFIG_KALLSYMS\nstruct blacklist_entry {\n\tstruct list_head next;\n\tchar *buf;\n};\n\nstatic __initdata_or_module LIST_HEAD(blacklisted_initcalls);\n\nstatic int __init initcall_blacklist(char *str)\n{\n\tchar *str_entry;\n\tstruct blacklist_entry *entry;\n\n\t \n\tdo {\n\t\tstr_entry = strsep(&str, \",\");\n\t\tif (str_entry) {\n\t\t\tpr_debug(\"blacklisting initcall %s\\n\", str_entry);\n\t\t\tentry = memblock_alloc(sizeof(*entry),\n\t\t\t\t\t       SMP_CACHE_BYTES);\n\t\t\tif (!entry)\n\t\t\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\",\n\t\t\t\t      __func__, sizeof(*entry));\n\t\t\tentry->buf = memblock_alloc(strlen(str_entry) + 1,\n\t\t\t\t\t\t    SMP_CACHE_BYTES);\n\t\t\tif (!entry->buf)\n\t\t\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\",\n\t\t\t\t      __func__, strlen(str_entry) + 1);\n\t\t\tstrcpy(entry->buf, str_entry);\n\t\t\tlist_add(&entry->next, &blacklisted_initcalls);\n\t\t}\n\t} while (str_entry);\n\n\treturn 1;\n}\n\nstatic bool __init_or_module initcall_blacklisted(initcall_t fn)\n{\n\tstruct blacklist_entry *entry;\n\tchar fn_name[KSYM_SYMBOL_LEN];\n\tunsigned long addr;\n\n\tif (list_empty(&blacklisted_initcalls))\n\t\treturn false;\n\n\taddr = (unsigned long) dereference_function_descriptor(fn);\n\tsprint_symbol_no_offset(fn_name, addr);\n\n\t \n\tstrreplace(fn_name, ' ', '\\0');\n\n\tlist_for_each_entry(entry, &blacklisted_initcalls, next) {\n\t\tif (!strcmp(fn_name, entry->buf)) {\n\t\t\tpr_debug(\"initcall %s blacklisted\\n\", fn_name);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n#else\nstatic int __init initcall_blacklist(char *str)\n{\n\tpr_warn(\"initcall_blacklist requires CONFIG_KALLSYMS\\n\");\n\treturn 0;\n}\n\nstatic bool __init_or_module initcall_blacklisted(initcall_t fn)\n{\n\treturn false;\n}\n#endif\n__setup(\"initcall_blacklist=\", initcall_blacklist);\n\nstatic __init_or_module void\ntrace_initcall_start_cb(void *data, initcall_t fn)\n{\n\tktime_t *calltime = data;\n\n\tprintk(KERN_DEBUG \"calling  %pS @ %i\\n\", fn, task_pid_nr(current));\n\t*calltime = ktime_get();\n}\n\nstatic __init_or_module void\ntrace_initcall_finish_cb(void *data, initcall_t fn, int ret)\n{\n\tktime_t rettime, *calltime = data;\n\n\trettime = ktime_get();\n\tprintk(KERN_DEBUG \"initcall %pS returned %d after %lld usecs\\n\",\n\t\t fn, ret, (unsigned long long)ktime_us_delta(rettime, *calltime));\n}\n\nstatic ktime_t initcall_calltime;\n\n#ifdef TRACEPOINTS_ENABLED\nstatic void __init initcall_debug_enable(void)\n{\n\tint ret;\n\n\tret = register_trace_initcall_start(trace_initcall_start_cb,\n\t\t\t\t\t    &initcall_calltime);\n\tret |= register_trace_initcall_finish(trace_initcall_finish_cb,\n\t\t\t\t\t      &initcall_calltime);\n\tWARN(ret, \"Failed to register initcall tracepoints\\n\");\n}\n# define do_trace_initcall_start\ttrace_initcall_start\n# define do_trace_initcall_finish\ttrace_initcall_finish\n#else\nstatic inline void do_trace_initcall_start(initcall_t fn)\n{\n\tif (!initcall_debug)\n\t\treturn;\n\ttrace_initcall_start_cb(&initcall_calltime, fn);\n}\nstatic inline void do_trace_initcall_finish(initcall_t fn, int ret)\n{\n\tif (!initcall_debug)\n\t\treturn;\n\ttrace_initcall_finish_cb(&initcall_calltime, fn, ret);\n}\n#endif  \n\nint __init_or_module do_one_initcall(initcall_t fn)\n{\n\tint count = preempt_count();\n\tchar msgbuf[64];\n\tint ret;\n\n\tif (initcall_blacklisted(fn))\n\t\treturn -EPERM;\n\n\tdo_trace_initcall_start(fn);\n\tret = fn();\n\tdo_trace_initcall_finish(fn, ret);\n\n\tmsgbuf[0] = 0;\n\n\tif (preempt_count() != count) {\n\t\tsprintf(msgbuf, \"preemption imbalance \");\n\t\tpreempt_count_set(count);\n\t}\n\tif (irqs_disabled()) {\n\t\tstrlcat(msgbuf, \"disabled interrupts \", sizeof(msgbuf));\n\t\tlocal_irq_enable();\n\t}\n\tWARN(msgbuf[0], \"initcall %pS returned with %s\\n\", fn, msgbuf);\n\n\tadd_latent_entropy();\n\treturn ret;\n}\n\n\nstatic initcall_entry_t *initcall_levels[] __initdata = {\n\t__initcall0_start,\n\t__initcall1_start,\n\t__initcall2_start,\n\t__initcall3_start,\n\t__initcall4_start,\n\t__initcall5_start,\n\t__initcall6_start,\n\t__initcall7_start,\n\t__initcall_end,\n};\n\n \nstatic const char *initcall_level_names[] __initdata = {\n\t\"pure\",\n\t\"core\",\n\t\"postcore\",\n\t\"arch\",\n\t\"subsys\",\n\t\"fs\",\n\t\"device\",\n\t\"late\",\n};\n\nstatic int __init ignore_unknown_bootoption(char *param, char *val,\n\t\t\t       const char *unused, void *arg)\n{\n\treturn 0;\n}\n\nstatic void __init do_initcall_level(int level, char *command_line)\n{\n\tinitcall_entry_t *fn;\n\n\tparse_args(initcall_level_names[level],\n\t\t   command_line, __start___param,\n\t\t   __stop___param - __start___param,\n\t\t   level, level,\n\t\t   NULL, ignore_unknown_bootoption);\n\n\ttrace_initcall_level(initcall_level_names[level]);\n\tfor (fn = initcall_levels[level]; fn < initcall_levels[level+1]; fn++)\n\t\tdo_one_initcall(initcall_from_entry(fn));\n}\n\nstatic void __init do_initcalls(void)\n{\n\tint level;\n\tsize_t len = saved_command_line_len + 1;\n\tchar *command_line;\n\n\tcommand_line = kzalloc(len, GFP_KERNEL);\n\tif (!command_line)\n\t\tpanic(\"%s: Failed to allocate %zu bytes\\n\", __func__, len);\n\n\tfor (level = 0; level < ARRAY_SIZE(initcall_levels) - 1; level++) {\n\t\t \n\t\tstrcpy(command_line, saved_command_line);\n\t\tdo_initcall_level(level, command_line);\n\t}\n\n\tkfree(command_line);\n}\n\n \nstatic void __init do_basic_setup(void)\n{\n\tcpuset_init_smp();\n\tdriver_init();\n\tinit_irq_proc();\n\tdo_ctors();\n\tdo_initcalls();\n}\n\nstatic void __init do_pre_smp_initcalls(void)\n{\n\tinitcall_entry_t *fn;\n\n\ttrace_initcall_level(\"early\");\n\tfor (fn = __initcall_start; fn < __initcall0_start; fn++)\n\t\tdo_one_initcall(initcall_from_entry(fn));\n}\n\nstatic int run_init_process(const char *init_filename)\n{\n\tconst char *const *p;\n\n\targv_init[0] = init_filename;\n\tpr_info(\"Run %s as init process\\n\", init_filename);\n\tpr_debug(\"  with arguments:\\n\");\n\tfor (p = argv_init; *p; p++)\n\t\tpr_debug(\"    %s\\n\", *p);\n\tpr_debug(\"  with environment:\\n\");\n\tfor (p = envp_init; *p; p++)\n\t\tpr_debug(\"    %s\\n\", *p);\n\treturn kernel_execve(init_filename, argv_init, envp_init);\n}\n\nstatic int try_to_run_init_process(const char *init_filename)\n{\n\tint ret;\n\n\tret = run_init_process(init_filename);\n\n\tif (ret && ret != -ENOENT) {\n\t\tpr_err(\"Starting init: %s exists but couldn't execute it (error %d)\\n\",\n\t\t       init_filename, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic noinline void __init kernel_init_freeable(void);\n\n#if defined(CONFIG_STRICT_KERNEL_RWX) || defined(CONFIG_STRICT_MODULE_RWX)\nbool rodata_enabled __ro_after_init = true;\n\n#ifndef arch_parse_debug_rodata\nstatic inline bool arch_parse_debug_rodata(char *str) { return false; }\n#endif\n\nstatic int __init set_debug_rodata(char *str)\n{\n\tif (arch_parse_debug_rodata(str))\n\t\treturn 0;\n\n\tif (str && !strcmp(str, \"on\"))\n\t\trodata_enabled = true;\n\telse if (str && !strcmp(str, \"off\"))\n\t\trodata_enabled = false;\n\telse\n\t\tpr_warn(\"Invalid option string for rodata: '%s'\\n\", str);\n\treturn 0;\n}\nearly_param(\"rodata\", set_debug_rodata);\n#endif\n\n#ifdef CONFIG_STRICT_KERNEL_RWX\nstatic void mark_readonly(void)\n{\n\tif (rodata_enabled) {\n\t\t \n\t\trcu_barrier();\n\t\tmark_rodata_ro();\n\t\trodata_test();\n\t} else\n\t\tpr_info(\"Kernel memory protection disabled.\\n\");\n}\n#elif defined(CONFIG_ARCH_HAS_STRICT_KERNEL_RWX)\nstatic inline void mark_readonly(void)\n{\n\tpr_warn(\"Kernel memory protection not selected by kernel config.\\n\");\n}\n#else\nstatic inline void mark_readonly(void)\n{\n\tpr_warn(\"This architecture does not have kernel memory protection.\\n\");\n}\n#endif\n\nvoid __weak free_initmem(void)\n{\n\tfree_initmem_default(POISON_FREE_INITMEM);\n}\n\nstatic int __ref kernel_init(void *unused)\n{\n\tint ret;\n\n\t \n\twait_for_completion(&kthreadd_done);\n\n\tkernel_init_freeable();\n\t \n\tasync_synchronize_full();\n\n\tsystem_state = SYSTEM_FREEING_INITMEM;\n\tkprobe_free_init_mem();\n\tftrace_free_init_mem();\n\tkgdb_free_init_mem();\n\texit_boot_config();\n\tfree_initmem();\n\tmark_readonly();\n\n\t \n\tpti_finalize();\n\n\tsystem_state = SYSTEM_RUNNING;\n\tnuma_default_policy();\n\n\trcu_end_inkernel_boot();\n\n\tdo_sysctl_args();\n\n\tif (ramdisk_execute_command) {\n\t\tret = run_init_process(ramdisk_execute_command);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tpr_err(\"Failed to execute %s (error %d)\\n\",\n\t\t       ramdisk_execute_command, ret);\n\t}\n\n\t \n\tif (execute_command) {\n\t\tret = run_init_process(execute_command);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tpanic(\"Requested init %s failed (error %d).\",\n\t\t      execute_command, ret);\n\t}\n\n\tif (CONFIG_DEFAULT_INIT[0] != '\\0') {\n\t\tret = run_init_process(CONFIG_DEFAULT_INIT);\n\t\tif (ret)\n\t\t\tpr_err(\"Default init %s failed (error %d)\\n\",\n\t\t\t       CONFIG_DEFAULT_INIT, ret);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (!try_to_run_init_process(\"/sbin/init\") ||\n\t    !try_to_run_init_process(\"/etc/init\") ||\n\t    !try_to_run_init_process(\"/bin/init\") ||\n\t    !try_to_run_init_process(\"/bin/sh\"))\n\t\treturn 0;\n\n\tpanic(\"No working init found.  Try passing init= option to kernel. \"\n\t      \"See Linux Documentation/admin-guide/init.rst for guidance.\");\n}\n\n \nvoid __init console_on_rootfs(void)\n{\n\tstruct file *file = filp_open(\"/dev/console\", O_RDWR, 0);\n\n\tif (IS_ERR(file)) {\n\t\tpr_err(\"Warning: unable to open an initial console.\\n\");\n\t\treturn;\n\t}\n\tinit_dup(file);\n\tinit_dup(file);\n\tinit_dup(file);\n\tfput(file);\n}\n\nstatic noinline void __init kernel_init_freeable(void)\n{\n\t \n\tgfp_allowed_mask = __GFP_BITS_MASK;\n\n\t \n\tset_mems_allowed(node_states[N_MEMORY]);\n\n\tcad_pid = get_pid(task_pid(current));\n\n\tsmp_prepare_cpus(setup_max_cpus);\n\n\tworkqueue_init();\n\n\tinit_mm_internals();\n\n\trcu_init_tasks_generic();\n\tdo_pre_smp_initcalls();\n\tlockup_detector_init();\n\n\tsmp_init();\n\tsched_init_smp();\n\n\tworkqueue_init_topology();\n\tpadata_init();\n\tpage_alloc_init_late();\n\n\tdo_basic_setup();\n\n\tkunit_run_all_tests();\n\n\twait_for_initramfs();\n\tconsole_on_rootfs();\n\n\t \n\tif (init_eaccess(ramdisk_execute_command) != 0) {\n\t\tramdisk_execute_command = NULL;\n\t\tprepare_namespace();\n\t}\n\n\t \n\n\tintegrity_load_keys();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}