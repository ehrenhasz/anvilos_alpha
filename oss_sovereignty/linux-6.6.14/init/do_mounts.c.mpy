{
  "module_name": "do_mounts.c",
  "hash_id": "18eb08bf3e0b8ccbc572929c9c2036c9aaa964ae6815d8ab7c97a72b358940fa",
  "original_prompt": "Ingested from linux-6.6.14/init/do_mounts.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fd.h>\n#include <linux/tty.h>\n#include <linux/suspend.h>\n#include <linux/root_dev.h>\n#include <linux/security.h>\n#include <linux/delay.h>\n#include <linux/mount.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/initrd.h>\n#include <linux/async.h>\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/ramfs.h>\n#include <linux/shmem_fs.h>\n#include <linux/ktime.h>\n\n#include <linux/nfs_fs.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_mount.h>\n#include <linux/raid/detect.h>\n#include <uapi/linux/mount.h>\n\n#include \"do_mounts.h\"\n\nint root_mountflags = MS_RDONLY | MS_SILENT;\nstatic char __initdata saved_root_name[64];\nstatic int root_wait;\n\ndev_t ROOT_DEV;\n\nstatic int __init load_ramdisk(char *str)\n{\n\tpr_warn(\"ignoring the deprecated load_ramdisk= option\\n\");\n\treturn 1;\n}\n__setup(\"load_ramdisk=\", load_ramdisk);\n\nstatic int __init readonly(char *str)\n{\n\tif (*str)\n\t\treturn 0;\n\troot_mountflags |= MS_RDONLY;\n\treturn 1;\n}\n\nstatic int __init readwrite(char *str)\n{\n\tif (*str)\n\t\treturn 0;\n\troot_mountflags &= ~MS_RDONLY;\n\treturn 1;\n}\n\n__setup(\"ro\", readonly);\n__setup(\"rw\", readwrite);\n\nstatic int __init root_dev_setup(char *line)\n{\n\tstrscpy(saved_root_name, line, sizeof(saved_root_name));\n\treturn 1;\n}\n\n__setup(\"root=\", root_dev_setup);\n\nstatic int __init rootwait_setup(char *str)\n{\n\tif (*str)\n\t\treturn 0;\n\troot_wait = -1;\n\treturn 1;\n}\n\n__setup(\"rootwait\", rootwait_setup);\n\nstatic int __init rootwait_timeout_setup(char *str)\n{\n\tint sec;\n\n\tif (kstrtoint(str, 0, &sec) || sec < 0) {\n\t\tpr_warn(\"ignoring invalid rootwait value\\n\");\n\t\tgoto ignore;\n\t}\n\n\tif (check_mul_overflow(sec, MSEC_PER_SEC, &root_wait)) {\n\t\tpr_warn(\"ignoring excessive rootwait value\\n\");\n\t\tgoto ignore;\n\t}\n\n\treturn 1;\n\nignore:\n\t \n\troot_wait = -1;\n\n\treturn 1;\n}\n\n__setup(\"rootwait=\", rootwait_timeout_setup);\n\nstatic char * __initdata root_mount_data;\nstatic int __init root_data_setup(char *str)\n{\n\troot_mount_data = str;\n\treturn 1;\n}\n\nstatic char * __initdata root_fs_names;\nstatic int __init fs_names_setup(char *str)\n{\n\troot_fs_names = str;\n\treturn 1;\n}\n\nstatic unsigned int __initdata root_delay;\nstatic int __init root_delay_setup(char *str)\n{\n\troot_delay = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}\n\n__setup(\"rootflags=\", root_data_setup);\n__setup(\"rootfstype=\", fs_names_setup);\n__setup(\"rootdelay=\", root_delay_setup);\n\n \nstatic int __init split_fs_names(char *page, size_t size)\n{\n\tint count = 1;\n\tchar *p = page;\n\n\tstrscpy(p, root_fs_names, size);\n\twhile (*p++) {\n\t\tif (p[-1] == ',') {\n\t\t\tp[-1] = '\\0';\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int __init do_mount_root(const char *name, const char *fs,\n\t\t\t\t const int flags, const void *data)\n{\n\tstruct super_block *s;\n\tstruct page *p = NULL;\n\tchar *data_page = NULL;\n\tint ret;\n\n\tif (data) {\n\t\t \n\t\tp = alloc_page(GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tdata_page = page_address(p);\n\t\t \n\t\tstrncpy(data_page, data, PAGE_SIZE);\n\t}\n\n\tret = init_mount(name, \"/root\", fs, flags, data_page);\n\tif (ret)\n\t\tgoto out;\n\n\tinit_chdir(\"/root\");\n\ts = current->fs->pwd.dentry->d_sb;\n\tROOT_DEV = s->s_dev;\n\tprintk(KERN_INFO\n\t       \"VFS: Mounted root (%s filesystem)%s on device %u:%u.\\n\",\n\t       s->s_type->name,\n\t       sb_rdonly(s) ? \" readonly\" : \"\",\n\t       MAJOR(ROOT_DEV), MINOR(ROOT_DEV));\n\nout:\n\tif (p)\n\t\tput_page(p);\n\treturn ret;\n}\n\nvoid __init mount_root_generic(char *name, char *pretty_name, int flags)\n{\n\tstruct page *page = alloc_page(GFP_KERNEL);\n\tchar *fs_names = page_address(page);\n\tchar *p;\n\tchar b[BDEVNAME_SIZE];\n\tint num_fs, i;\n\n\tscnprintf(b, BDEVNAME_SIZE, \"unknown-block(%u,%u)\",\n\t\t  MAJOR(ROOT_DEV), MINOR(ROOT_DEV));\n\tif (root_fs_names)\n\t\tnum_fs = split_fs_names(fs_names, PAGE_SIZE);\n\telse\n\t\tnum_fs = list_bdev_fs_names(fs_names, PAGE_SIZE);\nretry:\n\tfor (i = 0, p = fs_names; i < num_fs; i++, p += strlen(p)+1) {\n\t\tint err;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\terr = do_mount_root(name, p, flags, root_mount_data);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\tcase -EACCES:\n\t\t\tcase -EINVAL:\n\t\t\t\tcontinue;\n\t\t}\n\t         \n\t\tprintk(\"VFS: Cannot open root device \\\"%s\\\" or %s: error %d\\n\",\n\t\t\t\tpretty_name, b, err);\n\t\tprintk(\"Please append a correct \\\"root=\\\" boot option; here are the available partitions:\\n\");\n\t\tprintk_all_partitions();\n\n\t\tif (root_fs_names)\n\t\t\tnum_fs = list_bdev_fs_names(fs_names, PAGE_SIZE);\n\t\tif (!num_fs)\n\t\t\tpr_err(\"Can't find any bdev filesystem to be used for mount!\\n\");\n\t\telse {\n\t\t\tpr_err(\"List of all bdev filesystems:\\n\");\n\t\t\tfor (i = 0, p = fs_names; i < num_fs; i++, p += strlen(p)+1)\n\t\t\t\tpr_err(\" %s\", p);\n\t\t\tpr_err(\"\\n\");\n\t\t}\n\n\t\tpanic(\"VFS: Unable to mount root fs on %s\", b);\n\t}\n\tif (!(flags & SB_RDONLY)) {\n\t\tflags |= SB_RDONLY;\n\t\tgoto retry;\n\t}\n\n\tprintk(\"List of all partitions:\\n\");\n\tprintk_all_partitions();\n\tprintk(\"No filesystem could mount root, tried: \");\n\tfor (i = 0, p = fs_names; i < num_fs; i++, p += strlen(p)+1)\n\t\tprintk(\" %s\", p);\n\tprintk(\"\\n\");\n\tpanic(\"VFS: Unable to mount root fs on %s\", b);\nout:\n\tput_page(page);\n}\n \n#ifdef CONFIG_ROOT_NFS\n\n#define NFSROOT_TIMEOUT_MIN\t5\n#define NFSROOT_TIMEOUT_MAX\t30\n#define NFSROOT_RETRY_MAX\t5\n\nstatic void __init mount_nfs_root(void)\n{\n\tchar *root_dev, *root_data;\n\tunsigned int timeout;\n\tint try;\n\n\tif (nfs_root_data(&root_dev, &root_data))\n\t\tgoto fail;\n\n\t \n\ttimeout = NFSROOT_TIMEOUT_MIN;\n\tfor (try = 1; ; try++) {\n\t\tif (!do_mount_root(root_dev, \"nfs\", root_mountflags, root_data))\n\t\t\treturn;\n\t\tif (try > NFSROOT_RETRY_MAX)\n\t\t\tbreak;\n\n\t\t \n\t\tssleep(timeout);\n\t\ttimeout <<= 1;\n\t\tif (timeout > NFSROOT_TIMEOUT_MAX)\n\t\t\ttimeout = NFSROOT_TIMEOUT_MAX;\n\t}\nfail:\n\tpr_err(\"VFS: Unable to mount root fs via NFS.\\n\");\n}\n#else\nstatic inline void mount_nfs_root(void)\n{\n}\n#endif  \n\n#ifdef CONFIG_CIFS_ROOT\n\n#define CIFSROOT_TIMEOUT_MIN\t5\n#define CIFSROOT_TIMEOUT_MAX\t30\n#define CIFSROOT_RETRY_MAX\t5\n\nstatic void __init mount_cifs_root(void)\n{\n\tchar *root_dev, *root_data;\n\tunsigned int timeout;\n\tint try;\n\n\tif (cifs_root_data(&root_dev, &root_data))\n\t\tgoto fail;\n\n\ttimeout = CIFSROOT_TIMEOUT_MIN;\n\tfor (try = 1; ; try++) {\n\t\tif (!do_mount_root(root_dev, \"cifs\", root_mountflags,\n\t\t\t\t   root_data))\n\t\t\treturn;\n\t\tif (try > CIFSROOT_RETRY_MAX)\n\t\t\tbreak;\n\n\t\tssleep(timeout);\n\t\ttimeout <<= 1;\n\t\tif (timeout > CIFSROOT_TIMEOUT_MAX)\n\t\t\ttimeout = CIFSROOT_TIMEOUT_MAX;\n\t}\nfail:\n\tpr_err(\"VFS: Unable to mount root fs via SMB.\\n\");\n}\n#else\nstatic inline void mount_cifs_root(void)\n{\n}\n#endif  \n\nstatic bool __init fs_is_nodev(char *fstype)\n{\n\tstruct file_system_type *fs = get_fs_type(fstype);\n\tbool ret = false;\n\n\tif (fs) {\n\t\tret = !(fs->fs_flags & FS_REQUIRES_DEV);\n\t\tput_filesystem(fs);\n\t}\n\n\treturn ret;\n}\n\nstatic int __init mount_nodev_root(char *root_device_name)\n{\n\tchar *fs_names, *fstype;\n\tint err = -EINVAL;\n\tint num_fs, i;\n\n\tfs_names = (void *)__get_free_page(GFP_KERNEL);\n\tif (!fs_names)\n\t\treturn -EINVAL;\n\tnum_fs = split_fs_names(fs_names, PAGE_SIZE);\n\n\tfor (i = 0, fstype = fs_names; i < num_fs;\n\t     i++, fstype += strlen(fstype) + 1) {\n\t\tif (!*fstype)\n\t\t\tcontinue;\n\t\tif (!fs_is_nodev(fstype))\n\t\t\tcontinue;\n\t\terr = do_mount_root(root_device_name, fstype, root_mountflags,\n\t\t\t\t    root_mount_data);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\n\tfree_page((unsigned long)fs_names);\n\treturn err;\n}\n\n#ifdef CONFIG_BLOCK\nstatic void __init mount_block_root(char *root_device_name)\n{\n\tint err = create_dev(\"/dev/root\", ROOT_DEV);\n\n\tif (err < 0)\n\t\tpr_emerg(\"Failed to create /dev/root: %d\\n\", err);\n\tmount_root_generic(\"/dev/root\", root_device_name, root_mountflags);\n}\n#else\nstatic inline void mount_block_root(char *root_device_name)\n{\n}\n#endif  \n\nvoid __init mount_root(char *root_device_name)\n{\n\tswitch (ROOT_DEV) {\n\tcase Root_NFS:\n\t\tmount_nfs_root();\n\t\tbreak;\n\tcase Root_CIFS:\n\t\tmount_cifs_root();\n\t\tbreak;\n\tcase Root_Generic:\n\t\tmount_root_generic(root_device_name, root_device_name,\n\t\t\t\t   root_mountflags);\n\t\tbreak;\n\tcase 0:\n\t\tif (root_device_name && root_fs_names &&\n\t\t    mount_nodev_root(root_device_name) == 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tmount_block_root(root_device_name);\n\t\tbreak;\n\t}\n}\n\n \nstatic void __init wait_for_root(char *root_device_name)\n{\n\tktime_t end;\n\n\tif (ROOT_DEV != 0)\n\t\treturn;\n\n\tpr_info(\"Waiting for root device %s...\\n\", root_device_name);\n\n\tend = ktime_add_ms(ktime_get_raw(), root_wait);\n\n\twhile (!driver_probe_done() ||\n\t       early_lookup_bdev(root_device_name, &ROOT_DEV) < 0) {\n\t\tmsleep(5);\n\t\tif (root_wait > 0 && ktime_after(ktime_get_raw(), end))\n\t\t\tbreak;\n\t}\n\n\tasync_synchronize_full();\n\n}\n\nstatic dev_t __init parse_root_device(char *root_device_name)\n{\n\tint error;\n\tdev_t dev;\n\n\tif (!strncmp(root_device_name, \"mtd\", 3) ||\n\t    !strncmp(root_device_name, \"ubi\", 3))\n\t\treturn Root_Generic;\n\tif (strcmp(root_device_name, \"/dev/nfs\") == 0)\n\t\treturn Root_NFS;\n\tif (strcmp(root_device_name, \"/dev/cifs\") == 0)\n\t\treturn Root_CIFS;\n\tif (strcmp(root_device_name, \"/dev/ram\") == 0)\n\t\treturn Root_RAM0;\n\n\terror = early_lookup_bdev(root_device_name, &dev);\n\tif (error) {\n\t\tif (error == -EINVAL && root_wait) {\n\t\t\tpr_err(\"Disabling rootwait; root= is invalid.\\n\");\n\t\t\troot_wait = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn dev;\n}\n\n \nvoid __init prepare_namespace(void)\n{\n\tif (root_delay) {\n\t\tprintk(KERN_INFO \"Waiting %d sec before mounting root device...\\n\",\n\t\t       root_delay);\n\t\tssleep(root_delay);\n\t}\n\n\t \n\twait_for_device_probe();\n\n\tmd_run_setup();\n\n\tif (saved_root_name[0])\n\t\tROOT_DEV = parse_root_device(saved_root_name);\n\n\tif (initrd_load(saved_root_name))\n\t\tgoto out;\n\n\tif (root_wait)\n\t\twait_for_root(saved_root_name);\n\tmount_root(saved_root_name);\nout:\n\tdevtmpfs_mount();\n\tinit_mount(\".\", \"/\", NULL, MS_MOVE, NULL);\n\tinit_chroot(\".\");\n}\n\nstatic bool is_tmpfs;\nstatic int rootfs_init_fs_context(struct fs_context *fc)\n{\n\tif (IS_ENABLED(CONFIG_TMPFS) && is_tmpfs)\n\t\treturn shmem_init_fs_context(fc);\n\n\treturn ramfs_init_fs_context(fc);\n}\n\nstruct file_system_type rootfs_fs_type = {\n\t.name\t\t= \"rootfs\",\n\t.init_fs_context = rootfs_init_fs_context,\n\t.kill_sb\t= kill_litter_super,\n};\n\nvoid __init init_rootfs(void)\n{\n\tif (IS_ENABLED(CONFIG_TMPFS)) {\n\t\tif (!saved_root_name[0] && !root_fs_names)\n\t\t\tis_tmpfs = true;\n\t\telse if (root_fs_names && !!strstr(root_fs_names, \"tmpfs\"))\n\t\t\tis_tmpfs = true;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}