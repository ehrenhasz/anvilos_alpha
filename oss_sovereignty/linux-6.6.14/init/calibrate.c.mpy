{
  "module_name": "calibrate.c",
  "hash_id": "7d8d6af163abcc85347549b7599de3925f2797d2e9f5c0c3165b45fff396dc9f",
  "original_prompt": "Ingested from linux-6.6.14/init/calibrate.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n\nunsigned long lpj_fine;\nunsigned long preset_lpj;\nstatic int __init lpj_setup(char *str)\n{\n\tpreset_lpj = simple_strtoul(str,NULL,0);\n\treturn 1;\n}\n\n__setup(\"lpj=\", lpj_setup);\n\n#ifdef ARCH_HAS_READ_CURRENT_TIMER\n\n \n#define DELAY_CALIBRATION_TICKS\t\t\t((HZ < 100) ? 1 : (HZ/100))\n#define MAX_DIRECT_CALIBRATION_RETRIES\t\t5\n\nstatic unsigned long calibrate_delay_direct(void)\n{\n\tunsigned long pre_start, start, post_start;\n\tunsigned long pre_end, end, post_end;\n\tunsigned long start_jiffies;\n\tunsigned long timer_rate_min, timer_rate_max;\n\tunsigned long good_timer_sum = 0;\n\tunsigned long good_timer_count = 0;\n\tunsigned long measured_times[MAX_DIRECT_CALIBRATION_RETRIES];\n\tint max = -1;  \n\tint min = -1;\n\tint i;\n\n\tif (read_current_timer(&pre_start) < 0 )\n\t\treturn 0;\n\n\t \n\n\tfor (i = 0; i < MAX_DIRECT_CALIBRATION_RETRIES; i++) {\n\t\tpre_start = 0;\n\t\tread_current_timer(&start);\n\t\tstart_jiffies = jiffies;\n\t\twhile (time_before_eq(jiffies, start_jiffies + 1)) {\n\t\t\tpre_start = start;\n\t\t\tread_current_timer(&start);\n\t\t}\n\t\tread_current_timer(&post_start);\n\n\t\tpre_end = 0;\n\t\tend = post_start;\n\t\twhile (time_before_eq(jiffies, start_jiffies + 1 +\n\t\t\t\t\t       DELAY_CALIBRATION_TICKS)) {\n\t\t\tpre_end = end;\n\t\t\tread_current_timer(&end);\n\t\t}\n\t\tread_current_timer(&post_end);\n\n\t\ttimer_rate_max = (post_end - pre_start) /\n\t\t\t\t\tDELAY_CALIBRATION_TICKS;\n\t\ttimer_rate_min = (pre_end - post_start) /\n\t\t\t\t\tDELAY_CALIBRATION_TICKS;\n\n\t\t \n\t\tif (start >= post_end)\n\t\t\tprintk(KERN_NOTICE \"calibrate_delay_direct() ignoring \"\n\t\t\t\t\t\"timer_rate as we had a TSC wrap around\"\n\t\t\t\t\t\" start=%lu >=post_end=%lu\\n\",\n\t\t\t\tstart, post_end);\n\t\tif (start < post_end && pre_start != 0 && pre_end != 0 &&\n\t\t    (timer_rate_max - timer_rate_min) < (timer_rate_max >> 3)) {\n\t\t\tgood_timer_count++;\n\t\t\tgood_timer_sum += timer_rate_max;\n\t\t\tmeasured_times[i] = timer_rate_max;\n\t\t\tif (max < 0 || timer_rate_max > measured_times[max])\n\t\t\t\tmax = i;\n\t\t\tif (min < 0 || timer_rate_max < measured_times[min])\n\t\t\t\tmin = i;\n\t\t} else\n\t\t\tmeasured_times[i] = 0;\n\n\t}\n\n\t \n\twhile (good_timer_count > 1) {\n\t\tunsigned long estimate;\n\t\tunsigned long maxdiff;\n\n\t\t \n\t\testimate = (good_timer_sum/good_timer_count);\n\t\tmaxdiff = estimate >> 3;\n\n\t\t \n\t\tif ((measured_times[max] - measured_times[min]) < maxdiff)\n\t\t\treturn estimate;\n\n\t\t \n\t\tgood_timer_sum = 0;\n\t\tgood_timer_count = 0;\n\t\tif ((measured_times[max] - estimate) <\n\t\t\t\t(estimate - measured_times[min])) {\n\t\t\tprintk(KERN_NOTICE \"calibrate_delay_direct() dropping \"\n\t\t\t\t\t\"min bogoMips estimate %d = %lu\\n\",\n\t\t\t\tmin, measured_times[min]);\n\t\t\tmeasured_times[min] = 0;\n\t\t\tmin = max;\n\t\t} else {\n\t\t\tprintk(KERN_NOTICE \"calibrate_delay_direct() dropping \"\n\t\t\t\t\t\"max bogoMips estimate %d = %lu\\n\",\n\t\t\t\tmax, measured_times[max]);\n\t\t\tmeasured_times[max] = 0;\n\t\t\tmax = min;\n\t\t}\n\n\t\tfor (i = 0; i < MAX_DIRECT_CALIBRATION_RETRIES; i++) {\n\t\t\tif (measured_times[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tgood_timer_count++;\n\t\t\tgood_timer_sum += measured_times[i];\n\t\t\tif (measured_times[i] < measured_times[min])\n\t\t\t\tmin = i;\n\t\t\tif (measured_times[i] > measured_times[max])\n\t\t\t\tmax = i;\n\t\t}\n\n\t}\n\n\tprintk(KERN_NOTICE \"calibrate_delay_direct() failed to get a good \"\n\t       \"estimate for loops_per_jiffy.\\nProbably due to long platform \"\n\t\t\"interrupts. Consider using \\\"lpj=\\\" boot option.\\n\");\n\treturn 0;\n}\n#else\nstatic unsigned long calibrate_delay_direct(void)\n{\n\treturn 0;\n}\n#endif\n\n \n#define LPS_PREC 8\n\nstatic unsigned long calibrate_delay_converge(void)\n{\n\t \n\tunsigned long lpj, lpj_base, ticks, loopadd, loopadd_base, chop_limit;\n\tint trials = 0, band = 0, trial_in_band = 0;\n\n\tlpj = (1<<12);\n\n\t \n\tticks = jiffies;\n\twhile (ticks == jiffies)\n\t\t;  \n\t \n\tticks = jiffies;\n\tdo {\n\t\tif (++trial_in_band == (1<<band)) {\n\t\t\t++band;\n\t\t\ttrial_in_band = 0;\n\t\t}\n\t\t__delay(lpj * band);\n\t\ttrials += band;\n\t} while (ticks == jiffies);\n\t \n\ttrials -= band;\n\tloopadd_base = lpj * band;\n\tlpj_base = lpj * trials;\n\nrecalibrate:\n\tlpj = lpj_base;\n\tloopadd = loopadd_base;\n\n\t \n\tchop_limit = lpj >> LPS_PREC;\n\twhile (loopadd > chop_limit) {\n\t\tlpj += loopadd;\n\t\tticks = jiffies;\n\t\twhile (ticks == jiffies)\n\t\t\t;  \n\t\tticks = jiffies;\n\t\t__delay(lpj);\n\t\tif (jiffies != ticks)\t \n\t\t\tlpj -= loopadd;\n\t\tloopadd >>= 1;\n\t}\n\t \n\tif (lpj + loopadd * 2 == lpj_base + loopadd_base * 2) {\n\t\tlpj_base = lpj;\n\t\tloopadd_base <<= 2;\n\t\tgoto recalibrate;\n\t}\n\n\treturn lpj;\n}\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_loops_per_jiffy) = { 0 };\n\n \nunsigned long __attribute__((weak)) calibrate_delay_is_known(void)\n{\n\treturn 0;\n}\n\n \n\nvoid __attribute__((weak)) calibration_delay_done(void)\n{\n}\n\nvoid calibrate_delay(void)\n{\n\tunsigned long lpj;\n\tstatic bool printed;\n\tint this_cpu = smp_processor_id();\n\n\tif (per_cpu(cpu_loops_per_jiffy, this_cpu)) {\n\t\tlpj = per_cpu(cpu_loops_per_jiffy, this_cpu);\n\t\tif (!printed)\n\t\t\tpr_info(\"Calibrating delay loop (skipped) \"\n\t\t\t\t\"already calibrated this CPU\");\n\t} else if (preset_lpj) {\n\t\tlpj = preset_lpj;\n\t\tif (!printed)\n\t\t\tpr_info(\"Calibrating delay loop (skipped) \"\n\t\t\t\t\"preset value.. \");\n\t} else if ((!printed) && lpj_fine) {\n\t\tlpj = lpj_fine;\n\t\tpr_info(\"Calibrating delay loop (skipped), \"\n\t\t\t\"value calculated using timer frequency.. \");\n\t} else if ((lpj = calibrate_delay_is_known())) {\n\t\t;\n\t} else if ((lpj = calibrate_delay_direct()) != 0) {\n\t\tif (!printed)\n\t\t\tpr_info(\"Calibrating delay using timer \"\n\t\t\t\t\"specific routine.. \");\n\t} else {\n\t\tif (!printed)\n\t\t\tpr_info(\"Calibrating delay loop... \");\n\t\tlpj = calibrate_delay_converge();\n\t}\n\tper_cpu(cpu_loops_per_jiffy, this_cpu) = lpj;\n\tif (!printed)\n\t\tpr_cont(\"%lu.%02lu BogoMIPS (lpj=%lu)\\n\",\n\t\t\tlpj/(500000/HZ),\n\t\t\t(lpj/(5000/HZ)) % 100, lpj);\n\n\tloops_per_jiffy = lpj;\n\tprinted = true;\n\n\tcalibration_delay_done();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}