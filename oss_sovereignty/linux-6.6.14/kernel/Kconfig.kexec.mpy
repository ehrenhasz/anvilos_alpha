{
  "module_name": "Kconfig.kexec",
  "hash_id": "312cd1e7b4b7c65d73c4985378cf8f416d46230750d3cc0c1dbb65ae54bbe02c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/Kconfig.kexec",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n\nmenu \"Kexec and crash features\"\n\nconfig CRASH_CORE\n\tbool\n\nconfig KEXEC_CORE\n\tselect CRASH_CORE\n\tbool\n\nconfig KEXEC_ELF\n\tbool\n\nconfig HAVE_IMA_KEXEC\n\tbool\n\nconfig KEXEC\n\tbool \"Enable kexec system call\"\n\tdepends on ARCH_SUPPORTS_KEXEC\n\tselect KEXEC_CORE\n\thelp\n\t  kexec is a system call that implements the ability to shutdown your\n\t  current kernel, and to start another kernel. It is like a reboot\n\t  but it is independent of the system firmware. And like a reboot\n\t  you can start any kernel with it, not just Linux.\n\n\t  The name comes from the similarity to the exec system call.\n\n\t  It is an ongoing process to be certain the hardware in a machine\n\t  is properly shutdown, so do not be surprised if this code does not\n\t  initially work for you. As of this writing the exact hardware\n\t  interface is strongly in flux, so no good recommendation can be\n\t  made.\n\nconfig KEXEC_FILE\n\tbool \"Enable kexec file based system call\"\n\tdepends on ARCH_SUPPORTS_KEXEC_FILE\n\tselect CRYPTO\n\tselect CRYPTO_SHA256\n\tselect KEXEC_CORE\n\thelp\n\t  This is new version of kexec system call. This system call is\n\t  file based and takes file descriptors as system call argument\n\t  for kernel and initramfs as opposed to list of segments as\n\t  accepted by kexec system call.\n\nconfig KEXEC_SIG\n\tbool \"Verify kernel signature during kexec_file_load() syscall\"\n\tdepends on ARCH_SUPPORTS_KEXEC_SIG\n\tdepends on KEXEC_FILE\n\thelp\n\t  This option makes the kexec_file_load() syscall check for a valid\n\t  signature of the kernel image. The image can still be loaded without\n\t  a valid signature unless you also enable KEXEC_SIG_FORCE, though if\n\t  there's a signature that we can check, then it must be valid.\n\n\t  In addition to this option, you need to enable signature\n\t  verification for the corresponding kernel image type being\n\t  loaded in order for this to work.\n\nconfig KEXEC_SIG_FORCE\n\tbool \"Require a valid signature in kexec_file_load() syscall\"\n\tdepends on ARCH_SUPPORTS_KEXEC_SIG_FORCE\n\tdepends on KEXEC_SIG\n\thelp\n\t  This option makes kernel signature verification mandatory for\n\t  the kexec_file_load() syscall.\n\nconfig KEXEC_IMAGE_VERIFY_SIG\n\tbool \"Enable Image signature verification support (ARM)\"\n\tdefault ARCH_DEFAULT_KEXEC_IMAGE_VERIFY_SIG\n\tdepends on ARCH_SUPPORTS_KEXEC_IMAGE_VERIFY_SIG\n\tdepends on KEXEC_SIG\n\tdepends on EFI && SIGNED_PE_FILE_VERIFICATION\n\thelp\n\t  Enable Image signature verification support.\n\nconfig KEXEC_BZIMAGE_VERIFY_SIG\n\tbool \"Enable bzImage signature verification support\"\n\tdepends on ARCH_SUPPORTS_KEXEC_BZIMAGE_VERIFY_SIG\n\tdepends on KEXEC_SIG\n\tdepends on SIGNED_PE_FILE_VERIFICATION\n\tselect SYSTEM_TRUSTED_KEYRING\n\thelp\n\t  Enable bzImage signature verification support.\n\nconfig KEXEC_JUMP\n\tbool \"kexec jump\"\n\tdepends on ARCH_SUPPORTS_KEXEC_JUMP\n\tdepends on KEXEC && HIBERNATION\n\thelp\n\t  Jump between original kernel and kexeced kernel and invoke\n\t  code in physical address mode via KEXEC\n\nconfig CRASH_DUMP\n\tbool \"kernel crash dumps\"\n\tdepends on ARCH_SUPPORTS_CRASH_DUMP\n\tselect CRASH_CORE\n\tselect KEXEC_CORE\n\thelp\n\t  Generate crash dump after being started by kexec.\n\t  This should be normally only set in special crash dump kernels\n\t  which are loaded in the main kernel with kexec-tools into\n\t  a specially reserved region and then later executed after\n\t  a crash by kdump/kexec. The crash dump kernel must be compiled\n\t  to a memory address not used by the main kernel or BIOS using\n\t  PHYSICAL_START, or it must be built as a relocatable image\n\t  (CONFIG_RELOCATABLE=y).\n\t  For more details see Documentation/admin-guide/kdump/kdump.rst\n\n\t  For s390, this option also enables zfcpdump.\n\t  See also <file:Documentation/s390/zfcpdump.rst>\n\nconfig CRASH_HOTPLUG\n\tbool \"Update the crash elfcorehdr on system configuration changes\"\n\tdefault y\n\tdepends on CRASH_DUMP && (HOTPLUG_CPU || MEMORY_HOTPLUG)\n\tdepends on ARCH_SUPPORTS_CRASH_HOTPLUG\n\thelp\n\t  Enable direct update to the crash elfcorehdr (which contains\n\t  the list of CPUs and memory regions to be dumped upon a crash)\n\t  in response to hot plug/unplug or online/offline of CPUs or\n\t  memory. This is a much more advanced approach than userspace\n\t  attempting that.\n\n\t  If unsure, say Y.\n\nconfig CRASH_MAX_MEMORY_RANGES\n\tint \"Specify the maximum number of memory regions for the elfcorehdr\"\n\tdefault 8192\n\tdepends on CRASH_HOTPLUG\n\thelp\n\t  For the kexec_file_load() syscall path, specify the maximum number of\n\t  memory regions that the elfcorehdr buffer/segment can accommodate.\n\t  These regions are obtained via walk_system_ram_res(); eg. the\n\t  'System RAM' entries in /proc/iomem.\n\t  This value is combined with NR_CPUS_DEFAULT and multiplied by\n\t  sizeof(Elf64_Phdr) to determine the final elfcorehdr memory buffer/\n\t  segment size.\n\t  The value 8192, for example, covers a (sparsely populated) 1TiB system\n\t  consisting of 128MiB memblocks, while resulting in an elfcorehdr\n\t  memory buffer/segment size under 1MiB. This represents a sane choice\n\t  to accommodate both baremetal and virtual machine configurations.\n\n\t  For the kexec_load() syscall path, CRASH_MAX_MEMORY_RANGES is part of\n\t  the computation behind the value provided through the\n\t  /sys/kernel/crash_elfcorehdr_size attribute.\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}