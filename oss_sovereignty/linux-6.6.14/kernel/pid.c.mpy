{
  "module_name": "pid.c",
  "hash_id": "1a794a4644f57b9fcbba0f79a5f9330484b0b7ac6d28a84a4bfd05baf86b35d4",
  "original_prompt": "Ingested from linux-6.6.14/kernel/pid.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/rculist.h>\n#include <linux/memblock.h>\n#include <linux/pid_namespace.h>\n#include <linux/init_task.h>\n#include <linux/syscalls.h>\n#include <linux/proc_ns.h>\n#include <linux/refcount.h>\n#include <linux/anon_inodes.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/idr.h>\n#include <net/sock.h>\n#include <uapi/linux/pidfd.h>\n\nstruct pid init_struct_pid = {\n\t.count\t\t= REFCOUNT_INIT(1),\n\t.tasks\t\t= {\n\t\t{ .first = NULL },\n\t\t{ .first = NULL },\n\t\t{ .first = NULL },\n\t},\n\t.level\t\t= 0,\n\t.numbers\t= { {\n\t\t.nr\t\t= 0,\n\t\t.ns\t\t= &init_pid_ns,\n\t}, }\n};\n\nint pid_max = PID_MAX_DEFAULT;\n\n#define RESERVED_PIDS\t\t300\n\nint pid_max_min = RESERVED_PIDS + 1;\nint pid_max_max = PID_MAX_LIMIT;\n\n \nstruct pid_namespace init_pid_ns = {\n\t.ns.count = REFCOUNT_INIT(2),\n\t.idr = IDR_INIT(init_pid_ns.idr),\n\t.pid_allocated = PIDNS_ADDING,\n\t.level = 0,\n\t.child_reaper = &init_task,\n\t.user_ns = &init_user_ns,\n\t.ns.inum = PROC_PID_INIT_INO,\n#ifdef CONFIG_PID_NS\n\t.ns.ops = &pidns_operations,\n#endif\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)\n\t.memfd_noexec_scope = MEMFD_NOEXEC_SCOPE_EXEC,\n#endif\n};\nEXPORT_SYMBOL_GPL(init_pid_ns);\n\n \n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);\n\nvoid put_pid(struct pid *pid)\n{\n\tstruct pid_namespace *ns;\n\n\tif (!pid)\n\t\treturn;\n\n\tns = pid->numbers[pid->level].ns;\n\tif (refcount_dec_and_test(&pid->count)) {\n\t\tkmem_cache_free(ns->pid_cachep, pid);\n\t\tput_pid_ns(ns);\n\t}\n}\nEXPORT_SYMBOL_GPL(put_pid);\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}\n\nvoid free_pid(struct pid *pid)\n{\n\t \n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pidmap_lock, flags);\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tstruct upid *upid = pid->numbers + i;\n\t\tstruct pid_namespace *ns = upid->ns;\n\t\tswitch (--ns->pid_allocated) {\n\t\tcase 2:\n\t\tcase 1:\n\t\t\t \n\t\t\twake_up_process(ns->child_reaper);\n\t\t\tbreak;\n\t\tcase PIDNS_ADDING:\n\t\t\t \n\t\t\tWARN_ON(ns->child_reaper);\n\t\t\tns->pid_allocated = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tidr_remove(&ns->idr, upid->nr);\n\t}\n\tspin_unlock_irqrestore(&pidmap_lock, flags);\n\n\tcall_rcu(&pid->rcu, delayed_put_pid);\n}\n\nstruct pid *alloc_pid(struct pid_namespace *ns, pid_t *set_tid,\n\t\t      size_t set_tid_size)\n{\n\tstruct pid *pid;\n\tenum pid_type type;\n\tint i, nr;\n\tstruct pid_namespace *tmp;\n\tstruct upid *upid;\n\tint retval = -ENOMEM;\n\n\t \n\tif (set_tid_size > ns->level + 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpid = kmem_cache_alloc(ns->pid_cachep, GFP_KERNEL);\n\tif (!pid)\n\t\treturn ERR_PTR(retval);\n\n\ttmp = ns;\n\tpid->level = ns->level;\n\n\tfor (i = ns->level; i >= 0; i--) {\n\t\tint tid = 0;\n\n\t\tif (set_tid_size) {\n\t\t\ttid = set_tid[ns->level - i];\n\n\t\t\tretval = -EINVAL;\n\t\t\tif (tid < 1 || tid >= pid_max)\n\t\t\t\tgoto out_free;\n\t\t\t \n\t\t\tif (tid != 1 && !tmp->child_reaper)\n\t\t\t\tgoto out_free;\n\t\t\tretval = -EPERM;\n\t\t\tif (!checkpoint_restore_ns_capable(tmp->user_ns))\n\t\t\t\tgoto out_free;\n\t\t\tset_tid_size--;\n\t\t}\n\n\t\tidr_preload(GFP_KERNEL);\n\t\tspin_lock_irq(&pidmap_lock);\n\n\t\tif (tid) {\n\t\t\tnr = idr_alloc(&tmp->idr, NULL, tid,\n\t\t\t\t       tid + 1, GFP_ATOMIC);\n\t\t\t \n\t\t\tif (nr == -ENOSPC)\n\t\t\t\tnr = -EEXIST;\n\t\t} else {\n\t\t\tint pid_min = 1;\n\t\t\t \n\t\t\tif (idr_get_cursor(&tmp->idr) > RESERVED_PIDS)\n\t\t\t\tpid_min = RESERVED_PIDS;\n\n\t\t\t \n\t\t\tnr = idr_alloc_cyclic(&tmp->idr, NULL, pid_min,\n\t\t\t\t\t      pid_max, GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock_irq(&pidmap_lock);\n\t\tidr_preload_end();\n\n\t\tif (nr < 0) {\n\t\t\tretval = (nr == -ENOSPC) ? -EAGAIN : nr;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tpid->numbers[i].nr = nr;\n\t\tpid->numbers[i].ns = tmp;\n\t\ttmp = tmp->parent;\n\t}\n\n\t \n\tretval = -ENOMEM;\n\n\tget_pid_ns(ns);\n\trefcount_set(&pid->count, 1);\n\tspin_lock_init(&pid->lock);\n\tfor (type = 0; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_HEAD(&pid->tasks[type]);\n\n\tinit_waitqueue_head(&pid->wait_pidfd);\n\tINIT_HLIST_HEAD(&pid->inodes);\n\n\tupid = pid->numbers + ns->level;\n\tspin_lock_irq(&pidmap_lock);\n\tif (!(ns->pid_allocated & PIDNS_ADDING))\n\t\tgoto out_unlock;\n\tfor ( ; upid >= pid->numbers; --upid) {\n\t\t \n\t\tidr_replace(&upid->ns->idr, pid, upid->nr);\n\t\tupid->ns->pid_allocated++;\n\t}\n\tspin_unlock_irq(&pidmap_lock);\n\n\treturn pid;\n\nout_unlock:\n\tspin_unlock_irq(&pidmap_lock);\n\tput_pid_ns(ns);\n\nout_free:\n\tspin_lock_irq(&pidmap_lock);\n\twhile (++i <= ns->level) {\n\t\tupid = pid->numbers + i;\n\t\tidr_remove(&upid->ns->idr, upid->nr);\n\t}\n\n\t \n\tif (ns->pid_allocated == PIDNS_ADDING)\n\t\tidr_set_cursor(&ns->idr, 0);\n\n\tspin_unlock_irq(&pidmap_lock);\n\n\tkmem_cache_free(ns->pid_cachep, pid);\n\treturn ERR_PTR(retval);\n}\n\nvoid disable_pid_allocation(struct pid_namespace *ns)\n{\n\tspin_lock_irq(&pidmap_lock);\n\tns->pid_allocated &= ~PIDNS_ADDING;\n\tspin_unlock_irq(&pidmap_lock);\n}\n\nstruct pid *find_pid_ns(int nr, struct pid_namespace *ns)\n{\n\treturn idr_find(&ns->idr, nr);\n}\nEXPORT_SYMBOL_GPL(find_pid_ns);\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}\nEXPORT_SYMBOL_GPL(find_vpid);\n\nstatic struct pid **task_pid_ptr(struct task_struct *task, enum pid_type type)\n{\n\treturn (type == PIDTYPE_PID) ?\n\t\t&task->thread_pid :\n\t\t&task->signal->pids[type];\n}\n\n \nvoid attach_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid = *task_pid_ptr(task, type);\n\thlist_add_head_rcu(&task->pid_links[type], &pid->tasks[type]);\n}\n\nstatic void __change_pid(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid *new)\n{\n\tstruct pid **pid_ptr = task_pid_ptr(task, type);\n\tstruct pid *pid;\n\tint tmp;\n\n\tpid = *pid_ptr;\n\n\thlist_del_rcu(&task->pid_links[type]);\n\t*pid_ptr = new;\n\n\tfor (tmp = PIDTYPE_MAX; --tmp >= 0; )\n\t\tif (pid_has_task(pid, tmp))\n\t\t\treturn;\n\n\tfree_pid(pid);\n}\n\nvoid detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}\n\nvoid change_pid(struct task_struct *task, enum pid_type type,\n\t\tstruct pid *pid)\n{\n\t__change_pid(task, type, pid);\n\tattach_pid(task, type);\n}\n\nvoid exchange_tids(struct task_struct *left, struct task_struct *right)\n{\n\tstruct pid *pid1 = left->thread_pid;\n\tstruct pid *pid2 = right->thread_pid;\n\tstruct hlist_head *head1 = &pid1->tasks[PIDTYPE_PID];\n\tstruct hlist_head *head2 = &pid2->tasks[PIDTYPE_PID];\n\n\t \n\thlists_swap_heads_rcu(head1, head2);\n\n\t \n\trcu_assign_pointer(left->thread_pid, pid2);\n\trcu_assign_pointer(right->thread_pid, pid1);\n\n\t \n\tWRITE_ONCE(left->pid, pid_nr(pid2));\n\tWRITE_ONCE(right->pid, pid_nr(pid1));\n}\n\n \nvoid transfer_pid(struct task_struct *old, struct task_struct *new,\n\t\t\t   enum pid_type type)\n{\n\tif (type == PIDTYPE_PID)\n\t\tnew->thread_pid = old->thread_pid;\n\thlist_replace_rcu(&old->pid_links[type], &new->pid_links[type]);\n}\n\nstruct task_struct *pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result = NULL;\n\tif (pid) {\n\t\tstruct hlist_node *first;\n\t\tfirst = rcu_dereference_check(hlist_first_rcu(&pid->tasks[type]),\n\t\t\t\t\t      lockdep_tasklist_lock_is_held());\n\t\tif (first)\n\t\t\tresult = hlist_entry(first, struct task_struct, pid_links[(type)]);\n\t}\n\treturn result;\n}\nEXPORT_SYMBOL(pid_task);\n\n \nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}\n\nstruct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}\n\nstruct pid *get_task_pid(struct task_struct *task, enum pid_type type)\n{\n\tstruct pid *pid;\n\trcu_read_lock();\n\tpid = get_pid(rcu_dereference(*task_pid_ptr(task, type)));\n\trcu_read_unlock();\n\treturn pid;\n}\nEXPORT_SYMBOL_GPL(get_task_pid);\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(get_pid_task);\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}\nEXPORT_SYMBOL_GPL(find_get_pid);\n\npid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)\n{\n\tstruct upid *upid;\n\tpid_t nr = 0;\n\n\tif (pid && ns->level <= pid->level) {\n\t\tupid = &pid->numbers[ns->level];\n\t\tif (upid->ns == ns)\n\t\t\tnr = upid->nr;\n\t}\n\treturn nr;\n}\nEXPORT_SYMBOL_GPL(pid_nr_ns);\n\npid_t pid_vnr(struct pid *pid)\n{\n\treturn pid_nr_ns(pid, task_active_pid_ns(current));\n}\nEXPORT_SYMBOL_GPL(pid_vnr);\n\npid_t __task_pid_nr_ns(struct task_struct *task, enum pid_type type,\n\t\t\tstruct pid_namespace *ns)\n{\n\tpid_t nr = 0;\n\n\trcu_read_lock();\n\tif (!ns)\n\t\tns = task_active_pid_ns(current);\n\tnr = pid_nr_ns(rcu_dereference(*task_pid_ptr(task, type)), ns);\n\trcu_read_unlock();\n\n\treturn nr;\n}\nEXPORT_SYMBOL(__task_pid_nr_ns);\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}\nEXPORT_SYMBOL_GPL(task_active_pid_ns);\n\n \nstruct pid *find_ge_pid(int nr, struct pid_namespace *ns)\n{\n\treturn idr_get_next(&ns->idr, &nr);\n}\nEXPORT_SYMBOL_GPL(find_ge_pid);\n\nstruct pid *pidfd_get_pid(unsigned int fd, unsigned int *flags)\n{\n\tstruct fd f;\n\tstruct pid *pid;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tpid = pidfd_pid(f.file);\n\tif (!IS_ERR(pid)) {\n\t\tget_pid(pid);\n\t\t*flags = f.file->f_flags;\n\t}\n\n\tfdput(f);\n\treturn pid;\n}\n\n \nstruct task_struct *pidfd_get_task(int pidfd, unsigned int *flags)\n{\n\tunsigned int f_flags;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\n\tpid = pidfd_get_pid(pidfd, &f_flags);\n\tif (IS_ERR(pid))\n\t\treturn ERR_CAST(pid);\n\n\ttask = get_pid_task(pid, PIDTYPE_TGID);\n\tput_pid(pid);\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\t*flags = f_flags;\n\treturn task;\n}\n\n \nint pidfd_create(struct pid *pid, unsigned int flags)\n{\n\tint pidfd;\n\tstruct file *pidfd_file;\n\n\tpidfd = pidfd_prepare(pid, flags, &pidfd_file);\n\tif (pidfd < 0)\n\t\treturn pidfd;\n\n\tfd_install(pidfd, pidfd_file);\n\treturn pidfd;\n}\n\n \nSYSCALL_DEFINE2(pidfd_open, pid_t, pid, unsigned int, flags)\n{\n\tint fd;\n\tstruct pid *p;\n\n\tif (flags & ~PIDFD_NONBLOCK)\n\t\treturn -EINVAL;\n\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\tp = find_get_pid(pid);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tfd = pidfd_create(p, flags);\n\n\tput_pid(p);\n\treturn fd;\n}\n\nvoid __init pid_idr_init(void)\n{\n\t \n\tBUILD_BUG_ON(PID_MAX_LIMIT >= PIDNS_ADDING);\n\n\t \n\tpid_max = min(pid_max_max, max_t(int, pid_max,\n\t\t\t\tPIDS_PER_CPU_DEFAULT * num_possible_cpus()));\n\tpid_max_min = max_t(int, pid_max_min,\n\t\t\t\tPIDS_PER_CPU_MIN * num_possible_cpus());\n\tpr_info(\"pid_max: default: %u minimum: %u\\n\", pid_max, pid_max_min);\n\n\tidr_init(&init_pid_ns.idr);\n\n\tinit_pid_ns.pid_cachep = kmem_cache_create(\"pid\",\n\t\t\tstruct_size_t(struct pid, numbers, 1),\n\t\t\t__alignof__(struct pid),\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT,\n\t\t\tNULL);\n}\n\nstatic struct file *__pidfd_fget(struct task_struct *task, int fd)\n{\n\tstruct file *file;\n\tint ret;\n\n\tret = down_read_killable(&task->signal->exec_update_lock);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS))\n\t\tfile = fget_task(task, fd);\n\telse\n\t\tfile = ERR_PTR(-EPERM);\n\n\tup_read(&task->signal->exec_update_lock);\n\n\treturn file ?: ERR_PTR(-EBADF);\n}\n\nstatic int pidfd_getfd(struct pid *pid, int fd)\n{\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint ret;\n\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tfile = __pidfd_fget(task, fd);\n\tput_task_struct(task);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = receive_fd(file, O_CLOEXEC);\n\tfput(file);\n\n\treturn ret;\n}\n\n \nSYSCALL_DEFINE3(pidfd_getfd, int, pidfd, int, fd,\n\t\tunsigned int, flags)\n{\n\tstruct pid *pid;\n\tstruct fd f;\n\tint ret;\n\n\t \n\tif (flags)\n\t\treturn -EINVAL;\n\n\tf = fdget(pidfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tpid = pidfd_pid(f.file);\n\tif (IS_ERR(pid))\n\t\tret = PTR_ERR(pid);\n\telse\n\t\tret = pidfd_getfd(pid, fd);\n\n\tfdput(f);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}