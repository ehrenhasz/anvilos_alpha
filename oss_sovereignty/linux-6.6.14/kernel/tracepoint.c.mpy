{
  "module_name": "tracepoint.c",
  "hash_id": "ddd7457f5bd0ca984bf9bb385dad1a933b93d63d3a8cd4c9ac480086cbadff08",
  "original_prompt": "Ingested from linux-6.6.14/kernel/tracepoint.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/jhash.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/tracepoint.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/static_key.h>\n\nenum tp_func_state {\n\tTP_FUNC_0,\n\tTP_FUNC_1,\n\tTP_FUNC_2,\n\tTP_FUNC_N,\n};\n\nextern tracepoint_ptr_t __start___tracepoints_ptrs[];\nextern tracepoint_ptr_t __stop___tracepoints_ptrs[];\n\nDEFINE_SRCU(tracepoint_srcu);\nEXPORT_SYMBOL_GPL(tracepoint_srcu);\n\nenum tp_transition_sync {\n\tTP_TRANSITION_SYNC_1_0_1,\n\tTP_TRANSITION_SYNC_N_2_1,\n\n\t_NR_TP_TRANSITION_SYNC,\n};\n\nstruct tp_transition_snapshot {\n\tunsigned long rcu;\n\tunsigned long srcu;\n\tbool ongoing;\n};\n\n \nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t \n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}\n\nstatic void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}\n\n \nstatic const int tracepoint_debug;\n\n#ifdef CONFIG_MODULES\n \nstatic DEFINE_MUTEX(tracepoint_module_list_mutex);\n\n \nstatic LIST_HEAD(tracepoint_module_list);\n#endif  \n\n \nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\n \nstruct tp_probes {\n\tstruct rcu_head rcu;\n\tstruct tracepoint_func probes[];\n};\n\n \nstatic void tp_stub_func(void)\n{\n\treturn;\n}\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}\n\nstatic void srcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}\n\nstatic void rcu_free_old_probes(struct rcu_head *head)\n{\n\tcall_srcu(&tracepoint_srcu, head, srcu_free_old_probes);\n}\n\nstatic __init int release_early_probes(void)\n{\n\tstruct rcu_head *tmp;\n\n\tok_to_free_tracepoints = true;\n\n\twhile (early_probes) {\n\t\ttmp = early_probes;\n\t\tearly_probes = tmp->next;\n\t\tcall_rcu(tmp, rcu_free_old_probes);\n\t}\n\n\treturn 0;\n}\n\n \npostcore_initcall(release_early_probes);\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t \n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}\n\nstatic struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint iter_probes;\t \n\tint nr_probes = 0;\t \n\tint pos = -1;\t\t \n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t \n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\t \n\t\t\tif (old[iter_probes].func == tp_func->func &&\n\t\t\t    old[iter_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\tnr_probes++;\n\t\t}\n\t}\n\t \n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tnr_probes = 0;\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (pos < 0 && old[iter_probes].prio < prio)\n\t\t\t\tpos = nr_probes++;\n\t\t\tnew[nr_probes++] = old[iter_probes];\n\t\t}\n\t\tif (pos < 0)\n\t\t\tpos = nr_probes++;\n\t\t \n\t} else {\n\t\tpos = 0;\n\t\tnr_probes = 1;  \n\t}\n\tnew[pos] = *tp_func;\n\tnew[nr_probes].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t \n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif ((old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data) ||\n\t\t\t    old[nr_probes].func == tp_stub_func)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t \n\tif (nr_probes - nr_del == 0) {\n\t\t \n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t \n\t\t \n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new) {\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif ((old[i].func != tp_func->func ||\n\t\t\t\t     old[i].data != tp_func->data) &&\n\t\t\t\t    old[i].func != tp_stub_func)\n\t\t\t\t\tnew[j++] = old[i];\n\t\t\t}\n\t\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t\t*funcs = new;\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif (old[i].func == tp_func->func &&\n\t\t\t\t    old[i].data == tp_func->data)\n\t\t\t\t\tWRITE_ONCE(old[i].func, tp_stub_func);\n\t\t\t}\n\t\t\t*funcs = old;\n\t\t}\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}\n\n \nstatic enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t \n}\n\nstatic void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t \n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}\n\n \nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t \n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t \n\t\t \n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t \n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t \n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t \n\t\t \n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t \n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t \n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t \n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}\n\n \nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (WARN_ON_ONCE(IS_ERR(old)))\n\t\treturn PTR_ERR(old);\n\n\tif (tp_funcs == old)\n\t\t \n\t\treturn 0;\n\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_0:\t\t \n\t\t \n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tstatic_key_disable(&tp->key);\n\t\t \n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t \n\t\trcu_assign_pointer(tp->funcs, NULL);\n\t\t \n\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_1_0_1);\n\t\tbreak;\n\tcase TP_FUNC_1:\t\t \n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t \n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_N_2_1);\n\t\t \n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t \n\t\tfallthrough;\n\tcase TP_FUNC_N:\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t \n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\trelease_probes(old);\n\treturn 0;\n}\n\n \nint tracepoint_probe_register_prio_may_exist(struct tracepoint *tp, void *probe,\n\t\t\t\t\t     void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, false);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tracepoint_probe_register_prio_may_exist);\n\n \nint tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, true);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tracepoint_probe_register_prio);\n\n \nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}\nEXPORT_SYMBOL_GPL(tracepoint_probe_register);\n\n \nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tracepoint_probe_unregister);\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}\n\n#ifdef CONFIG_MODULES\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t\t(1 << TAINT_UNSIGNED_MODULE) | (1 << TAINT_TEST) |\n\t\t\t\t(1 << TAINT_LIVEPATCH));\n}\n\nstatic BLOCKING_NOTIFIER_HEAD(tracepoint_notify_list);\n\n \nint register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_tracepoint_module_notifier);\n\n \nint unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_GOING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(unregister_tracepoint_module_notifier);\n\n \nstatic void tp_module_going_check_quiescent(struct tracepoint *tp, void *priv)\n{\n\tWARN_ON_ONCE(tp->funcs);\n}\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t \n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod)\n\t\treturn -ENOMEM;\n\ttp_mod->mod = mod;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn 0;\n}\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t \n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tmutex_unlock(&tracepoint_module_list_mutex);\n}\n\nstatic int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_LIVE:\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase MODULE_STATE_UNFORMED:\n\t\tbreak;\n\t}\n\treturn notifier_from_errno(ret);\n}\n\nstatic struct notifier_block tracepoint_module_nb = {\n\t.notifier_call = tracepoint_module_notify,\n\t.priority = 0,\n};\n\nstatic __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register tracepoint module enter notifier\\n\");\n\n\treturn ret;\n}\n__initcall(init_tracepoints);\n#endif  \n\n \nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}\nEXPORT_SYMBOL_GPL(for_each_kernel_tracepoint);\n\n#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS\n\n \nstatic int sys_tracepoint_refcount;\n\nint syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_task_syscall_work(t, SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n\n\treturn 0;\n}\n\nvoid syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_task_syscall_work(t, SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}