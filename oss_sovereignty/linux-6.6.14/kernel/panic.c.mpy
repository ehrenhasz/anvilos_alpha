{
  "module_name": "panic.c",
  "hash_id": "91f94a9d081966af5e8b5d43051f8f591f72a66e3655d1f689bdbef620b449af",
  "original_prompt": "Ingested from linux-6.6.14/kernel/panic.c",
  "human_readable_source": "\n \n\n \n#include <linux/debug_locks.h>\n#include <linux/sched/debug.h>\n#include <linux/interrupt.h>\n#include <linux/kgdb.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kallsyms.h>\n#include <linux/notifier.h>\n#include <linux/vt_kern.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/delay.h>\n#include <linux/kexec.h>\n#include <linux/panic_notifier.h>\n#include <linux/sched.h>\n#include <linux/string_helpers.h>\n#include <linux/sysrq.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/console.h>\n#include <linux/bug.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/sysfs.h>\n#include <linux/context_tracking.h>\n#include <trace/events/error_report.h>\n#include <asm/sections.h>\n\n#define PANIC_TIMER_STEP 100\n#define PANIC_BLINK_SPD 18\n\n#ifdef CONFIG_SMP\n \nstatic unsigned int __read_mostly sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif  \n\nint panic_on_oops = CONFIG_PANIC_ON_OOPS_VALUE;\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nstatic int pause_on_oops;\nstatic int pause_on_oops_flag;\nstatic DEFINE_SPINLOCK(pause_on_oops_lock);\nbool crash_kexec_post_notifiers;\nint panic_on_warn __read_mostly;\nunsigned long panic_on_taint;\nbool panic_on_taint_nousertaint = false;\nstatic unsigned int warn_limit __read_mostly;\n\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nEXPORT_SYMBOL_GPL(panic_timeout);\n\n#define PANIC_PRINT_TASK_INFO\t\t0x00000001\n#define PANIC_PRINT_MEM_INFO\t\t0x00000002\n#define PANIC_PRINT_TIMER_INFO\t\t0x00000004\n#define PANIC_PRINT_LOCK_INFO\t\t0x00000008\n#define PANIC_PRINT_FTRACE_INFO\t\t0x00000010\n#define PANIC_PRINT_ALL_PRINTK_MSG\t0x00000020\n#define PANIC_PRINT_ALL_CPU_BT\t\t0x00000040\nunsigned long panic_print;\n\nATOMIC_NOTIFIER_HEAD(panic_notifier_list);\n\nEXPORT_SYMBOL(panic_notifier_list);\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table kern_panic_table[] = {\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname       = \"oops_all_cpu_backtrace\",\n\t\t.data           = &sysctl_oops_all_cpu_backtrace,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname       = \"warn_limit\",\n\t\t.data           = &warn_limit,\n\t\t.maxlen         = sizeof(warn_limit),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_douintvec,\n\t},\n\t{ }\n};\n\nstatic __init int kernel_panic_sysctls_init(void)\n{\n\tregister_sysctl_init(\"kernel\", kern_panic_table);\n\treturn 0;\n}\nlate_initcall(kernel_panic_sysctls_init);\n#endif\n\nstatic atomic_t warn_count = ATOMIC_INIT(0);\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t warn_count_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *page)\n{\n\treturn sysfs_emit(page, \"%d\\n\", atomic_read(&warn_count));\n}\n\nstatic struct kobj_attribute warn_count_attr = __ATTR_RO(warn_count);\n\nstatic __init int kernel_panic_sysfs_init(void)\n{\n\tsysfs_add_file_to_group(kernel_kobj, &warn_count_attr.attr, NULL);\n\treturn 0;\n}\nlate_initcall(kernel_panic_sysfs_init);\n#endif\n\nstatic long no_blink(int state)\n{\n\treturn 0;\n}\n\n \nlong (*panic_blink)(int state);\nEXPORT_SYMBOL(panic_blink);\n\n \nvoid __weak __noreturn panic_smp_self_stop(void)\n{\n\twhile (1)\n\t\tcpu_relax();\n}\n\n \nvoid __weak __noreturn nmi_panic_self_stop(struct pt_regs *regs)\n{\n\tpanic_smp_self_stop();\n}\n\n \nvoid __weak crash_smp_send_stop(void)\n{\n\tstatic int cpus_stopped;\n\n\t \n\tif (cpus_stopped)\n\t\treturn;\n\n\t \n\tsmp_send_stop();\n\tcpus_stopped = 1;\n}\n\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\n \nvoid nmi_panic(struct pt_regs *regs, const char *msg)\n{\n\tint old_cpu, cpu;\n\n\tcpu = raw_smp_processor_id();\n\told_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);\n\n\tif (old_cpu == PANIC_CPU_INVALID)\n\t\tpanic(\"%s\", msg);\n\telse if (old_cpu != cpu)\n\t\tnmi_panic_self_stop(regs);\n}\nEXPORT_SYMBOL(nmi_panic);\n\nstatic void panic_print_sys_info(bool console_flush)\n{\n\tif (console_flush) {\n\t\tif (panic_print & PANIC_PRINT_ALL_PRINTK_MSG)\n\t\t\tconsole_flush_on_panic(CONSOLE_REPLAY_ALL);\n\t\treturn;\n\t}\n\n\tif (panic_print & PANIC_PRINT_TASK_INFO)\n\t\tshow_state();\n\n\tif (panic_print & PANIC_PRINT_MEM_INFO)\n\t\tshow_mem();\n\n\tif (panic_print & PANIC_PRINT_TIMER_INFO)\n\t\tsysrq_timer_list_show();\n\n\tif (panic_print & PANIC_PRINT_LOCK_INFO)\n\t\tdebug_show_all_locks();\n\n\tif (panic_print & PANIC_PRINT_FTRACE_INFO)\n\t\tftrace_dump(DUMP_ALL);\n}\n\nvoid check_panic_on_warn(const char *origin)\n{\n\tunsigned int limit;\n\n\tif (panic_on_warn)\n\t\tpanic(\"%s: panic_on_warn set ...\\n\", origin);\n\n\tlimit = READ_ONCE(warn_limit);\n\tif (atomic_inc_return(&warn_count) >= limit && limit)\n\t\tpanic(\"%s: system warned too often (kernel.warn_limit is %d)\",\n\t\t      origin, limit);\n}\n\n \nstatic void panic_other_cpus_shutdown(bool crash_kexec)\n{\n\tif (panic_print & PANIC_PRINT_ALL_CPU_BT)\n\t\ttrigger_all_cpu_backtrace();\n\n\t \n\tif (!crash_kexec)\n\t\tsmp_send_stop();\n\telse\n\t\tcrash_smp_send_stop();\n}\n\n \nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\tif (panic_on_warn) {\n\t\t \n\t\tpanic_on_warn = 0;\n\t}\n\n\t \n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t \n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t \n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t \n\tkgdb_panic(buf);\n\n\t \n\tif (!_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tpanic_other_cpus_shutdown(_crash_kexec_post_notifiers);\n\n\t \n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tpanic_print_sys_info(false);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t \n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tconsole_unblank();\n\n\t \n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info(true);\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t \n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t \n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t \n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t \n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}\n\nEXPORT_SYMBOL(panic);\n\n \nconst struct taint_flag taint_flags[TAINT_FLAGS_COUNT] = {\n\t[ TAINT_PROPRIETARY_MODULE ]\t= { 'P', 'G', true },\n\t[ TAINT_FORCED_MODULE ]\t\t= { 'F', ' ', true },\n\t[ TAINT_CPU_OUT_OF_SPEC ]\t= { 'S', ' ', false },\n\t[ TAINT_FORCED_RMMOD ]\t\t= { 'R', ' ', false },\n\t[ TAINT_MACHINE_CHECK ]\t\t= { 'M', ' ', false },\n\t[ TAINT_BAD_PAGE ]\t\t= { 'B', ' ', false },\n\t[ TAINT_USER ]\t\t\t= { 'U', ' ', false },\n\t[ TAINT_DIE ]\t\t\t= { 'D', ' ', false },\n\t[ TAINT_OVERRIDDEN_ACPI_TABLE ]\t= { 'A', ' ', false },\n\t[ TAINT_WARN ]\t\t\t= { 'W', ' ', false },\n\t[ TAINT_CRAP ]\t\t\t= { 'C', ' ', true },\n\t[ TAINT_FIRMWARE_WORKAROUND ]\t= { 'I', ' ', false },\n\t[ TAINT_OOT_MODULE ]\t\t= { 'O', ' ', true },\n\t[ TAINT_UNSIGNED_MODULE ]\t= { 'E', ' ', true },\n\t[ TAINT_SOFTLOCKUP ]\t\t= { 'L', ' ', false },\n\t[ TAINT_LIVEPATCH ]\t\t= { 'K', ' ', true },\n\t[ TAINT_AUX ]\t\t\t= { 'X', ' ', true },\n\t[ TAINT_RANDSTRUCT ]\t\t= { 'T', ' ', true },\n\t[ TAINT_TEST ]\t\t\t= { 'N', ' ', true },\n};\n\n \nconst char *print_tainted(void)\n{\n\tstatic char buf[TAINT_FLAGS_COUNT + sizeof(\"Tainted: \")];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(taint_flags) != TAINT_FLAGS_COUNT);\n\n\tif (tainted_mask) {\n\t\tchar *s;\n\t\tint i;\n\n\t\ts = buf + sprintf(buf, \"Tainted: \");\n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\t\tconst struct taint_flag *t = &taint_flags[i];\n\t\t\t*s++ = test_bit(i, &tainted_mask) ?\n\t\t\t\t\tt->c_true : t->c_false;\n\t\t}\n\t\t*s = 0;\n\t} else\n\t\tsnprintf(buf, sizeof(buf), \"Not tainted\");\n\n\treturn buf;\n}\n\nint test_taint(unsigned flag)\n{\n\treturn test_bit(flag, &tainted_mask);\n}\nEXPORT_SYMBOL(test_taint);\n\nunsigned long get_taint(void)\n{\n\treturn tainted_mask;\n}\n\n \nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}\nEXPORT_SYMBOL(add_taint);\n\nstatic void spin_msec(int msecs)\n{\n\tint i;\n\n\tfor (i = 0; i < msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}\n\n \nstatic void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t \n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t \n\t\tif (!spin_counter) {\n\t\t\t \n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(MSEC_PER_SEC);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t \n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}\n\n \nbool oops_may_print(void)\n{\n\treturn pause_on_oops_flag == 0;\n}\n\n \nvoid oops_enter(void)\n{\n\ttracing_off();\n\t \n\tdebug_locks_off();\n\tdo_oops_enter_exit();\n\n\tif (sysctl_oops_all_cpu_backtrace)\n\t\ttrigger_all_cpu_backtrace();\n}\n\nstatic void print_oops_end_marker(void)\n{\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", 0ULL);\n}\n\n \nvoid oops_exit(void)\n{\n\tdo_oops_enter_exit();\n\tprint_oops_end_marker();\n\tkmsg_dump(KMSG_DUMP_OOPS);\n}\n\nstruct warn_args {\n\tconst char *fmt;\n\tva_list args;\n};\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args)\n{\n\tdisable_trace_on_warning();\n\n\tif (file)\n\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %s:%d %pS\\n\",\n\t\t\traw_smp_processor_id(), current->pid, file, line,\n\t\t\tcaller);\n\telse\n\t\tpr_warn(\"WARNING: CPU: %d PID: %d at %pS\\n\",\n\t\t\traw_smp_processor_id(), current->pid, caller);\n\n\tif (args)\n\t\tvprintk(args->fmt, args->args);\n\n\tprint_modules();\n\n\tif (regs)\n\t\tshow_regs(regs);\n\n\tcheck_panic_on_warn(\"kernel\");\n\n\tif (!regs)\n\t\tdump_stack();\n\n\tprint_irqtrace_events(current);\n\n\tprint_oops_end_marker();\n\ttrace_error_report_end(ERROR_DETECTOR_WARN, (unsigned long)caller);\n\n\t \n\tadd_taint(taint, LOCKDEP_STILL_OK);\n}\n\n#ifdef CONFIG_BUG\n#ifndef __WARN_FLAGS\nvoid warn_slowpath_fmt(const char *file, int line, unsigned taint,\n\t\t       const char *fmt, ...)\n{\n\tbool rcu = warn_rcu_enter();\n\tstruct warn_args args;\n\n\tpr_warn(CUT_HERE);\n\n\tif (!fmt) {\n\t\t__warn(file, line, __builtin_return_address(0), taint,\n\t\t       NULL, NULL);\n\t\twarn_rcu_exit(rcu);\n\t\treturn;\n\t}\n\n\targs.fmt = fmt;\n\tva_start(args.args, fmt);\n\t__warn(file, line, __builtin_return_address(0), taint, NULL, &args);\n\tva_end(args.args);\n\twarn_rcu_exit(rcu);\n}\nEXPORT_SYMBOL(warn_slowpath_fmt);\n#else\nvoid __warn_printk(const char *fmt, ...)\n{\n\tbool rcu = warn_rcu_enter();\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n\twarn_rcu_exit(rcu);\n}\nEXPORT_SYMBOL(__warn_printk);\n#endif\n\n \n\nstatic int clear_warn_once_set(void *data, u64 val)\n{\n\tgeneric_bug_clear_once();\n\tmemset(__start_once, 0, __end_once - __start_once);\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(clear_warn_once_fops, NULL, clear_warn_once_set,\n\t\t\t \"%lld\\n\");\n\nstatic __init int register_warn_debugfs(void)\n{\n\t \n\tdebugfs_create_file_unsafe(\"clear_warn_once\", 0200, NULL, NULL,\n\t\t\t\t   &clear_warn_once_fops);\n\treturn 0;\n}\n\ndevice_initcall(register_warn_debugfs);\n#endif\n\n#ifdef CONFIG_STACKPROTECTOR\n\n \n__visible noinstr void __stack_chk_fail(void)\n{\n\tinstrumentation_begin();\n\tpanic(\"stack-protector: Kernel stack is corrupted in: %pB\",\n\t\t__builtin_return_address(0));\n\tinstrumentation_end();\n}\nEXPORT_SYMBOL(__stack_chk_fail);\n\n#endif\n\ncore_param(panic, panic_timeout, int, 0644);\ncore_param(panic_print, panic_print, ulong, 0644);\ncore_param(pause_on_oops, pause_on_oops, int, 0644);\ncore_param(panic_on_warn, panic_on_warn, int, 0644);\ncore_param(crash_kexec_post_notifiers, crash_kexec_post_notifiers, bool, 0644);\n\nstatic int __init oops_setup(char *s)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\tif (!strcmp(s, \"panic\"))\n\t\tpanic_on_oops = 1;\n\treturn 0;\n}\nearly_param(\"oops\", oops_setup);\n\nstatic int __init panic_on_taint_setup(char *s)\n{\n\tchar *taint_str;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\ttaint_str = strsep(&s, \",\");\n\tif (kstrtoul(taint_str, 16, &panic_on_taint))\n\t\treturn -EINVAL;\n\n\t \n\tpanic_on_taint &= TAINT_FLAGS_MAX;\n\n\tif (!panic_on_taint)\n\t\treturn -EINVAL;\n\n\tif (s && !strcmp(s, \"nousertaint\"))\n\t\tpanic_on_taint_nousertaint = true;\n\n\tpr_info(\"panic_on_taint: bitmask=0x%lx nousertaint_mode=%s\\n\",\n\t\tpanic_on_taint, str_enabled_disabled(panic_on_taint_nousertaint));\n\n\treturn 0;\n}\nearly_param(\"panic_on_taint\", panic_on_taint_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}