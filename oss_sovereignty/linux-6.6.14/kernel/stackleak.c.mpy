{
  "module_name": "stackleak.c",
  "hash_id": "f83df15eea79ab5ab9b54ba6731eb7c1bc5342a01c874c6e202280538f458361",
  "original_prompt": "Ingested from linux-6.6.14/kernel/stackleak.c",
  "human_readable_source": "\n \n\n#include <linux/stackleak.h>\n#include <linux/kprobes.h>\n\n#ifdef CONFIG_STACKLEAK_RUNTIME_DISABLE\n#include <linux/jump_label.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(stack_erasing_bypass);\n\n#ifdef CONFIG_SYSCTL\nstatic int stack_erasing_sysctl(struct ctl_table *table, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret = 0;\n\tint state = !static_branch_unlikely(&stack_erasing_bypass);\n\tint prev_state = state;\n\n\ttable->data = &state;\n\ttable->maxlen = sizeof(int);\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tstate = !!state;\n\tif (ret || !write || state == prev_state)\n\t\treturn ret;\n\n\tif (state)\n\t\tstatic_branch_disable(&stack_erasing_bypass);\n\telse\n\t\tstatic_branch_enable(&stack_erasing_bypass);\n\n\tpr_warn(\"stackleak: kernel stack erasing is %s\\n\",\n\t\t\t\t\tstate ? \"enabled\" : \"disabled\");\n\treturn ret;\n}\nstatic struct ctl_table stackleak_sysctls[] = {\n\t{\n\t\t.procname\t= \"stack_erasing\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= stack_erasing_sysctl,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{}\n};\n\nstatic int __init stackleak_sysctls_init(void)\n{\n\tregister_sysctl_init(\"kernel\", stackleak_sysctls);\n\treturn 0;\n}\nlate_initcall(stackleak_sysctls_init);\n#endif  \n\n#define skip_erasing()\tstatic_branch_unlikely(&stack_erasing_bypass)\n#else\n#define skip_erasing()\tfalse\n#endif  \n\n#ifndef __stackleak_poison\nstatic __always_inline void __stackleak_poison(unsigned long erase_low,\n\t\t\t\t\t       unsigned long erase_high,\n\t\t\t\t\t       unsigned long poison)\n{\n\twhile (erase_low < erase_high) {\n\t\t*(unsigned long *)erase_low = poison;\n\t\terase_low += sizeof(unsigned long);\n\t}\n}\n#endif\n\nstatic __always_inline void __stackleak_erase(bool on_task_stack)\n{\n\tconst unsigned long task_stack_low = stackleak_task_low_bound(current);\n\tconst unsigned long task_stack_high = stackleak_task_high_bound(current);\n\tunsigned long erase_low, erase_high;\n\n\terase_low = stackleak_find_top_of_poison(task_stack_low,\n\t\t\t\t\t\t current->lowest_stack);\n\n#ifdef CONFIG_STACKLEAK_METRICS\n\tcurrent->prev_lowest_stack = erase_low;\n#endif\n\n\t \n\tif (on_task_stack)\n\t\terase_high = current_stack_pointer;\n\telse\n\t\terase_high = task_stack_high;\n\n\t__stackleak_poison(erase_low, erase_high, STACKLEAK_POISON);\n\n\t \n\tcurrent->lowest_stack = task_stack_high;\n}\n\n \nasmlinkage void noinstr stackleak_erase(void)\n{\n\tif (skip_erasing())\n\t\treturn;\n\n\t__stackleak_erase(on_thread_stack());\n}\n\n \nasmlinkage void noinstr stackleak_erase_on_task_stack(void)\n{\n\tif (skip_erasing())\n\t\treturn;\n\n\t__stackleak_erase(true);\n}\n\n \nasmlinkage void noinstr stackleak_erase_off_task_stack(void)\n{\n\tif (skip_erasing())\n\t\treturn;\n\n\t__stackleak_erase(false);\n}\n\nvoid __used __no_caller_saved_registers noinstr stackleak_track_stack(void)\n{\n\tunsigned long sp = current_stack_pointer;\n\n\t \n\tBUILD_BUG_ON(CONFIG_STACKLEAK_TRACK_MIN_SIZE > STACKLEAK_SEARCH_DEPTH);\n\n\t \n\tsp = ALIGN(sp, sizeof(unsigned long));\n\tif (sp < current->lowest_stack &&\n\t    sp >= stackleak_task_low_bound(current)) {\n\t\tcurrent->lowest_stack = sp;\n\t}\n}\nEXPORT_SYMBOL(stackleak_track_stack);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}