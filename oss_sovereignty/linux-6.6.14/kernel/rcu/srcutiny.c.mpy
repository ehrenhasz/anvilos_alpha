{
  "module_name": "srcutiny.c",
  "hash_id": "f94ee23050d5da2e171005162dfe18e64a1c12bc98402c6cf048480295739c07",
  "original_prompt": "Ingested from linux-6.6.14/kernel/rcu/srcutiny.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/preempt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/srcu.h>\n\n#include <linux/rcu_node_tree.h>\n#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n\nint rcu_scheduler_active __read_mostly;\nstatic LIST_HEAD(srcu_boot_list);\nstatic bool srcu_init_done;\n\nstatic int init_srcu_struct_fields(struct srcu_struct *ssp)\n{\n\tssp->srcu_lock_nesting[0] = 0;\n\tssp->srcu_lock_nesting[1] = 0;\n\tinit_swait_queue_head(&ssp->srcu_wq);\n\tssp->srcu_cb_head = NULL;\n\tssp->srcu_cb_tail = &ssp->srcu_cb_head;\n\tssp->srcu_gp_running = false;\n\tssp->srcu_gp_waiting = false;\n\tssp->srcu_idx = 0;\n\tssp->srcu_idx_max = 0;\n\tINIT_WORK(&ssp->srcu_work, srcu_drive_gp);\n\tINIT_LIST_HEAD(&ssp->srcu_work.entry);\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nint __init_srcu_struct(struct srcu_struct *ssp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t \n\tdebug_check_no_locks_freed((void *)ssp, sizeof(*ssp));\n\tlockdep_init_map(&ssp->dep_map, name, key, 0);\n\treturn init_srcu_struct_fields(ssp);\n}\nEXPORT_SYMBOL_GPL(__init_srcu_struct);\n\n#else  \n\n \nint init_srcu_struct(struct srcu_struct *ssp)\n{\n\treturn init_srcu_struct_fields(ssp);\n}\nEXPORT_SYMBOL_GPL(init_srcu_struct);\n\n#endif  \n\n \nvoid cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tWARN_ON(ssp->srcu_lock_nesting[0] || ssp->srcu_lock_nesting[1]);\n\tflush_work(&ssp->srcu_work);\n\tWARN_ON(ssp->srcu_gp_running);\n\tWARN_ON(ssp->srcu_gp_waiting);\n\tWARN_ON(ssp->srcu_cb_head);\n\tWARN_ON(&ssp->srcu_cb_head != ssp->srcu_cb_tail);\n\tWARN_ON(ssp->srcu_idx != ssp->srcu_idx_max);\n\tWARN_ON(ssp->srcu_idx & 0x1);\n}\nEXPORT_SYMBOL_GPL(cleanup_srcu_struct);\n\n \nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tint newval = READ_ONCE(ssp->srcu_lock_nesting[idx]) - 1;\n\n\tWRITE_ONCE(ssp->srcu_lock_nesting[idx], newval);\n\tif (!newval && READ_ONCE(ssp->srcu_gp_waiting) && in_task())\n\t\tswake_up_one(&ssp->srcu_wq);\n}\nEXPORT_SYMBOL_GPL(__srcu_read_unlock);\n\n \nvoid srcu_drive_gp(struct work_struct *wp)\n{\n\tint idx;\n\tstruct rcu_head *lh;\n\tstruct rcu_head *rhp;\n\tstruct srcu_struct *ssp;\n\n\tssp = container_of(wp, struct srcu_struct, srcu_work);\n\tif (ssp->srcu_gp_running || ULONG_CMP_GE(ssp->srcu_idx, READ_ONCE(ssp->srcu_idx_max)))\n\t\treturn;  \n\n\t \n\tWRITE_ONCE(ssp->srcu_gp_running, true);\n\tlocal_irq_disable();\n\tlh = ssp->srcu_cb_head;\n\tssp->srcu_cb_head = NULL;\n\tssp->srcu_cb_tail = &ssp->srcu_cb_head;\n\tlocal_irq_enable();\n\tidx = (ssp->srcu_idx & 0x2) / 2;\n\tWRITE_ONCE(ssp->srcu_idx, ssp->srcu_idx + 1);\n\tWRITE_ONCE(ssp->srcu_gp_waiting, true);   \n\tswait_event_exclusive(ssp->srcu_wq, !READ_ONCE(ssp->srcu_lock_nesting[idx]));\n\tWRITE_ONCE(ssp->srcu_gp_waiting, false);  \n\tWRITE_ONCE(ssp->srcu_idx, ssp->srcu_idx + 1);\n\n\t \n\twhile (lh) {\n\t\trhp = lh;\n\t\tlh = lh->next;\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\n\t \n\tWRITE_ONCE(ssp->srcu_gp_running, false);\n\tif (ULONG_CMP_LT(ssp->srcu_idx, READ_ONCE(ssp->srcu_idx_max)))\n\t\tschedule_work(&ssp->srcu_work);\n}\nEXPORT_SYMBOL_GPL(srcu_drive_gp);\n\nstatic void srcu_gp_start_if_needed(struct srcu_struct *ssp)\n{\n\tunsigned long cookie;\n\n\tcookie = get_state_synchronize_srcu(ssp);\n\tif (ULONG_CMP_GE(READ_ONCE(ssp->srcu_idx_max), cookie))\n\t\treturn;\n\tWRITE_ONCE(ssp->srcu_idx_max, cookie);\n\tif (!READ_ONCE(ssp->srcu_gp_running)) {\n\t\tif (likely(srcu_init_done))\n\t\t\tschedule_work(&ssp->srcu_work);\n\t\telse if (list_empty(&ssp->srcu_work.entry))\n\t\t\tlist_add(&ssp->srcu_work.entry, &srcu_boot_list);\n\t}\n}\n\n \nvoid call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\tunsigned long flags;\n\n\trhp->func = func;\n\trhp->next = NULL;\n\tlocal_irq_save(flags);\n\t*ssp->srcu_cb_tail = rhp;\n\tssp->srcu_cb_tail = &rhp->next;\n\tlocal_irq_restore(flags);\n\tsrcu_gp_start_if_needed(ssp);\n}\nEXPORT_SYMBOL_GPL(call_srcu);\n\n \nvoid synchronize_srcu(struct srcu_struct *ssp)\n{\n\tstruct rcu_synchronize rs;\n\n\tsrcu_lock_sync(&ssp->dep_map);\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\tlock_is_held(&rcu_bh_lock_map) ||\n\t\t\tlock_is_held(&rcu_lock_map) ||\n\t\t\tlock_is_held(&rcu_sched_lock_map),\n\t\t\t\"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\n\tmight_sleep();\n\tinit_rcu_head_on_stack(&rs.head);\n\tinit_completion(&rs.completion);\n\tcall_srcu(ssp, &rs.head, wakeme_after_rcu);\n\twait_for_completion(&rs.completion);\n\tdestroy_rcu_head_on_stack(&rs.head);\n}\nEXPORT_SYMBOL_GPL(synchronize_srcu);\n\n \nunsigned long get_state_synchronize_srcu(struct srcu_struct *ssp)\n{\n\tunsigned long ret;\n\n\tbarrier();\n\tret = (READ_ONCE(ssp->srcu_idx) + 3) & ~0x1;\n\tbarrier();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(get_state_synchronize_srcu);\n\n \nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\tunsigned long ret = get_state_synchronize_srcu(ssp);\n\n\tsrcu_gp_start_if_needed(ssp);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(start_poll_synchronize_srcu);\n\n \nbool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tunsigned long cur_s = READ_ONCE(ssp->srcu_idx);\n\n\tbarrier();\n\treturn ULONG_CMP_GE(cur_s, cookie) || ULONG_CMP_LT(cur_s, cookie - 3);\n}\nEXPORT_SYMBOL_GPL(poll_state_synchronize_srcu);\n\n \nvoid __init rcu_scheduler_starting(void)\n{\n\trcu_scheduler_active = RCU_SCHEDULER_RUNNING;\n}\n\n \nvoid __init srcu_init(void)\n{\n\tstruct srcu_struct *ssp;\n\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tssp = list_first_entry(&srcu_boot_list,\n\t\t\t\t      struct srcu_struct, srcu_work.entry);\n\t\tlist_del_init(&ssp->srcu_work.entry);\n\t\tschedule_work(&ssp->srcu_work);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}