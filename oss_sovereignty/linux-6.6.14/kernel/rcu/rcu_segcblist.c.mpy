{
  "module_name": "rcu_segcblist.c",
  "hash_id": "c7bdc5a45b479def570a9355ca8fa9334b9f778e5ad584e761369b58ea48923b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/rcu/rcu_segcblist.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#include \"rcu_segcblist.h\"\n\n \nvoid rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n}\n\n \nvoid rcu_cblist_enqueue(struct rcu_cblist *rclp, struct rcu_head *rhp)\n{\n\t*rclp->tail = rhp;\n\trclp->tail = &rhp->next;\n\tWRITE_ONCE(rclp->len, rclp->len + 1);\n}\n\n \nvoid rcu_cblist_flush_enqueue(struct rcu_cblist *drclp,\n\t\t\t      struct rcu_cblist *srclp,\n\t\t\t      struct rcu_head *rhp)\n{\n\tdrclp->head = srclp->head;\n\tif (drclp->head)\n\t\tdrclp->tail = srclp->tail;\n\telse\n\t\tdrclp->tail = &drclp->head;\n\tdrclp->len = srclp->len;\n\tif (!rhp) {\n\t\trcu_cblist_init(srclp);\n\t} else {\n\t\trhp->next = NULL;\n\t\tsrclp->head = rhp;\n\t\tsrclp->tail = &rhp->next;\n\t\tWRITE_ONCE(srclp->len, 1);\n\t}\n}\n\n \nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp)\n{\n\tstruct rcu_head *rhp;\n\n\trhp = rclp->head;\n\tif (!rhp)\n\t\treturn NULL;\n\trclp->len--;\n\trclp->head = rhp->next;\n\tif (!rclp->head)\n\t\trclp->tail = &rclp->head;\n\treturn rhp;\n}\n\n \nstatic void rcu_segcblist_set_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tatomic_long_set(&rsclp->len, v);\n#else\n\tWRITE_ONCE(rsclp->len, v);\n#endif\n}\n\n \nlong rcu_segcblist_get_seglen(struct rcu_segcblist *rsclp, int seg)\n{\n\treturn READ_ONCE(rsclp->seglen[seg]);\n}\n\n \nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp)\n{\n\tlong len = 0;\n\tint i;\n\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tlen += rcu_segcblist_get_seglen(rsclp, i);\n\n\treturn len;\n}\n\n \nstatic void rcu_segcblist_set_seglen(struct rcu_segcblist *rsclp, int seg, long v)\n{\n\tWRITE_ONCE(rsclp->seglen[seg], v);\n}\n\n \nstatic void rcu_segcblist_add_seglen(struct rcu_segcblist *rsclp, int seg, long v)\n{\n\tWRITE_ONCE(rsclp->seglen[seg], rsclp->seglen[seg] + v);\n}\n\n \nstatic void rcu_segcblist_move_seglen(struct rcu_segcblist *rsclp, int from, int to)\n{\n\tlong len;\n\n\tif (from == to)\n\t\treturn;\n\n\tlen = rcu_segcblist_get_seglen(rsclp, from);\n\tif (!len)\n\t\treturn;\n\n\trcu_segcblist_add_seglen(rsclp, to, len);\n\trcu_segcblist_set_seglen(rsclp, from, 0);\n}\n\n \nstatic void rcu_segcblist_inc_seglen(struct rcu_segcblist *rsclp, int seg)\n{\n\trcu_segcblist_add_seglen(rsclp, seg, 1);\n}\n\n \nvoid rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic();  \n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();   \n#else\n\tsmp_mb();  \n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb();  \n#endif\n}\n\n \nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp)\n{\n\trcu_segcblist_add_len(rsclp, 1);\n}\n\n \nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}\n\n \nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp)\n{\n\tWARN_ON_ONCE(!rcu_segcblist_empty(rsclp));\n\tWARN_ON_ONCE(rcu_segcblist_n_cbs(rsclp));\n\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_ENABLED);\n}\n\n \nvoid rcu_segcblist_offload(struct rcu_segcblist *rsclp, bool offload)\n{\n\tif (offload)\n\t\trcu_segcblist_set_flags(rsclp, SEGCBLIST_LOCKING | SEGCBLIST_OFFLOADED);\n\telse\n\t\trcu_segcblist_clear_flags(rsclp, SEGCBLIST_OFFLOADED);\n}\n\n \nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}\n\n \nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}\n\n \nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn rsclp->head;\n\treturn NULL;\n}\n\n \nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp)\n{\n\tif (rcu_segcblist_is_enabled(rsclp))\n\t\treturn *rsclp->tails[RCU_DONE_TAIL];\n\treturn NULL;\n}\n\n \nbool rcu_segcblist_nextgp(struct rcu_segcblist *rsclp, unsigned long *lp)\n{\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn false;\n\t*lp = rsclp->gp_seq[RCU_WAIT_TAIL];\n\treturn true;\n}\n\n \nvoid rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\trcu_segcblist_inc_len(rsclp);\n\trcu_segcblist_inc_seglen(rsclp, RCU_NEXT_TAIL);\n\trhp->next = NULL;\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rhp);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], &rhp->next);\n}\n\n \nbool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\trcu_segcblist_inc_len(rsclp);\n\tsmp_mb();  \n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\trcu_segcblist_inc_seglen(rsclp, i);\n\tWRITE_ONCE(*rsclp->tails[i], rhp);\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\tWRITE_ONCE(rsclp->tails[i], &rhp->next);\n\treturn true;\n}\n\n \nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn;  \n\trclp->len = rcu_segcblist_get_seglen(rsclp, RCU_DONE_TAIL);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, *rsclp->tails[RCU_DONE_TAIL]);\n\tWRITE_ONCE(*rsclp->tails[RCU_DONE_TAIL], NULL);\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\tWRITE_ONCE(rsclp->tails[i], &rsclp->head);\n\trcu_segcblist_set_seglen(rsclp, RCU_DONE_TAIL, 0);\n}\n\n \nvoid rcu_segcblist_extract_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_pend_cbs(rsclp))\n\t\treturn;  \n\trclp->len = 0;\n\t*rclp->tail = *rsclp->tails[RCU_DONE_TAIL];\n\trclp->tail = rsclp->tails[RCU_NEXT_TAIL];\n\tWRITE_ONCE(*rsclp->tails[RCU_DONE_TAIL], NULL);\n\tfor (i = RCU_DONE_TAIL + 1; i < RCU_CBLIST_NSEGS; i++) {\n\t\trclp->len += rcu_segcblist_get_seglen(rsclp, i);\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_DONE_TAIL]);\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n}\n\n \nvoid rcu_segcblist_insert_count(struct rcu_segcblist *rsclp,\n\t\t\t\tstruct rcu_cblist *rclp)\n{\n\trcu_segcblist_add_len(rsclp, rclp->len);\n}\n\n \nvoid rcu_segcblist_insert_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rclp->head)\n\t\treturn;  \n\trcu_segcblist_add_seglen(rsclp, RCU_DONE_TAIL, rclp->len);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, rclp->head);\n\tfor (i = RCU_DONE_TAIL; i < RCU_CBLIST_NSEGS; i++)\n\t\tif (&rsclp->head == rsclp->tails[i])\n\t\t\tWRITE_ONCE(rsclp->tails[i], rclp->tail);\n\t\telse\n\t\t\tbreak;\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n}\n\n \nvoid rcu_segcblist_insert_pend_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t   struct rcu_cblist *rclp)\n{\n\tif (!rclp->head)\n\t\treturn;  \n\n\trcu_segcblist_add_seglen(rsclp, RCU_NEXT_TAIL, rclp->len);\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rclp->head);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], rclp->tail);\n}\n\n \nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t \n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t \n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t \n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t \n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;   \n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}\n\n \nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t \n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t \n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t \n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t \n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}\n\n \nvoid rcu_segcblist_merge(struct rcu_segcblist *dst_rsclp,\n\t\t\t struct rcu_segcblist *src_rsclp)\n{\n\tstruct rcu_cblist donecbs;\n\tstruct rcu_cblist pendcbs;\n\n\tlockdep_assert_cpus_held();\n\n\trcu_cblist_init(&donecbs);\n\trcu_cblist_init(&pendcbs);\n\n\trcu_segcblist_extract_done_cbs(src_rsclp, &donecbs);\n\trcu_segcblist_extract_pend_cbs(src_rsclp, &pendcbs);\n\n\t \n\trcu_segcblist_set_len(src_rsclp, 0);\n\n\trcu_segcblist_insert_count(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_count(dst_rsclp, &pendcbs);\n\trcu_segcblist_insert_done_cbs(dst_rsclp, &donecbs);\n\trcu_segcblist_insert_pend_cbs(dst_rsclp, &pendcbs);\n\n\trcu_segcblist_init(src_rsclp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}