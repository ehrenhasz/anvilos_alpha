{
  "module_name": "Kconfig",
  "hash_id": "68d7c746148419d09d1d54567f67b8e25e818cf499f4f1195d2c925f2e3bfb3c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/rcu/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# RCU-related configuration options\n#\n\nmenu \"RCU Subsystem\"\n\nconfig TREE_RCU\n\tbool\n\tdefault y if SMP\n\t# Dynticks-idle tracking\n\tselect CONTEXT_TRACKING_IDLE\n\thelp\n\t  This option selects the RCU implementation that is\n\t  designed for very large SMP system with hundreds or\n\t  thousands of CPUs.  It also scales down nicely to\n\t  smaller systems.\n\nconfig PREEMPT_RCU\n\tbool\n\tdefault y if PREEMPTION\n\tselect TREE_RCU\n\thelp\n\t  This option selects the RCU implementation that is\n\t  designed for very large SMP systems with hundreds or\n\t  thousands of CPUs, but for which real-time response\n\t  is also required.  It also scales down nicely to\n\t  smaller systems.\n\n\t  Select this option if you are unsure.\n\nconfig TINY_RCU\n\tbool\n\tdefault y if !PREEMPTION && !SMP\n\thelp\n\t  This option selects the RCU implementation that is\n\t  designed for UP systems from which real-time response\n\t  is not required.  This option greatly reduces the\n\t  memory footprint of RCU.\n\nconfig RCU_EXPERT\n\tbool \"Make expert-level adjustments to RCU configuration\"\n\tdefault n\n\thelp\n\t  This option needs to be enabled if you wish to make\n\t  expert-level adjustments to RCU configuration.  By default,\n\t  no such adjustments can be made, which has the often-beneficial\n\t  side-effect of preventing \"make oldconfig\" from asking you all\n\t  sorts of detailed questions about how you would like numerous\n\t  obscure RCU options to be set up.\n\n\t  Say Y if you need to make expert-level adjustments to RCU.\n\n\t  Say N if you are unsure.\n\nconfig TINY_SRCU\n\tbool\n\tdefault y if TINY_RCU\n\thelp\n\t  This option selects the single-CPU non-preemptible version of SRCU.\n\nconfig TREE_SRCU\n\tbool\n\tdefault y if !TINY_RCU\n\thelp\n\t  This option selects the full-fledged version of SRCU.\n\nconfig NEED_SRCU_NMI_SAFE\n\tdef_bool HAVE_NMI && !ARCH_HAS_NMI_SAFE_THIS_CPU_OPS && !TINY_SRCU\n\nconfig TASKS_RCU_GENERIC\n\tdef_bool TASKS_RCU || TASKS_RUDE_RCU || TASKS_TRACE_RCU\n\thelp\n\t  This option enables generic infrastructure code supporting\n\t  task-based RCU implementations.  Not for manual selection.\n\nconfig FORCE_TASKS_RCU\n\tbool \"Force selection of TASKS_RCU\"\n\tdepends on RCU_EXPERT\n\tselect TASKS_RCU\n\tdefault n\n\thelp\n\t  This option force-enables a task-based RCU implementation\n\t  that uses only voluntary context switch (not preemption!),\n\t  idle, and user-mode execution as quiescent states.  Not for\n\t  manual selection in most cases.\n\nconfig TASKS_RCU\n\tbool\n\tdefault n\n\tselect IRQ_WORK\n\nconfig FORCE_TASKS_RUDE_RCU\n\tbool \"Force selection of Tasks Rude RCU\"\n\tdepends on RCU_EXPERT\n\tselect TASKS_RUDE_RCU\n\tdefault n\n\thelp\n\t  This option force-enables a task-based RCU implementation\n\t  that uses only context switch (including preemption) and\n\t  user-mode execution as quiescent states.  It forces IPIs and\n\t  context switches on all online CPUs, including idle ones,\n\t  so use with caution.\tNot for manual selection in most cases.\n\nconfig TASKS_RUDE_RCU\n\tbool\n\tdefault n\n\tselect IRQ_WORK\n\nconfig FORCE_TASKS_TRACE_RCU\n\tbool \"Force selection of Tasks Trace RCU\"\n\tdepends on RCU_EXPERT\n\tselect TASKS_TRACE_RCU\n\tdefault n\n\thelp\n\t  This option enables a task-based RCU implementation that uses\n\t  explicit rcu_read_lock_trace() read-side markers, and allows\n\t  these readers to appear in the idle loop as well as on the\n\t  CPU hotplug code paths.  It can force IPIs on online CPUs,\n\t  including idle ones, so use with caution.  Not for manual\n\t  selection in most cases.\n\nconfig TASKS_TRACE_RCU\n\tbool\n\tdefault n\n\tselect IRQ_WORK\n\nconfig RCU_STALL_COMMON\n\tdef_bool TREE_RCU\n\thelp\n\t  This option enables RCU CPU stall code that is common between\n\t  the TINY and TREE variants of RCU.  The purpose is to allow\n\t  the tiny variants to disable RCU CPU stall warnings, while\n\t  making these warnings mandatory for the tree variants.\n\nconfig RCU_NEED_SEGCBLIST\n\tdef_bool ( TREE_RCU || TREE_SRCU || TASKS_RCU_GENERIC )\n\nconfig RCU_FANOUT\n\tint \"Tree-based hierarchical RCU fanout value\"\n\trange 2 64 if 64BIT\n\trange 2 32 if !64BIT\n\tdepends on TREE_RCU && RCU_EXPERT\n\tdefault 64 if 64BIT\n\tdefault 32 if !64BIT\n\thelp\n\t  This option controls the fanout of hierarchical implementations\n\t  of RCU, allowing RCU to work efficiently on machines with\n\t  large numbers of CPUs.  This value must be at least the fourth\n\t  root of NR_CPUS, which allows NR_CPUS to be insanely large.\n\t  The default value of RCU_FANOUT should be used for production\n\t  systems, but if you are stress-testing the RCU implementation\n\t  itself, small RCU_FANOUT values allow you to test large-system\n\t  code paths on small(er) systems.\n\n\t  Select a specific number if testing RCU itself.\n\t  Take the default if unsure.\n\nconfig RCU_FANOUT_LEAF\n\tint \"Tree-based hierarchical RCU leaf-level fanout value\"\n\trange 2 64 if 64BIT && !RCU_STRICT_GRACE_PERIOD\n\trange 2 32 if !64BIT && !RCU_STRICT_GRACE_PERIOD\n\trange 2 3 if RCU_STRICT_GRACE_PERIOD\n\tdepends on TREE_RCU && RCU_EXPERT\n\tdefault 16 if !RCU_STRICT_GRACE_PERIOD\n\tdefault 2 if RCU_STRICT_GRACE_PERIOD\n\thelp\n\t  This option controls the leaf-level fanout of hierarchical\n\t  implementations of RCU, and allows trading off cache misses\n\t  against lock contention.  Systems that synchronize their\n\t  scheduling-clock interrupts for energy-efficiency reasons will\n\t  want the default because the smaller leaf-level fanout keeps\n\t  lock contention levels acceptably low.  Very large systems\n\t  (hundreds or thousands of CPUs) will instead want to set this\n\t  value to the maximum value possible in order to reduce the\n\t  number of cache misses incurred during RCU's grace-period\n\t  initialization.  These systems tend to run CPU-bound, and thus\n\t  are not helped by synchronized interrupts, and thus tend to\n\t  skew them, which reduces lock contention enough that large\n\t  leaf-level fanouts work well.  That said, setting leaf-level\n\t  fanout to a large number will likely cause problematic\n\t  lock contention on the leaf-level rcu_node structures unless\n\t  you boot with the skew_tick kernel parameter.\n\n\t  Select a specific number if testing RCU itself.\n\n\t  Select the maximum permissible value for large systems, but\n\t  please understand that you may also need to set the skew_tick\n\t  kernel boot parameter to avoid contention on the rcu_node\n\t  structure's locks.\n\n\t  Take the default if unsure.\n\nconfig RCU_BOOST\n\tbool \"Enable RCU priority boosting\"\n\tdepends on (RT_MUTEXES && PREEMPT_RCU && RCU_EXPERT) || PREEMPT_RT\n\tdefault y if PREEMPT_RT\n\thelp\n\t  This option boosts the priority of preempted RCU readers that\n\t  block the current preemptible RCU grace period for too long.\n\t  This option also prevents heavy loads from blocking RCU\n\t  callback invocation.\n\n\t  Say Y here if you are working with real-time apps or heavy loads\n\t  Say N here if you are unsure.\n\nconfig RCU_BOOST_DELAY\n\tint \"Milliseconds to delay boosting after RCU grace-period start\"\n\trange 0 3000\n\tdepends on RCU_BOOST\n\tdefault 500\n\thelp\n\t  This option specifies the time to wait after the beginning of\n\t  a given grace period before priority-boosting preempted RCU\n\t  readers blocking that grace period.  Note that any RCU reader\n\t  blocking an expedited RCU grace period is boosted immediately.\n\n\t  Accept the default if unsure.\n\nconfig RCU_EXP_KTHREAD\n\tbool \"Perform RCU expedited work in a real-time kthread\"\n\tdepends on RCU_BOOST && RCU_EXPERT\n\tdefault !PREEMPT_RT && NR_CPUS <= 32\n\thelp\n\t  Use this option to further reduce the latencies of expedited\n\t  grace periods at the expense of being more disruptive.\n\n\t  This option is disabled by default on PREEMPT_RT=y kernels which\n\t  disable expedited grace periods after boot by unconditionally\n\t  setting rcupdate.rcu_normal_after_boot=1.\n\n\t  Accept the default if unsure.\n\nconfig RCU_NOCB_CPU\n\tbool \"Offload RCU callback processing from boot-selected CPUs\"\n\tdepends on TREE_RCU\n\tdepends on RCU_EXPERT || NO_HZ_FULL\n\tdefault n\n\thelp\n\t  Use this option to reduce OS jitter for aggressive HPC or\n\t  real-time workloads.\tIt can also be used to offload RCU\n\t  callback invocation to energy-efficient CPUs in battery-powered\n\t  asymmetric multiprocessors.  The price of this reduced jitter\n\t  is that the overhead of call_rcu() increases and that some\n\t  workloads will incur significant increases in context-switch\n\t  rates.\n\n\t  This option offloads callback invocation from the set of CPUs\n\t  specified at boot time by the rcu_nocbs parameter.  For each\n\t  such CPU, a kthread (\"rcuox/N\") will be created to invoke\n\t  callbacks, where the \"N\" is the CPU being offloaded, and where\n\t  the \"x\" is \"p\" for RCU-preempt (PREEMPTION kernels) and \"s\" for\n\t  RCU-sched (!PREEMPTION kernels).  Nothing prevents this kthread\n\t  from running on the specified CPUs, but (1) the kthreads may be\n\t  preempted between each callback, and (2) affinity or cgroups can\n\t  be used to force the kthreads to run on whatever set of CPUs is\n\t  desired.\n\n\t  Say Y here if you need reduced OS jitter, despite added overhead.\n\t  Say N here if you are unsure.\n\nconfig RCU_NOCB_CPU_DEFAULT_ALL\n\tbool \"Offload RCU callback processing from all CPUs by default\"\n\tdepends on RCU_NOCB_CPU\n\tdefault n\n\thelp\n\t  Use this option to offload callback processing from all CPUs\n\t  by default, in the absence of the rcu_nocbs or nohz_full boot\n\t  parameter. This also avoids the need to use any boot parameters\n\t  to achieve the effect of offloading all CPUs on boot.\n\n\t  Say Y here if you want offload all CPUs by default on boot.\n\t  Say N here if you are unsure.\n\nconfig RCU_NOCB_CPU_CB_BOOST\n\tbool \"Offload RCU callback from real-time kthread\"\n\tdepends on RCU_NOCB_CPU && RCU_BOOST\n\tdefault y if PREEMPT_RT\n\thelp\n\t  Use this option to invoke offloaded callbacks as SCHED_FIFO\n\t  to avoid starvation by heavy SCHED_OTHER background load.\n\t  Of course, running as SCHED_FIFO during callback floods will\n\t  cause the rcuo[ps] kthreads to monopolize the CPU for hundreds\n\t  of milliseconds or more.  Therefore, when enabling this option,\n\t  it is your responsibility to ensure that latency-sensitive\n\t  tasks either run with higher priority or run on some other CPU.\n\n\t  Say Y here if you want to set RT priority for offloading kthreads.\n\t  Say N here if you are building a !PREEMPT_RT kernel and are unsure.\n\nconfig TASKS_TRACE_RCU_READ_MB\n\tbool \"Tasks Trace RCU readers use memory barriers in user and idle\"\n\tdepends on RCU_EXPERT && TASKS_TRACE_RCU\n\tdefault PREEMPT_RT || NR_CPUS < 8\n\thelp\n\t  Use this option to further reduce the number of IPIs sent\n\t  to CPUs executing in userspace or idle during tasks trace\n\t  RCU grace periods.  Given that a reasonable setting of\n\t  the rcupdate.rcu_task_ipi_delay kernel boot parameter\n\t  eliminates such IPIs for many workloads, proper setting\n\t  of this Kconfig option is important mostly for aggressive\n\t  real-time installations and for battery-powered devices,\n\t  hence the default chosen above.\n\n\t  Say Y here if you hate IPIs.\n\t  Say N here if you hate read-side memory barriers.\n\t  Take the default if you are unsure.\n\nconfig RCU_LAZY\n\tbool \"RCU callback lazy invocation functionality\"\n\tdepends on RCU_NOCB_CPU\n\tdefault n\n\thelp\n\t  To save power, batch RCU callbacks and flush after delay, memory\n\t  pressure, or callback list growing too big.\n\nconfig RCU_DOUBLE_CHECK_CB_TIME\n\tbool \"RCU callback-batch backup time check\"\n\tdepends on RCU_EXPERT\n\tdefault n\n\thelp\n\t  Use this option to provide more precise enforcement of the\n\t  rcutree.rcu_resched_ns module parameter in situations where\n\t  a single RCU callback might run for hundreds of microseconds,\n\t  thus defeating the 32-callback batching used to amortize the\n\t  cost of the fine-grained but expensive local_clock() function.\n\n\t  This option rounds rcutree.rcu_resched_ns up to the next\n\t  jiffy, and overrides the 32-callback batching if this limit\n\t  is exceeded.\n\n\t  Say Y here if you need tighter callback-limit enforcement.\n\t  Say N here if you are unsure.\n\nendmenu # \"RCU Subsystem\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}