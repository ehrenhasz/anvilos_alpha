{
  "module_name": "sync.c",
  "hash_id": "cdd76394fde75bf4e7714221bed8e22adc76b37ab01c3965ce2b8f89b65d6407",
  "original_prompt": "Ingested from linux-6.6.14/kernel/rcu/sync.c",
  "human_readable_source": "\n \n\n#include <linux/rcu_sync.h>\n#include <linux/sched.h>\n\nenum { GP_IDLE = 0, GP_ENTER, GP_PASSED, GP_EXIT, GP_REPLAY };\n\n#define\trss_lock\tgp_wait.lock\n\n \nvoid rcu_sync_init(struct rcu_sync *rsp)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n}\n\n \nvoid rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}\n\n\nstatic void rcu_sync_func(struct rcu_head *rhp);\n\nstatic void rcu_sync_call(struct rcu_sync *rsp)\n{\n\tcall_rcu_hurry(&rsp->cb_head, rcu_sync_func);\n}\n\n \nstatic void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t \n\t\tWRITE_ONCE(rsp->gp_state, GP_PASSED);\n\t\twake_up_locked(&rsp->gp_wait);\n\t} else if (rsp->gp_state == GP_REPLAY) {\n\t\t \n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\trcu_sync_call(rsp);\n\t} else {\n\t\t \n\t\tWRITE_ONCE(rsp->gp_state, GP_IDLE);\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}\n\n \nvoid rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tgp_state = rsp->gp_state;\n\tif (gp_state == GP_IDLE) {\n\t\tWRITE_ONCE(rsp->gp_state, GP_ENTER);\n\t\tWARN_ON_ONCE(rsp->gp_count);\n\t\t \n\t}\n\trsp->gp_count++;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state == GP_IDLE) {\n\t\t \n\t\tsynchronize_rcu();\n\t\trcu_sync_func(&rsp->cb_head);\n\t\t \n\t\treturn;\n\t}\n\n\twait_event(rsp->gp_wait, READ_ONCE(rsp->gp_state) >= GP_PASSED);\n}\n\n \nvoid rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_IDLE);\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count) == 0);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->gp_state == GP_PASSED) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\t\t\trcu_sync_call(rsp);\n\t\t} else if (rsp->gp_state == GP_EXIT) {\n\t\t\tWRITE_ONCE(rsp->gp_state, GP_REPLAY);\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}\n\n \nvoid rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint gp_state;\n\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_count));\n\tWARN_ON_ONCE(READ_ONCE(rsp->gp_state) == GP_PASSED);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->gp_state == GP_REPLAY)\n\t\tWRITE_ONCE(rsp->gp_state, GP_EXIT);\n\tgp_state = rsp->gp_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (gp_state != GP_IDLE) {\n\t\trcu_barrier();\n\t\tWARN_ON_ONCE(rsp->gp_state != GP_IDLE);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}