{
  "module_name": "Kconfig.debug",
  "hash_id": "49a1fc997f781d001ea8e2b7c36b669ab165392fa238f03e7a287e7b2e89d58e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/rcu/Kconfig.debug",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# RCU-related debugging configuration options\n#\n\nmenu \"RCU Debugging\"\n\nconfig PROVE_RCU\n\tdef_bool PROVE_LOCKING\n\nconfig PROVE_RCU_LIST\n\tbool \"RCU list lockdep debugging\"\n\tdepends on PROVE_RCU && RCU_EXPERT\n\tdefault n\n\thelp\n\t  Enable RCU lockdep checking for list usages. By default it is\n\t  turned off since there are several list RCU users that still\n\t  need to be converted to pass a lockdep expression. To prevent\n\t  false-positive splats, we keep it default disabled but once all\n\t  users are converted, we can remove this config option.\n\nconfig TORTURE_TEST\n\ttristate\n\tdefault n\n\nconfig RCU_SCALE_TEST\n\ttristate \"performance tests for RCU\"\n\tdepends on DEBUG_KERNEL\n\tselect TORTURE_TEST\n\tdefault n\n\thelp\n\t  This option provides a kernel module that runs performance\n\t  tests on the RCU infrastructure.  The kernel module may be built\n\t  after the fact on the running kernel to be tested, if desired.\n\n\t  Say Y here if you want RCU performance tests to be built into\n\t  the kernel.\n\t  Say M if you want the RCU performance tests to build as a module.\n\t  Say N if you are unsure.\n\nconfig RCU_TORTURE_TEST\n\ttristate \"torture tests for RCU\"\n\tdepends on DEBUG_KERNEL\n\tselect TORTURE_TEST\n\tdefault n\n\thelp\n\t  This option provides a kernel module that runs torture tests\n\t  on the RCU infrastructure.  The kernel module may be built\n\t  after the fact on the running kernel to be tested, if desired.\n\n\t  Say Y here if you want RCU torture tests to be built into\n\t  the kernel.\n\t  Say M if you want the RCU torture tests to build as a module.\n\t  Say N if you are unsure.\n\nconfig RCU_REF_SCALE_TEST\n\ttristate \"Scalability tests for read-side synchronization (RCU and others)\"\n\tdepends on DEBUG_KERNEL\n\tselect TORTURE_TEST\n\tdefault n\n\thelp\n\t  This option provides a kernel module that runs performance tests\n\t  useful comparing RCU with various read-side synchronization mechanisms.\n\t  The kernel module may be built after the fact on the running kernel to be\n\t  tested, if desired.\n\n\t  Say Y here if you want these performance tests built into the kernel.\n\t  Say M if you want to build it as a module instead.\n\t  Say N if you are unsure.\n\nconfig RCU_CPU_STALL_TIMEOUT\n\tint \"RCU CPU stall timeout in seconds\"\n\tdepends on RCU_STALL_COMMON\n\trange 3 300\n\tdefault 21\n\thelp\n\t  If a given RCU grace period extends more than the specified\n\t  number of seconds, a CPU stall warning is printed.  If the\n\t  RCU grace period persists, additional CPU stall warnings are\n\t  printed at more widely spaced intervals.\n\nconfig RCU_EXP_CPU_STALL_TIMEOUT\n\tint \"Expedited RCU CPU stall timeout in milliseconds\"\n\tdepends on RCU_STALL_COMMON\n\trange 0 300000\n\tdefault 0\n\thelp\n\t  If a given expedited RCU grace period extends more than the\n\t  specified number of milliseconds, a CPU stall warning is printed.\n\t  If the RCU grace period persists, additional CPU stall warnings\n\t  are printed at more widely spaced intervals.  A value of zero\n\t  says to use the RCU_CPU_STALL_TIMEOUT value converted from\n\t  seconds to milliseconds.\n\nconfig RCU_CPU_STALL_CPUTIME\n\tbool \"Provide additional RCU stall debug information\"\n\tdepends on RCU_STALL_COMMON\n\tdefault n\n\thelp\n\t  Collect statistics during the sampling period, such as the number of\n\t  (hard interrupts, soft interrupts, task switches) and the cputime of\n\t  (hard interrupts, soft interrupts, kernel tasks) are added to the\n\t  RCU stall report. For multiple continuous RCU stalls, all sampling\n\t  periods begin at half of the first RCU stall timeout.\n\t  The boot option rcupdate.rcu_cpu_stall_cputime has the same function\n\t  as this one, but will override this if it exists.\n\nconfig RCU_TRACE\n\tbool \"Enable tracing for RCU\"\n\tdepends on DEBUG_KERNEL\n\tdefault y if TREE_RCU\n\tselect TRACE_CLOCK\n\thelp\n\t  This option enables additional tracepoints for ftrace-style\n\t  event tracing.\n\n\t  Say Y here if you want to enable RCU tracing\n\t  Say N if you are unsure.\n\nconfig RCU_EQS_DEBUG\n\tbool \"Provide debugging asserts for adding NO_HZ support to an arch\"\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  This option provides consistency checks in RCU's handling of\n\t  NO_HZ.  These checks have proven quite helpful in detecting\n\t  bugs in arch-specific NO_HZ code.\n\n\t  Say N here if you need ultimate kernel/user switch latencies\n\t  Say Y if you are unsure\n\nconfig RCU_STRICT_GRACE_PERIOD\n\tbool \"Provide debug RCU implementation with short grace periods\"\n\tdepends on DEBUG_KERNEL && RCU_EXPERT && NR_CPUS <= 4 && !TINY_RCU\n\tdefault n\n\tselect PREEMPT_COUNT if PREEMPT=n\n\thelp\n\t  Select this option to build an RCU variant that is strict about\n\t  grace periods, making them as short as it can.  This limits\n\t  scalability, destroys real-time response, degrades battery\n\t  lifetime and kills performance.  Don't try this on large\n\t  machines, as in systems with more than about 10 or 20 CPUs.\n\t  But in conjunction with tools like KASAN, it can be helpful\n\t  when looking for certain types of RCU usage bugs, for example,\n\t  too-short RCU read-side critical sections.\n\nendmenu # \"RCU Debugging\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}