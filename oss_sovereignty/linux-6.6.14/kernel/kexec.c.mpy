{
  "module_name": "kexec.c",
  "hash_id": "2949a722be4a719f1371bf44ec5bfc1a4fd0131b86b3d9c30f06c163da526d0c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kexec.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/kexec.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/syscalls.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n\n#include \"kexec_internal.h\"\n\nstatic int kimage_alloc_init(struct kimage **rimage, unsigned long entry,\n\t\t\t     unsigned long nr_segments,\n\t\t\t     struct kexec_segment *segments,\n\t\t\t     unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_ON_CRASH;\n\n\tif (kexec_on_panic) {\n\t\t \n\t\tif ((entry < phys_to_boot_phys(crashk_res.start)) ||\n\t\t    (entry > phys_to_boot_phys(crashk_res.end)))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t \n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->start = entry;\n\timage->nr_segments = nr_segments;\n\tmemcpy(image->segment, segments, nr_segments * sizeof(*segments));\n\n\tif (kexec_on_panic) {\n\t\t \n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\t \n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_image;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}\n\nstatic int do_kexec_load(unsigned long entry, unsigned long nr_segments,\n\t\tstruct kexec_segment *segments, unsigned long flags)\n{\n\tstruct kimage **dest_image, *image;\n\tunsigned long i;\n\tint ret;\n\n\t \n\tif (!kexec_trylock())\n\t\treturn -EBUSY;\n\n\tif (flags & KEXEC_ON_CRASH) {\n\t\tdest_image = &kexec_crash_image;\n\t\tif (kexec_crash_image)\n\t\t\tarch_kexec_unprotect_crashkres();\n\t} else {\n\t\tdest_image = &kexec_image;\n\t}\n\n\tif (nr_segments == 0) {\n\t\t \n\t\tkimage_free(xchg(dest_image, NULL));\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\tif (flags & KEXEC_ON_CRASH) {\n\t\t \n\t\tkimage_free(xchg(&kexec_crash_image, NULL));\n\t}\n\n\tret = kimage_alloc_init(&image, entry, nr_segments, segments, flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (flags & KEXEC_PRESERVE_CONTEXT)\n\t\timage->preserve_context = 1;\n\n#ifdef CONFIG_CRASH_HOTPLUG\n\tif (flags & KEXEC_UPDATE_ELFCOREHDR)\n\t\timage->update_elfcorehdr = 1;\n#endif\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = kimage_crash_copy_vmcoreinfo(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tret = kimage_load_segment(image, &image->segment[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tkimage_terminate(image);\n\n\tret = machine_kexec_post_load(image);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\timage = xchg(dest_image, image);\n\nout:\n\tif ((flags & KEXEC_ON_CRASH) && kexec_crash_image)\n\t\tarch_kexec_protect_crashkres();\n\n\tkimage_free(image);\nout_unlock:\n\tkexec_unlock();\n\treturn ret;\n}\n\n \n\nstatic inline int kexec_load_check(unsigned long nr_segments,\n\t\t\t\t   unsigned long flags)\n{\n\tint image_type = (flags & KEXEC_ON_CRASH) ?\n\t\t\t KEXEC_TYPE_CRASH : KEXEC_TYPE_DEFAULT;\n\tint result;\n\n\t \n\tif (!kexec_load_permitted(image_type))\n\t\treturn -EPERM;\n\n\t \n\tresult = security_kernel_load_data(LOADING_KEXEC_IMAGE, false);\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tresult = security_locked_down(LOCKDOWN_KEXEC);\n\tif (result)\n\t\treturn result;\n\n\t \n\tif ((flags & KEXEC_FLAGS) != (flags & ~KEXEC_ARCH_MASK))\n\t\treturn -EINVAL;\n\n\t \n\tif (nr_segments > KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,\n\t\tstruct kexec_segment __user *, segments, unsigned long, flags)\n{\n\tstruct kexec_segment *ksegments;\n\tunsigned long result;\n\n\tresult = kexec_load_check(nr_segments, flags);\n\tif (result)\n\t\treturn result;\n\n\t \n\tif (((flags & KEXEC_ARCH_MASK) != KEXEC_ARCH) &&\n\t\t((flags & KEXEC_ARCH_MASK) != KEXEC_ARCH_DEFAULT))\n\t\treturn -EINVAL;\n\n\tksegments = memdup_array_user(segments, nr_segments, sizeof(ksegments[0]));\n\tif (IS_ERR(ksegments))\n\t\treturn PTR_ERR(ksegments);\n\n\tresult = do_kexec_load(entry, nr_segments, ksegments, flags);\n\tkfree(ksegments);\n\n\treturn result;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(kexec_load, compat_ulong_t, entry,\n\t\t       compat_ulong_t, nr_segments,\n\t\t       struct compat_kexec_segment __user *, segments,\n\t\t       compat_ulong_t, flags)\n{\n\tstruct compat_kexec_segment in;\n\tstruct kexec_segment *ksegments;\n\tunsigned long i, result;\n\n\tresult = kexec_load_check(nr_segments, flags);\n\tif (result)\n\t\treturn result;\n\n\t \n\tif ((flags & KEXEC_ARCH_MASK) == KEXEC_ARCH_DEFAULT)\n\t\treturn -EINVAL;\n\n\tksegments = kmalloc_array(nr_segments, sizeof(ksegments[0]),\n\t\t\tGFP_KERNEL);\n\tif (!ksegments)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tresult = copy_from_user(&in, &segments[i], sizeof(in));\n\t\tif (result)\n\t\t\tgoto fail;\n\n\t\tksegments[i].buf   = compat_ptr(in.buf);\n\t\tksegments[i].bufsz = in.bufsz;\n\t\tksegments[i].mem   = in.mem;\n\t\tksegments[i].memsz = in.memsz;\n\t}\n\n\tresult = do_kexec_load(entry, nr_segments, ksegments, flags);\n\nfail:\n\tkfree(ksegments);\n\treturn result;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}