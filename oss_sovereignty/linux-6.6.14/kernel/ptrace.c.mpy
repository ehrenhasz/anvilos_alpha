{
  "module_name": "ptrace.c",
  "hash_id": "2f68e20a4243e42dc60fc8075e9360c1127d736fba3cbffe0b37d1b8c5d2c94e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/ptrace.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/signal.h>\n#include <linux/uio.h>\n#include <linux/audit.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/regset.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/sched/signal.h>\n#include <linux/minmax.h>\n#include <linux/syscall_user_dispatch.h>\n\n#include <asm/syscall.h>\t \n\n \nint ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n\t\t     void *buf, int len, unsigned int gup_flags)\n{\n\tstruct mm_struct *mm;\n\tint ret;\n\n\tmm = get_task_mm(tsk);\n\tif (!mm)\n\t\treturn 0;\n\n\tif (!tsk->ptrace ||\n\t    (current != tsk->parent) ||\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptracer_capable(tsk, mm->user_ns))) {\n\t\tmmput(mm);\n\t\treturn 0;\n\t}\n\n\tret = __access_remote_vm(mm, addr, buf, len, gup_flags);\n\tmmput(mm);\n\n\treturn ret;\n}\n\n\nvoid __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n\t\t   const struct cred *ptracer_cred)\n{\n\tBUG_ON(!list_empty(&child->ptrace_entry));\n\tlist_add(&child->ptrace_entry, &new_parent->ptraced);\n\tchild->parent = new_parent;\n\tchild->ptracer_cred = get_cred(ptracer_cred);\n}\n\n \nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\t__ptrace_link(child, new_parent, current_cred());\n}\n\n \nvoid __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_task_syscall_work(child, SYSCALL_TRACE);\n#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)\n\tclear_task_syscall_work(child, SYSCALL_EMU);\n#endif\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t \n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t \n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t \n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t \n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}\n\nstatic bool looks_like_a_spurious_pid(struct task_struct *task)\n{\n\tif (task->exit_code != ((PTRACE_EVENT_EXEC << 8) | SIGTRAP))\n\t\treturn false;\n\n\tif (task_pid_vnr(task) == task->ptrace_message)\n\t\treturn false;\n\t \n\treturn true;\n}\n\n \nstatic bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\n\t \n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !looks_like_a_spurious_pid(task) &&\n\t    !__fatal_signal_pending(task)) {\n\t\ttask->jobctl |= JOBCTL_PTRACE_FROZEN;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn ret;\n}\n\nstatic void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tunsigned long flags;\n\n\t \n\tif (lock_task_sighand(task, &flags)) {\n\t\ttask->jobctl &= ~JOBCTL_PTRACE_FROZEN;\n\t\tif (__fatal_signal_pending(task)) {\n\t\t\ttask->jobctl &= ~JOBCTL_TRACED;\n\t\t\twake_up_state(task, __TASK_TRACED);\n\t\t}\n\t\tunlock_task_sighand(task, &flags);\n\t}\n}\n\n \nstatic int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t \n\tread_lock(&tasklist_lock);\n\tif (child->ptrace && child->parent == current) {\n\t\t \n\t\tif (ignore_state || ptrace_freeze_traced(child))\n\t\t\tret = 0;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state &&\n\t    WARN_ON_ONCE(!wait_task_inactive(child, __TASK_TRACED|TASK_FROZEN)))\n\t\tret = -ESRCH;\n\n\treturn ret;\n}\n\nstatic bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_NOAUDIT)\n\t\treturn ns_capable_noaudit(ns, CAP_SYS_PTRACE);\n\treturn ns_capable(ns, CAP_SYS_PTRACE);\n}\n\n \nstatic int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\n\t \n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t \n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\t \n\tsmp_rmb();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\treturn security_ptrace_access_check(task, mode);\n}\n\nbool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}\n\nstatic int check_ptrace_options(unsigned long data)\n{\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\t \n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tretval = check_ptrace_options(flags);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t \n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t \n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t \n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_STOPPED;\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\t}\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t \n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}\n\n \nstatic int ptrace_traceme(void)\n{\n\tint ret = -EPERM;\n\n\twrite_lock_irq(&tasklist_lock);\n\t \n\tif (!current->ptrace) {\n\t\tret = security_ptrace_traceme(current->parent);\n\t\t \n\t\tif (!ret && !(current->real_parent->flags & PF_EXITING)) {\n\t\t\tcurrent->ptrace = PT_PTRACED;\n\t\t\tptrace_link(current, current->real_parent);\n\t\t}\n\t}\n\twrite_unlock_irq(&tasklist_lock);\n\n\treturn ret;\n}\n\n \nstatic int ignoring_children(struct sighand_struct *sigh)\n{\n\tint ret;\n\tspin_lock(&sigh->siglock);\n\tret = (sigh->action[SIGCHLD-1].sa.sa_handler == SIG_IGN) ||\n\t      (sigh->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT);\n\tspin_unlock(&sigh->siglock);\n\treturn ret;\n}\n\n \nstatic bool __ptrace_detach(struct task_struct *tracer, struct task_struct *p)\n{\n\tbool dead;\n\n\t__ptrace_unlink(p);\n\n\tif (p->exit_state != EXIT_ZOMBIE)\n\t\treturn false;\n\n\tdead = !thread_group_leader(p);\n\n\tif (!dead && thread_group_empty(p)) {\n\t\tif (!same_thread_group(p->real_parent, tracer))\n\t\t\tdead = do_notify_parent(p, p->exit_signal);\n\t\telse if (ignoring_children(tracer->sighand)) {\n\t\t\t__wake_up_parent(p, tracer);\n\t\t\tdead = true;\n\t\t}\n\t}\n\t \n\tif (dead)\n\t\tp->exit_state = EXIT_DEAD;\n\treturn dead;\n}\n\nstatic int ptrace_detach(struct task_struct *child, unsigned int data)\n{\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\t \n\tptrace_disable(child);\n\n\twrite_lock_irq(&tasklist_lock);\n\t \n\tWARN_ON(!child->ptrace || child->exit_state);\n\t \n\tchild->exit_code = data;\n\t__ptrace_detach(current, child);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_ptrace_connector(child, PTRACE_DETACH);\n\n\treturn 0;\n}\n\n \nvoid exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}\n\nint ptrace_readdata(struct task_struct *tsk, unsigned long src, char __user *dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tretval = ptrace_access_vm(tsk, src, buf, this_len, FOLL_FORCE);\n\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_to_user(dst, buf, retval))\n\t\t\treturn -EFAULT;\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}\n\nint ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tif (copy_from_user(buf, src, this_len))\n\t\t\treturn -EFAULT;\n\t\tretval = ptrace_access_vm(tsk, dst, buf, this_len,\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}\n\nstatic int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tint ret;\n\n\tret = check_ptrace_options(data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}\n\nstatic int ptrace_getsiginfo(struct task_struct *child, kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(info, child->last_siginfo);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}\n\nstatic int ptrace_setsiginfo(struct task_struct *child, const kernel_siginfo_t *info)\n{\n\tunsigned long flags;\n\tint error = -ESRCH;\n\n\tif (lock_task_sighand(child, &flags)) {\n\t\terror = -EINVAL;\n\t\tif (likely(child->last_siginfo != NULL)) {\n\t\t\tcopy_siginfo(child->last_siginfo, info);\n\t\t\terror = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t}\n\treturn error;\n}\n\nstatic int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL;  \n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (arg.off > ULONG_MAX)\n\t\treturn 0;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\tunsigned long off = arg.off + i;\n\t\tbool found = false;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tfound = true;\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (!found)  \n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}\n\n#ifdef CONFIG_RSEQ\nstatic long ptrace_get_rseq_configuration(struct task_struct *task,\n\t\t\t\t\t  unsigned long size, void __user *data)\n{\n\tstruct ptrace_rseq_configuration conf = {\n\t\t.rseq_abi_pointer = (u64)(uintptr_t)task->rseq,\n\t\t.rseq_abi_size = task->rseq_len,\n\t\t.signature = task->rseq_sig,\n\t\t.flags = 0,\n\t};\n\n\tsize = min_t(unsigned long, size, sizeof(conf));\n\tif (copy_to_user(data, &conf, size))\n\t\treturn -EFAULT;\n\treturn sizeof(conf);\n}\n#endif\n\n#define is_singlestep(request)\t\t((request) == PTRACE_SINGLESTEP)\n\n#ifdef PTRACE_SINGLEBLOCK\n#define is_singleblock(request)\t\t((request) == PTRACE_SINGLEBLOCK)\n#else\n#define is_singleblock(request)\t\t0\n#endif\n\n#ifdef PTRACE_SYSEMU\n#define is_sysemu_singlestep(request)\t((request) == PTRACE_SYSEMU_SINGLESTEP)\n#else\n#define is_sysemu_singlestep(request)\t0\n#endif\n\nstatic int ptrace_resume(struct task_struct *child, long request,\n\t\t\t unsigned long data)\n{\n\tif (!valid_signal(data))\n\t\treturn -EIO;\n\n\tif (request == PTRACE_SYSCALL)\n\t\tset_task_syscall_work(child, SYSCALL_TRACE);\n\telse\n\t\tclear_task_syscall_work(child, SYSCALL_TRACE);\n\n#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)\n\tif (request == PTRACE_SYSEMU || request == PTRACE_SYSEMU_SINGLESTEP)\n\t\tset_task_syscall_work(child, SYSCALL_EMU);\n\telse\n\t\tclear_task_syscall_work(child, SYSCALL_EMU);\n#endif\n\n\tif (is_singleblock(request)) {\n\t\tif (unlikely(!arch_has_block_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_block_step(child);\n\t} else if (is_singlestep(request) || is_sysemu_singlestep(request)) {\n\t\tif (unlikely(!arch_has_single_step()))\n\t\t\treturn -EIO;\n\t\tuser_enable_single_step(child);\n\t} else {\n\t\tuser_disable_single_step(child);\n\t}\n\n\t \n\tspin_lock_irq(&child->sighand->siglock);\n\tchild->exit_code = data;\n\tchild->jobctl &= ~JOBCTL_TRACED;\n\twake_up_state(child, __TASK_TRACED);\n\tspin_unlock_irq(&child->sighand->siglock);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\nstatic const struct user_regset *\nfind_regset(const struct user_regset_view *view, unsigned int type)\n{\n\tconst struct user_regset *regset;\n\tint n;\n\n\tfor (n = 0; n < view->n; ++n) {\n\t\tregset = view->regsets + n;\n\t\tif (regset->core_note_type == type)\n\t\t\treturn regset;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ptrace_regset(struct task_struct *task, int req, unsigned int type,\n\t\t\t struct iovec *kiov)\n{\n\tconst struct user_regset_view *view = task_user_regset_view(task);\n\tconst struct user_regset *regset = find_regset(view, type);\n\tint regset_no;\n\n\tif (!regset || (kiov->iov_len % regset->size) != 0)\n\t\treturn -EINVAL;\n\n\tregset_no = regset - view->regsets;\n\tkiov->iov_len = min(kiov->iov_len,\n\t\t\t    (__kernel_size_t) (regset->n * regset->size));\n\n\tif (req == PTRACE_GETREGSET)\n\t\treturn copy_regset_to_user(task, view, regset_no, 0,\n\t\t\t\t\t   kiov->iov_len, kiov->iov_base);\n\telse\n\t\treturn copy_regset_from_user(task, view, regset_no, 0,\n\t\t\t\t\t     kiov->iov_len, kiov->iov_base);\n}\n\n \nEXPORT_SYMBOL_GPL(task_user_regset_view);\n\nstatic unsigned long\nptrace_get_syscall_info_entry(struct task_struct *child, struct pt_regs *regs,\n\t\t\t      struct ptrace_syscall_info *info)\n{\n\tunsigned long args[ARRAY_SIZE(info->entry.args)];\n\tint i;\n\n\tinfo->op = PTRACE_SYSCALL_INFO_ENTRY;\n\tinfo->entry.nr = syscall_get_nr(child, regs);\n\tsyscall_get_arguments(child, regs, args);\n\tfor (i = 0; i < ARRAY_SIZE(args); i++)\n\t\tinfo->entry.args[i] = args[i];\n\n\t \n\treturn offsetofend(struct ptrace_syscall_info, entry.args);\n}\n\nstatic unsigned long\nptrace_get_syscall_info_seccomp(struct task_struct *child, struct pt_regs *regs,\n\t\t\t\tstruct ptrace_syscall_info *info)\n{\n\t \n\tptrace_get_syscall_info_entry(child, regs, info);\n\tinfo->op = PTRACE_SYSCALL_INFO_SECCOMP;\n\tinfo->seccomp.ret_data = child->ptrace_message;\n\n\t \n\treturn offsetofend(struct ptrace_syscall_info, seccomp.ret_data);\n}\n\nstatic unsigned long\nptrace_get_syscall_info_exit(struct task_struct *child, struct pt_regs *regs,\n\t\t\t     struct ptrace_syscall_info *info)\n{\n\tinfo->op = PTRACE_SYSCALL_INFO_EXIT;\n\tinfo->exit.rval = syscall_get_error(child, regs);\n\tinfo->exit.is_error = !!info->exit.rval;\n\tif (!info->exit.is_error)\n\t\tinfo->exit.rval = syscall_get_return_value(child, regs);\n\n\t \n\treturn offsetofend(struct ptrace_syscall_info, exit.is_error);\n}\n\nstatic int\nptrace_get_syscall_info(struct task_struct *child, unsigned long user_size,\n\t\t\tvoid __user *datavp)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\tstruct ptrace_syscall_info info = {\n\t\t.op = PTRACE_SYSCALL_INFO_NONE,\n\t\t.arch = syscall_get_arch(child),\n\t\t.instruction_pointer = instruction_pointer(regs),\n\t\t.stack_pointer = user_stack_pointer(regs),\n\t};\n\tunsigned long actual_size = offsetof(struct ptrace_syscall_info, entry);\n\tunsigned long write_size;\n\n\t \n\tswitch (child->last_siginfo ? child->last_siginfo->si_code : 0) {\n\tcase SIGTRAP | 0x80:\n\t\tswitch (child->ptrace_message) {\n\t\tcase PTRACE_EVENTMSG_SYSCALL_ENTRY:\n\t\t\tactual_size = ptrace_get_syscall_info_entry(child, regs,\n\t\t\t\t\t\t\t\t    &info);\n\t\t\tbreak;\n\t\tcase PTRACE_EVENTMSG_SYSCALL_EXIT:\n\t\t\tactual_size = ptrace_get_syscall_info_exit(child, regs,\n\t\t\t\t\t\t\t\t   &info);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIGTRAP | (PTRACE_EVENT_SECCOMP << 8):\n\t\tactual_size = ptrace_get_syscall_info_seccomp(child, regs,\n\t\t\t\t\t\t\t      &info);\n\t\tbreak;\n\t}\n\n\twrite_size = min(actual_size, user_size);\n\treturn copy_to_user(datavp, &info, write_size) ? -EFAULT : actual_size;\n}\n#endif  \n\nint ptrace_request(struct task_struct *child, long request,\n\t\t   unsigned long addr, unsigned long data)\n{\n\tbool seized = child->ptrace & PT_SEIZED;\n\tint ret = -EIO;\n\tkernel_siginfo_t siginfo, *si;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\tunsigned long flags;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\treturn generic_ptrace_peekdata(child, addr, data);\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\treturn generic_ptrace_pokedata(child, addr, data);\n\n#ifdef PTRACE_OLDSETOPTIONS\n\tcase PTRACE_OLDSETOPTIONS:\n#endif\n\tcase PTRACE_SETOPTIONS:\n\t\tret = ptrace_setoptions(child, data);\n\t\tbreak;\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user(child->ptrace_message, datalp);\n\t\tbreak;\n\n\tcase PTRACE_PEEKSIGINFO:\n\t\tret = ptrace_peek_siginfo(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user(datavp, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user(&siginfo, datavp);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGMASK: {\n\t\tsigset_t *mask;\n\n\t\tif (addr != sizeof(sigset_t)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (test_tsk_restore_sigmask(child))\n\t\t\tmask = &child->saved_sigmask;\n\t\telse\n\t\t\tmask = &child->blocked;\n\n\t\tif (copy_to_user(datavp, mask, sizeof(sigset_t)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\n\t\tbreak;\n\t}\n\n\tcase PTRACE_SETSIGMASK: {\n\t\tsigset_t new_set;\n\n\t\tif (addr != sizeof(sigset_t)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&new_set, datavp, sizeof(sigset_t))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\t \n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tchild->blocked = new_set;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tclear_tsk_restore_sigmask(child);\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tcase PTRACE_INTERRUPT:\n\t\t \n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\t \n\t\tif (likely(task_set_jobctl_pending(child, JOBCTL_TRAP_STOP)))\n\t\t\tptrace_signal_wake_up(child, child->jobctl & JOBCTL_LISTENING);\n\n\t\tunlock_task_sighand(child, &flags);\n\t\tret = 0;\n\t\tbreak;\n\n\tcase PTRACE_LISTEN:\n\t\t \n\t\tif (unlikely(!seized || !lock_task_sighand(child, &flags)))\n\t\t\tbreak;\n\n\t\tsi = child->last_siginfo;\n\t\tif (likely(si && (si->si_code >> 8) == PTRACE_EVENT_STOP)) {\n\t\t\tchild->jobctl |= JOBCTL_LISTENING;\n\t\t\t \n\t\t\tif (child->jobctl & JOBCTL_TRAP_NOTIFY)\n\t\t\t\tptrace_signal_wake_up(child, true);\n\t\t\tret = 0;\n\t\t}\n\t\tunlock_task_sighand(child, &flags);\n\t\tbreak;\n\n\tcase PTRACE_DETACH:\t  \n\t\tret = ptrace_detach(child, data);\n\t\tbreak;\n\n#ifdef CONFIG_BINFMT_ELF_FDPIC\n\tcase PTRACE_GETFDPIC: {\n\t\tstruct mm_struct *mm = get_task_mm(child);\n\t\tunsigned long tmp = 0;\n\n\t\tret = -ESRCH;\n\t\tif (!mm)\n\t\t\tbreak;\n\n\t\tswitch (addr) {\n\t\tcase PTRACE_GETFDPIC_EXEC:\n\t\t\ttmp = mm->context.exec_fdpic_loadmap;\n\t\t\tbreak;\n\t\tcase PTRACE_GETFDPIC_INTERP:\n\t\t\ttmp = mm->context.interp_fdpic_loadmap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmmput(mm);\n\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n#endif\n\n\tcase PTRACE_SINGLESTEP:\n#ifdef PTRACE_SINGLEBLOCK\n\tcase PTRACE_SINGLEBLOCK:\n#endif\n#ifdef PTRACE_SYSEMU\n\tcase PTRACE_SYSEMU:\n\tcase PTRACE_SYSEMU_SINGLESTEP:\n#endif\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\t\treturn ptrace_resume(child, request, data);\n\n\tcase PTRACE_KILL:\n\t\tsend_sig_info(SIGKILL, SEND_SIG_NOINFO, child);\n\t\treturn 0;\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET: {\n\t\tstruct iovec kiov;\n\t\tstruct iovec __user *uiov = datavp;\n\n\t\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(kiov.iov_base, &uiov->iov_base) ||\n\t\t    __get_user(kiov.iov_len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_SYSCALL_INFO:\n\t\tret = ptrace_get_syscall_info(child, addr, datavp);\n\t\tbreak;\n#endif\n\n\tcase PTRACE_SECCOMP_GET_FILTER:\n\t\tret = seccomp_get_filter(child, addr, datavp);\n\t\tbreak;\n\n\tcase PTRACE_SECCOMP_GET_METADATA:\n\t\tret = seccomp_get_metadata(child, addr, datavp);\n\t\tbreak;\n\n#ifdef CONFIG_RSEQ\n\tcase PTRACE_GET_RSEQ_CONFIGURATION:\n\t\tret = ptrace_get_rseq_configuration(child, addr, datavp);\n\t\tbreak;\n#endif\n\n\tcase PTRACE_SET_SYSCALL_USER_DISPATCH_CONFIG:\n\t\tret = syscall_user_dispatch_set_config(child, addr, datavp);\n\t\tbreak;\n\n\tcase PTRACE_GET_SYSCALL_USER_DISPATCH_CONFIG:\n\t\tret = syscall_user_dispatch_get_config(child, addr, datavp);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = find_get_task_by_vpid(pid);\n\tif (!child) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}\n\nint generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE);\n\tif (copied != sizeof(tmp))\n\t\treturn -EIO;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}\n\nint generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = ptrace_access_vm(tsk, addr, &data, sizeof(data),\n\t\t\tFOLL_FORCE | FOLL_WRITE);\n\treturn (copied == sizeof(data)) ? 0 : -EIO;\n}\n\n#if defined CONFIG_COMPAT\n\nint compat_ptrace_request(struct task_struct *child, compat_long_t request,\n\t\t\t  compat_ulong_t addr, compat_ulong_t data)\n{\n\tcompat_ulong_t __user *datap = compat_ptr(data);\n\tcompat_ulong_t word;\n\tkernel_siginfo_t siginfo;\n\tint ret;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\n\tcase PTRACE_PEEKDATA:\n\t\tret = ptrace_access_vm(child, addr, &word, sizeof(word),\n\t\t\t\tFOLL_FORCE);\n\t\tif (ret != sizeof(word))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = put_user(word, datap);\n\t\tbreak;\n\n\tcase PTRACE_POKETEXT:\n\tcase PTRACE_POKEDATA:\n\t\tret = ptrace_access_vm(child, addr, &data, sizeof(data),\n\t\t\t\tFOLL_FORCE | FOLL_WRITE);\n\t\tret = (ret != sizeof(data) ? -EIO : 0);\n\t\tbreak;\n\n\tcase PTRACE_GETEVENTMSG:\n\t\tret = put_user((compat_ulong_t) child->ptrace_message, datap);\n\t\tbreak;\n\n\tcase PTRACE_GETSIGINFO:\n\t\tret = ptrace_getsiginfo(child, &siginfo);\n\t\tif (!ret)\n\t\t\tret = copy_siginfo_to_user32(\n\t\t\t\t(struct compat_siginfo __user *) datap,\n\t\t\t\t&siginfo);\n\t\tbreak;\n\n\tcase PTRACE_SETSIGINFO:\n\t\tret = copy_siginfo_from_user32(\n\t\t\t&siginfo, (struct compat_siginfo __user *) datap);\n\t\tif (!ret)\n\t\t\tret = ptrace_setsiginfo(child, &siginfo);\n\t\tbreak;\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tcase PTRACE_GETREGSET:\n\tcase PTRACE_SETREGSET:\n\t{\n\t\tstruct iovec kiov;\n\t\tstruct compat_iovec __user *uiov =\n\t\t\t(struct compat_iovec __user *) datap;\n\t\tcompat_uptr_t ptr;\n\t\tcompat_size_t len;\n\n\t\tif (!access_ok(uiov, sizeof(*uiov)))\n\t\t\treturn -EFAULT;\n\n\t\tif (__get_user(ptr, &uiov->iov_base) ||\n\t\t    __get_user(len, &uiov->iov_len))\n\t\t\treturn -EFAULT;\n\n\t\tkiov.iov_base = compat_ptr(ptr);\n\t\tkiov.iov_len = len;\n\n\t\tret = ptrace_regset(child, request, addr, &kiov);\n\t\tif (!ret)\n\t\t\tret = __put_user(kiov.iov_len, &uiov->iov_len);\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t}\n\n\treturn ret;\n}\n\nCOMPAT_SYSCALL_DEFINE4(ptrace, compat_long_t, request, compat_long_t, pid,\n\t\t       compat_long_t, addr, compat_long_t, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = find_get_task_by_vpid(pid);\n\tif (!child) {\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret) {\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n\t\tif (ret || request != PTRACE_DETACH)\n\t\t\tptrace_unfreeze_traced(child);\n\t}\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}