{
  "module_name": "extable.c",
  "hash_id": "5ca0da18e4b99ac00614925914d26f20fd580b38b75cb07d8f8ad7df1271fd41",
  "original_prompt": "Ingested from linux-6.6.14/kernel/extable.c",
  "human_readable_source": "\n \n#include <linux/elf.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/extable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/kprobes.h>\n#include <linux/filter.h>\n\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n\n \nDEFINE_MUTEX(text_mutex);\n\nextern struct exception_table_entry __start___ex_table[];\nextern struct exception_table_entry __stop___ex_table[];\n\n \nu32 __initdata __visible main_extable_sort_needed = 1;\n\n \nvoid __init sort_main_extable(void)\n{\n\tif (main_extable_sort_needed &&\n\t    &__stop___ex_table > &__start___ex_table) {\n\t\tpr_notice(\"Sorting __ex_table...\\n\");\n\t\tsort_extable(__start___ex_table, __stop___ex_table);\n\t}\n}\n\n \nconst\nstruct exception_table_entry *search_kernel_exception_table(unsigned long addr)\n{\n\treturn search_extable(__start___ex_table,\n\t\t\t      __stop___ex_table - __start___ex_table, addr);\n}\n\n \nconst struct exception_table_entry *search_exception_tables(unsigned long addr)\n{\n\tconst struct exception_table_entry *e;\n\n\te = search_kernel_exception_table(addr);\n\tif (!e)\n\t\te = search_module_extables(addr);\n\tif (!e)\n\t\te = search_bpf_extables(addr);\n\treturn e;\n}\n\nint notrace core_kernel_text(unsigned long addr)\n{\n\tif (is_kernel_text(addr))\n\t\treturn 1;\n\n\tif (system_state < SYSTEM_FREEING_INITMEM &&\n\t    is_kernel_inittext(addr))\n\t\treturn 1;\n\treturn 0;\n}\n\nint __kernel_text_address(unsigned long addr)\n{\n\tif (kernel_text_address(addr))\n\t\treturn 1;\n\t \n\tif (is_kernel_inittext(addr))\n\t\treturn 1;\n\treturn 0;\n}\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t \n\tno_rcu = !rcu_is_watching();\n\n\t \n\tif (no_rcu)\n\t\tct_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\tct_nmi_exit();\n\n\treturn ret;\n}\n\n \n#ifdef CONFIG_HAVE_FUNCTION_DESCRIPTORS\nvoid *dereference_function_descriptor(void *ptr)\n{\n\tfunc_desc_t *desc = ptr;\n\tvoid *p;\n\n\tif (!get_kernel_nofault(p, (void *)&desc->addr))\n\t\tptr = p;\n\treturn ptr;\n}\nEXPORT_SYMBOL_GPL(dereference_function_descriptor);\n\nvoid *dereference_kernel_function_descriptor(void *ptr)\n{\n\tif (ptr < (void *)__start_opd || ptr >= (void *)__end_opd)\n\t\treturn ptr;\n\n\treturn dereference_function_descriptor(ptr);\n}\n#endif\n\nint func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}