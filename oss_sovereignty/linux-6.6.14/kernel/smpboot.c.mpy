{
  "module_name": "smpboot.c",
  "hash_id": "38eadae926967674217502e2a5cfcfd22906bc828e5407e0f64f6f661f62555f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/smpboot.c",
  "human_readable_source": "\n \n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/kthread.h>\n#include <linux/smpboot.h>\n\n#include \"smpboot.h\"\n\n#ifdef CONFIG_SMP\n\n#ifdef CONFIG_GENERIC_SMP_IDLE_THREAD\n \nstatic DEFINE_PER_CPU(struct task_struct *, idle_threads);\n\nstruct task_struct *idle_thread_get(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn tsk;\n}\n\nvoid __init idle_thread_set_boot_cpu(void)\n{\n\tper_cpu(idle_threads, smp_processor_id()) = current;\n}\n\n \nstatic __always_inline void idle_init(unsigned int cpu)\n{\n\tstruct task_struct *tsk = per_cpu(idle_threads, cpu);\n\n\tif (!tsk) {\n\t\ttsk = fork_idle(cpu);\n\t\tif (IS_ERR(tsk))\n\t\t\tpr_err(\"SMP: fork_idle() failed for CPU %u\\n\", cpu);\n\t\telse\n\t\t\tper_cpu(idle_threads, cpu) = tsk;\n\t}\n}\n\n \nvoid __init idle_threads_init(void)\n{\n\tunsigned int cpu, boot_cpu;\n\n\tboot_cpu = smp_processor_id();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu != boot_cpu)\n\t\t\tidle_init(cpu);\n\t}\n}\n#endif\n\n#endif  \n\nstatic LIST_HEAD(hotplug_threads);\nstatic DEFINE_MUTEX(smpboot_threads_lock);\n\nstruct smpboot_thread_data {\n\tunsigned int\t\t\tcpu;\n\tunsigned int\t\t\tstatus;\n\tstruct smp_hotplug_thread\t*ht;\n};\n\nenum {\n\tHP_THREAD_NONE = 0,\n\tHP_THREAD_ACTIVE,\n\tHP_THREAD_PARKED,\n};\n\n \nstatic int smpboot_thread_fn(void *data)\n{\n\tstruct smpboot_thread_data *td = data;\n\tstruct smp_hotplug_thread *ht = td->ht;\n\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tpreempt_disable();\n\t\tif (kthread_should_stop()) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tpreempt_enable();\n\t\t\t \n\t\t\tif (ht->cleanup && td->status != HP_THREAD_NONE)\n\t\t\t\tht->cleanup(td->cpu, cpu_online(td->cpu));\n\t\t\tkfree(td);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (kthread_should_park()) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tpreempt_enable();\n\t\t\tif (ht->park && td->status == HP_THREAD_ACTIVE) {\n\t\t\t\tBUG_ON(td->cpu != smp_processor_id());\n\t\t\t\tht->park(td->cpu);\n\t\t\t\ttd->status = HP_THREAD_PARKED;\n\t\t\t}\n\t\t\tkthread_parkme();\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(td->cpu != smp_processor_id());\n\n\t\t \n\t\tswitch (td->status) {\n\t\tcase HP_THREAD_NONE:\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tpreempt_enable();\n\t\t\tif (ht->setup)\n\t\t\t\tht->setup(td->cpu);\n\t\t\ttd->status = HP_THREAD_ACTIVE;\n\t\t\tcontinue;\n\n\t\tcase HP_THREAD_PARKED:\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tpreempt_enable();\n\t\t\tif (ht->unpark)\n\t\t\t\tht->unpark(td->cpu);\n\t\t\ttd->status = HP_THREAD_ACTIVE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ht->thread_should_run(td->cpu)) {\n\t\t\tpreempt_enable_no_resched();\n\t\t\tschedule();\n\t\t} else {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tpreempt_enable();\n\t\t\tht->thread_fn(td->cpu);\n\t\t}\n\t}\n}\n\nstatic int\n__smpboot_create_thread(struct smp_hotplug_thread *ht, unsigned int cpu)\n{\n\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);\n\tstruct smpboot_thread_data *td;\n\n\tif (tsk)\n\t\treturn 0;\n\n\ttd = kzalloc_node(sizeof(*td), GFP_KERNEL, cpu_to_node(cpu));\n\tif (!td)\n\t\treturn -ENOMEM;\n\ttd->cpu = cpu;\n\ttd->ht = ht;\n\n\ttsk = kthread_create_on_cpu(smpboot_thread_fn, td, cpu,\n\t\t\t\t    ht->thread_comm);\n\tif (IS_ERR(tsk)) {\n\t\tkfree(td);\n\t\treturn PTR_ERR(tsk);\n\t}\n\tkthread_set_per_cpu(tsk, cpu);\n\t \n\tkthread_park(tsk);\n\tget_task_struct(tsk);\n\t*per_cpu_ptr(ht->store, cpu) = tsk;\n\tif (ht->create) {\n\t\t \n\t\tif (!wait_task_inactive(tsk, TASK_PARKED))\n\t\t\tWARN_ON(1);\n\t\telse\n\t\t\tht->create(cpu);\n\t}\n\treturn 0;\n}\n\nint smpboot_create_threads(unsigned int cpu)\n{\n\tstruct smp_hotplug_thread *cur;\n\tint ret = 0;\n\n\tmutex_lock(&smpboot_threads_lock);\n\tlist_for_each_entry(cur, &hotplug_threads, list) {\n\t\tret = __smpboot_create_thread(cur, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&smpboot_threads_lock);\n\treturn ret;\n}\n\nstatic void smpboot_unpark_thread(struct smp_hotplug_thread *ht, unsigned int cpu)\n{\n\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);\n\n\tif (!ht->selfparking)\n\t\tkthread_unpark(tsk);\n}\n\nint smpboot_unpark_threads(unsigned int cpu)\n{\n\tstruct smp_hotplug_thread *cur;\n\n\tmutex_lock(&smpboot_threads_lock);\n\tlist_for_each_entry(cur, &hotplug_threads, list)\n\t\tsmpboot_unpark_thread(cur, cpu);\n\tmutex_unlock(&smpboot_threads_lock);\n\treturn 0;\n}\n\nstatic void smpboot_park_thread(struct smp_hotplug_thread *ht, unsigned int cpu)\n{\n\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);\n\n\tif (tsk && !ht->selfparking)\n\t\tkthread_park(tsk);\n}\n\nint smpboot_park_threads(unsigned int cpu)\n{\n\tstruct smp_hotplug_thread *cur;\n\n\tmutex_lock(&smpboot_threads_lock);\n\tlist_for_each_entry_reverse(cur, &hotplug_threads, list)\n\t\tsmpboot_park_thread(cur, cpu);\n\tmutex_unlock(&smpboot_threads_lock);\n\treturn 0;\n}\n\nstatic void smpboot_destroy_threads(struct smp_hotplug_thread *ht)\n{\n\tunsigned int cpu;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tstruct task_struct *tsk = *per_cpu_ptr(ht->store, cpu);\n\n\t\tif (tsk) {\n\t\t\tkthread_stop(tsk);\n\t\t\tput_task_struct(tsk);\n\t\t\t*per_cpu_ptr(ht->store, cpu) = NULL;\n\t\t}\n\t}\n}\n\n \nint smpboot_register_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tfor_each_online_cpu(cpu) {\n\t\tret = __smpboot_create_thread(plug_thread, cpu);\n\t\tif (ret) {\n\t\t\tsmpboot_destroy_threads(plug_thread);\n\t\t\tgoto out;\n\t\t}\n\t\tsmpboot_unpark_thread(plug_thread, cpu);\n\t}\n\tlist_add(&plug_thread->list, &hotplug_threads);\nout:\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(smpboot_register_percpu_thread);\n\n \nvoid smpboot_unregister_percpu_thread(struct smp_hotplug_thread *plug_thread)\n{\n\tcpus_read_lock();\n\tmutex_lock(&smpboot_threads_lock);\n\tlist_del(&plug_thread->list);\n\tsmpboot_destroy_threads(plug_thread);\n\tmutex_unlock(&smpboot_threads_lock);\n\tcpus_read_unlock();\n}\nEXPORT_SYMBOL_GPL(smpboot_unregister_percpu_thread);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}