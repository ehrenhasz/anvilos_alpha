{
  "module_name": "vhost_task.c",
  "hash_id": "57198ec4ccd207b68d9c5bd96705d357dacee203539bfba07f3ca20d7ad6d69f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/vhost_task.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched/task.h>\n#include <linux/sched/vhost_task.h>\n#include <linux/sched/signal.h>\n\nenum vhost_task_flags {\n\tVHOST_TASK_FLAGS_STOP,\n};\n\nstruct vhost_task {\n\tbool (*fn)(void *data);\n\tvoid *data;\n\tstruct completion exited;\n\tunsigned long flags;\n\tstruct task_struct *task;\n};\n\nstatic int vhost_task_fn(void *data)\n{\n\tstruct vhost_task *vtsk = data;\n\tbool dead = false;\n\n\tfor (;;) {\n\t\tbool did_work;\n\n\t\tif (!dead && signal_pending(current)) {\n\t\t\tstruct ksignal ksig;\n\t\t\t \n\t\t\tdead = get_signal(&ksig);\n\t\t\tif (dead)\n\t\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t}\n\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (test_bit(VHOST_TASK_FLAGS_STOP, &vtsk->flags)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\n\t\tdid_work = vtsk->fn(vtsk->data);\n\t\tif (!did_work)\n\t\t\tschedule();\n\t}\n\n\tcomplete(&vtsk->exited);\n\tdo_exit(0);\n}\n\n \nvoid vhost_task_wake(struct vhost_task *vtsk)\n{\n\twake_up_process(vtsk->task);\n}\nEXPORT_SYMBOL_GPL(vhost_task_wake);\n\n \nvoid vhost_task_stop(struct vhost_task *vtsk)\n{\n\tset_bit(VHOST_TASK_FLAGS_STOP, &vtsk->flags);\n\tvhost_task_wake(vtsk);\n\t \n\twait_for_completion(&vtsk->exited);\n\tkfree(vtsk);\n}\nEXPORT_SYMBOL_GPL(vhost_task_stop);\n\n \nstruct vhost_task *vhost_task_create(bool (*fn)(void *), void *arg,\n\t\t\t\t     const char *name)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= CLONE_FS | CLONE_UNTRACED | CLONE_VM |\n\t\t\t\t  CLONE_THREAD | CLONE_SIGHAND,\n\t\t.exit_signal\t= 0,\n\t\t.fn\t\t= vhost_task_fn,\n\t\t.name\t\t= name,\n\t\t.user_worker\t= 1,\n\t\t.no_files\t= 1,\n\t};\n\tstruct vhost_task *vtsk;\n\tstruct task_struct *tsk;\n\n\tvtsk = kzalloc(sizeof(*vtsk), GFP_KERNEL);\n\tif (!vtsk)\n\t\treturn NULL;\n\tinit_completion(&vtsk->exited);\n\tvtsk->data = arg;\n\tvtsk->fn = fn;\n\n\targs.fn_arg = vtsk;\n\n\ttsk = copy_process(NULL, 0, NUMA_NO_NODE, &args);\n\tif (IS_ERR(tsk)) {\n\t\tkfree(vtsk);\n\t\treturn NULL;\n\t}\n\n\tvtsk->task = tsk;\n\treturn vtsk;\n}\nEXPORT_SYMBOL_GPL(vhost_task_create);\n\n \nvoid vhost_task_start(struct vhost_task *vtsk)\n{\n\twake_up_new_task(vtsk->task);\n}\nEXPORT_SYMBOL_GPL(vhost_task_start);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}