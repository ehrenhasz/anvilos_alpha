{
  "module_name": "syscall_user_dispatch.c",
  "hash_id": "8edc2a1589ae6bd35412151aa108be4068c3e72b96adf0ea8e493abefc792003",
  "original_prompt": "Ingested from linux-6.6.14/kernel/entry/syscall_user_dispatch.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/syscall_user_dispatch.h>\n#include <linux/uaccess.h>\n#include <linux/signal.h>\n#include <linux/elf.h>\n\n#include <linux/sched/signal.h>\n#include <linux/sched/task_stack.h>\n\n#include <asm/syscall.h>\n\n#include \"common.h\"\n\nstatic void trigger_sigsys(struct pt_regs *regs)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_USER_DISPATCH;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = 0;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall_get_nr(current, regs);\n\n\tforce_sig_info(&info);\n}\n\nbool syscall_user_dispatch(struct pt_regs *regs)\n{\n\tstruct syscall_user_dispatch *sd = &current->syscall_dispatch;\n\tchar state;\n\n\tif (likely(instruction_pointer(regs) - sd->offset < sd->len))\n\t\treturn false;\n\n\tif (unlikely(arch_syscall_is_vdso_sigreturn(regs)))\n\t\treturn false;\n\n\tif (likely(sd->selector)) {\n\t\t \n\t\tif (unlikely(__get_user(state, sd->selector))) {\n\t\t\tforce_exit_sig(SIGSEGV);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (likely(state == SYSCALL_DISPATCH_FILTER_ALLOW))\n\t\t\treturn false;\n\n\t\tif (state != SYSCALL_DISPATCH_FILTER_BLOCK) {\n\t\t\tforce_exit_sig(SIGSYS);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tsd->on_dispatch = true;\n\tsyscall_rollback(current, regs);\n\ttrigger_sigsys(regs);\n\n\treturn true;\n}\n\nstatic int task_set_syscall_user_dispatch(struct task_struct *task, unsigned long mode,\n\t\t\t\t\t  unsigned long offset, unsigned long len,\n\t\t\t\t\t  char __user *selector)\n{\n\tswitch (mode) {\n\tcase PR_SYS_DISPATCH_OFF:\n\t\tif (offset || len || selector)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PR_SYS_DISPATCH_ON:\n\t\t \n\t\tif (offset && offset + len <= offset)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (selector && !access_ok(untagged_addr(selector), sizeof(*selector)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttask->syscall_dispatch.selector = selector;\n\ttask->syscall_dispatch.offset = offset;\n\ttask->syscall_dispatch.len = len;\n\ttask->syscall_dispatch.on_dispatch = false;\n\n\tif (mode == PR_SYS_DISPATCH_ON)\n\t\tset_task_syscall_work(task, SYSCALL_USER_DISPATCH);\n\telse\n\t\tclear_task_syscall_work(task, SYSCALL_USER_DISPATCH);\n\n\treturn 0;\n}\n\nint set_syscall_user_dispatch(unsigned long mode, unsigned long offset,\n\t\t\t      unsigned long len, char __user *selector)\n{\n\treturn task_set_syscall_user_dispatch(current, mode, offset, len, selector);\n}\n\nint syscall_user_dispatch_get_config(struct task_struct *task, unsigned long size,\n\t\t\t\t     void __user *data)\n{\n\tstruct syscall_user_dispatch *sd = &task->syscall_dispatch;\n\tstruct ptrace_sud_config cfg;\n\n\tif (size != sizeof(cfg))\n\t\treturn -EINVAL;\n\n\tif (test_task_syscall_work(task, SYSCALL_USER_DISPATCH))\n\t\tcfg.mode = PR_SYS_DISPATCH_ON;\n\telse\n\t\tcfg.mode = PR_SYS_DISPATCH_OFF;\n\n\tcfg.offset = sd->offset;\n\tcfg.len = sd->len;\n\tcfg.selector = (__u64)(uintptr_t)sd->selector;\n\n\tif (copy_to_user(data, &cfg, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint syscall_user_dispatch_set_config(struct task_struct *task, unsigned long size,\n\t\t\t\t     void __user *data)\n{\n\tstruct ptrace_sud_config cfg;\n\n\tif (size != sizeof(cfg))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cfg, data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\treturn task_set_syscall_user_dispatch(task, cfg.mode, cfg.offset, cfg.len,\n\t\t\t\t\t      (char __user *)(uintptr_t)cfg.selector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}