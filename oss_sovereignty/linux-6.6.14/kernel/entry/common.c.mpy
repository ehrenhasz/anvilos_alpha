{
  "module_name": "common.c",
  "hash_id": "48a03f27b1766c9786812243b5547507b5c1f889313df2c53502d21e50e76579",
  "original_prompt": "Ingested from linux-6.6.14/kernel/entry/common.c",
  "human_readable_source": "\n\n#include <linux/context_tracking.h>\n#include <linux/entry-common.h>\n#include <linux/resume_user_mode.h>\n#include <linux/highmem.h>\n#include <linux/jump_label.h>\n#include <linux/kmsan.h>\n#include <linux/livepatch.h>\n#include <linux/audit.h>\n#include <linux/tick.h>\n\n#include \"common.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/syscalls.h>\n\n \nstatic __always_inline void __enter_from_user_mode(struct pt_regs *regs)\n{\n\tarch_enter_from_user_mode(regs);\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\n\tCT_WARN_ON(__ct_state() != CONTEXT_USER);\n\tuser_exit_irqoff();\n\n\tinstrumentation_begin();\n\tkmsan_unpoison_entry_regs(regs);\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n}\n\nvoid noinstr enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}\n\nstatic inline void syscall_enter_audit(struct pt_regs *regs, long syscall)\n{\n\tif (unlikely(audit_context())) {\n\t\tunsigned long args[6];\n\n\t\tsyscall_get_arguments(current, regs, args);\n\t\taudit_syscall_entry(syscall, args[0], args[1], args[2], args[3]);\n\t}\n}\n\nstatic long syscall_trace_enter(struct pt_regs *regs, long syscall,\n\t\t\t\tunsigned long work)\n{\n\tlong ret = 0;\n\n\t \n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (syscall_user_dispatch(regs))\n\t\t\treturn -1L;\n\t}\n\n\t \n\tif (work & (SYSCALL_WORK_SYSCALL_TRACE | SYSCALL_WORK_SYSCALL_EMU)) {\n\t\tret = ptrace_report_syscall_entry(regs);\n\t\tif (ret || (work & SYSCALL_WORK_SYSCALL_EMU))\n\t\t\treturn -1L;\n\t}\n\n\t \n\tif (work & SYSCALL_WORK_SECCOMP) {\n\t\tret = __secure_computing(NULL);\n\t\tif (ret == -1L)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsyscall = syscall_get_nr(current, regs);\n\n\tif (unlikely(work & SYSCALL_WORK_SYSCALL_TRACEPOINT))\n\t\ttrace_sys_enter(regs, syscall);\n\n\tsyscall_enter_audit(regs, syscall);\n\n\treturn ret ? : syscall;\n}\n\nstatic __always_inline long\n__syscall_enter_from_user_work(struct pt_regs *regs, long syscall)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\n\tif (work & SYSCALL_WORK_ENTER)\n\t\tsyscall = syscall_trace_enter(regs, syscall, work);\n\n\treturn syscall;\n}\n\nlong syscall_enter_from_user_mode_work(struct pt_regs *regs, long syscall)\n{\n\treturn __syscall_enter_from_user_work(regs, syscall);\n}\n\nnoinstr long syscall_enter_from_user_mode(struct pt_regs *regs, long syscall)\n{\n\tlong ret;\n\n\t__enter_from_user_mode(regs);\n\n\tinstrumentation_begin();\n\tlocal_irq_enable();\n\tret = __syscall_enter_from_user_work(regs, syscall);\n\tinstrumentation_end();\n\n\treturn ret;\n}\n\nnoinstr void syscall_enter_from_user_mode_prepare(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n\tinstrumentation_begin();\n\tlocal_irq_enable();\n\tinstrumentation_end();\n}\n\n \nstatic __always_inline void __exit_to_user_mode(void)\n{\n\tinstrumentation_begin();\n\ttrace_hardirqs_on_prepare();\n\tlockdep_hardirqs_on_prepare();\n\tinstrumentation_end();\n\n\tuser_enter_irqoff();\n\tarch_exit_to_user_mode();\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}\n\nvoid noinstr exit_to_user_mode(void)\n{\n\t__exit_to_user_mode();\n}\n\n \nvoid __weak arch_do_signal_or_restart(struct pt_regs *regs) { }\n\nstatic unsigned long exit_to_user_mode_loop(struct pt_regs *regs,\n\t\t\t\t\t    unsigned long ti_work)\n{\n\t \n\twhile (ti_work & EXIT_TO_USER_MODE_WORK) {\n\n\t\tlocal_irq_enable_exit_to_user(ti_work);\n\n\t\tif (ti_work & _TIF_NEED_RESCHED)\n\t\t\tschedule();\n\n\t\tif (ti_work & _TIF_UPROBE)\n\t\t\tuprobe_notify_resume(regs);\n\n\t\tif (ti_work & _TIF_PATCH_PENDING)\n\t\t\tklp_update_patch_state(current);\n\n\t\tif (ti_work & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))\n\t\t\tarch_do_signal_or_restart(regs);\n\n\t\tif (ti_work & _TIF_NOTIFY_RESUME)\n\t\t\tresume_user_mode_work(regs);\n\n\t\t \n\t\tarch_exit_to_user_mode_work(regs, ti_work);\n\n\t\t \n\t\tlocal_irq_disable_exit_to_user();\n\n\t\t \n\t\ttick_nohz_user_enter_prepare();\n\n\t\tti_work = read_thread_flags();\n\t}\n\n\t \n\treturn ti_work;\n}\n\nstatic void exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long ti_work;\n\n\tlockdep_assert_irqs_disabled();\n\n\t \n\ttick_nohz_user_enter_prepare();\n\n\tti_work = read_thread_flags();\n\tif (unlikely(ti_work & EXIT_TO_USER_MODE_WORK))\n\t\tti_work = exit_to_user_mode_loop(regs, ti_work);\n\n\tarch_exit_to_user_mode_prepare(regs, ti_work);\n\n\t \n\tkmap_assert_nomap();\n\tlockdep_assert_irqs_disabled();\n\tlockdep_sys_exit();\n}\n\n \nstatic inline bool report_single_step(unsigned long work)\n{\n\tif (work & SYSCALL_WORK_SYSCALL_EMU)\n\t\treturn false;\n\n\treturn work & SYSCALL_WORK_SYSCALL_EXIT_TRAP;\n}\n\nstatic void syscall_exit_work(struct pt_regs *regs, unsigned long work)\n{\n\tbool step;\n\n\t \n\tif (work & SYSCALL_WORK_SYSCALL_USER_DISPATCH) {\n\t\tif (unlikely(current->syscall_dispatch.on_dispatch)) {\n\t\t\tcurrent->syscall_dispatch.on_dispatch = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\taudit_syscall_exit(regs);\n\n\tif (work & SYSCALL_WORK_SYSCALL_TRACEPOINT)\n\t\ttrace_sys_exit(regs, syscall_get_return_value(current, regs));\n\n\tstep = report_single_step(work);\n\tif (step || work & SYSCALL_WORK_SYSCALL_TRACE)\n\t\tptrace_report_syscall_exit(regs, step);\n}\n\n \nstatic void syscall_exit_to_user_mode_prepare(struct pt_regs *regs)\n{\n\tunsigned long work = READ_ONCE(current_thread_info()->syscall_work);\n\tunsigned long nr = syscall_get_nr(current, regs);\n\n\tCT_WARN_ON(ct_state() != CONTEXT_KERNEL);\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tif (WARN(irqs_disabled(), \"syscall %lu left IRQs disabled\", nr))\n\t\t\tlocal_irq_enable();\n\t}\n\n\trseq_syscall(regs);\n\n\t \n\tif (unlikely(work & SYSCALL_WORK_EXIT))\n\t\tsyscall_exit_work(regs, work);\n}\n\nstatic __always_inline void __syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\tsyscall_exit_to_user_mode_prepare(regs);\n\tlocal_irq_disable_exit_to_user();\n\texit_to_user_mode_prepare(regs);\n}\n\nvoid syscall_exit_to_user_mode_work(struct pt_regs *regs)\n{\n\t__syscall_exit_to_user_mode_work(regs);\n}\n\n__visible noinstr void syscall_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\t__syscall_exit_to_user_mode_work(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}\n\nnoinstr void irqentry_enter_from_user_mode(struct pt_regs *regs)\n{\n\t__enter_from_user_mode(regs);\n}\n\nnoinstr void irqentry_exit_to_user_mode(struct pt_regs *regs)\n{\n\tinstrumentation_begin();\n\texit_to_user_mode_prepare(regs);\n\tinstrumentation_end();\n\t__exit_to_user_mode();\n}\n\nnoinstr irqentry_state_t irqentry_enter(struct pt_regs *regs)\n{\n\tirqentry_state_t ret = {\n\t\t.exit_rcu = false,\n\t};\n\n\tif (user_mode(regs)) {\n\t\tirqentry_enter_from_user_mode(regs);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!IS_ENABLED(CONFIG_TINY_RCU) && is_idle_task(current)) {\n\t\t \n\t\tlockdep_hardirqs_off(CALLER_ADDR0);\n\t\tct_irq_enter();\n\t\tinstrumentation_begin();\n\t\tkmsan_unpoison_entry_regs(regs);\n\t\ttrace_hardirqs_off_finish();\n\t\tinstrumentation_end();\n\n\t\tret.exit_rcu = true;\n\t\treturn ret;\n\t}\n\n\t \n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\tinstrumentation_begin();\n\tkmsan_unpoison_entry_regs(regs);\n\trcu_irq_enter_check_tick();\n\ttrace_hardirqs_off_finish();\n\tinstrumentation_end();\n\n\treturn ret;\n}\n\nvoid raw_irqentry_exit_cond_resched(void)\n{\n\tif (!preempt_count()) {\n\t\t \n\t\trcu_irq_exit_check_preempt();\n\t\tif (IS_ENABLED(CONFIG_DEBUG_ENTRY))\n\t\t\tWARN_ON_ONCE(!on_thread_stack());\n\t\tif (need_resched())\n\t\t\tpreempt_schedule_irq();\n\t}\n}\n#ifdef CONFIG_PREEMPT_DYNAMIC\n#if defined(CONFIG_HAVE_PREEMPT_DYNAMIC_CALL)\nDEFINE_STATIC_CALL(irqentry_exit_cond_resched, raw_irqentry_exit_cond_resched);\n#elif defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)\nDEFINE_STATIC_KEY_TRUE(sk_dynamic_irqentry_exit_cond_resched);\nvoid dynamic_irqentry_exit_cond_resched(void)\n{\n\tif (!static_branch_unlikely(&sk_dynamic_irqentry_exit_cond_resched))\n\t\treturn;\n\traw_irqentry_exit_cond_resched();\n}\n#endif\n#endif\n\nnoinstr void irqentry_exit(struct pt_regs *regs, irqentry_state_t state)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t \n\tif (user_mode(regs)) {\n\t\tirqentry_exit_to_user_mode(regs);\n\t} else if (!regs_irqs_disabled(regs)) {\n\t\t \n\t\tif (state.exit_rcu) {\n\t\t\tinstrumentation_begin();\n\t\t\t \n\t\t\ttrace_hardirqs_on_prepare();\n\t\t\tlockdep_hardirqs_on_prepare();\n\t\t\tinstrumentation_end();\n\t\t\tct_irq_exit();\n\t\t\tlockdep_hardirqs_on(CALLER_ADDR0);\n\t\t\treturn;\n\t\t}\n\n\t\tinstrumentation_begin();\n\t\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\t\tirqentry_exit_cond_resched();\n\n\t\t \n\t\ttrace_hardirqs_on();\n\t\tinstrumentation_end();\n\t} else {\n\t\t \n\t\tif (state.exit_rcu)\n\t\t\tct_irq_exit();\n\t}\n}\n\nirqentry_state_t noinstr irqentry_nmi_enter(struct pt_regs *regs)\n{\n\tirqentry_state_t irq_state;\n\n\tirq_state.lockdep = lockdep_hardirqs_enabled();\n\n\t__nmi_enter();\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n\tlockdep_hardirq_enter();\n\tct_nmi_enter();\n\n\tinstrumentation_begin();\n\tkmsan_unpoison_entry_regs(regs);\n\ttrace_hardirqs_off_finish();\n\tftrace_nmi_enter();\n\tinstrumentation_end();\n\n\treturn irq_state;\n}\n\nvoid noinstr irqentry_nmi_exit(struct pt_regs *regs, irqentry_state_t irq_state)\n{\n\tinstrumentation_begin();\n\tftrace_nmi_exit();\n\tif (irq_state.lockdep) {\n\t\ttrace_hardirqs_on_prepare();\n\t\tlockdep_hardirqs_on_prepare();\n\t}\n\tinstrumentation_end();\n\n\tct_nmi_exit();\n\tlockdep_hardirq_exit();\n\tif (irq_state.lockdep)\n\t\tlockdep_hardirqs_on(CALLER_ADDR0);\n\t__nmi_exit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}