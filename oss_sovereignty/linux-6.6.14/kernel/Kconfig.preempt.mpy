{
  "module_name": "Kconfig.preempt",
  "hash_id": "f95505919b35e5967137fd0120301a3d1e9af50a5c5ff03714335e894c2df8b8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/Kconfig.preempt",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n\nconfig PREEMPT_NONE_BUILD\n\tbool\n\nconfig PREEMPT_VOLUNTARY_BUILD\n\tbool\n\nconfig PREEMPT_BUILD\n\tbool\n\tselect PREEMPTION\n\tselect UNINLINE_SPIN_UNLOCK if !ARCH_INLINE_SPIN_UNLOCK\n\nchoice\n\tprompt \"Preemption Model\"\n\tdefault PREEMPT_NONE\n\nconfig PREEMPT_NONE\n\tbool \"No Forced Preemption (Server)\"\n\tselect PREEMPT_NONE_BUILD if !PREEMPT_DYNAMIC\n\thelp\n\t  This is the traditional Linux preemption model, geared towards\n\t  throughput. It will still provide good latencies most of the\n\t  time, but there are no guarantees and occasional longer delays\n\t  are possible.\n\n\t  Select this option if you are building a kernel for a server or\n\t  scientific/computation system, or if you want to maximize the\n\t  raw processing power of the kernel, irrespective of scheduling\n\t  latencies.\n\nconfig PREEMPT_VOLUNTARY\n\tbool \"Voluntary Kernel Preemption (Desktop)\"\n\tdepends on !ARCH_NO_PREEMPT\n\tselect PREEMPT_VOLUNTARY_BUILD if !PREEMPT_DYNAMIC\n\thelp\n\t  This option reduces the latency of the kernel by adding more\n\t  \"explicit preemption points\" to the kernel code. These new\n\t  preemption points have been selected to reduce the maximum\n\t  latency of rescheduling, providing faster application reactions,\n\t  at the cost of slightly lower throughput.\n\n\t  This allows reaction to interactive events by allowing a\n\t  low priority process to voluntarily preempt itself even if it\n\t  is in kernel mode executing a system call. This allows\n\t  applications to run more 'smoothly' even when the system is\n\t  under load.\n\n\t  Select this if you are building a kernel for a desktop system.\n\nconfig PREEMPT\n\tbool \"Preemptible Kernel (Low-Latency Desktop)\"\n\tdepends on !ARCH_NO_PREEMPT\n\tselect PREEMPT_BUILD\n\thelp\n\t  This option reduces the latency of the kernel by making\n\t  all kernel code (that is not executing in a critical section)\n\t  preemptible.  This allows reaction to interactive events by\n\t  permitting a low priority process to be preempted involuntarily\n\t  even if it is in kernel mode executing a system call and would\n\t  otherwise not be about to reach a natural preemption point.\n\t  This allows applications to run more 'smoothly' even when the\n\t  system is under load, at the cost of slightly lower throughput\n\t  and a slight runtime overhead to kernel code.\n\n\t  Select this if you are building a kernel for a desktop or\n\t  embedded system with latency requirements in the milliseconds\n\t  range.\n\nconfig PREEMPT_RT\n\tbool \"Fully Preemptible Kernel (Real-Time)\"\n\tdepends on EXPERT && ARCH_SUPPORTS_RT\n\tselect PREEMPTION\n\thelp\n\t  This option turns the kernel into a real-time kernel by replacing\n\t  various locking primitives (spinlocks, rwlocks, etc.) with\n\t  preemptible priority-inheritance aware variants, enforcing\n\t  interrupt threading and introducing mechanisms to break up long\n\t  non-preemptible sections. This makes the kernel, except for very\n\t  low level and critical code paths (entry code, scheduler, low\n\t  level interrupt handling) fully preemptible and brings most\n\t  execution contexts under scheduler control.\n\n\t  Select this if you are building a kernel for systems which\n\t  require real-time guarantees.\n\nendchoice\n\nconfig PREEMPT_COUNT\n       bool\n\nconfig PREEMPTION\n       bool\n       select PREEMPT_COUNT\n\nconfig PREEMPT_DYNAMIC\n\tbool \"Preemption behaviour defined on boot\"\n\tdepends on HAVE_PREEMPT_DYNAMIC && !PREEMPT_RT\n\tselect JUMP_LABEL if HAVE_PREEMPT_DYNAMIC_KEY\n\tselect PREEMPT_BUILD\n\tdefault y if HAVE_PREEMPT_DYNAMIC_CALL\n\thelp\n\t  This option allows to define the preemption model on the kernel\n\t  command line parameter and thus override the default preemption\n\t  model defined during compile time.\n\n\t  The feature is primarily interesting for Linux distributions which\n\t  provide a pre-built kernel binary to reduce the number of kernel\n\t  flavors they offer while still offering different usecases.\n\n\t  The runtime overhead is negligible with HAVE_STATIC_CALL_INLINE enabled\n\t  but if runtime patching is not available for the specific architecture\n\t  then the potential overhead should be considered.\n\n\t  Interesting if you want the same pre-built kernel should be used for\n\t  both Server and Desktop workloads.\n\nconfig SCHED_CORE\n\tbool \"Core Scheduling for SMT\"\n\tdepends on SCHED_SMT\n\thelp\n\t  This option permits Core Scheduling, a means of coordinated task\n\t  selection across SMT siblings. When enabled -- see\n\t  prctl(PR_SCHED_CORE) -- task selection ensures that all SMT siblings\n\t  will execute a task from the same 'core group', forcing idle when no\n\t  matching task is found.\n\n\t  Use of this feature includes:\n\t   - mitigation of some (not all) SMT side channels;\n\t   - limiting SMT interference to improve determinism and/or performance.\n\n\t  SCHED_CORE is default disabled. When it is enabled and unused,\n\t  which is the likely usage by Linux distributions, there should\n\t  be no measurable impact on performance.\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}