{
  "module_name": "acct.c",
  "hash_id": "1ab7d29465ffa3d103a1982c4d445d5bf2b879545e831cb5eca4037fb17ff11b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/acct.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/security.h>\n#include <linux/vfs.h>\n#include <linux/jiffies.h>\n#include <linux/times.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/sched/cputime.h>\n\n#include <asm/div64.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs_pin.h>\n\n \n\nstatic int acct_parm[3] = {4, 2, 30};\n#define RESUME\t\t(acct_parm[0])\t \n#define SUSPEND\t\t(acct_parm[1])\t \n#define ACCT_TIMEOUT\t(acct_parm[2])\t \n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table kern_acct_table[] = {\n\t{\n\t\t.procname       = \"acct\",\n\t\t.data           = &acct_parm,\n\t\t.maxlen         = 3*sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic __init int kernel_acct_sysctls_init(void)\n{\n\tregister_sysctl_init(\"kernel\", kern_acct_table);\n\treturn 0;\n}\nlate_initcall(kernel_acct_sysctls_init);\n#endif  \n\n \n\nstruct bsd_acct_struct {\n\tstruct fs_pin\t\tpin;\n\tatomic_long_t\t\tcount;\n\tstruct rcu_head\t\trcu;\n\tstruct mutex\t\tlock;\n\tint\t\t\tactive;\n\tunsigned long\t\tneedcheck;\n\tstruct file\t\t*file;\n\tstruct pid_namespace\t*ns;\n\tstruct work_struct\twork;\n\tstruct completion\tdone;\n};\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\n \nstatic int check_free_space(struct bsd_acct_struct *acct)\n{\n\tstruct kstatfs sbuf;\n\n\tif (time_is_after_jiffies(acct->needcheck))\n\t\tgoto out;\n\n\t \n\tif (vfs_statfs(&acct->file->f_path, &sbuf))\n\t\tgoto out;\n\n\tif (acct->active) {\n\t\tu64 suspend = sbuf.f_blocks * SUSPEND;\n\t\tdo_div(suspend, 100);\n\t\tif (sbuf.f_bavail <= suspend) {\n\t\t\tacct->active = 0;\n\t\t\tpr_info(\"Process accounting paused\\n\");\n\t\t}\n\t} else {\n\t\tu64 resume = sbuf.f_blocks * RESUME;\n\t\tdo_div(resume, 100);\n\t\tif (sbuf.f_bavail >= resume) {\n\t\t\tacct->active = 1;\n\t\t\tpr_info(\"Process accounting resumed\\n\");\n\t\t}\n\t}\n\n\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\nout:\n\treturn acct->active;\n}\n\nstatic void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}\n\nstatic inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}\n\nstatic struct bsd_acct_struct *acct_get(struct pid_namespace *ns)\n{\n\tstruct bsd_acct_struct *res;\nagain:\n\tsmp_rmb();\n\trcu_read_lock();\n\tres = to_acct(READ_ONCE(ns->bacct));\n\tif (!res) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tif (!atomic_long_inc_not_zero(&res->count)) {\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock(&res->lock);\n\tif (res != to_acct(READ_ONCE(ns->bacct))) {\n\t\tmutex_unlock(&res->lock);\n\t\tacct_put(res);\n\t\tgoto again;\n\t}\n\treturn res;\n}\n\nstatic void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}\n\nstatic void close_work(struct work_struct *work)\n{\n\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);\n\tstruct file *file = acct->file;\n\tif (file->f_op->flush)\n\t\tfile->f_op->flush(file, NULL);\n\t__fput_sync(file);\n\tcomplete(&acct->done);\n}\n\nstatic int acct_on(struct filename *pathname)\n{\n\tstruct file *file;\n\tstruct vfsmount *mnt, *internal;\n\tstruct pid_namespace *ns = task_active_pid_ns(current);\n\tstruct bsd_acct_struct *acct;\n\tstruct fs_pin *old;\n\tint err;\n\n\tacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);\n\tif (!acct)\n\t\treturn -ENOMEM;\n\n\t \n\tfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);\n\tif (IS_ERR(file)) {\n\t\tkfree(acct);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tif (!S_ISREG(file_inode(file)->i_mode)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn -EACCES;\n\t}\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn -EIO;\n\t}\n\tinternal = mnt_clone_internal(&file->f_path);\n\tif (IS_ERR(internal)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn PTR_ERR(internal);\n\t}\n\terr = __mnt_want_write(internal);\n\tif (err) {\n\t\tmntput(internal);\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn err;\n\t}\n\tmnt = file->f_path.mnt;\n\tfile->f_path.mnt = internal;\n\n\tatomic_long_set(&acct->count, 1);\n\tinit_fs_pin(&acct->pin, acct_pin_kill);\n\tacct->file = file;\n\tacct->needcheck = jiffies;\n\tacct->ns = ns;\n\tmutex_init(&acct->lock);\n\tINIT_WORK(&acct->work, close_work);\n\tinit_completion(&acct->done);\n\tmutex_lock_nested(&acct->lock, 1);\t \n\tpin_insert(&acct->pin, mnt);\n\n\trcu_read_lock();\n\told = xchg(&ns->bacct, &acct->pin);\n\tmutex_unlock(&acct->lock);\n\tpin_kill(old);\n\t__mnt_drop_write(mnt);\n\tmntput(mnt);\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(acct_on_mutex);\n\n \nSYSCALL_DEFINE1(acct, const char __user *, name)\n{\n\tint error = 0;\n\n\tif (!capable(CAP_SYS_PACCT))\n\t\treturn -EPERM;\n\n\tif (name) {\n\t\tstruct filename *tmp = getname(name);\n\n\t\tif (IS_ERR(tmp))\n\t\t\treturn PTR_ERR(tmp);\n\t\tmutex_lock(&acct_on_mutex);\n\t\terror = acct_on(tmp);\n\t\tmutex_unlock(&acct_on_mutex);\n\t\tputname(tmp);\n\t} else {\n\t\trcu_read_lock();\n\t\tpin_kill(task_active_pid_ns(current)->bacct);\n\t}\n\n\treturn error;\n}\n\nvoid acct_exit_ns(struct pid_namespace *ns)\n{\n\trcu_read_lock();\n\tpin_kill(ns->bacct);\n}\n\n \n\n#define\tMANTSIZE\t13\t\t\t \n#define\tEXPSIZE\t\t3\t\t\t \n#define\tMAXFRACT\t((1 << MANTSIZE) - 1)\t \n\nstatic comp_t encode_comp_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value > MAXFRACT) {\n\t\trnd = value & (1 << (EXPSIZE - 1));\t \n\t\tvalue >>= EXPSIZE;\t \n\t\texp++;\n\t}\n\n\t \n\tif (rnd && (++value > MAXFRACT)) {\n\t\tvalue >>= EXPSIZE;\n\t\texp++;\n\t}\n\n\tif (exp > (((comp_t) ~0U) >> MANTSIZE))\n\t\treturn (comp_t) ~0U;\n\t \n\texp <<= MANTSIZE;\t\t \n\texp += value;\t\t\t \n\treturn exp;\n}\n\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n \n\n#define MANTSIZE2       20                       \n#define EXPSIZE2        5                        \n#define MAXFRACT2       ((1ul << MANTSIZE2) - 1)  \n#define MAXEXP2         ((1 << EXPSIZE2) - 1)     \n\nstatic comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value > (MAXFRACT2>>1));\n\trnd = 0;\n\twhile (value > MAXFRACT2) {\n\t\trnd = value & 1;\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\t \n\tif (rnd && (++value > MAXFRACT2)) {\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\tif (exp > MAXEXP2) {\n\t\t \n\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\n\t} else {\n\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\n\t}\n}\n#elif ACCT_VERSION == 3\n \nstatic u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value > 0) {\n\t\tvalue <<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >> 40) & 0x7fffffu;\n\treturn u | (exp << 23);\n}\n#endif\n\n \n\nstatic void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 elapsed, run_time;\n\ttime64_t btime;\n\tstruct tty_struct *tty;\n\n\t \n\tmemset(ac, 0, sizeof(acct_t));\n\n\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;\n\tstrscpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));\n\n\t \n\trun_time = ktime_get_ns();\n\trun_time -= current->group_leader->start_time;\n\t \n\telapsed = nsec_to_AHZ(run_time);\n#if ACCT_VERSION == 3\n\tac->ac_etime = encode_float(elapsed);\n#else\n\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t{\n\t\t \n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->ac_etime_hi = etime >> 16;\n\t\tac->ac_etime_lo = (u16) etime;\n\t}\n#endif\n\tdo_div(elapsed, AHZ);\n\tbtime = ktime_get_real_seconds() - elapsed;\n\tac->ac_btime = clamp_t(time64_t, btime, 0, U32_MAX);\n#if ACCT_VERSION == 2\n\tac->ac_ahz = AHZ;\n#endif\n\n\tspin_lock_irq(&current->sighand->siglock);\n\ttty = current->signal->tty;\t \n\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\n\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));\n\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));\n\tac->ac_flag = pacct->ac_flag;\n\tac->ac_mem = encode_comp_t(pacct->ac_mem);\n\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);\n\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);\n\tac->ac_exitcode = pacct->ac_exitcode;\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n \nstatic void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t \n\tflim = rlimit(RLIMIT_FSIZE);\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t \n\torig_cred = override_creds(file->f_cred);\n\n\t \n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t \n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t \n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#elif ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t \n\tif (file_start_write_trylock(file)) {\n\t\t \n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}\n\n \nvoid acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct mm_struct *mm = current->mm;\n\t\tVMA_ITERATOR(vmi, mm, 0);\n\t\tstruct vm_area_struct *vma;\n\n\t\tmmap_read_lock(mm);\n\t\tfor_each_vma(vmi, vma)\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\tmmap_read_unlock(mm);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}\n\nstatic void slow_acct_process(struct pid_namespace *ns)\n{\n\tfor ( ; ns; ns = ns->parent) {\n\t\tstruct bsd_acct_struct *acct = acct_get(ns);\n\t\tif (acct) {\n\t\t\tdo_acct_process(acct);\n\t\t\tmutex_unlock(&acct->lock);\n\t\t\tacct_put(acct);\n\t\t}\n\t}\n}\n\n \nvoid acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t \n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}