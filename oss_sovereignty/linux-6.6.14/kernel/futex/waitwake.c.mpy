{
  "module_name": "waitwake.c",
  "hash_id": "9b693feadad971186a51b1d461b4caedc3d2b51b6e12bffc0634b515e7f1d129",
  "original_prompt": "Ingested from linux-6.6.14/kernel/futex/waitwake.c",
  "human_readable_source": "\n\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/freezer.h>\n\n#include \"futex.h\"\n\n \n\n \nvoid futex_wake_mark(struct wake_q_head *wake_q, struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\tget_task_struct(p);\n\t__futex_unqueue(q);\n\t \n\tsmp_store_release(&q->lock_ptr, NULL);\n\n\t \n\twake_q_add_safe(wake_q, p);\n}\n\n \nint futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tint ret;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, FUTEX_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\thb = futex_hash(&key);\n\n\t \n\tif (!futex_hb_waiters_pending(hb))\n\t\treturn ret;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (futex_match (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\tfutex_wake_mark(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\n\twake_up_q(&wake_q);\n\treturn ret;\n}\n\nstatic int futex_atomic_op_inuser(unsigned int encoded_op, u32 __user *uaddr)\n{\n\tunsigned int op =\t  (encoded_op & 0x70000000) >> 28;\n\tunsigned int cmp =\t  (encoded_op & 0x0f000000) >> 24;\n\tint oparg = sign_extend32((encoded_op & 0x00fff000) >> 12, 11);\n\tint cmparg = sign_extend32(encoded_op & 0x00000fff, 11);\n\tint oldval, ret;\n\n\tif (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28)) {\n\t\tif (oparg < 0 || oparg > 31) {\n\t\t\tchar comm[sizeof(current->comm)];\n\t\t\t \n\t\t\tpr_info_ratelimited(\"futex_wake_op: %s tries to shift op by %d; fix this program\\n\",\n\t\t\t\t\tget_task_comm(comm, current), oparg);\n\t\t\toparg &= 31;\n\t\t}\n\t\toparg = 1 << oparg;\n\t}\n\n\tpagefault_disable();\n\tret = arch_futex_atomic_op_inuser(op, oparg, &oldval, uaddr);\n\tpagefault_enable();\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (cmp) {\n\tcase FUTEX_OP_CMP_EQ:\n\t\treturn oldval == cmparg;\n\tcase FUTEX_OP_CMP_NE:\n\t\treturn oldval != cmparg;\n\tcase FUTEX_OP_CMP_LT:\n\t\treturn oldval < cmparg;\n\tcase FUTEX_OP_CMP_GE:\n\t\treturn oldval >= cmparg;\n\tcase FUTEX_OP_CMP_LE:\n\t\treturn oldval <= cmparg;\n\tcase FUTEX_OP_CMP_GT:\n\t\treturn oldval > cmparg;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\n \nint futex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t\t  int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\tDEFINE_WAKE_Q(wake_q);\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, FUTEX_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, FUTEX_WRITE);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\thb1 = futex_hash(&key1);\n\thb2 = futex_hash(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\t\tdouble_unlock_hb(hb1, hb2);\n\n\t\tif (!IS_ENABLED(CONFIG_MMU) ||\n\t\t    unlikely(op_ret != -EFAULT && op_ret != -EAGAIN)) {\n\t\t\t \n\t\t\tret = op_ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (op_ret == -EFAULT) {\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (futex_match (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfutex_wake_mark(&wake_q, this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (futex_match (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tfutex_wake_mark(&wake_q, this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\treturn ret;\n}\n\nstatic long futex_wait_restart(struct restart_block *restart);\n\n \nvoid futex_wait_queue(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t    struct hrtimer_sleeper *timeout)\n{\n\t \n\tset_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);\n\tfutex_queue(q, hb);\n\n\t \n\tif (timeout)\n\t\thrtimer_sleeper_start_expires(timeout, HRTIMER_MODE_ABS);\n\n\t \n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t \n\t\tif (!timeout || timeout->task)\n\t\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}\n\n \nstatic int unqueue_multiple(struct futex_vector *v, int count)\n{\n\tint ret = -1, i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!futex_unqueue(&v[i].q))\n\t\t\tret = i;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int futex_wait_multiple_setup(struct futex_vector *vs, int count, int *woken)\n{\n\tstruct futex_hash_bucket *hb;\n\tbool retry = false;\n\tint ret, i;\n\tu32 uval;\n\n\t \nretry:\n\tfor (i = 0; i < count; i++) {\n\t\tif ((vs[i].w.flags & FUTEX_PRIVATE_FLAG) && retry)\n\t\t\tcontinue;\n\n\t\tret = get_futex_key(u64_to_user_ptr(vs[i].w.uaddr),\n\t\t\t\t    !(vs[i].w.flags & FUTEX_PRIVATE_FLAG),\n\t\t\t\t    &vs[i].q.key, FUTEX_READ);\n\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE|TASK_FREEZABLE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tu32 __user *uaddr = (u32 __user *)(unsigned long)vs[i].w.uaddr;\n\t\tstruct futex_q *q = &vs[i].q;\n\t\tu32 val = (u32)vs[i].w.val;\n\n\t\thb = futex_q_lock(q);\n\t\tret = futex_get_value_locked(&uval, uaddr);\n\n\t\tif (!ret && uval == val) {\n\t\t\t \n\t\t\tfutex_queue(q, hb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfutex_q_unlock(hb);\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\t \n\t\t*woken = unqueue_multiple(vs, i);\n\t\tif (*woken >= 0)\n\t\t\treturn 1;\n\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (get_user(uval, uaddr))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tretry = true;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (uval != val)\n\t\t\treturn -EWOULDBLOCK;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void futex_sleep_multiple(struct futex_vector *vs, unsigned int count,\n\t\t\t\t struct hrtimer_sleeper *to)\n{\n\tif (to && !to->task)\n\t\treturn;\n\n\tfor (; count; count--, vs++) {\n\t\tif (!READ_ONCE(vs->q.lock_ptr))\n\t\t\treturn;\n\t}\n\n\tschedule();\n}\n\n \nint futex_wait_multiple(struct futex_vector *vs, unsigned int count,\n\t\t\tstruct hrtimer_sleeper *to)\n{\n\tint ret, hint = 0;\n\n\tif (to)\n\t\thrtimer_sleeper_start_expires(to, HRTIMER_MODE_ABS);\n\n\twhile (1) {\n\t\tret = futex_wait_multiple_setup(vs, count, &hint);\n\t\tif (ret) {\n\t\t\tif (ret > 0) {\n\t\t\t\t \n\t\t\t\tret = hint;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tfutex_sleep_multiple(vs, count, to);\n\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\tret = unqueue_multiple(vs, count);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\n\t\tif (to && !to->task)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t\t \n\t}\n}\n\n \nint futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t     struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t \nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q->key, FUTEX_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = futex_q_lock(q);\n\n\tret = futex_get_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tfutex_q_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(flags & FLAGS_SHARED))\n\t\t\tgoto retry_private;\n\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tfutex_q_unlock(*hb);\n\t\tret = -EWOULDBLOCK;\n\t}\n\n\treturn ret;\n}\n\nint futex_wait(u32 __user *uaddr, unsigned int flags, u32 val, ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.bitset = bitset;\n\n\tto = futex_setup_timer(abs_time, &timeout, flags,\n\t\t\t       current->timer_slack_ns);\nretry:\n\t \n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tfutex_wait_queue(hb, &q, to);\n\n\t \n\tret = 0;\n\tif (!futex_unqueue(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t \n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = *abs_time;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | FLAGS_HAS_TIMEOUT;\n\n\tret = set_restart_fn(restart, futex_wait_restart);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n\nstatic long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}