{
  "module_name": "futex.h",
  "hash_id": "59a6fbb12487296f50927b1d826b7c66663a5a17efa63c6117455faaf37d792b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/futex/futex.h",
  "human_readable_source": " \n#ifndef _FUTEX_H\n#define _FUTEX_H\n\n#include <linux/futex.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/wake_q.h>\n\n#ifdef CONFIG_PREEMPT_RT\n#include <linux/rcuwait.h>\n#endif\n\n#include <asm/futex.h>\n\n \n#ifdef CONFIG_MMU\n# define FLAGS_SHARED\t\t0x01\n#else\n \n# define FLAGS_SHARED\t\t0x00\n#endif\n#define FLAGS_CLOCKRT\t\t0x02\n#define FLAGS_HAS_TIMEOUT\t0x04\n\n#ifdef CONFIG_FAIL_FUTEX\nextern bool should_fail_futex(bool fshared);\n#else\nstatic inline bool should_fail_futex(bool fshared)\n{\n\treturn false;\n}\n#endif\n\n \nstruct futex_hash_bucket {\n\tatomic_t waiters;\n\tspinlock_t lock;\n\tstruct plist_head chain;\n} ____cacheline_aligned_in_smp;\n\n \nstruct futex_pi_state {\n\t \n\tstruct list_head list;\n\n\t \n\tstruct rt_mutex_base pi_mutex;\n\n\tstruct task_struct *owner;\n\trefcount_t refcount;\n\n\tunion futex_key key;\n} __randomize_layout;\n\n \nstruct futex_q {\n\tstruct plist_node list;\n\n\tstruct task_struct *task;\n\tspinlock_t *lock_ptr;\n\tunion futex_key key;\n\tstruct futex_pi_state *pi_state;\n\tstruct rt_mutex_waiter *rt_waiter;\n\tunion futex_key *requeue_pi_key;\n\tu32 bitset;\n\tatomic_t requeue_state;\n#ifdef CONFIG_PREEMPT_RT\n\tstruct rcuwait requeue_wait;\n#endif\n} __randomize_layout;\n\nextern const struct futex_q futex_q_init;\n\nenum futex_access {\n\tFUTEX_READ,\n\tFUTEX_WRITE\n};\n\nextern int get_futex_key(u32 __user *uaddr, bool fshared, union futex_key *key,\n\t\t\t enum futex_access rw);\n\nextern struct hrtimer_sleeper *\nfutex_setup_timer(ktime_t *time, struct hrtimer_sleeper *timeout,\n\t\t  int flags, u64 range_ns);\n\nextern struct futex_hash_bucket *futex_hash(union futex_key *key);\n\n \nstatic inline int futex_match(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}\n\nextern int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t    struct futex_q *q, struct futex_hash_bucket **hb);\nextern void futex_wait_queue(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\t   struct hrtimer_sleeper *timeout);\nextern void futex_wake_mark(struct wake_q_head *wake_q, struct futex_q *q);\n\nextern int fault_in_user_writeable(u32 __user *uaddr);\nextern int futex_cmpxchg_value_locked(u32 *curval, u32 __user *uaddr, u32 uval, u32 newval);\nextern int futex_get_value_locked(u32 *dest, u32 __user *from);\nextern struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb, union futex_key *key);\n\nextern void __futex_unqueue(struct futex_q *q);\nextern void __futex_queue(struct futex_q *q, struct futex_hash_bucket *hb);\nextern int futex_unqueue(struct futex_q *q);\n\n \nstatic inline void futex_queue(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\t__futex_queue(q, hb);\n\tspin_unlock(&hb->lock);\n}\n\nextern void futex_unqueue_pi(struct futex_q *q);\n\nextern void wait_for_owner_exiting(int ret, struct task_struct *exiting);\n\n \nstatic inline void futex_hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_inc(&hb->waiters);\n\t \n\tsmp_mb__after_atomic();\n#endif\n}\n\n \nstatic inline void futex_hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\tatomic_dec(&hb->waiters);\n#endif\n}\n\nstatic inline int futex_hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef CONFIG_SMP\n\t \n\tsmp_mb();\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}\n\nextern struct futex_hash_bucket *futex_q_lock(struct futex_q *q);\nextern void futex_q_unlock(struct futex_hash_bucket *hb);\n\n\nextern int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task,\n\t\t\t\tstruct task_struct **exiting,\n\t\t\t\tint set_waiters);\n\nextern int refill_pi_state_cache(void);\nextern void get_pi_state(struct futex_pi_state *pi_state);\nextern void put_pi_state(struct futex_pi_state *pi_state);\nextern int fixup_pi_owner(u32 __user *uaddr, struct futex_q *q, int locked);\n\n \nstatic inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 > hb2)\n\t\tswap(hb1, hb2);\n\n\tspin_lock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_lock_nested(&hb2->lock, SINGLE_DEPTH_NESTING);\n}\n\nstatic inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}\n\n \n\nextern int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags, u32\n\t\t\t\t val, ktime_t *abs_time, u32 bitset, u32 __user\n\t\t\t\t *uaddr2);\n\nextern int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi);\n\nextern int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset);\n\n \nstruct futex_vector {\n\tstruct futex_waitv w;\n\tstruct futex_q q;\n};\n\nextern int futex_wait_multiple(struct futex_vector *vs, unsigned int count,\n\t\t\t       struct hrtimer_sleeper *to);\n\nextern int futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset);\n\nextern int futex_wake_op(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_wake2, int op);\n\nextern int futex_unlock_pi(u32 __user *uaddr, unsigned int flags);\n\nextern int futex_lock_pi(u32 __user *uaddr, unsigned int flags, ktime_t *time, int trylock);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}