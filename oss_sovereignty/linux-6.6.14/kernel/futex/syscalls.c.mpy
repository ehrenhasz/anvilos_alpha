{
  "module_name": "syscalls.c",
  "hash_id": "f967197a4663cd00659ff23fa9efaeb60055d5f98606ca53f38da8e8bc1f3f1a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/futex/syscalls.c",
  "human_readable_source": "\n\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/time_namespace.h>\n\n#include \"futex.h\"\n\n \n\n \nSYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head,\n\t\tsize_t, len)\n{\n\t \n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -EINVAL;\n\n\tcurrent->robust_list = head;\n\n\treturn 0;\n}\n\n \nSYSCALL_DEFINE3(get_robust_list, int, pid,\n\t\tstruct robust_list_head __user * __user *, head_ptr,\n\t\tsize_t __user *, len_ptr)\n{\n\tstruct robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -EPERM;\n\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto err_unlock;\n\n\thead = p->robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -EFAULT;\n\treturn put_user(head, head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nlong do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,\n\t\tu32 __user *uaddr2, u32 val2, u32 val3)\n{\n\tint cmd = op & FUTEX_CMD_MASK;\n\tunsigned int flags = 0;\n\n\tif (!(op & FUTEX_PRIVATE_FLAG))\n\t\tflags |= FLAGS_SHARED;\n\n\tif (op & FUTEX_CLOCK_REALTIME) {\n\t\tflags |= FLAGS_CLOCKRT;\n\t\tif (cmd != FUTEX_WAIT_BITSET && cmd != FUTEX_WAIT_REQUEUE_PI &&\n\t\t    cmd != FUTEX_LOCK_PI2)\n\t\t\treturn -ENOSYS;\n\t}\n\n\tswitch (cmd) {\n\tcase FUTEX_WAIT:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\tfallthrough;\n\tcase FUTEX_WAIT_BITSET:\n\t\treturn futex_wait(uaddr, flags, val, timeout, val3);\n\tcase FUTEX_WAKE:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\tfallthrough;\n\tcase FUTEX_WAKE_BITSET:\n\t\treturn futex_wake(uaddr, flags, val, val3);\n\tcase FUTEX_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0);\n\tcase FUTEX_CMP_REQUEUE:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 0);\n\tcase FUTEX_WAKE_OP:\n\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);\n\tcase FUTEX_LOCK_PI:\n\t\tflags |= FLAGS_CLOCKRT;\n\t\tfallthrough;\n\tcase FUTEX_LOCK_PI2:\n\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);\n\tcase FUTEX_UNLOCK_PI:\n\t\treturn futex_unlock_pi(uaddr, flags);\n\tcase FUTEX_TRYLOCK_PI:\n\t\treturn futex_lock_pi(uaddr, flags, NULL, 1);\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\t\tval3 = FUTEX_BITSET_MATCH_ANY;\n\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,\n\t\t\t\t\t     uaddr2);\n\tcase FUTEX_CMP_REQUEUE_PI:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 1);\n\t}\n\treturn -ENOSYS;\n}\n\nstatic __always_inline bool futex_cmd_has_timeout(u32 cmd)\n{\n\tswitch (cmd) {\n\tcase FUTEX_WAIT:\n\tcase FUTEX_LOCK_PI:\n\tcase FUTEX_LOCK_PI2:\n\tcase FUTEX_WAIT_BITSET:\n\tcase FUTEX_WAIT_REQUEUE_PI:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic __always_inline int\nfutex_init_timeout(u32 cmd, u32 op, struct timespec64 *ts, ktime_t *t)\n{\n\tif (!timespec64_valid(ts))\n\t\treturn -EINVAL;\n\n\t*t = timespec64_to_ktime(*ts);\n\tif (cmd == FUTEX_WAIT)\n\t\t*t = ktime_add_safe(ktime_get(), *t);\n\telse if (cmd != FUTEX_LOCK_PI && !(op & FUTEX_CLOCK_REALTIME))\n\t\t*t = timens_ktime_to_host(CLOCK_MONOTONIC, *t);\n\treturn 0;\n}\n\nSYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tconst struct __kernel_timespec __user *, utime,\n\t\tu32 __user *, uaddr2, u32, val3)\n{\n\tint ret, cmd = op & FUTEX_CMD_MASK;\n\tktime_t t, *tp = NULL;\n\tstruct timespec64 ts;\n\n\tif (utime && futex_cmd_has_timeout(cmd)) {\n\t\tif (unlikely(should_fail_futex(!(op & FUTEX_PRIVATE_FLAG))))\n\t\t\treturn -EFAULT;\n\t\tif (get_timespec64(&ts, utime))\n\t\t\treturn -EFAULT;\n\t\tret = futex_init_timeout(cmd, op, &ts, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttp = &t;\n\t}\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, (unsigned long)utime, val3);\n}\n\n \n#define FUTEXV_WAITER_MASK (FUTEX_32 | FUTEX_PRIVATE_FLAG)\n\n \nstatic int futex_parse_waitv(struct futex_vector *futexv,\n\t\t\t     struct futex_waitv __user *uwaitv,\n\t\t\t     unsigned int nr_futexes)\n{\n\tstruct futex_waitv aux;\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_futexes; i++) {\n\t\tif (copy_from_user(&aux, &uwaitv[i], sizeof(aux)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((aux.flags & ~FUTEXV_WAITER_MASK) || aux.__reserved)\n\t\t\treturn -EINVAL;\n\n\t\tif (!(aux.flags & FUTEX_32))\n\t\t\treturn -EINVAL;\n\n\t\tfutexv[i].w.flags = aux.flags;\n\t\tfutexv[i].w.val = aux.val;\n\t\tfutexv[i].w.uaddr = aux.uaddr;\n\t\tfutexv[i].q = futex_q_init;\n\t}\n\n\treturn 0;\n}\n\n \n\nSYSCALL_DEFINE5(futex_waitv, struct futex_waitv __user *, waiters,\n\t\tunsigned int, nr_futexes, unsigned int, flags,\n\t\tstruct __kernel_timespec __user *, timeout, clockid_t, clockid)\n{\n\tstruct hrtimer_sleeper to;\n\tstruct futex_vector *futexv;\n\tstruct timespec64 ts;\n\tktime_t time;\n\tint ret;\n\n\t \n\tif (flags)\n\t\treturn -EINVAL;\n\n\tif (!nr_futexes || nr_futexes > FUTEX_WAITV_MAX || !waiters)\n\t\treturn -EINVAL;\n\n\tif (timeout) {\n\t\tint flag_clkid = 0, flag_init = 0;\n\n\t\tif (clockid == CLOCK_REALTIME) {\n\t\t\tflag_clkid = FLAGS_CLOCKRT;\n\t\t\tflag_init = FUTEX_CLOCK_REALTIME;\n\t\t}\n\n\t\tif (clockid != CLOCK_REALTIME && clockid != CLOCK_MONOTONIC)\n\t\t\treturn -EINVAL;\n\n\t\tif (get_timespec64(&ts, timeout))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tret = futex_init_timeout(FUTEX_WAIT_BITSET, flag_init, &ts, &time);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfutex_setup_timer(&time, &to, flag_clkid, 0);\n\t}\n\n\tfutexv = kcalloc(nr_futexes, sizeof(*futexv), GFP_KERNEL);\n\tif (!futexv) {\n\t\tret = -ENOMEM;\n\t\tgoto destroy_timer;\n\t}\n\n\tret = futex_parse_waitv(futexv, waiters, nr_futexes);\n\tif (!ret)\n\t\tret = futex_wait_multiple(futexv, nr_futexes, timeout ? &to : NULL);\n\n\tkfree(futexv);\n\ndestroy_timer:\n\tif (timeout) {\n\t\thrtimer_cancel(&to.timer);\n\t\tdestroy_hrtimer_on_stack(&to.timer);\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(set_robust_list,\n\t\tstruct compat_robust_list_head __user *, head,\n\t\tcompat_size_t, len)\n{\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -EINVAL;\n\n\tcurrent->compat_robust_list = head;\n\n\treturn 0;\n}\n\nCOMPAT_SYSCALL_DEFINE3(get_robust_list, int, pid,\n\t\t\tcompat_uptr_t __user *, head_ptr,\n\t\t\tcompat_size_t __user *, len_ptr)\n{\n\tstruct compat_robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -EPERM;\n\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto err_unlock;\n\n\thead = p->compat_robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -EFAULT;\n\treturn put_user(ptr_to_compat(head), head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nSYSCALL_DEFINE6(futex_time32, u32 __user *, uaddr, int, op, u32, val,\n\t\tconst struct old_timespec32 __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tint ret, cmd = op & FUTEX_CMD_MASK;\n\tktime_t t, *tp = NULL;\n\tstruct timespec64 ts;\n\n\tif (utime && futex_cmd_has_timeout(cmd)) {\n\t\tif (get_old_timespec32(&ts, utime))\n\t\t\treturn -EFAULT;\n\t\tret = futex_init_timeout(cmd, op, &ts, &t);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttp = &t;\n\t}\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, (unsigned long)utime, val3);\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}