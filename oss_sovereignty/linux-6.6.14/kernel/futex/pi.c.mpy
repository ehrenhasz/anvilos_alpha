{
  "module_name": "pi.c",
  "hash_id": "256700a3afa58d94a510271e7cd20a1cb6baab3f7e052e152e45a2879ce96e3f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/futex/pi.c",
  "human_readable_source": "\n\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n\n#include \"futex.h\"\n#include \"../locking/rtmutex_common.h\"\n\n \nint refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), GFP_KERNEL);\n\n\tif (!pi_state)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pi_state->list);\n\t \n\tpi_state->owner = NULL;\n\trefcount_set(&pi_state->refcount, 1);\n\tpi_state->key = FUTEX_KEY_INIT;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}\n\nstatic struct futex_pi_state *alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\tWARN_ON(!pi_state);\n\tcurrent->pi_state_cache = NULL;\n\n\treturn pi_state;\n}\n\nstatic void pi_state_update_owner(struct futex_pi_state *pi_state,\n\t\t\t\t  struct task_struct *new_owner)\n{\n\tstruct task_struct *old_owner = pi_state->owner;\n\n\tlockdep_assert_held(&pi_state->pi_mutex.wait_lock);\n\n\tif (old_owner) {\n\t\traw_spin_lock(&old_owner->pi_lock);\n\t\tWARN_ON(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock(&old_owner->pi_lock);\n\t}\n\n\tif (new_owner) {\n\t\traw_spin_lock(&new_owner->pi_lock);\n\t\tWARN_ON(!list_empty(&pi_state->list));\n\t\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\t\tpi_state->owner = new_owner;\n\t\traw_spin_unlock(&new_owner->pi_lock);\n\t}\n}\n\nvoid get_pi_state(struct futex_pi_state *pi_state)\n{\n\tWARN_ON_ONCE(!refcount_inc_not_zero(&pi_state->refcount));\n}\n\n \nvoid put_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t \n\tif (pi_state->owner) {\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&pi_state->pi_mutex.wait_lock, flags);\n\t\tpi_state_update_owner(pi_state, NULL);\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex);\n\t\traw_spin_unlock_irqrestore(&pi_state->pi_mutex.wait_lock, flags);\n\t}\n\n\tif (current->pi_state_cache) {\n\t\tkfree(pi_state);\n\t} else {\n\t\t \n\t\tpi_state->owner = NULL;\n\t\trefcount_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}\n\n \n\n \nstatic int attach_to_pi_state(u32 __user *uaddr, u32 uval,\n\t\t\t      struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tu32 uval2;\n\tint ret;\n\n\t \n\tif (unlikely(!pi_state))\n\t\treturn -EINVAL;\n\n\t \n\tWARN_ON(!refcount_read(&pi_state->refcount));\n\n\t \n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t \n\tif (futex_get_value_locked(&uval2, uaddr))\n\t\tgoto out_efault;\n\n\tif (uval != uval2)\n\t\tgoto out_eagain;\n\n\t \n\tif (uval & FUTEX_OWNER_DIED) {\n\t\t \n\t\tif (!pi_state->owner) {\n\t\t\t \n\t\t\tif (pid)\n\t\t\t\tgoto out_einval;\n\t\t\t \n\t\t\tgoto out_attach;\n\t\t}\n\n\t\t \n\t\tif (!pid)\n\t\t\tgoto out_attach;\n\t} else {\n\t\t \n\t\tif (!pi_state->owner)\n\t\t\tgoto out_einval;\n\t}\n\n\t \n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\tgoto out_einval;\n\nout_attach:\n\tget_pi_state(pi_state);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\t*ps = pi_state;\n\treturn 0;\n\nout_einval:\n\tret = -EINVAL;\n\tgoto out_error;\n\nout_eagain:\n\tret = -EAGAIN;\n\tgoto out_error;\n\nout_efault:\n\tret = -EFAULT;\n\tgoto out_error;\n\nout_error:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}\n\nstatic int handle_exit_race(u32 __user *uaddr, u32 uval,\n\t\t\t    struct task_struct *tsk)\n{\n\tu32 uval2;\n\n\t \n\tif (tsk && tsk->futex_state != FUTEX_STATE_DEAD)\n\t\treturn -EBUSY;\n\n\t \n\tif (futex_get_value_locked(&uval2, uaddr))\n\t\treturn -EFAULT;\n\n\t \n\tif (uval2 != uval)\n\t\treturn -EAGAIN;\n\n\t \n\treturn -ESRCH;\n}\n\nstatic void __attach_to_pi_owner(struct task_struct *p, union futex_key *key,\n\t\t\t\t struct futex_pi_state **ps)\n{\n\t \n\tstruct futex_pi_state *pi_state = alloc_pi_state();\n\n\t \n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t \n\tpi_state->key = *key;\n\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\t \n\tpi_state->owner = p;\n\n\t*ps = pi_state;\n}\n \nstatic int attach_to_pi_owner(u32 __user *uaddr, u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps,\n\t\t\t      struct task_struct **exiting)\n{\n\tpid_t pid = uval & FUTEX_TID_MASK;\n\tstruct task_struct *p;\n\n\t \n\tif (!pid)\n\t\treturn -EAGAIN;\n\tp = find_get_task_by_vpid(pid);\n\tif (!p)\n\t\treturn handle_exit_race(uaddr, uval, NULL);\n\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\tput_task_struct(p);\n\t\treturn -EPERM;\n\t}\n\n\t \n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->futex_state != FUTEX_STATE_OK)) {\n\t\t \n\t\tint ret = handle_exit_race(uaddr, uval, p);\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\t \n\t\tif (ret == -EBUSY)\n\t\t\t*exiting = p;\n\t\telse\n\t\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t__attach_to_pi_owner(p, key, ps);\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tint err;\n\tu32 curval;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\terr = futex_cmpxchg_value_locked(&curval, uaddr, uval, newval);\n\tif (unlikely(err))\n\t\treturn err;\n\n\t \n\treturn curval != uval ? -EAGAIN : 0;\n}\n\n \nint futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t union futex_key *key,\n\t\t\t struct futex_pi_state **ps,\n\t\t\t struct task_struct *task,\n\t\t\t struct task_struct **exiting,\n\t\t\t int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\t \n\tif (futex_get_value_locked(&uval, uaddr))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t \n\tif ((unlikely((uval & FUTEX_TID_MASK) == vpid)))\n\t\treturn -EDEADLK;\n\n\tif ((unlikely(should_fail_futex(true))))\n\t\treturn -EDEADLK;\n\n\t \n\ttop_waiter = futex_top_waiter(hb, key);\n\tif (top_waiter)\n\t\treturn attach_to_pi_state(uaddr, uval, top_waiter->pi_state, ps);\n\n\t \n\tif (!(uval & FUTEX_TID_MASK)) {\n\t\t \n\t\tnewval = uval & FUTEX_OWNER_DIED;\n\t\tnewval |= vpid;\n\n\t\t \n\t\tif (set_waiters)\n\t\t\tnewval |= FUTEX_WAITERS;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (set_waiters) {\n\t\t\traw_spin_lock_irq(&task->pi_lock);\n\t\t\t__attach_to_pi_owner(task, key, ps);\n\t\t\traw_spin_unlock_irq(&task->pi_lock);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tnewval = uval | FUTEX_WAITERS;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t \n\treturn attach_to_pi_owner(uaddr, newval, key, ps, exiting);\n}\n\n \nstatic int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_pi_state *pi_state)\n{\n\tstruct rt_mutex_waiter *top_waiter;\n\tstruct task_struct *new_owner;\n\tbool postunlock = false;\n\tDEFINE_RT_WAKE_Q(wqh);\n\tu32 curval, newval;\n\tint ret = 0;\n\n\ttop_waiter = rt_mutex_top_waiter(&pi_state->pi_mutex);\n\tif (WARN_ON_ONCE(!top_waiter)) {\n\t\t \n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tnew_owner = top_waiter->task;\n\n\t \n\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\tif (unlikely(should_fail_futex(true))) {\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tret = futex_cmpxchg_value_locked(&curval, uaddr, uval, newval);\n\tif (!ret && (curval != uval)) {\n\t\t \n\t\tif ((FUTEX_TID_MASK & curval) == uval)\n\t\t\tret = -EAGAIN;\n\t\telse\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tpi_state_update_owner(pi_state, new_owner);\n\t\tpostunlock = __rt_mutex_futex_unlock(&pi_state->pi_mutex, &wqh);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\n\tif (postunlock)\n\t\trt_mutex_postunlock(&wqh);\n\n\treturn ret;\n}\n\nstatic int __fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\t  struct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tstruct task_struct *oldowner, *newowner;\n\tu32 uval, curval, newval, newtid;\n\tint err = 0;\n\n\toldowner = pi_state->owner;\n\n\t \nretry:\n\tif (!argowner) {\n\t\tif (oldowner != current) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tif (__rt_mutex_futex_trylock(&pi_state->pi_mutex)) {\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tnewowner = rt_mutex_owner(&pi_state->pi_mutex);\n\t\t \n\t\tif (unlikely(!newowner)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto handle_err;\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(argowner != current);\n\t\tif (oldowner == current) {\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t\tnewowner = argowner;\n\t}\n\n\tnewtid = task_pid_vnr(newowner) | FUTEX_WAITERS;\n\t \n\tif (!pi_state->owner)\n\t\tnewtid |= FUTEX_OWNER_DIED;\n\n\terr = futex_get_value_locked(&uval, uaddr);\n\tif (err)\n\t\tgoto handle_err;\n\n\tfor (;;) {\n\t\tnewval = (uval & FUTEX_OWNER_DIED) | newtid;\n\n\t\terr = futex_cmpxchg_value_locked(&curval, uaddr, uval, newval);\n\t\tif (err)\n\t\t\tgoto handle_err;\n\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t \n\tpi_state_update_owner(pi_state, newowner);\n\n\treturn argowner == current;\n\n\t \nhandle_err:\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q->lock_ptr);\n\n\tswitch (err) {\n\tcase -EFAULT:\n\t\terr = fault_in_user_writeable(uaddr);\n\t\tbreak;\n\n\tcase -EAGAIN:\n\t\tcond_resched();\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\tspin_lock(q->lock_ptr);\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\n\t \n\tif (pi_state->owner != oldowner)\n\t\treturn argowner == current;\n\n\t \n\tif (!err)\n\t\tgoto retry;\n\n\t \n\tpi_state_update_owner(pi_state, rt_mutex_owner(&pi_state->pi_mutex));\n\n\treturn err;\n}\n\nstatic int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *argowner)\n{\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tint ret;\n\n\tlockdep_assert_held(q->lock_ptr);\n\n\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\tret = __fixup_pi_state_owner(uaddr, q, argowner);\n\traw_spin_unlock_irq(&pi_state->pi_mutex.wait_lock);\n\treturn ret;\n}\n\n \nint fixup_pi_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tif (locked) {\n\t\t \n\t\tif (q->pi_state->owner != current)\n\t\t\treturn fixup_pi_state_owner(uaddr, q, current);\n\t\treturn 1;\n\t}\n\n\t \n\tif (q->pi_state->owner == current)\n\t\treturn fixup_pi_state_owner(uaddr, q, NULL);\n\n\t \n\tif (WARN_ON_ONCE(rt_mutex_owner(&q->pi_state->pi_mutex) == current))\n\t\treturn fixup_pi_state_owner(uaddr, q, current);\n\n\treturn 0;\n}\n\n \nint futex_lock_pi(u32 __user *uaddr, unsigned int flags, ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to;\n\tstruct task_struct *exiting = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tto = futex_setup_timer(time, &timeout, flags, 0);\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, FUTEX_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = futex_q_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current,\n\t\t\t\t   &exiting, 0);\n\tif (unlikely(ret)) {\n\t\t \n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EBUSY:\n\t\tcase -EAGAIN:\n\t\t\t \n\t\t\tfutex_q_unlock(hb);\n\t\t\t \n\t\t\twait_for_owner_exiting(ret, exiting);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\tWARN_ON(!q.pi_state);\n\n\t \n\t__futex_queue(&q, hb);\n\n\tif (trylock) {\n\t\tret = rt_mutex_futex_trylock(&q.pi_state->pi_mutex);\n\t\t \n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t\tgoto no_block;\n\t}\n\n\trt_mutex_init_waiter(&rt_waiter);\n\n\t \n\traw_spin_lock_irq(&q.pi_state->pi_mutex.wait_lock);\n\tspin_unlock(q.lock_ptr);\n\t \n\tret = __rt_mutex_start_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter, current);\n\traw_spin_unlock_irq(&q.pi_state->pi_mutex.wait_lock);\n\n\tif (ret) {\n\t\tif (ret == 1)\n\t\t\tret = 0;\n\t\tgoto cleanup;\n\t}\n\n\tif (unlikely(to))\n\t\thrtimer_sleeper_start_expires(to, HRTIMER_MODE_ABS);\n\n\tret = rt_mutex_wait_proxy_lock(&q.pi_state->pi_mutex, to, &rt_waiter);\n\ncleanup:\n\tspin_lock(q.lock_ptr);\n\t \n\tif (ret && !rt_mutex_cleanup_proxy_lock(&q.pi_state->pi_mutex, &rt_waiter))\n\t\tret = 0;\n\nno_block:\n\t \n\tres = fixup_pi_owner(uaddr, &q, !ret);\n\t \n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\tfutex_unqueue_pi(&q);\n\tspin_unlock(q.lock_ptr);\n\tgoto out;\n\nout_unlock_put_key:\n\tfutex_q_unlock(hb);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tfutex_q_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!(flags & FLAGS_SHARED))\n\t\tgoto retry_private;\n\n\tgoto retry;\n}\n\n \nint futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 curval, uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = FUTEX_KEY_INIT;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *top_waiter;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -EFAULT;\n\t \n\tif ((uval & FUTEX_TID_MASK) != vpid)\n\t\treturn -EPERM;\n\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, FUTEX_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\thb = futex_hash(&key);\n\tspin_lock(&hb->lock);\n\n\t \n\ttop_waiter = futex_top_waiter(hb, &key);\n\tif (top_waiter) {\n\t\tstruct futex_pi_state *pi_state = top_waiter->pi_state;\n\n\t\tret = -EINVAL;\n\t\tif (!pi_state)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (pi_state->owner != current)\n\t\t\tgoto out_unlock;\n\n\t\tget_pi_state(pi_state);\n\t\t \n\t\traw_spin_lock_irq(&pi_state->pi_mutex.wait_lock);\n\t\tspin_unlock(&hb->lock);\n\n\t\t \n\t\tret = wake_futex_pi(uaddr, uval, pi_state);\n\n\t\tput_pi_state(pi_state);\n\n\t\t \n\t\tif (!ret)\n\t\t\treturn ret;\n\t\t \n\t\tif (ret == -EFAULT)\n\t\t\tgoto pi_faulted;\n\t\t \n\t\tif (ret == -EAGAIN)\n\t\t\tgoto pi_retry;\n\t\t \n\t\treturn ret;\n\t}\n\n\t \n\tif ((ret = futex_cmpxchg_value_locked(&curval, uaddr, uval, 0))) {\n\t\tspin_unlock(&hb->lock);\n\t\tswitch (ret) {\n\t\tcase -EFAULT:\n\t\t\tgoto pi_faulted;\n\n\t\tcase -EAGAIN:\n\t\t\tgoto pi_retry;\n\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = (curval == uval) ? 0 : -EAGAIN;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\n\treturn ret;\n\npi_retry:\n\tcond_resched();\n\tgoto retry;\n\npi_faulted:\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}