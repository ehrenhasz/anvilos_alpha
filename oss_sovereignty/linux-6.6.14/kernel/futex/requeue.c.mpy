{
  "module_name": "requeue.c",
  "hash_id": "25284c497f6698ec4f3c825402ee94014525afdf7f17ac878fdd242068dedd7a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/futex/requeue.c",
  "human_readable_source": "\n\n#include <linux/sched/signal.h>\n\n#include \"futex.h\"\n#include \"../locking/rtmutex_common.h\"\n\n \nenum {\n\tQ_REQUEUE_PI_NONE\t\t=  0,\n\tQ_REQUEUE_PI_IGNORE,\n\tQ_REQUEUE_PI_IN_PROGRESS,\n\tQ_REQUEUE_PI_WAIT,\n\tQ_REQUEUE_PI_DONE,\n\tQ_REQUEUE_PI_LOCKED,\n};\n\nconst struct futex_q futex_q_init = {\n\t \n\t.key\t\t= FUTEX_KEY_INIT,\n\t.bitset\t\t= FUTEX_BITSET_MATCH_ANY,\n\t.requeue_state\t= ATOMIC_INIT(Q_REQUEUE_PI_NONE),\n};\n\n \nstatic inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t \n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\tfutex_hb_waiters_dec(hb1);\n\t\tfutex_hb_waiters_inc(hb2);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tq->key = *key2;\n}\n\nstatic inline bool futex_requeue_pi_prepare(struct futex_q *q,\n\t\t\t\t\t    struct futex_pi_state *pi_state)\n{\n\tint old, new;\n\n\t \n\told = atomic_read_acquire(&q->requeue_state);\n\tdo {\n\t\tif (old == Q_REQUEUE_PI_IGNORE)\n\t\t\treturn false;\n\n\t\t \n\t\tif (old != Q_REQUEUE_PI_NONE)\n\t\t\tbreak;\n\n\t\tnew = Q_REQUEUE_PI_IN_PROGRESS;\n\t} while (!atomic_try_cmpxchg(&q->requeue_state, &old, new));\n\n\tq->pi_state = pi_state;\n\treturn true;\n}\n\nstatic inline void futex_requeue_pi_complete(struct futex_q *q, int locked)\n{\n\tint old, new;\n\n\told = atomic_read_acquire(&q->requeue_state);\n\tdo {\n\t\tif (old == Q_REQUEUE_PI_IGNORE)\n\t\t\treturn;\n\n\t\tif (locked >= 0) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(old != Q_REQUEUE_PI_IN_PROGRESS &&\n\t\t\t\t     old != Q_REQUEUE_PI_WAIT);\n\t\t\tnew = Q_REQUEUE_PI_DONE + locked;\n\t\t} else if (old == Q_REQUEUE_PI_IN_PROGRESS) {\n\t\t\t \n\t\t\tnew = Q_REQUEUE_PI_NONE;\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON_ONCE(old != Q_REQUEUE_PI_WAIT);\n\t\t\tnew = Q_REQUEUE_PI_IGNORE;\n\t\t}\n\t} while (!atomic_try_cmpxchg(&q->requeue_state, &old, new));\n\n#ifdef CONFIG_PREEMPT_RT\n\t \n\tif (unlikely(old == Q_REQUEUE_PI_WAIT))\n\t\trcuwait_wake_up(&q->requeue_wait);\n#endif\n}\n\nstatic inline int futex_requeue_pi_wakeup_sync(struct futex_q *q)\n{\n\tint old, new;\n\n\told = atomic_read_acquire(&q->requeue_state);\n\tdo {\n\t\t \n\t\tif (old >= Q_REQUEUE_PI_DONE)\n\t\t\treturn old;\n\n\t\t \n\t\tnew = Q_REQUEUE_PI_WAIT;\n\t\tif (old == Q_REQUEUE_PI_NONE)\n\t\t\tnew = Q_REQUEUE_PI_IGNORE;\n\t} while (!atomic_try_cmpxchg(&q->requeue_state, &old, new));\n\n\t \n\tif (old == Q_REQUEUE_PI_IN_PROGRESS) {\n#ifdef CONFIG_PREEMPT_RT\n\t\trcuwait_wait_event(&q->requeue_wait,\n\t\t\t\t   atomic_read(&q->requeue_state) != Q_REQUEUE_PI_WAIT,\n\t\t\t\t   TASK_UNINTERRUPTIBLE);\n#else\n\t\t(void)atomic_cond_read_relaxed(&q->requeue_state, VAL != Q_REQUEUE_PI_WAIT);\n#endif\n\t}\n\n\t \n\treturn atomic_read(&q->requeue_state);\n}\n\n \nstatic inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tq->key = *key;\n\n\t__futex_unqueue(q);\n\n\tWARN_ON(!q->rt_waiter);\n\tq->rt_waiter = NULL;\n\n\tq->lock_ptr = &hb->lock;\n\n\t \n\tfutex_requeue_pi_complete(q, 1);\n\twake_up_state(q->task, TASK_NORMAL);\n}\n\n \nstatic int\nfutex_proxy_trylock_atomic(u32 __user *pifutex, struct futex_hash_bucket *hb1,\n\t\t\t   struct futex_hash_bucket *hb2, union futex_key *key1,\n\t\t\t   union futex_key *key2, struct futex_pi_state **ps,\n\t\t\t   struct task_struct **exiting, int set_waiters)\n{\n\tstruct futex_q *top_waiter = NULL;\n\tu32 curval;\n\tint ret;\n\n\tif (futex_get_value_locked(&curval, pifutex))\n\t\treturn -EFAULT;\n\n\tif (unlikely(should_fail_futex(true)))\n\t\treturn -EFAULT;\n\n\t \n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t \n\tif (!top_waiter)\n\t\treturn 0;\n\n\t \n\tif (!top_waiter->rt_waiter || top_waiter->pi_state)\n\t\treturn -EINVAL;\n\n\t \n\tif (!futex_match(top_waiter->requeue_pi_key, key2))\n\t\treturn -EINVAL;\n\n\t \n\tif (!futex_requeue_pi_prepare(top_waiter, NULL))\n\t\treturn -EAGAIN;\n\n\t \n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   exiting, set_waiters);\n\tif (ret == 1) {\n\t\t \n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t} else if (ret < 0) {\n\t\t \n\t\tfutex_requeue_pi_complete(top_waiter, ret);\n\t} else {\n\t\t \n\t}\n\treturn ret;\n}\n\n \nint futex_requeue(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t\t  int nr_wake, int nr_requeue, u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (nr_wake < 0 || nr_requeue < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ENABLED(CONFIG_FUTEX_PI) && requeue_pi)\n\t\treturn -ENOSYS;\n\n\tif (requeue_pi) {\n\t\t \n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, FUTEX_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? FUTEX_WRITE : FUTEX_READ);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n\t \n\tif (requeue_pi && futex_match(&key1, &key2))\n\t\treturn -EINVAL;\n\n\thb1 = futex_hash(&key1);\n\thb2 = futex_hash(&key2);\n\nretry_private:\n\tfutex_hb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = futex_get_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\tfutex_hb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi) {\n\t\tstruct task_struct *exiting = NULL;\n\n\t\t \n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state,\n\t\t\t\t\t\t &exiting, nr_requeue);\n\n\t\t \n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t \n\t\t\ttask_count++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\n\t\t \n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\tfutex_hb_waiters_dec(hb2);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\treturn ret;\n\t\tcase -EBUSY:\n\t\tcase -EAGAIN:\n\t\t\t \n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\tfutex_hb_waiters_dec(hb2);\n\t\t\t \n\t\t\twait_for_owner_exiting(ret, exiting);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!futex_match(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!requeue_pi) {\n\t\t\tif (++task_count <= nr_wake)\n\t\t\t\tfutex_wake_mark(&wake_q, this);\n\t\t\telse\n\t\t\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!futex_match(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tget_pi_state(pi_state);\n\n\t\t \n\t\tif (!futex_requeue_pi_prepare(this, pi_state)) {\n\t\t\t \n\t\t\tput_pi_state(pi_state);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\tthis->task);\n\n\t\tif (ret == 1) {\n\t\t\t \n\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\ttask_count++;\n\t\t} else if (!ret) {\n\t\t\t \n\t\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\t\tfutex_requeue_pi_complete(this, 0);\n\t\t\ttask_count++;\n\t\t} else {\n\t\t\t \n\t\t\tthis->pi_state = NULL;\n\t\t\tput_pi_state(pi_state);\n\t\t\tfutex_requeue_pi_complete(this, ret);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tput_pi_state(pi_state);\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\twake_up_q(&wake_q);\n\tfutex_hb_waiters_dec(hb2);\n\treturn ret ? ret : task_count;\n}\n\n \nstatic inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret;\n\n\t \n\tWARN_ON_ONCE(&hb->lock != q->lock_ptr);\n\n\t \n\tplist_del(&q->list, &hb->chain);\n\tfutex_hb_waiters_dec(hb);\n\n\t \n\tret = -EWOULDBLOCK;\n\tif (timeout && !timeout->task)\n\t\tret = -ETIMEDOUT;\n\telse if (signal_pending(current))\n\t\tret = -ERESTARTNOINTR;\n\treturn ret;\n}\n\n \nint futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t  u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t  u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n\tstruct futex_q q = futex_q_init;\n\tstruct rt_mutex_base *pi_mutex;\n\tint res, ret;\n\n\tif (!IS_ENABLED(CONFIG_FUTEX_PI))\n\t\treturn -ENOSYS;\n\n\tif (uaddr == uaddr2)\n\t\treturn -EINVAL;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tto = futex_setup_timer(abs_time, &timeout, flags,\n\t\t\t       current->timer_slack_ns);\n\n\t \n\trt_mutex_init_waiter(&rt_waiter);\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, FUTEX_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t \n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (futex_match(&q.key, &key2)) {\n\t\tfutex_q_unlock(hb);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tfutex_wait_queue(hb, &q, to);\n\n\tswitch (futex_requeue_pi_wakeup_sync(&q)) {\n\tcase Q_REQUEUE_PI_IGNORE:\n\t\t \n\t\tspin_lock(&hb->lock);\n\t\tret = handle_early_requeue_pi_wakeup(hb, &q, to);\n\t\tspin_unlock(&hb->lock);\n\t\tbreak;\n\n\tcase Q_REQUEUE_PI_LOCKED:\n\t\t \n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_owner(uaddr2, &q, true);\n\t\t\t \n\t\t\tput_pi_state(q.pi_state);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t\t \n\t\t\tret = ret < 0 ? ret : 0;\n\t\t}\n\t\tbreak;\n\n\tcase Q_REQUEUE_PI_DONE:\n\t\t \n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_wait_proxy_lock(pi_mutex, to, &rt_waiter);\n\n\t\t \n\t\tspin_lock(q.lock_ptr);\n\t\tif (ret && !rt_mutex_cleanup_proxy_lock(pi_mutex, &rt_waiter))\n\t\t\tret = 0;\n\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\t\t \n\t\tres = fixup_pi_owner(uaddr2, &q, !ret);\n\t\t \n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\tfutex_unqueue_pi(&q);\n\t\tspin_unlock(q.lock_ptr);\n\n\t\tif (ret == -EINTR) {\n\t\t\t \n\t\t\tret = -EWOULDBLOCK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}