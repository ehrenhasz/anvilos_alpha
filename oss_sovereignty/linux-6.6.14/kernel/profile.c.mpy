{
  "module_name": "profile.c",
  "hash_id": "a8b656823a11841cacd1234ab9658e656b1c742bed9fc63c6415a3982aa18ca8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/profile.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/profile.h>\n#include <linux/memblock.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/highmem.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/stat.h>\n\n#include <asm/sections.h>\n#include <asm/irq_regs.h>\n#include <asm/ptrace.h>\n\nstruct profile_hit {\n\tu32 pc, hits;\n};\n#define PROFILE_GRPSHIFT\t3\n#define PROFILE_GRPSZ\t\t(1 << PROFILE_GRPSHIFT)\n#define NR_PROFILE_HIT\t\t(PAGE_SIZE/sizeof(struct profile_hit))\n#define NR_PROFILE_GRP\t\t(NR_PROFILE_HIT/PROFILE_GRPSZ)\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len;\nstatic unsigned short int prof_shift;\n\nint prof_on __read_mostly;\nEXPORT_SYMBOL_GPL(prof_on);\n\nstatic cpumask_var_t prof_cpu_mask;\n#if defined(CONFIG_SMP) && defined(CONFIG_PROC_FS)\nstatic DEFINE_PER_CPU(struct profile_hit *[2], cpu_profile_hits);\nstatic DEFINE_PER_CPU(int, cpu_profile_flip);\nstatic DEFINE_MUTEX(profile_flip_mutex);\n#endif  \n\nint profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tconst char *select = NULL;\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tforce_schedstat_enabled();\n\t\tprof_on = SLEEP_PROFILING;\n\t\tselect = sleepstr;\n#else\n\t\tpr_warn(\"kernel sleep profiling requires CONFIG_SCHEDSTATS\\n\");\n#endif  \n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = SCHED_PROFILING;\n\t\tselect = schedstr;\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = KVM_PROFILING;\n\t\tselect = kvmstr;\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tprof_on = CPU_PROFILING;\n\t\tpr_info(\"kernel profiling enabled (shift: %u)\\n\",\n\t\t\tprof_shift);\n\t}\n\n\tif (select) {\n\t\tif (str[strlen(select)] == ',')\n\t\t\tstr += strlen(select) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = clamp(par, 0, BITS_PER_LONG - 1);\n\t\tpr_info(\"kernel %s profiling enabled (shift: %u)\\n\",\n\t\t\tselect, prof_shift);\n\t}\n\n\treturn 1;\n}\n__setup(\"profile=\", profile_setup);\n\n\nint __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t \n\tprof_len = (_etext - _stext) >> prof_shift;\n\n\tif (!prof_len) {\n\t\tpr_warn(\"profiling shift: %u too large\\n\", prof_shift);\n\t\tprof_on = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer_bytes = prof_len*sizeof(atomic_t);\n\n\tif (!alloc_cpumask_var(&prof_cpu_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_copy(prof_cpu_mask, cpu_possible_mask);\n\n\tprof_buffer = kzalloc(buffer_bytes, GFP_KERNEL|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = alloc_pages_exact(buffer_bytes,\n\t\t\t\t\tGFP_KERNEL|__GFP_ZERO|__GFP_NOWARN);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tprof_buffer = vzalloc(buffer_bytes);\n\tif (prof_buffer)\n\t\treturn 0;\n\n\tfree_cpumask_var(prof_cpu_mask);\n\treturn -ENOMEM;\n}\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PROC_FS)\n \nstatic void __profile_flip_buffers(void *unused)\n{\n\tint cpu = smp_processor_id();\n\n\tper_cpu(cpu_profile_flip, cpu) = !per_cpu(cpu_profile_flip, cpu);\n}\n\nstatic void profile_flip_buffers(void)\n{\n\tint i, j, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\tj = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[j];\n\t\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, NULL, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, NR_PROFILE_HIT*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >> prof_shift, prof_len - 1);\n\ti = primary = (pc & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tsecondary = (~(pc << 1) & (NR_PROFILE_GRP - 1)) << PROFILE_GRPSHIFT;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t \n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < PROFILE_GRPSZ; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (NR_PROFILE_HIT - 1);\n\t} while (i != primary);\n\n\t \n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < NR_PROFILE_HIT; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}\n\nstatic int profile_dead_cpu(unsigned int cpu)\n{\n\tstruct page *page;\n\tint i;\n\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[i]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[i] = NULL;\n\t\t\t__free_page(page);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int profile_prepare_cpu(unsigned int cpu)\n{\n\tint i, node = cpu_to_mem(cpu);\n\tstruct page *page;\n\n\tper_cpu(cpu_profile_flip, cpu) = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (per_cpu(cpu_profile_hits, cpu)[i])\n\t\t\tcontinue;\n\n\t\tpage = __alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\t\tif (!page) {\n\t\t\tprofile_dead_cpu(cpu);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tper_cpu(cpu_profile_hits, cpu)[i] = page_address(page);\n\n\t}\n\treturn 0;\n}\n\nstatic int profile_online_cpu(unsigned int cpu)\n{\n\tif (cpumask_available(prof_cpu_mask))\n\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\n\treturn 0;\n}\n\n#else  \n#define profile_flip_buffers()\t\tdo { } while (0)\n#define profile_discard_flip_buffers()\tdo { } while (0)\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >> prof_shift;\n\tatomic_add(nr_hits, &prof_buffer[min(pc, prof_len - 1)]);\n}\n#endif  \n\nvoid profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}\nEXPORT_SYMBOL_GPL(profile_hits);\n\nvoid profile_tick(int type)\n{\n\tstruct pt_regs *regs = get_irq_regs();\n\n\tif (!user_mode(regs) && cpumask_available(prof_cpu_mask) &&\n\t    cpumask_test_cpu(smp_processor_id(), prof_cpu_mask))\n\t\tprofile_hit(type, (void *)profile_pc(regs));\n}\n\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic int prof_cpu_mask_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(prof_cpu_mask));\n\treturn 0;\n}\n\nstatic int prof_cpu_mask_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, prof_cpu_mask_proc_show, NULL);\n}\n\nstatic ssize_t prof_cpu_mask_proc_write(struct file *file,\n\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (!err) {\n\t\tcpumask_copy(prof_cpu_mask, new_value);\n\t\terr = count;\n\t}\n\tfree_cpumask_var(new_value);\n\treturn err;\n}\n\nstatic const struct proc_ops prof_cpu_mask_proc_ops = {\n\t.proc_open\t= prof_cpu_mask_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= prof_cpu_mask_proc_write,\n};\n\nvoid create_prof_cpu_mask(void)\n{\n\t \n\tproc_create(\"irq/prof_cpu_mask\", 0600, NULL, &prof_cpu_mask_proc_ops);\n}\n\n \nstatic ssize_t\nread_profile(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t read;\n\tchar *pnt;\n\tunsigned long sample_step = 1UL << prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >= (prof_len+1)*sizeof(unsigned int))\n\t\treturn 0;\n\tif (count > (prof_len+1)*sizeof(unsigned int) - p)\n\t\tcount = (prof_len+1)*sizeof(unsigned int) - p;\n\tread = 0;\n\n\twhile (p < sizeof(unsigned int) && count > 0) {\n\t\tif (put_user(*((char *)(&sample_step)+p), buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++; p++; count--; read++;\n\t}\n\tpnt = (char *)prof_buffer + p - sizeof(atomic_t);\n\tif (copy_to_user(buf, (void *)pnt, count))\n\t\treturn -EFAULT;\n\tread += count;\n\t*ppos += read;\n\treturn read;\n}\n\n \nint __weak setup_profiling_timer(unsigned mult)\n{\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t write_profile(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n#ifdef CONFIG_SMP\n\tif (count == sizeof(int)) {\n\t\tunsigned int multiplier;\n\n\t\tif (copy_from_user(&multiplier, buf, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (setup_profiling_timer(multiplier))\n\t\t\treturn -EINVAL;\n\t}\n#endif\n\tprofile_discard_flip_buffers();\n\tmemset(prof_buffer, 0, prof_len * sizeof(atomic_t));\n\treturn count;\n}\n\nstatic const struct proc_ops profile_proc_ops = {\n\t.proc_read\t= read_profile,\n\t.proc_write\t= write_profile,\n\t.proc_lseek\t= default_llseek,\n};\n\nint __ref create_proc_profile(void)\n{\n\tstruct proc_dir_entry *entry;\n#ifdef CONFIG_SMP\n\tenum cpuhp_state online_state;\n#endif\n\n\tint err = 0;\n\n\tif (!prof_on)\n\t\treturn 0;\n#ifdef CONFIG_SMP\n\terr = cpuhp_setup_state(CPUHP_PROFILE_PREPARE, \"PROFILE_PREPARE\",\n\t\t\t\tprofile_prepare_cpu, profile_dead_cpu);\n\tif (err)\n\t\treturn err;\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"AP_PROFILE_ONLINE\",\n\t\t\t\tprofile_online_cpu, NULL);\n\tif (err < 0)\n\t\tgoto err_state_prep;\n\tonline_state = err;\n\terr = 0;\n#endif\n\tentry = proc_create(\"profile\", S_IWUSR | S_IRUGO,\n\t\t\t    NULL, &profile_proc_ops);\n\tif (!entry)\n\t\tgoto err_state_onl;\n\tproc_set_size(entry, (1 + prof_len) * sizeof(atomic_t));\n\n\treturn err;\nerr_state_onl:\n#ifdef CONFIG_SMP\n\tcpuhp_remove_state(online_state);\nerr_state_prep:\n\tcpuhp_remove_state(CPUHP_PROFILE_PREPARE);\n#endif\n\treturn err;\n}\nsubsys_initcall(create_proc_profile);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}