{
  "module_name": "kallsyms_selftest.c",
  "hash_id": "24bc0c35ec1bc1559f4ddfb3e5cb6850cf4a2eb49f04210fe4ad05e3499f5ac2",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kallsyms_selftest.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kallsyms_selftest: \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/random.h>\n#include <linux/sched/clock.h>\n#include <linux/kthread.h>\n#include <linux/vmalloc.h>\n\n#include \"kallsyms_internal.h\"\n#include \"kallsyms_selftest.h\"\n\n\n#define MAX_NUM_OF_RECORDS\t\t64\n\nstruct test_stat {\n\tint min;\n\tint max;\n\tint save_cnt;\n\tint real_cnt;\n\tint perf;\n\tu64 sum;\n\tchar *name;\n\tunsigned long addr;\n\tunsigned long addrs[MAX_NUM_OF_RECORDS];\n};\n\nstruct test_item {\n\tchar *name;\n\tunsigned long addr;\n};\n\n#define ITEM_FUNC(s)\t\t\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.name = #s,\t\t\t\\\n\t\t.addr = (unsigned long)s,\t\\\n\t}\n\n#define ITEM_DATA(s)\t\t\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.name = #s,\t\t\t\\\n\t\t.addr = (unsigned long)&s,\t\\\n\t}\n\n\nstatic int kallsyms_test_var_bss_static;\nstatic int kallsyms_test_var_data_static = 1;\nint kallsyms_test_var_bss;\nint kallsyms_test_var_data = 1;\n\nstatic int kallsyms_test_func_static(void)\n{\n\tkallsyms_test_var_bss_static++;\n\tkallsyms_test_var_data_static++;\n\n\treturn 0;\n}\n\nint kallsyms_test_func(void)\n{\n\treturn kallsyms_test_func_static();\n}\n\n__weak int kallsyms_test_func_weak(void)\n{\n\tkallsyms_test_var_bss++;\n\tkallsyms_test_var_data++;\n\treturn 0;\n}\n\nstatic struct test_item test_items[] = {\n\tITEM_FUNC(kallsyms_test_func_static),\n\tITEM_FUNC(kallsyms_test_func),\n\tITEM_FUNC(kallsyms_test_func_weak),\n\tITEM_FUNC(vmalloc),\n\tITEM_FUNC(vfree),\n#ifdef CONFIG_KALLSYMS_ALL\n\tITEM_DATA(kallsyms_test_var_bss_static),\n\tITEM_DATA(kallsyms_test_var_data_static),\n\tITEM_DATA(kallsyms_test_var_bss),\n\tITEM_DATA(kallsyms_test_var_data),\n\tITEM_DATA(vmap_area_list),\n#endif\n};\n\nstatic char stub_name[KSYM_NAME_LEN];\n\nstatic int stat_symbol_len(void *data, const char *name, unsigned long addr)\n{\n\t*(u32 *)data += strlen(name);\n\n\treturn 0;\n}\n\nstatic void test_kallsyms_compression_ratio(void)\n{\n\tu32 pos, off, len, num;\n\tu32 ratio, total_size, total_len = 0;\n\n\tkallsyms_on_each_symbol(stat_symbol_len, &total_len);\n\n\t \n\tmemset(stub_name, '4', sizeof(stub_name));\n\tpos = total_len / kallsyms_num_syms;\n\tstub_name[pos] = 0;\n\n\tpos = 0;\n\tnum = 0;\n\toff = 0;\n\twhile (pos < kallsyms_num_syms) {\n\t\tlen = kallsyms_names[off];\n\t\tnum++;\n\t\toff++;\n\t\tpos++;\n\t\tif ((len & 0x80) != 0) {\n\t\t\tlen = (len & 0x7f) | (kallsyms_names[off] << 7);\n\t\t\tnum++;\n\t\t\toff++;\n\t\t}\n\t\toff += len;\n\t}\n\n\t \n\ttotal_size = off - num;\n\tpos = kallsyms_token_index[0xff];\n\ttotal_size += pos + strlen(&kallsyms_token_table[pos]) + 1;\n\ttotal_size += 0x100 * sizeof(u16);\n\n\tpr_info(\" ---------------------------------------------------------\\n\");\n\tpr_info(\"| nr_symbols | compressed size | original size | ratio(%%) |\\n\");\n\tpr_info(\"|---------------------------------------------------------|\\n\");\n\tratio = (u32)div_u64(10000ULL * total_size, total_len);\n\tpr_info(\"| %10d |    %10d   |   %10d  |  %2d.%-2d   |\\n\",\n\t\tkallsyms_num_syms, total_size, total_len, ratio / 100, ratio % 100);\n\tpr_info(\" ---------------------------------------------------------\\n\");\n}\n\nstatic int lookup_name(void *data, const char *name, unsigned long addr)\n{\n\tu64 t0, t1, t;\n\tstruct test_stat *stat = (struct test_stat *)data;\n\n\tt0 = ktime_get_ns();\n\t(void)kallsyms_lookup_name(name);\n\tt1 = ktime_get_ns();\n\n\tt = t1 - t0;\n\tif (t < stat->min)\n\t\tstat->min = t;\n\n\tif (t > stat->max)\n\t\tstat->max = t;\n\n\tstat->real_cnt++;\n\tstat->sum += t;\n\n\treturn 0;\n}\n\nstatic void test_perf_kallsyms_lookup_name(void)\n{\n\tstruct test_stat stat;\n\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.min = INT_MAX;\n\tkallsyms_on_each_symbol(lookup_name, &stat);\n\tpr_info(\"kallsyms_lookup_name() looked up %d symbols\\n\", stat.real_cnt);\n\tpr_info(\"The time spent on each symbol is (ns): min=%d, max=%d, avg=%lld\\n\",\n\t\tstat.min, stat.max, div_u64(stat.sum, stat.real_cnt));\n}\n\nstatic bool match_cleanup_name(const char *s, const char *name)\n{\n\tchar *p;\n\tint len;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\tp = strstr(s, \".llvm.\");\n\tif (!p)\n\t\treturn false;\n\n\tlen = strlen(name);\n\tif (p - s != len)\n\t\treturn false;\n\n\treturn !strncmp(s, name, len);\n}\n\nstatic int find_symbol(void *data, const char *name, unsigned long addr)\n{\n\tstruct test_stat *stat = (struct test_stat *)data;\n\n\tif (strcmp(name, stat->name) == 0 ||\n\t    (!stat->perf && match_cleanup_name(name, stat->name))) {\n\t\tstat->real_cnt++;\n\t\tstat->addr = addr;\n\n\t\tif (stat->save_cnt < MAX_NUM_OF_RECORDS) {\n\t\t\tstat->addrs[stat->save_cnt] = addr;\n\t\t\tstat->save_cnt++;\n\t\t}\n\n\t\tif (stat->real_cnt == stat->max)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void test_perf_kallsyms_on_each_symbol(void)\n{\n\tu64 t0, t1;\n\tstruct test_stat stat;\n\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.max = INT_MAX;\n\tstat.name = stub_name;\n\tstat.perf = 1;\n\tt0 = ktime_get_ns();\n\tkallsyms_on_each_symbol(find_symbol, &stat);\n\tt1 = ktime_get_ns();\n\tpr_info(\"kallsyms_on_each_symbol() traverse all: %lld ns\\n\", t1 - t0);\n}\n\nstatic int match_symbol(void *data, unsigned long addr)\n{\n\tstruct test_stat *stat = (struct test_stat *)data;\n\n\tstat->real_cnt++;\n\tstat->addr = addr;\n\n\tif (stat->save_cnt < MAX_NUM_OF_RECORDS) {\n\t\tstat->addrs[stat->save_cnt] = addr;\n\t\tstat->save_cnt++;\n\t}\n\n\tif (stat->real_cnt == stat->max)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void test_perf_kallsyms_on_each_match_symbol(void)\n{\n\tu64 t0, t1;\n\tstruct test_stat stat;\n\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.max = INT_MAX;\n\tstat.name = stub_name;\n\tt0 = ktime_get_ns();\n\tkallsyms_on_each_match_symbol(match_symbol, stat.name, &stat);\n\tt1 = ktime_get_ns();\n\tpr_info(\"kallsyms_on_each_match_symbol() traverse all: %lld ns\\n\", t1 - t0);\n}\n\nstatic int test_kallsyms_basic_function(void)\n{\n\tint i, j, ret;\n\tint next = 0, nr_failed = 0;\n\tchar *prefix;\n\tunsigned short rand;\n\tunsigned long addr, lookup_addr;\n\tchar namebuf[KSYM_NAME_LEN];\n\tstruct test_stat *stat, *stat2;\n\n\tstat = kmalloc(sizeof(*stat) * 2, GFP_KERNEL);\n\tif (!stat)\n\t\treturn -ENOMEM;\n\tstat2 = stat + 1;\n\n\tprefix = \"kallsyms_lookup_name() for\";\n\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {\n\t\taddr = kallsyms_lookup_name(test_items[i].name);\n\t\tif (addr != test_items[i].addr) {\n\t\t\tnr_failed++;\n\t\t\tpr_info(\"%s %s failed: addr=%lx, expect %lx\\n\",\n\t\t\t\tprefix, test_items[i].name, addr, test_items[i].addr);\n\t\t}\n\t}\n\n\tprefix = \"kallsyms_on_each_symbol() for\";\n\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {\n\t\tmemset(stat, 0, sizeof(*stat));\n\t\tstat->max = INT_MAX;\n\t\tstat->name = test_items[i].name;\n\t\tkallsyms_on_each_symbol(find_symbol, stat);\n\t\tif (stat->addr != test_items[i].addr || stat->real_cnt != 1) {\n\t\t\tnr_failed++;\n\t\t\tpr_info(\"%s %s failed: count=%d, addr=%lx, expect %lx\\n\",\n\t\t\t\tprefix, test_items[i].name,\n\t\t\t\tstat->real_cnt, stat->addr, test_items[i].addr);\n\t\t}\n\t}\n\n\tprefix = \"kallsyms_on_each_match_symbol() for\";\n\tfor (i = 0; i < ARRAY_SIZE(test_items); i++) {\n\t\tmemset(stat, 0, sizeof(*stat));\n\t\tstat->max = INT_MAX;\n\t\tstat->name = test_items[i].name;\n\t\tkallsyms_on_each_match_symbol(match_symbol, test_items[i].name, stat);\n\t\tif (stat->addr != test_items[i].addr || stat->real_cnt != 1) {\n\t\t\tnr_failed++;\n\t\t\tpr_info(\"%s %s failed: count=%d, addr=%lx, expect %lx\\n\",\n\t\t\t\tprefix, test_items[i].name,\n\t\t\t\tstat->real_cnt, stat->addr, test_items[i].addr);\n\t\t}\n\t}\n\n\tif (nr_failed) {\n\t\tkfree(stat);\n\t\treturn -ESRCH;\n\t}\n\n\tfor (i = 0; i < kallsyms_num_syms; i++) {\n\t\taddr = kallsyms_sym_address(i);\n\t\tif (!is_ksym_addr(addr))\n\t\t\tcontinue;\n\n\t\tret = lookup_symbol_name(addr, namebuf);\n\t\tif (unlikely(ret)) {\n\t\t\tnamebuf[0] = 0;\n\t\t\tpr_info(\"%d: lookup_symbol_name(%lx) failed\\n\", i, addr);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tlookup_addr = kallsyms_lookup_name(namebuf);\n\n\t\tmemset(stat, 0, sizeof(*stat));\n\t\tstat->max = INT_MAX;\n\t\tkallsyms_on_each_match_symbol(match_symbol, namebuf, stat);\n\n\t\t \n\t\tif (i >= next) {\n\t\t\tmemset(stat2, 0, sizeof(*stat2));\n\t\t\tstat2->max = INT_MAX;\n\t\t\tstat2->name = namebuf;\n\t\t\tkallsyms_on_each_symbol(find_symbol, stat2);\n\n\t\t\t \n\t\t\tif (stat->addr != stat2->addr ||\n\t\t\t    stat->real_cnt != stat2->real_cnt ||\n\t\t\t    memcmp(stat->addrs, stat2->addrs,\n\t\t\t\t   stat->save_cnt * sizeof(stat->addrs[0]))) {\n\t\t\t\tpr_info(\"%s: mismatch between kallsyms_on_each_symbol() and kallsyms_on_each_match_symbol()\\n\",\n\t\t\t\t\tnamebuf);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t \n\t\t\tget_random_bytes(&rand, sizeof(rand));\n\t\t\tnext = i + (rand & 0xff) + 1;\n\t\t}\n\n\t\t \n\t\tif (!stat->real_cnt) {\n\t\t\tpr_info(\"%s: Never found\\n\", namebuf);\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\tif (!lookup_addr) {\n\t\t\tpr_info(\"%s: NULL lookup_addr?!\\n\", namebuf);\n\t\t\tgoto failed;\n\t\t}\n\t\tif (lookup_addr != stat->addrs[0]) {\n\t\t\tpr_info(\"%s: lookup_addr != stat->addrs[0]\\n\", namebuf);\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\tif (stat->real_cnt <= MAX_NUM_OF_RECORDS) {\n\t\t\tfor (j = 0; j < stat->save_cnt; j++) {\n\t\t\t\tif (stat->addrs[j] == addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (j == stat->save_cnt) {\n\t\t\t\tpr_info(\"%s: j == save_cnt?!\\n\", namebuf);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(stat);\n\n\treturn 0;\n\nfailed:\n\tpr_info(\"Test for %dth symbol failed: (%s) addr=%lx\", i, namebuf, addr);\n\tkfree(stat);\n\treturn -ESRCH;\n}\n\nstatic int test_entry(void *p)\n{\n\tint ret;\n\n\tdo {\n\t\tschedule_timeout(5 * HZ);\n\t} while (system_state != SYSTEM_RUNNING);\n\n\tpr_info(\"start\\n\");\n\tret = test_kallsyms_basic_function();\n\tif (ret) {\n\t\tpr_info(\"abort\\n\");\n\t\treturn 0;\n\t}\n\n\ttest_kallsyms_compression_ratio();\n\ttest_perf_kallsyms_lookup_name();\n\ttest_perf_kallsyms_on_each_symbol();\n\ttest_perf_kallsyms_on_each_match_symbol();\n\tpr_info(\"finish\\n\");\n\n\treturn 0;\n}\n\nstatic int __init kallsyms_test_init(void)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_create(test_entry, NULL, \"kallsyms_test\");\n\tif (IS_ERR(t)) {\n\t\tpr_info(\"Create kallsyms selftest task failed\\n\");\n\t\treturn PTR_ERR(t);\n\t}\n\tkthread_bind(t, 0);\n\twake_up_process(t);\n\n\treturn 0;\n}\nlate_initcall(kallsyms_test_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}