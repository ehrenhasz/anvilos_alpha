{
  "module_name": "utsname.c",
  "hash_id": "1118500fa3f2283af69befe2c9bc8e6894e33fbbe129278fcd0f0a22800fdb3d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/utsname.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/uts.h>\n#include <linux/utsname.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/task.h>\n\nstatic struct kmem_cache *uts_ns_cache __ro_after_init;\n\nstatic struct ucounts *inc_uts_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_UTS_NAMESPACES);\n}\n\nstatic void dec_uts_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_UTS_NAMESPACES);\n}\n\nstatic struct uts_namespace *create_uts_ns(void)\n{\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = kmem_cache_alloc(uts_ns_cache, GFP_KERNEL);\n\tif (uts_ns)\n\t\trefcount_set(&uts_ns->ns.count, 1);\n\treturn uts_ns;\n}\n\n \nstatic struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\n\t\t\t\t\t  struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n\tucounts = inc_uts_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tns = create_uts_ns();\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free;\n\n\tns->ucounts = ucounts;\n\tns->ns.ops = &utsns_operations;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\n\tns->user_ns = get_user_ns(user_ns);\n\tup_read(&uts_sem);\n\treturn ns;\n\nfail_free:\n\tkmem_cache_free(uts_ns_cache, ns);\nfail_dec:\n\tdec_uts_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}\n\n \nstruct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}\n\nvoid free_uts_ns(struct uts_namespace *ns)\n{\n\tdec_uts_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkmem_cache_free(uts_ns_cache, ns);\n}\n\nstatic inline struct uts_namespace *to_uts_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct uts_namespace, ns);\n}\n\nstatic struct ns_common *utsns_get(struct task_struct *task)\n{\n\tstruct uts_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->uts_ns;\n\t\tget_uts_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic void utsns_put(struct ns_common *ns)\n{\n\tput_uts_ns(to_uts_ns(ns));\n}\n\nstatic int utsns_install(struct nsset *nsset, struct ns_common *new)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct uts_namespace *ns = to_uts_ns(new);\n\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tget_uts_ns(ns);\n\tput_uts_ns(nsproxy->uts_ns);\n\tnsproxy->uts_ns = ns;\n\treturn 0;\n}\n\nstatic struct user_namespace *utsns_owner(struct ns_common *ns)\n{\n\treturn to_uts_ns(ns)->user_ns;\n}\n\nconst struct proc_ns_operations utsns_operations = {\n\t.name\t\t= \"uts\",\n\t.type\t\t= CLONE_NEWUTS,\n\t.get\t\t= utsns_get,\n\t.put\t\t= utsns_put,\n\t.install\t= utsns_install,\n\t.owner\t\t= utsns_owner,\n};\n\nvoid __init uts_ns_init(void)\n{\n\tuts_ns_cache = kmem_cache_create_usercopy(\n\t\t\t\"uts_namespace\", sizeof(struct uts_namespace), 0,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT,\n\t\t\toffsetof(struct uts_namespace, name),\n\t\t\tsizeof_field(struct uts_namespace, name),\n\t\t\tNULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}