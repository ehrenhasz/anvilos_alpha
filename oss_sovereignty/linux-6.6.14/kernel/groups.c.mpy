{
  "module_name": "groups.c",
  "hash_id": "833a0e4445e9fc1912e42e08bae393f5edba02660143bc1ecb4f38db28140f58",
  "original_prompt": "Ingested from linux-6.6.14/kernel/groups.c",
  "human_readable_source": "\n \n#include <linux/cred.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/sort.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n\nstruct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *gi;\n\tgi = kvmalloc(struct_size(gi, gid, gidsetsize), GFP_KERNEL_ACCOUNT);\n\tif (!gi)\n\t\treturn NULL;\n\n\tatomic_set(&gi->usage, 1);\n\tgi->ngroups = gidsetsize;\n\treturn gi;\n}\n\nEXPORT_SYMBOL(groups_alloc);\n\nvoid groups_free(struct group_info *group_info)\n{\n\tkvfree(group_info);\n}\n\nEXPORT_SYMBOL(groups_free);\n\n \nstatic int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_info->gid[i]);\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -EFAULT;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -EINVAL;\n\n\t\tgroup_info->gid[i] = kgid;\n\t}\n\treturn 0;\n}\n\nstatic int gid_cmp(const void *_a, const void *_b)\n{\n\tkgid_t a = *(kgid_t *)_a;\n\tkgid_t b = *(kgid_t *)_b;\n\n\treturn gid_gt(a, b) - gid_lt(a, b);\n}\n\nvoid groups_sort(struct group_info *group_info)\n{\n\tsort(group_info->gid, group_info->ngroups, sizeof(*group_info->gid),\n\t     gid_cmp, NULL);\n}\nEXPORT_SYMBOL(groups_sort);\n\n \nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}\n\nEXPORT_SYMBOL(set_groups);\n\n \nint set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\tconst struct cred *old;\n\tint retval;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\told = current_cred();\n\n\tset_groups(new, group_info);\n\n\tretval = security_task_fix_setgroups(new, old);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(set_current_groups);\n\nSYSCALL_DEFINE2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -EINVAL;\n\n\t \n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}\n\nbool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable_setid(user_ns, CAP_SETGID) &&\n\t\tuserns_may_setgroups(user_ns);\n}\n\n \n\nSYSCALL_DEFINE2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -EPERM;\n\tif ((unsigned)gidsetsize > NGROUPS_MAX)\n\t\treturn -EINVAL;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -ENOMEM;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tgroups_sort(group_info);\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}\n\n \nint in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(in_group_p);\n\nint in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(in_egroup_p);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}