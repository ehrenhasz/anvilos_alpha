{
  "module_name": "shadow.c",
  "hash_id": "a2e35c2d076891a72ee11ec313224dc141f6523d438ef05a9ce9dc51f81ab9c7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/livepatch/shadow.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hashtable.h>\n#include <linux/slab.h>\n#include <linux/livepatch.h>\n\nstatic DEFINE_HASHTABLE(klp_shadow_hash, 12);\n\n \nstatic DEFINE_SPINLOCK(klp_shadow_lock);\n\n \nstruct klp_shadow {\n\tstruct hlist_node node;\n\tstruct rcu_head rcu_head;\n\tvoid *obj;\n\tunsigned long id;\n\tchar data[];\n};\n\n \nstatic inline bool klp_shadow_match(struct klp_shadow *shadow, void *obj,\n\t\t\t\tunsigned long id)\n{\n\treturn shadow->obj == obj && shadow->id == id;\n}\n\n \nvoid *klp_shadow_get(void *obj, unsigned long id)\n{\n\tstruct klp_shadow *shadow;\n\n\trcu_read_lock();\n\n\thash_for_each_possible_rcu(klp_shadow_hash, shadow, node,\n\t\t\t\t   (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn shadow->data;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(klp_shadow_get);\n\nstatic void *__klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t\t       size_t size, gfp_t gfp_flags,\n\t\t\t\t       klp_shadow_ctor_t ctor, void *ctor_data,\n\t\t\t\t       bool warn_on_exist)\n{\n\tstruct klp_shadow *new_shadow;\n\tvoid *shadow_data;\n\tunsigned long flags;\n\n\t \n\tshadow_data = klp_shadow_get(obj, id);\n\tif (shadow_data)\n\t\tgoto exists;\n\n\t \n\tnew_shadow = kzalloc(size + sizeof(*new_shadow), gfp_flags);\n\tif (!new_shadow)\n\t\treturn NULL;\n\n\t \n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\tshadow_data = klp_shadow_get(obj, id);\n\tif (unlikely(shadow_data)) {\n\t\t \n\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\tkfree(new_shadow);\n\t\tgoto exists;\n\t}\n\n\tnew_shadow->obj = obj;\n\tnew_shadow->id = id;\n\n\tif (ctor) {\n\t\tint err;\n\n\t\terr = ctor(obj, new_shadow->data, ctor_data);\n\t\tif (err) {\n\t\t\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\t\t\tkfree(new_shadow);\n\t\t\tpr_err(\"Failed to construct shadow variable <%p, %lx> (%d)\\n\",\n\t\t\t       obj, id, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\thash_add_rcu(klp_shadow_hash, &new_shadow->node,\n\t\t     (unsigned long)new_shadow->obj);\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n\n\treturn new_shadow->data;\n\nexists:\n\tif (warn_on_exist) {\n\t\tWARN(1, \"Duplicate shadow variable <%p, %lx>\\n\", obj, id);\n\t\treturn NULL;\n\t}\n\n\treturn shadow_data;\n}\n\n \nvoid *klp_shadow_alloc(void *obj, unsigned long id,\n\t\t       size_t size, gfp_t gfp_flags,\n\t\t       klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, true);\n}\nEXPORT_SYMBOL_GPL(klp_shadow_alloc);\n\n \nvoid *klp_shadow_get_or_alloc(void *obj, unsigned long id,\n\t\t\t      size_t size, gfp_t gfp_flags,\n\t\t\t      klp_shadow_ctor_t ctor, void *ctor_data)\n{\n\treturn __klp_shadow_get_or_alloc(obj, id, size, gfp_flags,\n\t\t\t\t\t ctor, ctor_data, false);\n}\nEXPORT_SYMBOL_GPL(klp_shadow_get_or_alloc);\n\nstatic void klp_shadow_free_struct(struct klp_shadow *shadow,\n\t\t\t\t   klp_shadow_dtor_t dtor)\n{\n\thash_del_rcu(&shadow->node);\n\tif (dtor)\n\t\tdtor(shadow->obj, shadow->data);\n\tkfree_rcu(shadow, rcu_head);\n}\n\n \nvoid klp_shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t \n\thash_for_each_possible(klp_shadow_hash, shadow, node,\n\t\t\t       (unsigned long)obj) {\n\n\t\tif (klp_shadow_match(shadow, obj, id)) {\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}\nEXPORT_SYMBOL_GPL(klp_shadow_free);\n\n \nvoid klp_shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tstruct klp_shadow *shadow;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&klp_shadow_lock, flags);\n\n\t \n\thash_for_each(klp_shadow_hash, i, shadow, node) {\n\t\tif (klp_shadow_match(shadow, shadow->obj, id))\n\t\t\tklp_shadow_free_struct(shadow, dtor);\n\t}\n\n\tspin_unlock_irqrestore(&klp_shadow_lock, flags);\n}\nEXPORT_SYMBOL_GPL(klp_shadow_free_all);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}