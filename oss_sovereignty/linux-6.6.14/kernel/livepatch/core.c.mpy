{
  "module_name": "core.c",
  "hash_id": "6b8c4af2880475e33dd747c64322c2d623ff2581d769d5ca042b0fa349782d0a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/livepatch/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/kallsyms.h>\n#include <linux/livepatch.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/completion.h>\n#include <linux/memory.h>\n#include <linux/rcupdate.h>\n#include <asm/cacheflush.h>\n#include \"core.h\"\n#include \"patch.h\"\n#include \"state.h\"\n#include \"transition.h\"\n\n \nDEFINE_MUTEX(klp_mutex);\n\n \nLIST_HEAD(klp_patches);\n\nstatic struct kobject *klp_root_kobj;\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}\n\n \nstatic void klp_find_object_module(struct klp_object *obj)\n{\n\tstruct module *mod;\n\n\tif (!klp_is_module(obj))\n\t\treturn;\n\n\trcu_read_lock_sched();\n\t \n\tmod = find_module(obj->name);\n\t \n\tif (mod && mod->klp_alive)\n\t\tobj->mod = mod;\n\n\trcu_read_unlock_sched();\n}\n\nstatic bool klp_initialized(void)\n{\n\treturn !!klp_root_kobj;\n}\n\nstatic struct klp_func *klp_find_func(struct klp_object *obj,\n\t\t\t\t      struct klp_func *old_func)\n{\n\tstruct klp_func *func;\n\n\tklp_for_each_func(obj, func) {\n\t\tif ((strcmp(old_func->old_name, func->old_name) == 0) &&\n\t\t    (old_func->old_sympos == func->old_sympos)) {\n\t\t\treturn func;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct klp_object *klp_find_object(struct klp_patch *patch,\n\t\t\t\t\t  struct klp_object *old_obj)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (klp_is_module(old_obj)) {\n\t\t\tif (klp_is_module(obj) &&\n\t\t\t    strcmp(old_obj->name, obj->name) == 0) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t} else if (!klp_is_module(obj)) {\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct klp_find_arg {\n\tconst char *name;\n\tunsigned long addr;\n\tunsigned long count;\n\tunsigned long pos;\n};\n\nstatic int klp_match_callback(void *data, unsigned long addr)\n{\n\tstruct klp_find_arg *args = data;\n\n\targs->addr = addr;\n\targs->count++;\n\n\t \n\tif ((args->pos && (args->count == args->pos)) ||\n\t    (!args->pos && (args->count > 1)))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int klp_find_callback(void *data, const char *name, unsigned long addr)\n{\n\tstruct klp_find_arg *args = data;\n\n\tif (strcmp(args->name, name))\n\t\treturn 0;\n\n\treturn klp_match_callback(data, addr);\n}\n\nstatic int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(objname, klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_match_symbol(klp_match_callback, name, &args);\n\n\t \n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}\n\nstatic int klp_resolve_symbols(Elf_Shdr *sechdrs, const char *strtab,\n\t\t\t       unsigned int symndx, Elf_Shdr *relasec,\n\t\t\t       const char *sec_objname)\n{\n\tint i, cnt, ret;\n\tchar sym_objname[MODULE_NAME_LEN];\n\tchar sym_name[KSYM_NAME_LEN];\n\tElf_Rela *relas;\n\tElf_Sym *sym;\n\tunsigned long sympos, addr;\n\tbool sym_vmlinux;\n\tbool sec_vmlinux = !strcmp(sec_objname, \"vmlinux\");\n\n\t \n\tBUILD_BUG_ON(MODULE_NAME_LEN < 56 || KSYM_NAME_LEN != 512);\n\n\trelas = (Elf_Rela *) relasec->sh_addr;\n\t \n\tfor (i = 0; i < relasec->sh_size / sizeof(Elf_Rela); i++) {\n\t\tsym = (Elf_Sym *)sechdrs[symndx].sh_addr + ELF_R_SYM(relas[i].r_info);\n\t\tif (sym->st_shndx != SHN_LIVEPATCH) {\n\t\t\tpr_err(\"symbol %s is not marked as a livepatch symbol\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tcnt = sscanf(strtab + sym->st_name,\n\t\t\t     \".klp.sym.%55[^.].%511[^,],%lu\",\n\t\t\t     sym_objname, sym_name, &sympos);\n\t\tif (cnt != 3) {\n\t\t\tpr_err(\"symbol %s has an incorrectly formatted name\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsym_vmlinux = !strcmp(sym_objname, \"vmlinux\");\n\n\t\t \n\t\tif (!sec_vmlinux && sym_vmlinux) {\n\t\t\tpr_err(\"invalid access to vmlinux symbol '%s' from module-specific livepatch relocation section\\n\",\n\t\t\t       sym_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = klp_find_object_symbol(sym_vmlinux ? NULL : sym_objname,\n\t\t\t\t\t     sym_name, sympos, &addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsym->st_value = addr;\n\t}\n\n\treturn 0;\n}\n\nvoid __weak clear_relocate_add(Elf_Shdr *sechdrs,\n\t\t   const char *strtab,\n\t\t   unsigned int symindex,\n\t\t   unsigned int relsec,\n\t\t   struct module *me)\n{\n}\n\n \nstatic int klp_write_section_relocs(struct module *pmod, Elf_Shdr *sechdrs,\n\t\t\t\t    const char *shstrtab, const char *strtab,\n\t\t\t\t    unsigned int symndx, unsigned int secndx,\n\t\t\t\t    const char *objname, bool apply)\n{\n\tint cnt, ret;\n\tchar sec_objname[MODULE_NAME_LEN];\n\tElf_Shdr *sec = sechdrs + secndx;\n\n\t \n\tcnt = sscanf(shstrtab + sec->sh_name, \".klp.rela.%55[^.]\",\n\t\t     sec_objname);\n\tif (cnt != 1) {\n\t\tpr_err(\"section %s has an incorrectly formatted name\\n\",\n\t\t       shstrtab + sec->sh_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(objname ? objname : \"vmlinux\", sec_objname))\n\t\treturn 0;\n\n\tif (apply) {\n\t\tret = klp_resolve_symbols(sechdrs, strtab, symndx,\n\t\t\t\t\t  sec, sec_objname);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn apply_relocate_add(sechdrs, strtab, symndx, secndx, pmod);\n\t}\n\n\tclear_relocate_add(sechdrs, strtab, symndx, secndx, pmod);\n\treturn 0;\n}\n\nint klp_apply_section_relocs(struct module *pmod, Elf_Shdr *sechdrs,\n\t\t\t     const char *shstrtab, const char *strtab,\n\t\t\t     unsigned int symndx, unsigned int secndx,\n\t\t\t     const char *objname)\n{\n\treturn klp_write_section_relocs(pmod, sechdrs, shstrtab, strtab, symndx,\n\t\t\t\t\tsecndx, objname, true);\n}\n\n \nstatic int __klp_disable_patch(struct klp_patch *patch);\n\nstatic ssize_t enabled_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool enabled;\n\n\tret = kstrtobool(buf, &enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\n\tmutex_lock(&klp_mutex);\n\n\tif (patch->enabled == enabled) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (patch == klp_transition_patch)\n\t\tklp_reverse_transition();\n\telse if (!enabled)\n\t\tret = __klp_disable_patch(patch);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\tmutex_unlock(&klp_mutex);\n\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\treturn snprintf(buf, PAGE_SIZE-1, \"%d\\n\", patch->enabled);\n}\n\nstatic ssize_t transition_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\treturn snprintf(buf, PAGE_SIZE-1, \"%d\\n\",\n\t\t\tpatch == klp_transition_patch);\n}\n\nstatic ssize_t force_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn count;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tif (patch != klp_transition_patch) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tklp_force_transition();\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n}\n\nstatic struct kobj_attribute enabled_kobj_attr = __ATTR_RW(enabled);\nstatic struct kobj_attribute transition_kobj_attr = __ATTR_RO(transition);\nstatic struct kobj_attribute force_kobj_attr = __ATTR_WO(force);\nstatic struct attribute *klp_patch_attrs[] = {\n\t&enabled_kobj_attr.attr,\n\t&transition_kobj_attr.attr,\n\t&force_kobj_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(klp_patch);\n\nstatic ssize_t patched_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_object *obj;\n\n\tobj = container_of(kobj, struct klp_object, kobj);\n\treturn sysfs_emit(buf, \"%d\\n\", obj->patched);\n}\n\nstatic struct kobj_attribute patched_kobj_attr = __ATTR_RO(patched);\nstatic struct attribute *klp_object_attrs[] = {\n\t&patched_kobj_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(klp_object);\n\nstatic void klp_free_object_dynamic(struct klp_object *obj)\n{\n\tkfree(obj->name);\n\tkfree(obj);\n}\n\nstatic void klp_init_func_early(struct klp_object *obj,\n\t\t\t\tstruct klp_func *func);\nstatic void klp_init_object_early(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj);\n\nstatic struct klp_object *klp_alloc_object_dynamic(const char *name,\n\t\t\t\t\t\t   struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tobj = kzalloc(sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn NULL;\n\n\tif (name) {\n\t\tobj->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!obj->name) {\n\t\t\tkfree(obj);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tklp_init_object_early(patch, obj);\n\tobj->dynamic = true;\n\n\treturn obj;\n}\n\nstatic void klp_free_func_nop(struct klp_func *func)\n{\n\tkfree(func->old_name);\n\tkfree(func);\n}\n\nstatic struct klp_func *klp_alloc_func_nop(struct klp_func *old_func,\n\t\t\t\t\t   struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn NULL;\n\n\tif (old_func->old_name) {\n\t\tfunc->old_name = kstrdup(old_func->old_name, GFP_KERNEL);\n\t\tif (!func->old_name) {\n\t\t\tkfree(func);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tklp_init_func_early(obj, func);\n\t \n\tfunc->old_sympos = old_func->old_sympos;\n\tfunc->nop = true;\n\n\treturn func;\n}\n\nstatic int klp_add_object_nops(struct klp_patch *patch,\n\t\t\t       struct klp_object *old_obj)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func, *old_func;\n\n\tobj = klp_find_object(patch, old_obj);\n\n\tif (!obj) {\n\t\tobj = klp_alloc_object_dynamic(old_obj->name, patch);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tklp_for_each_func(old_obj, old_func) {\n\t\tfunc = klp_find_func(obj, old_func);\n\t\tif (func)\n\t\t\tcontinue;\n\n\t\tfunc = klp_alloc_func_nop(old_func, obj);\n\t\tif (!func)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int klp_add_nops(struct klp_patch *patch)\n{\n\tstruct klp_patch *old_patch;\n\tstruct klp_object *old_obj;\n\n\tklp_for_each_patch(old_patch) {\n\t\tklp_for_each_object(old_patch, old_obj) {\n\t\t\tint err;\n\n\t\t\terr = klp_add_object_nops(patch, old_obj);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void klp_kobj_release_patch(struct kobject *kobj)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tcomplete(&patch->finish);\n}\n\nstatic const struct kobj_type klp_ktype_patch = {\n\t.release = klp_kobj_release_patch,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = klp_patch_groups,\n};\n\nstatic void klp_kobj_release_object(struct kobject *kobj)\n{\n\tstruct klp_object *obj;\n\n\tobj = container_of(kobj, struct klp_object, kobj);\n\n\tif (obj->dynamic)\n\t\tklp_free_object_dynamic(obj);\n}\n\nstatic const struct kobj_type klp_ktype_object = {\n\t.release = klp_kobj_release_object,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = klp_object_groups,\n};\n\nstatic void klp_kobj_release_func(struct kobject *kobj)\n{\n\tstruct klp_func *func;\n\n\tfunc = container_of(kobj, struct klp_func, kobj);\n\n\tif (func->nop)\n\t\tklp_free_func_nop(func);\n}\n\nstatic const struct kobj_type klp_ktype_func = {\n\t.release = klp_kobj_release_func,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic void __klp_free_funcs(struct klp_object *obj, bool nops_only)\n{\n\tstruct klp_func *func, *tmp_func;\n\n\tklp_for_each_func_safe(obj, func, tmp_func) {\n\t\tif (nops_only && !func->nop)\n\t\t\tcontinue;\n\n\t\tlist_del(&func->node);\n\t\tkobject_put(&func->kobj);\n\t}\n}\n\n \nstatic void klp_free_object_loaded(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tobj->mod = NULL;\n\n\tklp_for_each_func(obj, func) {\n\t\tfunc->old_func = NULL;\n\n\t\tif (func->nop)\n\t\t\tfunc->new_func = NULL;\n\t}\n}\n\nstatic void __klp_free_objects(struct klp_patch *patch, bool nops_only)\n{\n\tstruct klp_object *obj, *tmp_obj;\n\n\tklp_for_each_object_safe(patch, obj, tmp_obj) {\n\t\t__klp_free_funcs(obj, nops_only);\n\n\t\tif (nops_only && !obj->dynamic)\n\t\t\tcontinue;\n\n\t\tlist_del(&obj->node);\n\t\tkobject_put(&obj->kobj);\n\t}\n}\n\nstatic void klp_free_objects(struct klp_patch *patch)\n{\n\t__klp_free_objects(patch, false);\n}\n\nstatic void klp_free_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_free_objects(patch, true);\n}\n\n \nstatic void klp_free_patch_start(struct klp_patch *patch)\n{\n\tif (!list_empty(&patch->list))\n\t\tlist_del(&patch->list);\n\n\tklp_free_objects(patch);\n}\n\n \nstatic void klp_free_patch_finish(struct klp_patch *patch)\n{\n\t \n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\t \n\tif (!patch->forced)\n\t\tmodule_put(patch->mod);\n}\n\n \nstatic void klp_free_patch_work_fn(struct work_struct *work)\n{\n\tstruct klp_patch *patch =\n\t\tcontainer_of(work, struct klp_patch, free_work);\n\n\tklp_free_patch_finish(patch);\n}\n\nvoid klp_free_patch_async(struct klp_patch *patch)\n{\n\tklp_free_patch_start(patch);\n\tschedule_work(&patch->free_work);\n}\n\nvoid klp_free_replaced_patches_async(struct klp_patch *new_patch)\n{\n\tstruct klp_patch *old_patch, *tmp_patch;\n\n\tklp_for_each_patch_safe(old_patch, tmp_patch) {\n\t\tif (old_patch == new_patch)\n\t\t\treturn;\n\t\tklp_free_patch_async(old_patch);\n\t}\n}\n\nstatic int klp_init_func(struct klp_object *obj, struct klp_func *func)\n{\n\tif (!func->old_name)\n\t\treturn -EINVAL;\n\n\t \n\tif (!func->new_func && !func->nop)\n\t\treturn -EINVAL;\n\n\tif (strlen(func->old_name) >= KSYM_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&func->stack_node);\n\tfunc->patched = false;\n\tfunc->transition = false;\n\n\t \n\treturn kobject_add(&func->kobj, &obj->kobj, \"%s,%lu\",\n\t\t\t   func->old_name,\n\t\t\t   func->old_sympos ? func->old_sympos : 1);\n}\n\nstatic int klp_write_object_relocs(struct klp_patch *patch,\n\t\t\t\t   struct klp_object *obj,\n\t\t\t\t   bool apply)\n{\n\tint i, ret;\n\tstruct klp_modinfo *info = patch->mod->klp_info;\n\n\tfor (i = 1; i < info->hdr.e_shnum; i++) {\n\t\tElf_Shdr *sec = info->sechdrs + i;\n\n\t\tif (!(sec->sh_flags & SHF_RELA_LIVEPATCH))\n\t\t\tcontinue;\n\n\t\tret = klp_write_section_relocs(patch->mod, info->sechdrs,\n\t\t\t\t\t       info->secstrings,\n\t\t\t\t\t       patch->mod->core_kallsyms.strtab,\n\t\t\t\t\t       info->symndx, i, obj->name, apply);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int klp_apply_object_relocs(struct klp_patch *patch,\n\t\t\t\t   struct klp_object *obj)\n{\n\treturn klp_write_object_relocs(patch, obj, true);\n}\n\nstatic void klp_clear_object_relocs(struct klp_patch *patch,\n\t\t\t\t    struct klp_object *obj)\n{\n\tklp_write_object_relocs(patch, obj, false);\n}\n\n \nstatic int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (klp_is_module(obj)) {\n\t\t \n\t\tret = klp_apply_object_relocs(patch, obj);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     (unsigned long *)&func->old_func);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->old_func,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (func->nop)\n\t\t\tfunc->new_func = func->old_func;\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int klp_init_object(struct klp_patch *patch, struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\tconst char *name;\n\n\tif (klp_is_module(obj) && strlen(obj->name) >= MODULE_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tobj->patched = false;\n\tobj->mod = NULL;\n\n\tklp_find_object_module(obj);\n\n\tname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\tret = kobject_add(&obj->kobj, &patch->kobj, \"%s\", name);\n\tif (ret)\n\t\treturn ret;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_init_func(obj, func);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (klp_is_object_loaded(obj))\n\t\tret = klp_init_object_loaded(patch, obj);\n\n\treturn ret;\n}\n\nstatic void klp_init_func_early(struct klp_object *obj,\n\t\t\t\tstruct klp_func *func)\n{\n\tkobject_init(&func->kobj, &klp_ktype_func);\n\tlist_add_tail(&func->node, &obj->func_list);\n}\n\nstatic void klp_init_object_early(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tINIT_LIST_HEAD(&obj->func_list);\n\tkobject_init(&obj->kobj, &klp_ktype_object);\n\tlist_add_tail(&obj->node, &patch->obj_list);\n}\n\nstatic void klp_init_patch_early(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\n\tINIT_LIST_HEAD(&patch->list);\n\tINIT_LIST_HEAD(&patch->obj_list);\n\tkobject_init(&patch->kobj, &klp_ktype_patch);\n\tpatch->enabled = false;\n\tpatch->forced = false;\n\tINIT_WORK(&patch->free_work, klp_free_patch_work_fn);\n\tinit_completion(&patch->finish);\n\n\tklp_for_each_object_static(patch, obj) {\n\t\tklp_init_object_early(patch, obj);\n\n\t\tklp_for_each_func_static(obj, func) {\n\t\t\tklp_init_func_early(obj, func);\n\t\t}\n\t}\n}\n\nstatic int klp_init_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tret = kobject_add(&patch->kobj, klp_root_kobj, \"%s\", patch->mod->name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (patch->replace) {\n\t\tret = klp_add_nops(patch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tklp_for_each_object(patch, obj) {\n\t\tret = klp_init_object(patch, obj);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tlist_add_tail(&patch->list, &klp_patches);\n\n\treturn 0;\n}\n\nstatic int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t \n\tsmp_wmb();\n\n\tklp_start_transition();\n\tpatch->enabled = false;\n\tklp_try_complete_transition();\n\n\treturn 0;\n}\n\nstatic int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t \n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tpatch->enabled = true;\n\tklp_try_complete_transition();\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}\n\n \nint klp_enable_patch(struct klp_patch *patch)\n{\n\tint ret;\n\tstruct klp_object *obj;\n\n\tif (!patch || !patch->mod || !patch->objs)\n\t\treturn -EINVAL;\n\n\tklp_for_each_object_static(patch, obj) {\n\t\tif (!obj->funcs)\n\t\t\treturn -EINVAL;\n\t}\n\n\n\tif (!is_livepatch_module(patch->mod)) {\n\t\tpr_err(\"module %s is not marked as a livepatch module\\n\",\n\t\t       patch->mod->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!klp_initialized())\n\t\treturn -ENODEV;\n\n\tif (!klp_have_reliable_stack()) {\n\t\tpr_warn(\"This architecture doesn't have support for the livepatch consistency model.\\n\");\n\t\tpr_warn(\"The livepatch transition may never complete.\\n\");\n\t}\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_compatible(patch)) {\n\t\tpr_err(\"Livepatch patch (%s) is not compatible with the already installed livepatches.\\n\",\n\t\t\tpatch->mod->name);\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!try_module_get(patch->mod)) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tklp_init_patch_early(patch);\n\n\tret = klp_init_patch(patch);\n\tif (ret)\n\t\tgoto err;\n\n\tret = __klp_enable_patch(patch);\n\tif (ret)\n\t\tgoto err;\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nerr:\n\tklp_free_patch_start(patch);\n\n\tmutex_unlock(&klp_mutex);\n\n\tklp_free_patch_finish(patch);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(klp_enable_patch);\n\n \nvoid klp_unpatch_replaced_patches(struct klp_patch *new_patch)\n{\n\tstruct klp_patch *old_patch;\n\n\tklp_for_each_patch(old_patch) {\n\t\tif (old_patch == new_patch)\n\t\t\treturn;\n\n\t\told_patch->enabled = false;\n\t\tklp_unpatch_objects(old_patch);\n\t}\n}\n\n \nvoid klp_discard_nops(struct klp_patch *new_patch)\n{\n\tklp_unpatch_objects_dynamic(klp_transition_patch);\n\tklp_free_objects_dynamic(klp_transition_patch);\n}\n\n \nstatic void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tklp_for_each_patch(patch) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\tif (patch != klp_transition_patch)\n\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\tklp_unpatch_object(obj);\n\n\t\t\tklp_post_unpatch_callback(obj);\n\t\t\tklp_clear_object_relocs(patch, obj);\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint klp_module_coming(struct module *mod)\n{\n\tint ret;\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(mod->state != MODULE_STATE_COMING))\n\t\treturn -EINVAL;\n\n\tif (!strcmp(mod->name, \"vmlinux\")) {\n\t\tpr_err(\"vmlinux.ko: invalid module name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&klp_mutex);\n\t \n\tmod->klp_alive = true;\n\n\tklp_for_each_patch(patch) {\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\tobj->mod = mod;\n\n\t\t\tret = klp_init_object_loaded(patch, obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"failed to initialize patch '%s' for module '%s' (%d)\\n\",\n\t\t\t\t\tpatch->mod->name, obj->mod->name, ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpr_notice(\"applying patch '%s' to loading module '%s'\\n\",\n\t\t\t\t  patch->mod->name, obj->mod->name);\n\n\t\t\tret = klp_pre_patch_callback(obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\t\tobj->name);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = klp_patch_object(obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"failed to apply patch '%s' to module '%s' (%d)\\n\",\n\t\t\t\t\tpatch->mod->name, obj->mod->name, ret);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (patch != klp_transition_patch)\n\t\t\t\tklp_post_patch_callback(obj);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nerr:\n\t \n\tpr_warn(\"patch '%s' failed for module '%s', refusing to load module '%s'\\n\",\n\t\tpatch->mod->name, obj->mod->name, obj->mod->name);\n\tmod->klp_alive = false;\n\tobj->mod = NULL;\n\tklp_cleanup_module_patches_limited(mod, patch);\n\tmutex_unlock(&klp_mutex);\n\n\treturn ret;\n}\n\nvoid klp_module_going(struct module *mod)\n{\n\tif (WARN_ON(mod->state != MODULE_STATE_GOING &&\n\t\t    mod->state != MODULE_STATE_COMING))\n\t\treturn;\n\n\tmutex_lock(&klp_mutex);\n\t \n\tmod->klp_alive = false;\n\n\tklp_cleanup_module_patches_limited(mod, NULL);\n\n\tmutex_unlock(&klp_mutex);\n}\n\nstatic int __init klp_init(void)\n{\n\tklp_root_kobj = kobject_create_and_add(\"livepatch\", kernel_kobj);\n\tif (!klp_root_kobj)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nmodule_init(klp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}