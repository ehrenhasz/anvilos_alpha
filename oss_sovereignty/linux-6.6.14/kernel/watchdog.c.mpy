{
  "module_name": "watchdog.c",
  "hash_id": "652cbb636ea5cea22cef2b499ccc892f8c97cba718180cf40c829faa934808f7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/watchdog.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"watchdog: \" fmt\n\n#include <linux/mm.h>\n#include <linux/cpu.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/sysctl.h>\n#include <linux/tick.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/isolation.h>\n#include <linux/stop_machine.h>\n\n#include <asm/irq_regs.h>\n#include <linux/kvm_para.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\n#if defined(CONFIG_HARDLOCKUP_DETECTOR) || defined(CONFIG_HARDLOCKUP_DETECTOR_SPARC64)\n# define WATCHDOG_HARDLOCKUP_DEFAULT\t1\n#else\n# define WATCHDOG_HARDLOCKUP_DEFAULT\t0\n#endif\n\nunsigned long __read_mostly watchdog_enabled;\nint __read_mostly watchdog_user_enabled = 1;\nstatic int __read_mostly watchdog_hardlockup_user_enabled = WATCHDOG_HARDLOCKUP_DEFAULT;\nstatic int __read_mostly watchdog_softlockup_user_enabled = 1;\nint __read_mostly watchdog_thresh = 10;\nstatic int __read_mostly watchdog_hardlockup_available;\n\nstruct cpumask watchdog_cpumask __read_mostly;\nunsigned long *watchdog_cpumask_bits = cpumask_bits(&watchdog_cpumask);\n\n#ifdef CONFIG_HARDLOCKUP_DETECTOR\n\n# ifdef CONFIG_SMP\nint __read_mostly sysctl_hardlockup_all_cpu_backtrace;\n# endif  \n\n \nunsigned int __read_mostly hardlockup_panic =\n\t\t\tIS_ENABLED(CONFIG_BOOTPARAM_HARDLOCKUP_PANIC);\n \nvoid __init hardlockup_detector_disable(void)\n{\n\twatchdog_hardlockup_user_enabled = 0;\n}\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\twatchdog_hardlockup_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\twatchdog_hardlockup_user_enabled = 1;\n\treturn 1;\n}\n__setup(\"nmi_watchdog=\", hardlockup_panic_setup);\n\n#endif  \n\n#if defined(CONFIG_HARDLOCKUP_DETECTOR_COUNTS_HRTIMER)\n\nstatic DEFINE_PER_CPU(atomic_t, hrtimer_interrupts);\nstatic DEFINE_PER_CPU(int, hrtimer_interrupts_saved);\nstatic DEFINE_PER_CPU(bool, watchdog_hardlockup_warned);\nstatic DEFINE_PER_CPU(bool, watchdog_hardlockup_touched);\nstatic unsigned long watchdog_hardlockup_all_cpu_dumped;\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t \n\traw_cpu_write(watchdog_hardlockup_touched, true);\n}\nEXPORT_SYMBOL(arch_touch_nmi_watchdog);\n\nvoid watchdog_hardlockup_touch_cpu(unsigned int cpu)\n{\n\tper_cpu(watchdog_hardlockup_touched, cpu) = true;\n}\n\nstatic bool is_hardlockup(unsigned int cpu)\n{\n\tint hrint = atomic_read(&per_cpu(hrtimer_interrupts, cpu));\n\n\tif (per_cpu(hrtimer_interrupts_saved, cpu) == hrint)\n\t\treturn true;\n\n\t \n\tper_cpu(hrtimer_interrupts_saved, cpu) = hrint;\n\n\treturn false;\n}\n\nstatic void watchdog_hardlockup_kick(void)\n{\n\tint new_interrupts;\n\n\tnew_interrupts = atomic_inc_return(this_cpu_ptr(&hrtimer_interrupts));\n\twatchdog_buddy_check_hardlockup(new_interrupts);\n}\n\nvoid watchdog_hardlockup_check(unsigned int cpu, struct pt_regs *regs)\n{\n\tif (per_cpu(watchdog_hardlockup_touched, cpu)) {\n\t\tper_cpu(watchdog_hardlockup_touched, cpu) = false;\n\t\treturn;\n\t}\n\n\t \n\tif (is_hardlockup(cpu)) {\n\t\tunsigned int this_cpu = smp_processor_id();\n\n\t\t \n\t\tif (per_cpu(watchdog_hardlockup_warned, cpu))\n\t\t\treturn;\n\n\t\tpr_emerg(\"Watchdog detected hard LOCKUP on cpu %d\\n\", cpu);\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tif (cpu == this_cpu) {\n\t\t\tif (regs)\n\t\t\t\tshow_regs(regs);\n\t\t\telse\n\t\t\t\tdump_stack();\n\t\t} else {\n\t\t\ttrigger_single_cpu_backtrace(cpu);\n\t\t}\n\n\t\t \n\t\tif (sysctl_hardlockup_all_cpu_backtrace &&\n\t\t    !test_and_set_bit(0, &watchdog_hardlockup_all_cpu_dumped))\n\t\t\ttrigger_allbutcpu_cpu_backtrace(cpu);\n\n\t\tif (hardlockup_panic)\n\t\t\tnmi_panic(regs, \"Hard LOCKUP\");\n\n\t\tper_cpu(watchdog_hardlockup_warned, cpu) = true;\n\t} else {\n\t\tper_cpu(watchdog_hardlockup_warned, cpu) = false;\n\t}\n}\n\n#else  \n\nstatic inline void watchdog_hardlockup_kick(void) { }\n\n#endif  \n\n \nvoid __weak watchdog_hardlockup_enable(unsigned int cpu) { }\n\nvoid __weak watchdog_hardlockup_disable(unsigned int cpu) { }\n\n \nint __weak __init watchdog_hardlockup_probe(void)\n{\n\treturn -ENODEV;\n}\n\n \nvoid __weak watchdog_hardlockup_stop(void) { }\n\n \nvoid __weak watchdog_hardlockup_start(void) { }\n\n \nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (watchdog_hardlockup_available && watchdog_hardlockup_user_enabled)\n\t\twatchdog_enabled |= WATCHDOG_HARDLOCKUP_ENABLED;\n\tif (watchdog_softlockup_user_enabled)\n\t\twatchdog_enabled |= WATCHDOG_SOFTOCKUP_ENABLED;\n}\n\n#ifdef CONFIG_SOFTLOCKUP_DETECTOR\n\n \n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\n#ifdef CONFIG_SMP\nint __read_mostly sysctl_softlockup_all_cpu_backtrace;\n#endif\n\nstatic struct cpumask watchdog_allowed_mask __read_mostly;\n\n \nunsigned int __read_mostly softlockup_panic =\n\t\t\tIS_ENABLED(CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC);\n\nstatic bool softlockup_initialized __read_mostly;\nstatic u64 __read_mostly sample_period;\n\n \nstatic DEFINE_PER_CPU(unsigned long, watchdog_touch_ts);\n \nstatic DEFINE_PER_CPU(unsigned long, watchdog_report_ts);\nstatic DEFINE_PER_CPU(struct hrtimer, watchdog_hrtimer);\nstatic DEFINE_PER_CPU(bool, softlockup_touch_sync);\nstatic unsigned long soft_lockup_nmi_warn;\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}\n__setup(\"softlockup_panic=\", softlockup_panic_setup);\n\nstatic int __init nowatchdog_setup(char *str)\n{\n\twatchdog_user_enabled = 0;\n\treturn 1;\n}\n__setup(\"nowatchdog\", nowatchdog_setup);\n\nstatic int __init nosoftlockup_setup(char *str)\n{\n\twatchdog_softlockup_user_enabled = 0;\n\treturn 1;\n}\n__setup(\"nosoftlockup\", nosoftlockup_setup);\n\nstatic int __init watchdog_thresh_setup(char *str)\n{\n\tget_option(&str, &watchdog_thresh);\n\treturn 1;\n}\n__setup(\"watchdog_thresh=\", watchdog_thresh_setup);\n\nstatic void __lockup_detector_cleanup(void);\n\n \nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}\n\n \nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;   \n}\n\nstatic void set_sample_period(void)\n{\n\t \n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}\n\nstatic void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}\n\n \nstatic void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}\n\n \nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t \n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}\n\nnotrace void touch_softlockup_watchdog(void)\n{\n\ttouch_softlockup_watchdog_sched();\n\twq_watchdog_touch(raw_smp_processor_id());\n}\nEXPORT_SYMBOL(touch_softlockup_watchdog);\n\nvoid touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t \n\tfor_each_cpu(cpu, &watchdog_allowed_mask) {\n\t\tper_cpu(watchdog_report_ts, cpu) = SOFTLOCKUP_DELAY_REPORT;\n\t\twq_watchdog_touch(cpu);\n\t}\n}\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}\n\nstatic int is_softlockup(unsigned long touch_ts,\n\t\t\t unsigned long period_ts,\n\t\t\t unsigned long now)\n{\n\tif ((watchdog_enabled & WATCHDOG_SOFTOCKUP_ENABLED) && watchdog_thresh) {\n\t\t \n\t\tif (time_after(now, period_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}\n\n \nstatic DEFINE_PER_CPU(struct completion, softlockup_completion);\nstatic DEFINE_PER_CPU(struct cpu_stop_work, softlockup_stop_work);\n\n \nstatic int softlockup_fn(void *data)\n{\n\tupdate_touch_ts();\n\tcomplete(this_cpu_ptr(&softlockup_completion));\n\n\treturn 0;\n}\n\n \nstatic enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tunsigned long touch_ts, period_ts, now;\n\tstruct pt_regs *regs = get_irq_regs();\n\tint duration;\n\tint softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;\n\n\tif (!watchdog_enabled)\n\t\treturn HRTIMER_NORESTART;\n\n\twatchdog_hardlockup_kick();\n\n\t \n\tif (completion_done(this_cpu_ptr(&softlockup_completion))) {\n\t\treinit_completion(this_cpu_ptr(&softlockup_completion));\n\t\tstop_one_cpu_nowait(smp_processor_id(),\n\t\t\t\tsoftlockup_fn, NULL,\n\t\t\t\tthis_cpu_ptr(&softlockup_stop_work));\n\t}\n\n\t \n\thrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));\n\n\t \n\tnow = get_timestamp();\n\t \n\tkvm_check_and_clear_guest_paused();\n\t \n\tperiod_ts = READ_ONCE(*this_cpu_ptr(&watchdog_report_ts));\n\n\t \n\tif (period_ts == SOFTLOCKUP_DELAY_REPORT) {\n\t\tif (unlikely(__this_cpu_read(softlockup_touch_sync))) {\n\t\t\t \n\t\t\t__this_cpu_write(softlockup_touch_sync, false);\n\t\t\tsched_clock_tick();\n\t\t}\n\n\t\tupdate_report_ts();\n\t\treturn HRTIMER_RESTART;\n\t}\n\n\t \n\ttouch_ts = __this_cpu_read(watchdog_touch_ts);\n\tduration = is_softlockup(touch_ts, period_ts, now);\n\tif (unlikely(duration)) {\n\t\t \n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\tif (test_and_set_bit_lock(0, &soft_lockup_nmi_warn))\n\t\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\n\t\t \n\t\tupdate_report_ts();\n\n\t\tpr_emerg(\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\",\n\t\t\tsmp_processor_id(), duration,\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tif (regs)\n\t\t\tshow_regs(regs);\n\t\telse\n\t\t\tdump_stack();\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\ttrigger_allbutcpu_cpu_backtrace(smp_processor_id());\n\t\t\tclear_bit_unlock(0, &soft_lockup_nmi_warn);\n\t\t}\n\n\t\tadd_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);\n\t\tif (softlockup_panic)\n\t\t\tpanic(\"softlockup: hung tasks\");\n\t}\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t \n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t \n\tupdate_touch_ts();\n\t \n\tif (watchdog_enabled & WATCHDOG_HARDLOCKUP_ENABLED)\n\t\twatchdog_hardlockup_enable(cpu);\n}\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t \n\twatchdog_hardlockup_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}\n\nstatic int softlockup_stop_fn(void *data)\n{\n\twatchdog_disable(smp_processor_id());\n\treturn 0;\n}\n\nstatic void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}\n\nstatic int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}\n\nstatic void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}\n\nint lockup_detector_online_cpu(unsigned int cpu)\n{\n\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))\n\t\twatchdog_enable(cpu);\n\treturn 0;\n}\n\nint lockup_detector_offline_cpu(unsigned int cpu)\n{\n\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))\n\t\twatchdog_disable(cpu);\n\treturn 0;\n}\n\nstatic void __lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_hardlockup_stop();\n\n\tsoftlockup_stop_all();\n\tset_sample_period();\n\tlockup_detector_update_enable();\n\tif (watchdog_enabled && watchdog_thresh)\n\t\tsoftlockup_start_all();\n\n\twatchdog_hardlockup_start();\n\tcpus_read_unlock();\n\t \n\t__lockup_detector_cleanup();\n}\n\nvoid lockup_detector_reconfigure(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_reconfigure();\n\tmutex_unlock(&watchdog_mutex);\n}\n\n \nstatic __init void lockup_detector_setup(void)\n{\n\t \n\tlockup_detector_update_enable();\n\n\tif (!IS_ENABLED(CONFIG_SYSCTL) &&\n\t    !(watchdog_enabled && watchdog_thresh))\n\t\treturn;\n\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_reconfigure();\n\tsoftlockup_initialized = true;\n\tmutex_unlock(&watchdog_mutex);\n}\n\n#else  \nstatic void __lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_hardlockup_stop();\n\tlockup_detector_update_enable();\n\twatchdog_hardlockup_start();\n\tcpus_read_unlock();\n}\nvoid lockup_detector_reconfigure(void)\n{\n\t__lockup_detector_reconfigure();\n}\nstatic inline void lockup_detector_setup(void)\n{\n\t__lockup_detector_reconfigure();\n}\n#endif  \n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}\n\n \nvoid lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}\n\n \nvoid lockup_detector_soft_poweroff(void)\n{\n\twatchdog_enabled = 0;\n}\n\n#ifdef CONFIG_SYSCTL\n\n \nstatic void proc_watchdog_update(void)\n{\n\t \n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\t__lockup_detector_reconfigure();\n}\n\n \nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t \n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}\n\n \nint proc_watchdog(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED |\n\t\t\t\t    WATCHDOG_SOFTOCKUP_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}\n\n \nint proc_nmi_watchdog(struct ctl_table *table, int write,\n\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!watchdog_hardlockup_available && write)\n\t\treturn -ENOTSUPP;\n\treturn proc_watchdog_common(WATCHDOG_HARDLOCKUP_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}\n\n \nint proc_soft_watchdog(struct ctl_table *table, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(WATCHDOG_SOFTOCKUP_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}\n\n \nint proc_watchdog_thresh(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old;\n\n\tmutex_lock(&watchdog_mutex);\n\n\told = READ_ONCE(watchdog_thresh);\n\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!err && write && old != READ_ONCE(watchdog_thresh))\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}\n\n \nint proc_watchdog_cpumask(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\tmutex_lock(&watchdog_mutex);\n\n\terr = proc_do_large_bitmap(table, write, buffer, lenp, ppos);\n\tif (!err && write)\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}\n\nstatic const int sixty = 60;\n\nstatic struct ctl_table watchdog_sysctls[] = {\n\t{\n\t\t.procname       = \"watchdog\",\n\t\t.data\t\t= &watchdog_user_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler   = proc_watchdog,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"watchdog_thresh\",\n\t\t.data\t\t= &watchdog_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_watchdog_thresh,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&sixty,\n\t},\n\t{\n\t\t.procname\t= \"watchdog_cpumask\",\n\t\t.data\t\t= &watchdog_cpumask_bits,\n\t\t.maxlen\t\t= NR_CPUS,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_watchdog_cpumask,\n\t},\n#ifdef CONFIG_SOFTLOCKUP_DETECTOR\n\t{\n\t\t.procname       = \"soft_watchdog\",\n\t\t.data\t\t= &watchdog_softlockup_user_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler   = proc_soft_watchdog,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"softlockup_panic\",\n\t\t.data\t\t= &softlockup_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname\t= \"softlockup_all_cpu_backtrace\",\n\t\t.data\t\t= &sysctl_softlockup_all_cpu_backtrace,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif  \n#endif\n#ifdef CONFIG_HARDLOCKUP_DETECTOR\n\t{\n\t\t.procname\t= \"hardlockup_panic\",\n\t\t.data\t\t= &hardlockup_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname\t= \"hardlockup_all_cpu_backtrace\",\n\t\t.data\t\t= &sysctl_hardlockup_all_cpu_backtrace,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif  \n#endif\n\t{}\n};\n\nstatic struct ctl_table watchdog_hardlockup_sysctl[] = {\n\t{\n\t\t.procname       = \"nmi_watchdog\",\n\t\t.data\t\t= &watchdog_hardlockup_user_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler   = proc_nmi_watchdog,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{}\n};\n\nstatic void __init watchdog_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", watchdog_sysctls);\n\n\tif (watchdog_hardlockup_available)\n\t\twatchdog_hardlockup_sysctl[0].mode = 0644;\n\tregister_sysctl_init(\"kernel\", watchdog_hardlockup_sysctl);\n}\n\n#else\n#define watchdog_sysctl_init() do { } while (0)\n#endif  \n\nstatic void __init lockup_detector_delay_init(struct work_struct *work);\nstatic bool allow_lockup_detector_init_retry __initdata;\n\nstatic struct work_struct detector_work __initdata =\n\t\t__WORK_INITIALIZER(detector_work, lockup_detector_delay_init);\n\nstatic void __init lockup_detector_delay_init(struct work_struct *work)\n{\n\tint ret;\n\n\tret = watchdog_hardlockup_probe();\n\tif (ret) {\n\t\tpr_info(\"Delayed init of the lockup detector failed: %d\\n\", ret);\n\t\tpr_info(\"Hard watchdog permanently disabled\\n\");\n\t\treturn;\n\t}\n\n\tallow_lockup_detector_init_retry = false;\n\n\twatchdog_hardlockup_available = true;\n\tlockup_detector_setup();\n}\n\n \nvoid __init lockup_detector_retry_init(void)\n{\n\t \n\tif (!allow_lockup_detector_init_retry)\n\t\treturn;\n\n\tschedule_work(&detector_work);\n}\n\n \nstatic int __init lockup_detector_check(void)\n{\n\t \n\tallow_lockup_detector_init_retry = false;\n\n\t \n\tflush_work(&detector_work);\n\n\twatchdog_sysctl_init();\n\n\treturn 0;\n\n}\nlate_initcall_sync(lockup_detector_check);\n\nvoid __init lockup_detector_init(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tpr_info(\"Disabling watchdog on nohz_full cores by default\\n\");\n\n\tcpumask_copy(&watchdog_cpumask,\n\t\t     housekeeping_cpumask(HK_TYPE_TIMER));\n\n\tif (!watchdog_hardlockup_probe())\n\t\twatchdog_hardlockup_available = true;\n\telse\n\t\tallow_lockup_detector_init_retry = true;\n\n\tlockup_detector_setup();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}