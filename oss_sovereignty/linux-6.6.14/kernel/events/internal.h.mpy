{
  "module_name": "internal.h",
  "hash_id": "1767dc3dc6790c3a2f590b1b70c596f53e47e5a70861d80d17d7c6e3f304f311",
  "original_prompt": "Ingested from linux-6.6.14/kernel/events/internal.h",
  "human_readable_source": " \n#ifndef _KERNEL_EVENTS_INTERNAL_H\n#define _KERNEL_EVENTS_INTERNAL_H\n\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/refcount.h>\n\n \n\n#define RING_BUFFER_WRITABLE\t\t0x01\n\nstruct perf_buffer {\n\trefcount_t\t\t\trefcount;\n\tstruct rcu_head\t\t\trcu_head;\n#ifdef CONFIG_PERF_USE_VMALLOC\n\tstruct work_struct\t\twork;\n\tint\t\t\t\tpage_order;\t \n#endif\n\tint\t\t\t\tnr_pages;\t \n\tint\t\t\t\toverwrite;\t \n\tint\t\t\t\tpaused;\t\t \n\n\tatomic_t\t\t\tpoll;\t\t \n\n\tlocal_t\t\t\t\thead;\t\t \n\tunsigned int\t\t\tnest;\t\t \n\tlocal_t\t\t\t\tevents;\t\t \n\tlocal_t\t\t\t\twakeup;\t\t \n\tlocal_t\t\t\t\tlost;\t\t \n\n\tlong\t\t\t\twatermark;\t \n\tlong\t\t\t\taux_watermark;\n\t \n\tspinlock_t\t\t\tevent_lock;\n\tstruct list_head\t\tevent_list;\n\n\tatomic_t\t\t\tmmap_count;\n\tunsigned long\t\t\tmmap_locked;\n\tstruct user_struct\t\t*mmap_user;\n\n\t \n\tlong\t\t\t\taux_head;\n\tunsigned int\t\t\taux_nest;\n\tlong\t\t\t\taux_wakeup;\t \n\tunsigned long\t\t\taux_pgoff;\n\tint\t\t\t\taux_nr_pages;\n\tint\t\t\t\taux_overwrite;\n\tatomic_t\t\t\taux_mmap_count;\n\tunsigned long\t\t\taux_mmap_locked;\n\tvoid\t\t\t\t(*free_aux)(void *);\n\trefcount_t\t\t\taux_refcount;\n\tint\t\t\t\taux_in_sampling;\n\tvoid\t\t\t\t**aux_pages;\n\tvoid\t\t\t\t*aux_priv;\n\n\tstruct perf_event_mmap_page\t*user_page;\n\tvoid\t\t\t\t*data_pages[];\n};\n\nextern void rb_free(struct perf_buffer *rb);\n\nstatic inline void rb_free_rcu(struct rcu_head *rcu_head)\n{\n\tstruct perf_buffer *rb;\n\n\trb = container_of(rcu_head, struct perf_buffer, rcu_head);\n\trb_free(rb);\n}\n\nstatic inline void rb_toggle_paused(struct perf_buffer *rb, bool pause)\n{\n\tif (!pause && rb->nr_pages)\n\t\trb->paused = 0;\n\telse\n\t\trb->paused = 1;\n}\n\nextern struct perf_buffer *\nrb_alloc(int nr_pages, long watermark, int cpu, int flags);\nextern void perf_event_wakeup(struct perf_event *event);\nextern int rb_alloc_aux(struct perf_buffer *rb, struct perf_event *event,\n\t\t\tpgoff_t pgoff, int nr_pages, long watermark, int flags);\nextern void rb_free_aux(struct perf_buffer *rb);\nextern struct perf_buffer *ring_buffer_get(struct perf_event *event);\nextern void ring_buffer_put(struct perf_buffer *rb);\n\nstatic inline bool rb_has_aux(struct perf_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags);\n\nextern struct page *\nperf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff);\n\n#ifdef CONFIG_PERF_USE_VMALLOC\n \n\nstatic inline int page_order(struct perf_buffer *rb)\n{\n\treturn rb->page_order;\n}\n\n#else\n\nstatic inline int page_order(struct perf_buffer *rb)\n{\n\treturn 0;\n}\n#endif\n\nstatic inline int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}\n\nstatic inline unsigned long perf_data_size(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}\n\nstatic inline unsigned long perf_aux_size(struct perf_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}\n\n#define __DEFINE_OUTPUT_COPY_BODY(advance_buf, memcpy_func, ...)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long size, written;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tsize    = min(handle->size, len);\t\t\t\\\n\t\twritten = memcpy_func(__VA_ARGS__);\t\t\t\\\n\t\twritten = size - written;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tlen -= written;\t\t\t\t\t\t\\\n\t\thandle->addr += written;\t\t\t\t\\\n\t\tif (advance_buf)\t\t\t\t\t\\\n\t\t\tbuf += written;\t\t\t\t\t\\\n\t\thandle->size -= written;\t\t\t\t\\\n\t\tif (!handle->size) {\t\t\t\t\t\\\n\t\t\tstruct perf_buffer *rb = handle->rb;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\thandle->page++;\t\t\t\t\t\\\n\t\t\thandle->page &= rb->nr_pages - 1;\t\t\\\n\t\t\thandle->addr = rb->data_pages[handle->page];\t\\\n\t\t\thandle->size = PAGE_SIZE << page_order(rb);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (len && written == size);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\n#define DEFINE_OUTPUT_COPY(func_name, memcpy_func)\t\t\t\\\nstatic inline unsigned long\t\t\t\t\t\t\\\nfunc_name(struct perf_output_handle *handle,\t\t\t\t\\\n\t  const void *buf, unsigned long len)\t\t\t\t\\\n__DEFINE_OUTPUT_COPY_BODY(true, memcpy_func, handle->addr, buf, size)\n\nstatic inline unsigned long\n__output_custom(struct perf_output_handle *handle, perf_copy_f copy_func,\n\t\tconst void *buf, unsigned long len)\n{\n\tunsigned long orig_len = len;\n\t__DEFINE_OUTPUT_COPY_BODY(false, copy_func, handle->addr, buf,\n\t\t\t\t  orig_len - len, size)\n}\n\nstatic inline unsigned long\nmemcpy_common(void *dst, const void *src, unsigned long n)\n{\n\tmemcpy(dst, src, n);\n\treturn 0;\n}\n\nDEFINE_OUTPUT_COPY(__output_copy, memcpy_common)\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}\n\nDEFINE_OUTPUT_COPY(__output_skip, memcpy_skip)\n\n#ifndef arch_perf_out_copy_user\n#define arch_perf_out_copy_user arch_perf_out_copy_user\n\nstatic inline unsigned long\narch_perf_out_copy_user(void *dst, const void *src, unsigned long n)\n{\n\tunsigned long ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\treturn ret;\n}\n#endif\n\nDEFINE_OUTPUT_COPY(__output_copy_user, arch_perf_out_copy_user)\n\nstatic inline int get_recursion_context(int *recursion)\n{\n\tunsigned char rctx = interrupt_context_level();\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}\n\nstatic inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}\n\n#ifdef CONFIG_HAVE_PERF_USER_STACK_DUMP\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn true;\n}\n\n#define perf_user_stack_pointer(regs) user_stack_pointer(regs)\n#else\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn false;\n}\n\n#define perf_user_stack_pointer(regs) 0\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}