{
  "module_name": "hw_breakpoint_test.c",
  "hash_id": "1accf7ebaea0379b2923e94a9fad7d15699b16e406328ed4dab9bf5aa9c3cfbd",
  "original_prompt": "Ingested from linux-6.6.14/kernel/events/hw_breakpoint_test.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include <linux/cpumask.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/kthread.h>\n#include <linux/perf_event.h>\n#include <asm/hw_breakpoint.h>\n\n#define TEST_REQUIRES_BP_SLOTS(test, slots)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\\\n\t\tif ((slots) > get_test_bp_slots()) {\t\t\t\t\t\\\n\t\t\tkunit_skip((test), \"Requires breakpoint slots: %d > %d\", slots,\t\\\n\t\t\t\t   get_test_bp_slots());\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define TEST_EXPECT_NOSPC(expr) KUNIT_EXPECT_EQ(test, -ENOSPC, PTR_ERR(expr))\n\n#define MAX_TEST_BREAKPOINTS 512\n\nstatic char break_vars[MAX_TEST_BREAKPOINTS];\nstatic struct perf_event *test_bps[MAX_TEST_BREAKPOINTS];\nstatic struct task_struct *__other_task;\n\nstatic struct perf_event *register_test_bp(int cpu, struct task_struct *tsk, int idx)\n{\n\tstruct perf_event_attr attr = {};\n\n\tif (WARN_ON(idx < 0 || idx >= MAX_TEST_BREAKPOINTS))\n\t\treturn NULL;\n\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)&break_vars[idx];\n\tattr.bp_len = HW_BREAKPOINT_LEN_1;\n\tattr.bp_type = HW_BREAKPOINT_RW;\n\treturn perf_event_create_kernel_counter(&attr, cpu, tsk, NULL, NULL);\n}\n\nstatic void unregister_test_bp(struct perf_event **bp)\n{\n\tif (WARN_ON(IS_ERR(*bp)))\n\t\treturn;\n\tif (WARN_ON(!*bp))\n\t\treturn;\n\tunregister_hw_breakpoint(*bp);\n\t*bp = NULL;\n}\n\nstatic int get_test_bp_slots(void)\n{\n\tstatic int slots;\n\n\tif (!slots)\n\t\tslots = hw_breakpoint_slots(TYPE_DATA);\n\n\treturn slots;\n}\n\nstatic void fill_one_bp_slot(struct kunit *test, int *id, int cpu, struct task_struct *tsk)\n{\n\tstruct perf_event *bp = register_test_bp(cpu, tsk, *id);\n\n\tKUNIT_ASSERT_NOT_NULL(test, bp);\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(bp));\n\tKUNIT_ASSERT_NULL(test, test_bps[*id]);\n\ttest_bps[(*id)++] = bp;\n}\n\n \nstatic bool fill_bp_slots(struct kunit *test, int *id, int cpu, struct task_struct *tsk, int skip)\n{\n\tfor (int i = 0; i < get_test_bp_slots() - skip; ++i)\n\t\tfill_one_bp_slot(test, id, cpu, tsk);\n\n\treturn *id + get_test_bp_slots() <= MAX_TEST_BREAKPOINTS;\n}\n\nstatic int dummy_kthread(void *arg)\n{\n\treturn 0;\n}\n\nstatic struct task_struct *get_other_task(struct kunit *test)\n{\n\tstruct task_struct *tsk;\n\n\tif (__other_task)\n\t\treturn __other_task;\n\n\ttsk = kthread_create(dummy_kthread, NULL, \"hw_breakpoint_dummy_task\");\n\tKUNIT_ASSERT_FALSE(test, IS_ERR(tsk));\n\t__other_task = tsk;\n\treturn __other_task;\n}\n\nstatic int get_test_cpu(int num)\n{\n\tint cpu;\n\n\tWARN_ON(num < 0);\n\n\tfor_each_online_cpu(cpu) {\n\t\tif (num-- <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn cpu;\n}\n\n \n\nstatic void test_one_cpu(struct kunit *test)\n{\n\tint idx = 0;\n\n\tfill_bp_slots(test, &idx, get_test_cpu(0), NULL, 0);\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n}\n\nstatic void test_many_cpus(struct kunit *test)\n{\n\tint idx = 0;\n\tint cpu;\n\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tbool do_continue = fill_bp_slots(test, &idx, cpu, NULL, 0);\n\n\t\tTEST_EXPECT_NOSPC(register_test_bp(cpu, NULL, idx));\n\t\tif (!do_continue)\n\t\t\tbreak;\n\t}\n}\n\nstatic void test_one_task_on_all_cpus(struct kunit *test)\n{\n\tint idx = 0;\n\n\tfill_bp_slots(test, &idx, -1, current, 0);\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\t \n\tunregister_test_bp(&test_bps[0]);\n\tfill_one_bp_slot(test, &idx, get_test_cpu(0), NULL);\n}\n\nstatic void test_two_tasks_on_all_cpus(struct kunit *test)\n{\n\tint idx = 0;\n\n\t \n\tfill_bp_slots(test, &idx, -1, current, 0);\n\tfill_bp_slots(test, &idx, -1, get_other_task(test), 0);\n\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, get_other_task(test), idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), get_other_task(test), idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\t \n\tunregister_test_bp(&test_bps[0]);\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n}\n\nstatic void test_one_task_on_one_cpu(struct kunit *test)\n{\n\tint idx = 0;\n\n\tfill_bp_slots(test, &idx, get_test_cpu(0), current, 0);\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\t \n\tunregister_test_bp(&test_bps[0]);\n\tfill_one_bp_slot(test, &idx, get_test_cpu(0), NULL);\n}\n\nstatic void test_one_task_mixed(struct kunit *test)\n{\n\tint idx = 0;\n\n\tTEST_REQUIRES_BP_SLOTS(test, 3);\n\n\tfill_one_bp_slot(test, &idx, get_test_cpu(0), current);\n\tfill_bp_slots(test, &idx, -1, current, 1);\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\n\t \n\tunregister_test_bp(&test_bps[0]);\n\tunregister_test_bp(&test_bps[1]);\n\tfill_one_bp_slot(test, &idx, get_test_cpu(0), NULL);\n\tfill_one_bp_slot(test, &idx, get_test_cpu(0), NULL);\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n}\n\nstatic void test_two_tasks_on_one_cpu(struct kunit *test)\n{\n\tint idx = 0;\n\n\tfill_bp_slots(test, &idx, get_test_cpu(0), current, 0);\n\tfill_bp_slots(test, &idx, get_test_cpu(0), get_other_task(test), 0);\n\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, get_other_task(test), idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), get_other_task(test), idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\t \n\tfill_bp_slots(test, &idx, get_test_cpu(1), NULL, 0);\n}\n\nstatic void test_two_tasks_on_one_all_cpus(struct kunit *test)\n{\n\tint idx = 0;\n\n\tfill_bp_slots(test, &idx, get_test_cpu(0), current, 0);\n\tfill_bp_slots(test, &idx, -1, get_other_task(test), 0);\n\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, get_other_task(test), idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), get_other_task(test), idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\t \n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(1), NULL, idx));\n}\n\nstatic void test_task_on_all_and_one_cpu(struct kunit *test)\n{\n\tint tsk_on_cpu_idx, cpu_idx;\n\tint idx = 0;\n\n\tTEST_REQUIRES_BP_SLOTS(test, 3);\n\n\tfill_bp_slots(test, &idx, -1, current, 2);\n\t \n\ttsk_on_cpu_idx = idx;\n\tfill_one_bp_slot(test, &idx, get_test_cpu(0), current);\n\tfill_one_bp_slot(test, &idx, -1, current);\n\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\n\t \n\tcpu_idx = idx;\n\tfill_one_bp_slot(test, &idx, get_test_cpu(1), NULL);\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(1), NULL, idx));\n\n\t \n\tunregister_test_bp(&test_bps[tsk_on_cpu_idx]);\n\t \n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\t \n\tunregister_test_bp(&test_bps[cpu_idx]);\n\tfill_one_bp_slot(test, &idx, -1, current);\n\n\tTEST_EXPECT_NOSPC(register_test_bp(-1, current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), current, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(0), NULL, idx));\n\tTEST_EXPECT_NOSPC(register_test_bp(get_test_cpu(1), NULL, idx));\n}\n\nstatic struct kunit_case hw_breakpoint_test_cases[] = {\n\tKUNIT_CASE(test_one_cpu),\n\tKUNIT_CASE(test_many_cpus),\n\tKUNIT_CASE(test_one_task_on_all_cpus),\n\tKUNIT_CASE(test_two_tasks_on_all_cpus),\n\tKUNIT_CASE(test_one_task_on_one_cpu),\n\tKUNIT_CASE(test_one_task_mixed),\n\tKUNIT_CASE(test_two_tasks_on_one_cpu),\n\tKUNIT_CASE(test_two_tasks_on_one_all_cpus),\n\tKUNIT_CASE(test_task_on_all_and_one_cpu),\n\t{},\n};\n\nstatic int test_init(struct kunit *test)\n{\n\t \n\tif (num_online_cpus() < 2)\n\t\tkunit_skip(test, \"not enough cpus\");\n\n\t \n\tif (hw_breakpoint_is_used())\n\t\tkunit_skip(test, \"hw breakpoint already in use\");\n\n\treturn 0;\n}\n\nstatic void test_exit(struct kunit *test)\n{\n\tfor (int i = 0; i < MAX_TEST_BREAKPOINTS; ++i) {\n\t\tif (test_bps[i])\n\t\t\tunregister_test_bp(&test_bps[i]);\n\t}\n\n\tif (__other_task) {\n\t\tkthread_stop(__other_task);\n\t\t__other_task = NULL;\n\t}\n\n\t \n\tKUNIT_EXPECT_FALSE(test, hw_breakpoint_is_used());\n}\n\nstatic struct kunit_suite hw_breakpoint_test_suite = {\n\t.name = \"hw_breakpoint\",\n\t.test_cases = hw_breakpoint_test_cases,\n\t.init = test_init,\n\t.exit = test_exit,\n};\n\nkunit_test_suites(&hw_breakpoint_test_suite);\n\nMODULE_AUTHOR(\"Marco Elver <elver@google.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}