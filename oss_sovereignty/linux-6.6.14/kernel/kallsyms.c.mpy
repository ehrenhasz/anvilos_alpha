{
  "module_name": "kallsyms.c",
  "hash_id": "097315a4bb6c087a98ef76e6336ca9952d59e64754cbb8df192f17dc8a172fd8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kallsyms.c",
  "human_readable_source": "\n \n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/kdb.h>\n#include <linux/err.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\t \n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/ftrace.h>\n#include <linux/kprobes.h>\n#include <linux/build_bug.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/bsearch.h>\n#include <linux/btf_ids.h>\n\n#include \"kallsyms_internal.h\"\n\n \nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t \n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\toff++;\n\n\t \n\tif ((len & 0x80) != 0) {\n\t\tlen = (len & 0x7F) | (*data << 7);\n\t\tdata++;\n\t\toff++;\n\t}\n\n\t \n\toff += len;\n\n\t \n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t \n\treturn off;\n}\n\n \nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t \n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}\n\n\n \nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i, len;\n\n\t \n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t \n\tfor (i = 0; i < (pos & 0xFF); i++) {\n\t\tlen = *name;\n\n\t\t \n\t\tif ((len & 0x80) != 0)\n\t\t\tlen = ((len & 0x7F) | (name[1] << 7)) + 1;\n\n\t\tname = name + len + 1;\n\t}\n\n\treturn name - kallsyms_names;\n}\n\nunsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t \n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t \n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t \n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}\n\nstatic void cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn;\n\n\t \n\tres = strstr(s, \".llvm.\");\n\tif (res)\n\t\t*res = '\\0';\n\n\treturn;\n}\n\nstatic int compare_symbol_name(const char *name, char *namebuf)\n{\n\t \n\tcleanup_symbol_name(namebuf);\n\treturn strcmp(name, namebuf);\n}\n\nstatic unsigned int get_symbol_seq(int index)\n{\n\tunsigned int i, seq = 0;\n\n\tfor (i = 0; i < 3; i++)\n\t\tseq = (seq << 8) | kallsyms_seqs_of_names[3 * index + i];\n\n\treturn seq;\n}\n\nstatic int kallsyms_lookup_names(const char *name,\n\t\t\t\t unsigned int *start,\n\t\t\t\t unsigned int *end)\n{\n\tint ret;\n\tint low, mid, high;\n\tunsigned int seq, off;\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tlow = 0;\n\thigh = kallsyms_num_syms - 1;\n\n\twhile (low <= high) {\n\t\tmid = low + (high - low) / 2;\n\t\tseq = get_symbol_seq(mid);\n\t\toff = get_symbol_offset(seq);\n\t\tkallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tret = compare_symbol_name(name, namebuf);\n\t\tif (ret > 0)\n\t\t\tlow = mid + 1;\n\t\telse if (ret < 0)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (low > high)\n\t\treturn -ESRCH;\n\n\tlow = mid;\n\twhile (low) {\n\t\tseq = get_symbol_seq(low - 1);\n\t\toff = get_symbol_offset(seq);\n\t\tkallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tif (compare_symbol_name(name, namebuf))\n\t\t\tbreak;\n\t\tlow--;\n\t}\n\t*start = low;\n\n\tif (end) {\n\t\thigh = mid;\n\t\twhile (high < kallsyms_num_syms - 1) {\n\t\t\tseq = get_symbol_seq(high + 1);\n\t\t\toff = get_symbol_offset(seq);\n\t\t\tkallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\t\tif (compare_symbol_name(name, namebuf))\n\t\t\t\tbreak;\n\t\t\thigh++;\n\t\t}\n\t\t*end = high;\n\t}\n\n\treturn 0;\n}\n\n \nunsigned long kallsyms_lookup_name(const char *name)\n{\n\tint ret;\n\tunsigned int i;\n\n\t \n\tif (!*name)\n\t\treturn 0;\n\n\tret = kallsyms_lookup_names(name, &i, NULL);\n\tif (!ret)\n\t\treturn kallsyms_sym_address(get_symbol_seq(i));\n\n\treturn module_kallsyms_lookup_name(name);\n}\n\n \nint kallsyms_on_each_symbol(int (*fn)(void *, const char *, unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tret = fn(data, namebuf, kallsyms_sym_address(i));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}\n\nint kallsyms_on_each_match_symbol(int (*fn)(void *, unsigned long),\n\t\t\t\t  const char *name, void *data)\n{\n\tint ret;\n\tunsigned int i, start, end;\n\n\tret = kallsyms_lookup_names(name, &start, &end);\n\tif (ret)\n\t\treturn 0;\n\n\tfor (i = start; !ret && i <= end; i++) {\n\t\tret = fn(data, kallsyms_sym_address(get_symbol_seq(i)));\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t \n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t \n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t \n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t \n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}\n\n \nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}\n\nstatic const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t \n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t \n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}\n\n \nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}\n\nint lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t \n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t \n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}\n\n \nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t \n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}\n\n \nint sprint_symbol(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1, 0);\n}\nEXPORT_SYMBOL_GPL(sprint_symbol);\n\n \nint sprint_symbol_build_id(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1, 1);\n}\nEXPORT_SYMBOL_GPL(sprint_symbol_build_id);\n\n \nint sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0, 0);\n}\nEXPORT_SYMBOL_GPL(sprint_symbol_no_offset);\n\n \nint sprint_backtrace(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1, 0);\n}\n\n \nint sprint_backtrace_build_id(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1, 1);\n}\n\n \nstruct kallsym_iter {\n\tloff_t pos;\n\tloff_t pos_mod_end;\n\tloff_t pos_ftrace_mod_end;\n\tloff_t pos_bpf_end;\n\tunsigned long value;\n\tunsigned int nameoff;  \n\tchar type;\n\tchar name[KSYM_NAME_LEN];\n\tchar module_name[MODULE_NAME_LEN];\n\tint exported;\n\tint show_value;\n};\n\nstatic int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\tint ret;\n\n\tstrscpy(iter->module_name, \"bpf\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\tret = bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t      &iter->value, &iter->type,\n\t\t\t      iter->name);\n\tif (ret < 0) {\n\t\titer->pos_bpf_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int get_ksymbol_kprobe(struct kallsym_iter *iter)\n{\n\tstrscpy(iter->module_name, \"__builtin__kprobes\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\treturn kprobe_get_kallsym(iter->pos - iter->pos_bpf_end,\n\t\t\t\t  &iter->value, &iter->type,\n\t\t\t\t  iter->name) < 0 ? 0 : 1;\n}\n\n \nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}\n\n \nstatic int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_bpf_end || iter->pos_bpf_end > pos) &&\n\t    get_ksymbol_bpf(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_kprobe(iter);\n}\n\n \nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t \n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t \n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}\n\nstatic void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\t(*pos)++;\n\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn p;\n}\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn m->private;\n}\n\nstatic void s_stop(struct seq_file *m, void *p)\n{\n}\n\nstatic int s_show(struct seq_file *m, void *p)\n{\n\tvoid *value;\n\tstruct kallsym_iter *iter = m->private;\n\n\t \n\tif (!iter->name[0])\n\t\treturn 0;\n\n\tvalue = iter->show_value ? (void *)iter->value : NULL;\n\n\tif (iter->module_name[0]) {\n\t\tchar type;\n\n\t\t \n\t\ttype = iter->exported ? toupper(iter->type) :\n\t\t\t\t\ttolower(iter->type);\n\t\tseq_printf(m, \"%px %c %s\\t[%s]\\n\", value,\n\t\t\t   type, iter->name, iter->module_name);\n\t} else\n\t\tseq_printf(m, \"%px %c %s\\n\", value,\n\t\t\t   iter->type, iter->name);\n\treturn 0;\n}\n\nstatic const struct seq_operations kallsyms_op = {\n\t.start = s_start,\n\t.next = s_next,\n\t.stop = s_stop,\n\t.show = s_show\n};\n\n#ifdef CONFIG_BPF_SYSCALL\n\nstruct bpf_iter__ksym {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct kallsym_iter *, ksym);\n};\n\nstatic int ksym_prog_seq_show(struct seq_file *m, bool in_stop)\n{\n\tstruct bpf_iter__ksym ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = m;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.ksym = m ? m->private : NULL;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}\n\nstatic int bpf_iter_ksym_seq_show(struct seq_file *m, void *p)\n{\n\treturn ksym_prog_seq_show(m, false);\n}\n\nstatic void bpf_iter_ksym_seq_stop(struct seq_file *m, void *p)\n{\n\tif (!p)\n\t\t(void) ksym_prog_seq_show(m, true);\n\telse\n\t\ts_stop(m, p);\n}\n\nstatic const struct seq_operations bpf_iter_ksym_ops = {\n\t.start = s_start,\n\t.next = s_next,\n\t.stop = bpf_iter_ksym_seq_stop,\n\t.show = bpf_iter_ksym_seq_show,\n};\n\nstatic int bpf_iter_ksym_init(void *priv_data, struct bpf_iter_aux_info *aux)\n{\n\tstruct kallsym_iter *iter = priv_data;\n\n\treset_iter(iter, 0);\n\n\t \n\titer->show_value = kallsyms_show_value(current_cred());\n\n\treturn 0;\n}\n\nDEFINE_BPF_ITER_FUNC(ksym, struct bpf_iter_meta *meta, struct kallsym_iter *ksym)\n\nstatic const struct bpf_iter_seq_info ksym_iter_seq_info = {\n\t.seq_ops\t\t= &bpf_iter_ksym_ops,\n\t.init_seq_private\t= bpf_iter_ksym_init,\n\t.fini_seq_private\t= NULL,\n\t.seq_priv_size\t\t= sizeof(struct kallsym_iter),\n};\n\nstatic struct bpf_iter_reg ksym_iter_reg_info = {\n\t.target                 = \"ksym\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__ksym, ksym),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &ksym_iter_seq_info,\n};\n\nBTF_ID_LIST(btf_ksym_iter_id)\nBTF_ID(struct, kallsym_iter)\n\nstatic int __init bpf_ksym_iter_register(void)\n{\n\tksym_iter_reg_info.ctx_arg_info[0].btf_id = *btf_ksym_iter_id;\n\treturn bpf_iter_reg_target(&ksym_iter_reg_info);\n}\n\nlate_initcall(bpf_ksym_iter_register);\n\n#endif  \n\nstatic int kallsyms_open(struct inode *inode, struct file *file)\n{\n\t \n\tstruct kallsym_iter *iter;\n\titer = __seq_open_private(file, &kallsyms_op, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\treset_iter(iter, 0);\n\n\t \n\titer->show_value = kallsyms_show_value(file->f_cred);\n\treturn 0;\n}\n\n#ifdef\tCONFIG_KGDB_KDB\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t \n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}\n#endif\t \n\nstatic const struct proc_ops kallsyms_proc_ops = {\n\t.proc_open\t= kallsyms_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release_private,\n};\n\nstatic int __init kallsyms_init(void)\n{\n\tproc_create(\"kallsyms\", 0444, NULL, &kallsyms_proc_ops);\n\treturn 0;\n}\ndevice_initcall(kallsyms_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}