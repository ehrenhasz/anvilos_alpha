{
  "module_name": "umh.c",
  "hash_id": "3889a6d25dbbd5b8e4c37ffabe71a3c348f868c662620c0765d86e00a85ab5eb",
  "original_prompt": "Ingested from linux-6.6.14/kernel/umh.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/binfmts.h>\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/cred.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/fs_struct.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/resource.h>\n#include <linux/notifier.h>\n#include <linux/suspend.h>\n#include <linux/rwsem.h>\n#include <linux/ptrace.h>\n#include <linux/async.h>\n#include <linux/uaccess.h>\n#include <linux/initrd.h>\n#include <linux/freezer.h>\n\n#include <trace/events/module.h>\n\nstatic kernel_cap_t usermodehelper_bset = CAP_FULL_SET;\nstatic kernel_cap_t usermodehelper_inheritable = CAP_FULL_SET;\nstatic DEFINE_SPINLOCK(umh_sysctl_lock);\nstatic DECLARE_RWSEM(umhelper_sem);\n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}\n\nstatic void umh_complete(struct subprocess_info *sub_info)\n{\n\tstruct completion *comp = xchg(&sub_info->complete, NULL);\n\t \n\tif (comp)\n\t\tcomplete(comp);\n\telse\n\t\tcall_usermodehelper_freeinfo(sub_info);\n}\n\n \nstatic int call_usermodehelper_exec_async(void *data)\n{\n\tstruct subprocess_info *sub_info = data;\n\tstruct cred *new;\n\tint retval;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tflush_signal_handlers(current, 1);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t \n\tcurrent->fs->umask = 0022;\n\n\t \n\tset_user_nice(current, 0);\n\n\tretval = -ENOMEM;\n\tnew = prepare_kernel_cred(current);\n\tif (!new)\n\t\tgoto out;\n\n\tspin_lock(&umh_sysctl_lock);\n\tnew->cap_bset = cap_intersect(usermodehelper_bset, new->cap_bset);\n\tnew->cap_inheritable = cap_intersect(usermodehelper_inheritable,\n\t\t\t\t\t     new->cap_inheritable);\n\tspin_unlock(&umh_sysctl_lock);\n\n\tif (sub_info->init) {\n\t\tretval = sub_info->init(sub_info, new);\n\t\tif (retval) {\n\t\t\tabort_creds(new);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcommit_creds(new);\n\n\twait_for_initramfs();\n\tretval = kernel_execve(sub_info->path,\n\t\t\t       (const char *const *)sub_info->argv,\n\t\t\t       (const char *const *)sub_info->envp);\nout:\n\tsub_info->retval = retval;\n\t \n\tif (!(sub_info->wait & UMH_WAIT_PROC))\n\t\tumh_complete(sub_info);\n\tif (!retval)\n\t\treturn 0;\n\tdo_exit(0);\n}\n\n \nstatic void call_usermodehelper_exec_sync(struct subprocess_info *sub_info)\n{\n\tpid_t pid;\n\n\t \n\tkernel_sigaction(SIGCHLD, SIG_DFL);\n\tpid = user_mode_thread(call_usermodehelper_exec_async, sub_info, SIGCHLD);\n\tif (pid < 0)\n\t\tsub_info->retval = pid;\n\telse\n\t\tkernel_wait(pid, &sub_info->retval);\n\n\t \n\tkernel_sigaction(SIGCHLD, SIG_IGN);\n\tumh_complete(sub_info);\n}\n\n \nstatic void call_usermodehelper_exec_work(struct work_struct *work)\n{\n\tstruct subprocess_info *sub_info =\n\t\tcontainer_of(work, struct subprocess_info, work);\n\n\tif (sub_info->wait & UMH_WAIT_PROC) {\n\t\tcall_usermodehelper_exec_sync(sub_info);\n\t} else {\n\t\tpid_t pid;\n\t\t \n\t\tpid = user_mode_thread(call_usermodehelper_exec_async, sub_info,\n\t\t\t\t       CLONE_PARENT | SIGCHLD);\n\t\tif (pid < 0) {\n\t\t\tsub_info->retval = pid;\n\t\t\tumh_complete(sub_info);\n\t\t}\n\t}\n}\n\n \nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\n \nstatic atomic_t running_helpers = ATOMIC_INIT(0);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\n \n#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)\n\nint usermodehelper_read_trylock(void)\n{\n\tDEFINE_WAIT(wait);\n\tint ret = 0;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tif (usermodehelper_disabled == UMH_DISABLED)\n\t\t\tret = -EAGAIN;\n\n\t\tup_read(&umhelper_sem);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tschedule();\n\t\ttry_to_freeze();\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usermodehelper_read_trylock);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}\nEXPORT_SYMBOL_GPL(usermodehelper_read_lock_wait);\n\nvoid usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}\nEXPORT_SYMBOL_GPL(usermodehelper_read_unlock);\n\n \nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}\n\n \nint __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t \n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}\n\n \nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}\nEXPORT_SYMBOL(call_usermodehelper_setup);\n\n \nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tunsigned int state = TASK_UNINTERRUPTIBLE;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t \n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t \n\t\tgoto unlock;\n\n\tif (wait & UMH_FREEZABLE)\n\t\tstate |= TASK_FREEZABLE;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_state(&done, state | TASK_KILLABLE);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t \n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\n\t\t \n\t}\n\twait_for_completion_state(&done, state);\n\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}\nEXPORT_SYMBOL(call_usermodehelper_exec);\n\n \nint call_usermodehelper(const char *path, char **argv, char **envp, int wait)\n{\n\tstruct subprocess_info *info;\n\tgfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, gfp_mask,\n\t\t\t\t\t NULL, NULL, NULL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\n\treturn call_usermodehelper_exec(info, wait);\n}\nEXPORT_SYMBOL(call_usermodehelper);\n\n#if defined(CONFIG_SYSCTL)\nstatic int proc_cap_handler(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long cap_array[2];\n\tkernel_cap_t new_cap, *cap;\n\tint err;\n\n\tif (write && (!capable(CAP_SETPCAP) ||\n\t\t      !capable(CAP_SYS_MODULE)))\n\t\treturn -EPERM;\n\n\t \n\tcap = table->data;\n\tspin_lock(&umh_sysctl_lock);\n\tcap_array[0] = (u32) cap->val;\n\tcap_array[1] = cap->val >> 32;\n\tspin_unlock(&umh_sysctl_lock);\n\n\tt = *table;\n\tt.data = &cap_array;\n\n\t \n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\tnew_cap.val = (u32)cap_array[0];\n\tnew_cap.val += (u64)cap_array[1] << 32;\n\n\t \n\tif (write) {\n\t\tspin_lock(&umh_sysctl_lock);\n\t\t*cap = cap_intersect(*cap, new_cap);\n\t\tspin_unlock(&umh_sysctl_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic struct ctl_table usermodehelper_table[] = {\n\t{\n\t\t.procname\t= \"bset\",\n\t\t.data\t\t= &usermodehelper_bset,\n\t\t.maxlen\t\t= 2 * sizeof(unsigned long),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_cap_handler,\n\t},\n\t{\n\t\t.procname\t= \"inheritable\",\n\t\t.data\t\t= &usermodehelper_inheritable,\n\t\t.maxlen\t\t= 2 * sizeof(unsigned long),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_cap_handler,\n\t},\n\t{ }\n};\n\nstatic int __init init_umh_sysctls(void)\n{\n\tregister_sysctl_init(\"kernel/usermodehelper\", usermodehelper_table);\n\treturn 0;\n}\nearly_initcall(init_umh_sysctls);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}