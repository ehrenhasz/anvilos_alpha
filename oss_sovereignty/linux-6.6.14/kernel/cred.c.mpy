{
  "module_name": "cred.c",
  "hash_id": "b85f9831745ec2a57c241f1094bc21f517fef67b69ca6fbabfd1304edda25472",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cred.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"CRED: \" fmt\n\n#include <linux/export.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/sched/coredump.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/init_task.h>\n#include <linux/security.h>\n#include <linux/binfmts.h>\n#include <linux/cn_proc.h>\n#include <linux/uidgid.h>\n\n#if 0\n#define kdebug(FMT, ...)\t\t\t\t\t\t\\\n\tprintk(\"[%-5.5s%5u] \" FMT \"\\n\",\t\t\t\t\t\\\n\t       current->comm, current->pid, ##__VA_ARGS__)\n#else\n#define kdebug(FMT, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\tno_printk(\"[%-5.5s%5u] \" FMT \"\\n\",\t\t\t\\\n\t\t\t  current->comm, current->pid, ##__VA_ARGS__);\t\\\n} while (0)\n#endif\n\nstatic struct kmem_cache *cred_jar;\n\n \nstatic struct group_info init_groups = { .usage = ATOMIC_INIT(2) };\n\n \nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n\t.ucounts\t\t= &init_ucounts,\n};\n\n \nstatic void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n\tif (atomic_long_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %ld\\n\",\n\t\t      cred, atomic_long_read(&cred->usage));\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tif (cred->ucounts)\n\t\tput_ucounts(cred->ucounts);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}\n\n \nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%ld})\", cred,\n\t       atomic_long_read(&cred->usage));\n\n\tBUG_ON(atomic_long_read(&cred->usage) != 0);\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}\nEXPORT_SYMBOL(__put_cred);\n\n \nvoid exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%ld})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_long_read(&tsk->cred->usage));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tput_cred(cred);\n\n#ifdef CONFIG_KEYS_REQUEST_CACHE\n\tkey_put(tsk->cached_requested_key);\n\ttsk->cached_requested_key = NULL;\n#endif\n}\n\n \nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!get_cred_rcu(cred));\n\n\trcu_read_unlock();\n\treturn cred;\n}\nEXPORT_SYMBOL(get_task_cred);\n\n \nstruct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tatomic_long_set(&new->usage, 1);\n\tif (security_cred_alloc_blank(new, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}\n\n \nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_long_set(&new->usage, 1);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}\nEXPORT_SYMBOL(prepare_creds);\n\n \nstruct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t \n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t \n\tkey_put(new->process_keyring);\n\tnew->process_keyring = NULL;\n#endif\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\treturn new;\n}\n\n \nint copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n\tstruct cred *new;\n\tint ret;\n\n#ifdef CONFIG_KEYS_REQUEST_CACHE\n\tp->cached_requested_key = NULL;\n#endif\n\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\tkdebug(\"share_creds(%p{%ld})\",\n\t\t       p->cred, atomic_long_read(&p->cred->usage));\n\t\tinc_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\t\treturn 0;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t\tret = set_cred_ucounts(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\n#ifdef CONFIG_KEYS\n\t \n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\n\t \n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\tkey_put(new->process_keyring);\n\t\tnew->process_keyring = NULL;\n\t}\n#endif\n\n\tp->cred = p->real_cred = get_cred(new);\n\tinc_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\treturn 0;\n\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}\n\nstatic bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t \n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t \n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%ld})\", new,\n\t       atomic_long_read(&new->usage));\n\n\tBUG_ON(task->cred != old);\n\tBUG_ON(atomic_long_read(&new->usage) < 1);\n\n\tget_cred(new);  \n\n\t \n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t \n\t\tsmp_wmb();\n\t}\n\n\t \n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t \n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\n\t \n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t \n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}\nEXPORT_SYMBOL(commit_creds);\n\n \nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%ld})\", new,\n\t       atomic_long_read(&new->usage));\n\n\tBUG_ON(atomic_long_read(&new->usage) < 1);\n\tput_cred(new);\n}\nEXPORT_SYMBOL(abort_creds);\n\n \nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%ld})\", new,\n\t       atomic_long_read(&new->usage));\n\n\t \n\tget_new_cred((struct cred *)new);\n\trcu_assign_pointer(current->cred, new);\n\n\tkdebug(\"override_creds() = %p{%ld}\", old,\n\t       atomic_long_read(&old->usage));\n\treturn old;\n}\nEXPORT_SYMBOL(override_creds);\n\n \nvoid revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%ld})\", old,\n\t       atomic_long_read(&old->usage));\n\n\trcu_assign_pointer(current->cred, old);\n\tput_cred(override);\n}\nEXPORT_SYMBOL(revert_creds);\n\n \nint cred_fscmp(const struct cred *a, const struct cred *b)\n{\n\tstruct group_info *ga, *gb;\n\tint g;\n\n\tif (a == b)\n\t\treturn 0;\n\tif (uid_lt(a->fsuid, b->fsuid))\n\t\treturn -1;\n\tif (uid_gt(a->fsuid, b->fsuid))\n\t\treturn 1;\n\n\tif (gid_lt(a->fsgid, b->fsgid))\n\t\treturn -1;\n\tif (gid_gt(a->fsgid, b->fsgid))\n\t\treturn 1;\n\n\tga = a->group_info;\n\tgb = b->group_info;\n\tif (ga == gb)\n\t\treturn 0;\n\tif (ga == NULL)\n\t\treturn -1;\n\tif (gb == NULL)\n\t\treturn 1;\n\tif (ga->ngroups < gb->ngroups)\n\t\treturn -1;\n\tif (ga->ngroups > gb->ngroups)\n\t\treturn 1;\n\n\tfor (g = 0; g < ga->ngroups; g++) {\n\t\tif (gid_lt(ga->gid[g], gb->gid[g]))\n\t\t\treturn -1;\n\t\tif (gid_gt(ga->gid[g], gb->gid[g]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(cred_fscmp);\n\nint set_cred_ucounts(struct cred *new)\n{\n\tstruct ucounts *new_ucounts, *old_ucounts = new->ucounts;\n\n\t \n\tif (old_ucounts->ns == new->user_ns && uid_eq(old_ucounts->uid, new->uid))\n\t\treturn 0;\n\n\tif (!(new_ucounts = alloc_ucounts(new->user_ns, new->uid)))\n\t\treturn -EAGAIN;\n\n\tnew->ucounts = new_ucounts;\n\tput_ucounts(old_ucounts);\n\n\treturn 0;\n}\n\n \nvoid __init cred_init(void)\n{\n\t \n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n}\n\n \nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tif (WARN_ON_ONCE(!daemon))\n\t\treturn NULL;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\told = get_task_cred(daemon);\n\n\t*new = *old;\n\tnew->non_rcu = 0;\n\tatomic_long_set(&new->usage, 1);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}\nEXPORT_SYMBOL(prepare_kernel_cred);\n\n \nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}\nEXPORT_SYMBOL(set_security_override);\n\n \nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}\nEXPORT_SYMBOL(set_security_override_from_ctx);\n\n \nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EINVAL;\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}\nEXPORT_SYMBOL(set_create_files_as);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}