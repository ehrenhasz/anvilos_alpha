{
  "module_name": "hung_task.c",
  "hash_id": "e39dcce031fb656d084e719e851d1dca3896d0608aadba77ca6689fb44d8c149",
  "original_prompt": "Ingested from linux-6.6.14/kernel/hung_task.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/cpu.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/lockdep.h>\n#include <linux/export.h>\n#include <linux/panic_notifier.h>\n#include <linux/sysctl.h>\n#include <linux/suspend.h>\n#include <linux/utsname.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/sysctl.h>\n\n#include <trace/events/sched.h>\n\n \nstatic int __read_mostly sysctl_hung_task_check_count = PID_MAX_LIMIT;\n\n \n#define HUNG_TASK_LOCK_BREAK (HZ / 10)\n\n \nunsigned long __read_mostly sysctl_hung_task_timeout_secs = CONFIG_DEFAULT_HUNG_TASK_TIMEOUT;\n\n \nstatic unsigned long __read_mostly sysctl_hung_task_check_interval_secs;\n\nstatic int __read_mostly sysctl_hung_task_warnings = 10;\n\nstatic int __read_mostly did_panic;\nstatic bool hung_task_show_lock;\nstatic bool hung_task_call_panic;\nstatic bool hung_task_show_all_bt;\n\nstatic struct task_struct *watchdog_task;\n\n#ifdef CONFIG_SMP\n \nstatic unsigned int __read_mostly sysctl_hung_task_all_cpu_backtrace;\n#else\n#define sysctl_hung_task_all_cpu_backtrace 0\n#endif  \n\n \nstatic unsigned int __read_mostly sysctl_hung_task_panic =\n\tIS_ENABLED(CONFIG_BOOTPARAM_HUNG_TASK_PANIC);\n\nstatic int\nhung_task_panic(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tdid_panic = 1;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block panic_block = {\n\t.notifier_call = hung_task_panic,\n};\n\nstatic void check_hung_task(struct task_struct *t, unsigned long timeout)\n{\n\tunsigned long switch_count = t->nvcsw + t->nivcsw;\n\n\t \n\tif (unlikely(READ_ONCE(t->__state) & TASK_FROZEN))\n\t\treturn;\n\n\t \n\tif (unlikely(!switch_count))\n\t\treturn;\n\n\tif (switch_count != t->last_switch_count) {\n\t\tt->last_switch_count = switch_count;\n\t\tt->last_switch_time = jiffies;\n\t\treturn;\n\t}\n\tif (time_is_after_jiffies(t->last_switch_time + timeout * HZ))\n\t\treturn;\n\n\ttrace_sched_process_hang(t);\n\n\tif (sysctl_hung_task_panic) {\n\t\tconsole_verbose();\n\t\thung_task_show_lock = true;\n\t\thung_task_call_panic = true;\n\t}\n\n\t \n\tif (sysctl_hung_task_warnings) {\n\t\tif (sysctl_hung_task_warnings > 0)\n\t\t\tsysctl_hung_task_warnings--;\n\t\tpr_err(\"INFO: task %s:%d blocked for more than %ld seconds.\\n\",\n\t\t       t->comm, t->pid, (jiffies - t->last_switch_time) / HZ);\n\t\tpr_err(\"      %s %s %.*s\\n\",\n\t\t\tprint_tainted(), init_utsname()->release,\n\t\t\t(int)strcspn(init_utsname()->version, \" \"),\n\t\t\tinit_utsname()->version);\n\t\tpr_err(\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"\n\t\t\t\" disables this message.\\n\");\n\t\tsched_show_task(t);\n\t\thung_task_show_lock = true;\n\n\t\tif (sysctl_hung_task_all_cpu_backtrace)\n\t\t\thung_task_show_all_bt = true;\n\t\tif (!sysctl_hung_task_warnings)\n\t\t\tpr_info(\"Future hung task reports are suppressed, see sysctl kernel.hung_task_warnings\\n\");\n\t}\n\n\ttouch_nmi_watchdog();\n}\n\n \nstatic bool rcu_lock_break(struct task_struct *g, struct task_struct *t)\n{\n\tbool can_cont;\n\n\tget_task_struct(g);\n\tget_task_struct(t);\n\trcu_read_unlock();\n\tcond_resched();\n\trcu_read_lock();\n\tcan_cont = pid_alive(g) && pid_alive(t);\n\tput_task_struct(t);\n\tput_task_struct(g);\n\n\treturn can_cont;\n}\n\n \nstatic void check_hung_uninterruptible_tasks(unsigned long timeout)\n{\n\tint max_count = sysctl_hung_task_check_count;\n\tunsigned long last_break = jiffies;\n\tstruct task_struct *g, *t;\n\n\t \n\tif (test_taint(TAINT_DIE) || did_panic)\n\t\treturn;\n\n\thung_task_show_lock = false;\n\trcu_read_lock();\n\tfor_each_process_thread(g, t) {\n\t\tunsigned int state;\n\n\t\tif (!max_count--)\n\t\t\tgoto unlock;\n\t\tif (time_after(jiffies, last_break + HUNG_TASK_LOCK_BREAK)) {\n\t\t\tif (!rcu_lock_break(g, t))\n\t\t\t\tgoto unlock;\n\t\t\tlast_break = jiffies;\n\t\t}\n\t\t \n\t\tstate = READ_ONCE(t->__state);\n\t\tif ((state & TASK_UNINTERRUPTIBLE) &&\n\t\t    !(state & TASK_WAKEKILL) &&\n\t\t    !(state & TASK_NOLOAD))\n\t\t\tcheck_hung_task(t, timeout);\n\t}\n unlock:\n\trcu_read_unlock();\n\tif (hung_task_show_lock)\n\t\tdebug_show_all_locks();\n\n\tif (hung_task_show_all_bt) {\n\t\thung_task_show_all_bt = false;\n\t\ttrigger_all_cpu_backtrace();\n\t}\n\n\tif (hung_task_call_panic)\n\t\tpanic(\"hung_task: blocked tasks\");\n}\n\nstatic long hung_timeout_jiffies(unsigned long last_checked,\n\t\t\t\t unsigned long timeout)\n{\n\t \n\treturn timeout ? last_checked - jiffies + timeout * HZ :\n\t\tMAX_SCHEDULE_TIMEOUT;\n}\n\n#ifdef CONFIG_SYSCTL\n \nstatic int proc_dohung_task_timeout_secs(struct ctl_table *table, int write,\n\t\t\t\t  void *buffer,\n\t\t\t\t  size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\tgoto out;\n\n\twake_up_process(watchdog_task);\n\n out:\n\treturn ret;\n}\n\n \nstatic const unsigned long hung_task_timeout_max = (LONG_MAX / HZ);\nstatic struct ctl_table hung_task_sysctls[] = {\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname\t= \"hung_task_all_cpu_backtrace\",\n\t\t.data\t\t= &sysctl_hung_task_all_cpu_backtrace,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif  \n\t{\n\t\t.procname\t= \"hung_task_panic\",\n\t\t.data\t\t= &sysctl_hung_task_panic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_check_count\",\n\t\t.data\t\t= &sysctl_hung_task_check_count,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_timeout_secs\",\n\t\t.data\t\t= &sysctl_hung_task_timeout_secs,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dohung_task_timeout_secs,\n\t\t.extra2\t\t= (void *)&hung_task_timeout_max,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_check_interval_secs\",\n\t\t.data\t\t= &sysctl_hung_task_check_interval_secs,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dohung_task_timeout_secs,\n\t\t.extra2\t\t= (void *)&hung_task_timeout_max,\n\t},\n\t{\n\t\t.procname\t= \"hung_task_warnings\",\n\t\t.data\t\t= &sysctl_hung_task_warnings,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_NEG_ONE,\n\t},\n\t{}\n};\n\nstatic void __init hung_task_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", hung_task_sysctls);\n}\n#else\n#define hung_task_sysctl_init() do { } while (0)\n#endif  \n\n\nstatic atomic_t reset_hung_task = ATOMIC_INIT(0);\n\nvoid reset_hung_task_detector(void)\n{\n\tatomic_set(&reset_hung_task, 1);\n}\nEXPORT_SYMBOL_GPL(reset_hung_task_detector);\n\nstatic bool hung_detector_suspended;\n\nstatic int hungtask_pm_notify(struct notifier_block *self,\n\t\t\t      unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\thung_detector_suspended = true;\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\thung_detector_suspended = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\n \nstatic int watchdog(void *dummy)\n{\n\tunsigned long hung_last_checked = jiffies;\n\n\tset_user_nice(current, 0);\n\n\tfor ( ; ; ) {\n\t\tunsigned long timeout = sysctl_hung_task_timeout_secs;\n\t\tunsigned long interval = sysctl_hung_task_check_interval_secs;\n\t\tlong t;\n\n\t\tif (interval == 0)\n\t\t\tinterval = timeout;\n\t\tinterval = min_t(unsigned long, interval, timeout);\n\t\tt = hung_timeout_jiffies(hung_last_checked, interval);\n\t\tif (t <= 0) {\n\t\t\tif (!atomic_xchg(&reset_hung_task, 0) &&\n\t\t\t    !hung_detector_suspended)\n\t\t\t\tcheck_hung_uninterruptible_tasks(timeout);\n\t\t\thung_last_checked = jiffies;\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(t);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init hung_task_init(void)\n{\n\tatomic_notifier_chain_register(&panic_notifier_list, &panic_block);\n\n\t \n\tpm_notifier(hungtask_pm_notify, 0);\n\n\twatchdog_task = kthread_run(watchdog, NULL, \"khungtaskd\");\n\thung_task_sysctl_init();\n\n\treturn 0;\n}\nsubsys_initcall(hung_task_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}