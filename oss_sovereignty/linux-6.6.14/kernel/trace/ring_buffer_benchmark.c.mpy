{
  "module_name": "ring_buffer_benchmark.c",
  "hash_id": "ab4a6cee0f35715fb3130e4c279ebc78f513c982313713a75a4ff8b161c534da",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/ring_buffer_benchmark.c",
  "human_readable_source": "\n \n#include <linux/ring_buffer.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <asm/local.h>\n\nstruct rb_page {\n\tu64\t\tts;\n\tlocal_t\t\tcommit;\n\tchar\t\tdata[4080];\n};\n\n \n#define RUN_TIME\t10ULL\n#define SLEEP_TIME\t10\n\n \nstatic int wakeup_interval = 100;\n\nstatic int reader_finish;\nstatic DECLARE_COMPLETION(read_start);\nstatic DECLARE_COMPLETION(read_done);\n\nstatic struct trace_buffer *buffer;\nstatic struct task_struct *producer;\nstatic struct task_struct *consumer;\nstatic unsigned long read;\n\nstatic unsigned int disable_reader;\nmodule_param(disable_reader, uint, 0644);\nMODULE_PARM_DESC(disable_reader, \"only run producer\");\n\nstatic unsigned int write_iteration = 50;\nmodule_param(write_iteration, uint, 0644);\nMODULE_PARM_DESC(write_iteration, \"# of writes between timestamp readings\");\n\nstatic int producer_nice = MAX_NICE;\nstatic int consumer_nice = MAX_NICE;\n\nstatic int producer_fifo;\nstatic int consumer_fifo;\n\nmodule_param(producer_nice, int, 0644);\nMODULE_PARM_DESC(producer_nice, \"nice prio for producer\");\n\nmodule_param(consumer_nice, int, 0644);\nMODULE_PARM_DESC(consumer_nice, \"nice prio for consumer\");\n\nmodule_param(producer_fifo, int, 0644);\nMODULE_PARM_DESC(producer_fifo, \"use fifo for producer: 0 - disabled, 1 - low prio, 2 - fifo\");\n\nmodule_param(consumer_fifo, int, 0644);\nMODULE_PARM_DESC(consumer_fifo, \"use fifo for consumer: 0 - disabled, 1 - low prio, 2 - fifo\");\n\nstatic int read_events;\n\nstatic int test_error;\n\n#define TEST_ERROR()\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (!test_error) {\t\t\\\n\t\t\ttest_error = 1;\t\t\\\n\t\t\tWARN_ON(1);\t\t\\\n\t\t}\t\t\t\t\\\n\t} while (0)\n\nenum event_status {\n\tEVENT_FOUND,\n\tEVENT_DROPPED,\n};\n\nstatic bool break_test(void)\n{\n\treturn test_error || kthread_should_stop();\n}\n\nstatic enum event_status read_event(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tint *entry;\n\tu64 ts;\n\n\tevent = ring_buffer_consume(buffer, cpu, &ts, NULL);\n\tif (!event)\n\t\treturn EVENT_DROPPED;\n\n\tentry = ring_buffer_event_data(event);\n\tif (*entry != cpu) {\n\t\tTEST_ERROR();\n\t\treturn EVENT_DROPPED;\n\t}\n\n\tread++;\n\treturn EVENT_FOUND;\n}\n\nstatic enum event_status read_page(int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_page *rpage;\n\tunsigned long commit;\n\tvoid *bpage;\n\tint *entry;\n\tint ret;\n\tint inc;\n\tint i;\n\n\tbpage = ring_buffer_alloc_read_page(buffer, cpu);\n\tif (IS_ERR(bpage))\n\t\treturn EVENT_DROPPED;\n\n\tret = ring_buffer_read_page(buffer, &bpage, PAGE_SIZE, cpu, 1);\n\tif (ret >= 0) {\n\t\trpage = bpage;\n\t\t \n\t\tcommit = local_read(&rpage->commit) & 0xfffff;\n\t\tfor (i = 0; i < commit && !test_error ; i += inc) {\n\n\t\t\tif (i >= (PAGE_SIZE - offsetof(struct rb_page, data))) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tinc = -1;\n\t\t\tevent = (void *)&rpage->data[i];\n\t\t\tswitch (event->type_len) {\n\t\t\tcase RINGBUF_TYPE_PADDING:\n\t\t\t\t \n\t\t\t\tif (!event->time_delta)\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\t\t\tinc = 8;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tif (!event->array[0]) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc = event->array[0] + 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\tif (*entry != cpu) {\n\t\t\t\t\tTEST_ERROR();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tread++;\n\t\t\t\tinc = ((event->type_len + 1) * 4);\n\t\t\t}\n\t\t\tif (test_error)\n\t\t\t\tbreak;\n\n\t\t\tif (inc <= 0) {\n\t\t\t\tTEST_ERROR();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, cpu, bpage);\n\n\tif (ret < 0)\n\t\treturn EVENT_DROPPED;\n\treturn EVENT_FOUND;\n}\n\nstatic void ring_buffer_consumer(void)\n{\n\t \n\tread_events ^= 1;\n\n\tread = 0;\n\t \n\twhile (!READ_ONCE(reader_finish)) {\n\t\tint found = 1;\n\n\t\twhile (found && !test_error) {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (test_error)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (stat == EVENT_FOUND)\n\t\t\t\t\tfound = 1;\n\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treader_finish = 0;\n\tcomplete(&read_done);\n}\n\nstatic void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t \n\ttrace_printk(\"Starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, RUN_TIME * NSEC_PER_SEC);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef CONFIG_PREEMPTION\n\t\t \n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\t} while (ktime_before(end_time, timeout) && !break_test());\n\ttrace_printk(\"End ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t \n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t \n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (test_error)\n\t\ttrace_printk(\"ERROR!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo)\n\t\t\ttrace_printk(\"Running Consumer at SCHED_FIFO %s\\n\",\n\t\t\t\t     consumer_fifo == 1 ? \"low\" : \"high\");\n\t\telse\n\t\t\ttrace_printk(\"Running Consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t}\n\tif (producer_fifo)\n\t\ttrace_printk(\"Running Producer at SCHED_FIFO %s\\n\",\n\t\t\t     producer_fifo == 1 ? \"low\" : \"high\");\n\telse\n\t\ttrace_printk(\"Running Producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\n\t \n\tif (!producer_fifo && !consumer_fifo &&\n\t    producer_nice == MAX_NICE && consumer_nice == MAX_NICE)\n\t\ttrace_printk(\"WARNING!!! This test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"Time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"Overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"Read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"Read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"Entries:  %lld\\n\", entries);\n\ttrace_printk(\"Total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"Missed:   %ld\\n\", missed);\n\ttrace_printk(\"Hit:      %ld\\n\", hit);\n\n\t \n\tdo_div(time, USEC_PER_MSEC);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"TIME IS ZERO??\\n\");\n\n\ttrace_printk(\"Entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t \n\t\tavg = NSEC_PER_MSEC / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"Total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t \n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--;  \n\t\t}\n\n\t\t \n\t\tavg = NSEC_PER_MSEC / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}\n\nstatic void wait_to_die(void)\n{\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n}\n\nstatic int ring_buffer_consumer_thread(void *arg)\n{\n\twhile (!break_test()) {\n\t\tcomplete(&read_start);\n\n\t\tring_buffer_consumer();\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (break_test())\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!kthread_should_stop())\n\t\twait_to_die();\n\n\treturn 0;\n}\n\nstatic int ring_buffer_producer_thread(void *arg)\n{\n\twhile (!break_test()) {\n\t\tring_buffer_reset(buffer);\n\n\t\tif (consumer) {\n\t\t\twake_up_process(consumer);\n\t\t\twait_for_completion(&read_start);\n\t\t}\n\n\t\tring_buffer_producer();\n\t\tif (break_test())\n\t\t\tgoto out_kill;\n\n\t\ttrace_printk(\"Sleeping for 10 secs\\n\");\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (break_test())\n\t\t\tgoto out_kill;\n\t\tschedule_timeout(HZ * SLEEP_TIME);\n\t}\n\nout_kill:\n\t__set_current_state(TASK_RUNNING);\n\tif (!kthread_should_stop())\n\t\twait_to_die();\n\n\treturn 0;\n}\n\nstatic int __init ring_buffer_benchmark_init(void)\n{\n\tint ret;\n\n\t \n\tbuffer = ring_buffer_alloc(1000000, RB_FL_OVERWRITE);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tif (!disable_reader) {\n\t\tconsumer = kthread_create(ring_buffer_consumer_thread,\n\t\t\t\t\t  NULL, \"rb_consumer\");\n\t\tret = PTR_ERR(consumer);\n\t\tif (IS_ERR(consumer))\n\t\t\tgoto out_fail;\n\t}\n\n\tproducer = kthread_run(ring_buffer_producer_thread,\n\t\t\t       NULL, \"rb_producer\");\n\tret = PTR_ERR(producer);\n\n\tif (IS_ERR(producer))\n\t\tgoto out_kill;\n\n\t \n\tif (!disable_reader) {\n\t\tif (consumer_fifo >= 2)\n\t\t\tsched_set_fifo(consumer);\n\t\telse if (consumer_fifo == 1)\n\t\t\tsched_set_fifo_low(consumer);\n\t\telse\n\t\t\tset_user_nice(consumer, consumer_nice);\n\t}\n\n\tif (producer_fifo >= 2)\n\t\tsched_set_fifo(producer);\n\telse if (producer_fifo == 1)\n\t\tsched_set_fifo_low(producer);\n\telse\n\t\tset_user_nice(producer, producer_nice);\n\n\treturn 0;\n\n out_kill:\n\tif (consumer)\n\t\tkthread_stop(consumer);\n\n out_fail:\n\tring_buffer_free(buffer);\n\treturn ret;\n}\n\nstatic void __exit ring_buffer_benchmark_exit(void)\n{\n\tkthread_stop(producer);\n\tif (consumer)\n\t\tkthread_stop(consumer);\n\tring_buffer_free(buffer);\n}\n\nmodule_init(ring_buffer_benchmark_init);\nmodule_exit(ring_buffer_benchmark_exit);\n\nMODULE_AUTHOR(\"Steven Rostedt\");\nMODULE_DESCRIPTION(\"ring_buffer_benchmark\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}