{
  "module_name": "rv_reactors.c",
  "hash_id": "5b4e5e591c317c0dfb9af8ae49692e80dd7fddb7d0a24ba314ff22c7a286266f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/rv/rv_reactors.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"rv.h\"\n\n \nstatic LIST_HEAD(rv_reactors_list);\n\nstatic struct rv_reactor_def *get_reactor_rdef_by_name(char *name)\n{\n\tstruct rv_reactor_def *r;\n\n\tlist_for_each_entry(r, &rv_reactors_list, list) {\n\t\tif (strcmp(name, r->reactor->name) == 0)\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\n\n \nstatic int reactors_show(struct seq_file *m, void *p)\n{\n\tstruct rv_reactor_def *rea_def = p;\n\n\tseq_printf(m, \"%s\\n\", rea_def->reactor->name);\n\treturn 0;\n}\n\nstatic void reactors_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&rv_interface_lock);\n}\n\nstatic void *reactors_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&rv_interface_lock);\n\treturn seq_list_start(&rv_reactors_list, *pos);\n}\n\nstatic void *reactors_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &rv_reactors_list, pos);\n}\n\n \nstatic const struct seq_operations available_reactors_seq_ops = {\n\t.start\t= reactors_start,\n\t.next\t= reactors_next,\n\t.stop\t= reactors_stop,\n\t.show\t= reactors_show\n};\n\n \nstatic int available_reactors_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &available_reactors_seq_ops);\n};\n\nstatic const struct file_operations available_reactors_ops = {\n\t.open    = available_reactors_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\n \nstatic int monitor_reactor_show(struct seq_file *m, void *p)\n{\n\tstruct rv_monitor_def *mdef = m->private;\n\tstruct rv_reactor_def *rdef = p;\n\n\tif (mdef->rdef == rdef)\n\t\tseq_printf(m, \"[%s]\\n\", rdef->reactor->name);\n\telse\n\t\tseq_printf(m, \"%s\\n\", rdef->reactor->name);\n\treturn 0;\n}\n\n \nstatic const struct seq_operations monitor_reactors_seq_ops = {\n\t.start\t= reactors_start,\n\t.next\t= reactors_next,\n\t.stop\t= reactors_stop,\n\t.show\t= monitor_reactor_show\n};\n\nstatic void monitor_swap_reactors(struct rv_monitor_def *mdef, struct rv_reactor_def *rdef,\n\t\t\t\t    bool reacting)\n{\n\tbool monitor_enabled;\n\n\t \n\tif (mdef->rdef == rdef)\n\t\treturn;\n\n\tmonitor_enabled = mdef->monitor->enabled;\n\tif (monitor_enabled)\n\t\trv_disable_monitor(mdef);\n\n\t \n\tmdef->rdef->counter--;\n\trdef->counter++;\n\n\tmdef->rdef = rdef;\n\tmdef->reacting = reacting;\n\tmdef->monitor->react = rdef->reactor->react;\n\n\tif (monitor_enabled)\n\t\trv_enable_monitor(mdef);\n}\n\nstatic ssize_t\nmonitor_reactors_write(struct file *file, const char __user *user_buf,\n\t\t      size_t count, loff_t *ppos)\n{\n\tchar buff[MAX_RV_REACTOR_NAME_SIZE + 2];\n\tstruct rv_monitor_def *mdef;\n\tstruct rv_reactor_def *rdef;\n\tstruct seq_file *seq_f;\n\tint retval = -EINVAL;\n\tbool enable;\n\tchar *ptr;\n\tint len;\n\n\tif (count < 1 || count > MAX_RV_REACTOR_NAME_SIZE + 1)\n\t\treturn -EINVAL;\n\n\tmemset(buff, 0, sizeof(buff));\n\n\tretval = simple_write_to_buffer(buff, sizeof(buff) - 1, ppos, user_buf, count);\n\tif (retval < 0)\n\t\treturn -EFAULT;\n\n\tptr = strim(buff);\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn count;\n\n\t \n\tseq_f = file->private_data;\n\tmdef = seq_f->private;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tretval = -EINVAL;\n\n\tlist_for_each_entry(rdef, &rv_reactors_list, list) {\n\t\tif (strcmp(ptr, rdef->reactor->name) != 0)\n\t\t\tcontinue;\n\n\t\tif (rdef == get_reactor_rdef_by_name(\"nop\"))\n\t\t\tenable = false;\n\t\telse\n\t\t\tenable = true;\n\n\t\tmonitor_swap_reactors(mdef, rdef, enable);\n\n\t\tretval = count;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&rv_interface_lock);\n\n\treturn retval;\n}\n\n \nstatic int monitor_reactors_open(struct inode *inode, struct file *file)\n{\n\tstruct rv_monitor_def *mdef = inode->i_private;\n\tstruct seq_file *seq_f;\n\tint ret;\n\n\tret = seq_open(file, &monitor_reactors_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tseq_f = file->private_data;\n\n\t \n\tseq_f->private = mdef;\n\n\treturn 0;\n};\n\nstatic const struct file_operations monitor_reactors_ops = {\n\t.open    = monitor_reactors_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n\t.write = monitor_reactors_write\n};\n\nstatic int __rv_register_reactor(struct rv_reactor *reactor)\n{\n\tstruct rv_reactor_def *r;\n\n\tlist_for_each_entry(r, &rv_reactors_list, list) {\n\t\tif (strcmp(reactor->name, r->reactor->name) == 0) {\n\t\t\tpr_info(\"Reactor %s is already registered\\n\", reactor->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tr = kzalloc(sizeof(struct rv_reactor_def), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tr->reactor = reactor;\n\tr->counter = 0;\n\n\tlist_add_tail(&r->list, &rv_reactors_list);\n\n\treturn 0;\n}\n\n \nint rv_register_reactor(struct rv_reactor *reactor)\n{\n\tint retval = 0;\n\n\tif (strlen(reactor->name) >= MAX_RV_REACTOR_NAME_SIZE) {\n\t\tpr_info(\"Reactor %s has a name longer than %d\\n\",\n\t\t\treactor->name, MAX_RV_MONITOR_NAME_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&rv_interface_lock);\n\tretval = __rv_register_reactor(reactor);\n\tmutex_unlock(&rv_interface_lock);\n\treturn retval;\n}\n\n \nint rv_unregister_reactor(struct rv_reactor *reactor)\n{\n\tstruct rv_reactor_def *ptr, *next;\n\tint ret = 0;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tlist_for_each_entry_safe(ptr, next, &rv_reactors_list, list) {\n\t\tif (strcmp(reactor->name, ptr->reactor->name) == 0) {\n\n\t\t\tif (!ptr->counter) {\n\t\t\t\tlist_del(&ptr->list);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"rv: the rv_reactor %s is in use by %d monitor(s)\\n\",\n\t\t\t\t       ptr->reactor->name, ptr->counter);\n\t\t\t\tprintk(KERN_WARNING \"rv: the rv_reactor %s cannot be removed\\n\",\n\t\t\t\t       ptr->reactor->name);\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&rv_interface_lock);\n\treturn ret;\n}\n\n \nstatic bool __read_mostly reacting_on;\n\n \nbool rv_reacting_on(void)\n{\n\t \n\tsmp_rmb();\n\treturn READ_ONCE(reacting_on);\n}\n\nstatic ssize_t reacting_on_read_data(struct file *filp,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\n\tbuff = rv_reacting_on() ? \"1\\n\" : \"0\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff)+1);\n}\n\nstatic void turn_reacting_off(void)\n{\n\tWRITE_ONCE(reacting_on, false);\n\t \n\tsmp_wmb();\n}\n\nstatic void turn_reacting_on(void)\n{\n\tWRITE_ONCE(reacting_on, true);\n\t \n\tsmp_wmb();\n}\n\nstatic ssize_t reacting_on_write_data(struct file *filp, const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tint retval;\n\tbool val;\n\n\tretval = kstrtobool_from_user(user_buf, count, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tif (val)\n\t\tturn_reacting_on();\n\telse\n\t\tturn_reacting_off();\n\n\t \n\ttracepoint_synchronize_unregister();\n\n\tmutex_unlock(&rv_interface_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations reacting_on_fops = {\n\t.open   = simple_open,\n\t.llseek = no_llseek,\n\t.write  = reacting_on_write_data,\n\t.read   = reacting_on_read_data,\n};\n\n \nint reactor_populate_monitor(struct rv_monitor_def *mdef)\n{\n\tstruct dentry *tmp;\n\n\ttmp = rv_create_file(\"reactors\", RV_MODE_WRITE, mdef->root_d, mdef, &monitor_reactors_ops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t \n\tmdef->rdef = get_reactor_rdef_by_name(\"nop\");\n\tmdef->rdef->counter++;\n\tmdef->reacting = false;\n\n\treturn 0;\n}\n\n \nvoid reactor_cleanup_monitor(struct rv_monitor_def *mdef)\n{\n\tlockdep_assert_held(&rv_interface_lock);\n\tmdef->rdef->counter--;\n\tWARN_ON_ONCE(mdef->rdef->counter < 0);\n}\n\n \nstatic void rv_nop_reaction(char *msg)\n{\n}\n\nstatic struct rv_reactor rv_nop = {\n\t.name = \"nop\",\n\t.description = \"no-operation reactor: do nothing.\",\n\t.react = rv_nop_reaction\n};\n\nint init_rv_reactors(struct dentry *root_dir)\n{\n\tstruct dentry *available, *reacting;\n\tint retval;\n\n\tavailable = rv_create_file(\"available_reactors\", RV_MODE_READ, root_dir, NULL,\n\t\t\t\t   &available_reactors_ops);\n\tif (!available)\n\t\tgoto out_err;\n\n\treacting = rv_create_file(\"reacting_on\", RV_MODE_WRITE, root_dir, NULL, &reacting_on_fops);\n\tif (!reacting)\n\t\tgoto rm_available;\n\n\tretval = __rv_register_reactor(&rv_nop);\n\tif (retval)\n\t\tgoto rm_reacting;\n\n\tturn_reacting_on();\n\n\treturn 0;\n\nrm_reacting:\n\trv_remove(reacting);\nrm_available:\n\trv_remove(available);\nout_err:\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}