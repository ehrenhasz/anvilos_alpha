{
  "module_name": "rv.c",
  "hash_id": "ee83a4854239d054541086218e4c70ca7ebef49a150874710da919c74ffc6aa3",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/rv/rv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_DA_MON_EVENTS\n#define CREATE_TRACE_POINTS\n#include <trace/events/rv.h>\n#endif\n\n#include \"rv.h\"\n\nDEFINE_MUTEX(rv_interface_lock);\n\nstatic struct rv_interface rv_root;\n\nstruct dentry *get_monitors_root(void)\n{\n\treturn rv_root.monitors_dir;\n}\n\n \nstatic LIST_HEAD(rv_monitors_list);\n\nstatic int task_monitor_count;\nstatic bool task_monitor_slots[RV_PER_TASK_MONITORS];\n\nint rv_get_task_monitor_slot(void)\n{\n\tint i;\n\n\tlockdep_assert_held(&rv_interface_lock);\n\n\tif (task_monitor_count == RV_PER_TASK_MONITORS)\n\t\treturn -EBUSY;\n\n\ttask_monitor_count++;\n\n\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++) {\n\t\tif (task_monitor_slots[i] == false) {\n\t\t\ttask_monitor_slots[i] = true;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tWARN_ONCE(1, \"RV task_monitor_count and slots are out of sync\\n\");\n\n\treturn -EINVAL;\n}\n\nvoid rv_put_task_monitor_slot(int slot)\n{\n\tlockdep_assert_held(&rv_interface_lock);\n\n\tif (slot < 0 || slot >= RV_PER_TASK_MONITORS) {\n\t\tWARN_ONCE(1, \"RV releasing an invalid slot!: %d\\n\", slot);\n\t\treturn;\n\t}\n\n\tWARN_ONCE(!task_monitor_slots[slot], \"RV releasing unused task_monitor_slots: %d\\n\",\n\t\t  slot);\n\n\ttask_monitor_count--;\n\ttask_monitor_slots[slot] = false;\n}\n\n \nstatic ssize_t monitor_enable_read_data(struct file *filp, char __user *user_buf, size_t count,\n\t\t\t\t\tloff_t *ppos)\n{\n\tstruct rv_monitor_def *mdef = filp->private_data;\n\tconst char *buff;\n\n\tbuff = mdef->monitor->enabled ? \"1\\n\" : \"0\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff)+1);\n}\n\n \nstatic int __rv_disable_monitor(struct rv_monitor_def *mdef, bool sync)\n{\n\tlockdep_assert_held(&rv_interface_lock);\n\n\tif (mdef->monitor->enabled) {\n\t\tmdef->monitor->enabled = 0;\n\t\tmdef->monitor->disable();\n\n\t\t \n\t\tif (sync)\n\t\t\ttracepoint_synchronize_unregister();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint rv_disable_monitor(struct rv_monitor_def *mdef)\n{\n\t__rv_disable_monitor(mdef, true);\n\treturn 0;\n}\n\n \nint rv_enable_monitor(struct rv_monitor_def *mdef)\n{\n\tint retval;\n\n\tlockdep_assert_held(&rv_interface_lock);\n\n\tif (mdef->monitor->enabled)\n\t\treturn 0;\n\n\tretval = mdef->monitor->enable();\n\n\tif (!retval)\n\t\tmdef->monitor->enabled = 1;\n\n\treturn retval;\n}\n\n \nstatic ssize_t monitor_enable_write_data(struct file *filp, const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct rv_monitor_def *mdef = filp->private_data;\n\tint retval;\n\tbool val;\n\n\tretval = kstrtobool_from_user(user_buf, count, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tif (val)\n\t\tretval = rv_enable_monitor(mdef);\n\telse\n\t\tretval = rv_disable_monitor(mdef);\n\n\tmutex_unlock(&rv_interface_lock);\n\n\treturn retval ? : count;\n}\n\nstatic const struct file_operations interface_enable_fops = {\n\t.open   = simple_open,\n\t.llseek = no_llseek,\n\t.write  = monitor_enable_write_data,\n\t.read   = monitor_enable_read_data,\n};\n\n \nstatic ssize_t monitor_desc_read_data(struct file *filp, char __user *user_buf, size_t count,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct rv_monitor_def *mdef = filp->private_data;\n\tchar buff[256];\n\n\tmemset(buff, 0, sizeof(buff));\n\n\tsnprintf(buff, sizeof(buff), \"%s\\n\", mdef->monitor->description);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);\n}\n\nstatic const struct file_operations interface_desc_fops = {\n\t.open   = simple_open,\n\t.llseek\t= no_llseek,\n\t.read\t= monitor_desc_read_data,\n};\n\n \nstatic int create_monitor_dir(struct rv_monitor_def *mdef)\n{\n\tstruct dentry *root = get_monitors_root();\n\tconst char *name = mdef->monitor->name;\n\tstruct dentry *tmp;\n\tint retval;\n\n\tmdef->root_d = rv_create_dir(name, root);\n\tif (!mdef->root_d)\n\t\treturn -ENOMEM;\n\n\ttmp = rv_create_file(\"enable\", RV_MODE_WRITE, mdef->root_d, mdef, &interface_enable_fops);\n\tif (!tmp) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_remove_root;\n\t}\n\n\ttmp = rv_create_file(\"desc\", RV_MODE_READ, mdef->root_d, mdef, &interface_desc_fops);\n\tif (!tmp) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_remove_root;\n\t}\n\n\tretval = reactor_populate_monitor(mdef);\n\tif (retval)\n\t\tgoto out_remove_root;\n\n\treturn 0;\n\nout_remove_root:\n\trv_remove(mdef->root_d);\n\treturn retval;\n}\n\n \nstatic int monitors_show(struct seq_file *m, void *p)\n{\n\tstruct rv_monitor_def *mon_def = p;\n\n\tseq_printf(m, \"%s\\n\", mon_def->monitor->name);\n\treturn 0;\n}\n\n \nstatic void monitors_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&rv_interface_lock);\n}\n\n \nstatic void *available_monitors_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&rv_interface_lock);\n\treturn seq_list_start(&rv_monitors_list, *pos);\n}\n\nstatic void *available_monitors_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &rv_monitors_list, pos);\n}\n\n \nstatic void *enabled_monitors_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct rv_monitor_def *m_def = p;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(m_def, &rv_monitors_list, list) {\n\t\tif (m_def->monitor->enabled)\n\t\t\treturn m_def;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *enabled_monitors_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct rv_monitor_def *m_def;\n\tloff_t l;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tif (list_empty(&rv_monitors_list))\n\t\treturn NULL;\n\n\tm_def = list_entry(&rv_monitors_list, struct rv_monitor_def, list);\n\n\tfor (l = 0; l <= *pos; ) {\n\t\tm_def = enabled_monitors_next(m, m_def, &l);\n\t\tif (!m_def)\n\t\t\tbreak;\n\t}\n\n\treturn m_def;\n}\n\n \nstatic const struct seq_operations available_monitors_seq_ops = {\n\t.start\t= available_monitors_start,\n\t.next\t= available_monitors_next,\n\t.stop\t= monitors_stop,\n\t.show\t= monitors_show\n};\n\nstatic const struct seq_operations enabled_monitors_seq_ops = {\n\t.start  = enabled_monitors_start,\n\t.next   = enabled_monitors_next,\n\t.stop   = monitors_stop,\n\t.show   = monitors_show\n};\n\n \nstatic int available_monitors_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &available_monitors_seq_ops);\n};\n\nstatic const struct file_operations available_monitors_ops = {\n\t.open    = available_monitors_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release\n};\n\n \nstatic void disable_all_monitors(void)\n{\n\tstruct rv_monitor_def *mdef;\n\tint enabled = 0;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tlist_for_each_entry(mdef, &rv_monitors_list, list)\n\t\tenabled += __rv_disable_monitor(mdef, false);\n\n\tif (enabled) {\n\t\t \n\t\ttracepoint_synchronize_unregister();\n\t}\n\n\tmutex_unlock(&rv_interface_lock);\n}\n\nstatic int enabled_monitors_open(struct inode *inode, struct file *file)\n{\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))\n\t\tdisable_all_monitors();\n\n\treturn seq_open(file, &enabled_monitors_seq_ops);\n};\n\nstatic ssize_t enabled_monitors_write(struct file *filp, const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar buff[MAX_RV_MONITOR_NAME_SIZE + 2];\n\tstruct rv_monitor_def *mdef;\n\tint retval = -EINVAL;\n\tbool enable = true;\n\tchar *ptr;\n\tint len;\n\n\tif (count < 1 || count > MAX_RV_MONITOR_NAME_SIZE + 1)\n\t\treturn -EINVAL;\n\n\tmemset(buff, 0, sizeof(buff));\n\n\tretval = simple_write_to_buffer(buff, sizeof(buff) - 1, ppos, user_buf, count);\n\tif (retval < 0)\n\t\treturn -EFAULT;\n\n\tptr = strim(buff);\n\n\tif (ptr[0] == '!') {\n\t\tenable = false;\n\t\tptr++;\n\t}\n\n\tlen = strlen(ptr);\n\tif (!len)\n\t\treturn count;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tretval = -EINVAL;\n\n\tlist_for_each_entry(mdef, &rv_monitors_list, list) {\n\t\tif (strcmp(ptr, mdef->monitor->name) != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (enable)\n\t\t\tretval = rv_enable_monitor(mdef);\n\t\telse\n\t\t\tretval = rv_disable_monitor(mdef);\n\n\t\tif (!retval)\n\t\t\tretval = count;\n\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&rv_interface_lock);\n\treturn retval;\n}\n\nstatic const struct file_operations enabled_monitors_ops = {\n\t.open\t\t= enabled_monitors_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= enabled_monitors_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\n \nstatic bool __read_mostly monitoring_on;\n\n \nbool rv_monitoring_on(void)\n{\n\t \n\tsmp_rmb();\n\treturn READ_ONCE(monitoring_on);\n}\n\n \nstatic ssize_t monitoring_on_read_data(struct file *filp, char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tconst char *buff;\n\n\tbuff = rv_monitoring_on() ? \"1\\n\" : \"0\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buff, strlen(buff) + 1);\n}\n\nstatic void turn_monitoring_off(void)\n{\n\tWRITE_ONCE(monitoring_on, false);\n\t \n\tsmp_wmb();\n}\n\nstatic void reset_all_monitors(void)\n{\n\tstruct rv_monitor_def *mdef;\n\n\tlist_for_each_entry(mdef, &rv_monitors_list, list) {\n\t\tif (mdef->monitor->enabled)\n\t\t\tmdef->monitor->reset();\n\t}\n}\n\nstatic void turn_monitoring_on(void)\n{\n\tWRITE_ONCE(monitoring_on, true);\n\t \n\tsmp_wmb();\n}\n\nstatic void turn_monitoring_on_with_reset(void)\n{\n\tlockdep_assert_held(&rv_interface_lock);\n\n\tif (rv_monitoring_on())\n\t\treturn;\n\n\t \n\treset_all_monitors();\n\tturn_monitoring_on();\n}\n\nstatic ssize_t monitoring_on_write_data(struct file *filp, const char __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tint retval;\n\tbool val;\n\n\tretval = kstrtobool_from_user(user_buf, count, &val);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tif (val)\n\t\tturn_monitoring_on_with_reset();\n\telse\n\t\tturn_monitoring_off();\n\n\t \n\ttracepoint_synchronize_unregister();\n\n\tmutex_unlock(&rv_interface_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations monitoring_on_fops = {\n\t.open   = simple_open,\n\t.llseek = no_llseek,\n\t.write  = monitoring_on_write_data,\n\t.read   = monitoring_on_read_data,\n};\n\nstatic void destroy_monitor_dir(struct rv_monitor_def *mdef)\n{\n\treactor_cleanup_monitor(mdef);\n\trv_remove(mdef->root_d);\n}\n\n \nint rv_register_monitor(struct rv_monitor *monitor)\n{\n\tstruct rv_monitor_def *r;\n\tint retval = 0;\n\n\tif (strlen(monitor->name) >= MAX_RV_MONITOR_NAME_SIZE) {\n\t\tpr_info(\"Monitor %s has a name longer than %d\\n\", monitor->name,\n\t\t\tMAX_RV_MONITOR_NAME_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&rv_interface_lock);\n\n\tlist_for_each_entry(r, &rv_monitors_list, list) {\n\t\tif (strcmp(monitor->name, r->monitor->name) == 0) {\n\t\t\tpr_info(\"Monitor %s is already registered\\n\", monitor->name);\n\t\t\tretval = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tr = kzalloc(sizeof(struct rv_monitor_def), GFP_KERNEL);\n\tif (!r) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tr->monitor = monitor;\n\n\tretval = create_monitor_dir(r);\n\tif (retval) {\n\t\tkfree(r);\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&r->list, &rv_monitors_list);\n\nout_unlock:\n\tmutex_unlock(&rv_interface_lock);\n\treturn retval;\n}\n\n \nint rv_unregister_monitor(struct rv_monitor *monitor)\n{\n\tstruct rv_monitor_def *ptr, *next;\n\n\tmutex_lock(&rv_interface_lock);\n\n\tlist_for_each_entry_safe(ptr, next, &rv_monitors_list, list) {\n\t\tif (strcmp(monitor->name, ptr->monitor->name) == 0) {\n\t\t\trv_disable_monitor(ptr);\n\t\t\tlist_del(&ptr->list);\n\t\t\tdestroy_monitor_dir(ptr);\n\t\t}\n\t}\n\n\tmutex_unlock(&rv_interface_lock);\n\treturn 0;\n}\n\nint __init rv_init_interface(void)\n{\n\tstruct dentry *tmp;\n\tint retval;\n\n\trv_root.root_dir = rv_create_dir(\"rv\", NULL);\n\tif (!rv_root.root_dir)\n\t\tgoto out_err;\n\n\trv_root.monitors_dir = rv_create_dir(\"monitors\", rv_root.root_dir);\n\tif (!rv_root.monitors_dir)\n\t\tgoto out_err;\n\n\ttmp = rv_create_file(\"available_monitors\", RV_MODE_READ, rv_root.root_dir, NULL,\n\t\t\t     &available_monitors_ops);\n\tif (!tmp)\n\t\tgoto out_err;\n\n\ttmp = rv_create_file(\"enabled_monitors\", RV_MODE_WRITE, rv_root.root_dir, NULL,\n\t\t\t     &enabled_monitors_ops);\n\tif (!tmp)\n\t\tgoto out_err;\n\n\ttmp = rv_create_file(\"monitoring_on\", RV_MODE_WRITE, rv_root.root_dir, NULL,\n\t\t\t     &monitoring_on_fops);\n\tif (!tmp)\n\t\tgoto out_err;\n\tretval = init_rv_reactors(rv_root.root_dir);\n\tif (retval)\n\t\tgoto out_err;\n\n\tturn_monitoring_on();\n\n\treturn 0;\n\nout_err:\n\trv_remove(rv_root.root_dir);\n\tprintk(KERN_ERR \"RV: Error while creating the RV interface\\n\");\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}