{
  "module_name": "trace_events_trigger.c",
  "hash_id": "c92cb28bb3058c15b800866baad0526c418ce7cbd3cdccbb7be2011cbb6e40a5",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_events_trigger.c",
  "human_readable_source": "\n \n\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n\n#include \"trace.h\"\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t \n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}\n\n \nenum event_trigger_type\nevent_triggers_call(struct trace_event_file *file,\n\t\t    struct trace_buffer *buffer, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct event_trigger_data *data;\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct event_filter *filter;\n\n\tif (list_empty(&file->triggers))\n\t\treturn tt;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (!rec) {\n\t\t\tdata->ops->trigger(data, buffer, rec, event);\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = rcu_dereference_sched(data->filter);\n\t\tif (filter && !filter_match_preds(filter, rec))\n\t\t\tcontinue;\n\t\tif (event_command_post_trigger(data->cmd_ops)) {\n\t\t\ttt |= data->cmd_ops->trigger_type;\n\t\t\tcontinue;\n\t\t}\n\t\tdata->ops->trigger(data, buffer, rec, event);\n\t}\n\treturn tt;\n}\nEXPORT_SYMBOL_GPL(event_triggers_call);\n\nbool __trace_trigger_soft_disabled(struct trace_event_file *file)\n{\n\tunsigned long eflags = file->flags;\n\n\tif (eflags & EVENT_FILE_FL_TRIGGER_MODE)\n\t\tevent_triggers_call(file, NULL, NULL, NULL);\n\tif (eflags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\treturn true;\n\tif (eflags & EVENT_FILE_FL_PID_FILTER)\n\t\treturn trace_event_ignore_this_pid(file);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(__trace_trigger_soft_disabled);\n\n \nvoid\nevent_triggers_post_call(struct trace_event_file *file,\n\t\t\t enum event_trigger_type tt)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (data->cmd_ops->trigger_type & tt)\n\t\t\tdata->ops->trigger(data, NULL, NULL, NULL);\n\t}\n}\nEXPORT_SYMBOL_GPL(event_triggers_post_call);\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic void *trigger_next(struct seq_file *m, void *t, loff_t *pos)\n{\n\tstruct trace_event_file *event_file = event_file_data(m->private);\n\n\tif (t == SHOW_AVAILABLE_TRIGGERS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn seq_list_next(t, &event_file->triggers, pos);\n}\n\nstatic bool check_user_trigger(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list,\n\t\t\t\tlockdep_is_held(&event_mutex)) {\n\t\tif (data->flags & EVENT_TRIGGER_FL_PROBE)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void *trigger_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *event_file;\n\n\t \n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (list_empty(&event_file->triggers) || !check_user_trigger(event_file))\n\t\treturn *pos == 0 ? SHOW_AVAILABLE_TRIGGERS : NULL;\n\n\treturn seq_list_start(&event_file->triggers, *pos);\n}\n\nstatic void trigger_stop(struct seq_file *m, void *t)\n{\n\tmutex_unlock(&event_mutex);\n}\n\nstatic int trigger_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct event_command *p;\n\n\tif (v == SHOW_AVAILABLE_TRIGGERS) {\n\t\tseq_puts(m, \"# Available triggers:\\n\");\n\t\tseq_putc(m, '#');\n\t\tmutex_lock(&trigger_cmd_mutex);\n\t\tlist_for_each_entry_reverse(p, &trigger_commands, list)\n\t\t\tseq_printf(m, \" %s\", p->name);\n\t\tseq_putc(m, '\\n');\n\t\tmutex_unlock(&trigger_cmd_mutex);\n\t\treturn 0;\n\t}\n\n\tdata = list_entry(v, struct event_trigger_data, list);\n\tdata->ops->print(m, data);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};\n\nstatic int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\n\nint trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t\nevent_trigger_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn event_trigger_regex_write(filp, ubuf, cnt, ppos);\n}\n\nstatic int\nevent_trigger_open(struct inode *inode, struct file *filp)\n{\n\t \n\treturn event_trigger_regex_open(inode, filp);\n}\n\nstatic int\nevent_trigger_release(struct inode *inode, struct file *file)\n{\n\treturn event_trigger_regex_release(inode, file);\n}\n\nconst struct file_operations event_trigger_fops = {\n\t.open = event_trigger_open,\n\t.read = seq_read,\n\t.write = event_trigger_write,\n\t.llseek = tracing_lseek,\n\t.release = event_trigger_release,\n};\n\n \n__init int register_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &trigger_commands);\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}\n\n \n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}\n\n \nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\n \nint event_trigger_init(struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}\n\n \nstatic void\nevent_trigger_free(struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}\n\n \nvoid\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data);\n\t\t}\n\t}\n}\n\n \nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}\n\n \nstatic int register_trigger(char *glob,\n\t\t\t    struct event_trigger_data *data,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\tret = trace_event_trigger_enable_disable(file, 1);\n\tif (ret < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic void unregister_trigger(char *glob,\n\t\t\t       struct event_trigger_data *test,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data = NULL, *iter;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(iter, &file->triggers, list) {\n\t\tif (iter->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {\n\t\t\tdata = iter;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (data && data->ops->free)\n\t\tdata->ops->free(data);\n}\n\n \n\n \nbool event_trigger_check_remove(const char *glob)\n{\n\treturn (glob && glob[0] == '!') ? true : false;\n}\n\n \nbool event_trigger_empty_param(const char *param)\n{\n\treturn !param;\n}\n\n \nint event_trigger_separate_filter(char *param_and_filter, char **param,\n\t\t\t\t  char **filter, bool param_required)\n{\n\tint ret = 0;\n\n\t*param = *filter = NULL;\n\n\tif (!param_and_filter) {\n\t\tif (param_required)\n\t\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!param_required && param_and_filter && !isdigit(param_and_filter[0])) {\n\t\t*filter = param_and_filter;\n\t\tgoto out;\n\t}\n\n\t \n\t*param = strsep(&param_and_filter, \" \\t\");\n\n\t \n\tif (param_and_filter) {\n\t\t*filter = skip_spaces(param_and_filter);\n\t\tif (!**filter)\n\t\t\t*filter = NULL;\n\t}\nout:\n\treturn ret;\n}\n\n \nstruct event_trigger_data *event_trigger_alloc(struct event_command *cmd_ops,\n\t\t\t\t\t       char *cmd,\n\t\t\t\t\t       char *param,\n\t\t\t\t\t       void *private_data)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, param);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\treturn NULL;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = private_data;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\treturn trigger_data;\n}\n\n \nint event_trigger_parse_num(char *param,\n\t\t\t    struct event_trigger_data *trigger_data)\n{\n\tchar *number;\n\tint ret = 0;\n\n\tif (param) {\n\t\tnumber = strsep(&param, \":\");\n\n\t\tif (!strlen(number))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t}\n\n\treturn ret;\n}\n\n \nint event_trigger_set_filter(struct event_command *cmd_ops,\n\t\t\t     struct trace_event_file *file,\n\t\t\t     char *param,\n\t\t\t     struct event_trigger_data *trigger_data)\n{\n\tif (param && cmd_ops->set_filter)\n\t\treturn cmd_ops->set_filter(param, trigger_data, file);\n\n\treturn 0;\n}\n\n \nvoid event_trigger_reset_filter(struct event_command *cmd_ops,\n\t\t\t\tstruct event_trigger_data *trigger_data)\n{\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n}\n\n \nint event_trigger_register(struct event_command *cmd_ops,\n\t\t\t   struct trace_event_file *file,\n\t\t\t   char *glob,\n\t\t\t   struct event_trigger_data *trigger_data)\n{\n\treturn cmd_ops->reg(glob, trigger_data, file);\n}\n\n \nvoid event_trigger_unregister(struct event_command *cmd_ops,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *glob,\n\t\t\t      struct event_trigger_data *trigger_data)\n{\n\tcmd_ops->unreg(glob, trigger_data, file);\n}\n\n \n\n \nstatic int\nevent_trigger_parse(struct event_command *cmd_ops,\n\t\t    struct trace_event_file *file,\n\t\t    char *glob, char *cmd, char *param_and_filter)\n{\n\tstruct event_trigger_data *trigger_data;\n\tchar *param, *filter;\n\tbool remove;\n\tint ret;\n\n\tremove = event_trigger_check_remove(glob);\n\n\tret = event_trigger_separate_filter(param_and_filter, &param, &filter, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\ttrigger_data = event_trigger_alloc(cmd_ops, cmd, param, file);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\tif (remove) {\n\t\tevent_trigger_unregister(cmd_ops, file, glob+1, trigger_data);\n\t\tkfree(trigger_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = event_trigger_parse_num(param, trigger_data);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = event_trigger_set_filter(cmd_ops, file, filter, trigger_data);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\t \n\tevent_trigger_init(trigger_data);\n\n\tret = event_trigger_register(cmd_ops, file, glob, trigger_data);\n\tif (ret)\n\t\tgoto out_free;\n\n\t \n\tevent_trigger_free(trigger_data);\n out:\n\treturn ret;\n\n out_free:\n\tevent_trigger_reset_filter(cmd_ops, trigger_data);\n\tkfree(trigger_data);\n\tgoto out;\n}\n\n \nint set_trigger_filter(char *filter_str,\n\t\t       struct event_trigger_data *trigger_data,\n\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data = trigger_data;\n\tstruct event_filter *filter = NULL, *tmp;\n\tint ret = -EINVAL;\n\tchar *s;\n\n\tif (!filter_str)  \n\t\tgoto assign;\n\n\ts = strsep(&filter_str, \" \\t\");\n\n\tif (!strlen(s) || strcmp(s, \"if\") != 0)\n\t\tgoto out;\n\n\tif (!filter_str)\n\t\tgoto out;\n\n\t \n\tret = create_event_filter(file->tr, file->event_call,\n\t\t\t\t  filter_str, true, &filter);\n\n\t \n\tif (filter) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = NULL;\n\t}\n\n\t \n assign:\n\ttmp = rcu_access_pointer(data->filter);\n\n\trcu_assign_pointer(data->filter, filter);\n\n\tif (tmp) {\n\t\t \n\t\tif (system_state != SYSTEM_BOOTING)\n\t\t\ttracepoint_synchronize_unregister();\n\t\tfree_event_filter(tmp);\n\t}\n\n\tkfree(data->filter_str);\n\tdata->filter_str = NULL;\n\n\tif (filter_str) {\n\t\tdata->filter_str = kstrdup(filter_str, GFP_KERNEL);\n\t\tif (!data->filter_str) {\n\t\t\tfree_event_filter(rcu_access_pointer(data->filter));\n\t\t\tdata->filter = NULL;\n\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n out:\n\treturn ret;\n}\n\nstatic LIST_HEAD(named_triggers);\n\n \nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}\n\n \nbool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}\n\n \nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid pause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, true);\n}\n\n \nvoid unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}\n\n \nvoid set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}\n\nstruct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}\n\nstatic void\ntraceon_trigger(struct event_trigger_data *data,\n\t\tstruct trace_buffer *buffer, void *rec,\n\t\tstruct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file) {\n\t\tif (tracer_tracing_is_on(file->tr))\n\t\t\treturn;\n\n\t\ttracer_tracing_on(file->tr);\n\t\treturn;\n\t}\n\n\tif (tracing_is_on())\n\t\treturn;\n\n\ttracing_on();\n}\n\nstatic void\ntraceon_count_trigger(struct event_trigger_data *data,\n\t\t      struct trace_buffer *buffer, void *rec,\n\t\t      struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file) {\n\t\tif (tracer_tracing_is_on(file->tr))\n\t\t\treturn;\n\t} else {\n\t\tif (tracing_is_on())\n\t\t\treturn;\n\t}\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tif (file)\n\t\ttracer_tracing_on(file->tr);\n\telse\n\t\ttracing_on();\n}\n\nstatic void\ntraceoff_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file) {\n\t\tif (!tracer_tracing_is_on(file->tr))\n\t\t\treturn;\n\n\t\ttracer_tracing_off(file->tr);\n\t\treturn;\n\t}\n\n\tif (!tracing_is_on())\n\t\treturn;\n\n\ttracing_off();\n}\n\nstatic void\ntraceoff_count_trigger(struct event_trigger_data *data,\n\t\t       struct trace_buffer *buffer, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file) {\n\t\tif (!tracer_tracing_is_on(file->tr))\n\t\t\treturn;\n\t} else {\n\t\tif (!tracing_is_on())\n\t\t\treturn;\n\t}\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tif (file)\n\t\ttracer_tracing_off(file->tr);\n\telse\n\t\ttracing_off();\n}\n\nstatic int\ntraceon_trigger_print(struct seq_file *m, struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceon\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}\n\nstatic int\ntraceoff_trigger_print(struct seq_file *m, struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceoff\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}\n\nstatic struct event_trigger_ops traceon_trigger_ops = {\n\t.trigger\t\t= traceon_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops traceon_count_trigger_ops = {\n\t.trigger\t\t= traceon_count_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops traceoff_trigger_ops = {\n\t.trigger\t\t= traceoff_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops traceoff_count_trigger_ops = {\n\t.trigger\t\t= traceoff_count_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nonoff_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\n\t \n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_trigger_ops :\n\t\t\t&traceon_trigger_ops;\n\telse\n\t\tops = param ? &traceoff_count_trigger_ops :\n\t\t\t&traceoff_trigger_ops;\n\n\treturn ops;\n}\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n#ifdef CONFIG_TRACER_SNAPSHOT\nstatic void\nsnapshot_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}\n\nstatic void\nsnapshot_count_trigger(struct event_trigger_data *data,\n\t\t       struct trace_buffer *buffer, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tsnapshot_trigger(data, buffer, rec, event);\n}\n\nstatic int\nregister_snapshot_trigger(char *glob,\n\t\t\t  struct event_trigger_data *data,\n\t\t\t  struct trace_event_file *file)\n{\n\tif (tracing_alloc_snapshot_instance(file->tr) != 0)\n\t\treturn 0;\n\n\treturn register_trigger(glob, data, file);\n}\n\nstatic int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}\n\nstatic struct event_trigger_ops snapshot_trigger_ops = {\n\t.trigger\t\t= snapshot_trigger,\n\t.print\t\t\t= snapshot_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops snapshot_count_trigger_ops = {\n\t.trigger\t\t= snapshot_count_trigger,\n\t.print\t\t\t= snapshot_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nsnapshot_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &snapshot_count_trigger_ops : &snapshot_trigger_ops;\n}\n\nstatic struct event_command trigger_snapshot_cmd = {\n\t.name\t\t\t= \"snapshot\",\n\t.trigger_type\t\t= ETT_SNAPSHOT,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_snapshot_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= snapshot_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_snapshot_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_snapshot_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}\n#else\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }\n#endif  \n\n#ifdef CONFIG_STACKTRACE\n#ifdef CONFIG_UNWINDER_ORC\n \n# define STACK_SKIP 2\n#else\n \n#define STACK_SKIP 4\n#endif\n\nstatic void\nstacktrace_trigger(struct event_trigger_data *data,\n\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\t__trace_stack(file->tr, tracing_gen_ctx(), STACK_SKIP);\n\telse\n\t\ttrace_dump_stack(STACK_SKIP);\n}\n\nstatic void\nstacktrace_count_trigger(struct event_trigger_data *data,\n\t\t\t struct trace_buffer *buffer, void *rec,\n\t\t\t struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tstacktrace_trigger(data, buffer, rec, event);\n}\n\nstatic int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}\n\nstatic struct event_trigger_ops stacktrace_trigger_ops = {\n\t.trigger\t\t= stacktrace_trigger,\n\t.print\t\t\t= stacktrace_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops stacktrace_count_trigger_ops = {\n\t.trigger\t\t= stacktrace_count_trigger,\n\t.print\t\t\t= stacktrace_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nstacktrace_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &stacktrace_count_trigger_ops : &stacktrace_trigger_ops;\n}\n\nstatic struct event_command trigger_stacktrace_cmd = {\n\t.name\t\t\t= \"stacktrace\",\n\t.trigger_type\t\t= ETT_STACKTRACE,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= stacktrace_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_stacktrace_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_stacktrace_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}\n#else\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }\n#endif  \n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}\n\nstatic void\nevent_enable_trigger(struct event_trigger_data *data,\n\t\t     struct trace_buffer *buffer,  void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}\n\nstatic void\nevent_enable_count_trigger(struct event_trigger_data *data,\n\t\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t\t   struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (!data->count)\n\t\treturn;\n\n\t \n\tif (enable_data->enable == !(enable_data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tevent_enable_trigger(data, buffer, rec, event);\n}\n\nint event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nvoid event_enable_trigger_free(struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\t \n\t\ttrace_event_enable_disable(enable_data->file, 0, 1);\n\t\ttrace_event_put_ref(enable_data->file->event_call);\n\t\ttrigger_data_free(data);\n\t\tkfree(enable_data);\n\t}\n}\n\nstatic struct event_trigger_ops event_enable_trigger_ops = {\n\t.trigger\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops event_enable_count_trigger_ops = {\n\t.trigger\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops event_disable_trigger_ops = {\n\t.trigger\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops event_disable_count_trigger_ops = {\n\t.trigger\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nint event_enable_trigger_parse(struct event_command *cmd_ops,\n\t\t\t       struct trace_event_file *file,\n\t\t\t       char *glob, char *cmd, char *param_and_filter)\n{\n\tstruct trace_event_file *event_enable_file;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *trigger_data;\n\tstruct trace_array *tr = file->tr;\n\tchar *param, *filter;\n\tbool enable, remove;\n\tconst char *system;\n\tconst char *event;\n\tbool hist = false;\n\tint ret;\n\n\tremove = event_trigger_check_remove(glob);\n\n\tif (event_trigger_empty_param(param_and_filter))\n\t\treturn -EINVAL;\n\n\tret = event_trigger_separate_filter(param_and_filter, &param, &filter, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsystem = strsep(&param, \":\");\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&param, \":\");\n\n\tret = -EINVAL;\n\tevent_enable_file = find_event_file(tr, system, event);\n\tif (!event_enable_file)\n\t\tgoto out;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\thist = ((strcmp(cmd, ENABLE_HIST_STR) == 0) ||\n\t\t(strcmp(cmd, DISABLE_HIST_STR) == 0));\n\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\tret = -ENOMEM;\n\n\tenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);\n\tif (!enable_data)\n\t\tgoto out;\n\n\tenable_data->hist = hist;\n\tenable_data->enable = enable;\n\tenable_data->file = event_enable_file;\n\n\ttrigger_data = event_trigger_alloc(cmd_ops, cmd, param, enable_data);\n\tif (!trigger_data) {\n\t\tkfree(enable_data);\n\t\tgoto out;\n\t}\n\n\tif (remove) {\n\t\tevent_trigger_unregister(cmd_ops, file, glob+1, trigger_data);\n\t\tkfree(trigger_data);\n\t\tkfree(enable_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tevent_trigger_init(trigger_data);\n\n\tret = event_trigger_parse_num(param, trigger_data);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = event_trigger_set_filter(cmd_ops, file, filter, trigger_data);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\t \n\tret = trace_event_try_get_ref(event_enable_file->event_call);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = trace_event_enable_disable(event_enable_file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\n\tret = event_trigger_register(cmd_ops, file, glob, trigger_data);\n\tif (ret)\n\t\tgoto out_disable;\n\n\tevent_trigger_free(trigger_data);\n out:\n\treturn ret;\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\ttrace_event_put_ref(event_enable_file->event_call);\n out_free:\n\tevent_trigger_reset_filter(cmd_ops, trigger_data);\n\tevent_trigger_free(trigger_data);\n\tkfree(enable_data);\n\n\tgoto out;\n}\n\nint event_enable_register_trigger(char *glob,\n\t\t\t\t  struct event_trigger_data *data,\n\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct enable_trigger_data *test_enable_data;\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\ttest_enable_data = test->private_data;\n\t\tif (test_enable_data &&\n\t\t    (test->cmd_ops->trigger_type ==\n\t\t     data->cmd_ops->trigger_type) &&\n\t\t    (test_enable_data->file == enable_data->file)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\tret = trace_event_trigger_enable_disable(file, 1);\n\tif (ret < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t}\nout:\n\treturn ret;\n}\n\nvoid event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct event_trigger_data *data = NULL, *iter;\n\tstruct enable_trigger_data *enable_data;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(iter, &file->triggers, list) {\n\t\tenable_data = iter->private_data;\n\t\tif (enable_data &&\n\t\t    (iter->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tdata = iter;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (data && data->ops->free)\n\t\tdata->ops->free(data);\n}\n\nstatic struct event_trigger_ops *\nevent_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\tif (enable)\n\t\tops = param ? &event_enable_count_trigger_ops :\n\t\t\t&event_enable_trigger_ops;\n\telse\n\t\tops = param ? &event_disable_count_trigger_ops :\n\t\t\t&event_disable_trigger_ops;\n\n\treturn ops;\n}\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}\n\nstatic __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}