{
  "module_name": "trace_probe.c",
  "hash_id": "c1a1e7c99a59e5eec70e0521255dee6241ed72c494ef6d7cd56e74ab5304436c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_probe.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)\t\"trace_probe: \" fmt\n\n#include <linux/bpf.h>\n#include \"trace_btf.h\"\n\n#include \"trace_probe.h\"\n\n#undef C\n#define C(a, b)\t\tb\n\nstatic const char *trace_probe_err_text[] = { ERRORS };\n\nstatic const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};\n\n \n#define DEFINE_BASIC_PRINT_TYPE_FUNC(tname, type, fmt)\t\t\t\\\nint PRINT_TYPE_FUNC_NAME(tname)(struct trace_seq *s, void *data, void *ent)\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttrace_seq_printf(s, fmt, *(type *)data);\t\t\t\\\n\treturn !trace_seq_has_overflowed(s);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nconst char PRINT_TYPE_FMT_NAME(tname)[] = fmt;\n\nDEFINE_BASIC_PRINT_TYPE_FUNC(u8,  u8,  \"%u\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(u16, u16, \"%u\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(u32, u32, \"%u\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(u64, u64, \"%Lu\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(s8,  s8,  \"%d\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(s16, s16, \"%d\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(s32, s32, \"%d\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(s64, s64, \"%Ld\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(x8,  u8,  \"0x%x\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(x16, u16, \"0x%x\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(x32, u32, \"0x%x\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(x64, u64, \"0x%Lx\")\nDEFINE_BASIC_PRINT_TYPE_FUNC(char, u8, \"'%c'\")\n\nint PRINT_TYPE_FUNC_NAME(symbol)(struct trace_seq *s, void *data, void *ent)\n{\n\ttrace_seq_printf(s, \"%pS\", (void *)*(unsigned long *)data);\n\treturn !trace_seq_has_overflowed(s);\n}\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\n \nint PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s, void *data, void *ent)\n{\n\tint len = *(u32 *)data >> 16;\n\n\tif (!len)\n\t\ttrace_seq_puts(s, FAULT_STRING);\n\telse\n\t\ttrace_seq_printf(s, \"\\\"%s\\\"\",\n\t\t\t\t (const char *)get_loc_data(data, ent));\n\treturn !trace_seq_has_overflowed(s);\n}\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\n \nstatic const struct fetch_type probe_fetch_types[] = {\n\t \n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1, 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"ustring\", string, string, sizeof(u32), 1, 1,\n\t\t\t    \"__data_loc char[]\"),\n\t__ASSIGN_FETCH_TYPE(\"symstr\", string, string, sizeof(u32), 1, 1,\n\t\t\t    \"__data_loc char[]\"),\n\t \n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(char, u8, u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type, unsigned long flags)\n{\n\tint i;\n\n\t \n\tif (type && (flags & TPARG_FL_USER) &&\n\t    (!strcmp(type, \"symbol\") || !strcmp(type, \"symstr\")))\n\t\treturn NULL;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t \n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\", flags);\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\", flags);\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\", flags);\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\", flags);\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}\n\nstatic struct trace_probe_log trace_probe_log;\n\nvoid trace_probe_log_init(const char *subsystem, int argc, const char **argv)\n{\n\ttrace_probe_log.subsystem = subsystem;\n\ttrace_probe_log.argc = argc;\n\ttrace_probe_log.argv = argv;\n\ttrace_probe_log.index = 0;\n}\n\nvoid trace_probe_log_clear(void)\n{\n\tmemset(&trace_probe_log, 0, sizeof(trace_probe_log));\n}\n\nvoid trace_probe_log_set_index(int index)\n{\n\ttrace_probe_log.index = index;\n}\n\nvoid __trace_probe_log_err(int offset, int err_type)\n{\n\tchar *command, *p;\n\tint i, len = 0, pos = 0;\n\n\tif (!trace_probe_log.argv)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tif (i == trace_probe_log.index)\n\t\t\tpos = len;\n\t\tlen += strlen(trace_probe_log.argv[i]) + 1;\n\t}\n\tcommand = kzalloc(len, GFP_KERNEL);\n\tif (!command)\n\t\treturn;\n\n\tif (trace_probe_log.index >= trace_probe_log.argc) {\n\t\t \n\t\tpos = len;\n\t\toffset = 0;\n\t}\n\n\t \n\tp = command;\n\tfor (i = 0; i < trace_probe_log.argc; i++) {\n\t\tlen = strlen(trace_probe_log.argv[i]);\n\t\tstrcpy(p, trace_probe_log.argv[i]);\n\t\tp[len] = ' ';\n\t\tp += len + 1;\n\t}\n\t*(p - 1) = '\\0';\n\n\ttracing_log_err(NULL, trace_probe_log.subsystem, command,\n\t\t\ttrace_probe_err_text, err_type, pos + offset);\n\n\tkfree(command);\n}\n\n \nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}\n\n \nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset)\n{\n\tconst char *slash, *event = *pevent;\n\tint len;\n\n\tslash = strchr(event, '/');\n\tif (!slash)\n\t\tslash = strchr(event, '.');\n\n\tif (slash) {\n\t\tif (slash == event) {\n\t\t\ttrace_probe_log_err(offset, NO_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (slash - event + 1 > MAX_EVENT_NAME_LEN) {\n\t\t\ttrace_probe_log_err(offset, GROUP_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrscpy(buf, event, slash - event + 1);\n\t\tif (!is_good_system_name(buf)) {\n\t\t\ttrace_probe_log_err(offset, BAD_GROUP_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pgroup = buf;\n\t\t*pevent = slash + 1;\n\t\toffset += slash - event + 1;\n\t\tevent = *pevent;\n\t}\n\tlen = strlen(event);\n\tif (len == 0) {\n\t\tif (slash) {\n\t\t\t*pevent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\ttrace_probe_log_err(offset, NO_EVENT_NAME);\n\t\treturn -EINVAL;\n\t} else if (len > MAX_EVENT_NAME_LEN) {\n\t\ttrace_probe_log_err(offset, EVENT_TOO_LONG);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_good_name(event)) {\n\t\ttrace_probe_log_err(offset, BAD_EVENT_NAME);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int parse_trace_event_arg(char *arg, struct fetch_insn *code,\n\t\t\t\t struct traceprobe_parse_context *ctx)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(ctx->event);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(arg, field->name)) {\n\t\t\tcode->op = FETCH_OP_TP_ARG;\n\t\t\tcode->data = field;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\n#ifdef CONFIG_PROBE_EVENTS_BTF_ARGS\n\nstatic u32 btf_type_int(const struct btf_type *t)\n{\n\treturn *(u32 *)(t + 1);\n}\n\nstatic bool btf_type_is_char_ptr(struct btf *btf, const struct btf_type *type)\n{\n\tconst struct btf_type *real_type;\n\tu32 intdata;\n\ts32 tid;\n\n\treal_type = btf_type_skip_modifiers(btf, type->type, &tid);\n\tif (!real_type)\n\t\treturn false;\n\n\tif (BTF_INFO_KIND(real_type->info) != BTF_KIND_INT)\n\t\treturn false;\n\n\tintdata = btf_type_int(real_type);\n\treturn !(BTF_INT_ENCODING(intdata) & BTF_INT_SIGNED)\n\t\t&& BTF_INT_BITS(intdata) == 8;\n}\n\nstatic bool btf_type_is_char_array(struct btf *btf, const struct btf_type *type)\n{\n\tconst struct btf_type *real_type;\n\tconst struct btf_array *array;\n\tu32 intdata;\n\ts32 tid;\n\n\tif (BTF_INFO_KIND(type->info) != BTF_KIND_ARRAY)\n\t\treturn false;\n\n\tarray = (const struct btf_array *)(type + 1);\n\n\treal_type = btf_type_skip_modifiers(btf, array->type, &tid);\n\n\tintdata = btf_type_int(real_type);\n\treturn !(BTF_INT_ENCODING(intdata) & BTF_INT_SIGNED)\n\t\t&& BTF_INT_BITS(intdata) == 8;\n}\n\nstatic int check_prepare_btf_string_fetch(char *typename,\n\t\t\t\tstruct fetch_insn **pcode,\n\t\t\t\tstruct traceprobe_parse_context *ctx)\n{\n\tstruct btf *btf = ctx->btf;\n\n\tif (!btf || !ctx->last_type)\n\t\treturn 0;\n\n\t \n\tif (btf_type_is_char_array(btf, ctx->last_type))\n\t\treturn 0;\n\n\t \n\tif (btf_type_is_char_ptr(btf, ctx->last_type)) {\n\t\tstruct fetch_insn *code = *pcode + 1;\n\n\t\tif (code->op == FETCH_OP_END) {\n\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tif (typename[0] == 'u')\n\t\t\tcode->op = FETCH_OP_UDEREF;\n\t\telse\n\t\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = 0;\n\t\t*pcode = code;\n\t\treturn 0;\n\t}\n\t \n\ttrace_probe_log_err(ctx->offset, BAD_TYPE4STR);\n\treturn -EINVAL;\n}\n\nstatic const char *fetch_type_from_btf_type(struct btf *btf,\n\t\t\t\t\tconst struct btf_type *type,\n\t\t\t\t\tstruct traceprobe_parse_context *ctx)\n{\n\tu32 intdata;\n\n\t \n\tswitch (BTF_INFO_KIND(type->info)) {\n\tcase BTF_KIND_ENUM:\n\t\t \n\t\treturn \"s32\";\n\tcase BTF_KIND_ENUM64:\n\t\treturn \"s64\";\n\tcase BTF_KIND_PTR:\n\t\t \n\t\tif (IS_ENABLED(CONFIG_64BIT))\n\t\t\treturn \"x64\";\n\t\telse\n\t\t\treturn \"x32\";\n\tcase BTF_KIND_INT:\n\t\tintdata = btf_type_int(type);\n\t\tif (BTF_INT_ENCODING(intdata) & BTF_INT_SIGNED) {\n\t\t\tswitch (BTF_INT_BITS(intdata)) {\n\t\t\tcase 8:\n\t\t\t\treturn \"s8\";\n\t\t\tcase 16:\n\t\t\t\treturn \"s16\";\n\t\t\tcase 32:\n\t\t\t\treturn \"s32\";\n\t\t\tcase 64:\n\t\t\t\treturn \"s64\";\n\t\t\t}\n\t\t} else {\t \n\t\t\tswitch (BTF_INT_BITS(intdata)) {\n\t\t\tcase 8:\n\t\t\t\treturn \"u8\";\n\t\t\tcase 16:\n\t\t\t\treturn \"u16\";\n\t\t\tcase 32:\n\t\t\t\treturn \"u32\";\n\t\t\tcase 64:\n\t\t\t\treturn \"u64\";\n\t\t\t}\n\t\t\t \n\t\t\tctx->last_bitsize = BTF_INT_BITS(intdata);\n\t\t\tctx->last_bitoffs += BTF_INT_OFFSET(intdata);\n\t\t\treturn \"u64\";\n\t\t}\n\t}\n\t \n\n\treturn NULL;\n}\n\nstatic int query_btf_context(struct traceprobe_parse_context *ctx)\n{\n\tconst struct btf_param *param;\n\tconst struct btf_type *type;\n\tstruct btf *btf;\n\ts32 nr;\n\n\tif (ctx->btf)\n\t\treturn 0;\n\n\tif (!ctx->funcname)\n\t\treturn -EINVAL;\n\n\ttype = btf_find_func_proto(ctx->funcname, &btf);\n\tif (!type)\n\t\treturn -ENOENT;\n\n\tctx->btf = btf;\n\tctx->proto = type;\n\n\t \n\tnr = 0;\n\tparam = btf_get_func_param(type, &nr);\n\tif (!IS_ERR_OR_NULL(param)) {\n\t\t \n\t\tif (ctx->flags & TPARG_FL_TPOINT) {\n\t\t\tnr--;\n\t\t\tparam++;\n\t\t}\n\t}\n\n\tif (nr > 0) {\n\t\tctx->nr_params = nr;\n\t\tctx->params = param;\n\t} else {\n\t\tctx->nr_params = 0;\n\t\tctx->params = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void clear_btf_context(struct traceprobe_parse_context *ctx)\n{\n\tif (ctx->btf) {\n\t\tbtf_put(ctx->btf);\n\t\tctx->btf = NULL;\n\t\tctx->proto = NULL;\n\t\tctx->params = NULL;\n\t\tctx->nr_params = 0;\n\t}\n}\n\n \nstatic int split_next_field(char *varname, char **next_field,\n\t\t\t    struct traceprobe_parse_context *ctx)\n{\n\tchar *field;\n\tint ret = 0;\n\n\tfield = strpbrk(varname, \".-\");\n\tif (field) {\n\t\tif (field[0] == '-' && field[1] == '>') {\n\t\t\tfield[0] = '\\0';\n\t\t\tfield += 2;\n\t\t\tret = 1;\n\t\t} else if (field[0] == '.') {\n\t\t\tfield[0] = '\\0';\n\t\t\tfield += 1;\n\t\t} else {\n\t\t\ttrace_probe_log_err(ctx->offset + field - varname, BAD_HYPHEN);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*next_field = field;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int parse_btf_field(char *fieldname, const struct btf_type *type,\n\t\t\t   struct fetch_insn **pcode, struct fetch_insn *end,\n\t\t\t   struct traceprobe_parse_context *ctx)\n{\n\tstruct fetch_insn *code = *pcode;\n\tconst struct btf_member *field;\n\tu32 bitoffs, anon_offs;\n\tchar *next;\n\tint is_ptr;\n\ts32 tid;\n\n\tdo {\n\t\t \n\t\tif (BTF_INFO_KIND(type->info) != BTF_KIND_PTR) {\n\t\t\ttrace_probe_log_err(ctx->offset, NO_PTR_STRCT);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\ttype = btf_type_skip_modifiers(ctx->btf, type->type, &tid);\n\t\tif (!type) {\n\t\t\ttrace_probe_log_err(ctx->offset, BAD_BTF_TID);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbitoffs = 0;\n\t\tdo {\n\t\t\t \n\t\t\tnext = NULL;\n\t\t\tis_ptr = split_next_field(fieldname, &next, ctx);\n\t\t\tif (is_ptr < 0)\n\t\t\t\treturn is_ptr;\n\n\t\t\tanon_offs = 0;\n\t\t\tfield = btf_find_struct_member(ctx->btf, type, fieldname,\n\t\t\t\t\t\t       &anon_offs);\n\t\t\tif (!field) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, NO_BTF_FIELD);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\t \n\t\t\tbitoffs += anon_offs;\n\n\t\t\t \n\t\t\tif (btf_type_kflag(type)) {\n\t\t\t\tbitoffs += BTF_MEMBER_BIT_OFFSET(field->offset);\n\t\t\t\tctx->last_bitsize = BTF_MEMBER_BITFIELD_SIZE(field->offset);\n\t\t\t} else {\n\t\t\t\tbitoffs += field->offset;\n\t\t\t\tctx->last_bitsize = 0;\n\t\t\t}\n\n\t\t\ttype = btf_type_skip_modifiers(ctx->btf, field->type, &tid);\n\t\t\tif (!type) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, BAD_BTF_TID);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tctx->offset += next - fieldname;\n\t\t\tfieldname = next;\n\t\t} while (!is_ptr && fieldname);\n\n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcode->op = FETCH_OP_DEREF;\t \n\t\tcode->offset = bitoffs / 8;\n\t\t*pcode = code;\n\n\t\tctx->last_bitoffs = bitoffs % 8;\n\t\tctx->last_type = type;\n\t} while (fieldname);\n\n\treturn 0;\n}\n\nstatic int parse_btf_arg(char *varname,\n\t\t\t struct fetch_insn **pcode, struct fetch_insn *end,\n\t\t\t struct traceprobe_parse_context *ctx)\n{\n\tstruct fetch_insn *code = *pcode;\n\tconst struct btf_param *params;\n\tconst struct btf_type *type;\n\tchar *field = NULL;\n\tint i, is_ptr, ret;\n\tu32 tid;\n\n\tif (WARN_ON_ONCE(!ctx->funcname))\n\t\treturn -EINVAL;\n\n\tis_ptr = split_next_field(varname, &field, ctx);\n\tif (is_ptr < 0)\n\t\treturn is_ptr;\n\tif (!is_ptr && field) {\n\t\t \n\t\ttrace_probe_log_err(ctx->offset + field - varname,\n\t\t\t\t    NOSUP_DAT_ARG);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ctx->flags & TPARG_FL_RETURN) {\n\t\tif (strcmp(varname, \"$retval\") != 0) {\n\t\t\ttrace_probe_log_err(ctx->offset, NO_BTFARG);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tcode->op = FETCH_OP_RETVAL;\n\t\t \n\t\tif (query_btf_context(ctx) == 0) {\n\t\t\tif (ctx->proto->type == 0) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, NO_RETVAL);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\ttid = ctx->proto->type;\n\t\t\tgoto found;\n\t\t}\n\t\tif (field) {\n\t\t\ttrace_probe_log_err(ctx->offset + field - varname,\n\t\t\t\t\t    NO_BTF_ENTRY);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!ctx->btf) {\n\t\tret = query_btf_context(ctx);\n\t\tif (ret < 0 || ctx->nr_params == 0) {\n\t\t\ttrace_probe_log_err(ctx->offset, NO_BTF_ENTRY);\n\t\t\treturn PTR_ERR(params);\n\t\t}\n\t}\n\tparams = ctx->params;\n\n\tfor (i = 0; i < ctx->nr_params; i++) {\n\t\tconst char *name = btf_name_by_offset(ctx->btf, params[i].name_off);\n\n\t\tif (name && !strcmp(name, varname)) {\n\t\t\tcode->op = FETCH_OP_ARG;\n\t\t\tif (ctx->flags & TPARG_FL_TPOINT)\n\t\t\t\tcode->param = i + 1;\n\t\t\telse\n\t\t\t\tcode->param = i;\n\t\t\ttid = params[i].type;\n\t\t\tgoto found;\n\t\t}\n\t}\n\ttrace_probe_log_err(ctx->offset, NO_BTFARG);\n\treturn -ENOENT;\n\nfound:\n\ttype = btf_type_skip_modifiers(ctx->btf, tid, &tid);\n\tif (!type) {\n\t\ttrace_probe_log_err(ctx->offset, BAD_BTF_TID);\n\t\treturn -EINVAL;\n\t}\n\t \n\tctx->last_type = type;\n\tctx->last_bitoffs = 0;\n\tctx->last_bitsize = 0;\n\tif (field) {\n\t\tctx->offset += field - varname;\n\t\treturn parse_btf_field(field, type, pcode, end, ctx);\n\t}\n\treturn 0;\n}\n\nstatic const struct fetch_type *find_fetch_type_from_btf_type(\n\t\t\t\t\tstruct traceprobe_parse_context *ctx)\n{\n\tstruct btf *btf = ctx->btf;\n\tconst char *typestr = NULL;\n\n\tif (btf && ctx->last_type)\n\t\ttypestr = fetch_type_from_btf_type(btf, ctx->last_type, ctx);\n\n\treturn find_fetch_type(typestr, ctx->flags);\n}\n\nstatic int parse_btf_bitfield(struct fetch_insn **pcode,\n\t\t\t      struct traceprobe_parse_context *ctx)\n{\n\tstruct fetch_insn *code = *pcode;\n\n\tif ((ctx->last_bitsize % 8 == 0) && ctx->last_bitoffs == 0)\n\t\treturn 0;\n\n\tcode++;\n\tif (code->op != FETCH_OP_NOP) {\n\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\treturn -EINVAL;\n\t}\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = 64 - (ctx->last_bitsize + ctx->last_bitoffs);\n\tcode->rshift = 64 - ctx->last_bitsize;\n\tcode->basesize = 64 / 8;\n\treturn 0;\n}\n\n#else\nstatic void clear_btf_context(struct traceprobe_parse_context *ctx)\n{\n\tctx->btf = NULL;\n}\n\nstatic int query_btf_context(struct traceprobe_parse_context *ctx)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int parse_btf_arg(char *varname,\n\t\t\t struct fetch_insn **pcode, struct fetch_insn *end,\n\t\t\t struct traceprobe_parse_context *ctx)\n{\n\ttrace_probe_log_err(ctx->offset, NOSUP_BTFARG);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int parse_btf_bitfield(struct fetch_insn **pcode,\n\t\t\t      struct traceprobe_parse_context *ctx)\n{\n\ttrace_probe_log_err(ctx->offset, NOSUP_BTFARG);\n\treturn -EOPNOTSUPP;\n}\n\n#define find_fetch_type_from_btf_type(ctx)\t\t\\\n\tfind_fetch_type(NULL, ctx->flags)\n\nstatic int check_prepare_btf_string_fetch(char *typename,\n\t\t\t\tstruct fetch_insn **pcode,\n\t\t\t\tstruct traceprobe_parse_context *ctx)\n{\n\treturn 0;\n}\n\n#endif\n\n#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))\n\n \nstatic int parse_probe_vars(char *orig_arg, const struct fetch_type *t,\n\t\t\t    struct fetch_insn **pcode,\n\t\t\t    struct fetch_insn *end,\n\t\t\t    struct traceprobe_parse_context *ctx)\n{\n\tstruct fetch_insn *code = *pcode;\n\tint err = TP_ERR_BAD_VAR;\n\tchar *arg = orig_arg + 1;\n\tunsigned long param;\n\tint ret = 0;\n\tint len;\n\n\tif (ctx->flags & TPARG_FL_TEVENT) {\n\t\tif (code->data)\n\t\t\treturn -EFAULT;\n\t\tret = parse_trace_event_arg(arg, code, ctx);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tif (strcmp(arg, \"comm\") == 0 || strcmp(arg, \"COMM\") == 0) {\n\t\t\tcode->op = FETCH_OP_COMM;\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tctx->offset = 0;\n\t\tgoto inval;\n\t}\n\n\tif (str_has_prefix(arg, \"retval\")) {\n\t\tif (!(ctx->flags & TPARG_FL_RETURN)) {\n\t\t\terr = TP_ERR_RETVAL_ON_PROBE;\n\t\t\tgoto inval;\n\t\t}\n\t\tif (!(ctx->flags & TPARG_FL_KERNEL) ||\n\t\t    !IS_ENABLED(CONFIG_PROBE_EVENTS_BTF_ARGS)) {\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\t\treturn 0;\n\t\t}\n\t\treturn parse_btf_arg(orig_arg, pcode, end, ctx);\n\t}\n\n\tlen = str_has_prefix(arg, \"stack\");\n\tif (len) {\n\n\t\tif (arg[len] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (isdigit(arg[len])) {\n\t\t\tret = kstrtoul(arg + len, 10, &param);\n\t\t\tif (ret)\n\t\t\t\tgoto inval;\n\n\t\t\tif ((ctx->flags & TPARG_FL_KERNEL) &&\n\t\t\t    param > PARAM_MAX_STACK) {\n\t\t\t\terr = TP_ERR_BAD_STACK_NUM;\n\t\t\t\tgoto inval;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\tcode->param = (unsigned int)param;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto inval;\n\t}\n\n\tif (strcmp(arg, \"comm\") == 0 || strcmp(arg, \"COMM\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\tlen = str_has_prefix(arg, \"arg\");\n\tif (len && tparg_is_function_entry(ctx->flags)) {\n\t\tret = kstrtoul(arg + len, 10, &param);\n\t\tif (ret)\n\t\t\tgoto inval;\n\n\t\tif (!param || param > PARAM_MAX_STACK) {\n\t\t\terr = TP_ERR_BAD_ARG_NUM;\n\t\t\tgoto inval;\n\t\t}\n\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n\t\t \n\t\tif (ctx->flags & TPARG_FL_TPOINT)\n\t\t\tcode->param++;\n\t\treturn 0;\n\t}\n#endif\n\ninval:\n\t__trace_probe_log_err(ctx->offset, err);\n\treturn -EINVAL;\n}\n\nstatic int str_to_immediate(char *str, unsigned long *imm)\n{\n\tif (isdigit(str[0]))\n\t\treturn kstrtoul(str, 0, imm);\n\telse if (str[0] == '-')\n\t\treturn kstrtol(str, 0, (long *)imm);\n\telse if (str[0] == '+')\n\t\treturn kstrtol(str + 1, 0, (long *)imm);\n\treturn -EINVAL;\n}\n\nstatic int __parse_imm_string(char *str, char **pbuf, int offs)\n{\n\tsize_t len = strlen(str);\n\n\tif (str[len - 1] != '\"') {\n\t\ttrace_probe_log_err(offs + len, IMMSTR_NO_CLOSE);\n\t\treturn -EINVAL;\n\t}\n\t*pbuf = kstrndup(str, len - 1, GFP_KERNEL);\n\tif (!*pbuf)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nstatic int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tstruct traceprobe_parse_context *ctx)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tint deref = FETCH_OP_DEREF;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg, type, pcode, end, ctx);\n\t\tbreak;\n\n\tcase '%':\t \n\t\tif (ctx->flags & (TPARG_FL_TEVENT | TPARG_FL_FPROBE)) {\n\t\t\t \n\t\t\ttrace_probe_log_err(ctx->offset, BAD_VAR);\n\t\t\tbreak;\n\t\t}\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t} else\n\t\t\ttrace_probe_log_err(ctx->offset, BAD_REG_NAME);\n\t\tbreak;\n\n\tcase '@':\t \n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, BAD_MEM_ADDR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t \n\t\t\tif (ctx->flags & TPARG_FL_KERNEL) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, FILE_ON_KPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, BAD_FILE_OFFS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;   \n\t\t} else {\n\t\t\t \n\t\t\tif (!(ctx->flags & TPARG_FL_KERNEL)) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, SYM_ON_UPROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t \n\t\tif (++code == end) {\n\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t \n\tcase '-':\n\t\tif (arg[1] == 'u') {\n\t\t\tderef = FETCH_OP_UDEREF;\n\t\t\targ[1] = arg[0];\n\t\t\targ++;\n\t\t}\n\t\tif (arg[0] == '+')\n\t\t\targ++;\t \n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(ctx->offset, DEREF_NEED_BRACE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(ctx->offset, BAD_DEREF_OFFS);\n\t\t\tbreak;\n\t\t}\n\t\tctx->offset += (tmp + 1 - arg) + (arg[0] != '-' ? 1 : 0);\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\t\tif (!tmp) {\n\t\t\ttrace_probe_log_err(ctx->offset + strlen(arg),\n\t\t\t\t\t    DEREF_OPEN_BRACE);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL, ctx->flags);\n\t\t\tint cur_offs = ctx->offset;\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tctx->offset = cur_offs;\n\t\t\tif (code->op == FETCH_OP_COMM ||\n\t\t\t    code->op == FETCH_OP_DATA) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, COMM_CANT_DEREF);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (++code == end) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = deref;\n\t\t\tcode->offset = offset;\n\t\t\t \n\t\t\tctx->last_type = NULL;\n\t\t}\n\t\tbreak;\n\tcase '\\\\':\t \n\t\tif (arg[1] == '\"') {\t \n\t\t\tret = __parse_imm_string(arg + 2, &tmp, ctx->offset + 2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tcode->op = FETCH_OP_DATA;\n\t\t\tcode->data = tmp;\n\t\t} else {\n\t\t\tret = str_to_immediate(arg + 1, &code->immediate);\n\t\t\tif (ret)\n\t\t\t\ttrace_probe_log_err(ctx->offset + 1, BAD_IMM);\n\t\t\telse\n\t\t\t\tcode->op = FETCH_OP_IMM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (isalpha(arg[0]) || arg[0] == '_') {\t \n\t\t\tif (!tparg_is_function_entry(ctx->flags)) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, NOSUP_BTFARG);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = parse_btf_arg(arg, pcode, end, ctx);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t \n\t\ttrace_probe_log_err(ctx->offset, BAD_FETCH_ARG);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\n#define BYTES_TO_BITS(nb)\t((BITS_PER_LONG * (nb)) / sizeof(long))\n\n \nstatic int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t \n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -EINVAL;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}\n\n \nstatic int traceprobe_parse_probe_arg_body(const char *argv, ssize_t *size,\n\t\t\t\t\t   struct probe_arg *parg,\n\t\t\t\t\t   struct traceprobe_parse_context *ctx)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2, *t3;\n\tint ret, len;\n\tchar *arg;\n\n\targ = kstrdup(argv, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\n\tret = -EINVAL;\n\tlen = strlen(arg);\n\tif (len > MAX_ARGSTR_LEN) {\n\t\ttrace_probe_log_err(ctx->offset, ARG_TOO_LONG);\n\t\tgoto out;\n\t} else if (len == 0) {\n\t\ttrace_probe_log_err(ctx->offset, NO_ARG_BODY);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2++ = '\\0';\n\t\t\tt3 = strchr(t2, ']');\n\t\t\tif (!t3) {\n\t\t\t\tint offs = t2 + strlen(t2) - arg;\n\n\t\t\t\ttrace_probe_log_err(ctx->offset + offs,\n\t\t\t\t\t\t    ARRAY_NO_CLOSE);\n\t\t\t\tgoto out;\n\t\t\t} else if (t3[1] != '\\0') {\n\t\t\t\ttrace_probe_log_err(ctx->offset + t3 + 1 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_SUFFIX);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*t3 = '\\0';\n\t\t\tif (kstrtouint(t2, 0, &parg->count) || !parg->count) {\n\t\t\t\ttrace_probe_log_err(ctx->offset + t2 - arg,\n\t\t\t\t\t\t    BAD_ARRAY_NUM);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (parg->count > MAX_ARRAY_LEN) {\n\t\t\t\ttrace_probe_log_err(ctx->offset + t2 - arg,\n\t\t\t\t\t\t    ARRAY_TOO_BIG);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(ctx->flags & TPARG_FL_TEVENT) &&\n\t    (strcmp(arg, \"$comm\") == 0 || strcmp(arg, \"$COMM\") == 0 ||\n\t     strncmp(arg, \"\\\\\\\"\", 2) == 0)) {\n\t\t \n\t\tif (parg->count || (t && strcmp(t, \"string\")))\n\t\t\tgoto out;\n\t\tparg->type = find_fetch_type(\"string\", ctx->flags);\n\t} else\n\t\tparg->type = find_fetch_type(t, ctx->flags);\n\tif (!parg->type) {\n\t\ttrace_probe_log_err(ctx->offset + (t ? (t - arg) : 0), BAD_TYPE);\n\t\tgoto out;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tret = -ENOMEM;\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\tgoto out;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kcalloc(FETCH_INSN_MAX, sizeof(*code), GFP_KERNEL);\n\tif (!code)\n\t\tgoto out;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tctx->last_type = NULL;\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tif (IS_ENABLED(CONFIG_PROBE_EVENTS_BTF_ARGS) &&\n\t    ctx->last_type) {\n\t\tif (!t) {\n\t\t\tparg->type = find_fetch_type_from_btf_type(ctx);\n\t\t} else if (strstr(t, \"string\")) {\n\t\t\tret = check_prepare_btf_string_fetch(t, &code, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tret = -EINVAL;\n\t \n\tif (parg->type->is_string) {\n\t\tif (!strcmp(parg->type->name, \"symstr\")) {\n\t\t\tif (code->op != FETCH_OP_REG && code->op != FETCH_OP_STACK &&\n\t\t\t    code->op != FETCH_OP_RETVAL && code->op != FETCH_OP_ARG &&\n\t\t\t    code->op != FETCH_OP_DEREF && code->op != FETCH_OP_TP_ARG) {\n\t\t\t\ttrace_probe_log_err(ctx->offset + (t ? (t - arg) : 0),\n\t\t\t\t\t\t    BAD_SYMSTRING);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_UDEREF &&\n\t\t\t    code->op != FETCH_OP_IMM && code->op != FETCH_OP_COMM &&\n\t\t\t    code->op != FETCH_OP_DATA && code->op != FETCH_OP_TP_ARG) {\n\t\t\t\ttrace_probe_log_err(ctx->offset + (t ? (t - arg) : 0),\n\t\t\t\t\t\t    BAD_STRING);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(parg->type->name, \"symstr\") ||\n\t\t    (code->op == FETCH_OP_IMM || code->op == FETCH_OP_COMM ||\n\t\t     code->op == FETCH_OP_DATA) || code->op == FETCH_OP_TP_ARG ||\n\t\t     parg->count) {\n\t\t\t \n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!strcmp(parg->type->name, \"ustring\") ||\n\t\t    code->op == FETCH_OP_UDEREF)\n\t\t\tcode->op = FETCH_OP_ST_USTRING;\n\t\telse if (!strcmp(parg->type->name, \"symstr\"))\n\t\t\tcode->op = FETCH_OP_ST_SYMSTR;\n\t\telse\n\t\t\tcode->op = FETCH_OP_ST_STRING;\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\tcode->op = FETCH_OP_ST_UMEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t \n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(ctx->offset + t - arg, BAD_BITFIELD);\n\t\t\tgoto fail;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_PROBE_EVENTS_BTF_ARGS) &&\n\t\t   ctx->last_type) {\n\t\tret = parse_btf_bitfield(&code, ctx);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\tret = -EINVAL;\n\t \n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING &&\n\t\t    scode->op != FETCH_OP_ST_USTRING) {\n\t\t\ttrace_probe_log_err(ctx->offset + (t ? (t - arg) : 0),\n\t\t\t\t\t    BAD_STRING);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\ttrace_probe_log_err(ctx->offset, TOO_MANY_OPS);\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\tret = 0;\n\t \n\tparg->code = kcalloc(code - tmp + 1, sizeof(*code), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t\t    code->op == FETCH_OP_DATA)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\nout:\n\tkfree(arg);\n\n\treturn ret;\n}\n\n \nstatic int traceprobe_conflict_field_name(const char *name,\n\t\t\t\t\t  struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic char *generate_probe_arg_name(const char *arg, int idx)\n{\n\tchar *name = NULL;\n\tconst char *end;\n\n\t \n\tif (IS_ENABLED(CONFIG_PROBE_EVENTS_BTF_ARGS)) {\n\t\tend = strchr(arg, ':');\n\t\tif (!end)\n\t\t\tend = arg + strlen(arg);\n\n\t\tname = kmemdup_nul(arg, end - arg, GFP_KERNEL);\n\t\tif (!name || !is_good_name(name)) {\n\t\t\tkfree(name);\n\t\t\tname = NULL;\n\t\t}\n\t}\n\n\tif (!name)\n\t\tname = kasprintf(GFP_KERNEL, \"arg%d\", idx + 1);\n\n\treturn name;\n}\n\nint traceprobe_parse_probe_arg(struct trace_probe *tp, int i, const char *arg,\n\t\t\t       struct traceprobe_parse_context *ctx)\n{\n\tstruct probe_arg *parg = &tp->args[i];\n\tconst char *body;\n\n\t \n\ttp->nr_args++;\n\n\tbody = strchr(arg, '=');\n\tif (body) {\n\t\tif (body - arg > MAX_ARG_NAME_LEN) {\n\t\t\ttrace_probe_log_err(0, ARG_NAME_TOO_LONG);\n\t\t\treturn -EINVAL;\n\t\t} else if (body == arg) {\n\t\t\ttrace_probe_log_err(0, NO_ARG_NAME);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparg->name = kmemdup_nul(arg, body - arg, GFP_KERNEL);\n\t\tbody++;\n\t} else {\n\t\tparg->name = generate_probe_arg_name(arg, i);\n\t\tbody = arg;\n\t}\n\tif (!parg->name)\n\t\treturn -ENOMEM;\n\n\tif (!is_good_name(parg->name)) {\n\t\ttrace_probe_log_err(0, BAD_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tif (traceprobe_conflict_field_name(parg->name, tp->args, i)) {\n\t\ttrace_probe_log_err(0, USED_ARG_NAME);\n\t\treturn -EINVAL;\n\t}\n\tctx->offset = body - arg;\n\t \n\treturn traceprobe_parse_probe_arg_body(body, &tp->size, parg, ctx);\n}\n\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL ||\n\t\t    code->op == FETCH_OP_DATA)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}\n\nstatic int argv_has_var_arg(int argc, const char *argv[], int *args_idx,\n\t\t\t    struct traceprobe_parse_context *ctx)\n{\n\tint i, found = 0;\n\n\tfor (i = 0; i < argc; i++)\n\t\tif (str_has_prefix(argv[i], \"$arg\")) {\n\t\t\ttrace_probe_log_set_index(i + 2);\n\n\t\t\tif (!tparg_is_function_entry(ctx->flags)) {\n\t\t\t\ttrace_probe_log_err(0, NOFENTRY_ARGS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (isdigit(argv[i][4])) {\n\t\t\t\tfound = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (argv[i][4] != '*') {\n\t\t\t\ttrace_probe_log_err(0, BAD_VAR);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (*args_idx >= 0 && *args_idx < argc) {\n\t\t\t\ttrace_probe_log_err(0, DOUBLE_ARGS);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\t*args_idx = i;\n\t\t}\n\n\treturn found;\n}\n\nstatic int sprint_nth_btf_arg(int idx, const char *type,\n\t\t\t      char *buf, int bufsize,\n\t\t\t      struct traceprobe_parse_context *ctx)\n{\n\tconst char *name;\n\tint ret;\n\n\tif (idx >= ctx->nr_params) {\n\t\ttrace_probe_log_err(0, NO_BTFARG);\n\t\treturn -ENOENT;\n\t}\n\tname = btf_name_by_offset(ctx->btf, ctx->params[idx].name_off);\n\tif (!name) {\n\t\ttrace_probe_log_err(0, NO_BTF_ENTRY);\n\t\treturn -ENOENT;\n\t}\n\tret = snprintf(buf, bufsize, \"%s%s\", name, type);\n\tif (ret >= bufsize) {\n\t\ttrace_probe_log_err(0, ARGS_2LONG);\n\t\treturn -E2BIG;\n\t}\n\treturn ret;\n}\n\n \nconst char **traceprobe_expand_meta_args(int argc, const char *argv[],\n\t\t\t\t\t int *new_argc, char *buf, int bufsize,\n\t\t\t\t\t struct traceprobe_parse_context *ctx)\n{\n\tconst struct btf_param *params = NULL;\n\tint i, j, n, used, ret, args_idx = -1;\n\tconst char **new_argv = NULL;\n\n\tret = argv_has_var_arg(argc, argv, &args_idx, ctx);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!ret) {\n\t\t*new_argc = argc;\n\t\treturn NULL;\n\t}\n\n\tret = query_btf_context(ctx);\n\tif (ret < 0 || ctx->nr_params == 0) {\n\t\tif (args_idx != -1) {\n\t\t\t \n\t\t\ttrace_probe_log_err(0, NOSUP_BTFARG);\n\t\t\treturn (const char **)params;\n\t\t}\n\t\t*new_argc = argc;\n\t\treturn NULL;\n\t}\n\n\tif (args_idx >= 0)\n\t\t*new_argc = argc + ctx->nr_params - 1;\n\telse\n\t\t*new_argc = argc;\n\n\tnew_argv = kcalloc(*new_argc, sizeof(char *), GFP_KERNEL);\n\tif (!new_argv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tused = 0;\n\tfor (i = 0, j = 0; i < argc; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tif (i == args_idx) {\n\t\t\tfor (n = 0; n < ctx->nr_params; n++) {\n\t\t\t\tret = sprint_nth_btf_arg(n, \"\", buf + used,\n\t\t\t\t\t\t\t bufsize - used, ctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tnew_argv[j++] = buf + used;\n\t\t\t\tused += ret + 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (str_has_prefix(argv[i], \"$arg\")) {\n\t\t\tchar *type = NULL;\n\n\t\t\tn = simple_strtoul(argv[i] + 4, &type, 10);\n\t\t\tif (type && !(*type == ':' || *type == '\\0')) {\n\t\t\t\ttrace_probe_log_err(0, BAD_VAR);\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tret = sprint_nth_btf_arg(n - 1, type, buf + used,\n\t\t\t\t\t\t bufsize - used, ctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tnew_argv[j++] = buf + used;\n\t\t\tused += ret + 1;\n\t\t} else\n\t\t\tnew_argv[j++] = argv[i];\n\t}\n\n\treturn new_argv;\n\nerror:\n\tkfree(new_argv);\n\treturn ERR_PTR(ret);\n}\n\nvoid traceprobe_finish_parse(struct traceprobe_parse_context *ctx)\n{\n\tclear_btf_context(ctx);\n}\n\nint traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(code->data, \"+-\");\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}\n\n \n#define LEN_OR_ZERO (len ? len - pos : 0)\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   enum probe_print_type ptype)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tswitch (ptype) {\n\tcase PROBE_PRINT_NORMAL:\n\t\tfmt = \"(%lx)\";\n\t\targ = \", REC->\" FIELD_STRING_IP;\n\t\tbreak;\n\tcase PROBE_PRINT_RETURN:\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \", REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t\tbreak;\n\tcase PROBE_PRINT_EVENT:\n\t\tfmt = \"\";\n\t\targ = \"\";\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif (parg->type->is_string)\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif (parg->type->is_string)\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t \n\treturn pos;\n}\n#undef LEN_OR_ZERO\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint len;\n\tchar *print_fmt;\n\n\t \n\tlen = __set_print_fmt(tp, NULL, 0, ptype);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t \n\t__set_print_fmt(tp, print_fmt, len + 1, ptype);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void trace_probe_event_free(struct trace_probe_event *tpe)\n{\n\tkfree(tpe->class.system);\n\tkfree(tpe->call.name);\n\tkfree(tpe->call.print_fmt);\n\tkfree(tpe);\n}\n\nint trace_probe_append(struct trace_probe *tp, struct trace_probe *to)\n{\n\tif (trace_probe_has_sibling(tp))\n\t\treturn -EBUSY;\n\n\tlist_del_init(&tp->list);\n\ttrace_probe_event_free(tp->event);\n\n\ttp->event = to->event;\n\tlist_add_tail(&tp->list, trace_probe_probe_list(to));\n\n\treturn 0;\n}\n\nvoid trace_probe_unlink(struct trace_probe *tp)\n{\n\tlist_del_init(&tp->list);\n\tif (list_empty(trace_probe_probe_list(tp)))\n\t\ttrace_probe_event_free(tp->event);\n\ttp->event = NULL;\n}\n\nvoid trace_probe_cleanup(struct trace_probe *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->nr_args; i++)\n\t\ttraceprobe_free_probe_arg(&tp->args[i]);\n\n\tif (tp->event)\n\t\ttrace_probe_unlink(tp);\n}\n\nint trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter)\n{\n\tstruct trace_event_call *call;\n\tsize_t size = sizeof(struct trace_probe_event);\n\tint ret = 0;\n\n\tif (!event || !group)\n\t\treturn -EINVAL;\n\n\tif (alloc_filter)\n\t\tsize += sizeof(struct trace_uprobe_filter);\n\n\ttp->event = kzalloc(size, GFP_KERNEL);\n\tif (!tp->event)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&tp->event->files);\n\tINIT_LIST_HEAD(&tp->event->class.fields);\n\tINIT_LIST_HEAD(&tp->event->probes);\n\tINIT_LIST_HEAD(&tp->list);\n\tlist_add(&tp->list, &tp->event->probes);\n\n\tcall = trace_probe_event_call(tp);\n\tcall->class = &tp->event->class;\n\tcall->name = kstrdup(event, GFP_KERNEL);\n\tif (!call->name) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttp->event->class.system = kstrdup(group, GFP_KERNEL);\n\tif (!tp->event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ttrace_probe_cleanup(tp);\n\treturn ret;\n}\n\nstatic struct trace_event_call *\nfind_trace_event_call(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\treturn tp_event;\n\t}\n\n\treturn NULL;\n}\n\nint trace_probe_register_event_call(struct trace_probe *tp)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(tp);\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (find_trace_event_call(trace_probe_group_name(tp),\n\t\t\t\t  trace_probe_name(tp)))\n\t\treturn -EEXIST;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret)\n\t\treturn -ENODEV;\n\n\tret = trace_add_event_call(call);\n\tif (ret)\n\t\tunregister_trace_event(&call->event);\n\n\treturn ret;\n}\n\nint trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = kmalloc(sizeof(*link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->file = file;\n\tINIT_LIST_HEAD(&link->list);\n\tlist_add_tail_rcu(&link->list, &tp->event->files);\n\ttrace_probe_set_flag(tp, TP_FLAG_TRACE);\n\treturn 0;\n}\n\nstruct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link(link, tp) {\n\t\tif (link->file == file)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}\n\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_file_link *link;\n\n\tlink = trace_probe_get_file_link(tp, file);\n\tif (!link)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&link->list);\n\tkvfree_rcu_mightsleep(link);\n\n\tif (list_empty(&tp->event->files))\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\n\treturn 0;\n}\n\n \nint trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b)\n{\n\tint i;\n\n\t \n\tif (a->nr_args < b->nr_args)\n\t\treturn a->nr_args + 1;\n\tif (a->nr_args > b->nr_args)\n\t\treturn b->nr_args + 1;\n\n\tfor (i = 0; i < a->nr_args; i++) {\n\t\tif ((b->nr_args <= i) ||\n\t\t    ((a->args[i].type != b->args[i].type) ||\n\t\t     (a->args[i].count != b->args[i].count) ||\n\t\t     strcmp(a->args[i].name, b->args[i].name)))\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\nbool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint i;\n\n\tif (tp->nr_args < argc)\n\t\treturn false;\n\n\tfor (i = 0; i < argc; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"%s=%s\",\n\t\t\t tp->args[i].name, tp->args[i].comm);\n\t\tif (strcmp(buf, argv[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint trace_probe_create(const char *raw_command, int (*createfn)(int, const char **))\n{\n\tint argc = 0, ret = 0;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, (const char **)argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}\n\nint trace_probe_print_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field)\n{\n\tvoid *p;\n\tint i, j;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tstruct probe_arg *a = args + i;\n\n\t\ttrace_seq_printf(s, \" %s=\", a->name);\n\t\tif (likely(!a->count)) {\n\t\t\tif (!a->type->print(s, data + a->offset, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_seq_putc(s, '{');\n\t\tp = data + a->offset;\n\t\tfor (j = 0; j < a->count; j++) {\n\t\t\tif (!a->type->print(s, p, field))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttrace_seq_putc(s, j == a->count - 1 ? '}' : ',');\n\t\t\tp += a->type->size;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}