{
  "module_name": "trace_events_filter.c",
  "hash_id": "e0b922ac7fa0cf8472861e3131004cb2af9c23cd6c84653e2d4ae62821a4908d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_events_filter.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\n \n#define OPS\t\t\t\t\t\\\n\tC( OP_GLOB,\t\"~\"  ),\t\t\t\\\n\tC( OP_NE,\t\"!=\" ),\t\t\t\\\n\tC( OP_EQ,\t\"==\" ),\t\t\t\\\n\tC( OP_LE,\t\"<=\" ),\t\t\t\\\n\tC( OP_LT,\t\"<\"  ),\t\t\t\\\n\tC( OP_GE,\t\">=\" ),\t\t\t\\\n\tC( OP_GT,\t\">\"  ),\t\t\t\\\n\tC( OP_BAND,\t\"&\"  ),\t\t\t\\\n\tC( OP_MAX,\tNULL )\n\n#undef C\n#define C(a, b)\ta\n\nenum filter_op_ids { OPS };\n\n#undef C\n#define C(a, b)\tb\n\nstatic const char * ops[] = { OPS };\n\nenum filter_pred_fn {\n\tFILTER_PRED_FN_NOP,\n\tFILTER_PRED_FN_64,\n\tFILTER_PRED_FN_64_CPUMASK,\n\tFILTER_PRED_FN_S64,\n\tFILTER_PRED_FN_U64,\n\tFILTER_PRED_FN_32,\n\tFILTER_PRED_FN_32_CPUMASK,\n\tFILTER_PRED_FN_S32,\n\tFILTER_PRED_FN_U32,\n\tFILTER_PRED_FN_16,\n\tFILTER_PRED_FN_16_CPUMASK,\n\tFILTER_PRED_FN_S16,\n\tFILTER_PRED_FN_U16,\n\tFILTER_PRED_FN_8,\n\tFILTER_PRED_FN_8_CPUMASK,\n\tFILTER_PRED_FN_S8,\n\tFILTER_PRED_FN_U8,\n\tFILTER_PRED_FN_COMM,\n\tFILTER_PRED_FN_STRING,\n\tFILTER_PRED_FN_STRLOC,\n\tFILTER_PRED_FN_STRRELLOC,\n\tFILTER_PRED_FN_PCHAR_USER,\n\tFILTER_PRED_FN_PCHAR,\n\tFILTER_PRED_FN_CPU,\n\tFILTER_PRED_FN_CPU_CPUMASK,\n\tFILTER_PRED_FN_CPUMASK,\n\tFILTER_PRED_FN_CPUMASK_CPU,\n\tFILTER_PRED_FN_FUNCTION,\n\tFILTER_PRED_FN_,\n\tFILTER_PRED_TEST_VISITED,\n};\n\nstruct filter_pred {\n\tstruct regex\t\t*regex;\n\tstruct cpumask          *mask;\n\tunsigned short\t\t*ops;\n\tstruct ftrace_event_field *field;\n\tu64\t\t\tval;\n\tu64\t\t\tval2;\n\tenum filter_pred_fn\tfn_num;\n\tint\t\t\toffset;\n\tint\t\t\tnot;\n\tint\t\t\top;\n};\n\n \n#define PRED_FUNC_START\t\t\tOP_LE\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n\n#define ERRORS\t\t\t\t\t\t\t\t\\\n\tC(NONE,\t\t\t\"No error\"),\t\t\t\t\\\n\tC(INVALID_OP,\t\t\"Invalid operator\"),\t\t\t\\\n\tC(TOO_MANY_OPEN,\t\"Too many '('\"),\t\t\t\\\n\tC(TOO_MANY_CLOSE,\t\"Too few '('\"),\t\t\t\t\\\n\tC(MISSING_QUOTE,\t\"Missing matching quote\"),\t\t\\\n\tC(MISSING_BRACE_OPEN,   \"Missing '{'\"),\t\t\t\t\\\n\tC(MISSING_BRACE_CLOSE,  \"Missing '}'\"),\t\t\t\t\\\n\tC(OPERAND_TOO_LONG,\t\"Operand too long\"),\t\t\t\\\n\tC(EXPECT_STRING,\t\"Expecting string field\"),\t\t\\\n\tC(EXPECT_DIGIT,\t\t\"Expecting numeric field\"),\t\t\\\n\tC(ILLEGAL_FIELD_OP,\t\"Illegal operation for field type\"),\t\\\n\tC(FIELD_NOT_FOUND,\t\"Field not found\"),\t\t\t\\\n\tC(ILLEGAL_INTVAL,\t\"Illegal integer value\"),\t\t\\\n\tC(BAD_SUBSYS_FILTER,\t\"Couldn't find or set field in one of a subsystem's events\"), \\\n\tC(TOO_MANY_PREDS,\t\"Too many terms in predicate expression\"), \\\n\tC(INVALID_FILTER,\t\"Meaningless filter expression\"),\t\\\n\tC(INVALID_CPULIST,\t\"Invalid cpulist\"),\t\\\n\tC(IP_FIELD_ONLY,\t\"Only 'ip' field is supported for function trace\"), \\\n\tC(INVALID_VALUE,\t\"Invalid value (did you forget quotes)?\"), \\\n\tC(NO_FUNCTION,\t\t\"Function not found\"),\t\t\t\\\n\tC(ERRNO,\t\t\"Error\"),\t\t\t\t\\\n\tC(NO_FILTER,\t\t\"No filter found\")\n\n#undef C\n#define C(a, b)\t\tFILT_ERR_##a\n\nenum { ERRORS };\n\n#undef C\n#define C(a, b)\t\tb\n\nstatic const char *err_text[] = { ERRORS };\n\n \nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstruct prog_entry {\n\tint\t\t\ttarget;\n\tint\t\t\twhen_to_branch;\n\tstruct filter_pred\t*pred;\n};\n\n \nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}\n\nstruct filter_parse_error {\n\tint lasterr;\n\tint lasterr_pos;\n};\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}\n\ntypedef int (*parse_pred_fn)(const char *str, void *data, int pos,\n\t\t\t     struct filter_parse_error *pe,\n\t\t\t     struct filter_pred **pred);\n\nenum {\n\tINVERT\t\t= 1,\n\tPROCESS_AND\t= 2,\n\tPROCESS_OR\t= 4,\n};\n\nstatic void free_predicate(struct filter_pred *pred)\n{\n\tif (pred) {\n\t\tkfree(pred->regex);\n\t\tkfree(pred->mask);\n\t\tkfree(pred);\n\t}\n}\n\n \nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2;  \n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t \n\twhile (*ptr) {\t\t\t\t\t\t \n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t \n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t \n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t \n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t \n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t \n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t \n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t \n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t \n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t \n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t \n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t \n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t \n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t \n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t \n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t \n\tprog[N].target = 1;\t\t \n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t \n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t \n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t \n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t \n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tfree_predicate(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}\n\nstatic inline int\ndo_filter_cpumask(int op, const struct cpumask *mask, const struct cpumask *cmp)\n{\n\tswitch (op) {\n\tcase OP_EQ:\n\t\treturn cpumask_equal(mask, cmp);\n\tcase OP_NE:\n\t\treturn !cpumask_equal(mask, cmp);\n\tcase OP_BAND:\n\t\treturn cpumask_intersects(mask, cmp);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic inline int\ndo_filter_scalar_cpumask(int op, unsigned int cpu, const struct cpumask *mask)\n{\n\t \n\tswitch (op) {\n\tcase OP_EQ:\n\t\treturn false;\n\tcase OP_NE:\n\t\treturn true;\n\tcase OP_BAND:\n\t\treturn cpumask_test_cpu(cpu, mask);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int\ndo_filter_cpumask_scalar(int op, const struct cpumask *mask, unsigned int cpu)\n{\n\tswitch (op) {\n\tcase OP_EQ:\n\t\treturn cpumask_test_cpu(cpu, mask) &&\n\t\t\tcpumask_nth(1, mask) >= nr_cpu_ids;\n\tcase OP_NE:\n\t\treturn !cpumask_test_cpu(cpu, mask) ||\n\t\t\tcpumask_nth(1, mask) < nr_cpu_ids;\n\tcase OP_BAND:\n\t\treturn cpumask_test_cpu(cpu, mask);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nenum pred_cmp_types {\n\tPRED_CMP_TYPE_NOP,\n\tPRED_CMP_TYPE_LT,\n\tPRED_CMP_TYPE_LE,\n\tPRED_CMP_TYPE_GT,\n\tPRED_CMP_TYPE_GE,\n\tPRED_CMP_TYPE_BAND,\n};\n\n#define DEFINE_COMPARISON_PRED(type)\t\t\t\t\t\\\nstatic int filter_pred_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tswitch (pred->op) {\t\t\t\t\t\t\\\n\tcase OP_LT: {\t\t\t\t\t\t\t\\\n\t\ttype *addr = (type *)(event + pred->offset);\t\t\\\n\t\ttype val = (type)pred->val;\t\t\t\t\\\n\t\treturn *addr < val;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tcase OP_LE: {\t\t\t\t\t\\\n\t\ttype *addr = (type *)(event + pred->offset);\t\t\\\n\t\ttype val = (type)pred->val;\t\t\t\t\\\n\t\treturn *addr <= val;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tcase OP_GT: {\t\t\t\t\t\\\n\t\ttype *addr = (type *)(event + pred->offset);\t\t\\\n\t\ttype val = (type)pred->val;\t\t\t\t\\\n\t\treturn *addr > val;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tcase OP_GE: {\t\t\t\t\t\\\n\t\ttype *addr = (type *)(event + pred->offset);\t\t\\\n\t\ttype val = (type)pred->val;\t\t\t\t\\\n\t\treturn *addr >= val;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tcase OP_BAND: {\t\t\t\t\t\\\n\t\ttype *addr = (type *)(event + pred->offset);\t\t\\\n\t\ttype val = (type)pred->val;\t\t\t\t\\\n\t\treturn !!(*addr & val);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define DEFINE_CPUMASK_COMPARISON_PRED(size)\t\t\t\t\t\\\nstatic int filter_pred_##size##_cpumask(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tu##size *addr = (u##size *)(event + pred->offset);\t\t\t\\\n\tunsigned int cpu = *addr;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (cpu >= nr_cpu_ids)\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);\t\t\\\n}\n\n#define DEFINE_EQUALITY_PRED(size)\t\t\t\t\t\\\nstatic int filter_pred_##size(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu##size *addr = (u##size *)(event + pred->offset);\t\t\\\n\tu##size val = (u##size)pred->val;\t\t\t\t\\\n\tint match;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmatch = (val == *addr) ^ pred->not;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn match;\t\t\t\t\t\t\t\\\n}\n\nDEFINE_COMPARISON_PRED(s64);\nDEFINE_COMPARISON_PRED(u64);\nDEFINE_COMPARISON_PRED(s32);\nDEFINE_COMPARISON_PRED(u32);\nDEFINE_COMPARISON_PRED(s16);\nDEFINE_COMPARISON_PRED(u16);\nDEFINE_COMPARISON_PRED(s8);\nDEFINE_COMPARISON_PRED(u8);\n\nDEFINE_CPUMASK_COMPARISON_PRED(64);\nDEFINE_CPUMASK_COMPARISON_PRED(32);\nDEFINE_CPUMASK_COMPARISON_PRED(16);\nDEFINE_CPUMASK_COMPARISON_PRED(8);\n\nDEFINE_EQUALITY_PRED(64);\nDEFINE_EQUALITY_PRED(32);\nDEFINE_EQUALITY_PRED(16);\nDEFINE_EQUALITY_PRED(8);\n\n \n#define USTRING_BUF_SIZE\t1024\n\nstruct ustring_buffer {\n\tchar\t\tbuffer[USTRING_BUF_SIZE];\n};\n\nstatic __percpu struct ustring_buffer *ustring_per_cpu;\n\nstatic __always_inline char *test_string(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t \n\tif (!strncpy_from_kernel_nofault(kstr, str, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\treturn kstr;\n}\n\nstatic __always_inline char *test_ustring(char *str)\n{\n\tstruct ustring_buffer *ubuf;\n\tchar __user *ustr;\n\tchar *kstr;\n\n\tif (!ustring_per_cpu)\n\t\treturn NULL;\n\n\tubuf = this_cpu_ptr(ustring_per_cpu);\n\tkstr = ubuf->buffer;\n\n\t \n\tustr = (char __user *)str;\n\tif (!strncpy_from_user_nofault(kstr, ustr, USTRING_BUF_SIZE))\n\t\treturn NULL;\n\n\treturn kstr;\n}\n\n \nstatic int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex->match(addr, pred->regex, pred->regex->field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\nstatic __always_inline int filter_pchar(struct filter_pred *pred, char *str)\n{\n\tint cmp, match;\n\tint len;\n\n\tlen = strlen(str) + 1;\t \n\tcmp = pred->regex->match(str, pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n \nstatic int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tchar *str;\n\n\tstr = test_string(*addr);\n\tif (!str)\n\t\treturn 0;\n\n\treturn filter_pchar(pred, str);\n}\n\n \nstatic int filter_pred_pchar_user(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tchar *str;\n\n\tstr = test_ustring(*addr);\n\tif (!str)\n\t\treturn 0;\n\n\treturn filter_pchar(pred, str);\n}\n\n \nstatic int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex->match(addr, pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n \nstatic int filter_pred_strrelloc(struct filter_pred *pred, void *event)\n{\n\tu32 *item = (u32 *)(event + pred->offset);\n\tu32 str_item = *item;\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(&item[1]) + str_loc;\n\tint cmp, match;\n\n\tcmp = pred->regex->match(addr, pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n \nstatic int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int filter_pred_cpu_cpumask(struct filter_pred *pred, void *event)\n{\n\tint cpu = raw_smp_processor_id();\n\n\treturn do_filter_scalar_cpumask(pred->op, cpu, pred->mask);\n}\n\n \nstatic int filter_pred_cpumask(struct filter_pred *pred, void *event)\n{\n\tu32 item = *(u32 *)(event + pred->offset);\n\tint loc = item & 0xffff;\n\tconst struct cpumask *mask = (event + loc);\n\tconst struct cpumask *cmp = pred->mask;\n\n\treturn do_filter_cpumask(pred->op, mask, cmp);\n}\n\n \nstatic int filter_pred_cpumask_cpu(struct filter_pred *pred, void *event)\n{\n\tu32 item = *(u32 *)(event + pred->offset);\n\tint loc = item & 0xffff;\n\tconst struct cpumask *mask = (event + loc);\n\tunsigned int cpu = pred->val;\n\n\treturn do_filter_cpumask_scalar(pred->op, mask, cpu);\n}\n\n \nstatic int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex->match(current->comm, pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}\n\n \nstatic int filter_pred_function(struct filter_pred *pred, void *event)\n{\n\tunsigned long *addr = (unsigned long *)(event + pred->offset);\n\tunsigned long start = (unsigned long)pred->val;\n\tunsigned long end = (unsigned long)pred->val2;\n\tint ret = *addr >= start && *addr < end;\n\n\treturn pred->op == OP_EQ ? ret : !ret;\n}\n\n \n\nstatic int regex_match_full(char *str, struct regex *r, int len)\n{\n\t \n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}\n\nstatic int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}\n\nstatic int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}\n\nstatic int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t \n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t \n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}\n\n\n#ifdef CONFIG_FTRACE_STARTUP_TEST\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event);\n#else\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}\n#endif\n\n\nstatic int filter_pred_fn_call(struct filter_pred *pred, void *event);\n\n \nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t \n\tif (!filter)\n\t\treturn 1;\n\n\t \n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = filter_pred_fn_call(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}\nEXPORT_SYMBOL_GPL(filter_match_preds);\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t \n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}\n\nstatic inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}\n\n \nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tfree_predicate(prog[i].pred);\n\tkfree(prog);\n}\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\")) {\n\t\tif (strstr(type, \"char\"))\n\t\t\treturn FILTER_DYN_STRING;\n\t\tif (strstr(type, \"cpumask_t\"))\n\t\t\treturn FILTER_CPUMASK;\n\t}\n\n\tif (strstr(type, \"__rel_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_RDYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}\n\nstatic enum filter_pred_fn select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t\tint field_size, int field_is_signed)\n{\n\tenum filter_pred_fn fn = FILTER_PRED_FN_NOP;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn fn;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn fn;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = FILTER_PRED_FN_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = FILTER_PRED_FN_S64;\n\t\telse\n\t\t\tfn = FILTER_PRED_FN_U64;\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = FILTER_PRED_FN_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = FILTER_PRED_FN_S32;\n\t\telse\n\t\t\tfn = FILTER_PRED_FN_U32;\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = FILTER_PRED_FN_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = FILTER_PRED_FN_S16;\n\t\telse\n\t\t\tfn = FILTER_PRED_FN_U16;\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = FILTER_PRED_FN_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = FILTER_PRED_FN_S8;\n\t\telse\n\t\t\tfn = FILTER_PRED_FN_U8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}\n\n\nstatic int filter_pred_fn_call(struct filter_pred *pred, void *event)\n{\n\tswitch (pred->fn_num) {\n\tcase FILTER_PRED_FN_64:\n\t\treturn filter_pred_64(pred, event);\n\tcase FILTER_PRED_FN_64_CPUMASK:\n\t\treturn filter_pred_64_cpumask(pred, event);\n\tcase FILTER_PRED_FN_S64:\n\t\treturn filter_pred_s64(pred, event);\n\tcase FILTER_PRED_FN_U64:\n\t\treturn filter_pred_u64(pred, event);\n\tcase FILTER_PRED_FN_32:\n\t\treturn filter_pred_32(pred, event);\n\tcase FILTER_PRED_FN_32_CPUMASK:\n\t\treturn filter_pred_32_cpumask(pred, event);\n\tcase FILTER_PRED_FN_S32:\n\t\treturn filter_pred_s32(pred, event);\n\tcase FILTER_PRED_FN_U32:\n\t\treturn filter_pred_u32(pred, event);\n\tcase FILTER_PRED_FN_16:\n\t\treturn filter_pred_16(pred, event);\n\tcase FILTER_PRED_FN_16_CPUMASK:\n\t\treturn filter_pred_16_cpumask(pred, event);\n\tcase FILTER_PRED_FN_S16:\n\t\treturn filter_pred_s16(pred, event);\n\tcase FILTER_PRED_FN_U16:\n\t\treturn filter_pred_u16(pred, event);\n\tcase FILTER_PRED_FN_8:\n\t\treturn filter_pred_8(pred, event);\n\tcase FILTER_PRED_FN_8_CPUMASK:\n\t\treturn filter_pred_8_cpumask(pred, event);\n\tcase FILTER_PRED_FN_S8:\n\t\treturn filter_pred_s8(pred, event);\n\tcase FILTER_PRED_FN_U8:\n\t\treturn filter_pred_u8(pred, event);\n\tcase FILTER_PRED_FN_COMM:\n\t\treturn filter_pred_comm(pred, event);\n\tcase FILTER_PRED_FN_STRING:\n\t\treturn filter_pred_string(pred, event);\n\tcase FILTER_PRED_FN_STRLOC:\n\t\treturn filter_pred_strloc(pred, event);\n\tcase FILTER_PRED_FN_STRRELLOC:\n\t\treturn filter_pred_strrelloc(pred, event);\n\tcase FILTER_PRED_FN_PCHAR_USER:\n\t\treturn filter_pred_pchar_user(pred, event);\n\tcase FILTER_PRED_FN_PCHAR:\n\t\treturn filter_pred_pchar(pred, event);\n\tcase FILTER_PRED_FN_CPU:\n\t\treturn filter_pred_cpu(pred, event);\n\tcase FILTER_PRED_FN_CPU_CPUMASK:\n\t\treturn filter_pred_cpu_cpumask(pred, event);\n\tcase FILTER_PRED_FN_CPUMASK:\n\t\treturn filter_pred_cpumask(pred, event);\n\tcase FILTER_PRED_FN_CPUMASK_CPU:\n\t\treturn filter_pred_cpumask_cpu(pred, event);\n\tcase FILTER_PRED_FN_FUNCTION:\n\t\treturn filter_pred_function(pred, event);\n\tcase FILTER_PRED_TEST_VISITED:\n\t\treturn test_pred_visited_fn(pred, event);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tunsigned long offset;\n\tunsigned long size;\n\tunsigned long ip;\n\tchar num_buf[24];\t \n\tchar *field_name;\n\tchar *name;\n\tbool function = false;\n\tbool ustring = false;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t \n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t \n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((len = str_has_prefix(str + i, \".ustring\"))) {\n\t\tustring = true;\n\t\ti += len;\n\t}\n\n\t \n\tif ((len = str_has_prefix(str + i, \".function\"))) {\n\t\tfunction = true;\n\t\ti += len;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t \n\tfor (op = 0; ops[op]; op++) {\n\t\t \n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (function) {\n\t\t \n\t\tif (field->size != sizeof(long)) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t \n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (isdigit(str[i])) {\n\t\t\t \n\t\t\twhile (isalnum(str[i]))\n\t\t\t\ti++;\n\n\t\t\tlen = i - s;\n\t\t\t \n\t\t\tif (len >= sizeof(num_buf)) {\n\t\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\n\t\t\tstrncpy(num_buf, str + s, len);\n\t\t\tnum_buf[len] = 0;\n\n\t\t\tret = kstrtoul(num_buf, 0, &ip);\n\t\t\tif (ret) {\n\t\t\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t} else {\n\t\t\ts = i;\n\t\t\tfor (; str[i] && !isspace(str[i]); i++)\n\t\t\t\t;\n\n\t\t\tlen = i - s;\n\t\t\tname = kmemdup_nul(str + s, len, GFP_KERNEL);\n\t\t\tif (!name)\n\t\t\t\tgoto err_mem;\n\t\t\tip = kallsyms_lookup_name(name);\n\t\t\tkfree(name);\n\t\t\tif (!ip) {\n\t\t\t\tparse_error(pe, FILT_ERR_NO_FUNCTION, pos + i);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!kallsyms_lookup_size_offset(ip, &size, &offset)) {\n\t\t\tparse_error(pe, FILT_ERR_NO_FUNCTION, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->fn_num = FILTER_PRED_FN_FUNCTION;\n\t\tpred->val = ip - offset;\n\t\tpred->val2 = pred->val + size;\n\n\t} else if (ftrace_event_is_function(call)) {\n\t\t \n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn_num = FILTER_PRED_FN_NOP;\n\n\t\t \n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex = kzalloc(sizeof(*pred->regex), GFP_KERNEL);\n\t\tif (!pred->regex)\n\t\t\tgoto err_mem;\n\t\tpred->regex->len = len;\n\t\tstrncpy(pred->regex->pattern, str + s, len);\n\t\tpred->regex->pattern[len] = 0;\n\n\t} else if (!strncmp(str + i, \"CPUS\", 4)) {\n\t\tunsigned int maskstart;\n\t\tbool single;\n\t\tchar *tmp;\n\n\t\tswitch (field->filter_type) {\n\t\tcase FILTER_CPUMASK:\n\t\tcase FILTER_CPU:\n\t\tcase FILTER_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tswitch (op) {\n\t\tcase OP_EQ:\n\t\tcase OP_NE:\n\t\tcase OP_BAND:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t \n\t\ti += 4;\n\t\tif (str[i++] != '{') {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_BRACE_OPEN, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tmaskstart = i;\n\n\t\t \n\t\tfor (; str[i] && str[i] != '}'; i++)\n\t\t\t;\n\n\t\tif (str[i] != '}') {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_BRACE_CLOSE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (maskstart == i) {\n\t\t\tparse_error(pe, FILT_ERR_INVALID_CPULIST, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t \n\t\ttmp = kmalloc((i - maskstart) + 1, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto err_mem;\n\n\t\tstrscpy(tmp, str + maskstart, (i - maskstart) + 1);\n\t\tpred->mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\tif (!pred->mask) {\n\t\t\tkfree(tmp);\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\t \n\t\tif (cpulist_parse(tmp, pred->mask)) {\n\t\t\tkfree(tmp);\n\t\t\tparse_error(pe, FILT_ERR_INVALID_CPULIST, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tkfree(tmp);\n\n\t\t \n\t\ti++;\n\n\t\t \n\t\tsingle = cpumask_weight(pred->mask) == 1;\n\t\tif (single) {\n\t\t\tpred->val = cpumask_first(pred->mask);\n\t\t\tkfree(pred->mask);\n\t\t\tpred->mask = NULL;\n\t\t}\n\n\t\tif (field->filter_type == FILTER_CPUMASK) {\n\t\t\tpred->fn_num = single ?\n\t\t\t\tFILTER_PRED_FN_CPUMASK_CPU :\n\t\t\t\tFILTER_PRED_FN_CPUMASK;\n\t\t} else if (field->filter_type == FILTER_CPU) {\n\t\t\tif (single) {\n\t\t\t\tif (pred->op == OP_BAND)\n\t\t\t\t\tpred->op = OP_EQ;\n\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_CPU;\n\t\t\t} else {\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_CPU_CPUMASK;\n\t\t\t}\n\t\t} else if (single) {\n\t\t\tif (pred->op == OP_BAND)\n\t\t\t\tpred->op = OP_EQ;\n\n\t\t\tpred->fn_num = select_comparison_fn(pred->op, field->size, false);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t} else {\n\t\t\tswitch (field->size) {\n\t\t\tcase 8:\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_64_CPUMASK;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_32_CPUMASK;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_16_CPUMASK;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_8_CPUMASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t \n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t \n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\tfallthrough;\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t \n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t \n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex = kzalloc(sizeof(*pred->regex), GFP_KERNEL);\n\t\tif (!pred->regex)\n\t\t\tgoto err_mem;\n\t\tpred->regex->len = len;\n\t\tstrncpy(pred->regex->pattern, str + s, len);\n\t\tpred->regex->pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn_num = FILTER_PRED_FN_COMM;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn_num = FILTER_PRED_FN_STRING;\n\t\t\tpred->regex->field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\tpred->fn_num = FILTER_PRED_FN_STRLOC;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\tpred->fn_num = FILTER_PRED_FN_STRRELLOC;\n\t\telse {\n\n\t\t\tif (!ustring_per_cpu) {\n\t\t\t\t \n\t\t\t\tustring_per_cpu = alloc_percpu(struct ustring_buffer);\n\t\t\t\tif (!ustring_per_cpu)\n\t\t\t\t\tgoto err_mem;\n\t\t\t}\n\n\t\t\tif (ustring)\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_PCHAR_USER;\n\t\t\telse\n\t\t\t\tpred->fn_num = FILTER_PRED_FN_PCHAR;\n\t\t}\n\t\t \n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t \n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t \n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t \n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t \n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn_num = FILTER_PRED_FN_CPU;\n\t\telse {\n\t\t\tpred->fn_num = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\t    field->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tfree_predicate(pred);\n\treturn -EINVAL;\nerr_mem:\n\tfree_predicate(pred);\n\treturn -ENOMEM;\n}\n\nenum {\n\tTOO_MANY_CLOSE\t\t= -1,\n\tTOO_MANY_OPEN\t\t= -2,\n\tMISSING_QUOTE\t\t= -3,\n};\n\n \nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1;  \n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t \n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t \n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}\n\nstruct filter_list {\n\tstruct list_head\tlist;\n\tstruct event_filter\t*filter;\n};\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t \n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t \n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t \n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\t__free_filter(filter);\n\t \n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}\n\n \nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t \n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}\n\nint create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}\n\n \nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, dir->tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t \n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(dir->tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}\n\n \nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (file->flags & EVENT_FILE_FL_FREED)\n\t\treturn -ENODEV;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t \n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t \n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t \n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t \n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t \n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, filter_string, &filter);\n\tif (filter) {\n\t\t \n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n\n#ifdef CONFIG_PERF_EVENTS\n\nvoid ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}\n\nstruct function_filter_data {\n\tstruct ftrace_ops *ops;\n\tint first_filter;\n\tint first_notrace;\n};\n\n#ifdef CONFIG_FUNCTION_TRACER\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t \n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t \n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t \n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t \n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex->pattern,\n\t\t\t\t\t    pred->regex->len,\n\t\t\t\t\t    data);\n}\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t \n\ttarget = prog[i].target + 1;\n\t \n\tif (prog[target].pred)\n\t\treturn false;\n\n\t \n\treturn prog[i].when_to_branch == prog[target].target;\n}\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n#else\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nint ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(NULL, call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n\n#endif  \n\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace_events_filter_test.h\"\n\n#define DATA_REC(m, va, vb, vc, vd, ve, vf, vg, vh, nvisit) \\\n{ \\\n\t.filter = FILTER, \\\n\t.rec    = { .a = va, .b = vb, .c = vc, .d = vd, \\\n\t\t    .e = ve, .f = vf, .g = vg, .h = vh }, \\\n\t.match  = m, \\\n\t.not_visited = nvisit, \\\n}\n#define YES 1\n#define NO  0\n\nstatic struct test_filter_data_t {\n\tchar *filter;\n\tstruct trace_event_raw_ftrace_test_filter rec;\n\tint match;\n\tchar *not_visited;\n} test_filter_data[] = {\n#define FILTER \"a == 1 && b == 1 && c == 1 && d == 1 && \" \\\n\t       \"e == 1 && f == 1 && g == 1 && h == 1\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"\"),\n\tDATA_REC(NO,  0, 1, 1, 1, 1, 1, 1, 1, \"bcdefgh\"),\n\tDATA_REC(NO,  1, 1, 1, 1, 1, 1, 1, 0, \"\"),\n#undef FILTER\n#define FILTER \"a == 1 || b == 1 || c == 1 || d == 1 || \" \\\n\t       \"e == 1 || f == 1 || g == 1 || h == 1\"\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 0, \"\"),\n\tDATA_REC(YES, 0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 0, 0, 0, 0, 0, 0, \"bcdefgh\"),\n#undef FILTER\n#define FILTER \"(a == 1 || b == 1) && (c == 1 || d == 1) && \" \\\n\t       \"(e == 1 || f == 1) && (g == 1 || h == 1)\"\n\tDATA_REC(NO,  0, 0, 1, 1, 1, 1, 1, 1, \"dfh\"),\n\tDATA_REC(YES, 0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 1, 0, 0, 1, 0, 1, \"bd\"),\n\tDATA_REC(NO,  1, 0, 1, 0, 0, 1, 0, 0, \"bd\"),\n#undef FILTER\n#define FILTER \"(a == 1 && b == 1) || (c == 1 && d == 1) || \" \\\n\t       \"(e == 1 && f == 1) || (g == 1 && h == 1)\"\n\tDATA_REC(YES, 1, 0, 1, 1, 1, 1, 1, 1, \"efgh\"),\n\tDATA_REC(YES, 0, 0, 0, 0, 0, 0, 1, 1, \"\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n#undef FILTER\n#define FILTER \"(a == 1 && b == 1) && (c == 1 && d == 1) && \" \\\n\t       \"(e == 1 && f == 1) || (g == 1 && h == 1)\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 0, 0, \"gh\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 0, 1, 1, \"\"),\n#undef FILTER\n#define FILTER \"((a == 1 || b == 1) || (c == 1 || d == 1) || \" \\\n\t       \"(e == 1 || f == 1)) && (g == 1 || h == 1)\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 0, 1, \"bcdef\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 0, \"\"),\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 0, 1, 1, \"h\"),\n#undef FILTER\n#define FILTER \"((((((((a == 1) && (b == 1)) || (c == 1)) && (d == 1)) || \" \\\n\t       \"(e == 1)) && (f == 1)) || (g == 1)) && (h == 1))\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"ceg\"),\n\tDATA_REC(NO,  0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(NO,  1, 0, 1, 0, 1, 0, 1, 0, \"\"),\n#undef FILTER\n#define FILTER \"((((((((a == 1) || (b == 1)) && (c == 1)) || (d == 1)) && \" \\\n\t       \"(e == 1)) || (f == 1)) && (g == 1)) || (h == 1))\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"bdfh\"),\n\tDATA_REC(YES, 0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 1, 0, 1, 0, 1, 0, \"bdfh\"),\n};\n\n#undef DATA_REC\n#undef FILTER\n#undef YES\n#undef NO\n\n#define DATA_CNT ARRAY_SIZE(test_filter_data)\n\nstatic int test_pred_visited;\n\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(pred->fn_num == FILTER_PRED_FN_NOP);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn_num = FILTER_PRED_TEST_VISITED;\n\t}\n}\n\nstatic __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(NULL, &event_ftrace_test_filter,\n\t\t\t\t    d->filter, false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&event_mutex);\n\t\t \n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}\n\nlate_initcall(ftrace_test_event_filter);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}