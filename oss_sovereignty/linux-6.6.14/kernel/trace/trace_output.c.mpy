{
  "module_name": "trace_output.c",
  "hash_id": "47684711ad79dbf60ef903f3533886c99ff00024e8108bcf4ea0c8521fee1cdb",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_output.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/ftrace.h>\n#include <linux/kprobes.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/mm.h>\n#include <linux/idr.h>\n\n#include \"trace_output.h\"\n\n \n#define EVENT_HASHSIZE\t128\n\nDECLARE_RWSEM(trace_event_sem);\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE] __read_mostly;\n\nenum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\nenum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nenum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nconst char *\ntrace_print_flags_seq(struct trace_seq *p, const char *delim,\n\t\t      unsigned long flags,\n\t\t      const struct trace_print_flags *flag_array)\n{\n\tunsigned long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t \n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%lx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_flags_seq);\n\nconst char *\ntrace_print_symbols_seq(struct trace_seq *p, unsigned long val,\n\t\t\tconst struct trace_print_flags *symbol_array)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0;  symbol_array[i].name; i++) {\n\n\t\tif (val != symbol_array[i].mask)\n\t\t\tcontinue;\n\n\t\ttrace_seq_puts(p, symbol_array[i].name);\n\t\tbreak;\n\t}\n\n\tif (ret == (const char *)(trace_seq_buffer_ptr(p)))\n\t\ttrace_seq_printf(p, \"0x%lx\", val);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_symbols_seq);\n\n#if BITS_PER_LONG == 32\nconst char *\ntrace_print_flags_seq_u64(struct trace_seq *p, const char *delim,\n\t\t      unsigned long long flags,\n\t\t      const struct trace_print_flags_u64 *flag_array)\n{\n\tunsigned long long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t \n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%llx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_flags_seq_u64);\n\nconst char *\ntrace_print_symbols_seq_u64(struct trace_seq *p, unsigned long long val,\n\t\t\t const struct trace_print_flags_u64 *symbol_array)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\tfor (i = 0;  symbol_array[i].name; i++) {\n\n\t\tif (val != symbol_array[i].mask)\n\t\t\tcontinue;\n\n\t\ttrace_seq_puts(p, symbol_array[i].name);\n\t\tbreak;\n\t}\n\n\tif (ret == (const char *)(trace_seq_buffer_ptr(p)))\n\t\ttrace_seq_printf(p, \"0x%llx\", val);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_symbols_seq_u64);\n#endif\n\nconst char *\ntrace_print_bitmask_seq(struct trace_seq *p, void *bitmask_ptr,\n\t\t\tunsigned int bitmask_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\ttrace_seq_bitmask(p, bitmask_ptr, bitmask_size * 8);\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(trace_print_bitmask_seq);\n\n \nconst char *\ntrace_print_hex_seq(struct trace_seq *p, const unsigned char *buf, int buf_len,\n\t\t    bool concatenate)\n{\n\tint i;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *fmt = concatenate ? \"%*phN\" : \"%*ph\";\n\n\tfor (i = 0; i < buf_len; i += 16) {\n\t\tif (!concatenate && i != 0)\n\t\t\ttrace_seq_putc(p, ' ');\n\t\ttrace_seq_printf(p, fmt, min(buf_len - i, 16), &buf[i]);\n\t}\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_hex_seq);\n\nconst char *\ntrace_print_array_seq(struct trace_seq *p, const void *buf, int count,\n\t\t      size_t el_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *prefix = \"\";\n\tvoid *ptr = (void *)buf;\n\tsize_t buf_len = count * el_size;\n\n\ttrace_seq_putc(p, '{');\n\n\twhile (ptr < buf + buf_len) {\n\t\tswitch (el_size) {\n\t\tcase 1:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u16 *)ptr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u32 *)ptr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttrace_seq_printf(p, \"%s0x%llx\", prefix,\n\t\t\t\t\t *(u64 *)ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_seq_printf(p, \"BAD SIZE:%zu 0x%x\", el_size,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tel_size = 1;\n\t\t}\n\t\tprefix = \",\";\n\t\tptr += el_size;\n\t}\n\n\ttrace_seq_putc(p, '}');\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_array_seq);\n\nconst char *\ntrace_print_hex_dump_seq(struct trace_seq *p, const char *prefix_str,\n\t\t\t int prefix_type, int rowsize, int groupsize,\n\t\t\t const void *buf, size_t len, bool ascii)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\n\ttrace_seq_putc(p, '\\n');\n\ttrace_seq_hex_dump(p, prefix_str, prefix_type,\n\t\t\t   rowsize, groupsize, buf, len, ascii);\n\ttrace_seq_putc(p, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_print_hex_dump_seq);\n\nint trace_raw_output_prep(struct trace_iterator *iter,\n\t\t\t  struct trace_event *trace_event)\n{\n\tstruct trace_event_call *event;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_seq *p = &iter->tmp_seq;\n\tstruct trace_entry *entry;\n\n\tevent = container_of(trace_event, struct trace_event_call, event);\n\tentry = iter->ent;\n\n\tif (entry->type != event->event.type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_init(p);\n\ttrace_seq_printf(s, \"%s: \", trace_event_name(event));\n\n\treturn trace_handle_return(s);\n}\nEXPORT_SYMBOL(trace_raw_output_prep);\n\nvoid trace_event_printf(struct trace_iterator *iter, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\ttrace_check_vprintf(iter, trace_event_format(iter, fmt), ap);\n\tva_end(ap);\n}\nEXPORT_SYMBOL(trace_event_printf);\n\nstatic __printf(3, 0)\nint trace_output_raw(struct trace_iterator *iter, char *name,\n\t\t     char *fmt, va_list ap)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_printf(s, \"%s: \", name);\n\ttrace_seq_vprintf(s, trace_event_format(iter, fmt), ap);\n\n\treturn trace_handle_return(s);\n}\n\nint trace_output_call(struct trace_iterator *iter, char *name, char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = trace_output_raw(iter, name, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(trace_output_call);\n\nstatic inline const char *kretprobed(const char *name, unsigned long addr)\n{\n\tif (is_kretprobe_trampoline(addr))\n\t\treturn \"[unknown/kretprobe'd]\";\n\treturn name;\n}\n\nvoid\ntrace_seq_print_sym(struct trace_seq *s, unsigned long address, bool offset)\n{\n#ifdef CONFIG_KALLSYMS\n\tchar str[KSYM_SYMBOL_LEN];\n\tconst char *name;\n\n\tif (offset)\n\t\tsprint_symbol(str, address);\n\telse\n\t\tkallsyms_lookup(address, NULL, NULL, NULL, str);\n\tname = kretprobed(str, address);\n\n\tif (name && strlen(name)) {\n\t\ttrace_seq_puts(s, name);\n\t\treturn;\n\t}\n#endif\n\ttrace_seq_printf(s, \"0x%08lx\", address);\n}\n\n#ifndef CONFIG_64BIT\n# define IP_FMT \"%08lx\"\n#else\n# define IP_FMT \"%016lx\"\n#endif\n\nstatic int seq_print_user_ip(struct trace_seq *s, struct mm_struct *mm,\n\t\t\t     unsigned long ip, unsigned long sym_flags)\n{\n\tstruct file *file = NULL;\n\tunsigned long vmstart = 0;\n\tint ret = 1;\n\n\tif (s->full)\n\t\treturn 0;\n\n\tif (mm) {\n\t\tconst struct vm_area_struct *vma;\n\n\t\tmmap_read_lock(mm);\n\t\tvma = find_vma(mm, ip);\n\t\tif (vma) {\n\t\t\tfile = vma->vm_file;\n\t\t\tvmstart = vma->vm_start;\n\t\t}\n\t\tif (file) {\n\t\t\tret = trace_seq_path(s, &file->f_path);\n\t\t\tif (ret)\n\t\t\t\ttrace_seq_printf(s, \"[+0x%lx]\",\n\t\t\t\t\t\t ip - vmstart);\n\t\t}\n\t\tmmap_read_unlock(mm);\n\t}\n\tif (ret && ((sym_flags & TRACE_ITER_SYM_ADDR) || !file))\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\treturn !trace_seq_has_overflowed(s);\n}\n\nint\nseq_print_ip_sym(struct trace_seq *s, unsigned long ip, unsigned long sym_flags)\n{\n\tif (!ip) {\n\t\ttrace_seq_putc(s, '0');\n\t\tgoto out;\n\t}\n\n\ttrace_seq_print_sym(s, ip, sym_flags & TRACE_ITER_SYM_OFFSET);\n\n\tif (sym_flags & TRACE_ITER_SYM_ADDR)\n\t\ttrace_seq_printf(s, \" <\" IP_FMT \">\", ip);\n\n out:\n\treturn !trace_seq_has_overflowed(s);\n}\n\n \nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}\n\nstatic int\nlat_print_generic(struct trace_seq *s, struct trace_entry *entry, int cpu)\n{\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%8.8s-%-7d %3d\",\n\t\t\t comm, entry->pid, cpu);\n\n\treturn trace_print_lat_fmt(s, entry);\n}\n\n#undef MARK\n#define MARK(v, s) {.val = v, .sym = s}\n \nstatic const struct trace_mark {\n\tunsigned long long\tval;  \n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'),  \n\tMARK(100000000ULL\t, '@'),  \n\tMARK(10000000ULL\t, '*'),  \n\tMARK(1000000ULL\t\t, '#'),  \n\tMARK(100000ULL\t\t, '!'),  \n\tMARK(10000ULL\t\t, '+'),  \n};\n#undef MARK\n\nchar trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}\n\nstatic int\nlat_print_timestamp(struct trace_iterator *iter, u64 next_ts)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long verbose = tr->trace_flags & TRACE_ITER_VERBOSE;\n\tunsigned long in_ns = iter->iter_flags & TRACE_FILE_TIME_IN_NS;\n\tunsigned long long abs_ts = iter->ts - iter->array_buffer->time_start;\n\tunsigned long long rel_ts = next_ts - iter->ts;\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (in_ns) {\n\t\tabs_ts = ns2usecs(abs_ts);\n\t\trel_ts = ns2usecs(rel_ts);\n\t}\n\n\tif (verbose && in_ns) {\n\t\tunsigned long abs_usec = do_div(abs_ts, USEC_PER_MSEC);\n\t\tunsigned long abs_msec = (unsigned long)abs_ts;\n\t\tunsigned long rel_usec = do_div(rel_ts, USEC_PER_MSEC);\n\t\tunsigned long rel_msec = (unsigned long)rel_ts;\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%08llx] %ld.%03ldms (+%ld.%03ldms): \",\n\t\t\tns2usecs(iter->ts),\n\t\t\tabs_msec, abs_usec,\n\t\t\trel_msec, rel_usec);\n\n\t} else if (verbose && !in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \"[%016llx] %lld (+%lld): \",\n\t\t\titer->ts, abs_ts, rel_ts);\n\n\t} else if (!verbose && in_ns) {\n\t\ttrace_seq_printf(\n\t\t\ts, \" %4lldus%c: \",\n\t\t\tabs_ts,\n\t\t\ttrace_find_mark(rel_ts * NSEC_PER_USEC));\n\n\t} else {  \n\t\ttrace_seq_printf(s, \" %4lld: \", abs_ts);\n\t}\n\n\treturn !trace_seq_has_overflowed(s);\n}\n\nstatic void trace_print_time(struct trace_seq *s, struct trace_iterator *iter,\n\t\t\t     unsigned long long ts)\n{\n\tunsigned long secs, usec_rem;\n\tunsigned long long t;\n\n\tif (iter->iter_flags & TRACE_FILE_TIME_IN_NS) {\n\t\tt = ns2usecs(ts);\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\tsecs = (unsigned long)t;\n\t\ttrace_seq_printf(s, \" %5lu.%06lu\", secs, usec_rem);\n\t} else\n\t\ttrace_seq_printf(s, \" %12llu\", ts);\n}\n\nint trace_print_context(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tchar comm[TASK_COMM_LEN];\n\n\ttrace_find_cmdline(entry->pid, comm);\n\n\ttrace_seq_printf(s, \"%16s-%-7d \", comm, entry->pid);\n\n\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\tunsigned int tgid = trace_find_tgid(entry->pid);\n\n\t\tif (!tgid)\n\t\t\ttrace_seq_printf(s, \"(-------) \");\n\t\telse\n\t\t\ttrace_seq_printf(s, \"(%7d) \", tgid);\n\t}\n\n\ttrace_seq_printf(s, \"[%03d] \", iter->cpu);\n\n\tif (tr->trace_flags & TRACE_ITER_IRQ_INFO)\n\t\ttrace_print_lat_fmt(s, entry);\n\n\ttrace_print_time(s, iter, iter->ts);\n\ttrace_seq_puts(s, \": \");\n\n\treturn !trace_seq_has_overflowed(s);\n}\n\nint trace_print_lat_context(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry, *next_entry;\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long verbose = (tr->trace_flags & TRACE_ITER_VERBOSE);\n\tu64 next_ts;\n\n\tnext_entry = trace_find_next_entry(iter, NULL, &next_ts);\n\tif (!next_entry)\n\t\tnext_ts = iter->ts;\n\n\t \n\tentry = iter->ent;\n\n\tif (verbose) {\n\t\tchar comm[TASK_COMM_LEN];\n\n\t\ttrace_find_cmdline(entry->pid, comm);\n\n\t\ttrace_seq_printf(\n\t\t\ts, \"%16s %7d %3d %d %08x %08lx \",\n\t\t\tcomm, entry->pid, iter->cpu, entry->flags,\n\t\t\tentry->preempt_count & 0xf, iter->idx);\n\t} else {\n\t\tlat_print_generic(s, entry, iter->cpu);\n\t}\n\n\tlat_print_timestamp(iter, next_ts);\n\n\treturn !trace_seq_has_overflowed(s);\n}\n\n \nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}\n\nstatic DEFINE_IDA(trace_event_ida);\n\nstatic void free_trace_event_type(int type)\n{\n\tif (type >= __TRACE_LAST_TYPE)\n\t\tida_free(&trace_event_ida, type);\n}\n\nstatic int alloc_trace_event_type(void)\n{\n\tint next;\n\n\t \n\tnext = ida_alloc_range(&trace_event_ida, __TRACE_LAST_TYPE,\n\t\t\t       TRACE_EVENT_TYPE_MAX, GFP_KERNEL);\n\tif (next < 0)\n\t\treturn 0;\n\treturn next;\n}\n\nvoid trace_event_read_lock(void)\n{\n\tdown_read(&trace_event_sem);\n}\n\nvoid trace_event_read_unlock(void)\n{\n\tup_read(&trace_event_sem);\n}\n\n \nint register_trace_event(struct trace_event *event)\n{\n\tunsigned key;\n\tint ret = 0;\n\n\tdown_write(&trace_event_sem);\n\n\tif (WARN_ON(!event))\n\t\tgoto out;\n\n\tif (WARN_ON(!event->funcs))\n\t\tgoto out;\n\n\tif (!event->type) {\n\t\tevent->type = alloc_trace_event_type();\n\t\tif (!event->type)\n\t\t\tgoto out;\n\t} else if (WARN(event->type > __TRACE_LAST_TYPE,\n\t\t\t\"Need to add type to trace.h\")) {\n\t\tgoto out;\n\t} else {\n\t\t \n\t\tif (ftrace_find_event(event->type))\n\t\t\tgoto out;\n\t}\n\n\tif (event->funcs->trace == NULL)\n\t\tevent->funcs->trace = trace_nop_print;\n\tif (event->funcs->raw == NULL)\n\t\tevent->funcs->raw = trace_nop_print;\n\tif (event->funcs->hex == NULL)\n\t\tevent->funcs->hex = trace_nop_print;\n\tif (event->funcs->binary == NULL)\n\t\tevent->funcs->binary = trace_nop_print;\n\n\tkey = event->type & (EVENT_HASHSIZE - 1);\n\n\thlist_add_head(&event->node, &event_hash[key]);\n\n\tret = event->type;\n out:\n\tup_write(&trace_event_sem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_trace_event);\n\n \nint __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tfree_trace_event_type(event->type);\n\treturn 0;\n}\n\n \nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(unregister_trace_event);\n\n \n\nstatic void print_array(struct trace_iterator *iter, void *pos,\n\t\t\tstruct ftrace_event_field *field)\n{\n\tint offset;\n\tint len;\n\tint i;\n\n\toffset = *(int *)pos & 0xffff;\n\tlen = *(int *)pos >> 16;\n\n\tif (field)\n\t\toffset += field->offset + sizeof(int);\n\n\tif (offset + len > iter->ent_size) {\n\t\ttrace_seq_puts(&iter->seq, \"<OVERFLOW>\");\n\t\treturn;\n\t}\n\n\tpos = (void *)iter->ent + offset;\n\n\tfor (i = 0; i < len; i++, pos++) {\n\t\tif (i)\n\t\t\ttrace_seq_putc(&iter->seq, ',');\n\t\ttrace_seq_printf(&iter->seq, \"%02x\", *(unsigned char *)pos);\n\t}\n}\n\nstatic void print_fields(struct trace_iterator *iter, struct trace_event_call *call,\n\t\t\t struct list_head *head)\n{\n\tstruct ftrace_event_field *field;\n\tint offset;\n\tint len;\n\tint ret;\n\tvoid *pos;\n\n\tlist_for_each_entry_reverse(field, head, link) {\n\t\ttrace_seq_printf(&iter->seq, \" %s=\", field->name);\n\t\tif (field->offset + field->size > iter->ent_size) {\n\t\t\ttrace_seq_puts(&iter->seq, \"<OVERFLOW>\");\n\t\t\tcontinue;\n\t\t}\n\t\tpos = (void *)iter->ent + field->offset;\n\n\t\tswitch (field->filter_type) {\n\t\tcase FILTER_COMM:\n\t\tcase FILTER_STATIC_STRING:\n\t\t\ttrace_seq_printf(&iter->seq, \"%.*s\", field->size, (char *)pos);\n\t\t\tbreak;\n\t\tcase FILTER_RDYN_STRING:\n\t\tcase FILTER_DYN_STRING:\n\t\t\toffset = *(int *)pos & 0xffff;\n\t\t\tlen = *(int *)pos >> 16;\n\n\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\toffset += field->offset + sizeof(int);\n\n\t\t\tif (offset + len > iter->ent_size) {\n\t\t\t\ttrace_seq_puts(&iter->seq, \"<OVERFLOW>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = (void *)iter->ent + offset;\n\t\t\ttrace_seq_printf(&iter->seq, \"%.*s\", len, (char *)pos);\n\t\t\tbreak;\n\t\tcase FILTER_PTR_STRING:\n\t\t\tif (!iter->fmt_size)\n\t\t\t\ttrace_iter_expand_format(iter);\n\t\t\tpos = *(void **)pos;\n\t\t\tret = strncpy_from_kernel_nofault(iter->fmt, pos,\n\t\t\t\t\t\t\t  iter->fmt_size);\n\t\t\tif (ret < 0)\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(0x%px)\", pos);\n\t\t\telse\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(0x%px:%s)\",\n\t\t\t\t\t\t pos, iter->fmt);\n\t\t\tbreak;\n\t\tcase FILTER_TRACE_FN:\n\t\t\tpos = *(void **)pos;\n\t\t\ttrace_seq_printf(&iter->seq, \"%pS\", pos);\n\t\t\tbreak;\n\t\tcase FILTER_CPU:\n\t\tcase FILTER_OTHER:\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\tif (isprint(*(char *)pos)) {\n\t\t\t\t\ttrace_seq_printf(&iter->seq, \"'%c'\",\n\t\t\t\t\t\t *(unsigned char *)pos);\n\t\t\t\t}\n\t\t\t\ttrace_seq_printf(&iter->seq, \"(%d)\",\n\t\t\t\t\t\t *(unsigned char *)pos);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttrace_seq_printf(&iter->seq, \"0x%x (%d)\",\n\t\t\t\t\t\t *(unsigned short *)pos,\n\t\t\t\t\t\t *(unsigned short *)pos);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t \n\t\t\t\tif (strstr(field->type, \"__data_loc\")) {\n\t\t\t\t\tprint_array(iter, pos, NULL);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (strstr(field->type, \"__rel_loc\")) {\n\t\t\t\t\tprint_array(iter, pos, field);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttrace_seq_printf(&iter->seq, \"0x%x (%d)\",\n\t\t\t\t\t\t *(unsigned int *)pos,\n\t\t\t\t\t\t *(unsigned int *)pos);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\ttrace_seq_printf(&iter->seq, \"0x%llx (%lld)\",\n\t\t\t\t\t\t *(unsigned long long *)pos,\n\t\t\t\t\t\t *(unsigned long long *)pos);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttrace_seq_puts(&iter->seq, \"<INVALID-SIZE>\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_seq_puts(&iter->seq, \"<INVALID-TYPE>\");\n\t\t}\n\t}\n\ttrace_seq_putc(&iter->seq, '\\n');\n}\n\nenum print_line_t print_event_fields(struct trace_iterator *iter,\n\t\t\t\t     struct trace_event *event)\n{\n\tstruct trace_event_call *call;\n\tstruct list_head *head;\n\n\t \n\tif (event->type <= __TRACE_LAST_TYPE) {\n\t\tbool found = false;\n\n\t\tdown_read(&trace_event_sem);\n\t\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t\tif (call->event.type == event->type) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (call->event.type > __TRACE_LAST_TYPE)\n\t\t\t\tbreak;\n\t\t}\n\t\tup_read(&trace_event_sem);\n\t\tif (!found) {\n\t\t\ttrace_seq_printf(&iter->seq, \"UNKNOWN TYPE %d\\n\", event->type);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tcall = container_of(event, struct trace_event_call, event);\n\t}\n\thead = trace_get_fields(call);\n\n\ttrace_seq_printf(&iter->seq, \"%s:\", trace_event_name(call));\n\n\tif (head && !list_empty(head))\n\t\tprint_fields(iter, call, head);\n\telse\n\t\ttrace_seq_puts(&iter->seq, \"No fields found\\n\");\n\n out:\n\treturn trace_handle_return(&iter->seq);\n}\n\nenum print_line_t trace_nop_print(struct trace_iterator *iter, int flags,\n\t\t\t\t  struct trace_event *event)\n{\n\ttrace_seq_printf(&iter->seq, \"type: %d\\n\", iter->ent->type);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic void print_fn_trace(struct trace_seq *s, unsigned long ip,\n\t\t\t   unsigned long parent_ip, int flags)\n{\n\tseq_print_ip_sym(s, ip, flags);\n\n\tif ((flags & TRACE_ITER_PRINT_PARENT) && parent_ip) {\n\t\ttrace_seq_puts(s, \" <-\");\n\t\tseq_print_ip_sym(s, parent_ip, flags);\n\t}\n}\n\n \nstatic enum print_line_t trace_fn_trace(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tprint_fn_trace(s, field->ip, field->parent_ip, flags);\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t trace_fn_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"%lx %lx\\n\",\n\t\t\t field->ip,\n\t\t\t field->parent_ip);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic enum print_line_t trace_fn_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_HEX_FIELD(s, field->ip);\n\tSEQ_PUT_HEX_FIELD(s, field->parent_ip);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t trace_fn_bin(struct trace_iterator *iter, int flags,\n\t\t\t\t      struct trace_event *event)\n{\n\tstruct ftrace_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_FIELD(s, field->ip);\n\tSEQ_PUT_FIELD(s, field->parent_ip);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_fn_funcs = {\n\t.trace\t\t= trace_fn_trace,\n\t.raw\t\t= trace_fn_raw,\n\t.hex\t\t= trace_fn_hex,\n\t.binary\t\t= trace_fn_bin,\n};\n\nstatic struct trace_event trace_fn_event = {\n\t.type\t\t= TRACE_FN,\n\t.funcs\t\t= &trace_fn_funcs,\n};\n\n \nstatic enum print_line_t trace_ctxwake_print(struct trace_iterator *iter,\n\t\t\t\t\t     char *delim)\n{\n\tstruct ctx_switch_entry *field;\n\tchar comm[TASK_COMM_LEN];\n\tint S, T;\n\n\n\ttrace_assign_type(field, iter->ent);\n\n\tT = task_index_to_char(field->next_state);\n\tS = task_index_to_char(field->prev_state);\n\ttrace_find_cmdline(field->next_pid, comm);\n\ttrace_seq_printf(&iter->seq,\n\t\t\t \" %7d:%3d:%c %s [%03d] %7d:%3d:%c %s\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S, delim,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T, comm);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic enum print_line_t trace_ctx_print(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\treturn trace_ctxwake_print(iter, \"==>\");\n}\n\nstatic enum print_line_t trace_wake_print(struct trace_iterator *iter,\n\t\t\t\t\t  int flags, struct trace_event *event)\n{\n\treturn trace_ctxwake_print(iter, \"  +\");\n}\n\nstatic int trace_ctxwake_raw(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\ttrace_seq_printf(&iter->seq, \"%d %d %c %d %d %d %c\\n\",\n\t\t\t field->prev_pid,\n\t\t\t field->prev_prio,\n\t\t\t S,\n\t\t\t field->next_cpu,\n\t\t\t field->next_pid,\n\t\t\t field->next_prio,\n\t\t\t T);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic enum print_line_t trace_ctx_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t       struct trace_event *event)\n{\n\treturn trace_ctxwake_raw(iter, 0);\n}\n\nstatic enum print_line_t trace_wake_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\treturn trace_ctxwake_raw(iter, '+');\n}\n\n\nstatic int trace_ctxwake_hex(struct trace_iterator *iter, char S)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint T;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tif (!S)\n\t\tS = task_index_to_char(field->prev_state);\n\tT = task_index_to_char(field->next_state);\n\n\tSEQ_PUT_HEX_FIELD(s, field->prev_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->prev_prio);\n\tSEQ_PUT_HEX_FIELD(s, S);\n\tSEQ_PUT_HEX_FIELD(s, field->next_cpu);\n\tSEQ_PUT_HEX_FIELD(s, field->next_pid);\n\tSEQ_PUT_HEX_FIELD(s, field->next_prio);\n\tSEQ_PUT_HEX_FIELD(s, T);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t trace_ctx_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t       struct trace_event *event)\n{\n\treturn trace_ctxwake_hex(iter, 0);\n}\n\nstatic enum print_line_t trace_wake_hex(struct trace_iterator *iter, int flags,\n\t\t\t\t\tstruct trace_event *event)\n{\n\treturn trace_ctxwake_hex(iter, '+');\n}\n\nstatic enum print_line_t trace_ctxwake_bin(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct ctx_switch_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tSEQ_PUT_FIELD(s, field->prev_pid);\n\tSEQ_PUT_FIELD(s, field->prev_prio);\n\tSEQ_PUT_FIELD(s, field->prev_state);\n\tSEQ_PUT_FIELD(s, field->next_cpu);\n\tSEQ_PUT_FIELD(s, field->next_pid);\n\tSEQ_PUT_FIELD(s, field->next_prio);\n\tSEQ_PUT_FIELD(s, field->next_state);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_ctx_funcs = {\n\t.trace\t\t= trace_ctx_print,\n\t.raw\t\t= trace_ctx_raw,\n\t.hex\t\t= trace_ctx_hex,\n\t.binary\t\t= trace_ctxwake_bin,\n};\n\nstatic struct trace_event trace_ctx_event = {\n\t.type\t\t= TRACE_CTX,\n\t.funcs\t\t= &trace_ctx_funcs,\n};\n\nstatic struct trace_event_functions trace_wake_funcs = {\n\t.trace\t\t= trace_wake_print,\n\t.raw\t\t= trace_wake_raw,\n\t.hex\t\t= trace_wake_hex,\n\t.binary\t\t= trace_ctxwake_bin,\n};\n\nstatic struct trace_event trace_wake_event = {\n\t.type\t\t= TRACE_WAKE,\n\t.funcs\t\t= &trace_wake_funcs,\n};\n\n \n\nstatic enum print_line_t trace_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct stack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long *p;\n\tunsigned long *end;\n\n\ttrace_assign_type(field, iter->ent);\n\tend = (unsigned long *)((long)iter->ent + iter->ent_size);\n\n\ttrace_seq_puts(s, \"<stack trace>\\n\");\n\n\tfor (p = field->caller; p && p < end && *p != ULONG_MAX; p++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" => \");\n\t\tseq_print_ip_sym(s, *p, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_stack_funcs = {\n\t.trace\t\t= trace_stack_print,\n};\n\nstatic struct trace_event trace_stack_event = {\n\t.type\t\t= TRACE_STACK,\n\t.funcs\t\t= &trace_stack_funcs,\n};\n\n \nstatic enum print_line_t trace_user_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t\tint flags, struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct userstack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct mm_struct *mm = NULL;\n\tunsigned int i;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_puts(s, \"<user stack trace>\\n\");\n\n\tif (tr->trace_flags & TRACE_ITER_SYM_USEROBJ) {\n\t\tstruct task_struct *task;\n\t\t \n\t\trcu_read_lock();\n\t\ttask = find_task_by_vpid(field->tgid);\n\t\tif (task)\n\t\t\tmm = get_task_mm(task);\n\t\trcu_read_unlock();\n\t}\n\n\tfor (i = 0; i < FTRACE_STACK_ENTRIES; i++) {\n\t\tunsigned long ip = field->caller[i];\n\n\t\tif (!ip || trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" => \");\n\t\tseq_print_user_ip(s, mm, ip, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\tif (mm)\n\t\tmmput(mm);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_user_stack_funcs = {\n\t.trace\t\t= trace_user_stack_print,\n};\n\nstatic struct trace_event trace_user_stack_event = {\n\t.type\t\t= TRACE_USER_STACK,\n\t.funcs\t\t= &trace_user_stack_funcs,\n};\n\n \nstatic enum print_line_t\ntrace_hwlat_print(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct hwlat_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_printf(s, \"#%-5u inner/outer(us): %4llu/%-5llu ts:%lld.%09ld count:%d\",\n\t\t\t field->seqnum,\n\t\t\t field->duration,\n\t\t\t field->outer_duration,\n\t\t\t (long long)field->timestamp.tv_sec,\n\t\t\t field->timestamp.tv_nsec, field->count);\n\n\tif (field->nmi_count) {\n\t\t \n\t\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK))\n\t\t\ttrace_seq_printf(s, \" nmi-total:%llu\",\n\t\t\t\t\t field->nmi_total_ts);\n\t\ttrace_seq_printf(s, \" nmi-count:%u\",\n\t\t\t\t field->nmi_count);\n\t}\n\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t\ntrace_hwlat_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct hwlat_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%llu %lld %lld %09ld %u\\n\",\n\t\t\t field->duration,\n\t\t\t field->outer_duration,\n\t\t\t (long long)field->timestamp.tv_sec,\n\t\t\t field->timestamp.tv_nsec,\n\t\t\t field->seqnum);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_hwlat_funcs = {\n\t.trace\t\t= trace_hwlat_print,\n\t.raw\t\t= trace_hwlat_raw,\n};\n\nstatic struct trace_event trace_hwlat_event = {\n\t.type\t\t= TRACE_HWLAT,\n\t.funcs\t\t= &trace_hwlat_funcs,\n};\n\n \nstatic enum print_line_t\ntrace_osnoise_print(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct osnoise_entry *field;\n\tu64 ratio, ratio_dec;\n\tu64 net_runtime;\n\n\ttrace_assign_type(field, entry);\n\n\t \n\tnet_runtime = field->runtime - field->noise;\n\tratio = net_runtime * 10000000;\n\tdo_div(ratio, field->runtime);\n\tratio_dec = do_div(ratio, 100000);\n\n\ttrace_seq_printf(s, \"%llu %10llu %3llu.%05llu %7llu\",\n\t\t\t field->runtime,\n\t\t\t field->noise,\n\t\t\t ratio, ratio_dec,\n\t\t\t field->max_sample);\n\n\ttrace_seq_printf(s, \" %6u\", field->hw_count);\n\ttrace_seq_printf(s, \" %6u\", field->nmi_count);\n\ttrace_seq_printf(s, \" %6u\", field->irq_count);\n\ttrace_seq_printf(s, \" %6u\", field->softirq_count);\n\ttrace_seq_printf(s, \" %6u\", field->thread_count);\n\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t\ntrace_osnoise_raw(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct osnoise_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%lld %llu %llu %u %u %u %u %u\\n\",\n\t\t\t field->runtime,\n\t\t\t field->noise,\n\t\t\t field->max_sample,\n\t\t\t field->hw_count,\n\t\t\t field->nmi_count,\n\t\t\t field->irq_count,\n\t\t\t field->softirq_count,\n\t\t\t field->thread_count);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_osnoise_funcs = {\n\t.trace\t\t= trace_osnoise_print,\n\t.raw\t\t= trace_osnoise_raw,\n};\n\nstatic struct trace_event trace_osnoise_event = {\n\t.type\t\t= TRACE_OSNOISE,\n\t.funcs\t\t= &trace_osnoise_funcs,\n};\n\n \n\nstatic char *timerlat_lat_context[] = {\"irq\", \"thread\", \"user-ret\"};\nstatic enum print_line_t\ntrace_timerlat_print(struct trace_iterator *iter, int flags,\n\t\t     struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct timerlat_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_printf(s, \"#%-5u context %6s timer_latency %9llu ns\\n\",\n\t\t\t field->seqnum,\n\t\t\t timerlat_lat_context[field->context],\n\t\t\t field->timer_latency);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t\ntrace_timerlat_raw(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct timerlat_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%u %d %llu\\n\",\n\t\t\t field->seqnum,\n\t\t\t field->context,\n\t\t\t field->timer_latency);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_timerlat_funcs = {\n\t.trace\t\t= trace_timerlat_print,\n\t.raw\t\t= trace_timerlat_raw,\n};\n\nstatic struct trace_event trace_timerlat_event = {\n\t.type\t\t= TRACE_TIMERLAT,\n\t.funcs\t\t= &trace_timerlat_funcs,\n};\n\n \nstatic enum print_line_t\ntrace_bputs_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \": \");\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\n\nstatic enum print_line_t\ntrace_bputs_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct bputs_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \": %lx : \", field->ip);\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_bputs_funcs = {\n\t.trace\t\t= trace_bputs_print,\n\t.raw\t\t= trace_bputs_raw,\n};\n\nstatic struct trace_event trace_bputs_event = {\n\t.type\t\t= TRACE_BPUTS,\n\t.funcs\t\t= &trace_bputs_funcs,\n};\n\n \nstatic enum print_line_t\ntrace_bprint_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \": \");\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\n\nstatic enum print_line_t\ntrace_bprint_raw(struct trace_iterator *iter, int flags,\n\t\t struct trace_event *event)\n{\n\tstruct bprint_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \": %lx : \", field->ip);\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_bprint_funcs = {\n\t.trace\t\t= trace_bprint_print,\n\t.raw\t\t= trace_bprint_raw,\n};\n\nstatic struct trace_event trace_bprint_event = {\n\t.type\t\t= TRACE_BPRINT,\n\t.funcs\t\t= &trace_bprint_funcs,\n};\n\n \nstatic enum print_line_t trace_print_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct print_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\tint max = iter->ent_size - offsetof(struct print_entry, buf);\n\n\ttrace_assign_type(field, iter->ent);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_printf(s, \": %.*s\", max, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t trace_print_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct print_entry *field;\n\tint max = iter->ent_size - offsetof(struct print_entry, buf);\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"# %lx %.*s\", field->ip, max, field->buf);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic struct trace_event_functions trace_print_funcs = {\n\t.trace\t\t= trace_print_print,\n\t.raw\t\t= trace_print_raw,\n};\n\nstatic struct trace_event trace_print_event = {\n\t.type\t \t= TRACE_PRINT,\n\t.funcs\t\t= &trace_print_funcs,\n};\n\nstatic enum print_line_t trace_raw_data(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct raw_data_entry *field;\n\tint i;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"# %x buf:\", field->id);\n\n\tfor (i = 0; i < iter->ent_size - offsetof(struct raw_data_entry, buf); i++)\n\t\ttrace_seq_printf(&iter->seq, \" %02x\",\n\t\t\t\t (unsigned char)field->buf[i]);\n\n\ttrace_seq_putc(&iter->seq, '\\n');\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic struct trace_event_functions trace_raw_data_funcs = {\n\t.trace\t\t= trace_raw_data,\n\t.raw\t\t= trace_raw_data,\n};\n\nstatic struct trace_event trace_raw_data_event = {\n\t.type\t \t= TRACE_RAW_DATA,\n\t.funcs\t\t= &trace_raw_data_funcs,\n};\n\nstatic enum print_line_t\ntrace_func_repeats_raw(struct trace_iterator *iter, int flags,\n\t\t\t struct trace_event *event)\n{\n\tstruct func_repeats_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"%lu %lu %u %llu\\n\",\n\t\t\t field->ip,\n\t\t\t field->parent_ip,\n\t\t\t field->count,\n\t\t\t FUNC_REPEATS_GET_DELTA_TS(field));\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t\ntrace_func_repeats_print(struct trace_iterator *iter, int flags,\n\t\t\t struct trace_event *event)\n{\n\tstruct func_repeats_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tprint_fn_trace(s, field->ip, field->parent_ip, flags);\n\ttrace_seq_printf(s, \" (repeats: %u, last_ts:\", field->count);\n\ttrace_print_time(s, iter,\n\t\t\t iter->ts - FUNC_REPEATS_GET_DELTA_TS(field));\n\ttrace_seq_puts(s, \")\\n\");\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_func_repeats_funcs = {\n\t.trace\t\t= trace_func_repeats_print,\n\t.raw\t\t= trace_func_repeats_raw,\n};\n\nstatic struct trace_event trace_func_repeats_event = {\n\t.type\t \t= TRACE_FUNC_REPEATS,\n\t.funcs\t\t= &trace_func_repeats_funcs,\n};\n\nstatic struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\t&trace_hwlat_event,\n\t&trace_osnoise_event,\n\t&trace_timerlat_event,\n\t&trace_raw_data_event,\n\t&trace_func_repeats_event,\n\tNULL\n};\n\n__init int init_events(void)\n{\n\tstruct trace_event *event;\n\tint i, ret;\n\n\tfor (i = 0; events[i]; i++) {\n\t\tevent = events[i];\n\t\tret = register_trace_event(event);\n\t\tWARN_ONCE(!ret, \"event %d failed to register\", event->type);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}