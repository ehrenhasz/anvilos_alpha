{
  "module_name": "trace_dynevent.c",
  "hash_id": "111dd0495a752e13a208acc0ff85c74f777b532d27599e90c5fe267d2d5b8618",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_dynevent.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/mutex.h>\n#include <linux/tracefs.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\t \n#include \"trace_dynevent.h\"\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nbool trace_event_dyn_try_get_ref(struct trace_event_call *dyn_call)\n{\n\tstruct trace_event_call *call;\n\tbool ret = false;\n\n\tif (WARN_ON_ONCE(!(dyn_call->flags & TRACE_EVENT_FL_DYNAMIC)))\n\t\treturn false;\n\n\tdown_read(&trace_event_sem);\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tif (call == dyn_call) {\n\t\t\tatomic_inc(&dyn_call->refcnt);\n\t\t\tret = true;\n\t\t}\n\t}\n\tup_read(&trace_event_sem);\n\treturn ret;\n}\n\nvoid trace_event_dyn_put_ref(struct trace_event_call *call)\n{\n\tif (WARN_ON_ONCE(!(call->flags & TRACE_EVENT_FL_DYNAMIC)))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(atomic_read(&call->refcnt) <= 0)) {\n\t\tatomic_set(&call->refcnt, 0);\n\t\treturn;\n\t}\n\n\tatomic_dec(&call->refcnt);\n}\n\nbool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}\n\nint dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}\n\nint dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (!system && event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_reset_all_online_cpus();\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}\n\nstatic int create_dyn_event(const char *raw_command)\n{\n\tstruct dyn_event_operations *ops;\n\tint ret = -ENODEV;\n\n\tif (raw_command[0] == '-' || raw_command[0] == '!')\n\t\treturn dyn_event_release(raw_command, NULL);\n\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_for_each_entry(ops, &dyn_event_ops_list, list) {\n\t\tret = ops->create(raw_command);\n\t\tif (!ret || ret != -ECANCELED)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&dyn_event_ops_mutex);\n\tif (ret == -ECANCELED)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\n \nLIST_HEAD(dyn_event_list);\n\nvoid *dyn_event_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&event_mutex);\n\treturn seq_list_start(&dyn_event_list, *pos);\n}\n\nvoid *dyn_event_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &dyn_event_list, pos);\n}\n\nvoid dyn_event_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&event_mutex);\n}\n\nstatic int dyn_event_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (ev && ev->ops)\n\t\treturn ev->ops->show(m, ev);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations dyn_event_seq_op = {\n\t.start\t= dyn_event_seq_start,\n\t.next\t= dyn_event_seq_next,\n\t.stop\t= dyn_event_seq_stop,\n\t.show\t= dyn_event_seq_show\n};\n\n \nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\ttracing_reset_all_online_cpus();\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\n\nstatic int dyn_event_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &dyn_event_seq_op);\n}\n\nstatic ssize_t dyn_event_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_dyn_event);\n}\n\nstatic const struct file_operations dynamic_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = dyn_event_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= dyn_event_write,\n};\n\n \nstatic __init int init_dynamic_event(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"dynamic_events\", TRACE_MODE_WRITE, NULL,\n\t\t\t  NULL, &dynamic_events_ops);\n\n\treturn 0;\n}\nfs_initcall(init_dynamic_event);\n\n \nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}\n\n \nint dynevent_arg_pair_add(struct dynevent_cmd *cmd,\n\t\t\t  struct dynevent_arg_pair *arg_pair,\n\t\t\t  dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg_pair);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c%s%c\", arg_pair->lhs,\n\t\t\t     arg_pair->operator, arg_pair->rhs,\n\t\t\t     arg_pair->separator);\n\tif (ret) {\n\t\tpr_err(\"field string is too long: %s%c%s%c\\n\", arg_pair->lhs,\n\t\t       arg_pair->operator, arg_pair->rhs,\n\t\t       arg_pair->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}\n\n \nint dynevent_str_add(struct dynevent_cmd *cmd, const char *str)\n{\n\tint ret = 0;\n\n\tret = seq_buf_puts(&cmd->seq, str);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s\\n\", str);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}\n\n \nvoid dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}\n\n \nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}\n\n \nvoid dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,\n\t\t\t    char operator, char separator)\n{\n\tmemset(arg_pair, '\\0', sizeof(*arg_pair));\n\n\tif (!operator)\n\t\toperator = ' ';\n\targ_pair->operator = operator;\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ_pair->separator = separator;\n}\n\n \nint dynevent_create(struct dynevent_cmd *cmd)\n{\n\treturn cmd->run_command(cmd);\n}\nEXPORT_SYMBOL_GPL(dynevent_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}