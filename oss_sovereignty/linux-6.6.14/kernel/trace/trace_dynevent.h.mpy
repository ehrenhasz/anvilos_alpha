{
  "module_name": "trace_dynevent.h",
  "hash_id": "410eb6c79f35acdd7ea513fccb479a51e03731442fd02bdcf9161ac0bf99c677",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_dynevent.h",
  "human_readable_source": " \n \n\n#ifndef _TRACE_DYNEVENT_H\n#define _TRACE_DYNEVENT_H\n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n\n#include \"trace.h\"\n\nstruct dyn_event;\n\n \nstruct dyn_event_operations {\n\tstruct list_head\tlist;\n\tint (*create)(const char *raw_command);\n\tint (*show)(struct seq_file *m, struct dyn_event *ev);\n\tbool (*is_busy)(struct dyn_event *ev);\n\tint (*free)(struct dyn_event *ev);\n\tbool (*match)(const char *system, const char *event,\n\t\t      int argc, const char **argv, struct dyn_event *ev);\n};\n\n \nint dyn_event_register(struct dyn_event_operations *ops);\n\n \nstruct dyn_event {\n\tstruct list_head\t\tlist;\n\tstruct dyn_event_operations\t*ops;\n};\n\nextern struct list_head dyn_event_list;\n\nstatic inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}\n\nstatic inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}\n\nvoid *dyn_event_seq_start(struct seq_file *m, loff_t *pos);\nvoid *dyn_event_seq_next(struct seq_file *m, void *v, loff_t *pos);\nvoid dyn_event_seq_stop(struct seq_file *m, void *v);\nint dyn_events_release_all(struct dyn_event_operations *type);\nint dyn_event_release(const char *raw_command, struct dyn_event_operations *type);\n\n \n#define for_each_dyn_event(pos)\t\\\n\tlist_for_each_entry(pos, &dyn_event_list, list)\n\n \n#define for_each_dyn_event_safe(pos, n)\t\\\n\tlist_for_each_entry_safe(pos, n, &dyn_event_list, list)\n\nextern void dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t\t      enum dynevent_type type,\n\t\t\t      dynevent_create_fn_t run_command);\n\ntypedef int (*dynevent_check_arg_fn_t)(void *data);\n\nstruct dynevent_arg {\n\tconst char\t\t*str;\n\tchar\t\t\tseparator;  \n};\n\nextern void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t\t      char separator);\nextern int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t\t    struct dynevent_arg *arg,\n\t\t\t    dynevent_check_arg_fn_t check_arg);\n\nstruct dynevent_arg_pair {\n\tconst char\t\t*lhs;\n\tconst char\t\t*rhs;\n\tchar\t\t\toperator;  \n\tchar\t\t\tseparator;  \n};\n\nextern void dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,\n\t\t\t\t   char operator, char separator);\n\nextern int dynevent_arg_pair_add(struct dynevent_cmd *cmd,\n\t\t\t\t struct dynevent_arg_pair *arg_pair,\n\t\t\t\t dynevent_check_arg_fn_t check_arg);\nextern int dynevent_str_add(struct dynevent_cmd *cmd, const char *str);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}