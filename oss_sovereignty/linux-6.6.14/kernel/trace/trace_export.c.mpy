{
  "module_name": "trace_export.c",
  "hash_id": "bcfd27fc3694acec7a041f522f3e01d84024d6221fb1569719bb13630f06af76",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_export.c",
  "human_readable_source": "\n \n#include <linux/stringify.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include \"trace_output.h\"\n\n \nstatic int ftrace_event_register(struct trace_event_call *call,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\treturn 0;\n}\n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM\tftrace\n\n \n#undef FTRACE_ENTRY_REG\n#define FTRACE_ENTRY_REG(name, struct_name, id, tstruct, print, regfn) \\\n\tFTRACE_ENTRY(name, struct_name, id, PARAMS(tstruct), PARAMS(print))\n\n \n#undef __field_struct\n#define __field_struct(type, item)\n\n#undef __field\n#define __field(type, item)\t\t\t\ttype item;\n\n#undef __field_fn\n#define __field_fn(type, item)\t\t\t\ttype item;\n\n#undef __field_desc\n#define __field_desc(type, container, item)\t\ttype item;\n\n#undef __field_packed\n#define __field_packed(type, container, item)\t\ttype item;\n\n#undef __array\n#define __array(type, item, size)\t\t\ttype item[size];\n\n#undef __stack_array\n#define __stack_array(type, item, size, field)\t\t__array(type, item, size)\n\n#undef __array_desc\n#define __array_desc(type, container, item, size)\ttype item[size];\n\n#undef __dynamic_array\n#define __dynamic_array(type, item)\t\t\ttype item[];\n\n#undef F_STRUCT\n#define F_STRUCT(args...)\t\t\t\targs\n\n#undef F_printk\n#define F_printk(fmt, args...) fmt, args\n\n#undef FTRACE_ENTRY\n#define FTRACE_ENTRY(name, struct_name, id, tstruct, print)\t\t\\\nstruct ____ftrace_##name {\t\t\t\t\t\t\\\n\ttstruct\t\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic void __always_unused ____ftrace_check_##name(void)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ____ftrace_##name *__entry = NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\\\n\tprintk(print);\t\t\t\t\t\t\t\\\n}\n\n#undef FTRACE_ENTRY_DUP\n#define FTRACE_ENTRY_DUP(name, struct_name, id, tstruct, print)\t\t\\\n\tFTRACE_ENTRY(name, struct_name, id, PARAMS(tstruct), PARAMS(print))\n\n#include \"trace_entries.h\"\n\n#undef __field_ext\n#define __field_ext(_type, _item, _filter_type) {\t\t\t\\\n\t.type = #_type, .name = #_item,\t\t\t\t\t\\\n\t.size = sizeof(_type), .align = __alignof__(_type),\t\t\\\n\tis_signed_type(_type), .filter_type = _filter_type },\n\n\n#undef __field_ext_packed\n#define __field_ext_packed(_type, _item, _filter_type) {\t\\\n\t.type = #_type, .name = #_item,\t\t\t\t\\\n\t.size = sizeof(_type), .align = 1,\t\t\t\\\n\tis_signed_type(_type), .filter_type = _filter_type },\n\n#undef __field\n#define __field(_type, _item) __field_ext(_type, _item, FILTER_OTHER)\n\n#undef __field_fn\n#define __field_fn(_type, _item) __field_ext(_type, _item, FILTER_TRACE_FN)\n\n#undef __field_desc\n#define __field_desc(_type, _container, _item) __field_ext(_type, _item, FILTER_OTHER)\n\n#undef __field_packed\n#define __field_packed(_type, _container, _item) __field_ext_packed(_type, _item, FILTER_OTHER)\n\n#undef __array\n#define __array(_type, _item, _len) {\t\t\t\t\t\\\n\t.type = #_type\"[\"__stringify(_len)\"]\", .name = #_item,\t\t\\\n\t.size = sizeof(_type[_len]), .align = __alignof__(_type),\t\\\n\tis_signed_type(_type), .filter_type = FILTER_OTHER,\t\t\t\\\n\t.len = _len },\n\n#undef __stack_array\n#define __stack_array(_type, _item, _len, _field) __array(_type, _item, _len)\n\n#undef __array_desc\n#define __array_desc(_type, _container, _item, _len) __array(_type, _item, _len)\n\n#undef __dynamic_array\n#define __dynamic_array(_type, _item) {\t\t\t\t\t\\\n\t.type = #_type \"[]\", .name = #_item,\t\t\t\t\\\n\t.size = 0, .align = __alignof__(_type),\t\t\t\t\\\n\tis_signed_type(_type), .filter_type = FILTER_OTHER },\n\n#undef FTRACE_ENTRY\n#define FTRACE_ENTRY(name, struct_name, id, tstruct, print)\t\t\\\nstatic struct trace_event_fields ftrace_event_fields_##name[] = {\t\\\n\ttstruct\t\t\t\t\t\t\t\t\\\n\t{} };\n\n#include \"trace_entries.h\"\n\n#undef __entry\n#define __entry REC\n\n#undef __field\n#define __field(type, item)\n\n#undef __field_fn\n#define __field_fn(type, item)\n\n#undef __field_desc\n#define __field_desc(type, container, item)\n\n#undef __field_packed\n#define __field_packed(type, container, item)\n\n#undef __array\n#define __array(type, item, len)\n\n#undef __stack_array\n#define __stack_array(type, item, len, field)\n\n#undef __array_desc\n#define __array_desc(type, container, item, len)\n\n#undef __dynamic_array\n#define __dynamic_array(type, item)\n\n#undef F_printk\n#define F_printk(fmt, args...) __stringify(fmt) \", \"  __stringify(args)\n\n#undef FTRACE_ENTRY_REG\n#define FTRACE_ENTRY_REG(call, struct_name, etype, tstruct, print, regfn) \\\nstatic struct trace_event_class __refdata event_class_ftrace_##call = {\t\\\n\t.system\t\t\t= __stringify(TRACE_SYSTEM),\t\t\\\n\t.fields_array\t\t= ftrace_event_fields_##call,\t\t\\\n\t.fields\t\t\t= LIST_HEAD_INIT(event_class_ftrace_##call.fields),\\\n\t.reg\t\t\t= regfn,\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstruct trace_event_call __used event_##call = {\t\t\t\t\\\n\t.class\t\t\t= &event_class_ftrace_##call,\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name\t\t\t= #call,\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.event.type\t\t= etype,\t\t\t\t\\\n\t.print_fmt\t\t= print,\t\t\t\t\\\n\t.flags\t\t\t= TRACE_EVENT_FL_IGNORE_ENABLE,\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic struct trace_event_call __used\t\t\t\t\t\t\\\n__section(\"_ftrace_events\") *__event_##call = &event_##call;\n\n#undef FTRACE_ENTRY\n#define FTRACE_ENTRY(call, struct_name, etype, tstruct, print)\t\t\\\n\tFTRACE_ENTRY_REG(call, struct_name, etype,\t\t\t\\\n\t\t\t PARAMS(tstruct), PARAMS(print), NULL)\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}\n\n#include \"trace_entries.h\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}