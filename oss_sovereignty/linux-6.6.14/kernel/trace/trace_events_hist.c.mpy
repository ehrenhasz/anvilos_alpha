{
  "module_name": "trace_events_hist.c",
  "hash_id": "55ca8d60f1b5635f5bde0b9d51659e8f3e03045cc7035c4296030dd2c1f9b5a9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_events_hist.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/stacktrace.h>\n#include <linux/rculist.h>\n#include <linux/tracefs.h>\n\n \n#include <linux/trace_events.h>\n#include <trace/events/mmflags.h>\n\n#include \"tracing_map.h\"\n#include \"trace_synth.h\"\n\n#define ERRORS\t\t\t\t\t\t\t\t\\\n\tC(NONE,\t\t\t\"No error\"),\t\t\t\t\\\n\tC(DUPLICATE_VAR,\t\"Variable already defined\"),\t\t\\\n\tC(VAR_NOT_UNIQUE,\t\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable\"), \\\n\tC(TOO_MANY_VARS,\t\"Too many variables defined\"),\t\t\\\n\tC(MALFORMED_ASSIGNMENT,\t\"Malformed assignment\"),\t\t\\\n\tC(NAMED_MISMATCH,\t\"Named hist trigger doesn't match existing named trigger (includes variables)\"), \\\n\tC(TRIGGER_EEXIST,\t\"Hist trigger already exists\"),\t\t\\\n\tC(TRIGGER_ENOENT_CLEAR,\t\"Can't clear or continue a nonexistent hist trigger\"), \\\n\tC(SET_CLOCK_FAIL,\t\"Couldn't set trace_clock\"),\t\t\\\n\tC(BAD_FIELD_MODIFIER,\t\"Invalid field modifier\"),\t\t\\\n\tC(TOO_MANY_SUBEXPR,\t\"Too many subexpressions (3 max)\"),\t\\\n\tC(TIMESTAMP_MISMATCH,\t\"Timestamp units in expression don't match\"), \\\n\tC(TOO_MANY_FIELD_VARS,\t\"Too many field variables defined\"),\t\\\n\tC(EVENT_FILE_NOT_FOUND,\t\"Event file not found\"),\t\t\\\n\tC(HIST_NOT_FOUND,\t\"Matching event histogram not found\"),\t\\\n\tC(HIST_CREATE_FAIL,\t\"Couldn't create histogram for field\"),\t\\\n\tC(SYNTH_VAR_NOT_FOUND,\t\"Couldn't find synthetic variable\"),\t\\\n\tC(SYNTH_EVENT_NOT_FOUND,\"Couldn't find synthetic event\"),\t\\\n\tC(SYNTH_TYPE_MISMATCH,\t\"Param type doesn't match synthetic event field type\"), \\\n\tC(SYNTH_COUNT_MISMATCH,\t\"Param count doesn't match synthetic event field count\"), \\\n\tC(FIELD_VAR_PARSE_FAIL,\t\"Couldn't parse field variable\"),\t\\\n\tC(VAR_CREATE_FIND_FAIL,\t\"Couldn't create or find variable\"),\t\\\n\tC(ONX_NOT_VAR,\t\t\"For onmax(x) or onchange(x), x must be a variable\"), \\\n\tC(ONX_VAR_NOT_FOUND,\t\"Couldn't find onmax or onchange variable\"), \\\n\tC(ONX_VAR_CREATE_FAIL,\t\"Couldn't create onmax or onchange variable\"), \\\n\tC(FIELD_VAR_CREATE_FAIL,\"Couldn't create field variable\"),\t\\\n\tC(TOO_MANY_PARAMS,\t\"Too many action params\"),\t\t\\\n\tC(PARAM_NOT_FOUND,\t\"Couldn't find param\"),\t\t\t\\\n\tC(INVALID_PARAM,\t\"Invalid action param\"),\t\t\\\n\tC(ACTION_NOT_FOUND,\t\"No action found\"),\t\t\t\\\n\tC(NO_SAVE_PARAMS,\t\"No params found for save()\"),\t\t\\\n\tC(TOO_MANY_SAVE_ACTIONS,\"Can't have more than one save() action per hist\"), \\\n\tC(ACTION_MISMATCH,\t\"Handler doesn't support action\"),\t\\\n\tC(NO_CLOSING_PAREN,\t\"No closing paren found\"),\t\t\\\n\tC(SUBSYS_NOT_FOUND,\t\"Missing subsystem\"),\t\t\t\\\n\tC(INVALID_SUBSYS_EVENT,\t\"Invalid subsystem or event name\"),\t\\\n\tC(INVALID_REF_KEY,\t\"Using variable references in keys not supported\"), \\\n\tC(VAR_NOT_FOUND,\t\"Couldn't find variable\"),\t\t\\\n\tC(FIELD_NOT_FOUND,\t\"Couldn't find field\"),\t\t\t\\\n\tC(EMPTY_ASSIGNMENT,\t\"Empty assignment\"),\t\t\t\\\n\tC(INVALID_SORT_MODIFIER,\"Invalid sort modifier\"),\t\t\\\n\tC(EMPTY_SORT_FIELD,\t\"Empty sort field\"),\t\t\t\\\n\tC(TOO_MANY_SORT_FIELDS,\t\"Too many sort fields (Max = 2)\"),\t\\\n\tC(INVALID_SORT_FIELD,\t\"Sort field must be a key or a val\"),\t\\\n\tC(INVALID_STR_OPERAND,\t\"String type can not be an operand in expression\"), \\\n\tC(EXPECT_NUMBER,\t\"Expecting numeric literal\"),\t\t\\\n\tC(UNARY_MINUS_SUBEXPR,\t\"Unary minus not supported in sub-expressions\"), \\\n\tC(DIVISION_BY_ZERO,\t\"Division by zero\"),\t\t\t\\\n\tC(NEED_NOHC_VAL,\t\"Non-hitcount value is required for 'nohitcount'\"),\n\n#undef C\n#define C(a, b)\t\tHIST_ERR_##a\n\nenum { ERRORS };\n\n#undef C\n#define C(a, b)\t\tb\n\nstatic const char *err_text[] = { ERRORS };\n\nstruct hist_field;\n\ntypedef u64 (*hist_field_fn_t) (struct hist_field *field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event);\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n#define HIST_ACTIONS_MAX\t8\n#define HIST_CONST_DIGITS_MAX\t21\n#define HIST_DIV_SHIFT\t\t20   \n\nenum field_op_id {\n\tFIELD_OP_NONE,\n\tFIELD_OP_PLUS,\n\tFIELD_OP_MINUS,\n\tFIELD_OP_UNARY_MINUS,\n\tFIELD_OP_DIV,\n\tFIELD_OP_MULT,\n};\n\nenum hist_field_fn {\n\tHIST_FIELD_FN_NOP,\n\tHIST_FIELD_FN_VAR_REF,\n\tHIST_FIELD_FN_COUNTER,\n\tHIST_FIELD_FN_CONST,\n\tHIST_FIELD_FN_LOG2,\n\tHIST_FIELD_FN_BUCKET,\n\tHIST_FIELD_FN_TIMESTAMP,\n\tHIST_FIELD_FN_CPU,\n\tHIST_FIELD_FN_STRING,\n\tHIST_FIELD_FN_DYNSTRING,\n\tHIST_FIELD_FN_RELDYNSTRING,\n\tHIST_FIELD_FN_PSTRING,\n\tHIST_FIELD_FN_S64,\n\tHIST_FIELD_FN_U64,\n\tHIST_FIELD_FN_S32,\n\tHIST_FIELD_FN_U32,\n\tHIST_FIELD_FN_S16,\n\tHIST_FIELD_FN_U16,\n\tHIST_FIELD_FN_S8,\n\tHIST_FIELD_FN_U8,\n\tHIST_FIELD_FN_UMINUS,\n\tHIST_FIELD_FN_MINUS,\n\tHIST_FIELD_FN_PLUS,\n\tHIST_FIELD_FN_DIV,\n\tHIST_FIELD_FN_MULT,\n\tHIST_FIELD_FN_DIV_POWER2,\n\tHIST_FIELD_FN_DIV_NOT_POWER2,\n\tHIST_FIELD_FN_DIV_MULT_SHIFT,\n\tHIST_FIELD_FN_EXECNAME,\n\tHIST_FIELD_FN_STACK,\n};\n\n \nstruct hist_var {\n\tchar\t\t\t\t*name;\n\tstruct hist_trigger_data\t*hist_data;\n\tunsigned int\t\t\tidx;\n};\n\nstruct hist_field {\n\tstruct ftrace_event_field\t*field;\n\tunsigned long\t\t\tflags;\n\tunsigned long\t\t\tbuckets;\n\tconst char\t\t\t*type;\n\tstruct hist_field\t\t*operands[HIST_FIELD_OPERANDS_MAX];\n\tstruct hist_trigger_data\t*hist_data;\n\tenum hist_field_fn\t\tfn_num;\n\tunsigned int\t\t\tref;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\toffset;\n\tunsigned int                    is_signed;\n\n\t \n\tstruct hist_var\t\t\tvar;\n\tenum field_op_id\t\toperator;\n\tchar\t\t\t\t*system;\n\tchar\t\t\t\t*event_name;\n\n\t \n\tchar\t\t\t\t*name;\n\n\t \n\tunsigned int\t\t\tvar_ref_idx;\n\tbool                            read_once;\n\n\tunsigned int\t\t\tvar_str_idx;\n\n\t \n\tu64\t\t\t\tconstant;\n\t \n\tu64\t\t\t\tdiv_multiplier;\n};\n\nstatic u64 hist_fn_call(struct hist_field *hist_field,\n\t\t\tstruct tracing_map_elt *elt,\n\t\t\tstruct trace_buffer *buffer,\n\t\t\tstruct ring_buffer_event *rbe,\n\t\t\tvoid *event);\n\nstatic u64 hist_field_const(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn field->constant;\n}\n\nstatic u64 hist_field_counter(struct hist_field *field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\treturn 1;\n}\n\nstatic u64 hist_field_string(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tchar *addr = (char *)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)addr;\n}\n\nstatic u64 hist_field_dynstring(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tu32 str_item = *(u32 *)(event + hist_field->field->offset);\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)(event + str_loc);\n\n\treturn (u64)(unsigned long)addr;\n}\n\nstatic u64 hist_field_reldynstring(struct hist_field *hist_field,\n\t\t\t\t   struct tracing_map_elt *elt,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t\t   void *event)\n{\n\tu32 *item = event + hist_field->field->offset;\n\tu32 str_item = *item;\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)&item[1] + str_loc;\n\n\treturn (u64)(unsigned long)addr;\n}\n\nstatic u64 hist_field_pstring(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tchar **addr = (char **)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)*addr;\n}\n\nstatic u64 hist_field_log2(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\tu64 val = hist_fn_call(operand, elt, buffer, rbe, event);\n\n\treturn (u64) ilog2(roundup_pow_of_two(val));\n}\n\nstatic u64 hist_field_bucket(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\tunsigned long buckets = hist_field->buckets;\n\n\tu64 val = hist_fn_call(operand, elt, buffer, rbe, event);\n\n\tif (WARN_ON_ONCE(!buckets))\n\t\treturn val;\n\n\tif (val >= LONG_MAX)\n\t\tval = div64_ul(val, buckets);\n\telse\n\t\tval = (u64)((unsigned long)val / buckets);\n\treturn val * buckets;\n}\n\nstatic u64 hist_field_plus(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\tu64 val2 = hist_fn_call(operand2, elt, buffer, rbe, event);\n\n\treturn val1 + val2;\n}\n\nstatic u64 hist_field_minus(struct hist_field *hist_field,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\tu64 val2 = hist_fn_call(operand2, elt, buffer, rbe, event);\n\n\treturn val1 - val2;\n}\n\nstatic u64 hist_field_div(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\tu64 val2 = hist_fn_call(operand2, elt, buffer, rbe, event);\n\n\t \n\tif (!val2)\n\t\treturn -1;\n\n\t \n\tif (!(val2 & (val2 - 1)))\n\t\treturn val1 >> __ffs64(val2);\n\n\treturn div64_u64(val1, val2);\n}\n\nstatic u64 div_by_power_of_two(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\n\treturn val1 >> __ffs64(operand2->constant);\n}\n\nstatic u64 div_by_not_power_of_two(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\n\treturn div64_u64(val1, operand2->constant);\n}\n\nstatic u64 div_by_mult_and_shift(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\n\t \n\tif (val1 < (1 << HIST_DIV_SHIFT)) {\n\t\tu64 mult = operand2->div_multiplier;\n\n\t\treturn (val1 * mult + ((1 << HIST_DIV_SHIFT) - 1)) >> HIST_DIV_SHIFT;\n\t}\n\n\treturn div64_u64(val1, operand2->constant);\n}\n\nstatic u64 hist_field_mult(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = hist_fn_call(operand1, elt, buffer, rbe, event);\n\tu64 val2 = hist_fn_call(operand2, elt, buffer, rbe, event);\n\n\treturn val1 * val2;\n}\n\nstatic u64 hist_field_unary_minus(struct hist_field *hist_field,\n\t\t\t\t  struct tracing_map_elt *elt,\n\t\t\t\t  struct trace_buffer *buffer,\n\t\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t\t  void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\ts64 sval = (s64)hist_fn_call(operand, elt, buffer, rbe, event);\n\tu64 val = (u64)-sval;\n\n\treturn val;\n}\n\n#define DEFINE_HIST_FIELD_FN(type)\t\t\t\t\t\\\n\tstatic u64 hist_field_##type(struct hist_field *hist_field,\t\\\n\t\t\t\t     struct tracing_map_elt *elt,\t\\\n\t\t\t\t     struct trace_buffer *buffer,\t\\\n\t\t\t\t     struct ring_buffer_event *rbe,\t\\\n\t\t\t\t     void *event)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + hist_field->field->offset);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn (u64)(unsigned long)*addr;\t\t\t\t\\\n}\n\nDEFINE_HIST_FIELD_FN(s64);\nDEFINE_HIST_FIELD_FN(u64);\nDEFINE_HIST_FIELD_FN(s32);\nDEFINE_HIST_FIELD_FN(u32);\nDEFINE_HIST_FIELD_FN(s16);\nDEFINE_HIST_FIELD_FN(u16);\nDEFINE_HIST_FIELD_FN(s8);\nDEFINE_HIST_FIELD_FN(u8);\n\n#define for_each_hist_field(i, hist_data)\t\\\n\tfor ((i) = 0; (i) < (hist_data)->n_fields; (i)++)\n\n#define for_each_hist_val_field(i, hist_data)\t\\\n\tfor ((i) = 0; (i) < (hist_data)->n_vals; (i)++)\n\n#define for_each_hist_key_field(i, hist_data)\t\\\n\tfor ((i) = (hist_data)->n_vals; (i) < (hist_data)->n_fields; (i)++)\n\n#define HITCOUNT_IDX\t\t0\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n\nenum hist_field_flags {\n\tHIST_FIELD_FL_HITCOUNT\t\t= 1 << 0,\n\tHIST_FIELD_FL_KEY\t\t= 1 << 1,\n\tHIST_FIELD_FL_STRING\t\t= 1 << 2,\n\tHIST_FIELD_FL_HEX\t\t= 1 << 3,\n\tHIST_FIELD_FL_SYM\t\t= 1 << 4,\n\tHIST_FIELD_FL_SYM_OFFSET\t= 1 << 5,\n\tHIST_FIELD_FL_EXECNAME\t\t= 1 << 6,\n\tHIST_FIELD_FL_SYSCALL\t\t= 1 << 7,\n\tHIST_FIELD_FL_STACKTRACE\t= 1 << 8,\n\tHIST_FIELD_FL_LOG2\t\t= 1 << 9,\n\tHIST_FIELD_FL_TIMESTAMP\t\t= 1 << 10,\n\tHIST_FIELD_FL_TIMESTAMP_USECS\t= 1 << 11,\n\tHIST_FIELD_FL_VAR\t\t= 1 << 12,\n\tHIST_FIELD_FL_EXPR\t\t= 1 << 13,\n\tHIST_FIELD_FL_VAR_REF\t\t= 1 << 14,\n\tHIST_FIELD_FL_CPU\t\t= 1 << 15,\n\tHIST_FIELD_FL_ALIAS\t\t= 1 << 16,\n\tHIST_FIELD_FL_BUCKET\t\t= 1 << 17,\n\tHIST_FIELD_FL_CONST\t\t= 1 << 18,\n\tHIST_FIELD_FL_PERCENT\t\t= 1 << 19,\n\tHIST_FIELD_FL_GRAPH\t\t= 1 << 20,\n};\n\nstruct var_defs {\n\tunsigned int\tn_vars;\n\tchar\t\t*name[TRACING_MAP_VARS_MAX];\n\tchar\t\t*expr[TRACING_MAP_VARS_MAX];\n};\n\nstruct hist_trigger_attrs {\n\tchar\t\t*keys_str;\n\tchar\t\t*vals_str;\n\tchar\t\t*sort_key_str;\n\tchar\t\t*name;\n\tchar\t\t*clock;\n\tbool\t\tpause;\n\tbool\t\tcont;\n\tbool\t\tclear;\n\tbool\t\tts_in_usecs;\n\tbool\t\tno_hitcount;\n\tunsigned int\tmap_bits;\n\n\tchar\t\t*assignment_str[TRACING_MAP_VARS_MAX];\n\tunsigned int\tn_assignments;\n\n\tchar\t\t*action_str[HIST_ACTIONS_MAX];\n\tunsigned int\tn_actions;\n\n\tstruct var_defs\tvar_defs;\n};\n\nstruct field_var {\n\tstruct hist_field\t*var;\n\tstruct hist_field\t*val;\n};\n\nstruct field_var_hist {\n\tstruct hist_trigger_data\t*hist_data;\n\tchar\t\t\t\t*cmd;\n};\n\nstruct hist_trigger_data {\n\tstruct hist_field               *fields[HIST_FIELDS_MAX];\n\tunsigned int\t\t\tn_vals;\n\tunsigned int\t\t\tn_keys;\n\tunsigned int\t\t\tn_fields;\n\tunsigned int\t\t\tn_vars;\n\tunsigned int\t\t\tn_var_str;\n\tunsigned int\t\t\tkey_size;\n\tstruct tracing_map_sort_key\tsort_keys[TRACING_MAP_SORT_KEYS_MAX];\n\tunsigned int\t\t\tn_sort_keys;\n\tstruct trace_event_file\t\t*event_file;\n\tstruct hist_trigger_attrs\t*attrs;\n\tstruct tracing_map\t\t*map;\n\tbool\t\t\t\tenable_timestamps;\n\tbool\t\t\t\tremove;\n\tstruct hist_field               *var_refs[TRACING_MAP_VARS_MAX];\n\tunsigned int\t\t\tn_var_refs;\n\n\tstruct action_data\t\t*actions[HIST_ACTIONS_MAX];\n\tunsigned int\t\t\tn_actions;\n\n\tstruct field_var\t\t*field_vars[SYNTH_FIELDS_MAX];\n\tunsigned int\t\t\tn_field_vars;\n\tunsigned int\t\t\tn_field_var_str;\n\tstruct field_var_hist\t\t*field_var_hists[SYNTH_FIELDS_MAX];\n\tunsigned int\t\t\tn_field_var_hists;\n\n\tstruct field_var\t\t*save_vars[SYNTH_FIELDS_MAX];\n\tunsigned int\t\t\tn_save_vars;\n\tunsigned int\t\t\tn_save_var_str;\n};\n\nstruct action_data;\n\ntypedef void (*action_fn_t) (struct hist_trigger_data *hist_data,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t     struct action_data *data, u64 *var_ref_vals);\n\ntypedef bool (*check_track_val_fn_t) (u64 track_val, u64 var_val);\n\nenum handler_id {\n\tHANDLER_ONMATCH = 1,\n\tHANDLER_ONMAX,\n\tHANDLER_ONCHANGE,\n};\n\nenum action_id {\n\tACTION_SAVE = 1,\n\tACTION_TRACE,\n\tACTION_SNAPSHOT,\n};\n\nstruct action_data {\n\tenum handler_id\t\thandler;\n\tenum action_id\t\taction;\n\tchar\t\t\t*action_name;\n\taction_fn_t\t\tfn;\n\n\tunsigned int\t\tn_params;\n\tchar\t\t\t*params[SYNTH_FIELDS_MAX];\n\n\t \n\tunsigned int\t\tvar_ref_idx[SYNTH_FIELDS_MAX];\n\tstruct synth_event\t*synth_event;\n\tbool\t\t\tuse_trace_keyword;\n\tchar\t\t\t*synth_event_name;\n\n\tunion {\n\t\tstruct {\n\t\t\tchar\t\t\t*event;\n\t\t\tchar\t\t\t*event_system;\n\t\t} match_data;\n\n\t\tstruct {\n\t\t\t \n\t\t\tchar\t\t\t*var_str;\n\n\t\t\t \n\t\t\tstruct hist_field\t*var_ref;\n\n\t\t\t \n\t\t\tstruct hist_field\t*track_var;\n\n\t\t\tcheck_track_val_fn_t\tcheck_val;\n\t\t\taction_fn_t\t\tsave_data;\n\t\t} track_data;\n\t};\n};\n\nstruct track_data {\n\tu64\t\t\t\ttrack_val;\n\tbool\t\t\t\tupdated;\n\n\tunsigned int\t\t\tkey_len;\n\tvoid\t\t\t\t*key;\n\tstruct tracing_map_elt\t\telt;\n\n\tstruct action_data\t\t*action_data;\n\tstruct hist_trigger_data\t*hist_data;\n};\n\nstruct hist_elt_data {\n\tchar *comm;\n\tu64 *var_ref_vals;\n\tchar **field_var_str;\n\tint n_field_var_str;\n};\n\nstruct snapshot_context {\n\tstruct tracing_map_elt\t*elt;\n\tvoid\t\t\t*key;\n};\n\n \nstatic enum hist_field_fn hist_field_get_div_fn(struct hist_field *divisor)\n{\n\tu64 div = divisor->constant;\n\n\tif (!(div & (div - 1)))\n\t\treturn HIST_FIELD_FN_DIV_POWER2;\n\n\t \n\tif (div > (1 << HIST_DIV_SHIFT))\n\t\treturn HIST_FIELD_FN_DIV_NOT_POWER2;\n\n\tdivisor->div_multiplier = div64_u64((u64)(1 << HIST_DIV_SHIFT), div);\n\treturn HIST_FIELD_FN_DIV_MULT_SHIFT;\n}\n\nstatic void track_data_free(struct track_data *track_data)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (!track_data)\n\t\treturn;\n\n\tkfree(track_data->key);\n\n\telt_data = track_data->elt.private_data;\n\tif (elt_data) {\n\t\tkfree(elt_data->comm);\n\t\tkfree(elt_data);\n\t}\n\n\tkfree(track_data);\n}\n\nstatic struct track_data *track_data_alloc(unsigned int key_len,\n\t\t\t\t\t   struct action_data *action_data,\n\t\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tstruct track_data *data = kzalloc(sizeof(*data), GFP_KERNEL);\n\tstruct hist_elt_data *elt_data;\n\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata->key = kzalloc(key_len, GFP_KERNEL);\n\tif (!data->key) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->key_len = key_len;\n\tdata->action_data = action_data;\n\tdata->hist_data = hist_data;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdata->elt.private_data = elt_data;\n\n\telt_data->comm = kzalloc(TASK_COMM_LEN, GFP_KERNEL);\n\tif (!elt_data->comm) {\n\t\ttrack_data_free(data);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn data;\n}\n\n#define HIST_PREFIX \"hist:\"\n\nstatic char *last_cmd;\nstatic char last_cmd_loc[MAX_FILTER_STR_VAL];\n\nstatic int errpos(char *str)\n{\n\tif (!str || !last_cmd)\n\t\treturn 0;\n\n\treturn err_pos(last_cmd, str);\n}\n\nstatic void last_cmd_set(struct trace_event_file *file, char *str)\n{\n\tconst char *system = NULL, *name = NULL;\n\tstruct trace_event_call *call;\n\tint len;\n\n\tif (!str)\n\t\treturn;\n\n\t \n\tlen = sizeof(HIST_PREFIX) + strlen(str);\n\tkfree(last_cmd);\n\tlast_cmd = kzalloc(len, GFP_KERNEL);\n\tif (!last_cmd)\n\t\treturn;\n\n\tstrcpy(last_cmd, HIST_PREFIX);\n\t \n\tlen -= sizeof(HIST_PREFIX);\n\tstrncat(last_cmd, str, len);\n\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsystem = call->class->system;\n\t\tif (system) {\n\t\t\tname = trace_event_name(call);\n\t\t\tif (!name)\n\t\t\t\tsystem = NULL;\n\t\t}\n\t}\n\n\tif (system)\n\t\tsnprintf(last_cmd_loc, MAX_FILTER_STR_VAL, HIST_PREFIX \"%s:%s\", system, name);\n}\n\nstatic void hist_err(struct trace_array *tr, u8 err_type, u16 err_pos)\n{\n\tif (!last_cmd)\n\t\treturn;\n\n\ttracing_log_err(tr, last_cmd_loc, last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}\n\nstatic void hist_err_clear(void)\n{\n\tif (last_cmd)\n\t\tlast_cmd[0] = '\\0';\n\tlast_cmd_loc[0] = '\\0';\n}\n\ntypedef void (*synth_probe_func_t) (void *__data, u64 *var_ref_vals,\n\t\t\t\t    unsigned int *var_ref_idx);\n\nstatic inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int *var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}\n\nstatic void action_trace(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct trace_buffer *buffer, void *rec,\n\t\t\t struct ring_buffer_event *rbe, void *key,\n\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\tstruct synth_event *event = data->synth_event;\n\n\ttrace_synth(event, var_ref_vals, data->var_ref_idx);\n}\n\nstruct hist_var_data {\n\tstruct list_head list;\n\tstruct hist_trigger_data *hist_data;\n};\n\nstatic u64 hist_field_timestamp(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct trace_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_trigger_data *hist_data = hist_field->hist_data;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tu64 ts = ring_buffer_event_time_stamp(buffer, rbe);\n\n\tif (hist_data->attrs->ts_in_usecs && trace_clock_in_ns(tr))\n\t\tts = ns2usecs(ts);\n\n\treturn ts;\n}\n\nstatic u64 hist_field_cpu(struct hist_field *hist_field,\n\t\t\t  struct tracing_map_elt *elt,\n\t\t\t  struct trace_buffer *buffer,\n\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t  void *event)\n{\n\tint cpu = smp_processor_id();\n\n\treturn cpu;\n}\n\n \nstatic struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tWARN_ON(!(hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF));\n\n\tif (hist_field && hist_field->var.idx == var_idx &&\n\t    hist_field->var.hist_data == var_data)\n\t\treturn hist_field;\n\n\treturn NULL;\n}\n\n \nstatic struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tif (check_field_for_var_ref(hist_field, var_data, var_idx))\n\t\t\treturn hist_field;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}\n\n \nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE, errpos(var_name));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tchar *system = data->match_data.event_system;\n\t\t\tchar *event_name = data->match_data.event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err(tr, HIST_ERR_VAR_NOT_UNIQUE,\n\t\t\t\t\t\t errpos(var_name));\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}\n\nstatic u64 hist_field_var_ref(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\tu64 var_val = 0;\n\n\tif (WARN_ON_ONCE(!elt))\n\t\treturn var_val;\n\n\telt_data = elt->private_data;\n\tvar_val = elt_data->var_ref_vals[hist_field->var_ref_idx];\n\n\treturn var_val;\n}\n\nstatic bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (WARN_ON_ONCE(!field))\n\t\treturn field_name;\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS ||\n\t\t field->flags & HIST_FIELD_FL_BUCKET)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"common_cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\telse if (field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\tif (field->field)\n\t\t\tfield_name = field->field->name;\n\t\telse\n\t\t\tfield_name = \"common_stacktrace\";\n\t} else if (field->flags & HIST_FIELD_FL_HITCOUNT)\n\t\tfield_name = \"hitcount\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}\n\nstatic enum hist_field_fn select_value_fn(int field_size, int field_is_signed)\n{\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\treturn HIST_FIELD_FN_S64;\n\t\telse\n\t\t\treturn HIST_FIELD_FN_U64;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\treturn HIST_FIELD_FN_S32;\n\t\telse\n\t\t\treturn HIST_FIELD_FN_U32;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\treturn HIST_FIELD_FN_S16;\n\t\telse\n\t\t\treturn HIST_FIELD_FN_U16;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\treturn HIST_FIELD_FN_S8;\n\t\telse\n\t\t\treturn HIST_FIELD_FN_U8;\n\t}\n\n\treturn HIST_FIELD_FN_NOP;\n}\n\nstatic int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}\n\nstatic int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((str_has_prefix(str, \"onmatch(\")) ||\n\t    (str_has_prefix(str, \"onmax(\")) ||\n\t    (str_has_prefix(str, \"onchange(\"))) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic int parse_assignment(struct trace_array *tr,\n\t\t\t    char *str, struct hist_trigger_attrs *attrs)\n{\n\tint len, ret = 0;\n\n\tif ((len = str_has_prefix(str, \"key=\")) ||\n\t    (len = str_has_prefix(str, \"keys=\"))) {\n\t\tattrs->keys_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"val=\")) ||\n\t\t   (len = str_has_prefix(str, \"vals=\")) ||\n\t\t   (len = str_has_prefix(str, \"values=\"))) {\n\t\tattrs->vals_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"sort=\"))) {\n\t\tattrs->sort_key_str = kstrdup(str + len, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (str_has_prefix(str, \"name=\")) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"clock=\"))) {\n\t\tstr += len;\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((len = str_has_prefix(str, \"size=\"))) {\n\t\tint map_bits = parse_map_size(str + len);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}\n\nstatic struct hist_trigger_attrs *\nparse_hist_trigger_attrs(struct trace_array *tr, char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\t\tchar *rhs;\n\n\t\trhs = strchr(str, '=');\n\t\tif (rhs) {\n\t\t\tif (!strlen(++rhs)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\thist_err(tr, HIST_ERR_EMPTY_ASSIGNMENT, errpos(str));\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tret = parse_assignment(tr, str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"nohitcount\") == 0 ||\n\t\t\t   strcmp(str, \"NOHC\") == 0)\n\t\t\tattrs->no_hitcount = true;\n\t\telse if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tstrncpy(comm, task->comm, TASK_COMM_LEN);\n}\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < elt_data->n_field_var_str; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->field_var_str);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}\n\nstatic void hist_trigger_elt_data_free(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\thist_elt_data_free(elt_data);\n}\n\nstatic int hist_trigger_elt_data_alloc(struct tracing_map_elt *elt)\n{\n\tstruct hist_trigger_data *hist_data = elt->map->private_data;\n\tunsigned int size = TASK_COMM_LEN;\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, n_str;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data)\n\t\treturn -ENOMEM;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\telt_data->comm = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!elt_data->comm) {\n\t\t\t\tkfree(elt_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn_str = hist_data->n_field_var_str + hist_data->n_save_var_str +\n\t\thist_data->n_var_str;\n\tif (n_str > SYNTH_FIELDS_MAX) {\n\t\thist_elt_data_free(elt_data);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(STR_VAR_LEN_MAX & (sizeof(u64) - 1));\n\n\tsize = STR_VAR_LEN_MAX;\n\n\telt_data->field_var_str = kcalloc(n_str, sizeof(char *), GFP_KERNEL);\n\tif (!elt_data->field_var_str) {\n\t\thist_elt_data_free(elt_data);\n\t\treturn -EINVAL;\n\t}\n\telt_data->n_field_var_str = n_str;\n\n\tfor (i = 0; i < n_str; i++) {\n\t\telt_data->field_var_str[i] = kzalloc(size, GFP_KERNEL);\n\t\tif (!elt_data->field_var_str[i]) {\n\t\t\thist_elt_data_free(elt_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\telt->private_data = elt_data;\n\n\treturn 0;\n}\n\nstatic void hist_trigger_elt_data_init(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\tif (elt_data->comm)\n\t\tsave_comm(elt_data->comm, current);\n}\n\nstatic const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_BUCKET)\n\t\tflags_str = \"buckets\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\telse if (hist_field->flags & HIST_FIELD_FL_PERCENT)\n\t\tflags_str = \"percent\";\n\telse if (hist_field->flags & HIST_FIELD_FL_GRAPH)\n\t\tflags_str = \"graph\";\n\telse if (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\tflags_str = \"stacktrace\";\n\n\treturn flags_str;\n}\n\nstatic void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\telse if (field->flags & HIST_FIELD_FL_CONST) {\n\t\tchar str[HIST_CONST_DIGITS_MAX];\n\n\t\tsnprintf(str, HIST_CONST_DIGITS_MAX, \"%llu\", field->constant);\n\t\tstrcat(expr, str);\n\t}\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\tstrcat(expr, \"/\");\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\tstrcat(expr, \"*\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}\n\n \nstatic int contains_operator(char *str, char **sep)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *minus_op, *plus_op, *div_op, *mult_op;\n\n\n\t \n\n\t \n\tminus_op = strrchr(str, '-');\n\tif (minus_op) {\n\t\t \n\t\tif (minus_op == str) {\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_op = FIELD_OP_MINUS;\n\t}\n\n\tplus_op = strrchr(str, '+');\n\tif (plus_op || minus_op) {\n\t\t \n\t\tif (plus_op > minus_op)\n\t\t\tfield_op = FIELD_OP_PLUS;\n\t\tgoto out;\n\t}\n\n\t \n\tdiv_op = strrchr(str, '/');\n\tif (div_op)\n\t\tfield_op = FIELD_OP_DIV;\n\n\tmult_op = strrchr(str, '*');\n\t \n\tif (mult_op > div_op)\n\t\tfield_op = FIELD_OP_MULT;\n\nout:\n\tif (sep) {\n\t\tswitch (field_op) {\n\t\tcase FIELD_OP_UNARY_MINUS:\n\t\tcase FIELD_OP_MINUS:\n\t\t\t*sep = minus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_PLUS:\n\t\t\t*sep = plus_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_DIV:\n\t\t\t*sep = div_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_MULT:\n\t\t\t*sep = mult_op;\n\t\t\tbreak;\n\t\tcase FIELD_OP_NONE:\n\t\tdefault:\n\t\t\t*sep = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn field_op;\n}\n\nstatic void get_hist_field(struct hist_field *hist_field)\n{\n\thist_field->ref++;\n}\n\nstatic void __destroy_hist_field(struct hist_field *hist_field)\n{\n\tif (--hist_field->ref > 1)\n\t\treturn;\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\n\t \n\tkfree_const(hist_field->type);\n\n\tkfree(hist_field->system);\n\tkfree(hist_field->event_name);\n\n\tkfree(hist_field);\n}\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn;  \n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\t__destroy_hist_field(hist_field);\n}\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->ref = 1;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out;  \n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn_num = HIST_FIELD_FN_VAR_REF;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn_num = HIST_FIELD_FN_COUNTER;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CONST) {\n\t\thist_field->fn_num = HIST_FIELD_FN_CONST;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\tif (field)\n\t\t\thist_field->fn_num = HIST_FIELD_FN_STACK;\n\t\telse\n\t\t\thist_field->fn_num = HIST_FIELD_FN_NOP;\n\t\thist_field->size = HIST_STACKTRACE_SIZE;\n\t\thist_field->type = kstrdup_const(\"unsigned long[]\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & (HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET)) {\n\t\tunsigned long fl = flags & ~(HIST_FIELD_FL_LOG2 | HIST_FIELD_FL_BUCKET);\n\t\thist_field->fn_num = flags & HIST_FIELD_FL_LOG2 ? HIST_FIELD_FN_LOG2 :\n\t\t\tHIST_FIELD_FN_BUCKET;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\tif (!hist_field->operands[0])\n\t\t\tgoto free;\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup_const(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn_num = HIST_FIELD_FN_TIMESTAMP;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = \"u64\";\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn_num = HIST_FIELD_FN_CPU;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = \"unsigned int\";\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\t \n\tif (is_string_field(field) &&\n\t    (field->filter_type != FILTER_PTR_STRING)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\thist_field->fn_num = HIST_FIELD_FN_STRING;\n\t\t\thist_field->size = field->size;\n\t\t} else if (field->filter_type == FILTER_DYN_STRING) {\n\t\t\thist_field->fn_num = HIST_FIELD_FN_DYNSTRING;\n\t\t} else if (field->filter_type == FILTER_RDYN_STRING)\n\t\t\thist_field->fn_num = HIST_FIELD_FN_RELDYNSTRING;\n\t\telse\n\t\t\thist_field->fn_num = HIST_FIELD_FN_PSTRING;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup_const(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn_num = select_value_fn(field->size,\n\t\t\t\t\t\t     field->is_signed);\n\t\tif (hist_field->fn_num == HIST_FIELD_FN_NOP) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}\n\nstatic void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tWARN_ON(!(hist_data->var_refs[i]->flags & HIST_FIELD_FL_VAR_REF));\n\t\t__destroy_hist_field(hist_data->var_refs[i]);\n\t\thist_data->var_refs[i] = NULL;\n\t}\n}\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup_const(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tref_field->system = NULL;\n\tkfree(ref_field->event_name);\n\tref_field->event_name = NULL;\n\tkfree(ref_field->name);\n\tref_field->name = NULL;\n\n\tgoto out;\n}\n\nstatic int find_var_ref_idx(struct hist_trigger_data *hist_data,\n\t\t\t    struct hist_field *var_field)\n{\n\tstruct hist_field *ref_field;\n\tint i;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic struct hist_field *create_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\tint i;\n\n\t \n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tref_field = hist_data->var_refs[i];\n\t\tif (ref_field->var.idx == var_field->var.idx &&\n\t\t    ref_field->var.hist_data == var_field->hist_data) {\n\t\t\tget_hist_field(ref_field);\n\t\t\treturn ref_field;\n\t\t}\n\t}\n\t \n\tif (hist_data->n_var_refs >= TRACING_MAP_VARS_MAX)\n\t\treturn NULL;\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\n\t\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\t\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\t}\n\n\treturn ref_field;\n}\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field, NULL) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}\n\nstatic struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(hist_data, var_field,\n\t\t\t\t\t   system, event_name);\n\n\tif (!ref_field)\n\t\thist_err(tr, HIST_ERR_VAR_NOT_FOUND, errpos(var_name));\n\n\treturn ref_field;\n}\n\nstatic struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags, unsigned long *buckets)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\tstruct trace_array *tr = file->tr;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\t \n\t\telse if (strcmp(modifier, \"symXoffset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"stacktrace\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_STACKTRACE;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse if (strncmp(modifier, \"bucket\", 6) == 0) {\n\t\t\tint ret;\n\n\t\t\tmodifier += 6;\n\n\t\t\tif (*modifier == 's')\n\t\t\t\tmodifier++;\n\t\t\tif (*modifier != '=')\n\t\t\t\tgoto error;\n\t\t\tmodifier++;\n\t\t\tret = kstrtoul(modifier, 0, buckets);\n\t\t\tif (ret || !(*buckets))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_BUCKET;\n\t\t} else if (strncmp(modifier, \"percent\", 7) == 0) {\n\t\t\tif (*flags & (HIST_FIELD_FL_VAR | HIST_FIELD_FL_KEY))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_PERCENT;\n\t\t} else if (strncmp(modifier, \"graph\", 5) == 0) {\n\t\t\tif (*flags & (HIST_FIELD_FL_VAR | HIST_FIELD_FL_KEY))\n\t\t\t\tgoto error;\n\t\t\t*flags |= HIST_FIELD_FL_GRAPH;\n\t\t} else {\n error:\n\t\t\thist_err(tr, HIST_ERR_BAD_FIELD_MODIFIER, errpos(modifier));\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"common_stacktrace\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_STACKTRACE;\n\t} else if (strcmp(field_name, \"common_cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse if (strcmp(field_name, \"hitcount\") == 0)\n\t\t*flags |= HIST_FIELD_FL_HITCOUNT;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\t \n\t\t\tif (field && field->filter_type == FILTER_CPU) {\n\t\t\t\t*flags |= HIST_FIELD_FL_CPU;\n\t\t\t} else if (field && field->filter_type == FILTER_STACKTRACE) {\n\t\t\t\t*flags |= HIST_FIELD_FL_STACKTRACE;\n\t\t\t} else {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_NOT_FOUND,\n\t\t\t\t\t errpos(field_name));\n\t\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}\n\nstatic struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn_num = var_ref->fn_num;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\talias->var_ref_idx = var_ref->var_ref_idx;\n\n\treturn alias;\n}\n\nstatic struct hist_field *parse_const(struct hist_trigger_data *hist_data,\n\t\t\t\t      char *str, char *var_name,\n\t\t\t\t      unsigned long *flags)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *field = NULL;\n\tu64 constant;\n\n\tif (kstrtoull(str, 0, &constant)) {\n\t\thist_err(tr, HIST_ERR_EXPECT_NUMBER, errpos(str));\n\t\treturn NULL;\n\t}\n\n\t*flags |= HIST_FIELD_FL_CONST;\n\tfield = create_hist_field(hist_data, NULL, *flags, var_name);\n\tif (!field)\n\t\treturn NULL;\n\n\tfield->constant = constant;\n\n\treturn field;\n}\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long buckets = 0;\n\tint ret = 0;\n\n\tif (isdigit(str[0])) {\n\t\thist_field = parse_const(hist_data, str, var_name, flags);\n\t\tif (!hist_field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treturn hist_field;\n\t}\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system,\n\t\t\t\t\t   ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags, &buckets);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_field->buckets = buckets;\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs);\n\nstatic struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t \n\t++*n_subexprs;\n\n\t \n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++;  \n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s) {\n\t\t  \n\t\tif (*(s+1) != '\\0') {\n\t\t\thist_err(file->tr, HIST_ERR_UNARY_MINUS_SUBEXPR,\n\t\t\t\t errpos(str));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\t*s = '\\0';\n\t}\n\telse {\n\t\tret = -EINVAL;  \n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\t \n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tdestroy_hist_field(operand1, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn_num = HIST_FIELD_FN_UMINUS;\n\texpr->operands[0] = operand1;\n\texpr->size = operand1->size;\n\texpr->is_signed = operand1->is_signed;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int check_expr_operands(struct trace_array *tr,\n\t\t\t       struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2,\n\t\t\t       struct hist_field **var1,\n\t\t\t       struct hist_field **var2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t\t*var1 = var;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t\t*var2 = var;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(tr, HIST_ERR_TIMESTAMP_MISMATCH, 0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int *n_subexprs)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tstruct hist_field *var1 = NULL, *var2 = NULL;\n\tunsigned long operand_flags, operand2_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\tenum hist_field_fn op_fn;\n\tbool combine_consts;\n\n\tif (*n_subexprs > 3) {\n\t\thist_err(file->tr, HIST_ERR_TOO_MANY_SUBEXPR, errpos(str));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str, &sep);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, n_subexprs);\n\n\t \n\t++*n_subexprs;\n\n\t \n\tif (!sep)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*sep = '\\0';\n\toperand1_str = str;\n\tstr = sep+1;\n\n\t \n\tif (*operand1_str == '\\0' || *str == '\\0')\n\t\treturn ERR_PTR(-EINVAL);\n\n\toperand_flags = 0;\n\n\t \n\toperand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand1))\n\t\treturn ERR_CAST(operand1);\n\n\tif (operand1->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));\n\t\tret = -EINVAL;\n\t\tgoto free_op1;\n\t}\n\n\t \n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, n_subexprs);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\tgoto free_op1;\n\t}\n\tif (operand2->flags & HIST_FIELD_FL_STRING) {\n\t\thist_err(file->tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\top_fn = HIST_FIELD_FN_MINUS;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\top_fn = HIST_FIELD_FN_PLUS;\n\t\tbreak;\n\tcase FIELD_OP_DIV:\n\t\top_fn = HIST_FIELD_FN_DIV;\n\t\tbreak;\n\tcase FIELD_OP_MULT:\n\t\top_fn = HIST_FIELD_FN_MULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free_operands;\n\t}\n\n\tret = check_expr_operands(file->tr, operand1, operand2, &var1, &var2);\n\tif (ret)\n\t\tgoto free_operands;\n\n\toperand_flags = var1 ? var1->flags : operand1->flags;\n\toperand2_flags = var2 ? var2->flags : operand2->flags;\n\n\t \n\tcombine_consts = operand_flags & operand2_flags & HIST_FIELD_FL_CONST;\n\n\tflags |= combine_consts ? HIST_FIELD_FL_CONST : HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_operands;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\t \n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\n\tif (field_op == FIELD_OP_DIV &&\n\t\t\toperand2_flags & HIST_FIELD_FL_CONST) {\n\t\tu64 divisor = var2 ? var2->constant : operand2->constant;\n\n\t\tif (!divisor) {\n\t\t\thist_err(file->tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));\n\t\t\tret = -EDOM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\t \n\t\toperand2->constant = divisor;\n\t\top_fn = hist_field_get_div_fn(operand2);\n\t}\n\n\texpr->fn_num = op_fn;\n\n\tif (combine_consts) {\n\t\tif (var1)\n\t\t\texpr->operands[0] = var1;\n\t\tif (var2)\n\t\t\texpr->operands[1] = var2;\n\n\t\texpr->constant = hist_fn_call(expr, NULL, NULL, NULL, NULL);\n\t\texpr->fn_num = HIST_FIELD_FN_CONST;\n\n\t\texpr->operands[0] = NULL;\n\t\texpr->operands[1] = NULL;\n\n\t\t \n\t\tdestroy_hist_field(operand2, 0);\n\t\tdestroy_hist_field(operand1, 0);\n\n\t\texpr->name = expr_str(expr, 0);\n\t} else {\n\t\t \n\t\texpr->size = operand1->size;\n\t\texpr->is_signed = operand1->is_signed;\n\n\t\texpr->operator = field_op;\n\t\texpr->type = kstrdup_const(operand1->type, GFP_KERNEL);\n\t\tif (!expr->type) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_expr;\n\t\t}\n\n\t\texpr->name = expr_str(expr, 0);\n\t}\n\n\treturn expr;\n\nfree_operands:\n\tdestroy_hist_field(operand2, 0);\nfree_op1:\n\tdestroy_hist_field(operand1, 0);\n\treturn ERR_PTR(ret);\n\nfree_expr:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}\n\nstatic char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct event_command trigger_hist_cmd;\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd,\n\t\t\t\t    char *param_and_filter);\n\nstatic bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}\n\nstatic struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}\n\n \nstatic struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tstruct hist_field *event_var;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err(tr, HIST_ERR_EVENT_FILE_NOT_FOUND, errpos(field_name));\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err(tr, HIST_ERR_HIST_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t \n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t \n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tvar_hist->hist_data = hist_data;\n\n\t \n\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t       \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_HIST_CREATE_FAIL, errpos(field_name));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t \n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err(tr, HIST_ERR_SYNTH_VAR_NOT_FOUND, errpos(field_name));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct trace_buffer *buffer,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\t \n\tBUILD_BUG_ON((HIST_STACKTRACE_DEPTH + 1) * sizeof(long) >= STR_VAR_LEN_MAX);\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = hist_fn_call(val, elt, buffer, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & (HIST_FIELD_FL_STRING |\n\t\t\t\t  HIST_FIELD_FL_STACKTRACE)) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\t\t\tunsigned int size;\n\n\t\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tsize = min(val->size, STR_VAR_LEN_MAX);\n\t\t\t\tstrscpy(str, val_str, size);\n\t\t\t} else {\n\t\t\t\tchar *stack_start = str + sizeof(unsigned long);\n\t\t\t\tint e;\n\n\t\t\t\te = stack_trace_save((void *)stack_start,\n\t\t\t\t\t\t     HIST_STACKTRACE_DEPTH,\n\t\t\t\t\t\t     HIST_STACKTRACE_SKIP);\n\t\t\t\tif (e < HIST_STACKTRACE_DEPTH - 1)\n\t\t\t\t\t((unsigned long *)stack_start)[e] = 0;\n\t\t\t\t*((unsigned long *)str) = e;\n\t\t\t}\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}\n\nstatic void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}\n\nstatic void save_track_data_vars(struct hist_trigger_data *hist_data,\n\t\t\t\t struct tracing_map_elt *elt,\n\t\t\t\t struct trace_buffer *buffer,  void *rec,\n\t\t\t\t struct ring_buffer_event *rbe, void *key,\n\t\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\t__update_field_vars(elt, buffer, rbe, rec, hist_data->save_vars,\n\t\t\t    hist_data->n_save_vars, hist_data->n_field_var_str);\n}\n\nstatic struct hist_field *create_var(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *name, int size, const char *type)\n{\n\tstruct hist_field *var;\n\tint idx;\n\n\tif (find_var(hist_data, file, name) && !hist_data->remove) {\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!var) {\n\t\tvar = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tidx = tracing_map_add_var(hist_data->map);\n\tif (idx < 0) {\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar->ref = 1;\n\tvar->flags = HIST_FIELD_FL_VAR;\n\tvar->var.idx = idx;\n\tvar->var.hist_data = var->hist_data = hist_data;\n\tvar->size = size;\n\tvar->var.name = kstrdup(name, GFP_KERNEL);\n\tvar->type = kstrdup_const(type, GFP_KERNEL);\n\tif (!var->var.name || !var->type) {\n\t\tkfree_const(var->type);\n\t\tkfree(var->var.name);\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-ENOMEM);\n\t}\n out:\n\treturn var;\n}\n\nstatic struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct trace_array *tr = file->tr;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(tr, HIST_ERR_TOO_MANY_FIELD_VARS, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(tr, HIST_ERR_FIELD_VAR_PARSE_FAIL, errpos(field_name));\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(tr, HIST_ERR_VAR_CREATE_FIND_FAIL, errpos(field_name));\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}\n\n \nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}\n\nstatic bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool check_track_val_changed(u64 track_val, u64 var_val)\n{\n\tif (var_val == track_val)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic u64 get_track_val(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt,\n\t\t\t struct action_data *data)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\tu64 track_val;\n\n\ttrack_val = tracing_map_read_var(elt, track_var_idx);\n\n\treturn track_val;\n}\n\nstatic void save_track_val(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct action_data *data, u64 var_val)\n{\n\tunsigned int track_var_idx = data->track_data.track_var->var.idx;\n\n\ttracing_map_set_var(elt, track_var_idx, var_val);\n}\n\nstatic void save_track_data(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t    struct ring_buffer_event *rbe, void *key,\n\t\t\t    struct action_data *data, u64 *var_ref_vals)\n{\n\tif (data->track_data.save_data)\n\t\tdata->track_data.save_data(hist_data, elt, buffer, rec, rbe,\n\t\t\t\t\t   key, data, var_ref_vals);\n}\n\nstatic bool check_track_val(struct tracing_map_elt *elt,\n\t\t\t    struct action_data *data,\n\t\t\t    u64 var_val)\n{\n\tstruct hist_trigger_data *hist_data;\n\tu64 track_val;\n\n\thist_data = data->track_data.track_var->hist_data;\n\ttrack_val = get_track_val(hist_data, elt, data);\n\n\treturn data->track_data.check_val(track_val, var_val);\n}\n\n#ifdef CONFIG_TRACER_SNAPSHOT\nstatic bool cond_snapshot_update(struct trace_array *tr, void *cond_data)\n{\n\t \n\tstruct track_data *track_data = tr->cond_snapshot->cond_data;\n\tstruct hist_elt_data *elt_data, *track_elt_data;\n\tstruct snapshot_context *context = cond_data;\n\tstruct action_data *action;\n\tu64 track_val;\n\n\tif (!track_data)\n\t\treturn false;\n\n\taction = track_data->action_data;\n\n\ttrack_val = get_track_val(track_data->hist_data, context->elt,\n\t\t\t\t  track_data->action_data);\n\n\tif (!action->track_data.check_val(track_data->track_val, track_val))\n\t\treturn false;\n\n\ttrack_data->track_val = track_val;\n\tmemcpy(track_data->key, context->key, track_data->key_len);\n\n\telt_data = context->elt->private_data;\n\ttrack_elt_data = track_data->elt.private_data;\n\tif (elt_data->comm)\n\t\tstrncpy(track_elt_data->comm, elt_data->comm, TASK_COMM_LEN);\n\n\ttrack_data->updated = true;\n\n\treturn true;\n}\n\nstatic void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct snapshot_context context;\n\n\tcontext.elt = elt;\n\tcontext.key = key;\n\n\ttracing_snapshot_cond(file->tr, &context);\n}\n\nstatic void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt);\n\nstatic struct action_data *snapshot_action(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tif (!hist_data->n_actions)\n\t\treturn NULL;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}\n\nstatic void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct track_data *track_data;\n\tstruct action_data *action;\n\n\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\tif (!track_data)\n\t\treturn;\n\n\tif (!track_data->updated)\n\t\treturn;\n\n\taction = snapshot_action(hist_data);\n\tif (!action)\n\t\treturn;\n\n\tseq_puts(m, \"\\nSnapshot taken (see tracing/snapshot).  Details:\\n\");\n\tseq_printf(m, \"\\ttriggering value { %s(%s) }: %10llu\",\n\t\t   action->handler == HANDLER_ONMAX ? \"onmax\" : \"onchange\",\n\t\t   action->track_data.var_str, track_data->track_val);\n\n\tseq_puts(m, \"\\ttriggered by event with key: \");\n\thist_trigger_print_key(m, hist_data, track_data->key, &track_data->elt);\n\tseq_putc(m, '\\n');\n}\n#else\nstatic bool cond_snapshot_update(struct trace_array *tr, void *cond_data)\n{\n\treturn false;\n}\nstatic void save_track_data_snapshot(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct tracing_map_elt *elt,\n\t\t\t\t     struct trace_buffer *buffer, void *rec,\n\t\t\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t\t\t     struct action_data *data,\n\t\t\t\t     u64 *var_ref_vals) {}\nstatic void track_data_snapshot_print(struct seq_file *m,\n\t\t\t\t      struct hist_trigger_data *hist_data) {}\n#endif  \n\nstatic void track_data_print(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct action_data *data)\n{\n\tu64 track_val = get_track_val(hist_data, elt, data);\n\tunsigned int i, save_var_idx;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_printf(m, \"\\n\\tmax: %10llu\", track_val);\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_printf(m, \"\\n\\tchanged: %10llu\", track_val);\n\n\tif (data->action == ACTION_SNAPSHOT)\n\t\treturn;\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->save_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->save_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}\n\nstatic void ontrack_action(struct hist_trigger_data *hist_data,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct trace_buffer *buffer, void *rec,\n\t\t\t   struct ring_buffer_event *rbe, void *key,\n\t\t\t   struct action_data *data, u64 *var_ref_vals)\n{\n\tu64 var_val = var_ref_vals[data->track_data.var_ref->var_ref_idx];\n\n\tif (check_track_val(elt, data, var_val)) {\n\t\tsave_track_val(hist_data, elt, data, var_val);\n\t\tsave_track_data(hist_data, elt, buffer, rec, rbe,\n\t\t\t\tkey, data, var_ref_vals);\n\t}\n}\n\nstatic void action_data_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tkfree(data->action_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->synth_event)\n\t\tdata->synth_event->ref--;\n\n\tkfree(data->synth_event_name);\n\n\tkfree(data);\n}\n\nstatic void track_data_destroy(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\n\tdestroy_hist_field(data->track_data.track_var, 0);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\tstruct track_data *track_data;\n\n\t\ttrack_data = tracing_cond_snapshot_data(file->tr);\n\t\tif (track_data && track_data->hist_data == hist_data) {\n\t\t\ttracing_snapshot_cond_disable(file->tr);\n\t\t\ttrack_data_free(track_data);\n\t\t}\n\t}\n\n\tkfree(data->track_data.var_str);\n\n\taction_data_destroy(data);\n}\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data);\n\nstatic int track_data_create(struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tstruct hist_field *var_field, *ref_field, *track_var = NULL;\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tchar *track_data_var_str;\n\tint ret = 0;\n\n\ttrack_data_var_str = data->track_data.var_str;\n\tif (track_data_var_str[0] != '$') {\n\t\thist_err(tr, HIST_ERR_ONX_NOT_VAR, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\ttrack_data_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, track_data_var_str);\n\tif (!var_field) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_NOT_FOUND, errpos(track_data_var_str));\n\t\treturn -EINVAL;\n\t}\n\n\tref_field = create_var_ref(hist_data, var_field, NULL, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tdata->track_data.var_ref = ref_field;\n\n\tif (data->handler == HANDLER_ONMAX)\n\t\ttrack_var = create_var(hist_data, file, \"__max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONCHANGE)\n\t\ttrack_var = create_var(hist_data, file, \"__change\", sizeof(u64), \"u64\");\n\tif (IS_ERR(track_var)) {\n\t\thist_err(tr, HIST_ERR_ONX_VAR_CREATE_FAIL, 0);\n\t\tret = PTR_ERR(track_var);\n\t\tgoto out;\n\t}\n\tdata->track_data.track_var = track_var;\n\n\tret = action_create(hist_data, data);\n out:\n\treturn ret;\n}\n\nstatic int parse_action_params(struct trace_array *tr, char *params,\n\t\t\t       struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tbool first_param = true;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(tr, HIST_ERR_INVALID_PARAM, errpos(param));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (first_param && data->use_trace_keyword) {\n\t\t\tdata->synth_event_name = saved_param;\n\t\t\tfirst_param = false;\n\t\t\tcontinue;\n\t\t}\n\t\tfirst_param = false;\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}\n\nstatic int action_parse(struct trace_array *tr, char *str, struct action_data *data,\n\t\t\tenum handler_id handler)\n{\n\tchar *action_name;\n\tint ret = 0;\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taction_name = strsep(&str, \"(\");\n\tif (!action_name || !str) {\n\t\thist_err(tr, HIST_ERR_ACTION_NOT_FOUND, 0);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (str_has_prefix(action_name, \"save\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\thist_err(tr, HIST_ERR_NO_SAVE_PARAMS, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = parse_action_params(tr, params, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_vars;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SAVE;\n\t} else if (str_has_prefix(action_name, \"snapshot\")) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!str) {\n\t\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(params));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\t\telse {\n\t\t\thist_err(tr, HIST_ERR_ACTION_MISMATCH, errpos(action_name));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->track_data.save_data = save_track_data_snapshot;\n\t\tdata->fn = ontrack_action;\n\t\tdata->action = ACTION_SNAPSHOT;\n\t} else {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (str_has_prefix(action_name, \"trace\"))\n\t\t\tdata->use_trace_keyword = true;\n\n\t\tif (params) {\n\t\t\tret = parse_action_params(tr, params, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (handler == HANDLER_ONMAX)\n\t\t\tdata->track_data.check_val = check_track_val_max;\n\t\telse if (handler == HANDLER_ONCHANGE)\n\t\t\tdata->track_data.check_val = check_track_val_changed;\n\n\t\tif (handler != HANDLER_ONMATCH) {\n\t\t\tdata->track_data.save_data = action_trace;\n\t\t\tdata->fn = ontrack_action;\n\t\t} else\n\t\t\tdata->fn = action_trace;\n\n\t\tdata->action = ACTION_TRACE;\n\t}\n\n\tdata->action_name = kstrdup(action_name, GFP_KERNEL);\n\tif (!data->action_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdata->handler = handler;\n out:\n\treturn ret;\n}\n\nstatic struct action_data *track_data_parse(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    char *str, enum handler_id handler)\n{\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\tchar *var_str;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvar_str = strsep(&str, \")\");\n\tif (!var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->track_data.var_str = kstrdup(var_str, GFP_KERNEL);\n\tif (!data->track_data.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(hist_data->event_file->tr, str, data, handler);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\ttrack_data_destroy(hist_data, data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tkfree(data->match_data.event);\n\tkfree(data->match_data.event_system);\n\n\taction_data_destroy(data);\n}\n\nstatic void destroy_field_var(struct field_var *field_var)\n{\n\tif (!field_var)\n\t\treturn;\n\n\tdestroy_hist_field(field_var->var, 0);\n\tdestroy_hist_field(field_var->val, 0);\n\n\tkfree(field_var);\n}\n\nstatic void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++)\n\t\tdestroy_field_var(hist_data->save_vars[i]);\n}\n\nstatic void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\t \n\tif (field_var->val->flags & (HIST_FIELD_FL_STRING | HIST_FIELD_FL_STACKTRACE))\n\t\thist_data->n_field_var_str++;\n}\n\n\nstatic int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\t \n\tif (strstr(hist_field->type, \"char[\") && field->is_string\n\t    && field->is_dynamic)\n\t\treturn 0;\n\n\tif (strstr(hist_field->type, \"long[\") && field->is_stack)\n\t\treturn 0;\n\n\tif (strcmp(field->type, hist_field->type) != 0) {\n\t\tif (field->size != hist_field->size ||\n\t\t    (!field->is_string && field->is_signed != hist_field->is_signed))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct hist_field *\ntrace_action_find_var(struct hist_trigger_data *hist_data,\n\t\t      struct action_data *data,\n\t\t      char *system, char *event, char *var)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field;\n\n\tvar++;  \n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err(tr, HIST_ERR_PARAM_NOT_FOUND, errpos(var));\n\n\treturn hist_field;\n}\n\nstatic struct hist_field *\ntrace_action_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data, char *system,\n\t\t\t      char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t \n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t \n\t\tif (!system && data->handler == HANDLER_ONMATCH) {\n\t\t\tsystem = data->match_data.event_system;\n\t\t\tevent = data->match_data.event;\n\t\t}\n\n\t\tif (!event)\n\t\t\tgoto free;\n\t\t \n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}\n\nstatic int trace_action_create(struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tchar *synth_event_name;\n\tint var_ref_idx, ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\t \n\tif (data->n_params > SYNTH_FIELDS_MAX)\n\t\treturn -EINVAL;\n\n\tif (data->use_trace_keyword)\n\t\tsynth_event_name = data->synth_event_name;\n\telse\n\t\tsynth_event_name = data->action_name;\n\n\tevent = find_synth_event(synth_event_name);\n\tif (!event) {\n\t\thist_err(tr, HIST_ERR_SYNTH_EVENT_NOT_FOUND, errpos(synth_event_name));\n\t\treturn -EINVAL;\n\t}\n\n\tevent->ref++;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = trace_action_find_var(hist_data, data,\n\t\t\t\t\t\t\t   system, event_name,\n\t\t\t\t\t\t\t   param);\n\t\telse\n\t\t\thist_field = trace_action_create_field_var(hist_data,\n\t\t\t\t\t\t\t\t   data,\n\t\t\t\t\t\t\t\t   system,\n\t\t\t\t\t\t\t\t   event_name,\n\t\t\t\t\t\t\t\t   param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_data, hist_field,\n\t\t\t\t\t\t system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tvar_ref_idx = find_var_ref_idx(hist_data, var_ref);\n\t\t\tif (WARN_ON(var_ref_idx < 0)) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = var_ref_idx;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdata->var_ref_idx[i] = var_ref_idx;\n\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err(tr, HIST_ERR_SYNTH_TYPE_MISMATCH, errpos(param));\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(tr, HIST_ERR_SYNTH_COUNT_MISMATCH, errpos(event->name));\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->synth_event = event;\n out:\n\treturn ret;\n err:\n\tevent->ref--;\n\n\tgoto out;\n}\n\nstatic int action_create(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct trace_array *tr = file->tr;\n\tstruct track_data *track_data;\n\tstruct field_var *field_var;\n\tunsigned int i;\n\tchar *param;\n\tint ret = 0;\n\n\tif (data->action == ACTION_TRACE)\n\t\treturn trace_action_create(hist_data, data);\n\n\tif (data->action == ACTION_SNAPSHOT) {\n\t\ttrack_data = track_data_alloc(hist_data->key_size, data, hist_data);\n\t\tif (IS_ERR(track_data)) {\n\t\t\tret = PTR_ERR(track_data);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = tracing_snapshot_cond_enable(file->tr, track_data,\n\t\t\t\t\t\t   cond_snapshot_update);\n\t\tif (ret)\n\t\t\ttrack_data_free(track_data);\n\n\t\tgoto out;\n\t}\n\n\tif (data->action == ACTION_SAVE) {\n\t\tif (hist_data->n_save_vars) {\n\t\t\tret = -EEXIST;\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SAVE_ACTIONS, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\t\tif (!param) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\t\tif (IS_ERR(field_var)) {\n\t\t\t\thist_err(tr, HIST_ERR_FIELD_VAR_CREATE_FAIL,\n\t\t\t\t\t errpos(param));\n\t\t\t\tret = PTR_ERR(field_var);\n\t\t\t\tkfree(param);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thist_data->save_vars[hist_data->n_save_vars++] = field_var;\n\t\t\tif (field_var->val->flags &\n\t\t\t    (HIST_FIELD_FL_STRING | HIST_FIELD_FL_STACKTRACE))\n\t\t\t\thist_data->n_save_var_str++;\n\t\t\tkfree(param);\n\t\t}\n\t}\n out:\n\treturn ret;\n}\n\nstatic int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct action_data *data)\n{\n\treturn action_create(hist_data, data);\n}\n\nstatic struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(tr, HIST_ERR_NO_CLOSING_PAREN, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(tr, HIST_ERR_SUBSYS_NOT_FOUND, errpos(match_event_system));\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err(tr, HIST_ERR_INVALID_SUBSYS_EVENT, errpos(match_event));\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->match_data.event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->match_data.event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->match_data.event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tret = action_parse(tr, str, data, HANDLER_ONMATCH);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}\n\nstatic int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0, n_subexprs = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, &n_subexprs);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\t \n\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t \n\t\tif (hist_field->flags & (HIST_FIELD_FL_GRAPH | HIST_FIELD_FL_PERCENT |\n\t\t\t\t\t HIST_FIELD_FL_BUCKET | HIST_FIELD_FL_LOG2))\n\t\t\tgoto err;\n\t} else {\n\t\t \n\t\tif (hist_field->flags & (HIST_FIELD_FL_GRAPH | HIST_FIELD_FL_PERCENT |\n\t\t\t\t\t HIST_FIELD_FL_BUCKET | HIST_FIELD_FL_LOG2 |\n\t\t\t\t\t HIST_FIELD_FL_SYM | HIST_FIELD_FL_SYM_OFFSET |\n\t\t\t\t\t HIST_FIELD_FL_SYSCALL | HIST_FIELD_FL_STACKTRACE))\n\t\t\tgoto err;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n err:\n\thist_err(file->tr, HIST_ERR_BAD_FIELD_MODIFIER, errpos(field_str));\n\treturn -EINVAL;\n}\n\nstatic int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}\n\nstatic const char no_comm[] = \"(no comm)\";\n\nstatic u64 hist_field_execname(struct hist_field *hist_field,\n\t\t\t       struct tracing_map_elt *elt,\n\t\t\t       struct trace_buffer *buffer,\n\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t       void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\n\tif (WARN_ON_ONCE(!elt))\n\t\treturn (u64)(unsigned long)no_comm;\n\n\telt_data = elt->private_data;\n\n\tif (WARN_ON_ONCE(!elt_data->comm))\n\t\treturn (u64)(unsigned long)no_comm;\n\n\treturn (u64)(unsigned long)(elt_data->comm);\n}\n\nstatic u64 hist_field_stack(struct hist_field *hist_field,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct trace_buffer *buffer,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *event)\n{\n\tu32 str_item = *(u32 *)(event + hist_field->field->offset);\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)(event + str_loc);\n\n\treturn (u64)(unsigned long)addr;\n}\n\nstatic u64 hist_fn_call(struct hist_field *hist_field,\n\t\t\tstruct tracing_map_elt *elt,\n\t\t\tstruct trace_buffer *buffer,\n\t\t\tstruct ring_buffer_event *rbe,\n\t\t\tvoid *event)\n{\n\tswitch (hist_field->fn_num) {\n\tcase HIST_FIELD_FN_VAR_REF:\n\t\treturn hist_field_var_ref(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_COUNTER:\n\t\treturn hist_field_counter(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_CONST:\n\t\treturn hist_field_const(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_LOG2:\n\t\treturn hist_field_log2(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_BUCKET:\n\t\treturn hist_field_bucket(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_TIMESTAMP:\n\t\treturn hist_field_timestamp(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_CPU:\n\t\treturn hist_field_cpu(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_STRING:\n\t\treturn hist_field_string(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_DYNSTRING:\n\t\treturn hist_field_dynstring(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_RELDYNSTRING:\n\t\treturn hist_field_reldynstring(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_PSTRING:\n\t\treturn hist_field_pstring(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_S64:\n\t\treturn hist_field_s64(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_U64:\n\t\treturn hist_field_u64(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_S32:\n\t\treturn hist_field_s32(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_U32:\n\t\treturn hist_field_u32(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_S16:\n\t\treturn hist_field_s16(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_U16:\n\t\treturn hist_field_u16(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_S8:\n\t\treturn hist_field_s8(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_U8:\n\t\treturn hist_field_u8(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_UMINUS:\n\t\treturn hist_field_unary_minus(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_MINUS:\n\t\treturn hist_field_minus(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_PLUS:\n\t\treturn hist_field_plus(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_DIV:\n\t\treturn hist_field_div(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_MULT:\n\t\treturn hist_field_mult(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_DIV_POWER2:\n\t\treturn div_by_power_of_two(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_DIV_NOT_POWER2:\n\t\treturn div_by_not_power_of_two(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_DIV_MULT_SHIFT:\n\t\treturn div_by_mult_and_shift(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_EXECNAME:\n\t\treturn hist_field_execname(hist_field, elt, buffer, rbe, event);\n\tcase HIST_FIELD_FN_STACK:\n\t\treturn hist_field_stack(hist_field, elt, buffer, rbe, event);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic void update_var_execname(struct hist_field *hist_field)\n{\n\thist_field->flags = HIST_FIELD_FL_STRING | HIST_FIELD_FL_VAR |\n\t\tHIST_FIELD_FL_EXECNAME;\n\thist_field->size = MAX_FILTER_STR_VAL;\n\thist_field->is_signed = 0;\n\n\tkfree_const(hist_field->type);\n\thist_field->type = \"char[]\";\n\n\thist_field->fn_num = HIST_FIELD_FN_EXECNAME;\n}\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(tr, HIST_ERR_DUPLICATE_VAR, errpos(var_name));\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tret = __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n\n\tif (!ret && hist_data->fields[val_idx]->flags & HIST_FIELD_FL_EXECNAME)\n\t\tupdate_var_execname(hist_data->fields[val_idx]);\n\n\tif (!ret && hist_data->fields[val_idx]->flags &\n\t    (HIST_FIELD_FL_STRING | HIST_FIELD_FL_STACKTRACE))\n\t\thist_data->fields[val_idx]->var_str_idx = hist_data->n_var_str++;\n\n\treturn ret;\n}\n\nstatic int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = 1, n_hitcount = 0;\n\tchar *fields_str, *field_str;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0) {\n\t\t\tif (!n_hitcount++)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\t \n\tif (j == 1 && hist_data->attrs->no_hitcount) {\n\t\thist_err(hist_data->event_file->tr, HIST_ERR_NEED_NOHC_VAL, 0);\n\t\tret = -ENOENT;\n\t}\n\n\treturn ret;\n}\n\nstatic int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0, n_subexprs = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, &n_subexprs);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (field_has_hist_vars(hist_field, 0))\t{\n\t\t\thist_err(tr, HIST_ERR_INVALID_REF_KEY, errpos(field_str));\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}\n\nstatic int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}\n\nstatic int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}\n\nstatic int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(tr, HIST_ERR_MALFORMED_ASSIGNMENT,\n\t\t\t\t\t errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(tr, HIST_ERR_TOO_MANY_VARS, errpos(var_name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tkfree(hist_data->attrs->var_defs.name[n_vars]);\n\t\t\t\thist_data->attrs->var_defs.name[n_vars] = NULL;\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}\n\nstatic int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}\n\nstatic int is_descending(struct trace_array *tr, const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\thist_err(tr, HIST_ERR_INVALID_SORT_MODIFIER, errpos((char *)str));\n\n\treturn -EINVAL;\n}\n\nstatic int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1;  \n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (!*field_str) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\thist_err(tr, HIST_ERR_TOO_MANY_SORT_FIELDS, errpos(\"sort=\"));\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name || !*field_name) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_EMPTY_SORT_FIELD, errpos(\"sort=\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(tr, field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(tr, field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\thist_err(tr, HIST_ERR_INVALID_SORT_FIELD, errpos(field_name));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}\n\nstatic void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_destroy(hist_data, data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}\n\nstatic int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\tint len;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif ((len = str_has_prefix(str, \"onmatch(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onmax(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONMAX);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((len = str_has_prefix(str, \"onchange(\"))) {\n\t\t\tchar *action_str = str + len;\n\n\t\t\tdata = track_data_parse(hist_data, action_str,\n\t\t\t\t\t\tHANDLER_ONCHANGE);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}\n\nstatic int create_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tret = onmatch_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tret = track_data_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->action == ACTION_SNAPSHOT)\n\t\t\tcontinue;\n\n\t\tif (data->handler == HANDLER_ONMAX ||\n\t\t    data->handler == HANDLER_ONCHANGE)\n\t\t\ttrack_data_print(m, hist_data, elt, data);\n\t}\n}\n\nstatic void print_action_spec(struct seq_file *m,\n\t\t\t      struct hist_trigger_data *hist_data,\n\t\t\t      struct action_data *data)\n{\n\tunsigned int i;\n\n\tif (data->action == ACTION_SAVE) {\n\t\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\t\tseq_printf(m, \"%s\", hist_data->save_vars[i]->var->var.name);\n\t\t\tif (i < hist_data->n_save_vars - 1)\n\t\t\t\tseq_puts(m, \",\");\n\t\t}\n\t} else if (data->action == ACTION_TRACE) {\n\t\tif (data->use_trace_keyword)\n\t\t\tseq_printf(m, \"%s\", data->synth_event_name);\n\t\tfor (i = 0; i < data->n_params; i++) {\n\t\t\tif (i || data->use_trace_keyword)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\tseq_printf(m, \"%s\", data->params[i]);\n\t\t}\n\t}\n}\n\nstatic void print_track_data_spec(struct seq_file *m,\n\t\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t\t  struct action_data *data)\n{\n\tif (data->handler == HANDLER_ONMAX)\n\t\tseq_puts(m, \":onmax(\");\n\telse if (data->handler == HANDLER_ONCHANGE)\n\t\tseq_puts(m, \":onchange(\");\n\tseq_printf(m, \"%s\", data->track_data.var_str);\n\tseq_printf(m, \").%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}\n\nstatic void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tseq_printf(m, \":onmatch(%s.%s).\", data->match_data.event_system,\n\t\t   data->match_data.event);\n\n\tseq_printf(m, \"%s(\", data->action_name);\n\n\tprint_action_spec(m, hist_data, data);\n\n\tseq_puts(m, \")\");\n}\n\nstatic bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\t\tchar *action_name, *action_name_test;\n\n\t\tif (data->handler != data_test->handler)\n\t\t\treturn false;\n\t\tif (data->action != data_test->action)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->use_trace_keyword)\n\t\t\taction_name = data->synth_event_name;\n\t\telse\n\t\t\taction_name = data->action_name;\n\n\t\tif (data_test->use_trace_keyword)\n\t\t\taction_name_test = data_test->synth_event_name;\n\t\telse\n\t\t\taction_name_test = data_test->action_name;\n\n\t\tif (strcmp(action_name, action_name_test) != 0)\n\t\t\treturn false;\n\n\t\tif (data->handler == HANDLER_ONMATCH) {\n\t\t\tif (strcmp(data->match_data.event_system,\n\t\t\t\t   data_test->match_data.event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->match_data.event,\n\t\t\t\t   data_test->match_data.event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->handler == HANDLER_ONMAX ||\n\t\t\t   data->handler == HANDLER_ONCHANGE) {\n\t\t\tif (strcmp(data->track_data.var_str,\n\t\t\t\t   data_test->track_data.var_str) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nstatic void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->handler == HANDLER_ONMATCH)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->handler == HANDLER_ONMAX ||\n\t\t\t data->handler == HANDLER_ONCHANGE)\n\t\t\tprint_track_data_spec(m, hist_data, data);\n\t}\n}\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\n\tkfree(hist_data);\n}\n\nstatic int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field || hist_field->flags & HIST_FIELD_FL_CPU)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}\n\nstatic void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt,\n\t\t\t\t    struct trace_buffer *buffer, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_fn_call(hist_field, elt, buffer, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\n\t\t\tif (hist_field->flags &\n\t\t\t    (HIST_FIELD_FL_STRING | HIST_FIELD_FL_STACKTRACE)) {\n\t\t\t\tunsigned int str_start, var_str_idx, idx;\n\t\t\t\tchar *str, *val_str;\n\t\t\t\tunsigned int size;\n\n\t\t\t\tstr_start = hist_data->n_field_var_str +\n\t\t\t\t\thist_data->n_save_var_str;\n\t\t\t\tvar_str_idx = hist_field->var_str_idx;\n\t\t\t\tidx = str_start + var_str_idx;\n\n\t\t\t\tstr = elt_data->field_var_str[idx];\n\t\t\t\tval_str = (char *)(uintptr_t)hist_val;\n\n\t\t\t\tif (hist_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\t\tsize = min(hist_field->size, STR_VAR_LEN_MAX);\n\t\t\t\t\tstrscpy(str, val_str, size);\n\t\t\t\t} else {\n\t\t\t\t\tchar *stack_start = str + sizeof(unsigned long);\n\t\t\t\t\tint e;\n\n\t\t\t\t\te = stack_trace_save((void *)stack_start,\n\t\t\t\t\t\t\t     HIST_STACKTRACE_DEPTH,\n\t\t\t\t\t\t\t     HIST_STACKTRACE_SKIP);\n\t\t\t\t\tif (e < HIST_STACKTRACE_DEPTH - 1)\n\t\t\t\t\t\t((unsigned long *)stack_start)[e] = 0;\n\t\t\t\t\t*((unsigned long *)str) = e;\n\t\t\t\t}\n\t\t\t\thist_val = (u64)(uintptr_t)str;\n\t\t\t}\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_fn_call(hist_field, elt, buffer, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, buffer, rbe, rec);\n}\n\nstatic inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t \n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\n\t\tstrncpy(compound_key + key_field->offset, (char *)key, size);\n\t} else\n\t\tmemcpy(compound_key + key_field->offset, key, size);\n}\n\nstatic void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt,\n\t\t     struct trace_buffer *buffer, void *rec,\n\t\t     struct ring_buffer_event *rbe, void *key,\n\t\t     u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, buffer, rec, rbe, key, data, var_ref_vals);\n\t}\n}\n\nstatic void event_hist_trigger(struct event_trigger_data *data,\n\t\t\t       struct trace_buffer *buffer, void *rec,\n\t\t\t       struct ring_buffer_event *rbe)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tbool use_compound_key = (hist_data->n_keys > 1);\n\tunsigned long entries[HIST_STACKTRACE_DEPTH];\n\tu64 var_ref_vals[TRACING_MAP_VARS_MAX];\n\tchar compound_key[HIST_KEY_SIZE_MAX];\n\tstruct tracing_map_elt *elt = NULL;\n\tstruct hist_field *key_field;\n\tu64 field_contents;\n\tvoid *key = NULL;\n\tunsigned int i;\n\n\tif (unlikely(!rbe))\n\t\treturn;\n\n\tmemset(compound_key, 0, hist_data->key_size);\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tmemset(entries, 0, HIST_STACKTRACE_SIZE);\n\t\t\tif (key_field->field) {\n\t\t\t\tunsigned long *stack, n_entries;\n\n\t\t\t\tfield_contents = hist_fn_call(key_field, elt, buffer, rbe, rec);\n\t\t\t\tstack = (unsigned long *)(long)field_contents;\n\t\t\t\tn_entries = *stack;\n\t\t\t\tmemcpy(entries, ++stack, n_entries * sizeof(unsigned long));\n\t\t\t} else {\n\t\t\t\tstack_trace_save(entries, HIST_STACKTRACE_DEPTH,\n\t\t\t\t\t\t HIST_STACKTRACE_SKIP);\n\t\t\t}\n\t\t\tkey = entries;\n\t\t} else {\n\t\t\tfield_contents = hist_fn_call(key_field, elt, buffer, rbe, rec);\n\t\t\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tkey = (void *)(unsigned long)field_contents;\n\t\t\t\tuse_compound_key = true;\n\t\t\t} else\n\t\t\t\tkey = (void *)&field_contents;\n\t\t}\n\n\t\tif (use_compound_key)\n\t\t\tadd_to_key(compound_key, key, key_field, rec);\n\t}\n\n\tif (use_compound_key)\n\t\tkey = compound_key;\n\n\tif (hist_data->n_var_refs &&\n\t    !resolve_var_refs(hist_data, key, var_ref_vals, false))\n\t\treturn;\n\n\telt = tracing_map_insert(hist_data->map, key);\n\tif (!elt)\n\t\treturn;\n\n\thist_trigger_elt_update(hist_data, elt, buffer, rec, rbe, var_ref_vals);\n\n\tif (resolve_var_refs(hist_data, key, var_ref_vals, true))\n\t\thist_trigger_actions(hist_data, elt, buffer, rec, rbe, key, var_ref_vals);\n}\n\nstatic void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (!stacktrace_entries[i])\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tseq_printf(m, \"%pS\\n\", (void*)stacktrace_entries[i]);\n\t}\n}\n\nstatic void hist_trigger_print_key(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data,\n\t\t\t\t   void *key,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45ps\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55pS\", field_name,\n\t\t\t\t   uval, (void *)(uintptr_t)uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tif (key_field->field)\n\t\t\t\tseq_printf(m, \"%s.stacktrace\", key_field->field->name);\n\t\t\telse\n\t\t\t\tseq_puts(m, \"common_stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_BUCKET) {\n\t\t\tunsigned long buckets = key_field->buckets;\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: ~ %llu-%llu\", field_name,\n\t\t\t\t   uval, uval + buckets -1);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n}\n\n \nstatic inline unsigned int __get_percentage(u64 val, u64 total)\n{\n\tif (!total)\n\t\tgoto div0;\n\n\tif (val < (U64_MAX / 10000))\n\t\treturn (unsigned int)div64_ul(val * 10000, total);\n\n\ttotal = div64_u64(total, 10000);\n\tif (!total)\n\t\tgoto div0;\n\n\treturn (unsigned int)div64_ul(val, total);\ndiv0:\n\treturn val ? UINT_MAX : 0;\n}\n\n#define BAR_CHAR '#'\n\nstatic inline const char *__fill_bar_str(char *buf, int size, u64 val, u64 max)\n{\n\tunsigned int len = __get_percentage(val, max);\n\tint i;\n\n\tif (len == UINT_MAX) {\n\t\tsnprintf(buf, size, \"[ERROR]\");\n\t\treturn buf;\n\t}\n\n\tlen = len * size / 10000;\n\tfor (i = 0; i < len && i < size; i++)\n\t\tbuf[i] = BAR_CHAR;\n\twhile (i < size)\n\t\tbuf[i++] = ' ';\n\tbuf[size] = '\\0';\n\n\treturn buf;\n}\n\nstruct hist_val_stat {\n\tu64 max;\n\tu64 total;\n};\n\nstatic void hist_trigger_print_val(struct seq_file *m, unsigned int idx,\n\t\t\t\t   const char *field_name, unsigned long flags,\n\t\t\t\t   struct hist_val_stat *stats,\n\t\t\t\t   struct tracing_map_elt *elt)\n{\n\tu64 val = tracing_map_read_sum(elt, idx);\n\tunsigned int pc;\n\tchar bar[21];\n\n\tif (flags & HIST_FIELD_FL_PERCENT) {\n\t\tpc = __get_percentage(val, stats[idx].total);\n\t\tif (pc == UINT_MAX)\n\t\t\tseq_printf(m, \" %s (%%):[ERROR]\", field_name);\n\t\telse\n\t\t\tseq_printf(m, \" %s (%%): %3u.%02u\", field_name,\n\t\t\t\t\tpc / 100, pc % 100);\n\t} else if (flags & HIST_FIELD_FL_GRAPH) {\n\t\tseq_printf(m, \" %s: %20s\", field_name,\n\t\t\t   __fill_bar_str(bar, 20, val, stats[idx].max));\n\t} else if (flags & HIST_FIELD_FL_HEX) {\n\t\tseq_printf(m, \" %s: %10llx\", field_name, val);\n\t} else {\n\t\tseq_printf(m, \" %s: %10llu\", field_name, val);\n\t}\n}\n\nstatic void hist_trigger_entry_print(struct seq_file *m,\n\t\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t\t     struct hist_val_stat *stats,\n\t\t\t\t     void *key,\n\t\t\t\t     struct tracing_map_elt *elt)\n{\n\tconst char *field_name;\n\tunsigned int i = HITCOUNT_IDX;\n\tunsigned long flags;\n\n\thist_trigger_print_key(m, hist_data, key, elt);\n\n\t \n\tif (!hist_data->attrs->no_hitcount)\n\t\thist_trigger_print_val(m, i, \"hitcount\", 0, stats, elt);\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\t\tflags = hist_data->fields[i]->flags;\n\t\tif (flags & HIST_FIELD_FL_VAR || flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tseq_puts(m, \" \");\n\t\thist_trigger_print_val(m, i, field_name, flags, stats, elt);\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}\n\nstatic int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, j, n_entries;\n\tstruct hist_val_stat *stats = NULL;\n\tu64 val;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\t \n\tfor (j = 0; j < hist_data->n_vals; j++) {\n\t\tif (!(hist_data->fields[j]->flags &\n\t\t\t(HIST_FIELD_FL_PERCENT | HIST_FIELD_FL_GRAPH)))\n\t\t\tcontinue;\n\t\tif (!stats) {\n\t\t\tstats = kcalloc(hist_data->n_vals, sizeof(*stats),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!stats) {\n\t\t\t\tn_entries = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < n_entries; i++) {\n\t\t\tval = tracing_map_read_sum(sort_entries[i]->elt, j);\n\t\t\tstats[j].total += val;\n\t\t\tif (stats[j].max < val)\n\t\t\t\tstats[j].max = val;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data, stats,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\tkfree(stats);\nout:\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}\n\nstatic void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\ttrack_data_snapshot_print(m, hist_data);\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}\n\nstatic int hist_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_show(m, data, n++);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\n\nstatic int event_hist_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = tracing_open_file_tr(inode, file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfile->private_data = NULL;\n\treturn single_open(file, hist_show, file);\n}\n\nconst struct file_operations event_hist_fops = {\n\t.open = event_hist_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = tracing_single_release_file_tr,\n};\n\n#ifdef CONFIG_HIST_TRIGGERS_DEBUG\nstatic void hist_field_debug_show_flags(struct seq_file *m,\n\t\t\t\t\tunsigned long flags)\n{\n\tseq_puts(m, \"      flags:\\n\");\n\n\tif (flags & HIST_FIELD_FL_KEY)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_KEY\\n\");\n\telse if (flags & HIST_FIELD_FL_HITCOUNT)\n\t\tseq_puts(m, \"        VAL: HIST_FIELD_FL_HITCOUNT\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR\\n\");\n\telse if (flags & HIST_FIELD_FL_VAR_REF)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_VAR_REF\\n\");\n\telse\n\t\tseq_puts(m, \"        VAL: normal u64 value\\n\");\n\n\tif (flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_ALIAS\\n\");\n\telse if (flags & HIST_FIELD_FL_CONST)\n\t\tseq_puts(m, \"        HIST_FIELD_FL_CONST\\n\");\n}\n\nstatic int hist_field_debug_show(struct seq_file *m,\n\t\t\t\t struct hist_field *field, unsigned long flags)\n{\n\tif ((field->flags & flags) != flags) {\n\t\tseq_printf(m, \"ERROR: bad flags - %lx\\n\", flags);\n\t\treturn -EINVAL;\n\t}\n\n\thist_field_debug_show_flags(m, field->flags);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\n\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t}\n\n\tif (field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"      constant: %llu\\n\", field->constant);\n\n\tif (field->flags & HIST_FIELD_FL_ALIAS)\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\n\tif (field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tseq_printf(m, \"      name: %s\\n\", field->name);\n\t\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t\t   field->var.idx);\n\t\tseq_printf(m, \"      var.hist_data: %p\\n\", field->var.hist_data);\n\t\tseq_printf(m, \"      var_ref_idx (into hist_data->var_refs[]): %u\\n\",\n\t\t\t   field->var_ref_idx);\n\t\tif (field->system)\n\t\t\tseq_printf(m, \"      system: %s\\n\", field->system);\n\t\tif (field->event_name)\n\t\t\tseq_printf(m, \"      event_name: %s\\n\", field->event_name);\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\n\n\treturn 0;\n}\n\nstatic int field_var_debug_show(struct seq_file *m,\n\t\t\t\tstruct field_var *field_var, unsigned int i,\n\t\t\t\tbool save_vars)\n{\n\tconst char *vars_name = save_vars ? \"save_vars\" : \"field_vars\";\n\tstruct hist_field *field;\n\tint ret = 0;\n\n\tseq_printf(m, \"\\n    hist_data->%s[%d]:\\n\", vars_name, i);\n\n\tfield = field_var->var;\n\n\tseq_printf(m, \"\\n      %s[%d].var:\\n\", vars_name, i);\n\n\thist_field_debug_show_flags(m, field->flags);\n\tseq_printf(m, \"      var.name: %s\\n\", field->var.name);\n\tseq_printf(m, \"      var.idx (into tracing_map_elt.vars[]): %u\\n\",\n\t\t   field->var.idx);\n\n\tfield = field_var->val;\n\n\tseq_printf(m, \"\\n      %s[%d].val:\\n\", vars_name, i);\n\tif (field->field)\n\t\tseq_printf(m, \"      ftrace_event_field name: %s\\n\",\n\t\t\t   field->field->name);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tseq_printf(m, \"      type: %s\\n\", field->type);\n\tseq_printf(m, \"      size: %u\\n\", field->size);\n\tseq_printf(m, \"      is_signed: %u\\n\", field->is_signed);\nout:\n\treturn ret;\n}\n\nstatic int hist_action_debug_show(struct seq_file *m,\n\t\t\t\t  struct action_data *data, int i)\n{\n\tint ret = 0;\n\n\tif (data->handler == HANDLER_ONMAX ||\n\t    data->handler == HANDLER_ONCHANGE) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.var_ref:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.var_ref,\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].track_data.track_var:\\n\", i);\n\t\tret = hist_field_debug_show(m, data->track_data.track_var,\n\t\t\t\t\t    HIST_FIELD_FL_VAR);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (data->handler == HANDLER_ONMATCH) {\n\t\tseq_printf(m, \"\\n    hist_data->actions[%d].match_data.event_system: %s\\n\",\n\t\t\t   i, data->match_data.event_system);\n\t\tseq_printf(m, \"    hist_data->actions[%d].match_data.event: %s\\n\",\n\t\t\t   i, data->match_data.event);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int hist_actions_debug_show(struct seq_file *m,\n\t\t\t\t   struct hist_trigger_data *hist_data)\n{\n\tint i, ret = 0;\n\n\tif (hist_data->n_actions)\n\t\tseq_puts(m, \"\\n  action tracking variables (for onmax()/onchange()/onmatch()):\\n\");\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *action = hist_data->actions[i];\n\n\t\tret = hist_action_debug_show(m, action, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->n_save_vars)\n\t\tseq_puts(m, \"\\n  save action variables (save() params):\\n\");\n\n\tfor (i = 0; i < hist_data->n_save_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->save_vars[i], i, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}\n\nstatic void hist_trigger_debug_show(struct seq_file *m,\n\t\t\t\t    struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint i, ret;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\n\tseq_printf(m, \"hist_data: %p\\n\\n\", hist_data);\n\tseq_printf(m, \"  n_vals: %u\\n\", hist_data->n_vals);\n\tseq_printf(m, \"  n_keys: %u\\n\", hist_data->n_keys);\n\tseq_printf(m, \"  n_fields: %u\\n\", hist_data->n_fields);\n\n\tseq_puts(m, \"\\n  val fields:\\n\\n\");\n\n\tseq_puts(m, \"    hist_data->fields[0]:\\n\");\n\tret = hist_field_debug_show(m, hist_data->fields[0],\n\t\t\t\t    HIST_FIELD_FL_HITCOUNT);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i], 0);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tseq_puts(m, \"\\n  key fields:\\n\");\n\n\tfor (i = hist_data->n_vals; i < hist_data->n_fields; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->fields[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->fields[i],\n\t\t\t\t\t    HIST_FIELD_FL_KEY);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_var_refs)\n\t\tseq_puts(m, \"\\n  variable reference fields:\\n\");\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\tseq_printf(m, \"\\n    hist_data->var_refs[%d]:\\n\", i);\n\t\tret = hist_field_debug_show(m, hist_data->var_refs[i],\n\t\t\t\t\t    HIST_FIELD_FL_VAR_REF);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tif (hist_data->n_field_vars)\n\t\tseq_puts(m, \"\\n  field variables:\\n\");\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++) {\n\t\tret = field_var_debug_show(m, hist_data->field_vars[i], i, false);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\tret = hist_actions_debug_show(m, hist_data);\n\tif (ret)\n\t\treturn;\n}\n\nstatic int hist_debug_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_debug_show(m, data, n++);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\n\nstatic int event_hist_debug_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = tracing_open_file_tr(inode, file);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfile->private_data = NULL;\n\treturn single_open(file, hist_debug_show, file);\n}\n\nconst struct file_operations event_hist_debug_fops = {\n\t.open = event_hist_debug_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = tracing_single_release_file_tr,\n};\n#endif\n\nstatic void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"common_cpu\");\n\telse if (hist_field->flags & HIST_FIELD_FL_CONST)\n\t\tseq_printf(m, \"%llu\", hist_field->constant);\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_STACKTRACE)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n\tif (hist_field->buckets)\n\t\tseq_printf(m, \"=%ld\", hist_field->buckets);\n}\n\nstatic int event_hist_trigger_print(struct seq_file *m,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct hist_field *field;\n\tbool have_var = false;\n\tbool show_val = false;\n\tunsigned int i;\n\n\tseq_puts(m, HIST_PREFIX);\n\n\tif (data->name)\n\t\tseq_printf(m, \"%s:\", data->name);\n\n\tseq_puts(m, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tif (field->field)\n\t\t\t\tseq_printf(m, \"%s.stacktrace\", field->field->name);\n\t\t\telse\n\t\t\t\tseq_puts(m, \"common_stacktrace\");\n\t\t} else\n\t\t\thist_field_print(m, field);\n\t}\n\n\tseq_puts(m, \":vals=\");\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thave_var = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == HITCOUNT_IDX) {\n\t\t\tif (hist_data->attrs->no_hitcount)\n\t\t\t\tcontinue;\n\t\t\tseq_puts(m, \"hitcount\");\n\t\t} else {\n\t\t\tif (show_val)\n\t\t\t\tseq_puts(m, \",\");\n\t\t\thist_field_print(m, field);\n\t\t}\n\t\tshow_val = true;\n\t}\n\n\tif (have_var) {\n\t\tunsigned int n = 0;\n\n\t\tseq_puts(m, \":\");\n\n\t\tfor_each_hist_val_field(i, hist_data) {\n\t\t\tfield = hist_data->fields[i];\n\n\t\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\t\tif (n++)\n\t\t\t\t\tseq_puts(m, \",\");\n\t\t\t\thist_field_print(m, field);\n\t\t\t}\n\t\t}\n\t}\n\n\tseq_puts(m, \":sort=\");\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tstruct tracing_map_sort_key *sort_key;\n\t\tunsigned int idx, first_key_idx;\n\n\t\t \n\t\tfirst_key_idx = hist_data->n_vals - hist_data->n_vars;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tidx = sort_key->field_idx;\n\n\t\tif (WARN_ON(idx >= HIST_FIELDS_MAX))\n\t\t\treturn -EINVAL;\n\n\t\tif (i > 0)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (idx == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tif (idx >= first_key_idx)\n\t\t\t\tidx += hist_data->n_vars;\n\t\t\thist_field_print(m, hist_data->fields[idx]);\n\t\t}\n\n\t\tif (sort_key->descending)\n\t\t\tseq_puts(m, \".descending\");\n\t}\n\tseq_printf(m, \":size=%u\", (1 << hist_data->map->map_bits));\n\tif (hist_data->enable_timestamps)\n\t\tseq_printf(m, \":clock=%s\", hist_data->attrs->clock);\n\tif (hist_data->attrs->no_hitcount)\n\t\tseq_puts(m, \":nohitcount\");\n\n\tprint_actions_spec(m, hist_data);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\", data->filter_str);\n\n\tif (data->paused)\n\t\tseq_puts(m, \" [paused]\");\n\telse\n\t\tseq_puts(m, \" [active]\");\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic int event_hist_trigger_init(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}\n\nstatic void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_parse(&trigger_hist_cmd, file,\n\t\t\t\t\t       \"!hist\", \"hist\", cmd);\n\t\tWARN_ON_ONCE(ret < 0);\n\t}\n}\n\nstatic void event_hist_trigger_free(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}\n\nstatic struct event_trigger_ops event_hist_trigger_ops = {\n\t.trigger\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_init,\n\t.free\t\t\t= event_hist_trigger_free,\n};\n\nstatic int event_hist_trigger_named_init(struct event_trigger_data *data)\n{\n\tdata->ref++;\n\n\tsave_named_trigger(data->named_data->name, data);\n\n\tevent_hist_trigger_init(data->named_data);\n\n\treturn 0;\n}\n\nstatic void event_hist_trigger_named_free(struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tevent_hist_trigger_free(data->named_data);\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tdel_named_trigger(data);\n\t\ttrigger_data_free(data);\n\t}\n}\n\nstatic struct event_trigger_ops event_hist_trigger_named_ops = {\n\t.trigger\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_named_init,\n\t.free\t\t\t= event_hist_trigger_named_free,\n};\n\nstatic struct event_trigger_ops *event_hist_get_trigger_ops(char *cmd,\n\t\t\t\t\t\t\t    char *param)\n{\n\treturn &event_hist_trigger_ops;\n}\n\nstatic void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}\n\nstatic bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool existing_hist_update_only(char *glob,\n\t\t\t\t      struct event_trigger_data *data,\n\t\t\t\t      struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool updated = false;\n\n\tif (!hist_data->attrs->pause && !hist_data->attrs->cont &&\n\t    !hist_data->attrs->clear)\n\t\tgoto out;\n\n\tif (hist_data->attrs->name) {\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\t\tif (named_data) {\n\t\t\tif (!hist_trigger_match(data, named_data, named_data,\n\t\t\t\t\t\ttrue))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (hist_data->attrs->name && !named_data)\n\t\tgoto out;\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tif (hist_data->attrs->pause)\n\t\t\t\ttest->paused = true;\n\t\t\telse if (hist_data->attrs->cont)\n\t\t\t\ttest->paused = false;\n\t\t\telse if (hist_data->attrs->clear)\n\t\t\t\thist_clear(test);\n\t\t\tupdated = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\treturn updated;\n}\n\nstatic int hist_register_trigger(char *glob,\n\t\t\t\t struct event_trigger_data *data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\n\tif (hist_data->attrs->name) {\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\t\tif (named_data) {\n\t\t\tif (!hist_trigger_match(data, named_data, named_data,\n\t\t\t\t\t\ttrue)) {\n\t\t\t\thist_err(tr, HIST_ERR_NAMED_MISMATCH, errpos(hist_data->attrs->name));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hist_data->attrs->name && !named_data)\n\t\tgoto new;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\thist_err(tr, HIST_ERR_TRIGGER_EEXIST, 0);\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n new:\n\tif (hist_data->attrs->cont || hist_data->attrs->clear) {\n\t\thist_err(tr, HIST_ERR_TRIGGER_ENOENT_CLEAR, 0);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (hist_data->attrs->pause)\n\t\tdata->paused = true;\n\n\tif (named_data) {\n\t\tdata->private_data = named_data->private_data;\n\t\tset_named_trigger_data(data, named_data);\n\t\tdata->ops = &event_hist_trigger_named_ops;\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->enable_timestamps) {\n\t\tchar *clock = hist_data->attrs->clock;\n\n\t\tret = tracing_set_clock(file->tr, hist_data->attrs->clock);\n\t\tif (ret) {\n\t\t\thist_err(tr, HIST_ERR_SET_CLOCK_FAIL, errpos(clock));\n\t\t\tgoto out;\n\t\t}\n\n\t\ttracing_set_filter_buffering(file->tr, true);\n\t}\n\n\tif (named_data)\n\t\tdestroy_hist_data(hist_data);\n out:\n\treturn ret;\n}\n\nstatic int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}\n\nstatic bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}\n\nstatic bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void hist_unregister_trigger(char *glob,\n\t\t\t\t    struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test = NULL, *iter, *named_data = NULL;\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry(iter, &file->triggers, list) {\n\t\tif (iter->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, iter, named_data, false))\n\t\t\t\tcontinue;\n\t\t\ttest = iter;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (test && test->ops->free)\n\t\ttest->ops->free(test);\n\n\tif (hist_data->enable_timestamps) {\n\t\tif (!hist_data->remove || test)\n\t\t\ttracing_set_filter_buffering(file->tr, false);\n\t}\n}\n\nstatic bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void hist_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (hist_file_check_refs(file))\n\t\treturn;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\n\t\t\tse_name = trace_event_name(file->event_call);\n\t\t\tse = find_synth_event(se_name);\n\t\t\tif (se)\n\t\t\t\tse->ref--;\n\n\t\t\tupdate_cond_flag(file);\n\t\t\tif (hist_data->enable_timestamps)\n\t\t\t\ttracing_set_filter_buffering(file->tr, false);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test);\n\t\t}\n\t}\n}\n\nstatic int event_hist_trigger_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd,\n\t\t\t\t    char *param_and_filter)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct hist_trigger_data *hist_data;\n\tchar *param, *filter, *p, *start;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tif (WARN_ON(!glob))\n\t\treturn -EINVAL;\n\n\tif (glob[0]) {\n\t\thist_err_clear();\n\t\tlast_cmd_set(file, param_and_filter);\n\t}\n\n\tremove = event_trigger_check_remove(glob);\n\n\tif (event_trigger_empty_param(param_and_filter))\n\t\treturn -EINVAL;\n\n\t \n\tp = param = param_and_filter;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param_and_filter)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param_and_filter + strlen(param_and_filter) - (sizeof(\"if\") - 1) - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + sizeof(\"if\") - 1) != ' ' && *(p + sizeof(\"if\") - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (1);\n\n\tif (!p)\n\t\tfilter = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tfilter = strstrip(p);\n\t\tparam = strstrip(param);\n\t}\n\n\t \n\tstart = strstr(param, \".sym-offset\");\n\twhile (start) {\n\t\t*(start + 4) = 'X';\n\t\tstart = strstr(start + 11, \".sym-offset\");\n\t}\n\n\tattrs = parse_hist_trigger_attrs(file->tr, param);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_data = event_trigger_alloc(cmd_ops, cmd, param, hist_data);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tret = event_trigger_set_filter(cmd_ops, file, filter, trigger_data);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tevent_trigger_unregister(cmd_ops, file, glob+1, trigger_data);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tif (existing_hist_update_only(glob, trigger_data, file))\n\t\tgoto out_free;\n\n\tret = event_trigger_register(cmd_ops, file, glob, trigger_data);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tret = create_actions(hist_data);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tif (has_hist_vars(hist_data) || hist_data->n_var_refs) {\n\t\tret = save_hist_vars(hist_data);\n\t\tif (ret)\n\t\t\tgoto out_unreg;\n\t}\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n out:\n\tif (ret == 0 && glob[0])\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tevent_trigger_unregister(cmd_ops, file, glob+1, trigger_data);\n out_free:\n\tevent_trigger_reset_filter(cmd_ops, trigger_data);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}\n\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}\n\nstatic void\nhist_enable_trigger(struct event_trigger_data *data,\n\t\t    struct trace_buffer *buffer,  void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list,\n\t\t\t\tlockdep_is_held(&event_mutex)) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}\n\nstatic void\nhist_enable_count_trigger(struct event_trigger_data *data,\n\t\t\t  struct trace_buffer *buffer,  void *rec,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\thist_enable_trigger(data, buffer, rec, event);\n}\n\nstatic struct event_trigger_ops hist_enable_trigger_ops = {\n\t.trigger\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops hist_enable_count_trigger_ops = {\n\t.trigger\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops hist_disable_trigger_ops = {\n\t.trigger\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops hist_disable_count_trigger_ops = {\n\t.trigger\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nhist_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n\tenable = (strcmp(cmd, ENABLE_HIST_STR) == 0);\n\n\tif (enable)\n\t\tops = param ? &hist_enable_count_trigger_ops :\n\t\t\t&hist_enable_trigger_ops;\n\telse\n\t\tops = param ? &hist_disable_count_trigger_ops :\n\t\t\t&hist_disable_trigger_ops;\n\n\treturn ops;\n}\n\nstatic void hist_enable_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_HIST_ENABLE) {\n\t\t\tlist_del_rcu(&test->list);\n\t\t\tupdate_cond_flag(file);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test);\n\t\t}\n\t}\n}\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}\n\n__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}