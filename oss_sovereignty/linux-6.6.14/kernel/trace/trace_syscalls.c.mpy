{
  "module_name": "trace_syscalls.c",
  "hash_id": "f3317e4b0bd66e6abd86f4f833072ed8cddbc2effbb0f0c5c0f19af726dae59c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_syscalls.c",
  "human_readable_source": "\n#include <trace/syscall.h>\n#include <trace/events/syscalls.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\t \n#include <linux/ftrace.h>\n#include <linux/perf_event.h>\n#include <linux/xarray.h>\n#include <asm/syscall.h>\n\n#include \"trace_output.h\"\n#include \"trace.h\"\n\nstatic DEFINE_MUTEX(syscall_trace_lock);\n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data);\n\nstatic struct list_head *\nsyscall_get_enter_fields(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\treturn &entry->enter_fields;\n}\n\nextern struct syscall_metadata *__start_syscalls_metadata[];\nextern struct syscall_metadata *__stop_syscalls_metadata[];\n\nstatic DEFINE_XARRAY(syscalls_metadata_sparse);\nstatic struct syscall_metadata **syscalls_metadata;\n\n#ifndef ARCH_HAS_SYSCALL_MATCH_SYM_NAME\nstatic inline bool arch_syscall_match_sym_name(const char *sym, const char *name)\n{\n\t \n\treturn !strcmp(sym + 3, name + 3);\n}\n#endif\n\n#ifdef ARCH_TRACE_IGNORE_COMPAT_SYSCALLS\n \nstatic int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\tif (unlikely(arch_trace_is_compat_syscall(regs)))\n\t\treturn -1;\n\n\treturn syscall_get_nr(task, regs);\n}\n#else\nstatic inline int\ntrace_get_syscall_nr(struct task_struct *task, struct pt_regs *regs)\n{\n\treturn syscall_get_nr(task, regs);\n}\n#endif  \n\nstatic __init struct syscall_metadata *\nfind_syscall_meta(unsigned long syscall)\n{\n\tstruct syscall_metadata **start;\n\tstruct syscall_metadata **stop;\n\tchar str[KSYM_SYMBOL_LEN];\n\n\n\tstart = __start_syscalls_metadata;\n\tstop = __stop_syscalls_metadata;\n\tkallsyms_lookup(syscall, NULL, NULL, NULL, str);\n\n\tif (arch_syscall_match_sym_name(str, \"sys_ni_syscall\"))\n\t\treturn NULL;\n\n\tfor ( ; start < stop; start++) {\n\t\tif ((*start)->name && arch_syscall_match_sym_name(str, (*start)->name))\n\t\t\treturn *start;\n\t}\n\treturn NULL;\n}\n\nstatic struct syscall_metadata *syscall_nr_to_meta(int nr)\n{\n\tif (IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR))\n\t\treturn xa_load(&syscalls_metadata_sparse, (unsigned long)nr);\n\n\tif (!syscalls_metadata || nr >= NR_syscalls || nr < 0)\n\t\treturn NULL;\n\n\treturn syscalls_metadata[nr];\n}\n\nconst char *get_syscall_name(int syscall)\n{\n\tstruct syscall_metadata *entry;\n\n\tentry = syscall_nr_to_meta(syscall);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn entry->name;\n}\n\nstatic enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_enter *trace;\n\tstruct syscall_metadata *entry;\n\tint i, syscall;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry)\n\t\tgoto end;\n\n\tif (entry->enter_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto end;\n\t}\n\n\ttrace_seq_printf(s, \"%s(\", entry->name);\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\t \n\t\tif (tr && tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", entry->types[i]);\n\n\t\t \n\t\ttrace_seq_printf(s, \"%s: %lx%s\", entry->args[i],\n\t\t\t\t trace->args[i],\n\t\t\t\t i == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\n\ttrace_seq_putc(s, ')');\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t\nprint_syscall_exit(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_exit *trace;\n\tint syscall;\n\tstruct syscall_metadata *entry;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry) {\n\t\ttrace_seq_putc(s, '\\n');\n\t\tgoto out;\n\t}\n\n\tif (entry->exit_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\ttrace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,\n\t\t\t\ttrace->ret);\n\n out:\n\treturn trace_handle_return(s);\n}\n\n#define SYSCALL_FIELD(_type, _name) {\t\t\t\t\t\\\n\t.type = #_type, .name = #_name,\t\t\t\t\t\\\n\t.size = sizeof(_type), .align = __alignof__(_type),\t\t\\\n\t.is_signed = is_signed_type(_type), .filter_type = FILTER_OTHER }\n\nstatic int __init\n__set_enter_print_fmt(struct syscall_metadata *entry, char *buf, int len)\n{\n\tint i;\n\tint pos = 0;\n\n\t \n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s: 0x%%0%zulx%s\",\n\t\t\t\tentry->args[i], sizeof(unsigned long),\n\t\t\t\ti == entry->nb_args - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < entry->nb_args; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", ((unsigned long)(REC->%s))\", entry->args[i]);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t \n\treturn pos;\n}\n\nstatic int __init set_syscall_print_fmt(struct trace_event_call *call)\n{\n\tchar *print_fmt;\n\tint len;\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event != call) {\n\t\tcall->print_fmt = \"\\\"0x%lx\\\", REC->ret\";\n\t\treturn 0;\n\t}\n\n\t \n\tlen = __set_enter_print_fmt(entry, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t \n\t__set_enter_print_fmt(entry, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}\n\nstatic void __init free_syscall_print_fmt(struct trace_event_call *call)\n{\n\tstruct syscall_metadata *entry = call->data;\n\n\tif (entry->enter_event == call)\n\t\tkfree(call->print_fmt);\n}\n\nstatic int __init syscall_enter_define_fields(struct trace_event_call *call)\n{\n\tstruct syscall_trace_enter trace;\n\tstruct syscall_metadata *meta = call->data;\n\tint offset = offsetof(typeof(trace), args);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < meta->nb_args; i++) {\n\t\tret = trace_define_field(call, meta->types[i],\n\t\t\t\t\t meta->args[i], offset,\n\t\t\t\t\t sizeof(unsigned long), 0,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\t\toffset += sizeof(unsigned long);\n\t}\n\n\treturn ret;\n}\n\nstatic void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_enter *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct trace_event_buffer fbuffer;\n\tunsigned long args[6];\n\tint syscall_nr;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t \n\ttrace_file = rcu_dereference_sched(tr->enter_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tsize = sizeof(*entry) + sizeof(unsigned long) * sys_data->nb_args;\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(fbuffer.event);\n\tentry->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, args);\n\tmemcpy(entry->args, args, sizeof(unsigned long) * sys_data->nb_args);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}\n\nstatic void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_event_file *trace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct trace_event_buffer fbuffer;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\n\t \n\ttrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!trace_file)\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, sizeof(*entry));\n\tif (!entry)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(fbuffer.event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}\n\nstatic int reg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t   struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_enter)\n\t\tret = register_trace_sys_enter(ftrace_syscall_enter, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->enter_syscall_files[num], file);\n\t\ttr->sys_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}\n\nstatic void unreg_event_syscall_enter(struct trace_event_file *file,\n\t\t\t\t      struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_enter--;\n\tRCU_INIT_POINTER(tr->enter_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_enter)\n\t\tunregister_trace_sys_enter(ftrace_syscall_enter, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}\n\nstatic int reg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t  struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn -ENOSYS;\n\tmutex_lock(&syscall_trace_lock);\n\tif (!tr->sys_refcount_exit)\n\t\tret = register_trace_sys_exit(ftrace_syscall_exit, tr);\n\tif (!ret) {\n\t\trcu_assign_pointer(tr->exit_syscall_files[num], file);\n\t\ttr->sys_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}\n\nstatic void unreg_event_syscall_exit(struct trace_event_file *file,\n\t\t\t\t     struct trace_event_call *call)\n{\n\tstruct trace_array *tr = file->tr;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (WARN_ON_ONCE(num < 0 || num >= NR_syscalls))\n\t\treturn;\n\tmutex_lock(&syscall_trace_lock);\n\ttr->sys_refcount_exit--;\n\tRCU_INIT_POINTER(tr->exit_syscall_files[num], NULL);\n\tif (!tr->sys_refcount_exit)\n\t\tunregister_trace_sys_exit(ftrace_syscall_exit, tr);\n\tmutex_unlock(&syscall_trace_lock);\n}\n\nstatic int __init init_syscall_trace(struct trace_event_call *call)\n{\n\tint id;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\tif (num < 0 || num >= NR_syscalls) {\n\t\tpr_debug(\"syscall %s metadata not mapped, disabling ftrace event\\n\",\n\t\t\t\t((struct syscall_metadata *)call->data)->name);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (set_syscall_print_fmt(call) < 0)\n\t\treturn -ENOMEM;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}\n\nstatic struct trace_event_fields __refdata syscall_enter_fields_array[] = {\n\tSYSCALL_FIELD(int, __syscall_nr),\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = syscall_enter_define_fields },\n\t{}\n};\n\nstruct trace_event_functions enter_syscall_print_funcs = {\n\t.trace\t\t= print_syscall_enter,\n};\n\nstruct trace_event_functions exit_syscall_print_funcs = {\n\t.trace\t\t= print_syscall_exit,\n};\n\nstruct trace_event_class __refdata event_class_syscall_enter = {\n\t.system\t\t= \"syscalls\",\n\t.reg\t\t= syscall_enter_register,\n\t.fields_array\t= syscall_enter_fields_array,\n\t.get_fields\t= syscall_get_enter_fields,\n\t.raw_init\t= init_syscall_trace,\n};\n\nstruct trace_event_class __refdata event_class_syscall_exit = {\n\t.system\t\t= \"syscalls\",\n\t.reg\t\t= syscall_exit_register,\n\t.fields_array\t= (struct trace_event_fields[]){\n\t\tSYSCALL_FIELD(int, __syscall_nr),\n\t\tSYSCALL_FIELD(long, ret),\n\t\t{}\n\t},\n\t.fields\t\t= LIST_HEAD_INIT(event_class_syscall_exit.fields),\n\t.raw_init\t= init_syscall_trace,\n};\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}\n\nvoid __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\tvoid *ret;\n\n\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {\n\t\tsyscalls_metadata = kcalloc(NR_syscalls,\n\t\t\t\t\tsizeof(*syscalls_metadata),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!syscalls_metadata) {\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->syscall_nr = i;\n\n\t\tif (!IS_ENABLED(CONFIG_HAVE_SPARSE_SYSCALL_NR)) {\n\t\t\tsyscalls_metadata[i] = meta;\n\t\t} else {\n\t\t\tret = xa_store(&syscalls_metadata_sparse, i, meta,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tWARN(xa_is_err(ret),\n\t\t\t\t\"Syscall memory allocation failed\\n\");\n\t\t}\n\n\t}\n}\n\n#ifdef CONFIG_PERF_EVENTS\n\nstatic DECLARE_BITMAP(enabled_perf_enter_syscalls, NR_syscalls);\nstatic DECLARE_BITMAP(enabled_perf_exit_syscalls, NR_syscalls);\nstatic int sys_perf_refcount_enter;\nstatic int sys_perf_refcount_exit;\n\nstatic int perf_call_bpf_enter(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t       struct syscall_metadata *sys_data,\n\t\t\t       struct syscall_trace_enter *rec)\n{\n\tstruct syscall_tp_t {\n\t\tstruct trace_entry ent;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long args[SYSCALL_DEFINE_MAXARGS];\n\t} __aligned(8) param;\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(param.ent) < sizeof(void *));\n\n\t \n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tfor (i = 0; i < sys_data->nb_args; i++)\n\t\tparam.args[i] = rec->args[i];\n\treturn trace_call_bpf(call, &param);\n}\n\nstatic void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tunsigned long args[6];\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->enter_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t \n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, args);\n\tmemcpy(&rec->args, args, sizeof(unsigned long) * sys_data->nb_args);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_enter(sys_data->enter_event, regs, sys_data, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx,\n\t\t\t      sys_data->enter_event->event.type, 1, regs,\n\t\t\t      head, NULL);\n}\n\nstatic int perf_sysenter_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_enter)\n\t\tret = register_trace_sys_enter(perf_syscall_enter, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall entry trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_enter_syscalls);\n\t\tsys_perf_refcount_enter++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}\n\nstatic void perf_sysenter_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_enter--;\n\tclear_bit(num, enabled_perf_enter_syscalls);\n\tif (!sys_perf_refcount_enter)\n\t\tunregister_trace_sys_enter(perf_syscall_enter, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}\n\nstatic int perf_call_bpf_exit(struct trace_event_call *call, struct pt_regs *regs,\n\t\t\t      struct syscall_trace_exit *rec)\n{\n\tstruct syscall_tp_t {\n\t\tstruct trace_entry ent;\n\t\tunsigned long syscall_nr;\n\t\tunsigned long ret;\n\t} __aligned(8) param;\n\n\t \n\t*(struct pt_regs **)&param = regs;\n\tparam.syscall_nr = rec->nr;\n\tparam.ret = rec->ret;\n\treturn trace_call_bpf(call, &param);\n}\n\nstatic void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tbool valid_prog_array;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tvalid_prog_array = bpf_prog_array_valid(sys_data->exit_event);\n\tif (!valid_prog_array && hlist_empty(head))\n\t\treturn;\n\n\t \n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\n\tif ((valid_prog_array &&\n\t     !perf_call_bpf_exit(sys_data->exit_event, regs, rec)) ||\n\t    hlist_empty(head)) {\n\t\tperf_swevent_put_recursion_context(rctx);\n\t\treturn;\n\t}\n\n\tperf_trace_buf_submit(rec, size, rctx, sys_data->exit_event->event.type,\n\t\t\t      1, regs, head, NULL);\n}\n\nstatic int perf_sysexit_enable(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tif (!sys_perf_refcount_exit)\n\t\tret = register_trace_sys_exit(perf_syscall_exit, NULL);\n\tif (ret) {\n\t\tpr_info(\"event trace: Could not activate syscall exit trace point\");\n\t} else {\n\t\tset_bit(num, enabled_perf_exit_syscalls);\n\t\tsys_perf_refcount_exit++;\n\t}\n\tmutex_unlock(&syscall_trace_lock);\n\treturn ret;\n}\n\nstatic void perf_sysexit_disable(struct trace_event_call *call)\n{\n\tint num;\n\n\tnum = ((struct syscall_metadata *)call->data)->syscall_nr;\n\n\tmutex_lock(&syscall_trace_lock);\n\tsys_perf_refcount_exit--;\n\tclear_bit(num, enabled_perf_exit_syscalls);\n\tif (!sys_perf_refcount_exit)\n\t\tunregister_trace_sys_exit(perf_syscall_exit, NULL);\n\tmutex_unlock(&syscall_trace_lock);\n}\n\n#endif  \n\nstatic int syscall_enter_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_enter(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_enter(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysenter_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysenter_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic int syscall_exit_register(struct trace_event_call *event,\n\t\t\t\t enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn reg_event_syscall_exit(file, event);\n\tcase TRACE_REG_UNREGISTER:\n\t\tunreg_event_syscall_exit(file, event);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn perf_sysexit_enable(event);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tperf_sysexit_disable(event);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}