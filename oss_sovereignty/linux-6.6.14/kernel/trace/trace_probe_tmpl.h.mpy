{
  "module_name": "trace_probe_tmpl.h",
  "hash_id": "ea62e94f9db27712f9b2d0a91acfa12cccc95a159a7c70b798039343482a172a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_probe_tmpl.h",
  "human_readable_source": " \n \n\nstatic nokprobe_inline void\nfetch_store_raw(unsigned long val, struct fetch_insn *code, void *buf)\n{\n\tswitch (code->size) {\n\tcase 1:\n\t\t*(u8 *)buf = (u8)val;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf = (u16)val;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf = (u32)val;\n\t\tbreak;\n\tcase 8:\n\t\t\n\t\t*(u64 *)buf = (u64)val;\n\t\tbreak;\n\tdefault:\n\t\t*(unsigned long *)buf = val;\n\t}\n}\n\nstatic nokprobe_inline void\nfetch_apply_bitfield(struct fetch_insn *code, void *buf)\n{\n\tswitch (code->basesize) {\n\tcase 1:\n\t\t*(u8 *)buf <<= code->lshift;\n\t\t*(u8 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)buf <<= code->lshift;\n\t\t*(u16 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)buf <<= code->lshift;\n\t\t*(u32 *)buf >>= code->rshift;\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)buf <<= code->lshift;\n\t\t*(u64 *)buf >>= code->rshift;\n\t\tbreak;\n\t}\n}\n\n \nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec,\n\t\t   void *dest, void *base);\nstatic nokprobe_inline int fetch_store_strlen(unsigned long addr);\nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int fetch_store_strlen_user(unsigned long addr);\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base);\nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size);\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size);\n\nstatic nokprobe_inline int\nfetch_store_symstrlen(unsigned long addr)\n{\n\tchar namebuf[KSYM_SYMBOL_LEN];\n\tint ret;\n\n\tret = sprint_symbol(namebuf, addr);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn ret + 1;\n}\n\n \nstatic nokprobe_inline int\nfetch_store_symstring(unsigned long addr, void *dest, void *base)\n{\n\tint maxlen = get_loc_len(*(u32 *)dest);\n\tvoid *__dest;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\t__dest = get_loc_data(dest, base);\n\n\treturn sprint_symbol(__dest, addr);\n}\n\n \nstatic nokprobe_inline int\nprocess_common_fetch_insn(struct fetch_insn *code, unsigned long *val)\n{\n\tswitch (code->op) {\n\tcase FETCH_OP_IMM:\n\t\t*val = code->immediate;\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\t*val = (unsigned long)current->comm;\n\t\tbreak;\n\tcase FETCH_OP_DATA:\n\t\t*val = (unsigned long)code->data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\treturn 0;\n}\n\n \nstatic nokprobe_inline int\nprocess_fetch_insn_bottom(struct fetch_insn *code, unsigned long val,\n\t\t\t   void *dest, void *base)\n{\n\tstruct fetch_insn *s3 = NULL;\n\tint total = 0, ret = 0, i = 0;\n\tu32 loc = 0;\n\tunsigned long lval = val;\n\nstage2:\n\t \n\tdo {\n\t\tif (code->op == FETCH_OP_DEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read(&val, (void *)val + code->offset,\n\t\t\t\t\t     sizeof(val));\n\t\t} else if (code->op == FETCH_OP_UDEREF) {\n\t\t\tlval = val;\n\t\t\tret = probe_mem_read_user(&val,\n\t\t\t\t (void *)val + code->offset, sizeof(val));\n\t\t} else\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcode++;\n\t} while (1);\n\n\ts3 = code;\nstage3:\n\t \n\tif (unlikely(!dest)) {\n\t\tswitch (code->op) {\n\t\tcase FETCH_OP_ST_STRING:\n\t\t\tret = fetch_store_strlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\tcase FETCH_OP_ST_USTRING:\n\t\t\tret = fetch_store_strlen_user(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\tcase FETCH_OP_ST_SYMSTR:\n\t\t\tret = fetch_store_symstrlen(val + code->offset);\n\t\t\tcode++;\n\t\t\tgoto array;\n\t\tdefault:\n\t\t\treturn -EILSEQ;\n\t\t}\n\t}\n\n\tswitch (code->op) {\n\tcase FETCH_OP_ST_RAW:\n\t\tfetch_store_raw(val, code, dest);\n\t\tbreak;\n\tcase FETCH_OP_ST_MEM:\n\t\tprobe_mem_read(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_UMEM:\n\t\tprobe_mem_read_user(dest, (void *)val + code->offset, code->size);\n\t\tbreak;\n\tcase FETCH_OP_ST_STRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_USTRING:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_string_user(val + code->offset, dest, base);\n\t\tbreak;\n\tcase FETCH_OP_ST_SYMSTR:\n\t\tloc = *(u32 *)dest;\n\t\tret = fetch_store_symstring(val + code->offset, dest, base);\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\tcode++;\n\n\t \n\tif (code->op == FETCH_OP_MOD_BF) {\n\t\tfetch_apply_bitfield(code, dest);\n\t\tcode++;\n\t}\n\narray:\n\t \n\tif (code->op == FETCH_OP_LP_ARRAY) {\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t\ttotal += ret;\n\t\tif (++i < code->param) {\n\t\t\tcode = s3;\n\t\t\tif (s3->op != FETCH_OP_ST_STRING &&\n\t\t\t    s3->op != FETCH_OP_ST_USTRING) {\n\t\t\t\tdest += s3->size;\n\t\t\t\tval += s3->size;\n\t\t\t\tgoto stage3;\n\t\t\t}\n\t\t\tcode--;\n\t\t\tval = lval + sizeof(char *);\n\t\t\tif (dest) {\n\t\t\t\tdest += sizeof(u32);\n\t\t\t\t*(u32 *)dest = update_data_loc(loc, ret);\n\t\t\t}\n\t\t\tgoto stage2;\n\t\t}\n\t\tcode++;\n\t\tret = total;\n\t}\n\n\treturn code->op == FETCH_OP_END ? ret : -EILSEQ;\n}\n\n \nstatic nokprobe_inline int\n__get_data_size(struct trace_probe *tp, struct pt_regs *regs)\n{\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (unlikely(arg->dynamic)) {\n\t\t\tlen = process_fetch_insn(arg->code, regs, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic nokprobe_inline void\nstore_trace_args(void *data, struct trace_probe *tp, void *rec,\n\t\t int header_size, int maxlen)\n{\n\tstruct probe_arg *arg;\n\tvoid *base = data - header_size;\n\tvoid *dyndata = data + tp->size;\n\tu32 *dl;\t \n\tint ret, i;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tdl = data + arg->offset;\n\t\t \n\t\tif (unlikely(arg->dynamic))\n\t\t\t*dl = make_data_loc(maxlen, dyndata - base);\n\t\tret = process_fetch_insn(arg->code, rec, dl, base);\n\t\tif (arg->dynamic && likely(ret > 0)) {\n\t\t\tdyndata += ret;\n\t\t\tmaxlen -= ret;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}