{
  "module_name": "trace_btf.c",
  "hash_id": "e8965ef65506edbd32d22520d497b48951ca1b19c93c1cd0d3329687dbb1502e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_btf.c",
  "human_readable_source": "\n#include <linux/btf.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include \"trace_btf.h\"\n\n \nconst struct btf_type *btf_find_func_proto(const char *func_name, struct btf **btf_p)\n{\n\tconst struct btf_type *t;\n\ts32 id;\n\n\tid = bpf_find_btf_id(func_name, BTF_KIND_FUNC, btf_p);\n\tif (id < 0)\n\t\treturn NULL;\n\n\t \n\tt = btf_type_by_id(*btf_p, id);\n\tif (!t || !btf_type_is_func(t))\n\t\tgoto err;\n\n\t \n\tt = btf_type_by_id(*btf_p, t->type);\n\tif (!t || !btf_type_is_func_proto(t))\n\t\tgoto err;\n\n\treturn t;\nerr:\n\tbtf_put(*btf_p);\n\treturn NULL;\n}\n\n \nconst struct btf_param *btf_get_func_param(const struct btf_type *func_proto, s32 *nr)\n{\n\tif (!btf_type_is_func_proto(func_proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*nr = btf_type_vlen(func_proto);\n\tif (*nr > 0)\n\t\treturn (const struct btf_param *)(func_proto + 1);\n\telse\n\t\treturn NULL;\n}\n\n#define BTF_ANON_STACK_MAX\t16\n\nstruct btf_anon_stack {\n\tu32 tid;\n\tu32 offset;\n};\n\n \nconst struct btf_member *btf_find_struct_member(struct btf *btf,\n\t\t\t\t\t\tconst struct btf_type *type,\n\t\t\t\t\t\tconst char *member_name,\n\t\t\t\t\t\tu32 *anon_offset)\n{\n\tstruct btf_anon_stack *anon_stack;\n\tconst struct btf_member *member;\n\tu32 tid, cur_offset = 0;\n\tconst char *name;\n\tint i, top = 0;\n\n\tanon_stack = kcalloc(BTF_ANON_STACK_MAX, sizeof(*anon_stack), GFP_KERNEL);\n\tif (!anon_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\nretry:\n\tif (!btf_type_is_struct(type)) {\n\t\tmember = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tfor_each_member(i, type, member) {\n\t\tif (!member->name_off) {\n\t\t\t \n\t\t\ttype = btf_type_skip_modifiers(btf, member->type, &tid);\n\t\t\tif (type && top < BTF_ANON_STACK_MAX) {\n\t\t\t\tanon_stack[top].tid = tid;\n\t\t\t\tanon_stack[top++].offset =\n\t\t\t\t\tcur_offset + member->offset;\n\t\t\t}\n\t\t} else {\n\t\t\tname = btf_name_by_offset(btf, member->name_off);\n\t\t\tif (name && !strcmp(member_name, name)) {\n\t\t\t\tif (anon_offset)\n\t\t\t\t\t*anon_offset = cur_offset;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (top > 0) {\n\t\t \n\t\ttid = anon_stack[--top].tid;\n\t\tcur_offset = anon_stack[top].offset;\n\t\ttype = btf_type_by_id(btf, tid);\n\t\tgoto retry;\n\t}\n\tmember = NULL;\n\nout:\n\tkfree(anon_stack);\n\treturn member;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}