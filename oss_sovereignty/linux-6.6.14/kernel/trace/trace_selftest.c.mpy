{
  "module_name": "trace_selftest.c",
  "hash_id": "aab35eb29fbc23cfb4c2b4cb4012e532c6d1ce0421c263ac8871a7612f105634",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_selftest.c",
  "human_readable_source": "\n \n\n#include <uapi/linux/sched/types.h>\n#include <linux/stringify.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\nstatic inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int trace_test_buffer_cpu(struct array_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t \n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t \n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}\n\n \nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t \n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t \n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}\n#ifdef CONFIG_FUNCTION_TRACER\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\nstatic int trace_selftest_test_probe1_cnt;\nstatic void trace_selftest_test_probe1_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe1_cnt++;\n}\n\nstatic int trace_selftest_test_probe2_cnt;\nstatic void trace_selftest_test_probe2_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe2_cnt++;\n}\n\nstatic int trace_selftest_test_probe3_cnt;\nstatic void trace_selftest_test_probe3_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe3_cnt++;\n}\n\nstatic int trace_selftest_test_global_cnt;\nstatic void trace_selftest_test_global_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_global_cnt++;\n}\n\nstatic int trace_selftest_test_dyn_cnt;\nstatic void trace_selftest_test_dyn_func(unsigned long ip,\n\t\t\t\t\t unsigned long pip,\n\t\t\t\t\t struct ftrace_ops *op,\n\t\t\t\t\t struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_dyn_cnt++;\n}\n\nstatic struct ftrace_ops test_probe1 = {\n\t.func\t\t\t= trace_selftest_test_probe1_func,\n};\n\nstatic struct ftrace_ops test_probe2 = {\n\t.func\t\t\t= trace_selftest_test_probe2_func,\n};\n\nstatic struct ftrace_ops test_probe3 = {\n\t.func\t\t\t= trace_selftest_test_probe3_func,\n};\n\nstatic void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}\n\nstatic void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}\n\nstatic int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t \n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t \n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t \n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t \n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\t \n\tfunc1_name = \"!\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen1 = strlen(func1_name);\n\n\tftrace_set_filter(&test_probe3, func1_name, len1, 0);\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 5)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t \n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t \n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}\n\n \nstatic int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t \n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t \n\tftrace_enabled = 1;\n\n\t \n\tfunc();\n\n\t \n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t \n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t \n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t \n\tmsleep(100);\n\n\t \n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t \n\tfunc();\n\n\t \n\tmsleep(100);\n\n\t \n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t \n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t \n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t \n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t \n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}\n\nstatic int trace_selftest_recursion_cnt;\nstatic void trace_selftest_test_recursion_func(unsigned long ip,\n\t\t\t\t\t       unsigned long pip,\n\t\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t\t       struct ftrace_regs *fregs)\n{\n\t \n\tif (trace_selftest_recursion_cnt++ > 10)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}\n\nstatic void trace_selftest_test_recursion_safe_func(unsigned long ip,\n\t\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\t \n\tif (trace_selftest_recursion_cnt++)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}\n\nstatic struct ftrace_ops test_rec_probe = {\n\t.func\t\t\t= trace_selftest_test_recursion_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_RECURSION,\n};\n\nstatic struct ftrace_ops test_recsafe_probe = {\n\t.func\t\t\t= trace_selftest_test_recursion_safe_func,\n};\n\nstatic int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t \n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t \n\tftrace_enabled = 1;\n\n\t \n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\t \n\tif (trace_selftest_recursion_cnt != 1 &&\n\t    trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called once (or twice) (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}\n#else\n# define trace_selftest_startup_dynamic_tracing(trace, tr, func) ({ 0; })\n# define trace_selftest_function_recursion() ({ 0; })\n#endif  \n\nstatic enum {\n\tTRACE_SELFTEST_REGS_START,\n\tTRACE_SELFTEST_REGS_FOUND,\n\tTRACE_SELFTEST_REGS_NOT_FOUND,\n} trace_selftest_regs_stat;\n\nstatic void trace_selftest_test_regs_func(unsigned long ip,\n\t\t\t\t\t  unsigned long pip,\n\t\t\t\t\t  struct ftrace_ops *op,\n\t\t\t\t\t  struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\n\tif (regs)\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_FOUND;\n\telse\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_NOT_FOUND;\n}\n\nstatic struct ftrace_ops test_regs_probe = {\n\t.func\t\t= trace_selftest_test_regs_func,\n\t.flags\t\t= FTRACE_OPS_FL_SAVE_REGS,\n};\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t \n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t \n\tftrace_enabled = 1;\n\n\t \n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t \n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t \n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}\n\n \n__init int\ntrace_selftest_startup_function(struct tracer *trace, struct trace_array *tr)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t \n\tmsleep(1);\n\n\t \n\tftrace_enabled = 1;\n\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t \n\tmsleep(100);\n\t \n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t \n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = trace_selftest_startup_dynamic_tracing(trace, tr,\n\t\t\t\t\t\t     DYN_FTRACE_TEST_NAME);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_recursion();\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_regs();\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t \n\tif (ret)\n\t\tftrace_kill();\n\n\treturn ret;\n}\n#endif  \n\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\n \n#define GRAPH_MAX_FUNC_TEST\t100000000\n\nstatic unsigned int graph_hang_thresh;\n\n \nstatic int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t \n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t \n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}\n\nstatic struct fgraph_ops fgraph_ops __initdata  = {\n\t.entryfunc\t\t= &trace_graph_entry_watchdog,\n\t.retfunc\t\t= &trace_graph_return,\n};\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS\nstatic struct ftrace_ops direct;\n#endif\n\n \n__init int\ntrace_selftest_startup_function_graph(struct tracer *trace,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tint ret;\n\tunsigned long count;\n\tchar *func_name __maybe_unused;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t \n\ttracing_reset_online_cpus(&tr->array_buffer);\n\tset_graph_array(tr);\n\tret = register_ftrace_graph(&fgraph_ops);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\ttracing_start_cmdline_record();\n\n\t \n\tmsleep(100);\n\n\t \n\tif (graph_hang_thresh > GRAPH_MAX_FUNC_TEST) {\n\t\tdisable_tracing_selftest(\"recovering from a hang\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\ttracing_stop();\n\n\t \n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\t \n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph(&fgraph_ops);\n\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS\n\t \n\tcond_resched();\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\tset_graph_array(tr);\n\n\t \n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t \n\tftrace_set_filter_ip(&direct, (unsigned long)DYN_FTRACE_TEST_NAME, 0, 0);\n\tret = register_ftrace_direct(&direct,\n\t\t\t\t     (unsigned long)ftrace_stub_direct_tramp);\n\tif (ret)\n\t\tgoto out;\n\n\tcond_resched();\n\n\tret = register_ftrace_graph(&fgraph_ops);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tcount = 0;\n\n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tunregister_ftrace_graph(&fgraph_ops);\n\n\tret = unregister_ftrace_direct(&direct,\n\t\t\t\t       (unsigned long)ftrace_stub_direct_tramp,\n\t\t\t\t       true);\n\tif (ret)\n\t\tgoto out;\n\n\tcond_resched();\n\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tftrace_set_global_filter(NULL, 0, 1);\n#endif\n\n\t \nout:\n\t \n\tif (ret)\n\t\tftrace_graph_stop();\n\n\treturn ret;\n}\n#endif  \n\n\n#ifdef CONFIG_IRQSOFF_TRACER\nint\ntrace_selftest_startup_irqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t \n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t \n\ttr->max_latency = 0;\n\t \n\tlocal_irq_disable();\n\tudelay(100);\n\tlocal_irq_enable();\n\n\t \n\ttrace->stop(tr);\n\t \n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PREEMPT_TRACER\nint\ntrace_selftest_startup_preemptoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t \n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t \n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t \n\ttr->max_latency = 0;\n\t \n\tpreempt_disable();\n\tudelay(100);\n\tpreempt_enable();\n\n\t \n\ttrace->stop(tr);\n\t \n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}\n#endif  \n\n#if defined(CONFIG_IRQSOFF_TRACER) && defined(CONFIG_PREEMPT_TRACER)\nint\ntrace_selftest_startup_preemptirqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t \n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t \n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out_no_start;\n\t}\n\n\t \n\ttr->max_latency = 0;\n\n\t \n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t \n\tlocal_irq_enable();\n\n\t \n\ttrace->stop(tr);\n\t \n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\ttr->max_latency = 0;\n\ttracing_start();\n\ttrace->start(tr);\n\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t \n\tlocal_irq_enable();\n\n\ttrace->stop(tr);\n\t \n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\ttracing_start();\nout_no_start:\n\ttrace->reset(tr);\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_NOP_TRACER\nint\ntrace_selftest_startup_nop(struct tracer *trace, struct trace_array *tr)\n{\n\t \n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_SCHED_TRACER\n\nstruct wakeup_test_data {\n\tstruct completion\tis_ready;\n\tint\t\t\tgo;\n};\n\nstatic int trace_wakeup_test_thread(void *data)\n{\n\t \n\tstatic const struct sched_attr attr = {\n\t\t.sched_policy = SCHED_DEADLINE,\n\t\t.sched_runtime = 100000ULL,\n\t\t.sched_deadline = 10000000ULL,\n\t\t.sched_period = 10000000ULL\n\t};\n\tstruct wakeup_test_data *x = data;\n\n\tsched_setattr(current, &attr);\n\n\t \n\tcomplete(&x->is_ready);\n\n\t \n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!x->go) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\tcomplete(&x->is_ready);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t \n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}\nint\ntrace_selftest_startup_wakeup(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tstruct task_struct *p;\n\tstruct wakeup_test_data data;\n\tunsigned long count;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tinit_completion(&data.is_ready);\n\n\t \n\tp = kthread_run(trace_wakeup_test_thread, &data, \"ftrace-test\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_CONT \"Failed to create ftrace wakeup test thread \");\n\t\treturn -1;\n\t}\n\n\t \n\twait_for_completion(&data.is_ready);\n\n\t \n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t \n\ttr->max_latency = 0;\n\n\twhile (p->on_rq) {\n\t\t \n\t\tmsleep(100);\n\t}\n\n\tinit_completion(&data.is_ready);\n\n\tdata.go = 1;\n\t \n\n\twake_up_process(p);\n\n\t \n\twait_for_completion(&data.is_ready);\n\n\t \n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\ttr->max_latency = save_max;\n\n\t \n\tkthread_stop(p);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_BRANCH_TRACER\nint\ntrace_selftest_startup_branch(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long count;\n\tint ret;\n\n\t \n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(100);\n\t \n\ttracing_stop();\n\t \n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}