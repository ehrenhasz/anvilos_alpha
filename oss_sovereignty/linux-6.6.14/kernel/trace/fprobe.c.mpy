{
  "module_name": "fprobe.c",
  "hash_id": "7a13f4eedcb6d118ff64bc4b09a1ed4824164d5421b138bef014d568880bf25a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/fprobe.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"fprobe: \" fmt\n\n#include <linux/err.h>\n#include <linux/fprobe.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/rethook.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n#include \"trace.h\"\n\nstruct fprobe_rethook_node {\n\tstruct rethook_node node;\n\tunsigned long entry_ip;\n\tunsigned long entry_parent_ip;\n\tchar data[];\n};\n\nstatic inline void __fprobe_handler(unsigned long ip, unsigned long parent_ip,\n\t\t\tstruct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct fprobe_rethook_node *fpr;\n\tstruct rethook_node *rh = NULL;\n\tstruct fprobe *fp;\n\tvoid *entry_data = NULL;\n\tint ret = 0;\n\n\tfp = container_of(ops, struct fprobe, ops);\n\n\tif (fp->exit_handler) {\n\t\trh = rethook_try_get(fp->rethook);\n\t\tif (!rh) {\n\t\t\tfp->nmissed++;\n\t\t\treturn;\n\t\t}\n\t\tfpr = container_of(rh, struct fprobe_rethook_node, node);\n\t\tfpr->entry_ip = ip;\n\t\tfpr->entry_parent_ip = parent_ip;\n\t\tif (fp->entry_data_size)\n\t\t\tentry_data = fpr->data;\n\t}\n\n\tif (fp->entry_handler)\n\t\tret = fp->entry_handler(fp, ip, parent_ip, ftrace_get_regs(fregs), entry_data);\n\n\t \n\tif (rh) {\n\t\tif (ret)\n\t\t\trethook_recycle(rh);\n\t\telse\n\t\t\trethook_hook(rh, ftrace_get_regs(fregs), true);\n\t}\n}\n\nstatic void fprobe_handler(unsigned long ip, unsigned long parent_ip,\n\t\tstruct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct fprobe *fp;\n\tint bit;\n\n\tfp = container_of(ops, struct fprobe, ops);\n\tif (fprobe_disabled(fp))\n\t\treturn;\n\n\t \n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0) {\n\t\tfp->nmissed++;\n\t\treturn;\n\t}\n\t__fprobe_handler(ip, parent_ip, ops, fregs);\n\tftrace_test_recursion_unlock(bit);\n\n}\nNOKPROBE_SYMBOL(fprobe_handler);\n\nstatic void fprobe_kprobe_handler(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t  struct ftrace_ops *ops, struct ftrace_regs *fregs)\n{\n\tstruct fprobe *fp;\n\tint bit;\n\n\tfp = container_of(ops, struct fprobe, ops);\n\tif (fprobe_disabled(fp))\n\t\treturn;\n\n\t \n\tbit = ftrace_test_recursion_trylock(ip, parent_ip);\n\tif (bit < 0) {\n\t\tfp->nmissed++;\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(kprobe_running())) {\n\t\tfp->nmissed++;\n\t\tgoto recursion_unlock;\n\t}\n\n\tkprobe_busy_begin();\n\t__fprobe_handler(ip, parent_ip, ops, fregs);\n\tkprobe_busy_end();\n\nrecursion_unlock:\n\tftrace_test_recursion_unlock(bit);\n}\n\nstatic void fprobe_exit_handler(struct rethook_node *rh, void *data,\n\t\t\t\tunsigned long ret_ip, struct pt_regs *regs)\n{\n\tstruct fprobe *fp = (struct fprobe *)data;\n\tstruct fprobe_rethook_node *fpr;\n\tint bit;\n\n\tif (!fp || fprobe_disabled(fp))\n\t\treturn;\n\n\tfpr = container_of(rh, struct fprobe_rethook_node, node);\n\n\t \n\tbit = ftrace_test_recursion_trylock(fpr->entry_ip, fpr->entry_parent_ip);\n\tif (bit < 0) {\n\t\tfp->nmissed++;\n\t\treturn;\n\t}\n\n\tfp->exit_handler(fp, fpr->entry_ip, ret_ip, regs,\n\t\t\t fp->entry_data_size ? (void *)fpr->data : NULL);\n\tftrace_test_recursion_unlock(bit);\n}\nNOKPROBE_SYMBOL(fprobe_exit_handler);\n\nstatic int symbols_cmp(const void *a, const void *b)\n{\n\tconst char **str_a = (const char **) a;\n\tconst char **str_b = (const char **) b;\n\n\treturn strcmp(*str_a, *str_b);\n}\n\n \nstatic unsigned long *get_ftrace_locations(const char **syms, int num)\n{\n\tunsigned long *addrs;\n\n\t \n\taddrs = kcalloc(num, sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tsort(syms, num, sizeof(*syms), symbols_cmp, NULL);\n\n\tif (!ftrace_lookup_symbols(syms, num, addrs))\n\t\treturn addrs;\n\n\tkfree(addrs);\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic void fprobe_init(struct fprobe *fp)\n{\n\tfp->nmissed = 0;\n\tif (fprobe_shared_with_kprobes(fp))\n\t\tfp->ops.func = fprobe_kprobe_handler;\n\telse\n\t\tfp->ops.func = fprobe_handler;\n\tfp->ops.flags |= FTRACE_OPS_FL_SAVE_REGS;\n}\n\nstatic int fprobe_init_rethook(struct fprobe *fp, int num)\n{\n\tint i, size;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\n\tif (!fp->exit_handler) {\n\t\tfp->rethook = NULL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (fp->nr_maxactive)\n\t\tsize = fp->nr_maxactive;\n\telse\n\t\tsize = num * num_possible_cpus() * 2;\n\tif (size <= 0)\n\t\treturn -EINVAL;\n\n\tfp->rethook = rethook_alloc((void *)fp, fprobe_exit_handler);\n\tif (!fp->rethook)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < size; i++) {\n\t\tstruct fprobe_rethook_node *node;\n\n\t\tnode = kzalloc(sizeof(*node) + fp->entry_data_size, GFP_KERNEL);\n\t\tif (!node) {\n\t\t\trethook_free(fp->rethook);\n\t\t\tfp->rethook = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trethook_add_node(fp->rethook, &node->node);\n\t}\n\treturn 0;\n}\n\nstatic void fprobe_fail_cleanup(struct fprobe *fp)\n{\n\tif (fp->rethook) {\n\t\t \n\t\trethook_free(fp->rethook);\n\t\tfp->rethook = NULL;\n\t}\n\tftrace_free_filter(&fp->ops);\n}\n\n \nint register_fprobe(struct fprobe *fp, const char *filter, const char *notfilter)\n{\n\tstruct ftrace_hash *hash;\n\tunsigned char *str;\n\tint ret, len;\n\n\tif (!fp || !filter)\n\t\treturn -EINVAL;\n\n\tfprobe_init(fp);\n\n\tlen = strlen(filter);\n\tstr = kstrdup(filter, GFP_KERNEL);\n\tret = ftrace_set_filter(&fp->ops, str, len, 0);\n\tkfree(str);\n\tif (ret)\n\t\treturn ret;\n\n\tif (notfilter) {\n\t\tlen = strlen(notfilter);\n\t\tstr = kstrdup(notfilter, GFP_KERNEL);\n\t\tret = ftrace_set_notrace(&fp->ops, str, len, 0);\n\t\tkfree(str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\thash = rcu_access_pointer(fp->ops.local_hash.filter_hash);\n\tif (WARN_ON_ONCE(!hash))\n\t\tgoto out;\n\n\tret = fprobe_init_rethook(fp, (int)hash->count);\n\tif (!ret)\n\t\tret = register_ftrace_function(&fp->ops);\n\nout:\n\tif (ret)\n\t\tfprobe_fail_cleanup(fp);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_fprobe);\n\n \nint register_fprobe_ips(struct fprobe *fp, unsigned long *addrs, int num)\n{\n\tint ret;\n\n\tif (!fp || !addrs || num <= 0)\n\t\treturn -EINVAL;\n\n\tfprobe_init(fp);\n\n\tret = ftrace_set_filter_ips(&fp->ops, addrs, num, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fprobe_init_rethook(fp, num);\n\tif (!ret)\n\t\tret = register_ftrace_function(&fp->ops);\n\n\tif (ret)\n\t\tfprobe_fail_cleanup(fp);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_fprobe_ips);\n\n \nint register_fprobe_syms(struct fprobe *fp, const char **syms, int num)\n{\n\tunsigned long *addrs;\n\tint ret;\n\n\tif (!fp || !syms || num <= 0)\n\t\treturn -EINVAL;\n\n\taddrs = get_ftrace_locations(syms, num);\n\tif (IS_ERR(addrs))\n\t\treturn PTR_ERR(addrs);\n\n\tret = register_fprobe_ips(fp, addrs, num);\n\n\tkfree(addrs);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(register_fprobe_syms);\n\nbool fprobe_is_registered(struct fprobe *fp)\n{\n\tif (!fp || (fp->ops.saved_func != fprobe_handler &&\n\t\t    fp->ops.saved_func != fprobe_kprobe_handler))\n\t\treturn false;\n\treturn true;\n}\n\n \nint unregister_fprobe(struct fprobe *fp)\n{\n\tint ret;\n\n\tif (!fprobe_is_registered(fp))\n\t\treturn -EINVAL;\n\n\tif (fp->rethook)\n\t\trethook_stop(fp->rethook);\n\n\tret = unregister_ftrace_function(&fp->ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fp->rethook)\n\t\trethook_free(fp->rethook);\n\n\tftrace_free_filter(&fp->ops);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(unregister_fprobe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}