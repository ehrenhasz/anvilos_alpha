{
  "module_name": "trace_benchmark.c",
  "hash_id": "88d6c4792ea3d5db802932ccce5fa3add3c75b95b1cafe6dc1176112c8b68a24",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_benchmark.c",
  "human_readable_source": "\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/trace_clock.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace_benchmark.h\"\n\nstatic struct task_struct *bm_event_thread;\n\nstatic char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";\n\nstatic u64 bm_total;\nstatic u64 bm_totalsq;\nstatic u64 bm_last;\nstatic u64 bm_max;\nstatic u64 bm_min;\nstatic u64 bm_first;\nstatic u64 bm_cnt;\nstatic u64 bm_stddev;\nstatic unsigned int bm_avg;\nstatic unsigned int bm_std;\n\nstatic bool ok_to_run;\n\n \nstatic void trace_do_benchmark(void)\n{\n\tu64 start;\n\tu64 stop;\n\tu64 delta;\n\tu64 stddev;\n\tu64 seed;\n\tu64 last_seed;\n\tunsigned int avg;\n\tunsigned int std = 0;\n\n\t \n\tif (!trace_benchmark_event_enabled() || !tracing_is_on())\n\t\treturn;\n\n\tlocal_irq_disable();\n\tstart = trace_clock_local();\n\ttrace_benchmark_event(bm_str, bm_last);\n\tstop = trace_clock_local();\n\tlocal_irq_enable();\n\n\tbm_cnt++;\n\n\tdelta = stop - start;\n\n\t \n\tif (bm_cnt == 1) {\n\t\tbm_first = delta;\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t\t  \"first=%llu [COLD CACHED]\", bm_first);\n\t\treturn;\n\t}\n\n\tbm_last = delta;\n\n\tif (delta > bm_max)\n\t\tbm_max = delta;\n\tif (!bm_min || delta < bm_min)\n\t\tbm_min = delta;\n\n\t \n\tif (bm_cnt > UINT_MAX) {\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t    \"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\",\n\t\t\t  bm_last, bm_first, bm_max, bm_min, bm_avg, bm_std, bm_stddev);\n\t\treturn;\n\t}\n\n\tbm_total += delta;\n\tbm_totalsq += delta * delta;\n\n\n\tif (bm_cnt > 1) {\n\t\t \n\t\tstddev = (u64)bm_cnt * bm_totalsq - bm_total * bm_total;\n\t\tdo_div(stddev, (u32)bm_cnt);\n\t\tdo_div(stddev, (u32)bm_cnt - 1);\n\t} else\n\t\tstddev = 0;\n\n\tdelta = bm_total;\n\tdo_div(delta, bm_cnt);\n\tavg = delta;\n\n\tif (stddev > 0) {\n\t\tint i = 0;\n\t\t \n\t\tseed = avg;\n\t\tdo {\n\t\t\tlast_seed = seed;\n\t\t\tseed = stddev;\n\t\t\tif (!last_seed)\n\t\t\t\tbreak;\n\t\t\tdo_div(seed, last_seed);\n\t\t\tseed += last_seed;\n\t\t\tdo_div(seed, 2);\n\t\t} while (i++ < 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}\n\nstatic int benchmark_event_kthread(void *arg)\n{\n\t \n\tmsleep(100);\n\n\twhile (!kthread_should_stop()) {\n\n\t\ttrace_do_benchmark();\n\n\t\t \n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\n\treturn 0;\n}\n\n \nint trace_benchmark_reg(void)\n{\n\tif (!ok_to_run) {\n\t\tpr_warn(\"trace benchmark cannot be started via kernel command line\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbm_event_thread = kthread_run(benchmark_event_kthread,\n\t\t\t\t      NULL, \"event_benchmark\");\n\tif (IS_ERR(bm_event_thread)) {\n\t\tpr_warn(\"trace benchmark failed to create kernel thread\\n\");\n\t\treturn PTR_ERR(bm_event_thread);\n\t}\n\n\treturn 0;\n}\n\n \nvoid trace_benchmark_unreg(void)\n{\n\tif (!bm_event_thread)\n\t\treturn;\n\n\tkthread_stop(bm_event_thread);\n\tbm_event_thread = NULL;\n\n\tstrcpy(bm_str, \"START\");\n\tbm_total = 0;\n\tbm_totalsq = 0;\n\tbm_last = 0;\n\tbm_max = 0;\n\tbm_min = 0;\n\tbm_cnt = 0;\n\t \n\tbm_first = 0;\n\tbm_std = 0;\n\tbm_avg = 0;\n\tbm_stddev = 0;\n}\n\nstatic __init int ok_to_run_trace_benchmark(void)\n{\n\tok_to_run = true;\n\n\treturn 0;\n}\n\nearly_initcall(ok_to_run_trace_benchmark);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}