{
  "module_name": "trace_events_synth.c",
  "hash_id": "10ee58594ac7d7c4ed90a28224e0f40da1715e096ced6e4dc6dbef30911d8aa9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_events_synth.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/stacktrace.h>\n#include <linux/rculist.h>\n#include <linux/tracefs.h>\n\n \n#include <linux/trace_events.h>\n#include <trace/events/mmflags.h>\n#include \"trace_probe.h\"\n#include \"trace_probe_kernel.h\"\n\n#include \"trace_synth.h\"\n\n#undef ERRORS\n#define ERRORS\t\\\n\tC(BAD_NAME,\t\t\"Illegal name\"),\t\t\\\n\tC(INVALID_CMD,\t\t\"Command must be of the form: <name> field[;field] ...\"),\\\n\tC(INVALID_DYN_CMD,\t\"Command must be of the form: s or -:[synthetic/]<name> field[;field] ...\"),\\\n\tC(EVENT_EXISTS,\t\t\"Event already exists\"),\t\\\n\tC(TOO_MANY_FIELDS,\t\"Too many fields\"),\t\t\\\n\tC(INCOMPLETE_TYPE,\t\"Incomplete type\"),\t\t\\\n\tC(INVALID_TYPE,\t\t\"Invalid type\"),\t\t\\\n\tC(INVALID_FIELD,        \"Invalid field\"),\t\t\\\n\tC(INVALID_ARRAY_SPEC,\t\"Invalid array specification\"),\n\n#undef C\n#define C(a, b)\t\tSYNTH_ERR_##a\n\nenum { ERRORS };\n\n#undef C\n#define C(a, b)\t\tb\n\nstatic const char *err_text[] = { ERRORS };\n\nstatic DEFINE_MUTEX(lastcmd_mutex);\nstatic char *last_cmd;\n\nstatic int errpos(const char *str)\n{\n\tint ret = 0;\n\n\tmutex_lock(&lastcmd_mutex);\n\tif (!str || !last_cmd)\n\t\tgoto out;\n\n\tret = err_pos(last_cmd, str);\n out:\n\tmutex_unlock(&lastcmd_mutex);\n\treturn ret;\n}\n\nstatic void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tmutex_lock(&lastcmd_mutex);\n\tkfree(last_cmd);\n\tlast_cmd = kstrdup(str, GFP_KERNEL);\n\tmutex_unlock(&lastcmd_mutex);\n}\n\nstatic void synth_err(u8 err_type, u16 err_pos)\n{\n\tmutex_lock(&lastcmd_mutex);\n\tif (!last_cmd)\n\t\tgoto out;\n\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n out:\n\tmutex_unlock(&lastcmd_mutex);\n}\n\nstatic int create_synth_event(const char *raw_command);\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}\n\nstatic bool synth_event_is_busy(struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\n\treturn event->ref != 0;\n}\n\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct synth_event *sev = to_synth_event(ev);\n\n\treturn strcmp(sev->name, event) == 0 &&\n\t\t(!system || strcmp(system, SYNTH_SYSTEM) == 0);\n}\n\nstruct synth_trace_event {\n\tstruct trace_entry\tent;\n\tunion trace_synth_field\tfields[];\n};\n\nstatic int synth_event_define_fields(struct trace_event_call *call)\n{\n\tstruct synth_trace_event trace;\n\tint offset = offsetof(typeof(trace), fields);\n\tstruct synth_event *event = call->data;\n\tunsigned int i, size, n_u64;\n\tchar *name, *type;\n\tbool is_signed;\n\tint ret = 0;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tsize = event->fields[i]->size;\n\t\tis_signed = event->fields[i]->is_signed;\n\t\ttype = event->fields[i]->type;\n\t\tname = event->fields[i]->name;\n\t\tret = trace_define_field(call, type, name, offset, size,\n\t\t\t\t\t is_signed, FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tevent->fields[i]->offset = n_u64;\n\n\t\tif (event->fields[i]->is_string && !event->fields[i]->is_dynamic) {\n\t\t\toffset += STR_VAR_LEN_MAX;\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\toffset += sizeof(u64);\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\tevent->n_u64 = n_u64;\n\n\treturn ret;\n}\n\nstatic bool synth_field_signed(char *type)\n{\n\tif (str_has_prefix(type, \"u\"))\n\t\treturn false;\n\tif (strcmp(type, \"gfp_t\") == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int synth_field_is_stack(char *type)\n{\n\tif (strstr(type, \"long[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += sizeof(\"char[\") - 1;\n\n\tend = strchr(type, ']');\n\tif (!end || end < start || type + strlen(type) > end + 1)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tif (len == 0)\n\t\treturn 0;  \n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}\n\nstatic int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\telse if (synth_field_is_stack(type))\n\t\tsize = 0;\n\n\treturn size;\n}\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\telse if (synth_field_is_stack(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}\n\nstatic void print_synth_event_num_val(struct trace_seq *s,\n\t\t\t\t      char *print_fmt, char *name,\n\t\t\t\t      int size, union trace_synth_field *val, char *space)\n{\n\tswitch (size) {\n\tcase 1:\n\t\ttrace_seq_printf(s, print_fmt, name, val->as_u8, space);\n\t\tbreak;\n\n\tcase 2:\n\t\ttrace_seq_printf(s, print_fmt, name, val->as_u16, space);\n\t\tbreak;\n\n\tcase 4:\n\t\ttrace_seq_printf(s, print_fmt, name, val->as_u32, space);\n\t\tbreak;\n\n\tdefault:\n\t\ttrace_seq_printf(s, print_fmt, name, val->as_u64, space);\n\t\tbreak;\n\t}\n}\n\nstatic enum print_line_t print_synth_event(struct trace_iterator *iter,\n\t\t\t\t\t   int flags,\n\t\t\t\t\t   struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *se;\n\tunsigned int i, j, n_u64;\n\tchar print_fmt[32];\n\tconst char *fmt;\n\n\tentry = (struct synth_trace_event *)iter->ent;\n\tse = container_of(event, struct synth_event, call.event);\n\n\ttrace_seq_printf(s, \"%s: \", se->name);\n\n\tfor (i = 0, n_u64 = 0; i < se->n_fields; i++) {\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\tfmt = synth_field_fmt(se->fields[i]->type);\n\n\t\t \n\t\tif (tr && tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", fmt);\n\n\t\tsnprintf(print_fmt, sizeof(print_fmt), \"%%s=%s%%s\", fmt);\n\n\t\t \n\t\tif (se->fields[i]->is_string) {\n\t\t\tif (se->fields[i]->is_dynamic) {\n\t\t\t\tunion trace_synth_field *data = &entry->fields[n_u64];\n\n\t\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t\t STR_VAR_LEN_MAX,\n\t\t\t\t\t\t (char *)entry + data->as_dynamic.offset,\n\t\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\t\tn_u64++;\n\t\t\t} else {\n\t\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t\t STR_VAR_LEN_MAX,\n\t\t\t\t\t\t (char *)&entry->fields[n_u64].as_u64,\n\t\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t\t}\n\t\t} else if (se->fields[i]->is_stack) {\n\t\t\tunion trace_synth_field *data = &entry->fields[n_u64];\n\t\t\tunsigned long *p = (void *)entry + data->as_dynamic.offset;\n\n\t\t\ttrace_seq_printf(s, \"%s=STACK:\\n\", se->fields[i]->name);\n\t\t\tfor (j = 1; j < data->as_dynamic.len / sizeof(long); j++)\n\t\t\t\ttrace_seq_printf(s, \"=> %pS\\n\", (void *)p[j]);\n\t\t\tn_u64++;\n\t\t} else {\n\t\t\tstruct trace_print_flags __flags[] = {\n\t\t\t    __def_gfpflag_names, {-1, NULL} };\n\t\t\tchar *space = (i == se->n_fields - 1 ? \"\" : \" \");\n\n\t\t\tprint_synth_event_num_val(s, print_fmt,\n\t\t\t\t\t\t  se->fields[i]->name,\n\t\t\t\t\t\t  se->fields[i]->size,\n\t\t\t\t\t\t  &entry->fields[n_u64],\n\t\t\t\t\t\t  space);\n\n\t\t\tif (strcmp(se->fields[i]->type, \"gfp_t\") == 0) {\n\t\t\t\ttrace_seq_puts(s, \" (\");\n\t\t\t\ttrace_print_flags_seq(s, \"|\",\n\t\t\t\t\t\t      entry->fields[n_u64].as_u64,\n\t\t\t\t\t\t      __flags);\n\t\t\t\ttrace_seq_putc(s, ')');\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions synth_event_funcs = {\n\t.trace\t\t= print_synth_event\n};\n\nstatic unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\tint ret;\n\n\tif (is_dynamic) {\n\t\tunion trace_synth_field *data = &entry->fields[*n_u64];\n\n\t\tdata->as_dynamic.offset = struct_size(entry, fields, event->n_u64) + data_size;\n\t\tdata->as_dynamic.len = fetch_store_strlen((unsigned long)str_val);\n\n\t\tret = fetch_store_string((unsigned long)str_val, &entry->fields[*n_u64], entry);\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64].as_u64;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\t\tif ((unsigned long)str_val < TASK_SIZE)\n\t\t\tret = strncpy_from_user_nofault(str_field, (const void __user *)str_val, STR_VAR_LEN_MAX);\n\t\telse\n#endif\n\t\t\tret = strncpy_from_kernel_nofault(str_field, str_val, STR_VAR_LEN_MAX);\n\n\t\tif (ret < 0)\n\t\t\tstrcpy(str_field, FAULT_STRING);\n\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}\n\nstatic unsigned int trace_stack(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t long *stack,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunion trace_synth_field *data = &entry->fields[*n_u64];\n\tunsigned int len;\n\tu32 data_offset;\n\tvoid *data_loc;\n\n\tdata_offset = struct_size(entry, fields, event->n_u64);\n\tdata_offset += data_size;\n\n\tfor (len = 0; len < HIST_STACKTRACE_DEPTH; len++) {\n\t\tif (!stack[len])\n\t\t\tbreak;\n\t}\n\n\tlen *= sizeof(long);\n\n\t \n\tdata_loc = (void *)entry + data_offset;\n\tmemcpy(data_loc, stack, len);\n\n\t \n\n\tdata->as_dynamic.offset = data_offset;\n\tdata->as_dynamic.len = len;\n\n\t(*n_u64)++;\n\n\treturn len;\n}\n\nstatic notrace void trace_event_raw_event_synth(void *__data,\n\t\t\t\t\t\tu64 *var_ref_vals,\n\t\t\t\t\t\tunsigned int *var_ref_idx)\n{\n\tunsigned int i, n_u64, val_idx, len, data_size = 0;\n\tstruct trace_event_file *trace_file = __data;\n\tstruct synth_trace_event *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_buffer *buffer;\n\tstruct synth_event *event;\n\tint fields_size = 0;\n\n\tevent = trace_file->event_call->data;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tfields_size = event->n_u64 * sizeof(u64);\n\n\tfor (i = 0; i < event->n_dynamic_fields; i++) {\n\t\tunsigned int field_pos = event->dynamic_fields[i]->field_pos;\n\t\tchar *str_val;\n\n\t\tval_idx = var_ref_idx[field_pos];\n\t\tstr_val = (char *)(long)var_ref_vals[val_idx];\n\n\t\tif (event->dynamic_fields[i]->is_stack) {\n\t\t\t \n\t\t\tlen = *((unsigned long *)str_val) + 1;\n\t\t\tlen *= sizeof(unsigned long);\n\t\t} else {\n\t\t\tlen = fetch_store_strlen((unsigned long)str_val);\n\t\t}\n\n\t\tfields_size += len;\n\t}\n\n\t \n\tbuffer = trace_file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + fields_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tval_idx = var_ref_idx[i];\n\t\tif (event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)var_ref_vals[val_idx];\n\n\t\t\tlen = trace_string(entry, event, str_val,\n\t\t\t\t\t   event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len;  \n\t\t} else if (event->fields[i]->is_stack) {\n\t\t\tlong *stack = (long *)(long)var_ref_vals[val_idx];\n\n\t\t\tlen = trace_stack(entry, event, stack,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len;\n\t\t} else {\n\t\t\tstruct synth_field *field = event->fields[i];\n\t\t\tu64 val = var_ref_vals[val_idx];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\tentry->fields[n_u64].as_u8 = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tentry->fields[n_u64].as_u16 = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tentry->fields[n_u64].as_u32 = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tentry->fields[n_u64].as_u64 = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\ttrace_event_buffer_commit(&fbuffer);\nout:\n\tring_buffer_nest_end(buffer);\n}\n\nstatic void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}\n\nstatic int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t \n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string &&\n\t\t    event->fields[i]->is_dynamic)\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", __get_str(%s)\", event->fields[i]->name);\n\t\telse if (event->fields[i]->is_stack)\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", __get_stacktrace(%s)\", event->fields[i]->name);\n\t\telse\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t \n\treturn pos;\n}\n\nstatic int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t \n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t \n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}\n\nstatic int check_field_version(const char *prefix, const char *field_type,\n\t\t\t       const char *field_name)\n{\n\t \n\treturn 1;\n}\n\nstatic struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed, int *field_version)\n{\n\tconst char *prefix = NULL, *field_type = argv[0], *field_name, *array;\n\tstruct synth_field *field;\n\tint len, ret = -ENOMEM;\n\tstruct seq_buf s;\n\tssize_t size;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3) {\n\t\t\tsynth_err(SYNTH_ERR_INCOMPLETE_TYPE, errpos(field_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed += 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed += 2;\n\t}\n\n\tif (!field_name) {\n\t\tsynth_err(SYNTH_ERR_INVALID_FIELD, errpos(field_type));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*field_version = check_field_version(prefix, field_type, field_name);\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_name);\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen -= strlen(array);\n\n\tfield->name = kmemdup_nul(field_name, len, GFP_KERNEL);\n\tif (!field->name)\n\t\tgoto free;\n\n\tif (!is_good_name(field->name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = strlen(field_type) + 1;\n\n\tif (array)\n\t\tlen += strlen(array);\n\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type)\n\t\tgoto free;\n\n\tseq_buf_init(&s, field->type, len);\n\tif (prefix)\n\t\tseq_buf_puts(&s, prefix);\n\tseq_buf_puts(&s, field_type);\n\tif (array)\n\t\tseq_buf_puts(&s, array);\n\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\tgoto free;\n\n\ts.buffer[s.len] = '\\0';\n\n\tsize = synth_field_size(field->type);\n\tif (size < 0) {\n\t\tif (array)\n\t\t\tsynth_err(SYNTH_ERR_INVALID_ARRAY_SPEC, errpos(field_name));\n\t\telse\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t} else if (size == 0) {\n\t\tif (synth_field_is_string(field->type) ||\n\t\t    synth_field_is_stack(field->type)) {\n\t\t\tchar *type;\n\n\t\t\tlen = sizeof(\"__data_loc \") + strlen(field->type) + 1;\n\t\t\ttype = kzalloc(len, GFP_KERNEL);\n\t\t\tif (!type)\n\t\t\t\tgoto free;\n\n\t\t\tseq_buf_init(&s, type, len);\n\t\t\tseq_buf_puts(&s, \"__data_loc \");\n\t\t\tseq_buf_puts(&s, field->type);\n\n\t\t\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\t\t\tgoto free;\n\t\t\ts.buffer[s.len] = '\\0';\n\n\t\t\tkfree(field->type);\n\t\t\tfield->type = type;\n\n\t\t\tfield->is_dynamic = true;\n\t\t\tsize = sizeof(u64);\n\t\t} else {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\tfield->size = size;\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\telse if (synth_field_is_stack(field->type))\n\t\tfield->is_stack = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}\n\nstatic void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}\n\nstatic struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct trace_event_fields synth_event_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = synth_event_define_fields },\n\t{}\n};\n\nstatic int register_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret = 0;\n\n\tevent->call.class = &event->class;\n\tevent->class.system = kstrdup(SYNTH_SYSTEM, GFP_KERNEL);\n\tif (!event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tevent->tp = alloc_synth_tracepoint(event->name);\n\tif (IS_ERR(event->tp)) {\n\t\tret = PTR_ERR(event->tp);\n\t\tevent->tp = NULL;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &synth_event_funcs;\n\tcall->class->fields_array = synth_event_fields_array;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tcall->flags = TRACE_EVENT_FL_TRACEPOINT;\n\tcall->class->reg = trace_event_reg;\n\tcall->class->probe = trace_event_raw_event_synth;\n\tcall->data = event;\n\tcall->tp = event->tp;\n\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register synthetic event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tgoto err;\n\t}\n\n\tret = set_synth_event_print_fmt(call);\n\t \n\tif (ret < 0)\n\t\ttrace_remove_event_call(call);\n out:\n\treturn ret;\n err:\n\tunregister_trace_event(&call->event);\n\tgoto out;\n}\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}\n\nstatic struct synth_event *alloc_synth_event(const char *name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tunsigned int i, j, n_dynamic_fields = 0;\n\tstruct synth_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tif (fields[i]->is_dynamic)\n\t\t\tn_dynamic_fields++;\n\n\tif (n_dynamic_fields) {\n\t\tevent->dynamic_fields = kcalloc(n_dynamic_fields,\n\t\t\t\t\t\tsizeof(*event->dynamic_fields),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!event->dynamic_fields) {\n\t\t\tfree_synth_event(event);\n\t\t\tevent = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdyn_event_init(&event->devent, &synth_event_ops);\n\n\tfor (i = 0, j = 0; i < n_fields; i++) {\n\t\tfields[i]->field_pos = i;\n\t\tevent->fields[i] = fields[i];\n\n\t\tif (fields[i]->is_dynamic)\n\t\t\tevent->dynamic_fields[j++] = fields[i];\n\t}\n\tevent->n_dynamic_fields = j;\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}\n\nstatic int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}\n\n \nint synth_event_add_field(struct dynevent_cmd *cmd, const char *type,\n\t\t\t  const char *name)\n{\n\tstruct dynevent_arg_pair arg_pair;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type || !name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_pair_init(&arg_pair, 0, ';');\n\n\targ_pair.lhs = type;\n\targ_pair.rhs = name;\n\n\tret = dynevent_arg_pair_add(cmd, &arg_pair, synth_event_check_arg_fn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_add_field);\n\n \nint synth_event_add_field_str(struct dynevent_cmd *cmd, const char *type_name)\n{\n\tstruct dynevent_arg arg;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type_name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, ';');\n\n\targ.str = type_name;\n\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_add_field_str);\n\n \nint synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_add_fields);\n\n \nint __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__synth_event_gen_cmd_start);\n\n \nint synth_event_gen_cmd_array_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\t    struct module *mod,\n\t\t\t\t    struct synth_field_desc *fields,\n\t\t\t\t    unsigned int n_fields)\n{\n\tstruct dynevent_arg arg;\n\tunsigned int i;\n\tint ret = 0;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (n_fields > SYNTH_FIELDS_MAX)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_gen_cmd_array_start);\n\nstatic int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t \n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t \n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\t\t\tfields[n_fields++] = field;\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}\n\n \nint synth_event_create(const char *name, struct synth_field_desc *fields,\n\t\t       unsigned int n_fields, struct module *mod)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\tret = synth_event_gen_cmd_array_start(&cmd, name, mod,\n\t\t\t\t\t      fields, n_fields);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n out:\n\tkfree(buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_create);\n\nstatic int destroy_synth_event(struct synth_event *se)\n{\n\tint ret;\n\n\tif (se->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&se->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(se);\n\tif (!ret) {\n\t\tdyn_event_remove(&se->devent);\n\t\tfree_synth_event(se);\n\t}\n\n\treturn ret;\n}\n\n \nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\t \n\t\ttracing_reset_all_online_cpus();\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_delete);\n\nstatic int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}\n\nstatic int create_or_delete_synth_event(const char *raw_command)\n{\n\tchar *name = NULL, *fields, *p;\n\tint ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tret = check_command(raw_command);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p && raw_command[0] != '!') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tname = kmemdup_nul(raw_command, p ? p - raw_command : strlen(raw_command), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (name[0] == '!') {\n\t\tret = synth_event_delete(name + 1);\n\t\tgoto free;\n\t}\n\n\tfields = skip_spaces(p);\n\n\tret = __create_synth_event(name, fields);\nfree:\n\tkfree(name);\n\n\treturn ret;\n}\n\nstatic int synth_event_run_command(struct dynevent_cmd *cmd)\n{\n\tstruct synth_event *se;\n\tint ret;\n\n\tret = create_or_delete_synth_event(cmd->seq.buffer);\n\tif (ret)\n\t\treturn ret;\n\n\tse = find_synth_event(cmd->event_name);\n\tif (WARN_ON(!se))\n\t\treturn -ENOENT;\n\n\tse->mod = cmd->private_data;\n\n\treturn ret;\n}\n\n \nvoid synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}\nEXPORT_SYMBOL_GPL(synth_event_cmd_init);\n\nstatic inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t \n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}\n\nstatic inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t \n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}\n\n \nint synth_event_trace(struct trace_event_file *file, unsigned int n_vals, ...)\n{\n\tunsigned int i, n_u64, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tva_list args;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;  \n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tva_start(args, n_vals);\n\n\t\tfor (i = 0; i < state.event->n_fields; i++) {\n\t\t\tu64 val = va_arg(args, u64);\n\n\t\t\tif (state.event->fields[i]->is_string &&\n\t\t\t    state.event->fields[i]->is_dynamic) {\n\t\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\t\tdata_size += strlen(str_val) + 1;\n\t\t\t}\n\t\t}\n\n\t\tva_end(args);\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tva_start(args, n_vals);\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tu64 val;\n\n\t\tval = va_arg(args, u64);\n\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len;  \n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\tstate.entry->fields[n_u64].as_u8 = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tstate.entry->fields[n_u64].as_u16 = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tstate.entry->fields[n_u64].as_u32 = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64].as_u64 = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\tva_end(args);\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_trace);\n\n \nint synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;  \n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len;  \n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\tstate.entry->fields[n_u64].as_u8 = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tstate.entry->fields[n_u64].as_u16 = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tstate.entry->fields[n_u64].as_u32 = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64].as_u64 = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_trace_array);\n\n \nint synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;  \n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(synth_event_trace_start);\n\nstatic int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) {  \n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\ttrace_state->entry->fields[field->offset].as_u8 = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\ttrace_state->entry->fields[field->offset].as_u16 = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\ttrace_state->entry->fields[field->offset].as_u32 = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset].as_u64 = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}\n\n \nint synth_event_add_next_val(u64 val,\n\t\t\t     struct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(NULL, val, trace_state);\n}\nEXPORT_SYMBOL_GPL(synth_event_add_next_val);\n\n \nint synth_event_add_val(const char *field_name, u64 val,\n\t\t\tstruct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(field_name, val, trace_state);\n}\nEXPORT_SYMBOL_GPL(synth_event_add_val);\n\n \nint synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(synth_event_trace_end);\n\nstatic int create_synth_event(const char *raw_command)\n{\n\tchar *fields, *p;\n\tconst char *name;\n\tint len, ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tname = raw_command;\n\n\t \n\tif (name[0] != 's' || name[1] != ':')\n\t\treturn -ECANCELED;\n\tname += 2;\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tfields = skip_spaces(p);\n\n\t \n\tif (strchr(name, '/')) {\n\t\tlen = str_has_prefix(name, SYNTH_SYSTEM \"/\");\n\t\tif (len == 0) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_DYN_CMD, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tname += len;\n\t}\n\n\tlen = name - raw_command;\n\n\tret = check_command(raw_command + len);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tname = kmemdup_nul(raw_command + len, p - raw_command - len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = __create_synth_event(name, fields);\n\n\tkfree(name);\n\n\treturn ret;\n}\n\nstatic int synth_event_release(struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\tint ret;\n\n\tif (event->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&event->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(event);\n\tif (ret)\n\t\treturn ret;\n\n\tdyn_event_remove(ev);\n\tfree_synth_event(event);\n\treturn 0;\n}\n\nstatic int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) {  \n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t \n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\n\tseq_printf(m, \"s:%s/\", event->class.system);\n\n\treturn __synth_event_show(m, event);\n}\n\nstatic int synth_events_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_synth_event(ev))\n\t\treturn 0;\n\n\treturn __synth_event_show(m, to_synth_event(ev));\n}\n\nstatic const struct seq_operations synth_events_seq_op = {\n\t.start\t= dyn_event_seq_start,\n\t.next\t= dyn_event_seq_next,\n\t.stop\t= dyn_event_seq_stop,\n\t.show\t= synth_events_seq_show,\n};\n\nstatic int synth_events_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&synth_event_ops);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &synth_events_seq_op);\n}\n\nstatic ssize_t synth_events_write(struct file *file,\n\t\t\t\t  const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_or_delete_synth_event);\n}\n\nstatic const struct file_operations synth_events_fops = {\n\t.open           = synth_events_open,\n\t.write\t\t= synth_events_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};\n\n \nstatic __init int trace_events_synth_init_early(void)\n{\n\tint err = 0;\n\n\terr = dyn_event_register(&synth_event_ops);\n\tif (err)\n\t\tpr_warn(\"Could not register synth_event_ops\\n\");\n\n\treturn err;\n}\ncore_initcall(trace_events_synth_init_early);\n\nstatic __init int trace_events_synth_init(void)\n{\n\tstruct dentry *entry = NULL;\n\tint err = 0;\n\terr = tracing_init_dentry();\n\tif (err)\n\t\tgoto err;\n\n\tentry = tracefs_create_file(\"synthetic_events\", TRACE_MODE_WRITE,\n\t\t\t\t    NULL, NULL, &synth_events_fops);\n\tif (!entry) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn err;\n err:\n\tpr_warn(\"Could not create tracefs 'synthetic_events' entry\\n\");\n\n\treturn err;\n}\n\nfs_initcall(trace_events_synth_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}