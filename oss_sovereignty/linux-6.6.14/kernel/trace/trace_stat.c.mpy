{
  "module_name": "trace_stat.c",
  "hash_id": "66192566320ad2edb552d9dbf382442eb38f242f0bed4c3545e413f71bef2659",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_stat.c",
  "human_readable_source": "\n \n\n#include <linux/security.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/tracefs.h>\n#include \"trace_stat.h\"\n#include \"trace.h\"\n\n\n \nstruct stat_node {\n\tstruct rb_node\t\tnode;\n\tvoid\t\t\t*stat;\n};\n\n \nstruct stat_session {\n\tstruct list_head\tsession_list;\n\tstruct tracer_stat\t*ts;\n\tstruct rb_root\t\tstat_root;\n\tstruct mutex\t\tstat_mutex;\n\tstruct dentry\t\t*file;\n};\n\n \nstatic LIST_HEAD(all_stat_sessions);\nstatic DEFINE_MUTEX(all_stat_sessions_mutex);\n\n \nstatic struct dentry\t\t*stat_dir;\n\nstatic void __reset_stat_session(struct stat_session *session)\n{\n\tstruct stat_node *snode, *n;\n\n\trbtree_postorder_for_each_entry_safe(snode, n, &session->stat_root, node) {\n\t\tif (session->ts->stat_release)\n\t\t\tsession->ts->stat_release(snode->stat);\n\t\tkfree(snode);\n\t}\n\n\tsession->stat_root = RB_ROOT;\n}\n\nstatic void reset_stat_session(struct stat_session *session)\n{\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n}\n\nstatic void destroy_session(struct stat_session *session)\n{\n\ttracefs_remove(session->file);\n\t__reset_stat_session(session);\n\tmutex_destroy(&session->stat_mutex);\n\tkfree(session);\n}\n\nstatic int insert_stat(struct rb_root *root, void *stat, cmp_func_t cmp)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct stat_node *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->stat = stat;\n\n\t \n\twhile (*new) {\n\t\tstruct stat_node *this;\n\t\tint result;\n\n\t\tthis = container_of(*new, struct stat_node, node);\n\t\tresult = cmp(data->stat, this->stat);\n\n\t\tparent = *new;\n\t\tif (result >= 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&data->node, parent, new);\n\trb_insert_color(&data->node, root);\n\treturn 0;\n}\n\n \nstatic int dummy_cmp(const void *p1, const void *p2)\n{\n\treturn -1;\n}\n\n \nstatic int stat_seq_init(struct stat_session *session)\n{\n\tstruct tracer_stat *ts = session->ts;\n\tstruct rb_root *root = &session->stat_root;\n\tvoid *stat;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&session->stat_mutex);\n\t__reset_stat_session(session);\n\n\tif (!ts->stat_cmp)\n\t\tts->stat_cmp = dummy_cmp;\n\n\tstat = ts->stat_start(ts);\n\tif (!stat)\n\t\tgoto exit;\n\n\tret = insert_stat(root, stat, ts->stat_cmp);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tfor (i = 1; ; i++) {\n\t\tstat = ts->stat_next(stat, i);\n\n\t\t \n\t\tif (!stat)\n\t\t\tbreak;\n\n\t\tret = insert_stat(root, stat, ts->stat_cmp);\n\t\tif (ret)\n\t\t\tgoto exit_free_rbtree;\n\t}\n\nexit:\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n\nexit_free_rbtree:\n\t__reset_stat_session(session);\n\tmutex_unlock(&session->stat_mutex);\n\treturn ret;\n}\n\n\nstatic void *stat_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct stat_session *session = s->private;\n\tstruct rb_node *node;\n\tint n = *pos;\n\tint i;\n\n\t \n\tmutex_lock(&session->stat_mutex);\n\n\t \n\tif (session->ts->stat_headers) {\n\t\tif (n == 0)\n\t\t\treturn SEQ_START_TOKEN;\n\t\tn--;\n\t}\n\n\tnode = rb_first(&session->stat_root);\n\tfor (i = 0; node && i < n; i++)\n\t\tnode = rb_next(node);\n\n\treturn node;\n}\n\nstatic void *stat_seq_next(struct seq_file *s, void *p, loff_t *pos)\n{\n\tstruct stat_session *session = s->private;\n\tstruct rb_node *node = p;\n\n\t(*pos)++;\n\n\tif (p == SEQ_START_TOKEN)\n\t\treturn rb_first(&session->stat_root);\n\n\treturn rb_next(node);\n}\n\nstatic void stat_seq_stop(struct seq_file *s, void *p)\n{\n\tstruct stat_session *session = s->private;\n\tmutex_unlock(&session->stat_mutex);\n}\n\nstatic int stat_seq_show(struct seq_file *s, void *v)\n{\n\tstruct stat_session *session = s->private;\n\tstruct stat_node *l = container_of(v, struct stat_node, node);\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn session->ts->stat_headers(s);\n\n\treturn session->ts->stat_show(s, l->stat);\n}\n\nstatic const struct seq_operations trace_stat_seq_ops = {\n\t.start\t\t= stat_seq_start,\n\t.next\t\t= stat_seq_next,\n\t.stop\t\t= stat_seq_stop,\n\t.show\t\t= stat_seq_show\n};\n\n \nstatic int tracing_stat_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct seq_file *m;\n\tstruct stat_session *session = inode->i_private;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stat_seq_init(session);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, &trace_stat_seq_ops);\n\tif (ret) {\n\t\treset_stat_session(session);\n\t\treturn ret;\n\t}\n\n\tm = file->private_data;\n\tm->private = session;\n\treturn ret;\n}\n\n \nstatic int tracing_stat_release(struct inode *i, struct file *f)\n{\n\tstruct stat_session *session = i->i_private;\n\n\treset_stat_session(session);\n\n\treturn seq_release(i, f);\n}\n\nstatic const struct file_operations tracing_stat_fops = {\n\t.open\t\t= tracing_stat_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_stat_release\n};\n\nstatic int tracing_stat_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tstat_dir = tracefs_create_dir(\"trace_stat\", NULL);\n\tif (!stat_dir) {\n\t\tpr_warn(\"Could not create tracefs 'trace_stat' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int init_stat_file(struct stat_session *session)\n{\n\tint ret;\n\n\tif (!stat_dir && (ret = tracing_stat_init()))\n\t\treturn ret;\n\n\tsession->file = tracefs_create_file(session->ts->name, TRACE_MODE_WRITE,\n\t\t\t\t\t    stat_dir, session,\n\t\t\t\t\t    &tracing_stat_fops);\n\tif (!session->file)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nint register_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *session, *node;\n\tint ret = -EINVAL;\n\n\tif (!trace)\n\t\treturn -EINVAL;\n\n\tif (!trace->stat_start || !trace->stat_next || !trace->stat_show)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry(node, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace)\n\t\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\t \n\tsession = kzalloc(sizeof(*session), GFP_KERNEL);\n\tif (!session)\n\t\tgoto out;\n\n\tsession->ts = trace;\n\tINIT_LIST_HEAD(&session->session_list);\n\tmutex_init(&session->stat_mutex);\n\n\tret = init_stat_file(session);\n\tif (ret) {\n\t\tdestroy_session(session);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\t \n\tlist_add_tail(&session->session_list, &all_stat_sessions);\n out:\n\tmutex_unlock(&all_stat_sessions_mutex);\n\n\treturn ret;\n}\n\nvoid unregister_stat_tracer(struct tracer_stat *trace)\n{\n\tstruct stat_session *node, *tmp;\n\n\tmutex_lock(&all_stat_sessions_mutex);\n\tlist_for_each_entry_safe(node, tmp, &all_stat_sessions, session_list) {\n\t\tif (node->ts == trace) {\n\t\t\tlist_del(&node->session_list);\n\t\t\tdestroy_session(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&all_stat_sessions_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}