{
  "module_name": "tracing_map.c",
  "hash_id": "30063ee5f26d27e53accbcf46af93e272d4d5512187093e805b52e0606ebcdaf",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/tracing_map.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/kmemleak.h>\n\n#include \"tracing_map.h\"\n#include \"trace.h\"\n\n \n\n \nvoid tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}\n\n \nu64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}\n\n \nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}\n\n \nbool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}\n\n \nu64 tracing_map_read_var(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}\n\n \nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}\n\nint tracing_map_cmp_string(void *val_a, void *val_b)\n{\n\tchar *a = val_a;\n\tchar *b = val_b;\n\n\treturn strcmp(a, b);\n}\n\nint tracing_map_cmp_none(void *val_a, void *val_b)\n{\n\treturn 0;\n}\n\nstatic int tracing_map_cmp_atomic64(void *val_a, void *val_b)\n{\n\tu64 a = atomic64_read((atomic64_t *)val_a);\n\tu64 b = atomic64_read((atomic64_t *)val_b);\n\n\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);\n}\n\n#define DEFINE_TRACING_MAP_CMP_FN(type)\t\t\t\t\t\\\nstatic int tracing_map_cmp_##type(void *val_a, void *val_b)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype a = (type)(*(u64 *)val_a);\t\t\t\t\t\\\n\ttype b = (type)(*(u64 *)val_b);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn (a > b) ? 1 : ((a < b) ? -1 : 0);\t\t\t\\\n}\n\nDEFINE_TRACING_MAP_CMP_FN(s64);\nDEFINE_TRACING_MAP_CMP_FN(u64);\nDEFINE_TRACING_MAP_CMP_FN(s32);\nDEFINE_TRACING_MAP_CMP_FN(u32);\nDEFINE_TRACING_MAP_CMP_FN(s16);\nDEFINE_TRACING_MAP_CMP_FN(u16);\nDEFINE_TRACING_MAP_CMP_FN(s8);\nDEFINE_TRACING_MAP_CMP_FN(u8);\n\ntracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}\n\nstatic int tracing_map_add_field(struct tracing_map *map,\n\t\t\t\t tracing_map_cmp_fn_t cmp_fn)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_fields < TRACING_MAP_FIELDS_MAX) {\n\t\tret = map->n_fields;\n\t\tmap->fields[map->n_fields++].cmp_fn = cmp_fn;\n\t}\n\n\treturn ret;\n}\n\n \nint tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}\n\n \nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}\n\n \nint tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}\n\nstatic void tracing_map_array_clear(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a->pages)\n\t\treturn;\n\n\tfor (i = 0; i < a->n_pages; i++)\n\t\tmemset(a->pages[i], 0, PAGE_SIZE);\n}\n\nstatic void tracing_map_array_free(struct tracing_map_array *a)\n{\n\tunsigned int i;\n\n\tif (!a)\n\t\treturn;\n\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\tif (!a->pages[i])\n\t\t\tbreak;\n\t\tkmemleak_free(a->pages[i]);\n\t\tfree_page((unsigned long)a->pages[i]);\n\t}\n\n\tkfree(a->pages);\n\n free:\n\tkfree(a);\n}\n\nstatic struct tracing_map_array *tracing_map_array_alloc(unsigned int n_elts,\n\t\t\t\t\t\t  unsigned int entry_size)\n{\n\tstruct tracing_map_array *a;\n\tunsigned int i;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn NULL;\n\n\ta->entry_size_shift = fls(roundup_pow_of_two(entry_size) - 1);\n\ta->entries_per_page = PAGE_SIZE / (1 << a->entry_size_shift);\n\ta->n_pages = n_elts / a->entries_per_page;\n\tif (!a->n_pages)\n\t\ta->n_pages = 1;\n\ta->entry_shift = fls(a->entries_per_page) - 1;\n\ta->entry_mask = (1 << a->entry_shift) - 1;\n\n\ta->pages = kcalloc(a->n_pages, sizeof(void *), GFP_KERNEL);\n\tif (!a->pages)\n\t\tgoto free;\n\n\tfor (i = 0; i < a->n_pages; i++) {\n\t\ta->pages[i] = (void *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!a->pages[i])\n\t\t\tgoto free;\n\t\tkmemleak_alloc(a->pages[i], PAGE_SIZE, 1, GFP_KERNEL);\n\t}\n out:\n\treturn a;\n free:\n\ttracing_map_array_free(a);\n\ta = NULL;\n\n\tgoto out;\n}\n\nstatic void tracing_map_elt_clear(struct tracing_map_elt *elt)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < elt->map->n_fields; i++)\n\t\tif (elt->fields[i].cmp_fn == tracing_map_cmp_atomic64)\n\t\t\tatomic64_set(&elt->fields[i].sum, 0);\n\n\tfor (i = 0; i < elt->map->n_vars; i++) {\n\t\tatomic64_set(&elt->vars[i], 0);\n\t\telt->var_set[i] = false;\n\t}\n\n\tif (elt->map->ops && elt->map->ops->elt_clear)\n\t\telt->map->ops->elt_clear(elt);\n}\n\nstatic void tracing_map_elt_init_fields(struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\ttracing_map_elt_clear(elt);\n\n\tfor (i = 0; i < elt->map->n_fields; i++) {\n\t\telt->fields[i].cmp_fn = elt->map->fields[i].cmp_fn;\n\n\t\tif (elt->fields[i].cmp_fn != tracing_map_cmp_atomic64)\n\t\t\telt->fields[i].offset = elt->map->fields[i].offset;\n\t}\n}\n\nstatic void tracing_map_elt_free(struct tracing_map_elt *elt)\n{\n\tif (!elt)\n\t\treturn;\n\n\tif (elt->map->ops && elt->map->ops->elt_free)\n\t\telt->map->ops->elt_free(elt);\n\tkfree(elt->fields);\n\tkfree(elt->vars);\n\tkfree(elt->var_set);\n\tkfree(elt->key);\n\tkfree(elt);\n}\n\nstatic struct tracing_map_elt *tracing_map_elt_alloc(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt;\n\tint err = 0;\n\n\telt = kzalloc(sizeof(*elt), GFP_KERNEL);\n\tif (!elt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\telt->map = map;\n\n\telt->key = kzalloc(map->key_size, GFP_KERNEL);\n\tif (!elt->key) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->fields = kcalloc(map->n_fields, sizeof(*elt->fields), GFP_KERNEL);\n\tif (!elt->fields) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->vars = kcalloc(map->n_vars, sizeof(*elt->vars), GFP_KERNEL);\n\tif (!elt->vars) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\telt->var_set = kcalloc(map->n_vars, sizeof(*elt->var_set), GFP_KERNEL);\n\tif (!elt->var_set) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\ttracing_map_elt_init_fields(elt);\n\n\tif (map->ops && map->ops->elt_alloc) {\n\t\terr = map->ops->elt_alloc(elt);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\treturn elt;\n free:\n\ttracing_map_elt_free(elt);\n\n\treturn ERR_PTR(err);\n}\n\nstatic struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_inc_return(&map->next_elt);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}\n\nstatic void tracing_map_free_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tif (!map->elts)\n\t\treturn;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\ttracing_map_elt_free(*(TRACING_MAP_ELT(map->elts, i)));\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t}\n\n\ttracing_map_array_free(map->elts);\n\tmap->elts = NULL;\n}\n\nstatic int tracing_map_alloc_elts(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tmap->elts = tracing_map_array_alloc(map->max_elts,\n\t\t\t\t\t    sizeof(struct tracing_map_elt *));\n\tif (!map->elts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < map->max_elts; i++) {\n\t\t*(TRACING_MAP_ELT(map->elts, i)) = tracing_map_elt_alloc(map);\n\t\tif (IS_ERR(*(TRACING_MAP_ELT(map->elts, i)))) {\n\t\t\t*(TRACING_MAP_ELT(map->elts, i)) = NULL;\n\t\t\ttracing_map_free_elts(map);\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool keys_match(void *key, void *test_key, unsigned key_size)\n{\n\tbool match = true;\n\n\tif (memcmp(key, test_key, key_size))\n\t\tmatch = false;\n\n\treturn match;\n}\n\nstatic inline struct tracing_map_elt *\n__tracing_map_insert(struct tracing_map *map, void *key, bool lookup_only)\n{\n\tu32 idx, key_hash, test_key;\n\tint dup_try = 0;\n\tstruct tracing_map_entry *entry;\n\tstruct tracing_map_elt *val;\n\n\tkey_hash = jhash(key, map->key_size, 0);\n\tif (key_hash == 0)\n\t\tkey_hash = 1;\n\tidx = key_hash >> (32 - (map->map_bits + 1));\n\n\twhile (1) {\n\t\tidx &= (map->map_size - 1);\n\t\tentry = TRACING_MAP_ENTRY(map->map, idx);\n\t\ttest_key = entry->key;\n\n\t\tif (test_key && test_key == key_hash) {\n\t\t\tval = READ_ONCE(entry->val);\n\t\t\tif (val &&\n\t\t\t    keys_match(key, val->key, map->key_size)) {\n\t\t\t\tif (!lookup_only)\n\t\t\t\t\tatomic64_inc(&map->hits);\n\t\t\t\treturn val;\n\t\t\t} else if (unlikely(!val)) {\n\t\t\t\t \n\n\t\t\t\tdup_try++;\n\t\t\t\tif (dup_try > map->map_size) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_key) {\n\t\t\tif (lookup_only)\n\t\t\t\tbreak;\n\n\t\t\tif (!cmpxchg(&entry->key, 0, key_hash)) {\n\t\t\t\tstruct tracing_map_elt *elt;\n\n\t\t\t\telt = get_free_elt(map);\n\t\t\t\tif (!elt) {\n\t\t\t\t\tatomic64_inc(&map->drops);\n\t\t\t\t\tentry->key = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(elt->key, key, map->key_size);\n\t\t\t\tentry->val = elt;\n\t\t\t\tatomic64_inc(&map->hits);\n\n\t\t\t\treturn entry->val;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdup_try++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}\n\n \nstruct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}\n\n \nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}\n\n \nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}\n\nstatic void set_sort_key(struct tracing_map *map,\n\t\t\t struct tracing_map_sort_key *sort_key)\n{\n\tmap->sort_key = *sort_key;\n}\n\n \nstruct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}\n\n \nint tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL;  \n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}\n\nstatic int cmp_entries_dup(const void *A, const void *B)\n{\n\tconst struct tracing_map_sort_entry *a, *b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\tif (memcmp(a->key, b->key, a->elt->map->key_size))\n\t\tret = 1;\n\n\treturn ret;\n}\n\nstatic int cmp_entries_sum(const void *A, const void *B)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tconst struct tracing_map_sort_entry *a, *b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\telt_a = a->elt;\n\telt_b = b->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = &elt_a->fields[sort_key->field_idx].sum;\n\tval_b = &elt_b->fields[sort_key->field_idx].sum;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}\n\nstatic int cmp_entries_key(const void *A, const void *B)\n{\n\tconst struct tracing_map_elt *elt_a, *elt_b;\n\tconst struct tracing_map_sort_entry *a, *b;\n\tstruct tracing_map_sort_key *sort_key;\n\tstruct tracing_map_field *field;\n\ttracing_map_cmp_fn_t cmp_fn;\n\tvoid *val_a, *val_b;\n\tint ret = 0;\n\n\ta = *(const struct tracing_map_sort_entry **)A;\n\tb = *(const struct tracing_map_sort_entry **)B;\n\n\telt_a = a->elt;\n\telt_b = b->elt;\n\n\tsort_key = &elt_a->map->sort_key;\n\n\tfield = &elt_a->fields[sort_key->field_idx];\n\n\tcmp_fn = field->cmp_fn;\n\n\tval_a = elt_a->key + field->offset;\n\tval_b = elt_b->key + field->offset;\n\n\tret = cmp_fn(val_a, val_b);\n\tif (sort_key->descending)\n\t\tret = -ret;\n\n\treturn ret;\n}\n\nstatic void destroy_sort_entry(struct tracing_map_sort_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tif (entry->elt_copied)\n\t\ttracing_map_elt_free(entry->elt);\n\n\tkfree(entry);\n}\n\n \nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}\n\nstatic struct tracing_map_sort_entry *\ncreate_sort_entry(void *key, struct tracing_map_elt *elt)\n{\n\tstruct tracing_map_sort_entry *sort_entry;\n\n\tsort_entry = kzalloc(sizeof(*sort_entry), GFP_KERNEL);\n\tif (!sort_entry)\n\t\treturn NULL;\n\n\tsort_entry->key = key;\n\tsort_entry->elt = elt;\n\n\treturn sort_entry;\n}\n\nstatic void detect_dups(struct tracing_map_sort_entry **sort_entries,\n\t\t      int n_entries, unsigned int key_size)\n{\n\tunsigned int total_dups = 0;\n\tint i;\n\tvoid *key;\n\n\tif (n_entries < 2)\n\t\treturn;\n\n\tsort(sort_entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_dup, NULL);\n\n\tkey = sort_entries[0]->key;\n\tfor (i = 1; i < n_entries; i++) {\n\t\tif (!memcmp(sort_entries[i]->key, key, key_size)) {\n\t\t\ttotal_dups++;\n\t\t\tcontinue;\n\t\t}\n\t\tkey = sort_entries[i]->key;\n\t}\n\n\tWARN_ONCE(total_dups > 0,\n\t\t  \"Duplicates detected: %d\\n\", total_dups);\n}\n\nstatic bool is_key(struct tracing_map *map, unsigned int field_idx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < map->n_keys; i++)\n\t\tif (map->key_idx[i] == field_idx)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}\n\n \nint tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const void *, const void *);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}