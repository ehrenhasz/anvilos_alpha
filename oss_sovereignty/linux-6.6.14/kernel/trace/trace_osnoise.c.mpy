{
  "module_name": "trace_osnoise.c",
  "hash_id": "7f44681f011ccc74bd4e58a54ccbc1413838a260a18e07137602708ee7c92ca0",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_osnoise.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/tracefs.h>\n#include <linux/uaccess.h>\n#include <linux/cpumask.h>\n#include <linux/delay.h>\n#include <linux/sched/clock.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include \"trace.h\"\n\n#ifdef CONFIG_X86_LOCAL_APIC\n#include <asm/trace/irq_vectors.h>\n#undef TRACE_INCLUDE_PATH\n#undef TRACE_INCLUDE_FILE\n#endif  \n\n#include <trace/events/irq.h>\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/osnoise.h>\n\n \n#define BANNER\t\t\t\"osnoise: \"\n#define DEFAULT_SAMPLE_PERIOD\t1000000\t\t\t \n#define DEFAULT_SAMPLE_RUNTIME\t1000000\t\t\t \n\n#define DEFAULT_TIMERLAT_PERIOD\t1000\t\t\t \n#define DEFAULT_TIMERLAT_PRIO\t95\t\t\t \n\n \nenum osnoise_options_index {\n\tOSN_DEFAULTS = 0,\n\tOSN_WORKLOAD,\n\tOSN_PANIC_ON_STOP,\n\tOSN_PREEMPT_DISABLE,\n\tOSN_IRQ_DISABLE,\n\tOSN_MAX\n};\n\nstatic const char * const osnoise_options_str[OSN_MAX] = {\n\t\t\t\t\t\t\t\"DEFAULTS\",\n\t\t\t\t\t\t\t\"OSNOISE_WORKLOAD\",\n\t\t\t\t\t\t\t\"PANIC_ON_STOP\",\n\t\t\t\t\t\t\t\"OSNOISE_PREEMPT_DISABLE\",\n\t\t\t\t\t\t\t\"OSNOISE_IRQ_DISABLE\" };\n\n#define OSN_DEFAULT_OPTIONS\t\t0x2\nstatic unsigned long osnoise_options\t= OSN_DEFAULT_OPTIONS;\n\n \nstruct osnoise_instance {\n\tstruct list_head\tlist;\n\tstruct trace_array\t*tr;\n};\n\nstatic struct list_head osnoise_instances;\n\nstatic bool osnoise_has_registered_instances(void)\n{\n\treturn !!list_first_or_null_rcu(&osnoise_instances,\n\t\t\t\t\tstruct osnoise_instance,\n\t\t\t\t\tlist);\n}\n\n \nstatic int osnoise_instance_registered(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tif (inst->tr == tr)\n\t\t\tfound = 1;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}\n\n \nstatic int osnoise_register_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\n\t \n\tlockdep_assert_held(&trace_types_lock);\n\n\tinst = kmalloc(sizeof(*inst), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD_RCU(&inst->list);\n\tinst->tr = tr;\n\tlist_add_tail_rcu(&inst->list, &osnoise_instances);\n\n\treturn 0;\n}\n\n \nstatic void osnoise_unregister_instance(struct trace_array *tr)\n{\n\tstruct osnoise_instance *inst;\n\tint found = 0;\n\n\t \n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list,\n\t\t\t\tlockdep_is_held(&trace_types_lock)) {\n\t\tif (inst->tr == tr) {\n\t\t\tlist_del_rcu(&inst->list);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tkvfree_rcu_mightsleep(inst);\n}\n\n \nstruct osn_nmi {\n\tu64\tcount;\n\tu64\tdelta_start;\n};\n\n \nstruct osn_irq {\n\tu64\tcount;\n\tu64\tarrival_time;\n\tu64\tdelta_start;\n};\n\n#define IRQ_CONTEXT\t0\n#define THREAD_CONTEXT\t1\n#define THREAD_URET\t2\n \nstruct osn_softirq {\n\tu64\tcount;\n\tu64\tarrival_time;\n\tu64\tdelta_start;\n};\n\n \nstruct osn_thread {\n\tu64\tcount;\n\tu64\tarrival_time;\n\tu64\tdelta_start;\n};\n\n \nstruct osnoise_variables {\n\tstruct task_struct\t*kthread;\n\tbool\t\t\tsampling;\n\tpid_t\t\t\tpid;\n\tstruct osn_nmi\t\tnmi;\n\tstruct osn_irq\t\tirq;\n\tstruct osn_softirq\tsoftirq;\n\tstruct osn_thread\tthread;\n\tlocal_t\t\t\tint_counter;\n};\n\n \nstatic DEFINE_PER_CPU(struct osnoise_variables, per_cpu_osnoise_var);\n\n \nstatic inline struct osnoise_variables *this_cpu_osn_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_osnoise_var);\n}\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \nstruct timerlat_variables {\n\tstruct task_struct\t*kthread;\n\tstruct hrtimer\t\ttimer;\n\tu64\t\t\trel_period;\n\tu64\t\t\tabs_period;\n\tbool\t\t\ttracing_thread;\n\tu64\t\t\tcount;\n\tbool\t\t\tuthread_migrate;\n};\n\nstatic DEFINE_PER_CPU(struct timerlat_variables, per_cpu_timerlat_var);\n\n \nstatic inline struct timerlat_variables *this_cpu_tmr_var(void)\n{\n\treturn this_cpu_ptr(&per_cpu_timerlat_var);\n}\n\n \nstatic inline void tlat_var_reset(void)\n{\n\tstruct timerlat_variables *tlat_var;\n\tint cpu;\n\t \n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\ttlat_var = per_cpu_ptr(&per_cpu_timerlat_var, cpu);\n\t\tmemset(tlat_var, 0, sizeof(*tlat_var));\n\t}\n}\n#else  \n#define tlat_var_reset()\tdo {} while (0)\n#endif  \n\n \nstatic inline void osn_var_reset(void)\n{\n\tstruct osnoise_variables *osn_var;\n\tint cpu;\n\n\t \n\tfor_each_cpu(cpu, cpu_online_mask) {\n\t\tosn_var = per_cpu_ptr(&per_cpu_osnoise_var, cpu);\n\t\tmemset(osn_var, 0, sizeof(*osn_var));\n\t}\n}\n\n \nstatic inline void osn_var_reset_all(void)\n{\n\tosn_var_reset();\n\ttlat_var_reset();\n}\n\n \nbool trace_osnoise_callback_enabled;\n\n \nstruct osnoise_sample {\n\tu64\t\t\truntime;\t \n\tu64\t\t\tnoise;\t\t \n\tu64\t\t\tmax_sample;\t \n\tint\t\t\thw_count;\t \n\tint\t\t\tnmi_count;\t \n\tint\t\t\tirq_count;\t \n\tint\t\t\tsoftirq_count;\t \n\tint\t\t\tthread_count;\t \n};\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \nstruct timerlat_sample {\n\tu64\t\t\ttimer_latency;\t \n\tunsigned int\t\tseqnum;\t\t \n\tint\t\t\tcontext;\t \n};\n#endif\n\n \nstatic struct mutex interface_lock;\n\n \nstatic struct osnoise_data {\n\tu64\tsample_period;\t\t \n\tu64\tsample_runtime;\t\t \n\tu64\tstop_tracing;\t\t \n\tu64\tstop_tracing_total;\t \n#ifdef CONFIG_TIMERLAT_TRACER\n\tu64\ttimerlat_period;\t \n\tu64\tprint_stack;\t\t \n\tint\ttimerlat_tracer;\t \n#endif\n\tbool\ttainted;\t\t \n} osnoise_data = {\n\t.sample_period\t\t\t= DEFAULT_SAMPLE_PERIOD,\n\t.sample_runtime\t\t\t= DEFAULT_SAMPLE_RUNTIME,\n\t.stop_tracing\t\t\t= 0,\n\t.stop_tracing_total\t\t= 0,\n#ifdef CONFIG_TIMERLAT_TRACER\n\t.print_stack\t\t\t= 0,\n\t.timerlat_period\t\t= DEFAULT_TIMERLAT_PERIOD,\n\t.timerlat_tracer\t\t= 0,\n#endif\n};\n\n#ifdef CONFIG_TIMERLAT_TRACER\nstatic inline bool timerlat_enabled(void)\n{\n\treturn osnoise_data.timerlat_tracer;\n}\n\nstatic inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\tstruct timerlat_variables *tlat_var = this_cpu_tmr_var();\n\t \n\tif (!tlat_var->tracing_thread) {\n\t\tosn_var->softirq.arrival_time = 0;\n\t\tosn_var->softirq.delta_start = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\tstruct timerlat_variables *tlat_var = this_cpu_tmr_var();\n\t \n\tif (!tlat_var->tracing_thread) {\n\t\tosn_var->thread.delta_start = 0;\n\t\tosn_var->thread.arrival_time = 0;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n#else  \nstatic inline bool timerlat_enabled(void)\n{\n\treturn false;\n}\n\nstatic inline int timerlat_softirq_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}\nstatic inline int timerlat_thread_exit(struct osnoise_variables *osn_var)\n{\n\treturn 1;\n}\n#endif\n\n#ifdef CONFIG_PREEMPT_RT\n \nstatic void print_osnoise_headers(struct seq_file *s)\n{\n\tif (osnoise_data.tainted)\n\t\tseq_puts(s, \"# osnoise is tainted!\\n\");\n\n\tseq_puts(s, \"#                                _-------=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _------=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _-----=> need-resched-lazy\\n\");\n\tseq_puts(s, \"#                              || / _----=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              ||| / _---=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              |||| / _--=> preempt-lazy-depth\\n\");\n\tseq_puts(s, \"#                              ||||| / _-=> migrate-disable\\n\");\n\n\tseq_puts(s, \"#                              |||||| /          \");\n\tseq_puts(s, \"                                     MAX\\n\");\n\n\tseq_puts(s, \"#                              ||||| /                         \");\n\tseq_puts(s, \"                    SINGLE      Interference counters:\\n\");\n\n\tseq_puts(s, \"#                              |||||||               RUNTIME   \");\n\tseq_puts(s, \"   NOISE  %% OF CPU  NOISE    +-----------------------------+\\n\");\n\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||||   TIMESTAMP    IN US    \");\n\tseq_puts(s, \"   IN US  AVAILABLE  IN US     HW    NMI    IRQ   SIRQ THREAD\\n\");\n\n\tseq_puts(s, \"#              | |         |   |||||||      |           |      \");\n\tseq_puts(s, \"       |    |            |      |      |      |      |      |\\n\");\n}\n#else  \nstatic void print_osnoise_headers(struct seq_file *s)\n{\n\tif (osnoise_data.tainted)\n\t\tseq_puts(s, \"# osnoise is tainted!\\n\");\n\n\tseq_puts(s, \"#                                _-----=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _----=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _---=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              || / _--=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              ||| / _-=> migrate-disable     \");\n\tseq_puts(s, \"                    MAX\\n\");\n\tseq_puts(s, \"#                              |||| /     delay               \");\n\tseq_puts(s, \"                    SINGLE      Interference counters:\\n\");\n\n\tseq_puts(s, \"#                              |||||               RUNTIME   \");\n\tseq_puts(s, \"   NOISE  %% OF CPU  NOISE    +-----------------------------+\\n\");\n\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||   TIMESTAMP    IN US    \");\n\tseq_puts(s, \"   IN US  AVAILABLE  IN US     HW    NMI    IRQ   SIRQ THREAD\\n\");\n\n\tseq_puts(s, \"#              | |         |   |||||      |           |      \");\n\tseq_puts(s, \"       |    |            |      |      |      |      |      |\\n\");\n}\n#endif  \n\n \n#define osnoise_taint(msg) ({\t\t\t\t\t\t\t\\\n\tstruct osnoise_instance *inst;\t\t\t\t\t\t\\\n\tstruct trace_buffer *buffer;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\trcu_read_lock();\t\t\t\t\t\t\t\\\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\t\t\\\n\t\tbuffer = inst->tr->array_buffer.buffer;\t\t\t\t\\\n\t\ttrace_array_printk_buf(buffer, _THIS_IP_, msg);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\trcu_read_unlock();\t\t\t\t\t\t\t\\\n\tosnoise_data.tainted = true;\t\t\t\t\t\t\\\n})\n\n \nstatic void\n__trace_osnoise_sample(struct osnoise_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct osnoise_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_OSNOISE, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->runtime\t\t= sample->runtime;\n\tentry->noise\t\t= sample->noise;\n\tentry->max_sample\t= sample->max_sample;\n\tentry->hw_count\t\t= sample->hw_count;\n\tentry->nmi_count\t= sample->nmi_count;\n\tentry->irq_count\t= sample->irq_count;\n\tentry->softirq_count\t= sample->softirq_count;\n\tentry->thread_count\t= sample->thread_count;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}\n\n \nstatic void trace_osnoise_sample(struct osnoise_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_osnoise_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \n#ifdef CONFIG_PREEMPT_RT\nstatic void print_timerlat_headers(struct seq_file *s)\n{\n\tseq_puts(s, \"#                                _-------=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _------=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _-----=> need-resched-lazy\\n\");\n\tseq_puts(s, \"#                              || / _----=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              ||| / _---=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              |||| / _--=> preempt-lazy-depth\\n\");\n\tseq_puts(s, \"#                              ||||| / _-=> migrate-disable\\n\");\n\tseq_puts(s, \"#                              |||||| /\\n\");\n\tseq_puts(s, \"#                              |||||||             ACTIVATION\\n\");\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||||   TIMESTAMP    ID     \");\n\tseq_puts(s, \"       CONTEXT                LATENCY\\n\");\n\tseq_puts(s, \"#              | |         |   |||||||      |         |      \");\n\tseq_puts(s, \"            |                       |\\n\");\n}\n#else  \nstatic void print_timerlat_headers(struct seq_file *s)\n{\n\tseq_puts(s, \"#                                _-----=> irqs-off\\n\");\n\tseq_puts(s, \"#                               / _----=> need-resched\\n\");\n\tseq_puts(s, \"#                              | / _---=> hardirq/softirq\\n\");\n\tseq_puts(s, \"#                              || / _--=> preempt-depth\\n\");\n\tseq_puts(s, \"#                              ||| / _-=> migrate-disable\\n\");\n\tseq_puts(s, \"#                              |||| /     delay\\n\");\n\tseq_puts(s, \"#                              |||||            ACTIVATION\\n\");\n\tseq_puts(s, \"#           TASK-PID      CPU# |||||   TIMESTAMP   ID      \");\n\tseq_puts(s, \"      CONTEXT                 LATENCY\\n\");\n\tseq_puts(s, \"#              | |         |   |||||      |         |      \");\n\tseq_puts(s, \"            |                       |\\n\");\n}\n#endif  \n\nstatic void\n__trace_timerlat_sample(struct timerlat_sample *sample, struct trace_buffer *buffer)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct timerlat_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_TIMERLAT, sizeof(*entry),\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->seqnum\t\t\t= sample->seqnum;\n\tentry->context\t\t\t= sample->context;\n\tentry->timer_latency\t\t= sample->timer_latency;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}\n\n \nstatic void trace_timerlat_sample(struct timerlat_sample *sample)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__trace_timerlat_sample(sample, buffer);\n\t}\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_STACKTRACE\n\n#define\tMAX_CALLS\t256\n\n \nstruct trace_stack {\n\tint\t\tstack_size;\n\tint\t\tnr_entries;\n\tunsigned long\tcalls[MAX_CALLS];\n};\n\nstatic DEFINE_PER_CPU(struct trace_stack, trace_stack);\n\n \nstatic void timerlat_save_stack(int skip)\n{\n\tunsigned int size, nr_entries;\n\tstruct trace_stack *fstack;\n\n\tfstack = this_cpu_ptr(&trace_stack);\n\n\tsize = ARRAY_SIZE(fstack->calls);\n\n\tnr_entries = stack_trace_save(fstack->calls, size, skip);\n\n\tfstack->stack_size = nr_entries * sizeof(unsigned long);\n\tfstack->nr_entries = nr_entries;\n\n\treturn;\n\n}\n\nstatic void\n__timerlat_dump_stack(struct trace_buffer *buffer, struct trace_stack *fstack, unsigned int size)\n{\n\tstruct trace_event_call *call = &event_osnoise;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_STACK, sizeof(*entry) + size,\n\t\t\t\t\t  tracing_gen_ctx());\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\n\tmemcpy(&entry->caller, fstack->calls, size);\n\tentry->size = fstack->nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}\n\n \nstatic void timerlat_dump_stack(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_buffer *buffer;\n\tstruct trace_stack *fstack;\n\tunsigned int size;\n\n\t \n\tif (!osnoise_data.print_stack || osnoise_data.print_stack > latency)\n\t\treturn;\n\n\tpreempt_disable_notrace();\n\tfstack = this_cpu_ptr(&trace_stack);\n\tsize = fstack->stack_size;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\tbuffer = inst->tr->array_buffer.buffer;\n\t\t__timerlat_dump_stack(buffer, fstack, size);\n\n\t}\n\trcu_read_unlock();\n\tpreempt_enable_notrace();\n}\n#else  \n#define timerlat_dump_stack(u64 latency) do {} while (0)\n#define timerlat_save_stack(a) do {} while (0)\n#endif  \n#endif  \n\n \n#define time_get()\ttrace_clock_local()\n#define time_to_us(x)\tdiv_u64(x, 1000)\n#define time_sub(a, b)\t((a) - (b))\n\n \nstatic inline void\ncond_move_irq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->irq.delta_start)\n\t\tosn_var->irq.delta_start += duration;\n}\n\n#ifndef CONFIG_PREEMPT_RT\n \nstatic inline void\ncond_move_softirq_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->softirq.delta_start)\n\t\tosn_var->softirq.delta_start += duration;\n}\n#else  \n#define cond_move_softirq_delta_start(osn_var, duration) do {} while (0)\n#endif\n\n \nstatic inline void\ncond_move_thread_delta_start(struct osnoise_variables *osn_var, u64 duration)\n{\n\tif (osn_var->thread.delta_start)\n\t\tosn_var->thread.delta_start += duration;\n}\n\n \nstatic inline s64\nget_int_safe_duration(struct osnoise_variables *osn_var, u64 *delta_start)\n{\n\tu64 int_counter, now;\n\ts64 duration;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t \n\t\tbarrier();\n\n\t\tnow = time_get();\n\t\tduration = (now - *delta_start);\n\n\t\t \n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\t \n\tif (duration < 0)\n\t\tosnoise_taint(\"Negative duration!\\n\");\n\n\t*delta_start = 0;\n\n\treturn duration;\n}\n\n \nstatic u64\nset_int_safe_time(struct osnoise_variables *osn_var, u64 *time)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t \n\t\tbarrier();\n\n\t\t*time = time_get();\n\n\t\t \n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \nstatic u64\ncopy_int_safe_time(struct osnoise_variables *osn_var, u64 *dst, u64 *src)\n{\n\tu64 int_counter;\n\n\tdo {\n\t\tint_counter = local_read(&osn_var->int_counter);\n\t\t \n\t\tbarrier();\n\n\t\t*dst = *src;\n\n\t\t \n\t\tbarrier();\n\t} while (int_counter != local_read(&osn_var->int_counter));\n\n\treturn int_counter;\n}\n#endif  \n\n \nvoid trace_osnoise_callback(bool enter)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\t \n\tif (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK)) {\n\t\tif (enter) {\n\t\t\tosn_var->nmi.delta_start = time_get();\n\t\t\tlocal_inc(&osn_var->int_counter);\n\t\t} else {\n\t\t\tduration = time_get() - osn_var->nmi.delta_start;\n\n\t\t\ttrace_nmi_noise(osn_var->nmi.delta_start, duration);\n\n\t\t\tcond_move_irq_delta_start(osn_var, duration);\n\t\t\tcond_move_softirq_delta_start(osn_var, duration);\n\t\t\tcond_move_thread_delta_start(osn_var, duration);\n\t\t}\n\t}\n\n\tif (enter)\n\t\tosn_var->nmi.count++;\n}\n\n \nvoid osnoise_trace_irq_entry(int id)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t \n\tosn_var->irq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->irq.delta_start);\n\tosn_var->irq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}\n\n \nvoid osnoise_trace_irq_exit(int id, const char *desc)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\ts64 duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->irq.delta_start);\n\ttrace_irq_noise(id, desc, osn_var->irq.arrival_time, duration);\n\tosn_var->irq.arrival_time = 0;\n\tcond_move_softirq_delta_start(osn_var, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n}\n\n \nstatic void trace_irqentry_callback(void *data, int irq,\n\t\t\t\t    struct irqaction *action)\n{\n\tosnoise_trace_irq_entry(irq);\n}\n\n \nstatic void trace_irqexit_callback(void *data, int irq,\n\t\t\t\t   struct irqaction *action, int ret)\n{\n\tosnoise_trace_irq_exit(irq, action->name);\n}\n\n \nint __weak osnoise_arch_register(void)\n{\n\treturn 0;\n}\n\n \nvoid __weak osnoise_arch_unregister(void)\n{\n\treturn;\n}\n\n \nstatic int hook_irq_events(void)\n{\n\tint ret;\n\n\tret = register_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = register_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tif (ret)\n\t\tgoto out_unregister_entry;\n\n\tret = osnoise_arch_register();\n\tif (ret)\n\t\tgoto out_irq_exit;\n\n\treturn 0;\n\nout_irq_exit:\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\nout_unregister_entry:\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\nout_err:\n\treturn -EINVAL;\n}\n\n \nstatic void unhook_irq_events(void)\n{\n\tosnoise_arch_unregister();\n\tunregister_trace_irq_handler_exit(trace_irqexit_callback, NULL);\n\tunregister_trace_irq_handler_entry(trace_irqentry_callback, NULL);\n}\n\n#ifndef CONFIG_PREEMPT_RT\n \nstatic void trace_softirq_entry_callback(void *data, unsigned int vec_nr)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\t \n\tosn_var->softirq.arrival_time = time_get();\n\tset_int_safe_time(osn_var, &osn_var->softirq.delta_start);\n\tosn_var->softirq.count++;\n\n\tlocal_inc(&osn_var->int_counter);\n}\n\n \nstatic void trace_softirq_exit_callback(void *data, unsigned int vec_nr)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\ts64 duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_softirq_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->softirq.delta_start);\n\ttrace_softirq_noise(vec_nr, osn_var->softirq.arrival_time, duration);\n\tcond_move_thread_delta_start(osn_var, duration);\n\tosn_var->softirq.arrival_time = 0;\n}\n\n \nstatic int hook_softirq_events(void)\n{\n\tint ret;\n\n\tret = register_trace_softirq_entry(trace_softirq_entry_callback, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = register_trace_softirq_exit(trace_softirq_exit_callback, NULL);\n\tif (ret)\n\t\tgoto out_unreg_entry;\n\n\treturn 0;\n\nout_unreg_entry:\n\tunregister_trace_softirq_entry(trace_softirq_entry_callback, NULL);\nout_err:\n\treturn -EINVAL;\n}\n\n \nstatic void unhook_softirq_events(void)\n{\n\tunregister_trace_softirq_entry(trace_softirq_entry_callback, NULL);\n\tunregister_trace_softirq_exit(trace_softirq_exit_callback, NULL);\n}\n#else  \n \nstatic int hook_softirq_events(void)\n{\n\treturn 0;\n}\nstatic void unhook_softirq_events(void)\n{\n}\n#endif\n\n \nstatic void\nthread_entry(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\tif (!osn_var->sampling)\n\t\treturn;\n\t \n\tosn_var->thread.arrival_time = time_get();\n\n\tset_int_safe_time(osn_var, &osn_var->thread.delta_start);\n\n\tosn_var->thread.count++;\n\tlocal_inc(&osn_var->int_counter);\n}\n\n \nstatic void\nthread_exit(struct osnoise_variables *osn_var, struct task_struct *t)\n{\n\ts64 duration;\n\n\tif (!osn_var->sampling)\n\t\treturn;\n\n\tif (unlikely(timerlat_enabled()))\n\t\tif (!timerlat_thread_exit(osn_var))\n\t\t\treturn;\n\n\tduration = get_int_safe_duration(osn_var, &osn_var->thread.delta_start);\n\n\ttrace_thread_noise(t, osn_var->thread.arrival_time, duration);\n\n\tosn_var->thread.arrival_time = 0;\n}\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \nstatic __always_inline void osnoise_stop_exception(char *msg, int cpu)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t       \"stop tracing hit on cpu %d due to exception: %s\\n\",\n\t\t\t\t       smp_processor_id(),\n\t\t\t\t       msg);\n\n\t\tif (test_bit(OSN_PANIC_ON_STOP, &osnoise_options))\n\t\t\tpanic(\"tracer hit on cpu %d due to exception: %s\\n\",\n\t\t\t      smp_processor_id(),\n\t\t\t      msg);\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void trace_sched_migrate_callback(void *data, struct task_struct *p, int dest_cpu)\n{\n\tstruct osnoise_variables *osn_var;\n\tlong cpu = task_cpu(p);\n\n\tosn_var = per_cpu_ptr(&per_cpu_osnoise_var, cpu);\n\tif (osn_var->pid == p->pid && dest_cpu != cpu) {\n\t\tper_cpu_ptr(&per_cpu_timerlat_var, cpu)->uthread_migrate = 1;\n\t\tosnoise_taint(\"timerlat user-thread migrated\\n\");\n\t\tosnoise_stop_exception(\"timerlat user-thread migrated\", cpu);\n\t}\n}\n\nstatic int register_migration_monitor(void)\n{\n\tint ret = 0;\n\n\t \n\tif (timerlat_enabled() && !test_bit(OSN_WORKLOAD, &osnoise_options))\n\t\tret = register_trace_sched_migrate_task(trace_sched_migrate_callback, NULL);\n\n\treturn ret;\n}\n\nstatic void unregister_migration_monitor(void)\n{\n\tif (timerlat_enabled() && !test_bit(OSN_WORKLOAD, &osnoise_options))\n\t\tunregister_trace_sched_migrate_task(trace_sched_migrate_callback, NULL);\n}\n#else\nstatic int register_migration_monitor(void)\n{\n\treturn 0;\n}\nstatic void unregister_migration_monitor(void) {}\n#endif\n \nstatic void\ntrace_sched_switch_callback(void *data, bool preempt,\n\t\t\t    struct task_struct *p,\n\t\t\t    struct task_struct *n,\n\t\t\t    unsigned int prev_state)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tint workload = test_bit(OSN_WORKLOAD, &osnoise_options);\n\n\tif ((p->pid != osn_var->pid) || !workload)\n\t\tthread_exit(osn_var, p);\n\n\tif ((n->pid != osn_var->pid) || !workload)\n\t\tthread_entry(osn_var, n);\n}\n\n \nstatic int hook_thread_events(void)\n{\n\tint ret;\n\n\tret = register_trace_sched_switch(trace_sched_switch_callback, NULL);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tret = register_migration_monitor();\n\tif (ret)\n\t\tgoto out_unreg;\n\n\treturn 0;\n\nout_unreg:\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n\treturn -EINVAL;\n}\n\n \nstatic void unhook_thread_events(void)\n{\n\tunregister_trace_sched_switch(trace_sched_switch_callback, NULL);\n\tunregister_migration_monitor();\n}\n\n \nstatic void\nsave_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count;\n\ts->irq_count = osn_var->irq.count;\n\ts->softirq_count = osn_var->softirq.count;\n\ts->thread_count = osn_var->thread.count;\n}\n\n \nstatic void\ndiff_osn_sample_stats(struct osnoise_variables *osn_var, struct osnoise_sample *s)\n{\n\ts->nmi_count = osn_var->nmi.count - s->nmi_count;\n\ts->irq_count = osn_var->irq.count - s->irq_count;\n\ts->softirq_count = osn_var->softirq.count - s->softirq_count;\n\ts->thread_count = osn_var->thread.count - s->thread_count;\n}\n\n \nstatic __always_inline void osnoise_stop_tracing(void)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\ttrace_array_printk_buf(tr->array_buffer.buffer, _THIS_IP_,\n\t\t\t\t\"stop tracing hit on cpu %d\\n\", smp_processor_id());\n\n\t\tif (test_bit(OSN_PANIC_ON_STOP, &osnoise_options))\n\t\t\tpanic(\"tracer hit stop condition on CPU %d\\n\", smp_processor_id());\n\n\t\ttracer_tracing_off(tr);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic __always_inline int osnoise_has_tracing_on(void)\n{\n\tstruct osnoise_instance *inst;\n\tint trace_is_on = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list)\n\t\ttrace_is_on += tracer_tracing_is_on(inst->tr);\n\trcu_read_unlock();\n\n\treturn trace_is_on;\n}\n\n \nstatic void notify_new_max_latency(u64 latency)\n{\n\tstruct osnoise_instance *inst;\n\tstruct trace_array *tr;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(inst, &osnoise_instances, list) {\n\t\ttr = inst->tr;\n\t\tif (tracer_tracing_is_on(tr) && tr->max_latency < latency) {\n\t\t\ttr->max_latency = latency;\n\t\t\tlatency_fsnotify(tr);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic int run_osnoise(void)\n{\n\tbool disable_irq = test_bit(OSN_IRQ_DISABLE, &osnoise_options);\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tu64 start, sample, last_sample;\n\tu64 last_int_count, int_count;\n\ts64 noise = 0, max_noise = 0;\n\ts64 total, last_total = 0;\n\tstruct osnoise_sample s;\n\tbool disable_preemption;\n\tunsigned int threshold;\n\tu64 runtime, stop_in;\n\tu64 sum_noise = 0;\n\tint hw_count = 0;\n\tint ret = -1;\n\n\t \n\tdisable_preemption = !disable_irq && test_bit(OSN_PREEMPT_DISABLE, &osnoise_options);\n\n\t \n\tosn_var->pid = current->pid;\n\n\t \n\tsave_osn_sample_stats(osn_var, &s);\n\n\t \n\tthreshold = tracing_thresh ? : 5000;\n\n\t \n\tif (disable_irq)\n\t\tlocal_irq_disable();\n\n\tif (disable_preemption)\n\t\tpreempt_disable();\n\n\t \n\tosn_var->sampling = true;\n\tbarrier();\n\n\t \n\truntime = osnoise_data.sample_runtime * NSEC_PER_USEC;\n\tstop_in = osnoise_data.stop_tracing * NSEC_PER_USEC;\n\n\t \n\tstart = time_get();\n\n\t \n\tlast_int_count = set_int_safe_time(osn_var, &last_sample);\n\n\tdo {\n\t\t \n\t\tint_count = set_int_safe_time(osn_var, &sample);\n\n\t\tnoise = time_sub(sample, last_sample);\n\n\t\t \n\t\tif (noise < 0) {\n\t\t\tosnoise_taint(\"negative noise!\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\ttotal = time_sub(sample, start);\n\n\t\t \n\t\tif (total < last_total) {\n\t\t\tosnoise_taint(\"total overflow!\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_total = total;\n\n\t\tif (noise >= threshold) {\n\t\t\tint interference = int_count - last_int_count;\n\n\t\t\tif (noise > max_noise)\n\t\t\t\tmax_noise = noise;\n\n\t\t\tif (!interference)\n\t\t\t\thw_count++;\n\n\t\t\tsum_noise += noise;\n\n\t\t\ttrace_sample_threshold(last_sample, noise, interference);\n\n\t\t\tif (osnoise_data.stop_tracing)\n\t\t\t\tif (noise > stop_in)\n\t\t\t\t\tosnoise_stop_tracing();\n\t\t}\n\n\t\t \n\t\tif (IS_ENABLED(CONFIG_PREEMPT_RCU)) {\n\t\t\tif (!disable_irq)\n\t\t\t\tlocal_irq_disable();\n\n\t\t\trcu_momentary_dyntick_idle();\n\n\t\t\tif (!disable_irq)\n\t\t\t\tlocal_irq_enable();\n\t\t}\n\n\t\t \n\t\tif (!disable_irq && !disable_preemption)\n\t\t\tcond_resched();\n\n\t\tlast_sample = sample;\n\t\tlast_int_count = int_count;\n\n\t} while (total < runtime && !kthread_should_stop());\n\n\t \n\tbarrier();\n\n\tosn_var->sampling = false;\n\n\t \n\tbarrier();\n\n\t \n\tif (disable_preemption)\n\t\tpreempt_enable();\n\n\tif (disable_irq)\n\t\tlocal_irq_enable();\n\n\t \n\ts.noise = time_to_us(sum_noise);\n\ts.runtime = time_to_us(total);\n\ts.max_sample = time_to_us(max_noise);\n\ts.hw_count = hw_count;\n\n\t \n\tdiff_osn_sample_stats(osn_var, &s);\n\n\ttrace_osnoise_sample(&s);\n\n\tnotify_new_max_latency(max_noise);\n\n\tif (osnoise_data.stop_tracing_total)\n\t\tif (s.noise > osnoise_data.stop_tracing_total)\n\t\t\tosnoise_stop_tracing();\n\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic struct cpumask osnoise_cpumask;\nstatic struct cpumask save_cpumask;\n\n \nstatic void osnoise_sleep(bool skip_period)\n{\n\tu64 interval;\n\tktime_t wake_time;\n\n\tmutex_lock(&interface_lock);\n\tif (skip_period)\n\t\tinterval = osnoise_data.sample_period;\n\telse\n\t\tinterval = osnoise_data.sample_period - osnoise_data.sample_runtime;\n\tmutex_unlock(&interface_lock);\n\n\t \n\tif (!interval) {\n\t\t \n\t\tcond_resched_tasks_rcu_qs();\n\t\treturn;\n\t}\n\n\twake_time = ktime_add_us(ktime_get(), interval);\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (schedule_hrtimeout(&wake_time, HRTIMER_MODE_ABS)) {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t}\n}\n\n \nstatic inline int osnoise_migration_pending(void)\n{\n\tif (!current->migration_pending)\n\t\treturn 0;\n\n\t \n\tosnoise_taint(\"migration requested to osnoise threads, leaving.\");\n\n\t \n\tmutex_lock(&interface_lock);\n\tthis_cpu_osn_var()->kthread = NULL;\n\tmutex_unlock(&interface_lock);\n\n\treturn 1;\n}\n\n \nstatic int osnoise_main(void *data)\n{\n\tunsigned long flags;\n\n\t \n\tmigrate_disable();\n\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\tcurrent->flags &= ~(PF_NO_SETAFFINITY);\n\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (osnoise_migration_pending())\n\t\t\tbreak;\n\n\t\t \n\t\tif (!osnoise_has_tracing_on()) {\n\t\t\tosnoise_sleep(true);\n\t\t\tcontinue;\n\t\t}\n\n\t\trun_osnoise();\n\t\tosnoise_sleep(false);\n\t}\n\n\tmigrate_enable();\n\treturn 0;\n}\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \nstatic enum hrtimer_restart timerlat_irq(struct hrtimer *timer)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tstruct timerlat_variables *tlat;\n\tstruct timerlat_sample s;\n\tu64 now;\n\tu64 diff;\n\n\t \n\ttlat = container_of(timer, struct timerlat_variables, timer);\n\n\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\n\t \n\ttlat->tracing_thread = true;\n\n\tosn_var->thread.arrival_time = time_get();\n\n\t \n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT) && osn_var->softirq.delta_start) {\n\t\tcopy_int_safe_time(osn_var, &osn_var->thread.delta_start,\n\t\t\t\t   &osn_var->softirq.delta_start);\n\n\t\tcopy_int_safe_time(osn_var, &osn_var->softirq.delta_start,\n\t\t\t\t    &osn_var->irq.delta_start);\n\t} else {\n\t\tcopy_int_safe_time(osn_var, &osn_var->thread.delta_start,\n\t\t\t\t    &osn_var->irq.delta_start);\n\t}\n\n\t \n\tdiff = now - tlat->abs_period;\n\n\ttlat->count++;\n\ts.seqnum = tlat->count;\n\ts.timer_latency = diff;\n\ts.context = IRQ_CONTEXT;\n\n\ttrace_timerlat_sample(&s);\n\n\tif (osnoise_data.stop_tracing) {\n\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing) {\n\n\t\t\t \n\t\t\tif (osnoise_data.stop_tracing <= osnoise_data.print_stack) {\n\t\t\t\ttimerlat_save_stack(0);\n\t\t\t\ttimerlat_dump_stack(time_to_us(diff));\n\t\t\t}\n\n\t\t\tosnoise_stop_tracing();\n\t\t\tnotify_new_max_latency(diff);\n\n\t\t\twake_up_process(tlat->kthread);\n\n\t\t\treturn HRTIMER_NORESTART;\n\t\t}\n\t}\n\n\twake_up_process(tlat->kthread);\n\n\tif (osnoise_data.print_stack)\n\t\ttimerlat_save_stack(0);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic int wait_next_period(struct timerlat_variables *tlat)\n{\n\tktime_t next_abs_period, now;\n\tu64 rel_period = osnoise_data.timerlat_period * 1000;\n\n\tnow = hrtimer_cb_get_time(&tlat->timer);\n\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\n\t \n\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\n\t \n\twhile (ktime_compare(now, next_abs_period) > 0) {\n\t\tnext_abs_period = ns_to_ktime(tlat->abs_period + rel_period);\n\t\ttlat->abs_period = (u64) ktime_to_ns(next_abs_period);\n\t}\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\thrtimer_start(&tlat->timer, next_abs_period, HRTIMER_MODE_ABS_PINNED_HARD);\n\tschedule();\n\treturn 1;\n}\n\n \nstatic int timerlat_main(void *data)\n{\n\tstruct osnoise_variables *osn_var = this_cpu_osn_var();\n\tstruct timerlat_variables *tlat = this_cpu_tmr_var();\n\tstruct timerlat_sample s;\n\tstruct sched_param sp;\n\tunsigned long flags;\n\tu64 now, diff;\n\n\t \n\tsp.sched_priority = DEFAULT_TIMERLAT_PRIO;\n\tsched_setscheduler_nocheck(current, SCHED_FIFO, &sp);\n\n\t \n\tmigrate_disable();\n\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\tcurrent->flags &= ~(PF_NO_SETAFFINITY);\n\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\n\ttlat->count = 0;\n\ttlat->tracing_thread = false;\n\n\thrtimer_init(&tlat->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED_HARD);\n\ttlat->timer.function = timerlat_irq;\n\ttlat->kthread = current;\n\tosn_var->pid = current->pid;\n\t \n\ttlat->abs_period = hrtimer_cb_get_time(&tlat->timer);\n\n\twait_next_period(tlat);\n\n\tosn_var->sampling = 1;\n\n\twhile (!kthread_should_stop()) {\n\n\t\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\t\tdiff = now - tlat->abs_period;\n\n\t\ts.seqnum = tlat->count;\n\t\ts.timer_latency = diff;\n\t\ts.context = THREAD_CONTEXT;\n\n\t\ttrace_timerlat_sample(&s);\n\n\t\tnotify_new_max_latency(diff);\n\n\t\ttimerlat_dump_stack(time_to_us(diff));\n\n\t\ttlat->tracing_thread = false;\n\t\tif (osnoise_data.stop_tracing_total)\n\t\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing_total)\n\t\t\t\tosnoise_stop_tracing();\n\n\t\tif (osnoise_migration_pending())\n\t\t\tbreak;\n\n\t\twait_next_period(tlat);\n\t}\n\n\thrtimer_cancel(&tlat->timer);\n\tmigrate_enable();\n\treturn 0;\n}\n#else  \nstatic int timerlat_main(void *data)\n{\n\treturn 0;\n}\n#endif  \n\n \nstatic void stop_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\n\tkthread = per_cpu(per_cpu_osnoise_var, cpu).kthread;\n\tif (kthread) {\n\t\tif (test_bit(OSN_WORKLOAD, &osnoise_options)) {\n\t\t\tkthread_stop(kthread);\n\t\t} else {\n\t\t\t \n\t\t\tkill_pid(kthread->thread_pid, SIGKILL, 1);\n\t\t\tput_task_struct(kthread);\n\t\t}\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\t} else {\n\t\t \n\t\tif (!test_bit(OSN_WORKLOAD, &osnoise_options)) {\n\t\t\t \n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = false;\n\t\t\tbarrier();\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic void stop_per_cpu_kthreads(void)\n{\n\tint cpu;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu)\n\t\tstop_kthread(cpu);\n\n\tcpus_read_unlock();\n}\n\n \nstatic int start_kthread(unsigned int cpu)\n{\n\tstruct task_struct *kthread;\n\tvoid *main = osnoise_main;\n\tchar comm[24];\n\n\tif (timerlat_enabled()) {\n\t\tsnprintf(comm, 24, \"timerlat/%d\", cpu);\n\t\tmain = timerlat_main;\n\t} else {\n\t\t \n\t\tif (!test_bit(OSN_WORKLOAD, &osnoise_options)) {\n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = true;\n\t\t\tbarrier();\n\t\t\treturn 0;\n\t\t}\n\t\tsnprintf(comm, 24, \"osnoise/%d\", cpu);\n\t}\n\n\tkthread = kthread_run_on_cpu(main, NULL, cpu, comm);\n\n\tif (IS_ERR(kthread)) {\n\t\tpr_err(BANNER \"could not start sampling thread\\n\");\n\t\tstop_per_cpu_kthreads();\n\t\treturn -ENOMEM;\n\t}\n\n\tper_cpu(per_cpu_osnoise_var, cpu).kthread = kthread;\n\n\treturn 0;\n}\n\n \nstatic int start_per_cpu_kthreads(void)\n{\n\tstruct cpumask *current_mask = &save_cpumask;\n\tint retval = 0;\n\tint cpu;\n\n\tif (!test_bit(OSN_WORKLOAD, &osnoise_options)) {\n\t\tif (timerlat_enabled())\n\t\t\treturn 0;\n\t}\n\n\tcpus_read_lock();\n\t \n\tcpumask_and(current_mask, cpu_online_mask, &osnoise_cpumask);\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(per_cpu_osnoise_var, cpu).kthread = NULL;\n\n\tfor_each_cpu(cpu, current_mask) {\n\t\tretval = start_kthread(cpu);\n\t\tif (retval) {\n\t\t\tcpus_read_unlock();\n\t\t\tstop_per_cpu_kthreads();\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tcpus_read_unlock();\n\n\treturn retval;\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic void osnoise_hotplug_workfn(struct work_struct *dummy)\n{\n\tunsigned int cpu = smp_processor_id();\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!osnoise_has_registered_instances())\n\t\tgoto out_unlock_trace;\n\n\tmutex_lock(&interface_lock);\n\tcpus_read_lock();\n\n\tif (!cpumask_test_cpu(cpu, &osnoise_cpumask))\n\t\tgoto out_unlock;\n\n\tstart_kthread(cpu);\n\nout_unlock:\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\nout_unlock_trace:\n\tmutex_unlock(&trace_types_lock);\n}\n\nstatic DECLARE_WORK(osnoise_hotplug_work, osnoise_hotplug_workfn);\n\n \nstatic int osnoise_cpu_init(unsigned int cpu)\n{\n\tschedule_work_on(cpu, &osnoise_hotplug_work);\n\treturn 0;\n}\n\n \nstatic int osnoise_cpu_die(unsigned int cpu)\n{\n\tstop_kthread(cpu);\n\treturn 0;\n}\n\nstatic void osnoise_init_hotplug_support(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"trace/osnoise:online\",\n\t\t\t\tosnoise_cpu_init, osnoise_cpu_die);\n\tif (ret < 0)\n\t\tpr_warn(BANNER \"Error to init cpu hotplug support\\n\");\n\n\treturn;\n}\n#else  \nstatic void osnoise_init_hotplug_support(void)\n{\n\treturn;\n}\n#endif  \n\n \nstatic void *s_options_start(struct seq_file *s, loff_t *pos)\n{\n\tint option = *pos;\n\n\tmutex_lock(&interface_lock);\n\n\tif (option >= OSN_MAX)\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic void *s_options_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tint option = ++(*pos);\n\n\tif (option >= OSN_MAX)\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic int s_options_show(struct seq_file *s, void *v)\n{\n\tloff_t *pos = v;\n\tint option = *pos;\n\n\tif (option == OSN_DEFAULTS) {\n\t\tif (osnoise_options == OSN_DEFAULT_OPTIONS)\n\t\t\tseq_printf(s, \"%s\", osnoise_options_str[option]);\n\t\telse\n\t\t\tseq_printf(s, \"NO_%s\", osnoise_options_str[option]);\n\t\tgoto out;\n\t}\n\n\tif (test_bit(option, &osnoise_options))\n\t\tseq_printf(s, \"%s\", osnoise_options_str[option]);\n\telse\n\t\tseq_printf(s, \"NO_%s\", osnoise_options_str[option]);\n\nout:\n\tif (option != OSN_MAX)\n\t\tseq_puts(s, \" \");\n\n\treturn 0;\n}\n\nstatic void s_options_stop(struct seq_file *s, void *v)\n{\n\tseq_puts(s, \"\\n\");\n\tmutex_unlock(&interface_lock);\n}\n\nstatic const struct seq_operations osnoise_options_seq_ops = {\n\t.start\t\t= s_options_start,\n\t.next\t\t= s_options_next,\n\t.show\t\t= s_options_show,\n\t.stop\t\t= s_options_stop\n};\n\nstatic int osnoise_options_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &osnoise_options_seq_ops);\n};\n\n \nstatic ssize_t osnoise_options_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t     size_t cnt, loff_t *ppos)\n{\n\tint running, option, enable, retval;\n\tchar buf[256], *option_str;\n\n\tif (cnt >= 256)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tif (strncmp(buf, \"NO_\", 3)) {\n\t\toption_str = strstrip(buf);\n\t\tenable = true;\n\t} else {\n\t\toption_str = strstrip(&buf[3]);\n\t\tenable = false;\n\t}\n\n\toption = match_string(osnoise_options_str, OSN_MAX, option_str);\n\tif (option < 0)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&trace_types_lock);\n\trunning = osnoise_has_registered_instances();\n\tif (running)\n\t\tstop_per_cpu_kthreads();\n\n\tmutex_lock(&interface_lock);\n\t \n\tcpus_read_lock();\n\n\tretval = cnt;\n\n\tif (enable) {\n\t\tif (option == OSN_DEFAULTS)\n\t\t\tosnoise_options = OSN_DEFAULT_OPTIONS;\n\t\telse\n\t\t\tset_bit(option, &osnoise_options);\n\t} else {\n\t\tif (option == OSN_DEFAULTS)\n\t\t\tretval = -EINVAL;\n\t\telse\n\t\t\tclear_bit(option, &osnoise_options);\n\t}\n\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\n\n\tif (running)\n\t\tstart_per_cpu_kthreads();\n\tmutex_unlock(&trace_types_lock);\n\n\treturn retval;\n}\n\n \nstatic ssize_t\nosnoise_cpus_read(struct file *filp, char __user *ubuf, size_t count,\n\t\t  loff_t *ppos)\n{\n\tchar *mask_str;\n\tint len;\n\n\tmutex_lock(&interface_lock);\n\n\tlen = snprintf(NULL, 0, \"%*pbl\\n\", cpumask_pr_args(&osnoise_cpumask)) + 1;\n\tmask_str = kmalloc(len, GFP_KERNEL);\n\tif (!mask_str) {\n\t\tcount = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = snprintf(mask_str, len, \"%*pbl\\n\", cpumask_pr_args(&osnoise_cpumask));\n\tif (len >= count) {\n\t\tcount = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tcount = simple_read_from_buffer(ubuf, count, ppos, mask_str, len);\n\nout_free:\n\tkfree(mask_str);\nout_unlock:\n\tmutex_unlock(&interface_lock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nosnoise_cpus_write(struct file *filp, const char __user *ubuf, size_t count,\n\t\t   loff_t *ppos)\n{\n\tcpumask_var_t osnoise_cpumask_new;\n\tint running, err;\n\tchar buf[256];\n\n\tif (count >= 256)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, count))\n\t\treturn -EFAULT;\n\n\tif (!zalloc_cpumask_var(&osnoise_cpumask_new, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpulist_parse(buf, osnoise_cpumask_new);\n\tif (err)\n\t\tgoto err_free;\n\n\t \n\tmutex_lock(&trace_types_lock);\n\trunning = osnoise_has_registered_instances();\n\tif (running)\n\t\tstop_per_cpu_kthreads();\n\n\tmutex_lock(&interface_lock);\n\t \n\tcpus_read_lock();\n\n\tcpumask_copy(&osnoise_cpumask, osnoise_cpumask_new);\n\n\tcpus_read_unlock();\n\tmutex_unlock(&interface_lock);\n\n\tif (running)\n\t\tstart_per_cpu_kthreads();\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(osnoise_cpumask_new);\n\treturn count;\n\nerr_free:\n\tfree_cpumask_var(osnoise_cpumask_new);\n\n\treturn err;\n}\n\n#ifdef CONFIG_TIMERLAT_TRACER\nstatic int timerlat_fd_open(struct inode *inode, struct file *file)\n{\n\tstruct osnoise_variables *osn_var;\n\tstruct timerlat_variables *tlat;\n\tlong cpu = (long) inode->i_cdev;\n\n\tmutex_lock(&interface_lock);\n\n\t \n\tif (!timerlat_enabled() || test_bit(OSN_WORKLOAD, &osnoise_options)) {\n\t\tmutex_unlock(&interface_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmigrate_disable();\n\n\tosn_var = this_cpu_osn_var();\n\n\t \n\tif (osn_var->pid) {\n\t\tmutex_unlock(&interface_lock);\n\t\tmigrate_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (current->nr_cpus_allowed > 1 ||  cpu != smp_processor_id()) {\n\t\tmutex_unlock(&interface_lock);\n\t\tmigrate_enable();\n\t\treturn -EPERM;\n\t}\n\n\t \n\tfile->private_data = inode->i_cdev;\n\n\tget_task_struct(current);\n\n\tosn_var->kthread = current;\n\tosn_var->pid = current->pid;\n\n\t \n\tmutex_unlock(&interface_lock);\n\n\ttlat = this_cpu_tmr_var();\n\ttlat->count = 0;\n\n\tmigrate_enable();\n\treturn 0;\n};\n\n \nstatic ssize_t\ntimerlat_fd_read(struct file *file, char __user *ubuf, size_t count,\n\t\t  loff_t *ppos)\n{\n\tlong cpu = (long) file->private_data;\n\tstruct osnoise_variables *osn_var;\n\tstruct timerlat_variables *tlat;\n\tstruct timerlat_sample s;\n\ts64 diff;\n\tu64 now;\n\n\tmigrate_disable();\n\n\ttlat = this_cpu_tmr_var();\n\n\t \n\tif (cpu == smp_processor_id()) {\n\t\tif (tlat->uthread_migrate) {\n\t\t\tmigrate_enable();\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tper_cpu_ptr(&per_cpu_timerlat_var, cpu)->uthread_migrate = 1;\n\t\tosnoise_taint(\"timerlat user thread migrate\\n\");\n\t\tosnoise_stop_tracing();\n\t\tmigrate_enable();\n\t\treturn -EINVAL;\n\t}\n\n\tosn_var = this_cpu_osn_var();\n\n\t \n\tif (likely(osn_var->sampling)) {\n\t\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\t\tdiff = now - tlat->abs_period;\n\n\t\t \n\t\tif (diff < 0)\n\t\t\tgoto out;\n\n\t\ts.seqnum = tlat->count;\n\t\ts.timer_latency = diff;\n\t\ts.context = THREAD_URET;\n\n\t\ttrace_timerlat_sample(&s);\n\n\t\tnotify_new_max_latency(diff);\n\n\t\ttlat->tracing_thread = false;\n\t\tif (osnoise_data.stop_tracing_total)\n\t\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing_total)\n\t\t\t\tosnoise_stop_tracing();\n\t} else {\n\t\ttlat->tracing_thread = false;\n\t\ttlat->kthread = current;\n\n\t\thrtimer_init(&tlat->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED_HARD);\n\t\ttlat->timer.function = timerlat_irq;\n\n\t\t \n\t\ttlat->abs_period = hrtimer_cb_get_time(&tlat->timer);\n\n\t\tosn_var->sampling = 1;\n\t}\n\n\t \n\twait_next_period(tlat);\n\n\t \n\tnow = ktime_to_ns(hrtimer_cb_get_time(&tlat->timer));\n\tdiff = now - tlat->abs_period;\n\n\t \n\tif (diff < 0)\n\t\tgoto out;\n\n\ts.seqnum = tlat->count;\n\ts.timer_latency = diff;\n\ts.context = THREAD_CONTEXT;\n\n\ttrace_timerlat_sample(&s);\n\n\tif (osnoise_data.stop_tracing_total) {\n\t\tif (time_to_us(diff) >= osnoise_data.stop_tracing_total) {\n\t\t\ttimerlat_dump_stack(time_to_us(diff));\n\t\t\tnotify_new_max_latency(diff);\n\t\t\tosnoise_stop_tracing();\n\t\t}\n\t}\n\nout:\n\tmigrate_enable();\n\treturn 0;\n}\n\nstatic int timerlat_fd_release(struct inode *inode, struct file *file)\n{\n\tstruct osnoise_variables *osn_var;\n\tstruct timerlat_variables *tlat_var;\n\tlong cpu = (long) file->private_data;\n\n\tmigrate_disable();\n\tmutex_lock(&interface_lock);\n\n\tosn_var = per_cpu_ptr(&per_cpu_osnoise_var, cpu);\n\ttlat_var = per_cpu_ptr(&per_cpu_timerlat_var, cpu);\n\n\thrtimer_cancel(&tlat_var->timer);\n\tmemset(tlat_var, 0, sizeof(*tlat_var));\n\n\tosn_var->sampling = 0;\n\tosn_var->pid = 0;\n\n\t \n\tif (osn_var->kthread) {\n\t\tput_task_struct(osn_var->kthread);\n\t\tosn_var->kthread = NULL;\n\t}\n\n\tmutex_unlock(&interface_lock);\n\tmigrate_enable();\n\treturn 0;\n}\n#endif\n\n \nstatic struct trace_min_max_param osnoise_runtime = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_runtime,\n\t.max\t= &osnoise_data.sample_period,\n\t.min\t= NULL,\n};\n\n \nstatic struct trace_min_max_param osnoise_period = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.sample_period,\n\t.max\t= NULL,\n\t.min\t= &osnoise_data.sample_runtime,\n};\n\n \nstatic struct trace_min_max_param osnoise_stop_tracing_in = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\n\n \nstatic struct trace_min_max_param osnoise_stop_tracing_total = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.stop_tracing_total,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\n\n#ifdef CONFIG_TIMERLAT_TRACER\n \nstatic struct trace_min_max_param osnoise_print_stack = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.print_stack,\n\t.max\t= NULL,\n\t.min\t= NULL,\n};\n\n \nstatic u64 timerlat_min_period = 100;\nstatic u64 timerlat_max_period = 1000000;\nstatic struct trace_min_max_param timerlat_period = {\n\t.lock\t= &interface_lock,\n\t.val\t= &osnoise_data.timerlat_period,\n\t.max\t= &timerlat_max_period,\n\t.min\t= &timerlat_min_period,\n};\n\nstatic const struct file_operations timerlat_fd_fops = {\n\t.open\t\t= timerlat_fd_open,\n\t.read\t\t= timerlat_fd_read,\n\t.release\t= timerlat_fd_release,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\nstatic const struct file_operations cpus_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= osnoise_cpus_read,\n\t.write\t\t= osnoise_cpus_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations osnoise_options_fops = {\n\t.open\t\t= osnoise_options_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= osnoise_options_write\n};\n\n#ifdef CONFIG_TIMERLAT_TRACER\n#ifdef CONFIG_STACKTRACE\nstatic int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\tstruct dentry *tmp;\n\n\ttmp = tracefs_create_file(\"print_stack\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_print_stack, &trace_min_max_fops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n#else  \nstatic int init_timerlat_stack_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int osnoise_create_cpu_timerlat_fd(struct dentry *top_dir)\n{\n\tstruct dentry *timerlat_fd;\n\tstruct dentry *per_cpu;\n\tstruct dentry *cpu_dir;\n\tchar cpu_str[30];  \n\tlong cpu;\n\n\t \n\tper_cpu = tracefs_create_dir(\"per_cpu\", top_dir);\n\tif (!per_cpu)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsnprintf(cpu_str, 30, \"cpu%ld\", cpu);\n\t\tcpu_dir = tracefs_create_dir(cpu_str, per_cpu);\n\t\tif (!cpu_dir)\n\t\t\tgoto out_clean;\n\n\t\ttimerlat_fd = trace_create_file(\"timerlat_fd\", TRACE_MODE_READ,\n\t\t\t\t\t\tcpu_dir, NULL, &timerlat_fd_fops);\n\t\tif (!timerlat_fd)\n\t\t\tgoto out_clean;\n\n\t\t \n\t\td_inode(timerlat_fd)->i_cdev = (void *)(cpu);\n\t}\n\n\treturn 0;\n\nout_clean:\n\ttracefs_remove(per_cpu);\n\treturn -ENOMEM;\n}\n\n \nstatic int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\tstruct dentry *tmp;\n\tint retval;\n\n\ttmp = tracefs_create_file(\"timerlat_period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &timerlat_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tretval = osnoise_create_cpu_timerlat_fd(top_dir);\n\tif (retval)\n\t\treturn retval;\n\n\treturn init_timerlat_stack_tracefs(top_dir);\n}\n#else  \nstatic int init_timerlat_tracefs(struct dentry *top_dir)\n{\n\treturn 0;\n}\n#endif  \n\n \nstatic int init_tracefs(void)\n{\n\tstruct dentry *top_dir;\n\tstruct dentry *tmp;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttop_dir = tracefs_create_dir(\"osnoise\", NULL);\n\tif (!top_dir)\n\t\treturn 0;\n\n\ttmp = tracefs_create_file(\"period_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_period, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"runtime_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_runtime, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_in, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = tracefs_create_file(\"stop_tracing_total_us\", TRACE_MODE_WRITE, top_dir,\n\t\t\t\t  &osnoise_stop_tracing_total, &trace_min_max_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = trace_create_file(\"cpus\", TRACE_MODE_WRITE, top_dir, NULL, &cpus_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\ttmp = trace_create_file(\"options\", TRACE_MODE_WRITE, top_dir, NULL,\n\t\t\t\t&osnoise_options_fops);\n\tif (!tmp)\n\t\tgoto err;\n\n\tret = init_timerlat_tracefs(top_dir);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\ttracefs_remove(top_dir);\n\treturn -ENOMEM;\n}\n\nstatic int osnoise_hook_events(void)\n{\n\tint retval;\n\n\t \n\tif (trace_osnoise_callback_enabled)\n\t\treturn 0;\n\n\tretval = hook_irq_events();\n\tif (retval)\n\t\treturn -EINVAL;\n\n\tretval = hook_softirq_events();\n\tif (retval)\n\t\tgoto out_unhook_irq;\n\n\tretval = hook_thread_events();\n\t \n\tif (!retval)\n\t\treturn 0;\n\n\tunhook_softirq_events();\nout_unhook_irq:\n\tunhook_irq_events();\n\treturn -EINVAL;\n}\n\nstatic void osnoise_unhook_events(void)\n{\n\tunhook_thread_events();\n\tunhook_softirq_events();\n\tunhook_irq_events();\n}\n\n \nstatic int osnoise_workload_start(void)\n{\n\tint retval;\n\n\t \n\tif (osnoise_has_registered_instances())\n\t\treturn 0;\n\n\tosn_var_reset_all();\n\n\tretval = osnoise_hook_events();\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tbarrier();\n\ttrace_osnoise_callback_enabled = true;\n\n\tretval = start_per_cpu_kthreads();\n\tif (retval) {\n\t\ttrace_osnoise_callback_enabled = false;\n\t\t \n\t\tbarrier();\n\n\t\tosnoise_unhook_events();\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void osnoise_workload_stop(void)\n{\n\t \n\tif (osnoise_has_registered_instances())\n\t\treturn;\n\n\t \n\tif (!trace_osnoise_callback_enabled)\n\t\treturn;\n\n\ttrace_osnoise_callback_enabled = false;\n\t \n\tbarrier();\n\n\tstop_per_cpu_kthreads();\n\n\tosnoise_unhook_events();\n}\n\nstatic void osnoise_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t \n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting osnoise tracer\\n\");\n\n\tosnoise_register_instance(tr);\n}\n\nstatic void osnoise_tracer_stop(struct trace_array *tr)\n{\n\tosnoise_unregister_instance(tr);\n\tosnoise_workload_stop();\n}\n\nstatic int osnoise_tracer_init(struct trace_array *tr)\n{\n\t \n\tif (timerlat_enabled())\n\t\treturn -EBUSY;\n\n\ttr->max_latency = 0;\n\n\tosnoise_tracer_start(tr);\n\treturn 0;\n}\n\nstatic void osnoise_tracer_reset(struct trace_array *tr)\n{\n\tosnoise_tracer_stop(tr);\n}\n\nstatic struct tracer osnoise_tracer __read_mostly = {\n\t.name\t\t= \"osnoise\",\n\t.init\t\t= osnoise_tracer_init,\n\t.reset\t\t= osnoise_tracer_reset,\n\t.start\t\t= osnoise_tracer_start,\n\t.stop\t\t= osnoise_tracer_stop,\n\t.print_header\t= print_osnoise_headers,\n\t.allow_instances = true,\n};\n\n#ifdef CONFIG_TIMERLAT_TRACER\nstatic void timerlat_tracer_start(struct trace_array *tr)\n{\n\tint retval;\n\n\t \n\tif (osnoise_instance_registered(tr))\n\t\treturn;\n\n\tretval = osnoise_workload_start();\n\tif (retval)\n\t\tpr_err(BANNER \"Error starting timerlat tracer\\n\");\n\n\tosnoise_register_instance(tr);\n\n\treturn;\n}\n\nstatic void timerlat_tracer_stop(struct trace_array *tr)\n{\n\tint cpu;\n\n\tosnoise_unregister_instance(tr);\n\n\t \n\tif (!osnoise_has_registered_instances()) {\n\t\tfor_each_online_cpu(cpu)\n\t\t\tper_cpu(per_cpu_osnoise_var, cpu).sampling = 0;\n\t}\n\n\tosnoise_workload_stop();\n}\n\nstatic int timerlat_tracer_init(struct trace_array *tr)\n{\n\t \n\tif (osnoise_has_registered_instances() && !osnoise_data.timerlat_tracer)\n\t\treturn -EBUSY;\n\n\t \n\tif (!osnoise_has_registered_instances())\n\t\tosnoise_data.timerlat_tracer = 1;\n\n\ttr->max_latency = 0;\n\ttimerlat_tracer_start(tr);\n\n\treturn 0;\n}\n\nstatic void timerlat_tracer_reset(struct trace_array *tr)\n{\n\ttimerlat_tracer_stop(tr);\n\n\t \n\tif (!osnoise_has_registered_instances())\n\t\tosnoise_data.timerlat_tracer = 0;\n}\n\nstatic struct tracer timerlat_tracer __read_mostly = {\n\t.name\t\t= \"timerlat\",\n\t.init\t\t= timerlat_tracer_init,\n\t.reset\t\t= timerlat_tracer_reset,\n\t.start\t\t= timerlat_tracer_start,\n\t.stop\t\t= timerlat_tracer_stop,\n\t.print_header\t= print_timerlat_headers,\n\t.allow_instances = true,\n};\n\n__init static int init_timerlat_tracer(void)\n{\n\treturn register_tracer(&timerlat_tracer);\n}\n#else  \n__init static int init_timerlat_tracer(void)\n{\n\treturn 0;\n}\n#endif  \n\n__init static int init_osnoise_tracer(void)\n{\n\tint ret;\n\n\tmutex_init(&interface_lock);\n\n\tcpumask_copy(&osnoise_cpumask, cpu_all_mask);\n\n\tret = register_tracer(&osnoise_tracer);\n\tif (ret) {\n\t\tpr_err(BANNER \"Error registering osnoise!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = init_timerlat_tracer();\n\tif (ret) {\n\t\tpr_err(BANNER \"Error registering timerlat!\\n\");\n\t\treturn ret;\n\t}\n\n\tosnoise_init_hotplug_support();\n\n\tINIT_LIST_HEAD_RCU(&osnoise_instances);\n\n\tinit_tracefs();\n\n\treturn 0;\n}\nlate_initcall(init_osnoise_tracer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}