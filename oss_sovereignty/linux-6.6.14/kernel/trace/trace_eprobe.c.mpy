{
  "module_name": "trace_eprobe.c",
  "hash_id": "5fc04233d313426954a038b2c12dc5147d513639b886779cad554fd591dd4176",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_eprobe.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/ftrace.h>\n\n#include \"trace_dynevent.h\"\n#include \"trace_probe.h\"\n#include \"trace_probe_tmpl.h\"\n#include \"trace_probe_kernel.h\"\n\n#define EPROBE_EVENT_SYSTEM \"eprobes\"\n\nstruct trace_eprobe {\n\t \n\tconst char *event_system;\n\n\t \n\tconst char *event_name;\n\n\t \n\tchar *filter_str;\n\n\tstruct trace_event_call *event;\n\n\tstruct dyn_event\tdevent;\n\tstruct trace_probe\ttp;\n};\n\nstruct eprobe_data {\n\tstruct trace_event_file\t*file;\n\tstruct trace_eprobe\t*ep;\n};\n\n\n#define for_each_trace_eprobe_tp(ep, _tp) \\\n\tlist_for_each_entry(ep, trace_probe_probe_list(_tp), tp.list)\n\nstatic int __trace_eprobe_create(int argc, const char *argv[]);\n\nstatic void trace_event_probe_cleanup(struct trace_eprobe *ep)\n{\n\tif (!ep)\n\t\treturn;\n\ttrace_probe_cleanup(&ep->tp);\n\tkfree(ep->event_name);\n\tkfree(ep->event_system);\n\tif (ep->event)\n\t\ttrace_event_put_ref(ep->event);\n\tkfree(ep->filter_str);\n\tkfree(ep);\n}\n\nstatic struct trace_eprobe *to_trace_eprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_eprobe, devent);\n}\n\nstatic int eprobe_dyn_event_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_eprobe_create);\n}\n\nstatic int eprobe_dyn_event_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tint i;\n\n\tseq_printf(m, \"e:%s/%s\", trace_probe_group_name(&ep->tp),\n\t\t\t\ttrace_probe_name(&ep->tp));\n\tseq_printf(m, \" %s.%s\", ep->event_system, ep->event_name);\n\n\tfor (i = 0; i < ep->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", ep->tp.args[i].name, ep->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic int unregister_trace_eprobe(struct trace_eprobe *ep)\n{\n\t \n\tif (trace_probe_has_sibling(&ep->tp))\n\t\tgoto unreg;\n\n\t \n\tif (trace_probe_is_enabled(&ep->tp))\n\t\treturn -EBUSY;\n\n\t \n\tif (trace_probe_unregister_event_call(&ep->tp))\n\t\treturn -EBUSY;\n\nunreg:\n\tdyn_event_remove(&ep->devent);\n\ttrace_probe_unlink(&ep->tp);\n\n\treturn 0;\n}\n\nstatic int eprobe_dyn_event_release(struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tint ret = unregister_trace_eprobe(ep);\n\n\tif (!ret)\n\t\ttrace_event_probe_cleanup(ep);\n\treturn ret;\n}\n\nstatic bool eprobe_dyn_event_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\n\treturn trace_probe_is_enabled(&ep->tp);\n}\n\nstatic bool eprobe_dyn_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_eprobe *ep = to_trace_eprobe(ev);\n\tconst char *slash;\n\n\t \n\n\t \n\tif (system && strcmp(trace_probe_group_name(&ep->tp), system) != 0)\n\t\treturn false;\n\n\t \n\tif (event[0] != '\\0' && strcmp(trace_probe_name(&ep->tp), event) != 0)\n\t\treturn false;\n\n\t \n\tif (argc < 1)\n\t\treturn true;\n\n\t \n\n\tslash = strchr(argv[0], '/');\n\tif (!slash)\n\t\tslash = strchr(argv[0], '.');\n\tif (!slash)\n\t\treturn false;\n\n\tif (strncmp(ep->event_system, argv[0], slash - argv[0]))\n\t\treturn false;\n\tif (strcmp(ep->event_name, slash + 1))\n\t\treturn false;\n\n\targc--;\n\targv++;\n\n\t \n\tif (argc < 1)\n\t\treturn true;\n\n\treturn trace_probe_match_command_args(&ep->tp, argc, argv);\n}\n\nstatic struct dyn_event_operations eprobe_dyn_event_ops = {\n\t.create = eprobe_dyn_event_create,\n\t.show = eprobe_dyn_event_show,\n\t.is_busy = eprobe_dyn_event_is_busy,\n\t.free = eprobe_dyn_event_release,\n\t.match = eprobe_dyn_event_match,\n};\n\nstatic struct trace_eprobe *alloc_event_probe(const char *group,\n\t\t\t\t\t      const char *this_event,\n\t\t\t\t\t      struct trace_event_call *event,\n\t\t\t\t\t      int nargs)\n{\n\tstruct trace_eprobe *ep;\n\tconst char *event_name;\n\tconst char *sys_name;\n\tint ret = -ENOMEM;\n\n\tif (!event)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsys_name = event->class->system;\n\tevent_name = trace_event_name(event);\n\n\tep = kzalloc(struct_size(ep, tp.args, nargs), GFP_KERNEL);\n\tif (!ep) {\n\t\ttrace_event_put_ref(event);\n\t\tgoto error;\n\t}\n\tep->event = event;\n\tep->event_name = kstrdup(event_name, GFP_KERNEL);\n\tif (!ep->event_name)\n\t\tgoto error;\n\tep->event_system = kstrdup(sys_name, GFP_KERNEL);\n\tif (!ep->event_system)\n\t\tgoto error;\n\n\tret = trace_probe_init(&ep->tp, this_event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&ep->devent, &eprobe_dyn_event_ops);\n\treturn ep;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ERR_PTR(ret);\n}\n\nstatic int eprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tstruct eprobe_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}\n\nstatic struct trace_event_fields eprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = eprobe_event_define_fields },\n\t{}\n};\n\n \nstatic enum print_line_t\nprint_eprobe_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct eprobe_trace_entry_head *field;\n\tstruct trace_event_call *pevent;\n\tstruct trace_event *probed_event;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_eprobe *ep;\n\tstruct trace_probe *tp;\n\tunsigned int type;\n\n\tfield = (struct eprobe_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\tep = container_of(tp, struct trace_eprobe, tp);\n\ttype = ep->event->event.type;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tprobed_event = ftrace_find_event(type);\n\tif (probed_event) {\n\t\tpevent = container_of(probed_event, struct trace_event_call, event);\n\t\ttrace_seq_printf(s, \"%s.%s\", pevent->class->system,\n\t\t\t\t trace_event_name(pevent));\n\t} else {\n\t\ttrace_seq_printf(s, \"%u\", type);\n\t}\n\n\ttrace_seq_putc(s, ')');\n\n\tif (trace_probe_print_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}\n\nstatic nokprobe_inline unsigned long\nget_event_field(struct fetch_insn *code, void *rec)\n{\n\tstruct ftrace_event_field *field = code->data;\n\tunsigned long val;\n\tvoid *addr;\n\n\taddr = rec + field->offset;\n\n\tif (is_string_field(field)) {\n\t\tswitch (field->filter_type) {\n\t\tcase FILTER_DYN_STRING:\n\t\t\tval = (unsigned long)(rec + (*(unsigned int *)addr & 0xffff));\n\t\t\tbreak;\n\t\tcase FILTER_RDYN_STRING:\n\t\t\tval = (unsigned long)(addr + (*(unsigned int *)addr & 0xffff));\n\t\t\tbreak;\n\t\tcase FILTER_STATIC_STRING:\n\t\t\tval = (unsigned long)addr;\n\t\t\tbreak;\n\t\tcase FILTER_PTR_STRING:\n\t\t\tval = (unsigned long)(*(char *)addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn 0;\n\t\t}\n\t\treturn val;\n\t}\n\n\tswitch (field->size) {\n\tcase 1:\n\t\tif (field->is_signed)\n\t\t\tval = *(char *)addr;\n\t\telse\n\t\t\tval = *(unsigned char *)addr;\n\t\tbreak;\n\tcase 2:\n\t\tif (field->is_signed)\n\t\t\tval = *(short *)addr;\n\t\telse\n\t\t\tval = *(unsigned short *)addr;\n\t\tbreak;\n\tcase 4:\n\t\tif (field->is_signed)\n\t\t\tval = *(int *)addr;\n\t\telse\n\t\t\tval = *(unsigned int *)addr;\n\t\tbreak;\n\tdefault:\n\t\tif (field->is_signed)\n\t\t\tval = *(long *)addr;\n\t\telse\n\t\t\tval = *(unsigned long *)addr;\n\t\tbreak;\n\t}\n\treturn val;\n}\n\nstatic int get_eprobe_size(struct trace_probe *tp, void *rec)\n{\n\tstruct fetch_insn *code;\n\tstruct probe_arg *arg;\n\tint i, len, ret = 0;\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\targ = tp->args + i;\n\t\tif (arg->dynamic) {\n\t\t\tunsigned long val;\n\n\t\t\tcode = arg->code;\n retry:\n\t\t\tswitch (code->op) {\n\t\t\tcase FETCH_OP_TP_ARG:\n\t\t\t\tval = get_event_field(code, rec);\n\t\t\t\tbreak;\n\t\t\tcase FETCH_NOP_SYMBOL:\t \n\t\t\t\tcode++;\n\t\t\t\tgoto retry;\n\t\t\tdefault:\n\t\t\t\tif (process_common_fetch_insn(code, &val) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcode++;\n\t\t\tlen = process_fetch_insn_bottom(code, val, NULL, NULL);\n\t\t\tif (len > 0)\n\t\t\t\tret += len;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \n\n \nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tunsigned long val;\n\tint ret;\n\n retry:\n\tswitch (code->op) {\n\tcase FETCH_OP_TP_ARG:\n\t\tval = get_event_field(code, rec);\n\t\tbreak;\n\tcase FETCH_NOP_SYMBOL:\t \n\t\tcode++;\n\t\tgoto retry;\n\tdefault:\n\t\tret = process_common_fetch_insn(code, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tcode++;\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n \nstatic inline void\n__eprobe_trace_func(struct eprobe_data *edata, void *rec)\n{\n\tstruct eprobe_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&edata->ep->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != edata->file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(edata->file))\n\t\treturn;\n\n\tdsize = get_eprobe_size(&edata->ep->tp, rec);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, edata->file,\n\t\t\t\t\t   sizeof(*entry) + edata->ep->tp.size + dsize);\n\n\tif (!entry)\n\t\treturn;\n\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tstore_trace_args(&entry[1], &edata->ep->tp, rec, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}\n\n \nstatic int eprobe_trigger_init(struct event_trigger_data *data)\n{\n\treturn 0;\n}\n\nstatic void eprobe_trigger_free(struct event_trigger_data *data)\n{\n\n}\n\nstatic int eprobe_trigger_print(struct seq_file *m,\n\t\t\t\tstruct event_trigger_data *data)\n{\n\t \n\treturn 0;\n}\n\nstatic void eprobe_trigger_func(struct event_trigger_data *data,\n\t\t\t\tstruct trace_buffer *buffer, void *rec,\n\t\t\t\tstruct ring_buffer_event *rbe)\n{\n\tstruct eprobe_data *edata = data->private_data;\n\n\tif (unlikely(!rec))\n\t\treturn;\n\n\t__eprobe_trace_func(edata, rec);\n}\n\nstatic struct event_trigger_ops eprobe_trigger_ops = {\n\t.trigger\t\t= eprobe_trigger_func,\n\t.print\t\t\t= eprobe_trigger_print,\n\t.init\t\t\t= eprobe_trigger_init,\n\t.free\t\t\t= eprobe_trigger_free,\n};\n\nstatic int eprobe_trigger_cmd_parse(struct event_command *cmd_ops,\n\t\t\t\t    struct trace_event_file *file,\n\t\t\t\t    char *glob, char *cmd,\n\t\t\t\t    char *param_and_filter)\n{\n\treturn -1;\n}\n\nstatic int eprobe_trigger_reg_func(char *glob,\n\t\t\t\t   struct event_trigger_data *data,\n\t\t\t\t   struct trace_event_file *file)\n{\n\treturn -1;\n}\n\nstatic void eprobe_trigger_unreg_func(char *glob,\n\t\t\t\t      struct event_trigger_data *data,\n\t\t\t\t      struct trace_event_file *file)\n{\n\n}\n\nstatic struct event_trigger_ops *eprobe_trigger_get_ops(char *cmd,\n\t\t\t\t\t\t\tchar *param)\n{\n\treturn &eprobe_trigger_ops;\n}\n\nstatic struct event_command event_trigger_cmd = {\n\t.name\t\t\t= \"eprobe\",\n\t.trigger_type\t\t= ETT_EVENT_EPROBE,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= eprobe_trigger_cmd_parse,\n\t.reg\t\t\t= eprobe_trigger_reg_func,\n\t.unreg\t\t\t= eprobe_trigger_unreg_func,\n\t.unreg_all\t\t= NULL,\n\t.get_trigger_ops\t= eprobe_trigger_get_ops,\n\t.set_filter\t\t= NULL,\n};\n\nstatic struct event_trigger_data *\nnew_eprobe_trigger(struct trace_eprobe *ep, struct trace_event_file *file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct event_filter *filter = NULL;\n\tstruct eprobe_data *edata;\n\tint ret;\n\n\tedata = kzalloc(sizeof(*edata), GFP_KERNEL);\n\ttrigger = kzalloc(sizeof(*trigger), GFP_KERNEL);\n\tif (!trigger || !edata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ttrigger->flags = EVENT_TRIGGER_FL_PROBE;\n\ttrigger->count = -1;\n\ttrigger->ops = &eprobe_trigger_ops;\n\n\t \n\ttrigger->cmd_ops = &event_trigger_cmd;\n\n\tINIT_LIST_HEAD(&trigger->list);\n\n\tif (ep->filter_str) {\n\t\tret = create_event_filter(file->tr, ep->event,\n\t\t\t\t\tep->filter_str, false, &filter);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tRCU_INIT_POINTER(trigger->filter, filter);\n\n\tedata->file = file;\n\tedata->ep = ep;\n\ttrigger->private_data = edata;\n\n\treturn trigger;\nerror:\n\tfree_event_filter(filter);\n\tkfree(edata);\n\tkfree(trigger);\n\treturn ERR_PTR(ret);\n}\n\nstatic int enable_eprobe(struct trace_eprobe *ep,\n\t\t\t struct trace_event_file *eprobe_file)\n{\n\tstruct event_trigger_data *trigger;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = eprobe_file->tr;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\ttrigger = new_eprobe_trigger(ep, eprobe_file);\n\tif (IS_ERR(trigger))\n\t\treturn PTR_ERR(trigger);\n\n\tlist_add_tail_rcu(&trigger->list, &file->triggers);\n\n\ttrace_event_trigger_enable_disable(file, 1);\n\tupdate_cond_flag(file);\n\n\treturn 0;\n}\n\nstatic struct trace_event_functions eprobe_funcs = {\n\t.trace\t\t= print_eprobe_event\n};\n\nstatic int disable_eprobe(struct trace_eprobe *ep,\n\t\t\t  struct trace_array *tr)\n{\n\tstruct event_trigger_data *trigger = NULL, *iter;\n\tstruct trace_event_file *file;\n\tstruct event_filter *filter;\n\tstruct eprobe_data *edata;\n\n\tfile = find_event_file(tr, ep->event_system, ep->event_name);\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(iter, &file->triggers, list) {\n\t\tif (!(iter->flags & EVENT_TRIGGER_FL_PROBE))\n\t\t\tcontinue;\n\t\tedata = iter->private_data;\n\t\tif (edata->ep == ep) {\n\t\t\ttrigger = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!trigger)\n\t\treturn -ENODEV;\n\n\tlist_del_rcu(&trigger->list);\n\n\ttrace_event_trigger_enable_disable(file, 0);\n\tupdate_cond_flag(file);\n\n\t \n\ttracepoint_synchronize_unregister();\n\n\tfilter = rcu_access_pointer(trigger->filter);\n\n\tif (filter)\n\t\tfree_event_filter(filter);\n\tkfree(edata);\n\tkfree(trigger);\n\n\treturn 0;\n}\n\nstatic int enable_trace_eprobe(struct trace_event_call *call,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_eprobe *ep;\n\tbool enabled;\n\tint ret = 0;\n\tint cnt = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t \n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (enabled)\n\t\treturn 0;\n\n\tfor_each_trace_eprobe_tp(ep, tp) {\n\t\tret = enable_eprobe(ep, file);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tenabled = true;\n\t\tcnt++;\n\t}\n\n\tif (ret) {\n\t\t \n\t\tif (enabled) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\n\t\t\tfor_each_trace_eprobe_tp(ep, tp) {\n\t\t\t\tdisable_eprobe(ep, file->tr);\n\t\t\t\tif (!--cnt)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (file)\n\t\t\ttrace_probe_remove_file(tp, file);\n\t\telse\n\t\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\treturn ret;\n}\n\nstatic int disable_trace_eprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_eprobe *ep;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp)) {\n\t\tfor_each_trace_eprobe_tp(ep, tp)\n\t\t\tdisable_eprobe(ep, file->tr);\n\t}\n\n out:\n\tif (file)\n\t\t \n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}\n\nstatic int eprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_eprobe(event, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_eprobe(event, file);\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic inline void init_trace_eprobe_call(struct trace_eprobe *ep)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&ep->tp);\n\n\tcall->flags = TRACE_EVENT_FL_EPROBE;\n\tcall->event.funcs = &eprobe_funcs;\n\tcall->class->fields_array = eprobe_fields_array;\n\tcall->class->reg = eprobe_register;\n}\n\nstatic struct trace_event_call *\nfind_and_get_event(const char *system, const char *event_name)\n{\n\tstruct trace_event_call *tp_event;\n\tconst char *name;\n\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\t \n\t\tif (tp_event->flags &\n\t\t    (TRACE_EVENT_FL_IGNORE_ENABLE |\n\t\t     TRACE_EVENT_FL_KPROBE |\n\t\t     TRACE_EVENT_FL_UPROBE |\n\t\t     TRACE_EVENT_FL_EPROBE))\n\t\t\tcontinue;\n\t\tif (!tp_event->class->system ||\n\t\t    strcmp(system, tp_event->class->system))\n\t\t\tcontinue;\n\t\tname = trace_event_name(tp_event);\n\t\tif (!name || strcmp(event_name, name))\n\t\t\tcontinue;\n\t\tif (!trace_event_try_get_ref(tp_event)) {\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn tp_event;\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic int trace_eprobe_tp_update_arg(struct trace_eprobe *ep, const char *argv[], int i)\n{\n\tstruct traceprobe_parse_context ctx = {\n\t\t.event = ep->event,\n\t\t.flags = TPARG_FL_KERNEL | TPARG_FL_TEVENT,\n\t};\n\tint ret;\n\n\tret = traceprobe_parse_probe_arg(&ep->tp, i, argv[i], &ctx);\n\t \n\tif (!ret)\n\t\tret = traceprobe_update_arg(&ep->tp.args[i]);\n\n\ttraceprobe_finish_parse(&ctx);\n\treturn ret;\n}\n\nstatic int trace_eprobe_parse_filter(struct trace_eprobe *ep, int argc, const char *argv[])\n{\n\tstruct event_filter *dummy = NULL;\n\tint i, ret, len = 0;\n\tchar *p;\n\n\tif (argc == 0) {\n\t\ttrace_probe_log_err(0, NO_EP_FILTER);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < argc; i++)\n\t\tlen += strlen(argv[i]) + 1;\n\n\tep->filter_str = kzalloc(len, GFP_KERNEL);\n\tif (!ep->filter_str)\n\t\treturn -ENOMEM;\n\n\tp = ep->filter_str;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i)\n\t\t\tret = snprintf(p, len, \" %s\", argv[i]);\n\t\telse\n\t\t\tret = snprintf(p, len, \"%s\", argv[i]);\n\t\tp += ret;\n\t\tlen -= ret;\n\t}\n\n\t \n\tret = create_event_filter(top_trace_array(), ep->event, ep->filter_str,\n\t\t\t\t  true, &dummy);\n\tfree_event_filter(dummy);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tkfree(ep->filter_str);\n\tep->filter_str = NULL;\n\treturn ret;\n}\n\nstatic int __trace_eprobe_create(int argc, const char *argv[])\n{\n\t \n\tconst char *event = NULL, *group = EPROBE_EVENT_SYSTEM;\n\tconst char *sys_event = NULL, *sys_name = NULL;\n\tstruct trace_event_call *event_call;\n\tstruct trace_eprobe *ep = NULL;\n\tchar buf1[MAX_EVENT_NAME_LEN];\n\tchar buf2[MAX_EVENT_NAME_LEN];\n\tchar gbuf[MAX_EVENT_NAME_LEN];\n\tint ret = 0, filter_idx = 0;\n\tint i, filter_cnt;\n\n\tif (argc < 2 || argv[0][0] != 'e')\n\t\treturn -ECANCELED;\n\n\ttrace_probe_log_init(\"event_probe\", argc, argv);\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event) {\n\t\tevent++;\n\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t}\n\n\ttrace_probe_log_set_index(1);\n\tsys_event = argv[1];\n\tret = traceprobe_parse_event_name(&sys_event, &sys_name, buf2, 0);\n\tif (ret || !sys_event || !sys_name) {\n\t\ttrace_probe_log_err(0, NO_EVENT_INFO);\n\t\tgoto parse_error;\n\t}\n\n\tif (!event) {\n\t\tstrscpy(buf1, sys_event, MAX_EVENT_NAME_LEN);\n\t\tevent = buf1;\n\t}\n\n\tfor (i = 2; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"if\")) {\n\t\t\tfilter_idx = i + 1;\n\t\t\tfilter_cnt = argc - filter_idx;\n\t\t\targc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_lock(&event_mutex);\n\tevent_call = find_and_get_event(sys_name, sys_event);\n\tep = alloc_event_probe(group, event, event_call, argc - 2);\n\tmutex_unlock(&event_mutex);\n\n\tif (IS_ERR(ep)) {\n\t\tret = PTR_ERR(ep);\n\t\tif (ret == -ENODEV)\n\t\t\ttrace_probe_log_err(0, BAD_ATTACH_EVENT);\n\t\t \n\t\tWARN_ON_ONCE(ret != -ENOMEM && ret != -ENODEV);\n\t\tep = NULL;\n\t\tgoto error;\n\t}\n\n\tif (filter_idx) {\n\t\ttrace_probe_log_set_index(filter_idx);\n\t\tret = trace_eprobe_parse_filter(ep, filter_cnt, argv + filter_idx);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t} else\n\t\tep->filter_str = NULL;\n\n\targc -= 2; argv += 2;\n\t \n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = trace_eprobe_tp_update_arg(ep, argv, i);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\tret = traceprobe_set_print_fmt(&ep->tp, PROBE_PRINT_EVENT);\n\tif (ret < 0)\n\t\tgoto error;\n\tinit_trace_eprobe_call(ep);\n\tmutex_lock(&event_mutex);\n\tret = trace_probe_register_event_call(&ep->tp);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t}\n\t\tmutex_unlock(&event_mutex);\n\t\tgoto error;\n\t}\n\tret = dyn_event_add(&ep->devent, &ep->tp.event->call);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\nparse_error:\n\tret = -EINVAL;\nerror:\n\ttrace_event_probe_cleanup(ep);\n\treturn ret;\n}\n\n \nstatic __init int trace_events_eprobe_init_early(void)\n{\n\tint err = 0;\n\n\terr = dyn_event_register(&eprobe_dyn_event_ops);\n\tif (err)\n\t\tpr_warn(\"Could not register eprobe_dyn_event_ops\\n\");\n\n\treturn err;\n}\ncore_initcall(trace_events_eprobe_init_early);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}