{
  "module_name": "trace_printk.c",
  "hash_id": "ec246a2fa019df1327c6b163444e3f1234938584bb43f2503587a3dc24b909c1",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_printk.c",
  "human_readable_source": "\n \n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/ftrace.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include \"trace.h\"\n\n#ifdef CONFIG_MODULES\n\n \nstatic LIST_HEAD(trace_bprintk_fmt_list);\n\n \nstatic DEFINE_MUTEX(btrace_mutex);\n\nstruct trace_bprintk_fmt {\n\tstruct list_head list;\n\tconst char *fmt;\n};\n\nstatic inline struct trace_bprintk_fmt *lookup_format(const char *fmt)\n{\n\tstruct trace_bprintk_fmt *pos;\n\n\tif (!fmt)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlist_for_each_entry(pos, &trace_bprintk_fmt_list, list) {\n\t\tif (!strcmp(pos->fmt, fmt))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic\nvoid hold_module_trace_bprintk_format(const char **start, const char **end)\n{\n\tconst char **iter;\n\tchar *fmt;\n\n\t \n\tif (start != end)\n\t\ttrace_printk_init_buffers();\n\n\tmutex_lock(&btrace_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\tif (!IS_ERR(tb_fmt))\n\t\t\t\t*iter = tb_fmt->fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfmt = NULL;\n\t\ttb_fmt = kmalloc(sizeof(*tb_fmt), GFP_KERNEL);\n\t\tif (tb_fmt) {\n\t\t\tfmt = kmalloc(strlen(*iter) + 1, GFP_KERNEL);\n\t\t\tif (fmt) {\n\t\t\t\tlist_add_tail(&tb_fmt->list, &trace_bprintk_fmt_list);\n\t\t\t\tstrcpy(fmt, *iter);\n\t\t\t\ttb_fmt->fmt = fmt;\n\t\t\t} else\n\t\t\t\tkfree(tb_fmt);\n\t\t}\n\t\t*iter = fmt;\n\n\t}\n\tmutex_unlock(&btrace_mutex);\n}\n\nstatic int module_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tif (mod->num_trace_bprintk_fmt) {\n\t\tconst char **start = mod->trace_bprintk_fmt_start;\n\t\tconst char **end = start + mod->num_trace_bprintk_fmt;\n\n\t\tif (val == MODULE_STATE_COMING)\n\t\t\thold_module_trace_bprintk_format(start, end);\n\t}\n\treturn NOTIFY_OK;\n}\n\n \nstatic const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\tstruct trace_bprintk_fmt *mod_fmt;\n\n\tif (list_empty(&trace_bprintk_fmt_list))\n\t\treturn NULL;\n\n\t \n\tif (!v || start_index == *pos) {\n\t\tstruct trace_bprintk_fmt *p;\n\n\t\t \n\t\tlist_for_each_entry(p, &trace_bprintk_fmt_list, list) {\n\t\t\tif (start_index == *pos)\n\t\t\t\treturn &p->fmt;\n\t\t\tstart_index++;\n\t\t}\n\t\t \n\t\treturn NULL;\n\t}\n\n\t \n\tmod_fmt = container_of(v, typeof(*mod_fmt), fmt);\n\tif (mod_fmt->list.next == &trace_bprintk_fmt_list)\n\t\treturn NULL;\n\n\tmod_fmt = container_of(mod_fmt->list.next, typeof(*mod_fmt), list);\n\n\treturn &mod_fmt->fmt;\n}\n\nstatic void format_mod_start(void)\n{\n\tmutex_lock(&btrace_mutex);\n}\n\nstatic void format_mod_stop(void)\n{\n\tmutex_unlock(&btrace_mutex);\n}\n\n#else  \n__init static int\nmodule_trace_bprintk_format_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_OK;\n}\nstatic inline const char **\nfind_next_mod_format(int start_index, void *v, const char **fmt, loff_t *pos)\n{\n\treturn NULL;\n}\nstatic inline void format_mod_start(void) { }\nstatic inline void format_mod_stop(void) { }\n#endif  \n\nstatic bool __read_mostly trace_printk_enabled = true;\n\nvoid trace_printk_control(bool enabled)\n{\n\ttrace_printk_enabled = enabled;\n}\n\n__initdata_or_module static\nstruct notifier_block module_trace_bprintk_format_nb = {\n\t.notifier_call = module_trace_bprintk_format_notify,\n};\n\nint __trace_bprintk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vbprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__trace_bprintk);\n\nint __ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (unlikely(!fmt))\n\t\treturn 0;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vbprintk(ip, fmt, ap);\n}\nEXPORT_SYMBOL_GPL(__ftrace_vbprintk);\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__trace_printk);\n\nint __ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap)\n{\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\treturn trace_vprintk(ip, fmt, ap);\n}\nEXPORT_SYMBOL_GPL(__ftrace_vprintk);\n\nbool trace_is_tracepoint_string(const char *str)\n{\n\tconst char **ptr = __start___tracepoint_str;\n\n\tfor (ptr = __start___tracepoint_str; ptr < __stop___tracepoint_str; ptr++) {\n\t\tif (str == *ptr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char **find_next(void *v, loff_t *pos)\n{\n\tconst char **fmt = v;\n\tint start_index;\n\tint last_index;\n\n\tstart_index = __stop___trace_bprintk_fmt - __start___trace_bprintk_fmt;\n\n\tif (*pos < start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t \n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\tstart_index += last_index;\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}\n\nstatic void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(NULL, pos);\n}\n\nstatic void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tif (!*fmt)\n\t\treturn 0;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t \n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}\n\nstatic const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &show_format_seq_ops);\n}\n\nstatic const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic __init int init_trace_printk_function_export(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", TRACE_MODE_READ, NULL,\n\t\t\t\t    NULL, &ftrace_formats_fops);\n\n\treturn 0;\n}\n\nfs_initcall(init_trace_printk_function_export);\n\nstatic __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}\n\nearly_initcall(init_trace_printk);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}