{
  "module_name": "trace_mmiotrace.c",
  "hash_id": "771f95aeb2c51469b3325165708207426a03959e8148c8f35a41b78bc7e1d592",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_mmiotrace.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mmiotrace.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\n#include <linux/atomic.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\nstruct header_iter {\n\tstruct pci_dev *dev;\n};\n\nstatic struct trace_array *mmio_trace_array;\nstatic bool overrun_detected;\nstatic unsigned long prev_overruns;\nstatic atomic_t dropped_count;\n\nstatic void mmio_reset_data(struct trace_array *tr)\n{\n\toverrun_detected = false;\n\tprev_overruns = 0;\n\n\ttracing_reset_online_cpus(&tr->array_buffer);\n}\n\nstatic int mmio_trace_init(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_trace_array = tr;\n\n\tmmio_reset_data(tr);\n\tenable_mmiotrace();\n\treturn 0;\n}\n\nstatic void mmio_trace_reset(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\n\tdisable_mmiotrace();\n\tmmio_reset_data(tr);\n\tmmio_trace_array = NULL;\n}\n\nstatic void mmio_trace_start(struct trace_array *tr)\n{\n\tpr_debug(\"in %s\\n\", __func__);\n\tmmio_reset_data(tr);\n}\n\nstatic void mmio_print_pcidev(struct trace_seq *s, const struct pci_dev *dev)\n{\n\tint i;\n\tresource_size_t start, end;\n\tconst struct pci_driver *drv = pci_dev_driver(dev);\n\n\ttrace_seq_printf(s, \"PCIDEV %02x%02x %04x%04x %x\",\n\t\t\t dev->bus->number, dev->devfn,\n\t\t\t dev->vendor, dev->device, dev->irq);\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\t(unsigned long long)(start |\n\t\t\t(dev->resource[i].flags & PCI_REGION_FLAG_MASK)));\n\t}\n\tfor (i = 0; i < 7; i++) {\n\t\tstart = dev->resource[i].start;\n\t\tend = dev->resource[i].end;\n\t\ttrace_seq_printf(s, \" %llx\",\n\t\t\tdev->resource[i].start < dev->resource[i].end ?\n\t\t\t(unsigned long long)(end - start) + 1 : 0);\n\t}\n\tif (drv)\n\t\ttrace_seq_printf(s, \" %s\\n\", drv->name);\n\telse\n\t\ttrace_seq_puts(s, \" \\n\");\n}\n\nstatic void destroy_header_iter(struct header_iter *hiter)\n{\n\tif (!hiter)\n\t\treturn;\n\tpci_dev_put(hiter->dev);\n\tkfree(hiter);\n}\n\nstatic void mmio_pipe_open(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_seq_puts(s, \"VERSION 20070824\\n\");\n\n\thiter = kzalloc(sizeof(*hiter), GFP_KERNEL);\n\tif (!hiter)\n\t\treturn;\n\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);\n\titer->private = hiter;\n}\n\n \nstatic void mmio_close(struct trace_iterator *iter)\n{\n\tstruct header_iter *hiter = iter->private;\n\tdestroy_header_iter(hiter);\n\titer->private = NULL;\n}\n\nstatic unsigned long count_overruns(struct trace_iterator *iter)\n{\n\tunsigned long cnt = atomic_xchg(&dropped_count, 0);\n\tunsigned long over = ring_buffer_overruns(iter->array_buffer->buffer);\n\n\tif (over > prev_overruns)\n\t\tcnt += over - prev_overruns;\n\tprev_overruns = over;\n\treturn cnt;\n}\n\nstatic ssize_t mmio_read(struct trace_iterator *iter, struct file *filp,\n\t\t\t\tchar __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tssize_t ret;\n\tstruct header_iter *hiter = iter->private;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long n;\n\n\tn = count_overruns(iter);\n\tif (n) {\n\t\t \n\t\ttrace_seq_printf(s, \"MARK 0.000000 Lost %lu events.\\n\", n);\n\t\tif (!overrun_detected)\n\t\t\tpr_warn(\"mmiotrace has lost events\\n\");\n\t\toverrun_detected = true;\n\t\tgoto print_out;\n\t}\n\n\tif (!hiter)\n\t\treturn 0;\n\n\tmmio_print_pcidev(s, hiter->dev);\n\thiter->dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, hiter->dev);\n\n\tif (!hiter->dev) {\n\t\tdestroy_header_iter(hiter);\n\t\titer->private = NULL;\n\t}\n\nprint_out:\n\tret = trace_seq_to_user(s, ubuf, cnt);\n\treturn (ret == -EBUSY) ? 0 : ret;\n}\n\nstatic enum print_line_t mmio_print_rw(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_rw *field;\n\tstruct mmiotrace_rw *rw;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\trw = &field->rw;\n\n\tswitch (rw->opcode) {\n\tcase MMIO_READ:\n\t\ttrace_seq_printf(s,\n\t\t\t\"R %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_WRITE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"W %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\",\n\t\t\trw->width, secs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\trw->value, rw->pc, 0);\n\t\tbreak;\n\tcase MMIO_UNKNOWN_OP:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNKNOWN %u.%06lu %d 0x%llx %02lx,%02lx,\"\n\t\t\t\"%02lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, rw->map_id,\n\t\t\t(unsigned long long)rw->phys,\n\t\t\t(rw->value >> 16) & 0xff, (rw->value >> 8) & 0xff,\n\t\t\t(rw->value >> 0) & 0xff, rw->pc, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"rw what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t mmio_print_map(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_mmiotrace_map *field;\n\tstruct mmiotrace_map *m;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\ttrace_assign_type(field, entry);\n\tm = &field->map;\n\n\tswitch (m->opcode) {\n\tcase MMIO_PROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"MAP %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id,\n\t\t\t(unsigned long long)m->phys, m->virt, m->len,\n\t\t\t0UL, 0);\n\t\tbreak;\n\tcase MMIO_UNPROBE:\n\t\ttrace_seq_printf(s,\n\t\t\t\"UNMAP %u.%06lu %d 0x%lx %d\\n\",\n\t\t\tsecs, usec_rem, m->map_id, 0UL, 0);\n\t\tbreak;\n\tdefault:\n\t\ttrace_seq_puts(s, \"map what?\\n\");\n\t\tbreak;\n\t}\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t mmio_print_mark(struct trace_iterator *iter)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *print = (struct print_entry *)entry;\n\tconst char *msg\t\t= print->buf;\n\tstruct trace_seq *s\t= &iter->seq;\n\tunsigned long long t\t= ns2usecs(iter->ts);\n\tunsigned long usec_rem\t= do_div(t, USEC_PER_SEC);\n\tunsigned secs\t\t= (unsigned long)t;\n\n\t \n\ttrace_seq_printf(s, \"MARK %u.%06lu %s\", secs, usec_rem, msg);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t mmio_print_line(struct trace_iterator *iter)\n{\n\tswitch (iter->ent->type) {\n\tcase TRACE_MMIO_RW:\n\t\treturn mmio_print_rw(iter);\n\tcase TRACE_MMIO_MAP:\n\t\treturn mmio_print_map(iter);\n\tcase TRACE_PRINT:\n\t\treturn mmio_print_mark(iter);\n\tdefault:\n\t\treturn TRACE_TYPE_HANDLED;  \n\t}\n}\n\nstatic struct tracer mmio_tracer __read_mostly =\n{\n\t.name\t\t= \"mmiotrace\",\n\t.init\t\t= mmio_trace_init,\n\t.reset\t\t= mmio_trace_reset,\n\t.start\t\t= mmio_trace_start,\n\t.pipe_open\t= mmio_pipe_open,\n\t.close\t\t= mmio_close,\n\t.read\t\t= mmio_read,\n\t.print_line\t= mmio_print_line,\n\t.noboot\t\t= true,\n};\n\n__init static int init_mmio_trace(void)\n{\n\treturn register_tracer(&mmio_tracer);\n}\ndevice_initcall(init_mmio_trace);\n\nstatic void __trace_mmiotrace_rw(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_rw *rw)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_rw;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_rw *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_RW,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->rw\t\t\t= *rw;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}\n\nvoid mmio_trace_rw(struct mmiotrace_rw *rw)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data = per_cpu_ptr(tr->array_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_rw(tr, data, rw);\n}\n\nstatic void __trace_mmiotrace_map(struct trace_array *tr,\n\t\t\t\tstruct trace_array_cpu *data,\n\t\t\t\tstruct mmiotrace_map *map)\n{\n\tstruct trace_event_call *call = &event_mmiotrace_map;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_mmiotrace_map *entry;\n\tunsigned int trace_ctx;\n\n\ttrace_ctx = tracing_gen_ctx_flags(0);\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_MMIO_MAP,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event) {\n\t\tatomic_inc(&dropped_count);\n\t\treturn;\n\t}\n\tentry\t= ring_buffer_event_data(event);\n\tentry->map\t\t\t= *map;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit(tr, buffer, event, trace_ctx);\n}\n\nvoid mmio_trace_mapping(struct mmiotrace_map *map)\n{\n\tstruct trace_array *tr = mmio_trace_array;\n\tstruct trace_array_cpu *data;\n\n\tpreempt_disable();\n\tdata = per_cpu_ptr(tr->array_buffer.data, smp_processor_id());\n\t__trace_mmiotrace_map(tr, data, map);\n\tpreempt_enable();\n}\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}