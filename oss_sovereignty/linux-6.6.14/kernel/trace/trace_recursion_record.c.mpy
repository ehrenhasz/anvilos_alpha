{
  "module_name": "trace_recursion_record.c",
  "hash_id": "6324e67ac3ee9487129a218fc62bf739aedd1c7fbdc3bed0041b272f11b9ad67",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_recursion_record.c",
  "human_readable_source": "\n\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/fs.h>\n\n#include \"trace_output.h\"\n\nstruct recursed_functions {\n\tunsigned long\t\tip;\n\tunsigned long\t\tparent_ip;\n};\n\nstatic struct recursed_functions recursed_functions[CONFIG_FTRACE_RECORD_RECURSION_SIZE];\nstatic atomic_t nr_records;\n\n \nstatic unsigned long cached_function;\n\nvoid ftrace_record_recursion(unsigned long ip, unsigned long parent_ip)\n{\n\tint index = 0;\n\tint i;\n\tunsigned long old;\n\n again:\n\t \n\tif (ip == cached_function)\n\t\treturn;\n\n\ti = atomic_read(&nr_records);\n\t \n\tsmp_mb__after_atomic();\n\tif (i < 0)\n\t\treturn;\n\n\t \n\tif (index < i)\n\t\tindex = i;\n\tif (index >= CONFIG_FTRACE_RECORD_RECURSION_SIZE)\n\t\treturn;\n\n\tfor (i = index - 1; i >= 0; i--) {\n\t\tif (recursed_functions[i].ip == ip) {\n\t\t\tcached_function = ip;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcached_function = ip;\n\n\t \n\told = cmpxchg(&recursed_functions[index].ip, 0, ip);\n\tif (old != 0) {\n\t\t \n\t\tif (old == ip)\n\t\t\treturn;\n\t\t \n\t\tindex++;\n\t\tgoto again;\n\t}\n\n\trecursed_functions[index].parent_ip = parent_ip;\n\n\t \n\ti = atomic_read(&nr_records);\n\tsmp_mb__after_atomic();\n\tif (i < 0)\n\t\tcmpxchg(&recursed_functions[index].ip, ip, 0);\n\telse if (i <= index)\n\t\tatomic_cmpxchg(&nr_records, i, index + 1);\n}\nEXPORT_SYMBOL_GPL(ftrace_record_recursion);\n\nstatic DEFINE_MUTEX(recursed_function_lock);\nstatic struct trace_seq *tseq;\n\nstatic void *recursed_function_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *ret = NULL;\n\tint index;\n\n\tmutex_lock(&recursed_function_lock);\n\tindex = atomic_read(&nr_records);\n\tif (*pos < index) {\n\t\tret = &recursed_functions[*pos];\n\t}\n\n\ttseq = kzalloc(sizeof(*tseq), GFP_KERNEL);\n\tif (!tseq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrace_seq_init(tseq);\n\n\treturn ret;\n}\n\nstatic void *recursed_function_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tint index;\n\tint p;\n\n\tindex = atomic_read(&nr_records);\n\tp = ++(*pos);\n\n\treturn p < index ? &recursed_functions[p] : NULL;\n}\n\nstatic void recursed_function_seq_stop(struct seq_file *m, void *v)\n{\n\tkfree(tseq);\n\tmutex_unlock(&recursed_function_lock);\n}\n\nstatic int recursed_function_seq_show(struct seq_file *m, void *v)\n{\n\tstruct recursed_functions *record = v;\n\tint ret = 0;\n\n\tif (record) {\n\t\ttrace_seq_print_sym(tseq, record->parent_ip, true);\n\t\ttrace_seq_puts(tseq, \":\\t\");\n\t\ttrace_seq_print_sym(tseq, record->ip, true);\n\t\ttrace_seq_putc(tseq, '\\n');\n\t\tret = trace_print_seq(m, tseq);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct seq_operations recursed_function_seq_ops = {\n\t.start  = recursed_function_seq_start,\n\t.next   = recursed_function_seq_next,\n\t.stop   = recursed_function_seq_stop,\n\t.show   = recursed_function_seq_show\n};\n\nstatic int recursed_function_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&recursed_function_lock);\n\t \n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\t \n\t\tatomic_set(&nr_records, -1);\n\t\tsmp_mb__after_atomic();\n\t\tmemset(recursed_functions, 0, sizeof(recursed_functions));\n\t\tsmp_wmb();\n\t\t \n\t\tatomic_set(&nr_records, 0);\n\t}\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_open(file, &recursed_function_seq_ops);\n\tmutex_unlock(&recursed_function_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t recursed_function_write(struct file *file,\n\t\t\t\t       const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nstatic int recursed_function_release(struct inode *inode, struct file *file)\n{\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\treturn 0;\n}\n\nstatic const struct file_operations recursed_functions_fops = {\n\t.open           = recursed_function_open,\n\t.write\t\t= recursed_function_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = recursed_function_release,\n};\n\n__init static int create_recursed_functions(void)\n{\n\n\ttrace_create_file(\"recursed_functions\", TRACE_MODE_WRITE,\n\t\t\t  NULL, NULL, &recursed_functions_fops);\n\treturn 0;\n}\n\nfs_initcall(create_recursed_functions);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}