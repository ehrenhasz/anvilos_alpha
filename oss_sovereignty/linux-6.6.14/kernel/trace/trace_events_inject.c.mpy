{
  "module_name": "trace_events_inject.c",
  "hash_id": "bc5de5dd7889f061564754b6ae3fdbec664ac5fe23117f75ca457e72fcadcacc",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_events_inject.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n\n#include \"trace.h\"\n\nstatic int\ntrace_inject_entry(struct trace_event_file *file, void *rec, int len)\n{\n\tstruct trace_event_buffer fbuffer;\n\tint written = 0;\n\tvoid *entry;\n\n\trcu_read_lock_sched();\n\tentry = trace_event_buffer_reserve(&fbuffer, file, len);\n\tif (entry) {\n\t\tmemcpy(entry, rec, len);\n\t\twritten = len;\n\t\ttrace_event_buffer_commit(&fbuffer);\n\t}\n\trcu_read_unlock_sched();\n\n\treturn written;\n}\n\nstatic int\nparse_field(char *str, struct trace_event_call *call,\n\t    struct ftrace_event_field **pf, u64 *pv)\n{\n\tstruct ftrace_event_field *field;\n\tchar *field_name;\n\tint s, i = 0;\n\tint len;\n\tu64 val;\n\n\tif (!str[i])\n\t\treturn 0;\n\t \n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\tlen = i - s;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field)\n\t\treturn -ENOENT;\n\n\t*pf = field;\n\twhile (isspace(str[i]))\n\t\ti++;\n\tif (str[i] != '=')\n\t\treturn -EINVAL;\n\ti++;\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\tif (isdigit(str[i]) || str[i] == '-') {\n\t\tchar *num, c;\n\t\tint ret;\n\n\t\t \n\t\tif (is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t \n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\t\tnum = str + s;\n\t\tc = str[i];\n\t\tif (c != '\\0' && !isspace(c))\n\t\t\treturn -EINVAL;\n\t\tstr[i] = '\\0';\n\t\t \n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num, 0, &val);\n\t\tstr[i] = c;\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pv = val;\n\t\treturn i;\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t \n\t\tif (!is_string_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == '\\\\' && str[i + 1]) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i])\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL)\n\t\t\treturn -EINVAL;\n\n\t\t*pv = (unsigned long)(str + s);\n\t\tstr[i] = 0;\n\t\t \n\t\ti++;\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int trace_get_entry_size(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tint size = 0;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (field->size + field->offset > size)\n\t\t\tsize = field->size + field->offset;\n\t}\n\n\treturn size;\n}\n\nstatic void *trace_alloc_entry(struct trace_event_call *call, int *size)\n{\n\tint entry_size = trace_get_entry_size(call);\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\tvoid *entry = NULL;\n\n\t \n\tentry = kzalloc(entry_size + 1, GFP_KERNEL);\n\tif (!entry)\n\t\treturn NULL;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!is_string_field(field))\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tcontinue;\n\t\tif (field->filter_type == FILTER_DYN_STRING ||\n\t\t    field->filter_type == FILTER_RDYN_STRING) {\n\t\t\tu32 *str_item;\n\t\t\tint str_loc = entry_size & 0xffff;\n\n\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\tstr_loc -= field->offset + field->size;\n\n\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t*str_item = str_loc;  \n\t\t} else {\n\t\t\tchar **paddr;\n\n\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t*paddr = \"\";\n\t\t}\n\t}\n\n\t*size = entry_size + 1;\n\treturn entry;\n}\n\n#define INJECT_STRING \"STATIC STRING CAN NOT BE INJECTED\"\n\n \nstatic int parse_entry(char *str, struct trace_event_call *call, void **pentry)\n{\n\tstruct ftrace_event_field *field;\n\tvoid *entry = NULL;\n\tint entry_size;\n\tu64 val = 0;\n\tint len;\n\n\tentry = trace_alloc_entry(call, &entry_size);\n\t*pentry = entry;\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\ttracing_generic_entry_update(entry, call->event.type,\n\t\t\t\t     tracing_gen_ctx());\n\n\twhile ((len = parse_field(str, call, &field, &val)) > 0) {\n\t\tif (is_function_field(field))\n\t\t\treturn -EINVAL;\n\n\t\tif (is_string_field(field)) {\n\t\t\tchar *addr = (char *)(unsigned long) val;\n\n\t\t\tif (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\t\tstrscpy(entry + field->offset, addr, field->size);\n\t\t\t} else if (field->filter_type == FILTER_DYN_STRING ||\n\t\t\t\t   field->filter_type == FILTER_RDYN_STRING) {\n\t\t\t\tint str_len = strlen(addr) + 1;\n\t\t\t\tint str_loc = entry_size & 0xffff;\n\t\t\t\tu32 *str_item;\n\n\t\t\t\tentry_size += str_len;\n\t\t\t\t*pentry = krealloc(entry, entry_size, GFP_KERNEL);\n\t\t\t\tif (!*pentry) {\n\t\t\t\t\tkfree(entry);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tentry = *pentry;\n\n\t\t\t\tstrscpy(entry + (entry_size - str_len), addr, str_len);\n\t\t\t\tstr_item = (u32 *)(entry + field->offset);\n\t\t\t\tif (field->filter_type == FILTER_RDYN_STRING)\n\t\t\t\t\tstr_loc -= field->offset + field->size;\n\t\t\t\t*str_item = (str_len << 16) | str_loc;\n\t\t\t} else {\n\t\t\t\tchar **paddr;\n\n\t\t\t\tpaddr = (char **)(entry + field->offset);\n\t\t\t\t*paddr = INJECT_STRING;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (field->size) {\n\t\t\tcase 1: {\n\t\t\t\tu8 tmp = (u8) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tu16 tmp = (u16) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\tu32 tmp = (u32) val;\n\n\t\t\t\tmemcpy(entry + field->offset, &tmp, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8:\n\t\t\t\tmemcpy(entry + field->offset, &val, 8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tstr += len;\n\t}\n\n\tif (len < 0)\n\t\treturn len;\n\n\treturn entry_size;\n}\n\nstatic ssize_t\nevent_inject_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tint err = -ENODEV, size;\n\tvoid *entry = NULL;\n\tchar *buf;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsize = parse_entry(buf, call, &entry);\n\t\tif (size < 0)\n\t\t\terr = size;\n\t\telse\n\t\t\terr = trace_inject_entry(file, entry, size);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tkfree(entry);\n\tkfree(buf);\n\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += err;\n\treturn cnt;\n}\n\nstatic ssize_t\nevent_inject_read(struct file *file, char __user *buf, size_t size,\n\t\t  loff_t *ppos)\n{\n\treturn -EPERM;\n}\n\nconst struct file_operations event_inject_fops = {\n\t.open = tracing_open_file_tr,\n\t.read = event_inject_read,\n\t.write = event_inject_write,\n\t.release = tracing_release_file_tr,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}