{
  "module_name": "Kconfig",
  "hash_id": "b12e9dcf6f9610ce3f12f0739089cb0e83c0c306114951073a3a6fd12b8f8346",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Architectures that offer an FUNCTION_TRACER implementation should\n#  select HAVE_FUNCTION_TRACER:\n#\n\nconfig USER_STACKTRACE_SUPPORT\n\tbool\n\nconfig NOP_TRACER\n\tbool\n\nconfig HAVE_RETHOOK\n\tbool\n\nconfig RETHOOK\n\tbool\n\tdepends on HAVE_RETHOOK\n\thelp\n\t  Enable generic return hooking feature. This is an internal\n\t  API, which will be used by other function-entry hooking\n\t  features like fprobe and kprobes.\n\nconfig HAVE_FUNCTION_TRACER\n\tbool\n\thelp\n\t  See Documentation/trace/ftrace-design.rst\n\nconfig HAVE_FUNCTION_GRAPH_TRACER\n\tbool\n\thelp\n\t  See Documentation/trace/ftrace-design.rst\n\nconfig HAVE_FUNCTION_GRAPH_RETVAL\n\tbool\n\nconfig HAVE_DYNAMIC_FTRACE\n\tbool\n\thelp\n\t  See Documentation/trace/ftrace-design.rst\n\nconfig HAVE_DYNAMIC_FTRACE_WITH_REGS\n\tbool\n\nconfig HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS\n\tbool\n\nconfig HAVE_DYNAMIC_FTRACE_WITH_CALL_OPS\n\tbool\n\nconfig HAVE_DYNAMIC_FTRACE_WITH_ARGS\n\tbool\n\thelp\n\t If this is set, then arguments and stack can be found from\n\t the ftrace_regs passed into the function callback regs parameter\n\t by default, even without setting the REGS flag in the ftrace_ops.\n\t This allows for use of ftrace_regs_get_argument() and\n\t ftrace_regs_get_stack_pointer().\n\nconfig HAVE_DYNAMIC_FTRACE_NO_PATCHABLE\n\tbool\n\thelp\n\t  If the architecture generates __patchable_function_entries sections\n\t  but does not want them included in the ftrace locations.\n\nconfig HAVE_FTRACE_MCOUNT_RECORD\n\tbool\n\thelp\n\t  See Documentation/trace/ftrace-design.rst\n\nconfig HAVE_SYSCALL_TRACEPOINTS\n\tbool\n\thelp\n\t  See Documentation/trace/ftrace-design.rst\n\nconfig HAVE_FENTRY\n\tbool\n\thelp\n\t  Arch supports the gcc options -pg with -mfentry\n\nconfig HAVE_NOP_MCOUNT\n\tbool\n\thelp\n\t  Arch supports the gcc options -pg with -mrecord-mcount and -nop-mcount\n\nconfig HAVE_OBJTOOL_MCOUNT\n\tbool\n\thelp\n\t  Arch supports objtool --mcount\n\nconfig HAVE_OBJTOOL_NOP_MCOUNT\n\tbool\n\thelp\n\t  Arch supports the objtool options --mcount with --mnop.\n\t  An architecture can select this if it wants to enable nop'ing\n\t  of ftrace locations.\n\nconfig HAVE_C_RECORDMCOUNT\n\tbool\n\thelp\n\t  C version of recordmcount available?\n\nconfig HAVE_BUILDTIME_MCOUNT_SORT\n       bool\n       help\n         An architecture selects this if it sorts the mcount_loc section\n\t at build time.\n\nconfig BUILDTIME_MCOUNT_SORT\n       bool\n       default y\n       depends on HAVE_BUILDTIME_MCOUNT_SORT && DYNAMIC_FTRACE\n       help\n         Sort the mcount_loc section at build time.\n\nconfig TRACER_MAX_TRACE\n\tbool\n\nconfig TRACE_CLOCK\n\tbool\n\nconfig RING_BUFFER\n\tbool\n\tselect TRACE_CLOCK\n\tselect IRQ_WORK\n\nconfig EVENT_TRACING\n\tselect CONTEXT_SWITCH_TRACER\n\tselect GLOB\n\tbool\n\nconfig CONTEXT_SWITCH_TRACER\n\tbool\n\nconfig RING_BUFFER_ALLOW_SWAP\n\tbool\n\thelp\n\t Allow the use of ring_buffer_swap_cpu.\n\t Adds a very slight overhead to tracing when enabled.\n\nconfig PREEMPTIRQ_TRACEPOINTS\n\tbool\n\tdepends on TRACE_PREEMPT_TOGGLE || TRACE_IRQFLAGS\n\tselect TRACING\n\tdefault y\n\thelp\n\t  Create preempt/irq toggle tracepoints if needed, so that other parts\n\t  of the kernel can use them to generate or add hooks to them.\n\n# All tracer options should select GENERIC_TRACER. For those options that are\n# enabled by all tracers (context switch and event tracer) they select TRACING.\n# This allows those options to appear when no other tracer is selected. But the\n# options do not appear when something else selects it. We need the two options\n# GENERIC_TRACER and TRACING to avoid circular dependencies to accomplish the\n# hiding of the automatic options.\n\nconfig TRACING\n\tbool\n\tselect RING_BUFFER\n\tselect STACKTRACE if STACKTRACE_SUPPORT\n\tselect TRACEPOINTS\n\tselect NOP_TRACER\n\tselect BINARY_PRINTF\n\tselect EVENT_TRACING\n\tselect TRACE_CLOCK\n\tselect TASKS_RCU if PREEMPTION\n\nconfig GENERIC_TRACER\n\tbool\n\tselect TRACING\n\n#\n# Minimum requirements an architecture has to meet for us to\n# be able to offer generic tracing facilities:\n#\nconfig TRACING_SUPPORT\n\tbool\n\tdepends on TRACE_IRQFLAGS_SUPPORT\n\tdepends on STACKTRACE_SUPPORT\n\tdefault y\n\nmenuconfig FTRACE\n\tbool \"Tracers\"\n\tdepends on TRACING_SUPPORT\n\tdefault y if DEBUG_KERNEL\n\thelp\n\t  Enable the kernel tracing infrastructure.\n\nif FTRACE\n\nconfig BOOTTIME_TRACING\n\tbool \"Boot-time Tracing support\"\n\tdepends on TRACING\n\tselect BOOT_CONFIG\n\thelp\n\t  Enable developer to setup ftrace subsystem via supplemental\n\t  kernel cmdline at boot time for debugging (tracing) driver\n\t  initialization and boot process.\n\nconfig FUNCTION_TRACER\n\tbool \"Kernel Function Tracer\"\n\tdepends on HAVE_FUNCTION_TRACER\n\tselect KALLSYMS\n\tselect GENERIC_TRACER\n\tselect CONTEXT_SWITCH_TRACER\n\tselect GLOB\n\tselect TASKS_RCU if PREEMPTION\n\tselect TASKS_RUDE_RCU\n\thelp\n\t  Enable the kernel to trace every kernel function. This is done\n\t  by using a compiler feature to insert a small, 5-byte No-Operation\n\t  instruction at the beginning of every kernel function, which NOP\n\t  sequence is then dynamically patched into a tracer call when\n\t  tracing is enabled by the administrator. If it's runtime disabled\n\t  (the bootup default), then the overhead of the instructions is very\n\t  small and not measurable even in micro-benchmarks (at least on\n\t  x86, but may have impact on other architectures).\n\nconfig FUNCTION_GRAPH_TRACER\n\tbool \"Kernel Function Graph Tracer\"\n\tdepends on HAVE_FUNCTION_GRAPH_TRACER\n\tdepends on FUNCTION_TRACER\n\tdepends on !X86_32 || !CC_OPTIMIZE_FOR_SIZE\n\tdefault y\n\thelp\n\t  Enable the kernel to trace a function at both its return\n\t  and its entry.\n\t  Its first purpose is to trace the duration of functions and\n\t  draw a call graph for each thread with some information like\n\t  the return value. This is done by setting the current return\n\t  address on the current task structure into a stack of calls.\n\nconfig FUNCTION_GRAPH_RETVAL\n\tbool \"Kernel Function Graph Return Value\"\n\tdepends on HAVE_FUNCTION_GRAPH_RETVAL\n\tdepends on FUNCTION_GRAPH_TRACER\n\tdefault n\n\thelp\n\t  Support recording and printing the function return value when\n\t  using function graph tracer. It can be helpful to locate functions\n\t  that return errors. This feature is off by default, and you can\n\t  enable it via the trace option funcgraph-retval.\n\t  See Documentation/trace/ftrace.rst\n\nconfig DYNAMIC_FTRACE\n\tbool \"enable/disable function tracing dynamically\"\n\tdepends on FUNCTION_TRACER\n\tdepends on HAVE_DYNAMIC_FTRACE\n\tdefault y\n\thelp\n\t  This option will modify all the calls to function tracing\n\t  dynamically (will patch them out of the binary image and\n\t  replace them with a No-Op instruction) on boot up. During\n\t  compile time, a table is made of all the locations that ftrace\n\t  can function trace, and this table is linked into the kernel\n\t  image. When this is enabled, functions can be individually\n\t  enabled, and the functions not enabled will not affect\n\t  performance of the system.\n\n\t  See the files in /sys/kernel/tracing:\n\t    available_filter_functions\n\t    set_ftrace_filter\n\t    set_ftrace_notrace\n\n\t  This way a CONFIG_FUNCTION_TRACER kernel is slightly larger, but\n\t  otherwise has native performance as long as no tracing is active.\n\nconfig DYNAMIC_FTRACE_WITH_REGS\n\tdef_bool y\n\tdepends on DYNAMIC_FTRACE\n\tdepends on HAVE_DYNAMIC_FTRACE_WITH_REGS\n\nconfig DYNAMIC_FTRACE_WITH_DIRECT_CALLS\n\tdef_bool y\n\tdepends on DYNAMIC_FTRACE_WITH_REGS || DYNAMIC_FTRACE_WITH_ARGS\n\tdepends on HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS\n\nconfig DYNAMIC_FTRACE_WITH_CALL_OPS\n\tdef_bool y\n\tdepends on HAVE_DYNAMIC_FTRACE_WITH_CALL_OPS\n\nconfig DYNAMIC_FTRACE_WITH_ARGS\n\tdef_bool y\n\tdepends on DYNAMIC_FTRACE\n\tdepends on HAVE_DYNAMIC_FTRACE_WITH_ARGS\n\nconfig FPROBE\n\tbool \"Kernel Function Probe (fprobe)\"\n\tdepends on FUNCTION_TRACER\n\tdepends on DYNAMIC_FTRACE_WITH_REGS\n\tdepends on HAVE_RETHOOK\n\tselect RETHOOK\n\tdefault n\n\thelp\n\t  This option enables kernel function probe (fprobe) based on ftrace.\n\t  The fprobe is similar to kprobes, but probes only for kernel function\n\t  entries and exits. This also can probe multiple functions by one\n\t  fprobe.\n\n\t  If unsure, say N.\n\nconfig FUNCTION_PROFILER\n\tbool \"Kernel function profiler\"\n\tdepends on FUNCTION_TRACER\n\tdefault n\n\thelp\n\t  This option enables the kernel function profiler. A file is created\n\t  in debugfs called function_profile_enabled which defaults to zero.\n\t  When a 1 is echoed into this file profiling begins, and when a\n\t  zero is entered, profiling stops. A \"functions\" file is created in\n\t  the trace_stat directory; this file shows the list of functions that\n\t  have been hit and their counters.\n\n\t  If in doubt, say N.\n\nconfig STACK_TRACER\n\tbool \"Trace max stack\"\n\tdepends on HAVE_FUNCTION_TRACER\n\tselect FUNCTION_TRACER\n\tselect STACKTRACE\n\tselect KALLSYMS\n\thelp\n\t  This special tracer records the maximum stack footprint of the\n\t  kernel and displays it in /sys/kernel/tracing/stack_trace.\n\n\t  This tracer works by hooking into every function call that the\n\t  kernel executes, and keeping a maximum stack depth value and\n\t  stack-trace saved.  If this is configured with DYNAMIC_FTRACE\n\t  then it will not have any overhead while the stack tracer\n\t  is disabled.\n\n\t  To enable the stack tracer on bootup, pass in 'stacktrace'\n\t  on the kernel command line.\n\n\t  The stack tracer can also be enabled or disabled via the\n\t  sysctl kernel.stack_tracer_enabled\n\n\t  Say N if unsure.\n\nconfig TRACE_PREEMPT_TOGGLE\n\tbool\n\thelp\n\t  Enables hooks which will be called when preemption is first disabled,\n\t  and last enabled.\n\nconfig IRQSOFF_TRACER\n\tbool \"Interrupts-off Latency Tracer\"\n\tdefault n\n\tdepends on TRACE_IRQFLAGS_SUPPORT\n\tselect TRACE_IRQFLAGS\n\tselect GENERIC_TRACER\n\tselect TRACER_MAX_TRACE\n\tselect RING_BUFFER_ALLOW_SWAP\n\tselect TRACER_SNAPSHOT\n\tselect TRACER_SNAPSHOT_PER_CPU_SWAP\n\thelp\n\t  This option measures the time spent in irqs-off critical\n\t  sections, with microsecond accuracy.\n\n\t  The default measurement method is a maximum search, which is\n\t  disabled by default and can be runtime (re-)started\n\t  via:\n\n\t      echo 0 > /sys/kernel/tracing/tracing_max_latency\n\n\t  (Note that kernel size and overhead increase with this option\n\t  enabled. This option and the preempt-off timing option can be\n\t  used together or separately.)\n\nconfig PREEMPT_TRACER\n\tbool \"Preemption-off Latency Tracer\"\n\tdefault n\n\tdepends on PREEMPTION\n\tselect GENERIC_TRACER\n\tselect TRACER_MAX_TRACE\n\tselect RING_BUFFER_ALLOW_SWAP\n\tselect TRACER_SNAPSHOT\n\tselect TRACER_SNAPSHOT_PER_CPU_SWAP\n\tselect TRACE_PREEMPT_TOGGLE\n\thelp\n\t  This option measures the time spent in preemption-off critical\n\t  sections, with microsecond accuracy.\n\n\t  The default measurement method is a maximum search, which is\n\t  disabled by default and can be runtime (re-)started\n\t  via:\n\n\t      echo 0 > /sys/kernel/tracing/tracing_max_latency\n\n\t  (Note that kernel size and overhead increase with this option\n\t  enabled. This option and the irqs-off timing option can be\n\t  used together or separately.)\n\nconfig SCHED_TRACER\n\tbool \"Scheduling Latency Tracer\"\n\tselect GENERIC_TRACER\n\tselect CONTEXT_SWITCH_TRACER\n\tselect TRACER_MAX_TRACE\n\tselect TRACER_SNAPSHOT\n\thelp\n\t  This tracer tracks the latency of the highest priority task\n\t  to be scheduled in, starting from the point it has woken up.\n\nconfig HWLAT_TRACER\n\tbool \"Tracer to detect hardware latencies (like SMIs)\"\n\tselect GENERIC_TRACER\n\tselect TRACER_MAX_TRACE\n\thelp\n\t This tracer, when enabled will create one or more kernel threads,\n\t depending on what the cpumask file is set to, which each thread\n\t spinning in a loop looking for interruptions caused by\n\t something other than the kernel. For example, if a\n\t System Management Interrupt (SMI) takes a noticeable amount of\n\t time, this tracer will detect it. This is useful for testing\n\t if a system is reliable for Real Time tasks.\n\n\t Some files are created in the tracing directory when this\n\t is enabled:\n\n\t   hwlat_detector/width   - time in usecs for how long to spin for\n\t   hwlat_detector/window  - time in usecs between the start of each\n\t\t\t\t     iteration\n\n\t A kernel thread is created that will spin with interrupts disabled\n\t for \"width\" microseconds in every \"window\" cycle. It will not spin\n\t for \"window - width\" microseconds, where the system can\n\t continue to operate.\n\n\t The output will appear in the trace and trace_pipe files.\n\n\t When the tracer is not running, it has no affect on the system,\n\t but when it is running, it can cause the system to be\n\t periodically non responsive. Do not run this tracer on a\n\t production system.\n\n\t To enable this tracer, echo in \"hwlat\" into the current_tracer\n\t file. Every time a latency is greater than tracing_thresh, it will\n\t be recorded into the ring buffer.\n\nconfig OSNOISE_TRACER\n\tbool \"OS Noise tracer\"\n\tselect GENERIC_TRACER\n\tselect TRACER_MAX_TRACE\n\thelp\n\t  In the context of high-performance computing (HPC), the Operating\n\t  System Noise (osnoise) refers to the interference experienced by an\n\t  application due to activities inside the operating system. In the\n\t  context of Linux, NMIs, IRQs, SoftIRQs, and any other system thread\n\t  can cause noise to the system. Moreover, hardware-related jobs can\n\t  also cause noise, for example, via SMIs.\n\n\t  The osnoise tracer leverages the hwlat_detector by running a similar\n\t  loop with preemption, SoftIRQs and IRQs enabled, thus allowing all\n\t  the sources of osnoise during its execution. The osnoise tracer takes\n\t  note of the entry and exit point of any source of interferences,\n\t  increasing a per-cpu interference counter. It saves an interference\n\t  counter for each source of interference. The interference counter for\n\t  NMI, IRQs, SoftIRQs, and threads is increased anytime the tool\n\t  observes these interferences' entry events. When a noise happens\n\t  without any interference from the operating system level, the\n\t  hardware noise counter increases, pointing to a hardware-related\n\t  noise. In this way, osnoise can account for any source of\n\t  interference. At the end of the period, the osnoise tracer prints\n\t  the sum of all noise, the max single noise, the percentage of CPU\n\t  available for the thread, and the counters for the noise sources.\n\n\t  In addition to the tracer, a set of tracepoints were added to\n\t  facilitate the identification of the osnoise source.\n\n\t  The output will appear in the trace and trace_pipe files.\n\n\t  To enable this tracer, echo in \"osnoise\" into the current_tracer\n          file.\n\nconfig TIMERLAT_TRACER\n\tbool \"Timerlat tracer\"\n\tselect OSNOISE_TRACER\n\tselect GENERIC_TRACER\n\thelp\n\t  The timerlat tracer aims to help the preemptive kernel developers\n\t  to find sources of wakeup latencies of real-time threads.\n\n\t  The tracer creates a per-cpu kernel thread with real-time priority.\n\t  The tracer thread sets a periodic timer to wakeup itself, and goes\n\t  to sleep waiting for the timer to fire. At the wakeup, the thread\n\t  then computes a wakeup latency value as the difference between\n\t  the current time and the absolute time that the timer was set\n\t  to expire.\n\n\t  The tracer prints two lines at every activation. The first is the\n\t  timer latency observed at the hardirq context before the\n\t  activation of the thread. The second is the timer latency observed\n\t  by the thread, which is the same level that cyclictest reports. The\n\t  ACTIVATION ID field serves to relate the irq execution to its\n\t  respective thread execution.\n\n\t  The tracer is build on top of osnoise tracer, and the osnoise:\n\t  events can be used to trace the source of interference from NMI,\n\t  IRQs and other threads. It also enables the capture of the\n\t  stacktrace at the IRQ context, which helps to identify the code\n\t  path that can cause thread delay.\n\nconfig MMIOTRACE\n\tbool \"Memory mapped IO tracing\"\n\tdepends on HAVE_MMIOTRACE_SUPPORT && PCI\n\tselect GENERIC_TRACER\n\thelp\n\t  Mmiotrace traces Memory Mapped I/O access and is meant for\n\t  debugging and reverse engineering. It is called from the ioremap\n\t  implementation and works via page faults. Tracing is disabled by\n\t  default and can be enabled at run-time.\n\n\t  See Documentation/trace/mmiotrace.rst.\n\t  If you are not helping to develop drivers, say N.\n\nconfig ENABLE_DEFAULT_TRACERS\n\tbool \"Trace process context switches and events\"\n\tdepends on !GENERIC_TRACER\n\tselect TRACING\n\thelp\n\t  This tracer hooks to various trace points in the kernel,\n\t  allowing the user to pick and choose which trace point they\n\t  want to trace. It also includes the sched_switch tracer plugin.\n\nconfig FTRACE_SYSCALLS\n\tbool \"Trace syscalls\"\n\tdepends on HAVE_SYSCALL_TRACEPOINTS\n\tselect GENERIC_TRACER\n\tselect KALLSYMS\n\thelp\n\t  Basic tracer to catch the syscall entry and exit events.\n\nconfig TRACER_SNAPSHOT\n\tbool \"Create a snapshot trace buffer\"\n\tselect TRACER_MAX_TRACE\n\thelp\n\t  Allow tracing users to take snapshot of the current buffer using the\n\t  ftrace interface, e.g.:\n\n\t      echo 1 > /sys/kernel/tracing/snapshot\n\t      cat snapshot\n\nconfig TRACER_SNAPSHOT_PER_CPU_SWAP\n\tbool \"Allow snapshot to swap per CPU\"\n\tdepends on TRACER_SNAPSHOT\n\tselect RING_BUFFER_ALLOW_SWAP\n\thelp\n\t  Allow doing a snapshot of a single CPU buffer instead of a\n\t  full swap (all buffers). If this is set, then the following is\n\t  allowed:\n\n\t      echo 1 > /sys/kernel/tracing/per_cpu/cpu2/snapshot\n\n\t  After which, only the tracing buffer for CPU 2 was swapped with\n\t  the main tracing buffer, and the other CPU buffers remain the same.\n\n\t  When this is enabled, this adds a little more overhead to the\n\t  trace recording, as it needs to add some checks to synchronize\n\t  recording with swaps. But this does not affect the performance\n\t  of the overall system. This is enabled by default when the preempt\n\t  or irq latency tracers are enabled, as those need to swap as well\n\t  and already adds the overhead (plus a lot more).\n\nconfig TRACE_BRANCH_PROFILING\n\tbool\n\tselect GENERIC_TRACER\n\nchoice\n\tprompt \"Branch Profiling\"\n\tdefault BRANCH_PROFILE_NONE\n\thelp\n\t The branch profiling is a software profiler. It will add hooks\n\t into the C conditionals to test which path a branch takes.\n\n\t The likely/unlikely profiler only looks at the conditions that\n\t are annotated with a likely or unlikely macro.\n\n\t The \"all branch\" profiler will profile every if-statement in the\n\t kernel. This profiler will also enable the likely/unlikely\n\t profiler.\n\n\t Either of the above profilers adds a bit of overhead to the system.\n\t If unsure, choose \"No branch profiling\".\n\nconfig BRANCH_PROFILE_NONE\n\tbool \"No branch profiling\"\n\thelp\n\t  No branch profiling. Branch profiling adds a bit of overhead.\n\t  Only enable it if you want to analyse the branching behavior.\n\t  Otherwise keep it disabled.\n\nconfig PROFILE_ANNOTATED_BRANCHES\n\tbool \"Trace likely/unlikely profiler\"\n\tselect TRACE_BRANCH_PROFILING\n\thelp\n\t  This tracer profiles all likely and unlikely macros\n\t  in the kernel. It will display the results in:\n\n\t  /sys/kernel/tracing/trace_stat/branch_annotated\n\n\t  Note: this will add a significant overhead; only turn this\n\t  on if you need to profile the system's use of these macros.\n\nconfig PROFILE_ALL_BRANCHES\n\tbool \"Profile all if conditionals\" if !FORTIFY_SOURCE\n\tselect TRACE_BRANCH_PROFILING\n\thelp\n\t  This tracer profiles all branch conditions. Every if ()\n\t  taken in the kernel is recorded whether it hit or miss.\n\t  The results will be displayed in:\n\n\t  /sys/kernel/tracing/trace_stat/branch_all\n\n\t  This option also enables the likely/unlikely profiler.\n\n\t  This configuration, when enabled, will impose a great overhead\n\t  on the system. This should only be enabled when the system\n\t  is to be analyzed in much detail.\nendchoice\n\nconfig TRACING_BRANCHES\n\tbool\n\thelp\n\t  Selected by tracers that will trace the likely and unlikely\n\t  conditions. This prevents the tracers themselves from being\n\t  profiled. Profiling the tracing infrastructure can only happen\n\t  when the likelys and unlikelys are not being traced.\n\nconfig BRANCH_TRACER\n\tbool \"Trace likely/unlikely instances\"\n\tdepends on TRACE_BRANCH_PROFILING\n\tselect TRACING_BRANCHES\n\thelp\n\t  This traces the events of likely and unlikely condition\n\t  calls in the kernel.  The difference between this and the\n\t  \"Trace likely/unlikely profiler\" is that this is not a\n\t  histogram of the callers, but actually places the calling\n\t  events into a running trace buffer to see when and where the\n\t  events happened, as well as their results.\n\n\t  Say N if unsure.\n\nconfig BLK_DEV_IO_TRACE\n\tbool \"Support for tracing block IO actions\"\n\tdepends on SYSFS\n\tdepends on BLOCK\n\tselect RELAY\n\tselect DEBUG_FS\n\tselect TRACEPOINTS\n\tselect GENERIC_TRACER\n\tselect STACKTRACE\n\thelp\n\t  Say Y here if you want to be able to trace the block layer actions\n\t  on a given queue. Tracing allows you to see any traffic happening\n\t  on a block device queue. For more information (and the userspace\n\t  support tools needed), fetch the blktrace tools from:\n\n\t  git://git.kernel.dk/blktrace.git\n\n\t  Tracing also is possible using the ftrace interface, e.g.:\n\n\t    echo 1 > /sys/block/sda/sda1/trace/enable\n\t    echo blk > /sys/kernel/tracing/current_tracer\n\t    cat /sys/kernel/tracing/trace_pipe\n\n\t  If unsure, say N.\n\nconfig FPROBE_EVENTS\n\tdepends on FPROBE\n\tdepends on HAVE_REGS_AND_STACK_ACCESS_API\n\tbool \"Enable fprobe-based dynamic events\"\n\tselect TRACING\n\tselect PROBE_EVENTS\n\tselect DYNAMIC_EVENTS\n\tdefault y\n\thelp\n\t  This allows user to add tracing events on the function entry and\n\t  exit via ftrace interface. The syntax is same as the kprobe events\n\t  and the kprobe events on function entry and exit will be\n\t  transparently converted to this fprobe events.\n\nconfig PROBE_EVENTS_BTF_ARGS\n\tdepends on HAVE_FUNCTION_ARG_ACCESS_API\n\tdepends on FPROBE_EVENTS || KPROBE_EVENTS\n\tdepends on DEBUG_INFO_BTF && BPF_SYSCALL\n\tbool \"Support BTF function arguments for probe events\"\n\tdefault y\n\thelp\n\t  The user can specify the arguments of the probe event using the names\n\t  of the arguments of the probed function, when the probe location is a\n\t  kernel function entry or a tracepoint.\n\t  This is available only if BTF (BPF Type Format) support is enabled.\n\nconfig KPROBE_EVENTS\n\tdepends on KPROBES\n\tdepends on HAVE_REGS_AND_STACK_ACCESS_API\n\tbool \"Enable kprobes-based dynamic events\"\n\tselect TRACING\n\tselect PROBE_EVENTS\n\tselect DYNAMIC_EVENTS\n\tdefault y\n\thelp\n\t  This allows the user to add tracing events (similar to tracepoints)\n\t  on the fly via the ftrace interface. See\n\t  Documentation/trace/kprobetrace.rst for more details.\n\n\t  Those events can be inserted wherever kprobes can probe, and record\n\t  various register and memory values.\n\n\t  This option is also required by perf-probe subcommand of perf tools.\n\t  If you want to use perf tools, this option is strongly recommended.\n\nconfig KPROBE_EVENTS_ON_NOTRACE\n\tbool \"Do NOT protect notrace function from kprobe events\"\n\tdepends on KPROBE_EVENTS\n\tdepends on DYNAMIC_FTRACE\n\tdefault n\n\thelp\n\t  This is only for the developers who want to debug ftrace itself\n\t  using kprobe events.\n\n\t  If kprobes can use ftrace instead of breakpoint, ftrace related\n\t  functions are protected from kprobe-events to prevent an infinite\n\t  recursion or any unexpected execution path which leads to a kernel\n\t  crash.\n\n\t  This option disables such protection and allows you to put kprobe\n\t  events on ftrace functions for debugging ftrace by itself.\n\t  Note that this might let you shoot yourself in the foot.\n\n\t  If unsure, say N.\n\nconfig UPROBE_EVENTS\n\tbool \"Enable uprobes-based dynamic events\"\n\tdepends on ARCH_SUPPORTS_UPROBES\n\tdepends on MMU\n\tdepends on PERF_EVENTS\n\tselect UPROBES\n\tselect PROBE_EVENTS\n\tselect DYNAMIC_EVENTS\n\tselect TRACING\n\tdefault y\n\thelp\n\t  This allows the user to add tracing events on top of userspace\n\t  dynamic events (similar to tracepoints) on the fly via the trace\n\t  events interface. Those events can be inserted wherever uprobes\n\t  can probe, and record various registers.\n\t  This option is required if you plan to use perf-probe subcommand\n\t  of perf tools on user space applications.\n\nconfig BPF_EVENTS\n\tdepends on BPF_SYSCALL\n\tdepends on (KPROBE_EVENTS || UPROBE_EVENTS) && PERF_EVENTS\n\tbool\n\tdefault y\n\thelp\n\t  This allows the user to attach BPF programs to kprobe, uprobe, and\n\t  tracepoint events.\n\nconfig DYNAMIC_EVENTS\n\tdef_bool n\n\nconfig PROBE_EVENTS\n\tdef_bool n\n\nconfig BPF_KPROBE_OVERRIDE\n\tbool \"Enable BPF programs to override a kprobed function\"\n\tdepends on BPF_EVENTS\n\tdepends on FUNCTION_ERROR_INJECTION\n\tdefault n\n\thelp\n\t Allows BPF to override the execution of a probed function and\n\t set a different return value.  This is used for error injection.\n\nconfig FTRACE_MCOUNT_RECORD\n\tdef_bool y\n\tdepends on DYNAMIC_FTRACE\n\tdepends on HAVE_FTRACE_MCOUNT_RECORD\n\nconfig FTRACE_MCOUNT_USE_PATCHABLE_FUNCTION_ENTRY\n\tbool\n\tdepends on FTRACE_MCOUNT_RECORD\n\nconfig FTRACE_MCOUNT_USE_CC\n\tdef_bool y\n\tdepends on $(cc-option,-mrecord-mcount)\n\tdepends on !FTRACE_MCOUNT_USE_PATCHABLE_FUNCTION_ENTRY\n\tdepends on FTRACE_MCOUNT_RECORD\n\nconfig FTRACE_MCOUNT_USE_OBJTOOL\n\tdef_bool y\n\tdepends on HAVE_OBJTOOL_MCOUNT\n\tdepends on !FTRACE_MCOUNT_USE_PATCHABLE_FUNCTION_ENTRY\n\tdepends on !FTRACE_MCOUNT_USE_CC\n\tdepends on FTRACE_MCOUNT_RECORD\n\tselect OBJTOOL\n\nconfig FTRACE_MCOUNT_USE_RECORDMCOUNT\n\tdef_bool y\n\tdepends on !FTRACE_MCOUNT_USE_PATCHABLE_FUNCTION_ENTRY\n\tdepends on !FTRACE_MCOUNT_USE_CC\n\tdepends on !FTRACE_MCOUNT_USE_OBJTOOL\n\tdepends on FTRACE_MCOUNT_RECORD\n\nconfig TRACING_MAP\n\tbool\n\tdepends on ARCH_HAVE_NMI_SAFE_CMPXCHG\n\thelp\n\t  tracing_map is a special-purpose lock-free map for tracing,\n\t  separated out as a stand-alone facility in order to allow it\n\t  to be shared between multiple tracers.  It isn't meant to be\n\t  generally used outside of that context, and is normally\n\t  selected by tracers that use it.\n\nconfig SYNTH_EVENTS\n\tbool \"Synthetic trace events\"\n\tselect TRACING\n\tselect DYNAMIC_EVENTS\n\tdefault n\n\thelp\n\t  Synthetic events are user-defined trace events that can be\n\t  used to combine data from other trace events or in fact any\n\t  data source.  Synthetic events can be generated indirectly\n\t  via the trace() action of histogram triggers or directly\n\t  by way of an in-kernel API.\n\n\t  See Documentation/trace/events.rst or\n\t  Documentation/trace/histogram.rst for details and examples.\n\n\t  If in doubt, say N.\n\nconfig USER_EVENTS\n\tbool \"User trace events\"\n\tselect TRACING\n\tselect DYNAMIC_EVENTS\n\thelp\n\t  User trace events are user-defined trace events that\n\t  can be used like an existing kernel trace event.  User trace\n\t  events are generated by writing to a tracefs file.  User\n\t  processes can determine if their tracing events should be\n\t  generated by registering a value and bit with the kernel\n\t  that reflects when it is enabled or not.\n\n\t  See Documentation/trace/user_events.rst.\n\t  If in doubt, say N.\n\nconfig HIST_TRIGGERS\n\tbool \"Histogram triggers\"\n\tdepends on ARCH_HAVE_NMI_SAFE_CMPXCHG\n\tselect TRACING_MAP\n\tselect TRACING\n\tselect DYNAMIC_EVENTS\n\tselect SYNTH_EVENTS\n\tdefault n\n\thelp\n\t  Hist triggers allow one or more arbitrary trace event fields\n\t  to be aggregated into hash tables and dumped to stdout by\n\t  reading a debugfs/tracefs file.  They're useful for\n\t  gathering quick and dirty (though precise) summaries of\n\t  event activity as an initial guide for further investigation\n\t  using more advanced tools.\n\n\t  Inter-event tracing of quantities such as latencies is also\n\t  supported using hist triggers under this option.\n\n\t  See Documentation/trace/histogram.rst.\n\t  If in doubt, say N.\n\nconfig TRACE_EVENT_INJECT\n\tbool \"Trace event injection\"\n\tdepends on TRACING\n\thelp\n\t  Allow user-space to inject a specific trace event into the ring\n\t  buffer. This is mainly used for testing purpose.\n\n\t  If unsure, say N.\n\nconfig TRACEPOINT_BENCHMARK\n\tbool \"Add tracepoint that benchmarks tracepoints\"\n\thelp\n\t This option creates the tracepoint \"benchmark:benchmark_event\".\n\t When the tracepoint is enabled, it kicks off a kernel thread that\n\t goes into an infinite loop (calling cond_resched() to let other tasks\n\t run), and calls the tracepoint. Each iteration will record the time\n\t it took to write to the tracepoint and the next iteration that\n\t data will be passed to the tracepoint itself. That is, the tracepoint\n\t will report the time it took to do the previous tracepoint.\n\t The string written to the tracepoint is a static string of 128 bytes\n\t to keep the time the same. The initial string is simply a write of\n\t \"START\". The second string records the cold cache time of the first\n\t write which is not added to the rest of the calculations.\n\n\t As it is a tight loop, it benchmarks as hot cache. That's fine because\n\t we care most about hot paths that are probably in cache already.\n\n\t An example of the output:\n\n\t      START\n\t      first=3672 [COLD CACHED]\n\t      last=632 first=3672 max=632 min=632 avg=316 std=446 std^2=199712\n\t      last=278 first=3672 max=632 min=278 avg=303 std=316 std^2=100337\n\t      last=277 first=3672 max=632 min=277 avg=296 std=258 std^2=67064\n\t      last=273 first=3672 max=632 min=273 avg=292 std=224 std^2=50411\n\t      last=273 first=3672 max=632 min=273 avg=288 std=200 std^2=40389\n\t      last=281 first=3672 max=632 min=273 avg=287 std=183 std^2=33666\n\n\nconfig RING_BUFFER_BENCHMARK\n\ttristate \"Ring buffer benchmark stress tester\"\n\tdepends on RING_BUFFER\n\thelp\n\t  This option creates a test to stress the ring buffer and benchmark it.\n\t  It creates its own ring buffer such that it will not interfere with\n\t  any other users of the ring buffer (such as ftrace). It then creates\n\t  a producer and consumer that will run for 10 seconds and sleep for\n\t  10 seconds. Each interval it will print out the number of events\n\t  it recorded and give a rough estimate of how long each iteration took.\n\n\t  It does not disable interrupts or raise its priority, so it may be\n\t  affected by processes that are running.\n\n\t  If unsure, say N.\n\nconfig TRACE_EVAL_MAP_FILE\n       bool \"Show eval mappings for trace events\"\n       depends on TRACING\n       help\n\tThe \"print fmt\" of the trace events will show the enum/sizeof names\n\tinstead of their values. This can cause problems for user space tools\n\tthat use this string to parse the raw data as user space does not know\n\thow to convert the string to its value.\n\n\tTo fix this, there's a special macro in the kernel that can be used\n\tto convert an enum/sizeof into its value. If this macro is used, then\n\tthe print fmt strings will be converted to their values.\n\n\tIf something does not get converted properly, this option can be\n\tused to show what enums/sizeof the kernel tried to convert.\n\n\tThis option is for debugging the conversions. A file is created\n\tin the tracing directory called \"eval_map\" that will show the\n\tnames matched with their values and what trace event system they\n\tbelong too.\n\n\tNormally, the mapping of the strings to values will be freed after\n\tboot up or module load. With this option, they will not be freed, as\n\tthey are needed for the \"eval_map\" file. Enabling this option will\n\tincrease the memory footprint of the running kernel.\n\n\tIf unsure, say N.\n\nconfig FTRACE_RECORD_RECURSION\n\tbool \"Record functions that recurse in function tracing\"\n\tdepends on FUNCTION_TRACER\n\thelp\n\t  All callbacks that attach to the function tracing have some sort\n\t  of protection against recursion. Even though the protection exists,\n\t  it adds overhead. This option will create a file in the tracefs\n\t  file system called \"recursed_functions\" that will list the functions\n\t  that triggered a recursion.\n\n\t  This will add more overhead to cases that have recursion.\n\n\t  If unsure, say N\n\nconfig FTRACE_RECORD_RECURSION_SIZE\n\tint \"Max number of recursed functions to record\"\n\tdefault\t128\n\tdepends on FTRACE_RECORD_RECURSION\n\thelp\n\t  This defines the limit of number of functions that can be\n\t  listed in the \"recursed_functions\" file, that lists all\n\t  the functions that caused a recursion to happen.\n\t  This file can be reset, but the limit can not change in\n\t  size at runtime.\n\nconfig RING_BUFFER_RECORD_RECURSION\n\tbool \"Record functions that recurse in the ring buffer\"\n\tdepends on FTRACE_RECORD_RECURSION\n\t# default y, because it is coupled with FTRACE_RECORD_RECURSION\n\tdefault y\n\thelp\n\t  The ring buffer has its own internal recursion. Although when\n\t  recursion happens it won't cause harm because of the protection,\n\t  but it does cause unwanted overhead. Enabling this option will\n\t  place where recursion was detected into the ftrace \"recursed_functions\"\n\t  file.\n\n\t  This will add more overhead to cases that have recursion.\n\nconfig GCOV_PROFILE_FTRACE\n\tbool \"Enable GCOV profiling on ftrace subsystem\"\n\tdepends on GCOV_KERNEL\n\thelp\n\t  Enable GCOV profiling on ftrace subsystem for checking\n\t  which functions/lines are tested.\n\n\t  If unsure, say N.\n\n\t  Note that on a kernel compiled with this config, ftrace will\n\t  run significantly slower.\n\nconfig FTRACE_SELFTEST\n\tbool\n\nconfig FTRACE_STARTUP_TEST\n\tbool \"Perform a startup test on ftrace\"\n\tdepends on GENERIC_TRACER\n\tselect FTRACE_SELFTEST\n\thelp\n\t  This option performs a series of startup tests on ftrace. On bootup\n\t  a series of tests are made to verify that the tracer is\n\t  functioning properly. It will do tests on all the configured\n\t  tracers of ftrace.\n\nconfig EVENT_TRACE_STARTUP_TEST\n\tbool \"Run selftest on trace events\"\n\tdepends on FTRACE_STARTUP_TEST\n\tdefault y\n\thelp\n\t  This option performs a test on all trace events in the system.\n\t  It basically just enables each event and runs some code that\n\t  will trigger events (not necessarily the event it enables)\n\t  This may take some time run as there are a lot of events.\n\nconfig EVENT_TRACE_TEST_SYSCALLS\n\tbool \"Run selftest on syscall events\"\n\tdepends on EVENT_TRACE_STARTUP_TEST\n\thelp\n\t This option will also enable testing every syscall event.\n\t It only enables the event and disables it and runs various loads\n\t with the event enabled. This adds a bit more time for kernel boot\n\t up since it runs this on every system call defined.\n\n\t TBD - enable a way to actually call the syscalls as we test their\n\t       events\n\nconfig FTRACE_SORT_STARTUP_TEST\n       bool \"Verify compile time sorting of ftrace functions\"\n       depends on DYNAMIC_FTRACE\n       depends on BUILDTIME_MCOUNT_SORT\n       help\n\t Sorting of the mcount_loc sections that is used to find the\n\t where the ftrace knows where to patch functions for tracing\n\t and other callbacks is done at compile time. But if the sort\n\t is not done correctly, it will cause non-deterministic failures.\n\t When this is set, the sorted sections will be verified that they\n\t are in deed sorted and will warn if they are not.\n\n\t If unsure, say N\n\nconfig RING_BUFFER_STARTUP_TEST\n       bool \"Ring buffer startup self test\"\n       depends on RING_BUFFER\n       help\n\t Run a simple self test on the ring buffer on boot up. Late in the\n\t kernel boot sequence, the test will start that kicks off\n\t a thread per cpu. Each thread will write various size events\n\t into the ring buffer. Another thread is created to send IPIs\n\t to each of the threads, where the IPI handler will also write\n\t to the ring buffer, to test/stress the nesting ability.\n\t If any anomalies are discovered, a warning will be displayed\n\t and all ring buffers will be disabled.\n\n\t The test runs for 10 seconds. This will slow your boot time\n\t by at least 10 more seconds.\n\n\t At the end of the test, statistics and more checks are done.\n\t It will output the stats of each per cpu buffer: What\n\t was written, the sizes, what was read, what was lost, and\n\t other similar details.\n\n\t If unsure, say N\n\nconfig RING_BUFFER_VALIDATE_TIME_DELTAS\n\tbool \"Verify ring buffer time stamp deltas\"\n\tdepends on RING_BUFFER\n\thelp\n\t  This will audit the time stamps on the ring buffer sub\n\t  buffer to make sure that all the time deltas for the\n\t  events on a sub buffer matches the current time stamp.\n\t  This audit is performed for every event that is not\n\t  interrupted, or interrupting another event. A check\n\t  is also made when traversing sub buffers to make sure\n\t  that all the deltas on the previous sub buffer do not\n\t  add up to be greater than the current time stamp.\n\n\t  NOTE: This adds significant overhead to recording of events,\n\t  and should only be used to test the logic of the ring buffer.\n\t  Do not use it on production systems.\n\n\t  Only say Y if you understand what this does, and you\n\t  still want it enabled. Otherwise say N\n\nconfig MMIOTRACE_TEST\n\ttristate \"Test module for mmiotrace\"\n\tdepends on MMIOTRACE && m\n\thelp\n\t  This is a dumb module for testing mmiotrace. It is very dangerous\n\t  as it will write garbage to IO memory starting at a given address.\n\t  However, it should be safe to use on e.g. unused portion of VRAM.\n\n\t  Say N, unless you absolutely know what you are doing.\n\nconfig PREEMPTIRQ_DELAY_TEST\n\ttristate \"Test module to create a preempt / IRQ disable delay thread to test latency tracers\"\n\tdepends on m\n\thelp\n\t  Select this option to build a test module that can help test latency\n\t  tracers by executing a preempt or irq disable section with a user\n\t  configurable delay. The module busy waits for the duration of the\n\t  critical section.\n\n\t  For example, the following invocation generates a burst of three\n\t  irq-disabled critical sections for 500us:\n\t  modprobe preemptirq_delay_test test_mode=irq delay=500 burst_size=3\n\n\t  What's more, if you want to attach the test on the cpu which the latency\n\t  tracer is running on, specify cpu_affinity=cpu_num at the end of the\n\t  command.\n\n\t  If unsure, say N\n\nconfig SYNTH_EVENT_GEN_TEST\n\ttristate \"Test module for in-kernel synthetic event generation\"\n\tdepends on SYNTH_EVENTS\n\thelp\n          This option creates a test module to check the base\n          functionality of in-kernel synthetic event definition and\n          generation.\n\n          To test, insert the module, and then check the trace buffer\n\t  for the generated sample events.\n\n\t  If unsure, say N.\n\nconfig KPROBE_EVENT_GEN_TEST\n\ttristate \"Test module for in-kernel kprobe event generation\"\n\tdepends on KPROBE_EVENTS\n\thelp\n          This option creates a test module to check the base\n          functionality of in-kernel kprobe event definition.\n\n          To test, insert the module, and then check the trace buffer\n\t  for the generated kprobe events.\n\n\t  If unsure, say N.\n\nconfig HIST_TRIGGERS_DEBUG\n\tbool \"Hist trigger debug support\"\n\tdepends on HIST_TRIGGERS\n\thelp\n          Add \"hist_debug\" file for each event, which when read will\n          dump out a bunch of internal details about the hist triggers\n          defined on that event.\n\n          The hist_debug file serves a couple of purposes:\n\n            - Helps developers verify that nothing is broken.\n\n            - Provides educational information to support the details\n              of the hist trigger internals as described by\n              Documentation/trace/histogram-design.rst.\n\n          The hist_debug output only covers the data structures\n          related to the histogram definitions themselves and doesn't\n          display the internals of map buckets or variable values of\n          running histograms.\n\n          If unsure, say N.\n\nsource \"kernel/trace/rv/Kconfig\"\n\nendif # FTRACE\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}