{
  "module_name": "trace_boot.c",
  "hash_id": "4723ba8aae07d6185ec6f51ef90036bd64007bcc23adbf3bb700105a800e0b3a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_boot.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"trace_boot: \" fmt\n\n#include <linux/bootconfig.h>\n#include <linux/cpumask.h>\n#include <linux/ftrace.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/trace.h>\n#include <linux/trace_events.h>\n\n#include \"trace.h\"\n\n#define MAX_BUF_LEN 256\n\nstatic void __init\ntrace_boot_set_instance_options(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar buf[MAX_BUF_LEN];\n\tunsigned long v = 0;\n\n\t \n\txbc_node_for_each_array_value(node, \"options\", anode, p) {\n\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (trace_set_options(tr, buf) < 0)\n\t\t\tpr_err(\"Failed to set option: %s\\n\", buf);\n\t}\n\n\tp = xbc_node_find_value(node, \"tracing_on\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (kstrtoul(p, 10, &v))\n\t\t\tpr_err(\"Failed to set tracing on: %s\\n\", p);\n\t\tif (v)\n\t\t\ttracer_tracing_on(tr);\n\t\telse\n\t\t\ttracer_tracing_off(tr);\n\t}\n\n\tp = xbc_node_find_value(node, \"trace_clock\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_clock(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set trace clock: %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"buffer_size\", NULL);\n\tif (p && *p != '\\0') {\n\t\tv = memparse(p, NULL);\n\t\tif (v < PAGE_SIZE)\n\t\t\tpr_err(\"Buffer size is too small: %s\\n\", p);\n\t\tif (tracing_resize_ring_buffer(tr, v, RING_BUFFER_ALL_CPUS) < 0)\n\t\t\tpr_err(\"Failed to resize trace buffer to %s\\n\", p);\n\t}\n\n\tp = xbc_node_find_value(node, \"cpumask\", NULL);\n\tif (p && *p != '\\0') {\n\t\tcpumask_var_t new_mask;\n\n\t\tif (alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\t\tif (cpumask_parse(p, new_mask) < 0 ||\n\t\t\t    tracing_set_cpumask(tr, new_mask) < 0)\n\t\t\t\tpr_err(\"Failed to set new CPU mask %s\\n\", p);\n\t\t\tfree_cpumask_var(new_mask);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_EVENT_TRACING\nstatic void __init\ntrace_boot_enable_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\n\txbc_node_for_each_array_value(node, \"events\", anode, p) {\n\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0) {\n\t\t\tpr_err(\"String is too long: %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ftrace_set_clr_event(tr, buf, 1) < 0)\n\t\t\tpr_err(\"Failed to enable event: %s\\n\", p);\n\t}\n}\n\n#ifdef CONFIG_KPROBE_EVENTS\nstatic int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tstruct dynevent_cmd cmd;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *val;\n\tint ret = 0;\n\n\txbc_node_for_each_array_value(node, \"probes\", anode, val) {\n\t\tkprobe_event_cmd_init(&cmd, buf, MAX_BUF_LEN);\n\n\t\tret = kprobe_event_gen_cmd_start(&cmd, event, val);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to generate probe: %s\\n\", buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = kprobe_event_gen_cmd_end(&cmd);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to add probe: %s\\n\", buf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n#else\nstatic inline int __init\ntrace_boot_add_kprobe_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Kprobe event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}\n#endif\n\n#ifdef CONFIG_SYNTH_EVENTS\nstatic int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tstruct dynevent_cmd cmd;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p;\n\tint ret;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_BUF_LEN);\n\n\tret = synth_event_gen_cmd_start(&cmd, event, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\txbc_node_for_each_array_value(node, \"fields\", anode, p) {\n\t\tret = synth_event_add_field_str(&cmd, p);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = synth_event_gen_cmd_end(&cmd);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to add synthetic event: %s\\n\", buf);\n\n\treturn ret;\n}\n#else\nstatic inline int __init\ntrace_boot_add_synth_event(struct xbc_node *node, const char *event)\n{\n\tpr_err(\"Synthetic event is not supported.\\n\");\n\treturn -ENOTSUPP;\n}\n#endif\n\n#ifdef CONFIG_HIST_TRIGGERS\nstatic int __init __printf(3, 4)\nappend_printf(char **bufp, char *end, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tif (*bufp == end)\n\t\treturn -ENOSPC;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(*bufp, end - *bufp, fmt, args);\n\tif (ret < end - *bufp) {\n\t\t*bufp += ret;\n\t} else {\n\t\t*bufp = end;\n\t\tret = -ERANGE;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}\n\nstatic int __init\nappend_str_nospace(char **bufp, char *end, const char *str)\n{\n\tchar *p = *bufp;\n\tint len;\n\n\twhile (p < end - 1 && *str != '\\0') {\n\t\tif (!isspace(*str))\n\t\t\t*(p++) = *str;\n\t\tstr++;\n\t}\n\t*p = '\\0';\n\tif (p == end - 1) {\n\t\t*bufp = end;\n\t\treturn -ENOSPC;\n\t}\n\tlen = p - *bufp;\n\t*bufp = p;\n\treturn (int)len;\n}\n\nstatic int __init\ntrace_boot_hist_add_array(struct xbc_node *hnode, char **bufp,\n\t\t\t  char *end, const char *key)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar sep;\n\n\tp = xbc_node_find_value(hnode, key, &anode);\n\tif (p) {\n\t\tif (!anode) {\n\t\t\tpr_err(\"hist.%s requires value(s).\\n\", key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \":%s\", key);\n\t\tsep = '=';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '=')\n\t\t\t\tsep = ',';\n\t\t}\n\t} else\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int __init\ntrace_boot_hist_add_one_handler(struct xbc_node *hnode, char **bufp,\n\t\t\t\tchar *end, const char *handler,\n\t\t\t\tconst char *param)\n{\n\tstruct xbc_node *knode, *anode;\n\tconst char *p;\n\tchar sep;\n\n\t \n\tp = xbc_node_find_value(hnode, param, NULL);\n\tif (!p) {\n\t\tpr_err(\"hist.%s requires '%s' option.\\n\",\n\t\t       xbc_node_get_data(hnode), param);\n\t\treturn -EINVAL;\n\t}\n\tappend_printf(bufp, end, \":%s(%s)\", handler, p);\n\n\t \n\tknode = xbc_node_find_subkey(hnode, \"trace\");\n\tif (!knode)\n\t\tknode = xbc_node_find_subkey(hnode, \"save\");\n\n\tif (knode) {\n\t\tanode = xbc_node_get_child(knode);\n\t\tif (!anode || !xbc_node_is_value(anode)) {\n\t\t\tpr_err(\"hist.%s.%s requires value(s).\\n\",\n\t\t\t       xbc_node_get_data(hnode),\n\t\t\t       xbc_node_get_data(knode));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tappend_printf(bufp, end, \".%s\", xbc_node_get_data(knode));\n\t\tsep = '(';\n\t\txbc_array_for_each_value(anode, p) {\n\t\t\tappend_printf(bufp, end, \"%c%s\", sep, p);\n\t\t\tif (sep == '(')\n\t\t\t\tsep = ',';\n\t\t}\n\t\tappend_printf(bufp, end, \")\");\n\t} else if (xbc_node_find_subkey(hnode, \"snapshot\")) {\n\t\tappend_printf(bufp, end, \".snapshot()\");\n\t} else {\n\t\tpr_err(\"hist.%s requires an action.\\n\",\n\t\t       xbc_node_get_data(hnode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init\ntrace_boot_hist_add_handlers(struct xbc_node *hnode, char **bufp,\n\t\t\t     char *end, const char *param)\n{\n\tstruct xbc_node *node;\n\tconst char *p, *handler;\n\tint ret = 0;\n\n\thandler = xbc_node_get_data(hnode);\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t \n\t\tret = trace_boot_hist_add_one_handler(node, bufp, end, handler, param);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (xbc_node_find_subkey(hnode, param))\n\t\tret = trace_boot_hist_add_one_handler(hnode, bufp, end, handler, param);\n\n\treturn ret;\n}\n\n \nstatic int __init\ntrace_boot_compose_hist_cmd(struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node, *knode;\n\tchar *end = buf + size;\n\tconst char *p;\n\tint ret = 0;\n\n\tappend_printf(&buf, end, \"hist\");\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"keys\");\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tpr_err(\"hist requires keys.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"values\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\tret = trace_boot_hist_add_array(hnode, &buf, end, \"sort\");\n\tif (ret == -EINVAL)\n\t\treturn ret;\n\n\tp = xbc_node_find_value(hnode, \"size\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":size=%s\", p);\n\n\tp = xbc_node_find_value(hnode, \"name\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \":name=%s\", p);\n\n\tnode = xbc_node_find_subkey(hnode, \"var\");\n\tif (node) {\n\t\txbc_node_for_each_key_value(node, knode, p) {\n\t\t\t \n\t\t\tappend_printf(&buf, end, \":%s=\",\n\t\t\t\t      xbc_node_get_data(knode));\n\t\t\tappend_str_nospace(&buf, end, p);\n\t\t}\n\t}\n\n\t \n\tif (xbc_node_find_value(hnode, \"pause\", NULL))\n\t\tappend_printf(&buf, end, \":pause\");\n\telse if (xbc_node_find_value(hnode, \"continue\", NULL))\n\t\tappend_printf(&buf, end, \":continue\");\n\telse if (xbc_node_find_value(hnode, \"clear\", NULL))\n\t\tappend_printf(&buf, end, \":clear\");\n\n\t \n\tnode = xbc_node_find_subkey(hnode, \"onmax\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onchange\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"var\") < 0)\n\t\treturn -EINVAL;\n\tnode = xbc_node_find_subkey(hnode, \"onmatch\");\n\tif (node && trace_boot_hist_add_handlers(node, &buf, end, \"event\") < 0)\n\t\treturn -EINVAL;\n\n\tp = xbc_node_find_value(hnode, \"filter\", NULL);\n\tif (p)\n\t\tappend_printf(&buf, end, \" if %s\", p);\n\n\tif (buf == end) {\n\t\tpr_err(\"hist exceeds the max command length.\\n\");\n\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}\n\nstatic void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\tstruct xbc_node *node;\n\tconst char *p;\n\tchar *tmp;\n\n\txbc_node_for_each_subkey(hnode, node) {\n\t\tp = xbc_node_get_data(node);\n\t\tif (!isdigit(p[0]))\n\t\t\tcontinue;\n\t\t \n\t\tif (trace_boot_compose_hist_cmd(node, buf, size) == 0) {\n\t\t\ttmp = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\treturn;\n\t\t\tif (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n\n\tif (xbc_node_find_subkey(hnode, \"keys\")) {\n\t\tif (trace_boot_compose_hist_cmd(hnode, buf, size) == 0) {\n\t\t\ttmp = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\treturn;\n\t\t\tif (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply hist trigger: %s\\n\", tmp);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n}\n#else\nstatic void __init\ntrace_boot_init_histograms(struct trace_event_file *file,\n\t\t\t   struct xbc_node *hnode, char *buf, size_t size)\n{\n\t \n}\n#endif\n\nstatic void __init\ntrace_boot_init_one_event(struct trace_array *tr, struct xbc_node *gnode,\n\t\t\t  struct xbc_node *enode)\n{\n\tstruct trace_event_file *file;\n\tstruct xbc_node *anode;\n\tchar buf[MAX_BUF_LEN];\n\tconst char *p, *group, *event;\n\n\tgroup = xbc_node_get_data(gnode);\n\tevent = xbc_node_get_data(enode);\n\n\tif (!strcmp(group, \"kprobes\"))\n\t\tif (trace_boot_add_kprobe_event(enode, event) < 0)\n\t\t\treturn;\n\tif (!strcmp(group, \"synthetic\"))\n\t\tif (trace_boot_add_synth_event(enode, event) < 0)\n\t\t\treturn;\n\n\tmutex_lock(&event_mutex);\n\tfile = find_event_file(tr, group, event);\n\tif (!file) {\n\t\tpr_err(\"Failed to find event: %s:%s\\n\", group, event);\n\t\tgoto out;\n\t}\n\n\tp = xbc_node_find_value(enode, \"filter\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0)\n\t\t\tpr_err(\"filter string is too long: %s\\n\", p);\n\t\telse if (apply_event_filter(file, buf) < 0)\n\t\t\tpr_err(\"Failed to apply filter: %s\\n\", buf);\n\t}\n\n\tif (IS_ENABLED(CONFIG_HIST_TRIGGERS)) {\n\t\txbc_node_for_each_array_value(enode, \"actions\", anode, p) {\n\t\t\tif (strscpy(buf, p, ARRAY_SIZE(buf)) < 0)\n\t\t\t\tpr_err(\"action string is too long: %s\\n\", p);\n\t\t\telse if (trigger_process_regex(file, buf) < 0)\n\t\t\t\tpr_err(\"Failed to apply an action: %s\\n\", p);\n\t\t}\n\t\tanode = xbc_node_find_subkey(enode, \"hist\");\n\t\tif (anode)\n\t\t\ttrace_boot_init_histograms(file, anode, buf, ARRAY_SIZE(buf));\n\t} else if (xbc_node_find_value(enode, \"actions\", NULL))\n\t\tpr_err(\"Failed to apply event actions because CONFIG_HIST_TRIGGERS is not set.\\n\");\n\n\tif (xbc_node_find_value(enode, \"enable\", NULL)) {\n\t\tif (trace_event_enable_disable(file, 1, 0) < 0)\n\t\t\tpr_err(\"Failed to enable event node: %s:%s\\n\",\n\t\t\t\tgroup, event);\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n}\n\nstatic void __init\ntrace_boot_init_events(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *gnode, *enode;\n\tbool enable, enable_all = false;\n\tconst char *data;\n\n\tnode = xbc_node_find_subkey(node, \"event\");\n\tif (!node)\n\t\treturn;\n\t \n\txbc_node_for_each_subkey(node, gnode) {\n\t\tdata = xbc_node_get_data(gnode);\n\t\tif (!strcmp(data, \"enable\")) {\n\t\t\tenable_all = true;\n\t\t\tcontinue;\n\t\t}\n\t\tenable = false;\n\t\txbc_node_for_each_subkey(gnode, enode) {\n\t\t\tdata = xbc_node_get_data(enode);\n\t\t\tif (!strcmp(data, \"enable\")) {\n\t\t\t\tenable = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrace_boot_init_one_event(tr, gnode, enode);\n\t\t}\n\t\t \n\t\tif (enable) {\n\t\t\tdata = xbc_node_get_data(gnode);\n\t\t\ttrace_array_set_clr_event(tr, data, NULL, true);\n\t\t}\n\t}\n\t \n\tif (enable_all)\n\t\ttrace_array_set_clr_event(tr, NULL, NULL, true);\n}\n#else\n#define trace_boot_enable_events(tr, node) do {} while (0)\n#define trace_boot_init_events(tr, node) do {} while (0)\n#endif\n\n#ifdef CONFIG_DYNAMIC_FTRACE\nstatic void __init\ntrace_boot_set_ftrace_filter(struct trace_array *tr, struct xbc_node *node)\n{\n\tstruct xbc_node *anode;\n\tconst char *p;\n\tchar *q;\n\n\txbc_node_for_each_array_value(node, \"ftrace.filters\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_filter(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n\txbc_node_for_each_array_value(node, \"ftrace.notraces\", anode, p) {\n\t\tq = kstrdup(p, GFP_KERNEL);\n\t\tif (!q)\n\t\t\treturn;\n\t\tif (ftrace_set_notrace(tr->ops, q, strlen(q), 0) < 0)\n\t\t\tpr_err(\"Failed to add %s to ftrace filter\\n\", p);\n\t\telse\n\t\t\tftrace_filter_param = true;\n\t\tkfree(q);\n\t}\n}\n#else\n#define trace_boot_set_ftrace_filter(tr, node) do {} while (0)\n#endif\n\nstatic void __init\ntrace_boot_enable_tracer(struct trace_array *tr, struct xbc_node *node)\n{\n\tconst char *p;\n\n\ttrace_boot_set_ftrace_filter(tr, node);\n\n\tp = xbc_node_find_value(node, \"tracer\", NULL);\n\tif (p && *p != '\\0') {\n\t\tif (tracing_set_tracer(tr, p) < 0)\n\t\t\tpr_err(\"Failed to set given tracer: %s\\n\", p);\n\t}\n\n\t \n\tif (xbc_node_find_value(node, \"alloc_snapshot\", NULL)) {\n\t\tif (tracing_alloc_snapshot_instance(tr) < 0)\n\t\t\tpr_err(\"Failed to allocate snapshot buffer\\n\");\n\t}\n}\n\nstatic void __init\ntrace_boot_init_one_instance(struct trace_array *tr, struct xbc_node *node)\n{\n\ttrace_boot_set_instance_options(tr, node);\n\ttrace_boot_init_events(tr, node);\n\ttrace_boot_enable_events(tr, node);\n\ttrace_boot_enable_tracer(tr, node);\n}\n\nstatic void __init\ntrace_boot_init_instances(struct xbc_node *node)\n{\n\tstruct xbc_node *inode;\n\tstruct trace_array *tr;\n\tconst char *p;\n\n\tnode = xbc_node_find_subkey(node, \"instance\");\n\tif (!node)\n\t\treturn;\n\n\txbc_node_for_each_subkey(node, inode) {\n\t\tp = xbc_node_get_data(inode);\n\t\tif (!p || *p == '\\0')\n\t\t\tcontinue;\n\n\t\ttr = trace_array_get_by_name(p);\n\t\tif (!tr) {\n\t\t\tpr_err(\"Failed to get trace instance %s\\n\", p);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_boot_init_one_instance(tr, inode);\n\t\ttrace_array_put(tr);\n\t}\n}\n\nstatic int __init trace_boot_init(void)\n{\n\tstruct xbc_node *trace_node;\n\tstruct trace_array *tr;\n\n\ttrace_node = xbc_find_node(\"ftrace\");\n\tif (!trace_node)\n\t\treturn 0;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn 0;\n\n\t \n\ttrace_boot_init_one_instance(tr, trace_node);\n\ttrace_boot_init_instances(trace_node);\n\n\tdisable_tracing_selftest(\"running boot-time tracing\");\n\n\treturn 0;\n}\n \ncore_initcall_sync(trace_boot_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}