{
  "module_name": "trace_kdb.c",
  "hash_id": "5d873669d7a0a7b34f07799e241adeef3482623cb6b798ecaa4ec6ee53979631",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_kdb.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/ftrace.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\nstatic struct trace_iterator iter;\nstatic struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];\n\nstatic void ftrace_dump_buf(int skip_entries, long cpu_file)\n{\n\tstruct trace_array *tr;\n\tunsigned int old_userobj;\n\tint cnt = 0, cpu;\n\n\ttr = iter.tr;\n\n\told_userobj = tr->trace_flags;\n\n\t \n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tkdb_printf(\"Dumping ftrace buffer:\\n\");\n\tif (skip_entries)\n\t\tkdb_printf(\"(skipping %d entries)\\n\", skip_entries);\n\n\ttrace_iterator_reset(&iter);\n\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\tif (cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer.buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu, GFP_ATOMIC);\n\t\t\tring_buffer_read_start(iter.buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(&iter, cpu);\n\t\t}\n\t} else {\n\t\titer.cpu_file = cpu_file;\n\t\titer.buffer_iter[cpu_file] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu_file, GFP_ATOMIC);\n\t\tring_buffer_read_start(iter.buffer_iter[cpu_file]);\n\t\ttracing_iter_reset(&iter, cpu_file);\n\t}\n\n\twhile (trace_find_next_entry_inc(&iter)) {\n\t\tif (!cnt)\n\t\t\tkdb_printf(\"---------------------------------\\n\");\n\t\tcnt++;\n\n\t\tif (!skip_entries) {\n\t\t\tprint_trace_line(&iter);\n\t\t\ttrace_printk_seq(&iter.seq);\n\t\t} else {\n\t\t\tskip_entries--;\n\t\t}\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\tgoto out;\n\t}\n\n\tif (!cnt)\n\t\tkdb_printf(\"   (ftrace buffer empty)\\n\");\n\telse\n\t\tkdb_printf(\"---------------------------------\\n\");\n\nout:\n\ttr->trace_flags = old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter.buffer_iter[cpu]) {\n\t\t\tring_buffer_read_finish(iter.buffer_iter[cpu]);\n\t\t\titer.buffer_iter[cpu] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int kdb_ftdump(int argc, const char **argv)\n{\n\tint skip_entries = 0;\n\tlong cpu_file;\n\tchar *cp;\n\tint cnt;\n\tint cpu;\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tskip_entries = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tskip_entries = 0;\n\t}\n\n\tif (argc == 2) {\n\t\tcpu_file = simple_strtol(argv[2], &cp, 0);\n\t\tif (*cp || cpu_file >= NR_CPUS || cpu_file < 0 ||\n\t\t    !cpu_online(cpu_file))\n\t\t\treturn KDB_BADINT;\n\t} else {\n\t\tcpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tkdb_trap_printk++;\n\n\ttrace_init_global_iter(&iter);\n\titer.buffer_iter = buffer_iter;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\t \n\tif (skip_entries < 0) {\n\t\tif (cpu_file == RING_BUFFER_ALL_CPUS)\n\t\t\tcnt = trace_total_entries(NULL);\n\t\telse\n\t\t\tcnt = trace_total_entries_cpu(NULL, cpu_file);\n\t\tskip_entries = max(cnt + skip_entries, 0);\n\t}\n\n\tftrace_dump_buf(skip_entries, cpu_file);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\tkdb_trap_printk--;\n\n\treturn 0;\n}\n\nstatic kdbtab_t ftdump_cmd = {\n\t.name = \"ftdump\",\n\t.func = kdb_ftdump,\n\t.usage = \"[skip_#entries] [cpu]\",\n\t.help = \"Dump ftrace log; -skip dumps last #entries\",\n\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n};\n\nstatic __init int kdb_ftrace_register(void)\n{\n\tkdb_register(&ftdump_cmd);\n\treturn 0;\n}\n\nlate_initcall(kdb_ftrace_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}