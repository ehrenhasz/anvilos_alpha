{
  "module_name": "trace_branch.c",
  "hash_id": "f1f6e31b2e3448497b904a68b494f57c51c84e0ec0eb4100eac666f5f62bbc7f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_branch.c",
  "human_readable_source": "\n \n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/irqflags.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <asm/local.h>\n\n#include \"trace.h\"\n#include \"trace_stat.h\"\n#include \"trace_output.h\"\n\n#ifdef CONFIG_BRANCH_TRACER\n\nstatic struct tracer branch_trace;\nstatic int branch_tracing_enabled __read_mostly;\nstatic DEFINE_MUTEX(branch_tracing_mutex);\n\nstatic struct trace_array *branch_tracer;\n\nstatic void\nprobe_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tstruct trace_event_call *call = &event_branch;\n\tstruct trace_array *tr = branch_tracer;\n\tstruct trace_buffer *buffer;\n\tstruct trace_array_cpu *data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_branch *entry;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tconst char *p;\n\n\tif (current->trace_recursion & TRACE_BRANCH_BIT)\n\t\treturn;\n\n\t \n\n\tif (unlikely(!tr))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tcurrent->trace_recursion |= TRACE_BRANCH_BIT;\n\tdata = this_cpu_ptr(tr->array_buffer.data);\n\tif (atomic_read(&data->disabled))\n\t\tgoto out;\n\n\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\tbuffer = tr->array_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_BRANCH,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\tgoto out;\n\n\tentry\t= ring_buffer_event_data(event);\n\n\t \n\tp = f->data.file + strlen(f->data.file);\n\twhile (p >= f->data.file && *p != '/')\n\t\tp--;\n\tp++;\n\n\tstrncpy(entry->func, f->data.func, TRACE_FUNC_SIZE);\n\tstrncpy(entry->file, p, TRACE_FILE_SIZE);\n\tentry->func[TRACE_FUNC_SIZE] = 0;\n\tentry->file[TRACE_FILE_SIZE] = 0;\n\tentry->constant = f->constant;\n\tentry->line = f->data.line;\n\tentry->correct = val == expect;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n out:\n\tcurrent->trace_recursion &= ~TRACE_BRANCH_BIT;\n\traw_local_irq_restore(flags);\n}\n\nstatic inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n\tif (!branch_tracing_enabled)\n\t\treturn;\n\n\tprobe_likely_condition(f, val, expect);\n}\n\nint enable_branch_tracing(struct trace_array *tr)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\tbranch_tracer = tr;\n\t \n\tsmp_wmb();\n\tbranch_tracing_enabled++;\n\tmutex_unlock(&branch_tracing_mutex);\n\n\treturn 0;\n}\n\nvoid disable_branch_tracing(void)\n{\n\tmutex_lock(&branch_tracing_mutex);\n\n\tif (!branch_tracing_enabled)\n\t\tgoto out_unlock;\n\n\tbranch_tracing_enabled--;\n\n out_unlock:\n\tmutex_unlock(&branch_tracing_mutex);\n}\n\nstatic int branch_trace_init(struct trace_array *tr)\n{\n\treturn enable_branch_tracing(tr);\n}\n\nstatic void branch_trace_reset(struct trace_array *tr)\n{\n\tdisable_branch_tracing();\n}\n\nstatic enum print_line_t trace_branch_print(struct trace_iterator *iter,\n\t\t\t\t\t    int flags, struct trace_event *event)\n{\n\tstruct trace_branch *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"[%s] %s:%s:%d\\n\",\n\t\t\t field->correct ? \"  ok  \" : \" MISS \",\n\t\t\t field->func,\n\t\t\t field->file,\n\t\t\t field->line);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic void branch_print_header(struct seq_file *s)\n{\n\tseq_puts(s, \"#           TASK-PID    CPU#    TIMESTAMP  CORRECT\"\n\t\t    \"  FUNC:FILE:LINE\\n\"\n\t\t    \"#              | |       |          |         |   \"\n\t\t    \"    |\\n\");\n}\n\nstatic struct trace_event_functions trace_branch_funcs = {\n\t.trace\t\t= trace_branch_print,\n};\n\nstatic struct trace_event trace_branch_event = {\n\t.type\t\t= TRACE_BRANCH,\n\t.funcs\t\t= &trace_branch_funcs,\n};\n\nstatic struct tracer branch_trace __read_mostly =\n{\n\t.name\t\t= \"branch\",\n\t.init\t\t= branch_trace_init,\n\t.reset\t\t= branch_trace_reset,\n#ifdef CONFIG_FTRACE_SELFTEST\n\t.selftest\t= trace_selftest_startup_branch,\n#endif  \n\t.print_header\t= branch_print_header,\n};\n\n__init static int init_branch_tracer(void)\n{\n\tint ret;\n\n\tret = register_trace_event(&trace_branch_event);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"branch events\\n\");\n\t\treturn 1;\n\t}\n\treturn register_tracer(&branch_trace);\n}\ncore_initcall(init_branch_tracer);\n\n#else\nstatic inline\nvoid trace_likely_condition(struct ftrace_likely_data *f, int val, int expect)\n{\n}\n#endif  \n\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant)\n{\n\tunsigned long flags = user_access_save();\n\n\t \n\tif (is_constant) {\n\t\tf->constant++;\n\t\tval = expect;\n\t}\n\t \n\ttrace_likely_condition(f, val, expect);\n\n\t \n\tif (val == expect)\n\t\tf->data.correct++;\n\telse\n\t\tf->data.incorrect++;\n\n\tuser_access_restore(flags);\n}\nEXPORT_SYMBOL(ftrace_likely_update);\n\nextern unsigned long __start_annotated_branch_profile[];\nextern unsigned long __stop_annotated_branch_profile[];\n\nstatic int annotated_branch_stat_headers(struct seq_file *m)\n{\n\tseq_puts(m, \" correct incorrect  % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\");\n\treturn 0;\n}\n\nstatic inline long get_incorrect_percent(const struct ftrace_branch_data *p)\n{\n\tlong percent;\n\n\tif (p->correct) {\n\t\tpercent = p->incorrect * 100;\n\t\tpercent /= p->correct + p->incorrect;\n\t} else\n\t\tpercent = p->incorrect ? 100 : -1;\n\n\treturn percent;\n}\n\nstatic const char *branch_stat_process_file(struct ftrace_branch_data *p)\n{\n\tconst char *f;\n\n\t \n\tf = p->file + strlen(p->file);\n\twhile (f >= p->file && *f != '/')\n\t\tf--;\n\treturn ++f;\n}\n\nstatic void branch_stat_show(struct seq_file *m,\n\t\t\t     struct ftrace_branch_data *p, const char *f)\n{\n\tlong percent;\n\n\t \n\tpercent = get_incorrect_percent(p);\n\n\tif (percent < 0)\n\t\tseq_puts(m, \"  X \");\n\telse\n\t\tseq_printf(m, \"%3ld \", percent);\n\n\tseq_printf(m, \"%-30.30s %-20.20s %d\\n\", p->func, f, p->line);\n}\n\nstatic int branch_stat_show_normal(struct seq_file *m,\n\t\t\t\t   struct ftrace_branch_data *p, const char *f)\n{\n\tseq_printf(m, \"%8lu %8lu \",  p->correct, p->incorrect);\n\tbranch_stat_show(m, p, f);\n\treturn 0;\n}\n\nstatic int annotate_branch_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_likely_data *p = v;\n\tconst char *f;\n\tint l;\n\n\tf = branch_stat_process_file(&p->data);\n\n\tif (!p->constant)\n\t\treturn branch_stat_show_normal(m, &p->data, f);\n\n\tl = snprintf(NULL, 0, \"/%lu\", p->constant);\n\tl = l > 8 ? 0 : 8 - l;\n\n\tseq_printf(m, \"%8lu/%lu %*lu \",\n\t\t   p->data.correct, p->constant, l, p->data.incorrect);\n\tbranch_stat_show(m, &p->data, f);\n\treturn 0;\n}\n\nstatic void *annotated_branch_stat_start(struct tracer_stat *trace)\n{\n\treturn __start_annotated_branch_profile;\n}\n\nstatic void *\nannotated_branch_stat_next(void *v, int idx)\n{\n\tstruct ftrace_likely_data *p = v;\n\n\t++p;\n\n\tif ((void *)p >= (void *)__stop_annotated_branch_profile)\n\t\treturn NULL;\n\n\treturn p;\n}\n\nstatic int annotated_branch_stat_cmp(const void *p1, const void *p2)\n{\n\tconst struct ftrace_branch_data *a = p1;\n\tconst struct ftrace_branch_data *b = p2;\n\n\tlong percent_a, percent_b;\n\n\tpercent_a = get_incorrect_percent(a);\n\tpercent_b = get_incorrect_percent(b);\n\n\tif (percent_a < percent_b)\n\t\treturn -1;\n\tif (percent_a > percent_b)\n\t\treturn 1;\n\n\tif (a->incorrect < b->incorrect)\n\t\treturn -1;\n\tif (a->incorrect > b->incorrect)\n\t\treturn 1;\n\n\t \n\tif (a->correct > b->correct)\n\t\treturn -1;\n\tif (a->correct < b->correct)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct tracer_stat annotated_branch_stats = {\n\t.name = \"branch_annotated\",\n\t.stat_start = annotated_branch_stat_start,\n\t.stat_next = annotated_branch_stat_next,\n\t.stat_cmp = annotated_branch_stat_cmp,\n\t.stat_headers = annotated_branch_stat_headers,\n\t.stat_show = annotate_branch_stat_show\n};\n\n__init static int init_annotated_branch_stats(void)\n{\n\tint ret;\n\n\tret = register_stat_tracer(&annotated_branch_stats);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"annotated branches stats\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nfs_initcall(init_annotated_branch_stats);\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n\nextern unsigned long __start_branch_profile[];\nextern unsigned long __stop_branch_profile[];\n\nstatic int all_branch_stat_headers(struct seq_file *m)\n{\n\tseq_puts(m, \"   miss      hit    % \"\n\t\t    \"       Function                \"\n\t\t    \"  File              Line\\n\"\n\t\t    \" ------- ---------  - \"\n\t\t    \"       --------                \"\n\t\t    \"  ----              ----\\n\");\n\treturn 0;\n}\n\nstatic void *all_branch_stat_start(struct tracer_stat *trace)\n{\n\treturn __start_branch_profile;\n}\n\nstatic void *\nall_branch_stat_next(void *v, int idx)\n{\n\tstruct ftrace_branch_data *p = v;\n\n\t++p;\n\n\tif ((void *)p >= (void *)__stop_branch_profile)\n\t\treturn NULL;\n\n\treturn p;\n}\n\nstatic int all_branch_stat_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_branch_data *p = v;\n\tconst char *f;\n\n\tf = branch_stat_process_file(p);\n\treturn branch_stat_show_normal(m, p, f);\n}\n\nstatic struct tracer_stat all_branch_stats = {\n\t.name = \"branch_all\",\n\t.stat_start = all_branch_stat_start,\n\t.stat_next = all_branch_stat_next,\n\t.stat_headers = all_branch_stat_headers,\n\t.stat_show = all_branch_stat_show\n};\n\n__init static int all_annotated_branch_stats(void)\n{\n\tint ret;\n\n\tret = register_stat_tracer(&all_branch_stats);\n\tif (!ret) {\n\t\tprintk(KERN_WARNING \"Warning: could not register \"\n\t\t\t\t    \"all branches stats\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nfs_initcall(all_annotated_branch_stats);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}