{
  "module_name": "trace_fprobe.c",
  "hash_id": "f59c566fc91bdbb00ee476f6eb7d62506a414ee83f74eced66ba789469056bc9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_fprobe.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)\t\"trace_fprobe: \" fmt\n\n#include <linux/fprobe.h>\n#include <linux/module.h>\n#include <linux/rculist.h>\n#include <linux/security.h>\n#include <linux/tracepoint.h>\n#include <linux/uaccess.h>\n\n#include \"trace_dynevent.h\"\n#include \"trace_probe.h\"\n#include \"trace_probe_kernel.h\"\n#include \"trace_probe_tmpl.h\"\n\n#define FPROBE_EVENT_SYSTEM \"fprobes\"\n#define TRACEPOINT_EVENT_SYSTEM \"tracepoints\"\n#define RETHOOK_MAXACTIVE_MAX 4096\n\nstatic int trace_fprobe_create(const char *raw_command);\nstatic int trace_fprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_fprobe_release(struct dyn_event *ev);\nstatic bool trace_fprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_fprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct dyn_event_operations trace_fprobe_ops = {\n\t.create = trace_fprobe_create,\n\t.show = trace_fprobe_show,\n\t.is_busy = trace_fprobe_is_busy,\n\t.free = trace_fprobe_release,\n\t.match = trace_fprobe_match,\n};\n\n \nstruct trace_fprobe {\n\tstruct dyn_event\tdevent;\n\tstruct fprobe\t\tfp;\n\tconst char\t\t*symbol;\n\tstruct tracepoint\t*tpoint;\n\tstruct module\t\t*mod;\n\tstruct trace_probe\ttp;\n};\n\nstatic bool is_trace_fprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_fprobe_ops;\n}\n\nstatic struct trace_fprobe *to_trace_fprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_fprobe, devent);\n}\n\n \n#define for_each_trace_fprobe(pos, dpos)\t\\\n\tfor_each_dyn_event(dpos)\t\t\\\n\t\tif (is_trace_fprobe(dpos) && (pos = to_trace_fprobe(dpos)))\n\nstatic bool trace_fprobe_is_return(struct trace_fprobe *tf)\n{\n\treturn tf->fp.exit_handler != NULL;\n}\n\nstatic bool trace_fprobe_is_tracepoint(struct trace_fprobe *tf)\n{\n\treturn tf->tpoint != NULL;\n}\n\nstatic const char *trace_fprobe_symbol(struct trace_fprobe *tf)\n{\n\treturn tf->symbol ? tf->symbol : \"unknown\";\n}\n\nstatic bool trace_fprobe_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_fprobe *tf = to_trace_fprobe(ev);\n\n\treturn trace_probe_is_enabled(&tf->tp);\n}\n\nstatic bool trace_fprobe_match_command_head(struct trace_fprobe *tf,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\n\tif (!argc)\n\t\treturn true;\n\n\tsnprintf(buf, sizeof(buf), \"%s\", trace_fprobe_symbol(tf));\n\tif (strcmp(buf, argv[0]))\n\t\treturn false;\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tf->tp, argc, argv);\n}\n\nstatic bool trace_fprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_fprobe *tf = to_trace_fprobe(ev);\n\n\tif (event[0] != '\\0' && strcmp(trace_probe_name(&tf->tp), event))\n\t\treturn false;\n\n\tif (system && strcmp(trace_probe_group_name(&tf->tp), system))\n\t\treturn false;\n\n\treturn trace_fprobe_match_command_head(tf, argc, argv);\n}\n\nstatic bool trace_fprobe_is_registered(struct trace_fprobe *tf)\n{\n\treturn fprobe_is_registered(&tf->fp);\n}\n\n \nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tstruct pt_regs *regs = rec;\n\tunsigned long val;\n\tint ret;\n\nretry:\n\t \n\tswitch (code->op) {\n\tcase FETCH_OP_STACK:\n\t\tval = regs_get_kernel_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\tcase FETCH_OP_ARG:\n\t\tval = regs_get_kernel_argument(regs, code->param);\n\t\tbreak;\n#endif\n\tcase FETCH_NOP_SYMBOL:\t \n\t\tcode++;\n\t\tgoto retry;\n\tdefault:\n\t\tret = process_common_fetch_insn(code, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n \nstatic nokprobe_inline void\n__fentry_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,\n\t\t    struct pt_regs *regs,\n\t\t    struct trace_event_file *trace_file)\n{\n\tstruct fentry_trace_entry_head *entry;\n\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);\n\tstruct trace_event_buffer fbuffer;\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != trace_file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tf->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tf->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->ip = entry_ip;\n\tstore_trace_args(&entry[1], &tf->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}\n\nstatic void\nfentry_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,\n\t\t  struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tf->tp)\n\t\t__fentry_trace_func(tf, entry_ip, regs, link->file);\n}\nNOKPROBE_SYMBOL(fentry_trace_func);\n\n \nstatic nokprobe_inline void\n__fexit_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,\n\t\t   unsigned long ret_ip, struct pt_regs *regs,\n\t\t   struct trace_event_file *trace_file)\n{\n\tstruct fexit_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);\n\tint dsize;\n\n\tif (WARN_ON_ONCE(call != trace_file->event_call))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tdsize = __get_data_size(&tf->tp, regs);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + tf->tp.size + dsize);\n\tif (!entry)\n\t\treturn;\n\n\tfbuffer.regs = regs;\n\tentry = fbuffer.entry = ring_buffer_event_data(fbuffer.event);\n\tentry->func = entry_ip;\n\tentry->ret_ip = ret_ip;\n\tstore_trace_args(&entry[1], &tf->tp, regs, sizeof(*entry), dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}\n\nstatic void\nfexit_trace_func(struct trace_fprobe *tf, unsigned long entry_ip,\n\t\t unsigned long ret_ip, struct pt_regs *regs)\n{\n\tstruct event_file_link *link;\n\n\ttrace_probe_for_each_link_rcu(link, &tf->tp)\n\t\t__fexit_trace_func(tf, entry_ip, ret_ip, regs, link->file);\n}\nNOKPROBE_SYMBOL(fexit_trace_func);\n\n#ifdef CONFIG_PERF_EVENTS\n\nstatic int fentry_perf_func(struct trace_fprobe *tf, unsigned long entry_ip,\n\t\t\t    struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);\n\tstruct fentry_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tf->tp, regs);\n\t__size = sizeof(*entry) + tf->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn 0;\n\n\tentry->ip = entry_ip;\n\tmemset(&entry[1], 0, dsize);\n\tstore_trace_args(&entry[1], &tf->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n\treturn 0;\n}\nNOKPROBE_SYMBOL(fentry_perf_func);\n\nstatic void\nfexit_perf_func(struct trace_fprobe *tf, unsigned long entry_ip,\n\t\tunsigned long ret_ip, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);\n\tstruct fexit_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tint size, __size, dsize;\n\tint rctx;\n\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tdsize = __get_data_size(&tf->tp, regs);\n\t__size = sizeof(*entry) + tf->tp.size + dsize;\n\tsize = ALIGN(__size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->func = entry_ip;\n\tentry->ret_ip = ret_ip;\n\tstore_trace_args(&entry[1], &tf->tp, regs, sizeof(*entry), dsize);\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n}\nNOKPROBE_SYMBOL(fexit_perf_func);\n#endif\t \n\nstatic int fentry_dispatcher(struct fprobe *fp, unsigned long entry_ip,\n\t\t\t     unsigned long ret_ip, struct pt_regs *regs,\n\t\t\t     void *entry_data)\n{\n\tstruct trace_fprobe *tf = container_of(fp, struct trace_fprobe, fp);\n\tint ret = 0;\n\n\tif (trace_probe_test_flag(&tf->tp, TP_FLAG_TRACE))\n\t\tfentry_trace_func(tf, entry_ip, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tf->tp, TP_FLAG_PROFILE))\n\t\tret = fentry_perf_func(tf, entry_ip, regs);\n#endif\n\treturn ret;\n}\nNOKPROBE_SYMBOL(fentry_dispatcher);\n\nstatic void fexit_dispatcher(struct fprobe *fp, unsigned long entry_ip,\n\t\t\t     unsigned long ret_ip, struct pt_regs *regs,\n\t\t\t     void *entry_data)\n{\n\tstruct trace_fprobe *tf = container_of(fp, struct trace_fprobe, fp);\n\n\tif (trace_probe_test_flag(&tf->tp, TP_FLAG_TRACE))\n\t\tfexit_trace_func(tf, entry_ip, ret_ip, regs);\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tf->tp, TP_FLAG_PROFILE))\n\t\tfexit_perf_func(tf, entry_ip, ret_ip, regs);\n#endif\n}\nNOKPROBE_SYMBOL(fexit_dispatcher);\n\nstatic void free_trace_fprobe(struct trace_fprobe *tf)\n{\n\tif (tf) {\n\t\ttrace_probe_cleanup(&tf->tp);\n\t\tkfree(tf->symbol);\n\t\tkfree(tf);\n\t}\n}\n\n \nstatic struct trace_fprobe *alloc_trace_fprobe(const char *group,\n\t\t\t\t\t       const char *event,\n\t\t\t\t\t       const char *symbol,\n\t\t\t\t\t       struct tracepoint *tpoint,\n\t\t\t\t\t       int maxactive,\n\t\t\t\t\t       int nargs, bool is_return)\n{\n\tstruct trace_fprobe *tf;\n\tint ret = -ENOMEM;\n\n\ttf = kzalloc(struct_size(tf, tp.args, nargs), GFP_KERNEL);\n\tif (!tf)\n\t\treturn ERR_PTR(ret);\n\n\ttf->symbol = kstrdup(symbol, GFP_KERNEL);\n\tif (!tf->symbol)\n\t\tgoto error;\n\n\tif (is_return)\n\t\ttf->fp.exit_handler = fexit_dispatcher;\n\telse\n\t\ttf->fp.entry_handler = fentry_dispatcher;\n\n\ttf->tpoint = tpoint;\n\ttf->fp.nr_maxactive = maxactive;\n\n\tret = trace_probe_init(&tf->tp, event, group, false);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tf->devent, &trace_fprobe_ops);\n\treturn tf;\nerror:\n\tfree_trace_fprobe(tf);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct trace_fprobe *find_trace_fprobe(const char *event,\n\t\t\t\t\t      const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_fprobe *tf;\n\n\tfor_each_trace_fprobe(tf, pos)\n\t\tif (strcmp(trace_probe_name(&tf->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tf->tp), group) == 0)\n\t\t\treturn tf;\n\treturn NULL;\n}\n\nstatic inline int __enable_trace_fprobe(struct trace_fprobe *tf)\n{\n\tif (trace_fprobe_is_registered(tf))\n\t\tenable_fprobe(&tf->fp);\n\n\treturn 0;\n}\n\nstatic void __disable_trace_fprobe(struct trace_probe *tp)\n{\n\tstruct trace_fprobe *tf;\n\n\tlist_for_each_entry(tf, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!trace_fprobe_is_registered(tf))\n\t\t\tcontinue;\n\t\tdisable_fprobe(&tf->fp);\n\t}\n}\n\n \nstatic int enable_trace_fprobe(struct trace_event_call *call,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_fprobe *tf;\n\tbool enabled;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t \n\tif (file) {\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!enabled) {\n\t\tlist_for_each_entry(tf, trace_probe_probe_list(tp), tp.list) {\n\t\t\t \n\t\t\t__enable_trace_fprobe(tf);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int disable_trace_fprobe(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\tif (file) {\n\t\tif (!trace_probe_get_file_link(tp, file))\n\t\t\treturn -ENOENT;\n\t\tif (!trace_probe_has_single_file(tp))\n\t\t\tgoto out;\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_TRACE);\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\tif (!trace_probe_is_enabled(tp))\n\t\t__disable_trace_fprobe(tp);\n\n out:\n\tif (file)\n\t\t \n\t\ttrace_probe_remove_file(tp, file);\n\n\treturn 0;\n}\n\n \nstatic enum print_line_t\nprint_fentry_event(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct fentry_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct fentry_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tif (!seq_print_ip_sym(s, field->ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (trace_probe_print_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n out:\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t\nprint_fexit_event(struct trace_iterator *iter, int flags,\n\t\t  struct trace_event *event)\n{\n\tstruct fexit_trace_entry_head *field;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_probe *tp;\n\n\tfield = (struct fexit_trace_entry_head *)iter->ent;\n\ttp = trace_probe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (WARN_ON_ONCE(!tp))\n\t\tgoto out;\n\n\ttrace_seq_printf(s, \"%s: (\", trace_probe_name(tp));\n\n\tif (!seq_print_ip_sym(s, field->ret_ip, flags | TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_puts(s, \" <- \");\n\n\tif (!seq_print_ip_sym(s, field->func, flags & ~TRACE_ITER_SYM_OFFSET))\n\t\tgoto out;\n\n\ttrace_seq_putc(s, ')');\n\n\tif (trace_probe_print_args(s, tp->args, tp->nr_args,\n\t\t\t     (u8 *)&field[1], field) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}\n\nstatic int fentry_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct fentry_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned long, ip, FIELD_STRING_IP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}\n\nstatic int fexit_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret;\n\tstruct fexit_trace_entry_head field;\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(event_call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENOENT;\n\n\tDEFINE_FIELD(unsigned long, func, FIELD_STRING_FUNC, 0);\n\tDEFINE_FIELD(unsigned long, ret_ip, FIELD_STRING_RETIP, 0);\n\n\treturn traceprobe_define_arg_fields(event_call, sizeof(field), tp);\n}\n\nstatic struct trace_event_functions fentry_funcs = {\n\t.trace\t\t= print_fentry_event\n};\n\nstatic struct trace_event_functions fexit_funcs = {\n\t.trace\t\t= print_fexit_event\n};\n\nstatic struct trace_event_fields fentry_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = fentry_event_define_fields },\n\t{}\n};\n\nstatic struct trace_event_fields fexit_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = fexit_event_define_fields },\n\t{}\n};\n\nstatic int fprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data);\n\nstatic inline void init_trace_event_call(struct trace_fprobe *tf)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tf->tp);\n\n\tif (trace_fprobe_is_return(tf)) {\n\t\tcall->event.funcs = &fexit_funcs;\n\t\tcall->class->fields_array = fexit_fields_array;\n\t} else {\n\t\tcall->event.funcs = &fentry_funcs;\n\t\tcall->class->fields_array = fentry_fields_array;\n\t}\n\n\tcall->flags = TRACE_EVENT_FL_FPROBE;\n\tcall->class->reg = fprobe_register;\n}\n\nstatic int register_fprobe_event(struct trace_fprobe *tf)\n{\n\tinit_trace_event_call(tf);\n\n\treturn trace_probe_register_event_call(&tf->tp);\n}\n\nstatic int unregister_fprobe_event(struct trace_fprobe *tf)\n{\n\treturn trace_probe_unregister_event_call(&tf->tp);\n}\n\n \nstatic int __register_trace_fprobe(struct trace_fprobe *tf)\n{\n\tint i, ret;\n\n\t \n\tret = security_locked_down(LOCKDOWN_KPROBES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trace_fprobe_is_registered(tf))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < tf->tp.nr_args; i++) {\n\t\tret = traceprobe_update_arg(&tf->tp.args[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (trace_probe_is_enabled(&tf->tp))\n\t\ttf->fp.flags &= ~FPROBE_FL_DISABLED;\n\telse\n\t\ttf->fp.flags |= FPROBE_FL_DISABLED;\n\n\tif (trace_fprobe_is_tracepoint(tf)) {\n\t\tstruct tracepoint *tpoint = tf->tpoint;\n\t\tunsigned long ip = (unsigned long)tpoint->probestub;\n\t\t \n\t\tret = tracepoint_probe_register_prio_may_exist(tpoint,\n\t\t\t\t\ttpoint->probestub, NULL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn register_fprobe_ips(&tf->fp, &ip, 1);\n\t}\n\n\t \n\treturn register_fprobe(&tf->fp, tf->symbol, NULL);\n}\n\n \nstatic void __unregister_trace_fprobe(struct trace_fprobe *tf)\n{\n\tif (trace_fprobe_is_registered(tf)) {\n\t\tunregister_fprobe(&tf->fp);\n\t\tmemset(&tf->fp, 0, sizeof(tf->fp));\n\t\tif (trace_fprobe_is_tracepoint(tf)) {\n\t\t\ttracepoint_probe_unregister(tf->tpoint,\n\t\t\t\t\ttf->tpoint->probestub, NULL);\n\t\t\ttf->tpoint = NULL;\n\t\t\ttf->mod = NULL;\n\t\t}\n\t}\n}\n\n \n \nstatic int unregister_trace_fprobe(struct trace_fprobe *tf)\n{\n\t \n\tif (trace_probe_has_sibling(&tf->tp))\n\t\tgoto unreg;\n\n\t \n\tif (trace_probe_is_enabled(&tf->tp))\n\t\treturn -EBUSY;\n\n\t \n\tif (trace_event_dyn_busy(trace_probe_event_call(&tf->tp)))\n\t\treturn -EBUSY;\n\n\t \n\tif (unregister_fprobe_event(tf))\n\t\treturn -EBUSY;\n\nunreg:\n\t__unregister_trace_fprobe(tf);\n\tdyn_event_remove(&tf->devent);\n\ttrace_probe_unlink(&tf->tp);\n\n\treturn 0;\n}\n\nstatic bool trace_fprobe_has_same_fprobe(struct trace_fprobe *orig,\n\t\t\t\t\t struct trace_fprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (strcmp(trace_fprobe_symbol(orig),\n\t\t\t   trace_fprobe_symbol(comp)))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int append_trace_fprobe(struct trace_fprobe *tf, struct trace_fprobe *to)\n{\n\tint ret;\n\n\tif (trace_fprobe_is_return(tf) != trace_fprobe_is_return(to) ||\n\t    trace_fprobe_is_tracepoint(tf) != trace_fprobe_is_tracepoint(to)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tret = trace_probe_compare_arg_type(&tf->tp, &to->tp);\n\tif (ret) {\n\t\t \n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_fprobe_has_same_fprobe(to, tf)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tret = trace_probe_append(&tf->tp, &to->tp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __register_trace_fprobe(tf);\n\tif (ret)\n\t\ttrace_probe_unlink(&tf->tp);\n\telse\n\t\tdyn_event_add(&tf->devent, trace_probe_event_call(&tf->tp));\n\n\treturn ret;\n}\n\n \nstatic int register_trace_fprobe(struct trace_fprobe *tf)\n{\n\tstruct trace_fprobe *old_tf;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\told_tf = find_trace_fprobe(trace_probe_name(&tf->tp),\n\t\t\t\t   trace_probe_group_name(&tf->tp));\n\tif (old_tf) {\n\t\tret = append_trace_fprobe(tf, old_tf);\n\t\tgoto end;\n\t}\n\n\t \n\tret = register_fprobe_event(tf);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t \n\tret = __register_trace_fprobe(tf);\n\tif (ret < 0)\n\t\tunregister_fprobe_event(tf);\n\telse\n\t\tdyn_event_add(&tf->devent, trace_probe_event_call(&tf->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}\n\n#ifdef CONFIG_MODULES\nstatic int __tracepoint_probe_module_cb(struct notifier_block *self,\n\t\t\t\t\tunsigned long val, void *data)\n{\n\tstruct tp_module *tp_mod = data;\n\tstruct trace_fprobe *tf;\n\tstruct dyn_event *pos;\n\n\tif (val != MODULE_STATE_GOING)\n\t\treturn NOTIFY_DONE;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_trace_fprobe(tf, pos) {\n\t\tif (tp_mod->mod == tf->mod) {\n\t\t\ttracepoint_probe_unregister(tf->tpoint,\n\t\t\t\t\ttf->tpoint->probestub, NULL);\n\t\t\ttf->tpoint = NULL;\n\t\t\ttf->mod = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block tracepoint_module_nb = {\n\t.notifier_call = __tracepoint_probe_module_cb,\n};\n#endif  \n\nstruct __find_tracepoint_cb_data {\n\tconst char *tp_name;\n\tstruct tracepoint *tpoint;\n};\n\nstatic void __find_tracepoint_cb(struct tracepoint *tp, void *priv)\n{\n\tstruct __find_tracepoint_cb_data *data = priv;\n\n\tif (!data->tpoint && !strcmp(data->tp_name, tp->name))\n\t\tdata->tpoint = tp;\n}\n\nstatic struct tracepoint *find_tracepoint(const char *tp_name)\n{\n\tstruct __find_tracepoint_cb_data data = {\n\t\t.tp_name = tp_name,\n\t};\n\n\tfor_each_kernel_tracepoint(__find_tracepoint_cb, &data);\n\n\treturn data.tpoint;\n}\n\nstatic int parse_symbol_and_return(int argc, const char *argv[],\n\t\t\t\t   char **symbol, bool *is_return,\n\t\t\t\t   bool is_tracepoint)\n{\n\tchar *tmp = strchr(argv[1], '%');\n\tint i;\n\n\tif (tmp) {\n\t\tint len = tmp - argv[1];\n\n\t\tif (!is_tracepoint && !strcmp(tmp, \"%return\")) {\n\t\t\t*is_return = true;\n\t\t} else {\n\t\t\ttrace_probe_log_err(len, BAD_ADDR_SUFFIX);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*symbol = kmemdup_nul(argv[1], len, GFP_KERNEL);\n\t} else\n\t\t*symbol = kstrdup(argv[1], GFP_KERNEL);\n\tif (!*symbol)\n\t\treturn -ENOMEM;\n\n\tif (*is_return)\n\t\treturn 0;\n\n\t \n\tfor (i = 2; i < argc; i++) {\n\t\ttmp = strstr(argv[i], \"$retval\");\n\t\tif (tmp && !isalnum(tmp[7]) && tmp[7] != '_') {\n\t\t\tif (is_tracepoint) {\n\t\t\t\ttrace_probe_log_set_index(i);\n\t\t\t\ttrace_probe_log_err(tmp - argv[i], RETVAL_ON_PROBE);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*is_return = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __trace_fprobe_create(int argc, const char *argv[])\n{\n\t \n\tstruct trace_fprobe *tf = NULL;\n\tint i, len, new_argc = 0, ret = 0;\n\tbool is_return = false;\n\tchar *symbol = NULL;\n\tconst char *event = NULL, *group = FPROBE_EVENT_SYSTEM;\n\tconst char **new_argv = NULL;\n\tint maxactive = 0;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tchar gbuf[MAX_EVENT_NAME_LEN];\n\tchar sbuf[KSYM_NAME_LEN];\n\tchar abuf[MAX_BTF_ARGS_LEN];\n\tbool is_tracepoint = false;\n\tstruct tracepoint *tpoint = NULL;\n\tstruct traceprobe_parse_context ctx = {\n\t\t.flags = TPARG_FL_KERNEL | TPARG_FL_FPROBE,\n\t};\n\n\tif ((argv[0][0] != 'f' && argv[0][0] != 't') || argc < 2)\n\t\treturn -ECANCELED;\n\n\tif (argv[0][0] == 't') {\n\t\tis_tracepoint = true;\n\t\tgroup = TRACEPOINT_EVENT_SYSTEM;\n\t}\n\n\ttrace_probe_log_init(\"trace_fprobe\", argc, argv);\n\n\tevent = strchr(&argv[0][1], ':');\n\tif (event)\n\t\tevent++;\n\n\tif (isdigit(argv[0][1])) {\n\t\tif (event)\n\t\t\tlen = event - &argv[0][1] - 1;\n\t\telse\n\t\t\tlen = strlen(&argv[0][1]);\n\t\tif (len > MAX_EVENT_NAME_LEN - 1) {\n\t\t\ttrace_probe_log_err(1, BAD_MAXACT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tmemcpy(buf, &argv[0][1], len);\n\t\tbuf[len] = '\\0';\n\t\tret = kstrtouint(buf, 0, &maxactive);\n\t\tif (ret || !maxactive) {\n\t\t\ttrace_probe_log_err(1, BAD_MAXACT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\t \n\t\tif (maxactive > RETHOOK_MAXACTIVE_MAX) {\n\t\t\ttrace_probe_log_err(1, MAXACT_TOO_BIG);\n\t\t\tgoto parse_error;\n\t\t}\n\t}\n\n\ttrace_probe_log_set_index(1);\n\n\t \n\tret = parse_symbol_and_return(argc, argv, &symbol, &is_return, is_tracepoint);\n\tif (ret < 0)\n\t\tgoto parse_error;\n\n\tif (!is_return && maxactive) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(1, BAD_MAXACT_TYPE);\n\t\tgoto parse_error;\n\t}\n\n\ttrace_probe_log_set_index(0);\n\tif (event) {\n\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t}\n\n\tif (!event) {\n\t\t \n\t\tif (is_tracepoint)\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%s%s\",\n\t\t\t\t isdigit(*symbol) ? \"_\" : \"\", symbol);\n\t\telse\n\t\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%s__%s\", symbol,\n\t\t\t\t is_return ? \"exit\" : \"entry\");\n\t\tsanitize_event_name(buf);\n\t\tevent = buf;\n\t}\n\n\tif (is_return)\n\t\tctx.flags |= TPARG_FL_RETURN;\n\telse\n\t\tctx.flags |= TPARG_FL_FENTRY;\n\n\tif (is_tracepoint) {\n\t\tctx.flags |= TPARG_FL_TPOINT;\n\t\ttpoint = find_tracepoint(symbol);\n\t\tif (!tpoint) {\n\t\t\ttrace_probe_log_set_index(1);\n\t\t\ttrace_probe_log_err(0, NO_TRACEPOINT);\n\t\t\tgoto parse_error;\n\t\t}\n\t\tctx.funcname = kallsyms_lookup(\n\t\t\t\t(unsigned long)tpoint->probestub,\n\t\t\t\tNULL, NULL, NULL, sbuf);\n\t} else\n\t\tctx.funcname = symbol;\n\n\targc -= 2; argv += 2;\n\tnew_argv = traceprobe_expand_meta_args(argc, argv, &new_argc,\n\t\t\t\t\t       abuf, MAX_BTF_ARGS_LEN, &ctx);\n\tif (IS_ERR(new_argv)) {\n\t\tret = PTR_ERR(new_argv);\n\t\tnew_argv = NULL;\n\t\tgoto out;\n\t}\n\tif (new_argv) {\n\t\targc = new_argc;\n\t\targv = new_argv;\n\t}\n\n\t \n\ttf = alloc_trace_fprobe(group, event, symbol, tpoint, maxactive,\n\t\t\t\targc, is_return);\n\tif (IS_ERR(tf)) {\n\t\tret = PTR_ERR(tf);\n\t\t \n\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\t\tgoto out;\t \n\t}\n\n\tif (is_tracepoint)\n\t\ttf->mod = __module_text_address(\n\t\t\t\t(unsigned long)tf->tpoint->probestub);\n\n\t \n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tctx.offset = 0;\n\t\tret = traceprobe_parse_probe_arg(&tf->tp, i, argv[i], &ctx);\n\t\tif (ret)\n\t\t\tgoto error;\t \n\t}\n\n\tret = traceprobe_set_print_fmt(&tf->tp,\n\t\t\tis_return ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = register_trace_fprobe(tf);\n\tif (ret) {\n\t\ttrace_probe_log_set_index(1);\n\t\tif (ret == -EILSEQ)\n\t\t\ttrace_probe_log_err(0, BAD_INSN_BNDRY);\n\t\telse if (ret == -ENOENT)\n\t\t\ttrace_probe_log_err(0, BAD_PROBE_ADDR);\n\t\telse if (ret != -ENOMEM && ret != -EEXIST)\n\t\t\ttrace_probe_log_err(0, FAIL_REG_PROBE);\n\t\tgoto error;\n\t}\n\nout:\n\ttraceprobe_finish_parse(&ctx);\n\ttrace_probe_log_clear();\n\tkfree(new_argv);\n\tkfree(symbol);\n\treturn ret;\n\nparse_error:\n\tret = -EINVAL;\nerror:\n\tfree_trace_fprobe(tf);\n\tgoto out;\n}\n\nstatic int trace_fprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_fprobe_create);\n}\n\nstatic int trace_fprobe_release(struct dyn_event *ev)\n{\n\tstruct trace_fprobe *tf = to_trace_fprobe(ev);\n\tint ret = unregister_trace_fprobe(tf);\n\n\tif (!ret)\n\t\tfree_trace_fprobe(tf);\n\treturn ret;\n}\n\nstatic int trace_fprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_fprobe *tf = to_trace_fprobe(ev);\n\tint i;\n\n\tif (trace_fprobe_is_tracepoint(tf))\n\t\tseq_putc(m, 't');\n\telse\n\t\tseq_putc(m, 'f');\n\tif (trace_fprobe_is_return(tf) && tf->fp.nr_maxactive)\n\t\tseq_printf(m, \"%d\", tf->fp.nr_maxactive);\n\tseq_printf(m, \":%s/%s\", trace_probe_group_name(&tf->tp),\n\t\t\t\ttrace_probe_name(&tf->tp));\n\n\tseq_printf(m, \" %s%s\", trace_fprobe_symbol(tf),\n\t\t\t       trace_fprobe_is_return(tf) ? \"%return\" : \"\");\n\n\tfor (i = 0; i < tf->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tf->tp.args[i].name, tf->tp.args[i].comm);\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\n \nstatic int fprobe_register(struct trace_event_call *event,\n\t\t\t   enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn enable_trace_fprobe(event, file);\n\tcase TRACE_REG_UNREGISTER:\n\t\treturn disable_trace_fprobe(event, file);\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn enable_trace_fprobe(event, NULL);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn disable_trace_fprobe(event, NULL);\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}\n\n \nstatic __init int init_fprobe_trace_early(void)\n{\n\tint ret;\n\n\tret = dyn_event_register(&trace_fprobe_ops);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = register_tracepoint_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\treturn 0;\n}\ncore_initcall(init_fprobe_trace_early);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}