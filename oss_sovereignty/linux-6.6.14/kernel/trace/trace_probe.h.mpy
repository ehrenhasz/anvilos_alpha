{
  "module_name": "trace_probe.h",
  "hash_id": "7099720c44175e2b972f4b878e60a370492fac2ae57c0b6cc1a51d70a191b50d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_probe.h",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/tracefs.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/perf_event.h>\n#include <linux/kprobes.h>\n#include <linux/stringify.h>\n#include <linux/limits.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/btf.h>\n#include <asm/bitsperlong.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\n#define MAX_TRACE_ARGS\t\t128\n#define MAX_ARGSTR_LEN\t\t63\n#define MAX_ARRAY_LEN\t\t64\n#define MAX_ARG_NAME_LEN\t32\n#define MAX_BTF_ARGS_LEN\t128\n#define MAX_STRING_SIZE\t\tPATH_MAX\n#define MAX_ARG_BUF_LEN\t\t(MAX_TRACE_ARGS * MAX_ARG_NAME_LEN)\n\n \n#define FIELD_STRING_IP\t\t\"__probe_ip\"\n#define FIELD_STRING_RETIP\t\"__probe_ret_ip\"\n#define FIELD_STRING_FUNC\t\"__probe_func\"\n\n#undef DEFINE_FIELD\n#define DEFINE_FIELD(type, item, name, is_signed)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tret = trace_define_field(event_call, #type, name,\t\\\n\t\t\t\t\t offsetof(typeof(field), item),\t\\\n\t\t\t\t\t sizeof(field.item), is_signed, \\\n\t\t\t\t\t FILTER_OTHER);\t\t\t\\\n\t\tif (ret)\t\t\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\\\n\t} while (0)\n\n\n \n#define TP_FLAG_TRACE\t\t1\n#define TP_FLAG_PROFILE\t\t2\n\n \n#define make_data_loc(len, offs)\t\\\n\t(((u32)(len) << 16) | ((u32)(offs) & 0xffff))\n#define get_loc_len(dl)\t\t((u32)(dl) >> 16)\n#define get_loc_offs(dl)\t((u32)(dl) & 0xffff)\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}\n\nstatic nokprobe_inline u32 update_data_loc(u32 loc, int consumed)\n{\n\tu32 maxlen = get_loc_len(loc);\n\tu32 offset = get_loc_offs(loc);\n\n\treturn make_data_loc(maxlen - consumed, offset + consumed);\n}\n\n \ntypedef int (*print_type_func_t)(struct trace_seq *, void *, void *);\n\nenum fetch_op {\n\tFETCH_OP_NOP = 0,\n\t\n\tFETCH_OP_REG,\t\t \n\tFETCH_OP_STACK,\t\t \n\tFETCH_OP_STACKP,\t \n\tFETCH_OP_RETVAL,\t \n\tFETCH_OP_IMM,\t\t \n\tFETCH_OP_COMM,\t\t \n\tFETCH_OP_ARG,\t\t \n\tFETCH_OP_FOFFS,\t\t \n\tFETCH_OP_DATA,\t\t \n\t\n\tFETCH_OP_DEREF,\t\t \n\tFETCH_OP_UDEREF,\t \n\t\n\tFETCH_OP_ST_RAW,\t \n\tFETCH_OP_ST_MEM,\t \n\tFETCH_OP_ST_UMEM,\t \n\tFETCH_OP_ST_STRING,\t \n\tFETCH_OP_ST_USTRING,\t \n\tFETCH_OP_ST_SYMSTR,\t \n\t\n\tFETCH_OP_MOD_BF,\t \n\t\n\tFETCH_OP_LP_ARRAY,\t \n\tFETCH_OP_TP_ARG,\t \n\tFETCH_OP_END,\n\tFETCH_NOP_SYMBOL,\t \n};\n\nstruct fetch_insn {\n\tenum fetch_op op;\n\tunion {\n\t\tunsigned int param;\n\t\tstruct {\n\t\t\tunsigned int size;\n\t\t\tint offset;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned char basesize;\n\t\t\tunsigned char lshift;\n\t\t\tunsigned char rshift;\n\t\t};\n\t\tunsigned long immediate;\n\t\tvoid *data;\n\t};\n};\n\n \n#define FETCH_INSN_MAX\t16\n#define FETCH_TOKEN_COMM\t(-ECOMM)\n\n \nstruct fetch_type {\n\tconst char\t\t*name;\t\t \n\tsize_t\t\t\tsize;\t\t \n\tbool\t\t\tis_signed;\t \n\tbool\t\t\tis_string;\t \n\tprint_type_func_t\tprint;\t\t \n\tconst char\t\t*fmt;\t\t \n\tconst char\t\t*fmttype;\t \n};\n\n \ntypedef u32 string;\ntypedef u32 string_size;\n\n#define PRINT_TYPE_FUNC_NAME(type)\tprint_type_##type\n#define PRINT_TYPE_FMT_NAME(type)\tprint_type_format_##type\n\n \n#define DECLARE_BASIC_PRINT_TYPE_FUNC(type)\t\t\t\t\\\nint PRINT_TYPE_FUNC_NAME(type)(struct trace_seq *s, void *data, void *ent);\\\nextern const char PRINT_TYPE_FMT_NAME(type)[]\n\nDECLARE_BASIC_PRINT_TYPE_FUNC(u8);\nDECLARE_BASIC_PRINT_TYPE_FUNC(u16);\nDECLARE_BASIC_PRINT_TYPE_FUNC(u32);\nDECLARE_BASIC_PRINT_TYPE_FUNC(u64);\nDECLARE_BASIC_PRINT_TYPE_FUNC(s8);\nDECLARE_BASIC_PRINT_TYPE_FUNC(s16);\nDECLARE_BASIC_PRINT_TYPE_FUNC(s32);\nDECLARE_BASIC_PRINT_TYPE_FUNC(s64);\nDECLARE_BASIC_PRINT_TYPE_FUNC(x8);\nDECLARE_BASIC_PRINT_TYPE_FUNC(x16);\nDECLARE_BASIC_PRINT_TYPE_FUNC(x32);\nDECLARE_BASIC_PRINT_TYPE_FUNC(x64);\n\nDECLARE_BASIC_PRINT_TYPE_FUNC(char);\nDECLARE_BASIC_PRINT_TYPE_FUNC(string);\nDECLARE_BASIC_PRINT_TYPE_FUNC(symbol);\n\n \n#define __DEFAULT_FETCH_TYPE(t) x##t\n#define _DEFAULT_FETCH_TYPE(t) __DEFAULT_FETCH_TYPE(t)\n#define DEFAULT_FETCH_TYPE _DEFAULT_FETCH_TYPE(BITS_PER_LONG)\n#define DEFAULT_FETCH_TYPE_STR __stringify(DEFAULT_FETCH_TYPE)\n\n#define __ADDR_FETCH_TYPE(t) u##t\n#define _ADDR_FETCH_TYPE(t) __ADDR_FETCH_TYPE(t)\n#define ADDR_FETCH_TYPE _ADDR_FETCH_TYPE(BITS_PER_LONG)\n\n#define __ASSIGN_FETCH_TYPE(_name, ptype, ftype, _size, sign, str, _fmttype)\t\\\n\t{.name = _name,\t\t\t\t\t\\\n\t .size = _size,\t\t\t\t\t\\\n\t .is_signed = (bool)sign,\t\t\t\\\n\t .is_string = (bool)str,\t\t\t\\\n\t .print = PRINT_TYPE_FUNC_NAME(ptype),\t\t\\\n\t .fmt = PRINT_TYPE_FMT_NAME(ptype),\t\t\\\n\t .fmttype = _fmttype,\t\t\t\t\\\n\t}\n\n \n#define _ASSIGN_FETCH_TYPE(_name, ptype, ftype, _size, sign, _fmttype)\t\\\n\t__ASSIGN_FETCH_TYPE(_name, ptype, ftype, _size, sign, 0, #_fmttype)\n#define ASSIGN_FETCH_TYPE(ptype, ftype, sign)\t\t\t\\\n\t_ASSIGN_FETCH_TYPE(#ptype, ptype, ftype, sizeof(ftype), sign, ptype)\n\n \n#define ASSIGN_FETCH_TYPE_ALIAS(ptype, atype, ftype, sign)\t\t\\\n\t_ASSIGN_FETCH_TYPE(#ptype, ptype, ftype, sizeof(ftype), sign, atype)\n\n#define ASSIGN_FETCH_TYPE_END {}\n#define MAX_ARRAY_LEN\t64\n\n#ifdef CONFIG_KPROBE_EVENTS\nbool trace_kprobe_on_func_entry(struct trace_event_call *call);\nbool trace_kprobe_error_injectable(struct trace_event_call *call);\n#else\nstatic inline bool trace_kprobe_on_func_entry(struct trace_event_call *call)\n{\n\treturn false;\n}\n\nstatic inline bool trace_kprobe_error_injectable(struct trace_event_call *call)\n{\n\treturn false;\n}\n#endif  \n\nstruct probe_arg {\n\tstruct fetch_insn\t*code;\n\tbool\t\t\tdynamic; \n\tunsigned int\t\toffset;\t \n\tunsigned int\t\tcount;\t \n\tconst char\t\t*name;\t \n\tconst char\t\t*comm;\t \n\tchar\t\t\t*fmt;\t \n\tconst struct fetch_type\t*type;\t \n};\n\nstruct trace_uprobe_filter {\n\trwlock_t\t\trwlock;\n\tint\t\t\tnr_systemwide;\n\tstruct list_head\tperf_events;\n};\n\n \nstruct trace_probe_event {\n\tunsigned int\t\t\tflags;\t \n\tstruct trace_event_class\tclass;\n\tstruct trace_event_call\t\tcall;\n\tstruct list_head \t\tfiles;\n\tstruct list_head\t\tprobes;\n\tstruct trace_uprobe_filter\tfilter[];\n};\n\nstruct trace_probe {\n\tstruct list_head\t\tlist;\n\tstruct trace_probe_event\t*event;\n\tssize_t\t\t\t\tsize;\t \n\tunsigned int\t\t\tnr_args;\n\tstruct probe_arg\t\targs[];\n};\n\nstruct event_file_link {\n\tstruct trace_event_file\t\t*file;\n\tstruct list_head\t\tlist;\n};\n\nstatic inline bool trace_probe_test_flag(struct trace_probe *tp,\n\t\t\t\t\t unsigned int flag)\n{\n\treturn !!(tp->event->flags & flag);\n}\n\nstatic inline void trace_probe_set_flag(struct trace_probe *tp,\n\t\t\t\t\tunsigned int flag)\n{\n\ttp->event->flags |= flag;\n}\n\nstatic inline void trace_probe_clear_flag(struct trace_probe *tp,\n\t\t\t\t\t  unsigned int flag)\n{\n\ttp->event->flags &= ~flag;\n}\n\nstatic inline bool trace_probe_is_enabled(struct trace_probe *tp)\n{\n\treturn trace_probe_test_flag(tp, TP_FLAG_TRACE | TP_FLAG_PROFILE);\n}\n\nstatic inline const char *trace_probe_name(struct trace_probe *tp)\n{\n\treturn trace_event_name(&tp->event->call);\n}\n\nstatic inline const char *trace_probe_group_name(struct trace_probe *tp)\n{\n\treturn tp->event->call.class->system;\n}\n\nstatic inline struct trace_event_call *\n\ttrace_probe_event_call(struct trace_probe *tp)\n{\n\treturn &tp->event->call;\n}\n\nstatic inline struct trace_probe_event *\ntrace_probe_event_from_call(struct trace_event_call *event_call)\n{\n\treturn container_of(event_call, struct trace_probe_event, call);\n}\n\nstatic inline struct trace_probe *\ntrace_probe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe_event *tpe = trace_probe_event_from_call(call);\n\n\treturn list_first_entry_or_null(&tpe->probes, struct trace_probe, list);\n}\n\nstatic inline struct list_head *trace_probe_probe_list(struct trace_probe *tp)\n{\n\treturn &tp->event->probes;\n}\n\nstatic inline bool trace_probe_has_sibling(struct trace_probe *tp)\n{\n\tstruct list_head *list = trace_probe_probe_list(tp);\n\n\treturn !list_empty(list) && !list_is_singular(list);\n}\n\nstatic inline int trace_probe_unregister_event_call(struct trace_probe *tp)\n{\n\t \n\treturn trace_remove_event_call(&tp->event->call);\n}\n\nstatic inline bool trace_probe_has_single_file(struct trace_probe *tp)\n{\n\treturn !!list_is_singular(&tp->event->files);\n}\n\nint trace_probe_init(struct trace_probe *tp, const char *event,\n\t\t     const char *group, bool alloc_filter);\nvoid trace_probe_cleanup(struct trace_probe *tp);\nint trace_probe_append(struct trace_probe *tp, struct trace_probe *to);\nvoid trace_probe_unlink(struct trace_probe *tp);\nint trace_probe_register_event_call(struct trace_probe *tp);\nint trace_probe_add_file(struct trace_probe *tp, struct trace_event_file *file);\nint trace_probe_remove_file(struct trace_probe *tp,\n\t\t\t    struct trace_event_file *file);\nstruct event_file_link *trace_probe_get_file_link(struct trace_probe *tp,\n\t\t\t\t\t\tstruct trace_event_file *file);\nint trace_probe_compare_arg_type(struct trace_probe *a, struct trace_probe *b);\nbool trace_probe_match_command_args(struct trace_probe *tp,\n\t\t\t\t    int argc, const char **argv);\nint trace_probe_create(const char *raw_command, int (*createfn)(int, const char **));\nint trace_probe_print_args(struct trace_seq *s, struct probe_arg *args, int nr_args,\n\t\t u8 *data, void *field);\n\n#define trace_probe_for_each_link(pos, tp)\t\\\n\tlist_for_each_entry(pos, &(tp)->event->files, list)\n#define trace_probe_for_each_link_rcu(pos, tp)\t\\\n\tlist_for_each_entry_rcu(pos, &(tp)->event->files, list)\n\n \n#define TPARG_FL_RETURN BIT(0)\n#define TPARG_FL_KERNEL BIT(1)\n#define TPARG_FL_FENTRY BIT(2)\n#define TPARG_FL_TEVENT BIT(3)\n#define TPARG_FL_USER   BIT(4)\n#define TPARG_FL_FPROBE BIT(5)\n#define TPARG_FL_TPOINT BIT(6)\n#define TPARG_FL_LOC_MASK\tGENMASK(4, 0)\n\nstatic inline bool tparg_is_function_entry(unsigned int flags)\n{\n\treturn (flags & TPARG_FL_LOC_MASK) == (TPARG_FL_KERNEL | TPARG_FL_FENTRY);\n}\n\nstruct traceprobe_parse_context {\n\tstruct trace_event_call *event;\n\t \n\tconst char *funcname;\t\t \n\tconst struct btf_type  *proto;\t \n\tconst struct btf_param *params;\t \n\ts32 nr_params;\t\t\t \n\tstruct btf *btf;\t\t \n\tconst struct btf_type *last_type;\t \n\tu32 last_bitoffs;\t\t \n\tu32 last_bitsize;\t\t \n\tunsigned int flags;\n\tint offset;\n};\n\nextern int traceprobe_parse_probe_arg(struct trace_probe *tp, int i,\n\t\t\t\t      const char *argv,\n\t\t\t\t      struct traceprobe_parse_context *ctx);\nconst char **traceprobe_expand_meta_args(int argc, const char *argv[],\n\t\t\t\t\t int *new_argc, char *buf, int bufsize,\n\t\t\t\t\t struct traceprobe_parse_context *ctx);\n\nextern int traceprobe_update_arg(struct probe_arg *arg);\nextern void traceprobe_free_probe_arg(struct probe_arg *arg);\n\n \nvoid traceprobe_finish_parse(struct traceprobe_parse_context *ctx);\n\nextern int traceprobe_split_symbol_offset(char *symbol, long *offset);\nint traceprobe_parse_event_name(const char **pevent, const char **pgroup,\n\t\t\t\tchar *buf, int offset);\n\nenum probe_print_type {\n\tPROBE_PRINT_NORMAL,\n\tPROBE_PRINT_RETURN,\n\tPROBE_PRINT_EVENT,\n};\n\nextern int traceprobe_set_print_fmt(struct trace_probe *tp, enum probe_print_type ptype);\n\n#ifdef CONFIG_PERF_EVENTS\nextern struct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return);\nextern void destroy_local_trace_kprobe(struct trace_event_call *event_call);\n\nextern struct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return);\nextern void destroy_local_trace_uprobe(struct trace_event_call *event_call);\n#endif\nextern int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t\tsize_t offset, struct trace_probe *tp);\n\n#undef ERRORS\n#define ERRORS\t\\\n\tC(FILE_NOT_FOUND,\t\"Failed to find the given file\"),\t\\\n\tC(NO_REGULAR_FILE,\t\"Not a regular file\"),\t\t\t\\\n\tC(BAD_REFCNT,\t\t\"Invalid reference counter offset\"),\t\\\n\tC(REFCNT_OPEN_BRACE,\t\"Reference counter brace is not closed\"), \\\n\tC(BAD_REFCNT_SUFFIX,\t\"Reference counter has wrong suffix\"),\t\\\n\tC(BAD_UPROBE_OFFS,\t\"Invalid uprobe offset\"),\t\t\\\n\tC(BAD_MAXACT_TYPE,\t\"Maxactive is only for function exit\"),\t\\\n\tC(BAD_MAXACT,\t\t\"Invalid maxactive number\"),\t\t\\\n\tC(MAXACT_TOO_BIG,\t\"Maxactive is too big\"),\t\t\\\n\tC(BAD_PROBE_ADDR,\t\"Invalid probed address or symbol\"),\t\\\n\tC(NON_UNIQ_SYMBOL,\t\"The symbol is not unique\"),\t\t\\\n\tC(BAD_RETPROBE,\t\t\"Retprobe address must be an function entry\"), \\\n\tC(NO_TRACEPOINT,\t\"Tracepoint is not found\"),\t\t\\\n\tC(BAD_ADDR_SUFFIX,\t\"Invalid probed address suffix\"), \\\n\tC(NO_GROUP_NAME,\t\"Group name is not specified\"),\t\t\\\n\tC(GROUP_TOO_LONG,\t\"Group name is too long\"),\t\t\\\n\tC(BAD_GROUP_NAME,\t\"Group name must follow the same rules as C identifiers\"), \\\n\tC(NO_EVENT_NAME,\t\"Event name is not specified\"),\t\t\\\n\tC(EVENT_TOO_LONG,\t\"Event name is too long\"),\t\t\\\n\tC(BAD_EVENT_NAME,\t\"Event name must follow the same rules as C identifiers\"), \\\n\tC(EVENT_EXIST,\t\t\"Given group/event name is already used by another event\"), \\\n\tC(RETVAL_ON_PROBE,\t\"$retval is not available on probe\"),\t\\\n\tC(NO_RETVAL,\t\t\"This function returns 'void' type\"),\t\\\n\tC(BAD_STACK_NUM,\t\"Invalid stack number\"),\t\t\\\n\tC(BAD_ARG_NUM,\t\t\"Invalid argument number\"),\t\t\\\n\tC(BAD_VAR,\t\t\"Invalid $-valiable specified\"),\t\\\n\tC(BAD_REG_NAME,\t\t\"Invalid register name\"),\t\t\\\n\tC(BAD_MEM_ADDR,\t\t\"Invalid memory address\"),\t\t\\\n\tC(BAD_IMM,\t\t\"Invalid immediate value\"),\t\t\\\n\tC(IMMSTR_NO_CLOSE,\t\"String is not closed with '\\\"'\"),\t\\\n\tC(FILE_ON_KPROBE,\t\"File offset is not available with kprobe\"), \\\n\tC(BAD_FILE_OFFS,\t\"Invalid file offset value\"),\t\t\\\n\tC(SYM_ON_UPROBE,\t\"Symbol is not available with uprobe\"),\t\\\n\tC(TOO_MANY_OPS,\t\t\"Dereference is too much nested\"), \t\\\n\tC(DEREF_NEED_BRACE,\t\"Dereference needs a brace\"),\t\t\\\n\tC(BAD_DEREF_OFFS,\t\"Invalid dereference offset\"),\t\t\\\n\tC(DEREF_OPEN_BRACE,\t\"Dereference brace is not closed\"),\t\\\n\tC(COMM_CANT_DEREF,\t\"$comm can not be dereferenced\"),\t\\\n\tC(BAD_FETCH_ARG,\t\"Invalid fetch argument\"),\t\t\\\n\tC(ARRAY_NO_CLOSE,\t\"Array is not closed\"),\t\t\t\\\n\tC(BAD_ARRAY_SUFFIX,\t\"Array has wrong suffix\"),\t\t\\\n\tC(BAD_ARRAY_NUM,\t\"Invalid array size\"),\t\t\t\\\n\tC(ARRAY_TOO_BIG,\t\"Array number is too big\"),\t\t\\\n\tC(BAD_TYPE,\t\t\"Unknown type is specified\"),\t\t\\\n\tC(BAD_STRING,\t\t\"String accepts only memory argument\"),\t\\\n\tC(BAD_SYMSTRING,\t\"Symbol String doesn't accept data/userdata\"),\t\\\n\tC(BAD_BITFIELD,\t\t\"Invalid bitfield\"),\t\t\t\\\n\tC(ARG_NAME_TOO_LONG,\t\"Argument name is too long\"),\t\t\\\n\tC(NO_ARG_NAME,\t\t\"Argument name is not specified\"),\t\\\n\tC(BAD_ARG_NAME,\t\t\"Argument name must follow the same rules as C identifiers\"), \\\n\tC(USED_ARG_NAME,\t\"This argument name is already used\"),\t\\\n\tC(ARG_TOO_LONG,\t\t\"Argument expression is too long\"),\t\\\n\tC(NO_ARG_BODY,\t\t\"No argument expression\"),\t\t\\\n\tC(BAD_INSN_BNDRY,\t\"Probe point is not an instruction boundary\"),\\\n\tC(FAIL_REG_PROBE,\t\"Failed to register probe event\"),\\\n\tC(DIFF_PROBE_TYPE,\t\"Probe type is different from existing probe\"),\\\n\tC(DIFF_ARG_TYPE,\t\"Argument type or name is different from existing probe\"),\\\n\tC(SAME_PROBE,\t\t\"There is already the exact same probe event\"),\\\n\tC(NO_EVENT_INFO,\t\"This requires both group and event name to attach\"),\\\n\tC(BAD_ATTACH_EVENT,\t\"Attached event does not exist\"),\\\n\tC(BAD_ATTACH_ARG,\t\"Attached event does not have this field\"),\\\n\tC(NO_EP_FILTER,\t\t\"No filter rule after 'if'\"),\t\t\\\n\tC(NOSUP_BTFARG,\t\t\"BTF is not available or not supported\"),\t\\\n\tC(NO_BTFARG,\t\t\"This variable is not found at this probe point\"),\\\n\tC(NO_BTF_ENTRY,\t\t\"No BTF entry for this probe point\"),\t\\\n\tC(BAD_VAR_ARGS,\t\t\"$arg* must be an independent parameter without name etc.\"),\\\n\tC(NOFENTRY_ARGS,\t\"$arg* can be used only on function entry\"),\t\\\n\tC(DOUBLE_ARGS,\t\t\"$arg* can be used only once in the parameters\"),\t\\\n\tC(ARGS_2LONG,\t\t\"$arg* failed because the argument list is too long\"),\t\\\n\tC(ARGIDX_2BIG,\t\t\"$argN index is too big\"),\t\t\\\n\tC(NO_PTR_STRCT,\t\t\"This is not a pointer to union/structure.\"),\t\\\n\tC(NOSUP_DAT_ARG,\t\"Non pointer structure/union argument is not supported.\"),\\\n\tC(BAD_HYPHEN,\t\t\"Failed to parse single hyphen. Forgot '>'?\"),\t\\\n\tC(NO_BTF_FIELD,\t\t\"This field is not found.\"),\t\\\n\tC(BAD_BTF_TID,\t\t\"Failed to get BTF type info.\"),\\\n\tC(BAD_TYPE4STR,\t\t\"This type does not fit for string.\"),\n\n#undef C\n#define C(a, b)\t\tTP_ERR_##a\n\n \nenum { ERRORS };\n\n \n\nstruct trace_probe_log {\n\tconst char\t*subsystem;\n\tconst char\t**argv;\n\tint\t\targc;\n\tint\t\tindex;\n};\n\nvoid trace_probe_log_init(const char *subsystem, int argc, const char **argv);\nvoid trace_probe_log_set_index(int index);\nvoid trace_probe_log_clear(void);\nvoid __trace_probe_log_err(int offset, int err);\n\n#define trace_probe_log_err(offs, err)\t\\\n\t__trace_probe_log_err(offs, TP_ERR_##err)\n\nstruct uprobe_dispatch_data {\n\tstruct trace_uprobe\t*tu;\n\tunsigned long\t\tbp_addr;\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}