{
  "module_name": "preemptirq_delay_test.c",
  "hash_id": "96e58381fc88d3300971e43f7adbd8ff86bd6842775fc9d2d099e7e9ee6e7758",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/preemptirq_delay_test.c",
  "human_readable_source": "\n \n\n#include <linux/trace_clock.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/completion.h>\n\nstatic ulong delay = 100;\nstatic char test_mode[12] = \"irq\";\nstatic uint burst_size = 1;\nstatic int  cpu_affinity = -1;\n\nmodule_param_named(delay, delay, ulong, 0444);\nmodule_param_string(test_mode, test_mode, 12, 0444);\nmodule_param_named(burst_size, burst_size, uint, 0444);\nmodule_param_named(cpu_affinity, cpu_affinity, int, 0444);\nMODULE_PARM_DESC(delay, \"Period in microseconds (100 us default)\");\nMODULE_PARM_DESC(test_mode, \"Mode of the test such as preempt, irq, or alternate (default irq)\");\nMODULE_PARM_DESC(burst_size, \"The size of a burst (default 1)\");\nMODULE_PARM_DESC(cpu_affinity, \"Cpu num test is running on\");\n\nstatic struct completion done;\n\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n\nstatic void busy_wait(ulong time)\n{\n\tu64 start, end;\n\n\tstart = trace_clock_local();\n\n\tdo {\n\t\tend = trace_clock_local();\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t} while ((end - start) < (time * 1000));\n}\n\nstatic __always_inline void irqoff_test(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tbusy_wait(delay);\n\tlocal_irq_restore(flags);\n}\n\nstatic __always_inline void preemptoff_test(void)\n{\n\tpreempt_disable();\n\tbusy_wait(delay);\n\tpreempt_enable();\n}\n\nstatic void execute_preemptirqtest(int idx)\n{\n\tif (!strcmp(test_mode, \"irq\"))\n\t\tirqoff_test();\n\telse if (!strcmp(test_mode, \"preempt\"))\n\t\tpreemptoff_test();\n\telse if (!strcmp(test_mode, \"alternate\")) {\n\t\tif (idx % 2 == 0)\n\t\t\tirqoff_test();\n\t\telse\n\t\t\tpreemptoff_test();\n\t}\n}\n\n#define DECLARE_TESTFN(POSTFIX)\t\t\t\t\\\n\tstatic void preemptirqtest_##POSTFIX(int idx)\t\\\n\t{\t\t\t\t\t\t\\\n\t\texecute_preemptirqtest(idx);\t\t\\\n\t}\t\t\t\t\t\t\\\n\n \nDECLARE_TESTFN(0)\nDECLARE_TESTFN(1)\nDECLARE_TESTFN(2)\nDECLARE_TESTFN(3)\nDECLARE_TESTFN(4)\nDECLARE_TESTFN(5)\nDECLARE_TESTFN(6)\nDECLARE_TESTFN(7)\nDECLARE_TESTFN(8)\nDECLARE_TESTFN(9)\n\nstatic void (*testfuncs[])(int)  = {\n\tpreemptirqtest_0,\n\tpreemptirqtest_1,\n\tpreemptirqtest_2,\n\tpreemptirqtest_3,\n\tpreemptirqtest_4,\n\tpreemptirqtest_5,\n\tpreemptirqtest_6,\n\tpreemptirqtest_7,\n\tpreemptirqtest_8,\n\tpreemptirqtest_9,\n};\n\n#define NR_TEST_FUNCS ARRAY_SIZE(testfuncs)\n\nstatic int preemptirq_delay_run(void *data)\n{\n\tint i;\n\tint s = MIN(burst_size, NR_TEST_FUNCS);\n\tstruct cpumask cpu_mask;\n\n\tif (cpu_affinity > -1) {\n\t\tcpumask_clear(&cpu_mask);\n\t\tcpumask_set_cpu(cpu_affinity, &cpu_mask);\n\t\tif (set_cpus_allowed_ptr(current, &cpu_mask))\n\t\t\tpr_err(\"cpu_affinity:%d, failed\\n\", cpu_affinity);\n\t}\n\n\tfor (i = 0; i < s; i++)\n\t\t(testfuncs[i])(i);\n\n\tcomplete(&done);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}\n\nstatic int preemptirq_run_test(void)\n{\n\tstruct task_struct *task;\n\tchar task_name[50];\n\n\tinit_completion(&done);\n\n\tsnprintf(task_name, sizeof(task_name), \"%s_test\", test_mode);\n\ttask =  kthread_run(preemptirq_delay_run, NULL, task_name);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (task) {\n\t\twait_for_completion(&done);\n\t\tkthread_stop(task);\n\t}\n\treturn 0;\n}\n\n\nstatic ssize_t trigger_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tret = preemptirq_run_test();\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic struct kobj_attribute trigger_attribute =\n\t__ATTR(trigger, 0200, NULL, trigger_store);\n\nstatic struct attribute *attrs[] = {\n\t&trigger_attribute.attr,\n\tNULL,\n};\n\nstatic struct attribute_group attr_group = {\n\t.attrs = attrs,\n};\n\nstatic struct kobject *preemptirq_delay_kobj;\n\nstatic int __init preemptirq_delay_init(void)\n{\n\tint retval;\n\n\tretval = preemptirq_run_test();\n\tif (retval != 0)\n\t\treturn retval;\n\n\tpreemptirq_delay_kobj = kobject_create_and_add(\"preemptirq_delay_test\",\n\t\t\t\t\t\t       kernel_kobj);\n\tif (!preemptirq_delay_kobj)\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(preemptirq_delay_kobj, &attr_group);\n\tif (retval)\n\t\tkobject_put(preemptirq_delay_kobj);\n\n\treturn retval;\n}\n\nstatic void __exit preemptirq_delay_exit(void)\n{\n\tkobject_put(preemptirq_delay_kobj);\n}\n\nmodule_init(preemptirq_delay_init)\nmodule_exit(preemptirq_delay_exit)\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}