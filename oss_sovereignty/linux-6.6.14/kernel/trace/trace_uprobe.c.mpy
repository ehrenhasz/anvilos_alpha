{
  "module_name": "trace_uprobe.c",
  "hash_id": "b72deb97bce4982f58c728ab85256ece59a8ff939b6b53b09ef9e261de58b36d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_uprobe.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt)\t\"trace_uprobe: \" fmt\n\n#include <linux/bpf-cgroup.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/uprobes.h>\n#include <linux/namei.h>\n#include <linux/string.h>\n#include <linux/rculist.h>\n#include <linux/filter.h>\n\n#include \"trace_dynevent.h\"\n#include \"trace_probe.h\"\n#include \"trace_probe_tmpl.h\"\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstruct uprobe_trace_entry_head {\n\tstruct trace_entry\tent;\n\tunsigned long\t\tvaddr[];\n};\n\n#define SIZEOF_TRACE_ENTRY(is_return)\t\t\t\\\n\t(sizeof(struct uprobe_trace_entry_head) +\t\\\n\t sizeof(unsigned long) * (is_return ? 2 : 1))\n\n#define DATAOF_TRACE_ENTRY(entry, is_return)\t\t\\\n\t((void*)(entry) + SIZEOF_TRACE_ENTRY(is_return))\n\nstatic int trace_uprobe_create(const char *raw_command);\nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev);\nstatic int trace_uprobe_release(struct dyn_event *ev);\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev);\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct dyn_event_operations trace_uprobe_ops = {\n\t.create = trace_uprobe_create,\n\t.show = trace_uprobe_show,\n\t.is_busy = trace_uprobe_is_busy,\n\t.free = trace_uprobe_release,\n\t.match = trace_uprobe_match,\n};\n\n \nstruct trace_uprobe {\n\tstruct dyn_event\t\tdevent;\n\tstruct uprobe_consumer\t\tconsumer;\n\tstruct path\t\t\tpath;\n\tstruct inode\t\t\t*inode;\n\tchar\t\t\t\t*filename;\n\tunsigned long\t\t\toffset;\n\tunsigned long\t\t\tref_ctr_offset;\n\tunsigned long\t\t\tnhit;\n\tstruct trace_probe\t\ttp;\n};\n\nstatic bool is_trace_uprobe(struct dyn_event *ev)\n{\n\treturn ev->ops == &trace_uprobe_ops;\n}\n\nstatic struct trace_uprobe *to_trace_uprobe(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct trace_uprobe, devent);\n}\n\n \n#define for_each_trace_uprobe(pos, dpos)\t\\\n\tfor_each_dyn_event(dpos)\t\t\\\n\t\tif (is_trace_uprobe(dpos) && (pos = to_trace_uprobe(dpos)))\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs);\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs);\n\n#ifdef CONFIG_STACK_GROWSUP\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr - (n * sizeof(long));\n}\n#else\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\n{\n\treturn addr + (n * sizeof(long));\n}\n#endif\n\nstatic unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\n{\n\tunsigned long ret;\n\tunsigned long addr = user_stack_pointer(regs);\n\n\taddr = adjust_stack_addr(addr, n);\n\n\tif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\n\t\treturn 0;\n\n\treturn ret;\n}\n\n \nstatic nokprobe_inline int\nprobe_mem_read(void *dest, void *src, size_t size)\n{\n\tvoid __user *vaddr = (void __force __user *)src;\n\n\treturn copy_from_user(dest, vaddr, size) ? -EFAULT : 0;\n}\n\nstatic nokprobe_inline int\nprobe_mem_read_user(void *dest, void *src, size_t size)\n{\n\treturn probe_mem_read(dest, src, size);\n}\n\n \nstatic nokprobe_inline int\nfetch_store_string(unsigned long addr, void *dest, void *base)\n{\n\tlong ret;\n\tu32 loc = *(u32 *)dest;\n\tint maxlen  = get_loc_len(loc);\n\tu8 *dst = get_loc_data(dest, base);\n\tvoid __user *src = (void __force __user *) addr;\n\n\tif (unlikely(!maxlen))\n\t\treturn -ENOMEM;\n\n\tif (addr == FETCH_TOKEN_COMM)\n\t\tret = strlcpy(dst, current->comm, maxlen);\n\telse\n\t\tret = strncpy_from_user(dst, src, maxlen);\n\tif (ret >= 0) {\n\t\tif (ret == maxlen)\n\t\t\tdst[ret - 1] = '\\0';\n\t\telse\n\t\t\t \n\t\t\tret++;\n\t\t*(u32 *)dest = make_data_loc(ret, (void *)dst - base);\n\t} else\n\t\t*(u32 *)dest = make_data_loc(0, (void *)dst - base);\n\n\treturn ret;\n}\n\nstatic nokprobe_inline int\nfetch_store_string_user(unsigned long addr, void *dest, void *base)\n{\n\treturn fetch_store_string(addr, dest, base);\n}\n\n \nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tif (addr == FETCH_TOKEN_COMM)\n\t\tlen = strlen(current->comm) + 1;\n\telse\n\t\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}\n\nstatic nokprobe_inline int\nfetch_store_strlen_user(unsigned long addr)\n{\n\treturn fetch_store_strlen(addr);\n}\n\nstatic unsigned long translate_user_vaddr(unsigned long file_offset)\n{\n\tunsigned long base_addr;\n\tstruct uprobe_dispatch_data *udd;\n\n\tudd = (void *) current->utask->vaddr;\n\n\tbase_addr = udd->bp_addr - udd->tu->offset;\n\treturn base_addr + file_offset;\n}\n\n \nstatic int\nprocess_fetch_insn(struct fetch_insn *code, void *rec, void *dest,\n\t\t   void *base)\n{\n\tstruct pt_regs *regs = rec;\n\tunsigned long val;\n\tint ret;\n\n\t \n\tswitch (code->op) {\n\tcase FETCH_OP_REG:\n\t\tval = regs_get_register(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACK:\n\t\tval = get_user_stack_nth(regs, code->param);\n\t\tbreak;\n\tcase FETCH_OP_STACKP:\n\t\tval = user_stack_pointer(regs);\n\t\tbreak;\n\tcase FETCH_OP_RETVAL:\n\t\tval = regs_return_value(regs);\n\t\tbreak;\n\tcase FETCH_OP_COMM:\n\t\tval = FETCH_TOKEN_COMM;\n\t\tbreak;\n\tcase FETCH_OP_FOFFS:\n\t\tval = translate_user_vaddr(code->immediate);\n\t\tbreak;\n\tdefault:\n\t\tret = process_common_fetch_insn(code, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tcode++;\n\n\treturn process_fetch_insn_bottom(code, val, dest, base);\n}\nNOKPROBE_SYMBOL(process_fetch_insn)\n\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\n{\n\trwlock_init(&filter->rwlock);\n\tfilter->nr_systemwide = 0;\n\tINIT_LIST_HEAD(&filter->perf_events);\n}\n\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\n{\n\treturn !filter->nr_systemwide && list_empty(&filter->perf_events);\n}\n\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\n{\n\treturn tu->consumer.ret_handler != NULL;\n}\n\nstatic bool trace_uprobe_is_busy(struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn trace_probe_is_enabled(&tu->tp);\n}\n\nstatic bool trace_uprobe_match_command_head(struct trace_uprobe *tu,\n\t\t\t\t\t    int argc, const char **argv)\n{\n\tchar buf[MAX_ARGSTR_LEN + 1];\n\tint len;\n\n\tif (!argc)\n\t\treturn true;\n\n\tlen = strlen(tu->filename);\n\tif (strncmp(tu->filename, argv[0], len) || argv[0][len] != ':')\n\t\treturn false;\n\n\tif (tu->ref_ctr_offset == 0)\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"0x%0*lx(0x%lx)\",\n\t\t\t\t(int)(sizeof(void *) * 2), tu->offset,\n\t\t\t\ttu->ref_ctr_offset);\n\tif (strcmp(buf, &argv[0][len + 1]))\n\t\treturn false;\n\n\targc--; argv++;\n\n\treturn trace_probe_match_command_args(&tu->tp, argc, argv);\n}\n\nstatic bool trace_uprobe_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn (event[0] == '\\0' ||\n\t\tstrcmp(trace_probe_name(&tu->tp), event) == 0) &&\n\t   (!system || strcmp(trace_probe_group_name(&tu->tp), system) == 0) &&\n\t   trace_uprobe_match_command_head(tu, argc, argv);\n}\n\nstatic nokprobe_inline struct trace_uprobe *\ntrace_uprobe_primary_from_call(struct trace_event_call *call)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn NULL;\n\n\treturn container_of(tp, struct trace_uprobe, tp);\n}\n\n \nstatic struct trace_uprobe *\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\n{\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = kzalloc(struct_size(tu, tp.args, nargs), GFP_KERNEL);\n\tif (!tu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = trace_probe_init(&tu->tp, event, group, true);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdyn_event_init(&tu->devent, &trace_uprobe_ops);\n\ttu->consumer.handler = uprobe_dispatcher;\n\tif (is_ret)\n\t\ttu->consumer.ret_handler = uretprobe_dispatcher;\n\tinit_trace_uprobe_filter(tu->tp.event->filter);\n\treturn tu;\n\nerror:\n\tkfree(tu);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\n{\n\tif (!tu)\n\t\treturn;\n\n\tpath_put(&tu->path);\n\ttrace_probe_cleanup(&tu->tp);\n\tkfree(tu->filename);\n\tkfree(tu);\n}\n\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tu;\n\n\tfor_each_trace_uprobe(tu, pos)\n\t\tif (strcmp(trace_probe_name(&tu->tp), event) == 0 &&\n\t\t    strcmp(trace_probe_group_name(&tu->tp), group) == 0)\n\t\t\treturn tu;\n\n\treturn NULL;\n}\n\n \nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\n{\n\tint ret;\n\n\tif (trace_probe_has_sibling(&tu->tp))\n\t\tgoto unreg;\n\n\t \n\tif (trace_event_dyn_busy(trace_probe_event_call(&tu->tp)))\n\t\treturn -EBUSY;\n\n\tret = unregister_uprobe_event(tu);\n\tif (ret)\n\t\treturn ret;\n\nunreg:\n\tdyn_event_remove(&tu->devent);\n\ttrace_probe_unlink(&tu->tp);\n\tfree_trace_uprobe(tu);\n\treturn 0;\n}\n\nstatic bool trace_uprobe_has_same_uprobe(struct trace_uprobe *orig,\n\t\t\t\t\t struct trace_uprobe *comp)\n{\n\tstruct trace_probe_event *tpe = orig->tp.event;\n\tstruct inode *comp_inode = d_real_inode(comp->path.dentry);\n\tint i;\n\n\tlist_for_each_entry(orig, &tpe->probes, tp.list) {\n\t\tif (comp_inode != d_real_inode(orig->path.dentry) ||\n\t\t    comp->offset != orig->offset)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < orig->tp.nr_args; i++) {\n\t\t\tif (strcmp(orig->tp.args[i].comm,\n\t\t\t\t   comp->tp.args[i].comm))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == orig->tp.nr_args)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int append_trace_uprobe(struct trace_uprobe *tu, struct trace_uprobe *to)\n{\n\tint ret;\n\n\tret = trace_probe_compare_arg_type(&tu->tp, &to->tp);\n\tif (ret) {\n\t\t \n\t\ttrace_probe_log_set_index(ret + 1);\n\t\ttrace_probe_log_err(0, DIFF_ARG_TYPE);\n\t\treturn -EEXIST;\n\t}\n\tif (trace_uprobe_has_same_uprobe(to, tu)) {\n\t\ttrace_probe_log_set_index(0);\n\t\ttrace_probe_log_err(0, SAME_PROBE);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tret = trace_probe_append(&tu->tp, &to->tp);\n\tif (!ret)\n\t\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\n\treturn ret;\n}\n\n \nstatic int validate_ref_ctr_offset(struct trace_uprobe *new)\n{\n\tstruct dyn_event *pos;\n\tstruct trace_uprobe *tmp;\n\tstruct inode *new_inode = d_real_inode(new->path.dentry);\n\n\tfor_each_trace_uprobe(tmp, pos) {\n\t\tif (new_inode == d_real_inode(tmp->path.dentry) &&\n\t\t    new->offset == tmp->offset &&\n\t\t    new->ref_ctr_offset != tmp->ref_ctr_offset) {\n\t\t\tpr_warn(\"Reference counter offset mismatch.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int register_trace_uprobe(struct trace_uprobe *tu)\n{\n\tstruct trace_uprobe *old_tu;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = validate_ref_ctr_offset(tu);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\told_tu = find_probe_event(trace_probe_name(&tu->tp),\n\t\t\t\t  trace_probe_group_name(&tu->tp));\n\tif (old_tu) {\n\t\tif (is_ret_probe(tu) != is_ret_probe(old_tu)) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, DIFF_PROBE_TYPE);\n\t\t\tret = -EEXIST;\n\t\t} else {\n\t\t\tret = append_trace_uprobe(tu, old_tu);\n\t\t}\n\t\tgoto end;\n\t}\n\n\tret = register_uprobe_event(tu);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\ttrace_probe_log_set_index(0);\n\t\t\ttrace_probe_log_err(0, EVENT_EXIST);\n\t\t} else\n\t\t\tpr_warn(\"Failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\tdyn_event_add(&tu->devent, trace_probe_event_call(&tu->tp));\n\nend:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\n\n \nstatic int __trace_uprobe_create(int argc, const char **argv)\n{\n\tstruct trace_uprobe *tu;\n\tconst char *event = NULL, *group = UPROBE_EVENT_SYSTEM;\n\tchar *arg, *filename, *rctr, *rctr_end, *tmp;\n\tchar buf[MAX_EVENT_NAME_LEN];\n\tchar gbuf[MAX_EVENT_NAME_LEN];\n\tenum probe_print_type ptype;\n\tstruct path path;\n\tunsigned long offset, ref_ctr_offset;\n\tbool is_return = false;\n\tint i, ret;\n\n\tref_ctr_offset = 0;\n\n\tswitch (argv[0][0]) {\n\tcase 'r':\n\t\tis_return = true;\n\t\tbreak;\n\tcase 'p':\n\t\tbreak;\n\tdefault:\n\t\treturn -ECANCELED;\n\t}\n\n\tif (argc < 2)\n\t\treturn -ECANCELED;\n\n\tif (argv[0][1] == ':')\n\t\tevent = &argv[0][2];\n\n\tif (!strchr(argv[1], '/'))\n\t\treturn -ECANCELED;\n\n\tfilename = kstrdup(argv[1], GFP_KERNEL);\n\tif (!filename)\n\t\treturn -ENOMEM;\n\n\t \n\targ = strrchr(filename, ':');\n\tif (!arg || !isdigit(arg[1])) {\n\t\tkfree(filename);\n\t\treturn -ECANCELED;\n\t}\n\n\ttrace_probe_log_init(\"trace_uprobe\", argc, argv);\n\ttrace_probe_log_set_index(1);\t \n\n\t*arg++ = '\\0';\n\tret = kern_path(filename, LOOKUP_FOLLOW, &path);\n\tif (ret) {\n\t\ttrace_probe_log_err(0, FILE_NOT_FOUND);\n\t\tkfree(filename);\n\t\ttrace_probe_log_clear();\n\t\treturn ret;\n\t}\n\tif (!d_is_reg(path.dentry)) {\n\t\ttrace_probe_log_err(0, NO_REGULAR_FILE);\n\t\tret = -EINVAL;\n\t\tgoto fail_address_parse;\n\t}\n\n\t \n\trctr = strchr(arg, '(');\n\tif (rctr) {\n\t\trctr_end = strchr(rctr, ')');\n\t\tif (!rctr_end) {\n\t\t\tret = -EINVAL;\n\t\t\trctr_end = rctr + strlen(rctr);\n\t\t\ttrace_probe_log_err(rctr_end - filename,\n\t\t\t\t\t    REFCNT_OPEN_BRACE);\n\t\t\tgoto fail_address_parse;\n\t\t} else if (rctr_end[1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\ttrace_probe_log_err(rctr_end + 1 - filename,\n\t\t\t\t\t    BAD_REFCNT_SUFFIX);\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\t*rctr++ = '\\0';\n\t\t*rctr_end = '\\0';\n\t\tret = kstrtoul(rctr, 0, &ref_ctr_offset);\n\t\tif (ret) {\n\t\t\ttrace_probe_log_err(rctr - filename, BAD_REFCNT);\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t \n\ttmp = strchr(arg, '%');\n\tif (tmp) {\n\t\tif (!strcmp(tmp, \"%return\")) {\n\t\t\t*tmp = '\\0';\n\t\t\tis_return = true;\n\t\t} else {\n\t\t\ttrace_probe_log_err(tmp - filename, BAD_ADDR_SUFFIX);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\t}\n\n\t \n\tret = kstrtoul(arg, 0, &offset);\n\tif (ret) {\n\t\ttrace_probe_log_err(arg - filename, BAD_UPROBE_OFFS);\n\t\tgoto fail_address_parse;\n\t}\n\n\t \n\ttrace_probe_log_set_index(0);\n\tif (event) {\n\t\tret = traceprobe_parse_event_name(&event, &group, gbuf,\n\t\t\t\t\t\t  event - argv[0]);\n\t\tif (ret)\n\t\t\tgoto fail_address_parse;\n\t}\n\n\tif (!event) {\n\t\tchar *tail;\n\t\tchar *ptr;\n\n\t\ttail = kstrdup(kbasename(filename), GFP_KERNEL);\n\t\tif (!tail) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_address_parse;\n\t\t}\n\n\t\tptr = strpbrk(tail, \".-_\");\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\n\t\tsnprintf(buf, MAX_EVENT_NAME_LEN, \"%c_%s_0x%lx\", 'p', tail, offset);\n\t\tevent = buf;\n\t\tkfree(tail);\n\t}\n\n\targc -= 2;\n\targv += 2;\n\n\ttu = alloc_trace_uprobe(group, event, argc, is_return);\n\tif (IS_ERR(tu)) {\n\t\tret = PTR_ERR(tu);\n\t\t \n\t\tWARN_ON_ONCE(ret != -ENOMEM);\n\t\tgoto fail_address_parse;\n\t}\n\ttu->offset = offset;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->path = path;\n\ttu->filename = filename;\n\n\t \n\tfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\n\t\tstruct traceprobe_parse_context ctx = {\n\t\t\t.flags = (is_return ? TPARG_FL_RETURN : 0) | TPARG_FL_USER,\n\t\t};\n\n\t\ttrace_probe_log_set_index(i + 2);\n\t\tret = traceprobe_parse_probe_arg(&tu->tp, i, argv[i], &ctx);\n\t\ttraceprobe_finish_parse(&ctx);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tret = traceprobe_set_print_fmt(&tu->tp, ptype);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = register_trace_uprobe(tu);\n\tif (!ret)\n\t\tgoto out;\n\nerror:\n\tfree_trace_uprobe(tu);\nout:\n\ttrace_probe_log_clear();\n\treturn ret;\n\nfail_address_parse:\n\ttrace_probe_log_clear();\n\tpath_put(&path);\n\tkfree(filename);\n\n\treturn ret;\n}\n\nint trace_uprobe_create(const char *raw_command)\n{\n\treturn trace_probe_create(raw_command, __trace_uprobe_create);\n}\n\nstatic int create_or_delete_trace_uprobe(const char *raw_command)\n{\n\tint ret;\n\n\tif (raw_command[0] == '-')\n\t\treturn dyn_event_release(raw_command, &trace_uprobe_ops);\n\n\tret = trace_uprobe_create(raw_command);\n\treturn ret == -ECANCELED ? -EINVAL : ret;\n}\n\nstatic int trace_uprobe_release(struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\n\treturn unregister_trace_uprobe(tu);\n}\n\n \nstatic int trace_uprobe_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct trace_uprobe *tu = to_trace_uprobe(ev);\n\tchar c = is_ret_probe(tu) ? 'r' : 'p';\n\tint i;\n\n\tseq_printf(m, \"%c:%s/%s %s:0x%0*lx\", c, trace_probe_group_name(&tu->tp),\n\t\t\ttrace_probe_name(&tu->tp), tu->filename,\n\t\t\t(int)(sizeof(void *) * 2), tu->offset);\n\n\tif (tu->ref_ctr_offset)\n\t\tseq_printf(m, \"(0x%lx)\", tu->ref_ctr_offset);\n\n\tfor (i = 0; i < tu->tp.nr_args; i++)\n\t\tseq_printf(m, \" %s=%s\", tu->tp.args[i].name, tu->tp.args[i].comm);\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic int probes_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_trace_uprobe(ev))\n\t\treturn 0;\n\n\treturn trace_uprobe_show(m, ev);\n}\n\nstatic const struct seq_operations probes_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show   = probes_seq_show\n};\n\nstatic int probes_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&trace_uprobe_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t\tcreate_or_delete_trace_uprobe);\n}\n\nstatic const struct file_operations uprobe_events_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= probes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.write\t\t= probes_write,\n};\n\n \nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\tstruct trace_uprobe *tu;\n\n\tif (!is_trace_uprobe(ev))\n\t\treturn 0;\n\n\ttu = to_trace_uprobe(ev);\n\tseq_printf(m, \"  %s %-44s %15lu\\n\", tu->filename,\n\t\t\ttrace_probe_name(&tu->tp), tu->nhit);\n\treturn 0;\n}\n\nstatic const struct seq_operations profile_seq_op = {\n\t.start  = dyn_event_seq_start,\n\t.next   = dyn_event_seq_next,\n\t.stop   = dyn_event_seq_stop,\n\t.show\t= probes_profile_seq_show\n};\n\nstatic int profile_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &profile_seq_op);\n}\n\nstatic const struct file_operations uprobe_profile_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= profile_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstruct uprobe_cpu_buffer {\n\tstruct mutex mutex;\n\tvoid *buf;\n};\nstatic struct uprobe_cpu_buffer __percpu *uprobe_cpu_buffer;\nstatic int uprobe_buffer_refcnt;\n\nstatic int uprobe_buffer_init(void)\n{\n\tint cpu, err_cpu;\n\n\tuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\n\tif (uprobe_cpu_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct page *p = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\t\t  GFP_KERNEL, 0);\n\t\tif (p == NULL) {\n\t\t\terr_cpu = cpu;\n\t\t\tgoto err;\n\t\t}\n\t\tper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\n\t\tmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == err_cpu)\n\t\t\tbreak;\n\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\n\t}\n\n\tfree_percpu(uprobe_cpu_buffer);\n\treturn -ENOMEM;\n}\n\nstatic int uprobe_buffer_enable(void)\n{\n\tint ret = 0;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (uprobe_buffer_refcnt++ == 0) {\n\t\tret = uprobe_buffer_init();\n\t\tif (ret < 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tBUG_ON(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->buf);\n\n\t\tfree_percpu(uprobe_cpu_buffer);\n\t\tuprobe_cpu_buffer = NULL;\n\t}\n}\n\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\n{\n\tstruct uprobe_cpu_buffer *ucb;\n\tint cpu;\n\n\tcpu = raw_smp_processor_id();\n\tucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\n\n\t \n\tmutex_lock(&ucb->mutex);\n\n\treturn ucb;\n}\n\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\n{\n\tmutex_unlock(&ucb->mutex);\n}\n\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\n\t\t\t\tunsigned long func, struct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize,\n\t\t\t\tstruct trace_event_file *trace_file)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_event_buffer fbuffer;\n\tvoid *data;\n\tint size, esize;\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\n\tWARN_ON(call != trace_file->event_call);\n\n\tif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\n\t\treturn;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\tsize = esize + tu->tp.size + dsize;\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file, size);\n\tif (!entry)\n\t\treturn;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\ttrace_event_buffer_commit(&fbuffer);\n}\n\n \nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t     struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\tif (is_ret_probe(tu))\n\t\treturn 0;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct event_file_link *link;\n\n\trcu_read_lock();\n\ttrace_probe_for_each_link_rcu(link, &tu->tp)\n\t\t__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\n\trcu_read_unlock();\n}\n\n \nstatic enum print_line_t\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\n{\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_uprobe *tu;\n\tu8 *data;\n\n\tentry = (struct uprobe_trace_entry_head *)iter->ent;\n\ttu = trace_uprobe_primary_from_call(\n\t\tcontainer_of(event, struct trace_event_call, event));\n\tif (unlikely(!tu))\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx <- 0x%lx)\",\n\t\t\t\t trace_probe_name(&tu->tp),\n\t\t\t\t entry->vaddr[1], entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\ttrace_seq_printf(s, \"%s: (0x%lx)\",\n\t\t\t\t trace_probe_name(&tu->tp),\n\t\t\t\t entry->vaddr[0]);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tif (trace_probe_print_args(s, tu->tp.args, tu->tp.nr_args, data, entry) < 0)\n\t\tgoto out;\n\n\ttrace_seq_putc(s, '\\n');\n\n out:\n\treturn trace_handle_return(s);\n}\n\ntypedef bool (*filter_func_t)(struct uprobe_consumer *self,\n\t\t\t\tenum uprobe_filter_ctx ctx,\n\t\t\t\tstruct mm_struct *mm);\n\nstatic int trace_uprobe_enable(struct trace_uprobe *tu, filter_func_t filter)\n{\n\tint ret;\n\n\ttu->consumer.filter = filter;\n\ttu->inode = d_real_inode(tu->path.dentry);\n\n\tif (tu->ref_ctr_offset)\n\t\tret = uprobe_register_refctr(tu->inode, tu->offset,\n\t\t\t\ttu->ref_ctr_offset, &tu->consumer);\n\telse\n\t\tret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\n\n\tif (ret)\n\t\ttu->inode = NULL;\n\n\treturn ret;\n}\n\nstatic void __probe_event_disable(struct trace_probe *tp)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tif (!tu->inode)\n\t\t\tcontinue;\n\n\t\tuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\n\t\ttu->inode = NULL;\n\t}\n}\n\nstatic int probe_event_enable(struct trace_event_call *call,\n\t\t\tstruct trace_event_file *file, filter_func_t filter)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tbool enabled;\n\tint ret;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\tenabled = trace_probe_is_enabled(tp);\n\n\t \n\tif (file) {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_PROFILE))\n\t\t\treturn -EINTR;\n\n\t\tret = trace_probe_add_file(tp, file);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tif (trace_probe_test_flag(tp, TP_FLAG_TRACE))\n\t\t\treturn -EINTR;\n\n\t\ttrace_probe_set_flag(tp, TP_FLAG_PROFILE);\n\t}\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tWARN_ON(!uprobe_filter_is_empty(tu->tp.event->filter));\n\n\tif (enabled)\n\t\treturn 0;\n\n\tret = uprobe_buffer_enable();\n\tif (ret)\n\t\tgoto err_flags;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = trace_uprobe_enable(tu, filter);\n\t\tif (ret) {\n\t\t\t__probe_event_disable(tp);\n\t\t\tgoto err_buffer;\n\t\t}\n\t}\n\n\treturn 0;\n\n err_buffer:\n\tuprobe_buffer_disable();\n\n err_flags:\n\tif (file)\n\t\ttrace_probe_remove_file(tp, file);\n\telse\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\treturn ret;\n}\n\nstatic void probe_event_disable(struct trace_event_call *call,\n\t\t\t\tstruct trace_event_file *file)\n{\n\tstruct trace_probe *tp;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn;\n\n\tif (!trace_probe_is_enabled(tp))\n\t\treturn;\n\n\tif (file) {\n\t\tif (trace_probe_remove_file(tp, file) < 0)\n\t\t\treturn;\n\n\t\tif (trace_probe_is_enabled(tp))\n\t\t\treturn;\n\t} else\n\t\ttrace_probe_clear_flag(tp, TP_FLAG_PROFILE);\n\n\t__probe_event_disable(tp);\n\tuprobe_buffer_disable();\n}\n\nstatic int uprobe_event_define_fields(struct trace_event_call *event_call)\n{\n\tint ret, size;\n\tstruct uprobe_trace_entry_head field;\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\tif (unlikely(!tu))\n\t\treturn -ENODEV;\n\n\tif (is_ret_probe(tu)) {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\n\t\tDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(true);\n\t} else {\n\t\tDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\n\t\tsize = SIZEOF_TRACE_ENTRY(false);\n\t}\n\n\treturn traceprobe_define_arg_fields(event_call, size, &tu->tp);\n}\n\n#ifdef CONFIG_PERF_EVENTS\nstatic bool\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\n{\n\tstruct perf_event *event;\n\n\tif (filter->nr_systemwide)\n\t\treturn true;\n\n\tlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\n\t\tif (event->hw.target->mm == mm)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline bool\ntrace_uprobe_filter_event(struct trace_uprobe_filter *filter,\n\t\t\t  struct perf_event *event)\n{\n\treturn __uprobe_perf_filter(filter, event->hw.target->mm);\n}\n\nstatic bool trace_uprobe_filter_remove(struct trace_uprobe_filter *filter,\n\t\t\t\t       struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\tlist_del(&event->hw.tp_list);\n\t\tdone = filter->nr_systemwide ||\n\t\t\t(event->hw.target->flags & PF_EXITING) ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t} else {\n\t\tfilter->nr_systemwide--;\n\t\tdone = filter->nr_systemwide;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}\n\n \nstatic bool trace_uprobe_filter_add(struct trace_uprobe_filter *filter,\n\t\t\t\t    struct perf_event *event)\n{\n\tbool done;\n\n\twrite_lock(&filter->rwlock);\n\tif (event->hw.target) {\n\t\t \n\t\tdone = filter->nr_systemwide ||\n\t\t\tevent->parent || event->attr.enable_on_exec ||\n\t\t\ttrace_uprobe_filter_event(filter, event);\n\t\tlist_add(&event->hw.tp_list, &filter->perf_events);\n\t} else {\n\t\tdone = filter->nr_systemwide;\n\t\tfilter->nr_systemwide++;\n\t}\n\twrite_unlock(&filter->rwlock);\n\n\treturn done;\n}\n\nstatic int uprobe_perf_close(struct trace_event_call *call,\n\t\t\t     struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint ret = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_remove(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\tret = uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int uprobe_perf_open(struct trace_event_call *call,\n\t\t\t    struct perf_event *event)\n{\n\tstruct trace_probe *tp;\n\tstruct trace_uprobe *tu;\n\tint err = 0;\n\n\ttp = trace_probe_primary_from_call(call);\n\tif (WARN_ON_ONCE(!tp))\n\t\treturn -ENODEV;\n\n\ttu = container_of(tp, struct trace_uprobe, tp);\n\tif (trace_uprobe_filter_add(tu->tp.event->filter, event))\n\t\treturn 0;\n\n\tlist_for_each_entry(tu, trace_probe_probe_list(tp), tp.list) {\n\t\terr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\n\t\tif (err) {\n\t\t\tuprobe_perf_close(call, event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\n\t\t\t\tenum uprobe_filter_ctx ctx, struct mm_struct *mm)\n{\n\tstruct trace_uprobe_filter *filter;\n\tstruct trace_uprobe *tu;\n\tint ret;\n\n\ttu = container_of(uc, struct trace_uprobe, consumer);\n\tfilter = tu->tp.event->filter;\n\n\tread_lock(&filter->rwlock);\n\tret = __uprobe_perf_filter(filter, mm);\n\tread_unlock(&filter->rwlock);\n\n\treturn ret;\n}\n\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\n\t\t\t       unsigned long func, struct pt_regs *regs,\n\t\t\t       struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tstruct uprobe_trace_entry_head *entry;\n\tstruct hlist_head *head;\n\tvoid *data;\n\tint size, esize;\n\tint rctx;\n\n#ifdef CONFIG_BPF_EVENTS\n\tif (bpf_prog_array_valid(call)) {\n\t\tu32 ret;\n\n\t\tret = bpf_prog_run_array_uprobe(call->prog_array, regs, bpf_prog_run);\n\t\tif (!ret)\n\t\t\treturn;\n\t}\n#endif  \n\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tsize = esize + tu->tp.size + dsize;\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, \"profile buffer not large enough\"))\n\t\treturn;\n\n\tpreempt_disable();\n\thead = this_cpu_ptr(call->perf_events);\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tentry = perf_trace_buf_alloc(size, NULL, &rctx);\n\tif (!entry)\n\t\tgoto out;\n\n\tif (is_ret_probe(tu)) {\n\t\tentry->vaddr[0] = func;\n\t\tentry->vaddr[1] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, true);\n\t} else {\n\t\tentry->vaddr[0] = instruction_pointer(regs);\n\t\tdata = DATAOF_TRACE_ENTRY(entry, false);\n\t}\n\n\tmemcpy(data, ucb->buf, tu->tp.size + dsize);\n\n\tif (size - esize > tu->tp.size + dsize) {\n\t\tint len = tu->tp.size + dsize;\n\n\t\tmemset(data + len, 0, size - esize - len);\n\t}\n\n\tperf_trace_buf_submit(entry, size, rctx, call->event.type, 1, regs,\n\t\t\t      head, NULL);\n out:\n\tpreempt_enable();\n}\n\n \nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\n\t\t\t    struct uprobe_cpu_buffer *ucb, int dsize)\n{\n\tif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\n\t\treturn UPROBE_HANDLER_REMOVE;\n\n\tif (!is_ret_probe(tu))\n\t\t__uprobe_perf_func(tu, 0, regs, ucb, dsize);\n\treturn 0;\n}\n\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\n\t\t\t\tstruct pt_regs *regs,\n\t\t\t\tstruct uprobe_cpu_buffer *ucb, int dsize)\n{\n\t__uprobe_perf_func(tu, func, regs, ucb, dsize);\n}\n\nint bpf_get_uprobe_info(const struct perf_event *event, u32 *fd_type,\n\t\t\tconst char **filename, u64 *probe_offset,\n\t\t\tu64 *probe_addr, bool perf_type_tracepoint)\n{\n\tconst char *pevent = trace_event_name(event->tp_event);\n\tconst char *group = event->tp_event->class->system;\n\tstruct trace_uprobe *tu;\n\n\tif (perf_type_tracepoint)\n\t\ttu = find_probe_event(pevent, group);\n\telse\n\t\ttu = trace_uprobe_primary_from_call(event->tp_event);\n\tif (!tu)\n\t\treturn -EINVAL;\n\n\t*fd_type = is_ret_probe(tu) ? BPF_FD_TYPE_URETPROBE\n\t\t\t\t    : BPF_FD_TYPE_UPROBE;\n\t*filename = tu->filename;\n\t*probe_offset = tu->offset;\n\t*probe_addr = 0;\n\treturn 0;\n}\n#endif\t \n\nstatic int\ntrace_uprobe_register(struct trace_event_call *event, enum trace_reg type,\n\t\t      void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn probe_event_enable(event, file, NULL);\n\n\tcase TRACE_REG_UNREGISTER:\n\t\tprobe_event_disable(event, file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn probe_event_enable(event, NULL, uprobe_perf_filter);\n\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\tprobe_event_disable(event, NULL);\n\t\treturn 0;\n\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn uprobe_perf_open(event, data);\n\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn uprobe_perf_close(event, data);\n\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\tint ret = 0;\n\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\ttu->nhit++;\n\n\tudd.tu = tu;\n\tudd.bp_addr = instruction_pointer(regs);\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))\n\t\tret |= uprobe_trace_func(tu, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))\n\t\tret |= uprobe_perf_func(tu, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn ret;\n}\n\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\n\t\t\t\tunsigned long func, struct pt_regs *regs)\n{\n\tstruct trace_uprobe *tu;\n\tstruct uprobe_dispatch_data udd;\n\tstruct uprobe_cpu_buffer *ucb;\n\tint dsize, esize;\n\n\ttu = container_of(con, struct trace_uprobe, consumer);\n\n\tudd.tu = tu;\n\tudd.bp_addr = func;\n\n\tcurrent->utask->vaddr = (unsigned long) &udd;\n\n\tif (WARN_ON_ONCE(!uprobe_cpu_buffer))\n\t\treturn 0;\n\n\tdsize = __get_data_size(&tu->tp, regs);\n\tesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\n\n\tucb = uprobe_buffer_get();\n\tstore_trace_args(ucb->buf, &tu->tp, regs, esize, dsize);\n\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_TRACE))\n\t\turetprobe_trace_func(tu, func, regs, ucb, dsize);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (trace_probe_test_flag(&tu->tp, TP_FLAG_PROFILE))\n\t\turetprobe_perf_func(tu, func, regs, ucb, dsize);\n#endif\n\tuprobe_buffer_put(ucb);\n\treturn 0;\n}\n\nstatic struct trace_event_functions uprobe_funcs = {\n\t.trace\t\t= print_uprobe_event\n};\n\nstatic struct trace_event_fields uprobe_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = uprobe_event_define_fields },\n\t{}\n};\n\nstatic inline void init_trace_event_call(struct trace_uprobe *tu)\n{\n\tstruct trace_event_call *call = trace_probe_event_call(&tu->tp);\n\tcall->event.funcs = &uprobe_funcs;\n\tcall->class->fields_array = uprobe_fields_array;\n\n\tcall->flags = TRACE_EVENT_FL_UPROBE | TRACE_EVENT_FL_CAP_ANY;\n\tcall->class->reg = trace_uprobe_register;\n}\n\nstatic int register_uprobe_event(struct trace_uprobe *tu)\n{\n\tinit_trace_event_call(tu);\n\n\treturn trace_probe_register_event_call(&tu->tp);\n}\n\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\n{\n\treturn trace_probe_unregister_event_call(&tu->tp);\n}\n\n#ifdef CONFIG_PERF_EVENTS\nstruct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tenum probe_print_type ptype;\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tif (!tu->filename) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinit_trace_event_call(tu);\n\n\tptype = is_ret_probe(tu) ? PROBE_PRINT_RETURN : PROBE_PRINT_NORMAL;\n\tif (traceprobe_set_print_fmt(&tu->tp, ptype) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn trace_probe_event_call(&tu->tp);\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = trace_uprobe_primary_from_call(event_call);\n\n\tfree_trace_uprobe(tu);\n}\n#endif  \n\n \nstatic __init int init_uprobe_trace(void)\n{\n\tint ret;\n\n\tret = dyn_event_register(&trace_uprobe_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"uprobe_events\", TRACE_MODE_WRITE, NULL,\n\t\t\t\t    NULL, &uprobe_events_ops);\n\t \n\ttrace_create_file(\"uprobe_profile\", TRACE_MODE_READ, NULL,\n\t\t\t\t    NULL, &uprobe_profile_ops);\n\treturn 0;\n}\n\nfs_initcall(init_uprobe_trace);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}