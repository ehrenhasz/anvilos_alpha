{
  "module_name": "rethook.c",
  "hash_id": "472ba69dfd388f4985ceb5b66bc43985793f7c764ee4c200a445bdfbcee58ee6",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/rethook.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"rethook: \" fmt\n\n#include <linux/bug.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/preempt.h>\n#include <linux/rethook.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n \n\n \nvoid rethook_flush_task(struct task_struct *tk)\n{\n\tstruct rethook_node *rhn;\n\tstruct llist_node *node;\n\n\tnode = __llist_del_all(&tk->rethooks);\n\twhile (node) {\n\t\trhn = container_of(node, struct rethook_node, llist);\n\t\tnode = node->next;\n\t\tpreempt_disable();\n\t\trethook_recycle(rhn);\n\t\tpreempt_enable();\n\t}\n}\n\nstatic void rethook_free_rcu(struct rcu_head *head)\n{\n\tstruct rethook *rh = container_of(head, struct rethook, rcu);\n\tstruct rethook_node *rhn;\n\tstruct freelist_node *node;\n\tint count = 1;\n\n\tnode = rh->pool.head;\n\twhile (node) {\n\t\trhn = container_of(node, struct rethook_node, freelist);\n\t\tnode = node->next;\n\t\tkfree(rhn);\n\t\tcount++;\n\t}\n\n\t \n\tif (refcount_sub_and_test(count, &rh->ref))\n\t\tkfree(rh);\n}\n\n \nvoid rethook_stop(struct rethook *rh)\n{\n\trcu_assign_pointer(rh->handler, NULL);\n}\n\n \nvoid rethook_free(struct rethook *rh)\n{\n\trethook_stop(rh);\n\n\tcall_rcu(&rh->rcu, rethook_free_rcu);\n}\n\nstatic inline rethook_handler_t rethook_get_handler(struct rethook *rh)\n{\n\treturn (rethook_handler_t)rcu_dereference_check(rh->handler,\n\t\t\t\t\t\t\trcu_read_lock_any_held());\n}\n\n \nstruct rethook *rethook_alloc(void *data, rethook_handler_t handler)\n{\n\tstruct rethook *rh = kzalloc(sizeof(struct rethook), GFP_KERNEL);\n\n\tif (!rh || !handler) {\n\t\tkfree(rh);\n\t\treturn NULL;\n\t}\n\n\trh->data = data;\n\trcu_assign_pointer(rh->handler, handler);\n\trh->pool.head = NULL;\n\trefcount_set(&rh->ref, 1);\n\n\treturn rh;\n}\n\n \nvoid rethook_add_node(struct rethook *rh, struct rethook_node *node)\n{\n\tnode->rethook = rh;\n\tfreelist_add(&node->freelist, &rh->pool);\n\trefcount_inc(&rh->ref);\n}\n\nstatic void free_rethook_node_rcu(struct rcu_head *head)\n{\n\tstruct rethook_node *node = container_of(head, struct rethook_node, rcu);\n\n\tif (refcount_dec_and_test(&node->rethook->ref))\n\t\tkfree(node->rethook);\n\tkfree(node);\n}\n\n \nvoid rethook_recycle(struct rethook_node *node)\n{\n\trethook_handler_t handler;\n\n\thandler = rethook_get_handler(node->rethook);\n\tif (likely(handler))\n\t\tfreelist_add(&node->freelist, &node->rethook->pool);\n\telse\n\t\tcall_rcu(&node->rcu, free_rethook_node_rcu);\n}\nNOKPROBE_SYMBOL(rethook_recycle);\n\n \nstruct rethook_node *rethook_try_get(struct rethook *rh)\n{\n\trethook_handler_t handler = rethook_get_handler(rh);\n\tstruct freelist_node *fn;\n\n\t \n\tif (unlikely(!handler))\n\t\treturn NULL;\n\n\t \n\tif (unlikely(!rcu_is_watching()))\n\t\treturn NULL;\n\n\tfn = freelist_try_get(&rh->pool);\n\tif (!fn)\n\t\treturn NULL;\n\n\treturn container_of(fn, struct rethook_node, freelist);\n}\nNOKPROBE_SYMBOL(rethook_try_get);\n\n \nvoid rethook_hook(struct rethook_node *node, struct pt_regs *regs, bool mcount)\n{\n\tarch_rethook_prepare(node, regs, mcount);\n\t__llist_add(&node->llist, &current->rethooks);\n}\nNOKPROBE_SYMBOL(rethook_hook);\n\n \nstatic unsigned long __rethook_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t     struct llist_node **cur)\n{\n\tstruct rethook_node *rh = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->rethooks.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\trh = container_of(node, struct rethook_node, llist);\n\t\tif (rh->ret_addr != (unsigned long)arch_rethook_trampoline) {\n\t\t\t*cur = node;\n\t\t\treturn rh->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn 0;\n}\nNOKPROBE_SYMBOL(__rethook_find_ret_addr);\n\n \nunsigned long rethook_find_ret_addr(struct task_struct *tsk, unsigned long frame,\n\t\t\t\t    struct llist_node **cur)\n{\n\tstruct rethook_node *rhn = NULL;\n\tunsigned long ret;\n\n\tif (WARN_ON_ONCE(!cur))\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(tsk != current && task_is_running(tsk)))\n\t\treturn 0;\n\n\tdo {\n\t\tret = __rethook_find_ret_addr(tsk, cur);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\trhn = container_of(*cur, struct rethook_node, llist);\n\t} while (rhn->frame != frame);\n\n\treturn ret;\n}\nNOKPROBE_SYMBOL(rethook_find_ret_addr);\n\nvoid __weak arch_rethook_fixup_return(struct pt_regs *regs,\n\t\t\t\t      unsigned long correct_ret_addr)\n{\n\t \n}\n\n \nunsigned long rethook_trampoline_handler(struct pt_regs *regs,\n\t\t\t\t\t unsigned long frame)\n{\n\tstruct llist_node *first, *node = NULL;\n\tunsigned long correct_ret_addr;\n\trethook_handler_t handler;\n\tstruct rethook_node *rhn;\n\n\tcorrect_ret_addr = __rethook_find_ret_addr(current, &node);\n\tif (!correct_ret_addr) {\n\t\tpr_err(\"rethook: Return address not found! Maybe there is a bug in the kernel\\n\");\n\t\tBUG_ON(1);\n\t}\n\n\tinstruction_pointer_set(regs, correct_ret_addr);\n\n\t \n\tpreempt_disable_notrace();\n\n\t \n\tfirst = current->rethooks.first;\n\twhile (first) {\n\t\trhn = container_of(first, struct rethook_node, llist);\n\t\tif (WARN_ON_ONCE(rhn->frame != frame))\n\t\t\tbreak;\n\t\thandler = rethook_get_handler(rhn->rethook);\n\t\tif (handler)\n\t\t\thandler(rhn, rhn->rethook->data,\n\t\t\t\tcorrect_ret_addr, regs);\n\n\t\tif (first == node)\n\t\t\tbreak;\n\t\tfirst = first->next;\n\t}\n\n\t \n\tarch_rethook_fixup_return(regs, correct_ret_addr);\n\n\t \n\tfirst = current->rethooks.first;\n\tcurrent->rethooks.first = node->next;\n\tnode->next = NULL;\n\n\twhile (first) {\n\t\trhn = container_of(first, struct rethook_node, llist);\n\t\tfirst = first->next;\n\t\trethook_recycle(rhn);\n\t}\n\tpreempt_enable_notrace();\n\n\treturn correct_ret_addr;\n}\nNOKPROBE_SYMBOL(rethook_trampoline_handler);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}