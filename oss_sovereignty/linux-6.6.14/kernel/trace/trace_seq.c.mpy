{
  "module_name": "trace_seq.c",
  "hash_id": "e0030aa5616100331e077d7a42d23e73bc4c512074c88e25ef3cab358fe055ca",
  "original_prompt": "Ingested from linux-6.6.14/kernel/trace/trace_seq.c",
  "human_readable_source": "\n \n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/trace_seq.h>\n\n \n#define TRACE_SEQ_BUF_LEFT(s) seq_buf_buffer_left(&(s)->seq)\n\n \nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}\n\n \nint trace_print_seq(struct seq_file *m, struct trace_seq *s)\n{\n\tint ret;\n\n\t__trace_seq_init(s);\n\n\tret = seq_buf_print_seq(m, &s->seq);\n\n\t \n\tif (!ret)\n\t\ttrace_seq_init(s);\n\n\treturn ret;\n}\n\n \nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t \n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}\nEXPORT_SYMBOL_GPL(trace_seq_printf);\n\n \nvoid trace_seq_bitmask(struct trace_seq *s, const unsigned long *maskp,\n\t\t      int nmaskbits)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_printf(&s->seq, \"%*pb\", nmaskbits, maskp);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}\nEXPORT_SYMBOL_GPL(trace_seq_bitmask);\n\n \nvoid trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t \n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}\nEXPORT_SYMBOL_GPL(trace_seq_vprintf);\n\n \nvoid trace_seq_bprintf(struct trace_seq *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_bprintf(&s->seq, fmt, binary);\n\n\t \n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(trace_seq_bprintf);\n\n \nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}\nEXPORT_SYMBOL_GPL(trace_seq_puts);\n\n \nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}\nEXPORT_SYMBOL_GPL(trace_seq_putc);\n\n \nvoid trace_seq_putmem(struct trace_seq *s, const void *mem, unsigned int len)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, mem, len);\n}\nEXPORT_SYMBOL_GPL(trace_seq_putmem);\n\n \nvoid trace_seq_putmem_hex(struct trace_seq *s, const void *mem,\n\t\t\t unsigned int len)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\t \n\tif (len * 2 > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\t \n\tseq_buf_putmem_hex(&s->seq, mem, len);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn;\n\t}\n}\nEXPORT_SYMBOL_GPL(trace_seq_putmem_hex);\n\n \nint trace_seq_path(struct trace_seq *s, const struct path *path)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn 0;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\tseq_buf_path(&s->seq, path, \"\\n\");\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(trace_seq_path);\n\n \nint trace_seq_to_user(struct trace_seq *s, char __user *ubuf, int cnt)\n{\n\t__trace_seq_init(s);\n\treturn seq_buf_to_user(&s->seq, ubuf, cnt);\n}\nEXPORT_SYMBOL_GPL(trace_seq_to_user);\n\nint trace_seq_hex_dump(struct trace_seq *s, const char *prefix_str,\n\t\t       int prefix_type, int rowsize, int groupsize,\n\t\t       const void *buf, size_t len, bool ascii)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn 0;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\tseq_buf_hex_dump(&(s->seq), prefix_str,\n\t\t   prefix_type, rowsize, groupsize,\n\t\t   buf, len, ascii);\n\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL(trace_seq_hex_dump);\n\n \nchar *trace_seq_acquire(struct trace_seq *s, unsigned int len)\n{\n\tchar *ret = trace_seq_buffer_ptr(s);\n\n\tif (!WARN_ON_ONCE(seq_buf_buffer_left(&s->seq) < len))\n\t\tseq_buf_commit(&s->seq, len);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(trace_seq_acquire);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}