{
  "module_name": "params.c",
  "hash_id": "1a3ba9b4e40ccaca68934312fdef338e568e64e6c6a3b81cc7a9ecda3f1fd253",
  "original_prompt": "Ingested from linux-6.6.14/kernel/params.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n\n#ifdef CONFIG_SYSFS\n \nstatic DEFINE_MUTEX(param_lock);\n\n \n#ifdef CONFIG_MODULES\n#define KPARAM_MUTEX(mod)\t((mod) ? &(mod)->param_lock : &param_lock)\n#else\n#define KPARAM_MUTEX(mod)\t(&param_lock)\n#endif\n\nstatic inline void check_kparam_locked(struct module *mod)\n{\n\tBUG_ON(!mutex_is_locked(KPARAM_MUTEX(mod)));\n}\n#else\nstatic inline void check_kparam_locked(struct module *mod)\n{\n}\n#endif  \n\n \nstruct kmalloced_param {\n\tstruct list_head list;\n\tchar val[];\n};\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void *kmalloc_parameter(unsigned int size)\n{\n\tstruct kmalloced_param *p;\n\n\tp = kmalloc(sizeof(*p) + size, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_add(&p->list, &kmalloced_params);\n\tspin_unlock(&kmalloced_params_lock);\n\n\treturn p->val;\n}\n\n \nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}\n\nstatic char dash2underscore(char c)\n{\n\tif (c == '-')\n\t\treturn '_';\n\treturn c;\n}\n\nbool parameqn(const char *a, const char *b, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}\n\nstatic bool param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->flags & KERNEL_PARAM_FL_HWPARAM &&\n\t    security_locked_down(LOCKDOWN_MODULE_PARAMETERS))\n\t\treturn false;\n\n\tif (kp->flags & KERNEL_PARAM_FL_UNSAFE) {\n\t\tpr_notice(\"Setting dangerous option %s - tainting kernel\\n\",\n\t\t\t  kp->name);\n\t\tadd_taint(TAINT_USER, LOCKDEP_STILL_OK);\n\t}\n\n\treturn true;\n}\n\nstatic int parse_one(char *param,\n\t\t     char *val,\n\t\t     const char *doing,\n\t\t     const struct kernel_param *params,\n\t\t     unsigned num_params,\n\t\t     s16 min_level,\n\t\t     s16 max_level,\n\t\t     void *arg,\n\t\t     int (*handle_unknown)(char *param, char *val,\n\t\t\t\t     const char *doing, void *arg))\n{\n\tunsigned int i;\n\tint err;\n\n\t \n\tfor (i = 0; i < num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level > max_level)\n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tif (!val &&\n\t\t\t    !(params[i].ops->flags & KERNEL_PARAM_OPS_FL_NOARG))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"handling %s with %p\\n\", param,\n\t\t\t\tparams[i].ops->set);\n\t\t\tkernel_param_lock(params[i].mod);\n\t\t\tif (param_check_unsafe(&params[i]))\n\t\t\t\terr = params[i].ops->set(val, &params[i]);\n\t\t\telse\n\t\t\t\terr = -EPERM;\n\t\t\tkernel_param_unlock(params[i].mod);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (handle_unknown) {\n\t\tpr_debug(\"doing %s: %s='%s'\\n\", doing, param, val);\n\t\treturn handle_unknown(param, val, doing, arg);\n\t}\n\n\tpr_debug(\"Unknown argument '%s'\\n\", param);\n\treturn -ENOENT;\n}\n\n \nchar *parse_args(const char *doing,\n\t\t char *args,\n\t\t const struct kernel_param *params,\n\t\t unsigned num,\n\t\t s16 min_level,\n\t\t s16 max_level,\n\t\t void *arg,\n\t\t int (*unknown)(char *param, char *val,\n\t\t\t\tconst char *doing, void *arg))\n{\n\tchar *param, *val, *err = NULL;\n\n\t \n\targs = skip_spaces(args);\n\n\tif (*args)\n\t\tpr_debug(\"doing %s, parsing ARGS: '%s'\\n\", doing, args);\n\n\twhile (*args) {\n\t\tint ret;\n\t\tint irq_was_disabled;\n\n\t\targs = next_arg(args, &param, &val);\n\t\t \n\t\tif (!val && strcmp(param, \"--\") == 0)\n\t\t\treturn err ?: args;\n\t\tirq_was_disabled = irqs_disabled();\n\t\tret = parse_one(param, val, doing, params, num,\n\t\t\t\tmin_level, max_level, arg, unknown);\n\t\tif (irq_was_disabled && !irqs_disabled())\n\t\t\tpr_warn(\"%s: option '%s' enabled irq's!\\n\",\n\t\t\t\tdoing, param);\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tcontinue;\n\t\tcase -ENOENT:\n\t\t\tpr_err(\"%s: Unknown parameter `%s'\\n\", doing, param);\n\t\t\tbreak;\n\t\tcase -ENOSPC:\n\t\t\tpr_err(\"%s: `%s' too large for parameter `%s'\\n\",\n\t\t\t       doing, val ?: \"\", param);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%s: `%s' invalid for parameter `%s'\\n\",\n\t\t\t       doing, val ?: \"\", param);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ERR_PTR(ret);\n\t}\n\n\treturn err;\n}\n\n \n#define STANDARD_PARAM_DEF(name, type, format, strtolfn)      \t\t\\\n\tint param_set_##name(const char *val, const struct kernel_param *kp) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn strtolfn(val, 0, (type *)kp->arg);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tint param_get_##name(char *buffer, const struct kernel_param *kp) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn scnprintf(buffer, PAGE_SIZE, format \"\\n\",\t\\\n\t\t\t\t*((type *)kp->arg));\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tconst struct kernel_param_ops param_ops_##name = {\t\t\t\\\n\t\t.set = param_set_##name,\t\t\t\t\\\n\t\t.get = param_get_##name,\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tEXPORT_SYMBOL(param_set_##name);\t\t\t\t\\\n\tEXPORT_SYMBOL(param_get_##name);\t\t\t\t\\\n\tEXPORT_SYMBOL(param_ops_##name)\n\n\nSTANDARD_PARAM_DEF(byte,\tunsigned char,\t\t\"%hhu\",\t\tkstrtou8);\nSTANDARD_PARAM_DEF(short,\tshort,\t\t\t\"%hi\",\t\tkstrtos16);\nSTANDARD_PARAM_DEF(ushort,\tunsigned short,\t\t\"%hu\",\t\tkstrtou16);\nSTANDARD_PARAM_DEF(int,\t\tint,\t\t\t\"%i\",\t\tkstrtoint);\nSTANDARD_PARAM_DEF(uint,\tunsigned int,\t\t\"%u\",\t\tkstrtouint);\nSTANDARD_PARAM_DEF(long,\tlong,\t\t\t\"%li\",\t\tkstrtol);\nSTANDARD_PARAM_DEF(ulong,\tunsigned long,\t\t\"%lu\",\t\tkstrtoul);\nSTANDARD_PARAM_DEF(ullong,\tunsigned long long,\t\"%llu\",\t\tkstrtoull);\nSTANDARD_PARAM_DEF(hexint,\tunsigned int,\t\t\"%#08x\", \tkstrtouint);\n\nint param_set_uint_minmax(const char *val, const struct kernel_param *kp,\n\t\tunsigned int min, unsigned int max)\n{\n\tunsigned int num;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\tret = kstrtouint(val, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\tif (num < min || num > max)\n\t\treturn -EINVAL;\n\t*((unsigned int *)kp->arg) = num;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(param_set_uint_minmax);\n\nint param_set_charp(const char *val, const struct kernel_param *kp)\n{\n\tif (strlen(val) > 1024) {\n\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);\n\t\treturn -ENOSPC;\n\t}\n\n\tmaybe_kfree_parameter(*(char **)kp->arg);\n\n\t \n\tif (slab_is_available()) {\n\t\t*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);\n\t\tif (!*(char **)kp->arg)\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(*(char **)kp->arg, val);\n\t} else\n\t\t*(const char **)kp->arg = val;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(param_set_charp);\n\nint param_get_charp(char *buffer, const struct kernel_param *kp)\n{\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", *((char **)kp->arg));\n}\nEXPORT_SYMBOL(param_get_charp);\n\nvoid param_free_charp(void *arg)\n{\n\tmaybe_kfree_parameter(*((char **)arg));\n}\nEXPORT_SYMBOL(param_free_charp);\n\nconst struct kernel_param_ops param_ops_charp = {\n\t.set = param_set_charp,\n\t.get = param_get_charp,\n\t.free = param_free_charp,\n};\nEXPORT_SYMBOL(param_ops_charp);\n\n \nint param_set_bool(const char *val, const struct kernel_param *kp)\n{\n\t \n\tif (!val) val = \"1\";\n\n\t \n\treturn kstrtobool(val, kp->arg);\n}\nEXPORT_SYMBOL(param_set_bool);\n\nint param_get_bool(char *buffer, const struct kernel_param *kp)\n{\n\t \n\treturn sprintf(buffer, \"%c\\n\", *(bool *)kp->arg ? 'Y' : 'N');\n}\nEXPORT_SYMBOL(param_get_bool);\n\nconst struct kernel_param_ops param_ops_bool = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_bool,\n\t.get = param_get_bool,\n};\nEXPORT_SYMBOL(param_ops_bool);\n\nint param_set_bool_enable_only(const char *val, const struct kernel_param *kp)\n{\n\tint err;\n\tbool new_value;\n\tbool orig_value = *(bool *)kp->arg;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &new_value;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!new_value && orig_value)\n\t\treturn -EROFS;\n\n\tif (new_value)\n\t\terr = param_set_bool(val, kp);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(param_set_bool_enable_only);\n\nconst struct kernel_param_ops param_ops_bool_enable_only = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_bool_enable_only,\n\t.get = param_get_bool,\n};\nEXPORT_SYMBOL_GPL(param_ops_bool_enable_only);\n\n \nint param_set_invbool(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tbool boolval;\n\tstruct kernel_param dummy;\n\n\tdummy.arg = &boolval;\n\tret = param_set_bool(val, &dummy);\n\tif (ret == 0)\n\t\t*(bool *)kp->arg = !boolval;\n\treturn ret;\n}\nEXPORT_SYMBOL(param_set_invbool);\n\nint param_get_invbool(char *buffer, const struct kernel_param *kp)\n{\n\treturn sprintf(buffer, \"%c\\n\", (*(bool *)kp->arg) ? 'N' : 'Y');\n}\nEXPORT_SYMBOL(param_get_invbool);\n\nconst struct kernel_param_ops param_ops_invbool = {\n\t.set = param_set_invbool,\n\t.get = param_get_invbool,\n};\nEXPORT_SYMBOL(param_ops_invbool);\n\nint param_set_bint(const char *val, const struct kernel_param *kp)\n{\n\t \n\tstruct kernel_param boolkp = *kp;\n\tbool v;\n\tint ret;\n\n\tboolkp.arg = &v;\n\n\tret = param_set_bool(val, &boolkp);\n\tif (ret == 0)\n\t\t*(int *)kp->arg = v;\n\treturn ret;\n}\nEXPORT_SYMBOL(param_set_bint);\n\nconst struct kernel_param_ops param_ops_bint = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_bint,\n\t.get = param_get_int,\n};\nEXPORT_SYMBOL(param_ops_bint);\n\n \nstatic int param_array(struct module *mod,\n\t\t       const char *name,\n\t\t       const char *val,\n\t\t       unsigned int min, unsigned int max,\n\t\t       void *elem, int elemsize,\n\t\t       int (*set)(const char *, const struct kernel_param *kp),\n\t\t       s16 level,\n\t\t       unsigned int *num)\n{\n\tint ret;\n\tstruct kernel_param kp;\n\tchar save;\n\n\t \n\tkp.name = name;\n\tkp.arg = elem;\n\tkp.level = level;\n\n\t*num = 0;\n\t \n\tdo {\n\t\tint len;\n\n\t\tif (*num == max) {\n\t\t\tpr_err(\"%s: can only take %i arguments\\n\", name, max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlen = strcspn(val, \",\");\n\n\t\t \n\t\tsave = val[len];\n\t\t((char *)val)[len] = '\\0';\n\t\tcheck_kparam_locked(mod);\n\t\tret = set(val, &kp);\n\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tkp.arg += elemsize;\n\t\tval += len+1;\n\t\t(*num)++;\n\t} while (save == ',');\n\n\tif (*num < min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int param_array_set(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_array *arr = kp->arr;\n\tunsigned int temp_num;\n\n\treturn param_array(kp->mod, kp->name, val, 1, arr->max, arr->elem,\n\t\t\t   arr->elemsize, arr->ops->set, kp->level,\n\t\t\t   arr->num ?: &temp_num);\n}\n\nstatic int param_array_get(char *buffer, const struct kernel_param *kp)\n{\n\tint i, off, ret;\n\tconst struct kparam_array *arr = kp->arr;\n\tstruct kernel_param p = *kp;\n\n\tfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {\n\t\t \n\t\tif (i)\n\t\t\tbuffer[off - 1] = ',';\n\t\tp.arg = arr->elem + arr->elemsize * i;\n\t\tcheck_kparam_locked(p.mod);\n\t\tret = arr->ops->get(buffer + off, &p);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toff += ret;\n\t}\n\tbuffer[off] = '\\0';\n\treturn off;\n}\n\nstatic void param_array_free(void *arg)\n{\n\tunsigned int i;\n\tconst struct kparam_array *arr = arg;\n\n\tif (arr->ops->free)\n\t\tfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)\n\t\t\tarr->ops->free(arr->elem + arr->elemsize * i);\n}\n\nconst struct kernel_param_ops param_array_ops = {\n\t.set = param_array_set,\n\t.get = param_array_get,\n\t.free = param_array_free,\n};\nEXPORT_SYMBOL(param_array_ops);\n\nint param_set_copystring(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\n\tif (strlen(val)+1 > kps->maxlen) {\n\t\tpr_err(\"%s: string doesn't fit in %u chars.\\n\",\n\t\t       kp->name, kps->maxlen-1);\n\t\treturn -ENOSPC;\n\t}\n\tstrcpy(kps->string, val);\n\treturn 0;\n}\nEXPORT_SYMBOL(param_set_copystring);\n\nint param_get_string(char *buffer, const struct kernel_param *kp)\n{\n\tconst struct kparam_string *kps = kp->str;\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", kps->string);\n}\nEXPORT_SYMBOL(param_get_string);\n\nconst struct kernel_param_ops param_ops_string = {\n\t.set = param_set_copystring,\n\t.get = param_get_string,\n};\nEXPORT_SYMBOL(param_ops_string);\n\n \n#define to_module_attr(n) container_of(n, struct module_attribute, attr)\n#define to_module_kobject(n) container_of(n, struct module_kobject, kobj)\n\nstruct param_attribute\n{\n\tstruct module_attribute mattr;\n\tconst struct kernel_param *param;\n};\n\nstruct module_param_attrs\n{\n\tunsigned int num;\n\tstruct attribute_group grp;\n\tstruct param_attribute attrs[];\n};\n\n#ifdef CONFIG_SYSFS\n#define to_param_attr(n) container_of(n, struct param_attribute, mattr)\n\nstatic ssize_t param_attr_show(struct module_attribute *mattr,\n\t\t\t       struct module_kobject *mk, char *buf)\n{\n\tint count;\n\tstruct param_attribute *attribute = to_param_attr(mattr);\n\n\tif (!attribute->param->ops->get)\n\t\treturn -EPERM;\n\n\tkernel_param_lock(mk->mod);\n\tcount = attribute->param->ops->get(buf, attribute->param);\n\tkernel_param_unlock(mk->mod);\n\treturn count;\n}\n\n \nstatic ssize_t param_attr_store(struct module_attribute *mattr,\n\t\t\t\tstruct module_kobject *mk,\n\t\t\t\tconst char *buf, size_t len)\n{\n \tint err;\n\tstruct param_attribute *attribute = to_param_attr(mattr);\n\n\tif (!attribute->param->ops->set)\n\t\treturn -EPERM;\n\n\tkernel_param_lock(mk->mod);\n\tif (param_check_unsafe(attribute->param))\n\t\terr = attribute->param->ops->set(buf, attribute->param);\n\telse\n\t\terr = -EPERM;\n\tkernel_param_unlock(mk->mod);\n\tif (!err)\n\t\treturn len;\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_MODULES\n#define __modinit\n#else\n#define __modinit __init\n#endif\n\n#ifdef CONFIG_SYSFS\nvoid kernel_param_lock(struct module *mod)\n{\n\tmutex_lock(KPARAM_MUTEX(mod));\n}\n\nvoid kernel_param_unlock(struct module *mod)\n{\n\tmutex_unlock(KPARAM_MUTEX(mod));\n}\n\nEXPORT_SYMBOL(kernel_param_lock);\nEXPORT_SYMBOL(kernel_param_unlock);\n\n \nstatic __modinit int add_sysfs_param(struct module_kobject *mk,\n\t\t\t\t     const struct kernel_param *kp,\n\t\t\t\t     const char *name)\n{\n\tstruct module_param_attrs *new_mp;\n\tstruct attribute **new_attrs;\n\tunsigned int i;\n\n\t \n\tBUG_ON(!kp->perm);\n\n\tif (!mk->mp) {\n\t\t \n\t\tmk->mp = kzalloc(sizeof(*mk->mp), GFP_KERNEL);\n\t\tif (!mk->mp)\n\t\t\treturn -ENOMEM;\n\t\tmk->mp->grp.name = \"parameters\";\n\t\t \n\t\tmk->mp->grp.attrs = kzalloc(sizeof(mk->mp->grp.attrs[0]),\n\t\t\t\t\t    GFP_KERNEL);\n\t\t \n\t\tif (!mk->mp->grp.attrs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tnew_mp = krealloc(mk->mp,\n\t\t\t  sizeof(*mk->mp) +\n\t\t\t  sizeof(mk->mp->attrs[0]) * (mk->mp->num + 1),\n\t\t\t  GFP_KERNEL);\n\tif (!new_mp)\n\t\treturn -ENOMEM;\n\tmk->mp = new_mp;\n\n\t \n\tnew_attrs = krealloc(mk->mp->grp.attrs,\n\t\t\t     sizeof(mk->mp->grp.attrs[0]) * (mk->mp->num + 2),\n\t\t\t     GFP_KERNEL);\n\tif (!new_attrs)\n\t\treturn -ENOMEM;\n\tmk->mp->grp.attrs = new_attrs;\n\n\t \n\tmemset(&mk->mp->attrs[mk->mp->num], 0, sizeof(mk->mp->attrs[0]));\n\tsysfs_attr_init(&mk->mp->attrs[mk->mp->num].mattr.attr);\n\tmk->mp->attrs[mk->mp->num].param = kp;\n\tmk->mp->attrs[mk->mp->num].mattr.show = param_attr_show;\n\t \n\tif ((kp->perm & (S_IWUSR | S_IWGRP | S_IWOTH)) != 0)\n\t\tmk->mp->attrs[mk->mp->num].mattr.store = param_attr_store;\n\telse\n\t\tmk->mp->attrs[mk->mp->num].mattr.store = NULL;\n\tmk->mp->attrs[mk->mp->num].mattr.attr.name = (char *)name;\n\tmk->mp->attrs[mk->mp->num].mattr.attr.mode = kp->perm;\n\tmk->mp->num++;\n\n\t \n\tfor (i = 0; i < mk->mp->num; i++)\n\t\tmk->mp->grp.attrs[i] = &mk->mp->attrs[i].mattr.attr;\n\tmk->mp->grp.attrs[mk->mp->num] = NULL;\n\treturn 0;\n}\n\n#ifdef CONFIG_MODULES\nstatic void free_module_param_attrs(struct module_kobject *mk)\n{\n\tif (mk->mp)\n\t\tkfree(mk->mp->grp.attrs);\n\tkfree(mk->mp);\n\tmk->mp = NULL;\n}\n\n \nint module_param_sysfs_setup(struct module *mod,\n\t\t\t     const struct kernel_param *kparam,\n\t\t\t     unsigned int num_params)\n{\n\tint i, err;\n\tbool params = false;\n\n\tfor (i = 0; i < num_params; i++) {\n\t\tif (kparam[i].perm == 0)\n\t\t\tcontinue;\n\t\terr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);\n\t\tif (err) {\n\t\t\tfree_module_param_attrs(&mod->mkobj);\n\t\t\treturn err;\n\t\t}\n\t\tparams = true;\n\t}\n\n\tif (!params)\n\t\treturn 0;\n\n\t \n\terr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\n\tif (err)\n\t\tfree_module_param_attrs(&mod->mkobj);\n\treturn err;\n}\n\n \nvoid module_param_sysfs_remove(struct module *mod)\n{\n\tif (mod->mkobj.mp) {\n\t\tsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\n\t\t \n\t\tfree_module_param_attrs(&mod->mkobj);\n\t}\n}\n#endif\n\nvoid destroy_params(const struct kernel_param *params, unsigned num)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (params[i].ops->free)\n\t\t\tparams[i].ops->free(params[i].arg);\n}\n\nstatic struct module_kobject * __init locate_module_kobject(const char *name)\n{\n\tstruct module_kobject *mk;\n\tstruct kobject *kobj;\n\tint err;\n\n\tkobj = kset_find_obj(module_kset, name);\n\tif (kobj) {\n\t\tmk = to_module_kobject(kobj);\n\t} else {\n\t\tmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\n\t\tBUG_ON(!mk);\n\n\t\tmk->mod = THIS_MODULE;\n\t\tmk->kobj.kset = module_kset;\n\t\terr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\n\t\t\t\t\t   \"%s\", name);\n#ifdef CONFIG_MODULES\n\t\tif (!err)\n\t\t\terr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\n#endif\n\t\tif (err) {\n\t\t\tkobject_put(&mk->kobj);\n\t\t\tpr_crit(\"Adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\",\n\t\t\t\tname, err);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tkobject_get(&mk->kobj);\n\t}\n\n\treturn mk;\n}\n\nstatic void __init kernel_add_sysfs_param(const char *name,\n\t\t\t\t\t  const struct kernel_param *kparam,\n\t\t\t\t\t  unsigned int name_skip)\n{\n\tstruct module_kobject *mk;\n\tint err;\n\n\tmk = locate_module_kobject(name);\n\tif (!mk)\n\t\treturn;\n\n\t \n\tif (mk->mp)\n\t\tsysfs_remove_group(&mk->kobj, &mk->mp->grp);\n\n\t \n\terr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\n\tBUG_ON(err);\n\terr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\n\tBUG_ON(err);\n\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\tkobject_put(&mk->kobj);\n}\n\n \nstatic void __init param_sysfs_builtin(void)\n{\n\tconst struct kernel_param *kp;\n\tunsigned int name_len;\n\tchar modname[MODULE_NAME_LEN];\n\n\tfor (kp = __start___param; kp < __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->perm == 0)\n\t\t\tcontinue;\n\n\t\tdot = strchr(kp->name, '.');\n\t\tif (!dot) {\n\t\t\t \n\t\t\tstrcpy(modname, \"kernel\");\n\t\t\tname_len = 0;\n\t\t} else {\n\t\t\tname_len = dot - kp->name + 1;\n\t\t\tstrscpy(modname, kp->name, name_len);\n\t\t}\n\t\tkernel_add_sysfs_param(modname, kp, name_len);\n\t}\n}\n\nssize_t __modver_version_show(struct module_attribute *mattr,\n\t\t\t      struct module_kobject *mk, char *buf)\n{\n\tstruct module_version_attribute *vattr =\n\t\tcontainer_of(mattr, struct module_version_attribute, mattr);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vattr->version);\n}\n\nextern const struct module_version_attribute __start___modver[];\nextern const struct module_version_attribute __stop___modver[];\n\nstatic void __init version_sysfs_builtin(void)\n{\n\tconst struct module_version_attribute *vattr;\n\tstruct module_kobject *mk;\n\tint err;\n\n\tfor (vattr = __start___modver; vattr < __stop___modver; vattr++) {\n\t\tmk = locate_module_kobject(vattr->module_name);\n\t\tif (mk) {\n\t\t\terr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);\n\t\t\tWARN_ON_ONCE(err);\n\t\t\tkobject_uevent(&mk->kobj, KOBJ_ADD);\n\t\t\tkobject_put(&mk->kobj);\n\t\t}\n\t}\n}\n\n \n\nstatic ssize_t module_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct module_attribute *attribute;\n\tstruct module_kobject *mk;\n\tint ret;\n\n\tattribute = to_module_attr(attr);\n\tmk = to_module_kobject(kobj);\n\n\tif (!attribute->show)\n\t\treturn -EIO;\n\n\tret = attribute->show(attribute, mk, buf);\n\n\treturn ret;\n}\n\nstatic ssize_t module_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct module_attribute *attribute;\n\tstruct module_kobject *mk;\n\tint ret;\n\n\tattribute = to_module_attr(attr);\n\tmk = to_module_kobject(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\tret = attribute->store(attribute, mk, buf, len);\n\n\treturn ret;\n}\n\nstatic const struct sysfs_ops module_sysfs_ops = {\n\t.show = module_attr_show,\n\t.store = module_attr_store,\n};\n\nstatic int uevent_filter(const struct kobject *kobj)\n{\n\tconst struct kobj_type *ktype = get_ktype(kobj);\n\n\tif (ktype == &module_ktype)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic const struct kset_uevent_ops module_uevent_ops = {\n\t.filter = uevent_filter,\n};\n\nstruct kset *module_kset;\n\nstatic void module_kobj_release(struct kobject *kobj)\n{\n\tstruct module_kobject *mk = to_module_kobject(kobj);\n\tcomplete(mk->kobj_completion);\n}\n\nconst struct kobj_type module_ktype = {\n\t.release   =\tmodule_kobj_release,\n\t.sysfs_ops =\t&module_sysfs_ops,\n};\n\n \nstatic int __init param_sysfs_init(void)\n{\n\tmodule_kset = kset_create_and_add(\"module\", &module_uevent_ops, NULL);\n\tif (!module_kset) {\n\t\tprintk(KERN_WARNING \"%s (%d): error creating kset\\n\",\n\t\t\t__FILE__, __LINE__);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\nsubsys_initcall(param_sysfs_init);\n\n \nstatic int __init param_sysfs_builtin_init(void)\n{\n\tif (!module_kset)\n\t\treturn -ENOMEM;\n\n\tversion_sysfs_builtin();\n\tparam_sysfs_builtin();\n\n\treturn 0;\n}\nlate_initcall(param_sysfs_builtin_init);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}