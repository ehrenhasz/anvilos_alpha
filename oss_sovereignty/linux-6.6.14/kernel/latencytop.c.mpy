{
  "module_name": "latencytop.c",
  "hash_id": "8ced5f31cd4af3766dec7a79a117a6c46aab155f922a4f50f6103ffc0a3dba00",
  "original_prompt": "Ingested from linux-6.6.14/kernel/latencytop.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/notifier.h>\n#include <linux/spinlock.h>\n#include <linux/proc_fs.h>\n#include <linux/latencytop.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/list.h>\n#include <linux/stacktrace.h>\n#include <linux/sysctl.h>\n\nstatic DEFINE_RAW_SPINLOCK(latency_lock);\n\n#define MAXLR 128\nstatic struct latency_record latency_record[MAXLR];\n\nint latencytop_enabled;\n\n#ifdef CONFIG_SYSCTL\nstatic int sysctl_latencytop(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\terr = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (latencytop_enabled)\n\t\tforce_schedstat_enabled();\n\n\treturn err;\n}\n\nstatic struct ctl_table latencytop_sysctl[] = {\n\t{\n\t\t.procname   = \"latencytop\",\n\t\t.data       = &latencytop_enabled,\n\t\t.maxlen     = sizeof(int),\n\t\t.mode       = 0644,\n\t\t.proc_handler   = sysctl_latencytop,\n\t},\n\t{}\n};\n#endif\n\nvoid clear_tsk_latency_tracing(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&p->latency_record, 0, sizeof(p->latency_record));\n\tp->latency_record_count = 0;\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}\n\nstatic void clear_global_latency_tracing(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\tmemset(&latency_record, 0, sizeof(latency_record));\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}\n\nstatic void __sched\naccount_global_scheduler_latency(struct task_struct *tsk,\n\t\t\t\t struct latency_record *lat)\n{\n\tint firstnonnull = MAXLR;\n\tint i;\n\n\t \n\tif (!tsk->mm)\n\t\treturn;\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tint q, same = 1;\n\n\t\t \n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull > i)\n\t\t\t\tfirstnonnull = i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat->backtrace[q];\n\n\t\t\tif (latency_record[i].backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!record)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tlatency_record[i].count++;\n\t\t\tlatency_record[i].time += lat->time;\n\t\t\tif (lat->time > latency_record[i].max)\n\t\t\t\tlatency_record[i].max = lat->time;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti = firstnonnull;\n\tif (i >= MAXLR)\n\t\treturn;\n\n\t \n\tmemcpy(&latency_record[i], lat, sizeof(struct latency_record));\n}\n\n \nvoid __sched\n__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)\n{\n\tunsigned long flags;\n\tint i, q;\n\tstruct latency_record lat;\n\n\t \n\tif (inter && usecs > 5000)\n\t\treturn;\n\n\t \n\t \n\tif (usecs <= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\n\tstack_trace_save_tsk(tsk, lat.backtrace, LT_BACKTRACEDEPTH, 0);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->latency_record_count; i++) {\n\t\tstruct latency_record *mylat;\n\t\tint same = 1;\n\n\t\tmylat = &tsk->latency_record[i];\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!record)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tmylat->count++;\n\t\t\tmylat->time += lat.time;\n\t\t\tif (lat.time > mylat->max)\n\t\t\t\tmylat->max = lat.time;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tif (tsk->latency_record_count >= LT_SAVECOUNT)\n\t\tgoto out_unlock;\n\n\t \n\ti = tsk->latency_record_count++;\n\tmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}\n\nstatic int lstats_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\n\tfor (i = 0; i < MAXLR; i++) {\n\t\tstruct latency_record *lr = &latency_record[i];\n\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %lu %lu\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ssize_t\nlstats_write(struct file *file, const char __user *buf, size_t count,\n\t     loff_t *offs)\n{\n\tclear_global_latency_tracing();\n\n\treturn count;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, lstats_show, NULL);\n}\n\nstatic const struct proc_ops lstats_proc_ops = {\n\t.proc_open\t= lstats_open,\n\t.proc_read\t= seq_read,\n\t.proc_write\t= lstats_write,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\nstatic int __init init_lstats_procfs(void)\n{\n\tproc_create(\"latency_stats\", 0644, NULL, &lstats_proc_ops);\n#ifdef CONFIG_SYSCTL\n\tregister_sysctl_init(\"kernel\", latencytop_sysctl);\n#endif\n\treturn 0;\n}\ndevice_initcall(init_lstats_procfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}