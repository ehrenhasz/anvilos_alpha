{
  "module_name": "fork.c",
  "hash_id": "cf6080d8e00322219ae9bb13fee45f8cc0cb63da1a49b9543430ca8c2dfb1d5d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/fork.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/user.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/seq_file.h>\n#include <linux/rtmutex.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/kmsan.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mm_inline.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/seccomp.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/kthread.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/proc_fs.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/tty.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n#include <linux/oom.h>\n#include <linux/khugepaged.h>\n#include <linux/signalfd.h>\n#include <linux/uprobes.h>\n#include <linux/aio.h>\n#include <linux/compiler.h>\n#include <linux/sysctl.h>\n#include <linux/kcov.h>\n#include <linux/livepatch.h>\n#include <linux/thread_info.h>\n#include <linux/stackleak.h>\n#include <linux/kasan.h>\n#include <linux/scs.h>\n#include <linux/io_uring.h>\n#include <linux/bpf.h>\n#include <linux/stackprotector.h>\n#include <linux/user_events.h>\n#include <linux/iommu.h>\n\n#include <asm/pgalloc.h>\n#include <linux/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/task.h>\n\n \n#define MIN_THREADS 20\n\n \n#define MAX_THREADS FUTEX_TID_MASK\n\n \nunsigned long total_forks;\t \nint nr_threads;\t\t\t \n\nstatic int max_threads;\t\t \n\n#define NAMED_ARRAY_INDEX(x)\t[x] = __stringify(x)\n\nstatic const char * const resident_page_types[] = {\n\tNAMED_ARRAY_INDEX(MM_FILEPAGES),\n\tNAMED_ARRAY_INDEX(MM_ANONPAGES),\n\tNAMED_ARRAY_INDEX(MM_SWAPENTS),\n\tNAMED_ARRAY_INDEX(MM_SHMEMPAGES),\n};\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);   \n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif  \n\nint nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n\nvoid __weak arch_release_task_struct(struct task_struct *tsk)\n{\n}\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic struct kmem_cache *task_struct_cachep;\n\nstatic inline struct task_struct *alloc_task_struct_node(int node)\n{\n\treturn kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);\n}\n\nstatic inline void free_task_struct(struct task_struct *tsk)\n{\n\tkmem_cache_free(task_struct_cachep, tsk);\n}\n#endif\n\n#ifndef CONFIG_ARCH_THREAD_STACK_ALLOCATOR\n\n \n# if THREAD_SIZE >= PAGE_SIZE || defined(CONFIG_VMAP_STACK)\n\n#  ifdef CONFIG_VMAP_STACK\n \n#define NR_CACHED_STACKS 2\nstatic DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]);\n\nstruct vm_stack {\n\tstruct rcu_head rcu;\n\tstruct vm_struct *stack_vm_area;\n};\n\nstatic bool try_release_thread_stack_to_cache(struct vm_struct *vm)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tif (this_cpu_cmpxchg(cached_stacks[i], NULL, vm) != NULL)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void thread_stack_free_rcu(struct rcu_head *rh)\n{\n\tstruct vm_stack *vm_stack = container_of(rh, struct vm_stack, rcu);\n\n\tif (try_release_thread_stack_to_cache(vm_stack->stack_vm_area))\n\t\treturn;\n\n\tvfree(vm_stack);\n}\n\nstatic void thread_stack_delayed_free(struct task_struct *tsk)\n{\n\tstruct vm_stack *vm_stack = tsk->stack;\n\n\tvm_stack->stack_vm_area = tsk->stack_vm_area;\n\tcall_rcu(&vm_stack->rcu, thread_stack_free_rcu);\n}\n\nstatic int free_vm_stack_cache(unsigned int cpu)\n{\n\tstruct vm_struct **cached_vm_stacks = per_cpu_ptr(cached_stacks, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *vm_stack = cached_vm_stacks[i];\n\n\t\tif (!vm_stack)\n\t\t\tcontinue;\n\n\t\tvfree(vm_stack->addr);\n\t\tcached_vm_stacks[i] = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int memcg_charge_kernel_stack(struct vm_struct *vm)\n{\n\tint i;\n\tint ret;\n\tint nr_charged = 0;\n\n\tBUG_ON(vm->nr_pages != THREAD_SIZE / PAGE_SIZE);\n\n\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++) {\n\t\tret = memcg_kmem_charge_page(vm->pages[i], GFP_KERNEL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnr_charged++;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < nr_charged; i++)\n\t\tmemcg_kmem_uncharge_page(vm->pages[i], 0);\n\treturn ret;\n}\n\nstatic int alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n\tstruct vm_struct *vm;\n\tvoid *stack;\n\tint i;\n\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *s;\n\n\t\ts = this_cpu_xchg(cached_stacks[i], NULL);\n\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\t \n\t\tkasan_unpoison_range(s->addr, THREAD_SIZE);\n\n\t\tstack = kasan_reset_tag(s->addr);\n\n\t\t \n\t\tmemset(stack, 0, THREAD_SIZE);\n\n\t\tif (memcg_charge_kernel_stack(s)) {\n\t\t\tvfree(s->addr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttsk->stack_vm_area = s;\n\t\ttsk->stack = stack;\n\t\treturn 0;\n\t}\n\n\t \n\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,\n\t\t\t\t     VMALLOC_START, VMALLOC_END,\n\t\t\t\t     THREADINFO_GFP & ~__GFP_ACCOUNT,\n\t\t\t\t     PAGE_KERNEL,\n\t\t\t\t     0, node, __builtin_return_address(0));\n\tif (!stack)\n\t\treturn -ENOMEM;\n\n\tvm = find_vm_area(stack);\n\tif (memcg_charge_kernel_stack(vm)) {\n\t\tvfree(stack);\n\t\treturn -ENOMEM;\n\t}\n\t \n\ttsk->stack_vm_area = vm;\n\tstack = kasan_reset_tag(stack);\n\ttsk->stack = stack;\n\treturn 0;\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tif (!try_release_thread_stack_to_cache(tsk->stack_vm_area))\n\t\tthread_stack_delayed_free(tsk);\n\n\ttsk->stack = NULL;\n\ttsk->stack_vm_area = NULL;\n}\n\n#  else  \n\nstatic void thread_stack_free_rcu(struct rcu_head *rh)\n{\n\t__free_pages(virt_to_page(rh), THREAD_SIZE_ORDER);\n}\n\nstatic void thread_stack_delayed_free(struct task_struct *tsk)\n{\n\tstruct rcu_head *rh = tsk->stack;\n\n\tcall_rcu(rh, thread_stack_free_rcu);\n}\n\nstatic int alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,\n\t\t\t\t\t     THREAD_SIZE_ORDER);\n\n\tif (likely(page)) {\n\t\ttsk->stack = kasan_reset_tag(page_address(page));\n\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tthread_stack_delayed_free(tsk);\n\ttsk->stack = NULL;\n}\n\n#  endif  \n# else  \n\nstatic struct kmem_cache *thread_stack_cache;\n\nstatic void thread_stack_free_rcu(struct rcu_head *rh)\n{\n\tkmem_cache_free(thread_stack_cache, rh);\n}\n\nstatic void thread_stack_delayed_free(struct task_struct *tsk)\n{\n\tstruct rcu_head *rh = tsk->stack;\n\n\tcall_rcu(rh, thread_stack_free_rcu);\n}\n\nstatic int alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n\tunsigned long *stack;\n\tstack = kmem_cache_alloc_node(thread_stack_cache, THREADINFO_GFP, node);\n\tstack = kasan_reset_tag(stack);\n\ttsk->stack = stack;\n\treturn stack ? 0 : -ENOMEM;\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tthread_stack_delayed_free(tsk);\n\ttsk->stack = NULL;\n}\n\nvoid thread_stack_cache_init(void)\n{\n\tthread_stack_cache = kmem_cache_create_usercopy(\"thread_stack\",\n\t\t\t\t\tTHREAD_SIZE, THREAD_SIZE, 0, 0,\n\t\t\t\t\tTHREAD_SIZE, NULL);\n\tBUG_ON(thread_stack_cache == NULL);\n}\n\n# endif  \n#else  \n\nstatic int alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n\tunsigned long *stack;\n\n\tstack = arch_alloc_thread_stack_node(tsk, node);\n\ttsk->stack = stack;\n\treturn stack ? 0 : -ENOMEM;\n}\n\nstatic void free_thread_stack(struct task_struct *tsk)\n{\n\tarch_free_thread_stack(tsk);\n\ttsk->stack = NULL;\n}\n\n#endif  \n\n \nstatic struct kmem_cache *signal_cachep;\n\n \nstruct kmem_cache *sighand_cachep;\n\n \nstruct kmem_cache *files_cachep;\n\n \nstruct kmem_cache *fs_cachep;\n\n \nstatic struct kmem_cache *vm_area_cachep;\n\n \nstatic struct kmem_cache *mm_cachep;\n\n#ifdef CONFIG_PER_VMA_LOCK\n\n \nstatic struct kmem_cache *vma_lock_cachep;\n\nstatic bool vma_lock_alloc(struct vm_area_struct *vma)\n{\n\tvma->vm_lock = kmem_cache_alloc(vma_lock_cachep, GFP_KERNEL);\n\tif (!vma->vm_lock)\n\t\treturn false;\n\n\tinit_rwsem(&vma->vm_lock->lock);\n\tvma->vm_lock_seq = -1;\n\n\treturn true;\n}\n\nstatic inline void vma_lock_free(struct vm_area_struct *vma)\n{\n\tkmem_cache_free(vma_lock_cachep, vma->vm_lock);\n}\n\n#else  \n\nstatic inline bool vma_lock_alloc(struct vm_area_struct *vma) { return true; }\nstatic inline void vma_lock_free(struct vm_area_struct *vma) {}\n\n#endif  \n\nstruct vm_area_struct *vm_area_alloc(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\n\tvma = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma)\n\t\treturn NULL;\n\n\tvma_init(vma, mm);\n\tif (!vma_lock_alloc(vma)) {\n\t\tkmem_cache_free(vm_area_cachep, vma);\n\t\treturn NULL;\n\t}\n\n\treturn vma;\n}\n\nstruct vm_area_struct *vm_area_dup(struct vm_area_struct *orig)\n{\n\tstruct vm_area_struct *new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn NULL;\n\n\tASSERT_EXCLUSIVE_WRITER(orig->vm_flags);\n\tASSERT_EXCLUSIVE_WRITER(orig->vm_file);\n\t \n\tdata_race(memcpy(new, orig, sizeof(*new)));\n\tif (!vma_lock_alloc(new)) {\n\t\tkmem_cache_free(vm_area_cachep, new);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tvma_numab_state_init(new);\n\tdup_anon_vma_name(orig, new);\n\n\treturn new;\n}\n\nvoid __vm_area_free(struct vm_area_struct *vma)\n{\n\tvma_numab_state_free(vma);\n\tfree_anon_vma_name(vma);\n\tvma_lock_free(vma);\n\tkmem_cache_free(vm_area_cachep, vma);\n}\n\n#ifdef CONFIG_PER_VMA_LOCK\nstatic void vm_area_free_rcu_cb(struct rcu_head *head)\n{\n\tstruct vm_area_struct *vma = container_of(head, struct vm_area_struct,\n\t\t\t\t\t\t  vm_rcu);\n\n\t \n\tVM_BUG_ON_VMA(rwsem_is_locked(&vma->vm_lock->lock), vma);\n\t__vm_area_free(vma);\n}\n#endif\n\nvoid vm_area_free(struct vm_area_struct *vma)\n{\n#ifdef CONFIG_PER_VMA_LOCK\n\tcall_rcu(&vma->vm_rcu, vm_area_free_rcu_cb);\n#else\n\t__vm_area_free(vma);\n#endif\n}\n\nstatic void account_kernel_stack(struct task_struct *tsk, int account)\n{\n\tif (IS_ENABLED(CONFIG_VMAP_STACK)) {\n\t\tstruct vm_struct *vm = task_stack_vm_area(tsk);\n\t\tint i;\n\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++)\n\t\t\tmod_lruvec_page_state(vm->pages[i], NR_KERNEL_STACK_KB,\n\t\t\t\t\t      account * (PAGE_SIZE / 1024));\n\t} else {\n\t\tvoid *stack = task_stack_page(tsk);\n\n\t\t \n\t\tmod_lruvec_kmem_state(stack, NR_KERNEL_STACK_KB,\n\t\t\t\t      account * (THREAD_SIZE / 1024));\n\t}\n}\n\nvoid exit_task_stack_account(struct task_struct *tsk)\n{\n\taccount_kernel_stack(tsk, -1);\n\n\tif (IS_ENABLED(CONFIG_VMAP_STACK)) {\n\t\tstruct vm_struct *vm;\n\t\tint i;\n\n\t\tvm = task_stack_vm_area(tsk);\n\t\tfor (i = 0; i < THREAD_SIZE / PAGE_SIZE; i++)\n\t\t\tmemcg_kmem_uncharge_page(vm->pages[i], 0);\n\t}\n}\n\nstatic void release_task_stack(struct task_struct *tsk)\n{\n\tif (WARN_ON(READ_ONCE(tsk->__state) != TASK_DEAD))\n\t\treturn;   \n\n\tfree_thread_stack(tsk);\n}\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\nvoid put_task_stack(struct task_struct *tsk)\n{\n\tif (refcount_dec_and_test(&tsk->stack_refcount))\n\t\trelease_task_stack(tsk);\n}\n#endif\n\nvoid free_task(struct task_struct *tsk)\n{\n#ifdef CONFIG_SECCOMP\n\tWARN_ON_ONCE(tsk->seccomp.filter);\n#endif\n\trelease_user_cpus_ptr(tsk);\n\tscs_release(tsk);\n\n#ifndef CONFIG_THREAD_INFO_IN_TASK\n\t \n\trelease_task_stack(tsk);\n#else\n\t \n\tWARN_ON_ONCE(refcount_read(&tsk->stack_refcount) != 0);\n#endif\n\trt_mutex_debug_task_free(tsk);\n\tftrace_graph_exit_task(tsk);\n\tarch_release_task_struct(tsk);\n\tif (tsk->flags & PF_KTHREAD)\n\t\tfree_kthread_struct(tsk);\n\tbpf_task_storage_free(tsk);\n\tfree_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nstatic void dup_mm_exe_file(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct file *exe_file;\n\n\texe_file = get_mm_exe_file(oldmm);\n\tRCU_INIT_POINTER(mm->exe_file, exe_file);\n\t \n\tif (exe_file && deny_write_access(exe_file))\n\t\tpr_warn_once(\"deny_write_access() failed in %s\\n\", __func__);\n}\n\n#ifdef CONFIG_MMU\nstatic __latent_entropy int dup_mmap(struct mm_struct *mm,\n\t\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp;\n\tint retval;\n\tunsigned long charge = 0;\n\tLIST_HEAD(uf);\n\tVMA_ITERATOR(old_vmi, oldmm, 0);\n\tVMA_ITERATOR(vmi, mm, 0);\n\n\tuprobe_start_dup_mmap();\n\tif (mmap_write_lock_killable(oldmm)) {\n\t\tretval = -EINTR;\n\t\tgoto fail_uprobe_end;\n\t}\n\tflush_cache_dup_mm(oldmm);\n\tuprobe_dup_mmap(oldmm, mm);\n\t \n\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);\n\n\t \n\tdup_mm_exe_file(mm, oldmm);\n\n\tmm->total_vm = oldmm->total_vm;\n\tmm->data_vm = oldmm->data_vm;\n\tmm->exec_vm = oldmm->exec_vm;\n\tmm->stack_vm = oldmm->stack_vm;\n\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\tkhugepaged_fork(mm, oldmm);\n\n\tretval = vma_iter_bulk_alloc(&vmi, oldmm->map_count);\n\tif (retval)\n\t\tgoto out;\n\n\tmt_clear_in_rcu(vmi.mas.tree);\n\tfor_each_vma(old_vmi, mpnt) {\n\t\tstruct file *file;\n\n\t\tvma_start_write(mpnt);\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\t \n\t\tif (fatal_signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tgoto loop_out;\n\t\t}\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned long len = vma_pages(mpnt);\n\n\t\t\tif (security_vm_enough_memory_mm(oldmm, len))  \n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = vm_area_dup(mpnt);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\tretval = vma_dup_policy(mpnt, tmp);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_policy;\n\t\ttmp->vm_mm = mm;\n\t\tretval = dup_userfaultfd(tmp, &uf);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tif (tmp->vm_flags & VM_WIPEONFORK) {\n\t\t\t \n\t\t\ttmp->anon_vma = NULL;\n\t\t} else if (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\ti_mmap_lock_write(mapping);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping_allow_writable(mapping);\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t \n\t\t\tvma_interval_tree_insert_after(tmp, mpnt,\n\t\t\t\t\t&mapping->i_mmap);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\ti_mmap_unlock_write(mapping);\n\t\t}\n\n\t\t \n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\thugetlb_dup_vma_private(tmp);\n\n\t\t \n\t\tif (vma_iter_bulk_store(&vmi, tmp))\n\t\t\tgoto fail_nomem_vmi_store;\n\n\t\tmm->map_count++;\n\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))\n\t\t\tretval = copy_page_range(tmp, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto loop_out;\n\t}\n\t \n\tretval = arch_dup_mmap(oldmm, mm);\nloop_out:\n\tvma_iter_free(&vmi);\n\tif (!retval)\n\t\tmt_set_in_rcu(vmi.mas.tree);\nout:\n\tmmap_write_unlock(mm);\n\tflush_tlb_mm(oldmm);\n\tmmap_write_unlock(oldmm);\n\tdup_userfaultfd_complete(&uf);\nfail_uprobe_end:\n\tuprobe_end_dup_mmap();\n\treturn retval;\n\nfail_nomem_vmi_store:\n\tunlink_anon_vmas(tmp);\nfail_nomem_anon_vma_fork:\n\tmpol_put(vma_policy(tmp));\nfail_nomem_policy:\n\tvm_area_free(tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto loop_out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct *mm)\n{\n\tmm->pgd = pgd_alloc(mm);\n\tif (unlikely(!mm->pgd))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct *mm)\n{\n\tpgd_free(mm, mm->pgd);\n}\n#else\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tmmap_write_lock(oldmm);\n\tdup_mm_exe_file(mm, oldmm);\n\tmmap_write_unlock(oldmm);\n\treturn 0;\n}\n#define mm_alloc_pgd(mm)\t(0)\n#define mm_free_pgd(mm)\n#endif  \n\nstatic void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tBUILD_BUG_ON_MSG(ARRAY_SIZE(resident_page_types) != NR_MM_COUNTERS,\n\t\t\t \"Please make sure 'struct resident_page_types[]' is updated as well\");\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = percpu_counter_sum(&mm->rss_stat[i]);\n\n\t\tif (unlikely(x))\n\t\t\tpr_alert(\"BUG: Bad rss-counter state mm:%p type:%s val:%ld\\n\",\n\t\t\t\t mm, resident_page_types[i], x);\n\t}\n\n\tif (mm_pgtables_bytes(mm))\n\t\tpr_alert(\"BUG: non-zero pgtables_bytes on freeing mm: %ld\\n\",\n\t\t\t\tmm_pgtables_bytes(mm));\n\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tVM_BUG_ON_MM(mm->pmd_huge_pte, mm);\n#endif\n}\n\n#define allocate_mm()\t(kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)\t(kmem_cache_free(mm_cachep, (mm)))\n\nstatic void do_check_lazy_tlb(void *arg)\n{\n\tstruct mm_struct *mm = arg;\n\n\tWARN_ON_ONCE(current->active_mm == mm);\n}\n\nstatic void do_shoot_lazy_tlb(void *arg)\n{\n\tstruct mm_struct *mm = arg;\n\n\tif (current->active_mm == mm) {\n\t\tWARN_ON_ONCE(current->mm);\n\t\tcurrent->active_mm = &init_mm;\n\t\tswitch_mm(mm, &init_mm, current);\n\t}\n}\n\nstatic void cleanup_lazy_tlbs(struct mm_struct *mm)\n{\n\tif (!IS_ENABLED(CONFIG_MMU_LAZY_TLB_SHOOTDOWN)) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\ton_each_cpu_mask(mm_cpumask(mm), do_shoot_lazy_tlb, (void *)mm, 1);\n\tif (IS_ENABLED(CONFIG_DEBUG_VM_SHOOT_LAZIES))\n\t\ton_each_cpu(do_check_lazy_tlb, (void *)mm, 1);\n}\n\n \nvoid __mmdrop(struct mm_struct *mm)\n{\n\tBUG_ON(mm == &init_mm);\n\tWARN_ON_ONCE(mm == current->mm);\n\n\t \n\tcleanup_lazy_tlbs(mm);\n\n\tWARN_ON_ONCE(mm == current->active_mm);\n\tmm_free_pgd(mm);\n\tdestroy_context(mm);\n\tmmu_notifier_subscriptions_destroy(mm);\n\tcheck_mm(mm);\n\tput_user_ns(mm->user_ns);\n\tmm_pasid_drop(mm);\n\tmm_destroy_cid(mm);\n\tpercpu_counter_destroy_many(mm->rss_stat, NR_MM_COUNTERS);\n\n\tfree_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\nstatic void mmdrop_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm;\n\n\tmm = container_of(work, struct mm_struct, async_put_work);\n\t__mmdrop(mm);\n}\n\nstatic void mmdrop_async(struct mm_struct *mm)\n{\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count))) {\n\t\tINIT_WORK(&mm->async_put_work, mmdrop_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n\ttaskstats_tgid_free(sig);\n\tsched_autogroup_exit(sig);\n\t \n\tif (sig->oom_mm)\n\t\tmmdrop_async(sig->oom_mm);\n\tkmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n\tif (refcount_dec_and_test(&sig->sigcnt))\n\t\tfree_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct);\n\nvoid __put_task_struct_rcu_cb(struct rcu_head *rhp)\n{\n\tstruct task_struct *task = container_of(rhp, struct task_struct, rcu);\n\n\t__put_task_struct(task);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct_rcu_cb);\n\nvoid __init __weak arch_task_cache_init(void) { }\n\n \nstatic void set_max_threads(unsigned int max_threads_suggested)\n{\n\tu64 threads;\n\tunsigned long nr_pages = totalram_pages();\n\n\t \n\tif (fls64(nr_pages) + fls64(PAGE_SIZE) > 64)\n\t\tthreads = MAX_THREADS;\n\telse\n\t\tthreads = div64_u64((u64) nr_pages * (u64) PAGE_SIZE,\n\t\t\t\t    (u64) THREAD_SIZE * 8UL);\n\n\tif (threads > max_threads_suggested)\n\t\tthreads = max_threads_suggested;\n\n\tmax_threads = clamp_t(u64, threads, MIN_THREADS, MAX_THREADS);\n}\n\n#ifdef CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT\n \nint arch_task_struct_size __read_mostly;\n#endif\n\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\nstatic void task_struct_whitelist(unsigned long *offset, unsigned long *size)\n{\n\t \n\tarch_thread_struct_whitelist(offset, size);\n\n\t \n\tif (unlikely(*size == 0))\n\t\t*offset = 0;\n\telse\n\t\t*offset += offsetof(struct task_struct, thread);\n}\n#endif  \n\nvoid __init fork_init(void)\n{\n\tint i;\n#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN\t0\n#endif\n\tint align = max_t(int, L1_CACHE_BYTES, ARCH_MIN_TASKALIGN);\n\tunsigned long useroffset, usersize;\n\n\t \n\ttask_struct_whitelist(&useroffset, &usersize);\n\ttask_struct_cachep = kmem_cache_create_usercopy(\"task_struct\",\n\t\t\tarch_task_struct_size, align,\n\t\t\tSLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tuseroffset, usersize, NULL);\n#endif\n\n\t \n\tarch_task_cache_init();\n\n\tset_max_threads(MAX_THREADS);\n\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n\tinit_task.signal->rlim[RLIMIT_SIGPENDING] =\n\t\tinit_task.signal->rlim[RLIMIT_NPROC];\n\n\tfor (i = 0; i < UCOUNT_COUNTS; i++)\n\t\tinit_user_ns.ucount_max[i] = max_threads/2;\n\n\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_NPROC,      RLIM_INFINITY);\n\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_MSGQUEUE,   RLIM_INFINITY);\n\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_SIGPENDING, RLIM_INFINITY);\n\tset_userns_rlimit_max(&init_user_ns, UCOUNT_RLIMIT_MEMLOCK,    RLIM_INFINITY);\n\n#ifdef CONFIG_VMAP_STACK\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"fork:vm_stack_cache\",\n\t\t\t  NULL, free_vm_stack_cache);\n#endif\n\n\tscs_init();\n\n\tlockdep_init_task(&init_task);\n\tuprobes_init();\n}\n\nint __weak arch_dup_task_struct(struct task_struct *dst,\n\t\t\t\t\t       struct task_struct *src)\n{\n\t*dst = *src;\n\treturn 0;\n}\n\nvoid set_task_stack_end_magic(struct task_struct *tsk)\n{\n\tunsigned long *stackend;\n\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t \n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig, int node)\n{\n\tstruct task_struct *tsk;\n\tint err;\n\n\tif (node == NUMA_NO_NODE)\n\t\tnode = tsk_fork_get_node(orig);\n\ttsk = alloc_task_struct_node(node);\n\tif (!tsk)\n\t\treturn NULL;\n\n\terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto free_tsk;\n\n\terr = alloc_thread_stack_node(tsk, node);\n\tif (err)\n\t\tgoto free_tsk;\n\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\trefcount_set(&tsk->stack_refcount, 1);\n#endif\n\taccount_kernel_stack(tsk, 1);\n\n\terr = scs_prepare(tsk, node);\n\tif (err)\n\t\tgoto free_stack;\n\n#ifdef CONFIG_SECCOMP\n\t \n\ttsk->seccomp.filter = NULL;\n#endif\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tset_task_stack_end_magic(tsk);\n\tclear_syscall_work_syscall_user_dispatch(tsk);\n\n#ifdef CONFIG_STACKPROTECTOR\n\ttsk->stack_canary = get_random_canary();\n#endif\n\tif (orig->cpus_ptr == &orig->cpus_mask)\n\t\ttsk->cpus_ptr = &tsk->cpus_mask;\n\tdup_user_cpus_ptr(tsk, orig, node);\n\n\t \n\trefcount_set(&tsk->rcu_users, 2);\n\t \n\trefcount_set(&tsk->usage, 1);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\ttsk->task_frag.page = NULL;\n\ttsk->wake_q.next = NULL;\n\ttsk->worker_private = NULL;\n\n\tkcov_task_init(tsk);\n\tkmsan_task_create(tsk);\n\tkmap_local_fork(tsk);\n\n#ifdef CONFIG_FAULT_INJECTION\n\ttsk->fail_nth = 0;\n#endif\n\n#ifdef CONFIG_BLK_CGROUP\n\ttsk->throttle_disk = NULL;\n\ttsk->use_memdelay = 0;\n#endif\n\n#ifdef CONFIG_IOMMU_SVA\n\ttsk->pasid_activated = 0;\n#endif\n\n#ifdef CONFIG_MEMCG\n\ttsk->active_memcg = NULL;\n#endif\n\n#ifdef CONFIG_CPU_SUP_INTEL\n\ttsk->reported_split_lock = 0;\n#endif\n\n#ifdef CONFIG_SCHED_MM_CID\n\ttsk->mm_cid = -1;\n\ttsk->last_mm_cid = -1;\n\ttsk->mm_cid_active = 0;\n\ttsk->migrate_from_cpu = -1;\n#endif\n\treturn tsk;\n\nfree_stack:\n\texit_task_stack_account(tsk);\n\tfree_thread_stack(tsk);\nfree_tsk:\n\tfree_task_struct(tsk);\n\treturn NULL;\n}\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n\tdefault_dump_filter =\n\t\t(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n\t\tMMF_DUMP_FILTER_MASK;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n\tspin_lock_init(&mm->ioctx_lock);\n\tmm->ioctx_table = NULL;\n#endif\n}\n\nstatic __always_inline void mm_clear_owner(struct mm_struct *mm,\n\t\t\t\t\t   struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tif (mm->owner == p)\n\t\tWRITE_ONCE(mm->owner, NULL);\n#endif\n}\n\nstatic void mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n#ifdef CONFIG_MEMCG\n\tmm->owner = p;\n#endif\n}\n\nstatic void mm_init_uprobes_state(struct mm_struct *mm)\n{\n#ifdef CONFIG_UPROBES\n\tmm->uprobes_state.xol_area = NULL;\n#endif\n}\n\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmt_init_flags(&mm->mm_mt, MM_MT_FLAGS);\n\tmt_set_external_lock(&mm->mm_mt, &mm->mmap_lock);\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tseqcount_init(&mm->write_protect_seq);\n\tmmap_init_lock(mm);\n\tINIT_LIST_HEAD(&mm->mmlist);\n#ifdef CONFIG_PER_VMA_LOCK\n\tmm->mm_lock_seq = 0;\n#endif\n\tmm_pgtables_bytes_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tatomic64_set(&mm->pinned_vm, 0);\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tspin_lock_init(&mm->arg_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tmm_pasid_init(mm);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_subscriptions_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\thugetlb_count_init(mm);\n\n\tif (current->mm) {\n\t\tmm->flags = mmf_init_flags(current->mm->flags);\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\n\tif (mm_alloc_cid(mm))\n\t\tgoto fail_cid;\n\n\tif (percpu_counter_init_many(mm->rss_stat, 0, GFP_KERNEL_ACCOUNT,\n\t\t\t\t     NR_MM_COUNTERS))\n\t\tgoto fail_pcpu;\n\n\tmm->user_ns = get_user_ns(user_ns);\n\tlru_gen_init_mm(mm);\n\treturn mm;\n\nfail_pcpu:\n\tmm_destroy_cid(mm);\nfail_cid:\n\tdestroy_context(mm);\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}\n\n \nstruct mm_struct *mm_alloc(void)\n{\n\tstruct mm_struct *mm;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\treturn NULL;\n\n\tmemset(mm, 0, sizeof(*mm));\n\treturn mm_init(mm, current, current_user_ns());\n}\n\nstatic inline void __mmput(struct mm_struct *mm)\n{\n\tVM_BUG_ON(atomic_read(&mm->mm_users));\n\n\tuprobe_clear_state(mm);\n\texit_aio(mm);\n\tksm_exit(mm);\n\tkhugepaged_exit(mm);  \n\texit_mmap(mm);\n\tmm_put_huge_zero_page(mm);\n\tset_mm_exe_file(mm, NULL);\n\tif (!list_empty(&mm->mmlist)) {\n\t\tspin_lock(&mmlist_lock);\n\t\tlist_del(&mm->mmlist);\n\t\tspin_unlock(&mmlist_lock);\n\t}\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\tlru_gen_del_mm(mm);\n\tmmdrop(mm);\n}\n\n \nvoid mmput(struct mm_struct *mm)\n{\n\tmight_sleep();\n\n\tif (atomic_dec_and_test(&mm->mm_users))\n\t\t__mmput(mm);\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n#ifdef CONFIG_MMU\nstatic void mmput_async_fn(struct work_struct *work)\n{\n\tstruct mm_struct *mm = container_of(work, struct mm_struct,\n\t\t\t\t\t    async_put_work);\n\n\t__mmput(mm);\n}\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}\nEXPORT_SYMBOL_GPL(mmput_async);\n#endif\n\n \nint set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tstruct file *old_exe_file;\n\n\t \n\told_exe_file = rcu_dereference_raw(mm->exe_file);\n\n\tif (new_exe_file) {\n\t\t \n\t\tif (unlikely(deny_write_access(new_exe_file)))\n\t\t\treturn -EACCES;\n\t\tget_file(new_exe_file);\n\t}\n\trcu_assign_pointer(mm->exe_file, new_exe_file);\n\tif (old_exe_file) {\n\t\tallow_write_access(old_exe_file);\n\t\tfput(old_exe_file);\n\t}\n\treturn 0;\n}\n\n \nint replace_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tstruct vm_area_struct *vma;\n\tstruct file *old_exe_file;\n\tint ret = 0;\n\n\t \n\told_exe_file = get_mm_exe_file(mm);\n\tif (old_exe_file) {\n\t\tVMA_ITERATOR(vmi, mm, 0);\n\t\tmmap_read_lock(mm);\n\t\tfor_each_vma(vmi, vma) {\n\t\t\tif (!vma->vm_file)\n\t\t\t\tcontinue;\n\t\t\tif (path_equal(&vma->vm_file->f_path,\n\t\t\t\t       &old_exe_file->f_path)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmmap_read_unlock(mm);\n\t\tfput(old_exe_file);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = deny_write_access(new_exe_file);\n\tif (ret)\n\t\treturn -EACCES;\n\tget_file(new_exe_file);\n\n\t \n\tmmap_write_lock(mm);\n\told_exe_file = rcu_dereference_raw(mm->exe_file);\n\trcu_assign_pointer(mm->exe_file, new_exe_file);\n\tmmap_write_unlock(mm);\n\n\tif (old_exe_file) {\n\t\tallow_write_access(old_exe_file);\n\t\tfput(old_exe_file);\n\t}\n\treturn 0;\n}\n\n \nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}\n\n \nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}\n\n \nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\nstruct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\terr =  down_read_killable(&task->signal->exec_update_lock);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, mode)) {\n\t\tmmput(mm);\n\t\tmm = ERR_PTR(-EACCES);\n\t}\n\tup_read(&task->signal->exec_update_lock);\n\n\treturn mm;\n}\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}\n\nstatic int wait_for_vfork_done(struct task_struct *child,\n\t\t\t\tstruct completion *vfork)\n{\n\tunsigned int state = TASK_UNINTERRUPTIBLE|TASK_KILLABLE|TASK_FREEZABLE;\n\tint killed;\n\n\tcgroup_enter_frozen();\n\tkilled = wait_for_completion_state(vfork, state);\n\tcgroup_leave_frozen(false);\n\n\tif (killed) {\n\t\ttask_lock(child);\n\t\tchild->vfork_done = NULL;\n\t\ttask_unlock(child);\n\t}\n\n\tput_task_struct(child);\n\treturn killed;\n}\n\n \nstatic void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tuprobe_free_utask(tsk);\n\n\t \n\tdeactivate_mm(tsk, mm);\n\n\t \n\tif (tsk->clear_child_tid) {\n\t\tif (atomic_read(&mm->mm_users) > 1) {\n\t\t\t \n\t\t\tput_user(0, tsk->clear_child_tid);\n\t\t\tdo_futex(tsk->clear_child_tid, FUTEX_WAKE,\n\t\t\t\t\t1, NULL, NULL, 0, 0);\n\t\t}\n\t\ttsk->clear_child_tid = NULL;\n\t}\n\n\t \n\tif (tsk->vfork_done)\n\t\tcomplete_vfork_done(tsk);\n}\n\nvoid exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exit_release(tsk);\n\tmm_release(tsk, mm);\n}\n\nvoid exec_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exec_release(tsk);\n\tmm_release(tsk, mm);\n}\n\n \nstatic struct mm_struct *dup_mm(struct task_struct *tsk,\n\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t \n\tmm->binfmt = NULL;\n\tmm_init_owner(mm, NULL);\n\tmmput(mm);\n\nfail_nomem:\n\treturn NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n\ttsk->last_switch_time = 0;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t \n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t} else {\n\t\tmm = dup_mm(tsk, current->mm);\n\t\tif (!mm)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tsched_mm_cid_fork(tsk);\n\treturn 0;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct fs_struct *fs = current->fs;\n\tif (clone_flags & CLONE_FS) {\n\t\t \n\t\tspin_lock(&fs->lock);\n\t\tif (fs->in_exec) {\n\t\t\tspin_unlock(&fs->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfs->users++;\n\t\tspin_unlock(&fs->lock);\n\t\treturn 0;\n\t}\n\ttsk->fs = copy_fs_struct(fs);\n\tif (!tsk->fs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct *tsk,\n\t\t      int no_files)\n{\n\tstruct files_struct *oldf, *newf;\n\tint error = 0;\n\n\t \n\toldf = current->files;\n\tif (!oldf)\n\t\tgoto out;\n\n\tif (no_files) {\n\t\ttsk->files = NULL;\n\t\tgoto out;\n\t}\n\n\tif (clone_flags & CLONE_FILES) {\n\t\tatomic_inc(&oldf->count);\n\t\tgoto out;\n\t}\n\n\tnewf = dup_fd(oldf, NR_OPEN_MAX, &error);\n\tif (!newf)\n\t\tgoto out;\n\n\ttsk->files = newf;\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sighand_struct *sig;\n\n\tif (clone_flags & CLONE_SIGHAND) {\n\t\trefcount_inc(&current->sighand->count);\n\t\treturn 0;\n\t}\n\tsig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\tRCU_INIT_POINTER(tsk->sighand, sig);\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&sig->count, 1);\n\tspin_lock_irq(&current->sighand->siglock);\n\tmemcpy(sig->action, current->sighand->action, sizeof(sig->action));\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t \n\tif (clone_flags & CLONE_CLEAR_SIGHAND)\n\t\tflush_signal_handlers(tsk, 0);\n\n\treturn 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (refcount_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t \n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}\n\n \nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\tstruct posix_cputimers *pct = &sig->posix_cputimers;\n\tunsigned long cpu_limit;\n\n\tcpu_limit = READ_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n\tposix_cputimers_group_init(pct, cpu_limit);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\n\tif (clone_flags & CLONE_THREAD)\n\t\treturn 0;\n\n\tsig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tsig->nr_threads = 1;\n\tsig->quick_threads = 1;\n\tatomic_set(&sig->live, 1);\n\trefcount_set(&sig->sigcnt, 1);\n\n\t \n\tsig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);\n\ttsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);\n\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_HLIST_HEAD(&sig->multiprocess);\n\tseqlock_init(&sig->stats_lock);\n\tprev_cputime_init(&sig->prev_cputime);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->real_timer.function = it_real_fn;\n#endif\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\ttty_audit_fork(sig);\n\tsched_autogroup_fork(sig);\n\n\tsig->oom_score_adj = current->signal->oom_score_adj;\n\tsig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n\tmutex_init(&sig->cred_guard_mutex);\n\tinit_rwsem(&sig->exec_update_lock);\n\n\treturn 0;\n}\n\nstatic void copy_seccomp(struct task_struct *p)\n{\n#ifdef CONFIG_SECCOMP\n\t \n\tassert_spin_locked(&current->sighand->siglock);\n\n\t \n\tget_seccomp_filter(current);\n\tp->seccomp = current->seccomp;\n\n\t \n\tif (task_no_new_privs(current))\n\t\ttask_set_no_new_privs(p);\n\n\t \n\tif (p->seccomp.mode != SECCOMP_MODE_DISABLED)\n\t\tset_task_syscall_work(p, SECCOMP);\n#endif\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}\n\nstatic inline void\ninit_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)\n{\n\tif (type == PIDTYPE_PID)\n\t\ttask->thread_pid = pid;\n\telse\n\t\ttask->signal->pids[type] = pid;\n}\n\nstatic inline void rcu_copy_process(struct task_struct *p)\n{\n#ifdef CONFIG_PREEMPT_RCU\n\tp->rcu_read_lock_nesting = 0;\n\tp->rcu_read_unlock_special.s = 0;\n\tp->rcu_blocked_node = NULL;\n\tINIT_LIST_HEAD(&p->rcu_node_entry);\n#endif  \n#ifdef CONFIG_TASKS_RCU\n\tp->rcu_tasks_holdout = false;\n\tINIT_LIST_HEAD(&p->rcu_tasks_holdout_list);\n\tp->rcu_tasks_idle_cpu = -1;\n#endif  \n#ifdef CONFIG_TASKS_TRACE_RCU\n\tp->trc_reader_nesting = 0;\n\tp->trc_reader_special.s = 0;\n\tINIT_LIST_HEAD(&p->trc_holdout_list);\n\tINIT_LIST_HEAD(&p->trc_blkd_node);\n#endif  \n}\n\nstruct pid *pidfd_pid(const struct file *file)\n{\n\tif (file->f_op == &pidfd_fops)\n\t\treturn file->private_data;\n\n\treturn ERR_PTR(-EBADF);\n}\n\nstatic int pidfd_release(struct inode *inode, struct file *file)\n{\n\tstruct pid *pid = file->private_data;\n\n\tfile->private_data = NULL;\n\tput_pid(pid);\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n \nstatic void pidfd_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct pid *pid = f->private_data;\n\tstruct pid_namespace *ns;\n\tpid_t nr = -1;\n\n\tif (likely(pid_has_task(pid, PIDTYPE_PID))) {\n\t\tns = proc_pid_ns(file_inode(m->file)->i_sb);\n\t\tnr = pid_nr_ns(pid, ns);\n\t}\n\n\tseq_put_decimal_ll(m, \"Pid:\\t\", nr);\n\n#ifdef CONFIG_PID_NS\n\tseq_put_decimal_ll(m, \"\\nNSpid:\\t\", nr);\n\tif (nr > 0) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = ns->level + 1; i <= pid->level; i++)\n\t\t\tseq_put_decimal_ll(m, \"\\t\", pid->numbers[i].nr);\n\t}\n#endif\n\tseq_putc(m, '\\n');\n}\n#endif\n\n \nstatic __poll_t pidfd_poll(struct file *file, struct poll_table_struct *pts)\n{\n\tstruct pid *pid = file->private_data;\n\t__poll_t poll_flags = 0;\n\n\tpoll_wait(file, &pid->wait_pidfd, pts);\n\n\t \n\tif (thread_group_exited(pid))\n\t\tpoll_flags = EPOLLIN | EPOLLRDNORM;\n\n\treturn poll_flags;\n}\n\nconst struct file_operations pidfd_fops = {\n\t.release = pidfd_release,\n\t.poll = pidfd_poll,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = pidfd_show_fdinfo,\n#endif\n};\n\n \nstatic int __pidfd_prepare(struct pid *pid, unsigned int flags, struct file **ret)\n{\n\tint pidfd;\n\tstruct file *pidfd_file;\n\n\tif (flags & ~(O_NONBLOCK | O_RDWR | O_CLOEXEC))\n\t\treturn -EINVAL;\n\n\tpidfd = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\tif (pidfd < 0)\n\t\treturn pidfd;\n\n\tpidfd_file = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n\t\t\t\t\tflags | O_RDWR | O_CLOEXEC);\n\tif (IS_ERR(pidfd_file)) {\n\t\tput_unused_fd(pidfd);\n\t\treturn PTR_ERR(pidfd_file);\n\t}\n\tget_pid(pid);  \n\t*ret = pidfd_file;\n\treturn pidfd;\n}\n\n \nint pidfd_prepare(struct pid *pid, unsigned int flags, struct file **ret)\n{\n\tif (!pid || !pid_has_task(pid, PIDTYPE_TGID))\n\t\treturn -EINVAL;\n\n\treturn __pidfd_prepare(pid, flags, ret);\n}\n\nstatic void __delayed_free_task(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tfree_task(tsk);\n}\n\nstatic __always_inline void delayed_free_task(struct task_struct *tsk)\n{\n\tif (IS_ENABLED(CONFIG_MEMCG))\n\t\tcall_rcu(&tsk->rcu, __delayed_free_task);\n\telse\n\t\tfree_task(tsk);\n}\n\nstatic void copy_oom_score_adj(u64 clone_flags, struct task_struct *tsk)\n{\n\t \n\tif (!tsk->mm)\n\t\treturn;\n\n\t \n\tif ((clone_flags & (CLONE_VM | CLONE_THREAD | CLONE_VFORK)) != CLONE_VM)\n\t\treturn;\n\n\t \n\tmutex_lock(&oom_adj_mutex);\n\tset_bit(MMF_MULTIPROCESS, &tsk->mm->flags);\n\t \n\ttsk->signal->oom_score_adj = current->signal->oom_score_adj;\n\ttsk->signal->oom_score_adj_min = current->signal->oom_score_adj_min;\n\tmutex_unlock(&oom_adj_mutex);\n}\n\n#ifdef CONFIG_RV\nstatic void rv_task_fork(struct task_struct *p)\n{\n\tint i;\n\n\tfor (i = 0; i < RV_PER_TASK_MONITORS; i++)\n\t\tp->rv[i].da_mon.monitoring = false;\n}\n#else\n#define rv_task_fork(p) do {} while (0)\n#endif\n\n \n__latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tconst u64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t \n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t \n\t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (task_sigpending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\tp->flags &= ~PF_KTHREAD;\n\tif (args->kthread)\n\t\tp->flags |= PF_KTHREAD;\n\tif (args->user_worker) {\n\t\t \n\t\tp->flags |= PF_USER_WORKER;\n\t\tsiginitsetinv(&p->blocked, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t}\n\tif (args->io_thread)\n\t\tp->flags |= PF_IO_WORKER;\n\n\tif (args->name)\n\t\tstrscpy_pad(p->comm, args->name, sizeof(p->comm));\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t \n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\tretval = -EAGAIN;\n\tif (is_rlimit_overlimit(task_ucounts(p), UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC))) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_cleanup_count;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\t \n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t \n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE | PF_NO_SETAFFINITY);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n\tif (args->kthread) {\n\t\tif (!set_kthread_struct(p))\n\t\t\tgoto bad_fork_cleanup_delayacct;\n\t}\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_delayacct;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL;  \n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n#ifdef CONFIG_BPF_SYSCALL\n\tRCU_INIT_POINTER(p->bpf_storage, NULL);\n\tp->bpf_ctx = NULL;\n#endif\n\n\t \n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t \n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p, args->no_files);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(p, args);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t \n\tif (clone_flags & CLONE_PIDFD) {\n\t\t \n\t\tretval = __pidfd_prepare(pid, O_RDWR | O_CLOEXEC, &pidfile);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\t\tpidfd = retval;\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t \n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t \n\tuser_disable_single_step(p);\n\tclear_task_syscall_work(p, SYSCALL_TRACE);\n#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)\n\tclear_task_syscall_work(p, SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t \n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\tclear_posix_cputimers_work(p);\n\n#ifdef CONFIG_KRETPROBES\n\tp->kretprobe_instances.first = NULL;\n#endif\n#ifdef CONFIG_RETHOOK\n\tp->rethooks.first = NULL;\n#endif\n\n\t \n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t \n\tsched_cgroup_fork(p, args);\n\n\t \n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t \n\twrite_lock_irq(&tasklist_lock);\n\n\t \n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tp->exit_signal = -1;\n\t\telse\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t\tp->exit_signal = args->exit_signal;\n\t}\n\n\tklp_copy_process(p);\n\n\tsched_core_fork(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\trv_task_fork(p);\n\n\trseq_fork(p, clone_flags);\n\n\t \n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t \n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t \n\n\t \n\tcopy_seccomp(p);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t \n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tcurrent->signal->quick_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\tuser_events_fork(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tsched_core_free(p);\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p);  \nbad_fork_cleanup_files:\n\texit_files(p);  \nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\n#endif\nbad_fork_cleanup_delayacct:\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\texit_creds(p);\nbad_fork_free:\n\tWRITE_ONCE(p->__state, TASK_DEAD);\n\texit_task_stack_account(p);\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}\n\nstatic inline void init_idle_pids(struct task_struct *idle)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&idle->pid_links[type]);  \n\t\tinit_task_pid(idle, type, &init_struct_pid);\n\t}\n}\n\nstatic int idle_dummy(void *dummy)\n{\n\t \n\treturn 0;\n}\n\nstruct task_struct * __init fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= CLONE_VM,\n\t\t.fn\t\t= &idle_dummy,\n\t\t.fn_arg\t\t= NULL,\n\t\t.kthread\t= 1,\n\t\t.idle\t\t= 1,\n\t};\n\n\ttask = copy_process(&init_struct_pid, 0, cpu_to_node(cpu), &args);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}\n\n \nstruct task_struct *create_io_thread(int (*fn)(void *), void *arg, int node)\n{\n\tunsigned long flags = CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|\n\t\t\t\tCLONE_IO;\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.fn\t\t= fn,\n\t\t.fn_arg\t\t= arg,\n\t\t.io_thread\t= 1,\n\t\t.user_worker\t= 1,\n\t};\n\n\treturn copy_process(NULL, 0, node, &args);\n}\n\n \npid_t kernel_clone(struct kernel_clone_args *args)\n{\n\tu64 clone_flags = args->flags;\n\tstruct completion vfork;\n\tstruct pid *pid;\n\tstruct task_struct *p;\n\tint trace = 0;\n\tpid_t nr;\n\n\t \n\tif ((args->flags & CLONE_PIDFD) &&\n\t    (args->flags & CLONE_PARENT_SETTID) &&\n\t    (args->pidfd == args->parent_tid))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if (args->exit_signal != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);\n\tadd_latent_entropy();\n\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\t \n\ttrace_sched_process_fork(current, p);\n\n\tpid = get_task_pid(p, PIDTYPE_PID);\n\tnr = pid_vnr(pid);\n\n\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\tput_user(nr, args->parent_tid);\n\n\tif (clone_flags & CLONE_VFORK) {\n\t\tp->vfork_done = &vfork;\n\t\tinit_completion(&vfork);\n\t\tget_task_struct(p);\n\t}\n\n\tif (IS_ENABLED(CONFIG_LRU_GEN) && !(clone_flags & CLONE_VM)) {\n\t\t \n\t\ttask_lock(p);\n\t\tlru_gen_add_mm(p->mm);\n\t\ttask_unlock(p);\n\t}\n\n\twake_up_new_task(p);\n\n\t \n\tif (unlikely(trace))\n\t\tptrace_event_pid(trace, pid);\n\n\tif (clone_flags & CLONE_VFORK) {\n\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\tptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);\n\t}\n\n\tput_pid(pid);\n\treturn nr;\n}\n\n \npid_t kernel_thread(int (*fn)(void *), void *arg, const char *name,\n\t\t    unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.fn\t\t= fn,\n\t\t.fn_arg\t\t= arg,\n\t\t.name\t\t= name,\n\t\t.kthread\t= 1,\n\t};\n\n\treturn kernel_clone(&args);\n}\n\n \npid_t user_mode_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= ((lower_32_bits(flags) | CLONE_VM |\n\t\t\t\t    CLONE_UNTRACED) & ~CSIGNAL),\n\t\t.exit_signal\t= (lower_32_bits(flags) & CSIGNAL),\n\t\t.fn\t\t= fn,\n\t\t.fn_arg\t\t= arg,\n\t};\n\n\treturn kernel_clone(&args);\n}\n\n#ifdef __ARCH_WANT_SYS_FORK\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n\tstruct kernel_clone_args args = {\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\treturn kernel_clone(&args);\n#else\n\t \n\treturn -EINVAL;\n#endif\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_VFORK\nSYSCALL_DEFINE0(vfork)\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= CLONE_VFORK | CLONE_VM,\n\t\t.exit_signal\t= SIGCHLD,\n\t};\n\n\treturn kernel_clone(&args);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE\n#ifdef CONFIG_CLONE_BACKWARDS\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t unsigned long, tls,\n\t\t int __user *, child_tidptr)\n#elif defined(CONFIG_CLONE_BACKWARDS2)\nSYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#elif defined(CONFIG_CLONE_BACKWARDS3)\nSYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\tint, stack_size,\n\t\tint __user *, parent_tidptr,\n\t\tint __user *, child_tidptr,\n\t\tunsigned long, tls)\n#else\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#endif\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= (lower_32_bits(clone_flags) & ~CSIGNAL),\n\t\t.pidfd\t\t= parent_tidptr,\n\t\t.child_tid\t= child_tidptr,\n\t\t.parent_tid\t= parent_tidptr,\n\t\t.exit_signal\t= (lower_32_bits(clone_flags) & CSIGNAL),\n\t\t.stack\t\t= newsp,\n\t\t.tls\t\t= tls,\n\t};\n\n\treturn kernel_clone(&args);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_CLONE3\n\nnoinline static int copy_clone_args_from_user(struct kernel_clone_args *kargs,\n\t\t\t\t\t      struct clone_args __user *uargs,\n\t\t\t\t\t      size_t usize)\n{\n\tint err;\n\tstruct clone_args args;\n\tpid_t *kset_tid = kargs->set_tid;\n\n\tBUILD_BUG_ON(offsetofend(struct clone_args, tls) !=\n\t\t     CLONE_ARGS_SIZE_VER0);\n\tBUILD_BUG_ON(offsetofend(struct clone_args, set_tid_size) !=\n\t\t     CLONE_ARGS_SIZE_VER1);\n\tBUILD_BUG_ON(offsetofend(struct clone_args, cgroup) !=\n\t\t     CLONE_ARGS_SIZE_VER2);\n\tBUILD_BUG_ON(sizeof(struct clone_args) != CLONE_ARGS_SIZE_VER2);\n\n\tif (unlikely(usize > PAGE_SIZE))\n\t\treturn -E2BIG;\n\tif (unlikely(usize < CLONE_ARGS_SIZE_VER0))\n\t\treturn -EINVAL;\n\n\terr = copy_struct_from_user(&args, sizeof(args), uargs, usize);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(args.set_tid_size > MAX_PID_NS_LEVEL))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!args.set_tid && args.set_tid_size > 0))\n\t\treturn -EINVAL;\n\n\tif (unlikely(args.set_tid && args.set_tid_size == 0))\n\t\treturn -EINVAL;\n\n\t \n\tif (unlikely((args.exit_signal & ~((u64)CSIGNAL)) ||\n\t\t     !valid_signal(args.exit_signal)))\n\t\treturn -EINVAL;\n\n\tif ((args.flags & CLONE_INTO_CGROUP) &&\n\t    (args.cgroup > INT_MAX || usize < CLONE_ARGS_SIZE_VER2))\n\t\treturn -EINVAL;\n\n\t*kargs = (struct kernel_clone_args){\n\t\t.flags\t\t= args.flags,\n\t\t.pidfd\t\t= u64_to_user_ptr(args.pidfd),\n\t\t.child_tid\t= u64_to_user_ptr(args.child_tid),\n\t\t.parent_tid\t= u64_to_user_ptr(args.parent_tid),\n\t\t.exit_signal\t= args.exit_signal,\n\t\t.stack\t\t= args.stack,\n\t\t.stack_size\t= args.stack_size,\n\t\t.tls\t\t= args.tls,\n\t\t.set_tid_size\t= args.set_tid_size,\n\t\t.cgroup\t\t= args.cgroup,\n\t};\n\n\tif (args.set_tid &&\n\t\tcopy_from_user(kset_tid, u64_to_user_ptr(args.set_tid),\n\t\t\t(kargs->set_tid_size * sizeof(pid_t))))\n\t\treturn -EFAULT;\n\n\tkargs->set_tid = kset_tid;\n\n\treturn 0;\n}\n\n \nstatic inline bool clone3_stack_valid(struct kernel_clone_args *kargs)\n{\n\tif (kargs->stack == 0) {\n\t\tif (kargs->stack_size > 0)\n\t\t\treturn false;\n\t} else {\n\t\tif (kargs->stack_size == 0)\n\t\t\treturn false;\n\n\t\tif (!access_ok((void __user *)kargs->stack, kargs->stack_size))\n\t\t\treturn false;\n\n#if !defined(CONFIG_STACK_GROWSUP) && !defined(CONFIG_IA64)\n\t\tkargs->stack += kargs->stack_size;\n#endif\n\t}\n\n\treturn true;\n}\n\nstatic bool clone3_args_valid(struct kernel_clone_args *kargs)\n{\n\t \n\tif (kargs->flags &\n\t    ~(CLONE_LEGACY_FLAGS | CLONE_CLEAR_SIGHAND | CLONE_INTO_CGROUP))\n\t\treturn false;\n\n\t \n\tif (kargs->flags & (CLONE_DETACHED | (CSIGNAL & (~CLONE_NEWTIME))))\n\t\treturn false;\n\n\tif ((kargs->flags & (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND)) ==\n\t    (CLONE_SIGHAND | CLONE_CLEAR_SIGHAND))\n\t\treturn false;\n\n\tif ((kargs->flags & (CLONE_THREAD | CLONE_PARENT)) &&\n\t    kargs->exit_signal)\n\t\treturn false;\n\n\tif (!clone3_stack_valid(kargs))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nSYSCALL_DEFINE2(clone3, struct clone_args __user *, uargs, size_t, size)\n{\n\tint err;\n\n\tstruct kernel_clone_args kargs;\n\tpid_t set_tid[MAX_PID_NS_LEVEL];\n\n\tkargs.set_tid = set_tid;\n\n\terr = copy_clone_args_from_user(&kargs, uargs, size);\n\tif (err)\n\t\treturn err;\n\n\tif (!clone3_args_valid(&kargs))\n\t\treturn -EINVAL;\n\n\treturn kernel_clone(&kargs);\n}\n#endif\n\nvoid walk_process_tree(struct task_struct *top, proc_visitor visitor, void *data)\n{\n\tstruct task_struct *leader, *parent, *child;\n\tint res;\n\n\tread_lock(&tasklist_lock);\n\tleader = top = top->group_leader;\ndown:\n\tfor_each_thread(leader, parent) {\n\t\tlist_for_each_entry(child, &parent->children, sibling) {\n\t\t\tres = visitor(child, data);\n\t\t\tif (res) {\n\t\t\t\tif (res < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tleader = child;\n\t\t\t\tgoto down;\n\t\t\t}\nup:\n\t\t\t;\n\t\t}\n\t}\n\n\tif (leader != top) {\n\t\tchild = leader;\n\t\tparent = child->real_parent;\n\t\tleader = parent->group_leader;\n\t\tgoto up;\n\t}\nout:\n\tread_unlock(&tasklist_lock);\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n\tstruct sighand_struct *sighand = data;\n\n\tspin_lock_init(&sighand->siglock);\n\tinit_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init mm_cache_init(void)\n{\n\tunsigned int mm_size;\n\n\t \n\tmm_size = sizeof(struct mm_struct) + cpumask_size() + mm_cid_size();\n\n\tmm_cachep = kmem_cache_create_usercopy(\"mm_struct\",\n\t\t\tmm_size, ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\toffsetof(struct mm_struct, saved_auxv),\n\t\t\tsizeof_field(struct mm_struct, saved_auxv),\n\t\t\tNULL);\n}\n\nvoid __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_TYPESAFE_BY_RCU|\n\t\t\tSLAB_ACCOUNT, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT,\n\t\t\tNULL);\n\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);\n#ifdef CONFIG_PER_VMA_LOCK\n\tvma_lock_cachep = KMEM_CACHE(vma_lock, SLAB_PANIC|SLAB_ACCOUNT);\n#endif\n\tmmap_init();\n\tnsproxy_cache_init();\n}\n\n \nstatic int check_unshare_flags(unsigned long unshare_flags)\n{\n\tif (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n\t\t\t\tCLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n\t\t\t\tCLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|\n\t\t\t\tCLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|\n\t\t\t\tCLONE_NEWTIME))\n\t\treturn -EINVAL;\n\t \n\tif (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (!thread_group_empty(current))\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {\n\t\tif (refcount_read(&current->sighand->count) > 1)\n\t\t\treturn -EINVAL;\n\t}\n\tif (unshare_flags & CLONE_VM) {\n\t\tif (!current_is_single_threaded())\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\tif (!(unshare_flags & CLONE_FS) || !fs)\n\t\treturn 0;\n\n\t \n\tif (fs->users == 1)\n\t\treturn 0;\n\n\t*new_fsp = copy_fs_struct(fs);\n\tif (!*new_fsp)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nint unshare_fd(unsigned long unshare_flags, unsigned int max_fds,\n\t       struct files_struct **new_fdp)\n{\n\tstruct files_struct *fd = current->files;\n\tint error = 0;\n\n\tif ((unshare_flags & CLONE_FILES) &&\n\t    (fd && atomic_read(&fd->count) > 1)) {\n\t\t*new_fdp = dup_fd(fd, max_fds, &error);\n\t\tif (!*new_fdp)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint ksys_unshare(unsigned long unshare_flags)\n{\n\tstruct fs_struct *fs, *new_fs = NULL;\n\tstruct files_struct *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t \n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t \n\tif (unshare_flags & CLONE_VM)\n\t\tunshare_flags |= CLONE_SIGHAND;\n\t \n\tif (unshare_flags & CLONE_SIGHAND)\n\t\tunshare_flags |= CLONE_THREAD;\n\t \n\tif (unshare_flags & CLONE_NEWNS)\n\t\tunshare_flags |= CLONE_FS;\n\n\terr = check_unshare_flags(unshare_flags);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\t \n\tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n\t\tdo_sysvsem = 1;\n\terr = unshare_fs(unshare_flags, &new_fs);\n\tif (err)\n\t\tgoto bad_unshare_out;\n\terr = unshare_fd(unshare_flags, NR_OPEN_MAX, &new_fd);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fs;\n\terr = unshare_userns(unshare_flags, &new_cred);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_fd;\n\terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,\n\t\t\t\t\t new_cred, new_fs);\n\tif (err)\n\t\tgoto bad_unshare_cleanup_cred;\n\n\tif (new_cred) {\n\t\terr = set_cred_ucounts(new_cred);\n\t\tif (err)\n\t\t\tgoto bad_unshare_cleanup_cred;\n\t}\n\n\tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {\n\t\tif (do_sysvsem) {\n\t\t\t \n\t\t\texit_sem(current);\n\t\t}\n\t\tif (unshare_flags & CLONE_NEWIPC) {\n\t\t\t \n\t\t\texit_shm(current);\n\t\t\tshm_init_task(current);\n\t\t}\n\n\t\tif (new_nsproxy)\n\t\t\tswitch_task_namespaces(current, new_nsproxy);\n\n\t\ttask_lock(current);\n\n\t\tif (new_fs) {\n\t\t\tfs = current->fs;\n\t\t\tspin_lock(&fs->lock);\n\t\t\tcurrent->fs = new_fs;\n\t\t\tif (--fs->users)\n\t\t\t\tnew_fs = NULL;\n\t\t\telse\n\t\t\t\tnew_fs = fs;\n\t\t\tspin_unlock(&fs->lock);\n\t\t}\n\n\t\tif (new_fd)\n\t\t\tswap(current->files, new_fd);\n\n\t\ttask_unlock(current);\n\n\t\tif (new_cred) {\n\t\t\t \n\t\t\tcommit_creds(new_cred);\n\t\t\tnew_cred = NULL;\n\t\t}\n\t}\n\n\tperf_event_namespaces(current);\n\nbad_unshare_cleanup_cred:\n\tif (new_cred)\n\t\tput_cred(new_cred);\nbad_unshare_cleanup_fd:\n\tif (new_fd)\n\t\tput_files_struct(new_fd);\n\nbad_unshare_cleanup_fs:\n\tif (new_fs)\n\t\tfree_fs_struct(new_fs);\n\nbad_unshare_out:\n\treturn err;\n}\n\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n\treturn ksys_unshare(unshare_flags);\n}\n\n \n\nint unshare_files(void)\n{\n\tstruct task_struct *task = current;\n\tstruct files_struct *old, *copy = NULL;\n\tint error;\n\n\terror = unshare_fd(CLONE_FILES, NR_OPEN_MAX, &copy);\n\tif (error || !copy)\n\t\treturn error;\n\n\told = task->files;\n\ttask_lock(task);\n\ttask->files = copy;\n\ttask_unlock(task);\n\tput_files_struct(old);\n\treturn 0;\n}\n\nint sysctl_max_threads(struct ctl_table *table, int write,\n\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint ret;\n\tint threads = max_threads;\n\tint min = 1;\n\tint max = MAX_THREADS;\n\n\tt = *table;\n\tt.data = &threads;\n\tt.extra1 = &min;\n\tt.extra2 = &max;\n\n\tret = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tmax_threads = threads;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}