{
  "module_name": "nsproxy.c",
  "hash_id": "ab78acaea95ae330278295aa0ce0401d322bf9c9107efbb971fa816e8ed8eadd",
  "original_prompt": "Ingested from linux-6.6.14/kernel/nsproxy.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/nsproxy.h>\n#include <linux/init_task.h>\n#include <linux/mnt_namespace.h>\n#include <linux/utsname.h>\n#include <linux/pid_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <linux/time_namespace.h>\n#include <linux/fs_struct.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/file.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/perf_event.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstruct nsproxy init_nsproxy = {\n\t.count\t\t\t= REFCOUNT_INIT(1),\n\t.uts_ns\t\t\t= &init_uts_ns,\n#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)\n\t.ipc_ns\t\t\t= &init_ipc_ns,\n#endif\n\t.mnt_ns\t\t\t= NULL,\n\t.pid_ns_for_children\t= &init_pid_ns,\n#ifdef CONFIG_NET\n\t.net_ns\t\t\t= &init_net,\n#endif\n#ifdef CONFIG_CGROUPS\n\t.cgroup_ns\t\t= &init_cgroup_ns,\n#endif\n#ifdef CONFIG_TIME_NS\n\t.time_ns\t\t= &init_time_ns,\n\t.time_ns_for_children\t= &init_time_ns,\n#endif\n};\n\nstatic inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\trefcount_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}\n\n \nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}\n\n \nint copy_namespaces(unsigned long flags, struct task_struct *tsk)\n{\n\tstruct nsproxy *old_ns = tsk->nsproxy;\n\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);\n\tstruct nsproxy *new_ns;\n\n\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {\n\t\tif ((flags & CLONE_VM) ||\n\t\t    likely(old_ns->time_ns_for_children == old_ns->time_ns)) {\n\t\t\tget_nsproxy(old_ns);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==\n\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))\n\t\treturn -EINVAL;\n\n\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);\n\tif (IS_ERR(new_ns))\n\t\treturn  PTR_ERR(new_ns);\n\n\tif ((flags & CLONE_VM) == 0)\n\t\ttimens_on_fork(new_ns, tsk);\n\n\ttsk->nsproxy = new_ns;\n\treturn 0;\n}\n\nvoid free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tif (ns->time_ns)\n\t\tput_time_ns(ns->time_ns);\n\tif (ns->time_ns_for_children)\n\t\tput_time_ns(ns->time_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}\n\n \nint unshare_nsproxy_namespaces(unsigned long unshare_flags,\n\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)\n{\n\tstruct user_namespace *user_ns;\n\tint err = 0;\n\n\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |\n\t\t\t       CLONE_NEWTIME)))\n\t\treturn 0;\n\n\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,\n\t\t\t\t\t new_fs ? new_fs : current->fs);\n\tif (IS_ERR(*new_nsp)) {\n\t\terr = PTR_ERR(*new_nsp);\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}\n\nvoid exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}\n\nint exec_task_namespaces(void)\n{\n\tstruct task_struct *tsk = current;\n\tstruct nsproxy *new;\n\n\tif (tsk->nsproxy->time_ns_for_children == tsk->nsproxy->time_ns)\n\t\treturn 0;\n\n\tnew = create_new_namespaces(0, tsk, current_user_ns(), tsk->fs);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\ttimens_on_fork(new, tsk);\n\tswitch_task_namespaces(tsk, new);\n\treturn 0;\n}\n\nstatic int check_setns_flags(unsigned long flags)\n{\n\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |\n\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME)\n\t\treturn -EINVAL;\n#endif\n\n\treturn 0;\n}\n\nstatic void put_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\n\tif (flags & CLONE_NEWUSER)\n\t\tput_cred(nsset_cred(nsset));\n\t \n\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))\n\t\tfree_fs_struct(nsset->fs);\n\tif (nsset->nsproxy)\n\t\tfree_nsproxy(nsset->nsproxy);\n}\n\nstatic int prepare_nsset(unsigned flags, struct nsset *nsset)\n{\n\tstruct task_struct *me = current;\n\n\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);\n\tif (IS_ERR(nsset->nsproxy))\n\t\treturn PTR_ERR(nsset->nsproxy);\n\n\tif (flags & CLONE_NEWUSER)\n\t\tnsset->cred = prepare_creds();\n\telse\n\t\tnsset->cred = current_cred();\n\tif (!nsset->cred)\n\t\tgoto out;\n\n\t \n\tif (flags == CLONE_NEWNS) {\n\t\tnsset->fs = me->fs;\n\t} else if (flags & CLONE_NEWNS) {\n\t\tnsset->fs = copy_fs_struct(me->fs);\n\t\tif (!nsset->fs)\n\t\t\tgoto out;\n\t}\n\n\tnsset->flags = flags;\n\treturn 0;\n\nout:\n\tput_nsset(nsset);\n\treturn -ENOMEM;\n}\n\nstatic inline int validate_ns(struct nsset *nsset, struct ns_common *ns)\n{\n\treturn ns->ops->install(nsset, ns);\n}\n\n \nstatic int validate_nsset(struct nsset *nsset, struct pid *pid)\n{\n\tint ret = 0;\n\tunsigned flags = nsset->flags;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct pid_namespace *pid_ns = NULL;\n\tstruct nsproxy *nsp;\n\tstruct task_struct *tsk;\n\n\t \n\trcu_read_lock();\n\ttsk = pid_task(pid, PIDTYPE_PID);\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\n\ttask_lock(tsk);\n\tnsp = tsk->nsproxy;\n\tif (nsp)\n\t\tget_nsproxy(nsp);\n\ttask_unlock(tsk);\n\tif (!nsp) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tpid_ns = task_active_pid_ns(tsk);\n\t\tif (unlikely(!pid_ns)) {\n\t\t\trcu_read_unlock();\n\t\t\tret = -ESRCH;\n\t\t\tgoto out;\n\t\t}\n\t\tget_pid_ns(pid_ns);\n\t}\n#endif\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);\n#endif\n\trcu_read_unlock();\n\n\t \n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\tret = validate_ns(nsset, &user_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (flags & CLONE_NEWNS) {\n\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS) {\n\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC) {\n\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tret = validate_ns(nsset, &pid_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP) {\n\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET) {\n\t\tret = validate_ns(nsset, &nsp->net_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME) {\n\t\tret = validate_ns(nsset, &nsp->time_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\nout:\n\tif (pid_ns)\n\t\tput_pid_ns(pid_ns);\n\tif (nsp)\n\t\tput_nsproxy(nsp);\n\tput_user_ns(user_ns);\n\n\treturn ret;\n}\n\n \nstatic void commit_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\tstruct task_struct *me = current;\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\t \n\t\tcommit_creds(nsset_cred(nsset));\n\t\tnsset->cred = NULL;\n\t}\n#endif\n\n\t \n\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {\n\t\tset_fs_root(me->fs, &nsset->fs->root);\n\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);\n\t}\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC)\n\t\texit_sem(me);\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME)\n\t\ttimens_commit(me, nsset->nsproxy->time_ns);\n#endif\n\n\t \n\tswitch_task_namespaces(me, nsset->nsproxy);\n\tnsset->nsproxy = NULL;\n}\n\nSYSCALL_DEFINE2(setns, int, fd, int, flags)\n{\n\tstruct fd f = fdget(fd);\n\tstruct ns_common *ns = NULL;\n\tstruct nsset nsset = {};\n\tint err = 0;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tif (proc_ns_file(f.file)) {\n\t\tns = get_proc_ns(file_inode(f.file));\n\t\tif (flags && (ns->ops->type != flags))\n\t\t\terr = -EINVAL;\n\t\tflags = ns->ops->type;\n\t} else if (!IS_ERR(pidfd_pid(f.file))) {\n\t\terr = check_setns_flags(flags);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\terr = prepare_nsset(flags, &nsset);\n\tif (err)\n\t\tgoto out;\n\n\tif (proc_ns_file(f.file))\n\t\terr = validate_ns(&nsset, ns);\n\telse\n\t\terr = validate_nsset(&nsset, f.file->private_data);\n\tif (!err) {\n\t\tcommit_nsset(&nsset);\n\t\tperf_event_namespaces(current);\n\t}\n\tput_nsset(&nsset);\nout:\n\tfdput(f);\n\treturn err;\n}\n\nint __init nsproxy_cache_init(void)\n{\n\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}