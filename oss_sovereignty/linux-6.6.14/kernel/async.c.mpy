{
  "module_name": "async.c",
  "hash_id": "c745e67b2597aefd6d96fb8ffba55e9263dc2712553afc6d2eac081dff8b4b66",
  "original_prompt": "Ingested from linux-6.6.14/kernel/async.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/async.h>\n#include <linux/atomic.h>\n#include <linux/ktime.h>\n#include <linux/export.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"workqueue_internal.h\"\n\nstatic async_cookie_t next_cookie = 1;\n\n#define MAX_WORK\t\t32768\n#define ASYNC_COOKIE_MAX\tULLONG_MAX\t \n\nstatic LIST_HEAD(async_global_pending);\t \nstatic ASYNC_DOMAIN(async_dfl_domain);\nstatic DEFINE_SPINLOCK(async_lock);\n\nstruct async_entry {\n\tstruct list_head\tdomain_list;\n\tstruct list_head\tglobal_list;\n\tstruct work_struct\twork;\n\tasync_cookie_t\t\tcookie;\n\tasync_func_t\t\tfunc;\n\tvoid\t\t\t*data;\n\tstruct async_domain\t*domain;\n};\n\nstatic DECLARE_WAIT_QUEUE_HEAD(async_done);\n\nstatic atomic_t entry_count;\n\nstatic long long microseconds_since(ktime_t start)\n{\n\tktime_t now = ktime_get();\n\treturn ktime_to_ns(ktime_sub(now, start)) >> 10;\n}\n\nstatic async_cookie_t lowest_in_progress(struct async_domain *domain)\n{\n\tstruct async_entry *first = NULL;\n\tasync_cookie_t ret = ASYNC_COOKIE_MAX;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\tif (domain) {\n\t\tif (!list_empty(&domain->pending))\n\t\t\tfirst = list_first_entry(&domain->pending,\n\t\t\t\t\tstruct async_entry, domain_list);\n\t} else {\n\t\tif (!list_empty(&async_global_pending))\n\t\t\tfirst = list_first_entry(&async_global_pending,\n\t\t\t\t\tstruct async_entry, global_list);\n\t}\n\n\tif (first)\n\t\tret = first->cookie;\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\treturn ret;\n}\n\n \nstatic void async_run_entry_fn(struct work_struct *work)\n{\n\tstruct async_entry *entry =\n\t\tcontainer_of(work, struct async_entry, work);\n\tunsigned long flags;\n\tktime_t calltime;\n\n\t \n\tpr_debug(\"calling  %lli_%pS @ %i\\n\", (long long)entry->cookie,\n\t\t entry->func, task_pid_nr(current));\n\tcalltime = ktime_get();\n\n\tentry->func(entry->data, entry->cookie);\n\n\tpr_debug(\"initcall %lli_%pS returned after %lld usecs\\n\",\n\t\t (long long)entry->cookie, entry->func,\n\t\t microseconds_since(calltime));\n\n\t \n\tspin_lock_irqsave(&async_lock, flags);\n\tlist_del_init(&entry->domain_list);\n\tlist_del_init(&entry->global_list);\n\n\t \n\tkfree(entry);\n\tatomic_dec(&entry_count);\n\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t \n\twake_up(&async_done);\n}\n\n \nasync_cookie_t async_schedule_node_domain(async_func_t func, void *data,\n\t\t\t\t\t  int node, struct async_domain *domain)\n{\n\tstruct async_entry *entry;\n\tunsigned long flags;\n\tasync_cookie_t newcookie;\n\n\t \n\tentry = kzalloc(sizeof(struct async_entry), GFP_ATOMIC);\n\n\t \n\tif (!entry || atomic_read(&entry_count) > MAX_WORK) {\n\t\tkfree(entry);\n\t\tspin_lock_irqsave(&async_lock, flags);\n\t\tnewcookie = next_cookie++;\n\t\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t\t \n\t\tfunc(data, newcookie);\n\t\treturn newcookie;\n\t}\n\tINIT_LIST_HEAD(&entry->domain_list);\n\tINIT_LIST_HEAD(&entry->global_list);\n\tINIT_WORK(&entry->work, async_run_entry_fn);\n\tentry->func = func;\n\tentry->data = data;\n\tentry->domain = domain;\n\n\tspin_lock_irqsave(&async_lock, flags);\n\n\t \n\tnewcookie = entry->cookie = next_cookie++;\n\n\tlist_add_tail(&entry->domain_list, &domain->pending);\n\tif (domain->registered)\n\t\tlist_add_tail(&entry->global_list, &async_global_pending);\n\n\tatomic_inc(&entry_count);\n\tspin_unlock_irqrestore(&async_lock, flags);\n\n\t \n\tqueue_work_node(node, system_unbound_wq, &entry->work);\n\n\treturn newcookie;\n}\nEXPORT_SYMBOL_GPL(async_schedule_node_domain);\n\n \nasync_cookie_t async_schedule_node(async_func_t func, void *data, int node)\n{\n\treturn async_schedule_node_domain(func, data, node, &async_dfl_domain);\n}\nEXPORT_SYMBOL_GPL(async_schedule_node);\n\n \nvoid async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}\nEXPORT_SYMBOL_GPL(async_synchronize_full);\n\n \nvoid async_synchronize_full_domain(struct async_domain *domain)\n{\n\tasync_synchronize_cookie_domain(ASYNC_COOKIE_MAX, domain);\n}\nEXPORT_SYMBOL_GPL(async_synchronize_full_domain);\n\n \nvoid async_synchronize_cookie_domain(async_cookie_t cookie, struct async_domain *domain)\n{\n\tktime_t starttime;\n\n\tpr_debug(\"async_waiting @ %i\\n\", task_pid_nr(current));\n\tstarttime = ktime_get();\n\n\twait_event(async_done, lowest_in_progress(domain) >= cookie);\n\n\tpr_debug(\"async_continuing @ %i after %lli usec\\n\", task_pid_nr(current),\n\t\t microseconds_since(starttime));\n}\nEXPORT_SYMBOL_GPL(async_synchronize_cookie_domain);\n\n \nvoid async_synchronize_cookie(async_cookie_t cookie)\n{\n\tasync_synchronize_cookie_domain(cookie, &async_dfl_domain);\n}\nEXPORT_SYMBOL_GPL(async_synchronize_cookie);\n\n \nbool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}\nEXPORT_SYMBOL_GPL(current_is_async);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}