{
  "module_name": "kcov.c",
  "hash_id": "f08c87f433cf8fab3da52d480197dd28ca90882a595d888179c422c33f510aa8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcov.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"kcov: \" fmt\n\n#define DISABLE_BRANCH_PROFILING\n#include <linux/atomic.h>\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/hashtable.h>\n#include <linux/init.h>\n#include <linux/kmsan-checks.h>\n#include <linux/mm.h>\n#include <linux/preempt.h>\n#include <linux/printk.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/kcov.h>\n#include <linux/refcount.h>\n#include <linux/log2.h>\n#include <asm/setup.h>\n\n#define kcov_debug(fmt, ...) pr_debug(\"%s: \" fmt, __func__, ##__VA_ARGS__)\n\n \n#define KCOV_WORDS_PER_CMP 4\n\n \nstruct kcov {\n\t \n\trefcount_t\t\trefcount;\n\t \n\tspinlock_t\t\tlock;\n\tenum kcov_mode\t\tmode;\n\t \n\tunsigned int\t\tsize;\n\t \n\tvoid\t\t\t*area;\n\t \n\tstruct task_struct\t*t;\n\t \n\tbool\t\t\tremote;\n\t \n\tunsigned int\t\tremote_size;\n\t \n\tint\t\t\tsequence;\n};\n\nstruct kcov_remote_area {\n\tstruct list_head\tlist;\n\tunsigned int\t\tsize;\n};\n\nstruct kcov_remote {\n\tu64\t\t\thandle;\n\tstruct kcov\t\t*kcov;\n\tstruct hlist_node\thnode;\n};\n\nstatic DEFINE_SPINLOCK(kcov_remote_lock);\nstatic DEFINE_HASHTABLE(kcov_remote_map, 4);\nstatic struct list_head kcov_remote_areas = LIST_HEAD_INIT(kcov_remote_areas);\n\nstruct kcov_percpu_data {\n\tvoid\t\t\t*irq_area;\n\tlocal_lock_t\t\tlock;\n\n\tunsigned int\t\tsaved_mode;\n\tunsigned int\t\tsaved_size;\n\tvoid\t\t\t*saved_area;\n\tstruct kcov\t\t*saved_kcov;\n\tint\t\t\tsaved_sequence;\n};\n\nstatic DEFINE_PER_CPU(struct kcov_percpu_data, kcov_percpu_data) = {\n\t.lock = INIT_LOCAL_LOCK(lock),\n};\n\n \nstatic struct kcov_remote *kcov_remote_find(u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\thash_for_each_possible(kcov_remote_map, remote, hnode, handle) {\n\t\tif (remote->handle == handle)\n\t\t\treturn remote;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct kcov_remote *kcov_remote_add(struct kcov *kcov, u64 handle)\n{\n\tstruct kcov_remote *remote;\n\n\tif (kcov_remote_find(handle))\n\t\treturn ERR_PTR(-EEXIST);\n\tremote = kmalloc(sizeof(*remote), GFP_ATOMIC);\n\tif (!remote)\n\t\treturn ERR_PTR(-ENOMEM);\n\tremote->handle = handle;\n\tremote->kcov = kcov;\n\thash_add(kcov_remote_map, &remote->hnode, handle);\n\treturn remote;\n}\n\n \nstatic struct kcov_remote_area *kcov_remote_area_get(unsigned int size)\n{\n\tstruct kcov_remote_area *area;\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, &kcov_remote_areas) {\n\t\tarea = list_entry(pos, struct kcov_remote_area, list);\n\t\tif (area->size == size) {\n\t\t\tlist_del(&area->list);\n\t\t\treturn area;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void kcov_remote_area_put(struct kcov_remote_area *area,\n\t\t\t\t\tunsigned int size)\n{\n\tINIT_LIST_HEAD(&area->list);\n\tarea->size = size;\n\tlist_add(&area->list, &kcov_remote_areas);\n\t \n\tkmsan_unpoison_memory(&area->list, sizeof(area->list));\n}\n\nstatic notrace bool check_kcov_mode(enum kcov_mode needed_mode, struct task_struct *t)\n{\n\tunsigned int mode;\n\n\t \n\tif (!in_task() && !(in_serving_softirq() && t->kcov_softirq))\n\t\treturn false;\n\tmode = READ_ONCE(t->kcov_mode);\n\t \n\tbarrier();\n\treturn mode == needed_mode;\n}\n\nstatic notrace unsigned long canonicalize_ip(unsigned long ip)\n{\n#ifdef CONFIG_RANDOMIZE_BASE\n\tip -= kaslr_offset();\n#endif\n\treturn ip;\n}\n\n \nvoid notrace __sanitizer_cov_trace_pc(void)\n{\n\tstruct task_struct *t;\n\tunsigned long *area;\n\tunsigned long ip = canonicalize_ip(_RET_IP_);\n\tunsigned long pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))\n\t\treturn;\n\n\tarea = t->kcov_area;\n\t \n\tpos = READ_ONCE(area[0]) + 1;\n\tif (likely(pos < t->kcov_size)) {\n\t\t \n\t\tWRITE_ONCE(area[0], pos);\n\t\tbarrier();\n\t\tarea[pos] = ip;\n\t}\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_pc);\n\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\nstatic void notrace write_comp_data(u64 type, u64 arg1, u64 arg2, u64 ip)\n{\n\tstruct task_struct *t;\n\tu64 *area;\n\tu64 count, start_index, end_pos, max_pos;\n\n\tt = current;\n\tif (!check_kcov_mode(KCOV_MODE_TRACE_CMP, t))\n\t\treturn;\n\n\tip = canonicalize_ip(ip);\n\n\t \n\tarea = (u64 *)t->kcov_area;\n\tmax_pos = t->kcov_size * sizeof(unsigned long);\n\n\tcount = READ_ONCE(area[0]);\n\n\t \n\tstart_index = 1 + count * KCOV_WORDS_PER_CMP;\n\tend_pos = (start_index + KCOV_WORDS_PER_CMP) * sizeof(u64);\n\tif (likely(end_pos <= max_pos)) {\n\t\t \n\t\tWRITE_ONCE(area[0], count + 1);\n\t\tbarrier();\n\t\tarea[start_index] = type;\n\t\tarea[start_index + 1] = arg1;\n\t\tarea[start_index + 2] = arg2;\n\t\tarea[start_index + 3] = ip;\n\t}\n}\n\nvoid notrace __sanitizer_cov_trace_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0), arg1, arg2, _RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_cmp1);\n\nvoid notrace __sanitizer_cov_trace_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1), arg1, arg2, _RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_cmp2);\n\nvoid notrace __sanitizer_cov_trace_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2), arg1, arg2, _RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_cmp4);\n\nvoid notrace __sanitizer_cov_trace_cmp8(kcov_u64 arg1, kcov_u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3), arg1, arg2, _RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_cmp8);\n\nvoid notrace __sanitizer_cov_trace_const_cmp1(u8 arg1, u8 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(0) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_const_cmp1);\n\nvoid notrace __sanitizer_cov_trace_const_cmp2(u16 arg1, u16 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(1) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_const_cmp2);\n\nvoid notrace __sanitizer_cov_trace_const_cmp4(u32 arg1, u32 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(2) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_const_cmp4);\n\nvoid notrace __sanitizer_cov_trace_const_cmp8(kcov_u64 arg1, kcov_u64 arg2)\n{\n\twrite_comp_data(KCOV_CMP_SIZE(3) | KCOV_CMP_CONST, arg1, arg2,\n\t\t\t_RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_const_cmp8);\n\nvoid notrace __sanitizer_cov_trace_switch(kcov_u64 val, void *arg)\n{\n\tu64 i;\n\tu64 *cases = arg;\n\tu64 count = cases[0];\n\tu64 size = cases[1];\n\tu64 type = KCOV_CMP_CONST;\n\n\tswitch (size) {\n\tcase 8:\n\t\ttype |= KCOV_CMP_SIZE(0);\n\t\tbreak;\n\tcase 16:\n\t\ttype |= KCOV_CMP_SIZE(1);\n\t\tbreak;\n\tcase 32:\n\t\ttype |= KCOV_CMP_SIZE(2);\n\t\tbreak;\n\tcase 64:\n\t\ttype |= KCOV_CMP_SIZE(3);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tfor (i = 0; i < count; i++)\n\t\twrite_comp_data(type, cases[i + 2], val, _RET_IP_);\n}\nEXPORT_SYMBOL(__sanitizer_cov_trace_switch);\n#endif  \n\nstatic void kcov_start(struct task_struct *t, struct kcov *kcov,\n\t\t\tunsigned int size, void *area, enum kcov_mode mode,\n\t\t\tint sequence)\n{\n\tkcov_debug(\"t = %px, size = %u, area = %px\\n\", t, size, area);\n\tt->kcov = kcov;\n\t \n\tt->kcov_size = size;\n\tt->kcov_area = area;\n\tt->kcov_sequence = sequence;\n\t \n\tbarrier();\n\tWRITE_ONCE(t->kcov_mode, mode);\n}\n\nstatic void kcov_stop(struct task_struct *t)\n{\n\tWRITE_ONCE(t->kcov_mode, KCOV_MODE_DISABLED);\n\tbarrier();\n\tt->kcov = NULL;\n\tt->kcov_size = 0;\n\tt->kcov_area = NULL;\n}\n\nstatic void kcov_task_reset(struct task_struct *t)\n{\n\tkcov_stop(t);\n\tt->kcov_sequence = 0;\n\tt->kcov_handle = 0;\n}\n\nvoid kcov_task_init(struct task_struct *t)\n{\n\tkcov_task_reset(t);\n\tt->kcov_handle = current->kcov_handle;\n}\n\nstatic void kcov_reset(struct kcov *kcov)\n{\n\tkcov->t = NULL;\n\tkcov->mode = KCOV_MODE_INIT;\n\tkcov->remote = false;\n\tkcov->remote_size = 0;\n\tkcov->sequence++;\n}\n\nstatic void kcov_remote_reset(struct kcov *kcov)\n{\n\tint bkt;\n\tstruct kcov_remote *remote;\n\tstruct hlist_node *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\thash_for_each_safe(kcov_remote_map, bkt, tmp, remote, hnode) {\n\t\tif (remote->kcov != kcov)\n\t\t\tcontinue;\n\t\thash_del(&remote->hnode);\n\t\tkfree(remote);\n\t}\n\t \n\tkcov_reset(kcov);\n\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n}\n\nstatic void kcov_disable(struct task_struct *t, struct kcov *kcov)\n{\n\tkcov_task_reset(t);\n\tif (kcov->remote)\n\t\tkcov_remote_reset(kcov);\n\telse\n\t\tkcov_reset(kcov);\n}\n\nstatic void kcov_get(struct kcov *kcov)\n{\n\trefcount_inc(&kcov->refcount);\n}\n\nstatic void kcov_put(struct kcov *kcov)\n{\n\tif (refcount_dec_and_test(&kcov->refcount)) {\n\t\tkcov_remote_reset(kcov);\n\t\tvfree(kcov->area);\n\t\tkfree(kcov);\n\t}\n}\n\nvoid kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\tunsigned long flags;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tkcov_debug(\"t = %px, kcov->t = %px\\n\", t, kcov->t);\n\t \n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\treturn;\n\t}\n\t \n\tkcov_disable(t, kcov);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tkcov_put(kcov);\n}\n\nstatic int kcov_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tint res = 0;\n\tstruct kcov *kcov = vma->vm_file->private_data;\n\tunsigned long size, off;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tsize = kcov->size * sizeof(unsigned long);\n\tif (kcov->area == NULL || vma->vm_pgoff != 0 ||\n\t    vma->vm_end - vma->vm_start != size) {\n\t\tres = -EINVAL;\n\t\tgoto exit;\n\t}\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tvm_flags_set(vma, VM_DONTEXPAND);\n\tfor (off = 0; off < size; off += PAGE_SIZE) {\n\t\tpage = vmalloc_to_page(kcov->area + off);\n\t\tres = vm_insert_page(vma, vma->vm_start + off, page);\n\t\tif (res) {\n\t\t\tpr_warn_once(\"kcov: vm_insert_page() failed\\n\");\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\nexit:\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\treturn res;\n}\n\nstatic int kcov_open(struct inode *inode, struct file *filep)\n{\n\tstruct kcov *kcov;\n\n\tkcov = kzalloc(sizeof(*kcov), GFP_KERNEL);\n\tif (!kcov)\n\t\treturn -ENOMEM;\n\tkcov->mode = KCOV_MODE_DISABLED;\n\tkcov->sequence = 1;\n\trefcount_set(&kcov->refcount, 1);\n\tspin_lock_init(&kcov->lock);\n\tfilep->private_data = kcov;\n\treturn nonseekable_open(inode, filep);\n}\n\nstatic int kcov_close(struct inode *inode, struct file *filep)\n{\n\tkcov_put(filep->private_data);\n\treturn 0;\n}\n\nstatic int kcov_get_mode(unsigned long arg)\n{\n\tif (arg == KCOV_TRACE_PC)\n\t\treturn KCOV_MODE_TRACE_PC;\n\telse if (arg == KCOV_TRACE_CMP)\n#ifdef CONFIG_KCOV_ENABLE_COMPARISONS\n\t\treturn KCOV_MODE_TRACE_CMP;\n#else\n\t\treturn -ENOTSUPP;\n#endif\n\telse\n\t\treturn -EINVAL;\n}\n\n \nstatic void kcov_fault_in_area(struct kcov *kcov)\n{\n\tunsigned long stride = PAGE_SIZE / sizeof(unsigned long);\n\tunsigned long *area = kcov->area;\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < kcov->size; offset += stride)\n\t\tREAD_ONCE(area[offset]);\n}\n\nstatic inline bool kcov_check_handle(u64 handle, bool common_valid,\n\t\t\t\tbool uncommon_valid, bool zero_valid)\n{\n\tif (handle & ~(KCOV_SUBSYSTEM_MASK | KCOV_INSTANCE_MASK))\n\t\treturn false;\n\tswitch (handle & KCOV_SUBSYSTEM_MASK) {\n\tcase KCOV_SUBSYSTEM_COMMON:\n\t\treturn (handle & KCOV_INSTANCE_MASK) ?\n\t\t\tcommon_valid : zero_valid;\n\tcase KCOV_SUBSYSTEM_USB:\n\t\treturn uncommon_valid;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn false;\n}\n\nstatic int kcov_ioctl_locked(struct kcov *kcov, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tstruct task_struct *t;\n\tunsigned long flags, unused;\n\tint mode, i;\n\tstruct kcov_remote_arg *remote_arg;\n\tstruct kcov_remote *remote;\n\n\tswitch (cmd) {\n\tcase KCOV_ENABLE:\n\t\t \n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tmode = kcov_get_mode(arg);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tkcov_fault_in_area(kcov);\n\t\tkcov->mode = mode;\n\t\tkcov_start(t, kcov, kcov->size, kcov->area, kcov->mode,\n\t\t\t\tkcov->sequence);\n\t\tkcov->t = t;\n\t\t \n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tcase KCOV_DISABLE:\n\t\t \n\t\tunused = arg;\n\t\tif (unused != 0 || current->kcov != kcov)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (WARN_ON(kcov->t != t))\n\t\t\treturn -EINVAL;\n\t\tkcov_disable(t, kcov);\n\t\tkcov_put(kcov);\n\t\treturn 0;\n\tcase KCOV_REMOTE_ENABLE:\n\t\tif (kcov->mode != KCOV_MODE_INIT || !kcov->area)\n\t\t\treturn -EINVAL;\n\t\tt = current;\n\t\tif (kcov->t != NULL || t->kcov != NULL)\n\t\t\treturn -EBUSY;\n\t\tremote_arg = (struct kcov_remote_arg *)arg;\n\t\tmode = kcov_get_mode(remote_arg->trace_mode);\n\t\tif (mode < 0)\n\t\t\treturn mode;\n\t\tif (remote_arg->area_size > LONG_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tkcov->mode = mode;\n\t\tt->kcov = kcov;\n\t\tkcov->t = t;\n\t\tkcov->remote = true;\n\t\tkcov->remote_size = remote_arg->area_size;\n\t\tspin_lock_irqsave(&kcov_remote_lock, flags);\n\t\tfor (i = 0; i < remote_arg->num_handles; i++) {\n\t\t\tif (!kcov_check_handle(remote_arg->handles[i],\n\t\t\t\t\t\tfalse, true, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov, remote_arg->handles[i]);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t}\n\t\tif (remote_arg->common_handle) {\n\t\t\tif (!kcov_check_handle(remote_arg->common_handle,\n\t\t\t\t\t\ttrue, false, false)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tremote = kcov_remote_add(kcov,\n\t\t\t\t\tremote_arg->common_handle);\n\t\t\tif (IS_ERR(remote)) {\n\t\t\t\tspin_unlock_irqrestore(&kcov_remote_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\tkcov_disable(t, kcov);\n\t\t\t\treturn PTR_ERR(remote);\n\t\t\t}\n\t\t\tt->kcov_handle = remote_arg->common_handle;\n\t\t}\n\t\tspin_unlock_irqrestore(&kcov_remote_lock, flags);\n\t\t \n\t\tkcov_get(kcov);\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic long kcov_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tstruct kcov *kcov;\n\tint res;\n\tstruct kcov_remote_arg *remote_arg = NULL;\n\tunsigned int remote_num_handles;\n\tunsigned long remote_arg_size;\n\tunsigned long size, flags;\n\tvoid *area;\n\n\tkcov = filep->private_data;\n\tswitch (cmd) {\n\tcase KCOV_INIT_TRACE:\n\t\t \n\t\tsize = arg;\n\t\tif (size < 2 || size > INT_MAX / sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tarea = vmalloc_user(size * sizeof(unsigned long));\n\t\tif (area == NULL)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_irqsave(&kcov->lock, flags);\n\t\tif (kcov->mode != KCOV_MODE_DISABLED) {\n\t\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\t\tvfree(area);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tkcov->area = area;\n\t\tkcov->size = size;\n\t\tkcov->mode = KCOV_MODE_INIT;\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\treturn 0;\n\tcase KCOV_REMOTE_ENABLE:\n\t\tif (get_user(remote_num_handles, (unsigned __user *)(arg +\n\t\t\t\toffsetof(struct kcov_remote_arg, num_handles))))\n\t\t\treturn -EFAULT;\n\t\tif (remote_num_handles > KCOV_REMOTE_MAX_HANDLES)\n\t\t\treturn -EINVAL;\n\t\tremote_arg_size = struct_size(remote_arg, handles,\n\t\t\t\t\tremote_num_handles);\n\t\tremote_arg = memdup_user((void __user *)arg, remote_arg_size);\n\t\tif (IS_ERR(remote_arg))\n\t\t\treturn PTR_ERR(remote_arg);\n\t\tif (remote_arg->num_handles != remote_num_handles) {\n\t\t\tkfree(remote_arg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\targ = (unsigned long)remote_arg;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tspin_lock_irqsave(&kcov->lock, flags);\n\t\tres = kcov_ioctl_locked(kcov, cmd, arg);\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\tkfree(remote_arg);\n\t\treturn res;\n\t}\n}\n\nstatic const struct file_operations kcov_fops = {\n\t.open\t\t= kcov_open,\n\t.unlocked_ioctl\t= kcov_ioctl,\n\t.compat_ioctl\t= kcov_ioctl,\n\t.mmap\t\t= kcov_mmap,\n\t.release        = kcov_close,\n};\n\n \n\nstatic inline bool kcov_mode_enabled(unsigned int mode)\n{\n\treturn (mode & ~KCOV_IN_CTXSW) != KCOV_MODE_DISABLED;\n}\n\nstatic void kcov_remote_softirq_start(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\tunsigned int mode;\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (kcov_mode_enabled(mode)) {\n\t\tdata->saved_mode = mode;\n\t\tdata->saved_size = t->kcov_size;\n\t\tdata->saved_area = t->kcov_area;\n\t\tdata->saved_sequence = t->kcov_sequence;\n\t\tdata->saved_kcov = t->kcov;\n\t\tkcov_stop(t);\n\t}\n}\n\nstatic void kcov_remote_softirq_stop(struct task_struct *t)\n{\n\tstruct kcov_percpu_data *data = this_cpu_ptr(&kcov_percpu_data);\n\n\tif (data->saved_kcov) {\n\t\tkcov_start(t, data->saved_kcov, data->saved_size,\n\t\t\t\tdata->saved_area, data->saved_mode,\n\t\t\t\tdata->saved_sequence);\n\t\tdata->saved_mode = 0;\n\t\tdata->saved_size = 0;\n\t\tdata->saved_area = NULL;\n\t\tdata->saved_sequence = 0;\n\t\tdata->saved_kcov = NULL;\n\t}\n}\n\nvoid kcov_remote_start(u64 handle)\n{\n\tstruct task_struct *t = current;\n\tstruct kcov_remote *remote;\n\tstruct kcov *kcov;\n\tunsigned int mode;\n\tvoid *area;\n\tunsigned int size;\n\tint sequence;\n\tunsigned long flags;\n\n\tif (WARN_ON(!kcov_check_handle(handle, true, true, true)))\n\t\treturn;\n\tif (!in_task() && !in_serving_softirq())\n\t\treturn;\n\n\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\n\t \n\tmode = READ_ONCE(t->kcov_mode);\n\tif (WARN_ON(in_task() && kcov_mode_enabled(mode))) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t \n\tif (WARN_ON(in_serving_softirq() && t->kcov_softirq)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&kcov_remote_lock);\n\tremote = kcov_remote_find(handle);\n\tif (!remote) {\n\t\tspin_unlock(&kcov_remote_lock);\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\tkcov_debug(\"handle = %llx, context: %s\\n\", handle,\n\t\t\tin_task() ? \"task\" : \"softirq\");\n\tkcov = remote->kcov;\n\t \n\tkcov_get(kcov);\n\t \n\tmode = kcov->mode;\n\tsequence = kcov->sequence;\n\tif (in_task()) {\n\t\tsize = kcov->remote_size;\n\t\tarea = kcov_remote_area_get(size);\n\t} else {\n\t\tsize = CONFIG_KCOV_IRQ_AREA_SIZE;\n\t\tarea = this_cpu_ptr(&kcov_percpu_data)->irq_area;\n\t}\n\tspin_unlock(&kcov_remote_lock);\n\n\t \n\tif (!area) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\tarea = vmalloc(size * sizeof(unsigned long));\n\t\tif (!area) {\n\t\t\tkcov_put(kcov);\n\t\t\treturn;\n\t\t}\n\t\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\t}\n\n\t \n\t*(u64 *)area = 0;\n\n\tif (in_serving_softirq()) {\n\t\tkcov_remote_softirq_start(t);\n\t\tt->kcov_softirq = 1;\n\t}\n\tkcov_start(t, kcov, size, area, mode, sequence);\n\n\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\n}\nEXPORT_SYMBOL(kcov_remote_start);\n\nstatic void kcov_move_area(enum kcov_mode mode, void *dst_area,\n\t\t\t\tunsigned int dst_area_size, void *src_area)\n{\n\tu64 word_size = sizeof(unsigned long);\n\tu64 count_size, entry_size_log;\n\tu64 dst_len, src_len;\n\tvoid *dst_entries, *src_entries;\n\tu64 dst_occupied, dst_free, bytes_to_move, entries_moved;\n\n\tkcov_debug(\"%px %u <= %px %lu\\n\",\n\t\tdst_area, dst_area_size, src_area, *(unsigned long *)src_area);\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tdst_len = READ_ONCE(*(unsigned long *)dst_area);\n\t\tsrc_len = *(unsigned long *)src_area;\n\t\tcount_size = sizeof(unsigned long);\n\t\tentry_size_log = __ilog2_u64(sizeof(unsigned long));\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tdst_len = READ_ONCE(*(u64 *)dst_area);\n\t\tsrc_len = *(u64 *)src_area;\n\t\tcount_size = sizeof(u64);\n\t\tBUILD_BUG_ON(!is_power_of_2(KCOV_WORDS_PER_CMP));\n\t\tentry_size_log = __ilog2_u64(sizeof(u64) * KCOV_WORDS_PER_CMP);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\tif (dst_len > ((dst_area_size * word_size - count_size) >>\n\t\t\t\tentry_size_log))\n\t\treturn;\n\tdst_occupied = count_size + (dst_len << entry_size_log);\n\tdst_free = dst_area_size * word_size - dst_occupied;\n\tbytes_to_move = min(dst_free, src_len << entry_size_log);\n\tdst_entries = dst_area + dst_occupied;\n\tsrc_entries = src_area + count_size;\n\tmemcpy(dst_entries, src_entries, bytes_to_move);\n\tentries_moved = bytes_to_move >> entry_size_log;\n\n\tswitch (mode) {\n\tcase KCOV_MODE_TRACE_PC:\n\t\tWRITE_ONCE(*(unsigned long *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tcase KCOV_MODE_TRACE_CMP:\n\t\tWRITE_ONCE(*(u64 *)dst_area, dst_len + entries_moved);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid kcov_remote_stop(void)\n{\n\tstruct task_struct *t = current;\n\tstruct kcov *kcov;\n\tunsigned int mode;\n\tvoid *area;\n\tunsigned int size;\n\tint sequence;\n\tunsigned long flags;\n\n\tif (!in_task() && !in_serving_softirq())\n\t\treturn;\n\n\tlocal_lock_irqsave(&kcov_percpu_data.lock, flags);\n\n\tmode = READ_ONCE(t->kcov_mode);\n\tbarrier();\n\tif (!kcov_mode_enabled(mode)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t \n\tif (in_serving_softirq() && !t->kcov_softirq) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\t \n\tif (WARN_ON(!in_serving_softirq() && t->kcov_softirq)) {\n\t\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\t\treturn;\n\t}\n\n\tkcov = t->kcov;\n\tarea = t->kcov_area;\n\tsize = t->kcov_size;\n\tsequence = t->kcov_sequence;\n\n\tkcov_stop(t);\n\tif (in_serving_softirq()) {\n\t\tt->kcov_softirq = 0;\n\t\tkcov_remote_softirq_stop(t);\n\t}\n\n\tspin_lock(&kcov->lock);\n\t \n\tif (sequence == kcov->sequence && kcov->remote)\n\t\tkcov_move_area(kcov->mode, kcov->area, kcov->size, area);\n\tspin_unlock(&kcov->lock);\n\n\tif (in_task()) {\n\t\tspin_lock(&kcov_remote_lock);\n\t\tkcov_remote_area_put(area, size);\n\t\tspin_unlock(&kcov_remote_lock);\n\t}\n\n\tlocal_unlock_irqrestore(&kcov_percpu_data.lock, flags);\n\n\t \n\tkcov_put(kcov);\n}\nEXPORT_SYMBOL(kcov_remote_stop);\n\n \nu64 kcov_common_handle(void)\n{\n\tif (!in_task())\n\t\treturn 0;\n\treturn current->kcov_handle;\n}\nEXPORT_SYMBOL(kcov_common_handle);\n\nstatic int __init kcov_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tvoid *area = vmalloc_node(CONFIG_KCOV_IRQ_AREA_SIZE *\n\t\t\t\tsizeof(unsigned long), cpu_to_node(cpu));\n\t\tif (!area)\n\t\t\treturn -ENOMEM;\n\t\tper_cpu_ptr(&kcov_percpu_data, cpu)->irq_area = area;\n\t}\n\n\t \n\tdebugfs_create_file_unsafe(\"kcov\", 0600, NULL, NULL, &kcov_fops);\n\n\treturn 0;\n}\n\ndevice_initcall(kcov_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}