{
  "module_name": "user.c",
  "hash_id": "f7105b1bc703d43091efe226ba4e9df2ad258f41c202cdc60bcca4f7217b2af9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/user.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/key.h>\n#include <linux/sched/user.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n#include <linux/proc_ns.h>\n\n \nstruct user_namespace init_user_ns = {\n\t.uid_map = {\n\t\t.nr_extents = 1,\n\t\t{\n\t\t\t.extent[0] = {\n\t\t\t\t.first = 0,\n\t\t\t\t.lower_first = 0,\n\t\t\t\t.count = 4294967295U,\n\t\t\t},\n\t\t},\n\t},\n\t.gid_map = {\n\t\t.nr_extents = 1,\n\t\t{\n\t\t\t.extent[0] = {\n\t\t\t\t.first = 0,\n\t\t\t\t.lower_first = 0,\n\t\t\t\t.count = 4294967295U,\n\t\t\t},\n\t\t},\n\t},\n\t.projid_map = {\n\t\t.nr_extents = 1,\n\t\t{\n\t\t\t.extent[0] = {\n\t\t\t\t.first = 0,\n\t\t\t\t.lower_first = 0,\n\t\t\t\t.count = 4294967295U,\n\t\t\t},\n\t\t},\n\t},\n\t.ns.count = REFCOUNT_INIT(3),\n\t.owner = GLOBAL_ROOT_UID,\n\t.group = GLOBAL_ROOT_GID,\n\t.ns.inum = PROC_USER_INIT_INO,\n#ifdef CONFIG_USER_NS\n\t.ns.ops = &userns_operations,\n#endif\n\t.flags = USERNS_INIT_FLAGS,\n#ifdef CONFIG_KEYS\n\t.keyring_name_list = LIST_HEAD_INIT(init_user_ns.keyring_name_list),\n\t.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),\n#endif\n};\nEXPORT_SYMBOL_GPL(init_user_ns);\n\n \n\n#define UIDHASH_BITS\t(CONFIG_BASE_SMALL ? 3 : 7)\n#define UIDHASH_SZ\t(1 << UIDHASH_BITS)\n#define UIDHASH_MASK\t\t(UIDHASH_SZ - 1)\n#define __uidhashfn(uid)\t(((uid >> UIDHASH_BITS) + uid) & UIDHASH_MASK)\n#define uidhashentry(uid)\t(uidhash_table + __uidhashfn((__kuid_val(uid))))\n\nstatic struct kmem_cache *uid_cachep;\nstatic struct hlist_head uidhash_table[UIDHASH_SZ];\n\n \nstatic DEFINE_SPINLOCK(uidhash_lock);\n\n \nstruct user_struct root_user = {\n\t.__count\t= REFCOUNT_INIT(1),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n\t.ratelimit\t= RATELIMIT_STATE_INIT(root_user.ratelimit, 0, 0),\n};\n\n \nstatic void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)\n{\n\thlist_add_head(&up->uidhash_node, hashent);\n}\n\nstatic void uid_hash_remove(struct user_struct *up)\n{\n\thlist_del_init(&up->uidhash_node);\n}\n\nstatic struct user_struct *uid_hash_find(kuid_t uid, struct hlist_head *hashent)\n{\n\tstruct user_struct *user;\n\n\thlist_for_each_entry(user, hashent, uidhash_node) {\n\t\tif (uid_eq(user->uid, uid)) {\n\t\t\trefcount_inc(&user->__count);\n\t\t\treturn user;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int user_epoll_alloc(struct user_struct *up)\n{\n#ifdef CONFIG_EPOLL\n\treturn percpu_counter_init(&up->epoll_watches, 0, GFP_KERNEL);\n#else\n\treturn 0;\n#endif\n}\n\nstatic void user_epoll_free(struct user_struct *up)\n{\n#ifdef CONFIG_EPOLL\n\tpercpu_counter_destroy(&up->epoll_watches);\n#endif\n}\n\n \nstatic void free_user(struct user_struct *up, unsigned long flags)\n\t__releases(&uidhash_lock)\n{\n\tuid_hash_remove(up);\n\tspin_unlock_irqrestore(&uidhash_lock, flags);\n\tuser_epoll_free(up);\n\tkmem_cache_free(uid_cachep, up);\n}\n\n \nstruct user_struct *find_user(kuid_t uid)\n{\n\tstruct user_struct *ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uidhash_lock, flags);\n\tret = uid_hash_find(uid, uidhashentry(uid));\n\tspin_unlock_irqrestore(&uidhash_lock, flags);\n\treturn ret;\n}\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}\nEXPORT_SYMBOL_GPL(free_uid);\n\nstruct user_struct *alloc_uid(kuid_t uid)\n{\n\tstruct hlist_head *hashent = uidhashentry(uid);\n\tstruct user_struct *up, *new;\n\n\tspin_lock_irq(&uidhash_lock);\n\tup = uid_hash_find(uid, hashent);\n\tspin_unlock_irq(&uidhash_lock);\n\n\tif (!up) {\n\t\tnew = kmem_cache_zalloc(uid_cachep, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->uid = uid;\n\t\trefcount_set(&new->__count, 1);\n\t\tif (user_epoll_alloc(new)) {\n\t\t\tkmem_cache_free(uid_cachep, new);\n\t\t\treturn NULL;\n\t\t}\n\t\tratelimit_state_init(&new->ratelimit, HZ, 100);\n\t\tratelimit_set_flags(&new->ratelimit, RATELIMIT_MSG_ON_RELEASE);\n\n\t\t \n\t\tspin_lock_irq(&uidhash_lock);\n\t\tup = uid_hash_find(uid, hashent);\n\t\tif (up) {\n\t\t\tuser_epoll_free(new);\n\t\t\tkmem_cache_free(uid_cachep, new);\n\t\t} else {\n\t\t\tuid_hash_insert(new, hashent);\n\t\t\tup = new;\n\t\t}\n\t\tspin_unlock_irq(&uidhash_lock);\n\t}\n\n\treturn up;\n}\n\nstatic int __init uid_cache_init(void)\n{\n\tint n;\n\n\tuid_cachep = kmem_cache_create(\"uid_cache\", sizeof(struct user_struct),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\tfor(n = 0; n < UIDHASH_SZ; ++n)\n\t\tINIT_HLIST_HEAD(uidhash_table + n);\n\n\tif (user_epoll_alloc(&root_user))\n\t\tpanic(\"root_user epoll percpu counter alloc failed\");\n\n\t \n\tspin_lock_irq(&uidhash_lock);\n\tuid_hash_insert(&root_user, uidhashentry(GLOBAL_ROOT_UID));\n\tspin_unlock_irq(&uidhash_lock);\n\n\treturn 0;\n}\nsubsys_initcall(uid_cache_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}