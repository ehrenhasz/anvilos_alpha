{
  "module_name": "mutex-debug.c",
  "hash_id": "dd8828b9f798b6bd0de920dccb9e7bef0ede2f8845a37d7dee33f11566dc4d36",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/mutex-debug.c",
  "human_readable_source": " \n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/debug_locks.h>\n\n#include \"mutex.h\"\n\n \nvoid debug_mutex_lock_common(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tmemset(waiter, MUTEX_DEBUG_INIT, sizeof(*waiter));\n\twaiter->magic = waiter;\n\tINIT_LIST_HEAD(&waiter->list);\n\twaiter->ww_ctx = MUTEX_POISON_WW_CTX;\n}\n\nvoid debug_mutex_wake_waiter(struct mutex *lock, struct mutex_waiter *waiter)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&lock->wait_list));\n\tDEBUG_LOCKS_WARN_ON(waiter->magic != waiter);\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n}\n\nvoid debug_mutex_free_waiter(struct mutex_waiter *waiter)\n{\n\tDEBUG_LOCKS_WARN_ON(!list_empty(&waiter->list));\n\tmemset(waiter, MUTEX_DEBUG_FREE, sizeof(*waiter));\n}\n\nvoid debug_mutex_add_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t\t    struct task_struct *task)\n{\n\tlockdep_assert_held(&lock->wait_lock);\n\n\t \n\ttask->blocked_on = waiter;\n}\n\nvoid debug_mutex_remove_waiter(struct mutex *lock, struct mutex_waiter *waiter,\n\t\t\t struct task_struct *task)\n{\n\tDEBUG_LOCKS_WARN_ON(list_empty(&waiter->list));\n\tDEBUG_LOCKS_WARN_ON(waiter->task != task);\n\tDEBUG_LOCKS_WARN_ON(task->blocked_on != waiter);\n\ttask->blocked_on = NULL;\n\n\tINIT_LIST_HEAD(&waiter->list);\n\twaiter->task = NULL;\n}\n\nvoid debug_mutex_unlock(struct mutex *lock)\n{\n\tif (likely(debug_locks)) {\n\t\tDEBUG_LOCKS_WARN_ON(lock->magic != lock);\n\t\tDEBUG_LOCKS_WARN_ON(!lock->wait_list.prev && !lock->wait_list.next);\n\t}\n}\n\nvoid debug_mutex_init(struct mutex *lock, const char *name,\n\t\t      struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t \n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_SLEEP);\n#endif\n\tlock->magic = lock;\n}\n\n \nvoid mutex_destroy(struct mutex *lock)\n{\n\tDEBUG_LOCKS_WARN_ON(mutex_is_locked(lock));\n\tlock->magic = NULL;\n}\n\nEXPORT_SYMBOL_GPL(mutex_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}