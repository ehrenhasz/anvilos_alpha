{
  "module_name": "osq_lock.c",
  "hash_id": "906e90da837f7d86c952fdb3e6633320d550d20bfce0234d21c08044ec0d1b6a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/osq_lock.c",
  "human_readable_source": "\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/osq_lock.h>\n\n \nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct optimistic_spin_node, osq_node);\n\n \nstatic inline int encode_cpu(int cpu_nr)\n{\n\treturn cpu_nr + 1;\n}\n\nstatic inline int node_cpu(struct optimistic_spin_node *node)\n{\n\treturn node->cpu - 1;\n}\n\nstatic inline struct optimistic_spin_node *decode_cpu(int encoded_cpu_val)\n{\n\tint cpu_nr = encoded_cpu_val - 1;\n\n\treturn per_cpu_ptr(&osq_node, cpu_nr);\n}\n\n \nstatic inline struct optimistic_spin_node *\nosq_wait_next(struct optimistic_spin_queue *lock,\n\t      struct optimistic_spin_node *node,\n\t      struct optimistic_spin_node *prev)\n{\n\tstruct optimistic_spin_node *next = NULL;\n\tint curr = encode_cpu(smp_processor_id());\n\tint old;\n\n\t \n\told = prev ? prev->cpu : OSQ_UNLOCKED_VAL;\n\n\tfor (;;) {\n\t\tif (atomic_read(&lock->tail) == curr &&\n\t\t    atomic_cmpxchg_acquire(&lock->tail, curr, old) == curr) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (node->next) {\n\t\t\tnext = xchg(&node->next, NULL);\n\t\t\tif (next)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax();\n\t}\n\n\treturn next;\n}\n\nbool osq_lock(struct optimistic_spin_queue *lock)\n{\n\tstruct optimistic_spin_node *node = this_cpu_ptr(&osq_node);\n\tstruct optimistic_spin_node *prev, *next;\n\tint curr = encode_cpu(smp_processor_id());\n\tint old;\n\n\tnode->locked = 0;\n\tnode->next = NULL;\n\tnode->cpu = curr;\n\n\t \n\told = atomic_xchg(&lock->tail, curr);\n\tif (old == OSQ_UNLOCKED_VAL)\n\t\treturn true;\n\n\tprev = decode_cpu(old);\n\tnode->prev = prev;\n\n\t \n\tsmp_wmb();\n\n\tWRITE_ONCE(prev->next, node);\n\n\t \n\n\t \n\tif (smp_cond_load_relaxed(&node->locked, VAL || need_resched() ||\n\t\t\t\t  vcpu_is_preempted(node_cpu(node->prev))))\n\t\treturn true;\n\n\t \n\t \n\n\tfor (;;) {\n\t\t \n\t\tif (data_race(prev->next) == node &&\n\t\t    cmpxchg(&prev->next, node, NULL) == node)\n\t\t\tbreak;\n\n\t\t \n\t\tif (smp_load_acquire(&node->locked))\n\t\t\treturn true;\n\n\t\tcpu_relax();\n\n\t\t \n\t\tprev = READ_ONCE(node->prev);\n\t}\n\n\t \n\n\tnext = osq_wait_next(lock, node, prev);\n\tif (!next)\n\t\treturn false;\n\n\t \n\n\tWRITE_ONCE(next->prev, prev);\n\tWRITE_ONCE(prev->next, next);\n\n\treturn false;\n}\n\nvoid osq_unlock(struct optimistic_spin_queue *lock)\n{\n\tstruct optimistic_spin_node *node, *next;\n\tint curr = encode_cpu(smp_processor_id());\n\n\t \n\tif (likely(atomic_cmpxchg_release(&lock->tail, curr,\n\t\t\t\t\t  OSQ_UNLOCKED_VAL) == curr))\n\t\treturn;\n\n\t \n\tnode = this_cpu_ptr(&osq_node);\n\tnext = xchg(&node->next, NULL);\n\tif (next) {\n\t\tWRITE_ONCE(next->locked, 1);\n\t\treturn;\n\t}\n\n\tnext = osq_wait_next(lock, node, NULL);\n\tif (next)\n\t\tWRITE_ONCE(next->locked, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}