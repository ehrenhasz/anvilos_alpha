{
  "module_name": "rwbase_rt.c",
  "hash_id": "552a86168d90ddf897a70de79622388d23e69a15230b633a8e30b7d1701984d9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/rwbase_rt.c",
  "human_readable_source": "\n\n \n\nstatic __always_inline int rwbase_read_trylock(struct rwbase_rt *rwb)\n{\n\tint r;\n\n\t \n\tfor (r = atomic_read(&rwb->readers); r < 0;) {\n\t\tif (likely(atomic_try_cmpxchg_acquire(&rwb->readers, &r, r + 1)))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int __sched __rwbase_read_lock(struct rwbase_rt *rwb,\n\t\t\t\t      unsigned int state)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\tint ret;\n\n\traw_spin_lock_irq(&rtm->wait_lock);\n\n\t \n\n\ttrace_contention_begin(rwb, LCB_F_RT | LCB_F_READ);\n\n\t \n\tret = rwbase_rtmutex_slowlock_locked(rtm, state);\n\n\t \n\tif (!ret)\n\t\tatomic_inc(&rwb->readers);\n\traw_spin_unlock_irq(&rtm->wait_lock);\n\tif (!ret)\n\t\trwbase_rtmutex_unlock(rtm);\n\n\ttrace_contention_end(rwb, ret);\n\treturn ret;\n}\n\nstatic __always_inline int rwbase_read_lock(struct rwbase_rt *rwb,\n\t\t\t\t\t    unsigned int state)\n{\n\tif (rwbase_read_trylock(rwb))\n\t\treturn 0;\n\n\treturn __rwbase_read_lock(rwb, state);\n}\n\nstatic void __sched __rwbase_read_unlock(struct rwbase_rt *rwb,\n\t\t\t\t\t unsigned int state)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\tstruct task_struct *owner;\n\tDEFINE_RT_WAKE_Q(wqh);\n\n\traw_spin_lock_irq(&rtm->wait_lock);\n\t \n\towner = rt_mutex_owner(rtm);\n\tif (owner)\n\t\trt_mutex_wake_q_add_task(&wqh, owner, state);\n\n\t \n\tpreempt_disable();\n\traw_spin_unlock_irq(&rtm->wait_lock);\n\trt_mutex_wake_up_q(&wqh);\n}\n\nstatic __always_inline void rwbase_read_unlock(struct rwbase_rt *rwb,\n\t\t\t\t\t       unsigned int state)\n{\n\t \n\tif (unlikely(atomic_dec_and_test(&rwb->readers)))\n\t\t__rwbase_read_unlock(rwb, state);\n}\n\nstatic inline void __rwbase_write_unlock(struct rwbase_rt *rwb, int bias,\n\t\t\t\t\t unsigned long flags)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\n\t \n\t(void)atomic_add_return_release(READER_BIAS - bias, &rwb->readers);\n\traw_spin_unlock_irqrestore(&rtm->wait_lock, flags);\n\trwbase_rtmutex_unlock(rtm);\n}\n\nstatic inline void rwbase_write_unlock(struct rwbase_rt *rwb)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rtm->wait_lock, flags);\n\t__rwbase_write_unlock(rwb, WRITER_BIAS, flags);\n}\n\nstatic inline void rwbase_write_downgrade(struct rwbase_rt *rwb)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rtm->wait_lock, flags);\n\t \n\t__rwbase_write_unlock(rwb, WRITER_BIAS - 1, flags);\n}\n\nstatic inline bool __rwbase_write_trylock(struct rwbase_rt *rwb)\n{\n\t \n\tlockdep_assert_held(&rwb->rtmutex.wait_lock);\n\n\t \n\tif (!atomic_read_acquire(&rwb->readers)) {\n\t\tatomic_set(&rwb->readers, WRITER_BIAS);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __sched rwbase_write_lock(struct rwbase_rt *rwb,\n\t\t\t\t     unsigned int state)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\tunsigned long flags;\n\n\t \n\tif (rwbase_rtmutex_lock_state(rtm, state))\n\t\treturn -EINTR;\n\n\t \n\tatomic_sub(READER_BIAS, &rwb->readers);\n\n\traw_spin_lock_irqsave(&rtm->wait_lock, flags);\n\tif (__rwbase_write_trylock(rwb))\n\t\tgoto out_unlock;\n\n\trwbase_set_and_save_current_state(state);\n\ttrace_contention_begin(rwb, LCB_F_RT | LCB_F_WRITE);\n\tfor (;;) {\n\t\t \n\t\tif (rwbase_signal_pending_state(state, current)) {\n\t\t\trwbase_restore_current_state();\n\t\t\t__rwbase_write_unlock(rwb, 0, flags);\n\t\t\ttrace_contention_end(rwb, -EINTR);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tif (__rwbase_write_trylock(rwb))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irqrestore(&rtm->wait_lock, flags);\n\t\trwbase_schedule();\n\t\traw_spin_lock_irqsave(&rtm->wait_lock, flags);\n\n\t\tset_current_state(state);\n\t}\n\trwbase_restore_current_state();\n\ttrace_contention_end(rwb, 0);\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&rtm->wait_lock, flags);\n\treturn 0;\n}\n\nstatic inline int rwbase_write_trylock(struct rwbase_rt *rwb)\n{\n\tstruct rt_mutex_base *rtm = &rwb->rtmutex;\n\tunsigned long flags;\n\n\tif (!rwbase_rtmutex_trylock(rtm))\n\t\treturn 0;\n\n\tatomic_sub(READER_BIAS, &rwb->readers);\n\n\traw_spin_lock_irqsave(&rtm->wait_lock, flags);\n\tif (__rwbase_write_trylock(rwb)) {\n\t\traw_spin_unlock_irqrestore(&rtm->wait_lock, flags);\n\t\treturn 1;\n\t}\n\t__rwbase_write_unlock(rwb, 0, flags);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}