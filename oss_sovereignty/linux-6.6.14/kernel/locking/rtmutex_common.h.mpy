{
  "module_name": "rtmutex_common.h",
  "hash_id": "9e417ec68cb181cbfa197601b10584f5c9d227ce1e99ee6802bb3901fc9bd6df",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/rtmutex_common.h",
  "human_readable_source": " \n \n\n#ifndef __KERNEL_RTMUTEX_COMMON_H\n#define __KERNEL_RTMUTEX_COMMON_H\n\n#include <linux/debug_locks.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/wake_q.h>\n\n\n \nstruct rt_waiter_node {\n\tstruct rb_node\tentry;\n\tint\t\tprio;\n\tu64\t\tdeadline;\n};\n\n \nstruct rt_mutex_waiter {\n\tstruct rt_waiter_node\ttree;\n\tstruct rt_waiter_node\tpi_tree;\n\tstruct task_struct\t*task;\n\tstruct rt_mutex_base\t*lock;\n\tunsigned int\t\twake_state;\n\tstruct ww_acquire_ctx\t*ww_ctx;\n};\n\n \nstruct rt_wake_q_head {\n\tstruct wake_q_head\thead;\n\tstruct task_struct\t*rtlock_task;\n};\n\n#define DEFINE_RT_WAKE_Q(name)\t\t\t\t\t\t\\\n\tstruct rt_wake_q_head name = {\t\t\t\t\t\\\n\t\t.head\t\t= WAKE_Q_HEAD_INITIALIZER(name.head),\t\\\n\t\t.rtlock_task\t= NULL,\t\t\t\t\t\\\n\t}\n\n \nextern void rt_mutex_init_proxy_locked(struct rt_mutex_base *lock,\n\t\t\t\t       struct task_struct *proxy_owner);\nextern void rt_mutex_proxy_unlock(struct rt_mutex_base *lock);\nextern int __rt_mutex_start_proxy_lock(struct rt_mutex_base *lock,\n\t\t\t\t     struct rt_mutex_waiter *waiter,\n\t\t\t\t     struct task_struct *task);\nextern int rt_mutex_start_proxy_lock(struct rt_mutex_base *lock,\n\t\t\t\t     struct rt_mutex_waiter *waiter,\n\t\t\t\t     struct task_struct *task);\nextern int rt_mutex_wait_proxy_lock(struct rt_mutex_base *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter);\nextern bool rt_mutex_cleanup_proxy_lock(struct rt_mutex_base *lock,\n\t\t\t\t struct rt_mutex_waiter *waiter);\n\nextern int rt_mutex_futex_trylock(struct rt_mutex_base *l);\nextern int __rt_mutex_futex_trylock(struct rt_mutex_base *l);\n\nextern void rt_mutex_futex_unlock(struct rt_mutex_base *lock);\nextern bool __rt_mutex_futex_unlock(struct rt_mutex_base *lock,\n\t\t\t\tstruct rt_wake_q_head *wqh);\n\nextern void rt_mutex_postunlock(struct rt_wake_q_head *wqh);\n\n \n#ifdef CONFIG_RT_MUTEXES\nstatic inline int rt_mutex_has_waiters(struct rt_mutex_base *lock)\n{\n\treturn !RB_EMPTY_ROOT(&lock->waiters.rb_root);\n}\n\n \nstatic inline bool rt_mutex_waiter_is_top_waiter(struct rt_mutex_base *lock,\n\t\t\t\t\t\t struct rt_mutex_waiter *waiter)\n{\n\tstruct rb_node *leftmost = rb_first_cached(&lock->waiters);\n\n\treturn rb_entry(leftmost, struct rt_mutex_waiter, tree.entry) == waiter;\n}\n\nstatic inline struct rt_mutex_waiter *rt_mutex_top_waiter(struct rt_mutex_base *lock)\n{\n\tstruct rb_node *leftmost = rb_first_cached(&lock->waiters);\n\tstruct rt_mutex_waiter *w = NULL;\n\n\tlockdep_assert_held(&lock->wait_lock);\n\n\tif (leftmost) {\n\t\tw = rb_entry(leftmost, struct rt_mutex_waiter, tree.entry);\n\t\tBUG_ON(w->lock != lock);\n\t}\n\treturn w;\n}\n\nstatic inline int task_has_pi_waiters(struct task_struct *p)\n{\n\treturn !RB_EMPTY_ROOT(&p->pi_waiters.rb_root);\n}\n\nstatic inline struct rt_mutex_waiter *task_top_pi_waiter(struct task_struct *p)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\treturn rb_entry(p->pi_waiters.rb_leftmost, struct rt_mutex_waiter,\n\t\t\tpi_tree.entry);\n}\n\n#define RT_MUTEX_HAS_WAITERS\t1UL\n\nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex_base *lock)\n{\n\tunsigned long owner = (unsigned long) READ_ONCE(lock->owner);\n\n\treturn (struct task_struct *) (owner & ~RT_MUTEX_HAS_WAITERS);\n}\n\n \nenum rtmutex_chainwalk {\n\tRT_MUTEX_MIN_CHAINWALK,\n\tRT_MUTEX_FULL_CHAINWALK,\n};\n\nstatic inline void __rt_mutex_base_init(struct rt_mutex_base *lock)\n{\n\traw_spin_lock_init(&lock->wait_lock);\n\tlock->waiters = RB_ROOT_CACHED;\n\tlock->owner = NULL;\n}\n\n \nstatic inline void debug_rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_RT_MUTEXES))\n\t\tDEBUG_LOCKS_WARN_ON(rt_mutex_owner(lock) != current);\n}\n\nstatic inline void debug_rt_mutex_proxy_unlock(struct rt_mutex_base *lock)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_RT_MUTEXES))\n\t\tDEBUG_LOCKS_WARN_ON(!rt_mutex_owner(lock));\n}\n\nstatic inline void debug_rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_RT_MUTEXES))\n\t\tmemset(waiter, 0x11, sizeof(*waiter));\n}\n\nstatic inline void debug_rt_mutex_free_waiter(struct rt_mutex_waiter *waiter)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_RT_MUTEXES))\n\t\tmemset(waiter, 0x22, sizeof(*waiter));\n}\n\nstatic inline void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree.entry);\n\tRB_CLEAR_NODE(&waiter->tree.entry);\n\twaiter->wake_state = TASK_NORMAL;\n\twaiter->task = NULL;\n}\n\nstatic inline void rt_mutex_init_rtlock_waiter(struct rt_mutex_waiter *waiter)\n{\n\trt_mutex_init_waiter(waiter);\n\twaiter->wake_state = TASK_RTLOCK_WAIT;\n}\n\n#else  \n \nstatic inline struct task_struct *rt_mutex_owner(struct rt_mutex_base *lock)\n{\n\treturn NULL;\n}\n#endif   \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}