{
  "module_name": "spinlock_debug.c",
  "hash_id": "dda5970d1b721621593849dd4ffe1660dc9ba995d714f382395fee8d52ea0f1f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/spinlock_debug.c",
  "human_readable_source": " \n\n#include <linux/spinlock.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/debug_locks.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n\nvoid __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\n\t\t\t  struct lock_class_key *key, short inner)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t \n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, inner);\n#endif\n\tlock->raw_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tlock->magic = SPINLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}\n\nEXPORT_SYMBOL(__raw_spin_lock_init);\n\n#ifndef CONFIG_PREEMPT_RT\nvoid __rwlock_init(rwlock_t *lock, const char *name,\n\t\t   struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t \n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map_wait(&lock->dep_map, name, key, 0, LD_WAIT_CONFIG);\n#endif\n\tlock->raw_lock = (arch_rwlock_t) __ARCH_RW_LOCK_UNLOCKED;\n\tlock->magic = RWLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}\n\nEXPORT_SYMBOL(__rwlock_init);\n#endif\n\nstatic void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = READ_ONCE(lock->owner);\n\n\tif (owner == SPINLOCK_OWNER_INIT)\n\t\towner = NULL;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, READ_ONCE(lock->magic),\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tREAD_ONCE(lock->owner_cpu));\n\tdump_stack();\n}\n\nstatic void spin_bug(raw_spinlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tspin_dump(lock, msg);\n}\n\n#define SPIN_BUG_ON(cond, lock, msg) if (unlikely(cond)) spin_bug(lock, msg)\n\nstatic inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(READ_ONCE(lock->magic) != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner) == current, lock, \"recursion\");\n\tSPIN_BUG_ON(READ_ONCE(lock->owner_cpu) == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}\n\nstatic inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}\n\n \nvoid do_raw_spin_lock(raw_spinlock_t *lock)\n{\n\tdebug_spin_lock_before(lock);\n\tarch_spin_lock(&lock->raw_lock);\n\tmmiowb_spin_lock();\n\tdebug_spin_lock_after(lock);\n}\n\nint do_raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tint ret = arch_spin_trylock(&lock->raw_lock);\n\n\tif (ret) {\n\t\tmmiowb_spin_lock();\n\t\tdebug_spin_lock_after(lock);\n\t}\n#ifndef CONFIG_SMP\n\t \n\tSPIN_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}\n\nvoid do_raw_spin_unlock(raw_spinlock_t *lock)\n{\n\tmmiowb_spin_unlock();\n\tdebug_spin_unlock(lock);\n\tarch_spin_unlock(&lock->raw_lock);\n}\n\n#ifndef CONFIG_PREEMPT_RT\nstatic void rwlock_bug(rwlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tprintk(KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\",\n\t\tmsg, raw_smp_processor_id(), current->comm,\n\t\ttask_pid_nr(current), lock);\n\tdump_stack();\n}\n\n#define RWLOCK_BUG_ON(cond, lock, msg) if (unlikely(cond)) rwlock_bug(lock, msg)\n\nvoid do_raw_read_lock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_lock(&lock->raw_lock);\n}\n\nint do_raw_read_trylock(rwlock_t *lock)\n{\n\tint ret = arch_read_trylock(&lock->raw_lock);\n\n#ifndef CONFIG_SMP\n\t \n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}\n\nvoid do_raw_read_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_unlock(&lock->raw_lock);\n}\n\nstatic inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tWRITE_ONCE(lock->owner_cpu, raw_smp_processor_id());\n\tWRITE_ONCE(lock->owner, current);\n}\n\nstatic inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tWRITE_ONCE(lock->owner, SPINLOCK_OWNER_INIT);\n\tWRITE_ONCE(lock->owner_cpu, -1);\n}\n\nvoid do_raw_write_lock(rwlock_t *lock)\n{\n\tdebug_write_lock_before(lock);\n\tarch_write_lock(&lock->raw_lock);\n\tdebug_write_lock_after(lock);\n}\n\nint do_raw_write_trylock(rwlock_t *lock)\n{\n\tint ret = arch_write_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_write_lock_after(lock);\n#ifndef CONFIG_SMP\n\t \n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}\n\nvoid do_raw_write_unlock(rwlock_t *lock)\n{\n\tdebug_write_unlock(lock);\n\tarch_write_unlock(&lock->raw_lock);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}