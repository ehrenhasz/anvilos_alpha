{
  "module_name": "test-ww_mutex.c",
  "hash_id": "9ed358357bcf0e4f9e641cc7e442799dcb00a8c927475296d504f021621d6fa9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/test-ww_mutex.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/ww_mutex.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\n#ifdef CONFIG_DEBUG_WW_MUTEX_SLOWPATH\n#define ww_acquire_init_noinject(a, b) do { \\\n\t\tww_acquire_init((a), (b)); \\\n\t\t(a)->deadlock_inject_countdown = ~0U; \\\n\t} while (0)\n#else\n#define ww_acquire_init_noinject(a, b) ww_acquire_init((a), (b))\n#endif\n\nstruct test_mutex {\n\tstruct work_struct work;\n\tstruct ww_mutex mutex;\n\tstruct completion ready, go, done;\n\tunsigned int flags;\n};\n\n#define TEST_MTX_SPIN BIT(0)\n#define TEST_MTX_TRY BIT(1)\n#define TEST_MTX_CTX BIT(2)\n#define __TEST_MTX_LAST BIT(3)\n\nstatic void test_mutex_work(struct work_struct *work)\n{\n\tstruct test_mutex *mtx = container_of(work, typeof(*mtx), work);\n\n\tcomplete(&mtx->ready);\n\twait_for_completion(&mtx->go);\n\n\tif (mtx->flags & TEST_MTX_TRY) {\n\t\twhile (!ww_mutex_trylock(&mtx->mutex, NULL))\n\t\t\tcond_resched();\n\t} else {\n\t\tww_mutex_lock(&mtx->mutex, NULL);\n\t}\n\tcomplete(&mtx->done);\n\tww_mutex_unlock(&mtx->mutex);\n}\n\nstatic int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}\n\nstatic int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int test_aa(bool trylock)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\tconst char *from = trylock ? \"trylock\" : \"lock\";\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tif (!trylock) {\n\t\tret = ww_mutex_lock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial lock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = !ww_mutex_trylock(&mutex, &ctx);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: initial trylock failed!\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ww_mutex_trylock(&mutex, NULL))  {\n\t\tpr_err(\"%s: trylocked itself without context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ww_mutex_trylock(&mutex, &ctx))  {\n\t\tpr_err(\"%s: trylocked itself with context from %s!\\n\", __func__, from);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d from %s\\n\",\n\t\t       __func__, ret, from);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tww_mutex_unlock(&mutex);\n\tret = 0;\nout:\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}\n\nstruct test_abba {\n\tstruct work_struct work;\n\tstruct ww_mutex a_mutex;\n\tstruct ww_mutex b_mutex;\n\tstruct completion a_ready;\n\tstruct completion b_ready;\n\tbool resolve, trylock;\n\tint result;\n};\n\nstatic void test_abba_work(struct work_struct *work)\n{\n\tstruct test_abba *abba = container_of(work, typeof(*abba), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err;\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!abba->trylock)\n\t\tww_mutex_lock(&abba->b_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba->b_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba->b_mutex.ctx) != &ctx);\n\n\tcomplete(&abba->b_ready);\n\twait_for_completion(&abba->a_ready);\n\n\terr = ww_mutex_lock(&abba->a_mutex, &ctx);\n\tif (abba->resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba->b_mutex);\n\t\tww_mutex_lock_slow(&abba->a_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba->b_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba->a_mutex);\n\tww_mutex_unlock(&abba->b_mutex);\n\tww_acquire_fini(&ctx);\n\n\tabba->result = err;\n}\n\nstatic int test_abba(bool trylock, bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.trylock = trylock;\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tif (!trylock)\n\t\tww_mutex_lock(&abba.a_mutex, &ctx);\n\telse\n\t\tWARN_ON(!ww_mutex_trylock(&abba.a_mutex, &ctx));\n\n\tWARN_ON(READ_ONCE(abba.a_mutex.ctx) != &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstruct test_cycle {\n\tstruct work_struct work;\n\tstruct ww_mutex a_mutex;\n\tstruct ww_mutex *b_mutex;\n\tstruct completion *a_signal;\n\tstruct completion b_signal;\n\tint result;\n};\n\nstatic void test_cycle_work(struct work_struct *work)\n{\n\tstruct test_cycle *cycle = container_of(work, typeof(*cycle), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err, erra = 0;\n\n\tww_acquire_init_noinject(&ctx, &ww_class);\n\tww_mutex_lock(&cycle->a_mutex, &ctx);\n\n\tcomplete(cycle->a_signal);\n\twait_for_completion(&cycle->b_signal);\n\n\terr = ww_mutex_lock(cycle->b_mutex, &ctx);\n\tif (err == -EDEADLK) {\n\t\terr = 0;\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\t\tww_mutex_lock_slow(cycle->b_mutex, &ctx);\n\t\terra = ww_mutex_lock(&cycle->a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(cycle->b_mutex);\n\tif (!erra)\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tcycle->result = err ?: erra;\n}\n\nstatic int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}\n\nstatic int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct stress {\n\tstruct work_struct work;\n\tstruct ww_mutex *locks;\n\tunsigned long timeout;\n\tint nlocks;\n};\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_u32_below(n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}\n\nstatic void stress_inorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *locks = stress->locks;\n\tstruct ww_acquire_ctx ctx;\n\tint *order;\n\n\torder = get_random_order(nlocks);\n\tif (!order)\n\t\treturn;\n\n\tdo {\n\t\tint contended = -1;\n\t\tint n, err;\n\n\t\tww_acquire_init(&ctx, &ww_class);\nretry:\n\t\terr = 0;\n\t\tfor (n = 0; n < nlocks; n++) {\n\t\t\tif (n == contended)\n\t\t\t\tcontinue;\n\n\t\t\terr = ww_mutex_lock(&locks[order[n]], &ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!err)\n\t\t\tdummy_load(stress);\n\n\t\tif (contended > n)\n\t\t\tww_mutex_unlock(&locks[order[contended]]);\n\t\tcontended = n;\n\t\twhile (n--)\n\t\t\tww_mutex_unlock(&locks[order[n]]);\n\n\t\tif (err == -EDEADLK) {\n\t\t\tww_mutex_lock_slow(&locks[order[contended]], &ctx);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(order);\n}\n\nstruct reorder_lock {\n\tstruct list_head link;\n\tstruct ww_mutex *lock;\n};\n\nstatic void stress_reorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tLIST_HEAD(locks);\n\tstruct ww_acquire_ctx ctx;\n\tstruct reorder_lock *ll, *ln;\n\tint *order;\n\tint n, err;\n\n\torder = get_random_order(stress->nlocks);\n\tif (!order)\n\t\treturn;\n\n\tfor (n = 0; n < stress->nlocks; n++) {\n\t\tll = kmalloc(sizeof(*ll), GFP_KERNEL);\n\t\tif (!ll)\n\t\t\tgoto out;\n\n\t\tll->lock = &stress->locks[order[n]];\n\t\tlist_add(&ll->link, &locks);\n\t}\n\tkfree(order);\n\torder = NULL;\n\n\tdo {\n\t\tww_acquire_init(&ctx, &ww_class);\n\n\t\tlist_for_each_entry(ll, &locks, link) {\n\t\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\tln = ll;\n\t\t\tlist_for_each_entry_continue_reverse(ln, &locks, link)\n\t\t\t\tww_mutex_unlock(ln->lock);\n\n\t\t\tif (err != -EDEADLK) {\n\t\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t\t    __func__, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\t\tlist_move(&ll->link, &locks);  \n\t\t}\n\n\t\tdummy_load(stress);\n\t\tlist_for_each_entry(ll, &locks, link)\n\t\t\tww_mutex_unlock(ll->lock);\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\nout:\n\tlist_for_each_entry_safe(ll, ln, &locks, link)\n\t\tkfree(ll);\n\tkfree(order);\n}\n\nstatic void stress_one_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *lock = stress->locks + get_random_u32_below(nlocks);\n\tint err;\n\n\tdo {\n\t\terr = ww_mutex_lock(lock, NULL);\n\t\tif (!err) {\n\t\t\tdummy_load(stress);\n\t\t\tww_mutex_unlock(lock);\n\t\t} else {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\t} while (!time_after(jiffies, stress->timeout));\n}\n\n#define STRESS_INORDER BIT(0)\n#define STRESS_REORDER BIT(1)\n#define STRESS_ONE BIT(2)\n#define STRESS_ALL (STRESS_INORDER | STRESS_REORDER | STRESS_ONE)\n\nstatic int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tstruct stress *stress_array;\n\tint n, count;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tstress_array = kmalloc_array(nthreads, sizeof(*stress_array),\n\t\t\t\t     GFP_KERNEL);\n\tif (!stress_array) {\n\t\tkfree(locks);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tcount = 0;\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = &stress_array[count++];\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(stress_array);\n\tkfree(locks);\n\n\treturn 0;\n}\n\nstatic int __init test_ww_mutex_init(void)\n{\n\tint ncpus = num_online_cpus();\n\tint ret, i;\n\n\tprintk(KERN_INFO \"Beginning ww mutex selftests\\n\");\n\n\twq = alloc_workqueue(\"test-ww_mutex\", WQ_UNBOUND, 0);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = test_mutex();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa(false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa(true);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = test_abba(i & 1, i & 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = test_cycle(ncpus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_INORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_REORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(2047, hweight32(STRESS_ALL)*ncpus, STRESS_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\tprintk(KERN_INFO \"All ww mutex selftests passed\\n\");\n\treturn 0;\n}\n\nstatic void __exit test_ww_mutex_exit(void)\n{\n\tdestroy_workqueue(wq);\n}\n\nmodule_init(test_ww_mutex_init);\nmodule_exit(test_ww_mutex_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Intel Corporation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}