{
  "module_name": "percpu-rwsem.c",
  "hash_id": "ab16d664ef0d76bdada29c0b293ffb3b05d9256548eb46803048e95ea29c4516",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/percpu-rwsem.c",
  "human_readable_source": "\n#include <linux/atomic.h>\n#include <linux/percpu.h>\n#include <linux/wait.h>\n#include <linux/lockdep.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/rcupdate.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/errno.h>\n#include <trace/events/lock.h>\n\nint __percpu_init_rwsem(struct percpu_rw_semaphore *sem,\n\t\t\tconst char *name, struct lock_class_key *key)\n{\n\tsem->read_count = alloc_percpu(int);\n\tif (unlikely(!sem->read_count))\n\t\treturn -ENOMEM;\n\n\trcu_sync_init(&sem->rss);\n\trcuwait_init(&sem->writer);\n\tinit_waitqueue_head(&sem->waiters);\n\tatomic_set(&sem->block, 0);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tdebug_check_no_locks_freed((void *)sem, sizeof(*sem));\n\tlockdep_init_map(&sem->dep_map, name, key, 0);\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__percpu_init_rwsem);\n\nvoid percpu_free_rwsem(struct percpu_rw_semaphore *sem)\n{\n\t \n\tif (!sem->read_count)\n\t\treturn;\n\n\trcu_sync_dtor(&sem->rss);\n\tfree_percpu(sem->read_count);\n\tsem->read_count = NULL;  \n}\nEXPORT_SYMBOL_GPL(percpu_free_rwsem);\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t \n\n\tsmp_mb();  \n\n\t \n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t \n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}\n\nstatic inline bool __percpu_down_write_trylock(struct percpu_rw_semaphore *sem)\n{\n\tif (atomic_read(&sem->block))\n\t\treturn false;\n\n\treturn atomic_xchg(&sem->block, 1) == 0;\n}\n\nstatic bool __percpu_rwsem_trylock(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tif (reader) {\n\t\tbool ret;\n\n\t\tpreempt_disable();\n\t\tret = __percpu_down_read_trylock(sem);\n\t\tpreempt_enable();\n\n\t\treturn ret;\n\t}\n\treturn __percpu_down_write_trylock(sem);\n}\n\n \nstatic int percpu_rwsem_wake_function(struct wait_queue_entry *wq_entry,\n\t\t\t\t      unsigned int mode, int wake_flags,\n\t\t\t\t      void *key)\n{\n\tbool reader = wq_entry->flags & WQ_FLAG_CUSTOM;\n\tstruct percpu_rw_semaphore *sem = key;\n\tstruct task_struct *p;\n\n\t \n\tif (!__percpu_rwsem_trylock(sem, reader))\n\t\treturn 1;\n\n\tp = get_task_struct(wq_entry->private);\n\tlist_del_init(&wq_entry->entry);\n\tsmp_store_release(&wq_entry->private, NULL);\n\n\twake_up_process(p);\n\tput_task_struct(p);\n\n\treturn !reader;  \n}\n\nstatic void percpu_rwsem_wait(struct percpu_rw_semaphore *sem, bool reader)\n{\n\tDEFINE_WAIT_FUNC(wq_entry, percpu_rwsem_wake_function);\n\tbool wait;\n\n\tspin_lock_irq(&sem->waiters.lock);\n\t \n\twait = !__percpu_rwsem_trylock(sem, reader);\n\tif (wait) {\n\t\twq_entry.flags |= WQ_FLAG_EXCLUSIVE | reader * WQ_FLAG_CUSTOM;\n\t\t__add_wait_queue_entry_tail(&sem->waiters, &wq_entry);\n\t}\n\tspin_unlock_irq(&sem->waiters.lock);\n\n\twhile (wait) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!smp_load_acquire(&wq_entry.private))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}\n\nbool __sched __percpu_down_read(struct percpu_rw_semaphore *sem, bool try)\n{\n\tif (__percpu_down_read_trylock(sem))\n\t\treturn true;\n\n\tif (try)\n\t\treturn false;\n\n\ttrace_contention_begin(sem, LCB_F_PERCPU | LCB_F_READ);\n\tpreempt_enable();\n\tpercpu_rwsem_wait(sem,   true);\n\tpreempt_disable();\n\ttrace_contention_end(sem, 0);\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(__percpu_down_read);\n\n#define per_cpu_sum(var)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(var) __sum = 0;\t\t\t\t\t\t\\\n\tint cpu;\t\t\t\t\t\t\t\\\n\tcompiletime_assert_atomic_type(__sum);\t\t\t\t\\\n\tfor_each_possible_cpu(cpu)\t\t\t\t\t\\\n\t\t__sum += per_cpu(var, cpu);\t\t\t\t\\\n\t__sum;\t\t\t\t\t\t\t\t\\\n})\n\nbool percpu_is_read_locked(struct percpu_rw_semaphore *sem)\n{\n\treturn per_cpu_sum(*sem->read_count) != 0 && !atomic_read(&sem->block);\n}\nEXPORT_SYMBOL_GPL(percpu_is_read_locked);\n\n \nstatic bool readers_active_check(struct percpu_rw_semaphore *sem)\n{\n\tif (per_cpu_sum(*sem->read_count) != 0)\n\t\treturn false;\n\n\t \n\n\tsmp_mb();  \n\n\treturn true;\n}\n\nvoid __sched percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\ttrace_contention_begin(sem, LCB_F_PERCPU | LCB_F_WRITE);\n\n\t \n\trcu_sync_enter(&sem->rss);\n\n\t \n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem,   false);\n\n\t \n\n\t \n\n\t \n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n\ttrace_contention_end(sem, 0);\n}\nEXPORT_SYMBOL_GPL(percpu_down_write);\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t \n\tatomic_set_release(&sem->block, 0);\n\n\t \n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t \n\trcu_sync_exit(&sem->rss);\n}\nEXPORT_SYMBOL_GPL(percpu_up_write);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}