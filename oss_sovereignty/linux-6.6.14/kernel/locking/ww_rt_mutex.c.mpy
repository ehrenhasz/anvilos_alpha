{
  "module_name": "ww_rt_mutex.c",
  "hash_id": "a5b59aee132ecf15a1c71373f3b817fa0de81ab75ff3bfc2db4925ebea47d569",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/ww_rt_mutex.c",
  "human_readable_source": "\n \n#include <linux/spinlock.h>\n#include <linux/export.h>\n\n#define RT_MUTEX_BUILD_MUTEX\n#define WW_RT\n#include \"rtmutex.c\"\n\nint ww_mutex_trylock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\tif (!ww_ctx)\n\t\treturn rt_mutex_trylock(rtm);\n\n\t \n\tif (ww_ctx->acquired == 0)\n\t\tww_ctx->wounded = 0;\n\n\tif (__rt_mutex_trylock(&rtm->rtmutex)) {\n\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\tmutex_acquire_nest(&rtm->dep_map, 0, 1, &ww_ctx->dep_map, _RET_IP_);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ww_mutex_trylock);\n\nstatic int __sched\n__ww_rt_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ww_ctx,\n\t\t   unsigned int state, unsigned long ip)\n{\n\tstruct lockdep_map __maybe_unused *nest_lock = NULL;\n\tstruct rt_mutex *rtm = &lock->base;\n\tint ret;\n\n\tmight_sleep();\n\n\tif (ww_ctx) {\n\t\tif (unlikely(ww_ctx == READ_ONCE(lock->ctx)))\n\t\t\treturn -EALREADY;\n\n\t\t \n\t\tif (ww_ctx->acquired == 0)\n\t\t\tww_ctx->wounded = 0;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t\tnest_lock = &ww_ctx->dep_map;\n#endif\n\t}\n\tmutex_acquire_nest(&rtm->dep_map, 0, 0, nest_lock, ip);\n\n\tif (likely(rt_mutex_cmpxchg_acquire(&rtm->rtmutex, NULL, current))) {\n\t\tif (ww_ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ww_ctx);\n\t\treturn 0;\n\t}\n\n\tret = rt_mutex_slowlock(&rtm->rtmutex, ww_ctx, state);\n\n\tif (ret)\n\t\tmutex_release(&rtm->dep_map, ip);\n\treturn ret;\n}\n\nint __sched\nww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_rt_mutex_lock(lock, ctx, TASK_UNINTERRUPTIBLE, _RET_IP_);\n}\nEXPORT_SYMBOL(ww_mutex_lock);\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_rt_mutex_lock(lock, ctx, TASK_INTERRUPTIBLE, _RET_IP_);\n}\nEXPORT_SYMBOL(ww_mutex_lock_interruptible);\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\tstruct rt_mutex *rtm = &lock->base;\n\n\t__ww_mutex_unlock(lock);\n\n\tmutex_release(&rtm->dep_map, _RET_IP_);\n\t__rt_mutex_unlock(&rtm->rtmutex);\n}\nEXPORT_SYMBOL(ww_mutex_unlock);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}