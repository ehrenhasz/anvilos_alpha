{
  "module_name": "semaphore.c",
  "hash_id": "0574e52badbbde6118b0a6c749c42679696985ddb0cd5e1a626b36b3fd775da9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/semaphore.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/semaphore.h>\n#include <linux/spinlock.h>\n#include <linux/ftrace.h>\n#include <trace/events/lock.h>\n\nstatic noinline void __down(struct semaphore *sem);\nstatic noinline int __down_interruptible(struct semaphore *sem);\nstatic noinline int __down_killable(struct semaphore *sem);\nstatic noinline int __down_timeout(struct semaphore *sem, long timeout);\nstatic noinline void __up(struct semaphore *sem);\n\n \nvoid __sched down(struct semaphore *sem)\n{\n\tunsigned long flags;\n\n\tmight_sleep();\n\traw_spin_lock_irqsave(&sem->lock, flags);\n\tif (likely(sem->count > 0))\n\t\tsem->count--;\n\telse\n\t\t__down(sem);\n\traw_spin_unlock_irqrestore(&sem->lock, flags);\n}\nEXPORT_SYMBOL(down);\n\n \nint __sched down_interruptible(struct semaphore *sem)\n{\n\tunsigned long flags;\n\tint result = 0;\n\n\tmight_sleep();\n\traw_spin_lock_irqsave(&sem->lock, flags);\n\tif (likely(sem->count > 0))\n\t\tsem->count--;\n\telse\n\t\tresult = __down_interruptible(sem);\n\traw_spin_unlock_irqrestore(&sem->lock, flags);\n\n\treturn result;\n}\nEXPORT_SYMBOL(down_interruptible);\n\n \nint __sched down_killable(struct semaphore *sem)\n{\n\tunsigned long flags;\n\tint result = 0;\n\n\tmight_sleep();\n\traw_spin_lock_irqsave(&sem->lock, flags);\n\tif (likely(sem->count > 0))\n\t\tsem->count--;\n\telse\n\t\tresult = __down_killable(sem);\n\traw_spin_unlock_irqrestore(&sem->lock, flags);\n\n\treturn result;\n}\nEXPORT_SYMBOL(down_killable);\n\n \nint __sched down_trylock(struct semaphore *sem)\n{\n\tunsigned long flags;\n\tint count;\n\n\traw_spin_lock_irqsave(&sem->lock, flags);\n\tcount = sem->count - 1;\n\tif (likely(count >= 0))\n\t\tsem->count = count;\n\traw_spin_unlock_irqrestore(&sem->lock, flags);\n\n\treturn (count < 0);\n}\nEXPORT_SYMBOL(down_trylock);\n\n \nint __sched down_timeout(struct semaphore *sem, long timeout)\n{\n\tunsigned long flags;\n\tint result = 0;\n\n\tmight_sleep();\n\traw_spin_lock_irqsave(&sem->lock, flags);\n\tif (likely(sem->count > 0))\n\t\tsem->count--;\n\telse\n\t\tresult = __down_timeout(sem, timeout);\n\traw_spin_unlock_irqrestore(&sem->lock, flags);\n\n\treturn result;\n}\nEXPORT_SYMBOL(down_timeout);\n\n \nvoid __sched up(struct semaphore *sem)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sem->lock, flags);\n\tif (likely(list_empty(&sem->wait_list)))\n\t\tsem->count++;\n\telse\n\t\t__up(sem);\n\traw_spin_unlock_irqrestore(&sem->lock, flags);\n}\nEXPORT_SYMBOL(up);\n\n \n\nstruct semaphore_waiter {\n\tstruct list_head list;\n\tstruct task_struct *task;\n\tbool up;\n};\n\n \nstatic inline int __sched ___down_common(struct semaphore *sem, long state,\n\t\t\t\t\t\t\t\tlong timeout)\n{\n\tstruct semaphore_waiter waiter;\n\n\tlist_add_tail(&waiter.list, &sem->wait_list);\n\twaiter.task = current;\n\twaiter.up = false;\n\n\tfor (;;) {\n\t\tif (signal_pending_state(state, current))\n\t\t\tgoto interrupted;\n\t\tif (unlikely(timeout <= 0))\n\t\t\tgoto timed_out;\n\t\t__set_current_state(state);\n\t\traw_spin_unlock_irq(&sem->lock);\n\t\ttimeout = schedule_timeout(timeout);\n\t\traw_spin_lock_irq(&sem->lock);\n\t\tif (waiter.up)\n\t\t\treturn 0;\n\t}\n\n timed_out:\n\tlist_del(&waiter.list);\n\treturn -ETIME;\n\n interrupted:\n\tlist_del(&waiter.list);\n\treturn -EINTR;\n}\n\nstatic inline int __sched __down_common(struct semaphore *sem, long state,\n\t\t\t\t\tlong timeout)\n{\n\tint ret;\n\n\ttrace_contention_begin(sem, 0);\n\tret = ___down_common(sem, state, timeout);\n\ttrace_contention_end(sem, ret);\n\n\treturn ret;\n}\n\nstatic noinline void __sched __down(struct semaphore *sem)\n{\n\t__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic noinline int __sched __down_interruptible(struct semaphore *sem)\n{\n\treturn __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic noinline int __sched __down_killable(struct semaphore *sem)\n{\n\treturn __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);\n}\n\nstatic noinline int __sched __down_timeout(struct semaphore *sem, long timeout)\n{\n\treturn __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);\n}\n\nstatic noinline void __sched __up(struct semaphore *sem)\n{\n\tstruct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,\n\t\t\t\t\t\tstruct semaphore_waiter, list);\n\tlist_del(&waiter->list);\n\twaiter->up = true;\n\twake_up_process(waiter->task);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}