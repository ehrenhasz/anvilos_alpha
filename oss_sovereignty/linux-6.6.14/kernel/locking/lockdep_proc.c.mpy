{
  "module_name": "lockdep_proc.c",
  "hash_id": "16f0870df2660cc0543798bafed93e9f3c7a75a8b2019b98eba834624de7a838",
  "original_prompt": "Ingested from linux-6.6.14/kernel/locking/lockdep_proc.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/debug_locks.h>\n#include <linux/vmalloc.h>\n#include <linux/sort.h>\n#include <linux/uaccess.h>\n#include <asm/div64.h>\n\n#include \"lockdep_internals.h\"\n\n \n#define iterate_lock_classes(idx, class)\t\t\t\t\\\n\tfor (idx = 0, class = lock_classes; idx <= max_lock_class_idx;\t\\\n\t     idx++, class++)\n\nstatic void *l_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct lock_class *class = v;\n\n\t++class;\n\t*pos = class - lock_classes;\n\treturn (*pos > max_lock_class_idx) ? NULL : class;\n}\n\nstatic void *l_start(struct seq_file *m, loff_t *pos)\n{\n\tunsigned long idx = *pos;\n\n\tif (idx > max_lock_class_idx)\n\t\treturn NULL;\n\treturn lock_classes + idx;\n}\n\nstatic void l_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic void print_name(struct seq_file *m, struct lock_class *class)\n{\n\tchar str[KSYM_NAME_LEN];\n\tconst char *name = class->name;\n\n\tif (!name) {\n\t\tname = __get_key_name(class->key, str);\n\t\tseq_printf(m, \"%s\", name);\n\t} else{\n\t\tseq_printf(m, \"%s\", name);\n\t\tif (class->name_version > 1)\n\t\t\tseq_printf(m, \"#%d\", class->name_version);\n\t\tif (class->subclass)\n\t\t\tseq_printf(m, \"/%d\", class->subclass);\n\t}\n}\n\nstatic int l_show(struct seq_file *m, void *v)\n{\n\tstruct lock_class *class = v;\n\tstruct lock_list *entry;\n\tchar usage[LOCK_USAGE_CHARS];\n\tint idx = class - lock_classes;\n\n\tif (v == lock_classes)\n\t\tseq_printf(m, \"all lock classes:\\n\");\n\n\tif (!test_bit(idx, lock_classes_in_use))\n\t\treturn 0;\n\n\tseq_printf(m, \"%p\", class->key);\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tseq_printf(m, \" OPS:%8ld\", debug_class_ops_read(class));\n#endif\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tseq_printf(m, \" FD:%5ld\", lockdep_count_forward_deps(class));\n\t\tseq_printf(m, \" BD:%5ld\", lockdep_count_backward_deps(class));\n\n\t\tget_usage_chars(class, usage);\n\t\tseq_printf(m, \" %s\", usage);\n\t}\n\n\tseq_printf(m, \": \");\n\tprint_name(m, class);\n\tseq_puts(m, \"\\n\");\n\n\tif (IS_ENABLED(CONFIG_PROVE_LOCKING)) {\n\t\tlist_for_each_entry(entry, &class->locks_after, entry) {\n\t\t\tif (entry->distance == 1) {\n\t\t\t\tseq_printf(m, \" -> [%p] \", entry->class->key);\n\t\t\t\tprint_name(m, entry->class);\n\t\t\t\tseq_puts(m, \"\\n\");\n\t\t\t}\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations lockdep_ops = {\n\t.start\t= l_start,\n\t.next\t= l_next,\n\t.stop\t= l_stop,\n\t.show\t= l_show,\n};\n\n#ifdef CONFIG_PROVE_LOCKING\nstatic void *lc_start(struct seq_file *m, loff_t *pos)\n{\n\tif (*pos < 0)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn lock_chains + (*pos - 1);\n}\n\nstatic void *lc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t*pos = lockdep_next_lockchain(*pos - 1) + 1;\n\treturn lc_start(m, pos);\n}\n\nstatic void lc_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int lc_show(struct seq_file *m, void *v)\n{\n\tstruct lock_chain *chain = v;\n\tstruct lock_class *class;\n\tint i;\n\tstatic const char * const irq_strs[] = {\n\t\t[0]\t\t\t     = \"0\",\n\t\t[LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq\",\n\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT] = \"softirq\",\n\t\t[LOCK_CHAIN_SOFTIRQ_CONTEXT|\n\t\t LOCK_CHAIN_HARDIRQ_CONTEXT] = \"hardirq|softirq\",\n\t};\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tif (!nr_free_chain_hlocks)\n\t\t\tseq_printf(m, \"(buggered) \");\n\t\tseq_printf(m, \"all lock chains:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"irq_context: %s\\n\", irq_strs[chain->irq_context]);\n\n\tfor (i = 0; i < chain->depth; i++) {\n\t\tclass = lock_chain_get_class(chain, i);\n\t\tif (!class->key)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"[%p] \", class->key);\n\t\tprint_name(m, class);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\nstatic const struct seq_operations lockdep_chains_ops = {\n\t.start\t= lc_start,\n\t.next\t= lc_next,\n\t.stop\t= lc_stop,\n\t.show\t= lc_show,\n};\n#endif  \n\nstatic void lockdep_stats_debug_show(struct seq_file *m)\n{\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tunsigned long long hi1 = debug_atomic_read(hardirqs_on_events),\n\t\t\t   hi2 = debug_atomic_read(hardirqs_off_events),\n\t\t\t   hr1 = debug_atomic_read(redundant_hardirqs_on),\n\t\t\t   hr2 = debug_atomic_read(redundant_hardirqs_off),\n\t\t\t   si1 = debug_atomic_read(softirqs_on_events),\n\t\t\t   si2 = debug_atomic_read(softirqs_off_events),\n\t\t\t   sr1 = debug_atomic_read(redundant_softirqs_on),\n\t\t\t   sr2 = debug_atomic_read(redundant_softirqs_off);\n\n\tseq_printf(m, \" chain lookup misses:           %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_misses));\n\tseq_printf(m, \" chain lookup hits:             %11llu\\n\",\n\t\tdebug_atomic_read(chain_lookup_hits));\n\tseq_printf(m, \" cyclic checks:                 %11llu\\n\",\n\t\tdebug_atomic_read(nr_cyclic_checks));\n\tseq_printf(m, \" redundant checks:              %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant_checks));\n\tseq_printf(m, \" redundant links:               %11llu\\n\",\n\t\tdebug_atomic_read(nr_redundant));\n\tseq_printf(m, \" find-mask forwards checks:     %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_forwards_checks));\n\tseq_printf(m, \" find-mask backwards checks:    %11llu\\n\",\n\t\tdebug_atomic_read(nr_find_usage_backwards_checks));\n\n\tseq_printf(m, \" hardirq on events:             %11llu\\n\", hi1);\n\tseq_printf(m, \" hardirq off events:            %11llu\\n\", hi2);\n\tseq_printf(m, \" redundant hardirq ons:         %11llu\\n\", hr1);\n\tseq_printf(m, \" redundant hardirq offs:        %11llu\\n\", hr2);\n\tseq_printf(m, \" softirq on events:             %11llu\\n\", si1);\n\tseq_printf(m, \" softirq off events:            %11llu\\n\", si2);\n\tseq_printf(m, \" redundant softirq ons:         %11llu\\n\", sr1);\n\tseq_printf(m, \" redundant softirq offs:        %11llu\\n\", sr2);\n#endif\n}\n\nstatic int lockdep_stats_show(struct seq_file *m, void *v)\n{\n\tunsigned long nr_unused = 0, nr_uncategorized = 0,\n\t\t      nr_irq_safe = 0, nr_irq_unsafe = 0,\n\t\t      nr_softirq_safe = 0, nr_softirq_unsafe = 0,\n\t\t      nr_hardirq_safe = 0, nr_hardirq_unsafe = 0,\n\t\t      nr_irq_read_safe = 0, nr_irq_read_unsafe = 0,\n\t\t      nr_softirq_read_safe = 0, nr_softirq_read_unsafe = 0,\n\t\t      nr_hardirq_read_safe = 0, nr_hardirq_read_unsafe = 0,\n\t\t      sum_forward_deps = 0;\n\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct lock_class *class;\n\tunsigned long idx;\n\n\titerate_lock_classes(idx, class) {\n\t\tif (!test_bit(idx, lock_classes_in_use))\n\t\t\tcontinue;\n\n\t\tif (class->usage_mask == 0)\n\t\t\tnr_unused++;\n\t\tif (class->usage_mask == LOCKF_USED)\n\t\t\tnr_uncategorized++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ)\n\t\t\tnr_irq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ)\n\t\t\tnr_irq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ)\n\t\t\tnr_softirq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ)\n\t\t\tnr_softirq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ)\n\t\t\tnr_hardirq_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ)\n\t\t\tnr_hardirq_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_IRQ_READ)\n\t\t\tnr_irq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_IRQ_READ)\n\t\t\tnr_irq_read_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_SOFTIRQ_READ)\n\t\t\tnr_softirq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_SOFTIRQ_READ)\n\t\t\tnr_softirq_read_unsafe++;\n\t\tif (class->usage_mask & LOCKF_USED_IN_HARDIRQ_READ)\n\t\t\tnr_hardirq_read_safe++;\n\t\tif (class->usage_mask & LOCKF_ENABLED_HARDIRQ_READ)\n\t\t\tnr_hardirq_read_unsafe++;\n\n\t\tsum_forward_deps += lockdep_count_forward_deps(class);\n\t}\n\n#ifdef CONFIG_DEBUG_LOCKDEP\n\tDEBUG_LOCKS_WARN_ON(debug_atomic_read(nr_unused_locks) != nr_unused);\n#endif\n\n#endif\n\tseq_printf(m, \" lock-classes:                  %11lu [max: %lu]\\n\",\n\t\t\tnr_lock_classes, MAX_LOCKDEP_KEYS);\n\tseq_printf(m, \" direct dependencies:           %11lu [max: %lu]\\n\",\n\t\t\tnr_list_entries, MAX_LOCKDEP_ENTRIES);\n\tseq_printf(m, \" indirect dependencies:         %11lu\\n\",\n\t\t\tsum_forward_deps);\n\n\t \n\tseq_printf(m, \" all direct dependencies:       %11lu\\n\",\n\t\t\tnr_irq_unsafe * nr_irq_safe +\n\t\t\tnr_hardirq_unsafe * nr_hardirq_safe +\n\t\t\tnr_list_entries);\n\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" dependency chains:             %11lu [max: %lu]\\n\",\n\t\t\tlock_chain_count(), MAX_LOCKDEP_CHAINS);\n\tseq_printf(m, \" dependency chain hlocks used:  %11lu [max: %lu]\\n\",\n\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS -\n\t\t\t(nr_free_chain_hlocks + nr_lost_chain_hlocks),\n\t\t\tMAX_LOCKDEP_CHAIN_HLOCKS);\n\tseq_printf(m, \" dependency chain hlocks lost:  %11u\\n\",\n\t\t\tnr_lost_chain_hlocks);\n#endif\n\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tseq_printf(m, \" in-hardirq chains:             %11u\\n\",\n\t\t\tnr_hardirq_chains);\n\tseq_printf(m, \" in-softirq chains:             %11u\\n\",\n\t\t\tnr_softirq_chains);\n#endif\n\tseq_printf(m, \" in-process chains:             %11u\\n\",\n\t\t\tnr_process_chains);\n\tseq_printf(m, \" stack-trace entries:           %11lu [max: %lu]\\n\",\n\t\t\tnr_stack_trace_entries, MAX_STACK_TRACE_ENTRIES);\n#if defined(CONFIG_TRACE_IRQFLAGS) && defined(CONFIG_PROVE_LOCKING)\n\tseq_printf(m, \" number of stack traces:        %11llu\\n\",\n\t\t   lockdep_stack_trace_count());\n\tseq_printf(m, \" number of stack hash chains:   %11llu\\n\",\n\t\t   lockdep_stack_hash_count());\n#endif\n\tseq_printf(m, \" combined max dependencies:     %11u\\n\",\n\t\t\t(nr_hardirq_chains + 1) *\n\t\t\t(nr_softirq_chains + 1) *\n\t\t\t(nr_process_chains + 1)\n\t);\n\tseq_printf(m, \" hardirq-safe locks:            %11lu\\n\",\n\t\t\tnr_hardirq_safe);\n\tseq_printf(m, \" hardirq-unsafe locks:          %11lu\\n\",\n\t\t\tnr_hardirq_unsafe);\n\tseq_printf(m, \" softirq-safe locks:            %11lu\\n\",\n\t\t\tnr_softirq_safe);\n\tseq_printf(m, \" softirq-unsafe locks:          %11lu\\n\",\n\t\t\tnr_softirq_unsafe);\n\tseq_printf(m, \" irq-safe locks:                %11lu\\n\",\n\t\t\tnr_irq_safe);\n\tseq_printf(m, \" irq-unsafe locks:              %11lu\\n\",\n\t\t\tnr_irq_unsafe);\n\n\tseq_printf(m, \" hardirq-read-safe locks:       %11lu\\n\",\n\t\t\tnr_hardirq_read_safe);\n\tseq_printf(m, \" hardirq-read-unsafe locks:     %11lu\\n\",\n\t\t\tnr_hardirq_read_unsafe);\n\tseq_printf(m, \" softirq-read-safe locks:       %11lu\\n\",\n\t\t\tnr_softirq_read_safe);\n\tseq_printf(m, \" softirq-read-unsafe locks:     %11lu\\n\",\n\t\t\tnr_softirq_read_unsafe);\n\tseq_printf(m, \" irq-read-safe locks:           %11lu\\n\",\n\t\t\tnr_irq_read_safe);\n\tseq_printf(m, \" irq-read-unsafe locks:         %11lu\\n\",\n\t\t\tnr_irq_read_unsafe);\n\n\tseq_printf(m, \" uncategorized locks:           %11lu\\n\",\n\t\t\tnr_uncategorized);\n\tseq_printf(m, \" unused locks:                  %11lu\\n\",\n\t\t\tnr_unused);\n\tseq_printf(m, \" max locking depth:             %11u\\n\",\n\t\t\tmax_lockdep_depth);\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" max bfs queue depth:           %11u\\n\",\n\t\t\tmax_bfs_queue_depth);\n#endif\n\tseq_printf(m, \" max lock class index:          %11lu\\n\",\n\t\t\tmax_lock_class_idx);\n\tlockdep_stats_debug_show(m);\n\tseq_printf(m, \" debug_locks:                   %11u\\n\",\n\t\t\tdebug_locks);\n\n\t \n\tseq_puts(m, \"\\n\");\n\tseq_printf(m, \" zapped classes:                %11lu\\n\",\n\t\t\tnr_zapped_classes);\n#ifdef CONFIG_PROVE_LOCKING\n\tseq_printf(m, \" zapped lock chains:            %11lu\\n\",\n\t\t\tnr_zapped_lock_chains);\n\tseq_printf(m, \" large chain blocks:            %11u\\n\",\n\t\t\tnr_large_chain_blocks);\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_LOCK_STAT\n\nstruct lock_stat_data {\n\tstruct lock_class *class;\n\tstruct lock_class_stats stats;\n};\n\nstruct lock_stat_seq {\n\tstruct lock_stat_data *iter_end;\n\tstruct lock_stat_data stats[MAX_LOCKDEP_KEYS];\n};\n\n \nstatic int lock_stat_cmp(const void *l, const void *r)\n{\n\tconst struct lock_stat_data *dl = l, *dr = r;\n\tunsigned long nl, nr;\n\n\tnl = dl->stats.read_waittime.nr + dl->stats.write_waittime.nr;\n\tnr = dr->stats.read_waittime.nr + dr->stats.write_waittime.nr;\n\n\treturn nr - nl;\n}\n\nstatic void seq_line(struct seq_file *m, char c, int offset, int length)\n{\n\tint i;\n\n\tfor (i = 0; i < offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5;  \n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}\n\nstatic void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}\n\nstatic void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->nr);\n\tseq_time(m, lt->min);\n\tseq_time(m, lt->max);\n\tseq_time(m, lt->total);\n\tseq_time(m, lt->nr ? div64_u64(lt->total, lt->nr) : 0);\n}\n\nstatic void seq_stats(struct seq_file *m, struct lock_stat_data *data)\n{\n\tconst struct lockdep_subclass_key *ckey;\n\tstruct lock_class_stats *stats;\n\tstruct lock_class *class;\n\tconst char *cname;\n\tint i, namelen;\n\tchar name[39];\n\n\tclass = data->class;\n\tstats = &data->stats;\n\n\tnamelen = 38;\n\tif (class->name_version > 1)\n\t\tnamelen -= 2;  \n\tif (class->subclass)\n\t\tnamelen -= 2;\n\n\trcu_read_lock_sched();\n\tcname = rcu_dereference_sched(class->name);\n\tckey  = rcu_dereference_sched(class->key);\n\n\tif (!cname && !ckey) {\n\t\trcu_read_unlock_sched();\n\t\treturn;\n\n\t} else if (!cname) {\n\t\tchar str[KSYM_NAME_LEN];\n\t\tconst char *key_name;\n\n\t\tkey_name = __get_key_name(ckey, str);\n\t\tsnprintf(name, namelen, \"%s\", key_name);\n\t} else {\n\t\tsnprintf(name, namelen, \"%s\", cname);\n\t}\n\trcu_read_unlock_sched();\n\n\tnamelen = strlen(name);\n\tif (class->name_version > 1) {\n\t\tsnprintf(name+namelen, 3, \"#%d\", class->name_version);\n\t\tnamelen += 2;\n\t}\n\tif (class->subclass) {\n\t\tsnprintf(name+namelen, 3, \"/%d\", class->subclass);\n\t\tnamelen += 2;\n\t}\n\n\tif (stats->write_holdtime.nr) {\n\t\tif (stats->read_holdtime.nr)\n\t\t\tseq_printf(m, \"%38s-W:\", name);\n\t\telse\n\t\t\tseq_printf(m, \"%40s:\", name);\n\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_write]);\n\t\tseq_lock_time(m, &stats->write_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_write]);\n\t\tseq_lock_time(m, &stats->write_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_holdtime.nr) {\n\t\tseq_printf(m, \"%38s-R:\", name);\n\t\tseq_printf(m, \"%14lu \", stats->bounces[bounce_contended_read]);\n\t\tseq_lock_time(m, &stats->read_waittime);\n\t\tseq_printf(m, \" %14lu \", stats->bounces[bounce_acquired_read]);\n\t\tseq_lock_time(m, &stats->read_holdtime);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (stats->read_waittime.nr + stats->write_waittime.nr == 0)\n\t\treturn;\n\n\tif (stats->read_holdtime.nr)\n\t\tnamelen += 2;\n\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contention_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contention_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contention_point[i],\n\t\t\t   ip, (void *)class->contention_point[i]);\n\t}\n\tfor (i = 0; i < LOCKSTAT_POINTS; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->contending_point[i] == 0)\n\t\t\tbreak;\n\n\t\tif (!i)\n\t\t\tseq_line(m, '-', 40-namelen, namelen);\n\n\t\tsnprintf(ip, sizeof(ip), \"[<%p>]\",\n\t\t\t\t(void *)class->contending_point[i]);\n\t\tseq_printf(m, \"%40s %14lu %29s %pS\\n\",\n\t\t\t   name, stats->contending_point[i],\n\t\t\t   ip, (void *)class->contending_point[i]);\n\t}\n\tif (i) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_line(m, '.', 0, 40 + 1 + 12 * (14 + 1));\n\t\tseq_puts(m, \"\\n\");\n\t}\n}\n\nstatic void seq_header(struct seq_file *m)\n{\n\tseq_puts(m, \"lock_stat version 0.4\\n\");\n\n\tif (unlikely(!debug_locks))\n\t\tseq_printf(m, \"*WARNING* lock debugging disabled!! - possibly due to a lockdep warning\\n\");\n\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"\n\t\t\t\"%14s %14s\\n\",\n\t\t\t\"class name\",\n\t\t\t\"con-bounces\",\n\t\t\t\"contentions\",\n\t\t\t\"waittime-min\",\n\t\t\t\"waittime-max\",\n\t\t\t\"waittime-total\",\n\t\t\t\"waittime-avg\",\n\t\t\t\"acq-bounces\",\n\t\t\t\"acquisitions\",\n\t\t\t\"holdtime-min\",\n\t\t\t\"holdtime-max\",\n\t\t\t\"holdtime-total\",\n\t\t\t\"holdtime-avg\");\n\tseq_line(m, '-', 0, 40 + 1 + 12 * (14 + 1));\n\tseq_printf(m, \"\\n\");\n}\n\nstatic void *ls_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct lock_stat_seq *data = m->private;\n\tstruct lock_stat_data *iter;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\titer = data->stats + (*pos - 1);\n\tif (iter >= data->iter_end)\n\t\titer = NULL;\n\n\treturn iter;\n}\n\nstatic void *ls_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn ls_start(m, pos);\n}\n\nstatic void ls_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int ls_show(struct seq_file *m, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_header(m);\n\telse\n\t\tseq_stats(m, v);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations lockstat_ops = {\n\t.start\t= ls_start,\n\t.next\t= ls_next,\n\t.stop\t= ls_stop,\n\t.show\t= ls_show,\n};\n\nstatic int lock_stat_open(struct inode *inode, struct file *file)\n{\n\tint res;\n\tstruct lock_class *class;\n\tstruct lock_stat_seq *data = vmalloc(sizeof(struct lock_stat_seq));\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = seq_open(file, &lockstat_ops);\n\tif (!res) {\n\t\tstruct lock_stat_data *iter = data->stats;\n\t\tstruct seq_file *m = file->private_data;\n\t\tunsigned long idx;\n\n\t\titerate_lock_classes(idx, class) {\n\t\t\tif (!test_bit(idx, lock_classes_in_use))\n\t\t\t\tcontinue;\n\t\t\titer->class = class;\n\t\t\titer->stats = lock_stats(class);\n\t\t\titer++;\n\t\t}\n\n\t\tdata->iter_end = iter;\n\n\t\tsort(data->stats, data->iter_end - data->stats,\n\t\t\t\tsizeof(struct lock_stat_data),\n\t\t\t\tlock_stat_cmp, NULL);\n\n\t\tm->private = data;\n\t} else\n\t\tvfree(data);\n\n\treturn res;\n}\n\nstatic ssize_t lock_stat_write(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct lock_class *class;\n\tunsigned long idx;\n\tchar c;\n\n\tif (count) {\n\t\tif (get_user(c, buf))\n\t\t\treturn -EFAULT;\n\n\t\tif (c != '0')\n\t\t\treturn count;\n\n\t\titerate_lock_classes(idx, class) {\n\t\t\tif (!test_bit(idx, lock_classes_in_use))\n\t\t\t\tcontinue;\n\t\t\tclear_lock_stats(class);\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int lock_stat_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tvfree(seq->private);\n\treturn seq_release(inode, file);\n}\n\nstatic const struct proc_ops lock_stat_proc_ops = {\n\t.proc_open\t= lock_stat_open,\n\t.proc_write\t= lock_stat_write,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= lock_stat_release,\n};\n#endif  \n\nstatic int __init lockdep_proc_init(void)\n{\n\tproc_create_seq(\"lockdep\", S_IRUSR, NULL, &lockdep_ops);\n#ifdef CONFIG_PROVE_LOCKING\n\tproc_create_seq(\"lockdep_chains\", S_IRUSR, NULL, &lockdep_chains_ops);\n#endif\n\tproc_create_single(\"lockdep_stats\", S_IRUSR, NULL, lockdep_stats_show);\n#ifdef CONFIG_LOCK_STAT\n\tproc_create(\"lock_stat\", S_IRUSR | S_IWUSR, NULL, &lock_stat_proc_ops);\n#endif\n\n\treturn 0;\n}\n\n__initcall(lockdep_proc_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}