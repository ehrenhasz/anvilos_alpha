{
  "module_name": "torture.c",
  "hash_id": "964363b97487e64e03cdf728fab24b7fc2894fbc4e9288ce9dca7d4c6edc1c92",
  "original_prompt": "Ingested from linux-6.6.14/kernel/torture.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/spinlock.h>\n#include <linux/smp.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/moduleparam.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <asm/byteorder.h>\n#include <linux/torture.h>\n#include <linux/sched/rt.h>\n#include \"rcu/rcu.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul E. McKenney <paulmck@linux.ibm.com>\");\n\nstatic bool disable_onoff_at_boot;\nmodule_param(disable_onoff_at_boot, bool, 0444);\n\nstatic bool ftrace_dump_at_shutdown;\nmodule_param(ftrace_dump_at_shutdown, bool, 0444);\n\nstatic int verbose_sleep_frequency;\nmodule_param(verbose_sleep_frequency, int, 0444);\n\nstatic int verbose_sleep_duration = 1;\nmodule_param(verbose_sleep_duration, int, 0444);\n\nstatic int random_shuffle;\nmodule_param(random_shuffle, int, 0444);\n\nstatic char *torture_type;\nstatic int verbose;\n\n \n#define FULLSTOP_DONTSTOP 0\t \n#define FULLSTOP_SHUTDOWN 1\t \n#define FULLSTOP_RMMOD    2\t \nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nstatic atomic_t verbose_sleep_counter;\n\n \nvoid verbose_torout_sleep(void)\n{\n\tif (verbose_sleep_frequency > 0 &&\n\t    verbose_sleep_duration > 0 &&\n\t    !(atomic_inc_return(&verbose_sleep_counter) % verbose_sleep_frequency))\n\t\tschedule_timeout_uninterruptible(verbose_sleep_duration);\n}\nEXPORT_SYMBOL_GPL(verbose_torout_sleep);\n\n \nint torture_hrtimeout_ns(ktime_t baset_ns, u32 fuzzt_ns, const enum hrtimer_mode mode,\n\t\t\t struct torture_random_state *trsp)\n{\n\tktime_t hto = baset_ns;\n\n\tif (trsp)\n\t\thto += torture_random(trsp) % fuzzt_ns;\n\tset_current_state(TASK_IDLE);\n\treturn schedule_hrtimeout(&hto, mode);\n}\nEXPORT_SYMBOL_GPL(torture_hrtimeout_ns);\n\n \nint torture_hrtimeout_us(u32 baset_us, u32 fuzzt_ns, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_us * NSEC_PER_USEC;\n\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, HRTIMER_MODE_REL, trsp);\n}\nEXPORT_SYMBOL_GPL(torture_hrtimeout_us);\n\n \nint torture_hrtimeout_ms(u32 baset_ms, u32 fuzzt_us, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_ms * NSEC_PER_MSEC;\n\tu32 fuzzt_ns;\n\n\tif ((u32)~0U / NSEC_PER_USEC < fuzzt_us)\n\t\tfuzzt_ns = (u32)~0U;\n\telse\n\t\tfuzzt_ns = fuzzt_us * NSEC_PER_USEC;\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, HRTIMER_MODE_REL, trsp);\n}\nEXPORT_SYMBOL_GPL(torture_hrtimeout_ms);\n\n \nint torture_hrtimeout_jiffies(u32 baset_j, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = jiffies_to_nsecs(baset_j);\n\n\treturn torture_hrtimeout_ns(baset_ns, jiffies_to_nsecs(1), HRTIMER_MODE_REL, trsp);\n}\nEXPORT_SYMBOL_GPL(torture_hrtimeout_jiffies);\n\n \nint torture_hrtimeout_s(u32 baset_s, u32 fuzzt_ms, struct torture_random_state *trsp)\n{\n\tktime_t baset_ns = baset_s * NSEC_PER_SEC;\n\tu32 fuzzt_ns;\n\n\tif ((u32)~0U / NSEC_PER_MSEC < fuzzt_ms)\n\t\tfuzzt_ns = (u32)~0U;\n\telse\n\t\tfuzzt_ns = fuzzt_ms * NSEC_PER_MSEC;\n\treturn torture_hrtimeout_ns(baset_ns, fuzzt_ns, HRTIMER_MODE_REL, trsp);\n}\nEXPORT_SYMBOL_GPL(torture_hrtimeout_s);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\n \n\nstatic struct task_struct *onoff_task;\nstatic long onoff_holdoff;\nstatic long onoff_interval;\nstatic torture_ofl_func *onoff_f;\nstatic long n_offline_attempts;\nstatic long n_offline_successes;\nstatic unsigned long sum_offline;\nstatic int min_offline = -1;\nstatic int max_offline;\nstatic long n_online_attempts;\nstatic long n_online_successes;\nstatic unsigned long sum_online;\nstatic int min_online = -1;\nstatic int max_online;\n\nstatic int torture_online_cpus = NR_CPUS;\n\n \nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}\nEXPORT_SYMBOL_GPL(torture_num_online_cpus);\n\n \nbool torture_offline(int cpu, long *n_offl_attempts, long *n_offl_successes,\n\t\t     unsigned long *sum_offl, int *min_offl, int *max_offl)\n{\n\tunsigned long delta;\n\tint ret;\n\tchar *s;\n\tunsigned long starttime;\n\n\tif (!cpu_online(cpu) || !cpu_is_hotpluggable(cpu))\n\t\treturn false;\n\tif (num_online_cpus() <= 1)\n\t\treturn false;   \n\n\tif (verbose > 1)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \"torture_onoff task: offlining %d\\n\",\n\t\t\t torture_type, cpu);\n\tstarttime = jiffies;\n\t(*n_offl_attempts)++;\n\tret = remove_cpu(cpu);\n\tif (ret) {\n\t\ts = \"\";\n\t\tif (!rcu_inkernel_boot_has_ended() && ret == -EBUSY) {\n\t\t\t \n\t\t\t(*n_offl_attempts)--;\n\t\t\ts = \" (-EBUSY forgiven during boot)\";\n\t\t}\n\t\tif (verbose)\n\t\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t\t \"torture_onoff task: offline %d failed%s: errno %d\\n\",\n\t\t\t\t torture_type, cpu, s, ret);\n\t} else {\n\t\tif (verbose > 1)\n\t\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t\t \"torture_onoff task: offlined %d\\n\",\n\t\t\t\t torture_type, cpu);\n\t\tif (onoff_f)\n\t\t\tonoff_f();\n\t\t(*n_offl_successes)++;\n\t\tdelta = jiffies - starttime;\n\t\t*sum_offl += delta;\n\t\tif (*min_offl < 0) {\n\t\t\t*min_offl = delta;\n\t\t\t*max_offl = delta;\n\t\t}\n\t\tif (*min_offl > delta)\n\t\t\t*min_offl = delta;\n\t\tif (*max_offl < delta)\n\t\t\t*max_offl = delta;\n\t\tWRITE_ONCE(torture_online_cpus, torture_online_cpus - 1);\n\t\tWARN_ON_ONCE(torture_online_cpus <= 0);\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(torture_offline);\n\n \nbool torture_online(int cpu, long *n_onl_attempts, long *n_onl_successes,\n\t\t    unsigned long *sum_onl, int *min_onl, int *max_onl)\n{\n\tunsigned long delta;\n\tint ret;\n\tchar *s;\n\tunsigned long starttime;\n\n\tif (cpu_online(cpu) || !cpu_is_hotpluggable(cpu))\n\t\treturn false;\n\n\tif (verbose > 1)\n\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t \"torture_onoff task: onlining %d\\n\",\n\t\t\t torture_type, cpu);\n\tstarttime = jiffies;\n\t(*n_onl_attempts)++;\n\tret = add_cpu(cpu);\n\tif (ret) {\n\t\ts = \"\";\n\t\tif (!rcu_inkernel_boot_has_ended() && ret == -EBUSY) {\n\t\t\t \n\t\t\t(*n_onl_attempts)--;\n\t\t\ts = \" (-EBUSY forgiven during boot)\";\n\t\t}\n\t\tif (verbose)\n\t\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t\t \"torture_onoff task: online %d failed%s: errno %d\\n\",\n\t\t\t\t torture_type, cpu, s, ret);\n\t} else {\n\t\tif (verbose > 1)\n\t\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t\t \"torture_onoff task: onlined %d\\n\",\n\t\t\t\t torture_type, cpu);\n\t\t(*n_onl_successes)++;\n\t\tdelta = jiffies - starttime;\n\t\t*sum_onl += delta;\n\t\tif (*min_onl < 0) {\n\t\t\t*min_onl = delta;\n\t\t\t*max_onl = delta;\n\t\t}\n\t\tif (*min_onl > delta)\n\t\t\t*min_onl = delta;\n\t\tif (*max_onl < delta)\n\t\t\t*max_onl = delta;\n\t\tWRITE_ONCE(torture_online_cpus, torture_online_cpus + 1);\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(torture_online);\n\n \nstatic void torture_online_all(char *phase)\n{\n\tint cpu;\n\tint ret;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu_online(cpu))\n\t\t\tcontinue;\n\t\tret = add_cpu(cpu);\n\t\tif (ret && verbose) {\n\t\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t\t \"%s: %s online %d: errno %d\\n\",\n\t\t\t\t __func__, phase, torture_type, cpu, ret);\n\t\t}\n\t}\n}\n\n \nstatic int\ntorture_onoff(void *arg)\n{\n\tint cpu;\n\tint maxcpu = -1;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"torture_onoff task started\");\n\tfor_each_online_cpu(cpu)\n\t\tmaxcpu = cpu;\n\tWARN_ON(maxcpu < 0);\n\ttorture_online_all(\"Initial\");\n\tif (maxcpu == 0) {\n\t\tVERBOSE_TOROUT_STRING(\"Only one CPU, so CPU-hotplug testing is disabled\");\n\t\tgoto stop;\n\t}\n\n\tif (onoff_holdoff > 0) {\n\t\tVERBOSE_TOROUT_STRING(\"torture_onoff begin holdoff\");\n\t\ttorture_hrtimeout_jiffies(onoff_holdoff, &rand);\n\t\tVERBOSE_TOROUT_STRING(\"torture_onoff end holdoff\");\n\t}\n\twhile (!torture_must_stop()) {\n\t\tif (disable_onoff_at_boot && !rcu_inkernel_boot_has_ended()) {\n\t\t\ttorture_hrtimeout_jiffies(HZ / 10, &rand);\n\t\t\tcontinue;\n\t\t}\n\t\tcpu = torture_random(&rand) % (maxcpu + 1);\n\t\tif (!torture_offline(cpu,\n\t\t\t\t     &n_offline_attempts, &n_offline_successes,\n\t\t\t\t     &sum_offline, &min_offline, &max_offline))\n\t\t\ttorture_online(cpu,\n\t\t\t\t       &n_online_attempts, &n_online_successes,\n\t\t\t\t       &sum_online, &min_online, &max_online);\n\t\ttorture_hrtimeout_jiffies(onoff_interval, &rand);\n\t}\n\nstop:\n\ttorture_kthread_stopping(\"torture_onoff\");\n\ttorture_online_all(\"Final\");\n\treturn 0;\n}\n\n#endif  \n\n \nint torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else  \n\treturn 0;\n#endif  \n}\nEXPORT_SYMBOL_GPL(torture_onoff_init);\n\n \nstatic void torture_onoff_cleanup(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tif (onoff_task == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(\"Stopping torture_onoff task\");\n\tkthread_stop(onoff_task);\n\tonoff_task = NULL;\n#endif  \n}\n\n \nvoid torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif  \n}\nEXPORT_SYMBOL_GPL(torture_onoff_stats);\n\n \nbool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else  \n\treturn false;\n#endif  \n}\nEXPORT_SYMBOL_GPL(torture_onoff_failures);\n\n#define TORTURE_RANDOM_MULT\t39916801   \n#define TORTURE_RANDOM_ADD\t479001701  \n#define TORTURE_RANDOM_REFRESH\t10000\n\n \nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock() + raw_smp_processor_id();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}\nEXPORT_SYMBOL_GPL(torture_random);\n\n \nstruct shuffle_task {\n\tstruct list_head st_l;\n\tstruct task_struct *st_t;\n};\n\nstatic long shuffle_interval;\t \nstatic struct task_struct *shuffler_task;\nstatic cpumask_var_t shuffle_tmp_mask;\nstatic int shuffle_idle_cpu;\t \nstatic struct list_head shuffle_task_list = LIST_HEAD_INIT(shuffle_task_list);\nstatic DEFINE_MUTEX(shuffle_task_mutex);\n\n \nvoid torture_shuffle_task_register(struct task_struct *tp)\n{\n\tstruct shuffle_task *stp;\n\n\tif (WARN_ON_ONCE(tp == NULL))\n\t\treturn;\n\tstp = kmalloc(sizeof(*stp), GFP_KERNEL);\n\tif (WARN_ON_ONCE(stp == NULL))\n\t\treturn;\n\tstp->st_t = tp;\n\tmutex_lock(&shuffle_task_mutex);\n\tlist_add(&stp->st_l, &shuffle_task_list);\n\tmutex_unlock(&shuffle_task_mutex);\n}\nEXPORT_SYMBOL_GPL(torture_shuffle_task_register);\n\n \nstatic void torture_shuffle_task_unregister_all(void)\n{\n\tstruct shuffle_task *stp;\n\tstruct shuffle_task *p;\n\n\tmutex_lock(&shuffle_task_mutex);\n\tlist_for_each_entry_safe(stp, p, &shuffle_task_list, st_l) {\n\t\tlist_del(&stp->st_l);\n\t\tkfree(stp);\n\t}\n\tmutex_unlock(&shuffle_task_mutex);\n}\n\n \nstatic void torture_shuffle_tasks(void)\n{\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct shuffle_task *stp;\n\n\tcpumask_setall(shuffle_tmp_mask);\n\tcpus_read_lock();\n\n\t \n\tif (num_online_cpus() == 1) {\n\t\tcpus_read_unlock();\n\t\treturn;\n\t}\n\n\t \n\tshuffle_idle_cpu = cpumask_next(shuffle_idle_cpu, shuffle_tmp_mask);\n\tif (shuffle_idle_cpu >= nr_cpu_ids)\n\t\tshuffle_idle_cpu = -1;\n\telse\n\t\tcpumask_clear_cpu(shuffle_idle_cpu, shuffle_tmp_mask);\n\n\tmutex_lock(&shuffle_task_mutex);\n\tlist_for_each_entry(stp, &shuffle_task_list, st_l) {\n\t\tif (!random_shuffle || torture_random(&rand) & 0x1)\n\t\t\tset_cpus_allowed_ptr(stp->st_t, shuffle_tmp_mask);\n\t}\n\tmutex_unlock(&shuffle_task_mutex);\n\n\tcpus_read_unlock();\n}\n\n \nstatic int torture_shuffle(void *arg)\n{\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"torture_shuffle task started\");\n\tdo {\n\t\ttorture_hrtimeout_jiffies(shuffle_interval, &rand);\n\t\ttorture_shuffle_tasks();\n\t\ttorture_shutdown_absorb(\"torture_shuffle\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"torture_shuffle\");\n\treturn 0;\n}\n\n \nint torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tTOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}\nEXPORT_SYMBOL_GPL(torture_shuffle_init);\n\n \nstatic void torture_shuffle_cleanup(void)\n{\n\ttorture_shuffle_task_unregister_all();\n\tif (shuffler_task) {\n\t\tVERBOSE_TOROUT_STRING(\"Stopping torture_shuffle task\");\n\t\tkthread_stop(shuffler_task);\n\t\tfree_cpumask_var(shuffle_tmp_mask);\n\t}\n\tshuffler_task = NULL;\n}\n\n \nstatic struct task_struct *shutdown_task;\nstatic ktime_t shutdown_time;\t\t \nstatic void (*torture_shutdown_hook)(void);\n\n \nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}\nEXPORT_SYMBOL_GPL(torture_shutdown_absorb);\n\n \nstatic int torture_shutdown(void *arg)\n{\n\tktime_t ktime_snap;\n\n\tVERBOSE_TOROUT_STRING(\"torture_shutdown task started\");\n\tktime_snap = ktime_get();\n\twhile (ktime_before(ktime_snap, shutdown_time) &&\n\t       !torture_must_stop()) {\n\t\tif (verbose)\n\t\t\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t\t\t \"torture_shutdown task: %llu ms remaining\\n\",\n\t\t\t\t torture_type,\n\t\t\t\t ktime_ms_delta(shutdown_time, ktime_snap));\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_hrtimeout(&shutdown_time, HRTIMER_MODE_ABS);\n\t\tktime_snap = ktime_get();\n\t}\n\tif (torture_must_stop()) {\n\t\ttorture_kthread_stopping(\"torture_shutdown\");\n\t\treturn 0;\n\t}\n\n\t \n\n\tVERBOSE_TOROUT_STRING(\"torture_shutdown task shutting down system\");\n\tshutdown_task = NULL;\t \n\tif (torture_shutdown_hook)\n\t\ttorture_shutdown_hook();\n\telse\n\t\tVERBOSE_TOROUT_STRING(\"No torture_shutdown_hook(), skipping.\");\n\tif (ftrace_dump_at_shutdown)\n\t\trcu_ftrace_dump(DUMP_ALL);\n\tkernel_power_off();\t \n\treturn 0;\n}\n\n \nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(torture_shutdown_init);\n\n \nstatic int torture_shutdown_notify(struct notifier_block *unused1,\n\t\t\t\t   unsigned long unused2, void *unused3)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_DONTSTOP) {\n\t\tVERBOSE_TOROUT_STRING(\"Unscheduled system shutdown detected\");\n\t\tWRITE_ONCE(fullstop, FULLSTOP_SHUTDOWN);\n\t} else {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t}\n\tmutex_unlock(&fullstop_mutex);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\n \nstatic void torture_shutdown_cleanup(void)\n{\n\tunregister_reboot_notifier(&torture_shutdown_nb);\n\tif (shutdown_task != NULL) {\n\t\tVERBOSE_TOROUT_STRING(\"Stopping torture_shutdown task\");\n\t\tkthread_stop(shutdown_task);\n\t}\n\tshutdown_task = NULL;\n}\n\n \nstatic struct task_struct *stutter_task;\nstatic ktime_t stutter_till_abs_time;\nstatic int stutter;\nstatic int stutter_gap;\n\n \nbool stutter_wait(const char *title)\n{\n\tbool ret = false;\n\tktime_t till_ns;\n\n\tcond_resched_tasks_rcu_qs();\n\ttill_ns = READ_ONCE(stutter_till_abs_time);\n\tif (till_ns && ktime_before(ktime_get(), till_ns)) {\n\t\ttorture_hrtimeout_ns(till_ns, 0, HRTIMER_MODE_ABS, NULL);\n\t\tret = true;\n\t}\n\ttorture_shutdown_absorb(title);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stutter_wait);\n\n \nstatic int torture_stutter(void *arg)\n{\n\tktime_t till_ns;\n\n\tVERBOSE_TOROUT_STRING(\"torture_stutter task started\");\n\tdo {\n\t\tif (!torture_must_stop() && stutter > 1) {\n\t\t\ttill_ns = ktime_add_ns(ktime_get(),\n\t\t\t\t\t       jiffies_to_nsecs(stutter));\n\t\t\tWRITE_ONCE(stutter_till_abs_time, till_ns);\n\t\t\ttorture_hrtimeout_jiffies(stutter - 1, NULL);\n\t\t}\n\t\tif (!torture_must_stop())\n\t\t\ttorture_hrtimeout_jiffies(stutter_gap, NULL);\n\t\ttorture_shutdown_absorb(\"torture_stutter\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"torture_stutter\");\n\treturn 0;\n}\n\n \nint torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}\nEXPORT_SYMBOL_GPL(torture_stutter_init);\n\n \nstatic void torture_stutter_cleanup(void)\n{\n\tif (!stutter_task)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(\"Stopping torture_stutter task\");\n\tkthread_stop(stutter_task);\n\tstutter_task = NULL;\n}\n\n \nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(torture_init_begin);\n\n \nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}\nEXPORT_SYMBOL_GPL(torture_init_end);\n\n \nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(torture_cleanup_begin);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}\nEXPORT_SYMBOL_GPL(torture_cleanup_end);\n\n \nbool torture_must_stop(void)\n{\n\treturn torture_must_stop_irq() || kthread_should_stop();\n}\nEXPORT_SYMBOL_GPL(torture_must_stop);\n\n \nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}\nEXPORT_SYMBOL_GPL(torture_must_stop_irq);\n\n \nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"%s is stopping\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(HZ / 20);\n\t}\n}\nEXPORT_SYMBOL_GPL(torture_kthread_stopping);\n\n \nint _torture_create_kthread(int (*fn)(void *arg), void *arg, char *s, char *m,\n\t\t\t    char *f, struct task_struct **tp, void (*cbf)(struct task_struct *tp))\n{\n\tint ret = 0;\n\n\tVERBOSE_TOROUT_STRING(m);\n\t*tp = kthread_create(fn, arg, \"%s\", s);\n\tif (IS_ERR(*tp)) {\n\t\tret = PTR_ERR(*tp);\n\t\tTOROUT_ERRSTRING(f);\n\t\t*tp = NULL;\n\t\treturn ret;\n\t}\n\n\tif (cbf)\n\t\tcbf(*tp);\n\n\twake_up_process(*tp);  \n\ttorture_shuffle_task_register(*tp);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(_torture_create_kthread);\n\n \nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}\nEXPORT_SYMBOL_GPL(_torture_stop_kthread);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}