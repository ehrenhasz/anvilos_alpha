{
  "module_name": "sysctl.c",
  "hash_id": "7f7cf2bfa5d789b6fa360af258df570dfd40299bf0bc84bdf38a01238b6b002b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sysctl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/bitmap.h>\n#include <linux/signal.h>\n#include <linux/panic.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/kmemleak.h>\n#include <linux/filter.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/net.h>\n#include <linux/sysrq.h>\n#include <linux/highuid.h>\n#include <linux/writeback.h>\n#include <linux/ratelimit.h>\n#include <linux/hugetlb.h>\n#include <linux/initrd.h>\n#include <linux/key.h>\n#include <linux/times.h>\n#include <linux/limits.h>\n#include <linux/dcache.h>\n#include <linux/syscalls.h>\n#include <linux/vmstat.h>\n#include <linux/nfs_fs.h>\n#include <linux/acpi.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/perf_event.h>\n#include <linux/oom.h>\n#include <linux/kmod.h>\n#include <linux/capability.h>\n#include <linux/binfmts.h>\n#include <linux/sched/sysctl.h>\n#include <linux/mount.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/pid.h>\n\n#include \"../lib/kstrtox.h\"\n\n#include <linux/uaccess.h>\n#include <asm/processor.h>\n\n#ifdef CONFIG_X86\n#include <asm/nmi.h>\n#include <asm/stacktrace.h>\n#include <asm/io.h>\n#endif\n#ifdef CONFIG_SPARC\n#include <asm/setup.h>\n#endif\n#ifdef CONFIG_RT_MUTEXES\n#include <linux/rtmutex.h>\n#endif\n\n \nconst int sysctl_vals[] = { 0, 1, 2, 3, 4, 100, 200, 1000, 3000, INT_MAX, 65535, -1 };\nEXPORT_SYMBOL(sysctl_vals);\n\nconst unsigned long sysctl_long_vals[] = { 0, 1, LONG_MAX };\nEXPORT_SYMBOL_GPL(sysctl_long_vals);\n\n#if defined(CONFIG_SYSCTL)\n\n \n\n#ifdef CONFIG_PERF_EVENTS\nstatic const int six_hundred_forty_kb = 640 * 1024;\n#endif\n\n\nstatic const int ngroups_max = NGROUPS_MAX;\nstatic const int cap_last_cap = CAP_LAST_CAP;\n\n#ifdef CONFIG_PROC_SYSCTL\n\n \nenum sysctl_writes_mode {\n\tSYSCTL_WRITES_LEGACY\t\t= -1,\n\tSYSCTL_WRITES_WARN\t\t= 0,\n\tSYSCTL_WRITES_STRICT\t\t= 1,\n};\n\nstatic enum sysctl_writes_mode sysctl_writes_strict = SYSCTL_WRITES_STRICT;\n#endif  \n\n#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \\\n    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)\nint sysctl_legacy_va_layout;\n#endif\n\n#endif  \n\n \n\n#ifdef CONFIG_PROC_SYSCTL\n\nstatic int _proc_do_string(char *data, int maxlen, int write,\n\t\tchar *buffer, size_t *lenp, loff_t *ppos)\n{\n\tsize_t len;\n\tchar c, *p;\n\n\tif (!data || !maxlen || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tif (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {\n\t\t\t \n\t\t\tlen = strlen(data);\n\t\t\tif (len > maxlen - 1)\n\t\t\t\tlen = maxlen - 1;\n\n\t\t\tif (*ppos > len)\n\t\t\t\treturn 0;\n\t\t\tlen = *ppos;\n\t\t} else {\n\t\t\t \n\t\t\tlen = 0;\n\t\t}\n\n\t\t*ppos += *lenp;\n\t\tp = buffer;\n\t\twhile ((p - buffer) < *lenp && len < maxlen - 1) {\n\t\t\tc = *(p++);\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tdata[len++] = c;\n\t\t}\n\t\tdata[len] = 0;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (*ppos > len) {\n\t\t\t*lenp = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata += *ppos;\n\t\tlen  -= *ppos;\n\n\t\tif (len > *lenp)\n\t\t\tlen = *lenp;\n\t\tif (len)\n\t\t\tmemcpy(buffer, data, len);\n\t\tif (len < *lenp) {\n\t\t\tbuffer[len] = '\\n';\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n\nstatic void warn_sysctl_write(struct ctl_table *table)\n{\n\tpr_warn_once(\"%s wrote to %s when file position was not 0!\\n\"\n\t\t\"This will not be supported in the future. To silence this\\n\"\n\t\t\"warning, set kernel.sysctl_writes_strict = -1\\n\",\n\t\tcurrent->comm, table->procname);\n}\n\n \nstatic bool proc_first_pos_non_zero_ignore(loff_t *ppos,\n\t\t\t\t\t   struct ctl_table *table)\n{\n\tif (!*ppos)\n\t\treturn false;\n\n\tswitch (sysctl_writes_strict) {\n\tcase SYSCTL_WRITES_STRICT:\n\t\treturn true;\n\tcase SYSCTL_WRITES_WARN:\n\t\twarn_sysctl_write(table);\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write)\n\t\tproc_first_pos_non_zero_ignore(ppos, table);\n\n\treturn _proc_do_string(table->data, table->maxlen, write, buffer, lenp,\n\t\t\tppos);\n}\n\nstatic void proc_skip_spaces(char **buf, size_t *size)\n{\n\twhile (*size) {\n\t\tif (!isspace(**buf))\n\t\t\tbreak;\n\t\t(*size)--;\n\t\t(*buf)++;\n\t}\n}\n\nstatic void proc_skip_char(char **buf, size_t *size, const char v)\n{\n\twhile (*size) {\n\t\tif (**buf != v)\n\t\t\tbreak;\n\t\t(*size)--;\n\t\t(*buf)++;\n\t}\n}\n\n \nstatic int strtoul_lenient(const char *cp, char **endp, unsigned int base,\n\t\t\t   unsigned long *res)\n{\n\tunsigned long long result;\n\tunsigned int rv;\n\n\tcp = _parse_integer_fixup_radix(cp, &base);\n\trv = _parse_integer(cp, base, &result);\n\tif ((rv & KSTRTOX_OVERFLOW) || (result != (unsigned long)result))\n\t\treturn -ERANGE;\n\n\tcp += rv;\n\n\tif (endp)\n\t\t*endp = (char *)cp;\n\n\t*res = (unsigned long)result;\n\treturn 0;\n}\n\n#define TMPBUFLEN 22\n \nstatic int proc_get_long(char **buf, size_t *size,\n\t\t\t  unsigned long *val, bool *neg,\n\t\t\t  const char *perm_tr, unsigned perm_tr_len, char *tr)\n{\n\tchar *p, tmp[TMPBUFLEN];\n\tssize_t len = *size;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tif (len > TMPBUFLEN - 1)\n\t\tlen = TMPBUFLEN - 1;\n\n\tmemcpy(tmp, *buf, len);\n\n\ttmp[len] = 0;\n\tp = tmp;\n\tif (*p == '-' && *size > 1) {\n\t\t*neg = true;\n\t\tp++;\n\t} else\n\t\t*neg = false;\n\tif (!isdigit(*p))\n\t\treturn -EINVAL;\n\n\tif (strtoul_lenient(p, &p, 0, val))\n\t\treturn -EINVAL;\n\n\tlen = p - tmp;\n\n\t \n\tif (len == TMPBUFLEN - 1)\n\t\treturn -EINVAL;\n\n\tif (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))\n\t\treturn -EINVAL;\n\n\tif (tr && (len < *size))\n\t\t*tr = *p;\n\n\t*buf += len;\n\t*size -= len;\n\n\treturn 0;\n}\n\n \nstatic void proc_put_long(void **buf, size_t *size, unsigned long val, bool neg)\n{\n\tint len;\n\tchar tmp[TMPBUFLEN], *p = tmp;\n\n\tsprintf(p, \"%s%lu\", neg ? \"-\" : \"\", val);\n\tlen = strlen(tmp);\n\tif (len > *size)\n\t\tlen = *size;\n\tmemcpy(*buf, tmp, len);\n\t*size -= len;\n\t*buf += len;\n}\n#undef TMPBUFLEN\n\nstatic void proc_put_char(void **buf, size_t *size, char c)\n{\n\tif (*size) {\n\t\tchar **buffer = (char **)buf;\n\t\t**buffer = c;\n\n\t\t(*size)--;\n\t\t(*buffer)++;\n\t\t*buf = *buffer;\n\t}\n}\n\nstatic int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t int *valp,\n\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\tif (*negp) {\n\t\t\tif (*lvalp > (unsigned long) INT_MAX + 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tWRITE_ONCE(*valp, -*lvalp);\n\t\t} else {\n\t\t\tif (*lvalp > (unsigned long) INT_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\tWRITE_ONCE(*valp, *lvalp);\n\t\t}\n\t} else {\n\t\tint val = READ_ONCE(*valp);\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = -(unsigned long)val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_douintvec_conv(unsigned long *lvalp,\n\t\t\t\t  unsigned int *valp,\n\t\t\t\t  int write, void *data)\n{\n\tif (write) {\n\t\tif (*lvalp > UINT_MAX)\n\t\t\treturn -EINVAL;\n\t\tWRITE_ONCE(*valp, *lvalp);\n\t} else {\n\t\tunsigned int val = READ_ONCE(*valp);\n\t\t*lvalp = (unsigned long)val;\n\t}\n\treturn 0;\n}\n\nstatic const char proc_wspace_sep[] = { ' ', '\\t', '\\n' };\n\nstatic int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tsize_t left;\n\tchar *p;\n\n\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = (int *) tbl_data;\n\tvleft = table->maxlen / sizeof(*i);\n\tleft = *lenp;\n\n\tif (!conv)\n\t\tconv = do_proc_dointvec_conv;\n\n\tif (write) {\n\t\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\t\tgoto out;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tp = buffer;\n\t}\n\n\tfor (; left && vleft--; i++, first=0) {\n\t\tunsigned long lval;\n\t\tbool neg;\n\n\t\tif (write) {\n\t\t\tproc_skip_spaces(&p, &left);\n\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\t\t\terr = proc_get_long(&p, &left, &lval, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (conv(&neg, &lval, i, 1, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (conv(&neg, &lval, i, 0, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, '\\t');\n\t\t\tproc_put_long(&buffer, &left, lval, neg);\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\tproc_put_char(&buffer, &left, '\\n');\n\tif (write && !err && left)\n\t\tproc_skip_spaces(&p, &left);\n\tif (write && first)\n\t\treturn err ? : -EINVAL;\n\t*lenp -= left;\nout:\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_dointvec(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\treturn __do_proc_dointvec(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, conv, data);\n}\n\nstatic int do_proc_douintvec_w(unsigned int *tbl_data,\n\t\t\t       struct ctl_table *table,\n\t\t\t       void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos,\n\t\t\t       int (*conv)(unsigned long *lvalp,\n\t\t\t\t\t   unsigned int *valp,\n\t\t\t\t\t   int write, void *data),\n\t\t\t       void *data)\n{\n\tunsigned long lval;\n\tint err = 0;\n\tsize_t left;\n\tbool neg;\n\tchar *p = buffer;\n\n\tleft = *lenp;\n\n\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\tgoto bail_early;\n\n\tif (left > PAGE_SIZE - 1)\n\t\tleft = PAGE_SIZE - 1;\n\n\tproc_skip_spaces(&p, &left);\n\tif (!left) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\terr = proc_get_long(&p, &left, &lval, &neg,\n\t\t\t     proc_wspace_sep,\n\t\t\t     sizeof(proc_wspace_sep), NULL);\n\tif (err || neg) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (conv(&lval, tbl_data, 1, data)) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (!err && left)\n\t\tproc_skip_spaces(&p, &left);\n\nout_free:\n\tif (err)\n\t\treturn -EINVAL;\n\n\treturn 0;\n\n\t \nbail_early:\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos,\n\t\t\t       int (*conv)(unsigned long *lvalp,\n\t\t\t\t\t   unsigned int *valp,\n\t\t\t\t\t   int write, void *data),\n\t\t\t       void *data)\n{\n\tunsigned long lval;\n\tint err = 0;\n\tsize_t left;\n\n\tleft = *lenp;\n\n\tif (conv(&lval, tbl_data, 0, data)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tproc_put_long(&buffer, &left, lval, false);\n\tif (!left)\n\t\tgoto out;\n\n\tproc_put_char(&buffer, &left, '\\n');\n\nout:\n\t*lenp -= left;\n\t*ppos += *lenp;\n\n\treturn err;\n}\n\nstatic int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,\n\t\t\t       int write, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos,\n\t\t\t       int (*conv)(unsigned long *lvalp,\n\t\t\t\t\t   unsigned int *valp,\n\t\t\t\t\t   int write, void *data),\n\t\t\t       void *data)\n{\n\tunsigned int *i, vleft;\n\n\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = (unsigned int *) tbl_data;\n\tvleft = table->maxlen / sizeof(*i);\n\n\t \n\tif (vleft != 1) {\n\t\t*lenp = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (!conv)\n\t\tconv = do_proc_douintvec_conv;\n\n\tif (write)\n\t\treturn do_proc_douintvec_w(i, table, buffer, lenp, ppos,\n\t\t\t\t\t   conv, data);\n\treturn do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);\n}\n\nint do_proc_douintvec(struct ctl_table *table, int write,\n\t\t      void *buffer, size_t *lenp, loff_t *ppos,\n\t\t      int (*conv)(unsigned long *lvalp,\n\t\t\t\t  unsigned int *valp,\n\t\t\t\t  int write, void *data),\n\t\t      void *data)\n{\n\treturn __do_proc_douintvec(table->data, table, write,\n\t\t\t\t   buffer, lenp, ppos, conv, data);\n}\n\n \nint proc_dobool(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table tmp;\n\tbool *data = table->data;\n\tint res, val;\n\n\t \n\tif (table->maxlen != sizeof(bool))\n\t\treturn -EINVAL;\n\n\ttmp = *table;\n\ttmp.maxlen = sizeof(val);\n\ttmp.data = &val;\n\n\tval = READ_ONCE(*data);\n\tres = proc_dointvec(&tmp, write, buffer, lenp, ppos);\n\tif (res)\n\t\treturn res;\n\tif (write)\n\t\tWRITE_ONCE(*data, val);\n\treturn 0;\n}\n\n \nint proc_dointvec(struct ctl_table *table, int write, void *buffer,\n\t\t  size_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);\n}\n\n \nint proc_douintvec(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_douintvec(table, write, buffer, lenp, ppos,\n\t\t\t\t do_proc_douintvec_conv, NULL);\n}\n\n \nstatic int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long tmptaint = get_taint();\n\tint err;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &tmptaint;\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (write) {\n\t\tint i;\n\n\t\t \n\t\tif (panic_on_taint_nousertaint && (tmptaint & panic_on_taint))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++)\n\t\t\tif ((1UL << i) & tmptaint)\n\t\t\t\tadd_taint(i, LOCKDEP_STILL_OK);\n\t}\n\n\treturn err;\n}\n\n \nstruct do_proc_dointvec_minmax_conv_param {\n\tint *min;\n\tint *max;\n};\n\nstatic int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\tint *valp,\n\t\t\t\t\tint write, void *data)\n{\n\tint tmp, ret;\n\tstruct do_proc_dointvec_minmax_conv_param *param = data;\n\t \n\tint *ip = write ? &tmp : valp;\n\n\tret = do_proc_dointvec_conv(negp, lvalp, ip, write, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (write) {\n\t\tif ((param->min && *param->min > tmp) ||\n\t\t    (param->max && *param->max < tmp))\n\t\t\treturn -EINVAL;\n\t\tWRITE_ONCE(*valp, tmp);\n\t}\n\n\treturn 0;\n}\n\n \nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_dointvec_minmax_conv_param param = {\n\t\t.min = (int *) table->extra1,\n\t\t.max = (int *) table->extra2,\n\t};\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_minmax_conv, &param);\n}\n\n \nstruct do_proc_douintvec_minmax_conv_param {\n\tunsigned int *min;\n\tunsigned int *max;\n};\n\nstatic int do_proc_douintvec_minmax_conv(unsigned long *lvalp,\n\t\t\t\t\t unsigned int *valp,\n\t\t\t\t\t int write, void *data)\n{\n\tint ret;\n\tunsigned int tmp;\n\tstruct do_proc_douintvec_minmax_conv_param *param = data;\n\t \n\tunsigned int *up = write ? &tmp : valp;\n\n\tret = do_proc_douintvec_conv(lvalp, up, write, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (write) {\n\t\tif ((param->min && *param->min > tmp) ||\n\t\t    (param->max && *param->max < tmp))\n\t\t\treturn -ERANGE;\n\n\t\tWRITE_ONCE(*valp, tmp);\n\t}\n\n\treturn 0;\n}\n\n \nint proc_douintvec_minmax(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_douintvec_minmax_conv_param param = {\n\t\t.min = (unsigned int *) table->extra1,\n\t\t.max = (unsigned int *) table->extra2,\n\t};\n\treturn do_proc_douintvec(table, write, buffer, lenp, ppos,\n\t\t\t\t do_proc_douintvec_minmax_conv, &param);\n}\n\n \nint proc_dou8vec_minmax(struct ctl_table *table, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table tmp;\n\tunsigned int min = 0, max = 255U, val;\n\tu8 *data = table->data;\n\tstruct do_proc_douintvec_minmax_conv_param param = {\n\t\t.min = &min,\n\t\t.max = &max,\n\t};\n\tint res;\n\n\t \n\tif (table->maxlen != sizeof(u8))\n\t\treturn -EINVAL;\n\n\tif (table->extra1) {\n\t\tmin = *(unsigned int *) table->extra1;\n\t\tif (min > 255U)\n\t\t\treturn -EINVAL;\n\t}\n\tif (table->extra2) {\n\t\tmax = *(unsigned int *) table->extra2;\n\t\tif (max > 255U)\n\t\t\treturn -EINVAL;\n\t}\n\n\ttmp = *table;\n\n\ttmp.maxlen = sizeof(val);\n\ttmp.data = &val;\n\tval = READ_ONCE(*data);\n\tres = do_proc_douintvec(&tmp, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_douintvec_minmax_conv, &param);\n\tif (res)\n\t\treturn res;\n\tif (write)\n\t\tWRITE_ONCE(*data, val);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(proc_dou8vec_minmax);\n\n#ifdef CONFIG_MAGIC_SYSRQ\nstatic int sysrq_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint tmp, ret;\n\n\ttmp = sysrq_mask();\n\n\tret = __do_proc_dointvec(&tmp, table, write, buffer,\n\t\t\t       lenp, ppos, NULL, NULL);\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (write)\n\t\tsysrq_toggle_support(tmp);\n\n\treturn 0;\n}\n#endif\n\nstatic int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,\n\t\tint write, void *buffer, size_t *lenp, loff_t *ppos,\n\t\tunsigned long convmul, unsigned long convdiv)\n{\n\tunsigned long *i, *min, *max;\n\tint vleft, first = 1, err = 0;\n\tsize_t left;\n\tchar *p;\n\n\tif (!data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = data;\n\tmin = table->extra1;\n\tmax = table->extra2;\n\tvleft = table->maxlen / sizeof(unsigned long);\n\tleft = *lenp;\n\n\tif (write) {\n\t\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\t\tgoto out;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tp = buffer;\n\t}\n\n\tfor (; left && vleft--; i++, first = 0) {\n\t\tunsigned long val;\n\n\t\tif (write) {\n\t\t\tbool neg;\n\n\t\t\tproc_skip_spaces(&p, &left);\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\n\t\t\terr = proc_get_long(&p, &left, &val, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval = convmul * val / convdiv;\n\t\t\tif ((min && val < *min) || (max && val > *max)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWRITE_ONCE(*i, val);\n\t\t} else {\n\t\t\tval = convdiv * READ_ONCE(*i) / convmul;\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, '\\t');\n\t\t\tproc_put_long(&buffer, &left, val, false);\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\tproc_put_char(&buffer, &left, '\\n');\n\tif (write && !err)\n\t\tproc_skip_spaces(&p, &left);\n\tif (write && first)\n\t\treturn err ? : -EINVAL;\n\t*lenp -= left;\nout:\n\t*ppos += *lenp;\n\treturn err;\n}\n\nstatic int do_proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos, unsigned long convmul,\n\t\tunsigned long convdiv)\n{\n\treturn __do_proc_doulongvec_minmax(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, convmul, convdiv);\n}\n\n \nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);\n}\n\n \nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_doulongvec_minmax(table, write, buffer,\n\t\t\t\t     lenp, ppos, HZ, 1000l);\n}\n\n\nstatic int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t int *valp,\n\t\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\tif (*lvalp > INT_MAX / HZ)\n\t\t\treturn 1;\n\t\tif (*negp)\n\t\t\tWRITE_ONCE(*valp, -*lvalp * HZ);\n\t\telse\n\t\t\tWRITE_ONCE(*valp, *lvalp * HZ);\n\t} else {\n\t\tint val = READ_ONCE(*valp);\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = -(unsigned long)val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = lval / HZ;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t\tint *valp,\n\t\t\t\t\t\tint write, void *data)\n{\n\tif (write) {\n\t\tif (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)\n\t\t\treturn 1;\n\t\t*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);\n\t} else {\n\t\tint val = *valp;\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = -(unsigned long)val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_clock_t(lval);\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t    int *valp,\n\t\t\t\t\t    int write, void *data)\n{\n\tif (write) {\n\t\tunsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);\n\n\t\tif (jif > INT_MAX)\n\t\t\treturn 1;\n\t\tWRITE_ONCE(*valp, (int)jif);\n\t} else {\n\t\tint val = READ_ONCE(*valp);\n\t\tunsigned long lval;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\tlval = -(unsigned long)val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_msecs(lval);\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_ms_jiffies_minmax_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t\tint *valp, int write, void *data)\n{\n\tint tmp, ret;\n\tstruct do_proc_dointvec_minmax_conv_param *param = data;\n\t \n\tint *ip = write ? &tmp : valp;\n\n\tret = do_proc_dointvec_ms_jiffies_conv(negp, lvalp, ip, write, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (write) {\n\t\tif ((param->min && *param->min > tmp) ||\n\t\t\t\t(param->max && *param->max < tmp))\n\t\t\treturn -EINVAL;\n\t\t*valp = tmp;\n\t}\n\treturn 0;\n}\n\n \nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_jiffies_conv,NULL);\n}\n\nint proc_dointvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_dointvec_minmax_conv_param param = {\n\t\t.min = (int *) table->extra1,\n\t\t.max = (int *) table->extra2,\n\t};\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\tdo_proc_dointvec_ms_jiffies_minmax_conv, &param);\n}\n\n \nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_userhz_jiffies_conv, NULL);\n}\n\n \nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_ms_jiffies_conv, NULL);\n}\n\nstatic int proc_do_cad_pid(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\tstruct pid *new_pid;\n\tpid_t tmp;\n\tint r;\n\n\ttmp = pid_vnr(cad_pid);\n\n\tr = __do_proc_dointvec(&tmp, table, write, buffer,\n\t\t\t       lenp, ppos, NULL, NULL);\n\tif (r || !write)\n\t\treturn r;\n\n\tnew_pid = find_get_pid(tmp);\n\tif (!new_pid)\n\t\treturn -ESRCH;\n\n\tput_pid(xchg(&cad_pid, new_pid));\n\treturn 0;\n}\n\n \nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->maxlen;\n\tunsigned long *bitmap = *(unsigned long **) table->data;\n\tunsigned long *tmp_bitmap = NULL;\n\tchar tr_a[] = { '-', ',', '\\n' }, tr_b[] = { ',', '\\n', 0 }, c;\n\n\tif (!bitmap || !bitmap_len || !left || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tchar *p = buffer;\n\t\tsize_t skipped = 0;\n\n\t\tif (left > PAGE_SIZE - 1) {\n\t\t\tleft = PAGE_SIZE - 1;\n\t\t\t \n\t\t\tskipped = *lenp - left;\n\t\t}\n\n\t\ttmp_bitmap = bitmap_zalloc(bitmap_len, GFP_KERNEL);\n\t\tif (!tmp_bitmap)\n\t\t\treturn -ENOMEM;\n\t\tproc_skip_char(&p, &left, '\\n');\n\t\twhile (!err && left) {\n\t\t\tunsigned long val_a, val_b;\n\t\t\tbool neg;\n\t\t\tsize_t saved_left;\n\n\t\t\t \n\t\t\tsaved_left = left;\n\t\t\terr = proc_get_long(&p, &left, &val_a, &neg, tr_a,\n\t\t\t\t\t     sizeof(tr_a), &c);\n\t\t\t \n\t\t\tif ((left <= 1) && skipped) {\n\t\t\t\tleft = saved_left;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (val_a >= bitmap_len || neg) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tval_b = val_a;\n\t\t\tif (left) {\n\t\t\t\tp++;\n\t\t\t\tleft--;\n\t\t\t}\n\n\t\t\tif (c == '-') {\n\t\t\t\terr = proc_get_long(&p, &left, &val_b,\n\t\t\t\t\t\t     &neg, tr_b, sizeof(tr_b),\n\t\t\t\t\t\t     &c);\n\t\t\t\t \n\t\t\t\tif (!left && skipped) {\n\t\t\t\t\tleft = saved_left;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tif (val_b >= bitmap_len || neg ||\n\t\t\t\t    val_a > val_b) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (left) {\n\t\t\t\t\tp++;\n\t\t\t\t\tleft--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);\n\t\t\tproc_skip_char(&p, &left, '\\n');\n\t\t}\n\t\tleft += skipped;\n\t} else {\n\t\tunsigned long bit_a, bit_b = 0;\n\t\tbool first = 1;\n\n\t\twhile (left) {\n\t\t\tbit_a = find_next_bit(bitmap, bitmap_len, bit_b);\n\t\t\tif (bit_a >= bitmap_len)\n\t\t\t\tbreak;\n\t\t\tbit_b = find_next_zero_bit(bitmap, bitmap_len,\n\t\t\t\t\t\t   bit_a + 1) - 1;\n\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, ',');\n\t\t\tproc_put_long(&buffer, &left, bit_a, false);\n\t\t\tif (bit_a != bit_b) {\n\t\t\t\tproc_put_char(&buffer, &left, '-');\n\t\t\t\tproc_put_long(&buffer, &left, bit_b, false);\n\t\t\t}\n\n\t\t\tfirst = 0; bit_b++;\n\t\t}\n\t\tproc_put_char(&buffer, &left, '\\n');\n\t}\n\n\tif (!err) {\n\t\tif (write) {\n\t\t\tif (*ppos)\n\t\t\t\tbitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);\n\t\t\telse\n\t\t\t\tbitmap_copy(bitmap, tmp_bitmap, bitmap_len);\n\t\t}\n\t\t*lenp -= left;\n\t\t*ppos += *lenp;\n\t}\n\n\tbitmap_free(tmp_bitmap);\n\treturn err;\n}\n\n#else  \n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dobool(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_douintvec(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_douintvec_minmax(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dou8vec_minmax(struct ctl_table *table, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,\n\t\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n\n#endif  \n\n#if defined(CONFIG_SYSCTL)\nint proc_do_static_key(struct ctl_table *table, int write,\n\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct static_key *key = (struct static_key *)table->data;\n\tstatic DEFINE_MUTEX(static_key_mutex);\n\tint val, ret;\n\tstruct ctl_table tmp = {\n\t\t.data   = &val,\n\t\t.maxlen = sizeof(val),\n\t\t.mode   = table->mode,\n\t\t.extra1 = SYSCTL_ZERO,\n\t\t.extra2 = SYSCTL_ONE,\n\t};\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&static_key_mutex);\n\tval = static_key_enabled(key);\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\tif (write && !ret) {\n\t\tif (val)\n\t\t\tstatic_key_enable(key);\n\t\telse\n\t\t\tstatic_key_disable(key);\n\t}\n\tmutex_unlock(&static_key_mutex);\n\treturn ret;\n}\n\nstatic struct ctl_table kern_table[] = {\n\t{\n\t\t.procname\t= \"panic\",\n\t\t.data\t\t= &panic_timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_PROC_SYSCTL\n\t{\n\t\t.procname\t= \"tainted\",\n\t\t.maxlen \t= sizeof(long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_taint,\n\t},\n\t{\n\t\t.procname\t= \"sysctl_writes_strict\",\n\t\t.data\t\t= &sysctl_writes_strict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_NEG_ONE,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"print-fatal-signals\",\n\t\t.data\t\t= &print_fatal_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_SPARC\n\t{\n\t\t.procname\t= \"reboot-cmd\",\n\t\t.data\t\t= reboot_command,\n\t\t.maxlen\t\t= 256,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"stop-a\",\n\t\t.data\t\t= &stop_a_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"scons-poweroff\",\n\t\t.data\t\t= &scons_pwroff,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_SPARC64\n\t{\n\t\t.procname\t= \"tsb-ratio\",\n\t\t.data\t\t= &sysctl_tsb_ratio,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_PARISC\n\t{\n\t\t.procname\t= \"soft-power\",\n\t\t.data\t\t= &pwrsw_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_SYSCTL_ARCH_UNALIGN_ALLOW\n\t{\n\t\t.procname\t= \"unaligned-trap\",\n\t\t.data\t\t= &unaligned_enabled,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_STACK_TRACER\n\t{\n\t\t.procname\t= \"stack_tracer_enabled\",\n\t\t.data\t\t= &stack_tracer_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= stack_trace_sysctl,\n\t},\n#endif\n#ifdef CONFIG_TRACING\n\t{\n\t\t.procname\t= \"ftrace_dump_on_oops\",\n\t\t.data\t\t= &ftrace_dump_on_oops,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"traceoff_on_warning\",\n\t\t.data\t\t= &__disable_trace_on_warning,\n\t\t.maxlen\t\t= sizeof(__disable_trace_on_warning),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"tracepoint_printk\",\n\t\t.data\t\t= &tracepoint_printk,\n\t\t.maxlen\t\t= sizeof(tracepoint_printk),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= tracepoint_printk_sysctl,\n\t},\n#endif\n#ifdef CONFIG_MODULES\n\t{\n\t\t.procname\t= \"modprobe\",\n\t\t.data\t\t= &modprobe_path,\n\t\t.maxlen\t\t= KMOD_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"modules_disabled\",\n\t\t.data\t\t= &modules_disabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t \n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n#ifdef CONFIG_UEVENT_HELPER\n\t{\n\t\t.procname\t= \"hotplug\",\n\t\t.data\t\t= &uevent_helper,\n\t\t.maxlen\t\t= UEVENT_HELPER_PATH_LEN,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n#endif\n#ifdef CONFIG_MAGIC_SYSRQ\n\t{\n\t\t.procname\t= \"sysrq\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysrq_sysctl_handler,\n\t},\n#endif\n#ifdef CONFIG_PROC_SYSCTL\n\t{\n\t\t.procname\t= \"cad_pid\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_do_cad_pid,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"threads-max\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_max_threads,\n\t},\n\t{\n\t\t.procname\t= \"overflowuid\",\n\t\t.data\t\t= &overflowuid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_MAXOLDUID,\n\t},\n\t{\n\t\t.procname\t= \"overflowgid\",\n\t\t.data\t\t= &overflowgid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_MAXOLDUID,\n\t},\n#ifdef CONFIG_S390\n\t{\n\t\t.procname\t= \"userprocess_debug\",\n\t\t.data\t\t= &show_unhandled_signals,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"pid_max\",\n\t\t.data\t\t= &pid_max,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &pid_max_min,\n\t\t.extra2\t\t= &pid_max_max,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_oops\",\n\t\t.data\t\t= &panic_on_oops,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"panic_print\",\n\t\t.data\t\t= &panic_print,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ngroups_max\",\n\t\t.data\t\t= (void *)&ngroups_max,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"cap_last_cap\",\n\t\t.data\t\t= (void *)&cap_last_cap,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)\n\t{\n\t\t.procname       = \"unknown_nmi_panic\",\n\t\t.data           = &unknown_nmi_panic,\n\t\t.maxlen         = sizeof (int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n#endif\n\n#if (defined(CONFIG_X86_32) || defined(CONFIG_PARISC)) && \\\n\tdefined(CONFIG_DEBUG_STACKOVERFLOW)\n\t{\n\t\t.procname\t= \"panic_on_stackoverflow\",\n\t\t.data\t\t= &sysctl_panic_on_stackoverflow,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_X86)\n\t{\n\t\t.procname\t= \"panic_on_unrecovered_nmi\",\n\t\t.data\t\t= &panic_on_unrecovered_nmi,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"panic_on_io_nmi\",\n\t\t.data\t\t= &panic_on_io_nmi,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"bootloader_type\",\n\t\t.data\t\t= &bootloader_type,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"bootloader_version\",\n\t\t.data\t\t= &bootloader_version,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"io_delay_type\",\n\t\t.data\t\t= &io_delay_type,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_MMU)\n\t{\n\t\t.procname\t= \"randomize_va_space\",\n\t\t.data\t\t= &randomize_va_space,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if defined(CONFIG_S390) && defined(CONFIG_SMP)\n\t{\n\t\t.procname\t= \"spin_retry\",\n\t\t.data\t\t= &spin_retry,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#if\tdefined(CONFIG_ACPI_SLEEP) && defined(CONFIG_X86)\n\t{\n\t\t.procname\t= \"acpi_video_flags\",\n\t\t.data\t\t= &acpi_realmode_flags,\n\t\t.maxlen\t\t= sizeof (unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#endif\n#ifdef CONFIG_SYSCTL_ARCH_UNALIGN_NO_WARN\n\t{\n\t\t.procname\t= \"ignore-unaligned-usertrap\",\n\t\t.data\t\t= &no_unaligned_warning,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_IA64\n\t{\n\t\t.procname\t= \"unaligned-dump-stack\",\n\t\t.data\t\t= &unaligned_dump_stack,\n\t\t.maxlen\t\t= sizeof (int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_RT_MUTEXES\n\t{\n\t\t.procname\t= \"max_lock_depth\",\n\t\t.data\t\t= &max_lock_depth,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\t \n\t{\n\t\t.procname\t= \"perf_event_paranoid\",\n\t\t.data\t\t= &sysctl_perf_event_paranoid,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_paranoid),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_mlock_kb\",\n\t\t.data\t\t= &sysctl_perf_event_mlock,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_mlock),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_max_sample_rate\",\n\t\t.data\t\t= &sysctl_perf_event_sample_rate,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_sample_rate),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= perf_proc_update_handler,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"perf_cpu_time_max_percent\",\n\t\t.data\t\t= &sysctl_perf_cpu_time_max_percent,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_cpu_time_max_percent),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= perf_cpu_time_max_percent_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE_HUNDRED,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_max_stack\",\n\t\t.data\t\t= &sysctl_perf_event_max_stack,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_max_stack),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= perf_event_max_stack_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&six_hundred_forty_kb,\n\t},\n\t{\n\t\t.procname\t= \"perf_event_max_contexts_per_stack\",\n\t\t.data\t\t= &sysctl_perf_event_max_contexts_per_stack,\n\t\t.maxlen\t\t= sizeof(sysctl_perf_event_max_contexts_per_stack),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= perf_event_max_stack_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE_THOUSAND,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"panic_on_warn\",\n\t\t.data\t\t= &panic_on_warn,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#ifdef CONFIG_TREE_RCU\n\t{\n\t\t.procname\t= \"panic_on_rcu_stall\",\n\t\t.data\t\t= &sysctl_panic_on_rcu_stall,\n\t\t.maxlen\t\t= sizeof(sysctl_panic_on_rcu_stall),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"max_rcu_stall_to_panic\",\n\t\t.data\t\t= &sysctl_max_rcu_stall_to_panic,\n\t\t.maxlen\t\t= sizeof(sysctl_max_rcu_stall_to_panic),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct ctl_table vm_table[] = {\n\t{\n\t\t.procname\t= \"overcommit_memory\",\n\t\t.data\t\t= &sysctl_overcommit_memory,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_memory),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= overcommit_policy_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"overcommit_ratio\",\n\t\t.data\t\t= &sysctl_overcommit_ratio,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_ratio),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= overcommit_ratio_handler,\n\t},\n\t{\n\t\t.procname\t= \"overcommit_kbytes\",\n\t\t.data\t\t= &sysctl_overcommit_kbytes,\n\t\t.maxlen\t\t= sizeof(sysctl_overcommit_kbytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= overcommit_kbytes_handler,\n\t},\n\t{\n\t\t.procname\t= \"page-cluster\",\n\t\t.data\t\t= &page_cluster,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&page_cluster_max,\n\t},\n\t{\n\t\t.procname\t= \"dirtytime_expire_seconds\",\n\t\t.data\t\t= &dirtytime_expire_interval,\n\t\t.maxlen\t\t= sizeof(dirtytime_expire_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= dirtytime_interval_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname\t= \"swappiness\",\n\t\t.data\t\t= &vm_swappiness,\n\t\t.maxlen\t\t= sizeof(vm_swappiness),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO_HUNDRED,\n\t},\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname\t= \"numa_stat\",\n\t\t.data\t\t= &sysctl_vm_numa_stat,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= sysctl_vm_numa_stat_handler,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"drop_caches\",\n\t\t.data\t\t= &sysctl_drop_caches,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0200,\n\t\t.proc_handler\t= drop_caches_sysctl_handler,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_FOUR,\n\t},\n\t{\n\t\t.procname\t= \"page_lock_unfairness\",\n\t\t.data\t\t= &sysctl_page_lock_unfairness,\n\t\t.maxlen\t\t= sizeof(sysctl_page_lock_unfairness),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"max_map_count\",\n\t\t.data\t\t= &sysctl_max_map_count,\n\t\t.maxlen\t\t= sizeof(sysctl_max_map_count),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#else\n\t{\n\t\t.procname\t= \"nr_trim_pages\",\n\t\t.data\t\t= &sysctl_nr_trim_pages,\n\t\t.maxlen\t\t= sizeof(sysctl_nr_trim_pages),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"vfs_cache_pressure\",\n\t\t.data\t\t= &sysctl_vfs_cache_pressure,\n\t\t.maxlen\t\t= sizeof(sysctl_vfs_cache_pressure),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#if defined(HAVE_ARCH_PICK_MMAP_LAYOUT) || \\\n    defined(CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT)\n\t{\n\t\t.procname\t= \"legacy_va_layout\",\n\t\t.data\t\t= &sysctl_legacy_va_layout,\n\t\t.maxlen\t\t= sizeof(sysctl_legacy_va_layout),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#endif\n#ifdef CONFIG_NUMA\n\t{\n\t\t.procname\t= \"zone_reclaim_mode\",\n\t\t.data\t\t= &node_reclaim_mode,\n\t\t.maxlen\t\t= sizeof(node_reclaim_mode),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#endif\n#ifdef CONFIG_SMP\n\t{\n\t\t.procname\t= \"stat_interval\",\n\t\t.data\t\t= &sysctl_stat_interval,\n\t\t.maxlen\t\t= sizeof(sysctl_stat_interval),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"stat_refresh\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= 0,\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= vmstat_refresh,\n\t},\n#endif\n#ifdef CONFIG_MMU\n\t{\n\t\t.procname\t= \"mmap_min_addr\",\n\t\t.data\t\t= &dac_mmap_min_addr,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= mmap_min_addr_handler,\n\t},\n#endif\n#if (defined(CONFIG_X86_32) && !defined(CONFIG_UML))|| \\\n   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL))\n\t{\n\t\t.procname\t= \"vdso_enabled\",\n#ifdef CONFIG_X86_32\n\t\t.data\t\t= &vdso32_enabled,\n\t\t.maxlen\t\t= sizeof(vdso32_enabled),\n#else\n\t\t.data\t\t= &vdso_enabled,\n\t\t.maxlen\t\t= sizeof(vdso_enabled),\n#endif\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"user_reserve_kbytes\",\n\t\t.data\t\t= &sysctl_user_reserve_kbytes,\n\t\t.maxlen\t\t= sizeof(sysctl_user_reserve_kbytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"admin_reserve_kbytes\",\n\t\t.data\t\t= &sysctl_admin_reserve_kbytes,\n\t\t.maxlen\t\t= sizeof(sysctl_admin_reserve_kbytes),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n#ifdef CONFIG_HAVE_ARCH_MMAP_RND_BITS\n\t{\n\t\t.procname\t= \"mmap_rnd_bits\",\n\t\t.data\t\t= &mmap_rnd_bits,\n\t\t.maxlen\t\t= sizeof(mmap_rnd_bits),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= (void *)&mmap_rnd_bits_min,\n\t\t.extra2\t\t= (void *)&mmap_rnd_bits_max,\n\t},\n#endif\n#ifdef CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS\n\t{\n\t\t.procname\t= \"mmap_rnd_compat_bits\",\n\t\t.data\t\t= &mmap_rnd_compat_bits,\n\t\t.maxlen\t\t= sizeof(mmap_rnd_compat_bits),\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= (void *)&mmap_rnd_compat_bits_min,\n\t\t.extra2\t\t= (void *)&mmap_rnd_compat_bits_max,\n\t},\n#endif\n\t{ }\n};\n\nint __init sysctl_init_bases(void)\n{\n\tregister_sysctl_init(\"kernel\", kern_table);\n\tregister_sysctl_init(\"vm\", vm_table);\n\n\treturn 0;\n}\n#endif  \n \nEXPORT_SYMBOL(proc_dobool);\nEXPORT_SYMBOL(proc_dointvec);\nEXPORT_SYMBOL(proc_douintvec);\nEXPORT_SYMBOL(proc_dointvec_jiffies);\nEXPORT_SYMBOL(proc_dointvec_minmax);\nEXPORT_SYMBOL_GPL(proc_douintvec_minmax);\nEXPORT_SYMBOL(proc_dointvec_userhz_jiffies);\nEXPORT_SYMBOL(proc_dointvec_ms_jiffies);\nEXPORT_SYMBOL(proc_dostring);\nEXPORT_SYMBOL(proc_doulongvec_minmax);\nEXPORT_SYMBOL(proc_doulongvec_ms_jiffies_minmax);\nEXPORT_SYMBOL(proc_do_large_bitmap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}