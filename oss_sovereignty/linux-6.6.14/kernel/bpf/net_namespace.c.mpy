{
  "module_name": "net_namespace.c",
  "hash_id": "1890717588cacb88c83c3dcbdbe973856bb4d6c2fea7a7f38b9a0ecafd92bdb0",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/net_namespace.c",
  "human_readable_source": "\n\n#include <linux/bpf.h>\n#include <linux/bpf-netns.h>\n#include <linux/filter.h>\n#include <net/net_namespace.h>\n\n \n\nstruct bpf_netns_link {\n\tstruct bpf_link\tlink;\n\tenum bpf_attach_type type;\n\tenum netns_bpf_attach_type netns_type;\n\n\t \n\tstruct net *net;\n\tstruct list_head node;  \n};\n\n \nDEFINE_MUTEX(netns_bpf_mutex);\n\nstatic void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void netns_bpf_attach_type_need(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_inc(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}\n\nstatic int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}\n\nstatic void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}\n\nstatic void bpf_netns_link_release(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *old_array, *new_array;\n\tstruct net *net;\n\tint cnt, idx;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\t \n\tnet = net_link->net;\n\tif (!net)\n\t\tgoto out_unlock;\n\n\t \n\tnetns_bpf_attach_type_unneed(type);\n\n\t \n\tidx = link_index(net, type, net_link);\n\tlist_del(&net_link->node);\n\n\tcnt = link_count(net, type);\n\tif (!cnt) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tgoto out_unlock;\n\t}\n\n\told_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tnew_array = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!new_array) {\n\t\tWARN_ON(bpf_prog_array_delete_safe_at(old_array, idx));\n\t\tgoto out_unlock;\n\t}\n\tfill_prog_array(net, type, new_array);\n\trcu_assign_pointer(net->bpf.run_array[type], new_array);\n\tbpf_prog_array_free(old_array);\n\nout_unlock:\n\tnet_link->net = NULL;\n\tmutex_unlock(&netns_bpf_mutex);\n}\n\nstatic int bpf_netns_link_detach(struct bpf_link *link)\n{\n\tbpf_netns_link_release(link);\n\treturn 0;\n}\n\nstatic void bpf_netns_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\n\tkfree(net_link);\n}\n\nstatic int bpf_netns_link_update_prog(struct bpf_link *link,\n\t\t\t\t      struct bpf_prog *new_prog,\n\t\t\t\t      struct bpf_prog *old_prog)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *run_array;\n\tstruct net *net;\n\tint idx, ret;\n\n\tif (old_prog && old_prog != link->prog)\n\t\treturn -EPERM;\n\tif (new_prog->type != link->prog->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tnet = net_link->net;\n\tif (!net || !check_net(net)) {\n\t\t \n\t\tret = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tidx = link_index(net, type, net_link);\n\tret = bpf_prog_array_update_at(run_array, idx, new_prog);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\told_prog = xchg(&link->prog, new_prog);\n\tbpf_prog_put(old_prog);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn ret;\n}\n\nstatic int bpf_netns_link_fill_info(const struct bpf_link *link,\n\t\t\t\t    struct bpf_link_info *info)\n{\n\tconst struct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tunsigned int inum = 0;\n\tstruct net *net;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tnet = net_link->net;\n\tif (net && check_net(net))\n\t\tinum = net->ns.inum;\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tinfo->netns.netns_ino = inum;\n\tinfo->netns.attach_type = net_link->type;\n\treturn 0;\n}\n\nstatic void bpf_netns_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t       struct seq_file *seq)\n{\n\tstruct bpf_link_info info = {};\n\n\tbpf_netns_link_fill_info(link, &info);\n\tseq_printf(seq,\n\t\t   \"netns_ino:\\t%u\\n\"\n\t\t   \"attach_type:\\t%u\\n\",\n\t\t   info.netns.netns_ino,\n\t\t   info.netns.attach_type);\n}\n\nstatic const struct bpf_link_ops bpf_netns_link_ops = {\n\t.release = bpf_netns_link_release,\n\t.dealloc = bpf_netns_link_dealloc,\n\t.detach = bpf_netns_link_detach,\n\t.update_prog = bpf_netns_link_update_prog,\n\t.fill_link_info = bpf_netns_link_fill_info,\n\t.show_fdinfo = bpf_netns_link_show_fdinfo,\n};\n\n \nstatic int __netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr,\n\t\t\t\t  struct net *net,\n\t\t\t\t  enum netns_bpf_attach_type type)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tstruct bpf_prog_array *run_array;\n\tu32 prog_cnt = 0, flags = 0;\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array)\n\t\tprog_cnt = bpf_prog_array_length(run_array);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &prog_cnt, sizeof(prog_cnt)))\n\t\treturn -EFAULT;\n\tif (!attr->query.prog_cnt || !prog_ids || !prog_cnt)\n\t\treturn 0;\n\n\treturn bpf_prog_array_copy_to_user(run_array, prog_ids,\n\t\t\t\t\t   attr->query.prog_cnt);\n}\n\nint netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t union bpf_attr __user *uattr)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->query.query_flags)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->query.attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->query.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_query(attr, uattr, net, type);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tput_net(net);\n\treturn ret;\n}\n\nint netns_bpf_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *run_array;\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *attached;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->target_fd || attr->attach_flags || attr->replace_bpf_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = current->nsproxy->net_ns;\n\tmutex_lock(&netns_bpf_mutex);\n\n\t \n\tif (!list_empty(&net->bpf.links[type])) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\tret = flow_dissector_bpf_prog_attach_check(net, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tattached = net->bpf.progs[type];\n\tif (attached == prog) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array) {\n\t\tWRITE_ONCE(run_array->items[0].prog, prog);\n\t} else {\n\t\trun_array = bpf_prog_array_alloc(1, GFP_KERNEL);\n\t\tif (!run_array) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\trun_array->items[0].prog = prog;\n\t\trcu_assign_pointer(net->bpf.run_array[type], run_array);\n\t}\n\n\tnet->bpf.progs[type] = prog;\n\tif (attached)\n\t\tbpf_prog_put(attached);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\n\treturn ret;\n}\n\n \nstatic int __netns_bpf_prog_detach(struct net *net,\n\t\t\t\t   enum netns_bpf_attach_type type,\n\t\t\t\t   struct bpf_prog *old)\n{\n\tstruct bpf_prog *attached;\n\n\t \n\tif (!list_empty(&net->bpf.links[type]))\n\t\treturn -EINVAL;\n\n\tattached = net->bpf.progs[type];\n\tif (!attached || attached != old)\n\t\treturn -ENOENT;\n\tnetns_bpf_run_array_detach(net, type);\n\tnet->bpf.progs[type] = NULL;\n\tbpf_prog_put(attached);\n\treturn 0;\n}\n\nint netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (attr->target_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tbpf_prog_put(prog);\n\n\treturn ret;\n}\n\nstatic int netns_bpf_max_progs(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\treturn 1;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\treturn 64;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int netns_bpf_link_attach(struct net *net, struct bpf_link *link,\n\t\t\t\t enum netns_bpf_attach_type type)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tstruct bpf_prog_array *run_array;\n\tint cnt, err;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tcnt = link_count(net, type);\n\tif (cnt >= netns_bpf_max_progs(type)) {\n\t\terr = -E2BIG;\n\t\tgoto out_unlock;\n\t}\n\t \n\tif (net->bpf.progs[type]) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\terr = flow_dissector_bpf_prog_attach_check(net, link->prog);\n\t\tbreak;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\terr = 0;  \n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out_unlock;\n\n\trun_array = bpf_prog_array_alloc(cnt + 1, GFP_KERNEL);\n\tif (!run_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&net_link->node, &net->bpf.links[type]);\n\n\tfill_prog_array(net, type, run_array);\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], run_array,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n\n\t \n\tnetns_bpf_attach_type_need(type);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn err;\n}\n\nint netns_bpf_link_create(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tenum netns_bpf_attach_type netns_type;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_netns_link *net_link;\n\tenum bpf_attach_type type;\n\tstruct net *net;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\ttype = attr->link_create.attach_type;\n\tnetns_type = to_netns_bpf_attach_type(type);\n\tif (netns_type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->link_create.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tnet_link = kzalloc(sizeof(*net_link), GFP_USER);\n\tif (!net_link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_net;\n\t}\n\tbpf_link_init(&net_link->link, BPF_LINK_TYPE_NETNS,\n\t\t      &bpf_netns_link_ops, prog);\n\tnet_link->net = net;\n\tnet_link->type = type;\n\tnet_link->netns_type = netns_type;\n\n\terr = bpf_link_prime(&net_link->link, &link_primer);\n\tif (err) {\n\t\tkfree(net_link);\n\t\tgoto out_put_net;\n\t}\n\n\terr = netns_bpf_link_attach(net, &net_link->link, netns_type);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_net;\n\t}\n\n\tput_net(net);\n\treturn bpf_link_settle(&link_primer);\n\nout_put_net:\n\tput_net(net);\n\treturn err;\n}\n\nstatic int __net_init netns_bpf_pernet_init(struct net *net)\n{\n\tint type;\n\n\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++)\n\t\tINIT_LIST_HEAD(&net->bpf.links[type]);\n\n\treturn 0;\n}\n\nstatic void __net_exit netns_bpf_pernet_pre_exit(struct net *net)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_netns_link *net_link;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tlist_for_each_entry(net_link, &net->bpf.links[type], node) {\n\t\t\tnet_link->net = NULL;  \n\t\t\tnetns_bpf_attach_type_unneed(type);\n\t\t}\n\t\tif (net->bpf.progs[type])\n\t\t\tbpf_prog_put(net->bpf.progs[type]);\n\t}\n\tmutex_unlock(&netns_bpf_mutex);\n}\n\nstatic struct pernet_operations netns_bpf_pernet_ops __net_initdata = {\n\t.init = netns_bpf_pernet_init,\n\t.pre_exit = netns_bpf_pernet_pre_exit,\n};\n\nstatic int __init netns_bpf_init(void)\n{\n\treturn register_pernet_subsys(&netns_bpf_pernet_ops);\n}\n\nsubsys_initcall(netns_bpf_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}