{
  "module_name": "percpu_freelist.c",
  "hash_id": "6d92af02771d02e203d6cd840710d5e2621795cbed9aaad2de632a333ff5b86f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/percpu_freelist.c",
  "human_readable_source": "\n \n#include \"percpu_freelist.h\"\n\nint pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\traw_spin_lock_init(&s->extralist.lock);\n\ts->extralist.first = NULL;\n\treturn 0;\n}\n\nvoid pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}\n\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head,\n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\tWRITE_ONCE(head->first, node);\n}\n\nstatic inline void ___pcpu_freelist_push(struct pcpu_freelist_head *head,\n\t\t\t\t\t struct pcpu_freelist_node *node)\n{\n\traw_spin_lock(&head->lock);\n\tpcpu_freelist_push_node(head, node);\n\traw_spin_unlock(&head->lock);\n}\n\nstatic inline bool pcpu_freelist_try_push_extra(struct pcpu_freelist *s,\n\t\t\t\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (!raw_spin_trylock(&s->extralist.lock))\n\t\treturn false;\n\n\tpcpu_freelist_push_node(&s->extralist, node);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn true;\n}\n\nstatic inline void ___pcpu_freelist_push_nmi(struct pcpu_freelist *s,\n\t\t\t\t\t     struct pcpu_freelist_node *node)\n{\n\tint cpu, orig_cpu;\n\n\torig_cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\tfor_each_cpu_wrap(cpu, cpu_possible_mask, orig_cpu) {\n\t\t\tstruct pcpu_freelist_head *head;\n\n\t\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\t\tpcpu_freelist_push_node(head, node);\n\t\t\t\traw_spin_unlock(&head->lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pcpu_freelist_try_push_extra(s, node))\n\t\t\treturn;\n\t}\n}\n\nvoid __pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tif (in_nmi())\n\t\t___pcpu_freelist_push_nmi(s, node);\n\telse\n\t\t___pcpu_freelist_push(this_cpu_ptr(s->freelist), node);\n}\n\nvoid pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__pcpu_freelist_push(s, node);\n\tlocal_irq_restore(flags);\n}\n\nvoid pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tunsigned int cpu, cpu_idx, i, j, n, m;\n\n\tn = nr_elems / num_possible_cpus();\n\tm = nr_elems % num_possible_cpus();\n\n\tcpu_idx = 0;\n\tfor_each_possible_cpu(cpu) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tj = n + (cpu_idx < m ? 1 : 0);\n\t\tfor (i = 0; i < j; i++) {\n\t\t\t \n\t\t\tpcpu_freelist_push_node(head, buf);\n\t\t\tbuf += elem_size;\n\t\t}\n\t\tcpu_idx++;\n\t}\n}\n\nstatic struct pcpu_freelist_node *___pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint cpu;\n\n\tfor_each_cpu_wrap(cpu, cpu_possible_mask, raw_smp_processor_id()) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (!READ_ONCE(head->first))\n\t\t\tcontinue;\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\tWRITE_ONCE(head->first, node->next);\n\t\t\traw_spin_unlock(&head->lock);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t}\n\n\t \n\tif (!READ_ONCE(s->extralist.first))\n\t\treturn NULL;\n\traw_spin_lock(&s->extralist.lock);\n\tnode = s->extralist.first;\n\tif (node)\n\t\tWRITE_ONCE(s->extralist.first, node->next);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}\n\nstatic struct pcpu_freelist_node *\n___pcpu_freelist_pop_nmi(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tint cpu;\n\n\tfor_each_cpu_wrap(cpu, cpu_possible_mask, raw_smp_processor_id()) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\tif (!READ_ONCE(head->first))\n\t\t\tcontinue;\n\t\tif (raw_spin_trylock(&head->lock)) {\n\t\t\tnode = head->first;\n\t\t\tif (node) {\n\t\t\t\tWRITE_ONCE(head->first, node->next);\n\t\t\t\traw_spin_unlock(&head->lock);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\traw_spin_unlock(&head->lock);\n\t\t}\n\t}\n\n\t \n\tif (!READ_ONCE(s->extralist.first) || !raw_spin_trylock(&s->extralist.lock))\n\t\treturn NULL;\n\tnode = s->extralist.first;\n\tif (node)\n\t\tWRITE_ONCE(s->extralist.first, node->next);\n\traw_spin_unlock(&s->extralist.lock);\n\treturn node;\n}\n\nstruct pcpu_freelist_node *__pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tif (in_nmi())\n\t\treturn ___pcpu_freelist_pop_nmi(s);\n\treturn ___pcpu_freelist_pop(s);\n}\n\nstruct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_node *ret;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tret = __pcpu_freelist_pop(s);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}