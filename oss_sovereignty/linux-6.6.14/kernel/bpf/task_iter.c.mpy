{
  "module_name": "task_iter.c",
  "hash_id": "d8eed2a53cf3157975b5528414a75aa8a099629f5fcfc4c4845a7e17cfed8013",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/task_iter.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/namei.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/filter.h>\n#include <linux/btf_ids.h>\n#include \"mmap_unlock_work.h\"\n\nstatic const char * const iter_task_type_names[] = {\n\t\"ALL\",\n\t\"TID\",\n\t\"PID\",\n};\n\nstruct bpf_iter_seq_task_common {\n\tstruct pid_namespace *ns;\n\tenum bpf_iter_task_type\ttype;\n\tu32 pid;\n\tu32 pid_visiting;\n};\n\nstruct bpf_iter_seq_task_info {\n\t \n\tstruct bpf_iter_seq_task_common common;\n\tu32 tid;\n};\n\nstatic struct task_struct *task_group_seq_get_next(struct bpf_iter_seq_task_common *common,\n\t\t\t\t\t\t   u32 *tid,\n\t\t\t\t\t\t   bool skip_if_dup_files)\n{\n\tstruct task_struct *task, *next_task;\n\tstruct pid *pid;\n\tu32 saved_tid;\n\n\tif (!*tid) {\n\t\t \n\t\tpid = find_pid_ns(common->pid, common->ns);\n\t\tif (!pid)\n\t\t\treturn NULL;\n\n\t\ttask = get_pid_task(pid, PIDTYPE_TGID);\n\t\tif (!task)\n\t\t\treturn NULL;\n\n\t\t*tid = common->pid;\n\t\tcommon->pid_visiting = common->pid;\n\n\t\treturn task;\n\t}\n\n\t \n\tif (*tid == common->pid_visiting) {\n\t\tpid = find_pid_ns(common->pid_visiting, common->ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\n\t\treturn task;\n\t}\n\n\tpid = find_pid_ns(common->pid_visiting, common->ns);\n\tif (!pid)\n\t\treturn NULL;\n\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn NULL;\n\nretry:\n\tif (!pid_alive(task)) {\n\t\tput_task_struct(task);\n\t\treturn NULL;\n\t}\n\n\tnext_task = next_thread(task);\n\tput_task_struct(task);\n\tif (!next_task)\n\t\treturn NULL;\n\n\tsaved_tid = *tid;\n\t*tid = __task_pid_nr_ns(next_task, PIDTYPE_PID, common->ns);\n\tif (!*tid || *tid == common->pid) {\n\t\t \n\t\t*tid = saved_tid;\n\t\treturn NULL;\n\t}\n\n\tget_task_struct(next_task);\n\tcommon->pid_visiting = *tid;\n\n\tif (skip_if_dup_files && task->files == task->group_leader->files) {\n\t\ttask = next_task;\n\t\tgoto retry;\n\t}\n\n\treturn next_task;\n}\n\nstatic struct task_struct *task_seq_get_next(struct bpf_iter_seq_task_common *common,\n\t\t\t\t\t     u32 *tid,\n\t\t\t\t\t     bool skip_if_dup_files)\n{\n\tstruct task_struct *task = NULL;\n\tstruct pid *pid;\n\n\tif (common->type == BPF_TASK_ITER_TID) {\n\t\tif (*tid && *tid != common->pid)\n\t\t\treturn NULL;\n\t\trcu_read_lock();\n\t\tpid = find_pid_ns(common->pid, common->ns);\n\t\tif (pid) {\n\t\t\ttask = get_pid_task(pid, PIDTYPE_TGID);\n\t\t\t*tid = common->pid;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\treturn task;\n\t}\n\n\tif (common->type == BPF_TASK_ITER_TGID) {\n\t\trcu_read_lock();\n\t\ttask = task_group_seq_get_next(common, tid, skip_if_dup_files);\n\t\trcu_read_unlock();\n\n\t\treturn task;\n\t}\n\n\trcu_read_lock();\nretry:\n\tpid = find_ge_pid(*tid, common->ns);\n\tif (pid) {\n\t\t*tid = pid_nr_ns(pid, common->ns);\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\t\tif (!task) {\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t} else if (skip_if_dup_files && !thread_group_leader(task) &&\n\t\t\t   task->files == task->group_leader->files) {\n\t\t\tput_task_struct(task);\n\t\t\ttask = NULL;\n\t\t\t++*tid;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn task;\n}\n\nstatic void *task_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_info *info = seq->private;\n\tstruct task_struct *task;\n\n\ttask = task_seq_get_next(&info->common, &info->tid, false);\n\tif (!task)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\t++*pos;\n\treturn task;\n}\n\nstatic void *task_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_info *info = seq->private;\n\tstruct task_struct *task;\n\n\t++*pos;\n\t++info->tid;\n\tput_task_struct((struct task_struct *)v);\n\ttask = task_seq_get_next(&info->common, &info->tid, false);\n\tif (!task)\n\t\treturn NULL;\n\n\treturn task;\n}\n\nstruct bpf_iter__task {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct task_struct *, task);\n};\n\nDEFINE_BPF_ITER_FUNC(task, struct bpf_iter_meta *meta, struct task_struct *task)\n\nstatic int __task_seq_show(struct seq_file *seq, struct task_struct *task,\n\t\t\t   bool in_stop)\n{\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_iter__task ctx;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = task;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}\n\nstatic int task_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_seq_show(seq, v, false);\n}\n\nstatic void task_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!v)\n\t\t(void)__task_seq_show(seq, v, true);\n\telse\n\t\tput_task_struct((struct task_struct *)v);\n}\n\nstatic int bpf_iter_attach_task(struct bpf_prog *prog,\n\t\t\t\tunion bpf_iter_link_info *linfo,\n\t\t\t\tstruct bpf_iter_aux_info *aux)\n{\n\tunsigned int flags;\n\tstruct pid *pid;\n\tpid_t tgid;\n\n\tif ((!!linfo->task.tid + !!linfo->task.pid + !!linfo->task.pid_fd) > 1)\n\t\treturn -EINVAL;\n\n\taux->task.type = BPF_TASK_ITER_ALL;\n\tif (linfo->task.tid != 0) {\n\t\taux->task.type = BPF_TASK_ITER_TID;\n\t\taux->task.pid = linfo->task.tid;\n\t}\n\tif (linfo->task.pid != 0) {\n\t\taux->task.type = BPF_TASK_ITER_TGID;\n\t\taux->task.pid = linfo->task.pid;\n\t}\n\tif (linfo->task.pid_fd != 0) {\n\t\taux->task.type = BPF_TASK_ITER_TGID;\n\n\t\tpid = pidfd_get_pid(linfo->task.pid_fd, &flags);\n\t\tif (IS_ERR(pid))\n\t\t\treturn PTR_ERR(pid);\n\n\t\ttgid = pid_nr_ns(pid, task_active_pid_ns(current));\n\t\taux->task.pid = tgid;\n\t\tput_pid(pid);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations task_seq_ops = {\n\t.start\t= task_seq_start,\n\t.next\t= task_seq_next,\n\t.stop\t= task_seq_stop,\n\t.show\t= task_seq_show,\n};\n\nstruct bpf_iter_seq_task_file_info {\n\t \n\tstruct bpf_iter_seq_task_common common;\n\tstruct task_struct *task;\n\tu32 tid;\n\tu32 fd;\n};\n\nstatic struct file *\ntask_file_seq_get_next(struct bpf_iter_seq_task_file_info *info)\n{\n\tu32 saved_tid = info->tid;\n\tstruct task_struct *curr_task;\n\tunsigned int curr_fd = info->fd;\n\n\t \nagain:\n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_fd = info->fd;\n\t} else {\n\t\tcurr_task = task_seq_get_next(&info->common, &info->tid, true);\n                if (!curr_task) {\n                        info->task = NULL;\n                        return NULL;\n                }\n\n\t\t \n\t\tinfo->task = curr_task;\n\t\tif (saved_tid == info->tid)\n\t\t\tcurr_fd = info->fd;\n\t\telse\n\t\t\tcurr_fd = 0;\n\t}\n\n\trcu_read_lock();\n\tfor (;; curr_fd++) {\n\t\tstruct file *f;\n\t\tf = task_lookup_next_fd_rcu(curr_task, &curr_fd);\n\t\tif (!f)\n\t\t\tbreak;\n\t\tif (!get_file_rcu(f))\n\t\t\tcontinue;\n\n\t\t \n\t\tinfo->fd = curr_fd;\n\t\trcu_read_unlock();\n\t\treturn f;\n\t}\n\n\t \n\trcu_read_unlock();\n\tput_task_struct(curr_task);\n\n\tif (info->common.type == BPF_TASK_ITER_TID) {\n\t\tinfo->task = NULL;\n\t\treturn NULL;\n\t}\n\n\tinfo->task = NULL;\n\tinfo->fd = 0;\n\tsaved_tid = ++(info->tid);\n\tgoto again;\n}\n\nstatic void *task_file_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct file *file;\n\n\tinfo->task = NULL;\n\tfile = task_file_seq_get_next(info);\n\tif (file && *pos == 0)\n\t\t++*pos;\n\n\treturn file;\n}\n\nstatic void *task_file_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\n\t++*pos;\n\t++info->fd;\n\tfput((struct file *)v);\n\treturn task_file_seq_get_next(info);\n}\n\nstruct bpf_iter__task_file {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct task_struct *, task);\n\tu32 fd __aligned(8);\n\t__bpf_md_ptr(struct file *, file);\n};\n\nDEFINE_BPF_ITER_FUNC(task_file, struct bpf_iter_meta *meta,\n\t\t     struct task_struct *task, u32 fd,\n\t\t     struct file *file)\n\nstatic int __task_file_seq_show(struct seq_file *seq, struct file *file,\n\t\t\t\tbool in_stop)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\tstruct bpf_iter__task_file ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.fd = info->fd;\n\tctx.file = file;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}\n\nstatic int task_file_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_file_seq_show(seq, v, false);\n}\n\nstatic void task_file_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_task_file_info *info = seq->private;\n\n\tif (!v) {\n\t\t(void)__task_file_seq_show(seq, v, true);\n\t} else {\n\t\tfput((struct file *)v);\n\t\tput_task_struct(info->task);\n\t\tinfo->task = NULL;\n\t}\n}\n\nstatic int init_seq_pidns(void *priv_data, struct bpf_iter_aux_info *aux)\n{\n\tstruct bpf_iter_seq_task_common *common = priv_data;\n\n\tcommon->ns = get_pid_ns(task_active_pid_ns(current));\n\tcommon->type = aux->task.type;\n\tcommon->pid = aux->task.pid;\n\n\treturn 0;\n}\n\nstatic void fini_seq_pidns(void *priv_data)\n{\n\tstruct bpf_iter_seq_task_common *common = priv_data;\n\n\tput_pid_ns(common->ns);\n}\n\nstatic const struct seq_operations task_file_seq_ops = {\n\t.start\t= task_file_seq_start,\n\t.next\t= task_file_seq_next,\n\t.stop\t= task_file_seq_stop,\n\t.show\t= task_file_seq_show,\n};\n\nstruct bpf_iter_seq_task_vma_info {\n\t \n\tstruct bpf_iter_seq_task_common common;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tu32 tid;\n\tunsigned long prev_vm_start;\n\tunsigned long prev_vm_end;\n};\n\nenum bpf_task_vma_iter_find_op {\n\ttask_vma_iter_first_vma,    \n\ttask_vma_iter_next_vma,     \n\ttask_vma_iter_find_vma,     \n};\n\nstatic struct vm_area_struct *\ntask_vma_seq_get_next(struct bpf_iter_seq_task_vma_info *info)\n{\n\tenum bpf_task_vma_iter_find_op op;\n\tstruct vm_area_struct *curr_vma;\n\tstruct task_struct *curr_task;\n\tstruct mm_struct *curr_mm;\n\tu32 saved_tid = info->tid;\n\n\t \n\tif (info->task) {\n\t\tcurr_task = info->task;\n\t\tcurr_vma = info->vma;\n\t\tcurr_mm = info->mm;\n\t\t \n\t\tif (mmap_lock_is_contended(curr_mm)) {\n\t\t\tinfo->prev_vm_start = curr_vma->vm_start;\n\t\t\tinfo->prev_vm_end = curr_vma->vm_end;\n\t\t\top = task_vma_iter_find_vma;\n\t\t\tmmap_read_unlock(curr_mm);\n\t\t\tif (mmap_read_lock_killable(curr_mm)) {\n\t\t\t\tmmput(curr_mm);\n\t\t\t\tgoto finish;\n\t\t\t}\n\t\t} else {\n\t\t\top = task_vma_iter_next_vma;\n\t\t}\n\t} else {\nagain:\n\t\tcurr_task = task_seq_get_next(&info->common, &info->tid, true);\n\t\tif (!curr_task) {\n\t\t\tinfo->tid++;\n\t\t\tgoto finish;\n\t\t}\n\n\t\tif (saved_tid != info->tid) {\n\t\t\t \n\t\t\top = task_vma_iter_first_vma;\n\t\t} else {\n\t\t\t \n\t\t\top = task_vma_iter_find_vma;\n\t\t}\n\n\t\tcurr_mm = get_task_mm(curr_task);\n\t\tif (!curr_mm)\n\t\t\tgoto next_task;\n\n\t\tif (mmap_read_lock_killable(curr_mm)) {\n\t\t\tmmput(curr_mm);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tswitch (op) {\n\tcase task_vma_iter_first_vma:\n\t\tcurr_vma = find_vma(curr_mm, 0);\n\t\tbreak;\n\tcase task_vma_iter_next_vma:\n\t\tcurr_vma = find_vma(curr_mm, curr_vma->vm_end);\n\t\tbreak;\n\tcase task_vma_iter_find_vma:\n\t\t \n\t\tcurr_vma = find_vma(curr_mm, info->prev_vm_end - 1);\n\t\t \n\n\t\t \n\t\tif (curr_vma &&\n\t\t    curr_vma->vm_start == info->prev_vm_start &&\n\t\t    curr_vma->vm_end == info->prev_vm_end)\n\t\t\tcurr_vma = find_vma(curr_mm, curr_vma->vm_end);\n\t\tbreak;\n\t}\n\tif (!curr_vma) {\n\t\t \n\t\tmmap_read_unlock(curr_mm);\n\t\tmmput(curr_mm);\n\t\tgoto next_task;\n\t}\n\tinfo->task = curr_task;\n\tinfo->vma = curr_vma;\n\tinfo->mm = curr_mm;\n\treturn curr_vma;\n\nnext_task:\n\tif (info->common.type == BPF_TASK_ITER_TID)\n\t\tgoto finish;\n\n\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->mm = NULL;\n\tinfo->tid++;\n\tgoto again;\n\nfinish:\n\tif (curr_task)\n\t\tput_task_struct(curr_task);\n\tinfo->task = NULL;\n\tinfo->vma = NULL;\n\tinfo->mm = NULL;\n\treturn NULL;\n}\n\nstatic void *task_vma_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct vm_area_struct *vma;\n\n\tvma = task_vma_seq_get_next(info);\n\tif (vma && *pos == 0)\n\t\t++*pos;\n\n\treturn vma;\n}\n\nstatic void *task_vma_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\n\t++*pos;\n\treturn task_vma_seq_get_next(info);\n}\n\nstruct bpf_iter__task_vma {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct task_struct *, task);\n\t__bpf_md_ptr(struct vm_area_struct *, vma);\n};\n\nDEFINE_BPF_ITER_FUNC(task_vma, struct bpf_iter_meta *meta,\n\t\t     struct task_struct *task, struct vm_area_struct *vma)\n\nstatic int __task_vma_seq_show(struct seq_file *seq, bool in_stop)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\tstruct bpf_iter__task_vma ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.task = info->task;\n\tctx.vma = info->vma;\n\treturn bpf_iter_run_prog(prog, &ctx);\n}\n\nstatic int task_vma_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __task_vma_seq_show(seq, false);\n}\n\nstatic void task_vma_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_task_vma_info *info = seq->private;\n\n\tif (!v) {\n\t\t(void)__task_vma_seq_show(seq, true);\n\t} else {\n\t\t \n\t\tinfo->prev_vm_start = ~0UL;\n\t\tinfo->prev_vm_end = info->vma->vm_end;\n\t\tmmap_read_unlock(info->mm);\n\t\tmmput(info->mm);\n\t\tinfo->mm = NULL;\n\t\tput_task_struct(info->task);\n\t\tinfo->task = NULL;\n\t}\n}\n\nstatic const struct seq_operations task_vma_seq_ops = {\n\t.start\t= task_vma_seq_start,\n\t.next\t= task_vma_seq_next,\n\t.stop\t= task_vma_seq_stop,\n\t.show\t= task_vma_seq_show,\n};\n\nstatic const struct bpf_iter_seq_info task_seq_info = {\n\t.seq_ops\t\t= &task_seq_ops,\n\t.init_seq_private\t= init_seq_pidns,\n\t.fini_seq_private\t= fini_seq_pidns,\n\t.seq_priv_size\t\t= sizeof(struct bpf_iter_seq_task_info),\n};\n\nstatic int bpf_iter_fill_link_info(const struct bpf_iter_aux_info *aux, struct bpf_link_info *info)\n{\n\tswitch (aux->task.type) {\n\tcase BPF_TASK_ITER_TID:\n\t\tinfo->iter.task.tid = aux->task.pid;\n\t\tbreak;\n\tcase BPF_TASK_ITER_TGID:\n\t\tinfo->iter.task.pid = aux->task.pid;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void bpf_iter_task_show_fdinfo(const struct bpf_iter_aux_info *aux, struct seq_file *seq)\n{\n\tseq_printf(seq, \"task_type:\\t%s\\n\", iter_task_type_names[aux->task.type]);\n\tif (aux->task.type == BPF_TASK_ITER_TID)\n\t\tseq_printf(seq, \"tid:\\t%u\\n\", aux->task.pid);\n\telse if (aux->task.type == BPF_TASK_ITER_TGID)\n\t\tseq_printf(seq, \"pid:\\t%u\\n\", aux->task.pid);\n}\n\nstatic struct bpf_iter_reg task_reg_info = {\n\t.target\t\t\t= \"task\",\n\t.attach_target\t\t= bpf_iter_attach_task,\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_seq_info,\n\t.fill_link_info\t\t= bpf_iter_fill_link_info,\n\t.show_fdinfo\t\t= bpf_iter_task_show_fdinfo,\n};\n\nstatic const struct bpf_iter_seq_info task_file_seq_info = {\n\t.seq_ops\t\t= &task_file_seq_ops,\n\t.init_seq_private\t= init_seq_pidns,\n\t.fini_seq_private\t= fini_seq_pidns,\n\t.seq_priv_size\t\t= sizeof(struct bpf_iter_seq_task_file_info),\n};\n\nstatic struct bpf_iter_reg task_file_reg_info = {\n\t.target\t\t\t= \"task_file\",\n\t.attach_target\t\t= bpf_iter_attach_task,\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task_file, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t\t{ offsetof(struct bpf_iter__task_file, file),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_file_seq_info,\n\t.fill_link_info\t\t= bpf_iter_fill_link_info,\n\t.show_fdinfo\t\t= bpf_iter_task_show_fdinfo,\n};\n\nstatic const struct bpf_iter_seq_info task_vma_seq_info = {\n\t.seq_ops\t\t= &task_vma_seq_ops,\n\t.init_seq_private\t= init_seq_pidns,\n\t.fini_seq_private\t= fini_seq_pidns,\n\t.seq_priv_size\t\t= sizeof(struct bpf_iter_seq_task_vma_info),\n};\n\nstatic struct bpf_iter_reg task_vma_reg_info = {\n\t.target\t\t\t= \"task_vma\",\n\t.attach_target\t\t= bpf_iter_attach_task,\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__task_vma, task),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t\t{ offsetof(struct bpf_iter__task_vma, vma),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &task_vma_seq_info,\n\t.fill_link_info\t\t= bpf_iter_fill_link_info,\n\t.show_fdinfo\t\t= bpf_iter_task_show_fdinfo,\n};\n\nBPF_CALL_5(bpf_find_vma, struct task_struct *, task, u64, start,\n\t   bpf_callback_t, callback_fn, void *, callback_ctx, u64, flags)\n{\n\tstruct mmap_unlock_irq_work *work = NULL;\n\tstruct vm_area_struct *vma;\n\tbool irq_work_busy = false;\n\tstruct mm_struct *mm;\n\tint ret = -ENOENT;\n\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tmm = task->mm;\n\tif (!mm)\n\t\treturn -ENOENT;\n\n\tirq_work_busy = bpf_mmap_unlock_get_irq_work(&work);\n\n\tif (irq_work_busy || !mmap_read_trylock(mm))\n\t\treturn -EBUSY;\n\n\tvma = find_vma(mm, start);\n\n\tif (vma && vma->vm_start <= start && vma->vm_end > start) {\n\t\tcallback_fn((u64)(long)task, (u64)(long)vma,\n\t\t\t    (u64)(long)callback_ctx, 0, 0);\n\t\tret = 0;\n\t}\n\tbpf_mmap_unlock_mm(work, mm);\n\treturn ret;\n}\n\nconst struct bpf_func_proto bpf_find_vma_proto = {\n\t.func\t\t= bpf_find_vma,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_BTF_ID,\n\t.arg1_btf_id\t= &btf_tracing_ids[BTF_TRACING_TYPE_TASK],\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_PTR_TO_FUNC,\n\t.arg4_type\t= ARG_PTR_TO_STACK_OR_NULL,\n\t.arg5_type\t= ARG_ANYTHING,\n};\n\nDEFINE_PER_CPU(struct mmap_unlock_irq_work, mmap_unlock_work);\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}\n\nstatic int __init task_iter_init(void)\n{\n\tstruct mmap_unlock_irq_work *work;\n\tint ret, cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\twork = per_cpu_ptr(&mmap_unlock_work, cpu);\n\t\tinit_irq_work(&work->irq_work, do_mmap_read_unlock);\n\t}\n\n\ttask_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\tret = bpf_iter_reg_target(&task_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\ttask_file_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\ttask_file_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_FILE];\n\tret =  bpf_iter_reg_target(&task_file_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\ttask_vma_reg_info.ctx_arg_info[0].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_TASK];\n\ttask_vma_reg_info.ctx_arg_info[1].btf_id = btf_tracing_ids[BTF_TRACING_TYPE_VMA];\n\treturn bpf_iter_reg_target(&task_vma_reg_info);\n}\nlate_initcall(task_iter_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}