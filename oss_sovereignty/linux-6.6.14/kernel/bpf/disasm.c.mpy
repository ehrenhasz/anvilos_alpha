{
  "module_name": "disasm.c",
  "hash_id": "e729a3df0bde84f3c9345fe3dd266b3e82998bca703bd6da4d3e8f58e6ff064d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/disasm.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n\n#include \"disasm.h\"\n\n#define __BPF_FUNC_STR_FN(x) [BPF_FUNC_ ## x] = __stringify(bpf_ ## x)\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n#undef __BPF_FUNC_STR_FN\n\nstatic const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (!insn->src_reg &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call) {\n\t\tconst char *res;\n\n\t\tres = cbs->cb_call(cbs->private_data, insn);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)\n\t\tsnprintf(buff, len, \"kernel-function\");\n\n\treturn buff;\n}\n\nstatic const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}\n\nconst char *func_id_name(int id)\n{\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}\n\nconst char *const bpf_class_string[8] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_JMP32] = \"jmp32\",\n\t[BPF_ALU64] = \"alu64\",\n};\n\nconst char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\n\nstatic const char *const bpf_alu_sign_string[16] = {\n\t[BPF_DIV >> 4]  = \"s/=\",\n\t[BPF_MOD >> 4]  = \"s%=\",\n};\n\nstatic const char *const bpf_movsx_string[4] = {\n\t[0] = \"(s8)\",\n\t[1] = \"(s16)\",\n\t[3] = \"(s32)\",\n};\n\nstatic const char *const bpf_atomic_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"add\",\n\t[BPF_AND >> 4]  = \"and\",\n\t[BPF_OR >> 4]  = \"or\",\n\t[BPF_XOR >> 4]  = \"xor\",\n};\n\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\n\nstatic const char *const bpf_ldsx_string[] = {\n\t[BPF_W >> 3]  = \"s32\",\n\t[BPF_H >> 3]  = \"s16\",\n\t[BPF_B >> 3]  = \"s8\",\n};\n\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JLT >> 4]  = \"<\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JLE >> 4]  = \"<=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSLT >> 4] = \"s<\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_JSLE >> 4] = \"s<=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nstatic void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}\n\nstatic void print_bpf_bswap_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = bswap%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tinsn->imm, insn->dst_reg);\n}\n\nstatic bool is_sdiv_smod(const struct bpf_insn *insn)\n{\n\treturn (BPF_OP(insn->code)  == BPF_DIV || BPF_OP(insn->code) == BPF_MOD) &&\n\t       insn->off == 1;\n}\n\nstatic bool is_movsx(const struct bpf_insn *insn)\n{\n\treturn BPF_OP(insn->code) == BPF_MOV &&\n\t       (insn->off == 8 || insn->off == 16 || insn->off == 32);\n}\n\nvoid print_bpf_insn(const struct bpf_insn_cbs *cbs,\n\t\t    const struct bpf_insn *insn,\n\t\t    bool allow_ptr_leaks)\n{\n\tconst bpf_insn_print_t verbose = cbs->cb_print;\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_OP(insn->code) == BPF_END) {\n\t\t\tif (class == BPF_ALU64)\n\t\t\t\tprint_bpf_bswap_insn(verbose, cbs->private_data, insn);\n\t\t\telse\n\t\t\t\tprint_bpf_end_insn(verbose, cbs->private_data, insn);\n\t\t} else if (BPF_OP(insn->code) == BPF_NEG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d = -%c%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d %s %s%c%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tis_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]\n\t\t\t\t\t\t   : bpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tis_movsx(insn) ? bpf_movsx_string[(insn->off >> 3) - 1] : \"\",\n\t\t\t\tclass == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d %s %d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tis_sdiv_smod(insn) ? bpf_alu_sign_string[BPF_OP(insn->code) >> 4]\n\t\t\t\t\t\t   : bpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm);\n\t\t}\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t (insn->imm == BPF_ADD || insn->imm == BPF_AND ||\n\t\t\t  insn->imm == BPF_OR || insn->imm == BPF_XOR)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) lock *(%s *)(r%d %+d) %s r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->imm) >> 4],\n\t\t\t\tinsn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   (insn->imm == (BPF_ADD | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_AND | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_OR | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_XOR | BPF_FETCH))) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = atomic%s_fetch_%s((%s *)(r%d %+d), r%d)\\n\",\n\t\t\t\tinsn->code, insn->src_reg,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_atomic_alu_string[BPF_OP(insn->imm) >> 4],\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off, insn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   insn->imm == BPF_CMPXCHG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = atomic%s_cmpxchg((%s *)(r%d %+d), r0, r%d)\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   insn->imm == BPF_XCHG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = atomic%s_xchg((%s *)(r%d %+d), r%d)\\n\",\n\t\t\t\tinsn->code, insn->src_reg,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off, insn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_%02x\\n\", insn->code);\n\t\t}\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == 0xc0  ) {\n\t\t\tverbose(cbs->private_data, \"(%02x) nospec\\n\", insn->code);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_st_%02x\\n\", insn->code);\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM && BPF_MODE(insn->code) != BPF_MEMSX) {\n\t\t\tverbose(cbs->private_data, \"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tBPF_MODE(insn->code) == BPF_MEM ?\n\t\t\t\t bpf_ldst_string[BPF_SIZE(insn->code) >> 3] :\n\t\t\t\t bpf_ldsx_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t \n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool is_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD ||\n\t\t\t\t      insn->src_reg == BPF_PSEUDO_MAP_VALUE;\n\t\t\tchar tmp[64];\n\n\t\t\tif (is_ptr && !allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\t__func_imm_name(cbs, insn, imm,\n\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP32 || class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tchar tmp[64];\n\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL) {\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call pc%s\\n\",\n\t\t\t\t\tinsn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t\t} else {\n\t\t\t\tstrcpy(tmp, \"unknown\");\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)),\n\t\t\t\t\tinsn->imm);\n\t\t\t}\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP32 | BPF_JA)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) gotol pc%+d\\n\",\n\t\t\t\tinsn->code, insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data,\n\t\t\t\t\"(%02x) if %c%d %s %c%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, class == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(cbs->private_data,\n\t\t\t\t\"(%02x) if %c%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, class == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(cbs->private_data, \"(%02x) %s\\n\",\n\t\t\tinsn->code, bpf_class_string[class]);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}