{
  "module_name": "bpf_inode_storage.c",
  "hash_id": "01bbe8205961b25e3b8c1997be4765aeddc799fe669245f7555009c2beff074e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/bpf_inode_storage.c",
  "human_readable_source": "\n \n\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/bpf.h>\n#include <linux/bpf_local_storage.h>\n#include <net/sock.h>\n#include <uapi/linux/sock_diag.h>\n#include <uapi/linux/btf.h>\n#include <linux/bpf_lsm.h>\n#include <linux/btf_ids.h>\n#include <linux/fdtable.h>\n#include <linux/rcupdate_trace.h>\n\nDEFINE_BPF_STORAGE_CACHE(inode_cache);\n\nstatic struct bpf_local_storage __rcu **\ninode_storage_ptr(void *owner)\n{\n\tstruct inode *inode = owner;\n\tstruct bpf_storage_blob *bsb;\n\n\tbsb = bpf_inode(inode);\n\tif (!bsb)\n\t\treturn NULL;\n\treturn &bsb->storage;\n}\n\nstatic struct bpf_local_storage_data *inode_storage_lookup(struct inode *inode,\n\t\t\t\t\t\t\t   struct bpf_map *map,\n\t\t\t\t\t\t\t   bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *inode_storage;\n\tstruct bpf_local_storage_map *smap;\n\tstruct bpf_storage_blob *bsb;\n\n\tbsb = bpf_inode(inode);\n\tif (!bsb)\n\t\treturn NULL;\n\n\tinode_storage =\n\t\trcu_dereference_check(bsb->storage, bpf_rcu_lock_held());\n\tif (!inode_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(inode_storage, smap, cacheit_lockit);\n}\n\nvoid bpf_inode_storage_free(struct inode *inode)\n{\n\tstruct bpf_local_storage *local_storage;\n\tstruct bpf_storage_blob *bsb;\n\n\tbsb = bpf_inode(inode);\n\tif (!bsb)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlocal_storage = rcu_dereference(bsb->storage);\n\tif (!local_storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbpf_local_storage_destroy(local_storage);\n\trcu_read_unlock();\n}\n\nstatic void *bpf_fd_inode_storage_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct fd f = fdget_raw(*(int *)key);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tsdata = inode_storage_lookup(file_inode(f.file), map, true);\n\tfdput(f);\n\treturn sdata ? sdata->data : NULL;\n}\n\nstatic long bpf_fd_inode_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct fd f = fdget_raw(*(int *)key);\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (!inode_storage_ptr(file_inode(f.file))) {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\n\tsdata = bpf_local_storage_update(file_inode(f.file),\n\t\t\t\t\t (struct bpf_local_storage_map *)map,\n\t\t\t\t\t value, map_flags, GFP_ATOMIC);\n\tfdput(f);\n\treturn PTR_ERR_OR_ZERO(sdata);\n}\n\nstatic int inode_storage_delete(struct inode *inode, struct bpf_map *map)\n{\n\tstruct bpf_local_storage_data *sdata;\n\n\tsdata = inode_storage_lookup(inode, map, false);\n\tif (!sdata)\n\t\treturn -ENOENT;\n\n\tbpf_selem_unlink(SELEM(sdata), false);\n\n\treturn 0;\n}\n\nstatic long bpf_fd_inode_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct fd f = fdget_raw(*(int *)key);\n\tint err;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terr = inode_storage_delete(file_inode(f.file), map);\n\tfdput(f);\n\treturn err;\n}\n\n \nBPF_CALL_5(bpf_inode_storage_get, struct bpf_map *, map, struct inode *, inode,\n\t   void *, value, u64, flags, gfp_t, gfp_flags)\n{\n\tstruct bpf_local_storage_data *sdata;\n\n\tWARN_ON_ONCE(!bpf_rcu_lock_held());\n\tif (flags & ~(BPF_LOCAL_STORAGE_GET_F_CREATE))\n\t\treturn (unsigned long)NULL;\n\n\t \n\tif (!inode || !inode_storage_ptr(inode))\n\t\treturn (unsigned long)NULL;\n\n\tsdata = inode_storage_lookup(inode, map, true);\n\tif (sdata)\n\t\treturn (unsigned long)sdata->data;\n\n\t \n\tif (flags & BPF_LOCAL_STORAGE_GET_F_CREATE) {\n\t\tsdata = bpf_local_storage_update(\n\t\t\tinode, (struct bpf_local_storage_map *)map, value,\n\t\t\tBPF_NOEXIST, gfp_flags);\n\t\treturn IS_ERR(sdata) ? (unsigned long)NULL :\n\t\t\t\t\t     (unsigned long)sdata->data;\n\t}\n\n\treturn (unsigned long)NULL;\n}\n\nBPF_CALL_2(bpf_inode_storage_delete,\n\t   struct bpf_map *, map, struct inode *, inode)\n{\n\tWARN_ON_ONCE(!bpf_rcu_lock_held());\n\tif (!inode)\n\t\treturn -EINVAL;\n\n\t \n\treturn inode_storage_delete(inode, map);\n}\n\nstatic int notsupp_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\tvoid *next_key)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic struct bpf_map *inode_storage_map_alloc(union bpf_attr *attr)\n{\n\treturn bpf_local_storage_map_alloc(attr, &inode_cache, false);\n}\n\nstatic void inode_storage_map_free(struct bpf_map *map)\n{\n\tbpf_local_storage_map_free(map, &inode_cache, NULL);\n}\n\nconst struct bpf_map_ops inode_storage_map_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc_check = bpf_local_storage_map_alloc_check,\n\t.map_alloc = inode_storage_map_alloc,\n\t.map_free = inode_storage_map_free,\n\t.map_get_next_key = notsupp_get_next_key,\n\t.map_lookup_elem = bpf_fd_inode_storage_lookup_elem,\n\t.map_update_elem = bpf_fd_inode_storage_update_elem,\n\t.map_delete_elem = bpf_fd_inode_storage_delete_elem,\n\t.map_check_btf = bpf_local_storage_map_check_btf,\n\t.map_mem_usage = bpf_local_storage_map_mem_usage,\n\t.map_btf_id = &bpf_local_storage_map_btf_id[0],\n\t.map_owner_storage_ptr = inode_storage_ptr,\n};\n\nBTF_ID_LIST_SINGLE(bpf_inode_storage_btf_ids, struct, inode)\n\nconst struct bpf_func_proto bpf_inode_storage_get_proto = {\n\t.func\t\t= bpf_inode_storage_get,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_BTF_ID_OR_NULL,\n\t.arg2_btf_id\t= &bpf_inode_storage_btf_ids[0],\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nconst struct bpf_func_proto bpf_inode_storage_delete_proto = {\n\t.func\t\t= bpf_inode_storage_delete,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_BTF_ID_OR_NULL,\n\t.arg2_btf_id\t= &bpf_inode_storage_btf_ids[0],\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}