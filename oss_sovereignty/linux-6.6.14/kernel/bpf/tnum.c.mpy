{
  "module_name": "tnum.c",
  "hash_id": "a11d005c3e10d7789a47609b37485270edab72de43beb02e405d8418d8b89948",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/tnum.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/tnum.h>\n\n#define TNUM(_v, _m)\t(struct tnum){.value = _v, .mask = _m}\n \nconst struct tnum tnum_unknown = { .value = 0, .mask = -1 };\n\nstruct tnum tnum_const(u64 value)\n{\n\treturn TNUM(value, 0);\n}\n\nstruct tnum tnum_range(u64 min, u64 max)\n{\n\tu64 chi = min ^ max, delta;\n\tu8 bits = fls64(chi);\n\n\t \n\tif (bits > 63)\n\t\treturn tnum_unknown;\n\t \n\tdelta = (1ULL << bits) - 1;\n\treturn TNUM(min & ~delta, delta);\n}\n\nstruct tnum tnum_lshift(struct tnum a, u8 shift)\n{\n\treturn TNUM(a.value << shift, a.mask << shift);\n}\n\nstruct tnum tnum_rshift(struct tnum a, u8 shift)\n{\n\treturn TNUM(a.value >> shift, a.mask >> shift);\n}\n\nstruct tnum tnum_arshift(struct tnum a, u8 min_shift, u8 insn_bitness)\n{\n\t \n\tif (insn_bitness == 32)\n\t\treturn TNUM((u32)(((s32)a.value) >> min_shift),\n\t\t\t    (u32)(((s32)a.mask)  >> min_shift));\n\telse\n\t\treturn TNUM((s64)a.value >> min_shift,\n\t\t\t    (s64)a.mask  >> min_shift);\n}\n\nstruct tnum tnum_add(struct tnum a, struct tnum b)\n{\n\tu64 sm, sv, sigma, chi, mu;\n\n\tsm = a.mask + b.mask;\n\tsv = a.value + b.value;\n\tsigma = sm + sv;\n\tchi = sigma ^ sv;\n\tmu = chi | a.mask | b.mask;\n\treturn TNUM(sv & ~mu, mu);\n}\n\nstruct tnum tnum_sub(struct tnum a, struct tnum b)\n{\n\tu64 dv, alpha, beta, chi, mu;\n\n\tdv = a.value - b.value;\n\talpha = dv + a.mask;\n\tbeta = dv - b.mask;\n\tchi = alpha ^ beta;\n\tmu = chi | a.mask | b.mask;\n\treturn TNUM(dv & ~mu, mu);\n}\n\nstruct tnum tnum_and(struct tnum a, struct tnum b)\n{\n\tu64 alpha, beta, v;\n\n\talpha = a.value | a.mask;\n\tbeta = b.value | b.mask;\n\tv = a.value & b.value;\n\treturn TNUM(v, alpha & beta & ~v);\n}\n\nstruct tnum tnum_or(struct tnum a, struct tnum b)\n{\n\tu64 v, mu;\n\n\tv = a.value | b.value;\n\tmu = a.mask | b.mask;\n\treturn TNUM(v, mu & ~v);\n}\n\nstruct tnum tnum_xor(struct tnum a, struct tnum b)\n{\n\tu64 v, mu;\n\n\tv = a.value ^ b.value;\n\tmu = a.mask | b.mask;\n\treturn TNUM(v & ~mu, mu);\n}\n\n \nstruct tnum tnum_mul(struct tnum a, struct tnum b)\n{\n\tu64 acc_v = a.value * b.value;\n\tstruct tnum acc_m = TNUM(0, 0);\n\n\twhile (a.value || a.mask) {\n\t\t \n\t\tif (a.value & 1)\n\t\t\tacc_m = tnum_add(acc_m, TNUM(0, b.mask));\n\t\t \n\t\telse if (a.mask & 1)\n\t\t\tacc_m = tnum_add(acc_m, TNUM(0, b.value | b.mask));\n\t\t \n\t\ta = tnum_rshift(a, 1);\n\t\tb = tnum_lshift(b, 1);\n\t}\n\treturn tnum_add(TNUM(acc_v, 0), acc_m);\n}\n\n \nstruct tnum tnum_intersect(struct tnum a, struct tnum b)\n{\n\tu64 v, mu;\n\n\tv = a.value | b.value;\n\tmu = a.mask & b.mask;\n\treturn TNUM(v & ~mu, mu);\n}\n\nstruct tnum tnum_cast(struct tnum a, u8 size)\n{\n\ta.value &= (1ULL << (size * 8)) - 1;\n\ta.mask &= (1ULL << (size * 8)) - 1;\n\treturn a;\n}\n\nbool tnum_is_aligned(struct tnum a, u64 size)\n{\n\tif (!size)\n\t\treturn true;\n\treturn !((a.value | a.mask) & (size - 1));\n}\n\nbool tnum_in(struct tnum a, struct tnum b)\n{\n\tif (b.mask & ~a.mask)\n\t\treturn false;\n\tb.value &= ~a.mask;\n\treturn a.value == b.value;\n}\n\nint tnum_strn(char *str, size_t size, struct tnum a)\n{\n\treturn snprintf(str, size, \"(%#llx; %#llx)\", a.value, a.mask);\n}\nEXPORT_SYMBOL_GPL(tnum_strn);\n\nint tnum_sbin(char *str, size_t size, struct tnum a)\n{\n\tsize_t n;\n\n\tfor (n = 64; n; n--) {\n\t\tif (n < size) {\n\t\t\tif (a.mask & 1)\n\t\t\t\tstr[n - 1] = 'x';\n\t\t\telse if (a.value & 1)\n\t\t\t\tstr[n - 1] = '1';\n\t\t\telse\n\t\t\t\tstr[n - 1] = '0';\n\t\t}\n\t\ta.mask >>= 1;\n\t\ta.value >>= 1;\n\t}\n\tstr[min(size - 1, (size_t)64)] = 0;\n\treturn 64;\n}\n\nstruct tnum tnum_subreg(struct tnum a)\n{\n\treturn tnum_cast(a, 4);\n}\n\nstruct tnum tnum_clear_subreg(struct tnum a)\n{\n\treturn tnum_lshift(tnum_rshift(a, 32), 32);\n}\n\nstruct tnum tnum_const_subreg(struct tnum a, u32 value)\n{\n\treturn tnum_or(tnum_clear_subreg(a), tnum_const(value));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}