{
  "module_name": "dispatcher.c",
  "hash_id": "7ab69bd4a6a747f889899ced792179358f11e071106d39ebf2a9592a35aa9980",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/dispatcher.c",
  "human_readable_source": "\n \n\n#include <linux/hash.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/static_call.h>\n\n \n\nstatic struct bpf_dispatcher_prog *bpf_dispatcher_find_prog(\n\tstruct bpf_dispatcher *d, struct bpf_prog *prog)\n{\n\tint i;\n\n\tfor (i = 0; i < BPF_DISPATCHER_MAX; i++) {\n\t\tif (prog == d->progs[i].prog)\n\t\t\treturn &d->progs[i];\n\t}\n\treturn NULL;\n}\n\nstatic struct bpf_dispatcher_prog *bpf_dispatcher_find_free(\n\tstruct bpf_dispatcher *d)\n{\n\treturn bpf_dispatcher_find_prog(d, NULL);\n}\n\nstatic bool bpf_dispatcher_add_prog(struct bpf_dispatcher *d,\n\t\t\t\t    struct bpf_prog *prog)\n{\n\tstruct bpf_dispatcher_prog *entry;\n\n\tif (!prog)\n\t\treturn false;\n\n\tentry = bpf_dispatcher_find_prog(d, prog);\n\tif (entry) {\n\t\trefcount_inc(&entry->users);\n\t\treturn false;\n\t}\n\n\tentry = bpf_dispatcher_find_free(d);\n\tif (!entry)\n\t\treturn false;\n\n\tbpf_prog_inc(prog);\n\tentry->prog = prog;\n\trefcount_set(&entry->users, 1);\n\td->num_progs++;\n\treturn true;\n}\n\nstatic bool bpf_dispatcher_remove_prog(struct bpf_dispatcher *d,\n\t\t\t\t       struct bpf_prog *prog)\n{\n\tstruct bpf_dispatcher_prog *entry;\n\n\tif (!prog)\n\t\treturn false;\n\n\tentry = bpf_dispatcher_find_prog(d, prog);\n\tif (!entry)\n\t\treturn false;\n\n\tif (refcount_dec_and_test(&entry->users)) {\n\t\tentry->prog = NULL;\n\t\tbpf_prog_put(prog);\n\t\td->num_progs--;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint __weak arch_prepare_bpf_dispatcher(void *image, void *buf, s64 *funcs, int num_funcs)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int bpf_dispatcher_prepare(struct bpf_dispatcher *d, void *image, void *buf)\n{\n\ts64 ips[BPF_DISPATCHER_MAX] = {}, *ipsp = &ips[0];\n\tint i;\n\n\tfor (i = 0; i < BPF_DISPATCHER_MAX; i++) {\n\t\tif (d->progs[i].prog)\n\t\t\t*ipsp++ = (s64)(uintptr_t)d->progs[i].prog->bpf_func;\n\t}\n\treturn arch_prepare_bpf_dispatcher(image, buf, &ips[0], d->num_progs);\n}\n\nstatic void bpf_dispatcher_update(struct bpf_dispatcher *d, int prev_num_progs)\n{\n\tvoid *new, *tmp;\n\tu32 noff = 0;\n\n\tif (prev_num_progs)\n\t\tnoff = d->image_off ^ (PAGE_SIZE / 2);\n\n\tnew = d->num_progs ? d->image + noff : NULL;\n\ttmp = d->num_progs ? d->rw_image + noff : NULL;\n\tif (new) {\n\t\t \n\t\tif (bpf_dispatcher_prepare(d, new, tmp))\n\t\t\treturn;\n\t\tif (IS_ERR(bpf_arch_text_copy(new, tmp, PAGE_SIZE / 2)))\n\t\t\treturn;\n\t}\n\n\t__BPF_DISPATCHER_UPDATE(d, new ?: (void *)&bpf_dispatcher_nop_func);\n\n\t \n\tsynchronize_rcu();\n\n\tif (new)\n\t\td->image_off = noff;\n}\n\nvoid bpf_dispatcher_change_prog(struct bpf_dispatcher *d, struct bpf_prog *from,\n\t\t\t\tstruct bpf_prog *to)\n{\n\tbool changed = false;\n\tint prev_num_progs;\n\n\tif (from == to)\n\t\treturn;\n\n\tmutex_lock(&d->mutex);\n\tif (!d->image) {\n\t\td->image = bpf_prog_pack_alloc(PAGE_SIZE, bpf_jit_fill_hole_with_zero);\n\t\tif (!d->image)\n\t\t\tgoto out;\n\t\td->rw_image = bpf_jit_alloc_exec(PAGE_SIZE);\n\t\tif (!d->rw_image) {\n\t\t\tu32 size = PAGE_SIZE;\n\n\t\t\tbpf_arch_text_copy(d->image, &size, sizeof(size));\n\t\t\tbpf_prog_pack_free((struct bpf_binary_header *)d->image);\n\t\t\td->image = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tbpf_image_ksym_add(d->image, &d->ksym);\n\t}\n\n\tprev_num_progs = d->num_progs;\n\tchanged |= bpf_dispatcher_remove_prog(d, from);\n\tchanged |= bpf_dispatcher_add_prog(d, to);\n\n\tif (!changed)\n\t\tgoto out;\n\n\tbpf_dispatcher_update(d, prev_num_progs);\nout:\n\tmutex_unlock(&d->mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}