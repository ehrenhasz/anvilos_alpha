{
  "module_name": "bloom_filter.c",
  "hash_id": "c6d69737e23e243ee8f8f86c0b1264f6bdfd1634f05b1a1c9c9cd9f025996dcd",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/bloom_filter.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/err.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/btf_ids.h>\n\n#define BLOOM_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_ZERO_SEED | BPF_F_ACCESS_MASK)\n\nstruct bpf_bloom_filter {\n\tstruct bpf_map map;\n\tu32 bitset_mask;\n\tu32 hash_seed;\n\tu32 nr_hash_funcs;\n\tunsigned long bitset[];\n};\n\nstatic u32 hash(struct bpf_bloom_filter *bloom, void *value,\n\t\tu32 value_size, u32 index)\n{\n\tu32 h;\n\n\tif (likely(value_size % 4 == 0))\n\t\th = jhash2(value, value_size / 4, bloom->hash_seed + index);\n\telse\n\t\th = jhash(value, value_size, bloom->hash_seed + index);\n\n\treturn h & bloom->bitset_mask;\n}\n\nstatic long bloom_map_peek_elem(struct bpf_map *map, void *value)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\tu32 i, h;\n\n\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {\n\t\th = hash(bloom, value, map->value_size, i);\n\t\tif (!test_bit(h, bloom->bitset))\n\t\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic long bloom_map_push_elem(struct bpf_map *map, void *value, u64 flags)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\tu32 i, h;\n\n\tif (flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < bloom->nr_hash_funcs; i++) {\n\t\th = hash(bloom, value, map->value_size, i);\n\t\tset_bit(h, bloom->bitset);\n\t}\n\n\treturn 0;\n}\n\nstatic long bloom_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic long bloom_map_delete_elem(struct bpf_map *map, void *value)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int bloom_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct bpf_map *bloom_map_alloc(union bpf_attr *attr)\n{\n\tu32 bitset_bytes, bitset_mask, nr_hash_funcs, nr_bits;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_bloom_filter *bloom;\n\n\tif (attr->key_size != 0 || attr->value_size == 0 ||\n\t    attr->max_entries == 0 ||\n\t    attr->map_flags & ~BLOOM_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t     \n\t    (attr->map_extra & ~0xF))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_hash_funcs = attr->map_extra;\n\tif (nr_hash_funcs == 0)\n\t\t \n\t\tnr_hash_funcs = 5;\n\n\t \n\tif (check_mul_overflow(attr->max_entries, nr_hash_funcs, &nr_bits) ||\n\t    check_mul_overflow(nr_bits / 5, (u32)7, &nr_bits) ||\n\t    nr_bits > (1UL << 31)) {\n\t\t \n\t\tbitset_bytes = BITS_TO_BYTES(U32_MAX);\n\t\tbitset_mask = U32_MAX;\n\t} else {\n\t\tif (nr_bits <= BITS_PER_LONG)\n\t\t\tnr_bits = BITS_PER_LONG;\n\t\telse\n\t\t\tnr_bits = roundup_pow_of_two(nr_bits);\n\t\tbitset_bytes = BITS_TO_BYTES(nr_bits);\n\t\tbitset_mask = nr_bits - 1;\n\t}\n\n\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));\n\tbloom = bpf_map_area_alloc(sizeof(*bloom) + bitset_bytes, numa_node);\n\n\tif (!bloom)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&bloom->map, attr);\n\n\tbloom->nr_hash_funcs = nr_hash_funcs;\n\tbloom->bitset_mask = bitset_mask;\n\n\tif (!(attr->map_flags & BPF_F_ZERO_SEED))\n\t\tbloom->hash_seed = get_random_u32();\n\n\treturn &bloom->map;\n}\n\nstatic void bloom_map_free(struct bpf_map *map)\n{\n\tstruct bpf_bloom_filter *bloom =\n\t\tcontainer_of(map, struct bpf_bloom_filter, map);\n\n\tbpf_map_area_free(bloom);\n}\n\nstatic void *bloom_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\t \n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic long bloom_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t  void *value, u64 flags)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int bloom_map_check_btf(const struct bpf_map *map,\n\t\t\t       const struct btf *btf,\n\t\t\t       const struct btf_type *key_type,\n\t\t\t       const struct btf_type *value_type)\n{\n\t \n\treturn btf_type_is_void(key_type) ? 0 : -EINVAL;\n}\n\nstatic u64 bloom_map_mem_usage(const struct bpf_map *map)\n{\n\tstruct bpf_bloom_filter *bloom;\n\tu64 bitset_bytes;\n\n\tbloom = container_of(map, struct bpf_bloom_filter, map);\n\tbitset_bytes = BITS_TO_BYTES((u64)bloom->bitset_mask + 1);\n\tbitset_bytes = roundup(bitset_bytes, sizeof(unsigned long));\n\treturn sizeof(*bloom) + bitset_bytes;\n}\n\nBTF_ID_LIST_SINGLE(bpf_bloom_map_btf_ids, struct, bpf_bloom_filter)\nconst struct bpf_map_ops bloom_filter_map_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = bloom_map_alloc,\n\t.map_free = bloom_map_free,\n\t.map_get_next_key = bloom_map_get_next_key,\n\t.map_push_elem = bloom_map_push_elem,\n\t.map_peek_elem = bloom_map_peek_elem,\n\t.map_pop_elem = bloom_map_pop_elem,\n\t.map_lookup_elem = bloom_map_lookup_elem,\n\t.map_update_elem = bloom_map_update_elem,\n\t.map_delete_elem = bloom_map_delete_elem,\n\t.map_check_btf = bloom_map_check_btf,\n\t.map_mem_usage = bloom_map_mem_usage,\n\t.map_btf_id = &bpf_bloom_map_btf_ids[0],\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}