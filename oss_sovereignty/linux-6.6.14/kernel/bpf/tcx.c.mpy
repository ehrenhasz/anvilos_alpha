{
  "module_name": "tcx.c",
  "hash_id": "87b0510182346e8b394d82336f2e04238eda41c6a29064b02d4fcc5d2251f403",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/tcx.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/bpf_mprog.h>\n#include <linux/netdevice.h>\n\n#include <net/tcx.h>\n\nint tcx_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tbool created, ingress = attr->attach_type == BPF_TCX_INGRESS;\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct bpf_mprog_entry *entry, *entry_new;\n\tstruct bpf_prog *replace_prog = NULL;\n\tstruct net_device *dev;\n\tint ret;\n\n\trtnl_lock();\n\tdev = __dev_get_by_index(net, attr->target_ifindex);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (attr->attach_flags & BPF_F_REPLACE) {\n\t\treplace_prog = bpf_prog_get_type(attr->replace_bpf_fd,\n\t\t\t\t\t\t prog->type);\n\t\tif (IS_ERR(replace_prog)) {\n\t\t\tret = PTR_ERR(replace_prog);\n\t\t\treplace_prog = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tentry = tcx_entry_fetch_or_create(dev, ingress, &created);\n\tif (!entry) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = bpf_mprog_attach(entry, &entry_new, prog, NULL, replace_prog,\n\t\t\t       attr->attach_flags, attr->relative_fd,\n\t\t\t       attr->expected_revision);\n\tif (!ret) {\n\t\tif (entry != entry_new) {\n\t\t\ttcx_entry_update(dev, entry_new, ingress);\n\t\t\ttcx_entry_sync();\n\t\t\ttcx_skeys_inc(ingress);\n\t\t}\n\t\tbpf_mprog_commit(entry);\n\t} else if (created) {\n\t\ttcx_entry_free(entry);\n\t}\nout:\n\tif (replace_prog)\n\t\tbpf_prog_put(replace_prog);\n\trtnl_unlock();\n\treturn ret;\n}\n\nint tcx_prog_detach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tbool ingress = attr->attach_type == BPF_TCX_INGRESS;\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct bpf_mprog_entry *entry, *entry_new;\n\tstruct net_device *dev;\n\tint ret;\n\n\trtnl_lock();\n\tdev = __dev_get_by_index(net, attr->target_ifindex);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tentry = tcx_entry_fetch(dev, ingress);\n\tif (!entry) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = bpf_mprog_detach(entry, &entry_new, prog, NULL, attr->attach_flags,\n\t\t\t       attr->relative_fd, attr->expected_revision);\n\tif (!ret) {\n\t\tif (!tcx_entry_is_active(entry_new))\n\t\t\tentry_new = NULL;\n\t\ttcx_entry_update(dev, entry_new, ingress);\n\t\ttcx_entry_sync();\n\t\ttcx_skeys_dec(ingress);\n\t\tbpf_mprog_commit(entry);\n\t\tif (!entry_new)\n\t\t\ttcx_entry_free(entry);\n\t}\nout:\n\trtnl_unlock();\n\treturn ret;\n}\n\nvoid tcx_uninstall(struct net_device *dev, bool ingress)\n{\n\tstruct bpf_mprog_entry *entry, *entry_new = NULL;\n\tstruct bpf_tuple tuple = {};\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\tbool active;\n\n\tentry = tcx_entry_fetch(dev, ingress);\n\tif (!entry)\n\t\treturn;\n\tactive = tcx_entry(entry)->miniq_active;\n\tif (active)\n\t\tbpf_mprog_clear_all(entry, &entry_new);\n\ttcx_entry_update(dev, entry_new, ingress);\n\ttcx_entry_sync();\n\tbpf_mprog_foreach_tuple(entry, fp, cp, tuple) {\n\t\tif (tuple.link)\n\t\t\ttcx_link(tuple.link)->dev = NULL;\n\t\telse\n\t\t\tbpf_prog_put(tuple.prog);\n\t\ttcx_skeys_dec(ingress);\n\t}\n\tif (!active)\n\t\ttcx_entry_free(entry);\n}\n\nint tcx_prog_query(const union bpf_attr *attr, union bpf_attr __user *uattr)\n{\n\tbool ingress = attr->query.attach_type == BPF_TCX_INGRESS;\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct net_device *dev;\n\tint ret;\n\n\trtnl_lock();\n\tdev = __dev_get_by_index(net, attr->query.target_ifindex);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tret = bpf_mprog_query(attr, uattr, tcx_entry_fetch(dev, ingress));\nout:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic int tcx_link_prog_attach(struct bpf_link *link, u32 flags, u32 id_or_fd,\n\t\t\t\tu64 revision)\n{\n\tstruct tcx_link *tcx = tcx_link(link);\n\tbool created, ingress = tcx->location == BPF_TCX_INGRESS;\n\tstruct bpf_mprog_entry *entry, *entry_new;\n\tstruct net_device *dev = tcx->dev;\n\tint ret;\n\n\tASSERT_RTNL();\n\tentry = tcx_entry_fetch_or_create(dev, ingress, &created);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tret = bpf_mprog_attach(entry, &entry_new, link->prog, link, NULL, flags,\n\t\t\t       id_or_fd, revision);\n\tif (!ret) {\n\t\tif (entry != entry_new) {\n\t\t\ttcx_entry_update(dev, entry_new, ingress);\n\t\t\ttcx_entry_sync();\n\t\t\ttcx_skeys_inc(ingress);\n\t\t}\n\t\tbpf_mprog_commit(entry);\n\t} else if (created) {\n\t\ttcx_entry_free(entry);\n\t}\n\treturn ret;\n}\n\nstatic void tcx_link_release(struct bpf_link *link)\n{\n\tstruct tcx_link *tcx = tcx_link(link);\n\tbool ingress = tcx->location == BPF_TCX_INGRESS;\n\tstruct bpf_mprog_entry *entry, *entry_new;\n\tstruct net_device *dev;\n\tint ret = 0;\n\n\trtnl_lock();\n\tdev = tcx->dev;\n\tif (!dev)\n\t\tgoto out;\n\tentry = tcx_entry_fetch(dev, ingress);\n\tif (!entry) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = bpf_mprog_detach(entry, &entry_new, link->prog, link, 0, 0, 0);\n\tif (!ret) {\n\t\tif (!tcx_entry_is_active(entry_new))\n\t\t\tentry_new = NULL;\n\t\ttcx_entry_update(dev, entry_new, ingress);\n\t\ttcx_entry_sync();\n\t\ttcx_skeys_dec(ingress);\n\t\tbpf_mprog_commit(entry);\n\t\tif (!entry_new)\n\t\t\ttcx_entry_free(entry);\n\t\ttcx->dev = NULL;\n\t}\nout:\n\tWARN_ON_ONCE(ret);\n\trtnl_unlock();\n}\n\nstatic int tcx_link_update(struct bpf_link *link, struct bpf_prog *nprog,\n\t\t\t   struct bpf_prog *oprog)\n{\n\tstruct tcx_link *tcx = tcx_link(link);\n\tbool ingress = tcx->location == BPF_TCX_INGRESS;\n\tstruct bpf_mprog_entry *entry, *entry_new;\n\tstruct net_device *dev;\n\tint ret = 0;\n\n\trtnl_lock();\n\tdev = tcx->dev;\n\tif (!dev) {\n\t\tret = -ENOLINK;\n\t\tgoto out;\n\t}\n\tif (oprog && link->prog != oprog) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\toprog = link->prog;\n\tif (oprog == nprog) {\n\t\tbpf_prog_put(nprog);\n\t\tgoto out;\n\t}\n\tentry = tcx_entry_fetch(dev, ingress);\n\tif (!entry) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = bpf_mprog_attach(entry, &entry_new, nprog, link, oprog,\n\t\t\t       BPF_F_REPLACE | BPF_F_ID,\n\t\t\t       link->prog->aux->id, 0);\n\tif (!ret) {\n\t\tWARN_ON_ONCE(entry != entry_new);\n\t\toprog = xchg(&link->prog, nprog);\n\t\tbpf_prog_put(oprog);\n\t\tbpf_mprog_commit(entry);\n\t}\nout:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic void tcx_link_dealloc(struct bpf_link *link)\n{\n\tkfree(tcx_link(link));\n}\n\nstatic void tcx_link_fdinfo(const struct bpf_link *link, struct seq_file *seq)\n{\n\tconst struct tcx_link *tcx = tcx_link_const(link);\n\tu32 ifindex = 0;\n\n\trtnl_lock();\n\tif (tcx->dev)\n\t\tifindex = tcx->dev->ifindex;\n\trtnl_unlock();\n\n\tseq_printf(seq, \"ifindex:\\t%u\\n\", ifindex);\n\tseq_printf(seq, \"attach_type:\\t%u (%s)\\n\",\n\t\t   tcx->location,\n\t\t   tcx->location == BPF_TCX_INGRESS ? \"ingress\" : \"egress\");\n}\n\nstatic int tcx_link_fill_info(const struct bpf_link *link,\n\t\t\t      struct bpf_link_info *info)\n{\n\tconst struct tcx_link *tcx = tcx_link_const(link);\n\tu32 ifindex = 0;\n\n\trtnl_lock();\n\tif (tcx->dev)\n\t\tifindex = tcx->dev->ifindex;\n\trtnl_unlock();\n\n\tinfo->tcx.ifindex = ifindex;\n\tinfo->tcx.attach_type = tcx->location;\n\treturn 0;\n}\n\nstatic int tcx_link_detach(struct bpf_link *link)\n{\n\ttcx_link_release(link);\n\treturn 0;\n}\n\nstatic const struct bpf_link_ops tcx_link_lops = {\n\t.release\t= tcx_link_release,\n\t.detach\t\t= tcx_link_detach,\n\t.dealloc\t= tcx_link_dealloc,\n\t.update_prog\t= tcx_link_update,\n\t.show_fdinfo\t= tcx_link_fdinfo,\n\t.fill_link_info\t= tcx_link_fill_info,\n};\n\nstatic int tcx_link_init(struct tcx_link *tcx,\n\t\t\t struct bpf_link_primer *link_primer,\n\t\t\t const union bpf_attr *attr,\n\t\t\t struct net_device *dev,\n\t\t\t struct bpf_prog *prog)\n{\n\tbpf_link_init(&tcx->link, BPF_LINK_TYPE_TCX, &tcx_link_lops, prog);\n\ttcx->location = attr->link_create.attach_type;\n\ttcx->dev = dev;\n\treturn bpf_link_prime(&tcx->link, link_primer);\n}\n\nint tcx_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct bpf_link_primer link_primer;\n\tstruct net_device *dev;\n\tstruct tcx_link *tcx;\n\tint ret;\n\n\trtnl_lock();\n\tdev = __dev_get_by_index(net, attr->link_create.target_ifindex);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\ttcx = kzalloc(sizeof(*tcx), GFP_USER);\n\tif (!tcx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = tcx_link_init(tcx, &link_primer, attr, dev, prog);\n\tif (ret) {\n\t\tkfree(tcx);\n\t\tgoto out;\n\t}\n\tret = tcx_link_prog_attach(&tcx->link, attr->link_create.flags,\n\t\t\t\t   attr->link_create.tcx.relative_fd,\n\t\t\t\t   attr->link_create.tcx.expected_revision);\n\tif (ret) {\n\t\ttcx->dev = NULL;\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out;\n\t}\n\tret = bpf_link_settle(&link_primer);\nout:\n\trtnl_unlock();\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}