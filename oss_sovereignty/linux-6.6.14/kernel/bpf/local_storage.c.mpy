{
  "module_name": "local_storage.c",
  "hash_id": "2f6ee549baeb567822c6b37e92ab711dc7787f72187868c9094655e90cf07d1b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/local_storage.c",
  "human_readable_source": "\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf.h>\n#include <linux/bug.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <uapi/linux/btf.h>\n#include <linux/btf_ids.h>\n\n#ifdef CONFIG_CGROUP_BPF\n\n#include \"../cgroup/cgroup-internal.h\"\n\n#define LOCAL_STORAGE_CREATE_FLAG_MASK\t\t\t\t\t\\\n\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)\n\nstruct bpf_cgroup_storage_map {\n\tstruct bpf_map map;\n\n\tspinlock_t lock;\n\tstruct rb_root root;\n\tstruct list_head list;\n};\n\nstatic struct bpf_cgroup_storage_map *map_to_storage(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_cgroup_storage_map, map);\n}\n\nstatic bool attach_type_isolated(const struct bpf_map *map)\n{\n\treturn map->key_size == sizeof(struct bpf_cgroup_storage_key);\n}\n\nstatic int bpf_cgroup_storage_key_cmp(const struct bpf_cgroup_storage_map *map,\n\t\t\t\t      const void *_key1, const void *_key2)\n{\n\tif (attach_type_isolated(&map->map)) {\n\t\tconst struct bpf_cgroup_storage_key *key1 = _key1;\n\t\tconst struct bpf_cgroup_storage_key *key2 = _key2;\n\n\t\tif (key1->cgroup_inode_id < key2->cgroup_inode_id)\n\t\t\treturn -1;\n\t\telse if (key1->cgroup_inode_id > key2->cgroup_inode_id)\n\t\t\treturn 1;\n\t\telse if (key1->attach_type < key2->attach_type)\n\t\t\treturn -1;\n\t\telse if (key1->attach_type > key2->attach_type)\n\t\t\treturn 1;\n\t} else {\n\t\tconst __u64 *cgroup_inode_id1 = _key1;\n\t\tconst __u64 *cgroup_inode_id2 = _key2;\n\n\t\tif (*cgroup_inode_id1 < *cgroup_inode_id2)\n\t\t\treturn -1;\n\t\telse if (*cgroup_inode_id1 > *cgroup_inode_id2)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct bpf_cgroup_storage *\ncgroup_storage_lookup(struct bpf_cgroup_storage_map *map,\n\t\t      void *key, bool locked)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node *node;\n\n\tif (!locked)\n\t\tspin_lock_bh(&map->lock);\n\n\tnode = root->rb_node;\n\twhile (node) {\n\t\tstruct bpf_cgroup_storage *storage;\n\n\t\tstorage = container_of(node, struct bpf_cgroup_storage, node);\n\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, key, &storage->key)) {\n\t\tcase -1:\n\t\t\tnode = node->rb_left;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnode = node->rb_right;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!locked)\n\t\t\t\tspin_unlock_bh(&map->lock);\n\t\t\treturn storage;\n\t\t}\n\t}\n\n\tif (!locked)\n\t\tspin_unlock_bh(&map->lock);\n\n\treturn NULL;\n}\n\nstatic int cgroup_storage_insert(struct bpf_cgroup_storage_map *map,\n\t\t\t\t struct bpf_cgroup_storage *storage)\n{\n\tstruct rb_root *root = &map->root;\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\n\twhile (*new) {\n\t\tstruct bpf_cgroup_storage *this;\n\n\t\tthis = container_of(*new, struct bpf_cgroup_storage, node);\n\n\t\tparent = *new;\n\t\tswitch (bpf_cgroup_storage_key_cmp(map, &storage->key, &this->key)) {\n\t\tcase -1:\n\t\t\tnew = &((*new)->rb_left);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnew = &((*new)->rb_right);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&storage->node, parent, new);\n\trb_insert_color(&storage->node, root);\n\n\treturn 0;\n}\n\nstatic void *cgroup_storage_lookup_elem(struct bpf_map *_map, void *key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage)\n\t\treturn NULL;\n\n\treturn &READ_ONCE(storage->buf)->data[0];\n}\n\nstatic long cgroup_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 flags)\n{\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_storage_buffer *new;\n\n\tif (unlikely(flags & ~(BPF_F_LOCK | BPF_EXIST)))\n\t\treturn -EINVAL;\n\n\tif (unlikely((flags & BPF_F_LOCK) &&\n\t\t     !btf_record_has_field(map->record, BPF_SPIN_LOCK)))\n\t\treturn -EINVAL;\n\n\tstorage = cgroup_storage_lookup((struct bpf_cgroup_storage_map *)map,\n\t\t\t\t\tkey, false);\n\tif (!storage)\n\t\treturn -ENOENT;\n\n\tif (flags & BPF_F_LOCK) {\n\t\tcopy_map_value_locked(map, storage->buf->data, value, false);\n\t\treturn 0;\n\t}\n\n\tnew = bpf_map_kmalloc_node(map, struct_size(new, data, map->value_size),\n\t\t\t\t   __GFP_ZERO | GFP_NOWAIT | __GFP_NOWARN,\n\t\t\t\t   map->numa_node);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&new->data[0], value, map->value_size);\n\tcheck_and_init_map_value(map, new->data);\n\n\tnew = xchg(&storage->buf, new);\n\tkfree_rcu(new, rcu);\n\n\treturn 0;\n}\n\nint bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\nint bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int cgroup_storage_get_next_key(struct bpf_map *_map, void *key,\n\t\t\t\t       void *_next_key)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage *storage;\n\n\tspin_lock_bh(&map->lock);\n\n\tif (list_empty(&map->list))\n\t\tgoto enoent;\n\n\tif (key) {\n\t\tstorage = cgroup_storage_lookup(map, key, true);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\n\t\tstorage = list_next_entry(storage, list_map);\n\t\tif (!storage)\n\t\t\tgoto enoent;\n\t} else {\n\t\tstorage = list_first_entry(&map->list,\n\t\t\t\t\t struct bpf_cgroup_storage, list_map);\n\t}\n\n\tspin_unlock_bh(&map->lock);\n\n\tif (attach_type_isolated(&map->map)) {\n\t\tstruct bpf_cgroup_storage_key *next = _next_key;\n\t\t*next = storage->key;\n\t} else {\n\t\t__u64 *next = _next_key;\n\t\t*next = storage->key.cgroup_inode_id;\n\t}\n\treturn 0;\n\nenoent:\n\tspin_unlock_bh(&map->lock);\n\treturn -ENOENT;\n}\n\nstatic struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)\n{\n\t__u32 max_value_size = BPF_LOCAL_STORAGE_MAX_VALUE_SIZE;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_cgroup_storage_map *map;\n\n\t \n\tif (attr->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tmax_value_size = min_t(__u32, max_value_size,\n\t\t\t\t       PCPU_MIN_UNIT_SIZE);\n\n\tif (attr->key_size != sizeof(struct bpf_cgroup_storage_key) &&\n\t    attr->key_size != sizeof(__u64))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->value_size > max_value_size)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tif (attr->map_flags & ~LOCAL_STORAGE_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->max_entries)\n\t\t \n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = bpf_map_area_alloc(sizeof(struct bpf_cgroup_storage_map), numa_node);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tbpf_map_init_from_attr(&map->map, attr);\n\n\tspin_lock_init(&map->lock);\n\tmap->root = RB_ROOT;\n\tINIT_LIST_HEAD(&map->list);\n\n\treturn &map->map;\n}\n\nstatic void cgroup_storage_map_free(struct bpf_map *_map)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct list_head *storages = &map->list;\n\tstruct bpf_cgroup_storage *storage, *stmp;\n\n\tcgroup_lock();\n\n\tlist_for_each_entry_safe(storage, stmp, storages, list_map) {\n\t\tbpf_cgroup_storage_unlink(storage);\n\t\tbpf_cgroup_storage_free(storage);\n\t}\n\n\tcgroup_unlock();\n\n\tWARN_ON(!RB_EMPTY_ROOT(&map->root));\n\tWARN_ON(!list_empty(&map->list));\n\n\tbpf_map_area_free(map);\n}\n\nstatic long cgroup_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}\n\nstatic int cgroup_storage_check_btf(const struct bpf_map *map,\n\t\t\t\t    const struct btf *btf,\n\t\t\t\t    const struct btf_type *key_type,\n\t\t\t\t    const struct btf_type *value_type)\n{\n\tif (attach_type_isolated(map)) {\n\t\tstruct btf_member *m;\n\t\tu32 offset, size;\n\n\t\t \n\n\t\t \n\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ||\n\t\t    BTF_INFO_VLEN(key_type->info) != 2)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tm = (struct btf_member *)(key_type + 1);\n\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, cgroup_inode_id);\n\t\tif (!btf_member_is_reg_int(btf, key_type, m, 0, size))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tm++;\n\t\toffset = offsetof(struct bpf_cgroup_storage_key, attach_type);\n\t\tsize = sizeof_field(struct bpf_cgroup_storage_key, attach_type);\n\t\tif (!btf_member_is_reg_int(btf, key_type, m, offset, size))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tu32 int_data;\n\n\t\t \n\n\t\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\t\treturn -EINVAL;\n\n\t\tint_data = *(u32 *)(key_type + 1);\n\t\tif (BTF_INT_BITS(int_data) != 64 || BTF_INT_OFFSET(int_data))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void cgroup_storage_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t struct seq_file *m)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map_to_storage(map), key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tseq_puts(m, \": \");\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  &READ_ONCE(storage->buf)->data[0], m);\n\t\tseq_puts(m, \"\\n\");\n\t} else {\n\t\tseq_puts(m, \": {\\n\");\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t\t  per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\t\t  m);\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t\tseq_puts(m, \"}\\n\");\n\t}\n\trcu_read_unlock();\n}\n\nstatic u64 cgroup_storage_map_usage(const struct bpf_map *map)\n{\n\t \n\treturn sizeof(struct bpf_cgroup_storage_map);\n}\n\nBTF_ID_LIST_SINGLE(cgroup_storage_map_btf_ids, struct,\n\t\t   bpf_cgroup_storage_map)\nconst struct bpf_map_ops cgroup_storage_map_ops = {\n\t.map_alloc = cgroup_storage_map_alloc,\n\t.map_free = cgroup_storage_map_free,\n\t.map_get_next_key = cgroup_storage_get_next_key,\n\t.map_lookup_elem = cgroup_storage_lookup_elem,\n\t.map_update_elem = cgroup_storage_update_elem,\n\t.map_delete_elem = cgroup_storage_delete_elem,\n\t.map_check_btf = cgroup_storage_check_btf,\n\t.map_seq_show_elem = cgroup_storage_seq_show_elem,\n\t.map_mem_usage = cgroup_storage_map_usage,\n\t.map_btf_id = &cgroup_storage_map_btf_ids[0],\n};\n\nint bpf_cgroup_storage_assign(struct bpf_prog_aux *aux, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\n\tif (aux->cgroup_storage[stype] &&\n\t    aux->cgroup_storage[stype] != _map)\n\t\treturn -EBUSY;\n\n\taux->cgroup_storage[stype] = _map;\n\treturn 0;\n}\n\nstatic size_t bpf_cgroup_storage_calculate_size(struct bpf_map *map, u32 *pages)\n{\n\tsize_t size;\n\n\tif (cgroup_storage_type(map) == BPF_CGROUP_STORAGE_SHARED) {\n\t\tsize = sizeof(struct bpf_storage_buffer) + map->value_size;\n\t\t*pages = round_up(sizeof(struct bpf_cgroup_storage) + size,\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t} else {\n\t\tsize = map->value_size;\n\t\t*pages = round_up(round_up(size, 8) * num_possible_cpus(),\n\t\t\t\t  PAGE_SIZE) >> PAGE_SHIFT;\n\t}\n\n\treturn size;\n}\n\nstruct bpf_cgroup_storage *bpf_cgroup_storage_alloc(struct bpf_prog *prog,\n\t\t\t\t\tenum bpf_cgroup_storage_type stype)\n{\n\tconst gfp_t gfp = __GFP_ZERO | GFP_USER;\n\tstruct bpf_cgroup_storage *storage;\n\tstruct bpf_map *map;\n\tsize_t size;\n\tu32 pages;\n\n\tmap = prog->aux->cgroup_storage[stype];\n\tif (!map)\n\t\treturn NULL;\n\n\tsize = bpf_cgroup_storage_calculate_size(map, &pages);\n\n\tstorage = bpf_map_kmalloc_node(map, sizeof(struct bpf_cgroup_storage),\n\t\t\t\t       gfp, map->numa_node);\n\tif (!storage)\n\t\tgoto enomem;\n\n\tif (stype == BPF_CGROUP_STORAGE_SHARED) {\n\t\tstorage->buf = bpf_map_kmalloc_node(map, size, gfp,\n\t\t\t\t\t\t    map->numa_node);\n\t\tif (!storage->buf)\n\t\t\tgoto enomem;\n\t\tcheck_and_init_map_value(map, storage->buf->data);\n\t} else {\n\t\tstorage->percpu_buf = bpf_map_alloc_percpu(map, size, 8, gfp);\n\t\tif (!storage->percpu_buf)\n\t\t\tgoto enomem;\n\t}\n\n\tstorage->map = (struct bpf_cgroup_storage_map *)map;\n\n\treturn storage;\n\nenomem:\n\tkfree(storage);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void free_shared_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tkfree(storage->buf);\n\tkfree(storage);\n}\n\nstatic void free_percpu_cgroup_storage_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_cgroup_storage *storage =\n\t\tcontainer_of(rcu, struct bpf_cgroup_storage, rcu);\n\n\tfree_percpu(storage->percpu_buf);\n\tkfree(storage);\n}\n\nvoid bpf_cgroup_storage_free(struct bpf_cgroup_storage *storage)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tstruct bpf_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = &storage->map->map;\n\tstype = cgroup_storage_type(map);\n\tif (stype == BPF_CGROUP_STORAGE_SHARED)\n\t\tcall_rcu(&storage->rcu, free_shared_cgroup_storage_rcu);\n\telse\n\t\tcall_rcu(&storage->rcu, free_percpu_cgroup_storage_rcu);\n}\n\nvoid bpf_cgroup_storage_link(struct bpf_cgroup_storage *storage,\n\t\t\t     struct cgroup *cgroup,\n\t\t\t     enum bpf_attach_type type)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\n\tif (!storage)\n\t\treturn;\n\n\tstorage->key.attach_type = type;\n\tstorage->key.cgroup_inode_id = cgroup_id(cgroup);\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\tWARN_ON(cgroup_storage_insert(map, storage));\n\tlist_add(&storage->list_map, &map->list);\n\tlist_add(&storage->list_cg, &cgroup->bpf.storages);\n\tspin_unlock_bh(&map->lock);\n}\n\nvoid bpf_cgroup_storage_unlink(struct bpf_cgroup_storage *storage)\n{\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct rb_root *root;\n\n\tif (!storage)\n\t\treturn;\n\n\tmap = storage->map;\n\n\tspin_lock_bh(&map->lock);\n\troot = &map->root;\n\trb_erase(&storage->node, root);\n\n\tlist_del(&storage->list_map);\n\tlist_del(&storage->list_cg);\n\tspin_unlock_bh(&map->lock);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}