{
  "module_name": "ringbuf.c",
  "hash_id": "addb6a7a7155086b1b136aa72bd0bc04e4da8ba13d6649a5fb3d02c4410065fa",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/ringbuf.c",
  "human_readable_source": "#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/err.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/kmemleak.h>\n#include <uapi/linux/btf.h>\n#include <linux/btf_ids.h>\n\n#define RINGBUF_CREATE_FLAG_MASK (BPF_F_NUMA_NODE)\n\n \n#define RINGBUF_PGOFF \\\n\t(offsetof(struct bpf_ringbuf, consumer_pos) >> PAGE_SHIFT)\n \n#define RINGBUF_POS_PAGES 2\n#define RINGBUF_NR_META_PAGES (RINGBUF_PGOFF + RINGBUF_POS_PAGES)\n\n#define RINGBUF_MAX_RECORD_SZ (UINT_MAX/4)\n\nstruct bpf_ringbuf {\n\twait_queue_head_t waitq;\n\tstruct irq_work work;\n\tu64 mask;\n\tstruct page **pages;\n\tint nr_pages;\n\tspinlock_t spinlock ____cacheline_aligned_in_smp;\n\t \n\tatomic_t busy ____cacheline_aligned_in_smp;\n\t \n\tunsigned long consumer_pos __aligned(PAGE_SIZE);\n\tunsigned long producer_pos __aligned(PAGE_SIZE);\n\tchar data[] __aligned(PAGE_SIZE);\n};\n\nstruct bpf_ringbuf_map {\n\tstruct bpf_map map;\n\tstruct bpf_ringbuf *rb;\n};\n\n \nstruct bpf_ringbuf_hdr {\n\tu32 len;\n\tu32 pg_off;\n};\n\nstatic struct bpf_ringbuf *bpf_ringbuf_area_alloc(size_t data_sz, int numa_node)\n{\n\tconst gfp_t flags = GFP_KERNEL_ACCOUNT | __GFP_RETRY_MAYFAIL |\n\t\t\t    __GFP_NOWARN | __GFP_ZERO;\n\tint nr_meta_pages = RINGBUF_NR_META_PAGES;\n\tint nr_data_pages = data_sz >> PAGE_SHIFT;\n\tint nr_pages = nr_meta_pages + nr_data_pages;\n\tstruct page **pages, *page;\n\tstruct bpf_ringbuf *rb;\n\tsize_t array_size;\n\tint i;\n\n\t \n\tarray_size = (nr_meta_pages + 2 * nr_data_pages) * sizeof(*pages);\n\tpages = bpf_map_area_alloc(array_size, numa_node);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = alloc_pages_node(numa_node, flags, 0);\n\t\tif (!page) {\n\t\t\tnr_pages = i;\n\t\t\tgoto err_free_pages;\n\t\t}\n\t\tpages[i] = page;\n\t\tif (i >= nr_meta_pages)\n\t\t\tpages[nr_data_pages + i] = page;\n\t}\n\n\trb = vmap(pages, nr_meta_pages + 2 * nr_data_pages,\n\t\t  VM_MAP | VM_USERMAP, PAGE_KERNEL);\n\tif (rb) {\n\t\tkmemleak_not_leak(pages);\n\t\trb->pages = pages;\n\t\trb->nr_pages = nr_pages;\n\t\treturn rb;\n\t}\n\nerr_free_pages:\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tbpf_map_area_free(pages);\n\treturn NULL;\n}\n\nstatic void bpf_ringbuf_notify(struct irq_work *work)\n{\n\tstruct bpf_ringbuf *rb = container_of(work, struct bpf_ringbuf, work);\n\n\twake_up_all(&rb->waitq);\n}\n\n \nstatic struct bpf_ringbuf *bpf_ringbuf_alloc(size_t data_sz, int numa_node)\n{\n\tstruct bpf_ringbuf *rb;\n\n\trb = bpf_ringbuf_area_alloc(data_sz, numa_node);\n\tif (!rb)\n\t\treturn NULL;\n\n\tspin_lock_init(&rb->spinlock);\n\tatomic_set(&rb->busy, 0);\n\tinit_waitqueue_head(&rb->waitq);\n\tinit_irq_work(&rb->work, bpf_ringbuf_notify);\n\n\trb->mask = data_sz - 1;\n\trb->consumer_pos = 0;\n\trb->producer_pos = 0;\n\n\treturn rb;\n}\n\nstatic struct bpf_map *ringbuf_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\tif (attr->map_flags & ~RINGBUF_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attr->key_size || attr->value_size ||\n\t    !is_power_of_2(attr->max_entries) ||\n\t    !PAGE_ALIGNED(attr->max_entries))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trb_map = bpf_map_area_alloc(sizeof(*rb_map), NUMA_NO_NODE);\n\tif (!rb_map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&rb_map->map, attr);\n\n\trb_map->rb = bpf_ringbuf_alloc(attr->max_entries, rb_map->map.numa_node);\n\tif (!rb_map->rb) {\n\t\tbpf_map_area_free(rb_map);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &rb_map->map;\n}\n\nstatic void bpf_ringbuf_free(struct bpf_ringbuf *rb)\n{\n\t \n\tstruct page **pages = rb->pages;\n\tint i, nr_pages = rb->nr_pages;\n\n\tvunmap(rb);\n\tfor (i = 0; i < nr_pages; i++)\n\t\t__free_page(pages[i]);\n\tbpf_map_area_free(pages);\n}\n\nstatic void ringbuf_map_free(struct bpf_map *map)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tbpf_ringbuf_free(rb_map->rb);\n\tbpf_map_area_free(rb_map);\n}\n\nstatic void *ringbuf_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-ENOTSUPP);\n}\n\nstatic long ringbuf_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t    u64 flags)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic long ringbuf_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int ringbuf_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t    void *next_key)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int ringbuf_map_mmap_kern(struct bpf_map *map, struct vm_area_struct *vma)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\n\tif (vma->vm_flags & VM_WRITE) {\n\t\t \n\t\tif (vma->vm_pgoff != 0 || vma->vm_end - vma->vm_start != PAGE_SIZE)\n\t\t\treturn -EPERM;\n\t} else {\n\t\tvm_flags_clear(vma, VM_MAYWRITE);\n\t}\n\t \n\treturn remap_vmalloc_range(vma, rb_map->rb,\n\t\t\t\t   vma->vm_pgoff + RINGBUF_PGOFF);\n}\n\nstatic int ringbuf_map_mmap_user(struct bpf_map *map, struct vm_area_struct *vma)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\n\tif (vma->vm_flags & VM_WRITE) {\n\t\tif (vma->vm_pgoff == 0)\n\t\t\t \n\t\t\treturn -EPERM;\n\t} else {\n\t\tvm_flags_clear(vma, VM_MAYWRITE);\n\t}\n\t \n\treturn remap_vmalloc_range(vma, rb_map->rb, vma->vm_pgoff + RINGBUF_PGOFF);\n}\n\nstatic unsigned long ringbuf_avail_data_sz(struct bpf_ringbuf *rb)\n{\n\tunsigned long cons_pos, prod_pos;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tprod_pos = smp_load_acquire(&rb->producer_pos);\n\treturn prod_pos - cons_pos;\n}\n\nstatic u32 ringbuf_total_data_sz(const struct bpf_ringbuf *rb)\n{\n\treturn rb->mask + 1;\n}\n\nstatic __poll_t ringbuf_map_poll_kern(struct bpf_map *map, struct file *filp,\n\t\t\t\t      struct poll_table_struct *pts)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tpoll_wait(filp, &rb_map->rb->waitq, pts);\n\n\tif (ringbuf_avail_data_sz(rb_map->rb))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic __poll_t ringbuf_map_poll_user(struct bpf_map *map, struct file *filp,\n\t\t\t\t      struct poll_table_struct *pts)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\tpoll_wait(filp, &rb_map->rb->waitq, pts);\n\n\tif (ringbuf_avail_data_sz(rb_map->rb) < ringbuf_total_data_sz(rb_map->rb))\n\t\treturn EPOLLOUT | EPOLLWRNORM;\n\treturn 0;\n}\n\nstatic u64 ringbuf_map_mem_usage(const struct bpf_map *map)\n{\n\tstruct bpf_ringbuf *rb;\n\tint nr_data_pages;\n\tint nr_meta_pages;\n\tu64 usage = sizeof(struct bpf_ringbuf_map);\n\n\trb = container_of(map, struct bpf_ringbuf_map, map)->rb;\n\tusage += (u64)rb->nr_pages << PAGE_SHIFT;\n\tnr_meta_pages = RINGBUF_NR_META_PAGES;\n\tnr_data_pages = map->max_entries >> PAGE_SHIFT;\n\tusage += (nr_meta_pages + 2 * nr_data_pages) * sizeof(struct page *);\n\treturn usage;\n}\n\nBTF_ID_LIST_SINGLE(ringbuf_map_btf_ids, struct, bpf_ringbuf_map)\nconst struct bpf_map_ops ringbuf_map_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = ringbuf_map_alloc,\n\t.map_free = ringbuf_map_free,\n\t.map_mmap = ringbuf_map_mmap_kern,\n\t.map_poll = ringbuf_map_poll_kern,\n\t.map_lookup_elem = ringbuf_map_lookup_elem,\n\t.map_update_elem = ringbuf_map_update_elem,\n\t.map_delete_elem = ringbuf_map_delete_elem,\n\t.map_get_next_key = ringbuf_map_get_next_key,\n\t.map_mem_usage = ringbuf_map_mem_usage,\n\t.map_btf_id = &ringbuf_map_btf_ids[0],\n};\n\nBTF_ID_LIST_SINGLE(user_ringbuf_map_btf_ids, struct, bpf_ringbuf_map)\nconst struct bpf_map_ops user_ringbuf_map_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = ringbuf_map_alloc,\n\t.map_free = ringbuf_map_free,\n\t.map_mmap = ringbuf_map_mmap_user,\n\t.map_poll = ringbuf_map_poll_user,\n\t.map_lookup_elem = ringbuf_map_lookup_elem,\n\t.map_update_elem = ringbuf_map_update_elem,\n\t.map_delete_elem = ringbuf_map_delete_elem,\n\t.map_get_next_key = ringbuf_map_get_next_key,\n\t.map_mem_usage = ringbuf_map_mem_usage,\n\t.map_btf_id = &user_ringbuf_map_btf_ids[0],\n};\n\n \nstatic size_t bpf_ringbuf_rec_pg_off(struct bpf_ringbuf *rb,\n\t\t\t\t     struct bpf_ringbuf_hdr *hdr)\n{\n\treturn ((void *)hdr - (void *)rb) >> PAGE_SHIFT;\n}\n\n \nstatic struct bpf_ringbuf *\nbpf_ringbuf_restore_from_rec(struct bpf_ringbuf_hdr *hdr)\n{\n\tunsigned long addr = (unsigned long)(void *)hdr;\n\tunsigned long off = (unsigned long)hdr->pg_off << PAGE_SHIFT;\n\n\treturn (void*)((addr & PAGE_MASK) - off);\n}\n\nstatic void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tif (len > ringbuf_total_data_sz(rb))\n\t\treturn NULL;\n\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\n\t \n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\n\t \n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}\n\nBPF_CALL_3(bpf_ringbuf_reserve, struct bpf_map *, map, u64, size, u64, flags)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\n\tif (unlikely(flags))\n\t\treturn 0;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\treturn (unsigned long)__bpf_ringbuf_reserve(rb_map->rb, size);\n}\n\nconst struct bpf_func_proto bpf_ringbuf_reserve_proto = {\n\t.func\t\t= bpf_ringbuf_reserve,\n\t.ret_type\t= RET_PTR_TO_RINGBUF_MEM_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_CONST_ALLOC_SIZE_OR_ZERO,\n\t.arg3_type\t= ARG_ANYTHING,\n};\n\nstatic void bpf_ringbuf_commit(void *sample, u64 flags, bool discard)\n{\n\tunsigned long rec_pos, cons_pos;\n\tstruct bpf_ringbuf_hdr *hdr;\n\tstruct bpf_ringbuf *rb;\n\tu32 new_len;\n\n\thdr = sample - BPF_RINGBUF_HDR_SZ;\n\trb = bpf_ringbuf_restore_from_rec(hdr);\n\tnew_len = hdr->len ^ BPF_RINGBUF_BUSY_BIT;\n\tif (discard)\n\t\tnew_len |= BPF_RINGBUF_DISCARD_BIT;\n\n\t \n\txchg(&hdr->len, new_len);\n\n\t \n\trec_pos = (void *)hdr - (void *)rb->data;\n\tcons_pos = smp_load_acquire(&rb->consumer_pos) & rb->mask;\n\n\tif (flags & BPF_RB_FORCE_WAKEUP)\n\t\tirq_work_queue(&rb->work);\n\telse if (cons_pos == rec_pos && !(flags & BPF_RB_NO_WAKEUP))\n\t\tirq_work_queue(&rb->work);\n}\n\nBPF_CALL_2(bpf_ringbuf_submit, void *, sample, u64, flags)\n{\n\tbpf_ringbuf_commit(sample, flags, false  );\n\treturn 0;\n}\n\nconst struct bpf_func_proto bpf_ringbuf_submit_proto = {\n\t.func\t\t= bpf_ringbuf_submit,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_RINGBUF_MEM | OBJ_RELEASE,\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_2(bpf_ringbuf_discard, void *, sample, u64, flags)\n{\n\tbpf_ringbuf_commit(sample, flags, true  );\n\treturn 0;\n}\n\nconst struct bpf_func_proto bpf_ringbuf_discard_proto = {\n\t.func\t\t= bpf_ringbuf_discard,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_RINGBUF_MEM | OBJ_RELEASE,\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_4(bpf_ringbuf_output, struct bpf_map *, map, void *, data, u64, size,\n\t   u64, flags)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\tvoid *rec;\n\n\tif (unlikely(flags & ~(BPF_RB_NO_WAKEUP | BPF_RB_FORCE_WAKEUP)))\n\t\treturn -EINVAL;\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\trec = __bpf_ringbuf_reserve(rb_map->rb, size);\n\tif (!rec)\n\t\treturn -EAGAIN;\n\n\tmemcpy(rec, data, size);\n\tbpf_ringbuf_commit(rec, flags, false  );\n\treturn 0;\n}\n\nconst struct bpf_func_proto bpf_ringbuf_output_proto = {\n\t.func\t\t= bpf_ringbuf_output,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_MEM | MEM_RDONLY,\n\t.arg3_type\t= ARG_CONST_SIZE_OR_ZERO,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_2(bpf_ringbuf_query, struct bpf_map *, map, u64, flags)\n{\n\tstruct bpf_ringbuf *rb;\n\n\trb = container_of(map, struct bpf_ringbuf_map, map)->rb;\n\n\tswitch (flags) {\n\tcase BPF_RB_AVAIL_DATA:\n\t\treturn ringbuf_avail_data_sz(rb);\n\tcase BPF_RB_RING_SIZE:\n\t\treturn ringbuf_total_data_sz(rb);\n\tcase BPF_RB_CONS_POS:\n\t\treturn smp_load_acquire(&rb->consumer_pos);\n\tcase BPF_RB_PROD_POS:\n\t\treturn smp_load_acquire(&rb->producer_pos);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nconst struct bpf_func_proto bpf_ringbuf_query_proto = {\n\t.func\t\t= bpf_ringbuf_query,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_4(bpf_ringbuf_reserve_dynptr, struct bpf_map *, map, u32, size, u64, flags,\n\t   struct bpf_dynptr_kern *, ptr)\n{\n\tstruct bpf_ringbuf_map *rb_map;\n\tvoid *sample;\n\tint err;\n\n\tif (unlikely(flags)) {\n\t\tbpf_dynptr_set_null(ptr);\n\t\treturn -EINVAL;\n\t}\n\n\terr = bpf_dynptr_check_size(size);\n\tif (err) {\n\t\tbpf_dynptr_set_null(ptr);\n\t\treturn err;\n\t}\n\n\trb_map = container_of(map, struct bpf_ringbuf_map, map);\n\n\tsample = __bpf_ringbuf_reserve(rb_map->rb, size);\n\tif (!sample) {\n\t\tbpf_dynptr_set_null(ptr);\n\t\treturn -EINVAL;\n\t}\n\n\tbpf_dynptr_init(ptr, sample, BPF_DYNPTR_TYPE_RINGBUF, 0, size);\n\n\treturn 0;\n}\n\nconst struct bpf_func_proto bpf_ringbuf_reserve_dynptr_proto = {\n\t.func\t\t= bpf_ringbuf_reserve_dynptr,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_ANYTHING,\n\t.arg3_type\t= ARG_ANYTHING,\n\t.arg4_type\t= ARG_PTR_TO_DYNPTR | DYNPTR_TYPE_RINGBUF | MEM_UNINIT,\n};\n\nBPF_CALL_2(bpf_ringbuf_submit_dynptr, struct bpf_dynptr_kern *, ptr, u64, flags)\n{\n\tif (!ptr->data)\n\t\treturn 0;\n\n\tbpf_ringbuf_commit(ptr->data, flags, false  );\n\n\tbpf_dynptr_set_null(ptr);\n\n\treturn 0;\n}\n\nconst struct bpf_func_proto bpf_ringbuf_submit_dynptr_proto = {\n\t.func\t\t= bpf_ringbuf_submit_dynptr,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_DYNPTR | DYNPTR_TYPE_RINGBUF | OBJ_RELEASE,\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_2(bpf_ringbuf_discard_dynptr, struct bpf_dynptr_kern *, ptr, u64, flags)\n{\n\tif (!ptr->data)\n\t\treturn 0;\n\n\tbpf_ringbuf_commit(ptr->data, flags, true  );\n\n\tbpf_dynptr_set_null(ptr);\n\n\treturn 0;\n}\n\nconst struct bpf_func_proto bpf_ringbuf_discard_dynptr_proto = {\n\t.func\t\t= bpf_ringbuf_discard_dynptr,\n\t.ret_type\t= RET_VOID,\n\t.arg1_type\t= ARG_PTR_TO_DYNPTR | DYNPTR_TYPE_RINGBUF | OBJ_RELEASE,\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nstatic int __bpf_user_ringbuf_peek(struct bpf_ringbuf *rb, void **sample, u32 *size)\n{\n\tint err;\n\tu32 hdr_len, sample_len, total_len, flags, *hdr;\n\tu64 cons_pos, prod_pos;\n\n\t \n\tprod_pos = smp_load_acquire(&rb->producer_pos);\n\tif (prod_pos % 8)\n\t\treturn -EINVAL;\n\n\t \n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tif (cons_pos >= prod_pos)\n\t\treturn -ENODATA;\n\n\thdr = (u32 *)((uintptr_t)rb->data + (uintptr_t)(cons_pos & rb->mask));\n\t \n\thdr_len = smp_load_acquire(hdr);\n\tflags = hdr_len & (BPF_RINGBUF_BUSY_BIT | BPF_RINGBUF_DISCARD_BIT);\n\tsample_len = hdr_len & ~flags;\n\ttotal_len = round_up(sample_len + BPF_RINGBUF_HDR_SZ, 8);\n\n\t \n\tif (total_len > prod_pos - cons_pos)\n\t\treturn -EINVAL;\n\n\t \n\tif (total_len > ringbuf_total_data_sz(rb))\n\t\treturn -E2BIG;\n\n\t \n\terr = bpf_dynptr_check_size(sample_len);\n\tif (err)\n\t\treturn -E2BIG;\n\n\tif (flags & BPF_RINGBUF_DISCARD_BIT) {\n\t\t \n\t\tsmp_store_release(&rb->consumer_pos, cons_pos + total_len);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (flags & BPF_RINGBUF_BUSY_BIT)\n\t\treturn -ENODATA;\n\n\t*sample = (void *)((uintptr_t)rb->data +\n\t\t\t   (uintptr_t)((cons_pos + BPF_RINGBUF_HDR_SZ) & rb->mask));\n\t*size = sample_len;\n\treturn 0;\n}\n\nstatic void __bpf_user_ringbuf_sample_release(struct bpf_ringbuf *rb, size_t size, u64 flags)\n{\n\tu64 consumer_pos;\n\tu32 rounded_size = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\n\t \n\tconsumer_pos = rb->consumer_pos;\n\t  \n\tsmp_store_release(&rb->consumer_pos, consumer_pos + rounded_size);\n}\n\nBPF_CALL_4(bpf_user_ringbuf_drain, struct bpf_map *, map,\n\t   void *, callback_fn, void *, callback_ctx, u64, flags)\n{\n\tstruct bpf_ringbuf *rb;\n\tlong samples, discarded_samples = 0, ret = 0;\n\tbpf_callback_t callback = (bpf_callback_t)callback_fn;\n\tu64 wakeup_flags = BPF_RB_NO_WAKEUP | BPF_RB_FORCE_WAKEUP;\n\tint busy = 0;\n\n\tif (unlikely(flags & ~wakeup_flags))\n\t\treturn -EINVAL;\n\n\trb = container_of(map, struct bpf_ringbuf_map, map)->rb;\n\n\t \n\tif (!atomic_try_cmpxchg(&rb->busy, &busy, 1))\n\t\treturn -EBUSY;\n\n\tfor (samples = 0; samples < BPF_MAX_USER_RINGBUF_SAMPLES && ret == 0; samples++) {\n\t\tint err;\n\t\tu32 size;\n\t\tvoid *sample;\n\t\tstruct bpf_dynptr_kern dynptr;\n\n\t\terr = __bpf_user_ringbuf_peek(rb, &sample, &size);\n\t\tif (err) {\n\t\t\tif (err == -ENODATA) {\n\t\t\t\tbreak;\n\t\t\t} else if (err == -EAGAIN) {\n\t\t\t\tdiscarded_samples++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tret = err;\n\t\t\t\tgoto schedule_work_return;\n\t\t\t}\n\t\t}\n\n\t\tbpf_dynptr_init(&dynptr, sample, BPF_DYNPTR_TYPE_LOCAL, 0, size);\n\t\tret = callback((uintptr_t)&dynptr, (uintptr_t)callback_ctx, 0, 0, 0);\n\t\t__bpf_user_ringbuf_sample_release(rb, size, flags);\n\t}\n\tret = samples - discarded_samples;\n\nschedule_work_return:\n\t \n\tsmp_mb__before_atomic();\n\tatomic_set(&rb->busy, 0);\n\n\tif (flags & BPF_RB_FORCE_WAKEUP)\n\t\tirq_work_queue(&rb->work);\n\telse if (!(flags & BPF_RB_NO_WAKEUP) && samples > 0)\n\t\tirq_work_queue(&rb->work);\n\treturn ret;\n}\n\nconst struct bpf_func_proto bpf_user_ringbuf_drain_proto = {\n\t.func\t\t= bpf_user_ringbuf_drain,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n\t.arg3_type\t= ARG_PTR_TO_STACK_OR_NULL,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}