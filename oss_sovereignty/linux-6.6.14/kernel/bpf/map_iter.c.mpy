{
  "module_name": "map_iter.c",
  "hash_id": "46dde99db7ab98c9d29d529185afcd6192ea36b62b7826d62ed88fb7a0439887",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/map_iter.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kernel.h>\n#include <linux/btf_ids.h>\n\nstruct bpf_iter_seq_map_info {\n\tu32 map_id;\n};\n\nstatic void *bpf_map_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_map_info *info = seq->private;\n\tstruct bpf_map *map;\n\n\tmap = bpf_map_get_curr_or_next(&info->map_id);\n\tif (!map)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\t++*pos;\n\treturn map;\n}\n\nstatic void *bpf_map_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_map_info *info = seq->private;\n\n\t++*pos;\n\t++info->map_id;\n\tbpf_map_put((struct bpf_map *)v);\n\treturn bpf_map_get_curr_or_next(&info->map_id);\n}\n\nstruct bpf_iter__bpf_map {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct bpf_map *, map);\n};\n\nDEFINE_BPF_ITER_FUNC(bpf_map, struct bpf_iter_meta *meta, struct bpf_map *map)\n\nstatic int __bpf_map_seq_show(struct seq_file *seq, void *v, bool in_stop)\n{\n\tstruct bpf_iter__bpf_map ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint ret = 0;\n\n\tctx.meta = &meta;\n\tctx.map = v;\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (prog)\n\t\tret = bpf_iter_run_prog(prog, &ctx);\n\n\treturn ret;\n}\n\nstatic int bpf_map_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __bpf_map_seq_show(seq, v, false);\n}\n\nstatic void bpf_map_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!v)\n\t\t(void)__bpf_map_seq_show(seq, v, true);\n\telse\n\t\tbpf_map_put((struct bpf_map *)v);\n}\n\nstatic const struct seq_operations bpf_map_seq_ops = {\n\t.start\t= bpf_map_seq_start,\n\t.next\t= bpf_map_seq_next,\n\t.stop\t= bpf_map_seq_stop,\n\t.show\t= bpf_map_seq_show,\n};\n\nBTF_ID_LIST_GLOBAL_SINGLE(btf_bpf_map_id, struct, bpf_map)\n\nstatic const struct bpf_iter_seq_info bpf_map_seq_info = {\n\t.seq_ops\t\t= &bpf_map_seq_ops,\n\t.init_seq_private\t= NULL,\n\t.fini_seq_private\t= NULL,\n\t.seq_priv_size\t\t= sizeof(struct bpf_iter_seq_map_info),\n};\n\nstatic struct bpf_iter_reg bpf_map_reg_info = {\n\t.target\t\t\t= \"bpf_map\",\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__bpf_map, map),\n\t\t  PTR_TO_BTF_ID_OR_NULL | PTR_TRUSTED },\n\t},\n\t.seq_info\t\t= &bpf_map_seq_info,\n};\n\nstatic int bpf_iter_attach_map(struct bpf_prog *prog,\n\t\t\t       union bpf_iter_link_info *linfo,\n\t\t\t       struct bpf_iter_aux_info *aux)\n{\n\tu32 key_acc_size, value_acc_size, key_size, value_size;\n\tstruct bpf_map *map;\n\tbool is_percpu = false;\n\tint err = -EINVAL;\n\n\tif (!linfo->map.map_fd)\n\t\treturn -EBADF;\n\n\tmap = bpf_map_get_with_uref(linfo->map.map_fd);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY)\n\t\tis_percpu = true;\n\telse if (map->map_type != BPF_MAP_TYPE_HASH &&\n\t\t map->map_type != BPF_MAP_TYPE_LRU_HASH &&\n\t\t map->map_type != BPF_MAP_TYPE_ARRAY)\n\t\tgoto put_map;\n\n\tkey_acc_size = prog->aux->max_rdonly_access;\n\tvalue_acc_size = prog->aux->max_rdwr_access;\n\tkey_size = map->key_size;\n\tif (!is_percpu)\n\t\tvalue_size = map->value_size;\n\telse\n\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();\n\n\tif (key_acc_size > key_size || value_acc_size > value_size) {\n\t\terr = -EACCES;\n\t\tgoto put_map;\n\t}\n\n\taux->map = map;\n\treturn 0;\n\nput_map:\n\tbpf_map_put_with_uref(map);\n\treturn err;\n}\n\nstatic void bpf_iter_detach_map(struct bpf_iter_aux_info *aux)\n{\n\tbpf_map_put_with_uref(aux->map);\n}\n\nvoid bpf_iter_map_show_fdinfo(const struct bpf_iter_aux_info *aux,\n\t\t\t      struct seq_file *seq)\n{\n\tseq_printf(seq, \"map_id:\\t%u\\n\", aux->map->id);\n}\n\nint bpf_iter_map_fill_link_info(const struct bpf_iter_aux_info *aux,\n\t\t\t\tstruct bpf_link_info *info)\n{\n\tinfo->iter.map.map_id = aux->map->id;\n\treturn 0;\n}\n\nDEFINE_BPF_ITER_FUNC(bpf_map_elem, struct bpf_iter_meta *meta,\n\t\t     struct bpf_map *map, void *key, void *value)\n\nstatic const struct bpf_iter_reg bpf_map_elem_reg_info = {\n\t.target\t\t\t= \"bpf_map_elem\",\n\t.attach_target\t\t= bpf_iter_attach_map,\n\t.detach_target\t\t= bpf_iter_detach_map,\n\t.show_fdinfo\t\t= bpf_iter_map_show_fdinfo,\n\t.fill_link_info\t\t= bpf_iter_map_fill_link_info,\n\t.ctx_arg_info_size\t= 2,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__bpf_map_elem, key),\n\t\t  PTR_TO_BUF | PTR_MAYBE_NULL | MEM_RDONLY },\n\t\t{ offsetof(struct bpf_iter__bpf_map_elem, value),\n\t\t  PTR_TO_BUF | PTR_MAYBE_NULL },\n\t},\n};\n\nstatic int __init bpf_map_iter_init(void)\n{\n\tint ret;\n\n\tbpf_map_reg_info.ctx_arg_info[0].btf_id = *btf_bpf_map_id;\n\tret = bpf_iter_reg_target(&bpf_map_reg_info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bpf_iter_reg_target(&bpf_map_elem_reg_info);\n}\n\nlate_initcall(bpf_map_iter_init);\n\n__diag_push();\n__diag_ignore_all(\"-Wmissing-prototypes\",\n\t\t  \"Global functions as their definitions will be in vmlinux BTF\");\n\n__bpf_kfunc s64 bpf_map_sum_elem_count(const struct bpf_map *map)\n{\n\ts64 *pcount;\n\ts64 ret = 0;\n\tint cpu;\n\n\tif (!map || !map->elem_count)\n\t\treturn 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpcount = per_cpu_ptr(map->elem_count, cpu);\n\t\tret += READ_ONCE(*pcount);\n\t}\n\treturn ret;\n}\n\n__diag_pop();\n\nBTF_SET8_START(bpf_map_iter_kfunc_ids)\nBTF_ID_FLAGS(func, bpf_map_sum_elem_count, KF_TRUSTED_ARGS)\nBTF_SET8_END(bpf_map_iter_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set bpf_map_iter_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &bpf_map_iter_kfunc_ids,\n};\n\nstatic int init_subsystem(void)\n{\n\treturn register_btf_kfunc_id_set(BPF_PROG_TYPE_UNSPEC, &bpf_map_iter_kfunc_set);\n}\nlate_initcall(init_subsystem);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}