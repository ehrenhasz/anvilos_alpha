{
  "module_name": "cgroup_iter.c",
  "hash_id": "240d880dc339f4769e049d3c76f305dd5599eeae79478a0849a618fc5c602b44",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/cgroup_iter.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <linux/btf_ids.h>\n#include <linux/cgroup.h>\n#include <linux/kernel.h>\n#include <linux/seq_file.h>\n\n#include \"../cgroup/cgroup-internal.h\"   \n\n \n\nstruct bpf_iter__cgroup {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct cgroup *, cgroup);\n};\n\nstruct cgroup_iter_priv {\n\tstruct cgroup_subsys_state *start_css;\n\tbool visited_all;\n\tbool terminate;\n\tint order;\n};\n\nstatic void *cgroup_iter_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct cgroup_iter_priv *p = seq->private;\n\n\tcgroup_lock();\n\n\t \n\tif (*pos > 0) {\n\t\tif (p->visited_all)\n\t\t\treturn NULL;\n\n\t\t \n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\t++*pos;\n\tp->terminate = false;\n\tp->visited_all = false;\n\tif (p->order == BPF_CGROUP_ITER_DESCENDANTS_PRE)\n\t\treturn css_next_descendant_pre(NULL, p->start_css);\n\telse if (p->order == BPF_CGROUP_ITER_DESCENDANTS_POST)\n\t\treturn css_next_descendant_post(NULL, p->start_css);\n\telse  \n\t\treturn p->start_css;\n}\n\nstatic int __cgroup_iter_seq_show(struct seq_file *seq,\n\t\t\t\t  struct cgroup_subsys_state *css, int in_stop);\n\nstatic void cgroup_iter_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct cgroup_iter_priv *p = seq->private;\n\n\tcgroup_unlock();\n\n\t \n\tif (!v) {\n\t\t__cgroup_iter_seq_show(seq, NULL, true);\n\t\tp->visited_all = true;\n\t}\n}\n\nstatic void *cgroup_iter_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct cgroup_subsys_state *curr = (struct cgroup_subsys_state *)v;\n\tstruct cgroup_iter_priv *p = seq->private;\n\n\t++*pos;\n\tif (p->terminate)\n\t\treturn NULL;\n\n\tif (p->order == BPF_CGROUP_ITER_DESCENDANTS_PRE)\n\t\treturn css_next_descendant_pre(curr, p->start_css);\n\telse if (p->order == BPF_CGROUP_ITER_DESCENDANTS_POST)\n\t\treturn css_next_descendant_post(curr, p->start_css);\n\telse if (p->order == BPF_CGROUP_ITER_ANCESTORS_UP)\n\t\treturn curr->parent;\n\telse   \n\t\treturn NULL;\n}\n\nstatic int __cgroup_iter_seq_show(struct seq_file *seq,\n\t\t\t\t  struct cgroup_subsys_state *css, int in_stop)\n{\n\tstruct cgroup_iter_priv *p = seq->private;\n\tstruct bpf_iter__cgroup ctx;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint ret = 0;\n\n\t \n\tif (css && cgroup_is_dead(css->cgroup))\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.cgroup = css ? css->cgroup : NULL;\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, in_stop);\n\tif (prog)\n\t\tret = bpf_iter_run_prog(prog, &ctx);\n\n\t \n\tif (ret != 0)\n\t\tp->terminate = true;\n\n\treturn 0;\n}\n\nstatic int cgroup_iter_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __cgroup_iter_seq_show(seq, (struct cgroup_subsys_state *)v,\n\t\t\t\t      false);\n}\n\nstatic const struct seq_operations cgroup_iter_seq_ops = {\n\t.start  = cgroup_iter_seq_start,\n\t.next   = cgroup_iter_seq_next,\n\t.stop   = cgroup_iter_seq_stop,\n\t.show   = cgroup_iter_seq_show,\n};\n\nBTF_ID_LIST_GLOBAL_SINGLE(bpf_cgroup_btf_id, struct, cgroup)\n\nstatic int cgroup_iter_seq_init(void *priv, struct bpf_iter_aux_info *aux)\n{\n\tstruct cgroup_iter_priv *p = (struct cgroup_iter_priv *)priv;\n\tstruct cgroup *cgrp = aux->cgroup.start;\n\n\t \n\tp->start_css = &cgrp->self;\n\tcss_get(p->start_css);\n\tp->terminate = false;\n\tp->visited_all = false;\n\tp->order = aux->cgroup.order;\n\treturn 0;\n}\n\nstatic void cgroup_iter_seq_fini(void *priv)\n{\n\tstruct cgroup_iter_priv *p = (struct cgroup_iter_priv *)priv;\n\n\tcss_put(p->start_css);\n}\n\nstatic const struct bpf_iter_seq_info cgroup_iter_seq_info = {\n\t.seq_ops\t\t= &cgroup_iter_seq_ops,\n\t.init_seq_private\t= cgroup_iter_seq_init,\n\t.fini_seq_private\t= cgroup_iter_seq_fini,\n\t.seq_priv_size\t\t= sizeof(struct cgroup_iter_priv),\n};\n\nstatic int bpf_iter_attach_cgroup(struct bpf_prog *prog,\n\t\t\t\t  union bpf_iter_link_info *linfo,\n\t\t\t\t  struct bpf_iter_aux_info *aux)\n{\n\tint fd = linfo->cgroup.cgroup_fd;\n\tu64 id = linfo->cgroup.cgroup_id;\n\tint order = linfo->cgroup.order;\n\tstruct cgroup *cgrp;\n\n\tif (order != BPF_CGROUP_ITER_DESCENDANTS_PRE &&\n\t    order != BPF_CGROUP_ITER_DESCENDANTS_POST &&\n\t    order != BPF_CGROUP_ITER_ANCESTORS_UP &&\n\t    order != BPF_CGROUP_ITER_SELF_ONLY)\n\t\treturn -EINVAL;\n\n\tif (fd && id)\n\t\treturn -EINVAL;\n\n\tif (fd)\n\t\tcgrp = cgroup_v1v2_get_from_fd(fd);\n\telse if (id)\n\t\tcgrp = cgroup_get_from_id(id);\n\telse  \n\t\tcgrp = cgroup_get_from_path(\"/\");\n\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\taux->cgroup.start = cgrp;\n\taux->cgroup.order = order;\n\treturn 0;\n}\n\nstatic void bpf_iter_detach_cgroup(struct bpf_iter_aux_info *aux)\n{\n\tcgroup_put(aux->cgroup.start);\n}\n\nstatic void bpf_iter_cgroup_show_fdinfo(const struct bpf_iter_aux_info *aux,\n\t\t\t\t\tstruct seq_file *seq)\n{\n\tchar *buf;\n\n\tbuf = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf) {\n\t\tseq_puts(seq, \"cgroup_path:\\t<unknown>\\n\");\n\t\tgoto show_order;\n\t}\n\n\t \n\tcgroup_path_ns(aux->cgroup.start, buf, PATH_MAX,\n\t\t       current->nsproxy->cgroup_ns);\n\tseq_printf(seq, \"cgroup_path:\\t%s\\n\", buf);\n\tkfree(buf);\n\nshow_order:\n\tif (aux->cgroup.order == BPF_CGROUP_ITER_DESCENDANTS_PRE)\n\t\tseq_puts(seq, \"order: descendants_pre\\n\");\n\telse if (aux->cgroup.order == BPF_CGROUP_ITER_DESCENDANTS_POST)\n\t\tseq_puts(seq, \"order: descendants_post\\n\");\n\telse if (aux->cgroup.order == BPF_CGROUP_ITER_ANCESTORS_UP)\n\t\tseq_puts(seq, \"order: ancestors_up\\n\");\n\telse  \n\t\tseq_puts(seq, \"order: self_only\\n\");\n}\n\nstatic int bpf_iter_cgroup_fill_link_info(const struct bpf_iter_aux_info *aux,\n\t\t\t\t\t  struct bpf_link_info *info)\n{\n\tinfo->iter.cgroup.order = aux->cgroup.order;\n\tinfo->iter.cgroup.cgroup_id = cgroup_id(aux->cgroup.start);\n\treturn 0;\n}\n\nDEFINE_BPF_ITER_FUNC(cgroup, struct bpf_iter_meta *meta,\n\t\t     struct cgroup *cgroup)\n\nstatic struct bpf_iter_reg bpf_cgroup_reg_info = {\n\t.target\t\t\t= \"cgroup\",\n\t.feature\t\t= BPF_ITER_RESCHED,\n\t.attach_target\t\t= bpf_iter_attach_cgroup,\n\t.detach_target\t\t= bpf_iter_detach_cgroup,\n\t.show_fdinfo\t\t= bpf_iter_cgroup_show_fdinfo,\n\t.fill_link_info\t\t= bpf_iter_cgroup_fill_link_info,\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__cgroup, cgroup),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &cgroup_iter_seq_info,\n};\n\nstatic int __init bpf_cgroup_iter_init(void)\n{\n\tbpf_cgroup_reg_info.ctx_arg_info[0].btf_id = bpf_cgroup_btf_id[0];\n\treturn bpf_iter_reg_target(&bpf_cgroup_reg_info);\n}\n\nlate_initcall(bpf_cgroup_iter_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}