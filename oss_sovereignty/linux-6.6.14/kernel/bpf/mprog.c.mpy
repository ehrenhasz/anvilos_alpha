{
  "module_name": "mprog.c",
  "hash_id": "1af75afaf15d944cd3cd3fe77e7c9c085d8b0b681f26008c89237c5bbe6c0fd4",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/mprog.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/bpf_mprog.h>\n\nstatic int bpf_mprog_link(struct bpf_tuple *tuple,\n\t\t\t  u32 id_or_fd, u32 flags,\n\t\t\t  enum bpf_prog_type type)\n{\n\tstruct bpf_link *link = ERR_PTR(-EINVAL);\n\tbool id = flags & BPF_F_ID;\n\n\tif (id)\n\t\tlink = bpf_link_by_id(id_or_fd);\n\telse if (id_or_fd)\n\t\tlink = bpf_link_get_from_fd(id_or_fd);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\tif (type && link->prog->type != type) {\n\t\tbpf_link_put(link);\n\t\treturn -EINVAL;\n\t}\n\n\ttuple->link = link;\n\ttuple->prog = link->prog;\n\treturn 0;\n}\n\nstatic int bpf_mprog_prog(struct bpf_tuple *tuple,\n\t\t\t  u32 id_or_fd, u32 flags,\n\t\t\t  enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog = ERR_PTR(-EINVAL);\n\tbool id = flags & BPF_F_ID;\n\n\tif (id)\n\t\tprog = bpf_prog_by_id(id_or_fd);\n\telse if (id_or_fd)\n\t\tprog = bpf_prog_get(id_or_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\tif (type && prog->type != type) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\ttuple->link = NULL;\n\ttuple->prog = prog;\n\treturn 0;\n}\n\nstatic int bpf_mprog_tuple_relative(struct bpf_tuple *tuple,\n\t\t\t\t    u32 id_or_fd, u32 flags,\n\t\t\t\t    enum bpf_prog_type type)\n{\n\tbool link = flags & BPF_F_LINK;\n\tbool id = flags & BPF_F_ID;\n\n\tmemset(tuple, 0, sizeof(*tuple));\n\tif (link)\n\t\treturn bpf_mprog_link(tuple, id_or_fd, flags, type);\n\t \n\tif (!id && !id_or_fd)\n\t\treturn 0;\n\treturn bpf_mprog_prog(tuple, id_or_fd, flags, type);\n}\n\nstatic void bpf_mprog_tuple_put(struct bpf_tuple *tuple)\n{\n\tif (tuple->link)\n\t\tbpf_link_put(tuple->link);\n\telse if (tuple->prog)\n\t\tbpf_prog_put(tuple->prog);\n}\n\n \nstatic int bpf_mprog_replace(struct bpf_mprog_entry *entry,\n\t\t\t     struct bpf_mprog_entry **entry_new,\n\t\t\t     struct bpf_tuple *ntuple, int idx)\n{\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\tstruct bpf_prog *oprog;\n\n\tbpf_mprog_read(entry, idx, &fp, &cp);\n\toprog = READ_ONCE(fp->prog);\n\tbpf_mprog_write(fp, cp, ntuple);\n\tif (!ntuple->link) {\n\t\tWARN_ON_ONCE(cp->link);\n\t\tbpf_prog_put(oprog);\n\t}\n\t*entry_new = entry;\n\treturn 0;\n}\n\nstatic int bpf_mprog_insert(struct bpf_mprog_entry *entry,\n\t\t\t    struct bpf_mprog_entry **entry_new,\n\t\t\t    struct bpf_tuple *ntuple, int idx, u32 flags)\n{\n\tint total = bpf_mprog_total(entry);\n\tstruct bpf_mprog_entry *peer;\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\n\tpeer = bpf_mprog_peer(entry);\n\tbpf_mprog_entry_copy(peer, entry);\n\tif (idx == total)\n\t\tgoto insert;\n\telse if (flags & BPF_F_BEFORE)\n\t\tidx += 1;\n\tbpf_mprog_entry_grow(peer, idx);\ninsert:\n\tbpf_mprog_read(peer, idx, &fp, &cp);\n\tbpf_mprog_write(fp, cp, ntuple);\n\tbpf_mprog_inc(peer);\n\t*entry_new = peer;\n\treturn 0;\n}\n\nstatic int bpf_mprog_delete(struct bpf_mprog_entry *entry,\n\t\t\t    struct bpf_mprog_entry **entry_new,\n\t\t\t    struct bpf_tuple *dtuple, int idx)\n{\n\tint total = bpf_mprog_total(entry);\n\tstruct bpf_mprog_entry *peer;\n\n\tpeer = bpf_mprog_peer(entry);\n\tbpf_mprog_entry_copy(peer, entry);\n\tif (idx == -1)\n\t\tidx = 0;\n\telse if (idx == total)\n\t\tidx = total - 1;\n\tbpf_mprog_entry_shrink(peer, idx);\n\tbpf_mprog_dec(peer);\n\tbpf_mprog_mark_for_release(peer, dtuple);\n\t*entry_new = peer;\n\treturn 0;\n}\n\n \nstatic int bpf_mprog_pos_exact(struct bpf_mprog_entry *entry,\n\t\t\t       struct bpf_tuple *tuple)\n{\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\tint i;\n\n\tfor (i = 0; i < bpf_mprog_total(entry); i++) {\n\t\tbpf_mprog_read(entry, i, &fp, &cp);\n\t\tif (tuple->prog == READ_ONCE(fp->prog))\n\t\t\treturn tuple->link == cp->link ? i : -EBUSY;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int bpf_mprog_pos_before(struct bpf_mprog_entry *entry,\n\t\t\t\tstruct bpf_tuple *tuple)\n{\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\tint i;\n\n\tfor (i = 0; i < bpf_mprog_total(entry); i++) {\n\t\tbpf_mprog_read(entry, i, &fp, &cp);\n\t\tif (tuple->prog == READ_ONCE(fp->prog) &&\n\t\t    (!tuple->link || tuple->link == cp->link))\n\t\t\treturn i - 1;\n\t}\n\treturn tuple->prog ? -ENOENT : -1;\n}\n\nstatic int bpf_mprog_pos_after(struct bpf_mprog_entry *entry,\n\t\t\t       struct bpf_tuple *tuple)\n{\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\tint i;\n\n\tfor (i = 0; i < bpf_mprog_total(entry); i++) {\n\t\tbpf_mprog_read(entry, i, &fp, &cp);\n\t\tif (tuple->prog == READ_ONCE(fp->prog) &&\n\t\t    (!tuple->link || tuple->link == cp->link))\n\t\t\treturn i + 1;\n\t}\n\treturn tuple->prog ? -ENOENT : bpf_mprog_total(entry);\n}\n\nint bpf_mprog_attach(struct bpf_mprog_entry *entry,\n\t\t     struct bpf_mprog_entry **entry_new,\n\t\t     struct bpf_prog *prog_new, struct bpf_link *link,\n\t\t     struct bpf_prog *prog_old,\n\t\t     u32 flags, u32 id_or_fd, u64 revision)\n{\n\tstruct bpf_tuple rtuple, ntuple = {\n\t\t.prog = prog_new,\n\t\t.link = link,\n\t}, otuple = {\n\t\t.prog = prog_old,\n\t\t.link = link,\n\t};\n\tint ret, idx = -ERANGE, tidx;\n\n\tif (revision && revision != bpf_mprog_revision(entry))\n\t\treturn -ESTALE;\n\tif (bpf_mprog_exists(entry, prog_new))\n\t\treturn -EEXIST;\n\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd,\n\t\t\t\t       flags & ~BPF_F_REPLACE,\n\t\t\t\t       prog_new->type);\n\tif (ret)\n\t\treturn ret;\n\tif (flags & BPF_F_REPLACE) {\n\t\ttidx = bpf_mprog_pos_exact(entry, &otuple);\n\t\tif (tidx < 0) {\n\t\t\tret = tidx;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = tidx;\n\t} else if (bpf_mprog_total(entry) == bpf_mprog_max()) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (flags & BPF_F_BEFORE) {\n\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);\n\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {\n\t\t\tret = tidx < -1 ? tidx : -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = tidx;\n\t}\n\tif (flags & BPF_F_AFTER) {\n\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);\n\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {\n\t\t\tret = tidx < 0 ? tidx : -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = tidx;\n\t}\n\tif (idx < -1) {\n\t\tif (rtuple.prog || flags) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = bpf_mprog_total(entry);\n\t\tflags = BPF_F_AFTER;\n\t}\n\tif (idx >= bpf_mprog_max()) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (flags & BPF_F_REPLACE)\n\t\tret = bpf_mprog_replace(entry, entry_new, &ntuple, idx);\n\telse\n\t\tret = bpf_mprog_insert(entry, entry_new, &ntuple, idx, flags);\nout:\n\tbpf_mprog_tuple_put(&rtuple);\n\treturn ret;\n}\n\nstatic int bpf_mprog_fetch(struct bpf_mprog_entry *entry,\n\t\t\t   struct bpf_tuple *tuple, int idx)\n{\n\tint total = bpf_mprog_total(entry);\n\tstruct bpf_mprog_cp *cp;\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_prog *prog;\n\tstruct bpf_link *link;\n\n\tif (idx == -1)\n\t\tidx = 0;\n\telse if (idx == total)\n\t\tidx = total - 1;\n\tbpf_mprog_read(entry, idx, &fp, &cp);\n\tprog = READ_ONCE(fp->prog);\n\tlink = cp->link;\n\t \n\tif (link && !tuple->link)\n\t\treturn -EBUSY;\n\tWARN_ON_ONCE(tuple->prog && tuple->prog != prog);\n\tWARN_ON_ONCE(tuple->link && tuple->link != link);\n\ttuple->prog = prog;\n\ttuple->link = link;\n\treturn 0;\n}\n\nint bpf_mprog_detach(struct bpf_mprog_entry *entry,\n\t\t     struct bpf_mprog_entry **entry_new,\n\t\t     struct bpf_prog *prog, struct bpf_link *link,\n\t\t     u32 flags, u32 id_or_fd, u64 revision)\n{\n\tstruct bpf_tuple rtuple, dtuple = {\n\t\t.prog = prog,\n\t\t.link = link,\n\t};\n\tint ret, idx = -ERANGE, tidx;\n\n\tif (flags & BPF_F_REPLACE)\n\t\treturn -EINVAL;\n\tif (revision && revision != bpf_mprog_revision(entry))\n\t\treturn -ESTALE;\n\tif (!bpf_mprog_total(entry))\n\t\treturn -ENOENT;\n\tret = bpf_mprog_tuple_relative(&rtuple, id_or_fd, flags,\n\t\t\t\t       prog ? prog->type :\n\t\t\t\t       BPF_PROG_TYPE_UNSPEC);\n\tif (ret)\n\t\treturn ret;\n\tif (dtuple.prog) {\n\t\ttidx = bpf_mprog_pos_exact(entry, &dtuple);\n\t\tif (tidx < 0) {\n\t\t\tret = tidx;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = tidx;\n\t}\n\tif (flags & BPF_F_BEFORE) {\n\t\ttidx = bpf_mprog_pos_before(entry, &rtuple);\n\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {\n\t\t\tret = tidx < -1 ? tidx : -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = tidx;\n\t}\n\tif (flags & BPF_F_AFTER) {\n\t\ttidx = bpf_mprog_pos_after(entry, &rtuple);\n\t\tif (tidx < -1 || (idx >= -1 && tidx != idx)) {\n\t\t\tret = tidx < 0 ? tidx : -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = tidx;\n\t}\n\tif (idx < -1) {\n\t\tif (rtuple.prog || flags) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tidx = bpf_mprog_total(entry);\n\t\tflags = BPF_F_AFTER;\n\t}\n\tif (idx >= bpf_mprog_max()) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tret = bpf_mprog_fetch(entry, &dtuple, idx);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_mprog_delete(entry, entry_new, &dtuple, idx);\nout:\n\tbpf_mprog_tuple_put(&rtuple);\n\treturn ret;\n}\n\nint bpf_mprog_query(const union bpf_attr *attr, union bpf_attr __user *uattr,\n\t\t    struct bpf_mprog_entry *entry)\n{\n\tu32 __user *uprog_flags, *ulink_flags;\n\tu32 __user *uprog_id, *ulink_id;\n\tstruct bpf_mprog_fp *fp;\n\tstruct bpf_mprog_cp *cp;\n\tstruct bpf_prog *prog;\n\tconst u32 flags = 0;\n\tu32 id, count = 0;\n\tu64 revision = 1;\n\tint i, ret = 0;\n\n\tif (attr->query.query_flags || attr->query.attach_flags)\n\t\treturn -EINVAL;\n\tif (entry) {\n\t\trevision = bpf_mprog_revision(entry);\n\t\tcount = bpf_mprog_total(entry);\n\t}\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.revision, &revision, sizeof(revision)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.count, &count, sizeof(count)))\n\t\treturn -EFAULT;\n\tuprog_id = u64_to_user_ptr(attr->query.prog_ids);\n\tuprog_flags = u64_to_user_ptr(attr->query.prog_attach_flags);\n\tulink_id = u64_to_user_ptr(attr->query.link_ids);\n\tulink_flags = u64_to_user_ptr(attr->query.link_attach_flags);\n\tif (attr->query.count == 0 || !uprog_id || !count)\n\t\treturn 0;\n\tif (attr->query.count < count) {\n\t\tcount = attr->query.count;\n\t\tret = -ENOSPC;\n\t}\n\tfor (i = 0; i < bpf_mprog_max(); i++) {\n\t\tbpf_mprog_read(entry, i, &fp, &cp);\n\t\tprog = READ_ONCE(fp->prog);\n\t\tif (!prog)\n\t\t\tbreak;\n\t\tid = prog->aux->id;\n\t\tif (copy_to_user(uprog_id + i, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\tif (uprog_flags &&\n\t\t    copy_to_user(uprog_flags + i, &flags, sizeof(flags)))\n\t\t\treturn -EFAULT;\n\t\tid = cp->link ? cp->link->id : 0;\n\t\tif (ulink_id &&\n\t\t    copy_to_user(ulink_id + i, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\tif (ulink_flags &&\n\t\t    copy_to_user(ulink_flags + i, &flags, sizeof(flags)))\n\t\t\treturn -EFAULT;\n\t\tif (i + 1 == count)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}