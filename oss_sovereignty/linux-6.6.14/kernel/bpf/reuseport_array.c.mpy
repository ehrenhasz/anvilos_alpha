{
  "module_name": "reuseport_array.c",
  "hash_id": "c02948fd51ae4456f9dd45d9cc072d6ad989634bade0ec9b5c6d410eacfa18b7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/reuseport_array.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <linux/err.h>\n#include <linux/sock_diag.h>\n#include <net/sock_reuseport.h>\n#include <linux/btf_ids.h>\n\nstruct reuseport_array {\n\tstruct bpf_map map;\n\tstruct sock __rcu *ptrs[];\n};\n\nstatic struct reuseport_array *reuseport_array(struct bpf_map *map)\n{\n\treturn (struct reuseport_array *)map;\n}\n\n \nvoid bpf_sk_reuseport_detach(struct sock *sk)\n{\n\tstruct sock __rcu **socks;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsocks = __locked_read_sk_user_data_with_flags(sk, SK_USER_DATA_BPF);\n\tif (socks) {\n\t\tWRITE_ONCE(sk->sk_user_data, NULL);\n\t\t \n\t\tRCU_INIT_POINTER(*socks, NULL);\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic int reuseport_array_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32) &&\n\t    attr->value_size != sizeof(u64))\n\t\treturn -EINVAL;\n\n\treturn array_map_alloc_check(attr);\n}\n\nstatic void *reuseport_array_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn rcu_dereference(array->ptrs[index]);\n}\n\n \nstatic long reuseport_array_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = *(u32 *)key;\n\tstruct sock *sk;\n\tint err;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (!rcu_access_pointer(array->ptrs[index]))\n\t\treturn -ENOENT;\n\n\tspin_lock_bh(&reuseport_lock);\n\n\tsk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t       lockdep_is_held(&reuseport_lock));\n\tif (sk) {\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tWRITE_ONCE(sk->sk_user_data, NULL);\n\t\tRCU_INIT_POINTER(array->ptrs[index], NULL);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\n\n\treturn err;\n}\n\nstatic void reuseport_array_free(struct bpf_map *map)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *sk;\n\tu32 i;\n\n\t \n\n\t \n\trcu_read_lock();\n\tfor (i = 0; i < map->max_entries; i++) {\n\t\tsk = rcu_dereference(array->ptrs[i]);\n\t\tif (sk) {\n\t\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\t\t \n\t\t\tsk->sk_user_data = NULL;\n\t\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\t\tRCU_INIT_POINTER(array->ptrs[i], NULL);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tbpf_map_area_free(array);\n}\n\nstatic struct bpf_map *reuseport_array_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct reuseport_array *array;\n\n\t \n\tarray = bpf_map_area_alloc(struct_size(array, ptrs, attr->max_entries), numa_node);\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tbpf_map_init_from_attr(&array->map, attr);\n\n\treturn &array->map;\n}\n\nint bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = __sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic int\nreuseport_array_update_check(const struct reuseport_array *array,\n\t\t\t     const struct sock *nsk,\n\t\t\t     const struct sock *osk,\n\t\t\t     const struct sock_reuseport *nsk_reuse,\n\t\t\t     u32 map_flags)\n{\n\tif (osk && map_flags == BPF_NOEXIST)\n\t\treturn -EEXIST;\n\n\tif (!osk && map_flags == BPF_EXIST)\n\t\treturn -ENOENT;\n\n\tif (nsk->sk_protocol != IPPROTO_UDP && nsk->sk_protocol != IPPROTO_TCP)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_family != AF_INET && nsk->sk_family != AF_INET6)\n\t\treturn -ENOTSUPP;\n\n\tif (nsk->sk_type != SOCK_STREAM && nsk->sk_type != SOCK_DGRAM)\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (!sock_flag(nsk, SOCK_RCU_FREE) || !sk_hashed(nsk) || !nsk_reuse)\n\t\treturn -EINVAL;\n\n\t \n\tif (READ_ONCE(nsk->sk_user_data))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nint bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tuintptr_t sk_user_data;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t \n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t \n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\tsk_user_data = (uintptr_t)&array->ptrs[index] | SK_USER_DATA_NOCOPY |\n\t\tSK_USER_DATA_BPF;\n\tWRITE_ONCE(nsk->sk_user_data, (void *)sk_user_data);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}\n\n \nstatic int reuseport_array_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = (u32 *)next_key;\n\n\tif (index >= array->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == array->map.max_entries - 1)\n\t\treturn -ENOENT;\n\n\t*next = index + 1;\n\treturn 0;\n}\n\nstatic u64 reuseport_array_mem_usage(const struct bpf_map *map)\n{\n\tstruct reuseport_array *array;\n\n\treturn struct_size(array, ptrs, map->max_entries);\n}\n\nBTF_ID_LIST_SINGLE(reuseport_array_map_btf_ids, struct, reuseport_array)\nconst struct bpf_map_ops reuseport_array_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc_check = reuseport_array_alloc_check,\n\t.map_alloc = reuseport_array_alloc,\n\t.map_free = reuseport_array_free,\n\t.map_lookup_elem = reuseport_array_lookup_elem,\n\t.map_get_next_key = reuseport_array_get_next_key,\n\t.map_delete_elem = reuseport_array_delete_elem,\n\t.map_mem_usage = reuseport_array_mem_usage,\n\t.map_btf_id = &reuseport_array_map_btf_ids[0],\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}