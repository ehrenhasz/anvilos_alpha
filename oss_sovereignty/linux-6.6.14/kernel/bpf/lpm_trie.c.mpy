{
  "module_name": "lpm_trie.c",
  "hash_id": "9a1a54224c78b2c7c37cdde68f8232b8d905347f71eee7b24af0461384cf3ea5",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/lpm_trie.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <net/ipv6.h>\n#include <uapi/linux/btf.h>\n#include <linux/btf_ids.h>\n\n \n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstruct lpm_trie_node;\n\nstruct lpm_trie_node {\n\tstruct rcu_head rcu;\n\tstruct lpm_trie_node __rcu\t*child[2];\n\tu32\t\t\t\tprefixlen;\n\tu32\t\t\t\tflags;\n\tu8\t\t\t\tdata[];\n};\n\nstruct lpm_trie {\n\tstruct bpf_map\t\t\tmap;\n\tstruct lpm_trie_node __rcu\t*root;\n\tsize_t\t\t\t\tn_entries;\n\tsize_t\t\t\t\tmax_prefixlen;\n\tsize_t\t\t\t\tdata_size;\n\tspinlock_t\t\t\tlock;\n};\n\n \n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}\n\n \nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t \n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}\n\n \nstatic void *trie_lookup_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *found = NULL;\n\tstruct bpf_lpm_trie_key *key = _key;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn NULL;\n\n\t \n\n\tfor (node = rcu_dereference_check(trie->root, rcu_read_lock_bh_held());\n\t     node;) {\n\t\tunsigned int next_bit;\n\t\tsize_t matchlen;\n\n\t\t \n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (matchlen == trie->max_prefixlen) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (matchlen < node->prefixlen)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tfound = node;\n\n\t\t \n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference_check(node->child[next_bit],\n\t\t\t\t\t     rcu_read_lock_bh_held());\n\t}\n\n\tif (!found)\n\t\treturn NULL;\n\n\treturn found->data + trie->data_size;\n}\n\nstatic struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = bpf_map_kmalloc_node(&trie->map, size, GFP_NOWAIT | __GFP_NOWARN,\n\t\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}\n\n \nstatic long trie_update_elem(struct bpf_map *map,\n\t\t\t     void *_key, void *value, u64 flags)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *im_node = NULL, *new_node = NULL;\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct bpf_lpm_trie_key *key = _key;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&trie->lock, irq_flags);\n\n\t \n\n\tif (trie->n_entries == trie->map.max_entries) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tnew_node = lpm_trie_node_alloc(trie, value);\n\tif (!new_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries++;\n\n\tnew_node->prefixlen = key->prefixlen;\n\tRCU_INIT_POINTER(new_node->child[0], NULL);\n\tRCU_INIT_POINTER(new_node->child[1], NULL);\n\tmemcpy(new_node->data, key->data, trie->data_size);\n\n\t \n\tslot = &trie->root;\n\n\twhile ((node = rcu_dereference_protected(*slot,\n\t\t\t\t\tlockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen ||\n\t\t    node->prefixlen == trie->max_prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tslot = &node->child[next_bit];\n\t}\n\n\t \n\tif (!node) {\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\t \n\tif (node->prefixlen == matchlen) {\n\t\tnew_node->child[0] = node->child[0];\n\t\tnew_node->child[1] = node->child[1];\n\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\ttrie->n_entries--;\n\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tkfree_rcu(node, rcu);\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (matchlen == key->prefixlen) {\n\t\tnext_bit = extract_bit(node->data, matchlen);\n\t\trcu_assign_pointer(new_node->child[next_bit], node);\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\tim_node = lpm_trie_node_alloc(trie, NULL);\n\tif (!im_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tim_node->prefixlen = matchlen;\n\tim_node->flags |= LPM_TREE_NODE_FLAG_IM;\n\tmemcpy(im_node->data, node->data, trie->data_size);\n\n\t \n\tif (extract_bit(key->data, matchlen)) {\n\t\trcu_assign_pointer(im_node->child[0], node);\n\t\trcu_assign_pointer(im_node->child[1], new_node);\n\t} else {\n\t\trcu_assign_pointer(im_node->child[0], new_node);\n\t\trcu_assign_pointer(im_node->child[1], node);\n\t}\n\n\t \n\trcu_assign_pointer(*slot, im_node);\n\nout:\n\tif (ret) {\n\t\tif (new_node)\n\t\t\ttrie->n_entries--;\n\n\t\tkfree(new_node);\n\t\tkfree(im_node);\n\t}\n\n\tspin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}\n\n \nstatic long trie_delete_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key;\n\tstruct lpm_trie_node __rcu **trim, **trim2;\n\tstruct lpm_trie_node *node, *parent;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&trie->lock, irq_flags);\n\n\t \n\ttrim = &trie->root;\n\ttrim2 = trim;\n\tparent = NULL;\n\twhile ((node = rcu_dereference_protected(\n\t\t       *trim, lockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tparent = node;\n\t\ttrim2 = trim;\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\ttrim = &node->child[next_bit];\n\t}\n\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    node->prefixlen != matchlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries--;\n\n\t \n\tif (rcu_access_pointer(node->child[0]) &&\n\t    rcu_access_pointer(node->child[1])) {\n\t\tnode->flags |= LPM_TREE_NODE_FLAG_IM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (parent && (parent->flags & LPM_TREE_NODE_FLAG_IM) &&\n\t    !node->child[0] && !node->child[1]) {\n\t\tif (node == rcu_access_pointer(parent->child[0]))\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[1]));\n\t\telse\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[0]));\n\t\tkfree_rcu(parent, rcu);\n\t\tkfree_rcu(node, rcu);\n\t\tgoto out;\n\t}\n\n\t \n\tif (node->child[0])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[0]));\n\telse if (node->child[1])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[1]));\n\telse\n\t\tRCU_INIT_POINTER(*trim, NULL);\n\tkfree_rcu(node, rcu);\n\nout:\n\tspin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}\n\n#define LPM_DATA_SIZE_MAX\t256\n#define LPM_DATA_SIZE_MIN\t1\n\n#define LPM_VAL_SIZE_MAX\t(KMALLOC_MAX_SIZE - LPM_DATA_SIZE_MAX - \\\n\t\t\t\t sizeof(struct lpm_trie_node))\n#define LPM_VAL_SIZE_MIN\t1\n\n#define LPM_KEY_SIZE(X)\t\t(sizeof(struct bpf_lpm_trie_key) + (X))\n#define LPM_KEY_SIZE_MAX\tLPM_KEY_SIZE(LPM_DATA_SIZE_MAX)\n#define LPM_KEY_SIZE_MIN\tLPM_KEY_SIZE(LPM_DATA_SIZE_MIN)\n\n#define LPM_CREATE_FLAG_MASK\t(BPF_F_NO_PREALLOC | BPF_F_NUMA_NODE |\t\\\n\t\t\t\t BPF_F_ACCESS_MASK)\n\nstatic struct bpf_map *trie_alloc(union bpf_attr *attr)\n{\n\tstruct lpm_trie *trie;\n\n\t \n\tif (attr->max_entries == 0 ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->map_flags & ~LPM_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    attr->key_size < LPM_KEY_SIZE_MIN ||\n\t    attr->key_size > LPM_KEY_SIZE_MAX ||\n\t    attr->value_size < LPM_VAL_SIZE_MIN ||\n\t    attr->value_size > LPM_VAL_SIZE_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttrie = bpf_map_area_alloc(sizeof(*trie), NUMA_NO_NODE);\n\tif (!trie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tbpf_map_init_from_attr(&trie->map, attr);\n\ttrie->data_size = attr->key_size -\n\t\t\t  offsetof(struct bpf_lpm_trie_key, data);\n\ttrie->max_prefixlen = trie->data_size * 8;\n\n\tspin_lock_init(&trie->lock);\n\n\treturn &trie->map;\n}\n\nstatic void trie_free(struct bpf_map *map)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct lpm_trie_node *node;\n\n\t \n\n\tfor (;;) {\n\t\tslot = &trie->root;\n\n\t\tfor (;;) {\n\t\t\tnode = rcu_dereference_protected(*slot, 1);\n\t\t\tif (!node)\n\t\t\t\tgoto out;\n\n\t\t\tif (rcu_access_pointer(node->child[0])) {\n\t\t\t\tslot = &node->child[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rcu_access_pointer(node->child[1])) {\n\t\t\t\tslot = &node->child[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkfree(node);\n\t\t\tRCU_INIT_POINTER(*slot, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tbpf_map_area_free(trie);\n}\n\nstatic int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)\n{\n\tstruct lpm_trie_node *node, *next_node = NULL, *parent, *search_root;\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key, *next_key = _next_key;\n\tstruct lpm_trie_node **node_stack = NULL;\n\tint err = 0, stack_ptr = -1;\n\tunsigned int next_bit;\n\tsize_t matchlen;\n\n\t \n\n\t \n\tsearch_root = rcu_dereference(trie->root);\n\tif (!search_root)\n\t\treturn -ENOENT;\n\n\t \n\tif (!key || key->prefixlen > trie->max_prefixlen)\n\t\tgoto find_leftmost;\n\n\tnode_stack = kmalloc_array(trie->max_prefixlen,\n\t\t\t\t   sizeof(struct lpm_trie_node *),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN);\n\tif (!node_stack)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (node = search_root; node;) {\n\t\tnode_stack[++stack_ptr] = node;\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\tgoto find_leftmost;\n\n\t \n\tnode = node_stack[stack_ptr];\n\twhile (stack_ptr > 0) {\n\t\tparent = node_stack[stack_ptr - 1];\n\t\tif (rcu_dereference(parent->child[0]) == node) {\n\t\t\tsearch_root = rcu_dereference(parent->child[1]);\n\t\t\tif (search_root)\n\t\t\t\tgoto find_leftmost;\n\t\t}\n\t\tif (!(parent->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\t\tnext_node = parent;\n\t\t\tgoto do_copy;\n\t\t}\n\n\t\tnode = parent;\n\t\tstack_ptr--;\n\t}\n\n\t \n\terr = -ENOENT;\n\tgoto free_stack;\n\nfind_leftmost:\n\t \n\tfor (node = search_root; node;) {\n\t\tif (node->flags & LPM_TREE_NODE_FLAG_IM) {\n\t\t\tnode = rcu_dereference(node->child[0]);\n\t\t} else {\n\t\t\tnext_node = node;\n\t\t\tnode = rcu_dereference(node->child[0]);\n\t\t\tif (!node)\n\t\t\t\tnode = rcu_dereference(next_node->child[1]);\n\t\t}\n\t}\ndo_copy:\n\tnext_key->prefixlen = next_node->prefixlen;\n\tmemcpy((void *)next_key + offsetof(struct bpf_lpm_trie_key, data),\n\t       next_node->data, trie->data_size);\nfree_stack:\n\tkfree(node_stack);\n\treturn err;\n}\n\nstatic int trie_check_btf(const struct bpf_map *map,\n\t\t\t  const struct btf *btf,\n\t\t\t  const struct btf_type *key_type,\n\t\t\t  const struct btf_type *value_type)\n{\n\t \n\treturn BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ?\n\t       -EINVAL : 0;\n}\n\nstatic u64 trie_mem_usage(const struct bpf_map *map)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tu64 elem_size;\n\n\telem_size = sizeof(struct lpm_trie_node) + trie->data_size +\n\t\t\t    trie->map.value_size;\n\treturn elem_size * READ_ONCE(trie->n_entries);\n}\n\nBTF_ID_LIST_SINGLE(trie_map_btf_ids, struct, lpm_trie)\nconst struct bpf_map_ops trie_map_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc = trie_alloc,\n\t.map_free = trie_free,\n\t.map_get_next_key = trie_get_next_key,\n\t.map_lookup_elem = trie_lookup_elem,\n\t.map_update_elem = trie_update_elem,\n\t.map_delete_elem = trie_delete_elem,\n\t.map_lookup_batch = generic_map_lookup_batch,\n\t.map_update_batch = generic_map_update_batch,\n\t.map_delete_batch = generic_map_delete_batch,\n\t.map_check_btf = trie_check_btf,\n\t.map_mem_usage = trie_mem_usage,\n\t.map_btf_id = &trie_map_btf_ids[0],\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}