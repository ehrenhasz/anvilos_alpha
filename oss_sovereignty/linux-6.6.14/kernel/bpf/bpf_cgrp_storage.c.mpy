{
  "module_name": "bpf_cgrp_storage.c",
  "hash_id": "d4629425b07354356103075ed2c0090d6102cdf687234a4b1802e96872c822d8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/bpf_cgrp_storage.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/bpf.h>\n#include <linux/bpf_local_storage.h>\n#include <uapi/linux/btf.h>\n#include <linux/btf_ids.h>\n\nDEFINE_BPF_STORAGE_CACHE(cgroup_cache);\n\nstatic DEFINE_PER_CPU(int, bpf_cgrp_storage_busy);\n\nstatic void bpf_cgrp_storage_lock(void)\n{\n\tmigrate_disable();\n\tthis_cpu_inc(bpf_cgrp_storage_busy);\n}\n\nstatic void bpf_cgrp_storage_unlock(void)\n{\n\tthis_cpu_dec(bpf_cgrp_storage_busy);\n\tmigrate_enable();\n}\n\nstatic bool bpf_cgrp_storage_trylock(void)\n{\n\tmigrate_disable();\n\tif (unlikely(this_cpu_inc_return(bpf_cgrp_storage_busy) != 1)) {\n\t\tthis_cpu_dec(bpf_cgrp_storage_busy);\n\t\tmigrate_enable();\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic struct bpf_local_storage __rcu **cgroup_storage_ptr(void *owner)\n{\n\tstruct cgroup *cg = owner;\n\n\treturn &cg->bpf_cgrp_storage;\n}\n\nvoid bpf_cgrp_storage_free(struct cgroup *cgroup)\n{\n\tstruct bpf_local_storage *local_storage;\n\n\trcu_read_lock();\n\tlocal_storage = rcu_dereference(cgroup->bpf_cgrp_storage);\n\tif (!local_storage) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbpf_cgrp_storage_lock();\n\tbpf_local_storage_destroy(local_storage);\n\tbpf_cgrp_storage_unlock();\n\trcu_read_unlock();\n}\n\nstatic struct bpf_local_storage_data *\ncgroup_storage_lookup(struct cgroup *cgroup, struct bpf_map *map, bool cacheit_lockit)\n{\n\tstruct bpf_local_storage *cgroup_storage;\n\tstruct bpf_local_storage_map *smap;\n\n\tcgroup_storage = rcu_dereference_check(cgroup->bpf_cgrp_storage,\n\t\t\t\t\t       bpf_rcu_lock_held());\n\tif (!cgroup_storage)\n\t\treturn NULL;\n\n\tsmap = (struct bpf_local_storage_map *)map;\n\treturn bpf_local_storage_lookup(cgroup_storage, smap, cacheit_lockit);\n}\n\nstatic void *bpf_cgrp_storage_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct cgroup *cgroup;\n\tint fd;\n\n\tfd = *(int *)key;\n\tcgroup = cgroup_get_from_fd(fd);\n\tif (IS_ERR(cgroup))\n\t\treturn ERR_CAST(cgroup);\n\n\tbpf_cgrp_storage_lock();\n\tsdata = cgroup_storage_lookup(cgroup, map, true);\n\tbpf_cgrp_storage_unlock();\n\tcgroup_put(cgroup);\n\treturn sdata ? sdata->data : NULL;\n}\n\nstatic long bpf_cgrp_storage_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags)\n{\n\tstruct bpf_local_storage_data *sdata;\n\tstruct cgroup *cgroup;\n\tint fd;\n\n\tfd = *(int *)key;\n\tcgroup = cgroup_get_from_fd(fd);\n\tif (IS_ERR(cgroup))\n\t\treturn PTR_ERR(cgroup);\n\n\tbpf_cgrp_storage_lock();\n\tsdata = bpf_local_storage_update(cgroup, (struct bpf_local_storage_map *)map,\n\t\t\t\t\t value, map_flags, GFP_ATOMIC);\n\tbpf_cgrp_storage_unlock();\n\tcgroup_put(cgroup);\n\treturn PTR_ERR_OR_ZERO(sdata);\n}\n\nstatic int cgroup_storage_delete(struct cgroup *cgroup, struct bpf_map *map)\n{\n\tstruct bpf_local_storage_data *sdata;\n\n\tsdata = cgroup_storage_lookup(cgroup, map, false);\n\tif (!sdata)\n\t\treturn -ENOENT;\n\n\tbpf_selem_unlink(SELEM(sdata), false);\n\treturn 0;\n}\n\nstatic long bpf_cgrp_storage_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct cgroup *cgroup;\n\tint err, fd;\n\n\tfd = *(int *)key;\n\tcgroup = cgroup_get_from_fd(fd);\n\tif (IS_ERR(cgroup))\n\t\treturn PTR_ERR(cgroup);\n\n\tbpf_cgrp_storage_lock();\n\terr = cgroup_storage_delete(cgroup, map);\n\tbpf_cgrp_storage_unlock();\n\tcgroup_put(cgroup);\n\treturn err;\n}\n\nstatic int notsupp_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic struct bpf_map *cgroup_storage_map_alloc(union bpf_attr *attr)\n{\n\treturn bpf_local_storage_map_alloc(attr, &cgroup_cache, true);\n}\n\nstatic void cgroup_storage_map_free(struct bpf_map *map)\n{\n\tbpf_local_storage_map_free(map, &cgroup_cache, NULL);\n}\n\n \nBPF_CALL_5(bpf_cgrp_storage_get, struct bpf_map *, map, struct cgroup *, cgroup,\n\t   void *, value, u64, flags, gfp_t, gfp_flags)\n{\n\tstruct bpf_local_storage_data *sdata;\n\n\tWARN_ON_ONCE(!bpf_rcu_lock_held());\n\tif (flags & ~(BPF_LOCAL_STORAGE_GET_F_CREATE))\n\t\treturn (unsigned long)NULL;\n\n\tif (!cgroup)\n\t\treturn (unsigned long)NULL;\n\n\tif (!bpf_cgrp_storage_trylock())\n\t\treturn (unsigned long)NULL;\n\n\tsdata = cgroup_storage_lookup(cgroup, map, true);\n\tif (sdata)\n\t\tgoto unlock;\n\n\t \n\tif (!percpu_ref_is_dying(&cgroup->self.refcnt) &&\n\t    (flags & BPF_LOCAL_STORAGE_GET_F_CREATE))\n\t\tsdata = bpf_local_storage_update(cgroup, (struct bpf_local_storage_map *)map,\n\t\t\t\t\t\t value, BPF_NOEXIST, gfp_flags);\n\nunlock:\n\tbpf_cgrp_storage_unlock();\n\treturn IS_ERR_OR_NULL(sdata) ? (unsigned long)NULL : (unsigned long)sdata->data;\n}\n\nBPF_CALL_2(bpf_cgrp_storage_delete, struct bpf_map *, map, struct cgroup *, cgroup)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(!bpf_rcu_lock_held());\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tif (!bpf_cgrp_storage_trylock())\n\t\treturn -EBUSY;\n\n\tret = cgroup_storage_delete(cgroup, map);\n\tbpf_cgrp_storage_unlock();\n\treturn ret;\n}\n\nconst struct bpf_map_ops cgrp_storage_map_ops = {\n\t.map_meta_equal = bpf_map_meta_equal,\n\t.map_alloc_check = bpf_local_storage_map_alloc_check,\n\t.map_alloc = cgroup_storage_map_alloc,\n\t.map_free = cgroup_storage_map_free,\n\t.map_get_next_key = notsupp_get_next_key,\n\t.map_lookup_elem = bpf_cgrp_storage_lookup_elem,\n\t.map_update_elem = bpf_cgrp_storage_update_elem,\n\t.map_delete_elem = bpf_cgrp_storage_delete_elem,\n\t.map_check_btf = bpf_local_storage_map_check_btf,\n\t.map_mem_usage = bpf_local_storage_map_mem_usage,\n\t.map_btf_id = &bpf_local_storage_map_btf_id[0],\n\t.map_owner_storage_ptr = cgroup_storage_ptr,\n};\n\nconst struct bpf_func_proto bpf_cgrp_storage_get_proto = {\n\t.func\t\t= bpf_cgrp_storage_get,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_BTF_ID_OR_NULL,\n\t.arg2_btf_id\t= &bpf_cgroup_btf_id[0],\n\t.arg3_type\t= ARG_PTR_TO_MAP_VALUE_OR_NULL,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nconst struct bpf_func_proto bpf_cgrp_storage_delete_proto = {\n\t.func\t\t= bpf_cgrp_storage_delete,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_BTF_ID_OR_NULL,\n\t.arg2_btf_id\t= &bpf_cgroup_btf_id[0],\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}