{
  "module_name": "bpf_iter.c",
  "hash_id": "0034d97ef2175a132b65759a92db39a9c2cd13c8ab8fc755222783c0d6034be7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/bpf_iter.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/anon_inodes.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/rcupdate_trace.h>\n\nstruct bpf_iter_target_info {\n\tstruct list_head list;\n\tconst struct bpf_iter_reg *reg_info;\n\tu32 btf_id;\t \n};\n\nstruct bpf_iter_link {\n\tstruct bpf_link link;\n\tstruct bpf_iter_aux_info aux;\n\tstruct bpf_iter_target_info *tinfo;\n};\n\nstruct bpf_iter_priv_data {\n\tstruct bpf_iter_target_info *tinfo;\n\tconst struct bpf_iter_seq_info *seq_info;\n\tstruct bpf_prog *prog;\n\tu64 session_id;\n\tu64 seq_num;\n\tbool done_stop;\n\tu8 target_private[] __aligned(8);\n};\n\nstatic struct list_head targets = LIST_HEAD_INIT(targets);\nstatic DEFINE_MUTEX(targets_mutex);\n\n \nstatic DEFINE_MUTEX(link_mutex);\n\n \nstatic atomic64_t session_id;\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info);\n\nstatic void bpf_iter_inc_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num++;\n}\n\nstatic void bpf_iter_dec_seq_num(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->seq_num--;\n}\n\nstatic void bpf_iter_done_stop(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\titer_priv->done_stop = true;\n}\n\nstatic inline bool bpf_iter_target_support_resched(const struct bpf_iter_target_info *tinfo)\n{\n\treturn tinfo->reg_info->feature & BPF_ITER_RESCHED;\n}\n\nstatic bool bpf_iter_support_resched(struct seq_file *seq)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\treturn bpf_iter_target_support_resched(iter_priv->tinfo);\n}\n\n \n#define MAX_ITER_OBJECTS\t1000000\n\n \nstatic ssize_t bpf_seq_read(struct file *file, char __user *buf, size_t size,\n\t\t\t    loff_t *ppos)\n{\n\tstruct seq_file *seq = file->private_data;\n\tsize_t n, offs, copied = 0;\n\tint err = 0, num_objs = 0;\n\tbool can_resched;\n\tvoid *p;\n\n\tmutex_lock(&seq->lock);\n\n\tif (!seq->buf) {\n\t\tseq->size = PAGE_SIZE << 3;\n\t\tseq->buf = kvmalloc(seq->size, GFP_KERNEL);\n\t\tif (!seq->buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (seq->count) {\n\t\tn = min(seq->count, size);\n\t\terr = copy_to_user(buf, seq->buf + seq->from, n);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tseq->count -= n;\n\t\tseq->from += n;\n\t\tcopied = n;\n\t\tgoto done;\n\t}\n\n\tseq->from = 0;\n\tp = seq->op->start(seq, &seq->index);\n\tif (!p)\n\t\tgoto stop;\n\tif (IS_ERR(p)) {\n\t\terr = PTR_ERR(p);\n\t\tseq->op->stop(seq, p);\n\t\tseq->count = 0;\n\t\tgoto done;\n\t}\n\n\terr = seq->op->show(seq, p);\n\tif (err > 0) {\n\t\t \n\t\tbpf_iter_dec_seq_num(seq);\n\t\tseq->count = 0;\n\t} else if (err < 0 || seq_has_overflowed(seq)) {\n\t\tif (!err)\n\t\t\terr = -E2BIG;\n\t\tseq->op->stop(seq, p);\n\t\tseq->count = 0;\n\t\tgoto done;\n\t}\n\n\tcan_resched = bpf_iter_support_resched(seq);\n\twhile (1) {\n\t\tloff_t pos = seq->index;\n\n\t\tnum_objs++;\n\t\toffs = seq->count;\n\t\tp = seq->op->next(seq, p, &seq->index);\n\t\tif (pos == seq->index) {\n\t\t\tpr_info_ratelimited(\"buggy seq_file .next function %ps \"\n\t\t\t\t\"did not updated position index\\n\",\n\t\t\t\tseq->op->next);\n\t\t\tseq->index++;\n\t\t}\n\n\t\tif (IS_ERR_OR_NULL(p))\n\t\t\tbreak;\n\n\t\t \n\t\tbpf_iter_inc_seq_num(seq);\n\n\t\tif (seq->count >= size)\n\t\t\tbreak;\n\n\t\tif (num_objs >= MAX_ITER_OBJECTS) {\n\t\t\tif (offs == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tseq->op->stop(seq, p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\terr = seq->op->show(seq, p);\n\t\tif (err > 0) {\n\t\t\tbpf_iter_dec_seq_num(seq);\n\t\t\tseq->count = offs;\n\t\t} else if (err < 0 || seq_has_overflowed(seq)) {\n\t\t\tseq->count = offs;\n\t\t\tif (offs == 0) {\n\t\t\t\tif (!err)\n\t\t\t\t\terr = -E2BIG;\n\t\t\t\tseq->op->stop(seq, p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (can_resched)\n\t\t\tcond_resched();\n\t}\nstop:\n\toffs = seq->count;\n\tif (IS_ERR(p)) {\n\t\tseq->op->stop(seq, NULL);\n\t\terr = PTR_ERR(p);\n\t\tgoto done;\n\t}\n\t \n\tseq->op->stop(seq, p);\n\tif (!p) {\n\t\tif (!seq_has_overflowed(seq)) {\n\t\t\tbpf_iter_done_stop(seq);\n\t\t} else {\n\t\t\tseq->count = offs;\n\t\t\tif (offs == 0) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tn = min(seq->count, size);\n\terr = copy_to_user(buf, seq->buf, n);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tgoto done;\n\t}\n\tcopied = n;\n\tseq->count -= n;\n\tseq->from = n;\ndone:\n\tif (!copied)\n\t\tcopied = err;\n\telse\n\t\t*ppos += copied;\n\tmutex_unlock(&seq->lock);\n\treturn copied;\n}\n\nstatic const struct bpf_iter_seq_info *\n__get_seq_info(struct bpf_iter_link *link)\n{\n\tconst struct bpf_iter_seq_info *seq_info;\n\n\tif (link->aux.map) {\n\t\tseq_info = link->aux.map->ops->iter_seq_info;\n\t\tif (seq_info)\n\t\t\treturn seq_info;\n\t}\n\n\treturn link->tinfo->reg_info->seq_info;\n}\n\nstatic int iter_open(struct inode *inode, struct file *file)\n{\n\tstruct bpf_iter_link *link = inode->i_private;\n\n\treturn prepare_seq_file(file, link, __get_seq_info(link));\n}\n\nstatic int iter_release(struct inode *inode, struct file *file)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\tif (!seq)\n\t\treturn 0;\n\n\titer_priv = container_of(seq->private, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (iter_priv->seq_info->fini_seq_private)\n\t\titer_priv->seq_info->fini_seq_private(seq->private);\n\n\tbpf_prog_put(iter_priv->prog);\n\tseq->private = iter_priv;\n\n\treturn seq_release_private(inode, file);\n}\n\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\n\n \nint bpf_iter_reg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\n\ttinfo = kzalloc(sizeof(*tinfo), GFP_KERNEL);\n\tif (!tinfo)\n\t\treturn -ENOMEM;\n\n\ttinfo->reg_info = reg_info;\n\tINIT_LIST_HEAD(&tinfo->list);\n\n\tmutex_lock(&targets_mutex);\n\tlist_add(&tinfo->list, &targets);\n\tmutex_unlock(&targets_mutex);\n\n\treturn 0;\n}\n\nvoid bpf_iter_unreg_target(const struct bpf_iter_reg *reg_info)\n{\n\tstruct bpf_iter_target_info *tinfo;\n\tbool found = false;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (reg_info == tinfo->reg_info) {\n\t\t\tlist_del(&tinfo->list);\n\t\t\tkfree(tinfo);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\tWARN_ON(found == false);\n}\n\nstatic void cache_btf_id(struct bpf_iter_target_info *tinfo,\n\t\t\t struct bpf_prog *prog)\n{\n\ttinfo->btf_id = prog->aux->attach_btf_id;\n}\n\nbool bpf_iter_prog_supported(struct bpf_prog *prog)\n{\n\tconst char *attach_fname = prog->aux->attach_func_name;\n\tstruct bpf_iter_target_info *tinfo = NULL, *iter;\n\tu32 prog_btf_id = prog->aux->attach_btf_id;\n\tconst char *prefix = BPF_ITER_FUNC_PREFIX;\n\tint prefix_len = strlen(prefix);\n\n\tif (strncmp(attach_fname, prefix, prefix_len))\n\t\treturn false;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(iter, &targets, list) {\n\t\tif (iter->btf_id && iter->btf_id == prog_btf_id) {\n\t\t\ttinfo = iter;\n\t\t\tbreak;\n\t\t}\n\t\tif (!strcmp(attach_fname + prefix_len, iter->reg_info->target)) {\n\t\t\tcache_btf_id(iter, prog);\n\t\t\ttinfo = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\tif (tinfo) {\n\t\tprog->aux->ctx_arg_info_size = tinfo->reg_info->ctx_arg_info_size;\n\t\tprog->aux->ctx_arg_info = tinfo->reg_info->ctx_arg_info;\n\t}\n\n\treturn tinfo != NULL;\n}\n\nconst struct bpf_func_proto *\nbpf_iter_get_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tconst struct bpf_iter_target_info *tinfo;\n\tconst struct bpf_func_proto *fn = NULL;\n\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(tinfo, &targets, list) {\n\t\tif (tinfo->btf_id == prog->aux->attach_btf_id) {\n\t\t\tconst struct bpf_iter_reg *reg_info;\n\n\t\t\treg_info = tinfo->reg_info;\n\t\t\tif (reg_info->get_func_proto)\n\t\t\t\tfn = reg_info->get_func_proto(func_id, prog);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\n\treturn fn;\n}\n\nstatic void bpf_iter_link_release(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\n\tif (iter_link->tinfo->reg_info->detach_target)\n\t\titer_link->tinfo->reg_info->detach_target(&iter_link->aux);\n}\n\nstatic void bpf_iter_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\n\tkfree(iter_link);\n}\n\nstatic int bpf_iter_link_replace(struct bpf_link *link,\n\t\t\t\t struct bpf_prog *new_prog,\n\t\t\t\t struct bpf_prog *old_prog)\n{\n\tint ret = 0;\n\n\tmutex_lock(&link_mutex);\n\tif (old_prog && link->prog != old_prog) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (link->prog->type != new_prog->type ||\n\t    link->prog->expected_attach_type != new_prog->expected_attach_type ||\n\t    link->prog->aux->attach_btf_id != new_prog->aux->attach_btf_id) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\told_prog = xchg(&link->prog, new_prog);\n\tbpf_prog_put(old_prog);\n\nout_unlock:\n\tmutex_unlock(&link_mutex);\n\treturn ret;\n}\n\nstatic void bpf_iter_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t      struct seq_file *seq)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tbpf_iter_show_fdinfo_t show_fdinfo;\n\n\tseq_printf(seq,\n\t\t   \"target_name:\\t%s\\n\",\n\t\t   iter_link->tinfo->reg_info->target);\n\n\tshow_fdinfo = iter_link->tinfo->reg_info->show_fdinfo;\n\tif (show_fdinfo)\n\t\tshow_fdinfo(&iter_link->aux, seq);\n}\n\nstatic int bpf_iter_link_fill_link_info(const struct bpf_link *link,\n\t\t\t\t\tstruct bpf_link_info *info)\n{\n\tstruct bpf_iter_link *iter_link =\n\t\tcontainer_of(link, struct bpf_iter_link, link);\n\tchar __user *ubuf = u64_to_user_ptr(info->iter.target_name);\n\tbpf_iter_fill_link_info_t fill_link_info;\n\tu32 ulen = info->iter.target_name_len;\n\tconst char *target_name;\n\tu32 target_len;\n\n\tif (!ulen ^ !ubuf)\n\t\treturn -EINVAL;\n\n\ttarget_name = iter_link->tinfo->reg_info->target;\n\ttarget_len =  strlen(target_name);\n\tinfo->iter.target_name_len = target_len + 1;\n\n\tif (ubuf) {\n\t\tif (ulen >= target_len + 1) {\n\t\t\tif (copy_to_user(ubuf, target_name, target_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(ubuf, target_name, ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + ulen - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tfill_link_info = iter_link->tinfo->reg_info->fill_link_info;\n\tif (fill_link_info)\n\t\treturn fill_link_info(&iter_link->aux, info);\n\n\treturn 0;\n}\n\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nbool bpf_link_is_iter(struct bpf_link *link)\n{\n\treturn link->ops == &bpf_iter_link_lops;\n}\n\nint bpf_iter_link_attach(const union bpf_attr *attr, bpfptr_t uattr,\n\t\t\t struct bpf_prog *prog)\n{\n\tstruct bpf_iter_target_info *tinfo = NULL, *iter;\n\tstruct bpf_link_primer link_primer;\n\tunion bpf_iter_link_info linfo;\n\tstruct bpf_iter_link *link;\n\tu32 prog_btf_id, linfo_len;\n\tbpfptr_t ulinfo;\n\tint err;\n\n\tif (attr->link_create.target_fd || attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\tmemset(&linfo, 0, sizeof(union bpf_iter_link_info));\n\n\tulinfo = make_bpfptr(attr->link_create.iter_info, uattr.is_kernel);\n\tlinfo_len = attr->link_create.iter_info_len;\n\tif (bpfptr_is_null(ulinfo) ^ !linfo_len)\n\t\treturn -EINVAL;\n\n\tif (!bpfptr_is_null(ulinfo)) {\n\t\terr = bpf_check_uarg_tail_zero(ulinfo, sizeof(linfo),\n\t\t\t\t\t       linfo_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlinfo_len = min_t(u32, linfo_len, sizeof(linfo));\n\t\tif (copy_from_bpfptr(&linfo, ulinfo, linfo_len))\n\t\t\treturn -EFAULT;\n\t}\n\n\tprog_btf_id = prog->aux->attach_btf_id;\n\tmutex_lock(&targets_mutex);\n\tlist_for_each_entry(iter, &targets, list) {\n\t\tif (iter->btf_id == prog_btf_id) {\n\t\t\ttinfo = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&targets_mutex);\n\tif (!tinfo)\n\t\treturn -ENOENT;\n\n\t \n\tif (prog->aux->sleepable && !bpf_iter_target_support_resched(tinfo))\n\t\treturn -EINVAL;\n\n\tlink = kzalloc(sizeof(*link), GFP_USER | __GFP_NOWARN);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_ITER, &bpf_iter_link_lops, prog);\n\tlink->tinfo = tinfo;\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err) {\n\t\tkfree(link);\n\t\treturn err;\n\t}\n\n\tif (tinfo->reg_info->attach_target) {\n\t\terr = tinfo->reg_info->attach_target(prog, &linfo, &link->aux);\n\t\tif (err) {\n\t\t\tbpf_link_cleanup(&link_primer);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn bpf_link_settle(&link_primer);\n}\n\nstatic void init_seq_meta(struct bpf_iter_priv_data *priv_data,\n\t\t\t  struct bpf_iter_target_info *tinfo,\n\t\t\t  const struct bpf_iter_seq_info *seq_info,\n\t\t\t  struct bpf_prog *prog)\n{\n\tpriv_data->tinfo = tinfo;\n\tpriv_data->seq_info = seq_info;\n\tpriv_data->prog = prog;\n\tpriv_data->session_id = atomic64_inc_return(&session_id);\n\tpriv_data->seq_num = 0;\n\tpriv_data->done_stop = false;\n}\n\nstatic int prepare_seq_file(struct file *file, struct bpf_iter_link *link,\n\t\t\t    const struct bpf_iter_seq_info *seq_info)\n{\n\tstruct bpf_iter_priv_data *priv_data;\n\tstruct bpf_iter_target_info *tinfo;\n\tstruct bpf_prog *prog;\n\tu32 total_priv_dsize;\n\tstruct seq_file *seq;\n\tint err = 0;\n\n\tmutex_lock(&link_mutex);\n\tprog = link->link.prog;\n\tbpf_prog_inc(prog);\n\tmutex_unlock(&link_mutex);\n\n\ttinfo = link->tinfo;\n\ttotal_priv_dsize = offsetof(struct bpf_iter_priv_data, target_private) +\n\t\t\t   seq_info->seq_priv_size;\n\tpriv_data = __seq_open_private(file, seq_info->seq_ops,\n\t\t\t\t       total_priv_dsize);\n\tif (!priv_data) {\n\t\terr = -ENOMEM;\n\t\tgoto release_prog;\n\t}\n\n\tif (seq_info->init_seq_private) {\n\t\terr = seq_info->init_seq_private(priv_data->target_private, &link->aux);\n\t\tif (err)\n\t\t\tgoto release_seq_file;\n\t}\n\n\tinit_seq_meta(priv_data, tinfo, seq_info, prog);\n\tseq = file->private_data;\n\tseq->private = priv_data->target_private;\n\n\treturn 0;\n\nrelease_seq_file:\n\tseq_release_private(file->f_inode, file);\n\tfile->private_data = NULL;\nrelease_prog:\n\tbpf_prog_put(prog);\n\treturn err;\n}\n\nint bpf_iter_new_fd(struct bpf_link *link)\n{\n\tstruct bpf_iter_link *iter_link;\n\tstruct file *file;\n\tunsigned int flags;\n\tint err, fd;\n\n\tif (link->ops != &bpf_iter_link_lops)\n\t\treturn -EINVAL;\n\n\tflags = O_RDONLY | O_CLOEXEC;\n\tfd = get_unused_fd_flags(flags);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tfile = anon_inode_getfile(\"bpf_iter\", &bpf_iter_fops, NULL, flags);\n\tif (IS_ERR(file)) {\n\t\terr = PTR_ERR(file);\n\t\tgoto free_fd;\n\t}\n\n\titer_link = container_of(link, struct bpf_iter_link, link);\n\terr = prepare_seq_file(file, iter_link, __get_seq_info(iter_link));\n\tif (err)\n\t\tgoto free_file;\n\n\tfd_install(fd, file);\n\treturn fd;\n\nfree_file:\n\tfput(file);\nfree_fd:\n\tput_unused_fd(fd);\n\treturn err;\n}\n\nstruct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}\n\nint bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tstruct bpf_run_ctx run_ctx, *old_run_ctx;\n\tint ret;\n\n\tif (prog->aux->sleepable) {\n\t\trcu_read_lock_trace();\n\t\tmigrate_disable();\n\t\tmight_fault();\n\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);\n\t\tret = bpf_prog_run(prog, ctx);\n\t\tbpf_reset_run_ctx(old_run_ctx);\n\t\tmigrate_enable();\n\t\trcu_read_unlock_trace();\n\t} else {\n\t\trcu_read_lock();\n\t\tmigrate_disable();\n\t\told_run_ctx = bpf_set_run_ctx(&run_ctx);\n\t\tret = bpf_prog_run(prog, ctx);\n\t\tbpf_reset_run_ctx(old_run_ctx);\n\t\tmigrate_enable();\n\t\trcu_read_unlock();\n\t}\n\n\t \n\treturn ret == 0 ? 0 : -EAGAIN;\n}\n\nBPF_CALL_4(bpf_for_each_map_elem, struct bpf_map *, map, void *, callback_fn,\n\t   void *, callback_ctx, u64, flags)\n{\n\treturn map->ops->map_for_each_callback(map, callback_fn, callback_ctx, flags);\n}\n\nconst struct bpf_func_proto bpf_for_each_map_elem_proto = {\n\t.func\t\t= bpf_for_each_map_elem,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_CONST_MAP_PTR,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n\t.arg3_type\t= ARG_PTR_TO_STACK_OR_NULL,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_4(bpf_loop, u32, nr_loops, void *, callback_fn, void *, callback_ctx,\n\t   u64, flags)\n{\n\tbpf_callback_t callback = (bpf_callback_t)callback_fn;\n\tu64 ret;\n\tu32 i;\n\n\t \n\tif (flags)\n\t\treturn -EINVAL;\n\tif (nr_loops > BPF_MAX_LOOPS)\n\t\treturn -E2BIG;\n\n\tfor (i = 0; i < nr_loops; i++) {\n\t\tret = callback((u64)i, (u64)(long)callback_ctx, 0, 0, 0);\n\t\t \n\t\tif (ret)\n\t\t\treturn i + 1;\n\t}\n\n\treturn i;\n}\n\nconst struct bpf_func_proto bpf_loop_proto = {\n\t.func\t\t= bpf_loop,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_ANYTHING,\n\t.arg2_type\t= ARG_PTR_TO_FUNC,\n\t.arg3_type\t= ARG_PTR_TO_STACK_OR_NULL,\n\t.arg4_type\t= ARG_ANYTHING,\n};\n\nstruct bpf_iter_num_kern {\n\tint cur;  \n\tint end;  \n} __aligned(8);\n\n__diag_push();\n__diag_ignore_all(\"-Wmissing-prototypes\",\n\t\t  \"Global functions as their definitions will be in vmlinux BTF\");\n\n__bpf_kfunc int bpf_iter_num_new(struct bpf_iter_num *it, int start, int end)\n{\n\tstruct bpf_iter_num_kern *s = (void *)it;\n\n\tBUILD_BUG_ON(sizeof(struct bpf_iter_num_kern) != sizeof(struct bpf_iter_num));\n\tBUILD_BUG_ON(__alignof__(struct bpf_iter_num_kern) != __alignof__(struct bpf_iter_num));\n\n\tBTF_TYPE_EMIT(struct btf_iter_num);\n\n\t \n\tif (start > end) {\n\t\ts->cur = s->end = 0;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((s64)end - (s64)start > BPF_MAX_LOOPS) {\n\t\ts->cur = s->end = 0;\n\t\treturn -E2BIG;\n\t}\n\n\t \n\ts->cur = start - 1;\n\ts->end = end;\n\n\treturn 0;\n}\n\n__bpf_kfunc int *bpf_iter_num_next(struct bpf_iter_num* it)\n{\n\tstruct bpf_iter_num_kern *s = (void *)it;\n\n\t \n\tif ((s64)(s->cur + 1) >= s->end) {\n\t\ts->cur = s->end = 0;\n\t\treturn NULL;\n\t}\n\n\ts->cur++;\n\n\treturn &s->cur;\n}\n\n__bpf_kfunc void bpf_iter_num_destroy(struct bpf_iter_num *it)\n{\n\tstruct bpf_iter_num_kern *s = (void *)it;\n\n\ts->cur = s->end = 0;\n}\n\n__diag_pop();\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}