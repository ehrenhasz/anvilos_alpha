{
  "module_name": "bpf_lsm.c",
  "hash_id": "f4a9521508c29d3640da7b6d6e0d4d6030ef784b298e6c9eb6ec3fce647b439c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/bpf_lsm.c",
  "human_readable_source": "\n\n \n\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/binfmts.h>\n#include <linux/lsm_hooks.h>\n#include <linux/bpf_lsm.h>\n#include <linux/kallsyms.h>\n#include <linux/bpf_verifier.h>\n#include <net/bpf_sk_storage.h>\n#include <linux/bpf_local_storage.h>\n#include <linux/btf_ids.h>\n#include <linux/ima.h>\n#include <linux/bpf-cgroup.h>\n\n \n#define LSM_HOOK(RET, DEFAULT, NAME, ...)\t\\\nnoinline RET bpf_lsm_##NAME(__VA_ARGS__)\t\\\n{\t\t\t\t\t\t\\\n\treturn DEFAULT;\t\t\t\t\\\n}\n\n#include <linux/lsm_hook_defs.h>\n#undef LSM_HOOK\n\n#define LSM_HOOK(RET, DEFAULT, NAME, ...) BTF_ID(func, bpf_lsm_##NAME)\nBTF_SET_START(bpf_lsm_hooks)\n#include <linux/lsm_hook_defs.h>\n#undef LSM_HOOK\nBTF_SET_END(bpf_lsm_hooks)\n\n \nBTF_SET_START(bpf_lsm_current_hooks)\n \n#ifdef CONFIG_SECURITY_NETWORK\nBTF_ID(func, bpf_lsm_sk_alloc_security)\nBTF_ID(func, bpf_lsm_sk_free_security)\n#endif\nBTF_SET_END(bpf_lsm_current_hooks)\n\n \nBTF_SET_START(bpf_lsm_locked_sockopt_hooks)\n#ifdef CONFIG_SECURITY_NETWORK\nBTF_ID(func, bpf_lsm_sock_graft)\nBTF_ID(func, bpf_lsm_inet_csk_clone)\nBTF_ID(func, bpf_lsm_inet_conn_established)\n#endif\nBTF_SET_END(bpf_lsm_locked_sockopt_hooks)\n\n \nBTF_SET_START(bpf_lsm_unlocked_sockopt_hooks)\n#ifdef CONFIG_SECURITY_NETWORK\nBTF_ID(func, bpf_lsm_socket_post_create)\nBTF_ID(func, bpf_lsm_socket_socketpair)\n#endif\nBTF_SET_END(bpf_lsm_unlocked_sockopt_hooks)\n\n#ifdef CONFIG_CGROUP_BPF\nvoid bpf_lsm_find_cgroup_shim(const struct bpf_prog *prog,\n\t\t\t     bpf_func_t *bpf_func)\n{\n\tconst struct btf_param *args __maybe_unused;\n\n\tif (btf_type_vlen(prog->aux->attach_func_proto) < 1 ||\n\t    btf_id_set_contains(&bpf_lsm_current_hooks,\n\t\t\t\tprog->aux->attach_btf_id)) {\n\t\t*bpf_func = __cgroup_bpf_run_lsm_current;\n\t\treturn;\n\t}\n\n#ifdef CONFIG_NET\n\targs = btf_params(prog->aux->attach_func_proto);\n\n\tif (args[0].type == btf_sock_ids[BTF_SOCK_TYPE_SOCKET])\n\t\t*bpf_func = __cgroup_bpf_run_lsm_socket;\n\telse if (args[0].type == btf_sock_ids[BTF_SOCK_TYPE_SOCK])\n\t\t*bpf_func = __cgroup_bpf_run_lsm_sock;\n\telse\n#endif\n\t\t*bpf_func = __cgroup_bpf_run_lsm_current;\n}\n#endif\n\nint bpf_lsm_verify_prog(struct bpf_verifier_log *vlog,\n\t\t\tconst struct bpf_prog *prog)\n{\n\tif (!prog->gpl_compatible) {\n\t\tbpf_log(vlog,\n\t\t\t\"LSM programs must have a GPL compatible license\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_id_set_contains(&bpf_lsm_hooks, prog->aux->attach_btf_id)) {\n\t\tbpf_log(vlog, \"attach_btf_id %u points to wrong type name %s\\n\",\n\t\t\tprog->aux->attach_btf_id, prog->aux->attach_func_name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n#define BPF_F_BRPM_OPTS_MASK\tBPF_F_BPRM_SECUREEXEC\n\nBPF_CALL_2(bpf_bprm_opts_set, struct linux_binprm *, bprm, u64, flags)\n{\n\tif (flags & ~BPF_F_BRPM_OPTS_MASK)\n\t\treturn -EINVAL;\n\n\tbprm->secureexec = (flags & BPF_F_BPRM_SECUREEXEC);\n\treturn 0;\n}\n\nBTF_ID_LIST_SINGLE(bpf_bprm_opts_set_btf_ids, struct, linux_binprm)\n\nstatic const struct bpf_func_proto bpf_bprm_opts_set_proto = {\n\t.func\t\t= bpf_bprm_opts_set,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_BTF_ID,\n\t.arg1_btf_id\t= &bpf_bprm_opts_set_btf_ids[0],\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nBPF_CALL_3(bpf_ima_inode_hash, struct inode *, inode, void *, dst, u32, size)\n{\n\treturn ima_inode_hash(inode, dst, size);\n}\n\nstatic bool bpf_ima_inode_hash_allowed(const struct bpf_prog *prog)\n{\n\treturn bpf_lsm_is_sleepable_hook(prog->aux->attach_btf_id);\n}\n\nBTF_ID_LIST_SINGLE(bpf_ima_inode_hash_btf_ids, struct, inode)\n\nstatic const struct bpf_func_proto bpf_ima_inode_hash_proto = {\n\t.func\t\t= bpf_ima_inode_hash,\n\t.gpl_only\t= false,\n\t.might_sleep\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_BTF_ID,\n\t.arg1_btf_id\t= &bpf_ima_inode_hash_btf_ids[0],\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n\t.allowed\t= bpf_ima_inode_hash_allowed,\n};\n\nBPF_CALL_3(bpf_ima_file_hash, struct file *, file, void *, dst, u32, size)\n{\n\treturn ima_file_hash(file, dst, size);\n}\n\nBTF_ID_LIST_SINGLE(bpf_ima_file_hash_btf_ids, struct, file)\n\nstatic const struct bpf_func_proto bpf_ima_file_hash_proto = {\n\t.func\t\t= bpf_ima_file_hash,\n\t.gpl_only\t= false,\n\t.might_sleep\t= true,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_BTF_ID,\n\t.arg1_btf_id\t= &bpf_ima_file_hash_btf_ids[0],\n\t.arg2_type\t= ARG_PTR_TO_UNINIT_MEM,\n\t.arg3_type\t= ARG_CONST_SIZE,\n\t.allowed\t= bpf_ima_inode_hash_allowed,\n};\n\nBPF_CALL_1(bpf_get_attach_cookie, void *, ctx)\n{\n\tstruct bpf_trace_run_ctx *run_ctx;\n\n\trun_ctx = container_of(current->bpf_ctx, struct bpf_trace_run_ctx, run_ctx);\n\treturn run_ctx->bpf_cookie;\n}\n\nstatic const struct bpf_func_proto bpf_get_attach_cookie_proto = {\n\t.func\t\t= bpf_get_attach_cookie,\n\t.gpl_only\t= false,\n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_CTX,\n};\n\nstatic const struct bpf_func_proto *\nbpf_lsm_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)\n{\n\tconst struct bpf_func_proto *func_proto;\n\n\tif (prog->expected_attach_type == BPF_LSM_CGROUP) {\n\t\tfunc_proto = cgroup_common_func_proto(func_id, prog);\n\t\tif (func_proto)\n\t\t\treturn func_proto;\n\t}\n\n\tswitch (func_id) {\n\tcase BPF_FUNC_inode_storage_get:\n\t\treturn &bpf_inode_storage_get_proto;\n\tcase BPF_FUNC_inode_storage_delete:\n\t\treturn &bpf_inode_storage_delete_proto;\n#ifdef CONFIG_NET\n\tcase BPF_FUNC_sk_storage_get:\n\t\treturn &bpf_sk_storage_get_proto;\n\tcase BPF_FUNC_sk_storage_delete:\n\t\treturn &bpf_sk_storage_delete_proto;\n#endif  \n\tcase BPF_FUNC_spin_lock:\n\t\treturn &bpf_spin_lock_proto;\n\tcase BPF_FUNC_spin_unlock:\n\t\treturn &bpf_spin_unlock_proto;\n\tcase BPF_FUNC_bprm_opts_set:\n\t\treturn &bpf_bprm_opts_set_proto;\n\tcase BPF_FUNC_ima_inode_hash:\n\t\treturn &bpf_ima_inode_hash_proto;\n\tcase BPF_FUNC_ima_file_hash:\n\t\treturn &bpf_ima_file_hash_proto;\n\tcase BPF_FUNC_get_attach_cookie:\n\t\treturn bpf_prog_has_trampoline(prog) ? &bpf_get_attach_cookie_proto : NULL;\n#ifdef CONFIG_NET\n\tcase BPF_FUNC_setsockopt:\n\t\tif (prog->expected_attach_type != BPF_LSM_CGROUP)\n\t\t\treturn NULL;\n\t\tif (btf_id_set_contains(&bpf_lsm_locked_sockopt_hooks,\n\t\t\t\t\tprog->aux->attach_btf_id))\n\t\t\treturn &bpf_sk_setsockopt_proto;\n\t\tif (btf_id_set_contains(&bpf_lsm_unlocked_sockopt_hooks,\n\t\t\t\t\tprog->aux->attach_btf_id))\n\t\t\treturn &bpf_unlocked_sk_setsockopt_proto;\n\t\treturn NULL;\n\tcase BPF_FUNC_getsockopt:\n\t\tif (prog->expected_attach_type != BPF_LSM_CGROUP)\n\t\t\treturn NULL;\n\t\tif (btf_id_set_contains(&bpf_lsm_locked_sockopt_hooks,\n\t\t\t\t\tprog->aux->attach_btf_id))\n\t\t\treturn &bpf_sk_getsockopt_proto;\n\t\tif (btf_id_set_contains(&bpf_lsm_unlocked_sockopt_hooks,\n\t\t\t\t\tprog->aux->attach_btf_id))\n\t\t\treturn &bpf_unlocked_sk_getsockopt_proto;\n\t\treturn NULL;\n#endif\n\tdefault:\n\t\treturn tracing_prog_func_proto(func_id, prog);\n\t}\n}\n\n \nBTF_SET_START(sleepable_lsm_hooks)\nBTF_ID(func, bpf_lsm_bpf)\nBTF_ID(func, bpf_lsm_bpf_map)\nBTF_ID(func, bpf_lsm_bpf_map_alloc_security)\nBTF_ID(func, bpf_lsm_bpf_map_free_security)\nBTF_ID(func, bpf_lsm_bpf_prog)\nBTF_ID(func, bpf_lsm_bprm_check_security)\nBTF_ID(func, bpf_lsm_bprm_committed_creds)\nBTF_ID(func, bpf_lsm_bprm_committing_creds)\nBTF_ID(func, bpf_lsm_bprm_creds_for_exec)\nBTF_ID(func, bpf_lsm_bprm_creds_from_file)\nBTF_ID(func, bpf_lsm_capget)\nBTF_ID(func, bpf_lsm_capset)\nBTF_ID(func, bpf_lsm_cred_prepare)\nBTF_ID(func, bpf_lsm_file_ioctl)\nBTF_ID(func, bpf_lsm_file_lock)\nBTF_ID(func, bpf_lsm_file_open)\nBTF_ID(func, bpf_lsm_file_receive)\n\n#ifdef CONFIG_SECURITY_NETWORK\nBTF_ID(func, bpf_lsm_inet_conn_established)\n#endif  \n\nBTF_ID(func, bpf_lsm_inode_create)\nBTF_ID(func, bpf_lsm_inode_free_security)\nBTF_ID(func, bpf_lsm_inode_getattr)\nBTF_ID(func, bpf_lsm_inode_getxattr)\nBTF_ID(func, bpf_lsm_inode_mknod)\nBTF_ID(func, bpf_lsm_inode_need_killpriv)\nBTF_ID(func, bpf_lsm_inode_post_setxattr)\nBTF_ID(func, bpf_lsm_inode_readlink)\nBTF_ID(func, bpf_lsm_inode_rename)\nBTF_ID(func, bpf_lsm_inode_rmdir)\nBTF_ID(func, bpf_lsm_inode_setattr)\nBTF_ID(func, bpf_lsm_inode_setxattr)\nBTF_ID(func, bpf_lsm_inode_symlink)\nBTF_ID(func, bpf_lsm_inode_unlink)\nBTF_ID(func, bpf_lsm_kernel_module_request)\nBTF_ID(func, bpf_lsm_kernel_read_file)\nBTF_ID(func, bpf_lsm_kernfs_init_security)\n\n#ifdef CONFIG_KEYS\nBTF_ID(func, bpf_lsm_key_free)\n#endif  \n\nBTF_ID(func, bpf_lsm_mmap_file)\nBTF_ID(func, bpf_lsm_netlink_send)\nBTF_ID(func, bpf_lsm_path_notify)\nBTF_ID(func, bpf_lsm_release_secctx)\nBTF_ID(func, bpf_lsm_sb_alloc_security)\nBTF_ID(func, bpf_lsm_sb_eat_lsm_opts)\nBTF_ID(func, bpf_lsm_sb_kern_mount)\nBTF_ID(func, bpf_lsm_sb_mount)\nBTF_ID(func, bpf_lsm_sb_remount)\nBTF_ID(func, bpf_lsm_sb_set_mnt_opts)\nBTF_ID(func, bpf_lsm_sb_show_options)\nBTF_ID(func, bpf_lsm_sb_statfs)\nBTF_ID(func, bpf_lsm_sb_umount)\nBTF_ID(func, bpf_lsm_settime)\n\n#ifdef CONFIG_SECURITY_NETWORK\nBTF_ID(func, bpf_lsm_socket_accept)\nBTF_ID(func, bpf_lsm_socket_bind)\nBTF_ID(func, bpf_lsm_socket_connect)\nBTF_ID(func, bpf_lsm_socket_create)\nBTF_ID(func, bpf_lsm_socket_getpeername)\nBTF_ID(func, bpf_lsm_socket_getpeersec_dgram)\nBTF_ID(func, bpf_lsm_socket_getsockname)\nBTF_ID(func, bpf_lsm_socket_getsockopt)\nBTF_ID(func, bpf_lsm_socket_listen)\nBTF_ID(func, bpf_lsm_socket_post_create)\nBTF_ID(func, bpf_lsm_socket_recvmsg)\nBTF_ID(func, bpf_lsm_socket_sendmsg)\nBTF_ID(func, bpf_lsm_socket_shutdown)\nBTF_ID(func, bpf_lsm_socket_socketpair)\n#endif  \n\nBTF_ID(func, bpf_lsm_syslog)\nBTF_ID(func, bpf_lsm_task_alloc)\nBTF_ID(func, bpf_lsm_current_getsecid_subj)\nBTF_ID(func, bpf_lsm_task_getsecid_obj)\nBTF_ID(func, bpf_lsm_task_prctl)\nBTF_ID(func, bpf_lsm_task_setscheduler)\nBTF_ID(func, bpf_lsm_task_to_inode)\nBTF_ID(func, bpf_lsm_userns_create)\nBTF_SET_END(sleepable_lsm_hooks)\n\nBTF_SET_START(untrusted_lsm_hooks)\nBTF_ID(func, bpf_lsm_bpf_map_free_security)\nBTF_ID(func, bpf_lsm_bpf_prog_alloc_security)\nBTF_ID(func, bpf_lsm_bpf_prog_free_security)\nBTF_ID(func, bpf_lsm_file_alloc_security)\nBTF_ID(func, bpf_lsm_file_free_security)\n#ifdef CONFIG_SECURITY_NETWORK\nBTF_ID(func, bpf_lsm_sk_alloc_security)\nBTF_ID(func, bpf_lsm_sk_free_security)\n#endif  \nBTF_ID(func, bpf_lsm_task_free)\nBTF_SET_END(untrusted_lsm_hooks)\n\nbool bpf_lsm_is_sleepable_hook(u32 btf_id)\n{\n\treturn btf_id_set_contains(&sleepable_lsm_hooks, btf_id);\n}\n\nbool bpf_lsm_is_trusted(const struct bpf_prog *prog)\n{\n\treturn !btf_id_set_contains(&untrusted_lsm_hooks, prog->aux->attach_btf_id);\n}\n\nconst struct bpf_prog_ops lsm_prog_ops = {\n};\n\nconst struct bpf_verifier_ops lsm_verifier_ops = {\n\t.get_func_proto = bpf_lsm_func_proto,\n\t.is_valid_access = btf_ctx_access,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}