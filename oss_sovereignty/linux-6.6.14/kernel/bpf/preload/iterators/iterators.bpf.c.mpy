{
  "module_name": "iterators.bpf.c",
  "hash_id": "7a59bd33ad624b75c94f56d3944a135fd117811e4e686c50e735203d9e710073",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/preload/iterators/iterators.bpf.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_core_read.h>\n\n#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)\nstruct seq_file;\nstruct bpf_iter_meta {\n\tstruct seq_file *seq;\n\t__u64 session_id;\n\t__u64 seq_num;\n};\n\nstruct bpf_map {\n\t__u32 id;\n\tchar name[16];\n\t__u32 max_entries;\n};\n\nstruct bpf_iter__bpf_map {\n\tstruct bpf_iter_meta *meta;\n\tstruct bpf_map *map;\n};\n\nstruct btf_type {\n\t__u32 name_off;\n};\n\nstruct btf_header {\n\t__u32   str_len;\n};\n\nstruct btf {\n\tconst char *strings;\n\tstruct btf_type **types;\n\tstruct btf_header hdr;\n};\n\nstruct bpf_prog_aux {\n\t__u32 id;\n\tchar name[16];\n\tconst char *attach_func_name;\n\tstruct bpf_prog *dst_prog;\n\tstruct bpf_func_info *func_info;\n\tstruct btf *btf;\n};\n\nstruct bpf_prog {\n\tstruct bpf_prog_aux *aux;\n};\n\nstruct bpf_iter__bpf_prog {\n\tstruct bpf_iter_meta *meta;\n\tstruct bpf_prog *prog;\n};\n#pragma clang attribute pop\n\nstatic const char *get_name(struct btf *btf, long btf_id, const char *fallback)\n{\n\tstruct btf_type **types, *t;\n\tunsigned int name_off;\n\tconst char *str;\n\n\tif (!btf)\n\t\treturn fallback;\n\tstr = btf->strings;\n\ttypes = btf->types;\n\tbpf_probe_read_kernel(&t, sizeof(t), types + btf_id);\n\tname_off = BPF_CORE_READ(t, name_off);\n\tif (name_off >= btf->hdr.str_len)\n\t\treturn fallback;\n\treturn str + name_off;\n}\n\n__s64 bpf_map_sum_elem_count(struct bpf_map *map) __ksym;\n\nSEC(\"iter/bpf_map\")\nint dump_bpf_map(struct bpf_iter__bpf_map *ctx)\n{\n\tstruct seq_file *seq = ctx->meta->seq;\n\t__u64 seq_num = ctx->meta->seq_num;\n\tstruct bpf_map *map = ctx->map;\n\n\tif (!map)\n\t\treturn 0;\n\n\tif (seq_num == 0)\n\t\tBPF_SEQ_PRINTF(seq, \"  id name             max_entries  cur_entries\\n\");\n\n\tBPF_SEQ_PRINTF(seq, \"%4u %-16s  %10d   %10lld\\n\",\n\t\t       map->id, map->name, map->max_entries,\n\t\t       bpf_map_sum_elem_count(map));\n\n\treturn 0;\n}\n\nSEC(\"iter/bpf_prog\")\nint dump_bpf_prog(struct bpf_iter__bpf_prog *ctx)\n{\n\tstruct seq_file *seq = ctx->meta->seq;\n\t__u64 seq_num = ctx->meta->seq_num;\n\tstruct bpf_prog *prog = ctx->prog;\n\tstruct bpf_prog_aux *aux;\n\n\tif (!prog)\n\t\treturn 0;\n\n\taux = prog->aux;\n\tif (seq_num == 0)\n\t\tBPF_SEQ_PRINTF(seq, \"  id name             attached\\n\");\n\n\tBPF_SEQ_PRINTF(seq, \"%4u %-16s %s %s\\n\", aux->id,\n\t\t       get_name(aux->btf, aux->func_info[0].type_id, aux->name),\n\t\t       aux->attach_func_name, aux->dst_prog->aux->name);\n\treturn 0;\n}\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}