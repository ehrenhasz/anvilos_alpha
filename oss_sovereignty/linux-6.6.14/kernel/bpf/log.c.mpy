{
  "module_name": "log.c",
  "hash_id": "60d2fcc331f3da50ae0405952d3bb5a7a887c575965275af39642f6e7936ba78",
  "original_prompt": "Ingested from linux-6.6.14/kernel/bpf/log.c",
  "human_readable_source": "\n \n#include <uapi/linux/btf.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bpf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/math64.h>\n\nstatic bool bpf_verifier_log_attr_valid(const struct bpf_verifier_log *log)\n{\n\t \n\tif (!!log->ubuf != !!log->len_total)\n\t\treturn false;\n\t \n\tif (log->ubuf && log->level == 0)\n\t\treturn false;\n\tif (log->level & ~BPF_LOG_MASK)\n\t\treturn false;\n\tif (log->len_total > UINT_MAX >> 2)\n\t\treturn false;\n\treturn true;\n}\n\nint bpf_vlog_init(struct bpf_verifier_log *log, u32 log_level,\n\t\t  char __user *log_buf, u32 log_size)\n{\n\tlog->level = log_level;\n\tlog->ubuf = log_buf;\n\tlog->len_total = log_size;\n\n\t \n\tif (!bpf_verifier_log_attr_valid(log))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void bpf_vlog_update_len_max(struct bpf_verifier_log *log, u32 add_len)\n{\n\t \n\tu64 len = log->end_pos + add_len;\n\n\t \n\tif (len > UINT_MAX)\n\t\tlog->len_max = UINT_MAX;\n\telse if (len > log->len_max)\n\t\tlog->len_max = len;\n}\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tu64 cur_pos;\n\tu32 new_n, n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tif (log->level == BPF_LOG_KERNEL) {\n\t\tbool newline = n > 0 && log->kbuf[n - 1] == '\\n';\n\n\t\tpr_err(\"BPF: %s%s\", log->kbuf, newline ? \"\" : \"\\n\");\n\t\treturn;\n\t}\n\n\tn += 1;  \n\tbpf_vlog_update_len_max(log, n);\n\n\tif (log->level & BPF_LOG_FIXED) {\n\t\t \n\t\tnew_n = 0;\n\t\tif (log->end_pos < log->len_total) {\n\t\t\tnew_n = min_t(u32, log->len_total - log->end_pos, n);\n\t\t\tlog->kbuf[new_n - 1] = '\\0';\n\t\t}\n\n\t\tcur_pos = log->end_pos;\n\t\tlog->end_pos += n - 1;  \n\n\t\tif (log->ubuf && new_n &&\n\t\t    copy_to_user(log->ubuf + cur_pos, log->kbuf, new_n))\n\t\t\tgoto fail;\n\t} else {\n\t\tu64 new_end, new_start;\n\t\tu32 buf_start, buf_end, new_n;\n\n\t\tnew_end = log->end_pos + n;\n\t\tif (new_end - log->start_pos >= log->len_total)\n\t\t\tnew_start = new_end - log->len_total;\n\t\telse\n\t\t\tnew_start = log->start_pos;\n\n\t\tlog->start_pos = new_start;\n\t\tlog->end_pos = new_end - 1;  \n\n\t\tif (!log->ubuf)\n\t\t\treturn;\n\n\t\tnew_n = min(n, log->len_total);\n\t\tcur_pos = new_end - new_n;\n\t\tdiv_u64_rem(cur_pos, log->len_total, &buf_start);\n\t\tdiv_u64_rem(new_end, log->len_total, &buf_end);\n\t\t \n\t\tif (buf_end == 0)\n\t\t\tbuf_end = log->len_total;\n\n\t\t \n\t\tif (buf_start < buf_end) {\n\t\t\t \n\t\t\tif (copy_to_user(log->ubuf + buf_start,\n\t\t\t\t\t log->kbuf + n - new_n,\n\t\t\t\t\t buf_end - buf_start))\n\t\t\t\tgoto fail;\n\t\t} else {\n\t\t\t \n\t\t\tif (copy_to_user(log->ubuf + buf_start,\n\t\t\t\t\t log->kbuf + n - new_n,\n\t\t\t\t\t log->len_total - buf_start))\n\t\t\t\tgoto fail;\n\t\t\tif (copy_to_user(log->ubuf,\n\t\t\t\t\t log->kbuf + n - buf_end,\n\t\t\t\t\t buf_end))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn;\nfail:\n\tlog->ubuf = NULL;\n}\n\nvoid bpf_vlog_reset(struct bpf_verifier_log *log, u64 new_pos)\n{\n\tchar zero = 0;\n\tu32 pos;\n\n\tif (WARN_ON_ONCE(new_pos > log->end_pos))\n\t\treturn;\n\n\tif (!bpf_verifier_log_needed(log) || log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\n\t \n\tlog->end_pos = new_pos;\n\tif (log->end_pos < log->start_pos)\n\t\tlog->start_pos = log->end_pos;\n\n\tif (!log->ubuf)\n\t\treturn;\n\n\tif (log->level & BPF_LOG_FIXED)\n\t\tpos = log->end_pos + 1;\n\telse\n\t\tdiv_u64_rem(new_pos, log->len_total, &pos);\n\n\tif (pos < log->len_total && put_user(zero, log->ubuf + pos))\n\t\tlog->ubuf = NULL;\n}\n\nstatic void bpf_vlog_reverse_kbuf(char *buf, int len)\n{\n\tint i, j;\n\n\tfor (i = 0, j = len - 1; i < j; i++, j--)\n\t\tswap(buf[i], buf[j]);\n}\n\nstatic int bpf_vlog_reverse_ubuf(struct bpf_verifier_log *log, int start, int end)\n{\n\t \n\tint n = sizeof(log->kbuf) / 2, nn;\n\tchar *lbuf = log->kbuf, *rbuf = log->kbuf + n;\n\n\t \n\twhile (end - start > 1) {\n\t\tnn = min(n, (end - start ) / 2);\n\n\t\tif (copy_from_user(lbuf, log->ubuf + start, nn))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(rbuf, log->ubuf + end - nn, nn))\n\t\t\treturn -EFAULT;\n\n\t\tbpf_vlog_reverse_kbuf(lbuf, nn);\n\t\tbpf_vlog_reverse_kbuf(rbuf, nn);\n\n\t\t \n\t\tif (copy_to_user(log->ubuf + start, rbuf, nn))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(log->ubuf + end - nn, lbuf, nn))\n\t\t\treturn -EFAULT;\n\n\t\tstart += nn;\n\t\tend -= nn;\n\t}\n\n\treturn 0;\n}\n\nint bpf_vlog_finalize(struct bpf_verifier_log *log, u32 *log_size_actual)\n{\n\tu32 sublen;\n\tint err;\n\n\t*log_size_actual = 0;\n\tif (!log || log->level == 0 || log->level == BPF_LOG_KERNEL)\n\t\treturn 0;\n\n\tif (!log->ubuf)\n\t\tgoto skip_log_rotate;\n\t \n\tif (log->start_pos == 0)\n\t\tgoto skip_log_rotate;\n\n\t \n\n\t \n\tdiv_u64_rem(log->start_pos, log->len_total, &sublen);\n\tsublen = log->len_total - sublen;\n\n\terr = bpf_vlog_reverse_ubuf(log, 0, log->len_total);\n\terr = err ?: bpf_vlog_reverse_ubuf(log, 0, sublen);\n\terr = err ?: bpf_vlog_reverse_ubuf(log, sublen, log->len_total);\n\tif (err)\n\t\tlog->ubuf = NULL;\n\nskip_log_rotate:\n\t*log_size_actual = log->len_max;\n\n\t \n\tif (!!log->ubuf != !!log->len_total)\n\t\treturn -EFAULT;\n\n\t \n\tif (log->ubuf && log->len_max > log->len_total)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\n \n__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(bpf_verifier_log_write);\n\n__printf(2, 3) void bpf_log(struct bpf_verifier_log *log,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(bpf_log);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}