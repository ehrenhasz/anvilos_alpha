{
  "module_name": "timeconst.bc",
  "hash_id": "f27a270da894e3019711dda7e44730537db01e94f4838ad56a5cfe6a9ea88000",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/timeconst.bc",
  "human_readable_source": "/* SPDX-License-Identifier: GPL-2.0 */\n\nscale=0\n\ndefine gcd(a,b) {\n\tauto t;\n\twhile (b) {\n\t\tt = b;\n\t\tb = a % b;\n\t\ta = t;\n\t}\n\treturn a;\n}\n\n/* Division by reciprocal multiplication. */\ndefine fmul(b,n,d) {\n       return (2^b*n+d-1)/d;\n}\n\n/* Adjustment factor when a ceiling value is used.  Use as:\n   (imul * n) + (fmulxx * n + fadjxx) >> xx) */\ndefine fadj(b,n,d) {\n\tauto v;\n\td = d/gcd(n,d);\n\tv = 2^b*(d-1)/d;\n\treturn v;\n}\n\n/* Compute the appropriate mul/adj values as well as a shift count,\n   which brings the mul value into the range 2^b-1 <= x < 2^b.  Such\n   a shift value will be correct in the signed integer range and off\n   by at most one in the upper half of the unsigned range. */\ndefine fmuls(b,n,d) {\n\tauto s, m;\n\tfor (s = 0; 1; s++) {\n\t\tm = fmul(s,n,d);\n\t\tif (m >= 2^(b-1))\n\t\t\treturn s;\n\t}\n\treturn 0;\n}\n\ndefine timeconst(hz) {\n\tprint \"/* Automatically generated by kernel/time/timeconst.bc */\\n\"\n\tprint \"/* Time conversion constants for HZ == \", hz, \" */\\n\"\n\tprint \"\\n\"\n\n\tprint \"#ifndef KERNEL_TIMECONST_H\\n\"\n\tprint \"#define KERNEL_TIMECONST_H\\n\\n\"\n\n\tprint \"#include <linux/param.h>\\n\"\n\tprint \"#include <linux/types.h>\\n\\n\"\n\n\tprint \"#if HZ != \", hz, \"\\n\"\n\tprint \"#error \\qinclude/generated/timeconst.h has the wrong HZ value!\\q\\n\"\n\tprint \"#endif\\n\\n\"\n\n\tif (hz < 2) {\n\t\tprint \"#error Totally bogus HZ value!\\n\"\n\t} else {\n\t\ts=fmuls(32,1000,hz)\n\t\tobase=16\n\t\tprint \"#define HZ_TO_MSEC_MUL32\\tU64_C(0x\", fmul(s,1000,hz), \")\\n\"\n\t\tprint \"#define HZ_TO_MSEC_ADJ32\\tU64_C(0x\", fadj(s,1000,hz), \")\\n\"\n\t\tobase=10\n\t\tprint \"#define HZ_TO_MSEC_SHR32\\t\", s, \"\\n\"\n\n\t\ts=fmuls(32,hz,1000)\n\t\tobase=16\n\t\tprint \"#define MSEC_TO_HZ_MUL32\\tU64_C(0x\", fmul(s,hz,1000), \")\\n\"\n\t\tprint \"#define MSEC_TO_HZ_ADJ32\\tU64_C(0x\", fadj(s,hz,1000), \")\\n\"\n\t\tobase=10\n\t\tprint \"#define MSEC_TO_HZ_SHR32\\t\", s, \"\\n\"\n\n\t\tobase=10\n\t\tcd=gcd(hz,1000)\n\t\tprint \"#define HZ_TO_MSEC_NUM\\t\\t\", 1000/cd, \"\\n\"\n\t\tprint \"#define HZ_TO_MSEC_DEN\\t\\t\", hz/cd, \"\\n\"\n\t\tprint \"#define MSEC_TO_HZ_NUM\\t\\t\", hz/cd, \"\\n\"\n\t\tprint \"#define MSEC_TO_HZ_DEN\\t\\t\", 1000/cd, \"\\n\"\n\t\tprint \"\\n\"\n\n\t\ts=fmuls(32,1000000,hz)\n\t\tobase=16\n\t\tprint \"#define HZ_TO_USEC_MUL32\\tU64_C(0x\", fmul(s,1000000,hz), \")\\n\"\n\t\tprint \"#define HZ_TO_USEC_ADJ32\\tU64_C(0x\", fadj(s,1000000,hz), \")\\n\"\n\t\tobase=10\n\t\tprint \"#define HZ_TO_USEC_SHR32\\t\", s, \"\\n\"\n\n\t\ts=fmuls(32,hz,1000000)\n\t\tobase=16\n\t\tprint \"#define USEC_TO_HZ_MUL32\\tU64_C(0x\", fmul(s,hz,1000000), \")\\n\"\n\t\tprint \"#define USEC_TO_HZ_ADJ32\\tU64_C(0x\", fadj(s,hz,1000000), \")\\n\"\n\t\tobase=10\n\t\tprint \"#define USEC_TO_HZ_SHR32\\t\", s, \"\\n\"\n\n\t\tobase=10\n\t\tcd=gcd(hz,1000000)\n\t\tprint \"#define HZ_TO_USEC_NUM\\t\\t\", 1000000/cd, \"\\n\"\n\t\tprint \"#define HZ_TO_USEC_DEN\\t\\t\", hz/cd, \"\\n\"\n\t\tprint \"#define USEC_TO_HZ_NUM\\t\\t\", hz/cd, \"\\n\"\n\t\tprint \"#define USEC_TO_HZ_DEN\\t\\t\", 1000000/cd, \"\\n\"\n\n\t\tcd=gcd(hz,1000000000)\n\t\tprint \"#define HZ_TO_NSEC_NUM\\t\\t\", 1000000000/cd, \"\\n\"\n\t\tprint \"#define HZ_TO_NSEC_DEN\\t\\t\", hz/cd, \"\\n\"\n\t\tprint \"#define NSEC_TO_HZ_NUM\\t\\t\", hz/cd, \"\\n\"\n\t\tprint \"#define NSEC_TO_HZ_DEN\\t\\t\", 1000000000/cd, \"\\n\"\n\t\tprint \"\\n\"\n\n\t\tprint \"#endif /* KERNEL_TIMECONST_H */\\n\"\n\t}\n\thalt\n}\n\nhz = read();\ntimeconst(hz)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}