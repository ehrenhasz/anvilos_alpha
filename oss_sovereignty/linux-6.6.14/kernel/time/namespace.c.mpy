{
  "module_name": "namespace.c",
  "hash_id": "c9806e2309734256021e2342bc57b0f2fbf9e1ec463b4c4a9ef5696b33fe566b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/namespace.c",
  "human_readable_source": "\n \n\n#include <linux/time_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/seq_file.h>\n#include <linux/proc_ns.h>\n#include <linux/export.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n\n#include <vdso/datapage.h>\n\nktime_t do_timens_ktime_to_host(clockid_t clockid, ktime_t tim,\n\t\t\t\tstruct timens_offsets *ns_offsets)\n{\n\tktime_t offset;\n\n\tswitch (clockid) {\n\tcase CLOCK_MONOTONIC:\n\t\toffset = timespec64_to_ktime(ns_offsets->monotonic);\n\t\tbreak;\n\tcase CLOCK_BOOTTIME:\n\tcase CLOCK_BOOTTIME_ALARM:\n\t\toffset = timespec64_to_ktime(ns_offsets->boottime);\n\t\tbreak;\n\tdefault:\n\t\treturn tim;\n\t}\n\n\t \n\tif (tim < offset) {\n\t\t \n\t\ttim = 0;\n\t} else {\n\t\ttim = ktime_sub(tim, offset);\n\t\tif (unlikely(tim > KTIME_MAX))\n\t\t\ttim = KTIME_MAX;\n\t}\n\n\treturn tim;\n}\n\nstatic struct ucounts *inc_time_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_TIME_NAMESPACES);\n}\n\nstatic void dec_time_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_TIME_NAMESPACES);\n}\n\n \nstatic struct time_namespace *clone_time_ns(struct user_namespace *user_ns,\n\t\t\t\t\t  struct time_namespace *old_ns)\n{\n\tstruct time_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n\tucounts = inc_time_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto fail;\n\n\terr = -ENOMEM;\n\tns = kmalloc(sizeof(*ns), GFP_KERNEL_ACCOUNT);\n\tif (!ns)\n\t\tgoto fail_dec;\n\n\trefcount_set(&ns->ns.count, 1);\n\n\tns->vvar_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!ns->vvar_page)\n\t\tgoto fail_free;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free_page;\n\n\tns->ucounts = ucounts;\n\tns->ns.ops = &timens_operations;\n\tns->user_ns = get_user_ns(user_ns);\n\tns->offsets = old_ns->offsets;\n\tns->frozen_offsets = false;\n\treturn ns;\n\nfail_free_page:\n\t__free_page(ns->vvar_page);\nfail_free:\n\tkfree(ns);\nfail_dec:\n\tdec_time_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}\n\n \nstruct time_namespace *copy_time_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct time_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWTIME))\n\t\treturn get_time_ns(old_ns);\n\n\treturn clone_time_ns(user_ns, old_ns);\n}\n\nstatic struct timens_offset offset_from_ts(struct timespec64 off)\n{\n\tstruct timens_offset ret;\n\n\tret.sec = off.tv_sec;\n\tret.nsec = off.tv_nsec;\n\n\treturn ret;\n}\n\n \nstatic void timens_setup_vdso_data(struct vdso_data *vdata,\n\t\t\t\t   struct time_namespace *ns)\n{\n\tstruct timens_offset *offset = vdata->offset;\n\tstruct timens_offset monotonic = offset_from_ts(ns->offsets.monotonic);\n\tstruct timens_offset boottime = offset_from_ts(ns->offsets.boottime);\n\n\tvdata->seq\t\t\t= 1;\n\tvdata->clock_mode\t\t= VDSO_CLOCKMODE_TIMENS;\n\toffset[CLOCK_MONOTONIC]\t\t= monotonic;\n\toffset[CLOCK_MONOTONIC_RAW]\t= monotonic;\n\toffset[CLOCK_MONOTONIC_COARSE]\t= monotonic;\n\toffset[CLOCK_BOOTTIME]\t\t= boottime;\n\toffset[CLOCK_BOOTTIME_ALARM]\t= boottime;\n}\n\nstruct page *find_timens_vvar_page(struct vm_area_struct *vma)\n{\n\tif (likely(vma->vm_mm == current->mm))\n\t\treturn current->nsproxy->time_ns->vvar_page;\n\n\t \n\n\tWARN(1, \"vvar_page accessed remotely\");\n\n\treturn NULL;\n}\n\n \nstatic DEFINE_MUTEX(offset_lock);\n\nstatic void timens_set_vvar_page(struct task_struct *task,\n\t\t\t\tstruct time_namespace *ns)\n{\n\tstruct vdso_data *vdata;\n\tunsigned int i;\n\n\tif (ns == &init_time_ns)\n\t\treturn;\n\n\t \n\tif (likely(ns->frozen_offsets))\n\t\treturn;\n\n\tmutex_lock(&offset_lock);\n\t \n\tif (ns->frozen_offsets)\n\t\tgoto out;\n\n\tns->frozen_offsets = true;\n\tvdata = arch_get_vdso_data(page_address(ns->vvar_page));\n\n\tfor (i = 0; i < CS_BASES; i++)\n\t\ttimens_setup_vdso_data(&vdata[i], ns);\n\nout:\n\tmutex_unlock(&offset_lock);\n}\n\nvoid free_time_ns(struct time_namespace *ns)\n{\n\tdec_time_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\t__free_page(ns->vvar_page);\n\tkfree(ns);\n}\n\nstatic struct time_namespace *to_time_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct time_namespace, ns);\n}\n\nstatic struct ns_common *timens_get(struct task_struct *task)\n{\n\tstruct time_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->time_ns;\n\t\tget_time_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic struct ns_common *timens_for_children_get(struct task_struct *task)\n{\n\tstruct time_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->time_ns_for_children;\n\t\tget_time_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic void timens_put(struct ns_common *ns)\n{\n\tput_time_ns(to_time_ns(ns));\n}\n\nvoid timens_commit(struct task_struct *tsk, struct time_namespace *ns)\n{\n\ttimens_set_vvar_page(tsk, ns);\n\tvdso_join_timens(tsk, ns);\n}\n\nstatic int timens_install(struct nsset *nsset, struct ns_common *new)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct time_namespace *ns = to_time_ns(new);\n\n\tif (!current_is_single_threaded())\n\t\treturn -EUSERS;\n\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tget_time_ns(ns);\n\tput_time_ns(nsproxy->time_ns);\n\tnsproxy->time_ns = ns;\n\n\tget_time_ns(ns);\n\tput_time_ns(nsproxy->time_ns_for_children);\n\tnsproxy->time_ns_for_children = ns;\n\treturn 0;\n}\n\nvoid timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk)\n{\n\tstruct ns_common *nsc = &nsproxy->time_ns_for_children->ns;\n\tstruct time_namespace *ns = to_time_ns(nsc);\n\n\t \n\tif (nsproxy->time_ns == nsproxy->time_ns_for_children)\n\t\treturn;\n\n\tget_time_ns(ns);\n\tput_time_ns(nsproxy->time_ns);\n\tnsproxy->time_ns = ns;\n\n\ttimens_commit(tsk, ns);\n}\n\nstatic struct user_namespace *timens_owner(struct ns_common *ns)\n{\n\treturn to_time_ns(ns)->user_ns;\n}\n\nstatic void show_offset(struct seq_file *m, int clockid, struct timespec64 *ts)\n{\n\tchar *clock;\n\n\tswitch (clockid) {\n\tcase CLOCK_BOOTTIME:\n\t\tclock = \"boottime\";\n\t\tbreak;\n\tcase CLOCK_MONOTONIC:\n\t\tclock = \"monotonic\";\n\t\tbreak;\n\tdefault:\n\t\tclock = \"unknown\";\n\t\tbreak;\n\t}\n\tseq_printf(m, \"%-10s %10lld %9ld\\n\", clock, ts->tv_sec, ts->tv_nsec);\n}\n\nvoid proc_timens_show_offsets(struct task_struct *p, struct seq_file *m)\n{\n\tstruct ns_common *ns;\n\tstruct time_namespace *time_ns;\n\n\tns = timens_for_children_get(p);\n\tif (!ns)\n\t\treturn;\n\ttime_ns = to_time_ns(ns);\n\n\tshow_offset(m, CLOCK_MONOTONIC, &time_ns->offsets.monotonic);\n\tshow_offset(m, CLOCK_BOOTTIME, &time_ns->offsets.boottime);\n\tput_time_ns(time_ns);\n}\n\nint proc_timens_set_offset(struct file *file, struct task_struct *p,\n\t\t\t   struct proc_timens_offset *offsets, int noffsets)\n{\n\tstruct ns_common *ns;\n\tstruct time_namespace *time_ns;\n\tstruct timespec64 tp;\n\tint i, err;\n\n\tns = timens_for_children_get(p);\n\tif (!ns)\n\t\treturn -ESRCH;\n\ttime_ns = to_time_ns(ns);\n\n\tif (!file_ns_capable(file, time_ns->user_ns, CAP_SYS_TIME)) {\n\t\tput_time_ns(time_ns);\n\t\treturn -EPERM;\n\t}\n\n\tfor (i = 0; i < noffsets; i++) {\n\t\tstruct proc_timens_offset *off = &offsets[i];\n\n\t\tswitch (off->clockid) {\n\t\tcase CLOCK_MONOTONIC:\n\t\t\tktime_get_ts64(&tp);\n\t\t\tbreak;\n\t\tcase CLOCK_BOOTTIME:\n\t\t\tktime_get_boottime_ts64(&tp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -ERANGE;\n\n\t\tif (off->val.tv_sec > KTIME_SEC_MAX ||\n\t\t    off->val.tv_sec < -KTIME_SEC_MAX)\n\t\t\tgoto out;\n\n\t\ttp = timespec64_add(tp, off->val);\n\t\t \n\t\tif (tp.tv_sec < 0 || tp.tv_sec > KTIME_SEC_MAX / 2)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&offset_lock);\n\tif (time_ns->frozen_offsets) {\n\t\terr = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\terr = 0;\n\t \n\tfor (i = 0; i < noffsets; i++) {\n\t\tstruct proc_timens_offset *off = &offsets[i];\n\t\tstruct timespec64 *offset = NULL;\n\n\t\tswitch (off->clockid) {\n\t\tcase CLOCK_MONOTONIC:\n\t\t\toffset = &time_ns->offsets.monotonic;\n\t\t\tbreak;\n\t\tcase CLOCK_BOOTTIME:\n\t\t\toffset = &time_ns->offsets.boottime;\n\t\t\tbreak;\n\t\t}\n\n\t\t*offset = off->val;\n\t}\n\nout_unlock:\n\tmutex_unlock(&offset_lock);\nout:\n\tput_time_ns(time_ns);\n\n\treturn err;\n}\n\nconst struct proc_ns_operations timens_operations = {\n\t.name\t\t= \"time\",\n\t.type\t\t= CLONE_NEWTIME,\n\t.get\t\t= timens_get,\n\t.put\t\t= timens_put,\n\t.install\t= timens_install,\n\t.owner\t\t= timens_owner,\n};\n\nconst struct proc_ns_operations timens_for_children_operations = {\n\t.name\t\t= \"time_for_children\",\n\t.real_ns_name\t= \"time\",\n\t.type\t\t= CLONE_NEWTIME,\n\t.get\t\t= timens_for_children_get,\n\t.put\t\t= timens_put,\n\t.install\t= timens_install,\n\t.owner\t\t= timens_owner,\n};\n\nstruct time_namespace init_time_ns = {\n\t.ns.count\t= REFCOUNT_INIT(3),\n\t.user_ns\t= &init_user_ns,\n\t.ns.inum\t= PROC_TIME_INIT_INO,\n\t.ns.ops\t\t= &timens_operations,\n\t.frozen_offsets\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}