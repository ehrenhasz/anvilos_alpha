{
  "module_name": "ntp.c",
  "hash_id": "b8ab5df0034f47ee9453400ae0c1483a6bbdaad3ef1e1ca602e4dc2362753c4d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/ntp.c",
  "human_readable_source": "\n \n#include <linux/capability.h>\n#include <linux/clocksource.h>\n#include <linux/workqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/jiffies.h>\n#include <linux/math64.h>\n#include <linux/timex.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/rtc.h>\n#include <linux/audit.h>\n\n#include \"ntp_internal.h\"\n#include \"timekeeping_internal.h\"\n\n\n \n\n\n \nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\n\n \nunsigned long\t\t\ttick_nsec;\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\n\n#define SECS_PER_DAY\t\t86400\n#define MAX_TICKADJ\t\t500LL\t\t \n#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)\n#define MAX_TAI_OFFSET\t\t100000\n\n \n\n \nstatic int\t\t\ttime_state = TIME_OK;\n\n \nstatic int\t\t\ttime_status = STA_UNSYNC;\n\n \nstatic s64\t\t\ttime_offset;\n\n \nstatic long\t\t\ttime_constant = 2;\n\n \nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\n \nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\n\n \nstatic s64\t\t\ttime_freq;\n\n \nstatic time64_t\t\ttime_reftime;\n\nstatic long\t\t\ttime_adjust;\n\n \nstatic s64\t\t\tntp_tick_adj;\n\n \nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\n#ifdef CONFIG_NTP_PPS\n\n \n#define PPS_VALID\t10\t \n#define PPS_POPCORN\t4\t \n#define PPS_INTMIN\t2\t \n#define PPS_INTMAX\t8\t \n#define PPS_INTCOUNT\t4\t \n#define PPS_MAXWANDER\t100000\t \n\nstatic int pps_valid;\t\t \nstatic long pps_tf[3];\t\t \nstatic long pps_jitter;\t\t \nstatic struct timespec64 pps_fbase;  \nstatic int pps_shift;\t\t \nstatic int pps_intcnt;\t\t \nstatic s64 pps_freq;\t\t \nstatic long pps_stabil;\t\t \n\n \nstatic long pps_calcnt;\t\t \nstatic long pps_jitcnt;\t\t \nstatic long pps_stbcnt;\t\t \nstatic long pps_errcnt;\t\t \n\n\n \nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}\n\nstatic inline void pps_reset_freq_interval(void)\n{\n\t \n\tpps_shift = PPS_INTMIN;\n\tpps_intcnt = 0;\n}\n\n \nstatic inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}\n\n \nstatic inline void pps_dec_valid(void)\n{\n\tif (pps_valid > 0)\n\t\tpps_valid--;\n\telse {\n\t\ttime_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |\n\t\t\t\t STA_PPSWANDER | STA_PPSERROR);\n\t\tpps_clear();\n\t}\n}\n\nstatic inline void pps_set_freq(s64 freq)\n{\n\tpps_freq = freq;\n}\n\nstatic inline int is_error_status(int status)\n{\n\treturn (status & (STA_UNSYNC|STA_CLOCKERR))\n\t\t \n\t\t|| ((status & (STA_PPSFREQ|STA_PPSTIME))\n\t\t\t&& !(status & STA_PPSSIGNAL))\n\t\t \n\t\t|| ((status & (STA_PPSTIME|STA_PPSJITTER))\n\t\t\t== (STA_PPSTIME|STA_PPSJITTER))\n\t\t \n\t\t|| ((status & STA_PPSFREQ)\n\t\t\t&& (status & (STA_PPSWANDER|STA_PPSERROR)));\n}\n\nstatic inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\ttxc->ppsfreq\t   = shift_right((pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->jitter\t   = pps_jitter;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->jitter = pps_jitter / NSEC_PER_USEC;\n\ttxc->shift\t   = pps_shift;\n\ttxc->stabil\t   = pps_stabil;\n\ttxc->jitcnt\t   = pps_jitcnt;\n\ttxc->calcnt\t   = pps_calcnt;\n\ttxc->errcnt\t   = pps_errcnt;\n\ttxc->stbcnt\t   = pps_stbcnt;\n}\n\n#else  \n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}\n\nstatic inline void pps_reset_freq_interval(void) {}\nstatic inline void pps_clear(void) {}\nstatic inline void pps_dec_valid(void) {}\nstatic inline void pps_set_freq(s64 freq) {}\n\nstatic inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}\n\nstatic inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\t \n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}\n\n#endif  \n\n\n \nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}\n\n\n \n\n \nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t \n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}\n\nstatic inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t \n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t \n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t \n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t \n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}\n\n \nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t \n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t \n\tpps_clear();\n}\n\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}\n\n \nktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}\n\n \nint second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t \n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t \n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t \n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t \n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}\n\n#if defined(CONFIG_GENERIC_CMOS_UPDATE) || defined(CONFIG_RTC_SYSTOHC)\nstatic void sync_hw_clock(struct work_struct *work);\nstatic DECLARE_WORK(sync_work, sync_hw_clock);\nstatic struct hrtimer sync_hrtimer;\n#define SYNC_PERIOD_NS (11ULL * 60 * NSEC_PER_SEC)\n\nstatic enum hrtimer_restart sync_timer_callback(struct hrtimer *timer)\n{\n\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void sched_sync_hw_clock(unsigned long offset_nsec, bool retry)\n{\n\tktime_t exp = ktime_set(ktime_get_real_seconds(), 0);\n\n\tif (retry)\n\t\texp = ktime_add_ns(exp, 2ULL * NSEC_PER_SEC - offset_nsec);\n\telse\n\t\texp = ktime_add_ns(exp, SYNC_PERIOD_NS - offset_nsec);\n\n\thrtimer_start(&sync_hrtimer, exp, HRTIMER_MODE_ABS);\n}\n\n \nstatic inline bool rtc_tv_nsec_ok(unsigned long set_offset_nsec,\n\t\t\t\t  struct timespec64 *to_set,\n\t\t\t\t  const struct timespec64 *now)\n{\n\t \n\tconst unsigned long TIME_SET_NSEC_FUZZ = TICK_NSEC * 5;\n\tstruct timespec64 delay = {.tv_sec = -1,\n\t\t\t\t   .tv_nsec = set_offset_nsec};\n\n\t*to_set = timespec64_add(*now, delay);\n\n\tif (to_set->tv_nsec < TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\n\tif (to_set->tv_nsec > NSEC_PER_SEC - TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_sec++;\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#ifdef CONFIG_GENERIC_CMOS_UPDATE\nint __weak update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}\n#else\nstatic inline int update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#ifdef CONFIG_RTC_SYSTOHC\n \nstatic int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\tstruct rtc_device *rtc;\n\tstruct rtc_time tm;\n\tint err = -ENODEV;\n\n\trtc = rtc_class_open(CONFIG_RTC_SYSTOHC_DEVICE);\n\tif (!rtc)\n\t\treturn -ENODEV;\n\n\tif (!rtc->ops || !rtc->ops->set_time)\n\t\tgoto out_close;\n\n\t \n\tif (*offset_nsec == rtc->set_offset_nsec) {\n\t\trtc_time64_to_tm(to_set->tv_sec, &tm);\n\t\terr = rtc_set_time(rtc, &tm);\n\t} else {\n\t\t \n\t\t*offset_nsec = rtc->set_offset_nsec;\n\t\terr = -EAGAIN;\n\t}\nout_close:\n\trtc_class_close(rtc);\n\treturn err;\n}\n#else\nstatic inline int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\treturn -ENODEV;\n}\n#endif\n\n \nstatic void sync_hw_clock(struct work_struct *work)\n{\n\t \n\tstatic unsigned long offset_nsec = NSEC_PER_SEC / 2;\n\tstruct timespec64 now, to_set;\n\tint res = -EAGAIN;\n\n\t \n\tif (!ntp_synced() || hrtimer_is_queued(&sync_hrtimer))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\t \n\tif (!rtc_tv_nsec_ok(offset_nsec, &to_set, &now))\n\t\tgoto rearm;\n\n\t \n\tif (persistent_clock_is_local)\n\t\tto_set.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t \n\tres = update_persistent_clock64(to_set);\n\tif (res != -ENODEV)\n\t\tgoto rearm;\n\n\t \n\tres = update_rtc(&to_set, &offset_nsec);\n\tif (res == -ENODEV)\n\t\treturn;\nrearm:\n\tsched_sync_hw_clock(offset_nsec, res != 0);\n}\n\nvoid ntp_notify_cmos_timer(void)\n{\n\t \n\tif (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))\n\t\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n}\n\nstatic void __init ntp_init_cmos_sync(void)\n{\n\thrtimer_init(&sync_hrtimer, CLOCK_REALTIME, HRTIMER_MODE_ABS);\n\tsync_hrtimer.function = sync_timer_callback;\n}\n#else  \nstatic inline void __init ntp_init_cmos_sync(void) { }\n#endif  \n\n \nstatic inline void process_adj_status(const struct __kernel_timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t \n\t\tpps_reset_freq_interval();\n\t}\n\n\t \n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t \n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}\n\n\nstatic inline void process_adjtimex_modes(const struct __kernel_timex *txc,\n\t\t\t\t\t  s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t \n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI &&\n\t\t\ttxc->constant >= 0 && txc->constant <= MAX_TAI_OFFSET)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}\n\n\n \nint __do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts,\n\t\t  s32 *time_tai, struct audit_ntp_data *ad)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t \n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_ADJUST,\tsave_adjust);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_ADJUST,\ttime_adjust);\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\t\t \n\t\tif (txc->modes) {\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TICK,\ttick_usec);\n\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TICK,\ttick_usec);\n\t\t}\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset = (u32)txc->offset / NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t \n\t \n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t \n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec = ts->tv_nsec / NSEC_PER_USEC;\n\n\t \n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n#ifdef\tCONFIG_NTP_PPS\n\n \nstruct pps_normtime {\n\ts64\t\tsec;\t \n\tlong\t\tnsec;\t \n};\n\n \nstatic inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}\n\n \nstatic inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t \n\treturn pps_tf[0];\n}\n\n \nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}\n\n \nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}\n\n \nstatic inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}\n\n \nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t \n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t \n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t \n\t\tpps_inc_freq_interval();\n\t}\n\n\t \n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t \n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}\n\n \nstatic void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t \n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t \n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t \n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t \n\t\ttime_adjust = 0;\n\t}\n\t \n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}\n\n \nvoid __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t \n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t \n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t \n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t \n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t \n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t \n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t \n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}\n#endif\t \n\nstatic int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtos64(str, 0, &ntp_tick_adj);\n\tif (rc)\n\t\treturn rc;\n\n\tntp_tick_adj <<= NTP_SCALE_SHIFT;\n\treturn 1;\n}\n\n__setup(\"ntp_tick_adj=\", ntp_tick_adj_setup);\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n\tntp_init_cmos_sync();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}