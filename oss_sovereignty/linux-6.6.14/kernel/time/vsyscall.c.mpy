{
  "module_name": "vsyscall.c",
  "hash_id": "276988d4de35d0eb1f3ce0d2baa58848638d78c2c286a2deeee094c887be2580",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/vsyscall.c",
  "human_readable_source": "\n \n\n#include <linux/hrtimer.h>\n#include <linux/timekeeper_internal.h>\n#include <vdso/datapage.h>\n#include <vdso/helpers.h>\n#include <vdso/vsyscall.h>\n\n#include \"timekeeping_internal.h\"\n\nstatic inline void update_vdso_data(struct vdso_data *vdata,\n\t\t\t\t    struct timekeeper *tk)\n{\n\tstruct vdso_timestamp *vdso_ts;\n\tu64 nsec, sec;\n\n\tvdata[CS_HRES_COARSE].cycle_last\t= tk->tkr_mono.cycle_last;\n\tvdata[CS_HRES_COARSE].mask\t\t= tk->tkr_mono.mask;\n\tvdata[CS_HRES_COARSE].mult\t\t= tk->tkr_mono.mult;\n\tvdata[CS_HRES_COARSE].shift\t\t= tk->tkr_mono.shift;\n\tvdata[CS_RAW].cycle_last\t\t= tk->tkr_raw.cycle_last;\n\tvdata[CS_RAW].mask\t\t\t= tk->tkr_raw.mask;\n\tvdata[CS_RAW].mult\t\t\t= tk->tkr_raw.mult;\n\tvdata[CS_RAW].shift\t\t\t= tk->tkr_raw.shift;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\n\tnsec = tk->tkr_mono.xtime_nsec;\n\tnsec += ((u64)tk->wall_to_monotonic.tv_nsec << tk->tkr_mono.shift);\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t \n\tsec\t= vdso_ts->sec;\n\t \n\tsec\t+= tk->monotonic_to_boot.tv_sec;\n\tnsec\t+= (u64)tk->monotonic_to_boot.tv_nsec << tk->tkr_mono.shift;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_BOOTTIME];\n\tvdso_ts->sec\t= sec;\n\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_RAW].basetime[CLOCK_MONOTONIC_RAW];\n\tvdso_ts->sec\t= tk->raw_sec;\n\tvdso_ts->nsec\t= tk->tkr_raw.xtime_nsec;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_TAI];\n\tvdso_ts->sec\t= tk->xtime_sec + (s64)tk->tai_offset;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n}\n\nvoid update_vsyscall(struct timekeeper *tk)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tstruct vdso_timestamp *vdso_ts;\n\ts32 clock_mode;\n\tu64 nsec;\n\n\t \n\tvdso_write_begin(vdata);\n\n\tclock_mode = tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata[CS_HRES_COARSE].clock_mode\t= clock_mode;\n\tvdata[CS_RAW].clock_mode\t\t= clock_mode;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t \n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\tnsec\t\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\tnsec\t\t= nsec + tk->wall_to_monotonic.tv_nsec;\n\tvdso_ts->sec\t+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);\n\n\t \n\tWRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);\n\n\t \n\tif (clock_mode != VDSO_CLOCKMODE_NONE)\n\t\tupdate_vdso_data(vdata, tk);\n\n\t__arch_update_vsyscall(vdata, tk);\n\n\tvdso_write_end(vdata);\n\n\t__arch_sync_vdso_data(vdata);\n}\n\nvoid update_vsyscall_tz(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdata[CS_HRES_COARSE].tz_minuteswest = sys_tz.tz_minuteswest;\n\tvdata[CS_HRES_COARSE].tz_dsttime = sys_tz.tz_dsttime;\n\n\t__arch_sync_vdso_data(vdata);\n}\n\n \nunsigned long vdso_update_begin(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tvdso_write_begin(vdata);\n\treturn flags;\n}\n\n \nvoid vdso_update_end(unsigned long flags)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdso_write_end(vdata);\n\t__arch_sync_vdso_data(vdata);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}