{
  "module_name": "time.c",
  "hash_id": "28bded9500f2dce1365dd592945215e95f72adb67c26790c8689840e9b38640c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/time.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/timex.h>\n#include <linux/capability.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/errno.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/math64.h>\n#include <linux/ptrace.h>\n\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <asm/unistd.h>\n\n#include <generated/timeconst.h>\n#include \"timekeeping.h\"\n\n \nstruct timezone sys_tz;\n\nEXPORT_SYMBOL(sys_tz);\n\n#ifdef __ARCH_WANT_SYS_TIME\n\n \nSYSCALL_DEFINE1(time, __kernel_old_time_t __user *, tloc)\n{\n\t__kernel_old_time_t i = (__kernel_old_time_t)ktime_get_real_seconds();\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}\n\n \n\nSYSCALL_DEFINE1(stime, __kernel_old_time_t __user *, tptr)\n{\n\tstruct timespec64 tv;\n\tint err;\n\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\n\ttv.tv_nsec = 0;\n\n\terr = security_settime64(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdo_settimeofday64(&tv);\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_COMPAT_32BIT_TIME\n#ifdef __ARCH_WANT_SYS_TIME32\n\n \nSYSCALL_DEFINE1(time32, old_time32_t __user *, tloc)\n{\n\told_time32_t i;\n\n\ti = (old_time32_t)ktime_get_real_seconds();\n\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}\n\nSYSCALL_DEFINE1(stime32, old_time32_t __user *, tptr)\n{\n\tstruct timespec64 tv;\n\tint err;\n\n\tif (get_user(tv.tv_sec, tptr))\n\t\treturn -EFAULT;\n\n\ttv.tv_nsec = 0;\n\n\terr = security_settime64(&tv, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdo_settimeofday64(&tv);\n\treturn 0;\n}\n\n#endif  \n#endif\n\nSYSCALL_DEFINE2(gettimeofday, struct __kernel_old_timeval __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tif (likely(tv != NULL)) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||\n\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\t}\n\tif (unlikely(tz != NULL)) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \n\nint do_sys_settimeofday64(const struct timespec64 *tv, const struct timezone *tz)\n{\n\tstatic int firsttime = 1;\n\tint error = 0;\n\n\tif (tv && !timespec64_valid_settod(tv))\n\t\treturn -EINVAL;\n\n\terror = security_settime64(tv, tz);\n\tif (error)\n\t\treturn error;\n\n\tif (tz) {\n\t\t \n\t\tif (tz->tz_minuteswest > 15*60 || tz->tz_minuteswest < -15*60)\n\t\t\treturn -EINVAL;\n\n\t\tsys_tz = *tz;\n\t\tupdate_vsyscall_tz();\n\t\tif (firsttime) {\n\t\t\tfirsttime = 0;\n\t\t\tif (!tv)\n\t\t\t\ttimekeeping_warp_clock();\n\t\t}\n\t}\n\tif (tv)\n\t\treturn do_settimeofday64(tv);\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(settimeofday, struct __kernel_old_timeval __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tstruct timespec64 new_ts;\n\tstruct timezone new_tz;\n\n\tif (tv) {\n\t\tif (get_user(new_ts.tv_sec, &tv->tv_sec) ||\n\t\t    get_user(new_ts.tv_nsec, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_ts.tv_nsec > USEC_PER_SEC || new_ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnew_ts.tv_nsec *= NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_sys_settimeofday64(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(gettimeofday, struct old_timeval32 __user *, tv,\n\t\t       struct timezone __user *, tz)\n{\n\tif (tv) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_real_ts64(&ts);\n\t\tif (put_user(ts.tv_sec, &tv->tv_sec) ||\n\t\t    put_user(ts.tv_nsec / 1000, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_to_user(tz, &sys_tz, sizeof(sys_tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nCOMPAT_SYSCALL_DEFINE2(settimeofday, struct old_timeval32 __user *, tv,\n\t\t       struct timezone __user *, tz)\n{\n\tstruct timespec64 new_ts;\n\tstruct timezone new_tz;\n\n\tif (tv) {\n\t\tif (get_user(new_ts.tv_sec, &tv->tv_sec) ||\n\t\t    get_user(new_ts.tv_nsec, &tv->tv_usec))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_ts.tv_nsec > USEC_PER_SEC || new_ts.tv_nsec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnew_ts.tv_nsec *= NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_sys_settimeofday64(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}\n#endif\n\n#ifdef CONFIG_64BIT\nSYSCALL_DEFINE1(adjtimex, struct __kernel_timex __user *, txc_p)\n{\n\tstruct __kernel_timex txc;\t\t \n\tint ret;\n\n\t \n\tif (copy_from_user(&txc, txc_p, sizeof(struct __kernel_timex)))\n\t\treturn -EFAULT;\n\tret = do_adjtimex(&txc);\n\treturn copy_to_user(txc_p, &txc, sizeof(struct __kernel_timex)) ? -EFAULT : ret;\n}\n#endif\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nint get_old_timex32(struct __kernel_timex *txc, const struct old_timex32 __user *utp)\n{\n\tstruct old_timex32 tx32;\n\n\tmemset(txc, 0, sizeof(struct __kernel_timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct old_timex32)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}\n\nint put_old_timex32(struct old_timex32 __user *utp, const struct __kernel_timex *txc)\n{\n\tstruct old_timex32 tx32;\n\n\tmemset(&tx32, 0, sizeof(struct old_timex32));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct old_timex32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSYSCALL_DEFINE1(adjtimex_time32, struct old_timex32 __user *, utp)\n{\n\tstruct __kernel_timex txc;\n\tint err, ret;\n\n\terr = get_old_timex32(&txc, utp);\n\tif (err)\n\t\treturn err;\n\n\tret = do_adjtimex(&txc);\n\n\terr = put_old_timex32(utp, &txc);\n\tif (err)\n\t\treturn err;\n\n\treturn ret;\n}\n#endif\n\n \nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}\nEXPORT_SYMBOL(jiffies_to_msecs);\n\n \nunsigned int jiffies_to_usecs(const unsigned long j)\n{\n\t \n\tBUILD_BUG_ON(HZ > USEC_PER_SEC);\n\n#if !(USEC_PER_SEC % HZ)\n\treturn (USEC_PER_SEC / HZ) * j;\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_USEC_MUL32 * j) >> HZ_TO_USEC_SHR32;\n# else\n\treturn (j * HZ_TO_USEC_NUM) / HZ_TO_USEC_DEN;\n# endif\n#endif\n}\nEXPORT_SYMBOL(jiffies_to_usecs);\n\n \ntime64_t mktime64(const unsigned int year0, const unsigned int mon0,\n\t\tconst unsigned int day, const unsigned int hour,\n\t\tconst unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\n\t \n\tif (0 >= (int) (mon -= 2)) {\n\t\tmon += 12;\t \n\t\tyear -= 1;\n\t}\n\n\treturn ((((time64_t)\n\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +\n\t\t  year*365 - 719499\n\t    )*24 + hour  \n\t  )*60 + min  \n\t)*60 + sec;  \n}\nEXPORT_SYMBOL(mktime64);\n\nstruct __kernel_old_timeval ns_to_kernel_old_timeval(s64 nsec)\n{\n\tstruct timespec64 ts = ns_to_timespec64(nsec);\n\tstruct __kernel_old_timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t)ts.tv_nsec / 1000;\n\n\treturn tv;\n}\nEXPORT_SYMBOL(ns_to_kernel_old_timeval);\n\n \nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t \n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}\nEXPORT_SYMBOL(set_normalized_timespec64);\n\n \nstruct timespec64 ns_to_timespec64(s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t \n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}\nEXPORT_SYMBOL(ns_to_timespec64);\n\n \nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t \n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}\nEXPORT_SYMBOL(__msecs_to_jiffies);\n\n \nunsigned long __usecs_to_jiffies(const unsigned int u)\n{\n\tif (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _usecs_to_jiffies(u);\n}\nEXPORT_SYMBOL(__usecs_to_jiffies);\n\n \nunsigned long\ntimespec64_to_jiffies(const struct timespec64 *value)\n{\n\tu64 sec = value->tv_sec;\n\tlong nsec = value->tv_nsec + TICK_NSEC - 1;\n\n\tif (sec >= MAX_SEC_IN_JIFFIES){\n\t\tsec = MAX_SEC_IN_JIFFIES;\n\t\tnsec = 0;\n\t}\n\treturn ((sec * SEC_CONVERSION) +\n\t\t(((u64)nsec * NSEC_CONVERSION) >>\n\t\t (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;\n\n}\nEXPORT_SYMBOL(timespec64_to_jiffies);\n\n \nvoid\njiffies_to_timespec64(const unsigned long jiffies, struct timespec64 *value)\n{\n\t \n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}\nEXPORT_SYMBOL(jiffies_to_timespec64);\n\n \n\n \nclock_t jiffies_to_clock_t(unsigned long x)\n{\n#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0\n# if HZ < USER_HZ\n\treturn x * (USER_HZ / HZ);\n# else\n\treturn x / (HZ / USER_HZ);\n# endif\n#else\n\treturn div_u64((u64)x * TICK_NSEC, NSEC_PER_SEC / USER_HZ);\n#endif\n}\nEXPORT_SYMBOL(jiffies_to_clock_t);\n\n \nunsigned long clock_t_to_jiffies(unsigned long x)\n{\n#if (HZ % USER_HZ)==0\n\tif (x >= ~0UL / (HZ / USER_HZ))\n\t\treturn ~0UL;\n\treturn x * (HZ / USER_HZ);\n#else\n\t \n\tif (x >= ~0UL / HZ * USER_HZ)\n\t\treturn ~0UL;\n\n\t \n\treturn div_u64((u64)x * HZ, USER_HZ);\n#endif\n}\nEXPORT_SYMBOL(clock_t_to_jiffies);\n\n \nu64 jiffies_64_to_clock_t(u64 x)\n{\n#if (TICK_NSEC % (NSEC_PER_SEC / USER_HZ)) == 0\n# if HZ < USER_HZ\n\tx = div_u64(x * USER_HZ, HZ);\n# elif HZ > USER_HZ\n\tx = div_u64(x, HZ / USER_HZ);\n# else\n\t \n# endif\n#else\n\t \n\tx = div_u64(x * TICK_NSEC, (NSEC_PER_SEC / USER_HZ));\n#endif\n\treturn x;\n}\nEXPORT_SYMBOL(jiffies_64_to_clock_t);\n\n \nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t \n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}\n\n \nu64 jiffies64_to_nsecs(u64 j)\n{\n#if !(NSEC_PER_SEC % HZ)\n\treturn (NSEC_PER_SEC / HZ) * j;\n# else\n\treturn div_u64(j * HZ_TO_NSEC_NUM, HZ_TO_NSEC_DEN);\n#endif\n}\nEXPORT_SYMBOL(jiffies64_to_nsecs);\n\n \nu64 jiffies64_to_msecs(const u64 j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#else\n\treturn div_u64(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n#endif\n}\nEXPORT_SYMBOL(jiffies64_to_msecs);\n\n \nu64 nsecs_to_jiffies64(u64 n)\n{\n#if (NSEC_PER_SEC % HZ) == 0\n\t \n\treturn div_u64(n, NSEC_PER_SEC / HZ);\n#elif (HZ % 512) == 0\n\t \n\treturn div_u64(n * HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t \n\treturn div_u64(n * 9, (9ull * NSEC_PER_SEC + HZ / 2) / HZ);\n#endif\n}\nEXPORT_SYMBOL(nsecs_to_jiffies64);\n\n \nunsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}\nEXPORT_SYMBOL_GPL(nsecs_to_jiffies);\n\n \nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}\n\n \nint get_timespec64(struct timespec64 *ts,\n\t\t   const struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts;\n\tint ret;\n\n\tret = copy_from_user(&kts, uts, sizeof(kts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts->tv_sec = kts.tv_sec;\n\n\t \n\tif (in_compat_syscall())\n\t\tkts.tv_nsec &= 0xFFFFFFFFUL;\n\n\t \n\tts->tv_nsec = kts.tv_nsec;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_timespec64);\n\n \nint put_timespec64(const struct timespec64 *ts,\n\t\t   struct __kernel_timespec __user *uts)\n{\n\tstruct __kernel_timespec kts = {\n\t\t.tv_sec = ts->tv_sec,\n\t\t.tv_nsec = ts->tv_nsec\n\t};\n\n\treturn copy_to_user(uts, &kts, sizeof(kts)) ? -EFAULT : 0;\n}\nEXPORT_SYMBOL_GPL(put_timespec64);\n\nstatic int __get_old_timespec32(struct timespec64 *ts64,\n\t\t\t\t   const struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}\n\nstatic int __put_old_timespec32(const struct timespec64 *ts64,\n\t\t\t\t   struct old_timespec32 __user *cts)\n{\n\tstruct old_timespec32 ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}\n\n \nint get_old_timespec32(struct timespec64 *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __get_old_timespec32(ts, uts);\n}\nEXPORT_SYMBOL_GPL(get_old_timespec32);\n\n \nint put_old_timespec32(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __put_old_timespec32(ts, uts);\n}\nEXPORT_SYMBOL_GPL(put_old_timespec32);\n\n \nint get_itimerspec64(struct itimerspec64 *it,\n\t\t\tconst struct __kernel_itimerspec __user *uit)\n{\n\tint ret;\n\n\tret = get_timespec64(&it->it_interval, &uit->it_interval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_timespec64(&it->it_value, &uit->it_value);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(get_itimerspec64);\n\n \nint put_itimerspec64(const struct itimerspec64 *it,\n\t\t\tstruct __kernel_itimerspec __user *uit)\n{\n\tint ret;\n\n\tret = put_timespec64(&it->it_interval, &uit->it_interval);\n\tif (ret)\n\t\treturn ret;\n\n\tret = put_timespec64(&it->it_value, &uit->it_value);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(put_itimerspec64);\n\n \nint get_old_itimerspec32(struct itimerspec64 *its,\n\t\t\tconst struct old_itimerspec32 __user *uits)\n{\n\n\tif (__get_old_timespec32(&its->it_interval, &uits->it_interval) ||\n\t    __get_old_timespec32(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_old_itimerspec32);\n\n \nint put_old_itimerspec32(const struct itimerspec64 *its,\n\t\t\tstruct old_itimerspec32 __user *uits)\n{\n\tif (__put_old_timespec32(&its->it_interval, &uits->it_interval) ||\n\t    __put_old_timespec32(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(put_old_itimerspec32);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}