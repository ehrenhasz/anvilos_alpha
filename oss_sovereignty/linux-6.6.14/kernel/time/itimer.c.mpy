{
  "module_name": "itimer.c",
  "hash_id": "04110c0fa82dfe6a69681bdb3b5260044b783fe818d483eaa4146872b6b3d2d5",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/itimer.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/time.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/cputime.h>\n#include <linux/posix-timers.h>\n#include <linux/hrtimer.h>\n#include <trace/events/timer.h>\n#include <linux/compat.h>\n\n#include <linux/uaccess.h>\n\n \nstatic struct timespec64 itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t \n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timespec64(rem);\n}\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerspec64 *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tu64 t, samples[CPUCLOCK_MAX];\n\n\t\tthread_group_sample_cputime(tsk, samples);\n\t\tt = samples[clock_id];\n\n\t\tif (val < t)\n\t\t\t \n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timespec64(val);\n\tvalue->it_interval = ns_to_timespec64(interval);\n}\n\nstatic int do_getitimer(int which, struct itimerspec64 *value)\n{\n\tstruct task_struct *tsk = current;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\n\t\tvalue->it_interval =\n\t\t\tktime_to_timespec64(tsk->signal->it_real_incr);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\n\t\tbreak;\n\tdefault:\n\t\treturn(-EINVAL);\n\t}\n\treturn 0;\n}\n\nstatic int put_itimerval(struct __kernel_old_itimerval __user *o,\n\t\t\t const struct itimerspec64 *i)\n{\n\tstruct __kernel_old_itimerval v;\n\n\tv.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;\n\tv.it_value.tv_sec = i->it_value.tv_sec;\n\tv.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;\n\treturn copy_to_user(o, &v, sizeof(struct __kernel_old_itimerval)) ? -EFAULT : 0;\n}\n\n\nSYSCALL_DEFINE2(getitimer, int, which, struct __kernel_old_itimerval __user *, value)\n{\n\tstruct itimerspec64 get_buffer;\n\tint error = do_getitimer(which, &get_buffer);\n\n\tif (!error && put_itimerval(value, &get_buffer))\n\t\terror = -EFAULT;\n\treturn error;\n}\n\n#if defined(CONFIG_COMPAT) || defined(CONFIG_ALPHA)\nstruct old_itimerval32 {\n\tstruct old_timeval32\tit_interval;\n\tstruct old_timeval32\tit_value;\n};\n\nstatic int put_old_itimerval32(struct old_itimerval32 __user *o,\n\t\t\t       const struct itimerspec64 *i)\n{\n\tstruct old_itimerval32 v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_nsec / NSEC_PER_USEC;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_nsec / NSEC_PER_USEC;\n\treturn copy_to_user(o, &v32, sizeof(struct old_itimerval32)) ? -EFAULT : 0;\n}\n\nCOMPAT_SYSCALL_DEFINE2(getitimer, int, which,\n\t\t       struct old_itimerval32 __user *, value)\n{\n\tstruct itimerspec64 get_buffer;\n\tint error = do_getitimer(which, &get_buffer);\n\n\tif (!error && put_old_itimerval32(value, &get_buffer))\n\t\terror = -EFAULT;\n\treturn error;\n}\n#endif\n\n \nenum hrtimer_restart it_real_fn(struct hrtimer *timer)\n{\n\tstruct signal_struct *sig =\n\t\tcontainer_of(timer, struct signal_struct, real_timer);\n\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];\n\n\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);\n\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerspec64 *const value,\n\t\t\t   struct itimerspec64 *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tnval = timespec64_to_ns(&value->it_value);\n\tninterval = timespec64_to_ns(&value->it_interval);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timespec64(oval);\n\t\tovalue->it_interval = ns_to_timespec64(ointerval);\n\t}\n}\n\n \n#define timeval_valid(t) \\\n\t(((t)->tv_sec >= 0) && (((unsigned long) (t)->tv_usec) < USEC_PER_SEC))\n\nstatic int do_setitimer(int which, struct itimerspec64 *value,\n\t\t\tstruct itimerspec64 *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timespec64(tsk->signal->it_real_incr);\n\t\t}\n\t\t \n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\thrtimer_cancel_wait_running(timer);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timespec64_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimespec64_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_SECURITY_SELINUX\nvoid clear_itimer(void)\n{\n\tstruct itimerspec64 v = {};\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tdo_setitimer(i, &v, NULL);\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_ALARM\n\n \nstatic unsigned int alarm_setitimer(unsigned int seconds)\n{\n\tstruct itimerspec64 it_new, it_old;\n\n#if BITS_PER_LONG < 64\n\tif (seconds > INT_MAX)\n\t\tseconds = INT_MAX;\n#endif\n\tit_new.it_value.tv_sec = seconds;\n\tit_new.it_value.tv_nsec = 0;\n\tit_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = 0;\n\n\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);\n\n\t \n\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_nsec) ||\n\t      it_old.it_value.tv_nsec >= (NSEC_PER_SEC / 2))\n\t\tit_old.it_value.tv_sec++;\n\n\treturn it_old.it_value.tv_sec;\n}\n\n \nSYSCALL_DEFINE1(alarm, unsigned int, seconds)\n{\n\treturn alarm_setitimer(seconds);\n}\n\n#endif\n\nstatic int get_itimerval(struct itimerspec64 *o, const struct __kernel_old_itimerval __user *i)\n{\n\tstruct __kernel_old_itimerval v;\n\n\tif (copy_from_user(&v, i, sizeof(struct __kernel_old_itimerval)))\n\t\treturn -EFAULT;\n\n\t \n\tif (!timeval_valid(&v.it_value) ||\n\t    !timeval_valid(&v.it_interval))\n\t\treturn -EINVAL;\n\n\to->it_interval.tv_sec = v.it_interval.tv_sec;\n\to->it_interval.tv_nsec = v.it_interval.tv_usec * NSEC_PER_USEC;\n\to->it_value.tv_sec = v.it_value.tv_sec;\n\to->it_value.tv_nsec = v.it_value.tv_usec * NSEC_PER_USEC;\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(setitimer, int, which, struct __kernel_old_itimerval __user *, value,\n\t\tstruct __kernel_old_itimerval __user *, ovalue)\n{\n\tstruct itimerspec64 set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\terror = get_itimerval(&set_buffer, value);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\n\tif (put_itimerval(ovalue, &get_buffer))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#if defined(CONFIG_COMPAT) || defined(CONFIG_ALPHA)\nstatic int get_old_itimerval32(struct itimerspec64 *o, const struct old_itimerval32 __user *i)\n{\n\tstruct old_itimerval32 v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct old_itimerval32)))\n\t\treturn -EFAULT;\n\n\t \n\tif (!timeval_valid(&v32.it_value) ||\n\t    !timeval_valid(&v32.it_interval))\n\t\treturn -EINVAL;\n\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_nsec = v32.it_interval.tv_usec * NSEC_PER_USEC;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_nsec = v32.it_value.tv_usec * NSEC_PER_USEC;\n\treturn 0;\n}\n\nCOMPAT_SYSCALL_DEFINE3(setitimer, int, which,\n\t\t       struct old_itimerval32 __user *, value,\n\t\t       struct old_itimerval32 __user *, ovalue)\n{\n\tstruct itimerspec64 set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\terror = get_old_itimerval32(&set_buffer, value);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\tif (put_old_itimerval32(ovalue, &get_buffer))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}