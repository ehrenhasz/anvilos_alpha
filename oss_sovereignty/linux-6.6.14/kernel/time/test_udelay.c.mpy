{
  "module_name": "test_udelay.c",
  "hash_id": "99e3afbc8ee7a063124205a594aafd91faa8d8c78cbd57689e1750aaa2cc41a8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/test_udelay.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define DEFAULT_ITERATIONS 100\n\n#define DEBUGFS_FILENAME \"udelay_test\"\n\nstatic DEFINE_MUTEX(udelay_test_lock);\nstatic int udelay_test_usecs;\nstatic int udelay_test_iterations = DEFAULT_ITERATIONS;\n\nstatic int udelay_test_single(struct seq_file *s, int usecs, uint32_t iters)\n{\n\tint min = 0, max = 0, fail_count = 0;\n\tuint64_t sum = 0;\n\tuint64_t avg;\n\tint i;\n\t \n\tint allowed_error_ns = usecs * 5;\n\n\tfor (i = 0; i < iters; ++i) {\n\t\ts64 kt1, kt2;\n\t\tint time_passed;\n\n\t\tkt1 = ktime_get_ns();\n\t\tudelay(usecs);\n\t\tkt2 = ktime_get_ns();\n\t\ttime_passed = kt2 - kt1;\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed > max)\n\t\t\tmax = time_passed;\n\t\tif ((time_passed + allowed_error_ns) / 1000 < usecs)\n\t\t\t++fail_count;\n\t\tWARN_ON(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" FAIL=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int udelay_test_show(struct seq_file *s, void *v)\n{\n\tint usecs;\n\tint iters;\n\tint ret = 0;\n\n\tmutex_lock(&udelay_test_lock);\n\tusecs = udelay_test_usecs;\n\titers = udelay_test_iterations;\n\tmutex_unlock(&udelay_test_lock);\n\n\tif (usecs > 0 && iters > 0) {\n\t\treturn udelay_test_single(s, usecs, iters);\n\t} else if (usecs == 0) {\n\t\tstruct timespec64 ts;\n\n\t\tktime_get_ts64(&ts);\n\t\tseq_printf(s, \"udelay() test (lpj=%ld kt=%lld.%09ld)\\n\",\n\t\t\t\tloops_per_jiffy, (s64)ts.tv_sec, ts.tv_nsec);\n\t\tseq_puts(s, \"usage:\\n\");\n\t\tseq_puts(s, \"echo USECS [ITERS] > \" DEBUGFS_FILENAME \"\\n\");\n\t\tseq_puts(s, \"cat \" DEBUGFS_FILENAME \"\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int udelay_test_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, udelay_test_show, inode->i_private);\n}\n\nstatic ssize_t udelay_test_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *pos)\n{\n\tchar lbuf[32];\n\tint ret;\n\tint usecs;\n\tint iters;\n\n\tif (count >= sizeof(lbuf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(lbuf, buf, count))\n\t\treturn -EFAULT;\n\tlbuf[count] = '\\0';\n\n\tret = sscanf(lbuf, \"%d %d\", &usecs, &iters);\n\tif (ret < 1)\n\t\treturn -EINVAL;\n\telse if (ret < 2)\n\t\titers = DEFAULT_ITERATIONS;\n\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_usecs = usecs;\n\tudelay_test_iterations = iters;\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations udelay_test_debugfs_ops = {\n\t.owner = THIS_MODULE,\n\t.open = udelay_test_open,\n\t.read = seq_read,\n\t.write = udelay_test_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int __init udelay_test_init(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_create_file(DEBUGFS_FILENAME, S_IRUSR, NULL, NULL,\n\t\t\t    &udelay_test_debugfs_ops);\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn 0;\n}\n\nmodule_init(udelay_test_init);\n\nstatic void __exit udelay_test_exit(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_lookup_and_remove(DEBUGFS_FILENAME, NULL);\n\tmutex_unlock(&udelay_test_lock);\n}\n\nmodule_exit(udelay_test_exit);\n\nMODULE_AUTHOR(\"David Riley <davidriley@chromium.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}