{
  "module_name": "posix-clock.c",
  "hash_id": "5ab05f20e5a797cd012e3762f8cd284baac1e9be86944b0ad72d51db26411694",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/posix-clock.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/posix-clock.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n\n#include \"posix-timers.h\"\n\n \nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}\n\nstatic ssize_t posix_clock_read(struct file *fp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -EINVAL;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.read)\n\t\terr = clk->ops.read(clk, fp->f_flags, buf, count);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}\n\nstatic __poll_t posix_clock_poll(struct file *fp, poll_table *wait)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\t__poll_t result = 0;\n\n\tif (!clk)\n\t\treturn EPOLLERR;\n\n\tif (clk->ops.poll)\n\t\tresult = clk->ops.poll(clk, fp, wait);\n\n\tput_posix_clock(clk);\n\n\treturn result;\n}\n\nstatic long posix_clock_ioctl(struct file *fp,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -ENOTTY;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.ioctl)\n\t\terr = clk->ops.ioctl(clk, cmd, arg);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long posix_clock_compat_ioctl(struct file *fp,\n\t\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -ENOTTY;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.ioctl)\n\t\terr = clk->ops.ioctl(clk, cmd, arg);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}\n#endif\n\nstatic int posix_clock_open(struct inode *inode, struct file *fp)\n{\n\tint err;\n\tstruct posix_clock *clk =\n\t\tcontainer_of(inode->i_cdev, struct posix_clock, cdev);\n\n\tdown_read(&clk->rwsem);\n\n\tif (clk->zombie) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (clk->ops.open)\n\t\terr = clk->ops.open(clk, fp->f_mode);\n\telse\n\t\terr = 0;\n\n\tif (!err) {\n\t\tget_device(clk->dev);\n\t\tfp->private_data = clk;\n\t}\nout:\n\tup_read(&clk->rwsem);\n\treturn err;\n}\n\nstatic int posix_clock_release(struct inode *inode, struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\tint err = 0;\n\n\tif (clk->ops.release)\n\t\terr = clk->ops.release(clk);\n\n\tput_device(clk->dev);\n\n\tfp->private_data = NULL;\n\n\treturn err;\n}\n\nstatic const struct file_operations posix_clock_file_operations = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= posix_clock_read,\n\t.poll\t\t= posix_clock_poll,\n\t.unlocked_ioctl\t= posix_clock_ioctl,\n\t.open\t\t= posix_clock_open,\n\t.release\t= posix_clock_release,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= posix_clock_compat_ioctl,\n#endif\n};\n\nint posix_clock_register(struct posix_clock *clk, struct device *dev)\n{\n\tint err;\n\n\tinit_rwsem(&clk->rwsem);\n\n\tcdev_init(&clk->cdev, &posix_clock_file_operations);\n\terr = cdev_device_add(&clk->cdev, dev);\n\tif (err) {\n\t\tpr_err(\"%s unable to add device %d:%d\\n\",\n\t\t\tdev_name(dev), MAJOR(dev->devt), MINOR(dev->devt));\n\t\treturn err;\n\t}\n\tclk->cdev.owner = clk->ops.owner;\n\tclk->dev = dev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(posix_clock_register);\n\nvoid posix_clock_unregister(struct posix_clock *clk)\n{\n\tcdev_device_del(&clk->cdev, clk->dev);\n\n\tdown_write(&clk->rwsem);\n\tclk->zombie = true;\n\tup_write(&clk->rwsem);\n\n\tput_device(clk->dev);\n}\nEXPORT_SYMBOL_GPL(posix_clock_unregister);\n\nstruct posix_clock_desc {\n\tstruct file *fp;\n\tstruct posix_clock *clk;\n};\n\nstatic int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}\n\nstatic void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}\n\nstatic int pc_clock_adjtime(clockid_t id, struct __kernel_timex *tx)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif ((cd.fp->f_mode & FMODE_WRITE) == 0) {\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (cd.clk->ops.clock_adjtime)\n\t\terr = cd.clk->ops.clock_adjtime(cd.clk, tx);\n\telse\n\t\terr = -EOPNOTSUPP;\nout:\n\tput_clock_desc(&cd);\n\n\treturn err;\n}\n\nstatic int pc_clock_gettime(clockid_t id, struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif (cd.clk->ops.clock_gettime)\n\t\terr = cd.clk->ops.clock_gettime(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\tput_clock_desc(&cd);\n\n\treturn err;\n}\n\nstatic int pc_clock_getres(clockid_t id, struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif (cd.clk->ops.clock_getres)\n\t\terr = cd.clk->ops.clock_getres(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\tput_clock_desc(&cd);\n\n\treturn err;\n}\n\nstatic int pc_clock_settime(clockid_t id, const struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif ((cd.fp->f_mode & FMODE_WRITE) == 0) {\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (cd.clk->ops.clock_settime)\n\t\terr = cd.clk->ops.clock_settime(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\nout:\n\tput_clock_desc(&cd);\n\n\treturn err;\n}\n\nconst struct k_clock clock_posix_dynamic = {\n\t.clock_getres\t\t= pc_clock_getres,\n\t.clock_set\t\t= pc_clock_settime,\n\t.clock_get_timespec\t= pc_clock_gettime,\n\t.clock_adj\t\t= pc_clock_adjtime,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}