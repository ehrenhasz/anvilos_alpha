{
  "module_name": "tick-internal.h",
  "hash_id": "07fcaa914ec0b297ebef03b67cc56c258de0a56c8cd8cae3b3ccdecdd8da854d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/tick-internal.h",
  "human_readable_source": " \n \n#include <linux/hrtimer.h>\n#include <linux/tick.h>\n\n#include \"timekeeping.h\"\n#include \"tick-sched.h\"\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\n# define TICK_DO_TIMER_NONE\t-1\n# define TICK_DO_TIMER_BOOT\t-2\n\nDECLARE_PER_CPU(struct tick_device, tick_cpu_device);\nextern ktime_t tick_next_period;\nextern int tick_do_timer_cpu __read_mostly;\n\nextern void tick_setup_periodic(struct clock_event_device *dev, int broadcast);\nextern void tick_handle_periodic(struct clock_event_device *dev);\nextern void tick_check_new_device(struct clock_event_device *dev);\nextern void tick_shutdown(unsigned int cpu);\nextern void tick_suspend(void);\nextern void tick_resume(void);\nextern bool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t\t   struct clock_event_device *newdev);\nextern void tick_install_replacement(struct clock_event_device *dev);\nextern int tick_is_oneshot_available(void);\nextern struct tick_device *tick_get_device(int cpu);\n\nextern int clockevents_tick_resume(struct clock_event_device *dev);\n \nstatic inline int tick_device_is_functional(struct clock_event_device *dev)\n{\n\treturn !(dev->features & CLOCK_EVT_FEAT_DUMMY);\n}\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}\n\nextern void clockevents_shutdown(struct clock_event_device *dev);\nextern void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t\tstruct clock_event_device *new);\nextern void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t     enum clock_event_state state);\nextern int clockevents_program_event(struct clock_event_device *dev,\n\t\t\t\t     ktime_t expires, bool force);\nextern void clockevents_handle_noop(struct clock_event_device *dev);\nextern int __clockevents_update_freq(struct clock_event_device *dev, u32 freq);\nextern ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt);\n\n \n# ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\nextern int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu);\nextern void tick_install_broadcast_device(struct clock_event_device *dev, int cpu);\nextern int tick_is_broadcast_device(struct clock_event_device *dev);\nextern void tick_suspend_broadcast(void);\nextern void tick_resume_broadcast(void);\nextern bool tick_resume_check_broadcast(void);\nextern void tick_broadcast_init(void);\nextern void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast);\nextern int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq);\nextern struct tick_device *tick_get_broadcast_device(void);\nextern struct cpumask *tick_get_broadcast_mask(void);\nextern const struct clock_event_device *tick_get_wakeup_device(int cpu);\n# else  \nstatic inline void tick_install_broadcast_device(struct clock_event_device *dev, int cpu) { }\nstatic inline int tick_is_broadcast_device(struct clock_event_device *dev) { return 0; }\nstatic inline int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu) { return 0; }\nstatic inline void tick_do_periodic_broadcast(struct clock_event_device *d) { }\nstatic inline void tick_suspend_broadcast(void) { }\nstatic inline void tick_resume_broadcast(void) { }\nstatic inline bool tick_resume_check_broadcast(void) { return false; }\nstatic inline void tick_broadcast_init(void) { }\nstatic inline int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq) { return -ENODEV; }\n\n \nstatic inline void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\n{\n\tdev->event_handler = tick_handle_periodic;\n}\n# endif  \n\n#else  \nstatic inline void tick_suspend(void) { }\nstatic inline void tick_resume(void) { }\n#endif  \n\n \n#ifdef CONFIG_TICK_ONESHOT\nextern void tick_setup_oneshot(struct clock_event_device *newdev,\n\t\t\t       void (*handler)(struct clock_event_device *),\n\t\t\t       ktime_t nextevt);\nextern int tick_program_event(ktime_t expires, int force);\nextern void tick_oneshot_notify(void);\nextern int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *));\nextern void tick_resume_oneshot(void);\nstatic inline bool tick_oneshot_possible(void) { return true; }\nextern int tick_oneshot_mode_active(void);\nextern void tick_clock_notify(void);\nextern int tick_check_oneshot_change(int allow_nohz);\nextern int tick_init_highres(void);\n#else  \nstatic inline\nvoid tick_setup_oneshot(struct clock_event_device *newdev,\n\t\t\tvoid (*handler)(struct clock_event_device *),\n\t\t\tktime_t nextevt) { BUG(); }\nstatic inline void tick_resume_oneshot(void) { BUG(); }\nstatic inline int tick_program_event(ktime_t expires, int force) { return 0; }\nstatic inline void tick_oneshot_notify(void) { }\nstatic inline bool tick_oneshot_possible(void) { return false; }\nstatic inline int tick_oneshot_mode_active(void) { return 0; }\nstatic inline void tick_clock_notify(void) { }\nstatic inline int tick_check_oneshot_change(int allow_nohz) { return 0; }\n#endif  \n\n \n#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_TICK_ONESHOT)\nextern void tick_broadcast_switch_to_oneshot(void);\nextern int tick_broadcast_oneshot_active(void);\nextern void tick_check_oneshot_broadcast_this_cpu(void);\nbool tick_broadcast_oneshot_available(void);\nextern struct cpumask *tick_get_broadcast_oneshot_mask(void);\n#else  \nstatic inline void tick_broadcast_switch_to_oneshot(void) { }\nstatic inline int tick_broadcast_oneshot_active(void) { return 0; }\nstatic inline void tick_check_oneshot_broadcast_this_cpu(void) { }\nstatic inline bool tick_broadcast_oneshot_available(void) { return tick_oneshot_possible(); }\n#endif  \n\n#if defined(CONFIG_GENERIC_CLOCKEVENTS_BROADCAST) && defined(CONFIG_HOTPLUG_CPU)\nextern void tick_broadcast_offline(unsigned int cpu);\n#else\nstatic inline void tick_broadcast_offline(unsigned int cpu) { }\n#endif\n\n \n#ifdef CONFIG_NO_HZ_FULL\nextern void tick_nohz_init(void);\n# else\nstatic inline void tick_nohz_init(void) { }\n#endif\n\n#ifdef CONFIG_NO_HZ_COMMON\nextern unsigned long tick_nohz_active;\nextern void timers_update_nohz(void);\n# ifdef CONFIG_SMP\nextern struct static_key_false timers_migration_enabled;\n# endif\n#else  \nstatic inline void timers_update_nohz(void) { }\n#define tick_nohz_active (0)\n#endif\n\nDECLARE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases);\n\nextern u64 get_next_timer_interrupt(unsigned long basej, u64 basem);\nvoid timer_clear_idle(void);\n\n#define CLOCK_SET_WALL\t\t\t\t\t\t\t\\\n\t(BIT(HRTIMER_BASE_REALTIME) | BIT(HRTIMER_BASE_REALTIME_SOFT) |\t\\\n\t BIT(HRTIMER_BASE_TAI) | BIT(HRTIMER_BASE_TAI_SOFT))\n\n#define CLOCK_SET_BOOT\t\t\t\t\t\t\t\\\n\t(BIT(HRTIMER_BASE_BOOTTIME) | BIT(HRTIMER_BASE_BOOTTIME_SOFT))\n\nvoid clock_was_set(unsigned int bases);\nvoid clock_was_set_delayed(void);\n\nvoid hrtimers_resume_local(void);\n\n \n#if HZ < 34\n#define JIFFIES_SHIFT\t6\n#elif HZ < 67\n#define JIFFIES_SHIFT\t7\n#else\n#define JIFFIES_SHIFT\t8\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}