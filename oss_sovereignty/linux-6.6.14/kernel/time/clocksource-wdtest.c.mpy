{
  "module_name": "clocksource-wdtest.c",
  "hash_id": "59867f95558dccb383d8685a6e93296022845a724c42a843fcf758ec4712ad26",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/clocksource-wdtest.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/sched.h>  \n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/prandom.h>\n#include <linux/cpu.h>\n\n#include \"tick-internal.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul E. McKenney <paulmck@kernel.org>\");\n\nstatic int holdoff = IS_BUILTIN(CONFIG_TEST_CLOCKSOURCE_WATCHDOG) ? 10 : 0;\nmodule_param(holdoff, int, 0444);\nMODULE_PARM_DESC(holdoff, \"Time to wait to start test (s).\");\n\n \nstatic struct task_struct *wdtest_task;\n\nstatic u64 wdtest_jiffies_read(struct clocksource *cs)\n{\n\treturn (u64)jiffies;\n}\n\nstatic struct clocksource clocksource_wdtest_jiffies = {\n\t.name\t\t\t= \"wdtest-jiffies\",\n\t.rating\t\t\t= 1,  \n\t.uncertainty_margin\t= TICK_NSEC,\n\t.read\t\t\t= wdtest_jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.flags\t\t\t= CLOCK_SOURCE_MUST_VERIFY,\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT,  \n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};\n\nstatic int wdtest_ktime_read_ndelays;\nstatic bool wdtest_ktime_read_fuzz;\n\nstatic u64 wdtest_ktime_read(struct clocksource *cs)\n{\n\tint wkrn = READ_ONCE(wdtest_ktime_read_ndelays);\n\tstatic int sign = 1;\n\tu64 ret;\n\n\tif (wkrn) {\n\t\tudelay(cs->uncertainty_margin / 250);\n\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, wkrn - 1);\n\t}\n\tret = ktime_get_real_fast_ns();\n\tif (READ_ONCE(wdtest_ktime_read_fuzz)) {\n\t\tsign = -sign;\n\t\tret = ret + sign * 100 * NSEC_PER_MSEC;\n\t}\n\treturn ret;\n}\n\nstatic void wdtest_ktime_cs_mark_unstable(struct clocksource *cs)\n{\n\tpr_info(\"--- Marking %s unstable due to clocksource watchdog.\\n\", cs->name);\n}\n\n#define KTIME_FLAGS (CLOCK_SOURCE_IS_CONTINUOUS | \\\n\t\t     CLOCK_SOURCE_VALID_FOR_HRES | \\\n\t\t     CLOCK_SOURCE_MUST_VERIFY | \\\n\t\t     CLOCK_SOURCE_VERIFY_PERCPU)\n\nstatic struct clocksource clocksource_wdtest_ktime = {\n\t.name\t\t\t= \"wdtest-ktime\",\n\t.rating\t\t\t= 300,\n\t.read\t\t\t= wdtest_ktime_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t\t= KTIME_FLAGS,\n\t.mark_unstable\t\t= wdtest_ktime_cs_mark_unstable,\n\t.list\t\t\t= LIST_HEAD_INIT(clocksource_wdtest_ktime.list),\n};\n\n \nstatic void wdtest_ktime_clocksource_reset(void)\n{\n\tif (clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE) {\n\t\tclocksource_unregister(&clocksource_wdtest_ktime);\n\t\tclocksource_wdtest_ktime.flags = KTIME_FLAGS;\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\t}\n}\n\n \nstatic int wdtest_func(void *arg)\n{\n\tunsigned long j1, j2;\n\tchar *s;\n\tint i;\n\n\tschedule_timeout_uninterruptible(holdoff * HZ);\n\n\t \n\tpr_info(\"--- Verify jiffies-like uncertainty margin.\\n\");\n\t__clocksource_register(&clocksource_wdtest_jiffies);\n\tWARN_ON_ONCE(clocksource_wdtest_jiffies.uncertainty_margin != TICK_NSEC);\n\n\tj1 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);\n\tschedule_timeout_uninterruptible(HZ);\n\tj2 = clocksource_wdtest_jiffies.read(&clocksource_wdtest_jiffies);\n\tWARN_ON_ONCE(j1 == j2);\n\n\tclocksource_unregister(&clocksource_wdtest_jiffies);\n\n\t \n\tpr_info(\"--- Verify tsc-like uncertainty margin.\\n\");\n\tclocksource_register_khz(&clocksource_wdtest_ktime, 1000 * 1000);\n\tWARN_ON_ONCE(clocksource_wdtest_ktime.uncertainty_margin < NSEC_PER_USEC);\n\n\tj1 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);\n\tudelay(1);\n\tj2 = clocksource_wdtest_ktime.read(&clocksource_wdtest_ktime);\n\tpr_info(\"--- tsc-like times: %lu - %lu = %lu.\\n\", j2, j1, j2 - j1);\n\tWARN_ON_ONCE(time_before(j2, j1 + NSEC_PER_USEC));\n\n\t \n\tfor (i = 0; i <= max_cswd_read_retries + 1; i++) {\n\t\tif (i <= 1 && i < max_cswd_read_retries)\n\t\t\ts = \"\";\n\t\telse if (i <= max_cswd_read_retries)\n\t\t\ts = \", expect message\";\n\t\telse\n\t\t\ts = \", expect clock skew\";\n\t\tpr_info(\"--- Watchdog with %dx error injection, %lu retries%s.\\n\", i, max_cswd_read_retries, s);\n\t\tWRITE_ONCE(wdtest_ktime_read_ndelays, i);\n\t\tschedule_timeout_uninterruptible(2 * HZ);\n\t\tWARN_ON_ONCE(READ_ONCE(wdtest_ktime_read_ndelays));\n\t\tWARN_ON_ONCE((i <= max_cswd_read_retries) !=\n\t\t\t     !(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));\n\t\twdtest_ktime_clocksource_reset();\n\t}\n\n\t \n\tpr_info(\"--- Watchdog clock-value-fuzz error injection, expect clock skew and per-CPU mismatches.\\n\");\n\tWRITE_ONCE(wdtest_ktime_read_fuzz, true);\n\tschedule_timeout_uninterruptible(2 * HZ);\n\tWARN_ON_ONCE(!(clocksource_wdtest_ktime.flags & CLOCK_SOURCE_UNSTABLE));\n\tclocksource_verify_percpu(&clocksource_wdtest_ktime);\n\tWRITE_ONCE(wdtest_ktime_read_fuzz, false);\n\n\tclocksource_unregister(&clocksource_wdtest_ktime);\n\n\tpr_info(\"--- Done with test.\\n\");\n\treturn 0;\n}\n\nstatic void wdtest_print_module_parms(void)\n{\n\tpr_alert(\"--- holdoff=%d\\n\", holdoff);\n}\n\n \nstatic void clocksource_wdtest_cleanup(void)\n{\n}\n\nstatic int __init clocksource_wdtest_init(void)\n{\n\tint ret = 0;\n\n\twdtest_print_module_parms();\n\n\t \n\twdtest_task = kthread_run(wdtest_func, NULL, \"wdtest\");\n\tif (IS_ERR(wdtest_task)) {\n\t\tret = PTR_ERR(wdtest_task);\n\t\tpr_warn(\"%s: Failed to create wdtest kthread.\\n\", __func__);\n\t\twdtest_task = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(clocksource_wdtest_init);\nmodule_exit(clocksource_wdtest_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}