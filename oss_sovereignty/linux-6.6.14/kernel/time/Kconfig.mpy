{
  "module_name": "Kconfig",
  "hash_id": "60cb2f29cf0d209011d4379701c2b47ee9a17ed666b4d7f10718a94e0d98ac7a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Timer subsystem related configuration options\n#\n\n# Options selectable by arch Kconfig\n\n# Watchdog function for clocksources to detect instabilities\nconfig CLOCKSOURCE_WATCHDOG\n\tbool\n\n# Architecture has extra clocksource data\nconfig ARCH_CLOCKSOURCE_DATA\n\tbool\n\n# Architecture has extra clocksource init called from registration\nconfig ARCH_CLOCKSOURCE_INIT\n\tbool\n\n# Clocksources require validation of the clocksource against the last\n# cycle update - x86/TSC misfeature\nconfig CLOCKSOURCE_VALIDATE_LAST_CYCLE\n\tbool\n\n# Timekeeping vsyscall support\nconfig GENERIC_TIME_VSYSCALL\n\tbool\n\n# The generic clock events infrastructure\nconfig GENERIC_CLOCKEVENTS\n\tdef_bool !LEGACY_TIMER_TICK\n\n# Architecture can handle broadcast in a driver-agnostic way\nconfig ARCH_HAS_TICK_BROADCAST\n\tbool\n\n# Clockevents broadcasting infrastructure\nconfig GENERIC_CLOCKEVENTS_BROADCAST\n\tbool\n\tdepends on GENERIC_CLOCKEVENTS\n\n# Automatically adjust the min. reprogramming time for\n# clock event device\nconfig GENERIC_CLOCKEVENTS_MIN_ADJUST\n\tbool\n\n# Generic update of CMOS clock\nconfig GENERIC_CMOS_UPDATE\n\tbool\n\n# Select to handle posix CPU timers from task_work\n# and not from the timer interrupt context\nconfig HAVE_POSIX_CPU_TIMERS_TASK_WORK\n\tbool\n\nconfig POSIX_CPU_TIMERS_TASK_WORK\n\tbool\n\tdefault y if POSIX_TIMERS && HAVE_POSIX_CPU_TIMERS_TASK_WORK\n\nconfig LEGACY_TIMER_TICK\n\tbool\n\thelp\n\t  The legacy timer tick helper is used by platforms that\n\t  lack support for the generic clockevent framework.\n\t  New platforms should use generic clockevents instead.\n\nconfig TIME_KUNIT_TEST\n\ttristate \"KUnit test for kernel/time functions\" if !KUNIT_ALL_TESTS\n\tdepends on KUNIT\n\tdefault KUNIT_ALL_TESTS\n\thelp\n\t  Enable this option to test RTC library functions.\n\n\t  If unsure, say N.\n\nconfig CONTEXT_TRACKING\n\tbool\n\nconfig CONTEXT_TRACKING_IDLE\n\tbool\n\tselect CONTEXT_TRACKING\n\thelp\n\t  Tracks idle state on behalf of RCU.\n\nif GENERIC_CLOCKEVENTS\nmenu \"Timers subsystem\"\n\n# Core internal switch. Selected by NO_HZ_COMMON / HIGH_RES_TIMERS. This is\n# only related to the tick functionality. Oneshot clockevent devices\n# are supported independent of this.\nconfig TICK_ONESHOT\n\tbool\n\nconfig NO_HZ_COMMON\n\tbool\n\tselect TICK_ONESHOT\n\nchoice\n\tprompt \"Timer tick handling\"\n\tdefault NO_HZ_IDLE if NO_HZ\n\nconfig HZ_PERIODIC\n\tbool \"Periodic timer ticks (constant rate, no dynticks)\"\n\thelp\n\t  This option keeps the tick running periodically at a constant\n\t  rate, even when the CPU doesn't need it.\n\nconfig NO_HZ_IDLE\n\tbool \"Idle dynticks system (tickless idle)\"\n\tselect NO_HZ_COMMON\n\thelp\n\t  This option enables a tickless idle system: timer interrupts\n\t  will only trigger on an as-needed basis when the system is idle.\n\t  This is usually interesting for energy saving.\n\n\t  Most of the time you want to say Y here.\n\nconfig NO_HZ_FULL\n\tbool \"Full dynticks system (tickless)\"\n\t# NO_HZ_COMMON dependency\n\t# We need at least one periodic CPU for timekeeping\n\tdepends on SMP\n\tdepends on HAVE_CONTEXT_TRACKING_USER\n\t# VIRT_CPU_ACCOUNTING_GEN dependency\n\tdepends on HAVE_VIRT_CPU_ACCOUNTING_GEN\n\tselect NO_HZ_COMMON\n\tselect RCU_NOCB_CPU\n\tselect VIRT_CPU_ACCOUNTING_GEN\n\tselect IRQ_WORK\n\tselect CPU_ISOLATION\n\thelp\n\t Adaptively try to shutdown the tick whenever possible, even when\n\t the CPU is running tasks. Typically this requires running a single\n\t task on the CPU. Chances for running tickless are maximized when\n\t the task mostly runs in userspace and has few kernel activity.\n\n\t You need to fill up the nohz_full boot parameter with the\n\t desired range of dynticks CPUs to use it. This is implemented at\n\t the expense of some overhead in user <-> kernel transitions:\n\t syscalls, exceptions and interrupts.\n\n\t By default, without passing the nohz_full parameter, this behaves just\n\t like NO_HZ_IDLE.\n\n\t If you're a distro say Y.\n\nendchoice\n\nconfig CONTEXT_TRACKING_USER\n\tbool\n\tdepends on HAVE_CONTEXT_TRACKING_USER\n\tselect CONTEXT_TRACKING\n\thelp\n\t  Track transitions between kernel and user on behalf of RCU and\n\t  tickless cputime accounting. The former case relies on context\n\t  tracking to enter/exit RCU extended quiescent states.\n\nconfig CONTEXT_TRACKING_USER_FORCE\n\tbool \"Force user context tracking\"\n\tdepends on CONTEXT_TRACKING_USER\n\tdefault y if !NO_HZ_FULL\n\thelp\n\t  The major pre-requirement for full dynticks to work is to\n\t  support the user context tracking subsystem. But there are also\n\t  other dependencies to provide in order to make the full\n\t  dynticks working.\n\n\t  This option stands for testing when an arch implements the\n\t  user context tracking backend but doesn't yet fulfill all the\n\t  requirements to make the full dynticks feature working.\n\t  Without the full dynticks, there is no way to test the support\n\t  for user context tracking and the subsystems that rely on it: RCU\n\t  userspace extended quiescent state and tickless cputime\n\t  accounting. This option copes with the absence of the full\n\t  dynticks subsystem by forcing the user context tracking on all\n\t  CPUs in the system.\n\n\t  Say Y only if you're working on the development of an\n\t  architecture backend for the user context tracking.\n\n\t  Say N otherwise, this option brings an overhead that you\n\t  don't want in production.\n\nconfig NO_HZ\n\tbool \"Old Idle dynticks config\"\n\thelp\n\t  This is the old config entry that enables dynticks idle.\n\t  We keep it around for a little while to enforce backward\n\t  compatibility with older config files.\n\nconfig HIGH_RES_TIMERS\n\tbool \"High Resolution Timer Support\"\n\tselect TICK_ONESHOT\n\thelp\n\t  This option enables high resolution timer support. If your\n\t  hardware is not capable then this option only increases\n\t  the size of the kernel image.\n\nconfig CLOCKSOURCE_WATCHDOG_MAX_SKEW_US\n\tint \"Clocksource watchdog maximum allowable skew (in \u03bcs)\"\n\tdepends on CLOCKSOURCE_WATCHDOG\n\trange 50 1000\n\tdefault 125\n\thelp\n\t  Specify the maximum amount of allowable watchdog skew in\n\t  microseconds before reporting the clocksource to be unstable.\n\t  The default is based on a half-second clocksource watchdog\n\t  interval and NTP's maximum frequency drift of 500 parts\n\t  per million.\tIf the clocksource is good enough for NTP,\n\t  it is good enough for the clocksource watchdog!\n\nendmenu\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}