{
  "module_name": "sched_clock.c",
  "hash_id": "c25074724e691394f34117b83bc3a1df284c8c879e2a93ac8c035cc0c5bcd0cc",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/sched_clock.c",
  "human_readable_source": "\n \n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/math.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/syscore_ops.h>\n#include <linux/hrtimer.h>\n#include <linux/sched_clock.h>\n#include <linux/seqlock.h>\n#include <linux/bitops.h>\n\n#include \"timekeeping.h\"\n\n \nstruct clock_data {\n\tseqcount_latch_t\tseq;\n\tstruct clock_read_data\tread_data[2];\n\tktime_t\t\t\twrap_kt;\n\tunsigned long\t\trate;\n\n\tu64 (*actual_read_sched_clock)(void);\n};\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\n\ncore_param(irqtime, irqtime, int, 0400);\n\nstatic u64 notrace jiffy_sched_clock_read(void)\n{\n\t \n\treturn (u64)(jiffies - INITIAL_JIFFIES);\n}\n\nstatic struct clock_data cd ____cacheline_aligned = {\n\t.read_data[0] = { .mult = NSEC_PER_SEC / HZ,\n\t\t\t  .read_sched_clock = jiffy_sched_clock_read, },\n\t.actual_read_sched_clock = jiffy_sched_clock_read,\n};\n\nstatic __always_inline u64 cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}\n\nnotrace struct clock_read_data *sched_clock_read_begin(unsigned int *seq)\n{\n\t*seq = raw_read_seqcount_latch(&cd.seq);\n\treturn cd.read_data + (*seq & 1);\n}\n\nnotrace int sched_clock_read_retry(unsigned int seq)\n{\n\treturn raw_read_seqcount_latch_retry(&cd.seq, seq);\n}\n\nunsigned long long noinstr sched_clock_noinstr(void)\n{\n\tstruct clock_read_data *rd;\n\tunsigned int seq;\n\tu64 cyc, res;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&cd.seq);\n\t\trd = cd.read_data + (seq & 1);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (raw_read_seqcount_latch_retry(&cd.seq, seq));\n\n\treturn res;\n}\n\nunsigned long long notrace sched_clock(void)\n{\n\tunsigned long long ns;\n\tpreempt_disable_notrace();\n\tns = sched_clock_noinstr();\n\tpreempt_enable_notrace();\n\treturn ns;\n}\n\n \nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t \n\tcd.read_data[1] = *rd;\n\n\t \n\traw_write_seqcount_latch(&cd.seq);\n\n\t \n\tcd.read_data[0] = *rd;\n\n\t \n\traw_write_seqcount_latch(&cd.seq);\n}\n\n \nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}\n\nstatic enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn HRTIMER_RESTART;\n}\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r, flags;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t \n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t \n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t \n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt,\n\t\t\t      HRTIMER_MODE_REL_HARD);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr = DIV_ROUND_CLOSEST(r, 1000000);\n\t\tr_unit = 'M';\n\t} else if (r >= 4000) {\n\t\tr = DIV_ROUND_CLOSEST(r, 1000);\n\t\tr_unit = 'k';\n\t} else {\n\t\tr_unit = ' ';\n\t}\n\n\t \n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t \n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tlocal_irq_restore(flags);\n\n\tpr_debug(\"Registered %pS as sched_clock source\\n\", read);\n}\n\nvoid __init generic_sched_clock_init(void)\n{\n\t \n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t \n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n}\n\n \nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned int seq = raw_read_seqcount_latch(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}\n\nint sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}\n\nvoid sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL_HARD);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}\n\nstatic struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};\n\nstatic int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}\ndevice_initcall(sched_clock_syscore_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}