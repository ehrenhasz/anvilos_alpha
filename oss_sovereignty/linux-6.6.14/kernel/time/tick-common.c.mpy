{
  "module_name": "tick-common.c",
  "hash_id": "049b2f9d20dfe92e17c1186d47f2db5e44850c3e97fa071ebff958cbdc012db0",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/tick-common.c",
  "human_readable_source": "\n \n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/hrtimer.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/profile.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <trace/events/power.h>\n\n#include <asm/irq_regs.h>\n\n#include \"tick-internal.h\"\n\n \nDEFINE_PER_CPU(struct tick_device, tick_cpu_device);\n \nktime_t tick_next_period;\n\n \nint tick_do_timer_cpu __read_mostly = TICK_DO_TIMER_BOOT;\n#ifdef CONFIG_NO_HZ_FULL\n \nstatic int tick_do_timer_boot_cpu __read_mostly = -1;\n#endif\n\n \nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}\n\n \nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn 0;\n\tif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}\n\n \nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\traw_spin_lock(&jiffies_lock);\n\t\twrite_seqcount_begin(&jiffies_seq);\n\n\t\t \n\t\ttick_next_period = ktime_add_ns(tick_next_period, TICK_NSEC);\n\n\t\tdo_timer(1);\n\t\twrite_seqcount_end(&jiffies_seq);\n\t\traw_spin_unlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(CPU_PROFILING);\n}\n\n \nvoid tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n#if defined(CONFIG_HIGH_RES_TIMERS) || defined(CONFIG_NO_HZ_COMMON)\n\t \n\tif (dev->event_handler != tick_handle_periodic)\n\t\treturn;\n#endif\n\n\tif (!clockevent_state_oneshot(dev))\n\t\treturn;\n\tfor (;;) {\n\t\t \n\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t \n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}\n\n \nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t \n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\t} else {\n\t\tunsigned int seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&jiffies_seq);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqcount_retry(&jiffies_seq, seq));\n\n\t\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add_ns(next, TICK_NSEC);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_NO_HZ_FULL\nstatic void giveup_do_timer(void *info)\n{\n\tint cpu = *(unsigned int *)info;\n\n\tWARN_ON(tick_do_timer_cpu != smp_processor_id());\n\n\ttick_do_timer_cpu = cpu;\n}\n\nstatic void tick_take_do_timer_from_boot(void)\n{\n\tint cpu = smp_processor_id();\n\tint from = tick_do_timer_boot_cpu;\n\n\tif (from >= 0 && from != cpu)\n\t\tsmp_call_function_single(from, giveup_do_timer, &cpu, 1);\n}\n#endif\n\n \nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tvoid (*handler)(struct clock_event_device *) = NULL;\n\tktime_t next_event = 0;\n\n\t \n\tif (!td->evtdev) {\n\t\t \n\t\tif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\n\t\t\ttick_do_timer_cpu = cpu;\n\t\t\ttick_next_period = ktime_get();\n#ifdef CONFIG_NO_HZ_FULL\n\t\t\t \n\t\t\tif (tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_boot_cpu = cpu;\n\n\t\t} else if (tick_do_timer_boot_cpu != -1 &&\n\t\t\t\t\t\t!tick_nohz_full_cpu(cpu)) {\n\t\t\ttick_take_do_timer_from_boot();\n\t\t\ttick_do_timer_boot_cpu = -1;\n\t\t\tWARN_ON(tick_do_timer_cpu != cpu);\n#endif\n\t\t}\n\n\t\t \n\t\ttd->mode = TICKDEV_MODE_PERIODIC;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t \n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t \n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t \n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t \n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t \n\tif (!(newdev->features & CLOCK_EVT_FEAT_ONESHOT)) {\n\t\tif (curdev && (curdev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t \n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}\n\n \nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}\n\n \nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t \n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t \n\ttick_install_broadcast_device(newdev, cpu);\n}\n\n \nint tick_broadcast_oneshot_control(enum tick_broadcast_state state)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tif (!(td->evtdev->features & CLOCK_EVT_FEAT_C3STOP))\n\t\treturn 0;\n\n\treturn __tick_broadcast_oneshot_control(state);\n}\nEXPORT_SYMBOL_GPL(tick_broadcast_oneshot_control);\n\n#ifdef CONFIG_HOTPLUG_CPU\n \nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id())\n\t\ttick_do_timer_cpu = cpumask_first(cpu_online_mask);\n}\n\n \nvoid tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t \n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}\n#endif\n\n \nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}\n\n \nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == TICKDEV_MODE_PERIODIC)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n\n\t \n\thrtimers_resume_local();\n}\n\n \nvoid tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}\n\n \nvoid tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}\n\n#ifdef CONFIG_SUSPEND\nstatic DEFINE_RAW_SPINLOCK(tick_freeze_lock);\nstatic unsigned int tick_freeze_depth;\n\n \nvoid tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), true);\n\t\tsystem_state = SYSTEM_SUSPEND;\n\t\tsched_clock_suspend();\n\t\ttimekeeping_suspend();\n\t} else {\n\t\ttick_suspend_local();\n\t}\n\n\traw_spin_unlock(&tick_freeze_lock);\n}\n\n \nvoid tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus()) {\n\t\ttimekeeping_resume();\n\t\tsched_clock_resume();\n\t\tsystem_state = SYSTEM_RUNNING;\n\t\ttrace_suspend_resume(TPS(\"timekeeping_freeze\"),\n\t\t\t\t     smp_processor_id(), false);\n\t} else {\n\t\ttouch_softlockup_watchdog();\n\t\ttick_resume_local();\n\t}\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}\n#endif  \n\n \nvoid __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}