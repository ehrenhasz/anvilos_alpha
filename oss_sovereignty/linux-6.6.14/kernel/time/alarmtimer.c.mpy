{
  "module_name": "alarmtimer.c",
  "hash_id": "fe01bdbfeee8084ddb83acea152df7f8d74e61cd1d62f324b775ad4eb490b549",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/alarmtimer.c",
  "human_readable_source": "\n \n#include <linux/time.h>\n#include <linux/hrtimer.h>\n#include <linux/timerqueue.h>\n#include <linux/rtc.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/debug.h>\n#include <linux/alarmtimer.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/posix-timers.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/time_namespace.h>\n\n#include \"posix-timers.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/alarmtimer.h>\n\n \nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\n#if defined(CONFIG_POSIX_TIMERS) || defined(CONFIG_RTC_CLASS)\n \nstatic enum alarmtimer_type freezer_alarmtype;\nstatic ktime_t freezer_expires;\nstatic ktime_t freezer_delta;\nstatic DEFINE_SPINLOCK(freezer_delta_lock);\n#endif\n\n#ifdef CONFIG_RTC_CLASS\n \nstatic struct rtc_timer\t\trtctimer;\nstatic struct rtc_device\t*rtcdev;\nstatic DEFINE_SPINLOCK(rtcdev_lock);\n\n \nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(alarmtimer_get_rtcdev);\n\nstatic int alarmtimer_rtc_add_device(struct device *dev)\n{\n\tunsigned long flags;\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tstruct platform_device *pdev;\n\tint ret = 0;\n\n\tif (rtcdev)\n\t\treturn -EBUSY;\n\n\tif (!test_bit(RTC_FEATURE_ALARM, rtc->features))\n\t\treturn -1;\n\tif (!device_may_wakeup(rtc->dev.parent))\n\t\treturn -1;\n\n\tpdev = platform_device_register_data(dev, \"alarmtimer\",\n\t\t\t\t\t     PLATFORM_DEVID_AUTO, NULL, 0);\n\tif (!IS_ERR(pdev))\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tif (!IS_ERR(pdev) && !rtcdev) {\n\t\tif (!try_module_get(rtc->owner)) {\n\t\t\tret = -1;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\trtcdev = rtc;\n\t\t \n\t\tget_device(dev);\n\t\tpdev = NULL;\n\t} else {\n\t\tret = -1;\n\t}\nunlock:\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\tplatform_device_unregister(pdev);\n\n\treturn ret;\n}\n\nstatic inline void alarmtimer_rtc_timer_init(void)\n{\n\trtc_timer_init(&rtctimer, NULL, NULL);\n}\n\nstatic struct class_interface alarmtimer_rtc_interface = {\n\t.add_dev = &alarmtimer_rtc_add_device,\n};\n\nstatic int alarmtimer_rtc_interface_setup(void)\n{\n\talarmtimer_rtc_interface.class = rtc_class;\n\treturn class_interface_register(&alarmtimer_rtc_interface);\n}\nstatic void alarmtimer_rtc_interface_remove(void)\n{\n\tclass_interface_unregister(&alarmtimer_rtc_interface);\n}\n#else\nstatic inline int alarmtimer_rtc_interface_setup(void) { return 0; }\nstatic inline void alarmtimer_rtc_interface_remove(void) { }\nstatic inline void alarmtimer_rtc_timer_init(void) { }\n#endif\n\n \nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}\n\n \nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}\n\n\n \nstatic enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)\n{\n\tstruct alarm *alarm = container_of(timer, struct alarm, timer);\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret = HRTIMER_NORESTART;\n\tint restart = ALARMTIMER_NORESTART;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\tif (alarm->function)\n\t\trestart = alarm->function(alarm, base->get_ktime());\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tif (restart != ALARMTIMER_NORESTART) {\n\t\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\t\talarmtimer_enqueue(base, alarm);\n\t\tret = HRTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_fired(alarm, base->get_ktime());\n\treturn ret;\n\n}\n\nktime_t alarm_expires_remaining(const struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\treturn ktime_sub(alarm->node.expires, base->get_ktime());\n}\nEXPORT_SYMBOL_GPL(alarm_expires_remaining);\n\n#ifdef CONFIG_RTC_CLASS\n \nstatic int alarmtimer_suspend(struct device *dev)\n{\n\tktime_t min, now, expires;\n\tint i, ret, type;\n\tstruct rtc_device *rtc;\n\tunsigned long flags;\n\tstruct rtc_time tm;\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tmin = freezer_delta;\n\texpires = freezer_expires;\n\ttype = freezer_alarmtype;\n\tfreezer_delta = 0;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n\n\trtc = alarmtimer_get_rtcdev();\n\t \n\tif (!rtc)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->lock, flags);\n\t\tnext = timerqueue_getnext(&base->timerqueue);\n\t\tspin_unlock_irqrestore(&base->lock, flags);\n\t\tif (!next)\n\t\t\tcontinue;\n\t\tdelta = ktime_sub(next->expires, base->get_ktime());\n\t\tif (!min || (delta < min)) {\n\t\t\texpires = next->expires;\n\t\t\tmin = delta;\n\t\t\ttype = i;\n\t\t}\n\t}\n\tif (min == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {\n\t\tpm_wakeup_event(dev, 2 * MSEC_PER_SEC);\n\t\treturn -EBUSY;\n\t}\n\n\ttrace_alarmtimer_suspend(expires, type);\n\n\t \n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t \n\tret = rtc_timer_start(rtc, &rtctimer, now, 0);\n\tif (ret < 0)\n\t\tpm_wakeup_event(dev, MSEC_PER_SEC);\n\treturn ret;\n}\n\nstatic int alarmtimer_resume(struct device *dev)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = alarmtimer_get_rtcdev();\n\tif (rtc)\n\t\trtc_timer_cancel(rtc, &rtctimer);\n\treturn 0;\n}\n\n#else\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int alarmtimer_resume(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}\n\n \nvoid alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t     HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}\nEXPORT_SYMBOL_GPL(alarm_init);\n\n \nvoid alarm_start(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarm->node.expires = start;\n\talarmtimer_enqueue(base, alarm);\n\thrtimer_start(&alarm->timer, alarm->node.expires, HRTIMER_MODE_ABS);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_start(alarm, base->get_ktime());\n}\nEXPORT_SYMBOL_GPL(alarm_start);\n\n \nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}\nEXPORT_SYMBOL_GPL(alarm_start_relative);\n\nvoid alarm_restart(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\thrtimer_restart(&alarm->timer);\n\talarmtimer_enqueue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}\nEXPORT_SYMBOL_GPL(alarm_restart);\n\n \nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(alarm_try_to_cancel);\n\n\n \nint alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\thrtimer_cancel_wait_running(&alarm->timer);\n\t}\n}\nEXPORT_SYMBOL_GPL(alarm_cancel);\n\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t \n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}\nEXPORT_SYMBOL_GPL(alarm_forward);\n\nstatic u64 __alarm_forward_now(struct alarm *alarm, ktime_t interval, bool throttle)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tktime_t now = base->get_ktime();\n\n\tif (IS_ENABLED(CONFIG_HIGH_RES_TIMERS) && throttle) {\n\t\t \n\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\tif (interval < kj)\n\t\t\tnow = ktime_add(now, kj);\n\t}\n\n\treturn alarm_forward(alarm, now, interval);\n}\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\treturn __alarm_forward_now(alarm, interval, false);\n}\nEXPORT_SYMBOL_GPL(alarm_forward_now);\n\n#ifdef CONFIG_POSIX_TIMERS\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->get_ktime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}\n\n \nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}\n\n \nstatic enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,\n\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct k_itimer *ptr = container_of(alarm, struct k_itimer,\n\t\t\t\t\t    it.alarm.alarmtimer);\n\tenum alarmtimer_restart result = ALARMTIMER_NORESTART;\n\tunsigned long flags;\n\tint si_private = 0;\n\n\tspin_lock_irqsave(&ptr->it_lock, flags);\n\n\tptr->it_active = 0;\n\tif (ptr->it_interval)\n\t\tsi_private = ++ptr->it_requeue_pending;\n\n\tif (posix_timer_event(ptr, si_private) && ptr->it_interval) {\n\t\t \n\t\tptr->it_overrun += __alarm_forward_now(alarm, ptr->it_interval, true);\n\t\t++ptr->it_requeue_pending;\n\t\tptr->it_active = 1;\n\t\tresult = ALARMTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&ptr->it_lock, flags);\n\n\treturn result;\n}\n\n \nstatic void alarm_timer_rearm(struct k_itimer *timr)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\ttimr->it_overrun += alarm_forward_now(alarm, timr->it_interval);\n\talarm_start(alarm, alarm->node.expires);\n}\n\n \nstatic s64 alarm_timer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn alarm_forward(alarm, timr->it_interval, now);\n}\n\n \nstatic ktime_t alarm_timer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn ktime_sub(alarm->node.expires, now);\n}\n\n \nstatic int alarm_timer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn alarm_try_to_cancel(&timr->it.alarm.alarmtimer);\n}\n\n \nstatic void alarm_timer_wait_running(struct k_itimer *timr)\n{\n\thrtimer_cancel_wait_running(&timr->it.alarm.alarmtimer.timer);\n}\n\n \nstatic void alarm_timer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t    bool absolute, bool sigev_none)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, base->get_ktime());\n\tif (sigev_none)\n\t\talarm->node.expires = expires;\n\telse\n\t\talarm_start(&timr->it.alarm.alarmtimer, expires);\n}\n\n \nstatic int alarm_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}\n\n \nstatic int alarm_clock_get_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\tbase->get_timespec(tp);\n\n\treturn 0;\n}\n\n \nstatic ktime_t alarm_clock_get_ktime(clockid_t which_clock)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\treturn base->get_ktime();\n}\n\n \nstatic int alarm_timer_create(struct k_itimer *new_timer)\n{\n\tenum  alarmtimer_type type;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EOPNOTSUPP;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\ttype = clock2alarm(new_timer->it_clock);\n\talarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);\n\treturn 0;\n}\n\n \nstatic enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,\n\t\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct task_struct *task = alarm->data;\n\n\talarm->data = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\treturn ALARMTIMER_NORESTART;\n}\n\n \nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}\n\n \nstatic long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->nanosleep.clockid;\n\tktime_t exp = restart->nanosleep.expires;\n\tstruct alarm alarm;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\treturn alarmtimer_do_nsleep(&alarm, exp, type);\n}\n\n \nstatic int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t \n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].get_ktime();\n\n\t\texp = ktime_add_safe(now, exp);\n\t} else {\n\t\texp = timens_ktime_to_host(which_clock, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t \n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\tset_restart_fn(restart, alarm_timer_nsleep_restart);\n\treturn ret;\n}\n\nconst struct k_clock alarm_clock = {\n\t.clock_getres\t\t= alarm_clock_getres,\n\t.clock_get_ktime\t= alarm_clock_get_ktime,\n\t.clock_get_timespec\t= alarm_clock_get_timespec,\n\t.timer_create\t\t= alarm_timer_create,\n\t.timer_set\t\t= common_timer_set,\n\t.timer_del\t\t= common_timer_del,\n\t.timer_get\t\t= common_timer_get,\n\t.timer_arm\t\t= alarm_timer_arm,\n\t.timer_rearm\t\t= alarm_timer_rearm,\n\t.timer_forward\t\t= alarm_timer_forward,\n\t.timer_remaining\t= alarm_timer_remaining,\n\t.timer_try_to_cancel\t= alarm_timer_try_to_cancel,\n\t.timer_wait_running\t= alarm_timer_wait_running,\n\t.nsleep\t\t\t= alarm_timer_nsleep,\n};\n#endif  \n\n\n \nstatic const struct dev_pm_ops alarmtimer_pm_ops = {\n\t.suspend = alarmtimer_suspend,\n\t.resume = alarmtimer_resume,\n};\n\nstatic struct platform_driver alarmtimer_driver = {\n\t.driver = {\n\t\t.name = \"alarmtimer\",\n\t\t.pm = &alarmtimer_pm_ops,\n\t}\n};\n\nstatic void get_boottime_timespec(struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\ttimens_add_boottime(tp);\n}\n\n \nstatic int __init alarmtimer_init(void)\n{\n\tint error;\n\tint i;\n\n\talarmtimer_rtc_timer_init();\n\n\t \n\talarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;\n\talarm_bases[ALARM_REALTIME].get_ktime = &ktime_get_real;\n\talarm_bases[ALARM_REALTIME].get_timespec = ktime_get_real_ts64;\n\talarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;\n\talarm_bases[ALARM_BOOTTIME].get_ktime = &ktime_get_boottime;\n\talarm_bases[ALARM_BOOTTIME].get_timespec = get_boottime_timespec;\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\treturn 0;\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}\ndevice_initcall(alarmtimer_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}