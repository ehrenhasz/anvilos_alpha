{
  "module_name": "posix-stubs.c",
  "hash_id": "d7068bc0235c2e879e63c839fd793b2c9be8a437cc02fbaf3b50859e12490630",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/posix-stubs.c",
  "human_readable_source": "\n \n\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/syscalls.h>\n#include <linux/ktime.h>\n#include <linux/timekeeping.h>\n#include <linux/posix-timers.h>\n#include <linux/time_namespace.h>\n#include <linux/compat.h>\n\n \n\nSYSCALL_DEFINE2(clock_settime, const clockid_t, which_clock,\n\t\tconst struct __kernel_timespec __user *, tp)\n{\n\tstruct timespec64 new_tp;\n\n\tif (which_clock != CLOCK_REALTIME)\n\t\treturn -EINVAL;\n\tif (get_timespec64(&new_tp, tp))\n\t\treturn -EFAULT;\n\n\treturn do_sys_settimeofday64(&new_tp, NULL);\n}\n\nstatic int do_clock_gettime(clockid_t which_clock, struct timespec64 *tp)\n{\n\tswitch (which_clock) {\n\tcase CLOCK_REALTIME:\n\t\tktime_get_real_ts64(tp);\n\t\tbreak;\n\tcase CLOCK_MONOTONIC:\n\t\tktime_get_ts64(tp);\n\t\ttimens_add_monotonic(tp);\n\t\tbreak;\n\tcase CLOCK_BOOTTIME:\n\t\tktime_get_boottime_ts64(tp);\n\t\ttimens_add_boottime(tp);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(clock_gettime, const clockid_t, which_clock,\n\t\tstruct __kernel_timespec __user *, tp)\n{\n\tint ret;\n\tstruct timespec64 kernel_tp;\n\n\tret = do_clock_gettime(which_clock, &kernel_tp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (put_timespec64(&kernel_tp, tp))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(clock_getres, const clockid_t, which_clock, struct __kernel_timespec __user *, tp)\n{\n\tstruct timespec64 rtn_tp = {\n\t\t.tv_sec = 0,\n\t\t.tv_nsec = hrtimer_resolution,\n\t};\n\n\tswitch (which_clock) {\n\tcase CLOCK_REALTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_BOOTTIME:\n\t\tif (put_timespec64(&rtn_tp, tp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(clock_nanosleep, const clockid_t, which_clock, int, flags,\n\t\tconst struct __kernel_timespec __user *, rqtp,\n\t\tstruct __kernel_timespec __user *, rmtp)\n{\n\tstruct timespec64 t;\n\tktime_t texp;\n\n\tswitch (which_clock) {\n\tcase CLOCK_REALTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_BOOTTIME:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (get_timespec64(&t, rqtp))\n\t\treturn -EFAULT;\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;\n\tcurrent->restart_block.nanosleep.rmtp = rmtp;\n\ttexp = timespec64_to_ktime(t);\n\tif (flags & TIMER_ABSTIME)\n\t\ttexp = timens_ktime_to_host(which_clock, texp);\n\treturn hrtimer_nanosleep(texp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\nSYSCALL_DEFINE2(clock_settime32, const clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tstruct timespec64 new_tp;\n\n\tif (which_clock != CLOCK_REALTIME)\n\t\treturn -EINVAL;\n\tif (get_old_timespec32(&new_tp, tp))\n\t\treturn -EFAULT;\n\n\treturn do_sys_settimeofday64(&new_tp, NULL);\n}\n\nSYSCALL_DEFINE2(clock_gettime32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tint ret;\n\tstruct timespec64 kernel_tp;\n\n\tret = do_clock_gettime(which_clock, &kernel_tp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (put_old_timespec32(&kernel_tp, tp))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(clock_getres_time32, clockid_t, which_clock,\n\t\tstruct old_timespec32 __user *, tp)\n{\n\tstruct timespec64 rtn_tp = {\n\t\t.tv_sec = 0,\n\t\t.tv_nsec = hrtimer_resolution,\n\t};\n\n\tswitch (which_clock) {\n\tcase CLOCK_REALTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_BOOTTIME:\n\t\tif (put_old_timespec32(&rtn_tp, tp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(clock_nanosleep_time32, clockid_t, which_clock, int, flags,\n\t\tstruct old_timespec32 __user *, rqtp,\n\t\tstruct old_timespec32 __user *, rmtp)\n{\n\tstruct timespec64 t;\n\tktime_t texp;\n\n\tswitch (which_clock) {\n\tcase CLOCK_REALTIME:\n\tcase CLOCK_MONOTONIC:\n\tcase CLOCK_BOOTTIME:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (get_old_timespec32(&t, rqtp))\n\t\treturn -EFAULT;\n\tif (!timespec64_valid(&t))\n\t\treturn -EINVAL;\n\tif (flags & TIMER_ABSTIME)\n\t\trmtp = NULL;\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\tcurrent->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;\n\tcurrent->restart_block.nanosleep.compat_rmtp = rmtp;\n\ttexp = timespec64_to_ktime(t);\n\tif (flags & TIMER_ABSTIME)\n\t\ttexp = timens_ktime_to_host(which_clock, texp);\n\treturn hrtimer_nanosleep(texp, flags & TIMER_ABSTIME ?\n\t\t\t\t HRTIMER_MODE_ABS : HRTIMER_MODE_REL,\n\t\t\t\t which_clock);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}