{
  "module_name": "timer_list.c",
  "hash_id": "faef891aea58e93b6678c6658aa412e0f78d7d3725a719d5f0076f78a95e53bb",
  "original_prompt": "Ingested from linux-6.6.14/kernel/time/timer_list.c",
  "human_readable_source": "\n \n\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/nmi.h>\n\n#include <linux/uaccess.h>\n\n#include \"tick-internal.h\"\n\nstruct timer_list_iter {\n\tint cpu;\n\tbool second_pass;\n\tu64 now;\n};\n\n \n__printf(2, 3)\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: <%pK>, %ps\", idx, taddr, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t \n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   %ps\\n\", base->get_time);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\nstatic void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: %ps\\n\", dev->set_next_event);\n\n\tif (dev->set_state_shutdown)\n\t\tSEQ_printf(m, \" shutdown:       %ps\\n\",\n\t\t\tdev->set_state_shutdown);\n\n\tif (dev->set_state_periodic)\n\t\tSEQ_printf(m, \" periodic:       %ps\\n\",\n\t\t\tdev->set_state_periodic);\n\n\tif (dev->set_state_oneshot)\n\t\tSEQ_printf(m, \" oneshot:        %ps\\n\",\n\t\t\tdev->set_state_oneshot);\n\n\tif (dev->set_state_oneshot_stopped)\n\t\tSEQ_printf(m, \" oneshot stopped: %ps\\n\",\n\t\t\tdev->set_state_oneshot_stopped);\n\n\tif (dev->tick_resume)\n\t\tSEQ_printf(m, \" resume:         %ps\\n\",\n\t\t\tdev->tick_resume);\n\n\tSEQ_printf(m, \" event_handler:  %ps\\n\", dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tif (cpu >= 0) {\n\t\tconst struct clock_event_device *wd = tick_get_wakeup_device(cpu);\n\n\t\tSEQ_printf(m, \"Wakeup Device: %s\\n\", wd ? wd->name : \"<NULL>\");\n\t}\n#endif\n\tSEQ_printf(m, \"\\n\");\n}\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}\n#endif\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}\n\nvoid sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}\n\nstatic void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}\n\nstatic void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}\n\nstatic void timer_list_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations timer_list_sops = {\n\t.start = timer_list_start,\n\t.next = timer_list_next,\n\t.stop = timer_list_stop,\n\t.show = timer_list_show,\n};\n\nstatic int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create_seq_private(\"timer_list\", 0400, NULL, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter), NULL);\n\tif (!pe)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n__initcall(init_timer_list_procfs);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}