{
  "module_name": "audit_watch.c",
  "hash_id": "13411152b62818376709194421aae7acdf01f8d1cc1396302b5bbdfcebf81ad7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/audit_watch.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/audit.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/namei.h>\n#include <linux/netlink.h>\n#include <linux/refcount.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include \"audit.h\"\n\n \n\nstruct audit_watch {\n\trefcount_t\t\tcount;\t \n\tdev_t\t\t\tdev;\t \n\tchar\t\t\t*path;\t \n\tunsigned long\t\tino;\t \n\tstruct audit_parent\t*parent;  \n\tstruct list_head\twlist;\t \n\tstruct list_head\trules;\t \n};\n\nstruct audit_parent {\n\tstruct list_head\twatches;  \n\tstruct fsnotify_mark mark;  \n};\n\n \nstatic struct fsnotify_group *audit_watch_group;\n\n \n#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_UNMOUNT)\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}\n\nstatic void audit_watch_free_mark(struct fsnotify_mark *entry)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(entry, struct audit_parent, mark);\n\taudit_free_parent(parent);\n}\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}\n\n \nstatic inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}\n\nstatic void audit_remove_watch(struct audit_watch *watch)\n{\n\tlist_del(&watch->wlist);\n\taudit_put_parent(watch->parent);\n\twatch->parent = NULL;\n\taudit_put_watch(watch);  \n}\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}\n\nint audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}\n\n \nstatic struct audit_parent *audit_init_parent(const struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}\n\n \nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}\n\n \nint audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    (krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}\n\n \nstatic struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}\n\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_format(ab, \"op=%s path=\", op);\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}\n\n \nstatic void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const struct qstr *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t \n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t \n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t \n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent;  \n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}\n\n \nstatic void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}\n\n \nstatic int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d_is_positive(d)) {\n\t\t \n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tdput(d);\n\treturn 0;\n}\n\n \nstatic void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t \n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}\n\n \nint audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t \n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t \n\tret = audit_get_nd(watch, &parent_path);\n\n\t \n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t \n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t \n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}\n\n \nstatic int audit_watch_handle_event(struct fsnotify_mark *inode_mark, u32 mask,\n\t\t\t\t    struct inode *inode, struct inode *dir,\n\t\t\t\t    const struct qstr *dname, u32 cookie)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(inode_mark, struct audit_parent, mark);\n\n\tif (WARN_ON_ONCE(inode_mark->group != audit_watch_group))\n\t\treturn 0;\n\n\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)\n\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);\n\telse if (mask & (FS_DELETE|FS_MOVED_FROM))\n\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);\n\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\n\t\taudit_remove_parent_watches(parent);\n\n\treturn 0;\n}\n\nstatic const struct fsnotify_ops audit_watch_fsnotify_ops = {\n\t.handle_inode_event =\taudit_watch_handle_event,\n\t.free_mark =\t\taudit_watch_free_mark,\n};\n\nstatic int __init audit_watch_init(void)\n{\n\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops, 0);\n\tif (IS_ERR(audit_watch_group)) {\n\t\taudit_watch_group = NULL;\n\t\taudit_panic(\"cannot create audit fsnotify group\");\n\t}\n\treturn 0;\n}\ndevice_initcall(audit_watch_init);\n\nint audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\t \n\tif (tsk != current)\n\t\treturn 0;\n\n\tif (!current->mm)\n\t\treturn 0;\n\texe_file = get_mm_exe_file(current->mm);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\n\treturn audit_mark_compare(mark, ino, dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}