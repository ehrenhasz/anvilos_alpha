{
  "module_name": "usermode_driver.c",
  "hash_id": "302d6209511038b74e03c4838a7396998bf88b632156b8fcf68c58c1b46ca62f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/usermode_driver.c",
  "human_readable_source": "\n \n#include <linux/shmem_fs.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/usermode_driver.h>\n\nstatic struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)\n{\n\tstruct file_system_type *type;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\n\ttype = get_fs_type(\"tmpfs\");\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = kern_mount(type);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn mnt;\n\n\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);\n\tif (IS_ERR(file)) {\n\t\tkern_unmount(mnt);\n\t\treturn ERR_CAST(file);\n\t}\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\tint err = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tfilp_close(file, NULL);\n\t\tkern_unmount(mnt);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfput(file);\n\n\t \n\tflush_delayed_fput();\n\ttask_work_run();\n\treturn mnt;\n}\n\n \nint umd_load_blob(struct umd_info *info, const void *data, size_t len)\n{\n\tstruct vfsmount *mnt;\n\n\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))\n\t\treturn -EBUSY;\n\n\tmnt = blob_to_mnt(data, len, info->driver_name);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tinfo->wd.mnt = mnt;\n\tinfo->wd.dentry = mnt->mnt_root;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(umd_load_blob);\n\n \nint umd_unload_blob(struct umd_info *info)\n{\n\tif (WARN_ON_ONCE(!info->wd.mnt ||\n\t\t\t !info->wd.dentry ||\n\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))\n\t\treturn -EINVAL;\n\n\tkern_unmount(info->wd.mnt);\n\tinfo->wd.mnt = NULL;\n\tinfo->wd.dentry = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(umd_unload_blob);\n\nstatic int umd_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct umd_info *umd_info = info->data;\n\tstruct file *from_umh[2];\n\tstruct file *to_umh[2];\n\tint err;\n\n\t \n\terr = create_pipe_files(to_umh, 0);\n\tif (err)\n\t\treturn err;\n\terr = replace_fd(0, to_umh[0], 0);\n\tfput(to_umh[0]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treturn err;\n\t}\n\n\t \n\terr = create_pipe_files(from_umh, 0);\n\tif (err) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\treturn err;\n\t}\n\terr = replace_fd(1, from_umh[1], 0);\n\tfput(from_umh[1]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\tfput(from_umh[0]);\n\t\treturn err;\n\t}\n\n\tset_fs_pwd(current->fs, &umd_info->wd);\n\tumd_info->pipe_to_umh = to_umh[1];\n\tumd_info->pipe_from_umh = from_umh[0];\n\tumd_info->tgid = get_pid(task_tgid(current));\n\treturn 0;\n}\n\nstatic void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t \n\tif (info->retval)\n\t\tumd_cleanup_helper(umd_info);\n}\n\n \nvoid umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}\nEXPORT_SYMBOL_GPL(umd_cleanup_helper);\n\n \nint fork_usermode_driver(struct umd_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tconst char *argv[] = { info->driver_name, NULL };\n\tint err;\n\n\tif (WARN_ON_ONCE(info->tgid))\n\t\treturn -EBUSY;\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup(info->driver_name,\n\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,\n\t\t\t\t\t     umd_setup, umd_cleanup, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fork_usermode_driver);\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}