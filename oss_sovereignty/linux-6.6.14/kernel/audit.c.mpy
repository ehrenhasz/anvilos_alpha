{
  "module_name": "audit.c",
  "hash_id": "d27cfa2e96db8ff5b69124e7c7b8237fb8b45970a76d81e17c91dee58f3786b4",
  "original_prompt": "Ingested from linux-6.6.14/kernel/audit.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/file.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/gfp.h>\n#include <linux/pid.h>\n\n#include <linux/audit.h>\n\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/security.h>\n#include <linux/freezer.h>\n#include <linux/pid_namespace.h>\n#include <net/netns/generic.h>\n\n#include \"audit.h\"\n\n \n#define AUDIT_DISABLED\t\t-1\n#define AUDIT_UNINITIALIZED\t0\n#define AUDIT_INITIALIZED\t1\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\n\nu32\t\taudit_enabled = AUDIT_OFF;\nbool\t\taudit_ever_enabled = !!AUDIT_OFF;\n\nEXPORT_SYMBOL_GPL(audit_enabled);\n\n \nstatic u32\taudit_default = AUDIT_OFF;\n\n \nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\n \nstatic unsigned int audit_net_id;\n\n \nstruct audit_net {\n\tstruct sock *sk;\n};\n\n \nstruct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n};\nstatic struct auditd_connection __rcu *auditd_conn;\nstatic DEFINE_SPINLOCK(auditd_conn_lock);\n\n \nstatic u32\taudit_rate_limit;\n\n \nstatic u32\taudit_backlog_limit = 64;\n#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\n\n \nstatic kuid_t\t\taudit_sig_uid = INVALID_UID;\nstatic pid_t\t\taudit_sig_pid = -1;\nstatic u32\t\taudit_sig_sid;\n\n \nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\n \nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\n\n \nstruct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];\n\nstatic struct kmem_cache *audit_buffer_cache;\n\n \nstatic struct sk_buff_head audit_queue;\n \nstatic struct sk_buff_head audit_retry_queue;\n \nstatic struct sk_buff_head audit_hold_queue;\n\n \nstatic struct task_struct *kauditd_task;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nstatic char *audit_feature_names[2] = {\n\t\"only_unset_loginuid\",\n\t\"loginuid_immutable\",\n};\n\n \nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\n \n#define AUDIT_BUFSIZ 1024\n\n \nstruct audit_buffer {\n\tstruct sk_buff       *skb;\t \n\tstruct audit_context *ctx;\t \n\tgfp_t\t\t     gfp_mask;\n};\n\nstruct audit_reply {\n\t__u32 portid;\n\tstruct net *net;\n\tstruct sk_buff *skb;\n};\n\n \nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\n \nvoid audit_ctl_lock(void)\n{\n\tmutex_lock(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = current;\n}\n\n \nvoid audit_ctl_unlock(void)\n{\n\taudit_cmd_mutex.owner = NULL;\n\tmutex_unlock(&audit_cmd_mutex.lock);\n}\n\n \nstatic bool audit_ctl_owner_current(void)\n{\n\treturn (current == audit_cmd_mutex.owner);\n}\n\n \nstatic pid_t auditd_pid_vnr(void)\n{\n\tpid_t pid;\n\tconst struct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac || !ac->pid)\n\t\tpid = 0;\n\telse\n\t\tpid = pid_vnr(ac->pid);\n\trcu_read_unlock();\n\n\treturn pid;\n}\n\n \nstatic struct sock *audit_get_sk(const struct net *net)\n{\n\tstruct audit_net *aunet;\n\n\tif (!net)\n\t\treturn NULL;\n\n\taunet = net_generic(net, audit_net_id);\n\treturn aunet->sk;\n}\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}\n\nstatic inline int audit_rate_check(void)\n{\n\tstatic unsigned long\tlast_check = 0;\n\tstatic int\t\tmessages   = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tretval\t   = 0;\n\n\tif (!audit_rate_limit)\n\t\treturn 1;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (++messages < audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow = jiffies;\n\t\tif (time_after(now, last_check + HZ)) {\n\t\t\tlast_check = now;\n\t\t\tmessages   = 0;\n\t\t\tretval     = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&lock, flags);\n\n\treturn retval;\n}\n\n \nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (time_after(now, last_msg + HZ)) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}\n\nstatic int audit_log_config_change(char *function_name, u32 new, u32 old,\n\t\t\t\t   int allow_changes)\n{\n\tstruct audit_buffer *ab;\n\tint rc = 0;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn rc;\n\taudit_log_format(ab, \"op=set %s=%u old=%u \", function_name, new, old);\n\taudit_log_session_info(ab);\n\trc = audit_log_task_context(ab);\n\tif (rc)\n\t\tallow_changes = 0;  \n\taudit_log_format(ab, \" res=%d\", allow_changes);\n\taudit_log_end(ab);\n\treturn rc;\n}\n\nstatic int audit_do_config_change(char *function_name, u32 *to_change, u32 new)\n{\n\tint allow_changes, rc = 0;\n\tu32 old = *to_change;\n\n\t \n\tif (audit_enabled == AUDIT_LOCKED)\n\t\tallow_changes = 0;\n\telse\n\t\tallow_changes = 1;\n\n\tif (audit_enabled != AUDIT_OFF) {\n\t\trc = audit_log_config_change(function_name, new, old, allow_changes);\n\t\tif (rc)\n\t\t\tallow_changes = 0;\n\t}\n\n\t \n\tif (allow_changes == 1)\n\t\t*to_change = new;\n\t \n\telse if (rc == 0)\n\t\trc = -EPERM;\n\treturn rc;\n}\n\nstatic int audit_set_rate_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_rate_limit\", &audit_rate_limit, limit);\n}\n\nstatic int audit_set_backlog_limit(u32 limit)\n{\n\treturn audit_do_config_change(\"audit_backlog_limit\", &audit_backlog_limit, limit);\n}\n\nstatic int audit_set_backlog_wait_time(u32 timeout)\n{\n\treturn audit_do_config_change(\"audit_backlog_wait_time\",\n\t\t\t\t      &audit_backlog_wait_time, timeout);\n}\n\nstatic int audit_set_enabled(u32 state)\n{\n\tint rc;\n\tif (state > AUDIT_LOCKED)\n\t\treturn -EINVAL;\n\n\trc =  audit_do_config_change(\"audit_enabled\", &audit_enabled, state);\n\tif (!rc)\n\t\taudit_ever_enabled |= !!state;\n\n\treturn rc;\n}\n\nstatic int audit_set_failure(u32 state)\n{\n\tif (state != AUDIT_FAIL_SILENT\n\t    && state != AUDIT_FAIL_PRINTK\n\t    && state != AUDIT_FAIL_PANIC)\n\t\treturn -EINVAL;\n\n\treturn audit_do_config_change(\"audit_failure\", &audit_failure, state);\n}\n\n \nstatic void auditd_conn_free(struct rcu_head *rcu)\n{\n\tstruct auditd_connection *ac;\n\n\tac = container_of(rcu, struct auditd_connection, rcu);\n\tput_pid(ac->pid);\n\tput_net(ac->net);\n\tkfree(ac);\n}\n\n \nstatic int auditd_set(struct pid *pid, u32 portid, struct net *net)\n{\n\tunsigned long flags;\n\tstruct auditd_connection *ac_old, *ac_new;\n\n\tif (!pid || !net)\n\t\treturn -EINVAL;\n\n\tac_new = kzalloc(sizeof(*ac_new), GFP_KERNEL);\n\tif (!ac_new)\n\t\treturn -ENOMEM;\n\tac_new->pid = get_pid(pid);\n\tac_new->portid = portid;\n\tac_new->net = get_net(net);\n\n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\trcu_assign_pointer(auditd_conn, ac_new);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\treturn 0;\n}\n\n \nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}\n\n \nstatic void kauditd_rehold_skb(struct sk_buff *skb, __always_unused int error)\n{\n\t \n\tskb_queue_tail(&audit_hold_queue, skb);\n}\n\n \nstatic void kauditd_hold_skb(struct sk_buff *skb, int error)\n{\n\t \n\tkauditd_printk_skb(skb);\n\n\t \n\tif (!audit_default)\n\t\tgoto drop;\n\n\t \n\tif (error == -EAGAIN) {\n\t\tif (!audit_backlog_limit ||\n\t\t    skb_queue_len(&audit_retry_queue) < audit_backlog_limit) {\n\t\t\tskb_queue_tail(&audit_retry_queue, skb);\n\t\t\treturn;\n\t\t}\n\t\taudit_log_lost(\"kauditd retry queue overflow\");\n\t\tgoto drop;\n\t}\n\n\t \n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_hold_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_hold_queue, skb);\n\t\treturn;\n\t}\n\n\t \n\taudit_log_lost(\"kauditd hold queue overflow\");\ndrop:\n\tkfree_skb(skb);\n}\n\n \nstatic void kauditd_retry_skb(struct sk_buff *skb, __always_unused int error)\n{\n\tif (!audit_backlog_limit ||\n\t    skb_queue_len(&audit_retry_queue) < audit_backlog_limit) {\n\t\tskb_queue_tail(&audit_retry_queue, skb);\n\t\treturn;\n\t}\n\n\t \n\tkauditd_printk_skb(skb);\n\taudit_log_lost(\"kauditd retry queue overflow\");\n\tkfree_skb(skb);\n}\n\n \nstatic void auditd_reset(const struct auditd_connection *ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tstruct auditd_connection *ac_old;\n\n\t \n\tspin_lock_irqsave(&auditd_conn_lock, flags);\n\tac_old = rcu_dereference_protected(auditd_conn,\n\t\t\t\t\t   lockdep_is_held(&auditd_conn_lock));\n\tif (ac && ac != ac_old) {\n\t\t \n\t\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\t\treturn;\n\t}\n\trcu_assign_pointer(auditd_conn, NULL);\n\tspin_unlock_irqrestore(&auditd_conn_lock, flags);\n\n\tif (ac_old)\n\t\tcall_rcu(&ac_old->rcu, auditd_conn_free);\n\n\t \n\twhile ((skb = skb_dequeue(&audit_retry_queue)))\n\t\tkauditd_hold_skb(skb, -ECONNREFUSED);\n}\n\n \nstatic int auditd_send_unicast_skb(struct sk_buff *skb)\n{\n\tint rc;\n\tu32 portid;\n\tstruct net *net;\n\tstruct sock *sk;\n\tstruct auditd_connection *ac;\n\n\t \n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\tif (!ac) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\trc = -ECONNREFUSED;\n\t\tgoto err;\n\t}\n\tnet = get_net(ac->net);\n\tsk = audit_get_sk(net);\n\tportid = ac->portid;\n\trcu_read_unlock();\n\n\trc = netlink_unicast(sk, skb, portid, 0);\n\tput_net(net);\n\tif (rc < 0)\n\t\tgoto err;\n\n\treturn rc;\n\nerr:\n\tif (ac && rc == -ECONNREFUSED)\n\t\tauditd_reset(ac);\n\treturn rc;\n}\n\n \nstatic int kauditd_send_queue(struct sock *sk, u32 portid,\n\t\t\t      struct sk_buff_head *queue,\n\t\t\t      unsigned int retry_limit,\n\t\t\t      void (*skb_hook)(struct sk_buff *skb),\n\t\t\t      void (*err_hook)(struct sk_buff *skb, int error))\n{\n\tint rc = 0;\n\tstruct sk_buff *skb = NULL;\n\tstruct sk_buff *skb_tail;\n\tunsigned int failed = 0;\n\n\t \n\n\tskb_tail = skb_peek_tail(queue);\n\twhile ((skb != skb_tail) && (skb = skb_dequeue(queue))) {\n\t\t \n\t\tif (skb_hook)\n\t\t\t(*skb_hook)(skb);\n\n\t\t \n\t\tif (!sk) {\n\t\t\tif (err_hook)\n\t\t\t\t(*err_hook)(skb, -ECONNREFUSED);\n\t\t\tcontinue;\n\t\t}\n\nretry:\n\t\t \n\t\tskb_get(skb);\n\t\trc = netlink_unicast(sk, skb, portid, 0);\n\t\tif (rc < 0) {\n\t\t\t \n\t\t\tif (++failed >= retry_limit ||\n\t\t\t    rc == -ECONNREFUSED || rc == -EPERM) {\n\t\t\t\tsk = NULL;\n\t\t\t\tif (err_hook)\n\t\t\t\t\t(*err_hook)(skb, rc);\n\t\t\t\tif (rc == -EAGAIN)\n\t\t\t\t\trc = 0;\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tgoto retry;\n\t\t} else {\n\t\t\t \n\t\t\tconsume_skb(skb);\n\t\t\tfailed = 0;\n\t\t}\n\t}\n\n\treturn (rc >= 0 ? 0 : rc);\n}\n\n \nstatic void kauditd_send_multicast_skb(struct sk_buff *skb)\n{\n\tstruct sk_buff *copy;\n\tstruct sock *sock = audit_get_sk(&init_net);\n\tstruct nlmsghdr *nlh;\n\n\t \n\n\tif (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))\n\t\treturn;\n\n\t \n\tcopy = skb_copy(skb, GFP_KERNEL);\n\tif (!copy)\n\t\treturn;\n\tnlh = nlmsg_hdr(copy);\n\tnlh->nlmsg_len = skb->len;\n\n\tnlmsg_multicast(sock, copy, 0, AUDIT_NLGRP_READLOG, GFP_KERNEL);\n}\n\n \nstatic int kauditd_thread(void *dummy)\n{\n\tint rc;\n\tu32 portid = 0;\n\tstruct net *net = NULL;\n\tstruct sock *sk = NULL;\n\tstruct auditd_connection *ac;\n\n#define UNICAST_RETRIES 5\n\n\tset_freezable();\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\trcu_read_lock();\n\t\tac = rcu_dereference(auditd_conn);\n\t\tif (!ac) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto main_queue;\n\t\t}\n\t\tnet = get_net(ac->net);\n\t\tsk = audit_get_sk(net);\n\t\tportid = ac->portid;\n\t\trcu_read_unlock();\n\n\t\t \n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_hold_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_rehold_skb);\n\t\tif (rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\n\t\t \n\t\trc = kauditd_send_queue(sk, portid,\n\t\t\t\t\t&audit_retry_queue, UNICAST_RETRIES,\n\t\t\t\t\tNULL, kauditd_hold_skb);\n\t\tif (rc < 0) {\n\t\t\tsk = NULL;\n\t\t\tauditd_reset(ac);\n\t\t\tgoto main_queue;\n\t\t}\n\nmain_queue:\n\t\t \n\t\trc = kauditd_send_queue(sk, portid, &audit_queue, 1,\n\t\t\t\t\tkauditd_send_multicast_skb,\n\t\t\t\t\t(sk ?\n\t\t\t\t\t kauditd_retry_skb : kauditd_hold_skb));\n\t\tif (ac && rc < 0)\n\t\t\tauditd_reset(ac);\n\t\tsk = NULL;\n\n\t\t \n\t\tif (net) {\n\t\t\tput_net(net);\n\t\t\tnet = NULL;\n\t\t}\n\n\t\t \n\t\twake_up(&audit_backlog_wait);\n\n\t\t \n\t\twait_event_freezable(kauditd_wait,\n\t\t\t\t     (skb_queue_len(&audit_queue) ? 1 : 0));\n\t}\n\n\treturn 0;\n}\n\nint audit_send_list_thread(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = audit_get_sk(dest->net);\n\n\t \n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\twhile ((skb = __skb_dequeue(&dest->q)) != NULL)\n\t\tnetlink_unicast(sk, skb, dest->portid, 0);\n\n\tput_net(dest->net);\n\tkfree(dest);\n\n\treturn 0;\n}\n\nstruct sk_buff *audit_make_reply(int seq, int type, int done,\n\t\t\t\t int multi, const void *payload, int size)\n{\n\tstruct sk_buff\t*skb;\n\tstruct nlmsghdr\t*nlh;\n\tvoid\t\t*data;\n\tint\t\tflags = multi ? NLM_F_MULTI : 0;\n\tint\t\tt     = done  ? NLMSG_DONE  : type;\n\n\tskb = nlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tnlh\t= nlmsg_put(skb, 0, seq, t, size, flags);\n\tif (!nlh)\n\t\tgoto out_kfree_skb;\n\tdata = nlmsg_data(nlh);\n\tmemcpy(data, payload, size);\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic void audit_free_reply(struct audit_reply *reply)\n{\n\tif (!reply)\n\t\treturn;\n\n\tkfree_skb(reply->skb);\n\tif (reply->net)\n\t\tput_net(reply->net);\n\tkfree(reply);\n}\n\nstatic int audit_send_reply_thread(void *arg)\n{\n\tstruct audit_reply *reply = (struct audit_reply *)arg;\n\n\taudit_ctl_lock();\n\taudit_ctl_unlock();\n\n\t \n\tnetlink_unicast(audit_get_sk(reply->net), reply->skb, reply->portid, 0);\n\treply->skb = NULL;\n\taudit_free_reply(reply);\n\treturn 0;\n}\n\n \nstatic void audit_send_reply(struct sk_buff *request_skb, int seq, int type, int done,\n\t\t\t     int multi, const void *payload, int size)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_reply *reply;\n\n\treply = kzalloc(sizeof(*reply), GFP_KERNEL);\n\tif (!reply)\n\t\treturn;\n\n\treply->skb = audit_make_reply(seq, type, done, multi, payload, size);\n\tif (!reply->skb)\n\t\tgoto err;\n\treply->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\treply->portid = NETLINK_CB(request_skb).portid;\n\n\ttsk = kthread_run(audit_send_reply_thread, reply, \"audit_send_reply\");\n\tif (IS_ERR(tsk))\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\taudit_free_reply(reply);\n}\n\n \nstatic int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n{\n\tint err = 0;\n\n\t \n\t \n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -ECONNREFUSED;\n\n\tswitch (msg_type) {\n\tcase AUDIT_LIST:\n\tcase AUDIT_ADD:\n\tcase AUDIT_DEL:\n\t\treturn -EOPNOTSUPP;\n\tcase AUDIT_GET:\n\tcase AUDIT_SET:\n\tcase AUDIT_GET_FEATURE:\n\tcase AUDIT_SET_FEATURE:\n\tcase AUDIT_LIST_RULES:\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\tcase AUDIT_SIGNAL_INFO:\n\tcase AUDIT_TTY_GET:\n\tcase AUDIT_TTY_SET:\n\tcase AUDIT_TRIM:\n\tcase AUDIT_MAKE_EQUIV:\n\t\t \n\t\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\t\treturn -EPERM;\n\n\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n\t\t\terr = -EPERM;\n\t\tbreak;\n\tdefault:   \n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void audit_log_common_recv_msg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab, u16 msg_type)\n{\n\tuid_t uid = from_kuid(&init_user_ns, current_uid());\n\tpid_t pid = task_tgid_nr(current);\n\n\tif (!audit_enabled && msg_type != AUDIT_USER_AVC) {\n\t\t*ab = NULL;\n\t\treturn;\n\t}\n\n\t*ab = audit_log_start(context, GFP_KERNEL, msg_type);\n\tif (unlikely(!*ab))\n\t\treturn;\n\taudit_log_format(*ab, \"pid=%d uid=%u \", pid, uid);\n\taudit_log_session_info(*ab);\n\taudit_log_task_context(*ab);\n}\n\nstatic inline void audit_log_user_recv_msg(struct audit_buffer **ab,\n\t\t\t\t\t   u16 msg_type)\n{\n\taudit_log_common_recv_msg(NULL, ab, msg_type);\n}\n\nstatic int is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}\n\n\nstatic int audit_get_feature(struct sk_buff *skb)\n{\n\tu32 seq;\n\n\tseq = nlmsg_hdr(skb)->nlmsg_seq;\n\n\taudit_send_reply(skb, seq, AUDIT_GET_FEATURE, 0, 0, &af, sizeof(af));\n\n\treturn 0;\n}\n\nstatic void audit_log_feature_change(int which, u32 old_feature, u32 new_feature,\n\t\t\t\t     u32 old_lock, u32 new_lock, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (audit_enabled == AUDIT_OFF)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_FEATURE_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\",\n\t\t\t audit_feature_names[which], !!old_feature, !!new_feature,\n\t\t\t !!old_lock, !!new_lock, res);\n\taudit_log_end(ab);\n}\n\nstatic int audit_set_feature(struct audit_features *uaf)\n{\n\tint i;\n\n\tBUILD_BUG_ON(AUDIT_LAST_FEATURE + 1 > ARRAY_SIZE(audit_feature_names));\n\n\t \n\n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t \n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\t\told_lock = af.lock & feature;\n\n\t\t \n\t\tif (old_lock && (new_feature != old_feature)) {\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 0);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i <= AUDIT_LAST_FEATURE; i++) {\n\t\tu32 feature = AUDIT_FEATURE_TO_MASK(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t \n\t\tif (!(feature & uaf->mask))\n\t\t\tcontinue;\n\n\t\told_feature = af.features & feature;\n\t\tnew_feature = uaf->features & feature;\n\t\told_lock = af.lock & feature;\n\t\tnew_lock = (uaf->lock | af.lock) & feature;\n\n\t\tif (new_feature != old_feature)\n\t\t\taudit_log_feature_change(i, old_feature, new_feature,\n\t\t\t\t\t\t old_lock, new_lock, 1);\n\n\t\tif (new_feature)\n\t\t\taf.features |= feature;\n\t\telse\n\t\t\taf.features &= ~feature;\n\t\taf.lock |= new_lock;\n\t}\n\n\treturn 0;\n}\n\nstatic int audit_replace(struct pid *pid)\n{\n\tpid_t pvnr;\n\tstruct sk_buff *skb;\n\n\tpvnr = pid_vnr(pid);\n\tskb = audit_make_reply(0, AUDIT_REPLACE, 0, 0, &pvnr, sizeof(pvnr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treturn auditd_send_unicast_skb(skb);\n}\n\nstatic int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tu32\t\t\tseq;\n\tvoid\t\t\t*data;\n\tint\t\t\tdata_len;\n\tint\t\t\terr;\n\tstruct audit_buffer\t*ab;\n\tu16\t\t\tmsg_type = nlh->nlmsg_type;\n\tstruct audit_sig_info   *sig_data;\n\tchar\t\t\t*ctx = NULL;\n\tu32\t\t\tlen;\n\n\terr = audit_netlink_ok(skb, msg_type);\n\tif (err)\n\t\treturn err;\n\n\tseq  = nlh->nlmsg_seq;\n\tdata = nlmsg_data(nlh);\n\tdata_len = nlmsg_len(nlh);\n\n\tswitch (msg_type) {\n\tcase AUDIT_GET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\ts.enabled\t\t   = audit_enabled;\n\t\ts.failure\t\t   = audit_failure;\n\t\t \n\t\ts.pid\t\t\t   = auditd_pid_vnr();\n\t\ts.rate_limit\t\t   = audit_rate_limit;\n\t\ts.backlog_limit\t\t   = audit_backlog_limit;\n\t\ts.lost\t\t\t   = atomic_read(&audit_lost);\n\t\ts.backlog\t\t   = skb_queue_len(&audit_queue);\n\t\ts.feature_bitmap\t   = AUDIT_FEATURE_BITMAP_ALL;\n\t\ts.backlog_wait_time\t   = audit_backlog_wait_time;\n\t\ts.backlog_wait_time_actual = atomic_read(&audit_backlog_wait_time_actual);\n\t\taudit_send_reply(skb, seq, AUDIT_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_SET: {\n\t\tstruct audit_status\ts;\n\t\tmemset(&s, 0, sizeof(s));\n\t\t \n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\tif (s.mask & AUDIT_STATUS_ENABLED) {\n\t\t\terr = audit_set_enabled(s.enabled);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_FAILURE) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_PID) {\n\t\t\t \n\t\t\tpid_t new_pid = s.pid;\n\t\t\tpid_t auditd_pid;\n\t\t\tstruct pid *req_pid = task_tgid(current);\n\n\t\t\t \n\t\t\tif (new_pid && (new_pid != pid_vnr(req_pid)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\taudit_replace(req_pid);\n\n\t\t\tauditd_pid = auditd_pid_vnr();\n\t\t\tif (auditd_pid) {\n\t\t\t\t \n\t\t\t\tif (new_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (pid_vnr(req_pid) != auditd_pid) {\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\tnew_pid, auditd_pid, 0);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (new_pid) {\n\t\t\t\t \n\t\t\t\terr = auditd_set(req_pid,\n\t\t\t\t\t\t NETLINK_CB(skb).portid,\n\t\t\t\t\t\t sock_net(NETLINK_CB(skb).sk));\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid,\n\t\t\t\t\t\t\t\terr ? 0 : 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t \n\t\t\t\twake_up_interruptible(&kauditd_wait);\n\t\t\t} else {\n\t\t\t\tif (audit_enabled != AUDIT_OFF)\n\t\t\t\t\taudit_log_config_change(\"audit_pid\",\n\t\t\t\t\t\t\t\tnew_pid,\n\t\t\t\t\t\t\t\tauditd_pid, 1);\n\n\t\t\t\t \n\t\t\t\tauditd_reset(NULL);\n\t\t\t}\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_RATE_LIMIT) {\n\t\t\terr = audit_set_rate_limit(s.rate_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_LIMIT) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & AUDIT_STATUS_BACKLOG_WAIT_TIME) {\n\t\t\tif (sizeof(s) > (size_t)nlh->nlmsg_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (s.backlog_wait_time > 10*AUDIT_BACKLOG_WAIT_TIME)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = audit_set_backlog_wait_time(s.backlog_wait_time);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_LOST) {\n\t\t\tu32 lost = atomic_xchg(&audit_lost, 0);\n\n\t\t\taudit_log_config_change(\"lost\", 0, lost, 1);\n\t\t\treturn lost;\n\t\t}\n\t\tif (s.mask == AUDIT_STATUS_BACKLOG_WAIT_TIME_ACTUAL) {\n\t\t\tu32 actual = atomic_xchg(&audit_backlog_wait_time_actual, 0);\n\n\t\t\taudit_log_config_change(\"backlog_wait_time_actual\", 0, actual, 1);\n\t\t\treturn actual;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AUDIT_GET_FEATURE:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_SET_FEATURE:\n\t\tif (data_len < sizeof(struct audit_features))\n\t\t\treturn -EINVAL;\n\t\terr = audit_set_feature(data);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase AUDIT_USER:\n\tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n\tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n\t\tif (!audit_enabled && msg_type != AUDIT_USER_AVC)\n\t\t\treturn 0;\n\t\t \n\t\tif (data_len < 2)\n\t\t\treturn -EINVAL;\n\n\t\terr = audit_filter(msg_type, AUDIT_FILTER_USER);\n\t\tif (err == 1) {  \n\t\t\tchar *str = data;\n\n\t\t\terr = 0;\n\t\t\tif (msg_type == AUDIT_USER_TTY) {\n\t\t\t\terr = tty_audit_push();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\taudit_log_user_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != AUDIT_USER_TTY) {\n\t\t\t\t \n\t\t\t\tstr[data_len - 1] = '\\0';\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t AUDIT_MESSAGE_TEXT_MAX,\n\t\t\t\t\t\t str);\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tif (str[data_len - 1] == '\\0')\n\t\t\t\t\tdata_len--;\n\t\t\t\taudit_log_n_untrustedstring(ab, str, data_len);\n\t\t\t}\n\t\t\taudit_log_end(ab);\n\t\t}\n\t\tbreak;\n\tcase AUDIT_ADD_RULE:\n\tcase AUDIT_DEL_RULE:\n\t\tif (data_len < sizeof(struct audit_rule_data))\n\t\t\treturn -EINVAL;\n\t\tif (audit_enabled == AUDIT_LOCKED) {\n\t\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\t\taudit_log_format(ab, \" op=%s audit_enabled=%d res=0\",\n\t\t\t\t\t msg_type == AUDIT_ADD_RULE ?\n\t\t\t\t\t\t\"add_rule\" : \"remove_rule\",\n\t\t\t\t\t audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -EPERM;\n\t\t}\n\t\terr = audit_rule_change(msg_type, seq, data, data_len);\n\t\tbreak;\n\tcase AUDIT_LIST_RULES:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase AUDIT_TRIM:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_MAKE_EQUIV: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = data_len;\n\t\tchar *old, *new;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (IS_ERR(old)) {\n\t\t\terr = PTR_ERR(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (IS_ERR(new)) {\n\t\t\terr = PTR_ERR(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase AUDIT_SIGNAL_INFO:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(struct_size(sig_data, ctx, len), GFP_KERNEL);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsig_data->uid = from_kuid(&init_user_ns, audit_sig_uid);\n\t\tsig_data->pid = audit_sig_pid;\n\t\tif (audit_sig_sid) {\n\t\t\tmemcpy(sig_data->ctx, ctx, len);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t\taudit_send_reply(skb, seq, AUDIT_SIGNAL_INFO, 0, 0,\n\t\t\t\t sig_data, struct_size(sig_data, ctx, len));\n\t\tkfree(sig_data);\n\t\tbreak;\n\tcase AUDIT_TTY_GET: {\n\t\tstruct audit_tty_status s;\n\t\tunsigned int t;\n\n\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\ts.enabled = t & AUDIT_TTY_ENABLE;\n\t\ts.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_send_reply(skb, seq, AUDIT_TTY_GET, 0, 0, &s, sizeof(s));\n\t\tbreak;\n\t}\n\tcase AUDIT_TTY_SET: {\n\t\tstruct audit_tty_status s, old;\n\t\tstruct audit_buffer\t*ab;\n\t\tunsigned int t;\n\n\t\tmemset(&s, 0, sizeof(s));\n\t\t \n\t\tmemcpy(&s, data, min_t(size_t, sizeof(s), data_len));\n\t\t \n\t\tif ((s.enabled != 0 && s.enabled != 1) ||\n\t\t    (s.log_passwd != 0 && s.log_passwd != 1))\n\t\t\terr = -EINVAL;\n\n\t\tif (err)\n\t\t\tt = READ_ONCE(current->signal->audit_tty);\n\t\telse {\n\t\t\tt = s.enabled | (-s.log_passwd & AUDIT_TTY_LOG_PASSWD);\n\t\t\tt = xchg(&current->signal->audit_tty, t);\n\t\t}\n\t\told.enabled = t & AUDIT_TTY_ENABLE;\n\t\told.log_passwd = !!(t & AUDIT_TTY_LOG_PASSWD);\n\n\t\taudit_log_common_recv_msg(audit_context(), &ab,\n\t\t\t\t\t  AUDIT_CONFIG_CHANGE);\n\t\taudit_log_format(ab, \" op=tty_set old-enabled=%d new-enabled=%d\"\n\t\t\t\t \" old-log_passwd=%d new-log_passwd=%d res=%d\",\n\t\t\t\t old.enabled, s.enabled, old.log_passwd,\n\t\t\t\t s.log_passwd, !err);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err < 0 ? err : 0;\n}\n\n \nstatic void audit_receive(struct sk_buff  *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t \n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->len;\n\n\taudit_ctl_lock();\n\twhile (nlmsg_ok(nlh, len)) {\n\t\terr = audit_receive_msg(skb, nlh);\n\t\t \n\t\tif (err || (nlh->nlmsg_flags & NLM_F_ACK))\n\t\t\tnetlink_ack(skb, nlh, err, NULL);\n\n\t\tnlh = nlmsg_next(nlh, &len);\n\t}\n\taudit_ctl_unlock();\n\n\t \n\tif (audit_backlog_limit &&\n\t    (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t \n\t\twake_up_interruptible(&kauditd_wait);\n\n\t\tadd_wait_queue_exclusive(&audit_backlog_wait, &wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(audit_backlog_wait_time);\n\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t}\n}\n\n \nstatic void audit_log_multicast(int group, const char *op, int err)\n{\n\tconst struct cred *cred;\n\tstruct tty_struct *tty;\n\tchar comm[sizeof(current->comm)];\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_EVENT_LISTENER);\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab, \"pid=%u uid=%u auid=%u tty=%s ses=%u\",\n\t\t\t task_pid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_task_context(ab);  \n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);  \n\taudit_log_format(ab, \" nl-mcgrp=%d op=%s res=%d\", group, op, !err);\n\taudit_log_end(ab);\n}\n\n \nstatic int audit_multicast_bind(struct net *net, int group)\n{\n\tint err = 0;\n\n\tif (!capable(CAP_AUDIT_READ))\n\t\terr = -EPERM;\n\taudit_log_multicast(group, \"connect\", err);\n\treturn err;\n}\n\nstatic void audit_multicast_unbind(struct net *net, int group)\n{\n\taudit_log_multicast(group, \"disconnect\", 0);\n}\n\nstatic int __net_init audit_net_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= audit_receive,\n\t\t.bind\t= audit_multicast_bind,\n\t\t.unbind\t= audit_multicast_unbind,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV,\n\t\t.groups\t= AUDIT_NLGRP_MAX,\n\t};\n\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\taunet->sk = netlink_kernel_create(net, NETLINK_AUDIT, &cfg);\n\tif (aunet->sk == NULL) {\n\t\taudit_panic(\"cannot initialize netlink socket in namespace\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\taunet->sk->sk_sndtimeo = HZ / 10;\n\n\treturn 0;\n}\n\nstatic void __net_exit audit_net_exit(struct net *net)\n{\n\tstruct audit_net *aunet = net_generic(net, audit_net_id);\n\n\t \n\n\tnetlink_kernel_release(aunet->sk);\n}\n\nstatic struct pernet_operations audit_net_ops __net_initdata = {\n\t.init = audit_net_init,\n\t.exit = audit_net_exit,\n\t.id = &audit_net_id,\n\t.size = sizeof(struct audit_net),\n};\n\n \nstatic int __init audit_init(void)\n{\n\tint i;\n\n\tif (audit_initialized == AUDIT_DISABLED)\n\t\treturn 0;\n\n\taudit_buffer_cache = kmem_cache_create(\"audit_buffer\",\n\t\t\t\t\t       sizeof(struct audit_buffer),\n\t\t\t\t\t       0, SLAB_PANIC, NULL);\n\n\tskb_queue_head_init(&audit_queue);\n\tskb_queue_head_init(&audit_retry_queue);\n\tskb_queue_head_init(&audit_hold_queue);\n\n\tfor (i = 0; i < AUDIT_INODE_BUCKETS; i++)\n\t\tINIT_LIST_HEAD(&audit_inode_hash[i]);\n\n\tmutex_init(&audit_cmd_mutex.lock);\n\taudit_cmd_mutex.owner = NULL;\n\n\tpr_info(\"initializing netlink subsys (%s)\\n\",\n\t\taudit_default ? \"enabled\" : \"disabled\");\n\tregister_pernet_subsys(&audit_net_ops);\n\n\taudit_initialized = AUDIT_INITIALIZED;\n\n\tkauditd_task = kthread_run(kauditd_thread, NULL, \"kauditd\");\n\tif (IS_ERR(kauditd_task)) {\n\t\tint err = PTR_ERR(kauditd_task);\n\t\tpanic(\"audit: failed to start the kauditd thread (%d)\\n\", err);\n\t}\n\n\taudit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,\n\t\t\"state=initialized audit_enabled=%u res=1\",\n\t\t audit_enabled);\n\n\treturn 0;\n}\npostcore_initcall(audit_init);\n\n \nstatic int __init audit_enable(char *str)\n{\n\tif (!strcasecmp(str, \"off\") || !strcmp(str, \"0\"))\n\t\taudit_default = AUDIT_OFF;\n\telse if (!strcasecmp(str, \"on\") || !strcmp(str, \"1\"))\n\t\taudit_default = AUDIT_ON;\n\telse {\n\t\tpr_err(\"audit: invalid 'audit' parameter value (%s)\\n\", str);\n\t\taudit_default = AUDIT_ON;\n\t}\n\n\tif (audit_default == AUDIT_OFF)\n\t\taudit_initialized = AUDIT_DISABLED;\n\tif (audit_set_enabled(audit_default))\n\t\tpr_err(\"audit: error setting audit state (%d)\\n\",\n\t\t       audit_default);\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}\n__setup(\"audit=\", audit_enable);\n\n \nstatic int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}\n__setup(\"audit_backlog_limit=\", audit_backlog_limit_set);\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tif (!ab)\n\t\treturn;\n\n\tkfree_skb(ab->skb);\n\tkmem_cache_free(audit_buffer_cache, ab);\n}\n\nstatic struct audit_buffer *audit_buffer_alloc(struct audit_context *ctx,\n\t\t\t\t\t       gfp_t gfp_mask, int type)\n{\n\tstruct audit_buffer *ab;\n\n\tab = kmem_cache_alloc(audit_buffer_cache, gfp_mask);\n\tif (!ab)\n\t\treturn NULL;\n\n\tab->skb = nlmsg_new(AUDIT_BUFSIZ, gfp_mask);\n\tif (!ab->skb)\n\t\tgoto err;\n\tif (!nlmsg_put(ab->skb, 0, 0, type, 0, 0))\n\t\tgoto err;\n\n\tab->ctx = ctx;\n\tab->gfp_mask = gfp_mask;\n\n\treturn ab;\n\nerr:\n\taudit_buffer_free(ab);\n\treturn NULL;\n}\n\n \nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&serial);\n}\n\nstatic inline void audit_get_stamp(struct audit_context *ctx,\n\t\t\t\t   struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx || !auditsc_get_stamp(ctx, t, serial)) {\n\t\tktime_get_coarse_real_ts64(t);\n\t\t*serial = audit_serial();\n\t}\n}\n\n \nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t \n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t \n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t \n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t \n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}\n\n \nstatic inline int audit_expand(struct audit_buffer *ab, int extra)\n{\n\tstruct sk_buff *skb = ab->skb;\n\tint oldtail = skb_tailroom(skb);\n\tint ret = pskb_expand_head(skb, 0, extra, ab->gfp_mask);\n\tint newtail = skb_tailroom(skb);\n\n\tif (ret < 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->truesize += newtail - oldtail;\n\treturn newtail;\n}\n\n \nstatic void audit_log_vformat(struct audit_buffer *ab, const char *fmt,\n\t\t\t      va_list args)\n{\n\tint len, avail;\n\tstruct sk_buff *skb;\n\tva_list args2;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tif (avail == 0) {\n\t\tavail = audit_expand(ab, AUDIT_BUFSIZ);\n\t\tif (!avail)\n\t\t\tgoto out;\n\t}\n\tva_copy(args2, args);\n\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args);\n\tif (len >= avail) {\n\t\t \n\t\tavail = audit_expand(ab,\n\t\t\tmax_t(unsigned, AUDIT_BUFSIZ, 1+len-avail));\n\t\tif (!avail)\n\t\t\tgoto out_va_end;\n\t\tlen = vsnprintf(skb_tail_pointer(skb), avail, fmt, args2);\n\t}\n\tif (len > 0)\n\t\tskb_put(skb, len);\nout_va_end:\n\tva_end(args2);\nout:\n\treturn;\n}\n\n \nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}\n\n \nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t \n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1);  \n}\n\n \nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t \n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t \n}\n\n \nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}\n\n \nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}\n\n \nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t \n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_format(ab, \"\\\"<no_memory>\\\"\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) {  \n\t\t \n\t\taudit_log_format(ab, \"\\\"<too_long>\\\"\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_current_getsecid_subj(&sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}\nEXPORT_SYMBOL(audit_log_task_context);\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}\n\nstruct tty_struct *audit_get_tty(void)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tif (current->signal)\n\t\ttty = tty_kref_get(current->signal->tty);\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n\treturn tty;\n}\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}\n\nvoid audit_log_task_info(struct audit_buffer *ab)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(current->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\tcred = current_cred();\n\ttty = audit_get_tty();\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(current),\n\t\t\t task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(current));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n\taudit_log_task_context(ab);\n}\nEXPORT_SYMBOL(audit_log_task_info);\n\n \nvoid audit_log_path_denied(int type, const char *operation)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled || audit_dummy_context())\n\t\treturn;\n\n\t \n\tab = audit_log_start(audit_context(), GFP_KERNEL, type);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"op=%s\", operation);\n\taudit_log_task_info(ab);\n\taudit_log_format(ab, \" res=0\");\n\taudit_log_end(ab);\n}\n\n \nstatic atomic_t session_id = ATOMIC_INIT(0);\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t \n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t \n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t \n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t \n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID)\n\t\t\t\t && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid,\n\t\t\t\t   unsigned int sessionid, int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid);\n\ttty = audit_get_tty();\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}\n\n \nint audit_set_loginuid(kuid_t loginuid)\n{\n\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (uid_valid(loginuid)) {\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))\n\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t}\n\n\tcurrent->sessionid = sessionid;\n\tcurrent->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}\n\n \nint audit_signal_info(int sig, struct task_struct *t)\n{\n\tkuid_t uid = current_uid(), auid;\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_current_getsecid_subj(&audit_sig_sid);\n\t}\n\n\treturn audit_signal_info_syscall(t);\n}\n\n \nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t \n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t \n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}\n\n \nvoid audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,\n\t       const char *fmt, ...)\n{\n\tstruct audit_buffer *ab;\n\tva_list args;\n\n\tab = audit_log_start(ctx, gfp_mask, type);\n\tif (ab) {\n\t\tva_start(args, fmt);\n\t\taudit_log_vformat(ab, fmt, args);\n\t\tva_end(args);\n\t\taudit_log_end(ab);\n\t}\n}\n\nEXPORT_SYMBOL(audit_log_start);\nEXPORT_SYMBOL(audit_log_end);\nEXPORT_SYMBOL(audit_log_format);\nEXPORT_SYMBOL(audit_log);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}