{
  "module_name": "scs.c",
  "hash_id": "32f7c236ff77023aa7243297bb41fbf88537768be83c4ff3ae8e50bbb831b57e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/scs.c",
  "human_readable_source": "\n \n\n#include <linux/cpuhotplug.h>\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/scs.h>\n#include <linux/vmalloc.h>\n#include <linux/vmstat.h>\n\n#ifdef CONFIG_DYNAMIC_SCS\nDEFINE_STATIC_KEY_FALSE(dynamic_scs_enabled);\n#endif\n\nstatic void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}\n\n \n#define NR_CACHED_SCS 2\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nstatic void *__scs_alloc(int node)\n{\n\tint i;\n\tvoid *s;\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\ts = this_cpu_xchg(scs_cache[i], NULL);\n\t\tif (s) {\n\t\t\ts = kasan_unpoison_vmalloc(s, SCS_SIZE,\n\t\t\t\t\t\t   KASAN_VMALLOC_PROT_NORMAL);\n\t\t\tmemset(s, 0, SCS_SIZE);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ts = __vmalloc_node_range(SCS_SIZE, 1, VMALLOC_START, VMALLOC_END,\n\t\t\t\t    GFP_SCS, PAGE_KERNEL, 0, node,\n\t\t\t\t    __builtin_return_address(0));\n\nout:\n\treturn kasan_reset_tag(s);\n}\n\nvoid *scs_alloc(int node)\n{\n\tvoid *s;\n\n\ts = __scs_alloc(node);\n\tif (!s)\n\t\treturn NULL;\n\n\t*__scs_magic(s) = SCS_END_MAGIC;\n\n\t \n\tkasan_poison_vmalloc(s, SCS_SIZE);\n\t__scs_account(s, 1);\n\treturn s;\n}\n\nvoid scs_free(void *s)\n{\n\tint i;\n\n\t__scs_account(s, -1);\n\n\t \n\n\tfor (i = 0; i < NR_CACHED_SCS; i++)\n\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)\n\t\t\treturn;\n\n\tkasan_unpoison_vmalloc(s, SCS_SIZE, KASAN_VMALLOC_PROT_NORMAL);\n\tvfree_atomic(s);\n}\n\nstatic int scs_cleanup(unsigned int cpu)\n{\n\tint i;\n\tvoid **cache = per_cpu_ptr(scs_cache, cpu);\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\tvfree(cache[i]);\n\t\tcache[i] = NULL;\n\t}\n\n\treturn 0;\n}\n\nvoid __init scs_init(void)\n{\n\tif (!scs_is_enabled())\n\t\treturn;\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"scs:scs_cache\", NULL,\n\t\t\t  scs_cleanup);\n}\n\nint scs_prepare(struct task_struct *tsk, int node)\n{\n\tvoid *s;\n\n\tif (!scs_is_enabled())\n\t\treturn 0;\n\n\ts = scs_alloc(node);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttask_scs(tsk) = task_scs_sp(tsk) = s;\n\treturn 0;\n}\n\nstatic void scs_check_usage(struct task_struct *tsk)\n{\n\tstatic unsigned long highest;\n\n\tunsigned long *p, prev, curr = highest, used = 0;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))\n\t\treturn;\n\n\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {\n\t\tif (!READ_ONCE_NOCHECK(*p))\n\t\t\tbreak;\n\t\tused += sizeof(*p);\n\t}\n\n\twhile (used > curr) {\n\t\tprev = cmpxchg_relaxed(&highest, curr, used);\n\n\t\tif (prev == curr) {\n\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk), used);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr = prev;\n\t}\n}\n\nvoid scs_release(struct task_struct *tsk)\n{\n\tvoid *s = task_scs(tsk);\n\n\tif (!scs_is_enabled() || !s)\n\t\treturn;\n\n\tWARN(task_scs_end_corrupted(tsk),\n\t     \"corrupted shadow stack detected when freeing task\\n\");\n\tscs_check_usage(tsk);\n\tscs_free(s);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}