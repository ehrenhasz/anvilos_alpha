{
  "module_name": "cfi.c",
  "hash_id": "e45c178c0363defb457d853cbfbb73acdca629516f8ea72c9038d1d917c5537c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cfi.c",
  "human_readable_source": "\n \n\n#include <linux/cfi.h>\n\nenum bug_trap_type report_cfi_failure(struct pt_regs *regs, unsigned long addr,\n\t\t\t\t      unsigned long *target, u32 type)\n{\n\tif (target)\n\t\tpr_err(\"CFI failure at %pS (target: %pS; expected type: 0x%08x)\\n\",\n\t\t       (void *)addr, (void *)*target, type);\n\telse\n\t\tpr_err(\"CFI failure at %pS (no target information)\\n\",\n\t\t       (void *)addr);\n\n\tif (IS_ENABLED(CONFIG_CFI_PERMISSIVE)) {\n\t\t__warn(NULL, 0, (void *)addr, 0, regs, NULL);\n\t\treturn BUG_TRAP_TYPE_WARN;\n\t}\n\n\treturn BUG_TRAP_TYPE_BUG;\n}\n\n#ifdef CONFIG_ARCH_USES_CFI_TRAPS\nstatic inline unsigned long trap_address(s32 *p)\n{\n\treturn (unsigned long)((long)p + (long)*p);\n}\n\nstatic bool is_trap(unsigned long addr, s32 *start, s32 *end)\n{\n\ts32 *p;\n\n\tfor (p = start; p < end; ++p) {\n\t\tif (trap_address(p) == addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_MODULES\n \nvoid module_cfi_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,\n\t\t\t struct module *mod)\n{\n\tchar *secstrings;\n\tunsigned int i;\n\n\tmod->kcfi_traps = NULL;\n\tmod->kcfi_traps_end = NULL;\n\n\tsecstrings = (char *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;\n\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \"__kcfi_traps\"))\n\t\t\tcontinue;\n\n\t\tmod->kcfi_traps = (s32 *)sechdrs[i].sh_addr;\n\t\tmod->kcfi_traps_end = (s32 *)(sechdrs[i].sh_addr + sechdrs[i].sh_size);\n\t\tbreak;\n\t}\n}\n\nstatic bool is_module_cfi_trap(unsigned long addr)\n{\n\tstruct module *mod;\n\tbool found = false;\n\n\trcu_read_lock_sched_notrace();\n\n\tmod = __module_address(addr);\n\tif (mod)\n\t\tfound = is_trap(addr, mod->kcfi_traps, mod->kcfi_traps_end);\n\n\trcu_read_unlock_sched_notrace();\n\n\treturn found;\n}\n#else  \nstatic inline bool is_module_cfi_trap(unsigned long addr)\n{\n\treturn false;\n}\n#endif  \n\nextern s32 __start___kcfi_traps[];\nextern s32 __stop___kcfi_traps[];\n\nbool is_cfi_trap(unsigned long addr)\n{\n\tif (is_trap(addr, __start___kcfi_traps, __stop___kcfi_traps))\n\t\treturn true;\n\n\treturn is_module_cfi_trap(addr);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}