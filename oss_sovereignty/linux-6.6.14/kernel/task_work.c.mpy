{
  "module_name": "task_work.c",
  "hash_id": "53b730ea5bd165e9b01c2225642cb5e1eea82689260be90d83e01ecad40bf6f6",
  "original_prompt": "Ingested from linux-6.6.14/kernel/task_work.c",
  "human_readable_source": "\n#include <linux/spinlock.h>\n#include <linux/task_work.h>\n#include <linux/resume_user_mode.h>\n\nstatic struct callback_head work_exited;  \n\n \nint task_work_add(struct task_struct *task, struct callback_head *work,\n\t\t  enum task_work_notify_mode notify)\n{\n\tstruct callback_head *head;\n\n\t \n\tkasan_record_aux_stack(work);\n\n\thead = READ_ONCE(task->task_works);\n\tdo {\n\t\tif (unlikely(head == &work_exited))\n\t\t\treturn -ESRCH;\n\t\twork->next = head;\n\t} while (!try_cmpxchg(&task->task_works, &head, work));\n\n\tswitch (notify) {\n\tcase TWA_NONE:\n\t\tbreak;\n\tcase TWA_RESUME:\n\t\tset_notify_resume(task);\n\t\tbreak;\n\tcase TWA_SIGNAL:\n\t\tset_notify_signal(task);\n\t\tbreak;\n\tcase TWA_SIGNAL_NO_IPI:\n\t\t__set_notify_signal(task);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstruct callback_head *\ntask_work_cancel_match(struct task_struct *task,\n\t\t       bool (*match)(struct callback_head *, void *data),\n\t\t       void *data)\n{\n\tstruct callback_head **pprev = &task->task_works;\n\tstruct callback_head *work;\n\tunsigned long flags;\n\n\tif (likely(!task_work_pending(task)))\n\t\treturn NULL;\n\t \n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\twork = READ_ONCE(*pprev);\n\twhile (work) {\n\t\tif (!match(work, data)) {\n\t\t\tpprev = &work->next;\n\t\t\twork = READ_ONCE(*pprev);\n\t\t} else if (try_cmpxchg(pprev, &work, work->next))\n\t\t\tbreak;\n\t}\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\treturn work;\n}\n\nstatic bool task_work_func_match(struct callback_head *cb, void *data)\n{\n\treturn cb->func == data;\n}\n\n \nstruct callback_head *\ntask_work_cancel(struct task_struct *task, task_work_func_t func)\n{\n\treturn task_work_cancel_match(task, task_work_func_match, func);\n}\n\n \nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t \n\t\twork = READ_ONCE(task->task_works);\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!try_cmpxchg(&task->task_works, &work, head));\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t \n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}