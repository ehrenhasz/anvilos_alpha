{
  "module_name": "compat.c",
  "hash_id": "b5ae83364eb318da023155dc269a9c88b91807ef13efd020aaa554f1724de625",
  "original_prompt": "Ingested from linux-6.6.14/kernel/compat.c",
  "human_readable_source": "\n \n\n#include <linux/linkage.h>\n#include <linux/compat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\t \n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n#include <linux/posix-timers.h>\n#include <linux/times.h>\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\n#include <linux/uaccess.h>\n\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\n\n \nstatic inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}\n\nCOMPAT_SYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nint put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}\n\nCOMPAT_SYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}\n\nCOMPAT_SYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\n \nint get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t \n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_read_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_read_access_end();\n\treturn 0;\n\nEfault:\n\tuser_read_access_end();\n\treturn -EFAULT;\n}\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t \n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!user_write_access_begin(umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_write_access_end();\n\treturn 0;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}\n\nint\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\t\tfallthrough;\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\t\tfallthrough;\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\t\tfallthrough;\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_compat_sigset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}