{
  "module_name": "map_benchmark.c",
  "hash_id": "f901a6c9771fa13a1455021f1df090f8207bf32549e93feaf541ca47b2e8ce25",
  "original_prompt": "Ingested from linux-6.6.14/kernel/dma/map_benchmark.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/map_benchmark.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/timekeeping.h>\n\nstruct map_benchmark_data {\n\tstruct map_benchmark bparam;\n\tstruct device *dev;\n\tstruct dentry  *debugfs;\n\tenum dma_data_direction dir;\n\tatomic64_t sum_map_100ns;\n\tatomic64_t sum_unmap_100ns;\n\tatomic64_t sum_sq_map;\n\tatomic64_t sum_sq_unmap;\n\tatomic64_t loops;\n};\n\nstatic int map_benchmark_thread(void *data)\n{\n\tvoid *buf;\n\tdma_addr_t dma_addr;\n\tstruct map_benchmark_data *map = data;\n\tint npages = map->bparam.granule;\n\tu64 size = npages * PAGE_SIZE;\n\tint ret = 0;\n\n\tbuf = alloc_pages_exact(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (!kthread_should_stop())  {\n\t\tu64 map_100ns, unmap_100ns, map_sq, unmap_sq;\n\t\tktime_t map_stime, map_etime, unmap_stime, unmap_etime;\n\t\tktime_t map_delta, unmap_delta;\n\n\t\t \n\t\tif (map->dir != DMA_FROM_DEVICE)\n\t\t\tmemset(buf, 0x66, size);\n\n\t\tmap_stime = ktime_get();\n\t\tdma_addr = dma_map_single(map->dev, buf, size, map->dir);\n\t\tif (unlikely(dma_mapping_error(map->dev, dma_addr))) {\n\t\t\tpr_err(\"dma_map_single failed on %s\\n\",\n\t\t\t\tdev_name(map->dev));\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmap_etime = ktime_get();\n\t\tmap_delta = ktime_sub(map_etime, map_stime);\n\n\t\t \n\t\tndelay(map->bparam.dma_trans_ns);\n\n\t\tunmap_stime = ktime_get();\n\t\tdma_unmap_single(map->dev, dma_addr, size, map->dir);\n\t\tunmap_etime = ktime_get();\n\t\tunmap_delta = ktime_sub(unmap_etime, unmap_stime);\n\n\t\t \n\n\t\tmap_100ns = div64_ul(map_delta,  100);\n\t\tunmap_100ns = div64_ul(unmap_delta, 100);\n\t\tmap_sq = map_100ns * map_100ns;\n\t\tunmap_sq = unmap_100ns * unmap_100ns;\n\n\t\tatomic64_add(map_100ns, &map->sum_map_100ns);\n\t\tatomic64_add(unmap_100ns, &map->sum_unmap_100ns);\n\t\tatomic64_add(map_sq, &map->sum_sq_map);\n\t\tatomic64_add(unmap_sq, &map->sum_sq_unmap);\n\t\tatomic64_inc(&map->loops);\n\t}\n\nout:\n\tfree_pages_exact(buf, size);\n\treturn ret;\n}\n\nstatic int do_map_benchmark(struct map_benchmark_data *map)\n{\n\tstruct task_struct **tsk;\n\tint threads = map->bparam.threads;\n\tint node = map->bparam.node;\n\tconst cpumask_t *cpu_mask = cpumask_of_node(node);\n\tu64 loops;\n\tint ret = 0;\n\tint i;\n\n\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);\n\tif (!tsk)\n\t\treturn -ENOMEM;\n\n\tget_device(map->dev);\n\n\tfor (i = 0; i < threads; i++) {\n\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,\n\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);\n\t\tif (IS_ERR(tsk[i])) {\n\t\t\tpr_err(\"create dma_map thread failed\\n\");\n\t\t\tret = PTR_ERR(tsk[i]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (node != NUMA_NO_NODE)\n\t\t\tkthread_bind_mask(tsk[i], cpu_mask);\n\t}\n\n\t \n\tatomic64_set(&map->sum_map_100ns, 0);\n\tatomic64_set(&map->sum_unmap_100ns, 0);\n\tatomic64_set(&map->sum_sq_map, 0);\n\tatomic64_set(&map->sum_sq_unmap, 0);\n\tatomic64_set(&map->loops, 0);\n\n\tfor (i = 0; i < threads; i++) {\n\t\tget_task_struct(tsk[i]);\n\t\twake_up_process(tsk[i]);\n\t}\n\n\tmsleep_interruptible(map->bparam.seconds * 1000);\n\n\t \n\tfor (i = 0; i < threads; i++) {\n\t\tret = kthread_stop(tsk[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tloops = atomic64_read(&map->loops);\n\tif (likely(loops > 0)) {\n\t\tu64 map_variance, unmap_variance;\n\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);\n\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);\n\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);\n\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);\n\n\t\t \n\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);\n\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);\n\n\t\t \n\t\tmap_variance = div64_u64(sum_sq_map, loops) -\n\t\t\t\tmap->bparam.avg_map_100ns *\n\t\t\t\tmap->bparam.avg_map_100ns;\n\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -\n\t\t\t\tmap->bparam.avg_unmap_100ns *\n\t\t\t\tmap->bparam.avg_unmap_100ns;\n\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);\n\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);\n\t}\n\nout:\n\tfor (i = 0; i < threads; i++)\n\t\tput_task_struct(tsk[i]);\n\tput_device(map->dev);\n\tkfree(tsk);\n\treturn ret;\n}\n\nstatic long map_benchmark_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct map_benchmark_data *map = file->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 old_dma_mask;\n\tint ret;\n\n\tif (copy_from_user(&map->bparam, argp, sizeof(map->bparam)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase DMA_MAP_BENCHMARK:\n\t\tif (map->bparam.threads == 0 ||\n\t\t    map->bparam.threads > DMA_MAP_MAX_THREADS) {\n\t\t\tpr_err(\"invalid thread number\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.seconds == 0 ||\n\t\t    map->bparam.seconds > DMA_MAP_MAX_SECONDS) {\n\t\t\tpr_err(\"invalid duration seconds\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.dma_trans_ns > DMA_MAP_MAX_TRANS_DELAY) {\n\t\t\tpr_err(\"invalid transmission delay\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.node != NUMA_NO_NODE &&\n\t\t    !node_possible(map->bparam.node)) {\n\t\t\tpr_err(\"invalid numa node\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (map->bparam.granule < 1 || map->bparam.granule > 1024) {\n\t\t\tpr_err(\"invalid granule size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (map->bparam.dma_dir) {\n\t\tcase DMA_MAP_BIDIRECTIONAL:\n\t\t\tmap->dir = DMA_BIDIRECTIONAL;\n\t\t\tbreak;\n\t\tcase DMA_MAP_FROM_DEVICE:\n\t\t\tmap->dir = DMA_FROM_DEVICE;\n\t\t\tbreak;\n\t\tcase DMA_MAP_TO_DEVICE:\n\t\t\tmap->dir = DMA_TO_DEVICE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"invalid DMA direction\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\told_dma_mask = dma_get_mask(map->dev);\n\n\t\tret = dma_set_mask(map->dev,\n\t\t\t\t   DMA_BIT_MASK(map->bparam.dma_bits));\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to set dma_mask on device %s\\n\",\n\t\t\t\tdev_name(map->dev));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = do_map_benchmark(map);\n\n\t\t \n\t\tdma_set_mask(map->dev, old_dma_mask);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_to_user(argp, &map->bparam, sizeof(map->bparam)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic const struct file_operations map_benchmark_fops = {\n\t.open\t\t\t= simple_open,\n\t.unlocked_ioctl\t\t= map_benchmark_ioctl,\n};\n\nstatic void map_benchmark_remove_debugfs(void *data)\n{\n\tstruct map_benchmark_data *map = (struct map_benchmark_data *)data;\n\n\tdebugfs_remove(map->debugfs);\n}\n\nstatic int __map_benchmark_probe(struct device *dev)\n{\n\tstruct dentry *entry;\n\tstruct map_benchmark_data *map;\n\tint ret;\n\n\tmap = devm_kzalloc(dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap->dev = dev;\n\n\tret = devm_add_action(dev, map_benchmark_remove_debugfs, map);\n\tif (ret) {\n\t\tpr_err(\"Can't add debugfs remove action\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tentry = debugfs_create_file(\"dma_map_benchmark\", 0600, NULL, map,\n\t\t\t&map_benchmark_fops);\n\tif (IS_ERR(entry))\n\t\treturn PTR_ERR(entry);\n\tmap->debugfs = entry;\n\n\treturn 0;\n}\n\nstatic int map_benchmark_platform_probe(struct platform_device *pdev)\n{\n\treturn __map_benchmark_probe(&pdev->dev);\n}\n\nstatic struct platform_driver map_benchmark_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"dma_map_benchmark\",\n\t},\n\t.probe = map_benchmark_platform_probe,\n};\n\nstatic int\nmap_benchmark_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\treturn __map_benchmark_probe(&pdev->dev);\n}\n\nstatic struct pci_driver map_benchmark_pci_driver = {\n\t.name\t= \"dma_map_benchmark\",\n\t.probe\t= map_benchmark_pci_probe,\n};\n\nstatic int __init map_benchmark_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&map_benchmark_pci_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&map_benchmark_platform_driver);\n\tif (ret) {\n\t\tpci_unregister_driver(&map_benchmark_pci_driver);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit map_benchmark_cleanup(void)\n{\n\tplatform_driver_unregister(&map_benchmark_platform_driver);\n\tpci_unregister_driver(&map_benchmark_pci_driver);\n}\n\nmodule_init(map_benchmark_init);\nmodule_exit(map_benchmark_cleanup);\n\nMODULE_AUTHOR(\"Barry Song <song.bao.hua@hisilicon.com>\");\nMODULE_DESCRIPTION(\"dma_map benchmark driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}