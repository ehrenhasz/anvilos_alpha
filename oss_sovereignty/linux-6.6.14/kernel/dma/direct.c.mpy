{
  "module_name": "direct.c",
  "hash_id": "2a13aea5ad4d48d3b6ca8287cad4fe3385225d7c80a8177768df42eeb36d8553",
  "original_prompt": "Ingested from linux-6.6.14/kernel/dma/direct.c",
  "human_readable_source": "\n \n#include <linux/memblock.h>  \n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/scatterlist.h>\n#include <linux/pfn.h>\n#include <linux/vmalloc.h>\n#include <linux/set_memory.h>\n#include <linux/slab.h>\n#include \"direct.h\"\n\n \nunsigned int zone_dma_bits __ro_after_init = 24;\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}\n\nstatic inline struct page *dma_direct_to_page(struct device *dev,\n\t\tdma_addr_t dma_addr)\n{\n\treturn pfn_to_page(PHYS_PFN(dma_to_phys(dev, dma_addr)));\n}\n\nu64 dma_direct_get_required_mask(struct device *dev)\n{\n\tphys_addr_t phys = (phys_addr_t)(max_pfn - 1) << PAGE_SHIFT;\n\tu64 max_dma = phys_to_dma_direct(dev, phys);\n\n\treturn (1ULL << (fls64(max_dma) - 1)) * 2 - 1;\n}\n\nstatic gfp_t dma_direct_optimal_gfp_mask(struct device *dev, u64 *phys_limit)\n{\n\tu64 dma_limit = min_not_zero(\n\t\tdev->coherent_dma_mask,\n\t\tdev->bus_dma_limit);\n\n\t \n\t*phys_limit = dma_to_phys(dev, dma_limit);\n\tif (*phys_limit <= DMA_BIT_MASK(zone_dma_bits))\n\t\treturn GFP_DMA;\n\tif (*phys_limit <= DMA_BIT_MASK(32))\n\t\treturn GFP_DMA32;\n\treturn 0;\n}\n\nbool dma_coherent_ok(struct device *dev, phys_addr_t phys, size_t size)\n{\n\tdma_addr_t dma_addr = phys_to_dma_direct(dev, phys);\n\n\tif (dma_addr == DMA_MAPPING_ERROR)\n\t\treturn false;\n\treturn dma_addr + size - 1 <=\n\t\tmin_not_zero(dev->coherent_dma_mask, dev->bus_dma_limit);\n}\n\nstatic int dma_set_decrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\treturn set_memory_decrypted((unsigned long)vaddr, PFN_UP(size));\n}\n\nstatic int dma_set_encrypted(struct device *dev, void *vaddr, size_t size)\n{\n\tint ret;\n\n\tif (!force_dma_unencrypted(dev))\n\t\treturn 0;\n\tret = set_memory_encrypted((unsigned long)vaddr, PFN_UP(size));\n\tif (ret)\n\t\tpr_warn_ratelimited(\"leaking DMA memory that can't be re-encrypted\\n\");\n\treturn ret;\n}\n\nstatic void __dma_direct_free_pages(struct device *dev, struct page *page,\n\t\t\t\t    size_t size)\n{\n\tif (swiotlb_free(dev, page, size))\n\t\treturn;\n\tdma_free_contiguous(dev, page, size);\n}\n\nstatic struct page *dma_direct_alloc_swiotlb(struct device *dev, size_t size)\n{\n\tstruct page *page = swiotlb_alloc(dev, size);\n\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tswiotlb_free(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\treturn page;\n}\n\nstatic struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tgfp_t gfp, bool allow_highmem)\n{\n\tint node = dev_to_node(dev);\n\tstruct page *page = NULL;\n\tu64 phys_limit;\n\n\tWARN_ON_ONCE(!PAGE_ALIGNED(size));\n\n\tif (is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_swiotlb(dev, size);\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, &phys_limit);\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (page) {\n\t\tif (!dma_coherent_ok(dev, page_to_phys(page), size) ||\n\t\t    (!allow_highmem && PageHighMem(page))) {\n\t\t\tdma_free_contiguous(dev, page, size);\n\t\t\tpage = NULL;\n\t\t}\n\t}\nagain:\n\tif (!page)\n\t\tpage = alloc_pages_node(node, gfp, get_order(size));\n\tif (page && !dma_coherent_ok(dev, page_to_phys(page), size)) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\tpage = NULL;\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA32) &&\n\t\t    phys_limit < DMA_BIT_MASK(64) &&\n\t\t    !(gfp & (GFP_DMA32 | GFP_DMA))) {\n\t\t\tgfp |= GFP_DMA32;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_ZONE_DMA) && !(gfp & GFP_DMA)) {\n\t\t\tgfp = (gfp & ~GFP_DMA32) | GFP_DMA;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn page;\n}\n\n \nstatic bool dma_direct_use_pool(struct device *dev, gfp_t gfp)\n{\n\treturn !gfpflags_allow_blocking(gfp) && !is_swiotlb_for_alloc(dev);\n}\n\nstatic void *dma_direct_alloc_from_pool(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\tu64 phys_limit;\n\tvoid *ret;\n\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_DMA_COHERENT_POOL)))\n\t\treturn NULL;\n\n\tgfp |= dma_direct_optimal_gfp_mask(dev, &phys_limit);\n\tpage = dma_alloc_from_pool(dev, size, &ret, gfp, dma_coherent_ok);\n\tif (!page)\n\t\treturn NULL;\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n}\n\nstatic void *dma_direct_alloc_no_mapping(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct page *page;\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO, true);\n\tif (!page)\n\t\treturn NULL;\n\n\t \n\tif (!PageHighMem(page))\n\t\tarch_dma_prep_coherent(page, size);\n\n\t \n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\n}\n\nvoid *dma_direct_alloc(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)\n{\n\tbool remap = false, set_uncached = false;\n\tstruct page *page;\n\tvoid *ret;\n\n\tsize = PAGE_ALIGN(size);\n\tif (attrs & DMA_ATTR_NO_WARN)\n\t\tgfp |= __GFP_NOWARN;\n\n\tif ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&\n\t    !force_dma_unencrypted(dev) && !is_swiotlb_for_alloc(dev))\n\t\treturn dma_direct_alloc_no_mapping(dev, size, dma_handle, gfp);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\t \n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&\n\t\t    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&\n\t\t    !IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t\t    !is_swiotlb_for_alloc(dev))\n\t\t\treturn arch_dma_alloc(dev, size, dma_handle, gfp,\n\t\t\t\t\t      attrs);\n\n\t\t \n\t\tif (IS_ENABLED(CONFIG_DMA_GLOBAL_POOL))\n\t\t\treturn dma_alloc_from_global_coherent(dev, size,\n\t\t\t\t\tdma_handle);\n\n\t\t \n\t\tremap = IS_ENABLED(CONFIG_DMA_DIRECT_REMAP);\n\t\tif (remap) {\n\t\t\tif (dma_direct_use_pool(dev, gfp))\n\t\t\t\treturn dma_direct_alloc_from_pool(dev, size,\n\t\t\t\t\t\tdma_handle, gfp);\n\t\t} else {\n\t\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED))\n\t\t\t\treturn NULL;\n\t\t\tset_uncached = true;\n\t\t}\n\t}\n\n\t \n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\t \n\tpage = __dma_direct_alloc_pages(dev, size, gfp & ~__GFP_ZERO, true);\n\tif (!page)\n\t\treturn NULL;\n\n\t \n\tif (PageHighMem(page)) {\n\t\tremap = true;\n\t\tset_uncached = false;\n\t}\n\n\tif (remap) {\n\t\tpgprot_t prot = dma_pgprot(dev, PAGE_KERNEL, attrs);\n\n\t\tif (force_dma_unencrypted(dev))\n\t\t\tprot = pgprot_decrypted(prot);\n\n\t\t \n\t\tarch_dma_prep_coherent(page, size);\n\n\t\t \n\t\tret = dma_common_contiguous_remap(page, size, prot,\n\t\t\t\t__builtin_return_address(0));\n\t\tif (!ret)\n\t\t\tgoto out_free_pages;\n\t} else {\n\t\tret = page_address(page);\n\t\tif (dma_set_decrypted(dev, ret, size))\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemset(ret, 0, size);\n\n\tif (set_uncached) {\n\t\tarch_dma_prep_coherent(page, size);\n\t\tret = arch_dma_set_uncached(ret, size);\n\t\tif (IS_ERR(ret))\n\t\t\tgoto out_encrypt_pages;\n\t}\n\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn ret;\n\nout_encrypt_pages:\n\tif (dma_set_encrypted(dev, page_address(page), size))\n\t\treturn NULL;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}\n\nvoid dma_direct_free(struct device *dev, size_t size,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, unsigned long attrs)\n{\n\tunsigned int page_order = get_order(size);\n\n\tif ((attrs & DMA_ATTR_NO_KERNEL_MAPPING) &&\n\t    !force_dma_unencrypted(dev) && !is_swiotlb_for_alloc(dev)) {\n\t\t \n\t\tdma_free_contiguous(dev, cpu_addr, size);\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_SET_UNCACHED) &&\n\t    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&\n\t    !IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t    !dev_is_dma_coherent(dev) &&\n\t    !is_swiotlb_for_alloc(dev)) {\n\t\tarch_dma_free(dev, size, cpu_addr, dma_addr, attrs);\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_DMA_GLOBAL_POOL) &&\n\t    !dev_is_dma_coherent(dev)) {\n\t\tif (!dma_release_from_global_coherent(page_order, cpu_addr))\n\t\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, cpu_addr, PAGE_ALIGN(size)))\n\t\treturn;\n\n\tif (is_vmalloc_addr(cpu_addr)) {\n\t\tvunmap(cpu_addr);\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_ARCH_HAS_DMA_CLEAR_UNCACHED))\n\t\t\tarch_dma_clear_uncached(cpu_addr, size);\n\t\tif (dma_set_encrypted(dev, cpu_addr, size))\n\t\t\treturn;\n\t}\n\n\t__dma_direct_free_pages(dev, dma_direct_to_page(dev, dma_addr), size);\n}\n\nstruct page *dma_direct_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tstruct page *page;\n\tvoid *ret;\n\n\tif (force_dma_unencrypted(dev) && dma_direct_use_pool(dev, gfp))\n\t\treturn dma_direct_alloc_from_pool(dev, size, dma_handle, gfp);\n\n\tpage = __dma_direct_alloc_pages(dev, size, gfp, false);\n\tif (!page)\n\t\treturn NULL;\n\n\tret = page_address(page);\n\tif (dma_set_decrypted(dev, ret, size))\n\t\tgoto out_free_pages;\n\tmemset(ret, 0, size);\n\t*dma_handle = phys_to_dma_direct(dev, page_to_phys(page));\n\treturn page;\nout_free_pages:\n\t__dma_direct_free_pages(dev, page, size);\n\treturn NULL;\n}\n\nvoid dma_direct_free_pages(struct device *dev, size_t size,\n\t\tstruct page *page, dma_addr_t dma_addr,\n\t\tenum dma_data_direction dir)\n{\n\tvoid *vaddr = page_address(page);\n\n\t \n\tif (IS_ENABLED(CONFIG_DMA_COHERENT_POOL) &&\n\t    dma_free_from_pool(dev, vaddr, size))\n\t\treturn;\n\n\tif (dma_set_encrypted(dev, vaddr, size))\n\t\treturn;\n\t__dma_direct_free_pages(dev, page, size);\n}\n\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\n    defined(CONFIG_SWIOTLB)\nvoid dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_device(dev, paddr, sg->length,\n\t\t\t\t\t\t       dir);\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_device(paddr, sg->length,\n\t\t\t\t\tdir);\n\t}\n}\n#endif\n\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL) || \\\n    defined(CONFIG_SWIOTLB)\nvoid dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tphys_addr_t paddr = dma_to_phys(dev, sg_dma_address(sg));\n\n\t\tif (!dev_is_dma_coherent(dev))\n\t\t\tarch_sync_dma_for_cpu(paddr, sg->length, dir);\n\n\t\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\t\tswiotlb_sync_single_for_cpu(dev, paddr, sg->length,\n\t\t\t\t\t\t    dir);\n\n\t\tif (dir == DMA_FROM_DEVICE)\n\t\t\tarch_dma_mark_clean(paddr, sg->length);\n\t}\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_cpu_all();\n}\n\n \nvoid dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(sgl,  sg, nents, i) {\n\t\tif (sg_dma_is_bus_address(sg))\n\t\t\tsg_dma_unmark_bus_address(sg);\n\t\telse\n\t\t\tdma_direct_unmap_page(dev, sg->dma_address,\n\t\t\t\t\t      sg_dma_len(sg), dir, attrs);\n\t}\n}\n#endif\n\nint dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tstruct pci_p2pdma_map_state p2pdma_state = {};\n\tenum pci_p2pdma_map_type map;\n\tstruct scatterlist *sg;\n\tint i, ret;\n\n\tfor_each_sg(sgl, sg, nents, i) {\n\t\tif (is_pci_p2pdma_page(sg_page(sg))) {\n\t\t\tmap = pci_p2pdma_map_segment(&p2pdma_state, dev, sg);\n\t\t\tswitch (map) {\n\t\t\tcase PCI_P2PDMA_MAP_BUS_ADDR:\n\t\t\t\tcontinue;\n\t\t\tcase PCI_P2PDMA_MAP_THRU_HOST_BRIDGE:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EREMOTEIO;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t}\n\n\t\tsg->dma_address = dma_direct_map_page(dev, sg_page(sg),\n\t\t\t\tsg->offset, sg->length, dir, attrs);\n\t\tif (sg->dma_address == DMA_MAPPING_ERROR) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tsg_dma_len(sg) = sg->length;\n\t}\n\n\treturn nents;\n\nout_unmap:\n\tdma_direct_unmap_sg(dev, sgl, i, dir, attrs | DMA_ATTR_SKIP_CPU_SYNC);\n\treturn ret;\n}\n\ndma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tdma_addr_t dma_addr = paddr;\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, false))) {\n\t\tdev_err_once(dev,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\tWARN_ON_ONCE(1);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\treturn dma_addr;\n}\n\nint dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tstruct page *page = dma_direct_to_page(dev, dma_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}\n\nbool dma_direct_can_mmap(struct device *dev)\n{\n\treturn dev_is_dma_coherent(dev) ||\n\t\tIS_ENABLED(CONFIG_DMA_NONCOHERENT_MMAP);\n}\n\nint dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long pfn = PHYS_PFN(dma_to_phys(dev, dma_addr));\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\tif (force_dma_unencrypted(dev))\n\t\tvma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\tif (dma_mmap_from_global_coherent(vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (vma->vm_pgoff >= count || user_count > count - vma->vm_pgoff)\n\t\treturn -ENXIO;\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n}\n\nint dma_direct_supported(struct device *dev, u64 mask)\n{\n\tu64 min_mask = (max_pfn - 1) << PAGE_SHIFT;\n\n\t \n\tif (mask >= DMA_BIT_MASK(32))\n\t\treturn 1;\n\n\t \n\tif (IS_ENABLED(CONFIG_ZONE_DMA))\n\t\tmin_mask = min_t(u64, min_mask, DMA_BIT_MASK(zone_dma_bits));\n\treturn mask >= phys_to_dma_unencrypted(dev, min_mask);\n}\n\nsize_t dma_direct_max_mapping_size(struct device *dev)\n{\n\t \n\tif (is_swiotlb_active(dev) &&\n\t    (dma_addressing_limited(dev) || is_swiotlb_force_bounce(dev)))\n\t\treturn swiotlb_max_mapping_size(dev);\n\treturn SIZE_MAX;\n}\n\nbool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr)\n{\n\treturn !dev_is_dma_coherent(dev) ||\n\t       is_swiotlb_buffer(dev, dma_to_phys(dev, dma_addr));\n}\n\n \nint dma_direct_set_offset(struct device *dev, phys_addr_t cpu_start,\n\t\t\t dma_addr_t dma_start, u64 size)\n{\n\tstruct bus_dma_region *map;\n\tu64 offset = (u64)cpu_start - (u64)dma_start;\n\n\tif (dev->dma_range_map) {\n\t\tdev_err(dev, \"attempt to add DMA range to existing map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!offset)\n\t\treturn 0;\n\n\tmap = kcalloc(2, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\tmap[0].cpu_start = cpu_start;\n\tmap[0].dma_start = dma_start;\n\tmap[0].offset = offset;\n\tmap[0].size = size;\n\tdev->dma_range_map = map;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}