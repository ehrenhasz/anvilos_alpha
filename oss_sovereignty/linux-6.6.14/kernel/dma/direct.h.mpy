{
  "module_name": "direct.h",
  "hash_id": "01e1f398af3ad6a8222359cb965ce3e253c45489320993cfae51204e10ca3688",
  "original_prompt": "Ingested from linux-6.6.14/kernel/dma/direct.h",
  "human_readable_source": " \n \n#ifndef _KERNEL_DMA_DIRECT_H\n#define _KERNEL_DMA_DIRECT_H\n\n#include <linux/dma-direct.h>\n#include <linux/memremap.h>\n\nint dma_direct_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs);\nbool dma_direct_can_mmap(struct device *dev);\nint dma_direct_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs);\nbool dma_direct_need_sync(struct device *dev, dma_addr_t dma_addr);\nint dma_direct_map_sg(struct device *dev, struct scatterlist *sgl, int nents,\n\t\tenum dma_data_direction dir, unsigned long attrs);\nsize_t dma_direct_max_mapping_size(struct device *dev);\n\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\n    defined(CONFIG_SWIOTLB)\nvoid dma_direct_sync_sg_for_device(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir);\n#else\nstatic inline void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n}\n#endif\n\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL) || \\\n    defined(CONFIG_SWIOTLB)\nvoid dma_direct_unmap_sg(struct device *dev, struct scatterlist *sgl,\n\t\tint nents, enum dma_data_direction dir, unsigned long attrs);\nvoid dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir);\n#else\nstatic inline void dma_direct_unmap_sg(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n}\nstatic inline void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n}\n#endif\n\nstatic inline void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_device(dev, paddr, size, dir);\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_device(paddr, size, dir);\n}\n\nstatic inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}\n\nstatic inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev)) {\n\t\tif (is_pci_p2pdma_page(page))\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\t}\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true)) ||\n\t    dma_kmalloc_needs_bounce(dev, size, dir)) {\n\t\tif (is_pci_p2pdma_page(page))\n\t\t\treturn DMA_MAPPING_ERROR;\n\t\tif (is_swiotlb_active(dev))\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}\n\nstatic inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir,\n\t\t\t\t\t attrs | DMA_ATTR_SKIP_CPU_SYNC);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}