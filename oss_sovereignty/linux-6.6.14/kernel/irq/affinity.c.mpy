{
  "module_name": "affinity.c",
  "hash_id": "bcd2919f6973462b8f4c11ede0170b2bd1586cab45c691b3df54aae065b59236",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/affinity.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/cpu.h>\n#include <linux/group_cpus.h>\n\nstatic void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)\n{\n\taffd->nr_sets = 1;\n\taffd->set_size[0] = affvecs;\n}\n\n \nstruct irq_affinity_desc *\nirq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)\n{\n\tunsigned int affvecs, curvec, usedvecs, i;\n\tstruct irq_affinity_desc *masks = NULL;\n\n\t \n\tif (nvecs > affd->pre_vectors + affd->post_vectors)\n\t\taffvecs = nvecs - affd->pre_vectors - affd->post_vectors;\n\telse\n\t\taffvecs = 0;\n\n\t \n\tif (!affd->calc_sets)\n\t\taffd->calc_sets = default_calc_sets;\n\n\t \n\taffd->calc_sets(affd, affvecs);\n\n\tif (WARN_ON_ONCE(affd->nr_sets > IRQ_AFFINITY_MAX_SETS))\n\t\treturn NULL;\n\n\t \n\tif (!affvecs)\n\t\treturn NULL;\n\n\tmasks = kcalloc(nvecs, sizeof(*masks), GFP_KERNEL);\n\tif (!masks)\n\t\treturn NULL;\n\n\t \n\tfor (curvec = 0; curvec < affd->pre_vectors; curvec++)\n\t\tcpumask_copy(&masks[curvec].mask, irq_default_affinity);\n\n\t \n\tfor (i = 0, usedvecs = 0; i < affd->nr_sets; i++) {\n\t\tunsigned int this_vecs = affd->set_size[i];\n\t\tint j;\n\t\tstruct cpumask *result = group_cpus_evenly(this_vecs);\n\n\t\tif (!result) {\n\t\t\tkfree(masks);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (j = 0; j < this_vecs; j++)\n\t\t\tcpumask_copy(&masks[curvec + j].mask, &result[j]);\n\t\tkfree(result);\n\n\t\tcurvec += this_vecs;\n\t\tusedvecs += this_vecs;\n\t}\n\n\t \n\tif (usedvecs >= affvecs)\n\t\tcurvec = affd->pre_vectors + affvecs;\n\telse\n\t\tcurvec = affd->pre_vectors + usedvecs;\n\tfor (; curvec < nvecs; curvec++)\n\t\tcpumask_copy(&masks[curvec].mask, irq_default_affinity);\n\n\t \n\tfor (i = affd->pre_vectors; i < nvecs - affd->post_vectors; i++)\n\t\tmasks[i].is_managed = 1;\n\n\treturn masks;\n}\n\n \nunsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,\n\t\t\t\t       const struct irq_affinity *affd)\n{\n\tunsigned int resv = affd->pre_vectors + affd->post_vectors;\n\tunsigned int set_vecs;\n\n\tif (resv > minvec)\n\t\treturn 0;\n\n\tif (affd->calc_sets) {\n\t\tset_vecs = maxvec - resv;\n\t} else {\n\t\tcpus_read_lock();\n\t\tset_vecs = cpumask_weight(cpu_possible_mask);\n\t\tcpus_read_unlock();\n\t}\n\n\treturn resv + min(set_vecs, maxvec - resv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}