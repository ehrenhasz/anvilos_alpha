{
  "module_name": "spurious.c",
  "hash_id": "9d345ab7de96453935241ccf3fbba193672feed711b2f376664dfd2f79be7534",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/spurious.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/timer.h>\n\n#include \"internals.h\"\n\nstatic int irqfixup __read_mostly;\n\n#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)\nstatic void poll_spurious_irqs(struct timer_list *unused);\nstatic DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs);\nstatic int irq_poll_cpu;\nstatic atomic_t irq_poll_active;\n\n \nbool irq_wait_for_poll(struct irq_desc *desc)\n\t__must_hold(&desc->lock)\n{\n\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),\n\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",\n\t\t      smp_processor_id(), desc->irq_data.irq))\n\t\treturn false;\n\n#ifdef CONFIG_SMP\n\tdo {\n\t\traw_spin_unlock(&desc->lock);\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\t\traw_spin_lock(&desc->lock);\n\t} while (irqd_irq_inprogress(&desc->irq_data));\n\t \n\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;\n#else\n\treturn false;\n#endif\n}\n\n\n \nstatic int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t \n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t \n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t \n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t \n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t \n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t \n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t \n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}\n\nstatic int misrouted_irq(int irq)\n{\n\tstruct irq_desc *desc;\n\tint i, ok = 0;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tif (!i)\n\t\t\t continue;\n\n\t\tif (i == irq)\t \n\t\t\tcontinue;\n\n\t\tif (try_one_irq(desc, false))\n\t\t\tok = 1;\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\t \n\treturn ok;\n}\n\nstatic void poll_spurious_irqs(struct timer_list *unused)\n{\n\tstruct irq_desc *desc;\n\tint i;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tunsigned int state;\n\n\t\tif (!i)\n\t\t\t continue;\n\n\t\t \n\t\tstate = desc->istate;\n\t\tbarrier();\n\t\tif (!(state & IRQS_SPURIOUS_DISABLED))\n\t\t\tcontinue;\n\n\t\tlocal_irq_disable();\n\t\ttry_one_irq(desc, true);\n\t\tlocal_irq_enable();\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\tmod_timer(&poll_spurious_irq_timer,\n\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n}\n\nstatic inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t \n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}\n\nstatic void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tstatic int count = 100;\n\n\tif (count > 0) {\n\t\tcount--;\n\t\t__report_bad_irq(desc, action_ret);\n\t}\n}\n\nstatic inline int\ntry_misrouted_irq(unsigned int irq, struct irq_desc *desc,\n\t\t  irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\n\tif (!irqfixup)\n\t\treturn 0;\n\n\t \n\tif (action_ret == IRQ_NONE)\n\t\treturn 1;\n\n\t \n\tif (irqfixup < 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t \n\taction = desc->action;\n\tbarrier();\n\treturn action && (action->flags & IRQF_IRQPOLL);\n}\n\n#define SPURIOUS_DEFERRED\t0x80000000\n\nvoid note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq;\n\n\tif (desc->istate & IRQS_POLL_INPROGRESS ||\n\t    irq_settings_is_polled(desc))\n\t\treturn;\n\n\tif (bad_action_ret(action_ret)) {\n\t\treport_bad_irq(desc, action_ret);\n\t\treturn;\n\t}\n\n\t \n\tif (action_ret & IRQ_WAKE_THREAD) {\n\t\t \n\t\tif (action_ret == IRQ_WAKE_THREAD) {\n\t\t\tint handled;\n\t\t\t \n\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {\n\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\thandled = atomic_read(&desc->threads_handled);\n\t\t\thandled |= SPURIOUS_DEFERRED;\n\t\t\tif (handled != desc->threads_handled_last) {\n\t\t\t\taction_ret = IRQ_HANDLED;\n\t\t\t\t \n\t\t\t\tdesc->threads_handled_last = handled;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\taction_ret = IRQ_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;\n\t\t}\n\t}\n\n\tif (unlikely(action_ret == IRQ_NONE)) {\n\t\t \n\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))\n\t\t\tdesc->irqs_unhandled = 1;\n\t\telse\n\t\t\tdesc->irqs_unhandled++;\n\t\tdesc->last_unhandled = jiffies;\n\t}\n\n\tirq = irq_desc_get_irq(desc);\n\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {\n\t\tint ok = misrouted_irq(irq);\n\t\tif (action_ret == IRQ_NONE)\n\t\t\tdesc->irqs_unhandled -= ok;\n\t}\n\n\tif (likely(!desc->irqs_unhandled))\n\t\treturn;\n\n\t \n\tdesc->irq_count++;\n\tif (likely(desc->irq_count < 100000))\n\t\treturn;\n\n\tdesc->irq_count = 0;\n\tif (unlikely(desc->irqs_unhandled > 99900)) {\n\t\t \n\t\t__report_bad_irq(desc, action_ret);\n\t\t \n\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);\n\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\n\t\tmod_timer(&poll_spurious_irq_timer,\n\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n\t}\n\tdesc->irqs_unhandled = 0;\n}\n\nbool noirqdebug __read_mostly;\n\nint noirqdebug_setup(char *str)\n{\n\tnoirqdebug = 1;\n\tprintk(KERN_INFO \"IRQ lockup detection disabled\\n\");\n\n\treturn 1;\n}\n\n__setup(\"noirqdebug\", noirqdebug_setup);\nmodule_param(noirqdebug, bool, 0644);\nMODULE_PARM_DESC(noirqdebug, \"Disable irq lockup detection when true\");\n\nstatic int __init irqfixup_setup(char *str)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tpr_warn(\"irqfixup boot option not supported with PREEMPT_RT\\n\");\n\t\treturn 1;\n\t}\n\tirqfixup = 1;\n\tprintk(KERN_WARNING \"Misrouted IRQ fixup support enabled.\\n\");\n\tprintk(KERN_WARNING \"This may impact system performance.\\n\");\n\n\treturn 1;\n}\n\n__setup(\"irqfixup\", irqfixup_setup);\nmodule_param(irqfixup, int, 0644);\n\nstatic int __init irqpoll_setup(char *str)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tpr_warn(\"irqpoll boot option not supported with PREEMPT_RT\\n\");\n\t\treturn 1;\n\t}\n\tirqfixup = 2;\n\tprintk(KERN_WARNING \"Misrouted IRQ fixup and polling support \"\n\t\t\t\t\"enabled\\n\");\n\tprintk(KERN_WARNING \"This may significantly impact system \"\n\t\t\t\t\"performance\\n\");\n\treturn 1;\n}\n\n__setup(\"irqpoll\", irqpoll_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}