{
  "module_name": "ipi-mux.c",
  "hash_id": "08567caf79b5fcbaa144978135dcfd92b0ee3dd0cd989bfc246e395acc317ca0",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/ipi-mux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ipi-mux: \" fmt\n#include <linux/cpu.h>\n#include <linux/init.h>\n#include <linux/irq.h>\n#include <linux/irqchip.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/jump_label.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n\nstruct ipi_mux_cpu {\n\tatomic_t\t\t\tenable;\n\tatomic_t\t\t\tbits;\n};\n\nstatic struct ipi_mux_cpu __percpu *ipi_mux_pcpu;\nstatic struct irq_domain *ipi_mux_domain;\nstatic void (*ipi_mux_send)(unsigned int cpu);\n\nstatic void ipi_mux_mask(struct irq_data *d)\n{\n\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);\n\n\tatomic_andnot(BIT(irqd_to_hwirq(d)), &icpu->enable);\n}\n\nstatic void ipi_mux_unmask(struct irq_data *d)\n{\n\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);\n\tu32 ibit = BIT(irqd_to_hwirq(d));\n\n\tatomic_or(ibit, &icpu->enable);\n\n\t \n\tsmp_mb__after_atomic();\n\n\t \n\tif (atomic_read(&icpu->bits) & ibit)\n\t\tipi_mux_send(smp_processor_id());\n}\n\nstatic void ipi_mux_send_mask(struct irq_data *d, const struct cpumask *mask)\n{\n\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);\n\tu32 ibit = BIT(irqd_to_hwirq(d));\n\tunsigned long pending;\n\tint cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ticpu = per_cpu_ptr(ipi_mux_pcpu, cpu);\n\n\t\t \n\t\tpending = atomic_fetch_or_release(ibit, &icpu->bits);\n\n\t\t \n\t\tsmp_mb__after_atomic();\n\n\t\t \n\t\tif (!(pending & ibit) && (atomic_read(&icpu->enable) & ibit))\n\t\t\tipi_mux_send(cpu);\n\t}\n}\n\nstatic const struct irq_chip ipi_mux_chip = {\n\t.name\t\t= \"IPI Mux\",\n\t.irq_mask\t= ipi_mux_mask,\n\t.irq_unmask\t= ipi_mux_unmask,\n\t.ipi_send_mask\t= ipi_mux_send_mask,\n};\n\nstatic int ipi_mux_domain_alloc(struct irq_domain *d, unsigned int virq,\n\t\t\t\tunsigned int nr_irqs, void *arg)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_percpu_devid(virq + i);\n\t\tirq_domain_set_info(d, virq + i, i, &ipi_mux_chip, NULL,\n\t\t\t\t    handle_percpu_devid_irq, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ipi_mux_domain_ops = {\n\t.alloc\t\t= ipi_mux_domain_alloc,\n\t.free\t\t= irq_domain_free_irqs_top,\n};\n\n \nvoid ipi_mux_process(void)\n{\n\tstruct ipi_mux_cpu *icpu = this_cpu_ptr(ipi_mux_pcpu);\n\tirq_hw_number_t hwirq;\n\tunsigned long ipis;\n\tunsigned int en;\n\n\t \n\ten = atomic_read(&icpu->enable);\n\n\t \n\tipis = atomic_fetch_andnot(en, &icpu->bits) & en;\n\n\tfor_each_set_bit(hwirq, &ipis, BITS_PER_TYPE(int))\n\t\tgeneric_handle_domain_irq(ipi_mux_domain, hwirq);\n}\n\n \nint ipi_mux_create(unsigned int nr_ipi, void (*mux_send)(unsigned int cpu))\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct irq_domain *domain;\n\tint rc;\n\n\tif (ipi_mux_domain)\n\t\treturn -EEXIST;\n\n\tif (BITS_PER_TYPE(int) < nr_ipi || !mux_send)\n\t\treturn -EINVAL;\n\n\tipi_mux_pcpu = alloc_percpu(typeof(*ipi_mux_pcpu));\n\tif (!ipi_mux_pcpu)\n\t\treturn -ENOMEM;\n\n\tfwnode = irq_domain_alloc_named_fwnode(\"IPI-Mux\");\n\tif (!fwnode) {\n\t\tpr_err(\"unable to create IPI Mux fwnode\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto fail_free_cpu;\n\t}\n\n\tdomain = irq_domain_create_linear(fwnode, nr_ipi,\n\t\t\t\t\t  &ipi_mux_domain_ops, NULL);\n\tif (!domain) {\n\t\tpr_err(\"unable to add IPI Mux domain\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto fail_free_fwnode;\n\t}\n\n\tdomain->flags |= IRQ_DOMAIN_FLAG_IPI_SINGLE;\n\tirq_domain_update_bus_token(domain, DOMAIN_BUS_IPI);\n\n\trc = irq_domain_alloc_irqs(domain, nr_ipi, NUMA_NO_NODE, NULL);\n\tif (rc <= 0) {\n\t\tpr_err(\"unable to alloc IRQs from IPI Mux domain\\n\");\n\t\tgoto fail_free_domain;\n\t}\n\n\tipi_mux_domain = domain;\n\tipi_mux_send = mux_send;\n\n\treturn rc;\n\nfail_free_domain:\n\tirq_domain_remove(domain);\nfail_free_fwnode:\n\tirq_domain_free_fwnode(fwnode);\nfail_free_cpu:\n\tfree_percpu(ipi_mux_pcpu);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}