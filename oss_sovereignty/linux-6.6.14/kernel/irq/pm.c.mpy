{
  "module_name": "pm.c",
  "hash_id": "5fc6d3b7ea1bc999e63f382e1b2aa5aa28b3a8b2a3f6d5e4463b85ed05af2d0d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/pm.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n\n#include \"internals.h\"\n\nbool irq_pm_check_wakeup(struct irq_desc *desc)\n{\n\tif (irqd_is_wakeup_armed(&desc->irq_data)) {\n\t\tirqd_clear(&desc->irq_data, IRQD_WAKEUP_ARMED);\n\t\tdesc->istate |= IRQS_SUSPENDED | IRQS_PENDING;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\t\tpm_system_irq_wakeup(irq_desc_get_irq(desc));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid irq_pm_install_action(struct irq_desc *desc, struct irqaction *action)\n{\n\tdesc->nr_actions++;\n\n\tif (action->flags & IRQF_FORCE_RESUME)\n\t\tdesc->force_resume_depth++;\n\n\tWARN_ON_ONCE(desc->force_resume_depth &&\n\t\t     desc->force_resume_depth != desc->nr_actions);\n\n\tif (action->flags & IRQF_NO_SUSPEND)\n\t\tdesc->no_suspend_depth++;\n\telse if (action->flags & IRQF_COND_SUSPEND)\n\t\tdesc->cond_suspend_depth++;\n\n\tWARN_ON_ONCE(desc->no_suspend_depth &&\n\t\t     (desc->no_suspend_depth +\n\t\t\tdesc->cond_suspend_depth) != desc->nr_actions);\n}\n\n \nvoid irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action)\n{\n\tdesc->nr_actions--;\n\n\tif (action->flags & IRQF_FORCE_RESUME)\n\t\tdesc->force_resume_depth--;\n\n\tif (action->flags & IRQF_NO_SUSPEND)\n\t\tdesc->no_suspend_depth--;\n\telse if (action->flags & IRQF_COND_SUSPEND)\n\t\tdesc->cond_suspend_depth--;\n}\n\nstatic bool suspend_device_irq(struct irq_desc *desc)\n{\n\tunsigned long chipflags = irq_desc_get_chip(desc)->flags;\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tif (!desc->action || irq_desc_is_chained(desc) ||\n\t    desc->no_suspend_depth)\n\t\treturn false;\n\n\tif (irqd_is_wakeup_set(irqd)) {\n\t\tirqd_set(irqd, IRQD_WAKEUP_ARMED);\n\n\t\tif ((chipflags & IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND) &&\n\t\t     irqd_irq_disabled(irqd)) {\n\t\t\t \n\t\t\t__enable_irq(desc);\n\t\t\tirqd_set(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t\t}\n\t\t \n\t\treturn true;\n\t}\n\n\tdesc->istate |= IRQS_SUSPENDED;\n\t__disable_irq(desc);\n\n\t \n\tif (chipflags & IRQCHIP_MASK_ON_SUSPEND)\n\t\tmask_irq(desc);\n\treturn true;\n}\n\n \nvoid suspend_device_irqs(void)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool sync;\n\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tsync = suspend_device_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\t\tif (sync)\n\t\t\tsynchronize_irq(irq);\n\t}\n}\n\nstatic void resume_irq(struct irq_desc *desc)\n{\n\tstruct irq_data *irqd = &desc->irq_data;\n\n\tirqd_clear(irqd, IRQD_WAKEUP_ARMED);\n\n\tif (irqd_is_enabled_on_suspend(irqd)) {\n\t\t \n\t\t__disable_irq(desc);\n\t\tirqd_clear(irqd, IRQD_IRQ_ENABLED_ON_SUSPEND);\n\t}\n\n\tif (desc->istate & IRQS_SUSPENDED)\n\t\tgoto resume;\n\n\t \n\tif (!desc->force_resume_depth)\n\t\treturn;\n\n\t \n\tdesc->depth++;\n\tirq_state_set_disabled(desc);\n\tirq_state_set_masked(desc);\nresume:\n\tdesc->istate &= ~IRQS_SUSPENDED;\n\t__enable_irq(desc);\n}\n\nstatic void resume_irqs(bool want_early)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\tfor_each_irq_desc(irq, desc) {\n\t\tunsigned long flags;\n\t\tbool is_early = desc->action &&\n\t\t\tdesc->action->flags & IRQF_EARLY_RESUME;\n\n\t\tif (!is_early && want_early)\n\t\t\tcontinue;\n\t\tif (irq_settings_is_nested_thread(desc))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tresume_irq(desc);\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}\n\n \nvoid rearm_wake_irq(unsigned int irq)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn;\n\n\tif (!(desc->istate & IRQS_SUSPENDED) ||\n\t    !irqd_is_wakeup_set(&desc->irq_data))\n\t\tgoto unlock;\n\n\tdesc->istate &= ~IRQS_SUSPENDED;\n\tirqd_set(&desc->irq_data, IRQD_WAKEUP_ARMED);\n\t__enable_irq(desc);\n\nunlock:\n\tirq_put_desc_busunlock(desc, flags);\n}\n\n \nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}\n\nstatic struct syscore_ops irq_pm_syscore_ops = {\n\t.resume\t\t= irq_pm_syscore_resume,\n};\n\nstatic int __init irq_pm_init_ops(void)\n{\n\tregister_syscore_ops(&irq_pm_syscore_ops);\n\treturn 0;\n}\n\ndevice_initcall(irq_pm_init_ops);\n\n \nvoid resume_device_irqs(void)\n{\n\tresume_irqs(false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}