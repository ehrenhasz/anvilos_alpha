{
  "module_name": "autoprobe.c",
  "hash_id": "e629b3ad13f2ba4ed396b006a22168cad252763ebefb02f99d560e74ddfde349",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/autoprobe.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n\n#include \"internals.h\"\n\n \nstatic DEFINE_MUTEX(probing_active);\n\n \nunsigned long probe_irq_on(void)\n{\n\tstruct irq_desc *desc;\n\tunsigned long mask = 0;\n\tint i;\n\n\t \n\tasync_synchronize_full();\n\tmutex_lock(&probing_active);\n\t \n\tfor_each_irq_desc_reverse(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (!desc->action && irq_settings_can_probe(desc)) {\n\t\t\t \n\t\t\tif (desc->irq_data.chip->irq_set_type)\n\t\t\t\tdesc->irq_data.chip->irq_set_type(&desc->irq_data,\n\t\t\t\t\t\t\t IRQ_TYPE_PROBE);\n\t\t\tirq_activate_and_startup(desc, IRQ_NORESEND);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\t \n\tmsleep(20);\n\n\t \n\tfor_each_irq_desc_reverse(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (!desc->action && irq_settings_can_probe(desc)) {\n\t\t\tdesc->istate |= IRQS_AUTODETECT | IRQS_WAITING;\n\t\t\tif (irq_activate_and_startup(desc, IRQ_NORESEND))\n\t\t\t\tdesc->istate |= IRQS_PENDING;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\t \n\tmsleep(100);\n\n\t \n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\t \n\t\t\tif (!(desc->istate & IRQS_WAITING)) {\n\t\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\t\tirq_shutdown_and_deactivate(desc);\n\t\t\t} else\n\t\t\t\tif (i < 32)\n\t\t\t\t\tmask |= 1 << i;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\treturn mask;\n}\nEXPORT_SYMBOL(probe_irq_on);\n\n \nunsigned int probe_irq_mask(unsigned long val)\n{\n\tunsigned int mask = 0;\n\tstruct irq_desc *desc;\n\tint i;\n\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\tif (i < 16 && !(desc->istate & IRQS_WAITING))\n\t\t\t\tmask |= 1 << i;\n\n\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\tirq_shutdown_and_deactivate(desc);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tmutex_unlock(&probing_active);\n\n\treturn mask & val;\n}\nEXPORT_SYMBOL(probe_irq_mask);\n\n \nint probe_irq_off(unsigned long val)\n{\n\tint i, irq_found = 0, nr_of_irqs = 0;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\tif (!(desc->istate & IRQS_WAITING)) {\n\t\t\t\tif (!nr_of_irqs)\n\t\t\t\t\tirq_found = i;\n\t\t\t\tnr_of_irqs++;\n\t\t\t}\n\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\tirq_shutdown_and_deactivate(desc);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tmutex_unlock(&probing_active);\n\n\tif (nr_of_irqs > 1)\n\t\tirq_found = -irq_found;\n\n\treturn irq_found;\n}\nEXPORT_SYMBOL(probe_irq_off);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}