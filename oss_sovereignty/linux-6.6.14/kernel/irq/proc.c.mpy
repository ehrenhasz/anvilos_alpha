{
  "module_name": "proc.c",
  "hash_id": "8def96f2410444e132c23ba26cc597ad6ed4ee1d47273bf16713c29ddb4304ff",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/proc.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/gfp.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/mutex.h>\n\n#include \"internals.h\"\n\n \nstatic struct proc_dir_entry *root_irq_dir;\n\n#ifdef CONFIG_SMP\n\nenum {\n\tAFFINITY,\n\tAFFINITY_LIST,\n\tEFFECTIVE,\n\tEFFECTIVE_LIST,\n};\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int irq_affinity_hint_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tunsigned long flags;\n\tcpumask_var_t mask;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->affinity_hint)\n\t\tcpumask_copy(mask, desc->affinity_hint);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n}\n\nint no_irq_affinity;\nstatic int irq_affinity_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY, m);\n}\n\nstatic int irq_affinity_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY_LIST, m);\n}\n\n#ifndef CONFIG_AUTO_IRQ_AFFINITY\nstatic inline int irq_select_affinity_usr(unsigned int irq)\n{\n\t \n\treturn -EINVAL;\n}\n#else\n \nstatic inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}\n#endif\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t \n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t \n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}\n\nstatic ssize_t irq_affinity_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(0, file, buffer, count, pos);\n}\n\nstatic ssize_t irq_affinity_list_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(1, file, buffer, count, pos);\n}\n\nstatic int irq_affinity_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_proc_show, pde_data(inode));\n}\n\nstatic int irq_affinity_list_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_list_proc_show, pde_data(inode));\n}\n\nstatic const struct proc_ops irq_affinity_proc_ops = {\n\t.proc_open\t= irq_affinity_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= irq_affinity_proc_write,\n};\n\nstatic const struct proc_ops irq_affinity_list_proc_ops = {\n\t.proc_open\t= irq_affinity_list_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= irq_affinity_list_proc_write,\n};\n\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\nstatic int irq_effective_aff_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE, m);\n}\n\nstatic int irq_effective_aff_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE_LIST, m);\n}\n#endif\n\nstatic int default_affinity_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(irq_default_affinity));\n\treturn 0;\n}\n\nstatic ssize_t default_affinity_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcpumask_copy(irq_default_affinity, new_value);\n\terr = count;\n\nout:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}\n\nstatic int default_affinity_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, default_affinity_show, pde_data(inode));\n}\n\nstatic const struct proc_ops default_affinity_proc_ops = {\n\t.proc_open\t= default_affinity_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= default_affinity_write,\n};\n\nstatic int irq_node_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"%d\\n\", irq_desc_get_node(desc));\n\treturn 0;\n}\n#endif\n\nstatic int irq_spurious_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\",\n\t\t   desc->irq_count, desc->irqs_unhandled,\n\t\t   jiffies_to_msecs(desc->last_unhandled));\n\treturn 0;\n}\n\n#define MAX_NAMELEN 128\n\nstatic int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}\n\nvoid register_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tchar name [MAX_NAMELEN];\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc->dir || action->dir || !action->name ||\n\t\t\t\t\t!name_unique(irq, action))\n\t\treturn;\n\n\tsnprintf(name, MAX_NAMELEN, \"%s\", action->name);\n\n\t \n\taction->dir = proc_mkdir(name, desc->dir);\n}\n\n#undef MAX_NAMELEN\n\n#define MAX_NAMELEN 10\n\nvoid register_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tstatic DEFINE_MUTEX(register_lock);\n\tvoid __maybe_unused *irqp = (void *)(unsigned long) irq;\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))\n\t\treturn;\n\n\t \n\tmutex_lock(&register_lock);\n\n\tif (desc->dir)\n\t\tgoto out_unlock;\n\n\tsprintf(name, \"%d\", irq);\n\n\t \n\tdesc->dir = proc_mkdir(name, root_irq_dir);\n\tif (!desc->dir)\n\t\tgoto out_unlock;\n\n#ifdef CONFIG_SMP\n\t \n\tproc_create_data(\"smp_affinity\", 0644, desc->dir,\n\t\t\t &irq_affinity_proc_ops, irqp);\n\n\t \n\tproc_create_single_data(\"affinity_hint\", 0444, desc->dir,\n\t\t\tirq_affinity_hint_proc_show, irqp);\n\n\t \n\tproc_create_data(\"smp_affinity_list\", 0644, desc->dir,\n\t\t\t &irq_affinity_list_proc_ops, irqp);\n\n\tproc_create_single_data(\"node\", 0444, desc->dir, irq_node_proc_show,\n\t\t\tirqp);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tproc_create_single_data(\"effective_affinity\", 0444, desc->dir,\n\t\t\tirq_effective_aff_proc_show, irqp);\n\tproc_create_single_data(\"effective_affinity_list\", 0444, desc->dir,\n\t\t\tirq_effective_aff_list_proc_show, irqp);\n# endif\n#endif\n\tproc_create_single_data(\"spurious\", 0444, desc->dir,\n\t\t\tirq_spurious_proc_show, (void *)(long)irq);\n\nout_unlock:\n\tmutex_unlock(&register_lock);\n}\n\nvoid unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}\n\n#undef MAX_NAMELEN\n\nvoid unregister_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tproc_remove(action->dir);\n}\n\nstatic void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_ops);\n#endif\n}\n\nvoid init_irq_proc(void)\n{\n\tunsigned int irq;\n\tstruct irq_desc *desc;\n\n\t \n\troot_irq_dir = proc_mkdir(\"irq\", NULL);\n\tif (!root_irq_dir)\n\t\treturn;\n\n\tregister_default_affinity_proc();\n\n\t \n\tfor_each_irq_desc(irq, desc)\n\t\tregister_irq_proc(irq, desc);\n}\n\n#ifdef CONFIG_GENERIC_IRQ_SHOW\n\nint __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}\n\n#ifndef ACTUAL_NR_IRQS\n# define ACTUAL_NR_IRQS nr_irqs\n#endif\n\nint show_interrupts(struct seq_file *p, void *v)\n{\n\tstatic int prec;\n\n\tunsigned long flags, any_count = 0;\n\tint i = *(loff_t *) v, j;\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\n\tif (i > ACTUAL_NR_IRQS)\n\t\treturn 0;\n\n\tif (i == ACTUAL_NR_IRQS)\n\t\treturn arch_show_interrupts(p, prec);\n\n\t \n\tif (i == 0) {\n\t\tfor (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"CPU%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(i);\n\tif (!desc || irq_settings_is_hidden(desc))\n\t\tgoto outsparse;\n\n\tif (desc->kstat_irqs) {\n\t\tfor_each_online_cpu(j)\n\t\t\tany_count |= data_race(*per_cpu_ptr(desc->kstat_irqs, j));\n\t}\n\n\tif ((!desc->action || irq_desc_is_chained(desc)) && !any_count)\n\t\tgoto outsparse;\n\n\tseq_printf(p, \"%*d: \", prec, i);\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", desc->kstat_irqs ?\n\t\t\t\t\t*per_cpu_ptr(desc->kstat_irqs, j) : 0);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->irq_data.chip) {\n\t\tif (desc->irq_data.chip->irq_print_chip)\n\t\t\tdesc->irq_data.chip->irq_print_chip(&desc->irq_data, p);\n\t\telse if (desc->irq_data.chip->name)\n\t\t\tseq_printf(p, \" %8s\", desc->irq_data.chip->name);\n\t\telse\n\t\t\tseq_printf(p, \" %8s\", \"-\");\n\t} else {\n\t\tseq_printf(p, \" %8s\", \"None\");\n\t}\n\tif (desc->irq_data.domain)\n\t\tseq_printf(p, \" %*lu\", prec, desc->irq_data.hwirq);\n\telse\n\t\tseq_printf(p, \" %*s\", prec, \"\");\n#ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL\n\tseq_printf(p, \" %-8s\", irqd_is_level_type(&desc->irq_data) ? \"Level\" : \"Edge\");\n#endif\n\tif (desc->name)\n\t\tseq_printf(p, \"-%-8s\", desc->name);\n\n\taction = desc->action;\n\tif (action) {\n\t\tseq_printf(p, \"  %s\", action->name);\n\t\twhile ((action = action->next) != NULL)\n\t\t\tseq_printf(p, \", %s\", action->name);\n\t}\n\n\tseq_putc(p, '\\n');\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\noutsparse:\n\trcu_read_unlock();\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}