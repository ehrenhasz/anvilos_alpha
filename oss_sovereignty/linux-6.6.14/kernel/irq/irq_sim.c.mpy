{
  "module_name": "irq_sim.c",
  "hash_id": "c9f918c3aa7c2b882c284b283bb83fee116095b10875398eb45f1ec31b249f98",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/irq_sim.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/irq_sim.h>\n#include <linux/irq_work.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\nstruct irq_sim_work_ctx {\n\tstruct irq_work\t\twork;\n\tint\t\t\tirq_base;\n\tunsigned int\t\tirq_count;\n\tunsigned long\t\t*pending;\n\tstruct irq_domain\t*domain;\n};\n\nstruct irq_sim_irq_ctx {\n\tint\t\t\tirqnum;\n\tbool\t\t\tenabled;\n\tstruct irq_sim_work_ctx\t*work_ctx;\n};\n\nstatic void irq_sim_irqmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = false;\n}\n\nstatic void irq_sim_irqunmask(struct irq_data *data)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\n\tirq_ctx->enabled = true;\n}\n\nstatic int irq_sim_set_type(struct irq_data *data, unsigned int type)\n{\n\t \n\tif (type & ~IRQ_TYPE_EDGE_BOTH)\n\t\treturn -EINVAL;\n\n\tirqd_set_trigger_type(data, type);\n\n\treturn 0;\n}\n\nstatic int irq_sim_get_irqchip_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which, bool *state)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\tif (irq_ctx->enabled)\n\t\t\t*state = test_bit(hwirq, irq_ctx->work_ctx->pending);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int irq_sim_set_irqchip_state(struct irq_data *data,\n\t\t\t\t     enum irqchip_irq_state which, bool state)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx = irq_data_get_irq_chip_data(data);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\n\tswitch (which) {\n\tcase IRQCHIP_STATE_PENDING:\n\t\tif (irq_ctx->enabled) {\n\t\t\tassign_bit(hwirq, irq_ctx->work_ctx->pending, state);\n\t\t\tif (state)\n\t\t\t\tirq_work_queue(&irq_ctx->work_ctx->work);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct irq_chip irq_sim_irqchip = {\n\t.name\t\t\t= \"irq_sim\",\n\t.irq_mask\t\t= irq_sim_irqmask,\n\t.irq_unmask\t\t= irq_sim_irqunmask,\n\t.irq_set_type\t\t= irq_sim_set_type,\n\t.irq_get_irqchip_state\t= irq_sim_get_irqchip_state,\n\t.irq_set_irqchip_state\t= irq_sim_set_irqchip_state,\n};\n\nstatic void irq_sim_handle_irq(struct irq_work *work)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\tunsigned int offset = 0;\n\tint irqnum;\n\n\twork_ctx = container_of(work, struct irq_sim_work_ctx, work);\n\n\twhile (!bitmap_empty(work_ctx->pending, work_ctx->irq_count)) {\n\t\toffset = find_next_bit(work_ctx->pending,\n\t\t\t\t       work_ctx->irq_count, offset);\n\t\tclear_bit(offset, work_ctx->pending);\n\t\tirqnum = irq_find_mapping(work_ctx->domain, offset);\n\t\thandle_simple_irq(irq_to_desc(irqnum));\n\t}\n}\n\nstatic int irq_sim_domain_map(struct irq_domain *domain,\n\t\t\t      unsigned int virq, irq_hw_number_t hw)\n{\n\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;\n\tstruct irq_sim_irq_ctx *irq_ctx;\n\n\tirq_ctx = kzalloc(sizeof(*irq_ctx), GFP_KERNEL);\n\tif (!irq_ctx)\n\t\treturn -ENOMEM;\n\n\tirq_set_chip(virq, &irq_sim_irqchip);\n\tirq_set_chip_data(virq, irq_ctx);\n\tirq_set_handler(virq, handle_simple_irq);\n\tirq_modify_status(virq, IRQ_NOREQUEST | IRQ_NOAUTOEN, IRQ_NOPROBE);\n\tirq_ctx->work_ctx = work_ctx;\n\n\treturn 0;\n}\n\nstatic void irq_sim_domain_unmap(struct irq_domain *domain, unsigned int virq)\n{\n\tstruct irq_sim_irq_ctx *irq_ctx;\n\tstruct irq_data *irqd;\n\n\tirqd = irq_domain_get_irq_data(domain, virq);\n\tirq_ctx = irq_data_get_irq_chip_data(irqd);\n\n\tirq_set_handler(virq, NULL);\n\tirq_domain_reset_irq_data(irqd);\n\tkfree(irq_ctx);\n}\n\nstatic const struct irq_domain_ops irq_sim_domain_ops = {\n\t.map\t\t= irq_sim_domain_map,\n\t.unmap\t\t= irq_sim_domain_unmap,\n};\n\n \nstruct irq_domain *irq_domain_create_sim(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int num_irqs)\n{\n\tstruct irq_sim_work_ctx *work_ctx;\n\n\twork_ctx = kmalloc(sizeof(*work_ctx), GFP_KERNEL);\n\tif (!work_ctx)\n\t\tgoto err_out;\n\n\twork_ctx->pending = bitmap_zalloc(num_irqs, GFP_KERNEL);\n\tif (!work_ctx->pending)\n\t\tgoto err_free_work_ctx;\n\n\twork_ctx->domain = irq_domain_create_linear(fwnode, num_irqs,\n\t\t\t\t\t\t    &irq_sim_domain_ops,\n\t\t\t\t\t\t    work_ctx);\n\tif (!work_ctx->domain)\n\t\tgoto err_free_bitmap;\n\n\twork_ctx->irq_count = num_irqs;\n\twork_ctx->work = IRQ_WORK_INIT_HARD(irq_sim_handle_irq);\n\n\treturn work_ctx->domain;\n\nerr_free_bitmap:\n\tbitmap_free(work_ctx->pending);\nerr_free_work_ctx:\n\tkfree(work_ctx);\nerr_out:\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL_GPL(irq_domain_create_sim);\n\n \nvoid irq_domain_remove_sim(struct irq_domain *domain)\n{\n\tstruct irq_sim_work_ctx *work_ctx = domain->host_data;\n\n\tirq_work_sync(&work_ctx->work);\n\tbitmap_free(work_ctx->pending);\n\tkfree(work_ctx);\n\n\tirq_domain_remove(domain);\n}\nEXPORT_SYMBOL_GPL(irq_domain_remove_sim);\n\nstatic void devm_irq_domain_remove_sim(void *data)\n{\n\tstruct irq_domain *domain = data;\n\n\tirq_domain_remove_sim(domain);\n}\n\n \nstruct irq_domain *devm_irq_domain_create_sim(struct device *dev,\n\t\t\t\t\t      struct fwnode_handle *fwnode,\n\t\t\t\t\t      unsigned int num_irqs)\n{\n\tstruct irq_domain *domain;\n\tint ret;\n\n\tdomain = irq_domain_create_sim(fwnode, num_irqs);\n\tif (IS_ERR(domain))\n\t\treturn domain;\n\n\tret = devm_add_action_or_reset(dev, devm_irq_domain_remove_sim, domain);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(devm_irq_domain_create_sim);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}