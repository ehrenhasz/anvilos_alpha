{
  "module_name": "generic-chip.c",
  "hash_id": "170af11134adf645838867d33af1e0a734f7ddf61b5e29bbf87f6b20a5ca21c6",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/generic-chip.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/syscore_ops.h>\n\n#include \"internals.h\"\n\nstatic LIST_HEAD(gc_list);\nstatic DEFINE_RAW_SPINLOCK(gc_lock);\n\n \nvoid irq_gc_noop(struct irq_data *d)\n{\n}\nEXPORT_SYMBOL_GPL(irq_gc_noop);\n\n \nvoid irq_gc_mask_disable_reg(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.disable);\n\t*ct->mask_cache &= ~mask;\n\tirq_gc_unlock(gc);\n}\nEXPORT_SYMBOL_GPL(irq_gc_mask_disable_reg);\n\n \nvoid irq_gc_mask_set_bit(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\t*ct->mask_cache |= mask;\n\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);\n\tirq_gc_unlock(gc);\n}\nEXPORT_SYMBOL_GPL(irq_gc_mask_set_bit);\n\n \nvoid irq_gc_mask_clr_bit(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\t*ct->mask_cache &= ~mask;\n\tirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);\n\tirq_gc_unlock(gc);\n}\nEXPORT_SYMBOL_GPL(irq_gc_mask_clr_bit);\n\n \nvoid irq_gc_unmask_enable_reg(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.enable);\n\t*ct->mask_cache |= mask;\n\tirq_gc_unlock(gc);\n}\nEXPORT_SYMBOL_GPL(irq_gc_unmask_enable_reg);\n\n \nvoid irq_gc_ack_set_bit(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.ack);\n\tirq_gc_unlock(gc);\n}\nEXPORT_SYMBOL_GPL(irq_gc_ack_set_bit);\n\n \nvoid irq_gc_ack_clr_bit(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = ~d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.ack);\n\tirq_gc_unlock(gc);\n}\n\n \nvoid irq_gc_mask_disable_and_ack_set(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.disable);\n\t*ct->mask_cache &= ~mask;\n\tirq_reg_writel(gc, mask, ct->regs.ack);\n\tirq_gc_unlock(gc);\n}\n\n \nvoid irq_gc_eoi(struct irq_data *d)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = irq_data_get_chip_type(d);\n\tu32 mask = d->mask;\n\n\tirq_gc_lock(gc);\n\tirq_reg_writel(gc, mask, ct->regs.eoi);\n\tirq_gc_unlock(gc);\n}\n\n \nint irq_gc_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tu32 mask = d->mask;\n\n\tif (!(mask & gc->wake_enabled))\n\t\treturn -EINVAL;\n\n\tirq_gc_lock(gc);\n\tif (on)\n\t\tgc->wake_active |= mask;\n\telse\n\t\tgc->wake_active &= ~mask;\n\tirq_gc_unlock(gc);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_gc_set_wake);\n\nstatic u32 irq_readl_be(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\nstatic void irq_writel_be(u32 val, void __iomem *addr)\n{\n\tiowrite32be(val, addr);\n}\n\nvoid irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,\n\t\t\t   int num_ct, unsigned int irq_base,\n\t\t\t   void __iomem *reg_base, irq_flow_handler_t handler)\n{\n\traw_spin_lock_init(&gc->lock);\n\tgc->num_ct = num_ct;\n\tgc->irq_base = irq_base;\n\tgc->reg_base = reg_base;\n\tgc->chip_types->chip.name = name;\n\tgc->chip_types->handler = handler;\n}\n\n \nstruct irq_chip_generic *\nirq_alloc_generic_chip(const char *name, int num_ct, unsigned int irq_base,\n\t\t       void __iomem *reg_base, irq_flow_handler_t handler)\n{\n\tstruct irq_chip_generic *gc;\n\n\tgc = kzalloc(struct_size(gc, chip_types, num_ct), GFP_KERNEL);\n\tif (gc) {\n\t\tirq_init_generic_chip(gc, name, num_ct, irq_base, reg_base,\n\t\t\t\t      handler);\n\t}\n\treturn gc;\n}\nEXPORT_SYMBOL_GPL(irq_alloc_generic_chip);\n\nstatic void\nirq_gc_init_mask_cache(struct irq_chip_generic *gc, enum irq_gc_flags flags)\n{\n\tstruct irq_chip_type *ct = gc->chip_types;\n\tu32 *mskptr = &gc->mask_cache, mskreg = ct->regs.mask;\n\tint i;\n\n\tfor (i = 0; i < gc->num_ct; i++) {\n\t\tif (flags & IRQ_GC_MASK_CACHE_PER_TYPE) {\n\t\t\tmskptr = &ct[i].mask_cache_priv;\n\t\t\tmskreg = ct[i].regs.mask;\n\t\t}\n\t\tct[i].mask_cache = mskptr;\n\t\tif (flags & IRQ_GC_INIT_MASK_CACHE)\n\t\t\t*mskptr = irq_reg_readl(gc, mskreg);\n\t}\n}\n\n \nint __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,\n\t\t\t\t     int num_ct, const char *name,\n\t\t\t\t     irq_flow_handler_t handler,\n\t\t\t\t     unsigned int clr, unsigned int set,\n\t\t\t\t     enum irq_gc_flags gcflags)\n{\n\tstruct irq_domain_chip_generic *dgc;\n\tstruct irq_chip_generic *gc;\n\tunsigned long flags;\n\tint numchips, i;\n\tsize_t dgc_sz;\n\tsize_t gc_sz;\n\tsize_t sz;\n\tvoid *tmp;\n\n\tif (d->gc)\n\t\treturn -EBUSY;\n\n\tnumchips = DIV_ROUND_UP(d->revmap_size, irqs_per_chip);\n\tif (!numchips)\n\t\treturn -EINVAL;\n\n\t \n\tgc_sz = struct_size(gc, chip_types, num_ct);\n\tdgc_sz = struct_size(dgc, gc, numchips);\n\tsz = dgc_sz + numchips * gc_sz;\n\n\ttmp = dgc = kzalloc(sz, GFP_KERNEL);\n\tif (!dgc)\n\t\treturn -ENOMEM;\n\tdgc->irqs_per_chip = irqs_per_chip;\n\tdgc->num_chips = numchips;\n\tdgc->irq_flags_to_set = set;\n\tdgc->irq_flags_to_clear = clr;\n\tdgc->gc_flags = gcflags;\n\td->gc = dgc;\n\n\t \n\ttmp += dgc_sz;\n\tfor (i = 0; i < numchips; i++) {\n\t\t \n\t\tdgc->gc[i] = gc = tmp;\n\t\tirq_init_generic_chip(gc, name, num_ct, i * irqs_per_chip,\n\t\t\t\t      NULL, handler);\n\n\t\tgc->domain = d;\n\t\tif (gcflags & IRQ_GC_BE_IO) {\n\t\t\tgc->reg_readl = &irq_readl_be;\n\t\t\tgc->reg_writel = &irq_writel_be;\n\t\t}\n\n\t\traw_spin_lock_irqsave(&gc_lock, flags);\n\t\tlist_add_tail(&gc->list, &gc_list);\n\t\traw_spin_unlock_irqrestore(&gc_lock, flags);\n\t\t \n\t\ttmp += gc_sz;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__irq_alloc_domain_generic_chips);\n\nstatic struct irq_chip_generic *\n__irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq)\n{\n\tstruct irq_domain_chip_generic *dgc = d->gc;\n\tint idx;\n\n\tif (!dgc)\n\t\treturn ERR_PTR(-ENODEV);\n\tidx = hw_irq / dgc->irqs_per_chip;\n\tif (idx >= dgc->num_chips)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn dgc->gc[idx];\n}\n\n \nstruct irq_chip_generic *\nirq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq)\n{\n\tstruct irq_chip_generic *gc = __irq_get_domain_generic_chip(d, hw_irq);\n\n\treturn !IS_ERR(gc) ? gc : NULL;\n}\nEXPORT_SYMBOL_GPL(irq_get_domain_generic_chip);\n\n \nstatic struct lock_class_key irq_nested_lock_class;\nstatic struct lock_class_key irq_nested_request_class;\n\n \nint irq_map_generic_chip(struct irq_domain *d, unsigned int virq,\n\t\t\t irq_hw_number_t hw_irq)\n{\n\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);\n\tstruct irq_domain_chip_generic *dgc = d->gc;\n\tstruct irq_chip_generic *gc;\n\tstruct irq_chip_type *ct;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tint idx;\n\n\tgc = __irq_get_domain_generic_chip(d, hw_irq);\n\tif (IS_ERR(gc))\n\t\treturn PTR_ERR(gc);\n\n\tidx = hw_irq % dgc->irqs_per_chip;\n\n\tif (test_bit(idx, &gc->unused))\n\t\treturn -ENOTSUPP;\n\n\tif (test_bit(idx, &gc->installed))\n\t\treturn -EBUSY;\n\n\tct = gc->chip_types;\n\tchip = &ct->chip;\n\n\t \n\tif (!gc->installed) {\n\t\traw_spin_lock_irqsave(&gc->lock, flags);\n\t\tirq_gc_init_mask_cache(gc, dgc->gc_flags);\n\t\traw_spin_unlock_irqrestore(&gc->lock, flags);\n\t}\n\n\t \n\tset_bit(idx, &gc->installed);\n\n\tif (dgc->gc_flags & IRQ_GC_INIT_NESTED_LOCK)\n\t\tirq_set_lockdep_class(virq, &irq_nested_lock_class,\n\t\t\t\t      &irq_nested_request_class);\n\n\tif (chip->irq_calc_mask)\n\t\tchip->irq_calc_mask(data);\n\telse\n\t\tdata->mask = 1 << idx;\n\n\tirq_domain_set_info(d, virq, hw_irq, chip, gc, ct->handler, NULL, NULL);\n\tirq_modify_status(virq, dgc->irq_flags_to_clear, dgc->irq_flags_to_set);\n\treturn 0;\n}\n\nvoid irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)\n{\n\tstruct irq_data *data = irq_domain_get_irq_data(d, virq);\n\tstruct irq_domain_chip_generic *dgc = d->gc;\n\tunsigned int hw_irq = data->hwirq;\n\tstruct irq_chip_generic *gc;\n\tint irq_idx;\n\n\tgc = irq_get_domain_generic_chip(d, hw_irq);\n\tif (!gc)\n\t\treturn;\n\n\tirq_idx = hw_irq % dgc->irqs_per_chip;\n\n\tclear_bit(irq_idx, &gc->installed);\n\tirq_domain_set_info(d, virq, hw_irq, &no_irq_chip, NULL, NULL, NULL,\n\t\t\t    NULL);\n\n}\n\nconst struct irq_domain_ops irq_generic_chip_ops = {\n\t.map\t= irq_map_generic_chip,\n\t.unmap  = irq_unmap_generic_chip,\n\t.xlate\t= irq_domain_xlate_onetwocell,\n};\nEXPORT_SYMBOL_GPL(irq_generic_chip_ops);\n\n \nvoid irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t    enum irq_gc_flags flags, unsigned int clr,\n\t\t\t    unsigned int set)\n{\n\tstruct irq_chip_type *ct = gc->chip_types;\n\tstruct irq_chip *chip = &ct->chip;\n\tunsigned int i;\n\n\traw_spin_lock(&gc_lock);\n\tlist_add_tail(&gc->list, &gc_list);\n\traw_spin_unlock(&gc_lock);\n\n\tirq_gc_init_mask_cache(gc, flags);\n\n\tfor (i = gc->irq_base; msk; msk >>= 1, i++) {\n\t\tif (!(msk & 0x01))\n\t\t\tcontinue;\n\n\t\tif (flags & IRQ_GC_INIT_NESTED_LOCK)\n\t\t\tirq_set_lockdep_class(i, &irq_nested_lock_class,\n\t\t\t\t\t      &irq_nested_request_class);\n\n\t\tif (!(flags & IRQ_GC_NO_MASK)) {\n\t\t\tstruct irq_data *d = irq_get_irq_data(i);\n\n\t\t\tif (chip->irq_calc_mask)\n\t\t\t\tchip->irq_calc_mask(d);\n\t\t\telse\n\t\t\t\td->mask = 1 << (i - gc->irq_base);\n\t\t}\n\t\tirq_set_chip_and_handler(i, chip, ct->handler);\n\t\tirq_set_chip_data(i, gc);\n\t\tirq_modify_status(i, clr, set);\n\t}\n\tgc->irq_cnt = i - gc->irq_base;\n}\nEXPORT_SYMBOL_GPL(irq_setup_generic_chip);\n\n \nint irq_setup_alt_chip(struct irq_data *d, unsigned int type)\n{\n\tstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\n\tstruct irq_chip_type *ct = gc->chip_types;\n\tunsigned int i;\n\n\tfor (i = 0; i < gc->num_ct; i++, ct++) {\n\t\tif (ct->type & type) {\n\t\t\td->chip = &ct->chip;\n\t\t\tirq_data_to_desc(d)->handle_irq = ct->handler;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(irq_setup_alt_chip);\n\n \nvoid irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,\n\t\t\t     unsigned int clr, unsigned int set)\n{\n\tunsigned int i, virq;\n\n\traw_spin_lock(&gc_lock);\n\tlist_del(&gc->list);\n\traw_spin_unlock(&gc_lock);\n\n\tfor (i = 0; msk; msk >>= 1, i++) {\n\t\tif (!(msk & 0x01))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (gc->domain) {\n\t\t\tvirq = irq_find_mapping(gc->domain, gc->irq_base + i);\n\t\t\tif (!virq)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tvirq = gc->irq_base + i;\n\t\t}\n\n\t\t \n\t\tirq_set_handler(virq, NULL);\n\t\tirq_set_chip(virq, &no_irq_chip);\n\t\tirq_set_chip_data(virq, NULL);\n\t\tirq_modify_status(virq, clr, set);\n\t}\n}\nEXPORT_SYMBOL_GPL(irq_remove_generic_chip);\n\nstatic struct irq_data *irq_gc_get_irq_data(struct irq_chip_generic *gc)\n{\n\tunsigned int virq;\n\n\tif (!gc->domain)\n\t\treturn irq_get_irq_data(gc->irq_base);\n\n\t \n\tif (!gc->installed)\n\t\treturn NULL;\n\n\tvirq = irq_find_mapping(gc->domain, gc->irq_base + __ffs(gc->installed));\n\treturn virq ? irq_get_irq_data(virq) : NULL;\n}\n\n#ifdef CONFIG_PM\nstatic int irq_gc_suspend(void)\n{\n\tstruct irq_chip_generic *gc;\n\n\tlist_for_each_entry(gc, &gc_list, list) {\n\t\tstruct irq_chip_type *ct = gc->chip_types;\n\n\t\tif (ct->chip.irq_suspend) {\n\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);\n\n\t\t\tif (data)\n\t\t\t\tct->chip.irq_suspend(data);\n\t\t}\n\n\t\tif (gc->suspend)\n\t\t\tgc->suspend(gc);\n\t}\n\treturn 0;\n}\n\nstatic void irq_gc_resume(void)\n{\n\tstruct irq_chip_generic *gc;\n\n\tlist_for_each_entry(gc, &gc_list, list) {\n\t\tstruct irq_chip_type *ct = gc->chip_types;\n\n\t\tif (gc->resume)\n\t\t\tgc->resume(gc);\n\n\t\tif (ct->chip.irq_resume) {\n\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);\n\n\t\t\tif (data)\n\t\t\t\tct->chip.irq_resume(data);\n\t\t}\n\t}\n}\n#else\n#define irq_gc_suspend NULL\n#define irq_gc_resume NULL\n#endif\n\nstatic void irq_gc_shutdown(void)\n{\n\tstruct irq_chip_generic *gc;\n\n\tlist_for_each_entry(gc, &gc_list, list) {\n\t\tstruct irq_chip_type *ct = gc->chip_types;\n\n\t\tif (ct->chip.irq_pm_shutdown) {\n\t\t\tstruct irq_data *data = irq_gc_get_irq_data(gc);\n\n\t\t\tif (data)\n\t\t\t\tct->chip.irq_pm_shutdown(data);\n\t\t}\n\t}\n}\n\nstatic struct syscore_ops irq_gc_syscore_ops = {\n\t.suspend = irq_gc_suspend,\n\t.resume = irq_gc_resume,\n\t.shutdown = irq_gc_shutdown,\n};\n\nstatic int __init irq_gc_init_ops(void)\n{\n\tregister_syscore_ops(&irq_gc_syscore_ops);\n\treturn 0;\n}\ndevice_initcall(irq_gc_init_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}