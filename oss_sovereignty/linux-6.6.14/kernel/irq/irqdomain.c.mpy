{
  "module_name": "irqdomain.c",
  "hash_id": "c2dba5d33c9d415287ff0659eb09dd4c83395306cac3710dca9cd2da8f0b6ecf",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/irqdomain.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt)  \"irq: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/hardirq.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdesc.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/topology.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/fs.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\n\nstatic struct irq_domain *irq_default_domain;\n\nstatic int irq_domain_alloc_irqs_locked(struct irq_domain *domain, int irq_base,\n\t\t\t\t\tunsigned int nr_irqs, int node, void *arg,\n\t\t\t\t\tbool realloc, const struct irq_affinity_desc *affinity);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irqchip_fwid {\n\tstruct fwnode_handle\tfwnode;\n\tunsigned int\t\ttype;\n\tchar\t\t\t*name;\n\tphys_addr_t\t\t*pa;\n};\n\n#ifdef CONFIG_GENERIC_IRQ_DEBUGFS\nstatic void debugfs_add_domain_dir(struct irq_domain *d);\nstatic void debugfs_remove_domain_dir(struct irq_domain *d);\n#else\nstatic inline void debugfs_add_domain_dir(struct irq_domain *d) { }\nstatic inline void debugfs_remove_domain_dir(struct irq_domain *d) { }\n#endif\n\nstatic const char *irqchip_fwnode_get_name(const struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\treturn fwid->name;\n}\n\nconst struct fwnode_operations irqchip_fwnode_ops = {\n\t.get_name = irqchip_fwnode_get_name,\n};\nEXPORT_SYMBOL_GPL(irqchip_fwnode_ops);\n\n \nstruct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tphys_addr_t *pa)\n{\n\tstruct irqchip_fwid *fwid;\n\tchar *n;\n\n\tfwid = kzalloc(sizeof(*fwid), GFP_KERNEL);\n\n\tswitch (type) {\n\tcase IRQCHIP_FWNODE_NAMED:\n\t\tn = kasprintf(GFP_KERNEL, \"%s\", name);\n\t\tbreak;\n\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\tn = kasprintf(GFP_KERNEL, \"%s-%d\", name, id);\n\t\tbreak;\n\tdefault:\n\t\tn = kasprintf(GFP_KERNEL, \"irqchip@%pa\", pa);\n\t\tbreak;\n\t}\n\n\tif (!fwid || !n) {\n\t\tkfree(fwid);\n\t\tkfree(n);\n\t\treturn NULL;\n\t}\n\n\tfwid->type = type;\n\tfwid->name = n;\n\tfwid->pa = pa;\n\tfwnode_init(&fwid->fwnode, &irqchip_fwnode_ops);\n\treturn &fwid->fwnode;\n}\nEXPORT_SYMBOL_GPL(__irq_domain_alloc_fwnode);\n\n \nvoid irq_domain_free_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid;\n\n\tif (!fwnode || WARN_ON(!is_fwnode_irqchip(fwnode)))\n\t\treturn;\n\n\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\tkfree(fwid->name);\n\tkfree(fwid);\n}\nEXPORT_SYMBOL_GPL(irq_domain_free_fwnode);\n\nstatic struct irq_domain *__irq_domain_create(struct fwnode_handle *fwnode,\n\t\t\t\t\t      unsigned int size,\n\t\t\t\t\t      irq_hw_number_t hwirq_max,\n\t\t\t\t\t      int direct_max,\n\t\t\t\t\t      const struct irq_domain_ops *ops,\n\t\t\t\t\t      void *host_data)\n{\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tif (WARN_ON((size && direct_max) ||\n\t\t    (!IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) && direct_max) ||\n\t\t    (direct_max && (direct_max != hwirq_max))))\n\t\treturn NULL;\n\n\tdomain = kzalloc_node(struct_size(domain, revmap, size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(to_of_node(fwnode)));\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n\t} else if (is_of_node(fwnode) || is_acpi_device_node(fwnode) ||\n\t\t   is_software_node(fwnode)) {\n\t\tchar *name;\n\n\t\t \n\t\tname = kasprintf(GFP_KERNEL, \"%pfw\", fwnode);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdomain->name = strreplace(name, '/', ':');\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tfwnode_handle_get(fwnode);\n\tfwnode_dev_initialized(fwnode, true);\n\n\t \n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\n\tif (direct_max)\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_NO_MAP;\n\n\tdomain->revmap_size = size;\n\n\t \n\tmutex_init(&domain->mutex);\n\tdomain->root = domain;\n\n\tirq_domain_check_hierarchy(domain);\n\n\treturn domain;\n}\n\nstatic void __irq_domain_publish(struct irq_domain *domain)\n{\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n}\n\n \nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, unsigned int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_create(fwnode, size, hwirq_max, direct_max,\n\t\t\t\t     ops, host_data);\n\tif (domain)\n\t\t__irq_domain_publish(domain);\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(__irq_domain_add);\n\n \nvoid irq_domain_remove(struct irq_domain *domain)\n{\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_remove_domain_dir(domain);\n\n\tWARN_ON(!radix_tree_empty(&domain->revmap_tree));\n\n\tlist_del(&domain->link);\n\n\t \n\tif (unlikely(irq_default_domain == domain))\n\t\tirq_set_default_host(NULL);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Removed domain %s\\n\", domain->name);\n\n\tfwnode_dev_initialized(domain->fwnode, false);\n\tfwnode_handle_put(domain->fwnode);\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\tkfree(domain);\n}\nEXPORT_SYMBOL_GPL(irq_domain_remove);\n\nvoid irq_domain_update_bus_token(struct irq_domain *domain,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tchar *name;\n\n\tif (domain->bus_token == bus_token)\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\tdomain->bus_token = bus_token;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%d\", domain->name, bus_token);\n\tif (!name) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\treturn;\n\t}\n\n\tdebugfs_remove_domain_dir(domain);\n\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\telse\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\n\tdomain->name = name;\n\tdebugfs_add_domain_dir(domain);\n\n\tmutex_unlock(&irq_domain_mutex);\n}\nEXPORT_SYMBOL_GPL(irq_domain_update_bus_token);\n\n \nstruct irq_domain *irq_domain_create_simple(struct fwnode_handle *fwnode,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    unsigned int first_irq,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, size, size, 0, ops, host_data);\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (first_irq > 0) {\n\t\tif (IS_ENABLED(CONFIG_SPARSE_IRQ)) {\n\t\t\t \n\t\t\tint rc = irq_alloc_descs(first_irq, first_irq, size,\n\t\t\t\t\t\t of_node_to_nid(to_of_node(fwnode)));\n\t\t\tif (rc < 0)\n\t\t\t\tpr_info(\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(irq_domain_create_simple);\n\n \nstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\treturn irq_domain_create_legacy(of_node_to_fwnode(of_node), size,\n\t\t\t\t\tfirst_irq, first_hwirq, ops, host_data);\n}\nEXPORT_SYMBOL_GPL(irq_domain_add_legacy);\n\nstruct irq_domain *irq_domain_create_legacy(struct fwnode_handle *fwnode,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(fwnode, first_hwirq + size, first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(irq_domain_create_legacy);\n\n \nstruct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t \n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}\nEXPORT_SYMBOL_GPL(irq_find_matching_fwspec);\n\n \nvoid irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}\nEXPORT_SYMBOL_GPL(irq_set_default_host);\n\n \nstruct irq_domain *irq_get_default_host(void)\n{\n\treturn irq_default_domain;\n}\nEXPORT_SYMBOL_GPL(irq_get_default_host);\n\nstatic bool irq_domain_is_nomap(struct irq_domain *domain)\n{\n\treturn IS_ENABLED(CONFIG_IRQ_DOMAIN_NOMAP) &&\n\t       (domain->flags & IRQ_DOMAIN_FLAG_NO_MAP);\n}\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tlockdep_assert_held(&domain->root->mutex);\n\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], NULL);\n\telse\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n}\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\t \n\tlockdep_assert_held(&domain->root->mutex);\n\n\tif (irq_domain_is_nomap(domain))\n\t\treturn;\n\n\tif (hwirq < domain->revmap_size)\n\t\trcu_assign_pointer(domain->revmap[hwirq], irq_data);\n\telse\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n}\n\nstatic void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\n\tmutex_lock(&domain->root->mutex);\n\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t \n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t \n\tsynchronize_irq(irq);\n\n\t \n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t \n\tirq_domain_clear_mapping(domain, hwirq);\n\n\tmutex_unlock(&domain->root->mutex);\n}\n\nstatic int irq_domain_associate_locked(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t       irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t \n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tint ret;\n\n\tmutex_lock(&domain->root->mutex);\n\tret = irq_domain_associate_locked(domain, virq, hwirq);\n\tmutex_unlock(&domain->root->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(irq_domain_associate);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++)\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n}\nEXPORT_SYMBOL_GPL(irq_domain_associate_many);\n\n#ifdef CONFIG_IRQ_DOMAIN_NOMAP\n \nunsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tstruct device_node *of_node;\n\tunsigned int virq;\n\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(of_node));\n\tif (!virq) {\n\t\tpr_debug(\"create_direct virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\tif (virq >= domain->hwirq_max) {\n\t\tpr_err(\"ERROR: no free irqs available below %lu maximum\\n\",\n\t\t\tdomain->hwirq_max);\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"create_direct obtained virq %d\\n\", virq);\n\n\tif (irq_domain_associate(domain, virq, virq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\treturn virq;\n}\nEXPORT_SYMBOL_GPL(irq_create_direct_mapping);\n#endif\n\nstatic unsigned int irq_create_mapping_affinity_locked(struct irq_domain *domain,\n\t\t\t\t\t\t       irq_hw_number_t hwirq,\n\t\t\t\t\t\t       const struct irq_affinity_desc *affinity)\n{\n\tstruct device_node *of_node = irq_domain_get_of_node(domain);\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t \n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node),\n\t\t\t\t      affinity);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate_locked(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}\n\n \nunsigned int irq_create_mapping_affinity(struct irq_domain *domain,\n\t\t\t\t\t irq_hw_number_t hwirq,\n\t\t\t\t\t const struct irq_affinity_desc *affinity)\n{\n\tint virq;\n\n\t \n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&domain->root->mutex);\n\n\t \n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"existing mapping on virq %d\\n\", virq);\n\t\tgoto out;\n\t}\n\n\tvirq = irq_create_mapping_affinity_locked(domain, hwirq, affinity);\nout:\n\tmutex_unlock(&domain->root->mutex);\n\n\treturn virq;\n}\nEXPORT_SYMBOL_GPL(irq_create_mapping_affinity);\n\nstatic int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t \n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}\n\nvoid of_phandle_args_to_fwspec(struct device_node *np, const u32 *args,\n\t\t\t       unsigned int count, struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = of_node_to_fwnode(np);\n\tfwspec->param_count = count;\n\n\tfor (i = 0; i < count; i++)\n\t\tfwspec->param[i] = args[i];\n}\nEXPORT_SYMBOL_GPL(of_phandle_args_to_fwspec);\n\nunsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t \n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\tmutex_lock(&domain->root->mutex);\n\n\t \n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t \n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data) {\n\t\t\t\tvirq = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\tvirq = 0;\n\t\tgoto out;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs_locked(domain, -1, 1, NUMA_NO_NODE,\n\t\t\t\t\t\t    fwspec, false, NULL);\n\t\tif (virq <= 0) {\n\t\t\tvirq = 0;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tvirq = irq_create_mapping_affinity_locked(domain, hwirq, NULL);\n\t\tif (!virq)\n\t\t\tgoto out;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (WARN_ON(!irq_data)) {\n\t\tvirq = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tirqd_set_trigger_type(irq_data, type);\nout:\n\tmutex_unlock(&domain->root->mutex);\n\n\treturn virq;\n}\nEXPORT_SYMBOL_GPL(irq_create_fwspec_mapping);\n\nunsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(irq_data->np, irq_data->args,\n\t\t\t\t  irq_data->args_count, &fwspec);\n\n\treturn irq_create_fwspec_mapping(&fwspec);\n}\nEXPORT_SYMBOL_GPL(irq_create_of_mapping);\n\n \nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}\nEXPORT_SYMBOL_GPL(irq_dispose_mapping);\n\n \nstruct irq_desc *__irq_resolve_mapping(struct irq_domain *domain,\n\t\t\t\t       irq_hw_number_t hwirq,\n\t\t\t\t       unsigned int *irq)\n{\n\tstruct irq_desc *desc = NULL;\n\tstruct irq_data *data;\n\n\t \n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn desc;\n\n\tif (irq_domain_is_nomap(domain)) {\n\t\tif (hwirq < domain->hwirq_max) {\n\t\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\t\tif (data && data->hwirq == hwirq)\n\t\t\t\tdesc = irq_data_to_desc(data);\n\t\t\tif (irq && desc)\n\t\t\t\t*irq = hwirq;\n\t\t}\n\n\t\treturn desc;\n\t}\n\n\trcu_read_lock();\n\t \n\tif (hwirq < domain->revmap_size)\n\t\tdata = rcu_dereference(domain->revmap[hwirq]);\n\telse\n\t\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\n\tif (likely(data)) {\n\t\tdesc = irq_data_to_desc(data);\n\t\tif (irq)\n\t\t\t*irq = data->irq;\n\t}\n\n\trcu_read_unlock();\n\treturn desc;\n}\nEXPORT_SYMBOL_GPL(__irq_resolve_mapping);\n\n \nint irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_xlate_onecell);\n\n \nint irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(ctrlr, intspec, intsize, &fwspec);\n\treturn irq_domain_translate_twocell(d, &fwspec, out_hwirq, out_type);\n}\nEXPORT_SYMBOL_GPL(irq_domain_xlate_twocell);\n\n \nint irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_xlate_onetwocell);\n\nconst struct irq_domain_ops irq_domain_simple_ops = {\n\t.xlate = irq_domain_xlate_onetwocell,\n};\nEXPORT_SYMBOL_GPL(irq_domain_simple_ops);\n\n \nint irq_domain_translate_onecell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_translate_onecell);\n\n \nint irq_domain_translate_twocell(struct irq_domain *d,\n\t\t\t\t struct irq_fwspec *fwspec,\n\t\t\t\t unsigned long *out_hwirq,\n\t\t\t\t unsigned int *out_type)\n{\n\tif (WARN_ON(fwspec->param_count < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = fwspec->param[0];\n\t*out_type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_translate_twocell);\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct irq_affinity_desc *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}\n\n \nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}\nEXPORT_SYMBOL_GPL(irq_domain_reset_irq_data);\n\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n \nstruct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = __irq_domain_create(fwnode, size, size, 0, ops, host_data);\n\telse\n\t\tdomain = __irq_domain_create(fwnode, 0, ~0, 0, ops, host_data);\n\n\tif (domain) {\n\t\tif (parent)\n\t\t\tdomain->root = parent->root;\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\n\t\t__irq_domain_publish(domain);\n\t}\n\n\treturn domain;\n}\nEXPORT_SYMBOL_GPL(irq_domain_create_hierarchy);\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}\n\nstatic void __irq_domain_free_hierarchy(struct irq_data *irq_data)\n{\n\tstruct irq_data *tmp;\n\n\twhile (irq_data) {\n\t\ttmp = irq_data;\n\t\tirq_data = irq_data->parent_data;\n\t\tkfree(tmp);\n\t}\n}\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\t__irq_domain_free_hierarchy(tmp);\n\t}\n}\n\n \nint irq_domain_disconnect_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int virq)\n{\n\tstruct irq_data *irqd;\n\n\tirqd = irq_domain_get_irq_data(domain, virq);\n\tif (!irqd)\n\t\treturn -EINVAL;\n\n\tirqd->chip = ERR_PTR(-ENOTCONN);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_disconnect_hierarchy);\n\nstatic int irq_domain_trim_hierarchy(unsigned int virq)\n{\n\tstruct irq_data *tail, *irqd, *irq_data;\n\n\tirq_data = irq_get_irq_data(virq);\n\ttail = NULL;\n\n\t \n\tif (!irq_data->chip || IS_ERR(irq_data->chip))\n\t\treturn -EINVAL;\n\n\t \n\tfor (irqd = irq_data->parent_data; irqd; irq_data = irqd, irqd = irqd->parent_data) {\n\t\t \n\t\tif (irqd->chip && tail)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!irqd->chip && !tail)\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_ERR(irqd->chip)) {\n\t\t\t \n\t\t\tif (PTR_ERR(irqd->chip) != -ENOTCONN)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttail = irq_data;\n\t\t}\n\t}\n\n\t \n\tif (!tail)\n\t\treturn 0;\n\n\tpr_info(\"IRQ%d: trimming hierarchy from %s\\n\",\n\t\tvirq, tail->parent_data->domain->name);\n\n\t \n\tirqd = tail;\n\ttail = tail->parent_data;\n\tirqd->parent_data = NULL;\n\t__irq_domain_free_hierarchy(tail);\n\n\treturn 0;\n}\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t \n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(irq_domain_get_irq_data);\n\n \nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq,\n\t\t\t\t  const struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = (struct irq_chip *)(chip ? chip : &no_irq_chip);\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_set_hwirq_and_chip);\n\n \nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, const struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}\nEXPORT_SYMBOL(irq_domain_set_info);\n\n \nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\nEXPORT_SYMBOL_GPL(irq_domain_free_irqs_common);\n\n \nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tunsigned int i;\n\n\tif (!domain->ops->free)\n\t\treturn;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tif (irq_domain_get_irq_data(domain, irq_base + i))\n\t\t\tdomain->ops->free(domain, irq_base + i, 1);\n\t}\n}\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}\n\nstatic int irq_domain_alloc_irqs_locked(struct irq_domain *domain, int irq_base,\n\t\t\t\t\tunsigned int nr_irqs, int node, void *arg,\n\t\t\t\t\tbool realloc, const struct irq_affinity_desc *affinity)\n{\n\tint i, ret, virq;\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\tgoto out_free_irq_data;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = irq_domain_trim_hierarchy(virq + i);\n\t\tif (ret)\n\t\t\tgoto out_free_irq_data;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}\n\n \nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct irq_affinity_desc *affinity)\n{\n\tint ret;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&domain->root->mutex);\n\tret = irq_domain_alloc_irqs_locked(domain, irq_base, nr_irqs, node, arg,\n\t\t\t\t\t   realloc, affinity);\n\tmutex_unlock(&domain->root->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__irq_domain_alloc_irqs);\n\n \nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tlockdep_assert_held(&d->domain->root->mutex);\n\n\tif (irq_domain_is_nomap(d->domain))\n\t\treturn;\n\n\t \n\tif (d->hwirq < d->domain->revmap_size) {\n\t\t \n\t\trcu_assign_pointer(d->domain->revmap[d->hwirq], d);\n\t} else {\n\t\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\t\tif (slot)\n\t\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\t}\n}\n\n \nint irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_data *parent_irq_data;\n\tstruct irq_desc *desc;\n\tint rv = 0;\n\n\t \n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!irq_domain_is_hierarchy(domain)))\n\t\treturn -EINVAL;\n\n\tif (!irq_data)\n\t\treturn -EINVAL;\n\n\tif (domain->parent != irq_data->domain)\n\t\treturn -EINVAL;\n\n\tparent_irq_data = kzalloc_node(sizeof(*parent_irq_data), GFP_KERNEL,\n\t\t\t\t       irq_data_get_node(irq_data));\n\tif (!parent_irq_data)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&domain->root->mutex);\n\n\t \n\t*parent_irq_data = *irq_data;\n\n\t \n\tirq_data->parent_data = parent_irq_data;\n\tirq_data->domain = domain;\n\tirq_data->mask = 0;\n\tirq_data->hwirq = 0;\n\tirq_data->chip = NULL;\n\tirq_data->chip_data = NULL;\n\n\t \n\trv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);\n\tif (rv) {\n\t\t \n\t\t*irq_data = *parent_irq_data;\n\t\tkfree(parent_irq_data);\n\t\tgoto error;\n\t}\n\n\tirq_domain_fix_revmap(parent_irq_data);\n\tirq_domain_set_mapping(domain, irq_data->hwirq, irq_data);\nerror:\n\tmutex_unlock(&domain->root->mutex);\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(irq_domain_push_irq);\n\n \nint irq_domain_pop_irq(struct irq_domain *domain, int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_data *parent_irq_data;\n\tstruct irq_data *tmp_irq_data;\n\tstruct irq_desc *desc;\n\n\t \n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (!irq_data)\n\t\treturn -EINVAL;\n\n\ttmp_irq_data = irq_domain_get_irq_data(domain, virq);\n\n\t \n\tif (WARN_ON(irq_data != tmp_irq_data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(irq_data->domain != domain))\n\t\treturn -EINVAL;\n\n\tparent_irq_data = irq_data->parent_data;\n\tif (WARN_ON(!parent_irq_data))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&domain->root->mutex);\n\n\tirq_data->parent_data = NULL;\n\n\tirq_domain_clear_mapping(domain, irq_data->hwirq);\n\tirq_domain_free_irqs_hierarchy(domain, virq, 1);\n\n\t \n\t*irq_data = *parent_irq_data;\n\n\tirq_domain_fix_revmap(irq_data);\n\n\tmutex_unlock(&domain->root->mutex);\n\n\tkfree(parent_irq_data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_domain_pop_irq);\n\n \nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tdomain = data->domain;\n\n\tmutex_lock(&domain->root->mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(domain, virq, nr_irqs);\n\tmutex_unlock(&domain->root->mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}\n\n \nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}\nEXPORT_SYMBOL_GPL(irq_domain_alloc_irqs_parent);\n\n \nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}\nEXPORT_SYMBOL_GPL(irq_domain_free_irqs_parent);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}\n\nstatic int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t \n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint irq_domain_activate_irq(struct irq_data *irq_data, bool reserve)\n{\n\tint ret = 0;\n\n\tif (!irqd_is_activated(irq_data))\n\t\tret = __irq_domain_activate_irq(irq_data, reserve);\n\tif (!ret)\n\t\tirqd_set_activated(irq_data);\n\treturn ret;\n}\n\n \nvoid irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irqd_is_activated(irq_data)) {\n\t\t__irq_domain_deactivate_irq(irq_data);\n\t\tirqd_clr_activated(irq_data);\n\t}\n}\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t \n\tif (domain->ops->alloc)\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;\n}\n#else\t \n \nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}\nEXPORT_SYMBOL_GPL(irq_domain_get_irq_data);\n\n \nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, const struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_set_chip_and_handler_name(virq, chip, handler, handler_name);\n\tirq_set_chip_data(virq, chip_data);\n\tirq_set_handler_data(virq, handler_data);\n}\n\nstatic int irq_domain_alloc_irqs_locked(struct irq_domain *domain, int irq_base,\n\t\t\t\t\tunsigned int nr_irqs, int node, void *arg,\n\t\t\t\t\tbool realloc, const struct irq_affinity_desc *affinity)\n{\n\treturn -EINVAL;\n}\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}\n#endif\t \n\n#ifdef CONFIG_GENERIC_IRQ_DEBUGFS\n#include \"internals.h\"\n\nstatic struct dentry *domain_dir;\n\nstatic void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\", d->revmap_size);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}\n\nstatic int irq_domain_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_domain *d = m->private;\n\n\t \n\tif (!d) {\n\t\tif (!irq_default_domain)\n\t\t\treturn 0;\n\t\td = irq_default_domain;\n\t}\n\tirq_domain_debug_show_one(m, d, 0);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(irq_domain_debug);\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir)\n\t\treturn;\n\tdebugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t    &irq_domain_debug_fops);\n}\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_lookup_and_remove(d->name, domain_dir);\n}\n\nvoid __init irq_domain_debugfs_init(struct dentry *root)\n{\n\tstruct irq_domain *d;\n\n\tdomain_dir = debugfs_create_dir(\"domains\", root);\n\n\tdebugfs_create_file(\"default\", 0444, domain_dir, NULL,\n\t\t\t    &irq_domain_debug_fops);\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(d, &irq_domain_list, link)\n\t\tdebugfs_add_domain_dir(d);\n\tmutex_unlock(&irq_domain_mutex);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}