{
  "module_name": "internals.h",
  "hash_id": "8c3e86378432915f54d9b5564fbe59a15dfb7d12e64bb784e1abacb4bc550cc1",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/internals.h",
  "human_readable_source": " \n \n#include <linux/irqdesc.h>\n#include <linux/kernel_stat.h>\n#include <linux/pm_runtime.h>\n#include <linux/sched/clock.h>\n\n#ifdef CONFIG_SPARSE_IRQ\n# define MAX_SPARSE_IRQS\tINT_MAX\n#else\n# define MAX_SPARSE_IRQS\tNR_IRQS\n#endif\n\n#define istate core_internal_state__do_not_mess_with_it\n\nextern bool noirqdebug;\n\nextern struct irqaction chained_action;\n\n \nenum {\n\tIRQTF_RUNTHREAD,\n\tIRQTF_WARNED,\n\tIRQTF_AFFINITY,\n\tIRQTF_FORCED_THREAD,\n\tIRQTF_READY,\n};\n\n \nenum {\n\tIRQS_AUTODETECT\t\t= 0x00000001,\n\tIRQS_SPURIOUS_DISABLED\t= 0x00000002,\n\tIRQS_POLL_INPROGRESS\t= 0x00000008,\n\tIRQS_ONESHOT\t\t= 0x00000020,\n\tIRQS_REPLAY\t\t= 0x00000040,\n\tIRQS_WAITING\t\t= 0x00000080,\n\tIRQS_PENDING\t\t= 0x00000200,\n\tIRQS_SUSPENDED\t\t= 0x00000800,\n\tIRQS_TIMINGS\t\t= 0x00001000,\n\tIRQS_NMI\t\t= 0x00002000,\n\tIRQS_SYSFS\t\t= 0x00004000,\n};\n\n#include \"debug.h\"\n#include \"settings.h\"\n\nextern int __irq_set_trigger(struct irq_desc *desc, unsigned long flags);\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\n\n#define IRQ_RESEND\ttrue\n#define IRQ_NORESEND\tfalse\n\n#define IRQ_START_FORCE\ttrue\n#define IRQ_START_COND\tfalse\n\nextern int irq_activate(struct irq_desc *desc);\nextern int irq_activate_and_startup(struct irq_desc *desc, bool resend);\nextern int irq_startup(struct irq_desc *desc, bool resend, bool force);\n\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void irq_percpu_enable(struct irq_desc *desc, unsigned int cpu);\nextern void irq_percpu_disable(struct irq_desc *desc, unsigned int cpu);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\n\n#ifdef CONFIG_SPARSE_IRQ\nstatic inline void irq_mark_irq(unsigned int irq) { }\n#else\nextern void irq_mark_irq(unsigned int irq);\n#endif\n\nextern int __irq_get_irqchip_state(struct irq_data *data,\n\t\t\t\t   enum irqchip_irq_state which,\n\t\t\t\t   bool *state);\n\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\n\n \nint check_irq_resend(struct irq_desc *desc, bool inject);\nvoid clear_irq_resend(struct irq_desc *desc);\nvoid irq_resend_init(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\n\nvoid wake_threads_waitq(struct irq_desc *desc);\n\n#ifdef CONFIG_PROC_FS\nextern void register_irq_proc(unsigned int irq, struct irq_desc *desc);\nextern void unregister_irq_proc(unsigned int irq, struct irq_desc *desc);\nextern void register_handler_proc(unsigned int irq, struct irqaction *action);\nextern void unregister_handler_proc(unsigned int irq, struct irqaction *action);\n#else\nstatic inline void register_irq_proc(unsigned int irq, struct irq_desc *desc) { }\nstatic inline void unregister_irq_proc(unsigned int irq, struct irq_desc *desc) { }\nstatic inline void register_handler_proc(unsigned int irq,\n\t\t\t\t\t struct irqaction *action) { }\nstatic inline void unregister_handler_proc(unsigned int irq,\n\t\t\t\t\t   struct irqaction *action) { }\n#endif\n\nextern bool irq_can_set_affinity_usr(unsigned int irq);\n\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nextern int irq_do_set_affinity(struct irq_data *data,\n\t\t\t       const struct cpumask *dest, bool force);\n\n#ifdef CONFIG_SMP\nextern int irq_setup_affinity(struct irq_desc *desc);\n#else\nstatic inline int irq_setup_affinity(struct irq_desc *desc) { return 0; }\n#endif\n\n \nstatic inline void chip_bus_lock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_lock))\n\t\tdesc->irq_data.chip->irq_bus_lock(&desc->irq_data);\n}\n\nstatic inline void chip_bus_sync_unlock(struct irq_desc *desc)\n{\n\tif (unlikely(desc->irq_data.chip->irq_bus_sync_unlock))\n\t\tdesc->irq_data.chip->irq_bus_sync_unlock(&desc->irq_data);\n}\n\n#define _IRQ_DESC_CHECK\t\t(1 << 0)\n#define _IRQ_DESC_PERCPU\t(1 << 1)\n\n#define IRQ_GET_DESC_CHECK_GLOBAL\t(_IRQ_DESC_CHECK)\n#define IRQ_GET_DESC_CHECK_PERCPU\t(_IRQ_DESC_CHECK | _IRQ_DESC_PERCPU)\n\n#define for_each_action_of_desc(desc, act)\t\t\t\\\n\tfor (act = desc->action; act; act = act->next)\n\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\nvoid __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}\n\n#define __irqd_to_state(d) ACCESS_PRIVATE((d)->common, state_use_accessors)\n\nstatic inline unsigned int irqd_get(struct irq_data *d)\n{\n\treturn __irqd_to_state(d);\n}\n\n \nstatic inline void irqd_set_move_pending(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_SETAFFINITY_PENDING;\n}\n\nstatic inline void irqd_clr_move_pending(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_SETAFFINITY_PENDING;\n}\n\nstatic inline void irqd_set_managed_shutdown(struct irq_data *d)\n{\n\t__irqd_to_state(d) |= IRQD_MANAGED_SHUTDOWN;\n}\n\nstatic inline void irqd_clr_managed_shutdown(struct irq_data *d)\n{\n\t__irqd_to_state(d) &= ~IRQD_MANAGED_SHUTDOWN;\n}\n\nstatic inline void irqd_clear(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) &= ~mask;\n}\n\nstatic inline void irqd_set(struct irq_data *d, unsigned int mask)\n{\n\t__irqd_to_state(d) |= mask;\n}\n\nstatic inline bool irqd_has_set(struct irq_data *d, unsigned int mask)\n{\n\treturn __irqd_to_state(d) & mask;\n}\n\nstatic inline void irq_state_set_disabled(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_DISABLED);\n}\n\nstatic inline void irq_state_set_masked(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_MASKED);\n}\n\n#undef __irqd_to_state\n\nstatic inline void __kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__this_cpu_inc(*desc->kstat_irqs);\n\t__this_cpu_inc(kstat.irqs_sum);\n}\n\nstatic inline void kstat_incr_irqs_this_cpu(struct irq_desc *desc)\n{\n\t__kstat_incr_irqs_this_cpu(desc);\n\tdesc->tot_count++;\n}\n\nstatic inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}\n\nstatic inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}\n\n#ifdef CONFIG_PM_SLEEP\nbool irq_pm_check_wakeup(struct irq_desc *desc);\nvoid irq_pm_install_action(struct irq_desc *desc, struct irqaction *action);\nvoid irq_pm_remove_action(struct irq_desc *desc, struct irqaction *action);\n#else\nstatic inline bool irq_pm_check_wakeup(struct irq_desc *desc) { return false; }\nstatic inline void\nirq_pm_install_action(struct irq_desc *desc, struct irqaction *action) { }\nstatic inline void\nirq_pm_remove_action(struct irq_desc *desc, struct irqaction *action) { }\n#endif\n\n#ifdef CONFIG_IRQ_TIMINGS\n\n#define IRQ_TIMINGS_SHIFT\t5\n#define IRQ_TIMINGS_SIZE\t(1 << IRQ_TIMINGS_SHIFT)\n#define IRQ_TIMINGS_MASK\t(IRQ_TIMINGS_SIZE - 1)\n\n \nstruct irq_timings {\n\tu64\tvalues[IRQ_TIMINGS_SIZE];\n\tint\tcount;\n};\n\nDECLARE_PER_CPU(struct irq_timings, irq_timings);\n\nextern void irq_timings_free(int irq);\nextern int irq_timings_alloc(int irq);\n\nstatic inline void irq_remove_timings(struct irq_desc *desc)\n{\n\tdesc->istate &= ~IRQS_TIMINGS;\n\n\tirq_timings_free(irq_desc_get_irq(desc));\n}\n\nstatic inline void irq_setup_timings(struct irq_desc *desc, struct irqaction *act)\n{\n\tint irq = irq_desc_get_irq(desc);\n\tint ret;\n\n\t \n\tif (act->flags & __IRQF_TIMER)\n\t\treturn;\n\n\t \n\tret = irq_timings_alloc(irq);\n\tif (ret) {\n\t\tpr_warn(\"Failed to allocate irq timing stats for irq%d (%d)\",\n\t\t\tirq, ret);\n\t\treturn;\n\t}\n\n\tdesc->istate |= IRQS_TIMINGS;\n}\n\nextern void irq_timings_enable(void);\nextern void irq_timings_disable(void);\n\nDECLARE_STATIC_KEY_FALSE(irq_timing_enabled);\n\n \nstatic inline u64 irq_timing_encode(u64 timestamp, int irq)\n{\n\treturn (timestamp << 16) | irq;\n}\n\nstatic inline int irq_timing_decode(u64 value, u64 *timestamp)\n{\n\t*timestamp = value >> 16;\n\treturn value & U16_MAX;\n}\n\nstatic __always_inline void irq_timings_push(u64 ts, int irq)\n{\n\tstruct irq_timings *timings = this_cpu_ptr(&irq_timings);\n\n\ttimings->values[timings->count & IRQ_TIMINGS_MASK] =\n\t\tirq_timing_encode(ts, irq);\n\n\ttimings->count++;\n}\n\n \nstatic __always_inline void record_irq_time(struct irq_desc *desc)\n{\n\tif (!static_branch_likely(&irq_timing_enabled))\n\t\treturn;\n\n\tif (desc->istate & IRQS_TIMINGS)\n\t\tirq_timings_push(local_clock(), irq_desc_get_irq(desc));\n}\n#else\nstatic inline void irq_remove_timings(struct irq_desc *desc) {}\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {};\nstatic inline void record_irq_time(struct irq_desc *desc) {}\n#endif  \n\n\n#ifdef CONFIG_GENERIC_IRQ_CHIP\nvoid irq_init_generic_chip(struct irq_chip_generic *gc, const char *name,\n\t\t\t   int num_ct, unsigned int irq_base,\n\t\t\t   void __iomem *reg_base, irq_flow_handler_t handler);\n#else\nstatic inline void\nirq_init_generic_chip(struct irq_chip_generic *gc, const char *name,\n\t\t      int num_ct, unsigned int irq_base,\n\t\t      void __iomem *reg_base, irq_flow_handler_t handler) { }\n#endif  \n\n#ifdef CONFIG_GENERIC_PENDING_IRQ\nstatic inline bool irq_can_move_pcntxt(struct irq_data *data)\n{\n\treturn irqd_can_move_in_process_context(data);\n}\nstatic inline bool irq_move_pending(struct irq_data *data)\n{\n\treturn irqd_is_setaffinity_pending(data);\n}\nstatic inline void\nirq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)\n{\n\tcpumask_copy(desc->pending_mask, mask);\n}\nstatic inline void\nirq_get_pending(struct cpumask *mask, struct irq_desc *desc)\n{\n\tcpumask_copy(mask, desc->pending_mask);\n}\nstatic inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)\n{\n\treturn desc->pending_mask;\n}\nstatic inline bool handle_enforce_irqctx(struct irq_data *data)\n{\n\treturn irqd_is_handle_enforce_irqctx(data);\n}\nbool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear);\n#else  \nstatic inline bool irq_can_move_pcntxt(struct irq_data *data)\n{\n\treturn true;\n}\nstatic inline bool irq_move_pending(struct irq_data *data)\n{\n\treturn false;\n}\nstatic inline void\nirq_copy_pending(struct irq_desc *desc, const struct cpumask *mask)\n{\n}\nstatic inline void\nirq_get_pending(struct cpumask *mask, struct irq_desc *desc)\n{\n}\nstatic inline struct cpumask *irq_desc_get_pending_mask(struct irq_desc *desc)\n{\n\treturn NULL;\n}\nstatic inline bool irq_fixup_move_pending(struct irq_desc *desc, bool fclear)\n{\n\treturn false;\n}\nstatic inline bool handle_enforce_irqctx(struct irq_data *data)\n{\n\treturn false;\n}\n#endif  \n\n#if !defined(CONFIG_IRQ_DOMAIN) || !defined(CONFIG_IRQ_DOMAIN_HIERARCHY)\nstatic inline int irq_domain_activate_irq(struct irq_data *data, bool reserve)\n{\n\tirqd_set_activated(data);\n\treturn 0;\n}\nstatic inline void irq_domain_deactivate_irq(struct irq_data *data)\n{\n\tirqd_clr_activated(data);\n}\n#endif\n\nstatic inline struct irq_data *irqd_get_parent_data(struct irq_data *irqd)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irqd->parent_data;\n#else\n\treturn NULL;\n#endif\n}\n\n#ifdef CONFIG_GENERIC_IRQ_DEBUGFS\n#include <linux/debugfs.h>\n\nvoid irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc);\nstatic inline void irq_remove_debugfs_entry(struct irq_desc *desc)\n{\n\tdebugfs_remove(desc->debugfs_file);\n\tkfree(desc->dev_name);\n}\nvoid irq_debugfs_copy_devname(int irq, struct device *dev);\n# ifdef CONFIG_IRQ_DOMAIN\nvoid irq_domain_debugfs_init(struct dentry *root);\n# else\nstatic inline void irq_domain_debugfs_init(struct dentry *root)\n{\n}\n# endif\n#else  \nstatic inline void irq_add_debugfs_entry(unsigned int irq, struct irq_desc *d)\n{\n}\nstatic inline void irq_remove_debugfs_entry(struct irq_desc *d)\n{\n}\nstatic inline void irq_debugfs_copy_devname(int irq, struct device *dev)\n{\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}