{
  "module_name": "timings.c",
  "hash_id": "215b1f9baa880ecf6526edb3e3119f5d8291a20194de070f6084fe6ca388492a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/timings.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"irq_timings: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/static_key.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/idr.h>\n#include <linux/irq.h>\n#include <linux/math64.h>\n#include <linux/log2.h>\n\n#include <trace/events/irq.h>\n\n#include \"internals.h\"\n\nDEFINE_STATIC_KEY_FALSE(irq_timing_enabled);\n\nDEFINE_PER_CPU(struct irq_timings, irq_timings);\n\nstatic DEFINE_IDR(irqt_stats);\n\nvoid irq_timings_enable(void)\n{\n\tstatic_branch_enable(&irq_timing_enabled);\n}\n\nvoid irq_timings_disable(void)\n{\n\tstatic_branch_disable(&irq_timing_enabled);\n}\n\n \n#define EMA_ALPHA_VAL\t\t64\n#define EMA_ALPHA_SHIFT\t\t7\n\n#define PREDICTION_PERIOD_MIN\t3\n#define PREDICTION_PERIOD_MAX\t5\n#define PREDICTION_FACTOR\t4\n#define PREDICTION_MAX\t\t10  \n#define PREDICTION_BUFFER_SIZE\t16  \n\n \n#define for_each_irqts(i, irqts)\t\t\t\t\t\\\n\tfor (i = irqts->count < IRQ_TIMINGS_SIZE ?\t\t\t\\\n\t\t     0 : irqts->count & IRQ_TIMINGS_MASK,\t\t\\\n\t\t     irqts->count = min(IRQ_TIMINGS_SIZE,\t\t\\\n\t\t\t\t\tirqts->count);\t\t\t\\\n\t     irqts->count > 0; irqts->count--,\t\t\t\t\\\n\t\t     i = (i + 1) & IRQ_TIMINGS_MASK)\n\nstruct irqt_stat {\n\tu64\tlast_ts;\n\tu64\tema_time[PREDICTION_BUFFER_SIZE];\n\tint\ttimings[IRQ_TIMINGS_SIZE];\n\tint\tcirc_timings[IRQ_TIMINGS_SIZE];\n\tint\tcount;\n};\n\n \nstatic u64 irq_timings_ema_new(u64 value, u64 ema_old)\n{\n\ts64 diff;\n\n\tif (unlikely(!ema_old))\n\t\treturn value;\n\n\tdiff = (value - ema_old) * EMA_ALPHA_VAL;\n\t \n\treturn ema_old + (diff >> EMA_ALPHA_SHIFT);\n}\n\nstatic int irq_timings_next_event_index(int *buffer, size_t len, int period_max)\n{\n\tint period;\n\n\t \n\tbuffer = &buffer[len - (period_max * 3)];\n\n\t \n\tlen = period_max * 3;\n\n\t \n\tfor (period = period_max; period >= PREDICTION_PERIOD_MIN; period--) {\n\n\t\t \n\t\tint idx = period;\n\t\tsize_t size = period;\n\n\t\t \n\t\twhile (!memcmp(buffer, &buffer[idx], size * sizeof(int))) {\n\n\t\t\t \n\t\t\tidx += size;\n\n\t\t\t \n\t\t\tif (idx == len)\n\t\t\t\treturn buffer[len % period];\n\n\t\t\t \n\t\t\tif (len - idx < period)\n\t\t\t\tsize = len - idx;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic u64 __irq_timings_next_event(struct irqt_stat *irqs, int irq, u64 now)\n{\n\tint index, i, period_max, count, start, min = INT_MAX;\n\n\tif ((now - irqs->last_ts) >= NSEC_PER_SEC) {\n\t\tirqs->count = irqs->last_ts = 0;\n\t\treturn U64_MAX;\n\t}\n\n\t \n\tperiod_max = irqs->count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : irqs->count / 3;\n\n\t \n\tif (period_max <= PREDICTION_PERIOD_MIN)\n\t\treturn U64_MAX;\n\n\t \n\tcount = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\tirqs->count : IRQ_TIMINGS_SIZE;\n\n\tstart = irqs->count < IRQ_TIMINGS_SIZE ?\n\t\t0 : (irqs->count & IRQ_TIMINGS_MASK);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\n\t\tirqs->timings[i] = irqs->circ_timings[index];\n\t\tmin = min_t(int, irqs->timings[i], min);\n\t}\n\n\tindex = irq_timings_next_event_index(irqs->timings, count, period_max);\n\tif (index < 0)\n\t\treturn irqs->last_ts + irqs->ema_time[min];\n\n\treturn irqs->last_ts + irqs->ema_time[index];\n}\n\nstatic __always_inline int irq_timings_interval_index(u64 interval)\n{\n\t \n\tu64 interval_us = (interval >> 10) / PREDICTION_FACTOR;\n\n\treturn likely(interval_us) ? ilog2(interval_us) : 0;\n}\n\nstatic __always_inline void __irq_timings_store(int irq, struct irqt_stat *irqs,\n\t\t\t\t\t\tu64 interval)\n{\n\tint index;\n\n\t \n\tindex = irq_timings_interval_index(interval);\n\n\tif (index > PREDICTION_BUFFER_SIZE - 1) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t \n\tirqs->circ_timings[irqs->count & IRQ_TIMINGS_MASK] = index;\n\n\tirqs->ema_time[index] = irq_timings_ema_new(interval,\n\t\t\t\t\t\t    irqs->ema_time[index]);\n\n\tirqs->count++;\n}\n\nstatic inline void irq_timings_store(int irq, struct irqt_stat *irqs, u64 ts)\n{\n\tu64 old_ts = irqs->last_ts;\n\tu64 interval;\n\n\t \n\tirqs->last_ts = ts;\n\n\t \n\tinterval = ts - old_ts;\n\n\t \n\tif (interval >= NSEC_PER_SEC) {\n\t\tirqs->count = 0;\n\t\treturn;\n\t}\n\n\t__irq_timings_store(irq, irqs, interval);\n}\n\n \nu64 irq_timings_next_event(u64 now)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tstruct irqt_stat *irqs;\n\tstruct irqt_stat __percpu *s;\n\tu64 ts, next_evt = U64_MAX;\n\tint i, irq = 0;\n\n\t \n\tlockdep_assert_irqs_disabled();\n\n\tif (!irqts->count)\n\t\treturn next_evt;\n\n\t \n\tfor_each_irqts(i, irqts) {\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\t\ts = idr_find(&irqt_stats, irq);\n\t\tif (s)\n\t\t\tirq_timings_store(irq, this_cpu_ptr(s), ts);\n\t}\n\n\t \n\tidr_for_each_entry(&irqt_stats, s, i) {\n\n\t\tirqs = this_cpu_ptr(s);\n\n\t\tts = __irq_timings_next_event(irqs, i, now);\n\t\tif (ts <= now)\n\t\t\treturn now;\n\n\t\tif (ts < next_evt)\n\t\t\tnext_evt = ts;\n\t}\n\n\treturn next_evt;\n}\n\nvoid irq_timings_free(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (s) {\n\t\tfree_percpu(s);\n\t\tidr_remove(&irqt_stats, irq);\n\t}\n}\n\nint irq_timings_alloc(int irq)\n{\n\tstruct irqt_stat __percpu *s;\n\tint id;\n\n\t \n\ts = idr_find(&irqt_stats, irq);\n\tif (s)\n\t\treturn 0;\n\n\ts = alloc_percpu(*s);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tidr_preload(GFP_KERNEL);\n\tid = idr_alloc(&irqt_stats, s, irq, irq + 1, GFP_NOWAIT);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tfree_percpu(s);\n\t\treturn id;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_TEST_IRQ_TIMINGS\nstruct timings_intervals {\n\tu64 *intervals;\n\tsize_t count;\n};\n\n \nstatic u64 intervals0[] __initdata = {\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000, 500000,\n\t10000, 50000, 200000,\n};\n\nstatic u64 intervals1[] __initdata = {\n\t223947000, 1240000, 1384000, 1386000, 1386000,\n\t217416000, 1236000, 1384000, 1386000, 1387000,\n\t214719000, 1241000, 1386000, 1387000, 1384000,\n\t213696000, 1234000, 1384000, 1386000, 1388000,\n\t219904000, 1240000, 1385000, 1389000, 1385000,\n\t212240000, 1240000, 1386000, 1386000, 1386000,\n\t214415000, 1236000, 1384000, 1386000, 1387000,\n\t214276000, 1234000,\n};\n\nstatic u64 intervals2[] __initdata = {\n\t4000, 3000, 5000, 100000,\n\t3000, 3000, 5000, 117000,\n\t4000, 4000, 5000, 112000,\n\t4000, 3000, 4000, 110000,\n\t3000, 5000, 3000, 117000,\n\t4000, 4000, 5000, 112000,\n\t4000, 3000, 4000, 110000,\n\t3000, 4000, 5000, 112000,\n\t4000,\n};\n\nstatic u64 intervals3[] __initdata = {\n\t1385000, 212240000, 1240000,\n\t1386000, 214415000, 1236000,\n\t1384000, 214276000, 1234000,\n\t1386000, 214415000, 1236000,\n\t1385000, 212240000, 1240000,\n\t1386000, 214415000, 1236000,\n\t1384000, 214276000, 1234000,\n\t1386000, 214415000, 1236000,\n\t1385000, 212240000, 1240000,\n};\n\nstatic u64 intervals4[] __initdata = {\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000, 50000, 10000, 50000,\n\t10000,\n};\n\nstatic struct timings_intervals tis[] __initdata = {\n\t{ intervals0, ARRAY_SIZE(intervals0) },\n\t{ intervals1, ARRAY_SIZE(intervals1) },\n\t{ intervals2, ARRAY_SIZE(intervals2) },\n\t{ intervals3, ARRAY_SIZE(intervals3) },\n\t{ intervals4, ARRAY_SIZE(intervals4) },\n};\n\nstatic int __init irq_timings_test_next_index(struct timings_intervals *ti)\n{\n\tint _buffer[IRQ_TIMINGS_SIZE];\n\tint buffer[IRQ_TIMINGS_SIZE];\n\tint index, start, i, count, period_max;\n\n\tcount = ti->count - 1;\n\n\tperiod_max = count > (3 * PREDICTION_PERIOD_MAX) ?\n\t\tPREDICTION_PERIOD_MAX : count / 3;\n\n\t \n\tpr_debug(\"index suite: \");\n\n\tfor (i = 0; i < count; i++) {\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\t_buffer[i & IRQ_TIMINGS_MASK] = index;\n\t\tpr_cont(\"%d \", index);\n\t}\n\n\tstart = count < IRQ_TIMINGS_SIZE ? 0 :\n\t\tcount & IRQ_TIMINGS_MASK;\n\n\tcount = min_t(int, count, IRQ_TIMINGS_SIZE);\n\n\tfor (i = 0; i < count; i++) {\n\t\tint index = (start + i) & IRQ_TIMINGS_MASK;\n\t\tbuffer[i] = _buffer[index];\n\t}\n\n\tindex = irq_timings_next_event_index(buffer, count, period_max);\n\ti = irq_timings_interval_index(ti->intervals[ti->count - 1]);\n\n\tif (index != i) {\n\t\tpr_err(\"Expected (%d) and computed (%d) next indexes differ\\n\",\n\t\t       i, index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init irq_timings_next_index_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\n\t\tret = irq_timings_test_next_index(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int __init irq_timings_test_irqs(struct timings_intervals *ti)\n{\n\tstruct irqt_stat __percpu *s;\n\tstruct irqt_stat *irqs;\n\tint i, index, ret, irq = 0xACE5;\n\n\tret = irq_timings_alloc(irq);\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate irq timings\\n\");\n\t\treturn ret;\n\t}\n\n\ts = idr_find(&irqt_stats, irq);\n\tif (!s) {\n\t\tret = -EIDRM;\n\t\tgoto out;\n\t}\n\n\tirqs = this_cpu_ptr(s);\n\n\tfor (i = 0; i < ti->count; i++) {\n\n\t\tindex = irq_timings_interval_index(ti->intervals[i]);\n\t\tpr_debug(\"%d: interval=%llu ema_index=%d\\n\",\n\t\t\t i, ti->intervals[i], index);\n\n\t\t__irq_timings_store(irq, irqs, ti->intervals[i]);\n\t\tif (irqs->circ_timings[i & IRQ_TIMINGS_MASK] != index) {\n\t\t\tret = -EBADSLT;\n\t\t\tpr_err(\"Failed to store in the circular buffer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (irqs->count != ti->count) {\n\t\tret = -ERANGE;\n\t\tpr_err(\"Count differs\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tirq_timings_free(irq);\n\n\treturn ret;\n}\n\nstatic int __init irq_timings_irqs_selftest(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tis); i++) {\n\t\tpr_info(\"---> Injecting intervals number #%d (count=%zd)\\n\",\n\t\t\ti, tis[i].count);\n\t\tret = irq_timings_test_irqs(&tis[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int __init irq_timings_test_irqts(struct irq_timings *irqts,\n\t\t\t\t\t unsigned count)\n{\n\tint start = count >= IRQ_TIMINGS_SIZE ? count - IRQ_TIMINGS_SIZE : 0;\n\tint i, irq, oirq = 0xBEEF;\n\tu64 ots = 0xDEAD, ts;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"%d: index=%d, ts=%llX irq=%X\\n\",\n\t\t\t i, i & IRQ_TIMINGS_MASK, ots + i, oirq + i);\n\n\t\tirq_timings_push(ots + i, oirq + i);\n\t}\n\n\t \n\tots += start;\n\toirq += start;\n\n\t \n\tpr_debug(\"---> Checking timings array count (%d) is right\\n\", count);\n\tif (WARN_ON(irqts->count != count))\n\t\treturn -EINVAL;\n\n\t \n\tpr_debug(\"---> Checking the for_each_irqts() macro\\n\");\n\tfor_each_irqts(i, irqts) {\n\n\t\tirq = irq_timing_decode(irqts->values[i], &ts);\n\n\t\tpr_debug(\"index=%d, ts=%llX / %llX, irq=%X / %X\\n\",\n\t\t\t i, ts, ots, irq, oirq);\n\n\t\tif (WARN_ON(ts != ots || irq != oirq))\n\t\t\treturn -EINVAL;\n\n\t\tots++; oirq++;\n\t}\n\n\t \n\tpr_debug(\"---> Checking timings array is empty after browsing it\\n\");\n\tif (WARN_ON(irqts->count))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init irq_timings_irqts_selftest(void)\n{\n\tstruct irq_timings *irqts = this_cpu_ptr(&irq_timings);\n\tint i, ret;\n\n\t \n\tint count[] = { 0,\n\t\t\tIRQ_TIMINGS_SIZE >> 1,\n\t\t\tIRQ_TIMINGS_SIZE,\n\t\t\tIRQ_TIMINGS_SIZE + (IRQ_TIMINGS_SIZE >> 1),\n\t\t\t2 * IRQ_TIMINGS_SIZE,\n\t\t\t(2 * IRQ_TIMINGS_SIZE) + 3,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(count); i++) {\n\n\t\tpr_info(\"---> Checking the timings with %d/%d values\\n\",\n\t\t\tcount[i], IRQ_TIMINGS_SIZE);\n\n\t\tret = irq_timings_test_irqts(irqts, count[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int __init irq_timings_selftest(void)\n{\n\tint ret;\n\n\tpr_info(\"------------------- selftest start -----------------\\n\");\n\n\t \n\tif (static_branch_unlikely(&irq_timing_enabled)) {\n\t\tpr_warn(\"irq timings already initialized, skipping selftest\\n\");\n\t\treturn 0;\n\t}\n\n\tret = irq_timings_irqts_selftest();\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_timings_irqs_selftest();\n\tif (ret)\n\t\tgoto out;\n\n\tret = irq_timings_next_index_selftest();\nout:\n\tpr_info(\"---------- selftest end with %s -----------\\n\",\n\t\tret ? \"failure\" : \"success\");\n\n\treturn ret;\n}\nearly_initcall(irq_timings_selftest);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}