{
  "module_name": "ipi.c",
  "hash_id": "e73d3dd1a7f7cdb5a6ec35341f383940969c17aeb9d8f9e8a4183f001864ef11",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/ipi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"genirq/ipi: \" fmt\n\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n\n \nint irq_reserve_ipi(struct irq_domain *domain,\n\t\t\t     const struct cpumask *dest)\n{\n\tunsigned int nr_irqs, offset;\n\tstruct irq_data *data;\n\tint virq, i;\n\n\tif (!domain ||!irq_domain_is_ipi(domain)) {\n\t\tpr_warn(\"Reservation on a non IPI domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cpumask_subset(dest, cpu_possible_mask)) {\n\t\tpr_warn(\"Reservation is not in possible_cpu_mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_irqs = cpumask_weight(dest);\n\tif (!nr_irqs) {\n\t\tpr_warn(\"Reservation for empty destination mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (irq_domain_is_ipi_single(domain)) {\n\t\t \n\t\tnr_irqs = 1;\n\t\toffset = 0;\n\t} else {\n\t\tunsigned int next;\n\n\t\t \n\t\toffset = cpumask_first(dest);\n\t\t \n\t\tnext = cpumask_next_zero(offset, dest);\n\t\tif (next < nr_cpu_ids)\n\t\t\tnext = cpumask_next(next, dest);\n\t\tif (next < nr_cpu_ids) {\n\t\t\tpr_warn(\"Destination mask has holes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tvirq = irq_domain_alloc_descs(-1, nr_irqs, 0, NUMA_NO_NODE, NULL);\n\tif (virq <= 0) {\n\t\tpr_warn(\"Can't reserve IPI, failed to alloc descs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvirq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,\n\t\t\t\t       (void *) dest, true, NULL);\n\n\tif (virq <= 0) {\n\t\tpr_warn(\"Can't reserve IPI, failed to alloc hw irqs\\n\");\n\t\tgoto free_descs;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tdata = irq_get_irq_data(virq + i);\n\t\tcpumask_copy(data->common->affinity, dest);\n\t\tdata->common->ipi_offset = offset;\n\t\tirq_set_status_flags(virq + i, IRQ_NO_BALANCING);\n\t}\n\treturn virq;\n\nfree_descs:\n\tirq_free_descs(virq, nr_irqs);\n\treturn -EBUSY;\n}\n\n \nint irq_destroy_ipi(unsigned int irq, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tconst struct cpumask *ipimask;\n\tstruct irq_domain *domain;\n\tunsigned int nr_irqs;\n\n\tif (!irq || !data)\n\t\treturn -EINVAL;\n\n\tdomain = data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn -EINVAL;\n\n\tif (!irq_domain_is_ipi(domain)) {\n\t\tpr_warn(\"Trying to destroy a non IPI domain!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tipimask = irq_data_get_affinity_mask(data);\n\tif (!ipimask || WARN_ON(!cpumask_subset(dest, ipimask)))\n\t\t \n\t\treturn -EINVAL;\n\n\tif (irq_domain_is_ipi_per_cpu(domain)) {\n\t\tirq = irq + cpumask_first(dest) - data->common->ipi_offset;\n\t\tnr_irqs = cpumask_weight(dest);\n\t} else {\n\t\tnr_irqs = 1;\n\t}\n\n\tirq_domain_free_irqs(irq, nr_irqs);\n\treturn 0;\n}\n\n \nirq_hw_number_t ipi_get_hwirq(unsigned int irq, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_get_irq_data(irq);\n\tconst struct cpumask *ipimask;\n\n\tif (!data || cpu >= nr_cpu_ids)\n\t\treturn INVALID_HWIRQ;\n\n\tipimask = irq_data_get_affinity_mask(data);\n\tif (!ipimask || !cpumask_test_cpu(cpu, ipimask))\n\t\treturn INVALID_HWIRQ;\n\n\t \n\tif (irq_domain_is_ipi_per_cpu(data->domain))\n\t\tdata = irq_get_irq_data(irq + cpu - data->common->ipi_offset);\n\n\treturn data ? irqd_to_hwirq(data) : INVALID_HWIRQ;\n}\nEXPORT_SYMBOL_GPL(ipi_get_hwirq);\n\nstatic int ipi_send_verify(struct irq_chip *chip, struct irq_data *data,\n\t\t\t   const struct cpumask *dest, unsigned int cpu)\n{\n\tconst struct cpumask *ipimask;\n\n\tif (!chip || !data)\n\t\treturn -EINVAL;\n\n\tif (!chip->ipi_send_single && !chip->ipi_send_mask)\n\t\treturn -EINVAL;\n\n\tif (cpu >= nr_cpu_ids)\n\t\treturn -EINVAL;\n\n\tipimask = irq_data_get_affinity_mask(data);\n\tif (!ipimask)\n\t\treturn -EINVAL;\n\n\tif (dest) {\n\t\tif (!cpumask_subset(dest, ipimask))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!cpumask_test_cpu(cpu, ipimask))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nint __ipi_send_single(struct irq_desc *desc, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\n#ifdef DEBUG\n\t \n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n#endif\n\tif (!chip->ipi_send_single) {\n\t\tchip->ipi_send_mask(data, cpumask_of(cpu));\n\t\treturn 0;\n\t}\n\n\t \n\tif (irq_domain_is_ipi_per_cpu(data->domain) &&\n\t    cpu != data->common->ipi_offset) {\n\t\t \n\t\tunsigned irq = data->irq + cpu - data->common->ipi_offset;\n\n\t\tdata = irq_get_irq_data(irq);\n\t}\n\tchip->ipi_send_single(data, cpu);\n\treturn 0;\n}\n\n \nint __ipi_send_mask(struct irq_desc *desc, const struct cpumask *dest)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tunsigned int cpu;\n\n#ifdef DEBUG\n\t \n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n#endif\n\tif (chip->ipi_send_mask) {\n\t\tchip->ipi_send_mask(data, dest);\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_ipi_per_cpu(data->domain)) {\n\t\tunsigned int base = data->irq;\n\n\t\tfor_each_cpu(cpu, dest) {\n\t\t\tunsigned irq = base + cpu - data->common->ipi_offset;\n\n\t\t\tdata = irq_get_irq_data(irq);\n\t\t\tchip->ipi_send_single(data, cpu);\n\t\t}\n\t} else {\n\t\tfor_each_cpu(cpu, dest)\n\t\t\tchip->ipi_send_single(data, cpu);\n\t}\n\treturn 0;\n}\n\n \nint ipi_send_single(unsigned int virq, unsigned int cpu)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, NULL, cpu)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_single(desc, cpu);\n}\nEXPORT_SYMBOL_GPL(ipi_send_single);\n\n \nint ipi_send_mask(unsigned int virq, const struct cpumask *dest)\n{\n\tstruct irq_desc *desc = irq_to_desc(virq);\n\tstruct irq_data *data = desc ? irq_desc_get_irq_data(desc) : NULL;\n\tstruct irq_chip *chip = data ? irq_data_get_irq_chip(data) : NULL;\n\n\tif (WARN_ON_ONCE(ipi_send_verify(chip, data, dest, 0)))\n\t\treturn -EINVAL;\n\n\treturn __ipi_send_mask(desc, dest);\n}\nEXPORT_SYMBOL_GPL(ipi_send_mask);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}