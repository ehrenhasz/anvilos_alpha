{
  "module_name": "chip.c",
  "hash_id": "33519817d8f1518089ea2ccd96462fdb7ffb210c99b9ddf87623bb4417403fb6",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/chip.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/msi.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdomain.h>\n\n#include <trace/events/irq.h>\n\n#include \"internals.h\"\n\nstatic irqreturn_t bad_chained_irq(int irq, void *dev_id)\n{\n\tWARN_ONCE(1, \"Chained irq %d should not call an action\\n\", irq);\n\treturn IRQ_NONE;\n}\n\n \nstruct irqaction chained_action = {\n\t.handler = bad_chained_irq,\n};\n\n \nint irq_set_chip(unsigned int irq, const struct irq_chip *chip)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tdesc->irq_data.chip = (struct irq_chip *)(chip ?: &no_irq_chip);\n\tirq_put_desc_unlock(desc, flags);\n\t \n\tirq_mark_irq(irq);\n\treturn 0;\n}\nEXPORT_SYMBOL(irq_set_chip);\n\n \nint irq_set_irq_type(unsigned int irq, unsigned int type)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\tint ret = 0;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tret = __irq_set_trigger(desc, type);\n\tirq_put_desc_busunlock(desc, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(irq_set_irq_type);\n\n \nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(irq_set_handler_data);\n\n \nint irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,\n\t\t\t struct msi_desc *entry)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq_base + irq_offset, &flags, IRQ_GET_DESC_CHECK_GLOBAL);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.msi_desc = entry;\n\tif (entry && !irq_offset)\n\t\tentry->irq = irq_base;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}\n\n \nint irq_set_msi_desc(unsigned int irq, struct msi_desc *entry)\n{\n\treturn irq_set_msi_desc_off(irq, 0, entry);\n}\n\n \nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(irq_set_chip_data);\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}\nEXPORT_SYMBOL_GPL(irq_get_irq_data);\n\nstatic void irq_state_clr_disabled(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_DISABLED);\n}\n\nstatic void irq_state_clr_masked(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_MASKED);\n}\n\nstatic void irq_state_clr_started(struct irq_desc *desc)\n{\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_STARTED);\n}\n\nstatic void irq_state_set_started(struct irq_desc *desc)\n{\n\tirqd_set(&desc->irq_data, IRQD_IRQ_STARTED);\n}\n\nenum {\n\tIRQ_STARTUP_NORMAL,\n\tIRQ_STARTUP_MANAGED,\n\tIRQ_STARTUP_ABORT,\n};\n\n#ifdef CONFIG_SMP\nstatic int\n__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,\n\t\t      bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn IRQ_STARTUP_NORMAL;\n\n\tirqd_clr_managed_shutdown(d);\n\n\tif (cpumask_any_and(aff, cpu_online_mask) >= nr_cpu_ids) {\n\t\t \n\t\tif (WARN_ON_ONCE(force))\n\t\t\treturn IRQ_STARTUP_ABORT;\n\t\t \n\t\treturn IRQ_STARTUP_ABORT;\n\t}\n\t \n\tif (WARN_ON(irq_domain_activate_irq(d, false)))\n\t\treturn IRQ_STARTUP_ABORT;\n\treturn IRQ_STARTUP_MANAGED;\n}\n#else\nstatic __always_inline int\n__irq_startup_managed(struct irq_desc *desc, const struct cpumask *aff,\n\t\t      bool force)\n{\n\treturn IRQ_STARTUP_NORMAL;\n}\n#endif\n\nstatic int __irq_startup(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tint ret = 0;\n\n\t \n\tWARN_ON_ONCE(!irqd_is_activated(d));\n\n\tif (d->chip->irq_startup) {\n\t\tret = d->chip->irq_startup(d);\n\t\tirq_state_clr_disabled(desc);\n\t\tirq_state_clr_masked(desc);\n\t} else {\n\t\tirq_enable(desc);\n\t}\n\tirq_state_set_started(desc);\n\treturn ret;\n}\n\nint irq_startup(struct irq_desc *desc, bool resend, bool force)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tconst struct cpumask *aff = irq_data_get_affinity_mask(d);\n\tint ret = 0;\n\n\tdesc->depth = 0;\n\n\tif (irqd_is_started(d)) {\n\t\tirq_enable(desc);\n\t} else {\n\t\tswitch (__irq_startup_managed(desc, aff, force)) {\n\t\tcase IRQ_STARTUP_NORMAL:\n\t\t\tif (d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP)\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tret = __irq_startup(desc);\n\t\t\tif (!(d->chip->flags & IRQCHIP_AFFINITY_PRE_STARTUP))\n\t\t\t\tirq_setup_affinity(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_MANAGED:\n\t\t\tirq_do_set_affinity(d, aff, false);\n\t\t\tret = __irq_startup(desc);\n\t\t\tbreak;\n\t\tcase IRQ_STARTUP_ABORT:\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (resend)\n\t\tcheck_irq_resend(desc, false);\n\n\treturn ret;\n}\n\nint irq_activate(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_affinity_is_managed(d))\n\t\treturn irq_domain_activate_irq(d, false);\n\treturn 0;\n}\n\nint irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask);\n\nvoid irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tclear_irq_resend(desc);\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n}\n\n\nvoid irq_shutdown_and_deactivate(struct irq_desc *desc)\n{\n\tirq_shutdown(desc);\n\t \n\tirq_domain_deactivate_irq(&desc->irq_data);\n}\n\nvoid irq_enable(struct irq_desc *desc)\n{\n\tif (!irqd_irq_disabled(&desc->irq_data)) {\n\t\tunmask_irq(desc);\n\t} else {\n\t\tirq_state_clr_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_enable) {\n\t\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\t\t\tirq_state_clr_masked(desc);\n\t\t} else {\n\t\t\tunmask_irq(desc);\n\t\t}\n\t}\n}\n\nstatic void __irq_disable(struct irq_desc *desc, bool mask)\n{\n\tif (irqd_irq_disabled(&desc->irq_data)) {\n\t\tif (mask)\n\t\t\tmask_irq(desc);\n\t} else {\n\t\tirq_state_set_disabled(desc);\n\t\tif (desc->irq_data.chip->irq_disable) {\n\t\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else if (mask) {\n\t\t\tmask_irq(desc);\n\t\t}\n\t}\n}\n\n \nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}\n\nvoid irq_percpu_enable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_enable)\n\t\tdesc->irq_data.chip->irq_enable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\tcpumask_set_cpu(cpu, desc->percpu_enabled);\n}\n\nvoid irq_percpu_disable(struct irq_desc *desc, unsigned int cpu)\n{\n\tif (desc->irq_data.chip->irq_disable)\n\t\tdesc->irq_data.chip->irq_disable(&desc->irq_data);\n\telse\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\tcpumask_clear_cpu(cpu, desc->percpu_enabled);\n}\n\nstatic inline void mask_ack_irq(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_mask_ack) {\n\t\tdesc->irq_data.chip->irq_mask_ack(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t} else {\n\t\tmask_irq(desc);\n\t\tif (desc->irq_data.chip->irq_ack)\n\t\t\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\t}\n}\n\nvoid mask_irq(struct irq_desc *desc)\n{\n\tif (irqd_irq_masked(&desc->irq_data))\n\t\treturn;\n\n\tif (desc->irq_data.chip->irq_mask) {\n\t\tdesc->irq_data.chip->irq_mask(&desc->irq_data);\n\t\tirq_state_set_masked(desc);\n\t}\n}\n\nvoid unmask_irq(struct irq_desc *desc)\n{\n\tif (!irqd_irq_masked(&desc->irq_data))\n\t\treturn;\n\n\tif (desc->irq_data.chip->irq_unmask) {\n\t\tdesc->irq_data.chip->irq_unmask(&desc->irq_data);\n\t\tirq_state_clr_masked(desc);\n\t}\n}\n\nvoid unmask_threaded_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\tif (chip->flags & IRQCHIP_EOI_THREADED)\n\t\tchip->irq_eoi(&desc->irq_data);\n\n\tunmask_irq(desc);\n}\n\n \nvoid handle_nested_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tirqreturn_t action_ret;\n\n\tmight_sleep();\n\n\traw_spin_lock_irq(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\taction = desc->action;\n\tif (unlikely(!action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\traw_spin_unlock_irq(&desc->lock);\n\t\treturn;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tatomic_inc(&desc->threads_active);\n\traw_spin_unlock_irq(&desc->lock);\n\n\taction_ret = IRQ_NONE;\n\tfor_each_action_of_desc(desc, action)\n\t\taction_ret |= action->thread_fn(action->irq, action->dev_id);\n\n\tif (!irq_settings_no_debug(desc))\n\t\tnote_interrupt(desc, action_ret);\n\n\twake_threads_waitq(desc);\n}\nEXPORT_SYMBOL_GPL(handle_nested_irq);\n\nstatic bool irq_check_poll(struct irq_desc *desc)\n{\n\tif (!(desc->istate & IRQS_POLL_INPROGRESS))\n\t\treturn false;\n\treturn irq_wait_for_poll(desc);\n}\n\nstatic bool irq_may_run(struct irq_desc *desc)\n{\n\tunsigned int mask = IRQD_IRQ_INPROGRESS | IRQD_WAKEUP_ARMED;\n\n\t \n\tif (!irqd_has_set(&desc->irq_data, mask))\n\t\treturn true;\n\n\t \n\tif (irq_pm_check_wakeup(desc))\n\t\treturn false;\n\n\t \n\treturn irq_check_poll(desc);\n}\n\n \nvoid handle_simple_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL_GPL(handle_simple_irq);\n\n \nvoid handle_untracked_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\t__handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL_GPL(handle_untracked_irq);\n\n \nstatic void cond_unmask_irq(struct irq_desc *desc)\n{\n\t \n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot)\n\t\tunmask_irq(desc);\n}\n\n \nvoid handle_level_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out_unlock;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t \n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\thandle_irq_event(desc);\n\n\tcond_unmask_irq(desc);\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL_GPL(handle_level_irq);\n\nstatic void cond_unmask_eoi_irq(struct irq_desc *desc, struct irq_chip *chip)\n{\n\tif (!(desc->istate & IRQS_ONESHOT)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\treturn;\n\t}\n\t \n\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t    irqd_irq_masked(&desc->irq_data) && !desc->threads_oneshot) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t\tunmask_irq(desc);\n\t} else if (!(chip->flags & IRQCHIP_EOI_THREADED)) {\n\t\tchip->irq_eoi(&desc->irq_data);\n\t}\n}\n\n \nvoid handle_fasteoi_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\n\t \n\tif (!irq_may_run(desc)) {\n\t\tif (irqd_needs_resend_when_in_progress(&desc->irq_data))\n\t\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t \n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\t \n\tif (unlikely(desc->istate & IRQS_PENDING))\n\t\tcheck_irq_resend(desc, false);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL_GPL(handle_fasteoi_irq);\n\n \nvoid handle_fasteoi_nmi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\ttrace_irq_handler_entry(irq, action);\n\t \n\tres = action->handler(irq, action->dev_id);\n\ttrace_irq_handler_exit(irq, action, res);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}\nEXPORT_SYMBOL_GPL(handle_fasteoi_nmi);\n\n \nvoid handle_edge_irq(struct irq_desc *desc)\n{\n\traw_spin_lock(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (!irq_may_run(desc)) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_ack_irq(desc);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (irqd_irq_disabled(&desc->irq_data) || !desc->action) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_ack_irq(desc);\n\t\tgoto out_unlock;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\n\t \n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\tdo {\n\t\tif (unlikely(!desc->action)) {\n\t\t\tmask_irq(desc);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (unlikely(desc->istate & IRQS_PENDING)) {\n\t\t\tif (!irqd_irq_disabled(&desc->irq_data) &&\n\t\t\t    irqd_irq_masked(&desc->irq_data))\n\t\t\t\tunmask_irq(desc);\n\t\t}\n\n\t\thandle_irq_event(desc);\n\n\t} while ((desc->istate & IRQS_PENDING) &&\n\t\t !irqd_irq_disabled(&desc->irq_data));\n\nout_unlock:\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL(handle_edge_irq);\n\n#ifdef CONFIG_IRQ_EDGE_EOI_HANDLER\n \nvoid handle_edge_eoi_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\traw_spin_lock(&desc->lock);\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\tif (!irq_may_run(desc)) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_eoi;\n\t}\n\n\t \n\tif (irqd_irq_disabled(&desc->irq_data) || !desc->action) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out_eoi;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\n\tdo {\n\t\tif (unlikely(!desc->action))\n\t\t\tgoto out_eoi;\n\n\t\thandle_irq_event(desc);\n\n\t} while ((desc->istate & IRQS_PENDING) &&\n\t\t !irqd_irq_disabled(&desc->irq_data));\n\nout_eoi:\n\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}\n#endif\n\n \nvoid handle_percpu_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\t \n\t__kstat_incr_irqs_this_cpu(desc);\n\n\tif (chip->irq_ack)\n\t\tchip->irq_ack(&desc->irq_data);\n\n\thandle_irq_event_percpu(desc);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}\n\n \nvoid handle_percpu_devid_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t \n\t__kstat_incr_irqs_this_cpu(desc);\n\n\tif (chip->irq_ack)\n\t\tchip->irq_ack(&desc->irq_data);\n\n\tif (likely(action)) {\n\t\ttrace_irq_handler_entry(irq, action);\n\t\tres = action->handler(irq, raw_cpu_ptr(action->percpu_dev_id));\n\t\ttrace_irq_handler_exit(irq, action, res);\n\t} else {\n\t\tunsigned int cpu = smp_processor_id();\n\t\tbool enabled = cpumask_test_cpu(cpu, desc->percpu_enabled);\n\n\t\tif (enabled)\n\t\t\tirq_percpu_disable(desc, cpu);\n\n\t\tpr_err_once(\"Spurious%s percpu IRQ%u on CPU%u\\n\",\n\t\t\t    enabled ? \" and unmasked\" : \"\", irq, cpu);\n\t}\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}\n\n \nvoid handle_percpu_devid_fasteoi_nmi(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irqaction *action = desc->action;\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tirqreturn_t res;\n\n\t__kstat_incr_irqs_this_cpu(desc);\n\n\ttrace_irq_handler_entry(irq, action);\n\tres = action->handler(irq, raw_cpu_ptr(action->percpu_dev_id));\n\ttrace_irq_handler_exit(irq, action, res);\n\n\tif (chip->irq_eoi)\n\t\tchip->irq_eoi(&desc->irq_data);\n}\n\nstatic void\n__irq_do_set_handler(struct irq_desc *desc, irq_flow_handler_t handle,\n\t\t     int is_chained, const char *name)\n{\n\tif (!handle) {\n\t\thandle = handle_bad_irq;\n\t} else {\n\t\tstruct irq_data *irq_data = &desc->irq_data;\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\t\t \n\t\twhile (irq_data) {\n\t\t\tif (irq_data->chip != &no_irq_chip)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (WARN_ON(is_chained))\n\t\t\t\treturn;\n\t\t\t \n\t\t\tirq_data = irq_data->parent_data;\n\t\t}\n#endif\n\t\tif (WARN_ON(!irq_data || irq_data->chip == &no_irq_chip))\n\t\t\treturn;\n\t}\n\n\t \n\tif (handle == handle_bad_irq) {\n\t\tif (desc->irq_data.chip != &no_irq_chip)\n\t\t\tmask_ack_irq(desc);\n\t\tirq_state_set_disabled(desc);\n\t\tif (is_chained) {\n\t\t\tdesc->action = NULL;\n\t\t\tWARN_ON(irq_chip_pm_put(irq_desc_get_irq_data(desc)));\n\t\t}\n\t\tdesc->depth = 1;\n\t}\n\tdesc->handle_irq = handle;\n\tdesc->name = name;\n\n\tif (handle != handle_bad_irq && is_chained) {\n\t\tunsigned int type = irqd_get_trigger_type(&desc->irq_data);\n\n\t\t \n\t\tif (type != IRQ_TYPE_NONE) {\n\t\t\t__irq_set_trigger(desc, type);\n\t\t\tdesc->handle_irq = handle;\n\t\t}\n\n\t\tirq_settings_set_noprobe(desc);\n\t\tirq_settings_set_norequest(desc);\n\t\tirq_settings_set_nothread(desc);\n\t\tdesc->action = &chained_action;\n\t\tWARN_ON(irq_chip_pm_get(irq_desc_get_irq_data(desc)));\n\t\tirq_activate_and_startup(desc, IRQ_RESEND);\n\t}\n}\n\nvoid\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}\nEXPORT_SYMBOL_GPL(__irq_set_handler);\n\nvoid\nirq_set_chained_handler_and_data(unsigned int irq, irq_flow_handler_t handle,\n\t\t\t\t void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\tdesc->irq_common_data.handler_data = data;\n\t__irq_do_set_handler(desc, handle, 1, NULL);\n\n\tirq_put_desc_busunlock(desc, flags);\n}\nEXPORT_SYMBOL_GPL(irq_set_chained_handler_and_data);\n\nvoid\nirq_set_chip_and_handler_name(unsigned int irq, const struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}\nEXPORT_SYMBOL_GPL(irq_set_chip_and_handler_name);\n\nvoid irq_modify_status(unsigned int irq, unsigned long clr, unsigned long set)\n{\n\tunsigned long flags, trigger, tmp;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t \n\tWARN_ON_ONCE(!desc->depth && (set & _IRQ_NOAUTOEN));\n\n\tirq_settings_clr_and_set(desc, clr, set);\n\n\ttrigger = irqd_get_trigger_type(&desc->irq_data);\n\n\tirqd_clear(&desc->irq_data, IRQD_NO_BALANCING | IRQD_PER_CPU |\n\t\t   IRQD_TRIGGER_MASK | IRQD_LEVEL | IRQD_MOVE_PCNTXT);\n\tif (irq_settings_has_no_balance_set(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_NO_BALANCING);\n\tif (irq_settings_is_per_cpu(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_PER_CPU);\n\tif (irq_settings_can_move_pcntxt(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_MOVE_PCNTXT);\n\tif (irq_settings_is_level(desc))\n\t\tirqd_set(&desc->irq_data, IRQD_LEVEL);\n\n\ttmp = irq_settings_get_trigger_mask(desc);\n\tif (tmp != IRQ_TYPE_NONE)\n\t\ttrigger = tmp;\n\n\tirqd_set(&desc->irq_data, trigger);\n\n\tirq_put_desc_unlock(desc, flags);\n}\nEXPORT_SYMBOL_GPL(irq_modify_status);\n\n#ifdef CONFIG_DEPRECATED_IRQ_CPU_ONOFFLINE\n \nvoid irq_cpu_online(void)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tchip = irq_data_get_irq_chip(&desc->irq_data);\n\t\tif (chip && chip->irq_cpu_online &&\n\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||\n\t\t     !irqd_irq_disabled(&desc->irq_data)))\n\t\t\tchip->irq_cpu_online(&desc->irq_data);\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}\n\n \nvoid irq_cpu_offline(void)\n{\n\tstruct irq_desc *desc;\n\tstruct irq_chip *chip;\n\tunsigned long flags;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\n\t\tchip = irq_data_get_irq_chip(&desc->irq_data);\n\t\tif (chip && chip->irq_cpu_offline &&\n\t\t    (!(chip->flags & IRQCHIP_ONOFFLINE_ENABLED) ||\n\t\t     !irqd_irq_disabled(&desc->irq_data)))\n\t\t\tchip->irq_cpu_offline(&desc->irq_data);\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n}\n#endif\n\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\n#ifdef CONFIG_IRQ_FASTEOI_HIERARCHY_HANDLERS\n \nvoid handle_fasteoi_ack_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t \n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\t \n\tdesc->irq_data.chip->irq_ack(&desc->irq_data);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL_GPL(handle_fasteoi_ack_irq);\n\n \nvoid handle_fasteoi_mask_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = desc->irq_data.chip;\n\n\traw_spin_lock(&desc->lock);\n\tmask_ack_irq(desc);\n\n\tif (!irq_may_run(desc))\n\t\tgoto out;\n\n\tdesc->istate &= ~(IRQS_REPLAY | IRQS_WAITING);\n\n\t \n\tif (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tmask_irq(desc);\n\t\tgoto out;\n\t}\n\n\tkstat_incr_irqs_this_cpu(desc);\n\tif (desc->istate & IRQS_ONESHOT)\n\t\tmask_irq(desc);\n\n\thandle_irq_event(desc);\n\n\tcond_unmask_eoi_irq(desc, chip);\n\n\traw_spin_unlock(&desc->lock);\n\treturn;\nout:\n\tif (!(chip->flags & IRQCHIP_EOI_IF_HANDLED))\n\t\tchip->irq_eoi(&desc->irq_data);\n\traw_spin_unlock(&desc->lock);\n}\nEXPORT_SYMBOL_GPL(handle_fasteoi_mask_irq);\n\n#endif  \n\n \nint irq_chip_set_parent_state(struct irq_data *data,\n\t\t\t      enum irqchip_irq_state which,\n\t\t\t      bool val)\n{\n\tdata = data->parent_data;\n\n\tif (!data || !data->chip->irq_set_irqchip_state)\n\t\treturn 0;\n\n\treturn data->chip->irq_set_irqchip_state(data, which, val);\n}\nEXPORT_SYMBOL_GPL(irq_chip_set_parent_state);\n\n \nint irq_chip_get_parent_state(struct irq_data *data,\n\t\t\t      enum irqchip_irq_state which,\n\t\t\t      bool *state)\n{\n\tdata = data->parent_data;\n\n\tif (!data || !data->chip->irq_get_irqchip_state)\n\t\treturn 0;\n\n\treturn data->chip->irq_get_irqchip_state(data, which, state);\n}\nEXPORT_SYMBOL_GPL(irq_chip_get_parent_state);\n\n \nvoid irq_chip_enable_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_enable)\n\t\tdata->chip->irq_enable(data);\n\telse\n\t\tdata->chip->irq_unmask(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_enable_parent);\n\n \nvoid irq_chip_disable_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_disable)\n\t\tdata->chip->irq_disable(data);\n\telse\n\t\tdata->chip->irq_mask(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_disable_parent);\n\n \nvoid irq_chip_ack_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_ack(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_ack_parent);\n\n \nvoid irq_chip_mask_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_mask(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_mask_parent);\n\n \nvoid irq_chip_mask_ack_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_mask_ack(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_mask_ack_parent);\n\n \nvoid irq_chip_unmask_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_unmask(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_unmask_parent);\n\n \nvoid irq_chip_eoi_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tdata->chip->irq_eoi(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_eoi_parent);\n\n \nint irq_chip_set_affinity_parent(struct irq_data *data,\n\t\t\t\t const struct cpumask *dest, bool force)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_set_affinity)\n\t\treturn data->chip->irq_set_affinity(data, dest, force);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(irq_chip_set_affinity_parent);\n\n \nint irq_chip_set_type_parent(struct irq_data *data, unsigned int type)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->irq_set_type)\n\t\treturn data->chip->irq_set_type(data, type);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(irq_chip_set_type_parent);\n\n \nint irq_chip_retrigger_hierarchy(struct irq_data *data)\n{\n\tfor (data = data->parent_data; data; data = data->parent_data)\n\t\tif (data->chip && data->chip->irq_retrigger)\n\t\t\treturn data->chip->irq_retrigger(data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_chip_retrigger_hierarchy);\n\n \nint irq_chip_set_vcpu_affinity_parent(struct irq_data *data, void *vcpu_info)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_set_vcpu_affinity)\n\t\treturn data->chip->irq_set_vcpu_affinity(data, vcpu_info);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(irq_chip_set_vcpu_affinity_parent);\n \nint irq_chip_set_wake_parent(struct irq_data *data, unsigned int on)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->flags & IRQCHIP_SKIP_SET_WAKE)\n\t\treturn 0;\n\n\tif (data->chip->irq_set_wake)\n\t\treturn data->chip->irq_set_wake(data, on);\n\n\treturn -ENOSYS;\n}\nEXPORT_SYMBOL_GPL(irq_chip_set_wake_parent);\n\n \nint irq_chip_request_resources_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\n\tif (data->chip->irq_request_resources)\n\t\treturn data->chip->irq_request_resources(data);\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(irq_chip_request_resources_parent);\n\n \nvoid irq_chip_release_resources_parent(struct irq_data *data)\n{\n\tdata = data->parent_data;\n\tif (data->chip->irq_release_resources)\n\t\tdata->chip->irq_release_resources(data);\n}\nEXPORT_SYMBOL_GPL(irq_chip_release_resources_parent);\n#endif\n\n \nint irq_chip_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\n{\n\tstruct irq_data *pos;\n\n\tfor (pos = NULL; !pos && data; data = irqd_get_parent_data(data)) {\n\t\tif (data->chip && data->chip->irq_compose_msi_msg)\n\t\t\tpos = data;\n\t}\n\n\tif (!pos)\n\t\treturn -ENOSYS;\n\n\tpos->chip->irq_compose_msi_msg(pos, msg);\n\treturn 0;\n}\n\nstatic struct device *irq_get_pm_device(struct irq_data *data)\n{\n\tif (data->domain)\n\t\treturn data->domain->pm_dev;\n\n\treturn NULL;\n}\n\n \nint irq_chip_pm_get(struct irq_data *data)\n{\n\tstruct device *dev = irq_get_pm_device(data);\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && dev)\n\t\tretval = pm_runtime_resume_and_get(dev);\n\n\treturn retval;\n}\n\n \nint irq_chip_pm_put(struct irq_data *data)\n{\n\tstruct device *dev = irq_get_pm_device(data);\n\tint retval = 0;\n\n\tif (IS_ENABLED(CONFIG_PM) && dev)\n\t\tretval = pm_runtime_put(dev);\n\n\treturn (retval < 0) ? retval : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}