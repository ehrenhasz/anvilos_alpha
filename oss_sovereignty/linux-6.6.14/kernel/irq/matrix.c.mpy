{
  "module_name": "matrix.c",
  "hash_id": "bc6e8c668722a981713bd61d434895bf7f493beabccdc11f32398990a24799ff",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/matrix.c",
  "human_readable_source": "\n\n\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/bitmap.h>\n#include <linux/percpu.h>\n#include <linux/cpu.h>\n#include <linux/irq.h>\n\n#define IRQ_MATRIX_SIZE\t(BITS_TO_LONGS(IRQ_MATRIX_BITS))\n\nstruct cpumap {\n\tunsigned int\t\tavailable;\n\tunsigned int\t\tallocated;\n\tunsigned int\t\tmanaged;\n\tunsigned int\t\tmanaged_allocated;\n\tbool\t\t\tinitialized;\n\tbool\t\t\tonline;\n\tunsigned long\t\talloc_map[IRQ_MATRIX_SIZE];\n\tunsigned long\t\tmanaged_map[IRQ_MATRIX_SIZE];\n};\n\nstruct irq_matrix {\n\tunsigned int\t\tmatrix_bits;\n\tunsigned int\t\talloc_start;\n\tunsigned int\t\talloc_end;\n\tunsigned int\t\talloc_size;\n\tunsigned int\t\tglobal_available;\n\tunsigned int\t\tglobal_reserved;\n\tunsigned int\t\tsystembits_inalloc;\n\tunsigned int\t\ttotal_allocated;\n\tunsigned int\t\tonline_maps;\n\tstruct cpumap __percpu\t*maps;\n\tunsigned long\t\tscratch_map[IRQ_MATRIX_SIZE];\n\tunsigned long\t\tsystem_map[IRQ_MATRIX_SIZE];\n};\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/irq_matrix.h>\n\n \n__init struct irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,\n\t\t\t\t\t   unsigned int alloc_start,\n\t\t\t\t\t   unsigned int alloc_end)\n{\n\tstruct irq_matrix *m;\n\n\tif (matrix_bits > IRQ_MATRIX_BITS)\n\t\treturn NULL;\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn NULL;\n\n\tm->matrix_bits = matrix_bits;\n\tm->alloc_start = alloc_start;\n\tm->alloc_end = alloc_end;\n\tm->alloc_size = alloc_end - alloc_start;\n\tm->maps = alloc_percpu(*m->maps);\n\tif (!m->maps) {\n\t\tkfree(m);\n\t\treturn NULL;\n\t}\n\treturn m;\n}\n\n \nvoid irq_matrix_online(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tBUG_ON(cm->online);\n\n\tif (!cm->initialized) {\n\t\tcm->available = m->alloc_size;\n\t\tcm->available -= cm->managed + m->systembits_inalloc;\n\t\tcm->initialized = true;\n\t}\n\tm->global_available += cm->available;\n\tcm->online = true;\n\tm->online_maps++;\n\ttrace_irq_matrix_online(m);\n}\n\n \nvoid irq_matrix_offline(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\t \n\tm->global_available -= cm->available;\n\tcm->online = false;\n\tm->online_maps--;\n\ttrace_irq_matrix_offline(m);\n}\n\nstatic unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}\n\n \nstatic unsigned int matrix_find_best_cpu(struct irq_matrix *m,\n\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, maxavl = 0;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->available <= maxavl)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tmaxavl = cm->available;\n\t}\n\treturn best_cpu;\n}\n\n \nstatic unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}\n\n \nvoid irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,\n\t\t\t      bool replace)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tBUG_ON(bit > m->matrix_bits);\n\tBUG_ON(m->online_maps > 1 || (m->online_maps && !replace));\n\n\tset_bit(bit, m->system_map);\n\tif (replace) {\n\t\tBUG_ON(!test_and_clear_bit(bit, cm->alloc_map));\n\t\tcm->allocated--;\n\t\tm->total_allocated--;\n\t}\n\tif (bit >= m->alloc_start && bit < m->alloc_end)\n\t\tm->systembits_inalloc++;\n\n\ttrace_irq_matrix_assign_system(bit, m);\n}\n\n \nint irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu, failed_cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit;\n\n\t\tbit = matrix_alloc_area(m, cm, 1, true);\n\t\tif (bit >= m->alloc_end)\n\t\t\tgoto cleanup;\n\t\tcm->managed++;\n\t\tif (cm->online) {\n\t\t\tcm->available--;\n\t\t\tm->global_available--;\n\t\t}\n\t\ttrace_irq_matrix_reserve_managed(bit, cpu, m, cm);\n\t}\n\treturn 0;\ncleanup:\n\tfailed_cpu = cpu;\n\tfor_each_cpu(cpu, msk) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tirq_matrix_remove_managed(m, cpumask_of(cpu));\n\t}\n\treturn -ENOSPC;\n}\n\n \nvoid irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit, end = m->alloc_end;\n\n\t\tif (WARN_ON_ONCE(!cm->managed))\n\t\t\tcontinue;\n\n\t\t \n\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\n\t\tbit = find_first_bit(m->scratch_map, end);\n\t\tif (WARN_ON_ONCE(bit >= end))\n\t\t\tcontinue;\n\n\t\tclear_bit(bit, cm->managed_map);\n\n\t\tcm->managed--;\n\t\tif (cm->online) {\n\t\t\tcm->available++;\n\t\t\tm->global_available++;\n\t\t}\n\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);\n\t}\n}\n\n \nint irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,\n\t\t\t     unsigned int *mapped_cpu)\n{\n\tunsigned int bit, cpu, end;\n\tstruct cpumap *cm;\n\n\tif (cpumask_empty(msk))\n\t\treturn -EINVAL;\n\n\tcpu = matrix_find_best_cpu_managed(m, msk);\n\tif (cpu == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tcm = per_cpu_ptr(m->maps, cpu);\n\tend = m->alloc_end;\n\t \n\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\tbit = find_first_bit(m->scratch_map, end);\n\tif (bit >= end)\n\t\treturn -ENOSPC;\n\tset_bit(bit, cm->alloc_map);\n\tcm->allocated++;\n\tcm->managed_allocated++;\n\tm->total_allocated++;\n\t*mapped_cpu = cpu;\n\ttrace_irq_matrix_alloc_managed(bit, cpu, m, cm);\n\treturn bit;\n}\n\n \nvoid irq_matrix_assign(struct irq_matrix *m, unsigned int bit)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))\n\t\treturn;\n\tif (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))\n\t\treturn;\n\tcm->allocated++;\n\tm->total_allocated++;\n\tcm->available--;\n\tm->global_available--;\n\ttrace_irq_matrix_assign(bit, smp_processor_id(), m, cm);\n}\n\n \nvoid irq_matrix_reserve(struct irq_matrix *m)\n{\n\tif (m->global_reserved == m->global_available)\n\t\tpr_warn(\"Interrupt reservation exceeds available resources\\n\");\n\n\tm->global_reserved++;\n\ttrace_irq_matrix_reserve(m);\n}\n\n \nvoid irq_matrix_remove_reserved(struct irq_matrix *m)\n{\n\tm->global_reserved--;\n\ttrace_irq_matrix_remove_reserved(m);\n}\n\n \nint irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,\n\t\t     bool reserved, unsigned int *mapped_cpu)\n{\n\tunsigned int cpu, bit;\n\tstruct cpumap *cm;\n\n\t \n\tif (cpumask_empty(msk))\n\t\treturn -EINVAL;\n\n\tcpu = matrix_find_best_cpu(m, msk);\n\tif (cpu == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tcm = per_cpu_ptr(m->maps, cpu);\n\tbit = matrix_alloc_area(m, cm, 1, false);\n\tif (bit >= m->alloc_end)\n\t\treturn -ENOSPC;\n\tcm->allocated++;\n\tcm->available--;\n\tm->total_allocated++;\n\tm->global_available--;\n\tif (reserved)\n\t\tm->global_reserved--;\n\t*mapped_cpu = cpu;\n\ttrace_irq_matrix_alloc(bit, cpu, m, cm);\n\treturn bit;\n\n}\n\n \nvoid irq_matrix_free(struct irq_matrix *m, unsigned int cpu,\n\t\t     unsigned int bit, bool managed)\n{\n\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\n\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(!test_and_clear_bit(bit, cm->alloc_map)))\n\t\treturn;\n\n\tcm->allocated--;\n\tif(managed)\n\t\tcm->managed_allocated--;\n\n\tif (cm->online)\n\t\tm->total_allocated--;\n\n\tif (!managed) {\n\t\tcm->available++;\n\t\tif (cm->online)\n\t\t\tm->global_available++;\n\t}\n\ttrace_irq_matrix_free(bit, cpu, m, cm);\n}\n\n \nunsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tif (!cpudown)\n\t\treturn m->global_available;\n\treturn m->global_available - cm->available;\n}\n\n \nunsigned int irq_matrix_reserved(struct irq_matrix *m)\n{\n\treturn m->global_reserved;\n}\n\n \nunsigned int irq_matrix_allocated(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\treturn cm->allocated - cm->managed_allocated;\n}\n\n#ifdef CONFIG_GENERIC_IRQ_DEBUGFS\n \nvoid irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)\n{\n\tunsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);\n\tint cpu;\n\n\tseq_printf(sf, \"Online bitmaps:   %6u\\n\", m->online_maps);\n\tseq_printf(sf, \"Global available: %6u\\n\", m->global_available);\n\tseq_printf(sf, \"Global reserved:  %6u\\n\", m->global_reserved);\n\tseq_printf(sf, \"Total allocated:  %6u\\n\", m->total_allocated);\n\tseq_printf(sf, \"System: %u: %*pbl\\n\", nsys, m->matrix_bits,\n\t\t   m->system_map);\n\tseq_printf(sf, \"%*s| CPU | avl | man | mac | act | vectors\\n\", ind, \" \");\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\n\t\tseq_printf(sf, \"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\", ind, \" \",\n\t\t\t   cpu, cm->available, cm->managed,\n\t\t\t   cm->managed_allocated, cm->allocated,\n\t\t\t   m->matrix_bits, cm->alloc_map);\n\t}\n\tcpus_read_unlock();\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}