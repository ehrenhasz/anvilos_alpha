{
  "module_name": "msi.c",
  "hash_id": "72e97064388cde6fe5b13df70587969a4e316e667a41f73d75497ce1b6af57ca",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/msi.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/msi.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/pci.h>\n\n#include \"internals.h\"\n\n \nstruct msi_ctrl {\n\tunsigned int\t\t\tdomid;\n\tunsigned int\t\t\tfirst;\n\tunsigned int\t\t\tlast;\n\tunsigned int\t\t\tnirqs;\n};\n\n \n#define MSI_XA_MAX_INDEX\t(ULONG_MAX - 1)\n \n#define MSI_XA_DOMAIN_SIZE\t(MSI_MAX_INDEX + 1)\n\nstatic void msi_domain_free_locked(struct device *dev, struct msi_ctrl *ctrl);\nstatic unsigned int msi_domain_get_hwsize(struct device *dev, unsigned int domid);\nstatic inline int msi_sysfs_create_group(struct device *dev);\n\n\n \nstatic struct msi_desc *msi_alloc_desc(struct device *dev, int nvec,\n\t\t\t\t       const struct irq_affinity_desc *affinity)\n{\n\tstruct msi_desc *desc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\n\tif (!desc)\n\t\treturn NULL;\n\n\tdesc->dev = dev;\n\tdesc->nvec_used = nvec;\n\tif (affinity) {\n\t\tdesc->affinity = kmemdup(affinity, nvec * sizeof(*desc->affinity), GFP_KERNEL);\n\t\tif (!desc->affinity) {\n\t\t\tkfree(desc);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}\n\nstatic void msi_free_desc(struct msi_desc *desc)\n{\n\tkfree(desc->affinity);\n\tkfree(desc);\n}\n\nstatic int msi_insert_desc(struct device *dev, struct msi_desc *desc,\n\t\t\t   unsigned int domid, unsigned int index)\n{\n\tstruct msi_device_data *md = dev->msi.data;\n\tstruct xarray *xa = &md->__domains[domid].store;\n\tunsigned int hwsize;\n\tint ret;\n\n\thwsize = msi_domain_get_hwsize(dev, domid);\n\n\tif (index == MSI_ANY_INDEX) {\n\t\tstruct xa_limit limit = { .min = 0, .max = hwsize - 1 };\n\t\tunsigned int index;\n\n\t\t \n\t\tret = xa_alloc(xa, &index, desc, limit, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tdesc->msi_index = index;\n\t\treturn 0;\n\t} else {\n\t\tif (index >= hwsize) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdesc->msi_index = index;\n\t\tret = xa_insert(xa, index, desc, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\treturn 0;\n\t}\nfail:\n\tmsi_free_desc(desc);\n\treturn ret;\n}\n\n \nint msi_domain_insert_msi_desc(struct device *dev, unsigned int domid,\n\t\t\t       struct msi_desc *init_desc)\n{\n\tstruct msi_desc *desc;\n\n\tlockdep_assert_held(&dev->msi.data->mutex);\n\n\tdesc = msi_alloc_desc(dev, init_desc->nvec_used, init_desc->affinity);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t \n\tdesc->pci = init_desc->pci;\n\n\treturn msi_insert_desc(dev, desc, domid, init_desc->msi_index);\n}\n\nstatic bool msi_desc_match(struct msi_desc *desc, enum msi_desc_filter filter)\n{\n\tswitch (filter) {\n\tcase MSI_DESC_ALL:\n\t\treturn true;\n\tcase MSI_DESC_NOTASSOCIATED:\n\t\treturn !desc->irq;\n\tcase MSI_DESC_ASSOCIATED:\n\t\treturn !!desc->irq;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic bool msi_ctrl_valid(struct device *dev, struct msi_ctrl *ctrl)\n{\n\tunsigned int hwsize;\n\n\tif (WARN_ON_ONCE(ctrl->domid >= MSI_MAX_DEVICE_IRQDOMAINS ||\n\t\t\t (dev->msi.domain &&\n\t\t\t  !dev->msi.data->__domains[ctrl->domid].domain)))\n\t\treturn false;\n\n\thwsize = msi_domain_get_hwsize(dev, ctrl->domid);\n\tif (WARN_ON_ONCE(ctrl->first > ctrl->last ||\n\t\t\t ctrl->first >= hwsize ||\n\t\t\t ctrl->last >= hwsize))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void msi_domain_free_descs(struct device *dev, struct msi_ctrl *ctrl)\n{\n\tstruct msi_desc *desc;\n\tstruct xarray *xa;\n\tunsigned long idx;\n\n\tlockdep_assert_held(&dev->msi.data->mutex);\n\n\tif (!msi_ctrl_valid(dev, ctrl))\n\t\treturn;\n\n\txa = &dev->msi.data->__domains[ctrl->domid].store;\n\txa_for_each_range(xa, idx, desc, ctrl->first, ctrl->last) {\n\t\txa_erase(xa, idx);\n\n\t\t \n\t\tif (WARN_ON_ONCE(msi_desc_match(desc, MSI_DESC_ASSOCIATED)))\n\t\t\tcontinue;\n\t\tmsi_free_desc(desc);\n\t}\n}\n\n \nvoid msi_domain_free_msi_descs_range(struct device *dev, unsigned int domid,\n\t\t\t\t     unsigned int first, unsigned int last)\n{\n\tstruct msi_ctrl ctrl = {\n\t\t.domid\t= domid,\n\t\t.first\t= first,\n\t\t.last\t= last,\n\t};\n\n\tmsi_domain_free_descs(dev, &ctrl);\n}\n\n \nstatic int msi_domain_add_simple_msi_descs(struct device *dev, struct msi_ctrl *ctrl)\n{\n\tstruct msi_desc *desc;\n\tunsigned int idx;\n\tint ret;\n\n\tlockdep_assert_held(&dev->msi.data->mutex);\n\n\tif (!msi_ctrl_valid(dev, ctrl))\n\t\treturn -EINVAL;\n\n\tfor (idx = ctrl->first; idx <= ctrl->last; idx++) {\n\t\tdesc = msi_alloc_desc(dev, 1, NULL);\n\t\tif (!desc)\n\t\t\tgoto fail_mem;\n\t\tret = msi_insert_desc(dev, desc, ctrl->domid, idx);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\n\nfail_mem:\n\tret = -ENOMEM;\nfail:\n\tmsi_domain_free_descs(dev, ctrl);\n\treturn ret;\n}\n\nvoid __get_cached_msi_msg(struct msi_desc *entry, struct msi_msg *msg)\n{\n\t*msg = entry->msg;\n}\n\nvoid get_cached_msi_msg(unsigned int irq, struct msi_msg *msg)\n{\n\tstruct msi_desc *entry = irq_get_msi_desc(irq);\n\n\t__get_cached_msi_msg(entry, msg);\n}\nEXPORT_SYMBOL_GPL(get_cached_msi_msg);\n\nstatic void msi_device_data_release(struct device *dev, void *res)\n{\n\tstruct msi_device_data *md = res;\n\tint i;\n\n\tfor (i = 0; i < MSI_MAX_DEVICE_IRQDOMAINS; i++) {\n\t\tmsi_remove_device_irq_domain(dev, i);\n\t\tWARN_ON_ONCE(!xa_empty(&md->__domains[i].store));\n\t\txa_destroy(&md->__domains[i].store);\n\t}\n\tdev->msi.data = NULL;\n}\n\n \nint msi_setup_device_data(struct device *dev)\n{\n\tstruct msi_device_data *md;\n\tint ret, i;\n\n\tif (dev->msi.data)\n\t\treturn 0;\n\n\tmd = devres_alloc(msi_device_data_release, sizeof(*md), GFP_KERNEL);\n\tif (!md)\n\t\treturn -ENOMEM;\n\n\tret = msi_sysfs_create_group(dev);\n\tif (ret) {\n\t\tdevres_free(md);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MSI_MAX_DEVICE_IRQDOMAINS; i++)\n\t\txa_init_flags(&md->__domains[i].store, XA_FLAGS_ALLOC);\n\n\t \n\tif (dev->msi.domain && !irq_domain_is_msi_parent(dev->msi.domain))\n\t\tmd->__domains[MSI_DEFAULT_DOMAIN].domain = dev->msi.domain;\n\n\tmutex_init(&md->mutex);\n\tdev->msi.data = md;\n\tdevres_add(dev, md);\n\treturn 0;\n}\n\n \nvoid msi_lock_descs(struct device *dev)\n{\n\tmutex_lock(&dev->msi.data->mutex);\n}\nEXPORT_SYMBOL_GPL(msi_lock_descs);\n\n \nvoid msi_unlock_descs(struct device *dev)\n{\n\t \n\tdev->msi.data->__iter_idx = MSI_XA_MAX_INDEX;\n\tmutex_unlock(&dev->msi.data->mutex);\n}\nEXPORT_SYMBOL_GPL(msi_unlock_descs);\n\nstatic struct msi_desc *msi_find_desc(struct msi_device_data *md, unsigned int domid,\n\t\t\t\t      enum msi_desc_filter filter)\n{\n\tstruct xarray *xa = &md->__domains[domid].store;\n\tstruct msi_desc *desc;\n\n\txa_for_each_start(xa, md->__iter_idx, desc, md->__iter_idx) {\n\t\tif (msi_desc_match(desc, filter))\n\t\t\treturn desc;\n\t}\n\tmd->__iter_idx = MSI_XA_MAX_INDEX;\n\treturn NULL;\n}\n\n \nstruct msi_desc *msi_domain_first_desc(struct device *dev, unsigned int domid,\n\t\t\t\t       enum msi_desc_filter filter)\n{\n\tstruct msi_device_data *md = dev->msi.data;\n\n\tif (WARN_ON_ONCE(!md || domid >= MSI_MAX_DEVICE_IRQDOMAINS))\n\t\treturn NULL;\n\n\tlockdep_assert_held(&md->mutex);\n\n\tmd->__iter_idx = 0;\n\treturn msi_find_desc(md, domid, filter);\n}\nEXPORT_SYMBOL_GPL(msi_domain_first_desc);\n\n \nstruct msi_desc *msi_next_desc(struct device *dev, unsigned int domid,\n\t\t\t       enum msi_desc_filter filter)\n{\n\tstruct msi_device_data *md = dev->msi.data;\n\n\tif (WARN_ON_ONCE(!md || domid >= MSI_MAX_DEVICE_IRQDOMAINS))\n\t\treturn NULL;\n\n\tlockdep_assert_held(&md->mutex);\n\n\tif (md->__iter_idx >= (unsigned long)MSI_MAX_INDEX)\n\t\treturn NULL;\n\n\tmd->__iter_idx++;\n\treturn msi_find_desc(md, domid, filter);\n}\nEXPORT_SYMBOL_GPL(msi_next_desc);\n\n \nunsigned int msi_domain_get_virq(struct device *dev, unsigned int domid, unsigned int index)\n{\n\tstruct msi_desc *desc;\n\tunsigned int ret = 0;\n\tbool pcimsi = false;\n\tstruct xarray *xa;\n\n\tif (!dev->msi.data)\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(index > MSI_MAX_INDEX || domid >= MSI_MAX_DEVICE_IRQDOMAINS))\n\t\treturn 0;\n\n\t \n\tif (dev_is_pci(dev) && domid == MSI_DEFAULT_DOMAIN)\n\t\tpcimsi = to_pci_dev(dev)->msi_enabled;\n\n\tmsi_lock_descs(dev);\n\txa = &dev->msi.data->__domains[domid].store;\n\tdesc = xa_load(xa, pcimsi ? 0 : index);\n\tif (desc && desc->irq) {\n\t\t \n\t\tif (pcimsi) {\n\t\t\tif (index < desc->nvec_used)\n\t\t\t\tret = desc->irq + index;\n\t\t} else {\n\t\t\tret = desc->irq;\n\t\t}\n\t}\n\n\tmsi_unlock_descs(dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(msi_domain_get_virq);\n\n#ifdef CONFIG_SYSFS\nstatic struct attribute *msi_dev_attrs[] = {\n\tNULL\n};\n\nstatic const struct attribute_group msi_irqs_group = {\n\t.name\t= \"msi_irqs\",\n\t.attrs\t= msi_dev_attrs,\n};\n\nstatic inline int msi_sysfs_create_group(struct device *dev)\n{\n\treturn devm_device_add_group(dev, &msi_irqs_group);\n}\n\nstatic ssize_t msi_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\t \n\tbool is_msix = dev_is_pci(dev) ? to_pci_dev(dev)->msix_enabled : false;\n\n\treturn sysfs_emit(buf, \"%s\\n\", is_msix ? \"msix\" : \"msi\");\n}\n\nstatic void msi_sysfs_remove_desc(struct device *dev, struct msi_desc *desc)\n{\n\tstruct device_attribute *attrs = desc->sysfs_attrs;\n\tint i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tdesc->sysfs_attrs = NULL;\n\tfor (i = 0; i < desc->nvec_used; i++) {\n\t\tif (attrs[i].show)\n\t\t\tsysfs_remove_file_from_group(&dev->kobj, &attrs[i].attr, msi_irqs_group.name);\n\t\tkfree(attrs[i].attr.name);\n\t}\n\tkfree(attrs);\n}\n\nstatic int msi_sysfs_populate_desc(struct device *dev, struct msi_desc *desc)\n{\n\tstruct device_attribute *attrs;\n\tint ret, i;\n\n\tattrs = kcalloc(desc->nvec_used, sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tdesc->sysfs_attrs = attrs;\n\tfor (i = 0; i < desc->nvec_used; i++) {\n\t\tsysfs_attr_init(&attrs[i].attr);\n\t\tattrs[i].attr.name = kasprintf(GFP_KERNEL, \"%d\", desc->irq + i);\n\t\tif (!attrs[i].attr.name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tattrs[i].attr.mode = 0444;\n\t\tattrs[i].show = msi_mode_show;\n\n\t\tret = sysfs_add_file_to_group(&dev->kobj, &attrs[i].attr, msi_irqs_group.name);\n\t\tif (ret) {\n\t\t\tattrs[i].show = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\n\nfail:\n\tmsi_sysfs_remove_desc(dev, desc);\n\treturn ret;\n}\n\n#if defined(CONFIG_PCI_MSI_ARCH_FALLBACKS) || defined(CONFIG_PCI_XEN)\n \nint msi_device_populate_sysfs(struct device *dev)\n{\n\tstruct msi_desc *desc;\n\tint ret;\n\n\tmsi_for_each_desc(desc, dev, MSI_DESC_ASSOCIATED) {\n\t\tif (desc->sysfs_attrs)\n\t\t\tcontinue;\n\t\tret = msi_sysfs_populate_desc(dev, desc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nvoid msi_device_destroy_sysfs(struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tmsi_for_each_desc(desc, dev, MSI_DESC_ALL)\n\t\tmsi_sysfs_remove_desc(dev, desc);\n}\n#endif  \n#else  \nstatic inline int msi_sysfs_create_group(struct device *dev) { return 0; }\nstatic inline int msi_sysfs_populate_desc(struct device *dev, struct msi_desc *desc) { return 0; }\nstatic inline void msi_sysfs_remove_desc(struct device *dev, struct msi_desc *desc) { }\n#endif  \n\nstatic struct irq_domain *msi_get_device_domain(struct device *dev, unsigned int domid)\n{\n\tstruct irq_domain *domain;\n\n\tlockdep_assert_held(&dev->msi.data->mutex);\n\n\tif (WARN_ON_ONCE(domid >= MSI_MAX_DEVICE_IRQDOMAINS))\n\t\treturn NULL;\n\n\tdomain = dev->msi.data->__domains[domid].domain;\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (WARN_ON_ONCE(irq_domain_is_msi_parent(domain)))\n\t\treturn NULL;\n\n\treturn domain;\n}\n\nstatic unsigned int msi_domain_get_hwsize(struct device *dev, unsigned int domid)\n{\n\tstruct msi_domain_info *info;\n\tstruct irq_domain *domain;\n\n\tdomain = msi_get_device_domain(dev, domid);\n\tif (domain) {\n\t\tinfo = domain->host_data;\n\t\treturn info->hwsize;\n\t}\n\t \n\treturn MSI_XA_DOMAIN_SIZE;\n}\n\nstatic inline void irq_chip_write_msi_msg(struct irq_data *data,\n\t\t\t\t\t  struct msi_msg *msg)\n{\n\tdata->chip->irq_write_msi_msg(data, msg);\n}\n\nstatic void msi_check_level(struct irq_domain *domain, struct msi_msg *msg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\n\t \n\tWARN_ON(!((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t  (info->chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)) &&\n\t\t(msg[1].address_lo || msg[1].address_hi || msg[1].data));\n}\n\n \nint msi_domain_set_affinity(struct irq_data *irq_data,\n\t\t\t    const struct cpumask *mask, bool force)\n{\n\tstruct irq_data *parent = irq_data->parent_data;\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret >= 0 && ret != IRQ_SET_MASK_OK_DONE) {\n\t\tBUG_ON(irq_chip_compose_msi_msg(irq_data, msg));\n\t\tmsi_check_level(irq_data->domain, msg);\n\t\tirq_chip_write_msi_msg(irq_data, msg);\n\t}\n\n\treturn ret;\n}\n\nstatic int msi_domain_activate(struct irq_domain *domain,\n\t\t\t       struct irq_data *irq_data, bool early)\n{\n\tstruct msi_msg msg[2] = { [1] = { }, };\n\n\tBUG_ON(irq_chip_compose_msi_msg(irq_data, msg));\n\tmsi_check_level(irq_data->domain, msg);\n\tirq_chip_write_msi_msg(irq_data, msg);\n\treturn 0;\n}\n\nstatic void msi_domain_deactivate(struct irq_domain *domain,\n\t\t\t\t  struct irq_data *irq_data)\n{\n\tstruct msi_msg msg[2];\n\n\tmemset(msg, 0, sizeof(msg));\n\tirq_chip_write_msi_msg(irq_data, msg);\n}\n\nstatic int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tirq_hw_number_t hwirq = ops->get_hwirq(info, arg);\n\tint i, ret;\n\n\tif (irq_find_mapping(domain, hwirq) > 0)\n\t\treturn -EEXIST;\n\n\tif (domain->parent) {\n\t\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = ops->msi_init(domain, info, virq + i, hwirq + i, arg);\n\t\tif (ret < 0) {\n\t\t\tif (ops->msi_free) {\n\t\t\t\tfor (i--; i > 0; i--)\n\t\t\t\t\tops->msi_free(domain, info, virq + i);\n\t\t\t}\n\t\t\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void msi_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t    unsigned int nr_irqs)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tint i;\n\n\tif (info->ops->msi_free) {\n\t\tfor (i = 0; i < nr_irqs; i++)\n\t\t\tinfo->ops->msi_free(domain, info, virq + i);\n\t}\n\tirq_domain_free_irqs_top(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops msi_domain_ops = {\n\t.alloc\t\t= msi_domain_alloc,\n\t.free\t\t= msi_domain_free,\n\t.activate\t= msi_domain_activate,\n\t.deactivate\t= msi_domain_deactivate,\n};\n\nstatic irq_hw_number_t msi_domain_ops_get_hwirq(struct msi_domain_info *info,\n\t\t\t\t\t\tmsi_alloc_info_t *arg)\n{\n\treturn arg->hwirq;\n}\n\nstatic int msi_domain_ops_prepare(struct irq_domain *domain, struct device *dev,\n\t\t\t\t  int nvec, msi_alloc_info_t *arg)\n{\n\tmemset(arg, 0, sizeof(*arg));\n\treturn 0;\n}\n\nstatic void msi_domain_ops_set_desc(msi_alloc_info_t *arg,\n\t\t\t\t    struct msi_desc *desc)\n{\n\targ->desc = desc;\n}\n\nstatic int msi_domain_ops_init(struct irq_domain *domain,\n\t\t\t       struct msi_domain_info *info,\n\t\t\t       unsigned int virq, irq_hw_number_t hwirq,\n\t\t\t       msi_alloc_info_t *arg)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, info->chip,\n\t\t\t\t      info->chip_data);\n\tif (info->handler && info->handler_name) {\n\t\t__irq_set_handler(virq, info->handler, 0, info->handler_name);\n\t\tif (info->handler_data)\n\t\t\tirq_set_handler_data(virq, info->handler_data);\n\t}\n\treturn 0;\n}\n\nstatic struct msi_domain_ops msi_domain_ops_default = {\n\t.get_hwirq\t\t= msi_domain_ops_get_hwirq,\n\t.msi_init\t\t= msi_domain_ops_init,\n\t.msi_prepare\t\t= msi_domain_ops_prepare,\n\t.set_desc\t\t= msi_domain_ops_set_desc,\n};\n\nstatic void msi_domain_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tif (ops == NULL) {\n\t\tinfo->ops = &msi_domain_ops_default;\n\t\treturn;\n\t}\n\n\tif (!(info->flags & MSI_FLAG_USE_DEF_DOM_OPS))\n\t\treturn;\n\n\tif (ops->get_hwirq == NULL)\n\t\tops->get_hwirq = msi_domain_ops_default.get_hwirq;\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = msi_domain_ops_default.msi_init;\n\tif (ops->msi_prepare == NULL)\n\t\tops->msi_prepare = msi_domain_ops_default.msi_prepare;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = msi_domain_ops_default.set_desc;\n}\n\nstatic void msi_domain_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip || !chip->irq_mask || !chip->irq_unmask);\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n}\n\nstatic struct irq_domain *__msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t\t  struct msi_domain_info *info,\n\t\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t\t  struct irq_domain *parent)\n{\n\tstruct irq_domain *domain;\n\n\tif (info->hwsize > MSI_XA_DOMAIN_SIZE)\n\t\treturn NULL;\n\n\t \n\tif (!info->hwsize)\n\t\tinfo->hwsize = MSI_XA_DOMAIN_SIZE;\n\n\tmsi_domain_update_dom_ops(info);\n\tif (info->flags & MSI_FLAG_USE_DEF_CHIP_OPS)\n\t\tmsi_domain_update_chip_ops(info);\n\n\tdomain = irq_domain_create_hierarchy(parent, flags | IRQ_DOMAIN_FLAG_MSI, 0,\n\t\t\t\t\t     fwnode, &msi_domain_ops, info);\n\n\tif (domain)\n\t\tirq_domain_update_bus_token(domain, info->bus_token);\n\n\treturn domain;\n}\n\n \nstruct irq_domain *msi_create_irq_domain(struct fwnode_handle *fwnode,\n\t\t\t\t\t struct msi_domain_info *info,\n\t\t\t\t\t struct irq_domain *parent)\n{\n\treturn __msi_create_irq_domain(fwnode, info, 0, parent);\n}\n\n \nbool msi_parent_init_dev_msi_info(struct device *dev, struct irq_domain *domain,\n\t\t\t\t  struct irq_domain *msi_parent_domain,\n\t\t\t\t  struct msi_domain_info *msi_child_info)\n{\n\tstruct irq_domain *parent = domain->parent;\n\n\tif (WARN_ON_ONCE(!parent || !parent->msi_parent_ops ||\n\t\t\t !parent->msi_parent_ops->init_dev_msi_info))\n\t\treturn false;\n\n\treturn parent->msi_parent_ops->init_dev_msi_info(dev, parent, msi_parent_domain,\n\t\t\t\t\t\t\t msi_child_info);\n}\n\n \nbool msi_create_device_irq_domain(struct device *dev, unsigned int domid,\n\t\t\t\t  const struct msi_domain_template *template,\n\t\t\t\t  unsigned int hwsize, void *domain_data,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_domain *domain, *parent = dev->msi.domain;\n\tconst struct msi_parent_ops *pops;\n\tstruct msi_domain_template *bundle;\n\tstruct fwnode_handle *fwnode;\n\n\tif (!irq_domain_is_msi_parent(parent))\n\t\treturn false;\n\n\tif (domid >= MSI_MAX_DEVICE_IRQDOMAINS)\n\t\treturn false;\n\n\tbundle = kmemdup(template, sizeof(*bundle), GFP_KERNEL);\n\tif (!bundle)\n\t\treturn false;\n\n\tbundle->info.hwsize = hwsize;\n\tbundle->info.chip = &bundle->chip;\n\tbundle->info.ops = &bundle->ops;\n\tbundle->info.data = domain_data;\n\tbundle->info.chip_data = chip_data;\n\n\tpops = parent->msi_parent_ops;\n\tsnprintf(bundle->name, sizeof(bundle->name), \"%s%s-%s\",\n\t\t pops->prefix ? : \"\", bundle->chip.name, dev_name(dev));\n\tbundle->chip.name = bundle->name;\n\n\tfwnode = irq_domain_alloc_named_fwnode(bundle->name);\n\tif (!fwnode)\n\t\tgoto free_bundle;\n\n\tif (msi_setup_device_data(dev))\n\t\tgoto free_fwnode;\n\n\tmsi_lock_descs(dev);\n\n\tif (WARN_ON_ONCE(msi_get_device_domain(dev, domid)))\n\t\tgoto fail;\n\n\tif (!pops->init_dev_msi_info(dev, parent, parent, &bundle->info))\n\t\tgoto fail;\n\n\tdomain = __msi_create_irq_domain(fwnode, &bundle->info, IRQ_DOMAIN_FLAG_MSI_DEVICE, parent);\n\tif (!domain)\n\t\tgoto fail;\n\n\tdomain->dev = dev;\n\tdev->msi.data->__domains[domid].domain = domain;\n\tmsi_unlock_descs(dev);\n\treturn true;\n\nfail:\n\tmsi_unlock_descs(dev);\nfree_fwnode:\n\tirq_domain_free_fwnode(fwnode);\nfree_bundle:\n\tkfree(bundle);\n\treturn false;\n}\n\n \nvoid msi_remove_device_irq_domain(struct device *dev, unsigned int domid)\n{\n\tstruct fwnode_handle *fwnode = NULL;\n\tstruct msi_domain_info *info;\n\tstruct irq_domain *domain;\n\n\tmsi_lock_descs(dev);\n\n\tdomain = msi_get_device_domain(dev, domid);\n\n\tif (!domain || !irq_domain_is_msi_device(domain))\n\t\tgoto unlock;\n\n\tdev->msi.data->__domains[domid].domain = NULL;\n\tinfo = domain->host_data;\n\tif (irq_domain_is_msi_device(domain))\n\t\tfwnode = domain->fwnode;\n\tirq_domain_remove(domain);\n\tirq_domain_free_fwnode(fwnode);\n\tkfree(container_of(info, struct msi_domain_template, info));\n\nunlock:\n\tmsi_unlock_descs(dev);\n}\n\n \nbool msi_match_device_irq_domain(struct device *dev, unsigned int domid,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tstruct msi_domain_info *info;\n\tstruct irq_domain *domain;\n\tbool ret = false;\n\n\tmsi_lock_descs(dev);\n\tdomain = msi_get_device_domain(dev, domid);\n\tif (domain && irq_domain_is_msi_device(domain)) {\n\t\tinfo = domain->host_data;\n\t\tret = info->bus_token == bus_token;\n\t}\n\tmsi_unlock_descs(dev);\n\treturn ret;\n}\n\nint msi_domain_prepare_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t    int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\n\treturn ops->msi_prepare(domain, dev, nvec, arg);\n}\n\nint msi_domain_populate_irqs(struct irq_domain *domain, struct device *dev,\n\t\t\t     int virq_base, int nvec, msi_alloc_info_t *arg)\n{\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tstruct msi_ctrl ctrl = {\n\t\t.domid\t= MSI_DEFAULT_DOMAIN,\n\t\t.first  = virq_base,\n\t\t.last\t= virq_base + nvec - 1,\n\t};\n\tstruct msi_desc *desc;\n\tstruct xarray *xa;\n\tint ret, virq;\n\n\tmsi_lock_descs(dev);\n\n\tif (!msi_ctrl_valid(dev, &ctrl)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tret = msi_domain_add_simple_msi_descs(dev, &ctrl);\n\tif (ret)\n\t\tgoto unlock;\n\n\txa = &dev->msi.data->__domains[ctrl.domid].store;\n\n\tfor (virq = virq_base; virq < virq_base + nvec; virq++) {\n\t\tdesc = xa_load(xa, virq);\n\t\tdesc->irq = virq;\n\n\t\tops->set_desc(arg, desc);\n\t\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tirq_set_msi_desc(virq, desc);\n\t}\n\tmsi_unlock_descs(dev);\n\treturn 0;\n\nfail:\n\tfor (--virq; virq >= virq_base; virq--) {\n\t\tmsi_domain_depopulate_descs(dev, virq, 1);\n\t\tirq_domain_free_irqs_common(domain, virq, 1);\n\t}\n\tmsi_domain_free_descs(dev, &ctrl);\nunlock:\n\tmsi_unlock_descs(dev);\n\treturn ret;\n}\n\nvoid msi_domain_depopulate_descs(struct device *dev, int virq_base, int nvec)\n{\n\tstruct msi_ctrl ctrl = {\n\t\t.domid\t= MSI_DEFAULT_DOMAIN,\n\t\t.first  = virq_base,\n\t\t.last\t= virq_base + nvec - 1,\n\t};\n\tstruct msi_desc *desc;\n\tstruct xarray *xa;\n\tunsigned long idx;\n\n\tif (!msi_ctrl_valid(dev, &ctrl))\n\t\treturn;\n\n\txa = &dev->msi.data->__domains[ctrl.domid].store;\n\txa_for_each_range(xa, idx, desc, ctrl.first, ctrl.last)\n\t\tdesc->irq = 0;\n}\n\n \nstatic bool msi_check_reservation_mode(struct irq_domain *domain,\n\t\t\t\t       struct msi_domain_info *info,\n\t\t\t\t       struct device *dev)\n{\n\tstruct msi_desc *desc;\n\n\tswitch(domain->bus_token) {\n\tcase DOMAIN_BUS_PCI_MSI:\n\tcase DOMAIN_BUS_PCI_DEVICE_MSI:\n\tcase DOMAIN_BUS_PCI_DEVICE_MSIX:\n\tcase DOMAIN_BUS_VMD_MSI:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!(info->flags & MSI_FLAG_MUST_REACTIVATE))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_PCI_MSI) && pci_msi_ignore_mask)\n\t\treturn false;\n\n\t \n\tdesc = msi_first_desc(dev, MSI_DESC_ALL);\n\treturn desc->pci.msi_attrib.is_msix || desc->pci.msi_attrib.can_mask;\n}\n\nstatic int msi_handle_pci_fail(struct irq_domain *domain, struct msi_desc *desc,\n\t\t\t       int allocated)\n{\n\tswitch(domain->bus_token) {\n\tcase DOMAIN_BUS_PCI_MSI:\n\tcase DOMAIN_BUS_PCI_DEVICE_MSI:\n\tcase DOMAIN_BUS_PCI_DEVICE_MSIX:\n\tcase DOMAIN_BUS_VMD_MSI:\n\t\tif (IS_ENABLED(CONFIG_PCI_MSI))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tif (desc->nvec_used > 1)\n\t\treturn 1;\n\n\t \n\treturn allocated ? allocated : -ENOSPC;\n}\n\n#define VIRQ_CAN_RESERVE\t0x01\n#define VIRQ_ACTIVATE\t\t0x02\n\nstatic int msi_init_virq(struct irq_domain *domain, int virq, unsigned int vflags)\n{\n\tstruct irq_data *irqd = irq_domain_get_irq_data(domain, virq);\n\tint ret;\n\n\tif (!(vflags & VIRQ_CAN_RESERVE)) {\n\t\tirqd_clr_can_reserve(irqd);\n\n\t\t \n\t\tif ((vflags & VIRQ_ACTIVATE) &&\n\t\t    irqd_affinity_is_managed(irqd) &&\n\t\t    !cpumask_intersects(irq_data_get_affinity_mask(irqd),\n\t\t\t\t\tcpu_online_mask)) {\n\t\t\t    irqd_set_managed_shutdown(irqd);\n\t\t\t    return 0;\n\t\t    }\n\t}\n\n\tif (!(vflags & VIRQ_ACTIVATE))\n\t\treturn 0;\n\n\tret = irq_domain_activate_irq(irqd, vflags & VIRQ_CAN_RESERVE);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (vflags & VIRQ_CAN_RESERVE)\n\t\tirqd_clr_activated(irqd);\n\treturn 0;\n}\n\nstatic int __msi_domain_alloc_irqs(struct device *dev, struct irq_domain *domain,\n\t\t\t\t   struct msi_ctrl *ctrl)\n{\n\tstruct xarray *xa = &dev->msi.data->__domains[ctrl->domid].store;\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct msi_domain_ops *ops = info->ops;\n\tunsigned int vflags = 0, allocated = 0;\n\tmsi_alloc_info_t arg = { };\n\tstruct msi_desc *desc;\n\tunsigned long idx;\n\tint i, ret, virq;\n\n\tret = msi_domain_prepare_irqs(domain, dev, ctrl->nirqs, &arg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (info->flags & MSI_FLAG_ACTIVATE_EARLY)\n\t\tvflags |= VIRQ_ACTIVATE;\n\n\t \n\tif (msi_check_reservation_mode(domain, info, dev))\n\t\tvflags |= VIRQ_CAN_RESERVE;\n\n\txa_for_each_range(xa, idx, desc, ctrl->first, ctrl->last) {\n\t\tif (!msi_desc_match(desc, MSI_DESC_NOTASSOCIATED))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WARN_ON_ONCE(allocated >= ctrl->nirqs))\n\t\t\treturn -EINVAL;\n\n\t\tif (ops->prepare_desc)\n\t\t\tops->prepare_desc(domain, &arg, desc);\n\n\t\tops->set_desc(&arg, desc);\n\n\t\tvirq = __irq_domain_alloc_irqs(domain, -1, desc->nvec_used,\n\t\t\t\t\t       dev_to_node(dev), &arg, false,\n\t\t\t\t\t       desc->affinity);\n\t\tif (virq < 0)\n\t\t\treturn msi_handle_pci_fail(domain, desc, allocated);\n\n\t\tfor (i = 0; i < desc->nvec_used; i++) {\n\t\t\tirq_set_msi_desc_off(virq, i, desc);\n\t\t\tirq_debugfs_copy_devname(virq + i, dev);\n\t\t\tret = msi_init_virq(domain, virq + i, vflags);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (info->flags & MSI_FLAG_DEV_SYSFS) {\n\t\t\tret = msi_sysfs_populate_desc(dev, desc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tallocated++;\n\t}\n\treturn 0;\n}\n\nstatic int msi_domain_alloc_simple_msi_descs(struct device *dev,\n\t\t\t\t\t     struct msi_domain_info *info,\n\t\t\t\t\t     struct msi_ctrl *ctrl)\n{\n\tif (!(info->flags & MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS))\n\t\treturn 0;\n\n\treturn msi_domain_add_simple_msi_descs(dev, ctrl);\n}\n\nstatic int __msi_domain_alloc_locked(struct device *dev, struct msi_ctrl *ctrl)\n{\n\tstruct msi_domain_info *info;\n\tstruct msi_domain_ops *ops;\n\tstruct irq_domain *domain;\n\tint ret;\n\n\tif (!msi_ctrl_valid(dev, ctrl))\n\t\treturn -EINVAL;\n\n\tdomain = msi_get_device_domain(dev, ctrl->domid);\n\tif (!domain)\n\t\treturn -ENODEV;\n\n\tinfo = domain->host_data;\n\n\tret = msi_domain_alloc_simple_msi_descs(dev, info, ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tops = info->ops;\n\tif (ops->domain_alloc_irqs)\n\t\treturn ops->domain_alloc_irqs(domain, dev, ctrl->nirqs);\n\n\treturn __msi_domain_alloc_irqs(dev, domain, ctrl);\n}\n\nstatic int msi_domain_alloc_locked(struct device *dev, struct msi_ctrl *ctrl)\n{\n\tint ret = __msi_domain_alloc_locked(dev, ctrl);\n\n\tif (ret)\n\t\tmsi_domain_free_locked(dev, ctrl);\n\treturn ret;\n}\n\n \nint msi_domain_alloc_irqs_range_locked(struct device *dev, unsigned int domid,\n\t\t\t\t       unsigned int first, unsigned int last)\n{\n\tstruct msi_ctrl ctrl = {\n\t\t.domid\t= domid,\n\t\t.first\t= first,\n\t\t.last\t= last,\n\t\t.nirqs\t= last + 1 - first,\n\t};\n\n\treturn msi_domain_alloc_locked(dev, &ctrl);\n}\n\n \nint msi_domain_alloc_irqs_range(struct device *dev, unsigned int domid,\n\t\t\t\tunsigned int first, unsigned int last)\n{\n\tint ret;\n\n\tmsi_lock_descs(dev);\n\tret = msi_domain_alloc_irqs_range_locked(dev, domid, first, last);\n\tmsi_unlock_descs(dev);\n\treturn ret;\n}\n\n \nint msi_domain_alloc_irqs_all_locked(struct device *dev, unsigned int domid, int nirqs)\n{\n\tstruct msi_ctrl ctrl = {\n\t\t.domid\t= domid,\n\t\t.first\t= 0,\n\t\t.last\t= msi_domain_get_hwsize(dev, domid) - 1,\n\t\t.nirqs\t= nirqs,\n\t};\n\n\treturn msi_domain_alloc_locked(dev, &ctrl);\n}\n\n \nstruct msi_map msi_domain_alloc_irq_at(struct device *dev, unsigned int domid, unsigned int index,\n\t\t\t\t       const struct irq_affinity_desc *affdesc,\n\t\t\t\t       union msi_instance_cookie *icookie)\n{\n\tstruct msi_ctrl ctrl = { .domid\t= domid, .nirqs = 1, };\n\tstruct irq_domain *domain;\n\tstruct msi_map map = { };\n\tstruct msi_desc *desc;\n\tint ret;\n\n\tmsi_lock_descs(dev);\n\tdomain = msi_get_device_domain(dev, domid);\n\tif (!domain) {\n\t\tmap.index = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tdesc = msi_alloc_desc(dev, 1, affdesc);\n\tif (!desc) {\n\t\tmap.index = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tif (icookie)\n\t\tdesc->data.icookie = *icookie;\n\n\tret = msi_insert_desc(dev, desc, domid, index);\n\tif (ret) {\n\t\tmap.index = ret;\n\t\tgoto unlock;\n\t}\n\n\tctrl.first = ctrl.last = desc->msi_index;\n\n\tret = __msi_domain_alloc_irqs(dev, domain, &ctrl);\n\tif (ret) {\n\t\tmap.index = ret;\n\t\tmsi_domain_free_locked(dev, &ctrl);\n\t} else {\n\t\tmap.index = desc->msi_index;\n\t\tmap.virq = desc->irq;\n\t}\nunlock:\n\tmsi_unlock_descs(dev);\n\treturn map;\n}\n\nstatic void __msi_domain_free_irqs(struct device *dev, struct irq_domain *domain,\n\t\t\t\t   struct msi_ctrl *ctrl)\n{\n\tstruct xarray *xa = &dev->msi.data->__domains[ctrl->domid].store;\n\tstruct msi_domain_info *info = domain->host_data;\n\tstruct irq_data *irqd;\n\tstruct msi_desc *desc;\n\tunsigned long idx;\n\tint i;\n\n\txa_for_each_range(xa, idx, desc, ctrl->first, ctrl->last) {\n\t\t \n\t\tif (!msi_desc_match(desc, MSI_DESC_ASSOCIATED))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < desc->nvec_used; i++) {\n\t\t\tirqd = irq_domain_get_irq_data(domain, desc->irq + i);\n\t\t\tif (irqd && irqd_is_activated(irqd))\n\t\t\t\tirq_domain_deactivate_irq(irqd);\n\t\t}\n\n\t\tirq_domain_free_irqs(desc->irq, desc->nvec_used);\n\t\tif (info->flags & MSI_FLAG_DEV_SYSFS)\n\t\t\tmsi_sysfs_remove_desc(dev, desc);\n\t\tdesc->irq = 0;\n\t}\n}\n\nstatic void msi_domain_free_locked(struct device *dev, struct msi_ctrl *ctrl)\n{\n\tstruct msi_domain_info *info;\n\tstruct msi_domain_ops *ops;\n\tstruct irq_domain *domain;\n\n\tif (!msi_ctrl_valid(dev, ctrl))\n\t\treturn;\n\n\tdomain = msi_get_device_domain(dev, ctrl->domid);\n\tif (!domain)\n\t\treturn;\n\n\tinfo = domain->host_data;\n\tops = info->ops;\n\n\tif (ops->domain_free_irqs)\n\t\tops->domain_free_irqs(domain, dev);\n\telse\n\t\t__msi_domain_free_irqs(dev, domain, ctrl);\n\n\tif (ops->msi_post_free)\n\t\tops->msi_post_free(domain, dev);\n\n\tif (info->flags & MSI_FLAG_FREE_MSI_DESCS)\n\t\tmsi_domain_free_descs(dev, ctrl);\n}\n\n \nvoid msi_domain_free_irqs_range_locked(struct device *dev, unsigned int domid,\n\t\t\t\t       unsigned int first, unsigned int last)\n{\n\tstruct msi_ctrl ctrl = {\n\t\t.domid\t= domid,\n\t\t.first\t= first,\n\t\t.last\t= last,\n\t};\n\tmsi_domain_free_locked(dev, &ctrl);\n}\n\n \nvoid msi_domain_free_irqs_range(struct device *dev, unsigned int domid,\n\t\t\t\tunsigned int first, unsigned int last)\n{\n\tmsi_lock_descs(dev);\n\tmsi_domain_free_irqs_range_locked(dev, domid, first, last);\n\tmsi_unlock_descs(dev);\n}\n\n \nvoid msi_domain_free_irqs_all_locked(struct device *dev, unsigned int domid)\n{\n\tmsi_domain_free_irqs_range_locked(dev, domid, 0,\n\t\t\t\t\t  msi_domain_get_hwsize(dev, domid) - 1);\n}\n\n \nvoid msi_domain_free_irqs_all(struct device *dev, unsigned int domid)\n{\n\tmsi_lock_descs(dev);\n\tmsi_domain_free_irqs_all_locked(dev, domid);\n\tmsi_unlock_descs(dev);\n}\n\n \nstruct msi_domain_info *msi_get_domain_info(struct irq_domain *domain)\n{\n\treturn (struct msi_domain_info *)domain->host_data;\n}\n\n \nbool msi_device_has_isolated_msi(struct device *dev)\n{\n\tstruct irq_domain *domain = dev_get_msi_domain(dev);\n\n\tfor (; domain; domain = domain->parent)\n\t\tif (domain->flags & IRQ_DOMAIN_FLAG_ISOLATED_MSI)\n\t\t\treturn true;\n\treturn arch_is_isolated_msi();\n}\nEXPORT_SYMBOL_GPL(msi_device_has_isolated_msi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}