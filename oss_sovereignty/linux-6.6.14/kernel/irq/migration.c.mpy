{
  "module_name": "migration.c",
  "hash_id": "ad6657ef9b468e724f625aa4e87a9c8c91f13738f6a3b953f17d18d3bc00f668",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/migration.c",
  "human_readable_source": "\n\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n\n#include \"internals.h\"\n\n \nbool irq_fixup_move_pending(struct irq_desc *desc, bool force_clear)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\n\tif (!irqd_is_setaffinity_pending(data))\n\t\treturn false;\n\n\t \n\tif (cpumask_any_and(desc->pending_mask, cpu_online_mask) >= nr_cpu_ids) {\n\t\tirqd_clr_move_pending(data);\n\t\treturn false;\n\t}\n\tif (force_clear)\n\t\tirqd_clr_move_pending(data);\n\treturn true;\n}\n\nvoid irq_move_masked_irq(struct irq_data *idata)\n{\n\tstruct irq_desc *desc = irq_data_to_desc(idata);\n\tstruct irq_data *data = &desc->irq_data;\n\tstruct irq_chip *chip = data->chip;\n\n\tif (likely(!irqd_is_setaffinity_pending(data)))\n\t\treturn;\n\n\tirqd_clr_move_pending(data);\n\n\t \n\tif (irqd_is_per_cpu(data)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (unlikely(cpumask_empty(desc->pending_mask)))\n\t\treturn;\n\n\tif (!chip->irq_set_affinity)\n\t\treturn;\n\n\tassert_raw_spin_locked(&desc->lock);\n\n\t \n\tif (cpumask_any_and(desc->pending_mask, cpu_online_mask) < nr_cpu_ids) {\n\t\tint ret;\n\n\t\tret = irq_do_set_affinity(data, desc->pending_mask, false);\n\t\t \n\t\tif (ret == -EBUSY) {\n\t\t\tirqd_set_move_pending(data);\n\t\t\treturn;\n\t\t}\n\t}\n\tcpumask_clear(desc->pending_mask);\n}\n\nvoid __irq_move_irq(struct irq_data *idata)\n{\n\tbool masked;\n\n\t \n\tidata = irq_desc_get_irq_data(irq_data_to_desc(idata));\n\n\tif (unlikely(irqd_irq_disabled(idata)))\n\t\treturn;\n\n\t \n\tmasked = irqd_irq_masked(idata);\n\tif (!masked)\n\t\tidata->chip->irq_mask(idata);\n\tirq_move_masked_irq(idata);\n\tif (!masked)\n\t\tidata->chip->irq_unmask(idata);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}