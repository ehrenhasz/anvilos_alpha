{
  "module_name": "handle.c",
  "hash_id": "fb0a8ad44ba14a99d44549e3f34f25be223b1b6e1e8bac6031cc88d5892e7125",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/handle.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n\n#include <asm/irq_regs.h>\n\n#include <trace/events/irq.h>\n\n#include \"internals.h\"\n\n#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER\nvoid (*handle_arch_irq)(struct pt_regs *) __ro_after_init;\n#endif\n\n \nvoid handle_bad_irq(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\n\tprint_irq_desc(irq, desc);\n\tkstat_incr_irqs_this_cpu(desc);\n\tack_bad_irq(irq);\n}\nEXPORT_SYMBOL_GPL(handle_bad_irq);\n\n \nirqreturn_t no_action(int cpl, void *dev_id)\n{\n\treturn IRQ_NONE;\n}\nEXPORT_SYMBOL_GPL(no_action);\n\nstatic void warn_no_thread(unsigned int irq, struct irqaction *action)\n{\n\tif (test_and_set_bit(IRQTF_WARNED, &action->thread_flags))\n\t\treturn;\n\n\tprintk(KERN_WARNING \"IRQ %d device %s returned IRQ_WAKE_THREAD \"\n\t       \"but no thread function available.\", irq, action->name);\n}\n\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action)\n{\n\t \n\tif (action->thread->flags & PF_EXITING)\n\t\treturn;\n\n\t \n\tif (test_and_set_bit(IRQTF_RUNTHREAD, &action->thread_flags))\n\t\treturn;\n\n\t \n\tdesc->threads_oneshot |= action->thread_mask;\n\n\t \n\tatomic_inc(&desc->threads_active);\n\n\twake_up_process(action->thread);\n}\n\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\tunsigned int irq = desc->irq_data.irq;\n\tstruct irqaction *action;\n\n\trecord_irq_time(desc);\n\n\tfor_each_action_of_desc(desc, action) {\n\t\tirqreturn_t res;\n\n\t\t \n\t\tif (irq_settings_can_thread(desc) &&\n\t\t    !(action->flags & (IRQF_NO_THREAD | IRQF_PERCPU | IRQF_ONESHOT)))\n\t\t\tlockdep_hardirq_threaded();\n\n\t\ttrace_irq_handler_entry(irq, action);\n\t\tres = action->handler(irq, action->dev_id);\n\t\ttrace_irq_handler_exit(irq, action, res);\n\n\t\tif (WARN_ONCE(!irqs_disabled(),\"irq %u handler %pS enabled interrupts\\n\",\n\t\t\t      irq, action->handler))\n\t\t\tlocal_irq_disable();\n\n\t\tswitch (res) {\n\t\tcase IRQ_WAKE_THREAD:\n\t\t\t \n\t\t\tif (unlikely(!action->thread_fn)) {\n\t\t\t\twarn_no_thread(irq, action);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__irq_wake_thread(desc, action);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tretval |= res;\n\t}\n\n\treturn retval;\n}\n\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc)\n{\n\tirqreturn_t retval;\n\n\tretval = __handle_irq_event_percpu(desc);\n\n\tadd_interrupt_randomness(desc->irq_data.irq);\n\n\tif (!irq_settings_no_debug(desc))\n\t\tnote_interrupt(desc, retval);\n\treturn retval;\n}\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}\n\n#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER\nint __init set_handle_irq(void (*handle_irq)(struct pt_regs *))\n{\n\tif (handle_arch_irq)\n\t\treturn -EBUSY;\n\n\thandle_arch_irq = handle_irq;\n\treturn 0;\n}\n\n \nasmlinkage void noinstr generic_handle_arch_irq(struct pt_regs *regs)\n{\n\tstruct pt_regs *old_regs;\n\n\tirq_enter();\n\told_regs = set_irq_regs(regs);\n\thandle_arch_irq(regs);\n\tset_irq_regs(old_regs);\n\tirq_exit();\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}