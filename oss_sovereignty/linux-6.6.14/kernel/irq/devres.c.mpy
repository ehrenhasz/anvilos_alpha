{
  "module_name": "devres.c",
  "hash_id": "8bf160c1f0486423016a9378e986d95c102c9f32d86b854973465cf038e5f803",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/devres.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#include \"internals.h\"\n\n \nstruct irq_devres {\n\tunsigned int irq;\n\tvoid *dev_id;\n};\n\nstatic void devm_irq_release(struct device *dev, void *res)\n{\n\tstruct irq_devres *this = res;\n\n\tfree_irq(this->irq, this->dev_id);\n}\n\nstatic int devm_irq_match(struct device *dev, void *res, void *data)\n{\n\tstruct irq_devres *this = res, *match = data;\n\n\treturn this->irq == match->irq && this->dev_id == match->dev_id;\n}\n\n \nint devm_request_threaded_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,\n\t\t\t      unsigned long irqflags, const char *devname,\n\t\t\t      void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tif (!devname)\n\t\tdevname = dev_name(dev);\n\n\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,\n\t\t\t\t  dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(devm_request_threaded_irq);\n\n \nint devm_request_any_context_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tif (!devname)\n\t\tdevname = dev_name(dev);\n\n\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);\n\tif (rc < 0) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(devm_request_any_context_irq);\n\n \nvoid devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\n\tstruct irq_devres match_data = { irq, dev_id };\n\n\tWARN_ON(devres_destroy(dev, devm_irq_release, devm_irq_match,\n\t\t\t       &match_data));\n\tfree_irq(irq, dev_id);\n}\nEXPORT_SYMBOL(devm_free_irq);\n\nstruct irq_desc_devres {\n\tunsigned int from;\n\tunsigned int cnt;\n};\n\nstatic void devm_irq_desc_release(struct device *dev, void *res)\n{\n\tstruct irq_desc_devres *this = res;\n\n\tirq_free_descs(this->from, this->cnt);\n}\n\n \nint __devm_irq_alloc_descs(struct device *dev, int irq, unsigned int from,\n\t\t\t   unsigned int cnt, int node, struct module *owner,\n\t\t\t   const struct irq_affinity_desc *affinity)\n{\n\tstruct irq_desc_devres *dr;\n\tint base;\n\n\tdr = devres_alloc(devm_irq_desc_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tbase = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);\n\tif (base < 0) {\n\t\tdevres_free(dr);\n\t\treturn base;\n\t}\n\n\tdr->from = base;\n\tdr->cnt = cnt;\n\tdevres_add(dev, dr);\n\n\treturn base;\n}\nEXPORT_SYMBOL_GPL(__devm_irq_alloc_descs);\n\n#ifdef CONFIG_GENERIC_IRQ_CHIP\n \nstruct irq_chip_generic *\ndevm_irq_alloc_generic_chip(struct device *dev, const char *name, int num_ct,\n\t\t\t    unsigned int irq_base, void __iomem *reg_base,\n\t\t\t    irq_flow_handler_t handler)\n{\n\tstruct irq_chip_generic *gc;\n\n\tgc = devm_kzalloc(dev, struct_size(gc, chip_types, num_ct), GFP_KERNEL);\n\tif (gc)\n\t\tirq_init_generic_chip(gc, name, num_ct,\n\t\t\t\t      irq_base, reg_base, handler);\n\n\treturn gc;\n}\nEXPORT_SYMBOL_GPL(devm_irq_alloc_generic_chip);\n\nstruct irq_generic_chip_devres {\n\tstruct irq_chip_generic *gc;\n\tu32 msk;\n\tunsigned int clr;\n\tunsigned int set;\n};\n\nstatic void devm_irq_remove_generic_chip(struct device *dev, void *res)\n{\n\tstruct irq_generic_chip_devres *this = res;\n\n\tirq_remove_generic_chip(this->gc, this->msk, this->clr, this->set);\n}\n\n \nint devm_irq_setup_generic_chip(struct device *dev, struct irq_chip_generic *gc,\n\t\t\t\tu32 msk, enum irq_gc_flags flags,\n\t\t\t\tunsigned int clr, unsigned int set)\n{\n\tstruct irq_generic_chip_devres *dr;\n\n\tdr = devres_alloc(devm_irq_remove_generic_chip,\n\t\t\t  sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tirq_setup_generic_chip(gc, msk, flags, clr, set);\n\n\tdr->gc = gc;\n\tdr->msk = msk;\n\tdr->clr = clr;\n\tdr->set = set;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_irq_setup_generic_chip);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}