{
  "module_name": "resend.c",
  "hash_id": "f50d1978992bb25d7cfd13214617c2ab04d89875622a42000eff6f110b250bd1",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/resend.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/interrupt.h>\n\n#include \"internals.h\"\n\n#ifdef CONFIG_HARDIRQS_SW_RESEND\n\n \nstatic HLIST_HEAD(irq_resend_list);\nstatic DEFINE_RAW_SPINLOCK(irq_resend_lock);\n\n \nstatic void resend_irqs(struct tasklet_struct *unused)\n{\n\tstruct irq_desc *desc;\n\n\traw_spin_lock_irq(&irq_resend_lock);\n\twhile (!hlist_empty(&irq_resend_list)) {\n\t\tdesc = hlist_entry(irq_resend_list.first, struct irq_desc,\n\t\t\t\t   resend_node);\n\t\thlist_del_init(&desc->resend_node);\n\t\traw_spin_unlock(&irq_resend_lock);\n\t\tdesc->handle_irq(desc);\n\t\traw_spin_lock(&irq_resend_lock);\n\t}\n\traw_spin_unlock_irq(&irq_resend_lock);\n}\n\n \nstatic DECLARE_TASKLET(resend_tasklet, resend_irqs);\n\nstatic int irq_sw_resend(struct irq_desc *desc)\n{\n\t \n\tif (handle_enforce_irqctx(&desc->irq_data))\n\t\treturn -EINVAL;\n\n\t \n\tif (irq_settings_is_nested_thread(desc)) {\n\t\t \n\t\tif (!desc->parent_irq)\n\t\t\treturn -EINVAL;\n\n\t\tdesc = irq_to_desc(desc->parent_irq);\n\t\tif (!desc)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\traw_spin_lock(&irq_resend_lock);\n\tif (hlist_unhashed(&desc->resend_node))\n\t\thlist_add_head(&desc->resend_node, &irq_resend_list);\n\traw_spin_unlock(&irq_resend_lock);\n\ttasklet_schedule(&resend_tasklet);\n\treturn 0;\n}\n\nvoid clear_irq_resend(struct irq_desc *desc)\n{\n\traw_spin_lock(&irq_resend_lock);\n\thlist_del_init(&desc->resend_node);\n\traw_spin_unlock(&irq_resend_lock);\n}\n\nvoid irq_resend_init(struct irq_desc *desc)\n{\n\tINIT_HLIST_NODE(&desc->resend_node);\n}\n#else\nvoid clear_irq_resend(struct irq_desc *desc) {}\nvoid irq_resend_init(struct irq_desc *desc) {}\n\nstatic int irq_sw_resend(struct irq_desc *desc)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int try_retrigger(struct irq_desc *desc)\n{\n\tif (desc->irq_data.chip->irq_retrigger)\n\t\treturn desc->irq_data.chip->irq_retrigger(&desc->irq_data);\n\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\treturn irq_chip_retrigger_hierarchy(&desc->irq_data);\n#else\n\treturn 0;\n#endif\n}\n\n \nint check_irq_resend(struct irq_desc *desc, bool inject)\n{\n\tint err = 0;\n\n\t \n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn -EBUSY;\n\n\tif (!(desc->istate & IRQS_PENDING) && !inject)\n\t\treturn 0;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\n\tif (!try_retrigger(desc))\n\t\terr = irq_sw_resend(desc);\n\n\t \n\tif (!err)\n\t\tdesc->istate |= IRQS_REPLAY;\n\treturn err;\n}\n\n#ifdef CONFIG_GENERIC_IRQ_INJECTION\n \nint irq_inject_interrupt(unsigned int irq)\n{\n\tstruct irq_desc *desc;\n\tunsigned long flags;\n\tint err;\n\n\t \n\tif (!irq_set_irqchip_state(irq, IRQCHIP_STATE_PENDING, true))\n\t\treturn 0;\n\n\t \n\tdesc = irq_get_desc_buslock(irq, &flags, 0);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t \n\tif ((desc->istate & IRQS_NMI) || !irqd_is_activated(&desc->irq_data))\n\t\terr = -EINVAL;\n\telse\n\t\terr = check_irq_resend(desc, true);\n\n\tirq_put_desc_busunlock(desc, flags);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(irq_inject_interrupt);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}