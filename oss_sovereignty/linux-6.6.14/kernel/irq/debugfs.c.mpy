{
  "module_name": "debugfs.c",
  "hash_id": "7bb506eb895adc78227befcd7be7592b54a90571b8fe84f2c5cc931c49b3cf84",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/debugfs.c",
  "human_readable_source": "\n\n\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/uaccess.h>\n\n#include \"internals.h\"\n\nstatic struct dentry *irq_dir;\n\nstruct irq_bit_descr {\n\tunsigned int\tmask;\n\tchar\t\t*name;\n};\n#define BIT_MASK_DESCR(m)\t{ .mask = m, .name = #m }\n\nstatic void irq_debug_show_bits(struct seq_file *m, int ind, unsigned int state,\n\t\t\t\tconst struct irq_bit_descr *sd, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++, sd++) {\n\t\tif (state & sd->mask)\n\t\t\tseq_printf(m, \"%*s%s\\n\", ind + 12, \"\", sd->name);\n\t}\n}\n\n#ifdef CONFIG_SMP\nstatic void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tconst struct cpumask *msk;\n\n\tmsk = irq_data_get_affinity_mask(data);\n\tseq_printf(m, \"affinity: %*pbl\\n\", cpumask_pr_args(msk));\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tmsk = irq_data_get_effective_affinity_mask(data);\n\tseq_printf(m, \"effectiv: %*pbl\\n\", cpumask_pr_args(msk));\n#endif\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\tmsk = desc->pending_mask;\n\tseq_printf(m, \"pending:  %*pbl\\n\", cpumask_pr_args(msk));\n#endif\n}\n#else\nstatic void irq_debug_show_masks(struct seq_file *m, struct irq_desc *desc) { }\n#endif\n\nstatic const struct irq_bit_descr irqchip_flags[] = {\n\tBIT_MASK_DESCR(IRQCHIP_SET_TYPE_MASKED),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_IF_HANDLED),\n\tBIT_MASK_DESCR(IRQCHIP_MASK_ON_SUSPEND),\n\tBIT_MASK_DESCR(IRQCHIP_ONOFFLINE_ENABLED),\n\tBIT_MASK_DESCR(IRQCHIP_SKIP_SET_WAKE),\n\tBIT_MASK_DESCR(IRQCHIP_ONESHOT_SAFE),\n\tBIT_MASK_DESCR(IRQCHIP_EOI_THREADED),\n\tBIT_MASK_DESCR(IRQCHIP_SUPPORTS_LEVEL_MSI),\n\tBIT_MASK_DESCR(IRQCHIP_SUPPORTS_NMI),\n\tBIT_MASK_DESCR(IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND),\n\tBIT_MASK_DESCR(IRQCHIP_IMMUTABLE),\n};\n\nstatic void\nirq_debug_show_chip(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tstruct irq_chip *chip = data->chip;\n\n\tif (!chip) {\n\t\tseq_printf(m, \"chip: None\\n\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"%*schip:    \", ind, \"\");\n\tif (chip->irq_print_chip)\n\t\tchip->irq_print_chip(data, m);\n\telse\n\t\tseq_printf(m, \"%s\", chip->name);\n\tseq_printf(m, \"\\n%*sflags:   0x%lx\\n\", ind + 1, \"\", chip->flags);\n\tirq_debug_show_bits(m, ind, chip->flags, irqchip_flags,\n\t\t\t    ARRAY_SIZE(irqchip_flags));\n}\n\nstatic void\nirq_debug_show_data(struct seq_file *m, struct irq_data *data, int ind)\n{\n\tseq_printf(m, \"%*sdomain:  %s\\n\", ind, \"\",\n\t\t   data->domain ? data->domain->name : \"\");\n\tseq_printf(m, \"%*shwirq:   0x%lx\\n\", ind + 1, \"\", data->hwirq);\n\tirq_debug_show_chip(m, data, ind + 1);\n\tif (data->domain && data->domain->ops && data->domain->ops->debug_show)\n\t\tdata->domain->ops->debug_show(m, NULL, data, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!data->parent_data)\n\t\treturn;\n\tseq_printf(m, \"%*sparent:\\n\", ind + 1, \"\");\n\tirq_debug_show_data(m, data->parent_data, ind + 4);\n#endif\n}\n\nstatic const struct irq_bit_descr irqdata_states[] = {\n\tBIT_MASK_DESCR(IRQ_TYPE_EDGE_RISING),\n\tBIT_MASK_DESCR(IRQ_TYPE_EDGE_FALLING),\n\tBIT_MASK_DESCR(IRQ_TYPE_LEVEL_HIGH),\n\tBIT_MASK_DESCR(IRQ_TYPE_LEVEL_LOW),\n\tBIT_MASK_DESCR(IRQD_LEVEL),\n\n\tBIT_MASK_DESCR(IRQD_ACTIVATED),\n\tBIT_MASK_DESCR(IRQD_IRQ_STARTED),\n\tBIT_MASK_DESCR(IRQD_IRQ_DISABLED),\n\tBIT_MASK_DESCR(IRQD_IRQ_MASKED),\n\tBIT_MASK_DESCR(IRQD_IRQ_INPROGRESS),\n\n\tBIT_MASK_DESCR(IRQD_PER_CPU),\n\tBIT_MASK_DESCR(IRQD_NO_BALANCING),\n\n\tBIT_MASK_DESCR(IRQD_SINGLE_TARGET),\n\tBIT_MASK_DESCR(IRQD_MOVE_PCNTXT),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_SET),\n\tBIT_MASK_DESCR(IRQD_SETAFFINITY_PENDING),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_MANAGED),\n\tBIT_MASK_DESCR(IRQD_AFFINITY_ON_ACTIVATE),\n\tBIT_MASK_DESCR(IRQD_MANAGED_SHUTDOWN),\n\tBIT_MASK_DESCR(IRQD_CAN_RESERVE),\n\n\tBIT_MASK_DESCR(IRQD_FORWARDED_TO_VCPU),\n\n\tBIT_MASK_DESCR(IRQD_WAKEUP_STATE),\n\tBIT_MASK_DESCR(IRQD_WAKEUP_ARMED),\n\n\tBIT_MASK_DESCR(IRQD_DEFAULT_TRIGGER_SET),\n\n\tBIT_MASK_DESCR(IRQD_HANDLE_ENFORCE_IRQCTX),\n\n\tBIT_MASK_DESCR(IRQD_IRQ_ENABLED_ON_SUSPEND),\n\n\tBIT_MASK_DESCR(IRQD_RESEND_WHEN_IN_PROGRESS),\n};\n\nstatic const struct irq_bit_descr irqdesc_states[] = {\n\tBIT_MASK_DESCR(_IRQ_NOPROBE),\n\tBIT_MASK_DESCR(_IRQ_NOREQUEST),\n\tBIT_MASK_DESCR(_IRQ_NOTHREAD),\n\tBIT_MASK_DESCR(_IRQ_NOAUTOEN),\n\tBIT_MASK_DESCR(_IRQ_NESTED_THREAD),\n\tBIT_MASK_DESCR(_IRQ_PER_CPU_DEVID),\n\tBIT_MASK_DESCR(_IRQ_IS_POLLED),\n\tBIT_MASK_DESCR(_IRQ_DISABLE_UNLAZY),\n\tBIT_MASK_DESCR(_IRQ_HIDDEN),\n};\n\nstatic const struct irq_bit_descr irqdesc_istates[] = {\n\tBIT_MASK_DESCR(IRQS_AUTODETECT),\n\tBIT_MASK_DESCR(IRQS_SPURIOUS_DISABLED),\n\tBIT_MASK_DESCR(IRQS_POLL_INPROGRESS),\n\tBIT_MASK_DESCR(IRQS_ONESHOT),\n\tBIT_MASK_DESCR(IRQS_REPLAY),\n\tBIT_MASK_DESCR(IRQS_WAITING),\n\tBIT_MASK_DESCR(IRQS_PENDING),\n\tBIT_MASK_DESCR(IRQS_SUSPENDED),\n\tBIT_MASK_DESCR(IRQS_NMI),\n};\n\n\nstatic int irq_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_desc *desc = m->private;\n\tstruct irq_data *data;\n\n\traw_spin_lock_irq(&desc->lock);\n\tdata = irq_desc_get_irq_data(desc);\n\tseq_printf(m, \"handler:  %ps\\n\", desc->handle_irq);\n\tseq_printf(m, \"device:   %s\\n\", desc->dev_name);\n\tseq_printf(m, \"status:   0x%08x\\n\", desc->status_use_accessors);\n\tirq_debug_show_bits(m, 0, desc->status_use_accessors, irqdesc_states,\n\t\t\t    ARRAY_SIZE(irqdesc_states));\n\tseq_printf(m, \"istate:   0x%08x\\n\", desc->istate);\n\tirq_debug_show_bits(m, 0, desc->istate, irqdesc_istates,\n\t\t\t    ARRAY_SIZE(irqdesc_istates));\n\tseq_printf(m, \"ddepth:   %u\\n\", desc->depth);\n\tseq_printf(m, \"wdepth:   %u\\n\", desc->wake_depth);\n\tseq_printf(m, \"dstate:   0x%08x\\n\", irqd_get(data));\n\tirq_debug_show_bits(m, 0, irqd_get(data), irqdata_states,\n\t\t\t    ARRAY_SIZE(irqdata_states));\n\tseq_printf(m, \"node:     %d\\n\", irq_data_get_node(data));\n\tirq_debug_show_masks(m, desc);\n\tirq_debug_show_data(m, data, 0);\n\traw_spin_unlock_irq(&desc->lock);\n\treturn 0;\n}\n\nstatic int irq_debug_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_debug_show, inode->i_private);\n}\n\nstatic ssize_t irq_debug_write(struct file *file, const char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct irq_desc *desc = file_inode(file)->i_private;\n\tchar buf[8] = { 0, };\n\tsize_t size;\n\n\tsize = min(sizeof(buf) - 1, count);\n\tif (copy_from_user(buf, user_buf, size))\n\t\treturn -EFAULT;\n\n\tif (!strncmp(buf, \"trigger\", size)) {\n\t\tint err = irq_inject_interrupt(irq_desc_get_irq(desc));\n\n\t\treturn err ? err : count;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations dfs_irq_ops = {\n\t.open\t\t= irq_debug_open,\n\t.write\t\t= irq_debug_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nvoid irq_debugfs_copy_devname(int irq, struct device *dev)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tconst char *name = dev_name(dev);\n\n\tif (name)\n\t\tdesc->dev_name = kstrdup(name, GFP_KERNEL);\n}\n\nvoid irq_add_debugfs_entry(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [10];\n\n\tif (!irq_dir || !desc || desc->debugfs_file)\n\t\treturn;\n\n\tsprintf(name, \"%d\", irq);\n\tdesc->debugfs_file = debugfs_create_file(name, 0644, irq_dir, desc,\n\t\t\t\t\t\t &dfs_irq_ops);\n}\n\nstatic int __init irq_debugfs_init(void)\n{\n\tstruct dentry *root_dir;\n\tint irq;\n\n\troot_dir = debugfs_create_dir(\"irq\", NULL);\n\n\tirq_domain_debugfs_init(root_dir);\n\n\tirq_dir = debugfs_create_dir(\"irqs\", root_dir);\n\n\tirq_lock_sparse();\n\tfor_each_active_irq(irq)\n\t\tirq_add_debugfs_entry(irq, irq_to_desc(irq));\n\tirq_unlock_sparse();\n\n\treturn 0;\n}\n__initcall(irq_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}