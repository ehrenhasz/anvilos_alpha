{
  "module_name": "cpuhotplug.c",
  "hash_id": "84fb8876638c3600ffe8aac25ad9aa46472b22bd71ef441bb9fd1e913ee2e1d5",
  "original_prompt": "Ingested from linux-6.6.14/kernel/irq/cpuhotplug.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/ratelimit.h>\n#include <linux/irq.h>\n#include <linux/sched/isolation.h>\n\n#include \"internals.h\"\n\n \nstatic inline bool irq_needs_fixup(struct irq_data *d)\n{\n\tconst struct cpumask *m = irq_data_get_effective_affinity_mask(d);\n\tunsigned int cpu = smp_processor_id();\n\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t \n\tif (cpumask_empty(m))\n\t\tm = irq_data_get_affinity_mask(d);\n\n\t \n\tif (cpumask_any_but(m, cpu) < nr_cpu_ids &&\n\t    cpumask_any_and(m, cpu_online_mask) >= nr_cpu_ids) {\n\t\t \n\t\tpr_warn(\"Eff. affinity %*pbl of IRQ %u contains only offline CPUs after offlining CPU %u\\n\",\n\t\t\tcpumask_pr_args(m), d->irq, cpu);\n\t\treturn true;\n\t}\n#endif\n\treturn cpumask_test_cpu(cpu, m);\n}\n\nstatic bool migrate_one_irq(struct irq_desc *desc)\n{\n\tstruct irq_data *d = irq_desc_get_irq_data(desc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(d);\n\tbool maskchip = !irq_can_move_pcntxt(d) && !irqd_irq_masked(d);\n\tconst struct cpumask *affinity;\n\tbool brokeaff = false;\n\tint err;\n\n\t \n\tif (!chip || !chip->irq_set_affinity) {\n\t\tpr_debug(\"IRQ %u: Unable to migrate away\\n\", d->irq);\n\t\treturn false;\n\t}\n\n\t \n\tif (irqd_is_per_cpu(d) || !irqd_is_started(d) || !irq_needs_fixup(d)) {\n\t\t \n\t\tirq_fixup_move_pending(desc, false);\n\t\treturn false;\n\t}\n\n\t \n\tirq_force_complete_move(desc);\n\n\t \n\tif (irq_fixup_move_pending(desc, true))\n\t\taffinity = irq_desc_get_pending_mask(desc);\n\telse\n\t\taffinity = irq_data_get_affinity_mask(d);\n\n\t \n\tif (maskchip && chip->irq_mask)\n\t\tchip->irq_mask(d);\n\n\tif (cpumask_any_and(affinity, cpu_online_mask) >= nr_cpu_ids) {\n\t\t \n\t\tif (irqd_affinity_is_managed(d)) {\n\t\t\tirqd_set_managed_shutdown(d);\n\t\t\tirq_shutdown_and_deactivate(desc);\n\t\t\treturn false;\n\t\t}\n\t\taffinity = cpu_online_mask;\n\t\tbrokeaff = true;\n\t}\n\t \n\terr = irq_do_set_affinity(d, affinity, false);\n\tif (err) {\n\t\tpr_warn_ratelimited(\"IRQ%u: set affinity failed(%d).\\n\",\n\t\t\t\t    d->irq, err);\n\t\tbrokeaff = false;\n\t}\n\n\tif (maskchip && chip->irq_unmask)\n\t\tchip->irq_unmask(d);\n\n\treturn brokeaff;\n}\n\n \nvoid irq_migrate_all_off_this_cpu(void)\n{\n\tstruct irq_desc *desc;\n\tunsigned int irq;\n\n\tfor_each_active_irq(irq) {\n\t\tbool affinity_broken;\n\n\t\tdesc = irq_to_desc(irq);\n\t\traw_spin_lock(&desc->lock);\n\t\taffinity_broken = migrate_one_irq(desc);\n\t\traw_spin_unlock(&desc->lock);\n\n\t\tif (affinity_broken) {\n\t\t\tpr_debug_ratelimited(\"IRQ %u: no longer affine to CPU%u\\n\",\n\t\t\t\t\t    irq, smp_processor_id());\n\t\t}\n\t}\n}\n\nstatic bool hk_should_isolate(struct irq_data *data, unsigned int cpu)\n{\n\tconst struct cpumask *hk_mask;\n\n\tif (!housekeeping_enabled(HK_TYPE_MANAGED_IRQ))\n\t\treturn false;\n\n\thk_mask = housekeeping_cpumask(HK_TYPE_MANAGED_IRQ);\n\tif (cpumask_subset(irq_data_get_effective_affinity_mask(data), hk_mask))\n\t\treturn false;\n\n\treturn cpumask_test_cpu(cpu, hk_mask);\n}\n\nstatic void irq_restore_affinity_of_irq(struct irq_desc *desc, unsigned int cpu)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tconst struct cpumask *affinity = irq_data_get_affinity_mask(data);\n\n\tif (!irqd_affinity_is_managed(data) || !desc->action ||\n\t    !irq_data_get_irq_chip(data) || !cpumask_test_cpu(cpu, affinity))\n\t\treturn;\n\n\tif (irqd_is_managed_and_shutdown(data)) {\n\t\tirq_startup(desc, IRQ_RESEND, IRQ_START_COND);\n\t\treturn;\n\t}\n\n\t \n\tif (!irqd_is_single_target(data) || hk_should_isolate(data, cpu))\n\t\tirq_set_affinity_locked(data, affinity, false);\n}\n\n \nint irq_affinity_online_cpu(unsigned int cpu)\n{\n\tstruct irq_desc *desc;\n\tunsigned int irq;\n\n\tirq_lock_sparse();\n\tfor_each_active_irq(irq) {\n\t\tdesc = irq_to_desc(irq);\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tirq_restore_affinity_of_irq(desc, cpu);\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tirq_unlock_sparse();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}