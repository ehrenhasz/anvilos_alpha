{
  "module_name": "reboot.c",
  "hash_id": "158650f05d42d33b29b68ae8c8cb40b346470ed73fc01f9003febfa409c46dc7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/reboot.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"reboot: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/ctype.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/kmod.h>\n#include <linux/kmsg_dump.h>\n#include <linux/reboot.h>\n#include <linux/suspend.h>\n#include <linux/syscalls.h>\n#include <linux/syscore_ops.h>\n#include <linux/uaccess.h>\n\n \n\nstatic int C_A_D = 1;\nstruct pid *cad_pid;\nEXPORT_SYMBOL(cad_pid);\n\n#if defined(CONFIG_ARM)\n#define DEFAULT_REBOOT_MODE\t\t= REBOOT_HARD\n#else\n#define DEFAULT_REBOOT_MODE\n#endif\nenum reboot_mode reboot_mode DEFAULT_REBOOT_MODE;\nEXPORT_SYMBOL_GPL(reboot_mode);\nenum reboot_mode panic_reboot_mode = REBOOT_UNDEFINED;\n\n \nint reboot_default = 1;\nint reboot_cpu;\nenum reboot_type reboot_type = BOOT_ACPI;\nint reboot_force;\n\nstruct sys_off_handler {\n\tstruct notifier_block nb;\n\tint (*sys_off_cb)(struct sys_off_data *data);\n\tvoid *cb_data;\n\tenum sys_off_mode mode;\n\tbool blocking;\n\tvoid *list;\n};\n\n \nvoid __weak (*pm_power_off)(void);\n\n \nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tsystem_state = SYSTEM_RESTART;\n\tmachine_emergency_restart();\n}\nEXPORT_SYMBOL_GPL(emergency_restart);\n\nvoid kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}\n\n \nint register_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&reboot_notifier_list, nb);\n}\nEXPORT_SYMBOL(register_reboot_notifier);\n\n \nint unregister_reboot_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&reboot_notifier_list, nb);\n}\nEXPORT_SYMBOL(unregister_reboot_notifier);\n\nstatic void devm_unregister_reboot_notifier(struct device *dev, void *res)\n{\n\tWARN_ON(unregister_reboot_notifier(*(struct notifier_block **)res));\n}\n\nint devm_register_reboot_notifier(struct device *dev, struct notifier_block *nb)\n{\n\tstruct notifier_block **rcnb;\n\tint ret;\n\n\trcnb = devres_alloc(devm_unregister_reboot_notifier,\n\t\t\t    sizeof(*rcnb), GFP_KERNEL);\n\tif (!rcnb)\n\t\treturn -ENOMEM;\n\n\tret = register_reboot_notifier(nb);\n\tif (!ret) {\n\t\t*rcnb = nb;\n\t\tdevres_add(dev, rcnb);\n\t} else {\n\t\tdevres_free(rcnb);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(devm_register_reboot_notifier);\n\n \nstatic ATOMIC_NOTIFIER_HEAD(restart_handler_list);\n\n \nint register_restart_handler(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&restart_handler_list, nb);\n}\nEXPORT_SYMBOL(register_restart_handler);\n\n \nint unregister_restart_handler(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&restart_handler_list, nb);\n}\nEXPORT_SYMBOL(unregister_restart_handler);\n\n \nvoid do_kernel_restart(char *cmd)\n{\n\tatomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd);\n}\n\nvoid migrate_to_reboot_cpu(void)\n{\n\t \n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t \n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t \n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t \n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}\n\n \nstatic BLOCKING_NOTIFIER_HEAD(restart_prep_handler_list);\n\nstatic void do_kernel_restart_prepare(void)\n{\n\tblocking_notifier_call_chain(&restart_prep_handler_list, 0, NULL);\n}\n\n \nvoid kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tdo_kernel_restart_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tif (!cmd)\n\t\tpr_emerg(\"Restarting system\\n\");\n\telse\n\t\tpr_emerg(\"Restarting system with command '%s'\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_restart(cmd);\n}\nEXPORT_SYMBOL_GPL(kernel_restart);\n\nstatic void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n\t\t(state == SYSTEM_HALT) ? SYS_HALT : SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}\n \nvoid kernel_halt(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_HALT);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"System halted\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_halt();\n}\nEXPORT_SYMBOL_GPL(kernel_halt);\n\n \nstatic BLOCKING_NOTIFIER_HEAD(power_off_prep_handler_list);\n\n \nstatic ATOMIC_NOTIFIER_HEAD(power_off_handler_list);\n\nstatic int sys_off_notify(struct notifier_block *nb,\n\t\t\t  unsigned long mode, void *cmd)\n{\n\tstruct sys_off_handler *handler;\n\tstruct sys_off_data data = {};\n\n\thandler = container_of(nb, struct sys_off_handler, nb);\n\tdata.cb_data = handler->cb_data;\n\tdata.mode = mode;\n\tdata.cmd = cmd;\n\n\treturn handler->sys_off_cb(&data);\n}\n\nstatic struct sys_off_handler platform_sys_off_handler;\n\nstatic struct sys_off_handler *alloc_sys_off_handler(int priority)\n{\n\tstruct sys_off_handler *handler;\n\tgfp_t flags;\n\n\t \n\tif (priority == SYS_OFF_PRIO_PLATFORM) {\n\t\thandler = &platform_sys_off_handler;\n\t\tif (handler->cb_data)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t} else {\n\t\tif (system_state > SYSTEM_RUNNING)\n\t\t\tflags = GFP_ATOMIC;\n\t\telse\n\t\t\tflags = GFP_KERNEL;\n\n\t\thandler = kzalloc(sizeof(*handler), flags);\n\t\tif (!handler)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn handler;\n}\n\nstatic void free_sys_off_handler(struct sys_off_handler *handler)\n{\n\tif (handler == &platform_sys_off_handler)\n\t\tmemset(handler, 0, sizeof(*handler));\n\telse\n\t\tkfree(handler);\n}\n\n \nstruct sys_off_handler *\nregister_sys_off_handler(enum sys_off_mode mode,\n\t\t\t int priority,\n\t\t\t int (*callback)(struct sys_off_data *data),\n\t\t\t void *cb_data)\n{\n\tstruct sys_off_handler *handler;\n\tint err;\n\n\thandler = alloc_sys_off_handler(priority);\n\tif (IS_ERR(handler))\n\t\treturn handler;\n\n\tswitch (mode) {\n\tcase SYS_OFF_MODE_POWER_OFF_PREPARE:\n\t\thandler->list = &power_off_prep_handler_list;\n\t\thandler->blocking = true;\n\t\tbreak;\n\n\tcase SYS_OFF_MODE_POWER_OFF:\n\t\thandler->list = &power_off_handler_list;\n\t\tbreak;\n\n\tcase SYS_OFF_MODE_RESTART_PREPARE:\n\t\thandler->list = &restart_prep_handler_list;\n\t\thandler->blocking = true;\n\t\tbreak;\n\n\tcase SYS_OFF_MODE_RESTART:\n\t\thandler->list = &restart_handler_list;\n\t\tbreak;\n\n\tdefault:\n\t\tfree_sys_off_handler(handler);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\thandler->nb.notifier_call = sys_off_notify;\n\thandler->nb.priority = priority;\n\thandler->sys_off_cb = callback;\n\thandler->cb_data = cb_data;\n\thandler->mode = mode;\n\n\tif (handler->blocking) {\n\t\tif (priority == SYS_OFF_PRIO_DEFAULT)\n\t\t\terr = blocking_notifier_chain_register(handler->list,\n\t\t\t\t\t\t\t       &handler->nb);\n\t\telse\n\t\t\terr = blocking_notifier_chain_register_unique_prio(handler->list,\n\t\t\t\t\t\t\t\t\t   &handler->nb);\n\t} else {\n\t\tif (priority == SYS_OFF_PRIO_DEFAULT)\n\t\t\terr = atomic_notifier_chain_register(handler->list,\n\t\t\t\t\t\t\t     &handler->nb);\n\t\telse\n\t\t\terr = atomic_notifier_chain_register_unique_prio(handler->list,\n\t\t\t\t\t\t\t\t\t &handler->nb);\n\t}\n\n\tif (err) {\n\t\tfree_sys_off_handler(handler);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn handler;\n}\nEXPORT_SYMBOL_GPL(register_sys_off_handler);\n\n \nvoid unregister_sys_off_handler(struct sys_off_handler *handler)\n{\n\tint err;\n\n\tif (IS_ERR_OR_NULL(handler))\n\t\treturn;\n\n\tif (handler->blocking)\n\t\terr = blocking_notifier_chain_unregister(handler->list,\n\t\t\t\t\t\t\t &handler->nb);\n\telse\n\t\terr = atomic_notifier_chain_unregister(handler->list,\n\t\t\t\t\t\t       &handler->nb);\n\n\t \n\tWARN_ON(err);\n\n\tfree_sys_off_handler(handler);\n}\nEXPORT_SYMBOL_GPL(unregister_sys_off_handler);\n\nstatic void devm_unregister_sys_off_handler(void *data)\n{\n\tstruct sys_off_handler *handler = data;\n\n\tunregister_sys_off_handler(handler);\n}\n\n \nint devm_register_sys_off_handler(struct device *dev,\n\t\t\t\t  enum sys_off_mode mode,\n\t\t\t\t  int priority,\n\t\t\t\t  int (*callback)(struct sys_off_data *data),\n\t\t\t\t  void *cb_data)\n{\n\tstruct sys_off_handler *handler;\n\n\thandler = register_sys_off_handler(mode, priority, callback, cb_data);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\n\treturn devm_add_action_or_reset(dev, devm_unregister_sys_off_handler,\n\t\t\t\t\thandler);\n}\nEXPORT_SYMBOL_GPL(devm_register_sys_off_handler);\n\n \nint devm_register_power_off_handler(struct device *dev,\n\t\t\t\t    int (*callback)(struct sys_off_data *data),\n\t\t\t\t    void *cb_data)\n{\n\treturn devm_register_sys_off_handler(dev,\n\t\t\t\t\t     SYS_OFF_MODE_POWER_OFF,\n\t\t\t\t\t     SYS_OFF_PRIO_DEFAULT,\n\t\t\t\t\t     callback, cb_data);\n}\nEXPORT_SYMBOL_GPL(devm_register_power_off_handler);\n\n \nint devm_register_restart_handler(struct device *dev,\n\t\t\t\t  int (*callback)(struct sys_off_data *data),\n\t\t\t\t  void *cb_data)\n{\n\treturn devm_register_sys_off_handler(dev,\n\t\t\t\t\t     SYS_OFF_MODE_RESTART,\n\t\t\t\t\t     SYS_OFF_PRIO_DEFAULT,\n\t\t\t\t\t     callback, cb_data);\n}\nEXPORT_SYMBOL_GPL(devm_register_restart_handler);\n\nstatic struct sys_off_handler *platform_power_off_handler;\n\nstatic int platform_power_off_notify(struct sys_off_data *data)\n{\n\tvoid (*platform_power_power_off_cb)(void) = data->cb_data;\n\n\tplatform_power_power_off_cb();\n\n\treturn NOTIFY_DONE;\n}\n\n \nint register_platform_power_off(void (*power_off)(void))\n{\n\tstruct sys_off_handler *handler;\n\n\thandler = register_sys_off_handler(SYS_OFF_MODE_POWER_OFF,\n\t\t\t\t\t   SYS_OFF_PRIO_PLATFORM,\n\t\t\t\t\t   platform_power_off_notify,\n\t\t\t\t\t   power_off);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\n\tplatform_power_off_handler = handler;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(register_platform_power_off);\n\n \nvoid unregister_platform_power_off(void (*power_off)(void))\n{\n\tif (platform_power_off_handler &&\n\t    platform_power_off_handler->cb_data == power_off) {\n\t\tunregister_sys_off_handler(platform_power_off_handler);\n\t\tplatform_power_off_handler = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(unregister_platform_power_off);\n\nstatic int legacy_pm_power_off(struct sys_off_data *data)\n{\n\tif (pm_power_off)\n\t\tpm_power_off();\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void do_kernel_power_off_prepare(void)\n{\n\tblocking_notifier_call_chain(&power_off_prep_handler_list, 0, NULL);\n}\n\n \nvoid do_kernel_power_off(void)\n{\n\tstruct sys_off_handler *sys_off = NULL;\n\n\t \n\tif (pm_power_off)\n\t\tsys_off = register_sys_off_handler(SYS_OFF_MODE_POWER_OFF,\n\t\t\t\t\t\t   SYS_OFF_PRIO_DEFAULT,\n\t\t\t\t\t\t   legacy_pm_power_off, NULL);\n\n\tatomic_notifier_call_chain(&power_off_handler_list, 0, NULL);\n\n\tunregister_sys_off_handler(sys_off);\n}\n\n \nbool kernel_can_power_off(void)\n{\n\treturn !atomic_notifier_call_chain_is_empty(&power_off_handler_list) ||\n\t\tpm_power_off;\n}\nEXPORT_SYMBOL_GPL(kernel_can_power_off);\n\n \nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tdo_kernel_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}\nEXPORT_SYMBOL_GPL(kernel_power_off);\n\nDEFINE_MUTEX(system_transition_mutex);\n\n \nSYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,\n\t\tvoid __user *, arg)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);\n\tchar buffer[256];\n\tint ret = 0;\n\n\t \n\tif (!ns_capable(pid_ns->user_ns, CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\t \n\tif (magic1 != LINUX_REBOOT_MAGIC1 ||\n\t\t\t(magic2 != LINUX_REBOOT_MAGIC2 &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2A &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2B &&\n\t\t\tmagic2 != LINUX_REBOOT_MAGIC2C))\n\t\treturn -EINVAL;\n\n\t \n\tret = reboot_pid_ns(pid_ns, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((cmd == LINUX_REBOOT_CMD_POWER_OFF) && !kernel_can_power_off())\n\t\tcmd = LINUX_REBOOT_CMD_HALT;\n\n\tmutex_lock(&system_transition_mutex);\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_ON:\n\t\tC_A_D = 1;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_CAD_OFF:\n\t\tC_A_D = 0;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tkernel_halt();\n\t\tdo_exit(0);\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\t\tkernel_power_off();\n\t\tdo_exit(0);\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\t\tret = strncpy_from_user(&buffer[0], arg, sizeof(buffer) - 1);\n\t\tif (ret < 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef CONFIG_KEXEC_CORE\n\tcase LINUX_REBOOT_CMD_KEXEC:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_HIBERNATION\n\tcase LINUX_REBOOT_CMD_SW_SUSPEND:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tmutex_unlock(&system_transition_mutex);\n\treturn ret;\n}\n\nstatic void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(NULL);\n}\n\n \nvoid ctrl_alt_del(void)\n{\n\tstatic DECLARE_WORK(cad_work, deferred_cad);\n\n\tif (C_A_D)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(SIGINT, 1);\n}\n\n#define POWEROFF_CMD_PATH_LEN  256\nstatic char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = \"/sbin/poweroff\";\nstatic const char reboot_cmd[] = \"/sbin/reboot\";\n\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n\nstatic int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"Failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t \n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\n\nstatic bool poweroff_force;\n\nstatic void poweroff_work_func(struct work_struct *work)\n{\n\t__orderly_poweroff(poweroff_force);\n}\n\nstatic DECLARE_WORK(poweroff_work, poweroff_work_func);\n\n \nvoid orderly_poweroff(bool force)\n{\n\tif (force)  \n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}\nEXPORT_SYMBOL_GPL(orderly_poweroff);\n\nstatic void reboot_work_func(struct work_struct *work)\n{\n\t__orderly_reboot();\n}\n\nstatic DECLARE_WORK(reboot_work, reboot_work_func);\n\n \nvoid orderly_reboot(void)\n{\n\tschedule_work(&reboot_work);\n}\nEXPORT_SYMBOL_GPL(orderly_reboot);\n\n \nstatic void hw_failure_emergency_poweroff_func(struct work_struct *work)\n{\n\t \n\tpr_emerg(\"Hardware protection timed-out. Trying forced poweroff\\n\");\n\tkernel_power_off();\n\n\t \n\tpr_emerg(\"Hardware protection shutdown failed. Trying emergency restart\\n\");\n\temergency_restart();\n}\n\nstatic DECLARE_DELAYED_WORK(hw_failure_emergency_poweroff_work,\n\t\t\t    hw_failure_emergency_poweroff_func);\n\n \nstatic void hw_failure_emergency_poweroff(int poweroff_delay_ms)\n{\n\tif (poweroff_delay_ms <= 0)\n\t\treturn;\n\tschedule_delayed_work(&hw_failure_emergency_poweroff_work,\n\t\t\t      msecs_to_jiffies(poweroff_delay_ms));\n}\n\n \nvoid hw_protection_shutdown(const char *reason, int ms_until_forced)\n{\n\tstatic atomic_t allow_proceed = ATOMIC_INIT(1);\n\n\tpr_emerg(\"HARDWARE PROTECTION shutdown (%s)\\n\", reason);\n\n\t \n\tif (!atomic_dec_and_test(&allow_proceed))\n\t\treturn;\n\n\t \n\thw_failure_emergency_poweroff(ms_until_forced);\n\torderly_poweroff(true);\n}\nEXPORT_SYMBOL_GPL(hw_protection_shutdown);\n\nstatic int __init reboot_setup(char *str)\n{\n\tfor (;;) {\n\t\tenum reboot_mode *mode;\n\n\t\t \n\t\treboot_default = 0;\n\n\t\tif (!strncmp(str, \"panic_\", 6)) {\n\t\t\tmode = &panic_reboot_mode;\n\t\t\tstr += 6;\n\t\t} else {\n\t\t\tmode = &reboot_mode;\n\t\t}\n\n\t\tswitch (*str) {\n\t\tcase 'w':\n\t\t\t*mode = REBOOT_WARM;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\t*mode = REBOOT_COLD;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t*mode = REBOOT_HARD;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t \n\t\t\tstr += str[1] == 'm' && str[2] == 'p' ? 3 : 1;\n\n\t\t\tif (isdigit(str[0])) {\n\t\t\t\tint cpu = simple_strtoul(str, NULL, 0);\n\n\t\t\t\tif (cpu >= num_possible_cpus()) {\n\t\t\t\t\tpr_err(\"Ignoring the CPU number in reboot= option. \"\n\t\t\t\t\t\"CPU %d exceeds possible cpu number %d\\n\",\n\t\t\t\t\tcpu, num_possible_cpus());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treboot_cpu = cpu;\n\t\t\t} else\n\t\t\t\t*mode = REBOOT_SOFT;\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\t*mode = REBOOT_GPIO;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'a':\n\t\tcase 'k':\n\t\tcase 't':\n\t\tcase 'e':\n\t\tcase 'p':\n\t\t\treboot_type = *str;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\treboot_force = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tstr = strchr(str, ',');\n\t\tif (str)\n\t\t\tstr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n__setup(\"reboot=\", reboot_setup);\n\n#ifdef CONFIG_SYSFS\n\n#define REBOOT_COLD_STR\t\t\"cold\"\n#define REBOOT_WARM_STR\t\t\"warm\"\n#define REBOOT_HARD_STR\t\t\"hard\"\n#define REBOOT_SOFT_STR\t\t\"soft\"\n#define REBOOT_GPIO_STR\t\t\"gpio\"\n#define REBOOT_UNDEFINED_STR\t\"undefined\"\n\n#define BOOT_TRIPLE_STR\t\t\"triple\"\n#define BOOT_KBD_STR\t\t\"kbd\"\n#define BOOT_BIOS_STR\t\t\"bios\"\n#define BOOT_ACPI_STR\t\t\"acpi\"\n#define BOOT_EFI_STR\t\t\"efi\"\n#define BOOT_PCI_STR\t\t\"pci\"\n\nstatic ssize_t mode_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tconst char *val;\n\n\tswitch (reboot_mode) {\n\tcase REBOOT_COLD:\n\t\tval = REBOOT_COLD_STR;\n\t\tbreak;\n\tcase REBOOT_WARM:\n\t\tval = REBOOT_WARM_STR;\n\t\tbreak;\n\tcase REBOOT_HARD:\n\t\tval = REBOOT_HARD_STR;\n\t\tbreak;\n\tcase REBOOT_SOFT:\n\t\tval = REBOOT_SOFT_STR;\n\t\tbreak;\n\tcase REBOOT_GPIO:\n\t\tval = REBOOT_GPIO_STR;\n\t\tbreak;\n\tdefault:\n\t\tval = REBOOT_UNDEFINED_STR;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", val);\n}\nstatic ssize_t mode_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, REBOOT_COLD_STR, strlen(REBOOT_COLD_STR)))\n\t\treboot_mode = REBOOT_COLD;\n\telse if (!strncmp(buf, REBOOT_WARM_STR, strlen(REBOOT_WARM_STR)))\n\t\treboot_mode = REBOOT_WARM;\n\telse if (!strncmp(buf, REBOOT_HARD_STR, strlen(REBOOT_HARD_STR)))\n\t\treboot_mode = REBOOT_HARD;\n\telse if (!strncmp(buf, REBOOT_SOFT_STR, strlen(REBOOT_SOFT_STR)))\n\t\treboot_mode = REBOOT_SOFT;\n\telse if (!strncmp(buf, REBOOT_GPIO_STR, strlen(REBOOT_GPIO_STR)))\n\t\treboot_mode = REBOOT_GPIO;\n\telse\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\n\treturn count;\n}\nstatic struct kobj_attribute reboot_mode_attr = __ATTR_RW(mode);\n\n#ifdef CONFIG_X86\nstatic ssize_t force_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", reboot_force);\n}\nstatic ssize_t force_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tbool res;\n\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (kstrtobool(buf, &res))\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\treboot_force = res;\n\n\treturn count;\n}\nstatic struct kobj_attribute reboot_force_attr = __ATTR_RW(force);\n\nstatic ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tconst char *val;\n\n\tswitch (reboot_type) {\n\tcase BOOT_TRIPLE:\n\t\tval = BOOT_TRIPLE_STR;\n\t\tbreak;\n\tcase BOOT_KBD:\n\t\tval = BOOT_KBD_STR;\n\t\tbreak;\n\tcase BOOT_BIOS:\n\t\tval = BOOT_BIOS_STR;\n\t\tbreak;\n\tcase BOOT_ACPI:\n\t\tval = BOOT_ACPI_STR;\n\t\tbreak;\n\tcase BOOT_EFI:\n\t\tval = BOOT_EFI_STR;\n\t\tbreak;\n\tcase BOOT_CF9_FORCE:\n\t\tval = BOOT_PCI_STR;\n\t\tbreak;\n\tdefault:\n\t\tval = REBOOT_UNDEFINED_STR;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", val);\n}\nstatic ssize_t type_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, BOOT_TRIPLE_STR, strlen(BOOT_TRIPLE_STR)))\n\t\treboot_type = BOOT_TRIPLE;\n\telse if (!strncmp(buf, BOOT_KBD_STR, strlen(BOOT_KBD_STR)))\n\t\treboot_type = BOOT_KBD;\n\telse if (!strncmp(buf, BOOT_BIOS_STR, strlen(BOOT_BIOS_STR)))\n\t\treboot_type = BOOT_BIOS;\n\telse if (!strncmp(buf, BOOT_ACPI_STR, strlen(BOOT_ACPI_STR)))\n\t\treboot_type = BOOT_ACPI;\n\telse if (!strncmp(buf, BOOT_EFI_STR, strlen(BOOT_EFI_STR)))\n\t\treboot_type = BOOT_EFI;\n\telse if (!strncmp(buf, BOOT_PCI_STR, strlen(BOOT_PCI_STR)))\n\t\treboot_type = BOOT_CF9_FORCE;\n\telse\n\t\treturn -EINVAL;\n\n\treboot_default = 0;\n\n\treturn count;\n}\nstatic struct kobj_attribute reboot_type_attr = __ATTR_RW(type);\n#endif\n\n#ifdef CONFIG_SMP\nstatic ssize_t cpu_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", reboot_cpu);\n}\nstatic ssize_t cpu_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int cpunum;\n\tint rc;\n\n\tif (!capable(CAP_SYS_BOOT))\n\t\treturn -EPERM;\n\n\trc = kstrtouint(buf, 0, &cpunum);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (cpunum >= num_possible_cpus())\n\t\treturn -ERANGE;\n\n\treboot_default = 0;\n\treboot_cpu = cpunum;\n\n\treturn count;\n}\nstatic struct kobj_attribute reboot_cpu_attr = __ATTR_RW(cpu);\n#endif\n\nstatic struct attribute *reboot_attrs[] = {\n\t&reboot_mode_attr.attr,\n#ifdef CONFIG_X86\n\t&reboot_force_attr.attr,\n\t&reboot_type_attr.attr,\n#endif\n#ifdef CONFIG_SMP\n\t&reboot_cpu_attr.attr,\n#endif\n\tNULL,\n};\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table kern_reboot_table[] = {\n\t{\n\t\t.procname       = \"poweroff_cmd\",\n\t\t.data           = &poweroff_cmd,\n\t\t.maxlen         = POWEROFF_CMD_PATH_LEN,\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dostring,\n\t},\n\t{\n\t\t.procname       = \"ctrl-alt-del\",\n\t\t.data           = &C_A_D,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic void __init kernel_reboot_sysctls_init(void)\n{\n\tregister_sysctl_init(\"kernel\", kern_reboot_table);\n}\n#else\n#define kernel_reboot_sysctls_init() do { } while (0)\n#endif  \n\nstatic const struct attribute_group reboot_attr_group = {\n\t.attrs = reboot_attrs,\n};\n\nstatic int __init reboot_ksysfs_init(void)\n{\n\tstruct kobject *reboot_kobj;\n\tint ret;\n\n\treboot_kobj = kobject_create_and_add(\"reboot\", kernel_kobj);\n\tif (!reboot_kobj)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(reboot_kobj, &reboot_attr_group);\n\tif (ret) {\n\t\tkobject_put(reboot_kobj);\n\t\treturn ret;\n\t}\n\n\tkernel_reboot_sysctls_init();\n\n\treturn 0;\n}\nlate_initcall(reboot_ksysfs_init);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}