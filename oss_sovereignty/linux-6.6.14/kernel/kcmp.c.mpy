{
  "module_name": "kcmp.c",
  "hash_id": "8200773d777e7a74fcaf963c065e6ab0e47e4c7d1a5977efbf62acf7f2497c35",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcmp.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/cache.h>\n#include <linux/bug.h>\n#include <linux/err.h>\n#include <linux/kcmp.h>\n#include <linux/capability.h>\n#include <linux/list.h>\n#include <linux/eventpoll.h>\n#include <linux/file.h>\n\n#include <asm/unistd.h>\n\n \nstatic unsigned long cookies[KCMP_TYPES][2] __read_mostly;\n\nstatic long kptr_obfuscate(long v, int type)\n{\n\treturn (v ^ cookies[type][0]) * cookies[type][1];\n}\n\n \nstatic int kcmp_ptr(void *v1, void *v2, enum kcmp_type type)\n{\n\tlong t1, t2;\n\n\tt1 = kptr_obfuscate((long)v1, type);\n\tt2 = kptr_obfuscate((long)v2, type);\n\n\treturn (t1 < t2) | ((t1 > t2) << 1);\n}\n\n \nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\n\tfile = task_lookup_fd_rcu(task, idx);\n\trcu_read_unlock();\n\n\treturn file;\n}\n\nstatic void kcmp_unlock(struct rw_semaphore *l1, struct rw_semaphore *l2)\n{\n\tif (likely(l2 != l1))\n\t\tup_read(l2);\n\tup_read(l1);\n}\n\nstatic int kcmp_lock(struct rw_semaphore *l1, struct rw_semaphore *l2)\n{\n\tint err;\n\n\tif (l2 > l1)\n\t\tswap(l1, l2);\n\n\terr = down_read_killable(l1);\n\tif (!err && likely(l1 != l2)) {\n\t\terr = down_read_killable_nested(l2, SINGLE_DEPTH_NESTING);\n\t\tif (err)\n\t\t\tup_read(l1);\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_EPOLL\nstatic int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\tstruct file *filp, *filp_epoll, *filp_tgt;\n\tstruct kcmp_epoll_slot slot;\n\n\tif (copy_from_user(&slot, uslot, sizeof(slot)))\n\t\treturn -EFAULT;\n\n\tfilp = get_file_raw_ptr(task1, idx1);\n\tif (!filp)\n\t\treturn -EBADF;\n\n\tfilp_epoll = fget_task(task2, slot.efd);\n\tif (!filp_epoll)\n\t\treturn -EBADF;\n\n\tfilp_tgt = get_epoll_tfile_raw_ptr(filp_epoll, slot.tfd, slot.toff);\n\tfput(filp_epoll);\n\n\tif (IS_ERR(filp_tgt))\n\t\treturn PTR_ERR(filp_tgt);\n\n\treturn kcmp_ptr(filp, filp_tgt, KCMP_FILE);\n}\n#else\nstatic int kcmp_epoll_target(struct task_struct *task1,\n\t\t\t     struct task_struct *task2,\n\t\t\t     unsigned long idx1,\n\t\t\t     struct kcmp_epoll_slot __user *uslot)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nSYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,\n\t\tunsigned long, idx1, unsigned long, idx2)\n{\n\tstruct task_struct *task1, *task2;\n\tint ret;\n\n\trcu_read_lock();\n\n\t \n\ttask1 = find_task_by_vpid(pid1);\n\ttask2 = find_task_by_vpid(pid2);\n\tif (!task1 || !task2)\n\t\tgoto err_no_task;\n\n\tget_task_struct(task1);\n\tget_task_struct(task2);\n\n\trcu_read_unlock();\n\n\t \n\tret = kcmp_lock(&task1->signal->exec_update_lock,\n\t\t\t&task2->signal->exec_update_lock);\n\tif (ret)\n\t\tgoto err;\n\tif (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||\n\t    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {\n\t\tret = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase KCMP_FILE: {\n\t\tstruct file *filp1, *filp2;\n\n\t\tfilp1 = get_file_raw_ptr(task1, idx1);\n\t\tfilp2 = get_file_raw_ptr(task2, idx2);\n\n\t\tif (filp1 && filp2)\n\t\t\tret = kcmp_ptr(filp1, filp2, KCMP_FILE);\n\t\telse\n\t\t\tret = -EBADF;\n\t\tbreak;\n\t}\n\tcase KCMP_VM:\n\t\tret = kcmp_ptr(task1->mm, task2->mm, KCMP_VM);\n\t\tbreak;\n\tcase KCMP_FILES:\n\t\tret = kcmp_ptr(task1->files, task2->files, KCMP_FILES);\n\t\tbreak;\n\tcase KCMP_FS:\n\t\tret = kcmp_ptr(task1->fs, task2->fs, KCMP_FS);\n\t\tbreak;\n\tcase KCMP_SIGHAND:\n\t\tret = kcmp_ptr(task1->sighand, task2->sighand, KCMP_SIGHAND);\n\t\tbreak;\n\tcase KCMP_IO:\n\t\tret = kcmp_ptr(task1->io_context, task2->io_context, KCMP_IO);\n\t\tbreak;\n\tcase KCMP_SYSVSEM:\n#ifdef CONFIG_SYSVIPC\n\t\tret = kcmp_ptr(task1->sysvsem.undo_list,\n\t\t\t       task2->sysvsem.undo_list,\n\t\t\t       KCMP_SYSVSEM);\n#else\n\t\tret = -EOPNOTSUPP;\n#endif\n\t\tbreak;\n\tcase KCMP_EPOLL_TFD:\n\t\tret = kcmp_epoll_target(task1, task2, idx1, (void *)idx2);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nerr_unlock:\n\tkcmp_unlock(&task1->signal->exec_update_lock,\n\t\t    &task2->signal->exec_update_lock);\nerr:\n\tput_task_struct(task1);\n\tput_task_struct(task2);\n\n\treturn ret;\n\nerr_no_task:\n\trcu_read_unlock();\n\treturn -ESRCH;\n}\n\nstatic __init int kcmp_cookies_init(void)\n{\n\tint i;\n\n\tget_random_bytes(cookies, sizeof(cookies));\n\n\tfor (i = 0; i < KCMP_TYPES; i++)\n\t\tcookies[i][1] |= (~(~0UL >>  1) | 1);\n\n\treturn 0;\n}\narch_initcall(kcmp_cookies_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}