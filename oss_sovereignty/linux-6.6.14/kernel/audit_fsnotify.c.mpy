{
  "module_name": "audit_fsnotify.c",
  "hash_id": "72c8f7f203d9c5842c19b083d427570ff19414ee0456b54e1cc2deacb1fc8cdc",
  "original_prompt": "Ingested from linux-6.6.14/kernel/audit_fsnotify.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/audit.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/namei.h>\n#include <linux/netlink.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include \"audit.h\"\n\n \nstruct audit_fsnotify_mark {\n\tdev_t dev;\t\t \n\tunsigned long ino;\t \n\tchar *path;\t\t \n\tstruct fsnotify_mark mark;  \n\tstruct audit_krule *rule;\n};\n\n \nstatic struct fsnotify_group *audit_fsnotify_group;\n\n \n#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF)\n\nstatic void audit_fsnotify_mark_free(struct audit_fsnotify_mark *audit_mark)\n{\n\tkfree(audit_mark->path);\n\tkfree(audit_mark);\n}\n\nstatic void audit_fsnotify_free_mark(struct fsnotify_mark *mark)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\taudit_mark = container_of(mark, struct audit_fsnotify_mark, mark);\n\taudit_fsnotify_mark_free(audit_mark);\n}\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}\n\nint audit_mark_compare(struct audit_fsnotify_mark *mark, unsigned long ino, dev_t dev)\n{\n\tif (mark->ino == AUDIT_INO_UNSET)\n\t\treturn 0;\n\treturn (mark->ino == ino) && (mark->dev == dev);\n}\n\nstatic void audit_update_mark(struct audit_fsnotify_mark *audit_mark,\n\t\t\t     const struct inode *inode)\n{\n\taudit_mark->dev = inode ? inode->i_sb->s_dev : AUDIT_DEV_UNSET;\n\taudit_mark->ino = inode ? inode->i_ino : AUDIT_INO_UNSET;\n}\n\nstruct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry);  \n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_mark->path = NULL;\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}\n\nstatic void audit_mark_log_rule_change(struct audit_fsnotify_mark *audit_mark, char *op)\n{\n\tstruct audit_buffer *ab;\n\tstruct audit_krule *rule = audit_mark->rule;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_format(ab, \" op=%s path=\", op);\n\taudit_log_untrustedstring(ab, audit_mark->path);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", rule->listnr);\n\taudit_log_end(ab);\n}\n\nvoid audit_remove_mark(struct audit_fsnotify_mark *audit_mark)\n{\n\tfsnotify_destroy_mark(&audit_mark->mark, audit_fsnotify_group);\n\tfsnotify_put_mark(&audit_mark->mark);\n}\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}\n\nstatic void audit_autoremove_mark_rule(struct audit_fsnotify_mark *audit_mark)\n{\n\tstruct audit_krule *rule = audit_mark->rule;\n\tstruct audit_entry *entry = container_of(rule, struct audit_entry, rule);\n\n\taudit_mark_log_rule_change(audit_mark, \"autoremove_rule\");\n\taudit_del_rule(entry);\n}\n\n \nstatic int audit_mark_handle_event(struct fsnotify_mark *inode_mark, u32 mask,\n\t\t\t\t   struct inode *inode, struct inode *dir,\n\t\t\t\t   const struct qstr *dname, u32 cookie)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\taudit_mark = container_of(inode_mark, struct audit_fsnotify_mark, mark);\n\n\tif (WARN_ON_ONCE(inode_mark->group != audit_fsnotify_group))\n\t\treturn 0;\n\n\tif (mask & (FS_CREATE|FS_MOVED_TO|FS_DELETE|FS_MOVED_FROM)) {\n\t\tif (audit_compare_dname_path(dname, audit_mark->path, AUDIT_NAME_FULL))\n\t\t\treturn 0;\n\t\taudit_update_mark(audit_mark, inode);\n\t} else if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF)) {\n\t\taudit_autoremove_mark_rule(audit_mark);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct fsnotify_ops audit_mark_fsnotify_ops = {\n\t.handle_inode_event = audit_mark_handle_event,\n\t.free_mark = audit_fsnotify_free_mark,\n};\n\nstatic int __init audit_fsnotify_init(void)\n{\n\taudit_fsnotify_group = fsnotify_alloc_group(&audit_mark_fsnotify_ops,\n\t\t\t\t\t\t    FSNOTIFY_GROUP_DUPS);\n\tif (IS_ERR(audit_fsnotify_group)) {\n\t\taudit_fsnotify_group = NULL;\n\t\taudit_panic(\"cannot create audit fsnotify group\");\n\t}\n\treturn 0;\n}\ndevice_initcall(audit_fsnotify_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}