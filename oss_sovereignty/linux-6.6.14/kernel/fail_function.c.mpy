{
  "module_name": "fail_function.c",
  "hash_id": "598a718780f4e15079b9073b82b247623f9b4028776b367cbf29dadf642cb1cf",
  "original_prompt": "Ingested from linux-6.6.14/kernel/fail_function.c",
  "human_readable_source": "\n \n#include <linux/error-injection.h>\n#include <linux/debugfs.h>\n#include <linux/fault-inject.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);\n\nstatic void fei_post_handler(struct kprobe *kp, struct pt_regs *regs,\n\t\t\t     unsigned long flags)\n{\n\t \n}\n\nstruct fei_attr {\n\tstruct list_head list;\n\tstruct kprobe kp;\n\tunsigned long retval;\n};\nstatic DEFINE_MUTEX(fei_lock);\nstatic LIST_HEAD(fei_attr_list);\nstatic DECLARE_FAULT_ATTR(fei_fault_attr);\nstatic struct dentry *fei_debugfs_dir;\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\treturn 0;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_TRUE:\n\t\treturn 1;\n\t}\n\n\treturn retv;\n}\n\nstatic struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}\n\nstatic void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}\n\nstatic struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int fei_retval_set(void *data, u64 val)\n{\n\tstruct fei_attr *attr = data;\n\tunsigned long retv = (unsigned long)val;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t \n\tif (!fei_attr_is_valid(attr)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (attr->kp.addr) {\n\t\tif (adjust_error_retval((unsigned long)attr->kp.addr,\n\t\t\t\t\tval) != retv)\n\t\t\terr = -EINVAL;\n\t}\n\tif (!err)\n\t\tattr->retval = val;\nout:\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}\n\nstatic int fei_retval_get(void *data, u64 *val)\n{\n\tstruct fei_attr *attr = data;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t \n\tif (!fei_attr_is_valid(attr))\n\t\terr = -ENOENT;\n\telse\n\t\t*val = attr->retval;\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fei_retval_ops, fei_retval_get, fei_retval_set,\n\t\t\t \"%llx\\n\");\n\nstatic void fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\n\tdebugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops);\n}\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tdebugfs_lookup_and_remove(attr->kp.symbol_name, fei_debugfs_dir);\n}\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct fei_attr *attr = container_of(kp, struct fei_attr, kp);\n\n\tif (should_fail(&fei_fault_attr, 1)) {\n\t\tregs_set_return_value(regs, attr->retval);\n\t\toverride_function_with_return(regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nNOKPROBE_SYMBOL(fei_kprobe_handler)\n\nstatic void *fei_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&fei_lock);\n\treturn seq_list_start(&fei_attr_list, *pos);\n}\n\nstatic void fei_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&fei_lock);\n}\n\nstatic void *fei_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &fei_attr_list, pos);\n}\n\nstatic int fei_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fei_attr *attr = list_entry(v, struct fei_attr, list);\n\n\tseq_printf(m, \"%ps\\n\", attr->kp.addr);\n\treturn 0;\n}\n\nstatic const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};\n\nstatic int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}\n\nstatic void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}\n\nstatic ssize_t fei_write(struct file *file, const char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct fei_attr *attr;\n\tunsigned long addr;\n\tchar *buf, *sym;\n\tint ret;\n\n\t \n\tif (count > KSYM_NAME_LEN)\n\t\tcount = KSYM_NAME_LEN;\n\n\tbuf = memdup_user_nul(buffer, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tsym = strstrip(buf);\n\n\tmutex_lock(&fei_lock);\n\n\t \n\tif (sym[0] == '\\0') {\n\t\tfei_attr_remove_all();\n\t\tret = count;\n\t\tgoto out;\n\t}\n\t \n\tif (sym[0] == '!') {\n\t\tattr = fei_attr_lookup(sym + 1);\n\t\tif (!attr) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tfei_attr_remove(attr);\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\taddr = kallsyms_lookup_name(sym);\n\tif (!addr) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!within_error_injection_list(addr)) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (fei_attr_lookup(sym)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tattr = fei_attr_new(sym, addr);\n\tif (!attr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = register_kprobe(&attr->kp);\n\tif (ret) {\n\t\tfei_attr_free(attr);\n\t\tgoto out;\n\t}\n\tfei_debugfs_add_attr(attr);\n\tlist_add_tail(&attr->list, &fei_attr_list);\n\tret = count;\nout:\n\tmutex_unlock(&fei_lock);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations fei_ops = {\n\t.open =\t\tfei_open,\n\t.read =\t\tseq_read,\n\t.write =\tfei_write,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release,\n};\n\nstatic int __init fei_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_function\", NULL,\n\t\t\t\t\t&fei_fault_attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\t \n\tdebugfs_create_symlink(\"injectable\", dir, \"../error_injection/list\");\n\n\tdebugfs_create_file(\"inject\", 0600, dir, NULL, &fei_ops);\n\n\tfei_debugfs_dir = dir;\n\n\treturn 0;\n}\n\nlate_initcall(fei_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}