{
  "module_name": "auditsc.c",
  "hash_id": "78ff6181070bf286b3b48f4ca4b02859d55713ee11bbd512bee72e8ef2cee573",
  "original_prompt": "Ingested from linux-6.6.14/kernel/auditsc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <asm/types.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/socket.h>\n#include <linux/mqueue.h>\n#include <linux/audit.h>\n#include <linux/personality.h>\n#include <linux/time.h>\n#include <linux/netlink.h>\n#include <linux/compiler.h>\n#include <asm/unistd.h>\n#include <linux/security.h>\n#include <linux/list.h>\n#include <linux/binfmts.h>\n#include <linux/highmem.h>\n#include <linux/syscalls.h>\n#include <asm/syscall.h>\n#include <linux/capability.h>\n#include <linux/fs_struct.h>\n#include <linux/compat.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify_backend.h>\n#include <uapi/linux/limits.h>\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/openat2.h>  \n#include <uapi/linux/fanotify.h>\n\n#include \"audit.h\"\n\n \n#define AUDITSC_INVALID 0\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_FAILURE 2\n\n \n#define MAX_EXECVE_AUDIT_LEN 7500\n\n \n#define MAX_PROCTITLE_AUDIT_LEN 128\n\n \nint audit_n_rules;\n\n \nint audit_signals;\n\nstruct audit_aux_data {\n\tstruct audit_aux_data\t*next;\n\tint\t\t\ttype;\n};\n\n \n#define AUDIT_AUX_PIDS\t16\n\nstruct audit_aux_data_pids {\n\tstruct audit_aux_data\td;\n\tpid_t\t\t\ttarget_pid[AUDIT_AUX_PIDS];\n\tkuid_t\t\t\ttarget_auid[AUDIT_AUX_PIDS];\n\tkuid_t\t\t\ttarget_uid[AUDIT_AUX_PIDS];\n\tunsigned int\t\ttarget_sessionid[AUDIT_AUX_PIDS];\n\tu32\t\t\ttarget_sid[AUDIT_AUX_PIDS];\n\tchar \t\t\ttarget_comm[AUDIT_AUX_PIDS][TASK_COMM_LEN];\n\tint\t\t\tpid_count;\n};\n\nstruct audit_aux_data_bprm_fcaps {\n\tstruct audit_aux_data\td;\n\tstruct audit_cap_data\tfcap;\n\tunsigned int\t\tfcap_ver;\n\tstruct audit_cap_data\told_pcap;\n\tstruct audit_cap_data\tnew_pcap;\n};\n\nstruct audit_tree_refs {\n\tstruct audit_tree_refs *next;\n\tstruct audit_chunk *c[31];\n};\n\nstruct audit_nfcfgop_tab {\n\tenum audit_nfcfgop\top;\n\tconst char\t\t*s;\n};\n\nstatic const struct audit_nfcfgop_tab audit_nfcfgs[] = {\n\t{ AUDIT_XT_OP_REGISTER,\t\t\t\"xt_register\"\t\t   },\n\t{ AUDIT_XT_OP_REPLACE,\t\t\t\"xt_replace\"\t\t   },\n\t{ AUDIT_XT_OP_UNREGISTER,\t\t\"xt_unregister\"\t\t   },\n\t{ AUDIT_NFT_OP_TABLE_REGISTER,\t\t\"nft_register_table\"\t   },\n\t{ AUDIT_NFT_OP_TABLE_UNREGISTER,\t\"nft_unregister_table\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_REGISTER,\t\t\"nft_register_chain\"\t   },\n\t{ AUDIT_NFT_OP_CHAIN_UNREGISTER,\t\"nft_unregister_chain\"\t   },\n\t{ AUDIT_NFT_OP_RULE_REGISTER,\t\t\"nft_register_rule\"\t   },\n\t{ AUDIT_NFT_OP_RULE_UNREGISTER,\t\t\"nft_unregister_rule\"\t   },\n\t{ AUDIT_NFT_OP_SET_REGISTER,\t\t\"nft_register_set\"\t   },\n\t{ AUDIT_NFT_OP_SET_UNREGISTER,\t\t\"nft_unregister_set\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_REGISTER,\t\"nft_register_setelem\"\t   },\n\t{ AUDIT_NFT_OP_SETELEM_UNREGISTER,\t\"nft_unregister_setelem\"   },\n\t{ AUDIT_NFT_OP_GEN_REGISTER,\t\t\"nft_register_gen\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_REGISTER,\t\t\"nft_register_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_UNREGISTER,\t\t\"nft_unregister_obj\"\t   },\n\t{ AUDIT_NFT_OP_OBJ_RESET,\t\t\"nft_reset_obj\"\t\t   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_REGISTER,\t\"nft_register_flowtable\"   },\n\t{ AUDIT_NFT_OP_FLOWTABLE_UNREGISTER,\t\"nft_unregister_flowtable\" },\n\t{ AUDIT_NFT_OP_SETELEM_RESET,\t\t\"nft_reset_setelem\"        },\n\t{ AUDIT_NFT_OP_RULE_RESET,\t\t\"nft_reset_rule\"           },\n\t{ AUDIT_NFT_OP_INVALID,\t\t\t\"nft_invalid\"\t\t   },\n};\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase AUDITSC_NATIVE:\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_COMPAT:  \n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase AUDITSC_OPEN:\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase AUDITSC_OPENAT:\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase AUDITSC_SOCKETCALL:\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase AUDITSC_EXECVE:\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tcase AUDITSC_OPENAT2:\n\t\treturn mask & ACC_MODE((u32)ctx->openat2.flags);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n}\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n\tstruct audit_tree_refs *q;\n\tint n;\n\n\tif (!p) {\n\t\t \n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t \n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n}\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n\tstruct audit_tree_refs *p;\n\tint n;\n\n\tif (!tree)\n\t\treturn 0;\n\t \n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t \n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n\n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t \n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t \n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t \n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t \n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t \n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t \n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t \n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t \n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n \n \nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tif (ctx && rule->prio <= ctx->prio)\n\t\treturn 0;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid != AUDITSC_INVALID) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_watch_compare(rule->watch,\n\t\t\t\t\t\t\t     name->ino,\n\t\t\t\t\t\t\t     name->dev);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx) {\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SADDR_FAM:\n\t\t\tif (ctx && ctx->sockaddr)\n\t\t\t\tresult = audit_comparator(ctx->sockaddr->ss_family,\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t \n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\t \n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t\t\t\t\t   f->op,\n\t\t\t\t\t\t\t\t   f->lsm_rule);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t \n\t\t\tif (f->lsm_rule) {\n\t\t\t\t \n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t\t\t\tname->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(\n\t\t\t\t\t\t\t\tn->osid,\n\t\t\t\t\t\t\t\tf->type,\n\t\t\t\t\t\t\t\tf->op,\n\t\t\t\t\t\t\t\tf->lsm_rule)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t \n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_STATE_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_STATE_RECORD;\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n \nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_STATE_RECORD)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_STATE_BUILD;\n}\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}\n\n \nstatic int __audit_filter_op(struct task_struct *tsk,\n\t\t\t   struct audit_context *ctx,\n\t\t\t   struct list_head *list,\n\t\t\t   struct audit_names *name,\n\t\t\t   unsigned long op)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, op) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, name,\n\t\t\t\t       &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void audit_filter_uring(struct task_struct *tsk,\n\t\t\t       struct audit_context *ctx)\n{\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\t__audit_filter_op(tsk, ctx, &audit_filter_list[AUDIT_FILTER_URING_EXIT],\n\t\t\tNULL, ctx->uring_op);\n\trcu_read_unlock();\n}\n\n \nstatic void audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t struct audit_context *ctx)\n{\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\t__audit_filter_op(tsk, ctx, &audit_filter_list[AUDIT_FILTER_EXIT],\n\t\t\tNULL, ctx->major);\n\trcu_read_unlock();\n}\n\n \nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx)\n{\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\n\treturn __audit_filter_op(tsk, ctx, list, n, ctx->major);\n}\n\n \nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}\n\nstatic inline void audit_free_module(struct audit_context *context)\n{\n\tif (context->type == AUDIT_KERN_MODULE) {\n\t\tkfree(context->module.name);\n\t\tcontext->module.name = NULL;\n\t}\n}\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux = NULL;\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n\tcontext->aux_pids = NULL;\n}\n\n \nstatic void audit_reset_context(struct audit_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\t \n\tctx->context = AUDIT_CTX_UNUSED;\n\tif (ctx->dummy)\n\t\treturn;\n\n\t \n\n\tctx->current_state = ctx->state;\n\tctx->serial = 0;\n\tctx->major = 0;\n\tctx->uring_op = 0;\n\tctx->ctime = (struct timespec64){ .tv_sec = 0, .tv_nsec = 0 };\n\tmemset(ctx->argv, 0, sizeof(ctx->argv));\n\tctx->return_code = 0;\n\tctx->prio = (ctx->state == AUDIT_STATE_RECORD ? ~0ULL : 0);\n\tctx->return_valid = AUDITSC_INVALID;\n\taudit_free_names(ctx);\n\tif (ctx->state != AUDIT_STATE_RECORD) {\n\t\tkfree(ctx->filterkey);\n\t\tctx->filterkey = NULL;\n\t}\n\taudit_free_aux(ctx);\n\tkfree(ctx->sockaddr);\n\tctx->sockaddr = NULL;\n\tctx->sockaddr_len = 0;\n\tctx->ppid = 0;\n\tctx->uid = ctx->euid = ctx->suid = ctx->fsuid = KUIDT_INIT(0);\n\tctx->gid = ctx->egid = ctx->sgid = ctx->fsgid = KGIDT_INIT(0);\n\tctx->personality = 0;\n\tctx->arch = 0;\n\tctx->target_pid = 0;\n\tctx->target_auid = ctx->target_uid = KUIDT_INIT(0);\n\tctx->target_sessionid = 0;\n\tctx->target_sid = 0;\n\tctx->target_comm[0] = '\\0';\n\tunroll_tree_refs(ctx, NULL, 0);\n\tWARN_ON(!list_empty(&ctx->killed_trees));\n\taudit_free_module(ctx);\n\tctx->fds[0] = -1;\n\tctx->type = 0;  \n}\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->context = AUDIT_CTX_UNUSED;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_STATE_RECORD ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\tcontext->fds[0] = -1;\n\tcontext->return_valid = AUDITSC_INVALID;\n\treturn context;\n}\n\n \nint audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0;\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_STATE_DISABLED) {\n\t\tclear_task_syscall_work(tsk, SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tcontext = audit_alloc_context(state);\n\tif (!context) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\taudit_set_context(tsk, context);\n\tset_task_syscall_work(tsk, SYSCALL_AUDIT);\n\treturn 0;\n}\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\t \n\taudit_reset_context(context);\n\taudit_proctitle_free(context);\n\tfree_tree_refs(context);\n\tkfree(context->filterkey);\n\tkfree(context);\n}\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t \n\tchar abuf[96];\n\n\t \n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t \n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t \n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t \n\t\tif (require_data) {\n\t\t\t \n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t \n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t \n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t \n\t\t\t\trequire_data = true;\n\t\t\t\t \n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t \n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t \n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t \n\t\tif (len_buf >= 0) {\n\t\t\t \n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t \n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2;  \n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2;  \n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t \n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t \n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t \n\nout:\n\tkfree(buf_head);\n}\n\nstatic void audit_log_cap(struct audit_buffer *ab, char *prefix,\n\t\t\t  kernel_cap_t *cap)\n{\n\tif (cap_isclear(*cap)) {\n\t\taudit_log_format(ab, \" %s=0\", prefix);\n\t\treturn;\n\t}\n\taudit_log_format(ab, \" %s=%016llx\", prefix, cap->val);\n}\n\nstatic void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\n{\n\tif (name->fcap_ver == -1) {\n\t\taudit_log_format(ab, \" cap_fe=? cap_fver=? cap_fp=? cap_fi=?\");\n\t\treturn;\n\t}\n\taudit_log_cap(ab, \"cap_fp\", &name->fcap.permitted);\n\taudit_log_cap(ab, \"cap_fi\", &name->fcap.inheritable);\n\taudit_log_format(ab, \" cap_fe=%d cap_fver=%x cap_frootid=%d\",\n\t\t\t name->fcap.fE, name->fcap_ver,\n\t\t\t from_kuid(&init_user_ns, name->fcap.rootid));\n}\n\nstatic void audit_log_time(struct audit_context *context, struct audit_buffer **ab)\n{\n\tconst struct audit_ntp_data *ntp = &context->time.ntp_data;\n\tconst struct timespec64 *tk = &context->time.tk_injoffset;\n\tstatic const char * const ntp_name[] = {\n\t\t\"offset\",\n\t\t\"freq\",\n\t\t\"status\",\n\t\t\"tai\",\n\t\t\"tick\",\n\t\t\"adjust\",\n\t};\n\tint type;\n\n\tif (context->type == AUDIT_TIME_ADJNTPVAL) {\n\t\tfor (type = 0; type < AUDIT_NTP_NVALS; type++) {\n\t\t\tif (ntp->vals[type].newval != ntp->vals[type].oldval) {\n\t\t\t\tif (!*ab) {\n\t\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t\tAUDIT_TIME_ADJNTPVAL);\n\t\t\t\t\tif (!*ab)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\taudit_log_format(*ab, \"op=%s old=%lli new=%lli\",\n\t\t\t\t\t\t ntp_name[type],\n\t\t\t\t\t\t ntp->vals[type].oldval,\n\t\t\t\t\t\t ntp->vals[type].newval);\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (tk->tv_sec != 0 || tk->tv_nsec != 0) {\n\t\tif (!*ab) {\n\t\t\t*ab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t      AUDIT_TIME_INJOFFSET);\n\t\t\tif (!*ab)\n\t\t\t\treturn;\n\t\t}\n\t\taudit_log_format(*ab, \"sec=%lli nsec=%li\",\n\t\t\t\t (long long)tk->tv_sec, tk->tv_nsec);\n\t\taudit_log_end(*ab);\n\t\t*ab = NULL;\n\t}\n}\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_OPENAT2:\n\t\taudit_log_format(ab, \"oflag=0%llo mode=0%llo resolve=0x%llx\",\n\t\t\t\t context->openat2.flags,\n\t\t\t\t context->openat2.mode,\n\t\t\t\t context->openat2.resolve);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\tcase AUDIT_TIME_ADJNTPVAL:\n\tcase AUDIT_TIME_INJOFFSET:\n\t\t \n\t\taudit_log_time(context, &ab);\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t \n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}\n\n \nstatic void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t \n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t \n\t\t\tif (context->pwd.dentry && context->pwd.mnt)\n\t\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\telse\n\t\t\t\taudit_log_format(ab, \" name=(null)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu dev=%02x:%02x mode=%#ho ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t \n\tswitch (n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \" nametype=NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \" nametype=PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \" nametype=DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \" nametype=CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \" nametype=UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}\n\nstatic void audit_log_proctitle(void)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t \n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t \n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t \n\t\tres = get_cmdline(current, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}\n\n \nstatic void audit_log_uring(struct audit_context *ctx)\n{\n\tstruct audit_buffer *ab;\n\tconst struct cred *cred;\n\n\tab = audit_log_start(ctx, GFP_ATOMIC, AUDIT_URINGOP);\n\tif (!ab)\n\t\treturn;\n\tcred = current_cred();\n\taudit_log_format(ab, \"uring_op=%d\", ctx->uring_op);\n\tif (ctx->return_valid != AUDITSC_INVALID)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (ctx->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t ctx->return_code);\n\taudit_log_format(ab,\n\t\t\t \" items=%d\"\n\t\t\t \" ppid=%d pid=%d uid=%u gid=%u euid=%u suid=%u\"\n\t\t\t \" fsuid=%u egid=%u sgid=%u fsgid=%u\",\n\t\t\t ctx->name_count,\n\t\t\t task_ppid_nr(current), task_tgid_nr(current),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid));\n\taudit_log_task_context(ab);\n\taudit_log_key(ab, ctx->filterkey);\n\taudit_log_end(ab);\n}\n\nstatic void audit_log_exit(void)\n{\n\tint i, call_panic = 0;\n\tstruct audit_context *context = audit_context();\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\tcontext->personality = current->personality;\n\n\tswitch (context->context) {\n\tcase AUDIT_CTX_SYSCALL:\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\t\tif (!ab)\n\t\t\treturn;\n\t\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t\t context->arch, context->major);\n\t\tif (context->personality != PER_LINUX)\n\t\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\t\tif (context->return_valid != AUDITSC_INVALID)\n\t\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t\t (context->return_valid == AUDITSC_SUCCESS ?\n\t\t\t\t\t  \"yes\" : \"no\"),\n\t\t\t\t\t context->return_code);\n\t\taudit_log_format(ab,\n\t\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t\t context->argv[0],\n\t\t\t\t context->argv[1],\n\t\t\t\t context->argv[2],\n\t\t\t\t context->argv[3],\n\t\t\t\t context->name_count);\n\t\taudit_log_task_info(ab);\n\t\taudit_log_key(ab, context->filterkey);\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase AUDIT_CTX_URING:\n\t\taudit_log_uring(context);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue;  \n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\taudit_log_format(ab, \" frootid=%d\",\n\t\t\t\t\t from_kuid(&init_user_ns,\n\t\t\t\t\t\t   axs->fcap.rootid));\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\tif (context->context == AUDIT_CTX_SYSCALL)\n\t\taudit_log_proctitle();\n\n\t \n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error in audit_log_exit()\");\n}\n\n \nvoid __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn;\n\n\t \n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(context);\n\n\t \n\tif (tsk == current && !context->dummy) {\n\t\tcontext->return_valid = AUDITSC_INVALID;\n\t\tcontext->return_code = 0;\n\t\tif (context->context == AUDIT_CTX_SYSCALL) {\n\t\t\taudit_filter_syscall(tsk, context);\n\t\t\taudit_filter_inodes(tsk, context);\n\t\t\tif (context->current_state == AUDIT_STATE_RECORD)\n\t\t\t\taudit_log_exit();\n\t\t} else if (context->context == AUDIT_CTX_URING) {\n\t\t\t \n\t\t\taudit_filter_uring(tsk, context);\n\t\t\taudit_filter_inodes(tsk, context);\n\t\t\tif (context->current_state == AUDIT_STATE_RECORD)\n\t\t\t\taudit_log_uring(context);\n\t\t}\n\t}\n\n\taudit_set_context(tsk, NULL);\n\taudit_free_context(context);\n}\n\n \nstatic void audit_return_fixup(struct audit_context *ctx,\n\t\t\t       int success, long code)\n{\n\t \n\tif (unlikely(code <= -ERESTARTSYS) &&\n\t    (code >= -ERESTART_RESTARTBLOCK) &&\n\t    (code != -ENOIOCTLCMD))\n\t\tctx->return_code = -EINTR;\n\telse\n\t\tctx->return_code  = code;\n\tctx->return_valid = (success ? AUDITSC_SUCCESS : AUDITSC_FAILURE);\n}\n\n \nvoid __audit_uring_entry(u8 op)\n{\n\tstruct audit_context *ctx = audit_context();\n\n\tif (ctx->state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\t \n\tctx->uring_op = op;\n\tif (ctx->context == AUDIT_CTX_SYSCALL)\n\t\treturn;\n\n\tctx->dummy = !audit_n_rules;\n\tif (!ctx->dummy && ctx->state == AUDIT_STATE_BUILD)\n\t\tctx->prio = 0;\n\n\tctx->context = AUDIT_CTX_URING;\n\tctx->current_state = ctx->state;\n\tktime_get_coarse_real_ts64(&ctx->ctime);\n}\n\n \nvoid __audit_uring_exit(int success, long code)\n{\n\tstruct audit_context *ctx = audit_context();\n\n\tif (ctx->dummy) {\n\t\tif (ctx->context != AUDIT_CTX_URING)\n\t\t\treturn;\n\t\tgoto out;\n\t}\n\n\taudit_return_fixup(ctx, success, code);\n\tif (ctx->context == AUDIT_CTX_SYSCALL) {\n\t\t \n\n\t\t \n\t\taudit_filter_syscall(current, ctx);\n\t\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\t\taudit_filter_uring(current, ctx);\n\t\taudit_filter_inodes(current, ctx);\n\t\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\t\treturn;\n\n\t\taudit_log_uring(ctx);\n\t\treturn;\n\t}\n\n\t \n\tif (!list_empty(&ctx->killed_trees))\n\t\taudit_kill_trees(ctx);\n\n\t \n\taudit_filter_uring(current, ctx);\n\taudit_filter_inodes(current, ctx);\n\tif (ctx->current_state != AUDIT_STATE_RECORD)\n\t\tgoto out;\n\taudit_log_exit();\n\nout:\n\taudit_reset_context(ctx);\n}\n\n \nvoid __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tWARN_ON(context->context != AUDIT_CTX_UNUSED);\n\tWARN_ON(context->name_count);\n\tif (context->context != AUDIT_CTX_UNUSED || context->name_count) {\n\t\taudit_panic(\"unrecoverable error in audit_syscall_entry()\");\n\t\treturn;\n\t}\n\n\tstate = context->state;\n\tif (state == AUDIT_STATE_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_STATE_BUILD) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch(current);\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->context = AUDIT_CTX_SYSCALL;\n\tcontext->current_state  = state;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}\n\n \nvoid __audit_syscall_exit(int success, long return_code)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context || context->dummy ||\n\t    context->context != AUDIT_CTX_SYSCALL)\n\t\tgoto out;\n\n\t \n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(context);\n\n\taudit_return_fixup(context, success, return_code);\n\t \n\taudit_filter_syscall(current, context);\n\taudit_filter_inodes(current, context);\n\tif (context->current_state != AUDIT_STATE_RECORD)\n\t\tgoto out;\n\n\taudit_log_exit();\n\nout:\n\taudit_reset_context(context);\n}\n\nstatic inline void handle_one(const struct inode *inode)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n}\n\nstatic void handle_path(const struct dentry *dentry)\n{\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor (;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {   \n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t \n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t \n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t \n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n}\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n\treturn aname;\n}\n\n \nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tatomic_inc(&n->name->refcnt);\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nvoid __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tatomic_inc(&name->refcnt);\n}\n\nstatic inline int audit_copy_fcaps(struct audit_names *name,\n\t\t\t\t   const struct dentry *dentry)\n{\n\tstruct cpu_vfs_cap_data caps;\n\tint rc;\n\n\tif (!dentry)\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(&nop_mnt_idmap, dentry, &caps);\n\tif (rc)\n\t\treturn rc;\n\n\tname->fcap.permitted = caps.permitted;\n\tname->fcap.inheritable = caps.inheritable;\n\tname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tname->fcap.rootid = caps.rootid;\n\tname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >>\n\t\t\t\tVFS_CAP_REVISION_SHIFT;\n\n\treturn 0;\n}\n\n \nstatic void audit_copy_inode(struct audit_names *name,\n\t\t\t     const struct dentry *dentry,\n\t\t\t     struct inode *inode, unsigned int flags)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\tif (flags & AUDIT_INODE_NOEVAL) {\n\t\tname->fcap_ver = -1;\n\t\treturn;\n\t}\n\taudit_copy_fcaps(name, dentry);\n}\n\n \nvoid __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(inode->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t \n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t \n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t \n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t \n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tatomic_inc(&name->refcnt);\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode, flags & AUDIT_INODE_NOEVAL);\n}\n\nvoid __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}\n\n \nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst struct qstr *dname = &dentry->d_name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (context->context == AUDIT_CTX_UNUSED)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\tif (f->type == AUDIT_FSTYPE\n\t\t\t    && audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t\tf->op, f->val)\n\t\t\t    && e->rule.action == AUDIT_NEVER) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t \n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcond_resched();\n\n\t \n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t \n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname->name, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t \n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent, 0);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t \n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tatomic_inc(&found_child->name->refcnt);\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode, 0);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}\nEXPORT_SYMBOL_GPL(__audit_inode_child);\n\n \nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (ctx->context == AUDIT_CTX_UNUSED)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_STATE_RECORD;\n\t}\n\treturn 1;\n}\n\n \nvoid __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}\n\n \nvoid __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec64 *abs_timeout)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct timespec64 *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(*p));\n\telse\n\t\tmemset(p, 0, sizeof(*p));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}\n\n \n\nvoid __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}\n\n \nvoid __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}\n\n \nvoid __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}\n\n \nvoid __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}\n\nvoid __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}\n\n\n \nint __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}\n\n \nvoid __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}\n\n \nint __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}\n\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}\n\n \nint audit_signal_info_syscall(struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t t_uid = task_uid(t);\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t \n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid_obj(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}\n\n \nint __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = audit_context();\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(&nop_mnt_idmap,\n\t\t\t       bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap.rootid = vcaps.rootid;\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\tax->old_pcap.ambient     = old->cap_ambient;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\tax->new_pcap.ambient     = new->cap_ambient;\n\treturn 0;\n}\n\n \nvoid __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->capset.pid = task_tgid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->capset.cap.ambient     = new->cap_ambient;\n\tcontext->type = AUDIT_CAPSET;\n}\n\nvoid __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}\n\nvoid __audit_openat2_how(struct open_how *how)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->openat2.flags = how->flags;\n\tcontext->openat2.mode = how->mode;\n\tcontext->openat2.resolve = how->resolve;\n\tcontext->type = AUDIT_OPENAT2;\n}\n\nvoid __audit_log_kern_module(char *name)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->module.name = kstrdup(name, GFP_KERNEL);\n\tif (!context->module.name)\n\t\taudit_log_lost(\"out of memory in __audit_log_kern_module\");\n\tcontext->type = AUDIT_KERN_MODULE;\n}\n\nvoid __audit_fanotify(u32 response, struct fanotify_response_info_audit_rule *friar)\n{\n\t \n\tswitch (friar->hdr.type) {\n\tcase FAN_RESPONSE_INFO_NONE:\n\t\taudit_log(audit_context(), GFP_KERNEL, AUDIT_FANOTIFY,\n\t\t\t  \"resp=%u fan_type=%u fan_info=0 subj_trust=2 obj_trust=2\",\n\t\t\t  response, FAN_RESPONSE_INFO_NONE);\n\t\tbreak;\n\tcase FAN_RESPONSE_INFO_AUDIT_RULE:\n\t\taudit_log(audit_context(), GFP_KERNEL, AUDIT_FANOTIFY,\n\t\t\t  \"resp=%u fan_type=%u fan_info=%X subj_trust=%u obj_trust=%u\",\n\t\t\t  response, friar->hdr.type, friar->rule_number,\n\t\t\t  friar->subj_trust, friar->obj_trust);\n\t}\n}\n\nvoid __audit_tk_injoffset(struct timespec64 offset)\n{\n\tstruct audit_context *context = audit_context();\n\n\t \n\tif (!context->type)\n\t\tcontext->type = AUDIT_TIME_INJOFFSET;\n\tmemcpy(&context->time.tk_injoffset, &offset, sizeof(offset));\n}\n\nvoid __audit_ntp_log(const struct audit_ntp_data *ad)\n{\n\tstruct audit_context *context = audit_context();\n\tint type;\n\n\tfor (type = 0; type < AUDIT_NTP_NVALS; type++)\n\t\tif (ad->vals[type].newval != ad->vals[type].oldval) {\n\t\t\t \n\t\t\tcontext->type = AUDIT_TIME_ADJNTPVAL;\n\t\t\tmemcpy(&context->time.ntp_data, ad, sizeof(*ad));\n\t\t\tbreak;\n\t\t}\n}\n\nvoid __audit_log_nfcfg(const char *name, u8 af, unsigned int nentries,\n\t\t       enum audit_nfcfgop op, gfp_t gfp)\n{\n\tstruct audit_buffer *ab;\n\tchar comm[sizeof(current->comm)];\n\n\tab = audit_log_start(audit_context(), gfp, AUDIT_NETFILTER_CFG);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"table=%s family=%u entries=%u op=%s\",\n\t\t\t name, af, nentries, audit_nfcfgs[op].s);\n\n\taudit_log_format(ab, \" pid=%u\", task_pid_nr(current));\n\taudit_log_task_context(ab);  \n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_end(ab);\n}\nEXPORT_SYMBOL_GPL(__audit_log_nfcfg);\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}\n\n \nvoid audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t \n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld res=1\", signr);\n\taudit_log_end(ab);\n}\n\n \nvoid audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(current), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab,\n\t\t\t \"op=seccomp-logging actions=%s old-actions=%s res=%d\",\n\t\t\t names, old_names, res);\n\taudit_log_end(ab);\n}\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || ctx->context == AUDIT_CTX_UNUSED))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}