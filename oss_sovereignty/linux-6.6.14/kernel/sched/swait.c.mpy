{
  "module_name": "swait.c",
  "hash_id": "879ffb887593de3b6ceb7d1e152d90f206ae00fddc2e3ccbc938b3a4f64a7af8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/swait.c",
  "human_readable_source": "\n \n\nvoid __init_swait_queue_head(struct swait_queue_head *q, const char *name,\n\t\t\t     struct lock_class_key *key)\n{\n\traw_spin_lock_init(&q->lock);\n\tlockdep_set_class_and_name(&q->lock, key, name);\n\tINIT_LIST_HEAD(&q->task_list);\n}\nEXPORT_SYMBOL(__init_swait_queue_head);\n\n \nvoid swake_up_locked(struct swait_queue_head *q, int wake_flags)\n{\n\tstruct swait_queue *curr;\n\n\tif (list_empty(&q->task_list))\n\t\treturn;\n\n\tcurr = list_first_entry(&q->task_list, typeof(*curr), task_list);\n\ttry_to_wake_up(curr->task, TASK_NORMAL, wake_flags);\n\tlist_del_init(&curr->task_list);\n}\nEXPORT_SYMBOL(swake_up_locked);\n\n \nvoid swake_up_all_locked(struct swait_queue_head *q)\n{\n\twhile (!list_empty(&q->task_list))\n\t\tswake_up_locked(q, 0);\n}\n\nvoid swake_up_one(struct swait_queue_head *q)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tswake_up_locked(q, 0);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}\nEXPORT_SYMBOL(swake_up_one);\n\n \nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}\nEXPORT_SYMBOL(swake_up_all);\n\nvoid __prepare_to_swait(struct swait_queue_head *q, struct swait_queue *wait)\n{\n\twait->task = current;\n\tif (list_empty(&wait->task_list))\n\t\tlist_add_tail(&wait->task_list, &q->task_list);\n}\n\nvoid prepare_to_swait_exclusive(struct swait_queue_head *q, struct swait_queue *wait, int state)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\t__prepare_to_swait(q, wait);\n\tset_current_state(state);\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n}\nEXPORT_SYMBOL(prepare_to_swait_exclusive);\n\nlong prepare_to_swait_event(struct swait_queue_head *q, struct swait_queue *wait, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\traw_spin_lock_irqsave(&q->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t \n\t\tlist_del_init(&wait->task_list);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\t__prepare_to_swait(q, wait);\n\t\tset_current_state(state);\n\t}\n\traw_spin_unlock_irqrestore(&q->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(prepare_to_swait_event);\n\nvoid __finish_swait(struct swait_queue_head *q, struct swait_queue *wait)\n{\n\t__set_current_state(TASK_RUNNING);\n\tif (!list_empty(&wait->task_list))\n\t\tlist_del_init(&wait->task_list);\n}\n\nvoid finish_swait(struct swait_queue_head *q, struct swait_queue *wait)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!list_empty_careful(&wait->task_list)) {\n\t\traw_spin_lock_irqsave(&q->lock, flags);\n\t\tlist_del_init(&wait->task_list);\n\t\traw_spin_unlock_irqrestore(&q->lock, flags);\n\t}\n}\nEXPORT_SYMBOL(finish_swait);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}