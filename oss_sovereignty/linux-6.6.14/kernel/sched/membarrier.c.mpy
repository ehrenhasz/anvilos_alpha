{
  "module_name": "membarrier.c",
  "hash_id": "b37351c14ce79effe0ea420962de576a086bad4116119c7e43e0b8407a46af7f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/membarrier.c",
  "human_readable_source": "\n \n\n \n\n \n#ifdef CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE\n#define MEMBARRIER_PRIVATE_EXPEDITED_SYNC_CORE_BITMASK\t\t\t\\\n\t(MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE\t\t\t\\\n\t| MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE)\n#else\n#define MEMBARRIER_PRIVATE_EXPEDITED_SYNC_CORE_BITMASK\t0\n#endif\n\n#ifdef CONFIG_RSEQ\n#define MEMBARRIER_PRIVATE_EXPEDITED_RSEQ_BITMASK\t\t\\\n\t(MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ\t\t\t\\\n\t| MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ)\n#else\n#define MEMBARRIER_PRIVATE_EXPEDITED_RSEQ_BITMASK\t0\n#endif\n\n#define MEMBARRIER_CMD_BITMASK\t\t\t\t\t\t\\\n\t(MEMBARRIER_CMD_GLOBAL | MEMBARRIER_CMD_GLOBAL_EXPEDITED\t\\\n\t| MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED\t\t\t\\\n\t| MEMBARRIER_CMD_PRIVATE_EXPEDITED\t\t\t\t\\\n\t| MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED\t\t\t\\\n\t| MEMBARRIER_PRIVATE_EXPEDITED_SYNC_CORE_BITMASK\t\t\\\n\t| MEMBARRIER_PRIVATE_EXPEDITED_RSEQ_BITMASK\t\t\t\\\n\t| MEMBARRIER_CMD_GET_REGISTRATIONS)\n\nstatic void ipi_mb(void *info)\n{\n\tsmp_mb();\t \n}\n\nstatic void ipi_sync_core(void *info)\n{\n\t \n\tsmp_mb();\t \n\n\tsync_core_before_usermode();\n}\n\nstatic void ipi_rseq(void *info)\n{\n\t \n\tsmp_mb();\n\trseq_preempt(current);\n}\n\nstatic void ipi_sync_rq_state(void *info)\n{\n\tstruct mm_struct *mm = (struct mm_struct *) info;\n\n\tif (current->mm != mm)\n\t\treturn;\n\tthis_cpu_write(runqueues.membarrier_state,\n\t\t       atomic_read(&mm->membarrier_state));\n\t \n\tsmp_mb();\n}\n\nvoid membarrier_exec_mmap(struct mm_struct *mm)\n{\n\t \n\tsmp_mb();\n\tatomic_set(&mm->membarrier_state, 0);\n\t \n\tthis_cpu_write(runqueues.membarrier_state, 0);\n}\n\nvoid membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}\n\nstatic int membarrier_global_expedited(void)\n{\n\tint cpu;\n\tcpumask_var_t tmpmask;\n\n\tif (num_online_cpus() == 1)\n\t\treturn 0;\n\n\t \n\tsmp_mb();\t \n\n\tif (!zalloc_cpumask_var(&tmpmask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\trcu_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct task_struct *p;\n\n\t\t \n\t\tif (cpu == raw_smp_processor_id())\n\t\t\tcontinue;\n\n\t\tif (!(READ_ONCE(cpu_rq(cpu)->membarrier_state) &\n\t\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED))\n\t\t\tcontinue;\n\n\t\t \n\t\tp = rcu_dereference(cpu_rq(cpu)->curr);\n\t\tif (!p->mm)\n\t\t\tcontinue;\n\n\t\t__cpumask_set_cpu(cpu, tmpmask);\n\t}\n\trcu_read_unlock();\n\n\tpreempt_disable();\n\tsmp_call_function_many(tmpmask, ipi_mb, NULL, 1);\n\tpreempt_enable();\n\n\tfree_cpumask_var(tmpmask);\n\tcpus_read_unlock();\n\n\t \n\tsmp_mb();\t \n\treturn 0;\n}\n\nstatic int membarrier_private_expedited(int flags, int cpu_id)\n{\n\tcpumask_var_t tmpmask;\n\tstruct mm_struct *mm = current->mm;\n\tsmp_call_func_t ipi_func = ipi_mb;\n\n\tif (flags == MEMBARRIER_FLAG_SYNC_CORE) {\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE))\n\t\t\treturn -EINVAL;\n\t\tif (!(atomic_read(&mm->membarrier_state) &\n\t\t      MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY))\n\t\t\treturn -EPERM;\n\t\tipi_func = ipi_sync_core;\n\t} else if (flags == MEMBARRIER_FLAG_RSEQ) {\n\t\tif (!IS_ENABLED(CONFIG_RSEQ))\n\t\t\treturn -EINVAL;\n\t\tif (!(atomic_read(&mm->membarrier_state) &\n\t\t      MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY))\n\t\t\treturn -EPERM;\n\t\tipi_func = ipi_rseq;\n\t} else {\n\t\tWARN_ON_ONCE(flags);\n\t\tif (!(atomic_read(&mm->membarrier_state) &\n\t\t      MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY))\n\t\t\treturn -EPERM;\n\t}\n\n\tif (flags != MEMBARRIER_FLAG_SYNC_CORE &&\n\t    (atomic_read(&mm->mm_users) == 1 || num_online_cpus() == 1))\n\t\treturn 0;\n\n\t \n\tsmp_mb();\t \n\n\tif (cpu_id < 0 && !zalloc_cpumask_var(&tmpmask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tif (cpu_id >= 0) {\n\t\tstruct task_struct *p;\n\n\t\tif (cpu_id >= nr_cpu_ids || !cpu_online(cpu_id))\n\t\t\tgoto out;\n\t\trcu_read_lock();\n\t\tp = rcu_dereference(cpu_rq(cpu_id)->curr);\n\t\tif (!p || p->mm != mm) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\tint cpu;\n\n\t\trcu_read_lock();\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tstruct task_struct *p;\n\n\t\t\tp = rcu_dereference(cpu_rq(cpu)->curr);\n\t\t\tif (p && p->mm == mm)\n\t\t\t\t__cpumask_set_cpu(cpu, tmpmask);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (cpu_id >= 0) {\n\t\t \n\t\tsmp_call_function_single(cpu_id, ipi_func, NULL, 1);\n\t} else {\n\t\t \n\t\tif (flags != MEMBARRIER_FLAG_SYNC_CORE) {\n\t\t\tpreempt_disable();\n\t\t\tsmp_call_function_many(tmpmask, ipi_func, NULL, true);\n\t\t\tpreempt_enable();\n\t\t} else {\n\t\t\ton_each_cpu_mask(tmpmask, ipi_func, NULL, true);\n\t\t}\n\t}\n\nout:\n\tif (cpu_id < 0)\n\t\tfree_cpumask_var(tmpmask);\n\tcpus_read_unlock();\n\n\t \n\tsmp_mb();\t \n\n\treturn 0;\n}\n\nstatic int sync_runqueues_membarrier_state(struct mm_struct *mm)\n{\n\tint membarrier_state = atomic_read(&mm->membarrier_state);\n\tcpumask_var_t tmpmask;\n\tint cpu;\n\n\tif (atomic_read(&mm->mm_users) == 1 || num_online_cpus() == 1) {\n\t\tthis_cpu_write(runqueues.membarrier_state, membarrier_state);\n\n\t\t \n\t\tsmp_mb();\n\t\treturn 0;\n\t}\n\n\tif (!zalloc_cpumask_var(&tmpmask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tsynchronize_rcu();\n\n\t \n\tcpus_read_lock();\n\trcu_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\t\tstruct task_struct *p;\n\n\t\tp = rcu_dereference(rq->curr);\n\t\tif (p && p->mm == mm)\n\t\t\t__cpumask_set_cpu(cpu, tmpmask);\n\t}\n\trcu_read_unlock();\n\n\ton_each_cpu_mask(tmpmask, ipi_sync_rq_state, mm, true);\n\n\tfree_cpumask_var(tmpmask);\n\tcpus_read_unlock();\n\n\treturn 0;\n}\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}\n\nstatic int membarrier_register_private_expedited(int flags)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ready_state = MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY,\n\t    set_state = MEMBARRIER_STATE_PRIVATE_EXPEDITED,\n\t    ret;\n\n\tif (flags == MEMBARRIER_FLAG_SYNC_CORE) {\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE))\n\t\t\treturn -EINVAL;\n\t\tready_state =\n\t\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY;\n\t} else if (flags == MEMBARRIER_FLAG_RSEQ) {\n\t\tif (!IS_ENABLED(CONFIG_RSEQ))\n\t\t\treturn -EINVAL;\n\t\tready_state =\n\t\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY;\n\t} else {\n\t\tWARN_ON_ONCE(flags);\n\t}\n\n\t \n\tif ((atomic_read(&mm->membarrier_state) & ready_state) == ready_state)\n\t\treturn 0;\n\tif (flags & MEMBARRIER_FLAG_SYNC_CORE)\n\t\tset_state |= MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE;\n\tif (flags & MEMBARRIER_FLAG_RSEQ)\n\t\tset_state |= MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ;\n\tatomic_or(set_state, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(ready_state, &mm->membarrier_state);\n\n\treturn 0;\n}\n\nstatic int membarrier_get_registrations(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint registrations_mask = 0, membarrier_state, i;\n\tstatic const int states[] = {\n\t\tMEMBARRIER_STATE_GLOBAL_EXPEDITED |\n\t\t\tMEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED |\n\t\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_READY,\n\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE |\n\t\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY,\n\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ |\n\t\t\tMEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY\n\t};\n\tstatic const int registration_cmds[] = {\n\t\tMEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED,\n\t\tMEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED,\n\t\tMEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE,\n\t\tMEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ\n\t};\n\tBUILD_BUG_ON(ARRAY_SIZE(states) != ARRAY_SIZE(registration_cmds));\n\n\tmembarrier_state = atomic_read(&mm->membarrier_state);\n\tfor (i = 0; i < ARRAY_SIZE(states); ++i) {\n\t\tif (membarrier_state & states[i]) {\n\t\t\tregistrations_mask |= registration_cmds[i];\n\t\t\tmembarrier_state &= ~states[i];\n\t\t}\n\t}\n\tWARN_ON_ONCE(membarrier_state != 0);\n\treturn registrations_mask;\n}\n\n \nSYSCALL_DEFINE3(membarrier, int, cmd, unsigned int, flags, int, cpu_id)\n{\n\tswitch (cmd) {\n\tcase MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ:\n\t\tif (unlikely(flags && flags != MEMBARRIER_CMD_FLAG_CPU))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely(flags))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(flags & MEMBARRIER_CMD_FLAG_CPU))\n\t\tcpu_id = -1;\n\n\tswitch (cmd) {\n\tcase MEMBARRIER_CMD_QUERY:\n\t{\n\t\tint cmd_mask = MEMBARRIER_CMD_BITMASK;\n\n\t\tif (tick_nohz_full_enabled())\n\t\t\tcmd_mask &= ~MEMBARRIER_CMD_GLOBAL;\n\t\treturn cmd_mask;\n\t}\n\tcase MEMBARRIER_CMD_GLOBAL:\n\t\t \n\t\tif (tick_nohz_full_enabled())\n\t\t\treturn -EINVAL;\n\t\tif (num_online_cpus() > 1)\n\t\t\tsynchronize_rcu();\n\t\treturn 0;\n\tcase MEMBARRIER_CMD_GLOBAL_EXPEDITED:\n\t\treturn membarrier_global_expedited();\n\tcase MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED:\n\t\treturn membarrier_register_global_expedited();\n\tcase MEMBARRIER_CMD_PRIVATE_EXPEDITED:\n\t\treturn membarrier_private_expedited(0, cpu_id);\n\tcase MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED:\n\t\treturn membarrier_register_private_expedited(0);\n\tcase MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE:\n\t\treturn membarrier_private_expedited(MEMBARRIER_FLAG_SYNC_CORE, cpu_id);\n\tcase MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE:\n\t\treturn membarrier_register_private_expedited(MEMBARRIER_FLAG_SYNC_CORE);\n\tcase MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ:\n\t\treturn membarrier_private_expedited(MEMBARRIER_FLAG_RSEQ, cpu_id);\n\tcase MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ:\n\t\treturn membarrier_register_private_expedited(MEMBARRIER_FLAG_RSEQ);\n\tcase MEMBARRIER_CMD_GET_REGISTRATIONS:\n\t\treturn membarrier_get_registrations();\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}