{
  "module_name": "core_sched.c",
  "hash_id": "130479164fb28056c7d3729bf60dcca9537f4bb26f79ce7a99161450fce639ae",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/core_sched.c",
  "human_readable_source": "\n\n \nstruct sched_core_cookie {\n\trefcount_t refcnt;\n};\n\nstatic unsigned long sched_core_alloc_cookie(void)\n{\n\tstruct sched_core_cookie *ck = kmalloc(sizeof(*ck), GFP_KERNEL);\n\tif (!ck)\n\t\treturn 0;\n\n\trefcount_set(&ck->refcnt, 1);\n\tsched_core_get();\n\n\treturn (unsigned long)ck;\n}\n\nstatic void sched_core_put_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr && refcount_dec_and_test(&ptr->refcnt)) {\n\t\tkfree(ptr);\n\t\tsched_core_put();\n\t}\n}\n\nstatic unsigned long sched_core_get_cookie(unsigned long cookie)\n{\n\tstruct sched_core_cookie *ptr = (void *)cookie;\n\n\tif (ptr)\n\t\trefcount_inc(&ptr->refcnt);\n\n\treturn cookie;\n}\n\n \nstatic unsigned long sched_core_update_cookie(struct task_struct *p,\n\t\t\t\t\t      unsigned long cookie)\n{\n\tunsigned long old_cookie;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\t \n\tSCHED_WARN_ON((p->core_cookie || cookie) && !sched_core_enabled(rq));\n\n\tif (sched_core_enqueued(p))\n\t\tsched_core_dequeue(rq, p, DEQUEUE_SAVE);\n\n\told_cookie = p->core_cookie;\n\tp->core_cookie = cookie;\n\n\t \n\tif (cookie && task_on_rq_queued(p))\n\t\tsched_core_enqueue(rq, p);\n\n\t \n\tif (task_on_cpu(rq, p))\n\t\tresched_curr(rq);\n\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn old_cookie;\n}\n\nstatic unsigned long sched_core_clone_cookie(struct task_struct *p)\n{\n\tunsigned long cookie, flags;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcookie = sched_core_get_cookie(p->core_cookie);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn cookie;\n}\n\nvoid sched_core_fork(struct task_struct *p)\n{\n\tRB_CLEAR_NODE(&p->core_node);\n\tp->core_cookie = sched_core_clone_cookie(current);\n}\n\nvoid sched_core_free(struct task_struct *p)\n{\n\tsched_core_put_cookie(p->core_cookie);\n}\n\nstatic void __sched_core_set(struct task_struct *p, unsigned long cookie)\n{\n\tcookie = sched_core_get_cookie(cookie);\n\tcookie = sched_core_update_cookie(p, cookie);\n\tsched_core_put_cookie(cookie);\n}\n\n \nint sched_core_share_pid(unsigned int cmd, pid_t pid, enum pid_type type,\n\t\t\t unsigned long uaddr)\n{\n\tunsigned long cookie = 0, id = 0;\n\tstruct task_struct *task, *p;\n\tstruct pid *grp;\n\tint err = 0;\n\n\tif (!static_branch_likely(&sched_smt_present))\n\t\treturn -ENODEV;\n\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD != PIDTYPE_PID);\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_THREAD_GROUP != PIDTYPE_TGID);\n\tBUILD_BUG_ON(PR_SCHED_CORE_SCOPE_PROCESS_GROUP != PIDTYPE_PGID);\n\n\tif (type > PIDTYPE_PGID || cmd >= PR_SCHED_CORE_MAX || pid < 0 ||\n\t    (cmd != PR_SCHED_CORE_GET && uaddr))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tif (pid == 0) {\n\t\ttask = current;\n\t} else {\n\t\ttask = find_task_by_vpid(pid);\n\t\tif (!task) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\tget_task_struct(task);\n\trcu_read_unlock();\n\n\t \n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase PR_SCHED_CORE_GET:\n\t\tif (type != PIDTYPE_PID || uaddr & 7) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcookie = sched_core_clone_cookie(task);\n\t\tif (cookie) {\n\t\t\t \n\t\t\tptr_to_hashval((void *)cookie, &id);\n\t\t}\n\t\terr = put_user(id, (u64 __user *)uaddr);\n\t\tgoto out;\n\n\tcase PR_SCHED_CORE_CREATE:\n\t\tcookie = sched_core_alloc_cookie();\n\t\tif (!cookie) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase PR_SCHED_CORE_SHARE_TO:\n\t\tcookie = sched_core_clone_cookie(current);\n\t\tbreak;\n\n\tcase PR_SCHED_CORE_SHARE_FROM:\n\t\tif (type != PIDTYPE_PID) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcookie = sched_core_clone_cookie(task);\n\t\t__sched_core_set(current, cookie);\n\t\tgoto out;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (type == PIDTYPE_PID) {\n\t\t__sched_core_set(task, cookie);\n\t\tgoto out;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tgrp = task_pid_type(task, type);\n\n\tdo_each_pid_thread(grp, type, p) {\n\t\tif (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_tasklist;\n\t\t}\n\t} while_each_pid_thread(grp, type, p);\n\n\tdo_each_pid_thread(grp, type, p) {\n\t\t__sched_core_set(p, cookie);\n\t} while_each_pid_thread(grp, type, p);\nout_tasklist:\n\tread_unlock(&tasklist_lock);\n\nout:\n\tsched_core_put_cookie(cookie);\n\tput_task_struct(task);\n\treturn err;\n}\n\n#ifdef CONFIG_SCHEDSTATS\n\n \nvoid __sched_core_account_forceidle(struct rq *rq)\n{\n\tconst struct cpumask *smt_mask = cpu_smt_mask(cpu_of(rq));\n\tu64 delta, now = rq_clock(rq->core);\n\tstruct rq *rq_i;\n\tstruct task_struct *p;\n\tint i;\n\n\tlockdep_assert_rq_held(rq);\n\n\tWARN_ON_ONCE(!rq->core->core_forceidle_count);\n\n\tif (rq->core->core_forceidle_start == 0)\n\t\treturn;\n\n\tdelta = now - rq->core->core_forceidle_start;\n\tif (unlikely((s64)delta <= 0))\n\t\treturn;\n\n\trq->core->core_forceidle_start = now;\n\n\tif (WARN_ON_ONCE(!rq->core->core_forceidle_occupation)) {\n\t\t \n\t} else if (rq->core->core_forceidle_count > 1 ||\n\t\t   rq->core->core_forceidle_occupation > 1) {\n\t\t \n\t\tdelta *= rq->core->core_forceidle_count;\n\t\tdelta = div_u64(delta, rq->core->core_forceidle_occupation);\n\t}\n\n\tfor_each_cpu(i, smt_mask) {\n\t\trq_i = cpu_rq(i);\n\t\tp = rq_i->core_pick ?: rq_i->curr;\n\n\t\tif (p == rq_i->idle)\n\t\t\tcontinue;\n\n\t\t \n\t\t__account_forceidle_time(p, delta);\n\t}\n}\n\nvoid __sched_core_tick(struct rq *rq)\n{\n\tif (!rq->core->core_forceidle_count)\n\t\treturn;\n\n\tif (rq != rq->core)\n\t\tupdate_rq_clock(rq->core);\n\n\t__sched_core_account_forceidle(rq);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}