{
  "module_name": "wait.c",
  "hash_id": "7294e71ab81f7544b5bb314b1160ce52d6211a7e30656ff6caed6896a693b93e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/wait.c",
  "human_readable_source": "\n \n\nvoid __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)\n{\n\tspin_lock_init(&wq_head->lock);\n\tlockdep_set_class_and_name(&wq_head->lock, key, name);\n\tINIT_LIST_HEAD(&wq_head->head);\n}\n\nEXPORT_SYMBOL(__init_waitqueue_head);\n\nvoid add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}\nEXPORT_SYMBOL(add_wait_queue);\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}\nEXPORT_SYMBOL(add_wait_queue_exclusive);\n\nvoid add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}\nEXPORT_SYMBOL_GPL(add_wait_queue_priority);\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}\nEXPORT_SYMBOL(remove_wait_queue);\n\n \n#define WAITQUEUE_WALK_BREAK_CNT 64\n\n \nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}\n\nstatic int __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\tint remaining = nr_exclusive;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tremaining = __wake_up_common(wq_head, mode, remaining,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n\n\treturn nr_exclusive - remaining;\n}\n\n \nint __wake_up(struct wait_queue_head *wq_head, unsigned int mode,\n\t      int nr_exclusive, void *key)\n{\n\treturn __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);\n}\nEXPORT_SYMBOL(__wake_up);\n\nvoid __wake_up_on_current_cpu(struct wait_queue_head *wq_head, unsigned int mode, void *key)\n{\n\t__wake_up_common_lock(wq_head, mode, 1, WF_CURRENT_CPU, key);\n}\n\n \nvoid __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)\n{\n\t__wake_up_common(wq_head, mode, nr, 0, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(__wake_up_locked);\n\nvoid __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, NULL);\n}\nEXPORT_SYMBOL_GPL(__wake_up_locked_key);\n\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}\nEXPORT_SYMBOL_GPL(__wake_up_locked_key_bookmark);\n\n \nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}\nEXPORT_SYMBOL_GPL(__wake_up_sync_key);\n\n \nvoid __wake_up_locked_sync_key(struct wait_queue_head *wq_head,\n\t\t\t       unsigned int mode, void *key)\n{\n        __wake_up_common(wq_head, mode, 1, WF_SYNC, key, NULL);\n}\nEXPORT_SYMBOL_GPL(__wake_up_locked_sync_key);\n\n \nvoid __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode)\n{\n\t__wake_up_sync_key(wq_head, mode, NULL);\n}\nEXPORT_SYMBOL_GPL(__wake_up_sync);\t \n\nvoid __wake_up_pollfree(struct wait_queue_head *wq_head)\n{\n\t__wake_up(wq_head, TASK_NORMAL, 0, poll_to_key(EPOLLHUP | POLLFREE));\n\t \n\tWARN_ON_ONCE(waitqueue_active(wq_head));\n}\n\n \nvoid\nprepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}\nEXPORT_SYMBOL(prepare_to_wait);\n\n \nbool\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tbool was_empty = false;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry)) {\n\t\twas_empty = list_empty(&wq_head->head);\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t}\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\treturn was_empty;\n}\nEXPORT_SYMBOL(prepare_to_wait_exclusive);\n\nvoid init_wait_entry(struct wait_queue_entry *wq_entry, int flags)\n{\n\twq_entry->flags = flags;\n\twq_entry->private = current;\n\twq_entry->func = autoremove_wake_function;\n\tINIT_LIST_HEAD(&wq_entry->entry);\n}\nEXPORT_SYMBOL(init_wait_entry);\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t \n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(prepare_to_wait_event);\n\n \nint do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock(&wq->lock);\n\tschedule();\n\tspin_lock(&wq->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(do_wait_intr);\n\nint do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock_irq(&wq->lock);\n\tschedule();\n\tspin_lock_irq(&wq->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(do_wait_intr_irq);\n\n \nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t \n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}\nEXPORT_SYMBOL(finish_wait);\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init_careful(&wq_entry->entry);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(autoremove_wake_function);\n\n \nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)\n{\n\t \n\tset_current_state(mode);  \n\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !kthread_should_stop_or_park())\n\t\ttimeout = schedule_timeout(timeout);\n\t__set_current_state(TASK_RUNNING);\n\n\t \n\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN);  \n\n\treturn timeout;\n}\nEXPORT_SYMBOL(wait_woken);\n\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\t \n\tsmp_mb();  \n\twq_entry->flags |= WQ_FLAG_WOKEN;\n\n\treturn default_wake_function(wq_entry, mode, sync, key);\n}\nEXPORT_SYMBOL(woken_wake_function);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}