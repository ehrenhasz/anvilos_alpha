{
  "module_name": "cpupri.c",
  "hash_id": "e8eacf41bcd1903888179c637fa22cbb4ed2b8327c76f97804fa7e27247c44cb",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/cpupri.c",
  "human_readable_source": "\n \n\n \nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tswitch (prio) {\n\tcase CPUPRI_INVALID:\n\t\tcpupri = CPUPRI_INVALID;\t \n\t\tbreak;\n\n\tcase 0 ... 98:\n\t\tcpupri = MAX_RT_PRIO-1 - prio;\t \n\t\tbreak;\n\n\tcase MAX_RT_PRIO-1:\n\t\tcpupri = CPUPRI_NORMAL;\t\t \n\t\tbreak;\n\n\tcase MAX_RT_PRIO:\n\t\tcpupri = CPUPRI_HIGHER;\t\t \n\t\tbreak;\n\t}\n\n\treturn cpupri;\n}\n\nstatic inline int __cpupri_find(struct cpupri *cp, struct task_struct *p,\n\t\t\t\tstruct cpumask *lowest_mask, int idx)\n{\n\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[idx];\n\tint skip = 0;\n\n\tif (!atomic_read(&(vec)->count))\n\t\tskip = 1;\n\t \n\tsmp_rmb();\n\n\t \n\tif (skip)\n\t\treturn 0;\n\n\tif (cpumask_any_and(&p->cpus_mask, vec->mask) >= nr_cpu_ids)\n\t\treturn 0;\n\n\tif (lowest_mask) {\n\t\tcpumask_and(lowest_mask, &p->cpus_mask, vec->mask);\n\t\tcpumask_and(lowest_mask, lowest_mask, cpu_active_mask);\n\n\t\t \n\t\tif (cpumask_empty(lowest_mask))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint cpupri_find(struct cpupri *cp, struct task_struct *p,\n\t\tstruct cpumask *lowest_mask)\n{\n\treturn cpupri_find_fitness(cp, p, lowest_mask, NULL);\n}\n\n \nint cpupri_find_fitness(struct cpupri *cp, struct task_struct *p,\n\t\tstruct cpumask *lowest_mask,\n\t\tbool (*fitness_fn)(struct task_struct *p, int cpu))\n{\n\tint task_pri = convert_prio(p->prio);\n\tint idx, cpu;\n\n\tWARN_ON_ONCE(task_pri >= CPUPRI_NR_PRIORITIES);\n\n\tfor (idx = 0; idx < task_pri; idx++) {\n\n\t\tif (!__cpupri_find(cp, p, lowest_mask, idx))\n\t\t\tcontinue;\n\n\t\tif (!lowest_mask || !fitness_fn)\n\t\t\treturn 1;\n\n\t\t \n\t\tfor_each_cpu(cpu, lowest_mask) {\n\t\t\tif (!fitness_fn(p, cpu))\n\t\t\t\tcpumask_clear_cpu(cpu, lowest_mask);\n\t\t}\n\n\t\t \n\t\tif (cpumask_empty(lowest_mask))\n\t\t\tcontinue;\n\n\t\treturn 1;\n\t}\n\n\t \n\tif (fitness_fn)\n\t\treturn cpupri_find(cp, p, lowest_mask);\n\n\treturn 0;\n}\n\n \nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t \n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t \n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t \n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}\n\n \nint cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, GFP_KERNEL))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), GFP_KERNEL);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = CPUPRI_INVALID;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -ENOMEM;\n}\n\n \nvoid cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < CPUPRI_NR_PRIORITIES; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}