{
  "module_name": "wait_bit.c",
  "hash_id": "8de288b47f044879b08e98647c067f4521059a805031f73651742d6bfc0ff44b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/wait_bit.c",
  "human_readable_source": "\n\n \n\n#define WAIT_TABLE_BITS 8\n#define WAIT_TABLE_SIZE (1 << WAIT_TABLE_BITS)\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE] __cacheline_aligned;\n\nwait_queue_head_t *bit_waitqueue(void *word, int bit)\n{\n\tconst int shift = BITS_PER_LONG == 32 ? 5 : 6;\n\tunsigned long val = (unsigned long)word << shift | bit;\n\n\treturn bit_wait_table + hash_long(val, WAIT_TABLE_BITS);\n}\nEXPORT_SYMBOL(bit_waitqueue);\n\nint wake_bit_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *arg)\n{\n\tstruct wait_bit_key *key = arg;\n\tstruct wait_bit_queue_entry *wait_bit = container_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\n\n\tif (wait_bit->key.flags != key->flags ||\n\t\t\twait_bit->key.bit_nr != key->bit_nr ||\n\t\t\ttest_bit(key->bit_nr, key->flags))\n\t\treturn 0;\n\n\treturn autoremove_wake_function(wq_entry, mode, sync, key);\n}\nEXPORT_SYMBOL(wake_bit_function);\n\n \nint __sched\n__wait_on_bit(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t      wait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tdo {\n\t\tprepare_to_wait(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags))\n\t\t\tret = (*action)(&wbq_entry->key, mode);\n\t} while (test_bit_acquire(wbq_entry->key.bit_nr, wbq_entry->key.flags) && !ret);\n\n\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__wait_on_bit);\n\nint __sched out_of_line_wait_on_bit(void *word, int bit,\n\t\t\t\t    wait_bit_action_f *action, unsigned mode)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);\n}\nEXPORT_SYMBOL(out_of_line_wait_on_bit);\n\nint __sched out_of_line_wait_on_bit_timeout(\n\tvoid *word, int bit, wait_bit_action_f *action,\n\tunsigned mode, unsigned long timeout)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\twq_entry.key.timeout = jiffies + timeout;\n\n\treturn __wait_on_bit(wq_head, &wq_entry, action, mode);\n}\nEXPORT_SYMBOL_GPL(out_of_line_wait_on_bit_timeout);\n\nint __sched\n__wait_on_bit_lock(struct wait_queue_head *wq_head, struct wait_bit_queue_entry *wbq_entry,\n\t\t\twait_bit_action_f *action, unsigned mode)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(wq_head, &wbq_entry->wq_entry, mode);\n\t\tif (test_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tret = action(&wbq_entry->key, mode);\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t}\n\t\tif (!test_and_set_bit(wbq_entry->key.bit_nr, wbq_entry->key.flags)) {\n\t\t\tif (!ret)\n\t\t\t\tfinish_wait(wq_head, &wbq_entry->wq_entry);\n\t\t\treturn 0;\n\t\t} else if (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(__wait_on_bit_lock);\n\nint __sched out_of_line_wait_on_bit_lock(void *word, int bit,\n\t\t\t\t\t wait_bit_action_f *action, unsigned mode)\n{\n\tstruct wait_queue_head *wq_head = bit_waitqueue(word, bit);\n\tDEFINE_WAIT_BIT(wq_entry, word, bit);\n\n\treturn __wait_on_bit_lock(wq_head, &wq_entry, action, mode);\n}\nEXPORT_SYMBOL(out_of_line_wait_on_bit_lock);\n\nvoid __wake_up_bit(struct wait_queue_head *wq_head, void *word, int bit)\n{\n\tstruct wait_bit_key key = __WAIT_BIT_KEY_INITIALIZER(word, bit);\n\n\tif (waitqueue_active(wq_head))\n\t\t__wake_up(wq_head, TASK_NORMAL, 1, &key);\n}\nEXPORT_SYMBOL(__wake_up_bit);\n\n \nvoid wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}\nEXPORT_SYMBOL(wake_up_bit);\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}\nEXPORT_SYMBOL(__var_waitqueue);\n\nstatic int\nvar_wake_function(struct wait_queue_entry *wq_entry, unsigned int mode,\n\t\t  int sync, void *arg)\n{\n\tstruct wait_bit_key *key = arg;\n\tstruct wait_bit_queue_entry *wbq_entry =\n\t\tcontainer_of(wq_entry, struct wait_bit_queue_entry, wq_entry);\n\n\tif (wbq_entry->key.flags != key->flags ||\n\t    wbq_entry->key.bit_nr != key->bit_nr)\n\t\treturn 0;\n\n\treturn autoremove_wake_function(wq_entry, mode, sync, key);\n}\n\nvoid init_wait_var_entry(struct wait_bit_queue_entry *wbq_entry, void *var, int flags)\n{\n\t*wbq_entry = (struct wait_bit_queue_entry){\n\t\t.key = {\n\t\t\t.flags\t= (var),\n\t\t\t.bit_nr = -1,\n\t\t},\n\t\t.wq_entry = {\n\t\t\t.flags\t = flags,\n\t\t\t.private = current,\n\t\t\t.func\t = var_wake_function,\n\t\t\t.entry\t = LIST_HEAD_INIT(wbq_entry->wq_entry.entry),\n\t\t},\n\t};\n}\nEXPORT_SYMBOL(init_wait_var_entry);\n\nvoid wake_up_var(void *var)\n{\n\t__wake_up_bit(__var_waitqueue(var), var, -1);\n}\nEXPORT_SYMBOL(wake_up_var);\n\n__sched int bit_wait(struct wait_bit_key *word, int mode)\n{\n\tschedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(bit_wait);\n\n__sched int bit_wait_io(struct wait_bit_key *word, int mode)\n{\n\tio_schedule();\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(bit_wait_io);\n\n__sched int bit_wait_timeout(struct wait_bit_key *word, int mode)\n{\n\tunsigned long now = READ_ONCE(jiffies);\n\n\tif (time_after_eq(now, word->timeout))\n\t\treturn -EAGAIN;\n\tschedule_timeout(word->timeout - now);\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bit_wait_timeout);\n\n__sched int bit_wait_io_timeout(struct wait_bit_key *word, int mode)\n{\n\tunsigned long now = READ_ONCE(jiffies);\n\n\tif (time_after_eq(now, word->timeout))\n\t\treturn -EAGAIN;\n\tio_schedule_timeout(word->timeout - now);\n\tif (signal_pending_state(mode, current))\n\t\treturn -EINTR;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bit_wait_io_timeout);\n\nvoid __init wait_bit_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < WAIT_TABLE_SIZE; i++)\n\t\tinit_waitqueue_head(bit_wait_table + i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}