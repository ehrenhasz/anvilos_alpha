{
  "module_name": "autogroup.c",
  "hash_id": "fa5f47a406669ae37a734047ea59fcd5932bfb3a61df15c19c0963d14dae53d8",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/autogroup.c",
  "human_readable_source": "\n\n \n\nunsigned int __read_mostly sysctl_sched_autogroup_enabled = 1;\nstatic struct autogroup autogroup_default;\nstatic atomic_t autogroup_seq_nr;\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table sched_autogroup_sysctls[] = {\n\t{\n\t\t.procname       = \"sched_autogroup_enabled\",\n\t\t.data           = &sysctl_sched_autogroup_enabled,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{}\n};\n\nstatic void __init sched_autogroup_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", sched_autogroup_sysctls);\n}\n#else\n#define sched_autogroup_sysctl_init() do { } while (0)\n#endif\n\nvoid __init autogroup_init(struct task_struct *init_task)\n{\n\tautogroup_default.tg = &root_task_group;\n\tkref_init(&autogroup_default.kref);\n\tinit_rwsem(&autogroup_default.lock);\n\tinit_task->signal->autogroup = &autogroup_default;\n\tsched_autogroup_sysctl_init();\n}\n\nvoid autogroup_free(struct task_group *tg)\n{\n\tkfree(tg->autogroup);\n}\n\nstatic inline void autogroup_destroy(struct kref *kref)\n{\n\tstruct autogroup *ag = container_of(kref, struct autogroup, kref);\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\t \n\tag->tg->rt_se = NULL;\n\tag->tg->rt_rq = NULL;\n#endif\n\tsched_release_group(ag->tg);\n\tsched_destroy_group(ag->tg);\n}\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}\n\nstatic inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}\n\nstatic inline struct autogroup *autogroup_create(void)\n{\n\tstruct autogroup *ag = kzalloc(sizeof(*ag), GFP_KERNEL);\n\tstruct task_group *tg;\n\n\tif (!ag)\n\t\tgoto out_fail;\n\n\ttg = sched_create_group(&root_task_group);\n\tif (IS_ERR(tg))\n\t\tgoto out_free;\n\n\tkref_init(&ag->kref);\n\tinit_rwsem(&ag->lock);\n\tag->id = atomic_inc_return(&autogroup_seq_nr);\n\tag->tg = tg;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t \n\tfree_rt_sched_group(tg);\n\ttg->rt_se = root_task_group.rt_se;\n\ttg->rt_rq = root_task_group.rt_rq;\n#endif\n\ttg->autogroup = ag;\n\n\tsched_online_group(tg, &root_task_group);\n\treturn ag;\n\nout_free:\n\tkfree(ag);\nout_fail:\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_WARNING \"autogroup_create: %s failure.\\n\",\n\t\t\tag ? \"sched_create_group()\" : \"kzalloc()\");\n\t}\n\n\treturn autogroup_kref_get(&autogroup_default);\n}\n\nbool task_wants_autogroup(struct task_struct *p, struct task_group *tg)\n{\n\tif (tg != &root_task_group)\n\t\treturn false;\n\t \n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid sched_autogroup_exit_task(struct task_struct *p)\n{\n\t \n\tsched_move_task(p);\n}\n\nstatic void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tif (WARN_ON_ONCE(!lock_task_sighand(p, &flags)))\n\t\treturn;\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t \n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}\n\n \nvoid sched_autogroup_create_attach(struct task_struct *p)\n{\n\tstruct autogroup *ag = autogroup_create();\n\n\tautogroup_move_group(p, ag);\n\n\t \n\tautogroup_kref_put(ag);\n}\nEXPORT_SYMBOL(sched_autogroup_create_attach);\n\n \nvoid sched_autogroup_detach(struct task_struct *p)\n{\n\tautogroup_move_group(p, &autogroup_default);\n}\nEXPORT_SYMBOL(sched_autogroup_detach);\n\nvoid sched_autogroup_fork(struct signal_struct *sig)\n{\n\tsig->autogroup = autogroup_task_get(current);\n}\n\nvoid sched_autogroup_exit(struct signal_struct *sig)\n{\n\tautogroup_kref_put(sig->autogroup);\n}\n\nstatic int __init setup_autogroup(char *str)\n{\n\tsysctl_sched_autogroup_enabled = 0;\n\n\treturn 1;\n}\n__setup(\"noautogroup\", setup_autogroup);\n\n#ifdef CONFIG_PROC_FS\n\nint proc_sched_autogroup_set_nice(struct task_struct *p, int nice)\n{\n\tstatic unsigned long next = INITIAL_JIFFIES;\n\tstruct autogroup *ag;\n\tunsigned long shares;\n\tint err, idx;\n\n\tif (nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn -EINVAL;\n\n\terr = security_task_setnice(current, nice);\n\tif (err)\n\t\treturn err;\n\n\tif (nice < 0 && !can_nice(current, nice))\n\t\treturn -EPERM;\n\n\t \n\tif (!capable(CAP_SYS_ADMIN) && time_before(jiffies, next))\n\t\treturn -EAGAIN;\n\n\tnext = HZ / 10 + jiffies;\n\tag = autogroup_task_get(p);\n\n\tidx = array_index_nospec(nice + 20, 40);\n\tshares = scale_load(sched_prio_to_weight[idx]);\n\n\tdown_write(&ag->lock);\n\terr = sched_group_set_shares(ag->tg, shares);\n\tif (!err)\n\t\tag->nice = nice;\n\tup_write(&ag->lock);\n\n\tautogroup_kref_put(ag);\n\n\treturn err;\n}\n\nvoid proc_sched_autogroup_show_task(struct task_struct *p, struct seq_file *m)\n{\n\tstruct autogroup *ag = autogroup_task_get(p);\n\n\tif (!task_group_is_autogroup(ag->tg))\n\t\tgoto out;\n\n\tdown_read(&ag->lock);\n\tseq_printf(m, \"/autogroup-%ld nice %d\\n\", ag->id, ag->nice);\n\tup_read(&ag->lock);\n\nout:\n\tautogroup_kref_put(ag);\n}\n#endif  \n\nint autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\tif (!task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\treturn snprintf(buf, buflen, \"%s-%ld\", \"/autogroup\", tg->autogroup->id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}