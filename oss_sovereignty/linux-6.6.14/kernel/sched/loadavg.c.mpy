{
  "module_name": "loadavg.c",
  "hash_id": "116db796e5290bfac8fcd20a131b3a973967159a6ddd79e7cbfcfb2a0b31a2c9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/loadavg.c",
  "human_readable_source": "\n \n\n \n\n \natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\nunsigned long avenrun[3];\nEXPORT_SYMBOL(avenrun);  \n\n \nvoid get_avenrun(unsigned long *loads, unsigned long offset, int shift)\n{\n\tloads[0] = (avenrun[0] + offset) << shift;\n\tloads[1] = (avenrun[1] + offset) << shift;\n\tloads[2] = (avenrun[2] + offset) << shift;\n}\n\nlong calc_load_fold_active(struct rq *this_rq, long adjust)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->nr_running - adjust;\n\tnr_active += (int)this_rq->nr_uninterruptible;\n\n\tif (nr_active != this_rq->calc_load_active) {\n\t\tdelta = nr_active - this_rq->calc_load_active;\n\t\tthis_rq->calc_load_active = nr_active;\n\t}\n\n\treturn delta;\n}\n\n \nstatic unsigned long\nfixed_power_int(unsigned long x, unsigned int frac_bits, unsigned int n)\n{\n\tunsigned long result = 1UL << frac_bits;\n\n\tif (n) {\n\t\tfor (;;) {\n\t\t\tif (n & 1) {\n\t\t\t\tresult *= x;\n\t\t\t\tresult += 1UL << (frac_bits - 1);\n\t\t\t\tresult >>= frac_bits;\n\t\t\t}\n\t\t\tn >>= 1;\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tx *= x;\n\t\t\tx += 1UL << (frac_bits - 1);\n\t\t\tx >>= frac_bits;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n \nunsigned long\ncalc_load_n(unsigned long load, unsigned long exp,\n\t    unsigned long active, unsigned int n)\n{\n\treturn calc_load(load, fixed_power_int(exp, FSHIFT, n), active);\n}\n\n#ifdef CONFIG_NO_HZ_COMMON\n \nstatic atomic_long_t calc_load_nohz[2];\nstatic int calc_load_idx;\n\nstatic inline int calc_load_write_idx(void)\n{\n\tint idx = calc_load_idx;\n\n\t \n\tsmp_rmb();\n\n\t \n\tif (!time_before(jiffies, READ_ONCE(calc_load_update)))\n\t\tidx++;\n\n\treturn idx & 1;\n}\n\nstatic inline int calc_load_read_idx(void)\n{\n\treturn calc_load_idx & 1;\n}\n\nstatic void calc_load_nohz_fold(struct rq *rq)\n{\n\tlong delta;\n\n\tdelta = calc_load_fold_active(rq, 0);\n\tif (delta) {\n\t\tint idx = calc_load_write_idx();\n\n\t\tatomic_long_add(delta, &calc_load_nohz[idx]);\n\t}\n}\n\nvoid calc_load_nohz_start(void)\n{\n\t \n\tcalc_load_nohz_fold(this_rq());\n}\n\n \nvoid calc_load_nohz_remote(struct rq *rq)\n{\n\tcalc_load_nohz_fold(rq);\n}\n\nvoid calc_load_nohz_stop(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t \n\tthis_rq->calc_load_update = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\t \n\tif (time_before(jiffies, this_rq->calc_load_update + 10))\n\t\tthis_rq->calc_load_update += LOAD_FREQ;\n}\n\nstatic long calc_load_nohz_read(void)\n{\n\tint idx = calc_load_read_idx();\n\tlong delta = 0;\n\n\tif (atomic_long_read(&calc_load_nohz[idx]))\n\t\tdelta = atomic_long_xchg(&calc_load_nohz[idx], 0);\n\n\treturn delta;\n}\n\n \nstatic void calc_global_nohz(void)\n{\n\tunsigned long sample_window;\n\tlong delta, active, n;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (!time_before(jiffies, sample_window + 10)) {\n\t\t \n\t\tdelta = jiffies - sample_window - 10;\n\t\tn = 1 + (delta / LOAD_FREQ);\n\n\t\tactive = atomic_long_read(&calc_load_tasks);\n\t\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\t\tavenrun[0] = calc_load_n(avenrun[0], EXP_1, active, n);\n\t\tavenrun[1] = calc_load_n(avenrun[1], EXP_5, active, n);\n\t\tavenrun[2] = calc_load_n(avenrun[2], EXP_15, active, n);\n\n\t\tWRITE_ONCE(calc_load_update, sample_window + n * LOAD_FREQ);\n\t}\n\n\t \n\tsmp_wmb();\n\tcalc_load_idx++;\n}\n#else  \n\nstatic inline long calc_load_nohz_read(void) { return 0; }\nstatic inline void calc_global_nohz(void) { }\n\n#endif  \n\n \nvoid calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t \n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t \n\tcalc_global_nohz();\n}\n\n \nvoid calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}