{
  "module_name": "deadline.c",
  "hash_id": "c0b3ebe02e06a83b51c5bedeff33f0fcf8d51a74802b0232cb95e9bbd927e9b0",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/deadline.c",
  "human_readable_source": "\n \n\n#include <linux/cpuset.h>\n\n \nstatic unsigned int sysctl_sched_dl_period_max = 1 << 22;  \nstatic unsigned int sysctl_sched_dl_period_min = 100;      \n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table sched_dl_sysctls[] = {\n\t{\n\t\t.procname       = \"sched_deadline_period_max_us\",\n\t\t.data           = &sysctl_sched_dl_period_max,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_douintvec_minmax,\n\t\t.extra1         = (void *)&sysctl_sched_dl_period_min,\n\t},\n\t{\n\t\t.procname       = \"sched_deadline_period_min_us\",\n\t\t.data           = &sysctl_sched_dl_period_min,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_douintvec_minmax,\n\t\t.extra2         = (void *)&sysctl_sched_dl_period_max,\n\t},\n\t{}\n};\n\nstatic int __init sched_dl_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", sched_dl_sysctls);\n\treturn 0;\n}\nlate_initcall(sched_dl_sysctl_init);\n#endif\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}\n\n#ifdef CONFIG_RT_MUTEXES\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->pi_se;\n}\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn pi_of(dl_se) != dl_se;\n}\n#else\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}\n#endif\n\n#ifdef CONFIG_SMP\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\treturn &cpu_rq(i)->rd->dl_bw;\n}\n\nstatic inline int dl_bw_cpus(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tint cpus;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tif (cpumask_subset(rd->span, cpu_active_mask))\n\t\treturn cpumask_weight(rd->span);\n\n\tcpus = 0;\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcpus++;\n\n\treturn cpus;\n}\n\nstatic inline unsigned long __dl_bw_capacity(const struct cpumask *mask)\n{\n\tunsigned long cap = 0;\n\tint i;\n\n\tfor_each_cpu_and(i, mask, cpu_active_mask)\n\t\tcap += capacity_orig_of(i);\n\n\treturn cap;\n}\n\n \nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\tif (!sched_asym_cpucap_active() &&\n\t    capacity_orig_of(i) == SCHED_CAPACITY_SCALE) {\n\t\treturn dl_bw_cpus(i) << SCHED_CAPACITY_SHIFT;\n\t} else {\n\t\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t\t \"sched RCU must be held\");\n\n\t\treturn __dl_bw_capacity(cpu_rq(i)->rd->span);\n\t}\n}\n\nstatic inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\n\tif (rd->visit_gen == gen)\n\t\treturn true;\n\n\trd->visit_gen = gen;\n\treturn false;\n}\n\nstatic inline\nvoid __dl_update(struct dl_bw *dl_b, s64 bw)\n{\n\tstruct root_domain *rd = container_of(dl_b, struct root_domain, dl_bw);\n\tint i;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask) {\n\t\tstruct rq *rq = cpu_rq(i);\n\n\t\trq->dl.extra_bw += bw;\n\t}\n}\n#else\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}\n\nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}\n\nstatic inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}\n\nstatic inline\nvoid __dl_update(struct dl_bw *dl_b, s64 bw)\n{\n\tstruct dl_rq *dl = container_of(dl_b, struct dl_rq, dl_bw);\n\n\tdl->extra_bw += bw;\n}\n#endif\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}\n\nstatic inline bool\n__dl_overflow(struct dl_bw *dl_b, unsigned long cap, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}\n\nstatic inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old);  \n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t \n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}\n\nstatic inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old);  \n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t \n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old);  \n}\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old);  \n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}\n\nstatic void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tWARN_ON_ONCE(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t \n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}\n\n \nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t \n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t \n\tzerolag_time -= rq_clock(rq);\n\n\t \n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t\t__dl_clear_params(p);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t \n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t \n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t \n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn rb_first_cached(&dl_rq->root) == &dl_se->rb_node;\n}\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\tdl_b->total_bw = 0;\n}\n\nvoid init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->root = RB_ROOT_CACHED;\n\n#ifdef CONFIG_SMP\n\t \n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n\n\tdl_rq->running_bw = 0;\n\tdl_rq->this_bw = 0;\n\tinit_dl_rq_bw_ratio(dl_rq);\n}\n\n#ifdef CONFIG_SMP\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t \n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}\n\nstatic void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}\n\nstatic void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}\n\n#define __node_2_pdl(node) \\\n\trb_entry((node), struct task_struct, pushable_dl_tasks)\n\nstatic inline bool __pushable_less(struct rb_node *a, const struct rb_node *b)\n{\n\treturn dl_entity_preempt(&__node_2_pdl(a)->dl, &__node_2_pdl(b)->dl);\n}\n\n \nstatic void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct rb_node *leftmost;\n\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&p->pushable_dl_tasks));\n\n\tleftmost = rb_add_cached(&p->pushable_dl_tasks,\n\t\t\t\t &rq->dl.pushable_dl_tasks_root,\n\t\t\t\t __pushable_less);\n\tif (leftmost)\n\t\trq->dl.earliest_dl.next = p->dl.deadline;\n}\n\nstatic void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_root_cached *root = &dl_rq->pushable_dl_tasks_root;\n\tstruct rb_node *leftmost;\n\n\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tleftmost = rb_erase_cached(&p->pushable_dl_tasks, root);\n\tif (leftmost)\n\t\tdl_rq->earliest_dl.next = __node_2_pdl(leftmost)->dl.deadline;\n\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n}\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}\n\nstatic int push_dl_task(struct rq *rq);\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn rq->online && dl_task(prev);\n}\n\nstatic DEFINE_PER_CPU(struct balance_callback, dl_push_head);\nstatic DEFINE_PER_CPU(struct balance_callback, dl_pull_head);\n\nstatic void push_dl_tasks(struct rq *);\nstatic void pull_dl_task(struct rq *);\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(dl_push_head, rq->cpu), push_dl_tasks);\n}\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n\tqueue_balance_callback(rq, &per_cpu(dl_pull_head, rq->cpu), pull_dl_task);\n}\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq);\n\nstatic struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\tstruct dl_bw *dl_b;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t \n\t\tcpu = cpumask_any_and(cpu_active_mask, p->cpus_ptr);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(dl_bandwidth_enabled());\n\n\t\t\t \n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {\n\t\t \n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t\tadd_running_bw(&p->dl, &later_rq->dl);\n\t} else {\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t}\n\n\t \n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_sub(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tdl_b = &later_rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(later_rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}\n\n#else\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}\n#endif  \n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void replenish_dl_new_period(struct sched_dl_entity *dl_se,\n\t\t\t\t\t    struct rq *rq)\n{\n\t \n\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n}\n\n \nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(is_dl_boosted(dl_se));\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t \n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t \n\treplenish_dl_new_period(dl_se, rq);\n}\n\n \nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON_ONCE(pi_of(dl_se)->dl_runtime <= 0);\n\n\t \n\tif (dl_se->dl_deadline == 0)\n\t\treplenish_dl_new_period(dl_se, rq);\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t \n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t \n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\treplenish_dl_new_period(dl_se, rq);\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}\n\n \nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se, u64 t)\n{\n\tu64 left, right;\n\n\t \n\tleft = (pi_of(dl_se)->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_of(dl_se)->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}\n\n \nstatic void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t \n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}\n\n \nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}\n\n \nstatic void update_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !is_dl_boosted(dl_se))) {\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\treplenish_dl_new_period(dl_se, rq);\n\t}\n}\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}\n\n \nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t \n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t \n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t \n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}\n\n \nstatic enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\t \n\tif (!dl_task(p))\n\t\tgoto unlock;\n\n\t \n\tif (is_dl_boosted(dl_se))\n\t\tgoto unlock;\n\n\t \n\tif (!dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\t \n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se);\n\t\tgoto unlock;\n\t}\n\n#ifdef CONFIG_SMP\n\tif (unlikely(!rq->online)) {\n\t\t \n\t\tlockdep_unpin_lock(__rq_lockp(rq), rf.cookie);\n\t\trq = dl_task_offline_migration(rq, p);\n\t\trf.cookie = lockdep_pin_lock(__rq_lockp(rq));\n\t\tupdate_rq_clock(rq);\n\n\t\t \n\t}\n#endif\n\n\tenqueue_task_dl(rq, p, ENQUEUE_REPLENISH);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n\n#ifdef CONFIG_SMP\n\t \n\tif (has_pushable_dl_tasks(rq)) {\n\t\t \n\t\trq_unpin_lock(rq, &rf);\n\t\tpush_dl_task(rq);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\n\t \n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}\n\nvoid init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttimer->function = dl_task_timer;\n}\n\n \nstatic inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}\n\nstatic\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}\n\n \nstatic u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_act;\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw;  \n\n\t \n\tif (u_inact + rq->dl.extra_bw > rq->dl.max_bw - dl_se->dl_bw)\n\t\tu_act = dl_se->dl_bw;\n\telse\n\t\tu_act = rq->dl.max_bw - u_inact - rq->dl.extra_bw;\n\n\tu_act = (u_act * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\treturn (delta * u_act) >> BW_SHIFT;\n}\n\n \nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t \n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tupdate_current_exec_runtime(curr, now, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t \n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t \n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t \n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t \n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}\n\nstatic enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     inactive_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\tif (READ_ONCE(p->__state) == TASK_DEAD && dl_se->dl_non_contending) {\n\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tdl_se->dl_non_contending = 0;\n\t\t}\n\n\t\traw_spin_lock(&dl_b->lock);\n\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&dl_b->lock);\n\t\t__dl_clear_params(p);\n\n\t\tgoto unlock;\n\t}\n\tif (dl_se->dl_non_contending == 0)\n\t\tgoto unlock;\n\n\tsub_running_bw(dl_se, &rq->dl);\n\tdl_se->dl_non_contending = 0;\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}\n\nvoid init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttimer->function = inactive_task_timer;\n}\n\n#define __node_2_dle(node) \\\n\trb_entry((node), struct sched_dl_entity, rb_node)\n\n#ifdef CONFIG_SMP\n\nstatic void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\tif (dl_rq->earliest_dl.curr == 0)\n\t\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, CPUPRI_HIGHER);\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);\n\t}\n}\n\nstatic void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t \n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rq->rt.highest_prio.curr);\n\t} else {\n\t\tstruct rb_node *leftmost = rb_first_cached(&dl_rq->root);\n\t\tstruct sched_dl_entity *entry = __node_2_dle(leftmost);\n\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);\n\t}\n}\n\n#else\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}\n\n#endif  \n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}\n\nstatic inline bool __dl_less(struct rb_node *a, const struct rb_node *b)\n{\n\treturn dl_time_before(__node_2_dle(a)->deadline, __node_2_dle(b)->deadline);\n}\n\nstatic inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}\n\nstatic inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}\n\nstatic inline void\nupdate_stats_wait_end_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_end(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}\n\nstatic inline void\nupdate_stats_enqueue_sleeper_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_enqueue_sleeper(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}\n\nstatic inline void\nupdate_stats_enqueue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tupdate_stats_enqueue_sleeper_dl(dl_rq, dl_se);\n}\n\nstatic inline void\nupdate_stats_dequeue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif ((flags & DEQUEUE_SLEEP)) {\n\t\tunsigned int state;\n\n\t\tstate = READ_ONCE(p->__state);\n\t\tif (state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.sleep_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\n\t\tif (state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.block_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\t}\n}\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\trb_add_cached(&dl_se->rb_node, &dl_rq->root, __dl_less);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se, int flags)\n{\n\tWARN_ON_ONCE(on_dl_rq(dl_se));\n\n\tupdate_stats_enqueue_dl(dl_rq_of_se(dl_se), dl_se, flags);\n\n\t \n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t \n\t\tif (p->dl.dl_throttled) {\n\t\t\t \n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t \n\t\tp->dl.dl_throttled = 0;\n\t\tif (!(flags & ENQUEUE_REPLENISH))\n\t\t\tprintk_deferred_once(\"sched: DL de-boosted task PID %d: REPLENISH flag missing\\n\",\n\t\t\t\t\t     task_pid_nr(p));\n\n\t\treturn;\n\t}\n\n\t \n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t \n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}\n\nstatic void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & DEQUEUE_SAVE) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t \n\tif (flags & DEQUEUE_SLEEP)\n\t\ttask_non_contending(p);\n}\n\n \nstatic void yield_task_dl(struct rq *rq)\n{\n\t \n\trq->curr->dl.dl_yielded = 1;\n\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t \n\trq_clock_skip_update(rq);\n}\n\n#ifdef CONFIG_SMP\n\nstatic inline bool dl_task_is_earliest_deadline(struct task_struct *p,\n\t\t\t\t\t\t struct rq *rq)\n{\n\treturn (!rq->dl.dl_nr_running ||\n\t\tdl_time_before(p->dl.deadline,\n\t\t\t       rq->dl.earliest_dl.curr));\n}\n\nstatic int find_later_rq(struct task_struct *task);\n\nstatic int\nselect_task_rq_dl(struct task_struct *p, int cpu, int flags)\n{\n\tstruct task_struct *curr;\n\tbool select_rq;\n\tstruct rq *rq;\n\n\tif (!(flags & WF_TTWU))\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = READ_ONCE(rq->curr);  \n\n\t \n\tselect_rq = unlikely(dl_task(curr)) &&\n\t\t    (curr->nr_cpus_allowed < 2 ||\n\t\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t\t    p->nr_cpus_allowed > 1;\n\n\t \n\tif (sched_asym_cpucap_active())\n\t\tselect_rq |= !dl_task_fits_capacity(p, cpu);\n\n\tif (select_rq) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1 &&\n\t\t    dl_task_is_earliest_deadline(p, cpu_rq(target)))\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}\n\nstatic void migrate_task_rq_dl(struct task_struct *p, int new_cpu __maybe_unused)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (READ_ONCE(p->__state) != TASK_WAKING)\n\t\treturn;\n\n\trq = task_rq(p);\n\t \n\trq_lock(rq, &rf);\n\tif (p->dl.dl_non_contending) {\n\t\tupdate_rq_clock(rq);\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t \n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\tsub_rq_bw(&p->dl, &rq->dl);\n\trq_unlock(rq, &rf);\n}\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t \n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t \n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}\n\nstatic int balance_dl(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n{\n\tif (!on_dl_rq(&p->dl) && need_pull_dl_task(rq, p)) {\n\t\t \n\t\trq_unpin_lock(rq, rf);\n\t\tpull_dl_task(rq);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\treturn sched_stop_runnable(rq) || sched_dl_runnable(rq);\n}\n#endif  \n\n \nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t \n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif  \n}\n\n#ifdef CONFIG_SCHED_HRTICK\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}\n#else  \nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}\n#endif\n\nstatic void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_end_dl(dl_rq, dl_se);\n\n\t \n\tdequeue_pushable_dl_task(rq, p);\n\n\tif (!first)\n\t\treturn;\n\n\tif (hrtick_enabled_dl(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\n\tdeadline_queue_push_tasks(rq);\n}\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn __node_2_dle(left);\n}\n\nstatic struct task_struct *pick_task_dl(struct rq *rq)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct task_struct *p;\n\n\tif (!sched_dl_runnable(rq))\n\t\treturn NULL;\n\n\tdl_se = pick_next_dl_entity(dl_rq);\n\tWARN_ON_ONCE(!dl_se);\n\tp = dl_task_of(dl_se);\n\n\treturn p;\n}\n\nstatic struct task_struct *pick_next_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tp = pick_task_dl(rq);\n\tif (p)\n\t\tset_next_task_dl(rq, p, true);\n\n\treturn p;\n}\n\nstatic void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_start_dl(dl_rq, dl_se);\n\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}\n\n \nstatic void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);\n\t \n\tif (hrtick_enabled_dl(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}\n\nstatic void task_fork_dl(struct task_struct *p)\n{\n\t \n}\n\n#ifdef CONFIG_SMP\n\n \n#define DL_MAX_TRIES 3\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_on_cpu(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_mask))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct task_struct *p = NULL;\n\tstruct rb_node *next_node;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tnext_node = rb_first_cached(&rq->dl.pushable_dl_tasks_root);\n\nnext_node:\n\tif (next_node) {\n\t\tp = __node_2_pdl(next_node);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}\n\nstatic DEFINE_PER_CPU(cpumask_var_t, local_cpu_mask_dl);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t \n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t \n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t \n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t \n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t \n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t \n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}\n\n \nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (!dl_task_is_earliest_deadline(task, later_rq)) {\n\t\t\t \n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_on_cpu(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     is_migration_disabled(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (dl_task_is_earliest_deadline(task, later_rq))\n\t\t\tbreak;\n\n\t\t \n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = __node_2_pdl(rb_first_cached(&rq->dl.pushable_dl_tasks_root));\n\n\tWARN_ON_ONCE(rq->cpu != task_cpu(p));\n\tWARN_ON_ONCE(task_current(rq, p));\n\tWARN_ON_ONCE(p->nr_cpus_allowed <= 1);\n\n\tWARN_ON_ONCE(!task_on_rq_queued(p));\n\tWARN_ON_ONCE(!dl_task(p));\n\n\treturn p;\n}\n\n \nstatic int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\t \n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\tif (is_migration_disabled(next_task))\n\t\treturn 0;\n\n\tif (WARN_ON(next_task == rq->curr))\n\t\treturn 0;\n\n\t \n\tget_task_struct(next_task);\n\n\t \n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t \n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task == next_task) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t \n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tset_task_cpu(next_task, later_rq->cpu);\n\tactivate_task(later_rq, next_task, 0);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t \n\twhile (push_dl_task(rq))\n\t\t;\n}\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t \n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t \n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t \n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t \n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    dl_task_is_earliest_deadline(p, this_rq)) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t \n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t \n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\tpreempt_disable();\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\tpreempt_enable();\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}\n\n \nstatic void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_on_cpu(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}\n\nstatic void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tstruct affinity_context *ctx)\n{\n\tstruct root_domain *src_rd;\n\tstruct rq *rq;\n\n\tWARN_ON_ONCE(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t \n\tif (!cpumask_intersects(src_rd->span, ctx->new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t \n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_sub(src_dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\tset_cpus_allowed_common(p, ctx);\n}\n\n \nstatic void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr);\n}\n\n \nstatic void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}\n\nvoid __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}\n\nvoid dl_add_task_root_domain(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tstruct dl_bw *dl_b;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tif (!dl_task(p)) {\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\t\treturn;\n\t}\n\n\trq = __task_rq_lock(p, &rf);\n\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\n\traw_spin_unlock(&dl_b->lock);\n\n\ttask_rq_unlock(rq, p, &rf);\n}\n\nvoid dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}\n\n#endif  \n\nstatic void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t \n\tif (task_on_rq_queued(p) && p->dl.dl_runtime)\n\t\ttask_non_contending(p);\n\n\t \n\tdec_dl_tasks_cs(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\t \n\t\tif (p->dl.dl_non_contending)\n\t\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t \n\tif (p->dl.dl_non_contending)\n\t\tp->dl.dl_non_contending = 0;\n\n\t \n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tdeadline_queue_pull_task(rq);\n}\n\n \nstatic void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\tput_task_struct(p);\n\n\t \n\tinc_dl_tasks_cs(p);\n\n\t \n\tif (!task_on_rq_queued(p)) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\n\t\treturn;\n\t}\n\n\tif (rq->curr != p) {\n#ifdef CONFIG_SMP\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded)\n\t\t\tdeadline_queue_push_tasks(rq);\n#endif\n\t\tif (dl_task(rq->curr))\n\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\telse\n\t\t\tresched_curr(rq);\n\t} else {\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\t}\n}\n\n \nstatic void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (!task_on_rq_queued(p))\n\t\treturn;\n\n#ifdef CONFIG_SMP\n\t \n\tif (!rq->dl.overloaded)\n\t\tdeadline_queue_pull_task(rq);\n\n\tif (task_current(rq, p)) {\n\t\t \n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline))\n\t\t\tresched_curr(rq);\n\t} else {\n\t\t \n\t\tif (!dl_task(rq->curr) ||\n\t\t    dl_time_before(p->dl.deadline, rq->curr->dl.deadline))\n\t\t\tresched_curr(rq);\n\t}\n#else\n\t \n\tresched_curr(rq);\n#endif\n}\n\n#ifdef CONFIG_SCHED_CORE\nstatic int task_is_throttled_dl(struct task_struct *p, int cpu)\n{\n\treturn p->dl.dl_throttled;\n}\n#endif\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n#ifdef CONFIG_SCHED_CORE\n\t.task_is_throttled\t= task_is_throttled_dl,\n#endif\n};\n\n \nstatic u64 dl_generation;\n\nint sched_dl_global_validate(void)\n{\n\tu64 runtime = global_rt_runtime();\n\tu64 period = global_rt_period();\n\tu64 new_bw = to_ratio(period, runtime);\n\tu64 gen = ++dl_generation;\n\tstruct dl_bw *dl_b;\n\tint cpu, cpus, ret = 0;\n\tunsigned long flags;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\n\t\tif (dl_bw_visited(cpu, gen))\n\t\t\tgoto next;\n\n\t\tdl_b = dl_bw_of(cpu);\n\t\tcpus = dl_bw_cpus(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tif (new_bw * cpus < dl_b->total_bw)\n\t\t\tret = -EBUSY;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\nnext:\n\t\trcu_read_unlock_sched();\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->max_bw = dl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->max_bw = dl_rq->extra_bw =\n\t\t\tto_ratio(global_rt_period(), global_rt_runtime());\n\t}\n}\n\nvoid sched_dl_do_global(void)\n{\n\tu64 new_bw = -1;\n\tu64 gen = ++dl_generation;\n\tstruct dl_bw *dl_b;\n\tint cpu;\n\tunsigned long flags;\n\n\tif (global_rt_runtime() != RUNTIME_INF)\n\t\tnew_bw = to_ratio(global_rt_period(), global_rt_runtime());\n\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\n\t\tif (dl_bw_visited(cpu, gen)) {\n\t\t\trcu_read_unlock_sched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tdl_b->bw = new_bw;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\t\tinit_dl_rq_bw_ratio(&cpu_rq(cpu)->dl);\n\t}\n}\n\n \nint sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1, cpu = task_cpu(p);\n\tstruct dl_bw *dl_b = dl_bw_of(cpu);\n\tunsigned long cap;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t \n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t \n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(cpu);\n\tcap = dl_bw_capacity(cpu);\n\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cap, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cap, p->dl.dl_bw, new_bw)) {\n\t\t \n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t \n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}\n\n \nvoid __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags & SCHED_DL_FLAGS;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}\n\nvoid __getparam_dl(struct task_struct *p, struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tattr->sched_priority = p->rt_priority;\n\tattr->sched_runtime = dl_se->dl_runtime;\n\tattr->sched_deadline = dl_se->dl_deadline;\n\tattr->sched_period = dl_se->dl_period;\n\tattr->sched_flags &= ~SCHED_DL_FLAGS;\n\tattr->sched_flags |= dl_se->flags;\n}\n\n \nbool __checkparam_dl(const struct sched_attr *attr)\n{\n\tu64 period, max, min;\n\n\t \n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t \n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t \n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t \n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\tperiod = attr->sched_period;\n\tif (!period)\n\t\tperiod = attr->sched_deadline;\n\n\t \n\tif (period < attr->sched_deadline ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\tmax = (u64)READ_ONCE(sysctl_sched_dl_period_max) * NSEC_PER_USEC;\n\tmin = (u64)READ_ONCE(sysctl_sched_dl_period_min) * NSEC_PER_USEC;\n\n\tif (period < min || period > max)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}\n\nbool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != (attr->sched_flags & SCHED_DL_FLAGS))\n\t\treturn true;\n\n\treturn false;\n}\n\n#ifdef CONFIG_SMP\nint dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tunsigned long flags, cap;\n\tstruct dl_bw *cur_dl_b;\n\tint ret = 1;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\tcap = __dl_bw_capacity(trial);\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (__dl_overflow(cur_dl_b, cap, 0, 0))\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}\n\nenum dl_bw_request {\n\tdl_bw_req_check_overflow = 0,\n\tdl_bw_req_alloc,\n\tdl_bw_req_free\n};\n\nstatic int dl_bw_manage(enum dl_bw_request req, int cpu, u64 dl_bw)\n{\n\tunsigned long flags;\n\tstruct dl_bw *dl_b;\n\tbool overflow = 0;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\n\tif (req == dl_bw_req_free) {\n\t\t__dl_sub(dl_b, dl_bw, dl_bw_cpus(cpu));\n\t} else {\n\t\tunsigned long cap = dl_bw_capacity(cpu);\n\n\t\toverflow = __dl_overflow(dl_b, cap, 0, dl_bw);\n\n\t\tif (req == dl_bw_req_alloc && !overflow) {\n\t\t\t \n\t\t\t__dl_add(dl_b, dl_bw, dl_bw_cpus(cpu));\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow ? -EBUSY : 0;\n}\n\nint dl_bw_check_overflow(int cpu)\n{\n\treturn dl_bw_manage(dl_bw_req_check_overflow, cpu, 0);\n}\n\nint dl_bw_alloc(int cpu, u64 dl_bw)\n{\n\treturn dl_bw_manage(dl_bw_req_alloc, cpu, dl_bw);\n}\n\nvoid dl_bw_free(int cpu, u64 dl_bw)\n{\n\tdl_bw_manage(dl_bw_req_free, cpu, dl_bw);\n}\n#endif\n\n#ifdef CONFIG_SCHED_DEBUG\nvoid print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}