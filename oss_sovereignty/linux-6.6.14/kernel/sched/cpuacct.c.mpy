{
  "module_name": "cpuacct.c",
  "hash_id": "3f2f7f652dfaddb3c5d8a30435c60358d67efa2da67758032c58fabd35457a30",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sched/cpuacct.c",
  "human_readable_source": "\n\n \n\n \nenum cpuacct_stat_index {\n\tCPUACCT_STAT_USER,\t \n\tCPUACCT_STAT_SYSTEM,\t \n\n\tCPUACCT_STAT_NSTATS,\n};\n\nstatic const char * const cpuacct_stat_desc[] = {\n\t[CPUACCT_STAT_USER] = \"user\",\n\t[CPUACCT_STAT_SYSTEM] = \"system\",\n};\n\n \nstruct cpuacct {\n\tstruct cgroup_subsys_state\tcss;\n\t \n\tu64 __percpu\t*cpuusage;\n\tstruct kernel_cpustat __percpu\t*cpustat;\n};\n\nstatic inline struct cpuacct *css_ca(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuacct, css) : NULL;\n}\n\n \nstatic inline struct cpuacct *task_ca(struct task_struct *tsk)\n{\n\treturn css_ca(task_css(tsk, cpuacct_cgrp_id));\n}\n\nstatic inline struct cpuacct *parent_ca(struct cpuacct *ca)\n{\n\treturn css_ca(ca->css.parent);\n}\n\nstatic DEFINE_PER_CPU(u64, root_cpuacct_cpuusage);\nstatic struct cpuacct root_cpuacct = {\n\t.cpustat\t= &kernel_cpustat,\n\t.cpuusage\t= &root_cpuacct_cpuusage,\n};\n\n \nstatic struct cgroup_subsys_state *\ncpuacct_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cpuacct *ca;\n\n\tif (!parent_css)\n\t\treturn &root_cpuacct.css;\n\n\tca = kzalloc(sizeof(*ca), GFP_KERNEL);\n\tif (!ca)\n\t\tgoto out;\n\n\tca->cpuusage = alloc_percpu(u64);\n\tif (!ca->cpuusage)\n\t\tgoto out_free_ca;\n\n\tca->cpustat = alloc_percpu(struct kernel_cpustat);\n\tif (!ca->cpustat)\n\t\tgoto out_free_cpuusage;\n\n\treturn &ca->css;\n\nout_free_cpuusage:\n\tfree_percpu(ca->cpuusage);\nout_free_ca:\n\tkfree(ca);\nout:\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nstatic void cpuacct_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\n\tfree_percpu(ca->cpustat);\n\tfree_percpu(ca->cpuusage);\n\tkfree(ca);\n}\n\nstatic u64 cpuacct_cpuusage_read(struct cpuacct *ca, int cpu,\n\t\t\t\t enum cpuacct_stat_index index)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\tu64 data;\n\n\t \n\tif (WARN_ON_ONCE(index > CPUACCT_STAT_NSTATS))\n\t\treturn 0;\n\n#ifndef CONFIG_64BIT\n\t \n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\n\tswitch (index) {\n\tcase CPUACCT_STAT_USER:\n\t\tdata = cpustat[CPUTIME_USER] + cpustat[CPUTIME_NICE];\n\t\tbreak;\n\tcase CPUACCT_STAT_SYSTEM:\n\t\tdata = cpustat[CPUTIME_SYSTEM] + cpustat[CPUTIME_IRQ] +\n\t\t\tcpustat[CPUTIME_SOFTIRQ];\n\t\tbreak;\n\tcase CPUACCT_STAT_NSTATS:\n\t\tdata = *cpuusage;\n\t\tbreak;\n\t}\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n\n\treturn data;\n}\n\nstatic void cpuacct_cpuusage_write(struct cpuacct *ca, int cpu)\n{\n\tu64 *cpuusage = per_cpu_ptr(ca->cpuusage, cpu);\n\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\n\t \n\tif (ca == &root_cpuacct)\n\t\treturn;\n\n#ifndef CONFIG_64BIT\n\t \n\traw_spin_rq_lock_irq(cpu_rq(cpu));\n#endif\n\t*cpuusage = 0;\n\tcpustat[CPUTIME_USER] = cpustat[CPUTIME_NICE] = 0;\n\tcpustat[CPUTIME_SYSTEM] = cpustat[CPUTIME_IRQ] = 0;\n\tcpustat[CPUTIME_SOFTIRQ] = 0;\n\n#ifndef CONFIG_64BIT\n\traw_spin_rq_unlock_irq(cpu_rq(cpu));\n#endif\n}\n\n \nstatic u64 __cpuusage_read(struct cgroup_subsys_state *css,\n\t\t\t   enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tu64 totalcpuusage = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\ttotalcpuusage += cpuacct_cpuusage_read(ca, i, index);\n\n\treturn totalcpuusage;\n}\n\nstatic u64 cpuusage_user_read(struct cgroup_subsys_state *css,\n\t\t\t      struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_USER);\n}\n\nstatic u64 cpuusage_sys_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_SYSTEM);\n}\n\nstatic u64 cpuusage_read(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn __cpuusage_read(css, CPUACCT_STAT_NSTATS);\n}\n\nstatic int cpuusage_write(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t  u64 val)\n{\n\tstruct cpuacct *ca = css_ca(css);\n\tint cpu;\n\n\t \n\tif (val)\n\t\treturn -EINVAL;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpuacct_cpuusage_write(ca, cpu);\n\n\treturn 0;\n}\n\nstatic int __cpuacct_percpu_seq_show(struct seq_file *m,\n\t\t\t\t     enum cpuacct_stat_index index)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tu64 percpu;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tpercpu = cpuacct_cpuusage_read(ca, i, index);\n\t\tseq_printf(m, \"%llu \", (unsigned long long) percpu);\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}\n\nstatic int cpuacct_percpu_user_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_USER);\n}\n\nstatic int cpuacct_percpu_sys_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_SYSTEM);\n}\n\nstatic int cpuacct_percpu_seq_show(struct seq_file *m, void *V)\n{\n\treturn __cpuacct_percpu_seq_show(m, CPUACCT_STAT_NSTATS);\n}\n\nstatic int cpuacct_all_seq_show(struct seq_file *m, void *V)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(m));\n\tint index;\n\tint cpu;\n\n\tseq_puts(m, \"cpu\");\n\tfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\n\t\tseq_printf(m, \" %s\", cpuacct_stat_desc[index]);\n\tseq_puts(m, \"\\n\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"%d\", cpu);\n\t\tfor (index = 0; index < CPUACCT_STAT_NSTATS; index++)\n\t\t\tseq_printf(m, \" %llu\",\n\t\t\t\t   cpuacct_cpuusage_read(ca, cpu, index));\n\t\tseq_puts(m, \"\\n\");\n\t}\n\treturn 0;\n}\n\nstatic int cpuacct_stats_show(struct seq_file *sf, void *v)\n{\n\tstruct cpuacct *ca = css_ca(seq_css(sf));\n\tstruct task_cputime cputime;\n\tu64 val[CPUACCT_STAT_NSTATS];\n\tint cpu;\n\tint stat;\n\n\tmemset(&cputime, 0, sizeof(cputime));\n\tfor_each_possible_cpu(cpu) {\n\t\tu64 *cpustat = per_cpu_ptr(ca->cpustat, cpu)->cpustat;\n\n\t\tcputime.utime += cpustat[CPUTIME_USER];\n\t\tcputime.utime += cpustat[CPUTIME_NICE];\n\t\tcputime.stime += cpustat[CPUTIME_SYSTEM];\n\t\tcputime.stime += cpustat[CPUTIME_IRQ];\n\t\tcputime.stime += cpustat[CPUTIME_SOFTIRQ];\n\n\t\tcputime.sum_exec_runtime += *per_cpu_ptr(ca->cpuusage, cpu);\n\t}\n\n\tcputime_adjust(&cputime, &seq_css(sf)->cgroup->prev_cputime,\n\t\t&val[CPUACCT_STAT_USER], &val[CPUACCT_STAT_SYSTEM]);\n\n\tfor (stat = 0; stat < CPUACCT_STAT_NSTATS; stat++) {\n\t\tseq_printf(sf, \"%s %llu\\n\", cpuacct_stat_desc[stat],\n\t\t\tnsec_to_clock_t(val[stat]));\n\t}\n\n\treturn 0;\n}\n\nstatic struct cftype files[] = {\n\t{\n\t\t.name = \"usage\",\n\t\t.read_u64 = cpuusage_read,\n\t\t.write_u64 = cpuusage_write,\n\t},\n\t{\n\t\t.name = \"usage_user\",\n\t\t.read_u64 = cpuusage_user_read,\n\t},\n\t{\n\t\t.name = \"usage_sys\",\n\t\t.read_u64 = cpuusage_sys_read,\n\t},\n\t{\n\t\t.name = \"usage_percpu\",\n\t\t.seq_show = cpuacct_percpu_seq_show,\n\t},\n\t{\n\t\t.name = \"usage_percpu_user\",\n\t\t.seq_show = cpuacct_percpu_user_seq_show,\n\t},\n\t{\n\t\t.name = \"usage_percpu_sys\",\n\t\t.seq_show = cpuacct_percpu_sys_seq_show,\n\t},\n\t{\n\t\t.name = \"usage_all\",\n\t\t.seq_show = cpuacct_all_seq_show,\n\t},\n\t{\n\t\t.name = \"stat\",\n\t\t.seq_show = cpuacct_stats_show,\n\t},\n\t{ }\t \n};\n\n \nvoid cpuacct_charge(struct task_struct *tsk, u64 cputime)\n{\n\tunsigned int cpu = task_cpu(tsk);\n\tstruct cpuacct *ca;\n\n\tlockdep_assert_rq_held(cpu_rq(cpu));\n\n\tfor (ca = task_ca(tsk); ca; ca = parent_ca(ca))\n\t\t*per_cpu_ptr(ca->cpuusage, cpu) += cputime;\n}\n\n \nvoid cpuacct_account_field(struct task_struct *tsk, int index, u64 val)\n{\n\tstruct cpuacct *ca;\n\n\tfor (ca = task_ca(tsk); ca != &root_cpuacct; ca = parent_ca(ca))\n\t\t__this_cpu_add(ca->cpustat->cpustat[index], val);\n}\n\nstruct cgroup_subsys cpuacct_cgrp_subsys = {\n\t.css_alloc\t= cpuacct_css_alloc,\n\t.css_free\t= cpuacct_css_free,\n\t.legacy_cftypes\t= files,\n\t.early_init\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}