{
  "module_name": "kexec_file.c",
  "hash_id": "455f57737911e9fcd6784f473bc4346c230971b5d20bb0c84fedee32b6d54baf",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kexec_file.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/kexec.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/ima.h>\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n#include <linux/elf.h>\n#include <linux/elfcore.h>\n#include <linux/kernel.h>\n#include <linux/kernel_read_file.h>\n#include <linux/syscalls.h>\n#include <linux/vmalloc.h>\n#include \"kexec_internal.h\"\n\n#ifdef CONFIG_KEXEC_SIG\nstatic bool sig_enforce = IS_ENABLED(CONFIG_KEXEC_SIG_FORCE);\n\nvoid set_kexec_sig_enforced(void)\n{\n\tsig_enforce = true;\n}\n#endif\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\n \n#define KEXEC_FILE_SIZE_MAX\tmin_t(s64, 4LL << 30, SSIZE_MAX)\n\n \nint kexec_image_probe_default(struct kimage *image, void *buf,\n\t\t\t      unsigned long buf_len)\n{\n\tconst struct kexec_file_ops * const *fops;\n\tint ret = -ENOEXEC;\n\n\tfor (fops = &kexec_file_loaders[0]; *fops && (*fops)->probe; ++fops) {\n\t\tret = (*fops)->probe(buf, buf_len);\n\t\tif (!ret) {\n\t\t\timage->fops = *fops;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void *kexec_image_load_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->load)\n\t\treturn ERR_PTR(-ENOEXEC);\n\n\treturn image->fops->load(image, image->kernel_buf,\n\t\t\t\t image->kernel_buf_len, image->initrd_buf,\n\t\t\t\t image->initrd_buf_len, image->cmdline_buf,\n\t\t\t\t image->cmdline_buf_len);\n}\n\nint kexec_image_post_load_cleanup_default(struct kimage *image)\n{\n\tif (!image->fops || !image->fops->cleanup)\n\t\treturn 0;\n\n\treturn image->fops->cleanup(image->image_loader_data);\n}\n\n \nvoid kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n#ifdef CONFIG_IMA_KEXEC\n\tvfree(image->ima_buffer);\n\timage->ima_buffer = NULL;\n#endif  \n\n\t \n\tarch_kimage_file_post_load_cleanup(image);\n\n\t \n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}\n\n#ifdef CONFIG_KEXEC_SIG\n#ifdef CONFIG_SIGNED_PE_FILE_VERIFICATION\nint kexec_kernel_verify_pe_sig(const char *kernel, unsigned long kernel_len)\n{\n\tint ret;\n\n\tret = verify_pefile_signature(kernel, kernel_len,\n\t\t\t\t      VERIFY_USE_SECONDARY_KEYRING,\n\t\t\t\t      VERIFYING_KEXEC_PE_SIGNATURE);\n\tif (ret == -ENOKEY && IS_ENABLED(CONFIG_INTEGRITY_PLATFORM_KEYRING)) {\n\t\tret = verify_pefile_signature(kernel, kernel_len,\n\t\t\t\t\t      VERIFY_USE_PLATFORM_KEYRING,\n\t\t\t\t\t      VERIFYING_KEXEC_PE_SIGNATURE);\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int kexec_image_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t  unsigned long buf_len)\n{\n\tif (!image->fops || !image->fops->verify_sig) {\n\t\tpr_debug(\"kernel loader does not support signature verification.\\n\");\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn image->fops->verify_sig(buf, buf_len);\n}\n\nstatic int\nkimage_validate_signature(struct kimage *image)\n{\n\tint ret;\n\n\tret = kexec_image_verify_sig(image, image->kernel_buf,\n\t\t\t\t     image->kernel_buf_len);\n\tif (ret) {\n\n\t\tif (sig_enforce) {\n\t\t\tpr_notice(\"Enforced kernel signature verification failed (%d).\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!ima_appraise_signature(READING_KEXEC_IMAGE) &&\n\t\t    security_locked_down(LOCKDOWN_KEXEC))\n\t\t\treturn -EPERM;\n\n\t\tpr_debug(\"kernel signature verification failed (%d).\\n\", ret);\n\t}\n\n\treturn 0;\n}\n#endif\n\n \nstatic int\nkimage_file_prepare_segments(struct kimage *image, int kernel_fd, int initrd_fd,\n\t\t\t     const char __user *cmdline_ptr,\n\t\t\t     unsigned long cmdline_len, unsigned flags)\n{\n\tssize_t ret;\n\tvoid *ldata;\n\n\tret = kernel_read_file_from_fd(kernel_fd, 0, &image->kernel_buf,\n\t\t\t\t       KEXEC_FILE_SIZE_MAX, NULL,\n\t\t\t\t       READING_KEXEC_IMAGE);\n\tif (ret < 0)\n\t\treturn ret;\n\timage->kernel_buf_len = ret;\n\n\t \n\tret = arch_kexec_kernel_image_probe(image, image->kernel_buf,\n\t\t\t\t\t    image->kernel_buf_len);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_KEXEC_SIG\n\tret = kimage_validate_signature(image);\n\n\tif (ret)\n\t\tgoto out;\n#endif\n\t \n\tif (!(flags & KEXEC_FILE_NO_INITRAMFS)) {\n\t\tret = kernel_read_file_from_fd(initrd_fd, 0, &image->initrd_buf,\n\t\t\t\t\t       KEXEC_FILE_SIZE_MAX, NULL,\n\t\t\t\t\t       READING_KEXEC_INITRAMFS);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\timage->initrd_buf_len = ret;\n\t\tret = 0;\n\t}\n\n\tif (cmdline_len) {\n\t\timage->cmdline_buf = memdup_user(cmdline_ptr, cmdline_len);\n\t\tif (IS_ERR(image->cmdline_buf)) {\n\t\t\tret = PTR_ERR(image->cmdline_buf);\n\t\t\timage->cmdline_buf = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\timage->cmdline_buf_len = cmdline_len;\n\n\t\t \n\t\tif (image->cmdline_buf[cmdline_len - 1] != '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tima_kexec_cmdline(kernel_fd, image->cmdline_buf,\n\t\t\t\t  image->cmdline_buf_len - 1);\n\t}\n\n\t \n\tima_add_kexec_buffer(image);\n\n\t \n\tldata = kexec_image_load_default(image);\n\n\tif (IS_ERR(ldata)) {\n\t\tret = PTR_ERR(ldata);\n\t\tgoto out;\n\t}\n\n\timage->image_loader_data = ldata;\nout:\n\t \n\tif (ret)\n\t\tkimage_file_post_load_cleanup(image);\n\treturn ret;\n}\n\nstatic int\nkimage_file_alloc_init(struct kimage **rimage, int kernel_fd,\n\t\t       int initrd_fd, const char __user *cmdline_ptr,\n\t\t       unsigned long cmdline_len, unsigned long flags)\n{\n\tint ret;\n\tstruct kimage *image;\n\tbool kexec_on_panic = flags & KEXEC_FILE_ON_CRASH;\n\n\timage = do_kimage_alloc_init();\n\tif (!image)\n\t\treturn -ENOMEM;\n\n\timage->file_mode = 1;\n\n\tif (kexec_on_panic) {\n\t\t \n\t\timage->control_page = crashk_res.start;\n\t\timage->type = KEXEC_TYPE_CRASH;\n\t}\n\n\tret = kimage_file_prepare_segments(image, kernel_fd, initrd_fd,\n\t\t\t\t\t   cmdline_ptr, cmdline_len, flags);\n\tif (ret)\n\t\tgoto out_free_image;\n\n\tret = sanity_check_segment_list(image);\n\tif (ret)\n\t\tgoto out_free_post_load_bufs;\n\n\tret = -ENOMEM;\n\timage->control_code_page = kimage_alloc_control_pages(image,\n\t\t\t\t\t   get_order(KEXEC_CONTROL_PAGE_SIZE));\n\tif (!image->control_code_page) {\n\t\tpr_err(\"Could not allocate control_code_buffer\\n\");\n\t\tgoto out_free_post_load_bufs;\n\t}\n\n\tif (!kexec_on_panic) {\n\t\timage->swap_page = kimage_alloc_control_pages(image, 0);\n\t\tif (!image->swap_page) {\n\t\t\tpr_err(\"Could not allocate swap buffer\\n\");\n\t\t\tgoto out_free_control_pages;\n\t\t}\n\t}\n\n\t*rimage = image;\n\treturn 0;\nout_free_control_pages:\n\tkimage_free_page_list(&image->control_pages);\nout_free_post_load_bufs:\n\tkimage_file_post_load_cleanup(image);\nout_free_image:\n\tkfree(image);\n\treturn ret;\n}\n\nSYSCALL_DEFINE5(kexec_file_load, int, kernel_fd, int, initrd_fd,\n\t\tunsigned long, cmdline_len, const char __user *, cmdline_ptr,\n\t\tunsigned long, flags)\n{\n\tint image_type = (flags & KEXEC_FILE_ON_CRASH) ?\n\t\t\t KEXEC_TYPE_CRASH : KEXEC_TYPE_DEFAULT;\n\tstruct kimage **dest_image, *image;\n\tint ret = 0, i;\n\n\t \n\tif (!kexec_load_permitted(image_type))\n\t\treturn -EPERM;\n\n\t \n\tif (flags != (flags & KEXEC_FILE_FLAGS))\n\t\treturn -EINVAL;\n\n\timage = NULL;\n\n\tif (!kexec_trylock())\n\t\treturn -EBUSY;\n\n\tif (image_type == KEXEC_TYPE_CRASH) {\n\t\tdest_image = &kexec_crash_image;\n\t\tif (kexec_crash_image)\n\t\t\tarch_kexec_unprotect_crashkres();\n\t} else {\n\t\tdest_image = &kexec_image;\n\t}\n\n\tif (flags & KEXEC_FILE_UNLOAD)\n\t\tgoto exchange;\n\n\t \n\tif (flags & KEXEC_FILE_ON_CRASH)\n\t\tkimage_free(xchg(&kexec_crash_image, NULL));\n\n\tret = kimage_file_alloc_init(&image, kernel_fd, initrd_fd, cmdline_ptr,\n\t\t\t\t     cmdline_len, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = kimage_crash_copy_vmcoreinfo(image);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kexec_calculate_store_digests(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tstruct kexec_segment *ksegment;\n\n\t\tksegment = &image->segment[i];\n\t\tpr_debug(\"Loading segment %d: buf=0x%p bufsz=0x%zx mem=0x%lx memsz=0x%zx\\n\",\n\t\t\t i, ksegment->buf, ksegment->bufsz, ksegment->mem,\n\t\t\t ksegment->memsz);\n\n\t\tret = kimage_load_segment(image, &image->segment[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tkimage_terminate(image);\n\n\tret = machine_kexec_post_load(image);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tkimage_file_post_load_cleanup(image);\nexchange:\n\timage = xchg(dest_image, image);\nout:\n\tif ((flags & KEXEC_FILE_ON_CRASH) && kexec_crash_image)\n\t\tarch_kexec_protect_crashkres();\n\n\tkexec_unlock();\n\tkimage_free(image);\n\treturn ret;\n}\n\nstatic int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_end = min(end, kbuf->buf_max);\n\ttemp_start = temp_end - kbuf->memsz;\n\n\tdo {\n\t\t \n\t\ttemp_start = temp_start & (~(kbuf->buf_align - 1));\n\n\t\tif (temp_start < start || temp_start < kbuf->buf_min)\n\t\t\treturn 0;\n\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\t \n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start - PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t} while (1);\n\n\t \n\tkbuf->mem = temp_start;\n\n\t \n\treturn 1;\n}\n\nstatic int locate_mem_hole_bottom_up(unsigned long start, unsigned long end,\n\t\t\t\t     struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->image;\n\tunsigned long temp_start, temp_end;\n\n\ttemp_start = max(start, kbuf->buf_min);\n\n\tdo {\n\t\ttemp_start = ALIGN(temp_start, kbuf->buf_align);\n\t\ttemp_end = temp_start + kbuf->memsz - 1;\n\n\t\tif (temp_end > end || temp_end > kbuf->buf_max)\n\t\t\treturn 0;\n\t\t \n\t\tif (kimage_is_destination_range(image, temp_start, temp_end)) {\n\t\t\ttemp_start = temp_start + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t} while (1);\n\n\t \n\tkbuf->mem = temp_start;\n\n\t \n\treturn 1;\n}\n\nstatic int locate_mem_hole_callback(struct resource *res, void *arg)\n{\n\tstruct kexec_buf *kbuf = (struct kexec_buf *)arg;\n\tu64 start = res->start, end = res->end;\n\tunsigned long sz = end - start + 1;\n\n\t \n\n\t \n\tif (res->flags & IORESOURCE_SYSRAM_DRIVER_MANAGED)\n\t\treturn 0;\n\n\tif (sz < kbuf->memsz)\n\t\treturn 0;\n\n\tif (end < kbuf->buf_min || start > kbuf->buf_max)\n\t\treturn 0;\n\n\t \n\tif (kbuf->top_down)\n\t\treturn locate_mem_hole_top_down(start, end, kbuf);\n\treturn locate_mem_hole_bottom_up(start, end, kbuf);\n}\n\n#ifdef CONFIG_ARCH_KEEP_MEMBLOCK\nstatic int kexec_walk_memblock(struct kexec_buf *kbuf,\n\t\t\t       int (*func)(struct resource *, void *))\n{\n\tint ret = 0;\n\tu64 i;\n\tphys_addr_t mstart, mend;\n\tstruct resource res = { };\n\n\tif (kbuf->image->type == KEXEC_TYPE_CRASH)\n\t\treturn func(&crashk_res, kbuf);\n\n\t \n\tif (kbuf->top_down) {\n\t\tfor_each_free_mem_range_reverse(i, NUMA_NO_NODE, MEMBLOCK_NONE,\n\t\t\t\t\t\t&mstart, &mend, NULL) {\n\t\t\t \n\t\t\tres.start = mstart;\n\t\t\tres.end = mend - 1;\n\t\t\tret = func(&res, kbuf);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE,\n\t\t\t\t\t&mstart, &mend, NULL) {\n\t\t\t \n\t\t\tres.start = mstart;\n\t\t\tres.end = mend - 1;\n\t\t\tret = func(&res, kbuf);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n#else\nstatic int kexec_walk_memblock(struct kexec_buf *kbuf,\n\t\t\t       int (*func)(struct resource *, void *))\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int kexec_walk_resources(struct kexec_buf *kbuf,\n\t\t\t\tint (*func)(struct resource *, void *))\n{\n\tif (kbuf->image->type == KEXEC_TYPE_CRASH)\n\t\treturn walk_iomem_res_desc(crashk_res.desc,\n\t\t\t\t\t   IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,\n\t\t\t\t\t   crashk_res.start, crashk_res.end,\n\t\t\t\t\t   kbuf, func);\n\telse\n\t\treturn walk_system_ram_res(0, ULONG_MAX, kbuf, func);\n}\n\n \nint kexec_locate_mem_hole(struct kexec_buf *kbuf)\n{\n\tint ret;\n\n\t \n\tif (kbuf->mem != KEXEC_BUF_MEM_UNKNOWN)\n\t\treturn 0;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK))\n\t\tret = kexec_walk_resources(kbuf, locate_mem_hole_callback);\n\telse\n\t\tret = kexec_walk_memblock(kbuf, locate_mem_hole_callback);\n\n\treturn ret == 1 ? 0 : -EADDRNOTAVAIL;\n}\n\n \nint kexec_add_buffer(struct kexec_buf *kbuf)\n{\n\tstruct kexec_segment *ksegment;\n\tint ret;\n\n\t \n\tif (!kbuf->image->file_mode)\n\t\treturn -EINVAL;\n\n\tif (kbuf->image->nr_segments >= KEXEC_SEGMENT_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (!list_empty(&kbuf->image->control_pages)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tkbuf->memsz = ALIGN(kbuf->memsz, PAGE_SIZE);\n\tkbuf->buf_align = max(kbuf->buf_align, PAGE_SIZE);\n\n\t \n\tret = arch_kexec_locate_mem_hole(kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tksegment = &kbuf->image->segment[kbuf->image->nr_segments];\n\tksegment->kbuf = kbuf->buffer;\n\tksegment->bufsz = kbuf->bufsz;\n\tksegment->mem = kbuf->mem;\n\tksegment->memsz = kbuf->memsz;\n\tkbuf->image->nr_segments++;\n\treturn 0;\n}\n\n \nstatic int kexec_calculate_store_digests(struct kimage *image)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tint ret = 0, i, j, zero_buf_sz, sha_region_sz;\n\tsize_t desc_size, nullsz;\n\tchar *digest;\n\tvoid *zero_buf;\n\tstruct kexec_sha_region *sha_regions;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_SUPPORTS_KEXEC_PURGATORY))\n\t\treturn 0;\n\n\tzero_buf = __va(page_to_pfn(ZERO_PAGE(0)) << PAGE_SHIFT);\n\tzero_buf_sz = PAGE_SIZE;\n\n\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out;\n\t}\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdesc = kzalloc(desc_size, GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_tfm;\n\t}\n\n\tsha_region_sz = KEXEC_SEGMENT_MAX * sizeof(struct kexec_sha_region);\n\tsha_regions = vzalloc(sha_region_sz);\n\tif (!sha_regions) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tdesc->tfm   = tfm;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto out_free_sha_regions;\n\n\tdigest = kzalloc(SHA256_DIGEST_SIZE, GFP_KERNEL);\n\tif (!digest) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_sha_regions;\n\t}\n\n\tfor (j = i = 0; i < image->nr_segments; i++) {\n\t\tstruct kexec_segment *ksegment;\n\n#ifdef CONFIG_CRASH_HOTPLUG\n\t\t \n\t\tif (j == image->elfcorehdr_index)\n\t\t\tcontinue;\n#endif\n\n\t\tksegment = &image->segment[i];\n\t\t \n\t\tif (ksegment->kbuf == pi->purgatory_buf)\n\t\t\tcontinue;\n\n\t\tret = crypto_shash_update(desc, ksegment->kbuf,\n\t\t\t\t\t  ksegment->bufsz);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tnullsz = ksegment->memsz - ksegment->bufsz;\n\t\twhile (nullsz) {\n\t\t\tunsigned long bytes = nullsz;\n\n\t\t\tif (bytes > zero_buf_sz)\n\t\t\t\tbytes = zero_buf_sz;\n\t\t\tret = crypto_shash_update(desc, zero_buf, bytes);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tnullsz -= bytes;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tsha_regions[j].start = ksegment->mem;\n\t\tsha_regions[j].len = ksegment->memsz;\n\t\tj++;\n\t}\n\n\tif (!ret) {\n\t\tret = crypto_shash_final(desc, digest);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\t\tret = kexec_purgatory_get_set_symbol(image, \"purgatory_sha_regions\",\n\t\t\t\t\t\t     sha_regions, sha_region_sz, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\n\t\tret = kexec_purgatory_get_set_symbol(image, \"purgatory_sha256_digest\",\n\t\t\t\t\t\t     digest, SHA256_DIGEST_SIZE, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_digest;\n\t}\n\nout_free_digest:\n\tkfree(digest);\nout_free_sha_regions:\n\tvfree(sha_regions);\nout_free_desc:\n\tkfree(desc);\nout_free_tfm:\n\tkfree(tfm);\nout:\n\treturn ret;\n}\n\n#ifdef CONFIG_ARCH_SUPPORTS_KEXEC_PURGATORY\n \nstatic int kexec_purgatory_setup_kbuf(struct purgatory_info *pi,\n\t\t\t\t      struct kexec_buf *kbuf)\n{\n\tconst Elf_Shdr *sechdrs;\n\tunsigned long bss_align;\n\tunsigned long bss_sz;\n\tunsigned long align;\n\tint i, ret;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\tkbuf->buf_align = bss_align = 1;\n\tkbuf->bufsz = bss_sz = 0;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type != SHT_NOBITS) {\n\t\t\tif (kbuf->buf_align < align)\n\t\t\t\tkbuf->buf_align = align;\n\t\t\tkbuf->bufsz = ALIGN(kbuf->bufsz, align);\n\t\t\tkbuf->bufsz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = ALIGN(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\tkbuf->bufsz = ALIGN(kbuf->bufsz, bss_align);\n\tkbuf->memsz = kbuf->bufsz + bss_sz;\n\tif (kbuf->buf_align < bss_align)\n\t\tkbuf->buf_align = bss_align;\n\n\tkbuf->buffer = vzalloc(kbuf->bufsz);\n\tif (!kbuf->buffer)\n\t\treturn -ENOMEM;\n\tpi->purgatory_buf = kbuf->buffer;\n\n\tret = kexec_add_buffer(kbuf);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}\n\n \nstatic int kexec_purgatory_setup_sechdrs(struct purgatory_info *pi,\n\t\t\t\t\t struct kexec_buf *kbuf)\n{\n\tunsigned long bss_addr;\n\tunsigned long offset;\n\tsize_t sechdrs_size;\n\tElf_Shdr *sechdrs;\n\tint i;\n\n\t \n\tsechdrs_size = array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum);\n\tsechdrs = vzalloc(sechdrs_size);\n\tif (!sechdrs)\n\t\treturn -ENOMEM;\n\tmemcpy(sechdrs, (void *)pi->ehdr + pi->ehdr->e_shoff, sechdrs_size);\n\tpi->sechdrs = sechdrs;\n\n\toffset = 0;\n\tbss_addr = kbuf->mem + kbuf->bufsz;\n\tkbuf->image->start = pi->ehdr->e_entry;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tunsigned long align;\n\t\tvoid *src, *dst;\n\n\t\tif (!(sechdrs[i].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\talign = sechdrs[i].sh_addralign;\n\t\tif (sechdrs[i].sh_type == SHT_NOBITS) {\n\t\t\tbss_addr = ALIGN(bss_addr, align);\n\t\t\tsechdrs[i].sh_addr = bss_addr;\n\t\t\tbss_addr += sechdrs[i].sh_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = ALIGN(offset, align);\n\n\t\t \n\t\tif (sechdrs[i].sh_flags & SHF_EXECINSTR &&\n\t\t    pi->ehdr->e_entry >= sechdrs[i].sh_addr &&\n\t\t    pi->ehdr->e_entry < (sechdrs[i].sh_addr\n\t\t\t\t\t + sechdrs[i].sh_size) &&\n\t\t    !WARN_ON(kbuf->image->start != pi->ehdr->e_entry)) {\n\t\t\tkbuf->image->start -= sechdrs[i].sh_addr;\n\t\t\tkbuf->image->start += kbuf->mem + offset;\n\t\t}\n\n\t\tsrc = (void *)pi->ehdr + sechdrs[i].sh_offset;\n\t\tdst = pi->purgatory_buf + offset;\n\t\tmemcpy(dst, src, sechdrs[i].sh_size);\n\n\t\tsechdrs[i].sh_addr = kbuf->mem + offset;\n\t\tsechdrs[i].sh_offset = offset;\n\t\toffset += sechdrs[i].sh_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int kexec_apply_relocations(struct kimage *image)\n{\n\tint i, ret;\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Shdr *sechdrs;\n\n\tsechdrs = (void *)pi->ehdr + pi->ehdr->e_shoff;\n\n\tfor (i = 0; i < pi->ehdr->e_shnum; i++) {\n\t\tconst Elf_Shdr *relsec;\n\t\tconst Elf_Shdr *symtab;\n\t\tElf_Shdr *section;\n\n\t\trelsec = sechdrs + i;\n\n\t\tif (relsec->sh_type != SHT_RELA &&\n\t\t    relsec->sh_type != SHT_REL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (relsec->sh_info >= pi->ehdr->e_shnum ||\n\t\t    relsec->sh_link >= pi->ehdr->e_shnum)\n\t\t\treturn -ENOEXEC;\n\n\t\tsection = pi->sechdrs + relsec->sh_info;\n\t\tsymtab = sechdrs + relsec->sh_link;\n\n\t\tif (!(section->sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (symtab->sh_link >= pi->ehdr->e_shnum)\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\tif (relsec->sh_type == SHT_RELA)\n\t\t\tret = arch_kexec_apply_relocations_add(pi, section,\n\t\t\t\t\t\t\t       relsec, symtab);\n\t\telse if (relsec->sh_type == SHT_REL)\n\t\t\tret = arch_kexec_apply_relocations(pi, section,\n\t\t\t\t\t\t\t   relsec, symtab);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint kexec_load_purgatory(struct kimage *image, struct kexec_buf *kbuf)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tint ret;\n\n\tif (kexec_purgatory_size <= 0)\n\t\treturn -EINVAL;\n\n\tpi->ehdr = (const Elf_Ehdr *)kexec_purgatory;\n\n\tret = kexec_purgatory_setup_kbuf(pi, kbuf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kexec_purgatory_setup_sechdrs(pi, kbuf);\n\tif (ret)\n\t\tgoto out_free_kbuf;\n\n\tret = kexec_apply_relocations(image);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\nout_free_kbuf:\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\treturn ret;\n}\n\n \nstatic const Elf_Sym *kexec_purgatory_find_symbol(struct purgatory_info *pi,\n\t\t\t\t\t\t  const char *name)\n{\n\tconst Elf_Shdr *sechdrs;\n\tconst Elf_Ehdr *ehdr;\n\tconst Elf_Sym *syms;\n\tconst char *strtab;\n\tint i, k;\n\n\tif (!pi->ehdr)\n\t\treturn NULL;\n\n\tehdr = pi->ehdr;\n\tsechdrs = (void *)ehdr + ehdr->e_shoff;\n\n\tfor (i = 0; i < ehdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type != SHT_SYMTAB)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_link >= ehdr->e_shnum)\n\t\t\t \n\t\t\tcontinue;\n\t\tstrtab = (void *)ehdr + sechdrs[sechdrs[i].sh_link].sh_offset;\n\t\tsyms = (void *)ehdr + sechdrs[i].sh_offset;\n\n\t\t \n\t\tfor (k = 0; k < sechdrs[i].sh_size/sizeof(Elf_Sym); k++) {\n\t\t\tif (ELF_ST_BIND(syms[k].st_info) != STB_GLOBAL)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == SHN_UNDEF ||\n\t\t\t    syms[k].st_shndx >= ehdr->e_shnum) {\n\t\t\t\tpr_debug(\"Symbol: %s has bad section index %d.\\n\",\n\t\t\t\t\t\tname, syms[k].st_shndx);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn &syms[k];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nvoid *kexec_purgatory_get_symbol_addr(struct kimage *image, const char *name)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sechdr;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsechdr = &pi->sechdrs[sym->st_shndx];\n\n\t \n\treturn (void *)(sechdr->sh_addr + sym->st_value);\n}\n\n \nint kexec_purgatory_get_set_symbol(struct kimage *image, const char *name,\n\t\t\t\t   void *buf, unsigned int size, bool get_value)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\tconst Elf_Sym *sym;\n\tElf_Shdr *sec;\n\tchar *sym_buf;\n\n\tsym = kexec_purgatory_find_symbol(pi, name);\n\tif (!sym)\n\t\treturn -EINVAL;\n\n\tif (sym->st_size != size) {\n\t\tpr_err(\"symbol %s size mismatch: expected %lu actual %u\\n\",\n\t\t       name, (unsigned long)sym->st_size, size);\n\t\treturn -EINVAL;\n\t}\n\n\tsec = pi->sechdrs + sym->st_shndx;\n\n\tif (sec->sh_type == SHT_NOBITS) {\n\t\tpr_err(\"symbol %s is in a bss section. Cannot %s\\n\", name,\n\t\t       get_value ? \"get\" : \"set\");\n\t\treturn -EINVAL;\n\t}\n\n\tsym_buf = (char *)pi->purgatory_buf + sec->sh_offset + sym->st_value;\n\n\tif (get_value)\n\t\tmemcpy((void *)buf, sym_buf, size);\n\telse\n\t\tmemcpy((void *)sym_buf, buf, size);\n\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}