{
  "module_name": "audit.h",
  "hash_id": "28cc9e3253c01faaf81f79bf27885cfb532666eeb8872583957ce68d5d7454c4",
  "original_prompt": "Ingested from linux-6.6.14/kernel/audit.h",
  "human_readable_source": " \n \n\n#ifndef _KERNEL_AUDIT_H_\n#define _KERNEL_AUDIT_H_\n\n#include <linux/fs.h>\n#include <linux/audit.h>\n#include <linux/skbuff.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/tty.h>\n#include <uapi/linux/openat2.h> \n\n \n#define AUDIT_NAMES\t5\n\n \nenum audit_state {\n\tAUDIT_STATE_DISABLED,\t \n\tAUDIT_STATE_BUILD,\t \n\tAUDIT_STATE_RECORD\t \n};\n\n \nstruct audit_watch;\nstruct audit_fsnotify_mark;\nstruct audit_tree;\nstruct audit_chunk;\n\nstruct audit_entry {\n\tstruct list_head\tlist;\n\tstruct rcu_head\t\trcu;\n\tstruct audit_krule\trule;\n};\n\nstruct audit_cap_data {\n\tkernel_cap_t\t\tpermitted;\n\tkernel_cap_t\t\tinheritable;\n\tunion {\n\t\tunsigned int\tfE;\t\t \n\t\tkernel_cap_t\teffective;\t \n\t};\n\tkernel_cap_t\t\tambient;\n\tkuid_t\t\t\trootid;\n};\n\n \nstruct audit_names {\n\tstruct list_head\tlist;\t\t \n\n\tstruct filename\t\t*name;\n\tint\t\t\tname_len;\t \n\tbool\t\t\thidden;\t\t \n\n\tunsigned long\t\tino;\n\tdev_t\t\t\tdev;\n\tumode_t\t\t\tmode;\n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tdev_t\t\t\trdev;\n\tu32\t\t\tosid;\n\tstruct audit_cap_data\tfcap;\n\tunsigned int\t\tfcap_ver;\n\tunsigned char\t\ttype;\t\t \n\t \n\tbool\t\t\tshould_free;\n};\n\nstruct audit_proctitle {\n\tint\tlen;\t \n\tchar\t*value;\t \n};\n\n \nstruct audit_context {\n\tint\t\t    dummy;\t \n\tenum {\n\t\tAUDIT_CTX_UNUSED,\t \n\t\tAUDIT_CTX_SYSCALL,\t \n\t\tAUDIT_CTX_URING,\t \n\t} context;\n\tenum audit_state    state, current_state;\n\tunsigned int\t    serial;      \n\tint\t\t    major;       \n\tint\t\t    uring_op;    \n\tstruct timespec64   ctime;       \n\tunsigned long\t    argv[4];     \n\tlong\t\t    return_code; \n\tu64\t\t    prio;\n\tint\t\t    return_valid;  \n\t \n\tstruct audit_names  preallocated_names[AUDIT_NAMES];\n\tint\t\t    name_count;  \n\tstruct list_head    names_list;\t \n\tchar\t\t    *filterkey;\t \n\tstruct path\t    pwd;\n\tstruct audit_aux_data *aux;\n\tstruct audit_aux_data *aux_pids;\n\tstruct sockaddr_storage *sockaddr;\n\tsize_t sockaddr_len;\n\t\t\t\t \n\tpid_t\t\t    ppid;\n\tkuid_t\t\t    uid, euid, suid, fsuid;\n\tkgid_t\t\t    gid, egid, sgid, fsgid;\n\tunsigned long\t    personality;\n\tint\t\t    arch;\n\n\tpid_t\t\t    target_pid;\n\tkuid_t\t\t    target_auid;\n\tkuid_t\t\t    target_uid;\n\tunsigned int\t    target_sessionid;\n\tu32\t\t    target_sid;\n\tchar\t\t    target_comm[TASK_COMM_LEN];\n\n\tstruct audit_tree_refs *trees, *first_trees;\n\tstruct list_head killed_trees;\n\tint tree_count;\n\n\tint type;\n\tunion {\n\t\tstruct {\n\t\t\tint nargs;\n\t\t\tlong args[6];\n\t\t} socketcall;\n\t\tstruct {\n\t\t\tkuid_t\t\t\tuid;\n\t\t\tkgid_t\t\t\tgid;\n\t\t\tumode_t\t\t\tmode;\n\t\t\tu32\t\t\tosid;\n\t\t\tint\t\t\thas_perm;\n\t\t\tuid_t\t\t\tperm_uid;\n\t\t\tgid_t\t\t\tperm_gid;\n\t\t\tumode_t\t\t\tperm_mode;\n\t\t\tunsigned long\t\tqbytes;\n\t\t} ipc;\n\t\tstruct {\n\t\t\tmqd_t\t\t\tmqdes;\n\t\t\tstruct mq_attr\t\tmqstat;\n\t\t} mq_getsetattr;\n\t\tstruct {\n\t\t\tmqd_t\t\t\tmqdes;\n\t\t\tint\t\t\tsigev_signo;\n\t\t} mq_notify;\n\t\tstruct {\n\t\t\tmqd_t\t\t\tmqdes;\n\t\t\tsize_t\t\t\tmsg_len;\n\t\t\tunsigned int\t\tmsg_prio;\n\t\t\tstruct timespec64\tabs_timeout;\n\t\t} mq_sendrecv;\n\t\tstruct {\n\t\t\tint\t\t\toflag;\n\t\t\tumode_t\t\t\tmode;\n\t\t\tstruct mq_attr\t\tattr;\n\t\t} mq_open;\n\t\tstruct {\n\t\t\tpid_t\t\t\tpid;\n\t\t\tstruct audit_cap_data\tcap;\n\t\t} capset;\n\t\tstruct {\n\t\t\tint\t\t\tfd;\n\t\t\tint\t\t\tflags;\n\t\t} mmap;\n\t\tstruct open_how openat2;\n\t\tstruct {\n\t\t\tint\t\t\targc;\n\t\t} execve;\n\t\tstruct {\n\t\t\tchar\t\t\t*name;\n\t\t} module;\n\t\tstruct {\n\t\t\tstruct audit_ntp_data\tntp_data;\n\t\t\tstruct timespec64\ttk_injoffset;\n\t\t} time;\n\t};\n\tint fds[2];\n\tstruct audit_proctitle proctitle;\n};\n\nextern bool audit_ever_enabled;\n\nextern void audit_log_session_info(struct audit_buffer *ab);\n\nextern int auditd_test_task(struct task_struct *task);\n\n#define AUDIT_INODE_BUCKETS\t32\nextern struct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}\n\n \n#define AUDIT_NAME_FULL -1\n\nextern int audit_match_class(int class, unsigned syscall);\nextern int audit_comparator(const u32 left, const u32 op, const u32 right);\nextern int audit_uid_comparator(kuid_t left, u32 op, kuid_t right);\nextern int audit_gid_comparator(kgid_t left, u32 op, kgid_t right);\nextern int parent_len(const char *path);\nextern int audit_compare_dname_path(const struct qstr *dname, const char *path, int plen);\nextern struct sk_buff *audit_make_reply(int seq, int type, int done, int multi,\n\t\t\t\t\tconst void *payload, int size);\nextern void\t\t    audit_panic(const char *message);\n\nstruct audit_netlink_list {\n\t__u32 portid;\n\tstruct net *net;\n\tstruct sk_buff_head q;\n};\n\nint audit_send_list_thread(void *_dest);\n\nextern struct mutex audit_filter_mutex;\nextern int audit_del_rule(struct audit_entry *entry);\nextern void audit_free_rule_rcu(struct rcu_head *head);\nextern struct list_head audit_filter_list[];\n\nextern struct audit_entry *audit_dupe_rule(struct audit_krule *old);\n\nextern void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t\t struct mm_struct *mm);\n\nextern struct tty_struct *audit_get_tty(void);\nextern void audit_put_tty(struct tty_struct *tty);\n\n \nextern unsigned int audit_serial(void);\n#ifdef CONFIG_AUDITSYSCALL\nextern int auditsc_get_stamp(struct audit_context *ctx,\n\t\t\t      struct timespec64 *t, unsigned int *serial);\n\nextern void audit_put_watch(struct audit_watch *watch);\nextern void audit_get_watch(struct audit_watch *watch);\nextern int audit_to_watch(struct audit_krule *krule, char *path, int len,\n\t\t\t  u32 op);\nextern int audit_add_watch(struct audit_krule *krule, struct list_head **list);\nextern void audit_remove_watch_rule(struct audit_krule *krule);\nextern char *audit_watch_path(struct audit_watch *watch);\nextern int audit_watch_compare(struct audit_watch *watch, unsigned long ino,\n\t\t\t       dev_t dev);\n\nextern struct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule,\n\t\t\t\t\t\t    char *pathname, int len);\nextern char *audit_mark_path(struct audit_fsnotify_mark *mark);\nextern void audit_remove_mark(struct audit_fsnotify_mark *audit_mark);\nextern void audit_remove_mark_rule(struct audit_krule *krule);\nextern int audit_mark_compare(struct audit_fsnotify_mark *mark,\n\t\t\t      unsigned long ino, dev_t dev);\nextern int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old);\nextern int audit_exe_compare(struct task_struct *tsk,\n\t\t\t     struct audit_fsnotify_mark *mark);\n\nextern struct audit_chunk *audit_tree_lookup(const struct inode *inode);\nextern void audit_put_chunk(struct audit_chunk *chunk);\nextern bool audit_tree_match(struct audit_chunk *chunk,\n\t\t\t     struct audit_tree *tree);\nextern int audit_make_tree(struct audit_krule *rule, char *pathname, u32 op);\nextern int audit_add_tree_rule(struct audit_krule *rule);\nextern int audit_remove_tree_rule(struct audit_krule *rule);\nextern void audit_trim_trees(void);\nextern int audit_tag_tree(char *old, char *new);\nextern const char *audit_tree_path(struct audit_tree *tree);\nextern void audit_put_tree(struct audit_tree *tree);\nextern void audit_kill_trees(struct audit_context *context);\n\nextern int audit_signal_info_syscall(struct task_struct *t);\nextern void audit_filter_inodes(struct task_struct *tsk,\n\t\t\t\tstruct audit_context *ctx);\nextern struct list_head *audit_killed_trees(void);\n#else  \n#define auditsc_get_stamp(c, t, s) 0\n#define audit_put_watch(w) do { } while (0)\n#define audit_get_watch(w) do { } while (0)\n#define audit_to_watch(k, p, l, o) (-EINVAL)\n#define audit_add_watch(k, l) (-EINVAL)\n#define audit_remove_watch_rule(k) BUG()\n#define audit_watch_path(w) \"\"\n#define audit_watch_compare(w, i, d) 0\n\n#define audit_alloc_mark(k, p, l) (ERR_PTR(-EINVAL))\n#define audit_mark_path(m) \"\"\n#define audit_remove_mark(m) do { } while (0)\n#define audit_remove_mark_rule(k) do { } while (0)\n#define audit_mark_compare(m, i, d) 0\n#define audit_exe_compare(t, m) (-EINVAL)\n#define audit_dupe_exe(n, o) (-EINVAL)\n\n#define audit_remove_tree_rule(rule) BUG()\n#define audit_add_tree_rule(rule) -EINVAL\n#define audit_make_tree(rule, str, op) -EINVAL\n#define audit_trim_trees() do { } while (0)\n#define audit_put_tree(tree) do { } while (0)\n#define audit_tag_tree(old, new) -EINVAL\n#define audit_tree_path(rule) \"\"\t \n#define audit_kill_trees(context) BUG()\n\nstatic inline int audit_signal_info_syscall(struct task_struct *t)\n{\n\treturn 0;\n}\n\n#define audit_filter_inodes(t, c) do { } while (0)\n#endif  \n\nextern char *audit_unpack_string(void **bufp, size_t *remain, size_t len);\n\nextern int audit_filter(int msgtype, unsigned int listtype);\n\nextern void audit_ctl_lock(void);\nextern void audit_ctl_unlock(void);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}