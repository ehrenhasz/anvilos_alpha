{
  "module_name": "crash_core.c",
  "hash_id": "578fcd9921b1fe948ffcbca306f305c9ace5fd6815ca0dfa83a3d92cd4df2a4b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/crash_core.c",
  "human_readable_source": "\n \n\n#include <linux/buildid.h>\n#include <linux/crash_core.h>\n#include <linux/init.h>\n#include <linux/utsname.h>\n#include <linux/vmalloc.h>\n#include <linux/sizes.h>\n#include <linux/kexec.h>\n#include <linux/memory.h>\n#include <linux/cpuhotplug.h>\n\n#include <asm/page.h>\n#include <asm/sections.h>\n\n#include <crypto/sha1.h>\n\n#include \"kallsyms_internal.h\"\n#include \"kexec_internal.h\"\n\n \nnote_buf_t __percpu *crash_notes;\n\n \nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nu32 *vmcoreinfo_note;\n\n \nstatic unsigned char *vmcoreinfo_data_safecopy;\n\n \n\n\n \nstatic int __init parse_crashkernel_mem(char *cmdline,\n\t\t\t\t\tunsigned long long system_ram,\n\t\t\t\t\tunsigned long long *crash_size,\n\t\t\t\t\tunsigned long long *crash_base)\n{\n\tchar *cur = cmdline, *tmp;\n\tunsigned long long total_mem = system_ram;\n\n\t \n\ttotal_mem = roundup(total_mem, SZ_128M);\n\n\t \n\tdo {\n\t\tunsigned long long start, end = ULLONG_MAX, size;\n\n\t\t \n\t\tstart = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (*cur != '-') {\n\t\t\tpr_warn(\"crashkernel: '-' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\t \n\t\tif (*cur != ':') {\n\t\t\tend = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcur = tmp;\n\t\t\tif (end <= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >= total_mem) {\n\t\t\tpr_warn(\"crashkernel: invalid size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (total_mem >= start && total_mem < end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size > 0) {\n\t\twhile (*cur && *cur != ' ' && *cur != '@')\n\t\t\tcur++;\n\t\tif (*cur == '@') {\n\t\t\tcur++;\n\t\t\t*crash_base = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"Memory value expected after '@'\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpr_info(\"crashkernel size resulted in zero bytes\\n\");\n\n\treturn 0;\n}\n\n \nstatic int __init parse_crashkernel_simple(char *cmdline,\n\t\t\t\t\t   unsigned long long *crash_size,\n\t\t\t\t\t   unsigned long long *crash_base)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*cur == '@')\n\t\t*crash_base = memparse(cur+1, &cur);\n\telse if (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define SUFFIX_HIGH 0\n#define SUFFIX_LOW  1\n#define SUFFIX_NULL 2\nstatic __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};\n\n \nstatic int __init parse_crashkernel_suffix(char *cmdline,\n\t\t\t\t\t   unsigned long long\t*crash_size,\n\t\t\t\t\t   const char *suffix)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (strncmp(cur, suffix, strlen(suffix))) {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\tcur += strlen(suffix);\n\tif (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic __init char *get_last_crashkernel(char *cmdline,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar *p = cmdline, *ck_cmdline = NULL;\n\n\t \n\tp = strstr(p, name);\n\twhile (p) {\n\t\tchar *end_p = strchr(p, ' ');\n\t\tchar *q;\n\n\t\tif (!end_p)\n\t\t\tend_p = p + strlen(p);\n\n\t\tif (!suffix) {\n\t\t\tint i;\n\n\t\t\t \n\t\t\tfor (i = 0; suffix_tbl[i]; i++) {\n\t\t\t\tq = end_p - strlen(suffix_tbl[i]);\n\t\t\t\tif (!strncmp(q, suffix_tbl[i],\n\t\t\t\t\t     strlen(suffix_tbl[i])))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tck_cmdline = p;\n\t\t} else {\n\t\t\tq = end_p - strlen(suffix);\n\t\t\tif (!strncmp(q, suffix, strlen(suffix)))\n\t\t\t\tck_cmdline = p;\n\t\t}\nnext:\n\t\tp = strstr(p+1, name);\n\t}\n\n\treturn ck_cmdline;\n}\n\nstatic int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\tif (!ck_cmdline)\n\t\treturn -ENOENT;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t \n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}\n\n \nint __init parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\t\"crashkernel=\", NULL);\n}\n\nint __init parse_crashkernel_high(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[SUFFIX_HIGH]);\n}\n\nint __init parse_crashkernel_low(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[SUFFIX_LOW]);\n}\n\n \nstatic int __init parse_crashkernel_dummy(char *arg)\n{\n\treturn 0;\n}\nearly_param(\"crashkernel\", parse_crashkernel_dummy);\n\nint crash_prepare_elf64_headers(struct crash_mem *mem, int need_kernel_map,\n\t\t\t  void **addr, unsigned long *sz)\n{\n\tElf64_Ehdr *ehdr;\n\tElf64_Phdr *phdr;\n\tunsigned long nr_cpus = num_possible_cpus(), nr_phdr, elf_sz;\n\tunsigned char *buf;\n\tunsigned int cpu, i;\n\tunsigned long long notes_addr;\n\tunsigned long mstart, mend;\n\n\t \n\tnr_phdr = nr_cpus + 1;\n\tnr_phdr += mem->nr_ranges;\n\n\t \n\n\tnr_phdr++;\n\telf_sz = sizeof(Elf64_Ehdr) + nr_phdr * sizeof(Elf64_Phdr);\n\telf_sz = ALIGN(elf_sz, ELF_CORE_HEADER_ALIGN);\n\n\tbuf = vzalloc(elf_sz);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tehdr = (Elf64_Ehdr *)buf;\n\tphdr = (Elf64_Phdr *)(ehdr + 1);\n\tmemcpy(ehdr->e_ident, ELFMAG, SELFMAG);\n\tehdr->e_ident[EI_CLASS] = ELFCLASS64;\n\tehdr->e_ident[EI_DATA] = ELFDATA2LSB;\n\tehdr->e_ident[EI_VERSION] = EV_CURRENT;\n\tehdr->e_ident[EI_OSABI] = ELF_OSABI;\n\tmemset(ehdr->e_ident + EI_PAD, 0, EI_NIDENT - EI_PAD);\n\tehdr->e_type = ET_CORE;\n\tehdr->e_machine = ELF_ARCH;\n\tehdr->e_version = EV_CURRENT;\n\tehdr->e_phoff = sizeof(Elf64_Ehdr);\n\tehdr->e_ehsize = sizeof(Elf64_Ehdr);\n\tehdr->e_phentsize = sizeof(Elf64_Phdr);\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tphdr->p_type = PT_NOTE;\n\t\tnotes_addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpu));\n\t\tphdr->p_offset = phdr->p_paddr = notes_addr;\n\t\tphdr->p_filesz = phdr->p_memsz = sizeof(note_buf_t);\n\t\t(ehdr->e_phnum)++;\n\t\tphdr++;\n\t}\n\n\t \n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = phdr->p_paddr = paddr_vmcoreinfo_note();\n\tphdr->p_filesz = phdr->p_memsz = VMCOREINFO_NOTE_SIZE;\n\t(ehdr->e_phnum)++;\n\tphdr++;\n\n\t \n\tif (need_kernel_map) {\n\t\tphdr->p_type = PT_LOAD;\n\t\tphdr->p_flags = PF_R|PF_W|PF_X;\n\t\tphdr->p_vaddr = (unsigned long) _text;\n\t\tphdr->p_filesz = phdr->p_memsz = _end - _text;\n\t\tphdr->p_offset = phdr->p_paddr = __pa_symbol(_text);\n\t\tehdr->e_phnum++;\n\t\tphdr++;\n\t}\n\n\t \n\tfor (i = 0; i < mem->nr_ranges; i++) {\n\t\tmstart = mem->ranges[i].start;\n\t\tmend = mem->ranges[i].end;\n\n\t\tphdr->p_type = PT_LOAD;\n\t\tphdr->p_flags = PF_R|PF_W|PF_X;\n\t\tphdr->p_offset  = mstart;\n\n\t\tphdr->p_paddr = mstart;\n\t\tphdr->p_vaddr = (unsigned long) __va(mstart);\n\t\tphdr->p_filesz = phdr->p_memsz = mend - mstart + 1;\n\t\tphdr->p_align = 0;\n\t\tehdr->e_phnum++;\n\t\tpr_debug(\"Crash PT_LOAD ELF header. phdr=%p vaddr=0x%llx, paddr=0x%llx, sz=0x%llx e_phnum=%d p_offset=0x%llx\\n\",\n\t\t\tphdr, phdr->p_vaddr, phdr->p_paddr, phdr->p_filesz,\n\t\t\tehdr->e_phnum, phdr->p_offset);\n\t\tphdr++;\n\t}\n\n\t*addr = buf;\n\t*sz = elf_sz;\n\treturn 0;\n}\n\nint crash_exclude_mem_range(struct crash_mem *mem,\n\t\t\t    unsigned long long mstart, unsigned long long mend)\n{\n\tint i, j;\n\tunsigned long long start, end, p_start, p_end;\n\tstruct range temp_range = {0, 0};\n\n\tfor (i = 0; i < mem->nr_ranges; i++) {\n\t\tstart = mem->ranges[i].start;\n\t\tend = mem->ranges[i].end;\n\t\tp_start = mstart;\n\t\tp_end = mend;\n\n\t\tif (mstart > end || mend < start)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (mstart < start)\n\t\t\tp_start = start;\n\t\tif (mend > end)\n\t\t\tp_end = end;\n\n\t\t \n\t\tif (p_start == start && p_end == end) {\n\t\t\tmem->ranges[i].start = 0;\n\t\t\tmem->ranges[i].end = 0;\n\t\t\tif (i < mem->nr_ranges - 1) {\n\t\t\t\t \n\t\t\t\tfor (j = i; j < mem->nr_ranges - 1; j++) {\n\t\t\t\t\tmem->ranges[j].start =\n\t\t\t\t\t\tmem->ranges[j+1].start;\n\t\t\t\t\tmem->ranges[j].end =\n\t\t\t\t\t\t\tmem->ranges[j+1].end;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\ti--;\n\t\t\t\tmem->nr_ranges--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmem->nr_ranges--;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (p_start > start && p_end < end) {\n\t\t\t \n\t\t\tmem->ranges[i].end = p_start - 1;\n\t\t\ttemp_range.start = p_end + 1;\n\t\t\ttemp_range.end = end;\n\t\t} else if (p_start != start)\n\t\t\tmem->ranges[i].end = p_start - 1;\n\t\telse\n\t\t\tmem->ranges[i].start = p_end + 1;\n\t\tbreak;\n\t}\n\n\t \n\tif (!temp_range.end)\n\t\treturn 0;\n\n\t \n\tif (i == mem->max_nr_ranges - 1)\n\t\treturn -ENOMEM;\n\n\t \n\tj = i + 1;\n\tif (j < mem->nr_ranges) {\n\t\t \n\t\tfor (i = mem->nr_ranges - 1; i >= j; i--)\n\t\t\tmem->ranges[i + 1] = mem->ranges[i];\n\t}\n\n\tmem->ranges[j].start = temp_range.start;\n\tmem->ranges[j].end = temp_range.end;\n\tmem->nr_ranges++;\n\treturn 0;\n}\n\nElf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}\n\nvoid final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}\n\nstatic void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}\n\nvoid crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}\n\nvoid crash_save_vmcoreinfo(void)\n{\n\tif (!vmcoreinfo_note)\n\t\treturn;\n\n\t \n\tif (vmcoreinfo_data_safecopy)\n\t\tvmcoreinfo_data = vmcoreinfo_data_safecopy;\n\n\tvmcoreinfo_append_str(\"CRASHTIME=%lld\\n\", ktime_get_real_seconds());\n\tupdate_vmcoreinfo_note();\n}\n\nvoid vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, (size_t)VMCOREINFO_BYTES - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n\n\tWARN_ONCE(vmcoreinfo_size == VMCOREINFO_BYTES,\n\t\t  \"vmcoreinfo data exceeds allocated size, truncating\");\n}\n\n \nvoid __weak arch_crash_save_vmcoreinfo(void)\n{}\n\nphys_addr_t __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa(vmcoreinfo_note);\n}\nEXPORT_SYMBOL(paddr_vmcoreinfo_note);\n\nstatic int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_data = (unsigned char *)get_zeroed_page(GFP_KERNEL);\n\tif (!vmcoreinfo_data) {\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_data failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvmcoreinfo_note = alloc_pages_exact(VMCOREINFO_NOTE_SIZE,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!vmcoreinfo_note) {\n\t\tfree_page((unsigned long)vmcoreinfo_data);\n\t\tvmcoreinfo_data = NULL;\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_note failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tVMCOREINFO_OSRELEASE(init_uts_ns.name.release);\n\tVMCOREINFO_BUILD_ID();\n\tVMCOREINFO_PAGESIZE(PAGE_SIZE);\n\n\tVMCOREINFO_SYMBOL(init_uts_ns);\n\tVMCOREINFO_OFFSET(uts_namespace, name);\n\tVMCOREINFO_SYMBOL(node_online_map);\n#ifdef CONFIG_MMU\n\tVMCOREINFO_SYMBOL_ARRAY(swapper_pg_dir);\n#endif\n\tVMCOREINFO_SYMBOL(_stext);\n\tVMCOREINFO_SYMBOL(vmap_area_list);\n\n#ifndef CONFIG_NUMA\n\tVMCOREINFO_SYMBOL(mem_map);\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#ifdef CONFIG_SPARSEMEM\n\tVMCOREINFO_SYMBOL_ARRAY(mem_section);\n\tVMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);\n\tVMCOREINFO_STRUCT_SIZE(mem_section);\n\tVMCOREINFO_OFFSET(mem_section, section_mem_map);\n\tVMCOREINFO_NUMBER(SECTION_SIZE_BITS);\n\tVMCOREINFO_NUMBER(MAX_PHYSMEM_BITS);\n#endif\n\tVMCOREINFO_STRUCT_SIZE(page);\n\tVMCOREINFO_STRUCT_SIZE(pglist_data);\n\tVMCOREINFO_STRUCT_SIZE(zone);\n\tVMCOREINFO_STRUCT_SIZE(free_area);\n\tVMCOREINFO_STRUCT_SIZE(list_head);\n\tVMCOREINFO_SIZE(nodemask_t);\n\tVMCOREINFO_OFFSET(page, flags);\n\tVMCOREINFO_OFFSET(page, _refcount);\n\tVMCOREINFO_OFFSET(page, mapping);\n\tVMCOREINFO_OFFSET(page, lru);\n\tVMCOREINFO_OFFSET(page, _mapcount);\n\tVMCOREINFO_OFFSET(page, private);\n\tVMCOREINFO_OFFSET(page, compound_head);\n\tVMCOREINFO_OFFSET(pglist_data, node_zones);\n\tVMCOREINFO_OFFSET(pglist_data, nr_zones);\n#ifdef CONFIG_FLATMEM\n\tVMCOREINFO_OFFSET(pglist_data, node_mem_map);\n#endif\n\tVMCOREINFO_OFFSET(pglist_data, node_start_pfn);\n\tVMCOREINFO_OFFSET(pglist_data, node_spanned_pages);\n\tVMCOREINFO_OFFSET(pglist_data, node_id);\n\tVMCOREINFO_OFFSET(zone, free_area);\n\tVMCOREINFO_OFFSET(zone, vm_stat);\n\tVMCOREINFO_OFFSET(zone, spanned_pages);\n\tVMCOREINFO_OFFSET(free_area, free_list);\n\tVMCOREINFO_OFFSET(list_head, next);\n\tVMCOREINFO_OFFSET(list_head, prev);\n\tVMCOREINFO_OFFSET(vmap_area, va_start);\n\tVMCOREINFO_OFFSET(vmap_area, list);\n\tVMCOREINFO_LENGTH(zone.free_area, MAX_ORDER + 1);\n\tlog_buf_vmcoreinfo_setup();\n\tVMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);\n\tVMCOREINFO_NUMBER(NR_FREE_PAGES);\n\tVMCOREINFO_NUMBER(PG_lru);\n\tVMCOREINFO_NUMBER(PG_private);\n\tVMCOREINFO_NUMBER(PG_swapcache);\n\tVMCOREINFO_NUMBER(PG_swapbacked);\n\tVMCOREINFO_NUMBER(PG_slab);\n#ifdef CONFIG_MEMORY_FAILURE\n\tVMCOREINFO_NUMBER(PG_hwpoison);\n#endif\n\tVMCOREINFO_NUMBER(PG_head_mask);\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\tVMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);\n#ifdef CONFIG_HUGETLB_PAGE\n\tVMCOREINFO_NUMBER(PG_hugetlb);\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n\tVMCOREINFO_NUMBER(PAGE_OFFLINE_MAPCOUNT_VALUE);\n#endif\n\n#ifdef CONFIG_KALLSYMS\n\tVMCOREINFO_SYMBOL(kallsyms_names);\n\tVMCOREINFO_SYMBOL(kallsyms_num_syms);\n\tVMCOREINFO_SYMBOL(kallsyms_token_table);\n\tVMCOREINFO_SYMBOL(kallsyms_token_index);\n#ifdef CONFIG_KALLSYMS_BASE_RELATIVE\n\tVMCOREINFO_SYMBOL(kallsyms_offsets);\n\tVMCOREINFO_SYMBOL(kallsyms_relative_base);\n#else\n\tVMCOREINFO_SYMBOL(kallsyms_addresses);\n#endif  \n#endif  \n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}\n\nsubsys_initcall(crash_save_vmcoreinfo_init);\n\nstatic int __init crash_notes_memory_init(void)\n{\n\t \n\tsize_t size, align;\n\n\t \n\tsize = sizeof(note_buf_t);\n\talign = min(roundup_pow_of_two(sizeof(note_buf_t)), PAGE_SIZE);\n\n\t \n\tBUILD_BUG_ON(size > PAGE_SIZE);\n\n\tcrash_notes = __alloc_percpu(size, align);\n\tif (!crash_notes) {\n\t\tpr_warn(\"Memory allocation for saving cpu register states failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\nsubsys_initcall(crash_notes_memory_init);\n\n#ifdef CONFIG_CRASH_HOTPLUG\n#undef pr_fmt\n#define pr_fmt(fmt) \"crash hp: \" fmt\n\n \nDEFINE_MUTEX(__crash_hotplug_lock);\n#define crash_hotplug_lock() mutex_lock(&__crash_hotplug_lock)\n#define crash_hotplug_unlock() mutex_unlock(&__crash_hotplug_lock)\n\n \nint crash_check_update_elfcorehdr(void)\n{\n\tint rc = 0;\n\n\tcrash_hotplug_lock();\n\t \n\tif (!kexec_trylock()) {\n\t\tpr_info(\"kexec_trylock() failed, elfcorehdr may be inaccurate\\n\");\n\t\tcrash_hotplug_unlock();\n\t\treturn 0;\n\t}\n\tif (kexec_crash_image) {\n\t\tif (kexec_crash_image->file_mode)\n\t\t\trc = 1;\n\t\telse\n\t\t\trc = kexec_crash_image->update_elfcorehdr;\n\t}\n\t \n\tkexec_unlock();\n\tcrash_hotplug_unlock();\n\n\treturn rc;\n}\n\n \nstatic void crash_handle_hotplug_event(unsigned int hp_action, unsigned int cpu)\n{\n\tstruct kimage *image;\n\n\tcrash_hotplug_lock();\n\t \n\tif (!kexec_trylock()) {\n\t\tpr_info(\"kexec_trylock() failed, elfcorehdr may be inaccurate\\n\");\n\t\tcrash_hotplug_unlock();\n\t\treturn;\n\t}\n\n\t \n\tif (!kexec_crash_image)\n\t\tgoto out;\n\n\timage = kexec_crash_image;\n\n\t \n\tif (!(image->file_mode || image->update_elfcorehdr))\n\t\tgoto out;\n\n\tif (hp_action == KEXEC_CRASH_HP_ADD_CPU ||\n\t\thp_action == KEXEC_CRASH_HP_REMOVE_CPU)\n\t\tpr_debug(\"hp_action %u, cpu %u\\n\", hp_action, cpu);\n\telse\n\t\tpr_debug(\"hp_action %u\\n\", hp_action);\n\n\t \n\tif (image->elfcorehdr_index < 0) {\n\t\tunsigned long mem;\n\t\tunsigned char *ptr;\n\t\tunsigned int n;\n\n\t\tfor (n = 0; n < image->nr_segments; n++) {\n\t\t\tmem = image->segment[n].mem;\n\t\t\tptr = kmap_local_page(pfn_to_page(mem >> PAGE_SHIFT));\n\t\t\tif (ptr) {\n\t\t\t\t \n\t\t\t\tif (memcmp(ptr, ELFMAG, SELFMAG) == 0)\n\t\t\t\t\timage->elfcorehdr_index = (int)n;\n\t\t\t\tkunmap_local(ptr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (image->elfcorehdr_index < 0) {\n\t\tpr_err(\"unable to locate elfcorehdr segment\");\n\t\tgoto out;\n\t}\n\n\t \n\tarch_kexec_unprotect_crashkres();\n\n\t \n\timage->hp_action = hp_action;\n\n\t \n\tarch_crash_handle_hotplug_event(image);\n\n\t \n\timage->hp_action = KEXEC_CRASH_HP_NONE;\n\timage->elfcorehdr_updated = true;\n\n\t \n\tarch_kexec_protect_crashkres();\n\n\t \nout:\n\t \n\tkexec_unlock();\n\tcrash_hotplug_unlock();\n}\n\nstatic int crash_memhp_notifier(struct notifier_block *nb, unsigned long val, void *v)\n{\n\tswitch (val) {\n\tcase MEM_ONLINE:\n\t\tcrash_handle_hotplug_event(KEXEC_CRASH_HP_ADD_MEMORY,\n\t\t\tKEXEC_CRASH_HP_INVALID_CPU);\n\t\tbreak;\n\n\tcase MEM_OFFLINE:\n\t\tcrash_handle_hotplug_event(KEXEC_CRASH_HP_REMOVE_MEMORY,\n\t\t\tKEXEC_CRASH_HP_INVALID_CPU);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block crash_memhp_nb = {\n\t.notifier_call = crash_memhp_notifier,\n\t.priority = 0\n};\n\nstatic int crash_cpuhp_online(unsigned int cpu)\n{\n\tcrash_handle_hotplug_event(KEXEC_CRASH_HP_ADD_CPU, cpu);\n\treturn 0;\n}\n\nstatic int crash_cpuhp_offline(unsigned int cpu)\n{\n\tcrash_handle_hotplug_event(KEXEC_CRASH_HP_REMOVE_CPU, cpu);\n\treturn 0;\n}\n\nstatic int __init crash_hotplug_init(void)\n{\n\tint result = 0;\n\n\tif (IS_ENABLED(CONFIG_MEMORY_HOTPLUG))\n\t\tregister_memory_notifier(&crash_memhp_nb);\n\n\tif (IS_ENABLED(CONFIG_HOTPLUG_CPU)) {\n\t\tresult = cpuhp_setup_state_nocalls(CPUHP_BP_PREPARE_DYN,\n\t\t\t\"crash/cpuhp\", crash_cpuhp_online, crash_cpuhp_offline);\n\t}\n\n\treturn result;\n}\n\nsubsys_initcall(crash_hotplug_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}