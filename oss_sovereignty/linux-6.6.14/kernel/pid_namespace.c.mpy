{
  "module_name": "pid_namespace.c",
  "hash_id": "8769375c44eaf269d45739a25fdd1815fd5c4b88d948b1d20057cf6be5abddf3",
  "original_prompt": "Ingested from linux-6.6.14/kernel/pid_namespace.c",
  "human_readable_source": "\n \n\n#include <linux/pid.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/cred.h>\n#include <linux/err.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/proc_ns.h>\n#include <linux/reboot.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/idr.h>\n#include \"pid_sysctl.h\"\n\nstatic DEFINE_MUTEX(pid_caches_mutex);\nstatic struct kmem_cache *pid_ns_cachep;\n \nstatic struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];\n\n \n\nstatic struct kmem_cache *create_pid_cachep(unsigned int level)\n{\n\t \n\tstruct kmem_cache **pkc = &pid_cache[level - 1];\n\tstruct kmem_cache *kc;\n\tchar name[4 + 10 + 1];\n\tunsigned int len;\n\n\tkc = READ_ONCE(*pkc);\n\tif (kc)\n\t\treturn kc;\n\n\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);\n\tlen = struct_size_t(struct pid, numbers, level + 1);\n\tmutex_lock(&pid_caches_mutex);\n\t \n\tif (!*pkc)\n\t\t*pkc = kmem_cache_create(name, len, 0,\n\t\t\t\t\t SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);\n\tmutex_unlock(&pid_caches_mutex);\n\t \n\treturn READ_ONCE(*pkc);\n}\n\nstatic struct ucounts *inc_pid_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);\n}\n\nstatic void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}\n\nstatic struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,\n\tstruct pid_namespace *parent_pid_ns)\n{\n\tstruct pid_namespace *ns;\n\tunsigned int level = parent_pid_ns->level + 1;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -EINVAL;\n\tif (!in_userns(parent_pid_ns->user_ns, user_ns))\n\t\tgoto out;\n\n\terr = -ENOSPC;\n\tif (level > MAX_PID_NS_LEVEL)\n\t\tgoto out;\n\tucounts = inc_pid_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\n\tif (ns == NULL)\n\t\tgoto out_dec;\n\n\tidr_init(&ns->idr);\n\n\tns->pid_cachep = create_pid_cachep(level);\n\tif (ns->pid_cachep == NULL)\n\t\tgoto out_free_idr;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto out_free_idr;\n\tns->ns.ops = &pidns_operations;\n\n\trefcount_set(&ns->ns.count, 1);\n\tns->level = level;\n\tns->parent = get_pid_ns(parent_pid_ns);\n\tns->user_ns = get_user_ns(user_ns);\n\tns->ucounts = ucounts;\n\tns->pid_allocated = PIDNS_ADDING;\n#if defined(CONFIG_SYSCTL) && defined(CONFIG_MEMFD_CREATE)\n\tns->memfd_noexec_scope = pidns_memfd_noexec_scope(parent_pid_ns);\n#endif\n\treturn ns;\n\nout_free_idr:\n\tidr_destroy(&ns->idr);\n\tkmem_cache_free(pid_ns_cachep, ns);\nout_dec:\n\tdec_pid_namespaces(ucounts);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void delayed_free_pidns(struct rcu_head *p)\n{\n\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);\n\n\tdec_pid_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\n\tkmem_cache_free(pid_ns_cachep, ns);\n}\n\nstatic void destroy_pid_namespace(struct pid_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\n\tidr_destroy(&ns->idr);\n\tcall_rcu(&ns->rcu, delayed_free_pidns);\n}\n\nstruct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}\nEXPORT_SYMBOL_GPL(put_pid_ns);\n\nvoid zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t \n\tdisable_pid_allocation(pid_ns);\n\n\t \n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t \n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t \n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t \n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\t \n\t\texit_tasks_rcu_stop();\n\t\tschedule();\n\t\texit_tasks_rcu_start();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic int pid_ns_ctl_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);\n\tstruct ctl_table tmp = *table;\n\tint ret, next;\n\n\tif (write && !checkpoint_restore_ns_capable(pid_ns->user_ns))\n\t\treturn -EPERM;\n\n\t \n\n\tnext = idr_get_cursor(&pid_ns->idr) - 1;\n\n\ttmp.data = &next;\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\tif (!ret && write)\n\t\tidr_set_cursor(&pid_ns->idr, next + 1);\n\n\treturn ret;\n}\n\nextern int pid_max;\nstatic struct ctl_table pid_ns_ctl_table[] = {\n\t{\n\t\t.procname = \"ns_last_pid\",\n\t\t.maxlen = sizeof(int),\n\t\t.mode = 0666,  \n\t\t.proc_handler = pid_ns_ctl_handler,\n\t\t.extra1 = SYSCTL_ZERO,\n\t\t.extra2 = &pid_max,\n\t},\n\t{ }\n};\n#endif\t \n\nint reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)\n{\n\tif (pid_ns == &init_pid_ns)\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tpid_ns->reboot = SIGHUP;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tpid_ns->reboot = SIGINT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tsend_sig(SIGKILL, pid_ns->child_reaper, 1);\n\tread_unlock(&tasklist_lock);\n\n\tdo_exit(0);\n\n\t \n\treturn 0;\n}\n\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}\n\nstatic struct ns_common *pidns_get(struct task_struct *task)\n{\n\tstruct pid_namespace *ns;\n\n\trcu_read_lock();\n\tns = task_active_pid_ns(task);\n\tif (ns)\n\t\tget_pid_ns(ns);\n\trcu_read_unlock();\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic struct ns_common *pidns_for_children_get(struct task_struct *task)\n{\n\tstruct pid_namespace *ns = NULL;\n\n\ttask_lock(task);\n\tif (task->nsproxy) {\n\t\tns = task->nsproxy->pid_ns_for_children;\n\t\tget_pid_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\tif (ns) {\n\t\tread_lock(&tasklist_lock);\n\t\tif (!ns->child_reaper) {\n\t\t\tput_pid_ns(ns);\n\t\t\tns = NULL;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic void pidns_put(struct ns_common *ns)\n{\n\tput_pid_ns(to_pid_ns(ns));\n}\n\nstatic int pidns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);\n\n\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (new->level < active->level)\n\t\treturn -EINVAL;\n\n\tancestor = new;\n\twhile (ancestor->level > active->level)\n\t\tancestor = ancestor->parent;\n\tif (ancestor != active)\n\t\treturn -EINVAL;\n\n\tput_pid_ns(nsproxy->pid_ns_for_children);\n\tnsproxy->pid_ns_for_children = get_pid_ns(new);\n\treturn 0;\n}\n\nstatic struct ns_common *pidns_get_parent(struct ns_common *ns)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *pid_ns, *p;\n\n\t \n\tpid_ns = p = to_pid_ns(ns)->parent;\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn ERR_PTR(-EPERM);\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn &get_pid_ns(pid_ns)->ns;\n}\n\nstatic struct user_namespace *pidns_owner(struct ns_common *ns)\n{\n\treturn to_pid_ns(ns)->user_ns;\n}\n\nconst struct proc_ns_operations pidns_operations = {\n\t.name\t\t= \"pid\",\n\t.type\t\t= CLONE_NEWPID,\n\t.get\t\t= pidns_get,\n\t.put\t\t= pidns_put,\n\t.install\t= pidns_install,\n\t.owner\t\t= pidns_owner,\n\t.get_parent\t= pidns_get_parent,\n};\n\nconst struct proc_ns_operations pidns_for_children_operations = {\n\t.name\t\t= \"pid_for_children\",\n\t.real_ns_name\t= \"pid\",\n\t.type\t\t= CLONE_NEWPID,\n\t.get\t\t= pidns_for_children_get,\n\t.put\t\t= pidns_put,\n\t.install\t= pidns_install,\n\t.owner\t\t= pidns_owner,\n\t.get_parent\t= pidns_get_parent,\n};\n\nstatic __init int pid_namespaces_init(void)\n{\n\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC | SLAB_ACCOUNT);\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tregister_sysctl_init(\"kernel\", pid_ns_ctl_table);\n#endif\n\n\tregister_pid_ns_sysctl_table_vm();\n\treturn 0;\n}\n\n__initcall(pid_namespaces_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}