{
  "module_name": "range.c",
  "hash_id": "98361353c9ef80ed5438078f3ab4c5865ca5edb83f567e3392a65b380dbc0c2a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/range.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/minmax.h>\n#include <linux/printk.h>\n#include <linux/sort.h>\n#include <linux/string.h>\n#include <linux/range.h>\n\nint add_range(struct range *range, int az, int nr_range, u64 start, u64 end)\n{\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t \n\tif (nr_range >= az)\n\t\treturn nr_range;\n\n\trange[nr_range].start = start;\n\trange[nr_range].end = end;\n\n\tnr_range++;\n\n\treturn nr_range;\n}\n\nint add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t \n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t \n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t \n\treturn add_range(range, az, nr_range, start, end);\n}\n\nvoid subtract_range(struct range *range, int az, u64 start, u64 end)\n{\n\tint i, j;\n\n\tif (start >= end)\n\t\treturn;\n\n\tfor (j = 0; j < az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >= range[j].end) {\n\t\t\trange[j].start = 0;\n\t\t\trange[j].end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start <= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start > range[j].start && end >= range[j].end &&\n\t\t    range[j].end > start) {\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start > range[j].start && end < range[j].end) {\n\t\t\t \n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->start < r2->start)\n\t\treturn -1;\n\tif (r1->start > r2->start)\n\t\treturn 1;\n\treturn 0;\n}\n\nint clean_sort_range(struct range *range, int az)\n{\n\tint i, j, k = az - 1, nr_range = az;\n\n\tfor (i = 0; i < k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j > i; j--) {\n\t\t\tif (range[j].end) {\n\t\t\t\tk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == i)\n\t\t\tbreak;\n\t\trange[i].start = range[k].start;\n\t\trange[i].end   = range[k].end;\n\t\trange[k].start = 0;\n\t\trange[k].end   = 0;\n\t\tk--;\n\t}\n\t \n\tfor (i = 0; i < az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n\n\treturn nr_range;\n}\n\nvoid sort_range(struct range *range, int nr_range)\n{\n\t \n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}