{
  "module_name": "scftorture.c",
  "hash_id": "cf34f9ff57b10ce9a61aa306503eab0c8cff8d7cea265feedac37be68556528d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/scftorture.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#define pr_fmt(fmt) fmt\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/completion.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/rcupdate.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/smp.h>\n#include <linux/stat.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/torture.h>\n#include <linux/types.h>\n\n#define SCFTORT_STRING \"scftorture\"\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\n#define VERBOSE_SCFTORTOUT(s, x...) \\\n\tdo { if (verbose) pr_alert(SCFTORT_FLAG s \"\\n\", ## x); } while (0)\n\n#define SCFTORTOUT_ERRSTRING(s, x...) pr_alert(SCFTORT_FLAG \"!!! \" s \"\\n\", ## x)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul E. McKenney <paulmck@kernel.org>\");\n\n\ntorture_param(int, holdoff, IS_BUILTIN(CONFIG_SCF_TORTURE_TEST) ? 10 : 0,\n\t      \"Holdoff time before test start (s)\");\ntorture_param(int, longwait, 0, \"Include ridiculously long waits? (seconds)\");\ntorture_param(int, nthreads, -1, \"# threads, defaults to -1 for all CPUs.\");\ntorture_param(int, onoff_holdoff, 0, \"Time after boot before CPU hotplugs (s)\");\ntorture_param(int, onoff_interval, 0, \"Time between CPU hotplugs (s), 0=disable\");\ntorture_param(int, shutdown_secs, 0, \"Shutdown time (ms), <= zero to disable.\");\ntorture_param(int, stat_interval, 60, \"Number of seconds between stats printk()s.\");\ntorture_param(int, stutter, 5, \"Number of jiffies to run/halt test, 0=disable\");\ntorture_param(bool, use_cpus_read_lock, 0, \"Use cpus_read_lock() to exclude CPU hotplug.\");\ntorture_param(int, verbose, 0, \"Enable verbose debugging printk()s\");\ntorture_param(int, weight_resched, -1, \"Testing weight for resched_cpu() operations.\");\ntorture_param(int, weight_single, -1, \"Testing weight for single-CPU no-wait operations.\");\ntorture_param(int, weight_single_rpc, -1, \"Testing weight for single-CPU RPC operations.\");\ntorture_param(int, weight_single_wait, -1, \"Testing weight for single-CPU operations.\");\ntorture_param(int, weight_many, -1, \"Testing weight for multi-CPU no-wait operations.\");\ntorture_param(int, weight_many_wait, -1, \"Testing weight for multi-CPU operations.\");\ntorture_param(int, weight_all, -1, \"Testing weight for all-CPU no-wait operations.\");\ntorture_param(int, weight_all_wait, -1, \"Testing weight for all-CPU operations.\");\n\nchar *torture_type = \"\";\n\n#ifdef MODULE\n# define SCFTORT_SHUTDOWN 0\n#else\n# define SCFTORT_SHUTDOWN 1\n#endif\n\ntorture_param(bool, shutdown, SCFTORT_SHUTDOWN, \"Shutdown at end of torture test.\");\n\nstruct scf_statistics {\n\tstruct task_struct *task;\n\tint cpu;\n\tlong long n_resched;\n\tlong long n_single;\n\tlong long n_single_ofl;\n\tlong long n_single_rpc;\n\tlong long n_single_rpc_ofl;\n\tlong long n_single_wait;\n\tlong long n_single_wait_ofl;\n\tlong long n_many;\n\tlong long n_many_wait;\n\tlong long n_all;\n\tlong long n_all_wait;\n};\n\nstatic struct scf_statistics *scf_stats_p;\nstatic struct task_struct *scf_torture_stats_task;\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\n\n\n#define SCF_PRIM_RESCHED\t0\n#define SCF_PRIM_SINGLE\t\t1\n#define SCF_PRIM_SINGLE_RPC\t2\n#define SCF_PRIM_MANY\t\t3\n#define SCF_PRIM_ALL\t\t4\n#define SCF_NPRIMS\t\t8 \n\t\t\t\t  \n\t\t\t\t  \n\nstatic char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};\n\nstruct scf_selector {\n\tunsigned long scfs_weight;\n\tint scfs_prim;\n\tbool scfs_wait;\n};\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\n\nstruct scf_check {\n\tbool scfc_in;\n\tbool scfc_out;\n\tint scfc_cpu; \n\tbool scfc_wait;\n\tbool scfc_rpc;\n\tstruct completion scfc_completion;\n};\n\n\nstatic atomic_t n_started;\nstatic atomic_t n_errs;\nstatic atomic_t n_mb_in_errs;\nstatic atomic_t n_mb_out_errs;\nstatic atomic_t n_alloc_errs;\nstatic bool scfdone;\nstatic char *bangstr = \"\";\n\nstatic DEFINE_TORTURE_RANDOM_PERCPU(scf_torture_rand);\n\nextern void resched_cpu(int cpu); \n\n\nstatic void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) ||\n\t    (!IS_ENABLED(CONFIG_KASAN) && atomic_read(&n_alloc_errs)))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}\n\n\n\nstatic int\nscf_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"scf_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tscf_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"scf_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"scf_torture_stats\");\n\treturn 0;\n}\n\n\nstatic void scf_sel_add(unsigned long weight, int prim, bool wait)\n{\n\tstruct scf_selector *scfsp = &scf_sel_array[scf_sel_array_len];\n\n\t\n\t\n\t\n\tif (!weight ||\n\t    WARN_ON_ONCE(scf_sel_array_len >= ARRAY_SIZE(scf_sel_array)) ||\n\t    WARN_ON_ONCE(0 - 100000 * weight <= 100000 * scf_sel_totweight) ||\n\t    WARN_ON_ONCE(prim >= ARRAY_SIZE(scf_prim_name)))\n\t\treturn;\n\tscf_sel_totweight += weight;\n\tscfsp->scfs_weight = scf_sel_totweight;\n\tscfsp->scfs_prim = prim;\n\tscfsp->scfs_wait = wait;\n\tscf_sel_array_len++;\n}\n\n\nstatic void scf_sel_dump(void)\n{\n\tint i;\n\tunsigned long oldw = 0;\n\tstruct scf_selector *scfsp;\n\tunsigned long w;\n\n\tfor (i = 0; i < scf_sel_array_len; i++) {\n\t\tscfsp = &scf_sel_array[i];\n\t\tw = (scfsp->scfs_weight - oldw) * 100000 / scf_sel_totweight;\n\t\tpr_info(\"%s: %3lu.%03lu %s(%s)\\n\", __func__, w / 1000, w % 1000,\n\t\t\tscf_prim_name[scfsp->scfs_prim],\n\t\t\tscfsp->scfs_wait ? \"wait\" : \"nowait\");\n\t\toldw = scfsp->scfs_weight;\n\t}\n}\n\n\nstatic struct scf_selector *scf_sel_rand(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long w = torture_random(trsp) % (scf_sel_totweight + 1);\n\n\tfor (i = 0; i < scf_sel_array_len; i++)\n\t\tif (scf_sel_array[i].scfs_weight >= w)\n\t\t\treturn &scf_sel_array[i];\n\tWARN_ON_ONCE(1);\n\treturn &scf_sel_array[0];\n}\n\n\n\n\nstatic void scf_handler(void *scfc_in)\n{\n\tint i;\n\tint j;\n\tunsigned long r = torture_random(this_cpu_ptr(&scf_torture_rand));\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp)) {\n\t\tWRITE_ONCE(scfcp->scfc_out, false); \n\t\tif (WARN_ON_ONCE(unlikely(!READ_ONCE(scfcp->scfc_in))))\n\t\t\tatomic_inc(&n_mb_in_errs);\n\t}\n\tthis_cpu_inc(scf_invoked_count);\n\tif (longwait <= 0) {\n\t\tif (!(r & 0xffc0)) {\n\t\t\tudelay(r & 0x3f);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (r & 0xfff)\n\t\tgoto out;\n\tr = (r >> 12);\n\tif (longwait <= 0) {\n\t\tudelay((r & 0xff) + 1);\n\t\tgoto out;\n\t}\n\tr = r % longwait + 1;\n\tfor (i = 0; i < r; i++) {\n\t\tfor (j = 0; j < 1000; j++) {\n\t\t\tudelay(1000);\n\t\t\tcpu_relax();\n\t\t}\n\t}\nout:\n\tif (unlikely(!scfcp))\n\t\treturn;\n\tif (scfcp->scfc_wait) {\n\t\tWRITE_ONCE(scfcp->scfc_out, true);\n\t\tif (scfcp->scfc_rpc)\n\t\t\tcomplete(&scfcp->scfc_completion);\n\t} else {\n\t\tkfree(scfcp);\n\t}\n}\n\n\nstatic void scf_handler_1(void *scfc_in)\n{\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp) && WARN_ONCE(smp_processor_id() != scfcp->scfc_cpu, \"%s: Wanted CPU %d got CPU %d\\n\", __func__, scfcp->scfc_cpu, smp_processor_id())) {\n\t\tatomic_inc(&n_errs);\n\t}\n\tscf_handler(scfcp);\n}\n\n\nstatic void scftorture_invoke_one(struct scf_statistics *scfp, struct torture_random_state *trsp)\n{\n\tbool allocfail = false;\n\tuintptr_t cpu;\n\tint ret = 0;\n\tstruct scf_check *scfcp = NULL;\n\tstruct scf_selector *scfsp = scf_sel_rand(trsp);\n\n\tif (use_cpus_read_lock)\n\t\tcpus_read_lock();\n\telse\n\t\tpreempt_disable();\n\tif (scfsp->scfs_prim == SCF_PRIM_SINGLE || scfsp->scfs_wait) {\n\t\tscfcp = kmalloc(sizeof(*scfcp), GFP_ATOMIC);\n\t\tif (!scfcp) {\n\t\t\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_KASAN));\n\t\t\tatomic_inc(&n_alloc_errs);\n\t\t\tallocfail = true;\n\t\t} else {\n\t\t\tscfcp->scfc_cpu = -1;\n\t\t\tscfcp->scfc_wait = scfsp->scfs_wait;\n\t\t\tscfcp->scfc_out = false;\n\t\t\tscfcp->scfc_rpc = false;\n\t\t}\n\t}\n\tswitch (scfsp->scfs_prim) {\n\tcase SCF_PRIM_RESCHED:\n\t\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST)) {\n\t\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\t\tscfp->n_resched++;\n\t\t\tresched_cpu(cpu);\n\t\t\tthis_cpu_inc(scf_invoked_count);\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE:\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_single_wait++;\n\t\telse\n\t\t\tscfp->n_single++;\n\t\tif (scfcp) {\n\t\t\tscfcp->scfc_cpu = cpu;\n\t\t\tbarrier(); \n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, scfsp->scfs_wait);\n\t\tif (ret) {\n\t\t\tif (scfsp->scfs_wait)\n\t\t\t\tscfp->n_single_wait_ofl++;\n\t\t\telse\n\t\t\t\tscfp->n_single_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE_RPC:\n\t\tif (!scfcp)\n\t\t\tbreak;\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tscfp->n_single_rpc++;\n\t\tscfcp->scfc_cpu = cpu;\n\t\tscfcp->scfc_wait = true;\n\t\tinit_completion(&scfcp->scfc_completion);\n\t\tscfcp->scfc_rpc = true;\n\t\tbarrier(); \n\t\tscfcp->scfc_in = true;\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, 0);\n\t\tif (!ret) {\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_unlock();\n\t\t\telse\n\t\t\t\tpreempt_enable();\n\t\t\twait_for_completion(&scfcp->scfc_completion);\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_lock();\n\t\t\telse\n\t\t\t\tpreempt_disable();\n\t\t} else {\n\t\t\tscfp->n_single_rpc_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_MANY:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_many_wait++;\n\t\telse\n\t\t\tscfp->n_many++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); \n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function_many(cpu_online_mask, scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tcase SCF_PRIM_ALL:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_all_wait++;\n\t\telse\n\t\t\tscfp->n_all++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); \n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function(scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tif (scfcp)\n\t\t\tscfcp->scfc_out = true;\n\t}\n\tif (scfcp && scfsp->scfs_wait) {\n\t\tif (WARN_ON_ONCE((num_online_cpus() > 1 || scfsp->scfs_prim == SCF_PRIM_SINGLE) &&\n\t\t\t\t !scfcp->scfc_out)) {\n\t\t\tpr_warn(\"%s: Memory-ordering failure, scfs_prim: %d.\\n\", __func__, scfsp->scfs_prim);\n\t\t\tatomic_inc(&n_mb_out_errs); \n\t\t} else {\n\t\t\tkfree(scfcp);\n\t\t}\n\t\tbarrier(); \n\t}\n\tif (use_cpus_read_lock)\n\t\tcpus_read_unlock();\n\telse\n\t\tpreempt_enable();\n\tif (allocfail)\n\t\tschedule_timeout_idle((1 + longwait) * HZ);  \n\telse if (!(torture_random(trsp) & 0xfff))\n\t\tschedule_timeout_uninterruptible(1);\n}\n\n\n\nstatic int scftorture_invoker(void *arg)\n{\n\tint cpu;\n\tint curcpu;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct scf_statistics *scfp = (struct scf_statistics *)arg;\n\tbool was_offline = false;\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d: task started\", scfp->cpu);\n\tcpu = scfp->cpu % nr_cpu_ids;\n\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(cpu)));\n\tset_user_nice(current, MAX_NICE);\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d: Waiting for all SCF torturers from cpu %d\", scfp->cpu, raw_smp_processor_id());\n\n\t\n\tcurcpu = raw_smp_processor_id();\n\tWARN_ONCE(curcpu != scfp->cpu % nr_cpu_ids,\n\t\t  \"%s: Wanted CPU %d, running on %d, nr_cpu_ids = %d\\n\",\n\t\t  __func__, scfp->cpu, curcpu, nr_cpu_ids);\n\n\tif (!atomic_dec_return(&n_started))\n\t\twhile (atomic_read_acquire(&n_started)) {\n\t\t\tif (torture_must_stop()) {\n\t\t\t\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d ended before starting\", scfp->cpu);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d started\", scfp->cpu);\n\n\tdo {\n\t\tscftorture_invoke_one(scfp, &rand);\n\t\twhile (cpu_is_offline(cpu) && !torture_must_stop()) {\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\t\twas_offline = true;\n\t\t}\n\t\tif (was_offline) {\n\t\t\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n\t\t\twas_offline = false;\n\t\t}\n\t\tcond_resched();\n\t\tstutter_wait(\"scftorture_invoker\");\n\t} while (!torture_must_stop());\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d ended\", scfp->cpu);\nend:\n\ttorture_kthread_stopping(\"scftorture_invoker\");\n\treturn 0;\n}\n\nstatic void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}\n\nstatic void scf_cleanup_handler(void *unused)\n{\n}\n\nstatic void scf_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tWRITE_ONCE(scfdone, true);\n\tif (nthreads && scf_stats_p)\n\t\tfor (i = 0; i < nthreads; i++)\n\t\t\ttorture_stop_kthread(\"scftorture_invoker\", scf_stats_p[i].task);\n\telse\n\t\tgoto end;\n\tsmp_call_function(scf_cleanup_handler, NULL, 0);\n\ttorture_stop_kthread(scf_torture_stats, scf_torture_stats_task);\n\tscf_torture_stats_print();  \n\tkfree(scf_stats_p);  \n\tscf_stats_p = NULL;\n\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) || atomic_read(&n_mb_out_errs))\n\t\tscftorture_print_module_parms(\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tscftorture_print_module_parms(\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tscftorture_print_module_parms(\"End of test: SUCCESS\");\n\nend:\n\ttorture_cleanup_end();\n}\n\nstatic int __init scf_torture_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tunsigned long weight_resched1 = weight_resched;\n\tunsigned long weight_single1 = weight_single;\n\tunsigned long weight_single_rpc1 = weight_single_rpc;\n\tunsigned long weight_single_wait1 = weight_single_wait;\n\tunsigned long weight_many1 = weight_many;\n\tunsigned long weight_many_wait1 = weight_many_wait;\n\tunsigned long weight_all1 = weight_all;\n\tunsigned long weight_all_wait1 = weight_all_wait;\n\n\tif (!torture_init_begin(SCFTORT_STRING, verbose))\n\t\treturn -EBUSY;\n\n\tscftorture_print_module_parms(\"Start of test\");\n\n\tif (weight_resched <= 0 &&\n\t    weight_single <= 0 && weight_single_rpc <= 0 && weight_single_wait <= 0 &&\n\t    weight_many <= 0 && weight_many_wait <= 0 &&\n\t    weight_all <= 0 && weight_all_wait <= 0) {\n\t\tweight_resched1 = weight_resched == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single1 = weight_single == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single_rpc1 = weight_single_rpc == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single_wait1 = weight_single_wait == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_many1 = weight_many == 0 ? 0 : 2;\n\t\tweight_many_wait1 = weight_many_wait == 0 ? 0 : 2;\n\t\tweight_all1 = weight_all == 0 ? 0 : 1;\n\t\tweight_all_wait1 = weight_all_wait == 0 ? 0 : 1;\n\t} else {\n\t\tif (weight_resched == -1)\n\t\t\tweight_resched1 = 0;\n\t\tif (weight_single == -1)\n\t\t\tweight_single1 = 0;\n\t\tif (weight_single_rpc == -1)\n\t\t\tweight_single_rpc1 = 0;\n\t\tif (weight_single_wait == -1)\n\t\t\tweight_single_wait1 = 0;\n\t\tif (weight_many == -1)\n\t\t\tweight_many1 = 0;\n\t\tif (weight_many_wait == -1)\n\t\t\tweight_many_wait1 = 0;\n\t\tif (weight_all == -1)\n\t\t\tweight_all1 = 0;\n\t\tif (weight_all_wait == -1)\n\t\t\tweight_all_wait1 = 0;\n\t}\n\tif (weight_resched1 == 0 && weight_single1 == 0 && weight_single_rpc1 == 0 &&\n\t    weight_single_wait1 == 0 && weight_many1 == 0 && weight_many_wait1 == 0 &&\n\t    weight_all1 == 0 && weight_all_wait1 == 0) {\n\t\tSCFTORTOUT_ERRSTRING(\"all zero weights makes no sense\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST))\n\t\tscf_sel_add(weight_resched1, SCF_PRIM_RESCHED, false);\n\telse if (weight_resched1)\n\t\tSCFTORTOUT_ERRSTRING(\"built as module, weight_resched ignored\");\n\tscf_sel_add(weight_single1, SCF_PRIM_SINGLE, false);\n\tscf_sel_add(weight_single_rpc1, SCF_PRIM_SINGLE_RPC, true);\n\tscf_sel_add(weight_single_wait1, SCF_PRIM_SINGLE, true);\n\tscf_sel_add(weight_many1, SCF_PRIM_MANY, false);\n\tscf_sel_add(weight_many_wait1, SCF_PRIM_MANY, true);\n\tscf_sel_add(weight_all1, SCF_PRIM_ALL, false);\n\tscf_sel_add(weight_all_wait1, SCF_PRIM_ALL, true);\n\tscf_sel_dump();\n\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval, NULL);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs, scf_torture_cleanup);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter, stutter);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\t\n\tif (nthreads < 0)\n\t\tnthreads = num_online_cpus();\n\tscf_stats_p = kcalloc(nthreads, sizeof(scf_stats_p[0]), GFP_KERNEL);\n\tif (!scf_stats_p) {\n\t\tSCFTORTOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tVERBOSE_SCFTORTOUT(\"Starting %d smp_call_function() threads\", nthreads);\n\n\tatomic_set(&n_started, nthreads);\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscf_stats_p[i].cpu = i;\n\t\tfirsterr = torture_create_kthread(scftorture_invoker, (void *)&scf_stats_p[i],\n\t\t\t\t\t\t  scf_stats_p[i].task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(scf_torture_stats, NULL, scf_torture_stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tscf_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_SCF_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}\n\nmodule_init(scf_torture_init);\nmodule_exit(scf_torture_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}