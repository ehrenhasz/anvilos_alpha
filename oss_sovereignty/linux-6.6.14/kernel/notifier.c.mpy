{
  "module_name": "notifier.c",
  "hash_id": "eeb61d58ea112a7a75dd79b1eb974fd9641a82d6c21b086941588b87cedbbd98",
  "original_prompt": "Ingested from linux-6.6.14/kernel/notifier.c",
  "human_readable_source": "\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/notifier.h>\n#include <linux/rcupdate.h>\n#include <linux/vmalloc.h>\n#include <linux/reboot.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/notifier.h>\n\n \nBLOCKING_NOTIFIER_HEAD(reboot_notifier_list);\n\n \n\nstatic int notifier_chain_register(struct notifier_block **nl,\n\t\t\t\t   struct notifier_block *n,\n\t\t\t\t   bool unique_priority)\n{\n\twhile ((*nl) != NULL) {\n\t\tif (unlikely((*nl) == n)) {\n\t\t\tWARN(1, \"notifier callback %ps already registered\",\n\t\t\t     n->notifier_call);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (n->priority > (*nl)->priority)\n\t\t\tbreak;\n\t\tif (n->priority == (*nl)->priority && unique_priority)\n\t\t\treturn -EBUSY;\n\t\tnl = &((*nl)->next);\n\t}\n\tn->next = *nl;\n\trcu_assign_pointer(*nl, n);\n\ttrace_notifier_register((void *)n->notifier_call);\n\treturn 0;\n}\n\nstatic int notifier_chain_unregister(struct notifier_block **nl,\n\t\tstruct notifier_block *n)\n{\n\twhile ((*nl) != NULL) {\n\t\tif ((*nl) == n) {\n\t\t\trcu_assign_pointer(*nl, n->next);\n\t\t\ttrace_notifier_unregister((void *)n->notifier_call);\n\t\t\treturn 0;\n\t\t}\n\t\tnl = &((*nl)->next);\n\t}\n\treturn -ENOENT;\n}\n\n \nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\ttrace_notifier_run((void *)nb->notifier_call);\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}\nNOKPROBE_SYMBOL(notifier_call_chain);\n\n \nstatic int notifier_call_chain_robust(struct notifier_block **nl,\n\t\t\t\t     unsigned long val_up, unsigned long val_down,\n\t\t\t\t     void *v)\n{\n\tint ret, nr = 0;\n\n\tret = notifier_call_chain(nl, val_up, v, -1, &nr);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\tnotifier_call_chain(nl, val_down, v, nr-1, NULL);\n\n\treturn ret;\n}\n\n \n\n \nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n, false);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atomic_notifier_chain_register);\n\n \nint atomic_notifier_chain_register_unique_prio(struct atomic_notifier_head *nh,\n\t\t\t\t\t       struct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n, true);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atomic_notifier_chain_register_unique_prio);\n\n \nint atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atomic_notifier_chain_unregister);\n\n \nint atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atomic_notifier_call_chain);\nNOKPROBE_SYMBOL(atomic_notifier_call_chain);\n\n \nbool atomic_notifier_call_chain_is_empty(struct atomic_notifier_head *nh)\n{\n\treturn !rcu_access_pointer(nh->head);\n}\n\n \n\nstatic int __blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\t\t\t\t      struct notifier_block *n,\n\t\t\t\t\t      bool unique_priority)\n{\n\tint ret;\n\n\t \n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n, unique_priority);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n, unique_priority);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}\n\n \nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn __blocking_notifier_chain_register(nh, n, false);\n}\nEXPORT_SYMBOL_GPL(blocking_notifier_chain_register);\n\n \nint blocking_notifier_chain_register_unique_prio(struct blocking_notifier_head *nh,\n\t\t\t\t\t\t struct notifier_block *n)\n{\n\treturn __blocking_notifier_chain_register(nh, n, true);\n}\nEXPORT_SYMBOL_GPL(blocking_notifier_chain_register_unique_prio);\n\n \nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t \n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(blocking_notifier_chain_unregister);\n\nint blocking_notifier_call_chain_robust(struct blocking_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t \n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(blocking_notifier_call_chain_robust);\n\n \nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t \n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(blocking_notifier_call_chain);\n\n \n\n \nint raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n, false);\n}\nEXPORT_SYMBOL_GPL(raw_notifier_chain_register);\n\n \nint raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}\nEXPORT_SYMBOL_GPL(raw_notifier_chain_unregister);\n\nint raw_notifier_call_chain_robust(struct raw_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n}\nEXPORT_SYMBOL_GPL(raw_notifier_call_chain_robust);\n\n \nint raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn notifier_call_chain(&nh->head, val, v, -1, NULL);\n}\nEXPORT_SYMBOL_GPL(raw_notifier_call_chain);\n\n \n\n \nint srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t \n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n, false);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n, false);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(srcu_notifier_chain_register);\n\n \nint srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t \n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(srcu_notifier_chain_unregister);\n\n \nint srcu_notifier_call_chain(struct srcu_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret;\n\tint idx;\n\n\tidx = srcu_read_lock(&nh->srcu);\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\tsrcu_read_unlock(&nh->srcu, idx);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(srcu_notifier_call_chain);\n\n \nvoid srcu_init_notifier_head(struct srcu_notifier_head *nh)\n{\n\tmutex_init(&nh->mutex);\n\tif (init_srcu_struct(&nh->srcu) < 0)\n\t\tBUG();\n\tnh->head = NULL;\n}\nEXPORT_SYMBOL_GPL(srcu_init_notifier_head);\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint notrace notify_die(enum die_val val, const char *str,\n\t       struct pt_regs *regs, long err, int trap, int sig)\n{\n\tstruct die_args args = {\n\t\t.regs\t= regs,\n\t\t.str\t= str,\n\t\t.err\t= err,\n\t\t.trapnr\t= trap,\n\t\t.signr\t= sig,\n\n\t};\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t   \"notify_die called but RCU thinks we're quiescent\");\n\treturn atomic_notifier_call_chain(&die_chain, val, &args);\n}\nNOKPROBE_SYMBOL(notify_die);\n\nint register_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&die_chain, nb);\n}\nEXPORT_SYMBOL_GPL(register_die_notifier);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_die_notifier);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}