{
  "module_name": "up.c",
  "hash_id": "82017a1d50291a62afde14eb0ea31d1ef0128c6935b8d4675db54111b2ffb8f7",
  "original_prompt": "Ingested from linux-6.6.14/kernel/up.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n#include <linux/hypervisor.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(smp_call_function_single);\n\nint smp_call_function_single_async(int cpu, struct __call_single_data *csd)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcsd->func(csd->info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(smp_call_function_single_async);\n\n \nvoid on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,\n\t\t\t   void *info, bool wait, const struct cpumask *mask)\n{\n\tunsigned long flags;\n\n\tpreempt_disable();\n\tif ((!cond_func || cond_func(0, info)) && cpumask_test_cpu(0, mask)) {\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(on_each_cpu_cond_mask);\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(smp_call_on_cpu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}