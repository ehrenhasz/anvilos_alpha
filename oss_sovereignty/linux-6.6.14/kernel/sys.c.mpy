{
  "module_name": "sys.c",
  "hash_id": "6057f9bd700f7c692ee30bcbdbc3881bda97c91802501c7ef5d3b3b55cd9a940",
  "original_prompt": "Ingested from linux-6.6.14/kernel/sys.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/mm_inline.h>\n#include <linux/utsname.h>\n#include <linux/mman.h>\n#include <linux/reboot.h>\n#include <linux/prctl.h>\n#include <linux/highuid.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/ksm.h>\n#include <linux/perf_event.h>\n#include <linux/resource.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/key.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/security.h>\n#include <linux/random.h>\n#include <linux/suspend.h>\n#include <linux/tty.h>\n#include <linux/signal.h>\n#include <linux/cn_proc.h>\n#include <linux/getcpu.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/seccomp.h>\n#include <linux/cpu.h>\n#include <linux/personality.h>\n#include <linux/ptrace.h>\n#include <linux/fs_struct.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/syscore_ops.h>\n#include <linux/version.h>\n#include <linux/ctype.h>\n#include <linux/syscall_user_dispatch.h>\n\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/time_namespace.h>\n#include <linux/binfmts.h>\n\n#include <linux/sched.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task.h>\n#include <linux/sched/cputime.h>\n#include <linux/rcupdate.h>\n#include <linux/uidgid.h>\n#include <linux/cred.h>\n\n#include <linux/nospec.h>\n\n#include <linux/kmsg_dump.h>\n \n#include <generated/utsrelease.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/unistd.h>\n\n#include \"uid16.h\"\n\n#ifndef SET_UNALIGN_CTL\n# define SET_UNALIGN_CTL(a, b)\t(-EINVAL)\n#endif\n#ifndef GET_UNALIGN_CTL\n# define GET_UNALIGN_CTL(a, b)\t(-EINVAL)\n#endif\n#ifndef SET_FPEMU_CTL\n# define SET_FPEMU_CTL(a, b)\t(-EINVAL)\n#endif\n#ifndef GET_FPEMU_CTL\n# define GET_FPEMU_CTL(a, b)\t(-EINVAL)\n#endif\n#ifndef SET_FPEXC_CTL\n# define SET_FPEXC_CTL(a, b)\t(-EINVAL)\n#endif\n#ifndef GET_FPEXC_CTL\n# define GET_FPEXC_CTL(a, b)\t(-EINVAL)\n#endif\n#ifndef GET_ENDIAN\n# define GET_ENDIAN(a, b)\t(-EINVAL)\n#endif\n#ifndef SET_ENDIAN\n# define SET_ENDIAN(a, b)\t(-EINVAL)\n#endif\n#ifndef GET_TSC_CTL\n# define GET_TSC_CTL(a)\t\t(-EINVAL)\n#endif\n#ifndef SET_TSC_CTL\n# define SET_TSC_CTL(a)\t\t(-EINVAL)\n#endif\n#ifndef GET_FP_MODE\n# define GET_FP_MODE(a)\t\t(-EINVAL)\n#endif\n#ifndef SET_FP_MODE\n# define SET_FP_MODE(a,b)\t(-EINVAL)\n#endif\n#ifndef SVE_SET_VL\n# define SVE_SET_VL(a)\t\t(-EINVAL)\n#endif\n#ifndef SVE_GET_VL\n# define SVE_GET_VL()\t\t(-EINVAL)\n#endif\n#ifndef SME_SET_VL\n# define SME_SET_VL(a)\t\t(-EINVAL)\n#endif\n#ifndef SME_GET_VL\n# define SME_GET_VL()\t\t(-EINVAL)\n#endif\n#ifndef PAC_RESET_KEYS\n# define PAC_RESET_KEYS(a, b)\t(-EINVAL)\n#endif\n#ifndef PAC_SET_ENABLED_KEYS\n# define PAC_SET_ENABLED_KEYS(a, b, c)\t(-EINVAL)\n#endif\n#ifndef PAC_GET_ENABLED_KEYS\n# define PAC_GET_ENABLED_KEYS(a)\t(-EINVAL)\n#endif\n#ifndef SET_TAGGED_ADDR_CTRL\n# define SET_TAGGED_ADDR_CTRL(a)\t(-EINVAL)\n#endif\n#ifndef GET_TAGGED_ADDR_CTRL\n# define GET_TAGGED_ADDR_CTRL()\t\t(-EINVAL)\n#endif\n#ifndef RISCV_V_SET_CONTROL\n# define RISCV_V_SET_CONTROL(a)\t\t(-EINVAL)\n#endif\n#ifndef RISCV_V_GET_CONTROL\n# define RISCV_V_GET_CONTROL()\t\t(-EINVAL)\n#endif\n\n \n\nint overflowuid = DEFAULT_OVERFLOWUID;\nint overflowgid = DEFAULT_OVERFLOWGID;\n\nEXPORT_SYMBOL(overflowuid);\nEXPORT_SYMBOL(overflowgid);\n\n \n\nint fs_overflowuid = DEFAULT_FS_OVERFLOWUID;\nint fs_overflowgid = DEFAULT_FS_OVERFLOWGID;\n\nEXPORT_SYMBOL(fs_overflowuid);\nEXPORT_SYMBOL(fs_overflowgid);\n\n \nstatic bool set_one_prio_perm(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred = __task_cred(p);\n\n\tif (uid_eq(pcred->uid,  cred->euid) ||\n\t    uid_eq(pcred->euid, cred->euid))\n\t\treturn true;\n\tif (ns_capable(pcred->user_ns, CAP_SYS_NICE))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic int set_one_prio(struct task_struct *p, int niceval, int error)\n{\n\tint no_nice;\n\n\tif (!set_one_prio_perm(p)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\tif (niceval < task_nice(p) && !can_nice(p, niceval)) {\n\t\terror = -EACCES;\n\t\tgoto out;\n\t}\n\tno_nice = security_task_setnice(p, niceval);\n\tif (no_nice) {\n\t\terror = no_nice;\n\t\tgoto out;\n\t}\n\tif (error == -ESRCH)\n\t\terror = 0;\n\tset_user_nice(p, niceval);\nout:\n\treturn error;\n}\n\nSYSCALL_DEFINE3(setpriority, int, which, int, who, int, niceval)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tint error = -EINVAL;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which > PRIO_USER || which < PRIO_PROCESS)\n\t\tgoto out;\n\n\t \n\terror = -ESRCH;\n\tif (niceval < MIN_NICE)\n\t\tniceval = MIN_NICE;\n\tif (niceval > MAX_NICE)\n\t\tniceval = MAX_NICE;\n\n\trcu_read_lock();\n\tswitch (which) {\n\tcase PRIO_PROCESS:\n\t\tif (who)\n\t\t\tp = find_task_by_vpid(who);\n\t\telse\n\t\t\tp = current;\n\t\tif (p)\n\t\t\terror = set_one_prio(p, niceval, error);\n\t\tbreak;\n\tcase PRIO_PGRP:\n\t\tif (who)\n\t\t\tpgrp = find_vpid(who);\n\t\telse\n\t\t\tpgrp = task_pgrp(current);\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\terror = set_one_prio(p, niceval, error);\n\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\tread_unlock(&tasklist_lock);\n\t\tbreak;\n\tcase PRIO_USER:\n\t\tuid = make_kuid(cred->user_ns, who);\n\t\tuser = cred->user;\n\t\tif (!who)\n\t\t\tuid = cred->uid;\n\t\telse if (!uid_eq(uid, cred->uid)) {\n\t\t\tuser = find_user(uid);\n\t\t\tif (!user)\n\t\t\t\tgoto out_unlock;\t \n\t\t}\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (uid_eq(task_uid(p), uid) && task_pid_vnr(p))\n\t\t\t\terror = set_one_prio(p, niceval, error);\n\t\t}\n\t\tif (!uid_eq(uid, cred->uid))\n\t\t\tfree_uid(user);\t\t \n\t\tbreak;\n\t}\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn error;\n}\n\n \nSYSCALL_DEFINE2(getpriority, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tlong niceval, retval = -ESRCH;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which > PRIO_USER || which < PRIO_PROCESS)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tswitch (which) {\n\tcase PRIO_PROCESS:\n\t\tif (who)\n\t\t\tp = find_task_by_vpid(who);\n\t\telse\n\t\t\tp = current;\n\t\tif (p) {\n\t\t\tniceval = nice_to_rlimit(task_nice(p));\n\t\t\tif (niceval > retval)\n\t\t\t\tretval = niceval;\n\t\t}\n\t\tbreak;\n\tcase PRIO_PGRP:\n\t\tif (who)\n\t\t\tpgrp = find_vpid(who);\n\t\telse\n\t\t\tpgrp = task_pgrp(current);\n\t\tread_lock(&tasklist_lock);\n\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\tniceval = nice_to_rlimit(task_nice(p));\n\t\t\tif (niceval > retval)\n\t\t\t\tretval = niceval;\n\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\tread_unlock(&tasklist_lock);\n\t\tbreak;\n\tcase PRIO_USER:\n\t\tuid = make_kuid(cred->user_ns, who);\n\t\tuser = cred->user;\n\t\tif (!who)\n\t\t\tuid = cred->uid;\n\t\telse if (!uid_eq(uid, cred->uid)) {\n\t\t\tuser = find_user(uid);\n\t\t\tif (!user)\n\t\t\t\tgoto out_unlock;\t \n\t\t}\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (uid_eq(task_uid(p), uid) && task_pid_vnr(p)) {\n\t\t\t\tniceval = nice_to_rlimit(task_nice(p));\n\t\t\t\tif (niceval > retval)\n\t\t\t\t\tretval = niceval;\n\t\t\t}\n\t\t}\n\t\tif (!uid_eq(uid, cred->uid))\n\t\t\tfree_uid(user);\t\t \n\t\tbreak;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n \n#ifdef CONFIG_MULTIUSER\nlong __sys_setregid(gid_t rgid, gid_t egid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t krgid, kegid;\n\n\tkrgid = make_kgid(ns, rgid);\n\tkegid = make_kgid(ns, egid);\n\n\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))\n\t\treturn -EINVAL;\n\tif ((egid != (gid_t) -1) && !gid_valid(kegid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (rgid != (gid_t) -1) {\n\t\tif (gid_eq(old->gid, krgid) ||\n\t\t    gid_eq(old->egid, krgid) ||\n\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))\n\t\t\tnew->gid = krgid;\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (egid != (gid_t) -1) {\n\t\tif (gid_eq(old->gid, kegid) ||\n\t\t    gid_eq(old->egid, kegid) ||\n\t\t    gid_eq(old->sgid, kegid) ||\n\t\t    ns_capable_setid(old->user_ns, CAP_SETGID))\n\t\t\tnew->egid = kegid;\n\t\telse\n\t\t\tgoto error;\n\t}\n\n\tif (rgid != (gid_t) -1 ||\n\t    (egid != (gid_t) -1 && !gid_eq(kegid, old->gid)))\n\t\tnew->sgid = new->egid;\n\tnew->fsgid = new->egid;\n\n\tretval = security_task_fix_setgid(new, old, LSM_SETID_RE);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE2(setregid, gid_t, rgid, gid_t, egid)\n{\n\treturn __sys_setregid(rgid, egid);\n}\n\n \nlong __sys_setgid(gid_t gid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t kgid;\n\n\tkgid = make_kgid(ns, gid);\n\tif (!gid_valid(kgid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (ns_capable_setid(old->user_ns, CAP_SETGID))\n\t\tnew->gid = new->egid = new->sgid = new->fsgid = kgid;\n\telse if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))\n\t\tnew->egid = new->fsgid = kgid;\n\telse\n\t\tgoto error;\n\n\tretval = security_task_fix_setgid(new, old, LSM_SETID_ID);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE1(setgid, gid_t, gid)\n{\n\treturn __sys_setgid(gid);\n}\n\n \nstatic int set_user(struct cred *new)\n{\n\tstruct user_struct *new_user;\n\n\tnew_user = alloc_uid(new->uid);\n\tif (!new_user)\n\t\treturn -EAGAIN;\n\n\tfree_uid(new->user);\n\tnew->user = new_user;\n\treturn 0;\n}\n\nstatic void flag_nproc_exceeded(struct cred *new)\n{\n\tif (new->ucounts == current_ucounts())\n\t\treturn;\n\n\t \n\tif (is_rlimit_overlimit(new->ucounts, UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC)) &&\n\t\t\tnew->user != INIT_USER)\n\t\tcurrent->flags |= PF_NPROC_EXCEEDED;\n\telse\n\t\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n}\n\n \nlong __sys_setreuid(uid_t ruid, uid_t euid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -EINVAL;\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (ruid != (uid_t) -1) {\n\t\tnew->uid = kruid;\n\t\tif (!uid_eq(old->uid, kruid) &&\n\t\t    !uid_eq(old->euid, kruid) &&\n\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))\n\t\t\tgoto error;\n\t}\n\n\tif (euid != (uid_t) -1) {\n\t\tnew->euid = keuid;\n\t\tif (!uid_eq(old->uid, keuid) &&\n\t\t    !uid_eq(old->euid, keuid) &&\n\t\t    !uid_eq(old->suid, keuid) &&\n\t\t    !ns_capable_setid(old->user_ns, CAP_SETUID))\n\t\t\tgoto error;\n\t}\n\n\tif (!uid_eq(new->uid, old->uid)) {\n\t\tretval = set_user(new);\n\t\tif (retval < 0)\n\t\t\tgoto error;\n\t}\n\tif (ruid != (uid_t) -1 ||\n\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->uid)))\n\t\tnew->suid = new->euid;\n\tnew->fsuid = new->euid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_RE);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = set_cred_ucounts(new);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tflag_nproc_exceeded(new);\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE2(setreuid, uid_t, ruid, uid_t, euid)\n{\n\treturn __sys_setreuid(ruid, euid);\n}\n\n \nlong __sys_setuid(uid_t uid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kuid;\n\n\tkuid = make_kuid(ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\tretval = -EPERM;\n\tif (ns_capable_setid(old->user_ns, CAP_SETUID)) {\n\t\tnew->suid = new->uid = kuid;\n\t\tif (!uid_eq(kuid, old->uid)) {\n\t\t\tretval = set_user(new);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t} else if (!uid_eq(kuid, old->uid) && !uid_eq(kuid, new->suid)) {\n\t\tgoto error;\n\t}\n\n\tnew->fsuid = new->euid = kuid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_ID);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = set_cred_ucounts(new);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tflag_nproc_exceeded(new);\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE1(setuid, uid_t, uid)\n{\n\treturn __sys_setuid(uid);\n}\n\n\n \nlong __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid, ksuid;\n\tbool ruid_new, euid_new, suid_new;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\tksuid = make_kuid(ns, suid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -EINVAL;\n\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -EINVAL;\n\n\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))\n\t\treturn -EINVAL;\n\n\told = current_cred();\n\n\t \n\tif ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&\n\t    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&\n\t\t\t\t    uid_eq(keuid, old->fsuid))) &&\n\t    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))\n\t\treturn 0;\n\n\truid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&\n\t\t   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);\n\teuid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&\n\t\t   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);\n\tsuid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&\n\t\t   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);\n\tif ((ruid_new || euid_new || suid_new) &&\n\t    !ns_capable_setid(old->user_ns, CAP_SETUID))\n\t\treturn -EPERM;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (ruid != (uid_t) -1) {\n\t\tnew->uid = kruid;\n\t\tif (!uid_eq(kruid, old->uid)) {\n\t\t\tretval = set_user(new);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (euid != (uid_t) -1)\n\t\tnew->euid = keuid;\n\tif (suid != (uid_t) -1)\n\t\tnew->suid = ksuid;\n\tnew->fsuid = new->euid;\n\n\tretval = security_task_fix_setuid(new, old, LSM_SETID_RES);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = set_cred_ucounts(new);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tflag_nproc_exceeded(new);\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)\n{\n\treturn __sys_setresuid(ruid, euid, suid);\n}\n\nSYSCALL_DEFINE3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tuid_t ruid, euid, suid;\n\n\truid = from_kuid_munged(cred->user_ns, cred->uid);\n\teuid = from_kuid_munged(cred->user_ns, cred->euid);\n\tsuid = from_kuid_munged(cred->user_ns, cred->suid);\n\n\tretval = put_user(ruid, ruidp);\n\tif (!retval) {\n\t\tretval = put_user(euid, euidp);\n\t\tif (!retval)\n\t\t\treturn put_user(suid, suidp);\n\t}\n\treturn retval;\n}\n\n \nlong __sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkgid_t krgid, kegid, ksgid;\n\tbool rgid_new, egid_new, sgid_new;\n\n\tkrgid = make_kgid(ns, rgid);\n\tkegid = make_kgid(ns, egid);\n\tksgid = make_kgid(ns, sgid);\n\n\tif ((rgid != (gid_t) -1) && !gid_valid(krgid))\n\t\treturn -EINVAL;\n\tif ((egid != (gid_t) -1) && !gid_valid(kegid))\n\t\treturn -EINVAL;\n\tif ((sgid != (gid_t) -1) && !gid_valid(ksgid))\n\t\treturn -EINVAL;\n\n\told = current_cred();\n\n\t \n\tif ((rgid == (gid_t) -1 || gid_eq(krgid, old->gid)) &&\n\t    (egid == (gid_t) -1 || (gid_eq(kegid, old->egid) &&\n\t\t\t\t    gid_eq(kegid, old->fsgid))) &&\n\t    (sgid == (gid_t) -1 || gid_eq(ksgid, old->sgid)))\n\t\treturn 0;\n\n\trgid_new = rgid != (gid_t) -1        && !gid_eq(krgid, old->gid) &&\n\t\t   !gid_eq(krgid, old->egid) && !gid_eq(krgid, old->sgid);\n\tegid_new = egid != (gid_t) -1        && !gid_eq(kegid, old->gid) &&\n\t\t   !gid_eq(kegid, old->egid) && !gid_eq(kegid, old->sgid);\n\tsgid_new = sgid != (gid_t) -1        && !gid_eq(ksgid, old->gid) &&\n\t\t   !gid_eq(ksgid, old->egid) && !gid_eq(ksgid, old->sgid);\n\tif ((rgid_new || egid_new || sgid_new) &&\n\t    !ns_capable_setid(old->user_ns, CAP_SETGID))\n\t\treturn -EPERM;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (rgid != (gid_t) -1)\n\t\tnew->gid = krgid;\n\tif (egid != (gid_t) -1)\n\t\tnew->egid = kegid;\n\tif (sgid != (gid_t) -1)\n\t\tnew->sgid = ksgid;\n\tnew->fsgid = new->egid;\n\n\tretval = security_task_fix_setgid(new, old, LSM_SETID_RES);\n\tif (retval < 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nSYSCALL_DEFINE3(setresgid, gid_t, rgid, gid_t, egid, gid_t, sgid)\n{\n\treturn __sys_setresgid(rgid, egid, sgid);\n}\n\nSYSCALL_DEFINE3(getresgid, gid_t __user *, rgidp, gid_t __user *, egidp, gid_t __user *, sgidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tgid_t rgid, egid, sgid;\n\n\trgid = from_kgid_munged(cred->user_ns, cred->gid);\n\tegid = from_kgid_munged(cred->user_ns, cred->egid);\n\tsgid = from_kgid_munged(cred->user_ns, cred->sgid);\n\n\tretval = put_user(rgid, rgidp);\n\tif (!retval) {\n\t\tretval = put_user(egid, egidp);\n\t\tif (!retval)\n\t\t\tretval = put_user(sgid, sgidp);\n\t}\n\n\treturn retval;\n}\n\n\n \nlong __sys_setfsuid(uid_t uid)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tuid_t old_fsuid;\n\tkuid_t kuid;\n\n\told = current_cred();\n\told_fsuid = from_kuid_munged(old->user_ns, old->fsuid);\n\n\tkuid = make_kuid(old->user_ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn old_fsuid;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn old_fsuid;\n\n\tif (uid_eq(kuid, old->uid)  || uid_eq(kuid, old->euid)  ||\n\t    uid_eq(kuid, old->suid) || uid_eq(kuid, old->fsuid) ||\n\t    ns_capable_setid(old->user_ns, CAP_SETUID)) {\n\t\tif (!uid_eq(kuid, old->fsuid)) {\n\t\t\tnew->fsuid = kuid;\n\t\t\tif (security_task_fix_setuid(new, old, LSM_SETID_FS) == 0)\n\t\t\t\tgoto change_okay;\n\t\t}\n\t}\n\n\tabort_creds(new);\n\treturn old_fsuid;\n\nchange_okay:\n\tcommit_creds(new);\n\treturn old_fsuid;\n}\n\nSYSCALL_DEFINE1(setfsuid, uid_t, uid)\n{\n\treturn __sys_setfsuid(uid);\n}\n\n \nlong __sys_setfsgid(gid_t gid)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tgid_t old_fsgid;\n\tkgid_t kgid;\n\n\told = current_cred();\n\told_fsgid = from_kgid_munged(old->user_ns, old->fsgid);\n\n\tkgid = make_kgid(old->user_ns, gid);\n\tif (!gid_valid(kgid))\n\t\treturn old_fsgid;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn old_fsgid;\n\n\tif (gid_eq(kgid, old->gid)  || gid_eq(kgid, old->egid)  ||\n\t    gid_eq(kgid, old->sgid) || gid_eq(kgid, old->fsgid) ||\n\t    ns_capable_setid(old->user_ns, CAP_SETGID)) {\n\t\tif (!gid_eq(kgid, old->fsgid)) {\n\t\t\tnew->fsgid = kgid;\n\t\t\tif (security_task_fix_setgid(new,old,LSM_SETID_FS) == 0)\n\t\t\t\tgoto change_okay;\n\t\t}\n\t}\n\n\tabort_creds(new);\n\treturn old_fsgid;\n\nchange_okay:\n\tcommit_creds(new);\n\treturn old_fsgid;\n}\n\nSYSCALL_DEFINE1(setfsgid, gid_t, gid)\n{\n\treturn __sys_setfsgid(gid);\n}\n#endif  \n\n \nSYSCALL_DEFINE0(getpid)\n{\n\treturn task_tgid_vnr(current);\n}\n\n \nSYSCALL_DEFINE0(gettid)\n{\n\treturn task_pid_vnr(current);\n}\n\n \nSYSCALL_DEFINE0(getppid)\n{\n\tint pid;\n\n\trcu_read_lock();\n\tpid = task_tgid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\n\treturn pid;\n}\n\nSYSCALL_DEFINE0(getuid)\n{\n\t \n\treturn from_kuid_munged(current_user_ns(), current_uid());\n}\n\nSYSCALL_DEFINE0(geteuid)\n{\n\t \n\treturn from_kuid_munged(current_user_ns(), current_euid());\n}\n\nSYSCALL_DEFINE0(getgid)\n{\n\t \n\treturn from_kgid_munged(current_user_ns(), current_gid());\n}\n\nSYSCALL_DEFINE0(getegid)\n{\n\t \n\treturn from_kgid_munged(current_user_ns(), current_egid());\n}\n\nstatic void do_sys_times(struct tms *tms)\n{\n\tu64 tgutime, tgstime, cutime, cstime;\n\n\tthread_group_cputime_adjusted(current, &tgutime, &tgstime);\n\tcutime = current->signal->cutime;\n\tcstime = current->signal->cstime;\n\ttms->tms_utime = nsec_to_clock_t(tgutime);\n\ttms->tms_stime = nsec_to_clock_t(tgstime);\n\ttms->tms_cutime = nsec_to_clock_t(cutime);\n\ttms->tms_cstime = nsec_to_clock_t(cstime);\n}\n\nSYSCALL_DEFINE1(times, struct tms __user *, tbuf)\n{\n\tif (tbuf) {\n\t\tstruct tms tmp;\n\n\t\tdo_sys_times(&tmp);\n\t\tif (copy_to_user(tbuf, &tmp, sizeof(struct tms)))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn (long) jiffies_64_to_clock_t(get_jiffies_64());\n}\n\n#ifdef CONFIG_COMPAT\nstatic compat_clock_t clock_t_to_compat_clock_t(clock_t x)\n{\n\treturn compat_jiffies_to_clock_t(clock_t_to_jiffies(x));\n}\n\nCOMPAT_SYSCALL_DEFINE1(times, struct compat_tms __user *, tbuf)\n{\n\tif (tbuf) {\n\t\tstruct tms tms;\n\t\tstruct compat_tms tmp;\n\n\t\tdo_sys_times(&tms);\n\t\t \n\t\ttmp.tms_utime = clock_t_to_compat_clock_t(tms.tms_utime);\n\t\ttmp.tms_stime = clock_t_to_compat_clock_t(tms.tms_stime);\n\t\ttmp.tms_cutime = clock_t_to_compat_clock_t(tms.tms_cutime);\n\t\ttmp.tms_cstime = clock_t_to_compat_clock_t(tms.tms_cstime);\n\t\tif (copy_to_user(tbuf, &tmp, sizeof(tmp)))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn compat_jiffies_to_clock_t(jiffies);\n}\n#endif\n\n \nSYSCALL_DEFINE2(setpgid, pid_t, pid, pid_t, pgid)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *pgrp;\n\tint err;\n\n\tif (!pid)\n\t\tpid = task_pid_vnr(group_leader);\n\tif (!pgid)\n\t\tpgid = pid;\n\tif (pgid < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\n\t \n\twrite_lock_irq(&tasklist_lock);\n\n\terr = -ESRCH;\n\tp = find_task_by_vpid(pid);\n\tif (!p)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (!thread_group_leader(p))\n\t\tgoto out;\n\n\tif (same_thread_group(p->real_parent, group_leader)) {\n\t\terr = -EPERM;\n\t\tif (task_session(p) != task_session(group_leader))\n\t\t\tgoto out;\n\t\terr = -EACCES;\n\t\tif (!(p->flags & PF_FORKNOEXEC))\n\t\t\tgoto out;\n\t} else {\n\t\terr = -ESRCH;\n\t\tif (p != group_leader)\n\t\t\tgoto out;\n\t}\n\n\terr = -EPERM;\n\tif (p->signal->leader)\n\t\tgoto out;\n\n\tpgrp = task_pid(p);\n\tif (pgid != pid) {\n\t\tstruct task_struct *g;\n\n\t\tpgrp = find_vpid(pgid);\n\t\tg = pid_task(pgrp, PIDTYPE_PGID);\n\t\tif (!g || task_session(g) != task_session(group_leader))\n\t\t\tgoto out;\n\t}\n\n\terr = security_task_setpgid(p, pgid);\n\tif (err)\n\t\tgoto out;\n\n\tif (task_pgrp(p) != pgrp)\n\t\tchange_pid(p, PIDTYPE_PGID, pgrp);\n\n\terr = 0;\nout:\n\t \n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int do_getpgid(pid_t pid)\n{\n\tstruct task_struct *p;\n\tstruct pid *grp;\n\tint retval;\n\n\trcu_read_lock();\n\tif (!pid)\n\t\tgrp = task_pgrp(current);\n\telse {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tgrp = task_pgrp(p);\n\t\tif (!grp)\n\t\t\tgoto out;\n\n\t\tretval = security_task_getpgid(p);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = pid_vnr(grp);\nout:\n\trcu_read_unlock();\n\treturn retval;\n}\n\nSYSCALL_DEFINE1(getpgid, pid_t, pid)\n{\n\treturn do_getpgid(pid);\n}\n\n#ifdef __ARCH_WANT_SYS_GETPGRP\n\nSYSCALL_DEFINE0(getpgrp)\n{\n\treturn do_getpgid(0);\n}\n\n#endif\n\nSYSCALL_DEFINE1(getsid, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tstruct pid *sid;\n\tint retval;\n\n\trcu_read_lock();\n\tif (!pid)\n\t\tsid = task_session(current);\n\telse {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tsid = task_session(p);\n\t\tif (!sid)\n\t\t\tgoto out;\n\n\t\tretval = security_task_getsid(p);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\tretval = pid_vnr(sid);\nout:\n\trcu_read_unlock();\n\treturn retval;\n}\n\nstatic void set_special_pids(struct pid *pid)\n{\n\tstruct task_struct *curr = current->group_leader;\n\n\tif (task_session(curr) != pid)\n\t\tchange_pid(curr, PIDTYPE_SID, pid);\n\n\tif (task_pgrp(curr) != pid)\n\t\tchange_pid(curr, PIDTYPE_PGID, pid);\n}\n\nint ksys_setsid(void)\n{\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *sid = task_pid(group_leader);\n\tpid_t session = pid_vnr(sid);\n\tint err = -EPERM;\n\n\twrite_lock_irq(&tasklist_lock);\n\t \n\tif (group_leader->signal->leader)\n\t\tgoto out;\n\n\t \n\tif (pid_task(sid, PIDTYPE_PGID))\n\t\tgoto out;\n\n\tgroup_leader->signal->leader = 1;\n\tset_special_pids(sid);\n\n\tproc_clear_tty(group_leader);\n\n\terr = session;\nout:\n\twrite_unlock_irq(&tasklist_lock);\n\tif (err > 0) {\n\t\tproc_sid_connector(group_leader);\n\t\tsched_autogroup_create_attach(group_leader);\n\t}\n\treturn err;\n}\n\nSYSCALL_DEFINE0(setsid)\n{\n\treturn ksys_setsid();\n}\n\nDECLARE_RWSEM(uts_sem);\n\n#ifdef COMPAT_UTS_MACHINE\n#define override_architecture(name) \\\n\t(personality(current->personality) == PER_LINUX32 && \\\n\t copy_to_user(name->machine, COMPAT_UTS_MACHINE, \\\n\t\t      sizeof(COMPAT_UTS_MACHINE)))\n#else\n#define override_architecture(name)\t0\n#endif\n\n \nstatic int override_release(char __user *release, size_t len)\n{\n\tint ret = 0;\n\n\tif (current->personality & UNAME26) {\n\t\tconst char *rest = UTS_RELEASE;\n\t\tchar buf[65] = { 0 };\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\tsize_t copy;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = LINUX_VERSION_PATCHLEVEL + 60;\n\t\tcopy = clamp_t(size_t, len, 1, sizeof(buf));\n\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, copy + 1);\n\t}\n\treturn ret;\n}\n\nSYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)\n{\n\tstruct new_utsname tmp;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&tmp, utsname(), sizeof(tmp));\n\tup_read(&uts_sem);\n\tif (copy_to_user(name, &tmp, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (override_release(name->release, sizeof(name->release)))\n\t\treturn -EFAULT;\n\tif (override_architecture(name))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#ifdef __ARCH_WANT_SYS_OLD_UNAME\n \nSYSCALL_DEFINE1(uname, struct old_utsname __user *, name)\n{\n\tstruct old_utsname tmp;\n\n\tif (!name)\n\t\treturn -EFAULT;\n\n\tdown_read(&uts_sem);\n\tmemcpy(&tmp, utsname(), sizeof(tmp));\n\tup_read(&uts_sem);\n\tif (copy_to_user(name, &tmp, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (override_release(name->release, sizeof(name->release)))\n\t\treturn -EFAULT;\n\tif (override_architecture(name))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nSYSCALL_DEFINE1(olduname, struct oldold_utsname __user *, name)\n{\n\tstruct oldold_utsname tmp;\n\n\tif (!name)\n\t\treturn -EFAULT;\n\n\tmemset(&tmp, 0, sizeof(tmp));\n\n\tdown_read(&uts_sem);\n\tmemcpy(&tmp.sysname, &utsname()->sysname, __OLD_UTS_LEN);\n\tmemcpy(&tmp.nodename, &utsname()->nodename, __OLD_UTS_LEN);\n\tmemcpy(&tmp.release, &utsname()->release, __OLD_UTS_LEN);\n\tmemcpy(&tmp.version, &utsname()->version, __OLD_UTS_LEN);\n\tmemcpy(&tmp.machine, &utsname()->machine, __OLD_UTS_LEN);\n\tup_read(&uts_sem);\n\tif (copy_to_user(name, &tmp, sizeof(tmp)))\n\t\treturn -EFAULT;\n\n\tif (override_architecture(name))\n\t\treturn -EFAULT;\n\tif (override_release(name->release, sizeof(name->release)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif\n\nSYSCALL_DEFINE2(sethostname, char __user *, name, int, len)\n{\n\tint errno;\n\tchar tmp[__NEW_UTS_LEN];\n\n\tif (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (len < 0 || len > __NEW_UTS_LEN)\n\t\treturn -EINVAL;\n\terrno = -EFAULT;\n\tif (!copy_from_user(tmp, name, len)) {\n\t\tstruct new_utsname *u;\n\n\t\tadd_device_randomness(tmp, len);\n\t\tdown_write(&uts_sem);\n\t\tu = utsname();\n\t\tmemcpy(u->nodename, tmp, len);\n\t\tmemset(u->nodename + len, 0, sizeof(u->nodename) - len);\n\t\terrno = 0;\n\t\tuts_proc_notify(UTS_PROC_HOSTNAME);\n\t\tup_write(&uts_sem);\n\t}\n\treturn errno;\n}\n\n#ifdef __ARCH_WANT_SYS_GETHOSTNAME\n\nSYSCALL_DEFINE2(gethostname, char __user *, name, int, len)\n{\n\tint i;\n\tstruct new_utsname *u;\n\tchar tmp[__NEW_UTS_LEN + 1];\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->nodename);\n\tif (i > len)\n\t\ti = len;\n\tmemcpy(tmp, u->nodename, i);\n\tup_read(&uts_sem);\n\tif (copy_to_user(name, tmp, i))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#endif\n\n \nSYSCALL_DEFINE2(setdomainname, char __user *, name, int, len)\n{\n\tint errno;\n\tchar tmp[__NEW_UTS_LEN];\n\n\tif (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (len < 0 || len > __NEW_UTS_LEN)\n\t\treturn -EINVAL;\n\n\terrno = -EFAULT;\n\tif (!copy_from_user(tmp, name, len)) {\n\t\tstruct new_utsname *u;\n\n\t\tadd_device_randomness(tmp, len);\n\t\tdown_write(&uts_sem);\n\t\tu = utsname();\n\t\tmemcpy(u->domainname, tmp, len);\n\t\tmemset(u->domainname + len, 0, sizeof(u->domainname) - len);\n\t\terrno = 0;\n\t\tuts_proc_notify(UTS_PROC_DOMAINNAME);\n\t\tup_write(&uts_sem);\n\t}\n\treturn errno;\n}\n\n \nstatic int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\n\t \n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\t \n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\n\t \n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\t \n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\n\treturn retval;\n}\n\nSYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit value;\n\tint ret;\n\n\tret = do_prlimit(current, resource, NULL, &value);\n\tif (!ret)\n\t\tret = copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nCOMPAT_SYSCALL_DEFINE2(setrlimit, unsigned int, resource,\n\t\t       struct compat_rlimit __user *, rlim)\n{\n\tstruct rlimit r;\n\tstruct compat_rlimit r32;\n\n\tif (copy_from_user(&r32, rlim, sizeof(struct compat_rlimit)))\n\t\treturn -EFAULT;\n\n\tif (r32.rlim_cur == COMPAT_RLIM_INFINITY)\n\t\tr.rlim_cur = RLIM_INFINITY;\n\telse\n\t\tr.rlim_cur = r32.rlim_cur;\n\tif (r32.rlim_max == COMPAT_RLIM_INFINITY)\n\t\tr.rlim_max = RLIM_INFINITY;\n\telse\n\t\tr.rlim_max = r32.rlim_max;\n\treturn do_prlimit(current, resource, &r, NULL);\n}\n\nCOMPAT_SYSCALL_DEFINE2(getrlimit, unsigned int, resource,\n\t\t       struct compat_rlimit __user *, rlim)\n{\n\tstruct rlimit r;\n\tint ret;\n\n\tret = do_prlimit(current, resource, NULL, &r);\n\tif (!ret) {\n\t\tstruct compat_rlimit r32;\n\t\tif (r.rlim_cur > COMPAT_RLIM_INFINITY)\n\t\t\tr32.rlim_cur = COMPAT_RLIM_INFINITY;\n\t\telse\n\t\t\tr32.rlim_cur = r.rlim_cur;\n\t\tif (r.rlim_max > COMPAT_RLIM_INFINITY)\n\t\t\tr32.rlim_max = COMPAT_RLIM_INFINITY;\n\t\telse\n\t\t\tr32.rlim_max = r.rlim_max;\n\n\t\tif (copy_to_user(rlim, &r32, sizeof(struct compat_rlimit)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT\n\n \nSYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,\n\t\tstruct rlimit __user *, rlim)\n{\n\tstruct rlimit x;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\ttask_lock(current->group_leader);\n\tx = current->signal->rlim[resource];\n\ttask_unlock(current->group_leader);\n\tif (x.rlim_cur > 0x7FFFFFFF)\n\t\tx.rlim_cur = 0x7FFFFFFF;\n\tif (x.rlim_max > 0x7FFFFFFF)\n\t\tx.rlim_max = 0x7FFFFFFF;\n\treturn copy_to_user(rlim, &x, sizeof(x)) ? -EFAULT : 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(old_getrlimit, unsigned int, resource,\n\t\t       struct compat_rlimit __user *, rlim)\n{\n\tstruct rlimit r;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\ttask_lock(current->group_leader);\n\tr = current->signal->rlim[resource];\n\ttask_unlock(current->group_leader);\n\tif (r.rlim_cur > 0x7FFFFFFF)\n\t\tr.rlim_cur = 0x7FFFFFFF;\n\tif (r.rlim_max > 0x7FFFFFFF)\n\t\tr.rlim_max = 0x7FFFFFFF;\n\n\tif (put_user(r.rlim_cur, &rlim->rlim_cur) ||\n\t    put_user(r.rlim_max, &rlim->rlim_max))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif\n\n#endif\n\nstatic inline bool rlim64_is_infinity(__u64 rlim64)\n{\n#if BITS_PER_LONG < 64\n\treturn rlim64 >= ULONG_MAX;\n#else\n\treturn rlim64 == RLIM64_INFINITY;\n#endif\n}\n\nstatic void rlim_to_rlim64(const struct rlimit *rlim, struct rlimit64 *rlim64)\n{\n\tif (rlim->rlim_cur == RLIM_INFINITY)\n\t\trlim64->rlim_cur = RLIM64_INFINITY;\n\telse\n\t\trlim64->rlim_cur = rlim->rlim_cur;\n\tif (rlim->rlim_max == RLIM_INFINITY)\n\t\trlim64->rlim_max = RLIM64_INFINITY;\n\telse\n\t\trlim64->rlim_max = rlim->rlim_max;\n}\n\nstatic void rlim64_to_rlim(const struct rlimit64 *rlim64, struct rlimit *rlim)\n{\n\tif (rlim64_is_infinity(rlim64->rlim_cur))\n\t\trlim->rlim_cur = RLIM_INFINITY;\n\telse\n\t\trlim->rlim_cur = (unsigned long)rlim64->rlim_cur;\n\tif (rlim64_is_infinity(rlim64->rlim_max))\n\t\trlim->rlim_max = RLIM_INFINITY;\n\telse\n\t\trlim->rlim_max = (unsigned long)rlim64->rlim_max;\n}\n\n \nstatic int check_prlimit_permission(struct task_struct *task,\n\t\t\t\t    unsigned int flags)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tbool id_match;\n\n\tif (current == task)\n\t\treturn 0;\n\n\ttcred = __task_cred(task);\n\tid_match = (uid_eq(cred->uid, tcred->euid) &&\n\t\t    uid_eq(cred->uid, tcred->suid) &&\n\t\t    uid_eq(cred->uid, tcred->uid)  &&\n\t\t    gid_eq(cred->gid, tcred->egid) &&\n\t\t    gid_eq(cred->gid, tcred->sgid) &&\n\t\t    gid_eq(cred->gid, tcred->gid));\n\tif (!id_match && !ns_capable(tcred->user_ns, CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\treturn security_task_prlimit(cred, tcred, flags);\n}\n\nSYSCALL_DEFINE4(prlimit64, pid_t, pid, unsigned int, resource,\n\t\tconst struct rlimit64 __user *, new_rlim,\n\t\tstruct rlimit64 __user *, old_rlim)\n{\n\tstruct rlimit64 old64, new64;\n\tstruct rlimit old, new;\n\tstruct task_struct *tsk;\n\tunsigned int checkflags = 0;\n\tint ret;\n\n\tif (old_rlim)\n\t\tcheckflags |= LSM_PRLIMIT_READ;\n\n\tif (new_rlim) {\n\t\tif (copy_from_user(&new64, new_rlim, sizeof(new64)))\n\t\t\treturn -EFAULT;\n\t\trlim64_to_rlim(&new64, &new);\n\t\tcheckflags |= LSM_PRLIMIT_WRITE;\n\t}\n\n\trcu_read_lock();\n\ttsk = pid ? find_task_by_vpid(pid) : current;\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tret = check_prlimit_permission(tsk, checkflags);\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tget_task_struct(tsk);\n\trcu_read_unlock();\n\n\tret = do_prlimit(tsk, resource, new_rlim ? &new : NULL,\n\t\t\told_rlim ? &old : NULL);\n\n\tif (!ret && old_rlim) {\n\t\trlim_to_rlim64(&old, &old64);\n\t\tif (copy_to_user(old_rlim, &old64, sizeof(old64)))\n\t\t\tret = -EFAULT;\n\t}\n\n\tput_task_struct(tsk);\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)\n{\n\tstruct rlimit new_rlim;\n\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\treturn do_prlimit(current, resource, &new_rlim, NULL);\n}\n\n \n\nstatic void accumulate_thread_rusage(struct task_struct *t, struct rusage *r)\n{\n\tr->ru_nvcsw += t->nvcsw;\n\tr->ru_nivcsw += t->nivcsw;\n\tr->ru_minflt += t->min_flt;\n\tr->ru_majflt += t->maj_flt;\n\tr->ru_inblock += task_io_get_inblock(t);\n\tr->ru_oublock += task_io_get_oublock(t);\n}\n\nvoid getrusage(struct task_struct *p, int who, struct rusage *r)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tu64 tgutime, tgstime, utime, stime;\n\tunsigned long maxrss = 0;\n\n\tmemset((char *)r, 0, sizeof (*r));\n\tutime = stime = 0;\n\n\tif (who == RUSAGE_THREAD) {\n\t\ttask_cputime_adjusted(current, &utime, &stime);\n\t\taccumulate_thread_rusage(p, r);\n\t\tmaxrss = p->signal->maxrss;\n\t\tgoto out;\n\t}\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn;\n\n\tswitch (who) {\n\tcase RUSAGE_BOTH:\n\tcase RUSAGE_CHILDREN:\n\t\tutime = p->signal->cutime;\n\t\tstime = p->signal->cstime;\n\t\tr->ru_nvcsw = p->signal->cnvcsw;\n\t\tr->ru_nivcsw = p->signal->cnivcsw;\n\t\tr->ru_minflt = p->signal->cmin_flt;\n\t\tr->ru_majflt = p->signal->cmaj_flt;\n\t\tr->ru_inblock = p->signal->cinblock;\n\t\tr->ru_oublock = p->signal->coublock;\n\t\tmaxrss = p->signal->cmaxrss;\n\n\t\tif (who == RUSAGE_CHILDREN)\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase RUSAGE_SELF:\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tutime += tgutime;\n\t\tstime += tgstime;\n\t\tr->ru_nvcsw += p->signal->nvcsw;\n\t\tr->ru_nivcsw += p->signal->nivcsw;\n\t\tr->ru_minflt += p->signal->min_flt;\n\t\tr->ru_majflt += p->signal->maj_flt;\n\t\tr->ru_inblock += p->signal->inblock;\n\t\tr->ru_oublock += p->signal->oublock;\n\t\tif (maxrss < p->signal->maxrss)\n\t\t\tmaxrss = p->signal->maxrss;\n\t\tt = p;\n\t\tdo {\n\t\t\taccumulate_thread_rusage(t, r);\n\t\t} while_each_thread(p, t);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\tunlock_task_sighand(p, &flags);\n\nout:\n\tr->ru_utime = ns_to_kernel_old_timeval(utime);\n\tr->ru_stime = ns_to_kernel_old_timeval(stime);\n\n\tif (who != RUSAGE_CHILDREN) {\n\t\tstruct mm_struct *mm = get_task_mm(p);\n\n\t\tif (mm) {\n\t\t\tsetmax_mm_hiwater_rss(&maxrss, mm);\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\tr->ru_maxrss = maxrss * (PAGE_SIZE / 1024);  \n}\n\nSYSCALL_DEFINE2(getrusage, int, who, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&\n\t    who != RUSAGE_THREAD)\n\t\treturn -EINVAL;\n\n\tgetrusage(current, who, &r);\n\treturn copy_to_user(ru, &r, sizeof(r)) ? -EFAULT : 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(getrusage, int, who, struct compat_rusage __user *, ru)\n{\n\tstruct rusage r;\n\n\tif (who != RUSAGE_SELF && who != RUSAGE_CHILDREN &&\n\t    who != RUSAGE_THREAD)\n\t\treturn -EINVAL;\n\n\tgetrusage(current, who, &r);\n\treturn put_compat_rusage(&r, ru);\n}\n#endif\n\nSYSCALL_DEFINE1(umask, int, mask)\n{\n\tmask = xchg(&current->fs->umask, mask & S_IRWXUGO);\n\treturn mask;\n}\n\nstatic int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)\n{\n\tstruct fd exe;\n\tstruct inode *inode;\n\tint err;\n\n\texe = fdget(fd);\n\tif (!exe.file)\n\t\treturn -EBADF;\n\n\tinode = file_inode(exe.file);\n\n\t \n\terr = -EACCES;\n\tif (!S_ISREG(inode->i_mode) || path_noexec(&exe.file->f_path))\n\t\tgoto exit;\n\n\terr = file_permission(exe.file, MAY_EXEC);\n\tif (err)\n\t\tgoto exit;\n\n\terr = replace_mm_exe_file(mm, exe.file);\nexit:\n\tfdput(exe);\n\treturn err;\n}\n\n \nstatic int validate_prctl_map_addr(struct prctl_mm_map *prctl_map)\n{\n\tunsigned long mmap_max_addr = TASK_SIZE;\n\tint error = -EINVAL, i;\n\n\tstatic const unsigned char offsets[] = {\n\t\toffsetof(struct prctl_mm_map, start_code),\n\t\toffsetof(struct prctl_mm_map, end_code),\n\t\toffsetof(struct prctl_mm_map, start_data),\n\t\toffsetof(struct prctl_mm_map, end_data),\n\t\toffsetof(struct prctl_mm_map, start_brk),\n\t\toffsetof(struct prctl_mm_map, brk),\n\t\toffsetof(struct prctl_mm_map, start_stack),\n\t\toffsetof(struct prctl_mm_map, arg_start),\n\t\toffsetof(struct prctl_mm_map, arg_end),\n\t\toffsetof(struct prctl_mm_map, env_start),\n\t\toffsetof(struct prctl_mm_map, env_end),\n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(offsets); i++) {\n\t\tu64 val = *(u64 *)((char *)prctl_map + offsets[i]);\n\n\t\tif ((unsigned long)val >= mmap_max_addr ||\n\t\t    (unsigned long)val < mmap_min_addr)\n\t\t\tgoto out;\n\t}\n\n\t \n#define __prctl_check_order(__m1, __op, __m2)\t\t\t\t\\\n\t((unsigned long)prctl_map->__m1 __op\t\t\t\t\\\n\t (unsigned long)prctl_map->__m2) ? 0 : -EINVAL\n\terror  = __prctl_check_order(start_code, <, end_code);\n\terror |= __prctl_check_order(start_data,<=, end_data);\n\terror |= __prctl_check_order(start_brk, <=, brk);\n\terror |= __prctl_check_order(arg_start, <=, arg_end);\n\terror |= __prctl_check_order(env_start, <=, env_end);\n\tif (error)\n\t\tgoto out;\n#undef __prctl_check_order\n\n\terror = -EINVAL;\n\n\t \n\tif (check_data_rlimit(rlimit(RLIMIT_DATA), prctl_map->brk,\n\t\t\t      prctl_map->start_brk, prctl_map->end_data,\n\t\t\t      prctl_map->start_data))\n\t\t\tgoto out;\n\n\terror = 0;\nout:\n\treturn error;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data_size)\n{\n\tstruct prctl_mm_map prctl_map = { .exe_fd = (u32)-1, };\n\tunsigned long user_auxv[AT_VECTOR_SIZE];\n\tstruct mm_struct *mm = current->mm;\n\tint error;\n\n\tBUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));\n\tBUILD_BUG_ON(sizeof(struct prctl_mm_map) > 256);\n\n\tif (opt == PR_SET_MM_MAP_SIZE)\n\t\treturn put_user((unsigned int)sizeof(prctl_map),\n\t\t\t\t(unsigned int __user *)addr);\n\n\tif (data_size != sizeof(prctl_map))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&prctl_map, addr, sizeof(prctl_map)))\n\t\treturn -EFAULT;\n\n\terror = validate_prctl_map_addr(&prctl_map);\n\tif (error)\n\t\treturn error;\n\n\tif (prctl_map.auxv_size) {\n\t\t \n\t\tif (!prctl_map.auxv ||\n\t\t\t\tprctl_map.auxv_size > sizeof(mm->saved_auxv))\n\t\t\treturn -EINVAL;\n\n\t\tmemset(user_auxv, 0, sizeof(user_auxv));\n\t\tif (copy_from_user(user_auxv,\n\t\t\t\t   (const void __user *)prctl_map.auxv,\n\t\t\t\t   prctl_map.auxv_size))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tuser_auxv[AT_VECTOR_SIZE - 2] = AT_NULL;\n\t\tuser_auxv[AT_VECTOR_SIZE - 1] = AT_NULL;\n\t}\n\n\tif (prctl_map.exe_fd != (u32)-1) {\n\t\t \n\t\tif (!checkpoint_restore_ns_capable(current_user_ns()))\n\t\t\treturn -EPERM;\n\n\t\terror = prctl_set_mm_exe_file(mm, prctl_map.exe_fd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tmmap_read_lock(mm);\n\n\t \n\n\tspin_lock(&mm->arg_lock);\n\tmm->start_code\t= prctl_map.start_code;\n\tmm->end_code\t= prctl_map.end_code;\n\tmm->start_data\t= prctl_map.start_data;\n\tmm->end_data\t= prctl_map.end_data;\n\tmm->start_brk\t= prctl_map.start_brk;\n\tmm->brk\t\t= prctl_map.brk;\n\tmm->start_stack\t= prctl_map.start_stack;\n\tmm->arg_start\t= prctl_map.arg_start;\n\tmm->arg_end\t= prctl_map.arg_end;\n\tmm->env_start\t= prctl_map.env_start;\n\tmm->env_end\t= prctl_map.env_end;\n\tspin_unlock(&mm->arg_lock);\n\n\t \n\tif (prctl_map.auxv_size)\n\t\tmemcpy(mm->saved_auxv, user_auxv, sizeof(user_auxv));\n\n\tmmap_read_unlock(mm);\n\treturn 0;\n}\n#endif  \n\nstatic int prctl_set_auxv(struct mm_struct *mm, unsigned long addr,\n\t\t\t  unsigned long len)\n{\n\t \n\tunsigned long user_auxv[AT_VECTOR_SIZE] = {};\n\n\tif (len > sizeof(user_auxv))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(user_auxv, (const void __user *)addr, len))\n\t\treturn -EFAULT;\n\n\t \n\tuser_auxv[AT_VECTOR_SIZE - 2] = 0;\n\tuser_auxv[AT_VECTOR_SIZE - 1] = 0;\n\n\tBUILD_BUG_ON(sizeof(user_auxv) != sizeof(mm->saved_auxv));\n\n\ttask_lock(current);\n\tmemcpy(mm->saved_auxv, user_auxv, len);\n\ttask_unlock(current);\n\n\treturn 0;\n}\n\nstatic int prctl_set_mm(int opt, unsigned long addr,\n\t\t\tunsigned long arg4, unsigned long arg5)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct prctl_mm_map prctl_map = {\n\t\t.auxv = NULL,\n\t\t.auxv_size = 0,\n\t\t.exe_fd = -1,\n\t};\n\tstruct vm_area_struct *vma;\n\tint error;\n\n\tif (arg5 || (arg4 && (opt != PR_SET_MM_AUXV &&\n\t\t\t      opt != PR_SET_MM_MAP &&\n\t\t\t      opt != PR_SET_MM_MAP_SIZE)))\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tif (opt == PR_SET_MM_MAP || opt == PR_SET_MM_MAP_SIZE)\n\t\treturn prctl_set_mm_map(opt, (const void __user *)addr, arg4);\n#endif\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tif (opt == PR_SET_MM_EXE_FILE)\n\t\treturn prctl_set_mm_exe_file(mm, (unsigned int)addr);\n\n\tif (opt == PR_SET_MM_AUXV)\n\t\treturn prctl_set_auxv(mm, addr, arg4);\n\n\tif (addr >= TASK_SIZE || addr < mmap_min_addr)\n\t\treturn -EINVAL;\n\n\terror = -EINVAL;\n\n\t \n\tmmap_read_lock(mm);\n\tvma = find_vma(mm, addr);\n\n\tspin_lock(&mm->arg_lock);\n\tprctl_map.start_code\t= mm->start_code;\n\tprctl_map.end_code\t= mm->end_code;\n\tprctl_map.start_data\t= mm->start_data;\n\tprctl_map.end_data\t= mm->end_data;\n\tprctl_map.start_brk\t= mm->start_brk;\n\tprctl_map.brk\t\t= mm->brk;\n\tprctl_map.start_stack\t= mm->start_stack;\n\tprctl_map.arg_start\t= mm->arg_start;\n\tprctl_map.arg_end\t= mm->arg_end;\n\tprctl_map.env_start\t= mm->env_start;\n\tprctl_map.env_end\t= mm->env_end;\n\n\tswitch (opt) {\n\tcase PR_SET_MM_START_CODE:\n\t\tprctl_map.start_code = addr;\n\t\tbreak;\n\tcase PR_SET_MM_END_CODE:\n\t\tprctl_map.end_code = addr;\n\t\tbreak;\n\tcase PR_SET_MM_START_DATA:\n\t\tprctl_map.start_data = addr;\n\t\tbreak;\n\tcase PR_SET_MM_END_DATA:\n\t\tprctl_map.end_data = addr;\n\t\tbreak;\n\tcase PR_SET_MM_START_STACK:\n\t\tprctl_map.start_stack = addr;\n\t\tbreak;\n\tcase PR_SET_MM_START_BRK:\n\t\tprctl_map.start_brk = addr;\n\t\tbreak;\n\tcase PR_SET_MM_BRK:\n\t\tprctl_map.brk = addr;\n\t\tbreak;\n\tcase PR_SET_MM_ARG_START:\n\t\tprctl_map.arg_start = addr;\n\t\tbreak;\n\tcase PR_SET_MM_ARG_END:\n\t\tprctl_map.arg_end = addr;\n\t\tbreak;\n\tcase PR_SET_MM_ENV_START:\n\t\tprctl_map.env_start = addr;\n\t\tbreak;\n\tcase PR_SET_MM_ENV_END:\n\t\tprctl_map.env_end = addr;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terror = validate_prctl_map_addr(&prctl_map);\n\tif (error)\n\t\tgoto out;\n\n\tswitch (opt) {\n\t \n\tcase PR_SET_MM_START_STACK:\n\tcase PR_SET_MM_ARG_START:\n\tcase PR_SET_MM_ARG_END:\n\tcase PR_SET_MM_ENV_START:\n\tcase PR_SET_MM_ENV_END:\n\t\tif (!vma) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmm->start_code\t= prctl_map.start_code;\n\tmm->end_code\t= prctl_map.end_code;\n\tmm->start_data\t= prctl_map.start_data;\n\tmm->end_data\t= prctl_map.end_data;\n\tmm->start_brk\t= prctl_map.start_brk;\n\tmm->brk\t\t= prctl_map.brk;\n\tmm->start_stack\t= prctl_map.start_stack;\n\tmm->arg_start\t= prctl_map.arg_start;\n\tmm->arg_end\t= prctl_map.arg_end;\n\tmm->env_start\t= prctl_map.env_start;\n\tmm->env_end\t= prctl_map.env_end;\n\n\terror = 0;\nout:\n\tspin_unlock(&mm->arg_lock);\n\tmmap_read_unlock(mm);\n\treturn error;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic int prctl_get_tid_address(struct task_struct *me, int __user * __user *tid_addr)\n{\n\treturn put_user(me->clear_child_tid, tid_addr);\n}\n#else\nstatic int prctl_get_tid_address(struct task_struct *me, int __user * __user *tid_addr)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int propagate_has_child_subreaper(struct task_struct *p, void *data)\n{\n\t \n\tif (p->signal->has_child_subreaper ||\n\t    is_child_reaper(task_pid(p)))\n\t\treturn 0;\n\n\tp->signal->has_child_subreaper = 1;\n\treturn 1;\n}\n\nint __weak arch_prctl_spec_ctrl_get(struct task_struct *t, unsigned long which)\n{\n\treturn -EINVAL;\n}\n\nint __weak arch_prctl_spec_ctrl_set(struct task_struct *t, unsigned long which,\n\t\t\t\t    unsigned long ctrl)\n{\n\treturn -EINVAL;\n}\n\n#define PR_IO_FLUSHER (PF_MEMALLOC_NOIO | PF_LOCAL_THROTTLE)\n\n#ifdef CONFIG_ANON_VMA_NAME\n\n#define ANON_VMA_NAME_MAX_LEN\t\t80\n#define ANON_VMA_NAME_INVALID_CHARS\t\"\\\\`$[]\"\n\nstatic inline bool is_valid_name_char(char ch)\n{\n\t \n\treturn ch > 0x1f && ch < 0x7f &&\n\t\t!strchr(ANON_VMA_NAME_INVALID_CHARS, ch);\n}\n\nstatic int prctl_set_vma(unsigned long opt, unsigned long addr,\n\t\t\t unsigned long size, unsigned long arg)\n{\n\tstruct mm_struct *mm = current->mm;\n\tconst char __user *uname;\n\tstruct anon_vma_name *anon_name = NULL;\n\tint error;\n\n\tswitch (opt) {\n\tcase PR_SET_VMA_ANON_NAME:\n\t\tuname = (const char __user *)arg;\n\t\tif (uname) {\n\t\t\tchar *name, *pch;\n\n\t\t\tname = strndup_user(uname, ANON_VMA_NAME_MAX_LEN);\n\t\t\tif (IS_ERR(name))\n\t\t\t\treturn PTR_ERR(name);\n\n\t\t\tfor (pch = name; *pch != '\\0'; pch++) {\n\t\t\t\tif (!is_valid_name_char(*pch)) {\n\t\t\t\t\tkfree(name);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tanon_name = anon_vma_name_alloc(name);\n\t\t\tkfree(name);\n\t\t\tif (!anon_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t}\n\n\t\tmmap_write_lock(mm);\n\t\terror = madvise_set_anon_name(mm, addr, size, anon_name);\n\t\tmmap_write_unlock(mm);\n\t\tanon_vma_name_put(anon_name);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t}\n\n\treturn error;\n}\n\n#else  \nstatic int prctl_set_vma(unsigned long opt, unsigned long start,\n\t\t\t unsigned long size, unsigned long arg)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nstatic inline unsigned long get_current_mdwe(void)\n{\n\tunsigned long ret = 0;\n\n\tif (test_bit(MMF_HAS_MDWE, &current->mm->flags))\n\t\tret |= PR_MDWE_REFUSE_EXEC_GAIN;\n\tif (test_bit(MMF_HAS_MDWE_NO_INHERIT, &current->mm->flags))\n\t\tret |= PR_MDWE_NO_INHERIT;\n\n\treturn ret;\n}\n\nstatic inline int prctl_set_mdwe(unsigned long bits, unsigned long arg3,\n\t\t\t\t unsigned long arg4, unsigned long arg5)\n{\n\tunsigned long current_bits;\n\n\tif (arg3 || arg4 || arg5)\n\t\treturn -EINVAL;\n\n\tif (bits & ~(PR_MDWE_REFUSE_EXEC_GAIN | PR_MDWE_NO_INHERIT))\n\t\treturn -EINVAL;\n\n\t \n\tif (bits & PR_MDWE_NO_INHERIT && !(bits & PR_MDWE_REFUSE_EXEC_GAIN))\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_ENABLED(CONFIG_PARISC))\n\t\treturn -EINVAL;\n\n\tcurrent_bits = get_current_mdwe();\n\tif (current_bits && current_bits != bits)\n\t\treturn -EPERM;  \n\n\tif (bits & PR_MDWE_NO_INHERIT)\n\t\tset_bit(MMF_HAS_MDWE_NO_INHERIT, &current->mm->flags);\n\tif (bits & PR_MDWE_REFUSE_EXEC_GAIN)\n\t\tset_bit(MMF_HAS_MDWE, &current->mm->flags);\n\n\treturn 0;\n}\n\nstatic inline int prctl_get_mdwe(unsigned long arg2, unsigned long arg3,\n\t\t\t\t unsigned long arg4, unsigned long arg5)\n{\n\tif (arg2 || arg3 || arg4 || arg5)\n\t\treturn -EINVAL;\n\treturn get_current_mdwe();\n}\n\nstatic int prctl_get_auxv(void __user *addr, unsigned long len)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long size = min_t(unsigned long, sizeof(mm->saved_auxv), len);\n\n\tif (size && copy_to_user(addr, mm->saved_auxv, size))\n\t\treturn -EFAULT;\n\treturn sizeof(mm->saved_auxv);\n}\n\nSYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tstruct task_struct *me = current;\n\tunsigned char comm[sizeof(me->comm)];\n\tlong error;\n\n\terror = security_task_prctl(option, arg2, arg3, arg4, arg5);\n\tif (error != -ENOSYS)\n\t\treturn error;\n\n\terror = 0;\n\tswitch (option) {\n\tcase PR_SET_PDEATHSIG:\n\t\tif (!valid_signal(arg2)) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tme->pdeath_signal = arg2;\n\t\tbreak;\n\tcase PR_GET_PDEATHSIG:\n\t\terror = put_user(me->pdeath_signal, (int __user *)arg2);\n\t\tbreak;\n\tcase PR_GET_DUMPABLE:\n\t\terror = get_dumpable(me->mm);\n\t\tbreak;\n\tcase PR_SET_DUMPABLE:\n\t\tif (arg2 != SUID_DUMP_DISABLE && arg2 != SUID_DUMP_USER) {\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tset_dumpable(me->mm, arg2);\n\t\tbreak;\n\n\tcase PR_SET_UNALIGN:\n\t\terror = SET_UNALIGN_CTL(me, arg2);\n\t\tbreak;\n\tcase PR_GET_UNALIGN:\n\t\terror = GET_UNALIGN_CTL(me, arg2);\n\t\tbreak;\n\tcase PR_SET_FPEMU:\n\t\terror = SET_FPEMU_CTL(me, arg2);\n\t\tbreak;\n\tcase PR_GET_FPEMU:\n\t\terror = GET_FPEMU_CTL(me, arg2);\n\t\tbreak;\n\tcase PR_SET_FPEXC:\n\t\terror = SET_FPEXC_CTL(me, arg2);\n\t\tbreak;\n\tcase PR_GET_FPEXC:\n\t\terror = GET_FPEXC_CTL(me, arg2);\n\t\tbreak;\n\tcase PR_GET_TIMING:\n\t\terror = PR_TIMING_STATISTICAL;\n\t\tbreak;\n\tcase PR_SET_TIMING:\n\t\tif (arg2 != PR_TIMING_STATISTICAL)\n\t\t\terror = -EINVAL;\n\t\tbreak;\n\tcase PR_SET_NAME:\n\t\tcomm[sizeof(me->comm) - 1] = 0;\n\t\tif (strncpy_from_user(comm, (char __user *)arg2,\n\t\t\t\t      sizeof(me->comm) - 1) < 0)\n\t\t\treturn -EFAULT;\n\t\tset_task_comm(me, comm);\n\t\tproc_comm_connector(me);\n\t\tbreak;\n\tcase PR_GET_NAME:\n\t\tget_task_comm(comm, me);\n\t\tif (copy_to_user((char __user *)arg2, comm, sizeof(comm)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase PR_GET_ENDIAN:\n\t\terror = GET_ENDIAN(me, arg2);\n\t\tbreak;\n\tcase PR_SET_ENDIAN:\n\t\terror = SET_ENDIAN(me, arg2);\n\t\tbreak;\n\tcase PR_GET_SECCOMP:\n\t\terror = prctl_get_seccomp();\n\t\tbreak;\n\tcase PR_SET_SECCOMP:\n\t\terror = prctl_set_seccomp(arg2, (char __user *)arg3);\n\t\tbreak;\n\tcase PR_GET_TSC:\n\t\terror = GET_TSC_CTL(arg2);\n\t\tbreak;\n\tcase PR_SET_TSC:\n\t\terror = SET_TSC_CTL(arg2);\n\t\tbreak;\n\tcase PR_TASK_PERF_EVENTS_DISABLE:\n\t\terror = perf_event_task_disable();\n\t\tbreak;\n\tcase PR_TASK_PERF_EVENTS_ENABLE:\n\t\terror = perf_event_task_enable();\n\t\tbreak;\n\tcase PR_GET_TIMERSLACK:\n\t\tif (current->timer_slack_ns > ULONG_MAX)\n\t\t\terror = ULONG_MAX;\n\t\telse\n\t\t\terror = current->timer_slack_ns;\n\t\tbreak;\n\tcase PR_SET_TIMERSLACK:\n\t\tif (arg2 <= 0)\n\t\t\tcurrent->timer_slack_ns =\n\t\t\t\t\tcurrent->default_timer_slack_ns;\n\t\telse\n\t\t\tcurrent->timer_slack_ns = arg2;\n\t\tbreak;\n\tcase PR_MCE_KILL:\n\t\tif (arg4 | arg5)\n\t\t\treturn -EINVAL;\n\t\tswitch (arg2) {\n\t\tcase PR_MCE_KILL_CLEAR:\n\t\t\tif (arg3 != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tcurrent->flags &= ~PF_MCE_PROCESS;\n\t\t\tbreak;\n\t\tcase PR_MCE_KILL_SET:\n\t\t\tcurrent->flags |= PF_MCE_PROCESS;\n\t\t\tif (arg3 == PR_MCE_KILL_EARLY)\n\t\t\t\tcurrent->flags |= PF_MCE_EARLY;\n\t\t\telse if (arg3 == PR_MCE_KILL_LATE)\n\t\t\t\tcurrent->flags &= ~PF_MCE_EARLY;\n\t\t\telse if (arg3 == PR_MCE_KILL_DEFAULT)\n\t\t\t\tcurrent->flags &=\n\t\t\t\t\t\t~(PF_MCE_EARLY|PF_MCE_PROCESS);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PR_MCE_KILL_GET:\n\t\tif (arg2 | arg3 | arg4 | arg5)\n\t\t\treturn -EINVAL;\n\t\tif (current->flags & PF_MCE_PROCESS)\n\t\t\terror = (current->flags & PF_MCE_EARLY) ?\n\t\t\t\tPR_MCE_KILL_EARLY : PR_MCE_KILL_LATE;\n\t\telse\n\t\t\terror = PR_MCE_KILL_DEFAULT;\n\t\tbreak;\n\tcase PR_SET_MM:\n\t\terror = prctl_set_mm(arg2, arg3, arg4, arg5);\n\t\tbreak;\n\tcase PR_GET_TID_ADDRESS:\n\t\terror = prctl_get_tid_address(me, (int __user * __user *)arg2);\n\t\tbreak;\n\tcase PR_SET_CHILD_SUBREAPER:\n\t\tme->signal->is_child_subreaper = !!arg2;\n\t\tif (!arg2)\n\t\t\tbreak;\n\n\t\twalk_process_tree(me, propagate_has_child_subreaper, NULL);\n\t\tbreak;\n\tcase PR_GET_CHILD_SUBREAPER:\n\t\terror = put_user(me->signal->is_child_subreaper,\n\t\t\t\t (int __user *)arg2);\n\t\tbreak;\n\tcase PR_SET_NO_NEW_PRIVS:\n\t\tif (arg2 != 1 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\n\t\ttask_set_no_new_privs(current);\n\t\tbreak;\n\tcase PR_GET_NO_NEW_PRIVS:\n\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\treturn task_no_new_privs(current) ? 1 : 0;\n\tcase PR_GET_THP_DISABLE:\n\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = !!test_bit(MMF_DISABLE_THP, &me->mm->flags);\n\t\tbreak;\n\tcase PR_SET_THP_DISABLE:\n\t\tif (arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\tif (mmap_write_lock_killable(me->mm))\n\t\t\treturn -EINTR;\n\t\tif (arg2)\n\t\t\tset_bit(MMF_DISABLE_THP, &me->mm->flags);\n\t\telse\n\t\t\tclear_bit(MMF_DISABLE_THP, &me->mm->flags);\n\t\tmmap_write_unlock(me->mm);\n\t\tbreak;\n\tcase PR_MPX_ENABLE_MANAGEMENT:\n\tcase PR_MPX_DISABLE_MANAGEMENT:\n\t\t \n\t\treturn -EINVAL;\n\tcase PR_SET_FP_MODE:\n\t\terror = SET_FP_MODE(me, arg2);\n\t\tbreak;\n\tcase PR_GET_FP_MODE:\n\t\terror = GET_FP_MODE(me);\n\t\tbreak;\n\tcase PR_SVE_SET_VL:\n\t\terror = SVE_SET_VL(arg2);\n\t\tbreak;\n\tcase PR_SVE_GET_VL:\n\t\terror = SVE_GET_VL();\n\t\tbreak;\n\tcase PR_SME_SET_VL:\n\t\terror = SME_SET_VL(arg2);\n\t\tbreak;\n\tcase PR_SME_GET_VL:\n\t\terror = SME_GET_VL();\n\t\tbreak;\n\tcase PR_GET_SPECULATION_CTRL:\n\t\tif (arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = arch_prctl_spec_ctrl_get(me, arg2);\n\t\tbreak;\n\tcase PR_SET_SPECULATION_CTRL:\n\t\tif (arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = arch_prctl_spec_ctrl_set(me, arg2, arg3);\n\t\tbreak;\n\tcase PR_PAC_RESET_KEYS:\n\t\tif (arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = PAC_RESET_KEYS(me, arg2);\n\t\tbreak;\n\tcase PR_PAC_SET_ENABLED_KEYS:\n\t\tif (arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = PAC_SET_ENABLED_KEYS(me, arg2, arg3);\n\t\tbreak;\n\tcase PR_PAC_GET_ENABLED_KEYS:\n\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = PAC_GET_ENABLED_KEYS(me);\n\t\tbreak;\n\tcase PR_SET_TAGGED_ADDR_CTRL:\n\t\tif (arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = SET_TAGGED_ADDR_CTRL(arg2);\n\t\tbreak;\n\tcase PR_GET_TAGGED_ADDR_CTRL:\n\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = GET_TAGGED_ADDR_CTRL();\n\t\tbreak;\n\tcase PR_SET_IO_FLUSHER:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\n\t\tif (arg2 == 1)\n\t\t\tcurrent->flags |= PR_IO_FLUSHER;\n\t\telse if (!arg2)\n\t\t\tcurrent->flags &= ~PR_IO_FLUSHER;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PR_GET_IO_FLUSHER:\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\n\t\terror = (current->flags & PR_IO_FLUSHER) == PR_IO_FLUSHER;\n\t\tbreak;\n\tcase PR_SET_SYSCALL_USER_DISPATCH:\n\t\terror = set_syscall_user_dispatch(arg2, arg3, arg4,\n\t\t\t\t\t\t  (char __user *) arg5);\n\t\tbreak;\n#ifdef CONFIG_SCHED_CORE\n\tcase PR_SCHED_CORE:\n\t\terror = sched_core_share_pid(arg2, arg3, arg4, arg5);\n\t\tbreak;\n#endif\n\tcase PR_SET_MDWE:\n\t\terror = prctl_set_mdwe(arg2, arg3, arg4, arg5);\n\t\tbreak;\n\tcase PR_GET_MDWE:\n\t\terror = prctl_get_mdwe(arg2, arg3, arg4, arg5);\n\t\tbreak;\n\tcase PR_SET_VMA:\n\t\terror = prctl_set_vma(arg2, arg3, arg4, arg5);\n\t\tbreak;\n\tcase PR_GET_AUXV:\n\t\tif (arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\terror = prctl_get_auxv((void __user *)arg2, arg3);\n\t\tbreak;\n#ifdef CONFIG_KSM\n\tcase PR_SET_MEMORY_MERGE:\n\t\tif (arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\t\tif (mmap_write_lock_killable(me->mm))\n\t\t\treturn -EINTR;\n\n\t\tif (arg2)\n\t\t\terror = ksm_enable_merge_any(me->mm);\n\t\telse\n\t\t\terror = ksm_disable_merge_any(me->mm);\n\t\tmmap_write_unlock(me->mm);\n\t\tbreak;\n\tcase PR_GET_MEMORY_MERGE:\n\t\tif (arg2 || arg3 || arg4 || arg5)\n\t\t\treturn -EINVAL;\n\n\t\terror = !!test_bit(MMF_VM_MERGE_ANY, &me->mm->flags);\n\t\tbreak;\n#endif\n\tcase PR_RISCV_V_SET_CONTROL:\n\t\terror = RISCV_V_SET_CONTROL(arg2);\n\t\tbreak;\n\tcase PR_RISCV_V_GET_CONTROL:\n\t\terror = RISCV_V_GET_CONTROL();\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(getcpu, unsigned __user *, cpup, unsigned __user *, nodep,\n\t\tstruct getcpu_cache __user *, unused)\n{\n\tint err = 0;\n\tint cpu = raw_smp_processor_id();\n\n\tif (cpup)\n\t\terr |= put_user(cpu, cpup);\n\tif (nodep)\n\t\terr |= put_user(cpu_to_node(cpu), nodep);\n\treturn err ? -EFAULT : 0;\n}\n\n \nstatic int do_sysinfo(struct sysinfo *info)\n{\n\tunsigned long mem_total, sav_total;\n\tunsigned int mem_unit, bitcount;\n\tstruct timespec64 tp;\n\n\tmemset(info, 0, sizeof(struct sysinfo));\n\n\tktime_get_boottime_ts64(&tp);\n\ttimens_add_boottime(&tp);\n\tinfo->uptime = tp.tv_sec + (tp.tv_nsec ? 1 : 0);\n\n\tget_avenrun(info->loads, 0, SI_LOAD_SHIFT - FSHIFT);\n\n\tinfo->procs = nr_threads;\n\n\tsi_meminfo(info);\n\tsi_swapinfo(info);\n\n\t \n\n\tmem_total = info->totalram + info->totalswap;\n\tif (mem_total < info->totalram || mem_total < info->totalswap)\n\t\tgoto out;\n\tbitcount = 0;\n\tmem_unit = info->mem_unit;\n\twhile (mem_unit > 1) {\n\t\tbitcount++;\n\t\tmem_unit >>= 1;\n\t\tsav_total = mem_total;\n\t\tmem_total <<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t \n\n\tinfo->mem_unit = 1;\n\tinfo->totalram <<= bitcount;\n\tinfo->freeram <<= bitcount;\n\tinfo->sharedram <<= bitcount;\n\tinfo->bufferram <<= bitcount;\n\tinfo->totalswap <<= bitcount;\n\tinfo->freeswap <<= bitcount;\n\tinfo->totalhigh <<= bitcount;\n\tinfo->freehigh <<= bitcount;\n\nout:\n\treturn 0;\n}\n\nSYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)\n{\n\tstruct sysinfo val;\n\n\tdo_sysinfo(&val);\n\n\tif (copy_to_user(info, &val, sizeof(struct sysinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_sysinfo {\n\ts32 uptime;\n\tu32 loads[3];\n\tu32 totalram;\n\tu32 freeram;\n\tu32 sharedram;\n\tu32 bufferram;\n\tu32 totalswap;\n\tu32 freeswap;\n\tu16 procs;\n\tu16 pad;\n\tu32 totalhigh;\n\tu32 freehigh;\n\tu32 mem_unit;\n\tchar _f[20-2*sizeof(u32)-sizeof(int)];\n};\n\nCOMPAT_SYSCALL_DEFINE1(sysinfo, struct compat_sysinfo __user *, info)\n{\n\tstruct sysinfo s;\n\tstruct compat_sysinfo s_32;\n\n\tdo_sysinfo(&s);\n\n\t \n\tif (upper_32_bits(s.totalram) || upper_32_bits(s.totalswap)) {\n\t\tint bitcount = 0;\n\n\t\twhile (s.mem_unit < PAGE_SIZE) {\n\t\t\ts.mem_unit <<= 1;\n\t\t\tbitcount++;\n\t\t}\n\n\t\ts.totalram >>= bitcount;\n\t\ts.freeram >>= bitcount;\n\t\ts.sharedram >>= bitcount;\n\t\ts.bufferram >>= bitcount;\n\t\ts.totalswap >>= bitcount;\n\t\ts.freeswap >>= bitcount;\n\t\ts.totalhigh >>= bitcount;\n\t\ts.freehigh >>= bitcount;\n\t}\n\n\tmemset(&s_32, 0, sizeof(s_32));\n\ts_32.uptime = s.uptime;\n\ts_32.loads[0] = s.loads[0];\n\ts_32.loads[1] = s.loads[1];\n\ts_32.loads[2] = s.loads[2];\n\ts_32.totalram = s.totalram;\n\ts_32.freeram = s.freeram;\n\ts_32.sharedram = s.sharedram;\n\ts_32.bufferram = s.bufferram;\n\ts_32.totalswap = s.totalswap;\n\ts_32.freeswap = s.freeswap;\n\ts_32.procs = s.procs;\n\ts_32.totalhigh = s.totalhigh;\n\ts_32.freehigh = s.freehigh;\n\ts_32.mem_unit = s.mem_unit;\n\tif (copy_to_user(info, &s_32, sizeof(s_32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}