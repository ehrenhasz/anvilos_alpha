{
  "module_name": "seccomp.c",
  "hash_id": "823e60323086a69e917c91d7234c41b15e26629d8ee8b5d518b8b5fd99d04c93",
  "original_prompt": "Ingested from linux-6.6.14/kernel/seccomp.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"seccomp: \" fmt\n\n#include <linux/refcount.h>\n#include <linux/audit.h>\n#include <linux/compat.h>\n#include <linux/coredump.h>\n#include <linux/kmemleak.h>\n#include <linux/nospec.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/seccomp.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/sysctl.h>\n\n \n#define SECCOMP_MODE_DEAD\t(SECCOMP_MODE_FILTER + 1)\n\n#ifdef CONFIG_HAVE_ARCH_SECCOMP_FILTER\n#include <asm/syscall.h>\n#endif\n\n#ifdef CONFIG_SECCOMP_FILTER\n#include <linux/file.h>\n#include <linux/filter.h>\n#include <linux/pid.h>\n#include <linux/ptrace.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/lockdep.h>\n\n \n#define SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR\tSECCOMP_IOR(2, __u64)\n\nenum notify_state {\n\tSECCOMP_NOTIFY_INIT,\n\tSECCOMP_NOTIFY_SENT,\n\tSECCOMP_NOTIFY_REPLIED,\n};\n\nstruct seccomp_knotif {\n\t \n\tstruct task_struct *task;\n\n\t \n\tu64 id;\n\n\t \n\tconst struct seccomp_data *data;\n\n\t \n\tenum notify_state state;\n\n\t \n\tint error;\n\tlong val;\n\tu32 flags;\n\n\t \n\tstruct completion ready;\n\n\tstruct list_head list;\n\n\t \n\tstruct list_head addfd;\n};\n\n \nstruct seccomp_kaddfd {\n\tstruct file *file;\n\tint fd;\n\tunsigned int flags;\n\t__u32 ioctl_flags;\n\n\tunion {\n\t\tbool setfd;\n\t\t \n\t\tint ret;\n\t};\n\tstruct completion completion;\n\tstruct list_head list;\n};\n\n \n\nstruct notification {\n\tatomic_t requests;\n\tu32 flags;\n\tu64 next_id;\n\tstruct list_head notifications;\n};\n\n#ifdef SECCOMP_ARCH_NATIVE\n \nstruct action_cache {\n\tDECLARE_BITMAP(allow_native, SECCOMP_ARCH_NATIVE_NR);\n#ifdef SECCOMP_ARCH_COMPAT\n\tDECLARE_BITMAP(allow_compat, SECCOMP_ARCH_COMPAT_NR);\n#endif\n};\n#else\nstruct action_cache { };\n\nstatic inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\treturn false;\n}\n\nstatic inline void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n}\n#endif  \n\n \nstruct seccomp_filter {\n\trefcount_t refs;\n\trefcount_t users;\n\tbool log;\n\tbool wait_killable_recv;\n\tstruct action_cache cache;\n\tstruct seccomp_filter *prev;\n\tstruct bpf_prog *prog;\n\tstruct notification *notif;\n\tstruct mutex notify_lock;\n\twait_queue_head_t wqh;\n};\n\n \n#define MAX_INSNS_PER_PATH ((1 << 18) / sizeof(struct sock_filter))\n\n \nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\t \n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->nr = syscall_get_nr(task, regs);\n\tsd->arch = syscall_get_arch(task);\n\tsyscall_get_arguments(task, regs, args);\n\tsd->args[0] = args[0];\n\tsd->args[1] = args[1];\n\tsd->args[2] = args[2];\n\tsd->args[3] = args[3];\n\tsd->args[4] = args[4];\n\tsd->args[5] = args[5];\n\tsd->instruction_pointer = KSTK_EIP(task);\n}\n\n \nstatic int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)\n{\n\tint pc;\n\tfor (pc = 0; pc < flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->code;\n\t\tu32 k = ftest->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tftest->code = BPF_LDX | BPF_W | BPF_ABS;\n\t\t\t \n\t\t\tif (k >= sizeof(struct seccomp_data) || k & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tcontinue;\n\t\tcase BPF_LD | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LD | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\tcase BPF_LDX | BPF_W | BPF_LEN:\n\t\t\tftest->code = BPF_LDX | BPF_IMM;\n\t\t\tftest->k = sizeof(struct seccomp_data);\n\t\t\tcontinue;\n\t\t \n\t\tcase BPF_RET | BPF_K:\n\t\tcase BPF_RET | BPF_A:\n\t\tcase BPF_ALU | BPF_ADD | BPF_K:\n\t\tcase BPF_ALU | BPF_ADD | BPF_X:\n\t\tcase BPF_ALU | BPF_SUB | BPF_K:\n\t\tcase BPF_ALU | BPF_SUB | BPF_X:\n\t\tcase BPF_ALU | BPF_MUL | BPF_K:\n\t\tcase BPF_ALU | BPF_MUL | BPF_X:\n\t\tcase BPF_ALU | BPF_DIV | BPF_K:\n\t\tcase BPF_ALU | BPF_DIV | BPF_X:\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\tcase BPF_ALU | BPF_AND | BPF_X:\n\t\tcase BPF_ALU | BPF_OR | BPF_K:\n\t\tcase BPF_ALU | BPF_OR | BPF_X:\n\t\tcase BPF_ALU | BPF_XOR | BPF_K:\n\t\tcase BPF_ALU | BPF_XOR | BPF_X:\n\t\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\tcase BPF_ALU | BPF_NEG:\n\t\tcase BPF_LD | BPF_IMM:\n\t\tcase BPF_LDX | BPF_IMM:\n\t\tcase BPF_MISC | BPF_TAX:\n\t\tcase BPF_MISC | BPF_TXA:\n\t\tcase BPF_LD | BPF_MEM:\n\t\tcase BPF_LDX | BPF_MEM:\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\tcase BPF_JMP | BPF_JA:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_X:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_X:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_X:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifdef SECCOMP_ARCH_NATIVE\nstatic inline bool seccomp_cache_check_allow_bitmap(const void *bitmap,\n\t\t\t\t\t\t    size_t bitmap_size,\n\t\t\t\t\t\t    int syscall_nr)\n{\n\tif (unlikely(syscall_nr < 0 || syscall_nr >= bitmap_size))\n\t\treturn false;\n\tsyscall_nr = array_index_nospec(syscall_nr, bitmap_size);\n\n\treturn test_bit(syscall_nr, bitmap);\n}\n\n \nstatic inline bool seccomp_cache_check_allow(const struct seccomp_filter *sfilter,\n\t\t\t\t\t     const struct seccomp_data *sd)\n{\n\tint syscall_nr = sd->nr;\n\tconst struct action_cache *cache = &sfilter->cache;\n\n#ifndef SECCOMP_ARCH_COMPAT\n\t \n\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\tsyscall_nr);\n#else\n\tif (likely(sd->arch == SECCOMP_ARCH_NATIVE))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_native,\n\t\t\t\t\t\t\tSECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n\tif (likely(sd->arch == SECCOMP_ARCH_COMPAT))\n\t\treturn seccomp_cache_check_allow_bitmap(cache->allow_compat,\n\t\t\t\t\t\t\tSECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t\t\t\tsyscall_nr);\n#endif  \n\n\tWARN_ON_ONCE(true);\n\treturn false;\n}\n#endif  \n\n#define ACTION_ONLY(ret) ((s32)((ret) & (SECCOMP_RET_ACTION_FULL)))\n \nstatic u32 seccomp_run_filters(const struct seccomp_data *sd,\n\t\t\t       struct seccomp_filter **match)\n{\n\tu32 ret = SECCOMP_RET_ALLOW;\n\t \n\tstruct seccomp_filter *f =\n\t\t\tREAD_ONCE(current->seccomp.filter);\n\n\t \n\tif (WARN_ON(f == NULL))\n\t\treturn SECCOMP_RET_KILL_PROCESS;\n\n\tif (seccomp_cache_check_allow(f, sd))\n\t\treturn SECCOMP_RET_ALLOW;\n\n\t \n\tfor (; f; f = f->prev) {\n\t\tu32 cur_ret = bpf_prog_run_pin_on_cpu(f->prog, sd);\n\n\t\tif (ACTION_ONLY(cur_ret) < ACTION_ONLY(ret)) {\n\t\t\tret = cur_ret;\n\t\t\t*match = f;\n\t\t}\n\t}\n\treturn ret;\n}\n#endif  \n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->sighand->siglock);\n\n\tif (current->seccomp.mode && current->seccomp.mode != seccomp_mode)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid __weak arch_seccomp_spec_mitigate(struct task_struct *task) { }\n\nstatic inline void seccomp_assign_mode(struct task_struct *task,\n\t\t\t\t       unsigned long seccomp_mode,\n\t\t\t\t       unsigned long flags)\n{\n\tassert_spin_locked(&task->sighand->siglock);\n\n\ttask->seccomp.mode = seccomp_mode;\n\t \n\tsmp_mb__before_atomic();\n\t \n\tif ((flags & SECCOMP_FILTER_FLAG_SPEC_ALLOW) == 0)\n\t\tarch_seccomp_spec_mitigate(task);\n\tset_task_syscall_work(task, SECCOMP);\n}\n\n#ifdef CONFIG_SECCOMP_FILTER\n \nstatic int is_ancestor(struct seccomp_filter *parent,\n\t\t       struct seccomp_filter *child)\n{\n\t \n\tif (parent == NULL)\n\t\treturn 1;\n\tfor (; child; child = child->prev)\n\t\tif (child == parent)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline pid_t seccomp_can_sync_threads(void)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t \n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\tpid_t failed;\n\n\t\t \n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED ||\n\t\t    (thread->seccomp.mode == SECCOMP_MODE_FILTER &&\n\t\t     is_ancestor(thread->seccomp.filter,\n\t\t\t\t caller->seccomp.filter)))\n\t\t\tcontinue;\n\n\t\t \n\t\tfailed = task_pid_vnr(thread);\n\t\t \n\t\tif (WARN_ON(failed == 0))\n\t\t\tfailed = -ESRCH;\n\t\treturn failed;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void seccomp_filter_free(struct seccomp_filter *filter)\n{\n\tif (filter) {\n\t\tbpf_prog_destroy(filter->prog);\n\t\tkfree(filter);\n\t}\n}\n\nstatic void __seccomp_filter_orphan(struct seccomp_filter *orig)\n{\n\twhile (orig && refcount_dec_and_test(&orig->users)) {\n\t\tif (waitqueue_active(&orig->wqh))\n\t\t\twake_up_poll(&orig->wqh, EPOLLHUP);\n\t\torig = orig->prev;\n\t}\n}\n\nstatic void __put_seccomp_filter(struct seccomp_filter *orig)\n{\n\t \n\twhile (orig && refcount_dec_and_test(&orig->refs)) {\n\t\tstruct seccomp_filter *freeme = orig;\n\t\torig = orig->prev;\n\t\tseccomp_filter_free(freeme);\n\t}\n}\n\nstatic void __seccomp_filter_release(struct seccomp_filter *orig)\n{\n\t \n\t__seccomp_filter_orphan(orig);\n\t \n\t__put_seccomp_filter(orig);\n}\n\n \nvoid seccomp_filter_release(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\n\t \n\tWARN_ON(tsk->sighand != NULL);\n\n\t \n\ttsk->seccomp.filter = NULL;\n\t__seccomp_filter_release(orig);\n}\n\n \nstatic inline void seccomp_sync_threads(unsigned long flags)\n{\n\tstruct task_struct *thread, *caller;\n\n\tBUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t \n\tcaller = current;\n\tfor_each_thread(caller, thread) {\n\t\t \n\t\tif (thread == caller)\n\t\t\tcontinue;\n\n\t\t \n\t\tget_seccomp_filter(caller);\n\n\t\t \n\t\t__seccomp_filter_release(thread->seccomp.filter);\n\n\t\t \n\t\tsmp_store_release(&thread->seccomp.filter,\n\t\t\t\t  caller->seccomp.filter);\n\t\tatomic_set(&thread->seccomp.filter_count,\n\t\t\t   atomic_read(&caller->seccomp.filter_count));\n\n\t\t \n\t\tif (task_no_new_privs(caller))\n\t\t\ttask_set_no_new_privs(thread);\n\n\t\t \n\t\tif (thread->seccomp.mode == SECCOMP_MODE_DISABLED)\n\t\t\tseccomp_assign_mode(thread, SECCOMP_MODE_FILTER,\n\t\t\t\t\t    flags);\n\t}\n}\n\n \nstatic struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)\n{\n\tstruct seccomp_filter *sfilter;\n\tint ret;\n\tconst bool save_orig =\n#if defined(CONFIG_CHECKPOINT_RESTORE) || defined(SECCOMP_ARCH_NATIVE)\n\t\ttrue;\n#else\n\t\tfalse;\n#endif\n\n\tif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUG_ON(INT_MAX / fprog->len < sizeof(struct sock_filter));\n\n\t \n\tif (!task_no_new_privs(current) &&\n\t\t\t!ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EACCES);\n\n\t \n\tsfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!sfilter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&sfilter->notify_lock);\n\tret = bpf_prog_create_from_user(&sfilter->prog, fprog,\n\t\t\t\t\tseccomp_check_filter, save_orig);\n\tif (ret < 0) {\n\t\tkfree(sfilter);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trefcount_set(&sfilter->refs, 1);\n\trefcount_set(&sfilter->users, 1);\n\tinit_waitqueue_head(&sfilter->wqh);\n\n\treturn sfilter;\n}\n\n \nstatic struct seccomp_filter *\nseccomp_prepare_user_filter(const char __user *user_filter)\n{\n\tstruct sock_fprog fprog;\n\tstruct seccomp_filter *filter = ERR_PTR(-EFAULT);\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sock_fprog fprog32;\n\t\tif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\n\t\t\tgoto out;\n\t\tfprog.len = fprog32.len;\n\t\tfprog.filter = compat_ptr(fprog32.filter);\n\t} else  \n#endif\n\tif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\n\t\tgoto out;\n\tfilter = seccomp_prepare_filter(&fprog);\nout:\n\treturn filter;\n}\n\n#ifdef SECCOMP_ARCH_NATIVE\n \nstatic bool seccomp_is_const_allow(struct sock_fprog_kern *fprog,\n\t\t\t\t   struct seccomp_data *sd)\n{\n\tunsigned int reg_value = 0;\n\tunsigned int pc;\n\tbool op_res;\n\n\tif (WARN_ON_ONCE(!fprog))\n\t\treturn false;\n\n\tfor (pc = 0; pc < fprog->len; pc++) {\n\t\tstruct sock_filter *insn = &fprog->filter[pc];\n\t\tu16 code = insn->code;\n\t\tu32 k = insn->k;\n\n\t\tswitch (code) {\n\t\tcase BPF_LD | BPF_W | BPF_ABS:\n\t\t\tswitch (k) {\n\t\t\tcase offsetof(struct seccomp_data, nr):\n\t\t\t\treg_value = sd->nr;\n\t\t\t\tbreak;\n\t\t\tcase offsetof(struct seccomp_data, arch):\n\t\t\t\treg_value = sd->arch;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET | BPF_K:\n\t\t\t \n\t\t\treturn k == SECCOMP_RET_ALLOW;\n\t\tcase BPF_JMP | BPF_JA:\n\t\t\tpc += insn->k;\n\t\t\tbreak;\n\t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\t\tcase BPF_JMP | BPF_JGE | BPF_K:\n\t\tcase BPF_JMP | BPF_JGT | BPF_K:\n\t\tcase BPF_JMP | BPF_JSET | BPF_K:\n\t\t\tswitch (BPF_OP(code)) {\n\t\t\tcase BPF_JEQ:\n\t\t\t\top_res = reg_value == k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGE:\n\t\t\t\top_res = reg_value >= k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JGT:\n\t\t\t\top_res = reg_value > k;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JSET:\n\t\t\t\top_res = !!(reg_value & k);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpc += op_res ? insn->jt : insn->jf;\n\t\t\tbreak;\n\t\tcase BPF_ALU | BPF_AND | BPF_K:\n\t\t\treg_value &= k;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tWARN_ON(1);\n\treturn false;\n}\n\nstatic void seccomp_cache_prepare_bitmap(struct seccomp_filter *sfilter,\n\t\t\t\t\t void *bitmap, const void *bitmap_prev,\n\t\t\t\t\t size_t bitmap_size, int arch)\n{\n\tstruct sock_fprog_kern *fprog = sfilter->prog->orig_prog;\n\tstruct seccomp_data sd;\n\tint nr;\n\n\tif (bitmap_prev) {\n\t\t \n\t\tbitmap_copy(bitmap, bitmap_prev, bitmap_size);\n\t} else {\n\t\t \n\t\tbitmap_fill(bitmap, bitmap_size);\n\t}\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\t \n\t\tif (!test_bit(nr, bitmap))\n\t\t\tcontinue;\n\n\t\tsd.nr = nr;\n\t\tsd.arch = arch;\n\n\t\t \n\t\tif (seccomp_is_const_allow(fprog, &sd))\n\t\t\tcontinue;\n\n\t\t \n\t\t__clear_bit(nr, bitmap);\n\t}\n}\n\n \nstatic void seccomp_cache_prepare(struct seccomp_filter *sfilter)\n{\n\tstruct action_cache *cache = &sfilter->cache;\n\tconst struct action_cache *cache_prev =\n\t\tsfilter->prev ? &sfilter->prev->cache : NULL;\n\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_native,\n\t\t\t\t     cache_prev ? cache_prev->allow_native : NULL,\n\t\t\t\t     SECCOMP_ARCH_NATIVE_NR,\n\t\t\t\t     SECCOMP_ARCH_NATIVE);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tseccomp_cache_prepare_bitmap(sfilter, cache->allow_compat,\n\t\t\t\t     cache_prev ? cache_prev->allow_compat : NULL,\n\t\t\t\t     SECCOMP_ARCH_COMPAT_NR,\n\t\t\t\t     SECCOMP_ARCH_COMPAT);\n#endif  \n}\n#endif  \n\n \nstatic long seccomp_attach_filter(unsigned int flags,\n\t\t\t\t  struct seccomp_filter *filter)\n{\n\tunsigned long total_insns;\n\tstruct seccomp_filter *walker;\n\n\tassert_spin_locked(&current->sighand->siglock);\n\n\t \n\ttotal_insns = filter->prog->len;\n\tfor (walker = current->seccomp.filter; walker; walker = walker->prev)\n\t\ttotal_insns += walker->prog->len + 4;   \n\tif (total_insns > MAX_INSNS_PER_PATH)\n\t\treturn -ENOMEM;\n\n\t \n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC) {\n\t\tint ret;\n\n\t\tret = seccomp_can_sync_threads();\n\t\tif (ret) {\n\t\t\tif (flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH)\n\t\t\t\treturn -ESRCH;\n\t\t\telse\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (flags & SECCOMP_FILTER_FLAG_LOG)\n\t\tfilter->log = true;\n\n\t \n\tif (flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV)\n\t\tfilter->wait_killable_recv = true;\n\n\t \n\tfilter->prev = current->seccomp.filter;\n\tseccomp_cache_prepare(filter);\n\tcurrent->seccomp.filter = filter;\n\tatomic_inc(&current->seccomp.filter_count);\n\n\t \n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tseccomp_sync_threads(flags);\n\n\treturn 0;\n}\n\nstatic void __get_seccomp_filter(struct seccomp_filter *filter)\n{\n\trefcount_inc(&filter->refs);\n}\n\n \nvoid get_seccomp_filter(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\tif (!orig)\n\t\treturn;\n\t__get_seccomp_filter(orig);\n\trefcount_inc(&orig->users);\n}\n\n#endif\t \n\n \n#define SECCOMP_LOG_KILL_PROCESS\t(1 << 0)\n#define SECCOMP_LOG_KILL_THREAD\t\t(1 << 1)\n#define SECCOMP_LOG_TRAP\t\t(1 << 2)\n#define SECCOMP_LOG_ERRNO\t\t(1 << 3)\n#define SECCOMP_LOG_TRACE\t\t(1 << 4)\n#define SECCOMP_LOG_LOG\t\t\t(1 << 5)\n#define SECCOMP_LOG_ALLOW\t\t(1 << 6)\n#define SECCOMP_LOG_USER_NOTIF\t\t(1 << 7)\n\nstatic u32 seccomp_actions_logged = SECCOMP_LOG_KILL_PROCESS |\n\t\t\t\t    SECCOMP_LOG_KILL_THREAD  |\n\t\t\t\t    SECCOMP_LOG_TRAP  |\n\t\t\t\t    SECCOMP_LOG_ERRNO |\n\t\t\t\t    SECCOMP_LOG_USER_NOTIF |\n\t\t\t\t    SECCOMP_LOG_TRACE |\n\t\t\t\t    SECCOMP_LOG_LOG;\n\nstatic inline void seccomp_log(unsigned long syscall, long signr, u32 action,\n\t\t\t       bool requested)\n{\n\tbool log = false;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tcase SECCOMP_RET_TRAP:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRAP;\n\t\tbreak;\n\tcase SECCOMP_RET_ERRNO:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_ERRNO;\n\t\tbreak;\n\tcase SECCOMP_RET_TRACE:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_TRACE;\n\t\tbreak;\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tlog = requested && seccomp_actions_logged & SECCOMP_LOG_USER_NOTIF;\n\t\tbreak;\n\tcase SECCOMP_RET_LOG:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_LOG;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_THREAD:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_THREAD;\n\t\tbreak;\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tlog = seccomp_actions_logged & SECCOMP_LOG_KILL_PROCESS;\n\t}\n\n\t \n\tif (!log)\n\t\treturn;\n\n\taudit_seccomp(syscall, signr, action);\n}\n\n \nstatic const int mode1_syscalls[] = {\n\t__NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn,\n\t-1,  \n};\n\nstatic void __secure_computing_strict(int this_syscall)\n{\n\tconst int *allowed_syscalls = mode1_syscalls;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\tallowed_syscalls = get_compat_mode1_syscalls();\n#endif\n\tdo {\n\t\tif (*allowed_syscalls == this_syscall)\n\t\t\treturn;\n\t} while (*++allowed_syscalls != -1);\n\n#ifdef SECCOMP_DEBUG\n\tdump_stack();\n#endif\n\tcurrent->seccomp.mode = SECCOMP_MODE_DEAD;\n\tseccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);\n\tdo_exit(SIGKILL);\n}\n\n#ifndef CONFIG_HAVE_ARCH_SECCOMP_FILTER\nvoid secure_computing_strict(int this_syscall)\n{\n\tint mode = current->seccomp.mode;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn;\n\n\tif (mode == SECCOMP_MODE_DISABLED)\n\t\treturn;\n\telse if (mode == SECCOMP_MODE_STRICT)\n\t\t__secure_computing_strict(this_syscall);\n\telse\n\t\tBUG();\n}\n#else\n\n#ifdef CONFIG_SECCOMP_FILTER\nstatic u64 seccomp_next_notify_id(struct seccomp_filter *filter)\n{\n\t \n\tlockdep_assert_held(&filter->notify_lock);\n\treturn filter->notif->next_id++;\n}\n\nstatic void seccomp_handle_addfd(struct seccomp_kaddfd *addfd, struct seccomp_knotif *n)\n{\n\tint fd;\n\n\t \n\tlist_del_init(&addfd->list);\n\tif (!addfd->setfd)\n\t\tfd = receive_fd(addfd->file, addfd->flags);\n\telse\n\t\tfd = receive_fd_replace(addfd->fd, addfd->file, addfd->flags);\n\taddfd->ret = fd;\n\n\tif (addfd->ioctl_flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t \n\t\tif (fd < 0) {\n\t\t\tn->state = SECCOMP_NOTIFY_SENT;\n\t\t} else {\n\t\t\t \n\t\t\tn->flags = 0;\n\t\t\tn->error = 0;\n\t\t\tn->val = fd;\n\t\t}\n\t}\n\n\t \n\tcomplete(&addfd->completion);\n}\n\nstatic bool should_sleep_killable(struct seccomp_filter *match,\n\t\t\t\t  struct seccomp_knotif *n)\n{\n\treturn match->wait_killable_recv && n->state == SECCOMP_NOTIFY_SENT;\n}\n\nstatic int seccomp_do_user_notification(int this_syscall,\n\t\t\t\t\tstruct seccomp_filter *match,\n\t\t\t\t\tconst struct seccomp_data *sd)\n{\n\tint err;\n\tu32 flags = 0;\n\tlong ret = 0;\n\tstruct seccomp_knotif n = {};\n\tstruct seccomp_kaddfd *addfd, *tmp;\n\n\tmutex_lock(&match->notify_lock);\n\terr = -ENOSYS;\n\tif (!match->notif)\n\t\tgoto out;\n\n\tn.task = current;\n\tn.state = SECCOMP_NOTIFY_INIT;\n\tn.data = sd;\n\tn.id = seccomp_next_notify_id(match);\n\tinit_completion(&n.ready);\n\tlist_add_tail(&n.list, &match->notif->notifications);\n\tINIT_LIST_HEAD(&n.addfd);\n\n\tatomic_inc(&match->notif->requests);\n\tif (match->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)\n\t\twake_up_poll_on_current_cpu(&match->wqh, EPOLLIN | EPOLLRDNORM);\n\telse\n\t\twake_up_poll(&match->wqh, EPOLLIN | EPOLLRDNORM);\n\n\t \n\tdo {\n\t\tbool wait_killable = should_sleep_killable(match, &n);\n\n\t\tmutex_unlock(&match->notify_lock);\n\t\tif (wait_killable)\n\t\t\terr = wait_for_completion_killable(&n.ready);\n\t\telse\n\t\t\terr = wait_for_completion_interruptible(&n.ready);\n\t\tmutex_lock(&match->notify_lock);\n\n\t\tif (err != 0) {\n\t\t\t \n\t\t\tif (!wait_killable && should_sleep_killable(match, &n))\n\t\t\t\tcontinue;\n\n\t\t\tgoto interrupted;\n\t\t}\n\n\t\taddfd = list_first_entry_or_null(&n.addfd,\n\t\t\t\t\t\t struct seccomp_kaddfd, list);\n\t\t \n\t\tif (addfd)\n\t\t\tseccomp_handle_addfd(addfd, &n);\n\n\t}  while (n.state != SECCOMP_NOTIFY_REPLIED);\n\n\tret = n.val;\n\terr = n.error;\n\tflags = n.flags;\n\ninterrupted:\n\t \n\tlist_for_each_entry_safe(addfd, tmp, &n.addfd, list) {\n\t\t \n\t\taddfd->ret = -ESRCH;\n\t\tlist_del_init(&addfd->list);\n\t\tcomplete(&addfd->completion);\n\t}\n\n\t \n\tif (match->notif)\n\t\tlist_del(&n.list);\nout:\n\tmutex_unlock(&match->notify_lock);\n\n\t \n\tif (flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn 0;\n\n\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t err, ret);\n\treturn -1;\n}\n\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tu32 filter_ret, action;\n\tstruct seccomp_filter *match = NULL;\n\tint data;\n\tstruct seccomp_data sd_local;\n\n\t \n\tsmp_rmb();\n\n\tif (!sd) {\n\t\tpopulate_seccomp_data(&sd_local);\n\t\tsd = &sd_local;\n\t}\n\n\tfilter_ret = seccomp_run_filters(sd, &match);\n\tdata = filter_ret & SECCOMP_RET_DATA;\n\taction = filter_ret & SECCOMP_RET_ACTION_FULL;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_ERRNO:\n\t\t \n\t\tif (data > MAX_ERRNO)\n\t\t\tdata = MAX_ERRNO;\n\t\tsyscall_set_return_value(current, current_pt_regs(),\n\t\t\t\t\t -data, 0);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRAP:\n\t\t \n\t\tsyscall_rollback(current, current_pt_regs());\n\t\t \n\t\tforce_sig_seccomp(this_syscall, data, false);\n\t\tgoto skip;\n\n\tcase SECCOMP_RET_TRACE:\n\t\t \n\t\tif (recheck_after_trace)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {\n\t\t\tsyscall_set_return_value(current,\n\t\t\t\t\t\t current_pt_regs(),\n\t\t\t\t\t\t -ENOSYS, 0);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t \n\t\tptrace_event(PTRACE_EVENT_SECCOMP, data);\n\t\t \n\t\tif (fatal_signal_pending(current))\n\t\t\tgoto skip;\n\t\t \n\t\tthis_syscall = syscall_get_nr(current, current_pt_regs());\n\t\tif (this_syscall < 0)\n\t\t\tgoto skip;\n\n\t\t \n\t\tif (__seccomp_filter(this_syscall, NULL, true))\n\t\t\treturn -1;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_USER_NOTIF:\n\t\tif (seccomp_do_user_notification(this_syscall, match, sd))\n\t\t\tgoto skip;\n\n\t\treturn 0;\n\n\tcase SECCOMP_RET_LOG:\n\t\tseccomp_log(this_syscall, 0, action, true);\n\t\treturn 0;\n\n\tcase SECCOMP_RET_ALLOW:\n\t\t \n\t\treturn 0;\n\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tdefault:\n\t\tcurrent->seccomp.mode = SECCOMP_MODE_DEAD;\n\t\tseccomp_log(this_syscall, SIGSYS, action, true);\n\t\t \n\t\tif (action != SECCOMP_RET_KILL_THREAD ||\n\t\t    (atomic_read(&current->signal->live) == 1)) {\n\t\t\t \n\t\t\tsyscall_rollback(current, current_pt_regs());\n\t\t\t \n\t\t\tforce_sig_seccomp(this_syscall, data, true);\n\t\t} else {\n\t\t\tdo_exit(SIGSYS);\n\t\t}\n\t\treturn -1;  \n\t}\n\n\tunreachable();\n\nskip:\n\tseccomp_log(this_syscall, 0, action, match ? match->log : false);\n\treturn -1;\n}\n#else\nstatic int __seccomp_filter(int this_syscall, const struct seccomp_data *sd,\n\t\t\t    const bool recheck_after_trace)\n{\n\tBUG();\n\n\treturn -1;\n}\n#endif\n\nint __secure_computing(const struct seccomp_data *sd)\n{\n\tint mode = current->seccomp.mode;\n\tint this_syscall;\n\n\tif (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &&\n\t    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))\n\t\treturn 0;\n\n\tthis_syscall = sd ? sd->nr :\n\t\tsyscall_get_nr(current, current_pt_regs());\n\n\tswitch (mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\t__secure_computing_strict(this_syscall);   \n\t\treturn 0;\n\tcase SECCOMP_MODE_FILTER:\n\t\treturn __seccomp_filter(this_syscall, sd, false);\n\t \n\tcase SECCOMP_MODE_DEAD:\n\t\tWARN_ON_ONCE(1);\n\t\tdo_exit(SIGKILL);\n\t\treturn -1;\n\tdefault:\n\t\tBUG();\n\t}\n}\n#endif  \n\nlong prctl_get_seccomp(void)\n{\n\treturn current->seccomp.mode;\n}\n\n \nstatic long seccomp_set_mode_strict(void)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_STRICT;\n\tlong ret = -EINVAL;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n#ifdef TIF_NOTSC\n\tdisable_TSC();\n#endif\n\tseccomp_assign_mode(current, seccomp_mode, 0);\n\tret = 0;\n\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SECCOMP_FILTER\nstatic void seccomp_notify_free(struct seccomp_filter *filter)\n{\n\tkfree(filter->notif);\n\tfilter->notif = NULL;\n}\n\nstatic void seccomp_notify_detach(struct seccomp_filter *filter)\n{\n\tstruct seccomp_knotif *knotif;\n\n\tif (!filter)\n\t\treturn;\n\n\tmutex_lock(&filter->notify_lock);\n\n\t \n\tlist_for_each_entry(knotif, &filter->notif->notifications, list) {\n\t\tif (knotif->state == SECCOMP_NOTIFY_REPLIED)\n\t\t\tcontinue;\n\n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t\tknotif->error = -ENOSYS;\n\t\tknotif->val = 0;\n\n\t\t \n\t\tcomplete(&knotif->ready);\n\t}\n\n\tseccomp_notify_free(filter);\n\tmutex_unlock(&filter->notify_lock);\n}\n\nstatic int seccomp_notify_release(struct inode *inode, struct file *file)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\n\tseccomp_notify_detach(filter);\n\t__put_seccomp_filter(filter);\n\treturn 0;\n}\n\n \nstatic inline struct seccomp_knotif *\nfind_notification(struct seccomp_filter *filter, u64 id)\n{\n\tstruct seccomp_knotif *cur;\n\n\tlockdep_assert_held(&filter->notify_lock);\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->id == id)\n\t\t\treturn cur;\n\t}\n\n\treturn NULL;\n}\n\nstatic int recv_wake_function(wait_queue_entry_t *wait, unsigned int mode, int sync,\n\t\t\t\t  void *key)\n{\n\t \n\tif (key && !(key_to_poll(key) & (EPOLLIN | EPOLLERR)))\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}\n\nstatic int recv_wait_event(struct seccomp_filter *filter)\n{\n\tDEFINE_WAIT_FUNC(wait, recv_wake_function);\n\tint ret;\n\n\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tret = prepare_to_wait_event(&filter->wqh, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (atomic_dec_if_positive(&filter->notif->requests) >= 0)\n\t\t\tbreak;\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tschedule();\n\t}\n\tfinish_wait(&filter->wqh, &wait);\n\treturn 0;\n}\n\nstatic long seccomp_notify_recv(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_knotif *knotif = NULL, *cur;\n\tstruct seccomp_notif unotif;\n\tssize_t ret;\n\n\t \n\tret = check_zeroed_user(buf, sizeof(unotif));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tmemset(&unotif, 0, sizeof(unotif));\n\n\tret = recv_wait_event(filter);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&filter->notify_lock);\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT) {\n\t\t\tknotif = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tunotif.id = knotif->id;\n\tunotif.pid = task_pid_vnr(knotif->task);\n\tunotif.data = *(knotif->data);\n\n\tknotif->state = SECCOMP_NOTIFY_SENT;\n\twake_up_poll(&filter->wqh, EPOLLOUT | EPOLLWRNORM);\n\tret = 0;\nout:\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (ret == 0 && copy_to_user(buf, &unotif, sizeof(unotif))) {\n\t\tret = -EFAULT;\n\n\t\t \n\t\tmutex_lock(&filter->notify_lock);\n\t\tknotif = find_notification(filter, unotif.id);\n\t\tif (knotif) {\n\t\t\t \n\t\t\tif (should_sleep_killable(filter, knotif))\n\t\t\t\tcomplete(&knotif->ready);\n\t\t\tknotif->state = SECCOMP_NOTIFY_INIT;\n\t\t\tatomic_inc(&filter->notif->requests);\n\t\t\twake_up_poll(&filter->wqh, EPOLLIN | EPOLLRDNORM);\n\t\t}\n\t\tmutex_unlock(&filter->notify_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic long seccomp_notify_send(struct seccomp_filter *filter,\n\t\t\t\tvoid __user *buf)\n{\n\tstruct seccomp_notif_resp resp = {};\n\tstruct seccomp_knotif *knotif;\n\tlong ret;\n\n\tif (copy_from_user(&resp, buf, sizeof(resp)))\n\t\treturn -EFAULT;\n\n\tif (resp.flags & ~SECCOMP_USER_NOTIF_FLAG_CONTINUE)\n\t\treturn -EINVAL;\n\n\tif ((resp.flags & SECCOMP_USER_NOTIF_FLAG_CONTINUE) &&\n\t    (resp.error || resp.val))\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, resp.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\tknotif->error = resp.error;\n\tknotif->val = resp.val;\n\tknotif->flags = resp.flags;\n\tif (filter->notif->flags & SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)\n\t\tcomplete_on_current_cpu(&knotif->ready);\n\telse\n\t\tcomplete(&knotif->ready);\nout:\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}\n\nstatic long seccomp_notify_id_valid(struct seccomp_filter *filter,\n\t\t\t\t    void __user *buf)\n{\n\tstruct seccomp_knotif *knotif;\n\tu64 id;\n\tlong ret;\n\n\tif (copy_from_user(&id, buf, sizeof(id)))\n\t\treturn -EFAULT;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tknotif = find_notification(filter, id);\n\tif (knotif && knotif->state == SECCOMP_NOTIFY_SENT)\n\t\tret = 0;\n\telse\n\t\tret = -ENOENT;\n\n\tmutex_unlock(&filter->notify_lock);\n\treturn ret;\n}\n\nstatic long seccomp_notify_set_flags(struct seccomp_filter *filter,\n\t\t\t\t    unsigned long flags)\n{\n\tlong ret;\n\n\tif (flags & ~SECCOMP_USER_NOTIF_FD_SYNC_WAKE_UP)\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\treturn ret;\n\tfilter->notif->flags = flags;\n\tmutex_unlock(&filter->notify_lock);\n\treturn 0;\n}\n\nstatic long seccomp_notify_addfd(struct seccomp_filter *filter,\n\t\t\t\t struct seccomp_notif_addfd __user *uaddfd,\n\t\t\t\t unsigned int size)\n{\n\tstruct seccomp_notif_addfd addfd;\n\tstruct seccomp_knotif *knotif;\n\tstruct seccomp_kaddfd kaddfd;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(addfd) < SECCOMP_NOTIFY_ADDFD_SIZE_VER0);\n\tBUILD_BUG_ON(sizeof(addfd) != SECCOMP_NOTIFY_ADDFD_SIZE_LATEST);\n\n\tif (size < SECCOMP_NOTIFY_ADDFD_SIZE_VER0 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = copy_struct_from_user(&addfd, sizeof(addfd), uaddfd, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addfd.newfd_flags & ~O_CLOEXEC)\n\t\treturn -EINVAL;\n\n\tif (addfd.flags & ~(SECCOMP_ADDFD_FLAG_SETFD | SECCOMP_ADDFD_FLAG_SEND))\n\t\treturn -EINVAL;\n\n\tif (addfd.newfd && !(addfd.flags & SECCOMP_ADDFD_FLAG_SETFD))\n\t\treturn -EINVAL;\n\n\tkaddfd.file = fget(addfd.srcfd);\n\tif (!kaddfd.file)\n\t\treturn -EBADF;\n\n\tkaddfd.ioctl_flags = addfd.flags;\n\tkaddfd.flags = addfd.newfd_flags;\n\tkaddfd.setfd = addfd.flags & SECCOMP_ADDFD_FLAG_SETFD;\n\tkaddfd.fd = addfd.newfd;\n\tinit_completion(&kaddfd.completion);\n\n\tret = mutex_lock_interruptible(&filter->notify_lock);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tknotif = find_notification(filter, addfd.id);\n\tif (!knotif) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (knotif->state != SECCOMP_NOTIFY_SENT) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_unlock;\n\t}\n\n\tif (addfd.flags & SECCOMP_ADDFD_FLAG_SEND) {\n\t\t \n\t\tif (!list_empty(&knotif->addfd)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tknotif->state = SECCOMP_NOTIFY_REPLIED;\n\t}\n\n\tlist_add(&kaddfd.list, &knotif->addfd);\n\tcomplete(&knotif->ready);\n\tmutex_unlock(&filter->notify_lock);\n\n\t \n\tret = wait_for_completion_interruptible(&kaddfd.completion);\n\tif (ret == 0) {\n\t\t \n\t\tret = kaddfd.ret;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&filter->notify_lock);\n\t \n\tif (list_empty(&kaddfd.list))\n\t\tret = kaddfd.ret;\n\telse\n\t\tlist_del(&kaddfd.list);\n\nout_unlock:\n\tmutex_unlock(&filter->notify_lock);\nout:\n\tfput(kaddfd.file);\n\n\treturn ret;\n}\n\nstatic long seccomp_notify_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\tvoid __user *buf = (void __user *)arg;\n\n\t \n\tswitch (cmd) {\n\tcase SECCOMP_IOCTL_NOTIF_RECV:\n\t\treturn seccomp_notify_recv(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_SEND:\n\t\treturn seccomp_notify_send(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_ID_VALID_WRONG_DIR:\n\tcase SECCOMP_IOCTL_NOTIF_ID_VALID:\n\t\treturn seccomp_notify_id_valid(filter, buf);\n\tcase SECCOMP_IOCTL_NOTIF_SET_FLAGS:\n\t\treturn seccomp_notify_set_flags(filter, arg);\n\t}\n\n\t \n#define EA_IOCTL(cmd)\t((cmd) & ~(IOC_INOUT | IOCSIZE_MASK))\n\tswitch (EA_IOCTL(cmd)) {\n\tcase EA_IOCTL(SECCOMP_IOCTL_NOTIF_ADDFD):\n\t\treturn seccomp_notify_addfd(filter, buf, _IOC_SIZE(cmd));\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic __poll_t seccomp_notify_poll(struct file *file,\n\t\t\t\t    struct poll_table_struct *poll_tab)\n{\n\tstruct seccomp_filter *filter = file->private_data;\n\t__poll_t ret = 0;\n\tstruct seccomp_knotif *cur;\n\n\tpoll_wait(file, &filter->wqh, poll_tab);\n\n\tif (mutex_lock_interruptible(&filter->notify_lock) < 0)\n\t\treturn EPOLLERR;\n\n\tlist_for_each_entry(cur, &filter->notif->notifications, list) {\n\t\tif (cur->state == SECCOMP_NOTIFY_INIT)\n\t\t\tret |= EPOLLIN | EPOLLRDNORM;\n\t\tif (cur->state == SECCOMP_NOTIFY_SENT)\n\t\t\tret |= EPOLLOUT | EPOLLWRNORM;\n\t\tif ((ret & EPOLLIN) && (ret & EPOLLOUT))\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&filter->notify_lock);\n\n\tif (refcount_read(&filter->users) == 0)\n\t\tret |= EPOLLHUP;\n\n\treturn ret;\n}\n\nstatic const struct file_operations seccomp_notify_ops = {\n\t.poll = seccomp_notify_poll,\n\t.release = seccomp_notify_release,\n\t.unlocked_ioctl = seccomp_notify_ioctl,\n\t.compat_ioctl = seccomp_notify_ioctl,\n};\n\nstatic struct file *init_listener(struct seccomp_filter *filter)\n{\n\tstruct file *ret;\n\n\tret = ERR_PTR(-ENOMEM);\n\tfilter->notif = kzalloc(sizeof(*(filter->notif)), GFP_KERNEL);\n\tif (!filter->notif)\n\t\tgoto out;\n\n\tfilter->notif->next_id = get_random_u64();\n\tINIT_LIST_HEAD(&filter->notif->notifications);\n\n\tret = anon_inode_getfile(\"seccomp notify\", &seccomp_notify_ops,\n\t\t\t\t filter, O_RDWR);\n\tif (IS_ERR(ret))\n\t\tgoto out_notif;\n\n\t \n\t__get_seccomp_filter(filter);\n\nout_notif:\n\tif (IS_ERR(ret))\n\t\tseccomp_notify_free(filter);\nout:\n\treturn ret;\n}\n\n \nstatic bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t \n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t    const char __user *filter)\n{\n\tconst unsigned long seccomp_mode = SECCOMP_MODE_FILTER;\n\tstruct seccomp_filter *prepared = NULL;\n\tlong ret = -EINVAL;\n\tint listener = -1;\n\tstruct file *listener_f = NULL;\n\n\t \n\tif (flags & ~SECCOMP_FILTER_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & SECCOMP_FILTER_FLAG_TSYNC) &&\n\t    (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) &&\n\t    ((flags & SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == 0))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV) &&\n\t    ((flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) == 0))\n\t\treturn -EINVAL;\n\n\t \n\tprepared = seccomp_prepare_user_filter(filter);\n\tif (IS_ERR(prepared))\n\t\treturn PTR_ERR(prepared);\n\n\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {\n\t\tlistener = get_unused_fd_flags(O_CLOEXEC);\n\t\tif (listener < 0) {\n\t\t\tret = listener;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tlistener_f = init_listener(prepared);\n\t\tif (IS_ERR(listener_f)) {\n\t\t\tput_unused_fd(listener);\n\t\t\tret = PTR_ERR(listener_f);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t \n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC &&\n\t    mutex_lock_killable(&current->signal->cred_guard_mutex))\n\t\tgoto out_put_fd;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\n\tif (!seccomp_may_assign_mode(seccomp_mode))\n\t\tgoto out;\n\n\tif (has_duplicate_listener(prepared)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = seccomp_attach_filter(flags, prepared);\n\tif (ret)\n\t\tgoto out;\n\t \n\tprepared = NULL;\n\n\tseccomp_assign_mode(current, seccomp_mode, flags);\nout:\n\tspin_unlock_irq(&current->sighand->siglock);\n\tif (flags & SECCOMP_FILTER_FLAG_TSYNC)\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\nout_put_fd:\n\tif (flags & SECCOMP_FILTER_FLAG_NEW_LISTENER) {\n\t\tif (ret) {\n\t\t\tlistener_f->private_data = NULL;\n\t\t\tfput(listener_f);\n\t\t\tput_unused_fd(listener);\n\t\t\tseccomp_notify_detach(prepared);\n\t\t} else {\n\t\t\tfd_install(listener, listener_f);\n\t\t\tret = listener;\n\t\t}\n\t}\nout_free:\n\tseccomp_filter_free(prepared);\n\treturn ret;\n}\n#else\nstatic inline long seccomp_set_mode_filter(unsigned int flags,\n\t\t\t\t\t   const char __user *filter)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic long seccomp_get_action_avail(const char __user *uaction)\n{\n\tu32 action;\n\n\tif (copy_from_user(&action, uaction, sizeof(action)))\n\t\treturn -EFAULT;\n\n\tswitch (action) {\n\tcase SECCOMP_RET_KILL_PROCESS:\n\tcase SECCOMP_RET_KILL_THREAD:\n\tcase SECCOMP_RET_TRAP:\n\tcase SECCOMP_RET_ERRNO:\n\tcase SECCOMP_RET_USER_NOTIF:\n\tcase SECCOMP_RET_TRACE:\n\tcase SECCOMP_RET_LOG:\n\tcase SECCOMP_RET_ALLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic long seccomp_get_notif_sizes(void __user *usizes)\n{\n\tstruct seccomp_notif_sizes sizes = {\n\t\t.seccomp_notif = sizeof(struct seccomp_notif),\n\t\t.seccomp_notif_resp = sizeof(struct seccomp_notif_resp),\n\t\t.seccomp_data = sizeof(struct seccomp_data),\n\t};\n\n\tif (copy_to_user(usizes, &sizes, sizeof(sizes)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic long do_seccomp(unsigned int op, unsigned int flags,\n\t\t       void __user *uargs)\n{\n\tswitch (op) {\n\tcase SECCOMP_SET_MODE_STRICT:\n\t\tif (flags != 0 || uargs != NULL)\n\t\t\treturn -EINVAL;\n\t\treturn seccomp_set_mode_strict();\n\tcase SECCOMP_SET_MODE_FILTER:\n\t\treturn seccomp_set_mode_filter(flags, uargs);\n\tcase SECCOMP_GET_ACTION_AVAIL:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_action_avail(uargs);\n\tcase SECCOMP_GET_NOTIF_SIZES:\n\t\tif (flags != 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn seccomp_get_notif_sizes(uargs);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE3(seccomp, unsigned int, op, unsigned int, flags,\n\t\t\t void __user *, uargs)\n{\n\treturn do_seccomp(op, flags, uargs);\n}\n\n \nlong prctl_set_seccomp(unsigned long seccomp_mode, void __user *filter)\n{\n\tunsigned int op;\n\tvoid __user *uargs;\n\n\tswitch (seccomp_mode) {\n\tcase SECCOMP_MODE_STRICT:\n\t\top = SECCOMP_SET_MODE_STRICT;\n\t\t \n\t\tuargs = NULL;\n\t\tbreak;\n\tcase SECCOMP_MODE_FILTER:\n\t\top = SECCOMP_SET_MODE_FILTER;\n\t\tuargs = filter;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn do_seccomp(op, 0, uargs);\n}\n\n#if defined(CONFIG_SECCOMP_FILTER) && defined(CONFIG_CHECKPOINT_RESTORE)\nstatic struct seccomp_filter *get_nth_filter(struct task_struct *task,\n\t\t\t\t\t     unsigned long filter_off)\n{\n\tstruct seccomp_filter *orig, *filter;\n\tunsigned long count;\n\n\t \n\tspin_lock_irq(&task->sighand->siglock);\n\n\tif (task->seccomp.mode != SECCOMP_MODE_FILTER) {\n\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\torig = task->seccomp.filter;\n\t__get_seccomp_filter(orig);\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\tcount = 0;\n\tfor (filter = orig; filter; filter = filter->prev)\n\t\tcount++;\n\n\tif (filter_off >= count) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tcount -= filter_off;\n\tfor (filter = orig; filter && count > 1; filter = filter->prev)\n\t\tcount--;\n\n\tif (WARN_ON(count != 1 || !filter)) {\n\t\tfilter = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\t__get_seccomp_filter(filter);\n\nout:\n\t__put_seccomp_filter(orig);\n\treturn filter;\n}\n\nlong seccomp_get_filter(struct task_struct *task, unsigned long filter_off,\n\t\t\tvoid __user *data)\n{\n\tstruct seccomp_filter *filter;\n\tstruct sock_fprog_kern *fprog;\n\tlong ret;\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tfilter = get_nth_filter(task, filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tfprog = filter->prog->orig_prog;\n\tif (!fprog) {\n\t\t \n\t\tret = -EMEDIUMTYPE;\n\t\tgoto out;\n\t}\n\n\tret = fprog->len;\n\tif (!data)\n\t\tgoto out;\n\n\tif (copy_to_user(data, fprog->filter, bpf_classic_proglen(fprog)))\n\t\tret = -EFAULT;\n\nout:\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}\n\nlong seccomp_get_metadata(struct task_struct *task,\n\t\t\t  unsigned long size, void __user *data)\n{\n\tlong ret;\n\tstruct seccomp_filter *filter;\n\tstruct seccomp_metadata kmd = {};\n\n\tif (!capable(CAP_SYS_ADMIN) ||\n\t    current->seccomp.mode != SECCOMP_MODE_DISABLED) {\n\t\treturn -EACCES;\n\t}\n\n\tsize = min_t(unsigned long, size, sizeof(kmd));\n\n\tif (size < sizeof(kmd.filter_off))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kmd.filter_off, data, sizeof(kmd.filter_off)))\n\t\treturn -EFAULT;\n\n\tfilter = get_nth_filter(task, kmd.filter_off);\n\tif (IS_ERR(filter))\n\t\treturn PTR_ERR(filter);\n\n\tif (filter->log)\n\t\tkmd.flags |= SECCOMP_FILTER_FLAG_LOG;\n\n\tret = size;\n\tif (copy_to_user(data, &kmd, size))\n\t\tret = -EFAULT;\n\n\t__put_seccomp_filter(filter);\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_SYSCTL\n\n \n#define SECCOMP_RET_KILL_PROCESS_NAME\t\"kill_process\"\n#define SECCOMP_RET_KILL_THREAD_NAME\t\"kill_thread\"\n#define SECCOMP_RET_TRAP_NAME\t\t\"trap\"\n#define SECCOMP_RET_ERRNO_NAME\t\t\"errno\"\n#define SECCOMP_RET_USER_NOTIF_NAME\t\"user_notif\"\n#define SECCOMP_RET_TRACE_NAME\t\t\"trace\"\n#define SECCOMP_RET_LOG_NAME\t\t\"log\"\n#define SECCOMP_RET_ALLOW_NAME\t\t\"allow\"\n\nstatic const char seccomp_actions_avail[] =\n\t\t\t\tSECCOMP_RET_KILL_PROCESS_NAME\t\" \"\n\t\t\t\tSECCOMP_RET_KILL_THREAD_NAME\t\" \"\n\t\t\t\tSECCOMP_RET_TRAP_NAME\t\t\" \"\n\t\t\t\tSECCOMP_RET_ERRNO_NAME\t\t\" \"\n\t\t\t\tSECCOMP_RET_USER_NOTIF_NAME     \" \"\n\t\t\t\tSECCOMP_RET_TRACE_NAME\t\t\" \"\n\t\t\t\tSECCOMP_RET_LOG_NAME\t\t\" \"\n\t\t\t\tSECCOMP_RET_ALLOW_NAME;\n\nstruct seccomp_log_name {\n\tu32\t\tlog;\n\tconst char\t*name;\n};\n\nstatic const struct seccomp_log_name seccomp_log_names[] = {\n\t{ SECCOMP_LOG_KILL_PROCESS, SECCOMP_RET_KILL_PROCESS_NAME },\n\t{ SECCOMP_LOG_KILL_THREAD, SECCOMP_RET_KILL_THREAD_NAME },\n\t{ SECCOMP_LOG_TRAP, SECCOMP_RET_TRAP_NAME },\n\t{ SECCOMP_LOG_ERRNO, SECCOMP_RET_ERRNO_NAME },\n\t{ SECCOMP_LOG_USER_NOTIF, SECCOMP_RET_USER_NOTIF_NAME },\n\t{ SECCOMP_LOG_TRACE, SECCOMP_RET_TRACE_NAME },\n\t{ SECCOMP_LOG_LOG, SECCOMP_RET_LOG_NAME },\n\t{ SECCOMP_LOG_ALLOW, SECCOMP_RET_ALLOW_NAME },\n\t{ }\n};\n\nstatic bool seccomp_names_from_actions_logged(char *names, size_t size,\n\t\t\t\t\t      u32 actions_logged,\n\t\t\t\t\t      const char *sep)\n{\n\tconst struct seccomp_log_name *cur;\n\tbool append_sep = false;\n\n\tfor (cur = seccomp_log_names; cur->name && size; cur++) {\n\t\tssize_t ret;\n\n\t\tif (!(actions_logged & cur->log))\n\t\t\tcontinue;\n\n\t\tif (append_sep) {\n\t\t\tret = strscpy(names, sep, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tnames += ret;\n\t\t\tsize -= ret;\n\t\t} else\n\t\t\tappend_sep = true;\n\n\t\tret = strscpy(names, cur->name, size);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tnames += ret;\n\t\tsize -= ret;\n\t}\n\n\treturn true;\n}\n\nstatic bool seccomp_action_logged_from_name(u32 *action_logged,\n\t\t\t\t\t    const char *name)\n{\n\tconst struct seccomp_log_name *cur;\n\n\tfor (cur = seccomp_log_names; cur->name; cur++) {\n\t\tif (!strcmp(cur->name, name)) {\n\t\t\t*action_logged = cur->log;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool seccomp_actions_logged_from_names(u32 *actions_logged, char *names)\n{\n\tchar *name;\n\n\t*actions_logged = 0;\n\twhile ((name = strsep(&names, \" \")) && *name) {\n\t\tu32 action_logged = 0;\n\n\t\tif (!seccomp_action_logged_from_name(&action_logged, name))\n\t\t\treturn false;\n\n\t\t*actions_logged |= action_logged;\n\t}\n\n\treturn true;\n}\n\nstatic int read_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t       size_t *lenp, loff_t *ppos)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\n\tmemset(names, 0, sizeof(names));\n\n\tif (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t       seccomp_actions_logged, \" \"))\n\t\treturn -EINVAL;\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\treturn proc_dostring(&table, 0, buffer, lenp, ppos);\n}\n\nstatic int write_actions_logged(struct ctl_table *ro_table, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos, u32 *actions_logged)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tstruct ctl_table table;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(names, 0, sizeof(names));\n\n\ttable = *ro_table;\n\ttable.data = names;\n\ttable.maxlen = sizeof(names);\n\tret = proc_dostring(&table, 1, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!seccomp_actions_logged_from_names(actions_logged, table.data))\n\t\treturn -EINVAL;\n\n\tif (*actions_logged & SECCOMP_LOG_ALLOW)\n\t\treturn -EINVAL;\n\n\tseccomp_actions_logged = *actions_logged;\n\treturn 0;\n}\n\nstatic void audit_actions_logged(u32 actions_logged, u32 old_actions_logged,\n\t\t\t\t int ret)\n{\n\tchar names[sizeof(seccomp_actions_avail)];\n\tchar old_names[sizeof(seccomp_actions_avail)];\n\tconst char *new = names;\n\tconst char *old = old_names;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tmemset(names, 0, sizeof(names));\n\tmemset(old_names, 0, sizeof(old_names));\n\n\tif (ret)\n\t\tnew = \"?\";\n\telse if (!actions_logged)\n\t\tnew = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(names, sizeof(names),\n\t\t\t\t\t\t    actions_logged, \",\"))\n\t\tnew = \"?\";\n\n\tif (!old_actions_logged)\n\t\told = \"(none)\";\n\telse if (!seccomp_names_from_actions_logged(old_names,\n\t\t\t\t\t\t    sizeof(old_names),\n\t\t\t\t\t\t    old_actions_logged, \",\"))\n\t\told = \"?\";\n\n\treturn audit_seccomp_actions_logged(new, old, !ret);\n}\n\nstatic int seccomp_actions_logged_handler(struct ctl_table *ro_table, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tint ret;\n\n\tif (write) {\n\t\tu32 actions_logged = 0;\n\t\tu32 old_actions_logged = seccomp_actions_logged;\n\n\t\tret = write_actions_logged(ro_table, buffer, lenp, ppos,\n\t\t\t\t\t   &actions_logged);\n\t\taudit_actions_logged(actions_logged, old_actions_logged, ret);\n\t} else\n\t\tret = read_actions_logged(ro_table, buffer, lenp, ppos);\n\n\treturn ret;\n}\n\nstatic struct ctl_table seccomp_sysctl_table[] = {\n\t{\n\t\t.procname\t= \"actions_avail\",\n\t\t.data\t\t= (void *) &seccomp_actions_avail,\n\t\t.maxlen\t\t= sizeof(seccomp_actions_avail),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dostring,\n\t},\n\t{\n\t\t.procname\t= \"actions_logged\",\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= seccomp_actions_logged_handler,\n\t},\n\t{ }\n};\n\nstatic int __init seccomp_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel/seccomp\", seccomp_sysctl_table);\n\treturn 0;\n}\n\ndevice_initcall(seccomp_sysctl_init)\n\n#endif  \n\n#ifdef CONFIG_SECCOMP_CACHE_DEBUG\n \nstatic void proc_pid_seccomp_cache_arch(struct seq_file *m, const char *name,\n\t\t\t\t\tconst void *bitmap, size_t bitmap_size)\n{\n\tint nr;\n\n\tfor (nr = 0; nr < bitmap_size; nr++) {\n\t\tbool cached = test_bit(nr, bitmap);\n\t\tchar *status = cached ? \"ALLOW\" : \"FILTER\";\n\n\t\tseq_printf(m, \"%s %d %s\\n\", name, nr, status);\n\t}\n}\n\nint proc_pid_seccomp_cache(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tstruct seccomp_filter *f;\n\tunsigned long flags;\n\n\t \n\tif (!file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn -ESRCH;\n\n\tf = READ_ONCE(task->seccomp.filter);\n\tif (!f) {\n\t\tunlock_task_sighand(task, &flags);\n\t\treturn 0;\n\t}\n\n\t \n\t__get_seccomp_filter(f);\n\tunlock_task_sighand(task, &flags);\n\n\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_NATIVE_NAME,\n\t\t\t\t    f->cache.allow_native,\n\t\t\t\t    SECCOMP_ARCH_NATIVE_NR);\n\n#ifdef SECCOMP_ARCH_COMPAT\n\tproc_pid_seccomp_cache_arch(m, SECCOMP_ARCH_COMPAT_NAME,\n\t\t\t\t    f->cache.allow_compat,\n\t\t\t\t    SECCOMP_ARCH_COMPAT_NR);\n#endif  \n\n\t__put_seccomp_filter(f);\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}