{
  "module_name": "encoding.h",
  "hash_id": "e22a3181ec9136a675cf2d7d8034202d707dada1a552060500d0267935a9292b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcsan/encoding.h",
  "human_readable_source": " \n \n\n#ifndef _KERNEL_KCSAN_ENCODING_H\n#define _KERNEL_KCSAN_ENCODING_H\n\n#include <linux/bits.h>\n#include <linux/log2.h>\n#include <linux/mm.h>\n\n#include \"kcsan.h\"\n\n#define SLOT_RANGE PAGE_SIZE\n\n#define INVALID_WATCHPOINT  0\n#define CONSUMED_WATCHPOINT 1\n\n \n#define MAX_ENCODABLE_SIZE (SLOT_RANGE * (1 + KCSAN_CHECK_ADJACENT))\n\n \n#define WATCHPOINT_SIZE_BITS bits_per(MAX_ENCODABLE_SIZE)\n \n#define WATCHPOINT_ADDR_BITS (BITS_PER_LONG-1 - WATCHPOINT_SIZE_BITS)\n\n \n#define WATCHPOINT_WRITE_MASK\tBIT(BITS_PER_LONG-1)\n#define WATCHPOINT_SIZE_MASK\tGENMASK(BITS_PER_LONG-2, WATCHPOINT_ADDR_BITS)\n#define WATCHPOINT_ADDR_MASK\tGENMASK(WATCHPOINT_ADDR_BITS-1, 0)\nstatic_assert(WATCHPOINT_ADDR_MASK == (1UL << WATCHPOINT_ADDR_BITS) - 1);\nstatic_assert((WATCHPOINT_WRITE_MASK ^ WATCHPOINT_SIZE_MASK ^ WATCHPOINT_ADDR_MASK) == ~0UL);\n\nstatic inline bool check_encodable(unsigned long addr, size_t size)\n{\n\t \n\treturn addr >= PAGE_SIZE && size <= MAX_ENCODABLE_SIZE;\n}\n\nstatic inline long\nencode_watchpoint(unsigned long addr, size_t size, bool is_write)\n{\n\treturn (long)((is_write ? WATCHPOINT_WRITE_MASK : 0) |\n\t\t      (size << WATCHPOINT_ADDR_BITS) |\n\t\t      (addr & WATCHPOINT_ADDR_MASK));\n}\n\nstatic __always_inline bool decode_watchpoint(long watchpoint,\n\t\t\t\t\t      unsigned long *addr_masked,\n\t\t\t\t\t      size_t *size,\n\t\t\t\t\t      bool *is_write)\n{\n\tif (watchpoint == INVALID_WATCHPOINT ||\n\t    watchpoint == CONSUMED_WATCHPOINT)\n\t\treturn false;\n\n\t*addr_masked =    (unsigned long)watchpoint & WATCHPOINT_ADDR_MASK;\n\t*size\t     =   ((unsigned long)watchpoint & WATCHPOINT_SIZE_MASK) >> WATCHPOINT_ADDR_BITS;\n\t*is_write    = !!((unsigned long)watchpoint & WATCHPOINT_WRITE_MASK);\n\n\treturn true;\n}\n\n \nstatic __always_inline int watchpoint_slot(unsigned long addr)\n{\n\treturn (addr / PAGE_SIZE) % CONFIG_KCSAN_NUM_WATCHPOINTS;\n}\n\nstatic __always_inline bool matching_access(unsigned long addr1, size_t size1,\n\t\t\t\t\t    unsigned long addr2, size_t size2)\n{\n\tunsigned long end_range1 = addr1 + size1 - 1;\n\tunsigned long end_range2 = addr2 + size2 - 1;\n\n\treturn addr1 <= end_range2 && addr2 <= end_range1;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}