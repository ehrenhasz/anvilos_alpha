{
  "module_name": "kcsan.h",
  "hash_id": "69622135bc2517a99450261c0180b175c81ea245e9f9eec76defd20909e34575",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcsan/kcsan.h",
  "human_readable_source": " \n \n\n#ifndef _KERNEL_KCSAN_KCSAN_H\n#define _KERNEL_KCSAN_KCSAN_H\n\n#include <linux/atomic.h>\n#include <linux/kcsan.h>\n#include <linux/sched.h>\n\n \n#define KCSAN_CHECK_ADJACENT 1\n#define NUM_SLOTS (1 + 2*KCSAN_CHECK_ADJACENT)\n\nextern unsigned int kcsan_udelay_task;\nextern unsigned int kcsan_udelay_interrupt;\n\n \nextern bool kcsan_enabled;\n\n \nvoid kcsan_save_irqtrace(struct task_struct *task);\nvoid kcsan_restore_irqtrace(struct task_struct *task);\n\n \nenum kcsan_counter_id {\n\t \n\tKCSAN_COUNTER_USED_WATCHPOINTS,\n\n\t \n\tKCSAN_COUNTER_SETUP_WATCHPOINTS,\n\n\t \n\tKCSAN_COUNTER_DATA_RACES,\n\n\t \n\tKCSAN_COUNTER_ASSERT_FAILURES,\n\n\t \n\tKCSAN_COUNTER_NO_CAPACITY,\n\n\t \n\tKCSAN_COUNTER_REPORT_RACES,\n\n\t \n\tKCSAN_COUNTER_RACES_UNKNOWN_ORIGIN,\n\n\t \n\tKCSAN_COUNTER_UNENCODABLE_ACCESSES,\n\n\t \n\tKCSAN_COUNTER_ENCODING_FALSE_POSITIVES,\n\n\tKCSAN_COUNTER_COUNT,  \n};\nextern atomic_long_t kcsan_counters[KCSAN_COUNTER_COUNT];\n\n \nextern bool kcsan_skip_report_debugfs(unsigned long func_addr);\n\n \nenum kcsan_value_change {\n\t \n\tKCSAN_VALUE_CHANGE_MAYBE,\n\n\t \n\tKCSAN_VALUE_CHANGE_FALSE,\n\n\t \n\tKCSAN_VALUE_CHANGE_TRUE,\n};\n\n \nvoid kcsan_report_set_info(const volatile void *ptr, size_t size, int access_type,\n\t\t\t   unsigned long ip, int watchpoint_idx);\n\n \nvoid kcsan_report_known_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t       unsigned long ip, enum kcsan_value_change value_change,\n\t\t\t       int watchpoint_idx, u64 old, u64 new, u64 mask);\n\n \nvoid kcsan_report_unknown_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t\t unsigned long ip, u64 old, u64 new, u64 mask);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}