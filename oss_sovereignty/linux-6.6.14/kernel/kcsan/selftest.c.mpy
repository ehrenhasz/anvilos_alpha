{
  "module_name": "selftest.c",
  "hash_id": "35aa51e74b5d7314dee8abe55d42beb9d3a799cfbdd1bddabdadabdb365380e0",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcsan/selftest.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kcsan: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/kcsan-checks.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include \"encoding.h\"\n\n#define ITERS_PER_TEST 2000\n\n \nstatic bool __init test_encode_decode(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ITERS_PER_TEST; ++i) {\n\t\tsize_t size = get_random_u32_inclusive(1, MAX_ENCODABLE_SIZE);\n\t\tbool is_write = !!get_random_u32_below(2);\n\t\tunsigned long verif_masked_addr;\n\t\tlong encoded_watchpoint;\n\t\tbool verif_is_write;\n\t\tunsigned long addr;\n\t\tsize_t verif_size;\n\n\t\tget_random_bytes(&addr, sizeof(addr));\n\t\tif (addr < PAGE_SIZE)\n\t\t\taddr = PAGE_SIZE;\n\n\t\tif (WARN_ON(!check_encodable(addr, size)))\n\t\t\treturn false;\n\n\t\tencoded_watchpoint = encode_watchpoint(addr, size, is_write);\n\n\t\t \n\t\tif (WARN_ON(decode_watchpoint(INVALID_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\t\tif (WARN_ON(decode_watchpoint(CONSUMED_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\n\t\t \n\t\tif (WARN_ON(!decode_watchpoint(encoded_watchpoint, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\t\tif (WARN_ON(verif_masked_addr != (addr & WATCHPOINT_ADDR_MASK)))\n\t\t\tgoto fail;\n\t\tif (WARN_ON(verif_size != size))\n\t\t\tgoto fail;\n\t\tif (WARN_ON(is_write != verif_is_write))\n\t\t\tgoto fail;\n\n\t\tcontinue;\nfail:\n\t\tpr_err(\"%s fail: %s %zu bytes @ %lx -> encoded: %lx -> %s %zu bytes @ %lx\\n\",\n\t\t       __func__, is_write ? \"write\" : \"read\", size, addr, encoded_watchpoint,\n\t\t       verif_is_write ? \"write\" : \"read\", verif_size, verif_masked_addr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool __init test_matching_access(void)\n{\n\tif (WARN_ON(!matching_access(10, 1, 10, 1)))\n\t\treturn false;\n\tif (WARN_ON(!matching_access(10, 2, 11, 1)))\n\t\treturn false;\n\tif (WARN_ON(!matching_access(10, 1, 9, 2)))\n\t\treturn false;\n\tif (WARN_ON(matching_access(10, 1, 11, 1)))\n\t\treturn false;\n\tif (WARN_ON(matching_access(9, 1, 10, 1)))\n\t\treturn false;\n\n\t \n\tif (WARN_ON(!matching_access(8, 8, 12, 0)))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic DEFINE_SPINLOCK(test_spinlock);\nstatic bool __init test_barrier(void)\n{\n#ifdef CONFIG_KCSAN_WEAK_MEMORY\n\tstruct kcsan_scoped_access *reorder_access = &current->kcsan_ctx.reorder_access;\n#else\n\tstruct kcsan_scoped_access *reorder_access = NULL;\n#endif\n\tbool ret = true;\n\tarch_spinlock_t arch_spinlock = __ARCH_SPIN_LOCK_UNLOCKED;\n\tatomic_t dummy;\n\tlong test_var;\n\n\tif (!reorder_access || !IS_ENABLED(CONFIG_SMP))\n\t\treturn true;\n\n#define __KCSAN_CHECK_BARRIER(access_type, barrier, name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treorder_access->type = (access_type) | KCSAN_ACCESS_SCOPED;\t\t\t\\\n\t\treorder_access->size = 1;\t\t\t\t\t\t\t\\\n\t\tbarrier;\t\t\t\t\t\t\t\t\t\\\n\t\tif (reorder_access->size != 0) {\t\t\t\t\t\t\\\n\t\t\tpr_err(\"improperly instrumented type=(\" #access_type \"): \" name \"\\n\");\t\\\n\t\t\tret = false;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n#define KCSAN_CHECK_READ_BARRIER(b)  __KCSAN_CHECK_BARRIER(0, b, #b)\n#define KCSAN_CHECK_WRITE_BARRIER(b) __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE, b, #b)\n#define KCSAN_CHECK_RW_BARRIER(b)    __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE | KCSAN_ACCESS_COMPOUND, b, #b)\n\n\tkcsan_nestable_atomic_begin();  \n\n\tKCSAN_CHECK_READ_BARRIER(mb());\n\tKCSAN_CHECK_READ_BARRIER(rmb());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb());\n\tKCSAN_CHECK_READ_BARRIER(smp_rmb());\n\tKCSAN_CHECK_READ_BARRIER(dma_rmb());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_READ_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_READ_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_READ_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_READ_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_READ_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_READ_BARRIER(spin_unlock(&test_spinlock));\n\n\tKCSAN_CHECK_WRITE_BARRIER(mb());\n\tKCSAN_CHECK_WRITE_BARRIER(wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(dma_wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_WRITE_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_WRITE_BARRIER(spin_unlock(&test_spinlock));\n\n\tKCSAN_CHECK_RW_BARRIER(mb());\n\tKCSAN_CHECK_RW_BARRIER(wmb());\n\tKCSAN_CHECK_RW_BARRIER(rmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb());\n\tKCSAN_CHECK_RW_BARRIER(smp_wmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_rmb());\n\tKCSAN_CHECK_RW_BARRIER(dma_wmb());\n\tKCSAN_CHECK_RW_BARRIER(dma_rmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_RW_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_RW_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_RW_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_RW_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_RW_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_RW_BARRIER(spin_unlock(&test_spinlock));\n\n#ifdef clear_bit_unlock_is_negative_byte\n\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n#endif\n\tkcsan_nestable_atomic_end();\n\n\treturn ret;\n}\n\nstatic int __init kcsan_selftest(void)\n{\n\tint passed = 0;\n\tint total = 0;\n\n#define RUN_TEST(do_test)                                                      \\\n\tdo {                                                                   \\\n\t\t++total;                                                       \\\n\t\tif (do_test())                                                 \\\n\t\t\t++passed;                                              \\\n\t\telse                                                           \\\n\t\t\tpr_err(\"selftest: \" #do_test \" failed\");               \\\n\t} while (0)\n\n\tRUN_TEST(test_encode_decode);\n\tRUN_TEST(test_matching_access);\n\tRUN_TEST(test_barrier);\n\n\tpr_info(\"selftest: %d/%d tests passed\\n\", passed, total);\n\tif (passed != total)\n\t\tpanic(\"selftests failed\");\n\treturn 0;\n}\npostcore_initcall(kcsan_selftest);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}