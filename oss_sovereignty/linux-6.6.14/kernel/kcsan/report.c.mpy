{
  "module_name": "report.c",
  "hash_id": "9c18990d254b0b6e6ff5f9b868471ae4ef5d1c9128058bbbe9e35197caeb6fca",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcsan/report.c",
  "human_readable_source": "\n \n\n#include <linux/debug_locks.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/kallsyms.h>\n#include <linux/kernel.h>\n#include <linux/lockdep.h>\n#include <linux/preempt.h>\n#include <linux/printk.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/stacktrace.h>\n\n#include \"kcsan.h\"\n#include \"encoding.h\"\n\n \n#define NUM_STACK_ENTRIES 64\n\n \nstruct access_info {\n\tconst volatile void\t*ptr;\n\tsize_t\t\t\tsize;\n\tint\t\t\taccess_type;\n\tint\t\t\ttask_pid;\n\tint\t\t\tcpu_id;\n\tunsigned long\t\tip;\n};\n\n \nstruct other_info {\n\tstruct access_info\tai;\n\tunsigned long\t\tstack_entries[NUM_STACK_ENTRIES];\n\tint\t\t\tnum_stack_entries;\n\n\t \n\tstruct task_struct\t*task;\n};\n\n \nstatic struct other_info other_infos[CONFIG_KCSAN_NUM_WATCHPOINTS + NUM_SLOTS-1];\n\n \nstruct report_time {\n\t \n\tunsigned long time;\n\n\t \n\tunsigned long frame1;\n\tunsigned long frame2;\n};\n\n \n#define REPORT_TIMES_MAX (PAGE_SIZE / sizeof(struct report_time))\n#define REPORT_TIMES_SIZE                                                      \\\n\t(CONFIG_KCSAN_REPORT_ONCE_IN_MS > REPORT_TIMES_MAX ?                   \\\n\t\t REPORT_TIMES_MAX :                                            \\\n\t\t CONFIG_KCSAN_REPORT_ONCE_IN_MS)\nstatic struct report_time report_times[REPORT_TIMES_SIZE];\n\n \nstatic DEFINE_RAW_SPINLOCK(report_lock);\n\n \nstatic bool rate_limit_report(unsigned long frame1, unsigned long frame2)\n{\n\tstruct report_time *use_entry = &report_times[0];\n\tunsigned long invalid_before;\n\tint i;\n\n\tBUILD_BUG_ON(CONFIG_KCSAN_REPORT_ONCE_IN_MS != 0 && REPORT_TIMES_SIZE == 0);\n\n\tif (CONFIG_KCSAN_REPORT_ONCE_IN_MS == 0)\n\t\treturn false;\n\n\tinvalid_before = jiffies - msecs_to_jiffies(CONFIG_KCSAN_REPORT_ONCE_IN_MS);\n\n\t \n\tfor (i = 0; i < REPORT_TIMES_SIZE; ++i) {\n\t\tstruct report_time *rt = &report_times[i];\n\n\t\t \n\t\tif (time_before(rt->time, use_entry->time))\n\t\t\tuse_entry = rt;\n\n\t\t \n\t\tif (rt->time == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_before(rt->time, invalid_before))\n\t\t\tcontinue;  \n\n\t\t \n\t\tif ((rt->frame1 == frame1 && rt->frame2 == frame2) ||\n\t\t    (rt->frame1 == frame2 && rt->frame2 == frame1))\n\t\t\treturn true;\n\t}\n\n\tuse_entry->time = jiffies;\n\tuse_entry->frame1 = frame1;\n\tuse_entry->frame2 = frame2;\n\treturn false;\n}\n\n \nstatic bool\nskip_report(enum kcsan_value_change value_change, unsigned long top_frame)\n{\n\t \n\tWARN_ON_ONCE(value_change == KCSAN_VALUE_CHANGE_FALSE);\n\n\t \n\tif (IS_ENABLED(CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY) &&\n\t    value_change == KCSAN_VALUE_CHANGE_MAYBE) {\n\t\t \n\t\tchar buf[64];\n\t\tint len = scnprintf(buf, sizeof(buf), \"%ps\", (void *)top_frame);\n\n\t\tif (!strnstr(buf, \"rcu_\", len) &&\n\t\t    !strnstr(buf, \"_rcu\", len) &&\n\t\t    !strnstr(buf, \"_srcu\", len))\n\t\t\treturn true;\n\t}\n\n\treturn kcsan_skip_report_debugfs(top_frame);\n}\n\nstatic const char *get_access_type(int type)\n{\n\tif (type & KCSAN_ACCESS_ASSERT) {\n\t\tif (type & KCSAN_ACCESS_SCOPED) {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses (reordered)\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes (reordered)\";\n\t\t} else {\n\t\t\tif (type & KCSAN_ACCESS_WRITE)\n\t\t\t\treturn \"assert no accesses\";\n\t\t\telse\n\t\t\t\treturn \"assert no writes\";\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase 0:\n\t\treturn \"read\";\n\tcase KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked)\";\n\tcase KCSAN_ACCESS_WRITE:\n\t\treturn \"write\";\n\tcase KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked)\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write\";\n\tcase KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked)\";\n\tcase KCSAN_ACCESS_SCOPED:\n\t\treturn \"read (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE:\n\t\treturn \"write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"write (marked, reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE:\n\t\treturn \"read-write (reordered)\";\n\tcase KCSAN_ACCESS_SCOPED | KCSAN_ACCESS_COMPOUND | KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ATOMIC:\n\t\treturn \"read-write (marked, reordered)\";\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic const char *get_bug_type(int type)\n{\n\treturn (type & KCSAN_ACCESS_ASSERT) != 0 ? \"assert: race\" : \"data-race\";\n}\n\n \nstatic const char *get_thread_desc(int task_id)\n{\n\tif (task_id != -1) {\n\t\tstatic char buf[32];  \n\n\t\tsnprintf(buf, sizeof(buf), \"task %i\", task_id);\n\t\treturn buf;\n\t}\n\treturn \"interrupt\";\n}\n\n \nstatic int get_stack_skipnr(const unsigned long stack_entries[], int num_entries)\n{\n\tchar buf[64];\n\tchar *cur;\n\tint len, skip;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"%ps\", (void *)stack_entries[skip]);\n\n\t\t \n\t\tif (strnstr(buf, \"tsan_\", len) ||\n\t\t    strnstr(buf, \"_once_size\", len))\n\t\t\tcontinue;\n\n\t\tcur = strnstr(buf, \"kcsan_\", len);\n\t\tif (cur) {\n\t\t\tcur += strlen(\"kcsan_\");\n\t\t\tif (!str_has_prefix(cur, \"test\"))\n\t\t\t\tcontinue;  \n\t\t\t \n\t\t}\n\n\t\t \n\t\tbreak;\n\t}\n\n\treturn skip;\n}\n\n \nstatic int\nreplace_stack_entry(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t    unsigned long *replaced)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long target_func;\n\tint skip;\n\n\tif (kallsyms_lookup_size_offset(ip, &symbolsize, &offset))\n\t\ttarget_func = ip - offset;\n\telse\n\t\tgoto fallback;\n\n\tfor (skip = 0; skip < num_entries; ++skip) {\n\t\tunsigned long func = stack_entries[skip];\n\n\t\tif (!kallsyms_lookup_size_offset(func, &symbolsize, &offset))\n\t\t\tgoto fallback;\n\t\tfunc -= offset;\n\n\t\tif (func == target_func) {\n\t\t\t*replaced = stack_entries[skip];\n\t\t\tstack_entries[skip] = ip;\n\t\t\treturn skip;\n\t\t}\n\t}\n\nfallback:\n\t \n\tWARN_ONCE(1, \"Cannot find frame for %pS in stack trace\", (void *)ip);\n\treturn get_stack_skipnr(stack_entries, num_entries);\n}\n\nstatic int\nsanitize_stack_entries(unsigned long stack_entries[], int num_entries, unsigned long ip,\n\t\t       unsigned long *replaced)\n{\n\treturn ip ? replace_stack_entry(stack_entries, num_entries, ip, replaced) :\n\t\t\t  get_stack_skipnr(stack_entries, num_entries);\n}\n\n \nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}\n\nstatic void\nprint_stack_trace(unsigned long stack_entries[], int num_entries, unsigned long reordered_to)\n{\n\tstack_trace_print(stack_entries, num_entries, 0);\n\tif (reordered_to)\n\t\tpr_err(\"  |\\n  +-> reordered to: %pS\\n\", (void *)reordered_to);\n}\n\nstatic void print_verbose_info(struct task_struct *task)\n{\n\tif (!task)\n\t\treturn;\n\n\t \n\tkcsan_restore_irqtrace(task);\n\n\tpr_err(\"\\n\");\n\tdebug_show_held_locks(task);\n\tprint_irqtrace_events(task);\n}\n\nstatic void print_report(enum kcsan_value_change value_change,\n\t\t\t const struct access_info *ai,\n\t\t\t struct other_info *other_info,\n\t\t\t u64 old, u64 new, u64 mask)\n{\n\tunsigned long reordered_to = 0;\n\tunsigned long stack_entries[NUM_STACK_ENTRIES] = { 0 };\n\tint num_stack_entries = stack_trace_save(stack_entries, NUM_STACK_ENTRIES, 1);\n\tint skipnr = sanitize_stack_entries(stack_entries, num_stack_entries, ai->ip, &reordered_to);\n\tunsigned long this_frame = stack_entries[skipnr];\n\tunsigned long other_reordered_to = 0;\n\tunsigned long other_frame = 0;\n\tint other_skipnr = 0;  \n\n\t \n\tif (skip_report(KCSAN_VALUE_CHANGE_TRUE, stack_entries[skipnr]))\n\t\treturn;\n\n\tif (other_info) {\n\t\tother_skipnr = sanitize_stack_entries(other_info->stack_entries,\n\t\t\t\t\t\t      other_info->num_stack_entries,\n\t\t\t\t\t\t      other_info->ai.ip, &other_reordered_to);\n\t\tother_frame = other_info->stack_entries[other_skipnr];\n\n\t\t \n\t\tif (skip_report(value_change, other_frame))\n\t\t\treturn;\n\t}\n\n\tif (rate_limit_report(this_frame, other_frame))\n\t\treturn;\n\n\t \n\tpr_err(\"==================================================================\\n\");\n\tif (other_info) {\n\t\tint cmp;\n\n\t\t \n\t\tcmp = sym_strcmp((void *)other_frame, (void *)this_frame);\n\t\tpr_err(\"BUG: KCSAN: %s in %ps / %ps\\n\",\n\t\t       get_bug_type(ai->access_type | other_info->ai.access_type),\n\t\t       (void *)(cmp < 0 ? other_frame : this_frame),\n\t\t       (void *)(cmp < 0 ? this_frame : other_frame));\n\t} else {\n\t\tpr_err(\"BUG: KCSAN: %s in %pS\\n\", get_bug_type(ai->access_type),\n\t\t       (void *)this_frame);\n\t}\n\n\tpr_err(\"\\n\");\n\n\t \n\tif (other_info) {\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(other_info->ai.access_type), other_info->ai.ptr,\n\t\t       other_info->ai.size, get_thread_desc(other_info->ai.task_pid),\n\t\t       other_info->ai.cpu_id);\n\n\t\t \n\t\tprint_stack_trace(other_info->stack_entries + other_skipnr,\n\t\t\t\t  other_info->num_stack_entries - other_skipnr,\n\t\t\t\t  other_reordered_to);\n\t\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\t\tprint_verbose_info(other_info->task);\n\n\t\tpr_err(\"\\n\");\n\t\tpr_err(\"%s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t} else {\n\t\tpr_err(\"race at unknown origin, with %s to 0x%px of %zu bytes by %s on cpu %i:\\n\",\n\t\t       get_access_type(ai->access_type), ai->ptr, ai->size,\n\t\t       get_thread_desc(ai->task_pid), ai->cpu_id);\n\t}\n\t \n\tprint_stack_trace(stack_entries + skipnr, num_stack_entries - skipnr, reordered_to);\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tprint_verbose_info(current);\n\n\t \n\tif (ai->size <= 8) {\n\t\tint hex_len = ai->size * 2;\n\t\tu64 diff = old ^ new;\n\n\t\tif (mask)\n\t\t\tdiff &= mask;\n\t\tif (diff) {\n\t\t\tpr_err(\"\\n\");\n\t\t\tpr_err(\"value changed: 0x%0*llx -> 0x%0*llx\\n\",\n\t\t\t       hex_len, old, hex_len, new);\n\t\t\tif (mask) {\n\t\t\t\tpr_err(\" bits changed: 0x%0*llx with mask 0x%0*llx\\n\",\n\t\t\t\t       hex_len, diff, hex_len, mask);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpr_err(\"\\n\");\n\tpr_err(\"Reported by Kernel Concurrency Sanitizer on:\\n\");\n\tdump_stack_print_info(KERN_DEFAULT);\n\tpr_err(\"==================================================================\\n\");\n\n\tcheck_panic_on_warn(\"KCSAN\");\n}\n\nstatic void release_report(unsigned long *flags, struct other_info *other_info)\n{\n\t \n\tother_info->ai.size = 0;\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}\n\n \nstatic void set_other_info_task_blocking(unsigned long *flags,\n\t\t\t\t\t const struct access_info *ai,\n\t\t\t\t\t struct other_info *other_info)\n{\n\t \n\tconst bool is_running = task_is_running(current);\n\t \n\tint timeout = max(kcsan_udelay_task, kcsan_udelay_interrupt);\n\n\tother_info->task = current;\n\tdo {\n\t\tif (is_running) {\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\t \n\n\t\tudelay(1);\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t\tif (timeout-- < 0) {\n\t\t\t \n\t\t\tother_info->task = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t} while (other_info->ai.size && other_info->ai.ptr == ai->ptr &&\n\t\t other_info->task == current);\n\tif (is_running)\n\t\tset_current_state(TASK_RUNNING);\n}\n\n \nstatic void prepare_report_producer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\n\t \n\tWARN_ON(other_info->ai.size);\n\n\tother_info->ai = *ai;\n\tother_info->num_stack_entries = stack_trace_save(other_info->stack_entries, NUM_STACK_ENTRIES, 2);\n\n\tif (IS_ENABLED(CONFIG_KCSAN_VERBOSE))\n\t\tset_other_info_task_blocking(flags, ai, other_info);\n\n\traw_spin_unlock_irqrestore(&report_lock, *flags);\n}\n\n \nstatic bool prepare_report_consumer(unsigned long *flags,\n\t\t\t\t    const struct access_info *ai,\n\t\t\t\t    struct other_info *other_info)\n{\n\n\traw_spin_lock_irqsave(&report_lock, *flags);\n\twhile (!other_info->ai.size) {  \n\t\traw_spin_unlock_irqrestore(&report_lock, *flags);\n\t\tcpu_relax();\n\t\traw_spin_lock_irqsave(&report_lock, *flags);\n\t}\n\n\t \n\tif (WARN_ON(!matching_access((unsigned long)other_info->ai.ptr & WATCHPOINT_ADDR_MASK, other_info->ai.size,\n\t\t\t\t     (unsigned long)ai->ptr & WATCHPOINT_ADDR_MASK, ai->size)))\n\t\tgoto discard;\n\n\tif (!matching_access((unsigned long)other_info->ai.ptr, other_info->ai.size,\n\t\t\t     (unsigned long)ai->ptr, ai->size)) {\n\t\t \n\t\tatomic_long_inc(&kcsan_counters[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]);\n\t\tgoto discard;\n\t}\n\n\treturn true;\n\ndiscard:\n\trelease_report(flags, other_info);\n\treturn false;\n}\n\nstatic struct access_info prepare_access_info(const volatile void *ptr, size_t size,\n\t\t\t\t\t      int access_type, unsigned long ip)\n{\n\treturn (struct access_info) {\n\t\t.ptr\t\t= ptr,\n\t\t.size\t\t= size,\n\t\t.access_type\t= access_type,\n\t\t.task_pid\t= in_task() ? task_pid_nr(current) : -1,\n\t\t.cpu_id\t\t= raw_smp_processor_id(),\n\t\t \n\t\t.ip\t\t= (access_type & KCSAN_ACCESS_SCOPED) ? ip : 0,\n\t};\n}\n\nvoid kcsan_report_set_info(const volatile void *ptr, size_t size, int access_type,\n\t\t\t   unsigned long ip, int watchpoint_idx)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tunsigned long flags;\n\n\tkcsan_disable_current();\n\tlockdep_off();  \n\n\tprepare_report_producer(&flags, &ai, &other_infos[watchpoint_idx]);\n\n\tlockdep_on();\n\tkcsan_enable_current();\n}\n\nvoid kcsan_report_known_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t       unsigned long ip, enum kcsan_value_change value_change,\n\t\t\t       int watchpoint_idx, u64 old, u64 new, u64 mask)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tstruct other_info *other_info = &other_infos[watchpoint_idx];\n\tunsigned long flags = 0;\n\n\tkcsan_disable_current();\n\t \n\tlockdep_off();\n\n\tif (!prepare_report_consumer(&flags, &ai, other_info))\n\t\tgoto out;\n\t \n\tif (value_change != KCSAN_VALUE_CHANGE_FALSE)\n\t\tprint_report(value_change, &ai, other_info, old, new, mask);\n\n\trelease_report(&flags, other_info);\nout:\n\tlockdep_on();\n\tkcsan_enable_current();\n}\n\nvoid kcsan_report_unknown_origin(const volatile void *ptr, size_t size, int access_type,\n\t\t\t\t unsigned long ip, u64 old, u64 new, u64 mask)\n{\n\tconst struct access_info ai = prepare_access_info(ptr, size, access_type, ip);\n\tunsigned long flags;\n\n\tkcsan_disable_current();\n\tlockdep_off();  \n\n\traw_spin_lock_irqsave(&report_lock, flags);\n\tprint_report(KCSAN_VALUE_CHANGE_TRUE, &ai, NULL, old, new, mask);\n\traw_spin_unlock_irqrestore(&report_lock, flags);\n\n\tlockdep_on();\n\tkcsan_enable_current();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}