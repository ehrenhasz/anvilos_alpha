{
  "module_name": "debugfs.c",
  "hash_id": "9d0091161dbdd3f9b7afbcb4fbab8fcb55091b4389ef4e6a259b66b4c8030833",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kcsan/debugfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kcsan: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/bsearch.h>\n#include <linux/bug.h>\n#include <linux/debugfs.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#include \"kcsan.h\"\n\natomic_long_t kcsan_counters[KCSAN_COUNTER_COUNT];\nstatic const char *const counter_names[] = {\n\t[KCSAN_COUNTER_USED_WATCHPOINTS]\t\t= \"used_watchpoints\",\n\t[KCSAN_COUNTER_SETUP_WATCHPOINTS]\t\t= \"setup_watchpoints\",\n\t[KCSAN_COUNTER_DATA_RACES]\t\t\t= \"data_races\",\n\t[KCSAN_COUNTER_ASSERT_FAILURES]\t\t\t= \"assert_failures\",\n\t[KCSAN_COUNTER_NO_CAPACITY]\t\t\t= \"no_capacity\",\n\t[KCSAN_COUNTER_REPORT_RACES]\t\t\t= \"report_races\",\n\t[KCSAN_COUNTER_RACES_UNKNOWN_ORIGIN]\t\t= \"races_unknown_origin\",\n\t[KCSAN_COUNTER_UNENCODABLE_ACCESSES]\t\t= \"unencodable_accesses\",\n\t[KCSAN_COUNTER_ENCODING_FALSE_POSITIVES]\t= \"encoding_false_positives\",\n};\nstatic_assert(ARRAY_SIZE(counter_names) == KCSAN_COUNTER_COUNT);\n\n \nstatic struct {\n\tunsigned long\t*addrs;\t\t \n\tsize_t\t\tsize;\t\t \n\tint\t\tused;\t\t \n\tbool\t\tsorted;\t\t \n\tbool\t\twhitelist;\t \n} report_filterlist = {\n\t.addrs\t\t= NULL,\n\t.size\t\t= 8,\t\t \n\t.used\t\t= 0,\n\t.sorted\t\t= false,\n\t.whitelist\t= false,\t \n};\nstatic DEFINE_SPINLOCK(report_filterlist_lock);\n\n \nstatic noinline void microbenchmark(unsigned long iters)\n{\n\tconst struct kcsan_ctx ctx_save = current->kcsan_ctx;\n\tconst bool was_enabled = READ_ONCE(kcsan_enabled);\n\tu64 cycles;\n\n\t \n\tmemset(&current->kcsan_ctx, 0, sizeof(current->kcsan_ctx));\n\t \n\tWRITE_ONCE(kcsan_enabled, false);\n\n\tpr_info(\"%s begin | iters: %lu\\n\", __func__, iters);\n\n\tcycles = get_cycles();\n\twhile (iters--) {\n\t\tunsigned long addr = iters & ((PAGE_SIZE << 8) - 1);\n\t\tint type = !(iters & 0x7f) ? KCSAN_ACCESS_ATOMIC :\n\t\t\t\t(!(iters & 0xf) ? KCSAN_ACCESS_WRITE : 0);\n\t\t__kcsan_check_access((void *)addr, sizeof(long), type);\n\t}\n\tcycles = get_cycles() - cycles;\n\n\tpr_info(\"%s end   | cycles: %llu\\n\", __func__, cycles);\n\n\tWRITE_ONCE(kcsan_enabled, was_enabled);\n\t \n\tcurrent->kcsan_ctx = ctx_save;\n}\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}\n\nbool kcsan_skip_report_debugfs(unsigned long func_addr)\n{\n\tunsigned long symbolsize, offset;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (!kallsyms_lookup_size_offset(func_addr, &symbolsize, &offset))\n\t\treturn false;\n\tfunc_addr -= offset;  \n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tif (report_filterlist.used == 0)\n\t\tgoto out;\n\n\t \n\tif (!report_filterlist.sorted) {\n\t\tsort(report_filterlist.addrs, report_filterlist.used,\n\t\t     sizeof(unsigned long), cmp_filterlist_addrs, NULL);\n\t\treport_filterlist.sorted = true;\n\t}\n\tret = !!bsearch(&func_addr, report_filterlist.addrs,\n\t\t\treport_filterlist.used, sizeof(unsigned long),\n\t\t\tcmp_filterlist_addrs);\n\tif (report_filterlist.whitelist)\n\t\tret = !ret;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\treturn ret;\n}\n\nstatic void set_report_filterlist_whitelist(bool whitelist)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\treport_filterlist.whitelist = whitelist;\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n}\n\n \nstatic ssize_t insert_report_filterlist(const char *func)\n{\n\tunsigned long flags;\n\tunsigned long addr = kallsyms_lookup_name(func);\n\tssize_t ret = 0;\n\n\tif (!addr) {\n\t\tpr_err(\"could not find function: '%s'\\n\", func);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\n\tif (report_filterlist.addrs == NULL) {\n\t\t \n\t\treport_filterlist.addrs =\n\t\t\tkmalloc_array(report_filterlist.size,\n\t\t\t\t      sizeof(unsigned long), GFP_ATOMIC);\n\t\tif (report_filterlist.addrs == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (report_filterlist.used == report_filterlist.size) {\n\t\t \n\t\tsize_t new_size = report_filterlist.size * 2;\n\t\tunsigned long *new_addrs =\n\t\t\tkrealloc(report_filterlist.addrs,\n\t\t\t\t new_size * sizeof(unsigned long), GFP_ATOMIC);\n\n\t\tif (new_addrs == NULL) {\n\t\t\t \n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\treport_filterlist.size = new_size;\n\t\treport_filterlist.addrs = new_addrs;\n\t}\n\n\t \n\treport_filterlist.addrs[report_filterlist.used++] =\n\t\tkallsyms_lookup_name(func);\n\treport_filterlist.sorted = false;\n\nout:\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn ret;\n}\n\nstatic int show_info(struct seq_file *file, void *v)\n{\n\tint i;\n\tunsigned long flags;\n\n\t \n\tseq_printf(file, \"enabled: %i\\n\", READ_ONCE(kcsan_enabled));\n\tfor (i = 0; i < KCSAN_COUNTER_COUNT; ++i) {\n\t\tseq_printf(file, \"%s: %ld\\n\", counter_names[i],\n\t\t\t   atomic_long_read(&kcsan_counters[i]));\n\t}\n\n\t \n\tspin_lock_irqsave(&report_filterlist_lock, flags);\n\tseq_printf(file, \"\\n%s functions: %s\\n\",\n\t\t   report_filterlist.whitelist ? \"whitelisted\" : \"blacklisted\",\n\t\t   report_filterlist.used == 0 ? \"none\" : \"\");\n\tfor (i = 0; i < report_filterlist.used; ++i)\n\t\tseq_printf(file, \" %ps\\n\", (void *)report_filterlist.addrs[i]);\n\tspin_unlock_irqrestore(&report_filterlist_lock, flags);\n\n\treturn 0;\n}\n\nstatic int debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, show_info, NULL);\n}\n\nstatic ssize_t\ndebugfs_write(struct file *file, const char __user *buf, size_t count, loff_t *off)\n{\n\tchar kbuf[KSYM_NAME_LEN];\n\tchar *arg;\n\tint read_len = count < (sizeof(kbuf) - 1) ? count : (sizeof(kbuf) - 1);\n\n\tif (copy_from_user(kbuf, buf, read_len))\n\t\treturn -EFAULT;\n\tkbuf[read_len] = '\\0';\n\targ = strstrip(kbuf);\n\n\tif (!strcmp(arg, \"on\")) {\n\t\tWRITE_ONCE(kcsan_enabled, true);\n\t} else if (!strcmp(arg, \"off\")) {\n\t\tWRITE_ONCE(kcsan_enabled, false);\n\t} else if (str_has_prefix(arg, \"microbench=\")) {\n\t\tunsigned long iters;\n\n\t\tif (kstrtoul(&arg[strlen(\"microbench=\")], 0, &iters))\n\t\t\treturn -EINVAL;\n\t\tmicrobenchmark(iters);\n\t} else if (!strcmp(arg, \"whitelist\")) {\n\t\tset_report_filterlist_whitelist(true);\n\t} else if (!strcmp(arg, \"blacklist\")) {\n\t\tset_report_filterlist_whitelist(false);\n\t} else if (arg[0] == '!') {\n\t\tssize_t ret = insert_report_filterlist(&arg[1]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations debugfs_ops =\n{\n\t.read\t = seq_read,\n\t.open\t = debugfs_open,\n\t.write\t = debugfs_write,\n\t.release = single_release\n};\n\nstatic int __init kcsan_debugfs_init(void)\n{\n\tdebugfs_create_file(\"kcsan\", 0644, NULL, NULL, &debugfs_ops);\n\treturn 0;\n}\n\nlate_initcall(kcsan_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}