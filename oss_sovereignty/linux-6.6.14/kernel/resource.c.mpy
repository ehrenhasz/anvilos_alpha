{
  "module_name": "resource.c",
  "hash_id": "abb43516c1e53af5c926c6d481e298795d11ef45d25f97602c27cd7ca713050c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/resource.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/pseudo_fs.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/device.h>\n#include <linux/pfn.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/resource_ext.h>\n#include <uapi/linux/magic.h>\n#include <asm/io.h>\n\n\nstruct resource ioport_resource = {\n\t.name\t= \"PCI IO\",\n\t.start\t= 0,\n\t.end\t= IO_SPACE_LIMIT,\n\t.flags\t= IORESOURCE_IO,\n};\nEXPORT_SYMBOL(ioport_resource);\n\nstruct resource iomem_resource = {\n\t.name\t= \"PCI mem\",\n\t.start\t= 0,\n\t.end\t= -1,\n\t.flags\t= IORESOURCE_MEM,\n};\nEXPORT_SYMBOL(iomem_resource);\n\n \nstruct resource_constraint {\n\tresource_size_t min, max, align;\n\tresource_size_t (*alignf)(void *, const struct resource *,\n\t\t\tresource_size_t, resource_size_t);\n\tvoid *alignf_data;\n};\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nstatic struct resource *next_resource(struct resource *p)\n{\n\tif (p->child)\n\t\treturn p->child;\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}\n\nstatic struct resource *next_resource_skip_children(struct resource *p)\n{\n\twhile (!p->sibling && p->parent)\n\t\tp = p->parent;\n\treturn p->sibling;\n}\n\n#define for_each_resource(_root, _p, _skip_children) \\\n\tfor ((_p) = (_root)->child; (_p); \\\n\t     (_p) = (_skip_children) ? next_resource_skip_children(_p) : \\\n\t\t\t\t       next_resource(_p))\n\nstatic void *r_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct resource *p = v;\n\t(*pos)++;\n\treturn (void *)next_resource(p);\n}\n\n#ifdef CONFIG_PROC_FS\n\nenum { MAX_IORES_LEVEL = 5 };\n\nstatic void *r_start(struct seq_file *m, loff_t *pos)\n\t__acquires(resource_lock)\n{\n\tstruct resource *p = pde_data(file_inode(m->file));\n\tloff_t l = 0;\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p && l < *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}\n\nstatic void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}\n\nstatic int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = pde_data(file_inode(m->file));\n\tstruct resource *r = v, *p;\n\tunsigned long long start, end;\n\tint width = root->end < 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < MAX_IORES_LEVEL; depth++, p = p->parent)\n\t\tif (p->parent == root)\n\t\t\tbreak;\n\n\tif (file_ns_capable(m->file, &init_user_ns, CAP_SYS_ADMIN)) {\n\t\tstart = r->start;\n\t\tend = r->end;\n\t} else {\n\t\tstart = end = 0;\n\t}\n\n\tseq_printf(m, \"%*s%0*llx-%0*llx : %s\\n\",\n\t\t\tdepth * 2, \"\",\n\t\t\twidth, start,\n\t\t\twidth, end,\n\t\t\tr->name ? r->name : \"<BAD>\");\n\treturn 0;\n}\n\nstatic const struct seq_operations resource_op = {\n\t.start\t= r_start,\n\t.next\t= r_next,\n\t.stop\t= r_stop,\n\t.show\t= r_show,\n};\n\nstatic int __init ioresources_init(void)\n{\n\tproc_create_seq_data(\"ioports\", 0, NULL, &resource_op,\n\t\t\t&ioport_resource);\n\tproc_create_seq_data(\"iomem\", 0, NULL, &resource_op, &iomem_resource);\n\treturn 0;\n}\n__initcall(ioresources_init);\n\n#endif  \n\nstatic void free_resource(struct resource *res)\n{\n\t \n\tif (res && PageSlab(virt_to_head_page(res)))\n\t\tkfree(res);\n}\n\nstatic struct resource *alloc_resource(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct resource), flags);\n}\n\n \nstatic struct resource * __request_resource(struct resource *root, struct resource *new)\n{\n\tresource_size_t start = new->start;\n\tresource_size_t end = new->end;\n\tstruct resource *tmp, **p;\n\n\tif (end < start)\n\t\treturn root;\n\tif (start < root->start)\n\t\treturn root;\n\tif (end > root->end)\n\t\treturn root;\n\tp = &root->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp || tmp->start > end) {\n\t\t\tnew->sibling = tmp;\n\t\t\t*p = new;\n\t\t\tnew->parent = root;\n\t\t\treturn NULL;\n\t\t}\n\t\tp = &tmp->sibling;\n\t\tif (tmp->end < start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}\n\nstatic int __release_resource(struct resource *old, bool release_child)\n{\n\tstruct resource *tmp, **p, *chd;\n\n\tp = &old->parent->child;\n\tfor (;;) {\n\t\ttmp = *p;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tif (tmp == old) {\n\t\t\tif (release_child || !(tmp->child)) {\n\t\t\t\t*p = tmp->sibling;\n\t\t\t} else {\n\t\t\t\tfor (chd = tmp->child;; chd = chd->sibling) {\n\t\t\t\t\tchd->parent = tmp->parent;\n\t\t\t\t\tif (!(chd->sibling))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*p = tmp->child;\n\t\t\t\tchd->sibling = tmp->sibling;\n\t\t\t}\n\t\t\told->parent = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tp = &tmp->sibling;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t \n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}\n\nvoid release_child_resources(struct resource *r)\n{\n\twrite_lock(&resource_lock);\n\t__release_child_resources(r);\n\twrite_unlock(&resource_lock);\n}\n\n \nstruct resource *request_resource_conflict(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __request_resource(root, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}\n\n \nint request_resource(struct resource *root, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = request_resource_conflict(root, new);\n\treturn conflict ? -EBUSY : 0;\n}\n\nEXPORT_SYMBOL(request_resource);\n\n \nint release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}\n\nEXPORT_SYMBOL(release_resource);\n\n \nstatic int find_next_iomem_res(resource_size_t start, resource_size_t end,\n\t\t\t       unsigned long flags, unsigned long desc,\n\t\t\t       struct resource *res)\n{\n\tstruct resource *p;\n\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tif (start >= end)\n\t\treturn -EINVAL;\n\n\tread_lock(&resource_lock);\n\n\tfor (p = iomem_resource.child; p; p = next_resource(p)) {\n\t\t \n\t\tif (p->start > end) {\n\t\t\tp = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (p->end < start)\n\t\t\tcontinue;\n\n\t\tif ((p->flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((desc != IORES_DESC_NONE) && (desc != p->desc))\n\t\t\tcontinue;\n\n\t\t \n\t\tbreak;\n\t}\n\n\tif (p) {\n\t\t \n\t\t*res = (struct resource) {\n\t\t\t.start = max(start, p->start),\n\t\t\t.end = min(end, p->end),\n\t\t\t.flags = p->flags,\n\t\t\t.desc = p->desc,\n\t\t\t.parent = p->parent,\n\t\t};\n\t}\n\n\tread_unlock(&resource_lock);\n\treturn p ? 0 : -ENODEV;\n}\n\nstatic int __walk_iomem_res_desc(resource_size_t start, resource_size_t end,\n\t\t\t\t unsigned long flags, unsigned long desc,\n\t\t\t\t void *arg,\n\t\t\t\t int (*func)(struct resource *, void *))\n{\n\tstruct resource res;\n\tint ret = -EINVAL;\n\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, desc, &res)) {\n\t\tret = (*func)(&res, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tstart = res.end + 1;\n\t}\n\n\treturn ret;\n}\n\n \nint walk_iomem_res_desc(unsigned long desc, unsigned long flags, u64 start,\n\t\tu64 end, void *arg, int (*func)(struct resource *, void *))\n{\n\treturn __walk_iomem_res_desc(start, end, flags, desc, arg, func);\n}\nEXPORT_SYMBOL_GPL(walk_iomem_res_desc);\n\n \nint walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\tint (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,\n\t\t\t\t     func);\n}\n\n \nint walk_mem_res(u64 start, u64 end, void *arg,\n\t\t int (*func)(struct resource *, void *))\n{\n\tunsigned long flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\treturn __walk_iomem_res_desc(start, end, flags, IORES_DESC_NONE, arg,\n\t\t\t\t     func);\n}\n\n \nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\t  void *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tresource_size_t start, end;\n\tunsigned long flags;\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tint ret = -EINVAL;\n\n\tstart = (u64) start_pfn << PAGE_SHIFT;\n\tend = ((u64)(start_pfn + nr_pages) << PAGE_SHIFT) - 1;\n\tflags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\twhile (start < end &&\n\t       !find_next_iomem_res(start, end, flags, IORES_DESC_NONE, &res)) {\n\t\tpfn = PFN_UP(res.start);\n\t\tend_pfn = PFN_DOWN(res.end + 1);\n\t\tif (end_pfn > pfn)\n\t\t\tret = (*func)(pfn, end_pfn - pfn, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart = res.end + 1;\n\t}\n\treturn ret;\n}\n\nstatic int __is_ram(unsigned long pfn, unsigned long nr_pages, void *arg)\n{\n\treturn 1;\n}\n\n \nint __weak page_is_ram(unsigned long pfn)\n{\n\treturn walk_system_ram_range(pfn, 1, NULL, __is_ram) == 1;\n}\nEXPORT_SYMBOL_GPL(page_is_ram);\n\nstatic int __region_intersects(struct resource *parent, resource_size_t start,\n\t\t\t       size_t size, unsigned long flags,\n\t\t\t       unsigned long desc)\n{\n\tstruct resource res;\n\tint type = 0; int other = 0;\n\tstruct resource *p;\n\n\tres.start = start;\n\tres.end = start + size - 1;\n\n\tfor (p = parent->child; p ; p = p->sibling) {\n\t\tbool is_type = (((p->flags & flags) == flags) &&\n\t\t\t\t((desc == IORES_DESC_NONE) ||\n\t\t\t\t (desc == p->desc)));\n\n\t\tif (resource_overlaps(p, &res))\n\t\t\tis_type ? type++ : other++;\n\t}\n\n\tif (type == 0)\n\t\treturn REGION_DISJOINT;\n\n\tif (other == 0)\n\t\treturn REGION_INTERSECTS;\n\n\treturn REGION_MIXED;\n}\n\n \nint region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tint ret;\n\n\tread_lock(&resource_lock);\n\tret = __region_intersects(&iomem_resource, start, size, flags, desc);\n\tread_unlock(&resource_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(region_intersects);\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}\n\nstatic resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->start;\n}\n\nstatic void resource_clip(struct resource *res, resource_size_t min,\n\t\t\t  resource_size_t max)\n{\n\tif (res->start < min)\n\t\tres->start = min;\n\tif (res->end > max)\n\t\tres->end = max;\n}\n\n \nstatic int __find_resource(struct resource *root, struct resource *old,\n\t\t\t struct resource *new,\n\t\t\t resource_size_t  size,\n\t\t\t struct resource_constraint *constraint)\n{\n\tstruct resource *this = root->child;\n\tstruct resource tmp = *new, avail, alloc;\n\n\ttmp.start = root->start;\n\t \n\tif (this && this->start == root->start) {\n\t\ttmp.start = (this == old) ? old->start : this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\tfor(;;) {\n\t\tif (this)\n\t\t\ttmp.end = (this == old) ?  this->end : this->start - 1;\n\t\telse\n\t\t\ttmp.end = root->end;\n\n\t\tif (tmp.end < tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->min, constraint->max);\n\t\tarch_remove_reservations(&tmp);\n\n\t\t \n\t\tavail.start = ALIGN(tmp.start, constraint->align);\n\t\tavail.end = tmp.end;\n\t\tavail.flags = new->flags & ~IORESOURCE_UNSET;\n\t\tif (avail.start >= tmp.start) {\n\t\t\talloc.flags = avail.flags;\n\t\t\talloc.start = constraint->alignf(constraint->alignf_data, &avail,\n\t\t\t\t\tsize, constraint->align);\n\t\t\talloc.end = alloc.start + size - 1;\n\t\t\tif (alloc.start <= alloc.end &&\n\t\t\t    resource_contains(&avail, &alloc)) {\n\t\t\t\tnew->start = alloc.start;\n\t\t\t\tnew->end = alloc.end;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\nnext:\t\tif (!this || this->end == root->end)\n\t\t\tbreak;\n\n\t\tif (this != old)\n\t\t\ttmp.start = this->end + 1;\n\t\tthis = this->sibling;\n\t}\n\treturn -EBUSY;\n}\n\n \nstatic int find_resource(struct resource *root, struct resource *new,\n\t\t\tresource_size_t size,\n\t\t\tstruct resource_constraint  *constraint)\n{\n\treturn  __find_resource(root, NULL, new, size, constraint);\n}\n\n \nstatic int reallocate_resource(struct resource *root, struct resource *old,\n\t\t\t       resource_size_t newsize,\n\t\t\t       struct resource_constraint *constraint)\n{\n\tint err=0;\n\tstruct resource new = *old;\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\n\tif ((err = __find_resource(root, old, &new, newsize, constraint)))\n\t\tgoto out;\n\n\tif (resource_contains(&new, old)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t\tgoto out;\n\t}\n\n\tif (old->child) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (resource_contains(old, &new)) {\n\t\told->start = new.start;\n\t\told->end = new.end;\n\t} else {\n\t\t__release_resource(old, true);\n\t\t*old = new;\n\t\tconflict = __request_resource(root, old);\n\t\tBUG_ON(conflict);\n\t}\nout:\n\twrite_unlock(&resource_lock);\n\treturn err;\n}\n\n\n \nint allocate_resource(struct resource *root, struct resource *new,\n\t\t      resource_size_t size, resource_size_t min,\n\t\t      resource_size_t max, resource_size_t align,\n\t\t      resource_size_t (*alignf)(void *,\n\t\t\t\t\t\tconst struct resource *,\n\t\t\t\t\t\tresource_size_t,\n\t\t\t\t\t\tresource_size_t),\n\t\t      void *alignf_data)\n{\n\tint err;\n\tstruct resource_constraint constraint;\n\n\tif (!alignf)\n\t\talignf = simple_align_resource;\n\n\tconstraint.min = min;\n\tconstraint.max = max;\n\tconstraint.align = align;\n\tconstraint.alignf = alignf;\n\tconstraint.alignf_data = alignf_data;\n\n\tif ( new->parent ) {\n\t\t \n\t\treturn reallocate_resource(root, new, size, &constraint);\n\t}\n\n\twrite_lock(&resource_lock);\n\terr = find_resource(root, new, size, &constraint);\n\tif (err >= 0 && __request_resource(root, new))\n\t\terr = -EBUSY;\n\twrite_unlock(&resource_lock);\n\treturn err;\n}\n\nEXPORT_SYMBOL(allocate_resource);\n\n \nstruct resource *lookup_resource(struct resource *root, resource_size_t start)\n{\n\tstruct resource *res;\n\n\tread_lock(&resource_lock);\n\tfor (res = root->child; res; res = res->sibling) {\n\t\tif (res->start == start)\n\t\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn res;\n}\n\n \nstatic struct resource * __insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *first, *next;\n\n\tfor (;; parent = first) {\n\t\tfirst = __request_resource(parent, new);\n\t\tif (!first)\n\t\t\treturn first;\n\n\t\tif (first == parent)\n\t\t\treturn first;\n\t\tif (WARN_ON(first == new))\t \n\t\t\treturn first;\n\n\t\tif ((first->start > new->start) || (first->end < new->end))\n\t\t\tbreak;\n\t\tif ((first->start == new->start) && (first->end == new->end))\n\t\t\tbreak;\n\t}\n\n\tfor (next = first; ; next = next->sibling) {\n\t\t \n\t\tif (next->start < new->start || next->end > new->end)\n\t\t\treturn next;\n\t\tif (!next->sibling)\n\t\t\tbreak;\n\t\tif (next->sibling->start > new->end)\n\t\t\tbreak;\n\t}\n\n\tnew->parent = parent;\n\tnew->sibling = next->sibling;\n\tnew->child = first;\n\n\tnext->sibling = NULL;\n\tfor (next = first; next; next = next->sibling)\n\t\tnext->parent = new;\n\n\tif (parent->child == first) {\n\t\tparent->child = new;\n\t} else {\n\t\tnext = parent->child;\n\t\twhile (next->sibling != first)\n\t\t\tnext = next->sibling;\n\t\tnext->sibling = new;\n\t}\n\treturn NULL;\n}\n\n \nstruct resource *insert_resource_conflict(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\twrite_lock(&resource_lock);\n\tconflict = __insert_resource(parent, new);\n\twrite_unlock(&resource_lock);\n\treturn conflict;\n}\n\n \nint insert_resource(struct resource *parent, struct resource *new)\n{\n\tstruct resource *conflict;\n\n\tconflict = insert_resource_conflict(parent, new);\n\treturn conflict ? -EBUSY : 0;\n}\nEXPORT_SYMBOL_GPL(insert_resource);\n\n \nvoid insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t \n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tpr_info(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}\n \nEXPORT_SYMBOL_NS_GPL(insert_resource_expand_to_fit, CXL);\n\n \nint remove_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, false);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(remove_resource);\n\nstatic int __adjust_resource(struct resource *res, resource_size_t start,\n\t\t\t\tresource_size_t size)\n{\n\tstruct resource *tmp, *parent = res->parent;\n\tresource_size_t end = start + size - 1;\n\tint result = -EBUSY;\n\n\tif (!parent)\n\t\tgoto skip;\n\n\tif ((start < parent->start) || (end > parent->end))\n\t\tgoto out;\n\n\tif (res->sibling && (res->sibling->start <= end))\n\t\tgoto out;\n\n\ttmp = parent->child;\n\tif (tmp != res) {\n\t\twhile (tmp->sibling != res)\n\t\t\ttmp = tmp->sibling;\n\t\tif (start <= tmp->end)\n\t\t\tgoto out;\n\t}\n\nskip:\n\tfor (tmp = res->child; tmp; tmp = tmp->sibling)\n\t\tif ((tmp->start < start) || (tmp->end > end))\n\t\t\tgoto out;\n\n\tres->start = start;\n\tres->end = end;\n\tresult = 0;\n\n out:\n\treturn result;\n}\n\n \nint adjust_resource(struct resource *res, resource_size_t start,\n\t\t    resource_size_t size)\n{\n\tint result;\n\n\twrite_lock(&resource_lock);\n\tresult = __adjust_resource(res, start, size);\n\twrite_unlock(&resource_lock);\n\treturn result;\n}\nEXPORT_SYMBOL(adjust_resource);\n\nstatic void __init\n__reserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t    resource_size_t end, const char *name)\n{\n\tstruct resource *parent = root;\n\tstruct resource *conflict;\n\tstruct resource *res = alloc_resource(GFP_ATOMIC);\n\tstruct resource *next_res = NULL;\n\tint type = resource_type(root);\n\n\tif (!res)\n\t\treturn;\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = end;\n\tres->flags = type | IORESOURCE_BUSY;\n\tres->desc = IORES_DESC_NONE;\n\n\twhile (1) {\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict) {\n\t\t\tif (!next_res)\n\t\t\t\tbreak;\n\t\t\tres = next_res;\n\t\t\tnext_res = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (conflict->start <= res->start &&\n\t\t\t\tconflict->end >= res->end) {\n\t\t\tfree_resource(res);\n\t\t\tWARN_ON(next_res);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (conflict->start > res->start) {\n\t\t\tend = res->end;\n\t\t\tres->end = conflict->start - 1;\n\t\t\tif (conflict->end < end) {\n\t\t\t\tnext_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->name = name;\n\t\t\t\tnext_res->start = conflict->end + 1;\n\t\t\t\tnext_res->end = end;\n\t\t\t\tnext_res->flags = type | IORESOURCE_BUSY;\n\t\t\t\tnext_res->desc = IORES_DESC_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tres->start = conflict->end + 1;\n\t\t}\n\t}\n\n}\n\nvoid __init\nreserve_region_with_split(struct resource *root, resource_size_t start,\n\t\t\t  resource_size_t end, const char *name)\n{\n\tint abort = 0;\n\n\twrite_lock(&resource_lock);\n\tif (root->start > start || root->end < end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start > root->end || end < root->start)\n\t\t\tabort = 1;\n\t\telse {\n\t\t\tif (end > root->end)\n\t\t\t\tend = root->end;\n\t\t\tif (start < root->start)\n\t\t\t\tstart = root->start;\n\t\t\tpr_err(\"fixing request to [0x%llx-0x%llx]\\n\",\n\t\t\t       (unsigned long long)start,\n\t\t\t       (unsigned long long)end);\n\t\t}\n\t\tdump_stack();\n\t}\n\tif (!abort)\n\t\t__reserve_region_with_split(root, start, end, name);\n\twrite_unlock(&resource_lock);\n}\n\n \nresource_size_t resource_alignment(struct resource *res)\n{\n\tswitch (res->flags & (IORESOURCE_SIZEALIGN | IORESOURCE_STARTALIGN)) {\n\tcase IORESOURCE_SIZEALIGN:\n\t\treturn resource_size(res);\n\tcase IORESOURCE_STARTALIGN:\n\t\treturn res->start;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \n\nstatic DECLARE_WAIT_QUEUE_HEAD(muxed_resource_wait);\n\nstatic struct inode *iomem_inode;\n\n#ifdef CONFIG_IO_STRICT_DEVMEM\nstatic void revoke_iomem(struct resource *res)\n{\n\t \n\tstruct inode *inode = smp_load_acquire(&iomem_inode);\n\n\t \n\tif (!inode)\n\t\treturn;\n\n\t \n\tif (devmem_is_allowed(PHYS_PFN(res->start)) &&\n\t    devmem_is_allowed(PHYS_PFN(res->end))) {\n\t\t \n\t\treturn;\n\t}\n\n\tunmap_mapping_range(inode->i_mapping, res->start, resource_size(res), 1);\n}\n#else\nstatic void revoke_iomem(struct resource *res) {}\n#endif\n\nstruct address_space *iomem_get_mapping(void)\n{\n\t \n\treturn smp_load_acquire(&iomem_inode)->i_mapping;\n}\n\nstatic int __request_region_locked(struct resource *res, struct resource *parent,\n\t\t\t\t   resource_size_t start, resource_size_t n,\n\t\t\t\t   const char *name, int flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tres->name = name;\n\tres->start = start;\n\tres->end = start + n - 1;\n\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tres->flags = resource_type(parent) | resource_ext_type(parent);\n\t\tres->flags |= IORESOURCE_BUSY | flags;\n\t\tres->desc = parent->desc;\n\n\t\tconflict = __request_resource(parent, res);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\t \n\t\tif (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY) {\n\t\t\tpr_warn(\"Unaddressable device %s %pR conflicts with %pR\",\n\t\t\t\tconflict->name, conflict, res);\n\t\t}\n\t\tif (conflict != parent) {\n\t\t\tif (!(conflict->flags & IORESOURCE_BUSY)) {\n\t\t\t\tparent = conflict;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (conflict->flags & flags & IORESOURCE_MUXED) {\n\t\t\tadd_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&muxed_resource_wait, &wait);\n\t\t\twrite_lock(&resource_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \nstruct resource *__request_region(struct resource *parent,\n\t\t\t\t  resource_size_t start, resource_size_t n,\n\t\t\t\t  const char *name, int flags)\n{\n\tstruct resource *res = alloc_resource(GFP_KERNEL);\n\tint ret;\n\n\tif (!res)\n\t\treturn NULL;\n\n\twrite_lock(&resource_lock);\n\tret = __request_region_locked(res, parent, start, n, name, flags);\n\twrite_unlock(&resource_lock);\n\n\tif (ret) {\n\t\tfree_resource(res);\n\t\treturn NULL;\n\t}\n\n\tif (parent == &iomem_resource)\n\t\trevoke_iomem(res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(__request_region);\n\n \nvoid __release_region(struct resource *parent, resource_size_t start,\n\t\t      resource_size_t n)\n{\n\tstruct resource **p;\n\tresource_size_t end;\n\n\tp = &parent->child;\n\tend = start + n - 1;\n\n\twrite_lock(&resource_lock);\n\n\tfor (;;) {\n\t\tstruct resource *res = *p;\n\n\t\tif (!res)\n\t\t\tbreak;\n\t\tif (res->start <= start && res->end >= end) {\n\t\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\t\tp = &res->child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res->start != start || res->end != end)\n\t\t\t\tbreak;\n\t\t\t*p = res->sibling;\n\t\t\twrite_unlock(&resource_lock);\n\t\t\tif (res->flags & IORESOURCE_MUXED)\n\t\t\t\twake_up(&muxed_resource_wait);\n\t\t\tfree_resource(res);\n\t\t\treturn;\n\t\t}\n\t\tp = &res->sibling;\n\t}\n\n\twrite_unlock(&resource_lock);\n\n\tpr_warn(\"Trying to free nonexistent resource <%pa-%pa>\\n\", &start, &end);\n}\nEXPORT_SYMBOL(__release_region);\n\n#ifdef CONFIG_MEMORY_HOTREMOVE\n \nvoid release_mem_region_adjustable(resource_size_t start, resource_size_t size)\n{\n\tstruct resource *parent = &iomem_resource;\n\tstruct resource *new_res = NULL;\n\tbool alloc_nofail = false;\n\tstruct resource **p;\n\tstruct resource *res;\n\tresource_size_t end;\n\n\tend = start + size - 1;\n\tif (WARN_ON_ONCE((start < parent->start) || (end > parent->end)))\n\t\treturn;\n\n\t \nretry:\n\tnew_res = alloc_resource(GFP_KERNEL | (alloc_nofail ? __GFP_NOFAIL : 0));\n\n\tp = &parent->child;\n\twrite_lock(&resource_lock);\n\n\twhile ((res = *p)) {\n\t\tif (res->start >= end)\n\t\t\tbreak;\n\n\t\t \n\t\tif (res->start > start || res->end < end) {\n\t\t\tp = &res->sibling;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(res->flags & IORESOURCE_MEM))\n\t\t\tbreak;\n\n\t\tif (!(res->flags & IORESOURCE_BUSY)) {\n\t\t\tp = &res->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (res->start == start && res->end == end) {\n\t\t\t \n\t\t\t*p = res->sibling;\n\t\t\tfree_resource(res);\n\t\t} else if (res->start == start && res->end != end) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(__adjust_resource(res, end + 1,\n\t\t\t\t\t\t       res->end - end));\n\t\t} else if (res->start != start && res->end == end) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(__adjust_resource(res, res->start,\n\t\t\t\t\t\t       start - res->start));\n\t\t} else {\n\t\t\t \n\t\t\tif (!new_res) {\n\t\t\t\tnew_res = alloc_resource(GFP_ATOMIC);\n\t\t\t\tif (!new_res) {\n\t\t\t\t\talloc_nofail = true;\n\t\t\t\t\twrite_unlock(&resource_lock);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnew_res->name = res->name;\n\t\t\tnew_res->start = end + 1;\n\t\t\tnew_res->end = res->end;\n\t\t\tnew_res->flags = res->flags;\n\t\t\tnew_res->desc = res->desc;\n\t\t\tnew_res->parent = res->parent;\n\t\t\tnew_res->sibling = res->sibling;\n\t\t\tnew_res->child = NULL;\n\n\t\t\tif (WARN_ON_ONCE(__adjust_resource(res, res->start,\n\t\t\t\t\t\t\t   start - res->start)))\n\t\t\t\tbreak;\n\t\t\tres->sibling = new_res;\n\t\t\tnew_res = NULL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\twrite_unlock(&resource_lock);\n\tfree_resource(new_res);\n}\n#endif\t \n\n#ifdef CONFIG_MEMORY_HOTPLUG\nstatic bool system_ram_resources_mergeable(struct resource *r1,\n\t\t\t\t\t   struct resource *r2)\n{\n\t \n\treturn r1->flags == r2->flags && r1->end + 1 == r2->start &&\n\t       r1->name == r2->name && r1->desc == r2->desc &&\n\t       !r1->child && !r2->child;\n}\n\n \nvoid merge_system_ram_resource(struct resource *res)\n{\n\tconst unsigned long flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;\n\tstruct resource *cur;\n\n\tif (WARN_ON_ONCE((res->flags & flags) != flags))\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tres->flags |= IORESOURCE_SYSRAM_MERGEABLE;\n\n\t \n\tcur = res->sibling;\n\tif (cur && system_ram_resources_mergeable(res, cur)) {\n\t\tres->end = cur->end;\n\t\tres->sibling = cur->sibling;\n\t\tfree_resource(cur);\n\t}\n\n\t \n\tcur = res->parent->child;\n\twhile (cur && cur->sibling != res)\n\t\tcur = cur->sibling;\n\tif (cur && system_ram_resources_mergeable(cur, res)) {\n\t\tcur->end = res->end;\n\t\tcur->sibling = res->sibling;\n\t\tfree_resource(res);\n\t}\n\twrite_unlock(&resource_lock);\n}\n#endif\t \n\n \nstatic void devm_resource_release(struct device *dev, void *ptr)\n{\n\tstruct resource **r = ptr;\n\n\trelease_resource(*r);\n}\n\n \nint devm_request_resource(struct device *dev, struct resource *root,\n\t\t\t  struct resource *new)\n{\n\tstruct resource *conflict, **ptr;\n\n\tptr = devres_alloc(devm_resource_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\t*ptr = new;\n\n\tconflict = request_resource_conflict(root, new);\n\tif (conflict) {\n\t\tdev_err(dev, \"resource collision: %pR conflicts with %s %pR\\n\",\n\t\t\tnew, conflict->name, conflict);\n\t\tdevres_free(ptr);\n\t\treturn -EBUSY;\n\t}\n\n\tdevres_add(dev, ptr);\n\treturn 0;\n}\nEXPORT_SYMBOL(devm_request_resource);\n\nstatic int devm_resource_match(struct device *dev, void *res, void *data)\n{\n\tstruct resource **ptr = res;\n\n\treturn *ptr == data;\n}\n\n \nvoid devm_release_resource(struct device *dev, struct resource *new)\n{\n\tWARN_ON(devres_release(dev, devm_resource_release, devm_resource_match,\n\t\t\t       new));\n}\nEXPORT_SYMBOL(devm_release_resource);\n\nstruct region_devres {\n\tstruct resource *parent;\n\tresource_size_t start;\n\tresource_size_t n;\n};\n\nstatic void devm_region_release(struct device *dev, void *res)\n{\n\tstruct region_devres *this = res;\n\n\t__release_region(this->parent, this->start, this->n);\n}\n\nstatic int devm_region_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct region_devres *this = res, *match = match_data;\n\n\treturn this->parent == match->parent &&\n\t\tthis->start == match->start && this->n == match->n;\n}\n\nstruct resource *\n__devm_request_region(struct device *dev, struct resource *parent,\n\t\t      resource_size_t start, resource_size_t n, const char *name)\n{\n\tstruct region_devres *dr = NULL;\n\tstruct resource *res;\n\n\tdr = devres_alloc(devm_region_release, sizeof(struct region_devres),\n\t\t\t  GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tdr->parent = parent;\n\tdr->start = start;\n\tdr->n = n;\n\n\tres = __request_region(parent, start, n, name, 0);\n\tif (res)\n\t\tdevres_add(dev, dr);\n\telse\n\t\tdevres_free(dr);\n\n\treturn res;\n}\nEXPORT_SYMBOL(__devm_request_region);\n\nvoid __devm_release_region(struct device *dev, struct resource *parent,\n\t\t\t   resource_size_t start, resource_size_t n)\n{\n\tstruct region_devres match_data = { parent, start, n };\n\n\t__release_region(parent, start, n);\n\tWARN_ON(devres_destroy(dev, devm_region_release, devm_region_match,\n\t\t\t       &match_data));\n}\nEXPORT_SYMBOL(__devm_release_region);\n\n \n#define MAXRESERVE 4\nstatic int __init reserve_setup(char *str)\n{\n\tstatic int reserved;\n\tstatic struct resource reserve[MAXRESERVE];\n\n\tfor (;;) {\n\t\tunsigned int io_start, io_num;\n\t\tint x = reserved;\n\t\tstruct resource *parent;\n\n\t\tif (get_option(&str, &io_start) != 2)\n\t\t\tbreak;\n\t\tif (get_option(&str, &io_num) == 0)\n\t\t\tbreak;\n\t\tif (x < MAXRESERVE) {\n\t\t\tstruct resource *res = reserve + x;\n\n\t\t\t \n\t\t\tif (io_start < 0x10000) {\n\t\t\t\tres->flags = IORESOURCE_IO;\n\t\t\t\tparent = &ioport_resource;\n\t\t\t} else {\n\t\t\t\tres->flags = IORESOURCE_MEM;\n\t\t\t\tparent = &iomem_resource;\n\t\t\t}\n\t\t\tres->name = \"reserved\";\n\t\t\tres->start = io_start;\n\t\t\tres->end = io_start + io_num - 1;\n\t\t\tres->flags |= IORESOURCE_BUSY;\n\t\t\tres->desc = IORES_DESC_NONE;\n\t\t\tres->child = NULL;\n\t\t\tif (request_resource(parent, res) == 0)\n\t\t\t\treserved = x+1;\n\t\t}\n\t}\n\treturn 1;\n}\n__setup(\"reserve=\", reserve_setup);\n\n \nint iomem_map_sanity_check(resource_size_t addr, unsigned long size)\n{\n\tstruct resource *p = &iomem_resource;\n\tresource_size_t end = addr + size - 1;\n\tint err = 0;\n\tloff_t l;\n\n\tread_lock(&resource_lock);\n\tfor (p = p->child; p ; p = r_next(NULL, p, &l)) {\n\t\t \n\t\tif (p->start > end)\n\t\t\tcontinue;\n\t\tif (p->end < addr)\n\t\t\tcontinue;\n\t\tif (PFN_DOWN(p->start) <= PFN_DOWN(addr) &&\n\t\t    PFN_DOWN(p->end) >= PFN_DOWN(end))\n\t\t\tcontinue;\n\t\t \n\t\tif (p->flags & IORESOURCE_BUSY)\n\t\t\tcontinue;\n\n\t\tpr_warn(\"resource sanity check: requesting [mem %pa-%pa], which spans more than %s %pR\\n\",\n\t\t\t&addr, &end, p->name, p);\n\t\terr = -1;\n\t\tbreak;\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}\n\n#ifdef CONFIG_STRICT_DEVMEM\nstatic int strict_iomem_checks = 1;\n#else\nstatic int strict_iomem_checks;\n#endif\n\n \nbool resource_is_exclusive(struct resource *root, u64 addr, resource_size_t size)\n{\n\tconst unsigned int exclusive_system_ram = IORESOURCE_SYSTEM_RAM |\n\t\t\t\t\t\t  IORESOURCE_EXCLUSIVE;\n\tbool skip_children = false, err = false;\n\tstruct resource *p;\n\n\tread_lock(&resource_lock);\n\tfor_each_resource(root, p, skip_children) {\n\t\tif (p->start >= addr + size)\n\t\t\tbreak;\n\t\tif (p->end < addr) {\n\t\t\tskip_children = true;\n\t\t\tcontinue;\n\t\t}\n\t\tskip_children = false;\n\n\t\t \n\t\tif ((p->flags & exclusive_system_ram) == exclusive_system_ram) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!strict_iomem_checks || !(p->flags & IORESOURCE_BUSY))\n\t\t\tcontinue;\n\t\tif (IS_ENABLED(CONFIG_IO_STRICT_DEVMEM)\n\t\t\t\t|| p->flags & IORESOURCE_EXCLUSIVE) {\n\t\t\terr = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&resource_lock);\n\n\treturn err;\n}\n\nbool iomem_is_exclusive(u64 addr)\n{\n\treturn resource_is_exclusive(&iomem_resource, addr & PAGE_MASK,\n\t\t\t\t     PAGE_SIZE);\n}\n\nstruct resource_entry *resource_list_create_entry(struct resource *res,\n\t\t\t\t\t\t  size_t extra_size)\n{\n\tstruct resource_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry) + extra_size, GFP_KERNEL);\n\tif (entry) {\n\t\tINIT_LIST_HEAD(&entry->node);\n\t\tentry->res = res ? res : &entry->__res;\n\t}\n\n\treturn entry;\n}\nEXPORT_SYMBOL(resource_list_create_entry);\n\nvoid resource_list_free(struct list_head *head)\n{\n\tstruct resource_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, node)\n\t\tresource_list_destroy_entry(entry);\n}\nEXPORT_SYMBOL(resource_list_free);\n\n#ifdef CONFIG_GET_FREE_REGION\n#define GFR_DESCENDING\t\t(1UL << 0)\n#define GFR_REQUEST_REGION\t(1UL << 1)\n#define GFR_DEFAULT_ALIGN (1UL << PA_SECTION_SHIFT)\n\nstatic resource_size_t gfr_start(struct resource *base, resource_size_t size,\n\t\t\t\t resource_size_t align, unsigned long flags)\n{\n\tif (flags & GFR_DESCENDING) {\n\t\tresource_size_t end;\n\n\t\tend = min_t(resource_size_t, base->end,\n\t\t\t    (1ULL << MAX_PHYSMEM_BITS) - 1);\n\t\treturn end - size + 1;\n\t}\n\n\treturn ALIGN(base->start, align);\n}\n\nstatic bool gfr_continue(struct resource *base, resource_size_t addr,\n\t\t\t resource_size_t size, unsigned long flags)\n{\n\tif (flags & GFR_DESCENDING)\n\t\treturn addr > size && addr >= base->start;\n\t \n\treturn addr > addr - size &&\n\t       addr <= min_t(resource_size_t, base->end,\n\t\t\t     (1ULL << MAX_PHYSMEM_BITS) - 1);\n}\n\nstatic resource_size_t gfr_next(resource_size_t addr, resource_size_t size,\n\t\t\t\tunsigned long flags)\n{\n\tif (flags & GFR_DESCENDING)\n\t\treturn addr - size;\n\treturn addr + size;\n}\n\nstatic void remove_free_mem_region(void *_res)\n{\n\tstruct resource *res = _res;\n\n\tif (res->parent)\n\t\tremove_resource(res);\n\tfree_resource(res);\n}\n\nstatic struct resource *\nget_free_mem_region(struct device *dev, struct resource *base,\n\t\t    resource_size_t size, const unsigned long align,\n\t\t    const char *name, const unsigned long desc,\n\t\t    const unsigned long flags)\n{\n\tresource_size_t addr;\n\tstruct resource *res;\n\tstruct region_devres *dr = NULL;\n\n\tsize = ALIGN(size, align);\n\n\tres = alloc_resource(GFP_KERNEL);\n\tif (!res)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (dev && (flags & GFR_REQUEST_REGION)) {\n\t\tdr = devres_alloc(devm_region_release,\n\t\t\t\tsizeof(struct region_devres), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tfree_resource(res);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else if (dev) {\n\t\tif (devm_add_action_or_reset(dev, remove_free_mem_region, res))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twrite_lock(&resource_lock);\n\tfor (addr = gfr_start(base, size, align, flags);\n\t     gfr_continue(base, addr, align, flags);\n\t     addr = gfr_next(addr, align, flags)) {\n\t\tif (__region_intersects(base, addr, size, 0, IORES_DESC_NONE) !=\n\t\t    REGION_DISJOINT)\n\t\t\tcontinue;\n\n\t\tif (flags & GFR_REQUEST_REGION) {\n\t\t\tif (__request_region_locked(res, &iomem_resource, addr,\n\t\t\t\t\t\t    size, name, 0))\n\t\t\t\tbreak;\n\n\t\t\tif (dev) {\n\t\t\t\tdr->parent = &iomem_resource;\n\t\t\t\tdr->start = addr;\n\t\t\t\tdr->n = size;\n\t\t\t\tdevres_add(dev, dr);\n\t\t\t}\n\n\t\t\tres->desc = desc;\n\t\t\twrite_unlock(&resource_lock);\n\n\n\t\t\t \n\t\t\trevoke_iomem(res);\n\t\t} else {\n\t\t\tres->start = addr;\n\t\t\tres->end = addr + size - 1;\n\t\t\tres->name = name;\n\t\t\tres->desc = desc;\n\t\t\tres->flags = IORESOURCE_MEM;\n\n\t\t\t \n\t\t\tif (__insert_resource(base, res) || res->child)\n\t\t\t\tbreak;\n\n\t\t\twrite_unlock(&resource_lock);\n\t\t}\n\n\t\treturn res;\n\t}\n\twrite_unlock(&resource_lock);\n\n\tif (flags & GFR_REQUEST_REGION) {\n\t\tfree_resource(res);\n\t\tdevres_free(dr);\n\t} else if (dev)\n\t\tdevm_release_action(dev, remove_free_mem_region, res);\n\n\treturn ERR_PTR(-ERANGE);\n}\n\n \nstruct resource *devm_request_free_mem_region(struct device *dev,\n\t\tstruct resource *base, unsigned long size)\n{\n\tunsigned long flags = GFR_DESCENDING | GFR_REQUEST_REGION;\n\n\treturn get_free_mem_region(dev, base, size, GFR_DEFAULT_ALIGN,\n\t\t\t\t   dev_name(dev),\n\t\t\t\t   IORES_DESC_DEVICE_PRIVATE_MEMORY, flags);\n}\nEXPORT_SYMBOL_GPL(devm_request_free_mem_region);\n\nstruct resource *request_free_mem_region(struct resource *base,\n\t\tunsigned long size, const char *name)\n{\n\tunsigned long flags = GFR_DESCENDING | GFR_REQUEST_REGION;\n\n\treturn get_free_mem_region(NULL, base, size, GFR_DEFAULT_ALIGN, name,\n\t\t\t\t   IORES_DESC_DEVICE_PRIVATE_MEMORY, flags);\n}\nEXPORT_SYMBOL_GPL(request_free_mem_region);\n\n \nstruct resource *alloc_free_mem_region(struct resource *base,\n\t\t\t\t       unsigned long size, unsigned long align,\n\t\t\t\t       const char *name)\n{\n\t \n\tunsigned long flags = 0;\n\n\treturn get_free_mem_region(NULL, base, size, align, name,\n\t\t\t\t   IORES_DESC_NONE, flags);\n}\nEXPORT_SYMBOL_NS_GPL(alloc_free_mem_region, CXL);\n#endif  \n\nstatic int __init strict_iomem(char *str)\n{\n\tif (strstr(str, \"relaxed\"))\n\t\tstrict_iomem_checks = 0;\n\tif (strstr(str, \"strict\"))\n\t\tstrict_iomem_checks = 1;\n\treturn 1;\n}\n\nstatic int iomem_fs_init_fs_context(struct fs_context *fc)\n{\n\treturn init_pseudo(fc, DEVMEM_MAGIC) ? 0 : -ENOMEM;\n}\n\nstatic struct file_system_type iomem_fs_type = {\n\t.name\t\t= \"iomem\",\n\t.owner\t\t= THIS_MODULE,\n\t.init_fs_context = iomem_fs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init iomem_init_inode(void)\n{\n\tstatic struct vfsmount *iomem_vfs_mount;\n\tstatic int iomem_fs_cnt;\n\tstruct inode *inode;\n\tint rc;\n\n\trc = simple_pin_fs(&iomem_fs_type, &iomem_vfs_mount, &iomem_fs_cnt);\n\tif (rc < 0) {\n\t\tpr_err(\"Cannot mount iomem pseudo filesystem: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tinode = alloc_anon_inode(iomem_vfs_mount->mnt_sb);\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tpr_err(\"Cannot allocate inode for iomem: %d\\n\", rc);\n\t\tsimple_release_fs(&iomem_vfs_mount, &iomem_fs_cnt);\n\t\treturn rc;\n\t}\n\n\t \n\tsmp_store_release(&iomem_inode, inode);\n\n\treturn 0;\n}\n\nfs_initcall(iomem_init_inode);\n\n__setup(\"iomem=\", strict_iomem);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}