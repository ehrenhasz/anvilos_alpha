{
  "module_name": "printk.c",
  "hash_id": "e1171a4020a0c67d287b1f8c630fe732de52824e61102a0c24442c1cddbdf76f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/printk/printk.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/nmi.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/security.h>\n#include <linux/memblock.h>\n#include <linux/syscalls.h>\n#include <linux/crash_core.h>\n#include <linux/ratelimit.h>\n#include <linux/kmsg_dump.h>\n#include <linux/syslog.h>\n#include <linux/cpu.h>\n#include <linux/rculist.h>\n#include <linux/poll.h>\n#include <linux/irq_work.h>\n#include <linux/ctype.h>\n#include <linux/uio.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\n#include <linux/uaccess.h>\n#include <asm/sections.h>\n\n#include <trace/events/initcall.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/printk.h>\n\n#include \"printk_ringbuffer.h\"\n#include \"console_cmdline.h\"\n#include \"braille.h\"\n#include \"internal.h\"\n\nint console_printk[4] = {\n\tCONSOLE_LOGLEVEL_DEFAULT,\t \n\tMESSAGE_LOGLEVEL_DEFAULT,\t \n\tCONSOLE_LOGLEVEL_MIN,\t\t \n\tCONSOLE_LOGLEVEL_DEFAULT,\t \n};\nEXPORT_SYMBOL_GPL(console_printk);\n\natomic_t ignore_console_lock_warning __read_mostly = ATOMIC_INIT(0);\nEXPORT_SYMBOL(ignore_console_lock_warning);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(console);\n\n \nint oops_in_progress;\nEXPORT_SYMBOL(oops_in_progress);\n\n \nstatic DEFINE_MUTEX(console_mutex);\n\n \nstatic DEFINE_SEMAPHORE(console_sem, 1);\nHLIST_HEAD(console_list);\nEXPORT_SYMBOL_GPL(console_list);\nDEFINE_STATIC_SRCU(console_srcu);\n\n \nint __read_mostly suppress_printk;\n\n \nstatic int __read_mostly suppress_panic_printk;\n\n#ifdef CONFIG_LOCKDEP\nstatic struct lockdep_map console_lock_dep_map = {\n\t.name = \"console_lock\"\n};\n\nvoid lockdep_assert_console_list_lock_held(void)\n{\n\tlockdep_assert_held(&console_mutex);\n}\nEXPORT_SYMBOL(lockdep_assert_console_list_lock_held);\n#endif\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nbool console_srcu_read_lock_is_held(void)\n{\n\treturn srcu_read_lock_held(&console_srcu);\n}\nEXPORT_SYMBOL(console_srcu_read_lock_is_held);\n#endif\n\nenum devkmsg_log_bits {\n\t__DEVKMSG_LOG_BIT_ON = 0,\n\t__DEVKMSG_LOG_BIT_OFF,\n\t__DEVKMSG_LOG_BIT_LOCK,\n};\n\nenum devkmsg_log_masks {\n\tDEVKMSG_LOG_MASK_ON             = BIT(__DEVKMSG_LOG_BIT_ON),\n\tDEVKMSG_LOG_MASK_OFF            = BIT(__DEVKMSG_LOG_BIT_OFF),\n\tDEVKMSG_LOG_MASK_LOCK           = BIT(__DEVKMSG_LOG_BIT_LOCK),\n};\n\n \n#define DEVKMSG_LOG_MASK_DEFAULT\t0\n\nstatic unsigned int __read_mostly devkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\nstatic int __control_devkmsg(char *str)\n{\n\tsize_t len;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tlen = str_has_prefix(str, \"on\");\n\tif (len) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_ON;\n\t\treturn len;\n\t}\n\n\tlen = str_has_prefix(str, \"off\");\n\tif (len) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_OFF;\n\t\treturn len;\n\t}\n\n\tlen = str_has_prefix(str, \"ratelimit\");\n\tif (len) {\n\t\tdevkmsg_log = DEVKMSG_LOG_MASK_DEFAULT;\n\t\treturn len;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int __init control_devkmsg(char *str)\n{\n\tif (__control_devkmsg(str) < 0) {\n\t\tpr_warn(\"printk.devkmsg: bad option string '%s'\\n\", str);\n\t\treturn 1;\n\t}\n\n\t \n\tif (devkmsg_log == DEVKMSG_LOG_MASK_ON)\n\t\tstrcpy(devkmsg_log_str, \"on\");\n\telse if (devkmsg_log == DEVKMSG_LOG_MASK_OFF)\n\t\tstrcpy(devkmsg_log_str, \"off\");\n\t \n\n\t \n\tdevkmsg_log |= DEVKMSG_LOG_MASK_LOCK;\n\n\treturn 1;\n}\n__setup(\"printk.devkmsg=\", control_devkmsg);\n\nchar devkmsg_log_str[DEVKMSG_STR_MAX_SIZE] = \"ratelimit\";\n#if defined(CONFIG_PRINTK) && defined(CONFIG_SYSCTL)\nint devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write,\n\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar old_str[DEVKMSG_STR_MAX_SIZE];\n\tunsigned int old;\n\tint err;\n\n\tif (write) {\n\t\tif (devkmsg_log & DEVKMSG_LOG_MASK_LOCK)\n\t\t\treturn -EINVAL;\n\n\t\told = devkmsg_log;\n\t\tstrncpy(old_str, devkmsg_log_str, DEVKMSG_STR_MAX_SIZE);\n\t}\n\n\terr = proc_dostring(table, write, buffer, lenp, ppos);\n\tif (err)\n\t\treturn err;\n\n\tif (write) {\n\t\terr = __control_devkmsg(devkmsg_log_str);\n\n\t\t \n\t\tif (err < 0 || (err + 1 != *lenp)) {\n\n\t\t\t \n\t\t\tdevkmsg_log = old;\n\t\t\tstrncpy(devkmsg_log_str, old_str, DEVKMSG_STR_MAX_SIZE);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif  \n\n \nvoid console_list_lock(void)\n{\n\t \n\tWARN_ON_ONCE(debug_lockdep_rcu_enabled() &&\n\t\t     srcu_read_lock_held(&console_srcu));\n\n\tmutex_lock(&console_mutex);\n}\nEXPORT_SYMBOL(console_list_lock);\n\n \nvoid console_list_unlock(void)\n{\n\tmutex_unlock(&console_mutex);\n}\nEXPORT_SYMBOL(console_list_unlock);\n\n \nint console_srcu_read_lock(void)\n{\n\treturn srcu_read_lock_nmisafe(&console_srcu);\n}\nEXPORT_SYMBOL(console_srcu_read_lock);\n\n \nvoid console_srcu_read_unlock(int cookie)\n{\n\tsrcu_read_unlock_nmisafe(&console_srcu, cookie);\n}\nEXPORT_SYMBOL(console_srcu_read_unlock);\n\n \n#define down_console_sem() do { \\\n\tdown(&console_sem);\\\n\tmutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);\\\n} while (0)\n\nstatic int __down_trylock_console_sem(unsigned long ip)\n{\n\tint lock_failed;\n\tunsigned long flags;\n\n\t \n\tprintk_safe_enter_irqsave(flags);\n\tlock_failed = down_trylock(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n\n\tif (lock_failed)\n\t\treturn 1;\n\tmutex_acquire(&console_lock_dep_map, 0, 1, ip);\n\treturn 0;\n}\n#define down_trylock_console_sem() __down_trylock_console_sem(_RET_IP_)\n\nstatic void __up_console_sem(unsigned long ip)\n{\n\tunsigned long flags;\n\n\tmutex_release(&console_lock_dep_map, ip);\n\n\tprintk_safe_enter_irqsave(flags);\n\tup(&console_sem);\n\tprintk_safe_exit_irqrestore(flags);\n}\n#define up_console_sem() __up_console_sem(_RET_IP_)\n\nstatic bool panic_in_progress(void)\n{\n\treturn unlikely(atomic_read(&panic_cpu) != PANIC_CPU_INVALID);\n}\n\n \nstatic int console_locked;\n\n \n\n#define MAX_CMDLINECONSOLES 8\n\nstatic struct console_cmdline console_cmdline[MAX_CMDLINECONSOLES];\n\nstatic int preferred_console = -1;\nint console_set_on_cmdline;\nEXPORT_SYMBOL(console_set_on_cmdline);\n\n \nstatic int console_may_schedule;\n\nenum con_msg_format_flags {\n\tMSG_FORMAT_DEFAULT\t= 0,\n\tMSG_FORMAT_SYSLOG\t= (1 << 0),\n};\n\nstatic int console_msg_format = MSG_FORMAT_DEFAULT;\n\n \n\n \nstatic DEFINE_MUTEX(syslog_lock);\n\n#ifdef CONFIG_PRINTK\nDECLARE_WAIT_QUEUE_HEAD(log_wait);\n \n \nstatic u64 syslog_seq;\nstatic size_t syslog_partial;\nstatic bool syslog_time;\n\nstruct latched_seq {\n\tseqcount_latch_t\tlatch;\n\tu64\t\t\tval[2];\n};\n\n \nstatic struct latched_seq clear_seq = {\n\t.latch\t\t= SEQCNT_LATCH_ZERO(clear_seq.latch),\n\t.val[0]\t\t= 0,\n\t.val[1]\t\t= 0,\n};\n\n#define LOG_LEVEL(v)\t\t((v) & 0x07)\n#define LOG_FACILITY(v)\t\t((v) >> 3 & 0xff)\n\n \n#define LOG_ALIGN __alignof__(unsigned long)\n#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)\n#define LOG_BUF_LEN_MAX (u32)(1 << 31)\nstatic char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);\nstatic char *log_buf = __log_buf;\nstatic u32 log_buf_len = __LOG_BUF_LEN;\n\n \n#define PRB_AVGBITS 5\t \n\n#if CONFIG_LOG_BUF_SHIFT <= PRB_AVGBITS\n#error CONFIG_LOG_BUF_SHIFT value too small.\n#endif\n_DEFINE_PRINTKRB(printk_rb_static, CONFIG_LOG_BUF_SHIFT - PRB_AVGBITS,\n\t\t PRB_AVGBITS, &__log_buf[0]);\n\nstatic struct printk_ringbuffer printk_rb_dynamic;\n\nstatic struct printk_ringbuffer *prb = &printk_rb_static;\n\n \nstatic bool __printk_percpu_data_ready __ro_after_init;\n\nbool printk_percpu_data_ready(void)\n{\n\treturn __printk_percpu_data_ready;\n}\n\n \nstatic void latched_seq_write(struct latched_seq *ls, u64 val)\n{\n\traw_write_seqcount_latch(&ls->latch);\n\tls->val[0] = val;\n\traw_write_seqcount_latch(&ls->latch);\n\tls->val[1] = val;\n}\n\n \nstatic u64 latched_seq_read_nolock(struct latched_seq *ls)\n{\n\tunsigned int seq;\n\tunsigned int idx;\n\tu64 val;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&ls->latch);\n\t\tidx = seq & 0x1;\n\t\tval = ls->val[idx];\n\t} while (raw_read_seqcount_latch_retry(&ls->latch, seq));\n\n\treturn val;\n}\n\n \nchar *log_buf_addr_get(void)\n{\n\treturn log_buf;\n}\n\n \nu32 log_buf_len_get(void)\n{\n\treturn log_buf_len;\n}\n\n \n#define MAX_LOG_TAKE_PART 4\nstatic const char trunc_msg[] = \"<truncated>\";\n\nstatic void truncate_msg(u16 *text_len, u16 *trunc_msg_len)\n{\n\t \n\tu32 max_text_len = log_buf_len / MAX_LOG_TAKE_PART;\n\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\n\t \n\t*trunc_msg_len = strlen(trunc_msg);\n\tif (*text_len >= *trunc_msg_len)\n\t\t*text_len -= *trunc_msg_len;\n\telse\n\t\t*trunc_msg_len = 0;\n}\n\nint dmesg_restrict = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);\n\nstatic int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t \n\treturn type != SYSLOG_ACTION_READ_ALL &&\n\t       type != SYSLOG_ACTION_SIZE_BUFFER;\n}\n\nstatic int check_syslog_permissions(int type, int source)\n{\n\t \n\tif (source == SYSLOG_FROM_PROC && type != SYSLOG_ACTION_OPEN)\n\t\tgoto ok;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(CAP_SYSLOG))\n\t\t\tgoto ok;\n\t\t \n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tpr_warn_once(\"%s (%d): Attempt to access syslog with \"\n\t\t\t\t     \"CAP_SYS_ADMIN but no CAP_SYSLOG \"\n\t\t\t\t     \"(deprecated).\\n\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\tgoto ok;\n\t\t}\n\t\treturn -EPERM;\n\t}\nok:\n\treturn security_syslog(type);\n}\n\nstatic void append_char(char **pp, char *e, char c)\n{\n\tif (*pp < e)\n\t\t*(*pp)++ = c;\n}\n\nstatic ssize_t info_print_ext_header(char *buf, size_t size,\n\t\t\t\t     struct printk_info *info)\n{\n\tu64 ts_usec = info->ts_nsec;\n\tchar caller[20];\n#ifdef CONFIG_PRINTK_CALLER\n\tu32 id = info->caller_id;\n\n\tsnprintf(caller, sizeof(caller), \",caller=%c%u\",\n\t\t id & 0x80000000 ? 'C' : 'T', id & ~0x80000000);\n#else\n\tcaller[0] = '\\0';\n#endif\n\n\tdo_div(ts_usec, 1000);\n\n\treturn scnprintf(buf, size, \"%u,%llu,%llu,%c%s;\",\n\t\t\t (info->facility << 3) | info->level, info->seq,\n\t\t\t ts_usec, info->flags & LOG_CONT ? 'c' : '-', caller);\n}\n\nstatic ssize_t msg_add_ext_text(char *buf, size_t size,\n\t\t\t\tconst char *text, size_t text_len,\n\t\t\t\tunsigned char endc)\n{\n\tchar *p = buf, *e = buf + size;\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < text_len; i++) {\n\t\tunsigned char c = text[i];\n\n\t\tif (c < ' ' || c >= 127 || c == '\\\\')\n\t\t\tp += scnprintf(p, e - p, \"\\\\x%02x\", c);\n\t\telse\n\t\t\tappend_char(&p, e, c);\n\t}\n\tappend_char(&p, e, endc);\n\n\treturn p - buf;\n}\n\nstatic ssize_t msg_add_dict_text(char *buf, size_t size,\n\t\t\t\t const char *key, const char *val)\n{\n\tsize_t val_len = strlen(val);\n\tssize_t len;\n\n\tif (!val_len)\n\t\treturn 0;\n\n\tlen = msg_add_ext_text(buf, size, \"\", 0, ' ');\t \n\tlen += msg_add_ext_text(buf + len, size - len, key, strlen(key), '=');\n\tlen += msg_add_ext_text(buf + len, size - len, val, val_len, '\\n');\n\n\treturn len;\n}\n\nstatic ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *text, size_t text_len,\n\t\t\t\t  struct dev_printk_info *dev_info)\n{\n\tssize_t len;\n\n\tlen = msg_add_ext_text(buf, size, text, text_len, '\\n');\n\n\tif (!dev_info)\n\t\tgoto out;\n\n\tlen += msg_add_dict_text(buf + len, size - len, \"SUBSYSTEM\",\n\t\t\t\t dev_info->subsystem);\n\tlen += msg_add_dict_text(buf + len, size - len, \"DEVICE\",\n\t\t\t\t dev_info->device);\nout:\n\treturn len;\n}\n\nstatic bool printk_get_next_message(struct printk_message *pmsg, u64 seq,\n\t\t\t\t    bool is_extended, bool may_supress);\n\n \nstruct devkmsg_user {\n\tatomic64_t seq;\n\tstruct ratelimit_state rs;\n\tstruct mutex lock;\n\tstruct printk_buffers pbufs;\n};\n\nstatic __printf(3, 4) __cold\nint devkmsg_emit(int facility, int level, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, NULL, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}\n\nstatic ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tchar *buf, *line;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t \n\tstruct file *file = iocb->ki_filp;\n\tstruct devkmsg_user *user = file->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret = len;\n\n\tif (len > PRINTKRB_RECORD_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (devkmsg_log & DEVKMSG_LOG_MASK_OFF)\n\t\treturn len;\n\n\t \n\tif (!(devkmsg_log & DEVKMSG_LOG_MASK_ON)) {\n\t\tif (!___ratelimit(&user->rs, current->comm))\n\t\t\treturn ret;\n\t}\n\n\tbuf = kmalloc(len+1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[len] = '\\0';\n\tif (!copy_from_iter_full(buf, len, from)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = NULL;\n\t\tunsigned int u;\n\n\t\tu = simple_strtoul(line + 1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = LOG_LEVEL(u);\n\t\t\tif (LOG_FACILITY(u) != 0)\n\t\t\t\tfacility = LOG_FACILITY(u);\n\t\t\tendp++;\n\t\t\tline = endp;\n\t\t}\n\t}\n\n\tdevkmsg_emit(facility, level, \"%s\", line);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t devkmsg_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tchar *outbuf = &user->pbufs.outbuf[0];\n\tstruct printk_message pmsg = {\n\t\t.pbufs = &user->pbufs,\n\t};\n\tssize_t ret;\n\n\tret = mutex_lock_interruptible(&user->lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!printk_get_next_message(&pmsg, atomic64_read(&user->seq), true, false)) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = wait_event_interruptible(log_wait,\n\t\t\t\tprintk_get_next_message(&pmsg, atomic64_read(&user->seq), true,\n\t\t\t\t\t\t\tfalse));  \n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (pmsg.dropped) {\n\t\t \n\t\tatomic64_set(&user->seq, pmsg.seq);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tatomic64_set(&user->seq, pmsg.seq + 1);\n\n\tif (pmsg.outbuf_len > count) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(buf, outbuf, pmsg.outbuf_len)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tret = pmsg.outbuf_len;\nout:\n\tmutex_unlock(&user->lock);\n\treturn ret;\n}\n\n \nstatic loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tloff_t ret = 0;\n\n\tif (offset)\n\t\treturn -ESPIPE;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\t \n\t\tatomic64_set(&user->seq, prb_first_valid_seq(prb));\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\t \n\t\tatomic64_set(&user->seq, latched_seq_read_nolock(&clear_seq));\n\t\tbreak;\n\tcase SEEK_END:\n\t\t \n\t\tatomic64_set(&user->seq, prb_next_seq(prb));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic __poll_t devkmsg_poll(struct file *file, poll_table *wait)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tstruct printk_info info;\n\t__poll_t ret = 0;\n\n\tpoll_wait(file, &log_wait, wait);\n\n\tif (prb_read_valid_info(prb, atomic64_read(&user->seq), &info, NULL)) {\n\t\t \n\t\tif (info.seq != atomic64_read(&user->seq))\n\t\t\tret = EPOLLIN|EPOLLRDNORM|EPOLLERR|EPOLLPRI;\n\t\telse\n\t\t\tret = EPOLLIN|EPOLLRDNORM;\n\t}\n\n\treturn ret;\n}\n\nstatic int devkmsg_open(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user;\n\tint err;\n\n\tif (devkmsg_log & DEVKMSG_LOG_MASK_OFF)\n\t\treturn -EPERM;\n\n\t \n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY) {\n\t\terr = check_syslog_permissions(SYSLOG_ACTION_READ_ALL,\n\t\t\t\t\t       SYSLOG_FROM_READER);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tuser = kvmalloc(sizeof(struct devkmsg_user), GFP_KERNEL);\n\tif (!user)\n\t\treturn -ENOMEM;\n\n\tratelimit_default_init(&user->rs);\n\tratelimit_set_flags(&user->rs, RATELIMIT_MSG_ON_RELEASE);\n\n\tmutex_init(&user->lock);\n\n\tatomic64_set(&user->seq, prb_first_valid_seq(prb));\n\n\tfile->private_data = user;\n\treturn 0;\n}\n\nstatic int devkmsg_release(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\n\tratelimit_state_exit(&user->rs);\n\n\tmutex_destroy(&user->lock);\n\tkvfree(user);\n\treturn 0;\n}\n\nconst struct file_operations kmsg_fops = {\n\t.open = devkmsg_open,\n\t.read = devkmsg_read,\n\t.write_iter = devkmsg_write,\n\t.llseek = devkmsg_llseek,\n\t.poll = devkmsg_poll,\n\t.release = devkmsg_release,\n};\n\n#ifdef CONFIG_CRASH_CORE\n \nvoid log_buf_vmcoreinfo_setup(void)\n{\n\tstruct dev_printk_info *dev_info = NULL;\n\n\tVMCOREINFO_SYMBOL(prb);\n\tVMCOREINFO_SYMBOL(printk_rb_static);\n\tVMCOREINFO_SYMBOL(clear_seq);\n\n\t \n\n\tVMCOREINFO_STRUCT_SIZE(printk_ringbuffer);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, desc_ring);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, text_data_ring);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, fail);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_desc_ring);\n\tVMCOREINFO_OFFSET(prb_desc_ring, count_bits);\n\tVMCOREINFO_OFFSET(prb_desc_ring, descs);\n\tVMCOREINFO_OFFSET(prb_desc_ring, infos);\n\tVMCOREINFO_OFFSET(prb_desc_ring, head_id);\n\tVMCOREINFO_OFFSET(prb_desc_ring, tail_id);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_desc);\n\tVMCOREINFO_OFFSET(prb_desc, state_var);\n\tVMCOREINFO_OFFSET(prb_desc, text_blk_lpos);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_data_blk_lpos);\n\tVMCOREINFO_OFFSET(prb_data_blk_lpos, begin);\n\tVMCOREINFO_OFFSET(prb_data_blk_lpos, next);\n\n\tVMCOREINFO_STRUCT_SIZE(printk_info);\n\tVMCOREINFO_OFFSET(printk_info, seq);\n\tVMCOREINFO_OFFSET(printk_info, ts_nsec);\n\tVMCOREINFO_OFFSET(printk_info, text_len);\n\tVMCOREINFO_OFFSET(printk_info, caller_id);\n\tVMCOREINFO_OFFSET(printk_info, dev_info);\n\n\tVMCOREINFO_STRUCT_SIZE(dev_printk_info);\n\tVMCOREINFO_OFFSET(dev_printk_info, subsystem);\n\tVMCOREINFO_LENGTH(printk_info_subsystem, sizeof(dev_info->subsystem));\n\tVMCOREINFO_OFFSET(dev_printk_info, device);\n\tVMCOREINFO_LENGTH(printk_info_device, sizeof(dev_info->device));\n\n\tVMCOREINFO_STRUCT_SIZE(prb_data_ring);\n\tVMCOREINFO_OFFSET(prb_data_ring, size_bits);\n\tVMCOREINFO_OFFSET(prb_data_ring, data);\n\tVMCOREINFO_OFFSET(prb_data_ring, head_lpos);\n\tVMCOREINFO_OFFSET(prb_data_ring, tail_lpos);\n\n\tVMCOREINFO_SIZE(atomic_long_t);\n\tVMCOREINFO_TYPE_OFFSET(atomic_long_t, counter);\n\n\tVMCOREINFO_STRUCT_SIZE(latched_seq);\n\tVMCOREINFO_OFFSET(latched_seq, val);\n}\n#endif\n\n \nstatic unsigned long __initdata new_log_buf_len;\n\n \nstatic void __init log_buf_len_update(u64 size)\n{\n\tif (size > (u64)LOG_BUF_LEN_MAX) {\n\t\tsize = (u64)LOG_BUF_LEN_MAX;\n\t\tpr_err(\"log_buf over 2G is not supported.\\n\");\n\t}\n\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = (unsigned long)size;\n}\n\n \nstatic int __init log_buf_len_setup(char *str)\n{\n\tu64 size;\n\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tsize = memparse(str, &str);\n\n\tlog_buf_len_update(size);\n\n\treturn 0;\n}\nearly_param(\"log_buf_len\", log_buf_len_setup);\n\n#ifdef CONFIG_SMP\n#define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)\n\nstatic void __init log_buf_add_cpu(void)\n{\n\tunsigned int cpu_extra;\n\n\t \n\tif (num_possible_cpus() == 1)\n\t\treturn;\n\n\tcpu_extra = (num_possible_cpus() - 1) * __LOG_CPU_MAX_BUF_LEN;\n\n\t \n\tif (cpu_extra <= __LOG_BUF_LEN / 2)\n\t\treturn;\n\n\tpr_info(\"log_buf_len individual max cpu contribution: %d bytes\\n\",\n\t\t__LOG_CPU_MAX_BUF_LEN);\n\tpr_info(\"log_buf_len total cpu_extra contributions: %d bytes\\n\",\n\t\tcpu_extra);\n\tpr_info(\"log_buf_len min size: %d bytes\\n\", __LOG_BUF_LEN);\n\n\tlog_buf_len_update(cpu_extra + __LOG_BUF_LEN);\n}\n#else  \nstatic inline void log_buf_add_cpu(void) {}\n#endif  \n\nstatic void __init set_percpu_data_ready(void)\n{\n\t__printk_percpu_data_ready = true;\n}\n\nstatic unsigned int __init add_to_rb(struct printk_ringbuffer *rb,\n\t\t\t\t     struct printk_record *r)\n{\n\tstruct prb_reserved_entry e;\n\tstruct printk_record dest_r;\n\n\tprb_rec_init_wr(&dest_r, r->info->text_len);\n\n\tif (!prb_reserve(&e, rb, &dest_r))\n\t\treturn 0;\n\n\tmemcpy(&dest_r.text_buf[0], &r->text_buf[0], r->info->text_len);\n\tdest_r.info->text_len = r->info->text_len;\n\tdest_r.info->facility = r->info->facility;\n\tdest_r.info->level = r->info->level;\n\tdest_r.info->flags = r->info->flags;\n\tdest_r.info->ts_nsec = r->info->ts_nsec;\n\tdest_r.info->caller_id = r->info->caller_id;\n\tmemcpy(&dest_r.info->dev_info, &r->info->dev_info, sizeof(dest_r.info->dev_info));\n\n\tprb_final_commit(&e);\n\n\treturn prb_record_text_space(&e);\n}\n\nstatic char setup_text_buf[PRINTKRB_RECORD_MAX] __initdata;\n\nvoid __init setup_log_buf(int early)\n{\n\tstruct printk_info *new_infos;\n\tunsigned int new_descs_count;\n\tstruct prb_desc *new_descs;\n\tstruct printk_info info;\n\tstruct printk_record r;\n\tunsigned int text_size;\n\tsize_t new_descs_size;\n\tsize_t new_infos_size;\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tunsigned int free;\n\tu64 seq;\n\n\t \n\tif (!early)\n\t\tset_percpu_data_ready();\n\n\tif (log_buf != __log_buf)\n\t\treturn;\n\n\tif (!early && !new_log_buf_len)\n\t\tlog_buf_add_cpu();\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tnew_descs_count = new_log_buf_len >> PRB_AVGBITS;\n\tif (new_descs_count == 0) {\n\t\tpr_err(\"new_log_buf_len: %lu too small\\n\", new_log_buf_len);\n\t\treturn;\n\t}\n\n\tnew_log_buf = memblock_alloc(new_log_buf_len, LOG_ALIGN);\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %lu text bytes not available\\n\",\n\t\t       new_log_buf_len);\n\t\treturn;\n\t}\n\n\tnew_descs_size = new_descs_count * sizeof(struct prb_desc);\n\tnew_descs = memblock_alloc(new_descs_size, LOG_ALIGN);\n\tif (unlikely(!new_descs)) {\n\t\tpr_err(\"log_buf_len: %zu desc bytes not available\\n\",\n\t\t       new_descs_size);\n\t\tgoto err_free_log_buf;\n\t}\n\n\tnew_infos_size = new_descs_count * sizeof(struct printk_info);\n\tnew_infos = memblock_alloc(new_infos_size, LOG_ALIGN);\n\tif (unlikely(!new_infos)) {\n\t\tpr_err(\"log_buf_len: %zu info bytes not available\\n\",\n\t\t       new_infos_size);\n\t\tgoto err_free_descs;\n\t}\n\n\tprb_rec_init_rd(&r, &info, &setup_text_buf[0], sizeof(setup_text_buf));\n\n\tprb_init(&printk_rb_dynamic,\n\t\t new_log_buf, ilog2(new_log_buf_len),\n\t\t new_descs, ilog2(new_descs_count),\n\t\t new_infos);\n\n\tlocal_irq_save(flags);\n\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\n\tfree = __LOG_BUF_LEN;\n\tprb_for_each_record(0, &printk_rb_static, seq, &r) {\n\t\ttext_size = add_to_rb(&printk_rb_dynamic, &r);\n\t\tif (text_size > free)\n\t\t\tfree = 0;\n\t\telse\n\t\t\tfree -= text_size;\n\t}\n\n\tprb = &printk_rb_dynamic;\n\n\tlocal_irq_restore(flags);\n\n\t \n\tprb_for_each_record(seq, &printk_rb_static, seq, &r) {\n\t\ttext_size = add_to_rb(&printk_rb_dynamic, &r);\n\t\tif (text_size > free)\n\t\t\tfree = 0;\n\t\telse\n\t\t\tfree -= text_size;\n\t}\n\n\tif (seq != prb_next_seq(&printk_rb_static)) {\n\t\tpr_err(\"dropped %llu messages\\n\",\n\t\t       prb_next_seq(&printk_rb_static) - seq);\n\t}\n\n\tpr_info(\"log_buf_len: %u bytes\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %u(%u%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n\treturn;\n\nerr_free_descs:\n\tmemblock_free(new_descs, new_descs_size);\nerr_free_log_buf:\n\tmemblock_free(new_log_buf, new_log_buf_len);\n}\n\nstatic bool __read_mostly ignore_loglevel;\n\nstatic int __init ignore_loglevel_setup(char *str)\n{\n\tignore_loglevel = true;\n\tpr_info(\"debug: ignoring loglevel setting.\\n\");\n\n\treturn 0;\n}\n\nearly_param(\"ignore_loglevel\", ignore_loglevel_setup);\nmodule_param(ignore_loglevel, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ignore_loglevel,\n\t\t \"ignore loglevel setting (prints all kernel messages to the console)\");\n\nstatic bool suppress_message_printing(int level)\n{\n\treturn (level >= console_loglevel && !ignore_loglevel);\n}\n\n#ifdef CONFIG_BOOT_PRINTK_DELAY\n\nstatic int boot_delay;  \nstatic unsigned long long loops_per_msec;\t \n\nstatic int __init boot_delay_setup(char *str)\n{\n\tunsigned long lpj;\n\n\tlpj = preset_lpj ? preset_lpj : 1000000;\t \n\tloops_per_msec = (unsigned long long)lpj / 1000 * HZ;\n\n\tget_option(&str, &boot_delay);\n\tif (boot_delay > 10 * 1000)\n\t\tboot_delay = 0;\n\n\tpr_debug(\"boot_delay: %u, preset_lpj: %ld, lpj: %lu, \"\n\t\t\"HZ: %d, loops_per_msec: %llu\\n\",\n\t\tboot_delay, preset_lpj, lpj, HZ, loops_per_msec);\n\treturn 0;\n}\nearly_param(\"boot_delay\", boot_delay_setup);\n\nstatic void boot_delay_msec(int level)\n{\n\tunsigned long long k;\n\tunsigned long timeout;\n\n\tif ((boot_delay == 0 || system_state >= SYSTEM_RUNNING)\n\t\t|| suppress_message_printing(level)) {\n\t\treturn;\n\t}\n\n\tk = (unsigned long long)loops_per_msec * boot_delay;\n\n\ttimeout = jiffies + msecs_to_jiffies(boot_delay);\n\twhile (k) {\n\t\tk--;\n\t\tcpu_relax();\n\t\t \n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\ttouch_nmi_watchdog();\n\t}\n}\n#else\nstatic inline void boot_delay_msec(int level)\n{\n}\n#endif\n\nstatic bool printk_time = IS_ENABLED(CONFIG_PRINTK_TIME);\nmodule_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);\n\nstatic size_t print_syslog(unsigned int level, char *buf)\n{\n\treturn sprintf(buf, \"<%u>\", level);\n}\n\nstatic size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec = do_div(ts, 1000000000);\n\n\treturn sprintf(buf, \"[%5lu.%06lu]\",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}\n\n#ifdef CONFIG_PRINTK_CALLER\nstatic size_t print_caller(u32 id, char *buf)\n{\n\tchar caller[12];\n\n\tsnprintf(caller, sizeof(caller), \"%c%u\",\n\t\t id & 0x80000000 ? 'C' : 'T', id & ~0x80000000);\n\treturn sprintf(buf, \"[%6s]\", caller);\n}\n#else\n#define print_caller(id, buf) 0\n#endif\n\nstatic size_t info_print_prefix(const struct printk_info  *info, bool syslog,\n\t\t\t\tbool time, char *buf)\n{\n\tsize_t len = 0;\n\n\tif (syslog)\n\t\tlen = print_syslog((info->facility << 3) | info->level, buf);\n\n\tif (time)\n\t\tlen += print_time(info->ts_nsec, buf + len);\n\n\tlen += print_caller(info->caller_id, buf + len);\n\n\tif (IS_ENABLED(CONFIG_PRINTK_CALLER) || time) {\n\t\tbuf[len++] = ' ';\n\t\tbuf[len] = '\\0';\n\t}\n\n\treturn len;\n}\n\n \nstatic size_t record_print_text(struct printk_record *r, bool syslog,\n\t\t\t\tbool time)\n{\n\tsize_t text_len = r->info->text_len;\n\tsize_t buf_size = r->text_buf_size;\n\tchar *text = r->text_buf;\n\tchar prefix[PRINTK_PREFIX_MAX];\n\tbool truncated = false;\n\tsize_t prefix_len;\n\tsize_t line_len;\n\tsize_t len = 0;\n\tchar *next;\n\n\t \n\tif (text_len > buf_size)\n\t\ttext_len = buf_size;\n\n\tprefix_len = info_print_prefix(r->info, syslog, time, prefix);\n\n\t \n\tfor (;;) {\n\t\tnext = memchr(text, '\\n', text_len);\n\t\tif (next) {\n\t\t\tline_len = next - text;\n\t\t} else {\n\t\t\t \n\t\t\tif (truncated)\n\t\t\t\tbreak;\n\t\t\tline_len = text_len;\n\t\t}\n\n\t\t \n\t\tif (len + prefix_len + text_len + 1 + 1 > buf_size) {\n\t\t\t \n\t\t\tif (len + prefix_len + line_len + 1 + 1 > buf_size)\n\t\t\t\tbreak;\n\n\t\t\ttext_len = buf_size - len - prefix_len - 1 - 1;\n\t\t\ttruncated = true;\n\t\t}\n\n\t\tmemmove(text + prefix_len, text, text_len);\n\t\tmemcpy(text, prefix, prefix_len);\n\n\t\t \n\t\tlen += prefix_len + line_len + 1;\n\t\tif (text_len == line_len) {\n\t\t\t \n\t\t\ttext[prefix_len + line_len] = '\\n';\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttext += prefix_len + line_len + 1;\n\n\t\t \n\t\ttext_len -= line_len + 1;\n\t}\n\n\t \n\tif (buf_size > 0)\n\t\tr->text_buf[len] = 0;\n\n\treturn len;\n}\n\nstatic size_t get_record_print_text_size(struct printk_info *info,\n\t\t\t\t\t unsigned int line_count,\n\t\t\t\t\t bool syslog, bool time)\n{\n\tchar prefix[PRINTK_PREFIX_MAX];\n\tsize_t prefix_len;\n\n\tprefix_len = info_print_prefix(info, syslog, time, prefix);\n\n\t \n\treturn ((prefix_len * line_count) + info->text_len + 1);\n}\n\n \nstatic u64 find_first_fitting_seq(u64 start_seq, u64 max_seq, size_t size,\n\t\t\t\t  bool syslog, bool time)\n{\n\tstruct printk_info info;\n\tunsigned int line_count;\n\tsize_t len = 0;\n\tu64 seq;\n\n\t \n\tprb_for_each_info(start_seq, prb, seq, &info, &line_count) {\n\t\tif (info.seq >= max_seq)\n\t\t\tbreak;\n\t\tlen += get_record_print_text_size(&info, line_count, syslog, time);\n\t}\n\n\t \n\tif (seq < max_seq)\n\t\tmax_seq = seq;\n\n\t \n\tprb_for_each_info(start_seq, prb, seq, &info, &line_count) {\n\t\tif (len <= size || info.seq >= max_seq)\n\t\t\tbreak;\n\t\tlen -= get_record_print_text_size(&info, line_count, syslog, time);\n\t}\n\n\treturn seq;\n}\n\n \nstatic int syslog_print(char __user *buf, int size)\n{\n\tstruct printk_info info;\n\tstruct printk_record r;\n\tchar *text;\n\tint len = 0;\n\tu64 seq;\n\n\ttext = kmalloc(PRINTK_MESSAGE_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\tprb_rec_init_rd(&r, &info, text, PRINTK_MESSAGE_MAX);\n\n\tmutex_lock(&syslog_lock);\n\n\t \n\tdo {\n\t\tseq = syslog_seq;\n\n\t\tmutex_unlock(&syslog_lock);\n\t\t \n\t\tlen = wait_event_interruptible(log_wait,\n\t\t\t\tprb_read_valid(prb, seq, NULL));  \n\t\tmutex_lock(&syslog_lock);\n\n\t\tif (len)\n\t\t\tgoto out;\n\t} while (syslog_seq != seq);\n\n\t \n\tdo {\n\t\tsize_t n;\n\t\tsize_t skip;\n\t\tint err;\n\n\t\tif (!prb_read_valid(prb, syslog_seq, &r))\n\t\t\tbreak;\n\n\t\tif (r.info->seq != syslog_seq) {\n\t\t\t \n\t\t\tsyslog_seq = r.info->seq;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\n\t\t \n\t\tif (!syslog_partial)\n\t\t\tsyslog_time = printk_time;\n\n\t\tskip = syslog_partial;\n\t\tn = record_print_text(&r, true, syslog_time);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t \n\t\t\tsyslog_seq = r.info->seq + 1;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t \n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tmutex_unlock(&syslog_lock);\n\t\terr = copy_to_user(buf, text + skip, n);\n\t\tmutex_lock(&syslog_lock);\n\n\t\tif (err) {\n\t\t\tif (!len)\n\t\t\t\tlen = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t} while (size);\nout:\n\tmutex_unlock(&syslog_lock);\n\tkfree(text);\n\treturn len;\n}\n\nstatic int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tstruct printk_info info;\n\tstruct printk_record r;\n\tchar *text;\n\tint len = 0;\n\tu64 seq;\n\tbool time;\n\n\ttext = kmalloc(PRINTK_MESSAGE_MAX, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\ttime = printk_time;\n\t \n\tseq = find_first_fitting_seq(latched_seq_read_nolock(&clear_seq), -1,\n\t\t\t\t     size, true, time);\n\n\tprb_rec_init_rd(&r, &info, text, PRINTK_MESSAGE_MAX);\n\n\tlen = 0;\n\tprb_for_each_record(seq, prb, seq, &r) {\n\t\tint textlen;\n\n\t\ttextlen = record_print_text(&r, true, time);\n\n\t\tif (len + textlen > size) {\n\t\t\tseq--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\tlen = -EFAULT;\n\t\telse\n\t\t\tlen += textlen;\n\n\t\tif (len < 0)\n\t\t\tbreak;\n\t}\n\n\tif (clear) {\n\t\tmutex_lock(&syslog_lock);\n\t\tlatched_seq_write(&clear_seq, seq);\n\t\tmutex_unlock(&syslog_lock);\n\t}\n\n\tkfree(text);\n\treturn len;\n}\n\nstatic void syslog_clear(void)\n{\n\tmutex_lock(&syslog_lock);\n\tlatched_seq_write(&clear_seq, prb_next_seq(prb));\n\tmutex_unlock(&syslog_lock);\n}\n\nint do_syslog(int type, char __user *buf, int len, int source)\n{\n\tstruct printk_info info;\n\tbool clear = false;\n\tstatic int saved_console_loglevel = LOGLEVEL_DEFAULT;\n\tint error;\n\n\terror = check_syslog_permissions(type, source);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase SYSLOG_ACTION_CLOSE:\t \n\t\tbreak;\n\tcase SYSLOG_ACTION_OPEN:\t \n\t\tbreak;\n\tcase SYSLOG_ACTION_READ:\t \n\t\tif (!buf || len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (!len)\n\t\t\treturn 0;\n\t\tif (!access_ok(buf, len))\n\t\t\treturn -EFAULT;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_READ_CLEAR:\n\t\tclear = true;\n\t\tfallthrough;\n\t \n\tcase SYSLOG_ACTION_READ_ALL:\n\t\tif (!buf || len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (!len)\n\t\t\treturn 0;\n\t\tif (!access_ok(buf, len))\n\t\t\treturn -EFAULT;\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_CLEAR:\n\t\tsyslog_clear();\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_CONSOLE_OFF:\n\t\tif (saved_console_loglevel == LOGLEVEL_DEFAULT)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_CONSOLE_ON:\n\t\tif (saved_console_loglevel != LOGLEVEL_DEFAULT) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = LOGLEVEL_DEFAULT;\n\t\t}\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\tif (len < 1 || len > 8)\n\t\t\treturn -EINVAL;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t \n\t\tsaved_console_loglevel = LOGLEVEL_DEFAULT;\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_SIZE_UNREAD:\n\t\tmutex_lock(&syslog_lock);\n\t\tif (!prb_read_valid_info(prb, syslog_seq, &info, NULL)) {\n\t\t\t \n\t\t\tmutex_unlock(&syslog_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (info.seq != syslog_seq) {\n\t\t\t \n\t\t\tsyslog_seq = info.seq;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (source == SYSLOG_FROM_PROC) {\n\t\t\t \n\t\t\terror = prb_next_seq(prb) - syslog_seq;\n\t\t} else {\n\t\t\tbool time = syslog_partial ? syslog_time : printk_time;\n\t\t\tunsigned int line_count;\n\t\t\tu64 seq;\n\n\t\t\tprb_for_each_info(syslog_seq, prb, seq, &info,\n\t\t\t\t\t  &line_count) {\n\t\t\t\terror += get_record_print_text_size(&info, line_count,\n\t\t\t\t\t\t\t\t    true, time);\n\t\t\t\ttime = printk_time;\n\t\t\t}\n\t\t\terror -= syslog_partial;\n\t\t}\n\t\tmutex_unlock(&syslog_lock);\n\t\tbreak;\n\t \n\tcase SYSLOG_ACTION_SIZE_BUFFER:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn error;\n}\n\nSYSCALL_DEFINE3(syslog, int, type, char __user *, buf, int, len)\n{\n\treturn do_syslog(type, buf, len, SYSLOG_FROM_READER);\n}\n\n \n\n#ifdef CONFIG_LOCKDEP\nstatic struct lockdep_map console_owner_dep_map = {\n\t.name = \"console_owner\"\n};\n#endif\n\nstatic DEFINE_RAW_SPINLOCK(console_owner_lock);\nstatic struct task_struct *console_owner;\nstatic bool console_waiter;\n\n \nstatic void console_lock_spinning_enable(void)\n{\n\traw_spin_lock(&console_owner_lock);\n\tconsole_owner = current;\n\traw_spin_unlock(&console_owner_lock);\n\n\t \n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n}\n\n \nstatic int console_lock_spinning_disable_and_check(int cookie)\n{\n\tint waiter;\n\n\traw_spin_lock(&console_owner_lock);\n\twaiter = READ_ONCE(console_waiter);\n\tconsole_owner = NULL;\n\traw_spin_unlock(&console_owner_lock);\n\n\tif (!waiter) {\n\t\tspin_release(&console_owner_dep_map, _THIS_IP_);\n\t\treturn 0;\n\t}\n\n\t \n\tWRITE_ONCE(console_waiter, false);\n\n\tspin_release(&console_owner_dep_map, _THIS_IP_);\n\n\t \n\tconsole_srcu_read_unlock(cookie);\n\n\t \n\tmutex_release(&console_lock_dep_map, _THIS_IP_);\n\treturn 1;\n}\n\n \nstatic int console_trylock_spinning(void)\n{\n\tstruct task_struct *owner = NULL;\n\tbool waiter;\n\tbool spin = false;\n\tunsigned long flags;\n\n\tif (console_trylock())\n\t\treturn 1;\n\n\t \n\tif (panic_in_progress())\n\t\treturn 0;\n\n\tprintk_safe_enter_irqsave(flags);\n\n\traw_spin_lock(&console_owner_lock);\n\towner = READ_ONCE(console_owner);\n\twaiter = READ_ONCE(console_waiter);\n\tif (!waiter && owner && owner != current) {\n\t\tWRITE_ONCE(console_waiter, true);\n\t\tspin = true;\n\t}\n\traw_spin_unlock(&console_owner_lock);\n\n\t \n\tif (!spin) {\n\t\tprintk_safe_exit_irqrestore(flags);\n\t\treturn 0;\n\t}\n\n\t \n\tspin_acquire(&console_owner_dep_map, 0, 0, _THIS_IP_);\n\t \n\twhile (READ_ONCE(console_waiter))\n\t\tcpu_relax();\n\tspin_release(&console_owner_dep_map, _THIS_IP_);\n\n\tprintk_safe_exit_irqrestore(flags);\n\t \n\tmutex_acquire(&console_lock_dep_map, 0, 1, _THIS_IP_);\n\n\treturn 1;\n}\n\n \nstatic DEFINE_PER_CPU(u8, printk_count);\nstatic u8 printk_count_early;\n#ifdef CONFIG_HAVE_NMI\nstatic DEFINE_PER_CPU(u8, printk_count_nmi);\nstatic u8 printk_count_nmi_early;\n#endif\n\n \n#define PRINTK_MAX_RECURSION 3\n\n \nstatic u8 *__printk_recursion_counter(void)\n{\n#ifdef CONFIG_HAVE_NMI\n\tif (in_nmi()) {\n\t\tif (printk_percpu_data_ready())\n\t\t\treturn this_cpu_ptr(&printk_count_nmi);\n\t\treturn &printk_count_nmi_early;\n\t}\n#endif\n\tif (printk_percpu_data_ready())\n\t\treturn this_cpu_ptr(&printk_count);\n\treturn &printk_count_early;\n}\n\n \n#define printk_enter_irqsave(recursion_ptr, flags)\t\\\n({\t\t\t\t\t\t\t\\\n\tbool success = true;\t\t\t\t\\\n\t\t\t\t\t\t\t\\\n\ttypecheck(u8 *, recursion_ptr);\t\t\t\\\n\tlocal_irq_save(flags);\t\t\t\t\\\n\t(recursion_ptr) = __printk_recursion_counter();\t\\\n\tif (*(recursion_ptr) > PRINTK_MAX_RECURSION) {\t\\\n\t\tlocal_irq_restore(flags);\t\t\\\n\t\tsuccess = false;\t\t\t\\\n\t} else {\t\t\t\t\t\\\n\t\t(*(recursion_ptr))++;\t\t\t\\\n\t}\t\t\t\t\t\t\\\n\tsuccess;\t\t\t\t\t\\\n})\n\n \n#define printk_exit_irqrestore(recursion_ptr, flags)\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttypecheck(u8 *, recursion_ptr);\t\t\\\n\t\t(*(recursion_ptr))--;\t\t\t\\\n\t\tlocal_irq_restore(flags);\t\t\\\n\t} while (0)\n\nint printk_delay_msec __read_mostly;\n\nstatic inline void printk_delay(int level)\n{\n\tboot_delay_msec(level);\n\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}\n\nstatic inline u32 printk_caller_id(void)\n{\n\treturn in_task() ? task_pid_nr(current) :\n\t\t0x80000000 + smp_processor_id();\n}\n\n \nu16 printk_parse_prefix(const char *text, int *level,\n\t\t\tenum printk_info_flags *flags)\n{\n\tu16 prefix_len = 0;\n\tint kern_level;\n\n\twhile (*text) {\n\t\tkern_level = printk_get_level(text);\n\t\tif (!kern_level)\n\t\t\tbreak;\n\n\t\tswitch (kern_level) {\n\t\tcase '0' ... '7':\n\t\t\tif (level && *level == LOGLEVEL_DEFAULT)\n\t\t\t\t*level = kern_level - '0';\n\t\t\tbreak;\n\t\tcase 'c':\t \n\t\t\tif (flags)\n\t\t\t\t*flags |= LOG_CONT;\n\t\t}\n\n\t\tprefix_len += 2;\n\t\ttext += 2;\n\t}\n\n\treturn prefix_len;\n}\n\n__printf(5, 0)\nstatic u16 printk_sprint(char *text, u16 size, int facility,\n\t\t\t enum printk_info_flags *flags, const char *fmt,\n\t\t\t va_list args)\n{\n\tu16 text_len;\n\n\ttext_len = vscnprintf(text, size, fmt, args);\n\n\t \n\tif (text_len && text[text_len - 1] == '\\n') {\n\t\ttext_len--;\n\t\t*flags |= LOG_NEWLINE;\n\t}\n\n\t \n\tif (facility == 0) {\n\t\tu16 prefix_len;\n\n\t\tprefix_len = printk_parse_prefix(text, NULL, NULL);\n\t\tif (prefix_len) {\n\t\t\ttext_len -= prefix_len;\n\t\t\tmemmove(text, text + prefix_len, text_len);\n\t\t}\n\t}\n\n\ttrace_console(text, text_len);\n\n\treturn text_len;\n}\n\n__printf(4, 0)\nint vprintk_store(int facility, int level,\n\t\t  const struct dev_printk_info *dev_info,\n\t\t  const char *fmt, va_list args)\n{\n\tstruct prb_reserved_entry e;\n\tenum printk_info_flags flags = 0;\n\tstruct printk_record r;\n\tunsigned long irqflags;\n\tu16 trunc_msg_len = 0;\n\tchar prefix_buf[8];\n\tu8 *recursion_ptr;\n\tu16 reserve_size;\n\tva_list args2;\n\tu32 caller_id;\n\tu16 text_len;\n\tint ret = 0;\n\tu64 ts_nsec;\n\n\tif (!printk_enter_irqsave(recursion_ptr, irqflags))\n\t\treturn 0;\n\n\t \n\tts_nsec = local_clock();\n\n\tcaller_id = printk_caller_id();\n\n\t \n\tva_copy(args2, args);\n\treserve_size = vsnprintf(&prefix_buf[0], sizeof(prefix_buf), fmt, args2) + 1;\n\tva_end(args2);\n\n\tif (reserve_size > PRINTKRB_RECORD_MAX)\n\t\treserve_size = PRINTKRB_RECORD_MAX;\n\n\t \n\tif (facility == 0)\n\t\tprintk_parse_prefix(&prefix_buf[0], &level, &flags);\n\n\tif (level == LOGLEVEL_DEFAULT)\n\t\tlevel = default_message_loglevel;\n\n\tif (dev_info)\n\t\tflags |= LOG_NEWLINE;\n\n\tif (flags & LOG_CONT) {\n\t\tprb_rec_init_wr(&r, reserve_size);\n\t\tif (prb_reserve_in_last(&e, prb, &r, caller_id, PRINTKRB_RECORD_MAX)) {\n\t\t\ttext_len = printk_sprint(&r.text_buf[r.info->text_len], reserve_size,\n\t\t\t\t\t\t facility, &flags, fmt, args);\n\t\t\tr.info->text_len += text_len;\n\n\t\t\tif (flags & LOG_NEWLINE) {\n\t\t\t\tr.info->flags |= LOG_NEWLINE;\n\t\t\t\tprb_final_commit(&e);\n\t\t\t} else {\n\t\t\t\tprb_commit(&e);\n\t\t\t}\n\n\t\t\tret = text_len;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tprb_rec_init_wr(&r, reserve_size);\n\tif (!prb_reserve(&e, prb, &r)) {\n\t\t \n\t\ttruncate_msg(&reserve_size, &trunc_msg_len);\n\n\t\tprb_rec_init_wr(&r, reserve_size + trunc_msg_len);\n\t\tif (!prb_reserve(&e, prb, &r))\n\t\t\tgoto out;\n\t}\n\n\t \n\ttext_len = printk_sprint(&r.text_buf[0], reserve_size, facility, &flags, fmt, args);\n\tif (trunc_msg_len)\n\t\tmemcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);\n\tr.info->text_len = text_len + trunc_msg_len;\n\tr.info->facility = facility;\n\tr.info->level = level & 7;\n\tr.info->flags = flags & 0x1f;\n\tr.info->ts_nsec = ts_nsec;\n\tr.info->caller_id = caller_id;\n\tif (dev_info)\n\t\tmemcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));\n\n\t \n\tif (!(flags & LOG_NEWLINE))\n\t\tprb_commit(&e);\n\telse\n\t\tprb_final_commit(&e);\n\n\tret = text_len + trunc_msg_len;\nout:\n\tprintk_exit_irqrestore(recursion_ptr, irqflags);\n\treturn ret;\n}\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const struct dev_printk_info *dev_info,\n\t\t\t    const char *fmt, va_list args)\n{\n\tint printed_len;\n\tbool in_sched = false;\n\n\t \n\tif (unlikely(suppress_printk))\n\t\treturn 0;\n\n\tif (unlikely(suppress_panic_printk) &&\n\t    atomic_read(&panic_cpu) != raw_smp_processor_id())\n\t\treturn 0;\n\n\tif (level == LOGLEVEL_SCHED) {\n\t\tlevel = LOGLEVEL_DEFAULT;\n\t\tin_sched = true;\n\t}\n\n\tprintk_delay(level);\n\n\tprinted_len = vprintk_store(facility, level, dev_info, fmt, args);\n\n\t \n\tif (!in_sched) {\n\t\t \n\t\tpreempt_disable();\n\t\t \n\t\tif (console_trylock_spinning())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t}\n\n\tif (in_sched)\n\t\tdefer_console_output();\n\telse\n\t\twake_up_klogd();\n\n\treturn printed_len;\n}\nEXPORT_SYMBOL(vprintk_emit);\n\nint vprintk_default(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, fmt, args);\n}\nEXPORT_SYMBOL_GPL(vprintk_default);\n\nasmlinkage __visible int _printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}\nEXPORT_SYMBOL(_printk);\n\nstatic bool pr_flush(int timeout_ms, bool reset_on_progress);\nstatic bool __pr_flush(struct console *con, int timeout_ms, bool reset_on_progress);\n\n#else  \n\n#define printk_time\t\tfalse\n\n#define prb_read_valid(rb, seq, r)\tfalse\n#define prb_first_valid_seq(rb)\t\t0\n#define prb_next_seq(rb)\t\t0\n\nstatic u64 syslog_seq;\n\nstatic size_t record_print_text(const struct printk_record *r,\n\t\t\t\tbool syslog, bool time)\n{\n\treturn 0;\n}\nstatic ssize_t info_print_ext_header(char *buf, size_t size,\n\t\t\t\t     struct printk_info *info)\n{\n\treturn 0;\n}\nstatic ssize_t msg_print_ext_body(char *buf, size_t size,\n\t\t\t\t  char *text, size_t text_len,\n\t\t\t\t  struct dev_printk_info *dev_info) { return 0; }\nstatic void console_lock_spinning_enable(void) { }\nstatic int console_lock_spinning_disable_and_check(int cookie) { return 0; }\nstatic bool suppress_message_printing(int level) { return false; }\nstatic bool pr_flush(int timeout_ms, bool reset_on_progress) { return true; }\nstatic bool __pr_flush(struct console *con, int timeout_ms, bool reset_on_progress) { return true; }\n\n#endif  \n\n#ifdef CONFIG_EARLY_PRINTK\nstruct console *early_console;\n\nasmlinkage __visible void early_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tint n;\n\n\tif (!early_console)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tn = vscnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\n\tearly_console->write(early_console, buf, n);\n}\n#endif\n\nstatic void set_user_specified(struct console_cmdline *c, bool user_specified)\n{\n\tif (!user_specified)\n\t\treturn;\n\n\t \n\tc->user_specified = true;\n\t \n\tconsole_set_on_cmdline = 1;\n}\n\nstatic int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options, bool user_specified)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t \n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tpreferred_console = i;\n\t\t\tset_user_specified(c, user_specified);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == MAX_CMDLINECONSOLES)\n\t\treturn -E2BIG;\n\tif (!brl_options)\n\t\tpreferred_console = i;\n\tstrscpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tset_user_specified(c, user_specified);\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}\n\nstatic int __init console_msg_format_setup(char *str)\n{\n\tif (!strcmp(str, \"syslog\"))\n\t\tconsole_msg_format = MSG_FORMAT_SYSLOG;\n\tif (!strcmp(str, \"default\"))\n\t\tconsole_msg_format = MSG_FORMAT_DEFAULT;\n\treturn 1;\n}\n__setup(\"console_msg_format=\", console_msg_format_setup);\n\n \nstatic int __init console_setup(char *str)\n{\n\tchar buf[sizeof(console_cmdline[0].name) + 4];  \n\tchar *s, *options, *brl_options = NULL;\n\tint idx;\n\n\t \n\tif (str[0] == 0 || strcmp(str, \"null\") == 0) {\n\t\t__add_preferred_console(\"ttynull\", 0, NULL, NULL, true);\n\t\treturn 1;\n\t}\n\n\tif (_braille_console_setup(&str, &brl_options))\n\t\treturn 1;\n\n\t \n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tstrcpy(buf, \"ttyS\");\n\t\tstrncpy(buf + 4, str, sizeof(buf) - 5);\n\t} else {\n\t\tstrncpy(buf, str, sizeof(buf) - 1);\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\toptions = strchr(str, ',');\n\tif (options)\n\t\t*(options++) = 0;\n#ifdef __sparc__\n\tif (!strcmp(str, \"ttya\"))\n\t\tstrcpy(buf, \"ttyS0\");\n\tif (!strcmp(str, \"ttyb\"))\n\t\tstrcpy(buf, \"ttyS1\");\n#endif\n\tfor (s = buf; *s; s++)\n\t\tif (isdigit(*s) || *s == ',')\n\t\t\tbreak;\n\tidx = simple_strtoul(s, NULL, 10);\n\t*s = 0;\n\n\t__add_preferred_console(buf, idx, options, brl_options, true);\n\treturn 1;\n}\n__setup(\"console=\", console_setup);\n\n \nint add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, NULL, false);\n}\n\nbool console_suspend_enabled = true;\nEXPORT_SYMBOL(console_suspend_enabled);\n\nstatic int __init console_suspend_disable(char *str)\n{\n\tconsole_suspend_enabled = false;\n\treturn 1;\n}\n__setup(\"no_console_suspend\", console_suspend_disable);\nmodule_param_named(console_suspend, console_suspend_enabled,\n\t\tbool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(console_suspend, \"suspend console during suspend\"\n\t\" and hibernate operations\");\n\nstatic bool printk_console_no_auto_verbose;\n\nvoid console_verbose(void)\n{\n\tif (console_loglevel && !printk_console_no_auto_verbose)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}\nEXPORT_SYMBOL_GPL(console_verbose);\n\nmodule_param_named(console_no_auto_verbose, printk_console_no_auto_verbose, bool, 0644);\nMODULE_PARM_DESC(console_no_auto_verbose, \"Disable console loglevel raise to highest on oops/panic/etc\");\n\n \nvoid suspend_console(void)\n{\n\tstruct console *con;\n\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tpr_flush(1000, true);\n\n\tconsole_list_lock();\n\tfor_each_console(con)\n\t\tconsole_srcu_write_flags(con, con->flags | CON_SUSPENDED);\n\tconsole_list_unlock();\n\n\t \n\tsynchronize_srcu(&console_srcu);\n}\n\nvoid resume_console(void)\n{\n\tstruct console *con;\n\n\tif (!console_suspend_enabled)\n\t\treturn;\n\n\tconsole_list_lock();\n\tfor_each_console(con)\n\t\tconsole_srcu_write_flags(con, con->flags & ~CON_SUSPENDED);\n\tconsole_list_unlock();\n\n\t \n\tsynchronize_srcu(&console_srcu);\n\n\tpr_flush(1000, true);\n}\n\n \nstatic int console_cpu_notify(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\t \n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\treturn 0;\n}\n\n \nbool other_cpu_in_panic(void)\n{\n\tif (!panic_in_progress())\n\t\treturn false;\n\n\t \n\treturn atomic_read(&panic_cpu) != raw_smp_processor_id();\n}\n\n \nvoid console_lock(void)\n{\n\tmight_sleep();\n\n\t \n\twhile (other_cpu_in_panic())\n\t\tmsleep(1000);\n\n\tdown_console_sem();\n\tconsole_locked = 1;\n\tconsole_may_schedule = 1;\n}\nEXPORT_SYMBOL(console_lock);\n\n \nint console_trylock(void)\n{\n\t \n\tif (other_cpu_in_panic())\n\t\treturn 0;\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}\nEXPORT_SYMBOL(console_trylock);\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}\nEXPORT_SYMBOL(is_console_locked);\n\n \nstatic inline bool console_is_usable(struct console *con)\n{\n\tshort flags = console_srcu_read_flags(con);\n\n\tif (!(flags & CON_ENABLED))\n\t\treturn false;\n\n\tif ((flags & CON_SUSPENDED))\n\t\treturn false;\n\n\tif (!con->write)\n\t\treturn false;\n\n\t \n\tif (!cpu_online(raw_smp_processor_id()) && !(flags & CON_ANYTIME))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void __console_unlock(void)\n{\n\tconsole_locked = 0;\n\tup_console_sem();\n}\n\n \n#ifdef CONFIG_PRINTK\nstatic void console_prepend_dropped(struct printk_message *pmsg, unsigned long dropped)\n{\n\tstruct printk_buffers *pbufs = pmsg->pbufs;\n\tconst size_t scratchbuf_sz = sizeof(pbufs->scratchbuf);\n\tconst size_t outbuf_sz = sizeof(pbufs->outbuf);\n\tchar *scratchbuf = &pbufs->scratchbuf[0];\n\tchar *outbuf = &pbufs->outbuf[0];\n\tsize_t len;\n\n\tlen = scnprintf(scratchbuf, scratchbuf_sz,\n\t\t       \"** %lu printk messages dropped **\\n\", dropped);\n\n\t \n\tif (WARN_ON_ONCE(len + PRINTK_PREFIX_MAX >= outbuf_sz))\n\t\treturn;\n\n\tif (pmsg->outbuf_len + len >= outbuf_sz) {\n\t\t \n\t\tpmsg->outbuf_len = outbuf_sz - (len + 1);\n\t\toutbuf[pmsg->outbuf_len] = 0;\n\t}\n\n\tmemmove(outbuf + len, outbuf, pmsg->outbuf_len + 1);\n\tmemcpy(outbuf, scratchbuf, len);\n\tpmsg->outbuf_len += len;\n}\n#else\n#define console_prepend_dropped(pmsg, dropped)\n#endif  \n\n \nstatic bool printk_get_next_message(struct printk_message *pmsg, u64 seq,\n\t\t\t\t    bool is_extended, bool may_suppress)\n{\n\tstatic int panic_console_dropped;\n\n\tstruct printk_buffers *pbufs = pmsg->pbufs;\n\tconst size_t scratchbuf_sz = sizeof(pbufs->scratchbuf);\n\tconst size_t outbuf_sz = sizeof(pbufs->outbuf);\n\tchar *scratchbuf = &pbufs->scratchbuf[0];\n\tchar *outbuf = &pbufs->outbuf[0];\n\tstruct printk_info info;\n\tstruct printk_record r;\n\tsize_t len = 0;\n\n\t \n\tif (is_extended)\n\t\tprb_rec_init_rd(&r, &info, scratchbuf, scratchbuf_sz);\n\telse\n\t\tprb_rec_init_rd(&r, &info, outbuf, outbuf_sz);\n\n\tif (!prb_read_valid(prb, seq, &r))\n\t\treturn false;\n\n\tpmsg->seq = r.info->seq;\n\tpmsg->dropped = r.info->seq - seq;\n\n\t \n\tif (pmsg->dropped &&\n\t    panic_in_progress() &&\n\t    panic_console_dropped++ > 10) {\n\t\tsuppress_panic_printk = 1;\n\t\tpr_warn_once(\"Too many dropped messages. Suppress messages on non-panic CPUs to prevent livelock.\\n\");\n\t}\n\n\t \n\tif (may_suppress && suppress_message_printing(r.info->level))\n\t\tgoto out;\n\n\tif (is_extended) {\n\t\tlen = info_print_ext_header(outbuf, outbuf_sz, r.info);\n\t\tlen += msg_print_ext_body(outbuf + len, outbuf_sz - len,\n\t\t\t\t\t  &r.text_buf[0], r.info->text_len, &r.info->dev_info);\n\t} else {\n\t\tlen = record_print_text(&r, console_msg_format & MSG_FORMAT_SYSLOG, printk_time);\n\t}\nout:\n\tpmsg->outbuf_len = len;\n\treturn true;\n}\n\n \nstatic bool console_emit_next_record(struct console *con, bool *handover, int cookie)\n{\n\tstatic struct printk_buffers pbufs;\n\n\tbool is_extended = console_srcu_read_flags(con) & CON_EXTENDED;\n\tchar *outbuf = &pbufs.outbuf[0];\n\tstruct printk_message pmsg = {\n\t\t.pbufs = &pbufs,\n\t};\n\tunsigned long flags;\n\n\t*handover = false;\n\n\tif (!printk_get_next_message(&pmsg, con->seq, is_extended, true))\n\t\treturn false;\n\n\tcon->dropped += pmsg.dropped;\n\n\t \n\tif (pmsg.outbuf_len == 0) {\n\t\tcon->seq = pmsg.seq + 1;\n\t\tgoto skip;\n\t}\n\n\tif (con->dropped && !is_extended) {\n\t\tconsole_prepend_dropped(&pmsg, con->dropped);\n\t\tcon->dropped = 0;\n\t}\n\n\t \n\tprintk_safe_enter_irqsave(flags);\n\tconsole_lock_spinning_enable();\n\n\t \n\tstop_critical_timings();\n\n\t \n\tcon->write(con, outbuf, pmsg.outbuf_len);\n\n\tstart_critical_timings();\n\n\tcon->seq = pmsg.seq + 1;\n\n\t*handover = console_lock_spinning_disable_and_check(cookie);\n\tprintk_safe_exit_irqrestore(flags);\nskip:\n\treturn true;\n}\n\n \nstatic bool console_flush_all(bool do_cond_resched, u64 *next_seq, bool *handover)\n{\n\tbool any_usable = false;\n\tstruct console *con;\n\tbool any_progress;\n\tint cookie;\n\n\t*next_seq = 0;\n\t*handover = false;\n\n\tdo {\n\t\tany_progress = false;\n\n\t\tcookie = console_srcu_read_lock();\n\t\tfor_each_console_srcu(con) {\n\t\t\tbool progress;\n\n\t\t\tif (!console_is_usable(con))\n\t\t\t\tcontinue;\n\t\t\tany_usable = true;\n\n\t\t\tprogress = console_emit_next_record(con, handover, cookie);\n\n\t\t\t \n\t\t\tif (*handover)\n\t\t\t\treturn false;\n\n\t\t\t \n\t\t\tif (con->seq > *next_seq)\n\t\t\t\t*next_seq = con->seq;\n\n\t\t\tif (!progress)\n\t\t\t\tcontinue;\n\t\t\tany_progress = true;\n\n\t\t\t \n\t\t\tif (other_cpu_in_panic())\n\t\t\t\tgoto abandon;\n\n\t\t\tif (do_cond_resched)\n\t\t\t\tcond_resched();\n\t\t}\n\t\tconsole_srcu_read_unlock(cookie);\n\t} while (any_progress);\n\n\treturn any_usable;\n\nabandon:\n\tconsole_srcu_read_unlock(cookie);\n\treturn false;\n}\n\n \nvoid console_unlock(void)\n{\n\tbool do_cond_resched;\n\tbool handover;\n\tbool flushed;\n\tu64 next_seq;\n\n\t \n\tdo_cond_resched = console_may_schedule;\n\n\tdo {\n\t\tconsole_may_schedule = 0;\n\n\t\tflushed = console_flush_all(do_cond_resched, &next_seq, &handover);\n\t\tif (!handover)\n\t\t\t__console_unlock();\n\n\t\t \n\t\tif (!flushed)\n\t\t\tbreak;\n\n\t\t \n\t} while (prb_read_valid(prb, next_seq, NULL) && console_trylock());\n}\nEXPORT_SYMBOL(console_unlock);\n\n \nvoid __sched console_conditional_schedule(void)\n{\n\tif (console_may_schedule)\n\t\tcond_resched();\n}\nEXPORT_SYMBOL(console_conditional_schedule);\n\nvoid console_unblank(void)\n{\n\tbool found_unblank = false;\n\tstruct console *c;\n\tint cookie;\n\n\t \n\tcookie = console_srcu_read_lock();\n\tfor_each_console_srcu(c) {\n\t\tif ((console_srcu_read_flags(c) & CON_ENABLED) && c->unblank) {\n\t\t\tfound_unblank = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tconsole_srcu_read_unlock(cookie);\n\tif (!found_unblank)\n\t\treturn;\n\n\t \n\tif (oops_in_progress) {\n\t\t \n\t\tif (in_nmi())\n\t\t\treturn;\n\n\t\t \n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\n\tcookie = console_srcu_read_lock();\n\tfor_each_console_srcu(c) {\n\t\tif ((console_srcu_read_flags(c) & CON_ENABLED) && c->unblank)\n\t\t\tc->unblank();\n\t}\n\tconsole_srcu_read_unlock(cookie);\n\n\tconsole_unlock();\n\n\tif (!oops_in_progress)\n\t\tpr_flush(1000, true);\n}\n\n \nvoid console_flush_on_panic(enum con_flush_mode mode)\n{\n\tbool handover;\n\tu64 next_seq;\n\n\t \n\n\t \n\tconsole_may_schedule = 0;\n\n\tif (mode == CONSOLE_REPLAY_ALL) {\n\t\tstruct console *c;\n\t\tint cookie;\n\t\tu64 seq;\n\n\t\tseq = prb_first_valid_seq(prb);\n\n\t\tcookie = console_srcu_read_lock();\n\t\tfor_each_console_srcu(c) {\n\t\t\t \n\t\t\tc->seq = seq;\n\t\t}\n\t\tconsole_srcu_read_unlock(cookie);\n\t}\n\n\tconsole_flush_all(false, &next_seq, &handover);\n}\n\n \nstruct tty_driver *console_device(int *index)\n{\n\tstruct console *c;\n\tstruct tty_driver *driver = NULL;\n\tint cookie;\n\n\t \n\tconsole_lock();\n\n\tcookie = console_srcu_read_lock();\n\tfor_each_console_srcu(c) {\n\t\tif (!c->device)\n\t\t\tcontinue;\n\t\tdriver = c->device(c, index);\n\t\tif (driver)\n\t\t\tbreak;\n\t}\n\tconsole_srcu_read_unlock(cookie);\n\n\tconsole_unlock();\n\treturn driver;\n}\n\n \nvoid console_stop(struct console *console)\n{\n\t__pr_flush(console, 1000, true);\n\tconsole_list_lock();\n\tconsole_srcu_write_flags(console, console->flags & ~CON_ENABLED);\n\tconsole_list_unlock();\n\n\t \n\tsynchronize_srcu(&console_srcu);\n}\nEXPORT_SYMBOL(console_stop);\n\nvoid console_start(struct console *console)\n{\n\tconsole_list_lock();\n\tconsole_srcu_write_flags(console, console->flags | CON_ENABLED);\n\tconsole_list_unlock();\n\t__pr_flush(console, 1000, true);\n}\nEXPORT_SYMBOL(console_start);\n\nstatic int __read_mostly keep_bootcon;\n\nstatic int __init keep_bootcon_setup(char *str)\n{\n\tkeep_bootcon = 1;\n\tpr_info(\"debug: skip boot console de-registration.\\n\");\n\n\treturn 0;\n}\n\nearly_param(\"keep_bootcon\", keep_bootcon_setup);\n\n \nstatic int try_enable_preferred_console(struct console *newcon,\n\t\t\t\t\tbool user_specified)\n{\n\tstruct console_cmdline *c;\n\tint i, err;\n\n\tfor (i = 0, c = console_cmdline;\n\t     i < MAX_CMDLINECONSOLES && c->name[0];\n\t     i++, c++) {\n\t\tif (c->user_specified != user_specified)\n\t\t\tcontinue;\n\t\tif (!newcon->match ||\n\t\t    newcon->match(newcon, c->name, c->index, c->options) != 0) {\n\t\t\t \n\t\t\tBUILD_BUG_ON(sizeof(c->name) != sizeof(newcon->name));\n\t\t\tif (strcmp(c->name, newcon->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index >= 0 &&\n\t\t\t    newcon->index != c->index)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index < 0)\n\t\t\t\tnewcon->index = c->index;\n\n\t\t\tif (_braille_register_console(newcon, c))\n\t\t\t\treturn 0;\n\n\t\t\tif (newcon->setup &&\n\t\t\t    (err = newcon->setup(newcon, c->options)) != 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tnewcon->flags |= CON_ENABLED;\n\t\tif (i == preferred_console)\n\t\t\tnewcon->flags |= CON_CONSDEV;\n\t\treturn 0;\n\t}\n\n\t \n\tif (newcon->flags & CON_ENABLED && c->user_specified ==\tuser_specified)\n\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\n \nstatic void try_enable_default_console(struct console *newcon)\n{\n\tif (newcon->index < 0)\n\t\tnewcon->index = 0;\n\n\tif (newcon->setup && newcon->setup(newcon, NULL) != 0)\n\t\treturn;\n\n\tnewcon->flags |= CON_ENABLED;\n\n\tif (newcon->device)\n\t\tnewcon->flags |= CON_CONSDEV;\n}\n\n#define con_printk(lvl, con, fmt, ...)\t\t\t\\\n\tprintk(lvl pr_fmt(\"%sconsole [%s%d] \" fmt),\t\\\n\t       (con->flags & CON_BOOT) ? \"boot\" : \"\",\t\\\n\t       con->name, con->index, ##__VA_ARGS__)\n\nstatic void console_init_seq(struct console *newcon, bool bootcon_registered)\n{\n\tstruct console *con;\n\tbool handover;\n\n\tif (newcon->flags & (CON_PRINTBUFFER | CON_BOOT)) {\n\t\t \n\t\tmutex_lock(&syslog_lock);\n\t\tnewcon->seq = syslog_seq;\n\t\tmutex_unlock(&syslog_lock);\n\t} else {\n\t\t \n\t\tnewcon->seq = prb_next_seq(prb);\n\n\t\t \n\t\tif (bootcon_registered && !keep_bootcon) {\n\t\t\t \n\t\t\tconsole_lock();\n\n\t\t\t \n\t\t\tif (!console_flush_all(true, &newcon->seq, &handover)) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tif (handover)\n\t\t\t\t\tconsole_lock();\n\n\t\t\t\tnewcon->seq = prb_next_seq(prb);\n\t\t\t\tfor_each_console(con) {\n\t\t\t\t\tif ((con->flags & CON_BOOT) &&\n\t\t\t\t\t    (con->flags & CON_ENABLED) &&\n\t\t\t\t\t    con->seq < newcon->seq) {\n\t\t\t\t\t\tnewcon->seq = con->seq;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole_unlock();\n\t\t}\n\t}\n}\n\n#define console_first()\t\t\t\t\\\n\thlist_entry(console_list.first, struct console, node)\n\nstatic int unregister_console_locked(struct console *console);\n\n \nvoid register_console(struct console *newcon)\n{\n\tstruct console *con;\n\tbool bootcon_registered = false;\n\tbool realcon_registered = false;\n\tint err;\n\n\tconsole_list_lock();\n\n\tfor_each_console(con) {\n\t\tif (WARN(con == newcon, \"console '%s%d' already registered\\n\",\n\t\t\t\t\t con->name, con->index)) {\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (con->flags & CON_BOOT)\n\t\t\tbootcon_registered = true;\n\t\telse\n\t\t\trealcon_registered = true;\n\t}\n\n\t \n\tif ((newcon->flags & CON_BOOT) && realcon_registered) {\n\t\tpr_info(\"Too late to register bootconsole %s%d\\n\",\n\t\t\tnewcon->name, newcon->index);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (preferred_console < 0) {\n\t\tif (hlist_empty(&console_list) || !console_first()->device ||\n\t\t    console_first()->flags & CON_BOOT) {\n\t\t\ttry_enable_default_console(newcon);\n\t\t}\n\t}\n\n\t \n\terr = try_enable_preferred_console(newcon, true);\n\n\t \n\tif (err == -ENOENT)\n\t\terr = try_enable_preferred_console(newcon, false);\n\n\t \n\tif (err || newcon->flags & CON_BRL)\n\t\tgoto unlock;\n\n\t \n\tif (bootcon_registered &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV)) {\n\t\tnewcon->flags &= ~CON_PRINTBUFFER;\n\t}\n\n\tnewcon->dropped = 0;\n\tconsole_init_seq(newcon, bootcon_registered);\n\n\t \n\tif (hlist_empty(&console_list)) {\n\t\t \n\t\tnewcon->flags |= CON_CONSDEV;\n\t\thlist_add_head_rcu(&newcon->node, &console_list);\n\n\t} else if (newcon->flags & CON_CONSDEV) {\n\t\t \n\t\tconsole_srcu_write_flags(console_first(), console_first()->flags & ~CON_CONSDEV);\n\t\thlist_add_head_rcu(&newcon->node, &console_list);\n\n\t} else {\n\t\thlist_add_behind_rcu(&newcon->node, console_list.first);\n\t}\n\n\t \n\n\tconsole_sysfs_notify();\n\n\t \n\tcon_printk(KERN_INFO, newcon, \"enabled\\n\");\n\tif (bootcon_registered &&\n\t    ((newcon->flags & (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV) &&\n\t    !keep_bootcon) {\n\t\tstruct hlist_node *tmp;\n\n\t\thlist_for_each_entry_safe(con, tmp, &console_list, node) {\n\t\t\tif (con->flags & CON_BOOT)\n\t\t\t\tunregister_console_locked(con);\n\t\t}\n\t}\nunlock:\n\tconsole_list_unlock();\n}\nEXPORT_SYMBOL(register_console);\n\n \nstatic int unregister_console_locked(struct console *console)\n{\n\tint res;\n\n\tlockdep_assert_console_list_lock_held();\n\n\tcon_printk(KERN_INFO, console, \"disabled\\n\");\n\n\tres = _braille_unregister_console(console);\n\tif (res < 0)\n\t\treturn res;\n\tif (res > 0)\n\t\treturn 0;\n\n\t \n\tconsole_srcu_write_flags(console, console->flags & ~CON_ENABLED);\n\n\tif (!console_is_registered_locked(console))\n\t\treturn -ENODEV;\n\n\thlist_del_init_rcu(&console->node);\n\n\t \n\tif (!hlist_empty(&console_list) && console->flags & CON_CONSDEV)\n\t\tconsole_srcu_write_flags(console_first(), console_first()->flags | CON_CONSDEV);\n\n\t \n\tsynchronize_srcu(&console_srcu);\n\n\tconsole_sysfs_notify();\n\n\tif (console->exit)\n\t\tres = console->exit(console);\n\n\treturn res;\n}\n\nint unregister_console(struct console *console)\n{\n\tint res;\n\n\tconsole_list_lock();\n\tres = unregister_console_locked(console);\n\tconsole_list_unlock();\n\treturn res;\n}\nEXPORT_SYMBOL(unregister_console);\n\n \nvoid console_force_preferred_locked(struct console *con)\n{\n\tstruct console *cur_pref_con;\n\n\tif (!console_is_registered_locked(con))\n\t\treturn;\n\n\tcur_pref_con = console_first();\n\n\t \n\tif (cur_pref_con == con)\n\t\treturn;\n\n\t \n\thlist_del_rcu(&con->node);\n\n\t \n\tsynchronize_srcu(&console_srcu);\n\n\tcon->flags |= CON_CONSDEV;\n\tWARN_ON(!con->device);\n\n\t \n\tconsole_srcu_write_flags(cur_pref_con, cur_pref_con->flags & ~CON_CONSDEV);\n\thlist_add_head_rcu(&con->node, &console_list);\n}\nEXPORT_SYMBOL(console_force_preferred_locked);\n\n \nvoid __init console_init(void)\n{\n\tint ret;\n\tinitcall_t call;\n\tinitcall_entry_t *ce;\n\n\t \n\tn_tty_init();\n\n\t \n\tce = __con_initcall_start;\n\ttrace_initcall_level(\"console\");\n\twhile (ce < __con_initcall_end) {\n\t\tcall = initcall_from_entry(ce);\n\t\ttrace_initcall_start(call);\n\t\tret = call();\n\t\ttrace_initcall_finish(call, ret);\n\t\tce++;\n\t}\n}\n\n \nstatic int __init printk_late_init(void)\n{\n\tstruct hlist_node *tmp;\n\tstruct console *con;\n\tint ret;\n\n\tconsole_list_lock();\n\thlist_for_each_entry_safe(con, tmp, &console_list, node) {\n\t\tif (!(con->flags & CON_BOOT))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (init_section_intersects(con, sizeof(*con)) ||\n\t\t    init_section_contains(con->write, 0) ||\n\t\t    init_section_contains(con->read, 0) ||\n\t\t    init_section_contains(con->device, 0) ||\n\t\t    init_section_contains(con->unblank, 0) ||\n\t\t    init_section_contains(con->data, 0)) {\n\t\t\t \n\t\t\tpr_warn(\"bootconsole [%s%d] uses init memory and must be disabled even before the real one is ready\\n\",\n\t\t\t\tcon->name, con->index);\n\t\t\tunregister_console_locked(con);\n\t\t}\n\t}\n\tconsole_list_unlock();\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_PRINTK_DEAD, \"printk:dead\", NULL,\n\t\t\t\t\tconsole_cpu_notify);\n\tWARN_ON(ret < 0);\n\tret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, \"printk:online\",\n\t\t\t\t\tconsole_cpu_notify, NULL);\n\tWARN_ON(ret < 0);\n\tprintk_sysctl_init();\n\treturn 0;\n}\nlate_initcall(printk_late_init);\n\n#if defined CONFIG_PRINTK\n \nstatic bool __pr_flush(struct console *con, int timeout_ms, bool reset_on_progress)\n{\n\tint remaining = timeout_ms;\n\tstruct console *c;\n\tu64 last_diff = 0;\n\tu64 printk_seq;\n\tint cookie;\n\tu64 diff;\n\tu64 seq;\n\n\tmight_sleep();\n\n\tseq = prb_next_seq(prb);\n\n\t \n\tconsole_lock();\n\tconsole_unlock();\n\n\tfor (;;) {\n\t\tdiff = 0;\n\n\t\t \n\t\tconsole_lock();\n\n\t\tcookie = console_srcu_read_lock();\n\t\tfor_each_console_srcu(c) {\n\t\t\tif (con && con != c)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (!console_is_usable(c))\n\t\t\t\tcontinue;\n\t\t\tprintk_seq = c->seq;\n\t\t\tif (printk_seq < seq)\n\t\t\t\tdiff += seq - printk_seq;\n\t\t}\n\t\tconsole_srcu_read_unlock(cookie);\n\n\t\tif (diff != last_diff && reset_on_progress)\n\t\t\tremaining = timeout_ms;\n\n\t\tconsole_unlock();\n\n\t\t \n\t\tif (diff == 0 || remaining == 0)\n\t\t\tbreak;\n\n\t\tif (remaining < 0) {\n\t\t\t \n\t\t\tmsleep(100);\n\t\t} else if (remaining < 100) {\n\t\t\tmsleep(remaining);\n\t\t\tremaining = 0;\n\t\t} else {\n\t\t\tmsleep(100);\n\t\t\tremaining -= 100;\n\t\t}\n\n\t\tlast_diff = diff;\n\t}\n\n\treturn (diff == 0);\n}\n\n \nstatic bool pr_flush(int timeout_ms, bool reset_on_progress)\n{\n\treturn __pr_flush(NULL, timeout_ms, reset_on_progress);\n}\n\n \n#define PRINTK_PENDING_WAKEUP\t0x01\n#define PRINTK_PENDING_OUTPUT\t0x02\n\nstatic DEFINE_PER_CPU(int, printk_pending);\n\nstatic void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & PRINTK_PENDING_OUTPUT) {\n\t\t \n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & PRINTK_PENDING_WAKEUP)\n\t\twake_up_interruptible(&log_wait);\n}\n\nstatic DEFINE_PER_CPU(struct irq_work, wake_up_klogd_work) =\n\tIRQ_WORK_INIT_LAZY(wake_up_klogd_work_func);\n\nstatic void __wake_up_klogd(int val)\n{\n\tif (!printk_percpu_data_ready())\n\t\treturn;\n\n\tpreempt_disable();\n\t \n\tif (wq_has_sleeper(&log_wait) ||  \n\t    (val & PRINTK_PENDING_OUTPUT)) {\n\t\tthis_cpu_or(printk_pending, val);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}\n\n \nvoid wake_up_klogd(void)\n{\n\t__wake_up_klogd(PRINTK_PENDING_WAKEUP);\n}\n\n \nvoid defer_console_output(void)\n{\n\t \n\t__wake_up_klogd(PRINTK_PENDING_WAKEUP | PRINTK_PENDING_OUTPUT);\n}\n\nvoid printk_trigger_flush(void)\n{\n\tdefer_console_output();\n}\n\nint vprintk_deferred(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n}\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}\n\n \nDEFINE_RATELIMIT_STATE(printk_ratelimit_state, 5 * HZ, 10);\n\nint __printk_ratelimit(const char *func)\n{\n\treturn ___ratelimit(&printk_ratelimit_state, func);\n}\nEXPORT_SYMBOL(__printk_ratelimit);\n\n \nbool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\tunsigned int interval_msecs)\n{\n\tunsigned long elapsed = jiffies - *caller_jiffies;\n\n\tif (*caller_jiffies && elapsed <= msecs_to_jiffies(interval_msecs))\n\t\treturn false;\n\n\t*caller_jiffies = jiffies;\n\treturn true;\n}\nEXPORT_SYMBOL(printk_timed_ratelimit);\n\nstatic DEFINE_SPINLOCK(dump_list_lock);\nstatic LIST_HEAD(dump_list);\n\n \nint kmsg_dump_register(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -EBUSY;\n\n\t \n\tif (!dumper->dump)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\t \n\tif (!dumper->registered) {\n\t\tdumper->registered = 1;\n\t\tlist_add_tail_rcu(&dumper->list, &dump_list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(kmsg_dump_register);\n\n \nint kmsg_dump_unregister(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -EINVAL;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\tif (dumper->registered) {\n\t\tdumper->registered = 0;\n\t\tlist_del_rcu(&dumper->list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\tsynchronize_rcu();\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(kmsg_dump_unregister);\n\nstatic bool always_kmsg_dump;\nmodule_param_named(always_kmsg_dump, always_kmsg_dump, bool, S_IRUGO | S_IWUSR);\n\nconst char *kmsg_dump_reason_str(enum kmsg_dump_reason reason)\n{\n\tswitch (reason) {\n\tcase KMSG_DUMP_PANIC:\n\t\treturn \"Panic\";\n\tcase KMSG_DUMP_OOPS:\n\t\treturn \"Oops\";\n\tcase KMSG_DUMP_EMERG:\n\t\treturn \"Emergency\";\n\tcase KMSG_DUMP_SHUTDOWN:\n\t\treturn \"Shutdown\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\nEXPORT_SYMBOL_GPL(kmsg_dump_reason_str);\n\n \nvoid kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dumper *dumper;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list) {\n\t\tenum kmsg_dump_reason max_reason = dumper->max_reason;\n\n\t\t \n\t\tif (max_reason == KMSG_DUMP_UNDEF) {\n\t\t\tmax_reason = always_kmsg_dump ? KMSG_DUMP_MAX :\n\t\t\t\t\t\t\tKMSG_DUMP_OOPS;\n\t\t}\n\t\tif (reason > max_reason)\n\t\t\tcontinue;\n\n\t\t \n\t\tdumper->dump(dumper, reason);\n\t}\n\trcu_read_unlock();\n}\n\n \nbool kmsg_dump_get_line(struct kmsg_dump_iter *iter, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tu64 min_seq = latched_seq_read_nolock(&clear_seq);\n\tstruct printk_info info;\n\tunsigned int line_count;\n\tstruct printk_record r;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (iter->cur_seq < min_seq)\n\t\titer->cur_seq = min_seq;\n\n\tprb_rec_init_rd(&r, &info, line, size);\n\n\t \n\tif (line) {\n\t\tif (!prb_read_valid(prb, iter->cur_seq, &r))\n\t\t\tgoto out;\n\t\tl = record_print_text(&r, syslog, printk_time);\n\t} else {\n\t\tif (!prb_read_valid_info(prb, iter->cur_seq,\n\t\t\t\t\t &info, &line_count)) {\n\t\t\tgoto out;\n\t\t}\n\t\tl = get_record_print_text_size(&info, line_count, syslog,\n\t\t\t\t\t       printk_time);\n\n\t}\n\n\titer->cur_seq = r.info->seq + 1;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kmsg_dump_get_line);\n\n \nbool kmsg_dump_get_buffer(struct kmsg_dump_iter *iter, bool syslog,\n\t\t\t  char *buf, size_t size, size_t *len_out)\n{\n\tu64 min_seq = latched_seq_read_nolock(&clear_seq);\n\tstruct printk_info info;\n\tstruct printk_record r;\n\tu64 seq;\n\tu64 next_seq;\n\tsize_t len = 0;\n\tbool ret = false;\n\tbool time = printk_time;\n\n\tif (!buf || !size)\n\t\tgoto out;\n\n\tif (iter->cur_seq < min_seq)\n\t\titer->cur_seq = min_seq;\n\n\tif (prb_read_valid_info(prb, iter->cur_seq, &info, NULL)) {\n\t\tif (info.seq != iter->cur_seq) {\n\t\t\t \n\t\t\titer->cur_seq = info.seq;\n\t\t}\n\t}\n\n\t \n\tif (iter->cur_seq >= iter->next_seq)\n\t\tgoto out;\n\n\t \n\tseq = find_first_fitting_seq(iter->cur_seq, iter->next_seq,\n\t\t\t\t     size - 1, syslog, time);\n\n\t \n\tnext_seq = seq;\n\n\tprb_rec_init_rd(&r, &info, buf, size);\n\n\tlen = 0;\n\tprb_for_each_record(seq, prb, seq, &r) {\n\t\tif (r.info->seq >= iter->next_seq)\n\t\t\tbreak;\n\n\t\tlen += record_print_text(&r, syslog, time);\n\n\t\t \n\t\tprb_rec_init_rd(&r, &info, buf + len, size - len);\n\t}\n\n\titer->next_seq = next_seq;\n\tret = true;\nout:\n\tif (len_out)\n\t\t*len_out = len;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kmsg_dump_get_buffer);\n\n \nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}\nEXPORT_SYMBOL_GPL(kmsg_dump_rewind);\n\n#endif\n\n#ifdef CONFIG_SMP\nstatic atomic_t printk_cpu_sync_owner = ATOMIC_INIT(-1);\nstatic atomic_t printk_cpu_sync_nested = ATOMIC_INIT(0);\n\n \nvoid __printk_cpu_sync_wait(void)\n{\n\tdo {\n\t\tcpu_relax();\n\t} while (atomic_read(&printk_cpu_sync_owner) != -1);\n}\nEXPORT_SYMBOL(__printk_cpu_sync_wait);\n\n \nint __printk_cpu_sync_try_get(void)\n{\n\tint cpu;\n\tint old;\n\n\tcpu = smp_processor_id();\n\n\t \n\told = atomic_cmpxchg_acquire(&printk_cpu_sync_owner, -1,\n\t\t\t\t     cpu);  \n\tif (old == -1) {\n\t\t \n\t\treturn 1;\n\n\t} else if (old == cpu) {\n\t\t \n\t\tatomic_inc(&printk_cpu_sync_nested);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__printk_cpu_sync_try_get);\n\n \nvoid __printk_cpu_sync_put(void)\n{\n\tif (atomic_read(&printk_cpu_sync_nested)) {\n\t\tatomic_dec(&printk_cpu_sync_nested);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tatomic_set_release(&printk_cpu_sync_owner,\n\t\t\t   -1);  \n}\nEXPORT_SYMBOL(__printk_cpu_sync_put);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}