{
  "module_name": "printk_ringbuffer.c",
  "hash_id": "084938b87350f1b77b3fa51358091f9dfdb5a684ecaf20123af1e7279a0b263d",
  "original_prompt": "Ingested from linux-6.6.14/kernel/printk/printk_ringbuffer.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/irqflags.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include \"printk_ringbuffer.h\"\n\n \n\n#define DATA_SIZE(data_ring)\t\t_DATA_SIZE((data_ring)->size_bits)\n#define DATA_SIZE_MASK(data_ring)\t(DATA_SIZE(data_ring) - 1)\n\n#define DESCS_COUNT(desc_ring)\t\t_DESCS_COUNT((desc_ring)->count_bits)\n#define DESCS_COUNT_MASK(desc_ring)\t(DESCS_COUNT(desc_ring) - 1)\n\n \n#define DATA_INDEX(data_ring, lpos)\t((lpos) & DATA_SIZE_MASK(data_ring))\n\n \n#define DESC_INDEX(desc_ring, n)\t((n) & DESCS_COUNT_MASK(desc_ring))\n\n \n#define DATA_WRAPS(data_ring, lpos)\t((lpos) >> (data_ring)->size_bits)\n\n \n#define LPOS_DATALESS(lpos)\t\t((lpos) & 1UL)\n#define BLK_DATALESS(blk)\t\t(LPOS_DATALESS((blk)->begin) && \\\n\t\t\t\t\t LPOS_DATALESS((blk)->next))\n\n \n#define DATA_THIS_WRAP_START_LPOS(data_ring, lpos) \\\n((lpos) & ~DATA_SIZE_MASK(data_ring))\n\n \n#define DESC_ID_PREV_WRAP(desc_ring, id) \\\nDESC_ID((id) - DESCS_COUNT(desc_ring))\n\n \nstruct prb_data_block {\n\tunsigned long\tid;\n\tchar\t\tdata[];\n};\n\n \nstatic struct prb_desc *to_desc(struct prb_desc_ring *desc_ring, u64 n)\n{\n\treturn &desc_ring->descs[DESC_INDEX(desc_ring, n)];\n}\n\n \nstatic struct printk_info *to_info(struct prb_desc_ring *desc_ring, u64 n)\n{\n\treturn &desc_ring->infos[DESC_INDEX(desc_ring, n)];\n}\n\nstatic struct prb_data_block *to_block(struct prb_data_ring *data_ring,\n\t\t\t\t       unsigned long begin_lpos)\n{\n\treturn (void *)&data_ring->data[DATA_INDEX(data_ring, begin_lpos)];\n}\n\n \nstatic unsigned int to_blk_size(unsigned int size)\n{\n\tstruct prb_data_block *db = NULL;\n\n\tsize += sizeof(*db);\n\tsize = ALIGN(size, sizeof(db->id));\n\treturn size;\n}\n\n \nstatic bool data_check_size(struct prb_data_ring *data_ring, unsigned int size)\n{\n\tstruct prb_data_block *db = NULL;\n\n\tif (size == 0)\n\t\treturn true;\n\n\t \n\tsize = to_blk_size(size);\n\tif (size > DATA_SIZE(data_ring) - sizeof(db->id))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic enum desc_state get_desc_state(unsigned long id,\n\t\t\t\t      unsigned long state_val)\n{\n\tif (id != DESC_ID(state_val))\n\t\treturn desc_miss;\n\n\treturn DESC_STATE(state_val);\n}\n\n \nstatic enum desc_state desc_read(struct prb_desc_ring *desc_ring,\n\t\t\t\t unsigned long id, struct prb_desc *desc_out,\n\t\t\t\t u64 *seq_out, u32 *caller_id_out)\n{\n\tstruct printk_info *info = to_info(desc_ring, id);\n\tstruct prb_desc *desc = to_desc(desc_ring, id);\n\tatomic_long_t *state_var = &desc->state_var;\n\tenum desc_state d_state;\n\tunsigned long state_val;\n\n\t \n\tstate_val = atomic_long_read(state_var);  \n\td_state = get_desc_state(id, state_val);\n\tif (d_state == desc_miss || d_state == desc_reserved) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tsmp_rmb();  \n\n\t \n\tif (desc_out) {\n\t\tmemcpy(&desc_out->text_blk_lpos, &desc->text_blk_lpos,\n\t\t       sizeof(desc_out->text_blk_lpos));  \n\t}\n\tif (seq_out)\n\t\t*seq_out = info->seq;  \n\tif (caller_id_out)\n\t\t*caller_id_out = info->caller_id;  \n\n\t \n\tsmp_rmb();  \n\n\t \n\tstate_val = atomic_long_read(state_var);  \n\td_state = get_desc_state(id, state_val);\nout:\n\tif (desc_out)\n\t\tatomic_long_set(&desc_out->state_var, state_val);\n\treturn d_state;\n}\n\n \nstatic void desc_make_reusable(struct prb_desc_ring *desc_ring,\n\t\t\t       unsigned long id)\n{\n\tunsigned long val_finalized = DESC_SV(id, desc_finalized);\n\tunsigned long val_reusable = DESC_SV(id, desc_reusable);\n\tstruct prb_desc *desc = to_desc(desc_ring, id);\n\tatomic_long_t *state_var = &desc->state_var;\n\n\tatomic_long_cmpxchg_relaxed(state_var, val_finalized,\n\t\t\t\t    val_reusable);  \n}\n\n \nstatic bool data_make_reusable(struct printk_ringbuffer *rb,\n\t\t\t       unsigned long lpos_begin,\n\t\t\t       unsigned long lpos_end,\n\t\t\t       unsigned long *lpos_out)\n{\n\n\tstruct prb_data_ring *data_ring = &rb->text_data_ring;\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tstruct prb_data_block *blk;\n\tenum desc_state d_state;\n\tstruct prb_desc desc;\n\tstruct prb_data_blk_lpos *blk_lpos = &desc.text_blk_lpos;\n\tunsigned long id;\n\n\t \n\twhile ((lpos_end - lpos_begin) - 1 < DATA_SIZE(data_ring)) {\n\t\tblk = to_block(data_ring, lpos_begin);\n\n\t\t \n\t\tid = blk->id;  \n\n\t\td_state = desc_read(desc_ring, id, &desc,\n\t\t\t\t    NULL, NULL);  \n\n\t\tswitch (d_state) {\n\t\tcase desc_miss:\n\t\tcase desc_reserved:\n\t\tcase desc_committed:\n\t\t\treturn false;\n\t\tcase desc_finalized:\n\t\t\t \n\t\t\tif (blk_lpos->begin != lpos_begin)\n\t\t\t\treturn false;\n\t\t\tdesc_make_reusable(desc_ring, id);\n\t\t\tbreak;\n\t\tcase desc_reusable:\n\t\t\t \n\t\t\tif (blk_lpos->begin != lpos_begin)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlpos_begin = blk_lpos->next;\n\t}\n\n\t*lpos_out = lpos_begin;\n\treturn true;\n}\n\n \nstatic bool data_push_tail(struct printk_ringbuffer *rb, unsigned long lpos)\n{\n\tstruct prb_data_ring *data_ring = &rb->text_data_ring;\n\tunsigned long tail_lpos_new;\n\tunsigned long tail_lpos;\n\tunsigned long next_lpos;\n\n\t \n\tif (LPOS_DATALESS(lpos))\n\t\treturn true;\n\n\t \n\ttail_lpos = atomic_long_read(&data_ring->tail_lpos);  \n\n\t \n\twhile ((lpos - tail_lpos) - 1 < DATA_SIZE(data_ring)) {\n\t\t \n\t\tif (!data_make_reusable(rb, tail_lpos, lpos, &next_lpos)) {\n\t\t\t \n\t\t\tsmp_rmb();  \n\n\t\t\ttail_lpos_new = atomic_long_read(&data_ring->tail_lpos\n\t\t\t\t\t\t\t);  \n\t\t\tif (tail_lpos_new == tail_lpos)\n\t\t\t\treturn false;\n\n\t\t\t \n\t\t\ttail_lpos = tail_lpos_new;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (atomic_long_try_cmpxchg(&data_ring->tail_lpos, &tail_lpos,\n\t\t\t\t\t    next_lpos)) {  \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic bool desc_push_tail(struct printk_ringbuffer *rb,\n\t\t\t   unsigned long tail_id)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tenum desc_state d_state;\n\tstruct prb_desc desc;\n\n\td_state = desc_read(desc_ring, tail_id, &desc, NULL, NULL);\n\n\tswitch (d_state) {\n\tcase desc_miss:\n\t\t \n\t\tif (DESC_ID(atomic_long_read(&desc.state_var)) ==\n\t\t    DESC_ID_PREV_WRAP(desc_ring, tail_id)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\treturn true;\n\tcase desc_reserved:\n\tcase desc_committed:\n\t\treturn false;\n\tcase desc_finalized:\n\t\tdesc_make_reusable(desc_ring, tail_id);\n\t\tbreak;\n\tcase desc_reusable:\n\t\tbreak;\n\t}\n\n\t \n\n\tif (!data_push_tail(rb, desc.text_blk_lpos.next))\n\t\treturn false;\n\n\t \n\td_state = desc_read(desc_ring, DESC_ID(tail_id + 1), &desc,\n\t\t\t    NULL, NULL);  \n\n\tif (d_state == desc_finalized || d_state == desc_reusable) {\n\t\t \n\t\tatomic_long_cmpxchg(&desc_ring->tail_id, tail_id,\n\t\t\t\t    DESC_ID(tail_id + 1));  \n\t} else {\n\t\t \n\t\tsmp_rmb();  \n\n\t\t \n\t\tif (atomic_long_read(&desc_ring->tail_id) == tail_id)  \n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool desc_reserve(struct printk_ringbuffer *rb, unsigned long *id_out)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tunsigned long prev_state_val;\n\tunsigned long id_prev_wrap;\n\tstruct prb_desc *desc;\n\tunsigned long head_id;\n\tunsigned long id;\n\n\thead_id = atomic_long_read(&desc_ring->head_id);  \n\n\tdo {\n\t\tid = DESC_ID(head_id + 1);\n\t\tid_prev_wrap = DESC_ID_PREV_WRAP(desc_ring, id);\n\n\t\t \n\t\tsmp_rmb();  \n\n\t\tif (id_prev_wrap == atomic_long_read(&desc_ring->tail_id\n\t\t\t\t\t\t    )) {  \n\t\t\t \n\t\t\tif (!desc_push_tail(rb, id_prev_wrap))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t \n\t} while (!atomic_long_try_cmpxchg(&desc_ring->head_id, &head_id,\n\t\t\t\t\t  id));  \n\n\tdesc = to_desc(desc_ring, id);\n\n\t \n\tprev_state_val = atomic_long_read(&desc->state_var);  \n\tif (prev_state_val &&\n\t    get_desc_state(id_prev_wrap, prev_state_val) != desc_reusable) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\t \n\tif (!atomic_long_try_cmpxchg(&desc->state_var, &prev_state_val,\n\t\t\tDESC_SV(id, desc_reserved))) {  \n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\t \n\n\t*id_out = id;\n\treturn true;\n}\n\n \nstatic unsigned long get_next_lpos(struct prb_data_ring *data_ring,\n\t\t\t\t   unsigned long lpos, unsigned int size)\n{\n\tunsigned long begin_lpos;\n\tunsigned long next_lpos;\n\n\tbegin_lpos = lpos;\n\tnext_lpos = lpos + size;\n\n\t \n\tif (DATA_WRAPS(data_ring, begin_lpos) == DATA_WRAPS(data_ring, next_lpos))\n\t\treturn next_lpos;\n\n\t \n\treturn (DATA_THIS_WRAP_START_LPOS(data_ring, next_lpos) + size);\n}\n\n \nstatic char *data_alloc(struct printk_ringbuffer *rb, unsigned int size,\n\t\t\tstruct prb_data_blk_lpos *blk_lpos, unsigned long id)\n{\n\tstruct prb_data_ring *data_ring = &rb->text_data_ring;\n\tstruct prb_data_block *blk;\n\tunsigned long begin_lpos;\n\tunsigned long next_lpos;\n\n\tif (size == 0) {\n\t\t \n\t\tblk_lpos->begin = NO_LPOS;\n\t\tblk_lpos->next = NO_LPOS;\n\t\treturn NULL;\n\t}\n\n\tsize = to_blk_size(size);\n\n\tbegin_lpos = atomic_long_read(&data_ring->head_lpos);\n\n\tdo {\n\t\tnext_lpos = get_next_lpos(data_ring, begin_lpos, size);\n\n\t\tif (!data_push_tail(rb, next_lpos - DATA_SIZE(data_ring))) {\n\t\t\t \n\t\t\tblk_lpos->begin = FAILED_LPOS;\n\t\t\tblk_lpos->next = FAILED_LPOS;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t} while (!atomic_long_try_cmpxchg(&data_ring->head_lpos, &begin_lpos,\n\t\t\t\t\t  next_lpos));  \n\n\tblk = to_block(data_ring, begin_lpos);\n\tblk->id = id;  \n\n\tif (DATA_WRAPS(data_ring, begin_lpos) != DATA_WRAPS(data_ring, next_lpos)) {\n\t\t \n\t\tblk = to_block(data_ring, 0);\n\n\t\t \n\t\tblk->id = id;\n\t}\n\n\tblk_lpos->begin = begin_lpos;\n\tblk_lpos->next = next_lpos;\n\n\treturn &blk->data[0];\n}\n\n \nstatic char *data_realloc(struct printk_ringbuffer *rb, unsigned int size,\n\t\t\t  struct prb_data_blk_lpos *blk_lpos, unsigned long id)\n{\n\tstruct prb_data_ring *data_ring = &rb->text_data_ring;\n\tstruct prb_data_block *blk;\n\tunsigned long head_lpos;\n\tunsigned long next_lpos;\n\tbool wrapped;\n\n\t \n\thead_lpos = atomic_long_read(&data_ring->head_lpos);\n\tif (head_lpos != blk_lpos->next)\n\t\treturn NULL;\n\n\t \n\twrapped = (DATA_WRAPS(data_ring, blk_lpos->begin) != DATA_WRAPS(data_ring, blk_lpos->next));\n\n\tsize = to_blk_size(size);\n\n\tnext_lpos = get_next_lpos(data_ring, blk_lpos->begin, size);\n\n\t \n\tif (head_lpos - next_lpos < DATA_SIZE(data_ring)) {\n\t\tif (wrapped)\n\t\t\tblk = to_block(data_ring, 0);\n\t\telse\n\t\t\tblk = to_block(data_ring, blk_lpos->begin);\n\t\treturn &blk->data[0];\n\t}\n\n\tif (!data_push_tail(rb, next_lpos - DATA_SIZE(data_ring)))\n\t\treturn NULL;\n\n\t \n\tif (!atomic_long_try_cmpxchg(&data_ring->head_lpos, &head_lpos,\n\t\t\t\t     next_lpos)) {  \n\t\treturn NULL;\n\t}\n\n\tblk = to_block(data_ring, blk_lpos->begin);\n\n\tif (DATA_WRAPS(data_ring, blk_lpos->begin) != DATA_WRAPS(data_ring, next_lpos)) {\n\t\tstruct prb_data_block *old_blk = blk;\n\n\t\t \n\t\tblk = to_block(data_ring, 0);\n\n\t\t \n\t\tblk->id = id;\n\n\t\tif (!wrapped) {\n\t\t\t \n\t\t\tmemcpy(&blk->data[0], &old_blk->data[0],\n\t\t\t       (blk_lpos->next - blk_lpos->begin) - sizeof(blk->id));\n\t\t}\n\t}\n\n\tblk_lpos->next = next_lpos;\n\n\treturn &blk->data[0];\n}\n\n \nstatic unsigned int space_used(struct prb_data_ring *data_ring,\n\t\t\t       struct prb_data_blk_lpos *blk_lpos)\n{\n\t \n\tif (BLK_DATALESS(blk_lpos))\n\t\treturn 0;\n\n\tif (DATA_WRAPS(data_ring, blk_lpos->begin) == DATA_WRAPS(data_ring, blk_lpos->next)) {\n\t\t \n\t\treturn (DATA_INDEX(data_ring, blk_lpos->next) -\n\t\t\tDATA_INDEX(data_ring, blk_lpos->begin));\n\t}\n\n\t \n\treturn (DATA_INDEX(data_ring, blk_lpos->next) +\n\t\tDATA_SIZE(data_ring) - DATA_INDEX(data_ring, blk_lpos->begin));\n}\n\n \nstatic const char *get_data(struct prb_data_ring *data_ring,\n\t\t\t    struct prb_data_blk_lpos *blk_lpos,\n\t\t\t    unsigned int *data_size)\n{\n\tstruct prb_data_block *db;\n\n\t \n\tif (BLK_DATALESS(blk_lpos)) {\n\t\tif (blk_lpos->begin == NO_LPOS && blk_lpos->next == NO_LPOS) {\n\t\t\t*data_size = 0;\n\t\t\treturn \"\";\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t \n\tif (DATA_WRAPS(data_ring, blk_lpos->begin) == DATA_WRAPS(data_ring, blk_lpos->next) &&\n\t    blk_lpos->begin < blk_lpos->next) {\n\t\tdb = to_block(data_ring, blk_lpos->begin);\n\t\t*data_size = blk_lpos->next - blk_lpos->begin;\n\n\t \n\t} else if (DATA_WRAPS(data_ring, blk_lpos->begin + DATA_SIZE(data_ring)) ==\n\t\t   DATA_WRAPS(data_ring, blk_lpos->next)) {\n\t\tdb = to_block(data_ring, 0);\n\t\t*data_size = DATA_INDEX(data_ring, blk_lpos->next);\n\n\t \n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(blk_lpos->begin != ALIGN(blk_lpos->begin, sizeof(db->id))) ||\n\t    WARN_ON_ONCE(blk_lpos->next != ALIGN(blk_lpos->next, sizeof(db->id)))) {\n\t\treturn NULL;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(*data_size < sizeof(db->id)))\n\t\treturn NULL;\n\n\t \n\t*data_size -= sizeof(db->id);\n\n\treturn &db->data[0];\n}\n\n \nstatic struct prb_desc *desc_reopen_last(struct prb_desc_ring *desc_ring,\n\t\t\t\t\t u32 caller_id, unsigned long *id_out)\n{\n\tunsigned long prev_state_val;\n\tenum desc_state d_state;\n\tstruct prb_desc desc;\n\tstruct prb_desc *d;\n\tunsigned long id;\n\tu32 cid;\n\n\tid = atomic_long_read(&desc_ring->head_id);\n\n\t \n\td_state = desc_read(desc_ring, id, &desc, NULL, &cid);\n\tif (d_state != desc_committed || cid != caller_id)\n\t\treturn NULL;\n\n\td = to_desc(desc_ring, id);\n\n\tprev_state_val = DESC_SV(id, desc_committed);\n\n\t \n\tif (!atomic_long_try_cmpxchg(&d->state_var, &prev_state_val,\n\t\t\tDESC_SV(id, desc_reserved))) {  \n\t\treturn NULL;\n\t}\n\n\t*id_out = id;\n\treturn d;\n}\n\n \nbool prb_reserve_in_last(struct prb_reserved_entry *e, struct printk_ringbuffer *rb,\n\t\t\t struct printk_record *r, u32 caller_id, unsigned int max_size)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tstruct printk_info *info;\n\tunsigned int data_size;\n\tstruct prb_desc *d;\n\tunsigned long id;\n\n\tlocal_irq_save(e->irqflags);\n\n\t \n\td = desc_reopen_last(desc_ring, caller_id, &id);\n\tif (!d) {\n\t\tlocal_irq_restore(e->irqflags);\n\t\tgoto fail_reopen;\n\t}\n\n\t \n\n\tinfo = to_info(desc_ring, id);\n\n\t \n\te->rb = rb;\n\te->id = id;\n\n\t \n\tif (caller_id != info->caller_id)\n\t\tgoto fail;\n\n\tif (BLK_DATALESS(&d->text_blk_lpos)) {\n\t\tif (WARN_ON_ONCE(info->text_len != 0)) {\n\t\t\tpr_warn_once(\"wrong text_len value (%hu, expecting 0)\\n\",\n\t\t\t\t     info->text_len);\n\t\t\tinfo->text_len = 0;\n\t\t}\n\n\t\tif (!data_check_size(&rb->text_data_ring, r->text_buf_size))\n\t\t\tgoto fail;\n\n\t\tif (r->text_buf_size > max_size)\n\t\t\tgoto fail;\n\n\t\tr->text_buf = data_alloc(rb, r->text_buf_size,\n\t\t\t\t\t &d->text_blk_lpos, id);\n\t} else {\n\t\tif (!get_data(&rb->text_data_ring, &d->text_blk_lpos, &data_size))\n\t\t\tgoto fail;\n\n\t\t \n\t\tif (WARN_ON_ONCE(info->text_len > data_size)) {\n\t\t\tpr_warn_once(\"wrong text_len value (%hu, expecting <=%u)\\n\",\n\t\t\t\t     info->text_len, data_size);\n\t\t\tinfo->text_len = data_size;\n\t\t}\n\t\tr->text_buf_size += info->text_len;\n\n\t\tif (!data_check_size(&rb->text_data_ring, r->text_buf_size))\n\t\t\tgoto fail;\n\n\t\tif (r->text_buf_size > max_size)\n\t\t\tgoto fail;\n\n\t\tr->text_buf = data_realloc(rb, r->text_buf_size,\n\t\t\t\t\t   &d->text_blk_lpos, id);\n\t}\n\tif (r->text_buf_size && !r->text_buf)\n\t\tgoto fail;\n\n\tr->info = info;\n\n\te->text_space = space_used(&rb->text_data_ring, &d->text_blk_lpos);\n\n\treturn true;\nfail:\n\tprb_commit(e);\n\t \nfail_reopen:\n\t \n\tmemset(r, 0, sizeof(*r));\n\treturn false;\n}\n\n \nstatic void desc_make_final(struct prb_desc_ring *desc_ring, unsigned long id)\n{\n\tunsigned long prev_state_val = DESC_SV(id, desc_committed);\n\tstruct prb_desc *d = to_desc(desc_ring, id);\n\n\tatomic_long_cmpxchg_relaxed(&d->state_var, prev_state_val,\n\t\t\tDESC_SV(id, desc_finalized));  \n\n\t \n\tatomic_long_set(&desc_ring->last_finalized_id, id);\n}\n\n \nbool prb_reserve(struct prb_reserved_entry *e, struct printk_ringbuffer *rb,\n\t\t struct printk_record *r)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tstruct printk_info *info;\n\tstruct prb_desc *d;\n\tunsigned long id;\n\tu64 seq;\n\n\tif (!data_check_size(&rb->text_data_ring, r->text_buf_size))\n\t\tgoto fail;\n\n\t \n\tlocal_irq_save(e->irqflags);\n\n\tif (!desc_reserve(rb, &id)) {\n\t\t \n\t\tatomic_long_inc(&rb->fail);\n\t\tlocal_irq_restore(e->irqflags);\n\t\tgoto fail;\n\t}\n\n\td = to_desc(desc_ring, id);\n\tinfo = to_info(desc_ring, id);\n\n\t \n\tseq = info->seq;\n\tmemset(info, 0, sizeof(*info));\n\n\t \n\te->rb = rb;\n\te->id = id;\n\n\t \n\tif (seq == 0 && DESC_INDEX(desc_ring, id) != 0)\n\t\tinfo->seq = DESC_INDEX(desc_ring, id);\n\telse\n\t\tinfo->seq = seq + DESCS_COUNT(desc_ring);\n\n\t \n\tif (info->seq > 0)\n\t\tdesc_make_final(desc_ring, DESC_ID(id - 1));\n\n\tr->text_buf = data_alloc(rb, r->text_buf_size, &d->text_blk_lpos, id);\n\t \n\tif (r->text_buf_size && !r->text_buf) {\n\t\tprb_commit(e);\n\t\t \n\t\tgoto fail;\n\t}\n\n\tr->info = info;\n\n\t \n\te->text_space = space_used(&rb->text_data_ring, &d->text_blk_lpos);\n\n\treturn true;\nfail:\n\t \n\tmemset(r, 0, sizeof(*r));\n\treturn false;\n}\n\n \nstatic void _prb_commit(struct prb_reserved_entry *e, unsigned long state_val)\n{\n\tstruct prb_desc_ring *desc_ring = &e->rb->desc_ring;\n\tstruct prb_desc *d = to_desc(desc_ring, e->id);\n\tunsigned long prev_state_val = DESC_SV(e->id, desc_reserved);\n\n\t \n\n\t \n\tif (!atomic_long_try_cmpxchg(&d->state_var, &prev_state_val,\n\t\t\tDESC_SV(e->id, state_val))) {  \n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t \n\tlocal_irq_restore(e->irqflags);\n}\n\n \nvoid prb_commit(struct prb_reserved_entry *e)\n{\n\tstruct prb_desc_ring *desc_ring = &e->rb->desc_ring;\n\tunsigned long head_id;\n\n\t_prb_commit(e, desc_committed);\n\n\t \n\thead_id = atomic_long_read(&desc_ring->head_id);  \n\tif (head_id != e->id)\n\t\tdesc_make_final(desc_ring, e->id);\n}\n\n \nvoid prb_final_commit(struct prb_reserved_entry *e)\n{\n\tstruct prb_desc_ring *desc_ring = &e->rb->desc_ring;\n\n\t_prb_commit(e, desc_finalized);\n\n\t \n\tatomic_long_set(&desc_ring->last_finalized_id, e->id);\n}\n\n \nstatic unsigned int count_lines(const char *text, unsigned int text_size)\n{\n\tunsigned int next_size = text_size;\n\tunsigned int line_count = 1;\n\tconst char *next = text;\n\n\twhile (next_size) {\n\t\tnext = memchr(next, '\\n', next_size);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tline_count++;\n\t\tnext++;\n\t\tnext_size = text_size - (next - text);\n\t}\n\n\treturn line_count;\n}\n\n \nstatic bool copy_data(struct prb_data_ring *data_ring,\n\t\t      struct prb_data_blk_lpos *blk_lpos, u16 len, char *buf,\n\t\t      unsigned int buf_size, unsigned int *line_count)\n{\n\tunsigned int data_size;\n\tconst char *data;\n\n\t \n\tif ((!buf || !buf_size) && !line_count)\n\t\treturn true;\n\n\tdata = get_data(data_ring, blk_lpos, &data_size);\n\tif (!data)\n\t\treturn false;\n\n\t \n\tif (data_size < (unsigned int)len)\n\t\treturn false;\n\n\t \n\tif (line_count)\n\t\t*line_count = count_lines(data, len);\n\n\t \n\tif (!buf || !buf_size)\n\t\treturn true;\n\n\tdata_size = min_t(unsigned int, buf_size, len);\n\n\tmemcpy(&buf[0], data, data_size);  \n\treturn true;\n}\n\n \nstatic int desc_read_finalized_seq(struct prb_desc_ring *desc_ring,\n\t\t\t\t   unsigned long id, u64 seq,\n\t\t\t\t   struct prb_desc *desc_out)\n{\n\tstruct prb_data_blk_lpos *blk_lpos = &desc_out->text_blk_lpos;\n\tenum desc_state d_state;\n\tu64 s;\n\n\td_state = desc_read(desc_ring, id, desc_out, &s, NULL);\n\n\t \n\tif (d_state == desc_miss ||\n\t    d_state == desc_reserved ||\n\t    d_state == desc_committed ||\n\t    s != seq) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (d_state == desc_reusable ||\n\t    (blk_lpos->begin == FAILED_LPOS && blk_lpos->next == FAILED_LPOS)) {\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int prb_read(struct printk_ringbuffer *rb, u64 seq,\n\t\t    struct printk_record *r, unsigned int *line_count)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tstruct printk_info *info = to_info(desc_ring, seq);\n\tstruct prb_desc *rdesc = to_desc(desc_ring, seq);\n\tatomic_long_t *state_var = &rdesc->state_var;\n\tstruct prb_desc desc;\n\tunsigned long id;\n\tint err;\n\n\t \n\tid = DESC_ID(atomic_long_read(state_var));\n\n\t \n\terr = desc_read_finalized_seq(desc_ring, id, seq, &desc);\n\n\t \n\tif (err || !r)\n\t\treturn err;\n\n\t \n\tif (r->info)\n\t\tmemcpy(r->info, info, sizeof(*(r->info)));\n\n\t \n\tif (!copy_data(&rb->text_data_ring, &desc.text_blk_lpos, info->text_len,\n\t\t       r->text_buf, r->text_buf_size, line_count)) {\n\t\treturn -ENOENT;\n\t}\n\n\t \n\treturn desc_read_finalized_seq(desc_ring, id, seq, &desc);\n}\n\n \nstatic u64 prb_first_seq(struct printk_ringbuffer *rb)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tenum desc_state d_state;\n\tstruct prb_desc desc;\n\tunsigned long id;\n\tu64 seq;\n\n\tfor (;;) {\n\t\tid = atomic_long_read(&rb->desc_ring.tail_id);  \n\n\t\td_state = desc_read(desc_ring, id, &desc, &seq, NULL);  \n\n\t\t \n\t\tif (d_state == desc_finalized || d_state == desc_reusable)\n\t\t\tbreak;\n\n\t\t \n\t\tsmp_rmb();  \n\t}\n\n\treturn seq;\n}\n\n \nstatic bool _prb_read_valid(struct printk_ringbuffer *rb, u64 *seq,\n\t\t\t    struct printk_record *r, unsigned int *line_count)\n{\n\tu64 tail_seq;\n\tint err;\n\n\twhile ((err = prb_read(rb, *seq, r, line_count))) {\n\t\ttail_seq = prb_first_seq(rb);\n\n\t\tif (*seq < tail_seq) {\n\t\t\t \n\t\t\t*seq = tail_seq;\n\n\t\t} else if (err == -ENOENT) {\n\t\t\t \n\t\t\t(*seq)++;\n\n\t\t} else {\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nbool prb_read_valid(struct printk_ringbuffer *rb, u64 seq,\n\t\t    struct printk_record *r)\n{\n\treturn _prb_read_valid(rb, &seq, r, NULL);\n}\n\n \nbool prb_read_valid_info(struct printk_ringbuffer *rb, u64 seq,\n\t\t\t struct printk_info *info, unsigned int *line_count)\n{\n\tstruct printk_record r;\n\n\tprb_rec_init_rd(&r, info, NULL, 0);\n\n\treturn _prb_read_valid(rb, &seq, &r, line_count);\n}\n\n \nu64 prb_first_valid_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\tif (!_prb_read_valid(rb, &seq, NULL, NULL))\n\t\treturn 0;\n\n\treturn seq;\n}\n\n \nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tstruct prb_desc_ring *desc_ring = &rb->desc_ring;\n\tenum desc_state d_state;\n\tunsigned long id;\n\tu64 seq;\n\n\t \n\tid = atomic_long_read(&desc_ring->last_finalized_id);\n\td_state = desc_read(desc_ring, id, NULL, &seq, NULL);\n\n\tif (d_state == desc_finalized || d_state == desc_reusable) {\n\t\t \n\t\tif (seq != 0)\n\t\t\tseq++;\n\t} else {\n\t\t \n\t\tseq = 0;\n\t}\n\n\t \n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}\n\n \nvoid prb_init(struct printk_ringbuffer *rb,\n\t      char *text_buf, unsigned int textbits,\n\t      struct prb_desc *descs, unsigned int descbits,\n\t      struct printk_info *infos)\n{\n\tmemset(descs, 0, _DESCS_COUNT(descbits) * sizeof(descs[0]));\n\tmemset(infos, 0, _DESCS_COUNT(descbits) * sizeof(infos[0]));\n\n\trb->desc_ring.count_bits = descbits;\n\trb->desc_ring.descs = descs;\n\trb->desc_ring.infos = infos;\n\tatomic_long_set(&rb->desc_ring.head_id, DESC0_ID(descbits));\n\tatomic_long_set(&rb->desc_ring.tail_id, DESC0_ID(descbits));\n\tatomic_long_set(&rb->desc_ring.last_finalized_id, DESC0_ID(descbits));\n\n\trb->text_data_ring.size_bits = textbits;\n\trb->text_data_ring.data = text_buf;\n\tatomic_long_set(&rb->text_data_ring.head_lpos, BLK0_LPOS(textbits));\n\tatomic_long_set(&rb->text_data_ring.tail_lpos, BLK0_LPOS(textbits));\n\n\tatomic_long_set(&rb->fail, 0);\n\n\tatomic_long_set(&(descs[_DESCS_COUNT(descbits) - 1].state_var), DESC0_SV(descbits));\n\tdescs[_DESCS_COUNT(descbits) - 1].text_blk_lpos.begin = FAILED_LPOS;\n\tdescs[_DESCS_COUNT(descbits) - 1].text_blk_lpos.next = FAILED_LPOS;\n\n\tinfos[0].seq = -(u64)_DESCS_COUNT(descbits);\n\tinfos[_DESCS_COUNT(descbits) - 1].seq = 0;\n}\n\n \nunsigned int prb_record_text_space(struct prb_reserved_entry *e)\n{\n\treturn e->text_space;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}