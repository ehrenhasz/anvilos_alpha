{
  "module_name": "rdma.c",
  "hash_id": "4a77fceacffea380b822348a106392f9f17ea37b9290bae5f3039f4ec704948b",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/rdma.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/cgroup.h>\n#include <linux/parser.h>\n#include <linux/cgroup_rdma.h>\n\n#define RDMACG_MAX_STR \"max\"\n\n \nstatic DEFINE_MUTEX(rdmacg_mutex);\nstatic LIST_HEAD(rdmacg_devices);\n\nenum rdmacg_file_type {\n\tRDMACG_RESOURCE_TYPE_MAX,\n\tRDMACG_RESOURCE_TYPE_STAT,\n};\n\n \nstatic char const *rdmacg_resource_names[] = {\n\t[RDMACG_RESOURCE_HCA_HANDLE]\t= \"hca_handle\",\n\t[RDMACG_RESOURCE_HCA_OBJECT]\t= \"hca_object\",\n};\n\n \nstruct rdmacg_resource {\n\tint max;\n\tint usage;\n};\n\n \nstruct rdmacg_resource_pool {\n\tstruct rdmacg_device\t*device;\n\tstruct rdmacg_resource\tresources[RDMACG_RESOURCE_MAX];\n\n\tstruct list_head\tcg_node;\n\tstruct list_head\tdev_node;\n\n\t \n\tu64\t\t\tusage_sum;\n\t \n\tint\t\t\tnum_max_cnt;\n};\n\nstatic struct rdma_cgroup *css_rdmacg(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct rdma_cgroup, css);\n}\n\nstatic struct rdma_cgroup *parent_rdmacg(struct rdma_cgroup *cg)\n{\n\treturn css_rdmacg(cg->css.parent);\n}\n\nstatic inline struct rdma_cgroup *get_current_rdmacg(void)\n{\n\treturn css_rdmacg(task_get_css(current, rdma_cgrp_id));\n}\n\nstatic void set_resource_limit(struct rdmacg_resource_pool *rpool,\n\t\t\t       int index, int new_max)\n{\n\tif (new_max == S32_MAX) {\n\t\tif (rpool->resources[index].max != S32_MAX)\n\t\t\trpool->num_max_cnt++;\n\t} else {\n\t\tif (rpool->resources[index].max == S32_MAX)\n\t\t\trpool->num_max_cnt--;\n\t}\n\trpool->resources[index].max = new_max;\n}\n\nstatic void set_all_resource_max_limit(struct rdmacg_resource_pool *rpool)\n{\n\tint i;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++)\n\t\tset_resource_limit(rpool, i, S32_MAX);\n}\n\nstatic void free_cg_rpool_locked(struct rdmacg_resource_pool *rpool)\n{\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_del(&rpool->cg_node);\n\tlist_del(&rpool->dev_node);\n\tkfree(rpool);\n}\n\nstatic struct rdmacg_resource_pool *\nfind_cg_rpool_locked(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device)\n\n{\n\tstruct rdmacg_resource_pool *pool;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(pool, &cg->rpools, cg_node)\n\t\tif (pool->device == device)\n\t\t\treturn pool;\n\n\treturn NULL;\n}\n\nstatic struct rdmacg_resource_pool *\nget_cg_rpool_locked(struct rdma_cgroup *cg, struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\tif (rpool)\n\t\treturn rpool;\n\n\trpool = kzalloc(sizeof(*rpool), GFP_KERNEL);\n\tif (!rpool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trpool->device = device;\n\tset_all_resource_max_limit(rpool);\n\n\tINIT_LIST_HEAD(&rpool->cg_node);\n\tINIT_LIST_HEAD(&rpool->dev_node);\n\tlist_add_tail(&rpool->cg_node, &cg->rpools);\n\tlist_add_tail(&rpool->dev_node, &device->rpools);\n\treturn rpool;\n}\n\n \nstatic void\nuncharge_cg_locked(struct rdma_cgroup *cg,\n\t\t   struct rdmacg_device *device,\n\t\t   enum rdmacg_resource_type index)\n{\n\tstruct rdmacg_resource_pool *rpool;\n\n\trpool = find_cg_rpool_locked(cg, device);\n\n\t \n\tif (unlikely(!rpool)) {\n\t\tpr_warn(\"Invalid device %p or rdma cgroup %p\\n\", cg, device);\n\t\treturn;\n\t}\n\n\trpool->resources[index].usage--;\n\n\t \n\tWARN_ON_ONCE(rpool->resources[index].usage < 0);\n\trpool->usage_sum--;\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t \n\t\tfree_cg_rpool_locked(rpool);\n\t}\n}\n\n \nstatic void rdmacg_uncharge_hierarchy(struct rdma_cgroup *cg,\n\t\t\t\t     struct rdmacg_device *device,\n\t\t\t\t     struct rdma_cgroup *stop_cg,\n\t\t\t\t     enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *p;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tfor (p = cg; p != stop_cg; p = parent_rdmacg(p))\n\t\tuncharge_cg_locked(p, device, index);\n\n\tmutex_unlock(&rdmacg_mutex);\n\n\tcss_put(&cg->css);\n}\n\n \nvoid rdmacg_uncharge(struct rdma_cgroup *cg,\n\t\t     struct rdmacg_device *device,\n\t\t     enum rdmacg_resource_type index)\n{\n\tif (index >= RDMACG_RESOURCE_MAX)\n\t\treturn;\n\n\trdmacg_uncharge_hierarchy(cg, device, NULL, index);\n}\nEXPORT_SYMBOL(rdmacg_uncharge);\n\n \nint rdmacg_try_charge(struct rdma_cgroup **rdmacg,\n\t\t      struct rdmacg_device *device,\n\t\t      enum rdmacg_resource_type index)\n{\n\tstruct rdma_cgroup *cg, *p;\n\tstruct rdmacg_resource_pool *rpool;\n\ts64 new;\n\tint ret = 0;\n\n\tif (index >= RDMACG_RESOURCE_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tcg = get_current_rdmacg();\n\n\tmutex_lock(&rdmacg_mutex);\n\tfor (p = cg; p; p = parent_rdmacg(p)) {\n\t\trpool = get_cg_rpool_locked(p, device);\n\t\tif (IS_ERR(rpool)) {\n\t\t\tret = PTR_ERR(rpool);\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tnew = rpool->resources[index].usage + 1;\n\t\t\tif (new > rpool->resources[index].max) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\trpool->resources[index].usage = new;\n\t\t\t\trpool->usage_sum++;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&rdmacg_mutex);\n\n\t*rdmacg = cg;\n\treturn 0;\n\nerr:\n\tmutex_unlock(&rdmacg_mutex);\n\trdmacg_uncharge_hierarchy(cg, device, p, index);\n\treturn ret;\n}\nEXPORT_SYMBOL(rdmacg_try_charge);\n\n \nvoid rdmacg_register_device(struct rdmacg_device *device)\n{\n\tINIT_LIST_HEAD(&device->dev_node);\n\tINIT_LIST_HEAD(&device->rpools);\n\n\tmutex_lock(&rdmacg_mutex);\n\tlist_add_tail(&device->dev_node, &rdmacg_devices);\n\tmutex_unlock(&rdmacg_mutex);\n}\nEXPORT_SYMBOL(rdmacg_register_device);\n\n \nvoid rdmacg_unregister_device(struct rdmacg_device *device)\n{\n\tstruct rdmacg_resource_pool *rpool, *tmp;\n\n\t \n\tmutex_lock(&rdmacg_mutex);\n\tlist_del_init(&device->dev_node);\n\n\t \n\tlist_for_each_entry_safe(rpool, tmp, &device->rpools, dev_node)\n\t\tfree_cg_rpool_locked(rpool);\n\n\tmutex_unlock(&rdmacg_mutex);\n}\nEXPORT_SYMBOL(rdmacg_unregister_device);\n\nstatic int parse_resource(char *c, int *intval)\n{\n\tsubstring_t argstr;\n\tchar *name, *value = c;\n\tsize_t len;\n\tint ret, i;\n\n\tname = strsep(&value, \"=\");\n\tif (!name || !value)\n\t\treturn -EINVAL;\n\n\ti = match_string(rdmacg_resource_names, RDMACG_RESOURCE_MAX, name);\n\tif (i < 0)\n\t\treturn i;\n\n\tlen = strlen(value);\n\n\targstr.from = value;\n\targstr.to = value + len;\n\n\tret = match_int(&argstr, intval);\n\tif (ret >= 0) {\n\t\tif (*intval < 0)\n\t\t\treturn -EINVAL;\n\t\treturn i;\n\t}\n\tif (strncmp(value, RDMACG_MAX_STR, len) == 0) {\n\t\t*intval = S32_MAX;\n\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int rdmacg_parse_limits(char *options,\n\t\t\t       int *new_limits, unsigned long *enables)\n{\n\tchar *c;\n\tint err = -EINVAL;\n\n\t \n\twhile ((c = strsep(&options, \" \")) != NULL) {\n\t\tint index, intval;\n\n\t\tindex = parse_resource(c, &intval);\n\t\tif (index < 0)\n\t\t\tgoto err;\n\n\t\tnew_limits[index] = intval;\n\t\t*enables |= BIT(index);\n\t}\n\treturn 0;\n\nerr:\n\treturn err;\n}\n\nstatic struct rdmacg_device *rdmacg_get_device_locked(const char *name)\n{\n\tstruct rdmacg_device *device;\n\n\tlockdep_assert_held(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node)\n\t\tif (!strcmp(name, device->name))\n\t\t\treturn device;\n\n\treturn NULL;\n}\n\nstatic ssize_t rdmacg_resource_set_max(struct kernfs_open_file *of,\n\t\t\t\t       char *buf, size_t nbytes, loff_t off)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(of_css(of));\n\tconst char *dev_name;\n\tstruct rdmacg_resource_pool *rpool;\n\tstruct rdmacg_device *device;\n\tchar *options = strstrip(buf);\n\tint *new_limits;\n\tunsigned long enables = 0;\n\tint i = 0, ret = 0;\n\n\t \n\tdev_name = strsep(&options, \" \");\n\tif (!dev_name) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tnew_limits = kcalloc(RDMACG_RESOURCE_MAX, sizeof(int), GFP_KERNEL);\n\tif (!new_limits) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = rdmacg_parse_limits(options, new_limits, &enables);\n\tif (ret)\n\t\tgoto parse_err;\n\n\t \n\tmutex_lock(&rdmacg_mutex);\n\n\tdevice = rdmacg_get_device_locked(dev_name);\n\tif (!device) {\n\t\tret = -ENODEV;\n\t\tgoto dev_err;\n\t}\n\n\trpool = get_cg_rpool_locked(cg, device);\n\tif (IS_ERR(rpool)) {\n\t\tret = PTR_ERR(rpool);\n\t\tgoto dev_err;\n\t}\n\n\t \n\tfor_each_set_bit(i, &enables, RDMACG_RESOURCE_MAX)\n\t\tset_resource_limit(rpool, i, new_limits[i]);\n\n\tif (rpool->usage_sum == 0 &&\n\t    rpool->num_max_cnt == RDMACG_RESOURCE_MAX) {\n\t\t \n\t\tfree_cg_rpool_locked(rpool);\n\t}\n\ndev_err:\n\tmutex_unlock(&rdmacg_mutex);\n\nparse_err:\n\tkfree(new_limits);\n\nerr:\n\treturn ret ?: nbytes;\n}\n\nstatic void print_rpool_values(struct seq_file *sf,\n\t\t\t       struct rdmacg_resource_pool *rpool)\n{\n\tenum rdmacg_file_type sf_type;\n\tint i;\n\tu32 value;\n\n\tsf_type = seq_cft(sf)->private;\n\n\tfor (i = 0; i < RDMACG_RESOURCE_MAX; i++) {\n\t\tseq_puts(sf, rdmacg_resource_names[i]);\n\t\tseq_putc(sf, '=');\n\t\tif (sf_type == RDMACG_RESOURCE_TYPE_MAX) {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].max;\n\t\t\telse\n\t\t\t\tvalue = S32_MAX;\n\t\t} else {\n\t\t\tif (rpool)\n\t\t\t\tvalue = rpool->resources[i].usage;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t}\n\n\t\tif (value == S32_MAX)\n\t\t\tseq_puts(sf, RDMACG_MAX_STR);\n\t\telse\n\t\t\tseq_printf(sf, \"%d\", value);\n\t\tseq_putc(sf, ' ');\n\t}\n}\n\nstatic int rdmacg_resource_read(struct seq_file *sf, void *v)\n{\n\tstruct rdmacg_device *device;\n\tstruct rdmacg_resource_pool *rpool;\n\tstruct rdma_cgroup *cg = css_rdmacg(seq_css(sf));\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tlist_for_each_entry(device, &rdmacg_devices, dev_node) {\n\t\tseq_printf(sf, \"%s \", device->name);\n\n\t\trpool = find_cg_rpool_locked(cg, device);\n\t\tprint_rpool_values(sf, rpool);\n\n\t\tseq_putc(sf, '\\n');\n\t}\n\n\tmutex_unlock(&rdmacg_mutex);\n\treturn 0;\n}\n\nstatic struct cftype rdmacg_files[] = {\n\t{\n\t\t.name = \"max\",\n\t\t.write = rdmacg_resource_set_max,\n\t\t.seq_show = rdmacg_resource_read,\n\t\t.private = RDMACG_RESOURCE_TYPE_MAX,\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t},\n\t{\n\t\t.name = \"current\",\n\t\t.seq_show = rdmacg_resource_read,\n\t\t.private = RDMACG_RESOURCE_TYPE_STAT,\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t},\n\t{ }\t \n};\n\nstatic struct cgroup_subsys_state *\nrdmacg_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct rdma_cgroup *cg;\n\n\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\tif (!cg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&cg->rpools);\n\treturn &cg->css;\n}\n\nstatic void rdmacg_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(css);\n\n\tkfree(cg);\n}\n\n \nstatic void rdmacg_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct rdma_cgroup *cg = css_rdmacg(css);\n\tstruct rdmacg_resource_pool *rpool;\n\n\tmutex_lock(&rdmacg_mutex);\n\n\tlist_for_each_entry(rpool, &cg->rpools, cg_node)\n\t\tset_all_resource_max_limit(rpool);\n\n\tmutex_unlock(&rdmacg_mutex);\n}\n\nstruct cgroup_subsys rdma_cgrp_subsys = {\n\t.css_alloc\t= rdmacg_css_alloc,\n\t.css_free\t= rdmacg_css_free,\n\t.css_offline\t= rdmacg_css_offline,\n\t.legacy_cftypes\t= rdmacg_files,\n\t.dfl_cftypes\t= rdmacg_files,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}