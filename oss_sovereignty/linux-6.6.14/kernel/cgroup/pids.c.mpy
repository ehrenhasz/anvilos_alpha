{
  "module_name": "pids.c",
  "hash_id": "132a1b4ea9b54074a59a537f7adc26d7457df45a6209debbe6c7d5efcb64c905",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/pids.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/threads.h>\n#include <linux/atomic.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n#define PIDS_MAX_STR \"max\"\n\nstruct pids_cgroup {\n\tstruct cgroup_subsys_state\tcss;\n\n\t \n\tatomic64_t\t\t\tcounter;\n\tatomic64_t\t\t\tlimit;\n\tint64_t\t\t\t\twatermark;\n\n\t \n\tstruct cgroup_file\t\tevents_file;\n\n\t \n\tatomic64_t\t\t\tevents_limit;\n};\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}\n\nstatic struct cgroup_subsys_state *\npids_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct pids_cgroup *pids;\n\n\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);\n\tif (!pids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tatomic64_set(&pids->counter, 0);\n\tatomic64_set(&pids->limit, PIDS_MAX);\n\tatomic64_set(&pids->events_limit, 0);\n\treturn &pids->css;\n}\n\nstatic void pids_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_pids(css));\n}\n\nstatic void pids_update_watermark(struct pids_cgroup *p, int64_t nr_pids)\n{\n\t \n\tif (nr_pids > READ_ONCE(p->watermark))\n\t\tWRITE_ONCE(p->watermark, nr_pids);\n}\n\n \nstatic void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t \n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}\n\n \nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}\n\n \nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\n\t\tpids_update_watermark(p, new);\n\t}\n}\n\n \nstatic int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\t\tint64_t limit = atomic64_read(&p->limit);\n\n\t\t \n\t\tif (new > limit)\n\t\t\tgoto revert;\n\n\t\t \n\t\tpids_update_watermark(p, new);\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}\n\nstatic int pids_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\t \n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(pids, 1);\n\t\tpids_uncharge(old_pids, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic void pids_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(old_pids, 1);\n\t\tpids_uncharge(pids, 1);\n\t}\n}\n\n \nstatic int pids_can_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\tint err;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\terr = pids_try_charge(pids, 1);\n\tif (err) {\n\t\t \n\t\tif (atomic64_inc_return(&pids->events_limit) == 1) {\n\t\t\tpr_info(\"cgroup: fork rejected by pids controller in \");\n\t\t\tpr_cont_cgroup_path(css->cgroup);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tcgroup_file_notify(&pids->events_file);\n\t}\n\treturn err;\n}\n\nstatic void pids_cancel_fork(struct task_struct *task, struct css_set *cset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tif (cset)\n\t\tcss = cset->subsys[pids_cgrp_id];\n\telse\n\t\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}\n\nstatic void pids_release(struct task_struct *task)\n{\n\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));\n\n\tpids_uncharge(pids, 1);\n}\n\nstatic ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit;\n\tint err;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, PIDS_MAX_STR)) {\n\t\tlimit = PIDS_MAX;\n\t\tgoto set_limit;\n\t}\n\n\terr = kstrtoll(buf, 0, &limit);\n\tif (err)\n\t\treturn err;\n\n\tif (limit < 0 || limit >= PIDS_MAX)\n\t\treturn -EINVAL;\n\nset_limit:\n\t \n\tatomic64_set(&pids->limit, limit);\n\treturn nbytes;\n}\n\nstatic int pids_max_show(struct seq_file *sf, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(sf);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit = atomic64_read(&pids->limit);\n\n\tif (limit >= PIDS_MAX)\n\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);\n\telse\n\t\tseq_printf(sf, \"%lld\\n\", limit);\n\n\treturn 0;\n}\n\nstatic s64 pids_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct pids_cgroup *pids = css_pids(css);\n\n\treturn atomic64_read(&pids->counter);\n}\n\nstatic s64 pids_peak_read(struct cgroup_subsys_state *css,\n\t\t\t  struct cftype *cft)\n{\n\tstruct pids_cgroup *pids = css_pids(css);\n\n\treturn READ_ONCE(pids->watermark);\n}\n\nstatic int pids_events_show(struct seq_file *sf, void *v)\n{\n\tstruct pids_cgroup *pids = css_pids(seq_css(sf));\n\n\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&pids->events_limit));\n\treturn 0;\n}\n\nstatic struct cftype pids_files[] = {\n\t{\n\t\t.name = \"max\",\n\t\t.write = pids_max_write,\n\t\t.seq_show = pids_max_show,\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t},\n\t{\n\t\t.name = \"current\",\n\t\t.read_s64 = pids_current_read,\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t},\n\t{\n\t\t.name = \"peak\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.read_s64 = pids_peak_read,\n\t},\n\t{\n\t\t.name = \"events\",\n\t\t.seq_show = pids_events_show,\n\t\t.file_offset = offsetof(struct pids_cgroup, events_file),\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t},\n\t{ }\t \n};\n\nstruct cgroup_subsys pids_cgrp_subsys = {\n\t.css_alloc\t= pids_css_alloc,\n\t.css_free\t= pids_css_free,\n\t.can_attach \t= pids_can_attach,\n\t.cancel_attach \t= pids_cancel_attach,\n\t.can_fork\t= pids_can_fork,\n\t.cancel_fork\t= pids_cancel_fork,\n\t.release\t= pids_release,\n\t.legacy_cftypes\t= pids_files,\n\t.dfl_cftypes\t= pids_files,\n\t.threaded\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}