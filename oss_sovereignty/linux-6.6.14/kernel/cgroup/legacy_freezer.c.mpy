{
  "module_name": "legacy_freezer.c",
  "hash_id": "039cc2d35dc0c1d6a10cec476fc446d7885e8944028d415ac7f0469cd9457ebd",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/legacy_freezer.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n\n \nenum freezer_state_flags {\n\tCGROUP_FREEZER_ONLINE\t= (1 << 0),  \n\tCGROUP_FREEZING_SELF\t= (1 << 1),  \n\tCGROUP_FREEZING_PARENT\t= (1 << 2),  \n\tCGROUP_FROZEN\t\t= (1 << 3),  \n\n\t \n\tCGROUP_FREEZING\t\t= CGROUP_FREEZING_SELF | CGROUP_FREEZING_PARENT,\n};\n\nstruct freezer {\n\tstruct cgroup_subsys_state\tcss;\n\tunsigned int\t\t\tstate;\n};\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}\n\nstatic inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}\n\nbool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\tunsigned int state;\n\n\trcu_read_lock();\n\t \n\tstate = task_freezer(task)->state;\n\tret = (state & CGROUP_FREEZING) && !(state & CGROUP_FROZEN);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n};\n\nstatic struct cgroup_subsys_state *\nfreezer_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct freezer *freezer;\n\n\tfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\n\tif (!freezer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &freezer->css;\n}\n\n \nstatic int freezer_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct freezer *parent = parent_freezer(freezer);\n\n\tcpus_read_lock();\n\tmutex_lock(&freezer_mutex);\n\n\tfreezer->state |= CGROUP_FREEZER_ONLINE;\n\n\tif (parent && (parent->state & CGROUP_FREEZING)) {\n\t\tfreezer->state |= CGROUP_FREEZING_PARENT | CGROUP_FROZEN;\n\t\tstatic_branch_inc_cpuslocked(&freezer_active);\n\t}\n\n\tmutex_unlock(&freezer_mutex);\n\tcpus_read_unlock();\n\treturn 0;\n}\n\n \nstatic void freezer_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\tcpus_read_lock();\n\tmutex_lock(&freezer_mutex);\n\n\tif (freezer->state & CGROUP_FREEZING)\n\t\tstatic_branch_dec_cpuslocked(&freezer_active);\n\n\tfreezer->state = 0;\n\n\tmutex_unlock(&freezer_mutex);\n\tcpus_read_unlock();\n}\n\nstatic void freezer_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_freezer(css));\n}\n\n \nstatic void freezer_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *new_css;\n\n\tmutex_lock(&freezer_mutex);\n\n\t \n\tcgroup_taskset_for_each(task, new_css, tset) {\n\t\tstruct freezer *freezer = css_freezer(new_css);\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\t__thaw_task(task);\n\t\t} else {\n\t\t\tfreeze_task(task);\n\n\t\t\t \n\t\t\twhile (freezer && (freezer->state & CGROUP_FROZEN)) {\n\t\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\t\tfreezer = parent_freezer(freezer);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&freezer_mutex);\n}\n\n \nstatic void freezer_fork(struct task_struct *task)\n{\n\tstruct freezer *freezer;\n\n\t \n\tif (task_css_is_root(task, freezer_cgrp_id))\n\t\treturn;\n\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\n\tfreezer = task_freezer(task);\n\tif (freezer->state & CGROUP_FREEZING)\n\t\tfreeze_task(task);\n\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}\n\n \nstatic void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t \n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task) && !frozen(task))\n\t\t\tgoto out_iter_end;\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}\n\nstatic int freezer_read(struct seq_file *m, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(m), *pos;\n\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\n\t \n\tcss_for_each_descendant_post(pos, css) {\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tupdate_if_frozen(pos);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n\n\tseq_puts(m, freezer_state_strs(css_freezer(css)->state));\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\nstatic void freeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tfreeze_task(task);\n\tcss_task_iter_end(&it);\n}\n\nstatic void unfreeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\t__thaw_task(task);\n\tcss_task_iter_end(&it);\n}\n\n \nstatic void freezer_apply_state(struct freezer *freezer, bool freeze,\n\t\t\t\tunsigned int state)\n{\n\t \n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZER_ONLINE))\n\t\treturn;\n\n\tif (freeze) {\n\t\tif (!(freezer->state & CGROUP_FREEZING))\n\t\t\tstatic_branch_inc_cpuslocked(&freezer_active);\n\t\tfreezer->state |= state;\n\t\tfreeze_cgroup(freezer);\n\t} else {\n\t\tbool was_freezing = freezer->state & CGROUP_FREEZING;\n\n\t\tfreezer->state &= ~state;\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\tif (was_freezing)\n\t\t\t\tstatic_branch_dec_cpuslocked(&freezer_active);\n\t\t\tunfreeze_cgroup(freezer);\n\t\t}\n\t}\n}\n\n \nstatic void freezer_change_state(struct freezer *freezer, bool freeze)\n{\n\tstruct cgroup_subsys_state *pos;\n\n\tcpus_read_lock();\n\t \n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\tcss_for_each_descendant_pre(pos, &freezer->css) {\n\t\tstruct freezer *pos_f = css_freezer(pos);\n\t\tstruct freezer *parent = parent_freezer(pos_f);\n\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tif (pos_f == freezer)\n\t\t\tfreezer_apply_state(pos_f, freeze,\n\t\t\t\t\t    CGROUP_FREEZING_SELF);\n\t\telse\n\t\t\tfreezer_apply_state(pos_f,\n\t\t\t\t\t    parent->state & CGROUP_FREEZING,\n\t\t\t\t\t    CGROUP_FREEZING_PARENT);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n\tcpus_read_unlock();\n}\n\nstatic ssize_t freezer_write(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tbool freeze;\n\n\tbuf = strstrip(buf);\n\n\tif (strcmp(buf, freezer_state_strs(0)) == 0)\n\t\tfreeze = false;\n\telse if (strcmp(buf, freezer_state_strs(CGROUP_FROZEN)) == 0)\n\t\tfreeze = true;\n\telse\n\t\treturn -EINVAL;\n\n\tfreezer_change_state(css_freezer(of_css(of)), freeze);\n\treturn nbytes;\n}\n\nstatic u64 freezer_self_freezing_read(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\treturn (bool)(freezer->state & CGROUP_FREEZING_SELF);\n}\n\nstatic u64 freezer_parent_freezing_read(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\treturn (bool)(freezer->state & CGROUP_FREEZING_PARENT);\n}\n\nstatic struct cftype files[] = {\n\t{\n\t\t.name = \"state\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = freezer_read,\n\t\t.write = freezer_write,\n\t},\n\t{\n\t\t.name = \"self_freezing\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.read_u64 = freezer_self_freezing_read,\n\t},\n\t{\n\t\t.name = \"parent_freezing\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.read_u64 = freezer_parent_freezing_read,\n\t},\n\t{ }\t \n};\n\nstruct cgroup_subsys freezer_cgrp_subsys = {\n\t.css_alloc\t= freezer_css_alloc,\n\t.css_online\t= freezer_css_online,\n\t.css_offline\t= freezer_css_offline,\n\t.css_free\t= freezer_css_free,\n\t.attach\t\t= freezer_attach,\n\t.fork\t\t= freezer_fork,\n\t.legacy_cftypes\t= files,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}