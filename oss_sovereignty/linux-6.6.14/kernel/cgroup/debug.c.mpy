{
  "module_name": "debug.c",
  "hash_id": "b7e5b7969489804d8adb966853d783a15d5ec7ae372519c5f8364460d2c2e898",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/debug.c",
  "human_readable_source": "\n \n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include \"cgroup-internal.h\"\n\nstatic struct cgroup_subsys_state *\ndebug_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cgroup_subsys_state *css = kzalloc(sizeof(*css), GFP_KERNEL);\n\n\tif (!css)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn css;\n}\n\nstatic void debug_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css);\n}\n\n \nstatic u64 debug_taskcount_read(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft)\n{\n\treturn cgroup_task_count(css->cgroup);\n}\n\nstatic int current_css_set_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct css_set *cset;\n\tstruct cgroup_subsys *ss;\n\tstruct cgroup_subsys_state *css;\n\tint i, refcnt;\n\n\tif (!cgroup_kn_lock_live(of->kn, false))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\tcset = task_css_set(current);\n\trefcnt = refcount_read(&cset->refcount);\n\tseq_printf(seq, \"css_set %pK %d\", cset, refcnt);\n\tif (refcnt > cset->nr_tasks)\n\t\tseq_printf(seq, \" +%d\", refcnt - cset->nr_tasks);\n\tseq_puts(seq, \"\\n\");\n\n\t \n\tfor_each_subsys(ss, i) {\n\t\tcss = cset->subsys[ss->id];\n\t\tif (!css)\n\t\t\tcontinue;\n\t\tseq_printf(seq, \"%2d: %-4s\\t- %p[%d]\\n\", ss->id, ss->name,\n\t\t\t  css, css->id);\n\t}\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}\n\nstatic u64 current_css_set_refcount_read(struct cgroup_subsys_state *css,\n\t\t\t\t\t struct cftype *cft)\n{\n\tu64 count;\n\n\trcu_read_lock();\n\tcount = refcount_read(&task_css_set(current)->refcount);\n\trcu_read_unlock();\n\treturn count;\n}\n\nstatic int current_css_set_cg_links_read(struct seq_file *seq, void *v)\n{\n\tstruct cgrp_cset_link *link;\n\tstruct css_set *cset;\n\tchar *name_buf;\n\n\tname_buf = kmalloc(NAME_MAX + 1, GFP_KERNEL);\n\tif (!name_buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&css_set_lock);\n\trcu_read_lock();\n\tcset = task_css_set(current);\n\tlist_for_each_entry(link, &cset->cgrp_links, cgrp_link) {\n\t\tstruct cgroup *c = link->cgrp;\n\n\t\tcgroup_name(c, name_buf, NAME_MAX + 1);\n\t\tseq_printf(seq, \"Root %d group %s\\n\",\n\t\t\t   c->root->hierarchy_id, name_buf);\n\t}\n\trcu_read_unlock();\n\tspin_unlock_irq(&css_set_lock);\n\tkfree(name_buf);\n\treturn 0;\n}\n\n#define MAX_TASKS_SHOWN_PER_CSS 25\nstatic int cgroup_css_links_read(struct seq_file *seq, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(seq);\n\tstruct cgrp_cset_link *link;\n\tint dead_cnt = 0, extra_refs = 0, threaded_csets = 0;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tlist_for_each_entry(link, &css->cgroup->cset_links, cset_link) {\n\t\tstruct css_set *cset = link->cset;\n\t\tstruct task_struct *task;\n\t\tint count = 0;\n\t\tint refcnt = refcount_read(&cset->refcount);\n\n\t\t \n\t\tseq_printf(seq, \"css_set %pK\", cset);\n\t\tif (rcu_dereference_protected(cset->dom_cset, 1) != cset) {\n\t\t\tthreaded_csets++;\n\t\t\tseq_printf(seq, \"=>%pK\", cset->dom_cset);\n\t\t}\n\t\tif (!list_empty(&cset->threaded_csets)) {\n\t\t\tstruct css_set *tcset;\n\t\t\tint idx = 0;\n\n\t\t\tlist_for_each_entry(tcset, &cset->threaded_csets,\n\t\t\t\t\t    threaded_csets_node) {\n\t\t\t\tseq_puts(seq, idx ? \",\" : \"<=\");\n\t\t\t\tseq_printf(seq, \"%pK\", tcset);\n\t\t\t\tidx++;\n\t\t\t}\n\t\t} else {\n\t\t\tseq_printf(seq, \" %d\", refcnt);\n\t\t\tif (refcnt - cset->nr_tasks > 0) {\n\t\t\t\tint extra = refcnt - cset->nr_tasks;\n\n\t\t\t\tseq_printf(seq, \" +%d\", extra);\n\t\t\t\t \n\t\t\t\tif (cset == &init_css_set)\n\t\t\t\t\textra--;\n\t\t\t\textra_refs += extra;\n\t\t\t}\n\t\t}\n\t\tseq_puts(seq, \"\\n\");\n\n\t\tlist_for_each_entry(task, &cset->tasks, cg_list) {\n\t\t\tif (count++ <= MAX_TASKS_SHOWN_PER_CSS)\n\t\t\t\tseq_printf(seq, \"  task %d\\n\",\n\t\t\t\t\t   task_pid_vnr(task));\n\t\t}\n\n\t\tlist_for_each_entry(task, &cset->mg_tasks, cg_list) {\n\t\t\tif (count++ <= MAX_TASKS_SHOWN_PER_CSS)\n\t\t\t\tseq_printf(seq, \"  task %d\\n\",\n\t\t\t\t\t   task_pid_vnr(task));\n\t\t}\n\t\t \n\t\tif (count > MAX_TASKS_SHOWN_PER_CSS)\n\t\t\tseq_printf(seq, \"  ... (%d)\\n\",\n\t\t\t\t   count - MAX_TASKS_SHOWN_PER_CSS);\n\n\t\tif (cset->dead) {\n\t\t\tseq_puts(seq, \"    [dead]\\n\");\n\t\t\tdead_cnt++;\n\t\t}\n\n\t\tWARN_ON(count != cset->nr_tasks);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (!dead_cnt && !extra_refs && !threaded_csets)\n\t\treturn 0;\n\n\tseq_puts(seq, \"\\n\");\n\tif (threaded_csets)\n\t\tseq_printf(seq, \"threaded css_sets = %d\\n\", threaded_csets);\n\tif (extra_refs)\n\t\tseq_printf(seq, \"extra references = %d\\n\", extra_refs);\n\tif (dead_cnt)\n\t\tseq_printf(seq, \"dead css_sets = %d\\n\", dead_cnt);\n\n\treturn 0;\n}\n\nstatic int cgroup_subsys_states_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct cgroup *cgrp;\n\tstruct cgroup_subsys *ss;\n\tstruct cgroup_subsys_state *css;\n\tchar pbuf[16];\n\tint i;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tfor_each_subsys(ss, i) {\n\t\tcss = rcu_dereference_check(cgrp->subsys[ss->id], true);\n\t\tif (!css)\n\t\t\tcontinue;\n\n\t\tpbuf[0] = '\\0';\n\n\t\t \n\t\tif (css->parent)\n\t\t\tsnprintf(pbuf, sizeof(pbuf) - 1, \" P=%d\",\n\t\t\t\t css->parent->id);\n\t\tseq_printf(seq, \"%2d: %-4s\\t- %p[%d] %d%s\\n\", ss->id, ss->name,\n\t\t\t  css, css->id,\n\t\t\t  atomic_read(&css->online_cnt), pbuf);\n\t}\n\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}\n\nstatic void cgroup_masks_read_one(struct seq_file *seq, const char *name,\n\t\t\t\t  u16 mask)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\tbool first = true;\n\n\tseq_printf(seq, \"%-17s: \", name);\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(mask & (1 << ssid)))\n\t\t\tcontinue;\n\t\tif (!first)\n\t\t\tseq_puts(seq, \", \");\n\t\tseq_puts(seq, ss->name);\n\t\tfirst = false;\n\t}\n\tseq_putc(seq, '\\n');\n}\n\nstatic int cgroup_masks_read(struct seq_file *seq, void *v)\n{\n\tstruct kernfs_open_file *of = seq->private;\n\tstruct cgroup *cgrp;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\tcgroup_masks_read_one(seq, \"subtree_control\", cgrp->subtree_control);\n\tcgroup_masks_read_one(seq, \"subtree_ss_mask\", cgrp->subtree_ss_mask);\n\n\tcgroup_kn_unlock(of->kn);\n\treturn 0;\n}\n\nstatic u64 releasable_read(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\treturn (!cgroup_is_populated(css->cgroup) &&\n\t\t!css_has_online_children(&css->cgroup->self));\n}\n\nstatic struct cftype debug_legacy_files[] =  {\n\t{\n\t\t.name = \"taskcount\",\n\t\t.read_u64 = debug_taskcount_read,\n\t},\n\n\t{\n\t\t.name = \"current_css_set\",\n\t\t.seq_show = current_css_set_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_refcount\",\n\t\t.read_u64 = current_css_set_refcount_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_cg_links\",\n\t\t.seq_show = current_css_set_cg_links_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"cgroup_css_links\",\n\t\t.seq_show = cgroup_css_links_read,\n\t},\n\n\t{\n\t\t.name = \"cgroup_subsys_states\",\n\t\t.seq_show = cgroup_subsys_states_read,\n\t},\n\n\t{\n\t\t.name = \"cgroup_masks\",\n\t\t.seq_show = cgroup_masks_read,\n\t},\n\n\t{\n\t\t.name = \"releasable\",\n\t\t.read_u64 = releasable_read,\n\t},\n\n\t{ }\t \n};\n\nstatic struct cftype debug_files[] =  {\n\t{\n\t\t.name = \"taskcount\",\n\t\t.read_u64 = debug_taskcount_read,\n\t},\n\n\t{\n\t\t.name = \"current_css_set\",\n\t\t.seq_show = current_css_set_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_refcount\",\n\t\t.read_u64 = current_css_set_refcount_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"current_css_set_cg_links\",\n\t\t.seq_show = current_css_set_cg_links_read,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\n\t{\n\t\t.name = \"css_links\",\n\t\t.seq_show = cgroup_css_links_read,\n\t},\n\n\t{\n\t\t.name = \"csses\",\n\t\t.seq_show = cgroup_subsys_states_read,\n\t},\n\n\t{\n\t\t.name = \"masks\",\n\t\t.seq_show = cgroup_masks_read,\n\t},\n\n\t{ }\t \n};\n\nstruct cgroup_subsys debug_cgrp_subsys = {\n\t.css_alloc\t= debug_css_alloc,\n\t.css_free\t= debug_css_free,\n\t.legacy_cftypes\t= debug_legacy_files,\n};\n\n \nvoid __init enable_debug_cgroup(void)\n{\n\tdebug_cgrp_subsys.dfl_cftypes = debug_files;\n\tdebug_cgrp_subsys.implicit_on_dfl = true;\n\tdebug_cgrp_subsys.threaded = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}