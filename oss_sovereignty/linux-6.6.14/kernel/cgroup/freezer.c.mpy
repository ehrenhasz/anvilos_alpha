{
  "module_name": "freezer.c",
  "hash_id": "e968991ec0785e1131dae6cea4f665be1d0ea27d4fd986549f1832137221a355",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/freezer.c",
  "human_readable_source": "\n#include <linux/cgroup.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n\n#include \"cgroup-internal.h\"\n\n#include <trace/events/cgroup.h>\n\n \nstatic void cgroup_propagate_frozen(struct cgroup *cgrp, bool frozen)\n{\n\tint desc = 1;\n\n\t \n\twhile ((cgrp = cgroup_parent(cgrp))) {\n\t\tif (frozen) {\n\t\t\tcgrp->freezer.nr_frozen_descendants += desc;\n\t\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags) &&\n\t\t\t    test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\t\t    cgrp->freezer.nr_frozen_descendants ==\n\t\t\t    cgrp->nr_descendants) {\n\t\t\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 1);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t} else {\n\t\t\tcgrp->freezer.nr_frozen_descendants -= desc;\n\t\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags)) {\n\t\t\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t\t\t\tcgroup_file_notify(&cgrp->events_file);\n\t\t\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp, 0);\n\t\t\t\tdesc++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid cgroup_update_frozen(struct cgroup *cgrp)\n{\n\tbool frozen;\n\n\tlockdep_assert_held(&css_set_lock);\n\n\t \n\tfrozen = test_bit(CGRP_FREEZE, &cgrp->flags) &&\n\t\tcgrp->freezer.nr_frozen_tasks == __cgroup_task_count(cgrp);\n\n\tif (frozen) {\n\t\t \n\t\tif (test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tset_bit(CGRP_FROZEN, &cgrp->flags);\n\t} else {\n\t\t \n\t\tif (!test_bit(CGRP_FROZEN, &cgrp->flags))\n\t\t\treturn;\n\n\t\tclear_bit(CGRP_FROZEN, &cgrp->flags);\n\t}\n\tcgroup_file_notify(&cgrp->events_file);\n\tTRACE_CGROUP_PATH(notify_frozen, cgrp, frozen);\n\n\t \n\tcgroup_propagate_frozen(cgrp, frozen);\n}\n\n \nstatic void cgroup_inc_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks++;\n}\n\n \nstatic void cgroup_dec_frozen_cnt(struct cgroup *cgrp)\n{\n\tcgrp->freezer.nr_frozen_tasks--;\n\tWARN_ON_ONCE(cgrp->freezer.nr_frozen_tasks < 0);\n}\n\n \nvoid cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}\n\n \nvoid cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}\n\n \nstatic void cgroup_freeze_task(struct task_struct *task, bool freeze)\n{\n\tunsigned long flags;\n\n\t \n\tif (!lock_task_sighand(task, &flags))\n\t\treturn;\n\n\tif (freeze) {\n\t\ttask->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tsignal_wake_up(task, false);\n\t} else {\n\t\ttask->jobctl &= ~JOBCTL_TRAP_FREEZE;\n\t\twake_up_process(task);\n\t}\n\n\tunlock_task_sighand(task, &flags);\n}\n\n \nstatic void cgroup_do_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tspin_lock_irq(&css_set_lock);\n\tif (freeze)\n\t\tset_bit(CGRP_FREEZE, &cgrp->flags);\n\telse\n\t\tclear_bit(CGRP_FREEZE, &cgrp->flags);\n\tspin_unlock_irq(&css_set_lock);\n\n\tif (freeze)\n\t\tTRACE_CGROUP_PATH(freeze, cgrp);\n\telse\n\t\tTRACE_CGROUP_PATH(unfreeze, cgrp);\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\t \n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tcgroup_freeze_task(task, freeze);\n\t}\n\tcss_task_iter_end(&it);\n\n\t \n\tspin_lock_irq(&css_set_lock);\n\tif (cgrp->nr_descendants == cgrp->freezer.nr_frozen_descendants)\n\t\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}\n\n \nvoid cgroup_freezer_migrate_task(struct task_struct *task,\n\t\t\t\t struct cgroup *src, struct cgroup *dst)\n{\n\tlockdep_assert_held(&css_set_lock);\n\n\t \n\tif (task->flags & PF_KTHREAD)\n\t\treturn;\n\n\t \n\tif (!test_bit(CGRP_FREEZE, &src->flags) &&\n\t    !test_bit(CGRP_FREEZE, &dst->flags) &&\n\t    !task->frozen)\n\t\treturn;\n\n\t \n\tif (task->frozen) {\n\t\tcgroup_inc_frozen_cnt(dst);\n\t\tcgroup_dec_frozen_cnt(src);\n\t}\n\tcgroup_update_frozen(dst);\n\tcgroup_update_frozen(src);\n\n\t \n\tcgroup_freeze_task(task, test_bit(CGRP_FREEZE, &dst->flags));\n}\n\nvoid cgroup_freeze(struct cgroup *cgrp, bool freeze)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cgroup *dsct;\n\tbool applied = false;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\t \n\tif (cgrp->freezer.freeze == freeze)\n\t\treturn;\n\n\tcgrp->freezer.freeze = freeze;\n\n\t \n\tcss_for_each_descendant_pre(css, &cgrp->self) {\n\t\tdsct = css->cgroup;\n\n\t\tif (cgroup_is_dead(dsct))\n\t\t\tcontinue;\n\n\t\tif (freeze) {\n\t\t\tdsct->freezer.e_freeze++;\n\t\t\t \n\t\t\tif (dsct->freezer.e_freeze > 1)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tdsct->freezer.e_freeze--;\n\t\t\t \n\t\t\tif (dsct->freezer.e_freeze > 0)\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(dsct->freezer.e_freeze < 0);\n\t\t}\n\n\t\t \n\t\tcgroup_do_freeze(dsct, freeze);\n\t\tapplied = true;\n\t}\n\n\t \n\tif (!applied) {\n\t\tTRACE_CGROUP_PATH(notify_frozen, cgrp,\n\t\t\t\t  test_bit(CGRP_FROZEN, &cgrp->flags));\n\t\tcgroup_file_notify(&cgrp->events_file);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}