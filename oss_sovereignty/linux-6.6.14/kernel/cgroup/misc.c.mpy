{
  "module_name": "misc.c",
  "hash_id": "53e4d0507cdd02640bff5b26eed783112e73820ea867f9e4a3ae06d4bc9a1875",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/misc.c",
  "human_readable_source": "\n \n\n#include <linux/limits.h>\n#include <linux/cgroup.h>\n#include <linux/errno.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/misc_cgroup.h>\n\n#define MAX_STR \"max\"\n#define MAX_NUM U64_MAX\n\n \nstatic const char *const misc_res_name[] = {\n#ifdef CONFIG_KVM_AMD_SEV\n\t \n\t\"sev\",\n\t \n\t\"sev_es\",\n#endif\n};\n\n \nstatic struct misc_cg root_cg;\n\n \nstatic u64 misc_res_capacity[MISC_CG_RES_TYPES];\n\n \nstatic struct misc_cg *parent_misc(struct misc_cg *cgroup)\n{\n\treturn cgroup ? css_misc(cgroup->css.parent) : NULL;\n}\n\n \nstatic inline bool valid_type(enum misc_res_type type)\n{\n\treturn type >= 0 && type < MISC_CG_RES_TYPES;\n}\n\n \nu64 misc_cg_res_total_usage(enum misc_res_type type)\n{\n\tif (valid_type(type))\n\t\treturn atomic64_read(&root_cg.res[type].usage);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(misc_cg_res_total_usage);\n\n \nint misc_cg_set_capacity(enum misc_res_type type, u64 capacity)\n{\n\tif (!valid_type(type))\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(misc_res_capacity[type], capacity);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(misc_cg_set_capacity);\n\n \nstatic void misc_cg_cancel_charge(enum misc_res_type type, struct misc_cg *cg,\n\t\t\t\t  u64 amount)\n{\n\tWARN_ONCE(atomic64_add_negative(-amount, &cg->res[type].usage),\n\t\t  \"misc cgroup resource %s became less than 0\",\n\t\t  misc_res_name[type]);\n}\n\n \nint misc_cg_try_charge(enum misc_res_type type, struct misc_cg *cg, u64 amount)\n{\n\tstruct misc_cg *i, *j;\n\tint ret;\n\tstruct misc_res *res;\n\tu64 new_usage;\n\n\tif (!(valid_type(type) && cg && READ_ONCE(misc_res_capacity[type])))\n\t\treturn -EINVAL;\n\n\tif (!amount)\n\t\treturn 0;\n\n\tfor (i = cg; i; i = parent_misc(i)) {\n\t\tres = &i->res[type];\n\n\t\tnew_usage = atomic64_add_return(amount, &res->usage);\n\t\tif (new_usage > READ_ONCE(res->max) ||\n\t\t    new_usage > READ_ONCE(misc_res_capacity[type])) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_charge;\n\t\t}\n\t}\n\treturn 0;\n\nerr_charge:\n\tfor (j = i; j; j = parent_misc(j)) {\n\t\tatomic64_inc(&j->res[type].events);\n\t\tcgroup_file_notify(&j->events_file);\n\t}\n\n\tfor (j = cg; j != i; j = parent_misc(j))\n\t\tmisc_cg_cancel_charge(type, j, amount);\n\tmisc_cg_cancel_charge(type, i, amount);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(misc_cg_try_charge);\n\n \nvoid misc_cg_uncharge(enum misc_res_type type, struct misc_cg *cg, u64 amount)\n{\n\tstruct misc_cg *i;\n\n\tif (!(amount && valid_type(type) && cg))\n\t\treturn;\n\n\tfor (i = cg; i; i = parent_misc(i))\n\t\tmisc_cg_cancel_charge(type, i, amount);\n}\nEXPORT_SYMBOL_GPL(misc_cg_uncharge);\n\n \nstatic int misc_cg_max_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\tu64 max;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tif (READ_ONCE(misc_res_capacity[i])) {\n\t\t\tmax = READ_ONCE(cg->res[i].max);\n\t\t\tif (max == MAX_NUM)\n\t\t\t\tseq_printf(sf, \"%s max\\n\", misc_res_name[i]);\n\t\t\telse\n\t\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i],\n\t\t\t\t\t   max);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t misc_cg_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t size_t nbytes, loff_t off)\n{\n\tstruct misc_cg *cg;\n\tu64 max;\n\tint ret = 0, i;\n\tenum misc_res_type type = MISC_CG_RES_TYPES;\n\tchar *token;\n\n\tbuf = strstrip(buf);\n\ttoken = strsep(&buf, \" \");\n\n\tif (!token || !buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tif (!strcmp(misc_res_name[i], token)) {\n\t\t\ttype = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == MISC_CG_RES_TYPES)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(MAX_STR, buf)) {\n\t\tmax = MAX_NUM;\n\t} else {\n\t\tret = kstrtou64(buf, 0, &max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcg = css_misc(of_css(of));\n\n\tif (READ_ONCE(misc_res_capacity[type]))\n\t\tWRITE_ONCE(cg->res[type].max, max);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret ? ret : nbytes;\n}\n\n \nstatic int misc_cg_current_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tu64 usage;\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tusage = atomic64_read(&cg->res[i].usage);\n\t\tif (READ_ONCE(misc_res_capacity[i]) || usage)\n\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], usage);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int misc_cg_capacity_show(struct seq_file *sf, void *v)\n{\n\tint i;\n\tu64 cap;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tcap = READ_ONCE(misc_res_capacity[i]);\n\t\tif (cap)\n\t\t\tseq_printf(sf, \"%s %llu\\n\", misc_res_name[i], cap);\n\t}\n\n\treturn 0;\n}\n\nstatic int misc_events_show(struct seq_file *sf, void *v)\n{\n\tstruct misc_cg *cg = css_misc(seq_css(sf));\n\tu64 events;\n\tint i;\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tevents = atomic64_read(&cg->res[i].events);\n\t\tif (READ_ONCE(misc_res_capacity[i]) || events)\n\t\t\tseq_printf(sf, \"%s.max %llu\\n\", misc_res_name[i], events);\n\t}\n\treturn 0;\n}\n\n \nstatic struct cftype misc_cg_files[] = {\n\t{\n\t\t.name = \"max\",\n\t\t.write = misc_cg_max_write,\n\t\t.seq_show = misc_cg_max_show,\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t},\n\t{\n\t\t.name = \"current\",\n\t\t.seq_show = misc_cg_current_show,\n\t},\n\t{\n\t\t.name = \"capacity\",\n\t\t.seq_show = misc_cg_capacity_show,\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t},\n\t{\n\t\t.name = \"events\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.file_offset = offsetof(struct misc_cg, events_file),\n\t\t.seq_show = misc_events_show,\n\t},\n\t{}\n};\n\n \nstatic struct cgroup_subsys_state *\nmisc_cg_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tenum misc_res_type i;\n\tstruct misc_cg *cg;\n\n\tif (!parent_css) {\n\t\tcg = &root_cg;\n\t} else {\n\t\tcg = kzalloc(sizeof(*cg), GFP_KERNEL);\n\t\tif (!cg)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfor (i = 0; i < MISC_CG_RES_TYPES; i++) {\n\t\tWRITE_ONCE(cg->res[i].max, MAX_NUM);\n\t\tatomic64_set(&cg->res[i].usage, 0);\n\t}\n\n\treturn &cg->css;\n}\n\n \nstatic void misc_cg_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_misc(css));\n}\n\n \nstruct cgroup_subsys misc_cgrp_subsys = {\n\t.css_alloc = misc_cg_alloc,\n\t.css_free = misc_cg_free,\n\t.legacy_cftypes = misc_cg_files,\n\t.dfl_cftypes = misc_cg_files,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}