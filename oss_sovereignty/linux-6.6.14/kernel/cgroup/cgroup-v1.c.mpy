{
  "module_name": "cgroup-v1.c",
  "hash_id": "5b5dfa8363d7e13044104432e9e4c9be5bb5ebc6dd87ba5be4781e9d56efcbb6",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/cgroup-v1.c",
  "human_readable_source": "\n#include \"cgroup-internal.h\"\n\n#include <linux/ctype.h>\n#include <linux/kmod.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/delayacct.h>\n#include <linux/pid_namespace.h>\n#include <linux/cgroupstats.h>\n#include <linux/fs_parser.h>\n\n#include <trace/events/cgroup.h>\n\n \n#define CGROUP_PIDLIST_DESTROY_DELAY\tHZ\n\n \nstatic u16 cgroup_no_v1_mask;\n\n \nstatic bool cgroup_no_v1_named;\n\n \nstatic struct workqueue_struct *cgroup_pidlist_destroy_wq;\n\n \nstatic DEFINE_SPINLOCK(release_agent_path_lock);\n\nbool cgroup1_ssid_disabled(int ssid)\n{\n\treturn cgroup_no_v1_mask & (1 << ssid);\n}\n\n \nint cgroup_attach_task_all(struct task_struct *from, struct task_struct *tsk)\n{\n\tstruct cgroup_root *root;\n\tint retval = 0;\n\n\tcgroup_lock();\n\tcgroup_attach_lock(true);\n\tfor_each_root(root) {\n\t\tstruct cgroup *from_cgrp;\n\n\t\tspin_lock_irq(&css_set_lock);\n\t\tfrom_cgrp = task_cgroup_from_root(from, root);\n\t\tspin_unlock_irq(&css_set_lock);\n\n\t\tretval = cgroup_attach_task(from_cgrp, tsk, false);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\tcgroup_attach_unlock(true);\n\tcgroup_unlock();\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(cgroup_attach_task_all);\n\n \nint cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgrp_cset_link *link;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\tint ret;\n\n\tif (cgroup_on_dfl(to))\n\t\treturn -EINVAL;\n\n\tret = cgroup_migrate_vet_dst(to);\n\tif (ret)\n\t\treturn ret;\n\n\tcgroup_lock();\n\n\tcgroup_attach_lock(true);\n\n\t \n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &from->cset_links, cset_link)\n\t\tcgroup_migrate_add_src(link->cset, to, &mgctx);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tdo {\n\t\tcss_task_iter_start(&from->self, 0, &it);\n\n\t\tdo {\n\t\t\ttask = css_task_iter_next(&it);\n\t\t} while (task && (task->flags & PF_EXITING));\n\n\t\tif (task)\n\t\t\tget_task_struct(task);\n\t\tcss_task_iter_end(&it);\n\n\t\tif (task) {\n\t\t\tret = cgroup_migrate(task, false, &mgctx);\n\t\t\tif (!ret)\n\t\t\t\tTRACE_CGROUP_PATH(transfer_tasks, to, task, false);\n\t\t\tput_task_struct(task);\n\t\t}\n\t} while (task && !ret);\nout_err:\n\tcgroup_migrate_finish(&mgctx);\n\tcgroup_attach_unlock(true);\n\tcgroup_unlock();\n\treturn ret;\n}\n\n \n\n \nenum cgroup_filetype {\n\tCGROUP_FILE_PROCS,\n\tCGROUP_FILE_TASKS,\n};\n\n \nstruct cgroup_pidlist {\n\t \n\tstruct { enum cgroup_filetype type; struct pid_namespace *ns; } key;\n\t \n\tpid_t *list;\n\t \n\tint length;\n\t \n\tstruct list_head links;\n\t \n\tstruct cgroup *owner;\n\t \n\tstruct delayed_work destroy_dwork;\n};\n\n \nvoid cgroup1_pidlist_destroy_all(struct cgroup *cgrp)\n{\n\tstruct cgroup_pidlist *l, *tmp_l;\n\n\tmutex_lock(&cgrp->pidlist_mutex);\n\tlist_for_each_entry_safe(l, tmp_l, &cgrp->pidlists, links)\n\t\tmod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork, 0);\n\tmutex_unlock(&cgrp->pidlist_mutex);\n\n\tflush_workqueue(cgroup_pidlist_destroy_wq);\n\tBUG_ON(!list_empty(&cgrp->pidlists));\n}\n\nstatic void cgroup_pidlist_destroy_work_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct cgroup_pidlist *l = container_of(dwork, struct cgroup_pidlist,\n\t\t\t\t\t\tdestroy_dwork);\n\tstruct cgroup_pidlist *tofree = NULL;\n\n\tmutex_lock(&l->owner->pidlist_mutex);\n\n\t \n\tif (!delayed_work_pending(dwork)) {\n\t\tlist_del(&l->links);\n\t\tkvfree(l->list);\n\t\tput_pid_ns(l->key.ns);\n\t\ttofree = l;\n\t}\n\n\tmutex_unlock(&l->owner->pidlist_mutex);\n\tkfree(tofree);\n}\n\n \nstatic int pidlist_uniq(pid_t *list, int length)\n{\n\tint src, dest = 1;\n\n\t \n\tif (length == 0 || length == 1)\n\t\treturn length;\n\t \n\tfor (src = 1; src < length; src++) {\n\t\t \n\t\twhile (list[src] == list[src-1]) {\n\t\t\tsrc++;\n\t\t\tif (src == length)\n\t\t\t\tgoto after;\n\t\t}\n\t\t \n\t\tlist[dest] = list[src];\n\t\tdest++;\n\t}\nafter:\n\treturn dest;\n}\n\n \nstatic int cmppid(const void *a, const void *b)\n{\n\treturn *(pid_t *)a - *(pid_t *)b;\n}\n\nstatic struct cgroup_pidlist *cgroup_pidlist_find(struct cgroup *cgrp,\n\t\t\t\t\t\t  enum cgroup_filetype type)\n{\n\tstruct cgroup_pidlist *l;\n\t \n\tstruct pid_namespace *ns = task_active_pid_ns(current);\n\n\tlockdep_assert_held(&cgrp->pidlist_mutex);\n\n\tlist_for_each_entry(l, &cgrp->pidlists, links)\n\t\tif (l->key.type == type && l->key.ns == ns)\n\t\t\treturn l;\n\treturn NULL;\n}\n\n \nstatic struct cgroup_pidlist *cgroup_pidlist_find_create(struct cgroup *cgrp,\n\t\t\t\t\t\tenum cgroup_filetype type)\n{\n\tstruct cgroup_pidlist *l;\n\n\tlockdep_assert_held(&cgrp->pidlist_mutex);\n\n\tl = cgroup_pidlist_find(cgrp, type);\n\tif (l)\n\t\treturn l;\n\n\t \n\tl = kzalloc(sizeof(struct cgroup_pidlist), GFP_KERNEL);\n\tif (!l)\n\t\treturn l;\n\n\tINIT_DELAYED_WORK(&l->destroy_dwork, cgroup_pidlist_destroy_work_fn);\n\tl->key.type = type;\n\t \n\tl->key.ns = get_pid_ns(task_active_pid_ns(current));\n\tl->owner = cgrp;\n\tlist_add(&l->links, &cgrp->pidlists);\n\treturn l;\n}\n\n \nstatic int pidlist_array_load(struct cgroup *cgrp, enum cgroup_filetype type,\n\t\t\t      struct cgroup_pidlist **lp)\n{\n\tpid_t *array;\n\tint length;\n\tint pid, n = 0;  \n\tstruct css_task_iter it;\n\tstruct task_struct *tsk;\n\tstruct cgroup_pidlist *l;\n\n\tlockdep_assert_held(&cgrp->pidlist_mutex);\n\n\t \n\tlength = cgroup_task_count(cgrp);\n\tarray = kvmalloc_array(length, sizeof(pid_t), GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\t \n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((tsk = css_task_iter_next(&it))) {\n\t\tif (unlikely(n == length))\n\t\t\tbreak;\n\t\t \n\t\tif (type == CGROUP_FILE_PROCS)\n\t\t\tpid = task_tgid_vnr(tsk);\n\t\telse\n\t\t\tpid = task_pid_vnr(tsk);\n\t\tif (pid > 0)  \n\t\t\tarray[n++] = pid;\n\t}\n\tcss_task_iter_end(&it);\n\tlength = n;\n\t \n\tsort(array, length, sizeof(pid_t), cmppid, NULL);\n\tlength = pidlist_uniq(array, length);\n\n\tl = cgroup_pidlist_find_create(cgrp, type);\n\tif (!l) {\n\t\tkvfree(array);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tkvfree(l->list);\n\tl->list = array;\n\tl->length = length;\n\t*lp = l;\n\treturn 0;\n}\n\n \n\nstatic void *cgroup_pidlist_start(struct seq_file *s, loff_t *pos)\n{\n\t \n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup *cgrp = seq_css(s)->cgroup;\n\tstruct cgroup_pidlist *l;\n\tenum cgroup_filetype type = seq_cft(s)->private;\n\tint index = 0, pid = *pos;\n\tint *iter, ret;\n\n\tmutex_lock(&cgrp->pidlist_mutex);\n\n\t \n\tif (ctx->procs1.pidlist)\n\t\tctx->procs1.pidlist = cgroup_pidlist_find(cgrp, type);\n\n\t \n\tif (!ctx->procs1.pidlist) {\n\t\tret = pidlist_array_load(cgrp, type, &ctx->procs1.pidlist);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tl = ctx->procs1.pidlist;\n\n\tif (pid) {\n\t\tint end = l->length;\n\n\t\twhile (index < end) {\n\t\t\tint mid = (index + end) / 2;\n\t\t\tif (l->list[mid] == pid) {\n\t\t\t\tindex = mid;\n\t\t\t\tbreak;\n\t\t\t} else if (l->list[mid] < pid)\n\t\t\t\tindex = mid + 1;\n\t\t\telse\n\t\t\t\tend = mid;\n\t\t}\n\t}\n\t \n\tif (index >= l->length)\n\t\treturn NULL;\n\t \n\titer = l->list + index;\n\t*pos = *iter;\n\treturn iter;\n}\n\nstatic void cgroup_pidlist_stop(struct seq_file *s, void *v)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup_pidlist *l = ctx->procs1.pidlist;\n\n\tif (l)\n\t\tmod_delayed_work(cgroup_pidlist_destroy_wq, &l->destroy_dwork,\n\t\t\t\t CGROUP_PIDLIST_DESTROY_DELAY);\n\tmutex_unlock(&seq_css(s)->cgroup->pidlist_mutex);\n}\n\nstatic void *cgroup_pidlist_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct kernfs_open_file *of = s->private;\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\tstruct cgroup_pidlist *l = ctx->procs1.pidlist;\n\tpid_t *p = v;\n\tpid_t *end = l->list + l->length;\n\t \n\tp++;\n\tif (p >= end) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t} else {\n\t\t*pos = *p;\n\t\treturn p;\n\t}\n}\n\nstatic int cgroup_pidlist_show(struct seq_file *s, void *v)\n{\n\tseq_printf(s, \"%d\\n\", *(int *)v);\n\n\treturn 0;\n}\n\nstatic ssize_t __cgroup1_procs_write(struct kernfs_open_file *of,\n\t\t\t\t     char *buf, size_t nbytes, loff_t off,\n\t\t\t\t     bool threadgroup)\n{\n\tstruct cgroup *cgrp;\n\tstruct task_struct *task;\n\tconst struct cred *cred, *tcred;\n\tssize_t ret;\n\tbool locked;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\n\ttask = cgroup_procs_write_start(buf, threadgroup, &locked);\n\tret = PTR_ERR_OR_ZERO(task);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tcred = of->file->f_cred;\n\ttcred = get_task_cred(task);\n\tif (!uid_eq(cred->euid, GLOBAL_ROOT_UID) &&\n\t    !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->euid, tcred->suid))\n\t\tret = -EACCES;\n\tput_cred(tcred);\n\tif (ret)\n\t\tgoto out_finish;\n\n\tret = cgroup_attach_task(cgrp, task, threadgroup);\n\nout_finish:\n\tcgroup_procs_write_finish(task, locked);\nout_unlock:\n\tcgroup_kn_unlock(of->kn);\n\n\treturn ret ?: nbytes;\n}\n\nstatic ssize_t cgroup1_procs_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\treturn __cgroup1_procs_write(of, buf, nbytes, off, true);\n}\n\nstatic ssize_t cgroup1_tasks_write(struct kernfs_open_file *of,\n\t\t\t\t   char *buf, size_t nbytes, loff_t off)\n{\n\treturn __cgroup1_procs_write(of, buf, nbytes, off, false);\n}\n\nstatic ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tstruct cgroup_file_ctx *ctx;\n\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\n\t \n\tctx = of->priv;\n\tif ((ctx->ns->user_ns != &init_user_ns) ||\n\t    !file_ns_capable(of->file, &init_user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrscpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}\n\nstatic int cgroup_release_agent_show(struct seq_file *seq, void *v)\n{\n\tstruct cgroup *cgrp = seq_css(seq)->cgroup;\n\n\tspin_lock(&release_agent_path_lock);\n\tseq_puts(seq, cgrp->root->release_agent_path);\n\tspin_unlock(&release_agent_path_lock);\n\tseq_putc(seq, '\\n');\n\treturn 0;\n}\n\nstatic int cgroup_sane_behavior_show(struct seq_file *seq, void *v)\n{\n\tseq_puts(seq, \"0\\n\");\n\treturn 0;\n}\n\nstatic u64 cgroup_read_notify_on_release(struct cgroup_subsys_state *css,\n\t\t\t\t\t struct cftype *cft)\n{\n\treturn notify_on_release(css->cgroup);\n}\n\nstatic int cgroup_write_notify_on_release(struct cgroup_subsys_state *css,\n\t\t\t\t\t  struct cftype *cft, u64 val)\n{\n\tif (val)\n\t\tset_bit(CGRP_NOTIFY_ON_RELEASE, &css->cgroup->flags);\n\telse\n\t\tclear_bit(CGRP_NOTIFY_ON_RELEASE, &css->cgroup->flags);\n\treturn 0;\n}\n\nstatic u64 cgroup_clone_children_read(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft)\n{\n\treturn test_bit(CGRP_CPUSET_CLONE_CHILDREN, &css->cgroup->flags);\n}\n\nstatic int cgroup_clone_children_write(struct cgroup_subsys_state *css,\n\t\t\t\t       struct cftype *cft, u64 val)\n{\n\tif (val)\n\t\tset_bit(CGRP_CPUSET_CLONE_CHILDREN, &css->cgroup->flags);\n\telse\n\t\tclear_bit(CGRP_CPUSET_CLONE_CHILDREN, &css->cgroup->flags);\n\treturn 0;\n}\n\n \nstruct cftype cgroup1_base_files[] = {\n\t{\n\t\t.name = \"cgroup.procs\",\n\t\t.seq_start = cgroup_pidlist_start,\n\t\t.seq_next = cgroup_pidlist_next,\n\t\t.seq_stop = cgroup_pidlist_stop,\n\t\t.seq_show = cgroup_pidlist_show,\n\t\t.private = CGROUP_FILE_PROCS,\n\t\t.write = cgroup1_procs_write,\n\t},\n\t{\n\t\t.name = \"cgroup.clone_children\",\n\t\t.read_u64 = cgroup_clone_children_read,\n\t\t.write_u64 = cgroup_clone_children_write,\n\t},\n\t{\n\t\t.name = \"cgroup.sane_behavior\",\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t\t.seq_show = cgroup_sane_behavior_show,\n\t},\n\t{\n\t\t.name = \"tasks\",\n\t\t.seq_start = cgroup_pidlist_start,\n\t\t.seq_next = cgroup_pidlist_next,\n\t\t.seq_stop = cgroup_pidlist_stop,\n\t\t.seq_show = cgroup_pidlist_show,\n\t\t.private = CGROUP_FILE_TASKS,\n\t\t.write = cgroup1_tasks_write,\n\t},\n\t{\n\t\t.name = \"notify_on_release\",\n\t\t.read_u64 = cgroup_read_notify_on_release,\n\t\t.write_u64 = cgroup_write_notify_on_release,\n\t},\n\t{\n\t\t.name = \"release_agent\",\n\t\t.flags = CFTYPE_ONLY_ON_ROOT,\n\t\t.seq_show = cgroup_release_agent_show,\n\t\t.write = cgroup_release_agent_write,\n\t\t.max_write_len = PATH_MAX - 1,\n\t},\n\t{ }\t \n};\n\n \nint proc_cgroupstats_show(struct seq_file *m, void *v)\n{\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n\tseq_puts(m, \"#subsys_name\\thierarchy\\tnum_cgroups\\tenabled\\n\");\n\t \n\n\tfor_each_subsys(ss, i)\n\t\tseq_printf(m, \"%s\\t%d\\t%d\\t%d\\n\",\n\t\t\t   ss->legacy_name, ss->root->hierarchy_id,\n\t\t\t   atomic_read(&ss->root->nr_cgrps),\n\t\t\t   cgroup_ssid_enabled(i));\n\n\treturn 0;\n}\n\n \nint cgroupstats_build(struct cgroupstats *stats, struct dentry *dentry)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct cgroup *cgrp;\n\tstruct css_task_iter it;\n\tstruct task_struct *tsk;\n\n\t \n\tif (dentry->d_sb->s_type != &cgroup_fs_type || !kn ||\n\t    kernfs_type(kn) != KERNFS_DIR)\n\t\treturn -EINVAL;\n\n\t \n\trcu_read_lock();\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (!cgrp || !cgroup_tryget(cgrp)) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((tsk = css_task_iter_next(&it))) {\n\t\tswitch (READ_ONCE(tsk->__state)) {\n\t\tcase TASK_RUNNING:\n\t\t\tstats->nr_running++;\n\t\t\tbreak;\n\t\tcase TASK_INTERRUPTIBLE:\n\t\t\tstats->nr_sleeping++;\n\t\t\tbreak;\n\t\tcase TASK_UNINTERRUPTIBLE:\n\t\t\tstats->nr_uninterruptible++;\n\t\t\tbreak;\n\t\tcase TASK_STOPPED:\n\t\t\tstats->nr_stopped++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (tsk->in_iowait)\n\t\t\t\tstats->nr_io_wait++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcss_task_iter_end(&it);\n\n\tcgroup_put(cgrp);\n\treturn 0;\n}\n\nvoid cgroup1_check_for_release(struct cgroup *cgrp)\n{\n\tif (notify_on_release(cgrp) && !cgroup_is_populated(cgrp) &&\n\t    !css_has_online_children(&cgrp->self) && !cgroup_is_dead(cgrp))\n\t\tschedule_work(&cgrp->release_agent_work);\n}\n\n \nvoid cgroup1_release_agent(struct work_struct *work)\n{\n\tstruct cgroup *cgrp =\n\t\tcontainer_of(work, struct cgroup, release_agent_work);\n\tchar *pathbuf, *agentbuf;\n\tchar *argv[3], *envp[3];\n\tint ret;\n\n\t \n\tif (!cgrp->root->release_agent_path[0])\n\t\treturn;\n\n\t \n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tagentbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf || !agentbuf)\n\t\tgoto out_free;\n\n\tspin_lock(&release_agent_path_lock);\n\tstrscpy(agentbuf, cgrp->root->release_agent_path, PATH_MAX);\n\tspin_unlock(&release_agent_path_lock);\n\tif (!agentbuf[0])\n\t\tgoto out_free;\n\n\tret = cgroup_path_ns(cgrp, pathbuf, PATH_MAX, &init_cgroup_ns);\n\tif (ret < 0 || ret >= PATH_MAX)\n\t\tgoto out_free;\n\n\targv[0] = agentbuf;\n\targv[1] = pathbuf;\n\targv[2] = NULL;\n\n\t \n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tcall_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\nout_free:\n\tkfree(agentbuf);\n\tkfree(pathbuf);\n}\n\n \nstatic int cgroup1_rename(struct kernfs_node *kn, struct kernfs_node *new_parent,\n\t\t\t  const char *new_name_str)\n{\n\tstruct cgroup *cgrp = kn->priv;\n\tint ret;\n\n\t \n\tif (strchr(new_name_str, '\\n'))\n\t\treturn -EINVAL;\n\n\tif (kernfs_type(kn) != KERNFS_DIR)\n\t\treturn -ENOTDIR;\n\tif (kn->parent != new_parent)\n\t\treturn -EIO;\n\n\t \n\tkernfs_break_active_protection(new_parent);\n\tkernfs_break_active_protection(kn);\n\n\tcgroup_lock();\n\n\tret = kernfs_rename(kn, new_parent, new_name_str);\n\tif (!ret)\n\t\tTRACE_CGROUP_PATH(rename, cgrp);\n\n\tcgroup_unlock();\n\n\tkernfs_unbreak_active_protection(kn);\n\tkernfs_unbreak_active_protection(new_parent);\n\treturn ret;\n}\n\nstatic int cgroup1_show_options(struct seq_file *seq, struct kernfs_root *kf_root)\n{\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tfor_each_subsys(ss, ssid)\n\t\tif (root->subsys_mask & (1 << ssid))\n\t\t\tseq_show_option(seq, ss->legacy_name, NULL);\n\tif (root->flags & CGRP_ROOT_NOPREFIX)\n\t\tseq_puts(seq, \",noprefix\");\n\tif (root->flags & CGRP_ROOT_XATTR)\n\t\tseq_puts(seq, \",xattr\");\n\tif (root->flags & CGRP_ROOT_CPUSET_V2_MODE)\n\t\tseq_puts(seq, \",cpuset_v2_mode\");\n\tif (root->flags & CGRP_ROOT_FAVOR_DYNMODS)\n\t\tseq_puts(seq, \",favordynmods\");\n\n\tspin_lock(&release_agent_path_lock);\n\tif (strlen(root->release_agent_path))\n\t\tseq_show_option(seq, \"release_agent\",\n\t\t\t\troot->release_agent_path);\n\tspin_unlock(&release_agent_path_lock);\n\n\tif (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &root->cgrp.flags))\n\t\tseq_puts(seq, \",clone_children\");\n\tif (strlen(root->name))\n\t\tseq_show_option(seq, \"name\", root->name);\n\treturn 0;\n}\n\nenum cgroup1_param {\n\tOpt_all,\n\tOpt_clone_children,\n\tOpt_cpuset_v2_mode,\n\tOpt_name,\n\tOpt_none,\n\tOpt_noprefix,\n\tOpt_release_agent,\n\tOpt_xattr,\n\tOpt_favordynmods,\n\tOpt_nofavordynmods,\n};\n\nconst struct fs_parameter_spec cgroup1_fs_parameters[] = {\n\tfsparam_flag  (\"all\",\t\tOpt_all),\n\tfsparam_flag  (\"clone_children\", Opt_clone_children),\n\tfsparam_flag  (\"cpuset_v2_mode\", Opt_cpuset_v2_mode),\n\tfsparam_string(\"name\",\t\tOpt_name),\n\tfsparam_flag  (\"none\",\t\tOpt_none),\n\tfsparam_flag  (\"noprefix\",\tOpt_noprefix),\n\tfsparam_string(\"release_agent\",\tOpt_release_agent),\n\tfsparam_flag  (\"xattr\",\t\tOpt_xattr),\n\tfsparam_flag  (\"favordynmods\",\tOpt_favordynmods),\n\tfsparam_flag  (\"nofavordynmods\", Opt_nofavordynmods),\n\t{}\n};\n\nint cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct cgroup_subsys *ss;\n\tstruct fs_parse_result result;\n\tint opt, i;\n\n\topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);\n\tif (opt == -ENOPARAM) {\n\t\tint ret;\n\n\t\tret = vfs_parse_fs_param_source(fc, param);\n\t\tif (ret != -ENOPARAM)\n\t\t\treturn ret;\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(param->key, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))\n\t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",\n\t\t\t\t\t       param->key);\n\t\t\tctx->subsys_mask |= (1 << i);\n\t\t\treturn 0;\n\t\t}\n\t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);\n\t}\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_none:\n\t\t \n\t\tctx->none = true;\n\t\tbreak;\n\tcase Opt_all:\n\t\tctx->all_ss = true;\n\t\tbreak;\n\tcase Opt_noprefix:\n\t\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\t\tbreak;\n\tcase Opt_clone_children:\n\t\tctx->cpuset_clone_children = true;\n\t\tbreak;\n\tcase Opt_cpuset_v2_mode:\n\t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;\n\t\tbreak;\n\tcase Opt_xattr:\n\t\tctx->flags |= CGRP_ROOT_XATTR;\n\t\tbreak;\n\tcase Opt_favordynmods:\n\t\tctx->flags |= CGRP_ROOT_FAVOR_DYNMODS;\n\t\tbreak;\n\tcase Opt_nofavordynmods:\n\t\tctx->flags &= ~CGRP_ROOT_FAVOR_DYNMODS;\n\t\tbreak;\n\tcase Opt_release_agent:\n\t\t \n\t\tif (ctx->release_agent)\n\t\t\treturn invalfc(fc, \"release_agent respecified\");\n\t\t \n\t\tif ((fc->user_ns != &init_user_ns) || !capable(CAP_SYS_ADMIN))\n\t\t\treturn invalfc(fc, \"Setting release_agent not allowed\");\n\t\tctx->release_agent = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_name:\n\t\t \n\t\tif (cgroup_no_v1_named)\n\t\t\treturn -ENOENT;\n\t\t \n\t\tif (!param->size)\n\t\t\treturn invalfc(fc, \"Empty name\");\n\t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)\n\t\t\treturn invalfc(fc, \"Name too long\");\n\t\t \n\t\tfor (i = 0; i < param->size; i++) {\n\t\t\tchar c = param->string[i];\n\t\t\tif (isalnum(c))\n\t\t\t\tcontinue;\n\t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n\t\t\t\tcontinue;\n\t\t\treturn invalfc(fc, \"Invalid name\");\n\t\t}\n\t\t \n\t\tif (ctx->name)\n\t\t\treturn invalfc(fc, \"name respecified\");\n\t\tctx->name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int check_cgroupfs_options(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tu16 mask = U16_MAX;\n\tu16 enabled = 0;\n\tstruct cgroup_subsys *ss;\n\tint i;\n\n#ifdef CONFIG_CPUSETS\n\tmask = ~((u16)1 << cpuset_cgrp_id);\n#endif\n\tfor_each_subsys(ss, i)\n\t\tif (cgroup_ssid_enabled(i) && !cgroup1_ssid_disabled(i))\n\t\t\tenabled |= 1 << i;\n\n\tctx->subsys_mask &= enabled;\n\n\t \n\tif (!ctx->subsys_mask && !ctx->none && !ctx->name)\n\t\tctx->all_ss = true;\n\n\tif (ctx->all_ss) {\n\t\t \n\t\tif (ctx->subsys_mask)\n\t\t\treturn invalfc(fc, \"subsys name conflicts with all\");\n\t\t \n\t\tctx->subsys_mask = enabled;\n\t}\n\n\t \n\tif (!ctx->subsys_mask && !ctx->name)\n\t\treturn invalfc(fc, \"Need name or subsystem set\");\n\n\t \n\tif ((ctx->flags & CGRP_ROOT_NOPREFIX) && (ctx->subsys_mask & mask))\n\t\treturn invalfc(fc, \"noprefix used incorrectly\");\n\n\t \n\tif (ctx->subsys_mask && ctx->none)\n\t\treturn invalfc(fc, \"none used incorrectly\");\n\n\treturn 0;\n}\n\nint cgroup1_reconfigure(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct kernfs_root *kf_root = kernfs_root_from_sb(fc->root->d_sb);\n\tstruct cgroup_root *root = cgroup_root_from_kf(kf_root);\n\tint ret = 0;\n\tu16 added_mask, removed_mask;\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\t \n\tret = check_cgroupfs_options(fc);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (ctx->subsys_mask != root->subsys_mask || ctx->release_agent)\n\t\tpr_warn(\"option changes via remount are deprecated (pid=%d comm=%s)\\n\",\n\t\t\ttask_tgid_nr(current), current->comm);\n\n\tadded_mask = ctx->subsys_mask & ~root->subsys_mask;\n\tremoved_mask = root->subsys_mask & ~ctx->subsys_mask;\n\n\t \n\tif ((ctx->flags ^ root->flags) ||\n\t    (ctx->name && strcmp(ctx->name, root->name))) {\n\t\terrorfc(fc, \"option or name mismatch, new: 0x%x \\\"%s\\\", old: 0x%x \\\"%s\\\"\",\n\t\t       ctx->flags, ctx->name ?: \"\", root->flags, root->name);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!list_empty(&root->cgrp.self.children)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tret = rebind_subsystems(root, added_mask);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tWARN_ON(rebind_subsystems(&cgrp_dfl_root, removed_mask));\n\n\tif (ctx->release_agent) {\n\t\tspin_lock(&release_agent_path_lock);\n\t\tstrcpy(root->release_agent_path, ctx->release_agent);\n\t\tspin_unlock(&release_agent_path_lock);\n\t}\n\n\ttrace_cgroup_remount(root);\n\n out_unlock:\n\tcgroup_unlock();\n\treturn ret;\n}\n\nstruct kernfs_syscall_ops cgroup1_kf_syscall_ops = {\n\t.rename\t\t\t= cgroup1_rename,\n\t.show_options\t\t= cgroup1_show_options,\n\t.mkdir\t\t\t= cgroup_mkdir,\n\t.rmdir\t\t\t= cgroup_rmdir,\n\t.show_path\t\t= cgroup_show_path,\n};\n\n \nstatic int cgroup1_root_to_use(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct cgroup_root *root;\n\tstruct cgroup_subsys *ss;\n\tint i, ret;\n\n\t \n\tret = check_cgroupfs_options(fc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_subsys(ss, i) {\n\t\tif (!(ctx->subsys_mask & (1 << i)) ||\n\t\t    ss->root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\tif (!percpu_ref_tryget_live(&ss->root->cgrp.self.refcnt))\n\t\t\treturn 1;\t \n\t\tcgroup_put(&ss->root->cgrp);\n\t}\n\n\tfor_each_root(root) {\n\t\tbool name_match = false;\n\n\t\tif (root == &cgrp_dfl_root)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ctx->name) {\n\t\t\tif (strcmp(ctx->name, root->name))\n\t\t\t\tcontinue;\n\t\t\tname_match = true;\n\t\t}\n\n\t\t \n\t\tif ((ctx->subsys_mask || ctx->none) &&\n\t\t    (ctx->subsys_mask != root->subsys_mask)) {\n\t\t\tif (!name_match)\n\t\t\t\tcontinue;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tif (root->flags ^ ctx->flags)\n\t\t\tpr_warn(\"new mount options do not match the existing superblock, will be ignored\\n\");\n\n\t\tctx->root = root;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!ctx->subsys_mask && !ctx->none)\n\t\treturn invalfc(fc, \"No subsys list or none specified\");\n\n\t \n\tif (ctx->ns != &init_cgroup_ns)\n\t\treturn -EPERM;\n\n\troot = kzalloc(sizeof(*root), GFP_KERNEL);\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\tctx->root = root;\n\tinit_cgroup_root(ctx);\n\n\tret = cgroup_setup_root(root, ctx->subsys_mask);\n\tif (!ret)\n\t\tcgroup_favor_dynmods(root, ctx->flags & CGRP_ROOT_FAVOR_DYNMODS);\n\telse\n\t\tcgroup_free_root(root);\n\n\treturn ret;\n}\n\nint cgroup1_get_tree(struct fs_context *fc)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tint ret;\n\n\t \n\tif (!ns_capable(ctx->ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcgroup_lock_and_drain_offline(&cgrp_dfl_root.cgrp);\n\n\tret = cgroup1_root_to_use(fc);\n\tif (!ret && !percpu_ref_tryget_live(&ctx->root->cgrp.self.refcnt))\n\t\tret = 1;\t \n\n\tcgroup_unlock();\n\n\tif (!ret)\n\t\tret = cgroup_do_get_tree(fc);\n\n\tif (!ret && percpu_ref_is_dying(&ctx->root->cgrp.self.refcnt)) {\n\t\tfc_drop_locked(fc);\n\t\tret = 1;\n\t}\n\n\tif (unlikely(ret > 0)) {\n\t\tmsleep(10);\n\t\treturn restart_syscall();\n\t}\n\treturn ret;\n}\n\nstatic int __init cgroup1_wq_init(void)\n{\n\t \n\tcgroup_pidlist_destroy_wq = alloc_workqueue(\"cgroup_pidlist_destroy\",\n\t\t\t\t\t\t    0, 1);\n\tBUG_ON(!cgroup_pidlist_destroy_wq);\n\treturn 0;\n}\ncore_initcall(cgroup1_wq_init);\n\nstatic int __init cgroup_no_v1(char *str)\n{\n\tstruct cgroup_subsys *ss;\n\tchar *token;\n\tint i;\n\n\twhile ((token = strsep(&str, \",\")) != NULL) {\n\t\tif (!*token)\n\t\t\tcontinue;\n\n\t\tif (!strcmp(token, \"all\")) {\n\t\t\tcgroup_no_v1_mask = U16_MAX;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(token, \"named\")) {\n\t\t\tcgroup_no_v1_named = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(token, ss->name) &&\n\t\t\t    strcmp(token, ss->legacy_name))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_no_v1_mask |= 1 << i;\n\t\t}\n\t}\n\treturn 1;\n}\n__setup(\"cgroup_no_v1=\", cgroup_no_v1);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}