{
  "module_name": "cgroup-internal.h",
  "hash_id": "9ba669ea474f61b428227934f267e304d686c8c056775d02c1938c365020fb4a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/cgroup-internal.h",
  "human_readable_source": " \n#ifndef __CGROUP_INTERNAL_H\n#define __CGROUP_INTERNAL_H\n\n#include <linux/cgroup.h>\n#include <linux/kernfs.h>\n#include <linux/workqueue.h>\n#include <linux/list.h>\n#include <linux/refcount.h>\n#include <linux/fs_parser.h>\n\n#define TRACE_CGROUP_PATH_LEN 1024\nextern spinlock_t trace_cgroup_path_lock;\nextern char trace_cgroup_path[TRACE_CGROUP_PATH_LEN];\nextern void __init enable_debug_cgroup(void);\n\n \n#define TRACE_CGROUP_PATH(type, cgrp, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (trace_cgroup_##type##_enabled()) {\t\t\t\\\n\t\t\tunsigned long flags;\t\t\t\t\\\n\t\t\tspin_lock_irqsave(&trace_cgroup_path_lock,\t\\\n\t\t\t\t\t  flags);\t\t\t\\\n\t\t\tcgroup_path(cgrp, trace_cgroup_path,\t\t\\\n\t\t\t\t    TRACE_CGROUP_PATH_LEN);\t\t\\\n\t\t\ttrace_cgroup_##type(cgrp, trace_cgroup_path,\t\\\n\t\t\t\t\t    ##__VA_ARGS__);\t\t\\\n\t\t\tspin_unlock_irqrestore(&trace_cgroup_path_lock, \\\n\t\t\t\t\t       flags);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n \nstruct cgroup_fs_context {\n\tstruct kernfs_fs_context kfc;\n\tstruct cgroup_root\t*root;\n\tstruct cgroup_namespace\t*ns;\n\tunsigned int\tflags;\t\t\t \n\n\t \n\tbool\t\tcpuset_clone_children;\n\tbool\t\tnone;\t\t\t \n\tbool\t\tall_ss;\t\t\t \n\tu16\t\tsubsys_mask;\t\t \n\tchar\t\t*name;\t\t\t \n\tchar\t\t*release_agent;\t\t \n};\n\nstatic inline struct cgroup_fs_context *cgroup_fc2context(struct fs_context *fc)\n{\n\tstruct kernfs_fs_context *kfc = fc->fs_private;\n\n\treturn container_of(kfc, struct cgroup_fs_context, kfc);\n}\n\nstruct cgroup_pidlist;\n\nstruct cgroup_file_ctx {\n\tstruct cgroup_namespace\t*ns;\n\n\tstruct {\n\t\tvoid\t\t\t*trigger;\n\t} psi;\n\n\tstruct {\n\t\tbool\t\t\tstarted;\n\t\tstruct css_task_iter\titer;\n\t} procs;\n\n\tstruct {\n\t\tstruct cgroup_pidlist\t*pidlist;\n\t} procs1;\n};\n\n \nstruct cgrp_cset_link {\n\t \n\tstruct cgroup\t\t*cgrp;\n\tstruct css_set\t\t*cset;\n\n\t \n\tstruct list_head\tcset_link;\n\n\t \n\tstruct list_head\tcgrp_link;\n};\n\n \nstruct cgroup_taskset {\n\t \n\tstruct list_head\tsrc_csets;\n\tstruct list_head\tdst_csets;\n\n\t \n\tint\t\t\tnr_tasks;\n\n\t \n\tint\t\t\tssid;\n\n\t \n\tstruct list_head\t*csets;\n\tstruct css_set\t\t*cur_cset;\n\tstruct task_struct\t*cur_task;\n};\n\n \nstruct cgroup_mgctx {\n\t \n\tstruct list_head\tpreloaded_src_csets;\n\tstruct list_head\tpreloaded_dst_csets;\n\n\t \n\tstruct cgroup_taskset\ttset;\n\n\t \n\tu16\t\t\tss_mask;\n};\n\n#define CGROUP_TASKSET_INIT(tset)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t.src_csets\t\t= LIST_HEAD_INIT(tset.src_csets),\t\t\\\n\t.dst_csets\t\t= LIST_HEAD_INIT(tset.dst_csets),\t\t\\\n\t.csets\t\t\t= &tset.src_csets,\t\t\t\t\\\n}\n\n#define CGROUP_MGCTX_INIT(name)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tLIST_HEAD_INIT(name.preloaded_src_csets),\t\t\t\t\\\n\tLIST_HEAD_INIT(name.preloaded_dst_csets),\t\t\t\t\\\n\tCGROUP_TASKSET_INIT(name.tset),\t\t\t\t\t\t\\\n}\n\n#define DEFINE_CGROUP_MGCTX(name)\t\t\t\t\t\t\\\n\tstruct cgroup_mgctx name = CGROUP_MGCTX_INIT(name)\n\nextern spinlock_t css_set_lock;\nextern struct cgroup_subsys *cgroup_subsys[];\nextern struct list_head cgroup_roots;\n\n \n#define for_each_root(root)\t\t\t\t\t\t\\\n\tlist_for_each_entry((root), &cgroup_roots, root_list)\n\n \n#define for_each_subsys(ss, ssid)\t\t\t\t\t\\\n\tfor ((ssid) = 0; (ssid) < CGROUP_SUBSYS_COUNT &&\t\t\\\n\t     (((ss) = cgroup_subsys[ssid]) || true); (ssid)++)\n\nstatic inline bool cgroup_is_dead(const struct cgroup *cgrp)\n{\n\treturn !(cgrp->self.flags & CSS_ONLINE);\n}\n\nstatic inline bool notify_on_release(const struct cgroup *cgrp)\n{\n\treturn test_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);\n}\n\nvoid put_css_set_locked(struct css_set *cset);\n\nstatic inline void put_css_set(struct css_set *cset)\n{\n\tunsigned long flags;\n\n\t \n\tif (refcount_dec_not_one(&cset->refcount))\n\t\treturn;\n\n\tspin_lock_irqsave(&css_set_lock, flags);\n\tput_css_set_locked(cset);\n\tspin_unlock_irqrestore(&css_set_lock, flags);\n}\n\n \nstatic inline void get_css_set(struct css_set *cset)\n{\n\trefcount_inc(&cset->refcount);\n}\n\nbool cgroup_ssid_enabled(int ssid);\nbool cgroup_on_dfl(const struct cgroup *cgrp);\n\nstruct cgroup_root *cgroup_root_from_kf(struct kernfs_root *kf_root);\nstruct cgroup *task_cgroup_from_root(struct task_struct *task,\n\t\t\t\t     struct cgroup_root *root);\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline);\nvoid cgroup_kn_unlock(struct kernfs_node *kn);\nint cgroup_path_ns_locked(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t\t  struct cgroup_namespace *ns);\n\nvoid cgroup_favor_dynmods(struct cgroup_root *root, bool favor);\nvoid cgroup_free_root(struct cgroup_root *root);\nvoid init_cgroup_root(struct cgroup_fs_context *ctx);\nint cgroup_setup_root(struct cgroup_root *root, u16 ss_mask);\nint rebind_subsystems(struct cgroup_root *dst_root, u16 ss_mask);\nint cgroup_do_get_tree(struct fs_context *fc);\n\nint cgroup_migrate_vet_dst(struct cgroup *dst_cgrp);\nvoid cgroup_migrate_finish(struct cgroup_mgctx *mgctx);\nvoid cgroup_migrate_add_src(struct css_set *src_cset, struct cgroup *dst_cgrp,\n\t\t\t    struct cgroup_mgctx *mgctx);\nint cgroup_migrate_prepare_dst(struct cgroup_mgctx *mgctx);\nint cgroup_migrate(struct task_struct *leader, bool threadgroup,\n\t\t   struct cgroup_mgctx *mgctx);\n\nint cgroup_attach_task(struct cgroup *dst_cgrp, struct task_struct *leader,\n\t\t       bool threadgroup);\nvoid cgroup_attach_lock(bool lock_threadgroup);\nvoid cgroup_attach_unlock(bool lock_threadgroup);\nstruct task_struct *cgroup_procs_write_start(char *buf, bool threadgroup,\n\t\t\t\t\t     bool *locked)\n\t__acquires(&cgroup_threadgroup_rwsem);\nvoid cgroup_procs_write_finish(struct task_struct *task, bool locked)\n\t__releases(&cgroup_threadgroup_rwsem);\n\nvoid cgroup_lock_and_drain_offline(struct cgroup *cgrp);\n\nint cgroup_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode);\nint cgroup_rmdir(struct kernfs_node *kn);\nint cgroup_show_path(struct seq_file *sf, struct kernfs_node *kf_node,\n\t\t     struct kernfs_root *kf_root);\n\nint __cgroup_task_count(const struct cgroup *cgrp);\nint cgroup_task_count(const struct cgroup *cgrp);\n\n \nint cgroup_rstat_init(struct cgroup *cgrp);\nvoid cgroup_rstat_exit(struct cgroup *cgrp);\nvoid cgroup_rstat_boot(void);\nvoid cgroup_base_stat_cputime_show(struct seq_file *seq);\n\n \nextern const struct proc_ns_operations cgroupns_operations;\n\n \nextern struct cftype cgroup1_base_files[];\nextern struct kernfs_syscall_ops cgroup1_kf_syscall_ops;\nextern const struct fs_parameter_spec cgroup1_fs_parameters[];\n\nint proc_cgroupstats_show(struct seq_file *m, void *v);\nbool cgroup1_ssid_disabled(int ssid);\nvoid cgroup1_pidlist_destroy_all(struct cgroup *cgrp);\nvoid cgroup1_release_agent(struct work_struct *work);\nvoid cgroup1_check_for_release(struct cgroup *cgrp);\nint cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param);\nint cgroup1_get_tree(struct fs_context *fc);\nint cgroup1_reconfigure(struct fs_context *ctx);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}