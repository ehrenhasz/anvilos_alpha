{
  "module_name": "namespace.c",
  "hash_id": "d8e47321b9b1d6da753fef5c7ba9e3e837768475fe881e00aff6e2ce9a49b961",
  "original_prompt": "Ingested from linux-6.6.14/kernel/cgroup/namespace.c",
  "human_readable_source": "\n#include \"cgroup-internal.h\"\n\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n\n\n \n\nstatic struct ucounts *inc_cgroup_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_CGROUP_NAMESPACES);\n}\n\nstatic void dec_cgroup_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_CGROUP_NAMESPACES);\n}\n\nstatic struct cgroup_namespace *alloc_cgroup_ns(void)\n{\n\tstruct cgroup_namespace *new_ns;\n\tint ret;\n\n\tnew_ns = kzalloc(sizeof(struct cgroup_namespace), GFP_KERNEL_ACCOUNT);\n\tif (!new_ns)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\treturn ERR_PTR(ret);\n\t}\n\trefcount_set(&new_ns->ns.count, 1);\n\tnew_ns->ns.ops = &cgroupns_operations;\n\treturn new_ns;\n}\n\nvoid free_cgroup_ns(struct cgroup_namespace *ns)\n{\n\tput_css_set(ns->root_cset);\n\tdec_cgroup_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkfree(ns);\n}\nEXPORT_SYMBOL(free_cgroup_ns);\n\nstruct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t \n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t \n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}\n\nstatic inline struct cgroup_namespace *to_cg_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct cgroup_namespace, ns);\n}\n\nstatic int cgroupns_install(struct nsset *nsset, struct ns_common *ns)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct cgroup_namespace *cgroup_ns = to_cg_ns(ns);\n\n\tif (!ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(cgroup_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (cgroup_ns == nsproxy->cgroup_ns)\n\t\treturn 0;\n\n\tget_cgroup_ns(cgroup_ns);\n\tput_cgroup_ns(nsproxy->cgroup_ns);\n\tnsproxy->cgroup_ns = cgroup_ns;\n\n\treturn 0;\n}\n\nstatic struct ns_common *cgroupns_get(struct task_struct *task)\n{\n\tstruct cgroup_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->cgroup_ns;\n\t\tget_cgroup_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic void cgroupns_put(struct ns_common *ns)\n{\n\tput_cgroup_ns(to_cg_ns(ns));\n}\n\nstatic struct user_namespace *cgroupns_owner(struct ns_common *ns)\n{\n\treturn to_cg_ns(ns)->user_ns;\n}\n\nconst struct proc_ns_operations cgroupns_operations = {\n\t.name\t\t= \"cgroup\",\n\t.type\t\t= CLONE_NEWCGROUP,\n\t.get\t\t= cgroupns_get,\n\t.put\t\t= cgroupns_put,\n\t.install\t= cgroupns_install,\n\t.owner\t\t= cgroupns_owner,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}