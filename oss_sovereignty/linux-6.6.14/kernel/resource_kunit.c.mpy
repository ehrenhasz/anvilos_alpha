{
  "module_name": "resource_kunit.c",
  "hash_id": "a2a8dbb901fcb28363271b96c97e36e818da498cda4f18c344aaeb6d62c80fde",
  "original_prompt": "Ingested from linux-6.6.14/kernel/resource_kunit.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n#define R0_START\t0x0000\n#define R0_END\t\t0xffff\n#define R1_START\t0x1234\n#define R1_END\t\t0x2345\n#define R2_START\t0x4567\n#define R2_END\t\t0x5678\n#define R3_START\t0x6789\n#define R3_END\t\t0x789a\n#define R4_START\t0x2000\n#define R4_END\t\t0x7000\n\nstatic struct resource r0 = { .start = R0_START, .end = R0_END };\nstatic struct resource r1 = { .start = R1_START, .end = R1_END };\nstatic struct resource r2 = { .start = R2_START, .end = R2_END };\nstatic struct resource r3 = { .start = R3_START, .end = R3_END };\nstatic struct resource r4 = { .start = R4_START, .end = R4_END };\n\nstruct result {\n\tstruct resource *r1;\n\tstruct resource *r2;\n\tstruct resource r;\n\tbool ret;\n};\n\nstatic struct result results_for_union[] = {\n\t{\n\t\t.r1 = &r1, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,\n\t}, {\n\t\t.r1 = &r3, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,\n\t}, {\n\t\t.r1 = &r4, .r2 = &r0, .r.start = R0_START, .r.end = R0_END, .ret = true,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r1, .ret = false,\n\t}, {\n\t\t.r1 = &r3, .r2 = &r1, .ret = false,\n\t}, {\n\t\t.r1 = &r4, .r2 = &r1, .r.start = R1_START, .r.end = R4_END, .ret = true,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r3, .ret = false,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r4, .r.start = R4_START, .r.end = R4_END, .ret = true,\n\t}, {\n\t\t.r1 = &r3, .r2 = &r4, .r.start = R4_START, .r.end = R3_END, .ret = true,\n\t},\n};\n\nstatic struct result results_for_intersection[] = {\n\t{\n\t\t.r1 = &r1, .r2 = &r0, .r.start = R1_START, .r.end = R1_END, .ret = true,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r0, .r.start = R2_START, .r.end = R2_END, .ret = true,\n\t}, {\n\t\t.r1 = &r3, .r2 = &r0, .r.start = R3_START, .r.end = R3_END, .ret = true,\n\t}, {\n\t\t.r1 = &r4, .r2 = &r0, .r.start = R4_START, .r.end = R4_END, .ret = true,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r1, .ret = false,\n\t}, {\n\t\t.r1 = &r3, .r2 = &r1, .ret = false,\n\t}, {\n\t\t.r1 = &r4, .r2 = &r1, .r.start = R4_START, .r.end = R1_END, .ret = true,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r3, .ret = false,\n\t}, {\n\t\t.r1 = &r2, .r2 = &r4, .r.start = R2_START, .r.end = R2_END, .ret = true,\n\t}, {\n\t\t.r1 = &r3, .r2 = &r4, .r.start = R3_START, .r.end = R4_END, .ret = true,\n\t},\n};\n\nstatic void resource_do_test(struct kunit *test, bool ret, struct resource *r,\n\t\t\t     bool exp_ret, struct resource *exp_r,\n\t\t\t     struct resource *r1, struct resource *r2)\n{\n\tKUNIT_EXPECT_EQ_MSG(test, ret, exp_ret, \"Resources %pR %pR\", r1, r2);\n\tKUNIT_EXPECT_EQ_MSG(test, r->start, exp_r->start, \"Start elements are not equal\");\n\tKUNIT_EXPECT_EQ_MSG(test, r->end, exp_r->end, \"End elements are not equal\");\n}\n\nstatic void resource_do_union_test(struct kunit *test, struct result *r)\n{\n\tstruct resource result;\n\tbool ret;\n\n\tmemset(&result, 0, sizeof(result));\n\tret = resource_union(r->r1, r->r2, &result);\n\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r1, r->r2);\n\n\tmemset(&result, 0, sizeof(result));\n\tret = resource_union(r->r2, r->r1, &result);\n\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r2, r->r1);\n}\n\nstatic void resource_test_union(struct kunit *test)\n{\n\tstruct result *r = results_for_union;\n\tunsigned int i = 0;\n\n\tdo {\n\t\tresource_do_union_test(test, &r[i]);\n\t} while (++i < ARRAY_SIZE(results_for_union));\n}\n\nstatic void resource_do_intersection_test(struct kunit *test, struct result *r)\n{\n\tstruct resource result;\n\tbool ret;\n\n\tmemset(&result, 0, sizeof(result));\n\tret = resource_intersection(r->r1, r->r2, &result);\n\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r1, r->r2);\n\n\tmemset(&result, 0, sizeof(result));\n\tret = resource_intersection(r->r2, r->r1, &result);\n\tresource_do_test(test, ret, &result, r->ret, &r->r, r->r2, r->r1);\n}\n\nstatic void resource_test_intersection(struct kunit *test)\n{\n\tstruct result *r = results_for_intersection;\n\tunsigned int i = 0;\n\n\tdo {\n\t\tresource_do_intersection_test(test, &r[i]);\n\t} while (++i < ARRAY_SIZE(results_for_intersection));\n}\n\nstatic struct kunit_case resource_test_cases[] = {\n\tKUNIT_CASE(resource_test_union),\n\tKUNIT_CASE(resource_test_intersection),\n\t{}\n};\n\nstatic struct kunit_suite resource_test_suite = {\n\t.name = \"resource\",\n\t.test_cases = resource_test_cases,\n};\nkunit_test_suite(resource_test_suite);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}