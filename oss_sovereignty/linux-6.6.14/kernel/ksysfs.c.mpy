{
  "module_name": "ksysfs.c",
  "hash_id": "acf6a2d4f4452b41b9aa25f9d852a7b9391e317fe622fbd851a76c4b599c97c3",
  "original_prompt": "Ingested from linux-6.6.14/kernel/ksysfs.c",
  "human_readable_source": "\n \n\n#include <asm/byteorder.h>\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kexec.h>\n#include <linux/profile.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/compiler.h>\n\n#include <linux/rcupdate.h>\t \n\n#if defined(__LITTLE_ENDIAN)\n#define CPU_BYTEORDER_STRING\t\"little\"\n#elif defined(__BIG_ENDIAN)\n#define CPU_BYTEORDER_STRING\t\"big\"\n#else\n#error Unknown byteorder\n#endif\n\n#define KERNEL_ATTR_RO(_name) \\\nstatic struct kobj_attribute _name##_attr = __ATTR_RO(_name)\n\n#define KERNEL_ATTR_RW(_name) \\\nstatic struct kobj_attribute _name##_attr = __ATTR_RW(_name)\n\n \nstatic ssize_t uevent_seqnum_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)uevent_seqnum);\n}\nKERNEL_ATTR_RO(uevent_seqnum);\n\n \nstatic ssize_t cpu_byteorder_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", CPU_BYTEORDER_STRING);\n}\nKERNEL_ATTR_RO(cpu_byteorder);\n\n \nstatic ssize_t address_bits_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%zu\\n\", sizeof(void *) * 8  );\n}\nKERNEL_ATTR_RO(address_bits);\n\n#ifdef CONFIG_UEVENT_HELPER\n \nstatic ssize_t uevent_helper_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", uevent_helper);\n}\nstatic ssize_t uevent_helper_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tif (count+1 > UEVENT_HELPER_PATH_LEN)\n\t\treturn -ENOENT;\n\tmemcpy(uevent_helper, buf, count);\n\tuevent_helper[count] = '\\0';\n\tif (count && uevent_helper[count-1] == '\\n')\n\t\tuevent_helper[count-1] = '\\0';\n\treturn count;\n}\nKERNEL_ATTR_RW(uevent_helper);\n#endif\n\n#ifdef CONFIG_PROFILING\nstatic ssize_t profiling_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", prof_on);\n}\nstatic ssize_t profiling_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint ret;\n\n\tif (prof_on)\n\t\treturn -EEXIST;\n\t \n\tprofile_setup((char *)buf);\n\tret = profile_init();\n\tif (ret)\n\t\treturn ret;\n\tret = create_proc_profile();\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\nKERNEL_ATTR_RW(profiling);\n#endif\n\n#ifdef CONFIG_KEXEC_CORE\nstatic ssize_t kexec_loaded_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!kexec_image);\n}\nKERNEL_ATTR_RO(kexec_loaded);\n\nstatic ssize_t kexec_crash_loaded_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", kexec_crash_loaded());\n}\nKERNEL_ATTR_RO(kexec_crash_loaded);\n\nstatic ssize_t kexec_crash_size_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tssize_t size = crash_get_memory_size();\n\n\tif (size < 0)\n\t\treturn size;\n\n\treturn sysfs_emit(buf, \"%zd\\n\", size);\n}\nstatic ssize_t kexec_crash_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tunsigned long cnt;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &cnt))\n\t\treturn -EINVAL;\n\n\tret = crash_shrink_memory(cnt);\n\treturn ret < 0 ? ret : count;\n}\nKERNEL_ATTR_RW(kexec_crash_size);\n\n#endif  \n\n#ifdef CONFIG_CRASH_CORE\n\nstatic ssize_t vmcoreinfo_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tphys_addr_t vmcore_base = paddr_vmcoreinfo_note();\n\treturn sysfs_emit(buf, \"%pa %x\\n\", &vmcore_base,\n\t\t\t  (unsigned int)VMCOREINFO_NOTE_SIZE);\n}\nKERNEL_ATTR_RO(vmcoreinfo);\n\n#ifdef CONFIG_CRASH_HOTPLUG\nstatic ssize_t crash_elfcorehdr_size_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tunsigned int sz = crash_get_elfcorehdr_size();\n\n\treturn sysfs_emit(buf, \"%u\\n\", sz);\n}\nKERNEL_ATTR_RO(crash_elfcorehdr_size);\n\n#endif\n\n#endif  \n\n \nstatic ssize_t fscaps_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", file_caps_enabled);\n}\nKERNEL_ATTR_RO(fscaps);\n\n#ifndef CONFIG_TINY_RCU\nint rcu_expedited;\nstatic ssize_t rcu_expedited_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", READ_ONCE(rcu_expedited));\n}\nstatic ssize_t rcu_expedited_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tif (kstrtoint(buf, 0, &rcu_expedited))\n\t\treturn -EINVAL;\n\n\treturn count;\n}\nKERNEL_ATTR_RW(rcu_expedited);\n\nint rcu_normal;\nstatic ssize_t rcu_normal_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", READ_ONCE(rcu_normal));\n}\nstatic ssize_t rcu_normal_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tif (kstrtoint(buf, 0, &rcu_normal))\n\t\treturn -EINVAL;\n\n\treturn count;\n}\nKERNEL_ATTR_RW(rcu_normal);\n#endif  \n\n \nextern const void __start_notes __weak;\nextern const void __stop_notes __weak;\n#define\tnotes_size (&__stop_notes - &__start_notes)\n\nstatic ssize_t notes_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tmemcpy(buf, &__start_notes + off, count);\n\treturn count;\n}\n\nstatic struct bin_attribute notes_attr __ro_after_init  = {\n\t.attr = {\n\t\t.name = \"notes\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.read = &notes_read,\n};\n\nstruct kobject *kernel_kobj;\nEXPORT_SYMBOL_GPL(kernel_kobj);\n\nstatic struct attribute * kernel_attrs[] = {\n\t&fscaps_attr.attr,\n\t&uevent_seqnum_attr.attr,\n\t&cpu_byteorder_attr.attr,\n\t&address_bits_attr.attr,\n#ifdef CONFIG_UEVENT_HELPER\n\t&uevent_helper_attr.attr,\n#endif\n#ifdef CONFIG_PROFILING\n\t&profiling_attr.attr,\n#endif\n#ifdef CONFIG_KEXEC_CORE\n\t&kexec_loaded_attr.attr,\n\t&kexec_crash_loaded_attr.attr,\n\t&kexec_crash_size_attr.attr,\n#endif\n#ifdef CONFIG_CRASH_CORE\n\t&vmcoreinfo_attr.attr,\n#ifdef CONFIG_CRASH_HOTPLUG\n\t&crash_elfcorehdr_size_attr.attr,\n#endif\n#endif\n#ifndef CONFIG_TINY_RCU\n\t&rcu_expedited_attr.attr,\n\t&rcu_normal_attr.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group kernel_attr_group = {\n\t.attrs = kernel_attrs,\n};\n\nstatic int __init ksysfs_init(void)\n{\n\tint error;\n\n\tkernel_kobj = kobject_create_and_add(\"kernel\", NULL);\n\tif (!kernel_kobj) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\terror = sysfs_create_group(kernel_kobj, &kernel_attr_group);\n\tif (error)\n\t\tgoto kset_exit;\n\n\tif (notes_size > 0) {\n\t\tnotes_attr.size = notes_size;\n\t\terror = sysfs_create_bin_file(kernel_kobj, &notes_attr);\n\t\tif (error)\n\t\t\tgoto group_exit;\n\t}\n\n\treturn 0;\n\ngroup_exit:\n\tsysfs_remove_group(kernel_kobj, &kernel_attr_group);\nkset_exit:\n\tkobject_put(kernel_kobj);\nexit:\n\treturn error;\n}\n\ncore_initcall(ksysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}