{
  "module_name": "suspend.c",
  "hash_id": "6ebc2b3eb5bcefd251d2e79f59bd5d6096985f3e3e4928546ff58b90a3009a78",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/suspend.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PM: \" fmt\n\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n#include <linux/swait.h>\n#include <linux/ftrace.h>\n#include <trace/events/power.h>\n#include <linux/compiler.h>\n#include <linux/moduleparam.h>\n\n#include \"power.h\"\n\nconst char * const pm_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"freeze\",\n\t[PM_SUSPEND_STANDBY] = \"standby\",\n\t[PM_SUSPEND_MEM] = \"mem\",\n};\nconst char *pm_states[PM_SUSPEND_MAX];\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\nconst char *mem_sleep_states[PM_SUSPEND_MAX];\n\nsuspend_state_t mem_sleep_current = PM_SUSPEND_TO_IDLE;\nsuspend_state_t mem_sleep_default = PM_SUSPEND_MAX;\nsuspend_state_t pm_suspend_target_state;\nEXPORT_SYMBOL_GPL(pm_suspend_target_state);\n\nunsigned int pm_suspend_global_flags;\nEXPORT_SYMBOL_GPL(pm_suspend_global_flags);\n\nstatic const struct platform_suspend_ops *suspend_ops;\nstatic const struct platform_s2idle_ops *s2idle_ops;\nstatic DECLARE_SWAIT_QUEUE_HEAD(s2idle_wait_head);\n\nenum s2idle_states __read_mostly s2idle_state;\nstatic DEFINE_RAW_SPINLOCK(s2idle_lock);\n\n \nbool pm_suspend_default_s2idle(void)\n{\n\treturn mem_sleep_current == PM_SUSPEND_TO_IDLE;\n}\nEXPORT_SYMBOL_GPL(pm_suspend_default_s2idle);\n\nvoid s2idle_set_ops(const struct platform_s2idle_ops *ops)\n{\n\tunsigned int sleep_flags;\n\n\tsleep_flags = lock_system_sleep();\n\ts2idle_ops = ops;\n\tunlock_system_sleep(sleep_flags);\n}\n\nstatic void s2idle_begin(void)\n{\n\ts2idle_state = S2IDLE_STATE_NONE;\n}\n\nstatic void s2idle_enter(void)\n{\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_SUSPEND_TO_IDLE, true);\n\n\traw_spin_lock_irq(&s2idle_lock);\n\tif (pm_wakeup_pending())\n\t\tgoto out;\n\n\ts2idle_state = S2IDLE_STATE_ENTER;\n\traw_spin_unlock_irq(&s2idle_lock);\n\n\tcpus_read_lock();\n\n\t \n\twake_up_all_idle_cpus();\n\t \n\tswait_event_exclusive(s2idle_wait_head,\n\t\t    s2idle_state == S2IDLE_STATE_WAKE);\n\n\tcpus_read_unlock();\n\n\traw_spin_lock_irq(&s2idle_lock);\n\n out:\n\ts2idle_state = S2IDLE_STATE_NONE;\n\traw_spin_unlock_irq(&s2idle_lock);\n\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_SUSPEND_TO_IDLE, false);\n}\n\nstatic void s2idle_loop(void)\n{\n\tpm_pr_dbg(\"suspend-to-idle\\n\");\n\n\t \n\tfor (;;) {\n\t\tif (s2idle_ops && s2idle_ops->wake) {\n\t\t\tif (s2idle_ops->wake())\n\t\t\t\tbreak;\n\t\t} else if (pm_wakeup_pending()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (s2idle_ops && s2idle_ops->check)\n\t\t\ts2idle_ops->check();\n\n\t\ts2idle_enter();\n\t}\n\n\tpm_pr_dbg(\"resume from suspend-to-idle\\n\");\n}\n\nvoid s2idle_wake(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&s2idle_lock, flags);\n\tif (s2idle_state > S2IDLE_STATE_NONE) {\n\t\ts2idle_state = S2IDLE_STATE_WAKE;\n\t\tswake_up_one(&s2idle_wait_head);\n\t}\n\traw_spin_unlock_irqrestore(&s2idle_lock, flags);\n}\nEXPORT_SYMBOL_GPL(s2idle_wake);\n\nstatic bool valid_state(suspend_state_t state)\n{\n\t \n\treturn suspend_ops && suspend_ops->valid && suspend_ops->valid(state) &&\n\t\tsuspend_ops->enter;\n}\n\nvoid __init pm_states_init(void)\n{\n\t \n\tpm_states[PM_SUSPEND_MEM] = pm_labels[PM_SUSPEND_MEM];\n\tpm_states[PM_SUSPEND_TO_IDLE] = pm_labels[PM_SUSPEND_TO_IDLE];\n\t \n\tmem_sleep_states[PM_SUSPEND_TO_IDLE] = mem_sleep_labels[PM_SUSPEND_TO_IDLE];\n}\n\nstatic int __init mem_sleep_default_setup(char *str)\n{\n\tsuspend_state_t state;\n\n\tfor (state = PM_SUSPEND_TO_IDLE; state <= PM_SUSPEND_MEM; state++)\n\t\tif (mem_sleep_labels[state] &&\n\t\t    !strcmp(str, mem_sleep_labels[state])) {\n\t\t\tmem_sleep_default = state;\n\t\t\tbreak;\n\t\t}\n\n\treturn 1;\n}\n__setup(\"mem_sleep_default=\", mem_sleep_default_setup);\n\n \nvoid suspend_set_ops(const struct platform_suspend_ops *ops)\n{\n\tunsigned int sleep_flags;\n\n\tsleep_flags = lock_system_sleep();\n\n\tsuspend_ops = ops;\n\n\tif (valid_state(PM_SUSPEND_STANDBY)) {\n\t\tmem_sleep_states[PM_SUSPEND_STANDBY] = mem_sleep_labels[PM_SUSPEND_STANDBY];\n\t\tpm_states[PM_SUSPEND_STANDBY] = pm_labels[PM_SUSPEND_STANDBY];\n\t\tif (mem_sleep_default == PM_SUSPEND_STANDBY)\n\t\t\tmem_sleep_current = PM_SUSPEND_STANDBY;\n\t}\n\tif (valid_state(PM_SUSPEND_MEM)) {\n\t\tmem_sleep_states[PM_SUSPEND_MEM] = mem_sleep_labels[PM_SUSPEND_MEM];\n\t\tif (mem_sleep_default >= PM_SUSPEND_MEM)\n\t\t\tmem_sleep_current = PM_SUSPEND_MEM;\n\t}\n\n\tunlock_system_sleep(sleep_flags);\n}\nEXPORT_SYMBOL_GPL(suspend_set_ops);\n\n \nint suspend_valid_only_mem(suspend_state_t state)\n{\n\treturn state == PM_SUSPEND_MEM;\n}\nEXPORT_SYMBOL_GPL(suspend_valid_only_mem);\n\nstatic bool sleep_state_supported(suspend_state_t state)\n{\n\treturn state == PM_SUSPEND_TO_IDLE ||\n\t       (valid_state(state) && !cxl_mem_active());\n}\n\nstatic int platform_suspend_prepare(suspend_state_t state)\n{\n\treturn state != PM_SUSPEND_TO_IDLE && suspend_ops->prepare ?\n\t\tsuspend_ops->prepare() : 0;\n}\n\nstatic int platform_suspend_prepare_late(suspend_state_t state)\n{\n\treturn state == PM_SUSPEND_TO_IDLE && s2idle_ops && s2idle_ops->prepare ?\n\t\ts2idle_ops->prepare() : 0;\n}\n\nstatic int platform_suspend_prepare_noirq(suspend_state_t state)\n{\n\tif (state == PM_SUSPEND_TO_IDLE)\n\t\treturn s2idle_ops && s2idle_ops->prepare_late ?\n\t\t\ts2idle_ops->prepare_late() : 0;\n\n\treturn suspend_ops->prepare_late ? suspend_ops->prepare_late() : 0;\n}\n\nstatic void platform_resume_noirq(suspend_state_t state)\n{\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\tif (s2idle_ops && s2idle_ops->restore_early)\n\t\t\ts2idle_ops->restore_early();\n\t} else if (suspend_ops->wake) {\n\t\tsuspend_ops->wake();\n\t}\n}\n\nstatic void platform_resume_early(suspend_state_t state)\n{\n\tif (state == PM_SUSPEND_TO_IDLE && s2idle_ops && s2idle_ops->restore)\n\t\ts2idle_ops->restore();\n}\n\nstatic void platform_resume_finish(suspend_state_t state)\n{\n\tif (state != PM_SUSPEND_TO_IDLE && suspend_ops->finish)\n\t\tsuspend_ops->finish();\n}\n\nstatic int platform_suspend_begin(suspend_state_t state)\n{\n\tif (state == PM_SUSPEND_TO_IDLE && s2idle_ops && s2idle_ops->begin)\n\t\treturn s2idle_ops->begin();\n\telse if (suspend_ops && suspend_ops->begin)\n\t\treturn suspend_ops->begin(state);\n\telse\n\t\treturn 0;\n}\n\nstatic void platform_resume_end(suspend_state_t state)\n{\n\tif (state == PM_SUSPEND_TO_IDLE && s2idle_ops && s2idle_ops->end)\n\t\ts2idle_ops->end();\n\telse if (suspend_ops && suspend_ops->end)\n\t\tsuspend_ops->end();\n}\n\nstatic void platform_recover(suspend_state_t state)\n{\n\tif (state != PM_SUSPEND_TO_IDLE && suspend_ops->recover)\n\t\tsuspend_ops->recover();\n}\n\nstatic bool platform_suspend_again(suspend_state_t state)\n{\n\treturn state != PM_SUSPEND_TO_IDLE && suspend_ops->suspend_again ?\n\t\tsuspend_ops->suspend_again() : false;\n}\n\n#ifdef CONFIG_PM_DEBUG\nstatic unsigned int pm_test_delay = 5;\nmodule_param(pm_test_delay, uint, 0644);\nMODULE_PARM_DESC(pm_test_delay,\n\t\t \"Number of seconds to wait before resuming from suspend test\");\n#endif\n\nstatic int suspend_test(int level)\n{\n#ifdef CONFIG_PM_DEBUG\n\tif (pm_test_level == level) {\n\t\tpr_info(\"suspend debug: Waiting for %d second(s).\\n\",\n\t\t\t\tpm_test_delay);\n\t\tmdelay(pm_test_delay * 1000);\n\t\treturn 1;\n\t}\n#endif  \n\treturn 0;\n}\n\n \nstatic int suspend_prepare(suspend_state_t state)\n{\n\tint error;\n\n\tif (!sleep_state_supported(state))\n\t\treturn -EPERM;\n\n\tpm_prepare_console();\n\n\terror = pm_notifier_call_chain_robust(PM_SUSPEND_PREPARE, PM_POST_SUSPEND);\n\tif (error)\n\t\tgoto Restore;\n\n\ttrace_suspend_resume(TPS(\"freeze_processes\"), 0, true);\n\terror = suspend_freeze_processes();\n\ttrace_suspend_resume(TPS(\"freeze_processes\"), 0, false);\n\tif (!error)\n\t\treturn 0;\n\n\tsuspend_stats.failed_freeze++;\n\tdpm_save_failed_step(SUSPEND_FREEZE);\n\tpm_notifier_call_chain(PM_POST_SUSPEND);\n Restore:\n\tpm_restore_console();\n\treturn error;\n}\n\n \nvoid __weak arch_suspend_disable_irqs(void)\n{\n\tlocal_irq_disable();\n}\n\n \nvoid __weak arch_suspend_enable_irqs(void)\n{\n\tlocal_irq_enable();\n}\n\n \nstatic int suspend_enter(suspend_state_t state, bool *wakeup)\n{\n\tint error;\n\n\terror = platform_suspend_prepare(state);\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = dpm_suspend_late(PMSG_SUSPEND);\n\tif (error) {\n\t\tpr_err(\"late suspend of devices failed\\n\");\n\t\tgoto Platform_finish;\n\t}\n\terror = platform_suspend_prepare_late(state);\n\tif (error)\n\t\tgoto Devices_early_resume;\n\n\terror = dpm_suspend_noirq(PMSG_SUSPEND);\n\tif (error) {\n\t\tpr_err(\"noirq suspend of devices failed\\n\");\n\t\tgoto Platform_early_resume;\n\t}\n\terror = platform_suspend_prepare_noirq(state);\n\tif (error)\n\t\tgoto Platform_wake;\n\n\tif (suspend_test(TEST_PLATFORM))\n\t\tgoto Platform_wake;\n\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\ts2idle_loop();\n\t\tgoto Platform_wake;\n\t}\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error || suspend_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tarch_suspend_disable_irqs();\n\tBUG_ON(!irqs_disabled());\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (!error) {\n\t\t*wakeup = pm_wakeup_pending();\n\t\tif (!(suspend_test(TEST_CORE) || *wakeup)) {\n\t\t\ttrace_suspend_resume(TPS(\"machine_suspend\"),\n\t\t\t\tstate, true);\n\t\t\terror = suspend_ops->enter(state);\n\t\t\ttrace_suspend_resume(TPS(\"machine_suspend\"),\n\t\t\t\tstate, false);\n\t\t} else if (*wakeup) {\n\t\t\terror = -EBUSY;\n\t\t}\n\t\tsyscore_resume();\n\t}\n\n\tsystem_state = SYSTEM_RUNNING;\n\n\tarch_suspend_enable_irqs();\n\tBUG_ON(irqs_disabled());\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_wake:\n\tplatform_resume_noirq(state);\n\tdpm_resume_noirq(PMSG_RESUME);\n\n Platform_early_resume:\n\tplatform_resume_early(state);\n\n Devices_early_resume:\n\tdpm_resume_early(PMSG_RESUME);\n\n Platform_finish:\n\tplatform_resume_finish(state);\n\treturn error;\n}\n\n \nint suspend_devices_and_enter(suspend_state_t state)\n{\n\tint error;\n\tbool wakeup = false;\n\n\tif (!sleep_state_supported(state))\n\t\treturn -ENOSYS;\n\n\tpm_suspend_target_state = state;\n\n\tif (state == PM_SUSPEND_TO_IDLE)\n\t\tpm_set_suspend_no_platform();\n\n\terror = platform_suspend_begin(state);\n\tif (error)\n\t\tgoto Close;\n\n\tsuspend_console();\n\tsuspend_test_start();\n\terror = dpm_suspend_start(PMSG_SUSPEND);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to suspend, or early wake event detected\\n\");\n\t\tgoto Recover_platform;\n\t}\n\tsuspend_test_finish(\"suspend devices\");\n\tif (suspend_test(TEST_DEVICES))\n\t\tgoto Recover_platform;\n\n\tdo {\n\t\terror = suspend_enter(state, &wakeup);\n\t} while (!error && !wakeup && platform_suspend_again(state));\n\n Resume_devices:\n\tsuspend_test_start();\n\tdpm_resume_end(PMSG_RESUME);\n\tsuspend_test_finish(\"resume devices\");\n\ttrace_suspend_resume(TPS(\"resume_console\"), state, true);\n\tresume_console();\n\ttrace_suspend_resume(TPS(\"resume_console\"), state, false);\n\n Close:\n\tplatform_resume_end(state);\n\tpm_suspend_target_state = PM_SUSPEND_ON;\n\treturn error;\n\n Recover_platform:\n\tplatform_recover(state);\n\tgoto Resume_devices;\n}\n\n \nstatic void suspend_finish(void)\n{\n\tsuspend_thaw_processes();\n\tpm_notifier_call_chain(PM_POST_SUSPEND);\n\tpm_restore_console();\n}\n\n \nstatic int enter_state(suspend_state_t state)\n{\n\tint error;\n\n\ttrace_suspend_resume(TPS(\"suspend_enter\"), state, true);\n\tif (state == PM_SUSPEND_TO_IDLE) {\n#ifdef CONFIG_PM_DEBUG\n\t\tif (pm_test_level != TEST_NONE && pm_test_level <= TEST_CPUS) {\n\t\t\tpr_warn(\"Unsupported test mode for suspend to idle, please choose none/freezer/devices/platform.\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n#endif\n\t} else if (!valid_state(state)) {\n\t\treturn -EINVAL;\n\t}\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tif (state == PM_SUSPEND_TO_IDLE)\n\t\ts2idle_begin();\n\n\tif (sync_on_suspend_enabled) {\n\t\ttrace_suspend_resume(TPS(\"sync_filesystems\"), 0, true);\n\t\tksys_sync_helper();\n\t\ttrace_suspend_resume(TPS(\"sync_filesystems\"), 0, false);\n\t}\n\n\tpm_pr_dbg(\"Preparing system for sleep (%s)\\n\", mem_sleep_labels[state]);\n\tpm_suspend_clear_flags();\n\terror = suspend_prepare(state);\n\tif (error)\n\t\tgoto Unlock;\n\n\tif (suspend_test(TEST_FREEZER))\n\t\tgoto Finish;\n\n\ttrace_suspend_resume(TPS(\"suspend_enter\"), state, false);\n\tpm_pr_dbg(\"Suspending system (%s)\\n\", mem_sleep_labels[state]);\n\tpm_restrict_gfp_mask();\n\terror = suspend_devices_and_enter(state);\n\tpm_restore_gfp_mask();\n\n Finish:\n\tevents_check_enabled = false;\n\tpm_pr_dbg(\"Finishing wakeup.\\n\");\n\tsuspend_finish();\n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\treturn error;\n}\n\n \nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}\nEXPORT_SYMBOL(pm_suspend);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}