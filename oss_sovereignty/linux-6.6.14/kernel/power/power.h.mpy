{
  "module_name": "power.h",
  "hash_id": "c3b3a075cdb22e992a4f64a63930e32d7829206c045cbcbc780aab656b14c321",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/power.h",
  "human_readable_source": " \n#include <linux/suspend.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/utsname.h>\n#include <linux/freezer.h>\n#include <linux/compiler.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n\nstruct swsusp_info {\n\tstruct new_utsname\tuts;\n\tu32\t\t\tversion_code;\n\tunsigned long\t\tnum_physpages;\n\tint\t\t\tcpus;\n\tunsigned long\t\timage_pages;\n\tunsigned long\t\tpages;\n\tunsigned long\t\tsize;\n} __aligned(PAGE_SIZE);\n\n#ifdef CONFIG_HIBERNATION\n \nextern void __init hibernate_reserved_size_init(void);\nextern void __init hibernate_image_size_init(void);\n\n#ifdef CONFIG_ARCH_HIBERNATION_HEADER\n \n#define MAX_ARCH_HEADER_SIZE\t(sizeof(struct new_utsname) + 4)\n\nstatic inline int init_header_complete(struct swsusp_info *info)\n{\n\treturn arch_hibernation_header_save(info, MAX_ARCH_HEADER_SIZE);\n}\n\nstatic inline const char *check_image_kernel(struct swsusp_info *info)\n{\n\treturn arch_hibernation_header_restore(info) ?\n\t\t\t\"architecture specific data\" : NULL;\n}\n#endif  \n\n \n#define PAGES_FOR_IO\t((4096 * 1024) >> PAGE_SHIFT)\n\n \n#define SPARE_PAGES\t((1024 * 1024) >> PAGE_SHIFT)\n\nasmlinkage int swsusp_save(void);\n\n \nextern bool freezer_test_done;\n\nextern int hibernation_snapshot(int platform_mode);\nextern int hibernation_restore(int platform_mode);\nextern int hibernation_platform_enter(void);\n\n#ifdef CONFIG_STRICT_KERNEL_RWX\n \nextern void enable_restore_image_protection(void);\n#else\nstatic inline void enable_restore_image_protection(void) {}\n#endif  \n\n#else  \n\nstatic inline void hibernate_reserved_size_init(void) {}\nstatic inline void hibernate_image_size_init(void) {}\n#endif  \n\n#define power_attr(_name) \\\nstatic struct kobj_attribute _name##_attr = {\t\\\n\t.attr\t= {\t\t\t\t\\\n\t\t.name = __stringify(_name),\t\\\n\t\t.mode = 0644,\t\t\t\\\n\t},\t\t\t\t\t\\\n\t.show\t= _name##_show,\t\t\t\\\n\t.store\t= _name##_store,\t\t\\\n}\n\n#define power_attr_ro(_name) \\\nstatic struct kobj_attribute _name##_attr = {\t\\\n\t.attr\t= {\t\t\t\t\\\n\t\t.name = __stringify(_name),\t\\\n\t\t.mode = S_IRUGO,\t\t\\\n\t},\t\t\t\t\t\\\n\t.show\t= _name##_show,\t\t\t\\\n}\n\n \nextern unsigned long image_size;\n \nextern unsigned long reserved_size;\nextern int in_suspend;\nextern dev_t swsusp_resume_device;\nextern sector_t swsusp_resume_block;\n\nextern int create_basic_memory_bitmaps(void);\nextern void free_basic_memory_bitmaps(void);\nextern int hibernate_preallocate_memory(void);\n\nextern void clear_or_poison_free_pages(void);\n\n \n\nstruct snapshot_handle {\n\tunsigned int\tcur;\t \n\tvoid\t\t*buffer;\t \n\tint\t\tsync_read;\t \n};\n\n \n#define data_of(handle)\t((handle).buffer)\n\nextern unsigned int snapshot_additional_pages(struct zone *zone);\nextern unsigned long snapshot_get_image_size(void);\nextern int snapshot_read_next(struct snapshot_handle *handle);\nextern int snapshot_write_next(struct snapshot_handle *handle);\nextern void snapshot_write_finalize(struct snapshot_handle *handle);\nextern int snapshot_image_loaded(struct snapshot_handle *handle);\n\nextern bool hibernate_acquire(void);\nextern void hibernate_release(void);\n\nextern sector_t alloc_swapdev_block(int swap);\nextern void free_all_swap_pages(int swap);\nextern int swsusp_swap_in_use(void);\n\n \n#define SF_PLATFORM_MODE\t1\n#define SF_NOCOMPRESS_MODE\t2\n#define SF_CRC32_MODE\t        4\n#define SF_HW_SIG\t\t8\n\n \nint swsusp_check(bool exclusive);\nextern void swsusp_free(void);\nextern int swsusp_read(unsigned int *flags_p);\nextern int swsusp_write(unsigned int flags);\nvoid swsusp_close(bool exclusive);\n#ifdef CONFIG_SUSPEND\nextern int swsusp_unmark(void);\n#endif\n\nstruct __kernel_old_timeval;\n \nextern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);\n\n#ifdef CONFIG_SUSPEND\n \nextern const char * const pm_labels[];\nextern const char *pm_states[];\nextern const char *mem_sleep_states[];\n\nextern int suspend_devices_and_enter(suspend_state_t state);\n#else  \n#define mem_sleep_current\tPM_SUSPEND_ON\n\nstatic inline int suspend_devices_and_enter(suspend_state_t state)\n{\n\treturn -ENOSYS;\n}\n#endif  \n\n#ifdef CONFIG_PM_TEST_SUSPEND\n \nextern void suspend_test_start(void);\nextern void suspend_test_finish(const char *label);\n#else  \nstatic inline void suspend_test_start(void) {}\nstatic inline void suspend_test_finish(const char *label) {}\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\n \nextern int pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down);\nextern int pm_notifier_call_chain(unsigned long val);\nvoid pm_restrict_gfp_mask(void);\nvoid pm_restore_gfp_mask(void);\n#else\nstatic inline void pm_restrict_gfp_mask(void) {}\nstatic inline void pm_restore_gfp_mask(void) {}\n#endif\n\n#ifdef CONFIG_HIGHMEM\nint restore_highmem(void);\n#else\nstatic inline unsigned int count_highmem_pages(void) { return 0; }\nstatic inline int restore_highmem(void) { return 0; }\n#endif\n\n \nenum {\n\t \n\tTEST_NONE,\n\tTEST_CORE,\n\tTEST_CPUS,\n\tTEST_PLATFORM,\n\tTEST_DEVICES,\n\tTEST_FREEZER,\n\t \n\t__TEST_AFTER_LAST\n};\n\n#define TEST_FIRST\tTEST_NONE\n#define TEST_MAX\t(__TEST_AFTER_LAST - 1)\n\n#ifdef CONFIG_PM_SLEEP_DEBUG\nextern int pm_test_level;\n#else\n#define pm_test_level\t(TEST_NONE)\n#endif\n\n#ifdef CONFIG_SUSPEND_FREEZER\nstatic inline int suspend_freeze_processes(void)\n{\n\tint error;\n\n\terror = freeze_processes();\n\t \n\tif (error)\n\t\treturn error;\n\n\terror = freeze_kernel_threads();\n\t \n\tif (error)\n\t\tthaw_processes();\n\n\treturn error;\n}\n\nstatic inline void suspend_thaw_processes(void)\n{\n\tthaw_processes();\n}\n#else\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}\n\nstatic inline void suspend_thaw_processes(void)\n{\n}\n#endif\n\n#ifdef CONFIG_PM_AUTOSLEEP\n\n \nextern int pm_autosleep_init(void);\nextern int pm_autosleep_lock(void);\nextern void pm_autosleep_unlock(void);\nextern suspend_state_t pm_autosleep_state(void);\nextern int pm_autosleep_set_state(suspend_state_t state);\n\n#else  \n\nstatic inline int pm_autosleep_init(void) { return 0; }\nstatic inline int pm_autosleep_lock(void) { return 0; }\nstatic inline void pm_autosleep_unlock(void) {}\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }\n\n#endif  \n\n#ifdef CONFIG_PM_WAKELOCKS\n\n \nextern ssize_t pm_show_wakelocks(char *buf, bool show_active);\nextern int pm_wake_lock(const char *buf);\nextern int pm_wake_unlock(const char *buf);\n\n#endif  \n\nstatic inline int pm_sleep_disable_secondary_cpus(void)\n{\n\tcpuidle_pause();\n\treturn suspend_disable_secondary_cpus();\n}\n\nstatic inline void pm_sleep_enable_secondary_cpus(void)\n{\n\tsuspend_enable_secondary_cpus();\n\tcpuidle_resume();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}