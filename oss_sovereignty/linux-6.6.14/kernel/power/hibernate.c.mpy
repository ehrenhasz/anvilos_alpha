{
  "module_name": "hibernate.c",
  "hash_id": "abc25b8c285327846e8caedbb3324e1047d62f3e526c4c968e347176d32ec2ce",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/hibernate.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PM: hibernation: \" fmt\n\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/async.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/pm.h>\n#include <linux/nmi.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/gfp.h>\n#include <linux/syscore_ops.h>\n#include <linux/ctype.h>\n#include <linux/ktime.h>\n#include <linux/security.h>\n#include <linux/secretmem.h>\n#include <trace/events/power.h>\n\n#include \"power.h\"\n\n\nstatic int nocompress;\nstatic int noresume;\nstatic int nohibernate;\nstatic int resume_wait;\nstatic unsigned int resume_delay;\nstatic char resume_file[256] = CONFIG_PM_STD_PARTITION;\ndev_t swsusp_resume_device;\nsector_t swsusp_resume_block;\n__visible int in_suspend __nosavedata;\n\nenum {\n\tHIBERNATION_INVALID,\n\tHIBERNATION_PLATFORM,\n\tHIBERNATION_SHUTDOWN,\n\tHIBERNATION_REBOOT,\n#ifdef CONFIG_SUSPEND\n\tHIBERNATION_SUSPEND,\n#endif\n\tHIBERNATION_TEST_RESUME,\n\t \n\t__HIBERNATION_AFTER_LAST\n};\n#define HIBERNATION_MAX (__HIBERNATION_AFTER_LAST-1)\n#define HIBERNATION_FIRST (HIBERNATION_INVALID + 1)\n\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\n\nbool freezer_test_done;\n\nstatic const struct platform_hibernation_ops *hibernation_ops;\n\nstatic atomic_t hibernate_atomic = ATOMIC_INIT(1);\n\nbool hibernate_acquire(void)\n{\n\treturn atomic_add_unless(&hibernate_atomic, -1, 0);\n}\n\nvoid hibernate_release(void)\n{\n\tatomic_inc(&hibernate_atomic);\n}\n\nbool hibernation_available(void)\n{\n\treturn nohibernate == 0 &&\n\t\t!security_locked_down(LOCKDOWN_HIBERNATION) &&\n\t\t!secretmem_active() && !cxl_mem_active();\n}\n\n \nvoid hibernation_set_ops(const struct platform_hibernation_ops *ops)\n{\n\tunsigned int sleep_flags;\n\n\tif (ops && !(ops->begin && ops->end &&  ops->pre_snapshot\n\t    && ops->prepare && ops->finish && ops->enter && ops->pre_restore\n\t    && ops->restore_cleanup && ops->leave)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tsleep_flags = lock_system_sleep();\n\n\thibernation_ops = ops;\n\tif (ops)\n\t\thibernation_mode = HIBERNATION_PLATFORM;\n\telse if (hibernation_mode == HIBERNATION_PLATFORM)\n\t\thibernation_mode = HIBERNATION_SHUTDOWN;\n\n\tunlock_system_sleep(sleep_flags);\n}\nEXPORT_SYMBOL_GPL(hibernation_set_ops);\n\nstatic bool entering_platform_hibernation;\n\nbool system_entering_hibernation(void)\n{\n\treturn entering_platform_hibernation;\n}\nEXPORT_SYMBOL(system_entering_hibernation);\n\n#ifdef CONFIG_PM_DEBUG\nstatic void hibernation_debug_sleep(void)\n{\n\tpr_info(\"debug: Waiting for 5 seconds.\\n\");\n\tmdelay(5000);\n}\n\nstatic int hibernation_test(int level)\n{\n\tif (pm_test_level == level) {\n\t\thibernation_debug_sleep();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n#else  \nstatic int hibernation_test(int level) { return 0; }\n#endif  \n\n \nstatic int platform_begin(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->begin(PMSG_FREEZE) : 0;\n}\n\n \nstatic void platform_end(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->end();\n}\n\n \n\nstatic int platform_pre_snapshot(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_snapshot() : 0;\n}\n\n \nstatic void platform_leave(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->leave();\n}\n\n \nstatic void platform_finish(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->finish();\n}\n\n \nstatic int platform_pre_restore(int platform_mode)\n{\n\treturn (platform_mode && hibernation_ops) ?\n\t\thibernation_ops->pre_restore() : 0;\n}\n\n \nstatic void platform_restore_cleanup(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops)\n\t\thibernation_ops->restore_cleanup();\n}\n\n \nstatic void platform_recover(int platform_mode)\n{\n\tif (platform_mode && hibernation_ops && hibernation_ops->recover)\n\t\thibernation_ops->recover();\n}\n\n \nvoid swsusp_show_speed(ktime_t start, ktime_t stop,\n\t\t      unsigned nr_pages, char *msg)\n{\n\tktime_t diff;\n\tu64 elapsed_centisecs64;\n\tunsigned int centisecs;\n\tunsigned int k;\n\tunsigned int kps;\n\n\tdiff = ktime_sub(stop, start);\n\telapsed_centisecs64 = ktime_divns(diff, 10*NSEC_PER_MSEC);\n\tcentisecs = elapsed_centisecs64;\n\tif (centisecs == 0)\n\t\tcentisecs = 1;\t \n\tk = nr_pages * (PAGE_SIZE / 1024);\n\tkps = (k * 100) / centisecs;\n\tpr_info(\"%s %u kbytes in %u.%02u seconds (%u.%02u MB/s)\\n\",\n\t\tmsg, k, centisecs / 100, centisecs % 100, kps / 1000,\n\t\t(kps % 1000) / 10);\n}\n\n__weak int arch_resume_nosmt(void)\n{\n\treturn 0;\n}\n\n \nstatic int create_image(int platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_snapshot(platform_mode);\n\tif (error || hibernation_test(TEST_PLATFORM))\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error || hibernation_test(TEST_CPUS))\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error) {\n\t\tpr_err(\"Some system devices failed to power down, aborting\\n\");\n\t\tgoto Enable_irqs;\n\t}\n\n\tif (hibernation_test(TEST_CORE) || pm_wakeup_pending())\n\t\tgoto Power_up;\n\n\tin_suspend = 1;\n\tsave_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, true);\n\terror = swsusp_arch_suspend();\n\t \n\trestore_processor_state();\n\ttrace_suspend_resume(TPS(\"machine_suspend\"), PM_EVENT_HIBERNATE, false);\n\tif (error)\n\t\tpr_err(\"Error %d creating image\\n\", error);\n\n\tif (!in_suspend) {\n\t\tevents_check_enabled = false;\n\t\tclear_or_poison_free_pages();\n\t}\n\n\tplatform_leave(platform_mode);\n\n Power_up:\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n\t \n\tif (!in_suspend)\n\t\terror = arch_resume_nosmt();\n\n Platform_finish:\n\tplatform_finish(platform_mode);\n\n\tdpm_resume_start(in_suspend ?\n\t\t(error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE);\n\n\treturn error;\n}\n\n \nint hibernation_snapshot(int platform_mode)\n{\n\tpm_message_t msg;\n\tint error;\n\n\tpm_suspend_clear_flags();\n\terror = platform_begin(platform_mode);\n\tif (error)\n\t\tgoto Close;\n\n\t \n\terror = hibernate_preallocate_memory();\n\tif (error)\n\t\tgoto Close;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto Cleanup;\n\n\tif (hibernation_test(TEST_FREEZER)) {\n\n\t\t \n\t\tfreezer_test_done = true;\n\t\tgoto Thaw;\n\t}\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error) {\n\t\tdpm_complete(PMSG_RECOVER);\n\t\tgoto Thaw;\n\t}\n\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\n\tif (error || hibernation_test(TEST_DEVICES))\n\t\tplatform_recover(platform_mode);\n\telse\n\t\terror = create_image(platform_mode);\n\n\t \n\n\t \n\tif (error || !in_suspend)\n\t\tswsusp_free();\n\n\tmsg = in_suspend ? (error ? PMSG_RECOVER : PMSG_THAW) : PMSG_RESTORE;\n\tdpm_resume(msg);\n\n\tif (error || !in_suspend)\n\t\tpm_restore_gfp_mask();\n\n\tresume_console();\n\tdpm_complete(msg);\n\n Close:\n\tplatform_end(platform_mode);\n\treturn error;\n\n Thaw:\n\tthaw_kernel_threads();\n Cleanup:\n\tswsusp_free();\n\tgoto Close;\n}\n\nint __weak hibernate_resume_nonboot_cpu_disable(void)\n{\n\treturn suspend_disable_secondary_cpus();\n}\n\n \nstatic int resume_target_kernel(bool platform_mode)\n{\n\tint error;\n\n\terror = dpm_suspend_end(PMSG_QUIESCE);\n\tif (error) {\n\t\tpr_err(\"Some devices failed to power down, aborting resume\\n\");\n\t\treturn error;\n\t}\n\n\terror = platform_pre_restore(platform_mode);\n\tif (error)\n\t\tgoto Cleanup;\n\n\tcpuidle_pause();\n\n\terror = hibernate_resume_nonboot_cpu_disable();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\n\terror = syscore_suspend();\n\tif (error)\n\t\tgoto Enable_irqs;\n\n\tsave_processor_state();\n\terror = restore_highmem();\n\tif (!error) {\n\t\terror = swsusp_arch_resume();\n\t\t \n\t\tBUG_ON(!error);\n\t\t \n\t\trestore_highmem();\n\t}\n\t \n\tswsusp_free();\n\trestore_processor_state();\n\ttouch_softlockup_watchdog();\n\n\tsyscore_resume();\n\n Enable_irqs:\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Cleanup:\n\tplatform_restore_cleanup(platform_mode);\n\n\tdpm_resume_start(PMSG_RECOVER);\n\n\treturn error;\n}\n\n \nint hibernation_restore(int platform_mode)\n{\n\tint error;\n\n\tpm_prepare_console();\n\tsuspend_console();\n\tpm_restrict_gfp_mask();\n\terror = dpm_suspend_start(PMSG_QUIESCE);\n\tif (!error) {\n\t\terror = resume_target_kernel(platform_mode);\n\t\t \n\t\tBUG_ON(!error);\n\t}\n\tdpm_resume_end(PMSG_RECOVER);\n\tpm_restore_gfp_mask();\n\tresume_console();\n\tpm_restore_console();\n\treturn error;\n}\n\n \nint hibernation_platform_enter(void)\n{\n\tint error;\n\n\tif (!hibernation_ops)\n\t\treturn -ENOSYS;\n\n\t \n\terror = hibernation_ops->begin(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Close;\n\n\tentering_platform_hibernation = true;\n\tsuspend_console();\n\terror = dpm_suspend_start(PMSG_HIBERNATE);\n\tif (error) {\n\t\tif (hibernation_ops->recover)\n\t\t\thibernation_ops->recover();\n\t\tgoto Resume_devices;\n\t}\n\n\terror = dpm_suspend_end(PMSG_HIBERNATE);\n\tif (error)\n\t\tgoto Resume_devices;\n\n\terror = hibernation_ops->prepare();\n\tif (error)\n\t\tgoto Platform_finish;\n\n\terror = pm_sleep_disable_secondary_cpus();\n\tif (error)\n\t\tgoto Enable_cpus;\n\n\tlocal_irq_disable();\n\tsystem_state = SYSTEM_SUSPEND;\n\tsyscore_suspend();\n\tif (pm_wakeup_pending()) {\n\t\terror = -EAGAIN;\n\t\tgoto Power_up;\n\t}\n\n\thibernation_ops->enter();\n\t \n\twhile (1);\n\n Power_up:\n\tsyscore_resume();\n\tsystem_state = SYSTEM_RUNNING;\n\tlocal_irq_enable();\n\n Enable_cpus:\n\tpm_sleep_enable_secondary_cpus();\n\n Platform_finish:\n\thibernation_ops->finish();\n\n\tdpm_resume_start(PMSG_RESTORE);\n\n Resume_devices:\n\tentering_platform_hibernation = false;\n\tdpm_resume_end(PMSG_RESTORE);\n\tresume_console();\n\n Close:\n\thibernation_ops->end();\n\n\treturn error;\n}\n\n \nstatic void power_down(void)\n{\n#ifdef CONFIG_SUSPEND\n\tint error;\n\n\tif (hibernation_mode == HIBERNATION_SUSPEND) {\n\t\terror = suspend_devices_and_enter(mem_sleep_current);\n\t\tif (error) {\n\t\t\thibernation_mode = hibernation_ops ?\n\t\t\t\t\t\tHIBERNATION_PLATFORM :\n\t\t\t\t\t\tHIBERNATION_SHUTDOWN;\n\t\t} else {\n\t\t\t \n\t\t\terror = swsusp_unmark();\n\t\t\tif (error)\n\t\t\t\tpr_err(\"Swap will be unusable! Try swapon -a.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tswitch (hibernation_mode) {\n\tcase HIBERNATION_REBOOT:\n\t\tkernel_restart(NULL);\n\t\tbreak;\n\tcase HIBERNATION_PLATFORM:\n\t\thibernation_platform_enter();\n\t\tfallthrough;\n\tcase HIBERNATION_SHUTDOWN:\n\t\tif (kernel_can_power_off())\n\t\t\tkernel_power_off();\n\t\tbreak;\n\t}\n\tkernel_halt();\n\t \n\tpr_crit(\"Power down manually\\n\");\n\twhile (1)\n\t\tcpu_relax();\n}\n\nstatic int load_image_and_restore(bool snapshot_test)\n{\n\tint error;\n\tunsigned int flags;\n\n\tpm_pr_dbg(\"Loading hibernation image.\\n\");\n\n\tlock_device_hotplug();\n\terror = create_basic_memory_bitmaps();\n\tif (error) {\n\t\tswsusp_close(snapshot_test);\n\t\tgoto Unlock;\n\t}\n\n\terror = swsusp_read(&flags);\n\tswsusp_close(snapshot_test);\n\tif (!error)\n\t\terror = hibernation_restore(flags & SF_PLATFORM_MODE);\n\n\tpr_err(\"Failed to load image, recovering.\\n\");\n\tswsusp_free();\n\tfree_basic_memory_bitmaps();\n Unlock:\n\tunlock_device_hotplug();\n\n\treturn error;\n}\n\n \nint hibernate(void)\n{\n\tbool snapshot_test = false;\n\tunsigned int sleep_flags;\n\tint error;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tsleep_flags = lock_system_sleep();\n\t \n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto Restore;\n\n\tksys_sync_helper();\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t \n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing hibernation image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Hibernation image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check(false);\n\t\tif (!error)\n\t\t\terror = load_image_and_restore(false);\n\t}\n\tthaw_processes();\n\n\t \n\tfreezer_test_done = false;\n Exit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n Restore:\n\tpm_restore_console();\n\thibernate_release();\n Unlock:\n\tunlock_system_sleep(sleep_flags);\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}\n\n \nint hibernate_quiet_exec(int (*func)(void *data), void *data)\n{\n\tunsigned int sleep_flags;\n\tint error;\n\n\tsleep_flags = lock_system_sleep();\n\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tpm_prepare_console();\n\n\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\tif (error)\n\t\tgoto restore;\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto exit;\n\n\tlock_device_hotplug();\n\n\tpm_suspend_clear_flags();\n\n\terror = platform_begin(true);\n\tif (error)\n\t\tgoto thaw;\n\n\terror = freeze_kernel_threads();\n\tif (error)\n\t\tgoto thaw;\n\n\terror = dpm_prepare(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_complete;\n\n\tsuspend_console();\n\n\terror = dpm_suspend(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_resume;\n\n\terror = dpm_suspend_end(PMSG_FREEZE);\n\tif (error)\n\t\tgoto dpm_resume;\n\n\terror = platform_pre_snapshot(true);\n\tif (error)\n\t\tgoto skip;\n\n\terror = func(data);\n\nskip:\n\tplatform_finish(true);\n\n\tdpm_resume_start(PMSG_THAW);\n\ndpm_resume:\n\tdpm_resume(PMSG_THAW);\n\n\tresume_console();\n\ndpm_complete:\n\tdpm_complete(PMSG_THAW);\n\n\tthaw_kernel_threads();\n\nthaw:\n\tplatform_end(true);\n\n\tunlock_device_hotplug();\n\n\tthaw_processes();\n\nexit:\n\tpm_notifier_call_chain(PM_POST_HIBERNATION);\n\nrestore:\n\tpm_restore_console();\n\n\thibernate_release();\n\nunlock:\n\tunlock_system_sleep(sleep_flags);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(hibernate_quiet_exec);\n\nstatic int __init find_resume_device(void)\n{\n\tif (!strlen(resume_file))\n\t\treturn -ENOENT;\n\n\tpm_pr_dbg(\"Checking hibernation image partition %s\\n\", resume_file);\n\n\tif (resume_delay) {\n\t\tpr_info(\"Waiting %dsec before reading resume device ...\\n\",\n\t\t\tresume_delay);\n\t\tssleep(resume_delay);\n\t}\n\n\t \n\tif (!early_lookup_bdev(resume_file, &swsusp_resume_device))\n\t\treturn 0;\n\n\t \n\twait_for_device_probe();\n\tif (resume_wait) {\n\t\twhile (early_lookup_bdev(resume_file, &swsusp_resume_device))\n\t\t\tmsleep(10);\n\t\tasync_synchronize_full();\n\t}\n\n\treturn early_lookup_bdev(resume_file, &swsusp_resume_device);\n}\n\nstatic int software_resume(void)\n{\n\tint error;\n\n\tpm_pr_dbg(\"Hibernation image partition %d:%d present\\n\",\n\t\tMAJOR(swsusp_resume_device), MINOR(swsusp_resume_device));\n\n\tpm_pr_dbg(\"Looking for hibernation image.\\n\");\n\n\tmutex_lock(&system_transition_mutex);\n\terror = swsusp_check(true);\n\tif (error)\n\t\tgoto Unlock;\n\n\t \n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tswsusp_close(true);\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"resume from hibernation\\n\");\n\tpm_prepare_console();\n\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\tif (error)\n\t\tgoto Restore;\n\n\tpm_pr_dbg(\"Preparing processes for hibernation restore.\\n\");\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Close_Finish;\n\n\terror = freeze_kernel_threads();\n\tif (error) {\n\t\tthaw_processes();\n\t\tgoto Close_Finish;\n\t}\n\n\terror = load_image_and_restore(true);\n\tthaw_processes();\n Finish:\n\tpm_notifier_call_chain(PM_POST_RESTORE);\n Restore:\n\tpm_restore_console();\n\tpr_info(\"resume failed (%d)\\n\", error);\n\thibernate_release();\n\t \n Unlock:\n\tmutex_unlock(&system_transition_mutex);\n\tpm_pr_dbg(\"Hibernation image not present or could not be loaded.\\n\");\n\treturn error;\n Close_Finish:\n\tswsusp_close(true);\n\tgoto Finish;\n}\n\n \nstatic int __init software_resume_initcall(void)\n{\n\t \n\tif (noresume || !hibernation_available())\n\t\treturn 0;\n\n\tif (!swsusp_resume_device) {\n\t\tint error = find_resume_device();\n\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn software_resume();\n}\nlate_initcall_sync(software_resume_initcall);\n\n\nstatic const char * const hibernation_modes[] = {\n\t[HIBERNATION_PLATFORM]\t= \"platform\",\n\t[HIBERNATION_SHUTDOWN]\t= \"shutdown\",\n\t[HIBERNATION_REBOOT]\t= \"reboot\",\n#ifdef CONFIG_SUSPEND\n\t[HIBERNATION_SUSPEND]\t= \"suspend\",\n#endif\n\t[HIBERNATION_TEST_RESUME]\t= \"test_resume\",\n};\n\n \n\nstatic ssize_t disk_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tint i;\n\tchar *start = buf;\n\n\tif (!hibernation_available())\n\t\treturn sprintf(buf, \"[disabled]\\n\");\n\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}\n\nstatic ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint mode = HIBERNATION_INVALID;\n\tunsigned int sleep_flags;\n\tint error = 0;\n\tint len;\n\tchar *p;\n\tint i;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tsleep_flags = lock_system_sleep();\n\tfor (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != HIBERNATION_INVALID) {\n\t\tswitch (mode) {\n\t\tcase HIBERNATION_SHUTDOWN:\n\t\tcase HIBERNATION_REBOOT:\n#ifdef CONFIG_SUSPEND\n\t\tcase HIBERNATION_SUSPEND:\n#endif\n\t\tcase HIBERNATION_TEST_RESUME:\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase HIBERNATION_PLATFORM:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -EINVAL;\n\t\t}\n\t} else\n\t\terror = -EINVAL;\n\n\tif (!error)\n\t\tpm_pr_dbg(\"Hibernation mode set to '%s'\\n\",\n\t\t\t       hibernation_modes[mode]);\n\tunlock_system_sleep(sleep_flags);\n\treturn error ? error : n;\n}\n\npower_attr(disk);\n\nstatic ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"%d:%d\\n\", MAJOR(swsusp_resume_device),\n\t\t       MINOR(swsusp_resume_device));\n}\n\nstatic ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tunsigned int sleep_flags;\n\tint len = n;\n\tchar *name;\n\tdev_t dev;\n\tint error;\n\n\tif (!hibernation_available())\n\t\treturn n;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\terror = lookup_bdev(name, &dev);\n\tif (error) {\n\t\tunsigned maj, min, offset;\n\t\tchar *p, dummy;\n\n\t\terror = 0;\n\t\tif (sscanf(name, \"%u:%u%c\", &maj, &min, &dummy) == 2 ||\n\t\t    sscanf(name, \"%u:%u:%u:%c\", &maj, &min, &offset,\n\t\t\t\t&dummy) == 3) {\n\t\t\tdev = MKDEV(maj, min);\n\t\t\tif (maj != MAJOR(dev) || min != MINOR(dev))\n\t\t\t\terror = -EINVAL;\n\t\t} else {\n\t\t\tdev = new_decode_dev(simple_strtoul(name, &p, 16));\n\t\t\tif (*p)\n\t\t\t\terror = -EINVAL;\n\t\t}\n\t}\n\tkfree(name);\n\tif (error)\n\t\treturn error;\n\n\tsleep_flags = lock_system_sleep();\n\tswsusp_resume_device = dev;\n\tunlock_system_sleep(sleep_flags);\n\n\tpm_pr_dbg(\"Configured hibernation resume from disk to %u\\n\",\n\t\t  swsusp_resume_device);\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}\n\npower_attr(resume);\n\nstatic ssize_t resume_offset_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long)swsusp_resume_block);\n}\n\nstatic ssize_t resume_offset_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, const char *buf,\n\t\t\t\t   size_t n)\n{\n\tunsigned long long offset;\n\tint rc;\n\n\trc = kstrtoull(buf, 0, &offset);\n\tif (rc)\n\t\treturn rc;\n\tswsusp_resume_block = offset;\n\n\treturn n;\n}\n\npower_attr(resume_offset);\n\nstatic ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}\n\nstatic ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}\n\npower_attr(image_size);\n\nstatic ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}\n\nstatic ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -EINVAL;\n}\n\npower_attr(reserved_size);\n\nstatic struct attribute *g[] = {\n\t&disk_attr.attr,\n\t&resume_offset_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tNULL,\n};\n\n\nstatic const struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\n\nstatic int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}\n\ncore_initcall(pm_disk_init);\n\n\nstatic int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy(resume_file, str, 255);\n\treturn 1;\n}\n\nstatic int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}\n\nstatic int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8)) {\n\t\tnoresume = 1;\n\t} else if (!strncmp(str, \"nocompress\", 10)) {\n\t\tnocompress = 1;\n\t} else if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t} else if (IS_ENABLED(CONFIG_STRICT_KERNEL_RWX)\n\t\t   && !strncmp(str, \"protect_image\", 13)) {\n\t\tenable_restore_image_protection();\n\t}\n\treturn 1;\n}\n\nstatic int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}\n\nstatic int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}\n\nstatic int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\tpr_warn(\"resumedelay: bad option string '%s'\\n\", str);\n\treturn 1;\n}\n\nstatic int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}\n\n__setup(\"noresume\", noresume_setup);\n__setup(\"resume_offset=\", resume_offset_setup);\n__setup(\"resume=\", resume_setup);\n__setup(\"hibernate=\", hibernate_setup);\n__setup(\"resumewait\", resumewait_setup);\n__setup(\"resumedelay=\", resumedelay_setup);\n__setup(\"nohibernate\", nohibernate_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}