{
  "module_name": "wakelock.c",
  "hash_id": "4809dc3fe9e09fdf7462a2cc05e02072a7e4f0a915291d094391e68df69bad08",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/wakelock.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/hrtimer.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"power.h\"\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nstruct wakelock {\n\tchar\t\t\t*name;\n\tstruct rb_node\t\tnode;\n\tstruct wakeup_source\t*ws;\n#ifdef CONFIG_PM_WAKELOCKS_GC\n\tstruct list_head\tlru;\n#endif\n};\n\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tint len = 0;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws->active == show_active)\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s \", wl->name);\n\t}\n\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn len;\n}\n\n#if CONFIG_PM_WAKELOCKS_LIMIT > 0\nstatic unsigned int number_of_wakelocks;\n\nstatic inline bool wakelocks_limit_exceeded(void)\n{\n\treturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;\n}\n\nstatic inline void increment_wakelocks_number(void)\n{\n\tnumber_of_wakelocks++;\n}\n\nstatic inline void decrement_wakelocks_number(void)\n{\n\tnumber_of_wakelocks--;\n}\n#else  \nstatic inline bool wakelocks_limit_exceeded(void) { return false; }\nstatic inline void increment_wakelocks_number(void) {}\nstatic inline void decrement_wakelocks_number(void) {}\n#endif  \n\n#ifdef CONFIG_PM_WAKELOCKS_GC\n#define WL_GC_COUNT_MAX\t100\n#define WL_GC_TIME_SEC\t300\n\nstatic void __wakelocks_gc(struct work_struct *work);\nstatic LIST_HEAD(wakelocks_lru_list);\nstatic DECLARE_WORK(wakelock_work, __wakelocks_gc);\nstatic unsigned int wakelocks_gc_count;\n\nstatic inline void wakelocks_lru_add(struct wakelock *wl)\n{\n\tlist_add(&wl->lru, &wakelocks_lru_list);\n}\n\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl)\n{\n\tlist_move(&wl->lru, &wakelocks_lru_list);\n}\n\nstatic void __wakelocks_gc(struct work_struct *work)\n{\n\tstruct wakelock *wl, *aux;\n\tktime_t now;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->ws->lock);\n\t\tidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws->last_time));\n\t\tactive = wl->ws->active;\n\t\tspin_unlock_irq(&wl->ws->lock);\n\n\t\tif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_unregister(wl->ws);\n\t\t\trb_erase(&wl->node, &wakelocks_tree);\n\t\t\tlist_del(&wl->lru);\n\t\t\tkfree(wl->name);\n\t\t\tkfree(wl);\n\t\t\tdecrement_wakelocks_number();\n\t\t}\n\t}\n\twakelocks_gc_count = 0;\n\n\tmutex_unlock(&wakelocks_lock);\n}\n\nstatic void wakelocks_gc(void)\n{\n\tif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)\n\t\treturn;\n\n\tschedule_work(&wakelock_work);\n}\n#else  \nstatic inline void wakelocks_lru_add(struct wakelock *wl) {}\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}\nstatic inline void wakelocks_gc(void) {}\n#endif  \n\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\n\t\t\t\t\t    bool add_if_not_found)\n{\n\tstruct rb_node **node = &wakelocks_tree.rb_node;\n\tstruct rb_node *parent = *node;\n\tstruct wakelock *wl;\n\n\twhile (*node) {\n\t\tint diff;\n\n\t\tparent = *node;\n\t\twl = rb_entry(*node, struct wakelock, node);\n\t\tdiff = strncmp(name, wl->name, len);\n\t\tif (diff == 0) {\n\t\t\tif (wl->name[len])\n\t\t\t\tdiff = -1;\n\t\t\telse\n\t\t\t\treturn wl;\n\t\t}\n\t\tif (diff < 0)\n\t\t\tnode = &(*node)->rb_left;\n\t\telse\n\t\t\tnode = &(*node)->rb_right;\n\t}\n\tif (!add_if_not_found)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (wakelocks_limit_exceeded())\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t \n\twl = kzalloc(sizeof(*wl), GFP_KERNEL);\n\tif (!wl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twl->name = kstrndup(name, len, GFP_KERNEL);\n\tif (!wl->name) {\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\twl->ws = wakeup_source_register(NULL, wl->name);\n\tif (!wl->ws) {\n\t\tkfree(wl->name);\n\t\tkfree(wl);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\twl->ws->last_time = ktime_get();\n\n\trb_link_node(&wl->node, parent, node);\n\trb_insert_color(&wl->node, &wakelocks_tree);\n\twakelocks_lru_add(wl);\n\tincrement_wakelocks_number();\n\treturn wl;\n}\n\nint pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t \n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}\n\nint pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}