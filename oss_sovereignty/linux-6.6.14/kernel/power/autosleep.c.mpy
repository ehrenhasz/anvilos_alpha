{
  "module_name": "autosleep.c",
  "hash_id": "87a2bd20f30a753a94cd7b7dda91f69da865509cfcc00c50ffcca313420f9005",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/autosleep.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/pm_wakeup.h>\n\n#include \"power.h\"\n\nstatic suspend_state_t autosleep_state;\nstatic struct workqueue_struct *autosleep_wq;\n \nstatic DEFINE_MUTEX(autosleep_lock);\nstatic struct wakeup_source *autosleep_ws;\n\nstatic void try_to_suspend(struct work_struct *work)\n{\n\tunsigned int initial_count, final_count;\n\n\tif (!pm_get_wakeup_count(&initial_count, true))\n\t\tgoto out;\n\n\tmutex_lock(&autosleep_lock);\n\n\tif (!pm_save_wakeup_count(initial_count) ||\n\t\tsystem_state != SYSTEM_RUNNING) {\n\t\tmutex_unlock(&autosleep_lock);\n\t\tgoto out;\n\t}\n\n\tif (autosleep_state == PM_SUSPEND_ON) {\n\t\tmutex_unlock(&autosleep_lock);\n\t\treturn;\n\t}\n\tif (autosleep_state >= PM_SUSPEND_MAX)\n\t\thibernate();\n\telse\n\t\tpm_suspend(autosleep_state);\n\n\tmutex_unlock(&autosleep_lock);\n\n\tif (!pm_get_wakeup_count(&final_count, false))\n\t\tgoto out;\n\n\t \n\tif (final_count == initial_count)\n\t\tschedule_timeout_uninterruptible(HZ / 2);\n\n out:\n\tqueue_up_suspend_work();\n}\n\nstatic DECLARE_WORK(suspend_work, try_to_suspend);\n\nvoid queue_up_suspend_work(void)\n{\n\tif (autosleep_state > PM_SUSPEND_ON)\n\t\tqueue_work(autosleep_wq, &suspend_work);\n}\n\nsuspend_state_t pm_autosleep_state(void)\n{\n\treturn autosleep_state;\n}\n\nint pm_autosleep_lock(void)\n{\n\treturn mutex_lock_interruptible(&autosleep_lock);\n}\n\nvoid pm_autosleep_unlock(void)\n{\n\tmutex_unlock(&autosleep_lock);\n}\n\nint pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}\n\nint __init pm_autosleep_init(void)\n{\n\tautosleep_ws = wakeup_source_register(NULL, \"autosleep\");\n\tif (!autosleep_ws)\n\t\treturn -ENOMEM;\n\n\tautosleep_wq = alloc_ordered_workqueue(\"autosleep\", 0);\n\tif (autosleep_wq)\n\t\treturn 0;\n\n\twakeup_source_unregister(autosleep_ws);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}