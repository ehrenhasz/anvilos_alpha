{
  "module_name": "energy_model.c",
  "hash_id": "804aede9d3a7ceae15555a7de3fc91613dbce4bcf1df6a43fba24029f031404f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/energy_model.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"energy_model: \" fmt\n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/debugfs.h>\n#include <linux/energy_model.h>\n#include <linux/sched/topology.h>\n#include <linux/slab.h>\n\n \nstatic DEFINE_MUTEX(em_pd_mutex);\n\nstatic bool _is_cpu_device(struct device *dev)\n{\n\treturn (dev->bus == &cpu_subsys);\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic struct dentry *rootdir;\n\nstatic void em_debug_create_ps(struct em_perf_state *ps, struct dentry *pd)\n{\n\tstruct dentry *d;\n\tchar name[24];\n\n\tsnprintf(name, sizeof(name), \"ps:%lu\", ps->frequency);\n\n\t \n\td = debugfs_create_dir(name, pd);\n\tdebugfs_create_ulong(\"frequency\", 0444, d, &ps->frequency);\n\tdebugfs_create_ulong(\"power\", 0444, d, &ps->power);\n\tdebugfs_create_ulong(\"cost\", 0444, d, &ps->cost);\n\tdebugfs_create_ulong(\"inefficient\", 0444, d, &ps->flags);\n}\n\nstatic int em_debug_cpus_show(struct seq_file *s, void *unused)\n{\n\tseq_printf(s, \"%*pbl\\n\", cpumask_pr_args(to_cpumask(s->private)));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(em_debug_cpus);\n\nstatic int em_debug_flags_show(struct seq_file *s, void *unused)\n{\n\tstruct em_perf_domain *pd = s->private;\n\n\tseq_printf(s, \"%#lx\\n\", pd->flags);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(em_debug_flags);\n\nstatic void em_debug_create_pd(struct device *dev)\n{\n\tstruct dentry *d;\n\tint i;\n\n\t \n\td = debugfs_create_dir(dev_name(dev), rootdir);\n\n\tif (_is_cpu_device(dev))\n\t\tdebugfs_create_file(\"cpus\", 0444, d, dev->em_pd->cpus,\n\t\t\t\t    &em_debug_cpus_fops);\n\n\tdebugfs_create_file(\"flags\", 0444, d, dev->em_pd,\n\t\t\t    &em_debug_flags_fops);\n\n\t \n\tfor (i = 0; i < dev->em_pd->nr_perf_states; i++)\n\t\tem_debug_create_ps(&dev->em_pd->table[i], d);\n\n}\n\nstatic void em_debug_remove_pd(struct device *dev)\n{\n\tdebugfs_lookup_and_remove(dev_name(dev), rootdir);\n}\n\nstatic int __init em_debug_init(void)\n{\n\t \n\trootdir = debugfs_create_dir(\"energy_model\", NULL);\n\n\treturn 0;\n}\nfs_initcall(em_debug_init);\n#else  \nstatic void em_debug_create_pd(struct device *dev) {}\nstatic void em_debug_remove_pd(struct device *dev) {}\n#endif\n\nstatic int em_create_perf_table(struct device *dev, struct em_perf_domain *pd,\n\t\t\t\tint nr_states, struct em_data_callback *cb,\n\t\t\t\tunsigned long flags)\n{\n\tunsigned long power, freq, prev_freq = 0, prev_cost = ULONG_MAX;\n\tstruct em_perf_state *table;\n\tint i, ret;\n\tu64 fmax;\n\n\ttable = kcalloc(nr_states, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0, freq = 0; i < nr_states; i++, freq++) {\n\t\t \n\t\tret = cb->active_power(dev, &power, &freq);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"EM: invalid perf. state: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t \n\t\tif (freq <= prev_freq) {\n\t\t\tdev_err(dev, \"EM: non-increasing freq: %lu\\n\",\n\t\t\t\tfreq);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\t \n\t\tif (!power || power > EM_MAX_POWER) {\n\t\t\tdev_err(dev, \"EM: invalid power: %lu\\n\",\n\t\t\t\tpower);\n\t\t\tgoto free_ps_table;\n\t\t}\n\n\t\ttable[i].power = power;\n\t\ttable[i].frequency = prev_freq = freq;\n\t}\n\n\t \n\tfmax = (u64) table[nr_states - 1].frequency;\n\tfor (i = nr_states - 1; i >= 0; i--) {\n\t\tunsigned long power_res, cost;\n\n\t\tif (flags & EM_PERF_DOMAIN_ARTIFICIAL) {\n\t\t\tret = cb->get_cost(dev, table[i].frequency, &cost);\n\t\t\tif (ret || !cost || cost > EM_MAX_POWER) {\n\t\t\t\tdev_err(dev, \"EM: invalid cost %lu %d\\n\",\n\t\t\t\t\tcost, ret);\n\t\t\t\tgoto free_ps_table;\n\t\t\t}\n\t\t} else {\n\t\t\tpower_res = table[i].power;\n\t\t\tcost = div64_u64(fmax * power_res, table[i].frequency);\n\t\t}\n\n\t\ttable[i].cost = cost;\n\n\t\tif (table[i].cost >= prev_cost) {\n\t\t\ttable[i].flags = EM_PERF_STATE_INEFFICIENT;\n\t\t\tdev_dbg(dev, \"EM: OPP:%lu is inefficient\\n\",\n\t\t\t\ttable[i].frequency);\n\t\t} else {\n\t\t\tprev_cost = table[i].cost;\n\t\t}\n\t}\n\n\tpd->table = table;\n\tpd->nr_perf_states = nr_states;\n\n\treturn 0;\n\nfree_ps_table:\n\tkfree(table);\n\treturn -EINVAL;\n}\n\nstatic int em_create_pd(struct device *dev, int nr_states,\n\t\t\tstruct em_data_callback *cb, cpumask_t *cpus,\n\t\t\tunsigned long flags)\n{\n\tstruct em_perf_domain *pd;\n\tstruct device *cpu_dev;\n\tint cpu, ret, num_cpus;\n\n\tif (_is_cpu_device(dev)) {\n\t\tnum_cpus = cpumask_weight(cpus);\n\n\t\t \n\t\tif (num_cpus > EM_MAX_NUM_CPUS) {\n\t\t\tdev_err(dev, \"EM: too many CPUs, overflow possible\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpd = kzalloc(sizeof(*pd) + cpumask_size(), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\n\t\tcpumask_copy(em_span_cpus(pd), cpus);\n\t} else {\n\t\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\t\tif (!pd)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = em_create_perf_table(dev, pd, nr_states, cb, flags);\n\tif (ret) {\n\t\tkfree(pd);\n\t\treturn ret;\n\t}\n\n\tif (_is_cpu_device(dev))\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tcpu_dev = get_cpu_device(cpu);\n\t\t\tcpu_dev->em_pd = pd;\n\t\t}\n\n\tdev->em_pd = pd;\n\n\treturn 0;\n}\n\nstatic void em_cpufreq_update_efficiencies(struct device *dev)\n{\n\tstruct em_perf_domain *pd = dev->em_pd;\n\tstruct em_perf_state *table;\n\tstruct cpufreq_policy *policy;\n\tint found = 0;\n\tint i;\n\n\tif (!_is_cpu_device(dev) || !pd)\n\t\treturn;\n\n\tpolicy = cpufreq_cpu_get(cpumask_first(em_span_cpus(pd)));\n\tif (!policy) {\n\t\tdev_warn(dev, \"EM: Access to CPUFreq policy failed\");\n\t\treturn;\n\t}\n\n\ttable = pd->table;\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\t\tif (!(table[i].flags & EM_PERF_STATE_INEFFICIENT))\n\t\t\tcontinue;\n\n\t\tif (!cpufreq_table_set_inefficient(policy, table[i].frequency))\n\t\t\tfound++;\n\t}\n\n\tcpufreq_cpu_put(policy);\n\n\tif (!found)\n\t\treturn;\n\n\t \n\tpd->flags |= EM_PERF_DOMAIN_SKIP_INEFFICIENCIES;\n}\n\n \nstruct em_perf_domain *em_pd_get(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn NULL;\n\n\treturn dev->em_pd;\n}\nEXPORT_SYMBOL_GPL(em_pd_get);\n\n \nstruct em_perf_domain *em_cpu_get(int cpu)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn NULL;\n\n\treturn em_pd_get(cpu_dev);\n}\nEXPORT_SYMBOL_GPL(em_cpu_get);\n\n \nint em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,\n\t\t\t\tstruct em_data_callback *cb, cpumask_t *cpus,\n\t\t\t\tbool microwatts)\n{\n\tunsigned long cap, prev_cap = 0;\n\tunsigned long flags = 0;\n\tint cpu, ret;\n\n\tif (!dev || !nr_states || !cb)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&em_pd_mutex);\n\n\tif (dev->em_pd) {\n\t\tret = -EEXIST;\n\t\tgoto unlock;\n\t}\n\n\tif (_is_cpu_device(dev)) {\n\t\tif (!cpus) {\n\t\t\tdev_err(dev, \"EM: invalid CPU mask\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tfor_each_cpu(cpu, cpus) {\n\t\t\tif (em_cpu_get(cpu)) {\n\t\t\t\tdev_err(dev, \"EM: exists for CPU%d\\n\", cpu);\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\t \n\t\t\tcap = arch_scale_cpu_capacity(cpu);\n\t\t\tif (prev_cap && prev_cap != cap) {\n\t\t\t\tdev_err(dev, \"EM: CPUs of %*pbl must have the same capacity\\n\",\n\t\t\t\t\tcpumask_pr_args(cpus));\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tprev_cap = cap;\n\t\t}\n\t}\n\n\tif (microwatts)\n\t\tflags |= EM_PERF_DOMAIN_MICROWATTS;\n\telse if (cb->get_cost)\n\t\tflags |= EM_PERF_DOMAIN_ARTIFICIAL;\n\n\tret = em_create_pd(dev, nr_states, cb, cpus, flags);\n\tif (ret)\n\t\tgoto unlock;\n\n\tdev->em_pd->flags |= flags;\n\n\tem_cpufreq_update_efficiencies(dev);\n\n\tem_debug_create_pd(dev);\n\tdev_info(dev, \"EM: created perf domain\\n\");\n\nunlock:\n\tmutex_unlock(&em_pd_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(em_dev_register_perf_domain);\n\n \nvoid em_dev_unregister_perf_domain(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev) || !dev->em_pd)\n\t\treturn;\n\n\tif (_is_cpu_device(dev))\n\t\treturn;\n\n\t \n\tmutex_lock(&em_pd_mutex);\n\tem_debug_remove_pd(dev);\n\n\tkfree(dev->em_pd->table);\n\tkfree(dev->em_pd);\n\tdev->em_pd = NULL;\n\tmutex_unlock(&em_pd_mutex);\n}\nEXPORT_SYMBOL_GPL(em_dev_unregister_perf_domain);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}