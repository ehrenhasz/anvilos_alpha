{
  "module_name": "console.c",
  "hash_id": "91940c444cf3d1dbb5c208c533ef4f7153c96da48c32658c4b17d3e97d94b766",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/console.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/vt_kern.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"power.h\"\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nstatic DEFINE_MUTEX(vt_switch_mutex);\n\nstruct pm_vt_switch {\n\tstruct list_head head;\n\tstruct device *dev;\n\tbool required;\n};\n\nstatic LIST_HEAD(pm_vt_switch_list);\n\n\n \nvoid pm_vt_switch_required(struct device *dev, bool required)\n{\n\tstruct pm_vt_switch *entry, *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\t \n\t\t\ttmp->required = required;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->required = required;\n\tentry->dev = dev;\n\n\tlist_add(&entry->head, &pm_vt_switch_list);\nout:\n\tmutex_unlock(&vt_switch_mutex);\n}\nEXPORT_SYMBOL(pm_vt_switch_required);\n\n \nvoid pm_vt_switch_unregister(struct device *dev)\n{\n\tstruct pm_vt_switch *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\tlist_del(&tmp->head);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vt_switch_mutex);\n}\nEXPORT_SYMBOL(pm_vt_switch_unregister);\n\n \nstatic bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}