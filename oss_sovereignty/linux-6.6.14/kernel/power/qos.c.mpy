{
  "module_name": "qos.c",
  "hash_id": "abc4ada2a3fe9abdf15b95cc88aec8cd73041870ff8418efc05a49845d37684f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/qos.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/pm_qos.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/miscdevice.h>\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <trace/events/power.h>\n\n \nstatic DEFINE_SPINLOCK(pm_qos_lock);\n\n \ns32 pm_qos_read_value(struct pm_qos_constraints *c)\n{\n\treturn READ_ONCE(c->target_value);\n}\n\nstatic int pm_qos_get_value(struct pm_qos_constraints *c)\n{\n\tif (plist_head_empty(&c->list))\n\t\treturn c->no_constraint_value;\n\n\tswitch (c->type) {\n\tcase PM_QOS_MIN:\n\t\treturn plist_first(&c->list)->prio;\n\n\tcase PM_QOS_MAX:\n\t\treturn plist_last(&c->list)->prio;\n\n\tdefault:\n\t\tWARN(1, \"Unknown PM QoS type in %s\\n\", __func__);\n\t\treturn PM_QOS_DEFAULT_VALUE;\n\t}\n}\n\nstatic void pm_qos_set_value(struct pm_qos_constraints *c, s32 value)\n{\n\tWRITE_ONCE(c->target_value, value);\n}\n\n \nint pm_qos_update_target(struct pm_qos_constraints *c, struct plist_node *node,\n\t\t\t enum pm_qos_req_action action, int value)\n{\n\tint prev_value, curr_value, new_value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pm_qos_lock, flags);\n\n\tprev_value = pm_qos_get_value(c);\n\tif (value == PM_QOS_DEFAULT_VALUE)\n\t\tnew_value = c->default_value;\n\telse\n\t\tnew_value = value;\n\n\tswitch (action) {\n\tcase PM_QOS_REMOVE_REQ:\n\t\tplist_del(node, &c->list);\n\t\tbreak;\n\tcase PM_QOS_UPDATE_REQ:\n\t\t \n\t\tplist_del(node, &c->list);\n\t\tfallthrough;\n\tcase PM_QOS_ADD_REQ:\n\t\tplist_node_init(node, new_value);\n\t\tplist_add(node, &c->list);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t;\n\t}\n\n\tcurr_value = pm_qos_get_value(c);\n\tpm_qos_set_value(c, curr_value);\n\n\tspin_unlock_irqrestore(&pm_qos_lock, flags);\n\n\ttrace_pm_qos_update_target(action, prev_value, curr_value);\n\n\tif (prev_value == curr_value)\n\t\treturn 0;\n\n\tif (c->notifiers)\n\t\tblocking_notifier_call_chain(c->notifiers, curr_value, NULL);\n\n\treturn 1;\n}\n\n \nstatic void pm_qos_flags_remove_req(struct pm_qos_flags *pqf,\n\t\t\t\t    struct pm_qos_flags_request *req)\n{\n\ts32 val = 0;\n\n\tlist_del(&req->node);\n\tlist_for_each_entry(req, &pqf->list, node)\n\t\tval |= req->flags;\n\n\tpqf->effective_flags = val;\n}\n\n \nbool pm_qos_update_flags(struct pm_qos_flags *pqf,\n\t\t\t struct pm_qos_flags_request *req,\n\t\t\t enum pm_qos_req_action action, s32 val)\n{\n\tunsigned long irqflags;\n\ts32 prev_value, curr_value;\n\n\tspin_lock_irqsave(&pm_qos_lock, irqflags);\n\n\tprev_value = list_empty(&pqf->list) ? 0 : pqf->effective_flags;\n\n\tswitch (action) {\n\tcase PM_QOS_REMOVE_REQ:\n\t\tpm_qos_flags_remove_req(pqf, req);\n\t\tbreak;\n\tcase PM_QOS_UPDATE_REQ:\n\t\tpm_qos_flags_remove_req(pqf, req);\n\t\tfallthrough;\n\tcase PM_QOS_ADD_REQ:\n\t\treq->flags = val;\n\t\tINIT_LIST_HEAD(&req->node);\n\t\tlist_add_tail(&req->node, &pqf->list);\n\t\tpqf->effective_flags |= val;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t;\n\t}\n\n\tcurr_value = list_empty(&pqf->list) ? 0 : pqf->effective_flags;\n\n\tspin_unlock_irqrestore(&pm_qos_lock, irqflags);\n\n\ttrace_pm_qos_update_flags(action, prev_value, curr_value);\n\n\treturn prev_value != curr_value;\n}\n\n#ifdef CONFIG_CPU_IDLE\n \n\nstatic struct pm_qos_constraints cpu_latency_constraints = {\n\t.list = PLIST_HEAD_INIT(cpu_latency_constraints.list),\n\t.target_value = PM_QOS_CPU_LATENCY_DEFAULT_VALUE,\n\t.default_value = PM_QOS_CPU_LATENCY_DEFAULT_VALUE,\n\t.no_constraint_value = PM_QOS_CPU_LATENCY_DEFAULT_VALUE,\n\t.type = PM_QOS_MIN,\n};\n\nstatic inline bool cpu_latency_qos_value_invalid(s32 value)\n{\n\treturn value < 0 && value != PM_QOS_DEFAULT_VALUE;\n}\n\n \ns32 cpu_latency_qos_limit(void)\n{\n\treturn pm_qos_read_value(&cpu_latency_constraints);\n}\n\n \nbool cpu_latency_qos_request_active(struct pm_qos_request *req)\n{\n\treturn req->qos == &cpu_latency_constraints;\n}\nEXPORT_SYMBOL_GPL(cpu_latency_qos_request_active);\n\nstatic void cpu_latency_qos_apply(struct pm_qos_request *req,\n\t\t\t\t  enum pm_qos_req_action action, s32 value)\n{\n\tint ret = pm_qos_update_target(req->qos, &req->node, action, value);\n\tif (ret > 0)\n\t\twake_up_all_idle_cpus();\n}\n\n \nvoid cpu_latency_qos_add_request(struct pm_qos_request *req, s32 value)\n{\n\tif (!req || cpu_latency_qos_value_invalid(value))\n\t\treturn;\n\n\tif (cpu_latency_qos_request_active(req)) {\n\t\tWARN(1, KERN_ERR \"%s called for already added request\\n\", __func__);\n\t\treturn;\n\t}\n\n\ttrace_pm_qos_add_request(value);\n\n\treq->qos = &cpu_latency_constraints;\n\tcpu_latency_qos_apply(req, PM_QOS_ADD_REQ, value);\n}\nEXPORT_SYMBOL_GPL(cpu_latency_qos_add_request);\n\n \nvoid cpu_latency_qos_update_request(struct pm_qos_request *req, s32 new_value)\n{\n\tif (!req || cpu_latency_qos_value_invalid(new_value))\n\t\treturn;\n\n\tif (!cpu_latency_qos_request_active(req)) {\n\t\tWARN(1, KERN_ERR \"%s called for unknown object\\n\", __func__);\n\t\treturn;\n\t}\n\n\ttrace_pm_qos_update_request(new_value);\n\n\tif (new_value == req->node.prio)\n\t\treturn;\n\n\tcpu_latency_qos_apply(req, PM_QOS_UPDATE_REQ, new_value);\n}\nEXPORT_SYMBOL_GPL(cpu_latency_qos_update_request);\n\n \nvoid cpu_latency_qos_remove_request(struct pm_qos_request *req)\n{\n\tif (!req)\n\t\treturn;\n\n\tif (!cpu_latency_qos_request_active(req)) {\n\t\tWARN(1, KERN_ERR \"%s called for unknown object\\n\", __func__);\n\t\treturn;\n\t}\n\n\ttrace_pm_qos_remove_request(PM_QOS_DEFAULT_VALUE);\n\n\tcpu_latency_qos_apply(req, PM_QOS_REMOVE_REQ, PM_QOS_DEFAULT_VALUE);\n\tmemset(req, 0, sizeof(*req));\n}\nEXPORT_SYMBOL_GPL(cpu_latency_qos_remove_request);\n\n \n\nstatic int cpu_latency_qos_open(struct inode *inode, struct file *filp)\n{\n\tstruct pm_qos_request *req;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcpu_latency_qos_add_request(req, PM_QOS_DEFAULT_VALUE);\n\tfilp->private_data = req;\n\n\treturn 0;\n}\n\nstatic int cpu_latency_qos_release(struct inode *inode, struct file *filp)\n{\n\tstruct pm_qos_request *req = filp->private_data;\n\n\tfilp->private_data = NULL;\n\n\tcpu_latency_qos_remove_request(req);\n\tkfree(req);\n\n\treturn 0;\n}\n\nstatic ssize_t cpu_latency_qos_read(struct file *filp, char __user *buf,\n\t\t\t\t    size_t count, loff_t *f_pos)\n{\n\tstruct pm_qos_request *req = filp->private_data;\n\tunsigned long flags;\n\ts32 value;\n\n\tif (!req || !cpu_latency_qos_request_active(req))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&pm_qos_lock, flags);\n\tvalue = pm_qos_get_value(&cpu_latency_constraints);\n\tspin_unlock_irqrestore(&pm_qos_lock, flags);\n\n\treturn simple_read_from_buffer(buf, count, f_pos, &value, sizeof(s32));\n}\n\nstatic ssize_t cpu_latency_qos_write(struct file *filp, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *f_pos)\n{\n\ts32 value;\n\n\tif (count == sizeof(s32)) {\n\t\tif (copy_from_user(&value, buf, sizeof(s32)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tint ret;\n\n\t\tret = kstrtos32_from_user(buf, count, 16, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcpu_latency_qos_update_request(filp->private_data, value);\n\n\treturn count;\n}\n\nstatic const struct file_operations cpu_latency_qos_fops = {\n\t.write = cpu_latency_qos_write,\n\t.read = cpu_latency_qos_read,\n\t.open = cpu_latency_qos_open,\n\t.release = cpu_latency_qos_release,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice cpu_latency_qos_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"cpu_dma_latency\",\n\t.fops = &cpu_latency_qos_fops,\n};\n\nstatic int __init cpu_latency_qos_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&cpu_latency_qos_miscdev);\n\tif (ret < 0)\n\t\tpr_err(\"%s: %s setup failed\\n\", __func__,\n\t\t       cpu_latency_qos_miscdev.name);\n\n\treturn ret;\n}\nlate_initcall(cpu_latency_qos_init);\n#endif  \n\n \n\nstatic inline bool freq_qos_value_invalid(s32 value)\n{\n\treturn value < 0 && value != PM_QOS_DEFAULT_VALUE;\n}\n\n \nvoid freq_constraints_init(struct freq_constraints *qos)\n{\n\tstruct pm_qos_constraints *c;\n\n\tc = &qos->min_freq;\n\tplist_head_init(&c->list);\n\tc->target_value = FREQ_QOS_MIN_DEFAULT_VALUE;\n\tc->default_value = FREQ_QOS_MIN_DEFAULT_VALUE;\n\tc->no_constraint_value = FREQ_QOS_MIN_DEFAULT_VALUE;\n\tc->type = PM_QOS_MAX;\n\tc->notifiers = &qos->min_freq_notifiers;\n\tBLOCKING_INIT_NOTIFIER_HEAD(c->notifiers);\n\n\tc = &qos->max_freq;\n\tplist_head_init(&c->list);\n\tc->target_value = FREQ_QOS_MAX_DEFAULT_VALUE;\n\tc->default_value = FREQ_QOS_MAX_DEFAULT_VALUE;\n\tc->no_constraint_value = FREQ_QOS_MAX_DEFAULT_VALUE;\n\tc->type = PM_QOS_MIN;\n\tc->notifiers = &qos->max_freq_notifiers;\n\tBLOCKING_INIT_NOTIFIER_HEAD(c->notifiers);\n}\n\n \ns32 freq_qos_read_value(struct freq_constraints *qos,\n\t\t\tenum freq_qos_req_type type)\n{\n\ts32 ret;\n\n\tswitch (type) {\n\tcase FREQ_QOS_MIN:\n\t\tret = IS_ERR_OR_NULL(qos) ?\n\t\t\tFREQ_QOS_MIN_DEFAULT_VALUE :\n\t\t\tpm_qos_read_value(&qos->min_freq);\n\t\tbreak;\n\tcase FREQ_QOS_MAX:\n\t\tret = IS_ERR_OR_NULL(qos) ?\n\t\t\tFREQ_QOS_MAX_DEFAULT_VALUE :\n\t\t\tpm_qos_read_value(&qos->max_freq);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nint freq_qos_apply(struct freq_qos_request *req,\n\t\t\t  enum pm_qos_req_action action, s32 value)\n{\n\tint ret;\n\n\tswitch(req->type) {\n\tcase FREQ_QOS_MIN:\n\t\tret = pm_qos_update_target(&req->qos->min_freq, &req->pnode,\n\t\t\t\t\t   action, value);\n\t\tbreak;\n\tcase FREQ_QOS_MAX:\n\t\tret = pm_qos_update_target(&req->qos->max_freq, &req->pnode,\n\t\t\t\t\t   action, value);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nint freq_qos_add_request(struct freq_constraints *qos,\n\t\t\t struct freq_qos_request *req,\n\t\t\t enum freq_qos_req_type type, s32 value)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(qos) || !req || freq_qos_value_invalid(value))\n\t\treturn -EINVAL;\n\n\tif (WARN(freq_qos_request_active(req),\n\t\t \"%s() called for active request\\n\", __func__))\n\t\treturn -EINVAL;\n\n\treq->qos = qos;\n\treq->type = type;\n\tret = freq_qos_apply(req, PM_QOS_ADD_REQ, value);\n\tif (ret < 0) {\n\t\treq->qos = NULL;\n\t\treq->type = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(freq_qos_add_request);\n\n \nint freq_qos_update_request(struct freq_qos_request *req, s32 new_value)\n{\n\tif (!req || freq_qos_value_invalid(new_value))\n\t\treturn -EINVAL;\n\n\tif (WARN(!freq_qos_request_active(req),\n\t\t \"%s() called for unknown object\\n\", __func__))\n\t\treturn -EINVAL;\n\n\tif (req->pnode.prio == new_value)\n\t\treturn 0;\n\n\treturn freq_qos_apply(req, PM_QOS_UPDATE_REQ, new_value);\n}\nEXPORT_SYMBOL_GPL(freq_qos_update_request);\n\n \nint freq_qos_remove_request(struct freq_qos_request *req)\n{\n\tint ret;\n\n\tif (!req)\n\t\treturn -EINVAL;\n\n\tif (WARN(!freq_qos_request_active(req),\n\t\t \"%s() called for unknown object\\n\", __func__))\n\t\treturn -EINVAL;\n\n\tret = freq_qos_apply(req, PM_QOS_REMOVE_REQ, PM_QOS_DEFAULT_VALUE);\n\treq->qos = NULL;\n\treq->type = 0;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(freq_qos_remove_request);\n\n \nint freq_qos_add_notifier(struct freq_constraints *qos,\n\t\t\t  enum freq_qos_req_type type,\n\t\t\t  struct notifier_block *notifier)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(qos) || !notifier)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase FREQ_QOS_MIN:\n\t\tret = blocking_notifier_chain_register(qos->min_freq.notifiers,\n\t\t\t\t\t\t       notifier);\n\t\tbreak;\n\tcase FREQ_QOS_MAX:\n\t\tret = blocking_notifier_chain_register(qos->max_freq.notifiers,\n\t\t\t\t\t\t       notifier);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(freq_qos_add_notifier);\n\n \nint freq_qos_remove_notifier(struct freq_constraints *qos,\n\t\t\t     enum freq_qos_req_type type,\n\t\t\t     struct notifier_block *notifier)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(qos) || !notifier)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase FREQ_QOS_MIN:\n\t\tret = blocking_notifier_chain_unregister(qos->min_freq.notifiers,\n\t\t\t\t\t\t\t notifier);\n\t\tbreak;\n\tcase FREQ_QOS_MAX:\n\t\tret = blocking_notifier_chain_unregister(qos->max_freq.notifiers,\n\t\t\t\t\t\t\t notifier);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(freq_qos_remove_notifier);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}