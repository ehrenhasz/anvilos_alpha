{
  "module_name": "user.c",
  "hash_id": "72a14a447e0c0d6b4f5a66a2a74a08223d0ab575ac307a58710167d3e8fcac70",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/user.c",
  "human_readable_source": "\n \n\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/pm.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n\n#include <linux/uaccess.h>\n\n#include \"power.h\"\n\nstatic bool need_wait;\n\nstatic struct snapshot_data {\n\tstruct snapshot_handle handle;\n\tint swap;\n\tint mode;\n\tbool frozen;\n\tbool ready;\n\tbool platform_support;\n\tbool free_bitmaps;\n\tdev_t dev;\n} snapshot_state;\n\nint is_hibernate_resume_dev(dev_t dev)\n{\n\treturn hibernation_available() && snapshot_state.dev == dev;\n}\n\nstatic int snapshot_open(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\tunsigned int sleep_flags;\n\tint error;\n\n\tif (!hibernation_available())\n\t\treturn -EPERM;\n\n\tsleep_flags = lock_system_sleep();\n\n\tif (!hibernate_acquire()) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\n\t\thibernate_release();\n\t\terror = -ENOSYS;\n\t\tgoto Unlock;\n\t}\n\tnonseekable_open(inode, filp);\n\tdata = &snapshot_state;\n\tfilp->private_data = data;\n\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\tif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\n\t\t \n\t\tdata->swap = swap_type_of(swsusp_resume_device, 0);\n\t\tdata->mode = O_RDONLY;\n\t\tdata->free_bitmaps = false;\n\t\terror = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);\n\t} else {\n\t\t \n\t\tneed_wait = true;\n\n\t\tdata->swap = -1;\n\t\tdata->mode = O_WRONLY;\n\t\terror = pm_notifier_call_chain_robust(PM_RESTORE_PREPARE, PM_POST_RESTORE);\n\t\tif (!error) {\n\t\t\terror = create_basic_memory_bitmaps();\n\t\t\tdata->free_bitmaps = !error;\n\t\t}\n\t}\n\tif (error)\n\t\thibernate_release();\n\n\tdata->frozen = false;\n\tdata->ready = false;\n\tdata->platform_support = false;\n\tdata->dev = 0;\n\n Unlock:\n\tunlock_system_sleep(sleep_flags);\n\n\treturn error;\n}\n\nstatic int snapshot_release(struct inode *inode, struct file *filp)\n{\n\tstruct snapshot_data *data;\n\tunsigned int sleep_flags;\n\n\tsleep_flags = lock_system_sleep();\n\n\tswsusp_free();\n\tdata = filp->private_data;\n\tdata->dev = 0;\n\tfree_all_swap_pages(data->swap);\n\tif (data->frozen) {\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tthaw_processes();\n\t} else if (data->free_bitmaps) {\n\t\tfree_basic_memory_bitmaps();\n\t}\n\tpm_notifier_call_chain(data->mode == O_RDONLY ?\n\t\t\tPM_POST_HIBERNATION : PM_POST_RESTORE);\n\thibernate_release();\n\n\tunlock_system_sleep(sleep_flags);\n\n\treturn 0;\n}\n\nstatic ssize_t snapshot_read(struct file *filp, char __user *buf,\n                             size_t count, loff_t *offp)\n{\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\tstruct snapshot_data *data;\n\tunsigned int sleep_flags;\n\tssize_t res;\n\n\tsleep_flags = lock_system_sleep();\n\n\tdata = filp->private_data;\n\tif (!data->ready) {\n\t\tres = -ENODATA;\n\t\tgoto Unlock;\n\t}\n\tif (!pg_offp) {  \n\t\tres = snapshot_read_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto Unlock;\n\t} else {\n\t\tres = PAGE_SIZE - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->handle), res);\n\tif (res > 0)\n\t\t*offp += res;\n\n Unlock:\n\tunlock_system_sleep(sleep_flags);\n\n\treturn res;\n}\n\nstatic ssize_t snapshot_write(struct file *filp, const char __user *buf,\n                              size_t count, loff_t *offp)\n{\n\tloff_t pg_offp = *offp & ~PAGE_MASK;\n\tstruct snapshot_data *data;\n\tunsigned long sleep_flags;\n\tssize_t res;\n\n\tif (need_wait) {\n\t\twait_for_device_probe();\n\t\tneed_wait = false;\n\t}\n\n\tsleep_flags = lock_system_sleep();\n\n\tdata = filp->private_data;\n\n\tif (!pg_offp) {\n\t\tres = snapshot_write_next(&data->handle);\n\t\tif (res <= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = PAGE_SIZE;\n\t}\n\n\tif (!data_of(data->handle)) {\n\t\tres = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\n\t\t\tbuf, count);\n\tif (res > 0)\n\t\t*offp += res;\nunlock:\n\tunlock_system_sleep(sleep_flags);\n\n\treturn res;\n}\n\nstruct compat_resume_swap_area {\n\tcompat_loff_t offset;\n\tu32 dev;\n} __packed;\n\nstatic int snapshot_set_swap_area(struct snapshot_data *data,\n\t\tvoid __user *argp)\n{\n\tsector_t offset;\n\tdev_t swdev;\n\n\tif (swsusp_swap_in_use())\n\t\treturn -EPERM;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t} else {\n\t\tstruct resume_swap_area swap_area;\n\n\t\tif (copy_from_user(&swap_area, argp, sizeof(swap_area)))\n\t\t\treturn -EFAULT;\n\t\tswdev = new_decode_dev(swap_area.dev);\n\t\toffset = swap_area.offset;\n\t}\n\n\t \n\tdata->swap = swap_type_of(swdev, offset);\n\tif (data->swap < 0)\n\t\treturn swdev ? -ENODEV : -EINVAL;\n\tdata->dev = swdev;\n\treturn 0;\n}\n\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tint error = 0;\n\tstruct snapshot_data *data;\n\tloff_t size;\n\tsector_t offset;\n\n\tif (need_wait) {\n\t\twait_for_device_probe();\n\t\tneed_wait = false;\n\t}\n\n\tif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\n\t\treturn -ENOTTY;\n\tif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\n\t\treturn -ENOTTY;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!mutex_trylock(&system_transition_mutex))\n\t\treturn -EBUSY;\n\n\tlock_device_hotplug();\n\tdata = filp->private_data;\n\n\tswitch (cmd) {\n\n\tcase SNAPSHOT_FREEZE:\n\t\tif (data->frozen)\n\t\t\tbreak;\n\n\t\tksys_sync_helper();\n\n\t\terror = freeze_processes();\n\t\tif (error)\n\t\t\tbreak;\n\n\t\terror = create_basic_memory_bitmaps();\n\t\tif (error)\n\t\t\tthaw_processes();\n\t\telse\n\t\t\tdata->frozen = true;\n\n\t\tbreak;\n\n\tcase SNAPSHOT_UNFREEZE:\n\t\tif (!data->frozen || data->ready)\n\t\t\tbreak;\n\t\tpm_restore_gfp_mask();\n\t\tfree_basic_memory_bitmaps();\n\t\tdata->free_bitmaps = false;\n\t\tthaw_processes();\n\t\tdata->frozen = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_CREATE_IMAGE:\n\t\tif (data->mode != O_RDONLY || !data->frozen  || data->ready) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tpm_restore_gfp_mask();\n\t\terror = hibernation_snapshot(data->platform_support);\n\t\tif (!error) {\n\t\t\terror = put_user(in_suspend, (int __user *)arg);\n\t\t\tdata->ready = !freezer_test_done && !error;\n\t\t\tfreezer_test_done = false;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_ATOMIC_RESTORE:\n\t\tsnapshot_write_finalize(&data->handle);\n\t\tif (data->mode != O_WRONLY || !data->frozen ||\n\t\t    !snapshot_image_loaded(&data->handle)) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\terror = hibernation_restore(data->platform_support);\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE:\n\t\tswsusp_free();\n\t\tmemset(&data->handle, 0, sizeof(struct snapshot_handle));\n\t\tdata->ready = false;\n\t\t \n\t\tthaw_kernel_threads();\n\t\tbreak;\n\n\tcase SNAPSHOT_PREF_IMAGE_SIZE:\n\t\timage_size = arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\t\tif (!data->ready) {\n\t\t\terror = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\tsize = snapshot_get_image_size();\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\t\tsize = count_swap_pages(data->swap, 1);\n\t\tsize <<= PAGE_SHIFT;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\toffset = alloc_swapdev_block(data->swap);\n\t\tif (offset) {\n\t\t\toffset <<= PAGE_SHIFT;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -ENOSPC;\n\t\t}\n\t\tbreak;\n\n\tcase SNAPSHOT_FREE_SWAP_PAGES:\n\t\tif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\n\t\t\terror = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tfree_all_swap_pages(data->swap);\n\t\tbreak;\n\n\tcase SNAPSHOT_S2RAM:\n\t\tif (!data->frozen) {\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\terror = suspend_devices_and_enter(PM_SUSPEND_MEM);\n\t\tdata->ready = false;\n\t\tbreak;\n\n\tcase SNAPSHOT_PLATFORM_SUPPORT:\n\t\tdata->platform_support = !!arg;\n\t\tbreak;\n\n\tcase SNAPSHOT_POWER_OFF:\n\t\tif (data->platform_support)\n\t\t\terror = hibernation_platform_enter();\n\t\tbreak;\n\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\terror = snapshot_set_swap_area(data, (void __user *)arg);\n\t\tbreak;\n\n\tdefault:\n\t\terror = -ENOTTY;\n\n\t}\n\n\tunlock_device_hotplug();\n\tmutex_unlock(&system_transition_mutex);\n\n\treturn error;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long\nsnapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));\n\n\tswitch (cmd) {\n\tcase SNAPSHOT_GET_IMAGE_SIZE:\n\tcase SNAPSHOT_AVAIL_SWAP_SIZE:\n\tcase SNAPSHOT_ALLOC_SWAP_PAGE:\n\tcase SNAPSHOT_CREATE_IMAGE:\n\tcase SNAPSHOT_SET_SWAP_AREA:\n\t\treturn snapshot_ioctl(file, cmd,\n\t\t\t\t      (unsigned long) compat_ptr(arg));\n\tdefault:\n\t\treturn snapshot_ioctl(file, cmd, arg);\n\t}\n}\n#endif  \n\nstatic const struct file_operations snapshot_fops = {\n\t.open = snapshot_open,\n\t.release = snapshot_release,\n\t.read = snapshot_read,\n\t.write = snapshot_write,\n\t.llseek = no_llseek,\n\t.unlocked_ioctl = snapshot_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = snapshot_compat_ioctl,\n#endif\n};\n\nstatic struct miscdevice snapshot_device = {\n\t.minor = SNAPSHOT_MINOR,\n\t.name = \"snapshot\",\n\t.fops = &snapshot_fops,\n};\n\nstatic int __init snapshot_device_init(void)\n{\n\treturn misc_register(&snapshot_device);\n};\n\ndevice_initcall(snapshot_device_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}