{
  "module_name": "process.c",
  "hash_id": "830cd2123f65cd7d3e00d14eef79708d45fd895521ed5e52f6a357bace14068a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/process.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/oom.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/syscalls.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/kmod.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n\n \nunsigned int __read_mostly freeze_timeout_msecs = 20 * MSEC_PER_SEC;\n\nstatic int try_to_freeze_tasks(bool user_only)\n{\n\tconst char *what = user_only ? \"user space processes\" :\n\t\t\t\t\t\"remaining freezable tasks\";\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tpr_info(\"Freezing %s\\n\", what);\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_err(\"Freezing %s %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\", what,\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_freezable_workqueues();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_info(\"Freezing %s completed (elapsed %d.%03d seconds)\\n\",\n\t\t\twhat, elapsed_msecs / 1000, elapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}\n\n \nint freeze_processes(void)\n{\n\tint error;\n\n\terror = __usermodehelper_disable(UMH_FREEZING);\n\tif (error)\n\t\treturn error;\n\n\t \n\tcurrent->flags |= PF_SUSPEND_TASK;\n\n\tif (!pm_freezing)\n\t\tstatic_branch_inc(&freezer_active);\n\n\tpm_wakeup_clear(0);\n\tpm_freezing = true;\n\terror = try_to_freeze_tasks(true);\n\tif (!error)\n\t\t__usermodehelper_set_disable_depth(UMH_DISABLED);\n\n\tBUG_ON(in_atomic());\n\n\t \n\tif (!error && !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))\n\t\terror = -EBUSY;\n\n\tif (error)\n\t\tthaw_processes();\n\treturn error;\n}\n\n \nint freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}\n\nvoid thaw_processes(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct task_struct *curr = current;\n\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);\n\tif (pm_freezing)\n\t\tstatic_branch_dec(&freezer_active);\n\tpm_freezing = false;\n\tpm_nosig_freezing = false;\n\n\toom_killer_enable();\n\n\tpr_info(\"Restarting tasks ... \");\n\n\t__usermodehelper_set_disable_depth(UMH_FREEZING);\n\tthaw_workqueues();\n\n\tcpuset_wait_for_hotplug();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t \n\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));\n\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));\n\tcurr->flags &= ~PF_SUSPEND_TASK;\n\n\tusermodehelper_enable();\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);\n}\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}