{
  "module_name": "suspend_test.c",
  "hash_id": "eab0082adf8abe252c0c9aec858bb639a252dd15bd4daa5ef047b10288dd875c",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/suspend_test.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/rtc.h>\n\n#include \"power.h\"\n\n \n#define TEST_SUSPEND_SECONDS\t10\n\nstatic unsigned long suspend_test_start_time;\nstatic u32 test_repeat_count_max = 1;\nstatic u32 test_repeat_count_current;\n\nvoid suspend_test_start(void)\n{\n\t \n\tsuspend_test_start_time = jiffies;\n}\n\nvoid suspend_test_finish(const char *label)\n{\n\tlong nj = jiffies - suspend_test_start_time;\n\tunsigned msec;\n\n\tmsec = jiffies_to_msecs(abs(nj));\n\tpr_info(\"PM: %s took %d.%03d seconds\\n\", label,\n\t\t\tmsec / 1000, msec % 1000);\n\n\t \n\tWARN(msec > (TEST_SUSPEND_SECONDS * 1000),\n\t     \"Component: %s, time: %u\\n\", label, msec);\n}\n\n \n\nstatic void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)\n{\n\tstatic char err_readtime[] __initdata =\n\t\tKERN_ERR \"PM: can't read %s time, err %d\\n\";\n\tstatic char err_wakealarm [] __initdata =\n\t\tKERN_ERR \"PM: can't set %s wakealarm, err %d\\n\";\n\tstatic char err_suspend[] __initdata =\n\t\tKERN_ERR \"PM: suspend test failed, error %d\\n\";\n\tstatic char info_test[] __initdata =\n\t\tKERN_INFO \"PM: test RTC wakeup from '%s' suspend\\n\";\n\n\ttime64_t\t\tnow;\n\tstruct rtc_wkalrm\talm;\n\tint\t\t\tstatus;\n\n\t \nrepeat:\n\tstatus = rtc_read_time(rtc, &alm.time);\n\tif (status < 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\tnow = rtc_tm_to_time64(&alm.time);\n\n\tmemset(&alm, 0, sizeof alm);\n\trtc_time64_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);\n\talm.enabled = true;\n\n\tstatus = rtc_set_alarm(rtc, &alm);\n\tif (status < 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\n\tif (state == PM_SUSPEND_MEM) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status == -ENODEV)\n\t\t\tstate = PM_SUSPEND_STANDBY;\n\t}\n\tif (state == PM_SUSPEND_STANDBY) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status < 0)\n\t\t\tstate = PM_SUSPEND_TO_IDLE;\n\t}\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t \n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}\n\nstatic int __init has_wakealarm(struct device *dev, const void *data)\n{\n\tstruct rtc_device *candidate = to_rtc_device(dev);\n\n\tif (!test_bit(RTC_FEATURE_ALARM, candidate->features))\n\t\treturn 0;\n\tif (!device_may_wakeup(candidate->dev.parent))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic const char *test_state_label __initdata;\n\nstatic char warn_bad_state[] __initdata =\n\tKERN_WARNING \"PM: can't test '%s' suspend state\\n\";\n\nstatic int __init setup_test_suspend(char *value)\n{\n\tint i;\n\tchar *repeat;\n\tchar *suspend_type;\n\n\t \n\tvalue++;\n\tsuspend_type = strsep(&value, \",\");\n\tif (!suspend_type)\n\t\treturn 1;\n\n\trepeat = strsep(&value, \",\");\n\tif (repeat) {\n\t\tif (kstrtou32(repeat, 0, &test_repeat_count_max))\n\t\t\treturn 1;\n\t}\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (!strcmp(pm_labels[i], suspend_type)) {\n\t\t\ttest_state_label = pm_labels[i];\n\t\t\treturn 1;\n\t\t}\n\n\tprintk(warn_bad_state, suspend_type);\n\treturn 1;\n}\n__setup(\"test_suspend\", setup_test_suspend);\n\nstatic int __init test_suspend(void)\n{\n\tstatic char\t\twarn_no_rtc[] __initdata =\n\t\tKERN_WARNING \"PM: no wakealarm-capable RTC driver is ready\\n\";\n\n\tstruct rtc_device\t*rtc = NULL;\n\tstruct device\t\t*dev;\n\tsuspend_state_t test_state;\n\n\t \n\tif (!test_state_label)\n\t\treturn 0;\n\n\tfor (test_state = PM_SUSPEND_MIN; test_state < PM_SUSPEND_MAX; test_state++) {\n\t\tconst char *state_label = pm_states[test_state];\n\n\t\tif (state_label && !strcmp(test_state_label, state_label))\n\t\t\tbreak;\n\t}\n\tif (test_state == PM_SUSPEND_MAX) {\n\t\tprintk(warn_bad_state, test_state_label);\n\t\treturn 0;\n\t}\n\n\t \n\tdev = class_find_device(rtc_class, NULL, NULL, has_wakealarm);\n\tif (dev) {\n\t\trtc = rtc_class_open(dev_name(dev));\n\t\tput_device(dev);\n\t}\n\tif (!rtc) {\n\t\tprintk(warn_no_rtc);\n\t\treturn 0;\n\t}\n\n\t \n\ttest_wakealarm(rtc, test_state);\n\trtc_class_close(rtc);\n\treturn 0;\n}\nlate_initcall(test_suspend);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}