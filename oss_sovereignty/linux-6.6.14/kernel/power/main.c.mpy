{
  "module_name": "main.c",
  "hash_id": "a3a5e78dd1980ad5633bcffddaa0ff3711b46b1ebd23c0c94c35b5a2d78f48ee",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/main.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/export.h>\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/pm-trace.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/suspend.h>\n#include <linux/syscalls.h>\n#include <linux/pm_runtime.h>\n\n#include \"power.h\"\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic gfp_t saved_gfp_mask;\n\nvoid pm_restore_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&system_transition_mutex));\n\tif (saved_gfp_mask) {\n\t\tgfp_allowed_mask = saved_gfp_mask;\n\t\tsaved_gfp_mask = 0;\n\t}\n}\n\nvoid pm_restrict_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&system_transition_mutex));\n\tWARN_ON(saved_gfp_mask);\n\tsaved_gfp_mask = gfp_allowed_mask;\n\tgfp_allowed_mask &= ~(__GFP_IO | __GFP_FS);\n}\n\nunsigned int lock_system_sleep(void)\n{\n\tunsigned int flags = current->flags;\n\tcurrent->flags |= PF_NOFREEZE;\n\tmutex_lock(&system_transition_mutex);\n\treturn flags;\n}\nEXPORT_SYMBOL_GPL(lock_system_sleep);\n\nvoid unlock_system_sleep(unsigned int flags)\n{\n\t \n\tif (!(flags & PF_NOFREEZE))\n\t\tcurrent->flags &= ~PF_NOFREEZE;\n\tmutex_unlock(&system_transition_mutex);\n}\nEXPORT_SYMBOL_GPL(unlock_system_sleep);\n\nvoid ksys_sync_helper(void)\n{\n\tktime_t start;\n\tlong elapsed_msecs;\n\n\tstart = ktime_get();\n\tksys_sync();\n\telapsed_msecs = ktime_to_ms(ktime_sub(ktime_get(), start));\n\tpr_info(\"Filesystems sync: %ld.%03ld seconds\\n\",\n\t\telapsed_msecs / MSEC_PER_SEC, elapsed_msecs % MSEC_PER_SEC);\n}\nEXPORT_SYMBOL_GPL(ksys_sync_helper);\n\n \n\nstatic BLOCKING_NOTIFIER_HEAD(pm_chain_head);\n\nint register_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&pm_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(register_pm_notifier);\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_pm_notifier);\n\nvoid pm_report_hw_sleep_time(u64 t)\n{\n\tsuspend_stats.last_hw_sleep = t;\n\tsuspend_stats.total_hw_sleep += t;\n}\nEXPORT_SYMBOL_GPL(pm_report_hw_sleep_time);\n\nvoid pm_report_max_hw_sleep(u64 t)\n{\n\tsuspend_stats.max_hw_sleep = t;\n}\nEXPORT_SYMBOL_GPL(pm_report_max_hw_sleep);\n\nint pm_notifier_call_chain_robust(unsigned long val_up, unsigned long val_down)\n{\n\tint ret;\n\n\tret = blocking_notifier_call_chain_robust(&pm_chain_head, val_up, val_down, NULL);\n\n\treturn notifier_to_errno(ret);\n}\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn blocking_notifier_call_chain(&pm_chain_head, val, NULL);\n}\n\n \nint pm_async_enabled = 1;\n\nstatic ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_async_enabled);\n}\n\nstatic ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_async_enabled = val;\n\treturn n;\n}\n\npower_attr(pm_async);\n\n#ifdef CONFIG_SUSPEND\nstatic ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tchar *s = buf;\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++) {\n\t\tif (i >= PM_SUSPEND_MEM && cxl_mem_active())\n\t\t\tcontinue;\n\t\tif (mem_sleep_states[i]) {\n\t\t\tconst char *label = mem_sleep_states[i];\n\n\t\t\tif (mem_sleep_current == i)\n\t\t\t\ts += sprintf(s, \"[%s] \", label);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", label);\n\t\t}\n\t}\n\n\t \n\tif (s != buf)\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}\n\nstatic suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}\n\nstatic ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_suspend_state(buf, n);\n\tif (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)\n\t\tmem_sleep_current = state;\n\telse\n\t\terror = -EINVAL;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}\n\npower_attr(mem_sleep);\n\n \nbool sync_on_suspend_enabled = !IS_ENABLED(CONFIG_SUSPEND_SKIP_SYNC);\n\nstatic ssize_t sync_on_suspend_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", sync_on_suspend_enabled);\n}\n\nstatic ssize_t sync_on_suspend_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tsync_on_suspend_enabled = !!val;\n\treturn n;\n}\n\npower_attr(sync_on_suspend);\n#endif  \n\n#ifdef CONFIG_PM_SLEEP_DEBUG\nint pm_test_level = TEST_NONE;\n\nstatic const char * const pm_tests[__TEST_AFTER_LAST] = {\n\t[TEST_NONE] = \"none\",\n\t[TEST_CORE] = \"core\",\n\t[TEST_CPUS] = \"processors\",\n\t[TEST_PLATFORM] = \"platform\",\n\t[TEST_DEVICES] = \"devices\",\n\t[TEST_FREEZER] = \"freezer\",\n};\n\nstatic ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tchar *s = buf;\n\tint level;\n\n\tfor (level = TEST_FIRST; level <= TEST_MAX; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t \n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}\n\nstatic ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int sleep_flags;\n\tconst char * const *s;\n\tint error = -EINVAL;\n\tint level;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tsleep_flags = lock_system_sleep();\n\n\tlevel = TEST_FIRST;\n\tfor (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep(sleep_flags);\n\n\treturn error ? error : n;\n}\n\npower_attr(pm_test);\n#endif  \n\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\n#define suspend_attr(_name, format_str)\t\t\t\t\\\nstatic ssize_t _name##_show(struct kobject *kobj,\t\t\\\n\t\tstruct kobj_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, format_str, suspend_stats._name);\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic struct kobj_attribute _name = __ATTR_RO(_name)\n\nsuspend_attr(success, \"%d\\n\");\nsuspend_attr(fail, \"%d\\n\");\nsuspend_attr(failed_freeze, \"%d\\n\");\nsuspend_attr(failed_prepare, \"%d\\n\");\nsuspend_attr(failed_suspend, \"%d\\n\");\nsuspend_attr(failed_suspend_late, \"%d\\n\");\nsuspend_attr(failed_suspend_noirq, \"%d\\n\");\nsuspend_attr(failed_resume, \"%d\\n\");\nsuspend_attr(failed_resume_early, \"%d\\n\");\nsuspend_attr(failed_resume_noirq, \"%d\\n\");\nsuspend_attr(last_hw_sleep, \"%llu\\n\");\nsuspend_attr(total_hw_sleep, \"%llu\\n\");\nsuspend_attr(max_hw_sleep, \"%llu\\n\");\n\nstatic ssize_t last_failed_dev_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tchar *last_failed_dev = NULL;\n\n\tindex = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tlast_failed_dev = suspend_stats.failed_devs[index];\n\n\treturn sprintf(buf, \"%s\\n\", last_failed_dev);\n}\nstatic struct kobj_attribute last_failed_dev = __ATTR_RO(last_failed_dev);\n\nstatic ssize_t last_failed_errno_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tint last_failed_errno;\n\n\tindex = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tlast_failed_errno = suspend_stats.errno[index];\n\n\treturn sprintf(buf, \"%d\\n\", last_failed_errno);\n}\nstatic struct kobj_attribute last_failed_errno = __ATTR_RO(last_failed_errno);\n\nstatic ssize_t last_failed_step_show(struct kobject *kobj,\n\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tint index;\n\tenum suspend_stat_step step;\n\tchar *last_failed_step = NULL;\n\n\tindex = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tindex %= REC_FAILED_NUM;\n\tstep = suspend_stats.failed_steps[index];\n\tlast_failed_step = suspend_step_name(step);\n\n\treturn sprintf(buf, \"%s\\n\", last_failed_step);\n}\nstatic struct kobj_attribute last_failed_step = __ATTR_RO(last_failed_step);\n\nstatic struct attribute *suspend_attrs[] = {\n\t&success.attr,\n\t&fail.attr,\n\t&failed_freeze.attr,\n\t&failed_prepare.attr,\n\t&failed_suspend.attr,\n\t&failed_suspend_late.attr,\n\t&failed_suspend_noirq.attr,\n\t&failed_resume.attr,\n\t&failed_resume_early.attr,\n\t&failed_resume_noirq.attr,\n\t&last_failed_dev.attr,\n\t&last_failed_errno.attr,\n\t&last_failed_step.attr,\n\t&last_hw_sleep.attr,\n\t&total_hw_sleep.attr,\n\t&max_hw_sleep.attr,\n\tNULL,\n};\n\nstatic umode_t suspend_attr_is_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tif (attr != &last_hw_sleep.attr &&\n\t    attr != &total_hw_sleep.attr &&\n\t    attr != &max_hw_sleep.attr)\n\t\treturn 0444;\n\n#ifdef CONFIG_ACPI\n\tif (acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0)\n\t\treturn 0444;\n#endif\n\treturn 0;\n}\n\nstatic const struct attribute_group suspend_attr_group = {\n\t.name = \"suspend_stats\",\n\t.attrs = suspend_attrs,\n\t.is_visible = suspend_attr_is_visible,\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tlast_dev %= REC_FAILED_NUM;\n\tlast_errno = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tlast_errno %= REC_FAILED_NUM;\n\tlast_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tlast_step %= REC_FAILED_NUM;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_dev + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_errno + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_step + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(suspend_stats);\n\nstatic int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", S_IFREG | S_IRUGO,\n\t\t\tNULL, NULL, &suspend_stats_fops);\n\treturn 0;\n}\n\nlate_initcall(pm_debugfs_init);\n#endif  \n\n#endif  \n\n#ifdef CONFIG_PM_SLEEP_DEBUG\n \nbool pm_print_times_enabled;\n\nstatic ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}\n\nstatic ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_print_times_enabled = !!val;\n\treturn n;\n}\n\npower_attr(pm_print_times);\n\nstatic inline void pm_print_times_init(void)\n{\n\tpm_print_times_enabled = !!initcall_debug;\n}\n\nstatic ssize_t pm_wakeup_irq_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tif (!pm_wakeup_irq())\n\t\treturn -ENODATA;\n\n\treturn sprintf(buf, \"%u\\n\", pm_wakeup_irq());\n}\n\npower_attr_ro(pm_wakeup_irq);\n\nbool pm_debug_messages_on __read_mostly;\n\nbool pm_debug_messages_should_print(void)\n{\n\treturn pm_debug_messages_on && pm_suspend_target_state != PM_SUSPEND_ON;\n}\nEXPORT_SYMBOL_GPL(pm_debug_messages_should_print);\n\nstatic ssize_t pm_debug_messages_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_debug_messages_on);\n}\n\nstatic ssize_t pm_debug_messages_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_debug_messages_on = !!val;\n\treturn n;\n}\n\npower_attr(pm_debug_messages);\n\nstatic int __init pm_debug_messages_setup(char *str)\n{\n\tpm_debug_messages_on = true;\n\treturn 1;\n}\n__setup(\"pm_debug_messages\", pm_debug_messages_setup);\n\n#else  \nstatic inline void pm_print_times_init(void) {}\n#endif  \n\nstruct kobject *power_kobj;\n\n \nstatic ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tchar *s = buf;\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t \n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t \n\tif (len == 4 && str_has_prefix(buf, \"disk\"))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}\n\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_state(buf, n);\n\tif (state < PM_SUSPEND_MAX) {\n\t\tif (state == PM_SUSPEND_MEM)\n\t\t\tstate = mem_sleep_current;\n\n\t\terror = pm_suspend(state);\n\t} else if (state == PM_SUSPEND_MAX) {\n\t\terror = hibernate();\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}\n\npower_attr(state);\n\n#ifdef CONFIG_PM_SLEEP\n \n\nstatic ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -EINTR;\n}\n\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terror = -EINVAL;\n\tif (sscanf(buf, \"%u\", &val) == 1) {\n\t\tif (pm_save_wakeup_count(val))\n\t\t\terror = n;\n\t\telse\n\t\t\tpm_print_active_wakeup_sources();\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error;\n}\n\npower_attr(wakeup_count);\n\n#ifdef CONFIG_PM_AUTOSLEEP\nstatic ssize_t autosleep_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tsuspend_state_t state = pm_autosleep_state();\n\n\tif (state == PM_SUSPEND_ON)\n\t\treturn sprintf(buf, \"off\\n\");\n\n#ifdef CONFIG_SUSPEND\n\tif (state < PM_SUSPEND_MAX)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef CONFIG_HIBERNATION\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}\n\nstatic ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == PM_SUSPEND_ON\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -EINVAL;\n\n\tif (state == PM_SUSPEND_MEM)\n\t\tstate = mem_sleep_current;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}\n\npower_attr(autosleep);\n#endif  \n\n#ifdef CONFIG_PM_WAKELOCKS\nstatic ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}\n\nstatic ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}\n\npower_attr(wake_lock);\n\nstatic ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}\n\nstatic ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}\n\npower_attr(wake_unlock);\n\n#endif  \n#endif  \n\n#ifdef CONFIG_PM_TRACE\nint pm_trace_enabled;\n\nstatic ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}\n\nstatic ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -EINVAL;\n}\n\npower_attr(pm_trace);\n\nstatic ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, PAGE_SIZE);\n}\n\npower_attr_ro(pm_trace_dev_match);\n\n#endif  \n\n#ifdef CONFIG_FREEZER\nstatic ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}\n\nstatic ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}\n\npower_attr(pm_freeze_timeout);\n\n#endif\t \n\nstatic struct attribute * g[] = {\n\t&state_attr.attr,\n#ifdef CONFIG_PM_TRACE\n\t&pm_trace_attr.attr,\n\t&pm_trace_dev_match_attr.attr,\n#endif\n#ifdef CONFIG_PM_SLEEP\n\t&pm_async_attr.attr,\n\t&wakeup_count_attr.attr,\n#ifdef CONFIG_SUSPEND\n\t&mem_sleep_attr.attr,\n\t&sync_on_suspend_attr.attr,\n#endif\n#ifdef CONFIG_PM_AUTOSLEEP\n\t&autosleep_attr.attr,\n#endif\n#ifdef CONFIG_PM_WAKELOCKS\n\t&wake_lock_attr.attr,\n\t&wake_unlock_attr.attr,\n#endif\n#ifdef CONFIG_PM_SLEEP_DEBUG\n\t&pm_test_attr.attr,\n\t&pm_print_times_attr.attr,\n\t&pm_wakeup_irq_attr.attr,\n\t&pm_debug_messages_attr.attr,\n#endif\n#endif\n#ifdef CONFIG_FREEZER\n\t&pm_freeze_timeout_attr.attr,\n#endif\n\tNULL,\n};\n\nstatic const struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\nstatic const struct attribute_group *attr_groups[] = {\n\t&attr_group,\n#ifdef CONFIG_PM_SLEEP\n\t&suspend_attr_group,\n#endif\n\tNULL,\n};\n\nstruct workqueue_struct *pm_wq;\nEXPORT_SYMBOL_GPL(pm_wq);\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}\n\nstatic int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpm_states_init();\n\tpower_kobj = kobject_create_and_add(\"power\", NULL);\n\tif (!power_kobj)\n\t\treturn -ENOMEM;\n\terror = sysfs_create_groups(power_kobj, attr_groups);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}\n\ncore_initcall(pm_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}