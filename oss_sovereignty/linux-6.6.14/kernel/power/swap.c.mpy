{
  "module_name": "swap.c",
  "hash_id": "c03a237effdc84cb5ec4f8f85beac1c20952e378601910defbcd38b25c4c5228",
  "original_prompt": "Ingested from linux-6.6.14/kernel/power/swap.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"PM: \" fmt\n\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/swapops.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/lzo.h>\n#include <linux/vmalloc.h>\n#include <linux/cpumask.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/crc32.h>\n#include <linux/ktime.h>\n\n#include \"power.h\"\n\n#define HIBERNATE_SIG\t\"S1SUSPEND\"\n\nu32 swsusp_hardware_signature;\n\n \nstatic bool clean_pages_on_read;\nstatic bool clean_pages_on_decompress;\n\n \n\n#define MAP_PAGE_ENTRIES\t(PAGE_SIZE / sizeof(sector_t) - 1)\n\n \nstatic inline unsigned long low_free_pages(void)\n{\n\treturn nr_free_pages() - nr_free_highpages();\n}\n\n \nstatic inline unsigned long reqd_free_pages(void)\n{\n\treturn low_free_pages() / 2;\n}\n\nstruct swap_map_page {\n\tsector_t entries[MAP_PAGE_ENTRIES];\n\tsector_t next_swap;\n};\n\nstruct swap_map_page_list {\n\tstruct swap_map_page *map;\n\tstruct swap_map_page_list *next;\n};\n\n \n\nstruct swap_map_handle {\n\tstruct swap_map_page *cur;\n\tstruct swap_map_page_list *maps;\n\tsector_t cur_swap;\n\tsector_t first_sector;\n\tunsigned int k;\n\tunsigned long reqd_free_pages;\n\tu32 crc32;\n};\n\nstruct swsusp_header {\n\tchar reserved[PAGE_SIZE - 20 - sizeof(sector_t) - sizeof(int) -\n\t              sizeof(u32) - sizeof(u32)];\n\tu32\thw_sig;\n\tu32\tcrc32;\n\tsector_t image;\n\tunsigned int flags;\t \n\tchar\torig_sig[10];\n\tchar\tsig[10];\n} __packed;\n\nstatic struct swsusp_header *swsusp_header;\n\n \n\nstruct swsusp_extent {\n\tstruct rb_node node;\n\tunsigned long start;\n\tunsigned long end;\n};\n\nstatic struct rb_root swsusp_extents = RB_ROOT;\n\nstatic int swsusp_extents_insert(unsigned long swap_offset)\n{\n\tstruct rb_node **new = &(swsusp_extents.rb_node);\n\tstruct rb_node *parent = NULL;\n\tstruct swsusp_extent *ext;\n\n\t \n\twhile (*new) {\n\t\text = rb_entry(*new, struct swsusp_extent, node);\n\t\tparent = *new;\n\t\tif (swap_offset < ext->start) {\n\t\t\t \n\t\t\tif (swap_offset == ext->start - 1) {\n\t\t\t\text->start--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_left);\n\t\t} else if (swap_offset > ext->end) {\n\t\t\t \n\t\t\tif (swap_offset == ext->end + 1) {\n\t\t\t\text->end++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnew = &((*new)->rb_right);\n\t\t} else {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\text = kzalloc(sizeof(struct swsusp_extent), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->start = swap_offset;\n\text->end = swap_offset;\n\trb_link_node(&ext->node, parent, new);\n\trb_insert_color(&ext->node, &swsusp_extents);\n\treturn 0;\n}\n\n \n\nsector_t alloc_swapdev_block(int swap)\n{\n\tunsigned long offset;\n\n\toffset = swp_offset(get_swap_page_of_type(swap));\n\tif (offset) {\n\t\tif (swsusp_extents_insert(offset))\n\t\t\tswap_free(swp_entry(swap, offset));\n\t\telse\n\t\t\treturn swapdev_block(swap, offset);\n\t}\n\treturn 0;\n}\n\n \n\nvoid free_all_swap_pages(int swap)\n{\n\tstruct rb_node *node;\n\n\twhile ((node = swsusp_extents.rb_node)) {\n\t\tstruct swsusp_extent *ext;\n\t\tunsigned long offset;\n\n\t\text = rb_entry(node, struct swsusp_extent, node);\n\t\trb_erase(node, &swsusp_extents);\n\t\tfor (offset = ext->start; offset <= ext->end; offset++)\n\t\t\tswap_free(swp_entry(swap, offset));\n\n\t\tkfree(ext);\n\t}\n}\n\nint swsusp_swap_in_use(void)\n{\n\treturn (swsusp_extents.rb_node != NULL);\n}\n\n \n\nstatic unsigned short root_swap = 0xffff;\nstatic struct block_device *hib_resume_bdev;\n\nstruct hib_bio_batch {\n\tatomic_t\t\tcount;\n\twait_queue_head_t\twait;\n\tblk_status_t\t\terror;\n\tstruct blk_plug\t\tplug;\n};\n\nstatic void hib_init_batch(struct hib_bio_batch *hb)\n{\n\tatomic_set(&hb->count, 0);\n\tinit_waitqueue_head(&hb->wait);\n\thb->error = BLK_STS_OK;\n\tblk_start_plug(&hb->plug);\n}\n\nstatic void hib_finish_batch(struct hib_bio_batch *hb)\n{\n\tblk_finish_plug(&hb->plug);\n}\n\nstatic void hib_end_io(struct bio *bio)\n{\n\tstruct hib_bio_batch *hb = bio->bi_private;\n\tstruct page *page = bio_first_page_all(bio);\n\n\tif (bio->bi_status) {\n\t\tpr_alert(\"Read-error on swap-device (%u:%u:%Lu)\\n\",\n\t\t\t MAJOR(bio_dev(bio)), MINOR(bio_dev(bio)),\n\t\t\t (unsigned long long)bio->bi_iter.bi_sector);\n\t}\n\n\tif (bio_data_dir(bio) == WRITE)\n\t\tput_page(page);\n\telse if (clean_pages_on_read)\n\t\tflush_icache_range((unsigned long)page_address(page),\n\t\t\t\t   (unsigned long)page_address(page) + PAGE_SIZE);\n\n\tif (bio->bi_status && !hb->error)\n\t\thb->error = bio->bi_status;\n\tif (atomic_dec_and_test(&hb->count))\n\t\twake_up(&hb->wait);\n\n\tbio_put(bio);\n}\n\nstatic int hib_submit_io(blk_opf_t opf, pgoff_t page_off, void *addr,\n\t\t\t struct hib_bio_batch *hb)\n{\n\tstruct page *page = virt_to_page(addr);\n\tstruct bio *bio;\n\tint error = 0;\n\n\tbio = bio_alloc(hib_resume_bdev, 1, opf, GFP_NOIO | __GFP_HIGH);\n\tbio->bi_iter.bi_sector = page_off * (PAGE_SIZE >> 9);\n\n\tif (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\tpr_err(\"Adding page to bio failed at %llu\\n\",\n\t\t       (unsigned long long)bio->bi_iter.bi_sector);\n\t\tbio_put(bio);\n\t\treturn -EFAULT;\n\t}\n\n\tif (hb) {\n\t\tbio->bi_end_io = hib_end_io;\n\t\tbio->bi_private = hb;\n\t\tatomic_inc(&hb->count);\n\t\tsubmit_bio(bio);\n\t} else {\n\t\terror = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\n\treturn error;\n}\n\nstatic int hib_wait_io(struct hib_bio_batch *hb)\n{\n\t \n\twait_event(hb->wait, atomic_read(&hb->count) == 0);\n\treturn blk_status_to_errno(hb->error);\n}\n\n \nstatic int mark_swapfiles(struct swap_map_handle *handle, unsigned int flags)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, swsusp_resume_block, swsusp_header, NULL);\n\tif (!memcmp(\"SWAP-SPACE\",swsusp_header->sig, 10) ||\n\t    !memcmp(\"SWAPSPACE2\",swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->orig_sig,swsusp_header->sig, 10);\n\t\tmemcpy(swsusp_header->sig, HIBERNATE_SIG, 10);\n\t\tswsusp_header->image = handle->first_sector;\n\t\tif (swsusp_hardware_signature) {\n\t\t\tswsusp_header->hw_sig = swsusp_hardware_signature;\n\t\t\tflags |= SF_HW_SIG;\n\t\t}\n\t\tswsusp_header->flags = flags;\n\t\tif (flags & SF_CRC32_MODE)\n\t\t\tswsusp_header->crc32 = handle->crc32;\n\t\terror = hib_submit_io(REQ_OP_WRITE | REQ_SYNC,\n\t\t\t\t      swsusp_resume_block, swsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Swap header not found!\\n\");\n\t\terror = -ENODEV;\n\t}\n\treturn error;\n}\n\n \nstatic int swsusp_swap_check(void)\n{\n\tint res;\n\n\tif (swsusp_resume_device)\n\t\tres = swap_type_of(swsusp_resume_device, swsusp_resume_block);\n\telse\n\t\tres = find_first_swap(&swsusp_resume_device);\n\tif (res < 0)\n\t\treturn res;\n\troot_swap = res;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device,\n\t\t\tBLK_OPEN_WRITE, NULL, NULL);\n\tif (IS_ERR(hib_resume_bdev))\n\t\treturn PTR_ERR(hib_resume_bdev);\n\n\tres = set_blocksize(hib_resume_bdev, PAGE_SIZE);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, NULL);\n\n\treturn res;\n}\n\n \n\nstatic int write_page(void *buf, sector_t offset, struct hib_bio_batch *hb)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -ENOSPC;\n\n\tif (hb) {\n\t\tsrc = (void *)__get_free_page(GFP_NOIO | __GFP_NOWARN |\n\t\t                              __GFP_NORETRY);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_io(hb);  \n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(GFP_NOIO |\n\t\t\t                              __GFP_NOWARN |\n\t\t\t                              __GFP_NORETRY);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\thb = NULL;\t \n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_submit_io(REQ_OP_WRITE | REQ_SYNC, offset, src, hb);\n}\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur)\n\t\tfree_page((unsigned long)handle->cur);\n\thandle->cur = NULL;\n}\n\nstatic int get_swap_writer(struct swap_map_handle *handle)\n{\n\tint ret;\n\n\tret = swsusp_swap_check();\n\tif (ret) {\n\t\tif (ret != -ENOSPC)\n\t\t\tpr_err(\"Cannot find swap device, try swapon -a\\n\");\n\t\treturn ret;\n\t}\n\thandle->cur = (struct swap_map_page *)get_zeroed_page(GFP_KERNEL);\n\tif (!handle->cur) {\n\t\tret = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\thandle->cur_swap = alloc_swapdev_block(root_swap);\n\tif (!handle->cur_swap) {\n\t\tret = -ENOSPC;\n\t\tgoto err_rel;\n\t}\n\thandle->k = 0;\n\thandle->reqd_free_pages = reqd_free_pages();\n\thandle->first_sector = handle->cur_swap;\n\treturn 0;\nerr_rel:\n\trelease_swap_writer(handle);\nerr_close:\n\tswsusp_close(false);\n\treturn ret;\n}\n\nstatic int swap_write_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tint error = 0;\n\tsector_t offset;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = alloc_swapdev_block(root_swap);\n\terror = write_page(buf, offset, hb);\n\tif (error)\n\t\treturn error;\n\thandle->cur->entries[handle->k++] = offset;\n\tif (handle->k >= MAP_PAGE_ENTRIES) {\n\t\toffset = alloc_swapdev_block(root_swap);\n\t\tif (!offset)\n\t\t\treturn -ENOSPC;\n\t\thandle->cur->next_swap = offset;\n\t\terror = write_page(handle->cur, handle->cur_swap, hb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tclear_page(handle->cur);\n\t\thandle->cur_swap = offset;\n\t\thandle->k = 0;\n\n\t\tif (hb && low_free_pages() <= handle->reqd_free_pages) {\n\t\t\terror = hib_wait_io(hb);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\thandle->reqd_free_pages = reqd_free_pages();\n\t\t}\n\t}\n out:\n\treturn error;\n}\n\nstatic int flush_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->cur && handle->cur_swap)\n\t\treturn write_page(handle->cur, handle->cur_swap, NULL);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int swap_writer_finish(struct swap_map_handle *handle,\n\t\tunsigned int flags, int error)\n{\n\tif (!error) {\n\t\tpr_info(\"S\");\n\t\terror = mark_swapfiles(handle, flags);\n\t\tpr_cont(\"|\\n\");\n\t\tflush_swap_writer(handle);\n\t}\n\n\tif (error)\n\t\tfree_all_swap_pages(root_swap);\n\trelease_swap_writer(handle);\n\tswsusp_close(false);\n\n\treturn error;\n}\n\n \n#define LZO_HEADER\tsizeof(size_t)\n\n \n#define LZO_UNC_PAGES\t32\n#define LZO_UNC_SIZE\t(LZO_UNC_PAGES * PAGE_SIZE)\n\n \n#define LZO_CMP_PAGES\tDIV_ROUND_UP(lzo1x_worst_compress(LZO_UNC_SIZE) + \\\n\t\t\t             LZO_HEADER, PAGE_SIZE)\n#define LZO_CMP_SIZE\t(LZO_CMP_PAGES * PAGE_SIZE)\n\n \n#define LZO_THREADS\t3\n\n \n#define LZO_MIN_RD_PAGES\t1024\n#define LZO_MAX_RD_PAGES\t8192\n\n\n \n\nstatic int save_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\n\thib_init_batch(&hb);\n\n\tpr_info(\"Saving image data pages (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\twhile (1) {\n\t\tret = snapshot_read_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\thib_finish_batch(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\n\treturn ret;\n}\n\n \nstruct crc_data {\n\tstruct task_struct *thr;                   \n\tatomic_t ready;                            \n\tatomic_t stop;                             \n\tunsigned run_threads;                      \n\twait_queue_head_t go;                      \n\twait_queue_head_t done;                    \n\tu32 *crc32;                                \n\tsize_t *unc_len[LZO_THREADS];              \n\tunsigned char *unc[LZO_THREADS];           \n};\n\n \nstatic int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\tfor (i = 0; i < d->run_threads; i++)\n\t\t\t*d->crc32 = crc32_le(*d->crc32,\n\t\t\t                     d->unc[i], *d->unc_len[i]);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}\n \nstruct cmp_data {\n\tstruct task_struct *thr;                   \n\tatomic_t ready;                            \n\tatomic_t stop;                             \n\tint ret;                                   \n\twait_queue_head_t go;                      \n\twait_queue_head_t done;                    \n\tsize_t unc_len;                            \n\tsize_t cmp_len;                            \n\tunsigned char unc[LZO_UNC_SIZE];           \n\tunsigned char cmp[LZO_CMP_SIZE];           \n\tunsigned char wrk[LZO1X_1_MEM_COMPRESS];   \n};\n\n \nstatic int lzo_compress_threadfn(void *data)\n{\n\tstruct cmp_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->ret = lzo1x_1_compress(d->unc, d->unc_len,\n\t\t                          d->cmp + LZO_HEADER, &d->cmp_len,\n\t\t                          d->wrk);\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}\n\n \nstatic int save_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_write)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint nr_pages;\n\tint err2;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tsize_t off;\n\tunsigned thr, run_threads, nr_threads;\n\tunsigned char *page = NULL;\n\tstruct cmp_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t \n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = (void *)__get_free_page(GFP_NOIO | __GFP_HIGH);\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t \n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start compression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t \n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t \n\thandle->reqd_free_pages = reqd_free_pages();\n\n\tpr_info(\"Using %u thread(s) for compression\\n\", nr_threads);\n\tpr_info(\"Compressing and saving image data (%u pages)...\\n\",\n\t\tnr_to_write);\n\tm = nr_to_write / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\t\tfor (off = 0; off < LZO_UNC_SIZE; off += PAGE_SIZE) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image saving progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(data[thr].unc_len))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\t*(size_t *)data[thr].cmp = data[thr].cmp_len;\n\n\t\t\t \n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, PAGE_SIZE);\n\n\t\t\t\tret = swap_write_page(handle, page, &hb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\nout_finish:\n\terr2 = hib_wait_io(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tpr_info(\"Image saving done\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"Wrote\");\nout_clean:\n\thib_finish_batch(&hb);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}\n\n \n\nstatic int enough_swap(unsigned int nr_pages)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"Free swap pages: %u\\n\", free_swap);\n\n\trequired = PAGES_FOR_IO + nr_pages;\n\treturn free_swap > required;\n}\n\n \n\nint swsusp_write(unsigned int flags)\n{\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\tunsigned long pages;\n\tint error;\n\n\tpages = snapshot_get_image_size();\n\terror = get_swap_writer(&handle);\n\tif (error) {\n\t\tpr_err(\"Cannot get swap writer\\n\");\n\t\treturn error;\n\t}\n\tif (flags & SF_NOCOMPRESS_MODE) {\n\t\tif (!enough_swap(pages)) {\n\t\t\tpr_err(\"Not enough free swap\\n\");\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out_finish;\n\t\t}\n\t}\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_read_next(&snapshot);\n\tif (error < (int)PAGE_SIZE) {\n\t\tif (error >= 0)\n\t\t\terror = -EFAULT;\n\n\t\tgoto out_finish;\n\t}\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = swap_write_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (flags & SF_NOCOMPRESS_MODE) ?\n\t\t\tsave_image(&handle, &snapshot, pages - 1) :\n\t\t\tsave_image_lzo(&handle, &snapshot, pages - 1);\n\t}\nout_finish:\n\terror = swap_writer_finish(&handle, flags, error);\n\treturn error;\n}\n\n \n\nstatic void release_swap_reader(struct swap_map_handle *handle)\n{\n\tstruct swap_map_page_list *tmp;\n\n\twhile (handle->maps) {\n\t\tif (handle->maps->map)\n\t\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t}\n\thandle->cur = NULL;\n}\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image)  \n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kzalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}\n\nstatic int swap_read_page(struct swap_map_handle *handle, void *buf,\n\t\tstruct hib_bio_batch *hb)\n{\n\tsector_t offset;\n\tint error;\n\tstruct swap_map_page_list *tmp;\n\n\tif (!handle->cur)\n\t\treturn -EINVAL;\n\toffset = handle->cur->entries[handle->k];\n\tif (!offset)\n\t\treturn -EFAULT;\n\terror = hib_submit_io(REQ_OP_READ, offset, buf, hb);\n\tif (error)\n\t\treturn error;\n\tif (++handle->k >= MAP_PAGE_ENTRIES) {\n\t\thandle->k = 0;\n\t\tfree_page((unsigned long)handle->maps->map);\n\t\ttmp = handle->maps;\n\t\thandle->maps = handle->maps->next;\n\t\tkfree(tmp);\n\t\tif (!handle->maps)\n\t\t\trelease_swap_reader(handle);\n\t\telse\n\t\t\thandle->cur = handle->maps->map;\n\t}\n\treturn error;\n}\n\nstatic int swap_reader_finish(struct swap_map_handle *handle)\n{\n\trelease_swap_reader(handle);\n\n\treturn 0;\n}\n\n \n\nstatic int load_image(struct swap_map_handle *handle,\n                      struct snapshot_handle *snapshot,\n                      unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tktime_t start;\n\tktime_t stop;\n\tstruct hib_bio_batch hb;\n\tint err2;\n\tunsigned nr_pages;\n\n\thib_init_batch(&hb);\n\n\tclean_pages_on_read = true;\n\tpr_info(\"Loading image data pages (%u pages)...\\n\", nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\tfor ( ; ; ) {\n\t\tret = snapshot_write_next(snapshot);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->sync_read)\n\t\t\tret = hib_wait_io(&hb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\tnr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_io(&hb);\n\thib_finish_batch(&hb);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\n\treturn ret;\n}\n\n \nstruct dec_data {\n\tstruct task_struct *thr;                   \n\tatomic_t ready;                            \n\tatomic_t stop;                             \n\tint ret;                                   \n\twait_queue_head_t go;                      \n\twait_queue_head_t done;                    \n\tsize_t unc_len;                            \n\tsize_t cmp_len;                            \n\tunsigned char unc[LZO_UNC_SIZE];           \n\tunsigned char cmp[LZO_CMP_SIZE];           \n};\n\n \nstatic int lzo_decompress_threadfn(void *data)\n{\n\tstruct dec_data *d = data;\n\n\twhile (1) {\n\t\twait_event(d->go, atomic_read(&d->ready) ||\n\t\t                  kthread_should_stop());\n\t\tif (kthread_should_stop()) {\n\t\t\td->thr = NULL;\n\t\t\td->ret = -1;\n\t\t\tatomic_set(&d->stop, 1);\n\t\t\twake_up(&d->done);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_set(&d->ready, 0);\n\n\t\td->unc_len = LZO_UNC_SIZE;\n\t\td->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,\n\t\t                               d->unc, &d->unc_len);\n\t\tif (clean_pages_on_decompress)\n\t\t\tflush_icache_range((unsigned long)d->unc,\n\t\t\t\t\t   (unsigned long)d->unc + d->unc_len);\n\n\t\tatomic_set(&d->stop, 1);\n\t\twake_up(&d->done);\n\t}\n\treturn 0;\n}\n\n \nstatic int load_image_lzo(struct swap_map_handle *handle,\n                          struct snapshot_handle *snapshot,\n                          unsigned int nr_to_read)\n{\n\tunsigned int m;\n\tint ret = 0;\n\tint eof = 0;\n\tstruct hib_bio_batch hb;\n\tktime_t start;\n\tktime_t stop;\n\tunsigned nr_pages;\n\tsize_t off;\n\tunsigned i, thr, run_threads, nr_threads;\n\tunsigned ring = 0, pg = 0, ring_size = 0,\n\t         have = 0, want, need, asked = 0;\n\tunsigned long read_pages = 0;\n\tunsigned char **page = NULL;\n\tstruct dec_data *data = NULL;\n\tstruct crc_data *crc = NULL;\n\n\thib_init_batch(&hb);\n\n\t \n\tnr_threads = num_online_cpus() - 1;\n\tnr_threads = clamp_val(nr_threads, 1, LZO_THREADS);\n\n\tpage = vmalloc(array_size(LZO_MAX_RD_PAGES, sizeof(*page)));\n\tif (!page) {\n\t\tpr_err(\"Failed to allocate LZO page\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tdata = vzalloc(array_size(nr_threads, sizeof(*data)));\n\tif (!data) {\n\t\tpr_err(\"Failed to allocate LZO data\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tcrc = kzalloc(sizeof(*crc), GFP_KERNEL);\n\tif (!crc) {\n\t\tpr_err(\"Failed to allocate crc\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\tclean_pages_on_decompress = true;\n\n\t \n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (IS_ERR(data[thr].thr)) {\n\t\t\tdata[thr].thr = NULL;\n\t\t\tpr_err(\"Cannot start decompression threads\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t \n\tinit_waitqueue_head(&crc->go);\n\tinit_waitqueue_head(&crc->done);\n\n\thandle->crc32 = 0;\n\tcrc->crc32 = &handle->crc32;\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tcrc->unc[thr] = data[thr].unc;\n\t\tcrc->unc_len[thr] = &data[thr].unc_len;\n\t}\n\n\tcrc->thr = kthread_run(crc32_threadfn, crc, \"image_crc32\");\n\tif (IS_ERR(crc->thr)) {\n\t\tcrc->thr = NULL;\n\t\tpr_err(\"Cannot start CRC32 thread\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_clean;\n\t}\n\n\t \n\tif (low_free_pages() > snapshot_get_image_size())\n\t\tread_pages = (low_free_pages() - snapshot_get_image_size()) / 2;\n\tread_pages = clamp_val(read_pages, LZO_MIN_RD_PAGES, LZO_MAX_RD_PAGES);\n\n\tfor (i = 0; i < read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < LZO_CMP_PAGES ?\n\t\t\t\t\t\t  GFP_NOIO | __GFP_HIGH :\n\t\t\t\t\t\t  GFP_NOIO | __GFP_NOWARN |\n\t\t\t\t\t\t  __GFP_NORETRY);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < LZO_CMP_PAGES) {\n\t\t\t\tring_size = i;\n\t\t\t\tpr_err(\"Failed to allocate LZO pages\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tpr_info(\"Using %u thread(s) for decompression\\n\", nr_threads);\n\tpr_info(\"Loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &hb);\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tif (handle->cur &&\n\t\t\t\t    handle->cur->entries[handle->k]) {\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t} else {\n\t\t\t\t\teof = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++ring >= ring_size)\n\t\t\t\tring = 0;\n\t\t}\n\t\tasked += i;\n\t\twant -= i;\n\n\t\t \n\t\tif (!have) {\n\t\t\tif (!asked)\n\t\t\t\tbreak;\n\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tif (crc->run_threads) {\n\t\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\t\tatomic_set(&crc->stop, 0);\n\t\t\tcrc->run_threads = 0;\n\t\t}\n\n\t\tfor (thr = 0; have && thr < nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >\n\t\t\t             lzo1x_worst_compress(LZO_UNC_SIZE))) {\n\t\t\t\tpr_err(\"Invalid LZO compressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tneed = DIV_ROUND_UP(data[thr].cmp_len + LZO_HEADER,\n\t\t\t                    PAGE_SIZE);\n\t\t\tif (need > have) {\n\t\t\t\tif (eof > 1) {\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < LZO_HEADER + data[thr].cmp_len;\n\t\t\t     off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], PAGE_SIZE);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >= ring_size)\n\t\t\t\t\tpg = 0;\n\t\t\t}\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\t \n\t\tif (have < LZO_CMP_PAGES && asked) {\n\t\t\tret = hib_wait_io(&hb);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"LZO decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len > LZO_UNC_SIZE ||\n\t\t\t             data[thr].unc_len & (PAGE_SIZE - 1))) {\n\t\t\t\tpr_err(\"Invalid LZO uncompressed length\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tfor (off = 0;\n\t\t\t     off < data[thr].unc_len; off += PAGE_SIZE) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, PAGE_SIZE);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tpr_info(\"Image loading progress: %3d%%\\n\",\n\t\t\t\t\t\tnr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->run_threads = thr + 1;\n\t\t\t\t\tatomic_set(&crc->ready, 1);\n\t\t\t\t\twake_up(&crc->go);\n\t\t\t\t\tgoto out_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcrc->run_threads = thr;\n\t\tatomic_set(&crc->ready, 1);\n\t\twake_up(&crc->go);\n\t}\n\nout_finish:\n\tif (crc->run_threads) {\n\t\twait_event(crc->done, atomic_read(&crc->stop));\n\t\tatomic_set(&crc->stop, 0);\n\t}\n\tstop = ktime_get();\n\tif (!ret) {\n\t\tpr_info(\"Image loading done\\n\");\n\t\tsnapshot_write_finalize(snapshot);\n\t\tif (!snapshot_image_loaded(snapshot))\n\t\t\tret = -ENODATA;\n\t\tif (!ret) {\n\t\t\tif (swsusp_header->flags & SF_CRC32_MODE) {\n\t\t\t\tif(handle->crc32 != swsusp_header->crc32) {\n\t\t\t\t\tpr_err(\"Invalid image CRC32!\\n\");\n\t\t\t\t\tret = -ENODATA;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tswsusp_show_speed(start, stop, nr_to_read, \"Read\");\nout_clean:\n\thib_finish_batch(&hb);\n\tfor (i = 0; i < ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->thr)\n\t\t\tkthread_stop(crc->thr);\n\t\tkfree(crc);\n\t}\n\tif (data) {\n\t\tfor (thr = 0; thr < nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}\n\n \n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < (int)PAGE_SIZE)\n\t\treturn error < 0 ? error : -EFAULT;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, NULL);\n\tif (!error) {\n\t\terror = (*flags_p & SF_NOCOMPRESS_MODE) ?\n\t\t\tload_image(&handle, &snapshot, header->pages - 1) :\n\t\t\tload_image_lzo(&handle, &snapshot, header->pages - 1);\n\t}\n\tswap_reader_finish(&handle);\nend:\n\tif (!error)\n\t\tpr_debug(\"Image successfully loaded\\n\");\n\telse\n\t\tpr_debug(\"Error %d resuming\\n\", error);\n\treturn error;\n}\n\nstatic void *swsusp_holder;\n\n \n\nint swsusp_check(bool exclusive)\n{\n\tvoid *holder = exclusive ? &swsusp_holder : NULL;\n\tint error;\n\n\thib_resume_bdev = blkdev_get_by_dev(swsusp_resume_device, BLK_OPEN_READ,\n\t\t\t\t\t    holder, NULL);\n\tif (!IS_ERR(hib_resume_bdev)) {\n\t\tset_blocksize(hib_resume_bdev, PAGE_SIZE);\n\t\tclear_page(swsusp_header);\n\t\terror = hib_submit_io(REQ_OP_READ, swsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t\tif (error)\n\t\t\tgoto put;\n\n\t\tif (!memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)) {\n\t\t\tmemcpy(swsusp_header->sig, swsusp_header->orig_sig, 10);\n\t\t\t \n\t\t\terror = hib_submit_io(REQ_OP_WRITE | REQ_SYNC,\n\t\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\t\tswsusp_header, NULL);\n\t\t} else {\n\t\t\terror = -EINVAL;\n\t\t}\n\t\tif (!error && swsusp_header->flags & SF_HW_SIG &&\n\t\t    swsusp_header->hw_sig != swsusp_hardware_signature) {\n\t\t\tpr_info(\"Suspend image hardware signature mismatch (%08x now %08x); aborting resume.\\n\",\n\t\t\t\tswsusp_header->hw_sig, swsusp_hardware_signature);\n\t\t\terror = -EINVAL;\n\t\t}\n\nput:\n\t\tif (error)\n\t\t\tblkdev_put(hib_resume_bdev, holder);\n\t\telse\n\t\t\tpr_debug(\"Image signature found, resuming\\n\");\n\t} else {\n\t\terror = PTR_ERR(hib_resume_bdev);\n\t}\n\n\tif (error)\n\t\tpr_debug(\"Image not found (code %d)\\n\", error);\n\n\treturn error;\n}\n\n \n\nvoid swsusp_close(bool exclusive)\n{\n\tif (IS_ERR(hib_resume_bdev)) {\n\t\tpr_debug(\"Image device not initialised\\n\");\n\t\treturn;\n\t}\n\n\tblkdev_put(hib_resume_bdev, exclusive ? &swsusp_holder : NULL);\n}\n\n \n\n#ifdef CONFIG_SUSPEND\nint swsusp_unmark(void)\n{\n\tint error;\n\n\thib_submit_io(REQ_OP_READ, swsusp_resume_block,\n\t\t\tswsusp_header, NULL);\n\tif (!memcmp(HIBERNATE_SIG,swsusp_header->sig, 10)) {\n\t\tmemcpy(swsusp_header->sig,swsusp_header->orig_sig, 10);\n\t\terror = hib_submit_io(REQ_OP_WRITE | REQ_SYNC,\n\t\t\t\t\tswsusp_resume_block,\n\t\t\t\t\tswsusp_header, NULL);\n\t} else {\n\t\tpr_err(\"Cannot find swsusp signature!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\t \n\tfree_all_swap_pages(root_swap);\n\n\treturn error;\n}\n#endif\n\nstatic int __init swsusp_header_init(void)\n{\n\tswsusp_header = (struct swsusp_header*) __get_free_page(GFP_KERNEL);\n\tif (!swsusp_header)\n\t\tpanic(\"Could not allocate memory for swsusp_header\\n\");\n\treturn 0;\n}\n\ncore_initcall(swsusp_header_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}