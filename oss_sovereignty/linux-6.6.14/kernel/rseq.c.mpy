{
  "module_name": "rseq.c",
  "hash_id": "7f59fca179ceb613607abfec60f6bcf5230e15b0a31d50a9413eb1f3ef439b75",
  "original_prompt": "Ingested from linux-6.6.14/kernel/rseq.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/rseq.h>\n#include <linux/types.h>\n#include <asm/ptrace.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/rseq.h>\n\n \n#define ORIG_RSEQ_SIZE\t\t32\n\n#define RSEQ_CS_NO_RESTART_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT | \\\n\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL | \\\n\t\t\t\t  RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE)\n\n \n\nstatic int rseq_update_cpu_node_id(struct task_struct *t)\n{\n\tstruct rseq __user *rseq = t->rseq;\n\tu32 cpu_id = raw_smp_processor_id();\n\tu32 node_id = cpu_to_node(cpu_id);\n\tu32 mm_cid = task_mm_cid(t);\n\n\tWARN_ON_ONCE((int) mm_cid < 0);\n\tif (!user_write_access_begin(rseq, t->rseq_len))\n\t\tgoto efault;\n\tunsafe_put_user(cpu_id, &rseq->cpu_id_start, efault_end);\n\tunsafe_put_user(cpu_id, &rseq->cpu_id, efault_end);\n\tunsafe_put_user(node_id, &rseq->node_id, efault_end);\n\tunsafe_put_user(mm_cid, &rseq->mm_cid, efault_end);\n\t \n\tuser_write_access_end();\n\ttrace_rseq_update(t);\n\treturn 0;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\treturn -EFAULT;\n}\n\nstatic int rseq_reset_rseq_cpu_node_id(struct task_struct *t)\n{\n\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED, node_id = 0,\n\t    mm_cid = 0;\n\n\t \n\tif (put_user(cpu_id_start, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\t \n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\t \n\tif (put_user(node_id, &t->rseq->node_id))\n\t\treturn -EFAULT;\n\t \n\tif (put_user(mm_cid, &t->rseq->mm_cid))\n\t\treturn -EFAULT;\n\t \n\treturn 0;\n}\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t \n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t \n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic bool rseq_warn_flags(const char *str, u32 flags)\n{\n\tu32 test_flags;\n\n\tif (!flags)\n\t\treturn false;\n\ttest_flags = flags & RSEQ_CS_NO_RESTART_FLAGS;\n\tif (test_flags)\n\t\tpr_warn_once(\"Deprecated flags (%u) in %s ABI structure\", test_flags, str);\n\ttest_flags = flags & ~RSEQ_CS_NO_RESTART_FLAGS;\n\tif (test_flags)\n\t\tpr_warn_once(\"Unknown flags (%u) in %s ABI structure\", test_flags, str);\n\treturn true;\n}\n\nstatic int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\tif (rseq_warn_flags(\"rseq_cs\", cs_flags))\n\t\treturn -EINVAL;\n\n\t \n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rseq_warn_flags(\"rseq\", flags))\n\t\treturn -EINVAL;\n\n\t \n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!event_mask;\n}\n\nstatic int clear_rseq_cs(struct task_struct *t)\n{\n\t \n#ifdef CONFIG_64BIT\n\treturn put_user(0UL, &t->rseq->rseq_cs);\n#else\n\tif (clear_user(&t->rseq->rseq_cs, sizeof(t->rseq->rseq_cs)))\n\t\treturn -EFAULT;\n\treturn 0;\n#endif\n}\n\n \nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}\n\nstatic int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}\n\n \nvoid __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *t = current;\n\tint ret, sig;\n\n\tif (unlikely(t->flags & PF_EXITING))\n\t\treturn;\n\n\t \n\tif (regs) {\n\t\tret = rseq_ip_fixup(regs);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\tif (unlikely(rseq_update_cpu_node_id(t)))\n\t\tgoto error;\n\treturn;\n\nerror:\n\tsig = ksig ? ksig->sig : 0;\n\tforce_sigsegv(sig);\n}\n\n#ifdef CONFIG_DEBUG_RSEQ\n\n \nvoid rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV);\n}\n\n#endif\n\n \nSYSCALL_DEFINE4(rseq, struct rseq __user *, rseq, u32, rseq_len,\n\t\tint, flags, u32, sig)\n{\n\tint ret;\n\n\tif (flags & RSEQ_FLAG_UNREGISTER) {\n\t\tif (flags & ~RSEQ_FLAG_UNREGISTER)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (current->rseq != rseq || !current->rseq)\n\t\t\treturn -EINVAL;\n\t\tif (rseq_len != current->rseq_len)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\tret = rseq_reset_rseq_cpu_node_id(current);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcurrent->rseq = NULL;\n\t\tcurrent->rseq_sig = 0;\n\t\tcurrent->rseq_len = 0;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(flags))\n\t\treturn -EINVAL;\n\n\tif (current->rseq) {\n\t\t \n\t\tif (current->rseq != rseq || rseq_len != current->rseq_len)\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\t \n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (rseq_len < ORIG_RSEQ_SIZE ||\n\t    (rseq_len == ORIG_RSEQ_SIZE && !IS_ALIGNED((unsigned long)rseq, ORIG_RSEQ_SIZE)) ||\n\t    (rseq_len != ORIG_RSEQ_SIZE && (!IS_ALIGNED((unsigned long)rseq, __alignof__(*rseq)) ||\n\t\t\t\t\t    rseq_len < offsetof(struct rseq, end))))\n\t\treturn -EINVAL;\n\tif (!access_ok(rseq, rseq_len))\n\t\treturn -EFAULT;\n\tcurrent->rseq = rseq;\n\tcurrent->rseq_len = rseq_len;\n\tcurrent->rseq_sig = sig;\n\t \n\trseq_set_notify_resume(current);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}