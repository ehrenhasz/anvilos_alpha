{
  "module_name": "freezer.c",
  "hash_id": "ac8933981c06352bc981e6b329895caae8dc21545cf271f3bebfcae997eadf79",
  "original_prompt": "Ingested from linux-6.6.14/kernel/freezer.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n\n \nDEFINE_STATIC_KEY_FALSE(freezer_active);\nEXPORT_SYMBOL(freezer_active);\n\n \nbool pm_freezing;\nbool pm_nosig_freezing;\n\n \nstatic DEFINE_SPINLOCK(freezer_lock);\n\n \nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(freezing_slow_path);\n\nbool frozen(struct task_struct *p)\n{\n\treturn READ_ONCE(p->__state) & TASK_FROZEN;\n}\n\n \nbool __refrigerator(bool check_kthr_stop)\n{\n\tunsigned int state = get_current_state();\n\tbool was_frozen = false;\n\n\tpr_debug(\"%s entered refrigerator\\n\", current->comm);\n\n\tWARN_ON_ONCE(state && !(state & TASK_NORMAL));\n\n\tfor (;;) {\n\t\tbool freeze;\n\n\t\tset_current_state(TASK_FROZEN);\n\n\t\tspin_lock_irq(&freezer_lock);\n\t\tfreeze = freezing(current) && !(check_kthr_stop && kthread_should_stop());\n\t\tspin_unlock_irq(&freezer_lock);\n\n\t\tif (!freeze)\n\t\t\tbreak;\n\n\t\twas_frozen = true;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tpr_debug(\"%s left refrigerator\\n\", current->comm);\n\n\treturn was_frozen;\n}\nEXPORT_SYMBOL(__refrigerator);\n\nstatic void fake_signal_wake_up(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tsignal_wake_up(p, 0);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n}\n\nstatic int __set_task_frozen(struct task_struct *p, void *arg)\n{\n\tunsigned int state = READ_ONCE(p->__state);\n\n\tif (p->on_rq)\n\t\treturn 0;\n\n\tif (p != current && task_curr(p))\n\t\treturn 0;\n\n\tif (!(state & (TASK_FREEZABLE | __TASK_STOPPED | __TASK_TRACED)))\n\t\treturn 0;\n\n\t \n\tif (state & TASK_FREEZABLE)\n\t\tWARN_ON_ONCE(!(state & TASK_NORMAL));\n\n#ifdef CONFIG_LOCKDEP\n\t \n\tif (!(state & __TASK_FREEZABLE_UNSAFE))\n\t\tWARN_ON_ONCE(debug_locks && p->lockdep_depth);\n#endif\n\n\tWRITE_ONCE(p->__state, TASK_FROZEN);\n\treturn TASK_FROZEN;\n}\n\nstatic bool __freeze_task(struct task_struct *p)\n{\n\t \n\treturn task_call_func(p, __set_task_frozen, NULL);\n}\n\n \nbool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p) || __freeze_task(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_NORMAL);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}\n\n \nstatic int __set_task_special(struct task_struct *p, void *arg)\n{\n\tunsigned int state = 0;\n\n\tif (p->jobctl & JOBCTL_TRACED)\n\t\tstate = TASK_TRACED;\n\n\telse if (p->jobctl & JOBCTL_STOPPED)\n\t\tstate = TASK_STOPPED;\n\n\tif (state)\n\t\tWRITE_ONCE(p->__state, state);\n\n\treturn state;\n}\n\nvoid __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags, flags2;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (WARN_ON_ONCE(freezing(p)))\n\t\tgoto unlock;\n\n\tif (lock_task_sighand(p, &flags2)) {\n\t\t \n\t\tbool ret = task_call_func(p, __set_task_special, NULL);\n\t\tunlock_task_sighand(p, &flags2);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\twake_up_state(p, TASK_FROZEN);\nunlock:\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}\n\n \nbool set_freezable(void)\n{\n\tmight_sleep();\n\n\t \n\tspin_lock_irq(&freezer_lock);\n\tcurrent->flags &= ~PF_NOFREEZE;\n\tspin_unlock_irq(&freezer_lock);\n\n\treturn try_to_freeze();\n}\nEXPORT_SYMBOL(set_freezable);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}