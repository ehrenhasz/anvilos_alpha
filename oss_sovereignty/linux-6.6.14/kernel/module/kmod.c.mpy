{
  "module_name": "kmod.c",
  "hash_id": "4cb2ebd4d91cd559ab428c62d2e9c3594a781a7619d2c7a4a8112b014b9fe404",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/kmod.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/binfmts.h>\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/cred.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/resource.h>\n#include <linux/notifier.h>\n#include <linux/suspend.h>\n#include <linux/rwsem.h>\n#include <linux/ptrace.h>\n#include <linux/async.h>\n#include <linux/uaccess.h>\n\n#include <trace/events/module.h>\n#include \"internal.h\"\n\n \n#define MAX_KMOD_CONCURRENT 50\nstatic DEFINE_SEMAPHORE(kmod_concurrent_max, MAX_KMOD_CONCURRENT);\n\n \n#define MAX_KMOD_ALL_BUSY_TIMEOUT 5\n\n \nchar modprobe_path[KMOD_PATH_LEN] = CONFIG_MODPROBE_PATH;\n\nstatic void free_modprobe_argv(struct subprocess_info *info)\n{\n\tkfree(info->argv[3]);  \n\tkfree(info->argv);\n}\n\nstatic int call_modprobe(char *orig_module_name, int wait)\n{\n\tstruct subprocess_info *info;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *module_name;\n\tint ret;\n\n\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\n\tif (!argv)\n\t\tgoto out;\n\n\tmodule_name = kstrdup(orig_module_name, GFP_KERNEL);\n\tif (!module_name)\n\t\tgoto free_argv;\n\n\targv[0] = modprobe_path;\n\targv[1] = \"-q\";\n\targv[2] = \"--\";\n\targv[3] = module_name;\t \n\targv[4] = NULL;\n\n\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t NULL, free_modprobe_argv, NULL);\n\tif (!info)\n\t\tgoto free_module_name;\n\n\tret = call_usermodehelper_exec(info, wait | UMH_KILLABLE);\n\tkmod_dup_request_announce(orig_module_name, ret);\n\treturn ret;\n\nfree_module_name:\n\tkfree(module_name);\nfree_argv:\n\tkfree(argv);\nout:\n\tkmod_dup_request_announce(orig_module_name, -ENOMEM);\n\treturn -ENOMEM;\n}\n\n \nint __request_module(bool wait, const char *fmt, ...)\n{\n\tva_list args;\n\tchar module_name[MODULE_NAME_LEN];\n\tint ret, dup_ret;\n\n\t \n\tWARN_ON_ONCE(wait && current_is_async());\n\n\tif (!modprobe_path[0])\n\t\treturn -ENOENT;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);\n\tva_end(args);\n\tif (ret >= MODULE_NAME_LEN)\n\t\treturn -ENAMETOOLONG;\n\n\tret = security_kernel_module_request(module_name);\n\tif (ret)\n\t\treturn ret;\n\n\tret = down_timeout(&kmod_concurrent_max, MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);\n\tif (ret) {\n\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",\n\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);\n\t\treturn ret;\n\t}\n\n\ttrace_module_request(module_name, wait, _RET_IP_);\n\n\tif (kmod_dup_request_exists_wait(module_name, wait, &dup_ret)) {\n\t\tret = dup_ret;\n\t\tgoto out;\n\t}\n\n\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);\n\nout:\n\tup(&kmod_concurrent_max);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__request_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}