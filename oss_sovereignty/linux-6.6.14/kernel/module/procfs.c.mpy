{
  "module_name": "procfs.c",
  "hash_id": "754dbb8260e264fdb445f1369a92b9b62b9fb53bde1f736d8f8d3121e83a4538",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/procfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kallsyms.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"internal.h\"\n\n#ifdef CONFIG_MODULE_UNLOAD\nstatic inline void print_unload_info(struct seq_file *m, struct module *mod)\n{\n\tstruct module_use *use;\n\tint printed_something = 0;\n\n\tseq_printf(m, \" %i \", module_refcount(mod));\n\n\t \n\tlist_for_each_entry(use, &mod->source_list, source_list) {\n\t\tprinted_something = 1;\n\t\tseq_printf(m, \"%s,\", use->source->name);\n\t}\n\n\tif (mod->init && !mod->exit) {\n\t\tprinted_something = 1;\n\t\tseq_puts(m, \"[permanent],\");\n\t}\n\n\tif (!printed_something)\n\t\tseq_puts(m, \"-\");\n}\n#else  \nstatic inline void print_unload_info(struct seq_file *m, struct module *mod)\n{\n\t \n\tseq_puts(m, \" - -\");\n}\n#endif  \n\n \nstatic void *m_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&module_mutex);\n\treturn seq_list_start(&modules, *pos);\n}\n\nstatic void *m_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next(p, &modules, pos);\n}\n\nstatic void m_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&module_mutex);\n}\n\nstatic unsigned int module_total_size(struct module *mod)\n{\n\tint size = 0;\n\n\tfor_each_mod_mem_type(type)\n\t\tsize += mod->mem[type].size;\n\treturn size;\n}\n\nstatic int m_show(struct seq_file *m, void *p)\n{\n\tstruct module *mod = list_entry(p, struct module, list);\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\tvoid *value;\n\tunsigned int size;\n\n\t \n\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\treturn 0;\n\n\tsize = module_total_size(mod);\n\tseq_printf(m, \"%s %u\", mod->name, size);\n\tprint_unload_info(m, mod);\n\n\t \n\tseq_printf(m, \" %s\",\n\t\t   mod->state == MODULE_STATE_GOING ? \"Unloading\" :\n\t\t   mod->state == MODULE_STATE_COMING ? \"Loading\" :\n\t\t   \"Live\");\n\t \n\tvalue = m->private ? NULL : mod->mem[MOD_TEXT].base;\n\tseq_printf(m, \" 0x%px\", value);\n\n\t \n\tif (mod->taints)\n\t\tseq_printf(m, \" %s\", module_flags(mod, buf, true));\n\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n\n \nstatic const struct seq_operations modules_op = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= m_show\n};\n\n \nstatic int modules_open(struct inode *inode, struct file *file)\n{\n\tint err = seq_open(file, &modules_op);\n\n\tif (!err) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tm->private = kallsyms_show_value(file->f_cred) ? NULL : (void *)8ul;\n\t}\n\n\treturn err;\n}\n\nstatic const struct proc_ops modules_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_open\t= modules_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release,\n};\n\nstatic int __init proc_modules_init(void)\n{\n\tproc_create(\"modules\", 0, NULL, &modules_proc_ops);\n\treturn 0;\n}\nmodule_init(proc_modules_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}