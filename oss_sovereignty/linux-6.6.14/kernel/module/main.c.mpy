{
  "module_name": "main.c",
  "hash_id": "24ff581d53ec75d1abd36fda40b2a727a2eadf666d441e5f5611483e6a91ed25",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/main.c",
  "human_readable_source": "\n \n\n#define INCLUDE_VERMAGIC\n\n#include <linux/export.h>\n#include <linux/extable.h>\n#include <linux/moduleloader.h>\n#include <linux/module_signature.h>\n#include <linux/trace_events.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n#include <linux/buildid.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kstrtox.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/seq_file.h>\n#include <linux/syscalls.h>\n#include <linux/fcntl.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/vermagic.h>\n#include <linux/notifier.h>\n#include <linux/sched.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <asm/cacheflush.h>\n#include <linux/set_memory.h>\n#include <asm/mmu_context.h>\n#include <linux/license.h>\n#include <asm/sections.h>\n#include <linux/tracepoint.h>\n#include <linux/ftrace.h>\n#include <linux/livepatch.h>\n#include <linux/async.h>\n#include <linux/percpu.h>\n#include <linux/kmemleak.h>\n#include <linux/jump_label.h>\n#include <linux/pfn.h>\n#include <linux/bsearch.h>\n#include <linux/dynamic_debug.h>\n#include <linux/audit.h>\n#include <linux/cfi.h>\n#include <linux/debugfs.h>\n#include <uapi/linux/module.h>\n#include \"internal.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/module.h>\n\n \nDEFINE_MUTEX(module_mutex);\nLIST_HEAD(modules);\n\n \nstatic void do_free_init(struct work_struct *w);\nstatic DECLARE_WORK(init_free_wq, do_free_init);\nstatic LLIST_HEAD(init_free_list);\n\nstruct mod_tree_root mod_tree __cacheline_aligned = {\n\t.addr_min = -1UL,\n};\n\nstruct symsearch {\n\tconst struct kernel_symbol *start, *stop;\n\tconst s32 *crcs;\n\tenum mod_license license;\n};\n\n \nstatic void __mod_update_bounds(enum mod_mem_type type __maybe_unused, void *base,\n\t\t\t\tunsigned int size, struct mod_tree_root *tree)\n{\n\tunsigned long min = (unsigned long)base;\n\tunsigned long max = min + size;\n\n#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC\n\tif (mod_mem_type_is_core_data(type)) {\n\t\tif (min < tree->data_addr_min)\n\t\t\ttree->data_addr_min = min;\n\t\tif (max > tree->data_addr_max)\n\t\t\ttree->data_addr_max = max;\n\t\treturn;\n\t}\n#endif\n\tif (min < tree->addr_min)\n\t\ttree->addr_min = min;\n\tif (max > tree->addr_max)\n\t\ttree->addr_max = max;\n}\n\nstatic void mod_update_bounds(struct module *mod)\n{\n\tfor_each_mod_mem_type(type) {\n\t\tstruct module_memory *mod_mem = &mod->mem[type];\n\n\t\tif (mod_mem->size)\n\t\t\t__mod_update_bounds(type, mod_mem->base, mod_mem->size, &mod_tree);\n\t}\n}\n\n \nint modules_disabled;\ncore_param(nomodule, modules_disabled, bint, 0);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(module_wq);\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint register_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&module_notify_list, nb);\n}\nEXPORT_SYMBOL(register_module_notifier);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}\nEXPORT_SYMBOL(unregister_module_notifier);\n\n \nstatic inline int strong_try_module_get(struct module *mod)\n{\n\tBUG_ON(mod && mod->state == MODULE_STATE_UNFORMED);\n\tif (mod && mod->state == MODULE_STATE_COMING)\n\t\treturn -EBUSY;\n\tif (try_module_get(mod))\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}\n\nstatic inline void add_taint_module(struct module *mod, unsigned flag,\n\t\t\t\t    enum lockdep_ok lockdep_ok)\n{\n\tadd_taint(flag, lockdep_ok);\n\tset_bit(flag, &mod->taints);\n}\n\n \nvoid __noreturn __module_put_and_kthread_exit(struct module *mod, long code)\n{\n\tmodule_put(mod);\n\tkthread_exit(code);\n}\nEXPORT_SYMBOL(__module_put_and_kthread_exit);\n\n \nstatic unsigned int find_sec(const struct load_info *info, const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < info->hdr->e_shnum; i++) {\n\t\tElf_Shdr *shdr = &info->sechdrs[i];\n\t\t \n\t\tif ((shdr->sh_flags & SHF_ALLOC)\n\t\t    && strcmp(info->secstrings + shdr->sh_name, name) == 0)\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\n \nstatic void *section_addr(const struct load_info *info, const char *name)\n{\n\t \n\treturn (void *)info->sechdrs[find_sec(info, name)].sh_addr;\n}\n\n \nstatic void *section_objs(const struct load_info *info,\n\t\t\t  const char *name,\n\t\t\t  size_t object_size,\n\t\t\t  unsigned int *num)\n{\n\tunsigned int sec = find_sec(info, name);\n\n\t \n\t*num = info->sechdrs[sec].sh_size / object_size;\n\treturn (void *)info->sechdrs[sec].sh_addr;\n}\n\n \nstatic unsigned int find_any_sec(const struct load_info *info, const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < info->hdr->e_shnum; i++) {\n\t\tElf_Shdr *shdr = &info->sechdrs[i];\n\t\tif (strcmp(info->secstrings + shdr->sh_name, name) == 0)\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\n \nstatic __maybe_unused void *any_section_objs(const struct load_info *info,\n\t\t\t\t\t     const char *name,\n\t\t\t\t\t     size_t object_size,\n\t\t\t\t\t     unsigned int *num)\n{\n\tunsigned int sec = find_any_sec(info, name);\n\n\t \n\t*num = info->sechdrs[sec].sh_size / object_size;\n\treturn (void *)info->sechdrs[sec].sh_addr;\n}\n\n#ifndef CONFIG_MODVERSIONS\n#define symversion(base, idx) NULL\n#else\n#define symversion(base, idx) ((base != NULL) ? ((base) + (idx)) : NULL)\n#endif\n\nstatic const char *kernel_symbol_name(const struct kernel_symbol *sym)\n{\n#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS\n\treturn offset_to_ptr(&sym->name_offset);\n#else\n\treturn sym->name;\n#endif\n}\n\nstatic const char *kernel_symbol_namespace(const struct kernel_symbol *sym)\n{\n#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS\n\tif (!sym->namespace_offset)\n\t\treturn NULL;\n\treturn offset_to_ptr(&sym->namespace_offset);\n#else\n\treturn sym->namespace;\n#endif\n}\n\nint cmp_name(const void *name, const void *sym)\n{\n\treturn strcmp(name, kernel_symbol_name(sym));\n}\n\nstatic bool find_exported_symbol_in_section(const struct symsearch *syms,\n\t\t\t\t\t    struct module *owner,\n\t\t\t\t\t    struct find_symbol_arg *fsa)\n{\n\tstruct kernel_symbol *sym;\n\n\tif (!fsa->gplok && syms->license == GPL_ONLY)\n\t\treturn false;\n\n\tsym = bsearch(fsa->name, syms->start, syms->stop - syms->start,\n\t\t\tsizeof(struct kernel_symbol), cmp_name);\n\tif (!sym)\n\t\treturn false;\n\n\tfsa->owner = owner;\n\tfsa->crc = symversion(syms->crcs, sym - syms->start);\n\tfsa->sym = sym;\n\tfsa->license = syms->license;\n\n\treturn true;\n}\n\n \nbool find_symbol(struct find_symbol_arg *fsa)\n{\n\tstatic const struct symsearch arr[] = {\n\t\t{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,\n\t\t  NOT_GPL_ONLY },\n\t\t{ __start___ksymtab_gpl, __stop___ksymtab_gpl,\n\t\t  __start___kcrctab_gpl,\n\t\t  GPL_ONLY },\n\t};\n\tstruct module *mod;\n\tunsigned int i;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tfor (i = 0; i < ARRAY_SIZE(arr); i++)\n\t\tif (find_exported_symbol_in_section(&arr[i], NULL, fsa))\n\t\t\treturn true;\n\n\tlist_for_each_entry_rcu(mod, &modules, list,\n\t\t\t\tlockdep_is_held(&module_mutex)) {\n\t\tstruct symsearch arr[] = {\n\t\t\t{ mod->syms, mod->syms + mod->num_syms, mod->crcs,\n\t\t\t  NOT_GPL_ONLY },\n\t\t\t{ mod->gpl_syms, mod->gpl_syms + mod->num_gpl_syms,\n\t\t\t  mod->gpl_crcs,\n\t\t\t  GPL_ONLY },\n\t\t};\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(arr); i++)\n\t\t\tif (find_exported_symbol_in_section(&arr[i], mod, fsa))\n\t\t\t\treturn true;\n\t}\n\n\tpr_debug(\"Failed to find symbol %s\\n\", fsa->name);\n\treturn false;\n}\n\n \nstruct module *find_module_all(const char *name, size_t len,\n\t\t\t       bool even_unformed)\n{\n\tstruct module *mod;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tlist_for_each_entry_rcu(mod, &modules, list,\n\t\t\t\tlockdep_is_held(&module_mutex)) {\n\t\tif (!even_unformed && mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (strlen(mod->name) == len && !memcmp(mod->name, name, len))\n\t\t\treturn mod;\n\t}\n\treturn NULL;\n}\n\nstruct module *find_module(const char *name)\n{\n\treturn find_module_all(name, strlen(name), false);\n}\n\n#ifdef CONFIG_SMP\n\nstatic inline void __percpu *mod_percpu(struct module *mod)\n{\n\treturn mod->percpu;\n}\n\nstatic int percpu_modalloc(struct module *mod, struct load_info *info)\n{\n\tElf_Shdr *pcpusec = &info->sechdrs[info->index.pcpu];\n\tunsigned long align = pcpusec->sh_addralign;\n\n\tif (!pcpusec->sh_size)\n\t\treturn 0;\n\n\tif (align > PAGE_SIZE) {\n\t\tpr_warn(\"%s: per-cpu alignment %li > %li\\n\",\n\t\t\tmod->name, align, PAGE_SIZE);\n\t\talign = PAGE_SIZE;\n\t}\n\n\tmod->percpu = __alloc_reserved_percpu(pcpusec->sh_size, align);\n\tif (!mod->percpu) {\n\t\tpr_warn(\"%s: Could not allocate %lu bytes percpu data\\n\",\n\t\t\tmod->name, (unsigned long)pcpusec->sh_size);\n\t\treturn -ENOMEM;\n\t}\n\tmod->percpu_size = pcpusec->sh_size;\n\treturn 0;\n}\n\nstatic void percpu_modfree(struct module *mod)\n{\n\tfree_percpu(mod->percpu);\n}\n\nstatic unsigned int find_pcpusec(struct load_info *info)\n{\n\treturn find_sec(info, \".data..percpu\");\n}\n\nstatic void percpu_modcopy(struct module *mod,\n\t\t\t   const void *from, unsigned long size)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tmemcpy(per_cpu_ptr(mod->percpu, cpu), from, size);\n}\n\nbool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\tstruct module *mod;\n\tunsigned int cpu;\n\n\tpreempt_disable();\n\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (!mod->percpu_size)\n\t\t\tcontinue;\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tvoid *start = per_cpu_ptr(mod->percpu, cpu);\n\t\t\tvoid *va = (void *)addr;\n\n\t\t\tif (va >= start && va < start + mod->percpu_size) {\n\t\t\t\tif (can_addr) {\n\t\t\t\t\t*can_addr = (unsigned long) (va - start);\n\t\t\t\t\t*can_addr += (unsigned long)\n\t\t\t\t\t\tper_cpu_ptr(mod->percpu,\n\t\t\t\t\t\t\t    get_boot_cpu_id());\n\t\t\t\t}\n\t\t\t\tpreempt_enable();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tpreempt_enable();\n\treturn false;\n}\n\n \nbool is_module_percpu_address(unsigned long addr)\n{\n\treturn __is_module_percpu_address(addr, NULL);\n}\n\n#else  \n\nstatic inline void __percpu *mod_percpu(struct module *mod)\n{\n\treturn NULL;\n}\nstatic int percpu_modalloc(struct module *mod, struct load_info *info)\n{\n\t \n\tif (info->sechdrs[info->index.pcpu].sh_size != 0)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nstatic inline void percpu_modfree(struct module *mod)\n{\n}\nstatic unsigned int find_pcpusec(struct load_info *info)\n{\n\treturn 0;\n}\nstatic inline void percpu_modcopy(struct module *mod,\n\t\t\t\t  const void *from, unsigned long size)\n{\n\t \n\tBUG_ON(size != 0);\n}\nbool is_module_percpu_address(unsigned long addr)\n{\n\treturn false;\n}\n\nbool __is_module_percpu_address(unsigned long addr, unsigned long *can_addr)\n{\n\treturn false;\n}\n\n#endif  \n\n#define MODINFO_ATTR(field)\t\\\nstatic void setup_modinfo_##field(struct module *mod, const char *s)  \\\n{                                                                     \\\n\tmod->field = kstrdup(s, GFP_KERNEL);                          \\\n}                                                                     \\\nstatic ssize_t show_modinfo_##field(struct module_attribute *mattr,   \\\n\t\t\tstruct module_kobject *mk, char *buffer)      \\\n{                                                                     \\\n\treturn scnprintf(buffer, PAGE_SIZE, \"%s\\n\", mk->mod->field);  \\\n}                                                                     \\\nstatic int modinfo_##field##_exists(struct module *mod)               \\\n{                                                                     \\\n\treturn mod->field != NULL;                                    \\\n}                                                                     \\\nstatic void free_modinfo_##field(struct module *mod)                  \\\n{                                                                     \\\n\tkfree(mod->field);                                            \\\n\tmod->field = NULL;                                            \\\n}                                                                     \\\nstatic struct module_attribute modinfo_##field = {                    \\\n\t.attr = { .name = __stringify(field), .mode = 0444 },         \\\n\t.show = show_modinfo_##field,                                 \\\n\t.setup = setup_modinfo_##field,                               \\\n\t.test = modinfo_##field##_exists,                             \\\n\t.free = free_modinfo_##field,                                 \\\n};\n\nMODINFO_ATTR(version);\nMODINFO_ATTR(srcversion);\n\nstatic struct {\n\tchar name[MODULE_NAME_LEN + 1];\n\tchar taints[MODULE_FLAGS_BUF_SIZE];\n} last_unloaded_module;\n\n#ifdef CONFIG_MODULE_UNLOAD\n\nEXPORT_TRACEPOINT_SYMBOL(module_get);\n\n \n#define MODULE_REF_BASE\t1\n\n \nstatic int module_unload_init(struct module *mod)\n{\n\t \n\tatomic_set(&mod->refcnt, MODULE_REF_BASE);\n\n\tINIT_LIST_HEAD(&mod->source_list);\n\tINIT_LIST_HEAD(&mod->target_list);\n\n\t \n\tatomic_inc(&mod->refcnt);\n\n\treturn 0;\n}\n\n \nstatic int already_uses(struct module *a, struct module *b)\n{\n\tstruct module_use *use;\n\n\tlist_for_each_entry(use, &b->source_list, source_list) {\n\t\tif (use->source == a)\n\t\t\treturn 1;\n\t}\n\tpr_debug(\"%s does not use %s!\\n\", a->name, b->name);\n\treturn 0;\n}\n\n \nstatic int add_module_usage(struct module *a, struct module *b)\n{\n\tstruct module_use *use;\n\n\tpr_debug(\"Allocating new usage for %s.\\n\", a->name);\n\tuse = kmalloc(sizeof(*use), GFP_ATOMIC);\n\tif (!use)\n\t\treturn -ENOMEM;\n\n\tuse->source = a;\n\tuse->target = b;\n\tlist_add(&use->source_list, &b->source_list);\n\tlist_add(&use->target_list, &a->target_list);\n\treturn 0;\n}\n\n \nstatic int ref_module(struct module *a, struct module *b)\n{\n\tint err;\n\n\tif (b == NULL || already_uses(a, b))\n\t\treturn 0;\n\n\t \n\terr = strong_try_module_get(b);\n\tif (err)\n\t\treturn err;\n\n\terr = add_module_usage(a, b);\n\tif (err) {\n\t\tmodule_put(b);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic void module_unload_free(struct module *mod)\n{\n\tstruct module_use *use, *tmp;\n\n\tmutex_lock(&module_mutex);\n\tlist_for_each_entry_safe(use, tmp, &mod->target_list, target_list) {\n\t\tstruct module *i = use->target;\n\t\tpr_debug(\"%s unusing %s\\n\", mod->name, i->name);\n\t\tmodule_put(i);\n\t\tlist_del(&use->source_list);\n\t\tlist_del(&use->target_list);\n\t\tkfree(use);\n\t}\n\tmutex_unlock(&module_mutex);\n}\n\n#ifdef CONFIG_MODULE_FORCE_UNLOAD\nstatic inline int try_force_unload(unsigned int flags)\n{\n\tint ret = (flags & O_TRUNC);\n\tif (ret)\n\t\tadd_taint(TAINT_FORCED_RMMOD, LOCKDEP_NOW_UNRELIABLE);\n\treturn ret;\n}\n#else\nstatic inline int try_force_unload(unsigned int flags)\n{\n\treturn 0;\n}\n#endif  \n\n \nstatic int try_release_module_ref(struct module *mod)\n{\n\tint ret;\n\n\t \n\tret = atomic_sub_return(MODULE_REF_BASE, &mod->refcnt);\n\tBUG_ON(ret < 0);\n\tif (ret)\n\t\t \n\t\tret = atomic_add_unless(&mod->refcnt, MODULE_REF_BASE, 0);\n\n\treturn ret;\n}\n\nstatic int try_stop_module(struct module *mod, int flags, int *forced)\n{\n\t \n\tif (try_release_module_ref(mod) != 0) {\n\t\t*forced = try_force_unload(flags);\n\t\tif (!(*forced))\n\t\t\treturn -EWOULDBLOCK;\n\t}\n\n\t \n\tmod->state = MODULE_STATE_GOING;\n\n\treturn 0;\n}\n\n \nint module_refcount(struct module *mod)\n{\n\treturn atomic_read(&mod->refcnt) - MODULE_REF_BASE;\n}\nEXPORT_SYMBOL(module_refcount);\n\n \nstatic void free_module(struct module *mod);\n\nSYSCALL_DEFINE2(delete_module, const char __user *, name_user,\n\t\tunsigned int, flags)\n{\n\tstruct module *mod;\n\tchar name[MODULE_NAME_LEN];\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\tint ret, forced = 0;\n\n\tif (!capable(CAP_SYS_MODULE) || modules_disabled)\n\t\treturn -EPERM;\n\n\tif (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)\n\t\treturn -EFAULT;\n\tname[MODULE_NAME_LEN-1] = '\\0';\n\n\taudit_log_kern_module(name);\n\n\tif (mutex_lock_interruptible(&module_mutex) != 0)\n\t\treturn -EINTR;\n\n\tmod = find_module(name);\n\tif (!mod) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&mod->source_list)) {\n\t\t \n\t\tret = -EWOULDBLOCK;\n\t\tgoto out;\n\t}\n\n\t \n\tif (mod->state != MODULE_STATE_LIVE) {\n\t\t \n\t\tpr_debug(\"%s already dying\\n\", mod->name);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (mod->init && !mod->exit) {\n\t\tforced = try_force_unload(flags);\n\t\tif (!forced) {\n\t\t\t \n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = try_stop_module(mod, flags, &forced);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tmutex_unlock(&module_mutex);\n\t \n\tif (mod->exit != NULL)\n\t\tmod->exit();\n\tblocking_notifier_call_chain(&module_notify_list,\n\t\t\t\t     MODULE_STATE_GOING, mod);\n\tklp_module_going(mod);\n\tftrace_release_mod(mod);\n\n\tasync_synchronize_full();\n\n\t \n\tstrscpy(last_unloaded_module.name, mod->name, sizeof(last_unloaded_module.name));\n\tstrscpy(last_unloaded_module.taints, module_flags(mod, buf, false), sizeof(last_unloaded_module.taints));\n\n\tfree_module(mod);\n\t \n\twake_up_all(&module_wq);\n\treturn 0;\nout:\n\tmutex_unlock(&module_mutex);\n\treturn ret;\n}\n\nvoid __symbol_put(const char *symbol)\n{\n\tstruct find_symbol_arg fsa = {\n\t\t.name\t= symbol,\n\t\t.gplok\t= true,\n\t};\n\n\tpreempt_disable();\n\tBUG_ON(!find_symbol(&fsa));\n\tmodule_put(fsa.owner);\n\tpreempt_enable();\n}\nEXPORT_SYMBOL(__symbol_put);\n\n \nvoid symbol_put_addr(void *addr)\n{\n\tstruct module *modaddr;\n\tunsigned long a = (unsigned long)dereference_function_descriptor(addr);\n\n\tif (core_kernel_text(a))\n\t\treturn;\n\n\t \n\tpreempt_disable();\n\tmodaddr = __module_text_address(a);\n\tBUG_ON(!modaddr);\n\tmodule_put(modaddr);\n\tpreempt_enable();\n}\nEXPORT_SYMBOL_GPL(symbol_put_addr);\n\nstatic ssize_t show_refcnt(struct module_attribute *mattr,\n\t\t\t   struct module_kobject *mk, char *buffer)\n{\n\treturn sprintf(buffer, \"%i\\n\", module_refcount(mk->mod));\n}\n\nstatic struct module_attribute modinfo_refcnt =\n\t__ATTR(refcnt, 0444, show_refcnt, NULL);\n\nvoid __module_get(struct module *module)\n{\n\tif (module) {\n\t\tatomic_inc(&module->refcnt);\n\t\ttrace_module_get(module, _RET_IP_);\n\t}\n}\nEXPORT_SYMBOL(__module_get);\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\t \n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(try_module_get);\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t \n\t\ttrace_module_put(module, _RET_IP_);\n\t}\n}\nEXPORT_SYMBOL(module_put);\n\n#else  \nstatic inline void module_unload_free(struct module *mod)\n{\n}\n\nstatic int ref_module(struct module *a, struct module *b)\n{\n\treturn strong_try_module_get(b);\n}\n\nstatic inline int module_unload_init(struct module *mod)\n{\n\treturn 0;\n}\n#endif  \n\nsize_t module_flags_taint(unsigned long taints, char *buf)\n{\n\tsize_t l = 0;\n\tint i;\n\n\tfor (i = 0; i < TAINT_FLAGS_COUNT; i++) {\n\t\tif (taint_flags[i].module && test_bit(i, &taints))\n\t\t\tbuf[l++] = taint_flags[i].c_true;\n\t}\n\n\treturn l;\n}\n\nstatic ssize_t show_initstate(struct module_attribute *mattr,\n\t\t\t      struct module_kobject *mk, char *buffer)\n{\n\tconst char *state = \"unknown\";\n\n\tswitch (mk->mod->state) {\n\tcase MODULE_STATE_LIVE:\n\t\tstate = \"live\";\n\t\tbreak;\n\tcase MODULE_STATE_COMING:\n\t\tstate = \"coming\";\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tstate = \"going\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn sprintf(buffer, \"%s\\n\", state);\n}\n\nstatic struct module_attribute modinfo_initstate =\n\t__ATTR(initstate, 0444, show_initstate, NULL);\n\nstatic ssize_t store_uevent(struct module_attribute *mattr,\n\t\t\t    struct module_kobject *mk,\n\t\t\t    const char *buffer, size_t count)\n{\n\tint rc;\n\n\trc = kobject_synth_uevent(&mk->kobj, buffer, count);\n\treturn rc ? rc : count;\n}\n\nstruct module_attribute module_uevent =\n\t__ATTR(uevent, 0200, NULL, store_uevent);\n\nstatic ssize_t show_coresize(struct module_attribute *mattr,\n\t\t\t     struct module_kobject *mk, char *buffer)\n{\n\tunsigned int size = mk->mod->mem[MOD_TEXT].size;\n\n\tif (!IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC)) {\n\t\tfor_class_mod_mem_type(type, core_data)\n\t\t\tsize += mk->mod->mem[type].size;\n\t}\n\treturn sprintf(buffer, \"%u\\n\", size);\n}\n\nstatic struct module_attribute modinfo_coresize =\n\t__ATTR(coresize, 0444, show_coresize, NULL);\n\n#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC\nstatic ssize_t show_datasize(struct module_attribute *mattr,\n\t\t\t     struct module_kobject *mk, char *buffer)\n{\n\tunsigned int size = 0;\n\n\tfor_class_mod_mem_type(type, core_data)\n\t\tsize += mk->mod->mem[type].size;\n\treturn sprintf(buffer, \"%u\\n\", size);\n}\n\nstatic struct module_attribute modinfo_datasize =\n\t__ATTR(datasize, 0444, show_datasize, NULL);\n#endif\n\nstatic ssize_t show_initsize(struct module_attribute *mattr,\n\t\t\t     struct module_kobject *mk, char *buffer)\n{\n\tunsigned int size = 0;\n\n\tfor_class_mod_mem_type(type, init)\n\t\tsize += mk->mod->mem[type].size;\n\treturn sprintf(buffer, \"%u\\n\", size);\n}\n\nstatic struct module_attribute modinfo_initsize =\n\t__ATTR(initsize, 0444, show_initsize, NULL);\n\nstatic ssize_t show_taint(struct module_attribute *mattr,\n\t\t\t  struct module_kobject *mk, char *buffer)\n{\n\tsize_t l;\n\n\tl = module_flags_taint(mk->mod->taints, buffer);\n\tbuffer[l++] = '\\n';\n\treturn l;\n}\n\nstatic struct module_attribute modinfo_taint =\n\t__ATTR(taint, 0444, show_taint, NULL);\n\nstruct module_attribute *modinfo_attrs[] = {\n\t&module_uevent,\n\t&modinfo_version,\n\t&modinfo_srcversion,\n\t&modinfo_initstate,\n\t&modinfo_coresize,\n#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC\n\t&modinfo_datasize,\n#endif\n\t&modinfo_initsize,\n\t&modinfo_taint,\n#ifdef CONFIG_MODULE_UNLOAD\n\t&modinfo_refcnt,\n#endif\n\tNULL,\n};\n\nsize_t modinfo_attrs_count = ARRAY_SIZE(modinfo_attrs);\n\nstatic const char vermagic[] = VERMAGIC_STRING;\n\nint try_to_force_load(struct module *mod, const char *reason)\n{\n#ifdef CONFIG_MODULE_FORCE_LOAD\n\tif (!test_taint(TAINT_FORCED_MODULE))\n\t\tpr_warn(\"%s: %s: kernel tainted.\\n\", mod->name, reason);\n\tadd_taint_module(mod, TAINT_FORCED_MODULE, LOCKDEP_NOW_UNRELIABLE);\n\treturn 0;\n#else\n\treturn -ENOEXEC;\n#endif\n}\n\n \nchar *module_next_tag_pair(char *string, unsigned long *secsize)\n{\n\t \n\twhile (string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn NULL;\n\t}\n\n\t \n\twhile (!string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn NULL;\n\t}\n\treturn string;\n}\n\nstatic char *get_next_modinfo(const struct load_info *info, const char *tag,\n\t\t\t      char *prev)\n{\n\tchar *p;\n\tunsigned int taglen = strlen(tag);\n\tElf_Shdr *infosec = &info->sechdrs[info->index.info];\n\tunsigned long size = infosec->sh_size;\n\n\t \n\tchar *modinfo = (char *)info->hdr + infosec->sh_offset;\n\n\tif (prev) {\n\t\tsize -= prev - modinfo;\n\t\tmodinfo = module_next_tag_pair(prev, &size);\n\t}\n\n\tfor (p = modinfo; p; p = module_next_tag_pair(p, &size)) {\n\t\tif (strncmp(p, tag, taglen) == 0 && p[taglen] == '=')\n\t\t\treturn p + taglen + 1;\n\t}\n\treturn NULL;\n}\n\nstatic char *get_modinfo(const struct load_info *info, const char *tag)\n{\n\treturn get_next_modinfo(info, tag, NULL);\n}\n\nstatic int verify_namespace_is_imported(const struct load_info *info,\n\t\t\t\t\tconst struct kernel_symbol *sym,\n\t\t\t\t\tstruct module *mod)\n{\n\tconst char *namespace;\n\tchar *imported_namespace;\n\n\tnamespace = kernel_symbol_namespace(sym);\n\tif (namespace && namespace[0]) {\n\t\tfor_each_modinfo_entry(imported_namespace, info, \"import_ns\") {\n\t\t\tif (strcmp(namespace, imported_namespace) == 0)\n\t\t\t\treturn 0;\n\t\t}\n#ifdef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS\n\t\tpr_warn(\n#else\n\t\tpr_err(\n#endif\n\t\t\t\"%s: module uses symbol (%s) from namespace %s, but does not import it.\\n\",\n\t\t\tmod->name, kernel_symbol_name(sym), namespace);\n#ifndef CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic bool inherit_taint(struct module *mod, struct module *owner, const char *name)\n{\n\tif (!owner || !test_bit(TAINT_PROPRIETARY_MODULE, &owner->taints))\n\t\treturn true;\n\n\tif (mod->using_gplonly_symbols) {\n\t\tpr_err(\"%s: module using GPL-only symbols uses symbols %s from proprietary module %s.\\n\",\n\t\t\tmod->name, name, owner->name);\n\t\treturn false;\n\t}\n\n\tif (!test_bit(TAINT_PROPRIETARY_MODULE, &mod->taints)) {\n\t\tpr_warn(\"%s: module uses symbols %s from proprietary module %s, inheriting taint.\\n\",\n\t\t\tmod->name, name, owner->name);\n\t\tset_bit(TAINT_PROPRIETARY_MODULE, &mod->taints);\n\t}\n\treturn true;\n}\n\n \nstatic const struct kernel_symbol *resolve_symbol(struct module *mod,\n\t\t\t\t\t\t  const struct load_info *info,\n\t\t\t\t\t\t  const char *name,\n\t\t\t\t\t\t  char ownername[])\n{\n\tstruct find_symbol_arg fsa = {\n\t\t.name\t= name,\n\t\t.gplok\t= !(mod->taints & (1 << TAINT_PROPRIETARY_MODULE)),\n\t\t.warn\t= true,\n\t};\n\tint err;\n\n\t \n\tsched_annotate_sleep();\n\tmutex_lock(&module_mutex);\n\tif (!find_symbol(&fsa))\n\t\tgoto unlock;\n\n\tif (fsa.license == GPL_ONLY)\n\t\tmod->using_gplonly_symbols = true;\n\n\tif (!inherit_taint(mod, fsa.owner, name)) {\n\t\tfsa.sym = NULL;\n\t\tgoto getname;\n\t}\n\n\tif (!check_version(info, name, mod, fsa.crc)) {\n\t\tfsa.sym = ERR_PTR(-EINVAL);\n\t\tgoto getname;\n\t}\n\n\terr = verify_namespace_is_imported(info, fsa.sym, mod);\n\tif (err) {\n\t\tfsa.sym = ERR_PTR(err);\n\t\tgoto getname;\n\t}\n\n\terr = ref_module(mod, fsa.owner);\n\tif (err) {\n\t\tfsa.sym = ERR_PTR(err);\n\t\tgoto getname;\n\t}\n\ngetname:\n\t \n\tstrncpy(ownername, module_name(fsa.owner), MODULE_NAME_LEN);\nunlock:\n\tmutex_unlock(&module_mutex);\n\treturn fsa.sym;\n}\n\nstatic const struct kernel_symbol *\nresolve_symbol_wait(struct module *mod,\n\t\t    const struct load_info *info,\n\t\t    const char *name)\n{\n\tconst struct kernel_symbol *ksym;\n\tchar owner[MODULE_NAME_LEN];\n\n\tif (wait_event_interruptible_timeout(module_wq,\n\t\t\t!IS_ERR(ksym = resolve_symbol(mod, info, name, owner))\n\t\t\t|| PTR_ERR(ksym) != -EBUSY,\n\t\t\t\t\t     30 * HZ) <= 0) {\n\t\tpr_warn(\"%s: gave up waiting for init of module %s.\\n\",\n\t\t\tmod->name, owner);\n\t}\n\treturn ksym;\n}\n\nvoid __weak module_memfree(void *module_region)\n{\n\t \n\tWARN_ON(in_interrupt());\n\tvfree(module_region);\n}\n\nvoid __weak module_arch_cleanup(struct module *mod)\n{\n}\n\nvoid __weak module_arch_freeing_init(struct module *mod)\n{\n}\n\nstatic bool mod_mem_use_vmalloc(enum mod_mem_type type)\n{\n\treturn IS_ENABLED(CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC) &&\n\t\tmod_mem_type_is_core_data(type);\n}\n\nstatic void *module_memory_alloc(unsigned int size, enum mod_mem_type type)\n{\n\tif (mod_mem_use_vmalloc(type))\n\t\treturn vzalloc(size);\n\treturn module_alloc(size);\n}\n\nstatic void module_memory_free(void *ptr, enum mod_mem_type type)\n{\n\tif (mod_mem_use_vmalloc(type))\n\t\tvfree(ptr);\n\telse\n\t\tmodule_memfree(ptr);\n}\n\nstatic void free_mod_mem(struct module *mod)\n{\n\tfor_each_mod_mem_type(type) {\n\t\tstruct module_memory *mod_mem = &mod->mem[type];\n\n\t\tif (type == MOD_DATA)\n\t\t\tcontinue;\n\n\t\t \n\t\tlockdep_free_key_range(mod_mem->base, mod_mem->size);\n\t\tif (mod_mem->size)\n\t\t\tmodule_memory_free(mod_mem->base, type);\n\t}\n\n\t \n\tlockdep_free_key_range(mod->mem[MOD_DATA].base, mod->mem[MOD_DATA].size);\n\tmodule_memory_free(mod->mem[MOD_DATA].base, MOD_DATA);\n}\n\n \nstatic void free_module(struct module *mod)\n{\n\ttrace_module_free(mod);\n\n\tmod_sysfs_teardown(mod);\n\n\t \n\tmutex_lock(&module_mutex);\n\tmod->state = MODULE_STATE_UNFORMED;\n\tmutex_unlock(&module_mutex);\n\n\t \n\tmodule_arch_cleanup(mod);\n\n\t \n\tmodule_unload_free(mod);\n\n\t \n\tdestroy_params(mod->kp, mod->num_kp);\n\n\tif (is_livepatch_module(mod))\n\t\tfree_module_elf(mod);\n\n\t \n\tmutex_lock(&module_mutex);\n\t \n\tlist_del_rcu(&mod->list);\n\tmod_tree_remove(mod);\n\t \n\tmodule_bug_cleanup(mod);\n\t \n\tsynchronize_rcu();\n\tif (try_add_tainted_module(mod))\n\t\tpr_err(\"%s: adding tainted module to the unloaded tainted modules list failed.\\n\",\n\t\t       mod->name);\n\tmutex_unlock(&module_mutex);\n\n\t \n\tmodule_arch_freeing_init(mod);\n\tkfree(mod->args);\n\tpercpu_modfree(mod);\n\n\tfree_mod_mem(mod);\n}\n\nvoid *__symbol_get(const char *symbol)\n{\n\tstruct find_symbol_arg fsa = {\n\t\t.name\t= symbol,\n\t\t.gplok\t= true,\n\t\t.warn\t= true,\n\t};\n\n\tpreempt_disable();\n\tif (!find_symbol(&fsa))\n\t\tgoto fail;\n\tif (fsa.license != GPL_ONLY) {\n\t\tpr_warn(\"failing symbol_get of non-GPLONLY symbol %s.\\n\",\n\t\t\tsymbol);\n\t\tgoto fail;\n\t}\n\tif (strong_try_module_get(fsa.owner))\n\t\tgoto fail;\n\tpreempt_enable();\n\treturn (void *)kernel_symbol_value(fsa.sym);\nfail:\n\tpreempt_enable();\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__symbol_get);\n\n \nstatic int verify_exported_symbols(struct module *mod)\n{\n\tunsigned int i;\n\tconst struct kernel_symbol *s;\n\tstruct {\n\t\tconst struct kernel_symbol *sym;\n\t\tunsigned int num;\n\t} arr[] = {\n\t\t{ mod->syms, mod->num_syms },\n\t\t{ mod->gpl_syms, mod->num_gpl_syms },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(arr); i++) {\n\t\tfor (s = arr[i].sym; s < arr[i].sym + arr[i].num; s++) {\n\t\t\tstruct find_symbol_arg fsa = {\n\t\t\t\t.name\t= kernel_symbol_name(s),\n\t\t\t\t.gplok\t= true,\n\t\t\t};\n\t\t\tif (find_symbol(&fsa)) {\n\t\t\t\tpr_err(\"%s: exports duplicate symbol %s\"\n\t\t\t\t       \" (owned by %s)\\n\",\n\t\t\t\t       mod->name, kernel_symbol_name(s),\n\t\t\t\t       module_name(fsa.owner));\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool ignore_undef_symbol(Elf_Half emachine, const char *name)\n{\n\t \n\tif (emachine == EM_386 || emachine == EM_X86_64)\n\t\treturn !strcmp(name, \"_GLOBAL_OFFSET_TABLE_\");\n\treturn false;\n}\n\n \nstatic int simplify_symbols(struct module *mod, const struct load_info *info)\n{\n\tElf_Shdr *symsec = &info->sechdrs[info->index.sym];\n\tElf_Sym *sym = (void *)symsec->sh_addr;\n\tunsigned long secbase;\n\tunsigned int i;\n\tint ret = 0;\n\tconst struct kernel_symbol *ksym;\n\n\tfor (i = 1; i < symsec->sh_size / sizeof(Elf_Sym); i++) {\n\t\tconst char *name = info->strtab + sym[i].st_name;\n\n\t\tswitch (sym[i].st_shndx) {\n\t\tcase SHN_COMMON:\n\t\t\t \n\t\t\tif (!strncmp(name, \"__gnu_lto\", 9))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tpr_debug(\"Common symbol: %s\\n\", name);\n\t\t\tpr_warn(\"%s: please compile with -fno-common\\n\",\n\t\t\t       mod->name);\n\t\t\tret = -ENOEXEC;\n\t\t\tbreak;\n\n\t\tcase SHN_ABS:\n\t\t\t \n\t\t\tpr_debug(\"Absolute symbol: 0x%08lx %s\\n\",\n\t\t\t\t (long)sym[i].st_value, name);\n\t\t\tbreak;\n\n\t\tcase SHN_LIVEPATCH:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SHN_UNDEF:\n\t\t\tksym = resolve_symbol_wait(mod, info, name);\n\t\t\t \n\t\t\tif (ksym && !IS_ERR(ksym)) {\n\t\t\t\tsym[i].st_value = kernel_symbol_value(ksym);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!ksym &&\n\t\t\t    (ELF_ST_BIND(sym[i].st_info) == STB_WEAK ||\n\t\t\t     ignore_undef_symbol(info->hdr->e_machine, name)))\n\t\t\t\tbreak;\n\n\t\t\tret = PTR_ERR(ksym) ?: -ENOENT;\n\t\t\tpr_warn(\"%s: Unknown symbol %s (err %d)\\n\",\n\t\t\t\tmod->name, name, ret);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (sym[i].st_shndx == info->index.pcpu)\n\t\t\t\tsecbase = (unsigned long)mod_percpu(mod);\n\t\t\telse\n\t\t\t\tsecbase = info->sechdrs[sym[i].st_shndx].sh_addr;\n\t\t\tsym[i].st_value += secbase;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int apply_relocations(struct module *mod, const struct load_info *info)\n{\n\tunsigned int i;\n\tint err = 0;\n\n\t \n\tfor (i = 1; i < info->hdr->e_shnum; i++) {\n\t\tunsigned int infosec = info->sechdrs[i].sh_info;\n\n\t\t \n\t\tif (infosec >= info->hdr->e_shnum)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(info->sechdrs[infosec].sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\tif (info->sechdrs[i].sh_flags & SHF_RELA_LIVEPATCH)\n\t\t\terr = klp_apply_section_relocs(mod, info->sechdrs,\n\t\t\t\t\t\t       info->secstrings,\n\t\t\t\t\t\t       info->strtab,\n\t\t\t\t\t\t       info->index.sym, i,\n\t\t\t\t\t\t       NULL);\n\t\telse if (info->sechdrs[i].sh_type == SHT_REL)\n\t\t\terr = apply_relocate(info->sechdrs, info->strtab,\n\t\t\t\t\t     info->index.sym, i, mod);\n\t\telse if (info->sechdrs[i].sh_type == SHT_RELA)\n\t\t\terr = apply_relocate_add(info->sechdrs, info->strtab,\n\t\t\t\t\t\t info->index.sym, i, mod);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nunsigned int __weak arch_mod_section_prepend(struct module *mod,\n\t\t\t\t\t     unsigned int section)\n{\n\t \n\treturn 0;\n}\n\nlong module_get_offset_and_type(struct module *mod, enum mod_mem_type type,\n\t\t\t\tElf_Shdr *sechdr, unsigned int section)\n{\n\tlong offset;\n\tlong mask = ((unsigned long)(type) & SH_ENTSIZE_TYPE_MASK) << SH_ENTSIZE_TYPE_SHIFT;\n\n\tmod->mem[type].size += arch_mod_section_prepend(mod, section);\n\toffset = ALIGN(mod->mem[type].size, sechdr->sh_addralign ?: 1);\n\tmod->mem[type].size = offset + sechdr->sh_size;\n\n\tWARN_ON_ONCE(offset & mask);\n\treturn offset | mask;\n}\n\nbool module_init_layout_section(const char *sname)\n{\n#ifndef CONFIG_MODULE_UNLOAD\n\tif (module_exit_section(sname))\n\t\treturn true;\n#endif\n\treturn module_init_section(sname);\n}\n\nstatic void __layout_sections(struct module *mod, struct load_info *info, bool is_init)\n{\n\tunsigned int m, i;\n\n\tstatic const unsigned long masks[][2] = {\n\t\t \n\t\t{ SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL },\n\t\t{ SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL },\n\t\t{ SHF_RO_AFTER_INIT | SHF_ALLOC, ARCH_SHF_SMALL },\n\t\t{ SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL },\n\t\t{ ARCH_SHF_SMALL | SHF_ALLOC, 0 }\n\t};\n\tstatic const int core_m_to_mem_type[] = {\n\t\tMOD_TEXT,\n\t\tMOD_RODATA,\n\t\tMOD_RO_AFTER_INIT,\n\t\tMOD_DATA,\n\t\tMOD_DATA,\n\t};\n\tstatic const int init_m_to_mem_type[] = {\n\t\tMOD_INIT_TEXT,\n\t\tMOD_INIT_RODATA,\n\t\tMOD_INVALID,\n\t\tMOD_INIT_DATA,\n\t\tMOD_INIT_DATA,\n\t};\n\n\tfor (m = 0; m < ARRAY_SIZE(masks); ++m) {\n\t\tenum mod_mem_type type = is_init ? init_m_to_mem_type[m] : core_m_to_mem_type[m];\n\n\t\tfor (i = 0; i < info->hdr->e_shnum; ++i) {\n\t\t\tElf_Shdr *s = &info->sechdrs[i];\n\t\t\tconst char *sname = info->secstrings + s->sh_name;\n\n\t\t\tif ((s->sh_flags & masks[m][0]) != masks[m][0]\n\t\t\t    || (s->sh_flags & masks[m][1])\n\t\t\t    || s->sh_entsize != ~0UL\n\t\t\t    || is_init != module_init_layout_section(sname))\n\t\t\t\tcontinue;\n\n\t\t\tif (WARN_ON_ONCE(type == MOD_INVALID))\n\t\t\t\tcontinue;\n\n\t\t\ts->sh_entsize = module_get_offset_and_type(mod, type, s, i);\n\t\t\tpr_debug(\"\\t%s\\n\", sname);\n\t\t}\n\t}\n}\n\n \nstatic void layout_sections(struct module *mod, struct load_info *info)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < info->hdr->e_shnum; i++)\n\t\tinfo->sechdrs[i].sh_entsize = ~0UL;\n\n\tpr_debug(\"Core section allocation order for %s:\\n\", mod->name);\n\t__layout_sections(mod, info, false);\n\n\tpr_debug(\"Init section allocation order for %s:\\n\", mod->name);\n\t__layout_sections(mod, info, true);\n}\n\nstatic void module_license_taint_check(struct module *mod, const char *license)\n{\n\tif (!license)\n\t\tlicense = \"unspecified\";\n\n\tif (!license_is_gpl_compatible(license)) {\n\t\tif (!test_taint(TAINT_PROPRIETARY_MODULE))\n\t\t\tpr_warn(\"%s: module license '%s' taints kernel.\\n\",\n\t\t\t\tmod->name, license);\n\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,\n\t\t\t\t LOCKDEP_NOW_UNRELIABLE);\n\t}\n}\n\nstatic void setup_modinfo(struct module *mod, struct load_info *info)\n{\n\tstruct module_attribute *attr;\n\tint i;\n\n\tfor (i = 0; (attr = modinfo_attrs[i]); i++) {\n\t\tif (attr->setup)\n\t\t\tattr->setup(mod, get_modinfo(info, attr->attr.name));\n\t}\n}\n\nstatic void free_modinfo(struct module *mod)\n{\n\tstruct module_attribute *attr;\n\tint i;\n\n\tfor (i = 0; (attr = modinfo_attrs[i]); i++) {\n\t\tif (attr->free)\n\t\t\tattr->free(mod);\n\t}\n}\n\nvoid * __weak module_alloc(unsigned long size)\n{\n\treturn __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,\n\t\t\tGFP_KERNEL, PAGE_KERNEL_EXEC, VM_FLUSH_RESET_PERMS,\n\t\t\tNUMA_NO_NODE, __builtin_return_address(0));\n}\n\nbool __weak module_init_section(const char *name)\n{\n\treturn strstarts(name, \".init\");\n}\n\nbool __weak module_exit_section(const char *name)\n{\n\treturn strstarts(name, \".exit\");\n}\n\nstatic int validate_section_offset(struct load_info *info, Elf_Shdr *shdr)\n{\n#if defined(CONFIG_64BIT)\n\tunsigned long long secend;\n#else\n\tunsigned long secend;\n#endif\n\n\t \n\tsecend = shdr->sh_offset + shdr->sh_size;\n\tif (secend < shdr->sh_offset || secend > info->len)\n\t\treturn -ENOEXEC;\n\n\treturn 0;\n}\n\n \nstatic int elf_validity_cache_copy(struct load_info *info, int flags)\n{\n\tunsigned int i;\n\tElf_Shdr *shdr, *strhdr;\n\tint err;\n\tunsigned int num_mod_secs = 0, mod_idx;\n\tunsigned int num_info_secs = 0, info_idx;\n\tunsigned int num_sym_secs = 0, sym_idx;\n\n\tif (info->len < sizeof(*(info->hdr))) {\n\t\tpr_err(\"Invalid ELF header len %lu\\n\", info->len);\n\t\tgoto no_exec;\n\t}\n\n\tif (memcmp(info->hdr->e_ident, ELFMAG, SELFMAG) != 0) {\n\t\tpr_err(\"Invalid ELF header magic: != %s\\n\", ELFMAG);\n\t\tgoto no_exec;\n\t}\n\tif (info->hdr->e_type != ET_REL) {\n\t\tpr_err(\"Invalid ELF header type: %u != %u\\n\",\n\t\t       info->hdr->e_type, ET_REL);\n\t\tgoto no_exec;\n\t}\n\tif (!elf_check_arch(info->hdr)) {\n\t\tpr_err(\"Invalid architecture in ELF header: %u\\n\",\n\t\t       info->hdr->e_machine);\n\t\tgoto no_exec;\n\t}\n\tif (!module_elf_check_arch(info->hdr)) {\n\t\tpr_err(\"Invalid module architecture in ELF header: %u\\n\",\n\t\t       info->hdr->e_machine);\n\t\tgoto no_exec;\n\t}\n\tif (info->hdr->e_shentsize != sizeof(Elf_Shdr)) {\n\t\tpr_err(\"Invalid ELF section header size\\n\");\n\t\tgoto no_exec;\n\t}\n\n\t \n\tif (info->hdr->e_shoff >= info->len\n\t    || (info->hdr->e_shnum * sizeof(Elf_Shdr) >\n\t\tinfo->len - info->hdr->e_shoff)) {\n\t\tpr_err(\"Invalid ELF section header overflow\\n\");\n\t\tgoto no_exec;\n\t}\n\n\tinfo->sechdrs = (void *)info->hdr + info->hdr->e_shoff;\n\n\t \n\tif (info->hdr->e_shstrndx == SHN_UNDEF\n\t    || info->hdr->e_shstrndx >= info->hdr->e_shnum) {\n\t\tpr_err(\"Invalid ELF section name index: %d || e_shstrndx (%d) >= e_shnum (%d)\\n\",\n\t\t       info->hdr->e_shstrndx, info->hdr->e_shstrndx,\n\t\t       info->hdr->e_shnum);\n\t\tgoto no_exec;\n\t}\n\n\tstrhdr = &info->sechdrs[info->hdr->e_shstrndx];\n\terr = validate_section_offset(info, strhdr);\n\tif (err < 0) {\n\t\tpr_err(\"Invalid ELF section hdr(type %u)\\n\", strhdr->sh_type);\n\t\treturn err;\n\t}\n\n\t \n\tinfo->secstrings = (void *)info->hdr + strhdr->sh_offset;\n\tif (strhdr->sh_size == 0) {\n\t\tpr_err(\"empty section name table\\n\");\n\t\tgoto no_exec;\n\t}\n\tif (info->secstrings[strhdr->sh_size - 1] != '\\0') {\n\t\tpr_err(\"ELF Spec violation: section name table isn't null terminated\\n\");\n\t\tgoto no_exec;\n\t}\n\n\t \n\tif (info->sechdrs[0].sh_type != SHT_NULL\n\t    || info->sechdrs[0].sh_size != 0\n\t    || info->sechdrs[0].sh_addr != 0) {\n\t\tpr_err(\"ELF Spec violation: section 0 type(%d)!=SH_NULL or non-zero len or addr\\n\",\n\t\t       info->sechdrs[0].sh_type);\n\t\tgoto no_exec;\n\t}\n\n\tfor (i = 1; i < info->hdr->e_shnum; i++) {\n\t\tshdr = &info->sechdrs[i];\n\t\tswitch (shdr->sh_type) {\n\t\tcase SHT_NULL:\n\t\tcase SHT_NOBITS:\n\t\t\tcontinue;\n\t\tcase SHT_SYMTAB:\n\t\t\tif (shdr->sh_link == SHN_UNDEF\n\t\t\t    || shdr->sh_link >= info->hdr->e_shnum) {\n\t\t\t\tpr_err(\"Invalid ELF sh_link!=SHN_UNDEF(%d) or (sh_link(%d) >= hdr->e_shnum(%d)\\n\",\n\t\t\t\t       shdr->sh_link, shdr->sh_link,\n\t\t\t\t       info->hdr->e_shnum);\n\t\t\t\tgoto no_exec;\n\t\t\t}\n\t\t\tnum_sym_secs++;\n\t\t\tsym_idx = i;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\terr = validate_section_offset(info, shdr);\n\t\t\tif (err < 0) {\n\t\t\t\tpr_err(\"Invalid ELF section in module (section %u type %u)\\n\",\n\t\t\t\t\ti, shdr->sh_type);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (strcmp(info->secstrings + shdr->sh_name,\n\t\t\t\t   \".gnu.linkonce.this_module\") == 0) {\n\t\t\t\tnum_mod_secs++;\n\t\t\t\tmod_idx = i;\n\t\t\t} else if (strcmp(info->secstrings + shdr->sh_name,\n\t\t\t\t   \".modinfo\") == 0) {\n\t\t\t\tnum_info_secs++;\n\t\t\t\tinfo_idx = i;\n\t\t\t}\n\n\t\t\tif (shdr->sh_flags & SHF_ALLOC) {\n\t\t\t\tif (shdr->sh_name >= strhdr->sh_size) {\n\t\t\t\t\tpr_err(\"Invalid ELF section name in module (section %u type %u)\\n\",\n\t\t\t\t\t       i, shdr->sh_type);\n\t\t\t\t\treturn -ENOEXEC;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (num_info_secs > 1) {\n\t\tpr_err(\"Only one .modinfo section must exist.\\n\");\n\t\tgoto no_exec;\n\t} else if (num_info_secs == 1) {\n\t\t \n\t\tinfo->index.info = info_idx;\n\t\tinfo->name = get_modinfo(info, \"name\");\n\t}\n\n\tif (num_sym_secs != 1) {\n\t\tpr_warn(\"%s: module has no symbols (stripped?)\\n\",\n\t\t\tinfo->name ?: \"(missing .modinfo section or name field)\");\n\t\tgoto no_exec;\n\t}\n\n\t \n\tinfo->index.sym = sym_idx;\n\tshdr = &info->sechdrs[sym_idx];\n\tinfo->index.str = shdr->sh_link;\n\tinfo->strtab = (char *)info->hdr + info->sechdrs[info->index.str].sh_offset;\n\n\t \n\tif (num_mod_secs != 1) {\n\t\tpr_err(\"module %s: Only one .gnu.linkonce.this_module section must exist.\\n\",\n\t\t       info->name ?: \"(missing .modinfo section or name field)\");\n\t\tgoto no_exec;\n\t}\n\n\tshdr = &info->sechdrs[mod_idx];\n\n\t \n\tif (shdr->sh_type == SHT_NOBITS) {\n\t\tpr_err(\"module %s: .gnu.linkonce.this_module section must have a size set\\n\",\n\t\t       info->name ?: \"(missing .modinfo section or name field)\");\n\t\tgoto no_exec;\n\t}\n\n\tif (!(shdr->sh_flags & SHF_ALLOC)) {\n\t\tpr_err(\"module %s: .gnu.linkonce.this_module must occupy memory during process execution\\n\",\n\t\t       info->name ?: \"(missing .modinfo section or name field)\");\n\t\tgoto no_exec;\n\t}\n\n\tif (shdr->sh_size != sizeof(struct module)) {\n\t\tpr_err(\"module %s: .gnu.linkonce.this_module section size must match the kernel's built struct module size at run time\\n\",\n\t\t       info->name ?: \"(missing .modinfo section or name field)\");\n\t\tgoto no_exec;\n\t}\n\n\tinfo->index.mod = mod_idx;\n\n\t \n\tinfo->mod = (void *)info->hdr + shdr->sh_offset;\n\n\t \n\tif (!info->name)\n\t\tinfo->name = info->mod->name;\n\n\tif (flags & MODULE_INIT_IGNORE_MODVERSIONS)\n\t\tinfo->index.vers = 0;  \n\telse\n\t\tinfo->index.vers = find_sec(info, \"__versions\");\n\n\tinfo->index.pcpu = find_pcpusec(info);\n\n\treturn 0;\n\nno_exec:\n\treturn -ENOEXEC;\n}\n\n#define COPY_CHUNK_SIZE (16*PAGE_SIZE)\n\nstatic int copy_chunked_from_user(void *dst, const void __user *usrc, unsigned long len)\n{\n\tdo {\n\t\tunsigned long n = min(len, COPY_CHUNK_SIZE);\n\n\t\tif (copy_from_user(dst, usrc, n) != 0)\n\t\t\treturn -EFAULT;\n\t\tcond_resched();\n\t\tdst += n;\n\t\tusrc += n;\n\t\tlen -= n;\n\t} while (len);\n\treturn 0;\n}\n\nstatic int check_modinfo_livepatch(struct module *mod, struct load_info *info)\n{\n\tif (!get_modinfo(info, \"livepatch\"))\n\t\t \n\t\treturn 0;\n\n\tif (set_livepatch_module(mod))\n\t\treturn 0;\n\n\tpr_err(\"%s: module is marked as livepatch module, but livepatch support is disabled\",\n\t       mod->name);\n\treturn -ENOEXEC;\n}\n\nstatic void check_modinfo_retpoline(struct module *mod, struct load_info *info)\n{\n\tif (retpoline_module_ok(get_modinfo(info, \"retpoline\")))\n\t\treturn;\n\n\tpr_warn(\"%s: loading module not compiled with retpoline compiler.\\n\",\n\t\tmod->name);\n}\n\n \nstatic int copy_module_from_user(const void __user *umod, unsigned long len,\n\t\t\t\t  struct load_info *info)\n{\n\tint err;\n\n\tinfo->len = len;\n\tif (info->len < sizeof(*(info->hdr)))\n\t\treturn -ENOEXEC;\n\n\terr = security_kernel_load_data(LOADING_MODULE, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tinfo->hdr = __vmalloc(info->len, GFP_KERNEL | __GFP_NOWARN);\n\tif (!info->hdr)\n\t\treturn -ENOMEM;\n\n\tif (copy_chunked_from_user(info->hdr, umod, info->len) != 0) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = security_kernel_post_load_data((char *)info->hdr, info->len,\n\t\t\t\t\t     LOADING_MODULE, \"init_module\");\nout:\n\tif (err)\n\t\tvfree(info->hdr);\n\n\treturn err;\n}\n\nstatic void free_copy(struct load_info *info, int flags)\n{\n\tif (flags & MODULE_INIT_COMPRESSED_FILE)\n\t\tmodule_decompress_cleanup(info);\n\telse\n\t\tvfree(info->hdr);\n}\n\nstatic int rewrite_section_headers(struct load_info *info, int flags)\n{\n\tunsigned int i;\n\n\t \n\tinfo->sechdrs[0].sh_addr = 0;\n\n\tfor (i = 1; i < info->hdr->e_shnum; i++) {\n\t\tElf_Shdr *shdr = &info->sechdrs[i];\n\n\t\t \n\t\tshdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;\n\n\t}\n\n\t \n\tinfo->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;\n\tinfo->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;\n\n\treturn 0;\n}\n\n \nstatic void module_augment_kernel_taints(struct module *mod, struct load_info *info)\n{\n\tint prev_taint = test_taint(TAINT_PROPRIETARY_MODULE);\n\n\tif (!get_modinfo(info, \"intree\")) {\n\t\tif (!test_taint(TAINT_OOT_MODULE))\n\t\t\tpr_warn(\"%s: loading out-of-tree module taints kernel.\\n\",\n\t\t\t\tmod->name);\n\t\tadd_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);\n\t}\n\n\tcheck_modinfo_retpoline(mod, info);\n\n\tif (get_modinfo(info, \"staging\")) {\n\t\tadd_taint_module(mod, TAINT_CRAP, LOCKDEP_STILL_OK);\n\t\tpr_warn(\"%s: module is from the staging directory, the quality \"\n\t\t\t\"is unknown, you have been warned.\\n\", mod->name);\n\t}\n\n\tif (is_livepatch_module(mod)) {\n\t\tadd_taint_module(mod, TAINT_LIVEPATCH, LOCKDEP_STILL_OK);\n\t\tpr_notice_once(\"%s: tainting kernel with TAINT_LIVEPATCH\\n\",\n\t\t\t\tmod->name);\n\t}\n\n\tmodule_license_taint_check(mod, get_modinfo(info, \"license\"));\n\n\tif (get_modinfo(info, \"test\")) {\n\t\tif (!test_taint(TAINT_TEST))\n\t\t\tpr_warn(\"%s: loading test module taints kernel.\\n\",\n\t\t\t\tmod->name);\n\t\tadd_taint_module(mod, TAINT_TEST, LOCKDEP_STILL_OK);\n\t}\n#ifdef CONFIG_MODULE_SIG\n\tmod->sig_ok = info->sig_ok;\n\tif (!mod->sig_ok) {\n\t\tpr_notice_once(\"%s: module verification failed: signature \"\n\t\t\t       \"and/or required key missing - tainting \"\n\t\t\t       \"kernel\\n\", mod->name);\n\t\tadd_taint_module(mod, TAINT_UNSIGNED_MODULE, LOCKDEP_STILL_OK);\n\t}\n#endif\n\n\t \n\tif (strcmp(mod->name, \"ndiswrapper\") == 0)\n\t\tadd_taint(TAINT_PROPRIETARY_MODULE, LOCKDEP_NOW_UNRELIABLE);\n\n\t \n\tif (strcmp(mod->name, \"driverloader\") == 0)\n\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,\n\t\t\t\t LOCKDEP_NOW_UNRELIABLE);\n\n\t \n\tif (strcmp(mod->name, \"lve\") == 0)\n\t\tadd_taint_module(mod, TAINT_PROPRIETARY_MODULE,\n\t\t\t\t LOCKDEP_NOW_UNRELIABLE);\n\n\tif (!prev_taint && test_taint(TAINT_PROPRIETARY_MODULE))\n\t\tpr_warn(\"%s: module license taints kernel.\\n\", mod->name);\n\n}\n\nstatic int check_modinfo(struct module *mod, struct load_info *info, int flags)\n{\n\tconst char *modmagic = get_modinfo(info, \"vermagic\");\n\tint err;\n\n\tif (flags & MODULE_INIT_IGNORE_VERMAGIC)\n\t\tmodmagic = NULL;\n\n\t \n\tif (!modmagic) {\n\t\terr = try_to_force_load(mod, \"bad vermagic\");\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!same_magic(modmagic, vermagic, info->index.vers)) {\n\t\tpr_err(\"%s: version magic '%s' should be '%s'\\n\",\n\t\t       info->name, modmagic, vermagic);\n\t\treturn -ENOEXEC;\n\t}\n\n\terr = check_modinfo_livepatch(mod, info);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int find_module_sections(struct module *mod, struct load_info *info)\n{\n\tmod->kp = section_objs(info, \"__param\",\n\t\t\t       sizeof(*mod->kp), &mod->num_kp);\n\tmod->syms = section_objs(info, \"__ksymtab\",\n\t\t\t\t sizeof(*mod->syms), &mod->num_syms);\n\tmod->crcs = section_addr(info, \"__kcrctab\");\n\tmod->gpl_syms = section_objs(info, \"__ksymtab_gpl\",\n\t\t\t\t     sizeof(*mod->gpl_syms),\n\t\t\t\t     &mod->num_gpl_syms);\n\tmod->gpl_crcs = section_addr(info, \"__kcrctab_gpl\");\n\n#ifdef CONFIG_CONSTRUCTORS\n\tmod->ctors = section_objs(info, \".ctors\",\n\t\t\t\t  sizeof(*mod->ctors), &mod->num_ctors);\n\tif (!mod->ctors)\n\t\tmod->ctors = section_objs(info, \".init_array\",\n\t\t\t\tsizeof(*mod->ctors), &mod->num_ctors);\n\telse if (find_sec(info, \".init_array\")) {\n\t\t \n\t\tpr_warn(\"%s: has both .ctors and .init_array.\\n\",\n\t\t       mod->name);\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tmod->noinstr_text_start = section_objs(info, \".noinstr.text\", 1,\n\t\t\t\t\t\t&mod->noinstr_text_size);\n\n#ifdef CONFIG_TRACEPOINTS\n\tmod->tracepoints_ptrs = section_objs(info, \"__tracepoints_ptrs\",\n\t\t\t\t\t     sizeof(*mod->tracepoints_ptrs),\n\t\t\t\t\t     &mod->num_tracepoints);\n#endif\n#ifdef CONFIG_TREE_SRCU\n\tmod->srcu_struct_ptrs = section_objs(info, \"___srcu_struct_ptrs\",\n\t\t\t\t\t     sizeof(*mod->srcu_struct_ptrs),\n\t\t\t\t\t     &mod->num_srcu_structs);\n#endif\n#ifdef CONFIG_BPF_EVENTS\n\tmod->bpf_raw_events = section_objs(info, \"__bpf_raw_tp_map\",\n\t\t\t\t\t   sizeof(*mod->bpf_raw_events),\n\t\t\t\t\t   &mod->num_bpf_raw_events);\n#endif\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\n\tmod->btf_data = any_section_objs(info, \".BTF\", 1, &mod->btf_data_size);\n#endif\n#ifdef CONFIG_JUMP_LABEL\n\tmod->jump_entries = section_objs(info, \"__jump_table\",\n\t\t\t\t\tsizeof(*mod->jump_entries),\n\t\t\t\t\t&mod->num_jump_entries);\n#endif\n#ifdef CONFIG_EVENT_TRACING\n\tmod->trace_events = section_objs(info, \"_ftrace_events\",\n\t\t\t\t\t sizeof(*mod->trace_events),\n\t\t\t\t\t &mod->num_trace_events);\n\tmod->trace_evals = section_objs(info, \"_ftrace_eval_map\",\n\t\t\t\t\tsizeof(*mod->trace_evals),\n\t\t\t\t\t&mod->num_trace_evals);\n#endif\n#ifdef CONFIG_TRACING\n\tmod->trace_bprintk_fmt_start = section_objs(info, \"__trace_printk_fmt\",\n\t\t\t\t\t sizeof(*mod->trace_bprintk_fmt_start),\n\t\t\t\t\t &mod->num_trace_bprintk_fmt);\n#endif\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n\t \n\tmod->ftrace_callsites = section_objs(info, FTRACE_CALLSITE_SECTION,\n\t\t\t\t\t     sizeof(*mod->ftrace_callsites),\n\t\t\t\t\t     &mod->num_ftrace_callsites);\n#endif\n#ifdef CONFIG_FUNCTION_ERROR_INJECTION\n\tmod->ei_funcs = section_objs(info, \"_error_injection_whitelist\",\n\t\t\t\t\t    sizeof(*mod->ei_funcs),\n\t\t\t\t\t    &mod->num_ei_funcs);\n#endif\n#ifdef CONFIG_KPROBES\n\tmod->kprobes_text_start = section_objs(info, \".kprobes.text\", 1,\n\t\t\t\t\t\t&mod->kprobes_text_size);\n\tmod->kprobe_blacklist = section_objs(info, \"_kprobe_blacklist\",\n\t\t\t\t\t\tsizeof(unsigned long),\n\t\t\t\t\t\t&mod->num_kprobe_blacklist);\n#endif\n#ifdef CONFIG_PRINTK_INDEX\n\tmod->printk_index_start = section_objs(info, \".printk_index\",\n\t\t\t\t\t       sizeof(*mod->printk_index_start),\n\t\t\t\t\t       &mod->printk_index_size);\n#endif\n#ifdef CONFIG_HAVE_STATIC_CALL_INLINE\n\tmod->static_call_sites = section_objs(info, \".static_call_sites\",\n\t\t\t\t\t      sizeof(*mod->static_call_sites),\n\t\t\t\t\t      &mod->num_static_call_sites);\n#endif\n#if IS_ENABLED(CONFIG_KUNIT)\n\tmod->kunit_suites = section_objs(info, \".kunit_test_suites\",\n\t\t\t\t\t      sizeof(*mod->kunit_suites),\n\t\t\t\t\t      &mod->num_kunit_suites);\n#endif\n\n\tmod->extable = section_objs(info, \"__ex_table\",\n\t\t\t\t    sizeof(*mod->extable), &mod->num_exentries);\n\n\tif (section_addr(info, \"__obsparm\"))\n\t\tpr_warn(\"%s: Ignoring obsolete parameters\\n\", mod->name);\n\n#ifdef CONFIG_DYNAMIC_DEBUG_CORE\n\tmod->dyndbg_info.descs = section_objs(info, \"__dyndbg\",\n\t\t\t\t\t      sizeof(*mod->dyndbg_info.descs),\n\t\t\t\t\t      &mod->dyndbg_info.num_descs);\n\tmod->dyndbg_info.classes = section_objs(info, \"__dyndbg_classes\",\n\t\t\t\t\t\tsizeof(*mod->dyndbg_info.classes),\n\t\t\t\t\t\t&mod->dyndbg_info.num_classes);\n#endif\n\n\treturn 0;\n}\n\nstatic int move_module(struct module *mod, struct load_info *info)\n{\n\tint i;\n\tvoid *ptr;\n\tenum mod_mem_type t = 0;\n\tint ret = -ENOMEM;\n\n\tfor_each_mod_mem_type(type) {\n\t\tif (!mod->mem[type].size) {\n\t\t\tmod->mem[type].base = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tmod->mem[type].size = PAGE_ALIGN(mod->mem[type].size);\n\t\tptr = module_memory_alloc(mod->mem[type].size, type);\n\t\t \n\t\tkmemleak_not_leak(ptr);\n\t\tif (!ptr) {\n\t\t\tt = type;\n\t\t\tgoto out_enomem;\n\t\t}\n\t\tmemset(ptr, 0, mod->mem[type].size);\n\t\tmod->mem[type].base = ptr;\n\t}\n\n\t \n\tpr_debug(\"Final section addresses for %s:\\n\", mod->name);\n\tfor (i = 0; i < info->hdr->e_shnum; i++) {\n\t\tvoid *dest;\n\t\tElf_Shdr *shdr = &info->sechdrs[i];\n\t\tenum mod_mem_type type = shdr->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;\n\n\t\tif (!(shdr->sh_flags & SHF_ALLOC))\n\t\t\tcontinue;\n\n\t\tdest = mod->mem[type].base + (shdr->sh_entsize & SH_ENTSIZE_OFFSET_MASK);\n\n\t\tif (shdr->sh_type != SHT_NOBITS) {\n\t\t\t \n\t\t\tif (i == info->index.mod &&\n\t\t\t   (WARN_ON_ONCE(shdr->sh_size != sizeof(struct module)))) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto out_enomem;\n\t\t\t}\n\t\t\tmemcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);\n\t\t}\n\t\t \n\t\tshdr->sh_addr = (unsigned long)dest;\n\t\tpr_debug(\"\\t0x%lx 0x%.8lx %s\\n\", (long)shdr->sh_addr,\n\t\t\t (long)shdr->sh_size, info->secstrings + shdr->sh_name);\n\t}\n\n\treturn 0;\nout_enomem:\n\tfor (t--; t >= 0; t--)\n\t\tmodule_memory_free(mod->mem[t].base, t);\n\treturn ret;\n}\n\nstatic int check_export_symbol_versions(struct module *mod)\n{\n#ifdef CONFIG_MODVERSIONS\n\tif ((mod->num_syms && !mod->crcs) ||\n\t    (mod->num_gpl_syms && !mod->gpl_crcs)) {\n\t\treturn try_to_force_load(mod,\n\t\t\t\t\t \"no versions for exported symbols\");\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void flush_module_icache(const struct module *mod)\n{\n\t \n\tfor_each_mod_mem_type(type) {\n\t\tconst struct module_memory *mod_mem = &mod->mem[type];\n\n\t\tif (mod_mem->size) {\n\t\t\tflush_icache_range((unsigned long)mod_mem->base,\n\t\t\t\t\t   (unsigned long)mod_mem->base + mod_mem->size);\n\t\t}\n\t}\n}\n\nbool __weak module_elf_check_arch(Elf_Ehdr *hdr)\n{\n\treturn true;\n}\n\nint __weak module_frob_arch_sections(Elf_Ehdr *hdr,\n\t\t\t\t     Elf_Shdr *sechdrs,\n\t\t\t\t     char *secstrings,\n\t\t\t\t     struct module *mod)\n{\n\treturn 0;\n}\n\n \nstatic char *module_blacklist;\nstatic bool blacklisted(const char *module_name)\n{\n\tconst char *p;\n\tsize_t len;\n\n\tif (!module_blacklist)\n\t\treturn false;\n\n\tfor (p = module_blacklist; *p; p += len) {\n\t\tlen = strcspn(p, \",\");\n\t\tif (strlen(module_name) == len && !memcmp(module_name, p, len))\n\t\t\treturn true;\n\t\tif (p[len] == ',')\n\t\t\tlen++;\n\t}\n\treturn false;\n}\ncore_param(module_blacklist, module_blacklist, charp, 0400);\n\nstatic struct module *layout_and_allocate(struct load_info *info, int flags)\n{\n\tstruct module *mod;\n\tunsigned int ndx;\n\tint err;\n\n\t \n\terr = module_frob_arch_sections(info->hdr, info->sechdrs,\n\t\t\t\t\tinfo->secstrings, info->mod);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\terr = module_enforce_rwx_sections(info->hdr, info->sechdrs,\n\t\t\t\t\t  info->secstrings, info->mod);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\t \n\tinfo->sechdrs[info->index.pcpu].sh_flags &= ~(unsigned long)SHF_ALLOC;\n\n\t \n\tndx = find_sec(info, \".data..ro_after_init\");\n\tif (ndx)\n\t\tinfo->sechdrs[ndx].sh_flags |= SHF_RO_AFTER_INIT;\n\t \n\tndx = find_sec(info, \"__jump_table\");\n\tif (ndx)\n\t\tinfo->sechdrs[ndx].sh_flags |= SHF_RO_AFTER_INIT;\n\n\t \n\tlayout_sections(info->mod, info);\n\tlayout_symtab(info->mod, info);\n\n\t \n\terr = move_module(info->mod, info);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t \n\tmod = (void *)info->sechdrs[info->index.mod].sh_addr;\n\tkmemleak_load_module(mod, info);\n\treturn mod;\n}\n\n \nstatic void module_deallocate(struct module *mod, struct load_info *info)\n{\n\tpercpu_modfree(mod);\n\tmodule_arch_freeing_init(mod);\n\n\tfree_mod_mem(mod);\n}\n\nint __weak module_finalize(const Elf_Ehdr *hdr,\n\t\t\t   const Elf_Shdr *sechdrs,\n\t\t\t   struct module *me)\n{\n\treturn 0;\n}\n\nstatic int post_relocation(struct module *mod, const struct load_info *info)\n{\n\t \n\tsort_extable(mod->extable, mod->extable + mod->num_exentries);\n\n\t \n\tpercpu_modcopy(mod, (void *)info->sechdrs[info->index.pcpu].sh_addr,\n\t\t       info->sechdrs[info->index.pcpu].sh_size);\n\n\t \n\tadd_kallsyms(mod, info);\n\n\t \n\treturn module_finalize(info->hdr, info->sechdrs, mod);\n}\n\n \nstatic void do_mod_ctors(struct module *mod)\n{\n#ifdef CONFIG_CONSTRUCTORS\n\tunsigned long i;\n\n\tfor (i = 0; i < mod->num_ctors; i++)\n\t\tmod->ctors[i]();\n#endif\n}\n\n \nstruct mod_initfree {\n\tstruct llist_node node;\n\tvoid *init_text;\n\tvoid *init_data;\n\tvoid *init_rodata;\n};\n\nstatic void do_free_init(struct work_struct *w)\n{\n\tstruct llist_node *pos, *n, *list;\n\tstruct mod_initfree *initfree;\n\n\tlist = llist_del_all(&init_free_list);\n\n\tsynchronize_rcu();\n\n\tllist_for_each_safe(pos, n, list) {\n\t\tinitfree = container_of(pos, struct mod_initfree, node);\n\t\tmodule_memfree(initfree->init_text);\n\t\tmodule_memfree(initfree->init_data);\n\t\tmodule_memfree(initfree->init_rodata);\n\t\tkfree(initfree);\n\t}\n}\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"module.\"\n \nstatic bool async_probe;\nmodule_param(async_probe, bool, 0644);\n\n \nstatic noinline int do_init_module(struct module *mod)\n{\n\tint ret = 0;\n\tstruct mod_initfree *freeinit;\n#if defined(CONFIG_MODULE_STATS)\n\tunsigned int text_size = 0, total_size = 0;\n\n\tfor_each_mod_mem_type(type) {\n\t\tconst struct module_memory *mod_mem = &mod->mem[type];\n\t\tif (mod_mem->size) {\n\t\t\ttotal_size += mod_mem->size;\n\t\t\tif (type == MOD_TEXT || type == MOD_INIT_TEXT)\n\t\t\t\ttext_size += mod_mem->size;\n\t\t}\n\t}\n#endif\n\n\tfreeinit = kmalloc(sizeof(*freeinit), GFP_KERNEL);\n\tif (!freeinit) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tfreeinit->init_text = mod->mem[MOD_INIT_TEXT].base;\n\tfreeinit->init_data = mod->mem[MOD_INIT_DATA].base;\n\tfreeinit->init_rodata = mod->mem[MOD_INIT_RODATA].base;\n\n\tdo_mod_ctors(mod);\n\t \n\tif (mod->init != NULL)\n\t\tret = do_one_initcall(mod->init);\n\tif (ret < 0) {\n\t\tgoto fail_free_freeinit;\n\t}\n\tif (ret > 0) {\n\t\tpr_warn(\"%s: '%s'->init suspiciously returned %d, it should \"\n\t\t\t\"follow 0/-E convention\\n\"\n\t\t\t\"%s: loading module anyway...\\n\",\n\t\t\t__func__, mod->name, ret, __func__);\n\t\tdump_stack();\n\t}\n\n\t \n\tmod->state = MODULE_STATE_LIVE;\n\tblocking_notifier_call_chain(&module_notify_list,\n\t\t\t\t     MODULE_STATE_LIVE, mod);\n\n\t \n\tkobject_uevent(&mod->mkobj.kobj, KOBJ_ADD);\n\n\t \n\tif (!mod->async_probe_requested)\n\t\tasync_synchronize_full();\n\n\tftrace_free_mem(mod, mod->mem[MOD_INIT_TEXT].base,\n\t\t\tmod->mem[MOD_INIT_TEXT].base + mod->mem[MOD_INIT_TEXT].size);\n\tmutex_lock(&module_mutex);\n\t \n\tmodule_put(mod);\n\ttrim_init_extable(mod);\n#ifdef CONFIG_KALLSYMS\n\t \n\trcu_assign_pointer(mod->kallsyms, &mod->core_kallsyms);\n#endif\n\tmodule_enable_ro(mod, true);\n\tmod_tree_remove_init(mod);\n\tmodule_arch_freeing_init(mod);\n\tfor_class_mod_mem_type(type, init) {\n\t\tmod->mem[type].base = NULL;\n\t\tmod->mem[type].size = 0;\n\t}\n\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\n\t \n\tmod->btf_data = NULL;\n#endif\n\t \n\tif (llist_add(&freeinit->node, &init_free_list))\n\t\tschedule_work(&init_free_wq);\n\n\tmutex_unlock(&module_mutex);\n\twake_up_all(&module_wq);\n\n\tmod_stat_add_long(text_size, &total_text_size);\n\tmod_stat_add_long(total_size, &total_mod_size);\n\n\tmod_stat_inc(&modcount);\n\n\treturn 0;\n\nfail_free_freeinit:\n\tkfree(freeinit);\nfail:\n\t \n\tmod->state = MODULE_STATE_GOING;\n\tsynchronize_rcu();\n\tmodule_put(mod);\n\tblocking_notifier_call_chain(&module_notify_list,\n\t\t\t\t     MODULE_STATE_GOING, mod);\n\tklp_module_going(mod);\n\tftrace_release_mod(mod);\n\tfree_module(mod);\n\twake_up_all(&module_wq);\n\n\treturn ret;\n}\n\nstatic int may_init_module(void)\n{\n\tif (!capable(CAP_SYS_MODULE) || modules_disabled)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nstatic bool finished_loading(const char *name)\n{\n\tstruct module *mod;\n\tbool ret;\n\n\t \n\tsched_annotate_sleep();\n\tmutex_lock(&module_mutex);\n\tmod = find_module_all(name, strlen(name), true);\n\tret = !mod || mod->state == MODULE_STATE_LIVE\n\t\t|| mod->state == MODULE_STATE_GOING;\n\tmutex_unlock(&module_mutex);\n\n\treturn ret;\n}\n\n \nstatic int module_patient_check_exists(const char *name,\n\t\t\t\t       enum fail_dup_mod_reason reason)\n{\n\tstruct module *old;\n\tint err = 0;\n\n\told = find_module_all(name, strlen(name), true);\n\tif (old == NULL)\n\t\treturn 0;\n\n\tif (old->state == MODULE_STATE_COMING ||\n\t    old->state == MODULE_STATE_UNFORMED) {\n\t\t \n\t\tmutex_unlock(&module_mutex);\n\t\terr = wait_event_interruptible(module_wq,\n\t\t\t\t       finished_loading(name));\n\t\tmutex_lock(&module_mutex);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\told = find_module_all(name, strlen(name), true);\n\t}\n\n\tif (try_add_failed_module(name, reason))\n\t\tpr_warn(\"Could not add fail-tracking for module: %s\\n\", name);\n\n\t \n\tif (old && old->state == MODULE_STATE_LIVE)\n\t\treturn -EEXIST;\n\treturn -EBUSY;\n}\n\n \nstatic int add_unformed_module(struct module *mod)\n{\n\tint err;\n\n\tmod->state = MODULE_STATE_UNFORMED;\n\n\tmutex_lock(&module_mutex);\n\terr = module_patient_check_exists(mod->name, FAIL_DUP_MOD_LOAD);\n\tif (err)\n\t\tgoto out;\n\n\tmod_update_bounds(mod);\n\tlist_add_rcu(&mod->list, &modules);\n\tmod_tree_insert(mod);\n\terr = 0;\n\nout:\n\tmutex_unlock(&module_mutex);\n\treturn err;\n}\n\nstatic int complete_formation(struct module *mod, struct load_info *info)\n{\n\tint err;\n\n\tmutex_lock(&module_mutex);\n\n\t \n\terr = verify_exported_symbols(mod);\n\tif (err < 0)\n\t\tgoto out;\n\n\t \n\tmodule_bug_finalize(info->hdr, info->sechdrs, mod);\n\tmodule_cfi_finalize(info->hdr, info->sechdrs, mod);\n\n\tmodule_enable_ro(mod, false);\n\tmodule_enable_nx(mod);\n\tmodule_enable_x(mod);\n\n\t \n\tmod->state = MODULE_STATE_COMING;\n\tmutex_unlock(&module_mutex);\n\n\treturn 0;\n\nout:\n\tmutex_unlock(&module_mutex);\n\treturn err;\n}\n\nstatic int prepare_coming_module(struct module *mod)\n{\n\tint err;\n\n\tftrace_module_enable(mod);\n\terr = klp_module_coming(mod);\n\tif (err)\n\t\treturn err;\n\n\terr = blocking_notifier_call_chain_robust(&module_notify_list,\n\t\t\tMODULE_STATE_COMING, MODULE_STATE_GOING, mod);\n\terr = notifier_to_errno(err);\n\tif (err)\n\t\tklp_module_going(mod);\n\n\treturn err;\n}\n\nstatic int unknown_module_param_cb(char *param, char *val, const char *modname,\n\t\t\t\t   void *arg)\n{\n\tstruct module *mod = arg;\n\tint ret;\n\n\tif (strcmp(param, \"async_probe\") == 0) {\n\t\tif (kstrtobool(val, &mod->async_probe_requested))\n\t\t\tmod->async_probe_requested = true;\n\t\treturn 0;\n\t}\n\n\t \n\tret = ddebug_dyndbg_module_param_cb(param, val, modname);\n\tif (ret != 0)\n\t\tpr_warn(\"%s: unknown parameter '%s' ignored\\n\", modname, param);\n\treturn 0;\n}\n\n \nstatic int early_mod_check(struct load_info *info, int flags)\n{\n\tint err;\n\n\t \n\tif (blacklisted(info->name)) {\n\t\tpr_err(\"Module %s is blacklisted\\n\", info->name);\n\t\treturn -EPERM;\n\t}\n\n\terr = rewrite_section_headers(info, flags);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!check_modstruct_version(info, info->mod))\n\t\treturn -ENOEXEC;\n\n\terr = check_modinfo(info->mod, info, flags);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&module_mutex);\n\terr = module_patient_check_exists(info->mod->name, FAIL_DUP_MOD_BECOMING);\n\tmutex_unlock(&module_mutex);\n\n\treturn err;\n}\n\n \nstatic int load_module(struct load_info *info, const char __user *uargs,\n\t\t       int flags)\n{\n\tstruct module *mod;\n\tbool module_allocated = false;\n\tlong err = 0;\n\tchar *after_dashes;\n\n\t \n\terr = module_sig_check(info, flags);\n\tif (err)\n\t\tgoto free_copy;\n\n\t \n\terr = elf_validity_cache_copy(info, flags);\n\tif (err)\n\t\tgoto free_copy;\n\n\terr = early_mod_check(info, flags);\n\tif (err)\n\t\tgoto free_copy;\n\n\t \n\tmod = layout_and_allocate(info, flags);\n\tif (IS_ERR(mod)) {\n\t\terr = PTR_ERR(mod);\n\t\tgoto free_copy;\n\t}\n\n\tmodule_allocated = true;\n\n\taudit_log_kern_module(mod->name);\n\n\t \n\terr = add_unformed_module(mod);\n\tif (err)\n\t\tgoto free_module;\n\n\t \n\tmodule_augment_kernel_taints(mod, info);\n\n\t \n\terr = percpu_modalloc(mod, info);\n\tif (err)\n\t\tgoto unlink_mod;\n\n\t \n\terr = module_unload_init(mod);\n\tif (err)\n\t\tgoto unlink_mod;\n\n\tinit_param_lock(mod);\n\n\t \n\terr = find_module_sections(mod, info);\n\tif (err)\n\t\tgoto free_unload;\n\n\terr = check_export_symbol_versions(mod);\n\tif (err)\n\t\tgoto free_unload;\n\n\t \n\tsetup_modinfo(mod, info);\n\n\t \n\terr = simplify_symbols(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\terr = apply_relocations(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\terr = post_relocation(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\tflush_module_icache(mod);\n\n\t \n\tmod->args = strndup_user(uargs, ~0UL >> 1);\n\tif (IS_ERR(mod->args)) {\n\t\terr = PTR_ERR(mod->args);\n\t\tgoto free_arch_cleanup;\n\t}\n\n\tinit_build_id(mod, info);\n\n\t \n\tftrace_module_init(mod);\n\n\t \n\terr = complete_formation(mod, info);\n\tif (err)\n\t\tgoto ddebug_cleanup;\n\n\terr = prepare_coming_module(mod);\n\tif (err)\n\t\tgoto bug_cleanup;\n\n\tmod->async_probe_requested = async_probe;\n\n\t \n\tafter_dashes = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,\n\t\t\t\t  -32768, 32767, mod,\n\t\t\t\t  unknown_module_param_cb);\n\tif (IS_ERR(after_dashes)) {\n\t\terr = PTR_ERR(after_dashes);\n\t\tgoto coming_cleanup;\n\t} else if (after_dashes) {\n\t\tpr_warn(\"%s: parameters '%s' after `--' ignored\\n\",\n\t\t       mod->name, after_dashes);\n\t}\n\n\t \n\terr = mod_sysfs_setup(mod, info, mod->kp, mod->num_kp);\n\tif (err < 0)\n\t\tgoto coming_cleanup;\n\n\tif (is_livepatch_module(mod)) {\n\t\terr = copy_module_elf(mod, info);\n\t\tif (err < 0)\n\t\t\tgoto sysfs_cleanup;\n\t}\n\n\t \n\tfree_copy(info, flags);\n\n\t \n\ttrace_module_load(mod);\n\n\treturn do_init_module(mod);\n\n sysfs_cleanup:\n\tmod_sysfs_teardown(mod);\n coming_cleanup:\n\tmod->state = MODULE_STATE_GOING;\n\tdestroy_params(mod->kp, mod->num_kp);\n\tblocking_notifier_call_chain(&module_notify_list,\n\t\t\t\t     MODULE_STATE_GOING, mod);\n\tklp_module_going(mod);\n bug_cleanup:\n\tmod->state = MODULE_STATE_GOING;\n\t \n\tmutex_lock(&module_mutex);\n\tmodule_bug_cleanup(mod);\n\tmutex_unlock(&module_mutex);\n\n ddebug_cleanup:\n\tftrace_release_mod(mod);\n\tsynchronize_rcu();\n\tkfree(mod->args);\n free_arch_cleanup:\n\tmodule_arch_cleanup(mod);\n free_modinfo:\n\tfree_modinfo(mod);\n free_unload:\n\tmodule_unload_free(mod);\n unlink_mod:\n\tmutex_lock(&module_mutex);\n\t \n\tlist_del_rcu(&mod->list);\n\tmod_tree_remove(mod);\n\twake_up_all(&module_wq);\n\t \n\tsynchronize_rcu();\n\tmutex_unlock(&module_mutex);\n free_module:\n\tmod_stat_bump_invalid(info, flags);\n\t \n\tfor_class_mod_mem_type(type, core_data) {\n\t\tlockdep_free_key_range(mod->mem[type].base,\n\t\t\t\t       mod->mem[type].size);\n\t}\n\n\tmodule_deallocate(mod, info);\n free_copy:\n\t \n\tif (!module_allocated)\n\t\tmod_stat_bump_becoming(info, flags);\n\tfree_copy(info, flags);\n\treturn err;\n}\n\nSYSCALL_DEFINE3(init_module, void __user *, umod,\n\t\tunsigned long, len, const char __user *, uargs)\n{\n\tint err;\n\tstruct load_info info = { };\n\n\terr = may_init_module();\n\tif (err)\n\t\treturn err;\n\n\tpr_debug(\"init_module: umod=%p, len=%lu, uargs=%p\\n\",\n\t       umod, len, uargs);\n\n\terr = copy_module_from_user(umod, len, &info);\n\tif (err) {\n\t\tmod_stat_inc(&failed_kreads);\n\t\tmod_stat_add_long(len, &invalid_kread_bytes);\n\t\treturn err;\n\t}\n\n\treturn load_module(&info, uargs, 0);\n}\n\nstruct idempotent {\n\tconst void *cookie;\n\tstruct hlist_node entry;\n\tstruct completion complete;\n\tint ret;\n};\n\n#define IDEM_HASH_BITS 8\nstatic struct hlist_head idem_hash[1 << IDEM_HASH_BITS];\nstatic DEFINE_SPINLOCK(idem_lock);\n\nstatic bool idempotent(struct idempotent *u, const void *cookie)\n{\n\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);\n\tstruct hlist_head *head = idem_hash + hash;\n\tstruct idempotent *existing;\n\tbool first;\n\n\tu->ret = 0;\n\tu->cookie = cookie;\n\tinit_completion(&u->complete);\n\n\tspin_lock(&idem_lock);\n\tfirst = true;\n\thlist_for_each_entry(existing, head, entry) {\n\t\tif (existing->cookie != cookie)\n\t\t\tcontinue;\n\t\tfirst = false;\n\t\tbreak;\n\t}\n\thlist_add_head(&u->entry, idem_hash + hash);\n\tspin_unlock(&idem_lock);\n\n\treturn !first;\n}\n\n \nstatic int idempotent_complete(struct idempotent *u, int ret)\n{\n\tconst void *cookie = u->cookie;\n\tint hash = hash_ptr(cookie, IDEM_HASH_BITS);\n\tstruct hlist_head *head = idem_hash + hash;\n\tstruct hlist_node *next;\n\tstruct idempotent *pos;\n\n\tspin_lock(&idem_lock);\n\thlist_for_each_entry_safe(pos, next, head, entry) {\n\t\tif (pos->cookie != cookie)\n\t\t\tcontinue;\n\t\thlist_del(&pos->entry);\n\t\tpos->ret = ret;\n\t\tcomplete(&pos->complete);\n\t}\n\tspin_unlock(&idem_lock);\n\treturn ret;\n}\n\nstatic int init_module_from_file(struct file *f, const char __user * uargs, int flags)\n{\n\tstruct load_info info = { };\n\tvoid *buf = NULL;\n\tint len;\n\n\tlen = kernel_read_file(f, 0, &buf, INT_MAX, NULL, READING_MODULE);\n\tif (len < 0) {\n\t\tmod_stat_inc(&failed_kreads);\n\t\treturn len;\n\t}\n\n\tif (flags & MODULE_INIT_COMPRESSED_FILE) {\n\t\tint err = module_decompress(&info, buf, len);\n\t\tvfree(buf);  \n\t\tif (err) {\n\t\t\tmod_stat_inc(&failed_decompress);\n\t\t\tmod_stat_add_long(len, &invalid_decompress_bytes);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tinfo.hdr = buf;\n\t\tinfo.len = len;\n\t}\n\n\treturn load_module(&info, uargs, flags);\n}\n\nstatic int idempotent_init_module(struct file *f, const char __user * uargs, int flags)\n{\n\tstruct idempotent idem;\n\n\tif (!f || !(f->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\t \n\tif (idempotent(&idem, file_inode(f))) {\n\t\twait_for_completion(&idem.complete);\n\t\treturn idem.ret;\n\t}\n\n\t \n\treturn idempotent_complete(&idem,\n\t\tinit_module_from_file(f, uargs, flags));\n}\n\nSYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags)\n{\n\tint err;\n\tstruct fd f;\n\n\terr = may_init_module();\n\tif (err)\n\t\treturn err;\n\n\tpr_debug(\"finit_module: fd=%d, uargs=%p, flags=%i\\n\", fd, uargs, flags);\n\n\tif (flags & ~(MODULE_INIT_IGNORE_MODVERSIONS\n\t\t      |MODULE_INIT_IGNORE_VERMAGIC\n\t\t      |MODULE_INIT_COMPRESSED_FILE))\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\terr = idempotent_init_module(f.file, uargs, flags);\n\tfdput(f);\n\treturn err;\n}\n\n \nchar *module_flags(struct module *mod, char *buf, bool show_state)\n{\n\tint bx = 0;\n\n\tBUG_ON(mod->state == MODULE_STATE_UNFORMED);\n\tif (!mod->taints && !show_state)\n\t\tgoto out;\n\tif (mod->taints ||\n\t    mod->state == MODULE_STATE_GOING ||\n\t    mod->state == MODULE_STATE_COMING) {\n\t\tbuf[bx++] = '(';\n\t\tbx += module_flags_taint(mod->taints, buf + bx);\n\t\t \n\t\tif (mod->state == MODULE_STATE_GOING && show_state)\n\t\t\tbuf[bx++] = '-';\n\t\t \n\t\tif (mod->state == MODULE_STATE_COMING && show_state)\n\t\t\tbuf[bx++] = '+';\n\t\tbuf[bx++] = ')';\n\t}\nout:\n\tbuf[bx] = '\\0';\n\n\treturn buf;\n}\n\n \nconst struct exception_table_entry *search_module_extables(unsigned long addr)\n{\n\tconst struct exception_table_entry *e = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (!mod)\n\t\tgoto out;\n\n\tif (!mod->num_exentries)\n\t\tgoto out;\n\n\te = search_extable(mod->extable,\n\t\t\t   mod->num_exentries,\n\t\t\t   addr);\nout:\n\tpreempt_enable();\n\n\t \n\treturn e;\n}\n\n \nbool is_module_address(unsigned long addr)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tret = __module_address(addr) != NULL;\n\tpreempt_enable();\n\n\treturn ret;\n}\n\n \nstruct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr >= mod_tree.addr_min && addr <= mod_tree.addr_max)\n\t\tgoto lookup;\n\n#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC\n\tif (addr >= mod_tree.data_addr_min && addr <= mod_tree.data_addr_max)\n\t\tgoto lookup;\n#endif\n\n\treturn NULL;\n\nlookup:\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr, &mod_tree);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}\n\n \nbool is_module_text_address(unsigned long addr)\n{\n\tbool ret;\n\n\tpreempt_disable();\n\tret = __module_text_address(addr) != NULL;\n\tpreempt_enable();\n\n\treturn ret;\n}\n\n \nstruct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t \n\t\tif (!within_module_mem_type(addr, mod, MOD_TEXT) &&\n\t\t    !within_module_mem_type(addr, mod, MOD_INIT_TEXT))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}\n\n \nvoid print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t \n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf, true));\n\t}\n\n\tprint_unloaded_tainted_modules();\n\tpreempt_enable();\n\tif (last_unloaded_module.name[0])\n\t\tpr_cont(\" [last unloaded: %s%s]\", last_unloaded_module.name,\n\t\t\tlast_unloaded_module.taints);\n\tpr_cont(\"\\n\");\n}\n\n#ifdef CONFIG_MODULE_DEBUGFS\nstruct dentry *mod_debugfs_root;\n\nstatic int module_debugfs_init(void)\n{\n\tmod_debugfs_root = debugfs_create_dir(\"modules\", NULL);\n\treturn 0;\n}\nmodule_init(module_debugfs_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}