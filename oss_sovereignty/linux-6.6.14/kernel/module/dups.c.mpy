{
  "module_name": "dups.c",
  "hash_id": "567503bcc28e9f7aab6002ff26fd4601747ea7a618ebc74ba9d18821428af629",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/dups.c",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt)     \"module: \" fmt\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/binfmts.h>\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/cred.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/resource.h>\n#include <linux/notifier.h>\n#include <linux/suspend.h>\n#include <linux/rwsem.h>\n#include <linux/ptrace.h>\n#include <linux/async.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"module.\"\nstatic bool enable_dups_trace = IS_ENABLED(CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS_TRACE);\nmodule_param(enable_dups_trace, bool_enable_only, 0644);\n\n \nstatic DEFINE_MUTEX(kmod_dup_mutex);\nstatic LIST_HEAD(dup_kmod_reqs);\n\nstruct kmod_dup_req {\n\tstruct list_head list;\n\tchar name[MODULE_NAME_LEN];\n\tstruct completion first_req_done;\n\tstruct work_struct complete_work;\n\tstruct delayed_work delete_work;\n\tint dup_ret;\n};\n\nstatic struct kmod_dup_req *kmod_dup_request_lookup(char *module_name)\n{\n\tstruct kmod_dup_req *kmod_req;\n\n\tlist_for_each_entry_rcu(kmod_req, &dup_kmod_reqs, list,\n\t\t\t\tlockdep_is_held(&kmod_dup_mutex)) {\n\t\tif (strlen(kmod_req->name) == strlen(module_name) &&\n\t\t    !memcmp(kmod_req->name, module_name, strlen(module_name))) {\n\t\t\treturn kmod_req;\n                }\n        }\n\n\treturn NULL;\n}\n\nstatic void kmod_dup_request_delete(struct work_struct *work)\n{\n\tstruct kmod_dup_req *kmod_req;\n\tkmod_req = container_of(to_delayed_work(work), struct kmod_dup_req, delete_work);\n\n\t \n\tmutex_lock(&kmod_dup_mutex);\n\tlist_del_rcu(&kmod_req->list);\n\tsynchronize_rcu();\n\tmutex_unlock(&kmod_dup_mutex);\n\tkfree(kmod_req);\n}\n\nstatic void kmod_dup_request_complete(struct work_struct *work)\n{\n\tstruct kmod_dup_req *kmod_req;\n\n\tkmod_req = container_of(work, struct kmod_dup_req, complete_work);\n\n\t \n\tcomplete_all(&kmod_req->first_req_done);\n\n\t \n\tqueue_delayed_work(system_wq, &kmod_req->delete_work, 60 * HZ);\n}\n\nbool kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret)\n{\n\tstruct kmod_dup_req *kmod_req, *new_kmod_req;\n\tint ret;\n\n\t \n\tnew_kmod_req = kzalloc(sizeof(*new_kmod_req), GFP_KERNEL);\n\tif (!new_kmod_req)\n\t\treturn false;\n\n\tmemcpy(new_kmod_req->name, module_name, strlen(module_name));\n\tINIT_WORK(&new_kmod_req->complete_work, kmod_dup_request_complete);\n\tINIT_DELAYED_WORK(&new_kmod_req->delete_work, kmod_dup_request_delete);\n\tinit_completion(&new_kmod_req->first_req_done);\n\n\tmutex_lock(&kmod_dup_mutex);\n\n\tkmod_req = kmod_dup_request_lookup(module_name);\n\tif (!kmod_req) {\n\t\t \n\t\tif (!wait) {\n\t\t\tkfree(new_kmod_req);\n\t\t\tpr_debug(\"New request_module_nowait() for %s -- cannot track duplicates for this request\\n\", module_name);\n\t\t\tmutex_unlock(&kmod_dup_mutex);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tpr_debug(\"New request_module() for %s\\n\", module_name);\n\t\tlist_add_rcu(&new_kmod_req->list, &dup_kmod_reqs);\n\t\tmutex_unlock(&kmod_dup_mutex);\n\t\treturn false;\n\t}\n\tmutex_unlock(&kmod_dup_mutex);\n\n\t \n\tkfree(new_kmod_req);\n\n\t \n\tif (enable_dups_trace)\n\t\tWARN(1, \"module-autoload: duplicate request for module %s\\n\", module_name);\n\telse\n\t\tpr_warn(\"module-autoload: duplicate request for module %s\\n\", module_name);\n\n\tif (!wait) {\n\t\t \n\t\t*dup_ret = 0;\n\t\treturn true;\n\t}\n\n\t \n\tret = wait_for_completion_state(&kmod_req->first_req_done,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE | TASK_KILLABLE);\n\tif (ret) {\n\t\t*dup_ret = ret;\n\t\treturn true;\n\t}\n\n\t \n\t*dup_ret = kmod_req->dup_ret;\n\n\treturn true;\n}\n\nvoid kmod_dup_request_announce(char *module_name, int ret)\n{\n\tstruct kmod_dup_req *kmod_req;\n\n\tmutex_lock(&kmod_dup_mutex);\n\n\tkmod_req = kmod_dup_request_lookup(module_name);\n\tif (!kmod_req)\n\t\tgoto out;\n\n\tkmod_req->dup_ret = ret;\n\n\t \n\tqueue_work(system_wq, &kmod_req->complete_work);\n\nout:\n\tmutex_unlock(&kmod_dup_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}