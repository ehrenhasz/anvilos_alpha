{
  "module_name": "Kconfig",
  "hash_id": "ab5f28b322ff0940168477138958129198207d77a096ef5c6dc24fe3029a9337",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenuconfig MODULES\n\tbool \"Enable loadable module support\"\n\tmodules\n\thelp\n\t  Kernel modules are small pieces of compiled code which can\n\t  be inserted in the running kernel, rather than being\n\t  permanently built into the kernel.  You use the \"modprobe\"\n\t  tool to add (and sometimes remove) them.  If you say Y here,\n\t  many parts of the kernel can be built as modules (by\n\t  answering M instead of Y where indicated): this is most\n\t  useful for infrequently used options which are not required\n\t  for booting.  For more information, see the man pages for\n\t  modprobe, lsmod, modinfo, insmod and rmmod.\n\n\t  If you say Y here, you will need to run \"make\n\t  modules_install\" to put the modules under /lib/modules/\n\t  where modprobe can find them (you may need to be root to do\n\t  this).\n\n\t  If unsure, say Y.\n\nif MODULES\n\nconfig MODULE_DEBUGFS\n\tbool\n\nconfig MODULE_DEBUG\n\tbool \"Module debugging\"\n\tdepends on DEBUG_FS\n\thelp\n\t  Allows you to enable / disable features which can help you debug\n\t  modules. You don't need these options on production systems.\n\nif MODULE_DEBUG\n\nconfig MODULE_STATS\n\tbool \"Module statistics\"\n\tdepends on DEBUG_FS\n\tselect MODULE_DEBUGFS\n\thelp\n\t  This option allows you to maintain a record of module statistics.\n\t  For example, size of all modules, average size, text size, a list\n\t  of failed modules and the size for each of those. For failed\n\t  modules we keep track of modules which failed due to either the\n\t  existing module taking too long to load or that module was already\n\t  loaded.\n\n\t  You should enable this if you are debugging production loads\n\t  and want to see if userspace or the kernel is doing stupid things\n\t  with loading modules when it shouldn't or if you want to help\n\t  optimize userspace / kernel space module autoloading schemes.\n\t  You might want to do this because failed modules tend to use\n\t  up significant amount of memory, and so you'd be doing everyone a\n\t  favor in avoiding these failures proactively.\n\n\t  This functionality is also useful for those experimenting with\n\t  module .text ELF section optimization.\n\n\t  If unsure, say N.\n\nconfig MODULE_DEBUG_AUTOLOAD_DUPS\n\tbool \"Debug duplicate modules with auto-loading\"\n\thelp\n\t  Module autoloading allows in-kernel code to request modules through\n\t  the *request_module*() API calls. This in turn just calls userspace\n\t  modprobe. Although modprobe checks to see if a module is already\n\t  loaded before trying to load a module there is a small time window in\n\t  which multiple duplicate requests can end up in userspace and multiple\n\t  modprobe calls race calling finit_module() around the same time for\n\t  duplicate modules. The finit_module() system call can consume in the\n\t  worst case more than twice the respective module size in virtual\n\t  memory for each duplicate module requests. Although duplicate module\n\t  requests are non-fatal virtual memory is a limited resource and each\n\t  duplicate module request ends up just unnecessarily straining virtual\n\t  memory.\n\n\t  This debugging facility will create pr_warn() splats for duplicate\n\t  module requests to help identify if module auto-loading may be the\n\t  culprit to your early boot virtual memory pressure. Since virtual\n\t  memory abuse caused by duplicate module requests could render a\n\t  system unusable this functionality will also converge races in\n\t  requests for the same module to a single request. You can boot with\n\t  the module.enable_dups_trace=1 kernel parameter to use WARN_ON()\n\t  instead of the pr_warn().\n\n\t  If the first module request used request_module_nowait() we cannot\n\t  use that as the anchor to wait for duplicate module requests, since\n\t  users of request_module() do want a proper return value. If a call\n\t  for the same module happened earlier with request_module() though,\n\t  then a duplicate request_module_nowait() would be detected. The\n\t  non-wait request_module() call is synchronous and waits until modprobe\n\t  completes. Subsequent auto-loading requests for the same module do\n\t  not trigger a new finit_module() calls and do not strain virtual\n\t  memory, and so as soon as modprobe successfully completes we remove\n\t  tracking for duplicates for that module.\n\n\t  Enable this functionality to try to debug virtual memory abuse during\n\t  boot on systems which are failing to boot or if you suspect you may be\n\t  straining virtual memory during boot, and you want to identify if the\n\t  abuse was due to module auto-loading. These issues are currently only\n\t  known to occur on systems with many CPUs (over 400) and is likely the\n\t  result of udev issuing duplicate module requests for each CPU, and so\n\t  module auto-loading is not the culprit. There may very well still be\n\t  many duplicate module auto-loading requests which could be optimized\n\t  for and this debugging facility can be used to help identify them.\n\n\t  Only enable this for debugging system functionality, never have it\n\t  enabled on real systems.\n\nconfig MODULE_DEBUG_AUTOLOAD_DUPS_TRACE\n\tbool \"Force full stack trace when duplicates are found\"\n\tdepends on MODULE_DEBUG_AUTOLOAD_DUPS\n\thelp\n\t  Enabling this will force a full stack trace for duplicate module\n\t  auto-loading requests using WARN_ON() instead of pr_warn(). You\n\t  should keep this disabled at all times unless you are a developer\n\t  and are doing a manual inspection and want to debug exactly why\n\t  these duplicates occur.\n\nendif # MODULE_DEBUG\n\nconfig MODULE_FORCE_LOAD\n\tbool \"Forced module loading\"\n\tdefault n\n\thelp\n\t  Allow loading of modules without version information (ie. modprobe\n\t  --force).  Forced module loading sets the 'F' (forced) taint flag and\n\t  is usually a really bad idea.\n\nconfig MODULE_UNLOAD\n\tbool \"Module unloading\"\n\thelp\n\t  Without this option you will not be able to unload any\n\t  modules (note that some modules may not be unloadable\n\t  anyway), which makes your kernel smaller, faster\n\t  and simpler.  If unsure, say Y.\n\nconfig MODULE_FORCE_UNLOAD\n\tbool \"Forced module unloading\"\n\tdepends on MODULE_UNLOAD\n\thelp\n\t  This option allows you to force a module to unload, even if the\n\t  kernel believes it is unsafe: the kernel will remove the module\n\t  without waiting for anyone to stop using it (using the -f option to\n\t  rmmod).  This is mainly for kernel developers and desperate users.\n\t  If unsure, say N.\n\nconfig MODULE_UNLOAD_TAINT_TRACKING\n\tbool \"Tainted module unload tracking\"\n\tdepends on MODULE_UNLOAD\n\tselect MODULE_DEBUGFS\n\thelp\n\t  This option allows you to maintain a record of each unloaded\n\t  module that tainted the kernel. In addition to displaying a\n\t  list of linked (or loaded) modules e.g. on detection of a bad\n\t  page (see bad_page()), the aforementioned details are also\n\t  shown. If unsure, say N.\n\nconfig MODVERSIONS\n\tbool \"Module versioning support\"\n\thelp\n\t  Usually, you have to use modules compiled with your kernel.\n\t  Saying Y here makes it sometimes possible to use modules\n\t  compiled for different kernels, by adding enough information\n\t  to the modules to (hopefully) spot any changes which would\n\t  make them incompatible with the kernel you are running.  If\n\t  unsure, say N.\n\nconfig ASM_MODVERSIONS\n\tbool\n\tdefault HAVE_ASM_MODVERSIONS && MODVERSIONS\n\thelp\n\t  This enables module versioning for exported symbols also from\n\t  assembly. This can be enabled only when the target architecture\n\t  supports it.\n\nconfig MODULE_SRCVERSION_ALL\n\tbool \"Source checksum for all modules\"\n\thelp\n\t  Modules which contain a MODULE_VERSION get an extra \"srcversion\"\n\t  field inserted into their modinfo section, which contains a\n\t  sum of the source files which made it.  This helps maintainers\n\t  see exactly which source was used to build a module (since\n\t  others sometimes change the module source without updating\n\t  the version).  With this option, such a \"srcversion\" field\n\t  will be created for all modules.  If unsure, say N.\n\nconfig MODULE_SIG\n\tbool \"Module signature verification\"\n\tselect MODULE_SIG_FORMAT\n\thelp\n\t  Check modules for valid signatures upon load: the signature\n\t  is simply appended to the module. For more information see\n\t  <file:Documentation/admin-guide/module-signing.rst>.\n\n\t  Note that this option adds the OpenSSL development packages as a\n\t  kernel build dependency so that the signing tool can use its crypto\n\t  library.\n\n\t  You should enable this option if you wish to use either\n\t  CONFIG_SECURITY_LOCKDOWN_LSM or lockdown functionality imposed via\n\t  another LSM - otherwise unsigned modules will be loadable regardless\n\t  of the lockdown policy.\n\n\t  !!!WARNING!!!  If you enable this option, you MUST make sure that the\n\t  module DOES NOT get stripped after being signed.  This includes the\n\t  debuginfo strip done by some packagers (such as rpmbuild) and\n\t  inclusion into an initramfs that wants the module size reduced.\n\nconfig MODULE_SIG_FORCE\n\tbool \"Require modules to be validly signed\"\n\tdepends on MODULE_SIG\n\thelp\n\t  Reject unsigned modules or signed modules for which we don't have a\n\t  key.  Without this, such modules will simply taint the kernel.\n\nconfig MODULE_SIG_ALL\n\tbool \"Automatically sign all modules\"\n\tdefault y\n\tdepends on MODULE_SIG || IMA_APPRAISE_MODSIG\n\thelp\n\t  Sign all modules during make modules_install. Without this option,\n\t  modules must be signed manually, using the scripts/sign-file tool.\n\ncomment \"Do not forget to sign required modules with scripts/sign-file\"\n\tdepends on MODULE_SIG_FORCE && !MODULE_SIG_ALL\n\nchoice\n\tprompt \"Which hash algorithm should modules be signed with?\"\n\tdepends on MODULE_SIG || IMA_APPRAISE_MODSIG\n\thelp\n\t  This determines which sort of hashing algorithm will be used during\n\t  signature generation.  This algorithm _must_ be built into the kernel\n\t  directly so that signature verification can take place.  It is not\n\t  possible to load a signed module containing the algorithm to check\n\t  the signature on that module.\n\nconfig MODULE_SIG_SHA1\n\tbool \"Sign modules with SHA-1\"\n\tselect CRYPTO_SHA1\n\nconfig MODULE_SIG_SHA224\n\tbool \"Sign modules with SHA-224\"\n\tselect CRYPTO_SHA256\n\nconfig MODULE_SIG_SHA256\n\tbool \"Sign modules with SHA-256\"\n\tselect CRYPTO_SHA256\n\nconfig MODULE_SIG_SHA384\n\tbool \"Sign modules with SHA-384\"\n\tselect CRYPTO_SHA512\n\nconfig MODULE_SIG_SHA512\n\tbool \"Sign modules with SHA-512\"\n\tselect CRYPTO_SHA512\n\nendchoice\n\nconfig MODULE_SIG_HASH\n\tstring\n\tdepends on MODULE_SIG || IMA_APPRAISE_MODSIG\n\tdefault \"sha1\" if MODULE_SIG_SHA1\n\tdefault \"sha224\" if MODULE_SIG_SHA224\n\tdefault \"sha256\" if MODULE_SIG_SHA256\n\tdefault \"sha384\" if MODULE_SIG_SHA384\n\tdefault \"sha512\" if MODULE_SIG_SHA512\n\nchoice\n\tprompt \"Module compression mode\"\n\thelp\n\t  This option allows you to choose the algorithm which will be used to\n\t  compress modules when 'make modules_install' is run. (or, you can\n\t  choose to not compress modules at all.)\n\n\t  External modules will also be compressed in the same way during the\n\t  installation.\n\n\t  For modules inside an initrd or initramfs, it's more efficient to\n\t  compress the whole initrd or initramfs instead.\n\n\t  This is fully compatible with signed modules.\n\n\t  Please note that the tool used to load modules needs to support the\n\t  corresponding algorithm. module-init-tools MAY support gzip, and kmod\n\t  MAY support gzip, xz and zstd.\n\n\t  Your build system needs to provide the appropriate compression tool\n\t  to compress the modules.\n\n\t  If in doubt, select 'None'.\n\nconfig MODULE_COMPRESS_NONE\n\tbool \"None\"\n\thelp\n\t  Do not compress modules. The installed modules are suffixed\n\t  with .ko.\n\nconfig MODULE_COMPRESS_GZIP\n\tbool \"GZIP\"\n\thelp\n\t  Compress modules with GZIP. The installed modules are suffixed\n\t  with .ko.gz.\n\nconfig MODULE_COMPRESS_XZ\n\tbool \"XZ\"\n\thelp\n\t  Compress modules with XZ. The installed modules are suffixed\n\t  with .ko.xz.\n\nconfig MODULE_COMPRESS_ZSTD\n\tbool \"ZSTD\"\n\thelp\n\t  Compress modules with ZSTD. The installed modules are suffixed\n\t  with .ko.zst.\n\nendchoice\n\nconfig MODULE_DECOMPRESS\n\tbool \"Support in-kernel module decompression\"\n\tdepends on MODULE_COMPRESS_GZIP || MODULE_COMPRESS_XZ || MODULE_COMPRESS_ZSTD\n\tselect ZLIB_INFLATE if MODULE_COMPRESS_GZIP\n\tselect XZ_DEC if MODULE_COMPRESS_XZ\n\tselect ZSTD_DECOMPRESS if MODULE_COMPRESS_ZSTD\n\thelp\n\n\t  Support for decompressing kernel modules by the kernel itself\n\t  instead of relying on userspace to perform this task. Useful when\n\t  load pinning security policy is enabled.\n\n\t  If unsure, say N.\n\nconfig MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS\n\tbool \"Allow loading of modules with missing namespace imports\"\n\thelp\n\t  Symbols exported with EXPORT_SYMBOL_NS*() are considered exported in\n\t  a namespace. A module that makes use of a symbol exported with such a\n\t  namespace is required to import the namespace via MODULE_IMPORT_NS().\n\t  There is no technical reason to enforce correct namespace imports,\n\t  but it creates consistency between symbols defining namespaces and\n\t  users importing namespaces they make use of. This option relaxes this\n\t  requirement and lifts the enforcement when loading a module.\n\n\t  If unsure, say N.\n\nconfig MODPROBE_PATH\n\tstring \"Path to modprobe binary\"\n\tdefault \"/sbin/modprobe\"\n\thelp\n\t  When kernel code requests a module, it does so by calling\n\t  the \"modprobe\" userspace utility. This option allows you to\n\t  set the path where that binary is found. This can be changed\n\t  at runtime via the sysctl file\n\t  /proc/sys/kernel/modprobe. Setting this to the empty string\n\t  removes the kernel's ability to request modules (but\n\t  userspace can still load modules explicitly).\n\nconfig TRIM_UNUSED_KSYMS\n\tbool \"Trim unused exported kernel symbols\" if EXPERT\n\tdepends on !COMPILE_TEST\n\thelp\n\t  The kernel and some modules make many symbols available for\n\t  other modules to use via EXPORT_SYMBOL() and variants. Depending\n\t  on the set of modules being selected in your kernel configuration,\n\t  many of those exported symbols might never be used.\n\n\t  This option allows for unused exported symbols to be dropped from\n\t  the build. In turn, this provides the compiler more opportunities\n\t  (especially when using LTO) for optimizing the code and reducing\n\t  binary size.  This might have some security advantages as well.\n\n\t  If unsure, or if you need to build out-of-tree modules, say N.\n\nconfig UNUSED_KSYMS_WHITELIST\n\tstring \"Whitelist of symbols to keep in ksymtab\"\n\tdepends on TRIM_UNUSED_KSYMS\n\thelp\n\t  By default, all unused exported symbols will be un-exported from the\n\t  build when TRIM_UNUSED_KSYMS is selected.\n\n\t  UNUSED_KSYMS_WHITELIST allows to whitelist symbols that must be kept\n\t  exported at all times, even in absence of in-tree users. The value to\n\t  set here is the path to a text file containing the list of symbols,\n\t  one per line. The path can be absolute, or relative to the kernel\n\t  source tree.\n\nconfig MODULES_TREE_LOOKUP\n\tdef_bool y\n\tdepends on PERF_EVENTS || TRACING || CFI_CLANG\n\nendif # MODULES\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}