{
  "module_name": "decompress.c",
  "hash_id": "15ee98b36752c677b0aede0b3ec8f00158aa253bfbcea3dd092cc5c3c72d4b58",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/decompress.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/kobject.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/vmalloc.h>\n\n#include \"internal.h\"\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}\n\nstatic struct page *module_get_next_page(struct load_info *info)\n{\n\tstruct page *page;\n\tint error;\n\n\tif (info->max_pages == info->used_pages) {\n\t\terror = module_extend_max_pages(info, info->used_pages);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->pages[info->used_pages++] = page;\n\treturn page;\n}\n\n#if defined(CONFIG_MODULE_COMPRESS_GZIP)\n#include <linux/zlib.h>\n#define MODULE_COMPRESSION\tgzip\n#define MODULE_DECOMPRESS_FN\tmodule_gzip_decompress\n\n \nstatic size_t module_gzip_header_len(const u8 *buf, size_t size)\n{\n\tconst u8 signature[] = { 0x1f, 0x8b, 0x08 };\n\tsize_t len = 10;\n\n\tif (size < len || memcmp(buf, signature, sizeof(signature)))\n\t\treturn 0;\n\n\tif (buf[3] & 0x08) {\n\t\tdo {\n\t\t\t \n\t\t\tif (len == size)\n\t\t\t\treturn 0;\n\t\t} while (buf[len++] != '\\0');\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kvmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkvfree(s.workspace);\n\treturn retval;\n}\n#elif defined(CONFIG_MODULE_COMPRESS_XZ)\n#include <linux/xz.h>\n#define MODULE_COMPRESSION\txz\n#define MODULE_DECOMPRESS_FN\tmodule_xz_decompress\n\nstatic ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = new_size;\n\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}\n#elif defined(CONFIG_MODULE_COMPRESS_ZSTD)\n#include <linux/zstd.h>\n#define MODULE_COMPRESSION\tzstd\n#define MODULE_DECOMPRESS_FN\tmodule_zstd_decompress\n\nstatic ssize_t module_zstd_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0x28, 0xb5, 0x2f, 0xfd };\n\tZSTD_outBuffer zstd_dec;\n\tZSTD_inBuffer zstd_buf;\n\tzstd_frame_header header;\n\tsize_t wksp_size;\n\tvoid *wksp = NULL;\n\tZSTD_DStream *dstream;\n\tsize_t ret;\n\tsize_t new_size = 0;\n\tint retval;\n\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not a zstd compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tzstd_buf.src = buf;\n\tzstd_buf.pos = 0;\n\tzstd_buf.size = size;\n\n\tret = zstd_get_frame_header(&header, zstd_buf.src, zstd_buf.size);\n\tif (ret != 0) {\n\t\tpr_err(\"ZSTD-compressed data has an incomplete frame header\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (header.windowSize > (1 << ZSTD_WINDOWLOG_MAX)) {\n\t\tpr_err(\"ZSTD-compressed data has too large a window size\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twksp_size = zstd_dstream_workspace_bound(header.windowSize);\n\twksp = kvmalloc(wksp_size, GFP_KERNEL);\n\tif (!wksp) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdstream = zstd_init_dstream(header.windowSize, wksp, wksp_size);\n\tif (!dstream) {\n\t\tpr_err(\"Can't initialize ZSTD stream\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\tzstd_dec.dst = kmap_local_page(page);\n\t\tzstd_dec.pos = 0;\n\t\tzstd_dec.size = PAGE_SIZE;\n\n\t\tret = zstd_decompress_stream(dstream, &zstd_dec, &zstd_buf);\n\t\tkunmap_local(zstd_dec.dst);\n\t\tretval = zstd_get_error_code(ret);\n\t\tif (retval)\n\t\t\tbreak;\n\n\t\tnew_size += zstd_dec.pos;\n\t} while (zstd_dec.pos == PAGE_SIZE && ret != 0);\n\n\tif (retval) {\n\t\tpr_err(\"ZSTD-decompression failed with status %d\\n\", retval);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = new_size;\n\n out:\n\tkvfree(wksp);\n\treturn retval;\n}\n#else\n#error \"Unexpected configuration for CONFIG_MODULE_DECOMPRESS\"\n#endif\n\nint module_decompress(struct load_info *info, const void *buf, size_t size)\n{\n\tunsigned int n_pages;\n\tssize_t data_size;\n\tint error;\n\n#if defined(CONFIG_MODULE_STATS)\n\tinfo->compressed_len = size;\n#endif\n\n\t \n\tn_pages = DIV_ROUND_UP(size, PAGE_SIZE) * 2;\n\terror = module_extend_max_pages(info, n_pages);\n\n\tdata_size = MODULE_DECOMPRESS_FN(info, buf, size);\n\tif (data_size < 0) {\n\t\terror = data_size;\n\t\tgoto err;\n\t}\n\n\tinfo->hdr = vmap(info->pages, info->used_pages, VM_MAP, PAGE_KERNEL);\n\tif (!info->hdr) {\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tinfo->len = data_size;\n\treturn 0;\n\nerr:\n\tmodule_decompress_cleanup(info);\n\treturn error;\n}\n\nvoid module_decompress_cleanup(struct load_info *info)\n{\n\tint i;\n\n\tif (info->hdr)\n\t\tvunmap(info->hdr);\n\n\tfor (i = 0; i < info->used_pages; i++)\n\t\t__free_page(info->pages[i]);\n\n\tkvfree(info->pages);\n\n\tinfo->pages = NULL;\n\tinfo->max_pages = info->used_pages = 0;\n}\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t compression_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, __stringify(MODULE_COMPRESSION) \"\\n\");\n}\n\nstatic struct kobj_attribute module_compression_attr = __ATTR_RO(compression);\n\nstatic int __init module_decompress_sysfs_init(void)\n{\n\tint error;\n\n\terror = sysfs_create_file(&module_kset->kobj,\n\t\t\t\t  &module_compression_attr.attr);\n\tif (error)\n\t\tpr_warn(\"Failed to create 'compression' attribute\");\n\n\treturn 0;\n}\nlate_initcall(module_decompress_sysfs_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}