{
  "module_name": "sysfs.c",
  "hash_id": "5c34a65f202d5702839324ee7693b7cbd97b8439a5a8d02ae8404353cba0c560",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/kallsyms.h>\n#include <linux/mutex.h>\n#include \"internal.h\"\n\n \n#ifdef CONFIG_KALLSYMS\nstruct module_sect_attr {\n\tstruct bin_attribute battr;\n\tunsigned long address;\n};\n\nstruct module_sect_attrs {\n\tstruct attribute_group grp;\n\tunsigned int nsections;\n\tstruct module_sect_attr attrs[];\n};\n\n#define MODULE_SECT_READ_SIZE (3   + (BITS_PER_LONG / 4))\nstatic ssize_t module_sect_read(struct file *file, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *battr,\n\t\t\t\tchar *buf, loff_t pos, size_t count)\n{\n\tstruct module_sect_attr *sattr =\n\t\tcontainer_of(battr, struct module_sect_attr, battr);\n\tchar bounce[MODULE_SECT_READ_SIZE + 1];\n\tsize_t wrote;\n\n\tif (pos != 0)\n\t\treturn -EINVAL;\n\n\t \n\twrote = scnprintf(bounce, sizeof(bounce), \"0x%px\\n\",\n\t\t\t  kallsyms_show_value(file->f_cred)\n\t\t\t\t? (void *)sattr->address : NULL);\n\tcount = min(count, wrote);\n\tmemcpy(buf, bounce, count);\n\n\treturn count;\n}\n\nstatic void free_sect_attrs(struct module_sect_attrs *sect_attrs)\n{\n\tunsigned int section;\n\n\tfor (section = 0; section < sect_attrs->nsections; section++)\n\t\tkfree(sect_attrs->attrs[section].battr.attr.name);\n\tkfree(sect_attrs);\n}\n\nstatic void add_sect_attrs(struct module *mod, const struct load_info *info)\n{\n\tunsigned int nloaded = 0, i, size[2];\n\tstruct module_sect_attrs *sect_attrs;\n\tstruct module_sect_attr *sattr;\n\tstruct bin_attribute **gattr;\n\n\t \n\tfor (i = 0; i < info->hdr->e_shnum; i++)\n\t\tif (!sect_empty(&info->sechdrs[i]))\n\t\t\tnloaded++;\n\tsize[0] = ALIGN(struct_size(sect_attrs, attrs, nloaded),\n\t\t\tsizeof(sect_attrs->grp.bin_attrs[0]));\n\tsize[1] = (nloaded + 1) * sizeof(sect_attrs->grp.bin_attrs[0]);\n\tsect_attrs = kzalloc(size[0] + size[1], GFP_KERNEL);\n\tif (!sect_attrs)\n\t\treturn;\n\n\t \n\tsect_attrs->grp.name = \"sections\";\n\tsect_attrs->grp.bin_attrs = (void *)sect_attrs + size[0];\n\n\tsect_attrs->nsections = 0;\n\tsattr = &sect_attrs->attrs[0];\n\tgattr = &sect_attrs->grp.bin_attrs[0];\n\tfor (i = 0; i < info->hdr->e_shnum; i++) {\n\t\tElf_Shdr *sec = &info->sechdrs[i];\n\n\t\tif (sect_empty(sec))\n\t\t\tcontinue;\n\t\tsysfs_bin_attr_init(&sattr->battr);\n\t\tsattr->address = sec->sh_addr;\n\t\tsattr->battr.attr.name =\n\t\t\tkstrdup(info->secstrings + sec->sh_name, GFP_KERNEL);\n\t\tif (!sattr->battr.attr.name)\n\t\t\tgoto out;\n\t\tsect_attrs->nsections++;\n\t\tsattr->battr.read = module_sect_read;\n\t\tsattr->battr.size = MODULE_SECT_READ_SIZE;\n\t\tsattr->battr.attr.mode = 0400;\n\t\t*(gattr++) = &(sattr++)->battr;\n\t}\n\t*gattr = NULL;\n\n\tif (sysfs_create_group(&mod->mkobj.kobj, &sect_attrs->grp))\n\t\tgoto out;\n\n\tmod->sect_attrs = sect_attrs;\n\treturn;\nout:\n\tfree_sect_attrs(sect_attrs);\n}\n\nstatic void remove_sect_attrs(struct module *mod)\n{\n\tif (mod->sect_attrs) {\n\t\tsysfs_remove_group(&mod->mkobj.kobj,\n\t\t\t\t   &mod->sect_attrs->grp);\n\t\t \n\t\tfree_sect_attrs(mod->sect_attrs);\n\t\tmod->sect_attrs = NULL;\n\t}\n}\n\n \n\nstruct module_notes_attrs {\n\tstruct kobject *dir;\n\tunsigned int notes;\n\tstruct bin_attribute attrs[];\n};\n\nstatic ssize_t module_notes_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr,\n\t\t\t\t char *buf, loff_t pos, size_t count)\n{\n\t \n\tmemcpy(buf, bin_attr->private + pos, count);\n\treturn count;\n}\n\nstatic void free_notes_attrs(struct module_notes_attrs *notes_attrs,\n\t\t\t     unsigned int i)\n{\n\tif (notes_attrs->dir) {\n\t\twhile (i-- > 0)\n\t\t\tsysfs_remove_bin_file(notes_attrs->dir,\n\t\t\t\t\t      &notes_attrs->attrs[i]);\n\t\tkobject_put(notes_attrs->dir);\n\t}\n\tkfree(notes_attrs);\n}\n\nstatic void add_notes_attrs(struct module *mod, const struct load_info *info)\n{\n\tunsigned int notes, loaded, i;\n\tstruct module_notes_attrs *notes_attrs;\n\tstruct bin_attribute *nattr;\n\n\t \n\tif (!mod->sect_attrs)\n\t\treturn;\n\n\t \n\tnotes = 0;\n\tfor (i = 0; i < info->hdr->e_shnum; i++)\n\t\tif (!sect_empty(&info->sechdrs[i]) &&\n\t\t    info->sechdrs[i].sh_type == SHT_NOTE)\n\t\t\t++notes;\n\n\tif (notes == 0)\n\t\treturn;\n\n\tnotes_attrs = kzalloc(struct_size(notes_attrs, attrs, notes),\n\t\t\t      GFP_KERNEL);\n\tif (!notes_attrs)\n\t\treturn;\n\n\tnotes_attrs->notes = notes;\n\tnattr = &notes_attrs->attrs[0];\n\tfor (loaded = i = 0; i < info->hdr->e_shnum; ++i) {\n\t\tif (sect_empty(&info->sechdrs[i]))\n\t\t\tcontinue;\n\t\tif (info->sechdrs[i].sh_type == SHT_NOTE) {\n\t\t\tsysfs_bin_attr_init(nattr);\n\t\t\tnattr->attr.name = mod->sect_attrs->attrs[loaded].battr.attr.name;\n\t\t\tnattr->attr.mode = 0444;\n\t\t\tnattr->size = info->sechdrs[i].sh_size;\n\t\t\tnattr->private = (void *)info->sechdrs[i].sh_addr;\n\t\t\tnattr->read = module_notes_read;\n\t\t\t++nattr;\n\t\t}\n\t\t++loaded;\n\t}\n\n\tnotes_attrs->dir = kobject_create_and_add(\"notes\", &mod->mkobj.kobj);\n\tif (!notes_attrs->dir)\n\t\tgoto out;\n\n\tfor (i = 0; i < notes; ++i)\n\t\tif (sysfs_create_bin_file(notes_attrs->dir,\n\t\t\t\t\t  &notes_attrs->attrs[i]))\n\t\t\tgoto out;\n\n\tmod->notes_attrs = notes_attrs;\n\treturn;\n\nout:\n\tfree_notes_attrs(notes_attrs, i);\n}\n\nstatic void remove_notes_attrs(struct module *mod)\n{\n\tif (mod->notes_attrs)\n\t\tfree_notes_attrs(mod->notes_attrs, mod->notes_attrs->notes);\n}\n\n#else  \nstatic inline void add_sect_attrs(struct module *mod, const struct load_info *info) { }\nstatic inline void remove_sect_attrs(struct module *mod) { }\nstatic inline void add_notes_attrs(struct module *mod, const struct load_info *info) { }\nstatic inline void remove_notes_attrs(struct module *mod) { }\n#endif  \n\nstatic void del_usage_links(struct module *mod)\n{\n#ifdef CONFIG_MODULE_UNLOAD\n\tstruct module_use *use;\n\n\tmutex_lock(&module_mutex);\n\tlist_for_each_entry(use, &mod->target_list, target_list)\n\t\tsysfs_remove_link(use->target->holders_dir, mod->name);\n\tmutex_unlock(&module_mutex);\n#endif\n}\n\nstatic int add_usage_links(struct module *mod)\n{\n\tint ret = 0;\n#ifdef CONFIG_MODULE_UNLOAD\n\tstruct module_use *use;\n\n\tmutex_lock(&module_mutex);\n\tlist_for_each_entry(use, &mod->target_list, target_list) {\n\t\tret = sysfs_create_link(use->target->holders_dir,\n\t\t\t\t\t&mod->mkobj.kobj, mod->name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&module_mutex);\n\tif (ret)\n\t\tdel_usage_links(mod);\n#endif\n\treturn ret;\n}\n\nstatic void module_remove_modinfo_attrs(struct module *mod, int end)\n{\n\tstruct module_attribute *attr;\n\tint i;\n\n\tfor (i = 0; (attr = &mod->modinfo_attrs[i]); i++) {\n\t\tif (end >= 0 && i > end)\n\t\t\tbreak;\n\t\t \n\t\tif (!attr->attr.name)\n\t\t\tbreak;\n\t\tsysfs_remove_file(&mod->mkobj.kobj, &attr->attr);\n\t\tif (attr->free)\n\t\t\tattr->free(mod);\n\t}\n\tkfree(mod->modinfo_attrs);\n}\n\nstatic int module_add_modinfo_attrs(struct module *mod)\n{\n\tstruct module_attribute *attr;\n\tstruct module_attribute *temp_attr;\n\tint error = 0;\n\tint i;\n\n\tmod->modinfo_attrs = kzalloc((sizeof(struct module_attribute) *\n\t\t\t\t\t(modinfo_attrs_count + 1)),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mod->modinfo_attrs)\n\t\treturn -ENOMEM;\n\n\ttemp_attr = mod->modinfo_attrs;\n\tfor (i = 0; (attr = modinfo_attrs[i]); i++) {\n\t\tif (!attr->test || attr->test(mod)) {\n\t\t\tmemcpy(temp_attr, attr, sizeof(*temp_attr));\n\t\t\tsysfs_attr_init(&temp_attr->attr);\n\t\t\terror = sysfs_create_file(&mod->mkobj.kobj,\n\t\t\t\t\t\t  &temp_attr->attr);\n\t\t\tif (error)\n\t\t\t\tgoto error_out;\n\t\t\t++temp_attr;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_out:\n\tif (i > 0)\n\t\tmodule_remove_modinfo_attrs(mod, --i);\n\telse\n\t\tkfree(mod->modinfo_attrs);\n\treturn error;\n}\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}\n\nstatic int mod_sysfs_init(struct module *mod)\n{\n\tint err;\n\tstruct kobject *kobj;\n\n\tif (!module_kset) {\n\t\tpr_err(\"%s: module sysfs not initialized\\n\", mod->name);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkobj = kset_find_obj(module_kset, mod->name);\n\tif (kobj) {\n\t\tpr_err(\"%s: module is already loaded\\n\", mod->name);\n\t\tkobject_put(kobj);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmod->mkobj.mod = mod;\n\n\tmemset(&mod->mkobj.kobj, 0, sizeof(mod->mkobj.kobj));\n\tmod->mkobj.kobj.kset = module_kset;\n\terr = kobject_init_and_add(&mod->mkobj.kobj, &module_ktype, NULL,\n\t\t\t\t   \"%s\", mod->name);\n\tif (err)\n\t\tmod_kobject_put(mod);\n\nout:\n\treturn err;\n}\n\nint mod_sysfs_setup(struct module *mod,\n\t\t    const struct load_info *info,\n\t\t\t   struct kernel_param *kparam,\n\t\t\t   unsigned int num_params)\n{\n\tint err;\n\n\terr = mod_sysfs_init(mod);\n\tif (err)\n\t\tgoto out;\n\n\tmod->holders_dir = kobject_create_and_add(\"holders\", &mod->mkobj.kobj);\n\tif (!mod->holders_dir) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unreg;\n\t}\n\n\terr = module_param_sysfs_setup(mod, kparam, num_params);\n\tif (err)\n\t\tgoto out_unreg_holders;\n\n\terr = module_add_modinfo_attrs(mod);\n\tif (err)\n\t\tgoto out_unreg_param;\n\n\terr = add_usage_links(mod);\n\tif (err)\n\t\tgoto out_unreg_modinfo_attrs;\n\n\tadd_sect_attrs(mod, info);\n\tadd_notes_attrs(mod, info);\n\n\treturn 0;\n\nout_unreg_modinfo_attrs:\n\tmodule_remove_modinfo_attrs(mod, -1);\nout_unreg_param:\n\tmodule_param_sysfs_remove(mod);\nout_unreg_holders:\n\tkobject_put(mod->holders_dir);\nout_unreg:\n\tmod_kobject_put(mod);\nout:\n\treturn err;\n}\n\nstatic void mod_sysfs_fini(struct module *mod)\n{\n\tremove_notes_attrs(mod);\n\tremove_sect_attrs(mod);\n\tmod_kobject_put(mod);\n}\n\nvoid mod_sysfs_teardown(struct module *mod)\n{\n\tdel_usage_links(mod);\n\tmodule_remove_modinfo_attrs(mod, -1);\n\tmodule_param_sysfs_remove(mod);\n\tkobject_put(mod->mkobj.drivers_dir);\n\tkobject_put(mod->holders_dir);\n\tmod_sysfs_fini(mod);\n}\n\nvoid init_param_lock(struct module *mod)\n{\n\tmutex_init(&mod->param_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}