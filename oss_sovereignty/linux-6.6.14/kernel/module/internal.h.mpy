{
  "module_name": "internal.h",
  "hash_id": "b63ad4dc39d09a373ed3fa75a217873354a8681bc7db4742ebbb0f674a82261f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/internal.h",
  "human_readable_source": " \n \n\n#include <linux/elf.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/mm.h>\n\n#ifndef ARCH_SHF_SMALL\n#define ARCH_SHF_SMALL 0\n#endif\n\n \n\n#define SH_ENTSIZE_TYPE_BITS\t4\n#define SH_ENTSIZE_TYPE_SHIFT\t(BITS_PER_LONG - SH_ENTSIZE_TYPE_BITS)\n#define SH_ENTSIZE_TYPE_MASK\t((1UL << SH_ENTSIZE_TYPE_BITS) - 1)\n#define SH_ENTSIZE_OFFSET_MASK\t((1UL << (BITS_PER_LONG - SH_ENTSIZE_TYPE_BITS)) - 1)\n\n \n#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)\n\nstruct kernel_symbol {\n#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS\n\tint value_offset;\n\tint name_offset;\n\tint namespace_offset;\n#else\n\tunsigned long value;\n\tconst char *name;\n\tconst char *namespace;\n#endif\n};\n\nextern struct mutex module_mutex;\nextern struct list_head modules;\n\nextern struct module_attribute *modinfo_attrs[];\nextern size_t modinfo_attrs_count;\n\n \nextern const struct kernel_symbol __start___ksymtab[];\nextern const struct kernel_symbol __stop___ksymtab[];\nextern const struct kernel_symbol __start___ksymtab_gpl[];\nextern const struct kernel_symbol __stop___ksymtab_gpl[];\nextern const s32 __start___kcrctab[];\nextern const s32 __start___kcrctab_gpl[];\n\nstruct load_info {\n\tconst char *name;\n\t \n\tstruct module *mod;\n\tElf_Ehdr *hdr;\n\tunsigned long len;\n\tElf_Shdr *sechdrs;\n\tchar *secstrings, *strtab;\n\tunsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;\n\tbool sig_ok;\n#ifdef CONFIG_KALLSYMS\n\tunsigned long mod_kallsyms_init_off;\n#endif\n#ifdef CONFIG_MODULE_DECOMPRESS\n#ifdef CONFIG_MODULE_STATS\n\tunsigned long compressed_len;\n#endif\n\tstruct page **pages;\n\tunsigned int max_pages;\n\tunsigned int used_pages;\n#endif\n\tstruct {\n\t\tunsigned int sym, str, mod, vers, info, pcpu;\n\t} index;\n};\n\nenum mod_license {\n\tNOT_GPL_ONLY,\n\tGPL_ONLY,\n};\n\nstruct find_symbol_arg {\n\t \n\tconst char *name;\n\tbool gplok;\n\tbool warn;\n\n\t \n\tstruct module *owner;\n\tconst s32 *crc;\n\tconst struct kernel_symbol *sym;\n\tenum mod_license license;\n};\n\nint mod_verify_sig(const void *mod, struct load_info *info);\nint try_to_force_load(struct module *mod, const char *reason);\nbool find_symbol(struct find_symbol_arg *fsa);\nstruct module *find_module_all(const char *name, size_t len, bool even_unformed);\nint cmp_name(const void *name, const void *sym);\nlong module_get_offset_and_type(struct module *mod, enum mod_mem_type type,\n\t\t\t\tElf_Shdr *sechdr, unsigned int section);\nchar *module_flags(struct module *mod, char *buf, bool show_state);\nsize_t module_flags_taint(unsigned long taints, char *buf);\n\nchar *module_next_tag_pair(char *string, unsigned long *secsize);\n\n#define for_each_modinfo_entry(entry, info, name) \\\n\tfor (entry = get_modinfo(info, name); entry; entry = get_next_modinfo(info, name, entry))\n\nstatic inline void module_assert_mutex_or_preempt(void)\n{\n#ifdef CONFIG_LOCKDEP\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tWARN_ON_ONCE(!rcu_read_lock_sched_held() &&\n\t\t     !lockdep_is_held(&module_mutex));\n#endif\n}\n\nstatic inline unsigned long kernel_symbol_value(const struct kernel_symbol *sym)\n{\n#ifdef CONFIG_HAVE_ARCH_PREL32_RELOCATIONS\n\treturn (unsigned long)offset_to_ptr(&sym->value_offset);\n#else\n\treturn sym->value;\n#endif\n}\n\n#ifdef CONFIG_LIVEPATCH\nint copy_module_elf(struct module *mod, struct load_info *info);\nvoid free_module_elf(struct module *mod);\n#else  \nstatic inline int copy_module_elf(struct module *mod, struct load_info *info)\n{\n\treturn 0;\n}\n\nstatic inline void free_module_elf(struct module *mod) { }\n#endif  \n\nstatic inline bool set_livepatch_module(struct module *mod)\n{\n#ifdef CONFIG_LIVEPATCH\n\tmod->klp = true;\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\n \nenum fail_dup_mod_reason {\n\tFAIL_DUP_MOD_BECOMING = 0,\n\tFAIL_DUP_MOD_LOAD,\n};\n\n#ifdef CONFIG_MODULE_DEBUGFS\nextern struct dentry *mod_debugfs_root;\n#endif\n\n#ifdef CONFIG_MODULE_STATS\n\n#define mod_stat_add_long(count, var) atomic_long_add(count, var)\n#define mod_stat_inc(name) atomic_inc(name)\n\nextern atomic_long_t total_mod_size;\nextern atomic_long_t total_text_size;\nextern atomic_long_t invalid_kread_bytes;\nextern atomic_long_t invalid_decompress_bytes;\n\nextern atomic_t modcount;\nextern atomic_t failed_kreads;\nextern atomic_t failed_decompress;\nstruct mod_fail_load {\n\tstruct list_head list;\n\tchar name[MODULE_NAME_LEN];\n\tatomic_long_t count;\n\tunsigned long dup_fail_mask;\n};\n\nint try_add_failed_module(const char *name, enum fail_dup_mod_reason reason);\nvoid mod_stat_bump_invalid(struct load_info *info, int flags);\nvoid mod_stat_bump_becoming(struct load_info *info, int flags);\n\n#else\n\n#define mod_stat_add_long(name, var)\n#define mod_stat_inc(name)\n\nstatic inline int try_add_failed_module(const char *name,\n\t\t\t\t\tenum fail_dup_mod_reason reason)\n{\n\treturn 0;\n}\n\nstatic inline void mod_stat_bump_invalid(struct load_info *info, int flags)\n{\n}\n\nstatic inline void mod_stat_bump_becoming(struct load_info *info, int flags)\n{\n}\n\n#endif  \n\n#ifdef CONFIG_MODULE_DEBUG_AUTOLOAD_DUPS\nbool kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret);\nvoid kmod_dup_request_announce(char *module_name, int ret);\n#else\nstatic inline bool kmod_dup_request_exists_wait(char *module_name, bool wait, int *dup_ret)\n{\n\treturn false;\n}\n\nstatic inline void kmod_dup_request_announce(char *module_name, int ret)\n{\n}\n#endif\n\n#ifdef CONFIG_MODULE_UNLOAD_TAINT_TRACKING\nstruct mod_unload_taint {\n\tstruct list_head list;\n\tchar name[MODULE_NAME_LEN];\n\tunsigned long taints;\n\tu64 count;\n};\n\nint try_add_tainted_module(struct module *mod);\nvoid print_unloaded_tainted_modules(void);\n#else  \nstatic inline int try_add_tainted_module(struct module *mod)\n{\n\treturn 0;\n}\n\nstatic inline void print_unloaded_tainted_modules(void)\n{\n}\n#endif  \n\n#ifdef CONFIG_MODULE_DECOMPRESS\nint module_decompress(struct load_info *info, const void *buf, size_t size);\nvoid module_decompress_cleanup(struct load_info *info);\n#else\nstatic inline int module_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void module_decompress_cleanup(struct load_info *info)\n{\n}\n#endif\n\nstruct mod_tree_root {\n#ifdef CONFIG_MODULES_TREE_LOOKUP\n\tstruct latch_tree_root root;\n#endif\n\tunsigned long addr_min;\n\tunsigned long addr_max;\n#ifdef CONFIG_ARCH_WANTS_MODULES_DATA_IN_VMALLOC\n\tunsigned long data_addr_min;\n\tunsigned long data_addr_max;\n#endif\n};\n\nextern struct mod_tree_root mod_tree;\n\n#ifdef CONFIG_MODULES_TREE_LOOKUP\nvoid mod_tree_insert(struct module *mod);\nvoid mod_tree_remove_init(struct module *mod);\nvoid mod_tree_remove(struct module *mod);\nstruct module *mod_find(unsigned long addr, struct mod_tree_root *tree);\n#else  \n\nstatic inline void mod_tree_insert(struct module *mod) { }\nstatic inline void mod_tree_remove_init(struct module *mod) { }\nstatic inline void mod_tree_remove(struct module *mod) { }\nstatic inline struct module *mod_find(unsigned long addr, struct mod_tree_root *tree)\n{\n\tstruct module *mod;\n\n\tlist_for_each_entry_rcu(mod, &modules, list,\n\t\t\t\tlockdep_is_held(&module_mutex)) {\n\t\tif (within_module(addr, mod))\n\t\t\treturn mod;\n\t}\n\n\treturn NULL;\n}\n#endif  \n\nvoid module_enable_ro(const struct module *mod, bool after_init);\nvoid module_enable_nx(const struct module *mod);\nvoid module_enable_x(const struct module *mod);\nint module_enforce_rwx_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,\n\t\t\t\tchar *secstrings, struct module *mod);\n\n#ifdef CONFIG_MODULE_SIG\nint module_sig_check(struct load_info *info, int flags);\n#else  \nstatic inline int module_sig_check(struct load_info *info, int flags)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_DEBUG_KMEMLEAK\nvoid kmemleak_load_module(const struct module *mod, const struct load_info *info);\n#else  \nstatic inline void kmemleak_load_module(const struct module *mod,\n\t\t\t\t\tconst struct load_info *info) { }\n#endif  \n\n#ifdef CONFIG_KALLSYMS\nvoid init_build_id(struct module *mod, const struct load_info *info);\nvoid layout_symtab(struct module *mod, struct load_info *info);\nvoid add_kallsyms(struct module *mod, const struct load_info *info);\n\nstatic inline bool sect_empty(const Elf_Shdr *sect)\n{\n\treturn !(sect->sh_flags & SHF_ALLOC) || sect->sh_size == 0;\n}\n#else  \nstatic inline void init_build_id(struct module *mod, const struct load_info *info) { }\nstatic inline void layout_symtab(struct module *mod, struct load_info *info) { }\nstatic inline void add_kallsyms(struct module *mod, const struct load_info *info) { }\n#endif  \n\n#ifdef CONFIG_SYSFS\nint mod_sysfs_setup(struct module *mod, const struct load_info *info,\n\t\t    struct kernel_param *kparam, unsigned int num_params);\nvoid mod_sysfs_teardown(struct module *mod);\nvoid init_param_lock(struct module *mod);\n#else  \nstatic inline int mod_sysfs_setup(struct module *mod,\n\t\t\t   \t  const struct load_info *info,\n\t\t\t   \t  struct kernel_param *kparam,\n\t\t\t   \t  unsigned int num_params)\n{\n\treturn 0;\n}\n\nstatic inline void mod_sysfs_teardown(struct module *mod) { }\nstatic inline void init_param_lock(struct module *mod) { }\n#endif  \n\n#ifdef CONFIG_MODVERSIONS\nint check_version(const struct load_info *info,\n\t\t  const char *symname, struct module *mod, const s32 *crc);\nvoid module_layout(struct module *mod, struct modversion_info *ver, struct kernel_param *kp,\n\t\t   struct kernel_symbol *ks, struct tracepoint * const *tp);\nint check_modstruct_version(const struct load_info *info, struct module *mod);\nint same_magic(const char *amagic, const char *bmagic, bool has_crcs);\n#else  \nstatic inline int check_version(const struct load_info *info,\n\t\t\t\tconst char *symname,\n\t\t\t\tstruct module *mod,\n\t\t\t\tconst s32 *crc)\n{\n\treturn 1;\n}\n\nstatic inline int check_modstruct_version(const struct load_info *info,\n\t\t\t\t\t  struct module *mod)\n{\n\treturn 1;\n}\n\nstatic inline int same_magic(const char *amagic, const char *bmagic, bool has_crcs)\n{\n\treturn strcmp(amagic, bmagic) == 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}