{
  "module_name": "signing.c",
  "hash_id": "20729a35c6d4ab59b64a4c02b315335b204a5f1e7ce01d3dc77d531469444420",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/signing.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/module_signature.h>\n#include <linux/string.h>\n#include <linux/verification.h>\n#include <linux/security.h>\n#include <crypto/public_key.h>\n#include <uapi/linux/module.h>\n#include \"internal.h\"\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"module.\"\n\nstatic bool sig_enforce = IS_ENABLED(CONFIG_MODULE_SIG_FORCE);\nmodule_param(sig_enforce, bool_enable_only, 0644);\n\n \nbool is_module_sig_enforced(void)\n{\n\treturn sig_enforce;\n}\nEXPORT_SYMBOL(is_module_sig_enforced);\n\nvoid set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}\n\n \nint mod_verify_sig(const void *mod, struct load_info *info)\n{\n\tstruct module_signature ms;\n\tsize_t sig_len, modlen = info->len;\n\tint ret;\n\n\tpr_devel(\"==>%s(,%zu)\\n\", __func__, modlen);\n\n\tif (modlen <= sizeof(ms))\n\t\treturn -EBADMSG;\n\n\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));\n\n\tret = mod_check_sig(&ms, modlen, \"module\");\n\tif (ret)\n\t\treturn ret;\n\n\tsig_len = be32_to_cpu(ms.sig_len);\n\tmodlen -= sig_len + sizeof(ms);\n\tinfo->len = modlen;\n\n\treturn verify_pkcs7_signature(mod, modlen, mod + modlen, sig_len,\n\t\t\t\t      VERIFY_USE_SECONDARY_KEYRING,\n\t\t\t\t      VERIFYING_MODULE_SIGNATURE,\n\t\t\t\t      NULL, NULL);\n}\n\nint module_sig_check(struct load_info *info, int flags)\n{\n\tint err = -ENODATA;\n\tconst unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;\n\tconst char *reason;\n\tconst void *mod = info->hdr;\n\tbool mangled_module = flags & (MODULE_INIT_IGNORE_MODVERSIONS |\n\t\t\t\t       MODULE_INIT_IGNORE_VERMAGIC);\n\t \n\tif (!mangled_module &&\n\t    info->len > markerlen &&\n\t    memcmp(mod + info->len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {\n\t\t \n\t\tinfo->len -= markerlen;\n\t\terr = mod_verify_sig(mod, info);\n\t\tif (!err) {\n\t\t\tinfo->sig_ok = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tswitch (err) {\n\tcase -ENODATA:\n\t\treason = \"unsigned module\";\n\t\tbreak;\n\tcase -ENOPKG:\n\t\treason = \"module with unsupported crypto\";\n\t\tbreak;\n\tcase -ENOKEY:\n\t\treason = \"module with unavailable key\";\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn err;\n\t}\n\n\tif (is_module_sig_enforced()) {\n\t\tpr_notice(\"Loading of %s is rejected\\n\", reason);\n\t\treturn -EKEYREJECTED;\n\t}\n\n\treturn security_locked_down(LOCKDOWN_MODULE_SIGNATURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}