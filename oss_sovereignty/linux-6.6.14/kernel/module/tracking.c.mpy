{
  "module_name": "tracking.c",
  "hash_id": "4e7c6effc7edcc7d72665ba1155ad5c99825f079726f46b3b229d9c3a63cc95a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/tracking.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/debugfs.h>\n#include <linux/rculist.h>\n#include \"internal.h\"\n\nstatic LIST_HEAD(unloaded_tainted_modules);\nextern struct dentry *mod_debugfs_root;\n\nint try_add_tainted_module(struct module *mod)\n{\n\tstruct mod_unload_taint *mod_taint;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tif (!mod->taints)\n\t\tgoto out;\n\n\tlist_for_each_entry_rcu(mod_taint, &unloaded_tainted_modules, list,\n\t\t\t\tlockdep_is_held(&module_mutex)) {\n\t\tif (!strcmp(mod_taint->name, mod->name) &&\n\t\t    mod_taint->taints & mod->taints) {\n\t\t\tmod_taint->count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmod_taint = kmalloc(sizeof(*mod_taint), GFP_KERNEL);\n\tif (unlikely(!mod_taint))\n\t\treturn -ENOMEM;\n\tstrscpy(mod_taint->name, mod->name, MODULE_NAME_LEN);\n\tmod_taint->taints = mod->taints;\n\tlist_add_rcu(&mod_taint->list, &unloaded_tainted_modules);\n\tmod_taint->count = 1;\nout:\n\treturn 0;\n}\n\nvoid print_unloaded_tainted_modules(void)\n{\n\tstruct mod_unload_taint *mod_taint;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tif (!list_empty(&unloaded_tainted_modules)) {\n\t\tprintk(KERN_DEFAULT \"Unloaded tainted modules:\");\n\t\tlist_for_each_entry_rcu(mod_taint, &unloaded_tainted_modules,\n\t\t\t\t\tlist) {\n\t\t\tsize_t l;\n\n\t\t\tl = module_flags_taint(mod_taint->taints, buf);\n\t\t\tbuf[l++] = '\\0';\n\t\t\tpr_cont(\" %s(%s):%llu\", mod_taint->name, buf,\n\t\t\t\tmod_taint->count);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void *unloaded_tainted_modules_seq_start(struct seq_file *m, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn seq_list_start_rcu(&unloaded_tainted_modules, *pos);\n}\n\nstatic void *unloaded_tainted_modules_seq_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\treturn seq_list_next_rcu(p, &unloaded_tainted_modules, pos);\n}\n\nstatic void unloaded_tainted_modules_seq_stop(struct seq_file *m, void *p)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic int unloaded_tainted_modules_seq_show(struct seq_file *m, void *p)\n{\n\tstruct mod_unload_taint *mod_taint;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\tsize_t l;\n\n\tmod_taint = list_entry(p, struct mod_unload_taint, list);\n\tl = module_flags_taint(mod_taint->taints, buf);\n\tbuf[l++] = '\\0';\n\n\tseq_printf(m, \"%s (%s) %llu\", mod_taint->name, buf, mod_taint->count);\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\nstatic const struct seq_operations unloaded_tainted_modules_seq_ops = {\n\t.start = unloaded_tainted_modules_seq_start,\n\t.next  = unloaded_tainted_modules_seq_next,\n\t.stop  = unloaded_tainted_modules_seq_stop,\n\t.show  = unloaded_tainted_modules_seq_show,\n};\n\nstatic int unloaded_tainted_modules_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &unloaded_tainted_modules_seq_ops);\n}\n\nstatic const struct file_operations unloaded_tainted_modules_fops = {\n\t.open = unloaded_tainted_modules_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic int __init unloaded_tainted_modules_init(void)\n{\n\tdebugfs_create_file(\"unloaded_tainted\", 0444, mod_debugfs_root, NULL,\n\t\t\t    &unloaded_tainted_modules_fops);\n\treturn 0;\n}\nmodule_init(unloaded_tainted_modules_init);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}