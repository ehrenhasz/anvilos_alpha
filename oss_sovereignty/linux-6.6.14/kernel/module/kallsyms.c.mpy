{
  "module_name": "kallsyms.c",
  "hash_id": "c7ab9316ddef48b4f0ba56154203f999de5da0977cd5b1ac5e5c9c8494cd3381",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/kallsyms.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/module_symbol.h>\n#include <linux/kallsyms.h>\n#include <linux/buildid.h>\n#include <linux/bsearch.h>\n#include \"internal.h\"\n\n \nstatic const struct kernel_symbol *lookup_exported_symbol(const char *name,\n\t\t\t\t\t\t\t  const struct kernel_symbol *start,\n\t\t\t\t\t\t\t  const struct kernel_symbol *stop)\n{\n\treturn bsearch(name, start, stop - start,\n\t\t\tsizeof(struct kernel_symbol), cmp_name);\n}\n\nstatic int is_exported(const char *name, unsigned long value,\n\t\t       const struct module *mod)\n{\n\tconst struct kernel_symbol *ks;\n\n\tif (!mod)\n\t\tks = lookup_exported_symbol(name, __start___ksymtab, __stop___ksymtab);\n\telse\n\t\tks = lookup_exported_symbol(name, mod->syms, mod->syms + mod->num_syms);\n\n\treturn ks && kernel_symbol_value(ks) == value;\n}\n\n \nstatic char elf_type(const Elf_Sym *sym, const struct load_info *info)\n{\n\tconst Elf_Shdr *sechdrs = info->sechdrs;\n\n\tif (ELF_ST_BIND(sym->st_info) == STB_WEAK) {\n\t\tif (ELF_ST_TYPE(sym->st_info) == STT_OBJECT)\n\t\t\treturn 'v';\n\t\telse\n\t\t\treturn 'w';\n\t}\n\tif (sym->st_shndx == SHN_UNDEF)\n\t\treturn 'U';\n\tif (sym->st_shndx == SHN_ABS || sym->st_shndx == info->index.pcpu)\n\t\treturn 'a';\n\tif (sym->st_shndx >= SHN_LORESERVE)\n\t\treturn '?';\n\tif (sechdrs[sym->st_shndx].sh_flags & SHF_EXECINSTR)\n\t\treturn 't';\n\tif (sechdrs[sym->st_shndx].sh_flags & SHF_ALLOC &&\n\t    sechdrs[sym->st_shndx].sh_type != SHT_NOBITS) {\n\t\tif (!(sechdrs[sym->st_shndx].sh_flags & SHF_WRITE))\n\t\t\treturn 'r';\n\t\telse if (sechdrs[sym->st_shndx].sh_flags & ARCH_SHF_SMALL)\n\t\t\treturn 'g';\n\t\telse\n\t\t\treturn 'd';\n\t}\n\tif (sechdrs[sym->st_shndx].sh_type == SHT_NOBITS) {\n\t\tif (sechdrs[sym->st_shndx].sh_flags & ARCH_SHF_SMALL)\n\t\t\treturn 's';\n\t\telse\n\t\t\treturn 'b';\n\t}\n\tif (strstarts(info->secstrings + sechdrs[sym->st_shndx].sh_name,\n\t\t      \".debug\")) {\n\t\treturn 'n';\n\t}\n\treturn '?';\n}\n\nstatic bool is_core_symbol(const Elf_Sym *src, const Elf_Shdr *sechdrs,\n\t\t\t   unsigned int shnum, unsigned int pcpundx)\n{\n\tconst Elf_Shdr *sec;\n\tenum mod_mem_type type;\n\n\tif (src->st_shndx == SHN_UNDEF ||\n\t    src->st_shndx >= shnum ||\n\t    !src->st_name)\n\t\treturn false;\n\n#ifdef CONFIG_KALLSYMS_ALL\n\tif (src->st_shndx == pcpundx)\n\t\treturn true;\n#endif\n\n\tsec = sechdrs + src->st_shndx;\n\ttype = sec->sh_entsize >> SH_ENTSIZE_TYPE_SHIFT;\n\tif (!(sec->sh_flags & SHF_ALLOC)\n#ifndef CONFIG_KALLSYMS_ALL\n\t    || !(sec->sh_flags & SHF_EXECINSTR)\n#endif\n\t    || mod_mem_type_is_init(type))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid layout_symtab(struct module *mod, struct load_info *info)\n{\n\tElf_Shdr *symsect = info->sechdrs + info->index.sym;\n\tElf_Shdr *strsect = info->sechdrs + info->index.str;\n\tconst Elf_Sym *src;\n\tunsigned int i, nsrc, ndst, strtab_size = 0;\n\tstruct module_memory *mod_mem_data = &mod->mem[MOD_DATA];\n\tstruct module_memory *mod_mem_init_data = &mod->mem[MOD_INIT_DATA];\n\n\t \n\tsymsect->sh_flags |= SHF_ALLOC;\n\tsymsect->sh_entsize = module_get_offset_and_type(mod, MOD_INIT_DATA,\n\t\t\t\t\t\t\t symsect, info->index.sym);\n\tpr_debug(\"\\t%s\\n\", info->secstrings + symsect->sh_name);\n\n\tsrc = (void *)info->hdr + symsect->sh_offset;\n\tnsrc = symsect->sh_size / sizeof(*src);\n\n\t \n\tfor (ndst = i = 0; i < nsrc; i++) {\n\t\tif (i == 0 || is_livepatch_module(mod) ||\n\t\t    is_core_symbol(src + i, info->sechdrs, info->hdr->e_shnum,\n\t\t\t\t   info->index.pcpu)) {\n\t\t\tstrtab_size += strlen(&info->strtab[src[i].st_name]) + 1;\n\t\t\tndst++;\n\t\t}\n\t}\n\n\t \n\tinfo->symoffs = ALIGN(mod_mem_data->size, symsect->sh_addralign ?: 1);\n\tinfo->stroffs = mod_mem_data->size = info->symoffs + ndst * sizeof(Elf_Sym);\n\tmod_mem_data->size += strtab_size;\n\t \n\tinfo->core_typeoffs = mod_mem_data->size;\n\tmod_mem_data->size += ndst * sizeof(char);\n\n\t \n\tstrsect->sh_flags |= SHF_ALLOC;\n\tstrsect->sh_entsize = module_get_offset_and_type(mod, MOD_INIT_DATA,\n\t\t\t\t\t\t\t strsect, info->index.str);\n\tpr_debug(\"\\t%s\\n\", info->secstrings + strsect->sh_name);\n\n\t \n\tmod_mem_init_data->size = ALIGN(mod_mem_init_data->size,\n\t\t\t\t\t__alignof__(struct mod_kallsyms));\n\tinfo->mod_kallsyms_init_off = mod_mem_init_data->size;\n\n\tmod_mem_init_data->size += sizeof(struct mod_kallsyms);\n\tinfo->init_typeoffs = mod_mem_init_data->size;\n\tmod_mem_init_data->size += nsrc * sizeof(char);\n}\n\n \nvoid add_kallsyms(struct module *mod, const struct load_info *info)\n{\n\tunsigned int i, ndst;\n\tconst Elf_Sym *src;\n\tElf_Sym *dst;\n\tchar *s;\n\tElf_Shdr *symsec = &info->sechdrs[info->index.sym];\n\tunsigned long strtab_size;\n\tvoid *data_base = mod->mem[MOD_DATA].base;\n\tvoid *init_data_base = mod->mem[MOD_INIT_DATA].base;\n\n\t \n\tmod->kallsyms = (void __rcu *)init_data_base +\n\t\tinfo->mod_kallsyms_init_off;\n\n\trcu_read_lock();\n\t \n\trcu_dereference(mod->kallsyms)->symtab = (void *)symsec->sh_addr;\n\trcu_dereference(mod->kallsyms)->num_symtab = symsec->sh_size / sizeof(Elf_Sym);\n\t \n\trcu_dereference(mod->kallsyms)->strtab =\n\t\t(void *)info->sechdrs[info->index.str].sh_addr;\n\trcu_dereference(mod->kallsyms)->typetab = init_data_base + info->init_typeoffs;\n\n\t \n\tmod->core_kallsyms.symtab = dst = data_base + info->symoffs;\n\tmod->core_kallsyms.strtab = s = data_base + info->stroffs;\n\tmod->core_kallsyms.typetab = data_base + info->core_typeoffs;\n\tstrtab_size = info->core_typeoffs - info->stroffs;\n\tsrc = rcu_dereference(mod->kallsyms)->symtab;\n\tfor (ndst = i = 0; i < rcu_dereference(mod->kallsyms)->num_symtab; i++) {\n\t\trcu_dereference(mod->kallsyms)->typetab[i] = elf_type(src + i, info);\n\t\tif (i == 0 || is_livepatch_module(mod) ||\n\t\t    is_core_symbol(src + i, info->sechdrs, info->hdr->e_shnum,\n\t\t\t\t   info->index.pcpu)) {\n\t\t\tssize_t ret;\n\n\t\t\tmod->core_kallsyms.typetab[ndst] =\n\t\t\t    rcu_dereference(mod->kallsyms)->typetab[i];\n\t\t\tdst[ndst] = src[i];\n\t\t\tdst[ndst++].st_name = s - mod->core_kallsyms.strtab;\n\t\t\tret = strscpy(s,\n\t\t\t\t      &rcu_dereference(mod->kallsyms)->strtab[src[i].st_name],\n\t\t\t\t      strtab_size);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\ts += ret + 1;\n\t\t\tstrtab_size -= ret + 1;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tmod->core_kallsyms.num_symtab = ndst;\n}\n\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\nvoid init_build_id(struct module *mod, const struct load_info *info)\n{\n\tconst Elf_Shdr *sechdr;\n\tunsigned int i;\n\n\tfor (i = 0; i < info->hdr->e_shnum; i++) {\n\t\tsechdr = &info->sechdrs[i];\n\t\tif (!sect_empty(sechdr) && sechdr->sh_type == SHT_NOTE &&\n\t\t    !build_id_parse_buf((void *)sechdr->sh_addr, mod->build_id,\n\t\t\t\t\tsechdr->sh_size))\n\t\t\tbreak;\n\t}\n}\n#else\nvoid init_build_id(struct module *mod, const struct load_info *info)\n{\n}\n#endif\n\nstatic const char *kallsyms_symbol_name(struct mod_kallsyms *kallsyms, unsigned int symnum)\n{\n\treturn kallsyms->strtab + kallsyms->symtab[symnum].st_name;\n}\n\n \nstatic const char *find_kallsyms_symbol(struct module *mod,\n\t\t\t\t\tunsigned long addr,\n\t\t\t\t\tunsigned long *size,\n\t\t\t\t\tunsigned long *offset)\n{\n\tunsigned int i, best = 0;\n\tunsigned long nextval, bestval;\n\tstruct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);\n\tstruct module_memory *mod_mem;\n\n\t \n\tif (within_module_init(addr, mod))\n\t\tmod_mem = &mod->mem[MOD_INIT_TEXT];\n\telse\n\t\tmod_mem = &mod->mem[MOD_TEXT];\n\n\tnextval = (unsigned long)mod_mem->base + mod_mem->size;\n\n\tbestval = kallsyms_symbol_value(&kallsyms->symtab[best]);\n\n\t \n\tfor (i = 1; i < kallsyms->num_symtab; i++) {\n\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];\n\t\tunsigned long thisval = kallsyms_symbol_value(sym);\n\n\t\tif (sym->st_shndx == SHN_UNDEF)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (*kallsyms_symbol_name(kallsyms, i) == '\\0' ||\n\t\t    is_mapping_symbol(kallsyms_symbol_name(kallsyms, i)))\n\t\t\tcontinue;\n\n\t\tif (thisval <= addr && thisval > bestval) {\n\t\t\tbest = i;\n\t\t\tbestval = thisval;\n\t\t}\n\t\tif (thisval > addr && thisval < nextval)\n\t\t\tnextval = thisval;\n\t}\n\n\tif (!best)\n\t\treturn NULL;\n\n\tif (size)\n\t\t*size = nextval - bestval;\n\tif (offset)\n\t\t*offset = addr - bestval;\n\n\treturn kallsyms_symbol_name(kallsyms, best);\n}\n\nvoid * __weak dereference_module_function_descriptor(struct module *mod,\n\t\t\t\t\t\t     void *ptr)\n{\n\treturn ptr;\n}\n\n \nconst char *module_address_lookup(unsigned long addr,\n\t\t\t\t  unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    const unsigned char **modbuildid,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tif (modbuildid) {\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\t\t*modbuildid = mod->build_id;\n#else\n\t\t\t*modbuildid = NULL;\n#endif\n\t\t}\n\n\t\tret = find_kallsyms_symbol(mod, addr, size, offset);\n\t}\n\t \n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}\n\nint lookup_module_symbol_name(unsigned long addr, char *symname)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = find_kallsyms_symbol(mod, addr, NULL, NULL);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tstrscpy(symname, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}\n\nint module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *name, char *module_name, int *exported)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct mod_kallsyms *kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);\n\t\tif (symnum < kallsyms->num_symtab) {\n\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[symnum];\n\n\t\t\t*value = kallsyms_symbol_value(sym);\n\t\t\t*type = kallsyms->typetab[symnum];\n\t\t\tstrscpy(name, kallsyms_symbol_name(kallsyms, symnum), KSYM_NAME_LEN);\n\t\t\tstrscpy(module_name, mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = is_exported(name, *value, mod);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tsymnum -= kallsyms->num_symtab;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}\n\n \nstatic unsigned long __find_kallsyms_symbol_value(struct module *mod, const char *name)\n{\n\tunsigned int i;\n\tstruct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);\n\n\tfor (i = 0; i < kallsyms->num_symtab; i++) {\n\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];\n\n\t\tif (strcmp(name, kallsyms_symbol_name(kallsyms, i)) == 0 &&\n\t\t    sym->st_shndx != SHN_UNDEF)\n\t\t\treturn kallsyms_symbol_value(sym);\n\t}\n\treturn 0;\n}\n\nstatic unsigned long __module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\n\tcolon = strnchr(name, MODULE_NAME_LEN, ':');\n\tif (colon) {\n\t\tmod = find_module_all(name, colon - name, false);\n\t\tif (mod)\n\t\t\treturn __find_kallsyms_symbol_value(mod, colon + 1);\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tunsigned long ret;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tret = __find_kallsyms_symbol_value(mod, name);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tunsigned long ret;\n\n\t \n\tpreempt_disable();\n\tret = __module_kallsyms_lookup_name(name);\n\tpreempt_enable();\n\treturn ret;\n}\n\nunsigned long find_kallsyms_symbol_value(struct module *mod, const char *name)\n{\n\tunsigned long ret;\n\n\tpreempt_disable();\n\tret = __find_kallsyms_symbol_value(mod, name);\n\tpreempt_enable();\n\treturn ret;\n}\n\nint module_kallsyms_on_each_symbol(const char *modname,\n\t\t\t\t   int (*fn)(void *, const char *, unsigned long),\n\t\t\t\t   void *data)\n{\n\tstruct module *mod;\n\tunsigned int i;\n\tint ret = 0;\n\n\tmutex_lock(&module_mutex);\n\tlist_for_each_entry(mod, &modules, list) {\n\t\tstruct mod_kallsyms *kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\n\t\tif (modname && strcmp(modname, mod->name))\n\t\t\tcontinue;\n\n\t\t \n\t\tpreempt_disable();\n\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);\n\t\tpreempt_enable();\n\n\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {\n\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[i];\n\n\t\t\tif (sym->st_shndx == SHN_UNDEF)\n\t\t\t\tcontinue;\n\n\t\t\tret = fn(data, kallsyms_symbol_name(kallsyms, i),\n\t\t\t\t kallsyms_symbol_value(sym));\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (modname)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&module_mutex);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}