{
  "module_name": "tree_lookup.c",
  "hash_id": "d1777577628c86dcb45731fd7d0271fe71a78b0b5a1f9b0a44a2d44b40b22804",
  "original_prompt": "Ingested from linux-6.6.14/kernel/module/tree_lookup.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rbtree_latch.h>\n#include \"internal.h\"\n\n \n\nstatic __always_inline unsigned long __mod_tree_val(struct latch_tree_node *n)\n{\n\tstruct module_memory *mod_mem = container_of(n, struct module_memory, mtn.node);\n\n\treturn (unsigned long)mod_mem->base;\n}\n\nstatic __always_inline unsigned long __mod_tree_size(struct latch_tree_node *n)\n{\n\tstruct module_memory *mod_mem = container_of(n, struct module_memory, mtn.node);\n\n\treturn (unsigned long)mod_mem->size;\n}\n\nstatic __always_inline bool\nmod_tree_less(struct latch_tree_node *a, struct latch_tree_node *b)\n{\n\treturn __mod_tree_val(a) < __mod_tree_val(b);\n}\n\nstatic __always_inline int\nmod_tree_comp(void *key, struct latch_tree_node *n)\n{\n\tunsigned long val = (unsigned long)key;\n\tunsigned long start, end;\n\n\tstart = __mod_tree_val(n);\n\tif (val < start)\n\t\treturn -1;\n\n\tend = start + __mod_tree_size(n);\n\tif (val >= end)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct latch_tree_ops mod_tree_ops = {\n\t.less = mod_tree_less,\n\t.comp = mod_tree_comp,\n};\n\nstatic noinline void __mod_tree_insert(struct mod_tree_node *node, struct mod_tree_root *tree)\n{\n\tlatch_tree_insert(&node->node, &tree->root, &mod_tree_ops);\n}\n\nstatic void __mod_tree_remove(struct mod_tree_node *node, struct mod_tree_root *tree)\n{\n\tlatch_tree_erase(&node->node, &tree->root, &mod_tree_ops);\n}\n\n \nvoid mod_tree_insert(struct module *mod)\n{\n\tfor_each_mod_mem_type(type) {\n\t\tmod->mem[type].mtn.mod = mod;\n\t\tif (mod->mem[type].size)\n\t\t\t__mod_tree_insert(&mod->mem[type].mtn, &mod_tree);\n\t}\n}\n\nvoid mod_tree_remove_init(struct module *mod)\n{\n\tfor_class_mod_mem_type(type, init) {\n\t\tif (mod->mem[type].size)\n\t\t\t__mod_tree_remove(&mod->mem[type].mtn, &mod_tree);\n\t}\n}\n\nvoid mod_tree_remove(struct module *mod)\n{\n\tfor_each_mod_mem_type(type) {\n\t\tif (mod->mem[type].size)\n\t\t\t__mod_tree_remove(&mod->mem[type].mtn, &mod_tree);\n\t}\n}\n\nstruct module *mod_find(unsigned long addr, struct mod_tree_root *tree)\n{\n\tstruct latch_tree_node *ltn;\n\n\tltn = latch_tree_find((void *)addr, &tree->root, &mod_tree_ops);\n\tif (!ltn)\n\t\treturn NULL;\n\n\treturn container_of(ltn, struct mod_tree_node, node)->mod;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}