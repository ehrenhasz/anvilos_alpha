{
  "module_name": "auditfilter.c",
  "hash_id": "dec2bfeae319d0c9a829a074aaad3dd64024db87dcfa2e495cf615fff73aaad5",
  "original_prompt": "Ingested from linux-6.6.14/kernel/auditfilter.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/audit.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/netlink.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include \"audit.h\"\n\n \n\n \nstruct list_head audit_filter_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_filter_list[0]),\n\tLIST_HEAD_INIT(audit_filter_list[1]),\n\tLIST_HEAD_INIT(audit_filter_list[2]),\n\tLIST_HEAD_INIT(audit_filter_list[3]),\n\tLIST_HEAD_INIT(audit_filter_list[4]),\n\tLIST_HEAD_INIT(audit_filter_list[5]),\n\tLIST_HEAD_INIT(audit_filter_list[6]),\n\tLIST_HEAD_INIT(audit_filter_list[7]),\n#if AUDIT_NR_FILTERS != 8\n#error Fix audit_filter_list initialiser\n#endif\n};\nstatic struct list_head audit_rules_list[AUDIT_NR_FILTERS] = {\n\tLIST_HEAD_INIT(audit_rules_list[0]),\n\tLIST_HEAD_INIT(audit_rules_list[1]),\n\tLIST_HEAD_INIT(audit_rules_list[2]),\n\tLIST_HEAD_INIT(audit_rules_list[3]),\n\tLIST_HEAD_INIT(audit_rules_list[4]),\n\tLIST_HEAD_INIT(audit_rules_list[5]),\n\tLIST_HEAD_INIT(audit_rules_list[6]),\n\tLIST_HEAD_INIT(audit_rules_list[7]),\n};\n\nDEFINE_MUTEX(audit_filter_mutex);\n\nstatic void audit_free_lsm_field(struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tkfree(f->lsm_str);\n\t\tsecurity_audit_rule_free(f->lsm_rule);\n\t}\n}\n\nstatic inline void audit_free_rule(struct audit_entry *e)\n{\n\tint i;\n\tstruct audit_krule *erule = &e->rule;\n\n\t \n\tif (erule->watch)\n\t\taudit_put_watch(erule->watch);\n\tif (erule->fields)\n\t\tfor (i = 0; i < erule->field_count; i++)\n\t\t\taudit_free_lsm_field(&erule->fields[i]);\n\tkfree(erule->fields);\n\tkfree(erule->filterkey);\n\tkfree(e);\n}\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}\n\n \nstatic inline struct audit_entry *audit_init_entry(u32 field_count)\n{\n\tstruct audit_entry *entry;\n\tstruct audit_field *fields;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (unlikely(!entry))\n\t\treturn NULL;\n\n\tfields = kcalloc(field_count, sizeof(*fields), GFP_KERNEL);\n\tif (unlikely(!fields)) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\tentry->rule.fields = fields;\n\n\treturn entry;\n}\n\n \nchar *audit_unpack_string(void **bufp, size_t *remain, size_t len)\n{\n\tchar *str;\n\n\tif (!*bufp || (len == 0) || (len > *remain))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (len > PATH_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tstr = kmalloc(len + 1, GFP_KERNEL);\n\tif (unlikely(!str))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(str, *bufp, len);\n\tstr[len] = 0;\n\t*bufp += len;\n\t*remain -= len;\n\n\treturn str;\n}\n\n \nstatic inline int audit_to_inode(struct audit_krule *krule,\n\t\t\t\t struct audit_field *f)\n{\n\tif ((krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    krule->inode_f || krule->watch || krule->tree ||\n\t    (f->op != Audit_equal && f->op != Audit_not_equal))\n\t\treturn -EINVAL;\n\n\tkrule->inode_f = f;\n\treturn 0;\n}\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nint __init audit_register_class(int class, unsigned *list)\n{\n\t__u32 *p = kcalloc(AUDIT_BITMASK_SIZE, sizeof(__u32), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\twhile (*list != ~0U) {\n\t\tunsigned n = *list++;\n\t\tif (n >= AUDIT_BITMASK_SIZE * 32 - AUDIT_SYSCALL_CLASSES) {\n\t\t\tkfree(p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp[AUDIT_WORD(n)] |= AUDIT_BIT(n);\n\t}\n\tif (class >= AUDIT_SYSCALL_CLASSES || classes[class]) {\n\t\tkfree(p);\n\t\treturn -EINVAL;\n\t}\n\tclasses[class] = p;\n\treturn 0;\n}\n\nint audit_match_class(int class, unsigned syscall)\n{\n\tif (unlikely(syscall >= AUDIT_BITMASK_SIZE * 32))\n\t\treturn 0;\n\tif (unlikely(class >= AUDIT_SYSCALL_CLASSES || !classes[class]))\n\t\treturn 0;\n\treturn classes[class][AUDIT_WORD(syscall)] & AUDIT_BIT(syscall);\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->rule.arch_f;\n\n\tif (!arch) {\n\t\t \n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask) &&\n\t\t\taudit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\t}\n\n\tswitch (audit_classify_arch(arch->val)) {\n\tcase 0:  \n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL,\n\t\t\t\t\t       entry->rule.mask));\n\tcase 1:  \n\t\treturn (audit_match_class_bits(AUDIT_CLASS_SIGNAL_32,\n\t\t\t\t\t       entry->rule.mask));\n\tdefault:\n\t\treturn 1;\n\t}\n}\n#endif\n\n \nstatic inline struct audit_entry *audit_to_entry_common(struct audit_rule_data *rule)\n{\n\tunsigned listnr;\n\tstruct audit_entry *entry;\n\tint i, err;\n\n\terr = -EINVAL;\n\tlistnr = rule->flags & ~AUDIT_FILTER_PREPEND;\n\tswitch (listnr) {\n\tdefault:\n\t\tgoto exit_err;\n#ifdef CONFIG_AUDITSYSCALL\n\tcase AUDIT_FILTER_ENTRY:\n\t\tpr_err(\"AUDIT_FILTER_ENTRY is deprecated\\n\");\n\t\tgoto exit_err;\n\tcase AUDIT_FILTER_EXIT:\n\tcase AUDIT_FILTER_URING_EXIT:\n\tcase AUDIT_FILTER_TASK:\n#endif\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\t;\n\t}\n\tif (unlikely(rule->action == AUDIT_POSSIBLE)) {\n\t\tpr_err(\"AUDIT_POSSIBLE is deprecated\\n\");\n\t\tgoto exit_err;\n\t}\n\tif (rule->action != AUDIT_NEVER && rule->action != AUDIT_ALWAYS)\n\t\tgoto exit_err;\n\tif (rule->field_count > AUDIT_MAX_FIELDS)\n\t\tgoto exit_err;\n\n\terr = -ENOMEM;\n\tentry = audit_init_entry(rule->field_count);\n\tif (!entry)\n\t\tgoto exit_err;\n\n\tentry->rule.flags = rule->flags & AUDIT_FILTER_PREPEND;\n\tentry->rule.listnr = listnr;\n\tentry->rule.action = rule->action;\n\tentry->rule.field_count = rule->field_count;\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tentry->rule.mask[i] = rule->mask[i];\n\n\tfor (i = 0; i < AUDIT_SYSCALL_CLASSES; i++) {\n\t\tint bit = AUDIT_BITMASK_SIZE * 32 - i - 1;\n\t\t__u32 *p = &entry->rule.mask[AUDIT_WORD(bit)];\n\t\t__u32 *class;\n\n\t\tif (!(*p & AUDIT_BIT(bit)))\n\t\t\tcontinue;\n\t\t*p &= ~AUDIT_BIT(bit);\n\t\tclass = classes[i];\n\t\tif (class) {\n\t\t\tint j;\n\t\t\tfor (j = 0; j < AUDIT_BITMASK_SIZE; j++)\n\t\t\t\tentry->rule.mask[j] |= class[j];\n\t\t}\n\t}\n\n\treturn entry;\n\nexit_err:\n\treturn ERR_PTR(err);\n}\n\nstatic u32 audit_ops[] =\n{\n\t[Audit_equal] = AUDIT_EQUAL,\n\t[Audit_not_equal] = AUDIT_NOT_EQUAL,\n\t[Audit_bitmask] = AUDIT_BIT_MASK,\n\t[Audit_bittest] = AUDIT_BIT_TEST,\n\t[Audit_lt] = AUDIT_LESS_THAN,\n\t[Audit_gt] = AUDIT_GREATER_THAN,\n\t[Audit_le] = AUDIT_LESS_THAN_OR_EQUAL,\n\t[Audit_ge] = AUDIT_GREATER_THAN_OR_EQUAL,\n};\n\nstatic u32 audit_to_op(u32 op)\n{\n\tu32 n;\n\tfor (n = Audit_equal; n < Audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}\n\n \nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch (f->type) {\n\tcase AUDIT_MSGTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_EXCLUDE &&\n\t\t    entry->rule.listnr != AUDIT_FILTER_USER)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FSTYPE:\n\t\tif (entry->rule.listnr != AUDIT_FILTER_FS)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (entry->rule.listnr == AUDIT_FILTER_URING_EXIT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_FS:\n\t\tswitch (f->type) {\n\t\tcase AUDIT_FSTYPE:\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tswitch (f->type) {\n\tcase AUDIT_ARG0:\n\tcase AUDIT_ARG1:\n\tcase AUDIT_ARG2:\n\tcase AUDIT_ARG3:\n\tcase AUDIT_PERS:  \n\tcase AUDIT_DEVMINOR:\n\t\t \n\t\tbreak;\n\tcase AUDIT_UID:\n\tcase AUDIT_EUID:\n\tcase AUDIT_SUID:\n\tcase AUDIT_FSUID:\n\tcase AUDIT_LOGINUID:\n\tcase AUDIT_OBJ_UID:\n\tcase AUDIT_GID:\n\tcase AUDIT_EGID:\n\tcase AUDIT_SGID:\n\tcase AUDIT_FSGID:\n\tcase AUDIT_OBJ_GID:\n\tcase AUDIT_PID:\n\tcase AUDIT_MSGTYPE:\n\tcase AUDIT_PPID:\n\tcase AUDIT_DEVMAJOR:\n\tcase AUDIT_EXIT:\n\tcase AUDIT_SUCCESS:\n\tcase AUDIT_INODE:\n\tcase AUDIT_SESSIONID:\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\tcase AUDIT_SADDR_FAM:\n\t\t \n\t\tif (f->op == Audit_bitmask || f->op == Audit_bittest)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\tcase AUDIT_WATCH:\n\tcase AUDIT_DIR:\n\tcase AUDIT_FILTERKEY:\n\tcase AUDIT_LOGINUID_SET:\n\tcase AUDIT_ARCH:\n\tcase AUDIT_FSTYPE:\n\tcase AUDIT_PERM:\n\tcase AUDIT_FILETYPE:\n\tcase AUDIT_FIELD_COMPARE:\n\tcase AUDIT_EXE:\n\t\t \n\t\tif (f->op != Audit_not_equal && f->op != Audit_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (f->type) {\n\tcase AUDIT_LOGINUID_SET:\n\t\tif ((f->val != 0) && (f->val != 1))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_PERM:\n\t\tif (f->val & ~15)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FILETYPE:\n\t\tif (f->val & ~S_IFMT)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_FIELD_COMPARE:\n\t\tif (f->val > AUDIT_MAX_FIELD_COMPARE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SADDR_FAM:\n\t\tif (f->val >= AF_MAX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct audit_entry *audit_data_to_entry(struct audit_rule_data *data,\n\t\t\t\t\t       size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\tvoid *bufp;\n\tsize_t remain = datasz - sizeof(struct audit_rule_data);\n\tint i;\n\tchar *str;\n\tstruct audit_fsnotify_mark *audit_mark;\n\n\tentry = audit_to_entry_common(data);\n\tif (IS_ERR(entry))\n\t\tgoto exit_nofree;\n\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &entry->rule.fields[i];\n\t\tu32 f_val;\n\n\t\terr = -EINVAL;\n\n\t\tf->op = audit_to_op(data->fieldflags[i]);\n\t\tif (f->op == Audit_bad)\n\t\t\tgoto exit_free;\n\n\t\tf->type = data->fields[i];\n\t\tf_val = data->values[i];\n\n\t\t \n\t\tif ((f->type == AUDIT_LOGINUID) && (f_val == AUDIT_UID_UNSET)) {\n\t\t\tf->type = AUDIT_LOGINUID_SET;\n\t\t\tf_val = 0;\n\t\t\tentry->rule.pflags |= AUDIT_LOGINUID_LEGACY;\n\t\t}\n\n\t\terr = audit_field_valid(entry, f);\n\t\tif (err)\n\t\t\tgoto exit_free;\n\n\t\terr = -EINVAL;\n\t\tswitch (f->type) {\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tf->uid = make_kuid(current_user_ns(), f_val);\n\t\t\tif (!uid_valid(f->uid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tf->gid = make_kgid(current_user_ns(), f_val);\n\t\t\tif (!gid_valid(f->gid))\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tf->val = f_val;\n\t\t\tentry->rule.arch_f = f;\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tf->lsm_str = str;\n\t\t\terr = security_audit_rule_init(f->type, f->op, str,\n\t\t\t\t\t\t       (void **)&f->lsm_rule);\n\t\t\t \n\t\t\tif (err == -EINVAL) {\n\t\t\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\t\t\tstr);\n\t\t\t\terr = 0;\n\t\t\t} else if (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_to_watch(&entry->rule, str, f_val, f->op);\n\t\t\tif (err) {\n\t\t\t\tkfree(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\terr = audit_make_tree(&entry->rule, str, f->op);\n\t\t\tkfree(str);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tf->val = f_val;\n\t\t\terr = audit_to_inode(&entry->rule, f);\n\t\t\tif (err)\n\t\t\t\tgoto exit_free;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tif (entry->rule.filterkey || f_val > AUDIT_MAX_KEY_LEN)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.filterkey = str;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tif (entry->rule.exe || f_val > PATH_MAX)\n\t\t\t\tgoto exit_free;\n\t\t\tstr = audit_unpack_string(&bufp, &remain, f_val);\n\t\t\tif (IS_ERR(str)) {\n\t\t\t\terr = PTR_ERR(str);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\taudit_mark = audit_alloc_mark(&entry->rule, str, f_val);\n\t\t\tif (IS_ERR(audit_mark)) {\n\t\t\t\tkfree(str);\n\t\t\t\terr = PTR_ERR(audit_mark);\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tentry->rule.buflen += f_val;\n\t\t\tentry->rule.exe = audit_mark;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tf->val = f_val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (entry->rule.inode_f && entry->rule.inode_f->op == Audit_not_equal)\n\t\tentry->rule.inode_f = NULL;\n\nexit_nofree:\n\treturn entry;\n\nexit_free:\n\tif (entry->rule.tree)\n\t\taudit_put_tree(entry->rule.tree);  \n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);  \n\taudit_free_rule(entry);\n\treturn ERR_PTR(err);\n}\n\n \nstatic inline size_t audit_pack_string(void **bufp, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tmemcpy(*bufp, str, len);\n\t*bufp += len;\n\n\treturn len;\n}\n\n \nstatic struct audit_rule_data *audit_krule_to_data(struct audit_krule *krule)\n{\n\tstruct audit_rule_data *data;\n\tvoid *bufp;\n\tint i;\n\n\tdata = kmalloc(struct_size(data, buf, krule->buflen), GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn NULL;\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->flags = krule->flags | krule->listnr;\n\tdata->action = krule->action;\n\tdata->field_count = krule->field_count;\n\tbufp = data->buf;\n\tfor (i = 0; i < data->field_count; i++) {\n\t\tstruct audit_field *f = &krule->fields[i];\n\n\t\tdata->fields[i] = f->type;\n\t\tdata->fieldflags[i] = audit_ops[f->op];\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, f->lsm_str);\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_watch_path(krule->watch));\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp,\n\t\t\t\t\t\t  audit_tree_path(krule->tree));\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, krule->filterkey);\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tdata->buflen += data->values[i] =\n\t\t\t\taudit_pack_string(&bufp, audit_mark_path(krule->exe));\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tif (krule->pflags & AUDIT_LOGINUID_LEGACY && !f->val) {\n\t\t\t\tdata->fields[i] = AUDIT_LOGINUID;\n\t\t\t\tdata->values[i] = AUDIT_UID_UNSET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t \n\t\tdefault:\n\t\t\tdata->values[i] = f->val;\n\t\t}\n\t}\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tdata->mask[i] = krule->mask[i];\n\n\treturn data;\n}\n\n \nstatic int audit_compare_rule(struct audit_krule *a, struct audit_krule *b)\n{\n\tint i;\n\n\tif (a->flags != b->flags ||\n\t    a->pflags != b->pflags ||\n\t    a->listnr != b->listnr ||\n\t    a->action != b->action ||\n\t    a->field_count != b->field_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < a->field_count; i++) {\n\t\tif (a->fields[i].type != b->fields[i].type ||\n\t\t    a->fields[i].op != b->fields[i].op)\n\t\t\treturn 1;\n\n\t\tswitch (a->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\tif (strcmp(a->fields[i].lsm_str, b->fields[i].lsm_str))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (strcmp(audit_watch_path(a->watch),\n\t\t\t\t   audit_watch_path(b->watch)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (strcmp(audit_tree_path(a->tree),\n\t\t\t\t   audit_tree_path(b->tree)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t \n\t\t\tif (strcmp(a->filterkey, b->filterkey))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\t \n\t\t\tif (strcmp(audit_mark_path(a->exe),\n\t\t\t\t   audit_mark_path(b->exe)))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\tcase AUDIT_EUID:\n\t\tcase AUDIT_SUID:\n\t\tcase AUDIT_FSUID:\n\t\tcase AUDIT_LOGINUID:\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (!uid_eq(a->fields[i].uid, b->fields[i].uid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\tcase AUDIT_EGID:\n\t\tcase AUDIT_SGID:\n\t\tcase AUDIT_FSGID:\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (!gid_eq(a->fields[i].gid, b->fields[i].gid))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (a->fields[i].val != b->fields[i].val)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tif (a->mask[i] != b->mask[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic inline int audit_dupe_lsm_field(struct audit_field *df,\n\t\t\t\t\t   struct audit_field *sf)\n{\n\tint ret = 0;\n\tchar *lsm_str;\n\n\t \n\tlsm_str = kstrdup(sf->lsm_str, GFP_KERNEL);\n\tif (unlikely(!lsm_str))\n\t\treturn -ENOMEM;\n\tdf->lsm_str = lsm_str;\n\n\t \n\tret = security_audit_rule_init(df->type, df->op, df->lsm_str,\n\t\t\t\t       (void **)&df->lsm_rule);\n\t \n\tif (ret == -EINVAL) {\n\t\tpr_warn(\"audit rule for LSM \\'%s\\' is invalid\\n\",\n\t\t\tdf->lsm_str);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t \n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t \n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}\n\n \nstatic struct audit_entry *audit_find_rule(struct audit_entry *entry,\n\t\t\t\t\t   struct list_head **p)\n{\n\tstruct audit_entry *e, *found = NULL;\n\tstruct list_head *list;\n\tint h;\n\n\tif (entry->rule.inode_f) {\n\t\th = audit_hash_ino(entry->rule.inode_f->val);\n\t\t*p = list = &audit_inode_hash[h];\n\t} else if (entry->rule.watch) {\n\t\t \n\t\tfor (h = 0; h < AUDIT_INODE_BUCKETS; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\t\t\tfound = e;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t}\n\t\tgoto out;\n\t} else {\n\t\t*p = list = &audit_filter_list[entry->rule.listnr];\n\t}\n\n\tlist_for_each_entry(e, list, list)\n\t\tif (!audit_compare_rule(&entry->rule, &e->rule)) {\n\t\t\tfound = e;\n\t\t\tgoto out;\n\t\t}\n\nout:\n\treturn found;\n}\n\nstatic u64 prio_low = ~0ULL/2;\nstatic u64 prio_high = ~0ULL/2 - 1;\n\n \nstatic inline int audit_add_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry *e;\n\tstruct audit_watch *watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint err = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t \n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\terr = -EEXIST;\n\t\t \n\t\tif (tree)\n\t\t\taudit_put_tree(tree);\n\t\treturn err;\n\t}\n\n\tif (watch) {\n\t\t \n\t\terr = audit_add_watch(&entry->rule, &list);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\t \n\t\t\tif (tree)\n\t\t\t\taudit_put_tree(tree);\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (tree) {\n\t\terr = audit_add_tree_rule(&entry->rule);\n\t\tif (err) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tentry->rule.prio = ~0ULL;\n\tif (entry->rule.listnr == AUDIT_FILTER_EXIT ||\n\t    entry->rule.listnr == AUDIT_FILTER_URING_EXIT) {\n\t\tif (entry->rule.flags & AUDIT_FILTER_PREPEND)\n\t\t\tentry->rule.prio = ++prio_high;\n\t\telse\n\t\t\tentry->rule.prio = --prio_low;\n\t}\n\n\tif (entry->rule.flags & AUDIT_FILTER_PREPEND) {\n\t\tlist_add(&entry->rule.list,\n\t\t\t &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_rcu(&entry->list, list);\n\t\tentry->rule.flags &= ~AUDIT_FILTER_PREPEND;\n\t} else {\n\t\tlist_add_tail(&entry->rule.list,\n\t\t\t      &audit_rules_list[entry->rule.listnr]);\n\t\tlist_add_tail_rcu(&entry->list, list);\n\t}\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules++;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals++;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}\n\n \nint audit_del_rule(struct audit_entry *entry)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tstruct list_head *list;\n\tint ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t \n\tswitch (entry->rule.listnr) {\n\tcase AUDIT_FILTER_USER:\n\tcase AUDIT_FILTER_EXCLUDE:\n\tcase AUDIT_FILTER_FS:\n\t\tdont_count = 1;\n\t}\n#endif\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, &list);\n\tif (!e) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (e->rule.watch)\n\t\taudit_remove_watch_rule(&e->rule);\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tif (e->rule.exe)\n\t\taudit_remove_mark_rule(&e->rule);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\n\tlist_del_rcu(&e->list);\n\tlist_del(&e->rule.list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\nout:\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (tree)\n\t\taudit_put_tree(tree);\t \n\n\treturn ret;\n}\n\n \nstatic void audit_list_rules(int seq, struct sk_buff_head *q)\n{\n\tstruct sk_buff *skb;\n\tstruct audit_krule *r;\n\tint i;\n\n\t \n\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 0, 1,\n\t\t\t\t\t       data,\n\t\t\t\t\t       struct_size(data, buf, data->buflen));\n\t\t\tif (skb)\n\t\t\t\tskb_queue_tail(q, skb);\n\t\t\tkfree(data);\n\t\t}\n\t}\n\tskb = audit_make_reply(seq, AUDIT_LIST_RULES, 1, 1, NULL, 0);\n\tif (skb)\n\t\tskb_queue_tail(q, skb);\n}\n\n \nstatic void audit_log_rule_change(char *action, struct audit_krule *rule, int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" op=%s\", action);\n\taudit_log_key(ab, rule->filterkey);\n\taudit_log_format(ab, \" list=%d res=%d\", rule->listnr, res);\n\taudit_log_end(ab);\n}\n\n \nint audit_rule_change(int type, int seq, void *data, size_t datasz)\n{\n\tint err = 0;\n\tstruct audit_entry *entry;\n\n\tswitch (type) {\n\tcase AUDIT_ADD_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_add_rule(entry);\n\t\taudit_log_rule_change(\"add_rule\", &entry->rule, !err);\n\t\tbreak;\n\tcase AUDIT_DEL_RULE:\n\t\tentry = audit_data_to_entry(data, datasz);\n\t\tif (IS_ERR(entry))\n\t\t\treturn PTR_ERR(entry);\n\t\terr = audit_del_rule(entry);\n\t\taudit_log_rule_change(\"remove_rule\", &entry->rule, !err);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (err || type == AUDIT_DEL_RULE) {\n\t\tif (entry->rule.exe)\n\t\t\taudit_remove_mark(entry->rule.exe);\n\t\taudit_free_rule(entry);\n\t}\n\n\treturn err;\n}\n\n \nint audit_list_rules_send(struct sk_buff *request_skb, int seq)\n{\n\tstruct task_struct *tsk;\n\tstruct audit_netlink_list *dest;\n\n\t \n\n\tdest = kmalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest->net = get_net(sock_net(NETLINK_CB(request_skb).sk));\n\tdest->portid = NETLINK_CB(request_skb).portid;\n\tskb_queue_head_init(&dest->q);\n\n\tmutex_lock(&audit_filter_mutex);\n\taudit_list_rules(seq, &dest->q);\n\tmutex_unlock(&audit_filter_mutex);\n\n\ttsk = kthread_run(audit_send_list_thread, dest, \"audit_send_list\");\n\tif (IS_ERR(tsk)) {\n\t\tskb_queue_purge(&dest->q);\n\t\tput_net(dest->net);\n\t\tkfree(dest);\n\t\treturn PTR_ERR(tsk);\n\t}\n\n\treturn 0;\n}\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t \n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t \n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t \n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}\n\n \nint audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}\n\nint audit_filter(int msgtype, unsigned int listtype)\n{\n\tstruct audit_entry *e;\n\tint ret = 1;  \n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[listtype], list) {\n\t\tint i, result = 0;\n\n\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\t\t\tpid_t pid;\n\t\t\tu32 sid;\n\n\t\t\tswitch (f->type) {\n\t\t\tcase AUDIT_PID:\n\t\t\t\tpid = task_pid_nr(current);\n\t\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_UID:\n\t\t\t\tresult = audit_uid_comparator(current_uid(), f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_GID:\n\t\t\t\tresult = audit_gid_comparator(current_gid(), f->op, f->gid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID:\n\t\t\t\tresult = audit_uid_comparator(audit_get_loginuid(current),\n\t\t\t\t\t\t\t      f->op, f->uid);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_LOGINUID_SET:\n\t\t\t\tresult = audit_comparator(audit_loginuid_set(current),\n\t\t\t\t\t\t\t  f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_MSGTYPE:\n\t\t\t\tresult = audit_comparator(msgtype, f->op, f->val);\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_SUBJ_USER:\n\t\t\tcase AUDIT_SUBJ_ROLE:\n\t\t\tcase AUDIT_SUBJ_TYPE:\n\t\t\tcase AUDIT_SUBJ_SEN:\n\t\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t\tif (f->lsm_rule) {\n\t\t\t\t\tsecurity_current_getsecid_subj(&sid);\n\t\t\t\t\tresult = security_audit_rule_match(sid,\n\t\t\t\t\t\t   f->type, f->op, f->lsm_rule);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AUDIT_EXE:\n\t\t\t\tresult = audit_exe_compare(current, e->rule.exe);\n\t\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\t\tresult = !result;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unlock_and_return;\n\t\t\t}\n\t\t\tif (result < 0)  \n\t\t\t\tgoto unlock_and_return;\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result > 0) {\n\t\t\tif (e->rule.action == AUDIT_NEVER || listtype == AUDIT_FILTER_EXCLUDE)\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nunlock_and_return:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int update_lsm_rule(struct audit_krule *r)\n{\n\tstruct audit_entry *entry = container_of(r, struct audit_entry, rule);\n\tstruct audit_entry *nentry;\n\tint err = 0;\n\n\tif (!security_audit_rule_known(r))\n\t\treturn 0;\n\n\tnentry = audit_dupe_rule(r);\n\tif (entry->rule.exe)\n\t\taudit_remove_mark(entry->rule.exe);\n\tif (IS_ERR(nentry)) {\n\t\t \n\t\terr = PTR_ERR(nentry);\n\t\taudit_panic(\"error updating LSM filters\");\n\t\tif (r->watch)\n\t\t\tlist_del(&r->rlist);\n\t\tlist_del_rcu(&entry->list);\n\t\tlist_del(&r->list);\n\t} else {\n\t\tif (r->watch || r->tree)\n\t\t\tlist_replace_init(&r->rlist, &nentry->rule.rlist);\n\t\tlist_replace_rcu(&entry->list, &nentry->list);\n\t\tlist_replace(&r->list, &nentry->rule.list);\n\t}\n\tcall_rcu(&entry->rcu, audit_free_rule_rcu);\n\n\treturn err;\n}\n\n \nint audit_update_lsm_rules(void)\n{\n\tstruct audit_krule *r, *n;\n\tint i, err = 0;\n\n\t \n\tmutex_lock(&audit_filter_mutex);\n\n\tfor (i = 0; i < AUDIT_NR_FILTERS; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}