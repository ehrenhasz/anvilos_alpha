{
  "module_name": "taskstats.c",
  "hash_id": "13b389f69505ba7ad4863c1be1f45b473a666e7f97e51e14a6edbf0e1e49e874",
  "original_prompt": "Ingested from linux-6.6.14/kernel/taskstats.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/taskstats_kern.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/delayacct.h>\n#include <linux/cpumask.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/cgroupstats.h>\n#include <linux/cgroup.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/pid_namespace.h>\n#include <net/genetlink.h>\n#include <linux/atomic.h>\n#include <linux/sched/cputime.h>\n\n \n#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic int family_registered;\nstruct kmem_cache *taskstats_cache;\n\nstatic struct genl_family family;\n\nstatic const struct nla_policy taskstats_cmd_get_policy[] = {\n\t[TASKSTATS_CMD_ATTR_PID]  = { .type = NLA_U32 },\n\t[TASKSTATS_CMD_ATTR_TGID] = { .type = NLA_U32 },\n\t[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK] = { .type = NLA_STRING },\n\t[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK] = { .type = NLA_STRING },};\n\nstatic const struct nla_policy cgroupstats_cmd_get_policy[] = {\n\t[CGROUPSTATS_CMD_ATTR_FD] = { .type = NLA_U32 },\n};\n\nstruct listener {\n\tstruct list_head list;\n\tpid_t pid;\n\tchar valid;\n};\n\nstruct listener_list {\n\tstruct rw_semaphore sem;\n\tstruct list_head list;\n};\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nenum actions {\n\tREGISTER,\n\tDEREGISTER,\n\tCPU_DONT_CARE\n};\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t \n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}\n\n \nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}\n\n \nstatic void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint delcount = 0;\n\n\tgenlmsg_end(skb, reply);\n\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tint rc;\n\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t \n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}\n\nstatic void exe_add_tsk(struct taskstats *stats, struct task_struct *tsk)\n{\n\t \n\tstruct file *exe_file = get_task_exe_file(tsk);\n\n\tif (exe_file) {\n\t\t \n\t\tstats->ac_exe_dev =\n\t\t\thuge_encode_dev(exe_file->f_inode->i_sb->s_dev);\n\t\tstats->ac_exe_inode = exe_file->f_inode->i_ino;\n\t\tfput(exe_file);\n\t} else {\n\t\tstats->ac_exe_dev = 0;\n\t\tstats->ac_exe_inode = 0;\n\t}\n}\n\nstatic void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t \n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t \n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t \n\txacct_add_tsk(stats, tsk);\n\n\t \n\texe_add_tsk(stats, tsk);\n}\n\nstatic int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\ttsk = find_get_task_by_vpid(pid);\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}\n\nstatic int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\tu64 delta, utime, stime;\n\tu64 start_time;\n\n\t \n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tstart_time = ktime_get_ns();\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t \n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\t \n\t\tdelta = start_time - tsk->start_time;\n\t\t \n\t\tdo_div(delta, NSEC_PER_USEC);\n\t\tstats->ac_etime += delta;\n\n\t\ttask_cputime(tsk, &utime, &stime);\n\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);\n\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t \n\treturn rc;\n}\n\nstatic void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t \n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}\n\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s);  \n\t\t}\n\t\treturn 0;\n\t}\n\n\t \ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}\n\nstatic int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strscpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start_noflag(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}\n\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct fd f;\n\n\tna = info->attrs[CGROUPSTATS_CMD_ATTR_FD];\n\tif (!na)\n\t\treturn -EINVAL;\n\n\tfd = nla_get_u32(info->attrs[CGROUPSTATS_CMD_ATTR_FD]);\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct cgroupstats));\n\n\trc = prepare_reply(info, CGROUPSTATS_CMD_NEW, &rep_skb,\n\t\t\t\tsize);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, CGROUPSTATS_TYPE_CGROUP_STATS,\n\t\t\t\tsizeof(struct cgroupstats));\n\tif (na == NULL) {\n\t\tnlmsg_free(rep_skb);\n\t\trc = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, f.file->f_path.dentry);\n\tif (rc < 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfdput(f);\n\treturn rc;\n}\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}\n\nstatic int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}\n\nstatic int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])\n\t\treturn cmd_attr_register_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])\n\t\treturn cmd_attr_deregister_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])\n\t\treturn cmd_attr_pid(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])\n\t\treturn cmd_attr_tgid(info);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats_new, *stats;\n\n\t \n\tstats = smp_load_acquire(&sig->stats);\n\tif (stats || thread_group_empty(tsk))\n\t\treturn stats;\n\n\t \n\tstats_new = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tstats = sig->stats;\n\tif (!stats) {\n\t\t \n\t\tsmp_store_release(&sig->stats, stats_new);\n\t\tstats = stats_new;\n\t\tstats_new = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats_new)\n\t\tkmem_cache_free(taskstats_cache, stats_new);\n\n\treturn stats;\n}\n\n \nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t \n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t \n\t\tsize = 2 * size;\n\t\t \n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\tif (group_dead)\n\t\tstats->ac_flag |= AGROUP;\n\n\t \n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}\n\nstatic const struct genl_ops taskstats_ops[] = {\n\t{\n\t\t.cmd\t\t= TASKSTATS_CMD_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t\t= taskstats_user_cmd,\n\t\t.policy\t\t= taskstats_cmd_get_policy,\n\t\t.maxattr\t= ARRAY_SIZE(taskstats_cmd_get_policy) - 1,\n\t\t.flags\t\t= GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd\t\t= CGROUPSTATS_CMD_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t\t= cgroupstats_user_cmd,\n\t\t.policy\t\t= cgroupstats_cmd_get_policy,\n\t\t.maxattr\t= ARRAY_SIZE(cgroupstats_cmd_get_policy) - 1,\n\t},\n};\n\nstatic struct genl_family family __ro_after_init = {\n\t.name\t\t= TASKSTATS_GENL_NAME,\n\t.version\t= TASKSTATS_GENL_VERSION,\n\t.module\t\t= THIS_MODULE,\n\t.ops\t\t= taskstats_ops,\n\t.n_ops\t\t= ARRAY_SIZE(taskstats_ops),\n\t.resv_start_op\t= CGROUPSTATS_CMD_GET + 1,\n\t.netnsok\t= true,\n};\n\n \nvoid __init taskstats_init_early(void)\n{\n\tunsigned int i;\n\n\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\n\tfor_each_possible_cpu(i) {\n\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\n\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));\n\t}\n}\n\nstatic int __init taskstats_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&family);\n\tif (rc)\n\t\treturn rc;\n\n\tfamily_registered = 1;\n\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);\n\treturn 0;\n}\n\n \nlate_initcall(taskstats_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}