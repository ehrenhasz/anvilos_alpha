{
  "module_name": "debug_core.c",
  "hash_id": "55787f2fcd3b525ba826dd411e1a04013c9006fbc71343dc6a2253174e20d91e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/debug_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"KGDB: \" fmt\n\n#include <linux/pid_namespace.h>\n#include <linux/clocksource.h>\n#include <linux/serial_core.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/console.h>\n#include <linux/threads.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/sysrq.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/nmi.h>\n#include <linux/pid.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/rcupdate.h>\n#include <linux/irq.h>\n#include <linux/security.h>\n\n#include <asm/cacheflush.h>\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n\n#include \"debug_core.h\"\n\nstatic int kgdb_break_asap;\n\nstruct debuggerinfo_struct kgdb_info[NR_CPUS];\n\n \nint\t\t\t\tkgdb_connected;\nEXPORT_SYMBOL_GPL(kgdb_connected);\n\n \nint\t\t\tkgdb_io_module_registered;\n\n \nstatic int\t\t\texception_level;\n\nstruct kgdb_io\t\t*dbg_io_ops;\nstatic DEFINE_SPINLOCK(kgdb_registration_lock);\n\n \nstatic int kgdbreboot;\n \nstatic int kgdb_con_registered;\n \nstatic int kgdb_use_con;\n \nbool dbg_is_early = true;\n \nint dbg_switch_cpu;\n\n \nint dbg_kdb_mode = 1;\n\nmodule_param(kgdb_use_con, int, 0644);\nmodule_param(kgdbreboot, int, 0644);\n\n \nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\n \natomic_t\t\t\tkgdb_active = ATOMIC_INIT(-1);\nEXPORT_SYMBOL_GPL(kgdb_active);\nstatic DEFINE_RAW_SPINLOCK(dbg_master_lock);\nstatic DEFINE_RAW_SPINLOCK(dbg_slave_lock);\n\n \nstatic atomic_t\t\t\tmasters_in_kgdb;\nstatic atomic_t\t\t\tslaves_in_kgdb;\natomic_t\t\t\tkgdb_setting_breakpoint;\n\nstruct task_struct\t\t*kgdb_usethread;\nstruct task_struct\t\t*kgdb_contthread;\n\nint\t\t\t\tkgdb_single_step;\nstatic pid_t\t\t\tkgdb_sstep_pid;\n\n \natomic_t\t\t\tkgdb_cpu_doing_single_step = ATOMIC_INIT(-1);\n\n \nstatic int kgdb_do_roundup = 1;\n\nstatic int __init opt_nokgdbroundup(char *str)\n{\n\tkgdb_do_roundup = 0;\n\n\treturn 0;\n}\n\nearly_param(\"nokgdbroundup\", opt_nokgdbroundup);\n\n \n\n \nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\n{\n\tint err;\n\n\terr = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,\n\t\t\t\tBREAK_INSTR_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t arch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\n\treturn err;\n}\nNOKPROBE_SYMBOL(kgdb_arch_set_breakpoint);\n\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\n{\n\treturn copy_to_kernel_nofault((char *)bpt->bpt_addr,\n\t\t\t\t  (char *)bpt->saved_instr, BREAK_INSTR_SIZE);\n}\nNOKPROBE_SYMBOL(kgdb_arch_remove_breakpoint);\n\nint __weak kgdb_validate_break_address(unsigned long addr)\n{\n\tstruct kgdb_bkpt tmp;\n\tint err;\n\n\tif (kgdb_within_blocklist(addr))\n\t\treturn -EINVAL;\n\n\t \n\ttmp.bpt_addr = addr;\n\terr = kgdb_arch_set_breakpoint(&tmp);\n\tif (err)\n\t\treturn err;\n\terr = kgdb_arch_remove_breakpoint(&tmp);\n\tif (err)\n\t\tpr_err(\"Critical breakpoint error, kernel memory destroyed at: %lx\\n\",\n\t\t       addr);\n\treturn err;\n}\n\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\n{\n\treturn instruction_pointer(regs);\n}\nNOKPROBE_SYMBOL(kgdb_arch_pc);\n\nint __weak kgdb_arch_init(void)\n{\n\treturn 0;\n}\n\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\n{\n\treturn 0;\n}\nNOKPROBE_SYMBOL(kgdb_skipexception);\n\n#ifdef CONFIG_SMP\n\n \n\nvoid __weak kgdb_call_nmi_hook(void *ignored)\n{\n\t \n\tkgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());\n}\nNOKPROBE_SYMBOL(kgdb_call_nmi_hook);\n\nstatic DEFINE_PER_CPU(call_single_data_t, kgdb_roundup_csd) =\n\tCSD_INIT(kgdb_call_nmi_hook, NULL);\n\nvoid __weak kgdb_roundup_cpus(void)\n{\n\tcall_single_data_t *csd;\n\tint this_cpu = raw_smp_processor_id();\n\tint cpu;\n\tint ret;\n\n\tfor_each_online_cpu(cpu) {\n\t\t \n\t\tif (cpu == this_cpu)\n\t\t\tcontinue;\n\n\t\tcsd = &per_cpu(kgdb_roundup_csd, cpu);\n\n\t\t \n\t\tif (kgdb_info[cpu].rounding_up)\n\t\t\tcontinue;\n\t\tkgdb_info[cpu].rounding_up = true;\n\n\t\tret = smp_call_function_single_async(cpu, csd);\n\t\tif (ret)\n\t\t\tkgdb_info[cpu].rounding_up = false;\n\t}\n}\nNOKPROBE_SYMBOL(kgdb_roundup_cpus);\n\n#endif\n\n \nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\n{\n\tif (!CACHE_FLUSH_IS_SAFE)\n\t\treturn;\n\n\t \n\tflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\n}\nNOKPROBE_SYMBOL(kgdb_flush_swbreak_addr);\n\n \nint dbg_activate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_SET)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"BP install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_ACTIVE;\n\t}\n\treturn ret;\n}\nNOKPROBE_SYMBOL(dbg_activate_sw_breakpoints);\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"BP remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = BP_SET;\n\t}\n\treturn ret;\n}\nNOKPROBE_SYMBOL(dbg_deactivate_sw_breakpoints);\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nint kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_REMOVED) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint kgdb_has_hit_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_ACTIVE &&\n\t\t    kgdb_break[i].bpt_addr == addr)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t \n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t \n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}\n\nvoid kgdb_free_init_mem(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (init_section_contains((void *)kgdb_break[i].bpt_addr, 0))\n\t\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n}\n\n#ifdef CONFIG_KGDB_KDB\nvoid kdb_dump_stack_on_cpu(int cpu)\n{\n\tif (cpu == raw_smp_processor_id() || !IS_ENABLED(CONFIG_SMP)) {\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tif (!(kgdb_info[cpu].exception_state & DCPU_IS_SLAVE)) {\n\t\tkdb_printf(\"ERROR: Task on cpu %d didn't stop in the debugger\\n\",\n\t\t\t   cpu);\n\t\treturn;\n\t}\n\n\t \n\tkgdb_info[cpu].exception_state |= DCPU_WANT_BT;\n\twhile (kgdb_info[cpu].exception_state & DCPU_WANT_BT)\n\t\tcpu_relax();\n}\n#endif\n\n \nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}\nNOKPROBE_SYMBOL(kgdb_io_ready);\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t \n\texception_level++;\n\taddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tdbg_deactivate_sw_breakpoints();\n\n\t \n\tif (dbg_remove_sw_break(addr) == 0) {\n\t\texception_level = 0;\n\t\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\t\tdbg_activate_sw_breakpoints();\n\t\tpr_crit(\"re-enter error: breakpoint removed %lx\\n\", addr);\n\t\tWARN_ON_ONCE(1);\n\n\t\treturn 1;\n\t}\n\tdbg_remove_all_break();\n\tkgdb_skipexception(ks->ex_vector, ks->linux_regs);\n\n\tif (exception_level > 1) {\n\t\tdump_stack();\n\t\tkgdb_io_module_registered = false;\n\t\tpanic(\"Recursive entry to debugger\");\n\t}\n\n\tpr_crit(\"re-enter exception: ALL breakpoints killed\\n\");\n#ifdef CONFIG_KGDB_KDB\n\t \n\treturn 0;\n#endif\n\tdump_stack();\n\tpanic(\"Recursive entry to debugger\");\n\n\treturn 1;\n}\nNOKPROBE_SYMBOL(kgdb_reenter_check);\n\nstatic void dbg_touch_watchdogs(void)\n{\n\ttouch_softlockup_watchdog_sync();\n\tclocksource_touch_watchdog();\n\trcu_cpu_stall_reset();\n}\nNOKPROBE_SYMBOL(dbg_touch_watchdogs);\n\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t \n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t \n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t \n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t \n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t \n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore;  \n\t}\n\n\t \n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t \n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t \n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t \n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t \n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t \n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t \n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (security_locked_down(LOCKDOWN_DBG_WRITE_KERNEL)) {\n\t\t\t\tif (IS_ENABLED(CONFIG_KGDB_KDB)) {\n\t\t\t\t\t \n\t\t\t\t\tdbg_kdb_mode = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t \n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t \n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t \n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}\nNOKPROBE_SYMBOL(kgdb_cpu_enter);\n\n \nint\nkgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)\n{\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\tint ret = 0;\n\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(0);\n\t \n\tif (signo != SIGTRAP && panic_timeout)\n\t\treturn 1;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= raw_smp_processor_id();\n\tks->ex_vector\t\t= evector;\n\tks->signo\t\t= signo;\n\tks->err_code\t\t= ecode;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_reenter_check(ks))\n\t\tgoto out;  \n\tif (kgdb_info[ks->cpu].enter_kgdb != 0)\n\t\tgoto out;\n\n\tret = kgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\nout:\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tarch_kgdb_ops.enable_nmi(1);\n\treturn ret;\n}\nNOKPROBE_SYMBOL(kgdb_handle_exception);\n\n \nstatic int module_event(struct notifier_block *self, unsigned long val,\n\tvoid *data)\n{\n\treturn 0;\n}\n\nstatic struct notifier_block dbg_module_load_nb = {\n\t.notifier_call\t= module_event,\n};\n\nint kgdb_nmicallback(int cpu, void *regs)\n{\n#ifdef CONFIG_SMP\n\tstruct kgdb_state kgdb_var;\n\tstruct kgdb_state *ks = &kgdb_var;\n\n\tkgdb_info[cpu].rounding_up = false;\n\n\tmemset(ks, 0, sizeof(struct kgdb_state));\n\tks->cpu\t\t\t= cpu;\n\tks->linux_regs\t\t= regs;\n\n\tif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\n\t\t\traw_spin_is_locked(&dbg_master_lock)) {\n\t\tkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}\nNOKPROBE_SYMBOL(kgdb_nmicallback);\n\nint kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\n\t\t\t\t\t\t\tatomic_t *send_ready)\n{\n#ifdef CONFIG_SMP\n\tif (!kgdb_io_ready(0) || !send_ready)\n\t\treturn 1;\n\n\tif (kgdb_info[cpu].enter_kgdb == 0) {\n\t\tstruct kgdb_state kgdb_var;\n\t\tstruct kgdb_state *ks = &kgdb_var;\n\n\t\tmemset(ks, 0, sizeof(struct kgdb_state));\n\t\tks->cpu\t\t\t= cpu;\n\t\tks->ex_vector\t\t= trapnr;\n\t\tks->signo\t\t= SIGTRAP;\n\t\tks->err_code\t\t= err_code;\n\t\tks->linux_regs\t\t= regs;\n\t\tks->send_ready\t\t= send_ready;\n\t\tkgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\n\t\treturn 0;\n\t}\n#endif\n\treturn 1;\n}\nNOKPROBE_SYMBOL(kgdb_nmicallin);\n\nstatic void kgdb_console_write(struct console *co, const char *s,\n   unsigned count)\n{\n\tunsigned long flags;\n\n\t \n\tif (!kgdb_connected || atomic_read(&kgdb_active) != -1 || dbg_kdb_mode)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tgdbstub_msg_write(s, count);\n\tlocal_irq_restore(flags);\n}\n\nstatic struct console kgdbcons = {\n\t.name\t\t= \"kgdb\",\n\t.write\t\t= kgdb_console_write,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ENABLED,\n\t.index\t\t= -1,\n};\n\nstatic int __init opt_kgdb_con(char *str)\n{\n\tkgdb_use_con = 1;\n\n\tif (kgdb_io_module_registered && !kgdb_con_registered) {\n\t\tregister_console(&kgdbcons);\n\t\tkgdb_con_registered = 1;\n\t}\n\n\treturn 0;\n}\n\nearly_param(\"kgdbcon\", opt_kgdb_con);\n\n#ifdef CONFIG_MAGIC_SYSRQ\nstatic void sysrq_handle_dbg(u8 key)\n{\n\tif (!dbg_io_ops) {\n\t\tpr_crit(\"ERROR: No KGDB I/O module available\\n\");\n\t\treturn;\n\t}\n\tif (!kgdb_connected) {\n#ifdef CONFIG_KGDB_KDB\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"KGDB or $3#33 for KDB\\n\");\n#else\n\t\tpr_crit(\"Entering KGDB\\n\");\n#endif\n\t}\n\n\tkgdb_breakpoint();\n}\n\nstatic const struct sysrq_key_op sysrq_dbg_op = {\n\t.handler\t= sysrq_handle_dbg,\n\t.help_msg\t= \"debug(g)\",\n\t.action_msg\t= \"DEBUG\",\n};\n#endif\n\nvoid kgdb_panic(const char *msg)\n{\n\tif (!kgdb_io_module_registered)\n\t\treturn;\n\n\t \n\tif (panic_timeout)\n\t\treturn;\n\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tif (dbg_kdb_mode)\n\t\tkdb_printf(\"PANIC: %s\\n\", msg);\n\n\tkgdb_breakpoint();\n}\n\nstatic void kgdb_initial_breakpoint(void)\n{\n\tkgdb_break_asap = 0;\n\n\tpr_crit(\"Waiting for connection from remote gdb...\\n\");\n\tkgdb_breakpoint();\n}\n\nvoid __weak kgdb_arch_late(void)\n{\n}\n\nvoid __init dbg_late_init(void)\n{\n\tdbg_is_early = false;\n\tif (kgdb_io_module_registered)\n\t\tkgdb_arch_late();\n\tkdb_init(KDB_INIT_FULL);\n\n\tif (kgdb_io_module_registered && kgdb_break_asap)\n\t\tkgdb_initial_breakpoint();\n}\n\nstatic int\ndbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)\n{\n\t \n\tswitch (kgdbreboot) {\n\tcase 1:\n\t\tkgdb_breakpoint();\n\t\tgoto done;\n\tcase -1:\n\t\tgoto done;\n\t}\n\tif (!dbg_kdb_mode)\n\t\tgdbstub_exit(code);\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block dbg_reboot_notifier = {\n\t.notifier_call\t\t= dbg_notify_reboot,\n\t.next\t\t\t= NULL,\n\t.priority\t\t= INT_MAX,\n};\n\nstatic void kgdb_register_callbacks(void)\n{\n\tif (!kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 1;\n\t\tkgdb_arch_init();\n\t\tif (!dbg_is_early)\n\t\t\tkgdb_arch_late();\n\t\tregister_module_notifier(&dbg_module_load_nb);\n\t\tregister_reboot_notifier(&dbg_reboot_notifier);\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_use_con && !kgdb_con_registered) {\n\t\t\tregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 1;\n\t\t}\n\t}\n}\n\nstatic void kgdb_unregister_callbacks(void)\n{\n\t \n\tif (kgdb_io_module_registered) {\n\t\tkgdb_io_module_registered = 0;\n\t\tunregister_reboot_notifier(&dbg_reboot_notifier);\n\t\tunregister_module_notifier(&dbg_module_load_nb);\n\t\tkgdb_arch_exit();\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\tunregister_sysrq_key('g', &sysrq_dbg_op);\n#endif\n\t\tif (kgdb_con_registered) {\n\t\t\tunregister_console(&kgdbcons);\n\t\t\tkgdb_con_registered = 0;\n\t\t}\n\t}\n}\n\n \nint kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)\n{\n\tstruct kgdb_io *old_dbg_io_ops;\n\tint err;\n\n\tspin_lock(&kgdb_registration_lock);\n\n\told_dbg_io_ops = dbg_io_ops;\n\tif (old_dbg_io_ops) {\n\t\tif (!old_dbg_io_ops->deinit) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\n\t\t\tpr_err(\"KGDB I/O driver %s can't replace %s.\\n\",\n\t\t\t\tnew_dbg_io_ops->name, old_dbg_io_ops->name);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tpr_info(\"Replacing I/O driver %s with %s\\n\",\n\t\t\told_dbg_io_ops->name, new_dbg_io_ops->name);\n\t}\n\n\tif (new_dbg_io_ops->init) {\n\t\terr = new_dbg_io_ops->init();\n\t\tif (err) {\n\t\t\tspin_unlock(&kgdb_registration_lock);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdbg_io_ops = new_dbg_io_ops;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tif (old_dbg_io_ops) {\n\t\told_dbg_io_ops->deinit();\n\t\treturn 0;\n\t}\n\n\tpr_info(\"Registered I/O driver %s\\n\", new_dbg_io_ops->name);\n\n\t \n\tkgdb_register_callbacks();\n\n\tif (kgdb_break_asap &&\n\t    (!dbg_is_early || IS_ENABLED(CONFIG_ARCH_HAS_EARLY_DEBUG)))\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kgdb_register_io_module);\n\n \nvoid kgdb_unregister_io_module(struct kgdb_io *old_dbg_io_ops)\n{\n\tBUG_ON(kgdb_connected);\n\n\t \n\tkgdb_unregister_callbacks();\n\n\tspin_lock(&kgdb_registration_lock);\n\n\tWARN_ON_ONCE(dbg_io_ops != old_dbg_io_ops);\n\tdbg_io_ops = NULL;\n\n\tspin_unlock(&kgdb_registration_lock);\n\n\tif (old_dbg_io_ops->deinit)\n\t\told_dbg_io_ops->deinit();\n\n\tpr_info(\"Unregistered I/O driver %s, debugger disabled\\n\",\n\t\told_dbg_io_ops->name);\n}\nEXPORT_SYMBOL_GPL(kgdb_unregister_io_module);\n\nint dbg_io_get_char(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\tif (ret == NO_POLL_CHAR)\n\t\treturn -1;\n\tif (!dbg_kdb_mode)\n\t\treturn ret;\n\tif (ret == 127)\n\t\treturn 8;\n\treturn ret;\n}\n\n \nnoinline void kgdb_breakpoint(void)\n{\n\tatomic_inc(&kgdb_setting_breakpoint);\n\twmb();  \n\tarch_kgdb_breakpoint();\n\twmb();  \n\tatomic_dec(&kgdb_setting_breakpoint);\n}\nEXPORT_SYMBOL_GPL(kgdb_breakpoint);\n\nstatic int __init opt_kgdb_wait(char *str)\n{\n\tkgdb_break_asap = 1;\n\n\tkdb_init(KDB_INIT_EARLY);\n\tif (kgdb_io_module_registered &&\n\t    IS_ENABLED(CONFIG_ARCH_HAS_EARLY_DEBUG))\n\t\tkgdb_initial_breakpoint();\n\n\treturn 0;\n}\n\nearly_param(\"kgdbwait\", opt_kgdb_wait);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}