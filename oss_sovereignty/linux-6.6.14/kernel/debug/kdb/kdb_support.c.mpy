{
  "module_name": "kdb_support.c",
  "hash_id": "e8b67c729fb4e859745a9a374dcdf6745a14bd5df88791a62bb0cd1861d052dd",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/kdb/kdb_support.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/kallsyms.h>\n#include <linux/stddef.h>\n#include <linux/vmalloc.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/hardirq.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/kdb.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include \"kdb_private.h\"\n\n \nint kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tkdb_dbg_printf(AR, \"symname=%s, symtab=%px\\n\", symname, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tkdb_dbg_printf(AR, \"returns 1, symtab->sym_start=0x%lx\\n\",\n\t\t\t       symtab->sym_start);\n\t\treturn 1;\n\t}\n\tkdb_dbg_printf(AR, \"returns 0\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL(kdbgetsymval);\n\n \nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}\n\nstatic char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];\n\n \nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrscpy(ks_namebuf, name, sizeof(ks_namebuf));\n\t\t\t \n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}\n\n \nint kallsyms_symbol_next(char *prefix_name, int flag, int buf_size)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (!strncmp(name, prefix_name, prefix_len))\n\t\t\treturn strscpy(prefix_name, name, buf_size);\n\t}\n\treturn 0;\n}\n\n \nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}\n\n \nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}\n\n \nint kdb_getarea_size(void *res, unsigned long addr, size_t size)\n{\n\tint ret = copy_from_kernel_nofault((char *)res, (char *)addr, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_func_printf(\"Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}\n\n \nint kdb_putarea_size(unsigned long addr, void *res, size_t size)\n{\n\tint ret = copy_to_kernel_nofault((char *)addr, (char *)res, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_func_printf(\"Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}\n\n \nstatic int kdb_getphys(void *res, unsigned long addr, size_t size)\n{\n\tunsigned long pfn;\n\tvoid *vaddr;\n\tstruct page *page;\n\n\tpfn = (addr >> PAGE_SHIFT);\n\tif (!pfn_valid(pfn))\n\t\treturn 1;\n\tpage = pfn_to_page(pfn);\n\tvaddr = kmap_atomic(page);\n\tmemcpy(res, vaddr + (addr & (PAGE_SIZE - 1)), size);\n\tkunmap_atomic(vaddr);\n\n\treturn 0;\n}\n\n \nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t \n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}\n\n \nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t \n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}\n\n \nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}\n\n\n\n \nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t \n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t \n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t \n\t}\n\treturn state;\n}\n\n \nbool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t \n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t \n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}\n\n \n\nstatic int kdb_flags_stack[4], kdb_flags_index;\n\nvoid kdb_save_flags(void)\n{\n\tBUG_ON(kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack));\n\tkdb_flags_stack[kdb_flags_index++] = kdb_flags;\n}\n\nvoid kdb_restore_flags(void)\n{\n\tBUG_ON(kdb_flags_index <= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}