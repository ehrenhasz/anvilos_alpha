{
  "module_name": "kdb_bp.c",
  "hash_id": "ecf769034ce28627bc0f14a86a6f5ea81789578c142978aad22e15b20cac3cb9",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/kdb/kdb_bp.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include \"kdb_private.h\"\n\n \nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nstatic void kdb_setsinglestep(struct pt_regs *regs)\n{\n\tKDB_STATE_SET(DOING_SS);\n}\n\nstatic char *kdb_rwtypes[] = {\n\t\"Instruction(i)\",\n\t\"Instruction(Register)\",\n\t\"Data Write\",\n\t\"I/O\",\n\t\"Data Access\"\n};\n\nstatic char *kdb_bptype(kdb_bp_t *bp)\n{\n\tif (bp->bp_type < 0 || bp->bp_type > 4)\n\t\treturn \"\";\n\n\treturn kdb_rwtypes[bp->bp_type];\n}\n\nstatic int kdb_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)\n{\n\tint nextarg = *nextargp;\n\tint diag;\n\n\tbp->bph_length = 1;\n\tif ((argc + 1) != nextarg) {\n\t\tif (strncasecmp(argv[nextarg], \"datar\", sizeof(\"datar\")) == 0)\n\t\t\tbp->bp_type = BP_ACCESS_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"dataw\", sizeof(\"dataw\")) == 0)\n\t\t\tbp->bp_type = BP_WRITE_WATCHPOINT;\n\t\telse if (strncasecmp(argv[nextarg], \"inst\", sizeof(\"inst\")) == 0)\n\t\t\tbp->bp_type = BP_HARDWARE_BREAKPOINT;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tbp->bph_length = 1;\n\n\t\tnextarg++;\n\n\t\tif ((argc + 1) != nextarg) {\n\t\t\tunsigned long len;\n\n\t\t\tdiag = kdbgetularg((char *)argv[nextarg],\n\t\t\t\t\t   &len);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\n\n\t\t\tif (len > 8)\n\t\t\t\treturn KDB_BADLENGTH;\n\n\t\t\tbp->bph_length = len;\n\t\t\tnextarg++;\n\t\t}\n\n\t\tif ((argc + 1) != nextarg)\n\t\t\treturn KDB_ARGCOUNT;\n\t}\n\n\t*nextargp = nextarg;\n\treturn 0;\n}\n\nstatic int _kdb_bp_remove(kdb_bp_t *bp)\n{\n\tint ret = 1;\n\tif (!bp->bp_installed)\n\t\treturn ret;\n\tif (!bp->bp_type)\n\t\tret = dbg_remove_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.remove_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0)\n\t\tbp->bp_installed = 0;\n\treturn ret;\n}\n\nstatic void kdb_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"regs->ip = 0x%lx\\n\", instruction_pointer(regs));\n\n\t \n\tkdb_setsinglestep(regs);\n\n\t \n\tbp->bp_delay = 0;\n\tbp->bp_delayed = 1;\n}\n\nstatic int _kdb_bp_install(struct pt_regs *regs, kdb_bp_t *bp)\n{\n\tint ret;\n\t \n\n\tif (KDB_DEBUG(BP))\n\t\tkdb_printf(\"%s: bp_installed %d\\n\",\n\t\t\t   __func__, bp->bp_installed);\n\tif (!KDB_STATE(SSBPT))\n\t\tbp->bp_delay = 0;\n\tif (bp->bp_installed)\n\t\treturn 1;\n\tif (bp->bp_delay || (bp->bp_delayed && KDB_STATE(DOING_SS))) {\n\t\tif (KDB_DEBUG(BP))\n\t\t\tkdb_printf(\"%s: delayed bp\\n\", __func__);\n\t\tkdb_handle_bp(regs, bp);\n\t\treturn 0;\n\t}\n\tif (!bp->bp_type)\n\t\tret = dbg_set_sw_break(bp->bp_addr);\n\telse\n\t\tret = arch_kgdb_ops.set_hw_breakpoint(bp->bp_addr,\n\t\t\t bp->bph_length,\n\t\t\t bp->bp_type);\n\tif (ret == 0) {\n\t\tbp->bp_installed = 1;\n\t} else {\n\t\tkdb_printf(\"%s: failed to set breakpoint at 0x%lx\\n\",\n\t\t\t   __func__, bp->bp_addr);\n\t\tif (!bp->bp_type) {\n\t\t\tkdb_printf(\"Software breakpoints are unavailable.\\n\"\n\t\t\t\t   \"  Boot the kernel with rodata=off\\n\"\n\t\t\t\t   \"  OR use hw breaks: help bph\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nvoid kdb_bp_install(struct pt_regs *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < KDB_MAXBPT; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_install(regs, bp);\n\t}\n}\n\n \nvoid kdb_bp_remove(void)\n{\n\tint i;\n\n\tfor (i = KDB_MAXBPT - 1; i >= 0; i--) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (KDB_DEBUG(BP)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->bp_enabled);\n\t\t}\n\t\tif (bp->bp_enabled)\n\t\t\t_kdb_bp_remove(bp);\n\t}\n}\n\n\n \n\nstatic void kdb_printbp(kdb_bp_t *bp, int i)\n{\n\tkdb_printf(\"%s \", kdb_bptype(bp));\n\tkdb_printf(\"BP #%d at \", i);\n\tkdb_symbol_print(bp->bp_addr, NULL, KDB_SP_DEFAULT);\n\n\tif (bp->bp_enabled)\n\t\tkdb_printf(\"\\n    is enabled \");\n\telse\n\t\tkdb_printf(\"\\n    is disabled\");\n\n\tkdb_printf(\"  addr at %016lx, hardtype=%d installed=%d\\n\",\n\t\t   bp->bp_addr, bp->bp_type, bp->bp_installed);\n\n\tkdb_printf(\"\\n\");\n}\n\n \n\nstatic int kdb_bp(int argc, const char **argv)\n{\n\tint i, bpno;\n\tkdb_bp_t *bp, *bp_check;\n\tint diag;\n\tchar *symname = NULL;\n\tlong offset = 0ul;\n\tint nextarg;\n\tkdb_bp_t template = {0};\n\n\tif (argc == 0) {\n\t\t \n\t\tfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT;\n\t\t     bpno++, bp++) {\n\t\t\tif (bp->bp_free)\n\t\t\t\tcontinue;\n\t\t\tkdb_printbp(bp, bpno);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &template.bp_addr,\n\t\t\t     &offset, &symname);\n\tif (diag)\n\t\treturn diag;\n\tif (!template.bp_addr)\n\t\treturn KDB_BADINT;\n\n\t \n\tdiag = kgdb_validate_break_address(template.bp_addr);\n\tif (diag)\n\t\treturn diag;\n\n\t \n\tfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT; bpno++, bp++) {\n\t\tif (bp->bp_free)\n\t\t\tbreak;\n\t}\n\n\tif (bpno == KDB_MAXBPT)\n\t\treturn KDB_TOOMANYBPT;\n\n\tif (strcmp(argv[0], \"bph\") == 0) {\n\t\ttemplate.bp_type = BP_HARDWARE_BREAKPOINT;\n\t\tdiag = kdb_parsebp(argc, argv, &nextarg, &template);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else {\n\t\ttemplate.bp_type = BP_BREAKPOINT;\n\t}\n\n\t \n\tfor (i = 0, bp_check = kdb_breakpoints; i < KDB_MAXBPT;\n\t     i++, bp_check++) {\n\t\tif (!bp_check->bp_free &&\n\t\t    bp_check->bp_addr == template.bp_addr) {\n\t\t\tkdb_printf(\"You already have a breakpoint at \"\n\t\t\t\t   kdb_bfd_vma_fmt0 \"\\n\", template.bp_addr);\n\t\t\treturn KDB_DUPBPT;\n\t\t}\n\t}\n\n\ttemplate.bp_enabled = 1;\n\n\t \n\t*bp = template;\n\tbp->bp_free = 0;\n\n\tkdb_printbp(bp, bpno);\n\n\treturn 0;\n}\n\n \nstatic int kdb_bc(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tkdb_bp_t *bp = NULL;\n\tint lowbp = KDB_MAXBPT;\n\tint highbp = 0;\n\tint done = 0;\n\tint i;\n\tint diag = 0;\n\n\tint cmd;\t\t\t \n#define KDBCMD_BC\t0\n#define KDBCMD_BE\t1\n#define KDBCMD_BD\t2\n\n\tif (strcmp(argv[0], \"be\") == 0)\n\t\tcmd = KDBCMD_BE;\n\telse if (strcmp(argv[0], \"bd\") == 0)\n\t\tcmd = KDBCMD_BD;\n\telse\n\t\tcmd = KDBCMD_BC;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (strcmp(argv[1], \"*\") == 0) {\n\t\tlowbp = 0;\n\t\thighbp = KDB_MAXBPT;\n\t} else {\n\t\tdiag = kdbgetularg(argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\n\t\t \n\t\tif (addr < KDB_MAXBPT) {\n\t\t\tlowbp = highbp = addr;\n\t\t\thighbp++;\n\t\t} else {\n\t\t\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT;\n\t\t\t    i++, bp++) {\n\t\t\t\tif (bp->bp_addr == addr) {\n\t\t\t\t\tlowbp = highbp = i;\n\t\t\t\t\thighbp++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (bp = &kdb_breakpoints[lowbp], i = lowbp;\n\t    i < highbp;\n\t    i++, bp++) {\n\t\tif (bp->bp_free)\n\t\t\tcontinue;\n\n\t\tdone++;\n\n\t\tswitch (cmd) {\n\t\tcase KDBCMD_BC:\n\t\t\tbp->bp_enabled = 0;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" cleared\\n\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tbp->bp_addr = 0;\n\t\t\tbp->bp_free = 1;\n\n\t\t\tbreak;\n\t\tcase KDBCMD_BE:\n\t\t\tbp->bp_enabled = 1;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" enabled\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tbreak;\n\t\tcase KDBCMD_BD:\n\t\t\tif (!bp->bp_enabled)\n\t\t\t\tbreak;\n\n\t\t\tbp->bp_enabled = 0;\n\n\t\t\tkdb_printf(\"Breakpoint %d at \"\n\t\t\t\t   kdb_bfd_vma_fmt \" disabled\\n\",\n\t\t\t\t   i, bp->bp_addr);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (bp->bp_delay && (cmd == KDBCMD_BC || cmd == KDBCMD_BD)) {\n\t\t\tbp->bp_delay = 0;\n\t\t\tKDB_STATE_CLEAR(SSBPT);\n\t\t}\n\t}\n\n\treturn (!done) ? KDB_BPTNOTFOUND : 0;\n}\n\n \n\nstatic int kdb_ss(int argc, const char **argv)\n{\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\t \n\tKDB_STATE_SET(DOING_SS);\n\treturn KDB_CMD_SS;\n}\n\nstatic kdbtab_t bptab[] = {\n\t{\t.name = \"bp\",\n\t\t.func = kdb_bp,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Set/Display breakpoints\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"bl\",\n\t\t.func = kdb_bp,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Display breakpoints\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"bc\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Clear Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"be\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Enable Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"bd\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Disable Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"ss\",\n\t\t.func = kdb_ss,\n\t\t.usage = \"\",\n\t\t.help = \"Single Step\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n};\n\nstatic kdbtab_t bphcmd = {\n\t.name = \"bph\",\n\t.func = kdb_bp,\n\t.usage = \"[<vaddr>]\",\n\t.help = \"[datar [length]|dataw [length]]   Set hw brk\",\n\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n};\n\n \n\nvoid __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t \n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_table(bptab, ARRAY_SIZE(bptab));\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_table(&bphcmd, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}