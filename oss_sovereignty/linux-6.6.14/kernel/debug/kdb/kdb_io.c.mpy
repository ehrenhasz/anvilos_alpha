{
  "module_name": "kdb_io.c",
  "hash_id": "65aa64770d036cebc308c6b298092c70f185f79f750e56fda71476c0b982fd3a",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/kdb/kdb_io.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/kdev_t.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/kallsyms.h>\n#include \"kdb_private.h\"\n\n#define CMD_BUFLEN 256\nchar kdb_prompt_str[CMD_BUFLEN];\n\nint kdb_trap_printk;\nint kdb_printf_cpu = -1;\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\tkdb_printf(\"%s\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int kdb_handle_escape(char *buf, size_t sz)\n{\n\tchar *lastkey = buf + sz - 1;\n\n\tswitch (sz) {\n\tcase 1:\n\t\tif (*lastkey == '\\e')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 2:  \n\t\tif (*lastkey == '[')\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tswitch (*lastkey) {\n\t\tcase 'A':  \n\t\t\treturn 16;\n\t\tcase 'B':  \n\t\t\treturn 14;\n\t\tcase 'C':  \n\t\t\treturn 6;\n\t\tcase 'D':  \n\t\t\treturn 2;\n\t\tcase '1':  \n\t\tcase '3':\n\t\tcase '4':\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tif (*lastkey == '~') {\n\t\t\tswitch (buf[2]) {\n\t\t\tcase '1':  \n\t\t\t\treturn 1;\n\t\t\tcase '3':  \n\t\t\t\treturn 4;\n\t\t\tcase '4':  \n\t\t\t\treturn 5;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n \nchar kdb_getchar(void)\n{\n#define ESCAPE_UDELAY 1000\n#define ESCAPE_DELAY (2*1000000/ESCAPE_UDELAY)  \n\tchar buf[4];\t \n\tchar *pbuf = buf;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_prev = NULL;\n\tint key;\n\tstatic bool last_char_was_cr;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == NULL) {\n\t\t\t \n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(ESCAPE_UDELAY);\n\t\t\t\tif (--escape_delay == 0)\n\t\t\t\t\treturn '\\e';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (last_char_was_cr && key == '\\n') {\n\t\t\tlast_char_was_cr = false;\n\t\t\tcontinue;\n\t\t}\n\t\tlast_char_was_cr = (key == '\\r');\n\n\t\t \n\t\tif (f_prev != f) {\n\t\t\tf_prev = f;\n\t\t\tpbuf = buf;\n\t\t\tescape_delay = ESCAPE_DELAY;\n\t\t}\n\n\t\t*pbuf++ = key;\n\t\tkey = kdb_handle_escape(buf, pbuf - buf);\n\t\tif (key < 0)  \n\t\t\treturn buf[pbuf - buf == 2 ? 1 : 0];\n\t\tif (key > 0)\n\t\t\treturn key;\n\t}\n\n\tunreachable();\n}\n\n \n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t \n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[CMD_BUFLEN];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key, buf_size, ret;\n\n\n\tdiag = kdbgetintenv(\"DTABCOUNT\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"%s\", buffer);\npoll_again:\n\tkey = kdb_getchar();\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8:  \n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"\\b%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 10:  \n\tcase 13:  \n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\tKDB_STATE_SET(KGDB_TRANS);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t}\n\t\tkdb_printf(\"\\n\");\n\t\treturn buffer;\n\tcase 4:  \n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"%s \\r\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1:  \n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5:  \n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2:  \n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"\\b\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14:  \n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6:  \n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"%c\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16:  \n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"\\r%s\\r\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9:  \n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tbuf_size = sizeof(tmpbuffer) - (p_tmp - tmpbuffer);\n\t\tcount = kallsyms_symbol_complete(p_tmp, buf_size);\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"\\n%d symbols are found.\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\" But only first %d symbols will\"\n\t\t\t\t\t   \" be printed.\\nYou can change the\"\n\t\t\t\t\t   \" environment variable DTABCOUNT.\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = kallsyms_symbol_next(p_tmp, i, buf_size);\n\t\t\t\tif (WARN_ON(!ret))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ret != -E2BIG)\n\t\t\t\t\tkdb_printf(\"%s \", p_tmp);\n\t\t\t\telse\n\t\t\t\t\tkdb_printf(\"%s... \", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"...\");\n\t\t\tkdb_printf(\"\\n\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"%s\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"%s\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1;  \n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"%s\\r\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"%s\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t \n\t\t\t\tif (!KDB_STATE(KGDB_TRANS)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"%c\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"$?#3f\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"$qSupported\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"kgdb\");\n\t\t\t\tKDB_STATE_SET(DOING_KGDB);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}\n\n \n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t \n\treturn kdb_read(buffer, bufsize);\n}\n\n \n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}\n\n \n\nstatic char kdb_buffer[256];\t \nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\n \nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t \n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void kdb_msg_write(const char *msg, int msg_len)\n{\n\tstruct console *c;\n\tconst char *cp;\n\tint cookie;\n\tint len;\n\n\tif (msg_len == 0)\n\t\treturn;\n\n\tcp = msg;\n\tlen = msg_len;\n\n\twhile (len--) {\n\t\tdbg_io_ops->write_char(*cp);\n\t\tcp++;\n\t}\n\n\t \n\tcookie = console_srcu_read_lock();\n\tfor_each_console_srcu(c) {\n\t\tif (!(console_srcu_read_flags(c) & CON_ENABLED))\n\t\t\tcontinue;\n\t\tif (c == dbg_io_ops->cons)\n\t\t\tcontinue;\n\t\tif (!c->write)\n\t\t\tcontinue;\n\t\t \n\t\t++oops_in_progress;\n\t\tc->write(c, msg, msg_len);\n\t\t--oops_in_progress;\n\t\ttouch_nmi_watchdog();\n\t}\n\tconsole_srcu_read_unlock(cookie);\n}\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tint this_cpu, old_cpu;\n\tchar *cp, *cp2, *cphold = NULL, replaced_byte = ' ';\n\tchar *moreprompt = \"more> \";\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\tfor (;;) {\n\t\told_cpu = cmpxchg(&kdb_printf_cpu, -1, this_cpu);\n\t\tif (old_cpu == -1 || old_cpu == this_cpu)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tdiag = kdbgetintenv(\"LINES\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"COLUMNS\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t \n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t \n\n\t \n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t \n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t \n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t \n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t \n\t\tcp++;\t \t      \n\t\treplaced_byte = *cp;  \n\t\tcphold = cp;\n\t\t*cp = '\\0';\t      \n\n\t\t \n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t \n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= KDB_GREPPING_FLAG_SEARCH) {\n\t\t\t \n\t\t\t*cphold = replaced_byte;\n\t\t\tkdb_grepping_flag = 0;\n\t\t}\n\t\t \n\t}\nkdb_printit:\n\n\t \n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_headers(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected)\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\telse\n\t\tkdb_msg_write(cp, retlen - (cp - kdb_buffer));\n\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n\t\tif (printk_get_level(kdb_buffer) || src == KDB_MSGSRC_PRINTK)\n\t\t\tprintk(\"%s\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"%s\", kdb_buffer);\n\t}\n\n\tif (KDB_STATE(PAGER)) {\n\t\t \n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t \n\tif (kdb_nextline >= linecount) {\n\t\tchar ch;\n\n\t\t \n\t\tkdb_nextline = 1;\t \n\n\t\t \n\t\tmoreprompt = kdbgetenv(\"MOREPROMPT\");\n\t\tif (moreprompt == NULL)\n\t\t\tmoreprompt = \"more> \";\n\n\t\tkdb_input_flush();\n\t\tkdb_msg_write(moreprompt, strlen(moreprompt));\n\n\t\tif (logging)\n\t\t\tprintk(\"%s\", moreprompt);\n\n\t\tch = kdb_getchar();\n\t\tkdb_nextline = 1;\t \n\n\t\t \n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((ch == 'q') || (ch == 'Q')) {\n\t\t\t \n\t\t\tKDB_FLAG_SET(CMD_INTERRUPT);  \n\t\t\tKDB_STATE_CLEAR(PAGER);\n\t\t\t \n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t} else if (ch == ' ') {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1;  \n\t\t} else if (ch == '\\n' || ch == '\\r') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tsuspend_grep = 1;  \n\t\t} else if (ch == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"\\r\");\n\t\t\tkdb_getstr(kdb_grep_string, KDB_GREP_STRLEN,\n\t\t\t\t   kdbgetenv(\"SEARCHPROMPT\") ?: \"search> \");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += KDB_GREPPING_FLAG_SEARCH;\n\t\t\tsuspend_grep = 1;  \n\t\t} else if (ch) {\n\t\t\t \n\t\t\tsuspend_grep = 1;  \n\t\t\tif (ch != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"\\nOnly 'q', 'Q' or '/' are processed at \"\n\t\t\t\t    \"more prompt, input ignored\\n\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"\\n'/' cannot be used during | \"\n\t\t\t\t\t   \"grep filtering, input ignored\\n\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t \n\t\t\tsuspend_grep = 1;  \n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t \n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0;  \n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\t \n\tsmp_store_release(&kdb_printf_cpu, old_cpu);\n\tlocal_irq_restore(flags);\n\treturn retlen;\n}\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kdb_printf);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}