{
  "module_name": "kdb_bt.c",
  "hash_id": "342268294268229966d13b689a033974375cb5951ad375410509367cecffce8e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/kdb/kdb_bt.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/debug.h>\n#include <linux/kdb.h>\n#include <linux/nmi.h>\n#include \"kdb_private.h\"\n\n\nstatic void kdb_show_stack(struct task_struct *p, void *addr)\n{\n\tkdb_trap_printk++;\n\n\tif (!addr && kdb_task_has_cpu(p)) {\n\t\tint old_lvl = console_loglevel;\n\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\t\tkdb_dump_stack_on_cpu(kdb_process_cpu(p));\n\t\tconsole_loglevel = old_lvl;\n\t} else {\n\t\tshow_stack(p, addr, KERN_EMERG);\n\t}\n\n\tkdb_trap_printk--;\n}\n\n \n\nstatic int\nkdb_bt1(struct task_struct *p, const char *mask, bool btaprompt)\n{\n\tchar ch;\n\n\tif (kdb_getarea(ch, (unsigned long)p) ||\n\t    kdb_getarea(ch, (unsigned long)(p+1)-1))\n\t\treturn KDB_BADADDR;\n\tif (!kdb_task_state(p, mask))\n\t\treturn 0;\n\tkdb_printf(\"Stack traceback for pid %d\\n\", p->pid);\n\tkdb_ps1(p);\n\tkdb_show_stack(p, NULL);\n\tif (btaprompt) {\n\t\tkdb_printf(\"Enter <q> to end, <cr> or <space> to continue:\");\n\t\tdo {\n\t\t\tch = kdb_getchar();\n\t\t} while (!strchr(\"\\r\\n q\", ch));\n\t\tkdb_printf(\"\\n\");\n\n\t\t \n\t\tkdb_nextline = 1;\n\n\t\tif (ch == 'q')\n\t\t\treturn 1;\n\t}\n\ttouch_nmi_watchdog();\n\treturn 0;\n}\n\nstatic void\nkdb_bt_cpu(unsigned long cpu)\n{\n\tstruct task_struct *kdb_tsk;\n\n\tif (cpu >= num_possible_cpus() || !cpu_online(cpu)) {\n\t\tkdb_printf(\"WARNING: no process for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\t \n\tkdb_tsk = KDB_TSK(cpu);\n\tif (!kdb_tsk) {\n\t\tkdb_printf(\"WARNING: no task for cpu %ld\\n\", cpu);\n\t\treturn;\n\t}\n\n\tkdb_bt1(kdb_tsk, \"A\", false);\n}\n\nint\nkdb_bt(int argc, const char **argv)\n{\n\tint diag;\n\tint btaprompt = 1;\n\tint nextarg;\n\tunsigned long addr;\n\tlong offset;\n\n\t \n\tkdbgetintenv(\"BTAPROMPT\", &btaprompt);\n\n\tif (strcmp(argv[0], \"bta\") == 0) {\n\t\tstruct task_struct *g, *p;\n\t\tunsigned long cpu;\n\t\tconst char *mask = argc ? argv[1] : kdbgetenv(\"PS\");\n\n\t\tif (argc == 0)\n\t\t\tkdb_ps_suppressed();\n\t\t \n\t\tfor_each_online_cpu(cpu) {\n\t\t\tp = kdb_curr_task(cpu);\n\t\t\tif (kdb_bt1(p, mask, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\t\treturn 0;\n\t\t\tif (task_curr(p))\n\t\t\t\tcontinue;\n\t\t\tif (kdb_bt1(p, mask, btaprompt))\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (strcmp(argv[0], \"btp\") == 0) {\n\t\tstruct task_struct *p;\n\t\tunsigned long pid;\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &pid);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\tif (p)\n\t\t\treturn kdb_bt1(p, \"A\", false);\n\t\tkdb_printf(\"No process with pid == %ld found\\n\", pid);\n\t\treturn 0;\n\t} else if (strcmp(argv[0], \"btt\") == 0) {\n\t\tif (argc != 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tdiag = kdbgetularg((char *)argv[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\treturn kdb_bt1((struct task_struct *)addr, \"A\", false);\n\t} else if (strcmp(argv[0], \"btc\") == 0) {\n\t\tunsigned long cpu = ~0;\n\t\tif (argc > 1)\n\t\t\treturn KDB_ARGCOUNT;\n\t\tif (argc == 1) {\n\t\t\tdiag = kdbgetularg((char *)argv[1], &cpu);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t\tif (cpu != ~0) {\n\t\t\tkdb_bt_cpu(cpu);\n\t\t} else {\n\t\t\t \n\t\t\targv = NULL;\n\t\t\tkdb_printf(\"btc: cpu status: \");\n\t\t\tkdb_parse(\"cpu\\n\");\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tkdb_bt_cpu(cpu);\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\tif (argc) {\n\t\t\tnextarg = 1;\n\t\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t\t     &offset, NULL);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t\tkdb_show_stack(kdb_current_task, (void *)addr);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn kdb_bt1(kdb_current_task, \"A\", false);\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}