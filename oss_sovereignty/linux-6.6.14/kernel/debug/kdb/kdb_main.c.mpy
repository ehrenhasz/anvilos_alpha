{
  "module_name": "kdb_main.c",
  "hash_id": "1bc471188b8462e6d20c9945ff8be4bd455ad47a62e26589548b91f15d13e159",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/kdb/kdb_main.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/kmsg_dump.h>\n#include <linux/reboot.h>\n#include <linux/sched.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sysrq.h>\n#include <linux/smp.h>\n#include <linux/utsname.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/notifier.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/time.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/cpu.h>\n#include <linux/kdebug.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include \"kdb_private.h\"\n\n#undef\tMODULE_PARAM_PREFIX\n#define\tMODULE_PARAM_PREFIX \"kdb.\"\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nmodule_param_named(cmd_enable, kdb_cmd_enabled, int, 0600);\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nEXPORT_SYMBOL(kdb_grepping_flag);\nint kdb_grep_leading;\nint kdb_grep_trailing;\n\n \nunsigned int kdb_flags;\n\n \nint kdb_initial_cpu = -1;\t \nint kdb_nextline = 1;\nint kdb_state;\t\t\t \n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nconst char *kdb_diemsg;\nstatic int kdb_go_count;\n#ifdef CONFIG_KDB_CONTINUE_CATASTROPHIC\nstatic unsigned int kdb_continue_catastrophic =\n\tCONFIG_KDB_CONTINUE_CATASTROPHIC;\n#else\nstatic unsigned int kdb_continue_catastrophic;\n#endif\n\n \nstatic LIST_HEAD(kdb_cmds_head);\n\ntypedef struct _kdbmsg {\n\tint\tkm_diag;\t \n\tchar\t*km_msg;\t \n} kdbmsg_t;\n\n#define KDBMSG(msgnum, text) \\\n\t{ KDB_##msgnum, text }\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};\n#undef KDBMSG\n\nstatic const int __nkdb_err = ARRAY_SIZE(kdbmsgs);\n\n\n \n\nstatic char *__env[31] = {\n#if defined(CONFIG_SMP)\n\t\"PROMPT=[%d]kdb> \",\n#else\n\t\"PROMPT=kdb> \",\n#endif\n\t\"MOREPROMPT=more> \",\n\t\"RADIX=16\",\n\t\"MDCOUNT=8\",\t\t \n\tKDB_PLATFORM_ENV,\n\t\"DTABCOUNT=30\",\n\t\"NOSECT=1\",\n};\n\nstatic const int __nenv = ARRAY_SIZE(__env);\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}\n\n \nstatic void kdb_check_for_lockdown(void)\n{\n\tconst int write_flags = KDB_ENABLE_MEM_WRITE |\n\t\t\t\tKDB_ENABLE_REG_WRITE |\n\t\t\t\tKDB_ENABLE_FLOW_CTRL;\n\tconst int read_flags = KDB_ENABLE_MEM_READ |\n\t\t\t       KDB_ENABLE_REG_READ;\n\n\tbool need_to_lockdown_write = false;\n\tbool need_to_lockdown_read = false;\n\n\tif (kdb_cmd_enabled & (KDB_ENABLE_ALL | write_flags))\n\t\tneed_to_lockdown_write =\n\t\t\tsecurity_locked_down(LOCKDOWN_DBG_WRITE_KERNEL);\n\n\tif (kdb_cmd_enabled & (KDB_ENABLE_ALL | read_flags))\n\t\tneed_to_lockdown_read =\n\t\t\tsecurity_locked_down(LOCKDOWN_DBG_READ_KERNEL);\n\n\t \n\tif (need_to_lockdown_write || need_to_lockdown_read)\n\t\tif (kdb_cmd_enabled & KDB_ENABLE_ALL)\n\t\t\tkdb_cmd_enabled = KDB_ENABLE_MASK & ~KDB_ENABLE_ALL;\n\n\tif (need_to_lockdown_write)\n\t\tkdb_cmd_enabled &= ~write_flags;\n\n\tif (need_to_lockdown_read)\n\t\tkdb_cmd_enabled &= ~read_flags;\n}\n\n \nstatic bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t \n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t \n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}\n\n \nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}\n\n \nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}\n\n \nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}\n\n \nstatic int kdb_setenv(const char *var, const char *val)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\tvarlen = strlen(var);\n\tvallen = strlen(val);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", var, val);\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], var, varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}\n\n \nstatic void kdb_printenv(void)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n}\n\n \nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t \n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}\n\n \nint kdb_set(int argc, const char **argv)\n{\n\t \n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t \n\tif (strcmp(argv[1], \"PROMPT\") == 0 &&\n\t    !kdb_check_flags(KDB_ENABLE_MEM_READ, kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t \n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags & ~KDB_DEBUG(MASK))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn kdb_setenv(argv[1], argv[2]);\n}\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}\n\n \nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t \n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t \n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t \n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t \n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t \n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t \n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t \n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}\n\n \nstruct kdb_macro {\n\tkdbtab_t cmd;\t\t\t \n\tstruct list_head statements;\t \n};\n\nstruct kdb_macro_statement {\n\tchar *statement;\t\t \n\tstruct list_head list_node;\t \n};\n\nstatic struct kdb_macro *kdb_macro;\nstatic bool defcmd_in_progress;\n\n \nstatic int kdb_exec_defcmd(int argc, const char **argv);\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}\n\nstatic int kdb_defcmd(int argc, const char **argv)\n{\n\tkdbtab_t *mp;\n\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"kdb: nested defcmd detected, assuming missing \"\n\t\t\t   \"endefcmd\\n\");\n\t\tkdb_defcmd2(\"endefcmd\", \"endefcmd\");\n\t}\n\tif (argc == 0) {\n\t\tkdbtab_t *kp;\n\t\tstruct kdb_macro *kmp;\n\t\tstruct kdb_macro_statement *kms;\n\n\t\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\t\tif (kp->func == kdb_exec_defcmd) {\n\t\t\t\tkdb_printf(\"defcmd %s \\\"%s\\\" \\\"%s\\\"\\n\",\n\t\t\t\t\t   kp->name, kp->usage, kp->help);\n\t\t\t\tkmp = container_of(kp, struct kdb_macro, cmd);\n\t\t\t\tlist_for_each_entry(kms, &kmp->statements,\n\t\t\t\t\t\t    list_node)\n\t\t\t\t\tkdb_printf(\"%s\", kms->statement);\n\t\t\t\tkdb_printf(\"endefcmd\\n\");\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tif (argc != 3)\n\t\treturn KDB_ARGCOUNT;\n\tif (in_dbg_master()) {\n\t\tkdb_printf(\"Command only available during kdb_init()\\n\");\n\t\treturn KDB_NOTIMP;\n\t}\n\tkdb_macro = kzalloc(sizeof(*kdb_macro), GFP_KDB);\n\tif (!kdb_macro)\n\t\tgoto fail_defcmd;\n\n\tmp = &kdb_macro->cmd;\n\tmp->func = kdb_exec_defcmd;\n\tmp->minlen = 0;\n\tmp->flags = KDB_ENABLE_ALWAYS_SAFE;\n\tmp->name = kdb_strdup(argv[1], GFP_KDB);\n\tif (!mp->name)\n\t\tgoto fail_name;\n\tmp->usage = kdb_strdup(argv[2], GFP_KDB);\n\tif (!mp->usage)\n\t\tgoto fail_usage;\n\tmp->help = kdb_strdup(argv[3], GFP_KDB);\n\tif (!mp->help)\n\t\tgoto fail_help;\n\tif (mp->usage[0] == '\"') {\n\t\tstrcpy(mp->usage, argv[2]+1);\n\t\tmp->usage[strlen(mp->usage)-1] = '\\0';\n\t}\n\tif (mp->help[0] == '\"') {\n\t\tstrcpy(mp->help, argv[3]+1);\n\t\tmp->help[strlen(mp->help)-1] = '\\0';\n\t}\n\n\tINIT_LIST_HEAD(&kdb_macro->statements);\n\tdefcmd_in_progress = true;\n\treturn 0;\nfail_help:\n\tkfree(mp->usage);\nfail_usage:\n\tkfree(mp->name);\nfail_name:\n\tkfree(kdb_macro);\nfail_defcmd:\n\tkdb_printf(\"Could not allocate new kdb_macro entry for %s\\n\", argv[1]);\n\treturn KDB_NOTIMP;\n}\n\n \nstatic int kdb_exec_defcmd(int argc, const char **argv)\n{\n\tint ret;\n\tkdbtab_t *kp;\n\tstruct kdb_macro *kmp;\n\tstruct kdb_macro_statement *kms;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(kp, &kdb_cmds_head, list_node)) {\n\t\tkdb_printf(\"kdb_exec_defcmd: could not find commands for %s\\n\",\n\t\t\t   argv[0]);\n\t\treturn KDB_NOTIMP;\n\t}\n\tkmp = container_of(kp, struct kdb_macro, cmd);\n\tlist_for_each_entry(kms, &kmp->statements, list_node) {\n\t\t \n\t\targv = NULL;\n\t\tkdb_printf(\"[%s]kdb> %s\\n\", kmp->cmd.name, kms->statement);\n\t\tret = kdb_parse(kms->statement);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \n#define KDB_CMD_HISTORY_COUNT\t32\n#define CMD_BUFLEN\t\t200\t \nstatic unsigned int cmd_head, cmd_tail;\nstatic unsigned int cmdptr;\nstatic char cmd_hist[KDB_CMD_HISTORY_COUNT][CMD_BUFLEN];\nstatic char cmd_cur[CMD_BUFLEN];\n\n \nstatic void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t \n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (!str_has_prefix(cp, \"grep \")) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0';  \n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t \n\tif (*cp == '\"') {\n\t\t \n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0';  \n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}\n\n \n\n#define MAXARGC\t20\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t \n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t \n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t \n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t \n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t \n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t \n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t \n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t \n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t \n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}\n\n\nstatic int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t \n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr + KDB_CMD_HISTORY_COUNT - 1) %\n\t\t\t\t KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t \n\treturn 0;\n}\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}\n\nstatic void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}\n\nstatic void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}\n\n \nstatic int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\n\tkdb_check_for_lockdown();\n\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t \n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%px, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t \n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%px, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t \n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t \n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t \n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t \n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t \n\t}\n\n\twhile (1) {\n\t\t \n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t \n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n\t\t \n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n\n\t\t \n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}\n\n\n \nvoid kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}\n\n \nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t \n\twhile (1) {\n\t\t \n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t \n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t \n\t\t \n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t \n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}\n\n \nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}\n\n \nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t \n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}\n\nstatic int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = KDB_WORD_SIZE, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\tint raw = 0;\n\n\tkdbgetintenv(\"MDCOUNT\", &mdcount);\n\tkdbgetintenv(\"RADIX\", &radix);\n\tkdbgetintenv(\"BYTESPERWORD\", &bytesperword);\n\n\t \n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc == 2 || (argc == 0 && last_addr != 0))\n\t\t\tvalid = raw = 1;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn KDB_ARGCOUNT;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tif (raw)\n\t\t\tmdcount = repeat;\n\t\telse\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc > nextarg+2)\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tif (argc >= nextarg) {\n\t\t\tdiag = kdbgetularg(argv[nextarg], &val);\n\t\t\tif (!diag) {\n\t\t\t\tmdcount = (int) val;\n\t\t\t\tif (raw)\n\t\t\t\t\trepeat = mdcount;\n\t\t\t\telse\n\t\t\t\t\trepeat = mdcount * 16 / bytesperword;\n\t\t\t}\n\t\t}\n\t\tif (argc >= nextarg+1) {\n\t\t\tdiag = kdbgetularg(argv[nextarg+1], &val);\n\t\t\tif (!diag)\n\t\t\t\tradix = (int) val;\n\t\t}\n\t}\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tint ret;\n\t\tlast_addr = addr;\n\t\tret = kdb_mdr(addr, mdcount);\n\t\tlast_addr += mdcount;\n\t\tlast_repeat = mdcount;\n\t\tlast_bytesperword = bytesperword; \n\t\treturn ret;\n\t}\n\n\tswitch (radix) {\n\tcase 10:\n\t\tfmtchar = 'd';\n\t\tbreak;\n\tcase 16:\n\t\tfmtchar = 'x';\n\t\tbreak;\n\tcase 8:\n\t\tfmtchar = 'o';\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADRADIX;\n\t}\n\n\tlast_radix = radix;\n\n\tif (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\n\tswitch (bytesperword) {\n\tcase 8:\n\t\tsprintf(fmtstr, \"%%16.16l%c \", fmtchar);\n\t\tbreak;\n\tcase 4:\n\t\tsprintf(fmtstr, \"%%8.8l%c \", fmtchar);\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(fmtstr, \"%%4.4l%c \", fmtchar);\n\t\tbreak;\n\tcase 1:\n\t\tsprintf(fmtstr, \"%%2.2l%c \", fmtchar);\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADWIDTH;\n\t}\n\n\tlast_repeat = repeat;\n\tlast_bytesperword = bytesperword;\n\n\tif (strcmp(argv[0], \"mds\") == 0) {\n\t\tsymbolic = 1;\n\t\t \n\t\tbytesperword = KDB_WORD_SIZE;\n\t\trepeat = mdcount;\n\t\tkdbgetintenv(\"NOSECT\", &nosect);\n\t}\n\n\t \n\n\taddr &= ~(bytesperword-1);\n\n\twhile (repeat > 0) {\n\t\tunsigned long a;\n\t\tint n, z, num = (symbolic ? 1 : (16 / bytesperword));\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tfor (a = addr, z = 0; z < repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z > 2) {\n\t\t\tint s = num * (z-2);\n\t\t\tkdb_printf(kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\",\n\t\t\t\taddr, addr + bytesperword * s - 1);\n\t\t\taddr += bytesperword * s;\n\t\t\trepeat -= s;\n\t\t}\n\t}\n\tlast_addr = addr;\n\n\treturn 0;\n}\n\n \nstatic int kdb_mm(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset = 0;\n\tunsigned long contents;\n\tint nextarg;\n\tint width;\n\n\tif (argv[0][2] && !isdigit(argv[0][2]))\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc < 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &contents, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg != argc + 1)\n\t\treturn KDB_ARGCOUNT;\n\n\twidth = argv[0][2] ? (argv[0][2] - '0') : (KDB_WORD_SIZE);\n\tdiag = kdb_putword(addr, contents, width);\n\tif (diag)\n\t\treturn diag;\n\n\tkdb_printf(kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\", addr, contents);\n\n\treturn 0;\n}\n\n \nstatic int kdb_go(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tint diag;\n\tint nextarg;\n\tlong offset;\n\n\tif (raw_smp_processor_id() != kdb_initial_cpu) {\n\t\tkdb_printf(\"go must execute on the entry cpu, \"\n\t\t\t   \"please use \\\"cpu %d\\\" and then execute go\\n\",\n\t\t\t   kdb_initial_cpu);\n\t\treturn KDB_BADCPUNUM;\n\t}\n\tif (argc == 1) {\n\t\tnextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg,\n\t\t\t\t     &addr, &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (argc) {\n\t\treturn KDB_ARGCOUNT;\n\t}\n\n\tdiag = KDB_CMD_GO;\n\tif (KDB_FLAG(CATASTROPHIC)) {\n\t\tkdb_printf(\"Catastrophic error detected\\n\");\n\t\tkdb_printf(\"kdb_continue_catastrophic=%d, \",\n\t\t\tkdb_continue_catastrophic);\n\t\tif (kdb_continue_catastrophic == 0 && kdb_go_count++ == 0) {\n\t\t\tkdb_printf(\"type go a second time if you really want \"\n\t\t\t\t   \"to continue\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (kdb_continue_catastrophic == 2) {\n\t\t\tkdb_printf(\"forcing reboot\\n\");\n\t\t\tkdb_reboot(0, NULL);\n\t\t}\n\t\tkdb_printf(\"attempting to continue\\n\");\n\t}\n\treturn diag;\n}\n\n \nstatic int kdb_rd(int argc, const char **argv)\n{\n\tint len = kdb_check_regs();\n#if DBG_MAX_REG_NUM > 0\n\tint i;\n\tchar *rname;\n\tint rsize;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (len)\n\t\treturn len;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize > 16)\n\t\t\trsize = 2;\n\t\tif (len + strlen(dbg_reg_def[i].name) + 4 + rsize > 80) {\n\t\t\tlen = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tif (len)\n\t\t\tlen += kdb_printf(\"  \");\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\trname = dbg_get_reg(i, &reg8, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %02x\", rname, reg8);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\trname = dbg_get_reg(i, &reg16, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %04x\", rname, reg16);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\trname = dbg_get_reg(i, &reg32, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %08x\", rname, reg32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\trname = dbg_get_reg(i, &reg64, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %016llx\", rname, reg64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += kdb_printf(\"%s: ??\", dbg_reg_def[i].name);\n\t\t}\n\t}\n\tkdb_printf(\"\\n\");\n#else\n\tif (len)\n\t\treturn len;\n\n\tkdb_dumpregs(kdb_current_regs);\n#endif\n\treturn 0;\n}\n\n \nstatic int kdb_rm(int argc, const char **argv)\n{\n#if DBG_MAX_REG_NUM > 0\n\tint diag;\n\tconst char *rname;\n\tint i;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\t \n\trname = argv[1];\n\tif (*rname == '%')\n\t\trname++;\n\n\tdiag = kdbgetu64arg(argv[2], &reg64);\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = kdb_check_regs();\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = KDB_BADREG;\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"ERROR: Register set currently not implemented\\n\");\n    return 0;\n#endif\n}\n\n#if defined(CONFIG_MAGIC_SYSRQ)\n \nstatic int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(KDB_ENABLE_ALL, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}\n#endif\t \n\n \nstatic int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}\n\n \n\nstatic int kdb_env(int argc, const char **argv)\n{\n\tkdb_printenv();\n\n\tif (KDB_DEBUG(MASK))\n\t\tkdb_printf(\"KDBDEBUG=0x%x\\n\",\n\t\t\t(kdb_flags & KDB_DEBUG(MASK)) >> KDB_DEBUG_FLAG_SHIFT);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PRINTK\n \nstatic int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dump_iter iter;\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\tif (argc) {\n\t\tchar *cp;\n\t\tlines = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tlines = 0;\n\t\tif (argc > 1) {\n\t\t\tadjust = simple_strtoul(argv[2], &cp, 0);\n\t\t\tif (*cp || adjust < 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t \n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"LOGGING\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind(&iter);\n\twhile (kmsg_dump_get_line(&iter, 1, NULL, 0, NULL))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, nothing \"\n\t\t\t\t   \"printed\\n\", n);\n\t\telse if (adjust - lines >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, last %d \"\n\t\t\t\t   \"lines printed\\n\", n, n - adjust);\n\t\tskip = adjust;\n\t\tlines = abs(lines);\n\t} else if (lines > 0) {\n\t\tskip = n - lines - adjust;\n\t\tlines = abs(lines);\n\t\tif (adjust >= n) {\n\t\t\tkdb_printf(\"buffer only contains %d lines, \"\n\t\t\t\t   \"nothing printed\\n\", n);\n\t\t\tskip = n;\n\t\t} else if (skip < 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >= n || skip < 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind(&iter);\n\twhile (kmsg_dump_get_line(&iter, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}\n#endif  \n\n \nstatic atomic_t kdb_nmi_disabled;\n\nstatic int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}\n\nstatic int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -EINVAL;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops kdb_param_ops_enable_nmi = {\n\t.set = kdb_param_enable_nmi,\n};\nmodule_param_cb(enable_nmi, &kdb_param_ops_enable_nmi, NULL, 0600);\n\n \nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t \n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t \n\t\t} else {\n\t\t\tstate = ' ';\t \n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == '-')\n\t\t\t\tstate = '-';\t \n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t \n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}\n\nstatic int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t \n\tif ((cpunum >= CONFIG_NR_CPUS) || !kgdb_info[cpunum].enter_kgdb)\n\t\treturn KDB_BADCPUNUM;\n\n\tdbg_switch_cpu = cpunum;\n\n\t \n\treturn KDB_CMD_CPU;\n}\n\n \nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}\n\n \nstatic int kdb_ps(int argc, const char **argv)\n{\n\tstruct task_struct *g, *p;\n\tconst char *mask;\n\tunsigned long cpu;\n\n\tif (argc == 0)\n\t\tkdb_ps_suppressed();\n\tkdb_printf(\"%-*s      Pid   Parent [*] cpu State %-*s Command\\n\",\n\t\t(int)(2*sizeof(void *))+2, \"Task Addr\",\n\t\t(int)(2*sizeof(void *))+2, \"Thread\");\n\tmask = argc ? argv[1] : kdbgetenv(\"PS\");\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\tkdb_printf(\"\\n\");\n\t \n\tfor_each_process_thread(g, p) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int kdb_pid(int argc, const char **argv)\n{\n\tstruct task_struct *p;\n\tunsigned long val;\n\tint diag;\n\n\tif (argc > 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tif (strcmp(argv[1], \"R\") == 0) {\n\t\t\tp = KDB_TSK(kdb_initial_cpu);\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[1], &val);\n\t\t\tif (diag)\n\t\t\t\treturn KDB_BADINT;\n\n\t\t\tp = find_task_by_pid_ns((pid_t)val,\t&init_pid_ns);\n\t\t\tif (!p) {\n\t\t\t\tkdb_printf(\"No task with pid=%d\\n\", (pid_t)val);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tkdb_set_current_task(p);\n\t}\n\tkdb_printf(\"KDB current process is %s(pid=%d)\\n\",\n\t\t   kdb_current_task->comm,\n\t\t   kdb_current_task->pid);\n\n\treturn 0;\n}\n\nstatic int kdb_kgdb(int argc, const char **argv)\n{\n\treturn KDB_CMD_KGDB;\n}\n\n \nstatic int kdb_help(int argc, const char **argv)\n{\n\tkdbtab_t *kt;\n\n\tkdb_printf(\"%-15.15s %-20.20s %s\\n\", \"Command\", \"Usage\", \"Description\");\n\tkdb_printf(\"-----------------------------\"\n\t\t   \"-----------------------------\\n\");\n\tlist_for_each_entry(kt, &kdb_cmds_head, list_node) {\n\t\tchar *space = \"\";\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (!kdb_check_flags(kt->flags, kdb_cmd_enabled, true))\n\t\t\tcontinue;\n\t\tif (strlen(kt->usage) > 20)\n\t\t\tspace = \"\\n                                    \";\n\t\tkdb_printf(\"%-15.15s %-20s%s%s\\n\", kt->name,\n\t\t\t   kt->usage, space, kt->help);\n\t}\n\treturn 0;\n}\n\n \nstatic int kdb_kill(int argc, const char **argv)\n{\n\tlong sig, pid;\n\tchar *endp;\n\tstruct task_struct *p;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tsig = simple_strtol(argv[1], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif ((sig >= 0) || !valid_signal(-sig)) {\n\t\tkdb_printf(\"Invalid signal parameter.<-signal>\\n\");\n\t\treturn 0;\n\t}\n\tsig = -sig;\n\n\tpid = simple_strtol(argv[2], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif (pid <= 0) {\n\t\tkdb_printf(\"Process ID must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"The specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->group_leader;\n\tkdb_send_sig(p, sig);\n\treturn 0;\n}\n\n \nstatic void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}\n\n \nstatic int kdb_summary(int argc, const char **argv)\n{\n\ttime64_t now;\n\tstruct sysinfo val;\n\n\tif (argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"sysname    %s\\n\", init_uts_ns.name.sysname);\n\tkdb_printf(\"release    %s\\n\", init_uts_ns.name.release);\n\tkdb_printf(\"version    %s\\n\", init_uts_ns.name.version);\n\tkdb_printf(\"machine    %s\\n\", init_uts_ns.name.machine);\n\tkdb_printf(\"nodename   %s\\n\", init_uts_ns.name.nodename);\n\tkdb_printf(\"domainname %s\\n\", init_uts_ns.name.domainname);\n\n\tnow = __ktime_get_real_seconds();\n\tkdb_printf(\"date       %ptTs tz_minuteswest %d\\n\", &now, sys_tz.tz_minuteswest);\n\tkdb_sysinfo(&val);\n\tkdb_printf(\"uptime     \");\n\tif (val.uptime > (24*60*60)) {\n\t\tint days = val.uptime / (24*60*60);\n\t\tval.uptime %= (24*60*60);\n\t\tkdb_printf(\"%d day%s \", days, days == 1 ? \"\" : \"s\");\n\t}\n\tkdb_printf(\"%02ld:%02ld\\n\", val.uptime/(60*60), (val.uptime/60)%60);\n\n\tkdb_printf(\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\",\n\t\tLOAD_INT(val.loads[0]), LOAD_FRAC(val.loads[0]),\n\t\tLOAD_INT(val.loads[1]), LOAD_FRAC(val.loads[1]),\n\t\tLOAD_INT(val.loads[2]), LOAD_FRAC(val.loads[2]));\n\n\t \n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tkdb_printf(\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\",\n\t\t   K(val.totalram), K(val.freeram), K(val.bufferram));\n\treturn 0;\n}\n\n \nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (whichcpu >= nr_cpu_ids || !cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t \n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}\n\n \nstatic int kdb_grep_help(int argc, const char **argv)\n{\n\tkdb_printf(\"Usage of  cmd args | grep pattern:\\n\");\n\tkdb_printf(\"  Any command's output may be filtered through an \");\n\tkdb_printf(\"emulated 'pipe'.\\n\");\n\tkdb_printf(\"  'grep' is just a key word.\\n\");\n\tkdb_printf(\"  The pattern may include a very limited set of \"\n\t\t   \"metacharacters:\\n\");\n\tkdb_printf(\"   pattern or ^pattern or pattern$ or ^pattern$\\n\");\n\tkdb_printf(\"  And if there are spaces in the pattern, you may \"\n\t\t   \"quote it:\\n\");\n\tkdb_printf(\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\");\n\treturn 0;\n}\n\n \nint kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kdb_register);\n\n \nvoid kdb_register_table(kdbtab_t *kp, size_t len)\n{\n\twhile (len--) {\n\t\tlist_add_tail(&kp->list_node, &kdb_cmds_head);\n\t\tkp++;\n\t}\n}\n\n \nvoid kdb_unregister(kdbtab_t *cmd)\n{\n\tlist_del(&cmd->list_node);\n}\nEXPORT_SYMBOL_GPL(kdb_unregister);\n\nstatic kdbtab_t maintab[] = {\n\t{\t.name = \"md\",\n\t\t.func = kdb_md,\n\t\t.usage = \"<vaddr>\",\n\t\t.help = \"Display Memory Contents, also mdWcN, e.g. md8c1\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"mdr\",\n\t\t.func = kdb_md,\n\t\t.usage = \"<vaddr> <bytes>\",\n\t\t.help = \"Display Raw Memory\",\n\t\t.flags = KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"mdp\",\n\t\t.func = kdb_md,\n\t\t.usage = \"<paddr> <bytes>\",\n\t\t.help = \"Display Physical Memory\",\n\t\t.flags = KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"mds\",\n\t\t.func = kdb_md,\n\t\t.usage = \"<vaddr>\",\n\t\t.help = \"Display Memory Symbolically\",\n\t\t.flags = KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"mm\",\n\t\t.func = kdb_mm,\n\t\t.usage = \"<vaddr> <contents>\",\n\t\t.help = \"Modify Memory Contents\",\n\t\t.flags = KDB_ENABLE_MEM_WRITE | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"go\",\n\t\t.func = kdb_go,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Continue Execution\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_REG_WRITE |\n\t\t\t     KDB_ENABLE_ALWAYS_SAFE_NO_ARGS,\n\t},\n\t{\t.name = \"rd\",\n\t\t.func = kdb_rd,\n\t\t.usage = \"\",\n\t\t.help = \"Display Registers\",\n\t\t.flags = KDB_ENABLE_REG_READ,\n\t},\n\t{\t.name = \"rm\",\n\t\t.func = kdb_rm,\n\t\t.usage = \"<reg> <contents>\",\n\t\t.help = \"Modify Registers\",\n\t\t.flags = KDB_ENABLE_REG_WRITE,\n\t},\n\t{\t.name = \"ef\",\n\t\t.func = kdb_ef,\n\t\t.usage = \"<vaddr>\",\n\t\t.help = \"Display exception frame\",\n\t\t.flags = KDB_ENABLE_MEM_READ,\n\t},\n\t{\t.name = \"bt\",\n\t\t.func = kdb_bt,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Stack traceback\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS,\n\t},\n\t{\t.name = \"btp\",\n\t\t.func = kdb_bt,\n\t\t.usage = \"<pid>\",\n\t\t.help = \"Display stack for process <pid>\",\n\t\t.flags = KDB_ENABLE_INSPECT,\n\t},\n\t{\t.name = \"bta\",\n\t\t.func = kdb_bt,\n\t\t.usage = \"[<state_chars>|A]\",\n\t\t.help = \"Backtrace all processes whose state matches\",\n\t\t.flags = KDB_ENABLE_INSPECT,\n\t},\n\t{\t.name = \"btc\",\n\t\t.func = kdb_bt,\n\t\t.usage = \"\",\n\t\t.help = \"Backtrace current process on each cpu\",\n\t\t.flags = KDB_ENABLE_INSPECT,\n\t},\n\t{\t.name = \"btt\",\n\t\t.func = kdb_bt,\n\t\t.usage = \"<vaddr>\",\n\t\t.help = \"Backtrace process given its struct task address\",\n\t\t.flags = KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS,\n\t},\n\t{\t.name = \"env\",\n\t\t.func = kdb_env,\n\t\t.usage = \"\",\n\t\t.help = \"Show environment variables\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n\t{\t.name = \"set\",\n\t\t.func = kdb_set,\n\t\t.usage = \"\",\n\t\t.help = \"Set environment variables\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n\t{\t.name = \"help\",\n\t\t.func = kdb_help,\n\t\t.usage = \"\",\n\t\t.help = \"Display Help Message\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n\t{\t.name = \"?\",\n\t\t.func = kdb_help,\n\t\t.usage = \"\",\n\t\t.help = \"Display Help Message\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n\t{\t.name = \"cpu\",\n\t\t.func = kdb_cpu,\n\t\t.usage = \"<cpunum>\",\n\t\t.help = \"Switch to new cpu\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE_NO_ARGS,\n\t},\n\t{\t.name = \"kgdb\",\n\t\t.func = kdb_kgdb,\n\t\t.usage = \"\",\n\t\t.help = \"Enter kgdb mode\",\n\t\t.flags = 0,\n\t},\n\t{\t.name = \"ps\",\n\t\t.func = kdb_ps,\n\t\t.usage = \"[<state_chars>|A]\",\n\t\t.help = \"Display active task list\",\n\t\t.flags = KDB_ENABLE_INSPECT,\n\t},\n\t{\t.name = \"pid\",\n\t\t.func = kdb_pid,\n\t\t.usage = \"<pidnum>\",\n\t\t.help = \"Switch to another task\",\n\t\t.flags = KDB_ENABLE_INSPECT,\n\t},\n\t{\t.name = \"reboot\",\n\t\t.func = kdb_reboot,\n\t\t.usage = \"\",\n\t\t.help = \"Reboot the machine immediately\",\n\t\t.flags = KDB_ENABLE_REBOOT,\n\t},\n#if defined(CONFIG_MODULES)\n\t{\t.name = \"lsmod\",\n\t\t.func = kdb_lsmod,\n\t\t.usage = \"\",\n\t\t.help = \"List loaded kernel modules\",\n\t\t.flags = KDB_ENABLE_INSPECT,\n\t},\n#endif\n#if defined(CONFIG_MAGIC_SYSRQ)\n\t{\t.name = \"sr\",\n\t\t.func = kdb_sr,\n\t\t.usage = \"<key>\",\n\t\t.help = \"Magic SysRq key\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n#endif\n#if defined(CONFIG_PRINTK)\n\t{\t.name = \"dmesg\",\n\t\t.func = kdb_dmesg,\n\t\t.usage = \"[lines]\",\n\t\t.help = \"Display syslog buffer\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n#endif\n\t{\t.name = \"defcmd\",\n\t\t.func = kdb_defcmd,\n\t\t.usage = \"name \\\"usage\\\" \\\"help\\\"\",\n\t\t.help = \"Define a set of commands, down to endefcmd\",\n\t\t \n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n\t{\t.name = \"kill\",\n\t\t.func = kdb_kill,\n\t\t.usage = \"<-signal> <pid>\",\n\t\t.help = \"Send a signal to a process\",\n\t\t.flags = KDB_ENABLE_SIGNAL,\n\t},\n\t{\t.name = \"summary\",\n\t\t.func = kdb_summary,\n\t\t.usage = \"\",\n\t\t.help = \"Summarize the system\",\n\t\t.minlen = 4,\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n\t{\t.name = \"per_cpu\",\n\t\t.func = kdb_per_cpu,\n\t\t.usage = \"<sym> [<bytes>] [<cpu>]\",\n\t\t.help = \"Display per_cpu variables\",\n\t\t.minlen = 3,\n\t\t.flags = KDB_ENABLE_MEM_READ,\n\t},\n\t{\t.name = \"grephelp\",\n\t\t.func = kdb_grep_help,\n\t\t.usage = \"\",\n\t\t.help = \"Display help on | grep\",\n\t\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n\t},\n};\n\nstatic kdbtab_t nmicmd = {\n\t.name = \"disable_nmi\",\n\t.func = kdb_disable_nmi,\n\t.usage = \"\",\n\t.help = \"Disable NMI entry to KDB\",\n\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n};\n\n \nstatic void __init kdb_inittab(void)\n{\n\tkdb_register_table(maintab, ARRAY_SIZE(maintab));\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tkdb_register_table(&nmicmd, 1);\n}\n\n \nstatic void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}\n\n \nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t \n\t\t\tkdb_initbptab();\t \n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}