{
  "module_name": "kdb_debugger.c",
  "hash_id": "2909223bf2648957716389532f6f94b4eea4fa79933adeee4a0f9c76b24e5750",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/kdb/kdb_debugger.c",
  "human_readable_source": " \n\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/kdebug.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include \"kdb_private.h\"\n#include \"../debug_core.h\"\n\n \nget_char_func kdb_poll_funcs[] = {\n\tdbg_io_get_char,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(kdb_poll_funcs);\n\nint kdb_poll_idx = 1;\nEXPORT_SYMBOL_GPL(kdb_poll_idx);\n\nstatic struct kgdb_state *kdb_ks;\n\nint kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}\n\nint kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}\n\nint kdb_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tkdb_bp_t *bp;\n\tunsigned long addr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\n\tkdb_reason_t reason = KDB_REASON_OOPS;\n\tkdb_dbtrap_t db_result = KDB_DB_NOBPT;\n\tint i;\n\n\tkdb_ks = ks;\n\tif (KDB_STATE(REENTRY)) {\n\t\treason = KDB_REASON_SWITCH;\n\t\tKDB_STATE_CLEAR(REENTRY);\n\t\taddr = instruction_pointer(ks->linux_regs);\n\t}\n\tks->pass_exception = 0;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treason = KDB_REASON_KEYBOARD;\n\n\tif (ks->err_code == KDB_REASON_SYSTEM_NMI && ks->signo == SIGTRAP)\n\t\treason = KDB_REASON_SYSTEM_NMI;\n\n\telse if (in_nmi())\n\t\treason = KDB_REASON_NMI;\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\n\t\tif ((bp->bp_enabled) && (bp->bp_addr == addr)) {\n\t\t\treason = KDB_REASON_BREAK;\n\t\t\tdb_result = KDB_DB_BPT;\n\t\t\tif (addr != instruction_pointer(ks->linux_regs))\n\t\t\t\tkgdb_arch_set_pc(ks->linux_regs, addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (reason == KDB_REASON_BREAK || reason == KDB_REASON_SWITCH) {\n\t\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++) {\n\t\t\tif (bp->bp_free)\n\t\t\t\tcontinue;\n\t\t\tif (bp->bp_addr == addr) {\n\t\t\t\tbp->bp_delay = 1;\n\t\t\t\tbp->bp_delayed = 1;\n\t \n\t\t\t\treason = KDB_REASON_BREAK;\n\t\t\t\tdb_result = KDB_DB_BPT;\n\t\t\t\tKDB_STATE_SET(SSBPT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (reason != KDB_REASON_BREAK && ks->ex_vector == 0 &&\n\t\tks->signo == SIGTRAP) {\n\t\treason = KDB_REASON_SSTEP;\n\t\tdb_result = KDB_DB_BPT;\n\t}\n\t \n\tKDB_STATE_CLEAR(KGDB_TRANS);\n\tkdb_common_init_state(ks);\n\t \n\tkdb_bp_remove();\n\tKDB_STATE_CLEAR(DOING_SS);\n\tKDB_STATE_SET(PAGER);\n\tif (ks->err_code == DIE_OOPS || reason == KDB_REASON_OOPS) {\n\t\tks->pass_exception = 1;\n\t\tKDB_FLAG_SET(CATASTROPHIC);\n\t}\n\t \n\tfor_each_online_cpu(i)\n\t\tif (!kgdb_info[i].enter_kgdb)\n\t\t\tKDB_FLAG_SET(CATASTROPHIC);\n\tif (KDB_STATE(SSBPT) && reason == KDB_REASON_SSTEP) {\n\t\tKDB_STATE_CLEAR(SSBPT);\n\t\tKDB_STATE_CLEAR(DOING_SS);\n\t} else {\n\t\t \n\t\terror = kdb_main_loop(KDB_REASON_ENTER, reason,\n\t\t\t\t      ks->err_code, db_result, ks->linux_regs);\n\t}\n\t \n\tkdb_common_deinit_state();\n\tKDB_STATE_CLEAR(PAGER);\n\tif (error == KDB_CMD_KGDB) {\n\t\tif (KDB_STATE(DOING_KGDB))\n\t\t\tKDB_STATE_CLEAR(DOING_KGDB);\n\t\treturn DBG_PASS_EVENT;\n\t}\n\tkdb_bp_install(ks->linux_regs);\n\t \n\tif (KDB_STATE(DOING_SS))\n\t\tgdbstub_state(ks, \"s\");\n\telse\n\t\tgdbstub_state(ks, \"c\");\n\n\tKDB_FLAG_CLEAR(CATASTROPHIC);\n\n\t \n\tkgdb_info[ks->cpu].ret_state = gdbstub_state(ks, \"e\");\n\tif (ks->pass_exception)\n\t\tkgdb_info[ks->cpu].ret_state = 1;\n\tif (error == KDB_CMD_CPU) {\n\t\tKDB_STATE_SET(REENTRY);\n\t\t \n\t\tkgdb_single_step = 0;\n\t\treturn DBG_SWITCH_CPU_EVENT;\n\t}\n\treturn kgdb_info[ks->cpu].ret_state;\n}\n\nvoid kdb_gdb_state_pass(char *buf)\n{\n\tgdbstub_state(kdb_ks, buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}