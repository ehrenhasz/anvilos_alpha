{
  "module_name": "gdbstub.c",
  "hash_id": "782b844da574898b949038ffb8e72e932eb15a137c0c642aa60bc1650bf21686",
  "original_prompt": "Ingested from linux-6.6.14/kernel/debug/gdbstub.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/serial_core.h>\n#include <linux/reboot.h>\n#include <linux/uaccess.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include \"debug_core.h\"\n\n#define KGDB_MAX_THREAD_QUERY 17\n\n \nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic int\t\t\tgdbstub_use_prev_in_buf;\nstatic int\t\t\tgdbstub_prev_in_buf_pos;\n\n \nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\n \n\n#ifdef CONFIG_KGDB_KDB\nstatic int gdbstub_read_wait(void)\n{\n\tint ret = -1;\n\tint i;\n\n\tif (unlikely(gdbstub_use_prev_in_buf)) {\n\t\tif (gdbstub_prev_in_buf_pos < gdbstub_use_prev_in_buf)\n\t\t\treturn remcom_in_buffer[gdbstub_prev_in_buf_pos++];\n\t\telse\n\t\t\tgdbstub_use_prev_in_buf = 0;\n\t}\n\n\t \n\twhile (ret < 0)\n\t\tfor (i = 0; kdb_poll_funcs[i] != NULL; i++) {\n\t\t\tret = kdb_poll_funcs[i]();\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t}\n\treturn ret;\n}\n#else\nstatic int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}\n#endif\n \nstatic void get_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tunsigned char xmitcsum;\n\tint count;\n\tchar ch;\n\n\tdo {\n\t\t \n\t\twhile ((ch = (gdbstub_read_wait())) != '$')\n\t\t\t ;\n\n\t\tkgdb_connected = 1;\n\t\tchecksum = 0;\n\t\txmitcsum = -1;\n\n\t\tcount = 0;\n\n\t\t \n\t\twhile (count < (BUFMAX - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t \n\t\t\t\tdbg_io_ops->write_char('-');\n\t\t\telse\n\t\t\t\t \n\t\t\t\tdbg_io_ops->write_char('+');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t}\n\t\tbuffer[count] = 0;\n\t} while (checksum != xmitcsum);\n}\n\n \nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t \n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t \n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t \n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t \n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t \n\tgdbmsgbuf[0] = 'O';\n\n\t \n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t \n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t \n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t \n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t \n\t\tput_packet(gdbmsgbuf);\n\t}\n}\n\n \nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t \n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}\n\n \nint kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t \n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}\n\n \nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}\n\n \nstatic int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- > 0) {\n\t\tc[size] = *buf++;\n\t\tif (c[size] == 0x7d)\n\t\t\tc[size] = *buf++ ^ 0x20;\n\t\tsize++;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, c, size);\n}\n\n#if DBG_MAX_REG_NUM > 0\nvoid pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}\n\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}\n#endif  \n\n \nstatic int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}\n\n \n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}\n\nstatic void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t \n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t \n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}\n\n\n \nstatic inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}\n\n \n\n \nstatic void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t \n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 'S';\n\thex_byte_pack(&remcom_out_buffer[1], ks->signo);\n}\n\nstatic void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t \n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t \n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t \n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}\n\n \nstatic void gdb_cmd_getregs(struct kgdb_state *ks)\n{\n\tgdb_get_regs_helper(ks);\n\tkgdb_mem2hex((char *)gdb_regs, remcom_out_buffer, NUMREGBYTES);\n}\n\n \nstatic void gdb_cmd_setregs(struct kgdb_state *ks)\n{\n\tkgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs, NUMREGBYTES);\n\n\tif (kgdb_usethread && kgdb_usethread != current) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\tgdb_regs_to_pt_regs(gdb_regs, ks->linux_regs);\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t}\n}\n\n \nstatic void gdb_cmd_memread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long length;\n\tunsigned long addr;\n\tchar *err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&\n\t\t\t\t\tkgdb_hex2long(&ptr, &length) > 0) {\n\t\terr = kgdb_mem2hex((char *)addr, remcom_out_buffer, length);\n\t\tif (!err)\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t}\n}\n\n \nstatic void gdb_cmd_memwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(0);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}\n\n#if DBG_MAX_REG_NUM > 0\nstatic char *gdb_hex_reg_helper(int regnum, char *out)\n{\n\tint i;\n\tint offset = 0;\n\n\tfor (i = 0; i < regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}\n\n \nstatic void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >= DBG_MAX_REG_NUM) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tgdb_get_regs_helper(ks);\n\tgdb_hex_reg_helper(regnum, remcom_out_buffer);\n}\n\n \nstatic void gdb_cmd_reg_set(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\tint i = 0;\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (*ptr++ != '=' ||\n\t    !(!kgdb_usethread || kgdb_usethread == current) ||\n\t    !dbg_get_reg(regnum, gdb_regs, ks->linux_regs)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tmemset(gdb_regs, 0, sizeof(gdb_regs));\n\twhile (i < sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >= 0)\n\t\t\ti++;\n\t\telse\n\t\t\tbreak;\n\ti = i / 2;\n\tkgdb_hex2mem(ptr, (char *)gdb_regs, i);\n\tdbg_set_reg(regnum, gdb_regs, ks->linux_regs);\n\tstrcpy(remcom_out_buffer, \"OK\");\n}\n#endif  \n\n \nstatic void gdb_cmd_binwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(1);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}\n\n \nstatic void gdb_cmd_detachkill(struct kgdb_state *ks)\n{\n\tint error;\n\n\t \n\tif (remcom_in_buffer[0] == 'D') {\n\t\terror = dbg_remove_all_break();\n\t\tif (error < 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t \n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}\n\n \nstatic int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t \n\tif (strcmp(remcom_in_buffer, \"R0\") == 0) {\n\t\tprintk(KERN_CRIT \"Executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t \n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"ThreadInfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t \n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->thr_query = 0;\n\t\t\t\tint_to_threadref(thref, -cpu - 2);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (i >= ks->thr_query && !finished) {\n\t\t\t\tint_to_threadref(thref, p->pid);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\tks->thr_query++;\n\t\t\t\tif (ks->thr_query % KGDB_MAX_THREAD_QUERY == 0)\n\t\t\t\t\tfinished = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t*(--ptr) = '\\0';\n\t\tbreak;\n\n\tcase 'C':\n\t\t \n\t\tstrcpy(remcom_out_buffer, \"QC\");\n\t\tks->threadid = shadow_pid(current->pid);\n\t\tint_to_threadref(thref, ks->threadid);\n\t\tpack_threadid(remcom_out_buffer + 2, thref);\n\t\tbreak;\n\tcase 'T':\n\t\tif (memcmp(remcom_in_buffer + 1, \"ThreadExtraInfo,\", 16))\n\t\t\tbreak;\n\n\t\tks->threadid = 0;\n\t\tptr = remcom_in_buffer + 17;\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!getthread(ks->linux_regs, ks->threadid)) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tif ((int)ks->threadid > 0) {\n\t\t\tkgdb_mem2hex(getthread(ks->linux_regs,\n\t\t\t\t\tks->threadid)->comm,\n\t\t\t\t\tremcom_out_buffer, 16);\n\t\t} else {\n\t\t\tstatic char tmpstr[23 + BUF_THREAD_ID_SIZE];\n\n\t\t\tsprintf(tmpstr, \"shadowCPU%d\",\n\t\t\t\t\t(int)(-ks->threadid - 2));\n\t\t\tkgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\tcase 'R':\n\t\tif (strncmp(remcom_in_buffer, \"qRcmd,\", 6) == 0) {\n\t\t\tint len = strlen(remcom_in_buffer + 6);\n\n\t\t\tif ((len % 2) != 0) {\n\t\t\t\tstrcpy(remcom_out_buffer, \"E01\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_hex2mem(remcom_in_buffer + 6,\n\t\t\t\t     remcom_out_buffer, len);\n\t\t\tlen = len / 2;\n\t\t\tremcom_out_buffer[len++] = 0;\n\n\t\t\tkdb_common_init_state(ks);\n\t\t\tkdb_parse(remcom_out_buffer);\n\t\t\tkdb_common_deinit_state();\n\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_HAVE_ARCH_KGDB_QXFER_PKT\n\tcase 'S':\n\t\tif (!strncmp(remcom_in_buffer, \"qSupported:\", 11))\n\t\t\tstrcpy(remcom_out_buffer, kgdb_arch_gdb_stub_feature);\n\t\tbreak;\n\tcase 'X':\n\t\tif (!strncmp(remcom_in_buffer, \"qXfer:\", 6))\n\t\t\tkgdb_arch_handle_qxfer_pkt(remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void gdb_cmd_task(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tchar *ptr;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 'g':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\tif (!thread && ks->threadid > 0) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tkgdb_usethread = thread;\n\t\tks->kgdb_usethreadid = ks->threadid;\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\tcase 'c':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!ks->threadid) {\n\t\t\tkgdb_contthread = NULL;\n\t\t} else {\n\t\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\t\tif (!thread && ks->threadid > 0) {\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_contthread = thread;\n\t\t}\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\t}\n}\n\n \nstatic void gdb_cmd_thread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tstruct task_struct *thread;\n\n\tkgdb_hex2long(&ptr, &ks->threadid);\n\tthread = getthread(ks->linux_regs, ks->threadid);\n\tif (thread)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n}\n\n \nstatic void gdb_cmd_break(struct kgdb_state *ks)\n{\n\t \n\tchar *bpt_type = &remcom_in_buffer[1];\n\tchar *ptr = &remcom_in_buffer[2];\n\tunsigned long addr;\n\tunsigned long length;\n\tint error = 0;\n\n\tif (arch_kgdb_ops.set_hw_breakpoint && *bpt_type >= '1') {\n\t\t \n\t\tif (*bpt_type > '4')\n\t\t\treturn;\n\t} else {\n\t\tif (*bpt_type != '0' && *bpt_type != '1')\n\t\t\t \n\t\t\treturn;\n\t}\n\n\t \n\tif (*bpt_type == '1' && !(arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT))\n\t\t \n\t\treturn;\n\n\tif (*(ptr++) != ',') {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (!kgdb_hex2long(&ptr, &addr)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (*(ptr++) != ',' ||\n\t\t!kgdb_hex2long(&ptr, &length)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\n\tif (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')\n\t\terror = dbg_set_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')\n\t\terror = dbg_remove_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'Z')\n\t\terror = arch_kgdb_ops.set_hw_breakpoint(addr,\n\t\t\t(int)length, *bpt_type - '0');\n\telse if (remcom_in_buffer[0] == 'z')\n\t\terror = arch_kgdb_ops.remove_hw_breakpoint(addr,\n\t\t\t(int) length, *bpt_type - '0');\n\n\tif (error == 0)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, error);\n}\n\n \nstatic int gdb_cmd_exception_pass(struct kgdb_state *ks)\n{\n\t \n\tif (remcom_in_buffer[1] == '0' && remcom_in_buffer[2] == '9') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'c';\n\n\t} else if (remcom_in_buffer[1] == '1' && remcom_in_buffer[2] == '5') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'D';\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t\treturn 1;\n\n\t} else {\n\t\tgdbstub_msg_write(\"KGDB only knows signal 9 (pass)\"\n\t\t\t\" and 15 (pass and disconnect)\\n\"\n\t\t\t\"Executing a continue without signal passing\\n\", 0);\n\t\tremcom_in_buffer[0] = 'c';\n\t}\n\n\t \n\treturn -1;\n}\n\n \nint gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t \n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t \n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t \n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?':  \n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g':  \n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G':  \n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm':  \n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M':  \n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p':  \n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P':  \n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif  \n\t\tcase 'X':  \n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t \n\t\tcase 'D':  \n\t\tcase 'k':  \n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R':  \n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q':  \n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H':  \n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T':  \n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z':  \n\t\tcase 'Z':  \n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3':  \n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n\t\t\tfallthrough;\n#endif\n\t\tcase 'C':  \n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t \n\t\tcase 'c':  \n\t\tcase 's':  \n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t \n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t \n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t \n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}\n\nint gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}\n\n \nvoid gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t \n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}