{
  "module_name": "delayacct.c",
  "hash_id": "c4e24755a42b68e401952c9000de4af60339fa3965505a236b58a9e04216aa9e",
  "original_prompt": "Ingested from linux-6.6.14/kernel/delayacct.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/clock.h>\n#include <linux/slab.h>\n#include <linux/taskstats.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/module.h>\n\nDEFINE_STATIC_KEY_FALSE(delayacct_key);\nint delayacct_on __read_mostly;\t \nstruct kmem_cache *delayacct_cache;\n\nstatic void set_delayacct(bool enabled)\n{\n\tif (enabled) {\n\t\tstatic_branch_enable(&delayacct_key);\n\t\tdelayacct_on = 1;\n\t} else {\n\t\tdelayacct_on = 0;\n\t\tstatic_branch_disable(&delayacct_key);\n\t}\n}\n\nstatic int __init delayacct_setup_enable(char *str)\n{\n\tdelayacct_on = 1;\n\treturn 1;\n}\n__setup(\"delayacct\", delayacct_setup_enable);\n\nvoid delayacct_init(void)\n{\n\tdelayacct_cache = KMEM_CACHE(task_delay_info, SLAB_PANIC|SLAB_ACCOUNT);\n\tdelayacct_tsk_init(&init_task);\n\tset_delayacct(delayacct_on);\n}\n\n#ifdef CONFIG_PROC_SYSCTL\nstatic int sysctl_delayacct(struct ctl_table *table, int write, void *buffer,\n\t\t     size_t *lenp, loff_t *ppos)\n{\n\tint state = delayacct_on;\n\tstruct ctl_table t;\n\tint err;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_delayacct(state);\n\treturn err;\n}\n\nstatic struct ctl_table kern_delayacct_table[] = {\n\t{\n\t\t.procname       = \"task_delayacct\",\n\t\t.data           = NULL,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = sysctl_delayacct,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{ }\n};\n\nstatic __init int kernel_delayacct_sysctls_init(void)\n{\n\tregister_sysctl_init(\"kernel\", kern_delayacct_table);\n\treturn 0;\n}\nlate_initcall(kernel_delayacct_sysctls_init);\n#endif\n\nvoid __delayacct_tsk_init(struct task_struct *tsk)\n{\n\ttsk->delays = kmem_cache_zalloc(delayacct_cache, GFP_KERNEL);\n\tif (tsk->delays)\n\t\traw_spin_lock_init(&tsk->delays->lock);\n}\n\n \nstatic void delayacct_end(raw_spinlock_t *lock, u64 *start, u64 *total, u32 *count)\n{\n\ts64 ns = local_clock() - *start;\n\tunsigned long flags;\n\n\tif (ns > 0) {\n\t\traw_spin_lock_irqsave(lock, flags);\n\t\t*total += ns;\n\t\t(*count)++;\n\t\traw_spin_unlock_irqrestore(lock, flags);\n\t}\n}\n\nvoid __delayacct_blkio_start(void)\n{\n\tcurrent->delays->blkio_start = local_clock();\n}\n\n \nvoid __delayacct_blkio_end(struct task_struct *p)\n{\n\tdelayacct_end(&p->delays->lock,\n\t\t      &p->delays->blkio_start,\n\t\t      &p->delays->blkio_delay,\n\t\t      &p->delays->blkio_count);\n}\n\nint delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t \n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\tif (!tsk->delays)\n\t\treturn 0;\n\n\t \n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\ttmp = d->compact_delay_total + tsk->delays->compact_delay;\n\td->compact_delay_total = (tmp < d->compact_delay_total) ? 0 : tmp;\n\ttmp = d->wpcopy_delay_total + tsk->delays->wpcopy_delay;\n\td->wpcopy_delay_total = (tmp < d->wpcopy_delay_total) ? 0 : tmp;\n\ttmp = d->irq_delay_total + tsk->delays->irq_delay;\n\td->irq_delay_total = (tmp < d->irq_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\td->compact_count += tsk->delays->compact_count;\n\td->wpcopy_count += tsk->delays->wpcopy_count;\n\td->irq_count += tsk->delays->irq_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}\n\n__u64 __delayacct_blkio_ticks(struct task_struct *tsk)\n{\n\t__u64 ret;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\tret = nsec_to_clock_t(tsk->delays->blkio_delay);\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\treturn ret;\n}\n\nvoid __delayacct_freepages_start(void)\n{\n\tcurrent->delays->freepages_start = local_clock();\n}\n\nvoid __delayacct_freepages_end(void)\n{\n\tdelayacct_end(&current->delays->lock,\n\t\t      &current->delays->freepages_start,\n\t\t      &current->delays->freepages_delay,\n\t\t      &current->delays->freepages_count);\n}\n\nvoid __delayacct_thrashing_start(bool *in_thrashing)\n{\n\t*in_thrashing = !!current->in_thrashing;\n\tif (*in_thrashing)\n\t\treturn;\n\n\tcurrent->in_thrashing = 1;\n\tcurrent->delays->thrashing_start = local_clock();\n}\n\nvoid __delayacct_thrashing_end(bool *in_thrashing)\n{\n\tif (*in_thrashing)\n\t\treturn;\n\n\tcurrent->in_thrashing = 0;\n\tdelayacct_end(&current->delays->lock,\n\t\t      &current->delays->thrashing_start,\n\t\t      &current->delays->thrashing_delay,\n\t\t      &current->delays->thrashing_count);\n}\n\nvoid __delayacct_swapin_start(void)\n{\n\tcurrent->delays->swapin_start = local_clock();\n}\n\nvoid __delayacct_swapin_end(void)\n{\n\tdelayacct_end(&current->delays->lock,\n\t\t      &current->delays->swapin_start,\n\t\t      &current->delays->swapin_delay,\n\t\t      &current->delays->swapin_count);\n}\n\nvoid __delayacct_compact_start(void)\n{\n\tcurrent->delays->compact_start = local_clock();\n}\n\nvoid __delayacct_compact_end(void)\n{\n\tdelayacct_end(&current->delays->lock,\n\t\t      &current->delays->compact_start,\n\t\t      &current->delays->compact_delay,\n\t\t      &current->delays->compact_count);\n}\n\nvoid __delayacct_wpcopy_start(void)\n{\n\tcurrent->delays->wpcopy_start = local_clock();\n}\n\nvoid __delayacct_wpcopy_end(void)\n{\n\tdelayacct_end(&current->delays->lock,\n\t\t      &current->delays->wpcopy_start,\n\t\t      &current->delays->wpcopy_delay,\n\t\t      &current->delays->wpcopy_count);\n}\n\nvoid __delayacct_irq(struct task_struct *task, u32 delta)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->delays->lock, flags);\n\ttask->delays->irq_delay += delta;\n\ttask->delays->irq_count++;\n\traw_spin_unlock_irqrestore(&task->delays->lock, flags);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}