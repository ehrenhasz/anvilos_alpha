{
  "module_name": "static_call_inline.c",
  "hash_id": "a98014df4ada4fd2e18e6b5874b1dd4cd76a9d9bd86b1830bc2579386b829bba",
  "original_prompt": "Ingested from linux-6.6.14/kernel/static_call_inline.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/static_call.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/cpu.h>\n#include <linux/processor.h>\n#include <asm/sections.h>\n\nextern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];\nextern struct static_call_tramp_key __start_static_call_tramp_key[],\n\t\t\t\t    __stop_static_call_tramp_key[];\n\nstatic int static_call_initialized;\n\n \nvoid static_call_force_reinit(void)\n{\n\tif (WARN_ON_ONCE(!static_call_initialized))\n\t\treturn;\n\n\tstatic_call_initialized++;\n}\n\n \nstatic DEFINE_MUTEX(static_call_mutex);\n\nstatic void static_call_lock(void)\n{\n\tmutex_lock(&static_call_mutex);\n}\n\nstatic void static_call_unlock(void)\n{\n\tmutex_unlock(&static_call_mutex);\n}\n\nstatic inline void *static_call_addr(struct static_call_site *site)\n{\n\treturn (void *)((long)site->addr + (long)&site->addr);\n}\n\nstatic inline unsigned long __static_call_key(const struct static_call_site *site)\n{\n\treturn (long)site->key + (long)&site->key;\n}\n\nstatic inline struct static_call_key *static_call_key(const struct static_call_site *site)\n{\n\treturn (void *)(__static_call_key(site) & ~STATIC_CALL_SITE_FLAGS);\n}\n\n \nstatic inline bool static_call_is_init(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_INIT;\n}\n\nstatic inline bool static_call_is_tail(struct static_call_site *site)\n{\n\treturn __static_call_key(site) & STATIC_CALL_SITE_TAIL;\n}\n\nstatic inline void static_call_set_init(struct static_call_site *site)\n{\n\tsite->key = (__static_call_key(site) | STATIC_CALL_SITE_INIT) -\n\t\t    (long)&site->key;\n}\n\nstatic int static_call_site_cmp(const void *_a, const void *_b)\n{\n\tconst struct static_call_site *a = _a;\n\tconst struct static_call_site *b = _b;\n\tconst struct static_call_key *key_a = static_call_key(a);\n\tconst struct static_call_key *key_b = static_call_key(b);\n\n\tif (key_a < key_b)\n\t\treturn -1;\n\n\tif (key_a > key_b)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void static_call_site_swap(void *_a, void *_b, int size)\n{\n\tlong delta = (unsigned long)_a - (unsigned long)_b;\n\tstruct static_call_site *a = _a;\n\tstruct static_call_site *b = _b;\n\tstruct static_call_site tmp = *a;\n\n\ta->addr = b->addr  - delta;\n\ta->key  = b->key   - delta;\n\n\tb->addr = tmp.addr + delta;\n\tb->key  = tmp.key  + delta;\n}\n\nstatic inline void static_call_sort_entries(struct static_call_site *start,\n\t\t\t\t\t    struct static_call_site *stop)\n{\n\tsort(start, stop - start, sizeof(struct static_call_site),\n\t     static_call_site_cmp, static_call_site_swap);\n}\n\nstatic inline bool static_call_key_has_mods(struct static_call_key *key)\n{\n\treturn !(key->type & 1);\n}\n\nstatic inline struct static_call_mod *static_call_key_next(struct static_call_key *key)\n{\n\tif (!static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn key->mods;\n}\n\nstatic inline struct static_call_site *static_call_key_sites(struct static_call_key *key)\n{\n\tif (static_call_key_has_mods(key))\n\t\treturn NULL;\n\n\treturn (struct static_call_site *)(key->type & ~1);\n}\n\nvoid __static_call_update(struct static_call_key *key, void *tramp, void *func)\n{\n\tstruct static_call_site *site, *stop;\n\tstruct static_call_mod *site_mod, first;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tif (key->func == func)\n\t\tgoto done;\n\n\tkey->func = func;\n\n\tarch_static_call_transform(NULL, tramp, func, false);\n\n\t \n\tif (WARN_ON_ONCE(!static_call_initialized))\n\t\tgoto done;\n\n\tfirst = (struct static_call_mod){\n\t\t.next = static_call_key_next(key),\n\t\t.mod = NULL,\n\t\t.sites = static_call_key_sites(key),\n\t};\n\n\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {\n\t\tbool init = system_state < SYSTEM_RUNNING;\n\t\tstruct module *mod = site_mod->mod;\n\n\t\tif (!site_mod->sites) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tstop = __stop_static_call_sites;\n\n\t\tif (mod) {\n#ifdef CONFIG_MODULES\n\t\t\tstop = mod->static_call_sites +\n\t\t\t       mod->num_static_call_sites;\n\t\t\tinit = mod->state == MODULE_STATE_COMING;\n#endif\n\t\t}\n\n\t\tfor (site = site_mod->sites;\n\t\t     site < stop && static_call_key(site) == key; site++) {\n\t\t\tvoid *site_addr = static_call_addr(site);\n\n\t\t\tif (!init && static_call_is_init(site))\n\t\t\t\tcontinue;\n\n\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {\n\t\t\t\t \n\t\t\t\tWARN_ONCE(!static_call_is_init(site),\n\t\t\t\t\t  \"can't patch static call site at %pS\",\n\t\t\t\t\t  site_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tarch_static_call_transform(site_addr, NULL, func,\n\t\t\t\t\t\t   static_call_is_tail(site));\n\t\t}\n\t}\n\ndone:\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n}\nEXPORT_SYMBOL_GPL(__static_call_update);\n\nstatic int __static_call_init(struct module *mod,\n\t\t\t      struct static_call_site *start,\n\t\t\t      struct static_call_site *stop)\n{\n\tstruct static_call_site *site;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod;\n\n\tif (start == stop)\n\t\treturn 0;\n\n\tstatic_call_sort_entries(start, stop);\n\n\tfor (site = start; site < stop; site++) {\n\t\tvoid *site_addr = static_call_addr(site);\n\n\t\tif ((mod && within_module_init((unsigned long)site_addr, mod)) ||\n\t\t    (!mod && init_section_contains(site_addr, 1)))\n\t\t\tstatic_call_set_init(site);\n\n\t\tkey = static_call_key(site);\n\t\tif (key != prev_key) {\n\t\t\tprev_key = key;\n\n\t\t\t \n\t\t\tif (!mod) {\n\t\t\t\tkey->sites = site;\n\t\t\t\tkey->type |= 1;\n\t\t\t\tgoto do_transform;\n\t\t\t}\n\n\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\tif (!site_mod)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t \n\t\t\tif (static_call_key_sites(key)) {\n\t\t\t\tsite_mod->mod = NULL;\n\t\t\t\tsite_mod->next = NULL;\n\t\t\t\tsite_mod->sites = static_call_key_sites(key);\n\n\t\t\t\tkey->mods = site_mod;\n\n\t\t\t\tsite_mod = kzalloc(sizeof(*site_mod), GFP_KERNEL);\n\t\t\t\tif (!site_mod)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tsite_mod->mod = mod;\n\t\t\tsite_mod->sites = site;\n\t\t\tsite_mod->next = static_call_key_next(key);\n\t\t\tkey->mods = site_mod;\n\t\t}\n\ndo_transform:\n\t\tarch_static_call_transform(site_addr, NULL, key->func,\n\t\t\t\tstatic_call_is_tail(site));\n\t}\n\n\treturn 0;\n}\n\nstatic int addr_conflict(struct static_call_site *site, void *start, void *end)\n{\n\tunsigned long addr = (unsigned long)static_call_addr(site);\n\n\tif (addr <= (unsigned long)end &&\n\t    addr + CALL_INSN_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int __static_call_text_reserved(struct static_call_site *iter_start,\n\t\t\t\t       struct static_call_site *iter_stop,\n\t\t\t\t       void *start, void *end, bool init)\n{\n\tstruct static_call_site *iter = iter_start;\n\n\twhile (iter < iter_stop) {\n\t\tif (init || !static_call_is_init(iter)) {\n\t\t\tif (addr_conflict(iter, start, end))\n\t\t\t\treturn 1;\n\t\t}\n\t\titer++;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_MODULES\n\nstatic int __static_call_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\tint ret;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tif (!try_module_get(mod))\n\t\tmod = NULL;\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\tret = __static_call_text_reserved(mod->static_call_sites,\n\t\t\tmod->static_call_sites + mod->num_static_call_sites,\n\t\t\tstart, end, mod->state == MODULE_STATE_COMING);\n\n\tmodule_put(mod);\n\n\treturn ret;\n}\n\nstatic unsigned long tramp_key_lookup(unsigned long addr)\n{\n\tstruct static_call_tramp_key *start = __start_static_call_tramp_key;\n\tstruct static_call_tramp_key *stop = __stop_static_call_tramp_key;\n\tstruct static_call_tramp_key *tramp_key;\n\n\tfor (tramp_key = start; tramp_key != stop; tramp_key++) {\n\t\tunsigned long tramp;\n\n\t\ttramp = (long)tramp_key->tramp + (long)&tramp_key->tramp;\n\t\tif (tramp == addr)\n\t\t\treturn (long)tramp_key->key + (long)&tramp_key->key;\n\t}\n\n\treturn 0;\n}\n\nstatic int static_call_add_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = start + mod->num_static_call_sites;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site != stop; site++) {\n\t\tunsigned long s_key = __static_call_key(site);\n\t\tunsigned long addr = s_key & ~STATIC_CALL_SITE_FLAGS;\n\t\tunsigned long key;\n\n\t\t \n\t\tif (!kernel_text_address(addr))\n\t\t\tcontinue;\n\n\t\tkey = tramp_key_lookup(addr);\n\t\tif (!key) {\n\t\t\tpr_warn(\"Failed to fixup __raw_static_call() usage at: %ps\\n\",\n\t\t\t\tstatic_call_addr(site));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkey |= s_key & STATIC_CALL_SITE_FLAGS;\n\t\tsite->key = key - (long)&site->key;\n\t}\n\n\treturn __static_call_init(mod, start, stop);\n}\n\nstatic void static_call_del_module(struct module *mod)\n{\n\tstruct static_call_site *start = mod->static_call_sites;\n\tstruct static_call_site *stop = mod->static_call_sites +\n\t\t\t\t\tmod->num_static_call_sites;\n\tstruct static_call_key *key, *prev_key = NULL;\n\tstruct static_call_mod *site_mod, **prev;\n\tstruct static_call_site *site;\n\n\tfor (site = start; site < stop; site++) {\n\t\tkey = static_call_key(site);\n\t\tif (key == prev_key)\n\t\t\tcontinue;\n\n\t\tprev_key = key;\n\n\t\tfor (prev = &key->mods, site_mod = key->mods;\n\t\t     site_mod && site_mod->mod != mod;\n\t\t     prev = &site_mod->next, site_mod = site_mod->next)\n\t\t\t;\n\n\t\tif (!site_mod)\n\t\t\tcontinue;\n\n\t\t*prev = site_mod->next;\n\t\tkfree(site_mod);\n\t}\n}\n\nstatic int static_call_module_notify(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = static_call_add_module(mod);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Failed to allocate memory for static calls\");\n\t\t\tstatic_call_del_module(mod);\n\t\t}\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tstatic_call_del_module(mod);\n\t\tbreak;\n\t}\n\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic struct notifier_block static_call_module_nb = {\n\t.notifier_call = static_call_module_notify,\n};\n\n#else\n\nstatic inline int __static_call_mod_text_reserved(void *start, void *end)\n{\n\treturn 0;\n}\n\n#endif  \n\nint static_call_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __static_call_text_reserved(__start_static_call_sites,\n\t\t\t__stop_static_call_sites, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn __static_call_mod_text_reserved(start, end);\n}\n\nint __init static_call_init(void)\n{\n\tint ret;\n\n\t \n\tif (static_call_initialized == 1)\n\t\treturn 0;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\tret = __static_call_init(NULL, __start_static_call_sites,\n\t\t\t\t __stop_static_call_sites);\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n\n\tif (ret) {\n\t\tpr_err(\"Failed to allocate memory for static_call!\\n\");\n\t\tBUG();\n\t}\n\n#ifdef CONFIG_MODULES\n\tif (!static_call_initialized)\n\t\tregister_module_notifier(&static_call_module_nb);\n#endif\n\n\tstatic_call_initialized = 1;\n\treturn 0;\n}\nearly_initcall(static_call_init);\n\n#ifdef CONFIG_STATIC_CALL_SELFTEST\n\nstatic int func_a(int x)\n{\n\treturn x+1;\n}\n\nstatic int func_b(int x)\n{\n\treturn x+2;\n}\n\nDEFINE_STATIC_CALL(sc_selftest, func_a);\n\nstatic struct static_call_data {\n      int (*func)(int);\n      int val;\n      int expect;\n} static_call_data [] __initdata = {\n      { NULL,   2, 3 },\n      { func_b, 2, 4 },\n      { func_a, 2, 3 }\n};\n\nstatic int __init test_static_call_init(void)\n{\n      int i;\n\n      for (i = 0; i < ARRAY_SIZE(static_call_data); i++ ) {\n\t      struct static_call_data *scd = &static_call_data[i];\n\n              if (scd->func)\n                      static_call_update(sc_selftest, scd->func);\n\n              WARN_ON(static_call(sc_selftest)(scd->val) != scd->expect);\n      }\n\n      return 0;\n}\nearly_initcall(test_static_call_init);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}