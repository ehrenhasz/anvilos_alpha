{
  "module_name": "fs.c",
  "hash_id": "643680f4278012785fbf58d574e3902705778d0d8a6040661bef944e91da7720",
  "original_prompt": "Ingested from linux-6.6.14/kernel/gcov/fs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"gcov: \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include \"gcov.h\"\n\n \nstruct gcov_node {\n\tstruct list_head list;\n\tstruct list_head children;\n\tstruct list_head all;\n\tstruct gcov_node *parent;\n\tstruct gcov_info **loaded_info;\n\tstruct gcov_info *unloaded_info;\n\tstruct dentry *dentry;\n\tstruct dentry **links;\n\tint num_loaded;\n\tchar name[];\n};\n\nstatic const char objtree[] = OBJTREE;\nstatic const char srctree[] = SRCTREE;\nstatic struct gcov_node root_node;\nstatic LIST_HEAD(all_head);\nstatic DEFINE_MUTEX(node_lock);\n\n \nstatic int gcov_persist = 1;\n\nstatic int __init gcov_persist_setup(char *str)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(str, 0, &val)) {\n\t\tpr_warn(\"invalid gcov_persist parameter '%s'\\n\", str);\n\t\treturn 0;\n\t}\n\tgcov_persist = val;\n\tpr_info(\"setting gcov_persist to %d\\n\", gcov_persist);\n\n\treturn 1;\n}\n__setup(\"gcov_persist=\", gcov_persist_setup);\n\n#define ITER_STRIDE\tPAGE_SIZE\n\n \nstruct gcov_iterator {\n\tstruct gcov_info *info;\n\tsize_t size;\n\tloff_t pos;\n\tchar buffer[];\n};\n\n \nstatic struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\tsize_t size;\n\n\t \n\tsize = convert_to_gcda(NULL, info);\n\n\titer = kvmalloc(struct_size(iter, buffer, size), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->info = info;\n\titer->size = size;\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n}\n\n\n \nstatic void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tkvfree(iter);\n}\n\n \nstatic struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}\n\n \nstatic void gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}\n\n \nstatic int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}\n\n \nstatic void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t i;\n\n\tgcov_iter_start(seq->private);\n\tfor (i = 0; i < *pos; i++) {\n\t\tif (gcov_iter_next(seq->private))\n\t\t\treturn NULL;\n\t}\n\treturn seq->private;\n}\n\n \nstatic void *gcov_seq_next(struct seq_file *seq, void *data, loff_t *pos)\n{\n\tstruct gcov_iterator *iter = data;\n\n\t(*pos)++;\n\tif (gcov_iter_next(iter))\n\t\treturn NULL;\n\n\treturn iter;\n}\n\n \nstatic int gcov_seq_show(struct seq_file *seq, void *data)\n{\n\tstruct gcov_iterator *iter = data;\n\n\tif (gcov_iter_write(iter, seq))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void gcov_seq_stop(struct seq_file *seq, void *data)\n{\n\t \n}\n\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\n\n \nstatic struct gcov_info *get_node_info(struct gcov_node *node)\n{\n\tif (node->num_loaded > 0)\n\t\treturn node->loaded_info[0];\n\n\treturn node->unloaded_info;\n}\n\n \nstatic struct gcov_info *get_accumulated_info(struct gcov_node *node)\n{\n\tstruct gcov_info *info;\n\tint i = 0;\n\n\tif (node->unloaded_info)\n\t\tinfo = gcov_info_dup(node->unloaded_info);\n\telse\n\t\tinfo = gcov_info_dup(node->loaded_info[i++]);\n\tif (!info)\n\t\treturn NULL;\n\tfor (; i < node->num_loaded; i++)\n\t\tgcov_info_add(info, node->loaded_info[i]);\n\n\treturn info;\n}\n\n \nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t \n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}\n\n \nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}\n\n \nstatic struct gcov_node *get_node_by_name(const char *name)\n{\n\tstruct gcov_node *node;\n\tstruct gcov_info *info;\n\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tinfo = get_node_info(node);\n\t\tif (info && (strcmp(gcov_info_filename(info), name) == 0))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void reset_node(struct gcov_node *node)\n{\n\tint i;\n\n\tif (node->unloaded_info)\n\t\tgcov_info_reset(node->unloaded_info);\n\tfor (i = 0; i < node->num_loaded; i++)\n\t\tgcov_info_reset(node->loaded_info[i]);\n}\n\nstatic void remove_node(struct gcov_node *node);\n\n \nstatic ssize_t gcov_seq_write(struct file *file, const char __user *addr,\n\t\t\t      size_t len, loff_t *pos)\n{\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tstruct gcov_node *node;\n\n\tseq = file->private_data;\n\tinfo = gcov_iter_get_info(seq->private);\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tif (node) {\n\t\t \n\t\tif (node->num_loaded == 0)\n\t\t\tremove_node(node);\n\t\telse\n\t\t\treset_node(node);\n\t}\n\t \n\tgcov_info_reset(info);\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}\n\n \nstatic char *link_target(const char *dir, const char *path, const char *ext)\n{\n\tchar *target;\n\tchar *old_ext;\n\tchar *copy;\n\n\tcopy = kstrdup(path, GFP_KERNEL);\n\tif (!copy)\n\t\treturn NULL;\n\told_ext = strrchr(copy, '.');\n\tif (old_ext)\n\t\t*old_ext = '\\0';\n\tif (dir)\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s/%s.%s\", dir, copy, ext);\n\telse\n\t\ttarget = kasprintf(GFP_KERNEL, \"%s.%s\", copy, ext);\n\tkfree(copy);\n\n\treturn target;\n}\n\n \nstatic char *get_link_target(const char *filename, const struct gcov_link *ext)\n{\n\tconst char *rel;\n\tchar *result;\n\n\tif (strncmp(filename, objtree, strlen(objtree)) == 0) {\n\t\trel = filename + strlen(objtree) + 1;\n\t\tif (ext->dir == SRC_TREE)\n\t\t\tresult = link_target(srctree, rel, ext->ext);\n\t\telse\n\t\t\tresult = link_target(objtree, rel, ext->ext);\n\t} else {\n\t\t \n\t\tresult = link_target(NULL, filename, ext->ext);\n\t}\n\n\treturn result;\n}\n\n#define SKEW_PREFIX\t\".tmp_\"\n\n \nstatic const char *deskew(const char *basename)\n{\n\tif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\n\t\treturn basename + sizeof(SKEW_PREFIX) - 1;\n\treturn basename;\n}\n\n \nstatic void add_links(struct gcov_node *node, struct dentry *parent)\n{\n\tconst char *basename;\n\tchar *target;\n\tint num;\n\tint i;\n\n\tfor (num = 0; gcov_link[num].ext; num++)\n\t\t ;\n\tnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; i < num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->links[i] = debugfs_create_symlink(deskew(basename),\n\t\t\t\t\t\t\tparent,\ttarget);\n\t\tkfree(target);\n\t}\n\n\treturn;\nout_err:\n\tkfree(target);\n\twhile (i-- > 0)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}\n\nstatic const struct file_operations gcov_data_fops = {\n\t.open\t\t= gcov_seq_open,\n\t.release\t= gcov_seq_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= gcov_seq_write,\n};\n\n \nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\n\t\t      const char *name, struct gcov_node *parent)\n{\n\tINIT_LIST_HEAD(&node->list);\n\tINIT_LIST_HEAD(&node->children);\n\tINIT_LIST_HEAD(&node->all);\n\tif (node->loaded_info) {\n\t\tnode->loaded_info[0] = info;\n\t\tnode->num_loaded = 1;\n\t}\n\tnode->parent = parent;\n\tif (name)\n\t\tstrcpy(node->name, name);\n}\n\n \nstatic struct gcov_node *new_node(struct gcov_node *parent,\n\t\t\t\t  struct gcov_info *info, const char *name)\n{\n\tstruct gcov_node *node;\n\n\tnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\n\tif (!node)\n\t\tgoto err_nomem;\n\tif (info) {\n\t\tnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!node->loaded_info)\n\t\t\tgoto err_nomem;\n\t}\n\tinit_node(node, info, name, parent);\n\t \n\tif (info) {\n\t\tnode->dentry = debugfs_create_file(deskew(node->name), 0600,\n\t\t\t\t\tparent->dentry, node, &gcov_data_fops);\n\t} else\n\t\tnode->dentry = debugfs_create_dir(node->name, parent->dentry);\n\tif (info)\n\t\tadd_links(node, parent->dentry);\n\tlist_add(&node->list, &parent->children);\n\tlist_add(&node->all, &all_head);\n\n\treturn node;\n\nerr_nomem:\n\tkfree(node);\n\tpr_warn(\"out of memory\\n\");\n\treturn NULL;\n}\n\n \nstatic void remove_links(struct gcov_node *node)\n{\n\tint i;\n\n\tif (!node->links)\n\t\treturn;\n\tfor (i = 0; gcov_link[i].ext; i++)\n\t\tdebugfs_remove(node->links[i]);\n\tkfree(node->links);\n\tnode->links = NULL;\n}\n\n \nstatic void release_node(struct gcov_node *node)\n{\n\tlist_del(&node->list);\n\tlist_del(&node->all);\n\tdebugfs_remove(node->dentry);\n\tremove_links(node);\n\tkfree(node->loaded_info);\n\tif (node->unloaded_info)\n\t\tgcov_info_free(node->unloaded_info);\n\tkfree(node);\n}\n\n \nstatic void remove_node(struct gcov_node *node)\n{\n\tstruct gcov_node *parent;\n\n\twhile ((node != &root_node) && list_empty(&node->children)) {\n\t\tparent = node->parent;\n\t\trelease_node(node);\n\t\tnode = parent;\n\t}\n}\n\n \nstatic struct gcov_node *get_child_by_name(struct gcov_node *parent,\n\t\t\t\t\t   const char *name)\n{\n\tstruct gcov_node *node;\n\n\tlist_for_each_entry(node, &parent->children, list) {\n\t\tif (strcmp(node->name, name) == 0)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic ssize_t reset_write(struct file *file, const char __user *addr,\n\t\t\t   size_t len, loff_t *pos)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\nrestart:\n\tlist_for_each_entry(node, &all_head, all) {\n\t\tif (node->num_loaded > 0)\n\t\t\treset_node(node);\n\t\telse if (list_empty(&node->children)) {\n\t\t\tremove_node(node);\n\t\t\t \n\t\t\tgoto restart;\n\t\t}\n\t}\n\tmutex_unlock(&node_lock);\n\n\treturn len;\n}\n\n \nstatic ssize_t reset_read(struct file *file, char __user *addr, size_t len,\n\t\t\t  loff_t *pos)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct file_operations gcov_reset_fops = {\n\t.write\t= reset_write,\n\t.read\t= reset_read,\n\t.llseek = noop_llseek,\n};\n\n \nstatic void add_node(struct gcov_info *info)\n{\n\tchar *filename;\n\tchar *curr;\n\tchar *next;\n\tstruct gcov_node *parent;\n\tstruct gcov_node *node;\n\n\tfilename = kstrdup(gcov_info_filename(info), GFP_KERNEL);\n\tif (!filename)\n\t\treturn;\n\tparent = &root_node;\n\t \n\tfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\n\t\tif (curr == next)\n\t\t\tcontinue;\n\t\t*next = 0;\n\t\tif (strcmp(curr, \".\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(curr, \"..\") == 0) {\n\t\t\tif (!parent->parent)\n\t\t\t\tgoto err_remove;\n\t\t\tparent = parent->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tnode = get_child_by_name(parent, curr);\n\t\tif (!node) {\n\t\t\tnode = new_node(parent, NULL, curr);\n\t\t\tif (!node)\n\t\t\t\tgoto err_remove;\n\t\t}\n\t\tparent = node;\n\t}\n\t \n\tnode = new_node(parent, info, curr);\n\tif (!node)\n\t\tgoto err_remove;\nout:\n\tkfree(filename);\n\treturn;\n\nerr_remove:\n\tremove_node(parent);\n\tgoto out;\n}\n\n \nstatic void add_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tstruct gcov_info **loaded_info;\n\tint num = node->num_loaded;\n\n\t \n\tloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\n\tif (!loaded_info) {\n\t\tpr_warn(\"could not add '%s' (out of memory)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tmemcpy(loaded_info, node->loaded_info,\n\t       num * sizeof(struct gcov_info *));\n\tloaded_info[num] = info;\n\t \n\tif (num == 0) {\n\t\t \n\t\tif (!gcov_info_is_compatible(node->unloaded_info, info)) {\n\t\t\tpr_warn(\"discarding saved data for %s \"\n\t\t\t\t\"(incompatible version)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t\tgcov_info_free(node->unloaded_info);\n\t\t\tnode->unloaded_info = NULL;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\n\t\t\tpr_warn(\"could not add '%s' (incompatible \"\n\t\t\t\t\"version)\\n\", gcov_info_filename(info));\n\t\t\tkfree(loaded_info);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tkfree(node->loaded_info);\n\tnode->loaded_info = loaded_info;\n\tnode->num_loaded = num + 1;\n}\n\n \nstatic int get_info_index(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < node->num_loaded; i++) {\n\t\tif (node->loaded_info[i] == info)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}\n\n \nstatic void save_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tif (node->unloaded_info)\n\t\tgcov_info_add(node->unloaded_info, info);\n\telse {\n\t\tnode->unloaded_info = gcov_info_dup(info);\n\t\tif (!node->unloaded_info) {\n\t\t\tpr_warn(\"could not save data for '%s' \"\n\t\t\t\t\"(out of memory)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t}\n}\n\n \nstatic void remove_info(struct gcov_node *node, struct gcov_info *info)\n{\n\tint i;\n\n\ti = get_info_index(node, info);\n\tif (i < 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t \n\tnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\n\tnode->num_loaded--;\n\tif (node->num_loaded > 0)\n\t\treturn;\n\t \n\tkfree(node->loaded_info);\n\tnode->loaded_info = NULL;\n\tnode->num_loaded = 0;\n\tif (!node->unloaded_info)\n\t\tremove_node(node);\n}\n\n \nvoid gcov_event(enum gcov_action action, struct gcov_info *info)\n{\n\tstruct gcov_node *node;\n\n\tmutex_lock(&node_lock);\n\tnode = get_node_by_name(gcov_info_filename(info));\n\tswitch (action) {\n\tcase GCOV_ADD:\n\t\tif (node)\n\t\t\tadd_info(node, info);\n\t\telse\n\t\t\tadd_node(info);\n\t\tbreak;\n\tcase GCOV_REMOVE:\n\t\tif (node)\n\t\t\tremove_info(node, info);\n\t\telse {\n\t\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\t\tgcov_info_filename(info));\n\t\t}\n\t\tbreak;\n\t}\n\tmutex_unlock(&node_lock);\n}\n\n \nstatic __init int gcov_fs_init(void)\n{\n\tinit_node(&root_node, NULL, NULL, NULL);\n\t \n\troot_node.dentry = debugfs_create_dir(\"gcov\", NULL);\n\t \n\tdebugfs_create_file(\"reset\", 0600, root_node.dentry, NULL,\n\t\t\t    &gcov_reset_fops);\n\t \n\tgcov_enable_events();\n\treturn 0;\n}\ndevice_initcall(gcov_fs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}