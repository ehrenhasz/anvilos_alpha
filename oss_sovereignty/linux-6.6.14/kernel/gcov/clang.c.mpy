{
  "module_name": "clang.c",
  "hash_id": "d2b6801f8f96578daf12773bdffe919209094a93eaeded2c54cebc1862fcba77",
  "original_prompt": "Ingested from linux-6.6.14/kernel/gcov/clang.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"gcov: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include \"gcov.h\"\n\ntypedef void (*llvm_gcov_callback)(void);\n\nstruct gcov_info {\n\tstruct list_head head;\n\n\tconst char *filename;\n\tunsigned int version;\n\tu32 checksum;\n\n\tstruct list_head functions;\n};\n\nstruct gcov_fn_info {\n\tstruct list_head head;\n\n\tu32 ident;\n\tu32 checksum;\n\tu32 cfg_checksum;\n\n\tu32 num_counters;\n\tu64 *counters;\n};\n\nstatic struct gcov_info *current_info;\n\nstatic LIST_HEAD(clang_gcov_list);\n\nvoid llvm_gcov_init(llvm_gcov_callback writeout, llvm_gcov_callback flush)\n{\n\tstruct gcov_info *info = kzalloc(sizeof(*info), GFP_KERNEL);\n\n\tif (!info)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&info->head);\n\tINIT_LIST_HEAD(&info->functions);\n\n\tmutex_lock(&gcov_lock);\n\n\tlist_add_tail(&info->head, &clang_gcov_list);\n\tcurrent_info = info;\n\twriteout();\n\tcurrent_info = NULL;\n\tif (gcov_events_enabled)\n\t\tgcov_event(GCOV_ADD, info);\n\n\tmutex_unlock(&gcov_lock);\n}\nEXPORT_SYMBOL(llvm_gcov_init);\n\nvoid llvm_gcda_start_file(const char *orig_filename, u32 version, u32 checksum)\n{\n\tcurrent_info->filename = orig_filename;\n\tcurrent_info->version = version;\n\tcurrent_info->checksum = checksum;\n}\nEXPORT_SYMBOL(llvm_gcda_start_file);\n\nvoid llvm_gcda_emit_function(u32 ident, u32 func_checksum, u32 cfg_checksum)\n{\n\tstruct gcov_fn_info *info = kzalloc(sizeof(*info), GFP_KERNEL);\n\n\tif (!info)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&info->head);\n\tinfo->ident = ident;\n\tinfo->checksum = func_checksum;\n\tinfo->cfg_checksum = cfg_checksum;\n\tlist_add_tail(&info->head, &current_info->functions);\n}\nEXPORT_SYMBOL(llvm_gcda_emit_function);\n\nvoid llvm_gcda_emit_arcs(u32 num_counters, u64 *counters)\n{\n\tstruct gcov_fn_info *info = list_last_entry(&current_info->functions,\n\t\t\tstruct gcov_fn_info, head);\n\n\tinfo->num_counters = num_counters;\n\tinfo->counters = counters;\n}\nEXPORT_SYMBOL(llvm_gcda_emit_arcs);\n\nvoid llvm_gcda_summary_info(void)\n{\n}\nEXPORT_SYMBOL(llvm_gcda_summary_info);\n\nvoid llvm_gcda_end_file(void)\n{\n}\nEXPORT_SYMBOL(llvm_gcda_end_file);\n\n \nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}\n\n \nunsigned int gcov_info_version(struct gcov_info *info)\n{\n\treturn info->version;\n}\n\n \nstruct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn list_first_entry_or_null(&clang_gcov_list,\n\t\t\t\tstruct gcov_info, head);\n\tif (list_is_last(&info->head, &clang_gcov_list))\n\t\treturn NULL;\n\treturn list_next_entry(info, head);\n}\n\n \nvoid gcov_info_link(struct gcov_info *info)\n{\n\tlist_add_tail(&info->head, &clang_gcov_list);\n}\n\n \nvoid gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\n{\n\t \n\t__list_del_entry(&info->head);\n}\n\n \nbool gcov_info_within_module(struct gcov_info *info, struct module *mod)\n{\n\treturn within_module((unsigned long)info->filename, mod);\n}\n\n \nconst struct gcov_link gcov_link[] = {\n\t{ OBJ_TREE, \"gcno\" },\t \n\t{ 0, NULL},\n};\n\n \nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fn;\n\n\tlist_for_each_entry(fn, &info->functions, head)\n\t\tmemset(fn->counters, 0,\n\t\t\t\tsizeof(fn->counters[0]) * fn->num_counters);\n}\n\n \nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\tstruct gcov_fn_info *fn_ptr1 = list_first_entry_or_null(\n\t\t\t&info1->functions, struct gcov_fn_info, head);\n\tstruct gcov_fn_info *fn_ptr2 = list_first_entry_or_null(\n\t\t\t&info2->functions, struct gcov_fn_info, head);\n\n\tif (info1->checksum != info2->checksum)\n\t\treturn false;\n\tif (!fn_ptr1)\n\t\treturn fn_ptr1 == fn_ptr2;\n\twhile (!list_is_last(&fn_ptr1->head, &info1->functions) &&\n\t\t!list_is_last(&fn_ptr2->head, &info2->functions)) {\n\t\tif (fn_ptr1->checksum != fn_ptr2->checksum)\n\t\t\treturn false;\n\t\tif (fn_ptr1->cfg_checksum != fn_ptr2->cfg_checksum)\n\t\t\treturn false;\n\t\tfn_ptr1 = list_next_entry(fn_ptr1, head);\n\t\tfn_ptr2 = list_next_entry(fn_ptr2, head);\n\t}\n\treturn list_is_last(&fn_ptr1->head, &info1->functions) &&\n\t\tlist_is_last(&fn_ptr2->head, &info2->functions);\n}\n\n \nvoid gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_fn_info *dfn_ptr;\n\tstruct gcov_fn_info *sfn_ptr = list_first_entry_or_null(&src->functions,\n\t\t\tstruct gcov_fn_info, head);\n\n\tlist_for_each_entry(dfn_ptr, &dst->functions, head) {\n\t\tu32 i;\n\n\t\tfor (i = 0; i < sfn_ptr->num_counters; i++)\n\t\t\tdfn_ptr->counters[i] += sfn_ptr->counters[i];\n\n\t\tsfn_ptr = list_next_entry(sfn_ptr, head);\n\t}\n}\n\nstatic struct gcov_fn_info *gcov_fn_info_dup(struct gcov_fn_info *fn)\n{\n\tsize_t cv_size;  \n\tstruct gcov_fn_info *fn_dup = kmemdup(fn, sizeof(*fn),\n\t\t\tGFP_KERNEL);\n\tif (!fn_dup)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&fn_dup->head);\n\n\tcv_size = fn->num_counters * sizeof(fn->counters[0]);\n\tfn_dup->counters = kvmalloc(cv_size, GFP_KERNEL);\n\tif (!fn_dup->counters) {\n\t\tkfree(fn_dup);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(fn_dup->counters, fn->counters, cv_size);\n\n\treturn fn_dup;\n}\n\n \nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_fn_info *fn;\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&dup->head);\n\tINIT_LIST_HEAD(&dup->functions);\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err;\n\n\tlist_for_each_entry(fn, &info->functions, head) {\n\t\tstruct gcov_fn_info *fn_dup = gcov_fn_info_dup(fn);\n\n\t\tif (!fn_dup)\n\t\t\tgoto err;\n\t\tlist_add_tail(&fn_dup->head, &dup->functions);\n\t}\n\n\treturn dup;\n\nerr:\n\tgcov_info_free(dup);\n\treturn NULL;\n}\n\n \nvoid gcov_info_free(struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fn, *tmp;\n\n\tlist_for_each_entry_safe(fn, tmp, &info->functions, head) {\n\t\tkvfree(fn->counters);\n\t\tlist_del(&fn->head);\n\t\tkfree(fn);\n\t}\n\tkfree(info->filename);\n\tkfree(info);\n}\n\n \nsize_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tsize_t pos = 0;\n\n\t \n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->checksum);\n\n\tlist_for_each_entry(fi_ptr, &info->functions, head) {\n\t\tu32 i;\n\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, 3);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_COUNTER_BASE);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->num_counters * 2);\n\t\tfor (i = 0; i < fi_ptr->num_counters; i++)\n\t\t\tpos += store_gcov_u64(buffer, pos, fi_ptr->counters[i]);\n\t}\n\n\treturn pos;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}