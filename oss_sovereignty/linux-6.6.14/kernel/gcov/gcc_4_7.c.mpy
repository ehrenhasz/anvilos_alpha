{
  "module_name": "gcc_4_7.c",
  "hash_id": "c778073e9a8602dd02f8bce96ffffb0e8a550795382706e5653e15852d9a8017",
  "original_prompt": "Ingested from linux-6.6.14/kernel/gcov/gcc_4_7.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include \"gcov.h\"\n\n#if (__GNUC__ >= 10)\n#define GCOV_COUNTERS\t\t\t8\n#elif (__GNUC__ >= 7)\n#define GCOV_COUNTERS\t\t\t9\n#elif (__GNUC__ > 5) || (__GNUC__ == 5 && __GNUC_MINOR__ >= 1)\n#define GCOV_COUNTERS\t\t\t10\n#else\n#define GCOV_COUNTERS\t\t\t9\n#endif\n\n#define GCOV_TAG_FUNCTION_LENGTH\t3\n\n \n#if (__GNUC__ >= 12)\n#define GCOV_UNIT_SIZE\t\t\t\t4\n#else\n#define GCOV_UNIT_SIZE\t\t\t\t1\n#endif\n\nstatic struct gcov_info *gcov_info_head;\n\n \nstruct gcov_ctr_info {\n\tunsigned int num;\n\tgcov_type *values;\n};\n\n \nstruct gcov_fn_info {\n\tconst struct gcov_info *key;\n\tunsigned int ident;\n\tunsigned int lineno_checksum;\n\tunsigned int cfg_checksum;\n\tstruct gcov_ctr_info ctrs[];\n};\n\n \nstruct gcov_info {\n\tunsigned int version;\n\tstruct gcov_info *next;\n\tunsigned int stamp;\n  \n#if (__GNUC__ >= 12)\n\tunsigned int checksum;\n#endif\n\tconst char *filename;\n\tvoid (*merge[GCOV_COUNTERS])(gcov_type *, unsigned int);\n\tunsigned int n_functions;\n\tstruct gcov_fn_info **functions;\n};\n\n \nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}\n\n \nunsigned int gcov_info_version(struct gcov_info *info)\n{\n\treturn info->version;\n}\n\n \nstruct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}\n\n \nvoid gcov_info_link(struct gcov_info *info)\n{\n\tinfo->next = gcov_info_head;\n\tgcov_info_head = info;\n}\n\n \nvoid gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\n{\n\tif (prev)\n\t\tprev->next = info->next;\n\telse\n\t\tgcov_info_head = info->next;\n}\n\n \nbool gcov_info_within_module(struct gcov_info *info, struct module *mod)\n{\n\treturn within_module((unsigned long)info, mod);\n}\n\n \nconst struct gcov_link gcov_link[] = {\n\t{ OBJ_TREE, \"gcno\" },\t \n\t{ 0, NULL},\n};\n\n \nstatic int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}\n\n \nstatic unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}\n\n \nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}\n\n \nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}\n\n \nvoid gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}\n\n \nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr;  \n\tstruct gcov_ctr_info *sci_ptr;  \n\tunsigned int active;\n\tunsigned int fi_idx;  \n\tunsigned int ct_idx;  \n\tsize_t fi_size;  \n\tsize_t cv_size;  \n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = kvmalloc(cv_size, GFP_KERNEL);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}\n\n \nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tkvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}\n\n \nsize_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t \n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n#if (__GNUC__ >= 12)\n\t \n\tpos += store_gcov_u32(buffer, pos, 0);\n#endif\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t \n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\tGCOV_TAG_FUNCTION_LENGTH * GCOV_UNIT_SIZE);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\tci_ptr->num * 2 * GCOV_UNIT_SIZE);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}