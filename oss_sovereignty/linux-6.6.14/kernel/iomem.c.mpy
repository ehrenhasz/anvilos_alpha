{
  "module_name": "iomem.c",
  "hash_id": "9bc0cd44db2d6ccf5f6cc9c81dfa2513c360dbd268f067d02f06f988c45016d1",
  "original_prompt": "Ingested from linux-6.6.14/kernel/iomem.c",
  "human_readable_source": " \n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/ioremap.h>\n\n#ifndef arch_memremap_wb\nstatic void *arch_memremap_wb(resource_size_t offset, unsigned long size)\n{\n#ifdef ioremap_cache\n\treturn (__force void *)ioremap_cache(offset, size);\n#else\n\treturn (__force void *)ioremap(offset, size);\n#endif\n}\n#endif\n\n#ifndef arch_memremap_can_ram_remap\nstatic bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,\n\t\t\t\t\tunsigned long flags)\n{\n\treturn true;\n}\n#endif\n\nstatic void *try_ram_remap(resource_size_t offset, size_t size,\n\t\t\t   unsigned long flags)\n{\n\tunsigned long pfn = PHYS_PFN(offset);\n\n\t \n\tif (pfn_valid(pfn) && !PageHighMem(pfn_to_page(pfn)) &&\n\t    arch_memremap_can_ram_remap(offset, size, flags))\n\t\treturn __va(offset);\n\n\treturn NULL;  \n}\n\n \nvoid *memremap(resource_size_t offset, size_t size, unsigned long flags)\n{\n\tint is_ram = region_intersects(offset, size,\n\t\t\t\t       IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);\n\tvoid *addr = NULL;\n\n\tif (!flags)\n\t\treturn NULL;\n\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"memremap attempted on mixed range %pa size: %#lx\\n\",\n\t\t\t\t&offset, (unsigned long) size);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (flags & MEMREMAP_WB) {\n\t\t \n\t\tif (is_ram == REGION_INTERSECTS)\n\t\t\taddr = try_ram_remap(offset, size, flags);\n\t\tif (!addr)\n\t\t\taddr = arch_memremap_wb(offset, size);\n\t}\n\n\t \n\tif (!addr && is_ram == REGION_INTERSECTS && flags != MEMREMAP_WB) {\n\t\tWARN_ONCE(1, \"memremap attempted on ram %pa size: %#lx\\n\",\n\t\t\t\t&offset, (unsigned long) size);\n\t\treturn NULL;\n\t}\n\n\tif (!addr && (flags & MEMREMAP_WT))\n\t\taddr = ioremap_wt(offset, size);\n\n\tif (!addr && (flags & MEMREMAP_WC))\n\t\taddr = ioremap_wc(offset, size);\n\n\treturn addr;\n}\nEXPORT_SYMBOL(memremap);\n\nvoid memunmap(void *addr)\n{\n\tif (is_ioremap_addr(addr))\n\t\tiounmap((void __iomem *) addr);\n}\nEXPORT_SYMBOL(memunmap);\n\nstatic void devm_memremap_release(struct device *dev, void *res)\n{\n\tmemunmap(*(void **)res);\n}\n\nstatic int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}\n\nvoid *devm_memremap(struct device *dev, resource_size_t offset,\n\t\tsize_t size, unsigned long flags)\n{\n\tvoid **ptr, *addr;\n\n\tptr = devres_alloc_node(devm_memremap_release, sizeof(*ptr), GFP_KERNEL,\n\t\t\tdev_to_node(dev));\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taddr = memremap(offset, size, flags);\n\tif (addr) {\n\t\t*ptr = addr;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\treturn addr;\n}\nEXPORT_SYMBOL(devm_memremap);\n\nvoid devm_memunmap(struct device *dev, void *addr)\n{\n\tWARN_ON(devres_release(dev, devm_memremap_release,\n\t\t\t\tdevm_memremap_match, addr));\n}\nEXPORT_SYMBOL(devm_memunmap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}