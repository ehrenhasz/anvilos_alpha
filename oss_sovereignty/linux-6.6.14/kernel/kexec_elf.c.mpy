{
  "module_name": "kexec_elf.c",
  "hash_id": "aaf3de2362e998d2533a1f9e90b4e0b4bb181c1dc6171aa3bbbd0820ddf36e0f",
  "original_prompt": "Ingested from linux-6.6.14/kernel/kexec_elf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"kexec_elf: \" fmt\n\n#include <linux/elf.h>\n#include <linux/kexec.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline bool elf_is_elf_file(const struct elfhdr *ehdr)\n{\n\treturn memcmp(ehdr->e_ident, ELFMAG, SELFMAG) == 0;\n}\n\nstatic uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le64_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be64_to_cpu(value);\n\n\treturn value;\n}\n\nstatic uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le32_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be32_to_cpu(value);\n\n\treturn value;\n}\n\nstatic uint16_t elf16_to_cpu(const struct elfhdr *ehdr, uint16_t value)\n{\n\tif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\n\t\tvalue = le16_to_cpu(value);\n\telse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\n\t\tvalue = be16_to_cpu(value);\n\n\treturn value;\n}\n\n \nstatic bool elf_is_ehdr_sane(const struct elfhdr *ehdr, size_t buf_len)\n{\n\tif (ehdr->e_phnum > 0 && ehdr->e_phentsize != sizeof(struct elf_phdr)) {\n\t\tpr_debug(\"Bad program header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_shnum > 0 &&\n\t\t   ehdr->e_shentsize != sizeof(struct elf_shdr)) {\n\t\tpr_debug(\"Bad section header size.\\n\");\n\t\treturn false;\n\t} else if (ehdr->e_ident[EI_VERSION] != EV_CURRENT ||\n\t\t   ehdr->e_version != EV_CURRENT) {\n\t\tpr_debug(\"Unknown ELF version.\\n\");\n\t\treturn false;\n\t}\n\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tsize_t phdr_size;\n\n\t\t \n\t\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\t\t \n\t\tif (ehdr->e_phoff + phdr_size < ehdr->e_phoff) {\n\t\t\tpr_debug(\"Program headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_phoff + phdr_size > buf_len) {\n\t\t\tpr_debug(\"Program headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\n\t\tsize_t shdr_size;\n\n\t\t \n\t\tshdr_size = sizeof(struct elf_shdr) * ehdr->e_shnum;\n\n\t\t \n\t\tif (ehdr->e_shoff + shdr_size < ehdr->e_shoff) {\n\t\t\tpr_debug(\"Section headers at invalid location.\\n\");\n\t\t\treturn false;\n\t\t} else if (ehdr->e_shoff + shdr_size > buf_len) {\n\t\t\tpr_debug(\"Section headers truncated.\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int elf_read_ehdr(const char *buf, size_t len, struct elfhdr *ehdr)\n{\n\tstruct elfhdr *buf_ehdr;\n\n\tif (len < sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Buffer is too small to hold ELF header.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tmemset(ehdr, 0, sizeof(*ehdr));\n\tmemcpy(ehdr->e_ident, buf, sizeof(ehdr->e_ident));\n\tif (!elf_is_elf_file(ehdr)) {\n\t\tpr_debug(\"No ELF header magic.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {\n\t\tpr_debug(\"Not a supported ELF class.\\n\");\n\t\treturn -ENOEXEC;\n\t} else  if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB &&\n\t\tehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\n\t\tpr_debug(\"Not a supported ELF data format.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tbuf_ehdr = (struct elfhdr *) buf;\n\tif (elf16_to_cpu(ehdr, buf_ehdr->e_ehsize) != sizeof(*buf_ehdr)) {\n\t\tpr_debug(\"Bad ELF header size.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tehdr->e_type      = elf16_to_cpu(ehdr, buf_ehdr->e_type);\n\tehdr->e_machine   = elf16_to_cpu(ehdr, buf_ehdr->e_machine);\n\tehdr->e_version   = elf32_to_cpu(ehdr, buf_ehdr->e_version);\n\tehdr->e_flags     = elf32_to_cpu(ehdr, buf_ehdr->e_flags);\n\tehdr->e_phentsize = elf16_to_cpu(ehdr, buf_ehdr->e_phentsize);\n\tehdr->e_phnum     = elf16_to_cpu(ehdr, buf_ehdr->e_phnum);\n\tehdr->e_shentsize = elf16_to_cpu(ehdr, buf_ehdr->e_shentsize);\n\tehdr->e_shnum     = elf16_to_cpu(ehdr, buf_ehdr->e_shnum);\n\tehdr->e_shstrndx  = elf16_to_cpu(ehdr, buf_ehdr->e_shstrndx);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tehdr->e_entry = elf64_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf64_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf64_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tehdr->e_entry = elf32_to_cpu(ehdr, buf_ehdr->e_entry);\n\t\tehdr->e_phoff = elf32_to_cpu(ehdr, buf_ehdr->e_phoff);\n\t\tehdr->e_shoff = elf32_to_cpu(ehdr, buf_ehdr->e_shoff);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_ehdr_sane(ehdr, len) ? 0 : -ENOEXEC;\n}\n\n \nstatic bool elf_is_phdr_sane(const struct elf_phdr *phdr, size_t buf_len)\n{\n\n\tif (phdr->p_offset + phdr->p_filesz < phdr->p_offset) {\n\t\tpr_debug(\"ELF segment location wraps around.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_offset + phdr->p_filesz > buf_len) {\n\t\tpr_debug(\"ELF segment not in file.\\n\");\n\t\treturn false;\n\t} else if (phdr->p_paddr + phdr->p_memsz < phdr->p_paddr) {\n\t\tpr_debug(\"ELF segment address wraps around.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int elf_read_phdr(const char *buf, size_t len,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t int idx)\n{\n\t \n\tstruct elf_phdr *phdr = (struct elf_phdr *) &elf_info->proghdrs[idx];\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\tconst char *pbuf;\n\tstruct elf_phdr *buf_phdr;\n\n\tpbuf = buf + elf_info->ehdr->e_phoff + (idx * sizeof(*buf_phdr));\n\tbuf_phdr = (struct elf_phdr *) pbuf;\n\n\tphdr->p_type   = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_type);\n\tphdr->p_flags  = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_flags);\n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tcase ELFCLASS64:\n\t\tphdr->p_offset = elf64_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf64_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf64_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf64_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf64_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf64_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tcase ELFCLASS32:\n\t\tphdr->p_offset = elf32_to_cpu(ehdr, buf_phdr->p_offset);\n\t\tphdr->p_paddr  = elf32_to_cpu(ehdr, buf_phdr->p_paddr);\n\t\tphdr->p_vaddr  = elf32_to_cpu(ehdr, buf_phdr->p_vaddr);\n\t\tphdr->p_filesz = elf32_to_cpu(ehdr, buf_phdr->p_filesz);\n\t\tphdr->p_memsz  = elf32_to_cpu(ehdr, buf_phdr->p_memsz);\n\t\tphdr->p_align  = elf32_to_cpu(ehdr, buf_phdr->p_align);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"Unknown ELF class.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn elf_is_phdr_sane(phdr, len) ? 0 : -ENOEXEC;\n}\n\n \nstatic int elf_read_phdrs(const char *buf, size_t len,\n\t\t\t  struct kexec_elf_info *elf_info)\n{\n\tsize_t phdr_size, i;\n\tconst struct elfhdr *ehdr = elf_info->ehdr;\n\n\t \n\tphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\n\n\telf_info->proghdrs = kzalloc(phdr_size, GFP_KERNEL);\n\tif (!elf_info->proghdrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tint ret;\n\n\t\tret = elf_read_phdr(buf, len, elf_info, i);\n\t\tif (ret) {\n\t\t\tkfree(elf_info->proghdrs);\n\t\t\telf_info->proghdrs = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int elf_read_from_buffer(const char *buf, size_t len,\n\t\t\t\tstruct elfhdr *ehdr,\n\t\t\t\tstruct kexec_elf_info *elf_info)\n{\n\tint ret;\n\n\tret = elf_read_ehdr(buf, len, ehdr);\n\tif (ret)\n\t\treturn ret;\n\n\telf_info->buffer = buf;\n\telf_info->ehdr = ehdr;\n\tif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\n\t\tret = elf_read_phdrs(buf, len, elf_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nvoid kexec_free_elf_info(struct kexec_elf_info *elf_info)\n{\n\tkfree(elf_info->proghdrs);\n\tmemset(elf_info, 0, sizeof(*elf_info));\n}\n \nint kexec_build_elf_info(const char *buf, size_t len, struct elfhdr *ehdr,\n\t\t\t       struct kexec_elf_info *elf_info)\n{\n\tint i;\n\tint ret;\n\n\tret = elf_read_from_buffer(buf, len, ehdr, elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {\n\t\tpr_err(\"Not an ELF executable.\\n\");\n\t\tgoto error;\n\t} else if (!elf_info->proghdrs) {\n\t\tpr_err(\"No ELF program header.\\n\");\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\t \n\t\tif (elf_info->proghdrs[i].p_type == PT_INTERP) {\n\t\t\tpr_err(\"Requires an ELF interpreter.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\nerror:\n\tkexec_free_elf_info(elf_info);\n\treturn -ENOEXEC;\n}\n\n\nint kexec_elf_probe(const char *buf, unsigned long len)\n{\n\tstruct elfhdr ehdr;\n\tstruct kexec_elf_info elf_info;\n\tint ret;\n\n\tret = kexec_build_elf_info(buf, len, &ehdr, &elf_info);\n\tif (ret)\n\t\treturn ret;\n\n\tkexec_free_elf_info(&elf_info);\n\n\treturn elf_check_arch(&ehdr) ? 0 : -ENOEXEC;\n}\n\n \nint kexec_elf_load(struct kimage *image, struct elfhdr *ehdr,\n\t\t\t struct kexec_elf_info *elf_info,\n\t\t\t struct kexec_buf *kbuf,\n\t\t\t unsigned long *lowest_load_addr)\n{\n\tunsigned long lowest_addr = UINT_MAX;\n\tint ret;\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tunsigned long load_addr;\n\t\tsize_t size;\n\t\tconst struct elf_phdr *phdr;\n\n\t\tphdr = &elf_info->proghdrs[i];\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tsize = phdr->p_filesz;\n\t\tif (size > phdr->p_memsz)\n\t\t\tsize = phdr->p_memsz;\n\n\t\tkbuf->buffer = (void *) elf_info->buffer + phdr->p_offset;\n\t\tkbuf->bufsz = size;\n\t\tkbuf->memsz = phdr->p_memsz;\n\t\tkbuf->buf_align = phdr->p_align;\n\t\tkbuf->buf_min = phdr->p_paddr;\n\t\tkbuf->mem = KEXEC_BUF_MEM_UNKNOWN;\n\t\tret = kexec_add_buffer(kbuf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tload_addr = kbuf->mem;\n\n\t\tif (load_addr < lowest_addr)\n\t\t\tlowest_addr = load_addr;\n\t}\n\n\t*lowest_load_addr = lowest_addr;\n\tret = 0;\n out:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}