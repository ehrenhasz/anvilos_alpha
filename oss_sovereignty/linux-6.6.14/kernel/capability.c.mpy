{
  "module_name": "capability.c",
  "hash_id": "8e13188755e895d5c2d45443f6e7a287474eeb05644569a058c4f4177daaf083",
  "original_prompt": "Ingested from linux-6.6.14/kernel/capability.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n\nint file_caps_enabled = 1;\n\nstatic int __init file_caps_disable(char *str)\n{\n\tfile_caps_enabled = 0;\n\treturn 1;\n}\n__setup(\"no_file_caps\", file_caps_disable);\n\n#ifdef CONFIG_MULTIUSER\n \n\nstatic void warn_legacy_capability_use(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\",\n\t\t     get_task_comm(name, current));\n}\n\n \n\nstatic void warn_deprecated_v2(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_info_once(\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\",\n\t\t     get_task_comm(name, current));\n}\n\n \nstatic int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)\n{\n\t__u32 version;\n\n\tif (get_user(version, &header->version))\n\t\treturn -EFAULT;\n\n\tswitch (version) {\n\tcase _LINUX_CAPABILITY_VERSION_1:\n\t\twarn_legacy_capability_use();\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_1;\n\t\tbreak;\n\tcase _LINUX_CAPABILITY_VERSION_2:\n\t\twarn_deprecated_v2();\n\t\tfallthrough;\t \n\tcase _LINUX_CAPABILITY_VERSION_3:\n\t\t*tocopy = _LINUX_CAPABILITY_U32S_3;\n\t\tbreak;\n\tdefault:\n\t\tif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))\n\t\t\treturn -EFAULT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,\n\t\t\t\t     kernel_cap_t *pIp, kernel_cap_t *pPp)\n{\n\tint ret;\n\n\tif (pid && (pid != task_pid_vnr(current))) {\n\t\tconst struct task_struct *target;\n\n\t\trcu_read_lock();\n\n\t\ttarget = find_task_by_vpid(pid);\n\t\tif (!target)\n\t\t\tret = -ESRCH;\n\t\telse\n\t\t\tret = security_capget(target, pEp, pIp, pPp);\n\n\t\trcu_read_unlock();\n\t} else\n\t\tret = security_capget(current, pEp, pIp, pPp);\n\n\treturn ret;\n}\n\n \nSYSCALL_DEFINE2(capget, cap_user_header_t, header, cap_user_data_t, dataptr)\n{\n\tint ret = 0;\n\tpid_t pid;\n\tunsigned tocopy;\n\tkernel_cap_t pE, pI, pP;\n\tstruct __user_cap_data_struct kdata[2];\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif ((dataptr == NULL) || (ret != 0))\n\t\treturn ((dataptr == NULL) && (ret == -EINVAL)) ? 0 : ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tret = cap_get_target_pid(pid, &pE, &pI, &pP);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tkdata[0].effective   = pE.val; kdata[1].effective   = pE.val >> 32;\n\tkdata[0].permitted   = pP.val; kdata[1].permitted   = pP.val >> 32;\n\tkdata[0].inheritable = pI.val; kdata[1].inheritable = pI.val >> 32;\n\n\t \n\tif (copy_to_user(dataptr, kdata, tocopy * sizeof(kdata[0])))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic kernel_cap_t mk_kernel_cap(u32 low, u32 high)\n{\n\treturn (kernel_cap_t) { (low | ((u64)high << 32)) & CAP_VALID_MASK };\n}\n\n \nSYSCALL_DEFINE2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[2] = { { 0, }, };\n\tunsigned tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->pid))\n\t\treturn -EFAULT;\n\n\t \n\tif (pid != 0 && pid != task_pid_vnr(current))\n\t\treturn -EPERM;\n\n\tcopybytes = tocopy * sizeof(struct __user_cap_data_struct);\n\tif (copybytes > sizeof(kdata))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&kdata, data, copybytes))\n\t\treturn -EFAULT;\n\n\teffective   = mk_kernel_cap(kdata[0].effective,   kdata[1].effective);\n\tpermitted   = mk_kernel_cap(kdata[0].permitted,   kdata[1].permitted);\n\tinheritable = mk_kernel_cap(kdata[0].inheritable, kdata[1].inheritable);\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n \nbool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NONE);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}\n\n \nbool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}\nEXPORT_SYMBOL(has_capability);\n\n \nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap, CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}\n\n \nbool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}\nEXPORT_SYMBOL(has_capability_noaudit);\n\nstatic bool ns_capable_common(struct user_namespace *ns,\n\t\t\t      int cap,\n\t\t\t      unsigned int opts)\n{\n\tint capable;\n\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tBUG();\n\t}\n\n\tcapable = security_capable(current_cred(), ns, cap, opts);\n\tif (capable == 0) {\n\t\tcurrent->flags |= PF_SUPERPRIV;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nbool ns_capable(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NONE);\n}\nEXPORT_SYMBOL(ns_capable);\n\n \nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_NOAUDIT);\n}\nEXPORT_SYMBOL(ns_capable_noaudit);\n\n \nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}\nEXPORT_SYMBOL(ns_capable_setid);\n\n \nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}\nEXPORT_SYMBOL(capable);\n#endif  \n\n \nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\n\t\t     int cap)\n{\n\n\tif (WARN_ON_ONCE(!cap_valid(cap)))\n\t\treturn false;\n\n\tif (security_capable(file->f_cred, ns, cap, CAP_OPT_NONE) == 0)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(file_ns_capable);\n\n \nbool privileged_wrt_inode_uidgid(struct user_namespace *ns,\n\t\t\t\t struct mnt_idmap *idmap,\n\t\t\t\t const struct inode *inode)\n{\n\treturn vfsuid_has_mapping(ns, i_uid_into_vfsuid(idmap, inode)) &&\n\t       vfsgid_has_mapping(ns, i_gid_into_vfsgid(idmap, inode));\n}\n\n \nbool capable_wrt_inode_uidgid(struct mnt_idmap *idmap,\n\t\t\t      const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) &&\n\t       privileged_wrt_inode_uidgid(ns, idmap, inode);\n}\nEXPORT_SYMBOL(capable_wrt_inode_uidgid);\n\n \nbool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n{\n\tint ret = 0;   \n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = rcu_dereference(tsk->ptracer_cred);\n\tif (cred)\n\t\tret = security_capable(cred, ns, CAP_SYS_PTRACE,\n\t\t\t\t       CAP_OPT_NOAUDIT);\n\trcu_read_unlock();\n\treturn (ret == 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}