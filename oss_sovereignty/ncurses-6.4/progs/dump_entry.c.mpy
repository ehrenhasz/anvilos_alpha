{
  "module_name": "dump_entry.c",
  "hash_id": "59fa42e61c2d176643f91f2a78253fec7afc5b0a4d114be639d39b10df549d9c",
  "original_prompt": "Ingested from ncurses-6.4/progs/dump_entry.c",
  "human_readable_source": " \n\n \n\n#define __INTERNAL_CAPS_VISIBLE\n#include <progs.priv.h>\n\n#include <dump_entry.h>\n#include <termsort.h>\t\t \n#include <parametrized.h>\t \n\nMODULE_ID(\"$Id: dump_entry.c,v 1.190 2022/01/22 21:23:58 tom Exp $\")\n\n#define DISCARD(string) string = ABSENT_STRING\n#define PRINTF (void) printf\n#define WRAPPED 32\n\n#define OkIndex(index,array) ((int)(index) >= 0 && (int)(index) < (int) SIZEOF(array))\n#define TcOutput() (outform == F_TERMCAP || outform == F_TCONVERR)\n\ntypedef struct {\n    char *text;\n    size_t used;\n    size_t size;\n} DYNBUF;\n\nstatic int tversion;\t\t \nstatic int outform;\t\t \nstatic int sortmode;\t\t \nstatic int width = 60;\t\t \nstatic int height = 65535;\t \nstatic int column;\t\t \nstatic int oldcol;\t\t \nstatic bool pretty;\t\t \nstatic bool wrapped;\t\t \nstatic bool did_wrap;\t\t \nstatic bool checking;\t\t \nstatic int quickdump;\t\t \n\nstatic char *save_sgr;\n\nstatic DYNBUF outbuf;\nstatic DYNBUF tmpbuf;\n\n \nstatic const PredIdx *bool_indirect, *num_indirect, *str_indirect;\nstatic NCURSES_CONST char *const *bool_names;\nstatic NCURSES_CONST char *const *num_names;\nstatic NCURSES_CONST char *const *str_names;\n\nstatic const char *separator = \"\", *trailer = \"\";\nstatic int indent = 8;\n\n \n#define V_ALLCAPS\t0\t \n#define V_SVR1\t\t1\t \n#define V_HPUX\t\t2\t \n#define V_AIX\t\t3\t \n#define V_BSD\t\t4\t \n\n#if NCURSES_XNAMES\n#define OBSOLETE(n) (!_nc_user_definable && (n[0] == 'O' && n[1] == 'T'))\n#else\n#define OBSOLETE(n) (n[0] == 'O' && n[1] == 'T')\n#endif\n\n#define isObsolete(f,n) ((f == F_TERMINFO || f == F_VARIABLE) && (sortmode != S_VARIABLE) && OBSOLETE(n))\n\n#if NCURSES_XNAMES\n#define BoolIndirect(j) ((j >= BOOLCOUNT) ? (j) : ((sortmode == S_NOSORT) ? j : bool_indirect[j]))\n#define NumIndirect(j)  ((j >= NUMCOUNT)  ? (j) : ((sortmode == S_NOSORT) ? j : num_indirect[j]))\n#define StrIndirect(j)  ((j >= STRCOUNT)  ? (j) : ((sortmode == S_NOSORT) ? j : str_indirect[j]))\n#else\n#define BoolIndirect(j) ((sortmode == S_NOSORT) ? (j) : bool_indirect[j])\n#define NumIndirect(j)  ((sortmode == S_NOSORT) ? (j) : num_indirect[j])\n#define StrIndirect(j)  ((sortmode == S_NOSORT) ? (j) : str_indirect[j])\n#endif\n\nstatic GCC_NORETURN void\nfailed(const char *s)\n{\n    perror(s);\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic void\nstrncpy_DYN(DYNBUF * dst, const char *src, size_t need)\n{\n    size_t want = need + dst->used + 1;\n    if (want > dst->size) {\n\tdst->size += (want + 1024);\t \n\tdst->text = typeRealloc(char, dst->size, dst->text);\n\tif (dst->text == 0)\n\t    failed(\"strncpy_DYN\");\n    }\n    _nc_STRNCPY(dst->text + dst->used, src, need + 1);\n    dst->used += need;\n    dst->text[dst->used] = 0;\n}\n\nstatic void\nstrcpy_DYN(DYNBUF * dst, const char *src)\n{\n    if (src == 0) {\n\tdst->used = 0;\n\tstrcpy_DYN(dst, \"\");\n    } else {\n\tstrncpy_DYN(dst, src, strlen(src));\n    }\n}\n\n#if NO_LEAKS\nstatic void\nfree_DYN(DYNBUF * p)\n{\n    if (p->text != 0)\n\tfree(p->text);\n    p->text = 0;\n    p->size = 0;\n    p->used = 0;\n}\n\nvoid\n_nc_leaks_dump_entry(void)\n{\n    free_DYN(&outbuf);\n    free_DYN(&tmpbuf);\n}\n#endif\n\n#define NameTrans(check,result) \\\n\t    if ((np->nte_index <= OK_ ## check) \\\n\t\t&& check[np->nte_index]) \\\n\t\treturn (result[np->nte_index])\n\nNCURSES_CONST char *\nnametrans(const char *name)\n \n{\n    const struct name_table_entry *np;\n\n    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != 0) {\n\tswitch (np->nte_type) {\n\tcase BOOLEAN:\n\t    NameTrans(bool_from_termcap, boolcodes);\n\t    break;\n\n\tcase NUMBER:\n\t    NameTrans(num_from_termcap, numcodes);\n\t    break;\n\n\tcase STRING:\n\t    NameTrans(str_from_termcap, strcodes);\n\t    break;\n\t}\n    }\n\n    return (0);\n}\n\nvoid\ndump_init(const char *version,\n\t  int mode,\n\t  int sort,\n\t  bool wrap_strings,\n\t  int twidth,\n\t  int theight,\n\t  unsigned traceval,\n\t  bool formatted,\n\t  bool check,\n\t  int quick)\n \n{\n    width = twidth;\n    height = theight;\n    pretty = formatted;\n    wrapped = wrap_strings;\n    checking = check;\n    quickdump = (quick & 3);\n\n    did_wrap = (width <= 0);\n\n     \n    if (version == 0)\n\ttversion = V_ALLCAPS;\n    else if (!strcmp(version, \"SVr1\") || !strcmp(version, \"SVR1\")\n\t     || !strcmp(version, \"Ultrix\"))\n\ttversion = V_SVR1;\n    else if (!strcmp(version, \"HP\"))\n\ttversion = V_HPUX;\n    else if (!strcmp(version, \"AIX\"))\n\ttversion = V_AIX;\n    else if (!strcmp(version, \"BSD\"))\n\ttversion = V_BSD;\n    else\n\ttversion = V_ALLCAPS;\n\n     \n    switch (outform = mode) {\n    case F_LITERAL:\n    case F_TERMINFO:\n\tbool_names = boolnames;\n\tnum_names = numnames;\n\tstr_names = strnames;\n\tseparator = (twidth > 0 && theight > 1) ? \", \" : \",\";\n\ttrailer = \"\\n\\t\";\n\tbreak;\n\n    case F_VARIABLE:\n\tbool_names = boolfnames;\n\tnum_names = numfnames;\n\tstr_names = strfnames;\n\tseparator = (twidth > 0 && theight > 1) ? \", \" : \",\";\n\ttrailer = \"\\n\\t\";\n\tbreak;\n\n    case F_TERMCAP:\n    case F_TCONVERR:\n\tbool_names = boolcodes;\n\tnum_names = numcodes;\n\tstr_names = strcodes;\n\tseparator = \":\";\n\ttrailer = \"\\\\\\n\\t:\";\n\tbreak;\n    }\n    indent = 8;\n\n     \n    switch (sortmode = sort) {\n    case S_NOSORT:\n\tif (traceval)\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s: sorting by term structure order\\n\", _nc_progname);\n\tbreak;\n\n    case S_TERMINFO:\n\tif (traceval)\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s: sorting by terminfo name order\\n\", _nc_progname);\n\tbool_indirect = bool_terminfo_sort;\n\tnum_indirect = num_terminfo_sort;\n\tstr_indirect = str_terminfo_sort;\n\tbreak;\n\n    case S_VARIABLE:\n\tif (traceval)\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s: sorting by C variable order\\n\", _nc_progname);\n\tbool_indirect = bool_variable_sort;\n\tnum_indirect = num_variable_sort;\n\tstr_indirect = str_variable_sort;\n\tbreak;\n\n    case S_TERMCAP:\n\tif (traceval)\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s: sorting by termcap name order\\n\", _nc_progname);\n\tbool_indirect = bool_termcap_sort;\n\tnum_indirect = num_termcap_sort;\n\tstr_indirect = str_termcap_sort;\n\tbreak;\n    }\n\n    if (traceval)\n\t(void) fprintf(stderr,\n\t\t       \"%s: width = %d, tversion = %d, outform = %d\\n\",\n\t\t       _nc_progname, width, tversion, outform);\n}\n\nstatic TERMTYPE2 *cur_type;\n\nstatic int\ndump_predicate(PredType type, PredIdx idx)\n \n{\n    switch (type) {\n    case BOOLEAN:\n\treturn (cur_type->Booleans[idx] == FALSE)\n\t    ? FAIL : cur_type->Booleans[idx];\n\n    case NUMBER:\n\treturn (cur_type->Numbers[idx] == ABSENT_NUMERIC)\n\t    ? FAIL : cur_type->Numbers[idx];\n\n    case STRING:\n\treturn (cur_type->Strings[idx] != ABSENT_STRING)\n\t    ? (int) TRUE : FAIL;\n    }\n\n    return (FALSE);\t\t \n}\n\nstatic void set_obsolete_termcaps(TERMTYPE2 *tp);\n\n \n#define FNKEY(i) \\\n    (((i) >= STR_IDX(key_f0) && \\\n      (i) <= STR_IDX(key_f9)) || \\\n     ((i) >= STR_IDX(key_f11) && \\\n      (i) <= STR_IDX(key_f63)))\n\n \n#define BOOL_IDX(name) (PredType) (&(name) - &(CUR Booleans[0]))\n#define NUM_IDX(name)  (PredType) (&(name) - &(CUR Numbers[0]))\n#define STR_IDX(name)  (PredType) (&(name) - &(CUR Strings[0]))\n\nstatic bool\nversion_filter(PredType type, PredIdx idx)\n \n{\n    switch (tversion) {\n    case V_ALLCAPS:\t\t \n\treturn (TRUE);\n\n    case V_SVR1:\t\t \n\tswitch (type) {\n\tcase BOOLEAN:\n\t    return ((idx <= BOOL_IDX(xon_xoff)) ? TRUE : FALSE);\n\tcase NUMBER:\n\t    return ((idx <= NUM_IDX(width_status_line)) ? TRUE : FALSE);\n\tcase STRING:\n\t    return ((idx <= STR_IDX(prtr_non)) ? TRUE : FALSE);\n\t}\n\tbreak;\n\n    case V_HPUX:\t\t \n\tswitch (type) {\n\tcase BOOLEAN:\n\t    return ((idx <= BOOL_IDX(xon_xoff)) ? TRUE : FALSE);\n\tcase NUMBER:\n\t    return ((idx <= NUM_IDX(label_width)) ? TRUE : FALSE);\n\tcase STRING:\n\t    if (idx <= STR_IDX(prtr_non))\n\t\treturn (TRUE);\n\t    else if (FNKEY(idx))\t \n\t\treturn (TRUE);\n\t    else if (idx == STR_IDX(plab_norm)\n\t\t     || idx == STR_IDX(label_on)\n\t\t     || idx == STR_IDX(label_off))\n\t\treturn (TRUE);\n\t    else\n\t\treturn (FALSE);\n\t}\n\tbreak;\n\n    case V_AIX:\t\t \n\tswitch (type) {\n\tcase BOOLEAN:\n\t    return ((idx <= BOOL_IDX(xon_xoff)) ? TRUE : FALSE);\n\tcase NUMBER:\n\t    return ((idx <= NUM_IDX(width_status_line)) ? TRUE : FALSE);\n\tcase STRING:\n\t    if (idx <= STR_IDX(prtr_non))\n\t\treturn (TRUE);\n\t    else if (FNKEY(idx))\t \n\t\treturn (TRUE);\n\t    else\n\t\treturn (FALSE);\n\t}\n\tbreak;\n\n#define is_termcap(type) (OkIndex(idx, type##_from_termcap) && \\\n\t\t\t  type##_from_termcap[idx])\n\n    case V_BSD:\t\t \n\tswitch (type) {\n\tcase BOOLEAN:\n\t    return is_termcap(bool);\n\tcase NUMBER:\n\t    return is_termcap(num);\n\tcase STRING:\n\t    return is_termcap(str);\n\t}\n\tbreak;\n    }\n\n    return (FALSE);\t\t \n}\n\nstatic void\ntrim_trailing(void)\n{\n    while (outbuf.used > 0 && outbuf.text[outbuf.used - 1] == ' ')\n\toutbuf.text[--outbuf.used] = '\\0';\n}\n\nstatic void\nforce_wrap(void)\n{\n    oldcol = column;\n    trim_trailing();\n    strcpy_DYN(&outbuf, trailer);\n    column = indent;\n}\n\nstatic int\nop_length(const char *src, int offset)\n{\n    int result = 0;\n\n    if (offset > 0 && src[offset - 1] == '\\\\') {\n\tresult = 0;\n    } else {\n\tint ch;\n\n\tresult++;\t\t \n\tch = src[offset + result];\n\tif (TcOutput()) {\n\t    if (ch == '>') {\n\t\tresult += 3;\n\t    } else if (ch == '+') {\n\t\tresult += 2;\n\t    } else {\n\t\tresult++;\n\t    }\n\t} else if (ch == '\\'') {\n\t    result += 3;\n\t} else if (ch == L_CURL[0]) {\n\t    int n = result;\n\t    while ((ch = src[offset + n]) != '\\0') {\n\t\tif (ch == R_CURL[0]) {\n\t\t    result = ++n;\n\t\t    break;\n\t\t}\n\t\tn++;\n\t    }\n\t} else if (strchr(\"pPg\", ch) != 0) {\n\t    result += 2;\n\t} else {\n\t    result++;\t\t \n\t}\n    }\n    return result;\n}\n\n \nstatic int\nfind_split(const char *src, int step, int size)\n{\n    int result = size;\n\n    if (size > 0) {\n\t \n\tint mark = size;\n\tint n;\n\n\tfor (n = size - 1; n > 0; --n) {\n\t    int ch = UChar(src[step + n]);\n\t    if (ch == '\\\\') {\n\t\tif (n > 0 && src[step + n - 1] == ch)\n\t\t    --n;\n\t\tmark = n;\n\t\tbreak;\n\t    } else if (!isalnum(ch)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (mark < size) {\n\t    result = mark;\n\t} else {\n\t     \n\t    for (n = size - 1; n > 0; --n) {\n\t\tint ch = UChar(src[step + n]);\n\t\tif (ch == '%') {\n\t\t    int need = op_length(src, step + n);\n\t\t    if ((n + need) > size) {\n\t\t\tmark = n;\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t    if (mark < size) {\n\t\tresult = mark;\n\t    }\n\t}\n    }\n    return result;\n}\n\n \nstatic char *\nfill_spaces(const char *src)\n{\n    const char *fill = \"\\\\s\";\n    size_t need = strlen(src);\n    size_t size = strlen(fill);\n    char *result = 0;\n    int pass;\n    size_t s, d;\n    for (pass = 0; pass < 2; ++pass) {\n\tfor (s = d = 0; src[s] != '\\0'; ++s) {\n\t    if (src[s] == ' ') {\n\t\tif (pass) {\n\t\t    _nc_STRCPY(&result[d], fill, need + 1 - d);\n\t\t    d += size;\n\t\t} else {\n\t\t    need += size;\n\t\t}\n\t    } else {\n\t\tif (pass) {\n\t\t    result[d++] = src[s];\n\t\t} else {\n\t\t    ++d;\n\t\t}\n\t    }\n\t}\n\tif (pass) {\n\t    result[d] = '\\0';\n\t} else {\n\t    result = calloc(need + 1, sizeof(char));\n\t    if (result == 0)\n\t\tfailed(\"fill_spaces\");\n\t}\n    }\n    return result;\n}\n\ntypedef enum {\n    wOFF = 0\n    ,w1ST = 1\n    ,w2ND = 2\n    ,wEND = 4\n    ,wERR = 8\n} WRAPMODE;\n\n#define wrap_1ST(mode) ((mode)&w1ST)\n#define wrap_END(mode) ((mode)&wEND)\n#define wrap_ERR(mode) ((mode)&wERR)\n\nstatic void\nwrap_concat(const char *src, int need, unsigned mode)\n{\n    int gaps = (int) strlen(separator);\n    int want = gaps + need;\n\n    did_wrap = (width <= 0);\n    if (wrap_1ST(mode)\n\t&& column > indent\n\t&& column + want > width) {\n\tforce_wrap();\n    }\n    if ((wrap_END(mode) && !wrap_ERR(mode)) &&\n\twrapped &&\n\t(width >= 0) &&\n\t(column + want) > width) {\n\tint step = 0;\n\tint used = width > WRAPPED ? width : WRAPPED;\n\tint base = 0;\n\tchar *p, align[9];\n\tconst char *my_t = trailer;\n\tchar *fill = fill_spaces(src);\n\tint last = (int) strlen(fill);\n\n\tneed = last;\n\n\tif (TcOutput())\n\t    trailer = \"\\\\\\n\\t \";\n\n\tif (!TcOutput() && (p = strchr(fill, '=')) != 0) {\n\t    base = (int) (p + 1 - fill);\n\t    if (base > 8)\n\t\tbase = 8;\n\t    _nc_SPRINTF(align, _nc_SLIMIT(align) \"%*s\", base, \" \");\n\t} else if (column > 8) {\n\t    base = column - 8;\n\t    if (base > 8)\n\t\tbase = 8;\n\t    _nc_SPRINTF(align, _nc_SLIMIT(align) \"%*s\", base, \" \");\n\t} else {\n\t    align[base] = '\\0';\n\t}\n\t \n\tif (!pretty || strchr(fill, '\\n') == 0) {\n\t    int tag = 0;\n\n\t    if (TcOutput() && outbuf.used && !wrap_1ST(mode)) {\n\t\ttag = 3;\n\t    }\n\n\t    while ((column + (need + gaps)) > used) {\n\t\tint size = used - tag;\n\t\tif (step) {\n\t\t    strcpy_DYN(&outbuf, align);\n\t\t    size -= base;\n\t\t}\n\t\tif (size > (last - step)) {\n\t\t    size = (last - step);\n\t\t}\n\t\tsize = find_split(fill, step, size);\n\t\tstrncpy_DYN(&outbuf, fill + step, (size_t) size);\n\t\tstep += size;\n\t\tneed -= size;\n\t\tif (need > 0) {\n\t\t    force_wrap();\n\t\t    did_wrap = TRUE;\n\t\t    tag = 0;\n\t\t}\n\t    }\n\t}\n\tif (need > 0) {\n\t    if (step)\n\t\tstrcpy_DYN(&outbuf, align);\n\t    strcpy_DYN(&outbuf, fill + step);\n\t}\n\tif (wrap_END(mode))\n\t    strcpy_DYN(&outbuf, separator);\n\ttrailer = my_t;\n\tforce_wrap();\n\n\tfree(fill);\n    } else {\n\tstrcpy_DYN(&outbuf, src);\n\tif (wrap_END(mode))\n\t    strcpy_DYN(&outbuf, separator);\n\tcolumn += (int) strlen(src);\n    }\n}\n\nstatic void\nwrap_concat1(const char *src)\n{\n    int need = (int) strlen(src);\n    wrap_concat(src, need, w1ST | wEND);\n}\n\nstatic void\nwrap_concat3(const char *name, const char *eqls, const char *value)\n{\n    int nlen = (int) strlen(name);\n    int elen = (int) strlen(eqls);\n    int vlen = (int) strlen(value);\n\n    wrap_concat(name, nlen + elen + vlen, w1ST);\n    wrap_concat(eqls, elen + vlen, w2ND);\n    wrap_concat(value, vlen, wEND);\n}\n\n#define IGNORE_SEP_TRAIL(first,last,sep_trail) \\\n\tif ((size_t)(last - first) > sizeof(sep_trail)-1 \\\n\t && !strncmp(first, sep_trail, sizeof(sep_trail)-1)) \\\n\t\tfirst += sizeof(sep_trail)-2\n\n \n#ifdef TEST_TERMCAP_LENGTH\nstatic int\ntermcap_length(const char *src)\n{\n    static const char pattern[] = \":\\\\\\n\\t:\";\n\n    int len = 0;\n    const char *const t = src + strlen(src);\n\n    while (*src != '\\0') {\n\tIGNORE_SEP_TRAIL(src, t, pattern);\n\tsrc++;\n\tlen++;\n    }\n    return len;\n}\n#else\n#define termcap_length(src) strlen(src)\n#endif\n\nstatic void\nindent_DYN(DYNBUF * buffer, int level)\n{\n    int n;\n\n    for (n = 0; n < level; n++)\n\tstrncpy_DYN(buffer, \"\\t\", (size_t) 1);\n}\n\n \nstatic bool\nleading_DYN(DYNBUF * buffer, const char *leading)\n{\n    bool result = FALSE;\n    size_t need = strlen(leading);\n    if (buffer->used > need) {\n\tneed = buffer->used - need;\n\tif (!strcmp(buffer->text + need, leading)) {\n\t    result = TRUE;\n\t    while (--need != 0) {\n\t\tif (buffer->text[need] == '\\n') {\n\t\t    break;\n\t\t}\n\t\tif (buffer->text[need] != '\\t') {\n\t\t    result = FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\nbool\nhas_params(const char *src, bool formatting)\n{\n    bool result = FALSE;\n    int len = (int) strlen(src);\n    int n;\n    bool ifthen = FALSE;\n    bool params = FALSE;\n\n    for (n = 0; n < len - 1; ++n) {\n\tif (!strncmp(src + n, \"%p\", (size_t) 2)) {\n\t    params = TRUE;\n\t} else if (!strncmp(src + n, \"%;\", (size_t) 2)) {\n\t    ifthen = TRUE;\n\t    result = params;\n\t    break;\n\t}\n    }\n    if (!ifthen) {\n\tif (formatting) {\n\t    result = ((len > 50) && params);\n\t} else {\n\t    result = params;\n\t}\n    }\n    return result;\n}\n\nstatic char *\nfmt_complex(TERMTYPE2 *tterm, const char *capability, char *src, int level)\n{\n    bool percent = FALSE;\n    bool params = has_params(src, TRUE);\n\n    while (*src != '\\0') {\n\tswitch (*src) {\n\tcase '^':\n\t    percent = FALSE;\n\t    strncpy_DYN(&tmpbuf, src++, (size_t) 1);\n\t    break;\n\tcase '\\\\':\n\t    percent = FALSE;\n\t    strncpy_DYN(&tmpbuf, src++, (size_t) 1);\n\t    break;\n\tcase '%':\n\t    percent = TRUE;\n\t    break;\n\tcase '?':\t\t \n\tcase 't':\t\t \n\tcase 'e':\t\t \n\t    if (percent) {\n\t\tpercent = FALSE;\n\t\ttmpbuf.text[tmpbuf.used - 1] = '\\n';\n\t\t \n\t\tif (*src == 'e') {\n\t\t    indent_DYN(&tmpbuf, level);\n\t\t    strncpy_DYN(&tmpbuf, \"%\", (size_t) 1);\n\t\t    strncpy_DYN(&tmpbuf, src, (size_t) 1);\n\t\t    src++;\n\t\t    params = has_params(src, TRUE);\n\t\t    if (!params && *src != '\\0' && *src != '%') {\n\t\t\tstrncpy_DYN(&tmpbuf, \"\\n\", (size_t) 1);\n\t\t\tindent_DYN(&tmpbuf, level + 1);\n\t\t    }\n\t\t} else {\n\t\t    indent_DYN(&tmpbuf, level + 1);\n\t\t    strncpy_DYN(&tmpbuf, \"%\", (size_t) 1);\n\t\t    strncpy_DYN(&tmpbuf, src, (size_t) 1);\n\t\t    if (*src++ == '?') {\n\t\t\tsrc = fmt_complex(tterm, capability, src, level + 1);\n\t\t\tif (*src != '\\0' && *src != '%') {\n\t\t\t    strncpy_DYN(&tmpbuf, \"\\n\", (size_t) 1);\n\t\t\t    indent_DYN(&tmpbuf, level + 1);\n\t\t\t}\n\t\t    } else if (level == 1) {\n\t\t\tif (checking)\n\t\t\t    _nc_warning(\"%s: %%%c without %%? in %s\",\n\t\t\t\t\t_nc_first_name(tterm->term_names),\n\t\t\t\t\t*src, capability);\n\t\t    }\n\t\t}\n\t\tcontinue;\n\t    }\n\t    break;\n\tcase ';':\t\t \n\t    if (percent) {\n\t\tpercent = FALSE;\n\t\tif (level > 1) {\n\t\t    tmpbuf.text[tmpbuf.used - 1] = '\\n';\n\t\t    indent_DYN(&tmpbuf, level);\n\t\t    strncpy_DYN(&tmpbuf, \"%\", (size_t) 1);\n\t\t    strncpy_DYN(&tmpbuf, src++, (size_t) 1);\n\t\t    if (src[0] == '%'\n\t\t\t&& src[1] != '\\0'\n\t\t\t&& (strchr(\"?e;\", src[1])) == 0) {\n\t\t\ttmpbuf.text[tmpbuf.used++] = '\\n';\n\t\t\tindent_DYN(&tmpbuf, level);\n\t\t    }\n\t\t    return src;\n\t\t}\n\t\tif (checking)\n\t\t    _nc_warning(\"%s: %%; without %%? in %s\",\n\t\t\t\t_nc_first_name(tterm->term_names),\n\t\t\t\tcapability);\n\t    }\n\t    break;\n\tcase 'p':\n\t    if (percent && params && !leading_DYN(&tmpbuf, \"%\")) {\n\t\ttmpbuf.text[tmpbuf.used - 1] = '\\n';\n\t\tindent_DYN(&tmpbuf, level + 1);\n\t\tstrncpy_DYN(&tmpbuf, \"%\", (size_t) 1);\n\t    }\n\t    percent = FALSE;\n\t    break;\n\tcase ' ':\n\t    strncpy_DYN(&tmpbuf, \"\\\\s\", (size_t) 2);\n\t    ++src;\n\t    continue;\n\tdefault:\n\t    percent = FALSE;\n\t    break;\n\t}\n\tstrncpy_DYN(&tmpbuf, src++, (size_t) 1);\n    }\n    return src;\n}\n\n \nstatic const char *\nnumber_format(int value)\n{\n    const char *result = \"%d\";\n\n    if ((outform != F_TERMCAP) && (value > 255)) {\n\tunsigned long lv = (unsigned long) value;\n\tint bits = sizeof(unsigned long) * 8;\n\tint nn;\n\n\tfor (nn = 8; nn < bits; ++nn) {\n\t    unsigned long mm;\n\n\t    mm = 1UL << nn;\n\t    if ((mm - 16) <= lv && (mm + 16) > lv) {\n\t\tresult = \"%#x\";\n\t\tbreak;\n\t    }\n\t}\n    }\n    return result;\n}\n\n#define SAME_CAP(n,cap) (&tterm->Strings[n] == &cap)\n#define EXTRA_CAP 20\n\nint\nfmt_entry(TERMTYPE2 *tterm,\n\t  PredFunc pred,\n\t  int content_only,\n\t  int suppress_untranslatable,\n\t  int infodump,\n\t  int numbers)\n{\n    PredIdx i, j;\n    char buffer[MAX_TERMINFO_LENGTH + EXTRA_CAP];\n    NCURSES_CONST char *name;\n    int predval, len;\n    PredIdx num_bools = 0;\n    PredIdx num_values = 0;\n    PredIdx num_strings = 0;\n    bool outcount = 0;\n\n#define WRAP_CONCAT1(s)\t\twrap_concat1(s); outcount = TRUE\n#define WRAP_CONCAT\t\tWRAP_CONCAT1(buffer)\n\n    len = 12;\t\t\t \n\n    if (pred == 0) {\n\tcur_type = tterm;\n\tpred = dump_predicate;\n    }\n\n    strcpy_DYN(&outbuf, 0);\n    if (content_only) {\n\tcolumn = indent;\t \n    } else {\n\tstrcpy_DYN(&outbuf, tterm->term_names);\n\n\t \n\tif (!infodump) {\n\t    char *p = outbuf.text;\n\t    while (*p) {\n\t\tif (*p == ':') {\n\t\t    *p = '=';\n\t\t}\n\t\t++p;\n\t    }\n\t}\n\tstrcpy_DYN(&outbuf, separator);\n\tcolumn = (int) outbuf.used;\n\tif (height > 1)\n\t    force_wrap();\n    }\n\n    for_each_boolean(j, tterm) {\n\ti = BoolIndirect(j);\n\tname = ExtBoolname(tterm, (int) i, bool_names);\n\tassert(strlen(name) < sizeof(buffer) - EXTRA_CAP);\n\n\tif (!version_filter(BOOLEAN, i))\n\t    continue;\n\telse if (isObsolete(outform, name))\n\t    continue;\n\n\tpredval = pred(BOOLEAN, i);\n\tif (predval != FAIL) {\n\t    _nc_STRCPY(buffer, name, sizeof(buffer));\n\t    if (predval <= 0)\n\t\t_nc_STRCAT(buffer, \"@\", sizeof(buffer));\n\t    else if (i + 1 > num_bools)\n\t\tnum_bools = i + 1;\n\t    WRAP_CONCAT;\n\t}\n    }\n\n    if (column != indent && height > 1)\n\tforce_wrap();\n\n    for_each_number(j, tterm) {\n\ti = NumIndirect(j);\n\tname = ExtNumname(tterm, (int) i, num_names);\n\tassert(strlen(name) < sizeof(buffer) - EXTRA_CAP);\n\n\tif (!version_filter(NUMBER, i))\n\t    continue;\n\telse if (isObsolete(outform, name))\n\t    continue;\n\n\tpredval = pred(NUMBER, i);\n\tif (predval != FAIL) {\n\t    if (tterm->Numbers[i] < 0) {\n\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t    \"%s@\", name);\n\t    } else {\n\t\tsize_t nn;\n\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t    \"%s#\", name);\n\t\tnn = strlen(buffer);\n\t\t_nc_SPRINTF(buffer + nn, _nc_SLIMIT(sizeof(buffer) - nn)\n\t\t\t    number_format(tterm->Numbers[i]),\n\t\t\t    tterm->Numbers[i]);\n\t\tif (i + 1 > num_values)\n\t\t    num_values = i + 1;\n\t    }\n\t    WRAP_CONCAT;\n\t}\n    }\n\n    if (column != indent && height > 1)\n\tforce_wrap();\n\n    len += (int) (num_bools\n\t\t  + num_values * 2\n\t\t  + strlen(tterm->term_names) + 1);\n    if (len & 1)\n\tlen++;\n\n#undef CUR\n#define CUR tterm->\n    if (outform == F_TERMCAP) {\n\tif (VALID_STRING(termcap_reset)) {\n\t    if (VALID_STRING(init_3string)\n\t\t&& !strcmp(init_3string, termcap_reset))\n\t\tDISCARD(init_3string);\n\n\t    if (VALID_STRING(reset_2string)\n\t\t&& !strcmp(reset_2string, termcap_reset))\n\t\tDISCARD(reset_2string);\n\t}\n    }\n\n    for_each_string(j, tterm) {\n\tchar *capability;\n\ti = StrIndirect(j);\n\tname = ExtStrname(tterm, (int) i, str_names);\n\tassert(strlen(name) < sizeof(buffer) - EXTRA_CAP);\n\n\tcapability = tterm->Strings[i];\n\n\tif (!version_filter(STRING, i))\n\t    continue;\n\telse if (isObsolete(outform, name))\n\t    continue;\n\n#if NCURSES_XNAMES\n\t \n\tif (outform == F_TERMCAP && (strlen(name) > 2))\n\t    continue;\n#endif\n\n\tif (outform == F_TERMCAP) {\n\t     \n\t    if (PRESENT(insert_character) || PRESENT(parm_ich)) {\n\t\tif (SAME_CAP(i, enter_insert_mode)\n\t\t    && enter_insert_mode == ABSENT_STRING) {\n\t\t    _nc_STRCPY(buffer, \"im=\", sizeof(buffer));\n\t\t    WRAP_CONCAT;\n\t\t    continue;\n\t\t}\n\n\t\tif (SAME_CAP(i, exit_insert_mode)\n\t\t    && exit_insert_mode == ABSENT_STRING) {\n\t\t    _nc_STRCPY(buffer, \"ei=\", sizeof(buffer));\n\t\t    WRAP_CONCAT;\n\t\t    continue;\n\t\t}\n\t    }\n\t     \n\t    if (PRESENT(exit_attribute_mode)) {\n\t\tif (SAME_CAP(i, exit_attribute_mode)) {\n\t\t    char *trimmed_sgr0;\n\t\t    char *my_sgr = set_attributes;\n\n\t\t    set_attributes = save_sgr;\n\n\t\t    trimmed_sgr0 = _nc_trim_sgr0(tterm);\n\t\t    if (strcmp(capability, trimmed_sgr0)) {\n\t\t\tcapability = trimmed_sgr0;\n\t\t    } else {\n\t\t\tif (trimmed_sgr0 != exit_attribute_mode)\n\t\t\t    free(trimmed_sgr0);\n\t\t    }\n\n\t\t    set_attributes = my_sgr;\n\t\t}\n\t    }\n\t}\n\n\tpredval = pred(STRING, i);\n\tbuffer[0] = '\\0';\n\n\tif (predval != FAIL) {\n\t    if (VALID_STRING(capability)\n\t\t&& i + 1 > num_strings)\n\t\tnum_strings = i + 1;\n\n\t    if (!VALID_STRING(capability)) {\n\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t    \"%s@\", name);\n\t\tWRAP_CONCAT;\n\t    } else if (TcOutput()) {\n\t\tchar *srccap = _nc_tic_expand(capability, TRUE, numbers);\n\t\tint params = ((i < (int) SIZEOF(parametrized))\n\t\t\t      ? parametrized[i]\n\t\t\t      : ((*srccap == 'k')\n\t\t\t\t ? 0\n\t\t\t\t : has_params(srccap, FALSE)));\n\t\tchar *cv = _nc_infotocap(name, srccap, params);\n\n\t\tif (cv == 0) {\n\t\t    if (outform == F_TCONVERR) {\n\t\t\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t\t    \"%s=!!! %s WILL NOT CONVERT !!!\",\n\t\t\t\t    name, srccap);\n\t\t\tWRAP_CONCAT;\n\t\t    } else if (suppress_untranslatable) {\n\t\t\tcontinue;\n\t\t    } else {\n\t\t\tchar *s = srccap, *d = buffer;\n\t\t\tint need = 3 + (int) strlen(name);\n\t\t\twhile ((*d = *s++) != 0) {\n\t\t\t    if ((d - buffer + 2) >= (int) sizeof(buffer)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: value for %s is too long\\n\",\n\t\t\t\t\t_nc_progname,\n\t\t\t\t\tname);\n\t\t\t\t*d = '\\0';\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    if (*d == ':') {\n\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d = ':';\n\t\t\t    } else if (*d == '\\\\') {\n\t\t\t\tif ((*++d = *s++) == '\\0')\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    d++;\n\t\t\t    *d = '\\0';\n\t\t\t}\n\t\t\tneed += (int) (d - buffer);\n\t\t\twrap_concat(\"..\", need, w1ST | wERR);\n\t\t\tneed -= 2;\n\t\t\twrap_concat(name, need, wOFF | wERR);\n\t\t\tneed -= (int) strlen(name);\n\t\t\twrap_concat(\"=\", need, w2ND | wERR);\n\t\t\tneed -= 1;\n\t\t\twrap_concat(buffer, need, wEND | wERR);\n\t\t\toutcount = TRUE;\n\t\t    }\n\t\t} else {\n\t\t    wrap_concat3(name, \"=\", cv);\n\t\t}\n\t\tlen += (int) strlen(capability) + 1;\n\t    } else {\n\t\tchar *src = _nc_tic_expand(capability,\n\t\t\t\t\t   outform == F_TERMINFO, numbers);\n\n\t\tstrcpy_DYN(&tmpbuf, 0);\n\t\tstrcpy_DYN(&tmpbuf, name);\n\t\tstrcpy_DYN(&tmpbuf, \"=\");\n\t\tif (pretty\n\t\t    && (outform == F_TERMINFO\n\t\t\t|| outform == F_VARIABLE)) {\n\t\t    fmt_complex(tterm, name, src, 1);\n\t\t} else {\n\t\t    strcpy_DYN(&tmpbuf, src);\n\t\t}\n\t\tlen += (int) strlen(capability) + 1;\n\t\tWRAP_CONCAT1(tmpbuf.text);\n\t    }\n\t}\n\t \n\tif (VALID_STRING(capability) &&\n\t    capability != tterm->Strings[i])\n\t    free(capability);\n    }\n    len += (int) (num_strings * 2);\n\n     \n    if (tversion == V_HPUX) {\n\tif (VALID_STRING(memory_lock)) {\n\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t\"meml=%s\", memory_lock);\n\t    WRAP_CONCAT;\n\t}\n\tif (VALID_STRING(memory_unlock)) {\n\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\t\"memu=%s\", memory_unlock);\n\t    WRAP_CONCAT;\n\t}\n    } else if (tversion == V_AIX) {\n\tif (VALID_STRING(acs_chars)) {\n\t    bool box_ok = TRUE;\n\t    const char *acstrans = \"lqkxjmwuvtn\";\n\t    const char *cp;\n\t    char *tp, *sp, boxchars[11];\n\n\t    tp = boxchars;\n\t    for (cp = acstrans; *cp; cp++) {\n\t\tsp = (strchr) (acs_chars, *cp);\n\t\tif (sp)\n\t\t    *tp++ = sp[1];\n\t\telse {\n\t\t    box_ok = FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t    tp[0] = '\\0';\n\n\t    if (box_ok) {\n\t\tchar *tmp = _nc_tic_expand(boxchars,\n\t\t\t\t\t   (outform == F_TERMINFO),\n\t\t\t\t\t   numbers);\n\t\t_nc_STRCPY(buffer, \"box1=\", sizeof(buffer));\n\t\twhile (*tmp != '\\0') {\n\t\t    size_t have = strlen(buffer);\n\t\t    size_t next = strlen(tmp);\n\t\t    size_t want = have + next + 1;\n\t\t    size_t last = next;\n\t\t    char save = '\\0';\n\n\t\t     \n\t\t    if (want >= sizeof(buffer)) {\n\t\t\tsave = tmp[last];\n\t\t\ttmp[last] = '\\0';\n\t\t    }\n\t\t    _nc_STRCAT(buffer, tmp, sizeof(buffer));\n\n\t\t     \n\t\t    if (save != '\\0') {\n\t\t\tnext = 0;\n\t\t\ttmp[last] = save;\n\t\t\twhile ((tmp[next] = tmp[last + next]) != '\\0') {\n\t\t\t    ++next;\n\t\t\t}\n\t\t    } else {\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tWRAP_CONCAT;\n\t    }\n\t}\n    }\n\n     \n    if (outcount) {\n\tbool trimmed = FALSE;\n\tj = (PredIdx) outbuf.used;\n\tif (wrapped && did_wrap) {\n\t      ;\n\t} else if (j >= 2\n\t\t   && outbuf.text[j - 1] == '\\t'\n\t\t   && outbuf.text[j - 2] == '\\n') {\n\t    outbuf.used -= 2;\n\t    trimmed = TRUE;\n\t} else if (j >= 4\n\t\t   && outbuf.text[j - 1] == ':'\n\t\t   && outbuf.text[j - 2] == '\\t'\n\t\t   && outbuf.text[j - 3] == '\\n'\n\t\t   && outbuf.text[j - 4] == '\\\\') {\n\t    outbuf.used -= 4;\n\t    trimmed = TRUE;\n\t}\n\tif (trimmed) {\n\t    outbuf.text[outbuf.used] = '\\0';\n\t    column = oldcol;\n\t    strcpy_DYN(&outbuf, \" \");\n\t}\n    }\n#if 0\n    fprintf(stderr, \"num_bools = %d\\n\", num_bools);\n    fprintf(stderr, \"num_values = %d\\n\", num_values);\n    fprintf(stderr, \"num_strings = %d\\n\", num_strings);\n    fprintf(stderr, \"term_names=%s, len=%d, strlen(outbuf)=%d, outbuf=%s\\n\",\n\t    tterm->term_names, len, outbuf.used, outbuf.text);\n#endif\n     \n    return (infodump ? len : (int) termcap_length(outbuf.text));\n}\n\nstatic bool\nkill_string(TERMTYPE2 *tterm, char *cap)\n{\n    unsigned n;\n    for (n = 0; n < NUM_STRINGS(tterm); ++n) {\n\tif (cap == tterm->Strings[n]) {\n\t    tterm->Strings[n] = ABSENT_STRING;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\nstatic char *\nfind_string(TERMTYPE2 *tterm, char *name)\n{\n    PredIdx n;\n    for (n = 0; n < NUM_STRINGS(tterm); ++n) {\n\tif (version_filter(STRING, n)\n\t    && !strcmp(name, strnames[n])) {\n\t    char *cap = tterm->Strings[n];\n\t    if (VALID_STRING(cap)) {\n\t\treturn cap;\n\t    }\n\t    break;\n\t}\n    }\n    return ABSENT_STRING;\n}\n\n \nstatic int\nkill_labels(TERMTYPE2 *tterm, int target)\n{\n    int n;\n    int result = 0;\n    char name[20];\n\n    for (n = 0; n <= 10; ++n) {\n\tchar *cap;\n\n\t_nc_SPRINTF(name, _nc_SLIMIT(sizeof(name)) \"lf%d\", n);\n\tcap = find_string(tterm, name);\n\tif (VALID_STRING(cap)\n\t    && kill_string(tterm, cap)) {\n\t    target -= (int) (strlen(cap) + 5);\n\t    ++result;\n\t    if (target < 0)\n\t\tbreak;\n\t}\n    }\n    return result;\n}\n\n \nstatic int\nkill_fkeys(TERMTYPE2 *tterm, int target)\n{\n    int n;\n    int result = 0;\n    char name[20];\n\n    for (n = 60; n >= 0; --n) {\n\tchar *cap;\n\n\t_nc_SPRINTF(name, _nc_SLIMIT(sizeof(name)) \"kf%d\", n);\n\tcap = find_string(tterm, name);\n\tif (VALID_STRING(cap)\n\t    && kill_string(tterm, cap)) {\n\t    target -= (int) (strlen(cap) + 5);\n\t    ++result;\n\t    if (target < 0)\n\t\tbreak;\n\t}\n    }\n    return result;\n}\n\n \n#define isLine(c) (strchr(\"lmkjtuvwqxn\", c) != 0)\n\nstatic bool\none_one_mapping(const char *mapping)\n{\n    bool result = TRUE;\n\n    if (VALID_STRING(mapping)) {\n\tint n = 0;\n\twhile (mapping[n] != '\\0' && mapping[n + 1] != '\\0') {\n\t    if (isLine(mapping[n]) &&\n\t\tmapping[n] != mapping[n + 1]) {\n\t\tresult = FALSE;\n\t\tbreak;\n\t    }\n\t    n += 2;\n\t}\n    }\n    return result;\n}\n\n#define FMT_ENTRY() \\\n\t\tfmt_entry(tterm, pred, \\\n\t\t\t0, \\\n\t\t\tsuppress_untranslatable, \\\n\t\t\tinfodump, numbers)\n\n#define SHOW_WHY PRINTF\n\nstatic bool\npurged_acs(TERMTYPE2 *tterm)\n{\n    bool result = FALSE;\n\n    if (VALID_STRING(acs_chars)) {\n\tif (!one_one_mapping(acs_chars)) {\n\t    enter_alt_charset_mode = ABSENT_STRING;\n\t    exit_alt_charset_mode = ABSENT_STRING;\n\t    SHOW_WHY(\"# (rmacs/smacs removed for consistency)\\n\");\n\t}\n\tresult = TRUE;\n    }\n    return result;\n}\n\nstatic void\nencode_b64(char *target, char *source, unsigned state, int *saved)\n{\n     \n    static const char data[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789\" \"-_\";\n    int ch = UChar(source[state]);\n\n    switch (state % 3) {\n    case 0:\n\t*target++ = data[(ch >> 2) & 077];\n\t*saved = (ch << 4);\n\tbreak;\n    case 1:\n\t*target++ = data[((ch >> 4) | *saved) & 077];\n\t*saved = (ch << 2);\n\tbreak;\n    case 2:\n\t*target++ = data[((ch >> 6) | *saved) & 077];\n\t*target++ = data[ch & 077];\n\t*saved = 0;\n\tbreak;\n    }\n    *target = '\\0';\n}\n\n \nvoid\ndump_entry(TERMTYPE2 *tterm,\n\t   int suppress_untranslatable,\n\t   int limited,\n\t   int numbers,\n\t   PredFunc pred)\n{\n    TERMTYPE2 save_tterm;\n    int critlen;\n    const char *legend;\n    bool infodump;\n\n    if (quickdump) {\n\tchar bigbuf[65536];\n\tunsigned offset = 0;\n\n\tseparator = \"\";\n\ttrailer = \"\\n\";\n\tindent = 0;\n\n\tif (_nc_write_object(tterm, bigbuf, &offset, sizeof(bigbuf)) == OK) {\n\t    char numbuf[80];\n\t    unsigned n;\n\n\t    if (quickdump & 1) {\n\t\tif (outbuf.used)\n\t\t    wrap_concat1(\"\\n\");\n\t\twrap_concat1(\"hex:\");\n\t\tfor (n = 0; n < offset; ++n) {\n\t\t    _nc_SPRINTF(numbuf, _nc_SLIMIT(sizeof(numbuf))\n\t\t\t\t\"%02X\", UChar(bigbuf[n]));\n\t\t    wrap_concat1(numbuf);\n\t\t}\n\t    }\n\t    if (quickdump & 2) {\n\t\tstatic char padding[] =\n\t\t{0, 0};\n\t\tint value = 0;\n\n\t\tif (outbuf.used)\n\t\t    wrap_concat1(\"\\n\");\n\t\twrap_concat1(\"b64:\");\n\t\tfor (n = 0; n < offset; ++n) {\n\t\t    encode_b64(numbuf, bigbuf, n, &value);\n\t\t    wrap_concat1(numbuf);\n\t\t}\n\t\tswitch (n % 3) {\n\t\tcase 0:\n\t\t    break;\n\t\tcase 1:\n\t\t    encode_b64(numbuf, padding, 1, &value);\n\t\t    wrap_concat1(numbuf);\n\t\t    wrap_concat1(\"==\");\n\t\t    break;\n\t\tcase 2:\n\t\t    encode_b64(numbuf, padding, 1, &value);\n\t\t    wrap_concat1(numbuf);\n\t\t    wrap_concat1(\"=\");\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\treturn;\n    }\n\n    if (TcOutput()) {\n\tcritlen = MAX_TERMCAP_LENGTH;\n\tlegend = \"older termcap\";\n\tinfodump = FALSE;\n\tset_obsolete_termcaps(tterm);\n    } else {\n\tcritlen = MAX_TERMINFO_LENGTH;\n\tlegend = \"terminfo\";\n\tinfodump = TRUE;\n    }\n\n    save_sgr = set_attributes;\n\n    if ((FMT_ENTRY() > critlen)\n\t&& limited) {\n\n\tsave_tterm = *tterm;\n\tif (!suppress_untranslatable) {\n\t    SHOW_WHY(\"# (untranslatable capabilities removed to fit entry within %d bytes)\\n\",\n\t\t     critlen);\n\t    suppress_untranslatable = TRUE;\n\t}\n\tif (FMT_ENTRY() > critlen) {\n\t     \n\t    bool changed = FALSE;\n\n#if NCURSES_XNAMES\n\t     \n\t    unsigned n;\n\t    for (n = STRCOUNT; n < NUM_STRINGS(tterm); n++) {\n\t\tconst char *name = ExtStrname(tterm, (int) n, strnames);\n\n\t\tif (VALID_STRING(tterm->Strings[n])) {\n\t\t    set_attributes = ABSENT_STRING;\n\t\t     \n\t\t    if (strlen(name) <= 2) {\n\t\t\tSHOW_WHY(\"# (%s removed to fit entry within %d bytes)\\n\",\n\t\t\t\t name,\n\t\t\t\t critlen);\n\t\t    }\n\t\t    changed = TRUE;\n\t\t    if (FMT_ENTRY() <= critlen)\n\t\t\tbreak;\n\t\t}\n\t    }\n#endif\n\t    if (VALID_STRING(set_attributes)) {\n\t\tset_attributes = ABSENT_STRING;\n\t\tSHOW_WHY(\"# (sgr removed to fit entry within %d bytes)\\n\",\n\t\t\t critlen);\n\t\tchanged = TRUE;\n\t    }\n\t    if (!changed || (FMT_ENTRY() > critlen)) {\n\t\tif (purged_acs(tterm)) {\n\t\t    acs_chars = ABSENT_STRING;\n\t\t    SHOW_WHY(\"# (acsc removed to fit entry within %d bytes)\\n\",\n\t\t\t     critlen);\n\t\t    changed = TRUE;\n\t\t}\n\t    }\n\t    if (!changed || (FMT_ENTRY() > critlen)) {\n\t\tint oldversion = tversion;\n\t\tint len;\n\n\t\ttversion = V_BSD;\n\t\tSHOW_WHY(\"# (terminfo-only capabilities suppressed to fit entry within %d bytes)\\n\",\n\t\t\t critlen);\n\n\t\tlen = FMT_ENTRY();\n\t\tif (len > critlen\n\t\t    && kill_labels(tterm, len - critlen)) {\n\t\t    SHOW_WHY(\"# (some labels capabilities suppressed to fit entry within %d bytes)\\n\",\n\t\t\t     critlen);\n\t\t    len = FMT_ENTRY();\n\t\t}\n\t\tif (len > critlen\n\t\t    && kill_fkeys(tterm, len - critlen)) {\n\t\t    SHOW_WHY(\"# (some function-key capabilities suppressed to fit entry within %d bytes)\\n\",\n\t\t\t     critlen);\n\t\t    len = FMT_ENTRY();\n\t\t}\n\t\tif (len > critlen) {\n\t\t    (void) fprintf(stderr,\n\t\t\t\t   \"%s: %s entry is %d bytes long\\n\",\n\t\t\t\t   _nc_progname,\n\t\t\t\t   _nc_first_name(tterm->term_names),\n\t\t\t\t   len);\n\t\t    SHOW_WHY(\"# WARNING: this entry, %d bytes long, may core-dump %s libraries!\\n\",\n\t\t\t     len, legend);\n\t\t}\n\t\ttversion = oldversion;\n\t    }\n\t    set_attributes = save_sgr;\n\t    *tterm = save_tterm;\n\t}\n    } else if (!version_filter(STRING, STR_IDX(acs_chars))) {\n\tsave_tterm = *tterm;\n\tif (purged_acs(tterm)) {\n\t    (void) FMT_ENTRY();\n\t}\n\t*tterm = save_tterm;\n    }\n}\n\nvoid\ndump_uses(const char *name, bool infodump)\n \n{\n    char buffer[MAX_TERMINFO_LENGTH];\n\n    if (TcOutput())\n\ttrim_trailing();\n    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t\"%s%s\", infodump ? \"use=\" : \"tc=\", name);\n    wrap_concat1(buffer);\n}\n\nint\nshow_entry(void)\n{\n     \n    if (outbuf.used != 0) {\n\tbool infodump = !TcOutput();\n\tchar delim = (char) (infodump ? ',' : ':');\n\tint j;\n\n\tfor (j = (int) outbuf.used - 1; j > 0; --j) {\n\t    char ch = outbuf.text[j];\n\t    if (ch == '\\n') {\n\t\t;\n\t    } else if (isspace(UChar(ch))) {\n\t\toutbuf.used = (size_t) j;\n\t    } else if (!infodump && ch == '\\\\') {\n\t\toutbuf.used = (size_t) j;\n\t    } else if (ch == delim && (j == 0 || outbuf.text[j - 1] != '\\\\')) {\n\t\toutbuf.used = (size_t) (j + 1);\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n\toutbuf.text[outbuf.used] = '\\0';\n    }\n    if (outbuf.text != 0) {\n\t(void) fputs(outbuf.text, stdout);\n\tputchar('\\n');\n    }\n    return (int) outbuf.used;\n}\n\nvoid\ncompare_entry(PredHook hook,\n\t      TERMTYPE2 *tp GCC_UNUSED,\n\t      bool quiet)\n \n{\n    PredIdx i, j;\n    NCURSES_CONST char *name;\n\n    if (!quiet)\n\tfputs(\"    comparing booleans.\\n\", stdout);\n    for_each_boolean(j, tp) {\n\ti = BoolIndirect(j);\n\tname = ExtBoolname(tp, (int) i, bool_names);\n\n\tif (isObsolete(outform, name))\n\t    continue;\n\n\t(*hook) (CMP_BOOLEAN, i, name);\n    }\n\n    if (!quiet)\n\tfputs(\"    comparing numbers.\\n\", stdout);\n    for_each_number(j, tp) {\n\ti = NumIndirect(j);\n\tname = ExtNumname(tp, (int) i, num_names);\n\n\tif (isObsolete(outform, name))\n\t    continue;\n\n\t(*hook) (CMP_NUMBER, i, name);\n    }\n\n    if (!quiet)\n\tfputs(\"    comparing strings.\\n\", stdout);\n    for_each_string(j, tp) {\n\ti = StrIndirect(j);\n\tname = ExtStrname(tp, (int) i, str_names);\n\n\tif (isObsolete(outform, name))\n\t    continue;\n\n\t(*hook) (CMP_STRING, i, name);\n    }\n\n     \n    (*hook) (CMP_USE, 0, \"use\");\n\n}\n\n#define NOTSET(s)\t((s) == 0)\n\n \n#undef CUR\n#define CUR tp->\n\nstatic void\nset_obsolete_termcaps(TERMTYPE2 *tp)\n{\n#include \"capdefaults.c\"\n}\n\n \nvoid\nrepair_acsc(TERMTYPE2 *tp)\n{\n    if (VALID_STRING(acs_chars)) {\n\tsize_t n;\n\tchar mapped[256];\n\tunsigned source;\n\tunsigned target;\n\tbool fix_needed = FALSE;\n\n\tfor (n = 0, source = 0; acs_chars[n] != 0; n++) {\n\t    target = UChar(acs_chars[n]);\n\t    if (source >= target) {\n\t\tfix_needed = TRUE;\n\t\tbreak;\n\t    }\n\t    source = target;\n\t    if (acs_chars[n + 1])\n\t\tn++;\n\t}\n\n\tif (fix_needed) {\n\t    size_t m;\n\t    char extra = 0;\n\n\t    memset(mapped, 0, sizeof(mapped));\n\t    for (n = 0; acs_chars[n] != 0; n++) {\n\t\tsource = UChar(acs_chars[n]);\n\t\tif ((target = (unsigned char) acs_chars[n + 1]) != 0) {\n\t\t    mapped[source] = (char) target;\n\t\t    n++;\n\t\t} else {\n\t\t    extra = (char) source;\n\t\t}\n\t    }\n\t    for (n = m = 0; n < sizeof(mapped); n++) {\n\t\tif (mapped[n]) {\n\t\t    acs_chars[m++] = (char) n;\n\t\t    acs_chars[m++] = mapped[n];\n\t\t}\n\t    }\n\t    if (extra)\n\t\tacs_chars[m++] = extra;\t\t \n\t    acs_chars[m] = 0;\n\t}\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}