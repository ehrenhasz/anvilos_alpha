{
  "module_name": "tabs.c",
  "hash_id": "6eb25283d4945f25b9ae845786535bcb8483406dcd02fd3199cde31c8aae5fee",
  "original_prompt": "Ingested from ncurses-6.4/progs/tabs.c",
  "human_readable_source": " \n\n \n\n \n\n#define USE_LIBTINFO\n#include <progs.priv.h>\n#include <tty_settings.h>\n\nMODULE_ID(\"$Id: tabs.c,v 1.51 2022/02/26 22:44:44 tom Exp $\")\n\nstatic GCC_NORETURN void usage(void);\n\nconst char *_nc_progname;\nstatic int max_cols;\n\nstatic void\nfailed(const char *s)\n{\n    perror(s);\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic int\nputch(int c)\n{\n    return putchar(c);\n}\n\nstatic char *\nskip_csi(char *value)\n{\n    if (UChar(*value) == 0x9b)\n\t++value;\n    else if (!strncmp(value, \"\\033[\", 2))\n\tvalue += 2;\n    return value;\n}\n\n \nstatic bool\nansi_clear_tabs(void)\n{\n    bool result = FALSE;\n    if (VALID_STRING(clear_all_tabs)) {\n\tchar *param = skip_csi(clear_all_tabs);\n\tif (!strcmp(param, \"3g\"))\n\t    result = TRUE;\n    }\n    return result;\n}\n\nstatic void\ndo_tabs(int *tab_list)\n{\n    int last = 1;\n    int stop;\n    bool first = TRUE;\n\n    while ((stop = *tab_list++) > 0) {\n\tif (first) {\n\t    first = FALSE;\n\t    putchar('\\r');\n\t}\n\tif (last < stop) {\n\t    while (last++ < stop) {\n\t\tif (last > max_cols)\n\t\t    break;\n\t\tputchar(' ');\n\t    }\n\t}\n\tif (stop <= max_cols) {\n\t    tputs(set_tab, 1, putch);\n\t    last = stop;\n\t} else {\n\t    break;\n\t}\n    }\n    putchar('\\r');\n}\n\n \nstatic int *\ndecode_tabs(const char *tab_list, int margin)\n{\n    int *result = typeCalloc(int, strlen(tab_list) + (unsigned) max_cols);\n    int n = 0;\n    int value = 0;\n    int prior = 0;\n    int ch;\n\n    if (result == NULL)\n\tfailed(\"decode_tabs\");\n\n    if (margin < 0)\n\tmargin = 0;\n\n    while ((ch = *tab_list++) != '\\0') {\n\tif (isdigit(UChar(ch))) {\n\t    value *= 10;\n\t    value += (ch - '0');\n\t    if (value > max_cols)\n\t\tvalue = max_cols;\n\t} else if (ch == ',') {\n\t    result[n] = value + prior + margin;\n\t    if (n > 0 && result[n] <= result[n - 1]) {\n\t\tfprintf(stderr,\n\t\t\t\"%s: tab-stops are not in increasing order: %d %d\\n\",\n\t\t\t_nc_progname, value, result[n - 1]);\n\t\tfree(result);\n\t\tresult = 0;\n\t\tbreak;\n\t    }\n\t    ++n;\n\t    value = 0;\n\t    prior = 0;\n\t} else if (ch == '+') {\n\t    if (n)\n\t\tprior = result[n - 1];\n\t}\n    }\n\n    if (result != 0) {\n\t \n\tif ((n == 0) && (value > 0)) {\n\t    int step = value;\n\t    value = 1;\n\t    while (n < max_cols - 1) {\n\t\tresult[n++] = value + margin;\n\t\tvalue += step;\n\t    }\n\t}\n\n\t \n\tresult[n++] = value + prior + margin;\n\tresult[n] = 0;\n    }\n\n    return result;\n}\n\nstatic void\nprint_ruler(int *tab_list, const char *new_line)\n{\n    int last = 0;\n    int n;\n\n     \n    for (n = 0; n < max_cols; n += 10) {\n\tint ch = 1 + (n / 10);\n\tchar buffer[20];\n\t_nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer))\n\t\t    \"----+----%c\",\n\t\t    ((ch < 10)\n\t\t     ? (ch + '0')\n\t\t     : (ch + 'A' - 10)));\n\tprintf(\"%.*s\", ((max_cols - n) > 10) ? 10 : (max_cols - n), buffer);\n    }\n    printf(\"%s\", new_line);\n\n     \n    for (n = 0, last = 0; (tab_list[n] > 0) && (last < max_cols); ++n) {\n\tint stop = tab_list[n];\n\n\twhile (++last < stop) {\n\t    if (last <= max_cols) {\n\t\tputchar('-');\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n\tif (last <= max_cols) {\n\t    putchar('*');\n\t    last = stop;\n\t} else {\n\t    break;\n\t}\n    }\n    while (++last <= max_cols)\n\tputchar('-');\n    printf(\"%s\", new_line);\n}\n\n \nstatic void\nwrite_tabs(int *tab_list, const char *new_line)\n{\n    int stop;\n\n    while ((stop = *tab_list++) > 0 && stop <= max_cols) {\n\tfputs((stop == 1) ? \"*\" : \"\\t*\", stdout);\n    };\n     \n    if (stop < max_cols)\n\tfputs(\"\\t+\", stdout);\n    fputs(new_line, stdout);\n}\n\n \nstatic char *\ntrimmed_tab_list(const char *source)\n{\n    char *result = strdup(source);\n    if (result != 0) {\n\tint j, k, last;\n\n\tfor (j = k = last = 0; result[j] != 0; ++j) {\n\t    int ch = UChar(result[j]);\n\t    if (isspace(ch)) {\n\t\tif (last == '\\0') {\n\t\t    continue;\n\t\t} else if (isdigit(last) || last == ',') {\n\t\t    ch = ',';\n\t\t}\n\t    } else if (ch == ',') {\n\t\t;\n\t    } else {\n\t\tif (last == ',')\n\t\t    result[k++] = (char) last;\n\t\tresult[k++] = (char) ch;\n\t    }\n\t    last = ch;\n\t}\n\tresult[k] = '\\0';\n    }\n    return result;\n}\n\nstatic bool\ncomma_is_needed(const char *source)\n{\n    bool result = FALSE;\n\n    if (source != 0) {\n\tsize_t len = strlen(source);\n\tif (len != 0)\n\t    result = (source[len - 1] != ',');\n    } else {\n\tresult = FALSE;\n    }\n    return result;\n}\n\n \nstatic const char *\nadd_to_tab_list(char **append, const char *value)\n{\n    char *result = *append;\n    char *copied = trimmed_tab_list(value);\n\n    if (copied != 0 && *copied != '\\0') {\n\tconst char *comma = \",\";\n\tsize_t need = 1 + strlen(copied);\n\n\tif (*copied == ',')\n\t    comma = \"\";\n\telse if (!comma_is_needed(*append))\n\t    comma = \"\";\n\n\tneed += strlen(comma);\n\tif (*append != 0)\n\t    need += strlen(*append);\n\n\tresult = malloc(need);\n\tif (result == 0)\n\t    failed(\"add_to_tab_list\");\n\n\t*result = '\\0';\n\tif (*append != 0) {\n\t    _nc_STRCPY(result, *append, need);\n\t    free(*append);\n\t}\n\t_nc_STRCAT(result, comma, need);\n\t_nc_STRCAT(result, copied, need);\n\n\t*append = result;\n    }\n    free(copied);\n    return result;\n}\n\n \nstatic bool\ndo_set_margin(int margin, bool no_op)\n{\n    bool result = FALSE;\n\n    if (margin == 0) {\t\t \n\tif (VALID_STRING(clear_margins)) {\n\t    result = TRUE;\n\t    if (!no_op)\n\t\ttputs(clear_margins, 1, putch);\n\t}\n    } else if (margin-- < 0) {\t \n\tresult = TRUE;\n    } else if (VALID_STRING(set_left_margin)) {\n\tresult = TRUE;\n\tif (!no_op) {\n\t     \n\t    if (VALID_STRING(column_address)) {\n\t\ttputs(TIPARM_1(column_address, margin), 1, putch);\n\t    } else if (margin >= 1) {\n\t\tif (VALID_STRING(parm_right_cursor)) {\n\t\t    tputs(TIPARM_1(parm_right_cursor, margin), 1, putch);\n\t\t} else {\n\t\t    while (margin-- > 0)\n\t\t\tputch(' ');\n\t\t}\n\t    }\n\t    tputs(set_left_margin, 1, putch);\n\t}\n    } else if (VALID_STRING(set_left_margin_parm)) {\n\tresult = TRUE;\n\tif (!no_op) {\n\t    if (VALID_STRING(set_right_margin_parm)) {\n\t\ttputs(TIPARM_1(set_left_margin_parm, margin), 1, putch);\n\t    } else {\n\t\ttputs(TIPARM_2(set_left_margin_parm, margin, max_cols), 1, putch);\n\t    }\n\t}\n    } else if (VALID_STRING(set_lr_margin)) {\n\tresult = TRUE;\n\tif (!no_op) {\n\t    tputs(TIPARM_2(set_lr_margin, margin, max_cols), 1, putch);\n\t}\n    }\n    return result;\n}\n\n \nstatic bool\nlegal_tab_list(const char *tab_list)\n{\n    bool result = TRUE;\n\n    if (tab_list != 0 && *tab_list != '\\0') {\n\tif (comma_is_needed(tab_list)) {\n\t    int n;\n\n\t    for (n = 0; tab_list[n] != '\\0'; ++n) {\n\t\tint ch = UChar(tab_list[n]);\n\n\t\tif (!(isdigit(ch) || ch == ',' || ch == '+')) {\n\t\t    fprintf(stderr,\n\t\t\t    \"%s: unexpected character found '%c'\\n\",\n\t\t\t    _nc_progname, ch);\n\t\t    result = FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t} else {\n\t    fprintf(stderr, \"%s: trailing comma found '%s'\\n\", _nc_progname, tab_list);\n\t    result = FALSE;\n\t}\n    } else {\n\t \n    }\n    return result;\n}\n\nstatic char *\nskip_list(char *value)\n{\n    while (*value != '\\0' &&\n\t   (isdigit(UChar(*value)) ||\n\t    isspace(UChar(*value)) ||\n\t    strchr(\"+,\", UChar(*value)) != 0)) {\n\t++value;\n    }\n    return value;\n}\n\nstatic void\nusage(void)\n{\n#define DATA(s) s \"\\n\"\n    static const char msg[] =\n    {\n\tDATA(\"Usage: tabs [options] [tabstop-list]\")\n\tDATA(\"\")\n\tDATA(\"Options:\")\n\tDATA(\"  -0       reset tabs\")\n\tDATA(\"  -8       set tabs to standard interval\")\n\tDATA(\"  -a       Assembler, IBM S/370, first format\")\n\tDATA(\"  -a2      Assembler, IBM S/370, second format\")\n\tDATA(\"  -c       COBOL, normal format\")\n\tDATA(\"  -c2      COBOL compact format\")\n\tDATA(\"  -c3      COBOL compact format extended\")\n\tDATA(\"  -d       debug (show ruler with expected/actual tab positions)\")\n\tDATA(\"  -f       FORTRAN\")\n\tDATA(\"  -n       no-op (do not modify terminal settings)\")\n\tDATA(\"  -p       PL/I\")\n\tDATA(\"  -s       SNOBOL\")\n\tDATA(\"  -u       UNIVAC 1100 Assembler\")\n\tDATA(\"  -T name  use terminal type 'name'\")\n\tDATA(\"  -V       print version\")\n\tDATA(\"\")\n\tDATA(\"A tabstop-list is an ordered list of column numbers, e.g., 1,11,21\")\n\tDATA(\"or 1,+10,+10 which is the same.\")\n    };\n#undef DATA\n\n    fflush(stdout);\n    fputs(msg, stderr);\n    ExitProgram(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int rc = EXIT_FAILURE;\n    bool debug = FALSE;\n    bool no_op = FALSE;\n    bool change_tty = FALSE;\n    int n, ch;\n    NCURSES_CONST char *term_name = 0;\n    char *append = 0;\n    const char *tab_list = 0;\n    const char *new_line = \"\\n\";\n    int margin = -1;\n    TTY tty_settings;\n    int fd;\n\n    _nc_progname = _nc_rootname(argv[0]);\n\n    if ((term_name = getenv(\"TERM\")) == 0)\n\tterm_name = \"ansi+tabs\";\n\n     \n    for (n = 1; n < argc; ++n) {\n\tchar *option = argv[n];\n\tswitch (option[0]) {\n\tcase '-':\n\t    while ((ch = *++option) != '\\0') {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t    switch (*++option) {\n\t\t    default:\n\t\t    case '\\0':\n\t\t\ttab_list = \"1,10,16,36,72\";\n\t\t\toption--;\n\t\t\t \n\t\t\tbreak;\n\t\t    case '2':\n\t\t\ttab_list = \"1,10,16,40,72\";\n\t\t\t \n\t\t\tbreak;\n\t\t    }\n\t\t    break;\n\t\tcase 'c':\n\t\t    switch (*++option) {\n\t\t    default:\n\t\t    case '\\0':\n\t\t\ttab_list = \"1,8,12,16,20,55\";\n\t\t\toption--;\n\t\t\t \n\t\t\tbreak;\n\t\t    case '2':\n\t\t\ttab_list = \"1,6,10,14,49\";\n\t\t\t \n\t\t\tbreak;\n\t\t    case '3':\n\t\t\ttab_list = \"1,6,10,14,18,22,26,30,34,38,42,46,50,54,58,62,67\";\n\t\t\t \n\t\t\tbreak;\n\t\t    }\n\t\t    break;\n\t\tcase 'd':\t \n\t\t    debug = TRUE;\n\t\t    break;\n\t\tcase 'f':\n\t\t    tab_list = \"1,7,11,15,19,23\";\n\t\t     \n\t\t    break;\n\t\tcase 'n':\t \n\t\t    no_op = TRUE;\n\t\t    break;\n\t\tcase 'p':\n\t\t    tab_list = \"1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61\";\n\t\t     \n\t\t    break;\n\t\tcase 's':\n\t\t    tab_list = \"1,10,55\";\n\t\t     \n\t\t    break;\n\t\tcase 'u':\n\t\t    tab_list = \"1,12,20,44\";\n\t\t     \n\t\t    break;\n\t\tcase 'T':\n\t\t    ++n;\n\t\t    if (*++option != '\\0') {\n\t\t\tterm_name = option;\n\t\t    } else {\n\t\t\tterm_name = argv[n];\n\t\t\toption--;\n\t\t    }\n\t\t    option += ((int) strlen(option)) - 1;\n\t\t    continue;\n\t\tcase 'V':\n\t\t    puts(curses_version());\n\t\t    ExitProgram(EXIT_SUCCESS);\n\t\tdefault:\n\t\t    if (isdigit(UChar(*option))) {\n\t\t\tchar *copy = strdup(option);\n\t\t\t*skip_list(copy) = '\\0';\n\t\t\ttab_list = copy;\n\t\t\toption = skip_list(option) - 1;\n\t\t    } else {\n\t\t\tusage();\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase '+':\n\t    if ((ch = *++option) != '\\0') {\n\t\tint digits = 0;\n\t\tint number = 0;\n\n\t\tswitch (ch) {\n\t\tcase 'm':\n\t\t     \n\t\t    while ((ch = *++option) != '\\0') {\n\t\t\tif (isdigit(UChar(ch))) {\n\t\t\t    ++digits;\n\t\t\t    number = number * 10 + (ch - '0');\n\t\t\t} else {\n\t\t\t    usage();\n\t\t\t}\n\t\t    }\n\t\t    if (digits == 0)\n\t\t\tnumber = 10;\n\t\t    margin = number;\n\t\t    break;\n\t\tdefault:\n\t\t     \n\t\t    if (option == argv[n] + 1) {\n\t\t\ttab_list = add_to_tab_list(&append, argv[n]);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tdefault:\n\t    if (append != 0) {\n\t\tif (tab_list != (const char *) append) {\n\t\t     \n\t\t    free(append);\n\t\t    append = 0;\n\t\t}\n\t    }\n\t    tab_list = add_to_tab_list(&append, option);\n\t    break;\n\t}\n    }\n\n    fd = save_tty_settings(&tty_settings, FALSE);\n\n    setupterm(term_name, fd, (int *) 0);\n\n    max_cols = (columns > 0) ? columns : 80;\n    if (margin > 0)\n\tmax_cols -= margin;\n\n    if (!VALID_STRING(clear_all_tabs)) {\n\tfprintf(stderr,\n\t\t\"%s: terminal type '%s' cannot reset tabs\\n\",\n\t\t_nc_progname, term_name);\n    } else if (!VALID_STRING(set_tab)) {\n\tfprintf(stderr,\n\t\t\"%s: terminal type '%s' cannot set tabs\\n\",\n\t\t_nc_progname, term_name);\n    } else if (legal_tab_list(tab_list)) {\n\tint *list;\n\n\tif (tab_list == NULL)\n\t    tab_list = add_to_tab_list(&append, \"8\");\n\n\tif (!no_op) {\n#if defined(TERMIOS) && defined(OCRNL)\n\t     \n\t    if (isatty(STDOUT_FILENO)) {\n\t\tTTY new_settings = tty_settings;\n\t\tnew_settings.c_oflag &= (unsigned)~OCRNL;\n\t\tupdate_tty_settings(&tty_settings, &new_settings);\n\t\tchange_tty = TRUE;\n\t\tnew_line = \"\\r\\n\";\n\t    }\n#endif\n\n\t    if (!ansi_clear_tabs())\n\t\tputch('\\r');\n\t    tputs(clear_all_tabs, 1, putch);\n\t}\n\n\tif (margin >= 0) {\n\t    putch('\\r');\n\t    if (margin > 0) {\n\t\t \n\t\tif (do_set_margin(0, no_op))\n\t\t    putch('\\r');\n\t    }\n\t    if (do_set_margin(margin, no_op))\n\t\tmargin = -1;\n\t}\n\n\tlist = decode_tabs(tab_list, margin);\n\n\tif (list != 0) {\n\t    if (!no_op)\n\t\tdo_tabs(list);\n\t    if (debug) {\n\t\tfflush(stderr);\n\t\tprintf(\"tabs %s%s\", tab_list, new_line);\n\t\tprint_ruler(list, new_line);\n\t\twrite_tabs(list, new_line);\n\t    }\n\t    free(list);\n\t} else if (debug) {\n\t    fflush(stderr);\n\t    printf(\"tabs %s%s\", tab_list, new_line);\n\t}\n\tif (!no_op) {\n\t    if (change_tty) {\n\t\trestore_tty_settings();\n\t    }\n\t}\n\trc = EXIT_SUCCESS;\n    }\n    if (append != 0)\n\tfree(append);\n    ExitProgram(rc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}