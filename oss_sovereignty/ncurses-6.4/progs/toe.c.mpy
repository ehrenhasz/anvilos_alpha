{
  "module_name": "toe.c",
  "hash_id": "9af50ceb97b3d47224a0070beba26cd23d2951841e8672a3450c5d1dceac4fd3",
  "original_prompt": "Ingested from ncurses-6.4/progs/toe.c",
  "human_readable_source": " \n\n \n\n \n\n#include <progs.priv.h>\n\n#include <sys/stat.h>\n\n#if USE_HASHED_DB\n#include <hashed_db.h>\n#endif\n\nMODULE_ID(\"$Id: toe.c,v 1.88 2022/09/03 23:29:32 tom Exp $\")\n\n#define isDotname(name) (!strcmp(name, \".\") || !strcmp(name, \"..\"))\n\ntypedef struct {\n    int db_index;\n    unsigned long checksum;\n    char *term_name;\n    char *description;\n} TERMDATA;\n\nconst char *_nc_progname;\n\nstatic TERMDATA *ptr_termdata;\t \nstatic size_t use_termdata;\t \nstatic size_t len_termdata;\t \n\n#if NO_LEAKS\n#undef ExitProgram\nstatic GCC_NORETURN void ExitProgram(int code);\nstatic void\nExitProgram(int code)\n{\n    _nc_free_entries(_nc_head);\n    _nc_free_tic(code);\n}\n#endif\n\nstatic GCC_NORETURN void failed(const char *);\n\nstatic void\nfailed(const char *msg)\n{\n    perror(msg);\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic char *\nstrmalloc(const char *value)\n{\n    char *result = strdup(value);\n    if (result == 0) {\n\tfailed(\"strmalloc\");\n    }\n    return result;\n}\n\nstatic TERMDATA *\nnew_termdata(void)\n{\n    size_t want = use_termdata + 1;\n\n    if (want >= len_termdata) {\n\tlen_termdata = (2 * want) + 10;\n\tptr_termdata = typeRealloc(TERMDATA, len_termdata, ptr_termdata);\n\tif (ptr_termdata == 0)\n\t    failed(\"ptr_termdata\");\n    }\n\n    return ptr_termdata + use_termdata++;\n}\n\nstatic int\ncompare_termdata(const void *a, const void *b)\n{\n    const TERMDATA *p = (const TERMDATA *) a;\n    const TERMDATA *q = (const TERMDATA *) b;\n    int result = strcmp(p->term_name, q->term_name);\n\n    if (result == 0) {\n\tresult = (p->db_index - q->db_index);\n    }\n    return result;\n}\n\n \nstatic void\nshow_termdata(int eargc, char **eargv)\n{\n    if (use_termdata) {\n\tsize_t n;\n\n\tif (eargc > 1) {\n\t    int j;\n\n\t    for (j = 0; j < eargc; ++j) {\n\t\tint k;\n\n\t\tfor (k = 0; k <= j; ++k) {\n\t\t    printf(\"--\");\n\t\t}\n\t\tprintf(\"> \");\n\t\tprintf(\"%s\\n\", eargv[j]);\n\t    }\n\t}\n\tif (use_termdata > 1)\n\t    qsort(ptr_termdata, use_termdata, sizeof(TERMDATA), compare_termdata);\n\tfor (n = 0; n < use_termdata; ++n) {\n\t    int nk = -1;\n\n\t     \n\t    if (eargc > 1) {\n\t\tunsigned long check = 0;\n\t\tint k = 0;\n\t\tfor (;;) {\n\t\t    char mark = ((check == 0\n\t\t\t\t  || (check != ptr_termdata[n].checksum))\n\t\t\t\t ? '*'\n\t\t\t\t : '+');\n\n\t\t    for (; k < ptr_termdata[n].db_index; ++k) {\n\t\t\tprintf(\"--\");\n\t\t    }\n\n\t\t     \n\t\t    printf(\"%c-\", mark);\n\t\t    check = ptr_termdata[n].checksum;\n\t\t    if (mark == '*' && nk < 0)\n\t\t\tnk = (int) n;\n\n\t\t    ++k;\n\t\t    if ((n + 1) >= use_termdata\n\t\t\t|| strcmp(ptr_termdata[n].term_name,\n\t\t\t\t  ptr_termdata[n + 1].term_name)) {\n\t\t\tbreak;\n\t\t    }\n\t\t    ++n;\n\t\t}\n\t\tfor (; k < eargc; ++k) {\n\t\t    printf(\"--\");\n\t\t}\n\t\tprintf(\":\\t\");\n\t    }\n\t    if (nk < 0)\n\t\tnk = (int) n;\n\n\t    (void) printf(\"%-10s\\t%s\\n\",\n\t\t\t  ptr_termdata[n].term_name,\n\t\t\t  ptr_termdata[nk].description);\n\t}\n    }\n}\n\nstatic void\nfree_termdata(void)\n{\n    if (ptr_termdata != 0) {\n\twhile (use_termdata != 0) {\n\t    --use_termdata;\n\t    free(ptr_termdata[use_termdata].term_name);\n\t    free(ptr_termdata[use_termdata].description);\n\t}\n\tfree(ptr_termdata);\n\tptr_termdata = 0;\n    }\n    use_termdata = 0;\n    len_termdata = 0;\n}\n\nstatic char **\nallocArgv(size_t count)\n{\n    char **result = typeCalloc(char *, count + 1);\n    if (result == 0)\n\tfailed(\"realloc eargv\");\n\n    assert(result != 0);\n    return result;\n}\n\nstatic void\nfreeArgv(char **argv)\n{\n    if (argv) {\n\tint count = 0;\n\twhile (argv[count]) {\n\t    free(argv[count++]);\n\t}\n\tfree(argv);\n    }\n}\n\n#if USE_HASHED_DB\nstatic bool\nmake_db_name(char *dst, const char *src, unsigned limit)\n{\n    static const char suffix[] = DBM_SUFFIX;\n\n    bool result = FALSE;\n    size_t lens = sizeof(suffix) - 1;\n    size_t size = strlen(src);\n    size_t need = lens + size;\n\n    if (need <= limit) {\n\tif (size >= lens\n\t    && !strcmp(src + size - lens, suffix)) {\n\t    _nc_STRCPY(dst, src, PATH_MAX);\n\t} else {\n\t    _nc_SPRINTF(dst, _nc_SLIMIT(PATH_MAX) \"%.*s%s\",\n\t\t\t(int) (PATH_MAX - sizeof(suffix)),\n\t\t\tsrc, suffix);\n\t}\n\tresult = TRUE;\n    }\n    return result;\n}\n#endif\n\ntypedef void (DescHook) (int   ,\n\t\t\t int   ,\n\t\t\t const char *   ,\n\t\t\t TERMTYPE2 *   );\n\nstatic const char *\nterm_description(TERMTYPE2 *tp)\n{\n    const char *desc;\n\n    if (tp->term_names == 0\n\t|| (desc = strrchr(tp->term_names, '|')) == 0\n\t|| (*++desc == '\\0')) {\n\tdesc = \"(No description)\";\n    }\n\n    return desc;\n}\n\n \nstatic void\ndeschook(int db_index, int db_limit, const char *term_name, TERMTYPE2 *tp)\n{\n    (void) db_index;\n    (void) db_limit;\n    (void) printf(\"%-10s\\t%s\\n\", term_name, term_description(tp));\n}\n\nstatic unsigned long\nstring_sum(const char *value)\n{\n    unsigned long result = 0;\n\n    if ((intptr_t) value == (intptr_t) (-1)) {\n\tresult = ~result;\n    } else if (value) {\n\twhile (*value) {\n\t    result += UChar(*value);\n\t    ++value;\n\t}\n    }\n    return result;\n}\n\nstatic unsigned long\nchecksum_of(TERMTYPE2 *tp)\n{\n    unsigned long result = string_sum(tp->term_names);\n    unsigned i;\n\n    for (i = 0; i < NUM_BOOLEANS(tp); i++) {\n\tresult += (unsigned long) (tp->Booleans[i]);\n    }\n    for (i = 0; i < NUM_NUMBERS(tp); i++) {\n\tresult += (unsigned long) (tp->Numbers[i]);\n    }\n    for (i = 0; i < NUM_STRINGS(tp); i++) {\n\tresult += string_sum(tp->Strings[i]);\n    }\n    return result;\n}\n\n \nstatic void\nsorthook(int db_index, int db_limit, const char *term_name, TERMTYPE2 *tp)\n{\n    TERMDATA *data = new_termdata();\n\n    data->db_index = db_index;\n    data->checksum = ((db_limit > 1) ? checksum_of(tp) : 0);\n    data->term_name = strmalloc(term_name);\n    data->description = strmalloc(term_description(tp));\n}\n\n#if NCURSES_USE_TERMCAP\n \nstatic bool\nis_termcap(char *buffer)\n{\n    bool result = TRUE;\n    while (*buffer != '\\0') {\n\tint ch = UChar(*buffer++);\n\tif (ch == '\\t')\n\t    continue;\n\tif (ch < ' ' || ch > '~') {\n\t    result = FALSE;\n\t    break;\n\t}\n    }\n    return result;\n}\n\nstatic void\nshow_termcap(int db_index, int db_limit, char *buffer, DescHook hook)\n{\n    TERMTYPE2 data;\n    char *next = strchr(buffer, ':');\n    char *last;\n    char *list = buffer;\n\n    if (next)\n\t*next = '\\0';\n\n    last = strrchr(buffer, '|');\n    if (last)\n\t++last;\n\n    memset(&data, 0, sizeof(data));\n    data.term_names = strmalloc(buffer);\n    while ((next = strtok(list, \"|\")) != 0) {\n\tif (next != last)\n\t    hook(db_index, db_limit, next, &data);\n\tlist = 0;\n    }\n    free(data.term_names);\n}\n#endif\n\n#if NCURSES_USE_DATABASE\nstatic char *\ncopy_entryname(DIRENT * src)\n{\n    size_t len = NAMLEN(src);\n    char *result = malloc(len + 1);\n    if (result == 0)\n\tfailed(\"copy entryname\");\n    memcpy(result, src->d_name, len);\n    result[len] = '\\0';\n\n    return result;\n}\n#endif\n\nstatic int\ntypelist(int eargc, char *eargv[],\n\t int verbosity,\n\t DescHook hook)\n \n{\n    int i;\n\n    for (i = 0; i < eargc; i++) {\n#if NCURSES_USE_DATABASE\n\tif (_nc_is_dir_path(eargv[i])) {\n\t    char *cwd_buf = 0;\n\t    DIR *termdir;\n\t    DIRENT *subdir;\n\n\t    if ((termdir = opendir(eargv[i])) == 0) {\n\t\t(void) fflush(stdout);\n\t\t(void) fprintf(stderr,\n\t\t\t       \"%s: can't open terminfo directory %s\\n\",\n\t\t\t       _nc_progname, eargv[i]);\n\t\tcontinue;\n\t    }\n\n\t    if (verbosity)\n\t\t(void) printf(\"#\\n#%s:\\n#\\n\", eargv[i]);\n\n\t    while ((subdir = readdir(termdir)) != 0) {\n\t\tsize_t cwd_len;\n\t\tchar *name_1;\n\t\tDIR *entrydir;\n\t\tDIRENT *entry;\n\n\t\tname_1 = copy_entryname(subdir);\n\t\tif (isDotname(name_1)) {\n\t\t    free(name_1);\n\t\t    continue;\n\t\t}\n\n\t\tcwd_len = NAMLEN(subdir) + strlen(eargv[i]) + 3;\n\t\tcwd_buf = typeRealloc(char, cwd_len, cwd_buf);\n\t\tif (cwd_buf == 0)\n\t\t    failed(\"realloc cwd_buf\");\n\n\t\tassert(cwd_buf != 0);\n\n\t\t_nc_SPRINTF(cwd_buf, _nc_SLIMIT(cwd_len)\n\t\t\t    \"%s/%s/\", eargv[i], name_1);\n\t\tfree(name_1);\n\n\t\tif (chdir(cwd_buf) != 0)\n\t\t    continue;\n\n\t\tentrydir = opendir(\".\");\n\t\tif (entrydir == 0) {\n\t\t    perror(cwd_buf);\n\t\t    continue;\n\t\t}\n\t\twhile ((entry = readdir(entrydir)) != 0) {\n\t\t    char *name_2;\n\t\t    TERMTYPE2 lterm;\n\t\t    char *cn;\n\t\t    int status;\n\n\t\t    name_2 = copy_entryname(entry);\n\t\t    if (isDotname(name_2) || !_nc_is_file_path(name_2)) {\n\t\t\tfree(name_2);\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    status = _nc_read_file_entry(name_2, &lterm);\n\t\t    if (status <= 0) {\n\t\t\t(void) fflush(stdout);\n\t\t\t(void) fprintf(stderr,\n\t\t\t\t       \"%s: couldn't open terminfo file %s.\\n\",\n\t\t\t\t       _nc_progname, name_2);\n\t\t\tfree(name_2);\n\t\t\tcontinue;\n\t\t    }\n\n\t\t     \n\t\t    cn = _nc_first_name(lterm.term_names);\n\t\t    if (!strcmp(cn, name_2)) {\n\t\t\t \n\t\t\thook(i, eargc, cn, &lterm);\n\t\t    }\n\t\t    _nc_free_termtype2(&lterm);\n\t\t    free(name_2);\n\t\t}\n\t\tclosedir(entrydir);\n\t    }\n\t    closedir(termdir);\n\t    if (cwd_buf != 0)\n\t\tfree(cwd_buf);\n\t    continue;\n\t}\n#if USE_HASHED_DB\n\telse {\n\t    DB *capdbp;\n\t    char filename[PATH_MAX];\n\n\t    if (verbosity)\n\t\t(void) printf(\"#\\n#%s:\\n#\\n\", eargv[i]);\n\n\t    if (make_db_name(filename, eargv[i], sizeof(filename))) {\n\t\tif ((capdbp = _nc_db_open(filename, FALSE)) != 0) {\n\t\t    DBT key, data;\n\t\t    int code;\n\n\t\t    code = _nc_db_first(capdbp, &key, &data);\n\t\t    while (code == 0) {\n\t\t\tTERMTYPE2 lterm;\n\t\t\tint used;\n\t\t\tchar *have;\n\t\t\tchar *cn;\n\n\t\t\tif (_nc_db_have_data(&key, &data, &have, &used)) {\n\t\t\t    if (_nc_read_termtype(&lterm, have, used) > 0) {\n\t\t\t\t \n\t\t\t\tcn = _nc_first_name(lterm.term_names);\n\t\t\t\t \n\t\t\t\thook(i, eargc, cn, &lterm);\n\t\t\t\t_nc_free_termtype2(&lterm);\n\t\t\t    }\n\t\t\t}\n\t\t\tcode = _nc_db_next(capdbp, &key, &data);\n\t\t    }\n\n\t\t    _nc_db_close(capdbp);\n\t\t    continue;\n\t\t}\n\t    }\n\t}\n#endif  \n#endif  \n#if NCURSES_USE_TERMCAP\n#if HAVE_BSD_CGETENT\n\t{\n\t    CGETENT_CONST char *db_array[2];\n\t    char *buffer = 0;\n\n\t    if (verbosity)\n\t\t(void) printf(\"#\\n#%s:\\n#\\n\", eargv[i]);\n\n\t    db_array[0] = eargv[i];\n\t    db_array[1] = 0;\n\n\t    if (cgetfirst(&buffer, db_array) > 0) {\n\t\tif (is_termcap(buffer)) {\n\t\t    show_termcap(i, eargc, buffer, hook);\n\t\t    free(buffer);\n\t\t    while (cgetnext(&buffer, db_array) > 0) {\n\t\t\tshow_termcap(i, eargc, buffer, hook);\n\t\t\tfree(buffer);\n\t\t    }\n\t\t}\n\t\tcgetclose();\n\t\tcontinue;\n\t    }\n\t}\n#else\n\t \n\tif (_nc_is_file_path(eargv[i])) {\n\t    char buffer[2048];\n\t    FILE *fp;\n\n\t    if (verbosity)\n\t\t(void) printf(\"#\\n#%s:\\n#\\n\", eargv[i]);\n\n\t    if ((fp = safe_fopen(eargv[i], \"r\")) != 0) {\n\t\twhile (fgets(buffer, sizeof(buffer), fp) != 0) {\n\t\t    if (!is_termcap(buffer))\n\t\t\tbreak;\n\t\t    if (*buffer == '#')\n\t\t\tcontinue;\n\t\t    if (isspace(*buffer))\n\t\t\tcontinue;\n\t\t    show_termcap(i, eargc, buffer, hook);\n\t\t}\n\t\tfclose(fp);\n\t    }\n\t}\n#endif\n#endif\n    }\n\n    if (hook == sorthook) {\n\tshow_termdata(eargc, eargv);\n\tfree_termdata();\n    }\n\n    return (EXIT_SUCCESS);\n}\n\nstatic void\nusage(void)\n{\n    (void) fprintf(stderr, \"usage: %s [-ahsuUV] [-v n] [file...]\\n\", _nc_progname);\n    ExitProgram(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    bool all_dirs = FALSE;\n    bool direct_dependencies = FALSE;\n    bool invert_dependencies = FALSE;\n    bool header = FALSE;\n    char *report_file = 0;\n    int code;\n    int this_opt, last_opt = '?';\n    unsigned v_opt = 0;\n    DescHook *hook = deschook;\n\n    _nc_progname = _nc_rootname(argv[0]);\n\n    while ((this_opt = getopt(argc, argv, \"0123456789ahsu:vU:V\")) != -1) {\n\t \n\tif (isdigit(this_opt)) {\n\t    switch (last_opt) {\n\t    case 'v':\n\t\tv_opt = (unsigned) (this_opt - '0');\n\t\tbreak;\n\t    default:\n\t\tif (isdigit(last_opt))\n\t\t    v_opt *= 10;\n\t\telse\n\t\t    v_opt = 0;\n\t\tv_opt += (unsigned) (this_opt - '0');\n\t\tlast_opt = this_opt;\n\t    }\n\t    continue;\n\t}\n\tswitch (this_opt) {\n\tcase 'a':\n\t    all_dirs = TRUE;\n\t    break;\n\tcase 'h':\n\t    header = TRUE;\n\t    break;\n\tcase 's':\n\t    hook = sorthook;\n\t    break;\n\tcase 'u':\n\t    direct_dependencies = TRUE;\n\t    report_file = optarg;\n\t    break;\n\tcase 'v':\n\t    v_opt = 1;\n\t    break;\n\tcase 'U':\n\t    invert_dependencies = TRUE;\n\t    report_file = optarg;\n\t    break;\n\tcase 'V':\n\t    puts(curses_version());\n\t    ExitProgram(EXIT_SUCCESS);\n\tdefault:\n\t    usage();\n\t}\n    }\n    use_verbosity(v_opt);\n\n    if (report_file != 0) {\n\tif (freopen(report_file, \"r\", stdin) == 0) {\n\t    (void) fflush(stdout);\n\t    fprintf(stderr, \"%s: can't open %s\\n\", _nc_progname, report_file);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n\n\t \n\t_nc_set_source(report_file);\n\t_nc_read_entry_source(stdin, 0, FALSE, FALSE, NULLHOOK);\n    }\n\n     \n    if (direct_dependencies) {\n\tENTRY *qp;\n\n\tfor_entry_list(qp) {\n\t    if (qp->nuses) {\n\t\tunsigned j;\n\n\t\t(void) printf(\"%s:\", _nc_first_name(qp->tterm.term_names));\n\t\tfor (j = 0; j < qp->nuses; j++)\n\t\t    (void) printf(\" %s\", qp->uses[j].name);\n\t\tputchar('\\n');\n\t    }\n\t}\n\n\tExitProgram(EXIT_SUCCESS);\n    }\n\n     \n    if (invert_dependencies) {\n\tENTRY *qp, *rp;\n\n\tfor_entry_list(qp) {\n\t    int matchcount = 0;\n\n\t    for_entry_list(rp) {\n\t\tunsigned i;\n\n\t\tif (rp->nuses == 0)\n\t\t    continue;\n\n\t\tfor (i = 0; i < rp->nuses; i++)\n\t\t    if (_nc_name_match(qp->tterm.term_names,\n\t\t\t\t       rp->uses[i].name, \"|\")) {\n\t\t\tif (matchcount++ == 0)\n\t\t\t    (void) printf(\"%s:\",\n\t\t\t\t\t  _nc_first_name(qp->tterm.term_names));\n\t\t\t(void) printf(\" %s\",\n\t\t\t\t      _nc_first_name(rp->tterm.term_names));\n\t\t    }\n\t    }\n\t    if (matchcount)\n\t\tputchar('\\n');\n\t}\n\n\tExitProgram(EXIT_SUCCESS);\n    }\n\n     \n    if (optind < argc) {\n\tcode = typelist(argc - optind, argv + optind, header, hook);\n    } else if (all_dirs) {\n\tDBDIRS state;\n\tint offset;\n\tint pass;\n\tchar **eargv = 0;\n\n\tcode = EXIT_FAILURE;\n\tfor (pass = 0; pass < 2; ++pass) {\n\t    size_t count = 0;\n\t    const char *path;\n\n\t    _nc_first_db(&state, &offset);\n\t    while ((path = _nc_next_db(&state, &offset)) != 0) {\n\t\tif (quick_prefix(path))\n\t\t    continue;\n\t\tif (pass) {\n\t\t    eargv[count] = strmalloc(path);\n\t\t}\n\t\t++count;\n\t    }\n\t    if (!pass) {\n\t\teargv = allocArgv(count);\n\t\tif (eargv == 0)\n\t\t    failed(\"eargv\");\n\t    } else {\n\t\tcode = typelist((int) count, eargv, header, hook);\n\t\tfreeArgv(eargv);\n\t    }\n\t}\n    } else {\n\tDBDIRS state;\n\tint offset;\n\tconst char *path;\n\tchar **eargv = allocArgv((size_t) 2);\n\tsize_t count = 0;\n\n\tif (eargv == 0)\n\t    failed(\"eargv\");\n\t_nc_first_db(&state, &offset);\n\tif ((path = _nc_next_db(&state, &offset)) != 0) {\n\t    if (!quick_prefix(path))\n\t\teargv[count++] = strmalloc(path);\n\t}\n\n\tcode = typelist((int) count, eargv, header, hook);\n\n\tfreeArgv(eargv);\n    }\n    _nc_last_db();\n\n    ExitProgram(code);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}