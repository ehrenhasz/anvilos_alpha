{
  "module_name": "tset.c",
  "hash_id": "9073064904915825612bc2a1c390f5336aa65409bbaf339b34d94257854aa040",
  "original_prompt": "Ingested from ncurses-6.4/progs/tset.c",
  "human_readable_source": " \n\n \n\n \n\n \n \n\n#include <reset_cmd.h>\n#include <termcap.h>\n#include <transform.h>\n#include <tty_settings.h>\n\n#if HAVE_GETTTYNAM\n#include <ttyent.h>\n#endif\n#ifdef NeXT\nchar *ttyname(int fd);\n#endif\n\nMODULE_ID(\"$Id: tset.c,v 1.131 2021/12/04 23:02:13 tom Exp $\")\n\n#ifndef environ\nextern char **environ;\n#endif\n\nconst char *_nc_progname = \"tset\";\n\n#define LOWERCASE(c) ((isalpha(UChar(c)) && isupper(UChar(c))) ? tolower(UChar(c)) : (c))\n\nstatic GCC_NORETURN void exit_error(void);\n\nstatic int\nCaselessCmp(const char *a, const char *b)\n{\t\t\t\t \n    while (*a && *b) {\n\tint cmp = LOWERCASE(*a) - LOWERCASE(*b);\n\tif (cmp != 0)\n\t    break;\n\ta++, b++;\n    }\n    return LOWERCASE(*a) - LOWERCASE(*b);\n}\n\nstatic GCC_NORETURN void\nexit_error(void)\n{\n    restore_tty_settings();\n    (void) fprintf(stderr, \"\\n\");\n    fflush(stderr);\n    ExitProgram(EXIT_FAILURE);\n     \n}\n\nstatic GCC_NORETURN void\nerr(const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    (void) fprintf(stderr, \"%s: \", _nc_progname);\n    (void) vfprintf(stderr, fmt, ap);\n    va_end(ap);\n    exit_error();\n     \n}\n\nstatic GCC_NORETURN void\nfailed(const char *msg)\n{\n    char temp[BUFSIZ];\n    size_t len = strlen(_nc_progname) + 2;\n\n    if ((int) len < (int) sizeof(temp) - 12) {\n\t_nc_STRCPY(temp, _nc_progname, sizeof(temp));\n\t_nc_STRCAT(temp, \": \", sizeof(temp));\n    } else {\n\t_nc_STRCPY(temp, \"tset: \", sizeof(temp));\n    }\n    _nc_STRNCAT(temp, msg, sizeof(temp), sizeof(temp) - strlen(temp) - 2);\n    perror(temp);\n    exit_error();\n     \n}\n\n \nstatic const char *\naskuser(const char *dflt)\n{\n    static char answer[256];\n\n     \n    clearerr(stdin);\n    if (feof(stdin) || ferror(stdin)) {\n\t(void) fprintf(stderr, \"\\n\");\n\texit_error();\n\t \n    }\n\n    for (;;) {\n\tchar *p;\n\n\tif (dflt)\n\t    (void) fprintf(stderr, \"Terminal type? [%s] \", dflt);\n\telse\n\t    (void) fprintf(stderr, \"Terminal type? \");\n\t(void) fflush(stderr);\n\n\tif (fgets(answer, sizeof(answer), stdin) == 0) {\n\t    if (dflt == 0) {\n\t\texit_error();\n\t\t \n\t    }\n\t    return (dflt);\n\t}\n\n\tif ((p = strchr(answer, '\\n')) != 0)\n\t    *p = '\\0';\n\tif (answer[0])\n\t    return (answer);\n\tif (dflt != 0)\n\t    return (dflt);\n    }\n}\n\n \n\n \n#define\tGT\t\t0x01\n#define\tEQ\t\t0x02\n#define\tLT\t\t0x04\n#define\tNOT\t\t0x08\n#define\tGE\t\t(GT | EQ)\n#define\tLE\t\t(LT | EQ)\n\ntypedef struct map {\n    struct map *next;\t\t \n    const char *porttype;\t \n    const char *type;\t\t \n    int conditional;\t\t \n    int speed;\t\t\t \n} MAP;\n\nstatic MAP *cur, *maplist;\n\n#define DATA(name,value) { { name }, value }\n\ntypedef struct speeds {\n    const char string[8];\n    int speed;\n} SPEEDS;\n\n#if defined(EXP_WIN32_DRIVER)\nstatic const SPEEDS speeds[] =\n{\n    {\"0\", 0}\n};\n#else\nstatic const SPEEDS speeds[] =\n{\n    DATA(\"0\", B0),\n    DATA(\"50\", B50),\n    DATA(\"75\", B75),\n    DATA(\"110\", B110),\n    DATA(\"134\", B134),\n    DATA(\"134.5\", B134),\n    DATA(\"150\", B150),\n    DATA(\"200\", B200),\n    DATA(\"300\", B300),\n    DATA(\"600\", B600),\n    DATA(\"1200\", B1200),\n    DATA(\"1800\", B1800),\n    DATA(\"2400\", B2400),\n    DATA(\"4800\", B4800),\n    DATA(\"9600\", B9600),\n     \n#ifdef B19200\n    DATA(\"19200\", B19200),\n#endif\n#ifdef B38400\n    DATA(\"38400\", B38400),\n#endif\n#ifdef B19200\n    DATA(\"19200\", B19200),\n#endif\n#ifdef B38400\n    DATA(\"38400\", B38400),\n#endif\n#ifdef B19200\n    DATA(\"19200\", B19200),\n#else\n#ifdef EXTA\n    DATA(\"19200\", EXTA),\n#endif\n#endif\n#ifdef B38400\n    DATA(\"38400\", B38400),\n#else\n#ifdef EXTB\n    DATA(\"38400\", EXTB),\n#endif\n#endif\n#ifdef B57600\n    DATA(\"57600\", B57600),\n#endif\n#ifdef B76800\n    DATA(\"76800\", B57600),\n#endif\n#ifdef B115200\n    DATA(\"115200\", B115200),\n#endif\n#ifdef B153600\n    DATA(\"153600\", B153600),\n#endif\n#ifdef B230400\n    DATA(\"230400\", B230400),\n#endif\n#ifdef B307200\n    DATA(\"307200\", B307200),\n#endif\n#ifdef B460800\n    DATA(\"460800\", B460800),\n#endif\n#ifdef B500000\n    DATA(\"500000\", B500000),\n#endif\n#ifdef B576000\n    DATA(\"576000\", B576000),\n#endif\n#ifdef B921600\n    DATA(\"921600\", B921600),\n#endif\n#ifdef B1000000\n    DATA(\"1000000\", B1000000),\n#endif\n#ifdef B1152000\n    DATA(\"1152000\", B1152000),\n#endif\n#ifdef B1500000\n    DATA(\"1500000\", B1500000),\n#endif\n#ifdef B2000000\n    DATA(\"2000000\", B2000000),\n#endif\n#ifdef B2500000\n    DATA(\"2500000\", B2500000),\n#endif\n#ifdef B3000000\n    DATA(\"3000000\", B3000000),\n#endif\n#ifdef B3500000\n    DATA(\"3500000\", B3500000),\n#endif\n#ifdef B4000000\n    DATA(\"4000000\", B4000000),\n#endif\n};\n#undef DATA\n#endif\n\nstatic int\ntbaudrate(char *rate)\n{\n    const SPEEDS *sp = 0;\n    size_t n;\n\n     \n    if (*rate == 'B')\n\t++rate;\n\n    for (n = 0; n < SIZEOF(speeds); ++n) {\n\tif (n > 0 && (speeds[n].speed <= speeds[n - 1].speed)) {\n\t     \n\t    break;\n\t}\n\tif (!CaselessCmp(rate, speeds[n].string)) {\n\t    sp = speeds + n;\n\t    break;\n\t}\n    }\n    if (sp == 0)\n\terr(\"unknown baud rate %s\", rate);\n    return (sp->speed);\n}\n\n \nstatic void\nadd_mapping(const char *port, char *arg)\n{\n    MAP *mapp;\n    char *copy, *p;\n    const char *termp;\n    char *base = 0;\n\n    copy = strdup(arg);\n    mapp = typeMalloc(MAP, 1);\n    if (copy == 0 || mapp == 0)\n\tfailed(\"malloc\");\n\n    assert(copy != 0);\n    assert(mapp != 0);\n\n    mapp->next = 0;\n    if (maplist == 0)\n\tcur = maplist = mapp;\n    else {\n\tcur->next = mapp;\n\tcur = mapp;\n    }\n\n    mapp->porttype = arg;\n    mapp->conditional = 0;\n\n    arg = strpbrk(arg, \"><@=!:\");\n\n    if (arg == 0) {\t\t \n\tmapp->type = mapp->porttype;\n\tmapp->porttype = 0;\n\tgoto done;\n    }\n\n    if (arg == mapp->porttype)\t \n\ttermp = mapp->porttype = 0;\n    else\n\ttermp = base = arg;\n\n    for (;; ++arg) {\t\t \n\tswitch (*arg) {\n\tcase '<':\n\t    if (mapp->conditional & GT)\n\t\tgoto badmopt;\n\t    mapp->conditional |= LT;\n\t    break;\n\tcase '>':\n\t    if (mapp->conditional & LT)\n\t\tgoto badmopt;\n\t    mapp->conditional |= GT;\n\t    break;\n\tcase '@':\n\tcase '=':\t\t \n\t    mapp->conditional |= EQ;\n\t    break;\n\tcase '!':\n\t    mapp->conditional |= NOT;\n\t    break;\n\tdefault:\n\t    goto next;\n\t}\n    }\n\n  next:\n    if (*arg == ':') {\n\tif (mapp->conditional)\n\t    goto badmopt;\n\t++arg;\n    } else {\t\t\t \n\targ = strchr(p = arg, ':');\n\tif (arg == 0)\n\t    goto badmopt;\n\t*arg++ = '\\0';\n\tmapp->speed = tbaudrate(p);\n    }\n\n    mapp->type = arg;\n\n     \n    if (termp != 0)\n\t*base = '\\0';\n\n     \n    if (mapp->conditional & NOT)\n\tmapp->conditional = ~mapp->conditional & (EQ | GT | LT);\n\n     \n  done:\n    if (port) {\n\tif (mapp->porttype) {\n\t  badmopt:\n\t    err(\"illegal -m option format: %s\", copy);\n\t}\n\tmapp->porttype = port;\n    }\n    free(copy);\n#ifdef MAPDEBUG\n    (void) printf(\"port: %s\\n\", mapp->porttype ? mapp->porttype : \"ANY\");\n    (void) printf(\"type: %s\\n\", mapp->type);\n    (void) printf(\"conditional: \");\n    p = \"\";\n    if (mapp->conditional & GT) {\n\t(void) printf(\"GT\");\n\tp = \"/\";\n    }\n    if (mapp->conditional & EQ) {\n\t(void) printf(\"%sEQ\", p);\n\tp = \"/\";\n    }\n    if (mapp->conditional & LT)\n\t(void) printf(\"%sLT\", p);\n    (void) printf(\"\\nspeed: %d\\n\", mapp->speed);\n#endif\n}\n\n \nstatic const char *\nmapped(const char *type)\n{\n    MAP *mapp;\n    int match;\n\n    for (mapp = maplist; mapp; mapp = mapp->next)\n\tif (mapp->porttype == 0 || !strcmp(mapp->porttype, type)) {\n\t    switch (mapp->conditional) {\n\t    case 0:\t\t \n\t\tmatch = TRUE;\n\t\tbreak;\n\t    case EQ:\n\t\tmatch = ((int) ospeed == mapp->speed);\n\t\tbreak;\n\t    case GE:\n\t\tmatch = ((int) ospeed >= mapp->speed);\n\t\tbreak;\n\t    case GT:\n\t\tmatch = ((int) ospeed > mapp->speed);\n\t\tbreak;\n\t    case LE:\n\t\tmatch = ((int) ospeed <= mapp->speed);\n\t\tbreak;\n\t    case LT:\n\t\tmatch = ((int) ospeed < mapp->speed);\n\t\tbreak;\n\t    default:\n\t\tmatch = FALSE;\n\t    }\n\t    if (match)\n\t\treturn (mapp->type);\n\t}\n     \n    return (type);\n}\n\n \n\n \nstatic const char *\nget_termcap_entry(int fd, char *userarg)\n{\n    int errret;\n    char *p;\n    const char *ttype;\n#if HAVE_PATH_TTYS\n#if HAVE_GETTTYNAM\n    struct ttyent *t;\n#else\n    FILE *fp;\n#endif\n    char *ttypath;\n#endif  \n\n    (void) fd;\n\n    if (userarg) {\n\tttype = userarg;\n\tgoto found;\n    }\n\n     \n    if ((ttype = getenv(\"TERM\")) != 0)\n\tgoto map;\n\n#if HAVE_PATH_TTYS\n    if ((ttypath = ttyname(fd)) != 0) {\n\tp = _nc_basename(ttypath);\n#if HAVE_GETTTYNAM\n\t \n\tif ((t = getttynam(p))) {\n\t    ttype = t->ty_type;\n\t    goto map;\n\t}\n#else\n\tif ((fp = fopen(\"/etc/ttytype\", \"r\")) != 0\n\t    || (fp = fopen(\"/etc/ttys\", \"r\")) != 0) {\n\t    char buffer[BUFSIZ];\n\t    char *s, *t, *d;\n\n\t    while (fgets(buffer, sizeof(buffer) - 1, fp) != 0) {\n\t\tfor (s = buffer, t = d = 0; *s; s++) {\n\t\t    if (isspace(UChar(*s)))\n\t\t\t*s = '\\0';\n\t\t    else if (t == 0)\n\t\t\tt = s;\n\t\t    else if (d == 0 && s != buffer && s[-1] == '\\0')\n\t\t\td = s;\n\t\t}\n\t\tif (t != 0 && d != 0 && !strcmp(d, p)) {\n\t\t    ttype = strdup(t);\n\t\t    fclose(fp);\n\t\t    goto map;\n\t\t}\n\t    }\n\t    fclose(fp);\n\t}\n#endif  \n    }\n#endif  \n\n     \n    ttype = \"unknown\";\n\n  map:ttype = mapped(ttype);\n\n     \n  found:\n    if ((p = getenv(\"TERMCAP\")) != 0 && !_nc_is_abs_path(p)) {\n\t \n\tint n;\n\tfor (n = 0; environ[n] != 0; n++) {\n\t    if (!strncmp(\"TERMCAP=\", environ[n], (size_t) 8)) {\n\t\twhile ((environ[n] = environ[n + 1]) != 0) {\n\t\t    n++;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n\n     \n    if (ttype[0] == '?') {\n\tif (ttype[1] != '\\0')\n\t    ttype = askuser(ttype + 1);\n\telse\n\t    ttype = askuser(0);\n    }\n     \n    while (setupterm((NCURSES_CONST char *) ttype, fd, &errret)\n\t   != OK) {\n\tif (errret == 0) {\n\t    (void) fprintf(stderr, \"%s: unknown terminal type %s\\n\",\n\t\t\t   _nc_progname, ttype);\n\t    ttype = 0;\n\t} else {\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s: can't initialize terminal type %s (error %d)\\n\",\n\t\t\t   _nc_progname, ttype, errret);\n\t    ttype = 0;\n\t}\n\tttype = askuser(ttype);\n    }\n#if BROKEN_LINKER\n    tgetflag(\"am\");\t\t \n#endif\n    return (ttype);\n}\n\n \n\n \nstatic void\nobsolete(char **argv)\n{\n    for (; *argv; ++argv) {\n\tchar *parm = argv[0];\n\n\tif (parm[0] == '-' && parm[1] == '\\0') {\n\t    argv[0] = strdup(\"-q\");\n\t    continue;\n\t}\n\n\tif ((parm[0] != '-')\n\t    || (argv[1] && argv[1][0] != '-')\n\t    || (parm[1] != 'e' && parm[1] != 'i' && parm[1] != 'k')\n\t    || (parm[2] != '\\0'))\n\t    continue;\n\tswitch (argv[0][1]) {\n\tcase 'e':\n\t    argv[0] = strdup(\"-e^H\");\n\t    break;\n\tcase 'i':\n\t    argv[0] = strdup(\"-i^C\");\n\t    break;\n\tcase 'k':\n\t    argv[0] = strdup(\"-k^U\");\n\t    break;\n\t}\n    }\n}\n\nstatic void\nprint_shell_commands(const char *ttype)\n{\n    const char *p;\n    int len;\n    char *var;\n    char *leaf;\n     \n    if ((var = getenv(\"SHELL\")) != 0\n\t&& ((len = (int) strlen(leaf = _nc_basename(var))) >= 3)\n\t&& !strcmp(leaf + len - 3, \"csh\"))\n\tp = \"set noglob;\\nsetenv TERM %s;\\nunset noglob;\\n\";\n    else\n\tp = \"TERM=%s;\\n\";\n    (void) printf(p, ttype);\n}\n\nstatic void\nusage(void)\n{\n#define SKIP(s)\t\t\t \n#define KEEP(s) s \"\\n\"\n    static const char msg[] =\n    {\n\tKEEP(\"\")\n\tKEEP(\"Options:\")\n\tSKIP(\"  -a arpanet  (obsolete)\")\n\tKEEP(\"  -c          set control characters\")\n\tSKIP(\"  -d dialup   (obsolete)\")\n\tKEEP(\"  -e ch       erase character\")\n\tKEEP(\"  -I          no initialization strings\")\n\tKEEP(\"  -i ch       interrupt character\")\n\tKEEP(\"  -k ch       kill character\")\n\tKEEP(\"  -m mapping  map identifier to type\")\n\tSKIP(\"  -p plugboard (obsolete)\")\n\tKEEP(\"  -Q          do not output control key settings\")\n\tKEEP(\"  -q          display term only, do no changes\")\n\tKEEP(\"  -r          display term on stderr\")\n\tSKIP(\"  -S          (obsolete)\")\n\tKEEP(\"  -s          output TERM set command\")\n\tKEEP(\"  -V          print curses-version\")\n\tKEEP(\"  -w          set window-size\")\n\tKEEP(\"\")\n\tKEEP(\"If neither -c/-w are given, both are assumed.\")\n    };\n#undef KEEP\n#undef SKIP\n    (void) fprintf(stderr, \"Usage: %s [options] [terminal]\\n\", _nc_progname);\n    fputs(msg, stderr);\n    ExitProgram(EXIT_FAILURE);\n     \n}\n\nstatic char\narg_to_char(void)\n{\n    return (char) ((optarg[0] == '^' && optarg[1] != '\\0')\n\t\t   ? ((optarg[1] == '?') ? '\\177' : CTRL(optarg[1]))\n\t\t   : optarg[0]);\n}\n\nint\nmain(int argc, char **argv)\n{\n    int ch, noinit, noset, quiet, Sflag, sflag, showterm;\n    const char *ttype;\n    int terasechar = -1;\t \n    int intrchar = -1;\t\t \n    int tkillchar = -1;\t\t \n    int my_fd;\n    bool opt_c = FALSE;\t\t \n    bool opt_w = FALSE;\t\t \n    TTY mode, oldmode;\n\n    _nc_progname = _nc_rootname(*argv);\n    obsolete(argv);\n    noinit = noset = quiet = Sflag = sflag = showterm = 0;\n    while ((ch = getopt(argc, argv, \"a:cd:e:Ii:k:m:p:qQrSsVw\")) != -1) {\n\tswitch (ch) {\n\tcase 'c':\t\t \n\t    opt_c = TRUE;\n\t    break;\n\tcase 'a':\t\t \n\t    add_mapping(\"arpanet\", optarg);\n\t    break;\n\tcase 'd':\t\t \n\t    add_mapping(\"dialup\", optarg);\n\t    break;\n\tcase 'e':\t\t \n\t    terasechar = arg_to_char();\n\t    break;\n\tcase 'I':\t\t \n\t    noinit = 1;\n\t    break;\n\tcase 'i':\t\t \n\t    intrchar = arg_to_char();\n\t    break;\n\tcase 'k':\t\t \n\t    tkillchar = arg_to_char();\n\t    break;\n\tcase 'm':\t\t \n\t    add_mapping(0, optarg);\n\t    break;\n\tcase 'p':\t\t \n\t    add_mapping(\"plugboard\", optarg);\n\t    break;\n\tcase 'Q':\t\t \n\t    quiet = 1;\n\t    break;\n\tcase 'q':\t\t \n\t    noset = 1;\n\t    break;\n\tcase 'r':\t\t \n\t    showterm = 1;\n\t    break;\n\tcase 'S':\t\t \n\t    Sflag = 1;\n\t    break;\n\tcase 's':\t\t \n\t    sflag = 1;\n\t    break;\n\tcase 'V':\t\t \n\t    puts(curses_version());\n\t    ExitProgram(EXIT_SUCCESS);\n\tcase 'w':\t\t \n\t    opt_w = TRUE;\n\t    break;\n\tcase '?':\n\tdefault:\n\t    usage();\n\t}\n    }\n\n    argc -= optind;\n    argv += optind;\n\n    if (argc > 1)\n\tusage();\n\n    if (!opt_c && !opt_w)\n\topt_c = opt_w = TRUE;\n\n    my_fd = save_tty_settings(&mode, TRUE);\n    oldmode = mode;\n#ifdef TERMIOS\n    ospeed = (NCURSES_OSPEED) cfgetospeed(&mode);\n#elif defined(EXP_WIN32_DRIVER)\n    ospeed = 0;\n#else\n    ospeed = (NCURSES_OSPEED) mode.sg_ospeed;\n#endif\n\n    if (same_program(_nc_progname, PROG_RESET)) {\n\treset_start(stderr, TRUE, FALSE);\n\treset_tty_settings(my_fd, &mode, noset);\n    } else {\n\treset_start(stderr, FALSE, TRUE);\n    }\n\n    ttype = get_termcap_entry(my_fd, *argv);\n\n    if (!noset) {\n#if HAVE_SIZECHANGE\n\tif (opt_w) {\n\t    set_window_size(my_fd, &lines, &columns);\n\t}\n#endif\n\tif (opt_c) {\n\t    set_control_chars(&mode, terasechar, intrchar, tkillchar);\n\t    set_conversions(&mode);\n\n\t    if (!noinit) {\n\t\tif (send_init_strings(my_fd, &oldmode)) {\n\t\t    (void) putc('\\r', stderr);\n\t\t    (void) fflush(stderr);\n\t\t    (void) napms(1000);\t\t \n\t\t}\n\t    }\n\n\t    update_tty_settings(&oldmode, &mode);\n\t}\n    }\n\n    if (noset) {\n\t(void) printf(\"%s\\n\", ttype);\n    } else {\n\tif (showterm)\n\t    (void) fprintf(stderr, \"Terminal type is %s.\\n\", ttype);\n\t \n\tif (!quiet) {\n\t    print_tty_chars(&oldmode, &mode);\n\t}\n    }\n\n    if (Sflag)\n\terr(\"The -S option is not supported under terminfo.\");\n\n    if (sflag) {\n\tprint_shell_commands(ttype);\n    }\n\n    ExitProgram(EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}