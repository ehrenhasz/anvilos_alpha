{
  "module_name": "tic.c",
  "hash_id": "f7bb91741a127a7ff2fb0a67d2a1467ddc5de1ab6cda56a4b8c8c3618bd8c58f",
  "original_prompt": "Ingested from ncurses-6.4/progs/tic.c",
  "human_readable_source": " \n\n \n\n \n\n#include <progs.priv.h>\n#include <sys/stat.h>\n\n#include <dump_entry.h>\n#include <tparm_type.h>\n#include <hashed_db.h>\n#include <parametrized.h>\n#include <transform.h>\n\nMODULE_ID(\"$Id: tic.c,v 1.320 2022/09/17 18:55:28 tom Exp $\")\n\n#define STDIN_NAME \"<stdin>\"\n\nconst char *_nc_progname = \"tic\";\n\nstatic FILE *log_fp;\nstatic FILE *tmp_fp;\nstatic bool capdump = FALSE;\t \nstatic bool infodump = FALSE;\t \nstatic bool showsummary = FALSE;\nstatic unsigned debug_level;\nstatic char **namelst = 0;\nstatic const char *to_remove;\n\n#if NCURSES_XNAMES\nstatic bool using_extensions = FALSE;\n#endif\n\nstatic void (*save_check_termtype) (TERMTYPE2 *, bool);\nstatic void check_termtype(TERMTYPE2 *tt, bool);\n\nstatic const char usage_string[] = \"\\\n[-e names] \\\n[-o dir] \\\n[-R name] \\\n[-v[n]] \\\n[-V] \\\n[-w[n]] \\\n[-\\\n1\\\na\\\nC\\\nD\\\nc\\\nf\\\nG\\\ng\\\nI\\\nK\\\nL\\\nN\\\nr\\\ns\\\nT\\\nt\\\nU\\\nx\\\n] \\\nsource-file\\n\";\n\n#if NO_LEAKS\nstatic void\nfree_namelist(char **src)\n{\n    if (src != 0) {\n\tint n;\n\tfor (n = 0; src[n] != 0; ++n)\n\t    free(src[n]);\n\tfree(src);\n    }\n}\n#endif\n\nstatic void\ncleanup(void)\n{\n#if NO_LEAKS\n    free_namelist(namelst);\n    _nc_leaks_dump_entry();\n#endif\n    if (tmp_fp != 0)\n\tfclose(tmp_fp);\n    if (to_remove != 0) {\n\tint rc;\n\n#if HAVE_REMOVE\n\trc = remove(to_remove);\n#else\n\trc = unlink(to_remove);\n#endif\n\tif (rc != 0)\n\t    perror(to_remove);\n    }\n}\n\nstatic void\nfailed(const char *msg)\n{\n    perror(msg);\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic void\nusage(void)\n{\n#define DATA(s) s \"\\n\"\n    static const char options_string[] =\n    {\n\tDATA(\"Options:\")\n\tDATA(\"  -0         format translation output all capabilities on one line\")\n\tDATA(\"  -1         format translation output one capability per line\")\n#if NCURSES_XNAMES\n\tDATA(\"  -a         retain commented-out capabilities (sets -x also)\")\n#endif\n\tDATA(\"  -C         translate entries to termcap source form\")\n\tDATA(\"  -D         print list of tic's database locations (first must be writable)\")\n\tDATA(\"  -c         check only, validate input without compiling or translating\")\n\tDATA(\"  -e<names>  translate/compile only entries named by comma-separated list\")\n\tDATA(\"  -f         format complex strings for readability\")\n\tDATA(\"  -G         format %{number} to %'char'\")\n\tDATA(\"  -g         format %'char' to %{number}\")\n\tDATA(\"  -I         translate entries to terminfo source form\")\n\tDATA(\"  -K         translate entries to termcap source form with BSD syntax\")\n\tDATA(\"  -L         translate entries to full terminfo source form\")\n\tDATA(\"  -N         disable smart defaults for source translation\")\n\tDATA(\"  -o<dir>    set output directory for compiled entry writes\")\n\tDATA(\"  -Q[n]      dump compiled description\")\n\tDATA(\"  -q    brief listing, removes headers\")\n\tDATA(\"  -R<name>   restrict translation to given terminfo/termcap version\")\n\tDATA(\"  -r         force resolution of all use entries in source translation\")\n\tDATA(\"  -s         print summary statistics\")\n\tDATA(\"  -T         remove size-restrictions on compiled description\")\n#if NCURSES_XNAMES\n\tDATA(\"  -t         suppress commented-out capabilities\")\n#endif\n\tDATA(\"  -U         suppress post-processing of entries\")\n\tDATA(\"  -V         print version\")\n\tDATA(\"  -W         wrap long strings according to -w[n] option\")\n\tDATA(\"  -v[n]      set verbosity level\")\n\tDATA(\"  -w[n]      set format width for translation output\")\n#if NCURSES_XNAMES\n\tDATA(\"  -x         treat unknown capabilities as user-defined\")\n#endif\n\tDATA(\"\")\n\tDATA(\"Parameters:\")\n\tDATA(\"  <file>     file to translate or compile\")\n    };\n#undef DATA\n\n    fprintf(stderr, \"Usage: %s %s\\n\", _nc_progname, usage_string);\n    fputs(options_string, stderr);\n    ExitProgram(EXIT_FAILURE);\n}\n\n#define L_BRACE '{'\n#define R_BRACE '}'\n#define S_QUOTE '\\''\n\nstatic void\nwrite_it(ENTRY * ep)\n{\n    unsigned n;\n    int ch;\n    char *s, *d, *t;\n    char result[MAX_ENTRY_SIZE];\n\n     \n    for (n = 0; n < STRCOUNT; n++) {\n\ts = ep->tterm.Strings[n];\n\tif (VALID_STRING(s)\n\t    && strchr(s, L_BRACE) != 0) {\n\t    d = result;\n\t    t = s;\n\t    while ((ch = *t++) != 0) {\n\t\t*d++ = (char) ch;\n\t\tif (ch == '\\\\') {\n\t\t    if ((*d++ = *t++) == '\\0')\n\t\t\tbreak;\n\t\t} else if ((ch == '%')\n\t\t\t   && (*t == L_BRACE)) {\n\t\t    char *v = 0;\n\t\t    long value = strtol(t + 1, &v, 0);\n\t\t    if (v != 0\n\t\t\t&& *v == R_BRACE\n\t\t\t&& value > 0\n\t\t\t&& value != '\\\\'\t \n\t\t\t&& value < 127\n\t\t\t&& isprint((int) value)) {\n\t\t\t*d++ = S_QUOTE;\n\t\t\t*d++ = (char) value;\n\t\t\t*d++ = S_QUOTE;\n\t\t\tt = (v + 1);\n\t\t    }\n\t\t}\n\t    }\n\t    *d = 0;\n\t    if (strlen(result) < strlen(s))\n\t\t_nc_STRCPY(s, result, strlen(s) + 1);\n\t}\n    }\n\n    _nc_set_type(_nc_first_name(ep->tterm.term_names));\n    _nc_curr_line = (int) ep->startline;\n    _nc_write_entry(&ep->tterm);\n}\n\nstatic bool\nimmedhook(ENTRY * ep GCC_UNUSED)\n \n{\n#if !HAVE_BIG_CORE\n     \n    if (ep->nuses == 0) {\n\tint oldline = _nc_curr_line;\n\n\twrite_it(ep);\n\t_nc_curr_line = oldline;\n\tfree(ep->tterm.str_table);\n\treturn (TRUE);\n    }\n#endif  \n    return (FALSE);\n}\n\nstatic void\nput_translate(int c)\n \n{\n    static bool in_name = FALSE;\n    static size_t used;\n\n    if (in_name) {\n\tstatic size_t have;\n\tstatic char *namebuf, *suffix;\n\n\tif (used + 1 >= have) {\n\t    have += 132;\n\t    if ((namebuf = typeRealloc(char, have, namebuf)) == NULL)\n\t\t  failed(\"put_translate namebuf\");\n\t    if ((suffix = typeRealloc(char, have, suffix)) == NULL)\n\t\t  failed(\"put_translate suffix\");\n\t}\n\tif (c == '\\n' || c == '@') {\n\t    namebuf[used++] = '\\0';\n\t    (void) putchar('<');\n\t    (void) fputs(namebuf, stdout);\n\t    putchar(c);\n\t    in_name = FALSE;\n\t} else if (c != '>') {\n\t    namebuf[used++] = (char) c;\n\t} else {\t\t \n\t    char *up;\n\t    NCURSES_CONST char *tp;\n\n\t    namebuf[used++] = '\\0';\n\t    in_name = FALSE;\n\n\t    suffix[0] = '\\0';\n\t    if ((up = strchr(namebuf, '#')) != 0\n\t\t|| (up = strchr(namebuf, '=')) != 0\n\t\t|| ((up = strchr(namebuf, '@')) != 0 && up[1] == '>')) {\n\t\t_nc_STRCPY(suffix, up, have);\n\t\t*up = '\\0';\n\t    }\n\n\t    if ((tp = nametrans(namebuf)) != 0) {\n\t\t(void) putchar(':');\n\t\t(void) fputs(tp, stdout);\n\t\t(void) fputs(suffix, stdout);\n\t\t(void) putchar(':');\n\t    } else {\n\t\t \n\t\t(void) putchar('<');\n\t\t(void) fputs(namebuf, stdout);\n\t\t(void) fputs(suffix, stdout);\n\t\t(void) putchar('>');\n\t    }\n\t}\n    } else {\n\tused = 0;\n\tif (c == '<') {\n\t    in_name = TRUE;\n\t} else {\n\t    putchar(c);\n\t}\n    }\n}\n\n \nstatic char *\nstripped(char *src)\n{\n    char *dst = 0;\n\n    while (isspace(UChar(*src)))\n\tsrc++;\n\n    if (*src != '\\0') {\n\tif ((dst = strdup(src)) == NULL) {\n\t    failed(\"strdup\");\n\t} else {\n\t    size_t len = strlen(dst);\n\t    while (--len != 0 && isspace(UChar(dst[len])))\n\t\tdst[len] = '\\0';\n\t}\n    }\n    return dst;\n}\n\nstatic FILE *\nopen_tempfile(char *filename)\n{\n    FILE *result = 0;\n\n    _nc_STRCPY(filename, \"/tmp/XXXXXX\", PATH_MAX);\n#if HAVE_MKSTEMP\n    {\n\tint oldmask = (int) umask(077);\n\tint fd = mkstemp(filename);\n\tif (fd >= 0)\n\t    result = fdopen(fd, \"w\");\n\tumask((mode_t) oldmask);\n    }\n#else\n    if (tmpnam(filename) != 0)\n\tresult = safe_fopen(filename, \"w\");\n#endif\n    return result;\n}\n\nstatic FILE *\ncopy_input(FILE *source, const char *filename, char *alt_file)\n{\n    char my_altfile[PATH_MAX];\n    FILE *result = 0;\n    FILE *target;\n    int ch;\n\n    if (alt_file == NULL)\n\talt_file = my_altfile;\n\n    if (source == NULL) {\n\tfailed(\"copy_input (source)\");\n    } else if ((target = open_tempfile(alt_file)) == NULL) {\n\tfailed(\"copy_input (target)\");\n    } else {\n\tclearerr(source);\n\tfor (;;) {\n\t    ch = fgetc(source);\n\t    if (feof(source)) {\n\t\tbreak;\n\t    } else if (ferror(source)) {\n\t\tfailed(filename);\n\t    } else if (ch == 0) {\n\t\t \n\t\tfprintf(stderr, \"%s: %s is not a text-file\\n\", _nc_progname, filename);\n\t\tExitProgram(EXIT_FAILURE);\n\t    }\n\t    fputc(ch, target);\n\t}\n\tfclose(source);\n\t \n\tresult = safe_fopen(alt_file, \"r+\");\n\tfclose(target);\n\tto_remove = strdup(alt_file);\n    }\n    return result;\n}\n\nstatic FILE *\nopen_input(const char *filename, char *alt_file)\n{\n    FILE *fp;\n    struct stat sb;\n    int mode;\n\n    if (!strcmp(filename, \"-\")) {\n\tfp = copy_input(stdin, STDIN_NAME, alt_file);\n    } else if (stat(filename, &sb) == -1) {\n\tfprintf(stderr, \"%s: %s %s\\n\", _nc_progname, filename, strerror(errno));\n\tExitProgram(EXIT_FAILURE);\n    } else if ((mode = (sb.st_mode & S_IFMT)) == S_IFDIR\n\t       || (mode != S_IFREG && mode != S_IFCHR && mode != S_IFIFO)) {\n\tfprintf(stderr, \"%s: %s is not a file\\n\", _nc_progname, filename);\n\tExitProgram(EXIT_FAILURE);\n    } else {\n\tfp = safe_fopen(filename, \"r\");\n\n\tif (fp == NULL) {\n\t    fprintf(stderr, \"%s: Can't open %s\\n\", _nc_progname, filename);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n\tif (mode != S_IFREG) {\n\t    if (alt_file != 0) {\n\t\tFILE *fp2 = copy_input(fp, filename, alt_file);\n\t\tfp = fp2;\n\t    } else {\n\t\tfprintf(stderr, \"%s: %s is not a file\\n\", _nc_progname, filename);\n\t\tExitProgram(EXIT_FAILURE);\n\t    }\n\t}\n    }\n    return fp;\n}\n\n \nstatic char **\nmake_namelist(char *src)\n{\n    char **dst = 0;\n\n    char *s, *base;\n    unsigned pass, n, nn;\n    char buffer[BUFSIZ];\n\n    if (src == NULL) {\n\t  ;\n    } else if (strchr(src, '/') != 0) {\t\t \n\tFILE *fp = open_input(src, (char *) 0);\n\n\tfor (pass = 1; pass <= 2; pass++) {\n\t    nn = 0;\n\t    while (fgets(buffer, sizeof(buffer), fp) != 0) {\n\t\tif ((s = stripped(buffer)) != 0) {\n\t\t    if (dst != 0)\n\t\t\tdst[nn] = s;\n\t\t    else\n\t\t\tfree(s);\n\t\t    nn++;\n\t\t}\n\t    }\n\t    if (pass == 1) {\n\t\tif ((dst = typeCalloc(char *, nn + 1)) == NULL)\n\t\t      failed(\"make_namelist\");\n\t\trewind(fp);\n\t    }\n\t}\n\tfclose(fp);\n    } else {\t\t\t \n\tfor (pass = 1; pass <= 2; pass++) {\n\t    for (n = nn = 0, base = src;; n++) {\n\t\tint mark = src[n];\n\t\tif (mark == ',' || mark == '\\0') {\n\t\t    if (pass == 1) {\n\t\t\tnn++;\n\t\t    } else {\n\t\t\tsrc[n] = '\\0';\n\t\t\tif ((s = stripped(base)) != 0)\n\t\t\t    dst[nn++] = s;\n\t\t\tbase = &src[n + 1];\n\t\t    }\n\t\t}\n\t\tif (mark == '\\0')\n\t\t    break;\n\t    }\n\t    if (pass == 1) {\n\t\tif ((dst = typeCalloc(char *, nn + 1)) == NULL)\n\t\t      failed(\"make_namelist\");\n\t    }\n\t}\n    }\n    if (showsummary && (dst != 0)) {\n\tfprintf(log_fp, \"Entries that will be compiled:\\n\");\n\tfor (n = 0; dst[n] != 0; n++)\n\t    fprintf(log_fp, \"%u:%s\\n\", n + 1, dst[n]);\n    }\n    return dst;\n}\n\nstatic bool\nmatches(char **needle, const char *haystack)\n \n{\n    bool code = FALSE;\n\n    if (needle != 0) {\n\tsize_t n;\n\n\tfor (n = 0; needle[n] != 0; n++) {\n\t    if (_nc_name_match(haystack, needle[n], \"|\")) {\n\t\tcode = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    } else\n\tcode = TRUE;\n    return (code);\n}\n\nstatic char *\nvalid_db_path(const char *nominal)\n{\n    struct stat sb;\n#if USE_HASHED_DB\n    char suffix[] = DBM_SUFFIX;\n    size_t need = strlen(nominal) + sizeof(suffix);\n    char *result = malloc(need);\n\n    if (result == NULL)\n\tfailed(\"valid_db_path\");\n    _nc_STRCPY(result, nominal, need);\n    if (strcmp(result + need - sizeof(suffix), suffix)) {\n\t_nc_STRCAT(result, suffix, need);\n    }\n#else\n    char *result = strdup(nominal);\n#endif\n\n    DEBUG(1, (\"** stat(%s)\", result));\n    if (stat(result, &sb) >= 0) {\n#if USE_HASHED_DB\n\tif (!S_ISREG(sb.st_mode)\n\t    || access(result, R_OK | W_OK) != 0) {\n\t    DEBUG(1, (\"...not a writable file\"));\n\t    free(result);\n\t    result = 0;\n\t}\n#else\n\tif (!S_ISDIR(sb.st_mode)\n\t    || access(result, R_OK | W_OK | X_OK) != 0) {\n\t    DEBUG(1, (\"...not a writable directory\"));\n\t    free(result);\n\t    result = 0;\n\t}\n#endif\n    } else {\n\t \n\tunsigned leaf = _nc_pathlast(result);\n\n\tDEBUG(1, (\"...not found\"));\n\tif (leaf) {\n\t    char save = result[leaf];\n\t    result[leaf] = 0;\n\t    if (stat(result, &sb) >= 0\n\t\t&& S_ISDIR(sb.st_mode)\n\t\t&& access(result, R_OK | W_OK | X_OK) == 0) {\n\t\tresult[leaf] = save;\n\t    } else {\n\t\tDEBUG(1, (\"...parent directory %s is not writable\", result));\n\t\tfree(result);\n\t\tresult = 0;\n\t    }\n\t} else {\n\t    DEBUG(1, (\"... no parent directory\"));\n\t    free(result);\n\t    result = 0;\n\t}\n    }\n    return result;\n}\n\n \nstatic void\nshow_databases(const char *outdir)\n{\n    bool specific = (outdir != 0) || getenv(\"TERMINFO\") != 0;\n    char *result;\n    const char *tried = 0;\n\n    if (outdir == NULL) {\n\toutdir = _nc_tic_dir(NULL);\n    }\n    if ((result = valid_db_path(outdir)) != 0) {\n\tprintf(\"%s\\n\", result);\n\tfree(result);\n    } else {\n\ttried = outdir;\n    }\n\n    if ((outdir = _nc_home_terminfo())) {\n\tif ((result = valid_db_path(outdir)) != 0) {\n\t    printf(\"%s\\n\", result);\n\t    free(result);\n\t} else if (!specific) {\n\t    tried = outdir;\n\t}\n    }\n\n     \n    if (tried) {\n\tfflush(stdout);\n\tfprintf(stderr, \"%s: %s (no permission)\\n\", _nc_progname, tried);\n\tExitProgram(EXIT_FAILURE);\n    }\n}\n\nstatic void\nadd_digit(int *target, int source)\n{\n    *target = (*target * 10) + (source - '0');\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char my_tmpname[PATH_MAX];\n    int v_opt = -1;\n    int smart_defaults = TRUE;\n    char *termcap;\n    ENTRY *qp;\n\n    int this_opt, last_opt = '?';\n\n    int outform = F_TERMINFO;\t \n    int sortmode = S_TERMINFO;\t \n\n    int width = 60;\n    int height = 65535;\n    bool formatted = FALSE;\t \n    bool literal = FALSE;\t \n    int numbers = 0;\t\t \n    bool forceresolve = FALSE;\t \n    bool limited = TRUE;\n    char *tversion = (char *) NULL;\n    const char *source_file = \"terminfo\";\n    char *outdir = (char *) NULL;\n    bool check_only = FALSE;\n    bool suppress_untranslatable = FALSE;\n    int quickdump = 0;\n    bool quiet = FALSE;\n    bool wrap_strings = FALSE;\n\n    log_fp = stderr;\n\n    _nc_progname = _nc_rootname(argv[0]);\n    atexit(cleanup);\n\n    if ((infodump = same_program(_nc_progname, PROG_CAPTOINFO)) != FALSE) {\n\toutform = F_TERMINFO;\n\tsortmode = S_TERMINFO;\n    }\n    if ((capdump = same_program(_nc_progname, PROG_INFOTOCAP)) != FALSE) {\n\toutform = F_TERMCAP;\n\tsortmode = S_TERMCAP;\n    }\n#if NCURSES_XNAMES\n     \n    _nc_user_definable = FALSE;\n#endif\n    _nc_strict_bsd = 0;\n\n     \n    while ((this_opt = getopt(argc, argv,\n\t\t\t      \"0123456789CDIKLNQR:TUVWace:fGgo:qrstvwx\")) != -1) {\n\tif (isdigit(this_opt)) {\n\t    switch (last_opt) {\n\t    case 'Q':\n\t\tadd_digit(&quickdump, this_opt);\n\t\tbreak;\n\t    case 'v':\n\t\tadd_digit(&v_opt, this_opt);\n\t\tbreak;\n\t    case 'w':\n\t\tadd_digit(&width, this_opt);\n\t\tbreak;\n\t    default:\n\t\tswitch (this_opt) {\n\t\tcase '0':\n\t\t    last_opt = this_opt;\n\t\t    width = 65535;\n\t\t    height = 1;\n\t\t    break;\n\t\tcase '1':\n\t\t    last_opt = this_opt;\n\t\t    width = 0;\n\t\t    break;\n\t\tdefault:\n\t\t    usage();\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tswitch (this_opt) {\n\tcase 'K':\n\t    _nc_strict_bsd = 1;\n\t     \n\t    break;\n\tcase 'C':\n\t    capdump = TRUE;\n\t    outform = F_TERMCAP;\n\t    sortmode = S_TERMCAP;\n\t    break;\n\tcase 'D':\n\t    debug_level = VtoTrace(v_opt);\n\t    use_verbosity(debug_level);\n\t    show_databases(outdir);\n\t    ExitProgram(EXIT_SUCCESS);\n\t    break;\n\tcase 'I':\n\t    infodump = TRUE;\n\t    outform = F_TERMINFO;\n\t    sortmode = S_TERMINFO;\n\t    break;\n\tcase 'L':\n\t    infodump = TRUE;\n\t    outform = F_VARIABLE;\n\t    sortmode = S_VARIABLE;\n\t    break;\n\tcase 'N':\n\t    smart_defaults = FALSE;\n\t    literal = TRUE;\n\t    break;\n\tcase 'Q':\n\t    quickdump = 0;\n\t    break;\n\tcase 'R':\n\t    tversion = optarg;\n\t    break;\n\tcase 'T':\n\t    limited = FALSE;\n\t    break;\n\tcase 'U':\n\t    literal = TRUE;\n\t    break;\n\tcase 'V':\n\t    puts(curses_version());\n\t    ExitProgram(EXIT_SUCCESS);\n\tcase 'W':\n\t    wrap_strings = TRUE;\n\t    break;\n\tcase 'c':\n\t    check_only = TRUE;\n\t    break;\n\tcase 'e':\n\t    namelst = make_namelist(optarg);\n\t    break;\n\tcase 'f':\n\t    formatted = TRUE;\n\t    break;\n\tcase 'G':\n\t    numbers = 1;\n\t    break;\n\tcase 'g':\n\t    numbers = -1;\n\t    break;\n\tcase 'o':\n\t    outdir = optarg;\n\t    break;\n\tcase 'q':\n\t    quiet = TRUE;\n\t    break;\n\tcase 'r':\n\t    forceresolve = TRUE;\n\t    break;\n\tcase 's':\n\t    showsummary = TRUE;\n\t    break;\n\tcase 'v':\n\t    v_opt = 0;\n\t    break;\n\tcase 'w':\n\t    width = 0;\n\t    break;\n#if NCURSES_XNAMES\n\tcase 't':\n\t    _nc_disable_period = FALSE;\n\t    suppress_untranslatable = TRUE;\n\t    break;\n\tcase 'a':\n\t    _nc_disable_period = TRUE;\n\t     \n\tcase 'x':\n\t    using_extensions = TRUE;\n\t    break;\n#endif\n\tdefault:\n\t    usage();\n\t}\n\tlast_opt = this_opt;\n    }\n\n     \n    debug_level = VtoTrace(v_opt);\n    use_verbosity(debug_level);\n\n     \n#if NCURSES_XNAMES\n    if (using_extensions) {\n\tuse_extended_names(TRUE);\n    }\n#endif\n\n    if (_nc_tracing) {\n\tsave_check_termtype = _nc_check_termtype2;\n\t_nc_check_termtype2 = check_termtype;\n    }\n#if !HAVE_BIG_CORE\n     \n    if (namelst && (!infodump && !capdump)) {\n\t(void) fprintf(stderr,\n\t\t       \"%s: Sorry, -e can't be used without -I or -C\\n\",\n\t\t       _nc_progname);\n\tExitProgram(EXIT_FAILURE);\n    }\n#endif  \n\n    if (optind < argc) {\n\tsource_file = argv[optind++];\n\tif (optind < argc) {\n\t    fprintf(stderr,\n\t\t    \"%s: Too many file names.  Usage:\\n\\t%s %s\",\n\t\t    _nc_progname,\n\t\t    _nc_progname,\n\t\t    usage_string);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n    } else {\n\tif (infodump == TRUE) {\n\t     \n\t    source_file = \"/etc/termcap\";\n\t    if ((termcap = getenv(\"TERMCAP\")) != 0\n\t\t&& (namelst = make_namelist(getenv(\"TERM\"))) != 0) {\n\t\tif (access(termcap, F_OK) == 0) {\n\t\t     \n\t\t    source_file = termcap;\n\t\t} else {\n\t\t    if ((tmp_fp = open_tempfile(my_tmpname)) != 0) {\n\t\t\tsource_file = my_tmpname;\n\t\t\tfprintf(tmp_fp, \"%s\\n\", termcap);\n\t\t\tfclose(tmp_fp);\n\t\t\ttmp_fp = open_input(source_file, (char *) 0);\n\t\t\tto_remove = source_file;\n\t\t    } else {\n\t\t\tfailed(\"tmpnam\");\n\t\t    }\n\t\t}\n\t    }\n\t} else {\n\t     \n\t    fprintf(stderr,\n\t\t    \"%s: File name needed.  Usage:\\n\\t%s %s\",\n\t\t    _nc_progname,\n\t\t    _nc_progname,\n\t\t    usage_string);\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n    }\n\n    if (tmp_fp == NULL) {\n\tchar my_altfile[PATH_MAX];\n\ttmp_fp = open_input(source_file, my_altfile);\n\tif (!strcmp(source_file, \"-\")) {\n\t    source_file = STDIN_NAME;\n\t}\n    }\n\n    if (infodump || check_only) {\n\tdump_init(tversion,\n\t\t  (smart_defaults\n\t\t   ? outform\n\t\t   : F_LITERAL),\n\t\t  sortmode,\n\t\t  wrap_strings, width, height,\n\t\t  debug_level, formatted || check_only, check_only, quickdump);\n    } else if (capdump) {\n\tdump_init(tversion,\n\t\t  outform,\n\t\t  sortmode,\n\t\t  wrap_strings, width, height,\n\t\t  debug_level, FALSE, FALSE, FALSE);\n    }\n\n     \n    _nc_set_source(source_file);\n#if !HAVE_BIG_CORE\n    if (!(check_only || infodump || capdump))\n\t_nc_set_writedir(outdir);\n#endif  \n    _nc_read_entry_source(tmp_fp, (char *) NULL,\n\t\t\t  !smart_defaults || literal, FALSE,\n\t\t\t  ((check_only || infodump || capdump)\n\t\t\t   ? NULLHOOK\n\t\t\t   : immedhook));\n\n     \n    if (check_only || (!infodump && !capdump) || forceresolve) {\n\tif (!_nc_resolve_uses2(TRUE, literal) && !check_only) {\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n    }\n\n     \n    if (check_only && limited && (capdump || infodump)) {\n\tfor_entry_list(qp) {\n\t    if (matches(namelst, qp->tterm.term_names)) {\n\t\tint len = fmt_entry(&qp->tterm, NULL, FALSE, TRUE, infodump, numbers);\n\n\t\tif (len > (infodump ? MAX_TERMINFO_LENGTH : MAX_TERMCAP_LENGTH))\n\t\t    (void) fprintf(stderr,\n\t\t\t\t   \"%s: resolved %s entry is %d bytes long\\n\",\n\t\t\t\t   _nc_progname,\n\t\t\t\t   _nc_first_name(qp->tterm.term_names),\n\t\t\t\t   len);\n\t    }\n\t}\n    }\n\n     \n    if (check_only) {\n\t \n\t_nc_curr_col = _nc_curr_line = -1;\n\n\tfor_entry_list(qp) {\n\t    if (matches(namelst, qp->tterm.term_names)) {\n\t\t \n\t\t_nc_set_type(_nc_first_name(qp->tterm.term_names));\n\t\t_nc_curr_line = (int) qp->startline;\n\t\trepair_acsc(&qp->tterm);\n\t\tdump_entry(&qp->tterm, suppress_untranslatable,\n\t\t\t   limited, numbers, NULL);\n\t    }\n\t}\n    } else {\n\tif (!infodump && !capdump) {\n\t    _nc_set_writedir(outdir);\n\t    for_entry_list(qp) {\n\t\tif (matches(namelst, qp->tterm.term_names))\n\t\t    write_it(qp);\n\t    }\n\t} else {\n\t     \n\t    _nc_curr_col = _nc_curr_line = -1;\n\n\t    for_entry_list(qp) {\n\t\tif (matches(namelst, qp->tterm.term_names)) {\n\t\t    long j = qp->cend - qp->cstart;\n\t\t    int len = 0;\n\n\t\t     \n\t\t    _nc_set_type(_nc_first_name(qp->tterm.term_names));\n\n\t\t    if (!quiet) {\n\t\t\t(void) fseek(tmp_fp, qp->cstart, SEEK_SET);\n\t\t\twhile (j-- > 0) {\n\t\t\t    int ch = fgetc(tmp_fp);\n\t\t\t    if (ch == EOF || ferror(tmp_fp)) {\n\t\t\t\tbreak;\n\t\t\t    } else if (infodump) {\n\t\t\t\t(void) putchar(ch);\n\t\t\t    } else {\n\t\t\t\tput_translate(ch);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    repair_acsc(&qp->tterm);\n\t\t    dump_entry(&qp->tterm, suppress_untranslatable,\n\t\t\t       limited, numbers, NULL);\n\t\t    for (j = 0; j < (long) qp->nuses; j++)\n\t\t\tdump_uses(qp->uses[j].name, !capdump);\n\t\t    len = show_entry();\n\t\t    if (debug_level != 0 && !limited)\n\t\t\tprintf(\"# length=%d\\n\", len);\n\t\t}\n\t    }\n\t    if (!namelst && _nc_tail && !quiet) {\n\t\tint c, oldc = '\\0';\n\t\tbool in_comment = FALSE;\n\t\tbool trailing_comment = FALSE;\n\n\t\t(void) fseek(tmp_fp, _nc_tail->cend, SEEK_SET);\n\t\twhile ((c = fgetc(tmp_fp)) != EOF) {\n\t\t    if (oldc == '\\n') {\n\t\t\tif (c == '#') {\n\t\t\t    trailing_comment = TRUE;\n\t\t\t    in_comment = TRUE;\n\t\t\t} else {\n\t\t\t    in_comment = FALSE;\n\t\t\t}\n\t\t    }\n\t\t    if (trailing_comment\n\t\t\t&& (in_comment || (oldc == '\\n' && c == '\\n')))\n\t\t\tputchar(c);\n\t\t    oldc = c;\n\t\t}\n\t    }\n\t}\n    }\n\n     \n    if (showsummary\n\t&& (!(check_only || infodump || capdump))) {\n\tint total = _nc_tic_written();\n\tif (total != 0)\n\t    fprintf(log_fp, \"%d entries written to %s\\n\",\n\t\t    total,\n\t\t    _nc_tic_dir(NULL));\n\telse\n\t    fprintf(log_fp, \"No entries written\\n\");\n    }\n    ExitProgram(EXIT_SUCCESS);\n}\n\n \n#undef CUR\n#define CUR tp->\n\n \nstatic void\ncheck_acs(TERMTYPE2 *tp)\n{\n    int vt100_smacs = 0;\n    int vt100_rmacs = 0;\n    int vt100_enacs = 0;\n\n     \n    ANDMISSING(ena_acs, enter_alt_charset_mode);\n    ANDMISSING(ena_acs, exit_alt_charset_mode);\n    PAIRED(exit_alt_charset_mode, exit_alt_charset_mode);\n\n     \n    if (VALID_STRING(enter_alt_charset_mode)) {\n\tvt100_smacs = (!strcmp(\"\\033(0\", enter_alt_charset_mode)\n\t\t       ? 2\n\t\t       : (!strcmp(\"\\016\", enter_alt_charset_mode)\n\t\t\t  ? 1\n\t\t\t  : 0));\n    }\n    if (VALID_STRING(exit_alt_charset_mode)) {\n\tvt100_rmacs = (!strcmp(\"\\033(B\", exit_alt_charset_mode)\n\t\t       ? 2\n\t\t       : (!strcmp(\"\\017\", exit_alt_charset_mode)\n\t\t\t  ? 1\n\t\t\t  : 0));\n    }\n    if (VALID_STRING(ena_acs)) {\n\tvt100_enacs = (!strcmp(\"\\033(B\\033)0\", ena_acs)\n\t\t       ? 2\n\t\t       : 0);\n    }\n    if (vt100_rmacs && vt100_smacs && (vt100_rmacs != vt100_smacs)) {\n\t_nc_warning(\"rmacs/smacs are inconsistent\");\n    }\n    if ((vt100_rmacs == 2) && (vt100_smacs == 2) && vt100_enacs) {\n\t_nc_warning(\"rmacs/smacs make enacs redundant\");\n    }\n    if ((vt100_rmacs == 1) && (vt100_smacs == 1) && !vt100_enacs) {\n\t_nc_warning(\"VT100-style rmacs/smacs require enacs\");\n    }\n\n    if (VALID_STRING(acs_chars)) {\n\tconst char *boxes = \"lmkjtuvwqxn\";\n\tchar mapped[256];\n\tchar missing[256];\n\tconst char *p;\n\tchar *q;\n\n\tmemset(mapped, 0, sizeof(mapped));\n\tfor (p = acs_chars; *p != '\\0'; p += 2) {\n\t    if (p[1] == '\\0') {\n\t\t_nc_warning(\"acsc has odd number of characters\");\n\t\tbreak;\n\t    }\n\t    mapped[UChar(p[0])] = p[1];\n\t}\n\n\tif (mapped[UChar('I')] && !mapped[UChar('i')]) {\n\t    _nc_warning(\"acsc refers to 'I', which is probably an error\");\n\t}\n\n\tfor (p = boxes, q = missing; *p != '\\0'; ++p) {\n\t    if (!mapped[UChar(p[0])]) {\n\t\t*q++ = p[0];\n\t    }\n\t}\n\t*q = '\\0';\n\n\tassert(strlen(missing) <= strlen(boxes));\n\tif (*missing != '\\0' && strcmp(missing, boxes)) {\n\t    _nc_warning(\"acsc is missing some line-drawing mapping: %s\", missing);\n\t}\n    }\n}\n\nstatic char *\nsafe_strdup(const char *value)\n{\n    if (value == NULL)\n\tvalue = \"\";\n    return strdup(value);\n}\n\nstatic bool\nsame_color(NCURSES_CONST char *oldcap, NCURSES_CONST char *newcap, int limit)\n{\n    bool result = FALSE;\n    if (limit > 16)\n\tlimit = 16;\n    if (limit >= 8) {\n\tint n;\n\tint same;\n\tfor (n = same = 0; n < limit; ++n) {\n\t    char *oldvalue = safe_strdup(TIPARM_1(oldcap, n));\n\t    char *newvalue = safe_strdup(TIPARM_1(newcap, n));\n\t    same += !strcmp(oldvalue, newvalue);\n\t    free(oldvalue);\n\t    free(newvalue);\n\t}\n\tresult = (same == limit);\n    }\n    return result;\n}\n\n \nstatic void\ncheck_colors(TERMTYPE2 *tp)\n{\n    char *value;\n\n    if ((max_colors > 0) != (max_pairs > 0)\n\t|| ((max_colors > max_pairs) && !VALID_STRING(initialize_pair)))\n\t_nc_warning(\"inconsistent values for max_colors (%d) and max_pairs (%d)\",\n\t\t    max_colors, max_pairs);\n\n    PAIRED(set_foreground, set_background);\n    PAIRED(set_a_foreground, set_a_background);\n    PAIRED(set_color_pair, initialize_pair);\n\n    if (VALID_STRING(set_foreground)\n\t&& VALID_STRING(set_a_foreground)) {\n\tif (!_nc_capcmp(set_foreground, set_a_foreground)) {\n\t    _nc_warning(\"expected setf/setaf to be different\");\n\t} else if (same_color(set_foreground, set_a_foreground, max_colors)) {\n\t    _nc_warning(\"setf/setaf are equivalent\");\n\t}\n    }\n\n    if (VALID_STRING(set_background)\n\t&& VALID_STRING(set_a_background)) {\n\tif (!_nc_capcmp(set_background, set_a_background)) {\n\t    _nc_warning(\"expected setb/setab to be different\");\n\t} else if (same_color(set_background, set_a_background, max_colors)) {\n\t    _nc_warning(\"setb/setab are equivalent\");\n\t}\n    }\n\n     \n    if (VALID_NUMERIC(max_colors) && VALID_NUMERIC(max_pairs)\n\t&& ((VALID_STRING(set_foreground)\n\t     && VALID_STRING(set_background))\n\t    || (VALID_STRING(set_a_foreground)\n\t\t&& VALID_STRING(set_a_background))\n\t    || set_color_pair)) {\n\tif (!VALID_STRING(orig_pair) && !VALID_STRING(orig_colors))\n\t    _nc_warning(\"expected either op/oc string for resetting colors\");\n    }\n    if (can_change) {\n\tif (!VALID_STRING(initialize_pair) &&\n\t    !VALID_STRING(initialize_color)) {\n\t    _nc_warning(\"expected initc or initp because ccc is given\");\n\t}\n    } else {\n\tif (VALID_STRING(initialize_pair) ||\n\t    VALID_STRING(initialize_color)) {\n\t    _nc_warning(\"expected ccc because initc is given\");\n\t}\n    }\n    value = tigetstr(\"RGB\");\n    if (VALID_STRING(value)) {\n\tint r, g, b;\n\tchar bad;\n\tint code = sscanf(value, \"%d/%d/%d%c\", &r, &g, &b, &bad);\n\tif (code != 3 || r <= 0 || g <= 0 || b <= 0) {\n\t    _nc_warning(\"unexpected value for RGB capability: %s\", value);\n\t}\n    }\n}\n\nstatic int\ncsi_length(const char *value)\n{\n    int result = 0;\n\n    if (value[0] == '\\033' && value[1] == '[') {\n\tresult = 2;\n    } else if (UChar(value[0]) == 0x9a) {\n\tresult = 1;\n    }\n    return result;\n}\n\nstatic char\nkeypad_final(const char *string)\n{\n    char result = '\\0';\n\n    if (VALID_STRING(string)\n\t&& *string++ == '\\033'\n\t&& *string++ == 'O'\n\t&& strlen(string) == 1) {\n\tresult = *string;\n    }\n\n    return result;\n}\n\nstatic long\nkeypad_index(const char *string)\n{\n    int ch;\n    long result = -1;\n\n    if ((ch = keypad_final(string)) != '\\0') {\n\tconst char *list = \"PQRSwxymtuvlqrsPpn\";\t \n\tchar *test = (strchr) (list, ch);\n\tif (test != 0)\n\t    result = (long) (test - list);\n    }\n    return result;\n}\n\n \nstatic void\ncheck_ansi_cursor(char *list[4])\n{\n    int j, k;\n    bool skip[4];\n    bool repeated = FALSE;\n\n    for (j = 0; j < 4; ++j) {\n\tskip[j] = FALSE;\n\tfor (k = 0; k < j; ++k) {\n\t    if (j != k\n\t\t&& !strcmp(list[j], list[k])) {\n\t\tchar *value = _nc_tic_expand(list[k], TRUE, 0);\n\t\t_nc_warning(\"repeated cursor control %s\", value);\n\t\trepeated = TRUE;\n\t    }\n\t}\n    }\n    if (!repeated) {\n\tchar *up = list[1];\n\tsize_t prefix = (size_t) csi_length(up);\n\tsize_t suffix;\n\n\tif (prefix) {\n\t    suffix = prefix;\n\t    while (up[suffix] && isdigit(UChar(up[suffix])))\n\t\t++suffix;\n\t}\n\tif (prefix && up[suffix] == 'A') {\n\t    skip[1] = TRUE;\n\t    if (!strcmp(list[0], \"\\n\"))\n\t\tskip[0] = TRUE;\n\t    if (!strcmp(list[2], \"\\b\"))\n\t\tskip[2] = TRUE;\n\n\t    for (j = 0; j < 4; ++j) {\n\t\tint want;\n\n\t\tif (skip[j] || strlen(list[j]) == 1)\n\t\t    continue;\n\t\tif (memcmp(list[j], up, prefix)) {\n\t\t    char *value = _nc_tic_expand(list[j], TRUE, 0);\n\t\t    _nc_warning(\"inconsistent prefix for %s\", value);\n\t\t    continue;\n\t\t}\n\t\tif (strlen(list[j]) < suffix) {\n\t\t    char *value = _nc_tic_expand(list[j], TRUE, 0);\n\t\t    _nc_warning(\"inconsistent length for %s, expected %d\",\n\t\t\t\tvalue, (int) suffix + 1);\n\t\t    continue;\n\t\t}\n\t\twant = \"BADC\"[j];\n\t\tif (list[j][suffix] != want) {\n\t\t    char *value = _nc_tic_expand(list[j], TRUE, 0);\n\t\t    _nc_warning(\"inconsistent suffix for %s, expected %c, have %c\",\n\t\t\t\tvalue, want, list[j][suffix]);\n\t\t}\n\t    }\n\t}\n    }\n}\n\n#define EXPECTED(name) if (!PRESENT(name)) _nc_warning(\"expected \" #name)\n#define UNEXPECTED(name) if (PRESENT(name)) _nc_warning(\"unexpected \" #name \", for %s\", why)\n\nstatic void\ncheck_noaddress(TERMTYPE2 *tp, const char *why)\n{\n    UNEXPECTED(column_address);\n    UNEXPECTED(cursor_address);\n    UNEXPECTED(cursor_home);\n    UNEXPECTED(cursor_mem_address);\n    UNEXPECTED(cursor_to_ll);\n    UNEXPECTED(row_address);\n    UNEXPECTED(row_address);\n}\n\nstatic void\ncheck_cursor(TERMTYPE2 *tp)\n{\n    int count;\n    char *list[4];\n\n    if (hard_copy) {\n\tcheck_noaddress(tp, \"hard_copy\");\n    } else if (generic_type) {\n\tcheck_noaddress(tp, \"generic_type\");\n    } else if (strchr(tp->term_names, '+') == NULL) {\n\tint y = 0;\n\tint x = 0;\n\tif (PRESENT(column_address))\n\t    ++y;\n\tif (PRESENT(cursor_address))\n\t    y = x = 10;\n\tif (PRESENT(cursor_home))\n\t    ++y, ++x;\n\tif (PRESENT(cursor_mem_address))\n\t    y = x = 10;\n\tif (PRESENT(cursor_to_ll))\n\t    ++y, ++x;\n\tif (PRESENT(row_address))\n\t    ++x;\n\tif (PRESENT(cursor_down))\n\t    ++y;\n\tif (PRESENT(cursor_up))\n\t    ++y;\n\tif (PRESENT(cursor_left))\n\t    ++x;\n\tif (PRESENT(cursor_right))\n\t    ++x;\n\tif (x < 2 && y < 2) {\n\t    _nc_warning(\"terminal lacks cursor addressing\");\n\t} else {\n\t    if (x < 2)\n\t\t_nc_warning(\"terminal lacks cursor column-addressing\");\n\t    if (y < 2)\n\t\t_nc_warning(\"terminal lacks cursor row-addressing\");\n\t}\n    }\n\n     \n    ANDMISSING(parm_insert_line, insert_line);\n    ANDMISSING(parm_delete_line, delete_line);\n    ANDMISSING(parm_insert_line, parm_delete_line);\n\n     \n    ANDMISSING(parm_down_cursor, cursor_down);\n    ANDMISSING(parm_up_cursor, cursor_up);\n    ANDMISSING(parm_left_cursor, cursor_left);\n    ANDMISSING(parm_right_cursor, cursor_right);\n\n     \n    count = 0;\n    if (PRESENT(parm_down_cursor)) {\n\tlist[count++] = parm_down_cursor;\n    }\n    if (PRESENT(parm_up_cursor)) {\n\tlist[count++] = parm_up_cursor;\n    }\n    if (PRESENT(parm_left_cursor)) {\n\tlist[count++] = parm_left_cursor;\n    }\n    if (PRESENT(parm_right_cursor)) {\n\tlist[count++] = parm_right_cursor;\n    }\n    if (count == 4) {\n\tcheck_ansi_cursor(list);\n    } else if (count != 0) {\n\tEXPECTED(parm_down_cursor);\n\tEXPECTED(parm_up_cursor);\n\tEXPECTED(parm_left_cursor);\n\tEXPECTED(parm_right_cursor);\n    }\n\n    count = 0;\n    if (PRESENT(cursor_down)) {\n\tlist[count++] = cursor_down;\n    }\n    if (PRESENT(cursor_up)) {\n\tlist[count++] = cursor_up;\n    }\n    if (PRESENT(cursor_left)) {\n\tlist[count++] = cursor_left;\n    }\n    if (PRESENT(cursor_right)) {\n\tlist[count++] = cursor_right;\n    }\n    if (count == 4) {\n\tcheck_ansi_cursor(list);\n    } else if (count != 0) {\n\tcount = 0;\n\tif (PRESENT(cursor_down) && strcmp(cursor_down, \"\\n\"))\n\t    ++count;\n\tif (PRESENT(cursor_left) && strcmp(cursor_left, \"\\b\"))\n\t    ++count;\n\tif (PRESENT(cursor_up) && strlen(cursor_up) > 1)\n\t    ++count;\n\tif (PRESENT(cursor_right) && strlen(cursor_right) > 1)\n\t    ++count;\n\tif (count) {\n\t    EXPECTED(cursor_down);\n\t    EXPECTED(cursor_up);\n\t    EXPECTED(cursor_left);\n\t    EXPECTED(cursor_right);\n\t}\n    }\n}\n\n#define MAX_KP 5\n \nstatic void\ncheck_keypad(TERMTYPE2 *tp)\n{\n    char show[80];\n\n    if (VALID_STRING(key_a1) &&\n\tVALID_STRING(key_a3) &&\n\tVALID_STRING(key_b2) &&\n\tVALID_STRING(key_c1) &&\n\tVALID_STRING(key_c3)) {\n\tchar final[MAX_KP + 1];\n\tlong list[MAX_KP];\n\tint increase = 0;\n\tint j;\n\n\tfinal[0] = keypad_final(key_a1);\n\tfinal[1] = keypad_final(key_a3);\n\tfinal[2] = keypad_final(key_b2);\n\tfinal[3] = keypad_final(key_c1);\n\tfinal[4] = keypad_final(key_c3);\n\tfinal[5] = '\\0';\n\n\t \n\tassert(strlen(final) <= MAX_KP);\n\tif (!strcmp(final, \"qsrpn\"))\n\t    return;\n\n\tlist[0] = keypad_index(key_a1);\n\tlist[1] = keypad_index(key_a3);\n\tlist[2] = keypad_index(key_b2);\n\tlist[3] = keypad_index(key_c1);\n\tlist[4] = keypad_index(key_c3);\n\n\t \n\tfor (j = 0; j < MAX_KP; ++j) {\n\t    if (list[j] < 0) {\n\t\treturn;\n\t    }\n\t}\n\n\t \n\tfor (j = 1; j < MAX_KP; ++j) {\n\t    if (list[j] > list[j - 1]) {\n\t\t++increase;\n\t    }\n\t}\n\n\tif (increase != (MAX_KP - 1)) {\n\t    long last;\n\n\t    show[0] = '\\0';\n\n\t    for (j = 0, last = -1; j < MAX_KP; ++j) {\n\t\tint k;\n\t\tint kk;\n\t\tlong test;\n\n\t\tfor (k = 0, kk = -1, test = 100; k < 5; ++k) {\n\t\t    if (list[k] > last &&\n\t\t\tlist[k] < test) {\n\t\t\ttest = list[k];\n\t\t\tkk = k;\n\t\t    }\n\t\t}\n\t\tlast = test;\n\t\tassert(strlen(show) < (MAX_KP * 4));\n\t\tswitch (kk) {\n\t\tcase 0:\n\t\t    _nc_STRCAT(show, \" ka1\", sizeof(show));\n\t\t    break;\n\t\tcase 1:\n\t\t    _nc_STRCAT(show, \" ka3\", sizeof(show));\n\t\t    break;\n\t\tcase 2:\n\t\t    _nc_STRCAT(show, \" kb2\", sizeof(show));\n\t\t    break;\n\t\tcase 3:\n\t\t    _nc_STRCAT(show, \" kc1\", sizeof(show));\n\t\t    break;\n\t\tcase 4:\n\t\t    _nc_STRCAT(show, \" kc3\", sizeof(show));\n\t\t    break;\n\t\t}\n\t    }\n\n\t    _nc_warning(\"vt100 keypad order inconsistent: %s\", show);\n\t}\n\n    } else if (VALID_STRING(key_a1) ||\n\t       VALID_STRING(key_a3) ||\n\t       VALID_STRING(key_b2) ||\n\t       VALID_STRING(key_c1) ||\n\t       VALID_STRING(key_c3)) {\n\tshow[0] = '\\0';\n\tif (keypad_index(key_a1) >= 0)\n\t    _nc_STRCAT(show, \" ka1\", sizeof(show));\n\tif (keypad_index(key_a3) >= 0)\n\t    _nc_STRCAT(show, \" ka3\", sizeof(show));\n\tif (keypad_index(key_b2) >= 0)\n\t    _nc_STRCAT(show, \" kb2\", sizeof(show));\n\tif (keypad_index(key_c1) >= 0)\n\t    _nc_STRCAT(show, \" kc1\", sizeof(show));\n\tif (keypad_index(key_c3) >= 0)\n\t    _nc_STRCAT(show, \" kc3\", sizeof(show));\n\tif (*show != '\\0')\n\t    _nc_warning(\"vt100 keypad map incomplete:%s\", show);\n    }\n\n     \n    ANDMISSING(key_ic, key_dc);\n}\n\nstatic void\ncheck_printer(TERMTYPE2 *tp)\n{\n    (void) tp;\n#if defined(enter_doublewide_mode) && defined(exit_doublewide_mode)\n    PAIRED(enter_doublewide_mode, exit_doublewide_mode);\n#endif\n#if defined(enter_italics_mode) && defined(exit_italics_mode)\n    PAIRED(enter_italics_mode, exit_italics_mode);\n#endif\n#if defined(enter_leftward_mode) && defined(exit_leftward_mode)\n    PAIRED(enter_leftward_mode, exit_leftward_mode);\n#endif\n#if defined(enter_micro_mode) && defined(exit_micro_mode)\n    PAIRED(enter_micro_mode, exit_micro_mode);\n#endif\n#if defined(enter_shadow_mode) && defined(exit_shadow_mode)\n    PAIRED(enter_shadow_mode, exit_shadow_mode);\n#endif\n#if defined(enter_subscript_mode) && defined(exit_subscript_mode)\n    PAIRED(enter_subscript_mode, exit_subscript_mode);\n#endif\n#if defined(enter_superscript_mode) && defined(exit_superscript_mode)\n    PAIRED(enter_superscript_mode, exit_superscript_mode);\n#endif\n#if defined(enter_upward_mode) && defined(exit_upward_mode)\n    PAIRED(enter_upward_mode, exit_upward_mode);\n#endif\n\n#if defined(start_char_set_def) && defined(stop_char_set_def)\n    ANDMISSING(start_char_set_def, stop_char_set_def);\n#endif\n\n     \n#if defined(parm_down_micro) && defined(micro_down)\n    ANDMISSING(parm_down_micro, micro_down);\n#endif\n#if defined(parm_left_micro) && defined(micro_left)\n    ANDMISSING(parm_left_micro, micro_left);\n#endif\n#if defined(parm_right_micro) && defined(micro_right)\n    ANDMISSING(parm_right_micro, micro_right);\n#endif\n#if defined(parm_up_micro) && defined(micro_up)\n    ANDMISSING(parm_up_micro, micro_up);\n#endif\n}\n\n#if NCURSES_XNAMES\nstatic bool\nuses_SGR_39_49(const char *value)\n{\n    return (strstr(value, \"39;49\") != 0\n\t    || strstr(value, \"49;39\") != 0);\n}\n\n \nstatic void\ncheck_screen(TERMTYPE2 *tp)\n{\n    if (_nc_user_definable) {\n\tint have_XT = tigetflag(\"XT\");\n\tint have_XM = tigetflag(\"XM\");\n\tint have_bce = back_color_erase;\n\tbool have_kmouse = FALSE;\n\tbool use_sgr_39_49 = FALSE;\n\tconst char *name_39_49 = \"orig_pair or orig_colors\";\n\tchar *name = _nc_first_name(tp->term_names);\n\tbool is_screen = !strncmp(name, \"screen\", 6);\n\tbool screen_base = (is_screen\n\t\t\t    && strchr(name, '.') == NULL);\n\n\tif (!VALID_BOOLEAN(have_bce)) {\n\t    have_bce = FALSE;\n\t}\n\tif (!VALID_BOOLEAN(have_XM)) {\n\t    have_XM = FALSE;\n\t}\n\tif (!VALID_BOOLEAN(have_XT)) {\n\t    have_XT = FALSE;\n\t}\n\tif (VALID_STRING(key_mouse)) {\n\t    have_kmouse = !strcmp(\"\\033[M\", key_mouse);\n\t}\n\tif (have_bce) {\n\t    if (VALID_STRING(orig_pair)) {\n\t\tname_39_49 = \"orig_pair\";\n\t\tuse_sgr_39_49 = uses_SGR_39_49(orig_pair);\n\t    }\n\t    if (!use_sgr_39_49 && VALID_STRING(orig_colors)) {\n\t\tname_39_49 = \"orig_colors\";\n\t\tuse_sgr_39_49 = uses_SGR_39_49(orig_colors);\n\t    }\n\t}\n\n\tif (have_XM && have_XT) {\n\t    _nc_warning(\"screen's XT capability conflicts with XM\");\n\t} else if (have_XT && screen_base) {\n\t    _nc_warning(\"screen's \\\"screen\\\" entries should not have XT set\");\n\t} else if (have_XT) {\n\t    char *s;\n\n\t    if (!have_kmouse && is_screen) {\n\t\tif (VALID_STRING(key_mouse)) {\n\t\t    _nc_warning(\"value of kmous inconsistent with screen's usage\");\n\t\t} else {\n\t\t    _nc_warning(\"expected kmous capability with XT\");\n\t\t}\n\t    }\n\t    if (max_colors > 0) {\n\t\tif (!have_bce) {\n\t\t    _nc_warning(\"expected bce capability with XT\");\n\t\t} else if (!use_sgr_39_49) {\n\t\t    _nc_warning(\"expected %s capability with XT \"\n\t\t\t\t\"to have 39/49 parameters\", name_39_49);\n\t\t}\n\t    }\n\t    if (VALID_STRING(to_status_line)\n\t\t&& (s = strchr(to_status_line, ';')) != NULL\n\t\t&& *++s == '\\0')\n\t\t_nc_warning(\"\\\"tsl\\\" capability is redundant, given XT\");\n\t} else {\n\t    if (have_kmouse\n\t\t&& !have_XM\n\t\t&& !screen_base && strchr(name, '+') == NULL) {\n\t\t_nc_warning(\"expected XT to be set, given kmous\");\n\t    }\n\t}\n    }\n}\n#else\n#define check_screen(tp)\t \n#endif\n\n \nstatic int\nexpected_params(const char *name)\n{\n#define DATA(name,count) { { name }, count }\n     \n    static const struct {\n\tconst char name[9];\n\tint count;\n    } table[] = {\n\tDATA( \"S0\",\t\t1 ),\t \n\tDATA( \"birep\",\t\t2 ),\n\tDATA( \"chr\",\t\t1 ),\n\tDATA( \"colornm\",\t1 ),\n\tDATA( \"cpi\",\t\t1 ),\n\tDATA( \"csnm\",\t\t1 ),\n\tDATA( \"csr\",\t\t2 ),\n\tDATA( \"cub\",\t\t1 ),\n\tDATA( \"cud\",\t\t1 ),\n\tDATA( \"cuf\",\t\t1 ),\n\tDATA( \"cup\",\t\t2 ),\n\tDATA( \"cuu\",\t\t1 ),\n\tDATA( \"cvr\",\t\t1 ),\n\tDATA( \"cwin\",\t\t5 ),\n\tDATA( \"dch\",\t\t1 ),\n\tDATA( \"defc\",\t\t3 ),\n\tDATA( \"dial\",\t\t1 ),\n\tDATA( \"dispc\",\t\t1 ),\n\tDATA( \"dl\",\t\t1 ),\n\tDATA( \"ech\",\t\t1 ),\n\tDATA( \"getm\",\t\t1 ),\n\tDATA( \"hpa\",\t\t1 ),\n\tDATA( \"ich\",\t\t1 ),\n\tDATA( \"il\",\t\t1 ),\n\tDATA( \"indn\",\t\t1 ),\n\tDATA( \"initc\",\t\t4 ),\n\tDATA( \"initp\",\t\t7 ),\n\tDATA( \"lpi\",\t\t1 ),\n\tDATA( \"mc5p\",\t\t1 ),\n\tDATA( \"mrcup\",\t\t2 ),\n\tDATA( \"mvpa\",\t\t1 ),\n\tDATA( \"pfkey\",\t\t2 ),\n\tDATA( \"pfloc\",\t\t2 ),\n\tDATA( \"pfx\",\t\t2 ),\n\tDATA( \"pfxl\",\t\t3 ),\n\tDATA( \"pln\",\t\t2 ),\n\tDATA( \"qdial\",\t\t1 ),\n\tDATA( \"rcsd\",\t\t1 ),\n\tDATA( \"rep\",\t\t2 ),\n\tDATA( \"rin\",\t\t1 ),\n\tDATA( \"sclk\",\t\t3 ),\n\tDATA( \"scp\",\t\t1 ),\n\tDATA( \"scs\",\t\t1 ),\n\tDATA( \"scsd\",\t\t2 ),\n\tDATA( \"setab\",\t\t1 ),\n\tDATA( \"setaf\",\t\t1 ),\n\tDATA( \"setb\",\t\t1 ),\n\tDATA( \"setcolor\",\t1 ),\n\tDATA( \"setf\",\t\t1 ),\n\tDATA( \"sgr\",\t\t9 ),\n\tDATA( \"sgr1\",\t\t6 ),\n\tDATA( \"slength\",\t1 ),\n\tDATA( \"slines\",\t\t1 ),\n\tDATA( \"smgbp\",\t\t1 ),\t \n\tDATA( \"smglp\",\t\t1 ),\n\tDATA( \"smglr\",\t\t2 ),\n\tDATA( \"smgrp\",\t\t1 ),\n\tDATA( \"smgtb\",\t\t2 ),\n\tDATA( \"smgtp\",\t\t1 ),\n\tDATA( \"tsl\",\t\t1 ),\n\tDATA( \"u6\",\t\t-1 ),\n\tDATA( \"vpa\",\t\t1 ),\n\tDATA( \"wind\",\t\t4 ),\n\tDATA( \"wingo\",\t\t1 ),\n    };\n     \n#undef DATA\n\n    unsigned n;\n    int result = 0;\t\t \n\n    for (n = 0; n < SIZEOF(table); n++) {\n\tif (!strcmp(name, table[n].name)) {\n\t    result = table[n].count;\n\t    break;\n\t}\n    }\n\n    return result;\n}\n\n \n#if NCURSES_XNAMES\nstatic struct user_table_entry const *\nlookup_user_capability(const char *name)\n{\n    struct user_table_entry const *result = 0;\n    if (*name != 'k') {\n\tresult = _nc_find_user_entry(name);\n    }\n    return result;\n}\n#endif\n\n \nstatic int\nis_user_capability(const char *name)\n{\n    int result = -1;\n    if (name[0] == 'u' &&\n\t(name[1] >= '0' && name[1] <= '9') &&\n\tname[2] == '\\0') {\n\tresult = (name[1] == '6') ? 2 : 0;\n    }\n#if NCURSES_XNAMES\n    else if (using_extensions) {\n\tstruct user_table_entry const *p = lookup_user_capability(name);\n\tif (p != 0) {\n\t    result = (int) p->ute_argc;\n\t}\n    }\n#endif\n    return result;\n}\n\nstatic bool\nline_capability(const char *name)\n{\n    bool result = FALSE;\n    static const char *table[] =\n    {\n\t\"csr\",\t\t\t \n\t\"clear\",\t\t \n\t\"ed\",\t\t\t \n\t\"cwin\",\t\t\t \n\t\"cup\",\t\t\t \n\t\"cud1\",\t\t\t \n\t\"home\",\t\t\t \n\t\"mrcup\",\t\t \n\t\"ll\",\t\t\t \n\t\"cuu1\",\t\t\t \n\t\"dl1\",\t\t\t \n\t\"hd\",\t\t\t \n\t\"flash\",\t\t \n\t\"ff\",\t\t\t \n\t\"il1\",\t\t\t \n\t\"nel\",\t\t\t \n\t\"dl\",\t\t\t \n\t\"cud\",\t\t\t \n\t\"indn\",\t\t\t \n\t\"il\",\t\t\t \n\t\"rin\",\t\t\t \n\t\"cuu\",\t\t\t \n\t\"mc0\",\t\t\t \n\t\"vpa\",\t\t\t \n\t\"ind\",\t\t\t \n\t\"ri\",\t\t\t \n\t\"hu\",\t\t\t \n    };\n    size_t n;\n    for (n = 0; n < SIZEOF(table); ++n) {\n\tif (!strcmp(name, table[n])) {\n\t    result = TRUE;\n\t    break;\n\t}\n    }\n    return result;\n}\n\n \nstatic void\ncheck_params(TERMTYPE2 *tp, const char *name, const char *value, int extended)\n{\n    int expected = expected_params(name);\n    int actual = 0;\n    int n;\n    bool params[1 + NUM_PARM];\n    const char *s = value;\n\n#ifdef set_left_margin_parm\n    if (!strcmp(name, \"smgrp\")\n\t&& !VALID_STRING(set_left_margin_parm))\n\texpected = 2;\n#endif\n#ifdef set_right_margin_parm\n    if (!strcmp(name, \"smglp\")\n\t&& !VALID_STRING(set_right_margin_parm))\n\texpected = 2;\n#endif\n#ifdef set_top_margin_parm\n    if (!strcmp(name, \"smgbp\")\n\t&& !VALID_STRING(set_top_margin_parm))\n\texpected = 2;\n#endif\n#ifdef set_bottom_margin_parm\n    if (!strcmp(name, \"smgtp\")\n\t&& !VALID_STRING(set_bottom_margin_parm))\n\texpected = 2;\n#endif\n\n    for (n = 0; n <= NUM_PARM; n++)\n\tparams[n] = FALSE;\n\n    while (*s != 0) {\n\tif (*s == '%') {\n\t    if (*++s == '\\0') {\n\t\t_nc_warning(\"expected character after %% in %s\", name);\n\t\tbreak;\n\t    } else if (*s == 'p') {\n\t\tif (*++s == '\\0' || !isdigit((int) *s)) {\n\t\t    _nc_warning(\"expected digit after %%p in %s\", name);\n\t\t    return;\n\t\t} else {\n\t\t    n = (*s - '0');\n\t\t    if (n > actual)\n\t\t\tactual = n;\n\t\t    params[n] = TRUE;\n\t\t}\n\t    }\n\t}\n\ts++;\n    }\n\n#if NCURSES_XNAMES\n    if (extended) {\n\tint check = is_user_capability(name);\n\tif (check != actual && (check >= 0 && actual >= 0)) {\n\t    _nc_warning(\"extended %s capability has %d parameters, expected %d\",\n\t\t\tname, actual, check);\n\t} else if (debug_level > 1) {\n\t    _nc_warning(\"extended %s capability has %d parameters, as expected\",\n\t\t\tname, actual);\n\t}\n\texpected = actual;\n    }\n#else\n    (void) extended;\n#endif\n\n    if (params[0]) {\n\t_nc_warning(\"%s refers to parameter 0 (%%p0), which is not allowed\", name);\n    }\n    if (value == set_attributes || expected < 0) {\n\t;\n    } else if (expected != actual) {\n\t_nc_warning(\"%s uses %d parameters, expected %d\", name,\n\t\t    actual, expected);\n\tfor (n = 1; n < actual; n++) {\n\t    if (!params[n])\n\t\t_nc_warning(\"%s omits parameter %d\", name, n);\n\t}\n    }\n\n     \n    _nc_reset_tparm(NULL);\n    if (actual >= 0) {\n\tchar *p_is_s[NUM_PARM];\n\tint popcount;\n\tint analyzed = _nc_tparm_analyze(NULL, value, p_is_s, &popcount);\n\tif (analyzed < popcount) {\n\t    analyzed = popcount;\n\t}\n\tif (actual != analyzed && expected != analyzed) {\n#if NCURSES_XNAMES\n\t    int user_cap = is_user_capability(name);\n\t    if ((user_cap == analyzed) && using_extensions) {\n\t\t;\t\t \n\t    } else if (user_cap >= 0) {\n\t\t_nc_warning(\"tparm will use %d parameters for %s, expected %d\",\n\t\t\t    analyzed, name, user_cap);\n\t    } else\n#endif\n\t    {\n\t\t_nc_warning(\"tparm analyzed %d parameters for %s, expected %d\",\n\t\t\t    analyzed, name, actual);\n\t    }\n\t} else if (expected > 0\n\t\t   && actual == expected\n\t\t   && guess_tparm_type(expected, p_is_s) == Numbers) {\n\t    int limit = 1;\n\n\t    if (!strcmp(name, \"setf\")\n\t\t|| !strcmp(name, \"setb\")\n\t\t|| !strcmp(name, \"setaf\")\n\t\t|| !strcmp(name, \"setab\")) {\n\t\tif ((limit = max_colors) > 256)\n\t\t    limit = 256;\n\t    } else if (line_capability(name)) {\n\t\tlimit = 24;\n\t    } else if (is_user_capability(name) < 0) {\n\t\tlimit = 80;\n\t    }\n\t    for (n = 0; n < limit; ++n) {\n\t\t_nc_reset_tparm(NULL);\n\t\t(void) TPARM_9(value, n, n, n, n, n, n, n, n, n);\n\t\tif (_nc_tparm_err) {\n\t\t    _nc_warning(\"problem%s in tparm(%s, %d, ...)\",\n\t\t\t\t(_nc_tparm_err == 1) ? \"\" : \"s\",\n\t\t\t\tname, n);\n\t\t    if (debug_level < 2)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n \nstatic const char *\nskip_DECSCNM(const char *value, int *flag)\n{\n    *flag = -1;\n    if (value != 0) {\n\tint skip = csi_length(value);\n\tif (skip > 0 &&\n\t    value[skip++] == '?' &&\n\t    value[skip++] == '5') {\n\t    if (value[skip] == 'h') {\n\t\t*flag = 1;\n\t    } else if (value[skip] == 'l') {\n\t\t*flag = 0;\n\t    }\n\t    value += skip + 1;\n\t}\n    }\n    return value;\n}\n\nstatic void\ncheck_delays(TERMTYPE2 *tp, const char *name, const char *value)\n{\n    const char *p, *q;\n    const char *first = 0;\n    const char *last = 0;\n\n    for (p = value; *p != '\\0'; ++p) {\n\tif (p[0] == '$' && p[1] == '<') {\n\t    const char *base = p + 2;\n\t    const char *mark = 0;\n\t    bool mixed = FALSE;\n\t    int proportional = 0;\n\t    int mandatory = 0;\n\n\t    first = p;\n\n\t    for (q = base; *q != '\\0'; ++q) {\n\t\tif (*q == '>') {\n\t\t    if (mark == NULL)\n\t\t\tmark = q;\n\t\t    break;\n\t\t} else if (*q == '*' || *q == '/') {\n\t\t    if (*q == '*')\n\t\t\t++proportional;\n\t\t    if (*q == '/')\n\t\t\t++mandatory;\n\t\t    if (mark == NULL)\n\t\t\tmark = q;\n\t\t} else if (!(isalnum(UChar(*q)) || strchr(\"+-.\", *q) != 0)) {\n\t\t    break;\n\t\t} else if (proportional || mandatory) {\n\t\t    mixed = TRUE;\n\t\t}\n\t    }\n\t    last = *q ? (q + 1) : q;\n\t    if (*q != '\\0') {\n\t\tfloat check_f;\n\t\tchar check_c;\n\t\tint rc = sscanf(base, \"%f%c\", &check_f, &check_c);\n\t\tif ((rc != 2) || (mark != NULL && (check_c != *mark)) || mixed) {\n\t\t    _nc_warning(\"syntax error in %s delay '%.*s'\", name,\n\t\t\t\t(int) (q - base), base);\n\t\t} else if (*name == 'k') {\n\t\t    _nc_warning(\"function-key %s has delay\", name);\n\t\t} else if (proportional && !line_capability(name)) {\n\t\t    _nc_warning(\"non-line capability using proportional delay: %s\", name);\n\t\t} else if (!xon_xoff &&\n\t\t\t   !mandatory &&\n\t\t\t   strchr(_nc_first_name(tp->term_names), '+') == NULL) {\n\t\t    _nc_warning(\"%s in %s is used since no xon/xoff\",\n\t\t\t\t(proportional\n\t\t\t\t ? \"proportional delay\"\n\t\t\t\t : \"delay\"),\n\t\t\t\tname);\n\t\t}\n\t    } else {\n\t\tp = q - 1;\t \n\t    }\n\t}\n    }\n\n    if (!strcmp(name, \"flash\") ||\n\t!strcmp(name, \"beep\")) {\n\n\tif (first != 0) {\n\t    if (first == value || *last == 0) {\n\t\t \n\t\t_nc_warning(\"expected delay embedded within %s\", name);\n\t    }\n\t} else {\n\t    int flag;\n\n\t     \n\t    if ((p = skip_DECSCNM(value, &flag)) != 0 &&\n\t\tflag > 0 &&\n\t\tskip_DECSCNM(p, &flag) != 0 &&\n\t\tflag == 0) {\n\t\t_nc_warning(\"expected a delay in %s\", name);\n\t    }\n\t}\n    }\n}\n\nstatic char *\ncheck_1_infotocap(const char *name, NCURSES_CONST char *value, int count)\n{\n    int k;\n    int ignored;\n    long numbers[1 + NUM_PARM];\n    char *strings[1 + NUM_PARM];\n    char *p_is_s[NUM_PARM];\n    char *result;\n    char blob[NUM_PARM * 10];\n    char *next = blob;\n    TParams expect;\n    TParams actual;\n    int nparam;\n\n    *next++ = '\\0';\n    for (k = 1; k <= NUM_PARM; k++) {\n\tnumbers[k] = count;\n\t_nc_SPRINTF(next,\n\t\t    _nc_SLIMIT(sizeof(blob) - (size_t) (next - blob))\n\t\t    \"XYZ%d\", count);\n\tstrings[k] = next;\n\tnext += strlen(next) + 1;\n    }\n\n    _nc_reset_tparm(NULL);\n    expect = tparm_type(name);\n    nparam = _nc_tparm_analyze(NULL, value, p_is_s, &ignored);\n    actual = guess_tparm_type(nparam, p_is_s);\n\n    if (expect != actual) {\n\t_nc_warning(\"%s has mismatched parameters\", name);\n\tactual = Other;\n    }\n\n    _nc_reset_tparm(NULL);\n    switch (actual) {\n    case Num_Str:\n\tresult = TPARM_2(value, numbers[1], strings[2]);\n\tbreak;\n    case Num_Str_Str:\n\tresult = TPARM_3(value, numbers[1], strings[2], strings[3]);\n\tbreak;\n    case Numbers:\n#define myParam(n) numbers[n]\n\tresult = TIPARM_9(value,\n\t\t\t  myParam(1),\n\t\t\t  myParam(2),\n\t\t\t  myParam(3),\n\t\t\t  myParam(4),\n\t\t\t  myParam(5),\n\t\t\t  myParam(6),\n\t\t\t  myParam(7),\n\t\t\t  myParam(8),\n\t\t\t  myParam(9));\n#undef myParam\n\tbreak;\n    case Other:\n    default:\n#define myParam(n) (p_is_s[n - 1] != 0 ? ((TPARM_ARG) strings[n]) : numbers[n])\n\tresult = TPARM_9(value,\n\t\t\t myParam(1),\n\t\t\t myParam(2),\n\t\t\t myParam(3),\n\t\t\t myParam(4),\n\t\t\t myParam(5),\n\t\t\t myParam(6),\n\t\t\t myParam(7),\n\t\t\t myParam(8),\n\t\t\t myParam(9));\n#undef myParam\n\tbreak;\n    }\n    return strdup(result);\n}\n\n#define IsDelay(ch) ((ch) == '.' || isdigit(UChar(ch)))\n\nstatic const char *\nparse_delay_value(const char *src, double *delays, int *always)\n{\n    int star = 0;\n\n    *delays = 0.0;\n    if (always)\n\t*always = 0;\n\n    while (isdigit(UChar(*src))) {\n\t(*delays) = (*delays) * 10 + (*src++ - '0');\n    }\n    if (*src == '.') {\n\tint gotdot = 1;\n\n\t++src;\n\twhile (isdigit(UChar(*src))) {\n\t    gotdot *= 10;\n\t    (*delays) += (*src++ - '0') / gotdot;\n\t}\n    }\n    while (*src == '*' || *src == '/') {\n\tif (always == NULL && *src == '/')\n\t    break;\n\tif (*src++ == '*') {\n\t    star = 1;\n\t} else {\n\t    *always = 1;\n\t}\n    }\n    if (star)\n\t*delays = -(*delays);\n    return src;\n}\n\nstatic const char *\nparse_ti_delay(const char *ti, double *delays)\n{\n    *delays = 0.0;\n    while (*ti != '\\0') {\n\tif (*ti == '\\\\') {\n\t    ++ti;\n\t}\n\tif (ti[0] == '$'\n\t    && ti[1] == '<'\n\t    && IsDelay(UChar(ti[2]))) {\n\t    int ignored;\n\t    const char *last = parse_delay_value(ti + 2, delays, &ignored);\n\t    if (*last == '>') {\n\t\tti = last;\n\t    }\n\t} else {\n\t    ++ti;\n\t}\n    }\n    return ti;\n}\n\nstatic const char *\nparse_tc_delay(const char *tc, double *delays)\n{\n    return parse_delay_value(tc, delays, (int *) 0);\n}\n\n \nstatic bool\nsame_ti_tc(const char *ti, const char *tc, bool * embedded)\n{\n    bool same = TRUE;\n    double ti_delay = 0.0;\n    double tc_delay = 0.0;\n    const char *ti_last;\n\n    *embedded = FALSE;\n    ti_last = parse_ti_delay(ti, &ti_delay);\n    tc = parse_tc_delay(tc, &tc_delay);\n\n    while ((ti < ti_last) && *tc) {\n\tif (*ti == '\\\\' && ispunct(UChar(ti[1]))) {\n\t    ++ti;\n\t    if ((*ti == '^') && !strncmp(tc, \"\\\\136\", 4)) {\n\t\tti += 1;\n\t\ttc += 4;\n\t\tcontinue;\n\t    }\n\t} else if (ti[0] == '$' && ti[1] == '<') {\n\t    double no_delay;\n\t    const char *ss = parse_ti_delay(ti, &no_delay);\n\t    if (ss != ti) {\n\t\t*embedded = TRUE;\n\t\tti = ss;\n\t\tcontinue;\n\t    }\n\t}\n\tif (*tc == '\\\\' && ispunct(UChar(tc[1]))) {\n\t    ++tc;\n\t}\n\tif (*ti++ != *tc++) {\n\t    same = FALSE;\n\t    break;\n\t}\n    }\n\n    if (*embedded) {\n\tif (same) {\n\t    same = FALSE;\n\t} else {\n\t    *embedded = FALSE;\t \n\t}\n    }\n\n    return same;\n}\n\n \nstatic void\ncheck_infotocap(TERMTYPE2 *tp, int i, const char *value)\n{\n    const char *name = ExtStrname(tp, i, strnames);\n    int params = ((i < (int) SIZEOF(parametrized))\n\t\t  ? parametrized[i]\n\t\t  : ((*value == 'k')\n\t\t     ? 0\n\t\t     : has_params(value, FALSE)));\n    char *ti_value = NULL;\n    char *tc_value;\n    bool embedded;\n\n    assert(SIZEOF(parametrized) == STRCOUNT);\n    if (!VALID_STRING(value) || (ti_value = strdup(value)) == NULL) {\n\t_nc_warning(\"tic-expansion of %s failed\", name);\n    } else if ((tc_value = _nc_infotocap(name, ti_value, params)) == ABSENT_STRING) {\n\t_nc_warning(\"tic-conversion of %s failed\", name);\n    } else if (params > 0) {\n\tint limit = 5;\n\tint count;\n\tbool first = TRUE;\n\n\tif (!strcmp(name, \"setf\")\n\t    || !strcmp(name, \"setb\")\n\t    || !strcmp(name, \"setaf\")\n\t    || !strcmp(name, \"setab\")) {\n\t    if ((limit = max_colors) > 256)\n\t\tlimit = 256;\n\t}\n\tfor (count = 0; count < limit; ++count) {\n\t    char *ti_check = check_1_infotocap(name, ti_value, count);\n\t    char *tc_check = check_1_infotocap(name, tc_value, count);\n\n\t    if (strcmp(ti_check, tc_check)) {\n\t\tif (first) {\n\t\t    fprintf(stderr, \"check_infotocap(%s)\\n\", name);\n\t\t    fprintf(stderr, \"...ti '%s'\\n\", _nc_visbuf2(0, ti_value));\n\t\t    fprintf(stderr, \"...tc '%s'\\n\", _nc_visbuf2(0, tc_value));\n\t\t    first = FALSE;\n\t\t}\n\t\t_nc_warning(\"tparm-conversion of %s(%d) differs between\\n\\tterminfo %s\\n\\ttermcap  %s\",\n\t\t\t    name, count,\n\t\t\t    _nc_visbuf2(0, ti_check),\n\t\t\t    _nc_visbuf2(1, tc_check));\n\t    }\n\t    free(ti_check);\n\t    free(tc_check);\n\t}\n    } else if (params == 0 && !same_ti_tc(ti_value, tc_value, &embedded)) {\n\tif (embedded) {\n\t    _nc_warning(\"termcap equivalent of %s cannot use embedded delay\", name);\n\t} else {\n\t    _nc_warning(\"tic-conversion of %s changed value\\n\\tfrom %s\\n\\tto   %s\",\n\t\t\tname, ti_value, tc_value);\n\t}\n    }\n    free(ti_value);\n}\n\nstatic char *\nskip_delay(char *s)\n{\n    while (*s == '/' || isdigit(UChar(*s)))\n\t++s;\n    return s;\n}\n\n \nstatic char *\nignore_delays(char *s)\n{\n    int delaying = 0;\n\n    do {\n\tswitch (*s) {\n\tcase '$':\n\t    if (delaying == 0)\n\t\tdelaying = 1;\n\t    break;\n\tcase '<':\n\t    if (delaying == 1)\n\t\tdelaying = 2;\n\t    break;\n\tcase '\\0':\n\t    delaying = 0;\n\t    break;\n\tdefault:\n\t    if (delaying) {\n\t\ts = skip_delay(s);\n\t\tif (*s == '>')\n\t\t    ++s;\n\t\tdelaying = 0;\n\t    }\n\t    break;\n\t}\n\tif (delaying)\n\t    ++s;\n    } while (delaying);\n    return s;\n}\n\n#define DATA(name) { #name }\nstatic const char sgr_names[][11] =\n{\n    DATA(none),\n    DATA(standout),\n    DATA(underline),\n    DATA(reverse),\n    DATA(blink),\n    DATA(dim),\n    DATA(bold),\n    DATA(invis),\n    DATA(protect),\n    DATA(altcharset),\n    \"\"\n};\n#undef DATA\n\n \nstatic bool\nsimilar_sgr(int num, char *a, char *b)\n{\n    char *base_a = a;\n    char *base_b = b;\n    int delaying = 0;\n\n    while (*b != 0) {\n\twhile (*a != *b) {\n\t    if (*a == 0) {\n\t\tif (num < 0) {\n\t\t    ;\n\t\t} else if (b[0] == '$'\n\t\t\t   && b[1] == '<') {\n\t\t    _nc_warning(\"did not find delay %s\", _nc_visbuf(b));\n\t\t} else {\n\t\t    _nc_warning(\"checking sgr(%s) %s\\n\\tcompare to %s\\n\\tunmatched %s\",\n\t\t\t\tsgr_names[num], _nc_visbuf2(1, base_a),\n\t\t\t\t_nc_visbuf2(2, base_b),\n\t\t\t\t_nc_visbuf2(3, b));\n\t\t}\n\t\treturn FALSE;\n\t    } else if (delaying) {\n\t\ta = skip_delay(a);\n\t\tb = skip_delay(b);\n\t    } else if ((*b == '0' || (*b == ';')) && *a == 'm') {\n\t\tb++;\n\t    } else {\n\t\ta++;\n\t    }\n\t}\n\tswitch (*a) {\n\tcase '$':\n\t    if (delaying == 0)\n\t\tdelaying = 1;\n\t    break;\n\tcase '<':\n\t    if (delaying == 1)\n\t\tdelaying = 2;\n\t    break;\n\tdefault:\n\t    delaying = 0;\n\t    break;\n\t}\n\ta++;\n\tb++;\n    }\n     \n    a = ignore_delays(a);\n    return ((num != 0) || (*a == 0));\n}\n\nstatic void\ncheck_tparm_err(int num)\n{\n    if (_nc_tparm_err)\n\t_nc_warning(\"tparam error in sgr(%d): %s\", num, sgr_names[num]);\n}\n\nstatic char *\ncheck_sgr(TERMTYPE2 *tp, char *zero, int num, char *cap, const char *name)\n{\n    char *test;\n\n    _nc_tparm_err = 0;\n    test = TIPARM_9(set_attributes,\n\t\t    num == 1,\n\t\t    num == 2,\n\t\t    num == 3,\n\t\t    num == 4,\n\t\t    num == 5,\n\t\t    num == 6,\n\t\t    num == 7,\n\t\t    num == 8,\n\t\t    num == 9);\n    if (test != 0) {\n\tif (PRESENT(cap)) {\n\t    if (!similar_sgr(num, test, cap)) {\n\t\t_nc_warning(\"%s differs from sgr(%d)\\n\\t%s=%s\\n\\tsgr(%d)=%s\",\n\t\t\t    name, num,\n\t\t\t    name, _nc_visbuf2(1, cap),\n\t\t\t    num, _nc_visbuf2(2, test));\n\t    }\n\t} else if (_nc_capcmp(test, zero)) {\n\t    _nc_warning(\"sgr(%d) present, but not %s\", num, name);\n\t}\n    } else if (PRESENT(cap)) {\n\t_nc_warning(\"sgr(%d) missing, but %s present\", num, name);\n    }\n    check_tparm_err(num);\n    return test;\n}\n\n#define CHECK_SGR(num,name) check_sgr(tp, zero, num, name, #name)\n\n#ifdef TRACE\n \nstatic void\nshow_where(unsigned level)\n{\n    if (_nc_tracing >= DEBUG_LEVEL(level)) {\n\tchar my_name[MAX_NAME_SIZE];\n\t_nc_get_type(my_name);\n\t_tracef(\"\\\"%s\\\", line %d, '%s'\",\n\t\t_nc_get_source(),\n\t\t_nc_curr_line, my_name);\n    }\n}\n\n#else\n#define show_where(level)\t \n#endif\n\ntypedef struct {\n    int keycode;\n    const char *name;\n    const char *value;\n} NAME_VALUE;\n\nstatic NAME_VALUE *\nget_fkey_list(TERMTYPE2 *tp)\n{\n    NAME_VALUE *result = typeMalloc(NAME_VALUE, NUM_STRINGS(tp) + 1);\n    const struct tinfo_fkeys *all_fkeys = _nc_tinfo_fkeys;\n    int used = 0;\n    unsigned j;\n\n    if (result == NULL)\n\tfailed(\"get_fkey_list\");\n\n    for (j = 0; all_fkeys[j].code; j++) {\n\tchar *a = tp->Strings[all_fkeys[j].offset];\n\tif (VALID_STRING(a)) {\n\t    result[used].keycode = (int) all_fkeys[j].code;\n\t    result[used].name = strnames[all_fkeys[j].offset];\n\t    result[used].value = a;\n\t    ++used;\n\t}\n    }\n#if NCURSES_XNAMES\n    for (j = STRCOUNT; j < NUM_STRINGS(tp); ++j) {\n\tconst char *name = ExtStrname(tp, (int) j, strnames);\n\tif (*name == 'k') {\n\t    result[used].keycode = -1;\n\t    result[used].name = name;\n\t    result[used].value = tp->Strings[j];\n\t    ++used;\n\t}\n    }\n#endif\n    result[used].keycode = 0;\n    return result;\n}\n\nstatic void\nshow_fkey_name(NAME_VALUE * data)\n{\n    if (data->keycode > 0) {\n\tfprintf(stderr, \" %s\", keyname(data->keycode));\n\tfprintf(stderr, \" (capability \\\"%s\\\")\", data->name);\n    } else {\n\tfprintf(stderr, \" capability \\\"%s\\\"\", data->name);\n    }\n}\n\n \nstatic void\ncheck_conflict(TERMTYPE2 *tp)\n{\n    if (!(_nc_syntax == SYN_TERMCAP && capdump)) {\n\tchar *check = calloc((size_t) (NUM_STRINGS(tp) + 1), sizeof(char));\n\tNAME_VALUE *given = get_fkey_list(tp);\n\tunsigned j, k;\n\tbool conflict = FALSE;\n\n\tif (check == NULL)\n\t    failed(\"check_conflict\");\n\n\tfor (j = 0; given[j].keycode; ++j) {\n\t    const char *a = given[j].value;\n\t    bool first = TRUE;\n\n\t    if (!VALID_STRING(a))\n\t\tcontinue;\n\n\t    for (k = j + 1; given[k].keycode; k++) {\n\t\tconst char *b = given[k].value;\n\n\t\tif (!VALID_STRING(b))\n\t\t    continue;\n\t\tif (check[k])\n\t\t    continue;\n\n\t\tif (!_nc_capcmp(a, b)) {\n\t\t    check[j] = 1;\n\t\t    check[k] = 1;\n\t\t    if (first) {\n\t\t\tif (!conflict) {\n\t\t\t    _nc_warning(\"conflicting key definitions (using the last)\");\n\t\t\t    conflict = TRUE;\n\t\t\t}\n\t\t\tfprintf(stderr, \"...\");\n\t\t\tshow_fkey_name(given + j);\n\t\t\tfprintf(stderr, \" is the same as\");\n\t\t\tshow_fkey_name(given + k);\n\t\t\tfirst = FALSE;\n\t\t    } else {\n\t\t\tfprintf(stderr, \", \");\n\t\t\tshow_fkey_name(given + k);\n\t\t    }\n\t\t}\n\t    }\n\t    if (!first)\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#if NCURSES_XNAMES\n\tif (using_extensions) {\n\t     \n\t    static struct {\n\t\tconst char *xcurses;\n\t\tconst char *shifted;\n\t    } table[] = {\n\t\t{ \"kDC\",  NULL },\n\t\t{ \"kDN\",  \"kind\" },\n\t\t{ \"kEND\", NULL },\n\t\t{ \"kHOM\", NULL },\n\t\t{ \"kLFT\", NULL },\n\t\t{ \"kNXT\", NULL },\n\t\t{ \"kPRV\", NULL },\n\t\t{ \"kRIT\", NULL },\n\t\t{ \"kUP\",  \"kri\" },\n\t\t{ NULL,   NULL },\n\t    };\n\t     \n\t     \n\t    for (j = 0; given[j].keycode; ++j) {\n\t\tconst char *find = given[j].name;\n\t\tint value;\n\t\tchar ch;\n\n\t\tif (!VALID_STRING(given[j].value))\n\t\t    continue;\n\n\t\tfor (k = 0; table[k].xcurses; ++k) {\n\t\t    const char *test = table[k].xcurses;\n\t\t    size_t size = strlen(test);\n\n\t\t    if (!strncmp(find, test, size) && strcmp(find, test)) {\n\t\t\tswitch (sscanf(find + size, \"%d%c\", &value, &ch)) {\n\t\t\tcase 1:\n\t\t\t    if (value == 2) {\n\t\t\t\t_nc_warning(\"expected '%s' rather than '%s'\",\n\t\t\t\t\t    (table[k].shifted\n\t\t\t\t\t     ? table[k].shifted\n\t\t\t\t\t     : test), find);\n\t\t\t    } else if (value < 2 || value > 15) {\n\t\t\t\t_nc_warning(\"expected numeric 2..15 '%s'\", find);\n\t\t\t    }\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    _nc_warning(\"expected numeric suffix for '%s'\", find);\n\t\t\t    break;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif\n\tfree(given);\n\tfree(check);\n    }\n}\n\n \nstatic void\ncheck_exit_attribute(const char *name, char *test, char *trimmed, char *untrimmed)\n{\n    if (VALID_STRING(test) && (trimmed != 0)) {\n\tif (similar_sgr(-1, trimmed, test) ||\n\t    similar_sgr(-1, untrimmed, test)) {\n\t    _nc_warning(\"%s matches exit_attribute_mode\", name);\n\t}\n    }\n}\n\n \nstatic bool\nis_sgr_string(char *value)\n{\n    bool result = FALSE;\n\n    if (VALID_STRING(value)) {\n\tint skip = csi_length(value);\n\n\tif (skip) {\n\t    int ch;\n\n\t    result = TRUE;\n\t    value += skip;\n\t    while ((ch = UChar(*value++)) != '\\0') {\n\t\tif (isdigit(ch) || ch == ';') {\n\t\t    ;\n\t\t} else if (ch == 'm' && *value == '\\0') {\n\t\t    ;\n\t\t} else {\n\t\t    result = FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\n \nstatic void\ncheck_sgr_param(TERMTYPE2 *tp, int code, const char *name, char *value)\n{\n    if (VALID_STRING(value)) {\n\tint ncv = ((code != 0) ? (1 << (code - 1)) : 0);\n\tchar *test = tgoto(value, 0, 0);\n\tif (is_sgr_string(test)) {\n\t    int param = 0;\n\t    int count = 0;\n\t    int skips = 0;\n\t    int color = (value == set_a_foreground ||\n\t\t\t value == set_a_background ||\n\t\t\t value == set_foreground ||\n\t\t\t value == set_background);\n\t    while (*test != 0) {\n\t\tif (isdigit(UChar(*test))) {\n\t\t    param = 10 * param + (*test - '0');\n\t\t    ++count;\n\t\t} else {\n\t\t    if (count) {\n\t\t\t \n\t\t\tif (color && (param == 38 || param == 48))\n\t\t\t    skips = 3;\n\t\t\tif ((skips-- <= 0) && (param == code))\n\t\t\t    break;\n\t\t    }\n\t\t    count = 0;\n\t\t    param = 0;\n\t\t}\n\t\t++test;\n\t    }\n\t    if (count != 0 && param == code) {\n\t\tif (code == 0 ||\n\t\t    no_color_video < 0 ||\n\t\t    !(no_color_video & ncv)) {\n\t\t    _nc_warning(\"\\\"%s\\\" SGR-attribute used in %s\",\n\t\t\t\tsgr_names[code],\n\t\t\t\tname);\n\t\t}\n\t    }\n\t}\n    }\n}\n\n#if NCURSES_XNAMES\nstatic int\nstandard_type(const char *name)\n{\n    int result = -1;\n    const struct name_table_entry *np;\n\n    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != 0) {\n\tresult = np->nte_type;\n    }\n    return result;\n}\n\nstatic const char *\nname_of_type(int type)\n{\n    const char *result = \"unknown\";\n    switch (type) {\n    case BOOLEAN:\n\tresult = \"boolean\";\n\tbreak;\n    case NUMBER:\n\tresult = \"number\";\n\tbreak;\n    case STRING:\n\tresult = \"string\";\n\tbreak;\n    }\n    return result;\n}\n\nstatic void\ncheck_user_capability_type(const char *name, int actual)\n{\n    if (lookup_user_capability(name) == 0) {\n\tint expected = standard_type(name);\n\tif (expected >= 0) {\n\t    _nc_warning(\"expected %s to be %s, but actually %s\",\n\t\t\tname,\n\t\t\tname_of_type(actual),\n\t\t\tname_of_type(expected)\n\t\t);\n\t} else if (*name != 'k') {\n\t    _nc_warning(\"undocumented %s capability %s\",\n\t\t\tname_of_type(actual),\n\t\t\tname);\n\t}\n    }\n}\n#endif\n\n#define IN_DELAY \"0123456789*/.\"\n\nstatic bool\ncheck_ANSI_cap(const char *value, int nparams, char final)\n{\n    bool result = FALSE;\n    if (VALID_STRING(value) && csi_length(value) > 0) {\n\tchar *p_is_s[NUM_PARM];\n\tint popcount;\n\tint analyzed = _nc_tparm_analyze(NULL, value, p_is_s, &popcount);\n\tif (analyzed < popcount) {\n\t    analyzed = popcount;\n\t}\n\tif (analyzed == nparams) {\n\t    bool numbers = TRUE;\n\t    int p;\n\t    for (p = 0; p < nparams; ++p) {\n\t\tif (p_is_s[p]) {\n\t\t    numbers = FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (numbers) {\n\t\tint in_delay = 0;\n\t\tp = (int) strlen(value);\n\t\twhile (p-- > 0) {\n\t\t    char ch = value[p];\n\t\t    if (ch == final) {\n\t\t\tresult = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    switch (in_delay) {\n\t\t    case 0:\n\t\t\tif (ch == '>')\n\t\t\t    in_delay = 1;\n\t\t\tbreak;\n\t\t    case 1:\n\t\t\tif (strchr(IN_DELAY, value[p]) != NULL)\n\t\t\t    break;\n\t\t\tif (ch != '<')\n\t\t\t    p = 0;\n\t\t\tin_delay = 2;\n\t\t\tbreak;\n\t\t    case 2:\n\t\t\tif (ch != '$')\n\t\t\t    p = 0;\n\t\t\tin_delay = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\nstatic const char *\nskip_Delay(const char *value)\n{\n    const char *result = value;\n\n    if (*value == '$') {\n\t++result;\n\tif (*result++ == '<') {\n\t    while (strchr(IN_DELAY, *result) != NULL)\n\t\t++result;\n\t    if (*result++ != '>') {\n\t\tresult = value;\n\t    }\n\t} else {\n\t    result = value;\n\t}\n    }\n    return result;\n}\n\nstatic bool\nisValidString(const char *value, const char *expect)\n{\n    bool result = FALSE;\n    if (VALID_STRING(value)) {\n\tif (!strcmp(value, expect))\n\t    result = TRUE;\n    }\n    return result;\n}\n\nstatic bool\nisValidEscape(const char *value, const char *expect)\n{\n    bool result = FALSE;\n    if (VALID_STRING(value)) {\n\tif (*value == '\\033') {\n\t    size_t need = strlen(expect);\n\t    size_t have = strlen(value) - 1;\n\t    if (have >= need && !strncmp(value + 1, expect, need)) {\n\t\tif (*skip_Delay(value + need + 1) == '\\0') {\n\t\t    result = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\nstatic int\nguess_ANSI_VTxx(TERMTYPE2 *tp)\n{\n    int result = -1;\n    int checks = 0;\n\n     \n    if (check_ANSI_cap(change_scroll_region, 2, 'r') &&\n\t(isValidEscape(scroll_forward, \"D\") ||\n\t isValidString(scroll_forward, \"\\n\") ||\n\t isValidEscape(scroll_forward, \"6\")) &&\n\t(isValidEscape(scroll_reverse, \"M\") ||\n\t isValidEscape(scroll_reverse, \"9\"))) {\n\tchecks |= 2;\n    }\n    if (check_ANSI_cap(cursor_address, 2, 'H') &&\n\tcheck_ANSI_cap(cursor_up, 0, 'A') &&\n\t(check_ANSI_cap(cursor_down, 0, 'B') ||\n\t isValidString(cursor_down, \"\\n\")) &&\n\tcheck_ANSI_cap(cursor_right, 0, 'C') &&\n\t(check_ANSI_cap(cursor_left, 0, 'D') ||\n\t isValidString(cursor_left, \"\\b\")) &&\n\tcheck_ANSI_cap(clr_eos, 0, 'J') &&\n\tcheck_ANSI_cap(clr_bol, 0, 'K') &&\n\tcheck_ANSI_cap(clr_eol, 0, 'K')) {\n\tchecks |= 1;\n    }\n    if (checks == 3)\n\tresult = 1;\n    if (checks == 1)\n\tresult = 0;\n    return result;\n}\n\n \nstatic void\ncheck_user_6789(TERMTYPE2 *tp)\n{\n     \n#define NO_QUERY(longname,shortname) \\\n\tif (PRESENT(longname)) _nc_warning(#shortname \" is not supported\")\n    if (tigetflag(\"NQ\") > 0) {\n\tNO_QUERY(user6, u6);\n\tNO_QUERY(user7, u7);\n\tNO_QUERY(user8, u8);\n\tNO_QUERY(user9, u9);\n\treturn;\n    }\n\n    PAIRED(user6, user7);\n    PAIRED(user8, user9);\n\n    if (strchr(tp->term_names, '+') != NULL)\n\treturn;\n\n    switch (guess_ANSI_VTxx(tp)) {\n    case 1:\n\tif (!PRESENT(user8)) {\n\t    _nc_warning(\"expected u8/u9 for device-attributes\");\n\t}\n\t \n    case 0:\n\tif (!PRESENT(user6)) {\n\t    _nc_warning(\"expected u6/u7 for cursor-position\");\n\t}\n\tbreak;\n    }\n}\n\n \nstatic void\ncheck_termtype(TERMTYPE2 *tp, bool literal)\n{\n    unsigned j;\n\n    check_conflict(tp);\n\n    for_each_string(j, tp) {\n\tchar *a = tp->Strings[j];\n\tif (VALID_STRING(a)) {\n\t    const char *name = ExtStrname(tp, (int) j, strnames);\n\t     \n\t    if (j >= SIZEOF(parametrized) ||\n\t\tis_user_capability(name) >= 0 ||\n\t\tparametrized[j] > 0) {\n\t\tcheck_params(tp, name, a, (j >= STRCOUNT));\n\t    }\n\t    check_delays(tp, ExtStrname(tp, (int) j, strnames), a);\n\t    if (capdump) {\n\t\tcheck_infotocap(tp, (int) j, a);\n\t    }\n\t}\n    }\n#if NCURSES_XNAMES\n     \n    for_each_ext_boolean(j, tp) {\n\tcheck_user_capability_type(ExtBoolname(tp, (int) j, strnames), BOOLEAN);\n    }\n    for_each_ext_number(j, tp) {\n\tcheck_user_capability_type(ExtNumname(tp, (int) j, strnames), NUMBER);\n    }\n    for_each_ext_string(j, tp) {\n\tcheck_user_capability_type(ExtStrname(tp, (int) j, strnames), STRING);\n    }\n#endif  \n\n    check_acs(tp);\n    check_colors(tp);\n    check_cursor(tp);\n    check_keypad(tp);\n    check_printer(tp);\n    check_screen(tp);\n    check_user_6789(tp);\n\n     \n    PAIRED(parm_index, parm_rindex);\n    PAIRED(parm_ich, parm_dch);\n\n     \n    ANDMISSING(cursor_invisible, cursor_normal);\n    ANDMISSING(cursor_visible, cursor_normal);\n\n    if (PRESENT(cursor_visible) && PRESENT(cursor_normal)\n\t&& !_nc_capcmp(cursor_visible, cursor_normal))\n\t_nc_warning(\"cursor_visible is same as cursor_normal\");\n\n     \n    ANDMISSING(change_scroll_region, save_cursor);\n    ANDMISSING(change_scroll_region, restore_cursor);\n\n     \n    ANDMISSING(clear_all_tabs, set_tab);\n\n    if (PRESENT(set_attributes)) {\n\tchar *zero = 0;\n\n\t_nc_tparm_err = 0;\n\tif (PRESENT(exit_attribute_mode)) {\n\t    zero = strdup(CHECK_SGR(0, exit_attribute_mode));\n\t} else {\n\t    zero = strdup(TIPARM_9(set_attributes, 0, 0, 0, 0, 0, 0, 0, 0, 0));\n\t}\n\tcheck_tparm_err(0);\n\n\tif (zero != 0) {\n\t    CHECK_SGR(1, enter_standout_mode);\n\t    CHECK_SGR(2, enter_underline_mode);\n\t    CHECK_SGR(3, enter_reverse_mode);\n\t    CHECK_SGR(4, enter_blink_mode);\n\t    CHECK_SGR(5, enter_dim_mode);\n\t    CHECK_SGR(6, enter_bold_mode);\n\t    CHECK_SGR(7, enter_secure_mode);\n\t    CHECK_SGR(8, enter_protected_mode);\n\t    CHECK_SGR(9, enter_alt_charset_mode);\n\t    free(zero);\n\t} else {\n\t    _nc_warning(\"sgr(0) did not return a value\");\n\t}\n    } else if (PRESENT(exit_attribute_mode) &&\n\t       set_attributes != CANCELLED_STRING) {\n\tif (_nc_syntax == SYN_TERMINFO)\n\t    _nc_warning(\"missing sgr string\");\n    }\n#define CHECK_SGR0(name) check_exit_attribute(#name, name, check_sgr0, exit_attribute_mode)\n    if (PRESENT(exit_attribute_mode)) {\n\tchar *check_sgr0 = _nc_trim_sgr0(tp);\n\n\tif (check_sgr0 == NULL || *check_sgr0 == '\\0') {\n\t    _nc_warning(\"trimmed sgr0 is empty\");\n\t} else {\n\t    show_where(2);\n\t    if (check_sgr0 != exit_attribute_mode) {\n\t\tDEBUG(2,\n\t\t      (\"will trim sgr0\\n\\toriginal sgr0=%s\\n\\ttrimmed  sgr0=%s\",\n\t\t       _nc_visbuf2(1, exit_attribute_mode),\n\t\t       _nc_visbuf2(2, check_sgr0)));\n\t    } else {\n\t\tDEBUG(2,\n\t\t      (\"will not trim sgr0\\n\\toriginal sgr0=%s\",\n\t\t       _nc_visbuf(exit_attribute_mode)));\n\t    }\n\t}\n#if defined(exit_italics_mode)\n\tCHECK_SGR0(exit_italics_mode);\n#endif\n\tCHECK_SGR0(exit_standout_mode);\n\tCHECK_SGR0(exit_underline_mode);\n\tif (check_sgr0 != exit_attribute_mode) {\n\t    free(check_sgr0);\n\t}\n    }\n#define CHECK_SGR_PARAM(code, name) check_sgr_param(tp, (int)code, #name, name)\n    for (j = 0; *sgr_names[j] != '\\0'; ++j) {\n\tCHECK_SGR_PARAM(j, set_a_foreground);\n\tCHECK_SGR_PARAM(j, set_a_background);\n\tCHECK_SGR_PARAM(j, set_foreground);\n\tCHECK_SGR_PARAM(j, set_background);\n    }\n#ifdef TRACE\n    show_where(2);\n    if (!auto_right_margin) {\n\tDEBUG(2,\n\t      (\"can write to lower-right directly\"));\n    } else if (PRESENT(enter_am_mode) && PRESENT(exit_am_mode)) {\n\tDEBUG(2,\n\t      (\"can write to lower-right by suppressing automargin\"));\n    } else if ((PRESENT(enter_insert_mode) && PRESENT(exit_insert_mode))\n\t       || PRESENT(insert_character) || PRESENT(parm_ich)) {\n\tDEBUG(2,\n\t      (\"can write to lower-right by using inserts\"));\n    } else {\n\tDEBUG(2,\n\t      (\"cannot write to lower-right\"));\n    }\n#endif\n\n     \n    if ((PRESENT(enter_insert_mode) || PRESENT(exit_insert_mode))\n\t&& PRESENT(insert_character)) {\n\t_nc_warning(\"non-curses applications may be confused by ich1 with smir/rmir\");\n    }\n\n     \n    if (save_check_termtype != 0)\n\tsave_check_termtype(tp, literal);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}