{
  "module_name": "tput.c",
  "hash_id": "d2b428584ce68bd7f5ca2592a7cfc48b0c1df4bbdcbce76a603b5dedcfe21a80",
  "original_prompt": "Ingested from ncurses-6.4/progs/tput.c",
  "human_readable_source": " \n\n \n\n \n\n#include <tparm_type.h>\n#include <clear_cmd.h>\n#include <reset_cmd.h>\n\n#include <transform.h>\n#include <tty_settings.h>\n\nMODULE_ID(\"$Id: tput.c,v 1.99 2022/02/26 23:19:31 tom Exp $\")\n\n#define PUTS(s)\t\tfputs(s, stdout)\n\nconst char *_nc_progname = \"tput\";\n\nstatic bool is_init = FALSE;\nstatic bool is_reset = FALSE;\nstatic bool is_clear = FALSE;\n\nstatic GCC_NORETURN void\nquit(int status, const char *fmt, ...)\n{\n    va_list argp;\n\n    va_start(argp, fmt);\n    fprintf(stderr, \"%s: \", _nc_progname);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n    ExitProgram(status);\n}\n\nstatic GCC_NORETURN void\nusage(const char *optstring)\n{\n#define KEEP(s) s \"\\n\"\n    static const char msg[] =\n    {\n\tKEEP(\"\")\n\tKEEP(\"Options:\")\n\tKEEP(\"  -S <<       read commands from standard input\")\n\tKEEP(\"  -T TERM     use this instead of $TERM\")\n\tKEEP(\"  -V          print curses-version\")\n\tKEEP(\"  -x          do not try to clear scrollback\")\n\tKEEP(\"\")\n\tKEEP(\"Commands:\")\n\tKEEP(\"  clear       clear the screen\")\n\tKEEP(\"  init        initialize the terminal\")\n\tKEEP(\"  reset       reinitialize the terminal\")\n\tKEEP(\"  capname     unlike clear/init/reset, print value for capability \\\"capname\\\"\")\n    };\n#undef KEEP\n    (void) fprintf(stderr, \"Usage: %s [options] [command]\\n\", _nc_progname);\n    if (optstring != NULL) {\n\tconst char *s = msg;\n\twhile (*s != '\\0') {\n\t    fputc(UChar(*s), stderr);\n\t    if (!strncmp(s, \"  -\", 3)) {\n\t\tif (strchr(optstring, s[3]) == NULL)\n\t\t    s = strchr(s, '\\n') + 1;\n\t    } else if (!strncmp(s, \"\\n\\nC\", 3))\n\t\tbreak;\n\t    ++s;\n\t}\n    } else {\n\tfputs(msg, stderr);\n    }\n    ExitProgram(ErrUsage);\n}\n\nstatic char *\ncheck_aliases(char *name, bool program)\n{\n    static char my_init[] = \"init\";\n    static char my_reset[] = \"reset\";\n    static char my_clear[] = \"clear\";\n\n    char *result = name;\n    if ((is_init = same_program(name, program ? PROG_INIT : my_init)))\n\tresult = my_init;\n    if ((is_reset = same_program(name, program ? PROG_RESET : my_reset)))\n\tresult = my_reset;\n    if ((is_clear = same_program(name, program ? PROG_CLEAR : my_clear)))\n\tresult = my_clear;\n    return result;\n}\n\nstatic int\nexit_code(int token, int value)\n{\n    int result = 99;\n\n    switch (token) {\n    case BOOLEAN:\n\tresult = !value;\t \n\tbreak;\n    case NUMBER:\n\tresult = 0;\t\t \n\tbreak;\n    case STRING:\n\tresult = value;\t\t \n\tbreak;\n    }\n    return result;\n}\n\n \nstatic int\ntput_cmd(int fd, TTY * settings, bool opt_x, int argc, char **argv, int *used)\n{\n    NCURSES_CONST char *name;\n    char *s;\n    int status;\n#if !PURE_TERMINFO\n    bool termcap = FALSE;\n#endif\n\n    name = check_aliases(argv[0], FALSE);\n    *used = 1;\n    if (is_reset || is_init) {\n\tTTY oldmode = *settings;\n\n\tint terasechar = -1;\t \n\tint intrchar = -1;\t \n\tint tkillchar = -1;\t \n\n\tif (is_reset) {\n\t    reset_start(stdout, TRUE, FALSE);\n\t    reset_tty_settings(fd, settings, FALSE);\n\t} else {\n\t    reset_start(stdout, FALSE, TRUE);\n\t}\n\n#if HAVE_SIZECHANGE\n\tset_window_size(fd, &lines, &columns);\n#else\n\t(void) fd;\n#endif\n\tset_control_chars(settings, terasechar, intrchar, tkillchar);\n\tset_conversions(settings);\n\n\tif (send_init_strings(fd, &oldmode)) {\n\t    reset_flush();\n\t}\n\n\tupdate_tty_settings(&oldmode, settings);\n\treturn 0;\n    }\n\n    if (strcmp(name, \"longname\") == 0) {\n\tPUTS(longname());\n\treturn 0;\n    }\n#if !PURE_TERMINFO\n  retry:\n#endif\n    if (strcmp(name, \"clear\") == 0) {\n\treturn (clear_cmd(opt_x) == ERR) ? ErrUsage : 0;\n    } else if ((status = tigetflag(name)) != -1) {\n\treturn exit_code(BOOLEAN, status);\n    } else if ((status = tigetnum(name)) != CANCELLED_NUMERIC) {\n\t(void) printf(\"%d\\n\", status);\n\treturn exit_code(NUMBER, 0);\n    } else if ((s = tigetstr(name)) == CANCELLED_STRING) {\n#if !PURE_TERMINFO\n\tif (!termcap) {\n\t    const struct name_table_entry *np;\n\n\t    termcap = TRUE;\n\t    if ((np = _nc_find_entry(name, _nc_get_hash_table(termcap))) != 0) {\n\t\tswitch (np->nte_type) {\n\t\tcase BOOLEAN:\n\t\t    name = boolnames[np->nte_index];\n\t\t    break;\n\n\t\tcase NUMBER:\n\t\t    name = numnames[np->nte_index];\n\t\t    break;\n\n\t\tcase STRING:\n\t\t    name = strnames[np->nte_index];\n\t\t    break;\n\t\t}\n\t\tgoto retry;\n\t    }\n\t}\n#endif\n\tquit(ErrCapName, \"unknown terminfo capability '%s'\", name);\n    } else if (VALID_STRING(s)) {\n\tif (argc > 1) {\n\t    int k;\n\t    int analyzed;\n\t    int popcount;\n\t    long numbers[1 + NUM_PARM];\n\t    char *strings[1 + NUM_PARM];\n\t    char *p_is_s[NUM_PARM];\n\t    TParams paramType;\n\n\t     \n\n\t    for (k = 1; (k < argc) && (k <= NUM_PARM); k++) {\n\t\tchar *tmp = 0;\n\t\tstrings[k] = argv[k];\n\t\tnumbers[k] = strtol(argv[k], &tmp, 0);\n\t\tif (tmp == 0 || *tmp != 0)\n\t\t    numbers[k] = 0;\n\t    }\n\t    for (k = argc; k <= NUM_PARM; k++) {\n\t\tnumbers[k] = 0;\n\t\tstrings[k] = 0;\n\t    }\n\n\t    paramType = tparm_type(name);\n#if NCURSES_XNAMES\n\t     \n\t    if (paramType == Numbers) {\n\t\tstruct name_table_entry const *entry_ptr;\n\t\tentry_ptr = _nc_find_type_entry(name, STRING, FALSE);\n\t\tif (entry_ptr == NULL) {\n\t\t    paramType = Other;\n\t\t}\n\t    }\n#endif\n\n\t    popcount = 0;\n\t    _nc_reset_tparm(NULL);\n\t    switch (paramType) {\n\t    case Num_Str:\n\t\ts = TPARM_2(s, numbers[1], strings[2]);\n\t\tanalyzed = 2;\n\t\tbreak;\n\t    case Num_Str_Str:\n\t\ts = TPARM_3(s, numbers[1], strings[2], strings[3]);\n\t\tanalyzed = 3;\n\t\tbreak;\n\t    case Numbers:\n\t\tanalyzed = _nc_tparm_analyze(NULL, s, p_is_s, &popcount);\n#define myParam(n) numbers[n]\n\t\ts = TIPARM_9(s,\n\t\t\t     myParam(1),\n\t\t\t     myParam(2),\n\t\t\t     myParam(3),\n\t\t\t     myParam(4),\n\t\t\t     myParam(5),\n\t\t\t     myParam(6),\n\t\t\t     myParam(7),\n\t\t\t     myParam(8),\n\t\t\t     myParam(9));\n#undef myParam\n\t\tbreak;\n\t    case Other:\n\t\t \n\t    default:\n\t\tanalyzed = _nc_tparm_analyze(NULL, s, p_is_s, &popcount);\n#define myParam(n) (p_is_s[n - 1] != 0 ? ((TPARM_ARG) strings[n]) : numbers[n])\n\t\ts = TPARM_9(s,\n\t\t\t    myParam(1),\n\t\t\t    myParam(2),\n\t\t\t    myParam(3),\n\t\t\t    myParam(4),\n\t\t\t    myParam(5),\n\t\t\t    myParam(6),\n\t\t\t    myParam(7),\n\t\t\t    myParam(8),\n\t\t\t    myParam(9));\n#undef myParam\n\t\tbreak;\n\t    }\n\t    if (analyzed < popcount) {\n\t\tanalyzed = popcount;\n\t    }\n\t    *used += analyzed;\n\t}\n\n\t \n\tputp(s);\n\treturn exit_code(STRING, 0);\n    }\n    return exit_code(STRING, 1);\n}\n\nint\nmain(int argc, char **argv)\n{\n    char *term;\n    int errret;\n    bool cmdline = TRUE;\n    int c;\n    char buf[BUFSIZ];\n    int result = 0;\n    int fd;\n    int used;\n    TTY old_settings;\n    TTY tty_settings;\n    bool opt_x = FALSE;\t\t \n    bool is_alias;\n    bool need_tty;\n\n    _nc_progname = check_aliases(_nc_rootname(argv[0]), TRUE);\n    is_alias = (is_clear || is_reset || is_init);\n\n    term = getenv(\"TERM\");\n\n    while ((c = getopt(argc, argv, is_alias ? \"T:Vx\" : \"ST:Vx\")) != -1) {\n\tswitch (c) {\n\tcase 'S':\n\t    cmdline = FALSE;\n\t    break;\n\tcase 'T':\n\t    use_env(FALSE);\n\t    use_tioctl(TRUE);\n\t    term = optarg;\n\t    break;\n\tcase 'V':\n\t    puts(curses_version());\n\t    ExitProgram(EXIT_SUCCESS);\n\tcase 'x':\t\t \n\t    opt_x = TRUE;\n\t    break;\n\tdefault:\n\t    usage(is_alias ? \"TVx\" : NULL);\n\t     \n\t}\n    }\n\n    need_tty = ((is_reset || is_init) ||\n\t\t(optind < argc &&\n\t\t (!strcmp(argv[optind], \"reset\") ||\n\t\t  !strcmp(argv[optind], \"init\"))));\n\n     \n    if (is_alias) {\n\tif (optind-- < argc) {\n\t    argc -= optind;\n\t    argv += optind;\n\t}\n\targv[0] = strdup(_nc_progname);\n    } else {\n\targc -= optind;\n\targv += optind;\n    }\n\n    if (term == 0 || *term == '\\0')\n\tquit(ErrUsage, \"No value for $TERM and no -T specified\");\n\n    fd = save_tty_settings(&tty_settings, need_tty);\n    old_settings = tty_settings;\n\n    if (setupterm(term, fd, &errret) != OK && errret <= 0)\n\tquit(ErrTermType, \"unknown terminal \\\"%s\\\"\", term);\n\n    if (cmdline) {\n\tint code = 0;\n\tif ((argc <= 0) && !is_alias)\n\t    usage(NULL);\n\twhile (argc > 0) {\n\t    tty_settings = old_settings;\n\t    code = tput_cmd(fd, &tty_settings, opt_x, argc, argv, &used);\n\t    if (code != 0)\n\t\tbreak;\n\t    argc -= used;\n\t    argv += used;\n\t}\n\tExitProgram(code);\n    }\n\n    while (fgets(buf, sizeof(buf), stdin) != 0) {\n\tsize_t need = strlen(buf);\n\tchar **argvec = typeCalloc(char *, need + 1);\n\tchar **argnow;\n\tint argnum = 0;\n\tchar *cp;\n\n\tif (argvec == NULL) {\n\t    quit(ErrSystem(1), strerror(errno));\n\t}\n\n\t \n\tfor (cp = buf; *cp; cp++) {\n\t    if (isspace(UChar(*cp))) {\n\t\t*cp = '\\0';\n\t    } else if (cp == buf || cp[-1] == '\\0') {\n\t\targvec[argnum++] = cp;\n\t\tif (argnum >= (int) need)\n\t\t    break;\n\t    }\n\t}\n\n\targnow = argvec;\n\twhile (argnum > 0) {\n\t    int code;\n\t    tty_settings = old_settings;\n\t    code = tput_cmd(fd, &tty_settings, opt_x, argnum, argnow, &used);\n\t    if (code != 0) {\n\t\tif (result == 0)\n\t\t    result = ErrSystem(0);\t \n\t\t++result;\n\t    }\n\t    argnum -= used;\n\t    argnow += used;\n\t}\n\tfree(argvec);\n    }\n\n    ExitProgram(result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}