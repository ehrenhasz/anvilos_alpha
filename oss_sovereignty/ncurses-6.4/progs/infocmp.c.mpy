{
  "module_name": "infocmp.c",
  "hash_id": "649a783ec2dbba900bdf94508a654b9c45aaf0755873581641d85aa208e0ba2c",
  "original_prompt": "Ingested from ncurses-6.4/progs/infocmp.c",
  "human_readable_source": " \n\n \n\n \n\n#include <progs.priv.h>\n\n#include <dump_entry.h>\n\nMODULE_ID(\"$Id: infocmp.c,v 1.156 2022/09/24 10:13:06 tom Exp $\")\n\n#define MAX_STRING\t1024\t \n\nconst char *_nc_progname = \"infocmp\";\n\ntypedef char path[PATH_MAX];\n\n \n\nstatic ENTRY *entries;\t\t \nstatic int termcount;\t\t \n\nstatic bool limited = TRUE;\t \nstatic bool quiet = FALSE;\nstatic bool literal = FALSE;\nstatic const char *bool_sep = \":\";\nstatic const char *s_absent = \"NULL\";\nstatic const char *s_cancel = \"NULL\";\nstatic const char *tversion;\t \nstatic unsigned itrace;\t\t \nstatic int mwidth = 60;\nstatic int mheight = 65535;\nstatic int numbers = 0;\t\t \nstatic int outform = F_TERMINFO;\t \nstatic int sortmode;\t\t \n\n \nstatic int compare;\n#define C_DEFAULT\t0\t \n#define C_DIFFERENCE\t1\t \n#define C_COMMON\t2\t \n#define C_NAND\t\t3\t \n#define C_USEALL\t4\t \nstatic bool ignorepads;\t\t \n\n#if NO_LEAKS\n\ntypedef struct {\n    ENTRY *head;\n    ENTRY *tail;\n} ENTERED;\n\nstatic ENTERED *entered;\n\n#undef ExitProgram\nstatic GCC_NORETURN void ExitProgram(int code);\n \nstatic void\nExitProgram(int code)\n{\n    int n;\n\n    for (n = 0; n < termcount; ++n) {\n\tENTRY *new_head = _nc_head;\n\tENTRY *new_tail = _nc_tail;\n\t_nc_head = entered[n].head;\n\t_nc_tail = entered[n].tail;\n\t_nc_free_entries(entered[n].head);\n\t_nc_head = new_head;\n\t_nc_tail = new_tail;\n    }\n    _nc_leaks_dump_entry();\n    free(entries);\n    free(entered);\n    _nc_free_tic(code);\n}\n#endif\n\nstatic void\nfailed(const char *s)\n{\n    perror(s);\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic void\ncanonical_name(char *source, char *target)\n \n{\n    int limit = NAMESIZE;\n\n    while (--limit > 0) {\n\tchar ch = *source++;\n\tif (ch == '|')\n\t    break;\n\t*target++ = ch;\n    }\n    *target = '\\0';\n}\n\nstatic bool\nno_boolean(int value)\n{\n    bool result = (value == ABSENT_BOOLEAN);\n    if (!strcmp(s_absent, s_cancel))\n\tresult = !VALID_BOOLEAN(value);\n    return result;\n}\n\nstatic bool\nno_numeric(int value)\n{\n    bool result = (value == ABSENT_NUMERIC);\n    if (!strcmp(s_absent, s_cancel))\n\tresult = !VALID_NUMERIC(value);\n    return result;\n}\n\nstatic bool\nno_string(char *value)\n{\n    bool result = (value == ABSENT_STRING);\n    if (!strcmp(s_absent, s_cancel))\n\tresult = !VALID_STRING(value);\n    return result;\n}\n\n \n\nstatic int\ncapcmp(PredIdx idx, const char *s, const char *t)\n \n{\n    if (!VALID_STRING(s) && !VALID_STRING(t))\n\treturn (s != t);\n    else if (!VALID_STRING(s) || !VALID_STRING(t))\n\treturn (1);\n\n    if ((idx == acs_chars_index) || !ignorepads)\n\treturn (strcmp(s, t));\n    else\n\treturn (_nc_capcmp(s, t));\n}\n\nstatic int\nuse_predicate(unsigned type, PredIdx idx)\n \n{\n    ENTRY *ep;\n\n    switch (type) {\n    case BOOLEAN:\n\t{\n\t    int is_set = FALSE;\n\n\t     \n\t    for (ep = &entries[1]; ep < entries + termcount; ep++)\n\t\tif (ep->tterm.Booleans[idx] == TRUE) {\n\t\t    is_set = entries[0].tterm.Booleans[idx];\n\t\t    break;\n\t\t}\n\t    if (is_set != entries[0].tterm.Booleans[idx])\n\t\treturn (!is_set);\n\t    else\n\t\treturn (FAIL);\n\t}\n\n    case NUMBER:\n\t{\n\t    int value = ABSENT_NUMERIC;\n\n\t     \n\t    for (ep = &entries[1]; ep < entries + termcount; ep++)\n\t\tif (VALID_NUMERIC(ep->tterm.Numbers[idx])) {\n\t\t    value = ep->tterm.Numbers[idx];\n\t\t    break;\n\t\t}\n\n\t    if (value != entries[0].tterm.Numbers[idx])\n\t\treturn (value != ABSENT_NUMERIC);\n\t    else\n\t\treturn (FAIL);\n\t}\n\n    case STRING:\n\t{\n\t    char *termstr, *usestr = ABSENT_STRING;\n\n\t    termstr = entries[0].tterm.Strings[idx];\n\n\t     \n\t    for (ep = &entries[1]; ep < entries + termcount; ep++)\n\t\tif (ep->tterm.Strings[idx]) {\n\t\t    usestr = ep->tterm.Strings[idx];\n\t\t    break;\n\t\t}\n\n\t    if (usestr == ABSENT_STRING && termstr == ABSENT_STRING)\n\t\treturn (FAIL);\n\t    else if (!usestr || !termstr || capcmp(idx, usestr, termstr))\n\t\treturn (TRUE);\n\t    else\n\t\treturn (FAIL);\n\t}\n    }\n\n    return (FALSE);\t\t \n}\n\nstatic bool\nuseeq(ENTRY * e1, ENTRY * e2)\n \n{\n    unsigned i, j;\n\n    if (e1->nuses != e2->nuses)\n\treturn (FALSE);\n\n     \n    for (i = 0; i < e1->nuses; i++) {\n\tbool foundmatch = FALSE;\n\n\t \n\tfor (j = 0; j < e2->nuses; j++)\n\t    if (!strcmp(e1->uses[i].name, e2->uses[j].name)) {\n\t\tfoundmatch = TRUE;\n\t\tbreak;\n\t    }\n\n\tif (!foundmatch)\n\t    return (FALSE);\n    }\n\n    return (TRUE);\n}\n\nstatic bool\nentryeq(TERMTYPE2 *t1, TERMTYPE2 *t2)\n \n{\n    unsigned i;\n\n    for (i = 0; i < NUM_BOOLEANS(t1); i++)\n\tif (t1->Booleans[i] != t2->Booleans[i])\n\t    return (FALSE);\n\n    for (i = 0; i < NUM_NUMBERS(t1); i++)\n\tif (t1->Numbers[i] != t2->Numbers[i])\n\t    return (FALSE);\n\n    for (i = 0; i < NUM_STRINGS(t1); i++)\n\tif (capcmp((PredIdx) i, t1->Strings[i], t2->Strings[i]))\n\t    return (FALSE);\n\n    return (TRUE);\n}\n\n#define TIC_EXPAND(result) _nc_tic_expand(result, outform==F_TERMINFO, numbers)\n\nstatic void\nprint_uses(ENTRY * ep, FILE *fp)\n \n{\n    if (!ep->nuses) {\n\tfputs(\"NULL\", fp);\n    } else {\n\tunsigned i;\n\n\tfor (i = 0; i < ep->nuses; i++) {\n\t    fputs(ep->uses[i].name, fp);\n\t    if (i < ep->nuses - 1)\n\t\tfputs(\" \", fp);\n\t}\n    }\n}\n\nstatic const char *\ndump_boolean(int val)\n \n{\n    switch (val) {\n    case ABSENT_BOOLEAN:\n\treturn (s_absent);\n    case CANCELLED_BOOLEAN:\n\treturn (s_cancel);\n    case FALSE:\n\treturn (\"F\");\n    case TRUE:\n\treturn (\"T\");\n    default:\n\treturn (\"?\");\n    }\n}\n\nstatic void\ndump_numeric(int val, char *buf)\n \n{\n    switch (val) {\n    case ABSENT_NUMERIC:\n\t_nc_STRCPY(buf, s_absent, MAX_STRING);\n\tbreak;\n    case CANCELLED_NUMERIC:\n\t_nc_STRCPY(buf, s_cancel, MAX_STRING);\n\tbreak;\n    default:\n\t_nc_SPRINTF(buf, _nc_SLIMIT(MAX_STRING) \"%d\", val);\n\tbreak;\n    }\n}\n\nstatic void\ndump_string(char *val, char *buf)\n \n{\n    if (val == ABSENT_STRING)\n\t_nc_STRCPY(buf, s_absent, MAX_STRING);\n    else if (val == CANCELLED_STRING)\n\t_nc_STRCPY(buf, s_cancel, MAX_STRING);\n    else {\n\t_nc_SPRINTF(buf, _nc_SLIMIT(MAX_STRING)\n\t\t    \"'%.*s'\", MAX_STRING - 3, TIC_EXPAND(val));\n    }\n}\n\n \nstatic void\nshow_comparing(char **names)\n{\n    if (itrace) {\n\tswitch (compare) {\n\tcase C_DIFFERENCE:\n\t    (void) fprintf(stderr, \"%s: dumping differences\\n\", _nc_progname);\n\t    break;\n\n\tcase C_COMMON:\n\t    (void) fprintf(stderr, \"%s: dumping common capabilities\\n\", _nc_progname);\n\t    break;\n\n\tcase C_NAND:\n\t    (void) fprintf(stderr, \"%s: dumping differences\\n\", _nc_progname);\n\t    break;\n\t}\n    }\n    if (*names) {\n\tprintf(\"comparing %s\", *names++);\n\tif (*names) {\n\t    printf(\" to %s\", *names++);\n\t    while (*names) {\n\t\tprintf(\", %s\", *names++);\n\t    }\n\t}\n\tprintf(\".\\n\");\n    }\n}\n\n \n#if NCURSES_XNAMES\n#define check_user_definable(n,limit) if (!_nc_user_definable && (n) > (limit)) break\n#else\n#define check_user_definable(n,limit) if ((n) > (limit)) break\n#endif\n\n \n#define for_each_entry() while (entries[extra].tterm.term_names)\n#define next_entry           (&(entries[extra++].tterm))\n\nstatic void\ncompare_predicate(PredType type, PredIdx idx, const char *name)\n \n{\n    ENTRY *e1 = &entries[0];\n    ENTRY *e2 = &entries[1];\n    char buf1[MAX_STRING];\n    char buf2[MAX_STRING];\n    int b1, b2;\n    int n1, n2;\n    char *s1, *s2;\n    bool found;\n    int extra = 1;\n\n    switch (type) {\n    case CMP_BOOLEAN:\n\tcheck_user_definable(idx, BOOLWRITE);\n\tb1 = e1->tterm.Booleans[idx];\n\tswitch (compare) {\n\tcase C_DIFFERENCE:\n\t    b2 = next_entry->Booleans[idx];\n\t    if (!(no_boolean(b1) && no_boolean(b2)) && (b1 != b2))\n\t\t(void) printf(\"\\t%s: %s%s%s.\\n\",\n\t\t\t      name,\n\t\t\t      dump_boolean(b1),\n\t\t\t      bool_sep,\n\t\t\t      dump_boolean(b2));\n\t    break;\n\n\tcase C_COMMON:\n\t    if (b1 != ABSENT_BOOLEAN) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    b2 = next_entry->Booleans[idx];\n\t\t    if (b1 != b2) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) printf(\"\\t%s= %s.\\n\", name, dump_boolean(b1));\n\t\t}\n\t    }\n\t    break;\n\n\tcase C_NAND:\n\t    if (b1 == ABSENT_BOOLEAN) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    b2 = next_entry->Booleans[idx];\n\t\t    if (b1 != b2) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) printf(\"\\t!%s.\\n\", name);\n\t\t}\n\t    }\n\t    break;\n\t}\n\tbreak;\n\n    case CMP_NUMBER:\n\tcheck_user_definable(idx, NUMWRITE);\n\tn1 = e1->tterm.Numbers[idx];\n\tswitch (compare) {\n\tcase C_DIFFERENCE:\n\t    n2 = next_entry->Numbers[idx];\n\t    if (!(no_numeric(n1) && no_numeric(n2)) && n1 != n2) {\n\t\tdump_numeric(n1, buf1);\n\t\tdump_numeric(n2, buf2);\n\t\t(void) printf(\"\\t%s: %s, %s.\\n\", name, buf1, buf2);\n\t    }\n\t    break;\n\n\tcase C_COMMON:\n\t    if (n1 != ABSENT_NUMERIC) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    n2 = next_entry->Numbers[idx];\n\t\t    if (n1 != n2) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    dump_numeric(n1, buf1);\n\t\t    (void) printf(\"\\t%s= %s.\\n\", name, buf1);\n\t\t}\n\t    }\n\t    break;\n\n\tcase C_NAND:\n\t    if (n1 == ABSENT_NUMERIC) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    n2 = next_entry->Numbers[idx];\n\t\t    if (n1 != n2) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) printf(\"\\t!%s.\\n\", name);\n\t\t}\n\t    }\n\t    break;\n\t}\n\tbreak;\n\n    case CMP_STRING:\n\tcheck_user_definable(idx, STRWRITE);\n\ts1 = e1->tterm.Strings[idx];\n\tswitch (compare) {\n\tcase C_DIFFERENCE:\n\t    s2 = next_entry->Strings[idx];\n\t    if (!(no_string(s1) && no_string(s2)) && capcmp(idx, s1, s2)) {\n\t\tdump_string(s1, buf1);\n\t\tdump_string(s2, buf2);\n\t\tif (strcmp(buf1, buf2))\n\t\t    (void) printf(\"\\t%s: %s, %s.\\n\", name, buf1, buf2);\n\t    }\n\t    break;\n\n\tcase C_COMMON:\n\t    if (s1 != ABSENT_STRING) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    s2 = next_entry->Strings[idx];\n\t\t    if (capcmp(idx, s1, s2) != 0) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) printf(\"\\t%s= '%s'.\\n\", name, TIC_EXPAND(s1));\n\t\t}\n\t    }\n\t    break;\n\n\tcase C_NAND:\n\t    if (s1 == ABSENT_STRING) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    s2 = next_entry->Strings[idx];\n\t\t    if (s2 != s1) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) printf(\"\\t!%s.\\n\", name);\n\t\t}\n\t    }\n\t    break;\n\t}\n\tbreak;\n\n    case CMP_USE:\n\t \n\tswitch (compare) {\n\tcase C_DIFFERENCE:\n\t    if (!useeq(e1, e2)) {\n\t\t(void) fputs(\"\\tuse: \", stdout);\n\t\tprint_uses(e1, stdout);\n\t\tfputs(\", \", stdout);\n\t\tprint_uses(e2, stdout);\n\t\tfputs(\".\\n\", stdout);\n\t    }\n\t    break;\n\n\tcase C_COMMON:\n\t    if (e1->nuses) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    e2 = &entries[extra++];\n\t\t    if (e2->nuses != e1->nuses || !useeq(e1, e2)) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) fputs(\"\\tuse: \", stdout);\n\t\t    print_uses(e1, stdout);\n\t\t    fputs(\".\\n\", stdout);\n\t\t}\n\t    }\n\t    break;\n\n\tcase C_NAND:\n\t    if (!e1->nuses) {\n\t\tfound = TRUE;\n\t\tfor_each_entry() {\n\t\t    e2 = &entries[extra++];\n\t\t    if (e2->nuses != e1->nuses) {\n\t\t\tfound = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (found) {\n\t\t    (void) printf(\"\\t!use.\\n\");\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n}\n\n \n\n#define DATA(from, to) { { from }, { to } }\n#define DATAX()        DATA(\"\", \"\")\n\ntypedef struct {\n    const char from[4];\n    const char to[12];\n} assoc;\n\nstatic const assoc std_caps[] =\n{\n     \n    DATA(\"\\033c\", \"RIS\"),\t \n    DATA(\"\\0337\", \"SC\"),\t \n    DATA(\"\\0338\", \"RC\"),\t \n    DATA(\"\\033[r\", \"RSR\"),\t \n    DATA(\"\\033[m\", \"SGR0\"),\t \n    DATA(\"\\033[2J\", \"ED2\"),\t \n\n     \n    DATA(\"\\033(0\", \"ISO DEC G0\"),\t \n    DATA(\"\\033(A\", \"ISO UK G0\"),\t \n    DATA(\"\\033(B\", \"ISO US G0\"),\t \n    DATA(\"\\033)0\", \"ISO DEC G1\"),\t \n    DATA(\"\\033)A\", \"ISO UK G1\"),\t \n    DATA(\"\\033)B\", \"ISO US G1\"),\t \n\n     \n    DATA(\"\\033=\", \"DECPAM\"),\t \n    DATA(\"\\033>\", \"DECPNM\"),\t \n    DATA(\"\\033<\", \"DECANSI\"),\t \n    DATA(\"\\033[!p\", \"DECSTR\"),\t \n    DATA(\"\\033 F\", \"S7C1T\"),\t \n\n    DATAX()\n};\n\nstatic const assoc std_modes[] =\n \n{\n    DATA(\"2\", \"AM\"),\t\t \n    DATA(\"4\", \"IRM\"),\t\t \n    DATA(\"12\", \"SRM\"),\t\t \n    DATA(\"20\", \"LNM\"),\t\t \n    DATAX()\n};\n\nstatic const assoc private_modes[] =\n \n{\n    DATA(\"1\", \"CKM\"),\t\t \n    DATA(\"2\", \"ANM\"),\t\t \n    DATA(\"3\", \"COLM\"),\t\t \n    DATA(\"4\", \"SCLM\"),\t\t \n    DATA(\"5\", \"SCNM\"),\t\t \n    DATA(\"6\", \"OM\"),\t\t \n    DATA(\"7\", \"AWM\"),\t\t \n    DATA(\"8\", \"ARM\"),\t\t \n    DATAX()\n};\n\nstatic const assoc ecma_highlights[] =\n \n{\n    DATA(\"0\", \"NORMAL\"),\t \n    DATA(\"1\", \"+BOLD\"),\t\t \n    DATA(\"2\", \"+DIM\"),\t\t \n    DATA(\"3\", \"+ITALIC\"),\t \n    DATA(\"4\", \"+UNDERLINE\"),\t \n    DATA(\"5\", \"+BLINK\"),\t \n    DATA(\"6\", \"+FASTBLINK\"),\t \n    DATA(\"7\", \"+REVERSE\"),\t \n    DATA(\"8\", \"+INVISIBLE\"),\t \n    DATA(\"9\", \"+DELETED\"),\t \n    DATA(\"10\", \"MAIN-FONT\"),\t \n    DATA(\"11\", \"ALT-FONT-1\"),\t \n    DATA(\"12\", \"ALT-FONT-2\"),\t \n    DATA(\"13\", \"ALT-FONT-3\"),\t \n    DATA(\"14\", \"ALT-FONT-4\"),\t \n    DATA(\"15\", \"ALT-FONT-5\"),\t \n    DATA(\"16\", \"ALT-FONT-6\"),\t \n    DATA(\"17\", \"ALT-FONT-7\"),\t \n    DATA(\"18\", \"ALT-FONT-1\"),\t \n    DATA(\"19\", \"ALT-FONT-1\"),\t \n    DATA(\"20\", \"FRAKTUR\"),\t \n    DATA(\"21\", \"DOUBLEUNDER\"),\t \n    DATA(\"22\", \"-DIM\"),\t\t \n    DATA(\"23\", \"-ITALIC\"),\t \n    DATA(\"24\", \"-UNDERLINE\"),\t \n    DATA(\"25\", \"-BLINK\"),\t \n    DATA(\"26\", \"-FASTBLINK\"),\t \n    DATA(\"27\", \"-REVERSE\"),\t \n    DATA(\"28\", \"-INVISIBLE\"),\t \n    DATA(\"29\", \"-DELETED\"),\t \n    DATAX()\n};\n\n#undef DATA\n\nstatic int\nskip_csi(const char *cap)\n{\n    int result = 0;\n    if (cap[0] == '\\033' && cap[1] == '[')\n\tresult = 2;\n    else if (UChar(cap[0]) == 0233)\n\tresult = 1;\n    return result;\n}\n\nstatic bool\nsame_param(const char *table, const char *param, size_t length)\n{\n    bool result = FALSE;\n    if (strncmp(table, param, length) == 0) {\n\tresult = !isdigit(UChar(param[length]));\n    }\n    return result;\n}\n\nstatic char *\nlookup_params(const assoc * table, char *dst, char *src)\n{\n    char *result = 0;\n    const char *ep = strtok(src, \";\");\n\n    if (ep != 0) {\n\tconst assoc *ap;\n\n\tdo {\n\t    bool found = FALSE;\n\n\t    for (ap = table; ap->from[0]; ap++) {\n\t\tsize_t tlen = strlen(ap->from);\n\n\t\tif (same_param(ap->from, ep, tlen)) {\n\t\t    _nc_STRCAT(dst, ap->to, MAX_TERMINFO_LENGTH);\n\t\t    found = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (!found)\n\t\t_nc_STRCAT(dst, ep, MAX_TERMINFO_LENGTH);\n\t    _nc_STRCAT(dst, \";\", MAX_TERMINFO_LENGTH);\n\t} while\n\t    ((ep = strtok((char *) 0, \";\")));\n\n\tdst[strlen(dst) - 1] = '\\0';\n\n\tresult = dst;\n    }\n    return result;\n}\n\nstatic void\nanalyze_string(const char *name, const char *cap, TERMTYPE2 *tp)\n{\n    char buf2[MAX_TERMINFO_LENGTH];\n    const char *sp;\n    const assoc *ap;\n    int tp_lines = tp->Numbers[2];\n\n    if (!VALID_STRING(cap))\n\treturn;\n    (void) printf(\"%s: \", name);\n\n    for (sp = cap; *sp; sp++) {\n\tint i;\n\tint csi;\n\tsize_t len = 0;\n\tsize_t next;\n\tconst char *expansion = 0;\n\tchar buf3[MAX_TERMINFO_LENGTH];\n\n\t \n\tfor (i = 0; i < STRCOUNT; i++) {\n\t    char *cp = tp->Strings[i];\n\n\t     \n\t    if (strnames[i] == NULL)\n\t\tcontinue;\n\t    if (strnames[i][0] == 'k' && strnames[i][1] == 'f')\n\t\tcontinue;\n\n\t    if (VALID_STRING(cp) &&\n\t\tcp[0] != '\\0' &&\n\t\tcp != cap) {\n\t\tlen = strlen(cp);\n\t\t_nc_STRNCPY(buf2, sp, len);\n\t\tbuf2[len] = '\\0';\n\n\t\tif (_nc_capcmp(cp, buf2))\n\t\t    continue;\n\n#define ISRS(s)\t(!strncmp((s), \"is\", (size_t) 2) || !strncmp((s), \"rs\", (size_t) 2))\n\t\t \n\t\tif (ISRS(name) || ISRS(strnames[i]))\n\t\t    if (cap < cp)\n\t\t\tcontinue;\n#undef ISRS\n\n\t\texpansion = strnames[i];\n\t\tbreak;\n\t    }\n\t}\n\n\t \n\tif (!expansion) {\n\t    csi = skip_csi(sp);\n\t    for (ap = std_caps; ap->from[0]; ap++) {\n\t\tsize_t adj = (size_t) (csi ? 2 : 0);\n\n\t\tlen = strlen(ap->from);\n\t\tif (csi && skip_csi(ap->from) != csi)\n\t\t    continue;\n\t\tif (len > adj\n\t\t    && strncmp(ap->from + adj, sp + csi, len - adj) == 0) {\n\t\t    expansion = ap->to;\n\t\t    len -= adj;\n\t\t    len += (size_t) csi;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t \n\tif (!expansion\n\t    && (csi = skip_csi(sp)) != 0\n\t    && (len = (strspn) (sp + csi, \"0123456789;\"))\n\t    && (len < sizeof(buf3))\n\t    && (next = (size_t) csi + len)\n\t    && ((sp[next] == 'h') || (sp[next] == 'l'))) {\n\n\t    _nc_STRCPY(buf2,\n\t\t       ((sp[next] == 'h')\n\t\t\t? \"ECMA+\"\n\t\t\t: \"ECMA-\"),\n\t\t       sizeof(buf2));\n\t    _nc_STRNCPY(buf3, sp + csi, len);\n\t    buf3[len] = '\\0';\n\n\t    expansion = lookup_params(std_modes, buf2, buf3);\n\t}\n\n\t \n\tif (!expansion\n\t    && (csi = skip_csi(sp)) != 0\n\t    && sp[csi] == '?'\n\t    && (len = (strspn) (sp + csi + 1, \"0123456789;\"))\n\t    && (len < sizeof(buf3))\n\t    && (next = (size_t) csi + 1 + len)\n\t    && ((sp[next] == 'h') || (sp[next] == 'l'))) {\n\n\t    _nc_STRCPY(buf2,\n\t\t       ((sp[next] == 'h')\n\t\t\t? \"DEC+\"\n\t\t\t: \"DEC-\"),\n\t\t       sizeof(buf2));\n\t    _nc_STRNCPY(buf3, sp + csi + 1, len);\n\t    buf3[len] = '\\0';\n\n\t    expansion = lookup_params(private_modes, buf2, buf3);\n\t}\n\n\t \n\tif (!expansion\n\t    && (csi = skip_csi(sp)) != 0\n\t    && (len = (strspn) (sp + csi, \"0123456789;\")) != 0\n\t    && (len < sizeof(buf3))\n\t    && (next = (size_t) csi + len)\n\t    && sp[next] == 'm') {\n\n\t    _nc_STRCPY(buf2, \"SGR:\", sizeof(buf2));\n\t    _nc_STRNCPY(buf3, sp + csi, len);\n\t    buf3[len] = '\\0';\n\t    len += (size_t) csi + 1;\n\n\t    expansion = lookup_params(ecma_highlights, buf2, buf3);\n\t}\n\n\tif (!expansion\n\t    && (csi = skip_csi(sp)) != 0\n\t    && sp[csi] == 'm') {\n\t    len = (size_t) csi + 1;\n\t    _nc_STRCPY(buf2, \"SGR:\", sizeof(buf2));\n\t    _nc_STRCAT(buf2, ecma_highlights[0].to, sizeof(buf2));\n\t    expansion = buf2;\n\t}\n\n\t \n\tif (!expansion\n\t    && (csi = skip_csi(sp)) != 0) {\n\t    if (sp[csi] == 'r') {\n\t\texpansion = \"RSR\";\n\t\tlen = 1;\n\t    } else {\n\t\t_nc_SPRINTF(buf2, _nc_SLIMIT(sizeof(buf2)) \"1;%dr\", tp_lines);\n\t\tlen = strlen(buf2);\n\t\tif (strncmp(buf2, sp + csi, len) == 0)\n\t\t    expansion = \"RSR\";\n\t    }\n\t    len += (size_t) csi;\n\t}\n\n\t \n\tif (!expansion\n\t    && (csi = skip_csi(sp)) != 0) {\n\t    _nc_SPRINTF(buf2, _nc_SLIMIT(sizeof(buf2)) \"%d;1H\", tp_lines);\n\t    len = strlen(buf2);\n\t    if (strncmp(buf2, sp + csi, len) == 0) {\n\t\texpansion = \"LL\";\n\t    } else {\n\t\t_nc_SPRINTF(buf2, _nc_SLIMIT(sizeof(buf2)) \"%dH\", tp_lines);\n\t\tlen = strlen(buf2);\n\t\tif (strncmp(buf2, sp + csi, len) == 0) {\n\t\t    expansion = \"LL\";\n\t\t}\n\t    }\n\t    len += (size_t) csi;\n\t}\n\n\t \n\tif (expansion) {\n\t    printf(\"{%s}\", expansion);\n\t    sp += len - 1;\n\t} else {\n\t     \n\t    buf2[0] = *sp;\n\t    buf2[1] = '\\0';\n\t    fputs(TIC_EXPAND(buf2), stdout);\n\t}\n    }\n    putchar('\\n');\n}\n\n \n\nstatic void\nfile_comparison(int argc, char *argv[])\n{\n#define MAXCOMPARE\t2\n     \n    int filecount = 0;\n    ENTRY *heads[MAXCOMPARE];\n    ENTRY *qp, *rp;\n    int i, n;\n\n    memset(heads, 0, sizeof(heads));\n    dump_init((char *) 0, F_LITERAL, S_TERMINFO,\n\t      FALSE, 0, 65535, itrace, FALSE, FALSE, FALSE);\n\n    for (n = 0; n < argc && n < MAXCOMPARE; n++) {\n\tif (freopen(argv[n], \"r\", stdin) == 0)\n\t    _nc_err_abort(\"Can't open %s\", argv[n]);\n\n#if NO_LEAKS\n\tentered[n].head = _nc_head;\n\tentered[n].tail = _nc_tail;\n#endif\n\t_nc_head = _nc_tail = 0;\n\n\t \n\t_nc_set_source(argv[n]);\n\t_nc_read_entry_source(stdin, NULL, TRUE, literal, NULLHOOK);\n\n\tif (itrace)\n\t    (void) fprintf(stderr, \"Resolving file %d...\\n\", n - 0);\n\n\t \n\tif (!_nc_resolve_uses2(!limited, literal)) {\n\t    (void) fprintf(stderr,\n\t\t\t   \"There are unresolved use entries in %s:\\n\",\n\t\t\t   argv[n]);\n\t    for_entry_list(qp) {\n\t\tif (qp->nuses) {\n\t\t    (void) fputs(qp->tterm.term_names, stderr);\n\t\t    (void) fputc('\\n', stderr);\n\t\t}\n\t    }\n\t    ExitProgram(EXIT_FAILURE);\n\t}\n\n\theads[filecount] = _nc_head;\n\tfilecount++;\n    }\n\n     \n    if (itrace)\n\t(void) fprintf(stderr, \"Entries are now in core...\\n\");\n\n     \n    for (qp = heads[0]; qp; qp = qp->next) {\n\tfor (rp = heads[1]; rp; rp = rp->next)\n\t    if (_nc_entry_match(qp->tterm.term_names, rp->tterm.term_names)) {\n\t\tif (qp->ncrosslinks < MAX_CROSSLINKS)\n\t\t    qp->crosslinks[qp->ncrosslinks] = rp;\n\t\tqp->ncrosslinks++;\n\n\t\tif (rp->ncrosslinks < MAX_CROSSLINKS)\n\t\t    rp->crosslinks[rp->ncrosslinks] = qp;\n\t\trp->ncrosslinks++;\n\t    }\n    }\n\n     \n    if (itrace)\n\t(void) fprintf(stderr, \"Name matches are done...\\n\");\n\n    for (qp = heads[0]; qp; qp = qp->next) {\n\tif (qp->ncrosslinks > 1) {\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s in file 1 (%s) has %d matches in file 2 (%s):\\n\",\n\t\t\t   _nc_first_name(qp->tterm.term_names),\n\t\t\t   argv[0],\n\t\t\t   qp->ncrosslinks,\n\t\t\t   argv[1]);\n\t    for (i = 0; i < qp->ncrosslinks; i++)\n\t\t(void) fprintf(stderr,\n\t\t\t       \"\\t%s\\n\",\n\t\t\t       _nc_first_name((qp->crosslinks[i])->tterm.term_names));\n\t}\n    }\n\n    for (rp = heads[1]; rp; rp = rp->next) {\n\tif (rp->ncrosslinks > 1) {\n\t    (void) fprintf(stderr,\n\t\t\t   \"%s in file 2 (%s) has %d matches in file 1 (%s):\\n\",\n\t\t\t   _nc_first_name(rp->tterm.term_names),\n\t\t\t   argv[1],\n\t\t\t   rp->ncrosslinks,\n\t\t\t   argv[0]);\n\t    for (i = 0; i < rp->ncrosslinks; i++)\n\t\t(void) fprintf(stderr,\n\t\t\t       \"\\t%s\\n\",\n\t\t\t       _nc_first_name((rp->crosslinks[i])->tterm.term_names));\n\t}\n    }\n\n    (void) printf(\"In file 1 (%s) only:\\n\", argv[0]);\n    for (qp = heads[0]; qp; qp = qp->next)\n\tif (qp->ncrosslinks == 0)\n\t    (void) printf(\"\\t%s\\n\",\n\t\t\t  _nc_first_name(qp->tterm.term_names));\n\n    (void) printf(\"In file 2 (%s) only:\\n\", argv[1]);\n    for (rp = heads[1]; rp; rp = rp->next)\n\tif (rp->ncrosslinks == 0)\n\t    (void) printf(\"\\t%s\\n\",\n\t\t\t  _nc_first_name(rp->tterm.term_names));\n\n    (void) printf(\"The following entries are equivalent:\\n\");\n    for (qp = heads[0]; qp; qp = qp->next) {\n\tif (qp->ncrosslinks == 1) {\n\t    rp = qp->crosslinks[0];\n\n\t    repair_acsc(&qp->tterm);\n\t    repair_acsc(&rp->tterm);\n#if NCURSES_XNAMES\n\t    _nc_align_termtype(&qp->tterm, &rp->tterm);\n#endif\n\t    if (entryeq(&qp->tterm, &rp->tterm) && useeq(qp, rp)) {\n\t\tchar name1[NAMESIZE], name2[NAMESIZE];\n\n\t\tcanonical_name(qp->tterm.term_names, name1);\n\t\tcanonical_name(rp->tterm.term_names, name2);\n\n\t\t(void) printf(\"%s = %s\\n\", name1, name2);\n\t    }\n\t}\n    }\n\n    (void) printf(\"Differing entries:\\n\");\n    termcount = 2;\n    for (qp = heads[0]; qp; qp = qp->next) {\n\n\tif (qp->ncrosslinks == 1) {\n\t    rp = qp->crosslinks[0];\n#if NCURSES_XNAMES\n\t     \n\t    _nc_align_termtype(&qp->tterm, &rp->tterm);\n#endif\n\t    if (!(entryeq(&qp->tterm, &rp->tterm) && useeq(qp, rp))) {\n\t\tchar name1[NAMESIZE], name2[NAMESIZE];\n\t\tchar *names[3];\n\n\t\tnames[0] = name1;\n\t\tnames[1] = name2;\n\t\tnames[2] = 0;\n\n\t\tentries[0] = *qp;\n\t\tentries[1] = *rp;\n\n\t\tcanonical_name(qp->tterm.term_names, name1);\n\t\tcanonical_name(rp->tterm.term_names, name2);\n\n\t\tswitch (compare) {\n\t\tcase C_DIFFERENCE:\n\t\t    show_comparing(names);\n\t\t    compare_entry(compare_predicate, &entries->tterm, quiet);\n\t\t    break;\n\n\t\tcase C_COMMON:\n\t\t    show_comparing(names);\n\t\t    compare_entry(compare_predicate, &entries->tterm, quiet);\n\t\t    break;\n\n\t\tcase C_NAND:\n\t\t    show_comparing(names);\n\t\t    compare_entry(compare_predicate, &entries->tterm, quiet);\n\t\t    break;\n\n\t\t}\n\t    }\n\t}\n    }\n}\n\nstatic void\nusage(void)\n{\n#define DATA(s) s \"\\n\"\n    static const char head[] =\n    {\n\tDATA(\"Usage: infocmp [options] [-A directory] [-B directory] [termname...]\")\n\tDATA(\"\")\n\tDATA(\"Options:\")\n    };\n#undef DATA\n     \n#define DATA(s) s\n    static const char options[][46] =\n    {\n\t\"  -0    print single-row\"\n\t,\"  -1    print single-column\"\n\t,\"  -C    use termcap-names\"\n\t,\"  -D    print database locations\"\n\t,\"  -E    format output as C tables\"\n\t,\"  -F    compare terminfo-files\"\n\t,\"  -G    format %{number} to %'char'\"\n\t,\"  -I    use terminfo-names\"\n\t,\"  -K    use termcap-names and BSD syntax\"\n\t,\"  -L    use long names\"\n\t,\"  -R subset (see manpage)\"\n\t,\"  -T    eliminate size limits (test)\"\n\t,\"  -U    do not post-process entries\"\n\t,\"  -V    print version\"\n\t,\"  -W    wrap long strings per -w[n]\"\n#if NCURSES_XNAMES\n\t,\"  -a    with -F, list commented-out caps\"\n#endif\n\t,\"  -c    list common capabilities\"\n\t,\"  -d    list different capabilities\"\n\t,\"  -e    format output for C initializer\"\n\t,\"  -f    with -1, format complex strings\"\n\t,\"  -g    format %'char' to %{number}\"\n\t,\"  -i    analyze initialization/reset\"\n\t,\"  -l    output terminfo names\"\n\t,\"  -n    list capabilities in neither\"\n\t,\"  -p    ignore padding specifiers\"\n\t,\"  -Q number  dump compiled description\"\n\t,\"  -q    brief listing, removes headers\"\n\t,\"  -r    with -C, output in termcap form\"\n\t,\"  -r    with -F, resolve use-references\"\n\t,\"  -s [d|i|l|c] sort fields\"\n#if NCURSES_XNAMES\n\t,\"  -t    suppress commented-out capabilities\"\n#endif\n\t,\"  -u    produce source with 'use='\"\n\t,\"  -v number  (verbose)\"\n\t,\"  -w number  (width)\"\n#if NCURSES_XNAMES\n\t,\"  -x    unknown capabilities are user-defined\"\n#endif\n    };\n#undef DATA\n    const size_t last = SIZEOF(options);\n    const size_t left = (last + 1) / 2;\n    size_t n;\n\n    fputs(head, stderr);\n    for (n = 0; n < left; n++) {\n\tsize_t m = n + left;\n\tif (m < last)\n\t    fprintf(stderr, \"%-40.40s%s\\n\", options[n], options[m]);\n\telse\n\t    fprintf(stderr, \"%s\\n\", options[n]);\n    }\n    ExitProgram(EXIT_FAILURE);\n}\n\nstatic char *\nany_initializer(const char *fmt, const char *type)\n{\n    static char *initializer;\n    static size_t need;\n    char *s;\n\n    if (initializer == 0) {\n\tneed = (strlen(entries->tterm.term_names)\n\t\t+ strlen(type)\n\t\t+ strlen(fmt));\n\tinitializer = (char *) malloc(need + 1);\n\tif (initializer == 0)\n\t    failed(\"any_initializer\");\n    }\n\n    _nc_STRCPY(initializer, entries->tterm.term_names, need);\n    for (s = initializer; *s != 0 && *s != '|'; s++) {\n\tif (!isalnum(UChar(*s)))\n\t    *s = '_';\n    }\n    *s = 0;\n    _nc_SPRINTF(s, _nc_SLIMIT(need) fmt, type);\n    return initializer;\n}\n\nstatic char *\nname_initializer(const char *type)\n{\n    return any_initializer(\"_%s_data\", type);\n}\n\nstatic char *\nstring_variable(const char *type)\n{\n    return any_initializer(\"_s_%s\", type);\n}\n\n \nstatic void\ndump_initializers(TERMTYPE2 *term)\n{\n    unsigned n;\n    const char *str = 0;\n\n    printf(\"\\nstatic char %s[] = \\\"%s\\\";\\n\\n\",\n\t   name_initializer(\"alias\"), entries->tterm.term_names);\n\n    for_each_string(n, term) {\n\tif (VALID_STRING(term->Strings[n])) {\n\t    char buf[MAX_STRING], *sp, *tp;\n\n\t    tp = buf;\n#define TP_LIMIT\t((MAX_STRING - 5) - (size_t)(tp - buf))\n\t    *tp++ = '\"';\n\t    for (sp = term->Strings[n];\n\t\t *sp != 0 && TP_LIMIT > 2;\n\t\t sp++) {\n\t\tif (isascii(UChar(*sp))\n\t\t    && isprint(UChar(*sp))\n\t\t    && *sp != '\\\\'\n\t\t    && *sp != '\"')\n\t\t    *tp++ = *sp;\n\t\telse {\n\t\t    _nc_SPRINTF(tp, _nc_SLIMIT(TP_LIMIT) \"\\\\%03o\", UChar(*sp));\n\t\t    tp += 4;\n\t\t}\n\t    }\n\t    *tp++ = '\"';\n\t    *tp = '\\0';\n\t    (void) printf(\"static char %-20s[] = %s;\\n\",\n\t\t\t  string_variable(ExtStrname(term, (int) n, strnames)),\n\t\t\t  buf);\n\t}\n    }\n    printf(\"\\n\");\n\n    (void) printf(\"static char %s[] = %s\\n\", name_initializer(\"bool\"), L_CURL);\n\n    for_each_boolean(n, term) {\n\tswitch ((int) (term->Booleans[n])) {\n\tcase TRUE:\n\t    str = \"TRUE\";\n\t    break;\n\n\tcase FALSE:\n\t    str = \"FALSE\";\n\t    break;\n\n\tcase ABSENT_BOOLEAN:\n\t    str = \"ABSENT_BOOLEAN\";\n\t    break;\n\n\tcase CANCELLED_BOOLEAN:\n\t    str = \"CANCELLED_BOOLEAN\";\n\t    break;\n\t}\n\t(void) printf(\"\\t/* %3u: %-8s */\\t%s,\\n\",\n\t\t      n, ExtBoolname(term, (int) n, boolnames), str);\n    }\n    (void) printf(\"%s;\\n\", R_CURL);\n\n    (void) printf(\"static short %s[] = %s\\n\", name_initializer(\"number\"), L_CURL);\n\n    for_each_number(n, term) {\n\tchar buf[BUFSIZ];\n\tswitch (term->Numbers[n]) {\n\tcase ABSENT_NUMERIC:\n\t    str = \"ABSENT_NUMERIC\";\n\t    break;\n\tcase CANCELLED_NUMERIC:\n\t    str = \"CANCELLED_NUMERIC\";\n\t    break;\n\tdefault:\n\t    _nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf)) \"%d\", term->Numbers[n]);\n\t    str = buf;\n\t    break;\n\t}\n\t(void) printf(\"\\t/* %3u: %-8s */\\t%s,\\n\", n,\n\t\t      ExtNumname(term, (int) n, numnames), str);\n    }\n    (void) printf(\"%s;\\n\", R_CURL);\n\n    (void) printf(\"static char * %s[] = %s\\n\", name_initializer(\"string\"), L_CURL);\n\n    for_each_string(n, term) {\n\n\tif (term->Strings[n] == ABSENT_STRING)\n\t    str = \"ABSENT_STRING\";\n\telse if (term->Strings[n] == CANCELLED_STRING)\n\t    str = \"CANCELLED_STRING\";\n\telse {\n\t    str = string_variable(ExtStrname(term, (int) n, strnames));\n\t}\n\t(void) printf(\"\\t/* %3u: %-8s */\\t%s,\\n\", n,\n\t\t      ExtStrname(term, (int) n, strnames), str);\n    }\n    (void) printf(\"%s;\\n\", R_CURL);\n\n#if NCURSES_XNAMES\n    if ((NUM_BOOLEANS(term) != BOOLCOUNT)\n\t|| (NUM_NUMBERS(term) != NUMCOUNT)\n\t|| (NUM_STRINGS(term) != STRCOUNT)) {\n\t(void) printf(\"static char * %s[] = %s\\n\",\n\t\t      name_initializer(\"string_ext\"), L_CURL);\n\tfor (n = BOOLCOUNT; n < NUM_BOOLEANS(term); ++n) {\n\t    (void) printf(\"\\t/* %3u: bool */\\t\\\"%s\\\",\\n\",\n\t\t\t  n, ExtBoolname(term, (int) n, boolnames));\n\t}\n\tfor (n = NUMCOUNT; n < NUM_NUMBERS(term); ++n) {\n\t    (void) printf(\"\\t/* %3u: num */\\t\\\"%s\\\",\\n\",\n\t\t\t  n, ExtNumname(term, (int) n, numnames));\n\t}\n\tfor (n = STRCOUNT; n < NUM_STRINGS(term); ++n) {\n\t    (void) printf(\"\\t/* %3u: str */\\t\\\"%s\\\",\\n\",\n\t\t\t  n, ExtStrname(term, (int) n, strnames));\n\t}\n\t(void) printf(\"%s;\\n\", R_CURL);\n    }\n#endif\n}\n\n \nstatic void\ndump_termtype(TERMTYPE2 *term)\n{\n    (void) printf(\"\\t%s\\n\\t\\t%s,\\n\", L_CURL, name_initializer(\"alias\"));\n    (void) printf(\"\\t\\t(char *)0,\\t/* pointer to string table */\\n\");\n\n    (void) printf(\"\\t\\t%s,\\n\", name_initializer(\"bool\"));\n    (void) printf(\"\\t\\t%s,\\n\", name_initializer(\"number\"));\n\n    (void) printf(\"\\t\\t%s,\\n\", name_initializer(\"string\"));\n\n#if NCURSES_XNAMES\n    (void) printf(\"#if NCURSES_XNAMES\\n\");\n    (void) printf(\"\\t\\t(char *)0,\\t/* pointer to extended string table */\\n\");\n    (void) printf(\"\\t\\t%s,\\t/* ...corresponding names */\\n\",\n\t\t  ((NUM_BOOLEANS(term) != BOOLCOUNT)\n\t\t   || (NUM_NUMBERS(term) != NUMCOUNT)\n\t\t   || (NUM_STRINGS(term) != STRCOUNT))\n\t\t  ? name_initializer(\"string_ext\")\n\t\t  : \"(char **)0\");\n\n    (void) printf(\"\\t\\t%d,\\t\\t/* count total Booleans */\\n\", NUM_BOOLEANS(term));\n    (void) printf(\"\\t\\t%d,\\t\\t/* count total Numbers */\\n\", NUM_NUMBERS(term));\n    (void) printf(\"\\t\\t%d,\\t\\t/* count total Strings */\\n\", NUM_STRINGS(term));\n\n    (void) printf(\"\\t\\t%d,\\t\\t/* count extensions to Booleans */\\n\",\n\t\t  NUM_BOOLEANS(term) - BOOLCOUNT);\n    (void) printf(\"\\t\\t%d,\\t\\t/* count extensions to Numbers */\\n\",\n\t\t  NUM_NUMBERS(term) - NUMCOUNT);\n    (void) printf(\"\\t\\t%d,\\t\\t/* count extensions to Strings */\\n\",\n\t\t  NUM_STRINGS(term) - STRCOUNT);\n\n    (void) printf(\"#endif /* NCURSES_XNAMES */\\n\");\n#else\n    (void) term;\n#endif  \n    (void) printf(\"\\t%s\\n\", R_CURL);\n}\n\nstatic int\noptarg_to_number(void)\n{\n    char *temp = 0;\n    long value = strtol(optarg, &temp, 0);\n\n    if (temp == 0 || temp == optarg || *temp != 0) {\n\tfprintf(stderr, \"Expected a number, not \\\"%s\\\"\\n\", optarg);\n\tExitProgram(EXIT_FAILURE);\n    }\n    return (int) value;\n}\n\nstatic char *\nterminal_env(void)\n{\n    char *terminal;\n\n    if ((terminal = getenv(\"TERM\")) == 0) {\n\t(void) fprintf(stderr,\n\t\t       \"%s: environment variable TERM not set\\n\",\n\t\t       _nc_progname);\n\texit(EXIT_FAILURE);\n    }\n    return terminal;\n}\n\n \nstatic void\nshow_databases(void)\n{\n    DBDIRS state;\n    int offset;\n    const char *path2;\n\n    _nc_first_db(&state, &offset);\n    while ((path2 = _nc_next_db(&state, &offset)) != 0) {\n\tprintf(\"%s\\n\", path2);\n    }\n    _nc_last_db();\n}\n\n \n\n#if NO_LEAKS\n#define MAIN_LEAKS() \\\n    _nc_free_termtype2(&entries[0].tterm); \\\n    _nc_free_termtype2(&entries[1].tterm); \\\n    free(myargv); \\\n    free(tfile); \\\n    free(tname)\n#else\n#define MAIN_LEAKS()\t\t \n#endif\n\nint\nmain(int argc, char *argv[])\n{\n     \n     \n    path *tfile = 0;\n    char **tname = 0;\n    size_t maxterms;\n\n    char **myargv;\n\n    char *firstdir, *restdir;\n    int c;\n    bool formatted = FALSE;\n    bool filecompare = FALSE;\n    int initdump = 0;\n    bool init_analyze = FALSE;\n    bool suppress_untranslatable = FALSE;\n    int quickdump = 0;\n    bool wrap_strings = FALSE;\n\n     \n    restdir = firstdir = 0;\n\n#if NCURSES_XNAMES\n    use_extended_names(FALSE);\n#endif\n    _nc_strict_bsd = 0;\n\n    _nc_progname = _nc_rootname(argv[0]);\n\n     \n    myargv = typeCalloc(char *, (size_t) (argc + 3));\n    if (myargv == 0)\n\tfailed(\"myargv\");\n\n    memcpy(myargv, argv, (sizeof(char *) * (size_t) argc));\n    argv = myargv;\n\n    while ((c = getopt(argc,\n\t\t       argv,\n\t\t       \"01A:aB:CcDdEeFfGgIiKLlnpQ:qR:rs:TtUuVv:Ww:x\")) != -1) {\n\tswitch (c) {\n\tcase '0':\n\t    mwidth = 65535;\n\t    mheight = 1;\n\t    break;\n\n\tcase '1':\n\t    mwidth = 0;\n\t    break;\n\n\tcase 'A':\n\t    firstdir = optarg;\n\t    break;\n\n#if NCURSES_XNAMES\n\tcase 'a':\n\t    _nc_disable_period = TRUE;\n\t    use_extended_names(TRUE);\n\t    break;\n#endif\n\tcase 'B':\n\t    restdir = optarg;\n\t    break;\n\n\tcase 'K':\n\t    _nc_strict_bsd = 1;\n\t     \n\tcase 'C':\n\t    outform = F_TERMCAP;\n\t    tversion = \"BSD\";\n\t    if (sortmode == S_DEFAULT)\n\t\tsortmode = S_TERMCAP;\n\t    break;\n\n\tcase 'D':\n\t    show_databases();\n\t    ExitProgram(EXIT_SUCCESS);\n\t    break;\n\n\tcase 'c':\n\t    compare = C_COMMON;\n\t    break;\n\n\tcase 'd':\n\t    compare = C_DIFFERENCE;\n\t    break;\n\n\tcase 'E':\n\t    initdump |= 2;\n\t    break;\n\n\tcase 'e':\n\t    initdump |= 1;\n\t    break;\n\n\tcase 'F':\n\t    filecompare = TRUE;\n\t    break;\n\n\tcase 'f':\n\t    formatted = TRUE;\n\t    break;\n\n\tcase 'G':\n\t    numbers = 1;\n\t    break;\n\n\tcase 'g':\n\t    numbers = -1;\n\t    break;\n\n\tcase 'I':\n\t    outform = F_TERMINFO;\n\t    if (sortmode == S_DEFAULT)\n\t\tsortmode = S_VARIABLE;\n\t    tversion = 0;\n\t    break;\n\n\tcase 'i':\n\t    init_analyze = TRUE;\n\t    break;\n\n\tcase 'L':\n\t    outform = F_VARIABLE;\n\t    if (sortmode == S_DEFAULT)\n\t\tsortmode = S_VARIABLE;\n\t    break;\n\n\tcase 'l':\n\t    outform = F_TERMINFO;\n\t    break;\n\n\tcase 'n':\n\t    compare = C_NAND;\n\t    break;\n\n\tcase 'p':\n\t    ignorepads = TRUE;\n\t    break;\n\n\tcase 'Q':\n\t    quickdump = optarg_to_number();\n\t    break;\n\n\tcase 'q':\n\t    quiet = TRUE;\n\t    s_absent = \"-\";\n\t    s_cancel = \"@\";\n\t    bool_sep = \", \";\n\t    break;\n\n\tcase 'R':\n\t    tversion = optarg;\n\t    break;\n\n\tcase 'r':\n\t    tversion = 0;\n\t    break;\n\n\tcase 's':\n\t    if (*optarg == 'd')\n\t\tsortmode = S_NOSORT;\n\t    else if (*optarg == 'i')\n\t\tsortmode = S_TERMINFO;\n\t    else if (*optarg == 'l')\n\t\tsortmode = S_VARIABLE;\n\t    else if (*optarg == 'c')\n\t\tsortmode = S_TERMCAP;\n\t    else {\n\t\t(void) fprintf(stderr,\n\t\t\t       \"%s: unknown sort mode\\n\",\n\t\t\t       _nc_progname);\n\t\tExitProgram(EXIT_FAILURE);\n\t    }\n\t    break;\n\n\tcase 'T':\n\t    limited = FALSE;\n\t    break;\n\n#if NCURSES_XNAMES\n\tcase 't':\n\t    _nc_disable_period = FALSE;\n\t    suppress_untranslatable = TRUE;\n\t    break;\n#endif\n\n\tcase 'U':\n\t    literal = TRUE;\n\t    break;\n\n\tcase 'u':\n\t    compare = C_USEALL;\n\t    break;\n\n\tcase 'V':\n\t    puts(curses_version());\n\t    ExitProgram(EXIT_SUCCESS);\n\n\tcase 'v':\n\t    itrace = (unsigned) optarg_to_number();\n\t    use_verbosity(itrace);\n\t    break;\n\n\tcase 'W':\n\t    wrap_strings = TRUE;\n\t    break;\n\n\tcase 'w':\n\t    mwidth = optarg_to_number();\n\t    break;\n\n#if NCURSES_XNAMES\n\tcase 'x':\n\t    use_extended_names(TRUE);\n\t    break;\n#endif\n\n\tdefault:\n\t    usage();\n\t}\n    }\n\n    maxterms = (size_t) (argc + 2 - optind);\n    if ((tfile = typeMalloc(path, maxterms)) == 0)\n\tfailed(\"tfile\");\n    if ((tname = typeCalloc(char *, maxterms)) == 0)\n\t  failed(\"tname\");\n    if ((entries = typeCalloc(ENTRY, maxterms)) == 0)\n\tfailed(\"entries\");\n#if NO_LEAKS\n    if ((entered = typeCalloc(ENTERED, maxterms)) == 0)\n\tfailed(\"entered\");\n#endif\n\n    if (tfile == 0\n\t|| tname == 0\n\t|| entries == 0) {\n\tfprintf(stderr, \"%s: not enough memory\\n\", _nc_progname);\n\tExitProgram(EXIT_FAILURE);\n    }\n\n     \n    if (sortmode == S_DEFAULT)\n\tsortmode = S_TERMINFO;\n\n     \n    if (optind >= argc)\n\targv[argc++] = terminal_env();\n\n     \n    if (compare != C_DEFAULT && optind >= argc - 1)\n\targv[argc++] = terminal_env();\n\n     \n     \n    if (compare == C_DEFAULT) {\n\tswitch (argc - optind) {\n\tdefault:\n\t    fprintf(stderr, \"%s: too many names to compare\\n\", _nc_progname);\n\t    ExitProgram(EXIT_FAILURE);\n\tcase 1:\n\t    break;\n\tcase 2:\n\t    compare = C_DIFFERENCE;\n\t    break;\n\t}\n    }\n\n     \n    dump_init(tversion, outform, sortmode,\n\t      wrap_strings, mwidth, mheight, itrace,\n\t      formatted, FALSE, quickdump);\n\n    if (!filecompare) {\n\t \n\ttermcount = 0;\n\tfor (; optind < argc; optind++) {\n\t    const char *directory = termcount ? restdir : firstdir;\n\t    int status;\n\n\t    tname[termcount] = argv[optind];\n\n\t    if (directory) {\n#if NCURSES_USE_DATABASE\n#if MIXEDCASE_FILENAMES\n#define LEAF_FMT \"%c\"\n#else\n#define LEAF_FMT \"%02x\"\n#endif\n\t\t_nc_SPRINTF(tfile[termcount],\n\t\t\t    _nc_SLIMIT(sizeof(path))\n\t\t\t    \"%s/\" LEAF_FMT \"/%s\",\n\t\t\t    directory,\n\t\t\t    UChar(*argv[optind]), argv[optind]);\n\t\tif (itrace)\n\t\t    (void) fprintf(stderr,\n\t\t\t\t   \"%s: reading entry %s from file %s\\n\",\n\t\t\t\t   _nc_progname,\n\t\t\t\t   argv[optind], tfile[termcount]);\n\n\t\tstatus = _nc_read_file_entry(tfile[termcount],\n\t\t\t\t\t     &entries[termcount].tterm);\n#else\n\t\t(void) fprintf(stderr, \"%s: terminfo files not supported\\n\",\n\t\t\t       _nc_progname);\n\t\tMAIN_LEAKS();\n\t\tExitProgram(EXIT_FAILURE);\n#endif\n\t    } else {\n\t\tif (itrace)\n\t\t    (void) fprintf(stderr,\n\t\t\t\t   \"%s: reading entry %s from database\\n\",\n\t\t\t\t   _nc_progname,\n\t\t\t\t   tname[termcount]);\n\n\t\tstatus = _nc_read_entry2(tname[termcount],\n\t\t\t\t\t tfile[termcount],\n\t\t\t\t\t &entries[termcount].tterm);\n\t    }\n\n\t    if (status <= 0) {\n\t\t(void) fprintf(stderr,\n\t\t\t       \"%s: couldn't open terminfo file %s.\\n\",\n\t\t\t       _nc_progname,\n\t\t\t       tfile[termcount]);\n\t\tMAIN_LEAKS();\n\t\tExitProgram(EXIT_FAILURE);\n\t    }\n\t    repair_acsc(&entries[termcount].tterm);\n\t    termcount++;\n\t}\n\n#if NCURSES_XNAMES\n\tif (termcount > 1)\n\t    _nc_align_termtype(&entries[0].tterm, &entries[1].tterm);\n#endif\n\n\t \n\tif (initdump) {\n\t    if (initdump & 1)\n\t\tdump_termtype(&entries[0].tterm);\n\t    if (initdump & 2)\n\t\tdump_initializers(&entries[0].tterm);\n\t}\n\n\t \n\telse if (init_analyze) {\n#undef CUR\n#define CUR\tentries[0].tterm.\n\t    analyze_string(\"is1\", init_1string, &entries[0].tterm);\n\t    analyze_string(\"is2\", init_2string, &entries[0].tterm);\n\t    analyze_string(\"is3\", init_3string, &entries[0].tterm);\n\t    analyze_string(\"rs1\", reset_1string, &entries[0].tterm);\n\t    analyze_string(\"rs2\", reset_2string, &entries[0].tterm);\n\t    analyze_string(\"rs3\", reset_3string, &entries[0].tterm);\n\t    analyze_string(\"smcup\", enter_ca_mode, &entries[0].tterm);\n\t    analyze_string(\"rmcup\", exit_ca_mode, &entries[0].tterm);\n\t    analyze_string(\"smkx\", keypad_xmit, &entries[0].tterm);\n\t    analyze_string(\"rmkx\", keypad_local, &entries[0].tterm);\n#undef CUR\n\t} else {\n\t    int i;\n\t    int len;\n\n\t     \n\t    switch (compare) {\n\t    case C_DEFAULT:\n\t\tif (itrace)\n\t\t    (void) fprintf(stderr,\n\t\t\t\t   \"%s: about to dump %s\\n\",\n\t\t\t\t   _nc_progname,\n\t\t\t\t   tname[0]);\n\t\tif (!quiet)\n\t\t    (void)\n\t\t\tprintf(\"#\\tReconstructed via infocmp from file: %s\\n\",\n\t\t\t       tfile[0]);\n\t\tdump_entry(&entries[0].tterm,\n\t\t\t   suppress_untranslatable,\n\t\t\t   limited,\n\t\t\t   numbers,\n\t\t\t   NULL);\n\t\tlen = show_entry();\n\t\tif (itrace)\n\t\t    (void) fprintf(stderr, \"%s: length %d\\n\", _nc_progname, len);\n\t\tbreak;\n\n\t    case C_DIFFERENCE:\n\t\tshow_comparing(tname);\n\t\tcompare_entry(compare_predicate, &entries->tterm, quiet);\n\t\tbreak;\n\n\t    case C_COMMON:\n\t\tshow_comparing(tname);\n\t\tcompare_entry(compare_predicate, &entries->tterm, quiet);\n\t\tbreak;\n\n\t    case C_NAND:\n\t\tshow_comparing(tname);\n\t\tcompare_entry(compare_predicate, &entries->tterm, quiet);\n\t\tbreak;\n\n\t    case C_USEALL:\n\t\tif (itrace)\n\t\t    (void) fprintf(stderr, \"%s: dumping use entry\\n\", _nc_progname);\n\t\tdump_entry(&entries[0].tterm,\n\t\t\t   suppress_untranslatable,\n\t\t\t   limited,\n\t\t\t   numbers,\n\t\t\t   use_predicate);\n\t\tfor (i = 1; i < termcount; i++)\n\t\t    dump_uses(tname[i], !(outform == F_TERMCAP\n\t\t\t\t\t  || outform == F_TCONVERR));\n\t\tlen = show_entry();\n\t\tif (itrace)\n\t\t    (void) fprintf(stderr, \"%s: length %d\\n\", _nc_progname, len);\n\t\tbreak;\n\t    }\n\t}\n    } else if (compare == C_USEALL) {\n\t(void) fprintf(stderr, \"Sorry, -u doesn't work with -F\\n\");\n    } else if (compare == C_DEFAULT) {\n\t(void) fprintf(stderr, \"Use `tic -[CI] <file>' for this.\\n\");\n    } else if (argc - optind != 2) {\n\t(void) fprintf(stderr,\n\t\t       \"File comparison needs exactly two file arguments.\\n\");\n    } else {\n\tfile_comparison(argc - optind, argv + optind);\n    }\n\n    MAIN_LEAKS();\n    ExitProgram(EXIT_SUCCESS);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}