{
  "module_name": "reset_cmd.c",
  "hash_id": "153d441b93887929f1150a0dbd52d64b1b8e0a9625c06be1f461c4c59dc3a0be",
  "original_prompt": "Ingested from ncurses-6.4/progs/reset_cmd.c",
  "human_readable_source": " \n\n \n\n#include <reset_cmd.h>\n#include <tty_settings.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <fcntl.h>\n\n#if HAVE_SIZECHANGE\n# if !defined(sun) || !TERMIOS\n#  if HAVE_SYS_IOCTL_H\n#   include <sys/ioctl.h>\n#  endif\n# endif\n#endif\n\n#if NEED_PTEM_H\n \n#include <sys/stream.h>\n#include <sys/ptem.h>\n#endif\n\nMODULE_ID(\"$Id: reset_cmd.c,v 1.28 2021/10/02 18:08:44 tom Exp $\")\n\n \n#ifdef TIOCGSIZE\n# define IOCTL_GET_WINSIZE TIOCGSIZE\n# define IOCTL_SET_WINSIZE TIOCSSIZE\n# define STRUCT_WINSIZE struct ttysize\n# define WINSIZE_ROWS(n) n.ts_lines\n# define WINSIZE_COLS(n) n.ts_cols\n#else\n# ifdef TIOCGWINSZ\n#  define IOCTL_GET_WINSIZE TIOCGWINSZ\n#  define IOCTL_SET_WINSIZE TIOCSWINSZ\n#  define STRUCT_WINSIZE struct winsize\n#  define WINSIZE_ROWS(n) n.ws_row\n#  define WINSIZE_COLS(n) n.ws_col\n# endif\n#endif\n\nstatic FILE *my_file;\n\nstatic bool use_reset = FALSE;\t \nstatic bool use_init = FALSE;\t \n\nstatic GCC_NORETURN void\nfailed(const char *msg)\n{\n    int code = errno;\n\n    (void) fprintf(stderr, \"%s: %s: %s\\n\", _nc_progname, msg, strerror(code));\n    restore_tty_settings();\n    (void) fprintf(my_file, \"\\n\");\n    fflush(my_file);\n    ExitProgram(ErrSystem(code));\n     \n}\n\nstatic bool\ncat_file(char *file)\n{\n    FILE *fp;\n    size_t nr;\n    char buf[BUFSIZ];\n    bool sent = FALSE;\n\n    if (file != 0) {\n\tif ((fp = safe_fopen(file, \"r\")) == 0)\n\t    failed(file);\n\n\twhile ((nr = fread(buf, sizeof(char), sizeof(buf), fp)) != 0) {\n\t    if (fwrite(buf, sizeof(char), nr, my_file) != nr) {\n\t\tfailed(file);\n\t    }\n\t    sent = TRUE;\n\t}\n\tfclose(fp);\n    }\n    return sent;\n}\n\nstatic int\nout_char(int c)\n{\n    return putc(c, my_file);\n}\n\n \n\n \n#if !(defined(CERASE) && defined(CINTR) && defined(CKILL) && defined(CQUIT))\n#undef CEOF\n#undef CERASE\n#undef CINTR\n#undef CKILL\n#undef CLNEXT\n#undef CRPRNT\n#undef CQUIT\n#undef CSTART\n#undef CSTOP\n#undef CSUSP\n#endif\n\n \n#ifndef CEOF\n#define CEOF\tCTRL('D')\n#endif\n#ifndef CERASE\n#define CERASE\tCTRL('H')\n#endif\n#ifndef CINTR\n#define CINTR\t127\t\t \n#endif\n#ifndef CKILL\n#define CKILL\tCTRL('U')\n#endif\n#ifndef CLNEXT\n#define CLNEXT  CTRL('v')\n#endif\n#ifndef CRPRNT\n#define CRPRNT  CTRL('r')\n#endif\n#ifndef CQUIT\n#define CQUIT\tCTRL('\\\\')\n#endif\n#ifndef CSTART\n#define CSTART\tCTRL('Q')\n#endif\n#ifndef CSTOP\n#define CSTOP\tCTRL('S')\n#endif\n#ifndef CSUSP\n#define CSUSP\tCTRL('Z')\n#endif\n\n#if defined(_POSIX_VDISABLE)\n#define DISABLED(val)   (((_POSIX_VDISABLE != -1) \\\n\t\t       && ((val) == _POSIX_VDISABLE)) \\\n\t\t      || ((val) <= 0))\n#else\n#define DISABLED(val)   ((int)(val) <= 0)\n#endif\n\n#define CHK(val, dft)   (unsigned char) (DISABLED(val) ? dft : val)\n\n#define reset_char(item, value) \\\n    tty_settings->c_cc[item] = CHK(tty_settings->c_cc[item], value)\n\n \nvoid\nreset_tty_settings(int fd, TTY * tty_settings, int noset)\n{\n    GET_TTY(fd, tty_settings);\n\n#ifdef TERMIOS\n#if defined(VDISCARD) && defined(CDISCARD)\n    reset_char(VDISCARD, CDISCARD);\n#endif\n    reset_char(VEOF, CEOF);\n    reset_char(VERASE, CERASE);\n#if defined(VFLUSH) && defined(CFLUSH)\n    reset_char(VFLUSH, CFLUSH);\n#endif\n    reset_char(VINTR, CINTR);\n    reset_char(VKILL, CKILL);\n#if defined(VLNEXT) && defined(CLNEXT)\n    reset_char(VLNEXT, CLNEXT);\n#endif\n    reset_char(VQUIT, CQUIT);\n#if defined(VREPRINT) && defined(CRPRNT)\n    reset_char(VREPRINT, CRPRNT);\n#endif\n#if defined(VSTART) && defined(CSTART)\n    reset_char(VSTART, CSTART);\n#endif\n#if defined(VSTOP) && defined(CSTOP)\n    reset_char(VSTOP, CSTOP);\n#endif\n#if defined(VSUSP) && defined(CSUSP)\n    reset_char(VSUSP, CSUSP);\n#endif\n#if defined(VWERASE) && defined(CWERASE)\n    reset_char(VWERASE, CWERASE);\n#endif\n\n    tty_settings->c_iflag &= ~((unsigned) (IGNBRK\n\t\t\t\t\t   | PARMRK\n\t\t\t\t\t   | INPCK\n\t\t\t\t\t   | ISTRIP\n\t\t\t\t\t   | INLCR\n\t\t\t\t\t   | IGNCR\n#ifdef IUCLC\n\t\t\t\t\t   | IUCLC\n#endif\n#ifdef IXANY\n\t\t\t\t\t   | IXANY\n#endif\n\t\t\t\t\t   | IXOFF));\n\n    tty_settings->c_iflag |= (BRKINT\n\t\t\t      | IGNPAR\n\t\t\t      | ICRNL\n\t\t\t      | IXON\n#ifdef IMAXBEL\n\t\t\t      | IMAXBEL\n#endif\n\t);\n\n    tty_settings->c_oflag &= ~((unsigned) (0\n#ifdef OLCUC\n\t\t\t\t\t   | OLCUC\n#endif\n#ifdef OCRNL\n\t\t\t\t\t   | OCRNL\n#endif\n#ifdef ONOCR\n\t\t\t\t\t   | ONOCR\n#endif\n#ifdef ONLRET\n\t\t\t\t\t   | ONLRET\n#endif\n#ifdef OFILL\n\t\t\t\t\t   | OFILL\n#endif\n#ifdef OFDEL\n\t\t\t\t\t   | OFDEL\n#endif\n#ifdef NLDLY\n\t\t\t\t\t   | NLDLY\n#endif\n#ifdef CRDLY\n\t\t\t\t\t   | CRDLY\n#endif\n#ifdef TABDLY\n\t\t\t\t\t   | TABDLY\n#endif\n#ifdef BSDLY\n\t\t\t\t\t   | BSDLY\n#endif\n#ifdef VTDLY\n\t\t\t\t\t   | VTDLY\n#endif\n#ifdef FFDLY\n\t\t\t\t\t   | FFDLY\n#endif\n\t\t\t       ));\n\n    tty_settings->c_oflag |= (OPOST\n#ifdef ONLCR\n\t\t\t      | ONLCR\n#endif\n\t);\n\n    tty_settings->c_cflag &= ~((unsigned) (CSIZE\n\t\t\t\t\t   | CSTOPB\n\t\t\t\t\t   | PARENB\n\t\t\t\t\t   | PARODD\n\t\t\t\t\t   | CLOCAL));\n    tty_settings->c_cflag |= (CS8 | CREAD);\n    tty_settings->c_lflag &= ~((unsigned) (ECHONL\n\t\t\t\t\t   | NOFLSH\n#ifdef TOSTOP\n\t\t\t\t\t   | TOSTOP\n#endif\n#ifdef ECHOPTR\n\t\t\t\t\t   | ECHOPRT\n#endif\n#ifdef XCASE\n\t\t\t\t\t   | XCASE\n#endif\n\t\t\t       ));\n\n    tty_settings->c_lflag |= (ISIG\n\t\t\t      | ICANON\n\t\t\t      | ECHO\n\t\t\t      | ECHOE\n\t\t\t      | ECHOK\n#ifdef ECHOCTL\n\t\t\t      | ECHOCTL\n#endif\n#ifdef ECHOKE\n\t\t\t      | ECHOKE\n#endif\n\t);\n#endif\n\n    if (!noset) {\n\tSET_TTY(fd, tty_settings);\n    }\n}\n\n \nstatic int\ndefault_erase(void)\n{\n    int result;\n\n    if (over_strike\n\t&& VALID_STRING(key_backspace)\n\t&& strlen(key_backspace) == 1) {\n\tresult = key_backspace[0];\n    } else {\n\tresult = CERASE;\n    }\n\n    return result;\n}\n\n \nvoid\nset_control_chars(TTY * tty_settings, int my_erase, int my_intr, int my_kill)\n{\n#if defined(EXP_WIN32_DRIVER)\n     \n    (void) tty_settings;\n    (void) my_erase;\n    (void) my_intr;\n    (void) my_kill;\n#else\n    if (DISABLED(tty_settings->c_cc[VERASE]) || my_erase >= 0) {\n\ttty_settings->c_cc[VERASE] = UChar((my_erase >= 0)\n\t\t\t\t\t   ? my_erase\n\t\t\t\t\t   : default_erase());\n    }\n\n    if (DISABLED(tty_settings->c_cc[VINTR]) || my_intr >= 0) {\n\ttty_settings->c_cc[VINTR] = UChar((my_intr >= 0)\n\t\t\t\t\t  ? my_intr\n\t\t\t\t\t  : CINTR);\n    }\n\n    if (DISABLED(tty_settings->c_cc[VKILL]) || my_kill >= 0) {\n\ttty_settings->c_cc[VKILL] = UChar((my_kill >= 0)\n\t\t\t\t\t  ? my_kill\n\t\t\t\t\t  : CKILL);\n    }\n#endif\n}\n\n \nvoid\nset_conversions(TTY * tty_settings)\n{\n#if defined(EXP_WIN32_DRIVER)\n     \n#else\n#ifdef ONLCR\n    tty_settings->c_oflag |= ONLCR;\n#endif\n    tty_settings->c_iflag |= ICRNL;\n    tty_settings->c_lflag |= ECHO;\n#ifdef OXTABS\n    tty_settings->c_oflag |= OXTABS;\n#endif  \n\n     \n    if (VALID_STRING(newline) && newline[0] == '\\n' && !newline[1]) {\n\t \n#ifdef ONLCR\n\ttty_settings->c_oflag &= ~((unsigned) ONLCR);\n#endif\n\ttty_settings->c_iflag &= ~((unsigned) ICRNL);\n    }\n#ifdef OXTABS\n     \n    if (VALID_STRING(set_tab) && VALID_STRING(clear_all_tabs))\n\ttty_settings->c_oflag &= ~OXTABS;\n#endif  \n    tty_settings->c_lflag |= (ECHOE | ECHOK);\n#endif\n}\n\nstatic bool\nsent_string(const char *s)\n{\n    bool sent = FALSE;\n    if (VALID_STRING(s)) {\n\ttputs(s, 0, out_char);\n\tsent = TRUE;\n    }\n    return sent;\n}\n\nstatic bool\nto_left_margin(void)\n{\n    if (VALID_STRING(carriage_return)) {\n\tsent_string(carriage_return);\n    } else {\n\tout_char('\\r');\n    }\n    return TRUE;\n}\n\n \nstatic bool\nreset_tabstops(int wide)\n{\n    if ((init_tabs != 8)\n\t&& VALID_NUMERIC(init_tabs)\n\t&& VALID_STRING(set_tab)\n\t&& VALID_STRING(clear_all_tabs)) {\n\tint c;\n\n\tto_left_margin();\n\ttputs(clear_all_tabs, 0, out_char);\n\tif (init_tabs > 1) {\n\t    if (init_tabs > wide)\n\t\tinit_tabs = (short) wide;\n\t    for (c = init_tabs; c < wide; c += init_tabs) {\n\t\tfprintf(my_file, \"%*s\", init_tabs, \" \");\n\t\ttputs(set_tab, 0, out_char);\n\t    }\n\t    to_left_margin();\n\t}\n\treturn (TRUE);\n    }\n    return (FALSE);\n}\n\n \nbool\nsend_init_strings(int fd GCC_UNUSED, TTY * old_settings)\n{\n    int i;\n    bool need_flush = FALSE;\n\n    (void) old_settings;\n#ifdef TAB3\n    if (old_settings != 0 &&\n\told_settings->c_oflag & (TAB3 | ONLCR | OCRNL | ONLRET)) {\n\told_settings->c_oflag &= (TAB3 | ONLCR | OCRNL | ONLRET);\n\tSET_TTY(fd, old_settings);\n    }\n#endif\n    if (use_reset || use_init) {\n\tif (VALID_STRING(init_prog)) {\n\t    IGNORE_RC(system(init_prog));\n\t}\n\n\tneed_flush |= sent_string((use_reset && (reset_1string != 0))\n\t\t\t\t  ? reset_1string\n\t\t\t\t  : init_1string);\n\n\tneed_flush |= sent_string((use_reset && (reset_2string != 0))\n\t\t\t\t  ? reset_2string\n\t\t\t\t  : init_2string);\n\n\tif (VALID_STRING(clear_margins)) {\n\t    need_flush |= sent_string(clear_margins);\n\t} else\n#if defined(set_lr_margin)\n\tif (VALID_STRING(set_lr_margin)) {\n\t    need_flush |= sent_string(TIPARM_2(set_lr_margin, 0, columns - 1));\n\t} else\n#endif\n#if defined(set_left_margin_parm) && defined(set_right_margin_parm)\n\t    if (VALID_STRING(set_left_margin_parm)\n\t\t&& VALID_STRING(set_right_margin_parm)) {\n\t    need_flush |= sent_string(TIPARM_1(set_left_margin_parm, 0));\n\t    need_flush |= sent_string(TIPARM_1(set_right_margin_parm,\n\t\t\t\t\t       columns - 1));\n\t} else\n#endif\n\t    if (VALID_STRING(set_left_margin)\n\t\t&& VALID_STRING(set_right_margin)) {\n\t    need_flush |= to_left_margin();\n\t    need_flush |= sent_string(set_left_margin);\n\t    if (VALID_STRING(parm_right_cursor)) {\n\t\tneed_flush |= sent_string(TIPARM_1(parm_right_cursor,\n\t\t\t\t\t\t   columns - 1));\n\t    } else {\n\t\tfor (i = 0; i < columns - 1; i++) {\n\t\t    out_char(' ');\n\t\t    need_flush = TRUE;\n\t\t}\n\t    }\n\t    need_flush |= sent_string(set_right_margin);\n\t    need_flush |= to_left_margin();\n\t}\n\n\tneed_flush |= reset_tabstops(columns);\n\n\tneed_flush |= cat_file((use_reset && reset_file) ? reset_file : init_file);\n\n\tneed_flush |= sent_string((use_reset && (reset_3string != 0))\n\t\t\t\t  ? reset_3string\n\t\t\t\t  : init_3string);\n    }\n\n    return need_flush;\n}\n\n \nstatic void\nshow_tty_change(TTY * old_settings,\n\t\tTTY * new_settings,\n\t\tconst char *name,\n\t\tint which,\n\t\tunsigned def)\n{\n    unsigned older = 0, newer = 0;\n    char *p;\n\n#if defined(EXP_WIN32_DRIVER)\n     \n    (void) old_settings;\n    (void) new_settings;\n    (void) name;\n    (void) which;\n    (void) def;\n#else\n    newer = new_settings->c_cc[which];\n    older = old_settings->c_cc[which];\n\n    if (older == newer && older == def)\n\treturn;\n#endif\n    (void) fprintf(stderr, \"%s %s \", name, older == newer ? \"is\" : \"set to\");\n\n    if (DISABLED(newer)) {\n\t(void) fprintf(stderr, \"undef.\\n\");\n\t \n    } else if (newer == 0177) {\n\t(void) fprintf(stderr, \"delete.\\n\");\n    } else if ((p = key_backspace) != 0\n\t       && newer == (unsigned char) p[0]\n\t       && p[1] == '\\0') {\n\t(void) fprintf(stderr, \"backspace.\\n\");\n    } else if (newer < 040) {\n\tnewer ^= 0100;\n\t(void) fprintf(stderr, \"control-%c (^%c).\\n\", UChar(newer), UChar(newer));\n    } else\n\t(void) fprintf(stderr, \"%c.\\n\", UChar(newer));\n}\n\n \n\nvoid\nreset_start(FILE *fp, bool is_reset, bool is_init)\n{\n    my_file = fp;\n    use_reset = is_reset;\n    use_init = is_init;\n}\n\nvoid\nreset_flush(void)\n{\n    if (my_file != 0)\n\tfflush(my_file);\n}\n\nvoid\nprint_tty_chars(TTY * old_settings, TTY * new_settings)\n{\n#if defined(EXP_WIN32_DRIVER)\n     \n#else\n    show_tty_change(old_settings, new_settings, \"Erase\", VERASE, CERASE);\n    show_tty_change(old_settings, new_settings, \"Kill\", VKILL, CKILL);\n    show_tty_change(old_settings, new_settings, \"Interrupt\", VINTR, CINTR);\n#endif\n}\n\n#if HAVE_SIZECHANGE\n \nvoid\nset_window_size(int fd, short *high, short *wide)\n{\n    STRUCT_WINSIZE win;\n    (void) ioctl(fd, IOCTL_GET_WINSIZE, &win);\n    if (WINSIZE_ROWS(win) == 0 &&\n\tWINSIZE_COLS(win) == 0) {\n\tif (*high > 0 && *wide > 0) {\n\t    WINSIZE_ROWS(win) = (unsigned short) *high;\n\t    WINSIZE_COLS(win) = (unsigned short) *wide;\n\t    (void) ioctl(fd, IOCTL_SET_WINSIZE, &win);\n\t}\n    } else if (WINSIZE_ROWS(win) > 0 &&\n\t       WINSIZE_COLS(win) > 0) {\n\t*high = (short) WINSIZE_ROWS(win);\n\t*wide = (short) WINSIZE_COLS(win);\n    }\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}