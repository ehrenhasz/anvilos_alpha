{
  "module_name": "m_driver.c",
  "hash_id": "972d0d19d148443fdbad4ff3005dbd5fdd1aaad08992fbfc7734976fdcabd196",
  "original_prompt": "Ingested from ncurses-6.4/menu/m_driver.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"menu.priv.h\"\n\nMODULE_ID(\"$Id: m_driver.c,v 1.37 2021/03/27 23:46:29 tom Exp $\")\n\n \n\n \n#define Remove_Character_From_Pattern(menu) \\\n  (menu)->pattern[--((menu)->pindex)] = '\\0'\n\n \n#define Add_Character_To_Pattern(menu,ch) \\\n  { (menu)->pattern[((menu)->pindex)++] = (char) (ch);\\\n    (menu)->pattern[(menu)->pindex] = '\\0'; }\n\n \nstatic bool\nIs_Sub_String(\n\t       bool IgnoreCaseFlag,\n\t       const char *part,\n\t       const char *string\n)\n{\n  assert(part && string);\n  if (IgnoreCaseFlag)\n    {\n      while (*string && *part)\n\t{\n\t  if (toupper(UChar(*string++)) != toupper(UChar(*part)))\n\t    break;\n\t  part++;\n\t}\n    }\n  else\n    {\n      while (*string && *part)\n\tif (*part != *string++)\n\t  break;\n      part++;\n    }\n  return ((*part) ? FALSE : TRUE);\n}\n\n \nMENU_EXPORT(int)\n_nc_Match_Next_Character_In_Item_Name\n(MENU *menu, int ch, ITEM **item)\n{\n  bool found = FALSE, passed = FALSE;\n  int idx, last;\n\n  T((T_CALLED(\"_nc_Match_Next_Character(%p,%d,%p)\"),\n     (void *)menu, ch, (void *)item));\n\n  assert(menu && item && *item);\n  idx = (*item)->index;\n\n  if (ch && ch != BS)\n    {\n       \n      if ((menu->pindex + 1) > menu->namelen)\n\tRETURN(E_NO_MATCH);\n\n      Add_Character_To_Pattern(menu, ch);\n       \n      if (--idx < 0)\n\tidx = menu->nitems - 1;\n    }\n\n  last = idx;\t\t\t \n\n  do\n    {\n      if (ch == BS)\n\t{\t\t\t \n\t  if (--idx < 0)\n\t    idx = menu->nitems - 1;\n\t}\n      else\n\t{\t\t\t \n\t  if (++idx >= menu->nitems)\n\t    idx = 0;\n\t}\n      if (Is_Sub_String((bool)((menu->opt & O_IGNORECASE) != 0),\n\t\t\tmenu->pattern,\n\t\t\tmenu->items[idx]->name.str)\n\t)\n\tfound = TRUE;\n      else\n\tpassed = TRUE;\n    }\n  while (!found && (idx != last));\n\n  if (found)\n    {\n      if (!((idx == (*item)->index) && passed))\n\t{\n\t  *item = menu->items[idx];\n\t  RETURN(E_OK);\n\t}\n       \n      assert(ch == 0 || ch == BS);\n    }\n  else\n    {\n      if (ch && ch != BS && menu->pindex > 0)\n\t{\n\t   \n\t  Remove_Character_From_Pattern(menu);\n\t}\n    }\n  RETURN(E_NO_MATCH);\n}\n\n \nMENU_EXPORT(int)\nmenu_driver(MENU *menu, int c)\n{\n#define NAVIGATE(dir) \\\n  if (!item->dir)\\\n     result = E_REQUEST_DENIED;\\\n  else\\\n     item = item->dir\n\n  int result = E_OK;\n  ITEM *item;\n  int my_top_row;\n\n  T((T_CALLED(\"menu_driver(%p,%d)\"), (void *)menu, c));\n\n  if (!menu)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (menu->status & _IN_DRIVER)\n    RETURN(E_BAD_STATE);\n  if (!(menu->status & _POSTED))\n    RETURN(E_NOT_POSTED);\n\n  item = menu->curitem;\n\n  my_top_row = menu->toprow;\n  assert(item);\n\n  if ((c > KEY_MAX) && (c <= MAX_MENU_COMMAND))\n    {\n      int rdiff;\n\n      if (!((c == REQ_BACK_PATTERN)\n\t    || (c == REQ_NEXT_MATCH) || (c == REQ_PREV_MATCH)))\n\t{\n\t  assert(menu->pattern);\n\t  Reset_Pattern(menu);\n\t}\n\n      switch (c)\n\t{\n\tcase REQ_LEFT_ITEM:\n\t     \n\t  NAVIGATE(left);\n\t  break;\n\n\tcase REQ_RIGHT_ITEM:\n\t     \n\t  NAVIGATE(right);\n\t  break;\n\n\tcase REQ_UP_ITEM:\n\t     \n\t  NAVIGATE(up);\n\t  break;\n\n\tcase REQ_DOWN_ITEM:\n\t     \n\t  NAVIGATE(down);\n\t  break;\n\n\tcase REQ_SCR_ULINE:\n\t     \n\t  if (my_top_row == 0 || !(item->up))\n\t    result = E_REQUEST_DENIED;\n\t  else\n\t    {\n\t      --my_top_row;\n\t      item = item->up;\n\t    }\n\t  break;\n\n\tcase REQ_SCR_DLINE:\n\t     \n\t  if ((my_top_row + menu->arows >= menu->rows) || !(item->down))\n\t    {\n\t       \n\t      result = E_REQUEST_DENIED;\n\t    }\n\t  else\n\t    {\n\t      my_top_row++;\n\t      item = item->down;\n\t    }\n\t  break;\n\n\tcase REQ_SCR_DPAGE:\n\t     \n\t  rdiff = menu->rows - (menu->arows + my_top_row);\n\t  if (rdiff > menu->arows)\n\t    rdiff = menu->arows;\n\t  if (rdiff <= 0)\n\t    result = E_REQUEST_DENIED;\n\t  else\n\t    {\n\t      my_top_row += rdiff;\n\t      while (rdiff-- > 0 && item != 0 && item->down != 0)\n\t\titem = item->down;\n\t    }\n\t  break;\n\n\tcase REQ_SCR_UPAGE:\n\t     \n\t  rdiff = (menu->arows < my_top_row) ? menu->arows : my_top_row;\n\t  if (rdiff <= 0)\n\t    result = E_REQUEST_DENIED;\n\t  else\n\t    {\n\t      my_top_row -= rdiff;\n\t      while (rdiff-- > 0 && item != 0 && item->up != 0)\n\t\titem = item->up;\n\t    }\n\t  break;\n\n\tcase REQ_FIRST_ITEM:\n\t     \n\t  item = menu->items[0];\n\t  break;\n\n\tcase REQ_LAST_ITEM:\n\t     \n\t  item = menu->items[menu->nitems - 1];\n\t  break;\n\n\tcase REQ_NEXT_ITEM:\n\t     \n\t  if ((item->index + 1) >= menu->nitems)\n\t    {\n\t      if (menu->opt & O_NONCYCLIC)\n\t\tresult = E_REQUEST_DENIED;\n\t      else\n\t\titem = menu->items[0];\n\t    }\n\t  else\n\t    item = menu->items[item->index + 1];\n\t  break;\n\n\tcase REQ_PREV_ITEM:\n\t     \n\t  if (item->index <= 0)\n\t    {\n\t      if (menu->opt & O_NONCYCLIC)\n\t\tresult = E_REQUEST_DENIED;\n\t      else\n\t\titem = menu->items[menu->nitems - 1];\n\t    }\n\t  else\n\t    item = menu->items[item->index - 1];\n\t  break;\n\n\tcase REQ_TOGGLE_ITEM:\n\t     \n\t  if (menu->opt & O_ONEVALUE)\n\t    {\n\t      result = E_REQUEST_DENIED;\n\t    }\n\t  else\n\t    {\n\t      if (menu->curitem->opt & O_SELECTABLE)\n\t\t{\n\t\t  menu->curitem->value = !menu->curitem->value;\n\t\t  Move_And_Post_Item(menu, menu->curitem);\n\t\t  _nc_Show_Menu(menu);\n\t\t}\n\t      else\n\t\tresult = E_NOT_SELECTABLE;\n\t    }\n\t  break;\n\n\tcase REQ_CLEAR_PATTERN:\n\t     \n\t   \n\t  break;\n\n\tcase REQ_BACK_PATTERN:\n\t     \n\t  if (menu->pindex > 0)\n\t    {\n\t      assert(menu->pattern);\n\t      Remove_Character_From_Pattern(menu);\n\t      pos_menu_cursor(menu);\n\t    }\n\t  else\n\t    result = E_REQUEST_DENIED;\n\t  break;\n\n\tcase REQ_NEXT_MATCH:\n\t     \n\t  assert(menu->pattern);\n\t  if (menu->pattern[0])\n\t    result = _nc_Match_Next_Character_In_Item_Name(menu, 0, &item);\n\t  else\n\t    {\n\t      if ((item->index + 1) < menu->nitems)\n\t\titem = menu->items[item->index + 1];\n\t      else\n\t\t{\n\t\t  if (menu->opt & O_NONCYCLIC)\n\t\t    result = E_REQUEST_DENIED;\n\t\t  else\n\t\t    item = menu->items[0];\n\t\t}\n\t    }\n\t  break;\n\n\tcase REQ_PREV_MATCH:\n\t     \n\t  assert(menu->pattern);\n\t  if (menu->pattern[0])\n\t    result = _nc_Match_Next_Character_In_Item_Name(menu, BS, &item);\n\t  else\n\t    {\n\t      if (item->index)\n\t\titem = menu->items[item->index - 1];\n\t      else\n\t\t{\n\t\t  if (menu->opt & O_NONCYCLIC)\n\t\t    result = E_REQUEST_DENIED;\n\t\t  else\n\t\t    item = menu->items[menu->nitems - 1];\n\t\t}\n\t    }\n\t  break;\n\n\tdefault:\n\t     \n\t  result = E_UNKNOWN_COMMAND;\n\t  break;\n\t}\n    }\n  else\n    {\t\t\t\t \n      if (!(c & ~((int)MAX_REGULAR_CHARACTER)) && isprint(UChar(c)))\n\tresult = _nc_Match_Next_Character_In_Item_Name(menu, c, &item);\n#ifdef NCURSES_MOUSE_VERSION\n      else if (KEY_MOUSE == c)\n\t{\n\t  MEVENT event;\n\t  WINDOW *uwin = Get_Menu_UserWin(menu);\n\n\t  getmouse(&event);\n\t  if ((event.bstate & (BUTTON1_CLICKED |\n\t\t\t       BUTTON1_DOUBLE_CLICKED |\n\t\t\t       BUTTON1_TRIPLE_CLICKED))\n\t      && wenclose(uwin, event.y, event.x))\n\t    {\t\t\t \n\t      WINDOW *sub = Get_Menu_Window(menu);\n\t      int ry = event.y, rx = event.x;\t \n\n\t      result = E_REQUEST_DENIED;\n\t      if (mouse_trafo(&ry, &rx, FALSE))\n\t\t{\t\t \n\t\t  if (ry < sub->_begy)\n\t\t    {\t\t \n\t\t      if (event.bstate & BUTTON1_CLICKED)\n\t\t\tresult = menu_driver(menu, REQ_SCR_ULINE);\n\t\t      else if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t\tresult = menu_driver(menu, REQ_SCR_UPAGE);\n\t\t      else if (event.bstate & BUTTON1_TRIPLE_CLICKED)\n\t\t\tresult = menu_driver(menu, REQ_FIRST_ITEM);\n\t\t      RETURN(result);\n\t\t    }\n\t\t  else if (ry > sub->_begy + sub->_maxy)\n\t\t    {\t\t \n\t\t      if (event.bstate & BUTTON1_CLICKED)\n\t\t\tresult = menu_driver(menu, REQ_SCR_DLINE);\n\t\t      else if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t\tresult = menu_driver(menu, REQ_SCR_DPAGE);\n\t\t      else if (event.bstate & BUTTON1_TRIPLE_CLICKED)\n\t\t\tresult = menu_driver(menu, REQ_LAST_ITEM);\n\t\t      RETURN(result);\n\t\t    }\n\t\t  else if (wenclose(sub, event.y, event.x))\n\t\t    {\t\t \n\t\t      int x, y;\n\n\t\t      ry = event.y;\n\t\t      rx = event.x;\n\t\t      if (wmouse_trafo(sub, &ry, &rx, FALSE))\n\t\t\t{\n\t\t\t  int i;\n\n\t\t\t  for (i = 0; i < menu->nitems; i++)\n\t\t\t    {\n\t\t\t      int err = _nc_menu_cursor_pos(menu,\n\t\t\t\t\t\t\t    menu->items[i],\n\t\t\t\t\t\t\t    &y, &x);\n\n\t\t\t      if (E_OK == err)\n\t\t\t\t{\n\t\t\t\t  if ((ry == y) &&\n\t\t\t\t      (rx >= x) &&\n\t\t\t\t      (rx < x + menu->itemlen))\n\t\t\t\t    {\n\t\t\t\t      item = menu->items[i];\n\t\t\t\t      result = E_OK;\n\t\t\t\t      break;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  if (E_OK == result)\n\t\t\t    {\t \n\t\t\t      if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t\t\t{\n\t\t\t\t  _nc_New_TopRow_and_CurrentItem(menu,\n\t\t\t\t\t\t\t\t my_top_row,\n\t\t\t\t\t\t\t\t item);\n\t\t\t\t  menu_driver(menu, REQ_TOGGLE_ITEM);\n\t\t\t\t  result = E_UNKNOWN_COMMAND;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (menu->opt & O_MOUSE_MENU)\n\t\tungetmouse(&event);\t \n\t      result = E_REQUEST_DENIED;\n\t    }\n\t}\n#endif  \n      else\n\tresult = E_UNKNOWN_COMMAND;\n    }\n\n  if (item == 0)\n    {\n      result = E_BAD_STATE;\n    }\n  else if (E_OK == result)\n    {\n       \n      if (item->y < my_top_row)\n\tmy_top_row = item->y;\n      else if (item->y >= (my_top_row + menu->arows))\n\tmy_top_row = item->y - menu->arows + 1;\n\n      _nc_New_TopRow_and_CurrentItem(menu, my_top_row, item);\n\n    }\n\n  RETURN(result);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}