{
  "module_name": "m_item_new.c",
  "hash_id": "876ec0fac0591d0d86f2cef64abfc57f1a184c63c57911d5b132626fece5ff6f",
  "original_prompt": "Ingested from ncurses-6.4/menu/m_item_new.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"menu.priv.h\"\n\n#if USE_WIDEC_SUPPORT\n#if HAVE_WCTYPE_H\n#include <wctype.h>\n#endif\n#endif\n\nMODULE_ID(\"$Id: m_item_new.c,v 1.38 2021/06/17 21:26:02 tom Exp $\")\n\n \nstatic bool\nIs_Printable_String(const char *s)\n{\n  int result = TRUE;\n\n#if USE_WIDEC_SUPPORT\n  int count = (int)mbstowcs(0, s, 0);\n  wchar_t *temp = 0;\n\n  assert(s);\n\n  if (count > 0\n      && (temp = typeCalloc(wchar_t, (2 + (unsigned)count))) != 0)\n    {\n      int n;\n\n      mbstowcs(temp, s, (unsigned)count);\n      for (n = 0; n < count; ++n)\n\tif (!iswprint((wint_t)temp[n]))\n\t  {\n\t    result = FALSE;\n\t    break;\n\t  }\n      free(temp);\n    }\n#else\n  assert(s);\n  while (*s)\n    {\n      if (!isprint(UChar(*s)))\n\t{\n\t  result = FALSE;\n\t  break;\n\t}\n      s++;\n    }\n#endif\n  return result;\n}\n\n \nMENU_EXPORT(ITEM *)\nnew_item(const char *name, const char *description)\n{\n  ITEM *item;\n\n  T((T_CALLED(\"new_item(\\\"%s\\\", \\\"%s\\\")\"),\n     name ? name : \"\",\n     description ? description : \"\"));\n\n  if (!name || (*name == '\\0') || !Is_Printable_String(name))\n    {\n      item = (ITEM *)0;\n      SET_ERROR(E_BAD_ARGUMENT);\n    }\n  else\n    {\n      item = typeCalloc(ITEM, 1);\n\n      if (item)\n\t{\n\t  T((T_CREATE(\"item %p\"), (void *)item));\n\t  *item = _nc_Default_Item;\t \n\n\t  item->name.length = (unsigned short)strlen(name);\n\t  item->name.str = name;\n\n\t  if (description && (*description != '\\0') &&\n\t      Is_Printable_String(description))\n\t    {\n\t      item->description.length = (unsigned short)strlen(description);\n\t      item->description.str = description;\n\t    }\n\t  else\n\t    {\n\t      item->description.length = 0;\n\t      item->description.str = (char *)0;\n\t    }\n\t}\n      else\n\tSET_ERROR(E_SYSTEM_ERROR);\n    }\n  returnItem(item);\n}\n\n \nMENU_EXPORT(int)\nfree_item(ITEM *item)\n{\n  T((T_CALLED(\"free_item(%p)\"), (void *)item));\n\n  if (!item)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (item->imenu)\n    RETURN(E_CONNECTED);\n\n  free(item);\n\n  RETURN(E_OK);\n}\n\n \nMENU_EXPORT(int)\nset_menu_mark(MENU *menu, const char *mark)\n{\n  short l;\n\n  T((T_CALLED(\"set_menu_mark(%p,%s)\"), (void *)menu, _nc_visbuf(mark)));\n\n  if (mark && (*mark != '\\0') && Is_Printable_String(mark))\n    l = (short)strlen(mark);\n  else\n    l = 0;\n\n  if (menu)\n    {\n      char *old_mark = menu->mark;\n      unsigned short old_status = menu->status;\n\n      if (menu->status & _POSTED)\n\t{\n\t   \n\t  if (menu->marklen != l)\n\t    RETURN(E_BAD_ARGUMENT);\n\t}\n      menu->marklen = l;\n      if (l)\n\t{\n\t  menu->mark = strdup(mark);\n\t  if (menu->mark)\n\t    {\n\t      if (menu != &_nc_Default_Menu)\n\t\tSetStatus(menu, _MARK_ALLOCATED);\n\t    }\n\t  else\n\t    {\n\t      menu->mark = old_mark;\n\t      menu->marklen = (short)((old_mark != 0) ? strlen(old_mark) : 0);\n\t      RETURN(E_SYSTEM_ERROR);\n\t    }\n\t}\n      else\n\tmenu->mark = (char *)0;\n\n      if ((old_status & _MARK_ALLOCATED) && old_mark)\n\tfree(old_mark);\n\n      if (menu->status & _POSTED)\n\t{\n\t  _nc_Draw_Menu(menu);\n\t  _nc_Show_Menu(menu);\n\t}\n      else\n\t{\n\t   \n\t  _nc_Calculate_Item_Length_and_Width(menu);\n\t}\n    }\n  else\n    {\n      returnCode(set_menu_mark(&_nc_Default_Menu, mark));\n    }\n  RETURN(E_OK);\n}\n\n \nMENU_EXPORT(const char *)\nmenu_mark(const MENU *menu)\n{\n  T((T_CALLED(\"menu_mark(%p)\"), (const void *)menu));\n  returnPtr(Normalize_Menu(menu)->mark);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}