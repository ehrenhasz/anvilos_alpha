{
  "module_name": "m_post.c",
  "hash_id": "e6f64f47e182983b197a5d9ed1033c6e383a5135ff1ea9e2f65bf33de700f1d9",
  "original_prompt": "Ingested from ncurses-6.4/menu/m_post.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"menu.priv.h\"\n\nMODULE_ID(\"$Id: m_post.c,v 1.38 2022/09/24 09:38:44 tom Exp $\")\n\n \nMENU_EXPORT(void)\n_nc_Post_Item(const MENU *menu, const ITEM *item)\n{\n  int i;\n  chtype ch;\n  int item_x, item_y;\n  int count = 0;\n  bool isfore = FALSE, isback = FALSE, isgrey = FALSE;\n  int name_len;\n\n  assert(menu->win);\n\n  getyx(menu->win, item_y, item_x);\n\n   \n  wattron(menu->win, (int)menu->back);\n  if (item->value || (item == menu->curitem))\n    {\n      if (menu->marklen)\n\t{\n\t   \n\t  if (!(menu->opt & O_ONEVALUE) && item->value && item != menu->curitem)\n\t    {\n\t      wattron(menu->win, (int)menu->fore);\n\t      isfore = TRUE;\n\t    }\n\t  waddstr(menu->win, menu->mark);\n\t  if (isfore)\n\t    {\n\t      wattron(menu->win, (int)menu->fore);\n\t      isfore = FALSE;\n\t    }\n\t}\n    }\n  else\t\t\t\t \n    for (ch = ' ', i = menu->marklen; i > 0; i--)\n      waddch(menu->win, ch);\n  wattroff(menu->win, (int)menu->back);\n  count += menu->marklen;\n\n   \n  if (!(item->opt & O_SELECTABLE))\n    {\n      wattron(menu->win, (int)menu->grey);\n      isgrey = TRUE;\n    }\n  else\n    {\n      if (item->value || item == menu->curitem)\n\t{\n\t  wattron(menu->win, (int)menu->fore);\n\t  isfore = TRUE;\n\t}\n      else\n\t{\n\t  wattron(menu->win, (int)menu->back);\n\t  isback = TRUE;\n\t}\n    }\n\n  waddnstr(menu->win, item->name.str, item->name.length);\n  name_len = _nc_Calculate_Text_Width(&(item->name));\n  for (ch = ' ', i = menu->namelen - name_len; i > 0; i--)\n    {\n      waddch(menu->win, ch);\n    }\n  count += menu->namelen;\n\n   \n  if ((menu->opt & O_SHOWDESC) && menu->desclen > 0)\n    {\n      int m = menu->spc_desc / 2;\n      int cy = -1, cx = -1;\n      int desc_len;\n\n      for (ch = ' ', i = 0; i < menu->spc_desc; i++)\n\t{\n\t  if (i == m)\n\t    {\n\t      waddch(menu->win, menu->pad);\n\t      getyx(menu->win, cy, cx);\n\t    }\n\t  else\n\t    waddch(menu->win, ch);\n\t}\n      if (item->description.length)\n\twaddnstr(menu->win, item->description.str, item->description.length);\n      desc_len = _nc_Calculate_Text_Width(&(item->description));\n      for (ch = ' ', i = menu->desclen - desc_len; i > 0; i--)\n\t{\n\t  waddch(menu->win, ch);\n\t}\n      count += menu->desclen + menu->spc_desc;\n\n      if (menu->spc_rows > 1)\n\t{\n\t  int j, k, ncy, ncx;\n\n\t  assert(cx >= 0 && cy >= 0);\n\t  getyx(menu->win, ncy, ncx);\n\t  if (isgrey)\n\t    wattroff(menu->win, (int)menu->grey);\n\t  else if (isfore)\n\t    wattroff(menu->win, (int)menu->fore);\n\t  wattron(menu->win, (int)menu->back);\n\t  for (j = 1; j < menu->spc_rows; j++)\n\t    {\n\t      if ((item_y + j) < getmaxy(menu->win))\n\t\t{\n\t\t  wmove(menu->win, item_y + j, item_x);\n\t\t  for (k = 0; k < count; k++)\n\t\t    waddch(menu->win, ' ');\n\t\t}\n\t      if ((cy + j) < getmaxy(menu->win))\n\t\t(void)mvwaddch(menu->win, cy + j, cx - 1, menu->pad);\n\t    }\n\t  wmove(menu->win, ncy, ncx);\n\t  if (!isback)\n\t    wattroff(menu->win, (int)menu->back);\n\t}\n    }\n\n   \n  if (isfore)\n    wattroff(menu->win, (int)menu->fore);\n  if (isback)\n    wattroff(menu->win, (int)menu->back);\n  if (isgrey)\n    wattroff(menu->win, (int)menu->grey);\n}\n\n \nMENU_EXPORT(void)\n_nc_Draw_Menu(const MENU *menu)\n{\n  ITEM *item = menu->items[0];\n  ITEM *lastvert;\n  ITEM *hitem;\n  chtype s_bkgd;\n\n  assert(item && menu->win);\n\n  s_bkgd = getbkgd(menu->win);\n  wbkgdset(menu->win, menu->back);\n  werase(menu->win);\n  wbkgdset(menu->win, s_bkgd);\n\n  lastvert = (menu->opt & O_NONCYCLIC) ? (ITEM *)0 : item;\n\n  if (item != NULL)\n    {\n      int y = 0;\n\n      do\n\t{\n\t  ITEM *lasthor;\n\n\t  wmove(menu->win, y, 0);\n\n\t  hitem = item;\n\t  lasthor = (menu->opt & O_NONCYCLIC) ? (ITEM *)0 : hitem;\n\n\t  do\n\t    {\n\t      _nc_Post_Item(menu, hitem);\n\n\t      wattron(menu->win, (int)menu->back);\n\t      if (((hitem = hitem->right) != lasthor) && hitem)\n\t\t{\n\t\t  int i, j, cy, cx;\n\t\t  chtype ch = ' ';\n\n\t\t  getyx(menu->win, cy, cx);\n\t\t  for (j = 0; j < menu->spc_rows; j++)\n\t\t    {\n\t\t      wmove(menu->win, cy + j, cx);\n\t\t      for (i = 0; i < menu->spc_cols; i++)\n\t\t\t{\n\t\t\t  waddch(menu->win, ch);\n\t\t\t}\n\t\t    }\n\t\t  wmove(menu->win, cy, cx + menu->spc_cols);\n\t\t}\n\t    }\n\t  while (hitem && (hitem != lasthor));\n\t  wattroff(menu->win, (int)menu->back);\n\n\t  item = item->down;\n\t  y += menu->spc_rows;\n\n\t}\n      while (item && (item != lastvert));\n    }\n}\n\n \nMENU_EXPORT(int)\npost_menu(MENU *menu)\n{\n  T((T_CALLED(\"post_menu(%p)\"), (void *)menu));\n\n  if (!menu)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (menu->status & _IN_DRIVER)\n    RETURN(E_BAD_STATE);\n\n  if (menu->status & _POSTED)\n    RETURN(E_POSTED);\n\n  if (menu->items && *(menu->items))\n    {\n      int h = 1 + menu->spc_rows * (menu->rows - 1);\n\n      WINDOW *win = Get_Menu_Window(menu);\n      int maxy = getmaxy(win);\n\n      if ((menu->win = newpad(h, menu->width)))\n\t{\n\t  int y = (maxy >= h) ? h : maxy;\n\n\t  if (y >= menu->height)\n\t    y = menu->height;\n\t  if (!(menu->sub = subpad(menu->win, y, menu->width, 0, 0)))\n\t    RETURN(E_SYSTEM_ERROR);\n\t}\n      else\n\tRETURN(E_SYSTEM_ERROR);\n\n      if (menu->status & _LINK_NEEDED)\n\t_nc_Link_Items(menu);\n    }\n  else\n    RETURN(E_NOT_CONNECTED);\n\n  SetStatus(menu, _POSTED);\n\n  if (!(menu->opt & O_ONEVALUE))\n    {\n      ITEM **items;\n\n      for (items = menu->items; *items; items++)\n\t{\n\t  (*items)->value = FALSE;\n\t}\n    }\n\n  _nc_Draw_Menu(menu);\n\n  Call_Hook(menu, menuinit);\n  Call_Hook(menu, iteminit);\n\n  _nc_Show_Menu(menu);\n\n  RETURN(E_OK);\n}\n\n \nMENU_EXPORT(int)\nunpost_menu(MENU *menu)\n{\n  WINDOW *win;\n\n  T((T_CALLED(\"unpost_menu(%p)\"), (void *)menu));\n\n  if (!menu)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (menu->status & _IN_DRIVER)\n    RETURN(E_BAD_STATE);\n\n  if (!(menu->status & _POSTED))\n    RETURN(E_NOT_POSTED);\n\n  Call_Hook(menu, itemterm);\n  Call_Hook(menu, menuterm);\n\n  win = Get_Menu_Window(menu);\n  werase(win);\n  wsyncup(win);\n\n  assert(menu->sub);\n  delwin(menu->sub);\n  menu->sub = (WINDOW *)0;\n\n  assert(menu->win);\n  delwin(menu->win);\n  menu->win = (WINDOW *)0;\n\n  ClrStatus(menu, _POSTED);\n\n  RETURN(E_OK);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}