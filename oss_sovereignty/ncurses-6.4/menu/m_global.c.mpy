{
  "module_name": "m_global.c",
  "hash_id": "de3b2d364fd32484bba2edd33b5bc90e58ef6cf436656981a42ef5db3d344edc",
  "original_prompt": "Ingested from ncurses-6.4/menu/m_global.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"menu.priv.h\"\n\nMODULE_ID(\"$Id: m_global.c,v 1.33 2021/03/27 23:46:29 tom Exp $\")\n\nstatic char mark[] = \"-\";\n \nMENU_EXPORT_VAR(MENU) _nc_Default_Menu = {\n  16,\t\t\t\t   \n  1,\t\t\t\t   \n  16,\t\t\t\t   \n  1,\t\t\t           \n  16,\t\t\t\t   \n  1,\t\t\t\t   \n  16,\t\t\t\t   \n  0,\t\t\t\t   \n  0,\t\t\t\t   \n  1,\t\t\t\t   \n  1,\t\t\t\t   \n  1,                               \n  1,                               \n  1,                               \n  (char *)0,\t\t\t   \n  0,\t\t\t\t   \n  (WINDOW *)0,\t\t\t   \n  (WINDOW *)0,\t\t\t   \n  (WINDOW *)0,\t\t\t   \n  (WINDOW *)0,\t\t\t   \n  (ITEM **)0,\t\t\t   \n  0,\t\t\t\t   \n  (ITEM *)0,\t\t\t   \n  0,\t\t\t\t   \n  (chtype)A_REVERSE,\t\t   \n  (chtype)A_NORMAL,\t\t   \n  (chtype)A_UNDERLINE,\t\t   \n  ' ',  \t\t\t   \n  (Menu_Hook)0,\t\t\t   \n  (Menu_Hook)0,\t\t\t   \n  (Menu_Hook)0,\t\t\t   \n  (Menu_Hook)0,\t\t\t   \n  (void *)0,\t\t\t   \n  mark,\t\t\t\t   \n  ALL_MENU_OPTS,                   \n  0\t\t\t           \n};\n\nMENU_EXPORT_VAR(ITEM) _nc_Default_Item = {\n  { (char *)0, 0 },\t\t   \n  { (char *)0, 0 },\t\t   \n  (MENU *)0,\t\t           \n  (char *)0,\t\t\t   \n  ALL_ITEM_OPTS,\t\t   \n  0,\t\t\t\t   \n  0,\t\t\t\t   \n  0,\t\t\t\t   \n  FALSE,\t\t\t   \n  (ITEM *)0,\t\t           \n  (ITEM *)0,\t\t           \n  (ITEM *)0,\t\t           \n  (ITEM *)0\t\t           \n  };\n \n\n \nNCURSES_INLINE static void\nComputeMaximum_NameDesc_Lengths(MENU *menu)\n{\n  unsigned MaximumNameLength = 0;\n  unsigned MaximumDescriptionLength = 0;\n  ITEM **items;\n\n  assert(menu && menu->items);\n  for (items = menu->items; *items; items++)\n    {\n      unsigned check = (unsigned)_nc_Calculate_Text_Width(&((*items)->name));\n\n      if (check > MaximumNameLength)\n\tMaximumNameLength = check;\n\n      check = (unsigned)_nc_Calculate_Text_Width(&((*items)->description));\n      if (check > MaximumDescriptionLength)\n\tMaximumDescriptionLength = check;\n    }\n\n  menu->namelen = (short)MaximumNameLength;\n  menu->desclen = (short)MaximumDescriptionLength;\n  T((\"ComputeMaximum_NameDesc_Lengths %d,%d\", menu->namelen, menu->desclen));\n}\n\n \nNCURSES_INLINE static void\nResetConnectionInfo(MENU *menu, ITEM **items)\n{\n  ITEM **item;\n\n  assert(menu && items);\n  for (item = items; *item; item++)\n    {\n      (*item)->index = 0;\n      (*item)->imenu = (MENU *)0;\n    }\n  if (menu->pattern)\n    free(menu->pattern);\n  menu->pattern = (char *)0;\n  menu->pindex = 0;\n  menu->items = (ITEM **)0;\n  menu->nitems = 0;\n}\n\n \nMENU_EXPORT(bool)\n_nc_Connect_Items(MENU *menu, ITEM **items)\n{\n  unsigned int ItemCount = 0;\n\n  if (menu && items)\n    {\n      ITEM **item;\n\n      for (item = items; *item; item++)\n\t{\n\t  if ((*item)->imenu)\n\t    {\n\t       \n\t      break;\n\t    }\n\t}\n      if (!(*item))\n\t \n\t{\n\t  for (item = items; *item; item++)\n\t    {\n\t      if (menu->opt & O_ONEVALUE)\n\t\t{\n\t\t  (*item)->value = FALSE;\n\t\t}\n\t      (*item)->index = (short)ItemCount++;\n\t      (*item)->imenu = menu;\n\t    }\n\t}\n    }\n  else\n    return (FALSE);\n\n  if (ItemCount != 0)\n    {\n      menu->items = items;\n      menu->nitems = (short)ItemCount;\n      ComputeMaximum_NameDesc_Lengths(menu);\n      if ((menu->pattern = typeMalloc(char, (unsigned)(1 + menu->namelen))))\n\t{\n\t  Reset_Pattern(menu);\n\t  set_menu_format(menu, menu->frows, menu->fcols);\n\t  menu->curitem = *items;\n\t  menu->toprow = 0;\n\t  return (TRUE);\n\t}\n    }\n\n   \n  ResetConnectionInfo(menu, items);\n  return (FALSE);\n}\n\n \nMENU_EXPORT(void)\n_nc_Disconnect_Items(MENU *menu)\n{\n  if (menu && menu->items)\n    ResetConnectionInfo(menu, menu->items);\n}\n\n \nMENU_EXPORT(int)\n_nc_Calculate_Text_Width(const TEXT *item   )\n{\n#if USE_WIDEC_SUPPORT\n  int result = item->length;\n\n  T((T_CALLED(\"_nc_menu_text_width(%p)\"), (const void *)item));\n  if (result != 0 && item->str != 0)\n    {\n      int count = (int)mbstowcs(0, item->str, 0);\n      wchar_t *temp = 0;\n\n      if (count > 0\n\t  && (temp = typeMalloc(wchar_t, 2 + count)) != 0)\n\t{\n\t  int n;\n\n\t  result = 0;\n\t  mbstowcs(temp, item->str, (unsigned)count);\n\t  for (n = 0; n < count; ++n)\n\t    {\n\t      int test = wcwidth(temp[n]);\n\n\t      if (test <= 0)\n\t\ttest = 1;\n\t      result += test;\n\t    }\n\t  free(temp);\n\t}\n    }\n  returnCode(result);\n#else\n  return item->length;\n#endif\n}\n\n \n#if USE_WIDEC_SUPPORT\nstatic int\ncalculate_actual_width(MENU *menu, bool name)\n{\n  int width = 0;\n\n  assert(menu && menu->items);\n\n  if (menu->items != 0)\n    {\n      ITEM **items;\n\n      for (items = menu->items; *items; items++)\n\t{\n\t  int check = (name\n\t\t       ? _nc_Calculate_Text_Width(&((*items)->name))\n\t\t       : _nc_Calculate_Text_Width(&((*items)->description)));\n\n\t  if (check > width)\n\t    width = check;\n\t}\n    }\n  else\n    {\n      width = (name ? menu->namelen : menu->desclen);\n    }\n\n  T((\"calculate_actual_width %s = %d/%d\",\n     name ? \"name\" : \"desc\",\n     width,\n     name ? menu->namelen : menu->desclen));\n  return width;\n}\n#else\n#define calculate_actual_width(menu, name) (name ? menu->namelen : menu->desclen)\n#endif\n\n \nMENU_EXPORT(void)\n_nc_Calculate_Item_Length_and_Width(MENU *menu)\n{\n  int l;\n\n  assert(menu);\n\n  menu->height = (short)(1 + menu->spc_rows * (menu->arows - 1));\n\n  l = calculate_actual_width(menu, TRUE);\n  l += menu->marklen;\n\n  if ((menu->opt & O_SHOWDESC) && (menu->desclen > 0))\n    {\n      l += calculate_actual_width(menu, FALSE);\n      l += menu->spc_desc;\n    }\n\n  menu->itemlen = (short)l;\n  l *= menu->cols;\n  l += (menu->cols - 1) * menu->spc_cols;\t \n  menu->width = (short)l;\n\n  T((\"_nc_CalculateItem_Length_and_Width columns %d, item %d, width %d\",\n     menu->cols,\n     menu->itemlen,\n     menu->width));\n}\n\n \nMENU_EXPORT(void)\n_nc_Link_Items(MENU *menu)\n{\n  if (menu && menu->items && *(menu->items))\n    {\n      int i;\n      ITEM *item;\n      int Number_Of_Items = menu->nitems;\n      int col = 0, row = 0;\n      int Last_in_Row;\n      int Last_in_Column;\n      bool cycle = (menu->opt & O_NONCYCLIC) ? FALSE : TRUE;\n\n      ClrStatus(menu, _LINK_NEEDED);\n\n      if (menu->opt & O_ROWMAJOR)\n\t{\n\t  int Number_Of_Columns = menu->cols;\n\n\t  for (i = 0; i < Number_Of_Items; i++)\n\t    {\n\t      item = menu->items[i];\n\n\t      Last_in_Row = row * Number_Of_Columns + (Number_Of_Columns - 1);\n\n\t      item->left = (col) ?\n\t       \n\t\tmenu->items[i - 1] :\n\t\t(cycle ? menu->items[(Last_in_Row >= Number_Of_Items) ?\n\t\t\t\t     Number_Of_Items - 1 :\n\t\t\t\t     Last_in_Row] :\n\t\t (ITEM *)0);\n\n\t      item->right = ((col < (Number_Of_Columns - 1)) &&\n\t\t\t     ((i + 1) < Number_Of_Items)\n\t\t)?\n\t\tmenu->items[i + 1] :\n\t\t(cycle ? menu->items[row * Number_Of_Columns] :\n\t\t (ITEM *)0\n\t\t);\n\n\t      Last_in_Column = (menu->rows - 1) * Number_Of_Columns + col;\n\n\t      item->up = (row) ? menu->items[i - Number_Of_Columns] :\n\t\t(cycle ? menu->items[(Last_in_Column >= Number_Of_Items) ?\n\t\t\t\t     Number_Of_Items - 1 :\n\t\t\t\t     Last_in_Column] :\n\t\t (ITEM *)0);\n\n\t      item->down = ((i + Number_Of_Columns) < Number_Of_Items)\n\t\t?\n\t\tmenu->items[i + Number_Of_Columns] :\n\t\t(cycle ? menu->items[(row + 1) < menu->rows ?\n\t\t\t\t     Number_Of_Items - 1 : col] :\n\t\t (ITEM *)0);\n\t      item->x = (short)col;\n\t      item->y = (short)row;\n\t      if (++col == Number_Of_Columns)\n\t\t{\n\t\t  row++;\n\t\t  col = 0;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  int Number_Of_Rows = menu->rows;\n\t  int j;\n\n\t  for (j = 0; j < Number_Of_Items; j++)\n\t    {\n\t      item = menu->items[i = (col * Number_Of_Rows + row)];\n\n\t      Last_in_Column = (menu->cols - 1) * Number_Of_Rows + row;\n\n\t      item->left = (col) ?\n\t\tmenu->items[i - Number_Of_Rows] :\n\t\t(cycle ? (Last_in_Column >= Number_Of_Items) ?\n\t\t menu->items[Last_in_Column - Number_Of_Rows] :\n\t\t menu->items[Last_in_Column] :\n\t\t (ITEM *)0);\n\n\t      item->right = ((i + Number_Of_Rows) < Number_Of_Items)\n\t\t?\n\t\tmenu->items[i + Number_Of_Rows] :\n\t\t(cycle ? menu->items[row] : (ITEM *)0);\n\n\t      Last_in_Row = col * Number_Of_Rows + (Number_Of_Rows - 1);\n\n\t      item->up = (row) ?\n\t\tmenu->items[i - 1] :\n\t\t(cycle ?\n\t\t menu->items[(Last_in_Row >= Number_Of_Items) ?\n\t\t\t     Number_Of_Items - 1 :\n\t\t\t     Last_in_Row] :\n\t\t (ITEM *)0);\n\n\t      item->down = (row < (Number_Of_Rows - 1))\n\t\t?\n\t\t(menu->items[((i + 1) < Number_Of_Items) ?\n\t\t\t     i + 1 :\n\t\t\t     (col - 1) * Number_Of_Rows + row + 1]) :\n\t\t(cycle ?\n\t\t menu->items[col * Number_Of_Rows] :\n\t\t (ITEM *)0\n\t\t);\n\n\t      item->x = (short)col;\n\t      item->y = (short)row;\n\t      if ((++row) == Number_Of_Rows)\n\t\t{\n\t\t  col++;\n\t\t  row = 0;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n \nMENU_EXPORT(void)\n_nc_Show_Menu(const MENU *menu)\n{\n  assert(menu);\n  if ((menu->status & _POSTED) && !(menu->status & _IN_DRIVER))\n    {\n      WINDOW *win;\n      int maxy, maxx;\n\n       \n      assert(menu->sub);\n      mvderwin(menu->sub, menu->spc_rows * menu->toprow, 0);\n      win = Get_Menu_Window(menu);\n\n      maxy = getmaxy(win);\n      maxx = getmaxx(win);\n\n      if (menu->height < maxy)\n\tmaxy = menu->height;\n      if (menu->width < maxx)\n\tmaxx = menu->width;\n\n      copywin(menu->sub, win, 0, 0, 0, 0, maxy - 1, maxx - 1, 0);\n      pos_menu_cursor(menu);\n    }\n}\n\n \nMENU_EXPORT(void)\n_nc_New_TopRow_and_CurrentItem(\n\t\t\t\tMENU *menu,\n\t\t\t\tint new_toprow,\n\t\t\t\tITEM *new_current_item)\n{\n  assert(menu);\n  if (menu->status & _POSTED)\n    {\n      ITEM *cur_item;\n      bool mterm_called = FALSE;\n      bool iterm_called = FALSE;\n\n      if (new_current_item != menu->curitem)\n\t{\n\t  Call_Hook(menu, itemterm);\n\t  iterm_called = TRUE;\n\t}\n      if (new_toprow != menu->toprow)\n\t{\n\t  Call_Hook(menu, menuterm);\n\t  mterm_called = TRUE;\n\t}\n\n      cur_item = menu->curitem;\n      assert(cur_item);\n      menu->toprow = (short)(((menu->rows - menu->frows) >= 0)\n\t\t\t     ? min(menu->rows - menu->frows, new_toprow)\n\t\t\t     : 0);\n      menu->curitem = new_current_item;\n\n      if (mterm_called)\n\t{\n\t  Call_Hook(menu, menuinit);\n\t}\n      if (iterm_called)\n\t{\n\t   \n\t  Move_To_Current_Item(menu, cur_item);\n\t  Call_Hook(menu, iteminit);\n\t}\n      if (mterm_called || iterm_called)\n\t{\n\t  _nc_Show_Menu(menu);\n\t}\n      else\n\tpos_menu_cursor(menu);\n    }\n  else\n    {\t\t\t\t \n      menu->toprow = (short)(((menu->rows - menu->frows) >= 0)\n\t\t\t     ? min(menu->rows - menu->frows, new_toprow)\n\t\t\t     : 0);\n      menu->curitem = new_current_item;\n    }\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}