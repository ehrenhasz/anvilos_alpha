{
  "module_name": "MKkey_defs.sh",
  "hash_id": "ffa2a8a2d04c72d1823c474ba117eefe3566e027d0ba45d6a0f3ae8069505c5d",
  "original_prompt": "Ingested from ncurses-6.4/include/MKkey_defs.sh",
  "human_readable_source": "#! /bin/sh\n# $Id: MKkey_defs.sh,v 1.23 2022/07/16 16:54:02 tom Exp $\n##############################################################################\n# Copyright 2019-2020,2022 Thomas E. Dickey                                  #\n# Copyright 2001-2013,2017 Free Software Foundation, Inc.                    #\n#                                                                            #\n# Permission is hereby granted, free of charge, to any person obtaining a    #\n# copy of this software and associated documentation files (the \"Software\"), #\n# to deal in the Software without restriction, including without limitation  #\n# the rights to use, copy, modify, merge, publish, distribute, distribute    #\n# with modifications, sublicense, and/or sell copies of the Software, and to #\n# permit persons to whom the Software is furnished to do so, subject to the  #\n# following conditions:                                                      #\n#                                                                            #\n# The above copyright notice and this permission notice shall be included in #\n# all copies or substantial portions of the Software.                        #\n#                                                                            #\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR #\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   #\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    #\n# THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER      #\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    #\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        #\n# DEALINGS IN THE SOFTWARE.                                                  #\n#                                                                            #\n# Except as contained in this notice, the name(s) of the above copyright     #\n# holders shall not be used in advertising or otherwise to promote the sale, #\n# use or other dealings in this Software without prior written               #\n# authorization.                                                             #\n##############################################################################\n#\n# MKkey_defs.sh -- generate function-key definitions for curses.h\n#\n# Author: Thomas E. Dickey 2001\n#\n# Extract function-key definitions from the Caps file\n#\n: \"${AWK-awk}\"\n\ntest $# = 0 && set Caps\n\ndata=data$$\npass1=pass1_$$\npass2=pass2_$$\npass3=pass3_$$\npass4=pass4_$$\ntrap 'rm -f $data pass[1234]_$$; exit 1' 1 2 3 15\ntrap 'rm -f $data pass[1234]_$$' 0\n\n# change repeated tabs (used for readability) to single tabs (needed to make\n# awk see the right field alignment of the corresponding columns):\nif sort -k 6 \"$@\" >$data 2>/dev/null\nthen\n\t# POSIX\n\tsed -e 's/[\t][\t]*/\t/g' \"$@\" |sort -n -k 6 >$data\nelif sort -n +5 \"$@\" >$data 2>/dev/null\nthen\n\t# SunOS (and SVr4, marked as obsolete but still recognized)\n\tsed -e 's/[\t][\t]*/\t/g' \"$@\" |sort -n +5 >$data\nelse\n\techo \"Your sort utility is broken.  Please install one that works.\" >&2\n\texit 1\nfi\n\n# add keys that we generate automatically:\ncat >>$data <<EOF\nkey_resize\tkr1\tstr\tR1\tKEY_RESIZE\t+\tNCURSES_EXT_FUNCS \tTerminal resize event\nEOF\n\nTHIS=./`basename \"$0\"`\n\ncat <<EOF\n/*\n * These definitions were generated by $THIS $*\n */\nEOF\n\n# KEY_RESET\nmaxkey=345\n\nfor pass in 1 2 3 4\ndo\n\noutput=pass${pass}_$$\n\n${AWK-awk} >$output <$data '\nfunction print_cols(text,cols) {\n\tprintf \"%s\", text\n\tlen = length(text);\n\twhile (len < cols) {\n\t\tprintf \"\t\"\n\t\tlen += 8;\n\t}\n}\nfunction decode(keycode) {\n\tresult = 0;\n\tif (substr(keycode, 1, 2) == \"0x\") {\n\t\tdigits=\"0123456789abcdef\";\n\t} else if (substr(keycode, 1, 1) == \"0\") {\n\t\tdigits=\"01234567\";\n\t} else {\n\t\tdigits=\"0123456789\";\n\t}\n\twhile (length(keycode) != 0) {\n\t\tdigit=substr(keycode, 1, 1);\n\t\tkeycode=substr(keycode, 2);\n\t\tresult = result * length(digits) + index(digits, digit) - 1;\n\t}\n\treturn result;\n}\n\nBEGIN\t{\n\tmaxkey='$maxkey';\n\tpass='$pass';\n\tkey_max=1;\n\tbits=1;\n\twhile (key_max < maxkey) {\n\t\tbits = bits + 1;\n\t\tkey_max = (key_max * 2) + 1;\n\t}\n\toctal_fmt = sprintf (\"%%0%do\", (bits + 2) / 3 + 1);\n}\n\n/^$/\t\t{next;}\n/^#/\t\t{next;}\n/^capalias/\t{next;}\n/^infoalias/\t{next;}\n/^used_by/\t{next;}\n/^userdef/\t{next;}\n\n$5 != \"-\" && $6 != \"-\" {\n\t\tif ($6 == \"+\") {\n\t\t\tif (pass == 1 || pass == 2)\n\t\t\t\tnext;\n\t\t\tthiskey=maxkey + 1;\n\t\t} else {\n\t\t\tif (pass == 3)\n\t\t\t\tnext;\n\t\t\tthiskey=decode($6);\n\t\t}\n\t\tif (thiskey > maxkey)\n\t\t\tmaxkey = thiskey;\n\t\tif (pass == 2 || pass == 3) {\n\t\t\tshowkey=sprintf(octal_fmt, thiskey);\n\t\t\tifdef = 0;\n\t\t\tif (index($7,\"NCURSES_\") == 1) {\n\t\t\t\tifdef = 1;\n\t\t\t\tprintf \"\\n\";\n\t\t\t\tprintf \"#ifdef %s\\n\", $7;\n\t\t\t}\n\t\t\tif ($5 == \"KEY_F(0)\" ) {\n\t\t\t\tprintf \"#define \"\n\t\t\t\tprint_cols(\"KEY_F0\", 16);\n\t\t\t\tprint_cols(showkey, 16);\n\t\t\t\tprint \"/* Function keys.  Space for 64 */\";\n\t\t\t\tprintf \"#define \"\n\t\t\t\tprint_cols(\"KEY_F(n)\", 16);\n\t\t\t\tprint_cols(\"(KEY_F0+(n))\", 16);\n\t\t\t\tprint \"/* Value of function key n */\"\n\t\t\t} else {\n\t\t\t\tprintf \"#define \"\n\t\t\t\tprint_cols($5, 16);\n\t\t\t\tprint_cols(showkey, 16);\n\t\t\t\tprintf \"/*\"\n\t\t\t\tfor (i = 8; i <= NF; i++)\n\t\t\t\t\tprintf \" %s\", $i\n\t\t\t\tprint \" */\"\n\t\t\t}\n\t\t\tif (ifdef != 0) {\n\t\t\t\tprintf \"#endif\\n\";\n\t\t\t}\n\t\t}\n\t}\nEND\t{\n\t\tif (pass == 1) {\n\t\t\tprint maxkey;\n\t\t} else if (pass == 4) {\n\t\t\tprint \"\";\n\t\t\tprintf \"#define \";\n\t\t\tprint_cols(\"KEY_MAX\", 16);\n\t\t\tresult = sprintf (octal_fmt, key_max);\n\t\t\tprint_cols(result, 16);\n\t\t\tprintf \"/* Maximum key value is \";\n\t\t\tprintf octal_fmt, maxkey;\n\t\t\tprint \" */\";\n\t\t}\n\t}\n'\nif test $pass = 1 ; then\n\tmaxkey=`cat $pass1`\nfi\n\ndone\n\ncat $pass2\ncat $pass3\ncat $pass4\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}