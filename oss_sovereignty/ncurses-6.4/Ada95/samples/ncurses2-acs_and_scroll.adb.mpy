{
  "module_name": "ncurses2-acs_and_scroll.adb",
  "hash_id": "1c203fdd50192f7b1da18da6a5c75db7bb91bbdd678428478f50f381f9d00b53",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/samples/ncurses2-acs_and_scroll.adb",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                       GNAT ncurses Binding Samples                       --\n--                                                                          --\n--                                 ncurses                                  --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2018,2020 Thomas E. Dickey                                     --\n-- Copyright 2000-2009,2011 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author: Eugene V. Melaragno <aldomel@ix.netcom.com> 2000\n--  Version Control\n--  $Revision: 1.13 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\n--  Windows and scrolling tester.\n--  Demonstrate windows\n\nwith Ada.Strings.Fixed;\nwith Ada.Strings;\n\nwith ncurses2.util; use ncurses2.util;\nwith ncurses2.genericPuts;\nwith Terminal_Interface.Curses; use Terminal_Interface.Curses;\nwith Terminal_Interface.Curses.Mouse; use Terminal_Interface.Curses.Mouse;\nwith Terminal_Interface.Curses.PutWin; use Terminal_Interface.Curses.PutWin;\n\nwith Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;\nwith Ada.Streams; use Ada.Streams;\n\nprocedure ncurses2.acs_and_scroll is\n\n   Macro_Quit   : constant Key_Code := Character'Pos ('Q') mod 16#20#;\n   Macro_Escape : constant Key_Code := Character'Pos ('[') mod 16#20#;\n\n   Quit : constant Key_Code := CTRL ('Q');\n   Escape : constant Key_Code := CTRL ('[');\n\n   Botlines : constant Line_Position := 4;\n\n   type pair is record\n      y : Line_Position;\n      x : Column_Position;\n   end record;\n\n   type Frame;\n   type FrameA is access Frame;\n\n   f : File_Type;\n   dumpfile : constant String := \"screendump\";\n\n   procedure Outerbox (ul, lr : pair; onoff : Boolean);\n   function  HaveKeyPad (w : Window) return Boolean;\n   function  HaveScroll (w : Window) return Boolean;\n   procedure newwin_legend (curpw : Window);\n   procedure transient (curpw : Window; msg : String);\n   procedure newwin_report (win : Window := Standard_Window);\n   procedure selectcell (uli : Line_Position;\n                         ulj : Column_Position;\n                         lri : Line_Position;\n                         lrj : Column_Position;\n                         p   : out pair;\n                         b   : out Boolean);\n   function  getwindow return Window;\n   procedure newwin_move (win : Window;\n                          dy  : Line_Position;\n                          dx  : Column_Position);\n   function delete_framed (fp : FrameA; showit : Boolean) return FrameA;\n\n   --  A linked list\n   --  I  wish there was a standard library linked list. Oh well.\n   type Frame is record\n      next, last : FrameA;\n      do_scroll : Boolean;\n      do_keypad : Boolean;\n      wind : Window;\n   end record;\n\n   current : FrameA;\n\n   c : Key_Code;\n\n   procedure Outerbox (ul, lr : pair; onoff : Boolean) is\n   begin\n      if onoff then\n         --  Note the fix of an obscure bug\n         --  try making a 1x1 box then enlarging it, the is a blank\n         --  upper left corner!\n         Add (Line => ul.y - 1, Column => ul.x - 1,\n             Ch => ACS_Map (ACS_Upper_Left_Corner));\n         Add (Line => ul.y - 1, Column => lr.x + 1,\n             Ch => ACS_Map (ACS_Upper_Right_Corner));\n         Add (Line => lr.y + 1, Column => lr.x + 1,\n             Ch => ACS_Map (ACS_Lower_Right_Corner));\n         Add (Line => lr.y + 1, Column => ul.x - 1,\n             Ch => ACS_Map (ACS_Lower_Left_Corner));\n\n         Move_Cursor (Line => ul.y - 1, Column => ul.x);\n         Horizontal_Line (Line_Symbol => ACS_Map (ACS_Horizontal_Line),\n                          Line_Size => Integer (lr.x - ul.x) + 1);\n         Move_Cursor (Line => ul.y, Column => ul.x - 1);\n         Vertical_Line (Line_Symbol => ACS_Map (ACS_Vertical_Line),\n                        Line_Size => Integer (lr.y - ul.y) + 1);\n         Move_Cursor (Line => lr.y + 1, Column => ul.x);\n         Horizontal_Line (Line_Symbol => ACS_Map (ACS_Horizontal_Line),\n                          Line_Size => Integer (lr.x - ul.x) + 1);\n         Move_Cursor (Line => ul.y, Column => lr.x + 1);\n         Vertical_Line (Line_Symbol => ACS_Map (ACS_Vertical_Line),\n                        Line_Size => Integer (lr.y - ul.y) + 1);\n      else\n         Add (Line => ul.y - 1, Column => ul.x - 1, Ch => ' ');\n         Add (Line => ul.y - 1, Column => lr.x + 1, Ch => ' ');\n         Add (Line => lr.y + 1, Column => lr.x + 1, Ch => ' ');\n         Add (Line => lr.y + 1, Column => ul.x - 1, Ch => ' ');\n\n         Move_Cursor (Line => ul.y - 1, Column => ul.x);\n         Horizontal_Line (Line_Symbol => Blank2,\n                          Line_Size => Integer (lr.x - ul.x) + 1);\n         Move_Cursor (Line => ul.y, Column => ul.x - 1);\n         Vertical_Line (Line_Symbol => Blank2,\n                        Line_Size => Integer (lr.y - ul.y) + 1);\n         Move_Cursor (Line => lr.y + 1, Column => ul.x);\n         Horizontal_Line (Line_Symbol => Blank2,\n                          Line_Size => Integer (lr.x - ul.x) + 1);\n         Move_Cursor (Line => ul.y, Column => lr.x + 1);\n         Vertical_Line (Line_Symbol => Blank2,\n                        Line_Size => Integer (lr.y - ul.y) + 1);\n      end if;\n   end Outerbox;\n\n   function HaveKeyPad (w : Window) return Boolean is\n   begin\n      return Get_KeyPad_Mode (w);\n   exception\n      when Curses_Exception => return False;\n   end HaveKeyPad;\n\n   function HaveScroll (w : Window) return Boolean is\n   begin\n      return Scrolling_Allowed (w);\n   exception\n      when Curses_Exception => return False;\n   end HaveScroll;\n\n   procedure newwin_legend (curpw : Window) is\n\n      package p is new genericPuts (200);\n      use p;\n      use p.BS;\n\n      type string_a is access String;\n\n      type rrr is record\n         msg : string_a;\n         code : Integer range 0 .. 3;\n      end record;\n\n      legend : constant array (Positive range <>) of rrr :=\n        (\n         (\n          new String'(\"^C = create window\"), 0\n          ),\n         (\n          new String'(\"^N = next window\"), 0\n          ),\n         (\n          new String'(\"^P = previous window\"), 0\n          ),\n         (\n          new String'(\"^F = scroll forward\"), 0\n          ),\n         (\n          new String'(\"^B = scroll backward\"), 0\n          ),\n         (\n          new String'(\"^K = keypad(%s)\"), 1\n          ),\n         (\n          new String'(\"^S = scrollok(%s)\"), 2\n          ),\n         (\n          new String'(\"^W = save window to file\"), 0\n          ),\n         (\n          new String'(\"^R = restore window\"), 0\n          ),\n         (\n          new String'(\"^X = resize\"), 0\n          ),\n         (\n          new String'(\"^Q%s = exit\"), 3\n          )\n         );\n\n      buf : Bounded_String;\n      do_keypad : constant Boolean := HaveKeyPad (curpw);\n      do_scroll : constant Boolean := HaveScroll (curpw);\n\n      pos : Natural;\n\n      mypair : pair;\n\n   begin\n      Move_Cursor (Line => Lines - 4, Column => 0);\n      for n in legend'Range loop\n         pos := Ada.Strings.Fixed.Index (Source => legend (n).msg.all,\n                                         Pattern => \"%s\");\n         buf := To_Bounded_String (legend (n).msg.all);\n         case legend (n).code is\n            when 0 => null;\n            when 1 =>\n               if do_keypad then\n                  Replace_Slice (buf, pos, pos + 1, \"yes\");\n               else\n                  Replace_Slice (buf, pos, pos + 1, \"no\");\n               end if;\n            when 2 =>\n               if do_scroll then\n                  Replace_Slice (buf, pos, pos + 1, \"yes\");\n               else\n                  Replace_Slice (buf, pos, pos + 1, \"no\");\n               end if;\n            when 3 =>\n               if do_keypad then\n                  Replace_Slice (buf, pos, pos + 1, \"/ESC\");\n               else\n                  Replace_Slice (buf, pos, pos + 1, \"\");\n               end if;\n         end case;\n         Get_Cursor_Position (Line => mypair.y, Column => mypair.x);\n         if Columns < mypair.x + 3 + Column_Position (Length (buf)) then\n            Add (Ch => newl);\n         elsif n /= 1 then -- n /= legen'First\n            Add (Str => \", \");\n         end if;\n         myAdd (Str => buf);\n      end loop;\n      Clear_To_End_Of_Line;\n   end newwin_legend;\n\n   procedure transient (curpw : Window; msg : String) is\n   begin\n      newwin_legend (curpw);\n      if msg /= \"\" then\n         Add (Line => Lines - 1, Column => 0, Str => msg);\n         Refresh;\n         Nap_Milli_Seconds (1000);\n      end if;\n\n      Move_Cursor (Line => Lines - 1, Column => 0);\n\n      if HaveKeyPad (curpw) then\n         Add (Str => \"Non-arrow\");\n      else\n         Add (Str => \"All other\");\n      end if;\n      Add (Str => \" characters are echoed, window should \");\n      if not HaveScroll (curpw) then\n         Add (Str => \"not \");\n      end if;\n      Add (Str => \"scroll\");\n\n      Clear_To_End_Of_Line;\n   end transient;\n\n   procedure newwin_report (win : Window := Standard_Window) is\n      y : Line_Position;\n      x : Column_Position;\n      use Int_IO;\n      tmp2a : String (1 .. 2);\n      tmp2b : String (1 .. 2);\n   begin\n      if win /= Standard_Window then\n         transient (win, \"\");\n      end if;\n      Get_Cursor_Position (win, y, x);\n      Move_Cursor (Line => Lines - 1, Column => Columns - 17);\n      Put (tmp2a, Integer (y));\n      Put (tmp2b, Integer (x));\n      Add (Str => \"Y = \" & tmp2a & \" X = \" & tmp2b);\n      if win /= Standard_Window then\n         Refresh;\n      else\n         Move_Cursor (win, y, x);\n      end if;\n   end newwin_report;\n\n   procedure selectcell (uli : Line_Position;\n                         ulj : Column_Position;\n                         lri : Line_Position;\n                         lrj : Column_Position;\n                         p   : out pair;\n                         b   : out Boolean) is\n      c : Key_Code;\n      res : pair;\n      i : Line_Position := 0;\n      j : Column_Position := 0;\n      si : constant Line_Position := lri - uli + 1;\n      sj : constant Column_Position := lrj - ulj + 1;\n   begin\n      res.y := uli;\n      res.x := ulj;\n      loop\n         Move_Cursor (Line => uli + i, Column => ulj + j);\n         newwin_report;\n\n         c := Getchar;\n         case c is\n            when\n              Macro_Quit   |\n              Macro_Escape =>\n               --  on the same line macro calls interfere due to the # comment\n               --  this is needed because keypad off affects all windows.\n               --  try removing the ESCAPE and see what happens.\n               b := False;\n               return;\n            when KEY_UP =>\n               i := i + si - 1;\n               --  same as  i := i - 1 because of Modulus arithmetic,\n               --  on Line_Position, which is a Natural\n               --  the C version uses this form too, interestingly.\n            when KEY_DOWN =>\n               i := i + 1;\n            when KEY_LEFT =>\n               j := j + sj - 1;\n            when KEY_RIGHT =>\n               j := j + 1;\n            when Key_Mouse =>\n               declare\n                  event : Mouse_Event;\n                  y : Line_Position;\n                  x : Column_Position;\n                  Button : Mouse_Button;\n                  State : Button_State;\n\n               begin\n                  event := Get_Mouse;\n                  Get_Event (Event => event,\n                             Y => y,\n                             X => x,\n                             Button => Button,\n                             State  => State);\n                  if y > uli and x > ulj then\n                     i := y - uli;\n                     j := x - ulj;\n                     --  same as when others =>\n                     res.y := uli + i;\n                     res.x := ulj + j;\n                     p := res;\n                     b := True;\n                     return;\n                  else\n                     Beep;\n                  end if;\n               end;\n            when others =>\n               res.y := uli + i;\n               res.x := ulj + j;\n               p := res;\n               b := True;\n               return;\n         end case;\n         i := i mod si;\n         j := j mod sj;\n      end loop;\n   end selectcell;\n\n   function getwindow return Window is\n      rwindow : Window;\n      ul, lr : pair;\n      result : Boolean;\n   begin\n      Move_Cursor (Line => 0, Column => 0);\n      Clear_To_End_Of_Line;\n      Add (Str => \"Use arrows to move cursor, anything else to mark corner 1\");\n      Refresh;\n      selectcell (2, 1, Lines - Botlines - 2, Columns - 2, ul, result);\n      if not result then\n         return Null_Window;\n      end if;\n      Add (Line => ul.y - 1, Column => ul.x - 1,\n           Ch => ACS_Map (ACS_Upper_Left_Corner));\n      Move_Cursor (Line => 0, Column => 0);\n      Clear_To_End_Of_Line;\n      Add (Str => \"Use arrows to move cursor, anything else to mark corner 2\");\n      Refresh;\n      selectcell (ul.y, ul.x, Lines - Botlines - 2, Columns - 2, lr, result);\n      if not result then\n         return Null_Window;\n      end if;\n\n      rwindow := Sub_Window (Number_Of_Lines => lr.y - ul.y + 1,\n                             Number_Of_Columns => lr.x - ul.x + 1,\n                             First_Line_Position => ul.y,\n                             First_Column_Position => ul.x);\n\n      Outerbox (ul, lr, True);\n      Refresh;\n\n      Refresh (rwindow);\n\n      Move_Cursor (Line => 0, Column => 0);\n      Clear_To_End_Of_Line;\n      return rwindow;\n   end getwindow;\n\n   procedure newwin_move (win : Window;\n                          dy  : Line_Position;\n                          dx  : Column_Position) is\n      cur_y, max_y : Line_Position;\n      cur_x, max_x : Column_Position;\n   begin\n      Get_Cursor_Position (win, cur_y, cur_x);\n      Get_Size (win, max_y, max_x);\n      cur_x := Column_Position'Min (Column_Position'Max (cur_x + dx, 0),\n                                    max_x - 1);\n      cur_y := Line_Position'Min (Line_Position'Max (cur_y + dy, 0),\n                                  max_y - 1);\n\n      Move_Cursor (win, Line => cur_y, Column => cur_x);\n   end newwin_move;\n\n   function delete_framed (fp : FrameA; showit : Boolean) return FrameA is\n      np : FrameA;\n   begin\n      fp.all.last.all.next := fp.all.next;\n      fp.all.next.all.last := fp.all.last;\n\n      if showit then\n         Erase (fp.all.wind);\n         Refresh (fp.all.wind);\n      end if;\n      Delete (fp.all.wind);\n\n      if fp = fp.all.next then\n         np := null;\n      else\n         np := fp.all.next;\n      end if;\n      --  TODO free(fp);\n      return np;\n   end delete_framed;\n\n   Mask : Event_Mask := No_Events;\n   Mask2 : Event_Mask;\n\n   usescr : Window;\n\nbegin\n   if Has_Mouse then\n      Register_Reportable_Event (\n                                 Button => Left,\n                                 State => Clicked,\n                                 Mask => Mask);\n      Mask2 := Start_Mouse (Mask);\n   end if;\n   c := CTRL ('C');\n   Set_Raw_Mode (SwitchOn => True);\n   loop\n      transient (Standard_Window, \"\");\n      case c is\n         when Character'Pos ('c') mod 16#20# => --  Ctrl('c')\n            declare\n               neww : constant FrameA := new Frame'(null, null,\n                                                    False, False,\n                                                    Null_Window);\n            begin\n               neww.all.wind := getwindow;\n               if neww.all.wind = Null_Window  then\n                  exit;\n                  --  was goto breakout; ha ha ha\n               else\n\n                  if current = null  then\n                     neww.all.next := neww;\n                     neww.all.last := neww;\n                  else\n                     neww.all.next := current.all.next;\n                     neww.all.last := current;\n                     neww.all.last.all.next := neww;\n                     neww.all.next.all.last := neww;\n                  end if;\n                  current := neww;\n\n                  Set_KeyPad_Mode (current.all.wind, True);\n                  current.all.do_keypad := HaveKeyPad (current.all.wind);\n                  current.all.do_scroll := HaveScroll (current.all.wind);\n               end if;\n            end;\n         when Character'Pos ('N') mod 16#20#  => --  Ctrl('N')\n            if current /= null then\n               current := current.all.next;\n            end if;\n         when Character'Pos ('P') mod 16#20#  => --  Ctrl('P')\n            if current /= null then\n               current := current.all.last;\n            end if;\n         when Character'Pos ('F') mod 16#20#  => --  Ctrl('F')\n            if current /= null and then HaveScroll (current.all.wind) then\n               Scroll (current.all.wind, 1);\n            end if;\n         when Character'Pos ('B') mod 16#20#  => --  Ctrl('B')\n            if current /= null and then HaveScroll (current.all.wind) then\n            --  The C version of Scroll may return ERR which is ignored\n            --  we need to avoid the exception\n            --  with the 'and HaveScroll(current.wind)'\n               Scroll (current.all.wind, -1);\n            end if;\n         when Character'Pos ('K') mod 16#20#  => --  Ctrl('K')\n            if current /= null then\n               current.all.do_keypad := not current.all.do_keypad;\n               Set_KeyPad_Mode (current.all.wind, current.all.do_keypad);\n            end if;\n         when Character'Pos ('S') mod 16#20#  => --  Ctrl('S')\n            if current /= null then\n               current.all.do_scroll := not current.all.do_scroll;\n               Allow_Scrolling (current.all.wind, current.all.do_scroll);\n            end if;\n         when Character'Pos ('W') mod 16#20#  => --  Ctrl('W')\n            if current /= current.all.next then\n               Create (f, Name => dumpfile); -- TODO error checking\n               if not Is_Open (f) then\n                  raise Curses_Exception;\n               end if;\n               Put_Window (current.all.wind, f);\n               Close (f);\n               current := delete_framed (current, True);\n            end if;\n         when Character'Pos ('R') mod 16#20#  => --  Ctrl('R')\n            declare\n               neww : FrameA := new Frame'(null, null, False, False,\n                                           Null_Window);\n            begin\n               Open (f, Mode => In_File, Name => dumpfile);\n               neww := new Frame'(null, null, False, False, Null_Window);\n\n               neww.all.next := current.all.next;\n               neww.all.last := current;\n               neww.all.last.all.next := neww;\n               neww.all.next.all.last := neww;\n\n               neww.all.wind := Get_Window (f);\n               Close (f);\n\n               Refresh (neww.all.wind);\n            end;\n         when Character'Pos ('X') mod 16#20# => --  Ctrl('X')\n            if current /= null then\n               declare\n                  tmp, ul, lr : pair;\n                  mx : Column_Position;\n                  my : Line_Position;\n                  tmpbool : Boolean;\n               begin\n                  Move_Cursor (Line => 0, Column => 0);\n                  Clear_To_End_Of_Line;\n                  Add (Str => \"Use arrows to move cursor, anything else \" &\n                       \"to mark new corner\");\n                  Refresh;\n\n                  Get_Window_Position (current.all.wind, ul.y, ul.x);\n\n                  selectcell (ul.y, ul.x, Lines - Botlines - 2, Columns - 2,\n                              tmp, tmpbool);\n                  if not tmpbool then\n                     --  the C version had a goto. I refuse gotos.\n                     Beep;\n                  else\n                     Get_Size (current.all.wind, lr.y, lr.x);\n                     lr.y := lr.y + ul.y - 1;\n                     lr.x := lr.x + ul.x - 1;\n                     Outerbox (ul, lr, False);\n                     Refresh_Without_Update;\n\n                     Get_Size (current.all.wind, my, mx);\n                     if my > tmp.y - ul.y then\n                        Get_Cursor_Position (current.all.wind, lr.y, lr.x);\n                        Move_Cursor (current.all.wind, tmp.y - ul.y + 1, 0);\n                        Clear_To_End_Of_Screen (current.all.wind);\n                        Move_Cursor (current.all.wind, lr.y, lr.x);\n                     end if;\n                     if mx > tmp.x - ul.x then\n                        for i in 0 .. my - 1 loop\n                           Move_Cursor (current.all.wind, i, tmp.x - ul.x + 1);\n                           Clear_To_End_Of_Line (current.all.wind);\n                        end loop;\n                     end if;\n                     Refresh_Without_Update (current.all.wind);\n\n                     lr := tmp;\n                     --  The C version passes invalid args to resize\n                     --  which returns an ERR. For Ada we avoid the exception.\n                     if lr.y /= ul.y and lr.x /= ul.x then\n                        Resize (current.all.wind, lr.y - ul.y + 0,\n                                lr.x - ul.x + 0);\n                     end if;\n\n                     Get_Window_Position (current.all.wind, ul.y, ul.x);\n                     Get_Size (current.all.wind, lr.y, lr.x);\n                     lr.y := lr.y + ul.y - 1;\n                     lr.x := lr.x + ul.x - 1;\n                     Outerbox (ul, lr, True);\n                     Refresh_Without_Update;\n\n                     Refresh_Without_Update (current.all.wind);\n                     Move_Cursor (Line => 0, Column => 0);\n                     Clear_To_End_Of_Line;\n                     Update_Screen;\n                  end if;\n               end;\n            end if;\n         when Key_F10  =>\n            declare tmp : pair; tmpbool : Boolean;\n            begin\n               --  undocumented --- use this to test area clears\n               selectcell (0, 0, Lines - 1, Columns - 1, tmp, tmpbool);\n               Clear_To_End_Of_Screen;\n               Refresh;\n            end;\n         when Key_Cursor_Up =>\n            newwin_move (current.all.wind, -1, 0);\n         when Key_Cursor_Down  =>\n            newwin_move (current.all.wind, 1, 0);\n         when Key_Cursor_Left  =>\n            newwin_move (current.all.wind, 0, -1);\n         when Key_Cursor_Right  =>\n            newwin_move (current.all.wind, 0, 1);\n         when Key_Backspace | Key_Delete_Char  =>\n            declare\n               y : Line_Position;\n               x : Column_Position;\n               tmp : Line_Position;\n            begin\n               Get_Cursor_Position (current.all.wind, y, x);\n               --  x := x - 1;\n               --  I got tricked by the -1 = Max_Natural - 1 result\n               --  y := y - 1;\n               if not (x = 0 and y = 0) then\n                  if x = 0 then\n                     y := y - 1;\n                     Get_Size (current.all.wind, tmp, x);\n                  end if;\n                  x := x - 1;\n                  Delete_Character (current.all.wind, y, x);\n               end if;\n            end;\n         when others =>\n            --  TODO c = '\\r' ?\n            if current /= null then\n               declare\n               begin\n                  Add (current.all.wind, Ch => Code_To_Char (c));\n               exception\n                  when Curses_Exception => null;\n                     --  this happens if we are at the\n                     --  lower right of a window and add a character.\n               end;\n            else\n               Beep;\n            end if;\n      end case;\n      newwin_report (current.all.wind);\n      if current /= null then\n         usescr := current.all.wind;\n      else\n         usescr := Standard_Window;\n      end if;\n      Refresh (usescr);\n      c := Getchar (usescr);\n      exit when c = Quit or (c = Escape and HaveKeyPad (usescr));\n      --  TODO when does c = ERR happen?\n   end loop;\n\n   --  TODO while current /= null loop\n   --  current := delete_framed(current, False);\n   --  end loop;\n\n   Allow_Scrolling (Mode => True);\n\n   End_Mouse (Mask2);\n   Set_Raw_Mode (SwitchOn => True);\n   Erase;\n   End_Windows;\n\nend ncurses2.acs_and_scroll;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}