{
  "module_name": "ncurses2-demo_pad.adb",
  "hash_id": "984e7a0c265acb96400b890da95074f75c95e4a8fe8a0935dacd8afa4ca91cd9",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/samples/ncurses2-demo_pad.adb",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                       GNAT ncurses Binding Samples                       --\n--                                                                          --\n--                                 ncurses                                  --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 2000-2011,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author: Eugene V. Melaragno <aldomel@ix.netcom.com> 2000\n--  Version Control\n--  $Revision: 1.11 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith ncurses2.util; use ncurses2.util;\n\nwith Terminal_Interface.Curses; use Terminal_Interface.Curses;\n\nwith Interfaces.C;\nwith System.Storage_Elements;\nwith System.Address_To_Access_Conversions;\n\nwith Ada.Text_IO;\n--  with Ada.Real_Time; use Ada.Real_Time;\n--  TODO is there a way to use Real_Time or Ada.Calendar in place of\n--  gettimeofday?\n\n--  Demonstrate pads.\nprocedure ncurses2.demo_pad is\n\n   type timestruct is record\n      seconds : Integer;\n      microseconds : Integer;\n   end record;\n\n   type myfunc is access function (w : Window) return Key_Code;\n\n   function  gettime return timestruct;\n   procedure do_h_line (y  : Line_Position;\n                        x  : Column_Position;\n                        c  : Attributed_Character;\n                        to : Column_Position);\n   procedure do_v_line (y  : Line_Position;\n                        x  : Column_Position;\n                        c  : Attributed_Character;\n                        to : Line_Position);\n   function  padgetch (win : Window) return Key_Code;\n   function  panner_legend (line : Line_Position) return Boolean;\n   procedure panner_legend (line : Line_Position);\n   procedure panner_h_cleanup (from_y : Line_Position;\n                               from_x : Column_Position;\n                               to_x   : Column_Position);\n   procedure panner_v_cleanup (from_y : Line_Position;\n                               from_x : Column_Position;\n                               to_y   : Line_Position);\n   procedure panner (pad    : Window;\n                     top_xp : Column_Position;\n                     top_yp : Line_Position;\n                     portyp : Line_Position;\n                     portxp : Column_Position;\n                     pgetc  : myfunc);\n\n   function gettime return timestruct is\n\n      retval : timestruct;\n\n      use Interfaces.C;\n      type timeval is record\n         tv_sec : long;\n         tv_usec : long;\n      end record;\n      pragma Convention (C, timeval);\n\n      --      TODO    function from_timeval is new Ada.Unchecked_Conversion(\n      --                  timeval_a, System.Storage_Elements.Integer_Address);\n      --  should Interfaces.C.Pointers be used here?\n\n      package myP is new System.Address_To_Access_Conversions (timeval);\n      use myP;\n\n      t : constant Object_Pointer := new timeval;\n\n      function gettimeofday\n        (TP : System.Storage_Elements.Integer_Address;\n         TZP : System.Storage_Elements.Integer_Address) return int;\n      pragma Import (C, gettimeofday, \"gettimeofday\");\n      tmp : int;\n   begin\n      tmp := gettimeofday (System.Storage_Elements.To_Integer\n                           (myP.To_Address (t)),\n                           System.Storage_Elements.To_Integer\n                           (myP.To_Address (null)));\n      if tmp < 0 then\n         retval.seconds := 0;\n         retval.microseconds := 0;\n      else\n         retval.seconds := Integer (t.all.tv_sec);\n         retval.microseconds := Integer (t.all.tv_usec);\n      end if;\n      return retval;\n   end gettime;\n\n   --  in C, The behavior of mvhline, mvvline for negative/zero length is\n   --  unspecified, though we can rely on negative x/y values to stop the\n   --  macro. Except Ada makes Line_Position(-1) = Natural - 1 so forget it.\n   procedure do_h_line (y  : Line_Position;\n                        x  : Column_Position;\n                        c  : Attributed_Character;\n                        to : Column_Position) is\n   begin\n      if to > x then\n         Move_Cursor (Line => y, Column => x);\n         Horizontal_Line (Line_Size => Natural (to - x), Line_Symbol => c);\n      end if;\n   end do_h_line;\n\n   procedure do_v_line (y  : Line_Position;\n                        x  : Column_Position;\n                        c  : Attributed_Character;\n                        to : Line_Position) is\n   begin\n      if to > y then\n         Move_Cursor (Line => y, Column => x);\n         Vertical_Line (Line_Size => Natural (to - y), Line_Symbol => c);\n      end if;\n   end do_v_line;\n\n   function padgetch (win : Window) return Key_Code is\n      c : Key_Code;\n      c2 : Character;\n   begin\n      c := Getchar (win);\n      c2 := Code_To_Char (c);\n\n      case c2 is\n         when '!' =>\n            ShellOut (False);\n            return Key_Refresh;\n         when Character'Val (Character'Pos ('r') mod 16#20#) => --  CTRL('r')\n            End_Windows;\n            Refresh;\n            return Key_Refresh;\n         when Character'Val (Character'Pos ('l') mod 16#20#) => --  CTRL('l')\n            return Key_Refresh;\n         when 'U' =>\n            return Key_Cursor_Up;\n         when 'D' =>\n            return Key_Cursor_Down;\n         when 'R' =>\n            return Key_Cursor_Right;\n         when 'L' =>\n            return Key_Cursor_Left;\n         when '+' =>\n            return Key_Insert_Line;\n         when '-' =>\n            return Key_Delete_Line;\n         when '>' =>\n            return Key_Insert_Char;\n         when '<' =>\n            return Key_Delete_Char;\n            --  when ERR=>                   /* FALLTHRU */\n         when 'q' =>\n            return (Key_Exit);\n         when others =>\n            return (c);\n      end case;\n   end padgetch;\n\n   show_panner_legend : Boolean := True;\n\n   function panner_legend (line : Line_Position) return Boolean is\n      legend : constant array (0 .. 3) of String (1 .. 61) :=\n        (\n         \"Use arrow keys (or U,D,L,R) to pan, q to quit (?,t,s flags)  \",\n         \"Use ! to shell-out.  Toggle legend:?, timer:t, scroll mark:s.\",\n         \"Use +,- (or j,k) to grow/shrink the panner vertically.       \",\n         \"Use <,> (or h,l) to grow/shrink the panner horizontally.     \");\n      legendsize : constant := 4;\n\n      n : constant Integer := legendsize - Integer (Lines - line);\n   begin\n      if line < Lines and n >= 0 then\n         Move_Cursor (Line => line, Column => 0);\n         if show_panner_legend then\n            Add (Str => legend (n));\n         end if;\n         Clear_To_End_Of_Line;\n         return show_panner_legend;\n      end if;\n      return False;\n   end panner_legend;\n\n   procedure panner_legend (line : Line_Position) is\n   begin\n      if not panner_legend (line) then\n         Beep;\n      end if;\n   end panner_legend;\n\n   procedure panner_h_cleanup (from_y : Line_Position;\n                               from_x : Column_Position;\n                               to_x   : Column_Position) is\n   begin\n      if not panner_legend (from_y) then\n         do_h_line (from_y, from_x, Blank2, to_x);\n      end if;\n   end panner_h_cleanup;\n\n   procedure panner_v_cleanup (from_y : Line_Position;\n                               from_x : Column_Position;\n                               to_y   : Line_Position) is\n   begin\n      if not panner_legend (from_y) then\n         do_v_line (from_y, from_x, Blank2, to_y);\n      end if;\n   end panner_v_cleanup;\n\n   procedure panner (pad    : Window;\n                     top_xp : Column_Position;\n                     top_yp : Line_Position;\n                     portyp : Line_Position;\n                     portxp : Column_Position;\n                     pgetc  : myfunc) is\n\n      function f (y : Line_Position) return Line_Position;\n      function f (x : Column_Position) return Column_Position;\n      function greater (y1, y2 : Line_Position) return Integer;\n      function greater (x1, x2 : Column_Position) return Integer;\n\n      top_x : Column_Position := top_xp;\n      top_y : Line_Position := top_yp;\n      porty : Line_Position := portyp;\n      portx : Column_Position := portxp;\n\n      --  f[x] returns max[x - 1, 0]\n      function f (y : Line_Position) return Line_Position is\n      begin\n         if y > 0 then\n            return y - 1;\n         else\n            return y; -- 0\n         end if;\n      end f;\n\n      function f (x : Column_Position) return Column_Position is\n      begin\n         if x > 0 then\n            return x - 1;\n         else\n            return x; -- 0\n         end if;\n      end f;\n\n      function greater (y1, y2 : Line_Position) return Integer is\n      begin\n         if y1 > y2 then\n            return 1;\n         else\n            return 0;\n         end if;\n      end greater;\n\n      function greater (x1, x2 : Column_Position) return Integer is\n      begin\n         if x1 > x2 then\n            return 1;\n         else\n            return 0;\n         end if;\n      end greater;\n\n      pymax : Line_Position;\n      basey : Line_Position := 0;\n      pxmax : Column_Position;\n      basex : Column_Position := 0;\n      c : Key_Code;\n      scrollers : Boolean := True;\n      before, after : timestruct;\n      timing : Boolean := True;\n\n      package floatio is new Ada.Text_IO.Float_IO (Long_Float);\n   begin\n      Get_Size (pad, pymax, pxmax);\n      Allow_Scrolling (Mode => False); -- we don't want stdscr to scroll!\n\n      c := Key_Refresh;\n      loop\n         --  During shell-out, the user may have resized the window.  Adjust\n         --  the port size of the pad to accommodate this.  Ncurses\n         --  automatically resizes all of the normal windows to fit on the\n         --  new screen.\n         if top_x > Columns then\n            top_x := Columns;\n         end if;\n         if portx > Columns then\n            portx := Columns;\n         end if;\n         if top_y > Lines then\n            top_y := Lines;\n         end if;\n         if porty > Lines then\n            porty := Lines;\n         end if;\n\n         case c is\n            when Key_Refresh | Character'Pos ('?') =>\n               if c = Key_Refresh then\n                  Erase;\n               else -- '?'\n                  show_panner_legend := not show_panner_legend;\n               end if;\n               panner_legend (Lines - 4);\n               panner_legend (Lines - 3);\n               panner_legend (Lines - 2);\n               panner_legend (Lines - 1);\n            when Character'Pos ('t') =>\n               timing := not timing;\n               if not timing then\n                  panner_legend (Lines - 1);\n               end if;\n            when Character'Pos ('s') =>\n               scrollers := not scrollers;\n\n               --  Move the top-left corner of the pad, keeping the\n               --  bottom-right corner fixed.\n            when Character'Pos ('h') =>\n               --  increase-columns: move left edge to left\n               if top_x = 0 then\n                  Beep;\n               else\n                  panner_v_cleanup (top_y, top_x, porty);\n                  top_x := top_x - 1;\n               end if;\n\n            when Character'Pos ('j') =>\n               --  decrease-lines: move top-edge down\n               if top_y >= porty then\n                  Beep;\n               else\n                  if top_y /= 0 then\n                     panner_h_cleanup (top_y - 1, f (top_x), portx);\n                  end if;\n                  top_y := top_y + 1;\n               end if;\n            when Character'Pos ('k') =>\n               --  increase-lines: move top-edge up\n               if top_y = 0 then\n                  Beep;\n               else\n                  top_y := top_y - 1;\n                  panner_h_cleanup (top_y, top_x, portx);\n               end if;\n\n            when Character'Pos ('l') =>\n               --  decrease-columns: move left-edge to right\n               if top_x >= portx then\n                  Beep;\n               else\n                  if top_x /= 0 then\n                     panner_v_cleanup (f (top_y), top_x - 1, porty);\n                  end if;\n                  top_x := top_x + 1;\n               end if;\n\n               --  Move the bottom-right corner of the pad, keeping the\n               --  top-left corner fixed.\n            when Key_Insert_Char =>\n               --  increase-columns: move right-edge to right\n               if portx >= pxmax or portx >= Columns then\n                  Beep;\n               else\n                  panner_v_cleanup (f (top_y), portx - 1, porty);\n                  portx := portx + 1;\n                  --  C had ++portx instead of portx++, weird.\n               end if;\n            when Key_Insert_Line =>\n               --  increase-lines: move bottom-edge down\n               if porty >= pymax or porty >= Lines then\n                  Beep;\n               else\n                  panner_h_cleanup (porty - 1, f (top_x), portx);\n                  porty := porty + 1;\n               end if;\n\n            when Key_Delete_Char =>\n               --  decrease-columns: move bottom edge up\n               if portx <= top_x then\n                  Beep;\n               else\n                  portx := portx - 1;\n                  panner_v_cleanup (f (top_y), portx, porty);\n               end if;\n\n            when Key_Delete_Line =>\n               --  decrease-lines\n               if porty <= top_y then\n                  Beep;\n               else\n                  porty := porty - 1;\n                  panner_h_cleanup (porty, f (top_x), portx);\n               end if;\n            when Key_Cursor_Left =>\n               --  pan leftwards\n               if basex > 0 then\n                  basex := basex - 1;\n               else\n                  Beep;\n               end if;\n            when Key_Cursor_Right =>\n               --  pan rightwards\n               --  if (basex + portx - (pymax > porty) < pxmax)\n               if basex + portx -\n                   Column_Position (greater (pymax, porty)) < pxmax\n               then\n                  --  if basex + portx  < pxmax or\n                  --      (pymax > porty and basex + portx - 1 < pxmax) then\n                  basex := basex + 1;\n               else\n                  Beep;\n               end if;\n\n            when Key_Cursor_Up =>\n               --  pan upwards\n               if basey > 0 then\n                  basey := basey - 1;\n               else\n                  Beep;\n               end if;\n\n            when Key_Cursor_Down =>\n               --  pan downwards\n               --  same as if (basey + porty - (pxmax > portx) < pymax)\n               if basey + porty -\n                   Line_Position (greater (pxmax, portx)) < pymax\n               then\n                  --  if (basey + porty  < pymax) or\n                  --      (pxmax > portx and basey + porty - 1 < pymax) then\n                  basey := basey + 1;\n               else\n                  Beep;\n               end if;\n\n            when  Character'Pos ('H') |\n              Key_Home |\n              Key_Find =>\n               basey := 0;\n\n            when   Character'Pos ('E') |\n              Key_End |\n              Key_Select =>\n               if pymax < porty then\n                  basey := 0;\n               else\n                  basey := pymax - porty;\n               end if;\n\n            when others =>\n               Beep;\n         end case;\n\n         --  more writing off the screen.\n         --  Interestingly, the exception is not handled if\n         --  we put a block around this.\n         --  declare --begin\n         if top_y /= 0 and top_x /= 0 then\n            Add (Line => top_y - 1, Column => top_x - 1,\n                 Ch => ACS_Map (ACS_Upper_Left_Corner));\n         end if;\n         if top_x /= 0 then\n            do_v_line (top_y, top_x - 1, ACS_Map (ACS_Vertical_Line), porty);\n         end if;\n         if top_y /= 0 then\n            do_h_line (top_y - 1, top_x, ACS_Map (ACS_Horizontal_Line), portx);\n         end if;\n         --  exception when Curses_Exception => null; end;\n\n         --  in C was ... pxmax > portx - 1\n         if scrollers and pxmax >= portx then\n            declare\n               length : constant Column_Position := portx - top_x - 1;\n               lowend, highend : Column_Position;\n            begin\n               --  Instead of using floats, I'll use integers only.\n               lowend := top_x + (basex * length) / pxmax;\n               highend := top_x + ((basex + length) * length) / pxmax;\n\n               do_h_line (porty - 1, top_x, ACS_Map (ACS_Horizontal_Line),\n                          lowend);\n               if highend < portx then\n                  Switch_Character_Attribute\n                    (Attr => (Reverse_Video => True, others => False),\n                     On => True);\n                  do_h_line (porty - 1, lowend, Blank2, highend + 1);\n                  Switch_Character_Attribute\n                    (Attr => (Reverse_Video => True, others => False),\n                     On => False);\n                  do_h_line (porty - 1, highend + 1,\n                             ACS_Map (ACS_Horizontal_Line), portx);\n               end if;\n            end;\n         else\n            do_h_line (porty - 1, top_x, ACS_Map (ACS_Horizontal_Line), portx);\n         end if;\n\n         if scrollers and pymax >= porty then\n            declare\n               length : constant Line_Position := porty - top_y - 1;\n               lowend, highend : Line_Position;\n            begin\n               lowend := top_y + (basey * length) / pymax;\n               highend := top_y + ((basey + length) * length) / pymax;\n\n               do_v_line (top_y, portx - 1, ACS_Map (ACS_Vertical_Line),\n                          lowend);\n               if highend < porty then\n                  Switch_Character_Attribute\n                    (Attr => (Reverse_Video => True, others => False),\n                     On => True);\n                  do_v_line (lowend, portx - 1, Blank2, highend + 1);\n                  Switch_Character_Attribute\n                    (Attr => (Reverse_Video => True, others => False),\n                     On => False);\n                  do_v_line (highend + 1, portx - 1,\n                             ACS_Map (ACS_Vertical_Line), porty);\n               end if;\n            end;\n         else\n            do_v_line (top_y, portx - 1, ACS_Map (ACS_Vertical_Line), porty);\n         end if;\n\n         if top_y /= 0 then\n            Add (Line => top_y - 1, Column => portx - 1,\n                 Ch => ACS_Map (ACS_Upper_Right_Corner));\n         end if;\n         if top_x /= 0 then\n            Add (Line => porty - 1, Column => top_x - 1,\n                 Ch => ACS_Map (ACS_Lower_Left_Corner));\n         end if;\n         declare\n         begin\n            --  Here is another place where it is possible\n            --  to write to the corner of the screen.\n            Add (Line => porty - 1, Column => portx - 1,\n                 Ch => ACS_Map (ACS_Lower_Right_Corner));\n            exception\n            when Curses_Exception => null;\n         end;\n\n         before := gettime;\n\n         Refresh_Without_Update;\n\n         declare\n            --  the C version allows the panel to have a zero height\n            --  which raise the exception\n         begin\n            Refresh_Without_Update\n              (\n               pad,\n               basey, basex,\n               top_y, top_x,\n               porty - Line_Position (greater (pxmax, portx)) - 1,\n               portx - Column_Position (greater (pymax, porty)) - 1);\n            exception\n            when Curses_Exception => null;\n         end;\n\n         Update_Screen;\n\n         if timing then\n            declare\n               s : String (1 .. 7);\n               elapsed : Long_Float;\n            begin\n               after := gettime;\n               elapsed := (Long_Float (after.seconds - before.seconds) +\n                           Long_Float (after.microseconds\n                                     - before.microseconds)\n                           / 1.0e6);\n               Move_Cursor (Line => Lines - 1, Column => Columns - 20);\n               floatio.Put (s, elapsed, Aft => 3, Exp => 0);\n               Add (Str => s);\n               Refresh;\n            end;\n         end if;\n\n         c := pgetc (pad);\n         exit when c = Key_Exit;\n\n      end loop;\n\n      Allow_Scrolling (Mode => True);\n\n   end panner;\n\n   Gridsize : constant := 3;\n   Gridcount : Integer := 0;\n\n   Pad_High : constant Line_Count :=  200;\n   Pad_Wide : constant Column_Count := 200;\n   panpad : Window := New_Pad (Pad_High, Pad_Wide);\nbegin\n   if panpad = Null_Window then\n      Cannot (\"cannot create requested pad\");\n      return;\n   end if;\n\n   for i in 0 .. Pad_High - 1 loop\n      for j in 0 .. Pad_Wide - 1  loop\n         if i mod Gridsize = 0 and j mod Gridsize = 0 then\n            if i = 0 or j = 0 then\n               Add (panpad, '+');\n            else\n               --  depends on ASCII?\n               Add (panpad,\n                    Ch => Character'Val (Character'Pos ('A') +\n                                         Gridcount mod 26));\n               Gridcount := Gridcount + 1;\n            end if;\n         elsif i mod Gridsize = 0 then\n            Add (panpad, '-');\n         elsif j mod Gridsize = 0 then\n            Add (panpad, '|');\n         else\n            declare\n               --  handle the write to the lower right corner error\n            begin\n               Add (panpad, ' ');\n               exception\n               when Curses_Exception => null;\n            end;\n         end if;\n      end loop;\n   end loop;\n   panner_legend (Lines - 4);\n   panner_legend (Lines - 3);\n   panner_legend (Lines - 2);\n   panner_legend (Lines - 1);\n\n   Set_KeyPad_Mode (panpad, True);\n   --  Make the pad (initially) narrow enough that a trace file won't wrap.\n   --  We'll still be able to widen it during a test, since that's required\n   --  for testing boundaries.\n\n   panner (panpad, 2, 2, Lines - 5, Columns - 15, padgetch'Access);\n\n   Delete (panpad);\n   End_Windows; --  Hmm, Erase after End_Windows\n   Erase;\nend ncurses2.demo_pad;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}