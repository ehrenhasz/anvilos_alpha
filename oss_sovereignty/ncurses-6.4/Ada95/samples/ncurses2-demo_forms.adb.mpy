{
  "module_name": "ncurses2-demo_forms.adb",
  "hash_id": "f41213229e5caa406dadf8ad1e20fc5a61c78d569c9f8e04ff506fd6ae6999d8",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/samples/ncurses2-demo_forms.adb",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                       GNAT ncurses Binding Samples                       --\n--                                                                          --\n--                                 ncurses                                  --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020,2021 Thomas E. Dickey                                     --\n-- Copyright 2000-2011,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author: Eugene V. Melaragno <aldomel@ix.netcom.com> 2000\n--  Version Control\n--  $Revision: 1.9 $\n--  $Date: 2021/09/04 10:52:55 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith ncurses2.util; use ncurses2.util;\nwith Terminal_Interface.Curses; use Terminal_Interface.Curses;\nwith Terminal_Interface.Curses.Forms; use Terminal_Interface.Curses.Forms;\nwith Terminal_Interface.Curses.Forms.Field_User_Data;\nwith Ada.Characters.Handling;\nwith Ada.Strings;\nwith Ada.Strings.Bounded;\n\nprocedure ncurses2.demo_forms is\n   package BS is new Ada.Strings.Bounded.Generic_Bounded_Length (80);\n\n   type myptr is access Integer;\n\n   --  The C version stores a pointer in the userptr and\n   --  converts it into a long integer.\n   --  The correct, but inconvenient  way to do it is to use a\n   --  pointer to long and keep the pointer constant.\n   --  It just adds one memory piece to allocate and deallocate (not done here)\n\n   package StringData is new\n     Terminal_Interface.Curses.Forms.Field_User_Data (Integer, myptr);\n\n   function edit_secure (me : Field; c_in : Key_Code) return Key_Code;\n   function form_virtualize (f : Form; w : Window) return Key_Code;\n   function my_form_driver (f : Form; c : Key_Code) return Boolean;\n   function make_label (frow  : Line_Position;\n                        fcol  : Column_Position;\n                        label : String) return Field;\n   function make_field (frow   : Line_Position;\n                        fcol   : Column_Position;\n                        rows   : Line_Count;\n                        cols   : Column_Count;\n                        secure : Boolean) return Field;\n   procedure display_form (f : Form);\n   procedure erase_form (f : Form);\n\n   --  prints '*' instead of characters.\n   --  Not that this keeps a bug from the C version:\n   --  type in the psasword field then move off and back.\n   --  the cursor is at position one, but\n   --  this assumes it as at the end so text gets appended instead\n   --  of overwtitting.\n   function edit_secure (me : Field; c_in : Key_Code) return Key_Code is\n      rows, frow : Line_Position;\n      nrow : Natural;\n      cols, fcol : Column_Position;\n      nbuf : Buffer_Number;\n      c : Key_Code := c_in;\n      c2 :  Character;\n\n      use StringData;\n   begin\n      Info (me, rows, cols, frow, fcol, nrow, nbuf);\n      --  TODO         if result = Form_Ok and nbuf > 0 then\n      --  C version checked the return value\n      --  of Info, the Ada binding throws an exception I think.\n      if nbuf > 0 then\n         declare\n            temp : BS.Bounded_String;\n            temps : String (1 .. 10);\n            --  TODO Get_Buffer povides no information on the field length?\n            len : myptr;\n         begin\n            Get_Buffer (me, 1, Str => temps);\n            --  strcpy(temp, field_buffer(me, 1));\n            Get_User_Data (me, len);\n            temp := BS.To_Bounded_String (temps (1 .. len.all));\n            if c <= Key_Max then\n               c2 := Code_To_Char (c);\n               if Ada.Characters.Handling.Is_Graphic (c2) then\n                  BS.Append (temp, c2);\n                  len.all := len.all + 1;\n                  Set_Buffer (me, 1, BS.To_String (temp));\n                  c := Character'Pos ('*');\n               else\n                  c := 0;\n               end if;\n            else\n               case c is\n                  when  REQ_BEG_FIELD |\n                    REQ_CLR_EOF |\n                    REQ_CLR_EOL |\n                    REQ_DEL_LINE |\n                    REQ_DEL_WORD |\n                    REQ_DOWN_CHAR |\n                    REQ_END_FIELD |\n                    REQ_INS_CHAR |\n                    REQ_INS_LINE |\n                    REQ_LEFT_CHAR |\n                    REQ_NEW_LINE |\n                    REQ_NEXT_WORD |\n                    REQ_PREV_WORD |\n                    REQ_RIGHT_CHAR |\n                    REQ_UP_CHAR =>\n                     c := 0;         -- we don't want to do inline editing\n                  when REQ_CLR_FIELD =>\n                     if len.all /= 0 then\n                        temp := BS.To_Bounded_String (\"\");\n                        Set_Buffer (me, 1, BS.To_String (temp));\n                        len.all := 0;\n                     end if;\n\n                  when REQ_DEL_CHAR |\n                    REQ_DEL_PREV =>\n                     if len.all /= 0 then\n                        BS.Delete (temp, BS.Length (temp), BS.Length (temp));\n                        Set_Buffer (me, 1, BS.To_String (temp));\n                        len.all := len.all - 1;\n                     end if;\n                  when others => null;\n               end case;\n            end if;\n         end;\n      end if;\n      return c;\n   end edit_secure;\n\n   mode : Key_Code := REQ_INS_MODE;\n\n   function form_virtualize (f : Form; w : Window) return Key_Code is\n      type lookup_t is record\n         code : Key_Code;\n         result : Key_Code;\n         --  should be Form_Request_Code, but we need MAX_COMMAND + 1\n      end record;\n\n      lookup : constant array (Positive range <>) of lookup_t :=\n        (\n         (\n          Character'Pos ('A') mod 16#20#, REQ_NEXT_CHOICE\n          ),\n         (\n          Character'Pos ('B') mod 16#20#, REQ_PREV_WORD\n          ),\n         (\n          Character'Pos ('C') mod 16#20#, REQ_CLR_EOL\n          ),\n         (\n          Character'Pos ('D') mod 16#20#, REQ_DOWN_FIELD\n          ),\n         (\n          Character'Pos ('E') mod 16#20#, REQ_END_FIELD\n          ),\n         (\n          Character'Pos ('F') mod 16#20#, REQ_NEXT_PAGE\n          ),\n         (\n          Character'Pos ('G') mod 16#20#, REQ_DEL_WORD\n          ),\n         (\n          Character'Pos ('H') mod 16#20#, REQ_DEL_PREV\n          ),\n         (\n          Character'Pos ('I') mod 16#20#, REQ_INS_CHAR\n          ),\n         (\n          Character'Pos ('K') mod 16#20#, REQ_CLR_EOF\n          ),\n         (\n          Character'Pos ('L') mod 16#20#, REQ_LEFT_FIELD\n          ),\n         (\n          Character'Pos ('M') mod 16#20#, REQ_NEW_LINE\n          ),\n         (\n          Character'Pos ('N') mod 16#20#, REQ_NEXT_FIELD\n          ),\n         (\n          Character'Pos ('O') mod 16#20#, REQ_INS_LINE\n          ),\n         (\n          Character'Pos ('P') mod 16#20#, REQ_PREV_FIELD\n          ),\n         (\n          Character'Pos ('R') mod 16#20#, REQ_RIGHT_FIELD\n          ),\n         (\n          Character'Pos ('S') mod 16#20#, REQ_BEG_FIELD\n          ),\n         (\n          Character'Pos ('U') mod 16#20#, REQ_UP_FIELD\n          ),\n         (\n          Character'Pos ('V') mod 16#20#, REQ_DEL_CHAR\n          ),\n         (\n          Character'Pos ('W') mod 16#20#, REQ_NEXT_WORD\n          ),\n         (\n          Character'Pos ('X') mod 16#20#, REQ_CLR_FIELD\n          ),\n         (\n          Character'Pos ('Y') mod 16#20#, REQ_DEL_LINE\n          ),\n         (\n          Character'Pos ('Z') mod 16#20#, REQ_PREV_CHOICE\n          ),\n         (\n          Character'Pos ('[') mod 16#20#, --  ESCAPE\n          Form_Request_Code'Last + 1\n          ),\n         (\n          Key_Backspace, REQ_DEL_PREV\n          ),\n         (\n          KEY_DOWN, REQ_DOWN_CHAR\n          ),\n         (\n          Key_End, REQ_LAST_FIELD\n          ),\n         (\n          Key_Home, REQ_FIRST_FIELD\n          ),\n         (\n          KEY_LEFT, REQ_LEFT_CHAR\n          ),\n         (\n          KEY_LL, REQ_LAST_FIELD\n          ),\n         (\n          Key_Next, REQ_NEXT_FIELD\n          ),\n         (\n          KEY_NPAGE, REQ_NEXT_PAGE\n          ),\n         (\n          KEY_PPAGE, REQ_PREV_PAGE\n          ),\n         (\n          Key_Previous, REQ_PREV_FIELD\n          ),\n         (\n          KEY_RIGHT, REQ_RIGHT_CHAR\n          ),\n         (\n          KEY_UP, REQ_UP_CHAR\n          ),\n         (\n          Character'Pos ('Q') mod 16#20#, --  QUIT\n          Form_Request_Code'Last + 1      --  TODO MAX_FORM_COMMAND + 1\n          )\n         );\n\n      c : Key_Code := Getchar (w);\n      me : constant Field := Current (f);\n\n   begin\n      if c = Character'Pos (']') mod 16#20# then\n         if mode = REQ_INS_MODE then\n            mode := REQ_OVL_MODE;\n         else\n            mode := REQ_INS_MODE;\n         end if;\n         c := mode;\n      else\n         for n in lookup'Range loop\n            if lookup (n).code = c then\n               c := lookup (n).result;\n               exit;\n            end if;\n         end loop;\n      end if;\n\n      --  Force the field that the user is typing into to be in reverse video,\n      --  while the other fields are shown underlined.\n      if c <= Key_Max then\n         c := edit_secure (me, c);\n         Set_Background (me, (Reverse_Video => True, others => False));\n      elsif c <= Form_Request_Code'Last then\n         c := edit_secure (me, c);\n         Set_Background (me, (Under_Line => True, others => False));\n      end if;\n      return c;\n   end form_virtualize;\n\n   function my_form_driver (f : Form; c : Key_Code) return Boolean is\n      flag : constant Driver_Result := Driver (f, F_Validate_Field);\n   begin\n      if c = Form_Request_Code'Last + 1 and\n         flag = Form_Ok\n      then\n         return True;\n      else\n         Beep;\n         return False;\n      end if;\n   end my_form_driver;\n\n   function make_label (frow  : Line_Position;\n                        fcol  : Column_Position;\n                        label : String) return Field is\n      f : constant Field := Create (1, label'Length, frow, fcol, 0, 0);\n      o : Field_Option_Set := Get_Options (f);\n   begin\n      if f /= Null_Field then\n         Set_Buffer (f, 0, label);\n         o.Active := False;\n         Set_Options (f, o);\n      end if;\n      return f;\n   end make_label;\n\n   function make_field (frow   : Line_Position;\n                        fcol   : Column_Position;\n                        rows   : Line_Count;\n                        cols   : Column_Count;\n                        secure : Boolean) return Field is\n      f : Field;\n      use StringData;\n      len : myptr;\n   begin\n      if secure then\n         f := Create (rows, cols, frow, fcol, 0, 1);\n      else\n         f := Create (rows, cols, frow, fcol, 0, 0);\n      end if;\n\n      if f /= Null_Field then\n         Set_Background (f, (Under_Line => True, others => False));\n         len := new Integer;\n         len.all := 0;\n         Set_User_Data (f, len);\n      end if;\n      return f;\n   end make_field;\n\n   procedure display_form (f : Form) is\n      w : Window;\n      rows : Line_Count;\n      cols : Column_Count;\n   begin\n      Scale (f, rows, cols);\n\n      w := New_Window (rows + 2, cols + 4, 0, 0);\n      if w /= Null_Window then\n         Set_Window (f, w);\n         Set_Sub_Window (f, Derived_Window (w, rows, cols, 1, 2));\n         Box (w); -- 0,0\n         Set_KeyPad_Mode (w, True);\n      end if;\n\n      --  TODO if Post(f) /= Form_Ok then it is a procedure\n      declare\n      begin\n         Post (f);\n      exception\n         when\n           Eti_System_Error    |\n           Eti_Bad_Argument    |\n           Eti_Posted          |\n           Eti_Connected       |\n           Eti_Bad_State       |\n           Eti_No_Room         |\n           Eti_Not_Posted      |\n           Eti_Unknown_Command |\n           Eti_No_Match        |\n           Eti_Not_Selectable  |\n           Eti_Not_Connected   |\n           Eti_Request_Denied  |\n           Eti_Invalid_Field   |\n           Eti_Current         =>\n            Refresh (w);\n      end;\n      --  end if;\n   end display_form;\n\n   procedure erase_form (f : Form) is\n      w : Window := Get_Window (f);\n      s : Window := Get_Sub_Window (f);\n   begin\n      Post (f, False);\n      Erase (w);\n      Refresh (w);\n      Delete (s);\n      Delete (w);\n   end erase_form;\n\n   finished : Boolean := False;\n   f : constant Field_Array_Access := new Field_Array (1 .. 12);\n   secure : Field;\n   myform : Form;\n   w : Window;\n   c : Key_Code;\n   result : Driver_Result;\nbegin\n   Move_Cursor (Line => 18, Column => 0);\n   Add (Str => \"Defined form-traversal keys:   ^Q/ESC- exit form\");\n   Add (Ch => newl);\n   Add (Str => \"^N   -- go to next field       ^P  -- go to previous field\");\n   Add (Ch => newl);\n   Add (Str => \"Home -- go to first field      End -- go to last field\");\n   Add (Ch => newl);\n   Add (Str => \"^L   -- go to field to left    ^R  -- go to field to right\");\n   Add (Ch => newl);\n   Add (Str => \"^U   -- move upward to field   ^D  -- move downward to field\");\n   Add (Ch => newl);\n   Add (Str => \"^W   -- go to next word        ^B  -- go to previous word\");\n   Add (Ch => newl);\n   Add (Str => \"^S   -- go to start of field   ^E  -- go to end of field\");\n   Add (Ch => newl);\n   Add (Str => \"^H   -- delete previous char   ^Y  -- delete line\");\n   Add (Ch => newl);\n   Add (Str => \"^G   -- delete current word    ^C  -- clear to end of line\");\n   Add (Ch => newl);\n   Add (Str => \"^K   -- clear to end of field  ^X  -- clear field\");\n   Add (Ch => newl);\n   Add (Str => \"Arrow keys move within a field as you would expect.\");\n\n   Add (Line => 4, Column => 57, Str => \"Forms Entry Test\");\n\n   Refresh;\n\n   --  describe the form\n   f.all (1) := make_label (0, 15, \"Sample Form\");\n   f.all (2) := make_label (2, 0, \"Last Name\");\n   f.all (3) := make_field (3, 0, 1, 18, False);\n   f.all (4) := make_label (2, 20, \"First Name\");\n   f.all (5) := make_field (3, 20, 1, 12, False);\n   f.all (6) := make_label (2, 34, \"Middle Name\");\n   f.all (7) := make_field (3, 34, 1, 12, False);\n   f.all (8) := make_label (5, 0, \"Comments\");\n   f.all (9) := make_field (6, 0, 4, 46, False);\n   f.all (10) := make_label (5, 20, \"Password:\");\n   f.all (11) := make_field (5, 30, 1, 9, True);\n   secure := f.all (11);\n   f.all (12) := Null_Field;\n\n   myform := New_Form (f);\n\n   display_form (myform);\n\n   w := Get_Window (myform);\n   Set_Raw_Mode (SwitchOn => True);\n   Set_NL_Mode (SwitchOn => True);     --  lets us read ^M's\n   while not finished loop\n      c := form_virtualize (myform, w);\n      result := Driver (myform, c);\n      case result is\n         when Form_Ok =>\n            Add (Line => 5, Column => 57, Str => Get_Buffer (secure, 1));\n            Clear_To_End_Of_Line;\n            Refresh;\n         when Unknown_Request =>\n            finished := my_form_driver (myform, c);\n         when others =>\n            Beep;\n      end case;\n   end loop;\n\n   erase_form (myform);\n\n   --  TODO Free_Form(myform);\n   --     for (c = 0; f[c] != 0; c++) free_field(f[c]);\n   Set_Raw_Mode (SwitchOn => False);\n   Set_NL_Mode (SwitchOn => True);\n\nend ncurses2.demo_forms;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}