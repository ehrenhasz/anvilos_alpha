{
  "module_name": "ncurses2-acs_display.adb",
  "hash_id": "81449694a8235facce72f31de707df1e2f01f1d3033389b4bd1632df562009b3",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/samples/ncurses2-acs_display.adb",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                       GNAT ncurses Binding Samples                       --\n--                                                                          --\n--                                 ncurses                                  --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 2000-2006,2008 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author: Eugene V. Melaragno <aldomel@ix.netcom.com> 2000\n--  Version Control\n--  $Revision: 1.7 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith ncurses2.util; use ncurses2.util;\nwith ncurses2.genericPuts;\nwith Terminal_Interface.Curses; use Terminal_Interface.Curses;\n\nwith Ada.Strings.Unbounded;\nwith Ada.Strings.Fixed;\n\nprocedure ncurses2.acs_display is\n   use Int_IO;\n\n   procedure show_upper_chars (first : Integer);\n   function  show_1_acs (N    : Integer;\n                         name : String;\n                         code :  Attributed_Character)\n                        return Integer;\n   procedure show_acs_chars;\n\n   procedure show_upper_chars (first : Integer)  is\n      C1 : constant Boolean := (first = 128);\n      last : constant Integer := first + 31;\n      package p is new ncurses2.genericPuts (200);\n      use p;\n      use p.BS;\n      use Ada.Strings.Unbounded;\n\n      tmpa : Unbounded_String;\n      tmpb : BS.Bounded_String;\n   begin\n      Erase;\n      Switch_Character_Attribute\n        (Attr => (Bold_Character => True, others => False));\n      Move_Cursor (Line => 0, Column => 20);\n      tmpa := To_Unbounded_String (\"Display of \");\n      if C1 then\n         tmpa := tmpa & \"C1\";\n      else\n         tmpa := tmpa & \"GR\";\n      end if;\n      tmpa := tmpa & \" Character Codes \";\n      myPut (tmpb, first);\n      Append (tmpa, To_String (tmpb));\n      Append (tmpa, \" to \");\n      myPut (tmpb, last);\n      Append (tmpa, To_String (tmpb));\n      Add (Str => To_String (tmpa));\n      Switch_Character_Attribute\n        (On => False,\n         Attr => (Bold_Character => True, others => False));\n      Refresh;\n\n      for code in first .. last loop\n         declare\n            row : constant Line_Position\n                := Line_Position (4 + ((code - first) mod 16));\n            col : constant Column_Position\n                := Column_Position (((code - first) / 16) *\n                                    Integer (Columns) / 2);\n            tmp3 : String (1 .. 3);\n            tmpx : String (1 .. Integer (Columns / 4));\n            reply : Key_Code;\n         begin\n            Put (tmp3, code);\n            myPut (tmpb, code, 16);\n            tmpa := To_Unbounded_String (tmp3 & \" (\" & To_String (tmpb) & ')');\n\n            Ada.Strings.Fixed.Move (To_String (tmpa), tmpx,\n                                    Justify => Ada.Strings.Right);\n            Add (Line => row, Column => col,\n                 Str => tmpx & ' ' & ':' & ' ');\n            if C1 then\n               Set_NoDelay_Mode (Mode => True);\n            end if;\n            Add_With_Immediate_Echo (Ch => Code_To_Char (Key_Code (code)));\n            --  TODO check this\n            if C1 then\n               reply := Getchar;\n               while reply /= Key_None loop\n                  Add (Ch => Code_To_Char (reply));\n                  Nap_Milli_Seconds (10);\n                  reply := Getchar;\n               end loop;\n               Set_NoDelay_Mode (Mode => False);\n            end if;\n         end;\n      end loop;\n   end show_upper_chars;\n\n   function show_1_acs (N    : Integer;\n                        name : String;\n                        code :  Attributed_Character)\n                       return Integer is\n      height : constant Integer := 16;\n      row : constant Line_Position := Line_Position (4 + (N mod height));\n      col : constant Column_Position := Column_Position ((N / height) *\n                                                Integer (Columns) / 2);\n      tmpx : String (1 .. Integer (Columns) / 3);\n   begin\n      Ada.Strings.Fixed.Move (name, tmpx,\n                              Justify => Ada.Strings.Right,\n                              Drop => Ada.Strings.Left);\n      Add (Line => row, Column => col, Str => tmpx & ' ' & ':' & ' ');\n      --  we need more room than C because our identifiers are longer\n      --  22 chars actually\n      Add (Ch => code);\n      return N + 1;\n   end show_1_acs;\n\n   procedure show_acs_chars is\n      n : Integer;\n   begin\n      Erase;\n      Switch_Character_Attribute\n        (Attr => (Bold_Character => True, others => False));\n      Add (Line => 0, Column => 20,\n           Str => \"Display of the ACS Character Set\");\n      Switch_Character_Attribute (On => False,\n                                  Attr => (Bold_Character => True,\n                                           others => False));\n      Refresh;\n\n      --  the following is useful to generate the below\n      --  grep '^[ ]*ACS_' ../src/terminal_interface-curses.ads |\n      --  awk '{print  \"n := show_1_acs(n, \\\"\"$1\"\\\", ACS_Map(\"$1\"));\"}'\n\n      n := show_1_acs (0, \"ACS_Upper_Left_Corner\",\n                       ACS_Map (ACS_Upper_Left_Corner));\n      n := show_1_acs (n, \"ACS_Lower_Left_Corner\",\n                       ACS_Map (ACS_Lower_Left_Corner));\n      n := show_1_acs (n, \"ACS_Upper_Right_Corner\",\n                       ACS_Map (ACS_Upper_Right_Corner));\n      n := show_1_acs (n, \"ACS_Lower_Right_Corner\",\n                       ACS_Map (ACS_Lower_Right_Corner));\n      n := show_1_acs (n, \"ACS_Left_Tee\", ACS_Map (ACS_Left_Tee));\n      n := show_1_acs (n, \"ACS_Right_Tee\", ACS_Map (ACS_Right_Tee));\n      n := show_1_acs (n, \"ACS_Bottom_Tee\", ACS_Map (ACS_Bottom_Tee));\n      n := show_1_acs (n, \"ACS_Top_Tee\", ACS_Map (ACS_Top_Tee));\n      n := show_1_acs (n, \"ACS_Horizontal_Line\",\n                       ACS_Map (ACS_Horizontal_Line));\n      n := show_1_acs (n, \"ACS_Vertical_Line\", ACS_Map (ACS_Vertical_Line));\n      n := show_1_acs (n, \"ACS_Plus_Symbol\", ACS_Map (ACS_Plus_Symbol));\n      n := show_1_acs (n, \"ACS_Scan_Line_1\", ACS_Map (ACS_Scan_Line_1));\n      n := show_1_acs (n, \"ACS_Scan_Line_9\", ACS_Map (ACS_Scan_Line_9));\n      n := show_1_acs (n, \"ACS_Diamond\", ACS_Map (ACS_Diamond));\n      n := show_1_acs (n, \"ACS_Checker_Board\", ACS_Map (ACS_Checker_Board));\n      n := show_1_acs (n, \"ACS_Degree\", ACS_Map (ACS_Degree));\n      n := show_1_acs (n, \"ACS_Plus_Minus\", ACS_Map (ACS_Plus_Minus));\n      n := show_1_acs (n, \"ACS_Bullet\", ACS_Map (ACS_Bullet));\n      n := show_1_acs (n, \"ACS_Left_Arrow\", ACS_Map (ACS_Left_Arrow));\n      n := show_1_acs (n, \"ACS_Right_Arrow\", ACS_Map (ACS_Right_Arrow));\n      n := show_1_acs (n, \"ACS_Down_Arrow\", ACS_Map (ACS_Down_Arrow));\n      n := show_1_acs (n, \"ACS_Up_Arrow\", ACS_Map (ACS_Up_Arrow));\n      n := show_1_acs (n, \"ACS_Board_Of_Squares\",\n                       ACS_Map (ACS_Board_Of_Squares));\n      n := show_1_acs (n, \"ACS_Lantern\", ACS_Map (ACS_Lantern));\n      n := show_1_acs (n, \"ACS_Solid_Block\", ACS_Map (ACS_Solid_Block));\n      n := show_1_acs (n, \"ACS_Scan_Line_3\", ACS_Map (ACS_Scan_Line_3));\n      n := show_1_acs (n, \"ACS_Scan_Line_7\", ACS_Map (ACS_Scan_Line_7));\n      n := show_1_acs (n, \"ACS_Less_Or_Equal\", ACS_Map (ACS_Less_Or_Equal));\n      n := show_1_acs (n, \"ACS_Greater_Or_Equal\",\n                       ACS_Map (ACS_Greater_Or_Equal));\n      n := show_1_acs (n, \"ACS_PI\", ACS_Map (ACS_PI));\n      n := show_1_acs (n, \"ACS_Not_Equal\", ACS_Map (ACS_Not_Equal));\n      n := show_1_acs (n, \"ACS_Sterling\", ACS_Map (ACS_Sterling));\n\n      if n = 0 then\n         raise Constraint_Error;\n      end if;\n   end show_acs_chars;\n\n   c1 : Key_Code;\n   c : Character := 'a';\nbegin\n   loop\n      case c is\n         when 'a' =>\n            show_acs_chars;\n         when '0' | '1' | '2' | '3' =>\n            show_upper_chars (ctoi (c) * 32 + 128);\n         when others =>\n            null;\n      end case;\n      Add (Line => Lines - 3, Column => 0,\n           Str => \"Note: ANSI terminals may not display C1 characters.\");\n      Add (Line => Lines - 2, Column => 0,\n           Str => \"Select: a=ACS, 0=C1, 1,2,3=GR characters, q=quit\");\n      Refresh;\n      c1 := Getchar;\n      c := Code_To_Char (c1);\n      exit when c = 'q' or c = 'x';\n   end loop;\n   Pause;\n   Erase;\n   End_Windows;\nend ncurses2.acs_display;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}