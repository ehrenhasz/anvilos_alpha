{
  "module_name": "ncurses2-getch_test.adb",
  "hash_id": "062175f3dbd92b93fefc06470aaa677f000fe3f621b7500b704f39279f37b876",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/samples/ncurses2-getch_test.adb",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                       GNAT ncurses Binding Samples                       --\n--                                                                          --\n--                                 ncurses                                  --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 2000-2009,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author: Eugene V. Melaragno <aldomel@ix.netcom.com> 2000\n--  Version Control\n--  $Revision: 1.10 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\n--  Character input test\n--  test the keypad feature\n\nwith ncurses2.util; use ncurses2.util;\n\nwith Terminal_Interface.Curses; use Terminal_Interface.Curses;\nwith Terminal_Interface.Curses.Mouse; use Terminal_Interface.Curses.Mouse;\nwith Ada.Characters.Handling;\nwith Ada.Strings.Bounded;\n\nwith ncurses2.genericPuts;\n\nprocedure ncurses2.getch_test is\n   use Int_IO;\n\n   function mouse_decode (ep : Mouse_Event) return String;\n\n   function mouse_decode (ep : Mouse_Event) return String is\n      Y      : Line_Position;\n      X      : Column_Position;\n      Button : Mouse_Button;\n      State  : Button_State;\n      package BS is new Ada.Strings.Bounded.Generic_Bounded_Length (200);\n      use BS;\n      buf : Bounded_String := To_Bounded_String (\"\");\n   begin\n      --  Note that these bindings do not allow\n      --  two button states,\n      --  The C version can print {click-1, click-3} for example.\n      --  They also don't have the 'id' or z coordinate.\n      Get_Event (ep, Y, X, Button, State);\n\n      --  TODO Append (buf, \"id \"); from C version\n      Append (buf, \"at (\");\n      Append (buf, Column_Position'Image (X));\n      Append (buf, \", \");\n      Append (buf, Line_Position'Image (Y));\n      Append (buf, \") state\");\n      Append (buf, Mouse_Button'Image (Button));\n\n      Append (buf, \" = \");\n      Append (buf, Button_State'Image (State));\n      return To_String (buf);\n   end mouse_decode;\n\n   buf : String (1 .. 1024); --  TODO was BUFSIZE\n   n : Integer;\n   c : Key_Code;\n   blockflag : Timeout_Mode := Blocking;\n   firsttime : Boolean := True;\n   tmp2  : Event_Mask;\n   tmp6 : String (1 .. 6);\n   tmp20 : String (1 .. 20);\n   x : Column_Position;\n   y : Line_Position;\n   tmpx : Integer;\n   incount : Integer := 0;\n\nbegin\n   Refresh;\n   tmp2 := Start_Mouse (All_Events);\n   Add (Str => \"Delay in 10ths of a second (<CR> for blocking input)? \");\n   Set_Echo_Mode (SwitchOn => True);\n   Get (Str => buf);\n\n   Set_Echo_Mode (SwitchOn => False);\n   Set_NL_Mode (SwitchOn => False);\n\n   if Ada.Characters.Handling.Is_Digit (buf (1)) then\n      Get (Item => n, From => buf, Last => tmpx);\n      Set_Timeout_Mode (Mode => Delayed, Amount => n * 100);\n      blockflag := Delayed;\n   end if;\n\n   c := Character'Pos ('?');\n   Set_Raw_Mode (SwitchOn => True);\n   loop\n      if not firsttime then\n         Add (Str => \"Key pressed: \");\n         Put (tmp6, Integer (c), 8);\n         Add (Str => tmp6);\n         Add (Ch => ' ');\n         if c = Key_Mouse then\n            declare\n               event : Mouse_Event;\n            begin\n               event := Get_Mouse;\n               Add (Str => \"KEY_MOUSE, \");\n               Add (Str => mouse_decode (event));\n               Add (Ch => newl);\n            end;\n         elsif c >= Key_Min then\n            Key_Name (c, tmp20);\n            Add (Str => tmp20);\n            --  I used tmp and got bitten by the length problem:->\n            Add (Ch => newl);\n         elsif c > 16#80# then --  TODO fix, use constant if possible\n            declare\n               c2 : constant Character := Character'Val (c mod 16#80#);\n            begin\n               if Ada.Characters.Handling.Is_Graphic (c2) then\n                  Add (Str => \"M-\");\n                  Add (Ch => c2);\n               else\n                  Add (Str => \"M-\");\n                  Add (Str => Un_Control ((Ch => c2,\n                                           Color => Color_Pair'First,\n                                           Attr => Normal_Video)));\n               end if;\n               Add (Str => \" (high-half character)\");\n               Add (Ch => newl);\n            end;\n         else\n            declare\n               c2 : constant Character := Character'Val (c mod 16#80#);\n            begin\n               if Ada.Characters.Handling.Is_Graphic (c2) then\n                  Add (Ch => c2);\n                  Add (Str => \" (ASCII printable character)\");\n                  Add (Ch => newl);\n               else\n                  Add (Str => Un_Control ((Ch => c2,\n                                          Color => Color_Pair'First,\n                                          Attr => Normal_Video)));\n                  Add (Str => \" (ASCII control character)\");\n                  Add (Ch => newl);\n               end if;\n            end;\n         end if;\n         --  TODO I am not sure why this was in the C version\n         --  the delay statement scroll anyway.\n         Get_Cursor_Position (Line => y, Column => x);\n         if y >= Lines - 1 then\n            Move_Cursor (Line => 0, Column => 0);\n         end if;\n         Clear_To_End_Of_Line;\n      end if;\n\n      firsttime := False;\n      if c = Character'Pos ('g') then\n         declare\n            package p is new ncurses2.genericPuts (1024);\n            use p;\n            use p.BS;\n            timedout : Boolean := False;\n            boundedbuf : Bounded_String;\n         begin\n            Add (Str => \"getstr test: \");\n            Set_Echo_Mode (SwitchOn => True);\n            --  Note that if delay mode is set\n            --  Get can raise an exception.\n            --  The C version would print the string it had so far\n            --  also TODO get longer length string, like the C version\n            declare begin\n               myGet (Str => boundedbuf);\n            exception when Curses_Exception =>\n               Add (Str => \"Timed out.\");\n               Add (Ch => newl);\n               timedout := True;\n            end;\n            --  note that the Ada Get will stop reading at 1024.\n            if not timedout then\n               Set_Echo_Mode (SwitchOn => False);\n               Add (Str => \" I saw '\");\n               myAdd (Str => boundedbuf);\n               Add (Str => \"'.\");\n               Add (Ch => newl);\n            end if;\n         end;\n      elsif c = Character'Pos ('s') then\n         ShellOut (True);\n      elsif c = Character'Pos ('x') or\n            c = Character'Pos ('q') or\n           (c = Key_None and blockflag = Blocking)\n      then\n         exit;\n      elsif c = Character'Pos ('?') then\n         Add (Str => \"Type any key to see its keypad value.  Also:\");\n         Add (Ch => newl);\n         Add (Str => \"g -- triggers a getstr test\");\n         Add (Ch => newl);\n         Add (Str => \"s -- shell out\");\n         Add (Ch => newl);\n         Add (Str => \"q -- quit\");\n         Add (Ch => newl);\n         Add (Str => \"? -- repeats this help message\");\n         Add (Ch => newl);\n      end if;\n\n      loop\n         c := Getchar;\n         exit when c /= Key_None;\n         if blockflag /= Blocking then\n            Put (tmp6, incount); --  argh string length!\n            Add (Str => tmp6);\n            Add (Str => \": input timed out\");\n            Add (Ch => newl);\n         else\n            Put (tmp6, incount);\n            Add (Str => tmp6);\n            Add (Str => \": input error\");\n            Add (Ch => newl);\n            exit;\n         end if;\n         incount := incount + 1;\n      end loop;\n   end loop;\n\n   End_Mouse (tmp2);\n   Set_Timeout_Mode (Mode => Blocking, Amount => 0); --  amount is ignored\n   Set_Raw_Mode (SwitchOn => False);\n   Set_NL_Mode (SwitchOn => True);\n   Erase;\n   End_Windows;\nend ncurses2.getch_test;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}