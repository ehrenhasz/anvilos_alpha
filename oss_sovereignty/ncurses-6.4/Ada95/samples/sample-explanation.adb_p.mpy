{
  "module_name": "sample-explanation.adb_p",
  "hash_id": "ceedb0f3ab2bd613fabed946ab560d6fc8793cc71fc04dc340f9f67848b2bb66",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/samples/sample-explanation.adb_p",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                       GNAT ncurses Binding Samples                       --\n--                                                                          --\n--                           Sample.Explanation                             --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2019,2020 Thomas E. Dickey                                     --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author:  Juergen Pfeifer, 1996\n--  Version Control\n--  $Revision: 1.5 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\n--  Poor mans help system. This scans a sequential file for key lines and\n--  then reads the lines up to the next key. Those lines are presented in\n--  a window as help or explanation.\n--\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Unchecked_Deallocation;\nwith Terminal_Interface.Curses; use Terminal_Interface.Curses;\nwith Terminal_Interface.Curses.Panels; use Terminal_Interface.Curses.Panels;\n\nwith Sample.Keyboard_Handler; use Sample.Keyboard_Handler;\nwith Sample.Manifest; use Sample.Manifest;\nwith Sample.Function_Key_Setting; use Sample.Function_Key_Setting;\nwith Sample.Helpers; use Sample.Helpers;\n\npackage body Sample.Explanation is\n\n   Help_Keys : constant String := \"HELPKEYS\";\n   In_Help   : constant String := \"INHELP\";\n\n   File_Name : constant String := \"explain.txt\";\n   F : File_Type;\n\n   type Help_Line;\n   type Help_Line_Access is access Help_Line;\n   pragma Controlled (Help_Line_Access);\n   type String_Access is access String;\n   pragma Controlled (String_Access);\n\n   type Help_Line is\n      record\n         Prev, Next : Help_Line_Access;\n         Line : String_Access;\n      end record;\n\n   procedure Explain (Key : String;\n                      Win : Window);\n\n   procedure Release_String is\n     new Ada.Unchecked_Deallocation (String,\n                                     String_Access);\n   procedure Release_Help_Line is\n     new Ada.Unchecked_Deallocation (Help_Line,\n                                     Help_Line_Access);\n\n   function Search (Key : String) return Help_Line_Access;\n   procedure Release_Help (Root : in out Help_Line_Access);\n\n   function Check_File (Name : String) return Boolean;\n\n   procedure Explain (Key : String)\n   is\n   begin\n      Explain (Key, Null_Window);\n   end Explain;\n\n   procedure Explain (Key : String;\n                      Win : Window)\n   is\n      --  Retrieve the text associated with this key and display it in this\n      --  window. If no window argument is passed, the routine will create\n      --  a temporary window and use it.\n\n      function Filter_Key return Real_Key_Code;\n      procedure Unknown_Key;\n      procedure Redo;\n      procedure To_Window (C   : in out Help_Line_Access;\n                          More : in out Boolean);\n\n      Frame : Window := Null_Window;\n\n      W : Window := Win;\n      K : Real_Key_Code;\n      P : Panel;\n\n      Height   : Line_Count;\n      Width    : Column_Count;\n      Help     : Help_Line_Access := Search (Key);\n      Current  : Help_Line_Access;\n      Top_Line : Help_Line_Access;\n\n      Has_More : Boolean := True;\n\n      procedure Unknown_Key\n      is\n      begin\n         Add (W, \"Help message with ID \");\n         Add (W, Key);\n         Add (W, \" not found.\");\n         Add (W, Character'Val (10));\n         Add (W, \"Press the Function key labeled 'Quit' key to continue.\");\n      end Unknown_Key;\n\n      procedure Redo\n      is\n         H : Help_Line_Access := Top_Line;\n      begin\n         if Top_Line /= null then\n            for L in 0 .. (Height - 1) loop\n               Add (W, L, 0, H.all.Line.all);\n               exit when H.all.Next = null;\n               H := H.all.Next;\n            end loop;\n         else\n            Unknown_Key;\n         end if;\n      end Redo;\n\n      function Filter_Key return Real_Key_Code\n      is\n         K : Real_Key_Code;\n      begin\n         loop\n            K := Get_Key (W);\n            if K in Special_Key_Code'Range then\n               case K is\n                  when HELP_CODE =>\n                     if not Find_Context (In_Help) then\n                        Push_Environment (In_Help, False);\n                        Explain (In_Help, W);\n                        Pop_Environment;\n                        Redo;\n                     end if;\n                  when EXPLAIN_CODE =>\n                     if not Find_Context (Help_Keys) then\n                        Push_Environment (Help_Keys, False);\n                        Explain (Help_Keys, W);\n                        Pop_Environment;\n                        Redo;\n                     end if;\n                  when others => exit;\n               end case;\n            else\n               exit;\n            end if;\n         end loop;\n         return K;\n      end Filter_Key;\n\n      procedure To_Window (C   : in out Help_Line_Access;\n                          More : in out Boolean)\n      is\n         L : Line_Position := 0;\n      begin\n         loop\n            Add (W, L, 0, C.all.Line.all);\n            L := L + 1;\n            exit when C.all.Next = null or else L = Height;\n            C := C.all.Next;\n         end loop;\n         if C.all.Next /= null then\n            pragma Assert (L = Height);\n            More := True;\n         else\n            More := False;\n         end if;\n      end To_Window;\n\n   begin\n      if W = Null_Window then\n         Push_Environment (\"HELP\");\n         Default_Labels;\n         Frame := New_Window (Lines - 2, Columns, 0, 0);\n         if Has_Colors then\n            Set_Background (Win => Frame,\n                            Ch  => (Ch    => ' ',\n                                    Color => Help_Color,\n                                    Attr  => Normal_Video));\n            Set_Character_Attributes (Win   => Frame,\n                                      Attr  => Normal_Video,\n                                      Color => Help_Color);\n            Erase (Frame);\n         end if;\n         Box (Frame);\n         Set_Character_Attributes (Frame, (Reverse_Video => True,\n                                           others        => False));\n         Add (Frame, Lines - 3, 2, \"Cursor Up/Down scrolls\");\n         Set_Character_Attributes (Frame); -- Back to default.\n         Window_Title (Frame, \"Explanation\");\n         W := Derived_Window (Frame, Lines - 4, Columns - 2, 1, 1);\n         Refresh_Without_Update (Frame);\n         Get_Size (W, Height, Width);\n         Set_Meta_Mode (W);\n         Set_KeyPad_Mode (W);\n         Allow_Scrolling (W, True);\n         Set_Echo_Mode (False);\n         P := Create (Frame);\n         Top (P);\n         Update_Panels;\n      else\n         Clear (W);\n         Refresh_Without_Update (W);\n      end if;\n\n      Current := Help; Top_Line := Help;\n\n      if null = Help then\n         Unknown_Key;\n         loop\n            K := Filter_Key;\n            exit when K = QUIT_CODE;\n         end loop;\n      else\n         To_Window (Current, Has_More);\n         if Has_More then\n            --  This means there are more lines available, so we have to go\n            --  into a scroll manager.\n            loop\n               K := Filter_Key;\n               if K in Special_Key_Code'Range then\n                  case K is\n                     when Key_Cursor_Down =>\n                        if Current.all.Next /= null then\n                           Move_Cursor (W, Height - 1, 0);\n                           Scroll (W, 1);\n                           Current := Current.all.Next;\n                           Top_Line := Top_Line.all.Next;\n                           Add (W, Current.all.Line.all);\n                        end if;\n                     when Key_Cursor_Up =>\n                        if Top_Line.all.Prev /= null then\n                           Move_Cursor (W, 0, 0);\n                           Scroll (W, -1);\n                           Top_Line := Top_Line.all.Prev;\n                           Current := Current.all.Prev;\n                           Add (W, Top_Line.all.Line.all);\n                        end if;\n                     when QUIT_CODE => exit;\n                        when others => null;\n                  end case;\n               end if;\n            end loop;\n         else\n            loop\n               K := Filter_Key;\n               exit when K = QUIT_CODE;\n            end loop;\n         end if;\n      end if;\n\n      Clear (W);\n\n      if Frame /= Null_Window then\n         Clear (Frame);\n         Delete (P);\n         Delete (W);\n         Delete (Frame);\n         Pop_Environment;\n      end if;\n\n      Update_Panels;\n      Update_Screen;\n\n      Release_Help (Help);\n\n   end Explain;\n\n   function Search (Key : String) return Help_Line_Access\n   is\n      Last    : Natural;\n      Buffer  : String (1 .. 256);\n      Root    : Help_Line_Access := null;\n      Current : Help_Line_Access;\n      Tail    : Help_Line_Access := null;\n\n      function Next_Line return Boolean;\n\n      function Next_Line return Boolean\n      is\n         H_End : constant String := \"#END\";\n      begin\n         Get_Line (F, Buffer, Last);\n         if Last = H_End'Length and then H_End = Buffer (1 .. Last) then\n            return False;\n         else\n            return True;\n         end if;\n      end Next_Line;\n   begin\n      Reset (F);\n      Outer :\n      loop\n         exit Outer when not Next_Line;\n         if Last = (1 + Key'Length)\n           and then Key = Buffer (2 .. Last)\n           and then Buffer (1) = '#'\n         then\n            loop\n               exit when not Next_Line;\n               exit when Buffer (1) = '#';\n               Current := new Help_Line'(null, null,\n                                         new String'(Buffer (1 .. Last)));\n               if Tail = null then\n                  Release_Help (Root);\n                  Root := Current;\n               else\n                  Tail.all.Next := Current;\n                  Current.all.Prev := Tail;\n               end if;\n               Tail := Current;\n            end loop;\n            exit Outer;\n         end if;\n      end loop Outer;\n      return Root;\n   end Search;\n\n   procedure Release_Help (Root : in out Help_Line_Access)\n   is\n      Next : Help_Line_Access;\n   begin\n      loop\n         exit when Root = null;\n         Next := Root.all.Next;\n         Release_String (Root.all.Line);\n         Release_Help_Line (Root);\n         Root := Next;\n      end loop;\n   end Release_Help;\n\n   procedure Explain_Context\n   is\n   begin\n      Explain (Context);\n   end Explain_Context;\n\n   procedure Notepad (Key : String)\n   is\n      H : constant Help_Line_Access := Search (Key);\n      T : Help_Line_Access := H;\n      N : Line_Count := 1;\n      L : Line_Position := 0;\n      W : Window;\n      P : Panel;\n   begin\n      if H /= null then\n         loop\n            T := T.all.Next;\n            exit when T = null;\n            N := N + 1;\n         end loop;\n         W := New_Window (N + 2, Columns, Lines - N - 2, 0);\n         if Has_Colors then\n            Set_Background (Win => W,\n                            Ch  => (Ch    => ' ',\n                                    Color => Notepad_Color,\n                                    Attr  => Normal_Video));\n            Set_Character_Attributes (Win   => W,\n                                      Attr  => Normal_Video,\n                                      Color => Notepad_Color);\n            Erase (W);\n         end if;\n         Box (W);\n         Window_Title (W, \"Notepad\");\n         P := New_Panel (W);\n         T := H;\n         loop\n            Add (W, L + 1, 1, T.all.Line.all, Integer (Columns - 2));\n            L := L + 1;\n            T := T.all.Next;\n            exit when T = null;\n         end loop;\n         T := H;\n         Release_Help (T);\n         Refresh_Without_Update (W);\n         Notepad_To_Context (P);\n      end if;\n   end Notepad;\n\n   function Check_File (Name : String) return Boolean is\n      The_File : File_Type;\n   begin\n      Open (The_File, In_File, Name);\n      Close (The_File);\n      return True;\n   exception\n      when Name_Error =>\n         return False;\n   end Check_File;\n\nbegin\n   if Check_File\n      ($THIS_DATADIR\n       & File_Name)\n   then\n      Open (F, In_File,\n            $THIS_DATADIR\n            & File_Name);\n   elsif Check_File (File_Name) then\n      Open (F, In_File, File_Name);\n   else\n      Put_Line (Standard_Error,\n                \"The file \"\n                & File_Name\n                & \" was not found in \"\n                & $THIS_DATADIR\n                );\n      raise Name_Error;\n   end if;\nend Sample.Explanation;\n--  vile:adamode\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}