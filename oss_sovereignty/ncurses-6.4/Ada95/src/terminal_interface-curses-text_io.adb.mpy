{
  "module_name": "terminal_interface-curses-text_io.adb",
  "hash_id": "0761cce36ec27a7c4bce85b2243016eb2ca8a53910b4562bab1d98910e953081",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/src/terminal_interface-curses-text_io.adb",
  "human_readable_source": "------------------------------------------------------------------------------\n--                                                                          --\n--                           GNAT ncurses Binding                           --\n--                                                                          --\n--                     Terminal_Interface.Curses.Text_IO                    --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 1999-2011,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author:  Juergen Pfeifer, 1996\n--  Version Control:\n--  $Revision: 1.23 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\npackage body Terminal_Interface.Curses.Text_IO is\n\n   Default_Window : Window := Null_Window;\n\n   procedure Set_Window (Win : Window)\n   is\n   begin\n      Default_Window := Win;\n   end Set_Window;\n\n   function Get_Window return Window\n   is\n   begin\n      if Default_Window = Null_Window then\n         return Standard_Window;\n      else\n         return Default_Window;\n      end if;\n   end Get_Window;\n   pragma Inline (Get_Window);\n\n   procedure Flush (Win : Window)\n   is\n   begin\n      Refresh (Win);\n   end Flush;\n\n   procedure Flush\n   is\n   begin\n      Flush (Get_Window);\n   end Flush;\n\n   --------------------------------------------\n   -- Specification of line and page lengths --\n   --------------------------------------------\n\n   --  There are no set routines in this package. I assume, that you allocate\n   --  the window with an appropriate size.\n   --  A scroll-window is interpreted as an page with unbounded page length,\n   --  i.e. it returns the conventional 0 as page length.\n\n   function Line_Length (Win : Window) return Count\n   is\n      N_Lines : Line_Count;\n      N_Cols  : Column_Count;\n   begin\n      Get_Size (Win, N_Lines, N_Cols);\n      --  if Natural (N_Cols) > Natural (Count'Last) then\n      --     raise Layout_Error;\n      --  end if;\n      return Count (N_Cols);\n   end Line_Length;\n\n   function Line_Length return Count\n   is\n   begin\n      return Line_Length (Get_Window);\n   end Line_Length;\n\n   function Page_Length (Win : Window) return Count\n   is\n      N_Lines : Line_Count;\n      N_Cols  : Column_Count;\n   begin\n      if Scrolling_Allowed (Win) then\n         return 0;\n      else\n         Get_Size (Win, N_Lines, N_Cols);\n         --  if Natural (N_Lines) > Natural (Count'Last) then\n         --     raise Layout_Error;\n         --  end if;\n         return Count (N_Lines);\n      end if;\n   end Page_Length;\n\n   function Page_Length return Count\n   is\n   begin\n      return Page_Length (Get_Window);\n   end Page_Length;\n\n   ------------------------------------\n   -- Column, Line, and Page Control --\n   ------------------------------------\n   procedure New_Line (Win : Window; Spacing : Positive_Count := 1)\n   is\n      P_Size : constant Count := Page_Length (Win);\n   begin\n      if not Spacing'Valid then\n         raise Constraint_Error;\n      end if;\n\n      for I in 1 .. Spacing loop\n         if P_Size > 0 and then Line (Win) >= P_Size then\n            New_Page (Win);\n         else\n            Add (Win, ASCII.LF);\n         end if;\n      end loop;\n   end New_Line;\n\n   procedure New_Line (Spacing : Positive_Count := 1)\n   is\n   begin\n      New_Line (Get_Window, Spacing);\n   end New_Line;\n\n   procedure New_Page (Win : Window)\n   is\n   begin\n      Clear (Win);\n   end New_Page;\n\n   procedure New_Page\n   is\n   begin\n      New_Page (Get_Window);\n   end New_Page;\n\n   procedure Set_Col (Win : Window;  To : Positive_Count)\n   is\n      Y  : Line_Position;\n      X1 : Column_Position;\n      X2 : Column_Position;\n      N  : Natural;\n   begin\n      if not To'Valid then\n         raise Constraint_Error;\n      end if;\n\n      Get_Cursor_Position (Win, Y, X1);\n      N  := Natural (To); N := N - 1;\n      X2 := Column_Position (N);\n      if X1 > X2 then\n         New_Line (Win, 1);\n         X1 := 0;\n      end if;\n      if X1 < X2 then\n         declare\n            Filler : constant String (Integer (X1) .. (Integer (X2) - 1))\n              := (others => ' ');\n         begin\n            Put (Win, Filler);\n         end;\n      end if;\n   end Set_Col;\n\n   procedure Set_Col (To : Positive_Count)\n   is\n   begin\n      Set_Col (Get_Window, To);\n   end Set_Col;\n\n   procedure Set_Line (Win : Window; To : Positive_Count)\n   is\n      Y1 : Line_Position;\n      Y2 : Line_Position;\n      X  : Column_Position;\n      N  : Natural;\n   begin\n      if not To'Valid then\n         raise Constraint_Error;\n      end if;\n\n      Get_Cursor_Position (Win, Y1, X);\n      pragma Warnings (Off, X);         --  unreferenced\n      N  := Natural (To); N := N - 1;\n      Y2 := Line_Position (N);\n      if Y2 < Y1 then\n         New_Page (Win);\n         Y1 := 0;\n      end if;\n      if Y1 < Y2 then\n         New_Line (Win, Positive_Count (Y2 - Y1));\n      end if;\n   end Set_Line;\n\n   procedure Set_Line (To : Positive_Count)\n   is\n   begin\n      Set_Line (Get_Window, To);\n   end Set_Line;\n\n   function Col (Win : Window) return Positive_Count\n   is\n      Y : Line_Position;\n      X : Column_Position;\n      N : Natural;\n   begin\n      Get_Cursor_Position (Win, Y, X);\n      N := Natural (X); N := N + 1;\n      --  if N > Natural (Count'Last) then\n      --     raise Layout_Error;\n      --  end if;\n      return Positive_Count (N);\n   end Col;\n\n   function Col return Positive_Count\n   is\n   begin\n      return Col (Get_Window);\n   end Col;\n\n   function Line (Win : Window) return Positive_Count\n   is\n      Y : Line_Position;\n      X : Column_Position;\n      N : Natural;\n   begin\n      Get_Cursor_Position (Win, Y, X);\n      N := Natural (Y); N := N + 1;\n      --  if N > Natural (Count'Last) then\n      --     raise Layout_Error;\n      --  end if;\n      return Positive_Count (N);\n   end Line;\n\n   function Line return Positive_Count\n   is\n   begin\n      return Line (Get_Window);\n   end Line;\n\n   -----------------------\n   -- Characters Output --\n   -----------------------\n\n   procedure Put (Win  : Window; Item : Character)\n   is\n      P_Size : constant Count := Page_Length (Win);\n      Y : Line_Position;\n      X : Column_Position;\n      L : Line_Count;\n      C : Column_Count;\n   begin\n      if P_Size > 0 then\n         Get_Cursor_Position (Win, Y, X);\n         Get_Size (Win, L, C);\n         if (Y + 1) = L and then (X + 1) = C then\n            New_Page (Win);\n         end if;\n      end if;\n      Add (Win, Item);\n   end Put;\n\n   procedure Put (Item : Character)\n   is\n   begin\n      Put (Get_Window, Item);\n   end Put;\n\n   --------------------\n   -- Strings-Output --\n   --------------------\n\n   procedure Put (Win  : Window; Item : String)\n   is\n      P_Size : constant Count := Page_Length (Win);\n      Y : Line_Position;\n      X : Column_Position;\n      L : Line_Count;\n      C : Column_Count;\n   begin\n      if P_Size > 0 then\n         Get_Cursor_Position (Win, Y, X);\n         Get_Size (Win, L, C);\n         if (Y + 1) = L and then (X + 1 + Item'Length) >= C then\n            New_Page (Win);\n         end if;\n      end if;\n      Add (Win, Item);\n   end Put;\n\n   procedure Put (Item : String)\n   is\n   begin\n      Put (Get_Window, Item);\n   end Put;\n\n   procedure Put_Line\n     (Win  : Window;\n      Item : String)\n   is\n   begin\n      Put (Win, Item);\n      New_Line (Win, 1);\n   end Put_Line;\n\n   procedure Put_Line\n     (Item : String)\n   is\n   begin\n      Put_Line (Get_Window, Item);\n   end Put_Line;\n\nend Terminal_Interface.Curses.Text_IO;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}