{
  "module_name": "terminal_interface-curses.ads.m4",
  "hash_id": "de1058310b4df3b85df4f0a340d36dc70976d25b049ff6549ded8e379b1a8729",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/gen/terminal_interface-curses.ads.m4",
  "human_readable_source": "--  -*- ada -*-\ndefine(`HTMLNAME',`terminal_interface-curses__ads.htm')dnl\ninclude(M4MACRO)------------------------------------------------------------------------------\n--                                                                          --\n--                           GNAT ncurses Binding                           --\n--                                                                          --\n--                         Terminal_Interface.Curses                        --\n--                                                                          --\n--                                 S P E C                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 1998-2011,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author:  Juergen Pfeifer, 1996\n--  Version Control:\n--  $Revision: 1.48 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith System.Storage_Elements;\nwith Interfaces.C;   --  We need this for some assertions.\n\nwith Terminal_Interface.Curses_Constants;\n\npackage Terminal_Interface.Curses is\n   pragma Preelaborate (Terminal_Interface.Curses);\n   pragma Linker_Options (\"-lncurses\" & Curses_Constants.DFT_ARG_SUFFIX);\n\n   Major_Version : constant := Curses_Constants.NCURSES_VERSION_MAJOR;\n   Minor_Version : constant := Curses_Constants.NCURSES_VERSION_MINOR;\n   NC_Version : String renames Curses_Constants.Version;\n\n   type Window is private;\n   Null_Window : constant Window;\n\n   type Line_Position   is new Integer; --  line coordinate\n   type Column_Position is new Integer; --  column coordinate\n\n   subtype Line_Count   is Line_Position   range 1 .. Line_Position'Last;\n   --  Type to count lines. We do not allow null windows, so must be positive\n   subtype Column_Count is Column_Position range 1 .. Column_Position'Last;\n   --  Type to count columns. We do not allow null windows, so must be positive\n\n   type Key_Code is new Integer;\n   --  That is anything including real characters, special keys and logical\n   --  request codes.\n\n   --  FIXME: The \"-1\" should be Curses_Err\n   subtype Real_Key_Code is Key_Code range -1 .. Curses_Constants.KEY_MAX;\n   --  This are the codes that potentially represent a real keystroke.\n   --  Not all codes may be possible on a specific terminal. To check the\n   --  availability of a special key, the Has_Key function is provided.\n\n   subtype Special_Key_Code is Real_Key_Code\n     range Curses_Constants. KEY_MIN - 1 .. Real_Key_Code'Last;\n   --  Type for a function- or special key number\n\n   subtype Normal_Key_Code is Real_Key_Code range\n     Character'Pos (Character'First) .. Character'Pos (Character'Last);\n   --  This are the codes for regular (incl. non-graphical) characters.\n\n   --  For those who like to use the original key names we produce them were\n   --  they differ from the original.\n\n   --  Constants for function- and special keys\n   Key_None                    : constant Special_Key_Code\n     := Curses_Constants.KEY_MIN - 1;\n   Key_Min                     : constant Special_Key_Code\n     := Curses_Constants.KEY_MIN;\n   Key_Break                   : constant Special_Key_Code\n     := Curses_Constants.KEY_BREAK;\n   KEY_DOWN                    : constant Special_Key_Code\n     := Curses_Constants.KEY_DOWN;\n   Key_Cursor_Down             : Special_Key_Code renames KEY_DOWN;\n   KEY_UP                      : constant Special_Key_Code\n     := Curses_Constants.KEY_UP;\n   Key_Cursor_Up               : Special_Key_Code renames KEY_UP;\n   KEY_LEFT                    : constant Special_Key_Code\n     := Curses_Constants.KEY_LEFT;\n   Key_Cursor_Left             : Special_Key_Code renames KEY_LEFT;\n   KEY_RIGHT                   : constant Special_Key_Code\n     := Curses_Constants.KEY_RIGHT;\n   Key_Cursor_Right            : Special_Key_Code renames KEY_RIGHT;\n   Key_Home                    : constant Special_Key_Code\n     := Curses_Constants.KEY_HOME;\n   Key_Backspace               : constant Special_Key_Code\n     := Curses_Constants.KEY_BACKSPACE;\n   Key_F0                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F0;\n   Key_F1                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F1;\n   Key_F2                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F2;\n   Key_F3                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F3;\n   Key_F4                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F4;\n   Key_F5                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F5;\n   Key_F6                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F6;\n   Key_F7                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F7;\n   Key_F8                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F8;\n   Key_F9                      : constant Special_Key_Code\n     := Curses_Constants.KEY_F9;\n   Key_F10                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F10;\n   Key_F11                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F11;\n   Key_F12                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F12;\n   Key_F13                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F13;\n   Key_F14                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F14;\n   Key_F15                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F15;\n   Key_F16                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F16;\n   Key_F17                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F17;\n   Key_F18                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F18;\n   Key_F19                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F19;\n   Key_F20                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F20;\n   Key_F21                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F21;\n   Key_F22                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F22;\n   Key_F23                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F23;\n   Key_F24                     : constant Special_Key_Code\n     := Curses_Constants.KEY_F24;\n   KEY_DL                      : constant Special_Key_Code\n     := Curses_Constants.KEY_DL;\n   Key_Delete_Line             : Special_Key_Code renames KEY_DL;\n   KEY_IL                      : constant Special_Key_Code\n     := Curses_Constants.KEY_IL;\n   Key_Insert_Line             : Special_Key_Code renames KEY_IL;\n   KEY_DC                      : constant Special_Key_Code\n     := Curses_Constants.KEY_DC;\n   Key_Delete_Char             : Special_Key_Code renames KEY_DC;\n   KEY_IC                      : constant Special_Key_Code\n     := Curses_Constants.KEY_IC;\n   Key_Insert_Char             : Special_Key_Code renames KEY_IC;\n   KEY_EIC                     : constant Special_Key_Code\n     := Curses_Constants.KEY_EIC;\n   Key_Exit_Insert_Mode        : Special_Key_Code renames KEY_EIC;\n   KEY_CLEAR                   : constant Special_Key_Code\n     := Curses_Constants.KEY_CLEAR;\n   Key_Clear_Screen            : Special_Key_Code renames KEY_CLEAR;\n   KEY_EOS                     : constant Special_Key_Code\n     := Curses_Constants.KEY_EOS;\n   Key_Clear_End_Of_Screen     : Special_Key_Code renames KEY_EOS;\n   KEY_EOL                     : constant Special_Key_Code\n     := Curses_Constants.KEY_EOL;\n   Key_Clear_End_Of_Line       : Special_Key_Code renames KEY_EOL;\n   KEY_SF                      : constant Special_Key_Code\n     := Curses_Constants.KEY_SF;\n   Key_Scroll_1_Forward        : Special_Key_Code renames KEY_SF;\n   KEY_SR                      : constant Special_Key_Code\n     := Curses_Constants.KEY_SR;\n   Key_Scroll_1_Backward       : Special_Key_Code renames KEY_SR;\n   KEY_NPAGE                   : constant Special_Key_Code\n     := Curses_Constants.KEY_NPAGE;\n   Key_Next_Page               : Special_Key_Code renames KEY_NPAGE;\n   KEY_PPAGE                   : constant Special_Key_Code\n     := Curses_Constants.KEY_PPAGE;\n   Key_Previous_Page           : Special_Key_Code renames KEY_PPAGE;\n   KEY_STAB                    : constant Special_Key_Code\n     := Curses_Constants.KEY_STAB;\n   Key_Set_Tab                 : Special_Key_Code renames KEY_STAB;\n   KEY_CTAB                    : constant Special_Key_Code\n     := Curses_Constants.KEY_CTAB;\n   Key_Clear_Tab               : Special_Key_Code renames KEY_CTAB;\n   KEY_CATAB                   : constant Special_Key_Code\n     := Curses_Constants.KEY_CATAB;\n   Key_Clear_All_Tabs          : Special_Key_Code renames KEY_CATAB;\n   KEY_ENTER                   : constant Special_Key_Code\n     := Curses_Constants.KEY_ENTER;\n   Key_Enter_Or_Send           : Special_Key_Code renames KEY_ENTER;\n   KEY_SRESET                  : constant Special_Key_Code\n     := Curses_Constants.KEY_SRESET;\n   Key_Soft_Reset              : Special_Key_Code renames KEY_SRESET;\n   Key_Reset                   : constant Special_Key_Code\n     := Curses_Constants.KEY_RESET;\n   Key_Print                   : constant Special_Key_Code\n     := Curses_Constants.KEY_PRINT;\n   KEY_LL                      : constant Special_Key_Code\n     := Curses_Constants.KEY_LL;\n   Key_Bottom                  : Special_Key_Code renames KEY_LL;\n   KEY_A1                      : constant Special_Key_Code\n     := Curses_Constants.KEY_A1;\n   Key_Upper_Left_Of_Keypad    : Special_Key_Code renames KEY_A1;\n   KEY_A3                      : constant Special_Key_Code\n     := Curses_Constants.KEY_A3;\n   Key_Upper_Right_Of_Keypad   : Special_Key_Code renames KEY_A3;\n   KEY_B2                      : constant Special_Key_Code\n     := Curses_Constants.KEY_B2;\n   Key_Center_Of_Keypad        : Special_Key_Code renames KEY_B2;\n   KEY_C1                      : constant Special_Key_Code\n     := Curses_Constants.KEY_C1;\n   Key_Lower_Left_Of_Keypad    : Special_Key_Code renames KEY_C1;\n   KEY_C3                      : constant Special_Key_Code\n     := Curses_Constants.KEY_C3;\n   Key_Lower_Right_Of_Keypad   : Special_Key_Code renames KEY_C3;\n   KEY_BTAB                    : constant Special_Key_Code\n     := Curses_Constants.KEY_BTAB;\n   Key_Back_Tab                : Special_Key_Code renames KEY_BTAB;\n   KEY_BEG                     : constant Special_Key_Code\n     := Curses_Constants.KEY_BEG;\n   Key_Beginning               : Special_Key_Code renames KEY_BEG;\n   Key_Cancel                  : constant Special_Key_Code\n     := Curses_Constants.KEY_CANCEL;\n   Key_Close                   : constant Special_Key_Code\n     := Curses_Constants.KEY_CLOSE;\n   Key_Command                 : constant Special_Key_Code\n     := Curses_Constants.KEY_COMMAND;\n   Key_Copy                    : constant Special_Key_Code\n     := Curses_Constants.KEY_COPY;\n   Key_Create                  : constant Special_Key_Code\n     := Curses_Constants.KEY_CREATE;\n   Key_End                     : constant Special_Key_Code\n     := Curses_Constants.KEY_END;\n   Key_Exit                    : constant Special_Key_Code\n     := Curses_Constants.KEY_EXIT;\n   Key_Find                    : constant Special_Key_Code\n     := Curses_Constants.KEY_FIND;\n   Key_Help                    : constant Special_Key_Code\n     := Curses_Constants.KEY_HELP;\n   Key_Mark                    : constant Special_Key_Code\n     := Curses_Constants.KEY_MARK;\n   Key_Message                 : constant Special_Key_Code\n     := Curses_Constants.KEY_MESSAGE;\n   Key_Move                    : constant Special_Key_Code\n     := Curses_Constants.KEY_MOVE;\n   Key_Next                    : constant Special_Key_Code\n     := Curses_Constants.KEY_NEXT;\n   Key_Open                    : constant Special_Key_Code\n     := Curses_Constants.KEY_OPEN;\n   Key_Options                 : constant Special_Key_Code\n     := Curses_Constants.KEY_OPTIONS;\n   Key_Previous                : constant Special_Key_Code\n     := Curses_Constants.KEY_PREVIOUS;\n   Key_Redo                    : constant Special_Key_Code\n     := Curses_Constants.KEY_REDO;\n   Key_Reference               : constant Special_Key_Code\n     := Curses_Constants.KEY_REFERENCE;\n   Key_Refresh                 : constant Special_Key_Code\n     := Curses_Constants.KEY_REFRESH;\n   Key_Replace                 : constant Special_Key_Code\n     := Curses_Constants.KEY_REPLACE;\n   Key_Restart                 : constant Special_Key_Code\n     := Curses_Constants.KEY_RESTART;\n   Key_Resume                  : constant Special_Key_Code\n     := Curses_Constants.KEY_RESUME;\n   Key_Save                    : constant Special_Key_Code\n     := Curses_Constants.KEY_SAVE;\n   KEY_SBEG                    : constant Special_Key_Code\n     := Curses_Constants.KEY_SBEG;\n   Key_Shift_Begin             : Special_Key_Code renames KEY_SBEG;\n   KEY_SCANCEL                 : constant Special_Key_Code\n     := Curses_Constants.KEY_SCANCEL;\n   Key_Shift_Cancel            : Special_Key_Code renames KEY_SCANCEL;\n   KEY_SCOMMAND                : constant Special_Key_Code\n     := Curses_Constants.KEY_SCOMMAND;\n   Key_Shift_Command           : Special_Key_Code renames KEY_SCOMMAND;\n   KEY_SCOPY                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SCOPY;\n   Key_Shift_Copy              : Special_Key_Code renames KEY_SCOPY;\n   KEY_SCREATE                 : constant Special_Key_Code\n     := Curses_Constants.KEY_SCREATE;\n   Key_Shift_Create            : Special_Key_Code renames KEY_SCREATE;\n   KEY_SDC                     : constant Special_Key_Code\n     := Curses_Constants.KEY_SDC;\n   Key_Shift_Delete_Char       : Special_Key_Code renames KEY_SDC;\n   KEY_SDL                     : constant Special_Key_Code\n     := Curses_Constants.KEY_SDL;\n   Key_Shift_Delete_Line       : Special_Key_Code renames KEY_SDL;\n   Key_Select                  : constant Special_Key_Code\n     := Curses_Constants.KEY_SELECT;\n   KEY_SEND                    : constant Special_Key_Code\n     := Curses_Constants.KEY_SEND;\n   Key_Shift_End               : Special_Key_Code renames KEY_SEND;\n   KEY_SEOL                    : constant Special_Key_Code\n     := Curses_Constants.KEY_SEOL;\n   Key_Shift_Clear_End_Of_Line : Special_Key_Code renames KEY_SEOL;\n   KEY_SEXIT                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SEXIT;\n   Key_Shift_Exit              : Special_Key_Code renames KEY_SEXIT;\n   KEY_SFIND                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SFIND;\n   Key_Shift_Find              : Special_Key_Code renames KEY_SFIND;\n   KEY_SHELP                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SHELP;\n   Key_Shift_Help              : Special_Key_Code renames KEY_SHELP;\n   KEY_SHOME                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SHOME;\n   Key_Shift_Home              : Special_Key_Code renames KEY_SHOME;\n   KEY_SIC                     : constant Special_Key_Code\n     := Curses_Constants.KEY_SIC;\n   Key_Shift_Insert_Char       : Special_Key_Code renames KEY_SIC;\n   KEY_SLEFT                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SLEFT;\n   Key_Shift_Cursor_Left       : Special_Key_Code renames KEY_SLEFT;\n   KEY_SMESSAGE                : constant Special_Key_Code\n     := Curses_Constants.KEY_SMESSAGE;\n   Key_Shift_Message           : Special_Key_Code renames KEY_SMESSAGE;\n   KEY_SMOVE                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SMOVE;\n   Key_Shift_Move              : Special_Key_Code renames KEY_SMOVE;\n   KEY_SNEXT                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SNEXT;\n   Key_Shift_Next_Page         : Special_Key_Code renames KEY_SNEXT;\n   KEY_SOPTIONS                : constant Special_Key_Code\n     := Curses_Constants.KEY_SOPTIONS;\n   Key_Shift_Options           : Special_Key_Code renames KEY_SOPTIONS;\n   KEY_SPREVIOUS               : constant Special_Key_Code\n     := Curses_Constants.KEY_SPREVIOUS;\n   Key_Shift_Previous_Page     : Special_Key_Code renames KEY_SPREVIOUS;\n   KEY_SPRINT                  : constant Special_Key_Code\n     := Curses_Constants.KEY_SPRINT;\n   Key_Shift_Print             : Special_Key_Code renames KEY_SPRINT;\n   KEY_SREDO                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SREDO;\n   Key_Shift_Redo              : Special_Key_Code renames KEY_SREDO;\n   KEY_SREPLACE                : constant Special_Key_Code\n     := Curses_Constants.KEY_SREPLACE;\n   Key_Shift_Replace           : Special_Key_Code renames KEY_SREPLACE;\n   KEY_SRIGHT                  : constant Special_Key_Code\n     := Curses_Constants.KEY_SRIGHT;\n   Key_Shift_Cursor_Right      : Special_Key_Code renames KEY_SRIGHT;\n   KEY_SRSUME                  : constant Special_Key_Code\n     := Curses_Constants.KEY_SRSUME;\n   Key_Shift_Resume            : Special_Key_Code renames KEY_SRSUME;\n   KEY_SSAVE                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SSAVE;\n   Key_Shift_Save              : Special_Key_Code renames KEY_SSAVE;\n   KEY_SSUSPEND                : constant Special_Key_Code\n     := Curses_Constants.KEY_SSUSPEND;\n   Key_Shift_Suspend           : Special_Key_Code renames KEY_SSUSPEND;\n   KEY_SUNDO                   : constant Special_Key_Code\n     := Curses_Constants.KEY_SUNDO;\n   Key_Shift_Undo              : Special_Key_Code renames KEY_SUNDO;\n   Key_Suspend                 : constant Special_Key_Code\n     := Curses_Constants.KEY_SUSPEND;\n   Key_Undo                    : constant Special_Key_Code\n     := Curses_Constants.KEY_UNDO;\n   Key_Mouse                   : constant Special_Key_Code\n     := Curses_Constants.KEY_MOUSE;\n   Key_Resize                  : constant Special_Key_Code\n     := Curses_Constants.KEY_RESIZE;\n   Key_Max                     : constant Special_Key_Code\n     := Special_Key_Code'Last;\n\n   subtype User_Key_Code is Key_Code\n     range (Key_Max + 129) .. Key_Code'Last;\n   --  This is reserved for user defined key codes. The range between Key_Max\n   --  and the first user code is reserved for subsystems like menu and forms.\n\n   --------------------------------------------------------------------------\n\n   type Color_Number is range -1 .. Integer (Interfaces.C.short'Last);\n   for Color_Number'Size use Interfaces.C.short'Size;\n   --  (n)curses uses a short for the color index\n   --  The model is, that a Color_Number is an index into an array of\n   --  (potentially) definable colors. Some of those indices are\n   --  predefined (see below), although they may not really exist.\n\n   Black   : constant Color_Number := Curses_Constants.COLOR_BLACK;\n   Red     : constant Color_Number := Curses_Constants.COLOR_RED;\n   Green   : constant Color_Number := Curses_Constants.COLOR_GREEN;\n   Yellow  : constant Color_Number := Curses_Constants.COLOR_YELLOW;\n   Blue    : constant Color_Number := Curses_Constants.COLOR_BLUE;\n   Magenta : constant Color_Number := Curses_Constants.COLOR_MAGENTA;\n   Cyan    : constant Color_Number := Curses_Constants.COLOR_CYAN;\n   White   : constant Color_Number := Curses_Constants.COLOR_WHITE;\n\n   type RGB_Value is range 0 .. Integer (Interfaces.C.short'Last);\n   for RGB_Value'Size use Interfaces.C.short'Size;\n   --  Some system may allow to redefine a color by setting RGB values.\n\n   type Color_Pair is range 0 .. 255;\n   for Color_Pair'Size use 8;\n   subtype Redefinable_Color_Pair is Color_Pair range 1 .. 255;\n   --  (n)curses reserves 1 Byte for the color-pair number. Color Pair 0\n   --  is fixed (Black & White). A color pair is simply a combination of\n   --  two colors described by Color_Numbers, one for the foreground and\n   --  the other for the background\n\n   type Character_Attribute_Set is\n      record\n         Stand_Out               : Boolean;\n         Under_Line              : Boolean;\n         Reverse_Video           : Boolean;\n         Blink                   : Boolean;\n         Dim_Character           : Boolean;\n         Bold_Character          : Boolean;\n         Protected_Character     : Boolean;\n         Invisible_Character     : Boolean;\n         Alternate_Character_Set : Boolean;\n         Horizontal              : Boolean;\n         Left                    : Boolean;\n         Low                     : Boolean;\n         Right                   : Boolean;\n         Top                     : Boolean;\n         Vertical                : Boolean;\n      end record;\n\n   for Character_Attribute_Set use\n      record\n         Stand_Out at 0 range\n           Curses_Constants.A_STANDOUT_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_STANDOUT_Last - Curses_Constants.Attr_First;\n         Under_Line at 0 range\n           Curses_Constants.A_UNDERLINE_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_UNDERLINE_Last - Curses_Constants.Attr_First;\n         Reverse_Video at 0 range\n           Curses_Constants.A_REVERSE_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_REVERSE_Last - Curses_Constants.Attr_First;\n         Blink at 0 range\n           Curses_Constants.A_BLINK_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_BLINK_Last - Curses_Constants.Attr_First;\n         Dim_Character at 0 range\n           Curses_Constants.A_DIM_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_DIM_Last - Curses_Constants.Attr_First;\n         Bold_Character at 0 range\n           Curses_Constants.A_BOLD_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_BOLD_Last - Curses_Constants.Attr_First;\n         Protected_Character at 0 range\n           Curses_Constants.A_PROTECT_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_PROTECT_Last - Curses_Constants.Attr_First;\n         Invisible_Character at 0 range\n           Curses_Constants.A_INVIS_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_INVIS_Last - Curses_Constants.Attr_First;\n         Alternate_Character_Set at 0 range\n           Curses_Constants.A_ALTCHARSET_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_ALTCHARSET_Last - Curses_Constants.Attr_First;\n         Horizontal at 0 range\n           Curses_Constants.A_HORIZONTAL_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_HORIZONTAL_Last - Curses_Constants.Attr_First;\n         Left at 0 range\n           Curses_Constants.A_LEFT_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_LEFT_Last - Curses_Constants.Attr_First;\n         Low at 0 range\n           Curses_Constants.A_LOW_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_LOW_Last - Curses_Constants.Attr_First;\n         Right at 0 range\n           Curses_Constants.A_RIGHT_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_RIGHT_Last - Curses_Constants.Attr_First;\n         Top at 0 range\n           Curses_Constants.A_TOP_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_TOP_Last - Curses_Constants.Attr_First;\n         Vertical at 0 range\n           Curses_Constants.A_VERTICAL_First - Curses_Constants.Attr_First\n           .. Curses_Constants.A_VERTICAL_Last - Curses_Constants.Attr_First;\n      end record;\n\n   Normal_Video : constant Character_Attribute_Set := (others => False);\n\n   type Attributed_Character is\n      record\n         Attr  : Character_Attribute_Set;\n         Color : Color_Pair;\n         Ch    : Character;\n      end record;\n   pragma Convention (C_Pass_By_Copy, Attributed_Character);\n   --  This is the counterpart for the chtype in C.\n\n   for Attributed_Character use\n      record\n         Ch    at 0 range Curses_Constants.A_CHARTEXT_First\n           .. Curses_Constants.A_CHARTEXT_Last;\n         Color at 0 range Curses_Constants.A_COLOR_First\n           .. Curses_Constants.A_COLOR_Last;\n         pragma Warnings (Off);\n         Attr  at 0 range Curses_Constants.Attr_First\n           .. Curses_Constants.Attr_Last;\n         pragma Warnings (On);\n      end record;\n   for Attributed_Character'Size use Curses_Constants.chtype_Size;\n\n   Default_Character : constant Attributed_Character\n     := (Ch    => Character'First,\n         Color => Color_Pair'First,\n         Attr  => (others => False));  --  preelaboratable Normal_Video\n\n   type Attributed_String is array (Positive range <>) of Attributed_Character;\n   pragma Convention (C, Attributed_String);\n   --  In this binding we allow strings of attributed characters.\n\n   ------------------\n   --  Exceptions  --\n   ------------------\n   Curses_Exception     : exception;\n   Wrong_Curses_Version : exception;\n\n   --  Those exceptions are raised by the ETI (Extended Terminal Interface)\n   --  subpackets for Menu and Forms handling.\n   --\n   Eti_System_Error    : exception;\n   Eti_Bad_Argument    : exception;\n   Eti_Posted          : exception;\n   Eti_Connected       : exception;\n   Eti_Bad_State       : exception;\n   Eti_No_Room         : exception;\n   Eti_Not_Posted      : exception;\n   Eti_Unknown_Command : exception;\n   Eti_No_Match        : exception;\n   Eti_Not_Selectable  : exception;\n   Eti_Not_Connected   : exception;\n   Eti_Request_Denied  : exception;\n   Eti_Invalid_Field   : exception;\n   Eti_Current         : exception;\n\n   --------------------------------------------------------------------------\n   --  External C variables\n   --  Conceptually even in C this are kind of constants, but they are\n   --  initialized and sometimes changed by the library routines at runtime\n   --  depending on the type of terminal. I believe the best way to model\n   --  this is to use functions.\n   --------------------------------------------------------------------------\n\n   function Lines            return Line_Count;\n   pragma Inline (Lines);\n\n   function Columns          return Column_Count;\n   pragma Inline (Columns);\n\n   function Tab_Size         return Natural;\n   pragma Inline (Tab_Size);\n\n   function Number_Of_Colors return Natural;\n   pragma Inline (Number_Of_Colors);\n\n   function Number_Of_Color_Pairs return Natural;\n   pragma Inline (Number_Of_Color_Pairs);\n\n   subtype ACS_Index is Character range\n     Character'Val (0) .. Character'Val (127);\n   function ACS_Map (Index : ACS_Index) return Attributed_Character;\n   pragma Import (C, ACS_Map, \"acs_map_as_function\");\n\n   --  Constants for several characters from the Alternate Character Set\n   --  You must use these constants as indices into the ACS_Map function\n   --  to get the corresponding attributed character at runtime\n   ACS_Upper_Left_Corner  : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_ULCORNER);\n   ACS_Lower_Left_Corner  : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_LLCORNER);\n   ACS_Upper_Right_Corner : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_URCORNER);\n   ACS_Lower_Right_Corner : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_LRCORNER);\n   ACS_Left_Tee           : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_LTEE);\n   ACS_Right_Tee          : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_RTEE);\n   ACS_Bottom_Tee         : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_BTEE);\n   ACS_Top_Tee            : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_TTEE);\n   ACS_Horizontal_Line    : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_HLINE);\n   ACS_Vertical_Line      : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_VLINE);\n   ACS_Plus_Symbol        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_PLUS);\n   ACS_Scan_Line_1        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_S1);\n   ACS_Scan_Line_9        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_S9);\n   ACS_Diamond            : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_DIAMOND);\n   ACS_Checker_Board      : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_CKBOARD);\n   ACS_Degree             : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_DEGREE);\n   ACS_Plus_Minus         : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_PLMINUS);\n   ACS_Bullet             : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_BULLET);\n   ACS_Left_Arrow         : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_LARROW);\n   ACS_Right_Arrow        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_RARROW);\n   ACS_Down_Arrow         : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_DARROW);\n   ACS_Up_Arrow           : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_UARROW);\n   ACS_Board_Of_Squares   : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_BOARD);\n   ACS_Lantern            : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_LANTERN);\n   ACS_Solid_Block        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_BLOCK);\n   ACS_Scan_Line_3        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_S3);\n   ACS_Scan_Line_7        : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_S7);\n   ACS_Less_Or_Equal      : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_LEQUAL);\n   ACS_Greater_Or_Equal   : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_GEQUAL);\n   ACS_PI                 : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_PI);\n   ACS_Not_Equal          : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_NEQUAL);\n   ACS_Sterling           : constant ACS_Index\n      := Character'Val (Curses_Constants.ACS_STERLING);\n\n   --  MANPAGE(`curs_initscr.3x')\n   --  | Not implemented: newterm, set_term, delscreen\n\n   --  ANCHOR(`stdscr',`Standard_Window')\n   function Standard_Window return Window;\n   --  AKA\n   pragma Import (C, Standard_Window, \"stdscr_as_function\");\n   pragma Inline (Standard_Window);\n\n   --  ANCHOR(`curscr',`Current_Window')\n   function Current_Window return Window;\n   --  AKA\n   pragma Import (C, Current_Window, \"curscr_as_function\");\n   pragma Inline (Current_Window);\n\n   --  ANCHOR(`initscr()',`Init_Screen')\n   procedure Init_Screen;\n\n   --  ANCHOR(`initscr()',`Init_Windows')\n   procedure Init_Windows renames Init_Screen;\n   --  AKA\n   pragma Inline (Init_Screen);\n   --  pragma Inline (Init_Windows);\n\n   --  ANCHOR(`endwin()',`End_Windows')\n   procedure End_Windows;\n   --  AKA\n   procedure End_Screen renames End_Windows;\n   pragma Inline (End_Windows);\n   --  pragma Inline (End_Screen);\n\n   --  ANCHOR(`isendwin()',`Is_End_Window')\n   function Is_End_Window return Boolean;\n   --  AKA\n   pragma Inline (Is_End_Window);\n\n   --  MANPAGE(`curs_move.3x')\n\n   --  ANCHOR(`wmove()',`Move_Cursor')\n   procedure Move_Cursor (Win    : Window := Standard_Window;\n                          Line   : Line_Position;\n                          Column : Column_Position);\n   --  AKA\n   --  ALIAS(`move()')\n   pragma Inline (Move_Cursor);\n\n   --  MANPAGE(`curs_addch.3x')\n\n   --  ANCHOR(`waddch()',`Add')\n   procedure Add (Win : Window := Standard_Window;\n                  Ch  : Attributed_Character);\n   --  AKA\n   --  ALIAS(`addch()')\n\n   procedure Add (Win : Window := Standard_Window;\n                  Ch  : Character);\n   --  Add a single character at the current logical cursor position to\n   --  the window. Use the current windows attributes.\n\n   --  ANCHOR(`mvwaddch()',`Add')\n   procedure Add\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Ch     : Attributed_Character);\n   --  AKA\n   --  ALIAS(`mvaddch()')\n\n   procedure Add\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Ch     : Character);\n   --  Move to the position and add a single character into the window\n   --  There are more Add routines, so the Inline pragma follows later\n\n   --  ANCHOR(`wechochar()',`Add_With_Immediate_Echo')\n   procedure Add_With_Immediate_Echo\n     (Win : Window := Standard_Window;\n      Ch  : Attributed_Character);\n   --  AKA\n   --  ALIAS(`echochar()')\n\n   procedure Add_With_Immediate_Echo\n     (Win : Window := Standard_Window;\n      Ch  : Character);\n   --  Add a character and do an immediate refresh of the screen.\n   pragma Inline (Add_With_Immediate_Echo);\n\n   --  MANPAGE(`curs_window.3x')\n   --  Not Implemented: wcursyncup\n\n   --  ANCHOR(`newwin()',`Create')\n   function Create\n     (Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window;\n   --  Not Implemented: Default Number_Of_Lines, Number_Of_Columns\n   --  the C version lets them be 0, see the man page.\n   --  AKA\n   pragma Inline (Create);\n\n   function New_Window\n     (Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window\n     renames Create;\n   --  pragma Inline (New_Window);\n\n   --  ANCHOR(`delwin()',`Delete')\n   procedure Delete (Win : in out Window);\n   --  AKA\n   --  Reset Win to Null_Window\n   pragma Inline (Delete);\n\n   --  ANCHOR(`subwin()',`Sub_Window')\n   function Sub_Window\n     (Win                   : Window := Standard_Window;\n      Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window;\n   --  AKA\n   pragma Inline (Sub_Window);\n\n   --  ANCHOR(`derwin()',`Derived_Window')\n   function Derived_Window\n     (Win                   : Window := Standard_Window;\n      Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window;\n   --  AKA\n   pragma Inline (Derived_Window);\n\n   --  ANCHOR(`dupwin()',`Duplicate')\n   function Duplicate (Win : Window) return Window;\n   --  AKA\n   pragma Inline (Duplicate);\n\n   --  ANCHOR(`mvwin()',`Move_Window')\n   procedure Move_Window (Win    : Window;\n                          Line   : Line_Position;\n                          Column : Column_Position);\n   --  AKA\n   pragma Inline (Move_Window);\n\n   --  ANCHOR(`mvderwin()',`Move_Derived_Window')\n   procedure Move_Derived_Window (Win    : Window;\n                                  Line   : Line_Position;\n                                  Column : Column_Position);\n   --  AKA\n   pragma Inline (Move_Derived_Window);\n\n   --  ANCHOR(`wsyncup()',`Synchronize_Upwards')\n   procedure Synchronize_Upwards (Win : Window);\n   --  AKA\n   pragma Import (C, Synchronize_Upwards, \"wsyncup\");\n\n   --  ANCHOR(`wsyncdown()',`Synchronize_Downwards')\n   procedure Synchronize_Downwards (Win : Window);\n   --  AKA\n   pragma Import (C, Synchronize_Downwards, \"wsyncdown\");\n\n   --  ANCHOR(`syncok()',`Set_Synch_Mode')\n   procedure Set_Synch_Mode (Win  : Window := Standard_Window;\n                             Mode : Boolean := False);\n   --  AKA\n   pragma Inline (Set_Synch_Mode);\n\n   --  MANPAGE(`curs_addstr.3x')\n\n   --  ANCHOR(`waddnstr()',`Add')\n   procedure Add (Win : Window := Standard_Window;\n                  Str : String;\n                  Len : Integer := -1);\n   --  AKA\n   --  ALIAS(`waddstr()')\n   --  ALIAS(`addnstr()')\n   --  ALIAS(`addstr()')\n\n   --  ANCHOR(`mvwaddnstr()',`Add')\n   procedure Add (Win    : Window := Standard_Window;\n                  Line   : Line_Position;\n                  Column : Column_Position;\n                  Str    : String;\n                  Len    : Integer := -1);\n   --  AKA\n   --  ALIAS(`mvwaddstr()')\n   --  ALIAS(`mvaddnstr()')\n   --  ALIAS(`mvaddstr()')\n\n   --  MANPAGE(`curs_addchstr.3x')\n\n   --  ANCHOR(`waddchnstr()',`Add')\n   procedure Add (Win : Window := Standard_Window;\n                  Str : Attributed_String;\n                  Len : Integer := -1);\n   --  AKA\n   --  ALIAS(`waddchstr()')\n   --  ALIAS(`addchnstr()')\n   --  ALIAS(`addchstr()')\n\n   --  ANCHOR(`mvwaddchnstr()',`Add')\n   procedure Add (Win    : Window := Standard_Window;\n                  Line   : Line_Position;\n                  Column : Column_Position;\n                  Str    : Attributed_String;\n                  Len    : Integer := -1);\n   --  AKA\n   --  ALIAS(`mvwaddchstr()')\n   --  ALIAS(`mvaddchnstr()')\n   --  ALIAS(`mvaddchstr()')\n   pragma Inline (Add);\n\n   --  MANPAGE(`curs_border.3x')\n   --  | Not implemented: mvhline,  mvwhline, mvvline, mvwvline\n   --  | use Move_Cursor then Horizontal_Line or Vertical_Line\n\n   --  ANCHOR(`wborder()',`Border')\n   procedure Border\n     (Win                       : Window := Standard_Window;\n      Left_Side_Symbol          : Attributed_Character := Default_Character;\n      Right_Side_Symbol         : Attributed_Character := Default_Character;\n      Top_Side_Symbol           : Attributed_Character := Default_Character;\n      Bottom_Side_Symbol        : Attributed_Character := Default_Character;\n      Upper_Left_Corner_Symbol  : Attributed_Character := Default_Character;\n      Upper_Right_Corner_Symbol : Attributed_Character := Default_Character;\n      Lower_Left_Corner_Symbol  : Attributed_Character := Default_Character;\n      Lower_Right_Corner_Symbol : Attributed_Character := Default_Character\n     );\n   --  AKA\n   --  ALIAS(`border()')\n   pragma Inline (Border);\n\n   --  ANCHOR(`box()',`Box')\n   procedure Box\n     (Win               : Window := Standard_Window;\n      Vertical_Symbol   : Attributed_Character := Default_Character;\n      Horizontal_Symbol : Attributed_Character := Default_Character);\n   --  AKA\n   pragma Inline (Box);\n\n   --  ANCHOR(`whline()',`Horizontal_Line')\n   procedure Horizontal_Line\n     (Win         : Window := Standard_Window;\n      Line_Size   : Natural;\n      Line_Symbol : Attributed_Character := Default_Character);\n   --  AKA\n   --  ALIAS(`hline()')\n   pragma Inline (Horizontal_Line);\n\n   --  ANCHOR(`wvline()',`Vertical_Line')\n   procedure Vertical_Line\n     (Win         : Window := Standard_Window;\n      Line_Size   : Natural;\n      Line_Symbol : Attributed_Character := Default_Character);\n   --  AKA\n   --  ALIAS(`vline()')\n   pragma Inline (Vertical_Line);\n\n   --  MANPAGE(`curs_getch.3x')\n   --  Not implemented: mvgetch, mvwgetch\n\n   --  ANCHOR(`wgetch()',`Get_Keystroke')\n   function Get_Keystroke (Win : Window := Standard_Window)\n                           return Real_Key_Code;\n   --  AKA\n   --  ALIAS(`getch()')\n   --  Get a character from the keyboard and echo it - if enabled - to the\n   --  window.\n   --  If for any reason (i.e. a timeout) we could not get a character the\n   --  returned keycode is Key_None.\n   pragma Inline (Get_Keystroke);\n\n   --  ANCHOR(`ungetch()',`Undo_Keystroke')\n   procedure Undo_Keystroke (Key : Real_Key_Code);\n   --  AKA\n   pragma Inline (Undo_Keystroke);\n\n   --  ANCHOR(`has_key()',`Has_Key')\n   function Has_Key (Key : Special_Key_Code) return Boolean;\n   --  AKA\n   pragma Inline (Has_Key);\n\n   --  |\n   --  | Some helper functions\n   --  |\n   function Is_Function_Key (Key : Special_Key_Code) return Boolean;\n   --  Return True if the Key is a function key (i.e. one of F0 .. F63)\n   pragma Inline (Is_Function_Key);\n\n   subtype Function_Key_Number is Integer range 0 .. 63;\n   --  (n)curses allows for 64 function keys.\n\n   function Function_Key (Key : Real_Key_Code) return Function_Key_Number;\n   --  Return the number of the function key. If the code is not a\n   --  function key, a CONSTRAINT_ERROR will be raised.\n   pragma Inline (Function_Key);\n\n   function Function_Key_Code (Key : Function_Key_Number) return Real_Key_Code;\n   --  Return the key code for a given function-key number.\n   pragma Inline (Function_Key_Code);\n\n   --  MANPAGE(`curs_attr.3x')\n   --  | Not implemented attr_off,  wattr_off,\n   --  |  attr_on, wattr_on, attr_set, wattr_set\n\n   --  PAIR_NUMBER\n   --  PAIR_NUMBER(c) is the same as c.Color\n\n   --  ANCHOR(`standout()',`Standout')\n   procedure Standout (Win : Window  := Standard_Window;\n                       On  : Boolean := True);\n   --  ALIAS(`wstandout()')\n   --  ALIAS(`wstandend()')\n\n   --  ANCHOR(`wattron()',`Switch_Character_Attribute')\n   procedure Switch_Character_Attribute\n     (Win  : Window := Standard_Window;\n      Attr : Character_Attribute_Set := Normal_Video;\n      On   : Boolean := True); --  if False we switch Off.\n   --  Switches those Attributes set to true in the list.\n   --  AKA\n   --  ALIAS(`wattroff()')\n   --  ALIAS(`attron()')\n   --  ALIAS(`attroff()')\n\n   --  ANCHOR(`wattrset()',`Set_Character_Attributes')\n   procedure Set_Character_Attributes\n     (Win   : Window := Standard_Window;\n      Attr  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   --  ALIAS(`attrset()')\n   pragma Inline (Set_Character_Attributes);\n\n   --  ANCHOR(`wattr_get()',`Get_Character_Attributes')\n   function Get_Character_Attribute\n     (Win : Window := Standard_Window) return Character_Attribute_Set;\n   --  AKA\n   --  ALIAS(`attr_get()')\n\n   --  ANCHOR(`wattr_get()',`Get_Character_Attribute')\n   function Get_Character_Attribute\n     (Win : Window := Standard_Window) return Color_Pair;\n   --  AKA\n   pragma Inline (Get_Character_Attribute);\n\n   --  ANCHOR(`wcolor_set()',`Set_Color')\n   procedure Set_Color (Win  : Window := Standard_Window;\n                        Pair : Color_Pair);\n   --  AKA\n   --  ALIAS(`color_set()')\n   pragma Inline (Set_Color);\n\n   --  ANCHOR(`wchgat()',`Change_Attributes')\n   procedure Change_Attributes\n     (Win   : Window := Standard_Window;\n      Count : Integer := -1;\n      Attr  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   --  ALIAS(`chgat()')\n\n   --  ANCHOR(`mvwchgat()',`Change_Attributes')\n   procedure Change_Attributes\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position := Line_Position'First;\n      Column : Column_Position := Column_Position'First;\n      Count  : Integer := -1;\n      Attr   : Character_Attribute_Set := Normal_Video;\n      Color  : Color_Pair := Color_Pair'First);\n   --  AKA\n   --  ALIAS(`mvchgat()')\n   pragma Inline (Change_Attributes);\n\n   --  MANPAGE(`curs_beep.3x')\n\n   --  ANCHOR(`beep()',`Beep')\n   procedure Beep;\n   --  AKA\n   pragma Inline (Beep);\n\n   --  ANCHOR(`flash()',`Flash_Screen')\n   procedure Flash_Screen;\n   --  AKA\n   pragma Inline (Flash_Screen);\n\n   --  MANPAGE(`curs_inopts.3x')\n\n   --  | Not implemented : typeahead\n   --\n   --  ANCHOR(`cbreak()',`Set_Cbreak_Mode')\n   procedure Set_Cbreak_Mode (SwitchOn : Boolean := True);\n   --  AKA\n   --  ALIAS(`nocbreak()')\n   pragma Inline (Set_Cbreak_Mode);\n\n   --  ANCHOR(`raw()',`Set_Raw_Mode')\n   procedure Set_Raw_Mode (SwitchOn : Boolean := True);\n   --  AKA\n   --  ALIAS(`noraw()')\n   pragma Inline (Set_Raw_Mode);\n\n   --  ANCHOR(`echo()',`Set_Echo_Mode')\n   procedure Set_Echo_Mode (SwitchOn : Boolean := True);\n   --  AKA\n   --  ALIAS(`noecho()')\n   pragma Inline (Set_Echo_Mode);\n\n   --  ANCHOR(`meta()',`Set_Meta_Mode')\n   procedure Set_Meta_Mode (Win      : Window := Standard_Window;\n                            SwitchOn : Boolean := True);\n   --  AKA\n   pragma Inline (Set_Meta_Mode);\n\n   --  ANCHOR(`keypad()',`Set_KeyPad_Mode')\n   procedure Set_KeyPad_Mode (Win      : Window := Standard_Window;\n                              SwitchOn : Boolean := True);\n   --  AKA\n   pragma Inline (Set_KeyPad_Mode);\n\n   function Get_KeyPad_Mode (Win : Window := Standard_Window)\n                             return Boolean;\n   --  This has no pendant in C. There you've to look into the WINDOWS\n   --  structure to get the value. Bad practice, not repeated in Ada.\n\n   type Half_Delay_Amount is range 1 .. 255;\n\n   --  ANCHOR(`halfdelay()',`Half_Delay')\n   procedure Half_Delay (Amount : Half_Delay_Amount);\n   --  AKA\n   pragma Inline (Half_Delay);\n\n   --  ANCHOR(`intrflush()',`Set_Flush_On_Interrupt_Mode')\n   procedure Set_Flush_On_Interrupt_Mode\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := True);\n   --  AKA\n   pragma Inline (Set_Flush_On_Interrupt_Mode);\n\n   --  ANCHOR(`qiflush()',`Set_Queue_Interrupt_Mode')\n   procedure Set_Queue_Interrupt_Mode\n     (Win   : Window := Standard_Window;\n      Flush : Boolean := True);\n   --  AKA\n   --  ALIAS(`noqiflush()')\n   pragma Inline (Set_Queue_Interrupt_Mode);\n\n   --  ANCHOR(`nodelay()',`Set_NoDelay_Mode')\n   procedure Set_NoDelay_Mode\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := False);\n   --  AKA\n   pragma Inline (Set_NoDelay_Mode);\n\n   type Timeout_Mode is (Blocking, Non_Blocking, Delayed);\n\n   --  ANCHOR(`wtimeout()',`Set_Timeout_Mode')\n   procedure Set_Timeout_Mode (Win    : Window := Standard_Window;\n                               Mode   : Timeout_Mode;\n                               Amount : Natural); --  in Milliseconds\n   --  AKA\n   --  ALIAS(`timeout()')\n   --  Instead of overloading the semantic of the sign of amount, we\n   --  introduce the Timeout_Mode parameter. This should improve\n   --  readability. For Blocking and Non_Blocking, the Amount is not\n   --  evaluated.\n   --  We do not inline this procedure.\n\n   --  ANCHOR(`notimeout()',`Set_Escape_Time_Mode')\n   procedure Set_Escape_Timer_Mode\n     (Win       : Window := Standard_Window;\n      Timer_Off : Boolean := False);\n   --  AKA\n   pragma Inline (Set_Escape_Timer_Mode);\n\n   --  MANPAGE(`curs_outopts.3x')\n\n   --  ANCHOR(`nl()',`Set_NL_Mode')\n   procedure Set_NL_Mode (SwitchOn : Boolean := True);\n   --  AKA\n   --  ALIAS(`nonl()')\n   pragma Inline (Set_NL_Mode);\n\n   --  ANCHOR(`clearok()',`Clear_On_Next_Update')\n   procedure Clear_On_Next_Update\n     (Win      : Window := Standard_Window;\n      Do_Clear : Boolean := True);\n   --  AKA\n   pragma Inline (Clear_On_Next_Update);\n\n   --  ANCHOR(`idlok()',`Use_Insert_Delete_Line')\n   procedure Use_Insert_Delete_Line\n     (Win    : Window := Standard_Window;\n      Do_Idl : Boolean := True);\n   --  AKA\n   pragma Inline (Use_Insert_Delete_Line);\n\n   --  ANCHOR(`idcok()',`Use_Insert_Delete_Character')\n   procedure Use_Insert_Delete_Character\n     (Win    : Window := Standard_Window;\n      Do_Idc : Boolean := True);\n   --  AKA\n   pragma Inline (Use_Insert_Delete_Character);\n\n   --  ANCHOR(`leaveok()',`Leave_Cursor_After_Update')\n   procedure Leave_Cursor_After_Update\n     (Win      : Window := Standard_Window;\n      Do_Leave : Boolean := True);\n   --  AKA\n   pragma Inline (Leave_Cursor_After_Update);\n\n   --  ANCHOR(`immedok()',`Immediate_Update_Mode')\n   procedure Immediate_Update_Mode\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := False);\n   --  AKA\n   pragma Inline (Immediate_Update_Mode);\n\n   --  ANCHOR(`scrollok()',`Allow_Scrolling')\n   procedure Allow_Scrolling\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := False);\n   --  AKA\n   pragma Inline (Allow_Scrolling);\n\n   function Scrolling_Allowed (Win : Window := Standard_Window) return Boolean;\n   --  There is no such function in the C interface.\n   pragma Inline (Scrolling_Allowed);\n\n   --  ANCHOR(`wsetscrreg()',`Set_Scroll_Region')\n   procedure Set_Scroll_Region\n     (Win         : Window := Standard_Window;\n      Top_Line    : Line_Position;\n      Bottom_Line : Line_Position);\n   --  AKA\n   --  ALIAS(`setscrreg()')\n   pragma Inline (Set_Scroll_Region);\n\n   --  MANPAGE(`curs_refresh.3x')\n\n   --  ANCHOR(`doupdate()',`Update_Screen')\n   procedure Update_Screen;\n   --  AKA\n   pragma Inline (Update_Screen);\n\n   --  ANCHOR(`wrefresh()',`Refresh')\n   procedure Refresh (Win : Window := Standard_Window);\n   --  AKA\n   --  There is an overloaded Refresh for Pads.\n   --  The Inline pragma appears there\n   --  ALIAS(`refresh()')\n\n   --  ANCHOR(`wnoutrefresh()',`Refresh_Without_Update')\n   procedure Refresh_Without_Update\n     (Win : Window := Standard_Window);\n   --  AKA\n   --  There is an overloaded Refresh_Without_Update for Pads.\n   --  The Inline pragma appears there\n\n   --  ANCHOR(`redrawwin()',`Redraw')\n   procedure Redraw (Win : Window := Standard_Window);\n   --  AKA\n\n   --  ANCHOR(`wredrawln()',`Redraw')\n   procedure Redraw (Win        : Window := Standard_Window;\n                     Begin_Line : Line_Position;\n                     Line_Count : Positive);\n   --  AKA\n   pragma Inline (Redraw);\n\n   --  MANPAGE(`curs_clear.3x')\n\n   --  ANCHOR(`werase()',`Erase')\n   procedure Erase (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`erase()')\n   pragma Inline (Erase);\n\n   --  ANCHOR(`wclear()',`Clear')\n   procedure Clear\n     (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`clear()')\n   pragma Inline (Clear);\n\n   --  ANCHOR(`wclrtobot()',`Clear_To_End_Of_Screen')\n   procedure Clear_To_End_Of_Screen\n     (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`clrtobot()')\n   pragma Inline (Clear_To_End_Of_Screen);\n\n   --  ANCHOR(`wclrtoeol()',`Clear_To_End_Of_Line')\n   procedure Clear_To_End_Of_Line\n     (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`clrtoeol()')\n   pragma Inline (Clear_To_End_Of_Line);\n\n   --  MANPAGE(`curs_bkgd.3x')\n\n   --  ANCHOR(`wbkgdset()',`Set_Background')\n   --  TODO: we could have Set_Background(Window; Character_Attribute_Set)\n   --  because in C it is common to see bkgdset(A_BOLD) or\n   --  bkgdset(COLOR_PAIR(n))\n   procedure Set_Background\n     (Win : Window := Standard_Window;\n      Ch  : Attributed_Character);\n   --  AKA\n   --  ALIAS(`bkgdset()')\n   pragma Inline (Set_Background);\n\n   --  ANCHOR(`wbkgd()',`Change_Background')\n   procedure Change_Background\n     (Win : Window := Standard_Window;\n      Ch  : Attributed_Character);\n   --  AKA\n   --  ALIAS(`bkgd()')\n   pragma Inline (Change_Background);\n\n   --  ANCHOR(`wbkgdget()',`Get_Background')\n   --  ? wbkgdget is not listed in curs_bkgd, getbkgd is thpough.\n   function Get_Background (Win : Window := Standard_Window)\n     return Attributed_Character;\n   --  AKA\n   --  ALIAS(`bkgdget()')\n   pragma Inline (Get_Background);\n\n   --  MANPAGE(`curs_touch.3x')\n\n   --  ANCHOR(`untouchwin()',`Untouch')\n   procedure Untouch (Win : Window := Standard_Window);\n   --  AKA\n   pragma Inline (Untouch);\n\n   --  ANCHOR(`touchwin()',`Touch')\n   procedure Touch (Win : Window := Standard_Window);\n   --  AKA\n\n   --  ANCHOR(`touchline()',`Touch')\n   procedure Touch (Win   : Window := Standard_Window;\n                    Start : Line_Position;\n                    Count : Positive);\n   --  AKA\n   pragma Inline (Touch);\n\n   --  ANCHOR(`wtouchln()',`Change_Line_Status')\n   procedure Change_Lines_Status (Win   : Window := Standard_Window;\n                                  Start : Line_Position;\n                                  Count : Positive;\n                                  State : Boolean);\n   --  AKA\n   pragma Inline (Change_Lines_Status);\n\n   --  ANCHOR(`is_linetouched()',`Is_Touched')\n   function Is_Touched (Win  : Window := Standard_Window;\n                        Line : Line_Position) return Boolean;\n   --  AKA\n\n   --  ANCHOR(`is_wintouched()',`Is_Touched')\n   function Is_Touched (Win : Window := Standard_Window) return Boolean;\n   --  AKA\n   pragma Inline (Is_Touched);\n\n   --  MANPAGE(`curs_overlay.3x')\n\n   --  ANCHOR(`copywin()',`Copy')\n   procedure Copy\n     (Source_Window            : Window;\n      Destination_Window       : Window;\n      Source_Top_Row           : Line_Position;\n      Source_Left_Column       : Column_Position;\n      Destination_Top_Row      : Line_Position;\n      Destination_Left_Column  : Column_Position;\n      Destination_Bottom_Row   : Line_Position;\n      Destination_Right_Column : Column_Position;\n      Non_Destructive_Mode     : Boolean := True);\n   --  AKA\n   pragma Inline (Copy);\n\n   --  ANCHOR(`overwrite()',`Overwrite')\n   procedure Overwrite (Source_Window      : Window;\n                        Destination_Window : Window);\n   --  AKA\n   pragma Inline (Overwrite);\n\n   --  ANCHOR(`overlay()',`Overlay')\n   procedure Overlay (Source_Window      : Window;\n                      Destination_Window : Window);\n   --  AKA\n   pragma Inline (Overlay);\n\n   --  MANPAGE(`curs_deleteln.3x')\n\n   --  ANCHOR(`winsdelln()',`Insert_Delete_Lines')\n   procedure Insert_Delete_Lines\n     (Win   : Window  := Standard_Window;\n      Lines : Integer := 1); --  default is to insert one line above\n   --  AKA\n   --  ALIAS(`insdelln()')\n   pragma Inline (Insert_Delete_Lines);\n\n   --  ANCHOR(`wdeleteln()',`Delete_Line')\n   procedure Delete_Line (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`deleteln()')\n   pragma Inline (Delete_Line);\n\n   --  ANCHOR(`winsertln()',`Insert_Line')\n   procedure Insert_Line (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`insertln()')\n   pragma Inline (Insert_Line);\n\n   --  MANPAGE(`curs_getyx.3x')\n\n   --  ANCHOR(`getmaxyx()',`Get_Size')\n   procedure Get_Size\n     (Win               : Window := Standard_Window;\n      Number_Of_Lines   : out Line_Count;\n      Number_Of_Columns : out Column_Count);\n   --  AKA\n   pragma Inline (Get_Size);\n\n   --  ANCHOR(`getbegyx()',`Get_Window_Position')\n   procedure Get_Window_Position\n     (Win             : Window := Standard_Window;\n      Top_Left_Line   : out Line_Position;\n      Top_Left_Column : out Column_Position);\n   --  AKA\n   pragma Inline (Get_Window_Position);\n\n   --  ANCHOR(`getyx()',`Get_Cursor_Position')\n   procedure Get_Cursor_Position\n     (Win    : Window := Standard_Window;\n      Line   : out Line_Position;\n      Column : out Column_Position);\n   --  AKA\n   pragma Inline (Get_Cursor_Position);\n\n   --  ANCHOR(`getparyx()',`Get_Origin_Relative_To_Parent')\n   procedure Get_Origin_Relative_To_Parent\n     (Win                : Window;\n      Top_Left_Line      : out Line_Position;\n      Top_Left_Column    : out Column_Position;\n      Is_Not_A_Subwindow : out Boolean);\n   --  AKA\n   --  Instead of placing -1 in the coordinates as return, we use a Boolean\n   --  to return the info that the window has no parent.\n   pragma Inline (Get_Origin_Relative_To_Parent);\n\n   --  MANPAGE(`curs_pad.3x')\n\n   --  ANCHOR(`newpad()',`New_Pad')\n   function New_Pad (Lines   : Line_Count;\n                     Columns : Column_Count) return Window;\n   --  AKA\n   pragma Inline (New_Pad);\n\n   --  ANCHOR(`subpad()',`Sub_Pad')\n   function Sub_Pad\n     (Pad                   : Window;\n      Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window;\n   --  AKA\n   pragma Inline (Sub_Pad);\n\n   --  ANCHOR(`prefresh()',`Refresh')\n   procedure Refresh\n     (Pad                      : Window;\n      Source_Top_Row           : Line_Position;\n      Source_Left_Column       : Column_Position;\n      Destination_Top_Row      : Line_Position;\n      Destination_Left_Column  : Column_Position;\n      Destination_Bottom_Row   : Line_Position;\n      Destination_Right_Column : Column_Position);\n   --  AKA\n   pragma Inline (Refresh);\n\n   --  ANCHOR(`pnoutrefresh()',`Refresh_Without_Update')\n   procedure Refresh_Without_Update\n     (Pad                      : Window;\n      Source_Top_Row           : Line_Position;\n      Source_Left_Column       : Column_Position;\n      Destination_Top_Row      : Line_Position;\n      Destination_Left_Column  : Column_Position;\n      Destination_Bottom_Row   : Line_Position;\n      Destination_Right_Column : Column_Position);\n   --  AKA\n   pragma Inline (Refresh_Without_Update);\n\n   --  ANCHOR(`pechochar()',`Add_Character_To_Pad_And_Echo_It')\n   procedure Add_Character_To_Pad_And_Echo_It\n     (Pad : Window;\n      Ch  : Attributed_Character);\n   --  AKA\n\n   procedure Add_Character_To_Pad_And_Echo_It\n     (Pad : Window;\n      Ch  : Character);\n   pragma Inline (Add_Character_To_Pad_And_Echo_It);\n\n   --  MANPAGE(`curs_scroll.3x')\n\n   --  ANCHOR(`wscrl()',`Scroll')\n   procedure Scroll (Win    : Window  := Standard_Window;\n                     Amount : Integer := 1);\n   --  AKA\n   --  ALIAS(`scroll()')\n   --  ALIAS(`scrl()')\n   pragma Inline (Scroll);\n\n   --  MANPAGE(`curs_delch.3x')\n\n   --  ANCHOR(`wdelch()',`Delete_Character')\n   procedure Delete_Character (Win : Window := Standard_Window);\n   --  AKA\n   --  ALIAS(`delch()')\n\n   --  ANCHOR(`mvwdelch()',`Delete_Character')\n   procedure Delete_Character\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position);\n   --  AKA\n   --  ALIAS(`mvdelch()')\n   pragma Inline (Delete_Character);\n\n   --  MANPAGE(`curs_inch.3x')\n\n   --  ANCHOR(`winch()',`Peek')\n   function Peek (Win : Window := Standard_Window)\n     return Attributed_Character;\n   --  ALIAS(`inch()')\n   --  AKA\n\n   --  ANCHOR(`mvwinch()',`Peek')\n   function Peek\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position) return Attributed_Character;\n   --  AKA\n   --  ALIAS(`mvinch()')\n   --  More Peek's follow, pragma Inline appears later.\n\n   --  MANPAGE(`curs_insch.3x')\n\n   --  ANCHOR(`winsch()',`Insert')\n   procedure Insert (Win : Window := Standard_Window;\n                     Ch  : Attributed_Character);\n   --  AKA\n   --  ALIAS(`insch()')\n\n   --  ANCHOR(`mvwinsch()',`Insert')\n   procedure Insert (Win    : Window := Standard_Window;\n                     Line   : Line_Position;\n                     Column : Column_Position;\n                     Ch     : Attributed_Character);\n   --  AKA\n   --  ALIAS(`mvinsch()')\n\n   --  MANPAGE(`curs_insstr.3x')\n\n   --  ANCHOR(`winsnstr()',`Insert')\n   procedure Insert (Win : Window := Standard_Window;\n                     Str : String;\n                     Len : Integer := -1);\n   --  AKA\n   --  ALIAS(`winsstr()')\n   --  ALIAS(`insnstr()')\n   --  ALIAS(`insstr()')\n\n   --  ANCHOR(`mvwinsnstr()',`Insert')\n   procedure Insert (Win    : Window := Standard_Window;\n                     Line   : Line_Position;\n                     Column : Column_Position;\n                     Str    : String;\n                     Len    : Integer := -1);\n   --  AKA\n   --  ALIAS(`mvwinsstr()')\n   --  ALIAS(`mvinsnstr()')\n   --  ALIAS(`mvinsstr()')\n   pragma Inline (Insert);\n\n   --  MANPAGE(`curs_instr.3x')\n\n   --  ANCHOR(`winnstr()',`Peek')\n   procedure Peek (Win : Window := Standard_Window;\n                   Str : out String;\n                   Len : Integer := -1);\n   --  AKA\n   --  ALIAS(`winstr()')\n   --  ALIAS(`innstr()')\n   --  ALIAS(`instr()')\n\n   --  ANCHOR(`mvwinnstr()',`Peek')\n   procedure Peek (Win    : Window := Standard_Window;\n                   Line   : Line_Position;\n                   Column : Column_Position;\n                   Str    : out String;\n                   Len    : Integer := -1);\n   --  AKA\n   --  ALIAS(`mvwinstr()')\n   --  ALIAS(`mvinnstr()')\n   --  ALIAS(`mvinstr()')\n\n   --  MANPAGE(`curs_inchstr.3x')\n\n   --  ANCHOR(`winchnstr()',`Peek')\n   procedure Peek (Win : Window := Standard_Window;\n                   Str : out Attributed_String;\n                   Len : Integer := -1);\n   --  AKA\n   --  ALIAS(`winchstr()')\n   --  ALIAS(`inchnstr()')\n   --  ALIAS(`inchstr()')\n\n   --  ANCHOR(`mvwinchnstr()',`Peek')\n   procedure Peek (Win    : Window := Standard_Window;\n                   Line   : Line_Position;\n                   Column : Column_Position;\n                   Str    : out Attributed_String;\n                   Len    : Integer := -1);\n   --  AKA\n   --  ALIAS(`mvwinchstr()')\n   --  ALIAS(`mvinchnstr()')\n   --  ALIAS(`mvinchstr()')\n   --  We do not inline the Peek procedures\n\n   --  MANPAGE(`curs_getstr.3x')\n\n   --  ANCHOR(`wgetnstr()',`Get')\n   procedure Get (Win : Window := Standard_Window;\n                  Str : out String;\n                  Len : Integer := -1);\n   --  AKA\n   --  ALIAS(`wgetstr()')\n   --  ALIAS(`getnstr()')\n   --  ALIAS(`getstr()')\n   --  actually getstr is not supported because that results in buffer\n   --  overflows.\n\n   --  ANCHOR(`mvwgetnstr()',`Get')\n   procedure Get (Win    : Window := Standard_Window;\n                  Line   : Line_Position;\n                  Column : Column_Position;\n                  Str    : out String;\n                  Len    : Integer := -1);\n   --  AKA\n   --  ALIAS(`mvwgetstr()')\n   --  ALIAS(`mvgetnstr()')\n   --  ALIAS(`mvgetstr()')\n   --  Get is not inlined\n\n   --  MANPAGE(`curs_slk.3x')\n\n   --  Not Implemented: slk_attr_on, slk_attr_off, slk_attr_set\n\n   type Soft_Label_Key_Format is (Three_Two_Three,\n                                  Four_Four,\n                                  PC_Style,              --  ncurses specific\n                                  PC_Style_With_Index);  --  \"\n   type Label_Number is new Positive range 1 .. 12;\n   type Label_Justification is (Left, Centered, Right);\n\n   --  ANCHOR(`slk_init()',`Init_Soft_Label_Keys')\n   procedure Init_Soft_Label_Keys\n     (Format : Soft_Label_Key_Format := Three_Two_Three);\n   --  AKA\n   pragma Inline (Init_Soft_Label_Keys);\n\n   --  ANCHOR(`slk_set()',`Set_Soft_Label_Key')\n   procedure Set_Soft_Label_Key (Label : Label_Number;\n                                 Text  : String;\n                                 Fmt   : Label_Justification := Left);\n   --  AKA\n   --  We do not inline this procedure\n\n   --  ANCHOR(`slk_refresh()',`Refresh_Soft_Label_Key')\n   procedure Refresh_Soft_Label_Keys;\n   --  AKA\n   pragma Inline (Refresh_Soft_Label_Keys);\n\n   --  ANCHOR(`slk_noutrefresh()',`Refresh_Soft_Label_Keys_Without_Update')\n   procedure Refresh_Soft_Label_Keys_Without_Update;\n   --  AKA\n   pragma Inline (Refresh_Soft_Label_Keys_Without_Update);\n\n   --  ANCHOR(`slk_label()',`Get_Soft_Label_Key')\n   procedure Get_Soft_Label_Key (Label : Label_Number;\n                                 Text  : out String);\n   --  AKA\n\n   --  ANCHOR(`slk_label()',`Get_Soft_Label_Key')\n   function Get_Soft_Label_Key (Label : Label_Number) return String;\n   --  AKA\n   --  Same as function\n   pragma Inline (Get_Soft_Label_Key);\n\n   --  ANCHOR(`slk_clear()',`Clear_Soft_Label_Keys')\n   procedure Clear_Soft_Label_Keys;\n   --  AKA\n   pragma Inline (Clear_Soft_Label_Keys);\n\n   --  ANCHOR(`slk_restore()',`Restore_Soft_Label_Keys')\n   procedure Restore_Soft_Label_Keys;\n   --  AKA\n   pragma Inline (Restore_Soft_Label_Keys);\n\n   --  ANCHOR(`slk_touch()',`Touch_Soft_Label_Keys')\n   procedure Touch_Soft_Label_Keys;\n   --  AKA\n   pragma Inline (Touch_Soft_Label_Keys);\n\n   --  ANCHOR(`slk_attron()',`Switch_Soft_Label_Key_Attributes')\n   procedure Switch_Soft_Label_Key_Attributes\n     (Attr : Character_Attribute_Set;\n      On   : Boolean := True);\n   --  AKA\n   --  ALIAS(`slk_attroff()')\n   pragma Inline (Switch_Soft_Label_Key_Attributes);\n\n   --  ANCHOR(`slk_attrset()',`Set_Soft_Label_Key_Attributes')\n   procedure Set_Soft_Label_Key_Attributes\n     (Attr  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   pragma Inline (Set_Soft_Label_Key_Attributes);\n\n   --  ANCHOR(`slk_attr()',`Get_Soft_Label_Key_Attributes')\n   function Get_Soft_Label_Key_Attributes return Character_Attribute_Set;\n   --  AKA\n\n   --  ANCHOR(`slk_attr()',`Get_Soft_Label_Key_Attributes')\n   function Get_Soft_Label_Key_Attributes return Color_Pair;\n   --  AKA\n   pragma Inline (Get_Soft_Label_Key_Attributes);\n\n   --  ANCHOR(`slk_color()',`Set_Soft_Label_Key_Color')\n   procedure Set_Soft_Label_Key_Color (Pair : Color_Pair);\n   --  AKA\n   pragma Inline (Set_Soft_Label_Key_Color);\n\n   --  MANPAGE(`keybound.3x')\n   --  Not Implemented: keybound\n\n   --  MANPAGE(`keyok.3x')\n\n   --  ANCHOR(`keyok()',`Enable_Key')\n   procedure Enable_Key (Key    : Special_Key_Code;\n                         Enable : Boolean := True);\n   --  AKA\n   pragma Inline (Enable_Key);\n\n   --  MANPAGE(`define_key.3x')\n\n   --  ANCHOR(`define_key()',`Define_Key')\n   procedure Define_Key (Definition : String;\n                         Key        : Special_Key_Code);\n   --  AKA\n   pragma Inline (Define_Key);\n\n   --  MANPAGE(`curs_util.3x')\n\n   --  | Not implemented : filter, use_env\n   --  | putwin, getwin are in the child package PutWin\n   --\n\n   --  ANCHOR(`keyname()',`Key_Name')\n   procedure Key_Name (Key  : Real_Key_Code;\n                       Name : out String);\n   --  AKA\n   --  The external name for a real keystroke.\n\n   --  ANCHOR(`keyname()',`Key_Name')\n   function Key_Name (Key  : Real_Key_Code) return String;\n   --  AKA\n   --  Same as function\n   --  We do not inline this routine\n\n   --  ANCHOR(`unctrl()',`Un_Control')\n   procedure Un_Control (Ch  : Attributed_Character;\n                         Str : out String);\n   --  AKA\n\n   --  ANCHOR(`unctrl()',`Un_Control')\n   function Un_Control (Ch  : Attributed_Character) return String;\n   --  AKA\n   --  Same as function\n   pragma Inline (Un_Control);\n\n   --  ANCHOR(`delay_output()',`Delay_Output')\n   procedure Delay_Output (Msecs : Natural);\n   --  AKA\n   pragma Inline (Delay_Output);\n\n   --  ANCHOR(`flushinp()',`Flush_Input')\n   procedure Flush_Input;\n   --  AKA\n   pragma Inline (Flush_Input);\n\n   --  MANPAGE(`curs_termattrs.3x')\n\n   --  ANCHOR(`baudrate()',`Baudrate')\n   function Baudrate return Natural;\n   --  AKA\n   pragma Inline (Baudrate);\n\n   --  ANCHOR(`erasechar()',`Erase_Character')\n   function Erase_Character return Character;\n   --  AKA\n   pragma Inline (Erase_Character);\n\n   --  ANCHOR(`killchar()',`Kill_Character')\n   function Kill_Character return Character;\n   --  AKA\n   pragma Inline (Kill_Character);\n\n   --  ANCHOR(`has_ic()',`Has_Insert_Character')\n   function Has_Insert_Character return Boolean;\n   --  AKA\n   pragma Inline (Has_Insert_Character);\n\n   --  ANCHOR(`has_il()',`Has_Insert_Line')\n   function Has_Insert_Line return Boolean;\n   --  AKA\n   pragma Inline (Has_Insert_Line);\n\n   --  ANCHOR(`termattrs()',`Supported_Attributes')\n   function Supported_Attributes return Character_Attribute_Set;\n   --  AKA\n   pragma Inline (Supported_Attributes);\n\n   --  ANCHOR(`longname()',`Long_Name')\n   procedure Long_Name (Name : out String);\n   --  AKA\n\n   --  ANCHOR(`longname()',`Long_Name')\n   function Long_Name return String;\n   --  AKA\n   --  Same as function\n   pragma Inline (Long_Name);\n\n   --  ANCHOR(`termname()',`Terminal_Name')\n   procedure Terminal_Name (Name : out String);\n   --  AKA\n\n   --  ANCHOR(`termname()',`Terminal_Name')\n   function Terminal_Name return String;\n   --  AKA\n   --  Same as function\n   pragma Inline (Terminal_Name);\n\n   --  MANPAGE(`curs_color.3x')\n\n   --  COLOR_PAIR\n   --  COLOR_PAIR(n) in C is the same as\n   --  Attributed_Character(Ch => Nul, Color => n, Attr => Normal_Video)\n   --  In C you often see something like c = c | COLOR_PAIR(n);\n   --  This is equivalent to c.Color := n;\n\n   --  ANCHOR(`start_color()',`Start_Color')\n   procedure Start_Color;\n   --  AKA\n   pragma Import (C, Start_Color, \"start_color\");\n\n   --  ANCHOR(`init_pair()',`Init_Pair')\n   procedure Init_Pair (Pair : Redefinable_Color_Pair;\n                        Fore : Color_Number;\n                        Back : Color_Number);\n   --  AKA\n   pragma Inline (Init_Pair);\n\n   --  ANCHOR(`pair_content()',`Pair_Content')\n   procedure Pair_Content (Pair : Color_Pair;\n                           Fore : out Color_Number;\n                           Back : out Color_Number);\n   --  AKA\n   pragma Inline (Pair_Content);\n\n   --  ANCHOR(`has_colors()',`Has_Colors')\n   function Has_Colors return Boolean;\n   --  AKA\n   pragma Inline (Has_Colors);\n\n   --  ANCHOR(`init_color()',`Init_Color')\n   procedure Init_Color (Color : Color_Number;\n                         Red   : RGB_Value;\n                         Green : RGB_Value;\n                         Blue  : RGB_Value);\n   --  AKA\n   pragma Inline (Init_Color);\n\n   --  ANCHOR(`can_change_color()',`Can_Change_Color')\n   function Can_Change_Color return Boolean;\n   --  AKA\n   pragma Inline (Can_Change_Color);\n\n   --  ANCHOR(`color_content()',`Color_Content')\n   procedure Color_Content (Color : Color_Number;\n                            Red   : out RGB_Value;\n                            Green : out RGB_Value;\n                            Blue  : out RGB_Value);\n   --  AKA\n   pragma Inline (Color_Content);\n\n   --  MANPAGE(`curs_kernel.3x')\n   --  | Not implemented: getsyx, setsyx\n   --\n   type Curses_Mode is (Curses, Shell);\n\n   --  ANCHOR(`def_prog_mode()',`Save_Curses_Mode')\n   procedure Save_Curses_Mode (Mode : Curses_Mode);\n   --  AKA\n   --  ALIAS(`def_shell_mode()')\n   pragma Inline (Save_Curses_Mode);\n\n   --  ANCHOR(`reset_prog_mode()',`Reset_Curses_Mode')\n   procedure Reset_Curses_Mode (Mode : Curses_Mode);\n   --  AKA\n   --  ALIAS(`reset_shell_mode()')\n   pragma Inline (Reset_Curses_Mode);\n\n   --  ANCHOR(`savetty()',`Save_Terminal_State')\n   procedure Save_Terminal_State;\n   --  AKA\n   pragma Inline (Save_Terminal_State);\n\n   --  ANCHOR(`resetty();',`Reset_Terminal_State')\n   procedure Reset_Terminal_State;\n   --  AKA\n   pragma Inline (Reset_Terminal_State);\n\n   type Stdscr_Init_Proc is access\n      function (Win     : Window;\n                Columns : Column_Count) return Integer;\n   pragma Convention (C, Stdscr_Init_Proc);\n   --  N.B.: the return value is actually ignored, but it seems to be\n   --        a good practice to return 0 if you think all went fine\n   --        and -1 otherwise.\n\n   --  ANCHOR(`ripoffline()',`Rip_Off_Lines')\n   procedure Rip_Off_Lines (Lines : Integer;\n                            Proc  : Stdscr_Init_Proc);\n   --  AKA\n   --  N.B.: to be more precise, this uses a ncurses specific enhancement of\n   --        ripoffline(), in which the Lines argument absolute value is the\n   --        number of lines to be ripped of. The official ripoffline() only\n   --        uses the sign of Lines to remove a single line from bottom or top.\n   pragma Inline (Rip_Off_Lines);\n\n   type Cursor_Visibility is (Invisible, Normal, Very_Visible);\n\n   --  ANCHOR(`curs_set()',`Set_Cursor_Visibility')\n   procedure Set_Cursor_Visibility (Visibility : in out Cursor_Visibility);\n   --  AKA\n   pragma Inline (Set_Cursor_Visibility);\n\n   --  ANCHOR(`napms()',`Nap_Milli_Seconds')\n   procedure Nap_Milli_Seconds (Ms : Natural);\n   --  AKA\n   pragma Inline (Nap_Milli_Seconds);\n\n   --  |=====================================================================\n   --  | Some useful helpers.\n   --  |=====================================================================\n   type Transform_Direction is (From_Screen, To_Screen);\n   procedure Transform_Coordinates\n     (W      : Window := Standard_Window;\n      Line   : in out Line_Position;\n      Column : in out Column_Position;\n      Dir    : Transform_Direction := From_Screen);\n   --  This procedure transforms screen coordinates into coordinates relative\n   --  to the window and vice versa, depending on the Dir parameter.\n   --  Screen coordinates are the position information for the physical device.\n   --  An Curses_Exception will be raised if Line and Column are not in the\n   --  Window or if you pass the Null_Window as argument.\n   --  We do not inline this procedure\n\n   --  MANPAGE(`default_colors.3x')\n\n   Default_Color : constant Color_Number := -1;\n\n   --  ANCHOR(`use_default_colors()',`Use_Default_Colors')\n   procedure Use_Default_Colors;\n   --  AKA\n   pragma Inline (Use_Default_Colors);\n\n   --  ANCHOR(`assume_default_colors()',`Assume_Default_Colors')\n   procedure Assume_Default_Colors (Fore : Color_Number := Default_Color;\n                                    Back : Color_Number := Default_Color);\n   --  AKA\n   pragma Inline (Assume_Default_Colors);\n\n   --  MANPAGE(`curs_extend.3x')\n\n   --  ANCHOR(`curses_version()',`Curses_Version')\n   function Curses_Version return String;\n   --  AKA\n\n   --  ANCHOR(`use_extended_names()',`Use_Extended_Names')\n   --  The returnvalue is the previous setting of the flag\n   function Use_Extended_Names (Enable : Boolean) return Boolean;\n   --  AKA\n\n   --  MANPAGE(`curs_trace.3x')\n\n   --  ANCHOR(`_nc_freeall()',`Curses_Free_All')\n   procedure Curses_Free_All;\n   --  AKA\n\n   --  MANPAGE(`curs_scr_dump.3x')\n\n   --  ANCHOR(`scr_dump()',`Screen_Dump_To_File')\n   procedure Screen_Dump_To_File (Filename : String);\n   --  AKA\n\n   --  ANCHOR(`scr_restore()',`Screen_Restore_From_File')\n   procedure Screen_Restore_From_File (Filename : String);\n   --  AKA\n\n   --  ANCHOR(`scr_init()',`Screen_Init_From_File')\n   procedure Screen_Init_From_File (Filename : String);\n   --  AKA\n\n   --  ANCHOR(`scr_set()',`Screen_Set_File')\n   procedure Screen_Set_File (Filename : String);\n   --  AKA\n\n   --  MANPAGE(`curs_print.3x')\n   --  Not implemented: mcprint\n\n   --  MANPAGE(`curs_printw.3x')\n   --  Not implemented: printw,  wprintw, mvprintw, mvwprintw, vwprintw,\n   --                   vw_printw\n   --  Please use the Ada style Text_IO child packages for formatted\n   --  printing. It does not make a lot of sense to map the printf style\n   --  C functions to Ada.\n\n   --  MANPAGE(`curs_scanw.3x')\n   --  Not implemented: scanw, wscanw, mvscanw, mvwscanw, vwscanw, vw_scanw\n\n   --  MANPAGE(`resizeterm.3x')\n   --  Not Implemented: resizeterm\n\n   --  MANPAGE(`wresize.3x')\n\n   --  ANCHOR(`wresize()',`Resize')\n   procedure Resize (Win               : Window := Standard_Window;\n                     Number_Of_Lines   : Line_Count;\n                     Number_Of_Columns : Column_Count);\n   --  AKA\n\nprivate\n   type Window is new System.Storage_Elements.Integer_Address;\n   Null_Window : constant Window := 0;\n\n   --  The next constants are generated and may be different on your\n   --  architecture.\n   --\n\n   Sizeof_Bool : constant := Curses_Constants.Sizeof_Bool;\n\n   type Curses_Bool is mod 2 ** Sizeof_Bool;\n\n   Curses_Bool_False : constant Curses_Bool := 0;\n\nend Terminal_Interface.Curses;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}