{
  "module_name": "terminal_interface-curses-forms.ads.m4",
  "hash_id": "3e6a88812888e94e64a614d7624551055f7fd9313adfbf86c253f19392655516",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/gen/terminal_interface-curses-forms.ads.m4",
  "human_readable_source": "--  -*- ada -*-\ndefine(`HTMLNAME',`terminal_interface-curses-forms__ads.htm')dnl\ninclude(M4MACRO)dnl\n------------------------------------------------------------------------------\n--                                                                          --\n--                           GNAT ncurses Binding                           --\n--                                                                          --\n--                      Terminal_Interface.Curses.Form                      --\n--                                                                          --\n--                                 S P E C                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 1998-2009,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author:  Juergen Pfeifer, 1996\n--  Version Control:\n--  $Revision: 1.34 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith System;\nwith Ada.Characters.Latin_1;\n\npackage Terminal_Interface.Curses.Forms is\n   pragma Preelaborate (Terminal_Interface.Curses.Forms);\n   pragma Linker_Options (\"-lform\" & Curses_Constants.DFT_ARG_SUFFIX);\n\n   Space : Character renames Ada.Characters.Latin_1.Space;\n\n   type Field        is private;\n   type Form         is private;\n\n   Null_Field        : constant Field;\n   Null_Form         : constant Form;\n\n   type Field_Justification is (None,\n                                Left,\n                                Center,\n                                Right);\n\n   type Field_Option_Set is\n      record\n         Visible   : Boolean;\n         Active    : Boolean;\n         Public    : Boolean;\n         Edit      : Boolean;\n         Wrap      : Boolean;\n         Blank     : Boolean;\n         Auto_Skip : Boolean;\n         Null_Ok   : Boolean;\n         Pass_Ok   : Boolean;\n         Static    : Boolean;\n      end record;\n   pragma Convention (C_Pass_By_Copy, Field_Option_Set);\n\n   for Field_Option_Set use\n      record\n         Visible   at 0 range Curses_Constants.O_VISIBLE_First\n           .. Curses_Constants.O_VISIBLE_Last;\n         Active    at 0 range Curses_Constants.O_ACTIVE_First\n           .. Curses_Constants.O_ACTIVE_Last;\n         Public    at 0 range Curses_Constants.O_PUBLIC_First\n           .. Curses_Constants.O_PUBLIC_Last;\n         Edit      at 0 range Curses_Constants.O_EDIT_First\n           .. Curses_Constants.O_EDIT_Last;\n         Wrap      at 0 range Curses_Constants.O_WRAP_First\n           .. Curses_Constants.O_WRAP_Last;\n         Blank     at 0 range Curses_Constants.O_BLANK_First\n           .. Curses_Constants.O_BLANK_Last;\n         Auto_Skip at 0 range Curses_Constants.O_AUTOSKIP_First\n           .. Curses_Constants.O_AUTOSKIP_Last;\n         Null_Ok   at 0 range Curses_Constants.O_NULLOK_First\n           .. Curses_Constants.O_NULLOK_Last;\n         Pass_Ok   at 0 range Curses_Constants.O_PASSOK_First\n           .. Curses_Constants.O_PASSOK_Last;\n         Static    at 0 range Curses_Constants.O_STATIC_First\n           .. Curses_Constants.O_STATIC_Last;\n      end record;\n   pragma Warnings (Off);\n   for Field_Option_Set'Size use Curses_Constants.Field_Options_Size;\n   pragma Warnings (On);\n\n   function Default_Field_Options return Field_Option_Set;\n   --  The initial defaults for the field options.\n   pragma Inline (Default_Field_Options);\n\n   type Form_Option_Set is\n      record\n         NL_Overload : Boolean;\n         BS_Overload : Boolean;\n      end record;\n   pragma Convention (C_Pass_By_Copy, Form_Option_Set);\n\n   for Form_Option_Set use\n      record\n         NL_Overload at 0 range Curses_Constants.O_NL_OVERLOAD_First\n           .. Curses_Constants.O_NL_OVERLOAD_Last;\n         BS_Overload at 0 range Curses_Constants.O_BS_OVERLOAD_First\n           .. Curses_Constants.O_BS_OVERLOAD_Last;\n      end record;\n   pragma Warnings (Off);\n   for Form_Option_Set'Size use Curses_Constants.Field_Options_Size;\n   pragma Warnings (On);\n\n   function Default_Form_Options return Form_Option_Set;\n   --  The initial defaults for the form options.\n   pragma Inline (Default_Form_Options);\n\n   type Buffer_Number is new Natural;\n\n   type Field_Array is array (Positive range <>) of aliased Field;\n   pragma Convention (C, Field_Array);\n\n   type Field_Array_Access is access Field_Array;\n\n   procedure Free (FA          : in out Field_Array_Access;\n                   Free_Fields : Boolean := False);\n   --  Release the memory for an allocated field array\n   --  If Free_Fields is True, call Delete() for all the fields in\n   --  the array.\n\n   subtype Form_Request_Code is Key_Code range (Key_Max + 1) .. (Key_Max + 57);\n\n   --  The prefix F_ stands for \"Form Request\"\n   F_Next_Page                : constant Form_Request_Code := Key_Max + 1;\n   F_Previous_Page            : constant Form_Request_Code := Key_Max + 2;\n   F_First_Page               : constant Form_Request_Code := Key_Max + 3;\n   F_Last_Page                : constant Form_Request_Code := Key_Max + 4;\n\n   F_Next_Field               : constant Form_Request_Code := Key_Max + 5;\n   F_Previous_Field           : constant Form_Request_Code := Key_Max + 6;\n   F_First_Field              : constant Form_Request_Code := Key_Max + 7;\n   F_Last_Field               : constant Form_Request_Code := Key_Max + 8;\n   F_Sorted_Next_Field        : constant Form_Request_Code := Key_Max + 9;\n   F_Sorted_Previous_Field    : constant Form_Request_Code := Key_Max + 10;\n   F_Sorted_First_Field       : constant Form_Request_Code := Key_Max + 11;\n   F_Sorted_Last_Field        : constant Form_Request_Code := Key_Max + 12;\n   F_Left_Field               : constant Form_Request_Code := Key_Max + 13;\n   F_Right_Field              : constant Form_Request_Code := Key_Max + 14;\n   F_Up_Field                 : constant Form_Request_Code := Key_Max + 15;\n   F_Down_Field               : constant Form_Request_Code := Key_Max + 16;\n\n   F_Next_Char                : constant Form_Request_Code := Key_Max + 17;\n   F_Previous_Char            : constant Form_Request_Code := Key_Max + 18;\n   F_Next_Line                : constant Form_Request_Code := Key_Max + 19;\n   F_Previous_Line            : constant Form_Request_Code := Key_Max + 20;\n   F_Next_Word                : constant Form_Request_Code := Key_Max + 21;\n   F_Previous_Word            : constant Form_Request_Code := Key_Max + 22;\n   F_Begin_Field              : constant Form_Request_Code := Key_Max + 23;\n   F_End_Field                : constant Form_Request_Code := Key_Max + 24;\n   F_Begin_Line               : constant Form_Request_Code := Key_Max + 25;\n   F_End_Line                 : constant Form_Request_Code := Key_Max + 26;\n   F_Left_Char                : constant Form_Request_Code := Key_Max + 27;\n   F_Right_Char               : constant Form_Request_Code := Key_Max + 28;\n   F_Up_Char                  : constant Form_Request_Code := Key_Max + 29;\n   F_Down_Char                : constant Form_Request_Code := Key_Max + 30;\n\n   F_New_Line                 : constant Form_Request_Code := Key_Max + 31;\n   F_Insert_Char              : constant Form_Request_Code := Key_Max + 32;\n   F_Insert_Line              : constant Form_Request_Code := Key_Max + 33;\n   F_Delete_Char              : constant Form_Request_Code := Key_Max + 34;\n   F_Delete_Previous          : constant Form_Request_Code := Key_Max + 35;\n   F_Delete_Line              : constant Form_Request_Code := Key_Max + 36;\n   F_Delete_Word              : constant Form_Request_Code := Key_Max + 37;\n   F_Clear_EOL                : constant Form_Request_Code := Key_Max + 38;\n   F_Clear_EOF                : constant Form_Request_Code := Key_Max + 39;\n   F_Clear_Field              : constant Form_Request_Code := Key_Max + 40;\n   F_Overlay_Mode             : constant Form_Request_Code := Key_Max + 41;\n   F_Insert_Mode              : constant Form_Request_Code := Key_Max + 42;\n\n   --  Vertical Scrolling\n   F_ScrollForward_Line       : constant Form_Request_Code := Key_Max + 43;\n   F_ScrollBackward_Line      : constant Form_Request_Code := Key_Max + 44;\n   F_ScrollForward_Page       : constant Form_Request_Code := Key_Max + 45;\n   F_ScrollBackward_Page      : constant Form_Request_Code := Key_Max + 46;\n   F_ScrollForward_HalfPage   : constant Form_Request_Code := Key_Max + 47;\n   F_ScrollBackward_HalfPage  : constant Form_Request_Code := Key_Max + 48;\n\n   --  Horizontal Scrolling\n   F_HScrollForward_Char      : constant Form_Request_Code := Key_Max + 49;\n   F_HScrollBackward_Char     : constant Form_Request_Code := Key_Max + 50;\n   F_HScrollForward_Line      : constant Form_Request_Code := Key_Max + 51;\n   F_HScrollBackward_Line     : constant Form_Request_Code := Key_Max + 52;\n   F_HScrollForward_HalfLine  : constant Form_Request_Code := Key_Max + 53;\n   F_HScrollBackward_HalfLine : constant Form_Request_Code := Key_Max + 54;\n\n   F_Validate_Field           : constant Form_Request_Code := Key_Max + 55;\n   F_Next_Choice              : constant Form_Request_Code := Key_Max + 56;\n   F_Previous_Choice          : constant Form_Request_Code := Key_Max + 57;\n\n   --  For those who like the old 'C' style request names\n   REQ_NEXT_PAGE    : Form_Request_Code renames F_Next_Page;\n   REQ_PREV_PAGE    : Form_Request_Code renames F_Previous_Page;\n   REQ_FIRST_PAGE   : Form_Request_Code renames F_First_Page;\n   REQ_LAST_PAGE    : Form_Request_Code renames F_Last_Page;\n\n   REQ_NEXT_FIELD   : Form_Request_Code renames F_Next_Field;\n   REQ_PREV_FIELD   : Form_Request_Code renames F_Previous_Field;\n   REQ_FIRST_FIELD  : Form_Request_Code renames F_First_Field;\n   REQ_LAST_FIELD   : Form_Request_Code renames F_Last_Field;\n   REQ_SNEXT_FIELD  : Form_Request_Code renames F_Sorted_Next_Field;\n   REQ_SPREV_FIELD  : Form_Request_Code renames F_Sorted_Previous_Field;\n   REQ_SFIRST_FIELD : Form_Request_Code renames F_Sorted_First_Field;\n   REQ_SLAST_FIELD  : Form_Request_Code renames F_Sorted_Last_Field;\n   REQ_LEFT_FIELD   : Form_Request_Code renames F_Left_Field;\n   REQ_RIGHT_FIELD  : Form_Request_Code renames F_Right_Field;\n   REQ_UP_FIELD     : Form_Request_Code renames F_Up_Field;\n   REQ_DOWN_FIELD   : Form_Request_Code renames F_Down_Field;\n\n   REQ_NEXT_CHAR    : Form_Request_Code renames F_Next_Char;\n   REQ_PREV_CHAR    : Form_Request_Code renames F_Previous_Char;\n   REQ_NEXT_LINE    : Form_Request_Code renames F_Next_Line;\n   REQ_PREV_LINE    : Form_Request_Code renames F_Previous_Line;\n   REQ_NEXT_WORD    : Form_Request_Code renames F_Next_Word;\n   REQ_PREV_WORD    : Form_Request_Code renames F_Previous_Word;\n   REQ_BEG_FIELD    : Form_Request_Code renames F_Begin_Field;\n   REQ_END_FIELD    : Form_Request_Code renames F_End_Field;\n   REQ_BEG_LINE     : Form_Request_Code renames F_Begin_Line;\n   REQ_END_LINE     : Form_Request_Code renames F_End_Line;\n   REQ_LEFT_CHAR    : Form_Request_Code renames F_Left_Char;\n   REQ_RIGHT_CHAR   : Form_Request_Code renames F_Right_Char;\n   REQ_UP_CHAR      : Form_Request_Code renames F_Up_Char;\n   REQ_DOWN_CHAR    : Form_Request_Code renames F_Down_Char;\n\n   REQ_NEW_LINE     : Form_Request_Code renames F_New_Line;\n   REQ_INS_CHAR     : Form_Request_Code renames F_Insert_Char;\n   REQ_INS_LINE     : Form_Request_Code renames F_Insert_Line;\n   REQ_DEL_CHAR     : Form_Request_Code renames F_Delete_Char;\n   REQ_DEL_PREV     : Form_Request_Code renames F_Delete_Previous;\n   REQ_DEL_LINE     : Form_Request_Code renames F_Delete_Line;\n   REQ_DEL_WORD     : Form_Request_Code renames F_Delete_Word;\n   REQ_CLR_EOL      : Form_Request_Code renames F_Clear_EOL;\n   REQ_CLR_EOF      : Form_Request_Code renames F_Clear_EOF;\n   REQ_CLR_FIELD    : Form_Request_Code renames F_Clear_Field;\n   REQ_OVL_MODE     : Form_Request_Code renames F_Overlay_Mode;\n   REQ_INS_MODE     : Form_Request_Code renames F_Insert_Mode;\n\n   REQ_SCR_FLINE    : Form_Request_Code renames F_ScrollForward_Line;\n   REQ_SCR_BLINE    : Form_Request_Code renames F_ScrollBackward_Line;\n   REQ_SCR_FPAGE    : Form_Request_Code renames F_ScrollForward_Page;\n   REQ_SCR_BPAGE    : Form_Request_Code renames F_ScrollBackward_Page;\n   REQ_SCR_FHPAGE   : Form_Request_Code renames F_ScrollForward_HalfPage;\n   REQ_SCR_BHPAGE   : Form_Request_Code renames F_ScrollBackward_HalfPage;\n\n   REQ_SCR_FCHAR    : Form_Request_Code renames F_HScrollForward_Char;\n   REQ_SCR_BCHAR    : Form_Request_Code renames F_HScrollBackward_Char;\n   REQ_SCR_HFLINE   : Form_Request_Code renames F_HScrollForward_Line;\n   REQ_SCR_HBLINE   : Form_Request_Code renames F_HScrollBackward_Line;\n   REQ_SCR_HFHALF   : Form_Request_Code renames F_HScrollForward_HalfLine;\n   REQ_SCR_HBHALF   : Form_Request_Code renames F_HScrollBackward_HalfLine;\n\n   REQ_VALIDATION   : Form_Request_Code renames F_Validate_Field;\n   REQ_NEXT_CHOICE  : Form_Request_Code renames F_Next_Choice;\n   REQ_PREV_CHOICE  : Form_Request_Code renames F_Previous_Choice;\n\n   procedure Request_Name (Key  : Form_Request_Code;\n                           Name : out String);\n\n   function  Request_Name (Key : Form_Request_Code) return String;\n   --  Same as function\n   pragma Inline (Request_Name);\n\n   ------------------\n   --  Exceptions  --\n   ------------------\n   Form_Exception : exception;\n\n   --  MANPAGE(`form_field_new.3x')\n\n   --  ANCHOR(`new_field()',`Create')\n   function Create (Height       : Line_Count;\n                    Width        : Column_Count;\n                    Top          : Line_Position;\n                    Left         : Column_Position;\n                    Off_Screen   : Natural := 0;\n                    More_Buffers : Buffer_Number := Buffer_Number'First)\n                    return Field;\n   --  AKA\n   --  An overloaded Create is defined later. Pragma Inline appears there.\n\n   --  ANCHOR(`new_field()',`New_Field')\n   function New_Field (Height       : Line_Count;\n                       Width        : Column_Count;\n                       Top          : Line_Position;\n                       Left         : Column_Position;\n                       Off_Screen   : Natural := 0;\n                       More_Buffers : Buffer_Number := Buffer_Number'First)\n                       return Field renames Create;\n   --  AKA\n   pragma Inline (New_Field);\n\n   --  ANCHOR(`free_field()',`Delete')\n   procedure Delete (Fld : in out Field);\n   --  AKA\n   --  Reset Fld to Null_Field\n   --  An overloaded Delete is defined later. Pragma Inline appears there.\n\n   --  ANCHOR(`dup_field()',`Duplicate')\n   function Duplicate (Fld  : Field;\n                       Top  : Line_Position;\n                       Left : Column_Position) return Field;\n   --  AKA\n   pragma Inline (Duplicate);\n\n   --  ANCHOR(`link_field()',`Link')\n   function Link (Fld  : Field;\n                  Top  : Line_Position;\n                  Left : Column_Position) return Field;\n   --  AKA\n   pragma Inline (Link);\n\n   --  MANPAGE(`form_field_just.3x')\n\n   --  ANCHOR(`set_field_just()',`Set_Justification')\n   procedure Set_Justification (Fld  : Field;\n                                Just : Field_Justification := None);\n   --  AKA\n   pragma Inline (Set_Justification);\n\n   --  ANCHOR(`field_just()',`Get_Justification')\n   function Get_Justification (Fld : Field) return Field_Justification;\n   --  AKA\n   pragma Inline (Get_Justification);\n\n   --  MANPAGE(`form_field_buffer.3x')\n\n   --  ANCHOR(`set_field_buffer()',`Set_Buffer')\n   procedure Set_Buffer\n     (Fld    : Field;\n      Buffer : Buffer_Number := Buffer_Number'First;\n      Str    : String);\n   --  AKA\n   --  Not inlined\n\n   --  ANCHOR(`field_buffer()',`Get_Buffer')\n   procedure Get_Buffer\n     (Fld    : Field;\n      Buffer : Buffer_Number := Buffer_Number'First;\n      Str    : out String);\n   --  AKA\n\n   function Get_Buffer\n     (Fld    : Field;\n      Buffer : Buffer_Number := Buffer_Number'First) return String;\n   --  AKA\n   --  Same but as function\n   pragma Inline (Get_Buffer);\n\n   --  ANCHOR(`set_field_status()',`Set_Status')\n   procedure Set_Status (Fld    : Field;\n                         Status : Boolean := True);\n   --  AKA\n   pragma Inline (Set_Status);\n\n   --  ANCHOR(`field_status()',`Changed')\n   function Changed (Fld : Field) return Boolean;\n   --  AKA\n   pragma Inline (Changed);\n\n   --  ANCHOR(`set_field_max()',`Set_Maximum_Size')\n   procedure Set_Maximum_Size (Fld : Field;\n                               Max : Natural := 0);\n   --  AKA\n   pragma Inline (Set_Maximum_Size);\n\n   --  MANPAGE(`form_field_opts.3x')\n\n   --  ANCHOR(`set_field_opts()',`Set_Options')\n   procedure Set_Options (Fld     : Field;\n                          Options : Field_Option_Set);\n   --  AKA\n   --  An overloaded version is defined later. Pragma Inline appears there\n\n   --  ANCHOR(`field_opts_on()',`Switch_Options')\n   procedure Switch_Options (Fld     : Field;\n                             Options : Field_Option_Set;\n                             On      : Boolean := True);\n   --  AKA\n   --  ALIAS(`field_opts_off()')\n   --  An overloaded version is defined later. Pragma Inline appears there\n\n   --  ANCHOR(`field_opts()',`Get_Options')\n   procedure Get_Options (Fld     : Field;\n                          Options : out Field_Option_Set);\n   --  AKA\n\n   --  ANCHOR(`field_opts()',`Get_Options')\n   function Get_Options (Fld : Field := Null_Field)\n                         return Field_Option_Set;\n   --  AKA\n   --  An overloaded version is defined later. Pragma Inline appears there\n\n   --  MANPAGE(`form_field_attributes.3x')\n\n   --  ANCHOR(`set_field_fore()',`Set_Foreground')\n   procedure Set_Foreground\n     (Fld   : Field;\n      Fore  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   pragma Inline (Set_Foreground);\n\n   --  ANCHOR(`field_fore()',`Foreground')\n   procedure Foreground (Fld  : Field;\n                         Fore : out Character_Attribute_Set);\n   --  AKA\n\n   --  ANCHOR(`field_fore()',`Foreground')\n   procedure Foreground (Fld   : Field;\n                         Fore  : out Character_Attribute_Set;\n                         Color : out Color_Pair);\n   --  AKA\n   pragma Inline (Foreground);\n\n   --  ANCHOR(`set_field_back()',`Set_Background')\n   procedure Set_Background\n     (Fld   : Field;\n      Back  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   pragma Inline (Set_Background);\n\n   --  ANCHOR(`field_back()',`Background')\n   procedure Background (Fld  : Field;\n                         Back : out Character_Attribute_Set);\n   --  AKA\n\n   --  ANCHOR(`field_back()',`Background')\n   procedure Background (Fld   : Field;\n                         Back  : out Character_Attribute_Set;\n                         Color : out Color_Pair);\n   --  AKA\n   pragma Inline (Background);\n\n   --  ANCHOR(`set_field_pad()',`Set_Pad_Character')\n   procedure Set_Pad_Character (Fld : Field;\n                                Pad : Character := Space);\n   --  AKA\n   pragma Inline (Set_Pad_Character);\n\n   --  ANCHOR(`field_pad()',`Pad_Character')\n   procedure Pad_Character (Fld : Field;\n                            Pad : out Character);\n   --  AKA\n   pragma Inline (Pad_Character);\n\n   --  MANPAGE(`form_field_info.3x')\n\n   --  ANCHOR(`field_info()',`Info')\n   procedure Info (Fld                : Field;\n                   Lines              : out Line_Count;\n                   Columns            : out Column_Count;\n                   First_Row          : out Line_Position;\n                   First_Column       : out Column_Position;\n                   Off_Screen         : out Natural;\n                   Additional_Buffers : out Buffer_Number);\n   --  AKA\n   pragma Inline (Info);\n\n   --  ANCHOR(`dynamic_field_info()',`Dynamic_Info')\n   procedure Dynamic_Info (Fld     : Field;\n                           Lines   : out Line_Count;\n                           Columns : out Column_Count;\n                           Max     : out Natural);\n   --  AKA\n   pragma Inline (Dynamic_Info);\n\n   --  MANPAGE(`form_win.3x')\n\n   --  ANCHOR(`set_form_win()',`Set_Window')\n   procedure Set_Window (Frm : Form;\n                         Win : Window);\n   --  AKA\n   pragma Inline (Set_Window);\n\n   --  ANCHOR(`form_win()',`Get_Window')\n   function Get_Window (Frm : Form) return Window;\n   --  AKA\n   pragma Inline (Get_Window);\n\n   --  ANCHOR(`set_form_sub()',`Set_Sub_Window')\n   procedure Set_Sub_Window (Frm : Form;\n                             Win : Window);\n   --  AKA\n   pragma Inline (Set_Sub_Window);\n\n   --  ANCHOR(`form_sub()',`Get_Sub_Window')\n   function Get_Sub_Window (Frm : Form) return Window;\n   --  AKA\n   pragma Inline (Get_Sub_Window);\n\n   --  ANCHOR(`scale_form()',`Scale')\n   procedure Scale (Frm     : Form;\n                    Lines   : out Line_Count;\n                    Columns : out Column_Count);\n   --  AKA\n   pragma Inline (Scale);\n\n   --  MANPAGE(`form_hook.3x')\n\n   type Form_Hook_Function is access procedure (Frm : Form);\n   pragma Convention (C, Form_Hook_Function);\n\n   --  ANCHOR(`set_field_init()',`Set_Field_Init_Hook')\n   procedure Set_Field_Init_Hook (Frm  : Form;\n                                  Proc : Form_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Field_Init_Hook);\n\n   --  ANCHOR(`set_field_term()',`Set_Field_Term_Hook')\n   procedure Set_Field_Term_Hook (Frm  : Form;\n                                  Proc : Form_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Field_Term_Hook);\n\n   --  ANCHOR(`set_form_init()',`Set_Form_Init_Hook')\n   procedure Set_Form_Init_Hook (Frm  : Form;\n                                 Proc : Form_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Form_Init_Hook);\n\n   --  ANCHOR(`set_form_term()',`Set_Form_Term_Hook')\n   procedure Set_Form_Term_Hook (Frm  : Form;\n                                 Proc : Form_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Form_Term_Hook);\n\n   --  ANCHOR(`field_init()',`Get_Field_Init_Hook')\n   function Get_Field_Init_Hook (Frm : Form) return Form_Hook_Function;\n   --  AKA\n   pragma Import (C, Get_Field_Init_Hook, \"field_init\");\n\n   --  ANCHOR(`field_term()',`Get_Field_Term_Hook')\n   function Get_Field_Term_Hook (Frm : Form) return Form_Hook_Function;\n   --  AKA\n   pragma Import (C, Get_Field_Term_Hook, \"field_term\");\n\n   --  ANCHOR(`form_init()',`Get_Form_Init_Hook')\n   function Get_Form_Init_Hook (Frm : Form) return Form_Hook_Function;\n   --  AKA\n   pragma Import (C, Get_Form_Init_Hook, \"form_init\");\n\n   --  ANCHOR(`form_term()',`Get_Form_Term_Hook')\n   function Get_Form_Term_Hook (Frm : Form) return Form_Hook_Function;\n   --  AKA\n   pragma Import (C, Get_Form_Term_Hook, \"form_term\");\n\n   --  MANPAGE(`form_field.3x')\n\n   --  ANCHOR(`set_form_fields()',`Redefine')\n   procedure Redefine (Frm  : Form;\n                       Flds : Field_Array_Access);\n   --  AKA\n   pragma Inline (Redefine);\n\n   --  ANCHOR(`set_form_fields()',`Set_Fields')\n   procedure Set_Fields (Frm  : Form;\n                         Flds : Field_Array_Access) renames Redefine;\n   --  AKA\n   --  pragma Inline (Set_Fields);\n\n   --  ANCHOR(`form_fields()',`Fields')\n   function Fields (Frm   : Form;\n                    Index : Positive) return Field;\n   --  AKA\n   pragma Inline (Fields);\n\n   --  ANCHOR(`field_count()',`Field_Count')\n   function Field_Count (Frm : Form) return Natural;\n   --  AKA\n   pragma Inline (Field_Count);\n\n   --  ANCHOR(`move_field()',`Move')\n   procedure Move (Fld    : Field;\n                   Line   : Line_Position;\n                   Column : Column_Position);\n   --  AKA\n   pragma Inline (Move);\n\n   --  MANPAGE(`form_new.3x')\n\n   --  ANCHOR(`new_form()',`Create')\n   function Create (Fields : Field_Array_Access) return Form;\n   --  AKA\n   pragma Inline (Create);\n\n   --  ANCHOR(`new_form()',`New_Form')\n   function New_Form (Fields : Field_Array_Access) return Form\n     renames Create;\n   --  AKA\n   --  pragma Inline (New_Form);\n\n   --  ANCHOR(`free_form()',`Delete')\n   procedure Delete (Frm : in out Form);\n   --  AKA\n   --  Reset Frm to Null_Form\n   pragma Inline (Delete);\n\n   --  MANPAGE(`form_opts.3x')\n\n   --  ANCHOR(`set_form_opts()',`Set_Options')\n   procedure Set_Options (Frm     : Form;\n                          Options : Form_Option_Set);\n   --  AKA\n   pragma Inline (Set_Options);\n\n   --  ANCHOR(`form_opts_on()',`Switch_Options')\n   procedure Switch_Options (Frm     : Form;\n                             Options : Form_Option_Set;\n                             On      : Boolean := True);\n   --  AKA\n   --  ALIAS(`form_opts_off()')\n   pragma Inline (Switch_Options);\n\n   --  ANCHOR(`form_opts()',`Get_Options')\n   procedure Get_Options (Frm     : Form;\n                          Options : out Form_Option_Set);\n   --  AKA\n\n   --  ANCHOR(`form_opts()',`Get_Options')\n   function Get_Options (Frm : Form := Null_Form) return Form_Option_Set;\n   --  AKA\n   pragma Inline (Get_Options);\n\n   --  MANPAGE(`form_post.3x')\n\n   --  ANCHOR(`post_form()',`Post')\n   procedure Post (Frm  : Form;\n                   Post : Boolean := True);\n   --  AKA\n   --  ALIAS(`unpost_form()')\n   pragma Inline (Post);\n\n   --  MANPAGE(`form_cursor.3x')\n\n   --  ANCHOR(`pos_form_cursor()',`Position_Cursor')\n   procedure Position_Cursor (Frm : Form);\n   --  AKA\n   pragma Inline (Position_Cursor);\n\n   --  MANPAGE(`form_data.3x')\n\n   --  ANCHOR(`data_ahead()',`Data_Ahead')\n   function Data_Ahead (Frm : Form) return Boolean;\n   --  AKA\n   pragma Inline (Data_Ahead);\n\n   --  ANCHOR(`data_behind()',`Data_Behind')\n   function Data_Behind (Frm : Form) return Boolean;\n   --  AKA\n   pragma Inline (Data_Behind);\n\n   --  MANPAGE(`form_driver.3x')\n\n   type Driver_Result is (Form_Ok,\n                          Request_Denied,\n                          Unknown_Request,\n                          Invalid_Field);\n\n   --  ANCHOR(`form_driver()',`Driver')\n   function Driver (Frm : Form;\n                    Key : Key_Code) return Driver_Result;\n   --  AKA\n   --  Driver not inlined\n\n   --  MANPAGE(`form_page.3x')\n\n   type Page_Number is new Natural;\n\n   --  ANCHOR(`set_current_field()',`Set_Current')\n   procedure Set_Current (Frm : Form;\n                          Fld : Field);\n   --  AKA\n   pragma Inline (Set_Current);\n\n   --  ANCHOR(`current_field()',`Current')\n   function Current (Frm : Form) return Field;\n   --  AKA\n   pragma Inline (Current);\n\n   --  ANCHOR(`set_form_page()',`Set_Page')\n   procedure Set_Page (Frm  : Form;\n                       Page : Page_Number := Page_Number'First);\n   --  AKA\n   pragma Inline (Set_Page);\n\n   --  ANCHOR(`form_page()',`Page')\n   function Page (Frm : Form) return Page_Number;\n   --  AKA\n   pragma Inline (Page);\n\n   --  ANCHOR(`field_index()',`Get_Index')\n   function Get_Index (Fld : Field) return Positive;\n   --  AKA\n   --  Please note that in this binding we start the numbering of fields\n   --  with 1. So this is number is one more than you get from the low\n   --  level call.\n   pragma Inline (Get_Index);\n\n   --  MANPAGE(`form_new_page.3x')\n\n   --  ANCHOR(`set_new_page()',`Set_New_Page')\n   procedure Set_New_Page (Fld      : Field;\n                           New_Page : Boolean := True);\n   --  AKA\n   pragma Inline (Set_New_Page);\n\n   --  ANCHOR(`new_page()',`Is_New_Page')\n   function Is_New_Page (Fld : Field) return Boolean;\n   --  AKA\n   pragma Inline (Is_New_Page);\n\n   --  MANPAGE(`form_requestname.3x')\n   --  Not Implemented: form_request_name, form_request_by_name\n\n------------------------------------------------------------------------------\nprivate\n   type Field is new System.Storage_Elements.Integer_Address;\n   type Form  is new System.Storage_Elements.Integer_Address;\n\n   Null_Field : constant Field := 0;\n   Null_Form  : constant Form  := 0;\n\nend Terminal_Interface.Curses.Forms;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}