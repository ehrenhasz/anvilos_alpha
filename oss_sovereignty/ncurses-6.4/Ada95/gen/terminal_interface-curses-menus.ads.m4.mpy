{
  "module_name": "terminal_interface-curses-menus.ads.m4",
  "hash_id": "4981c89e2a79eb9def3ba76005e2920437d11d418cee5cbbaf37aa5deb536c63",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/gen/terminal_interface-curses-menus.ads.m4",
  "human_readable_source": "--  -*- ada -*-\ndefine(`HTMLNAME',`terminal_interface-curses-menus__ads.htm')dnl\ninclude(M4MACRO)dnl\n------------------------------------------------------------------------------\n--                                                                          --\n--                           GNAT ncurses Binding                           --\n--                                                                          --\n--                      Terminal_Interface.Curses.Menu                      --\n--                                                                          --\n--                                 S P E C                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2020 Thomas E. Dickey                                          --\n-- Copyright 1998-2009,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author:  Juergen Pfeifer, 1996\n--  Version Control:\n--  $Revision: 1.32 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith System;\nwith Ada.Characters.Latin_1;\n\npackage Terminal_Interface.Curses.Menus is\n   pragma Preelaborate (Terminal_Interface.Curses.Menus);\n   pragma Linker_Options (\"-lmenu\" & Curses_Constants.DFT_ARG_SUFFIX);\n\n   Space : Character renames Ada.Characters.Latin_1.Space;\n\n   type Item is private;\n   type Menu is private;\n\n   ---------------------------\n   --  Interface constants  --\n   ---------------------------\n   Null_Item : constant Item;\n   Null_Menu : constant Menu;\n\n   subtype Menu_Request_Code is Key_Code\n     range (Key_Max + 1) .. (Key_Max + 17);\n\n   --  The prefix M_ stands for \"Menu Request\"\n   M_Left_Item       : constant Menu_Request_Code := Key_Max + 1;\n   M_Right_Item      : constant Menu_Request_Code := Key_Max + 2;\n   M_Up_Item         : constant Menu_Request_Code := Key_Max + 3;\n   M_Down_Item       : constant Menu_Request_Code := Key_Max + 4;\n   M_ScrollUp_Line   : constant Menu_Request_Code := Key_Max + 5;\n   M_ScrollDown_Line : constant Menu_Request_Code := Key_Max + 6;\n   M_ScrollDown_Page : constant Menu_Request_Code := Key_Max + 7;\n   M_ScrollUp_Page   : constant Menu_Request_Code := Key_Max + 8;\n   M_First_Item      : constant Menu_Request_Code := Key_Max + 9;\n   M_Last_Item       : constant Menu_Request_Code := Key_Max + 10;\n   M_Next_Item       : constant Menu_Request_Code := Key_Max + 11;\n   M_Previous_Item   : constant Menu_Request_Code := Key_Max + 12;\n   M_Toggle_Item     : constant Menu_Request_Code := Key_Max + 13;\n   M_Clear_Pattern   : constant Menu_Request_Code := Key_Max + 14;\n   M_Back_Pattern    : constant Menu_Request_Code := Key_Max + 15;\n   M_Next_Match      : constant Menu_Request_Code := Key_Max + 16;\n   M_Previous_Match  : constant Menu_Request_Code := Key_Max + 17;\n\n   --  For those who like the old 'C' names for the request codes\n   REQ_LEFT_ITEM     : Menu_Request_Code renames M_Left_Item;\n   REQ_RIGHT_ITEM    : Menu_Request_Code renames M_Right_Item;\n   REQ_UP_ITEM       : Menu_Request_Code renames M_Up_Item;\n   REQ_DOWN_ITEM     : Menu_Request_Code renames M_Down_Item;\n   REQ_SCR_ULINE     : Menu_Request_Code renames M_ScrollUp_Line;\n   REQ_SCR_DLINE     : Menu_Request_Code renames M_ScrollDown_Line;\n   REQ_SCR_DPAGE     : Menu_Request_Code renames M_ScrollDown_Page;\n   REQ_SCR_UPAGE     : Menu_Request_Code renames M_ScrollUp_Page;\n   REQ_FIRST_ITEM    : Menu_Request_Code renames M_First_Item;\n   REQ_LAST_ITEM     : Menu_Request_Code renames M_Last_Item;\n   REQ_NEXT_ITEM     : Menu_Request_Code renames M_Next_Item;\n   REQ_PREV_ITEM     : Menu_Request_Code renames M_Previous_Item;\n   REQ_TOGGLE_ITEM   : Menu_Request_Code renames M_Toggle_Item;\n   REQ_CLEAR_PATTERN : Menu_Request_Code renames M_Clear_Pattern;\n   REQ_BACK_PATTERN  : Menu_Request_Code renames M_Back_Pattern;\n   REQ_NEXT_MATCH    : Menu_Request_Code renames M_Next_Match;\n   REQ_PREV_MATCH    : Menu_Request_Code renames M_Previous_Match;\n\n   procedure Request_Name (Key  : Menu_Request_Code;\n                           Name : out String);\n\n   function  Request_Name (Key : Menu_Request_Code) return String;\n   --  Same as function\n\n   ------------------\n   --  Exceptions  --\n   ------------------\n\n   Menu_Exception : exception;\n   --\n   --  Menu options\n   --\n   type Menu_Option_Set is\n      record\n         One_Valued        : Boolean;\n         Show_Descriptions : Boolean;\n         Row_Major_Order   : Boolean;\n         Ignore_Case       : Boolean;\n         Show_Matches      : Boolean;\n         Non_Cyclic        : Boolean;\n      end record;\n   pragma Convention (C_Pass_By_Copy, Menu_Option_Set);\n\n   for Menu_Option_Set use\n      record\n         One_Valued        at 0 range Curses_Constants.O_ONEVALUE_First\n           .. Curses_Constants.O_ONEVALUE_Last;\n         Show_Descriptions at 0 range Curses_Constants.O_SHOWDESC_First\n           .. Curses_Constants.O_SHOWDESC_Last;\n         Row_Major_Order   at 0 range Curses_Constants.O_ROWMAJOR_First\n           .. Curses_Constants.O_ROWMAJOR_Last;\n         Ignore_Case       at 0 range Curses_Constants.O_IGNORECASE_First\n           .. Curses_Constants.O_IGNORECASE_Last;\n         Show_Matches      at 0 range Curses_Constants.O_SHOWMATCH_First\n           .. Curses_Constants.O_SHOWMATCH_Last;\n         Non_Cyclic        at 0 range Curses_Constants.O_NONCYCLIC_First\n           .. Curses_Constants.O_NONCYCLIC_Last;\n      end record;\n   pragma Warnings (Off);\n   for Menu_Option_Set'Size use Curses_Constants.Menu_Options_Size;\n   pragma Warnings (On);\n\n   function Default_Menu_Options return Menu_Option_Set;\n   --  Initial default options for a menu.\n   pragma Inline (Default_Menu_Options);\n   --\n   --  Item options\n   --\n   type Item_Option_Set is\n      record\n         Selectable : Boolean;\n      end record;\n   pragma Convention (C_Pass_By_Copy, Item_Option_Set);\n\n   for Item_Option_Set use\n      record\n         Selectable at 0 range Curses_Constants.O_SELECTABLE_First\n           ..  Curses_Constants.O_SELECTABLE_Last;\n      end record;\n   pragma Warnings (Off);\n   for Item_Option_Set'Size use Curses_Constants.Item_Options_Size;\n   pragma Warnings (On);\n\n   function Default_Item_Options return Item_Option_Set;\n   --  Initial default options for an item.\n   pragma Inline (Default_Item_Options);\n\n   --\n   --  Item Array\n   --\n   type Item_Array is array (Positive range <>) of aliased Item;\n   pragma Convention (C, Item_Array);\n\n   type Item_Array_Access is access Item_Array;\n\n   procedure Free (IA         : in out Item_Array_Access;\n                   Free_Items : Boolean := False);\n   --  Release the memory for an allocated item array\n   --  If Free_Items is True, call Delete() for all the items in\n   --  the array.\n\n   --  MANPAGE(`mitem_new.3x')\n\n   --  ANCHOR(`new_item()',`Create')\n   function Create (Name        : String;\n                    Description : String := \"\") return Item;\n   --  AKA\n   --  Not inlined.\n\n   --  ANCHOR(`new_item()',`New_Item')\n   function New_Item (Name        : String;\n                      Description : String := \"\") return Item\n     renames Create;\n   --  AKA\n\n   --  ANCHOR(`free_item()',`Delete')\n   procedure Delete (Itm : in out Item);\n   --  AKA\n   --  Resets Itm to Null_Item\n\n   --  MANPAGE(`mitem_value.3x')\n\n   --  ANCHOR(`set_item_value()',`Set_Value')\n   procedure Set_Value (Itm   : Item;\n                        Value : Boolean := True);\n   --  AKA\n   pragma Inline (Set_Value);\n\n   --  ANCHOR(`item_value()',`Value')\n   function Value (Itm : Item) return Boolean;\n   --  AKA\n   pragma Inline (Value);\n\n   --  MANPAGE(`mitem_visible.3x')\n\n   --  ANCHOR(`item_visible()',`Visible')\n   function Visible (Itm : Item) return Boolean;\n   --  AKA\n   pragma Inline (Visible);\n\n   --  MANPAGE(`mitem_opts.3x')\n\n   --  ANCHOR(`set_item_opts()',`Set_Options')\n   procedure Set_Options (Itm     : Item;\n                          Options : Item_Option_Set);\n   --  AKA\n   --  An overloaded Set_Options is defined later. Pragma Inline appears there\n\n   --  ANCHOR(`item_opts_on()',`Switch_Options')\n   procedure Switch_Options (Itm     : Item;\n                             Options : Item_Option_Set;\n                             On      : Boolean := True);\n   --  AKA\n   --  ALIAS(`item_opts_off()')\n   --  An overloaded Switch_Options is defined later.\n   --  Pragma Inline appears there\n\n   --  ANCHOR(`item_opts()',`Get_Options')\n   procedure Get_Options (Itm     : Item;\n                          Options : out Item_Option_Set);\n   --  AKA\n\n   --  ANCHOR(`item_opts()',`Get_Options')\n   function Get_Options (Itm : Item := Null_Item) return Item_Option_Set;\n   --  AKA\n   --  An overloaded Get_Options is defined later. Pragma Inline appears there\n\n   --  MANPAGE(`mitem_name.3x')\n\n   --  ANCHOR(`item_name()',`Name')\n   procedure Name (Itm  : Item;\n                   Name : out String);\n   --  AKA\n   function  Name (Itm : Item) return String;\n   --  AKA\n   --  Implemented as function\n   pragma Inline (Name);\n\n   --  ANCHOR(`item_description();',`Description')\n   procedure Description (Itm         : Item;\n                          Description : out String);\n   --  AKA\n\n   function  Description (Itm : Item) return String;\n   --  AKA\n   --  Implemented as function\n   pragma Inline (Description);\n\n   --  MANPAGE(`mitem_current.3x')\n\n   --  ANCHOR(`set_current_item()',`Set_Current')\n   procedure Set_Current (Men : Menu;\n                          Itm : Item);\n   --  AKA\n   pragma Inline (Set_Current);\n\n   --  ANCHOR(`current_item()',`Current')\n   function Current (Men : Menu) return Item;\n   --  AKA\n   pragma Inline (Current);\n\n   --  ANCHOR(`set_top_row()',`Set_Top_Row')\n   procedure Set_Top_Row (Men  : Menu;\n                          Line : Line_Position);\n   --  AKA\n   pragma Inline (Set_Top_Row);\n\n   --  ANCHOR(`top_row()',`Top_Row')\n   function Top_Row (Men : Menu) return Line_Position;\n   --  AKA\n   pragma Inline (Top_Row);\n\n   --  ANCHOR(`item_index()',`Get_Index')\n   function Get_Index (Itm : Item) return Positive;\n   --  AKA\n   --  Please note that in this binding we start the numbering of items\n   --  with 1. So this is number is one more than you get from the low\n   --  level call.\n   pragma Inline (Get_Index);\n\n   --  MANPAGE(`menu_post.3x')\n\n   --  ANCHOR(`post_menu()',`Post')\n   procedure Post (Men  : Menu;\n                   Post : Boolean := True);\n   --  AKA\n   --  ALIAS(`unpost_menu()')\n   pragma Inline (Post);\n\n   --  MANPAGE(`menu_opts.3x')\n\n   --  ANCHOR(`set_menu_opts()',`Set_Options')\n   procedure Set_Options (Men     : Menu;\n                          Options : Menu_Option_Set);\n   --  AKA\n   pragma Inline (Set_Options);\n\n   --  ANCHOR(`menu_opts_on()',`Switch_Options')\n   procedure Switch_Options (Men     : Menu;\n                             Options : Menu_Option_Set;\n                             On      : Boolean := True);\n   --  AKA\n   --  ALIAS(`menu_opts_off()')\n   pragma Inline (Switch_Options);\n\n   --  ANCHOR(`menu_opts()',`Get_Options')\n   procedure Get_Options (Men     : Menu;\n                          Options : out Menu_Option_Set);\n   --  AKA\n\n   --  ANCHOR(`menu_opts()',`Get_Options')\n   function Get_Options (Men : Menu := Null_Menu) return Menu_Option_Set;\n   --  AKA\n   pragma Inline (Get_Options);\n\n   --  MANPAGE(`menu_win.3x')\n\n   --  ANCHOR(`set_menu_win()',`Set_Window')\n   procedure Set_Window (Men : Menu;\n                         Win : Window);\n   --  AKA\n   pragma Inline (Set_Window);\n\n   --  ANCHOR(`menu_win()',`Get_Window')\n   function Get_Window (Men : Menu) return Window;\n   --  AKA\n   pragma Inline (Get_Window);\n\n   --  ANCHOR(`set_menu_sub()',`Set_Sub_Window')\n   procedure Set_Sub_Window (Men : Menu;\n                             Win : Window);\n   --  AKA\n   pragma Inline (Set_Sub_Window);\n\n   --  ANCHOR(`menu_sub()',`Get_Sub_Window')\n   function Get_Sub_Window (Men : Menu) return Window;\n   --  AKA\n   pragma Inline (Get_Sub_Window);\n\n   --  ANCHOR(`scale_menu()',`Scale')\n   procedure Scale (Men     : Menu;\n                    Lines   : out Line_Count;\n                    Columns : out Column_Count);\n   --  AKA\n   pragma Inline (Scale);\n\n   --  MANPAGE(`menu_cursor.3x')\n\n   --  ANCHOR(`pos_menu_cursor()',`Position_Cursor')\n   procedure Position_Cursor (Men : Menu);\n   --  AKA\n   pragma Inline (Position_Cursor);\n\n   --  MANPAGE(`menu_mark.3x')\n\n   --  ANCHOR(`set_menu_mark()',`Set_Mark')\n   procedure Set_Mark (Men  : Menu;\n                       Mark : String);\n   --  AKA\n   pragma Inline (Set_Mark);\n\n   --  ANCHOR(`menu_mark()',`Mark')\n   procedure Mark (Men  : Menu;\n                   Mark : out String);\n   --  AKA\n\n   function  Mark (Men : Menu) return String;\n   --  AKA\n   --  Implemented as function\n   pragma Inline (Mark);\n\n   --  MANPAGE(`menu_attributes.3x')\n\n   --  ANCHOR(`set_menu_fore()',`Set_Foreground')\n   procedure Set_Foreground\n     (Men   : Menu;\n      Fore  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   pragma Inline (Set_Foreground);\n\n   --  ANCHOR(`menu_fore()',`Foreground')\n   procedure Foreground (Men   : Menu;\n                         Fore  : out Character_Attribute_Set);\n   --  AKA\n\n   --  ANCHOR(`menu_fore()',`Foreground')\n   procedure Foreground (Men   : Menu;\n                         Fore  : out Character_Attribute_Set;\n                         Color : out Color_Pair);\n   --  AKA\n   pragma Inline (Foreground);\n\n   --  ANCHOR(`set_menu_back()',`Set_Background')\n   procedure Set_Background\n     (Men   : Menu;\n      Back  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   pragma Inline (Set_Background);\n\n   --  ANCHOR(`menu_back()',`Background')\n   procedure Background (Men  : Menu;\n                         Back : out Character_Attribute_Set);\n   --  AKA\n   --  ANCHOR(`menu_back()',`Background')\n\n   procedure Background (Men   : Menu;\n                         Back  : out Character_Attribute_Set;\n                         Color : out Color_Pair);\n   --  AKA\n   pragma Inline (Background);\n\n   --  ANCHOR(`set_menu_grey()',`Set_Grey')\n   procedure Set_Grey\n     (Men   : Menu;\n      Grey  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First);\n   --  AKA\n   pragma Inline (Set_Grey);\n\n   --  ANCHOR(`menu_grey()',`Grey')\n   procedure Grey (Men  : Menu;\n                   Grey : out Character_Attribute_Set);\n   --  AKA\n\n   --  ANCHOR(`menu_grey()',`Grey')\n   procedure Grey\n     (Men   : Menu;\n      Grey  : out Character_Attribute_Set;\n      Color : out Color_Pair);\n   --  AKA\n   pragma Inline (Grey);\n\n   --  ANCHOR(`set_menu_pad()',`Set_Pad_Character')\n   procedure Set_Pad_Character (Men : Menu;\n                                Pad : Character := Space);\n   --  AKA\n   pragma Inline (Set_Pad_Character);\n\n   --  ANCHOR(`menu_pad()',`Pad_Character')\n   procedure Pad_Character (Men : Menu;\n                            Pad : out Character);\n   --  AKA\n   pragma Inline (Pad_Character);\n\n   --  MANPAGE(`menu_spacing.3x')\n\n   --  ANCHOR(`set_menu_spacing()',`Set_Spacing')\n   procedure Set_Spacing (Men   : Menu;\n                          Descr : Column_Position := 0;\n                          Row   : Line_Position   := 0;\n                          Col   : Column_Position := 0);\n   --  AKA\n   pragma Inline (Set_Spacing);\n\n   --  ANCHOR(`menu_spacing()',`Spacing')\n   procedure Spacing (Men   : Menu;\n                      Descr : out Column_Position;\n                      Row   : out Line_Position;\n                      Col   : out Column_Position);\n   --  AKA\n   pragma Inline (Spacing);\n\n   --  MANPAGE(`menu_pattern.3x')\n\n   --  ANCHOR(`set_menu_pattern()',`Set_Pattern')\n   function Set_Pattern (Men  : Menu;\n                         Text : String) return Boolean;\n   --  AKA\n   --  Return TRUE if the pattern matches, FALSE otherwise\n   pragma Inline (Set_Pattern);\n\n   --  ANCHOR(`menu_pattern()',`Pattern')\n   procedure Pattern (Men  : Menu;\n                      Text : out String);\n   --  AKA\n   pragma Inline (Pattern);\n\n   --  MANPAGE(`menu_format.3x')\n\n   --  ANCHOR(`set_menu_format()',`Set_Format')\n   procedure Set_Format (Men     : Menu;\n                         Lines   : Line_Count;\n                         Columns : Column_Count);\n   --  Not implemented: 0 argument for Lines or Columns;\n   --  instead use Format to get the current sizes\n   --      The  default  format  is  16  rows,  1  column.    Calling\n   --      set_menu_format  with a null menu pointer will change this\n   --      default.  A zero row or column argument to set_menu_format\n   --      is  interpreted  as  a  request  not to change the current\n   --      value.\n   --  AKA\n   pragma Inline (Set_Format);\n\n   --  ANCHOR(`menu_format()',`Format')\n   procedure Format (Men     : Menu;\n                     Lines   : out Line_Count;\n                     Columns : out Column_Count);\n   --  AKA\n   pragma Inline (Format);\n\n   --  MANPAGE(`menu_hook.3x')\n\n   type Menu_Hook_Function is access procedure (Men : Menu);\n   pragma Convention (C, Menu_Hook_Function);\n\n   --  ANCHOR(`set_item_init()',`Set_Item_Init_Hook')\n   procedure Set_Item_Init_Hook (Men  : Menu;\n                                 Proc : Menu_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Item_Init_Hook);\n\n   --  ANCHOR(`set_item_term()',`Set_Item_Term_Hook')\n   procedure Set_Item_Term_Hook (Men  : Menu;\n                                 Proc : Menu_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Item_Term_Hook);\n\n   --  ANCHOR(`set_menu_init()',`Set_Menu_Init_Hook')\n   procedure Set_Menu_Init_Hook (Men  : Menu;\n                                 Proc : Menu_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Menu_Init_Hook);\n\n   --  ANCHOR(`set_menu_term()',`Set_Menu_Term_Hook')\n   procedure Set_Menu_Term_Hook (Men  : Menu;\n                                 Proc : Menu_Hook_Function);\n   --  AKA\n   pragma Inline (Set_Menu_Term_Hook);\n\n   --  ANCHOR(`item_init()',`Get_Item_Init_Hook')\n   function Get_Item_Init_Hook (Men : Menu) return Menu_Hook_Function;\n   --  AKA\n   pragma Inline (Get_Item_Init_Hook);\n\n   --  ANCHOR(`item_term()',`Get_Item_Term_Hook')\n   function Get_Item_Term_Hook (Men : Menu) return Menu_Hook_Function;\n   --  AKA\n   pragma Inline (Get_Item_Term_Hook);\n\n   --  ANCHOR(`menu_init()',`Get_Menu_Init_Hook')\n   function Get_Menu_Init_Hook (Men : Menu) return Menu_Hook_Function;\n   --  AKA\n   pragma Inline (Get_Menu_Init_Hook);\n\n   --  ANCHOR(`menu_term()',`Get_Menu_Term_Hook')\n   function Get_Menu_Term_Hook (Men : Menu) return Menu_Hook_Function;\n   --  AKA\n   pragma Inline (Get_Menu_Term_Hook);\n\n   --  MANPAGE(`menu_items.3x')\n\n   --  ANCHOR(`set_menu_items()',`Redefine')\n   procedure Redefine (Men   : Menu;\n                       Items : Item_Array_Access);\n   --  AKA\n   pragma Inline (Redefine);\n\n   procedure Set_Items (Men   : Menu;\n                        Items : Item_Array_Access) renames Redefine;\n   --  pragma Inline (Set_Items);\n\n   --  ANCHOR(`menu_items()',`Items')\n   function Items (Men   : Menu;\n                   Index : Positive) return Item;\n   --  AKA\n   pragma Inline (Items);\n\n   --  ANCHOR(`item_count()',`Item_Count')\n   function Item_Count (Men : Menu) return Natural;\n   --  AKA\n   pragma Inline (Item_Count);\n\n   --  MANPAGE(`menu_new.3x')\n\n   --  ANCHOR(`new_menu()',`Create')\n   function Create (Items : Item_Array_Access) return Menu;\n   --  AKA\n   --  Not inlined\n\n   function New_Menu (Items : Item_Array_Access) return Menu renames Create;\n\n   --  ANCHOR(`free_menu()',`Delete')\n   procedure Delete (Men : in out Menu);\n   --  AKA\n   --  Reset Men to Null_Menu\n   --  Not inlined\n\n   --  MANPAGE(`menu_driver.3x')\n\n   type Driver_Result is (Menu_Ok,\n                          Request_Denied,\n                          Unknown_Request,\n                          No_Match);\n\n   --  ANCHOR(`menu_driver()',`Driver')\n   function Driver (Men : Menu;\n                    Key : Key_Code) return Driver_Result;\n   --  AKA\n   --  Driver is not inlined\n\n   --  ANCHOR(`menu_requestname.3x')\n   --  Not Implemented: menu_request_name, menu_request_by_name\n-------------------------------------------------------------------------------\nprivate\n   type Item   is new System.Storage_Elements.Integer_Address;\n   type Menu   is new System.Storage_Elements.Integer_Address;\n\n   Null_Item : constant Item := 0;\n   Null_Menu : constant Menu := 0;\n\nend Terminal_Interface.Curses.Menus;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}