{
  "module_name": "terminal_interface-curses.adb.m4",
  "hash_id": "a318b083d5c44e094731d611e0bdc1722f42b810530e29d5b6cc6238e2322b08",
  "original_prompt": "Ingested from ncurses-6.4/Ada95/gen/terminal_interface-curses.adb.m4",
  "human_readable_source": "--  -*- ada -*-\ndefine(`HTMLNAME',`terminal_interface-curses__adb.htm')dnl\ninclude(M4MACRO)------------------------------------------------------------------------------\n--                                                                          --\n--                           GNAT ncurses Binding                           --\n--                                                                          --\n--                        Terminal_Interface.Curses                         --\n--                                                                          --\n--                                 B O D Y                                  --\n--                                                                          --\n------------------------------------------------------------------------------\n-- Copyright 2018,2020 Thomas E. Dickey                                     --\n-- Copyright 2007-2011,2014 Free Software Foundation, Inc.                  --\n--                                                                          --\n-- Permission is hereby granted, free of charge, to any person obtaining a  --\n-- copy of this software and associated documentation files (the            --\n-- \"Software\"), to deal in the Software without restriction, including      --\n-- without limitation the rights to use, copy, modify, merge, publish,      --\n-- distribute, distribute with modifications, sublicense, and/or sell       --\n-- copies of the Software, and to permit persons to whom the Software is    --\n-- furnished to do so, subject to the following conditions:                 --\n--                                                                          --\n-- The above copyright notice and this permission notice shall be included  --\n-- in all copies or substantial portions of the Software.                   --\n--                                                                          --\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  --\n-- OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               --\n-- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   --\n-- IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   --\n-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    --\n-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    --\n-- THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               --\n--                                                                          --\n-- Except as contained in this notice, the name(s) of the above copyright   --\n-- holders shall not be used in advertising or otherwise to promote the     --\n-- sale, use or other dealings in this Software without prior written       --\n-- authorization.                                                           --\n------------------------------------------------------------------------------\n--  Author: Juergen Pfeifer, 1996\n--  Version Control:\n--  $Revision: 1.16 $\n--  $Date: 2020/02/02 23:34:34 $\n--  Binding Version 01.00\n------------------------------------------------------------------------------\nwith System;\n\nwith Terminal_Interface.Curses.Aux;\nwith Interfaces.C;                  use Interfaces.C;\nwith Interfaces.C.Strings;          use Interfaces.C.Strings;\nwith Ada.Characters.Handling;       use Ada.Characters.Handling;\nwith Ada.Strings.Fixed;\n\npackage body Terminal_Interface.Curses is\n\n   use Aux;\n\n   package ASF renames Ada.Strings.Fixed;\n\n   type chtype_array is array (size_t range <>)\n      of aliased Attributed_Character;\n   pragma Convention (C, chtype_array);\n\n------------------------------------------------------------------------------\n   function Key_Name (Key : Real_Key_Code) return String\n   is\n      function Keyname (K : C_Int) return chars_ptr;\n      pragma Import (C, Keyname, \"keyname\");\n\n      Ch : Character;\n   begin\n      if Key <= Character'Pos (Character'Last) then\n         Ch := Character'Val (Key);\n         if Is_Control (Ch) then\n            return Un_Control (Attributed_Character'(Ch    => Ch,\n                                                     Color => Color_Pair'First,\n                                                     Attr  => Normal_Video));\n         elsif Is_Graphic (Ch) then\n            declare\n               S : String (1 .. 1);\n            begin\n               S (1) := Ch;\n               return S;\n            end;\n         else\n            return \"\";\n         end if;\n      else\n         return Fill_String (Keyname (C_Int (Key)));\n      end if;\n   end Key_Name;\n\n   procedure Key_Name (Key  :  Real_Key_Code;\n                       Name : out String)\n   is\n   begin\n      ASF.Move (Key_Name (Key), Name);\n   end Key_Name;\n\n------------------------------------------------------------------------------\n   procedure Init_Screen\n   is\n      function Initscr return Window;\n      pragma Import (C, Initscr, \"initscr\");\n\n      W : Window;\n   begin\n      W := Initscr;\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n   end Init_Screen;\n\n   procedure End_Windows\n   is\n      function Endwin return C_Int;\n      pragma Import (C, Endwin, \"endwin\");\n   begin\n      if Endwin = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end End_Windows;\n\n   function Is_End_Window return Boolean\n   is\n      function Isendwin return Curses_Bool;\n      pragma Import (C, Isendwin, \"isendwin\");\n   begin\n      if Isendwin = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Is_End_Window;\n------------------------------------------------------------------------------\n   procedure Move_Cursor (Win    : Window := Standard_Window;\n                          Line   : Line_Position;\n                          Column : Column_Position)\n   is\n      function Wmove (Win    : Window;\n                      Line   : C_Int;\n                      Column : C_Int\n                     ) return C_Int;\n      pragma Import (C, Wmove, \"wmove\");\n   begin\n      if Wmove (Win, C_Int (Line), C_Int (Column)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Move_Cursor;\n------------------------------------------------------------------------------\n   procedure Add (Win : Window := Standard_Window;\n                  Ch  : Attributed_Character)\n   is\n      function Waddch (W  : Window;\n                       Ch : Attributed_Character) return C_Int;\n      pragma Import (C, Waddch, \"waddch\");\n   begin\n      if Waddch (Win, Ch) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Add;\n\n   procedure Add (Win : Window := Standard_Window;\n                  Ch  : Character)\n   is\n   begin\n      Add (Win,\n           Attributed_Character'(Ch    => Ch,\n                                 Color => Color_Pair'First,\n                                 Attr  => Normal_Video));\n   end Add;\n\n   procedure Add\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Ch     : Attributed_Character)\n   is\n      function mvwaddch (W  : Window;\n                         Y  : C_Int;\n                         X  : C_Int;\n                         Ch : Attributed_Character) return C_Int;\n      pragma Import (C, mvwaddch, \"mvwaddch\");\n   begin\n      if mvwaddch (Win, C_Int (Line),\n                   C_Int (Column),\n                   Ch) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Add;\n\n   procedure Add\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Ch     : Character)\n   is\n   begin\n      Add (Win,\n           Line,\n           Column,\n           Attributed_Character'(Ch    => Ch,\n                                 Color => Color_Pair'First,\n                                 Attr  => Normal_Video));\n   end Add;\n\n   procedure Add_With_Immediate_Echo\n     (Win : Window := Standard_Window;\n      Ch  : Attributed_Character)\n   is\n      function Wechochar (W  : Window;\n                          Ch : Attributed_Character) return C_Int;\n      pragma Import (C, Wechochar, \"wechochar\");\n   begin\n      if Wechochar (Win, Ch) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Add_With_Immediate_Echo;\n\n   procedure Add_With_Immediate_Echo\n     (Win : Window := Standard_Window;\n      Ch  : Character)\n   is\n   begin\n      Add_With_Immediate_Echo\n        (Win,\n         Attributed_Character'(Ch    => Ch,\n                               Color => Color_Pair'First,\n                               Attr  => Normal_Video));\n   end Add_With_Immediate_Echo;\n------------------------------------------------------------------------------\n   function Create (Number_Of_Lines       : Line_Count;\n                    Number_Of_Columns     : Column_Count;\n                    First_Line_Position   : Line_Position;\n                    First_Column_Position : Column_Position) return Window\n   is\n      function Newwin (Number_Of_Lines       : C_Int;\n                       Number_Of_Columns     : C_Int;\n                       First_Line_Position   : C_Int;\n                       First_Column_Position : C_Int) return Window;\n      pragma Import (C, Newwin, \"newwin\");\n\n      W : Window;\n   begin\n      W := Newwin (C_Int (Number_Of_Lines),\n                   C_Int (Number_Of_Columns),\n                   C_Int (First_Line_Position),\n                   C_Int (First_Column_Position));\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n      return W;\n   end Create;\n\n   procedure Delete (Win : in out Window)\n   is\n      function Wdelwin (W : Window) return C_Int;\n      pragma Import (C, Wdelwin, \"delwin\");\n   begin\n      if Wdelwin (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n      Win := Null_Window;\n   end Delete;\n\n   function Sub_Window\n     (Win                   : Window := Standard_Window;\n      Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window\n   is\n      function Subwin\n        (Win                   : Window;\n         Number_Of_Lines       : C_Int;\n         Number_Of_Columns     : C_Int;\n         First_Line_Position   : C_Int;\n         First_Column_Position : C_Int) return Window;\n      pragma Import (C, Subwin, \"subwin\");\n\n      W : Window;\n   begin\n      W := Subwin (Win,\n                   C_Int (Number_Of_Lines),\n                   C_Int (Number_Of_Columns),\n                   C_Int (First_Line_Position),\n                   C_Int (First_Column_Position));\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n      return W;\n   end Sub_Window;\n\n   function Derived_Window\n     (Win                   : Window := Standard_Window;\n      Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window\n   is\n      function Derwin\n        (Win                   : Window;\n         Number_Of_Lines       : C_Int;\n         Number_Of_Columns     : C_Int;\n         First_Line_Position   : C_Int;\n         First_Column_Position : C_Int) return Window;\n      pragma Import (C, Derwin, \"derwin\");\n\n      W : Window;\n   begin\n      W := Derwin (Win,\n                   C_Int (Number_Of_Lines),\n                   C_Int (Number_Of_Columns),\n                   C_Int (First_Line_Position),\n                   C_Int (First_Column_Position));\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n      return W;\n   end Derived_Window;\n\n   function Duplicate (Win : Window) return Window\n   is\n      function Dupwin (Win : Window) return Window;\n      pragma Import (C, Dupwin, \"dupwin\");\n\n      W : constant Window := Dupwin (Win);\n   begin\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n      return W;\n   end Duplicate;\n\n   procedure Move_Window (Win    : Window;\n                          Line   : Line_Position;\n                          Column : Column_Position)\n   is\n      function Mvwin (Win    : Window;\n                      Line   : C_Int;\n                      Column : C_Int) return C_Int;\n      pragma Import (C, Mvwin, \"mvwin\");\n   begin\n      if Mvwin (Win, C_Int (Line), C_Int (Column)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Move_Window;\n\n   procedure Move_Derived_Window (Win    : Window;\n                                  Line   : Line_Position;\n                                  Column : Column_Position)\n   is\n      function Mvderwin (Win    : Window;\n                         Line   : C_Int;\n                         Column : C_Int) return C_Int;\n      pragma Import (C, Mvderwin, \"mvderwin\");\n   begin\n      if Mvderwin (Win, C_Int (Line), C_Int (Column)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Move_Derived_Window;\n\n   procedure Set_Synch_Mode (Win  : Window  := Standard_Window;\n                             Mode : Boolean := False)\n   is\n      function Syncok (Win  : Window;\n                       Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Syncok, \"syncok\");\n   begin\n      if Syncok (Win, Curses_Bool (Boolean'Pos (Mode))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Synch_Mode;\n------------------------------------------------------------------------------\n   procedure Add (Win : Window := Standard_Window;\n                  Str : String;\n                  Len : Integer := -1)\n   is\n      function Waddnstr (Win : Window;\n                         Str : char_array;\n                         Len : C_Int := -1) return C_Int;\n      pragma Import (C, Waddnstr, \"waddnstr\");\n\n      Txt    : char_array (0 .. Str'Length);\n      Length : size_t;\n   begin\n      To_C (Str, Txt, Length);\n      if Waddnstr (Win, Txt, C_Int (Len)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Add;\n\n   procedure Add\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Str    : String;\n      Len    : Integer := -1)\n   is\n   begin\n      Move_Cursor (Win, Line, Column);\n      Add (Win, Str, Len);\n   end Add;\n------------------------------------------------------------------------------\n   procedure Add\n     (Win : Window := Standard_Window;\n      Str : Attributed_String;\n      Len : Integer := -1)\n   is\n      function Waddchnstr (Win : Window;\n                           Str : chtype_array;\n                           Len : C_Int := -1) return C_Int;\n      pragma Import (C, Waddchnstr, \"waddchnstr\");\n\n      Txt : chtype_array (0 .. Str'Length);\n   begin\n      for Length in 1 .. size_t (Str'Length) loop\n         Txt (Length - 1) := Str (Natural (Length));\n      end loop;\n      Txt (Str'Length) := Default_Character;\n      if Waddchnstr (Win,\n                     Txt,\n                     C_Int (Len)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Add;\n\n   procedure Add\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Str    : Attributed_String;\n      Len    : Integer := -1)\n   is\n   begin\n      Move_Cursor (Win, Line, Column);\n      Add (Win, Str, Len);\n   end Add;\n------------------------------------------------------------------------------\n   procedure Border\n     (Win                       : Window := Standard_Window;\n      Left_Side_Symbol          : Attributed_Character := Default_Character;\n      Right_Side_Symbol         : Attributed_Character := Default_Character;\n      Top_Side_Symbol           : Attributed_Character := Default_Character;\n      Bottom_Side_Symbol        : Attributed_Character := Default_Character;\n      Upper_Left_Corner_Symbol  : Attributed_Character := Default_Character;\n      Upper_Right_Corner_Symbol : Attributed_Character := Default_Character;\n      Lower_Left_Corner_Symbol  : Attributed_Character := Default_Character;\n      Lower_Right_Corner_Symbol : Attributed_Character := Default_Character)\n   is\n      function Wborder (W   : Window;\n                        LS  : Attributed_Character;\n                        RS  : Attributed_Character;\n                        TS  : Attributed_Character;\n                        BS  : Attributed_Character;\n                        ULC : Attributed_Character;\n                        URC : Attributed_Character;\n                        LLC : Attributed_Character;\n                        LRC : Attributed_Character) return C_Int;\n      pragma Import (C, Wborder, \"wborder\");\n   begin\n      if Wborder (Win,\n                  Left_Side_Symbol,\n                  Right_Side_Symbol,\n                  Top_Side_Symbol,\n                  Bottom_Side_Symbol,\n                  Upper_Left_Corner_Symbol,\n                  Upper_Right_Corner_Symbol,\n                  Lower_Left_Corner_Symbol,\n                  Lower_Right_Corner_Symbol) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Border;\n\n   procedure Box\n     (Win               : Window := Standard_Window;\n      Vertical_Symbol   : Attributed_Character := Default_Character;\n      Horizontal_Symbol : Attributed_Character := Default_Character)\n   is\n   begin\n      Border (Win,\n              Vertical_Symbol, Vertical_Symbol,\n              Horizontal_Symbol, Horizontal_Symbol);\n   end Box;\n\n   procedure Horizontal_Line\n     (Win         : Window := Standard_Window;\n      Line_Size   : Natural;\n      Line_Symbol : Attributed_Character := Default_Character)\n   is\n      function Whline (W   : Window;\n                       Ch  : Attributed_Character;\n                       Len : C_Int) return C_Int;\n      pragma Import (C, Whline, \"whline\");\n   begin\n      if Whline (Win,\n                 Line_Symbol,\n                 C_Int (Line_Size)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Horizontal_Line;\n\n   procedure Vertical_Line\n     (Win         : Window := Standard_Window;\n      Line_Size   : Natural;\n      Line_Symbol : Attributed_Character := Default_Character)\n   is\n      function Wvline (W   : Window;\n                       Ch  : Attributed_Character;\n                       Len : C_Int) return C_Int;\n      pragma Import (C, Wvline, \"wvline\");\n   begin\n      if Wvline (Win,\n                 Line_Symbol,\n                 C_Int (Line_Size)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Vertical_Line;\n\n------------------------------------------------------------------------------\n   function Get_Keystroke (Win : Window := Standard_Window)\n     return Real_Key_Code\n   is\n      function Wgetch (W : Window) return C_Int;\n      pragma Import (C, Wgetch, \"wgetch\");\n\n      C : constant C_Int := Wgetch (Win);\n   begin\n      if C = Curses_Err then\n         return Key_None;\n      else\n         return Real_Key_Code (C);\n      end if;\n   end Get_Keystroke;\n\n   procedure Undo_Keystroke (Key : Real_Key_Code)\n   is\n      function Ungetch (Ch : C_Int) return C_Int;\n      pragma Import (C, Ungetch, \"ungetch\");\n   begin\n      if Ungetch (C_Int (Key)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Undo_Keystroke;\n\n   function Has_Key (Key : Special_Key_Code) return Boolean\n   is\n      function Haskey (Key : C_Int) return C_Int;\n      pragma Import (C, Haskey, \"has_key\");\n   begin\n      if Haskey (C_Int (Key)) = Curses_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Has_Key;\n\n   function Is_Function_Key (Key : Special_Key_Code) return Boolean\n   is\n      L : constant Special_Key_Code  := Special_Key_Code (Natural (Key_F0) +\n        Natural (Function_Key_Number'Last));\n   begin\n      if (Key >= Key_F0) and then (Key <= L) then\n         return True;\n      else\n         return False;\n      end if;\n   end Is_Function_Key;\n\n   function Function_Key (Key : Real_Key_Code)\n                          return Function_Key_Number\n   is\n   begin\n      if Is_Function_Key (Key) then\n         return Function_Key_Number (Key - Key_F0);\n      else\n         raise Constraint_Error;\n      end if;\n   end Function_Key;\n\n   function Function_Key_Code (Key : Function_Key_Number) return Real_Key_Code\n   is\n   begin\n      return Real_Key_Code (Natural (Key_F0) + Natural (Key));\n   end Function_Key_Code;\n------------------------------------------------------------------------------\n   procedure Standout (Win : Window  := Standard_Window;\n                       On  : Boolean := True)\n   is\n      function wstandout (Win : Window) return C_Int;\n      pragma Import (C, wstandout, \"wstandout\");\n      function wstandend (Win : Window) return C_Int;\n      pragma Import (C, wstandend, \"wstandend\");\n\n      Err : C_Int;\n   begin\n      if On then\n         Err := wstandout (Win);\n      else\n         Err := wstandend (Win);\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Standout;\n\n   procedure Switch_Character_Attribute\n     (Win  : Window := Standard_Window;\n      Attr : Character_Attribute_Set := Normal_Video;\n      On   : Boolean := True)\n   is\n      function Wattron (Win    : Window;\n                        C_Attr : Attributed_Character) return C_Int;\n      pragma Import (C, Wattron, \"wattr_on\");\n      function Wattroff (Win    : Window;\n                         C_Attr : Attributed_Character) return C_Int;\n      pragma Import (C, Wattroff, \"wattr_off\");\n      --  In Ada we use the On Boolean to control whether or not we want to\n      --  switch on or off the attributes in the set.\n      Err : C_Int;\n      AC  : constant Attributed_Character := (Ch    => Character'First,\n                                              Color => Color_Pair'First,\n                                              Attr  => Attr);\n   begin\n      if On then\n         Err := Wattron  (Win, AC);\n      else\n         Err := Wattroff (Win, AC);\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Switch_Character_Attribute;\n\n   procedure Set_Character_Attributes\n     (Win   : Window := Standard_Window;\n      Attr  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First)\n   is\n      function Wattrset (Win    : Window;\n                         C_Attr : Attributed_Character) return C_Int;\n      pragma Import (C, Wattrset, \"wattrset\"); -- ??? wattr_set\n   begin\n      if Wattrset (Win, (Ch => Character'First,\n                         Color => Color,\n                         Attr => Attr)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Set_Character_Attributes;\n\n   function Get_Character_Attribute (Win : Window := Standard_Window)\n                                     return Character_Attribute_Set\n   is\n      function Wattrget (Win : Window;\n                         Atr : access Attributed_Character;\n                         Col : access C_Short;\n                         Opt : System.Address) return C_Int;\n      pragma Import (C, Wattrget, \"wattr_get\");\n\n      Attr : aliased Attributed_Character;\n      Col  : aliased C_Short;\n      Res  : constant C_Int := Wattrget (Win, Attr'Access, Col'Access,\n                                         System.Null_Address);\n   begin\n      if Res = Curses_Ok then\n         return Attr.Attr;\n      else\n         raise Curses_Exception;\n      end if;\n   end Get_Character_Attribute;\n\n   function Get_Character_Attribute (Win : Window := Standard_Window)\n                                     return Color_Pair\n   is\n      function Wattrget (Win : Window;\n                         Atr : access Attributed_Character;\n                         Col : access C_Short;\n                         Opt : System.Address) return C_Int;\n      pragma Import (C, Wattrget, \"wattr_get\");\n\n      Attr : aliased Attributed_Character;\n      Col  : aliased C_Short;\n      Res  : constant C_Int := Wattrget (Win, Attr'Access, Col'Access,\n                                         System.Null_Address);\n   begin\n      if Res = Curses_Ok then\n         return Attr.Color;\n      else\n         raise Curses_Exception;\n      end if;\n   end Get_Character_Attribute;\n\n   procedure Set_Color (Win  : Window := Standard_Window;\n                        Pair : Color_Pair)\n   is\n      function Wset_Color (Win   : Window;\n                           Color : C_Short;\n                           Opts  : C_Void_Ptr) return C_Int;\n      pragma Import (C, Wset_Color, \"wcolor_set\");\n   begin\n      if Wset_Color (Win,\n                     C_Short (Pair),\n                     C_Void_Ptr (System.Null_Address)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Set_Color;\n\n   procedure Change_Attributes\n     (Win   : Window := Standard_Window;\n      Count : Integer := -1;\n      Attr  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First)\n   is\n      function Wchgat (Win   : Window;\n                       Cnt   : C_Int;\n                       Attr  : Attributed_Character;\n                       Color : C_Short;\n                       Opts  : System.Address := System.Null_Address)\n                       return C_Int;\n      pragma Import (C, Wchgat, \"wchgat\");\n   begin\n      if Wchgat (Win,\n                 C_Int (Count),\n                 (Ch => Character'First,\n                  Color => Color_Pair'First,\n                  Attr => Attr),\n                 C_Short (Color)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Change_Attributes;\n\n   procedure Change_Attributes\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position := Line_Position'First;\n      Column : Column_Position := Column_Position'First;\n      Count  : Integer := -1;\n      Attr   : Character_Attribute_Set := Normal_Video;\n      Color  : Color_Pair := Color_Pair'First)\n   is\n   begin\n      Move_Cursor (Win, Line, Column);\n      Change_Attributes (Win, Count, Attr, Color);\n   end Change_Attributes;\n------------------------------------------------------------------------------\n   procedure Beep\n   is\n      function Beeper return C_Int;\n      pragma Import (C, Beeper, \"beep\");\n   begin\n      if Beeper = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Beep;\n\n   procedure Flash_Screen\n   is\n      function Flash return C_Int;\n      pragma Import (C, Flash, \"flash\");\n   begin\n      if Flash = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Flash_Screen;\n------------------------------------------------------------------------------\n   procedure Set_Cbreak_Mode (SwitchOn : Boolean := True)\n   is\n      function Cbreak return C_Int;\n      pragma Import (C, Cbreak, \"cbreak\");\n      function NoCbreak return C_Int;\n      pragma Import (C, NoCbreak, \"nocbreak\");\n\n      Err : C_Int;\n   begin\n      if SwitchOn then\n         Err := Cbreak;\n      else\n         Err := NoCbreak;\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Cbreak_Mode;\n\n   procedure Set_Raw_Mode (SwitchOn : Boolean := True)\n   is\n      function Raw return C_Int;\n      pragma Import (C, Raw, \"raw\");\n      function NoRaw return C_Int;\n      pragma Import (C, NoRaw, \"noraw\");\n\n      Err : C_Int;\n   begin\n      if SwitchOn then\n         Err := Raw;\n      else\n         Err := NoRaw;\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Raw_Mode;\n\n   procedure Set_Echo_Mode (SwitchOn : Boolean := True)\n   is\n      function Echo return C_Int;\n      pragma Import (C, Echo, \"echo\");\n      function NoEcho return C_Int;\n      pragma Import (C, NoEcho, \"noecho\");\n\n      Err : C_Int;\n   begin\n      if SwitchOn then\n         Err := Echo;\n      else\n         Err := NoEcho;\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Echo_Mode;\n\n   procedure Set_Meta_Mode (Win      : Window := Standard_Window;\n                            SwitchOn : Boolean := True)\n   is\n      function Meta (W : Window; Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Meta, \"meta\");\n   begin\n      if Meta (Win, Curses_Bool (Boolean'Pos (SwitchOn))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Meta_Mode;\n\n   procedure Set_KeyPad_Mode (Win      : Window := Standard_Window;\n                              SwitchOn : Boolean := True)\n   is\n      function Keypad (W : Window; Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Keypad, \"keypad\");\n   begin\n      if Keypad (Win, Curses_Bool (Boolean'Pos (SwitchOn))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_KeyPad_Mode;\n\n   function Get_KeyPad_Mode (Win : Window := Standard_Window)\n                             return Boolean\n   is\n      function Is_Keypad (W : Window) return Curses_Bool;\n      pragma Import (C, Is_Keypad, \"is_keypad\");\n   begin\n      return (Is_Keypad (Win) /= Curses_Bool_False);\n   end Get_KeyPad_Mode;\n\n   procedure Half_Delay (Amount : Half_Delay_Amount)\n   is\n      function Halfdelay (Amount : C_Int) return C_Int;\n      pragma Import (C, Halfdelay, \"halfdelay\");\n   begin\n      if Halfdelay (C_Int (Amount)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Half_Delay;\n\n   procedure Set_Flush_On_Interrupt_Mode\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := True)\n   is\n      function Intrflush (Win : Window; Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Intrflush, \"intrflush\");\n   begin\n      if Intrflush (Win, Curses_Bool (Boolean'Pos (Mode))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Flush_On_Interrupt_Mode;\n\n   procedure Set_Queue_Interrupt_Mode\n     (Win   : Window := Standard_Window;\n      Flush : Boolean := True)\n   is\n      procedure Qiflush;\n      pragma Import (C, Qiflush, \"qiflush\");\n      procedure No_Qiflush;\n      pragma Import (C, No_Qiflush, \"noqiflush\");\n   begin\n      if Win = Null_Window then\n         raise Curses_Exception;\n      end if;\n      if Flush then\n         Qiflush;\n      else\n         No_Qiflush;\n      end if;\n   end Set_Queue_Interrupt_Mode;\n\n   procedure Set_NoDelay_Mode\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := False)\n   is\n      function Nodelay (Win : Window; Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Nodelay, \"nodelay\");\n   begin\n      if Nodelay (Win, Curses_Bool (Boolean'Pos (Mode))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_NoDelay_Mode;\n\n   procedure Set_Timeout_Mode (Win    : Window := Standard_Window;\n                               Mode   : Timeout_Mode;\n                               Amount : Natural)\n   is\n      procedure Wtimeout (Win : Window; Amount : C_Int);\n      pragma Import (C, Wtimeout, \"wtimeout\");\n\n      Time : C_Int;\n   begin\n      case Mode is\n         when Blocking     => Time := -1;\n         when Non_Blocking => Time := 0;\n         when Delayed      =>\n            if Amount = 0 then\n               raise Constraint_Error;\n            end if;\n            Time := C_Int (Amount);\n      end case;\n      Wtimeout (Win, Time);\n   end Set_Timeout_Mode;\n\n   procedure Set_Escape_Timer_Mode\n     (Win       : Window := Standard_Window;\n      Timer_Off : Boolean := False)\n   is\n      function Notimeout (Win : Window; Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Notimeout, \"notimeout\");\n   begin\n      if Notimeout (Win, Curses_Bool (Boolean'Pos (Timer_Off)))\n        = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Set_Escape_Timer_Mode;\n\n------------------------------------------------------------------------------\n   procedure Set_NL_Mode (SwitchOn : Boolean := True)\n   is\n      function NL return C_Int;\n      pragma Import (C, NL, \"nl\");\n      function NoNL return C_Int;\n      pragma Import (C, NoNL, \"nonl\");\n\n      Err : C_Int;\n   begin\n      if SwitchOn then\n         Err := NL;\n      else\n         Err := NoNL;\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_NL_Mode;\n\n   procedure Clear_On_Next_Update\n     (Win      : Window := Standard_Window;\n      Do_Clear : Boolean := True)\n   is\n      function Clear_Ok (W : Window; Flag : Curses_Bool) return C_Int;\n      pragma Import (C, Clear_Ok, \"clearok\");\n   begin\n      if Clear_Ok (Win, Curses_Bool (Boolean'Pos (Do_Clear))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Clear_On_Next_Update;\n\n   procedure Use_Insert_Delete_Line\n     (Win    : Window := Standard_Window;\n      Do_Idl : Boolean := True)\n   is\n      function IDL_Ok (W : Window; Flag : Curses_Bool) return C_Int;\n      pragma Import (C, IDL_Ok, \"idlok\");\n   begin\n      if IDL_Ok (Win, Curses_Bool (Boolean'Pos (Do_Idl))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Use_Insert_Delete_Line;\n\n   procedure Use_Insert_Delete_Character\n     (Win    : Window := Standard_Window;\n      Do_Idc : Boolean := True)\n   is\n      procedure IDC_Ok (W : Window; Flag : Curses_Bool);\n      pragma Import (C, IDC_Ok, \"idcok\");\n   begin\n      IDC_Ok (Win, Curses_Bool (Boolean'Pos (Do_Idc)));\n   end Use_Insert_Delete_Character;\n\n   procedure Leave_Cursor_After_Update\n     (Win      : Window := Standard_Window;\n      Do_Leave : Boolean := True)\n   is\n      function Leave_Ok (W : Window; Flag : Curses_Bool) return C_Int;\n      pragma Import (C, Leave_Ok, \"leaveok\");\n   begin\n      if Leave_Ok (Win, Curses_Bool (Boolean'Pos (Do_Leave))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Leave_Cursor_After_Update;\n\n   procedure Immediate_Update_Mode\n     (Win  : Window := Standard_Window;\n      Mode : Boolean := False)\n   is\n      procedure Immedok (Win : Window; Mode : Curses_Bool);\n      pragma Import (C, Immedok, \"immedok\");\n   begin\n      Immedok (Win, Curses_Bool (Boolean'Pos (Mode)));\n   end Immediate_Update_Mode;\n\n   procedure Allow_Scrolling\n     (Win  : Window  := Standard_Window;\n      Mode : Boolean := False)\n   is\n      function Scrollok (Win : Window; Mode : Curses_Bool) return C_Int;\n      pragma Import (C, Scrollok, \"scrollok\");\n   begin\n      if Scrollok (Win, Curses_Bool (Boolean'Pos (Mode))) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Allow_Scrolling;\n\n   function Scrolling_Allowed (Win : Window := Standard_Window)\n                               return Boolean\n   is\n      function Is_Scroll_Ok (W : Window) return Curses_Bool;\n      pragma Import (C, Is_Scroll_Ok, \"is_scrollok\");\n   begin\n      return (Is_Scroll_Ok (Win) /= Curses_Bool_False);\n   end Scrolling_Allowed;\n\n   procedure Set_Scroll_Region\n     (Win         : Window := Standard_Window;\n      Top_Line    : Line_Position;\n      Bottom_Line : Line_Position)\n   is\n      function Wsetscrreg (Win : Window;\n                           Lin : C_Int;\n                           Col : C_Int) return C_Int;\n      pragma Import (C, Wsetscrreg, \"wsetscrreg\");\n   begin\n      if Wsetscrreg (Win, C_Int (Top_Line), C_Int (Bottom_Line))\n        = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Set_Scroll_Region;\n------------------------------------------------------------------------------\n   procedure Update_Screen\n   is\n      function Do_Update return C_Int;\n      pragma Import (C, Do_Update, \"doupdate\");\n   begin\n      if Do_Update = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Update_Screen;\n\n   procedure Refresh (Win : Window := Standard_Window)\n   is\n      function Wrefresh (W : Window) return C_Int;\n      pragma Import (C, Wrefresh, \"wrefresh\");\n   begin\n      if Wrefresh (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Refresh;\n\n   procedure Refresh_Without_Update\n     (Win : Window := Standard_Window)\n   is\n      function Wnoutrefresh (W : Window) return C_Int;\n      pragma Import (C, Wnoutrefresh, \"wnoutrefresh\");\n   begin\n      if Wnoutrefresh (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Refresh_Without_Update;\n\n   procedure Redraw (Win : Window := Standard_Window)\n   is\n      function Redrawwin (Win : Window) return C_Int;\n      pragma Import (C, Redrawwin, \"redrawwin\");\n   begin\n      if Redrawwin (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Redraw;\n\n   procedure Redraw\n     (Win        : Window := Standard_Window;\n      Begin_Line : Line_Position;\n      Line_Count : Positive)\n   is\n      function Wredrawln (Win : Window; First : C_Int; Cnt : C_Int)\n                          return C_Int;\n      pragma Import (C, Wredrawln, \"wredrawln\");\n   begin\n      if Wredrawln (Win,\n                    C_Int (Begin_Line),\n                    C_Int (Line_Count)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Redraw;\n\n------------------------------------------------------------------------------\n   procedure Erase (Win : Window := Standard_Window)\n   is\n      function Werase (W : Window) return C_Int;\n      pragma Import (C, Werase, \"werase\");\n   begin\n      if Werase (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Erase;\n\n   procedure Clear (Win : Window := Standard_Window)\n   is\n      function Wclear (W : Window) return C_Int;\n      pragma Import (C, Wclear, \"wclear\");\n   begin\n      if Wclear (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Clear;\n\n   procedure Clear_To_End_Of_Screen (Win : Window := Standard_Window)\n   is\n      function Wclearbot (W : Window) return C_Int;\n      pragma Import (C, Wclearbot, \"wclrtobot\");\n   begin\n      if Wclearbot (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Clear_To_End_Of_Screen;\n\n   procedure Clear_To_End_Of_Line (Win : Window := Standard_Window)\n   is\n      function Wcleareol (W : Window) return C_Int;\n      pragma Import (C, Wcleareol, \"wclrtoeol\");\n   begin\n      if Wcleareol (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Clear_To_End_Of_Line;\n------------------------------------------------------------------------------\n   procedure Set_Background\n     (Win : Window := Standard_Window;\n      Ch  : Attributed_Character)\n   is\n      procedure WBackground (W : Window; Ch : Attributed_Character);\n      pragma Import (C, WBackground, \"wbkgdset\");\n   begin\n      WBackground (Win, Ch);\n   end Set_Background;\n\n   procedure Change_Background\n     (Win : Window := Standard_Window;\n      Ch  : Attributed_Character)\n   is\n      function WChangeBkgd (W : Window; Ch : Attributed_Character)\n         return C_Int;\n      pragma Import (C, WChangeBkgd, \"wbkgd\");\n   begin\n      if WChangeBkgd (Win, Ch) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Change_Background;\n\n   function Get_Background (Win : Window := Standard_Window)\n     return Attributed_Character\n   is\n      function Wgetbkgd (Win : Window) return Attributed_Character;\n      pragma Import (C, Wgetbkgd, \"getbkgd\");\n   begin\n      return Wgetbkgd (Win);\n   end Get_Background;\n------------------------------------------------------------------------------\n   procedure Change_Lines_Status (Win   : Window := Standard_Window;\n                                  Start : Line_Position;\n                                  Count : Positive;\n                                  State : Boolean)\n   is\n      function Wtouchln (Win : Window;\n                         Sta : C_Int;\n                         Cnt : C_Int;\n                         Chg : C_Int) return C_Int;\n      pragma Import (C, Wtouchln, \"wtouchln\");\n   begin\n      if Wtouchln (Win, C_Int (Start), C_Int (Count),\n                   C_Int (Boolean'Pos (State))) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Change_Lines_Status;\n\n   procedure Touch (Win : Window := Standard_Window)\n   is\n      Y : Line_Position;\n      X : Column_Position;\n   begin\n      Get_Size (Win, Y, X);\n      pragma Warnings (Off, X);         --  unreferenced\n      Change_Lines_Status (Win, 0, Positive (Y), True);\n   end Touch;\n\n   procedure Untouch (Win : Window := Standard_Window)\n   is\n      Y : Line_Position;\n      X : Column_Position;\n   begin\n      Get_Size (Win, Y, X);\n      pragma Warnings (Off, X);         --  unreferenced\n      Change_Lines_Status (Win, 0, Positive (Y), False);\n   end Untouch;\n\n   procedure Touch (Win   : Window := Standard_Window;\n                    Start : Line_Position;\n                    Count : Positive)\n   is\n   begin\n      Change_Lines_Status (Win, Start, Count, True);\n   end Touch;\n\n   function Is_Touched\n     (Win  : Window := Standard_Window;\n      Line : Line_Position) return Boolean\n   is\n      function WLineTouched (W : Window; L : C_Int) return Curses_Bool;\n      pragma Import (C, WLineTouched, \"is_linetouched\");\n   begin\n      if WLineTouched (Win, C_Int (Line)) = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Is_Touched;\n\n   function Is_Touched\n     (Win : Window := Standard_Window) return Boolean\n   is\n      function WWinTouched (W : Window) return Curses_Bool;\n      pragma Import (C, WWinTouched, \"is_wintouched\");\n   begin\n      if WWinTouched (Win) = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Is_Touched;\n------------------------------------------------------------------------------\n   procedure Copy\n     (Source_Window            : Window;\n      Destination_Window       : Window;\n      Source_Top_Row           : Line_Position;\n      Source_Left_Column       : Column_Position;\n      Destination_Top_Row      : Line_Position;\n      Destination_Left_Column  : Column_Position;\n      Destination_Bottom_Row   : Line_Position;\n      Destination_Right_Column : Column_Position;\n      Non_Destructive_Mode     : Boolean := True)\n   is\n      function Copywin (Src : Window;\n                        Dst : Window;\n                        Str : C_Int;\n                        Slc : C_Int;\n                        Dtr : C_Int;\n                        Dlc : C_Int;\n                        Dbr : C_Int;\n                        Drc : C_Int;\n                        Ndm : C_Int) return C_Int;\n      pragma Import (C, Copywin, \"copywin\");\n   begin\n      if Copywin (Source_Window,\n                  Destination_Window,\n                  C_Int (Source_Top_Row),\n                  C_Int (Source_Left_Column),\n                  C_Int (Destination_Top_Row),\n                  C_Int (Destination_Left_Column),\n                  C_Int (Destination_Bottom_Row),\n                  C_Int (Destination_Right_Column),\n                  Boolean'Pos (Non_Destructive_Mode)\n                 ) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Copy;\n\n   procedure Overwrite\n     (Source_Window      : Window;\n      Destination_Window : Window)\n   is\n      function Overwrite (Src : Window; Dst : Window) return C_Int;\n      pragma Import (C, Overwrite, \"overwrite\");\n   begin\n      if Overwrite (Source_Window, Destination_Window) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Overwrite;\n\n   procedure Overlay\n     (Source_Window      : Window;\n      Destination_Window : Window)\n   is\n      function Overlay (Src : Window; Dst : Window) return C_Int;\n      pragma Import (C, Overlay, \"overlay\");\n   begin\n      if Overlay (Source_Window, Destination_Window) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Overlay;\n\n------------------------------------------------------------------------------\n   procedure Insert_Delete_Lines\n     (Win   : Window := Standard_Window;\n      Lines : Integer       := 1) -- default is to insert one line above\n   is\n      function Winsdelln (W : Window; N : C_Int) return C_Int;\n      pragma Import (C, Winsdelln, \"winsdelln\");\n   begin\n      if Winsdelln (Win, C_Int (Lines)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Insert_Delete_Lines;\n\n   procedure Delete_Line (Win : Window := Standard_Window)\n   is\n   begin\n      Insert_Delete_Lines (Win, -1);\n   end Delete_Line;\n\n   procedure Insert_Line (Win : Window := Standard_Window)\n   is\n   begin\n      Insert_Delete_Lines (Win, 1);\n   end Insert_Line;\n------------------------------------------------------------------------------\n\n   procedure Get_Size\n     (Win               : Window := Standard_Window;\n      Number_Of_Lines   : out Line_Count;\n      Number_Of_Columns : out Column_Count)\n   is\n      function GetMaxY (W : Window) return C_Int;\n      pragma Import (C, GetMaxY, \"getmaxy\");\n\n      function GetMaxX (W : Window) return C_Int;\n      pragma Import (C, GetMaxX, \"getmaxx\");\n\n      Y : constant C_Int := GetMaxY (Win);\n      X : constant C_Int := GetMaxX (Win);\n   begin\n      Number_Of_Lines   := Line_Count (Y);\n      Number_Of_Columns := Column_Count (X);\n   end Get_Size;\n\n   procedure Get_Window_Position\n     (Win             : Window := Standard_Window;\n      Top_Left_Line   : out Line_Position;\n      Top_Left_Column : out Column_Position)\n   is\n      function GetBegY (W : Window) return C_Int;\n      pragma Import (C, GetBegY, \"getbegy\");\n\n      function GetBegX (W : Window) return C_Int;\n      pragma Import (C, GetBegX, \"getbegx\");\n\n      Y : constant C_Short := C_Short (GetBegY (Win));\n      X : constant C_Short := C_Short (GetBegX (Win));\n   begin\n      Top_Left_Line   := Line_Position (Y);\n      Top_Left_Column := Column_Position (X);\n   end Get_Window_Position;\n\n   procedure Get_Cursor_Position\n     (Win    :  Window := Standard_Window;\n      Line   : out Line_Position;\n      Column : out Column_Position)\n   is\n      function GetCurY (W : Window) return C_Int;\n      pragma Import (C, GetCurY, \"getcury\");\n\n      function GetCurX (W : Window) return C_Int;\n      pragma Import (C, GetCurX, \"getcurx\");\n\n      Y : constant C_Short := C_Short (GetCurY (Win));\n      X : constant C_Short := C_Short (GetCurX (Win));\n   begin\n      Line   := Line_Position (Y);\n      Column := Column_Position (X);\n   end Get_Cursor_Position;\n\n   procedure Get_Origin_Relative_To_Parent\n     (Win                :  Window;\n      Top_Left_Line      : out Line_Position;\n      Top_Left_Column    : out Column_Position;\n      Is_Not_A_Subwindow : out Boolean)\n   is\n      function GetParY (W : Window) return C_Int;\n      pragma Import (C, GetParY, \"getpary\");\n\n      function GetParX (W : Window) return C_Int;\n      pragma Import (C, GetParX, \"getparx\");\n\n      Y : constant C_Int := GetParY (Win);\n      X : constant C_Int := GetParX (Win);\n   begin\n      if Y = -1 then\n         Top_Left_Line   := Line_Position'Last;\n         Top_Left_Column := Column_Position'Last;\n         Is_Not_A_Subwindow := True;\n      else\n         Top_Left_Line   := Line_Position (Y);\n         Top_Left_Column := Column_Position (X);\n         Is_Not_A_Subwindow := False;\n      end if;\n   end Get_Origin_Relative_To_Parent;\n------------------------------------------------------------------------------\n   function New_Pad (Lines   : Line_Count;\n                     Columns : Column_Count) return Window\n   is\n      function Newpad (Lines : C_Int; Columns : C_Int) return Window;\n      pragma Import (C, Newpad, \"newpad\");\n\n      W : Window;\n   begin\n      W := Newpad (C_Int (Lines), C_Int (Columns));\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n      return W;\n   end New_Pad;\n\n   function Sub_Pad\n     (Pad                   : Window;\n      Number_Of_Lines       : Line_Count;\n      Number_Of_Columns     : Column_Count;\n      First_Line_Position   : Line_Position;\n      First_Column_Position : Column_Position) return Window\n   is\n      function Subpad\n        (Pad                   : Window;\n         Number_Of_Lines       : C_Int;\n         Number_Of_Columns     : C_Int;\n         First_Line_Position   : C_Int;\n         First_Column_Position : C_Int) return Window;\n      pragma Import (C, Subpad, \"subpad\");\n\n      W : Window;\n   begin\n      W := Subpad (Pad,\n                   C_Int (Number_Of_Lines),\n                   C_Int (Number_Of_Columns),\n                   C_Int (First_Line_Position),\n                   C_Int (First_Column_Position));\n      if W = Null_Window then\n         raise Curses_Exception;\n      end if;\n      return W;\n   end Sub_Pad;\n\n   procedure Refresh\n     (Pad                      : Window;\n      Source_Top_Row           : Line_Position;\n      Source_Left_Column       : Column_Position;\n      Destination_Top_Row      : Line_Position;\n      Destination_Left_Column  : Column_Position;\n      Destination_Bottom_Row   : Line_Position;\n      Destination_Right_Column : Column_Position)\n   is\n      function Prefresh\n        (Pad                      : Window;\n         Source_Top_Row           : C_Int;\n         Source_Left_Column       : C_Int;\n         Destination_Top_Row      : C_Int;\n         Destination_Left_Column  : C_Int;\n         Destination_Bottom_Row   : C_Int;\n         Destination_Right_Column : C_Int) return C_Int;\n      pragma Import (C, Prefresh, \"prefresh\");\n   begin\n      if Prefresh (Pad,\n                   C_Int (Source_Top_Row),\n                   C_Int (Source_Left_Column),\n                   C_Int (Destination_Top_Row),\n                   C_Int (Destination_Left_Column),\n                   C_Int (Destination_Bottom_Row),\n                   C_Int (Destination_Right_Column)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Refresh;\n\n   procedure Refresh_Without_Update\n     (Pad                      : Window;\n      Source_Top_Row           : Line_Position;\n      Source_Left_Column       : Column_Position;\n      Destination_Top_Row      : Line_Position;\n      Destination_Left_Column  : Column_Position;\n      Destination_Bottom_Row   : Line_Position;\n      Destination_Right_Column : Column_Position)\n   is\n      function Pnoutrefresh\n        (Pad                      : Window;\n         Source_Top_Row           : C_Int;\n         Source_Left_Column       : C_Int;\n         Destination_Top_Row      : C_Int;\n         Destination_Left_Column  : C_Int;\n         Destination_Bottom_Row   : C_Int;\n         Destination_Right_Column : C_Int) return C_Int;\n      pragma Import (C, Pnoutrefresh, \"pnoutrefresh\");\n   begin\n      if Pnoutrefresh (Pad,\n                       C_Int (Source_Top_Row),\n                       C_Int (Source_Left_Column),\n                       C_Int (Destination_Top_Row),\n                       C_Int (Destination_Left_Column),\n                       C_Int (Destination_Bottom_Row),\n                       C_Int (Destination_Right_Column)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Refresh_Without_Update;\n\n   procedure Add_Character_To_Pad_And_Echo_It\n     (Pad : Window;\n      Ch  : Attributed_Character)\n   is\n      function Pechochar (Pad : Window; Ch : Attributed_Character)\n                          return C_Int;\n      pragma Import (C, Pechochar, \"pechochar\");\n   begin\n      if Pechochar (Pad, Ch) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Add_Character_To_Pad_And_Echo_It;\n\n   procedure Add_Character_To_Pad_And_Echo_It\n     (Pad : Window;\n      Ch  : Character)\n   is\n   begin\n      Add_Character_To_Pad_And_Echo_It\n        (Pad,\n         Attributed_Character'(Ch    => Ch,\n                               Color => Color_Pair'First,\n                               Attr  => Normal_Video));\n   end Add_Character_To_Pad_And_Echo_It;\n------------------------------------------------------------------------------\n   procedure Scroll (Win    : Window := Standard_Window;\n                     Amount : Integer := 1)\n   is\n      function Wscrl (Win : Window; N : C_Int) return C_Int;\n      pragma Import (C, Wscrl, \"wscrl\");\n\n   begin\n      if Wscrl (Win, C_Int (Amount)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Scroll;\n\n------------------------------------------------------------------------------\n   procedure Delete_Character (Win : Window := Standard_Window)\n   is\n      function Wdelch (Win : Window) return C_Int;\n      pragma Import (C, Wdelch, \"wdelch\");\n   begin\n      if Wdelch (Win) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Delete_Character;\n\n   procedure Delete_Character\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position)\n   is\n      function Mvwdelch (Win : Window;\n                         Lin : C_Int;\n                         Col : C_Int) return C_Int;\n      pragma Import (C, Mvwdelch, \"mvwdelch\");\n   begin\n      if Mvwdelch (Win, C_Int (Line), C_Int (Column)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Delete_Character;\n------------------------------------------------------------------------------\n   function Peek (Win : Window := Standard_Window)\n     return Attributed_Character\n   is\n      function Winch (Win : Window) return Attributed_Character;\n      pragma Import (C, Winch, \"winch\");\n   begin\n      return Winch (Win);\n   end Peek;\n\n   function Peek\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position) return Attributed_Character\n   is\n      function Mvwinch (Win : Window;\n                        Lin : C_Int;\n                        Col : C_Int) return Attributed_Character;\n      pragma Import (C, Mvwinch, \"mvwinch\");\n   begin\n      return Mvwinch (Win, C_Int (Line), C_Int (Column));\n   end Peek;\n------------------------------------------------------------------------------\n   procedure Insert (Win : Window := Standard_Window;\n                     Ch  : Attributed_Character)\n   is\n      function Winsch (Win : Window; Ch : Attributed_Character) return C_Int;\n      pragma Import (C, Winsch, \"winsch\");\n   begin\n      if Winsch (Win, Ch) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Insert;\n\n   procedure Insert\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Ch     : Attributed_Character)\n   is\n      function Mvwinsch (Win : Window;\n                         Lin : C_Int;\n                         Col : C_Int;\n                         Ch  : Attributed_Character) return C_Int;\n      pragma Import (C, Mvwinsch, \"mvwinsch\");\n   begin\n      if Mvwinsch (Win,\n                   C_Int (Line),\n                   C_Int (Column),\n                   Ch) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Insert;\n------------------------------------------------------------------------------\n   procedure Insert (Win : Window := Standard_Window;\n                     Str : String;\n                     Len : Integer := -1)\n   is\n      function Winsnstr (Win : Window;\n                         Str : char_array;\n                         Len : Integer := -1) return C_Int;\n      pragma Import (C, Winsnstr, \"winsnstr\");\n\n      Txt    : char_array (0 .. Str'Length);\n      Length : size_t;\n   begin\n      To_C (Str, Txt, Length);\n      if Winsnstr (Win, Txt, Len) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Insert;\n\n   procedure Insert\n     (Win    : Window := Standard_Window;\n      Line   : Line_Position;\n      Column : Column_Position;\n      Str    : String;\n      Len    : Integer := -1)\n   is\n      function Mvwinsnstr (Win    : Window;\n                           Line   : C_Int;\n                           Column : C_Int;\n                           Str    : char_array;\n                           Len    : C_Int) return C_Int;\n      pragma Import (C, Mvwinsnstr, \"mvwinsnstr\");\n\n      Txt    : char_array (0 .. Str'Length);\n      Length : size_t;\n   begin\n      To_C (Str, Txt, Length);\n      if Mvwinsnstr (Win, C_Int (Line), C_Int (Column), Txt, C_Int (Len))\n        = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Insert;\n------------------------------------------------------------------------------\n   procedure Peek (Win :  Window := Standard_Window;\n                   Str : out String;\n                   Len :  Integer := -1)\n   is\n      function Winnstr (Win : Window;\n                        Str : char_array;\n                        Len : C_Int) return C_Int;\n      pragma Import (C, Winnstr, \"winnstr\");\n\n      N   : Integer := Len;\n      Txt : char_array (0 .. Str'Length);\n      Cnt : Natural;\n   begin\n      if N < 0 then\n         N := Str'Length;\n      end if;\n      if N > Str'Length then\n         raise Constraint_Error;\n      end if;\n      Txt (0) := Interfaces.C.char'First;\n      if Winnstr (Win, Txt, C_Int (N)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n      To_Ada (Txt, Str, Cnt, True);\n      if Cnt < Str'Length then\n         Str ((Str'First + Cnt) .. Str'Last) := (others => ' ');\n      end if;\n   end Peek;\n\n   procedure Peek\n     (Win    :  Window := Standard_Window;\n      Line   :  Line_Position;\n      Column :  Column_Position;\n      Str    : out String;\n      Len    :  Integer := -1)\n   is\n   begin\n      Move_Cursor (Win, Line, Column);\n      Peek (Win, Str, Len);\n   end Peek;\n------------------------------------------------------------------------------\n   procedure Peek\n     (Win :  Window := Standard_Window;\n      Str : out Attributed_String;\n      Len :  Integer := -1)\n   is\n      function Winchnstr (Win : Window;\n                          Str : chtype_array;             -- out\n                          Len : C_Int) return C_Int;\n      pragma Import (C, Winchnstr, \"winchnstr\");\n\n      N   : Integer := Len;\n      Txt : constant chtype_array (0 .. Str'Length)\n          := (0 => Default_Character);\n      Cnt : Natural := 0;\n   begin\n      if N < 0 then\n         N := Str'Length;\n      end if;\n      if N > Str'Length then\n         raise Constraint_Error;\n      end if;\n      if Winchnstr (Win, Txt, C_Int (N)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n      for To in Str'Range loop\n         exit when Txt (size_t (Cnt)) = Default_Character;\n         Str (To) := Txt (size_t (Cnt));\n         Cnt := Cnt + 1;\n      end loop;\n      if Cnt < Str'Length then\n         Str ((Str'First + Cnt) .. Str'Last) :=\n           (others => (Ch => ' ',\n                       Color => Color_Pair'First,\n                       Attr => Normal_Video));\n      end if;\n   end Peek;\n\n   procedure Peek\n     (Win    :  Window := Standard_Window;\n      Line   :  Line_Position;\n      Column :  Column_Position;\n      Str    : out Attributed_String;\n      Len    : Integer := -1)\n   is\n   begin\n      Move_Cursor (Win, Line, Column);\n      Peek (Win, Str, Len);\n   end Peek;\n------------------------------------------------------------------------------\n   procedure Get (Win :  Window := Standard_Window;\n                  Str : out String;\n                  Len :  Integer := -1)\n   is\n      function Wgetnstr (Win : Window;\n                         Str : char_array;\n                         Len : C_Int) return C_Int;\n      pragma Import (C, Wgetnstr, \"wgetnstr\");\n\n      N   : Integer := Len;\n      Txt : char_array (0 .. Str'Length);\n      Cnt : Natural;\n   begin\n      if N < 0 then\n         N := Str'Length;\n      end if;\n      if N > Str'Length then\n         raise Constraint_Error;\n      end if;\n      Txt (0) := Interfaces.C.char'First;\n      if Wgetnstr (Win, Txt, C_Int (N)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n      To_Ada (Txt, Str, Cnt, True);\n      if Cnt < Str'Length then\n         Str ((Str'First + Cnt) .. Str'Last) := (others => ' ');\n      end if;\n   end Get;\n\n   procedure Get\n     (Win    :  Window := Standard_Window;\n      Line   :  Line_Position;\n      Column :  Column_Position;\n      Str    : out String;\n      Len    :  Integer := -1)\n   is\n   begin\n      Move_Cursor (Win, Line, Column);\n      Get (Win, Str, Len);\n   end Get;\n------------------------------------------------------------------------------\n   procedure Init_Soft_Label_Keys\n     (Format : Soft_Label_Key_Format := Three_Two_Three)\n   is\n      function Slk_Init (Fmt : C_Int) return C_Int;\n      pragma Import (C, Slk_Init, \"slk_init\");\n   begin\n      if Slk_Init (Soft_Label_Key_Format'Pos (Format)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Init_Soft_Label_Keys;\n\n   procedure Set_Soft_Label_Key (Label : Label_Number;\n                                 Text  : String;\n                                 Fmt   : Label_Justification := Left)\n   is\n      function Slk_Set (Label : C_Int;\n                        Txt   : char_array;\n                        Fmt   : C_Int) return C_Int;\n      pragma Import (C, Slk_Set, \"slk_set\");\n\n      Txt : char_array (0 .. Text'Length);\n      Len : size_t;\n   begin\n      To_C (Text, Txt, Len);\n      if Slk_Set (C_Int (Label), Txt,\n                  C_Int (Label_Justification'Pos (Fmt))) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Set_Soft_Label_Key;\n\n   procedure Refresh_Soft_Label_Keys\n   is\n      function Slk_Refresh return C_Int;\n      pragma Import (C, Slk_Refresh, \"slk_refresh\");\n   begin\n      if Slk_Refresh = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Refresh_Soft_Label_Keys;\n\n   procedure Refresh_Soft_Label_Keys_Without_Update\n   is\n      function Slk_Noutrefresh return C_Int;\n      pragma Import (C, Slk_Noutrefresh, \"slk_noutrefresh\");\n   begin\n      if Slk_Noutrefresh = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Refresh_Soft_Label_Keys_Without_Update;\n\n   procedure Get_Soft_Label_Key (Label : Label_Number;\n                                 Text  : out String)\n   is\n      function Slk_Label (Label : C_Int) return chars_ptr;\n      pragma Import (C, Slk_Label, \"slk_label\");\n   begin\n      Fill_String (Slk_Label (C_Int (Label)), Text);\n   end Get_Soft_Label_Key;\n\n   function Get_Soft_Label_Key (Label : Label_Number) return String\n   is\n      function Slk_Label (Label : C_Int) return chars_ptr;\n      pragma Import (C, Slk_Label, \"slk_label\");\n   begin\n      return Fill_String (Slk_Label (C_Int (Label)));\n   end Get_Soft_Label_Key;\n\n   procedure Clear_Soft_Label_Keys\n   is\n      function Slk_Clear return C_Int;\n      pragma Import (C, Slk_Clear, \"slk_clear\");\n   begin\n      if Slk_Clear = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Clear_Soft_Label_Keys;\n\n   procedure Restore_Soft_Label_Keys\n   is\n      function Slk_Restore return C_Int;\n      pragma Import (C, Slk_Restore, \"slk_restore\");\n   begin\n      if Slk_Restore = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Restore_Soft_Label_Keys;\n\n   procedure Touch_Soft_Label_Keys\n   is\n      function Slk_Touch return C_Int;\n      pragma Import (C, Slk_Touch, \"slk_touch\");\n   begin\n      if Slk_Touch = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Touch_Soft_Label_Keys;\n\n   procedure Switch_Soft_Label_Key_Attributes\n     (Attr : Character_Attribute_Set;\n      On   : Boolean := True)\n   is\n      function Slk_Attron (Ch : Attributed_Character) return C_Int;\n      pragma Import (C, Slk_Attron, \"slk_attron\");\n      function Slk_Attroff (Ch : Attributed_Character) return C_Int;\n      pragma Import (C, Slk_Attroff, \"slk_attroff\");\n\n      Err : C_Int;\n      Ch  : constant Attributed_Character := (Ch    => Character'First,\n                                              Attr  => Attr,\n                                              Color => Color_Pair'First);\n   begin\n      if On then\n         Err := Slk_Attron  (Ch);\n      else\n         Err := Slk_Attroff (Ch);\n      end if;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Switch_Soft_Label_Key_Attributes;\n\n   procedure Set_Soft_Label_Key_Attributes\n     (Attr  : Character_Attribute_Set := Normal_Video;\n      Color : Color_Pair := Color_Pair'First)\n   is\n      function Slk_Attrset (Ch : Attributed_Character) return C_Int;\n      pragma Import (C, Slk_Attrset, \"slk_attrset\");\n\n      Ch : constant Attributed_Character := (Ch    => Character'First,\n                                             Attr  => Attr,\n                                             Color => Color);\n   begin\n      if Slk_Attrset (Ch) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Soft_Label_Key_Attributes;\n\n   function Get_Soft_Label_Key_Attributes return Character_Attribute_Set\n   is\n      function Slk_Attr return Attributed_Character;\n      pragma Import (C, Slk_Attr, \"slk_attr\");\n\n      Attr : constant Attributed_Character := Slk_Attr;\n   begin\n      return Attr.Attr;\n   end Get_Soft_Label_Key_Attributes;\n\n   function Get_Soft_Label_Key_Attributes return Color_Pair\n   is\n      function Slk_Attr return Attributed_Character;\n      pragma Import (C, Slk_Attr, \"slk_attr\");\n\n      Attr : constant Attributed_Character := Slk_Attr;\n   begin\n      return Attr.Color;\n   end Get_Soft_Label_Key_Attributes;\n\n   procedure Set_Soft_Label_Key_Color (Pair : Color_Pair)\n   is\n      function Slk_Color (Color : C_Short) return C_Int;\n      pragma Import (C, Slk_Color, \"slk_color\");\n   begin\n      if Slk_Color (C_Short (Pair)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Set_Soft_Label_Key_Color;\n\n------------------------------------------------------------------------------\n   procedure Enable_Key (Key    : Special_Key_Code;\n                         Enable : Boolean := True)\n   is\n      function Keyok (Keycode : C_Int;\n                      On_Off  : Curses_Bool) return C_Int;\n      pragma Import (C, Keyok, \"keyok\");\n   begin\n      if Keyok (C_Int (Key), Curses_Bool (Boolean'Pos (Enable)))\n        = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Enable_Key;\n------------------------------------------------------------------------------\n   procedure Define_Key (Definition : String;\n                         Key        : Special_Key_Code)\n   is\n      function Defkey (Def : char_array;\n                       Key : C_Int) return C_Int;\n      pragma Import (C, Defkey, \"define_key\");\n\n      Txt    : char_array (0 .. Definition'Length);\n      Length : size_t;\n   begin\n      To_C (Definition, Txt, Length);\n      if Defkey (Txt, C_Int (Key)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Define_Key;\n------------------------------------------------------------------------------\n   procedure Un_Control (Ch  : Attributed_Character;\n                         Str : out String)\n   is\n      function Unctrl (Ch : Attributed_Character) return chars_ptr;\n      pragma Import (C, Unctrl, \"unctrl\");\n   begin\n      Fill_String (Unctrl (Ch), Str);\n   end Un_Control;\n\n   function Un_Control (Ch : Attributed_Character) return String\n   is\n      function Unctrl (Ch : Attributed_Character) return chars_ptr;\n      pragma Import (C, Unctrl, \"unctrl\");\n   begin\n      return Fill_String (Unctrl (Ch));\n   end Un_Control;\n\n   procedure Delay_Output (Msecs : Natural)\n   is\n      function Delayoutput (Msecs : C_Int) return C_Int;\n      pragma Import (C, Delayoutput, \"delay_output\");\n   begin\n      if Delayoutput (C_Int (Msecs)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Delay_Output;\n\n   procedure Flush_Input\n   is\n      function Flushinp return C_Int;\n      pragma Import (C, Flushinp, \"flushinp\");\n   begin\n      if Flushinp = Curses_Err then  -- docu says that never happens, but...\n         raise Curses_Exception;\n      end if;\n   end Flush_Input;\n------------------------------------------------------------------------------\n   function Baudrate return Natural\n   is\n      function Baud return C_Int;\n      pragma Import (C, Baud, \"baudrate\");\n   begin\n      return Natural (Baud);\n   end Baudrate;\n\n   function Erase_Character return Character\n   is\n      function Erasechar return C_Int;\n      pragma Import (C, Erasechar, \"erasechar\");\n   begin\n      return Character'Val (Erasechar);\n   end Erase_Character;\n\n   function Kill_Character return Character\n   is\n      function Killchar return C_Int;\n      pragma Import (C, Killchar, \"killchar\");\n   begin\n      return Character'Val (Killchar);\n   end Kill_Character;\n\n   function Has_Insert_Character return Boolean\n   is\n      function Has_Ic return Curses_Bool;\n      pragma Import (C, Has_Ic, \"has_ic\");\n   begin\n      if Has_Ic = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Has_Insert_Character;\n\n   function Has_Insert_Line return Boolean\n   is\n      function Has_Il return Curses_Bool;\n      pragma Import (C, Has_Il, \"has_il\");\n   begin\n      if Has_Il = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Has_Insert_Line;\n\n   function Supported_Attributes return Character_Attribute_Set\n   is\n      function Termattrs return Attributed_Character;\n      pragma Import (C, Termattrs, \"termattrs\");\n\n      Ch : constant Attributed_Character := Termattrs;\n   begin\n      return Ch.Attr;\n   end Supported_Attributes;\n\n   procedure Long_Name (Name : out String)\n   is\n      function Longname return chars_ptr;\n      pragma Import (C, Longname, \"longname\");\n   begin\n      Fill_String (Longname, Name);\n   end Long_Name;\n\n   function Long_Name return String\n   is\n      function Longname return chars_ptr;\n      pragma Import (C, Longname, \"longname\");\n   begin\n      return Fill_String (Longname);\n   end Long_Name;\n\n   procedure Terminal_Name (Name : out String)\n   is\n      function Termname return chars_ptr;\n      pragma Import (C, Termname, \"termname\");\n   begin\n      Fill_String (Termname, Name);\n   end Terminal_Name;\n\n   function Terminal_Name return String\n   is\n      function Termname return chars_ptr;\n      pragma Import (C, Termname, \"termname\");\n   begin\n      return Fill_String (Termname);\n   end Terminal_Name;\n------------------------------------------------------------------------------\n   procedure Init_Pair (Pair : Redefinable_Color_Pair;\n                        Fore : Color_Number;\n                        Back : Color_Number)\n   is\n      function Initpair (Pair : C_Short;\n                         Fore : C_Short;\n                         Back : C_Short) return C_Int;\n      pragma Import (C, Initpair, \"init_pair\");\n   begin\n      if Integer (Pair) >= Number_Of_Color_Pairs then\n         raise Constraint_Error;\n      end if;\n      if Integer (Fore) >= Number_Of_Colors or else\n         Integer (Back) >= Number_Of_Colors\n      then\n         raise Constraint_Error;\n      end if;\n      if Initpair (C_Short (Pair), C_Short (Fore), C_Short (Back))\n        = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Init_Pair;\n\n   procedure Pair_Content (Pair : Color_Pair;\n                           Fore : out Color_Number;\n                           Back : out Color_Number)\n   is\n      type C_Short_Access is access all C_Short;\n      function Paircontent (Pair : C_Short;\n                            Fp   : C_Short_Access;\n                            Bp   : C_Short_Access) return C_Int;\n      pragma Import (C, Paircontent, \"pair_content\");\n\n      F, B : aliased C_Short;\n   begin\n      if Paircontent (C_Short (Pair), F'Access, B'Access) = Curses_Err then\n         raise Curses_Exception;\n      else\n         Fore := Color_Number (F);\n         Back := Color_Number (B);\n      end if;\n   end Pair_Content;\n\n   function Has_Colors return Boolean\n   is\n      function Hascolors return Curses_Bool;\n      pragma Import (C, Hascolors, \"has_colors\");\n   begin\n      if Hascolors = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Has_Colors;\n\n   procedure Init_Color (Color : Color_Number;\n                         Red   : RGB_Value;\n                         Green : RGB_Value;\n                         Blue  : RGB_Value)\n   is\n      function Initcolor (Col   : C_Short;\n                          Red   : C_Short;\n                          Green : C_Short;\n                          Blue  : C_Short) return C_Int;\n      pragma Import (C, Initcolor, \"init_color\");\n   begin\n      if Initcolor (C_Short (Color), C_Short (Red), C_Short (Green),\n                    C_Short (Blue)) = Curses_Err\n      then\n            raise Curses_Exception;\n      end if;\n   end Init_Color;\n\n   function Can_Change_Color return Boolean\n   is\n      function Canchangecolor return Curses_Bool;\n      pragma Import (C, Canchangecolor, \"can_change_color\");\n   begin\n      if Canchangecolor = Curses_Bool_False then\n         return False;\n      else\n         return True;\n      end if;\n   end Can_Change_Color;\n\n   procedure Color_Content (Color :  Color_Number;\n                            Red   : out RGB_Value;\n                            Green : out RGB_Value;\n                            Blue  : out RGB_Value)\n   is\n      type C_Short_Access is access all C_Short;\n\n      function Colorcontent (Color : C_Short; R, G, B : C_Short_Access)\n                             return C_Int;\n      pragma Import (C, Colorcontent, \"color_content\");\n\n      R, G, B : aliased C_Short;\n   begin\n      if Colorcontent (C_Short (Color), R'Access, G'Access, B'Access) =\n        Curses_Err\n      then\n         raise Curses_Exception;\n      else\n         Red   := RGB_Value (R);\n         Green := RGB_Value (G);\n         Blue  := RGB_Value (B);\n      end if;\n   end Color_Content;\n\n------------------------------------------------------------------------------\n   procedure Save_Curses_Mode (Mode : Curses_Mode)\n   is\n      function Def_Prog_Mode return C_Int;\n      pragma Import (C, Def_Prog_Mode, \"def_prog_mode\");\n      function Def_Shell_Mode return C_Int;\n      pragma Import (C, Def_Shell_Mode, \"def_shell_mode\");\n\n      Err : C_Int;\n   begin\n      case Mode is\n         when Curses => Err := Def_Prog_Mode;\n         when Shell  => Err := Def_Shell_Mode;\n      end case;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Save_Curses_Mode;\n\n   procedure Reset_Curses_Mode (Mode : Curses_Mode)\n   is\n      function Reset_Prog_Mode return C_Int;\n      pragma Import (C, Reset_Prog_Mode, \"reset_prog_mode\");\n      function Reset_Shell_Mode return C_Int;\n      pragma Import (C, Reset_Shell_Mode, \"reset_shell_mode\");\n\n      Err : C_Int;\n   begin\n      case Mode is\n         when Curses => Err := Reset_Prog_Mode;\n         when Shell  => Err := Reset_Shell_Mode;\n      end case;\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Reset_Curses_Mode;\n\n   procedure Save_Terminal_State\n   is\n      function Savetty return C_Int;\n      pragma Import (C, Savetty, \"savetty\");\n   begin\n      if Savetty = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Save_Terminal_State;\n\n   procedure Reset_Terminal_State\n   is\n      function Resetty return C_Int;\n      pragma Import (C, Resetty, \"resetty\");\n   begin\n      if Resetty = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Reset_Terminal_State;\n\n   procedure Rip_Off_Lines (Lines : Integer;\n                            Proc  : Stdscr_Init_Proc)\n   is\n      function Ripoffline (Lines : C_Int;\n                           Proc  : Stdscr_Init_Proc) return C_Int;\n      pragma Import (C, Ripoffline, \"_nc_ripoffline\");\n   begin\n      if Ripoffline (C_Int (Lines), Proc) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Rip_Off_Lines;\n\n   procedure Set_Cursor_Visibility (Visibility : in out Cursor_Visibility)\n   is\n      function Curs_Set (Curs : C_Int) return C_Int;\n      pragma Import (C, Curs_Set, \"curs_set\");\n\n      Res : C_Int;\n   begin\n      Res := Curs_Set (Cursor_Visibility'Pos (Visibility));\n      if Res /= Curses_Err then\n         Visibility := Cursor_Visibility'Val (Res);\n      end if;\n   end Set_Cursor_Visibility;\n\n   procedure Nap_Milli_Seconds (Ms : Natural)\n   is\n      function Napms (Ms : C_Int) return C_Int;\n      pragma Import (C, Napms, \"napms\");\n   begin\n      if Napms (C_Int (Ms)) = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Nap_Milli_Seconds;\n------------------------------------------------------------------------------\n   function Lines return Line_Count\n   is\n      function LINES_As_Function return Interfaces.C.int;\n      pragma Import (C, LINES_As_Function, \"LINES_as_function\");\n   begin\n      return Line_Count (LINES_As_Function);\n   end Lines;\n\n   function Columns return Column_Count\n   is\n      function COLS_As_Function return Interfaces.C.int;\n      pragma Import (C, COLS_As_Function, \"COLS_as_function\");\n   begin\n      return Column_Count (COLS_As_Function);\n   end Columns;\n\n   function Tab_Size return Natural\n   is\n      function TABSIZE_As_Function return Interfaces.C.int;\n      pragma Import (C, TABSIZE_As_Function, \"TABSIZE_as_function\");\n\n   begin\n      return Natural (TABSIZE_As_Function);\n   end Tab_Size;\n\n   function Number_Of_Colors return Natural\n   is\n      function COLORS_As_Function return Interfaces.C.int;\n      pragma Import (C, COLORS_As_Function, \"COLORS_as_function\");\n   begin\n      return Natural (COLORS_As_Function);\n   end Number_Of_Colors;\n\n   function Number_Of_Color_Pairs return Natural\n   is\n      function COLOR_PAIRS_As_Function return Interfaces.C.int;\n      pragma Import (C, COLOR_PAIRS_As_Function, \"COLOR_PAIRS_as_function\");\n   begin\n      return Natural (COLOR_PAIRS_As_Function);\n   end Number_Of_Color_Pairs;\n------------------------------------------------------------------------------\n   procedure Transform_Coordinates\n     (W      : Window := Standard_Window;\n      Line   : in out Line_Position;\n      Column : in out Column_Position;\n      Dir    : Transform_Direction := From_Screen)\n   is\n      type Int_Access is access all C_Int;\n      function Transform (W    : Window;\n                          Y, X : Int_Access;\n                          Dir  : Curses_Bool) return C_Int;\n      pragma Import (C, Transform, \"wmouse_trafo\");\n\n      X : aliased C_Int := C_Int (Column);\n      Y : aliased C_Int := C_Int (Line);\n      D : Curses_Bool := Curses_Bool_False;\n      R : C_Int;\n   begin\n      if Dir = To_Screen then\n         D := 1;\n      end if;\n      R := Transform (W, Y'Access, X'Access, D);\n      if R = Curses_False then\n         raise Curses_Exception;\n      else\n         Line   := Line_Position (Y);\n         Column := Column_Position (X);\n      end if;\n   end Transform_Coordinates;\n------------------------------------------------------------------------------\n   procedure Use_Default_Colors is\n      function C_Use_Default_Colors return C_Int;\n      pragma Import (C, C_Use_Default_Colors, \"use_default_colors\");\n      Err : constant C_Int := C_Use_Default_Colors;\n   begin\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Use_Default_Colors;\n\n   procedure Assume_Default_Colors (Fore : Color_Number := Default_Color;\n                                    Back : Color_Number := Default_Color)\n   is\n      function C_Assume_Default_Colors (Fore : C_Int;\n                                        Back : C_Int) return C_Int;\n      pragma Import (C, C_Assume_Default_Colors, \"assume_default_colors\");\n\n      Err : constant C_Int := C_Assume_Default_Colors (C_Int (Fore),\n                                                       C_Int (Back));\n   begin\n      if Err = Curses_Err then\n         raise Curses_Exception;\n      end if;\n   end Assume_Default_Colors;\n------------------------------------------------------------------------------\n   function Curses_Version return String\n   is\n      function curses_versionC return chars_ptr;\n      pragma Import (C, curses_versionC, \"curses_version\");\n      Result : constant chars_ptr := curses_versionC;\n   begin\n      return Fill_String (Result);\n   end Curses_Version;\n------------------------------------------------------------------------------\n   procedure Curses_Free_All is\n      procedure curses_freeall;\n      pragma Import (C, curses_freeall, \"_nc_freeall\");\n   begin\n      --  Use this only for testing: you cannot use curses after calling it,\n      --  so it has to be the \"last\" thing done before exiting the program.\n      --  This will not really free ALL of memory used by curses.  That is\n      --  because it cannot free the memory used for stdout's setbuf.  The\n      --  _nc_free_and_exit() procedure can do that, but it can be invoked\n      --  safely only from C - and again, that only as the \"last\" thing done\n      --  before exiting the program.\n      curses_freeall;\n   end Curses_Free_All;\n------------------------------------------------------------------------------\n   function Use_Extended_Names (Enable : Boolean) return Boolean\n   is\n      function use_extended_namesC (e : Curses_Bool) return C_Int;\n      pragma Import (C, use_extended_namesC, \"use_extended_names\");\n\n      Res : constant C_Int :=\n         use_extended_namesC (Curses_Bool (Boolean'Pos (Enable)));\n   begin\n      if Res = C_Int (Curses_Bool_False) then\n         return False;\n      else\n         return True;\n      end if;\n   end Use_Extended_Names;\n------------------------------------------------------------------------------\n   procedure Screen_Dump_To_File (Filename : String)\n   is\n      function scr_dump (f : char_array) return C_Int;\n      pragma Import (C, scr_dump, \"scr_dump\");\n      Txt    : char_array (0 .. Filename'Length);\n      Length : size_t;\n   begin\n      To_C (Filename, Txt, Length);\n      if Curses_Err = scr_dump (Txt) then\n         raise Curses_Exception;\n      end if;\n   end Screen_Dump_To_File;\n\n   procedure Screen_Restore_From_File (Filename : String)\n   is\n      function scr_restore (f : char_array) return C_Int;\n      pragma Import (C, scr_restore, \"scr_restore\");\n      Txt    : char_array (0 .. Filename'Length);\n      Length : size_t;\n   begin\n      To_C (Filename, Txt, Length);\n      if Curses_Err = scr_restore (Txt)  then\n         raise Curses_Exception;\n      end if;\n   end Screen_Restore_From_File;\n\n   procedure Screen_Init_From_File (Filename : String)\n   is\n      function scr_init (f : char_array) return C_Int;\n      pragma Import (C, scr_init, \"scr_init\");\n      Txt    : char_array (0 .. Filename'Length);\n      Length : size_t;\n   begin\n      To_C (Filename, Txt, Length);\n      if Curses_Err = scr_init (Txt) then\n         raise Curses_Exception;\n      end if;\n   end Screen_Init_From_File;\n\n   procedure Screen_Set_File (Filename : String)\n   is\n      function scr_set (f : char_array) return C_Int;\n      pragma Import (C, scr_set, \"scr_set\");\n      Txt    : char_array (0 .. Filename'Length);\n      Length : size_t;\n   begin\n      To_C (Filename, Txt, Length);\n      if Curses_Err = scr_set (Txt) then\n         raise Curses_Exception;\n      end if;\n   end Screen_Set_File;\n------------------------------------------------------------------------------\n   procedure Resize (Win               : Window := Standard_Window;\n                     Number_Of_Lines   : Line_Count;\n                     Number_Of_Columns : Column_Count) is\n      function wresize (win     : Window;\n                        lines   : C_Int;\n                        columns : C_Int) return C_Int;\n      pragma Import (C, wresize);\n   begin\n      if wresize (Win,\n                  C_Int (Number_Of_Lines),\n                  C_Int (Number_Of_Columns)) = Curses_Err\n      then\n         raise Curses_Exception;\n      end if;\n   end Resize;\n------------------------------------------------------------------------------\n\nend Terminal_Interface.Curses;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}