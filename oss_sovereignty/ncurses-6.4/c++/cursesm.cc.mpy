{
  "module_name": "cursesm.cc",
  "hash_id": "eb5c93c5788715737c9846fc8fd951642b119cbe9b2d158c99a95ade178d76f6",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursesm.cc",
  "human_readable_source": "\n \n\n \n\n#include \"internal.h\"\n#include \"cursesm.h\"\n#include \"cursesapp.h\"\n\nMODULE_ID(\"$Id: cursesm.cc,v 1.27 2021/04/17 18:11:08 tom Exp $\")\n\nNCursesMenuItem::~NCursesMenuItem() THROWS(NCursesException)\n{\n  if (item)\n    OnError(::free_item(item));\n}\n\nbool\nNCursesMenuItem::action()\n{\n  return FALSE;\n}\n\nNCursesMenuCallbackItem::~NCursesMenuCallbackItem() THROWS(NCursesException)\n{\n}\n\nbool\nNCursesMenuCallbackItem::action()\n{\n  if (p_fct)\n    return p_fct (*this);\n  else\n    return FALSE;\n}\n\n \nvoid\n_nc_xx_mnu_init(MENU *m)\n{\n  NCursesMenu::getHook(m)->On_Menu_Init();\n}\n\nvoid\n_nc_xx_mnu_term(MENU *m)\n{\n  NCursesMenu::getHook(m)->On_Menu_Termination();\n}\n\nvoid\n_nc_xx_itm_init(MENU *m)\n{\n  NCursesMenu* M = NCursesMenu::getHook(m);\n  M->On_Item_Init (*(M->current_item ()));\n}\n\nvoid\n_nc_xx_itm_term(MENU *m)\n{\n  NCursesMenu* M = NCursesMenu::getHook(m);\n  M->On_Item_Termination (*(M->current_item ()));\n}\n\n \nITEM**\nNCursesMenu::mapItems(NCursesMenuItem* nitems[])\n{\n  int itemCount = 0,lcv;\n\n  for (lcv=0; nitems[lcv]->item; ++lcv)\n    ++itemCount;\n\n  ITEM** itemArray = new ITEM*[itemCount + 1];\n\n  for (lcv=0;nitems[lcv]->item;++lcv) {\n    itemArray[lcv] = nitems[lcv]->item;\n  }\n  itemArray[lcv] = NULL;\n\n  my_items = nitems;\n\n  if (menu)\n    delete[] ::menu_items(menu);\n  return itemArray;\n}\n\nvoid\nNCursesMenu::InitMenu(NCursesMenuItem* nitems[],\n\t\t      bool with_frame,\n\t\t      bool autoDelete_Items)\n{\n  int mrows, mcols;\n\n  keypad(TRUE);\n  meta(TRUE);\n\n  b_framed = with_frame;\n  b_autoDelete = autoDelete_Items;\n\n  menu = static_cast<MENU*>(0);\n  menu = ::new_menu(mapItems(nitems));\n  if (!menu)\n    OnError (E_SYSTEM_ERROR);\n\n  UserHook* hook = new UserHook;\n  hook->m_user   = NULL;\n  hook->m_back   = this;\n  hook->m_owner  = menu;\n  ::set_menu_userptr(menu, static_cast<void*>(hook));\n\n  ::set_menu_init (menu, _nc_xx_mnu_init);\n  ::set_menu_term (menu, _nc_xx_mnu_term);\n  ::set_item_init (menu, _nc_xx_itm_init);\n  ::set_item_term (menu, _nc_xx_itm_term);\n\n  scale(mrows, mcols);\n  ::set_menu_win(menu, w);\n\n  if (with_frame) {\n    if ((mrows > height()-2) || (mcols > width()-2))\n      OnError(E_NO_ROOM);\n    sub = new NCursesWindow(*this,mrows,mcols,1,1,'r');\n    ::set_menu_sub(menu, sub->w);\n    b_sub_owner = TRUE;\n  }\n  else {\n    sub = static_cast<NCursesWindow*>(0);\n    b_sub_owner = FALSE;\n  }\n  setDefaultAttributes();\n}\n\nvoid\nNCursesMenu::setDefaultAttributes()\n{\n  NCursesApplication* S = NCursesApplication::getApplication();\n  if (S) {\n    ::set_menu_fore(menu, S->foregrounds());\n    ::set_menu_back(menu, S->backgrounds());\n    ::set_menu_grey(menu, S->inactives());\n  }\n}\n\nNCursesMenu::~NCursesMenu() THROWS(NCursesException)\n{\n  UserHook* hook = reinterpret_cast<UserHook*>(::menu_userptr(menu));\n  delete hook;\n  if (b_sub_owner) {\n    ::set_menu_sub(menu, static_cast<WINDOW *>(0));\n    delete sub;\n  }\n  if (menu) {\n    ITEM** itms = ::menu_items(menu);\n    int cnt = count();\n\n    OnError(::set_menu_items(menu, static_cast<ITEM**>(0)));\n\n    if (b_autoDelete) {\n      if (cnt>0) {\n\tfor (int i=0; i <= cnt; i++)\n\t  delete my_items[i];\n      }\n      delete[] my_items;\n    }\n\n    ::free_menu(menu);\n    \n    delete[] itms;\n  }\n}\n\nvoid\nNCursesMenu::setSubWindow(NCursesWindow& nsub)\n{\n  if (!isDescendant(nsub))\n    OnError(E_SYSTEM_ERROR);\n  else {\n    if (b_sub_owner)\n      delete sub;\n    sub = &nsub;\n    ::set_menu_sub(menu,sub->w);\n  }\n}\n\nbool\nNCursesMenu::set_pattern (const char *pat)\n{\n  int res = ::set_menu_pattern (menu, pat);\n  switch(res) {\n  case E_OK:\n    break;\n  case E_NO_MATCH:\n    return FALSE;\n  default:\n    OnError (res);\n  }\n  return TRUE;\n}\n\n\nint\nNCursesMenu::driver (int c)\n{\n  int res = ::menu_driver (menu, c);\n  switch (res) {\n  case E_OK:\n  case E_REQUEST_DENIED:\n  case E_NOT_SELECTABLE:\n  case E_UNKNOWN_COMMAND:\n  case E_NO_MATCH:\n    break;\n  default:\n    OnError (res);\n  }\n  return (res);\n}\n\nstatic const int CMD_QUIT   = MAX_COMMAND + 1;\nstatic const int CMD_ACTION = MAX_COMMAND + 2;\n\n\n\n\n\n\n\nint\nNCursesMenu::virtualize(int c)\n{\n  switch(c) {\n  case CTRL('X')     : return(CMD_QUIT);              \n\n  case KEY_DOWN      : return(REQ_DOWN_ITEM);\n  case CTRL('N')     : return(REQ_NEXT_ITEM);         \n  case KEY_UP        : return(REQ_UP_ITEM);\n  case CTRL('P')     : return(REQ_PREV_ITEM);         \n\n  case CTRL('U')     : return(REQ_SCR_ULINE);         \n  case CTRL('D')     : return(REQ_SCR_DLINE);         \n  case CTRL('F')     : return(REQ_SCR_DPAGE);         \n  case CTRL('B')     : return(REQ_SCR_UPAGE);         \n\n  case CTRL('Y')     : return(REQ_CLEAR_PATTERN);\n  case CTRL('H')     : return(REQ_BACK_PATTERN);\n  case CTRL('A')     : return(REQ_NEXT_MATCH);\n  case CTRL('E')     : return(REQ_PREV_MATCH);\n  case CTRL('T')     : return(REQ_TOGGLE_ITEM);\n\n  case CTRL('J')     :\n  case CTRL('M')     : return(CMD_ACTION);\n\n  case KEY_HOME      : return(REQ_FIRST_ITEM);\n  case KEY_LEFT      : return(REQ_LEFT_ITEM);\n  case KEY_RIGHT     : return(REQ_RIGHT_ITEM);\n  case KEY_END       : return(REQ_LAST_ITEM);\n  case KEY_BACKSPACE : return(REQ_BACK_PATTERN);\n  case KEY_NPAGE     : return(REQ_SCR_DPAGE);\n  case KEY_PPAGE     : return(REQ_SCR_UPAGE);\n\n  default:\n    return(c);\n  }\n}\n\nNCursesMenuItem*\nNCursesMenu::operator()(void)\n{\n  int drvCmnd;\n  int c;\n  bool b_action = FALSE;\n\n  post();\n  show();\n  refresh();\n\n  while (!b_action && ((drvCmnd = virtualize((c = getKey()))) != CMD_QUIT)) {\n    int err;\n\n    switch((err = driver(drvCmnd))) {\n    case E_REQUEST_DENIED:\n      On_Request_Denied(c);\n      break;\n    case E_NOT_SELECTABLE:\n      On_Not_Selectable(c);\n      break;\n    case E_UNKNOWN_COMMAND:\n      if (drvCmnd == CMD_ACTION) {\n\tif (options() & O_ONEVALUE) {\n\t  NCursesMenuItem* itm = current_item();\n\t  assert(itm != 0);\n\t  if (itm->options() & O_SELECTABLE)\n\t    {\n\t      b_action = itm->action();\n\t      refresh();\n\t    }\n\t  else\n\t    On_Not_Selectable(c);\n\t}\n\telse {\n\t  int n = count();\n\t  for(int i=0; i<n; i++) {\n\t    NCursesMenuItem* itm = my_items[i];\n\t    if (itm->value()) {\n\t      b_action |= itm->action();\n\t      refresh();\n\t    }\n\t  }\n\t}\n      } else\n\tOn_Unknown_Command(c);\n      break;\n    case E_NO_MATCH:\n      On_No_Match(c);\n      break;\n    case E_OK:\n      break;\n    default:\n      OnError(err);\n    }\n  }\n\n  unpost();\n  hide();\n  refresh();\n  if (options() & O_ONEVALUE)\n    return my_items[::item_index (::current_item (menu))];\n  else\n    return NULL;\n}\n\nvoid\nNCursesMenu::On_Menu_Init()\n{\n}\n\nvoid\nNCursesMenu::On_Menu_Termination()\n{\n}\n\nvoid\nNCursesMenu::On_Item_Init(NCursesMenuItem& item)\n{\n  (void) item;\n}\n\nvoid\nNCursesMenu::On_Item_Termination(NCursesMenuItem& item)\n{\n  (void) item;\n}\n\nvoid\nNCursesMenu::On_Request_Denied(int c) const\n{\n  (void) c;\n  ::beep();\n}\n\nvoid\nNCursesMenu::On_Not_Selectable(int c) const\n{\n  (void) c;\n  ::beep();\n}\n\nvoid\nNCursesMenu::On_No_Match(int c) const\n{\n  (void) c;\n  ::beep();\n}\n\nvoid\nNCursesMenu::On_Unknown_Command(int c) const\n{\n  (void) c;\n  ::beep();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}