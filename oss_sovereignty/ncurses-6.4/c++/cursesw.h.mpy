{
  "module_name": "cursesw.h",
  "hash_id": "526ff112ac9f996b1c88cb40e593cbf159d11e7974a452553a0e9be035a129a8",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursesw.h",
  "human_readable_source": "\n\n \n\n#ifndef NCURSES_CURSESW_H_incl\n#define NCURSES_CURSESW_H_incl 1\n\n\n\nextern \"C\" {\n#  include   <curses.h>\n}\n\n#if defined(BUILDING_NCURSES_CXX)\n# define NCURSES_CXX_IMPEXP NCURSES_EXPORT_GENERAL_EXPORT\n#else\n# define NCURSES_CXX_IMPEXP NCURSES_EXPORT_GENERAL_IMPORT\n#endif\n\n#define NCURSES_CXX_WRAPPED_VAR(type,name) extern NCURSES_CXX_IMPEXP type NCURSES_PUBLIC_VAR(name)(void)\n\n#define NCURSES_CXX_EXPORT(type) NCURSES_CXX_IMPEXP type NCURSES_API\n#define NCURSES_CXX_EXPORT_VAR(type) NCURSES_CXX_IMPEXP type\n\n#include <etip.h>\n\n \n#undef lines\n\n \n#undef UNDEF\n#define UNDEF(name) CUR_ ##name\n\n#ifdef addch\ninline int UNDEF(addch)(chtype ch)  { return addch(ch); }\n#undef addch\n#define addch UNDEF(addch)\n#endif\n\n#ifdef addchstr\ninline int UNDEF(addchstr)(chtype *at) { return addchstr(at); }\n#undef addchstr\n#define addchstr UNDEF(addchstr)\n#endif\n\n#ifdef addnstr\ninline int UNDEF(addnstr)(const char *str, int n)\n{ return addnstr(str, n); }\n#undef addnstr\n#define addnstr UNDEF(addnstr)\n#endif\n\n#ifdef addstr\ninline int UNDEF(addstr)(const char * str)  { return addstr(str); }\n#undef addstr\n#define addstr UNDEF(addstr)\n#endif\n\n#ifdef attroff\ninline int UNDEF(attroff)(chtype at) { return attroff(at); }\n#undef attroff\n#define attroff UNDEF(attroff)\n#endif\n\n#ifdef attron\ninline int UNDEF(attron)(chtype at) { return attron(at); }\n#undef attron\n#define attron UNDEF(attron)\n#endif\n\n#ifdef attrset\ninline chtype UNDEF(attrset)(chtype at) { return attrset(at); }\n#undef attrset\n#define attrset UNDEF(attrset)\n#endif\n\n#ifdef bkgd\ninline int UNDEF(bkgd)(chtype ch) { return bkgd(ch); }\n#undef bkgd\n#define bkgd UNDEF(bkgd)\n#endif\n\n#ifdef bkgdset\ninline void UNDEF(bkgdset)(chtype ch) { bkgdset(ch); }\n#undef bkgdset\n#define bkgdset UNDEF(bkgdset)\n#endif\n\n#ifdef border\ninline int UNDEF(border)(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, chtype tr, chtype bl, chtype br)\n{ return border(ls, rs, ts, bs, tl, tr, bl, br); }\n#undef border\n#define border UNDEF(border)\n#endif\n\n#ifdef box\ninline int UNDEF(box)(WINDOW *win, int v, int h) { return box(win, v, h); }\n#undef box\n#define box UNDEF(box)\n#endif\n\n#ifdef chgat\ninline int UNDEF(chgat)(int n, attr_t attr, NCURSES_PAIRS_T color, const void *opts) {\n  return chgat(n, attr, color, opts); }\n#undef chgat\n#define chgat UNDEF(chgat)\n#endif\n\n#ifdef clear\ninline int UNDEF(clear)()  { return clear(); }\n#undef clear\n#define clear UNDEF(clear)\n#endif\n\n#ifdef clearok\ninline int UNDEF(clearok)(WINDOW* win, bool bf)  { return clearok(win, bf); }\n#undef clearok\n#define clearok UNDEF(clearok)\n#else\nextern \"C\" NCURSES_IMPEXP int NCURSES_API clearok(WINDOW*, bool);\n#endif\n\n#ifdef clrtobot\ninline int UNDEF(clrtobot)()  { return clrtobot(); }\n#undef clrtobot\n#define clrtobot UNDEF(clrtobot)\n#endif\n\n#ifdef clrtoeol\ninline int UNDEF(clrtoeol)()  { return clrtoeol(); }\n#undef clrtoeol\n#define clrtoeol UNDEF(clrtoeol)\n#endif\n\n#ifdef color_set\ninline chtype UNDEF(color_set)(NCURSES_PAIRS_T p, void* opts) { return color_set(p, opts); }\n#undef color_set\n#define color_set UNDEF(color_set)\n#endif\n\n#ifdef crmode\ninline int UNDEF(crmode)(void) { return crmode(); }\n#undef crmode\n#define crmode UNDEF(crmode)\n#endif\n\n#ifdef delch\ninline int UNDEF(delch)()  { return delch(); }\n#undef delch\n#define delch UNDEF(delch)\n#endif\n\n#ifdef deleteln\ninline int UNDEF(deleteln)()  { return deleteln(); }\n#undef deleteln\n#define deleteln UNDEF(deleteln)\n#endif\n\n#ifdef echochar\ninline int UNDEF(echochar)(chtype ch)  { return echochar(ch); }\n#undef echochar\n#define echochar UNDEF(echochar)\n#endif\n\n#ifdef erase\ninline int UNDEF(erase)()  { return erase(); }\n#undef erase\n#define erase UNDEF(erase)\n#endif\n\n#ifdef fixterm\ninline int UNDEF(fixterm)(void) { return fixterm(); }\n#undef fixterm\n#define fixterm UNDEF(fixterm)\n#endif\n\n#ifdef flushok\ninline int UNDEF(flushok)(WINDOW* _win, bool _bf)  {\n  return flushok(_win, _bf); }\n#undef flushok\n#define flushok UNDEF(flushok)\n#else\n#define _no_flushok\n#endif\n\n#ifdef getattrs\ninline int UNDEF(getattrs)(WINDOW *win) { return getattrs(win); }\n#undef getattrs\n#define getattrs UNDEF(getattrs)\n#endif\n\n#ifdef getbegyx\ninline void UNDEF(getbegyx)(WINDOW* win, int& y, int& x) { getbegyx(win, y, x); }\n#undef getbegyx\n#define getbegyx UNDEF(getbegyx)\n#endif\n\n#ifdef getbkgd\ninline chtype UNDEF(getbkgd)(const WINDOW *win) { return getbkgd(win); }\n#undef getbkgd\n#define getbkgd UNDEF(getbkgd)\n#endif\n\n#ifdef getch\ninline int UNDEF(getch)()  { return getch(); }\n#undef getch\n#define getch UNDEF(getch)\n#endif\n\n#ifdef getmaxyx\ninline void UNDEF(getmaxyx)(WINDOW* win, int& y, int& x) { getmaxyx(win, y, x); }\n#undef getmaxyx\n#define getmaxyx UNDEF(getmaxyx)\n#endif\n\n#ifdef getnstr\ninline int UNDEF(getnstr)(char *_str, int n)  { return getnstr(_str, n); }\n#undef getnstr\n#define getnstr UNDEF(getnstr)\n#endif\n\n#ifdef getparyx\ninline void UNDEF(getparyx)(WINDOW* win, int& y, int& x) { getparyx(win, y, x); }\n#undef getparyx\n#define getparyx UNDEF(getparyx)\n#endif\n\n#ifdef getstr\ninline int UNDEF(getstr)(char *_str)  { return getstr(_str); }\n#undef getstr\n#define getstr UNDEF(getstr)\n#endif\n\n#ifdef getyx\ninline void UNDEF(getyx)(const WINDOW* win, int& y, int& x) {\n  getyx(win, y, x); }\n#undef getyx\n#define getyx UNDEF(getyx)\n#endif\n\n#ifdef hline\ninline int UNDEF(hline)(chtype ch, int n) { return hline(ch, n); }\n#undef hline\n#define hline UNDEF(hline)\n#endif\n\n#ifdef inch\ninline chtype UNDEF(inch)()  { return inch(); }\n#undef inch\n#define inch UNDEF(inch)\n#endif\n\n#ifdef inchstr\ninline int UNDEF(inchstr)(chtype *str)  { return inchstr(str); }\n#undef inchstr\n#define inchstr UNDEF(inchstr)\n#endif\n\n#ifdef innstr\ninline int UNDEF(innstr)(char *_str, int n)  { return innstr(_str, n); }\n#undef innstr\n#define innstr UNDEF(innstr)\n#endif\n\n#ifdef insch\ninline int UNDEF(insch)(chtype c)  { return insch(c); }\n#undef insch\n#define insch UNDEF(insch)\n#endif\n\n#ifdef insdelln\ninline int UNDEF(insdelln)(int n)  { return insdelln(n); }\n#undef insdelln\n#define insdelln UNDEF(insdelln)\n#endif\n\n#ifdef insertln\ninline int UNDEF(insertln)()  { return insertln(); }\n#undef insertln\n#define insertln UNDEF(insertln)\n#endif\n\n#ifdef insnstr\ninline int UNDEF(insnstr)(const char *_str, int n)  {\n  return insnstr(_str, n); }\n#undef insnstr\n#define insnstr UNDEF(insnstr)\n#endif\n\n#ifdef insstr\ninline int UNDEF(insstr)(const char *_str)  {\n  return insstr(_str); }\n#undef insstr\n#define insstr UNDEF(insstr)\n#endif\n\n#ifdef instr\ninline int UNDEF(instr)(char *_str)  { return instr(_str); }\n#undef instr\n#define instr UNDEF(instr)\n#endif\n\n#ifdef intrflush\ninline void UNDEF(intrflush)(WINDOW *win, bool bf) { intrflush(); }\n#undef intrflush\n#define intrflush UNDEF(intrflush)\n#endif\n\n#ifdef is_linetouched\ninline int UNDEF(is_linetouched)(WINDOW *w, int l)  { return is_linetouched(w,l); }\n#undef is_linetouched\n#define is_linetouched UNDEF(is_linetouched)\n#endif\n\n#ifdef leaveok\ninline int UNDEF(leaveok)(WINDOW* win, bool bf)  { return leaveok(win, bf); }\n#undef leaveok\n#define leaveok UNDEF(leaveok)\n#else\nextern \"C\" NCURSES_IMPEXP int NCURSES_API leaveok(WINDOW* win, bool bf);\n#endif\n\n#ifdef move\ninline int UNDEF(move)(int x, int y)  { return move(x, y); }\n#undef move\n#define move UNDEF(move)\n#endif\n\n#ifdef mvaddch\ninline int UNDEF(mvaddch)(int y, int x, chtype ch)\n{ return mvaddch(y, x, ch); }\n#undef mvaddch\n#define mvaddch UNDEF(mvaddch)\n#endif\n\n#ifdef mvaddnstr\ninline int UNDEF(mvaddnstr)(int y, int x, const char *str, int n)\n{ return mvaddnstr(y, x, str, n); }\n#undef mvaddnstr\n#define mvaddnstr UNDEF(mvaddnstr)\n#endif\n\n#ifdef mvaddstr\ninline int UNDEF(mvaddstr)(int y, int x, const char * str)\n{ return mvaddstr(y, x, str); }\n#undef mvaddstr\n#define mvaddstr UNDEF(mvaddstr)\n#endif\n\n#ifdef mvchgat\ninline int UNDEF(mvchgat)(int y, int x, int n,\n\t\t\t  attr_t attr, NCURSES_PAIRS_T color, const void *opts) {\n  return mvchgat(y, x, n, attr, color, opts); }\n#undef mvchgat\n#define mvchgat UNDEF(mvchgat)\n#endif\n\n#ifdef mvdelch\ninline int UNDEF(mvdelch)(int y, int x) { return mvdelch(y, x);}\n#undef mvdelch\n#define mvdelch UNDEF(mvdelch)\n#endif\n\n#ifdef mvgetch\ninline int UNDEF(mvgetch)(int y, int x) { return mvgetch(y, x);}\n#undef mvgetch\n#define mvgetch UNDEF(mvgetch)\n#endif\n\n#ifdef mvgetnstr\ninline int UNDEF(mvgetnstr)(int y, int x, char *str, int n) {\n  return mvgetnstr(y, x, str, n);}\n#undef mvgetnstr\n#define mvgetnstr UNDEF(mvgetnstr)\n#endif\n\n#ifdef mvgetstr\ninline int UNDEF(mvgetstr)(int y, int x, char *str) {return mvgetstr(y, x, str);}\n#undef mvgetstr\n#define mvgetstr UNDEF(mvgetstr)\n#endif\n\n#ifdef mvinch\ninline chtype UNDEF(mvinch)(int y, int x) { return mvinch(y, x);}\n#undef mvinch\n#define mvinch UNDEF(mvinch)\n#endif\n\n#ifdef mvinnstr\ninline int UNDEF(mvinnstr)(int y, int x, char *_str, int n) {\n  return mvinnstr(y, x, _str, n); }\n#undef mvinnstr\n#define mvinnstr UNDEF(mvinnstr)\n#endif\n\n#ifdef mvinsch\ninline int UNDEF(mvinsch)(int y, int x, chtype c)\n{ return mvinsch(y, x, c); }\n#undef mvinsch\n#define mvinsch UNDEF(mvinsch)\n#endif\n\n#ifdef mvinsnstr\ninline int UNDEF(mvinsnstr)(int y, int x, const char *_str, int n) {\n  return mvinsnstr(y, x, _str, n); }\n#undef mvinsnstr\n#define mvinsnstr UNDEF(mvinsnstr)\n#endif\n\n#ifdef mvinsstr\ninline int UNDEF(mvinsstr)(int y, int x, const char *_str)  {\n  return mvinsstr(y, x, _str); }\n#undef mvinsstr\n#define mvinsstr UNDEF(mvinsstr)\n#endif\n\n#ifdef mvwaddch\ninline int UNDEF(mvwaddch)(WINDOW *win, int y, int x, const chtype ch)\n{ return mvwaddch(win, y, x, ch); }\n#undef mvwaddch\n#define mvwaddch UNDEF(mvwaddch)\n#endif\n\n#ifdef mvwaddchnstr\ninline int UNDEF(mvwaddchnstr)(WINDOW *win, int y, int x, const chtype *str, int n)\n{ return mvwaddchnstr(win, y, x, str, n); }\n#undef mvwaddchnstr\n#define mvwaddchnstr UNDEF(mvwaddchnstr)\n#endif\n\n#ifdef mvwaddchstr\ninline int UNDEF(mvwaddchstr)(WINDOW *win, int y, int x, const chtype *str)\n{ return mvwaddchstr(win, y, x, str); }\n#undef mvwaddchstr\n#define mvwaddchstr UNDEF(mvwaddchstr)\n#endif\n\n#ifdef mvwaddnstr\ninline int UNDEF(mvwaddnstr)(WINDOW *win, int y, int x, const char *str, int n)\n{ return mvwaddnstr(win, y, x, str, n); }\n#undef mvwaddnstr\n#define mvwaddnstr UNDEF(mvwaddnstr)\n#endif\n\n#ifdef mvwaddstr\ninline int UNDEF(mvwaddstr)(WINDOW *win, int y, int x, const char * str)\n{ return mvwaddstr(win, y, x, str); }\n#undef mvwaddstr\n#define mvwaddstr UNDEF(mvwaddstr)\n#endif\n\n#ifdef mvwchgat\ninline int UNDEF(mvwchgat)(WINDOW *win, int y, int x, int n,\n\t\t\t   attr_t attr, NCURSES_PAIRS_T color, const void *opts) {\n  return mvwchgat(win, y, x, n, attr, color, opts); }\n#undef mvwchgat\n#define mvwchgat UNDEF(mvwchgat)\n#endif\n\n#ifdef mvwdelch\ninline int UNDEF(mvwdelch)(WINDOW *win, int y, int x)\n{ return mvwdelch(win, y, x); }\n#undef mvwdelch\n#define mvwdelch UNDEF(mvwdelch)\n#endif\n\n#ifdef mvwgetch\ninline int UNDEF(mvwgetch)(WINDOW *win, int y, int x) { return mvwgetch(win, y, x);}\n#undef mvwgetch\n#define mvwgetch UNDEF(mvwgetch)\n#endif\n\n#ifdef mvwgetnstr\ninline int UNDEF(mvwgetnstr)(WINDOW *win, int y, int x, char *str, int n)\n{return mvwgetnstr(win, y, x, str, n);}\n#undef mvwgetnstr\n#define mvwgetnstr UNDEF(mvwgetnstr)\n#endif\n\n#ifdef mvwgetstr\ninline int UNDEF(mvwgetstr)(WINDOW *win, int y, int x, char *str)\n{return mvwgetstr(win, y, x, str);}\n#undef mvwgetstr\n#define mvwgetstr UNDEF(mvwgetstr)\n#endif\n\n#ifdef mvwhline\ninline int UNDEF(mvwhline)(WINDOW *win, int y, int x, chtype c, int n) {\n  return mvwhline(win, y, x, c, n); }\n#undef mvwhline\n#define mvwhline UNDEF(mvwhline)\n#endif\n\n#ifdef mvwinch\ninline chtype UNDEF(mvwinch)(WINDOW *win, int y, int x) {\n  return mvwinch(win, y, x);}\n#undef mvwinch\n#define mvwinch UNDEF(mvwinch)\n#endif\n\n#ifdef mvwinchnstr\ninline int UNDEF(mvwinchnstr)(WINDOW *win, int y, int x, chtype *str, int n)  { return mvwinchnstr(win, y, x, str, n); }\n#undef mvwinchnstr\n#define mvwinchnstr UNDEF(mvwinchnstr)\n#endif\n\n#ifdef mvwinchstr\ninline int UNDEF(mvwinchstr)(WINDOW *win, int y, int x, chtype *str)  { return mvwinchstr(win, y, x, str); }\n#undef mvwinchstr\n#define mvwinchstr UNDEF(mvwinchstr)\n#endif\n\n#ifdef mvwinnstr\ninline int UNDEF(mvwinnstr)(WINDOW *win, int y, int x, char *_str, int n) {\n  return mvwinnstr(win, y, x, _str, n); }\n#undef mvwinnstr\n#define mvwinnstr UNDEF(mvwinnstr)\n#endif\n\n#ifdef mvwinsch\ninline int UNDEF(mvwinsch)(WINDOW *win, int y, int x, chtype c)\n{ return mvwinsch(win, y, x, c); }\n#undef mvwinsch\n#define mvwinsch UNDEF(mvwinsch)\n#endif\n\n#ifdef mvwinsnstr\ninline int UNDEF(mvwinsnstr)(WINDOW *w, int y, int x, const char *_str, int n) {\n  return mvwinsnstr(w, y, x, _str, n); }\n#undef mvwinsnstr\n#define mvwinsnstr UNDEF(mvwinsnstr)\n#endif\n\n#ifdef mvwinsstr\ninline int UNDEF(mvwinsstr)(WINDOW *w, int y, int x,  const char *_str)  {\n  return mvwinsstr(w, y, x, _str); }\n#undef mvwinsstr\n#define mvwinsstr UNDEF(mvwinsstr)\n#endif\n\n#ifdef mvwvline\ninline int UNDEF(mvwvline)(WINDOW *win, int y, int x, chtype c, int n) {\n  return mvwvline(win, y, x, c, n); }\n#undef mvwvline\n#define mvwvline UNDEF(mvwvline)\n#endif\n\n#ifdef napms\ninline void UNDEF(napms)(unsigned long x) { napms(x); }\n#undef napms\n#define napms UNDEF(napms)\n#endif\n\n#ifdef nocrmode\ninline int UNDEF(nocrmode)(void) { return nocrmode(); }\n#undef nocrmode\n#define nocrmode UNDEF(nocrmode)\n#endif\n\n#ifdef nodelay\ninline void UNDEF(nodelay)() { nodelay(); }\n#undef nodelay\n#define nodelay UNDEF(nodelay)\n#endif\n\n#ifdef redrawwin\ninline int UNDEF(redrawwin)(WINDOW *win)  { return redrawwin(win); }\n#undef redrawwin\n#define redrawwin UNDEF(redrawwin)\n#endif\n\n#ifdef refresh\ninline int UNDEF(refresh)()  { return refresh(); }\n#undef refresh\n#define refresh UNDEF(refresh)\n#endif\n\n#ifdef resetterm\ninline int UNDEF(resetterm)(void) { return resetterm(); }\n#undef resetterm\n#define resetterm UNDEF(resetterm)\n#endif\n\n#ifdef saveterm\ninline int UNDEF(saveterm)(void) { return saveterm(); }\n#undef saveterm\n#define saveterm UNDEF(saveterm)\n#endif\n\n#ifdef scrl\ninline int UNDEF(scrl)(int l) { return scrl(l); }\n#undef scrl\n#define scrl UNDEF(scrl)\n#endif\n\n#ifdef scroll\ninline int UNDEF(scroll)(WINDOW *win) { return scroll(win); }\n#undef scroll\n#define scroll UNDEF(scroll)\n#endif\n\n#ifdef scrollok\ninline int UNDEF(scrollok)(WINDOW* win, bool bf)  { return scrollok(win, bf); }\n#undef scrollok\n#define scrollok UNDEF(scrollok)\n#else\n#if\tdefined(__NCURSES_H)\nextern \"C\" NCURSES_IMPEXP int NCURSES_API scrollok(WINDOW*, bool);\n#else\nextern \"C\" NCURSES_IMPEXP int NCURSES_API scrollok(WINDOW*, char);\n#endif\n#endif\n\n#ifdef setscrreg\ninline int UNDEF(setscrreg)(int t, int b) { return setscrreg(t, b); }\n#undef setscrreg\n#define setscrreg UNDEF(setscrreg)\n#endif\n\n#ifdef standend\ninline int UNDEF(standend)()  { return standend(); }\n#undef standend\n#define standend UNDEF(standend)\n#endif\n\n#ifdef standout\ninline int UNDEF(standout)()  { return standout(); }\n#undef standout\n#define standout UNDEF(standout)\n#endif\n\n#ifdef subpad\ninline WINDOW *UNDEF(subpad)(WINDOW *p, int l, int c, int y, int x)\n{ return derwin(p, l, c, y, x); }\n#undef subpad\n#define subpad UNDEF(subpad)\n#endif\n\n#ifdef timeout\ninline void UNDEF(timeout)(int delay) { timeout(delay); }\n#undef timeout\n#define timeout UNDEF(timeout)\n#endif\n\n#ifdef touchline\ninline int UNDEF(touchline)(WINDOW *win, int s, int c)\n{ return touchline(win, s, c); }\n#undef touchline\n#define touchline UNDEF(touchline)\n#endif\n\n#ifdef touchwin\ninline int UNDEF(touchwin)(WINDOW *win) { return touchwin(win); }\n#undef touchwin\n#define touchwin UNDEF(touchwin)\n#endif\n\n#ifdef untouchwin\ninline int UNDEF(untouchwin)(WINDOW *win) { return untouchwin(win); }\n#undef untouchwin\n#define untouchwin UNDEF(untouchwin)\n#endif\n\n#ifdef vline\ninline int UNDEF(vline)(chtype ch, int n) { return vline(ch, n); }\n#undef vline\n#define vline UNDEF(vline)\n#endif\n\n#ifdef waddchstr\ninline int UNDEF(waddchstr)(WINDOW *win, chtype *at) { return waddchstr(win, at); }\n#undef waddchstr\n#define waddchstr UNDEF(waddchstr)\n#endif\n\n#ifdef waddstr\ninline int UNDEF(waddstr)(WINDOW *win, char *str) { return waddstr(win, str); }\n#undef waddstr\n#define waddstr UNDEF(waddstr)\n#endif\n\n#ifdef wattroff\ninline int UNDEF(wattroff)(WINDOW *win, int att) { return wattroff(win, att); }\n#undef wattroff\n#define wattroff UNDEF(wattroff)\n#endif\n\n#ifdef wattrset\ninline int UNDEF(wattrset)(WINDOW *win, int att) { return wattrset(win, att); }\n#undef wattrset\n#define wattrset UNDEF(wattrset)\n#endif\n\n#ifdef winch\ninline chtype UNDEF(winch)(const WINDOW* win) { return winch(win); }\n#undef winch\n#define winch UNDEF(winch)\n#endif\n\n#ifdef winchnstr\ninline int UNDEF(winchnstr)(WINDOW *win, chtype *str, int n)  { return winchnstr(win, str, n); }\n#undef winchnstr\n#define winchnstr UNDEF(winchnstr)\n#endif\n\n#ifdef winchstr\ninline int UNDEF(winchstr)(WINDOW *win, chtype *str)  { return winchstr(win, str); }\n#undef winchstr\n#define winchstr UNDEF(winchstr)\n#endif\n\n#ifdef winsstr\ninline int UNDEF(winsstr)(WINDOW *w, const char *_str)  {\n  return winsstr(w, _str); }\n#undef winsstr\n#define winsstr UNDEF(winsstr)\n#endif\n\n#ifdef wstandend\ninline int UNDEF(wstandend)(WINDOW *win)  { return wstandend(win); }\n#undef wstandend\n#define wstandend UNDEF(wstandend)\n#endif\n\n#ifdef wstandout\ninline int UNDEF(wstandout)(WINDOW *win)  { return wstandout(win); }\n#undef wstandout\n#define wstandout UNDEF(wstandout)\n#endif\n\n \n\nextern \"C\" int     _nc_ripoffline(int, int (*init)(WINDOW*, int));\nextern \"C\" int     _nc_xx_ripoff_init(WINDOW *, int);\nextern \"C\" int     _nc_has_mouse(void);\n\nclass NCURSES_CXX_IMPEXP NCursesWindow\n{\n  friend class NCursesMenu;\n  friend class NCursesForm;\n\nprivate:\n  static bool    b_initialized;\n  static void    initialize();\n  void           constructing();\n  friend int     _nc_xx_ripoff_init(WINDOW *, int);\n\n  void           set_keyboard();\n\n  NCURSES_COLOR_T getcolor(int getback) const;\n  NCURSES_PAIRS_T getPair() const;\n\n  static int     setpalette(NCURSES_COLOR_T fore, NCURSES_COLOR_T back, NCURSES_PAIRS_T pair);\n  static int     colorInitialized;\n\n   \n   \n  NCursesWindow(WINDOW* win, int ncols);\n\nprotected:\n  virtual void   err_handler(const char *) const THROWS(NCursesException);\n   \n\n  static long count;         \n   \n   \n   \n\n  WINDOW*        w;                 \n\n  bool           alloced;           \n\n  NCursesWindow* par;               \n  NCursesWindow* subwins;           \n  NCursesWindow* sib;               \n\n  void           kill_subwindows();  \n   \n\n   \n  NCursesWindow();\n\npublic:\n  explicit NCursesWindow(WINDOW* window);    \n\n  NCursesWindow(int nlines,         \n\t\tint ncols,          \n\t\tint begin_y,        \n\t\tint begin_x);       \n\n  NCursesWindow(NCursesWindow& par, \n\t\tint nlines,         \n\t\tint ncols,          \n\t\tint begin_y,        \n\t\tint begin_x,        \n\t\tchar absrel = 'a'); \n  \n\n  NCursesWindow(NCursesWindow& par,\n\t\tbool do_box = TRUE);\n  \n  \n  \n\n  NCursesWindow& operator=(const NCursesWindow& rhs)\n  {\n    if (this != &rhs)\n      *this = rhs;\n    return *this;\n  }\n\n  NCursesWindow(const NCursesWindow& rhs)\n    : w(rhs.w), alloced(rhs.alloced), par(rhs.par), subwins(rhs.subwins), sib(rhs.sib)\n  {\n  }\n\n  virtual ~NCursesWindow() THROWS(NCursesException);\n\n  NCursesWindow Clone();\n  \n\n  \n  static void    useColors(void);\n  \n\n  static int ripoffline(int ripoff_lines,\n\t\t\tint (*init)(NCursesWindow& win));\n  \n  \n  \n  \n  \n  \n  \n  \n\n  \n  \n  \n  int            lines() const { initialize(); return LINES; }\n  \n\n  int            cols() const { initialize(); return COLS; }\n  \n\n  int            tabsize() const { initialize(); return TABSIZE; }\n  \n\n  static int     NumberOfColors();\n  \n\n  int            colors() const { return NumberOfColors(); }\n  \n\n  \n  \n  \n  int            height() const { return maxy() + 1; }\n  \n\n  int            width() const { return maxx() + 1; }\n  \n\n  int            begx() const { return getbegx(w); }\n  \n\n  int            begy() const { return getbegy(w); }\n  \n\n  int            curx() const { return getcurx(w); }\n  \n\n  int            cury() const { return getcury(w); }\n  \n\n  int            maxx() const { return getmaxx(w) == ERR ? ERR : getmaxx(w)-1; }\n  \n\n  int            maxy() const { return getmaxy(w) == ERR ? ERR : getmaxy(w)-1; }\n  \n\n  NCURSES_PAIRS_T getcolor() const;\n  \n\n  NCURSES_COLOR_T foreground() const { return getcolor(0); }\n  \n\n  NCURSES_COLOR_T background() const { return getcolor(1); }\n  \n\n  int            setpalette(NCURSES_COLOR_T fore, NCURSES_COLOR_T back);\n  \n\n  int            setcolor(NCURSES_PAIRS_T pair);\n  \n\n  \n  \n  \n  virtual int    mvwin(int begin_y, int begin_x) {\n    return ::mvwin(w, begin_y, begin_x); }\n  \n  \n\n  \n  \n  \n  int            move(int y, int x) { return ::wmove(w, y, x); }\n  \n\n  void           getyx(int& y, int& x) const { ::getyx(w, y, x); }\n  \n\n  void           getbegyx(int& y, int& x) const { ::getbegyx(w, y, x); }\n  \n\n  void           getmaxyx(int& y, int& x) const { ::getmaxyx(w, y, x); }\n  \n\n  void           getparyx(int& y, int& x) const { ::getparyx(w, y, x); }\n  \n\n  int            mvcur(int oldrow, int oldcol, int newrow, int newcol) const {\n    return ::mvcur(oldrow, oldcol, newrow, newcol); }\n  \n\n  \n  \n  \n  int            getch() { return ::wgetch(w); }\n  \n\n  int            getch(int y, int x) { return ::mvwgetch(w, y, x); }\n  \n\n  int            getstr(char* str, int n=-1) {\n    return ::wgetnstr(w, str, n); }\n  \n  \n  \n\n  int            getstr(int y, int x, char* str, int n=-1) {\n    return ::mvwgetnstr(w, y, x, str, n); }\n  \n  \n\n  int            instr(char *s, int n=-1) { return ::winnstr(w, s, n); }\n  \n  \n  \n\n  int            instr(int y, int x, char *s, int n=-1) {\n    return ::mvwinnstr(w, y, x, s, n); }\n  \n  \n\n  int            scanw(const char* fmt, ...)\n    \n#if __GNUG__ >= 2\n    __attribute__ ((format (scanf, 2, 3)));\n#else\n  ;\n#endif\n\n  int            scanw(const char*, va_list);\n    \n\n  int            scanw(int y, int x, const char* fmt, ...)\n    \n    \n#if __GNUG__ >= 2\n    __attribute__ ((format (scanf, 4, 5)));\n#else\n  ;\n#endif\n\n  int            scanw(int y, int x, const char* fmt, va_list);\n    \n    \n\n  \n  \n  \n  int            addch(const chtype ch) { return ::waddch(w, ch); }\n  \n\n  int            addch(int y, int x, const chtype ch) {\n    return ::mvwaddch(w, y, x, ch); }\n  \n  \n\n  int            echochar(const chtype ch) { return ::wechochar(w, ch); }\n  \n\n  int            addstr(const char* str, int n=-1) {\n    return ::waddnstr(w, str, n); }\n  \n  \n\n  int            addstr(int y, int x, const char * str, int n=-1) {\n    return ::mvwaddnstr(w, y, x, str, n); }\n  \n  \n\n  int            addchstr(const chtype* str, int n=-1) {\n    return ::waddchnstr(w, str, n); }\n  \n  \n\n  int            addchstr(int y, int x, const chtype * str, int n=-1) {\n    return ::mvwaddchnstr(w, y, x, str, n); }\n  \n  \n\n  int            printw(const char* fmt, ...)\n    \n#if (__GNUG__ >= 2) && !defined(printf)\n    __attribute__ ((format (printf, 2, 3)));\n#else\n  ;\n#endif\n\n  int            printw(int y, int x, const char * fmt, ...)\n    \n#if (__GNUG__ >= 2) && !defined(printf)\n    __attribute__ ((format (printf, 4, 5)));\n#else\n  ;\n#endif\n\n  int            printw(const char* fmt, va_list args);\n    \n\n  int            printw(int y, int x, const char * fmt, va_list args);\n    \n\n  chtype         inch() const { return ::winch(w); }\n  \n\n  chtype         inch(int y, int x) { return ::mvwinch(w, y, x); }\n  \n  \n\n  int            inchstr(chtype* str, int n=-1) {\n    return ::winchnstr(w, str, n); }\n  \n  \n\n  int            inchstr(int y, int x, chtype * str, int n=-1) {\n    return ::mvwinchnstr(w, y, x, str, n); }\n  \n  \n\n  int            insch(chtype ch) { return ::winsch(w, ch); }\n  \n  \n\n  int            insch(int y, int x, chtype ch) {\n    return ::mvwinsch(w, y, x, ch); }\n  \n  \n\n  int            insertln() { return ::winsdelln(w, 1); }\n  \n\n  int            insdelln(int n=1) { return ::winsdelln(w, n); }\n  \n  \n\n  int            insstr(const char *s, int n=-1) {\n    return ::winsnstr(w, s, n); }\n  \n  \n  \n\n  int            insstr(int y, int x, const char *s, int n=-1) {\n    return ::mvwinsnstr(w, y, x, s, n); }\n  \n  \n\n  int            attron (chtype at) { return ::wattron (w, at); }\n  \n\n  int            attroff(chtype at) { return ::wattroff(w, static_cast<int>(at)); }\n  \n\n  int            attrset(chtype at) { return ::wattrset(w, static_cast<int>(at)); }\n  \n\n  chtype         attrget() { return ::getattrs(w); }\n  \n\n  int            color_set(NCURSES_PAIRS_T color_pair_number, void* opts=NULL) {\n    return ::wcolor_set(w, color_pair_number, opts); }\n  \n\n  int            chgat(int n, attr_t attr, NCURSES_PAIRS_T color, const void *opts=NULL) {\n    return ::wchgat(w, n, attr, color, opts); }\n  \n  \n  \n\n  int            chgat(int y, int x,\n\t\t       int n, attr_t attr, NCURSES_PAIRS_T color, const void *opts=NULL) {\n    return ::mvwchgat(w, y, x, n, attr, color, opts); }\n  \n  \n\n  \n  \n  \n  chtype         getbkgd() const { return ::getbkgd(w); }\n  \n\n  int            bkgd(const chtype ch) { return ::wbkgd(w, ch); }\n  \n\n  void           bkgdset(chtype ch) { ::wbkgdset(w, ch); }\n  \n\n  \n  \n  \n  int            box(chtype vert=0, chtype  hor=0) {\n    return ::wborder(w, vert, vert, hor, hor, 0, 0, 0, 0); }\n  \n  \n  \n\n  int            border(chtype left=0, chtype right=0,\n\t\t\tchtype top =0, chtype bottom=0,\n\t\t\tchtype top_left =0, chtype top_right=0,\n\t\t\tchtype bottom_left =0, chtype bottom_right=0) {\n    return ::wborder(w, left, right, top, bottom, top_left, top_right,\n\t\t     bottom_left, bottom_right); }\n  \n  \n  \n\n  \n  \n  \n  int            hline(int len, chtype ch=0) { return ::whline(w, ch, len); }\n  \n  \n\n  int            hline(int y, int x, int len, chtype ch=0) {\n    return ::mvwhline(w, y, x, ch, len); }\n  \n\n  int            vline(int len, chtype ch=0) { return ::wvline(w, ch, len); }\n  \n  \n\n  int            vline(int y, int x, int len, chtype ch=0) {\n    return ::mvwvline(w, y, x, ch, len); }\n  \n\n  \n  \n  \n  int            erase() { return ::werase(w); }\n  \n\n  int            clear() { return ::wclear(w); }\n  \n\n  int            clearok(bool bf) { return ::clearok(w, bf); }\n  \n  \n\n  int            clrtobot() { return ::wclrtobot(w); }\n  \n\n  int            clrtoeol() { return ::wclrtoeol(w); }\n  \n\n  int            delch() { return ::wdelch(w); }\n  \n\n  int            delch(int y, int x) { return ::mvwdelch(w, y, x); }\n  \n  \n\n  int            deleteln() { return ::winsdelln(w, -1); }\n  \n\n  \n  \n  \n  int            scroll(int amount=1) { return ::wscrl(w, amount); }\n  \n  \n\n  int            scrollok(bool bf) { return ::scrollok(w, bf); }\n  \n  \n  \n\n  int            setscrreg(int from, int to) {\n    return ::wsetscrreg(w, from, to); }\n  \n\n  int            idlok(bool bf) { return ::idlok(w, bf); }\n  \n  \n\n  void           idcok(bool bf) { ::idcok(w, bf); }\n  \n  \n\n  int            touchline(int s, int c) { return ::touchline(w, s, c); }\n  \n\n  int            touchwin()   { return ::wtouchln(w, 0, height(), 1); }\n  \n\n  int            untouchwin() { return ::wtouchln(w, 0, height(), 0); }\n  \n\n  int            touchln(int s, int cnt, bool changed=TRUE) {\n    return ::wtouchln(w, s, cnt, static_cast<int>(changed ? 1 : 0)); }\n  \n  \n\n  bool           is_linetouched(int line) const {\n    return (::is_linetouched(w, line) == TRUE ? TRUE:FALSE); }\n  \n\n  bool           is_wintouched() const {\n    return (::is_wintouched(w) ? TRUE:FALSE); }\n  \n\n  int            leaveok(bool bf) { return ::leaveok(w, bf); }\n  \n  \n\n  int            redrawln(int from, int n) { return ::wredrawln(w, from, n); }\n  \n\n  int            redrawwin() { return ::wredrawln(w, 0, height()); }\n  \n\n  int            doupdate()  { return ::doupdate(); }\n  \n\n  void           syncdown()  { ::wsyncdown(w); }\n  \n\n  void           syncup()    { ::wsyncup(w); }\n  \n\n  void           cursyncup() { ::wcursyncup(w); }\n  \n\n  int            syncok(bool bf) { return ::syncok(w, bf); }\n  \n\n#ifndef _no_flushok\n  int            flushok(bool bf) { return ::flushok(w, bf); }\n#endif\n\n  void           immedok(bool bf) { ::immedok(w, bf); }\n  \n  \n\n  int            intrflush(bool bf) { return ::intrflush(w, bf); }\n\n  int            keypad(bool bf) { return ::keypad(w, bf); }\n  \n\n  int            nodelay(bool bf) { return ::nodelay(w, bf); }\n\n  int            meta(bool bf) { return ::meta(w, bf); }\n  \n  \n\n  int            standout() { return ::wstandout(w); }\n  \n\n  int            standend() { return ::wstandend(w); }\n  \n\n  \n  \n  \n  \n  virtual int    refresh() { return ::wrefresh(w); }\n  \n  \n\n  virtual int    noutrefresh() { return ::wnoutrefresh(w); }\n  \n  \n\n  \n  \n  \n  int            overlay(NCursesWindow& win) {\n    return ::overlay(w, win.w); }\n  \n\n  int            overwrite(NCursesWindow& win) {\n    return ::overwrite(w, win.w); }\n  \n\n  int            copywin(NCursesWindow& win,\n\t\t\t int sminrow, int smincol,\n\t\t\t int dminrow, int dmincol,\n\t\t\t int dmaxrow, int dmaxcol, bool overlaywin=TRUE) {\n    return ::copywin(w, win.w, sminrow, smincol, dminrow, dmincol,\n\t\t     dmaxrow, dmaxcol, static_cast<int>(overlaywin ? 1 : 0)); }\n  \n  \n  \n\n  \n  \n  \n#if defined(NCURSES_EXT_FUNCS) && (NCURSES_EXT_FUNCS != 0)\n  int            wresize(int newLines, int newColumns) {\n    return ::wresize(w, newLines, newColumns); }\n#endif\n\n  \n  \n  \n  bool has_mouse() const;\n  \n\n  \n  \n  \n  NCursesWindow*  child() { return subwins; }\n  \n\n  NCursesWindow*  sibling() { return sib; }\n  \n\n  NCursesWindow*  parent() { return par; }\n  \n\n  bool isDescendant(NCursesWindow& win);\n  \n};\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesColorWindow : public NCursesWindow\n{\npublic:\n  explicit NCursesColorWindow(WINDOW* &window)   \n    : NCursesWindow(window) {\n      useColors(); }\n\n  NCursesColorWindow(int nlines,        \n\t\t     int ncols,         \n\t\t     int begin_y,       \n\t\t     int begin_x)       \n    : NCursesWindow(nlines, ncols, begin_y, begin_x) {\n      useColors(); }\n\n  NCursesColorWindow(NCursesWindow& parentWin,\n\t\t     int nlines,        \n\t\t     int ncols,         \n\t\t     int begin_y,       \n\t\t     int begin_x,       \n\t\t     char absrel = 'a') \n    : NCursesWindow(parentWin,\n\t\t    nlines, ncols,\t\n\t\t    begin_y, begin_x,   \n\t\t    absrel ) {          \n      useColors(); }\n};\n\n\n\n\n  typedef enum {\n    REQ_PAD_REFRESH = KEY_MAX + 1,\n    REQ_PAD_UP,\n    REQ_PAD_DOWN,\n    REQ_PAD_LEFT,\n    REQ_PAD_RIGHT,\n    REQ_PAD_EXIT\n  } Pad_Request;\n\n  const Pad_Request PAD_LOW  = REQ_PAD_REFRESH;   \n  const Pad_Request PAD_HIGH = REQ_PAD_EXIT;      \n\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesPad : public NCursesWindow\n{\nprivate:\n  NCursesWindow* viewWin;       \n  NCursesWindow* viewSub;       \n\n  int h_gridsize, v_gridsize;\n\nprotected:\n  int min_row, min_col;         \n\n  NCursesWindow* Win(void) const {\n    \n    return (viewSub?viewSub:(viewWin?viewWin:0));\n  }\n\n  NCursesWindow* getWindow(void) const {\n    return viewWin;\n  }\n\n  NCursesWindow* getSubWindow(void) const {\n    return viewSub;\n  }\n\n  virtual int driver (int key);      \n  \n\n  virtual void OnUnknownOperation(int pad_req) {\n    (void) pad_req;\n    ::beep();\n  }\n  \n\n  virtual void OnNavigationError(int pad_req) {\n    (void) pad_req;\n    ::beep();\n  }\n  \n\n  virtual void OnOperation(int pad_req) {\n    (void) pad_req;\n  };\n  \n  \n\npublic:\n  NCursesPad(int nlines, int ncols);\n  \n\n  NCursesPad& operator=(const NCursesPad& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n      NCursesWindow::operator=(rhs);\n    }\n    return *this;\n  }\n\n  NCursesPad(const NCursesPad& rhs)\n    : NCursesWindow(rhs),\n      viewWin(rhs.viewWin),\n      viewSub(rhs.viewSub),\n      h_gridsize(rhs.h_gridsize),\n      v_gridsize(rhs.v_gridsize),\n      min_row(rhs.min_row),\n      min_col(rhs.min_col)\n  {\n  }\n\n  virtual ~NCursesPad() THROWS(NCursesException) {}\n\n  int echochar(const chtype ch) { return ::pechochar(w, ch); }\n  \n  \n\n  int refresh() NCURSES_OVERRIDE;\n  \n  \n\n  int refresh(int pminrow, int pmincol,\n\t      int sminrow, int smincol,\n\t      int smaxrow, int smaxcol) {\n    return ::prefresh(w, pminrow, pmincol,\n\t\t      sminrow, smincol, smaxrow, smaxcol);\n  }\n  \n  \n  \n\n  int noutrefresh() NCURSES_OVERRIDE;\n  \n  \n\n  int noutrefresh(int pminrow, int pmincol,\n\t\t  int sminrow, int smincol,\n\t\t  int smaxrow, int smaxcol) {\n    return ::pnoutrefresh(w, pminrow, pmincol,\n\t\t\t  sminrow, smincol, smaxrow, smaxcol);\n  }\n  \n\n  virtual void setWindow(NCursesWindow& view, int v_grid = 1, int h_grid = 1);\n  \n\n  virtual void setSubWindow(NCursesWindow& sub);\n  \n  \n  \n\n  virtual void operator() (void);\n  \n};\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesFramedPad : public NCursesPad\n{\nprotected:\n  virtual void OnOperation(int pad_req) NCURSES_OVERRIDE;\n\npublic:\n  NCursesFramedPad(NCursesWindow& win, int nlines, int ncols,\n\t\t   int v_grid = 1, int h_grid = 1)\n    : NCursesPad(nlines, ncols) {\n    NCursesPad::setWindow(win, v_grid, h_grid);\n    NCursesPad::setSubWindow(*(new NCursesWindow(win)));\n  }\n  \n\n  virtual ~NCursesFramedPad() THROWS(NCursesException) {\n    delete getSubWindow();\n  }\n\n  void setWindow(NCursesWindow& view, int v_grid = 1, int h_grid = 1) NCURSES_OVERRIDE {\n    (void) view;\n    (void) v_grid;\n    (void) h_grid;\n    err_handler(\"Operation not allowed\");\n  }\n  \n\n  void setSubWindow(NCursesWindow& sub) NCURSES_OVERRIDE {\n    (void) sub;\n    err_handler(\"Operation not allowed\");\n  }\n  \n\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}