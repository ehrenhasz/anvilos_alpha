{
  "module_name": "cursesf.h",
  "hash_id": "7903e4632873626b9f96b05aacbf7e29a54d7a754f105ad89cc3f3830792eda4",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursesf.h",
  "human_readable_source": "\n\n \n\n \n\n\n\n#ifndef NCURSES_CURSESF_H_incl\n#define NCURSES_CURSESF_H_incl 1\n\n#include <cursesp.h>\n\n#ifndef __EXT_QNX\n#include <string.h>\n#endif\n\nextern \"C\" {\n#  include <form.h>\n}\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesFormField; \n\n\n\nclass NCURSES_CXX_IMPEXP NCursesFieldType\n{\n  friend class NCursesFormField;\n\nprotected:\n  FIELDTYPE* fieldtype;\n\n  inline void OnError(int err) const THROW2(NCursesException const, NCursesFormException) {\n    if (err!=E_OK)\n      THROW(new NCursesFormException (err));\n  }\n\n  NCursesFieldType(FIELDTYPE *f) : fieldtype(f) {\n  }\n\n  virtual ~NCursesFieldType() {}\n\n  \n  virtual void set(NCursesFormField& f) = 0;\n\npublic:\n  NCursesFieldType()\n    : fieldtype(STATIC_CAST(FIELDTYPE*)(0))\n  {\n  }\n\n  NCursesFieldType& operator=(const NCursesFieldType& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n    }\n    return *this;\n  }\n\n  NCursesFieldType(const NCursesFieldType& rhs)\n    : fieldtype(rhs.fieldtype)\n  {\n  }\n\n};\n\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesFormField\n{\n  friend class NCursesForm;\n\nprotected:\n  FIELD *field;\t\t     \n  NCursesFieldType* ftype;   \n\n  \n  inline void OnError (int err) const THROW2(NCursesException const, NCursesFormException) {\n    if (err != E_OK)\n      THROW(new NCursesFormException (err));\n  }\n\npublic:\n  \n  NCursesFormField()\n    : field(STATIC_CAST(FIELD*)(0)),\n      ftype(STATIC_CAST(NCursesFieldType*)(0))\n  {\n  }\n\n  \n  NCursesFormField (int rows,\n\t\t    int ncols,\n\t\t    int first_row = 0,\n\t\t    int first_col = 0,\n\t\t    int offscreen_rows = 0,\n\t\t    int additional_buffers = 0)\n    : field(0),\n      ftype(STATIC_CAST(NCursesFieldType*)(0))\n  {\n      field = ::new_field(rows, ncols, first_row, first_col,\n\t\t\t  offscreen_rows, additional_buffers);\n      if (!field)\n\tOnError(errno);\n  }\n\n  NCursesFormField& operator=(const NCursesFormField& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n    }\n    return *this;\n  }\n\n  NCursesFormField(const NCursesFormField& rhs)\n    : field(rhs.field), ftype(rhs.ftype)\n  {\n  }\n\n  virtual ~NCursesFormField () THROWS(NCursesException);\n\n  \n  inline NCursesFormField* dup(int first_row, int first_col)\n  {\n    NCursesFormField* f = new NCursesFormField();\n    if (!f)\n      OnError(E_SYSTEM_ERROR);\n    else {\n      f->ftype = ftype;\n      f->field = ::dup_field(field,first_row,first_col);\n      if (!f->field)\n\tOnError(errno);\n    }\n    return f;\n  }\n\n  \n  inline NCursesFormField* link(int first_row, int first_col) {\n    NCursesFormField* f = new NCursesFormField();\n    if (!f)\n      OnError(E_SYSTEM_ERROR);\n    else {\n      f->ftype = ftype;\n      f->field = ::link_field(field,first_row,first_col);\n      if (!f->field)\n\tOnError(errno);\n    }\n    return f;\n  }\n\n  \n  inline FIELD* get_field() const {\n    return field;\n  }\n\n  \n  inline void info(int& rows, int& ncols,\n\t\t   int& first_row, int& first_col,\n\t\t   int& offscreen_rows, int& additional_buffers) const {\n    OnError(::field_info(field, &rows, &ncols,\n\t\t\t &first_row, &first_col,\n\t\t\t &offscreen_rows, &additional_buffers));\n  }\n\n  \n  inline void dynamic_info(int& dynamic_rows, int& dynamic_cols,\n\t\t\t   int& max_growth) const {\n    OnError(::dynamic_field_info(field, &dynamic_rows, &dynamic_cols,\n\t\t\t\t &max_growth));\n  }\n\n  \n  \n  inline void set_maximum_growth(int growth = 0) {\n    OnError(::set_max_field(field,growth));\n  }\n\n  \n  inline void move(int row, int col) {\n    OnError(::move_field(field,row,col));\n  }\n\n  \n  inline void new_page(bool pageFlag = FALSE) {\n    OnError(::set_new_page(field,pageFlag));\n  }\n\n  \n  inline bool is_new_page() const {\n    return ::new_page(field);\n  }\n\n  \n  inline void set_justification(int just) {\n    OnError(::set_field_just(field,just));\n  }\n\n  \n  inline int justification() const {\n    return ::field_just(field);\n  }\n  \n  inline void set_foreground(chtype foreground) {\n    OnError(::set_field_fore(field,foreground));\n  }\n\n  \n  inline chtype fore() const {\n    return ::field_fore(field);\n  }\n\n  \n  inline void set_background(chtype background) {\n    OnError(::set_field_back(field,background));\n  }\n\n  \n  inline chtype back() const {\n    return ::field_back(field);\n  }\n\n  \n  inline void set_pad_character(int padding) {\n    OnError(::set_field_pad(field, padding));\n  }\n\n  \n  inline int pad() const {\n    return ::field_pad(field);\n  }\n\n  \n  inline void options_on (Field_Options opts) {\n    OnError (::field_opts_on (field, opts));\n  }\n\n  \n  inline void options_off (Field_Options opts) {\n    OnError (::field_opts_off (field, opts));\n  }\n\n  \n  inline Field_Options options () const {\n    return ::field_opts (field);\n  }\n\n  \n  inline void set_options (Field_Options opts) {\n    OnError (::set_field_opts (field, opts));\n  }\n\n  \n  inline void set_changed(bool changeFlag = TRUE) {\n    OnError(::set_field_status(field,changeFlag));\n  }\n\n  \n  inline bool changed() const {\n    return ::field_status(field);\n  }\n\n  \n  \n  inline int (index)() const {\n    return ::field_index(field);\n  }\n\n  \n  inline void set_value(const char *val, int buffer = 0) {\n    OnError(::set_field_buffer(field,buffer,val));\n  }\n\n  \n  inline char* value(int buffer = 0) const {\n    return ::field_buffer(field,buffer);\n  }\n\n  \n  inline void set_fieldtype(NCursesFieldType& f) {\n    ftype = &f;\n    f.set(*this); \n  }\n\n  \n  inline NCursesFieldType* fieldtype() const {\n    return ftype;\n  }\n\n};\n\n  \n  \n  \nextern \"C\" {\n  void _nc_xx_frm_init(FORM *);\n  void _nc_xx_frm_term(FORM *);\n  void _nc_xx_fld_init(FORM *);\n  void _nc_xx_fld_term(FORM *);\n}\n\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesForm : public NCursesPanel\n{\nprotected:\n  FORM* form;  \n\nprivate:\n  NCursesWindow* sub;   \n  bool b_sub_owner;     \n  bool b_framed;\t\n  bool b_autoDelete;    \n\n  NCursesFormField** my_fields; \n\n  \n  \n  typedef struct {\n    void*\t       m_user;\t    \n    const NCursesForm* m_back;      \n    const FORM*\t       m_owner;\n  } UserHook;\n\n  \n  static inline NCursesForm* getHook(const FORM *f) {\n    UserHook* hook = reinterpret_cast<UserHook*>(::form_userptr(f));\n    assert(hook != 0 && hook->m_owner==f);\n    return const_cast<NCursesForm*>(hook->m_back);\n  }\n\n  friend void _nc_xx_frm_init(FORM *);\n  friend void _nc_xx_frm_term(FORM *);\n  friend void _nc_xx_fld_init(FORM *);\n  friend void _nc_xx_fld_term(FORM *);\n\n  \n  FIELD** mapFields(NCursesFormField* nfields[]);\n\nprotected:\n  \n  inline void set_user(void *user) {\n    UserHook* uptr = reinterpret_cast<UserHook*>(::form_userptr (form));\n    assert (uptr != 0 && uptr->m_back==this && uptr->m_owner==form);\n    uptr->m_user = user;\n  }\n\n  inline void *get_user() {\n    UserHook* uptr = reinterpret_cast<UserHook*>(::form_userptr (form));\n    assert (uptr != 0 && uptr->m_back==this && uptr->m_owner==form);\n    return uptr->m_user;\n  }\n\n  void InitForm (NCursesFormField* Fields[],\n\t\t bool with_frame,\n\t\t bool autoDeleteFields);\n\n  inline void OnError (int err) const THROW2(NCursesException const, NCursesFormException) {\n    if (err != E_OK)\n      THROW(new NCursesFormException (err));\n  }\n\n  \n  virtual int driver (int c) ;\n\n  \n  \n  NCursesForm( int  nlines,\n\t       int  ncols,\n\t       int  begin_y = 0,\n\t       int  begin_x = 0)\n    : NCursesPanel(nlines, ncols, begin_y, begin_x),\n      form (STATIC_CAST(FORM*)(0)),\n      sub(0),\n      b_sub_owner(0),\n      b_framed(0),\n      b_autoDelete(0),\n      my_fields(0)\n  {\n  }\n\npublic:\n  \n  NCursesForm (NCursesFormField* Fields[],\n\t       bool with_frame=FALSE,\t      \n\t       bool autoDelete_Fields=FALSE)  \n    : NCursesPanel(),\n      form(0),\n      sub(0),\n      b_sub_owner(0),\n      b_framed(0),\n      b_autoDelete(0),\n      my_fields(0)\n  {\n    InitForm(Fields, with_frame, autoDelete_Fields);\n  }\n\n  \n  NCursesForm (NCursesFormField* Fields[],\n\t       int  nlines,\n\t       int  ncols,\n\t       int  begin_y,\n\t       int  begin_x,\n\t       bool with_frame=FALSE,\t     \n\t       bool autoDelete_Fields=FALSE) \n    : NCursesPanel(nlines, ncols, begin_y, begin_x),\n      form(0),\n      sub(0),\n      b_sub_owner(0),\n      b_framed(0),\n      b_autoDelete(0),\n      my_fields(0)\n  {\n      InitForm(Fields, with_frame, autoDelete_Fields);\n  }\n\n  NCursesForm& operator=(const NCursesForm& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n      NCursesPanel::operator=(rhs);\n    }\n    return *this;\n  }\n\n  NCursesForm(const NCursesForm& rhs)\n    : NCursesPanel(rhs),\n      form(rhs.form),\n      sub(rhs.sub),\n      b_sub_owner(rhs.b_sub_owner),\n      b_framed(rhs.b_framed),\n      b_autoDelete(rhs.b_autoDelete),\n      my_fields(rhs.my_fields)\n  {\n  }\n\n  virtual ~NCursesForm() THROWS(NCursesException);\n\n  \n  virtual void setDefaultAttributes();\n\n  \n  inline NCursesFormField* current_field() const {\n    return my_fields[::field_index(::current_field(form))];\n  }\n\n  \n  void setSubWindow(NCursesWindow& sub);\n\n  \n  inline void setFields(NCursesFormField* Fields[]) {\n    OnError(::set_form_fields(form,mapFields(Fields)));\n  }\n\n  \n  inline void unpost (void) {\n    OnError (::unpost_form (form));\n  }\n\n  \n  inline void post(bool flag = TRUE) {\n    OnError (flag ? ::post_form(form) : ::unpost_form (form));\n  }\n\n  \n  inline void frame(const char *title=NULL, const char* btitle=NULL) NCURSES_OVERRIDE {\n    if (b_framed)\n      NCursesPanel::frame(title,btitle);\n    else\n      OnError(E_SYSTEM_ERROR);\n  }\n\n  inline void boldframe(const char *title=NULL, const char* btitle=NULL) NCURSES_OVERRIDE {\n    if (b_framed)\n      NCursesPanel::boldframe(title,btitle);\n    else\n      OnError(E_SYSTEM_ERROR);\n  }\n\n  inline void label(const char *topLabel, const char *bottomLabel) NCURSES_OVERRIDE {\n    if (b_framed)\n      NCursesPanel::label(topLabel,bottomLabel);\n    else\n      OnError(E_SYSTEM_ERROR);\n  }\n\n  \n  \n  \n\n  \n  \n  virtual void On_Form_Init();\n\n  \n  \n  virtual void On_Form_Termination();\n\n  \n  virtual void On_Field_Init(NCursesFormField& field);\n\n  \n  virtual void On_Field_Termination(NCursesFormField& field);\n\n  \n  void scale(int& rows, int& ncols) const {\n    OnError(::scale_form(form,&rows,&ncols));\n  }\n\n  \n  int count() const {\n    return ::field_count(form);\n  }\n\n  \n  void set_page(int pageNum) {\n    OnError(::set_form_page(form, pageNum));\n  }\n\n  \n  int page() const {\n    return ::form_page(form);\n  }\n\n  \n  inline void options_on (Form_Options opts) {\n    OnError (::form_opts_on (form, opts));\n  }\n\n  \n  inline void options_off (Form_Options opts) {\n    OnError (::form_opts_off (form, opts));\n  }\n\n  \n  inline Form_Options options () const {\n    return ::form_opts (form);\n  }\n\n  \n  inline void set_options (Form_Options opts) {\n    OnError (::set_form_opts (form, opts));\n  }\n\n  \n  inline bool data_ahead() const {\n    return ::data_ahead(form);\n  }\n\n  \n  inline bool data_behind() const {\n    return ::data_behind(form);\n  }\n\n  \n  inline void position_cursor () {\n    OnError (::pos_form_cursor (form));\n  }\n  \n  inline void set_current(NCursesFormField& F) {\n    OnError (::set_current_field(form, F.field));\n  }\n\n  \n  \n  \n  \n  virtual int virtualize(int c);\n\n  \n  inline NCursesFormField* operator[](int i) const {\n    if ( (i < 0) || (i >= ::field_count (form)) )\n      OnError (E_BAD_ARGUMENT);\n    return my_fields[i];\n  }\n\n  \n  \n  virtual NCursesFormField* operator()(void);\n\n  \n  virtual void On_Request_Denied(int c) const;\n  virtual void On_Invalid_Field(int c) const;\n  virtual void On_Unknown_Command(int c) const;\n\n};\n\n\n\n\n\n\n\n\ntemplate<class T> class NCURSES_CXX_IMPEXP NCursesUserField : public NCursesFormField\n{\npublic:\n  NCursesUserField (int rows,\n\t\t    int ncols,\n\t\t    int first_row = 0,\n\t\t    int first_col = 0,\n\t\t    const T* p_UserData = STATIC_CAST(T*)(0),\n\t\t    int offscreen_rows = 0,\n\t\t    int additional_buffers = 0)\n    : NCursesFormField (rows, ncols,\n\t\t\tfirst_row, first_col,\n\t\t\toffscreen_rows, additional_buffers) {\n      if (field)\n\tOnError(::set_field_userptr(field, STATIC_CAST(void *)(p_UserData)));\n  }\n\n  virtual ~NCursesUserField() THROWS(NCursesException) {};\n\n  inline const T* UserData (void) const {\n    return reinterpret_cast<const T*>(::field_userptr (field));\n  }\n\n  inline virtual void setUserData(const T* p_UserData) {\n    if (field)\n      OnError (::set_field_userptr (field, STATIC_CAST(void *)(p_UserData)));\n  }\n};\n\n\n\n\n\ntemplate<class T> class NCURSES_CXX_IMPEXP NCursesUserForm : public NCursesForm\n{\nprotected:\n  \n  \n  NCursesUserForm( int  nlines,\n\t\t   int  ncols,\n\t\t   int  begin_y = 0,\n\t\t   int  begin_x = 0,\n\t\t   const T* p_UserData = STATIC_CAST(T*)(0))\n    : NCursesForm(nlines,ncols,begin_y,begin_x) {\n      if (form)\n\tset_user (const_cast<void *>(reinterpret_cast<const void*>\n\t\t\t\t     (p_UserData)));\n  }\n\npublic:\n  NCursesUserForm (NCursesFormField* Fields[],\n\t\t   const T* p_UserData = STATIC_CAST(T*)(0),\n\t\t   bool with_frame=FALSE,\n\t\t   bool autoDelete_Fields=FALSE)\n    : NCursesForm (Fields, with_frame, autoDelete_Fields) {\n      if (form)\n\tset_user (const_cast<void *>(reinterpret_cast<const void*>(p_UserData)));\n  };\n\n  NCursesUserForm (NCursesFormField* Fields[],\n\t\t   int nlines,\n\t\t   int ncols,\n\t\t   int begin_y = 0,\n\t\t   int begin_x = 0,\n\t\t   const T* p_UserData = STATIC_CAST(T*)(0),\n\t\t   bool with_frame=FALSE,\n\t\t   bool autoDelete_Fields=FALSE)\n    : NCursesForm (Fields, nlines, ncols, begin_y, begin_x,\n\t\t   with_frame, autoDelete_Fields) {\n      if (form)\n\tset_user (const_cast<void *>(reinterpret_cast<const void*>\n\t\t\t\t     (p_UserData)));\n  };\n\n  virtual ~NCursesUserForm() THROWS(NCursesException) {\n  };\n\n  inline T* UserData (void) {\n    return reinterpret_cast<T*>(get_user ());\n  };\n\n  inline virtual void setUserData (const T* p_UserData) {\n    if (form)\n      set_user (const_cast<void *>(reinterpret_cast<const void*>(p_UserData)));\n  }\n\n};\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP Alpha_Field : public NCursesFieldType\n{\nprivate:\n  int min_field_width;\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,min_field_width));\n  }\n\npublic:\n  explicit Alpha_Field(int width)\n    : NCursesFieldType(TYPE_ALPHA),\n      min_field_width(width) {\n  }\n};\n\nclass NCURSES_CXX_IMPEXP Alphanumeric_Field : public NCursesFieldType\n{\nprivate:\n  int min_field_width;\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,min_field_width));\n  }\n\npublic:\n  explicit Alphanumeric_Field(int width)\n    : NCursesFieldType(TYPE_ALNUM),\n      min_field_width(width) {\n  }\n};\n\nclass NCURSES_CXX_IMPEXP Integer_Field : public NCursesFieldType\n{\nprivate:\n  int precision;\n  long lower_limit, upper_limit;\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,\n\t\t\t     precision,lower_limit,upper_limit));\n  }\n\npublic:\n  Integer_Field(int prec, long low=0L, long high=0L)\n    : NCursesFieldType(TYPE_INTEGER),\n      precision(prec), lower_limit(low), upper_limit(high) {\n  }\n};\n\nclass NCURSES_CXX_IMPEXP Numeric_Field : public NCursesFieldType\n{\nprivate:\n  int precision;\n  double lower_limit, upper_limit;\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,\n\t\t\t     precision,lower_limit,upper_limit));\n  }\n\npublic:\n  Numeric_Field(int prec, double low=0.0, double high=0.0)\n    : NCursesFieldType(TYPE_NUMERIC),\n      precision(prec), lower_limit(low), upper_limit(high) {\n  }\n};\n\nclass NCURSES_CXX_IMPEXP Regular_Expression_Field : public NCursesFieldType\n{\nprivate:\n  char* regex;\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,regex));\n  }\n\n  void copy_regex(const char *source)\n  {\n    regex = new char[1 + ::strlen(source)];\n    (::strcpy)(regex, source);\n  }\n\npublic:\n  explicit Regular_Expression_Field(const char *expr)\n    : NCursesFieldType(TYPE_REGEXP),\n      regex(NULL)\n  {\n    copy_regex(expr);\n  }\n\n  Regular_Expression_Field& operator=(const Regular_Expression_Field& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n      copy_regex(rhs.regex);\n      NCursesFieldType::operator=(rhs);\n    }\n    return *this;\n  }\n\n  Regular_Expression_Field(const Regular_Expression_Field& rhs)\n    : NCursesFieldType(rhs),\n      regex(NULL)\n  {\n    copy_regex(rhs.regex);\n  }\n\n  ~Regular_Expression_Field() {\n    delete[] regex;\n  }\n};\n\nclass NCURSES_CXX_IMPEXP Enumeration_Field : public NCursesFieldType\n{\nprivate:\n  const char** list;\n  int case_sensitive;\n  int non_unique_matches;\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,\n\t\t\t     list,case_sensitive,non_unique_matches));\n  }\npublic:\n  Enumeration_Field(const char* enums[],\n\t\t    bool case_sens=FALSE,\n\t\t    bool non_unique=FALSE)\n    : NCursesFieldType(TYPE_ENUM),\n      list(enums),\n      case_sensitive(case_sens ? -1 : 0),\n      non_unique_matches(non_unique ? -1 : 0) {\n  }\n\n  Enumeration_Field& operator=(const Enumeration_Field& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n      NCursesFieldType::operator=(rhs);\n    }\n    return *this;\n  }\n\n  Enumeration_Field(const Enumeration_Field& rhs)\n    : NCursesFieldType(rhs),\n      list(rhs.list),\n      case_sensitive(rhs.case_sensitive),\n      non_unique_matches(rhs.non_unique_matches)\n  {\n  }\n};\n\nclass NCURSES_CXX_IMPEXP IPV4_Address_Field : public NCursesFieldType\n{\nprivate:\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype));\n  }\n\npublic:\n  IPV4_Address_Field() : NCursesFieldType(TYPE_IPV4) {\n  }\n};\n\nextern \"C\" {\n  bool _nc_xx_fld_fcheck(FIELD *, const void*);\n  bool _nc_xx_fld_ccheck(int c, const void *);\n  void* _nc_xx_fld_makearg(va_list*);\n}\n\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP UserDefinedFieldType : public NCursesFieldType\n{\n  friend class UDF_Init; \nprivate:\n  \n  \n  static FIELDTYPE* generic_fieldtype;\n\nprotected:\n  \n  \n  friend bool _nc_xx_fld_fcheck(FIELD *, const void*);\n  friend bool _nc_xx_fld_ccheck(int c, const void *);\n  friend void* _nc_xx_fld_makearg(va_list*);\n\n  void set(NCursesFormField& f) NCURSES_OVERRIDE {\n    OnError(::set_field_type(f.get_field(),fieldtype,&f));\n  }\n\nprotected:\n  \n  \n  virtual bool field_check(NCursesFormField& f) = 0;\n\n  \n  \n  virtual bool char_check (int c) = 0;\n\npublic:\n  UserDefinedFieldType();\n};\n\nextern \"C\" {\n  bool _nc_xx_next_choice(FIELD*, const void *);\n  bool _nc_xx_prev_choice(FIELD*, const void *);\n}\n\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP UserDefinedFieldType_With_Choice : public UserDefinedFieldType\n{\n  friend class UDF_Init; \nprivate:\n  \n  \n  static FIELDTYPE* generic_fieldtype_with_choice;\n\n  \n  \n  friend bool _nc_xx_next_choice(FIELD*, const void *);\n  friend bool _nc_xx_prev_choice(FIELD*, const void *);\n\nprotected:\n  \n  \n  virtual bool next    (NCursesFormField& f) = 0;\n\n  \n  \n  virtual bool previous(NCursesFormField& f) = 0;\n\npublic:\n  UserDefinedFieldType_With_Choice();\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}