{
  "module_name": "cursesm.h",
  "hash_id": "8d7d1c16be88a9be8ac91b0360b623368428951e771362609d5964d3e8fad76c",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursesm.h",
  "human_readable_source": "\n \n\n \n\n\n\n#ifndef NCURSES_CURSESM_H_incl\n#define NCURSES_CURSESM_H_incl 1\n\n#include <cursesp.h>\n\nextern \"C\" {\n#  include <menu.h>\n}\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesMenuItem\n{\n  friend class NCursesMenu;\n\nprotected:\n  ITEM *item;\n\n  inline void OnError (int err) const THROW2(NCursesException const, NCursesMenuException) {\n    if (err != E_OK)\n      THROW(new NCursesMenuException (err));\n  }\n\npublic:\n  NCursesMenuItem (const char* p_name     = NULL,\n\t\t   const char* p_descript = NULL)\n    : item(0)\n  {\n    item = p_name ? ::new_item (p_name, p_descript) : STATIC_CAST(ITEM*)(0);\n    if (p_name && !item)\n      OnError (E_SYSTEM_ERROR);\n  }\n  \n  \n  \n\n  NCursesMenuItem& operator=(const NCursesMenuItem& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n    }\n    return *this;\n  }\n\n  NCursesMenuItem(const NCursesMenuItem& rhs)\n    : item(0)\n  {\n    (void) rhs;\n  }\n\n  virtual ~NCursesMenuItem () THROWS(NCursesException);\n  \n\n  inline const char* name () const {\n    return ::item_name (item);\n  }\n  \n\n  inline const char* description () const {\n    return ::item_description (item);\n  }\n  \n\n  inline int (index) (void) const {\n    return ::item_index (item);\n  }\n  \n\n  inline void options_on (Item_Options opts) {\n    OnError (::item_opts_on (item, opts));\n  }\n  \n\n  inline void options_off (Item_Options opts) {\n    OnError (::item_opts_off (item, opts));\n  }\n  \n\n  inline Item_Options options () const {\n    return ::item_opts (item);\n  }\n  \n\n  inline void set_options (Item_Options opts) {\n    OnError (::set_item_opts (item, opts));\n  }\n  \n\n  inline void set_value (bool f) {\n    OnError (::set_item_value (item,f));\n  }\n  \n\n  inline bool value () const {\n    return ::item_value (item);\n  }\n  \n\n  inline bool visible () const {\n    return ::item_visible (item);\n  }\n  \n\n  virtual bool action();\n  \n  \n  \n  \n  \n};\n\n\ntypedef bool ITEMCALLBACK(NCursesMenuItem&);\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesMenuCallbackItem : public NCursesMenuItem\n{\nprivate:\n  ITEMCALLBACK* p_fct;\n\npublic:\n  NCursesMenuCallbackItem(ITEMCALLBACK* fct       = NULL,\n\t\t\t  const char* p_name      = NULL,\n\t\t\t  const char* p_descript  = NULL )\n    : NCursesMenuItem (p_name, p_descript),\n      p_fct (fct) {\n  }\n\n  NCursesMenuCallbackItem& operator=(const NCursesMenuCallbackItem& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n    }\n    return *this;\n  }\n\n  NCursesMenuCallbackItem(const NCursesMenuCallbackItem& rhs)\n    : NCursesMenuItem(rhs),\n      p_fct(0)\n  {\n  }\n\n  virtual ~NCursesMenuCallbackItem() THROWS(NCursesException);\n\n  bool action() NCURSES_OVERRIDE;\n};\n\n  \n  \n  \nextern \"C\" {\n  void _nc_xx_mnu_init(MENU *);\n  void _nc_xx_mnu_term(MENU *);\n  void _nc_xx_itm_init(MENU *);\n  void _nc_xx_itm_term(MENU *);\n}\n\n\n\n\n\n\nclass NCURSES_CXX_IMPEXP NCursesMenu : public NCursesPanel\n{\nprotected:\n  MENU *menu;\n\nprivate:\n  NCursesWindow* sub;   \n  bool b_sub_owner;     \n  bool b_framed;        \n  bool b_autoDelete;    \n\n  NCursesMenuItem** my_items; \n\n  \n  \n  typedef struct {\n    void*              m_user;      \n    const NCursesMenu* m_back;      \n    const MENU*        m_owner;\n  } UserHook;\n\n  \n  static inline NCursesMenu* getHook(const MENU *m) {\n    UserHook* hook = STATIC_CAST(UserHook*)(::menu_userptr(m));\n    assert(hook != 0 && hook->m_owner==m);\n    return const_cast<NCursesMenu*>(hook->m_back);\n  }\n\n  friend void _nc_xx_mnu_init(MENU *);\n  friend void _nc_xx_mnu_term(MENU *);\n  friend void _nc_xx_itm_init(MENU *);\n  friend void _nc_xx_itm_term(MENU *);\n\n  \n  ITEM** mapItems(NCursesMenuItem* nitems[]);\n\nprotected:\n  \n  inline void set_user(void *user) {\n    UserHook* uptr = STATIC_CAST(UserHook*)(::menu_userptr (menu));\n    assert (uptr != 0 && uptr->m_back==this && uptr->m_owner==menu);\n    uptr->m_user = user;\n  }\n\n  inline void *get_user() {\n    UserHook* uptr = STATIC_CAST(UserHook*)(::menu_userptr (menu));\n    assert (uptr != 0 && uptr->m_back==this && uptr->m_owner==menu);\n    return uptr->m_user;\n  }\n\n  void InitMenu (NCursesMenuItem* menu[],\n\t\t bool with_frame,\n\t\t bool autoDeleteItems);\n\n  inline void OnError (int err) const THROW2(NCursesException const, NCursesMenuException) {\n    if (err != E_OK)\n      THROW(new NCursesMenuException (this, err));\n  }\n\n  \n  virtual int driver (int c) ;\n\n  \n  \n  NCursesMenu( int  nlines,\n\t       int  ncols,\n\t       int  begin_y = 0,\n\t       int  begin_x = 0)\n    : NCursesPanel(nlines,ncols,begin_y,begin_x),\n      menu (STATIC_CAST(MENU*)(0)),\n      sub(0),\n      b_sub_owner(0),\n      b_framed(0),\n      b_autoDelete(0),\n      my_items(0)\n  {\n  }\n\npublic:\n  \n  NCursesMenu (NCursesMenuItem* Items[],\n\t       bool with_frame=FALSE,        \n\t       bool autoDelete_Items=FALSE)  \n    : NCursesPanel(),\n      menu(0),\n      sub(0),\n      b_sub_owner(0),\n      b_framed(0),\n      b_autoDelete(0),\n      my_items(0)\n  {\n      InitMenu(Items, with_frame, autoDelete_Items);\n  }\n\n  \n  NCursesMenu (NCursesMenuItem* Items[],\n\t       int  nlines,\n\t       int  ncols,\n\t       int  begin_y = 0,\n\t       int  begin_x = 0,\n\t       bool with_frame=FALSE,        \n\t       bool autoDelete_Items=FALSE)  \n    : NCursesPanel(nlines, ncols, begin_y, begin_x),\n      menu(0),\n      sub(0),\n      b_sub_owner(0),\n      b_framed(0),\n      b_autoDelete(0),\n      my_items(0)\n  {\n      InitMenu(Items, with_frame, autoDelete_Items);\n  }\n\n  NCursesMenu& operator=(const NCursesMenu& rhs)\n  {\n    if (this != &rhs) {\n      *this = rhs;\n      NCursesPanel::operator=(rhs);\n    }\n    return *this;\n  }\n\n  NCursesMenu(const NCursesMenu& rhs)\n    : NCursesPanel(rhs),\n      menu(rhs.menu),\n      sub(rhs.sub),\n      b_sub_owner(rhs.b_sub_owner),\n      b_framed(rhs.b_framed),\n      b_autoDelete(rhs.b_autoDelete),\n      my_items(rhs.my_items)\n  {\n  }\n\n  virtual ~NCursesMenu () THROWS(NCursesException);\n\n  \n  inline NCursesWindow& subWindow() const {\n    assert(sub!=NULL);\n    return *sub;\n  }\n\n  \n  void setSubWindow(NCursesWindow& sub);\n\n  \n  inline void setItems(NCursesMenuItem* Items[]) {\n    OnError(::set_menu_items(menu,mapItems(Items)));\n  }\n\n  \n  inline void unpost (void) {\n    OnError (::unpost_menu (menu));\n  }\n\n  \n  inline void post(bool flag = TRUE) {\n    flag ? OnError (::post_menu(menu)) : OnError (::unpost_menu (menu));\n  }\n\n  \n  inline void scale (int& mrows, int& mcols) const  {\n    OnError (::scale_menu (menu, &mrows, &mcols));\n  }\n\n  \n  inline void set_format(int mrows, int mcols) {\n    OnError (::set_menu_format(menu, mrows, mcols));\n  }\n\n  \n  inline void menu_format(int& rows,int& ncols) {\n    ::menu_format(menu,&rows,&ncols);\n  }\n\n  \n  inline NCursesMenuItem* items() const {\n    return *my_items;\n  }\n\n  \n  inline int count() const {\n    return ::item_count(menu);\n  }\n\n  \n  inline NCursesMenuItem* current_item() const {\n    return my_items[::item_index(::current_item(menu))];\n  }\n\n  \n  inline const char* mark() const {\n    return ::menu_mark(menu);\n  }\n\n  \n  inline void set_mark(const char *marker) {\n    OnError (::set_menu_mark (menu, marker));\n  }\n\n  \n  inline static const char* request_name(int c) {\n    return ::menu_request_name(c);\n  }\n\n  \n  inline char* pattern() const {\n    return ::menu_pattern(menu);\n  }\n\n  \n  bool set_pattern (const char *pat);\n\n  \n  \n  virtual void setDefaultAttributes();\n\n  \n  inline chtype back() const {\n    return ::menu_back(menu);\n  }\n\n  \n  inline chtype fore() const {\n    return ::menu_fore(menu);\n  }\n\n  \n  inline chtype grey() const {\n    return ::menu_grey(menu);\n  }\n\n  \n  inline chtype set_background(chtype a) {\n    return ::set_menu_back(menu,a);\n  }\n\n  \n  inline chtype set_foreground(chtype a) {\n    return ::set_menu_fore(menu,a);\n  }\n\n  \n  inline chtype set_grey(chtype a) {\n    return ::set_menu_grey(menu,a);\n  }\n\n  inline void options_on (Menu_Options opts) {\n    OnError (::menu_opts_on (menu,opts));\n  }\n\n  inline void options_off(Menu_Options opts) {\n    OnError (::menu_opts_off(menu,opts));\n  }\n\n  inline Menu_Options options() const {\n    return ::menu_opts(menu);\n  }\n\n  inline void set_options (Menu_Options opts) {\n    OnError (::set_menu_opts (menu,opts));\n  }\n\n  inline int pad() const {\n    return ::menu_pad(menu);\n  }\n\n  inline void set_pad (int padch) {\n    OnError (::set_menu_pad (menu, padch));\n  }\n\n  \n  inline void position_cursor () const {\n    OnError (::pos_menu_cursor (menu));\n  }\n\n  \n  inline void set_current(NCursesMenuItem& I) {\n    OnError (::set_current_item(menu, I.item));\n  }\n\n  \n  inline int top_row (void) const {\n    return ::top_row (menu);\n  }\n\n  \n  inline void set_top_row (int row) {\n    OnError (::set_top_row (menu, row));\n  }\n\n  \n  \n  inline void setSpacing(int spc_description,\n\t\t\t int spc_rows,\n\t\t\t int spc_columns) {\n    OnError(::set_menu_spacing(menu,\n\t\t\t       spc_description,\n\t\t\t       spc_rows,\n\t\t\t       spc_columns));\n  }\n\n  \n  inline void Spacing(int& spc_description,\n\t\t      int& spc_rows,\n\t\t      int& spc_columns) const {\n    OnError(::menu_spacing(menu,\n\t\t\t   &spc_description,\n\t\t\t   &spc_rows,\n\t\t\t   &spc_columns));\n  }\n\n  \n  inline void frame(const char *title=NULL, const char* btitle=NULL) NCURSES_OVERRIDE {\n    if (b_framed)\n      NCursesPanel::frame(title,btitle);\n    else\n      OnError(E_SYSTEM_ERROR);\n  }\n\n  inline void boldframe(const char *title=NULL, const char* btitle=NULL) NCURSES_OVERRIDE {\n    if (b_framed)\n      NCursesPanel::boldframe(title,btitle);\n    else\n      OnError(E_SYSTEM_ERROR);\n  }\n\n  inline void label(const char *topLabel, const char *bottomLabel) NCURSES_OVERRIDE {\n    if (b_framed)\n      NCursesPanel::label(topLabel,bottomLabel);\n    else\n      OnError(E_SYSTEM_ERROR);\n  }\n\n  \n  \n  \n\n  \n  \n  virtual void On_Menu_Init();\n\n  \n  \n  virtual void On_Menu_Termination();\n\n  \n  virtual void On_Item_Init(NCursesMenuItem& item);\n\n  \n  virtual void On_Item_Termination(NCursesMenuItem& item);\n\n  \n  \n  \n  \n  virtual int virtualize(int c);\n\n\n  \n  inline NCursesMenuItem* operator[](int i) const {\n    if ( (i < 0) || (i >= ::item_count (menu)) )\n      OnError (E_BAD_ARGUMENT);\n    return (my_items[i]);\n  }\n\n  \n  \n  \n  virtual NCursesMenuItem* operator()(void);\n\n  \n  \n  \n  \n\n  \n  virtual void On_Request_Denied(int c) const;\n\n  \n  virtual void On_Not_Selectable(int c) const;\n\n  \n  virtual void On_No_Match(int c) const;\n\n  \n  virtual void On_Unknown_Command(int c) const;\n\n};\n\n\n\n\n\n\n\n\ntemplate<class T> class NCURSES_CXX_IMPEXP NCursesUserItem : public NCursesMenuItem\n{\npublic:\n  NCursesUserItem (const char* p_name,\n\t\t   const char* p_descript = NULL,\n\t\t   const T* p_UserData    = STATIC_CAST(T*)(0))\n    : NCursesMenuItem (p_name, p_descript) {\n      if (item)\n\tOnError (::set_item_userptr (item, const_cast<void *>(reinterpret_cast<const void*>(p_UserData))));\n  }\n\n  virtual ~NCursesUserItem() THROWS(NCursesException) {}\n\n  inline const T* UserData (void) const {\n    return reinterpret_cast<const T*>(::item_userptr (item));\n  };\n\n  inline virtual void setUserData(const T* p_UserData) {\n    if (item)\n      OnError (::set_item_userptr (item, const_cast<void *>(reinterpret_cast<const void *>(p_UserData))));\n  }\n};\n\n\n\n\n\ntemplate<class T> class NCURSES_CXX_IMPEXP NCursesUserMenu : public NCursesMenu\n{\nprotected:\n  NCursesUserMenu( int  nlines,\n\t\t   int  ncols,\n\t\t   int  begin_y = 0,\n\t\t   int  begin_x = 0,\n\t\t   const T* p_UserData = STATIC_CAST(T*)(0))\n    : NCursesMenu(nlines,ncols,begin_y,begin_x) {\n      if (menu)\n\tset_user (const_cast<void *>(reinterpret_cast<const void*>(p_UserData)));\n  }\n\npublic:\n  NCursesUserMenu (NCursesMenuItem* Items[],\n\t\t   const T* p_UserData = STATIC_CAST(T*)(0),\n\t\t   bool with_frame=FALSE,\n\t\t   bool autoDelete_Items=FALSE)\n    : NCursesMenu (Items, with_frame, autoDelete_Items) {\n      if (menu)\n\tset_user (const_cast<void *>(reinterpret_cast<const void*>(p_UserData)));\n  };\n\n  NCursesUserMenu (NCursesMenuItem* Items[],\n\t\t   int nlines,\n\t\t   int ncols,\n\t\t   int begin_y = 0,\n\t\t   int begin_x = 0,\n\t\t   const T* p_UserData = STATIC_CAST(T*)(0),\n\t\t   bool with_frame=FALSE)\n    : NCursesMenu (Items, nlines, ncols, begin_y, begin_x, with_frame) {\n      if (menu)\n\tset_user (const_cast<void *>(reinterpret_cast<const void*>(p_UserData)));\n  };\n\n  virtual ~NCursesUserMenu() THROWS(NCursesException) {\n  };\n\n  inline T* UserData (void) {\n    return reinterpret_cast<T*>(get_user ());\n  };\n\n  inline virtual void setUserData (const T* p_UserData) {\n    if (menu)\n      set_user (const_cast<void *>(reinterpret_cast<const void*>(p_UserData)));\n  }\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}