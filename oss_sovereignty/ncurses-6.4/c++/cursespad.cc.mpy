{
  "module_name": "cursespad.cc",
  "hash_id": "c8e93e8ed7a084d0b0d4e93825fab2fd8a338fd90675428209909d8663108dc4",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursespad.cc",
  "human_readable_source": "\n \n\n \n\n#include \"internal.h\"\n\n#include <cursesw.h>\n\nMODULE_ID(\"$Id: cursespad.cc,v 1.18 2020/02/02 23:34:34 tom Exp $\")\n\nNCursesPad::NCursesPad(int nlines, int ncols)\n  : NCursesWindow(),\n    viewWin(static_cast<NCursesWindow*>(0)),\n    viewSub(static_cast<NCursesWindow*>(0)),\n    h_gridsize(0), v_gridsize(0),\n    min_row(0), min_col(0)\n{\n  w = ::newpad(nlines, ncols);\n  if (static_cast<WINDOW*>(0) == w) {\n    count--;\n    err_handler(\"Cannot construct window\");\n  }\n  alloced = TRUE;\n}\n\n\nint NCursesPad::driver (int key)\n{\n  \n  switch(key) {\n  case KEY_UP:\n    \n    return REQ_PAD_UP;\n  case KEY_DOWN:\n    \n    return REQ_PAD_DOWN;\n  case KEY_LEFT:\n    \n    return REQ_PAD_LEFT;\n  case KEY_RIGHT:\n    \n    return REQ_PAD_RIGHT;\n  case KEY_EXIT:\n    \n  case CTRL('X'):\n    \n    return REQ_PAD_EXIT;\n\n  default: return(key);\n  }\n}\n\n\nvoid NCursesPad::operator()(void)\n{\n  NCursesWindow* W = Win();\n\n  if (static_cast<NCursesWindow*>(0) != W) {\n    int Width  = W->width();\n    int Height = W->height();\n\n    int req = REQ_PAD_REFRESH;\n\n    W->keypad(TRUE);\n    W->meta(TRUE);\n    refresh();\n\n    do {\n      bool changed = FALSE;\n\n      switch (req) {\n      case REQ_PAD_REFRESH:\n\t\n\tchanged = TRUE;\n\tbreak;\n      case REQ_PAD_LEFT:\n\t\n\tif (min_col > 0) {\n\t  changed = TRUE;\n\t  if (min_col < h_gridsize)\n\t    min_col = 0;\n\t  else\n\t    min_col -= h_gridsize;\n\t}\n\telse\n\t  OnNavigationError(req);\n\tbreak;\n      case REQ_PAD_RIGHT:\n\t\n\tif (min_col < (width() - Width - 1)) {\n\t  changed = TRUE;\n\t  if (min_col > (width() - Width - h_gridsize - 1))\n\t    min_col = width() - Width - 1;\n\t  else\n\t    min_col += h_gridsize;\n\t}\n\telse\n\t  OnNavigationError(req);\n\tbreak;\n      case REQ_PAD_UP:\n\t\n\tif (min_row > 0) {\n\t  changed = TRUE;\n\t  if (min_row < v_gridsize)\n\t    min_row = 0;\n\t  else\n\t    min_row -= v_gridsize;\n\t}\n\telse\n\t  OnNavigationError(req);\n\tbreak;\n      case REQ_PAD_DOWN:\n\t\n\tif (min_row < (height() - Height - 1)) {\n\t  changed = TRUE;\n\t  if (min_row > (height() - Height - v_gridsize - 1))\n\t    min_row = height() - Height - 1;\n\t  else\n\t    min_row += v_gridsize;\n\t}\n\telse\n\t  OnNavigationError(req);\n\tbreak;\n\n      default:\n\tOnUnknownOperation(req);\n      }\n\n      if (changed) {\n\tnoutrefresh();\n\tW->syncup();\n\tOnOperation(req);\n\tviewWin->refresh();\n      }\n    } while( (req=driver(W->getch())) != REQ_PAD_EXIT );\n  }\n}\n\n\nint NCursesPad::refresh()\n{\n  int res = noutrefresh();\n  if (res==OK && (static_cast<NCursesWindow*>(0) != viewWin)) {\n    res = (viewWin->refresh());\n  }\n  return(res);\n}\n\nint NCursesPad::noutrefresh()\n{\n  int res = OK;\n  NCursesWindow* W = Win();\n  if (static_cast<NCursesWindow*>(0) != W) {\n    int high = W->maxy();\n    int wide = W->maxx();\n    res = copywin(*W, min_row, min_col,\n\t\t  0, 0, high, wide,\n\t\t  FALSE);\n    if (res==OK) {\n      W->syncup();\n      res = viewWin->noutrefresh();\n    }\n  }\n  return (res);\n}\n\nvoid NCursesPad::setWindow(NCursesWindow& view,\n\t\t\t   int v_grid NCURSES_PARAM_INIT(1),\n\t\t\t   int h_grid NCURSES_PARAM_INIT(1))\n{\n  viewWin = &view;\n  min_row = min_col = 0;\n  if (h_grid <=0 || v_grid <= 0)\n    err_handler(\"Illegal Gridsize\");\n  else {\n    h_gridsize = h_grid;\n    v_gridsize = v_grid;\n  }\n}\n\nvoid NCursesPad::setSubWindow(NCursesWindow& sub)\n{\n  if (static_cast<NCursesWindow*>(0) == viewWin)\n    err_handler(\"Pad has no viewport\");\n  assert(viewWin != 0);\n  if (!viewWin->isDescendant(sub))\n    THROW(new NCursesException(\"NCursesFramePad\", E_SYSTEM_ERROR));\n  viewSub = &sub;\n}\n\nvoid NCursesFramedPad::OnOperation(int pad_req)\n{\n  (void) pad_req;\n  NCursesWindow* W = Win();\n  NCursesWindow* W2 = getWindow();\n\n  if ((static_cast<NCursesWindow*>(0) != W) && (static_cast<NCursesWindow*>(0) != W2)) {\n    int Width  = W->width();\n    int Height = W->height();\n    int i, row, col, h_len, v_len;\n\n    int my_width = width();\n\n    if (my_width != 0) {\n      h_len = (Width*Width + my_width - 1) / my_width;\n      if (h_len==0)\n\th_len = 1;\n      if (h_len > Width)\n\th_len = Width;\n    } else {\n      h_len = 1;\n    }\n\n    int my_height = height();\n\n    if (my_height != 0) {\n      v_len = (Height*Height + my_height - 1) / my_height;\n      if (v_len==0)\n\tv_len = 1;\n      if (v_len > Height)\n\tv_len = Height;\n    } else {\n      v_len = 1;\n    }\n\n    if (my_width != 0) {\n      col  = (min_col * Width + my_width - 1) / my_width;\n      if (col + h_len > Width)\n        col = Width - h_len;\n    } else {\n      col = 0;\n    }\n\n    if (my_height != 0) {\n      row  = (min_row * Height + my_height - 1) / my_height;\n      if (row + v_len > Height)\n        row = Height - v_len;\n    } else {\n      row = 0;\n    }\n\n    W2->vline(1,Width+1,Height);\n    W2->attron(A_REVERSE);\n    if (v_len>=2) {\n      W2->addch(row+1,Width+1,ACS_UARROW);\n      for(i=2;i<v_len;i++)\n\tW2->addch(row+i,Width+1,' ');\n      W2->addch(row+v_len,Width+1,ACS_DARROW);\n    }\n    else {\n      for(i=1;i<=v_len;i++)\n\tW2->addch(row+i,Width+1,' ');\n    }\n    W2->attroff(A_REVERSE);\n\n    W2->hline(Height+1,1,Width);\n    W2->attron(A_REVERSE);\n    if (h_len >= 2) {\n      W2->addch(Height+1,col+1,ACS_LARROW);\n      for(i=2;i<h_len;i++)\n\tW2->addch(Height+1,col+i,' ');\n      W2->addch(Height+1,col+h_len,ACS_RARROW);\n    }\n    else {\n      for(i=1;i<=h_len;i++)\n\tW2->addch(Height+1,col+i,' ');\n    }\n    W2->attroff(A_REVERSE);\n  }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}