{
  "module_name": "cursesw.cc",
  "hash_id": "18f1ef588accf654ca1e6d6437d209fed6e12797ae67e72991d9ea41f6df83fb",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursesw.cc",
  "human_readable_source": "\n \n\n \n\n#include \"internal.h\"\n#include \"cursesw.h\"\n\nMODULE_ID(\"$Id: cursesw.cc,v 1.56 2020/02/02 23:34:34 tom Exp $\")\n\n#define COLORS_NEED_INITIALIZATION  -1\n#define COLORS_NOT_INITIALIZED       0\n#define COLORS_MONOCHROME            1\n#define COLORS_ARE_REALLY_THERE      2\n\n#define HaveColors() (colorInitialized == COLORS_ARE_REALLY_THERE)\n\n\nlong NCursesWindow::count = 0L;\nbool NCursesWindow::b_initialized = FALSE;\n\nint\nNCursesWindow::scanw(const char* fmt, ...)\n{\n    int result = ERR;\n\n    va_list args;\n    va_start(args, fmt);\n    result = ::vw_scanw (w, const_cast<NCURSES_CONST char *>(fmt), args);\n    va_end(args);\n\n    return result;\n}\n\n\nint\nNCursesWindow::scanw(int y, int x, const char* fmt, ...)\n{\n    int result = ERR;\n\n    if (::wmove(w, y, x) != ERR) {\n\tva_list args;\n\tva_start(args, fmt);\n\tresult = ::vw_scanw (w, const_cast<NCURSES_CONST char *>(fmt), args);\n\tva_end(args);\n    }\n    return result;\n}\n\n\nint\nNCursesWindow::scanw(const char* fmt, va_list args)\n{\n    int result = ERR;\n\n    result = ::vw_scanw (w, const_cast<NCURSES_CONST char *>(fmt), args);\n\n    return result;\n}\n\n\nint\nNCursesWindow::scanw(int y, int x, const char* fmt, va_list args)\n{\n    int result = ERR;\n\n    if (::wmove(w, y, x) != ERR) {\n\tresult = ::vw_scanw (w, const_cast<NCURSES_CONST char *>(fmt), args);\n    }\n    return result;\n}\n\n\nint\nNCursesWindow::printw(const char * fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    int result = ::vw_printw(w, fmt, args);\n    va_end(args);\n    return result;\n}\n\n\nint\nNCursesWindow::printw(int y, int x, const char * fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    int result = ::wmove(w, y, x);\n    if (result == OK) {\n\tresult = ::vw_printw(w, fmt, args);\n    }\n    va_end(args);\n    return result;\n}\n\n\nint\nNCursesWindow::printw(const char * fmt, va_list args)\n{\n    int result = ::vw_printw(w, fmt, args);\n    return result;\n}\n\n\nint\nNCursesWindow::printw(int y, int x, const char * fmt, va_list args)\n{\n    int result = ::wmove(w, y, x);\n    if (result == OK) {\n\tresult = ::vw_printw(w, fmt, args);\n    }\n    return result;\n}\n\n\nvoid\nNCursesWindow::set_keyboard(void)\n{\n    keypad(TRUE);\n    meta(TRUE);\n}\n\nvoid\nNCursesWindow::err_handler(const char *msg) const THROWS(NCursesException)\n{\n  THROW(new NCursesException(msg));\n}\n\nvoid\nNCursesWindow::initialize()\n{\n    if (!b_initialized) {\n\t::initscr();\n\tb_initialized = TRUE;\n\tif (colorInitialized == COLORS_NEED_INITIALIZATION) {\n\t    colorInitialized = COLORS_NOT_INITIALIZED;\n\t    useColors();\n\t}\n\t::noecho();\n\t::cbreak();\n    }\n}\n\nvoid\nNCursesWindow::constructing()\n{\n    initialize();\n    ++count;\n}\n\nNCursesWindow::NCursesWindow()\n  : w(0), alloced(FALSE), par(0), subwins(0), sib(0)\n{\n    constructing();\n\n    w = static_cast<WINDOW *>(0);\n}\n\nNCursesWindow::NCursesWindow(int nlines, int ncols, int begin_y, int begin_x)\n  : w(0), alloced(TRUE), par(0), subwins(0), sib(0)\n{\n    constructing();\n\n    w = ::newwin(nlines, ncols, begin_y, begin_x);\n    if (w == 0) {\n\terr_handler(\"Cannot construct window\");\n    }\n    set_keyboard();\n}\n\nNCursesWindow::NCursesWindow(WINDOW* window)\n  : w(0), alloced(FALSE), par(0), subwins(0), sib(0)\n{\n    constructing();\n\n    \n    \n    \n    \n    \n    w = window ? window : ::stdscr;\n    set_keyboard();\n}\n\nNCursesWindow::NCursesWindow(NCursesWindow& win, int ny, int nx,\n\t\t\t     int begin_y, int begin_x, char absrel)\n  : w(0), alloced(TRUE), par(0), subwins(0), sib(0)\n{\n    constructing();\n    if (absrel == 'a') {\t\n\tbegin_y -= win.begy();\n\tbegin_x -= win.begx();\n    }\n\n    \n    \n    w = ::derwin(win.w, ny, nx, begin_y, begin_x);\n    if (w == 0) {\n\terr_handler(\"Cannot construct subwindow\");\n    }\n\n    par = &win;\n    sib = win.subwins;\n    win.subwins = this;\n}\n\nNCursesWindow::NCursesWindow(NCursesWindow& win,\n\t\t\t\tbool do_box NCURSES_PARAM_INIT(TRUE))\n  : w(0), alloced(TRUE), par(0), subwins(0), sib(0)\n{\n    constructing();\n    int myHeight = win.height();\n    int myWidth  = win.width();\n    w = :: derwin(win.w, myHeight - 2, myWidth - 2, 1, 1);\n    if (w == 0) {\n\terr_handler(\"Cannot construct subwindow\");\n    }\n\n    par = &win;\n    sib = win.subwins;\n    win.subwins = this;\n    subwins = 0;\n\n    if (do_box) {\n\twin.box();\n\twin.touchwin();\n    }\n}\n\nNCursesWindow NCursesWindow::Clone()\n{\n    WINDOW *d = ::dupwin(w);\n    NCursesWindow W(d);\n    W.subwins = subwins;\n    W.sib = sib;\n    W.par = par;\n    W.alloced = alloced;\n    return W;\n}\n\ntypedef int (*RIPOFFINIT)(NCursesWindow&);\nstatic RIPOFFINIT R_INIT[5];       \nstatic int r_init_idx   = 0;\nstatic RIPOFFINIT* prip = R_INIT;\n\nNCursesWindow::NCursesWindow(WINDOW *win, int ncols)\n  : w(0), alloced(FALSE), par(0), subwins(0), sib(0)\n{\n    (void) ncols;\n    initialize();\n    w = win;\n}\n\nint _nc_xx_ripoff_init(WINDOW *w, int ncols)\n{\n    (void) ncols;\n    int res = ERR;\n\n    RIPOFFINIT init = *prip++;\n    if (init) {\n\tres = init(*(new NCursesWindow(w,ncols)));\n    }\n    return res;\n}\n\nint NCursesWindow::ripoffline(int ripoff_lines,\n\t\t\t      int (*init)(NCursesWindow& win))\n{\n    int code = ::_nc_ripoffline(ripoff_lines,_nc_xx_ripoff_init);\n    if (code == OK && init && ripoff_lines) {\n\tR_INIT[r_init_idx++] = init;\n    }\n    return code;\n}\n\nbool\nNCursesWindow::isDescendant(NCursesWindow& win)\n{\n    bool result = FALSE;\n\n    for (NCursesWindow* p = subwins; p != NULL; p = p->sib) {\n\tif (p == &win || p->isDescendant(win)) {\n\t    result = TRUE;\n\t    break;\n\t}\n    }\n    return result;\n}\n\nvoid\nNCursesWindow::kill_subwindows()\n{\n    NCursesWindow* p = subwins;\n\n    subwins = 0;\n    while (p != 0) {\n\tNCursesWindow* q = p->sib;\n\tp->kill_subwindows();\n\tif (p->alloced) {\n\t    if (p->w != 0)\n\t\t::delwin(p->w);\n\t}\n\tdelete p;\n\tp = q;\n    }\n}\n\n\nNCursesWindow::~NCursesWindow() THROWS(NCursesException)\n{\n    kill_subwindows();\n\n    if (par != 0) {\n\t\n\tNCursesWindow * next = par->subwins;\n\tNCursesWindow * prev = 0;\n\twhile (next != 0) {\n\t    if (next == this) {\n\t\tif (prev != 0) {\n\t\t    prev->sib = next->sib;\n\t\t} else {\n\t\t    par->subwins = next->sib;\n\t\t}\n\t\tbreak;\n\t    }\n\t    prev = next;\n\t    next = next->sib;\n\t}\n    }\n\n    if (alloced && w != 0)\n\t::delwin(w);\n\n    if (alloced) {\n\t--count;\n\tif (count == 0) {\n\t    ::endwin();\n\t} else if (count < 0) { \n\t    err_handler(\"Too many windows destroyed\");\n\t}\n    }\n}\n\n\n\n\nint NCursesWindow::colorInitialized = COLORS_NOT_INITIALIZED;\n\nvoid\nNCursesWindow::useColors(void)\n{\n    if (colorInitialized == COLORS_NOT_INITIALIZED) {\n\tif (b_initialized) {\n\t    if (::has_colors()) {\n\t\t::start_color();\n\t\tcolorInitialized = COLORS_ARE_REALLY_THERE;\n\t    } else {\n\t\tcolorInitialized = COLORS_MONOCHROME;\n\t    }\n\t} else {\n\t    colorInitialized = COLORS_NEED_INITIALIZATION;\n\t}\n    }\n}\n\nNCURSES_PAIRS_T\nNCursesWindow::getPair() const\n{\n    return static_cast<NCURSES_PAIRS_T>(PAIR_NUMBER(getattrs(w)));\n}\n\nNCURSES_COLOR_T\nNCursesWindow::getcolor(int getback) const\n{\n    NCURSES_COLOR_T fore, back;\n\n    if (HaveColors()) {\n\tif (::pair_content(getPair(), &fore, &back) == ERR)\n\t    err_handler(\"Can't get color pair\");\n    } else {\n\t\n\tback = COLOR_BLACK;\n\tfore = COLOR_WHITE;\n    }\n    return getback ? back : fore;\n}\n\nint NCursesWindow::NumberOfColors()\n{\n    return (HaveColors()) ? COLORS : 1;\n}\n\nNCURSES_PAIRS_T\nNCursesWindow::getcolor() const\n{\n    return (HaveColors()) ? getPair() : 0;\n}\n\nint\nNCursesWindow::setpalette(NCURSES_COLOR_T fore, NCURSES_COLOR_T back, NCURSES_PAIRS_T pair)\n{\n    return (HaveColors()) ? ::init_pair(pair, fore, back) : OK;\n}\n\nint\nNCursesWindow::setpalette(NCURSES_COLOR_T fore, NCURSES_COLOR_T back)\n{\n    return setpalette(fore, back, getPair());\n}\n\n\nint\nNCursesWindow::setcolor(NCURSES_PAIRS_T pair)\n{\n    if (HaveColors()) {\n\tif ((pair < 1) || (pair > COLOR_PAIRS))\n\t    err_handler(\"Can't set color pair\");\n\n\tattroff(A_COLOR);\n\tattrset(COLOR_PAIR(pair));\n    }\n    return OK;\n}\n\n#if HAVE_HAS_KEY\nbool NCursesWindow::has_mouse() const\n{\n    return ((::has_key(KEY_MOUSE) || ::has_mouse())\n\t     ? TRUE : FALSE);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}