{
  "module_name": "cursesf.cc",
  "hash_id": "bf39a7662c50a64b8adff66a8e0e0c927c0b0cc915171758f70056699923136f",
  "original_prompt": "Ingested from ncurses-6.4/c++/cursesf.cc",
  "human_readable_source": "\n \n\n \n\n#include \"internal.h\"\n#include \"cursesf.h\"\n#include \"cursesapp.h\"\n\nMODULE_ID(\"$Id: cursesf.cc,v 1.26 2021/04/17 18:11:08 tom Exp $\")\n\nNCursesFormField::~NCursesFormField () THROWS(NCursesException)\n{\n  if (field)\n    OnError(::free_field (field));\n}\n\n \nFIELD**\nNCursesForm::mapFields(NCursesFormField* nfields[])\n{\n  int fieldCount = 0,lcv;\n  FIELD** old_fields;\n\n  assert(nfields != 0);\n\n  for (lcv=0; nfields[lcv]->field; ++lcv)\n    ++fieldCount;\n\n  FIELD** fields = new FIELD*[fieldCount + 1];\n\n  for (lcv=0;nfields[lcv]->field;++lcv) {\n    fields[lcv] = nfields[lcv]->field;\n  }\n  fields[lcv] = NULL;\n\n  my_fields = nfields;\n\n  if (form && (old_fields = ::form_fields(form))) {\n    ::set_form_fields(form, static_cast<FIELD**>(0));\n    delete[] old_fields;\n  }\n  return fields;\n}\n\nvoid NCursesForm::setDefaultAttributes()\n{\n  NCursesApplication* S = NCursesApplication::getApplication();\n\n  int n = count();\n  if (n > 0) {\n    for(int i=0; i<n; i++) {\n      NCursesFormField* f = (*this)[i];\n      if ((f->options() & (O_EDIT|O_ACTIVE))==(O_EDIT|O_ACTIVE)) {\n\tif (S) {\n\t  f->set_foreground(S->foregrounds());\n\t  f->set_background(S->backgrounds());\n\t}\n\tf->set_pad_character('_');\n      }\n      else {\n\tif (S)\n\t  f->set_background(S->labels());\n      }\n    }\n  }\n\n  if (S) {\n    bkgd(' '|S->dialog_backgrounds());\n    if (sub)\n      sub->bkgd(' '|S->dialog_backgrounds());\n  }\n}\n\nvoid\nNCursesForm::InitForm(NCursesFormField* nfields[],\n\t\t      bool with_frame,\n\t\t      bool autoDelete_Fields)\n{\n  int mrows, mcols;\n\n  keypad(TRUE);\n  meta(TRUE);\n\n  b_framed = with_frame;\n  b_autoDelete = autoDelete_Fields;\n\n  form = static_cast<FORM*>(0);\n  form = ::new_form(mapFields(nfields));\n  if (!form)\n    OnError (E_SYSTEM_ERROR);\n\n  UserHook* hook = new UserHook;\n  hook->m_user   = NULL;\n  hook->m_back   = this;\n  hook->m_owner  = form;\n  ::set_form_userptr(form, reinterpret_cast<void*>(hook));\n\n  ::set_form_init  (form, _nc_xx_frm_init);\n  ::set_form_term  (form, _nc_xx_frm_term);\n  ::set_field_init (form, _nc_xx_fld_init);\n  ::set_field_term (form, _nc_xx_fld_term);\n\n  scale(mrows, mcols);\n  ::set_form_win(form, w);\n\n  if (with_frame) {\n    if ((mrows > height()-2) || (mcols > width()-2))\n      OnError(E_NO_ROOM);\n    sub = new NCursesWindow(*this,mrows,mcols,1,1,'r');\n    ::set_form_sub(form, sub->w);\n    b_sub_owner = TRUE;\n  }\n  else {\n    sub = static_cast<NCursesWindow*>(0);\n    b_sub_owner = FALSE;\n  }\n  options_on(O_NL_OVERLOAD);\n  setDefaultAttributes();\n}\n\nNCursesForm::~NCursesForm() THROWS(NCursesException)\n{\n  UserHook* hook = reinterpret_cast<UserHook*>(::form_userptr(form));\n  delete hook;\n  if (b_sub_owner) {\n    delete sub;\n    ::set_form_sub(form, static_cast<WINDOW *>(0));\n  }\n  if (form) {\n    FIELD** fields = ::form_fields(form);\n    int cnt = count();\n\n    OnError(::set_form_fields(form, static_cast<FIELD**>(0)));\n\n    if (b_autoDelete) {\n      if (cnt>0) {\n\tfor (int i=0; i <= cnt; i++)\n\t  delete my_fields[i];\n      }\n      delete[] my_fields;\n    }\n\n    ::free_form(form);\n    \n    delete[] fields;\n  }\n}\n\nvoid\nNCursesForm::setSubWindow(NCursesWindow& nsub)\n{\n  if (!isDescendant(nsub))\n    OnError(E_SYSTEM_ERROR);\n  else {\n    if (b_sub_owner)\n      delete sub;\n    sub = &nsub;\n    ::set_form_sub(form,sub->w);\n  }\n}\n\n \nvoid\n_nc_xx_frm_init(FORM *f)\n{\n  NCursesForm::getHook(f)->On_Form_Init();\n}\n\nvoid\n_nc_xx_frm_term(FORM *f)\n{\n  NCursesForm::getHook(f)->On_Form_Termination();\n}\n\nvoid\n_nc_xx_fld_init(FORM *f)\n{\n  NCursesForm* F = NCursesForm::getHook(f);\n  F->On_Field_Init (*(F->current_field ()));\n}\n\nvoid\n_nc_xx_fld_term(FORM *f)\n{\n  NCursesForm* F = NCursesForm::getHook(f);\n  F->On_Field_Termination (*(F->current_field ()));\n}\n\nvoid\nNCursesForm::On_Form_Init()\n{\n}\n\nvoid\nNCursesForm::On_Form_Termination()\n{\n}\n\nvoid\nNCursesForm::On_Field_Init(NCursesFormField& field)\n{\n  (void) field;\n}\n\nvoid\nNCursesForm::On_Field_Termination(NCursesFormField& field)\n{\n  (void) field;\n}\n\n\nint\nNCursesForm::driver (int c)\n{\n  int res = ::form_driver (form, c);\n  switch (res) {\n  case E_OK:\n  case E_REQUEST_DENIED:\n  case E_INVALID_FIELD:\n  case E_UNKNOWN_COMMAND:\n    break;\n  default:\n    OnError (res);\n  }\n  return (res);\n}\n\nvoid NCursesForm::On_Request_Denied(int c) const\n{\n  (void) c;\n  ::beep();\n}\n\nvoid NCursesForm::On_Invalid_Field(int c) const\n{\n  (void) c;\n  ::beep();\n}\n\nvoid NCursesForm::On_Unknown_Command(int c) const\n{\n  (void) c;\n  ::beep();\n}\n\nstatic const int CMD_QUIT = MAX_COMMAND + 1;\n\nNCursesFormField*\nNCursesForm::operator()(void)\n{\n  int drvCmnd;\n  int c;\n\n  post();\n  show();\n  refresh();\n\n  while (((drvCmnd = virtualize((c = getKey()))) != CMD_QUIT)) {\n    int err;\n    switch((err = driver(drvCmnd))) {\n    case E_REQUEST_DENIED:\n      On_Request_Denied(c);\n      break;\n    case E_INVALID_FIELD:\n      On_Invalid_Field(c);\n      break;\n    case E_UNKNOWN_COMMAND:\n      On_Unknown_Command(c);\n      break;\n    case E_OK:\n      break;\n    default:\n      OnError(err);\n    }\n  }\n\n  unpost();\n  hide();\n  refresh();\n  return my_fields[::field_index (::current_field (form))];\n}\n\n\n\n\n\nint\nNCursesForm::virtualize(int c)\n{\n  switch(c) {\n\n  case KEY_HOME      : return(REQ_FIRST_FIELD);\n  case KEY_END       : return(REQ_LAST_FIELD);\n\n  case KEY_DOWN      : return(REQ_DOWN_CHAR);\n  case KEY_UP        : return(REQ_UP_CHAR);\n  case KEY_LEFT      : return(REQ_PREV_CHAR);\n  case KEY_RIGHT     : return(REQ_NEXT_CHAR);\n\n  case KEY_NPAGE     : return(REQ_NEXT_PAGE);\n  case KEY_PPAGE     : return(REQ_PREV_PAGE);\n\n  case KEY_BACKSPACE : return(REQ_DEL_PREV);\n  case KEY_ENTER     : return(REQ_NEW_LINE);\n  case KEY_CLEAR     : return(REQ_CLR_FIELD);\n\n  case CTRL('X')     : return(CMD_QUIT);        \n\n  case CTRL('F')     : return(REQ_NEXT_FIELD);  \n  case CTRL('B')     : return(REQ_PREV_FIELD);  \n  case CTRL('L')     : return(REQ_LEFT_FIELD);  \n  case CTRL('R')     : return(REQ_RIGHT_FIELD); \n  case CTRL('U')     : return(REQ_UP_FIELD);    \n  case CTRL('D')     : return(REQ_DOWN_FIELD);  \n\n  case CTRL('W')     : return(REQ_NEXT_WORD);\n  case CTRL('T')     : return(REQ_PREV_WORD);\n\n  case CTRL('A')     : return(REQ_BEG_FIELD);\n  case CTRL('E')     : return(REQ_END_FIELD);\n\n  case CTRL('I')     : return(REQ_INS_CHAR);\n  case CTRL('M')     :\n  case CTRL('J')     : return(REQ_NEW_LINE);\n  case CTRL('O')     : return(REQ_INS_LINE);\n  case CTRL('V')     : return(REQ_DEL_CHAR);\n  case CTRL('H')     : return(REQ_DEL_PREV);\n  case CTRL('Y')     : return(REQ_DEL_LINE);\n  case CTRL('G')     : return(REQ_DEL_WORD);\n  case CTRL('K')     : return(REQ_CLR_EOF);\n\n  case CTRL('N')     : return(REQ_NEXT_CHOICE);\n  case CTRL('P')     : return(REQ_PREV_CHOICE);\n\n  default:\n    return(c);\n  }\n}\n\n\n\n\n\nbool _nc_xx_fld_fcheck(FIELD *f, const void *u)\n{\n  (void) f;\n  NCursesFormField* F = reinterpret_cast<NCursesFormField*>(const_cast<void *>(u));\n  assert(F != 0);\n  UserDefinedFieldType* udf = reinterpret_cast<UserDefinedFieldType*>(F->fieldtype());\n  assert(udf != 0);\n  return udf->field_check(*F);\n}\n\nbool _nc_xx_fld_ccheck(int c, const void *u)\n{\n  NCursesFormField* F = reinterpret_cast<NCursesFormField*>(const_cast<void *>(u));\n  assert(F != 0);\n  UserDefinedFieldType* udf =\n    reinterpret_cast<UserDefinedFieldType*>(F->fieldtype());\n  assert(udf != 0);\n  return udf->char_check(c);\n}\n\nvoid* _nc_xx_fld_makearg(va_list* va)\n{\n  return va_arg(*va,NCursesFormField*);\n}\n\nFIELDTYPE* UserDefinedFieldType::generic_fieldtype =\n  ::new_fieldtype(_nc_xx_fld_fcheck,\n\t\t  _nc_xx_fld_ccheck);\n\n\nUserDefinedFieldType::UserDefinedFieldType() : NCursesFieldType(generic_fieldtype) {\n}\n\nFIELDTYPE* UserDefinedFieldType_With_Choice::generic_fieldtype_with_choice =\n  ::new_fieldtype(_nc_xx_fld_fcheck,\n\t\t  _nc_xx_fld_ccheck);\n\n\nUserDefinedFieldType_With_Choice::UserDefinedFieldType_With_Choice() {\n  fieldtype = generic_fieldtype_with_choice;\n}\n\nbool _nc_xx_next_choice(FIELD *f, const void *u)\n{\n  (void) f;\n  NCursesFormField* F = reinterpret_cast<NCursesFormField*>(const_cast<void *>(u));\n  assert(F != 0);\n  UserDefinedFieldType_With_Choice* udf =\n    reinterpret_cast<UserDefinedFieldType_With_Choice*>(F->fieldtype());\n  assert(udf != 0);\n  return udf->next(*F);\n}\n\nbool _nc_xx_prev_choice(FIELD *f, const void *u)\n{\n  (void) f;\n  NCursesFormField* F = reinterpret_cast<NCursesFormField*>(const_cast<void *>(u));\n  assert(F != 0);\n  UserDefinedFieldType_With_Choice* udf =\n    reinterpret_cast<UserDefinedFieldType_With_Choice*>(F->fieldtype());\n  assert(udf != 0);\n  return udf->previous(*F);\n}\n\nclass UDF_Init\n{\nprivate:\n  int code;\n  static UDF_Init* I;\n\npublic:\n  UDF_Init()\n    : code(0)\n  {\n    code = ::set_fieldtype_arg(UserDefinedFieldType::generic_fieldtype,\n\t\t\t       _nc_xx_fld_makearg,\n\t\t\t       NULL,\n\t\t\t       NULL);\n    if (code==E_OK)\n      code = ::set_fieldtype_arg\n\t(UserDefinedFieldType_With_Choice::generic_fieldtype_with_choice,\n\t _nc_xx_fld_makearg,\n\t NULL,\n\t NULL);\n    if (code==E_OK)\n      code = ::set_fieldtype_choice\n\t(UserDefinedFieldType_With_Choice::generic_fieldtype_with_choice,\n\t _nc_xx_next_choice,\n\t _nc_xx_prev_choice);\n  }\n};\n\nUDF_Init* UDF_Init::I = new UDF_Init();\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}