{
  "module_name": "ncu2openbsd",
  "hash_id": "d9c8203c9f07963ffa2986451c4caa91344db040fa17233fe35f7c0d6e6e0582",
  "original_prompt": "Ingested from ncurses-6.4/misc/ncu2openbsd",
  "human_readable_source": "#!/usr/bin/env perl\n# $Id: ncu2openbsd,v 1.65 2021/10/03 18:52:22 tom Exp $\n# -----------------------------------------------------------------------------\n# Copyright 2021 by Thomas E. Dickey\n#\n#                         All Rights Reserved\n#\n# Permission is hereby granted, free of charge, to any person obtaining a\n# copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be included\n# in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n# Except as contained in this notice, the name(s) of the above copyright\n# holders shall not be used in advertising or otherwise to promote the\n# sale, use or other dealings in this Software without prior written\n# authorization.\n# -----------------------------------------------------------------------------\n# https://invisible-island.net/ncurses/ncurses-openbsd.html\n#\n# Update the OpenBSD source-tree given an ncurses tarball or build-tree.\n\nuse strict;\nuse warnings;\n\nuse Getopt::Std;\nuse Cwd;\nuse Cwd 'abs_path';\nuse File::Path qw/ remove_tree /;\nuse File::Temp qw/ tempdir /;\n\n$| = 1;\n\nour ( $opt_d, $opt_n, $opt_r, $opt_t, $opt_v, $opt_x );\nour $source_dir;\nour $target_dir;\nour $update_dir;\nour $backup_dir;\n\nour $tempdir = tempdir( CLEANUP => 1 );\nmy $current = getcwd;\nmy $working = $current;\n\nour $generated_by = \"generated by: ncu2openbsd\";\n\nour %setup_dir = qw(\n  lib/libcurses         ncurses\n  lib/libform           form\n  lib/libmenu           menu\n  lib/libpanel          panel\n  usr.bin/infocmp       progs\n  usr.bin/tabs          progs\n  usr.bin/tic           progs\n  usr.bin/toe           progs\n  usr.bin/tput          progs\n  usr.bin/tset          progs\n  share/termtypes       misc\n);\n\nour %generated = qw(\n  codes.c 1\n  comp_captab.c         1\n  comp_userdefs.c       1\n  expanded.c            1\n  fallback.c            1\n  init_keytry.h         1\n  keys.list             1\n  lib_gen.c             1\n  lib_keyname.c         1\n  make_hash             1\n  make_keys             1\n  names.c               1\n  termsort.c            1\n  unctrl.c              1\n);\n\nour %definitions = qw(\n  CAPTOINFO             captoinfo\n  DATADIR               /usr/share\n  INFOCMP               infocmp\n  INFOTOCAP             infotocap\n  NCURSES_MAJOR         5\n  NCURSES_MINOR         7\n  NCURSES_OSPEED        int\n  NCURSES_PATCH         20081102\n  TERMINFO              /usr/share/terminfo\n  TIC                   tic\n  TOE                   toe\n  TPUT                  tput\n  TSET                  tset\n);\n\nsub patchdate() {\n    return $definitions{\"NCURSES_PATCH\"};\n}\n\nsub failed($) {\n    chdir $current;\n    printf STDERR \"? %s\\n\", $_[0];\n    exit;\n}\n\nsub verbose($) {\n    my $text = shift;\n    printf \"%s\\n\", $text if ($opt_v);\n}\n\nsub read_file($) {\n    my $name = shift;\n    open( my $fp, $name ) || &failed(\"cannot open $name\");\n    my (@input) = <$fp>;\n    chomp @input;\n    close($fp);\n    return @input;\n}\n\nsub read_dir($) {\n    my $path = shift;\n    my @result;\n    if ( opendir( my $dh, $path ) ) {\n        my @data = sort readdir($dh);\n        closedir $dh;\n        for my $d ( 0 .. $#data ) {\n            next if ( $data[$d] =~ /^\\.(\\.)?$/ );\n            next if ( -l $path . \"/\" . $data[$d] );\n            $result[ $#result + 1 ] = $data[$d];\n        }\n    }\n    return @result;\n}\n\nsub rename_dir($$) {\n    my $src = shift;\n    my $dst = shift;\n    printf \"%% mv %s -> %s\\n\", $src, $dst if ($opt_v);\n    rename $src, $dst unless ($opt_n);\n}\n\nsub check_sourcedir($) {\n    my $path = shift;\n    &failed(\"not a directory: $path\") unless ( -d $path );\n    my $full = abs_path($path);\n    chdir $full;\n    &failed(\"not an ncurses source-tree: $path\")\n      unless ( -f \"NEWS\" and -f \"dist.mk\" );\n    $source_dir = $full;\n}\n\nsub unpack($) {\n    my $path    = shift;\n    my $full    = abs_path($path);\n    my $command = \"\";\n    if ( $path =~ /\\.tgz$/ or $path =~ /\\.tar\\.gz$/ ) {\n        $command = \"tar xzf %s\";\n    }\n    elsif ( $path =~ /\\.zip$/ ) {\n        $command = \"unzip -q %s\";\n    }\n    else {\n        &failed(\"not a gzip'd tarball or zip-file: $path\");\n    }\n    chdir $tempdir;\n    system( sprintf( $command, $full ) );\n\n    # there should be exactly one subdirectory -- the source-tree\n    my @data = &read_dir(\".\");\n    &failed(\"found no subdirectories of $path\") if ( $#data < 0 );\n    &failed( \"too many subdirectories: \" . $data[0] . \" vs \" . $data[1] )\n      if ( $#data > 0 );\n    &check_sourcedir( $data[0] );\n}\n\nsub remove_dir($) {\n    my $tree = shift;\n    if ( -d $tree ) {\n        printf \"%% rm -rf %s\\n\", $tree if ($opt_v);\n        remove_tree( $tree, $opt_v ? 1 : 0, 1 ) unless ($opt_n);\n    }\n}\n\nsub copy_CVS($) {\n    my $leaf    = shift;\n    my $src     = $target_dir . $leaf . \"/CVS\";\n    my $dst     = $update_dir . $leaf . \"/CVS\";\n    my $verbose = $opt_v ? \"v\" : \"\";\n    if ( -d $src and !-d $dst ) {\n        my $mid = $update_dir . $leaf;\n        mkdir $mid unless ( -d $mid );\n        mkdir $dst unless ( -d $dst );\n        system(\"cp -a$verbose $src/* $dst/\");\n    }\n}\n\nsub is_tic_code($) {\n    my $item   = shift;\n    my $result = 0;\n    $result = 1\n      if (\n        $item =~ /^(capconvert\n                   |tic\n                   |dump\n                   |progs\n                   |termsort\n                   |transform\n                   |MKtermsort)/x\n      );\n    return $result;\n}\n\nsub is_ident($$) {\n    my $name = shift;\n    my $text = shift;\n    my $code = 0;\n    $code = 1 if ( $text =~ /\\$$name:.*\\$/ );\n    return $code;\n}\n\n# We \"could\", filter out differences with ident's using the diff -I option,\n# but in practice, that is cumbersome.\nsub munge_ident($) {\n    my $target = shift;\n    my $source = $target;\n    $source =~ s/\\.update\\b//;\n    &failed(\"bug at $source\") if ( $source eq $target );\n    return unless ( -f $source );\n    my @source = &read_file($source);\n    my @target = &read_file($target);\n    my $old_id = \"\";\n    my $gap_id = 0;\n    my $new_id = \"\";\n    my $skipit = -1;\n\n    for my $n ( 0 .. $#source ) {\n        if ( &is_ident( \"OpenBSD\", $source[$n] ) ) {\n            $old_id = $source[$n];\n            $skipit = $n + 1;\n        }\n        elsif ( &is_ident( \"Id\", $source[$n] ) ) {\n            $new_id = $source[$n];\n            last;\n        }\n        elsif ( $n == $skipit ) {\n            $source[$n] =~ s/\\s+$//;\n            if ( $source[$n] eq \"\" ) {\n                $gap_id = $source[$n];\n            }\n            elsif ( $source[$n] eq '.\\\"' ) {\n                $gap_id = $source[$n];\n            }\n        }\n    }\n    if ( $old_id ne \"\" ) {\n        my @update;\n        my $tables = &uses_tables($target);\n        $update[ $#update + 1 ] = $target[0] if ($tables);\n        $update[ $#update + 1 ] = $old_id;\n        $update[ $#update + 1 ] = $gap_id unless ( $gap_id eq 0 );\n        for my $n ( $tables .. $#target ) {\n            if ( &is_ident( \"Id\", $target[$n] ) ) {\n                $update[ $#update + 1 ] = $new_id;\n            }\n            else {\n                $update[ $#update + 1 ] = $target[$n];\n            }\n        }\n        system(\"chmod u+w $target\");\n        if ( open my $fp, \">\", $target ) {\n            for my $n ( 0 .. $#update ) {\n                printf $fp \"%s\\n\", $update[$n];\n            }\n            close $fp;\n            system(\"chmod u-w $target\");\n        }\n    }\n}\n\n# ncurses manual pages provide for renaming the utilities, normally as part of\n# the scripts provided in its sources.  OpenBSD developers do not use those.\nsub munge_docs($) {\n    my $path = shift;\n    my @data = &read_file($path);\n    my $done = 0;\n    for my $n ( 0 .. $#data ) {\n        my $text = $data[$n];\n        $text =~ s/\\b1M\\b/1/g;\n        $text =~ s/\\b3X\\b/3/g;\n        $text =~ s/\\bcurs_(term(info|cap)\\s*3\\b)/$1/g;\n        $text =~ s/(\\\\fB)curs_(term(info|cap)\\\\f[RP]\\(3\\))/$1$2/g;\n        my $left = \"\";\n        while ( $text =~ /@[[:alnum:]_]+@/ ) {\n            my $next = index( $text, \"@\" );\n            last if ( $next < 0 );\n            $left .= substr( $text, 0, $next++ );\n            $text = substr( $text, $next );\n            $next = index( $text, \"@\" );\n            last if ( $next < 0 );\n            my $word = substr( $text, 0, $next );\n            if ( $word =~ /^[[:alnum:]_]+/ ) {\n\n                if ( $definitions{$word} ) {\n                    $word = $definitions{$word};\n                }\n                else {\n                    $word = \"?\";\n                }\n                $left .= $word;\n                $text = substr( $text, $next + 1 );\n            }\n            else {\n                &failed(\"unexpected definition @$word@\");\n            }\n        }\n        $text = $left . $text;\n        if ( $text ne $data[$n] ) {\n            $done++;\n            $data[$n] = $text;\n        }\n    }\n    if ($done) {\n        system(\"chmod u+w $path\");\n        if ( open my $fp, \">\", $path ) {\n            for my $n ( 0 .. $#data ) {\n                printf $fp \"%s\\n\", $data[$n];\n            }\n            close $fp;\n            system(\"chmod u-w $path\");\n        }\n    }\n}\n\nsub copy_file($$) {\n    my $src     = shift;\n    my $dst     = shift;\n    my $verbose = $opt_v ? \"v\" : \"\";\n    if ( -d $dst ) {\n        my $leaf = $src;\n        $leaf =~ s,^.*/,,;\n        $dst .= \"/\" . $leaf;\n    }\n    system(\"chmod u+w $dst\") if ( -f $dst );\n    system(\"cp -a$verbose $src $dst\");\n    &munge_ident($dst);\n}\n\nsub copy_code($) {\n    my $src = shift;\n    my $dst = shift;\n    &copy_CVS( substr( $dst, length($update_dir) ) );\n    printf \".. copying files for $dst\\n\";\n    my @data = &read_dir($src);\n    printf \".. %d entries\\n\", $#data + 1;\n    my $verbose = $opt_v ? \"v\" : \"\";\n    for my $d ( 0 .. $#data ) {\n        my $item     = $data[$d];\n        my $src_item = $src . \"/\" . $item;\n        next if ( -d $src_item );\n        next if ( -l $src_item );\n        next if ( $item =~ /^\\.(\\.)?$/ );\n        next if ( $item =~ /\\.(bak|in|log|status)$/ );\n        next if ( $item =~ /^llib-/ );\n        next if ( $item =~ /^modules/ );\n        next if ( $item =~ /^[fm]_trace\\.c/ and not $opt_t );\n        next\n          if ( $item =~ /^Makefile/ and index( $update_dir, \"/share/\" ) < 0 );\n        next if ( $item =~ /^README/ );\n        next if ( $item eq \"headers\" );\n        next if ( $generated{$item} );\n        next if ( $item eq \"link_test.c\" );\n\n        if ( index( $dst, \"/usr.bin/\" ) >= 0 ) {\n            next if ( $item =~ /^(clear)/ );    # OpenBSD uses \"tput clear\"\n            my $prog = $dst;\n            $prog =~ s%^.*/%%;\n            $prog =~ s/(update|backup)//;\n            $prog .= \"c\";\n            if ( $dst =~ /infocmp/ ) {\n                next if ( $item ne $prog );\n            }\n            elsif ( $dst =~ /tabs/ ) {\n                next if ( $item ne $prog );\n            }\n            elsif ( $dst =~ /tic/ ) {\n                next if ( &is_tic_code($item) == 0 );\n            }\n            elsif ( $dst =~ /toe/ ) {\n                next if ( $item ne $prog );\n            }\n            elsif ( $dst =~ /tput/ ) {\n                next if ( $item ne $prog );\n            }\n            elsif ( $dst =~ /tset/ ) {\n                next if ( $item ne $prog );\n            }\n            else {\n                next;\n            }\n        }\n        system( sprintf( \"cp -a$verbose %s %s/%s\", $src_item, $dst, $item ) );\n        &munge_ident(\"$dst/$item\");\n    }\n}\n\n# Checking if nroff supports tables is a long-obsolete issue, and is not really\n# necessary, except to match OpenBSD's source-tree.\nsub uses_tables($) {\n    my $docs = shift;\n    my @docs = &read_file($docs);\n    my $code = 0;\n    for my $n ( 0 .. $#docs ) {\n        if ( $docs[$n] =~ /^[.']\\\\\"\\s+t\\b.*/ ) {\n            $code = 1;\n            last;\n        }\n        elsif ( $docs[$n] =~ /^\\./ ) {\n            last;\n        }\n    }\n    return $code;\n}\n\nsub copy_1doc($$) {\n    my $docs = shift;\n    my $src  = \"$source_dir/man/$docs\";\n    my $dst  = \"$update_dir/$docs\";\n    $src .= \"m\" if ( -f \"${src}m\" );\n    $dst =~ s/x$//;\n    if ( $dst =~ /\\.3/ ) {\n        $dst =~ s/\\bncurses/curses/ if ( $dst =~ /ncurses\\./ );\n        $dst =~ s/\\bcurs_//         if ( $dst =~ /_term(cap|info)\\./ );\n    }\n    &copy_file( $src, $dst );\n    &munge_docs($dst);\n}\n\nsub copy_docs($) {\n    my $docs = shift;\n    if ( index( $update_dir, \"/usr.bin/\" ) >= 0 ) {\n        &copy_1doc( $docs . \".1\" );\n        if ( $docs eq \"tic\" ) {\n            &copy_1doc(\"captoinfo.1\");\n            &copy_1doc(\"infotocap.1\");\n        }\n    }\n    else {\n        my @docs = &read_dir(\"$source_dir/man\");\n        if ( $docs eq \"curses\" ) {\n            for my $n ( 0 .. $#docs ) {\n                next if ( $docs[$n] eq \"Makefile\" );\n                next if ( $docs[$n] eq \"make_sed.sh\" );\n                next if ( $docs[$n] eq \"man_db.renames\" );\n                next if ( $docs[$n] eq \"manlinks.sed\" );\n                next if ( $docs[$n] =~ /\\.(1|head|tail|in)/ );\n                next if ( $docs[$n] =~ /^(form|menu|mitem|panel)/ );\n                &copy_1doc( $docs[$n] );\n            }\n        }\n        elsif ( $docs eq \"form\" ) {\n            for my $n ( 0 .. $#docs ) {\n                next unless ( $docs[$n] =~ /^form/ );\n                &copy_1doc( $docs[$n] );\n            }\n        }\n        elsif ( $docs eq \"menu\" ) {\n            for my $n ( 0 .. $#docs ) {\n                next unless ( $docs[$n] =~ /^(menu|mitem)/ );\n                &copy_1doc( $docs[$n] );\n            }\n        }\n        elsif ( $docs eq \"panel\" ) {\n            for my $n ( 0 .. $#docs ) {\n                next unless ( $docs[$n] =~ /^panel/ );\n                &copy_1doc( $docs[$n] );\n            }\n        }\n    }\n}\n\nsub setup_dir($) {\n    my $dst = shift;\n    &failed(\"no definition for $dst\")\n      unless ( defined $setup_dir{$dst} or $opt_r );\n    $target_dir = sprintf( \"%s/%s\", $opt_d, $dst );\n    $update_dir = $target_dir . \".update\";\n    $backup_dir = $target_dir . \".backup\";\n    my $result = 0;\n    if ($opt_r) {\n        &remove_dir($update_dir);\n        if ( $target_dir =~ /\\/(tabs|toe)$/ ) {\n            &remove_dir($target_dir);\n        }\n        elsif ( -d $backup_dir ) {\n            &remove_dir($target_dir);\n            &rename_dir( $backup_dir, $target_dir );\n        }\n    }\n    else {\n        &remove_dir($update_dir);\n        mkdir $update_dir;\n\n        # reuse the shared-library version, assuming ABI=5 would involve at\n        # most a minor-version bump.\n        &copy_file( \"$target_dir/shlib_version\", $update_dir )\n          if ( $dst =~ /^lib\\// );\n        &copy_code( $source_dir . \"/\" . $setup_dir{$dst}, $update_dir )\n          unless ( $setup_dir{$dst} eq \"misc\" );\n        $result = 1;\n    }\n    return $result;\n}\n\nsub do_build($) {\n    my $command = shift;\n    printf \"%% %s\\n\", $command if ($opt_v);\n    system($command);\n}\n\nsub finish_dir() {\n    printf \"** $target_dir\\n\";\n    system(\"diff -Naurb $target_dir $update_dir | diffstat -n 30\")\n      if ( -d $target_dir );\n    if ($opt_n) {\n        &do_build(\"cd $update_dir && make -n\") if ($opt_x);\n    }\n    else {\n        if ( -d $backup_dir ) {\n            printf STDERR \"? backup directory exists: %s\\n\", $backup_dir;\n        }\n        else {\n            &rename_dir( $target_dir, $backup_dir );\n            &rename_dir( $update_dir, $target_dir );\n        }\n        &do_build(\"cd $target_dir && make\") if ($opt_x);\n    }\n}\n\n################################################################################\n\nsub only_c_files($) {\n    my @data = @{ $_[0] };\n    my %data;\n    for my $n ( 0 .. $#data ) {\n        my $text = $data[$n];\n        $data{$text}++ if ( $text =~ /\\.c$/ );\n    }\n    return sort keys %data;\n}\n\nsub makefile_list($$$) {\n    my @data = @{ $_[0] };\n    my $name = $_[1];\n    my $skip = $_[2];\n    my %data;\n    my $state = 0;\n    for my $n ( 0 .. $#data ) {\n        my $text = $data[$n];\n        $text =~ s/^\\s+//;\n        next if ( index( $text, $skip ) == 0 );\n        $text =~ s/\\s+=/=/;\n        $text =~ s/=\\s+/=/;\n        $text =~ s/\\s*\\\\//;\n        $state = 1 if ( $text =~ /^${name}=/ );\n        next unless ( $state == 1 );\n\n        if ( index( $text, \"(trace)\" ) >= 0 and not $opt_t ) {\n            next unless ( $text =~ /\\b(lib_trace|visbuf)\\.c$/ );\n        }\n        if ( not $opt_t ) {\n            next if ( $text =~ /\\b[fm]_trace\\.c$/ );\n        }\n        $text =~ s/^.*=//;\n        $text =~ s/\\$o/.o/g;\n        $text =~ s/^.*\\///;\n        next           if ( $text eq \"link_test.c\" );\n        next           if ( $text eq \"mf_common.h\" );\n        next           if ( $text eq \"transform.h\" );\n        $data{$text}++ if ( $text ne \"\" );\n        last           if ( $data[$n] !~ /\\\\$/ );\n    }\n    return sort keys %data;\n}\n\nsub manpage_list($) {\n    my $path = shift;\n    my @data = &read_dir($path);\n    my %data;\n    for my $n ( 0 .. $#data ) {\n        my $text = $data[$n];\n        $data{$text}++ if ( $text =~ /\\.\\d$/ );\n    }\n    return sort keys %data;\n}\n\nsub columns_of($) {\n    my $string = shift;\n    my $result = 0;\n    for my $n ( 0 .. length($string) - 1 ) {\n        my $c = substr( $string, $n, 1 );\n        if ( $c eq \"\\t\" ) {\n            $result |= 7;\n            $result++;\n        }\n        elsif ( $c eq \"\\n\" ) {\n            $result = 0;\n        }\n        else {\n            ++$result;\n        }\n    }\n    return $result;\n}\n\nsub format_list($$) {\n    my $name = $_[0];\n    my @data = @{ $_[1] };\n    my $keep = ( defined $_[2] ) ? 1 : 0;\n    my $base;\n    my $fill;\n    if ( length($name) >= 9 ) {\n        $fill = \" \";\n        $base = length($name) + 1;\n    }\n    else {\n        $base = 9;\n        $fill = \"\\t\";\n    }\n    my $result = sprintf( \"%s%s\", $name, $fill );\n    if ( $keep == 0 ) {\n        my %data;\n        for my $n ( 0 .. $#data ) {\n            $data{ $data[$n] } = 1 if ( defined $data[$n] );\n        }\n        @data = sort keys %data;\n    }\n    for my $n ( 0 .. $#data ) {\n        my $data = $data[$n];\n        my $col  = &columns_of($result);\n        my $add  = 1 + length($data);\n        if ( ( $col + $add ) > 76 ) {\n            $result .= \" \" if ( $col > $base );\n            $base = 9;\n            $fill = \"\\t\";\n            $result .= \"\\\\\\n\" . $fill . $data;\n        }\n        else {\n            $result .= \" \" if ( $col > $base );\n            $result .= $data;\n        }\n    }\n    return $result;\n}\n\n################################################################################\n\nsub compare_makefiles($) {\n    if ($opt_v) {\n        my $newfile = shift;\n        my $bakfile =\n          ( -d $backup_dir ? $backup_dir : $target_dir ) . \"/Makefile\";\n        system(\"diff -u $bakfile $newfile\") if ( -f $bakfile );\n    }\n}\n\n# The curses makefile has to build build-time utilities and generate source.\nsub gen_1st_makefile() {\n    my $libname = \"curses\";\n    my $oldfile = \"$source_dir/n$libname/Makefile\";\n    my @oldfile = &read_file($oldfile);\n\n    my $newfile = \"$update_dir/Makefile\";\n    open( my $fp, \">\", $newfile ) || &failed(\"cannot open $newfile\");\n    my @subdirs = (\n        '${.CURDIR}/base', '${.CURDIR}/tinfo',\n        '${.CURDIR}/tty',  '${.CURDIR}/widechar'\n    );\n    $subdirs[ $#subdirs + 1 ] = '${.CURDIR}/trace' if ($opt_t);\n    printf $fp <<EOF;\n# $generated_by\n\nLIB=\t$libname\n\n# Uncomment this to enable tracing in libcurses\n#CURSESTRACE=-DTRACE\n\n# This is used to compile terminal info directly into the library\nFALLBACK_LIST=\n\n# XXX - should be defined elsewhere\nAWK?=\t/usr/bin/awk\n\n# Search in subdirs\nEOF\n    printf $fp \"%s\\n\", &format_list( \".PATH:\", \\@subdirs );\n\n    my @autosrc = &makefile_list( \\@oldfile, \"AUTO_SRC\", \"?\" );\n    my @auto_cc = &only_c_files( \\@autosrc );\n    printf $fp \"%s\\n\", &format_list( \"SRCS=\", \\@auto_cc );\n\n    my @sources = &makefile_list( \\@oldfile, \"C_SRC\", \"./\" );\n    printf $fp \"%s\\n\", &format_list( \"SRCS+=\", \\@sources );\n\n    printf $fp <<EOF;\n\nHOSTCFLAGS?=\t\\${CFLAGS}\nHOSTLDFLAGS?=\t\\${LDFLAGS}\nHOSTCFLAGS+=\t-I. -I\\${.CURDIR} \\${CURSESTRACE}\nCFLAGS+=\t-I. -I\\${.CURDIR} \\${CURSESTRACE} -D_XOPEN_SOURCE_EXTENDED -DNDEBUG\n\nEOF\n    my @manpages = &manpage_list($update_dir);\n    printf $fp \"%s\\n\", &format_list( \"MAN=\", \\@manpages );\n\n    $autosrc[ $#autosrc++ ] = \"make_hash\";\n    $autosrc[ $#autosrc++ ] = \"make_keys\";\n    printf $fp \"%s\\n\", &format_list( \"GENERATED=\", \\@autosrc );\n    printf $fp <<EOF;\n\nCAPLIST\t= \\${.CURDIR}/Caps\nUSE_BIG_STRINGS\t= 1\n\nCLEANFILES+= \\${GENERATED}\n\nBUILDFIRST = \\${GENERATED}\n\nincludes:\n\t\\@cmp -s \\${DESTDIR}/usr/include/ncurses.h \\${.CURDIR}/curses.h || \\\\\n\t  \\${INSTALL} \\${INSTALL_COPY} -m 444 -o \\$(BINOWN) -g \\$(BINGRP) \\\\\n\t  \\${.CURDIR}/curses.h \\${DESTDIR}/usr/include/ncurses.h\n\t\\@cd \\${.CURDIR}; for i in ncurses_dll.h unctrl.h term.h termcap.h; do \\\\\n\t  cmp -s \\$\\$i \\${DESTDIR}/usr/include/\\$\\$i || \\\\\n\t  \\${INSTALL} \\${INSTALL_COPY} -m 444 -o \\$(BINOWN) -g \\$(BINGRP) \\$\\$i \\\\\n\t  \\${DESTDIR}/usr/include; done\n\nkeys.list: \\${.CURDIR}/tinfo/MKkeys_list.sh\n\tsh \\${.CURDIR}/tinfo/MKkeys_list.sh \\${.CURDIR}/Caps | sort > \\${.TARGET}\n\nfallback.c: \\${.CURDIR}/tinfo/MKfallback.sh\n\tsh \\${.CURDIR}/tinfo/MKfallback.sh /usr/share/terminfo \\${.CURDIR}/../../share/termtypes/termtypes.master \\$(FALLBACK_LIST) > \\${.TARGET}\n\nlib_gen.c: \\${.CURDIR}/base/MKlib_gen.sh\n\tsh \\${.CURDIR}/base/MKlib_gen.sh \"\\${CC} -E -P -I\\${.CURDIR}\" \\\\\n\t\t\"\\${AWK}\" generated < \\${.CURDIR}/curses.h > lib_gen.c\n\ninit_keytry.h: make_keys keys.list\n\t./make_keys keys.list > \\${.TARGET}\n\nmake_keys: \\${.CURDIR}/tinfo/make_keys.c \\${.CURDIR}/curses.priv.h names.c\n\t\\${HOSTCC} \\${LDSTATIC} \\${HOSTCFLAGS} \\${HOSTLDFLAGS} \\\\\n\t\t-o \\${.TARGET} \\${.CURDIR}/tinfo/make_keys.c \\${LDADD}\nEOF\n\n    if ( &patchdate >= 20090808 ) {\n        printf $fp <<EOF;\nmake_hash:\t\\${.CURDIR}/tinfo/make_hash.c \\\\\n\t\t\\${.CURDIR}/curses.priv.h \\\\\n\t\t\\${.CURDIR}/hashsize.h\n\t\\${HOSTCC} \\${LDSTATIC} \\${HOSTCFLAGS} -DMAIN_PROGRAM \\${HOSTLDFLAGS} \\\\\n\t\t-o \\${.TARGET} \\${.CURDIR}/tinfo/make_hash.c \\${LDADD}\nEOF\n    }\n    else {\n        printf $fp <<EOF;\nmake_hash: \\${.CURDIR}/tinfo/comp_hash.c \\\\\n\t\t\\${.CURDIR}/curses.priv.h \\\\\n\t\t\\${.CURDIR}/hashsize.h\n\t\\${HOSTCC} \\${LDSTATIC} \\${HOSTCFLAGS} -DMAIN_PROGRAM \\${HOSTLDFLAGS} \\\\\n\t\t-o \\${.TARGET} \\${.CURDIR}/tinfo/comp_hash.c \\${LDADD}\nEOF\n    }\n\n    if ( &patchdate >= 20190309 ) {\n        printf $fp <<EOF;\nCAPLIST += \\${.CURDIR}/Caps-ncurses\n\ncomp_userdefs.c: make_hash \\\\\n\t\t\\${.CURDIR}/hashsize.h \\\\\n\t\t\\${.CURDIR}/tinfo/MKuserdefs.sh\n\tsh \\${.CURDIR}/tinfo/MKuserdefs.sh \\${AWK} \\${USE_BIG_STRINGS} \\${CAPLIST} > \\${.TARGET}\nEOF\n    }\n    printf $fp <<EOF;\n\nexpanded.c: \\${.CURDIR}/term.h \\${.CURDIR}/curses.priv.h \\\\\n\t\t\\${.CURDIR}/ncurses_cfg.h \\${.CURDIR}/tty/MKexpanded.sh\n\tsh \\${.CURDIR}/tty/MKexpanded.sh \"\\${CC} -E -P\" \\${CPPFLAGS} > \\${.TARGET}\n\ncomp_captab.c: make_hash\n\tsh \\${.CURDIR}/tinfo/MKcaptab.sh \\${AWK} \\${USE_BIG_STRINGS} \\\\\n\t\t\\${.CURDIR}/tinfo/MKcaptab.awk \\${CAPLIST} > \\${.TARGET}\n\nlib_keyname.c: keys.list \\${.CURDIR}/base/MKkeyname.awk\n\t\\${AWK} -f \\${.CURDIR}/base/MKkeyname.awk \\\\\n\t\tbigstrings=\\${USE_BIG_STRINGS} \\\\\n\t\tkeys.list > \\${.TARGET}\n\nnames.c: \\${.CURDIR}/tinfo/MKnames.awk\n\t\\${AWK} -f \\${.CURDIR}/tinfo/MKnames.awk \\\\\n\t\tbigstrings=\\${USE_BIG_STRINGS} \\\\\n\t\t\\${CAPLIST} > \\${.TARGET}\ncodes.c: \\${.CURDIR}/tinfo/MKcodes.awk\n\t\\${AWK} -f \\${.CURDIR}/tinfo/MKcodes.awk \\\\\n\t\tbigstrings=\\${USE_BIG_STRINGS} \\\\\n\t\t\\${CAPLIST} > \\${.TARGET}\n\nunctrl.c: \\${.CURDIR}/base/MKunctrl.awk\n\techo | \\${AWK} -f \\${.CURDIR}/base/MKunctrl.awk bigstrings=1 > \\${.TARGET}\n\n.include <bsd.own.mk>\n\n# Link libtermlib, libtermcap to libcurses so we don't break people's Makefiles\nafterinstall:\n\t-cd \\${DESTDIR}\\${LIBDIR}; \\\\\n\tfor i in \\${_LIBS}; do \\\\\n\t    ln -f \\$\\$i `echo \\$\\$i | sed 's/curses/termlib/'`; \\\\\n\t    ln -f \\$\\$i `echo \\$\\$i | sed 's/curses/termcap/'`; \\\\\n\t    ln -f \\$\\$i `echo \\$\\$i | sed 's/curses/ncurses/'`; \\\\\n\t    ln -f \\$\\$i `echo \\$\\$i | sed 's/curses/ncursesw/'`; \\\\\n\tdone\n\n.include <bsd.lib.mk>\nEOF\n    close $fp;\n    &compare_makefiles($newfile);\n}\n\nsub gen_lib_makefile($) {\n    my $libname = shift;\n    my $oldfile = \"$source_dir/$libname/Makefile\";\n    my @oldfile = &read_file($oldfile);\n\n    # in ncurses, header-files are quasi-generated, because the original\n    # header file for form/menu/panel lives in the source-directory, but is\n    # copied to the include-directory with \"make sources\".\n    my @headers = &makefile_list( \\@oldfile, \"AUTO_SRC\", \"?\" );\n\n    # The C source is more straightforward.\n    my @sources = &makefile_list( \\@oldfile, \"C_SRC\", \"?\" );\n    my $newfile = \"$update_dir/Makefile\";\n    open( my $fp, \">\", $newfile ) || &failed(\"cannot open $newfile\");\n    printf $fp <<EOF;\n# $generated_by\n\nLIB=\t$libname\nEOF\n\n    printf $fp \"%s\\n\", &format_list( \"SRCS=\", \\@sources );\n    printf $fp \"%s\\n\", &format_list( \"HDRS=\", \\@headers );\n    my $includes = '-I${.CURDIR}/../libcurses';\n    $includes .= ' -I${.CURDIR}/../libmenu' if ( $libname eq \"form\" );\n    printf $fp <<EOF;\nCFLAGS+=$includes -D_XOPEN_SOURCE_EXTENDED -DNDEBUG\nEOF\n    my @manpages = &manpage_list($update_dir);\n    printf $fp \"%s\\n\", &format_list( \"MAN=\", \\@manpages );\n    printf $fp <<EOF;\n\nincludes:\n\t\\@cd \\$\\{.CURDIR}; for i in \\$\\{HDRS}; do \\\\\n\t  cmp -s \\$\\$i \\${DESTDIR}/usr/include/\\$\\$i || \\\\\n\t  \\${INSTALL} \\${INSTALL_COPY} -m 444 -o \\$(BINOWN) -g \\$(BINGRP) \\$\\$i \\\\\n\t  \\${DESTDIR}/usr/include; done\n\n.include <bsd.own.mk>\n\nafterinstall:\n\t-cd \\${DESTDIR}\\${LIBDIR}; \\\\\n\tfor i in \\${_LIBS}; do \\\\\n\t    ln -f \\$\\$i `echo \\$\\$i | sed 's/${libname}/${libname}w/'`; \\\\\n\tdone\n\n.include <bsd.lib.mk>\nEOF\n    close $fp;\n    &compare_makefiles($newfile);\n}\n\nsub gen_bin_makefile($) {\n    my $binname = shift;\n    my $oldfile = \"$source_dir/progs/Makefile\";\n    my @oldfile = &read_file($oldfile);\n    my $newfile = \"$update_dir/Makefile\";\n\n    open( my $fp, \">\", $newfile ) || &failed(\"cannot open $newfile\");\n    my @sources = (\"$binname.c\");\n    my @links   = ();\n    my @autosrc = &makefile_list( \\@oldfile, \"AUTO_SRC\", \"?\" );\n\n    my $tput_ver       = 0;\n    my $use_dump_entry = 0;\n    my $use_termsort   = 0;\n    my $use_tparm_type = 0;\n    my $use_transform  = 0;\n\n    $use_dump_entry = 1 if ( $binname eq \"infocmp\" or $binname eq \"tic\" );\n    $use_termsort   = 1 if ( $use_dump_entry       or $binname eq \"tput\" );\n\n    if ( &patchdate >= 20090314 ) {\n        $use_transform = 1 if ( $binname =~ /^(tic|tput|tset)/ );\n    }\n    if ( &patchdate >= 20140521 ) {\n        $use_tparm_type = 1 if ( $binname =~ /^(tic|tput)$/ );\n    }\n    if ( &patchdate >= 20160806 ) {\n        $tput_ver = &patchdate;\n    }\n\n    $sources[ ++$#sources ] = \"dump_entry.c\" if ($use_dump_entry);\n    $sources[ ++$#sources ] = \"tparm_type.c\" if ($use_tparm_type);\n    $sources[ ++$#sources ] = \"transform.c\"  if ($use_transform);\n\n    $autosrc[ ++$#autosrc ] = \"termsort.c\" if ($use_termsort);\n\n    # transform.h also is generated, but OpenBSD checked-in a copy\n\n    if ( $binname eq \"tic\" ) {\n        $links[ ++$#links ] = \"captoinfo\";\n        $links[ ++$#links ] = \"infotocap\";\n    }\n    elsif ( $binname eq \"tabs\" ) {\n        $sources[ ++$#sources ] = \"tty_settings.c\" if ( $tput_ver >= 20161224 );\n    }\n    elsif ( $binname eq \"tput\" ) {\n        $sources[ ++$#sources ] = \"clear_cmd.c\"    if ( $tput_ver >= 20161022 );\n        $sources[ ++$#sources ] = \"reset_cmd.c\"    if ( $tput_ver >= 20160806 );\n        $sources[ ++$#sources ] = \"tty_settings.c\" if ( $tput_ver >= 20161224 );\n        $links[ ++$#links ]     = \"clear\";\n    }\n    elsif ( $binname eq \"tset\" ) {\n        $sources[ ++$#sources ] = \"reset_cmd.c\"    if ( $tput_ver >= 20160806 );\n        $sources[ ++$#sources ] = \"tty_settings.c\" if ( $tput_ver >= 20161224 );\n        $links[ ++$#links ]     = \"reset\";\n    }\n\n    printf $fp <<EOF;\n# $generated_by\n\nPROG=\t$binname\nEOF\n    printf $fp \"%s\\n\", &format_list( \"SRCS=\", \\@sources );\n    printf $fp <<EOF;\nCURSES=\t\\${.CURDIR}/../../lib/libcurses\nDPADD=\t\\${LIBCURSES}\nLDADD=\t-L\\${CURSES} -lcurses\\t# in-tree link to add _nc_strict_bsd, etc\nEOF\n    if ( $#links >= 0 ) {\n        my @bin_links;\n        for my $n ( 0 .. $#links ) {\n            $bin_links[ ++$#bin_links ] = '${BINDIR}/' . $binname;\n            $bin_links[ ++$#bin_links ] = '${BINDIR}/' . $links[$n];\n        }\n        printf $fp \"%s\\n\", &format_list( \"LINKS=\", \\@bin_links, 1 );\n    }\n    my $ticfix = '${.CURDIR}/';\n    if ( $binname eq \"tic\" ) {\n        printf $fp <<EOF;\nCFLAGS+= -I\\${CURSES} -I\\${.CURDIR} -I.\nEOF\n    }\n    else {\n        $ticfix = '${TIC}/';\n        printf $fp <<EOF;\nTIC= \\${.CURDIR}/../tic\nCFLAGS+= -I\\${CURSES} -I\\${TIC} -I\\${.CURDIR} -I.\n.PATH:  \\${TIC}\nEOF\n    }\n    printf $fp \"%s\\n\", &format_list( \"CLEANFILES+=\", \\@autosrc );\n    if ($use_dump_entry) {\n        printf $fp <<EOF;\n\ndump_entry.o: termsort.c\nEOF\n    }\n    if ($use_termsort) {\n        printf $fp <<EOF;\n\ntermsort.c: ${ticfix}MKtermsort.sh\n\tsh ${ticfix}MKtermsort.sh awk \\${CURSES}/Caps > \\${.TARGET}\nEOF\n    }\n    printf $fp <<EOF;\n\n.include <bsd.prog.mk>\nEOF\n    close $fp;\n\n    &compare_makefiles($newfile);\n}\n\n################################################################################\n\nsub setup_lib_libcurses() {\n    if ( &setup_dir(\"lib/libcurses\") ) {\n        &copy_code( \"$source_dir/ncurses/base\",     \"$update_dir/base\" );\n        &copy_code( \"$source_dir/ncurses/tinfo\",    \"$update_dir/tinfo\" );\n        &copy_code( \"$source_dir/ncurses/tty\",      \"$update_dir/tty\" );\n        &copy_code( \"$source_dir/ncurses/widechar\", \"$update_dir/widechar\" );\n        &copy_file( \"$source_dir/include/Caps\",           $update_dir );\n        &copy_file( \"$source_dir/include/capdefaults.c\",  $update_dir );\n        &copy_file( \"$source_dir/include/curses.h\",       $update_dir );\n        &copy_file( \"$source_dir/include/hashed_db.h\",    $update_dir );\n        &copy_file( \"$source_dir/include/hashsize.h\",     $update_dir );\n        &copy_file( \"$source_dir/include/nc_alloc.h\",     $update_dir );\n        &copy_file( \"$source_dir/include/nc_panel.h\",     $update_dir );\n        &copy_file( \"$source_dir/include/nc_tparm.h\",     $update_dir );\n        &copy_file( \"$source_dir/include/ncurses_cfg.h\",  $update_dir );\n        &copy_file( \"$source_dir/include/ncurses_def.h\",  $update_dir );\n        &copy_file( \"$source_dir/include/ncurses_dll.h\",  $update_dir );\n        &copy_file( \"$source_dir/include/parametrized.h\", $update_dir );\n        &copy_file( \"$source_dir/include/term.h\",         $update_dir );\n        &copy_file( \"$source_dir/include/termcap.h\",      $update_dir );\n        &copy_file( \"$source_dir/include/term_entry.h\",   $update_dir );\n        &copy_file( \"$source_dir/include/tic.h\",          $update_dir );\n        &copy_file( \"$source_dir/include/unctrl.h\",       $update_dir );\n        &copy_file( \"$source_dir/man/terminfo.5\",         $update_dir );\n        &copy_docs(\"curses\");\n\n        &verbose(\".. work around a bug in /bin/sh in OpenBSD\");\n        system( \"sed -i\"\n              . \" -e 's,^shift,test \\$# != 0 \\\\&\\\\& shift,'\"\n              . \" $update_dir/tinfo/MKfallback.sh\" );\n\n        # OpenBSD dropped support for sys/ttydev.h, without mentioning the\n        # system version.  Just trim it.\n        &verbose(\".. work around mishandled sys/ttydef.h\");\n        system( \"sed -i\"\n              . \" -e '/__FreeBSD_version/s,|| defined(__OpenBSD__),,'\"\n              . \" $update_dir/tinfo/lib_baudrate.c\" );\n\n        if ($opt_t) {\n            &copy_code( \"$source_dir/ncurses/trace\", \"$update_dir/trace\" );\n        }\n        else {\n            &copy_file( \"$source_dir/ncurses/trace/lib_trace.c\", $update_dir );\n            &copy_file( \"$source_dir/ncurses/trace/visbuf.c\",    $update_dir );\n        }\n        &copy_file( \"$source_dir/include/nc_termios.h\", $update_dir )\n          if ( &patchdate >= 20110625 );\n        &copy_file( \"$source_dir/include/nc_string.h\", $update_dir )\n          if ( &patchdate >= 20120222 );\n        &copy_file( \"$source_dir/include/nc_access.h\", $update_dir )\n          if ( &patchdate >= 20210626 );\n        &copy_file( \"$source_dir/include/Caps-ncurses\", $update_dir )\n          if ( &patchdate >= 20190302 );\n        &gen_1st_makefile;\n        &finish_dir;\n    }\n}\n\nsub setup_lib_libform() {\n    if ( &setup_dir(\"lib/libform\") ) {\n        &copy_docs(\"form\");\n        &gen_lib_makefile(\"form\");\n        &finish_dir;\n    }\n}\n\nsub setup_lib_libmenu() {\n    if ( &setup_dir(\"lib/libmenu\") ) {\n        &copy_docs(\"menu\");\n        &gen_lib_makefile(\"menu\");\n        &finish_dir;\n    }\n}\n\nsub setup_lib_libpanel() {\n    if ( &setup_dir(\"lib/libpanel\") ) {\n        &copy_docs(\"panel\");\n        &gen_lib_makefile(\"panel\");\n        &finish_dir;\n    }\n}\n\nsub setup_bin_infocmp() {\n    if ( &setup_dir(\"usr.bin/infocmp\") ) {\n        &copy_docs(\"infocmp\");\n        &gen_bin_makefile(\"infocmp\");\n        &finish_dir;\n    }\n}\n\nsub setup_bin_tabs() {\n    if ( &setup_dir(\"usr.bin/tabs\") ) {\n        &copy_docs(\"tabs\");\n        &gen_bin_makefile(\"tabs\");\n        &finish_dir;\n    }\n}\n\nsub setup_bin_tic() {\n    if ( &setup_dir(\"usr.bin/tic\") ) {\n        if ( &patchdate >= 20140521 ) {\n            &copy_file( \"$source_dir/progs/tparm_type.c\", $update_dir );\n            &copy_file( \"$source_dir/progs/tparm_type.h\", $update_dir );\n        }\n\n        # shared files for tput/tset\n        if ( &patchdate >= 20160806 ) {\n            &copy_file( \"$source_dir/progs/reset_cmd.c\", $update_dir );\n            &copy_file( \"$source_dir/progs/reset_cmd.h\", $update_dir );\n        }\n        if ( &patchdate >= 20161022 ) {\n            &copy_file( \"$source_dir/progs/clear_cmd.c\", $update_dir );\n            &copy_file( \"$source_dir/progs/clear_cmd.h\", $update_dir );\n        }\n        if ( &patchdate >= 20161224 ) {\n            &copy_file( \"$source_dir/progs/tty_settings.c\", $update_dir );\n            &copy_file( \"$source_dir/progs/tty_settings.h\", $update_dir );\n        }\n        &copy_docs(\"tic\");\n        &gen_bin_makefile(\"tic\");\n        &finish_dir;\n    }\n}\n\nsub setup_bin_toe() {\n    if ( &setup_dir(\"usr.bin/toe\") ) {\n        &copy_docs(\"toe\");\n        &gen_bin_makefile(\"toe\");\n        &finish_dir;\n    }\n}\n\nsub setup_bin_tput() {\n    if ( &setup_dir(\"usr.bin/tput\") ) {\n        &copy_docs(\"tput\");\n        &gen_bin_makefile(\"tput\");\n        &finish_dir;\n    }\n}\n\nsub setup_bin_tset() {\n    if ( &setup_dir(\"usr.bin/tset\") ) {\n        &copy_docs(\"tset\");\n        &gen_bin_makefile(\"tset\");\n        &finish_dir;\n    }\n}\n\nsub setup_terminfo() {\n    if ( &setup_dir(\"share/termtypes\") ) {\n        &copy_code( $target_dir, $update_dir );\n        &copy_file( \"$source_dir/misc/terminfo.src\",\n            \"$update_dir/termtypes.master\" );\n\n        # build the terminfo database using the in-tree tic.\n        # This is always best practice, but for ncurses 6.2 in particular is\n        # required.\n        my $prog = abs_path(\"$target_dir/../../usr.bin/tic\");\n        my $libs = abs_path(\"$target_dir/../../lib/libcurses\");\n        if ( defined $prog and defined $libs ) {\n            $prog .= \"/tic\";\n            &verbose(\".. changing makefile to use in-tree tic\");\n            system( \"sed -i -E \"\n                  . \"-e 's,(TIC=).*,\\\\1\\t$prog,' \"\n                  . \"-e 's,(\\\\\\${TIC}),LD_LIBRARY_PATH=$libs \\\\1,' \"\n                  . \"$update_dir/Makefile\" );\n        }\n        &finish_dir;\n    }\n}\n\nsub configure_tree() {\n    return if ( -f \"ncurses/Makefile\" );\n    my @search = ( \"/usr/share/terminfo\", \"/usr/local/share/terminfo\" );\n    my @prefix = (\"./configure\");\n    $prefix[ ++$#prefix ] = \"--with-abi-version=5\"\n      if ( &patchdate >= 20150502 );\n    my @options = (\n        \"--with-ospeed=int\",    #\n        \"--with-shared\",        #\n        \"--without-normal\",     #\n        \"--without-debug\",      #\n        \"--with-terminfo-dirs=\" . join( ':', @search ),    #\n        \"--without-ada\",                                   #\n        \"--disable-hard-tabs\",                             #\n        \"--enable-const\",                                  #\n        \"--enable-getcap\",                                 #\n        \"--enable-bsdpad\",                                 #\n        \"--enable-signed-char\",                            #\n        \"--enable-termcap\",                                #\n        \"--enable-widec\"\n    );\n    $options[ ++$#options ] = \"--with-trace\" if ($opt_t);\n    $options[ ++$#options ] = \"--enable-string-hacks\"\n      if ( &patchdate >= 20120225 );\n    system( join( ' ', @prefix ) . ' ' . join( ' ', @options ) );\n    &failed(\"problem with configuring\") unless ( -f \"ncurses/Makefile\" );\n\n    system(\"make sources\");\n\n    # OpenBSD developers edit the generated file and do not regen it when\n    # doing upgrades.  This script reflects those edits.\n    system( \"sed -i\" . \" -E\"\n          . \" -e '/TYPEOF_CHTYPE/s,int,long,'\"\n          . \" -e '/USE_TERMCAP/d'\"\n          . \" -e '/HAVE_LIB(FORM|MENU|PANEL)/s,^(.*)\\$,/* \\\\1 */,'\"\n          . \" -e 's/TERMPATH.*/PURE_TERMINFO 0/'\"\n          . \" -e '/SYSTEM_NAME/s,\\[0-9.\\]+,,'\"\n          . \" include/ncurses_cfg.h\" );\n}\n\nsub get_definitions() {\n    my @data = &read_file(\"dist.mk\");\n    for my $n ( 0 .. $#data ) {\n        my $text = $data[$n];\n        $text =~ s/^\\s*//;\n        next unless ( $text =~ /^NCURSES.*=/ );\n        $text =~ s/\\s*=\\s+/=/;\n        my $name = $text;\n        $name =~ s/=.*//;\n        my $value = $text;\n        $value =~ s/^[^=]*=//;\n        $value =~ s/\\s.*//;\n        $definitions{$name} = $value;\n    }\n}\n\nsub setup_all_dirs() {\n    printf \"** %s all build-directories\\n\", $opt_r ? \"removing\" : \"setting up\";\n    &get_definitions;\n    &configure_tree unless ($opt_r);\n    &setup_lib_libcurses;\n    &setup_lib_libmenu;\n    &setup_lib_libform;    # build after libmenu, for mf_common.h\n    &setup_lib_libpanel;\n    &setup_bin_tic;        # do this first, for shared headers\n    &setup_bin_infocmp;\n    &setup_bin_tabs if ( -f \"$source_dir/progs/tabs.c\" );\n    &setup_bin_toe;\n    &setup_bin_tput;\n    &setup_bin_tset;\n    &setup_terminfo;\n}\n\nsub usage() {\n    print <<EOF;\nUsage: ncu2openbsd [options] [sourcetree]\n\nOptions:\n  -d DST   specify destination (default: /usr/src)\n  -n       no-op, do not update destination\n  -r       remove update, restore sources from \".orig\"\n  -t       enable ncurses trace\n  -v       verbose\n  -x       build each directory after setting up\nEOF\n    exit;\n}\n\n$Getopt::Std::STANDARD_HELP_VERSION = 1;\n&getopts('d:nrtvx') || &usage();\n$opt_d = \"/usr/src\" unless ($opt_d);\n&usage() unless ( $#ARGV <= 0 );\n\nif ( $#ARGV == 0 ) {\n    if ( -f $ARGV[0] ) {\n        printf \"** unpacking sources: %s\\n\", $ARGV[0];\n        &unpack( $ARGV[0] );\n    }\n    else {\n        &check_sourcedir( $ARGV[0] );\n    }\n}\nelse {\n    &check_sourcedir(\".\");\n}\n\n&setup_all_dirs;\n\n# move out of temp-directory to allow cleanup.\nchdir $current;\n\n1;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}