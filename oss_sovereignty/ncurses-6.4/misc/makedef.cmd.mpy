{
  "module_name": "makedef.cmd",
  "hash_id": "563c6305fd18b8e96d11323281ecfbeca8dd4e8b4b79461ddc07c2ad9394cd81",
  "original_prompt": "Ingested from ncurses-6.4/misc/makedef.cmd",
  "human_readable_source": "/****************************************************************************\n * Copyright 2020,2021 Thomas E. Dickey                                     *\n * Copyright 1998,2006 Free Software Foundation, Inc.                       *\n *                                                                          *\n * Permission is hereby granted, free of charge, to any person obtaining a  *\n * copy of this software and associated documentation files (the            *\n * \"Software\"), to deal in the Software without restriction, including      *\n * without limitation the rights to use, copy, modify, merge, publish,      *\n * distribute, distribute with modifications, sublicense, and/or sell       *\n * copies of the Software, and to permit persons to whom the Software is    *\n * furnished to do so, subject to the following conditions:                 *\n *                                                                          *\n * The above copyright notice and this permission notice shall be included  *\n * in all copies or substantial portions of the Software.                   *\n *                                                                          *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n *                                                                          *\n * Except as contained in this notice, the name(s) of the above copyright   *\n * holders shall not be used in advertising or otherwise to promote the     *\n * sale, use or other dealings in this Software without prior written       *\n * authorization.                                                           *\n ****************************************************************************/\n\n/*\n * $Id: makedef.cmd,v 1.7 2021/09/04 10:52:55 tom Exp $\n *\n * Author:  Juan Jose Garcia Ripoll <worm@arrakis.es>.\n * Webpage: http://www.arrakis.es/~worm/\n *\n * makedef.cmd - update a DLL export list using a newly created library file\n *\t\t in a.out format, plus an old .DEF file.\n *\n * standard output gets a sorted list with all entrypoints with entrycodes.\n * This list, plus a few .def sentences (LIBRARY, DESCRIPTION and EXPORT)\n * is used to build a new .def file.\n *\n * `_nc_*' symbols are ignored.\n *\n * returns 1 when the old def_file is corrupted -- that is, export items are\n * not properly formatted.\n *\n * returns 0 if everything went OK.\n */\n\nparse arg lib_file def_file\n\nlib_file = translate(lib_file,'\\','/')\ndef_file = translate(def_file,'\\','/')\n\ncall CleanQueue\n\n/*\n * `codes' is the stem that links a code to every symbol\n * `names' is the stem where symbols are stored sequentially\n * `last' is the index of the last symbol defined\n */\nlast   = 0\nused.  = 0\ncodes. = 0\nnames. = ''\n\ntmp_name = 'foo.tmp'\n\n/*\n * This sed expression cleans empty lines, comments and special .DEF\n * commands, such as LIBRARY..., EXPORTS..., etc\n */\ntidy_up  = '\"/^[A-Z]/d;s/[ \t][ \t]*/ /g;s/;.*$//g;s/^[ ]*//g;/^[ ]*$/d\"'\n\n/*\n * First we find all public symbols (functions and variables). Next we\n * concatenate this list with the old one, sorting it and wiping out\n * all unused data (comments, DLL directives, blanks, etc). All this\n * information is pushed into a REXX private list with the RXQUEUE\n * utility program.\n */\n'@echo off'\n'emxexp -u' lib_file '>' tmp_name\n'cat' tmp_name def_file '| sed' tidy_up '| sort > foo2.tmp'\n'type foo2.tmp | rxqueue'\n'del' tmp_name '1>NUL'\n\n/*\n * This loop runs over the queue items\n */\ndo while queued() > 0\n   /*\n    * We retrieve the symbol name (NEW_NAME) and its number (NEW_NUMBER)\n    * When the line comes from `emximp's output, there's no number, so\n    * we assign it the special value 0.\n    */\n   parse pull new_symbol '@'new_code rest\n   if Left(new_symbol,1) = '\"' then\n      parse var new_symbol '\"' new_name '\"' rest\n   else\n      do\n      echo 'Symbol 'new_symbol' was not quoted'\n      new_name = new_symbol\n      end\n\n   if new_code = '' then\n      new_code = 0\n   /*\n    * Here, one would place all smart checks that would kill unused symbols.\n    * However, export tables are not that big, so why bothering?\n   if Left(new_name,4) = '_nc_' then\n      iterate\n    */\n   /*\n    * The algorithm:\n    *\tIF (this is the 2nd time the symbol appears) THEN\n    *\t\t(this symbol comes from a .DEF file)\n    *\t\tit has a valid code that we store\n    *\t\twe mark that code as used\n    *   ELIF (it has no number) THEN\n    *\t\t(it is a new symbol)\n    *\t\twe increase the counter of defined symbols\n    *\t\twe assign it the special number 0\n    *\t\t(later on it'll be assigned an unused export code)\n    *   ELSE\n    *\t\tthis symbol was in the old DLL and it is no longer\n    *\t\there, so we skip it.\n    */\n   select\n      when new_name = '' then\n         'echo Warning: empty symbol found 1>&2'\n      when names.last = new_name then\n         do\n         codes.last = new_code\n         used.new_code = 1\n         end\n      when new_code = 0 then\n         do\n         last = last + 1\n         names.last = new_name\n         codes.last = 0\n         end\n   otherwise\n      'echo Warning: symbol \"'new_name'\" has disappeared 1>&2'\n   end /* select */\nend /* do while queued() */\n\n/*\n * Finally we scan the stem, writing out all symbols with export codes.\n * Those that did not have a valid one (just 0) are assigned a new one.\n */\nnew_code = 1\ninx = 1\ndo while inx <= last\n   if codes.inx = 0 then\n      do\n      do while used.new_code \\= 0\n         new_code = new_code + 1\n      end\n      codes.inx = new_code\n      used.new_code = 1\n      end\n   say '\t\"'names.inx'\"\t@'codes.inx'\tNONAME'\n   inx = inx + 1\nend\n'del foo2.tmp 1>NUL'\nexit 0\n\n/*\n * Cleans the REXX queue by pulling and forgetting every line.\n * This is needed, at least, when `makedef.cmd' starts, because an aborted\n * REXX program might have left some rubbish in.\n */\nCleanQueue: procedure\n   do while queued() > 0\n      parse pull foo\n   end\nreturn\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}