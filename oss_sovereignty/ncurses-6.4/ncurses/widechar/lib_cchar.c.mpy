{
  "module_name": "lib_cchar.c",
  "hash_id": "ca2d9cc8a9c6dc209e2d214d57c9050f0c220e1b12d6342731750164ea95e9da",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/widechar/lib_cchar.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n#include <wchar.h>\n\nMODULE_ID(\"$Id: lib_cchar.c,v 1.38 2022/07/27 08:03:16 tom Exp $\")\n\n \nNCURSES_EXPORT(int)\nsetcchar(cchar_t *wcval,\n\t const wchar_t *wch,\n\t const attr_t attrs,\n\t NCURSES_PAIRS_T pair_arg,\n\t const void *opts)\n{\n    int code = OK;\n    int color_pair = pair_arg;\n    unsigned len;\n\n    TR(TRACE_CCALLS, (T_CALLED(\"setcchar(%p,%s,attrs=%lu,pair=%d,%p)\"),\n\t\t      (void *) wcval, _nc_viswbuf(wch),\n\t\t      (unsigned long) attrs, color_pair, opts));\n\n    set_extended_pair(opts, color_pair);\n    if (wch == NULL\n\t|| ((len = (unsigned) wcslen(wch)) > 1 && _nc_wacs_width(wch[0]) < 0)\n\t|| color_pair < 0) {\n\tcode = ERR;\n    } else {\n\tunsigned i;\n\n\tif (len > CCHARW_MAX)\n\t    len = CCHARW_MAX;\n\n\t \n\tfor (i = 1; i < len; ++i) {\n\t    if (_nc_wacs_width(wch[i]) != 0) {\n\t\tlen = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tmemset(wcval, 0, sizeof(*wcval));\n\n\tif (len != 0) {\n\t    SetAttr(*wcval, attrs);\n\t    SetPair(CHDEREF(wcval), color_pair);\n\t    memcpy(&wcval->chars, wch, len * sizeof(wchar_t));\n\t    TR(TRACE_CCALLS, (\"copy %d wchars, first is %s\", len,\n\t\t\t      _tracecchar_t(wcval)));\n\t}\n    }\n\n    TR(TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n\nNCURSES_EXPORT(int)\ngetcchar(const cchar_t *wcval,\n\t wchar_t *wch,\n\t attr_t *attrs,\n\t NCURSES_PAIRS_T *pair_arg,\n\t void *opts)\n{\n    int code = ERR;\n\n    TR(TRACE_CCALLS, (T_CALLED(\"getcchar(%p,%p,%p,%p,%p)\"),\n\t\t      (const void *) wcval,\n\t\t      (void *) wch,\n\t\t      (void *) attrs,\n\t\t      (void *) pair_arg,\n\t\t      opts));\n\n#if !NCURSES_EXT_COLORS\n    if (opts != NULL) {\n\t;\t\t\t \n    } else\n#endif\n    if (wcval != NULL) {\n\twchar_t *wp;\n\tint len;\n\n#if HAVE_WMEMCHR\n\tlen = ((wp = wmemchr(wcval->chars, L'\\0', (size_t) CCHARW_MAX))\n\t       ? (int) (wp - wcval->chars)\n\t       : CCHARW_MAX);\n#else\n\tlen = wcsnlen(wcval->chars, CCHARW_MAX);\n#endif\n\tif (wch == NULL) {\n\t     \n\t    code = (len < CCHARW_MAX) ? (len + 1) : CCHARW_MAX;\n\t} else if (attrs == 0 || pair_arg == 0) {\n\t    code = ERR;\n\t} else if (len >= 0) {\n\t    int color_pair;\n\n\t    TR(TRACE_CCALLS, (\"copy %d wchars, first is %s\", len,\n\t\t\t      _tracecchar_t(wcval)));\n\t    *attrs = AttrOf(*wcval) & A_ATTRIBUTES;\n\t    color_pair = GetPair(*wcval);\n\t    get_extended_pair(opts, color_pair);\n\t    *pair_arg = limit_PAIRS(color_pair);\n\t    wmemcpy(wch, wcval->chars, (size_t) len);\n\t    wch[len] = L'\\0';\n\t    if (*pair_arg >= 0)\n\t\tcode = OK;\n\t}\n    }\n\n    TR(TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}