{
  "module_name": "lib_add_wch.c",
  "hash_id": "2fb21400163cf43659603f856e22bc64b1bb2684ac69457697531440005856fa",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/widechar/lib_add_wch.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\n#if HAVE_WCTYPE_H\n#include <wctype.h>\n#endif\n\nMODULE_ID(\"$Id: lib_add_wch.c,v 1.17 2021/06/17 21:26:02 tom Exp $\")\n\n \nstatic const cchar_t blankchar = NewChar(BLANK_TEXT);\n\n \n\n \n#define COLOR_MASK(ch) (~(attr_t)(((ch) & A_COLOR) ? A_COLOR : 0))\n\nstatic NCURSES_INLINE cchar_t\nrender_char(WINDOW *win, cchar_t ch)\n \n{\n    attr_t a = WINDOW_ATTRS(win);\n    int pair = GetPair(ch);\n\n    if (ISBLANK(ch)\n\t&& AttrOf(ch) == A_NORMAL\n\t&& pair == 0) {\n\t \n\tch = win->_nc_bkgd;\n\tSetAttr(ch, a | AttrOf(win->_nc_bkgd));\n\tif ((pair = GET_WINDOW_PAIR(win)) == 0)\n\t    pair = GetPair(win->_nc_bkgd);\n\tSetPair(ch, pair);\n    } else {\n\t \n\ta |= AttrOf(win->_nc_bkgd) & COLOR_MASK(a);\n\t \n\tif (pair == 0) {\n\t    if ((pair = GET_WINDOW_PAIR(win)) == 0)\n\t\tpair = GetPair(win->_nc_bkgd);\n\t}\n\tAddAttr(ch, (a & COLOR_MASK(AttrOf(ch))));\n\tSetPair(ch, pair);\n    }\n\n    TR(TRACE_VIRTPUT,\n       (\"render_char bkg %s (%d), attrs %s (%d) -> ch %s (%d)\",\n\t_tracech_t2(1, CHREF(win->_nc_bkgd)),\n\tGetPair(win->_nc_bkgd),\n\t_traceattr(WINDOW_ATTRS(win)),\n\tGET_WINDOW_PAIR(win),\n\t_tracech_t2(3, CHREF(ch)),\n\tGetPair(ch)));\n\n    return (ch);\n}\n\n \n#ifndef NDEBUG\t\t\t \n#define CHECK_POSITION(win, x, y) \\\n\tif (y > win->_maxy \\\n\t || x > win->_maxx \\\n\t || y < 0 \\\n\t || x < 0) { \\\n\t\tTR(TRACE_VIRTPUT, (\"Alert! Win=%p _curx = %d, _cury = %d \" \\\n\t\t\t\t   \"(_maxx = %d, _maxy = %d)\", win, x, y, \\\n\t\t\t\t   win->_maxx, win->_maxy)); \\\n\t\treturn(ERR); \\\n\t}\n#else\n#define CHECK_POSITION(win, x, y)\t \n#endif\n\nstatic bool\nnewline_forces_scroll(WINDOW *win, NCURSES_SIZE_T *ypos)\n{\n    bool result = FALSE;\n\n    if (*ypos >= win->_regtop && *ypos == win->_regbottom) {\n\t*ypos = win->_regbottom;\n\tresult = TRUE;\n    } else {\n\t*ypos = (NCURSES_SIZE_T) (*ypos + 1);\n    }\n    return result;\n}\n\n \nstatic int\nwrap_to_next_line(WINDOW *win)\n{\n    win->_flags |= _WRAPPED;\n    if (newline_forces_scroll(win, &(win->_cury))) {\n\twin->_curx = win->_maxx;\n\tif (!win->_scroll)\n\t    return (ERR);\n\tscroll(win);\n    }\n    win->_curx = 0;\n    return (OK);\n}\n\nstatic int wadd_wch_literal(WINDOW *, cchar_t);\n \nstatic void\nfill_cells(WINDOW *win, int count)\n{\n    cchar_t blank = blankchar;\n    int save_x = win->_curx;\n    int save_y = win->_cury;\n\n    while (count-- > 0) {\n\tif (wadd_wch_literal(win, blank) == ERR)\n\t    break;\n    }\n    win->_curx = (NCURSES_SIZE_T) save_x;\n    win->_cury = (NCURSES_SIZE_T) save_y;\n}\n\nstatic int\nwadd_wch_literal(WINDOW *win, cchar_t ch)\n{\n    int x;\n    int y;\n    struct ldat *line;\n\n    x = win->_curx;\n    y = win->_cury;\n\n    CHECK_POSITION(win, x, y);\n\n    ch = render_char(win, ch);\n\n    line = win->_line + y;\n\n    CHANGED_CELL(line, x);\n\n     \n    {\n\tint len = _nc_wacs_width(CharOf(ch));\n\tint i;\n\tint j;\n\twchar_t *chars;\n\n\tif (len == 0) {\t\t \n\t    if ((x > 0 && y >= 0)\n\t\t|| (win->_maxx >= 0 && win->_cury >= 1)) {\n\t\tif (x > 0 && y >= 0)\n\t\t    chars = (win->_line[y].text[x - 1].chars);\n\t\telse\n\t\t    chars = (win->_line[y - 1].text[win->_maxx].chars);\n\t\tfor (i = 0; i < CCHARW_MAX; ++i) {\n\t\t    if (chars[i] == 0) {\n\t\t\tTR(TRACE_VIRTPUT,\n\t\t\t   (\"added non-spacing %d: %x\",\n\t\t\t    x, (int) CharOf(ch)));\n\t\t\tchars[i] = CharOf(ch);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    goto testwrapping;\n\t} else if (len > 1) {\t \n\t     \n\t    if (len > win->_maxx + 1) {\n\t\tTR(TRACE_VIRTPUT, (\"character will not fit\"));\n\t\treturn ERR;\n\t    } else if (x + len > win->_maxx + 1) {\n\t\tint count = win->_maxx + 1 - x;\n\t\tTR(TRACE_VIRTPUT, (\"fill %d remaining cells\", count));\n\t\tfill_cells(win, count);\n\t\tif (wrap_to_next_line(win) == ERR)\n\t\t    return ERR;\n\t\tx = win->_curx;\n\t\ty = win->_cury;\n\t\tline = win->_line + y;\n\t    }\n\t     \n\t    for (i = 0; i < len; ++i) {\n\t\tif (isWidecBase(win->_line[y].text[x + i])) {\n\t\t    break;\n\t\t} else if (isWidecExt(win->_line[y].text[x + i])) {\n\t\t    for (j = i; x + j <= win->_maxx; ++j) {\n\t\t\tif (!isWidecExt(win->_line[y].text[x + j])) {\n\t\t\t    TR(TRACE_VIRTPUT, (\"fill %d orphan cells\", j));\n\t\t\t    fill_cells(win, j);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t     \n\t    for (i = 0; i < len; ++i) {\n\t\tcchar_t value = ch;\n\t\tSetWidecExt(value, i);\n\t\tTR(TRACE_VIRTPUT, (\"multicolumn %d:%d (%d,%d)\",\n\t\t\t\t   i + 1, len,\n\t\t\t\t   win->_begy + y, win->_begx + x));\n\t\tline->text[x] = value;\n\t\tCHANGED_CELL(line, x);\n\t\t++x;\n\t    }\n\t    goto testwrapping;\n\t}\n    }\n\n     \n    line->text[x++] = ch;\n     \n  testwrapping:\n\n    TR(TRACE_VIRTPUT, (\"cell (%ld, %ld..%d) = %s\",\n\t\t       (long) win->_cury, (long) win->_curx, x - 1,\n\t\t       _tracech_t(CHREF(ch))));\n\n    if (x > win->_maxx) {\n\treturn wrap_to_next_line(win);\n    }\n    win->_curx = (NCURSES_SIZE_T) x;\n    return OK;\n}\n\nstatic NCURSES_INLINE int\nwadd_wch_nosync(WINDOW *win, cchar_t ch)\n \n{\n    NCURSES_SIZE_T x, y;\n    wchar_t *s;\n    int tabsize = 8;\n#if USE_REENTRANT\n    SCREEN *sp = _nc_screen_of(win);\n#endif\n\n     \n    if ((AttrOf(ch) & A_ALTCHARSET)\n\t|| iswprint((wint_t) CharOf(ch)))\n\treturn wadd_wch_literal(win, ch);\n\n     \n    x = win->_curx;\n    y = win->_cury;\n\n    switch (CharOf(ch)) {\n    case '\\t':\n#if USE_REENTRANT\n\ttabsize = *ptrTabsize(sp);\n#else\n\ttabsize = TABSIZE;\n#endif\n\tx = (NCURSES_SIZE_T) (x + (tabsize - (x % tabsize)));\n\t \n\tif ((!win->_scroll && (y == win->_regbottom))\n\t    || (x <= win->_maxx)) {\n\t    cchar_t blank = blankchar;\n\t    AddAttr(blank, AttrOf(ch));\n\t    while (win->_curx < x) {\n\t\tif (wadd_wch_literal(win, blank) == ERR)\n\t\t    return (ERR);\n\t    }\n\t    break;\n\t} else {\n\t    wclrtoeol(win);\n\t    win->_flags |= _WRAPPED;\n\t    if (newline_forces_scroll(win, &y)) {\n\t\tx = win->_maxx;\n\t\tif (win->_scroll) {\n\t\t    scroll(win);\n\t\t    x = 0;\n\t\t}\n\t    } else {\n\t\tx = 0;\n\t    }\n\t}\n\tbreak;\n    case '\\n':\n\twclrtoeol(win);\n\tif (newline_forces_scroll(win, &y)) {\n\t    if (win->_scroll)\n\t\tscroll(win);\n\t    else\n\t\treturn (ERR);\n\t}\n\t \n    case '\\r':\n\tx = 0;\n\twin->_flags &= ~_WRAPPED;\n\tbreak;\n    case '\\b':\n\tif (x == 0)\n\t    return (OK);\n\tx--;\n\twin->_flags &= ~_WRAPPED;\n\tbreak;\n    default:\n\tif ((s = wunctrl(&ch)) != 0) {\n\t    while (*s) {\n\t\tcchar_t sch;\n\t\tSetChar(sch, *s++, AttrOf(ch));\n\t\tif_EXT_COLORS(SetPair(sch, GetPair(ch)));\n\t\tif (wadd_wch_literal(win, sch) == ERR)\n\t\t    return ERR;\n\t    }\n\t    return OK;\n\t}\n\treturn ERR;\n    }\n\n    win->_curx = x;\n    win->_cury = y;\n\n    return OK;\n}\n\n \n\n \n\nNCURSES_EXPORT(int)\nwadd_wch(WINDOW *win, const cchar_t *wch)\n{\n    int code = ERR;\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED(\"wadd_wch(%p, %s)\"),\n\t\t\t\t      (void *) win,\n\t\t\t\t      _tracecchar_t(wch)));\n\n    if (win && (wadd_wch_nosync(win, *wch) != ERR)) {\n\t_nc_synchook(win);\n\tcode = OK;\n    }\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n\nNCURSES_EXPORT(int)\nwecho_wchar(WINDOW *win, const cchar_t *wch)\n{\n    int code = ERR;\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED(\"wechochar(%p, %s)\"),\n\t\t\t\t      (void *) win,\n\t\t\t\t      _tracecchar_t(wch)));\n\n    if (win && (wadd_wch_nosync(win, *wch) != ERR)) {\n\tbool save_immed = win->_immed;\n\twin->_immed = TRUE;\n\t_nc_synchook(win);\n\twin->_immed = save_immed;\n\tcode = OK;\n    }\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}