{
  "module_name": "lib_tstp.c",
  "hash_id": "61bf5f16d3decf44dc95c5d0712357b659a1baaa4e3aa90e58c62a472a2c84c4",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tty/lib_tstp.c",
  "human_readable_source": " \n\n \n\n \n#include <curses.priv.h>\n\n#include <SigAction.h>\n\nMODULE_ID(\"$Id: lib_tstp.c,v 1.54 2022/12/24 22:22:10 tom Exp $\")\n\n#if defined(SIGTSTP) && (HAVE_SIGACTION || HAVE_SIGVEC)\n#define USE_SIGTSTP 1\n#else\n#define USE_SIGTSTP 0\n#endif\n\n#ifdef TRACE\nstatic const char *\nsignal_name(int sig)\n{\n    switch (sig) {\n#ifdef SIGALRM\n    case SIGALRM:\n\treturn \"SIGALRM\";\n#endif\n#ifdef SIGCONT\n    case SIGCONT:\n\treturn \"SIGCONT\";\n#endif\n    case SIGINT:\n\treturn \"SIGINT\";\n#ifdef SIGQUIT\n    case SIGQUIT:\n\treturn \"SIGQUIT\";\n#endif\n    case SIGTERM:\n\treturn \"SIGTERM\";\n#ifdef SIGTSTP\n    case SIGTSTP:\n\treturn \"SIGTSTP\";\n#endif\n#ifdef SIGTTOU\n    case SIGTTOU:\n\treturn \"SIGTTOU\";\n#endif\n#ifdef SIGWINCH\n    case SIGWINCH:\n\treturn \"SIGWINCH\";\n#endif\n    default:\n\treturn \"unknown signal\";\n    }\n}\n#endif\n\n \n\n#if USE_SIGTSTP\nstatic void\nhandle_SIGTSTP(int dummy GCC_UNUSED)\n{\n    SCREEN *sp = CURRENT_SCREEN;\n    sigset_t mask, omask;\n    sigaction_t act, oact;\n\n#ifdef SIGTTOU\n    int sigttou_blocked;\n#endif\n\n    _nc_globals.have_sigtstp = 1;\n    T((\"handle_SIGTSTP() called\"));\n\n     \n    if (sp != 0 && (sp->_endwin == ewRunning))\n#if HAVE_TCGETPGRP\n\tif (tcgetpgrp(STDIN_FILENO) == getpgrp())\n#endif\n\t    NCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_ARG);\n\n     \n    (void) sigemptyset(&mask);\n#ifdef SIGALRM\n    (void) sigaddset(&mask, SIGALRM);\n#endif\n#if USE_SIGWINCH\n    (void) sigaddset(&mask, SIGWINCH);\n#endif\n    (void) sigprocmask(SIG_BLOCK, &mask, &omask);\n\n#ifdef SIGTTOU\n    sigttou_blocked = sigismember(&omask, SIGTTOU);\n    if (!sigttou_blocked) {\n\t(void) sigemptyset(&mask);\n\t(void) sigaddset(&mask, SIGTTOU);\n\t(void) sigprocmask(SIG_BLOCK, &mask, NULL);\n    }\n#endif\n\n     \n    NCURSES_SP_NAME(endwin) (NCURSES_SP_ARG);\n\n     \n    (void) sigemptyset(&mask);\n    (void) sigaddset(&mask, SIGTSTP);\n#ifdef SIGTTOU\n    if (!sigttou_blocked) {\n\t \n\t(void) sigaddset(&mask, SIGTTOU);\n    }\n#endif\n    (void) sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\n     \n    act.sa_handler = SIG_DFL;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n#ifdef SA_RESTART\n    act.sa_flags |= SA_RESTART;\n#endif  \n    sigaction(SIGTSTP, &act, &oact);\n    kill(getpid(), SIGTSTP);\n\n     \n\n    T((\"SIGCONT received\"));\n    sigaction(SIGTSTP, &oact, NULL);\n    NCURSES_SP_NAME(flushinp) (NCURSES_SP_ARG);\n\n     \n    NCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_ARG);\n\n     \n    NCURSES_SP_NAME(doupdate) (NCURSES_SP_ARG);\n\n     \n    (void) sigprocmask(SIG_SETMASK, &omask, NULL);\n}\n#endif  \n\nstatic void\nhandle_SIGINT(int sig)\n{\n    SCREEN *sp = CURRENT_SCREEN;\n\n     \n    if (!_nc_globals.cleanup_nested++\n\t&& (sig == SIGINT || sig == SIGTERM)) {\n#if HAVE_SIGACTION || HAVE_SIGVEC\n\tsigaction_t act;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\tact.sa_handler = SIG_IGN;\n\tif (sigaction(sig, &act, NULL) == 0)\n#else\n\tif (signal(sig, SIG_IGN) != SIG_ERR)\n#endif\n\t{\n\t    SCREEN *scan;\n\t    for (each_screen(scan)) {\n\t\tif (scan->_ofp != 0\n\t\t    && NC_ISATTY(fileno(scan->_ofp))) {\n\t\t    scan->_outch = NCURSES_SP_NAME(_nc_outch);\n\t\t}\n\t\tset_term(scan);\n\t\tNCURSES_SP_NAME(endwin) (NCURSES_SP_ARG);\n\t\tif (sp)\n\t\t    sp->_endwin = ewInitial;\t \n\t    }\n\t}\n    }\n    _exit(EXIT_FAILURE);\n}\n\n# ifndef _nc_set_read_thread\nNCURSES_EXPORT(void)\n_nc_set_read_thread(bool enable)\n{\n    _nc_lock_global(curses);\n    if (enable) {\n#  if USE_WEAK_SYMBOLS\n\tif ((pthread_self) && (pthread_kill) && (pthread_equal))\n#  endif\n\t    _nc_globals.read_thread = pthread_self();\n    } else {\n\t_nc_globals.read_thread = 0;\n    }\n    _nc_unlock_global(curses);\n}\n# endif\n\n#if USE_SIGWINCH\n\nstatic void\nhandle_SIGWINCH(int sig GCC_UNUSED)\n{\n    _nc_globals.have_sigwinch = 1;\n# if USE_PTHREADS_EINTR\n    if (_nc_globals.read_thread) {\n\tif (!pthread_equal(pthread_self(), _nc_globals.read_thread))\n\t    pthread_kill(_nc_globals.read_thread, SIGWINCH);\n\t_nc_globals.read_thread = 0;\n    }\n# endif\n}\n#endif  \n\n \nstatic int\nCatchIfDefault(int sig, void (*handler) (int))\n{\n    int result;\n#if HAVE_SIGACTION || HAVE_SIGVEC\n    sigaction_t old_act;\n    sigaction_t new_act;\n\n    memset(&new_act, 0, sizeof(new_act));\n    sigemptyset(&new_act.sa_mask);\n#ifdef SA_RESTART\n#ifdef SIGWINCH\n    if (sig != SIGWINCH)\n#endif\n\tnew_act.sa_flags |= SA_RESTART;\n#endif  \n    new_act.sa_handler = handler;\n\n    if (sigaction(sig, NULL, &old_act) == 0\n\t&& (old_act.sa_handler == SIG_DFL\n\t    || old_act.sa_handler == handler\n#if USE_SIGWINCH\n\t    || (sig == SIGWINCH && old_act.sa_handler == SIG_IGN)\n#endif\n\t)) {\n\t(void) sigaction(sig, &new_act, NULL);\n\tresult = TRUE;\n    } else {\n\tresult = FALSE;\n    }\n#else  \n    void (*ohandler) (int);\n\n    ohandler = signal(sig, SIG_IGN);\n    if (ohandler == SIG_DFL\n\t|| ohandler == handler\n#if USE_SIGWINCH\n\t|| (sig == SIGWINCH && ohandler == SIG_IGN)\n#endif\n\t) {\n\tsignal(sig, handler);\n\tresult = TRUE;\n    } else {\n\tsignal(sig, ohandler);\n\tresult = FALSE;\n    }\n#endif\n    T((\"CatchIfDefault - will %scatch %s\",\n       result ? \"\" : \"not \", signal_name(sig)));\n    return result;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_signal_handler(int enable)\n{\n    T((T_CALLED(\"_nc_signal_handler(%d)\"), enable));\n#if USE_SIGTSTP\t\t\t \n    {\n\tstatic bool ignore_tstp = FALSE;\n\n\tif (!ignore_tstp) {\n\t    static sigaction_t new_sigaction, old_sigaction;\n\n\t    if (!enable) {\n\t\tnew_sigaction.sa_handler = SIG_IGN;\n\t\tsigaction(SIGTSTP, &new_sigaction, &old_sigaction);\n\t    } else if (new_sigaction.sa_handler != SIG_DFL) {\n\t\tsigaction(SIGTSTP, &old_sigaction, NULL);\n\t    } else if (sigaction(SIGTSTP, NULL, &old_sigaction) == 0\n\t\t       && (old_sigaction.sa_handler == SIG_DFL)) {\n\t\tsigemptyset(&new_sigaction.sa_mask);\n#ifdef SA_RESTART\n\t\tnew_sigaction.sa_flags |= SA_RESTART;\n#endif  \n\t\tnew_sigaction.sa_handler = handle_SIGTSTP;\n\t\t(void) sigaction(SIGTSTP, &new_sigaction, NULL);\n\t    } else {\n\t\tignore_tstp = TRUE;\n\t    }\n\t}\n    }\n#endif  \n\n    if (!_nc_globals.init_signals) {\n\tif (enable) {\n\t    CatchIfDefault(SIGINT, handle_SIGINT);\n\t    CatchIfDefault(SIGTERM, handle_SIGINT);\n#if USE_SIGWINCH\n\t    CatchIfDefault(SIGWINCH, handle_SIGWINCH);\n#endif\n\t    _nc_globals.init_signals = TRUE;\n\t}\n    }\n    returnVoid;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}