{
  "module_name": "tty_update.c",
  "hash_id": "8517df9aade761fa5b8266fef4e3f2615a639f95f2808811c500155b5c8a9a74",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tty/tty_update.c",
  "human_readable_source": " \n\n \n\n \n\n#define NEW_PAIR_INTERNAL 1\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\n#if defined __HAIKU__ && defined __BEOS__\n#undef __BEOS__\n#endif\n\n#ifdef __BEOS__\n#undef false\n#undef true\n#include <OS.h>\n#endif\n\n#if defined(TRACE) && HAVE_SYS_TIMES_H && HAVE_TIMES\n#define USE_TRACE_TIMES 1\n#else\n#define USE_TRACE_TIMES 0\n#endif\n\n#if HAVE_SYS_TIME_H && HAVE_SYS_TIME_SELECT\n#include <sys/time.h>\n#endif\n\n#if USE_TRACE_TIMES\n#include <sys/times.h>\n#endif\n\n#if USE_FUNC_POLL\n#elif HAVE_SELECT\n#if HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#endif\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: tty_update.c,v 1.314 2022/07/23 22:12:59 tom Exp $\")\n\n \n#define CHECK_INTERVAL\t5\n\n#define FILL_BCE(sp) (sp->_coloron && !sp->_default_color && !back_color_erase)\n\nstatic const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);\nstatic NCURSES_CH_T normal = NewChar(BLANK_TEXT);\n\n \n \n\nstatic NCURSES_INLINE NCURSES_CH_T ClrBlank(NCURSES_SP_DCLx WINDOW *win);\n\n#if NCURSES_SP_FUNCS\nstatic int ClrBottom(SCREEN *, int total);\nstatic void ClearScreen(SCREEN *, NCURSES_CH_T blank);\nstatic void ClrUpdate(SCREEN *);\nstatic void DelChar(SCREEN *, int count);\nstatic void InsStr(SCREEN *, NCURSES_CH_T *line, int count);\nstatic void TransformLine(SCREEN *, int const lineno);\n#else\nstatic int ClrBottom(int total);\nstatic void ClearScreen(NCURSES_CH_T blank);\nstatic void ClrUpdate(void);\nstatic void DelChar(int count);\nstatic void InsStr(NCURSES_CH_T *line, int count);\nstatic void TransformLine(int const lineno);\n#endif\n\n#ifdef POSITION_DEBUG\n \n\nstatic void\nposition_check(NCURSES_SP_DCLx int expected_y, int expected_x, const char *legend)\n \n{\n    char buf[20];\n    char *s;\n    int y, x;\n\n    if (!_nc_tracing || (expected_y < 0 && expected_x < 0))\n\treturn;\n\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    memset(buf, '\\0', sizeof(buf));\n    NCURSES_PUTP2_FLUSH(\"cpr\", \"\\033[6n\");\t \n    *(s = buf) = 0;\n    do {\n\tint ask = sizeof(buf) - 1 - (s - buf);\n\tint got = read(0, s, ask);\n\tif (got == 0)\n\t    break;\n\ts += got;\n    } while (strchr(buf, 'R') == 0);\n    _tracef(\"probe returned %s\", _nc_visbuf(buf));\n\n     \n    if (sscanf(buf, \"\\033[%d;%dR\", &y, &x) != 2) {\n\t_tracef(\"position probe failed in %s\", legend);\n    } else {\n\tif (expected_x < 0)\n\t    expected_x = x - 1;\n\tif (expected_y < 0)\n\t    expected_y = y - 1;\n\tif (y - 1 != expected_y || x - 1 != expected_x) {\n\t    NCURSES_SP_NAME(beep) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TIPARM_2(\"\\033[%d;%dH\",\n\t\t\t\t\t     expected_y + 1,\n\t\t\t\t\t     expected_x + 1),\n\t\t\t\t    1, NCURSES_SP_NAME(_nc_outch));\n\t    _tracef(\"position seen (%d, %d) doesn't match expected one (%d, %d) in %s\",\n\t\t    y - 1, x - 1, expected_y, expected_x, legend);\n\t} else {\n\t    _tracef(\"position matches OK in %s\", legend);\n\t}\n    }\n}\n#else\n#define position_check(expected_y, expected_x, legend)\t \n#endif  \n\n \n\nstatic NCURSES_INLINE void\nGoTo(NCURSES_SP_DCLx int const row, int const col)\n{\n    TR(TRACE_MOVE, (\"GoTo(%p, %d, %d) from (%d, %d)\",\n\t\t    (void *) SP_PARM, row, col, SP_PARM->_cursrow, SP_PARM->_curscol));\n\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"GoTo\");\n\n    TINFO_MVCUR(NCURSES_SP_ARGx\n\t\tSP_PARM->_cursrow,\n\t\tSP_PARM->_curscol,\n\t\trow, col);\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"GoTo2\");\n}\n\n#if !NCURSES_WCWIDTH_GRAPHICS\n#define is_wacs_value(ch) (_nc_wacs_width(ch) == 1 && wcwidth(ch) > 1)\n#endif  \n\nstatic NCURSES_INLINE void\nPutAttrChar(NCURSES_SP_DCLx CARG_CH_T ch)\n{\n    int chlen = 1;\n    NCURSES_CH_T my_ch;\n#if USE_WIDEC_SUPPORT\n    PUTC_DATA;\n#endif\n    NCURSES_CH_T tilde;\n    NCURSES_CH_T attr = CHDEREF(ch);\n\n    TR(TRACE_CHARPUT, (\"PutAttrChar(%s) at (%d, %d)\",\n\t\t       _tracech_t(ch),\n\t\t       SP_PARM->_cursrow, SP_PARM->_curscol));\n#if USE_WIDEC_SUPPORT\n     \n    if (isWidecExt(CHDEREF(ch))) {\n\tTR(TRACE_CHARPUT, (\"...skip\"));\n\treturn;\n    }\n     \n    if ((chlen = _nc_wacs_width(CharOf(CHDEREF(ch)))) <= 0) {\n\tstatic const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n\n\t \n\tif (is8bits(CharOf(CHDEREF(ch)))\n\t    && (isprint(CharOf(CHDEREF(ch)))\n\t\t|| (SP_PARM->_legacy_coding > 0 && CharOf(CHDEREF(ch)) >= 160)\n\t\t|| (SP_PARM->_legacy_coding > 1 && CharOf(CHDEREF(ch)) >= 128)\n\t\t|| (AttrOf(attr) & A_ALTCHARSET\n\t\t    && ((CharOfD(ch) < ACS_LEN\n\t\t\t && SP_PARM->_acs_map != 0\n\t\t\t && SP_PARM->_acs_map[CharOfD(ch)] != 0)\n\t\t\t|| (CharOfD(ch) >= 128))))) {\n\t    ;\n\t} else {\n\t    ch = CHREF(blank);\n\t    TR(TRACE_CHARPUT, (\"forced to blank\"));\n\t}\n\tchlen = 1;\n    }\n#endif\n\n    if ((AttrOf(attr) & A_ALTCHARSET)\n\t&& SP_PARM->_acs_map != 0\n\t&& ((CharOfD(ch) < ACS_LEN)\n#if !NCURSES_WCWIDTH_GRAPHICS\n\t    || is_wacs_value(CharOfD(ch))\n#endif\n\t)) {\n\tint c8;\n\tmy_ch = CHDEREF(ch);\t \n\tc8 = CharOf(my_ch);\n#if USE_WIDEC_SUPPORT\n\t \n\tif (SP_PARM->_screen_unicode\n\t    && _nc_wacs[CharOf(my_ch)].chars[0]) {\n\t    if (SP_PARM->_screen_acs_map[CharOf(my_ch)]) {\n\t\tif (SP_PARM->_screen_acs_fix) {\n\t\t    RemAttr(attr, A_ALTCHARSET);\n\t\t    my_ch = _nc_wacs[CharOf(my_ch)];\n\t\t}\n\t    } else {\n\t\tRemAttr(attr, A_ALTCHARSET);\n\t\tmy_ch = _nc_wacs[CharOf(my_ch)];\n\t    }\n#if !NCURSES_WCWIDTH_GRAPHICS\n\t    if (!(AttrOf(attr) & A_ALTCHARSET)) {\n\t\tchlen = 1;\n\t    }\n#endif  \n\t} else\n#endif\n\tif (!SP_PARM->_screen_acs_map[c8]) {\n\t     \n\t    chtype temp = UChar(SP_PARM->_acs_map[c8]);\n\t    if (temp) {\n\t\tRemAttr(attr, A_ALTCHARSET);\n\t\tSetChar(my_ch, temp, AttrOf(attr));\n\t    }\n\t}\n\n\t \n\tif (AttrOf(attr) & A_ALTCHARSET) {\n\t    int j = CharOfD(ch);\n\t    chtype temp = UChar(SP_PARM->_acs_map[j]);\n\n\t    if (temp != 0) {\n\t\tSetChar(my_ch, temp, AttrOf(attr));\n\t    } else {\n\t\tmy_ch = CHDEREF(ch);\n\t\tRemAttr(attr, A_ALTCHARSET);\n\t    }\n\t}\n\tch = CHREF(my_ch);\n    }\n#if USE_WIDEC_SUPPORT && !NCURSES_WCWIDTH_GRAPHICS\n    else if (chlen > 1 && is_wacs_value(CharOfD(ch))) {\n\tchlen = 1;\n    }\n#endif\n    if (tilde_glitch && (CharOfD(ch) == L('~'))) {\n\tSetChar(tilde, L('`'), AttrOf(attr));\n\tch = CHREF(tilde);\n    }\n\n    UpdateAttrs(SP_PARM, attr);\n    PUTC(CHDEREF(ch));\n#if !USE_WIDEC_SUPPORT\n    COUNT_OUTCHARS(1);\n#endif\n    SP_PARM->_curscol += chlen;\n    if (char_padding) {\n\tNCURSES_PUTP2(\"char_padding\", char_padding);\n    }\n}\n\nstatic bool\ncheck_pending(NCURSES_SP_DCL0)\n \n{\n    bool have_pending = FALSE;\n\n     \n    if (SP_PARM->_fifohold != 0)\n\treturn FALSE;\n\n    if (SP_PARM->_checkfd >= 0) {\n#if USE_FUNC_POLL\n\tstruct pollfd fds[1];\n\tfds[0].fd = SP_PARM->_checkfd;\n\tfds[0].events = POLLIN;\n\tif (poll(fds, (size_t) 1, 0) > 0) {\n\t    have_pending = TRUE;\n\t}\n#elif defined(__BEOS__)\n\t \n\tint n = 0;\n\tint howmany = ioctl(0, 'ichr', &n);\n\tif (howmany >= 0 && n > 0) {\n\t    have_pending = TRUE;\n\t}\n#elif HAVE_SELECT\n\tfd_set fdset;\n\tstruct timeval ktimeout;\n\n\tktimeout.tv_sec =\n\t    ktimeout.tv_usec = 0;\n\n\tFD_ZERO(&fdset);\n\tFD_SET(SP_PARM->_checkfd, &fdset);\n\tif (select(SP_PARM->_checkfd + 1, &fdset, NULL, NULL, &ktimeout) != 0) {\n\t    have_pending = TRUE;\n\t}\n#endif\n    }\n    if (have_pending) {\n\tSP_PARM->_fifohold = 5;\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    }\n    return FALSE;\n}\n\n \nstatic void\nPutCharLR(NCURSES_SP_DCLx const ARG_CH_T ch)\n{\n    if (!auto_right_margin) {\n\t \n\tPutAttrChar(NCURSES_SP_ARGx ch);\n    } else if (enter_am_mode && exit_am_mode) {\n\tint oldcol = SP_PARM->_curscol;\n\t \n\tNCURSES_PUTP2(\"exit_am_mode\", exit_am_mode);\n\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n\tSP_PARM->_curscol = oldcol;\n\tposition_check(NCURSES_SP_ARGx\n\t\t       SP_PARM->_cursrow,\n\t\t       SP_PARM->_curscol,\n\t\t       \"exit_am_mode\");\n\n\tNCURSES_PUTP2(\"enter_am_mode\", enter_am_mode);\n    } else if ((enter_insert_mode && exit_insert_mode)\n\t       || insert_character || parm_ich) {\n\tGoTo(NCURSES_SP_ARGx\n\t     screen_lines(SP_PARM) - 1,\n\t     screen_columns(SP_PARM) - 2);\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n\tGoTo(NCURSES_SP_ARGx\n\t     screen_lines(SP_PARM) - 1,\n\t     screen_columns(SP_PARM) - 2);\n\tInsStr(NCURSES_SP_ARGx\n\t       NewScreen(SP_PARM)->_line[screen_lines(SP_PARM) - 1].text +\n\t       screen_columns(SP_PARM) - 2, 1);\n    }\n}\n\n \nstatic void\nwrap_cursor(NCURSES_SP_DCL0)\n{\n    if (eat_newline_glitch) {\n\t \n\tSP_PARM->_curscol = -1;\n\tSP_PARM->_cursrow = -1;\n    } else if (auto_right_margin) {\n\tSP_PARM->_curscol = 0;\n\tSP_PARM->_cursrow++;\n\t \n\tif (!move_standout_mode && AttrOf(SCREEN_ATTRS(SP_PARM))) {\n\t    TR(TRACE_CHARPUT, (\"turning off (%#lx) %s before wrapping\",\n\t\t\t       (unsigned long) AttrOf(SCREEN_ATTRS(SP_PARM)),\n\t\t\t       _traceattr(AttrOf(SCREEN_ATTRS(SP_PARM)))));\n\t    VIDPUTS(SP_PARM, A_NORMAL, 0);\n\t}\n    } else {\n\tSP_PARM->_curscol--;\n    }\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol,\n\t\t   \"wrap_cursor\");\n}\n\nstatic NCURSES_INLINE void\nPutChar(NCURSES_SP_DCLx const ARG_CH_T ch)\n \n{\n    if (SP_PARM->_cursrow == screen_lines(SP_PARM) - 1 &&\n\tSP_PARM->_curscol == screen_columns(SP_PARM) - 1) {\n\tPutCharLR(NCURSES_SP_ARGx ch);\n    } else {\n\tPutAttrChar(NCURSES_SP_ARGx ch);\n    }\n\n    if (SP_PARM->_curscol >= screen_columns(SP_PARM))\n\twrap_cursor(NCURSES_SP_ARG);\n\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"PutChar\");\n}\n\n \nstatic NCURSES_INLINE bool\ncan_clear_with(NCURSES_SP_DCLx ARG_CH_T ch)\n{\n    if (!back_color_erase && SP_PARM->_coloron) {\n#if NCURSES_EXT_FUNCS\n\tint pair;\n\n\tif (!SP_PARM->_default_color)\n\t    return FALSE;\n\tif (!(isDefaultColor(SP_PARM->_default_fg) &&\n\t      isDefaultColor(SP_PARM->_default_bg)))\n\t    return FALSE;\n\tif ((pair = GetPair(CHDEREF(ch))) != 0) {\n\t    NCURSES_COLOR_T fg, bg;\n\t    if (NCURSES_SP_NAME(pair_content) (NCURSES_SP_ARGx\n\t\t\t\t\t       (short) pair,\n\t\t\t\t\t       &fg, &bg) == ERR\n\t\t|| !(isDefaultColor(fg) && isDefaultColor(bg))) {\n\t\treturn FALSE;\n\t    }\n\t}\n#else\n\tif (AttrOfD(ch) & A_COLOR)\n\t    return FALSE;\n#endif\n    }\n    return (ISBLANK(CHDEREF(ch)) &&\n\t    (AttrOfD(ch) & ~(NONBLANK_ATTR | A_COLOR)) == BLANK_ATTR);\n}\n\n \nstatic int\nEmitRange(NCURSES_SP_DCLx const NCURSES_CH_T *ntext, int num)\n{\n    int i;\n\n    TR(TRACE_CHARPUT, (\"EmitRange %d:%s\", num, _nc_viscbuf(ntext, num)));\n\n    if (erase_chars || repeat_char) {\n\twhile (num > 0) {\n\t    int runcount;\n\t    NCURSES_CH_T ntext0;\n\n\t    while (num > 1 && !CharEq(ntext[0], ntext[1])) {\n\t\tPutChar(NCURSES_SP_ARGx CHREF(ntext[0]));\n\t\tntext++;\n\t\tnum--;\n\t    }\n\t    ntext0 = ntext[0];\n\t    if (num == 1) {\n\t\tPutChar(NCURSES_SP_ARGx CHREF(ntext0));\n\t\treturn 0;\n\t    }\n\t    runcount = 2;\n\n\t    while (runcount < num && CharEq(ntext[runcount], ntext0))\n\t\truncount++;\n\n\t     \n\t    if (erase_chars\n\t\t&& runcount > SP_PARM->_ech_cost + SP_PARM->_cup_ch_cost\n\t\t&& can_clear_with(NCURSES_SP_ARGx CHREF(ntext0))) {\n\t\tUpdateAttrs(SP_PARM, ntext0);\n\t\tNCURSES_PUTP2(\"erase_chars\", TIPARM_1(erase_chars, runcount));\n\n\t\t \n\t\tif (runcount < num) {\n\t\t    GoTo(NCURSES_SP_ARGx\n\t\t\t SP_PARM->_cursrow,\n\t\t\t SP_PARM->_curscol + runcount);\n\t\t} else {\n\t\t    return 1;\t \n\t\t}\n\t    } else if (repeat_char != 0 &&\n#if BSD_TPUTS\n\t\t       !isdigit(UChar(CharOf(ntext0))) &&\n#endif\n#if USE_WIDEC_SUPPORT\n\t\t       (!SP_PARM->_screen_unicode &&\n\t\t\t(CharOf(ntext0) < ((AttrOf(ntext0) & A_ALTCHARSET)\n\t\t\t\t\t   ? ACS_LEN\n\t\t\t\t\t   : 256))) &&\n#endif\n\t\t       runcount > SP_PARM->_rep_cost) {\n\t\tNCURSES_CH_T temp;\n\t\tbool wrap_possible = (SP_PARM->_curscol + runcount >=\n\t\t\t\t      screen_columns(SP_PARM));\n\t\tint rep_count = runcount;\n\n\t\tif (wrap_possible)\n\t\t    rep_count--;\n\n\t\tUpdateAttrs(SP_PARM, ntext0);\n\t\ttemp = ntext0;\n\t\tif ((AttrOf(temp) & A_ALTCHARSET) &&\n\t\t    SP_PARM->_acs_map != 0 &&\n\t\t    (SP_PARM->_acs_map[CharOf(temp)] & A_CHARTEXT) != 0) {\n\t\t    SetChar(temp,\n\t\t\t    (SP_PARM->_acs_map[CharOf(ntext0)] & A_CHARTEXT),\n\t\t\t    AttrOf(ntext0) | A_ALTCHARSET);\n\t\t}\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t\tTIPARM_2(repeat_char,\n\t\t\t\t\t\t CharOf(temp),\n\t\t\t\t\t\t rep_count),\n\t\t\t\t\t1,\n\t\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\t\tSP_PARM->_curscol += rep_count;\n\n\t\tif (wrap_possible)\n\t\t    PutChar(NCURSES_SP_ARGx CHREF(ntext0));\n\t    } else {\n\t\tfor (i = 0; i < runcount; i++)\n\t\t    PutChar(NCURSES_SP_ARGx CHREF(ntext[i]));\n\t    }\n\t    ntext += runcount;\n\t    num -= runcount;\n\t}\n\treturn 0;\n    }\n\n    for (i = 0; i < num; i++)\n\tPutChar(NCURSES_SP_ARGx CHREF(ntext[i]));\n    return 0;\n}\n\n \nstatic int\nPutRange(NCURSES_SP_DCLx\n\t const NCURSES_CH_T *otext,\n\t const NCURSES_CH_T *ntext,\n\t int row,\n\t int first, int last)\n{\n    int rc;\n\n    TR(TRACE_CHARPUT, (\"PutRange(%p, %p, %p, %d, %d, %d)\",\n\t\t       (void *) SP_PARM,\n\t\t       (const void *) otext,\n\t\t       (const void *) ntext,\n\t\t       row, first, last));\n\n    if (otext != ntext\n\t&& (last - first + 1) > SP_PARM->_inline_cost) {\n\tint i, j, same;\n\n\tfor (j = first, same = 0; j <= last; j++) {\n\t    if (!same && isWidecExt(otext[j]))\n\t\tcontinue;\n\t    if (CharEq(otext[j], ntext[j])) {\n\t\tsame++;\n\t    } else {\n\t\tif (same > SP_PARM->_inline_cost) {\n\t\t    EmitRange(NCURSES_SP_ARGx ntext + first, j - same - first);\n\t\t    GoTo(NCURSES_SP_ARGx row, first = j);\n\t\t}\n\t\tsame = 0;\n\t    }\n\t}\n\ti = EmitRange(NCURSES_SP_ARGx ntext + first, j - same - first);\n\t \n\trc = (same == 0 ? i : 1);\n    } else {\n\trc = EmitRange(NCURSES_SP_ARGx ntext + first, last - first + 1);\n    }\n    return rc;\n}\n\n \n#define MARK_NOCHANGE(win,row) \\\n\t\twin->_line[row].firstchar = _NOCHANGE; \\\n\t\twin->_line[row].lastchar = _NOCHANGE; \\\n\t\tif_USE_SCROLL_HINTS(win->_line[row].oldindex = row)\n\nNCURSES_EXPORT(int)\nTINFO_DOUPDATE(NCURSES_SP_DCL0)\n{\n    int i;\n    int nonempty;\n#if USE_TRACE_TIMES\n    struct tms before, after;\n#endif  \n\n    T((T_CALLED(\"_nc_tinfo:doupdate(%p)\"), (void *) SP_PARM));\n\n    _nc_lock_global(update);\n\n    if (SP_PARM == 0) {\n\t_nc_unlock_global(update);\n\treturnCode(ERR);\n    }\n#if !USE_REENTRANT\n     \n#if NCURSES_SP_FUNCS\n    if (SP_PARM == CURRENT_SCREEN) {\n#endif\n#define SyncScreens(internal,exported) \\\n\tif (internal == 0) internal = exported; \\\n\tif (internal != exported) exported = internal\n\n\tSyncScreens(CurScreen(SP_PARM), curscr);\n\tSyncScreens(NewScreen(SP_PARM), newscr);\n\tSyncScreens(StdScreen(SP_PARM), stdscr);\n#if NCURSES_SP_FUNCS\n    }\n#endif\n#endif  \n\n    if (CurScreen(SP_PARM) == 0\n\t|| NewScreen(SP_PARM) == 0\n\t|| StdScreen(SP_PARM) == 0) {\n\t_nc_unlock_global(update);\n\treturnCode(ERR);\n    }\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\tif (CurScreen(SP_PARM)->_clear)\n\t    _tracef(\"curscr is clear\");\n\telse\n\t    _tracedump(\"curscr\", CurScreen(SP_PARM));\n\t_tracedump(\"newscr\", NewScreen(SP_PARM));\n\t_nc_unlock_global(tracef);\n    }\n#endif  \n\n    _nc_signal_handler(FALSE);\n\n    if (SP_PARM->_fifohold)\n\tSP_PARM->_fifohold--;\n\n#if USE_SIZECHANGE\n    if ((SP_PARM->_endwin == ewSuspend)\n\t|| _nc_handle_sigwinch(SP_PARM)) {\n\t \n\t_nc_update_screensize(SP_PARM);\n    }\n#endif\n\n    if (SP_PARM->_endwin == ewSuspend) {\n\n\tT((\"coming back from shell mode\"));\n\tNCURSES_SP_NAME(reset_prog_mode) (NCURSES_SP_ARG);\n\n\tNCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_ARG);\n\tNCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_ARG);\n\tSP_PARM->_mouse_resume(SP_PARM);\n\n\tSP_PARM->_endwin = ewRunning;\n    }\n#if USE_TRACE_TIMES\n     \n    RESET_OUTCHARS();\n    (void) times(&before);\n#endif  \n\n     \n#if USE_XMC_SUPPORT\n    if (magic_cookie_glitch > 0) {\n\tint j, k;\n\tattr_t rattr = A_NORMAL;\n\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    for (j = 0; j < screen_columns(SP_PARM); j++) {\n\t\tbool failed = FALSE;\n\t\tNCURSES_CH_T *thisline = NewScreen(SP_PARM)->_line[i].text;\n\t\tattr_t thisattr = AttrOf(thisline[j]) & SP_PARM->_xmc_triggers;\n\t\tattr_t turnon = thisattr & ~rattr;\n\n\t\t \n\t\tif (turnon == 0) {\n\t\t    rattr = thisattr;\n\t\t    continue;\n\t\t}\n\n\t\tTR(TRACE_ATTRS, (\"At (%d, %d): from %s...\", i, j, _traceattr(rattr)));\n\t\tTR(TRACE_ATTRS, (\"...to %s\", _traceattr(turnon)));\n\n\t\t \n#define SAFE(scr,a)\t(!((a) & (scr)->_xmc_triggers))\n\t\tif (ISBLANK(thisline[j]) && SAFE(SP_PARM, turnon)) {\n\t\t    RemAttr(thisline[j], turnon);\n\t\t    continue;\n\t\t}\n\n\t\t \n\t\tfor (k = 1; k <= magic_cookie_glitch; k++) {\n\t\t    if (j - k < 0\n\t\t\t|| !ISBLANK(thisline[j - k])\n\t\t\t|| !SAFE(SP_PARM, AttrOf(thisline[j - k]))) {\n\t\t\tfailed = TRUE;\n\t\t\tTR(TRACE_ATTRS, (\"No room at start in %d,%d%s%s\",\n\t\t\t\t\t i, j - k,\n\t\t\t\t\t (ISBLANK(thisline[j - k])\n\t\t\t\t\t  ? \"\"\n\t\t\t\t\t  : \":nonblank\"),\n\t\t\t\t\t (SAFE(SP_PARM, AttrOf(thisline[j - k]))\n\t\t\t\t\t  ? \"\"\n\t\t\t\t\t  : \":unsafe\")));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!failed) {\n\t\t    bool end_onscreen = FALSE;\n\t\t    int m, n = j;\n\n\t\t     \n\t\t    for (m = i; m < screen_lines(SP_PARM); m++) {\n\t\t\tfor (; n < screen_columns(SP_PARM); n++) {\n\t\t\t    attr_t testattr =\n\t\t\t    AttrOf(NewScreen(SP_PARM)->_line[m].text[n]);\n\t\t\t    if ((testattr & SP_PARM->_xmc_triggers) == rattr) {\n\t\t\t\tend_onscreen = TRUE;\n\t\t\t\tTR(TRACE_ATTRS,\n\t\t\t\t   (\"Range attributed with %s ends at (%d, %d)\",\n\t\t\t\t    _traceattr(turnon), m, n));\n\t\t\t\tgoto foundit;\n\t\t\t    }\n\t\t\t}\n\t\t\tn = 0;\n\t\t    }\n\t\t    TR(TRACE_ATTRS,\n\t\t       (\"Range attributed with %s ends offscreen\",\n\t\t\t_traceattr(turnon)));\n\t\t  foundit:;\n\n\t\t    if (end_onscreen) {\n\t\t\tNCURSES_CH_T *lastline =\n\t\t\tNewScreen(SP_PARM)->_line[m].text;\n\n\t\t\t \n\t\t\twhile (n >= 0\n\t\t\t       && ISBLANK(lastline[n])\n\t\t\t       && SAFE(SP_PARM, AttrOf(lastline[n]))) {\n\t\t\t    RemAttr(lastline[n--], turnon);\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (k = 1; k <= magic_cookie_glitch; k++) {\n\t\t\t    if (n + k >= screen_columns(SP_PARM)\n\t\t\t\t|| !ISBLANK(lastline[n + k])\n\t\t\t\t|| !SAFE(SP_PARM, AttrOf(lastline[n + k]))) {\n\t\t\t\tfailed = TRUE;\n\t\t\t\tTR(TRACE_ATTRS,\n\t\t\t\t   (\"No room at end in %d,%d%s%s\",\n\t\t\t\t    i, j - k,\n\t\t\t\t    (ISBLANK(lastline[n + k])\n\t\t\t\t     ? \"\"\n\t\t\t\t     : \":nonblank\"),\n\t\t\t\t    (SAFE(SP_PARM, AttrOf(lastline[n + k]))\n\t\t\t\t     ? \"\"\n\t\t\t\t     : \":unsafe\")));\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (failed) {\n\t\t    int p, q = j;\n\n\t\t    TR(TRACE_ATTRS,\n\t\t       (\"Clearing %s beginning at (%d, %d)\",\n\t\t\t_traceattr(turnon), i, j));\n\n\t\t     \n\t\t    for (p = i; p < screen_lines(SP_PARM); p++) {\n\t\t\tfor (; q < screen_columns(SP_PARM); q++) {\n\t\t\t    attr_t testattr = AttrOf(newscr->_line[p].text[q]);\n\t\t\t    if ((testattr & SP_PARM->_xmc_triggers) == rattr)\n\t\t\t\tgoto foundend;\n\t\t\t    RemAttr(NewScreen(SP_PARM)->_line[p].text[q], turnon);\n\t\t\t}\n\t\t\tq = 0;\n\t\t    }\n\t\t  foundend:;\n\t\t} else {\n\t\t    TR(TRACE_ATTRS,\n\t\t       (\"Cookie space for %s found before (%d, %d)\",\n\t\t\t_traceattr(turnon), i, j));\n\n\t\t     \n\t\t    for (k = 1; k <= magic_cookie_glitch; k++)\n\t\t\tAddAttr(thisline[j - k], turnon);\n\t\t}\n\n\t\trattr = thisattr;\n\t    }\n\t}\n\n#ifdef TRACE\n\t \n\tif (USE_TRACEF(TRACE_UPDATE)) {\n\t    _tracef(\"After magic-cookie check...\");\n\t    _tracedump(\"newscr\", NewScreen(SP_PARM));\n\t    _nc_unlock_global(tracef);\n\t}\n#endif  \n    }\n#endif  \n\n    nonempty = 0;\n    if (CurScreen(SP_PARM)->_clear || NewScreen(SP_PARM)->_clear) {\t \n\tClrUpdate(NCURSES_SP_ARG);\n\tCurScreen(SP_PARM)->_clear = FALSE;\t \n\tNewScreen(SP_PARM)->_clear = FALSE;\t \n    } else {\n\tint changedlines = CHECK_INTERVAL;\n\n\tif (check_pending(NCURSES_SP_ARG))\n\t    goto cleanup;\n\n\tnonempty = min(screen_lines(SP_PARM), NewScreen(SP_PARM)->_maxy + 1);\n\n\tif (SP_PARM->_scrolling) {\n\t    NCURSES_SP_NAME(_nc_scroll_optimize) (NCURSES_SP_ARG);\n\t}\n\n\tnonempty = ClrBottom(NCURSES_SP_ARGx nonempty);\n\n\tTR(TRACE_UPDATE, (\"Transforming lines, nonempty %d\", nonempty));\n\tfor (i = 0; i < nonempty; i++) {\n\t     \n\t    if (changedlines == CHECK_INTERVAL) {\n\t\tif (check_pending(NCURSES_SP_ARG))\n\t\t    goto cleanup;\n\t\tchangedlines = 0;\n\t    }\n\n\t     \n\t    if (NewScreen(SP_PARM)->_line[i].firstchar != _NOCHANGE\n\t\t|| CurScreen(SP_PARM)->_line[i].firstchar != _NOCHANGE) {\n\t\tTransformLine(NCURSES_SP_ARGx i);\n\t\tchangedlines++;\n\t    }\n\n\t     \n\t    if (i <= NewScreen(SP_PARM)->_maxy) {\n\t\tMARK_NOCHANGE(NewScreen(SP_PARM), i);\n\t    }\n\t    if (i <= CurScreen(SP_PARM)->_maxy) {\n\t\tMARK_NOCHANGE(CurScreen(SP_PARM), i);\n\t    }\n\t}\n    }\n\n     \n    for (i = nonempty; i <= NewScreen(SP_PARM)->_maxy; i++) {\n\tMARK_NOCHANGE(NewScreen(SP_PARM), i);\n    }\n    for (i = nonempty; i <= CurScreen(SP_PARM)->_maxy; i++) {\n\tMARK_NOCHANGE(CurScreen(SP_PARM), i);\n    }\n\n    if (!NewScreen(SP_PARM)->_leaveok) {\n\tCurScreen(SP_PARM)->_curx = NewScreen(SP_PARM)->_curx;\n\tCurScreen(SP_PARM)->_cury = NewScreen(SP_PARM)->_cury;\n\n\tGoTo(NCURSES_SP_ARGx CurScreen(SP_PARM)->_cury, CurScreen(SP_PARM)->_curx);\n    }\n\n  cleanup:\n     \n#if USE_XMC_SUPPORT\n    if (magic_cookie_glitch != 0)\n#endif\n\tUpdateAttrs(SP_PARM, normal);\n\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    WINDOW_ATTRS(CurScreen(SP_PARM)) = WINDOW_ATTRS(NewScreen(SP_PARM));\n\n#if USE_TRACE_TIMES\n    (void) times(&after);\n    TR(TRACE_TIMES,\n       (\"Update cost: %ld chars, %ld clocks system time, %ld clocks user time\",\n\t_nc_outchars,\n\t(long) (after.tms_stime - before.tms_stime),\n\t(long) (after.tms_utime - before.tms_utime)));\n#endif  \n\n    _nc_signal_handler(TRUE);\n\n    _nc_unlock_global(update);\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS && !defined(USE_TERM_DRIVER)\nNCURSES_EXPORT(int)\ndoupdate(void)\n{\n    return TINFO_DOUPDATE(CURRENT_SCREEN);\n}\n#endif\n\n \n#define BCE_ATTRS (A_NORMAL|A_COLOR)\n#define BCE_BKGD(sp,win) (((win) == CurScreen(sp) ? StdScreen(sp) : (win))->_nc_bkgd)\n\nstatic NCURSES_INLINE NCURSES_CH_T\nClrBlank(NCURSES_SP_DCLx WINDOW *win)\n{\n    NCURSES_CH_T blank = blankchar;\n    if (back_color_erase)\n\tAddAttr(blank, (AttrOf(BCE_BKGD(SP_PARM, win)) & BCE_ATTRS));\n    return blank;\n}\n\n \n\nstatic void\nClrUpdate(NCURSES_SP_DCL0)\n{\n    TR(TRACE_UPDATE, (T_CALLED(\"ClrUpdate\")));\n    if (0 != SP_PARM) {\n\tint i;\n\tNCURSES_CH_T blank = ClrBlank(NCURSES_SP_ARGx StdScreen(SP_PARM));\n\tint nonempty = min(screen_lines(SP_PARM),\n\t\t\t   NewScreen(SP_PARM)->_maxy + 1);\n\n\tClearScreen(NCURSES_SP_ARGx blank);\n\n\tTR(TRACE_UPDATE, (\"updating screen from scratch\"));\n\n\tnonempty = ClrBottom(NCURSES_SP_ARGx nonempty);\n\n\tfor (i = 0; i < nonempty; i++)\n\t    TransformLine(NCURSES_SP_ARGx i);\n    }\n    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n}\n\n \n\nstatic void\nClrToEOL(NCURSES_SP_DCLx NCURSES_CH_T blank, int needclear)\n{\n    if (CurScreen(SP_PARM) != 0\n\t&& SP_PARM->_cursrow >= 0) {\n\tint j;\n\n\tfor (j = SP_PARM->_curscol; j < screen_columns(SP_PARM); j++) {\n\t    if (j >= 0) {\n\t\tNCURSES_CH_T *cp =\n\t\t&(CurScreen(SP_PARM)->_line[SP_PARM->_cursrow].text[j]);\n\n\t\tif (!CharEq(*cp, blank)) {\n\t\t    *cp = blank;\n\t\t    needclear = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (needclear) {\n\tUpdateAttrs(SP_PARM, blank);\n\tif (clr_eol && SP_PARM->_el_cost <= (screen_columns(SP_PARM) - SP_PARM->_curscol)) {\n\t    NCURSES_PUTP2(\"clr_eol\", clr_eol);\n\t} else {\n\t    int count = (screen_columns(SP_PARM) - SP_PARM->_curscol);\n\t    while (count-- > 0)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n}\n\n \n\nstatic void\nClrToEOS(NCURSES_SP_DCLx NCURSES_CH_T blank)\n{\n    int row, col;\n\n    row = SP_PARM->_cursrow;\n    col = SP_PARM->_curscol;\n\n    if (row < 0)\n\trow = 0;\n    if (col < 0)\n\tcol = 0;\n\n    UpdateAttrs(SP_PARM, blank);\n    TPUTS_TRACE(\"clr_eos\");\n    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t    clr_eos,\n\t\t\t    screen_lines(SP_PARM) - row,\n\t\t\t    NCURSES_SP_NAME(_nc_outch));\n\n    while (col < screen_columns(SP_PARM))\n\tCurScreen(SP_PARM)->_line[row].text[col++] = blank;\n\n    for (row++; row < screen_lines(SP_PARM); row++) {\n\tfor (col = 0; col < screen_columns(SP_PARM); col++)\n\t    CurScreen(SP_PARM)->_line[row].text[col] = blank;\n    }\n}\n\n \nstatic int\nClrBottom(NCURSES_SP_DCLx int total)\n{\n    int top = total;\n    int last = min(screen_columns(SP_PARM), NewScreen(SP_PARM)->_maxx + 1);\n    NCURSES_CH_T blank = NewScreen(SP_PARM)->_line[total - 1].text[last - 1];\n\n    if (clr_eos && can_clear_with(NCURSES_SP_ARGx CHREF(blank))) {\n\tint row;\n\n\tfor (row = total - 1; row >= 0; row--) {\n\t    int col;\n\t    bool ok;\n\n\t    for (col = 0, ok = TRUE; ok && col < last; col++) {\n\t\tok = (CharEq(NewScreen(SP_PARM)->_line[row].text[col], blank));\n\t    }\n\t    if (!ok)\n\t\tbreak;\n\n\t    for (col = 0; ok && col < last; col++) {\n\t\tok = (CharEq(CurScreen(SP_PARM)->_line[row].text[col], blank));\n\t    }\n\t    if (!ok)\n\t\ttop = row;\n\t}\n\n\t \n\tif (top < total) {\n\t    GoTo(NCURSES_SP_ARGx top, 0);\n\t    ClrToEOS(NCURSES_SP_ARGx blank);\n\t    if (SP_PARM->oldhash && SP_PARM->newhash) {\n\t\tfor (row = top; row < screen_lines(SP_PARM); row++)\n\t\t    SP_PARM->oldhash[row] = SP_PARM->newhash[row];\n\t    }\n\t}\n    }\n    return top;\n}\n\n#if USE_XMC_SUPPORT\n#if USE_WIDEC_SUPPORT\n#define check_xmc_transition(sp, a, b)\t\t\t\t\t\\\n    ((((a)->attr ^ (b)->attr) & ~((a)->attr) & (sp)->_xmc_triggers) != 0)\n#define xmc_turn_on(sp,a,b) check_xmc_transition(sp,&(a), &(b))\n#else\n#define xmc_turn_on(sp,a,b) ((((a)^(b)) & ~(a) & (sp)->_xmc_triggers) != 0)\n#endif\n\n#define xmc_new(sp,r,c) NewScreen(sp)->_line[r].text[c]\n#define xmc_turn_off(sp,a,b) xmc_turn_on(sp,b,a)\n#endif  \n\n \n\nstatic void\nTransformLine(NCURSES_SP_DCLx int const lineno)\n{\n    int firstChar, oLastChar, nLastChar;\n    NCURSES_CH_T *newLine = NewScreen(SP_PARM)->_line[lineno].text;\n    NCURSES_CH_T *oldLine = CurScreen(SP_PARM)->_line[lineno].text;\n    int n;\n    bool attrchanged = FALSE;\n\n    TR(TRACE_UPDATE, (T_CALLED(\"TransformLine(%p, %d)\"), (void *) SP_PARM, lineno));\n\n     \n    if (SP_PARM->oldhash && SP_PARM->newhash)\n\tSP_PARM->oldhash[lineno] = SP_PARM->newhash[lineno];\n\n     \n    if (SP_PARM->_coloron) {\n\tint oldPair;\n\tint newPair;\n\n\tfor (n = 0; n < screen_columns(SP_PARM); n++) {\n\t    if (!CharEq(newLine[n], oldLine[n])) {\n\t\toldPair = GetPair(oldLine[n]);\n\t\tnewPair = GetPair(newLine[n]);\n\t\tif (oldPair != newPair\n\t\t    && unColor(oldLine[n]) == unColor(newLine[n])) {\n\t\t    if (oldPair < SP_PARM->_pair_alloc\n\t\t\t&& newPair < SP_PARM->_pair_alloc\n\t\t\t&& (isSamePair(SP_PARM->_color_pairs[oldPair],\n\t\t\t\t       SP_PARM->_color_pairs[newPair]))) {\n\t\t\tSetPair(oldLine[n], GetPair(newLine[n]));\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (ceol_standout_glitch && clr_eol) {\n\tfirstChar = 0;\n\twhile (firstChar < screen_columns(SP_PARM)) {\n\t    if (!SameAttrOf(newLine[firstChar], oldLine[firstChar])) {\n\t\tattrchanged = TRUE;\n\t\tbreak;\n\t    }\n\t    firstChar++;\n\t}\n    }\n\n    firstChar = 0;\n\n    if (attrchanged) {\t\t \n\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\tClrToEOL(NCURSES_SP_ARGx\n\t\t ClrBlank(NCURSES_SP_ARGx\n\t\t\t  CurScreen(SP_PARM)), FALSE);\n\tPutRange(NCURSES_SP_ARGx\n\t\t oldLine, newLine, lineno, 0,\n\t\t screen_columns(SP_PARM) - 1);\n#if USE_XMC_SUPPORT\n\n\t \n    } else if (magic_cookie_glitch > 0) {\n\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\tfor (n = 0; n < screen_columns(SP_PARM); n++) {\n\t    int m = n + magic_cookie_glitch;\n\n\t     \n\t    if (ISBLANK(newLine[n])\n\t\t&& ((n > 0\n\t\t     && xmc_turn_on(SP_PARM, newLine[n - 1], newLine[n]))\n\t\t    || (n == 0\n\t\t\t&& lineno > 0\n\t\t\t&& xmc_turn_on(SP_PARM,\n\t\t\t\t       xmc_new(SP_PARM, lineno - 1,\n\t\t\t\t\t       screen_columns(SP_PARM) - 1),\n\t\t\t\t       newLine[n])))) {\n\t\tn = m;\n\t    }\n\n\t    PutChar(NCURSES_SP_ARGx CHREF(newLine[n]));\n\n\t     \n\t    if (!ISBLANK(newLine[n])\n\t\t&& ((n + 1 < screen_columns(SP_PARM)\n\t\t     && xmc_turn_off(SP_PARM, newLine[n], newLine[n + 1]))\n\t\t    || (n + 1 >= screen_columns(SP_PARM)\n\t\t\t&& lineno + 1 < screen_lines(SP_PARM)\n\t\t\t&& xmc_turn_off(SP_PARM,\n\t\t\t\t\tnewLine[n],\n\t\t\t\t\txmc_new(SP_PARM, lineno + 1, 0))))) {\n\t\tn = m;\n\t    }\n\n\t}\n#endif\n    } else {\n\tNCURSES_CH_T blank;\n\n\t \n\tblank = newLine[0];\n\tif (clr_bol && can_clear_with(NCURSES_SP_ARGx CHREF(blank))) {\n\t    int oFirstChar, nFirstChar;\n\n\t    for (oFirstChar = 0;\n\t\t oFirstChar < screen_columns(SP_PARM);\n\t\t oFirstChar++)\n\t\tif (!CharEq(oldLine[oFirstChar], blank))\n\t\t    break;\n\t    for (nFirstChar = 0;\n\t\t nFirstChar < screen_columns(SP_PARM);\n\t\t nFirstChar++)\n\t\tif (!CharEq(newLine[nFirstChar], blank))\n\t\t    break;\n\n\t    if (nFirstChar == oFirstChar) {\n\t\tfirstChar = nFirstChar;\n\t\t \n\t\twhile (firstChar < screen_columns(SP_PARM)\n\t\t       && CharEq(newLine[firstChar], oldLine[firstChar]))\n\t\t    firstChar++;\n\t    } else if (oFirstChar > nFirstChar) {\n\t\tfirstChar = nFirstChar;\n\t    } else {\t\t \n\t\tfirstChar = oFirstChar;\n\t\tif (SP_PARM->_el1_cost < nFirstChar - oFirstChar) {\n\t\t    if (nFirstChar >= screen_columns(SP_PARM)\n\t\t\t&& SP_PARM->_el_cost <= SP_PARM->_el1_cost) {\n\t\t\tGoTo(NCURSES_SP_ARGx lineno, 0);\n\t\t\tUpdateAttrs(SP_PARM, blank);\n\t\t\tNCURSES_PUTP2(\"clr_eol\", clr_eol);\n\t\t    } else {\n\t\t\tGoTo(NCURSES_SP_ARGx lineno, nFirstChar - 1);\n\t\t\tUpdateAttrs(SP_PARM, blank);\n\t\t\tNCURSES_PUTP2(\"clr_bol\", clr_bol);\n\t\t    }\n\n\t\t    while (firstChar < nFirstChar)\n\t\t\toldLine[firstChar++] = blank;\n\t\t}\n\t    }\n\t} else {\n\t     \n\t    while (firstChar < screen_columns(SP_PARM)\n\t\t   && CharEq(newLine[firstChar], oldLine[firstChar]))\n\t\tfirstChar++;\n\t}\n\t \n\tif (firstChar >= screen_columns(SP_PARM)) {\n\t    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n\t    return;\n\t}\n\n\tblank = newLine[screen_columns(SP_PARM) - 1];\n\n\tif (!can_clear_with(NCURSES_SP_ARGx CHREF(blank))) {\n\t     \n\t    nLastChar = screen_columns(SP_PARM) - 1;\n\n\t    while (nLastChar > firstChar\n\t\t   && CharEq(newLine[nLastChar], oldLine[nLastChar]))\n\t\tnLastChar--;\n\n\t    if (nLastChar >= firstChar) {\n\t\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t\tPutRange(NCURSES_SP_ARGx\n\t\t\t oldLine,\n\t\t\t newLine,\n\t\t\t lineno,\n\t\t\t firstChar,\n\t\t\t nLastChar);\n\t\tmemcpy(oldLine + firstChar,\n\t\t       newLine + firstChar,\n\t\t       (unsigned) (nLastChar - firstChar + 1) * sizeof(NCURSES_CH_T));\n\t    }\n\t    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n\t    return;\n\t}\n\n\t \n\toLastChar = screen_columns(SP_PARM) - 1;\n\twhile (oLastChar > firstChar && CharEq(oldLine[oLastChar], blank))\n\t    oLastChar--;\n\n\t \n\tnLastChar = screen_columns(SP_PARM) - 1;\n\twhile (nLastChar > firstChar && CharEq(newLine[nLastChar], blank))\n\t    nLastChar--;\n\n\tif ((nLastChar == firstChar)\n\t    && (SP_PARM->_el_cost < (oLastChar - nLastChar))) {\n\t    GoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t    if (!CharEq(newLine[firstChar], blank))\n\t\tPutChar(NCURSES_SP_ARGx CHREF(newLine[firstChar]));\n\t    ClrToEOL(NCURSES_SP_ARGx blank, FALSE);\n\t} else if ((nLastChar != oLastChar)\n\t\t   && (!CharEq(newLine[nLastChar], oldLine[oLastChar])\n\t\t       || !(SP_PARM->_nc_sp_idcok\n\t\t\t    && NCURSES_SP_NAME(has_ic) (NCURSES_SP_ARG)))) {\n\t    GoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t    if ((oLastChar - nLastChar) > SP_PARM->_el_cost) {\n\t\tif (PutRange(NCURSES_SP_ARGx\n\t\t\t     oldLine,\n\t\t\t     newLine,\n\t\t\t     lineno,\n\t\t\t     firstChar,\n\t\t\t     nLastChar)) {\n\t\t    GoTo(NCURSES_SP_ARGx lineno, nLastChar + 1);\n\t\t}\n\t\tClrToEOL(NCURSES_SP_ARGx blank, FALSE);\n\t    } else {\n\t\tn = max(nLastChar, oLastChar);\n\t\tPutRange(NCURSES_SP_ARGx\n\t\t\t oldLine,\n\t\t\t newLine,\n\t\t\t lineno,\n\t\t\t firstChar,\n\t\t\t n);\n\t    }\n\t} else {\n\t    int nLastNonblank = nLastChar;\n\t    int oLastNonblank = oLastChar;\n\n\t     \n\t     \n\t    while (CharEq(newLine[nLastChar], oldLine[oLastChar])) {\n\t\t \n\t\tif (isWidecExt(newLine[nLastChar]) &&\n\t\t    !CharEq(newLine[nLastChar - 1], oldLine[oLastChar - 1]))\n\t\t    break;\n\t\tnLastChar--;\n\t\toLastChar--;\n\t\tif (nLastChar == -1 || oLastChar == -1)\n\t\t    break;\n\t    }\n\n\t    n = min(oLastChar, nLastChar);\n\t    if (n >= firstChar) {\n\t\tGoTo(NCURSES_SP_ARGx lineno, firstChar);\n\t\tPutRange(NCURSES_SP_ARGx\n\t\t\t oldLine,\n\t\t\t newLine,\n\t\t\t lineno,\n\t\t\t firstChar,\n\t\t\t n);\n\t    }\n\n\t    if (oLastChar < nLastChar) {\n\t\tint m = max(nLastNonblank, oLastNonblank);\n#if USE_WIDEC_SUPPORT\n\t\tif (n) {\n\t\t    while (isWidecExt(newLine[n + 1]) && n) {\n\t\t\t--n;\n\t\t\t--oLastChar;\t \n\t\t    }\n\t\t} else if (n >= firstChar &&\n\t\t\t   isWidecBase(newLine[n])) {\n\t\t    while (isWidecExt(newLine[n + 1])) {\n\t\t\t++n;\n\t\t\t++oLastChar;\t \n\t\t    }\n\t\t}\n#endif\n\t\tGoTo(NCURSES_SP_ARGx lineno, n + 1);\n\t\tif ((nLastChar < nLastNonblank)\n\t\t    || InsCharCost(SP_PARM, nLastChar - oLastChar) > (m - n)) {\n\t\t    PutRange(NCURSES_SP_ARGx\n\t\t\t     oldLine,\n\t\t\t     newLine,\n\t\t\t     lineno,\n\t\t\t     n + 1,\n\t\t\t     m);\n\t\t} else {\n\t\t    InsStr(NCURSES_SP_ARGx &newLine[n + 1], nLastChar - oLastChar);\n\t\t}\n\t    } else if (oLastChar > nLastChar) {\n\t\tGoTo(NCURSES_SP_ARGx lineno, n + 1);\n\t\tif (DelCharCost(SP_PARM, oLastChar - nLastChar)\n\t\t    > SP_PARM->_el_cost + nLastNonblank - (n + 1)) {\n\t\t    if (PutRange(NCURSES_SP_ARGx oldLine, newLine, lineno,\n\t\t\t\t n + 1, nLastNonblank)) {\n\t\t\tGoTo(NCURSES_SP_ARGx lineno, nLastNonblank + 1);\n\t\t    }\n\t\t    ClrToEOL(NCURSES_SP_ARGx blank, FALSE);\n\t\t} else {\n\t\t     \n\t\t    UpdateAttrs(SP_PARM, blank);\n\t\t    DelChar(NCURSES_SP_ARGx oLastChar - nLastChar);\n\t\t}\n\t    }\n\t}\n    }\n\n     \n    if (screen_columns(SP_PARM) > firstChar)\n\tmemcpy(oldLine + firstChar,\n\t       newLine + firstChar,\n\t       (unsigned) (screen_columns(SP_PARM) - firstChar) * sizeof(NCURSES_CH_T));\n    TR(TRACE_UPDATE, (T_RETURN(\"\")));\n    return;\n}\n\n \n\nstatic void\nClearScreen(NCURSES_SP_DCLx NCURSES_CH_T blank)\n{\n    int i, j;\n    bool fast_clear = (clear_screen || clr_eos || clr_eol);\n\n    TR(TRACE_UPDATE, (\"ClearScreen() called\"));\n\n#if NCURSES_EXT_FUNCS\n    if (SP_PARM->_coloron\n\t&& !SP_PARM->_default_color) {\n\tNCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_ARGx\n\t\t\t\t       (short) GET_SCREEN_PAIR(SP_PARM),\n\t\t\t\t       0,\n\t\t\t\t       FALSE,\n\t\t\t\t       NCURSES_SP_NAME(_nc_outch));\n\tif (!back_color_erase) {\n\t    fast_clear = FALSE;\n\t}\n    }\n#endif\n\n    if (fast_clear) {\n\tif (clear_screen) {\n\t    UpdateAttrs(SP_PARM, blank);\n\t    NCURSES_PUTP2(\"clear_screen\", clear_screen);\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = 0;\n\t    position_check(NCURSES_SP_ARGx\n\t\t\t   SP_PARM->_cursrow,\n\t\t\t   SP_PARM->_curscol,\n\t\t\t   \"ClearScreen\");\n\t} else if (clr_eos) {\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    GoTo(NCURSES_SP_ARGx 0, 0);\n\t    UpdateAttrs(SP_PARM, blank);\n\t    TPUTS_TRACE(\"clr_eos\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    clr_eos,\n\t\t\t\t    screen_lines(SP_PARM),\n\t\t\t\t    NCURSES_SP_NAME(_nc_outch));\n\t} else if (clr_eol) {\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    UpdateAttrs(SP_PARM, blank);\n\t    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\t\tGoTo(NCURSES_SP_ARGx i, 0);\n\t\tNCURSES_PUTP2(\"clr_eol\", clr_eol);\n\t    }\n\t    GoTo(NCURSES_SP_ARGx 0, 0);\n\t}\n    } else {\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    GoTo(NCURSES_SP_ARGx i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n\tGoTo(NCURSES_SP_ARGx 0, 0);\n    }\n\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tfor (j = 0; j < screen_columns(SP_PARM); j++)\n\t    CurScreen(SP_PARM)->_line[i].text[j] = blank;\n    }\n\n    TR(TRACE_UPDATE, (\"screen cleared\"));\n}\n\n \n\nstatic void\nInsStr(NCURSES_SP_DCLx NCURSES_CH_T *line, int count)\n{\n    TR(TRACE_UPDATE, (\"InsStr(%p, %p,%d) called\",\n\t\t      (void *) SP_PARM,\n\t\t      (void *) line, count));\n\n     \n     \n    if (parm_ich) {\n\tTPUTS_TRACE(\"parm_ich\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_ich, count),\n\t\t\t\t1,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\twhile (count > 0) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    line++;\n\t    count--;\n\t}\n    } else if (enter_insert_mode && exit_insert_mode) {\n\tNCURSES_PUTP2(\"enter_insert_mode\", enter_insert_mode);\n\twhile (count > 0) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tNCURSES_PUTP2(\"insert_padding\", insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n\tNCURSES_PUTP2(\"exit_insert_mode\", exit_insert_mode);\n    } else {\n\twhile (count > 0) {\n\t    NCURSES_PUTP2(\"insert_character\", insert_character);\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tNCURSES_PUTP2(\"insert_padding\", insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n    }\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"InsStr\");\n}\n\n \n\nstatic void\nDelChar(NCURSES_SP_DCLx int count)\n{\n    TR(TRACE_UPDATE, (\"DelChar(%p, %d) called, position = (%ld,%ld)\",\n\t\t      (void *) SP_PARM, count,\n\t\t      (long) NewScreen(SP_PARM)->_cury,\n\t\t      (long) NewScreen(SP_PARM)->_curx));\n\n    if (parm_dch) {\n\tTPUTS_TRACE(\"parm_dch\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_dch, count),\n\t\t\t\t1,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\n\tint n;\n\n\tfor (n = 0; n < count; n++) {\n\t    NCURSES_PUTP2(\"delete_character\", delete_character);\n\t}\n    }\n}\n\n \n\n \nstatic int\nscroll_csr_forward(NCURSES_SP_DCLx\n\t\t   int n,\n\t\t   int top,\n\t\t   int bot,\n\t\t   int miny,\n\t\t   int maxy,\n\t\t   NCURSES_CH_T blank)\n{\n    int i;\n\n    if (n == 1 && scroll_forward && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"scroll_forward\", scroll_forward);\n    } else if (n == 1 && delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"delete_line\", delete_line);\n    } else if (parm_index && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_index\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_index, n),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (parm_delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_delete_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_delete_line, n),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (scroll_forward && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx bot, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"scroll_forward\", scroll_forward);\n\t}\n    } else if (delete_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"delete_line\", delete_line);\n\t}\n    } else\n\treturn ERR;\n\n#if NCURSES_EXT_FUNCS\n    if (FILL_BCE(SP_PARM)) {\n\tint j;\n\tfor (i = 0; i < n; i++) {\n\t    GoTo(NCURSES_SP_ARGx bot - i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n#endif\n    return OK;\n}\n\n \n \nstatic int\nscroll_csr_backward(NCURSES_SP_DCLx\n\t\t    int n,\n\t\t    int top,\n\t\t    int bot,\n\t\t    int miny,\n\t\t    int maxy,\n\t\t    NCURSES_CH_T blank)\n{\n    int i;\n\n    if (n == 1 && scroll_reverse && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"scroll_reverse\", scroll_reverse);\n    } else if (n == 1 && insert_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tNCURSES_PUTP2(\"insert_line\", insert_line);\n    } else if (parm_rindex && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_rindex\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_rindex, n),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (parm_insert_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tTPUTS_TRACE(\"parm_insert_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_insert_line, n),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else if (scroll_reverse && top == miny && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"scroll_reverse\", scroll_reverse);\n\t}\n    } else if (insert_line && bot == maxy) {\n\tGoTo(NCURSES_SP_ARGx top, 0);\n\tUpdateAttrs(SP_PARM, blank);\n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"insert_line\", insert_line);\n\t}\n    } else\n\treturn ERR;\n\n#if NCURSES_EXT_FUNCS\n    if (FILL_BCE(SP_PARM)) {\n\tint j;\n\tfor (i = 0; i < n; i++) {\n\t    GoTo(NCURSES_SP_ARGx top + i, 0);\n\t    for (j = 0; j < screen_columns(SP_PARM); j++)\n\t\tPutChar(NCURSES_SP_ARGx CHREF(blank));\n\t}\n    }\n#endif\n    return OK;\n}\n\n \n \nstatic int\nscroll_idl(NCURSES_SP_DCLx int n, int del, int ins, NCURSES_CH_T blank)\n{\n    int i;\n\n    if (!((parm_delete_line || delete_line) && (parm_insert_line || insert_line)))\n\treturn ERR;\n\n    GoTo(NCURSES_SP_ARGx del, 0);\n    UpdateAttrs(SP_PARM, blank);\n    if (n == 1 && delete_line) {\n\tNCURSES_PUTP2(\"delete_line\", delete_line);\n    } else if (parm_delete_line) {\n\tTPUTS_TRACE(\"parm_delete_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_delete_line, n),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\t\t\t \n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"delete_line\", delete_line);\n\t}\n    }\n\n    GoTo(NCURSES_SP_ARGx ins, 0);\n    UpdateAttrs(SP_PARM, blank);\n    if (n == 1 && insert_line) {\n\tNCURSES_PUTP2(\"insert_line\", insert_line);\n    } else if (parm_insert_line) {\n\tTPUTS_TRACE(\"parm_insert_line\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTIPARM_1(parm_insert_line, n),\n\t\t\t\tn,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n    } else {\t\t\t \n\tfor (i = 0; i < n; i++) {\n\t    NCURSES_PUTP2(\"insert_line\", insert_line);\n\t}\n    }\n\n    return OK;\n}\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_scrolln) (NCURSES_SP_DCLx\n\t\t\t      int n,\n\t\t\t      int top,\n\t\t\t      int bot,\n\t\t\t      int maxy)\n \n{\n    NCURSES_CH_T blank;\n    int i;\n    bool cursor_saved = FALSE;\n    int res;\n\n    TR(TRACE_MOVE, (\"_nc_scrolln(%p, %d, %d, %d, %d)\",\n\t\t    (void *) SP_PARM, n, top, bot, maxy));\n\n    if (!IsValidScreen(SP_PARM))\n\treturn (ERR);\n\n    blank = ClrBlank(NCURSES_SP_ARGx StdScreen(SP_PARM));\n\n#if USE_XMC_SUPPORT\n     \n    if (magic_cookie_glitch > 0) {\n\treturn (ERR);\n    }\n#endif\n\n    if (n > 0) {\t\t \n\t \n\tres = scroll_csr_forward(NCURSES_SP_ARGx n, top, bot, 0, maxy, blank);\n\n\tif (res == ERR && change_scroll_region) {\n\t    if ((((n == 1 && scroll_forward) || parm_index)\n\t\t && (SP_PARM->_cursrow == bot || SP_PARM->_cursrow == bot - 1))\n\t\t&& save_cursor && restore_cursor) {\n\t\tcursor_saved = TRUE;\n\t\tNCURSES_PUTP2(\"save_cursor\", save_cursor);\n\t    }\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TIPARM_2(change_scroll_region, top, bot));\n\t    if (cursor_saved) {\n\t\tNCURSES_PUTP2(\"restore_cursor\", restore_cursor);\n\t    } else {\n\t\tSP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    }\n\n\t    res = scroll_csr_forward(NCURSES_SP_ARGx n, top, bot, top, bot, blank);\n\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TIPARM_2(change_scroll_region, 0, maxy));\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t}\n\n\tif (res == ERR && SP_PARM->_nc_sp_idlok)\n\t    res = scroll_idl(NCURSES_SP_ARGx n, top, bot - n + 1, blank);\n\n\t \n\tif (res != ERR\n\t    && (non_dest_scroll_region || (memory_below && bot == maxy))) {\n\t    static const NCURSES_CH_T blank2 = NewChar(BLANK_TEXT);\n\t    if (bot == maxy && clr_eos) {\n\t\tGoTo(NCURSES_SP_ARGx bot - n + 1, 0);\n\t\tClrToEOS(NCURSES_SP_ARGx blank2);\n\t    } else {\n\t\tfor (i = 0; i < n; i++) {\n\t\t    GoTo(NCURSES_SP_ARGx bot - i, 0);\n\t\t    ClrToEOL(NCURSES_SP_ARGx blank2, FALSE);\n\t\t}\n\t    }\n\t}\n\n    } else {\t\t\t \n\tres = scroll_csr_backward(NCURSES_SP_ARGx -n, top, bot, 0, maxy, blank);\n\n\tif (res == ERR && change_scroll_region) {\n\t    if (top != 0\n\t\t&& (SP_PARM->_cursrow == top ||\n\t\t    SP_PARM->_cursrow == top - 1)\n\t\t&& save_cursor && restore_cursor) {\n\t\tcursor_saved = TRUE;\n\t\tNCURSES_PUTP2(\"save_cursor\", save_cursor);\n\t    }\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TIPARM_2(change_scroll_region, top, bot));\n\t    if (cursor_saved) {\n\t\tNCURSES_PUTP2(\"restore_cursor\", restore_cursor);\n\t    } else {\n\t\tSP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t    }\n\n\t    res = scroll_csr_backward(NCURSES_SP_ARGx\n\t\t\t\t      -n, top, bot, top, bot, blank);\n\n\t    NCURSES_PUTP2(\"change_scroll_region\",\n\t\t\t  TIPARM_2(change_scroll_region, 0, maxy));\n\t    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\t}\n\n\tif (res == ERR && SP_PARM->_nc_sp_idlok)\n\t    res = scroll_idl(NCURSES_SP_ARGx -n, bot + n + 1, top, blank);\n\n\t \n\tif (res != ERR\n\t    && (non_dest_scroll_region || (memory_above && top == 0))) {\n\t    static const NCURSES_CH_T blank2 = NewChar(BLANK_TEXT);\n\t    for (i = 0; i < -n; i++) {\n\t\tGoTo(NCURSES_SP_ARGx i + top, 0);\n\t\tClrToEOL(NCURSES_SP_ARGx blank2, FALSE);\n\t    }\n\t}\n    }\n\n    if (res == ERR)\n\treturn (ERR);\n\n    _nc_scroll_window(CurScreen(SP_PARM), n,\n\t\t      (NCURSES_SIZE_T) top,\n\t\t      (NCURSES_SIZE_T) bot,\n\t\t      blank);\n\n     \n    NCURSES_SP_NAME(_nc_scroll_oldhash) (NCURSES_SP_ARGx n, top, bot);\n\n    return (OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_scrolln(int n, int top, int bot, int maxy)\n{\n    return NCURSES_SP_NAME(_nc_scrolln) (CURRENT_SCREEN, n, top, bot, maxy);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_DCL0)\n{\n    assert(SP_PARM);\n\n     \n    SetAttr(SCREEN_ATTRS(SP_PARM), A_NORMAL);\n    NewScreen(SP_PARM)->_clear = TRUE;\n\n     \n    if (SP_PARM->_coloron || SP_PARM->_color_defs)\n\tNCURSES_SP_NAME(_nc_reset_colors) (NCURSES_SP_ARG);\n\n     \n    if (SP_PARM->_color_defs < 0 && !SP_PARM->_direct_color.value) {\n\tint n;\n\tSP_PARM->_color_defs = -(SP_PARM->_color_defs);\n\tfor (n = 0; n < SP_PARM->_color_defs; ++n) {\n\t    if (SP_PARM->_color_table[n].init) {\n\t\t_nc_init_color(SP_PARM,\n\t\t\t       n,\n\t\t\t       SP_PARM->_color_table[n].r,\n\t\t\t       SP_PARM->_color_table[n].g,\n\t\t\t       SP_PARM->_color_table[n].b);\n\t    }\n\t}\n    }\n\n    if (exit_attribute_mode)\n\tNCURSES_PUTP2(\"exit_attribute_mode\", exit_attribute_mode);\n    else {\n\t \n\tif (exit_alt_charset_mode)\n\t    NCURSES_PUTP2(\"exit_alt_charset_mode\", exit_alt_charset_mode);\n\tif (exit_standout_mode)\n\t    NCURSES_PUTP2(\"exit_standout_mode\", exit_standout_mode);\n\tif (exit_underline_mode)\n\t    NCURSES_PUTP2(\"exit_underline_mode\", exit_underline_mode);\n    }\n    if (exit_insert_mode)\n\tNCURSES_PUTP2(\"exit_insert_mode\", exit_insert_mode);\n    if (enter_am_mode && exit_am_mode) {\n\tif (auto_right_margin) {\n\t    NCURSES_PUTP2(\"enter_am_mode\", enter_am_mode);\n\t} else {\n\t    NCURSES_PUTP2(\"exit_am_mode\", exit_am_mode);\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_screen_resume(void)\n{\n    NCURSES_SP_NAME(_nc_screen_resume) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_screen_init) (NCURSES_SP_DCL0)\n{\n    NCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_ARG);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_screen_init(void)\n{\n    NCURSES_SP_NAME(_nc_screen_init) (CURRENT_SCREEN);\n}\n#endif\n\n \nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_screen_wrap) (NCURSES_SP_DCL0)\n{\n    if (SP_PARM != 0) {\n\n\tUpdateAttrs(SP_PARM, normal);\n#if NCURSES_EXT_FUNCS\n\tif (SP_PARM->_coloron\n\t    && !SP_PARM->_default_color) {\n\t    static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n\t    SP_PARM->_default_color = TRUE;\n\t    NCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_ARGx\n\t\t\t\t\t   -1,\n\t\t\t\t\t   0,\n\t\t\t\t\t   FALSE,\n\t\t\t\t\t   NCURSES_SP_NAME(_nc_outch));\n\t    SP_PARM->_default_color = FALSE;\n\n\t    TINFO_MVCUR(NCURSES_SP_ARGx\n\t\t\tSP_PARM->_cursrow,\n\t\t\tSP_PARM->_curscol,\n\t\t\tscreen_lines(SP_PARM) - 1,\n\t\t\t0);\n\n\t    ClrToEOL(NCURSES_SP_ARGx blank, TRUE);\n\t}\n#endif\n\tif (SP_PARM->_color_defs) {\n\t    NCURSES_SP_NAME(_nc_reset_colors) (NCURSES_SP_ARG);\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_screen_wrap(void)\n{\n    NCURSES_SP_NAME(_nc_screen_wrap) (CURRENT_SCREEN);\n}\n#endif\n\n#if USE_XMC_SUPPORT\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_do_xmc_glitch) (NCURSES_SP_DCLx attr_t previous)\n{\n    if (SP_PARM != 0) {\n\tattr_t chg = XMC_CHANGES(previous ^ AttrOf(SCREEN_ATTRS(SP_PARM)));\n\n\twhile (chg != 0) {\n\t    if (chg & 1) {\n\t\tSP_PARM->_curscol += magic_cookie_glitch;\n\t\tif (SP_PARM->_curscol >= SP_PARM->_columns)\n\t\t    wrap_cursor(NCURSES_SP_ARG);\n\t\tTR(TRACE_UPDATE, (\"bumped to %d,%d after cookie\",\n\t\t\t\t  SP_PARM->_cursrow, SP_PARM->_curscol));\n\t    }\n\t    chg >>= 1;\n\t}\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_do_xmc_glitch(attr_t previous)\n{\n    NCURSES_SP_NAME(_nc_do_xmc_glitch) (CURRENT_SCREEN, previous);\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}