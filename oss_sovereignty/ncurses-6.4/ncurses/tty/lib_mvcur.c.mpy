{
  "module_name": "lib_mvcur.c",
  "hash_id": "2e420f9727dc71d38ed26b15aa888e08f658048b8537766fbfccd9e8fd36950a",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tty/lib_mvcur.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n \n#define COMPUTE_OVERHEAD\t1\t \n\n \n#define LONG_DIST\t\t(8 - COMPUTE_OVERHEAD)\n\n \n#define NOT_LOCAL(sp, fy, fx, ty, tx)\t((tx > LONG_DIST) \\\n\t\t && (tx < screen_columns(sp) - 1 - LONG_DIST) \\\n\t\t && (abs(ty-fy) + abs(tx-fx) > LONG_DIST))\n\n \n\n \n\n#include <curses.priv.h>\n#include <ctype.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_mvcur.c,v 1.157 2022/08/20 18:28:58 tom Exp $\")\n\n#define WANT_CHAR(sp, y, x) NewScreen(sp)->_line[y].text[x]\t \n\n#if NCURSES_SP_FUNCS\n#define BAUDRATE(sp)\tsp->_term->_baudrate\t \n#else\n#define BAUDRATE(sp)\tcur_term->_baudrate\t \n#endif\n\n#if defined(MAIN) || defined(NCURSES_TEST)\n#include <sys/time.h>\n\nstatic bool profiling = FALSE;\nstatic float diff;\n#endif  \n\n#undef NCURSES_OUTC_FUNC\n#define NCURSES_OUTC_FUNC myOutCh\n\n#define OPT_SIZE 512\n\nstatic int normalized_cost(NCURSES_SP_DCLx const char *const cap, int affcnt);\n\n \n\n#ifdef TRACE\nstatic int\ntrace_cost_of(NCURSES_SP_DCLx const char *capname, const char *cap, int affcnt)\n{\n    int result = NCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_ARGx cap, affcnt);\n    TR(TRACE_CHARPUT | TRACE_MOVE,\n       (\"CostOf %s %d %s\", capname, result, _nc_visbuf(cap)));\n    return result;\n}\n#define CostOf(cap,affcnt) trace_cost_of(NCURSES_SP_ARGx #cap, cap, affcnt)\n\nstatic int\ntrace_normalized_cost(NCURSES_SP_DCLx const char *capname, const char *cap, int affcnt)\n{\n    int result = normalized_cost(NCURSES_SP_ARGx cap, affcnt);\n    TR(TRACE_CHARPUT | TRACE_MOVE,\n       (\"NormalizedCost %s %d %s\", capname, result, _nc_visbuf(cap)));\n    return result;\n}\n#define NormalizedCost(cap,affcnt) trace_normalized_cost(NCURSES_SP_ARGx #cap, cap, affcnt)\n\n#else\n\n#define CostOf(cap,affcnt) NCURSES_SP_NAME(_nc_msec_cost)(NCURSES_SP_ARGx cap, affcnt)\n#define NormalizedCost(cap,affcnt) normalized_cost(NCURSES_SP_ARGx cap, affcnt)\n\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_DCLx const char *const cap, int affcnt)\n \n{\n    if (cap == 0)\n\treturn (INFINITY);\n    else {\n\tconst char *cp;\n\tfloat cum_cost = 0.0;\n\n\tfor (cp = cap; *cp; cp++) {\n\t     \n\t    if (cp[0] == '$' && cp[1] == '<' && strchr(cp, '>')) {\n\t\tfloat number = 0.0;\n\n\t\tfor (cp += 2; *cp != '>'; cp++) {\n\t\t    if (isdigit(UChar(*cp)))\n\t\t\tnumber = number * 10 + (float) (*cp - '0');\n\t\t    else if (*cp == '*')\n\t\t\tnumber *= (float) affcnt;\n\t\t    else if (*cp == '.' && (*++cp != '>') && isdigit(UChar(*cp)))\n\t\t\tnumber += (float) ((*cp - '0') / 10.0);\n\t\t}\n\n#if NCURSES_NO_PADDING\n\t\tif (!GetNoPadding(SP_PARM))\n#endif\n\t\t    cum_cost += number * 10;\n\t    } else if (SP_PARM) {\n\t\tcum_cost += (float) SP_PARM->_char_padding;\n\t    }\n\t}\n\n\treturn ((int) cum_cost);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_msec_cost(const char *const cap, int affcnt)\n{\n    return NCURSES_SP_NAME(_nc_msec_cost) (CURRENT_SCREEN, cap, affcnt);\n}\n#endif\n\nstatic int\nnormalized_cost(NCURSES_SP_DCLx const char *const cap, int affcnt)\n \n{\n    int cost = NCURSES_SP_NAME(_nc_msec_cost) (NCURSES_SP_ARGx cap, affcnt);\n    if (cost != INFINITY)\n\tcost = (cost + SP_PARM->_char_padding - 1) / SP_PARM->_char_padding;\n    return cost;\n}\n\nstatic void\nreset_scroll_region(NCURSES_SP_DCL0)\n \n{\n    if (change_scroll_region) {\n\tNCURSES_PUTP2(\"change_scroll_region\",\n\t\t      TIPARM_2(change_scroll_region,\n\t\t\t       0, screen_lines(SP_PARM) - 1));\n    }\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_DCL0)\n \n{\n    if (!SP_PARM || !IsTermInfo(SP_PARM))\n\treturn;\n\n     \n    if (enter_ca_mode) {\n\tNCURSES_PUTP2(\"enter_ca_mode\", enter_ca_mode);\n    }\n\n     \n    reset_scroll_region(NCURSES_SP_ARG);\n    SP_PARM->_cursrow = SP_PARM->_curscol = -1;\n\n     \n    if (SP_PARM->_cursor != -1) {\n\tint cursor = SP_PARM->_cursor;\n\tSP_PARM->_cursor = -1;\n\tNCURSES_SP_NAME(curs_set) (NCURSES_SP_ARGx cursor);\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_mvcur_resume(void)\n{\n    NCURSES_SP_NAME(_nc_mvcur_resume) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_mvcur_init) (NCURSES_SP_DCL0)\n \n{\n    if (SP_PARM->_ofp && NC_ISATTY(fileno(SP_PARM->_ofp))) {\n\tSP_PARM->_char_padding = ((BAUDBYTE * 1000 * 10)\n\t\t\t\t  / (BAUDRATE(SP_PARM) > 0\n\t\t\t\t     ? BAUDRATE(SP_PARM)\n\t\t\t\t     : 9600));\n    } else {\n\tSP_PARM->_char_padding = 1;\t \n    }\n    if (SP_PARM->_char_padding <= 0)\n\tSP_PARM->_char_padding = 1;\t \n    TR(TRACE_CHARPUT | TRACE_MOVE, (\"char_padding %d msecs\", SP_PARM->_char_padding));\n\n     \n    SP_PARM->_cr_cost = CostOf(carriage_return, 0);\n    SP_PARM->_home_cost = CostOf(cursor_home, 0);\n    SP_PARM->_ll_cost = CostOf(cursor_to_ll, 0);\n#if USE_HARD_TABS\n    if (getenv(\"NCURSES_NO_HARD_TABS\") == 0\n\t&& dest_tabs_magic_smso == 0\n\t&& HasHardTabs()) {\n\tSP_PARM->_ht_cost = CostOf(tab, 0);\n\tSP_PARM->_cbt_cost = CostOf(back_tab, 0);\n    } else {\n\tSP_PARM->_ht_cost = INFINITY;\n\tSP_PARM->_cbt_cost = INFINITY;\n    }\n#endif  \n    SP_PARM->_cub1_cost = CostOf(cursor_left, 0);\n    SP_PARM->_cuf1_cost = CostOf(cursor_right, 0);\n    SP_PARM->_cud1_cost = CostOf(cursor_down, 0);\n    SP_PARM->_cuu1_cost = CostOf(cursor_up, 0);\n\n    SP_PARM->_smir_cost = CostOf(enter_insert_mode, 0);\n    SP_PARM->_rmir_cost = CostOf(exit_insert_mode, 0);\n    SP_PARM->_ip_cost = 0;\n    if (insert_padding) {\n\tSP_PARM->_ip_cost = CostOf(insert_padding, 0);\n    }\n\n     \n    SP_PARM->_address_cursor = cursor_address ? cursor_address : cursor_mem_address;\n\n     \n    SP_PARM->_cup_cost = CostOf(TIPARM_2(SP_PARM->_address_cursor, 23, 23), 1);\n    SP_PARM->_cub_cost = CostOf(TIPARM_1(parm_left_cursor, 23), 1);\n    SP_PARM->_cuf_cost = CostOf(TIPARM_1(parm_right_cursor, 23), 1);\n    SP_PARM->_cud_cost = CostOf(TIPARM_1(parm_down_cursor, 23), 1);\n    SP_PARM->_cuu_cost = CostOf(TIPARM_1(parm_up_cursor, 23), 1);\n    SP_PARM->_hpa_cost = CostOf(TIPARM_1(column_address, 23), 1);\n    SP_PARM->_vpa_cost = CostOf(TIPARM_1(row_address, 23), 1);\n\n     \n    SP_PARM->_ed_cost = NormalizedCost(clr_eos, 1);\n    SP_PARM->_el_cost = NormalizedCost(clr_eol, 1);\n    SP_PARM->_el1_cost = NormalizedCost(clr_bol, 1);\n    SP_PARM->_dch1_cost = NormalizedCost(delete_character, 1);\n    SP_PARM->_ich1_cost = NormalizedCost(insert_character, 1);\n\n     \n    if (back_color_erase)\n\tSP_PARM->_el_cost = 0;\n\n     \n    SP_PARM->_dch_cost = NormalizedCost(TIPARM_1(parm_dch, 23), 1);\n    SP_PARM->_ich_cost = NormalizedCost(TIPARM_1(parm_ich, 23), 1);\n    SP_PARM->_ech_cost = NormalizedCost(TIPARM_1(erase_chars, 23), 1);\n    SP_PARM->_rep_cost = NormalizedCost(TIPARM_2(repeat_char, ' ', 23), 1);\n\n    SP_PARM->_cup_ch_cost = NormalizedCost(TIPARM_2(SP_PARM->_address_cursor,\n\t\t\t\t\t\t    23, 23),\n\t\t\t\t\t   1);\n    SP_PARM->_hpa_ch_cost = NormalizedCost(TIPARM_1(column_address, 23), 1);\n    SP_PARM->_cuf_ch_cost = NormalizedCost(TIPARM_1(parm_right_cursor, 23), 1);\n    SP_PARM->_inline_cost = min(SP_PARM->_cup_ch_cost,\n\t\t\t\tmin(SP_PARM->_hpa_ch_cost,\n\t\t\t\t    SP_PARM->_cuf_ch_cost));\n\n     \n    if (save_cursor != 0\n\t&& enter_ca_mode != 0\n\t&& strstr(enter_ca_mode, save_cursor) != 0) {\n\tT((\"...suppressed sc/rc capability due to conflict with smcup/rmcup\"));\n\tsave_cursor = 0;\n\trestore_cursor = 0;\n    }\n\n     \n    NCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_ARG);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_mvcur_init(void)\n{\n    NCURSES_SP_NAME(_nc_mvcur_init) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_mvcur_wrap) (NCURSES_SP_DCL0)\n \n{\n    if (!SP_PARM || !IsTermInfo(SP_PARM))\n\treturn;\n\n     \n    TINFO_MVCUR(NCURSES_SP_ARGx -1, -1, screen_lines(SP_PARM) - 1, 0);\n\n     \n    if (SP_PARM->_cursor != -1) {\n\tint cursor = SP_PARM->_cursor;\n\tNCURSES_SP_NAME(curs_set) (NCURSES_SP_ARGx 1);\n\tSP_PARM->_cursor = cursor;\n    }\n\n    if (exit_ca_mode) {\n\tNCURSES_PUTP2(\"exit_ca_mode\", exit_ca_mode);\n    }\n     \n    NCURSES_SP_NAME(_nc_outch) (NCURSES_SP_ARGx '\\r');\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_mvcur_wrap(void)\n{\n    NCURSES_SP_NAME(_nc_mvcur_wrap) (CURRENT_SCREEN);\n}\n#endif\n\n \n\n \nstatic NCURSES_INLINE int\nrepeated_append(string_desc * target, int total, int num, int repeat, const char *src)\n{\n    size_t need = (size_t) repeat * strlen(src);\n\n    if (need < target->s_size) {\n\twhile (repeat-- > 0) {\n\t    if (_nc_safe_strcat(target, src)) {\n\t\ttotal += num;\n\t    } else {\n\t\ttotal = INFINITY;\n\t\tbreak;\n\t    }\n\t}\n    } else {\n\ttotal = INFINITY;\n    }\n    return total;\n}\n\n#ifndef NO_OPTIMIZE\n#define NEXTTAB(fr)\t(fr + init_tabs - (fr % init_tabs))\n\n \n#define LASTTAB(fr)\t((fr > 0) ? ((fr - 1) / init_tabs) * init_tabs : -1)\n\nstatic int\nrelative_move(NCURSES_SP_DCLx\n\t      string_desc * target,\n\t      int from_y,\n\t      int from_x,\n\t      int to_y,\n\t      int to_x,\n\t      int ovw)\n \n{\n    string_desc save;\n    int n, vcost = 0, hcost = 0;\n\n    (void) _nc_str_copy(&save, target);\n\n    if (to_y != from_y) {\n\tvcost = INFINITY;\n\n\tif (row_address != 0\n\t    && _nc_safe_strcat(target, TIPARM_1(row_address, to_y))) {\n\t    vcost = SP_PARM->_vpa_cost;\n\t}\n\n\tif (to_y > from_y) {\n\t    n = (to_y - from_y);\n\n\t    if (parm_down_cursor\n\t\t&& SP_PARM->_cud_cost < vcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TIPARM_1(parm_down_cursor, n))) {\n\t\tvcost = SP_PARM->_cud_cost;\n\t    }\n\n\t    if (cursor_down\n\t\t&& (*cursor_down != '\\n')\n\t\t&& (n * SP_PARM->_cud1_cost < vcost)) {\n\t\tvcost = repeated_append(_nc_str_copy(target, &save), 0,\n\t\t\t\t\tSP_PARM->_cud1_cost, n, cursor_down);\n\t    }\n\t} else {\t\t \n\t    n = (from_y - to_y);\n\n\t    if (parm_up_cursor\n\t\t&& SP_PARM->_cuu_cost < vcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TIPARM_1(parm_up_cursor, n))) {\n\t\tvcost = SP_PARM->_cuu_cost;\n\t    }\n\n\t    if (cursor_up && (n * SP_PARM->_cuu1_cost < vcost)) {\n\t\tvcost = repeated_append(_nc_str_copy(target, &save), 0,\n\t\t\t\t\tSP_PARM->_cuu1_cost, n, cursor_up);\n\t    }\n\t}\n\n\tif (vcost == INFINITY)\n\t    return (INFINITY);\n    }\n\n    save = *target;\n\n    if (to_x != from_x) {\n\tchar str[OPT_SIZE];\n\tstring_desc check;\n\n\thcost = INFINITY;\n\n\tif (column_address\n\t    && _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t       TIPARM_1(column_address, to_x))) {\n\t    hcost = SP_PARM->_hpa_cost;\n\t}\n\n\tif (to_x > from_x) {\n\t    n = to_x - from_x;\n\n\t    if (parm_right_cursor\n\t\t&& SP_PARM->_cuf_cost < hcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TIPARM_1(parm_right_cursor, n))) {\n\t\thcost = SP_PARM->_cuf_cost;\n\t    }\n\n\t    if (cursor_right) {\n\t\tint lhcost = 0;\n\n\t\t(void) _nc_str_init(&check, str, sizeof(str));\n\n#if USE_HARD_TABS\n\t\t \n\t\tif (init_tabs > 0 && tab) {\n\t\t    int nxt, fr;\n\n\t\t    for (fr = from_x; (nxt = NEXTTAB(fr)) <= to_x; fr = nxt) {\n\t\t\tlhcost = repeated_append(&check, lhcost,\n\t\t\t\t\t\t SP_PARM->_ht_cost, 1, tab);\n\t\t\tif (lhcost == INFINITY)\n\t\t\t    break;\n\t\t    }\n\n\t\t    n = to_x - fr;\n\t\t    from_x = fr;\n\t\t}\n#endif  \n\n\t\tif (n <= 0 || n >= (int) check.s_size)\n\t\t    ovw = FALSE;\n#if BSD_TPUTS\n\t\t \n\t\tif (ovw\n\t\t    && n > 0\n\t\t    && n < (int) check.s_size\n\t\t    && vcost == 0\n\t\t    && str[0] == '\\0') {\n\t\t    int wanted = CharOf(WANT_CHAR(SP_PARM, to_y, from_x));\n\t\t    if (is8bits(wanted) && isdigit(wanted))\n\t\t\tovw = FALSE;\n\t\t}\n#endif\n\t\t \n\t\tif (ovw) {\n\t\t    int i;\n\n\t\t    for (i = 0; i < n; i++) {\n\t\t\tNCURSES_CH_T ch = WANT_CHAR(SP_PARM, to_y, from_x + i);\n\t\t\tif (!SameAttrOf(ch, SCREEN_ATTRS(SP_PARM))\n#if USE_WIDEC_SUPPORT\n\t\t\t    || !Charable(ch)\n#endif\n\t\t\t    ) {\n\t\t\t    ovw = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ovw) {\n\t\t    int i;\n\n\t\t    for (i = 0; i < n; i++)\n\t\t\t*check.s_tail++ = (char) CharOf(WANT_CHAR(SP_PARM, to_y,\n\t\t\t\t\t\t\t\t  from_x + i));\n\t\t    *check.s_tail = '\\0';\n\t\t    check.s_size -= (size_t) n;\n\t\t    lhcost += n * SP_PARM->_char_padding;\n\t\t} else {\n\t\t    lhcost = repeated_append(&check, lhcost, SP_PARM->_cuf1_cost,\n\t\t\t\t\t     n, cursor_right);\n\t\t}\n\n\t\tif (lhcost < hcost\n\t\t    && _nc_safe_strcat(_nc_str_copy(target, &save), str)) {\n\t\t    hcost = lhcost;\n\t\t}\n\t    }\n\t} else {\t\t \n\t    n = from_x - to_x;\n\n\t    if (parm_left_cursor\n\t\t&& SP_PARM->_cub_cost < hcost\n\t\t&& _nc_safe_strcat(_nc_str_copy(target, &save),\n\t\t\t\t   TIPARM_1(parm_left_cursor, n))) {\n\t\thcost = SP_PARM->_cub_cost;\n\t    }\n\n\t    if (cursor_left) {\n\t\tint lhcost = 0;\n\n\t\t(void) _nc_str_init(&check, str, sizeof(str));\n\n#if USE_HARD_TABS\n\t\tif (init_tabs > 0 && back_tab) {\n\t\t    int nxt, fr;\n\n\t\t    for (fr = from_x; (nxt = LASTTAB(fr)) >= to_x; fr = nxt) {\n\t\t\tlhcost = repeated_append(&check, lhcost,\n\t\t\t\t\t\t SP_PARM->_cbt_cost,\n\t\t\t\t\t\t 1, back_tab);\n\t\t\tif (lhcost == INFINITY)\n\t\t\t    break;\n\t\t    }\n\n\t\t    n = fr - to_x;\n\t\t}\n#endif  \n\n\t\tlhcost = repeated_append(&check, lhcost,\n\t\t\t\t\t SP_PARM->_cub1_cost,\n\t\t\t\t\t n, cursor_left);\n\n\t\tif (lhcost < hcost\n\t\t    && _nc_safe_strcat(_nc_str_copy(target, &save), str)) {\n\t\t    hcost = lhcost;\n\t\t}\n\t    }\n\t}\n\n\tif (hcost == INFINITY)\n\t    return (INFINITY);\n    }\n\n    return (vcost + hcost);\n}\n#endif  \n\n \n\nstatic NCURSES_INLINE int\nonscreen_mvcur(NCURSES_SP_DCLx\n\t       int yold, int xold,\n\t       int ynew, int xnew, int ovw,\n\t       NCURSES_SP_OUTC myOutCh)\n \n{\n    string_desc result;\n    char buffer[OPT_SIZE];\n    int tactic = 0, newcost, usecost = INFINITY;\n    int t5_cr_cost;\n\n#if defined(MAIN) || defined(NCURSES_TEST)\n    struct timeval before, after;\n\n    gettimeofday(&before, NULL);\n#endif  \n\n#define NullResult _nc_str_null(&result, sizeof(buffer))\n#define InitResult _nc_str_init(&result, buffer, sizeof(buffer))\n\n     \n    if (_nc_safe_strcpy(InitResult, TIPARM_2(SP_PARM->_address_cursor,\n\t\t\t\t\t     ynew, xnew))) {\n\ttactic = 0;\n\tusecost = SP_PARM->_cup_cost;\n\n#if defined(TRACE) || defined(NCURSES_TEST)\n\tif (!(_nc_optimize_enable & OPTIMIZE_MVCUR))\n\t    goto nonlocal;\n#endif  \n\n\t \n\tif (yold == -1 || xold == -1 || NOT_LOCAL(SP_PARM, yold, xold, ynew, xnew)) {\n#if defined(MAIN) || defined(NCURSES_TEST)\n\t    if (!profiling) {\n\t\t(void) fputs(\"nonlocal\\n\", stderr);\n\t\tgoto nonlocal;\t \n\t    }\n#else\n\t    goto nonlocal;\n#endif  \n\t}\n    }\n#ifndef NO_OPTIMIZE\n     \n    if (yold != -1 && xold != -1\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     yold, xold,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& newcost < usecost) {\n\ttactic = 1;\n\tusecost = newcost;\n    }\n\n     \n    if (yold != -1 && carriage_return\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     yold, 0,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& SP_PARM->_cr_cost + newcost < usecost) {\n\ttactic = 2;\n\tusecost = SP_PARM->_cr_cost + newcost;\n    }\n\n     \n    if (cursor_home\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     0, 0,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& SP_PARM->_home_cost + newcost < usecost) {\n\ttactic = 3;\n\tusecost = SP_PARM->_home_cost + newcost;\n    }\n\n     \n    if (cursor_to_ll\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     screen_lines(SP_PARM) - 1, 0,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& SP_PARM->_ll_cost + newcost < usecost) {\n\ttactic = 4;\n\tusecost = SP_PARM->_ll_cost + newcost;\n    }\n\n     \n    t5_cr_cost = (xold > 0 ? SP_PARM->_cr_cost : 0);\n    if (auto_left_margin && !eat_newline_glitch\n\t&& yold > 0 && cursor_left\n\t&& ((newcost = relative_move(NCURSES_SP_ARGx\n\t\t\t\t     NullResult,\n\t\t\t\t     yold - 1, screen_columns(SP_PARM) - 1,\n\t\t\t\t     ynew, xnew, ovw)) != INFINITY)\n\t&& t5_cr_cost + SP_PARM->_cub1_cost + newcost < usecost) {\n\ttactic = 5;\n\tusecost = t5_cr_cost + SP_PARM->_cub1_cost + newcost;\n    }\n\n     \n    if (tactic)\n\tInitResult;\n    switch (tactic) {\n    case 1:\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     yold, xold,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 2:\n\t(void) _nc_safe_strcpy(&result, carriage_return);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     yold, 0,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 3:\n\t(void) _nc_safe_strcpy(&result, cursor_home);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result, 0, 0,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 4:\n\t(void) _nc_safe_strcpy(&result, cursor_to_ll);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     screen_lines(SP_PARM) - 1, 0,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    case 5:\n\tif (xold > 0)\n\t    (void) _nc_safe_strcat(&result, carriage_return);\n\t(void) _nc_safe_strcat(&result, cursor_left);\n\t(void) relative_move(NCURSES_SP_ARGx\n\t\t\t     &result,\n\t\t\t     yold - 1, screen_columns(SP_PARM) - 1,\n\t\t\t     ynew, xnew, ovw);\n\tbreak;\n    }\n#endif  \n\n  nonlocal:\n#if defined(MAIN) || defined(NCURSES_TEST)\n    gettimeofday(&after, NULL);\n    diff = after.tv_usec - before.tv_usec\n\t+ (after.tv_sec - before.tv_sec) * 1000000;\n    if (!profiling)\n\t(void) fprintf(stderr,\n\t\t       \"onscreen: %d microsec, %f 28.8Kbps char-equivalents\\n\",\n\t\t       (int) diff, diff / 288);\n#endif  \n\n    if (usecost != INFINITY) {\n\tTR(TRACE_MOVE, (\"mvcur tactic %d\", tactic));\n\tTPUTS_TRACE(\"mvcur\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tbuffer, 1, myOutCh);\n\tSP_PARM->_cursrow = ynew;\n\tSP_PARM->_curscol = xnew;\n\treturn (OK);\n    } else\n\treturn (ERR);\n}\n\n \nstatic int\n_nc_real_mvcur(NCURSES_SP_DCLx\n\t       int yold, int xold,\n\t       int ynew, int xnew,\n\t       NCURSES_SP_OUTC myOutCh,\n\t       int ovw)\n{\n    NCURSES_CH_T oldattr;\n    int code;\n\n    TR(TRACE_CALLS | TRACE_MOVE, (T_CALLED(\"_nc_real_mvcur(%p,%d,%d,%d,%d)\"),\n\t\t\t\t  (void *) SP_PARM, yold, xold, ynew, xnew));\n\n    if (SP_PARM == 0) {\n\tcode = ERR;\n    } else if (yold == ynew && xold == xnew) {\n\tcode = OK;\n    } else {\n\n\t \n\tif (xnew >= screen_columns(SP_PARM)) {\n\t    ynew += xnew / screen_columns(SP_PARM);\n\t    xnew %= screen_columns(SP_PARM);\n\t}\n\n\t \n\toldattr = SCREEN_ATTRS(SP_PARM);\n\tif ((AttrOf(oldattr) & A_ALTCHARSET)\n\t    || (AttrOf(oldattr) && !move_standout_mode)) {\n\t    TR(TRACE_CHARPUT, (\"turning off (%#lx) %s before move\",\n\t\t\t       (unsigned long) AttrOf(oldattr),\n\t\t\t       _traceattr(AttrOf(oldattr))));\n\t    VIDPUTS(SP_PARM, A_NORMAL, 0);\n\t}\n\n\tif (xold >= screen_columns(SP_PARM)) {\n\n\t    int l = (xold + 1) / screen_columns(SP_PARM);\n\n\t    yold += l;\n\t    if (yold >= screen_lines(SP_PARM))\n\t\tl -= (yold - screen_lines(SP_PARM) - 1);\n\n\t    if (l > 0) {\n\t\tif (carriage_return) {\n\t\t    NCURSES_PUTP2(\"carriage_return\", carriage_return);\n\t\t} else {\n\t\t    myOutCh(NCURSES_SP_ARGx '\\r');\n\t\t}\n\t\txold = 0;\n\n\t\twhile (l > 0) {\n\t\t    if (newline) {\n\t\t\tNCURSES_PUTP2(\"newline\", newline);\n\t\t    } else {\n\t\t\tmyOutCh(NCURSES_SP_ARGx '\\n');\n\t\t    }\n\t\t    l--;\n\t\t}\n\t    }\n\t}\n\n\tif (yold > screen_lines(SP_PARM) - 1)\n\t    yold = screen_lines(SP_PARM) - 1;\n\tif (ynew > screen_lines(SP_PARM) - 1)\n\t    ynew = screen_lines(SP_PARM) - 1;\n\n\t \n\tcode = onscreen_mvcur(NCURSES_SP_ARGx yold, xold, ynew, xnew, ovw, myOutCh);\n\n\t \n\tif (!SameAttrOf(oldattr, SCREEN_ATTRS(SP_PARM))) {\n\t    TR(TRACE_CHARPUT, (\"turning on (%#lx) %s after move\",\n\t\t\t       (unsigned long) AttrOf(oldattr),\n\t\t\t       _traceattr(AttrOf(oldattr))));\n\t    VIDPUTS(SP_PARM, AttrOf(oldattr), GetPair(oldattr));\n\t}\n    }\n    returnCode(code);\n}\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_mvcur) (NCURSES_SP_DCLx\n\t\t\t    int yold, int xold,\n\t\t\t    int ynew, int xnew)\n{\n    int rc;\n    rc = _nc_real_mvcur(NCURSES_SP_ARGx yold, xold, ynew, xnew,\n\t\t\tNCURSES_SP_NAME(_nc_outch),\n\t\t\tTRUE);\n     \n    if ((SP_PARM != 0) && (SP_PARM->_endwin == ewInitial))\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_mvcur(int yold, int xold,\n\t  int ynew, int xnew)\n{\n    return NCURSES_SP_NAME(_nc_mvcur) (CURRENT_SCREEN, yold, xold, ynew, xnew);\n}\n#endif\n\n#if defined(USE_TERM_DRIVER)\n \nNCURSES_EXPORT(int)\nTINFO_MVCUR(NCURSES_SP_DCLx int yold, int xold, int ynew, int xnew)\n{\n    int rc;\n    rc = _nc_real_mvcur(NCURSES_SP_ARGx\n\t\t\tyold, xold,\n\t\t\tynew, xnew,\n\t\t\tNCURSES_SP_NAME(_nc_outch),\n\t\t\tTRUE);\n    if ((SP_PARM != 0) && (SP_PARM->_endwin == ewInitial))\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    return rc;\n}\n\n#else  \n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(mvcur) (NCURSES_SP_DCLx int yold, int xold, int ynew,\n\t\t\tint xnew)\n{\n    return _nc_real_mvcur(NCURSES_SP_ARGx\n\t\t\t  yold, xold,\n\t\t\t  ynew, xnew,\n\t\t\t  NCURSES_SP_NAME(_nc_putchar),\n\t\t\t  FALSE);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nmvcur(int yold, int xold, int ynew, int xnew)\n{\n    return NCURSES_SP_NAME(mvcur) (CURRENT_SCREEN, yold, xold, ynew, xnew);\n}\n#endif\n#endif  \n\n#if defined(TRACE) || defined(NCURSES_TEST)\nNCURSES_EXPORT_VAR(int) _nc_optimize_enable = OPTIMIZE_ALL;\n#endif\n\n#if defined(MAIN) || defined(NCURSES_TEST)\n \n\n#include <tic.h>\n#include <dump_entry.h>\n#include <time.h>\n\nNCURSES_EXPORT_VAR(const char *) _nc_progname = \"mvcur\";\n\nstatic unsigned long xmits;\n\n \nNCURSES_EXPORT(int)\ntputs(const char *string, int affcnt GCC_UNUSED, int (*outc) (int) GCC_UNUSED)\n \n{\n    if (profiling)\n\txmits += strlen(string);\n    else\n\t(void) fputs(_nc_visbuf(string), stdout);\n    return (OK);\n}\n\nNCURSES_EXPORT(int)\nputp(const char *string)\n{\n    return (tputs(string, 1, _nc_outch));\n}\n\nNCURSES_EXPORT(int)\n_nc_outch(int ch)\n{\n    putc(ch, stdout);\n    return OK;\n}\n\nNCURSES_EXPORT(int)\ndelay_output(int ms GCC_UNUSED)\n{\n    return OK;\n}\n\nstatic char tname[PATH_MAX];\n\nstatic void\nload_term(void)\n{\n    (void) setupterm(tname, STDOUT_FILENO, NULL);\n}\n\nstatic int\nroll(int n)\n{\n    int i, j;\n\n    i = (RAND_MAX / n) * n;\n    while ((j = rand()) >= i)\n\tcontinue;\n    return (j % n);\n}\n\nint\nmain(int argc GCC_UNUSED, char *argv[]GCC_UNUSED)\n{\n    _nc_STRCPY(tname, getenv(\"TERM\"), sizeof(tname));\n    load_term();\n    _nc_setupscreen(lines, columns, stdout, FALSE, 0);\n    baudrate();\n\n    _nc_mvcur_init();\n\n    (void) puts(\"The mvcur tester.  Type ? for help\");\n\n    fputs(\"smcup:\", stdout);\n    putchar('\\n');\n\n    for (;;) {\n\tint fy, fx, ty, tx, n, i;\n\tchar buf[BUFSIZ], capname[BUFSIZ];\n\n\tif (fputs(\"> \", stdout) == EOF)\n\t    break;\n\tif (fgets(buf, sizeof(buf), stdin) == 0)\n\t    break;\n\n#define PUTS(s)   (void) puts(s)\n#define PUTF(s,t) (void) printf(s,t)\n\tif (buf[0] == '?') {\n\t    PUTS(\"?                -- display this help message\");\n\t    PUTS(\"fy fx ty tx      -- (4 numbers) display (fy,fx)->(ty,tx) move\");\n\t    PUTS(\"s[croll] n t b m -- display scrolling sequence\");\n\t    PUTF(\"r[eload]         -- reload terminal info for %s\\n\",\n\t\t termname());\n\t    PUTS(\"l[oad] <term>    -- load terminal info for type <term>\");\n\t    PUTS(\"d[elete] <cap>   -- delete named capability\");\n\t    PUTS(\"i[nspect]        -- display terminal capabilities\");\n\t    PUTS(\"c[ost]           -- dump cursor-optimization cost table\");\n\t    PUTS(\"o[optimize]      -- toggle movement optimization\");\n\t    PUTS(\"t[orture] <num>  -- torture-test with <num> random moves\");\n\t    PUTS(\"q[uit]           -- quit the program\");\n\t} else if (sscanf(buf, \"%d %d %d %d\", &fy, &fx, &ty, &tx) == 4) {\n\t    struct timeval before, after;\n\n\t    putchar('\"');\n\n\t    gettimeofday(&before, NULL);\n\t    mvcur(fy, fx, ty, tx);\n\t    gettimeofday(&after, NULL);\n\n\t    printf(\"\\\" (%ld msec)\\n\",\n\t\t   (long) (after.tv_usec - before.tv_usec\n\t\t\t   + (after.tv_sec - before.tv_sec)\n\t\t\t   * 1000000));\n\t} else if (sscanf(buf, \"s %d %d %d %d\", &fy, &fx, &ty, &tx) == 4) {\n\t    struct timeval before, after;\n\n\t    putchar('\"');\n\n\t    gettimeofday(&before, NULL);\n\t    _nc_scrolln(fy, fx, ty, tx);\n\t    gettimeofday(&after, NULL);\n\n\t    printf(\"\\\" (%ld msec)\\n\",\n\t\t   (long) (after.tv_usec - before.tv_usec + (after.tv_sec -\n\t\t\t\t\t\t\t     before.tv_sec)\n\t\t\t   * 1000000));\n\t} else if (buf[0] == 'r') {\n\t    _nc_STRCPY(tname, termname(), sizeof(tname));\n\t    load_term();\n\t} else if (sscanf(buf, \"l %s\", tname) == 1) {\n\t    load_term();\n\t} else if (sscanf(buf, \"d %s\", capname) == 1) {\n\t    struct name_table_entry const *np = _nc_find_entry(capname,\n\t\t\t\t\t\t\t       _nc_get_hash_table(FALSE));\n\n\t    if (np == NULL)\n\t\t(void) printf(\"No such capability as \\\"%s\\\"\\n\", capname);\n\t    else {\n\t\tswitch (np->nte_type) {\n\t\tcase BOOLEAN:\n\t\t    cur_term->type.Booleans[np->nte_index] = FALSE;\n\t\t    (void)\n\t\t\tprintf(\"Boolean capability `%s' (%d) turned off.\\n\",\n\t\t\t       np->nte_name, np->nte_index);\n\t\t    break;\n\n\t\tcase NUMBER:\n\t\t    cur_term->type.Numbers[np->nte_index] = ABSENT_NUMERIC;\n\t\t    (void) printf(\"Number capability `%s' (%d) set to -1.\\n\",\n\t\t\t\t  np->nte_name, np->nte_index);\n\t\t    break;\n\n\t\tcase STRING:\n\t\t    cur_term->type.Strings[np->nte_index] = ABSENT_STRING;\n\t\t    (void) printf(\"String capability `%s' (%d) deleted.\\n\",\n\t\t\t\t  np->nte_name, np->nte_index);\n\t\t    break;\n\t\t}\n\t    }\n\t} else if (buf[0] == 'i') {\n\t    dump_init(NULL, F_TERMINFO, S_TERMINFO,\n\t\t      FALSE, 70, 0, 0, FALSE, FALSE, 0);\n\t    dump_entry(&TerminalType(cur_term), FALSE, TRUE, 0, 0);\n\t    putchar('\\n');\n\t} else if (buf[0] == 'o') {\n\t    if (_nc_optimize_enable & OPTIMIZE_MVCUR) {\n\t\t_nc_optimize_enable &= ~OPTIMIZE_MVCUR;\n\t\t(void) puts(\"Optimization is now off.\");\n\t    } else {\n\t\t_nc_optimize_enable |= OPTIMIZE_MVCUR;\n\t\t(void) puts(\"Optimization is now on.\");\n\t    }\n\t}\n\t \n\telse if (sscanf(buf, \"t %d\", &n) == 1) {\n\t    float cumtime = 0.0, perchar;\n\t    int speeds[] =\n\t    {2400, 9600, 14400, 19200, 28800, 38400, 0};\n\n\t    srand((unsigned) (getpid() + time((time_t *) 0)));\n\t    profiling = TRUE;\n\t    xmits = 0;\n\t    for (i = 0; i < n; i++) {\n\t\t \n#ifdef FIND_COREDUMP\n\t\tint from_y = roll(lines);\n\t\tint to_y = roll(lines);\n\t\tint from_x = roll(columns);\n\t\tint to_x = roll(columns);\n\n\t\tprintf(\"(%d,%d) -> (%d,%d)\\n\", from_y, from_x, to_y, to_x);\n\t\tmvcur(from_y, from_x, to_y, to_x);\n#else\n\t\tmvcur(roll(lines), roll(columns), roll(lines), roll(columns));\n#endif  \n\t\tif (diff)\n\t\t    cumtime += diff;\n\t    }\n\t    profiling = FALSE;\n\n\t     \n\t    perchar = cumtime / n;\n\n\t    (void) printf(\"%d moves (%ld chars) in %d msec, %f msec each:\\n\",\n\t\t\t  n, xmits, (int) cumtime, perchar);\n\n\t    for (i = 0; speeds[i]; i++) {\n\t\t \n\t\tfloat totalest = cumtime + xmits * 9 * 1e6 / speeds[i];\n\n\t\t \n\t\tfloat overhead = speeds[i] * perchar / 1e6;\n\n\t\t(void)\n\t\t    printf(\"%6d bps: %3.2f char-xmits overhead; total estimated time %15.2f\\n\",\n\t\t\t   speeds[i], overhead, totalest);\n\t    }\n\t} else if (buf[0] == 'c') {\n\t    (void) printf(\"char padding: %d\\n\", CURRENT_SCREEN->_char_padding);\n\t    (void) printf(\"cr cost: %d\\n\", CURRENT_SCREEN->_cr_cost);\n\t    (void) printf(\"cup cost: %d\\n\", CURRENT_SCREEN->_cup_cost);\n\t    (void) printf(\"home cost: %d\\n\", CURRENT_SCREEN->_home_cost);\n\t    (void) printf(\"ll cost: %d\\n\", CURRENT_SCREEN->_ll_cost);\n#if USE_HARD_TABS\n\t    (void) printf(\"ht cost: %d\\n\", CURRENT_SCREEN->_ht_cost);\n\t    (void) printf(\"cbt cost: %d\\n\", CURRENT_SCREEN->_cbt_cost);\n#endif  \n\t    (void) printf(\"cub1 cost: %d\\n\", CURRENT_SCREEN->_cub1_cost);\n\t    (void) printf(\"cuf1 cost: %d\\n\", CURRENT_SCREEN->_cuf1_cost);\n\t    (void) printf(\"cud1 cost: %d\\n\", CURRENT_SCREEN->_cud1_cost);\n\t    (void) printf(\"cuu1 cost: %d\\n\", CURRENT_SCREEN->_cuu1_cost);\n\t    (void) printf(\"cub cost: %d\\n\", CURRENT_SCREEN->_cub_cost);\n\t    (void) printf(\"cuf cost: %d\\n\", CURRENT_SCREEN->_cuf_cost);\n\t    (void) printf(\"cud cost: %d\\n\", CURRENT_SCREEN->_cud_cost);\n\t    (void) printf(\"cuu cost: %d\\n\", CURRENT_SCREEN->_cuu_cost);\n\t    (void) printf(\"hpa cost: %d\\n\", CURRENT_SCREEN->_hpa_cost);\n\t    (void) printf(\"vpa cost: %d\\n\", CURRENT_SCREEN->_vpa_cost);\n\t} else if (buf[0] == 'x' || buf[0] == 'q')\n\t    break;\n\telse\n\t    (void) puts(\"Invalid command.\");\n    }\n\n    (void) fputs(\"rmcup:\", stdout);\n    _nc_mvcur_wrap();\n    putchar('\\n');\n\n    return (0);\n}\n\n#endif  \n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}