{
  "module_name": "lib_twait.c",
  "hash_id": "1e3194c7b195fa296874a3cf9422f36650d889f94fcc19e56377001018eb0638",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tty/lib_twait.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#if defined __HAIKU__ && defined __BEOS__\n#undef __BEOS__\n#endif\n\n#ifdef __BEOS__\n#undef false\n#undef true\n#include <OS.h>\n#endif\n\n#if USE_KLIBC_KBD\n#define INCL_KBD\n#include <os2.h>\n#endif\n\n#if USE_FUNC_POLL\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# endif\n#elif HAVE_SELECT\n# if HAVE_SYS_TIME_H && HAVE_SYS_TIME_SELECT\n#  include <sys/time.h>\n# endif\n# if HAVE_SYS_SELECT_H\n#  include <sys/select.h>\n# endif\n#endif\n#if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n#endif\n#undef CUR\n\nMODULE_ID(\"$Id: lib_twait.c,v 1.75 2020/02/29 15:46:00 anonymous.maarten Exp $\")\n\nstatic long\n_nc_gettime(TimeType * t0, int first)\n{\n    long res;\n\n#if PRECISE_GETTIME\n    TimeType t1;\n    gettimeofday(&t1, (struct timezone *) 0);\n    if (first) {\n\t*t0 = t1;\n\tres = 0;\n    } else {\n\t \n\tif (t0->tv_usec > t1.tv_usec) {\n\t    t1.tv_usec += 1000000;\t \n\t    t1.tv_sec--;\n\t}\n\tres = (t1.tv_sec - t0->tv_sec) * 1000\n\t    + (t1.tv_usec - t0->tv_usec) / 1000;\n    }\n#else\n    time_t t1 = time((time_t *) 0);\n    if (first) {\n\t*t0 = t1;\n    }\n    res = (long) ((t1 - *t0) * 1000);\n#endif\n    TR(TRACE_IEVENT, (\"%s time: %ld msec\", first ? \"get\" : \"elapsed\", res));\n    return res;\n}\n\n#ifdef NCURSES_WGETCH_EVENTS\nNCURSES_EXPORT(int)\n_nc_eventlist_timeout(_nc_eventlist * evl)\n{\n    int event_delay = -1;\n\n    if (evl != 0) {\n\tint n;\n\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_TIMEOUT_MSEC) {\n\t\tevent_delay = (int) ev->data.timeout_msec;\n\t\tif (event_delay < 0)\n\t\t    event_delay = INT_MAX;\t \n\t    }\n\t}\n    }\n    return event_delay;\n}\n#endif  \n\n#if (USE_FUNC_POLL || HAVE_SELECT)\n#  define MAYBE_UNUSED\n#else\n#  define MAYBE_UNUSED GCC_UNUSED\n#endif\n\n#if (USE_FUNC_POLL || HAVE_SELECT)\n#  define MAYBE_UNUSED\n#else\n#  define MAYBE_UNUSED GCC_UNUSED\n#endif\n\n \nNCURSES_EXPORT(int)\n_nc_timed_wait(SCREEN *sp MAYBE_UNUSED,\n\t       int mode MAYBE_UNUSED,\n\t       int milliseconds,\n\t       int *timeleft\n\t       EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int count;\n    int result = TW_NONE;\n    TimeType t0;\n#if (USE_FUNC_POLL || HAVE_SELECT)\n    int fd;\n#endif\n\n#ifdef NCURSES_WGETCH_EVENTS\n    int timeout_is_event = 0;\n    int n;\n#endif\n\n#if USE_FUNC_POLL\n#define MIN_FDS 2\n    struct pollfd fd_list[MIN_FDS];\n    struct pollfd *fds = fd_list;\n#elif defined(__BEOS__)\n#elif HAVE_SELECT\n    fd_set set;\n#endif\n\n#if USE_KLIBC_KBD\n    fd_set saved_set;\n    KBDKEYINFO ki;\n    struct timeval tv;\n#endif\n\n    long starttime, returntime;\n\n#ifdef NCURSES_WGETCH_EVENTS\n    (void) timeout_is_event;\n#endif\n\n    TR(TRACE_IEVENT, (\"start twait: %d milliseconds, mode: %d\",\n\t\t      milliseconds, mode));\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if (mode & TW_EVENT) {\n\tint event_delay = _nc_eventlist_timeout(evl);\n\n\tif (event_delay >= 0\n\t    && (milliseconds >= event_delay || milliseconds < 0)) {\n\t    milliseconds = event_delay;\n\t    timeout_is_event = 1;\n\t}\n    }\n#endif\n\n#if PRECISE_GETTIME && HAVE_NANOSLEEP\n  retry:\n#endif\n    starttime = _nc_gettime(&t0, TRUE);\n\n    count = 0;\n    (void) count;\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl)\n\tevl->result_flags = 0;\n#endif\n\n#if USE_FUNC_POLL\n    memset(fd_list, 0, sizeof(fd_list));\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tif (fds == fd_list)\n\t    fds = typeMalloc(struct pollfd, MIN_FDS + evl->count);\n\tif (fds == 0)\n\t    return TW_NONE;\n    }\n#endif\n\n    if (mode & TW_INPUT) {\n\tfds[count].fd = sp->_ifd;\n\tfds[count].events = POLLIN;\n\tcount++;\n    }\n    if ((mode & TW_MOUSE)\n\t&& (fd = sp->_mouse_fd) >= 0) {\n\tfds[count].fd = fd;\n\tfds[count].events = POLLIN;\n\tcount++;\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tfds[count].fd = ev->data.fev.fd;\n\t\tfds[count].events = POLLIN;\n\t\tcount++;\n\t    }\n\t}\n    }\n#endif\n\n    result = poll(fds, (size_t) count, milliseconds);\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tint c;\n\n\tif (!result)\n\t    count = 0;\n\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tev->data.fev.result = 0;\n\t\tfor (c = 0; c < count; c++)\n\t\t    if (fds[c].fd == ev->data.fev.fd\n\t\t\t&& fds[c].revents & POLLIN) {\n\t\t\tev->data.fev.result |= _NC_EVENT_FILE_READABLE;\n\t\t\tevl->result_flags |= _NC_EVENT_FILE_READABLE;\n\t\t    }\n\t    } else if (ev->type == _NC_EVENT_TIMEOUT_MSEC\n\t\t       && !result && timeout_is_event) {\n\t\tevl->result_flags |= _NC_EVENT_TIMEOUT_MSEC;\n\t    }\n\t}\n    }\n#endif\n\n#elif defined(__BEOS__)\n     \n    result = TW_NONE;\n    if (mode & TW_INPUT) {\n\tint step = (milliseconds < 0) ? 0 : 5000;\n\tbigtime_t d;\n\tbigtime_t useconds = milliseconds * 1000;\n\tint n, howmany;\n\n\tif (useconds <= 0)\t \n\t    useconds = 1;\n\n\tfor (d = 0; d < useconds; d += step) {\n\t    n = 0;\n\t    howmany = ioctl(0, 'ichr', &n);\n\t    if (howmany >= 0 && n > 0) {\n\t\tresult = 1;\n\t\tbreak;\n\t    }\n\t    if (useconds > 1 && step > 0) {\n\t\tsnooze(step);\n\t\tmilliseconds -= (step / 1000);\n\t\tif (milliseconds <= 0) {\n\t\t    milliseconds = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    } else if (milliseconds > 0) {\n\tsnooze(milliseconds * 1000);\n\tmilliseconds = 0;\n    }\n#elif HAVE_SELECT\n     \n    FD_ZERO(&set);\n\n#if !USE_KLIBC_KBD\n    if (mode & TW_INPUT) {\n\tFD_SET(sp->_ifd, &set);\n\tcount = sp->_ifd + 1;\n    }\n#endif\n    if ((mode & TW_MOUSE)\n\t&& (fd = sp->_mouse_fd) >= 0) {\n\tFD_SET(fd, &set);\n\tcount = max(fd, count) + 1;\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tFD_SET(ev->data.fev.fd, &set);\n\t\tcount = max(ev->data.fev.fd + 1, count);\n\t    }\n\t}\n    }\n#endif\n\n#if USE_KLIBC_KBD\n    for (saved_set = set;; set = saved_set) {\n\tif ((mode & TW_INPUT)\n\t    && (sp->_extended_key\n\t\t|| (KbdPeek(&ki, 0) == 0\n\t\t    && (ki.fbStatus & KBDTRF_FINAL_CHAR_IN)))) {\n\t    FD_ZERO(&set);\n\t    FD_SET(sp->_ifd, &set);\n\t    result = 1;\n\t    break;\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = (milliseconds == 0) ? 0 : (10 * 1000);\n\n\tif ((result = select(count, &set, NULL, NULL, &tv)) != 0)\n\t    break;\n\n\t \n\tif (milliseconds >= 0 && _nc_gettime(&t0, FALSE) >= milliseconds) {\n\t    result = 0;\n\t    break;\n\t}\n    }\n#else\n    if (milliseconds >= 0) {\n\tstruct timeval ntimeout;\n\tntimeout.tv_sec = milliseconds / 1000;\n\tntimeout.tv_usec = (milliseconds % 1000) * 1000;\n\tresult = select(count, &set, NULL, NULL, &ntimeout);\n    } else {\n\tresult = select(count, &set, NULL, NULL, NULL);\n    }\n#endif\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl) {\n\tevl->result_flags = 0;\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_FILE\n\t\t&& (ev->data.fev.flags & _NC_EVENT_FILE_READABLE)) {\n\t\tev->data.fev.result = 0;\n\t\tif (FD_ISSET(ev->data.fev.fd, &set)) {\n\t\t    ev->data.fev.result |= _NC_EVENT_FILE_READABLE;\n\t\t    evl->result_flags |= _NC_EVENT_FILE_READABLE;\n\t\t}\n\t    } else if (ev->type == _NC_EVENT_TIMEOUT_MSEC\n\t\t       && !result && timeout_is_event)\n\t\tevl->result_flags |= _NC_EVENT_TIMEOUT_MSEC;\n\t}\n    }\n#endif\n\n#endif  \n\n    returntime = _nc_gettime(&t0, FALSE);\n\n    if (milliseconds >= 0)\n\tmilliseconds -= (int) (returntime - starttime);\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if (evl) {\n\tevl->result_flags = 0;\n\tfor (n = 0; n < evl->count; ++n) {\n\t    _nc_event *ev = evl->events[n];\n\n\t    if (ev->type == _NC_EVENT_TIMEOUT_MSEC) {\n\t\tlong diff = (returntime - starttime);\n\t\tif (ev->data.timeout_msec <= diff)\n\t\t    ev->data.timeout_msec = 0;\n\t\telse\n\t\t    ev->data.timeout_msec -= diff;\n\t    }\n\n\t}\n    }\n#endif\n\n#if PRECISE_GETTIME && HAVE_NANOSLEEP\n     \n    if (result == 0 && milliseconds > 100) {\n\tnapms(100);\t\t \n\tmilliseconds -= 100;\n\tgoto retry;\n    }\n#endif\n\n     \n    if (timeleft)\n\t*timeleft = milliseconds;\n\n    TR(TRACE_IEVENT, (\"end twait: returned %d (%d), remaining time %d msec\",\n\t\t      result, errno, milliseconds));\n\n     \n    if (result != 0) {\n\tif (result > 0) {\n\t    result = 0;\n#if USE_FUNC_POLL\n\t    for (count = 0; count < MIN_FDS; count++) {\n\t\tif ((mode & (1 << count))\n\t\t    && (fds[count].revents & POLLIN)) {\n\t\t    result |= (1 << count);\n\t\t}\n\t    }\n#elif defined(__BEOS__)\n\t    result = TW_INPUT;\t \n#elif HAVE_SELECT\n\t    if ((mode & TW_MOUSE)\n\t\t&& (fd = sp->_mouse_fd) >= 0\n\t\t&& FD_ISSET(fd, &set))\n\t\tresult |= TW_MOUSE;\n\t    if ((mode & TW_INPUT)\n\t\t&& FD_ISSET(sp->_ifd, &set))\n\t\tresult |= TW_INPUT;\n#endif\n\t} else\n\t    result = 0;\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if ((mode & TW_EVENT) && evl && evl->result_flags)\n\tresult |= TW_EVENT;\n#endif\n\n#if USE_FUNC_POLL\n#ifdef NCURSES_WGETCH_EVENTS\n    if (fds != fd_list)\n\tfree((char *) fds);\n#endif\n#endif\n\n    return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}