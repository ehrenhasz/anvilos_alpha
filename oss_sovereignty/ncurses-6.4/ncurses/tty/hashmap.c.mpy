{
  "module_name": "hashmap.c",
  "hash_id": "e70d4599d3e0435cf2244fccace07462fe2c34404b3dea0735f50f5f680bed66",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tty/hashmap.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: hashmap.c,v 1.69 2020/05/31 17:50:48 tom Exp $\")\n\n#ifdef HASHDEBUG\n\n# define _tracef\tprintf\n# undef TR\n# ifdef TRACE\n# define TR(n, a)\tif (_nc_tracing & (n)) { _tracef a ; putchar('\\n'); }\n# else\n# define TR(n, a)\t{ _tracef a ; putchar('\\n'); }\n# endif\n# undef screen_lines\n# define screen_lines(sp) MAXLINES\n# define TEXTWIDTH(sp)\t1\nstatic int oldnums[MAXLINES], reallines[MAXLINES];\nstatic NCURSES_CH_T oldtext[MAXLINES][TEXTWIDTH(sp)];\nstatic NCURSES_CH_T newtext[MAXLINES][TEXTWIDTH(sp)];\n# define OLDNUM(sp,n)\toldnums[n]\n# define OLDTEXT(sp,n)\toldtext[n]\n# define NEWTEXT(sp,m)\tnewtext[m]\n# define PENDING(sp,n)  1\n\n#else  \n\n# define OLDNUM(sp,n)\t(sp)->_oldnum_list[n]\n# define OLDTEXT(sp,n)\tCurScreen(sp)->_line[n].text\n# define NEWTEXT(sp,m)\tNewScreen(sp)->_line[m].text\n# define TEXTWIDTH(sp)\t(CurScreen(sp)->_maxx + 1)\n# define PENDING(sp,n)  (NewScreen(sp)->_line[n].firstchar != _NOCHANGE)\n\n#endif  \n\n#define oldhash(sp)\t((sp)->oldhash)\n#define newhash(sp)\t((sp)->newhash)\n#define hashtab(sp)\t((sp)->hashtab)\n#define lines_alloc(sp)\t((sp)->hashtab_len)\n\n#if USE_WIDEC_SUPPORT\n#define HASH_VAL(ch) (ch.chars[0])\n#else\n#define HASH_VAL(ch) (ch)\n#endif\n\nstatic const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);\n\nstatic NCURSES_INLINE unsigned long\nhash(SCREEN *sp, NCURSES_CH_T *text)\n{\n    int i;\n    NCURSES_CH_T ch;\n    unsigned long result = 0;\n    (void) sp;\n\n    for (i = TEXTWIDTH(sp); i > 0; i--) {\n\tch = *text++;\n\tresult += (result << 5) + (unsigned long) HASH_VAL(ch);\n    }\n    return result;\n}\n\n \nstatic int\nupdate_cost(SCREEN *sp, NCURSES_CH_T *from, NCURSES_CH_T *to)\n{\n    int cost = 0;\n    int i;\n    (void) sp;\n\n    for (i = TEXTWIDTH(sp); i > 0; i--, from++, to++)\n\tif (!(CharEq(*from, *to)))\n\t    cost++;\n\n    return cost;\n}\n\nstatic int\nupdate_cost_from_blank(SCREEN *sp, NCURSES_CH_T *to)\n{\n    int cost = 0;\n    int i;\n    NCURSES_CH_T blank = blankchar;\n    (void) sp;\n\n    if (back_color_erase)\n\tSetPair(blank, GetPair(stdscr->_nc_bkgd));\n\n    for (i = TEXTWIDTH(sp); i > 0; i--, to++)\n\tif (!(CharEq(blank, *to)))\n\t    cost++;\n\n    return cost;\n}\n\n \nstatic NCURSES_INLINE bool\ncost_effective(SCREEN *sp, const int from, const int to, const int blank)\n{\n    int new_from;\n\n    if (from == to)\n\treturn FALSE;\n\n    new_from = OLDNUM(sp, from);\n    if (new_from == _NEWINDEX)\n\tnew_from = from;\n\n     \n    return (((blank ? update_cost_from_blank(sp, NEWTEXT(sp, to))\n\t      : update_cost(sp, OLDTEXT(sp, to), NEWTEXT(sp, to)))\n\t     + update_cost(sp, OLDTEXT(sp, new_from), NEWTEXT(sp, from)))\n\t    >= ((new_from == from ? update_cost_from_blank(sp, NEWTEXT(sp, from))\n\t\t : update_cost(sp, OLDTEXT(sp, new_from), NEWTEXT(sp, from)))\n\t\t+ update_cost(sp, OLDTEXT(sp, from), NEWTEXT(sp, to))))\n\t? TRUE : FALSE;\n}\n\nstatic void\ngrow_hunks(SCREEN *sp)\n{\n    int back_limit;\t\t \n    int back_ref_limit;\t\t \n    int i;\n    int next_hunk;\n\n     \n    back_limit = 0;\n    back_ref_limit = 0;\n\n    i = 0;\n    while (i < screen_lines(sp) && OLDNUM(sp, i) == _NEWINDEX)\n\ti++;\n    for (; i < screen_lines(sp); i = next_hunk) {\n\tint forward_limit;\n\tint forward_ref_limit;\n\tint end;\n\tint start = i;\n\tint shift = OLDNUM(sp, i) - i;\n\n\t \n\ti = start + 1;\n\twhile (i < screen_lines(sp)\n\t       && OLDNUM(sp, i) != _NEWINDEX\n\t       && OLDNUM(sp, i) - i == shift)\n\t    i++;\n\tend = i;\n\twhile (i < screen_lines(sp) && OLDNUM(sp, i) == _NEWINDEX)\n\t    i++;\n\tnext_hunk = i;\n\tforward_limit = i;\n\tif (i >= screen_lines(sp) || OLDNUM(sp, i) >= i)\n\t    forward_ref_limit = i;\n\telse\n\t    forward_ref_limit = OLDNUM(sp, i);\n\n\ti = start - 1;\n\t \n\tif (shift < 0)\n\t    back_limit = back_ref_limit + (-shift);\n\twhile (i >= back_limit) {\n\t    if (newhash(sp)[i] == oldhash(sp)[i + shift]\n\t\t|| cost_effective(sp, i + shift, i, shift < 0)) {\n\t\tOLDNUM(sp, i) = i + shift;\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"connected new line %d to old line %d (backward continuation)\",\n\t\t    i, i + shift));\n\t    } else {\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"not connecting new line %d to old line %d (backward continuation)\",\n\t\t    i, i + shift));\n\t\tbreak;\n\t    }\n\t    i--;\n\t}\n\n\ti = end;\n\t \n\tif (shift > 0)\n\t    forward_limit = forward_ref_limit - shift;\n\twhile (i < forward_limit) {\n\t    if (newhash(sp)[i] == oldhash(sp)[i + shift]\n\t\t|| cost_effective(sp, i + shift, i, shift > 0)) {\n\t\tOLDNUM(sp, i) = i + shift;\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"connected new line %d to old line %d (forward continuation)\",\n\t\t    i, i + shift));\n\t    } else {\n\t\tTR(TRACE_UPDATE | TRACE_MOVE,\n\t\t   (\"not connecting new line %d to old line %d (forward continuation)\",\n\t\t    i, i + shift));\n\t\tbreak;\n\t    }\n\t    i++;\n\t}\n\n\tback_ref_limit = back_limit = i;\n\tif (shift > 0)\n\t    back_ref_limit += shift;\n    }\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_hash_map) (NCURSES_SP_DCL0)\n{\n    HASHMAP *hsp;\n    register int i;\n\n    if (screen_lines(SP_PARM) > lines_alloc(SP_PARM)) {\n\tif (hashtab(SP_PARM))\n\t    free(hashtab(SP_PARM));\n\thashtab(SP_PARM) = typeMalloc(HASHMAP,\n\t\t\t\t      ((size_t) screen_lines(SP_PARM) + 1) * 2);\n\tif (!hashtab(SP_PARM)) {\n\t    if (oldhash(SP_PARM)) {\n\t\tFreeAndNull(oldhash(SP_PARM));\n\t    }\n\t    lines_alloc(SP_PARM) = 0;\n\t    return;\n\t}\n\tlines_alloc(SP_PARM) = screen_lines(SP_PARM);\n    }\n\n    if (oldhash(SP_PARM) && newhash(SP_PARM)) {\n\t \n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    if (PENDING(SP_PARM, i))\n\t\tnewhash(SP_PARM)[i] = hash(SP_PARM, NEWTEXT(SP_PARM, i));\n\t}\n    } else {\n\t \n\tif (oldhash(SP_PARM) == 0)\n\t    oldhash(SP_PARM) = typeCalloc(unsigned long,\n\t\t\t\t\t    (size_t) screen_lines(SP_PARM));\n\tif (newhash(SP_PARM) == 0)\n\t    newhash(SP_PARM) = typeCalloc(unsigned long,\n\t\t\t\t\t    (size_t) screen_lines(SP_PARM));\n\tif (!oldhash(SP_PARM) || !newhash(SP_PARM))\n\t    return;\t\t \n\tfor (i = 0; i < screen_lines(SP_PARM); i++) {\n\t    newhash(SP_PARM)[i] = hash(SP_PARM, NEWTEXT(SP_PARM, i));\n\t    oldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n\t}\n    }\n\n#ifdef HASH_VERIFY\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tif (newhash(SP_PARM)[i] != hash(SP_PARM, NEWTEXT(SP_PARM, i)))\n\t    fprintf(stderr, \"error in newhash[%d]\\n\", i);\n\tif (oldhash(SP_PARM)[i] != hash(SP_PARM, OLDTEXT(SP_PARM, i)))\n\t    fprintf(stderr, \"error in oldhash[%d]\\n\", i);\n    }\n#endif\n\n     \n    memset(hashtab(SP_PARM), '\\0',\n\t   sizeof(*(hashtab(SP_PARM)))\n\t   * ((size_t) screen_lines(SP_PARM) + 1) * 2);\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tunsigned long hashval = oldhash(SP_PARM)[i];\n\n\tfor (hsp = hashtab(SP_PARM); hsp->hashval; hsp++)\n\t    if (hsp->hashval == hashval)\n\t\tbreak;\n\thsp->hashval = hashval;\t \n\thsp->oldcount++;\n\thsp->oldindex = i;\n    }\n    for (i = 0; i < screen_lines(SP_PARM); i++) {\n\tunsigned long hashval = newhash(SP_PARM)[i];\n\n\tfor (hsp = hashtab(SP_PARM); hsp->hashval; hsp++)\n\t    if (hsp->hashval == hashval)\n\t\tbreak;\n\thsp->hashval = hashval;\t \n\thsp->newcount++;\n\thsp->newindex = i;\n\n\tOLDNUM(SP_PARM, i) = _NEWINDEX;\t\t \n    }\n\n     \n    for (hsp = hashtab(SP_PARM); hsp->hashval; hsp++)\n\tif (hsp->oldcount == 1 && hsp->newcount == 1\n\t    && hsp->oldindex != hsp->newindex) {\n\t    TR(TRACE_UPDATE | TRACE_MOVE,\n\t       (\"new line %d is hash-identical to old line %d (unique)\",\n\t\thsp->newindex, hsp->oldindex));\n\t    OLDNUM(SP_PARM, hsp->newindex) = hsp->oldindex;\n\t}\n\n    grow_hunks(SP_PARM);\n\n     \n    for (i = 0; i < screen_lines(SP_PARM);) {\n\tint start, shift, size;\n\n\twhile (i < screen_lines(SP_PARM) && OLDNUM(SP_PARM, i) == _NEWINDEX)\n\t    i++;\n\tif (i >= screen_lines(SP_PARM))\n\t    break;\n\tstart = i;\n\tshift = OLDNUM(SP_PARM, i) - i;\n\ti++;\n\twhile (i < screen_lines(SP_PARM)\n\t       && OLDNUM(SP_PARM, i) != _NEWINDEX\n\t       && OLDNUM(SP_PARM, i) - i == shift)\n\t    i++;\n\tsize = i - start;\n\tif (size < 3 || size + min(size / 8, 2) < abs(shift)) {\n\t    while (start < i) {\n\t\tOLDNUM(SP_PARM, start) = _NEWINDEX;\n\t\tstart++;\n\t    }\n\t}\n    }\n\n     \n    grow_hunks(SP_PARM);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_hash_map(void)\n{\n    NCURSES_SP_NAME(_nc_hash_map) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_make_oldhash) (NCURSES_SP_DCLx int i)\n{\n    if (oldhash(SP_PARM))\n\toldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_make_oldhash(int i)\n{\n    NCURSES_SP_NAME(_nc_make_oldhash) (CURRENT_SCREEN, i);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_scroll_oldhash) (NCURSES_SP_DCLx int n, int top, int bot)\n{\n    size_t size;\n    int i;\n\n    if (!oldhash(SP_PARM))\n\treturn;\n\n    size = sizeof(*(oldhash(SP_PARM))) * (size_t) (bot - top + 1 - abs(n));\n    if (n > 0) {\n\tmemmove(oldhash(SP_PARM) + top, oldhash(SP_PARM) + top + n, size);\n\tfor (i = bot; i > bot - n; i--)\n\t    oldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n    } else {\n\tmemmove(oldhash(SP_PARM) + top - n, oldhash(SP_PARM) + top, size);\n\tfor (i = top; i < top - n; i++)\n\t    oldhash(SP_PARM)[i] = hash(SP_PARM, OLDTEXT(SP_PARM, i));\n    }\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_scroll_oldhash(int n, int top, int bot)\n{\n    NCURSES_SP_NAME(_nc_scroll_oldhash) (CURRENT_SCREEN, n, top, bot);\n}\n#endif\n\n#ifdef HASHDEBUG\nstatic void\nusage(void)\n{\n    static const char *table[] =\n    {\n\t\"hashmap test-driver\",\n\t\"\",\n\t\"#  comment\",\n\t\"l  get initial line number vector\",\n\t\"n  use following letters as text of new lines\",\n\t\"o  use following letters as text of old lines\",\n\t\"d  dump state of test arrays\",\n\t\"h  apply hash mapper and see scroll optimization\",\n\t\"?  this message\"\n    };\n    size_t n;\n    for (n = 0; n < sizeof(table) / sizeof(table[0]); n++)\n\tfprintf(stderr, \"%s\\n\", table[n]);\n}\n\nint\nmain(int argc GCC_UNUSED, char *argv[]GCC_UNUSED)\n{\n    char line[BUFSIZ], *st;\n    int n;\n\n    if (setupterm(NULL, fileno(stdout), (int *) 0) == ERR)\n\treturn EXIT_FAILURE;\n    (void) _nc_alloc_screen();\n\n    for (n = 0; n < screen_lines(sp); n++) {\n\treallines[n] = n;\n\toldnums[n] = _NEWINDEX;\n\tCharOf(oldtext[n][0]) = CharOf(newtext[n][0]) = '.';\n    }\n\n    if (NC_ISATTY(fileno(stdin)))\n\tusage();\n\n#ifdef TRACE\n    _nc_tracing = TRACE_MOVE;\n#endif\n    for (;;) {\n\t \n\tif (fgets(line, sizeof(line), stdin) == (char *) NULL)\n\t    break;\n\n\tswitch (line[0]) {\n\tcase '#':\t\t \n\t    (void) fputs(line, stderr);\n\t    break;\n\n\tcase 'l':\t\t \n\t    for (n = 0; n < screen_lines(sp); n++) {\n\t\treallines[n] = n;\n\t\toldnums[n] = _NEWINDEX;\n\t    }\n\t    n = 0;\n\t    st = strtok(line, \" \");\n\t    do {\n\t\toldnums[n++] = atoi(st);\n\t    } while\n\t\t((st = strtok((char *) NULL, \" \")) != 0);\n\t    break;\n\n\tcase 'n':\t\t \n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tCharOf(newtext[n][0]) = '.';\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tif (line[n + 1] == '\\n')\n\t\t    break;\n\t\telse\n\t\t    CharOf(newtext[n][0]) = line[n + 1];\n\t    break;\n\n\tcase 'o':\t\t \n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tCharOf(oldtext[n][0]) = '.';\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tif (line[n + 1] == '\\n')\n\t\t    break;\n\t\telse\n\t\t    CharOf(oldtext[n][0]) = line[n + 1];\n\t    break;\n\n\tcase 'd':\t\t \n#ifdef TRACE\n\t    _nc_linedump();\n#endif\n\t    (void) fputs(\"Old lines: [\", stdout);\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tputchar(CharOf(oldtext[n][0]));\n\t    putchar(']');\n\t    putchar('\\n');\n\t    (void) fputs(\"New lines: [\", stdout);\n\t    for (n = 0; n < screen_lines(sp); n++)\n\t\tputchar(CharOf(newtext[n][0]));\n\t    putchar(']');\n\t    putchar('\\n');\n\t    break;\n\n\tcase 'h':\t\t \n\t    _nc_hash_map();\n\t    (void) fputs(\"Result:\\n\", stderr);\n#ifdef TRACE\n\t    _nc_linedump();\n#endif\n\t    _nc_scroll_optimize();\n\t    (void) fputs(\"Done.\\n\", stderr);\n\t    break;\n\tdefault:\n\tcase '?':\n\t    usage();\n\t    break;\n\t}\n    }\n    exit_curses(EXIT_SUCCESS);\n}\n\n#endif  \n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}