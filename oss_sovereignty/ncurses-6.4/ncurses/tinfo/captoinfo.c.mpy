{
  "module_name": "captoinfo.c",
  "hash_id": "deafca59fae2c81a5ac71159714a0363354d6c77885381e5f63f41820f99355a",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/captoinfo.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: captoinfo.c,v 1.102 2021/09/04 10:29:15 tom Exp $\")\n\n#if 0\n#define DEBUG_THIS(p) DEBUG(9, p)\n#else\n#define DEBUG_THIS(p)\t\t \n#endif\n\n#define MAX_PUSHED\t16\t \n\nstatic int stack[MAX_PUSHED];\t \nstatic int stackptr;\t\t \nstatic int onstack;\t\t \nstatic int seenm;\t\t \nstatic int seenn;\t\t \nstatic int seenr;\t\t \nstatic int param;\t\t \nstatic char *dp;\t\t \n\nstatic char *my_string;\nstatic size_t my_length;\n\nstatic char *\ninit_string(void)\n \n{\n    if (my_string == 0)\n\tTYPE_MALLOC(char, my_length = 256, my_string);\n\n    *my_string = '\\0';\n    return my_string;\n}\n\nstatic char *\nsave_string(char *d, const char *const s)\n{\n    size_t have = (size_t) (d - my_string);\n    size_t need = have + strlen(s) + 2;\n    if (need > my_length) {\n\tmy_string = (char *) _nc_doalloc(my_string, my_length = (need + need));\n\tif (my_string == 0)\n\t    _nc_err_abort(MSG_NO_MEMORY);\n\td = my_string + have;\n    }\n    _nc_STRCPY(d, s, my_length - have);\n    return d + strlen(d);\n}\n\nstatic NCURSES_INLINE char *\nsave_char(char *s, int c)\n{\n    static char temp[2];\n    temp[0] = (char) c;\n    return save_string(s, temp);\n}\n\nstatic void\npush(void)\n \n{\n    if (stackptr >= MAX_PUSHED)\n\t_nc_warning(\"string too complex to convert\");\n    else\n\tstack[stackptr++] = onstack;\n}\n\nstatic void\npop(void)\n \n{\n    if (stackptr == 0) {\n\tif (onstack == 0)\n\t    _nc_warning(\"I'm confused\");\n\telse\n\t    onstack = 0;\n    } else\n\tonstack = stack[--stackptr];\n    param++;\n}\n\nstatic int\ncvtchar(register const char *sp)\n \n{\n    unsigned char c = 0;\n    int len;\n\n    switch (*sp) {\n    case '\\\\':\n\tswitch (*++sp) {\n\tcase '\\'':\n\tcase '$':\n\tcase '\\\\':\n\tcase '%':\n\t    c = UChar(*sp);\n\t    len = 2;\n\t    break;\n\tcase '\\0':\n\t    c = '\\\\';\n\t    len = 1;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    len = 1;\n\t    while (isdigit(UChar(*sp))) {\n\t\tc = UChar(8 * c + (*sp++ - '0'));\n\t\tlen++;\n\t    }\n\t    break;\n\tdefault:\n\t    c = UChar(*sp);\n\t    len = (c != '\\0') ? 2 : 1;\n\t    break;\n\t}\n\tbreak;\n    case '^':\n\tlen = 2;\n\tc = UChar(*++sp);\n\tif (c == '?') {\n\t    c = 127;\n\t} else if (c == '\\0') {\n\t    len = 1;\n\t} else {\n\t    c &= 0x1f;\n\t}\n\tbreak;\n    default:\n\tc = UChar(*sp);\n\tlen = (c != '\\0') ? 1 : 0;\n    }\n    if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n\tdp = save_string(dp, \"%\\'\");\n\tdp = save_char(dp, c);\n\tdp = save_char(dp, '\\'');\n    } else if (c != '\\0') {\n\tdp = save_string(dp, \"%{\");\n\tif (c > 99)\n\t    dp = save_char(dp, c / 100 + '0');\n\tif (c > 9)\n\t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n\tdp = save_char(dp, c % 10 + '0');\n\tdp = save_char(dp, '}');\n    }\n    return len;\n}\n\nstatic void\ngetparm(int parm, int n)\n \n{\n    int nn;\n\n    if (seenr) {\n\tif (parm == 1)\n\t    parm = 2;\n\telse if (parm == 2)\n\t    parm = 1;\n    }\n\n    for (nn = 0; nn < n; ++nn) {\n\tdp = save_string(dp, \"%p\");\n\tdp = save_char(dp, '0' + parm);\n    }\n\n    if (onstack == parm) {\n\tif (n > 1) {\n\t    _nc_warning(\"string may not be optimal\");\n\t    dp = save_string(dp, \"%Pa\");\n\t    while (n-- > 0) {\n\t\tdp = save_string(dp, \"%ga\");\n\t    }\n\t}\n\treturn;\n    }\n    if (onstack != 0)\n\tpush();\n\n    onstack = parm;\n\n    if (seenn && parm < 3) {\n\tdp = save_string(dp, \"%{96}%^\");\n    }\n\n    if (seenm && parm < 3) {\n\tdp = save_string(dp, \"%{127}%^\");\n    }\n}\n\n \nNCURSES_EXPORT(char *)\n_nc_captoinfo(const char *cap, const char *s, int const parameterized)\n{\n    const char *capstart;\n\n    stackptr = 0;\n    onstack = 0;\n    seenm = 0;\n    seenn = 0;\n    seenr = 0;\n    param = 1;\n\n    DEBUG_THIS((\"_nc_captoinfo params %d, %s\", parameterized, s));\n\n    dp = init_string();\n\n     \n    capstart = 0;\n    if (s == 0)\n\ts = \"\";\n    if (parameterized >= 0 && isdigit(UChar(*s)))\n\tfor (capstart = s; *s != '\\0'; s++)\n\t    if (!(isdigit(UChar(*s)) || *s == '*' || *s == '.'))\n\t\tbreak;\n\n    while (*s != '\\0') {\n\tswitch (*s) {\n\tcase '%':\n\t    s++;\n\t    if (parameterized < 1) {\n\t\tdp = save_char(dp, '%');\n\t\tbreak;\n\t    }\n\t    switch (*s++) {\n\t    case '%':\n\t\tdp = save_string(dp, \"%%\");\n\t\tbreak;\n\t    case 'r':\n\t\tif (seenr++ == 1) {\n\t\t    _nc_warning(\"saw %%r twice in %s\", cap);\n\t\t}\n\t\tbreak;\n\t    case 'm':\n\t\tif (seenm++ == 1) {\n\t\t    _nc_warning(\"saw %%m twice in %s\", cap);\n\t\t}\n\t\tbreak;\n\t    case 'n':\n\t\tif (seenn++ == 1) {\n\t\t    _nc_warning(\"saw %%n twice in %s\", cap);\n\t\t}\n\t\tbreak;\n\t    case 'i':\n\t\tdp = save_string(dp, \"%i\");\n\t\tbreak;\n\t    case '6':\n\t    case 'B':\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%{10}%/%{16}%*\");\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%{10}%m%+\");\n\t\tbreak;\n\t    case '8':\n\t    case 'D':\n\t\tgetparm(param, 2);\n\t\tdp = save_string(dp, \"%{2}%*%-\");\n\t\tbreak;\n\t    case '>':\n\t\t \n\t\tif (s[0] && s[1]) {\n\t\t    getparm(param, 2);\n\t\t    dp = save_string(dp, \"%?\");\n\t\t    s += cvtchar(s);\n\t\t    dp = save_string(dp, \"%>%t\");\n\t\t    s += cvtchar(s);\n\t\t    dp = save_string(dp, \"%+%;\");\n\t\t} else {\n\t\t    _nc_warning(\"expected two characters after %%>\");\n\t\t    dp = save_string(dp, \"%>\");\n\t\t}\n\t\tbreak;\n\t    case 'a':\n\t\tif ((*s == '=' || *s == '+' || *s == '-'\n\t\t     || *s == '*' || *s == '/')\n\t\t    && (s[1] == 'p' || s[1] == 'c')\n\t\t    && s[2] != '\\0') {\n\t\t    int l;\n\t\t    l = 2;\n\t\t    if (*s != '=')\n\t\t\tgetparm(param, 1);\n\t\t    if (s[1] == 'p') {\n\t\t\tgetparm(param + s[2] - '@', 1);\n\t\t\tif (param != onstack) {\n\t\t\t    pop();\n\t\t\t    param--;\n\t\t\t}\n\t\t\tl++;\n\t\t    } else\n\t\t\tl += cvtchar(s + 2);\n\t\t    switch (*s) {\n\t\t    case '+':\n\t\t\tdp = save_string(dp, \"%+\");\n\t\t\tbreak;\n\t\t    case '-':\n\t\t\tdp = save_string(dp, \"%-\");\n\t\t\tbreak;\n\t\t    case '*':\n\t\t\tdp = save_string(dp, \"%*\");\n\t\t\tbreak;\n\t\t    case '/':\n\t\t\tdp = save_string(dp, \"%/\");\n\t\t\tbreak;\n\t\t    case '=':\n\t\t\tif (seenr) {\n\t\t\t    if (param == 1)\n\t\t\t\tonstack = 2;\n\t\t\t    else if (param == 2)\n\t\t\t\tonstack = 1;\n\t\t\t    else\n\t\t\t\tonstack = param;\n\t\t\t} else\n\t\t\t    onstack = param;\n\t\t\tbreak;\n\t\t    }\n\t\t    s += l;\n\t\t    break;\n\t\t}\n\t\tgetparm(param, 1);\n\t\ts += cvtchar(s);\n\t\tdp = save_string(dp, \"%+\");\n\t\tbreak;\n\t    case '+':\n\t\tgetparm(param, 1);\n\t\ts += cvtchar(s);\n\t\tdp = save_string(dp, \"%+%c\");\n\t\tpop();\n\t\tbreak;\n\t    case 's':\n#ifdef WATERLOO\n\t\ts += cvtchar(s);\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%-\");\n#else\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%s\");\n\t\tpop();\n#endif  \n\t\tbreak;\n\t    case '-':\n\t\ts += cvtchar(s);\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%-%c\");\n\t\tpop();\n\t\tbreak;\n\t    case '.':\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%c\");\n\t\tpop();\n\t\tbreak;\n\t    case '0':\t\t \n\t\tif (*s == '3') {\n\t\t    ++s;\n\t\t    goto see03;\n\t\t}\n\t\tif (*s == '2') {\n\t\t    ++s;\n\t\t    goto see02;\n\t\t}\n\t\tgoto invalid;\n\t    case '2':\n\t      see02:\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%2d\");\n\t\tpop();\n\t\tbreak;\n\t    case '3':\n\t      see03:\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%3d\");\n\t\tpop();\n\t\tbreak;\n\t    case 'd':\n\t\tgetparm(param, 1);\n\t\tdp = save_string(dp, \"%d\");\n\t\tpop();\n\t\tbreak;\n\t    case 'f':\n\t\tparam++;\n\t\tbreak;\n\t    case 'b':\n\t\tparam--;\n\t\tbreak;\n\t    case '\\\\':\n\t\tdp = save_string(dp, \"%\\\\\");\n\t\tbreak;\n\t    default:\n\t      invalid:\n\t\tdp = save_char(dp, '%');\n\t\ts--;\n\t\t_nc_warning(\"unknown %% code %s (%#x) in %s\",\n\t\t\t    unctrl((chtype) *s), UChar(*s), cap);\n\t\tbreak;\n\t    }\n\t    break;\n\tdefault:\n\t    if (*s != '\\0')\n\t\tdp = save_char(dp, *s++);\n\t    break;\n\t}\n    }\n\n     \n    if (capstart) {\n\tdp = save_string(dp, \"$<\");\n\tfor (s = capstart; *s != '\\0'; s++)\n\t    if (isdigit(UChar(*s)) || *s == '*' || *s == '.')\n\t\tdp = save_char(dp, *s);\n\t    else\n\t\tbreak;\n\tdp = save_string(dp, \"/>\");\n    }\n\n    (void) save_char(dp, '\\0');\n\n    DEBUG_THIS((\"... _nc_captoinfo %s\", NonNull(my_string)));\n\n    return (my_string);\n}\n\n \nstatic int\nbcd_expression(const char *str)\n{\n     \n    static char fmt[] = \"%%p%c%%{10}%%/%%{16}%%*%%p%c%%{10}%%m%%+\";\n    int len = 0;\n    char ch1, ch2;\n\n    if (sscanf(str, fmt, &ch1, &ch2) == 2\n\t&& isdigit(UChar(ch1))\n\t&& isdigit(UChar(ch2))\n\t&& (ch1 == ch2)) {\n\tlen = 28;\n#ifndef NDEBUG\n\t{\n\t    char buffer[80];\n\t    int tst;\n\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer)) fmt, ch1, ch2);\n\t    tst = strlen(buffer) - 1;\n\t    assert(len == tst);\n\t}\n#endif\n    }\n    return len;\n}\n\nstatic char *\nsave_tc_char(char *bufptr, int c1)\n{\n    if (is7bits(c1) && isprint(c1)) {\n\tif (c1 == ':' || c1 == '\\\\')\n\t    bufptr = save_char(bufptr, '\\\\');\n\tbufptr = save_char(bufptr, c1);\n    } else {\n\tchar temp[80];\n\n\tif (c1 == (c1 & 0x1f)) {\t \n\t    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\"%.20s\", unctrl((chtype) c1));\n\t} else {\n\t    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\"\\\\%03o\", c1);\n\t}\n\tbufptr = save_string(bufptr, temp);\n    }\n    return bufptr;\n}\n\nstatic char *\nsave_tc_inequality(char *bufptr, int c1, int c2)\n{\n    bufptr = save_string(bufptr, \"%>\");\n    bufptr = save_tc_char(bufptr, c1);\n    bufptr = save_tc_char(bufptr, c2);\n    return bufptr;\n}\n\n \n\n#define octal_fixup(n, c) fixups[n].ch = ((fixups[n].ch << 3) | ((c) - '0'))\n\n \nNCURSES_EXPORT(char *)\n_nc_infotocap(const char *cap GCC_UNUSED, const char *str, int const parameterized)\n{\n    int seenone = 0, seentwo = 0, saw_m = 0, saw_n = 0;\n    const char *padding;\n    const char *trimmed = 0;\n    int in0, in1, in2;\n    char ch1 = 0, ch2 = 0;\n    char *bufptr = init_string();\n    char octal[4];\n    int len;\n    int digits;\n    bool syntax_error = FALSE;\n    int myfix = 0;\n    struct {\n\tint ch;\n\tint offset;\n    } fixups[MAX_TC_FIXUPS];\n\n    DEBUG_THIS((\"_nc_infotocap %s params %d, %s\",\n\t\t_nc_strict_bsd ? \"strict\" : \"loose\",\n\t\tparameterized,\n\t\t_nc_visbuf(str)));\n\n     \n    padding = str + strlen(str) - 1;\n    if (padding > str && *padding == '>') {\n\tif (padding > (str + 1) && *--padding == '/')\n\t    --padding;\n\twhile (isdigit(UChar(*padding)) || *padding == '.' || *padding == '*')\n\t    padding--;\n\tif (padding > str && *padding == '<' && *--padding == '$')\n\t    trimmed = padding;\n\tpadding += 2;\n\n\twhile (isdigit(UChar(*padding)) || *padding == '.' || *padding == '*')\n\t    bufptr = save_char(bufptr, *padding++);\n    }\n\n    for (; !syntax_error &&\n\t *str &&\n\t ((trimmed == 0) || (str < trimmed)); str++) {\n\tint c1, c2;\n\tchar *cp = 0;\n\n\tif (str[0] == '^') {\n\t    if (str[1] == '\\0' || (str + 1) == trimmed) {\n\t\tbufptr = save_string(bufptr, \"\\\\136\");\n\t\t++str;\n\t    } else if (str[1] == '?') {\n\t\t \n\t\tbufptr = save_string(bufptr, \"\\\\177\");\n\t\t++str;\n\t    } else {\n\t\tbufptr = save_char(bufptr, *str++);\n\t\tbufptr = save_char(bufptr, *str);\n\t    }\n\t} else if (str[0] == ':') {\n\t    bufptr = save_char(bufptr, '\\\\');\n\t    bufptr = save_char(bufptr, '0');\n\t    bufptr = save_char(bufptr, '7');\n\t    bufptr = save_char(bufptr, '2');\n\t} else if (str[0] == '\\\\') {\n\t    if (str[1] == '\\0' || (str + 1) == trimmed) {\n\t\tbufptr = save_string(bufptr, \"\\\\134\");\n\t\t++str;\n\t    } else if (str[1] == '^') {\n\t\tbufptr = save_string(bufptr, \"\\\\136\");\n\t\t++str;\n\t    } else if (str[1] == ',') {\n\t\tbufptr = save_char(bufptr, *++str);\n\t    } else {\n\t\tint xx1;\n\n\t\tbufptr = save_char(bufptr, *str++);\n\t\txx1 = *str;\n\t\tif (_nc_strict_bsd) {\n\n\t\t    if (isoctal(UChar(xx1))) {\n\t\t\tint pad = 0;\n\t\t\tint xx2;\n\t\t\tint fix = 0;\n\n\t\t\tif (!isoctal(UChar(str[1])))\n\t\t\t    pad = 2;\n\t\t\telse if (str[1] && !isoctal(UChar(str[2])))\n\t\t\t    pad = 1;\n\n\t\t\t \n\t\t\tif (xx1 == '0'\n\t\t\t    && ((pad == 2) || (str[1] == '0'))\n\t\t\t    && ((pad >= 1) || (str[2] == '0'))) {\n\t\t\t    xx2 = '2';\n\t\t\t} else {\n\t\t\t    xx2 = '0';\n\t\t\t    pad = 0;\t \n\t\t\t}\n\t\t\tif (myfix < MAX_TC_FIXUPS) {\n\t\t\t    fix = 3 - pad;\n\t\t\t    fixups[myfix].ch = 0;\n\t\t\t    fixups[myfix].offset = (int) (bufptr\n\t\t\t\t\t\t\t  - my_string\n\t\t\t\t\t\t\t  - 1);\n\t\t\t}\n\t\t\twhile (pad-- > 0) {\n\t\t\t    bufptr = save_char(bufptr, xx2);\n\t\t\t    if (myfix < MAX_TC_FIXUPS) {\n\t\t\t\tfixups[myfix].ch <<= 3;\n\t\t\t\tfixups[myfix].ch |= (xx2 - '0');\n\t\t\t    }\n\t\t\t    xx2 = '0';\n\t\t\t}\n\t\t\tif (myfix < MAX_TC_FIXUPS) {\n\t\t\t    int n;\n\t\t\t    for (n = 0; n < fix; ++n) {\n\t\t\t\tfixups[myfix].ch <<= 3;\n\t\t\t\tfixups[myfix].ch |= (str[n] - '0');\n\t\t\t    }\n\t\t\t    if (fixups[myfix].ch < 32) {\n\t\t\t\t++myfix;\n\t\t\t    }\n\t\t\t}\n\t\t    } else if (strchr(\"E\\\\nrtbf\", xx1) == 0) {\n\t\t\tswitch (xx1) {\n\t\t\tcase 'e':\n\t\t\t    xx1 = 'E';\n\t\t\t    break;\n\t\t\tcase 'l':\n\t\t\t    xx1 = 'n';\n\t\t\t    break;\n\t\t\tcase 's':\n\t\t\t    bufptr = save_char(bufptr, '0');\n\t\t\t    bufptr = save_char(bufptr, '4');\n\t\t\t    xx1 = '0';\n\t\t\t    break;\n\t\t\tcase ':':\n\t\t\t     \n\t\t\t    bufptr = save_char(bufptr, '0');\n\t\t\t    bufptr = save_char(bufptr, '7');\n\t\t\t    xx1 = '2';\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t     \n\t\t\t    _nc_SPRINTF(octal, _nc_SLIMIT(sizeof(octal))\n\t\t\t\t\t\"%03o\", UChar(xx1));\n\t\t\t    bufptr = save_char(bufptr, octal[0]);\n\t\t\t    bufptr = save_char(bufptr, octal[1]);\n\t\t\t    xx1 = octal[2];\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t    if (myfix < MAX_TC_FIXUPS && isoctal(UChar(xx1))) {\n\t\t\tbool will_fix = TRUE;\n\t\t\tint n;\n\n\t\t\tfixups[myfix].ch = 0;\n\t\t\tfixups[myfix].offset = (int) (bufptr - my_string - 1);\n\t\t\tfor (n = 0; n < 3; ++n) {\n\t\t\t    if (isoctal(str[n])) {\n\t\t\t\toctal_fixup(myfix, str[n]);\n\t\t\t    } else {\n\t\t\t\twill_fix = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (will_fix && (fixups[myfix].ch < 32))\n\t\t\t    ++myfix;\n\t\t    }\n\t\t}\n\t\tbufptr = save_char(bufptr, xx1);\n\t    }\n\t} else if (str[0] == '$' && str[1] == '<') {\t \n\t    str += 2;\n\t    while (isdigit(UChar(*str))\n\t\t   || *str == '.'\n\t\t   || *str == '*'\n\t\t   || *str == '/'\n\t\t   || *str == '>')\n\t\tstr++;\n\t    --str;\n\t} else if (sscanf(str,\n\t\t\t  \"[%%?%%p1%%{8}%%<%%t%d%%p1%%d%%e%%p1%%{16}%%<%%t%d%%p1%%{8}%%-%%d%%e%d;5;%%p1%%d%%;m\",\n\t\t\t  &in0, &in1, &in2) == 3\n\t\t   && ((in0 == 4 && in1 == 10 && in2 == 48)\n\t\t       || (in0 == 3 && in1 == 9 && in2 == 38))) {\n\t     \n\t    if ((str = strstr(str, \";m\")) == 0)\n\t\tbreak;\t\t \n\t    ++str;\n\t    if (in2 == 48) {\n\t\tbufptr = save_string(bufptr, \"[48;5;%dm\");\n\t    } else {\n\t\tbufptr = save_string(bufptr, \"[38;5;%dm\");\n\t    }\n\t} else if (str[0] == '%' && str[1] == '%') {\t \n\t    bufptr = save_string(bufptr, \"%%\");\n\t    ++str;\n\t} else if (*str != '%' || (parameterized < 1)) {\n\t    bufptr = save_char(bufptr, *str);\n\t} else if (sscanf(str, \"%%?%%{%d}%%>%%t%%{%d}%%+%%;\", &c1, &c2) == 2) {\n\t    str = strchr(str, ';');\n\t    bufptr = save_tc_inequality(bufptr, c1, c2);\n\t} else if (sscanf(str, \"%%?%%{%d}%%>%%t%%'%c'%%+%%;\", &c1, &ch2) == 2) {\n\t    str = strchr(str, ';');\n\t    bufptr = save_tc_inequality(bufptr, c1, ch2);\n\t} else if (sscanf(str, \"%%?%%'%c'%%>%%t%%{%d}%%+%%;\", &ch1, &c2) == 2) {\n\t    str = strchr(str, ';');\n\t    bufptr = save_tc_inequality(bufptr, ch1, c2);\n\t} else if (sscanf(str, \"%%?%%'%c'%%>%%t%%'%c'%%+%%;\", &ch1, &ch2) == 2) {\n\t    str = strchr(str, ';');\n\t    bufptr = save_tc_inequality(bufptr, ch1, ch2);\n\t} else if ((len = bcd_expression(str)) != 0) {\n\t    str += len;\n\t    bufptr = save_string(bufptr, \"%B\");\n\t} else if ((sscanf(str, \"%%{%d}%%+%%%c\", &c1, &ch2) == 2\n\t\t    || sscanf(str, \"%%'%c'%%+%%%c\", &ch1, &ch2) == 2)\n\t\t   && ch2 == 'c'\n\t\t   && (cp = strchr(str, '+'))) {\n\t    str = cp + 2;\n\t    bufptr = save_string(bufptr, \"%+\");\n\n\t    if (ch1)\n\t\tc1 = ch1;\n\t    bufptr = save_tc_char(bufptr, c1);\n\t}\n\t \n\telse if (strncmp(str, \"%{2}%*%-\", (size_t) 8) == 0) {\n\t    str += 7;\n\t    bufptr = save_string(bufptr, \"%D\");\n\t} else if (strncmp(str, \"%{96}%^\", (size_t) 7) == 0) {\n\t    str += 6;\n\t    if (saw_m++ == 0) {\n\t\tbufptr = save_string(bufptr, \"%n\");\n\t    }\n\t} else if (strncmp(str, \"%{127}%^\", (size_t) 8) == 0) {\n\t    str += 7;\n\t    if (saw_n++ == 0) {\n\t\tbufptr = save_string(bufptr, \"%m\");\n\t    }\n\t} else {\t\t \n\t    str++;\n\t    switch (*str) {\n\t    case '%':\n\t\tbufptr = save_char(bufptr, '%');\n\t\tbreak;\n\n\t    case '0':\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t    case '8':\n\t    case '9':\n\t\tbufptr = save_char(bufptr, '%');\n\t\tch1 = 0;\n\t\tch2 = 0;\n\t\tdigits = 0;\n\t\twhile (isdigit(UChar(*str))) {\n\t\t    if (++digits > 2) {\n\t\t\tsyntax_error = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t    ch2 = ch1;\n\t\t    ch1 = *str++;\n\t\t    if (digits == 2 && ch2 != '0') {\n\t\t\tsyntax_error = TRUE;\n\t\t\tbreak;\n\t\t    } else if (_nc_strict_bsd) {\n\t\t\tif (ch1 > '3') {\n\t\t\t    syntax_error = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t    } else {\n\t\t\tbufptr = save_char(bufptr, ch1);\n\t\t    }\n\t\t}\n\t\tif (syntax_error)\n\t\t    break;\n\t\t \n\t\tif (ch2 == '0' && !_nc_strict_bsd) {\n\t\t    ch2 = 0;\n\t\t    bufptr[-2] = bufptr[-1];\n\t\t    *--bufptr = 0;\n\t\t}\n\t\tif (_nc_strict_bsd) {\n\t\t    if (ch2 != 0 && ch2 != '0') {\n\t\t\tsyntax_error = TRUE;\n\t\t    } else if (ch1 < '2') {\n\t\t\tch1 = 'd';\n\t\t    }\n\t\t    bufptr = save_char(bufptr, ch1);\n\t\t}\n\t\tif (strchr(\"oxX.\", *str)) {\n\t\t    syntax_error = TRUE;\t \n\t\t}\n\t\tbreak;\n\n\t    case 'd':\n\t\tbufptr = save_string(bufptr, \"%d\");\n\t\tbreak;\n\n\t    case 'c':\n\t\tbufptr = save_string(bufptr, \"%.\");\n\t\tbreak;\n\n\t\t \n\t    case 's':\n\t\tif (_nc_strict_bsd) {\n\t\t    syntax_error = TRUE;\n\t\t} else {\n\t\t    bufptr = save_string(bufptr, \"%s\");\n\t\t}\n\t\tbreak;\n\n\t    case 'p':\n\t\tstr++;\n\t\tif (*str == '1')\n\t\t    seenone = 1;\n\t\telse if (*str == '2') {\n\t\t    if (!seenone && !seentwo) {\n\t\t\tbufptr = save_string(bufptr, \"%r\");\n\t\t\tseentwo++;\n\t\t    }\n\t\t} else if (*str >= '3') {\n\t\t    syntax_error = TRUE;\n\t\t}\n\t\tbreak;\n\n\t    case 'i':\n\t\tbufptr = save_string(bufptr, \"%i\");\n\t\tbreak;\n\n\t    default:\n\t\tbufptr = save_char(bufptr, *str);\n\t\tsyntax_error = TRUE;\n\t\tbreak;\n\t    }\t\t\t \n\t}\t\t\t \n\n\t \n\tassert(str != 0);\n\tif (str == 0 || *str == '\\0')\n\t    break;\n\n    }\t\t\t\t \n\n    if (!syntax_error &&\n\tmyfix > 0 &&\n\t((int) strlen(my_string) - (4 * myfix)) < MIN_TC_FIXUPS) {\n\twhile (--myfix >= 0) {\n\t    char *p = fixups[myfix].offset + my_string;\n\t    *p++ = '^';\n\t    *p++ = (char) (fixups[myfix].ch | '@');\n\t    while ((p[0] = p[2]) != '\\0') {\n\t\t++p;\n\t    }\n\t}\n    }\n\n    DEBUG_THIS((\"... _nc_infotocap %s\",\n\t\tsyntax_error\n\t\t? \"<ERR>\"\n\t\t: _nc_visbuf(my_string)));\n\n    return (syntax_error ? NULL : my_string);\n}\n\n#ifdef MAIN\n\nint curr_line;\n\nint\nmain(int argc, char *argv[])\n{\n    int c, tc = FALSE;\n\n    while ((c = getopt(argc, argv, \"c\")) != EOF)\n\tswitch (c) {\n\tcase 'c':\n\t    tc = TRUE;\n\t    break;\n\t}\n\n    curr_line = 0;\n    for (;;) {\n\tchar buf[BUFSIZ];\n\n\t++curr_line;\n\tif (fgets(buf, sizeof(buf), stdin) == 0)\n\t    break;\n\tbuf[strlen(buf) - 1] = '\\0';\n\t_nc_set_source(buf);\n\n\tif (tc) {\n\t    char *cp = _nc_infotocap(\"to termcap\", buf, 1);\n\n\t    if (cp)\n\t\t(void) fputs(cp, stdout);\n\t} else\n\t    (void) fputs(_nc_captoinfo(\"to terminfo\", buf, 1), stdout);\n\t(void) putchar('\\n');\n    }\n    return (0);\n}\n#endif  \n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_captoinfo_leaks(void)\n{\n    if (my_string != 0) {\n\tFreeAndNull(my_string);\n    }\n    my_length = 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}