{
  "module_name": "tinfo_driver.c",
  "hash_id": "7fd807ac77328014c5e110a133515f3040aaf915b68f3ea700dabe52b367eebb",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/tinfo_driver.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n#define CUR TerminalType((TERMINAL*)TCB).\n#include <tic.h>\n#include <termcap.h>\t\t \n\n#if HAVE_NANOSLEEP\n#include <time.h>\n#if HAVE_SYS_TIME_H\n#include <sys/time.h>\t\t \n#endif\n#endif\n\n#if HAVE_SIZECHANGE\n# if !defined(sun) || !TERMIOS\n#  if HAVE_SYS_IOCTL_H\n#   include <sys/ioctl.h>\n#  endif\n# endif\n#endif\n\nMODULE_ID(\"$Id: tinfo_driver.c,v 1.73 2022/08/13 14:36:43 tom Exp $\")\n\n \n#ifdef TIOCGSIZE\n# define IOCTL_WINSIZE TIOCGSIZE\n# define STRUCT_WINSIZE struct ttysize\n# define WINSIZE_ROWS(n) (int)n.ts_lines\n# define WINSIZE_COLS(n) (int)n.ts_cols\n#else\n# ifdef TIOCGWINSZ\n#  define IOCTL_WINSIZE TIOCGWINSZ\n#  define STRUCT_WINSIZE struct winsize\n#  define WINSIZE_ROWS(n) (int)n.ws_row\n#  define WINSIZE_COLS(n) (int)n.ws_col\n# endif\n#endif\n\n \n#if USE_REENTRANT\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(COLOR_PAIRS) (void)\n{\n    return CURRENT_SCREEN ? CURRENT_SCREEN->_pair_count : -1;\n}\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(COLORS) (void)\n{\n    return CURRENT_SCREEN ? CURRENT_SCREEN->_color_count : -1;\n}\n#else\nNCURSES_EXPORT_VAR(int) COLOR_PAIRS = 0;\nNCURSES_EXPORT_VAR(int) COLORS = 0;\n#endif\n\n#define TCBMAGIC NCDRV_MAGIC(NCDRV_TINFO)\n#define AssertTCB() assert(TCB!=0 && TCB->magic==TCBMAGIC)\n#define SetSP() assert(TCB->csp!=0); sp = TCB->csp; (void) sp\n\n \nstatic int\ndrv_doupdate(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    AssertTCB();\n    return TINFO_DOUPDATE(TCB->csp);\n}\n\nstatic const char *\ndrv_Name(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    (void) TCB;\n    return \"tinfo\";\n}\n\nstatic void\nget_baudrate(TERMINAL *termp)\n{\n    int my_ospeed;\n    int result;\n    if (GET_TTY(termp->Filedes, &termp->Nttyb) == OK) {\n#ifdef TERMIOS\n\ttermp->Nttyb.c_oflag &= (unsigned) (~OFLAGS_TABS);\n#elif defined(EXP_WIN32_DRIVER)\n\t \n#else\n\ttermp->Nttyb.sg_flags &= (unsigned) (~XTABS);\n#endif\n    }\n#ifdef USE_OLD_TTY\n    result = (int) cfgetospeed(&(termp->Nttyb));\n    my_ospeed = (NCURSES_OSPEED) _nc_ospeed(result);\n#else  \n#ifdef TERMIOS\n    my_ospeed = (NCURSES_OSPEED) cfgetospeed(&(termp->Nttyb));\n#elif defined(EXP_WIN32_DRIVER)\n     \n    my_ospeed = 0;\n#else\n    my_ospeed = (NCURSES_OSPEED) termp->Nttyb.sg_ospeed;\n#endif\n    result = _nc_baudrate(my_ospeed);\n#endif\n    termp->_baudrate = result;\n    ospeed = (NCURSES_OSPEED) my_ospeed;\n}\n\n#undef SETUP_FAIL\n#define SETUP_FAIL FALSE\n\n#define NO_COPY {}\n\nstatic bool\ndrv_CanHandle(TERMINAL_CONTROL_BLOCK * TCB, const char *tname, int *errret)\n{\n    bool result = FALSE;\n    int status;\n    TERMINAL *termp;\n    SCREEN *sp;\n\n    START_TRACE();\n    T((T_CALLED(\"tinfo::drv_CanHandle(%p)\"), (void *) TCB));\n\n    assert(TCB != 0 && tname != 0);\n    termp = (TERMINAL *) TCB;\n    sp = TCB->csp;\n    TCB->magic = TCBMAGIC;\n\n#if (NCURSES_USE_DATABASE || NCURSES_USE_TERMCAP)\n    status = _nc_setup_tinfo(tname, &TerminalType(termp));\n    T((\"_nc_setup_tinfo returns %d\", status));\n#else\n    T((\"no database available\"));\n    status = TGETENT_NO;\n#endif\n\n     \n    if (status != TGETENT_YES) {\n\tconst TERMTYPE2 *fallback = _nc_fallback2(tname);\n\n\tif (fallback) {\n\t    T((\"found fallback entry\"));\n\t    TerminalType(termp) = *fallback;\n\t    status = TGETENT_YES;\n\t}\n    }\n\n    if (status != TGETENT_YES) {\n\tNCURSES_SP_NAME(del_curterm) (NCURSES_SP_ARGx termp);\n\tif (status == TGETENT_ERR) {\n\t    ret_error0(status, \"terminals database is inaccessible\\n\");\n\t} else if (status == TGETENT_NO) {\n\t    ret_error1(status, \"unknown terminal type.\\n\",\n\t\t       tname, NO_COPY);\n\t} else {\n\t    ret_error0(status, \"unexpected return-code\\n\");\n\t}\n    }\n    result = TRUE;\n#if NCURSES_EXT_NUMBERS\n    _nc_export_termtype2(&termp->type, &TerminalType(termp));\n#endif\n#if !USE_REENTRANT\n    save_ttytype(termp);\n#endif\n\n    if (command_character)\n\t_nc_tinfo_cmdch(termp, *command_character);\n\n     \n    if (sp == 0 && NC_ISATTY(termp->Filedes)) {\n\tget_baudrate(termp);\n    }\n#if NCURSES_EXT_NUMBERS\n#define cleanup_termtype() \\\n    _nc_free_termtype2(&TerminalType(termp)); \\\n    _nc_free_termtype(&termp->type)\n#else\n#define cleanup_termtype() \\\n    _nc_free_termtype2(&TerminalType(termp))\n#endif\n\n    if (generic_type) {\n\t \n\tif ((VALID_STRING(cursor_address)\n\t     || (VALID_STRING(cursor_down) && VALID_STRING(cursor_home)))\n\t    && VALID_STRING(clear_screen)) {\n\t    cleanup_termtype();\n\t    ret_error1(TGETENT_YES, \"terminal is not really generic.\\n\",\n\t\t       tname, NO_COPY);\n\t} else {\n\t    cleanup_termtype();\n\t    ret_error1(TGETENT_NO, \"I need something more specific.\\n\",\n\t\t       tname, NO_COPY);\n\t}\n    }\n    if (hard_copy) {\n\tcleanup_termtype();\n\tret_error1(TGETENT_YES, \"I can't handle hardcopy terminals.\\n\",\n\t\t   tname, NO_COPY);\n    }\n\n    returnBool(result);\n}\n\nstatic int\ndrv_dobeepflash(TERMINAL_CONTROL_BLOCK * TCB, int beepFlag)\n{\n    SCREEN *sp;\n    int res = ERR;\n\n    AssertTCB();\n    SetSP();\n\n     \n    if (beepFlag) {\n\tif (bell) {\n\t    res = NCURSES_PUTP2(\"bell\", bell);\n\t    NCURSES_SP_NAME(_nc_flush) (sp);\n\t} else if (flash_screen) {\n\t    res = NCURSES_PUTP2(\"flash_screen\", flash_screen);\n\t    NCURSES_SP_NAME(_nc_flush) (sp);\n\t}\n    } else {\n\tif (flash_screen) {\n\t    res = NCURSES_PUTP2(\"flash_screen\", flash_screen);\n\t    NCURSES_SP_NAME(_nc_flush) (sp);\n\t} else if (bell) {\n\t    res = NCURSES_PUTP2(\"bell\", bell);\n\t    NCURSES_SP_NAME(_nc_flush) (sp);\n\t}\n    }\n    return res;\n}\n\n \nstatic int\ntoggled_colors(int c)\n{\n    if (c < 16) {\n\tstatic const int table[] =\n\t{0, 4, 2, 6, 1, 5, 3, 7,\n\t 8, 12, 10, 14, 9, 13, 11, 15};\n\tc = table[c];\n    }\n    return c;\n}\n\nstatic int\ndrv_print(TERMINAL_CONTROL_BLOCK * TCB, char *data, int len)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n#if NCURSES_EXT_FUNCS\n    return NCURSES_SP_NAME(mcprint) (TCB->csp, data, len);\n#else\n    return ERR;\n#endif\n}\n\nstatic int\ndrv_defaultcolors(TERMINAL_CONTROL_BLOCK * TCB, int fg, int bg)\n{\n    SCREEN *sp;\n    int code = ERR;\n\n    AssertTCB();\n    SetSP();\n\n    if (sp != 0 && orig_pair && orig_colors && (initialize_pair != 0)) {\n#if NCURSES_EXT_FUNCS\n\tsp->_default_color = isDefaultColor(fg) || isDefaultColor(bg);\n\tsp->_has_sgr_39_49 = (NCURSES_SP_NAME(tigetflag) (NCURSES_SP_ARGx\n\t\t\t\t\t\t\t  \"AX\")\n\t\t\t      == TRUE);\n\tsp->_default_fg = isDefaultColor(fg) ? COLOR_DEFAULT : fg;\n\tsp->_default_bg = isDefaultColor(bg) ? COLOR_DEFAULT : bg;\n\tif (sp->_color_pairs != 0) {\n\t    bool save = sp->_default_color;\n\t    sp->_default_color = TRUE;\n\t    NCURSES_SP_NAME(init_pair) (NCURSES_SP_ARGx\n\t\t\t\t\t0,\n\t\t\t\t\t(short)fg,\n\t\t\t\t\t(short)bg);\n\t    sp->_default_color = save;\n\t}\n#endif\n\tcode = OK;\n    }\n    return (code);\n}\n\nstatic void\ndrv_setcolor(TERMINAL_CONTROL_BLOCK * TCB,\n\t     int fore,\n\t     int color,\n\t     NCURSES_SP_OUTC outc)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    if (fore) {\n\tif (set_a_foreground) {\n\t    TPUTS_TRACE(\"set_a_foreground\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TIPARM_1(set_a_foreground, color), 1, outc);\n\t} else {\n\t    TPUTS_TRACE(\"set_foreground\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TIPARM_1(set_foreground,\n\t\t\t\t\t     toggled_colors(color)), 1, outc);\n\t}\n    } else {\n\tif (set_a_background) {\n\t    TPUTS_TRACE(\"set_a_background\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TIPARM_1(set_a_background, color), 1, outc);\n\t} else {\n\t    TPUTS_TRACE(\"set_background\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TIPARM_1(set_background,\n\t\t\t\t\t     toggled_colors(color)), 1, outc);\n\t}\n    }\n}\n\nstatic bool\ndrv_rescol(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    bool result = FALSE;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    if (orig_pair != 0) {\n\tNCURSES_PUTP2(\"orig_pair\", orig_pair);\n\tresult = TRUE;\n    }\n    return result;\n}\n\nstatic bool\ndrv_rescolors(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    int result = FALSE;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    if (orig_colors != 0) {\n\tNCURSES_PUTP2(\"orig_colors\", orig_colors);\n\tresult = TRUE;\n    }\n    return result;\n}\n\nstatic int\ndrv_size(TERMINAL_CONTROL_BLOCK * TCB, int *linep, int *colp)\n{\n    SCREEN *sp;\n    bool useEnv = TRUE;\n    bool useTioctl = TRUE;\n\n    AssertTCB();\n    sp = TCB->csp;\t\t \n\n    if (sp) {\n\tuseEnv = sp->_use_env;\n\tuseTioctl = sp->use_tioctl;\n    } else {\n\tuseEnv = _nc_prescreen.use_env;\n\tuseTioctl = _nc_prescreen.use_tioctl;\n    }\n\n#ifdef EXP_WIN32_DRIVER\n     \n    _nc_console_size(linep, colp);\n    T((\"screen size: winconsole lines = %d columns = %d\", *linep, *colp));\n#else\n     \n    T((\"screen size: terminfo lines = %d columns = %d\", lines, columns));\n\n    *linep = (int) lines;\n    *colp = (int) columns;\n#endif\n    if (useEnv || useTioctl) {\n\tint value;\n\n#ifdef __EMX__\n\t{\n\t    int screendata[2];\n\t    _scrsize(screendata);\n\t    *colp = screendata[0];\n\t    *linep = ((sp != 0 && sp->_filtered)\n\t\t      ? 1\n\t\t      : screendata[1]);\n\t    T((\"EMX screen size: environment LINES = %d COLUMNS = %d\",\n\t       *linep, *colp));\n\t}\n#endif\n#if HAVE_SIZECHANGE\n\t \n\t{\n\t    TERMINAL *termp = (TERMINAL *) TCB;\n\t    if (NC_ISATTY(termp->Filedes)) {\n\t\tSTRUCT_WINSIZE size;\n\n\t\terrno = 0;\n\t\tdo {\n\t\t    if (ioctl(termp->Filedes, IOCTL_WINSIZE, &size) >= 0) {\n\t\t\t*linep = ((sp != 0 && sp->_filtered)\n\t\t\t\t  ? 1\n\t\t\t\t  : WINSIZE_ROWS(size));\n\t\t\t*colp = WINSIZE_COLS(size);\n\t\t\tT((\"SYS screen size: environment LINES = %d COLUMNS = %d\",\n\t\t\t   *linep, *colp));\n\t\t\tbreak;\n\t\t    }\n\t\t} while\n\t\t    (errno == EINTR);\n\t    }\n\t}\n#endif  \n\n\tif (useEnv) {\n\t    if (useTioctl) {\n\t\t \n\t\tif ((sp == 0 || !sp->_filtered) && _nc_getenv_num(\"LINES\") > 0) {\n\t\t    _nc_setenv_num(\"LINES\", *linep);\n\t\t}\n\t\tif (_nc_getenv_num(\"COLUMNS\") > 0) {\n\t\t    _nc_setenv_num(\"COLUMNS\", *colp);\n\t\t}\n\t    }\n\n\t     \n\t    if ((value = _nc_getenv_num(\"LINES\")) > 0) {\n\t\t*linep = value;\n\t\tT((\"screen size: environment LINES = %d\", *linep));\n\t    }\n\t    if ((value = _nc_getenv_num(\"COLUMNS\")) > 0) {\n\t\t*colp = value;\n\t\tT((\"screen size: environment COLUMNS = %d\", *colp));\n\t    }\n\t}\n\n\t \n\tif (*linep <= 0) {\n\t    *linep = (int) lines;\n\t}\n\tif (*colp <= 0) {\n\t    *colp = (int) columns;\n\t}\n\n\t \n\tif (*linep <= 0) {\n\t    *linep = 24;\n\t}\n\tif (*colp <= 0) {\n\t    *colp = 80;\n\t}\n\n\t \n\tlines = (short) (*linep);\n\tcolumns = (short) (*colp);\n    }\n\n    T((\"screen size is %dx%d\", *linep, *colp));\n    return OK;\n}\n\nstatic int\ndrv_getsize(TERMINAL_CONTROL_BLOCK * TCB, int *l, int *c)\n{\n    AssertTCB();\n    assert(l != 0 && c != 0);\n    *l = lines;\n    *c = columns;\n    return OK;\n}\n\nstatic int\ndrv_setsize(TERMINAL_CONTROL_BLOCK * TCB, int l, int c)\n{\n    AssertTCB();\n    lines = (short) l;\n    columns = (short) c;\n    return OK;\n}\n\nstatic int\ndrv_sgmode(TERMINAL_CONTROL_BLOCK * TCB, int setFlag, TTY * buf)\n{\n    SCREEN *sp = TCB->csp;\n    TERMINAL *_term = (TERMINAL *) TCB;\n    int result = OK;\n\n    AssertTCB();\n    if (setFlag) {\n\tfor (;;) {\n\t    if (SET_TTY(_term->Filedes, buf) != 0) {\n\t\tif (errno == EINTR)\n\t\t    continue;\n\t\tif (errno == ENOTTY) {\n\t\t    if (sp)\n\t\t\tsp->_notty = TRUE;\n\t\t}\n\t\tresult = ERR;\n\t    }\n\t    break;\n\t}\n    } else {\n\tfor (;;) {\n\t    if (GET_TTY(_term->Filedes, buf) != 0) {\n\t\tif (errno == EINTR)\n\t\t    continue;\n\t\tresult = ERR;\n\t    }\n\t    break;\n\t}\n    }\n    return result;\n}\n\nstatic int\ndrv_mode(TERMINAL_CONTROL_BLOCK * TCB, int progFlag, int defFlag)\n{\n    SCREEN *sp;\n    TERMINAL *_term = (TERMINAL *) TCB;\n    int code = ERR;\n\n    AssertTCB();\n    sp = TCB->csp;\n\n    if (progFlag)\t\t \n    {\n\tif (defFlag) {\n\t     \n\t     \n\t    if ((drv_sgmode(TCB, FALSE, &(_term->Nttyb)) == OK)) {\n#ifdef TERMIOS\n\t\t_term->Nttyb.c_oflag &= (unsigned) ~OFLAGS_TABS;\n#elif defined(EXP_WIN32_DRIVER)\n\t\t \n#else\n\t\t_term->Nttyb.sg_flags &= (unsigned) ~XTABS;\n#endif\n\t\tcode = OK;\n\t    }\n\t} else {\n\t     \n\t    if (drv_sgmode(TCB, TRUE, &(_term->Nttyb)) == OK) {\n\t\tif (sp) {\n\t\t    if (sp->_keypad_on)\n\t\t\t_nc_keypad(sp, TRUE);\n\t\t}\n\t\tcode = OK;\n\t    }\n\t}\n    } else {\t\t\t \n\tif (defFlag) {\n\t     \n\t     \n\t    if (drv_sgmode(TCB, FALSE, &(_term->Ottyb)) == OK) {\n#ifdef TERMIOS\n\t\tif (_term->Ottyb.c_oflag & OFLAGS_TABS)\n\t\t    tab = back_tab = NULL;\n#elif defined(EXP_WIN32_DRIVER)\n\t\t \n#else\n\t\tif (_term->Ottyb.sg_flags & XTABS)\n\t\t    tab = back_tab = NULL;\n#endif\n\t\tcode = OK;\n\t    }\n\t} else {\n\t     \n\t    if (sp) {\n\t\t_nc_keypad(sp, FALSE);\n\t\tNCURSES_SP_NAME(_nc_flush) (sp);\n\t    }\n\t    code = drv_sgmode(TCB, TRUE, &(_term->Ottyb));\n\t}\n    }\n    return (code);\n}\n\nstatic void\ndrv_wrap(SCREEN *sp)\n{\n    if (sp) {\n\tsp->_mouse_wrap(sp);\n\tNCURSES_SP_NAME(_nc_screen_wrap) (sp);\n\tNCURSES_SP_NAME(_nc_mvcur_wrap) (sp);\t \n    }\n}\n\nstatic void\ndrv_release(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED)\n{\n}\n\n#  define SGR0_TEST(mode) (mode != 0) && (exit_attribute_mode == 0 || strcmp(mode, exit_attribute_mode))\n\nstatic void\ndrv_screen_init(SCREEN *sp)\n{\n    TERMINAL_CONTROL_BLOCK *TCB = TCBOf(sp);\n\n    AssertTCB();\n\n     \n    sp->_use_rmso = SGR0_TEST(exit_standout_mode);\n    sp->_use_rmul = SGR0_TEST(exit_underline_mode);\n\n     \n    sp->_scrolling = ((scroll_forward && scroll_reverse) ||\n\t\t      ((parm_rindex ||\n\t\t\tparm_insert_line ||\n\t\t\tinsert_line) &&\n\t\t       (parm_index ||\n\t\t\tparm_delete_line ||\n\t\t\tdelete_line)));\n\n    NCURSES_SP_NAME(baudrate) (sp);\n\n    NCURSES_SP_NAME(_nc_mvcur_init) (sp);\n     \n    NCURSES_SP_NAME(_nc_screen_init) (sp);\n}\n\nstatic void\ndrv_init(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    TERMINAL *trm;\n\n    AssertTCB();\n\n    trm = (TERMINAL *) TCB;\n\n    TCB->info.initcolor = VALID_STRING(initialize_color);\n    TCB->info.canchange = can_change;\n    TCB->info.hascolor = ((VALID_NUMERIC(max_colors) && VALID_NUMERIC(max_pairs)\n\t\t\t   && (((set_foreground != NULL)\n\t\t\t\t&& (set_background != NULL))\n\t\t\t       || ((set_a_foreground != NULL)\n\t\t\t\t   && (set_a_background != NULL))\n\t\t\t       || set_color_pair)) ? TRUE : FALSE);\n\n    TCB->info.caninit = !(exit_ca_mode && non_rev_rmcup);\n\n    TCB->info.maxpairs = VALID_NUMERIC(max_pairs) ? max_pairs : 0;\n    TCB->info.maxcolors = VALID_NUMERIC(max_colors) ? max_colors : 0;\n    TCB->info.numlabels = VALID_NUMERIC(num_labels) ? num_labels : 0;\n    TCB->info.labelwidth = VALID_NUMERIC(label_width) ? label_width : 0;\n    TCB->info.labelheight = VALID_NUMERIC(label_height) ? label_height : 0;\n    TCB->info.nocolorvideo = VALID_NUMERIC(no_color_video) ? no_color_video\n\t: 0;\n    TCB->info.tabsize = VALID_NUMERIC(init_tabs) ? (int) init_tabs : 8;\n\n    TCB->info.defaultPalette = hue_lightness_saturation ? _nc_hls_palette : _nc_cga_palette;\n\n     \n    if (NC_ISATTY(trm->Filedes)) {\n\tTCB->drv->td_mode(TCB, TRUE, TRUE);\n    }\n}\n\n#define MAX_PALETTE\t8\n#define InPalette(n)\t((n) >= 0 && (n) < MAX_PALETTE)\n\nstatic void\ndrv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {\n\tconst color_t *tp = InfoOf(sp).defaultPalette;\n\n\tTR(TRACE_ATTRS,\n\t   (\"initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)\",\n\t    pair,\n\t    tp[f].red, tp[f].green, tp[f].blue,\n\t    tp[b].red, tp[b].green, tp[b].blue));\n\n\tNCURSES_PUTP2(\"initialize_pair\",\n\t\t      TIPARM_7(initialize_pair,\n\t\t\t       pair,\n\t\t\t       tp[f].red, tp[f].green, tp[f].blue,\n\t\t\t       tp[b].red, tp[b].green, tp[b].blue));\n    }\n}\n\nstatic int\ndefault_fg(SCREEN *sp)\n{\n#if NCURSES_EXT_FUNCS\n    return (sp != 0) ? sp->_default_fg : COLOR_WHITE;\n#else\n    return COLOR_WHITE;\n#endif\n}\n\nstatic int\ndefault_bg(SCREEN *sp)\n{\n#if NCURSES_EXT_FUNCS\n    return sp != 0 ? sp->_default_bg : COLOR_BLACK;\n#else\n    return COLOR_BLACK;\n#endif\n}\n\nstatic void\ndrv_initcolor(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int color, int r, int g, int b)\n{\n    SCREEN *sp = TCB->csp;\n\n    AssertTCB();\n    if (initialize_color != NULL) {\n\tNCURSES_PUTP2(\"initialize_color\",\n\t\t      TIPARM_4(initialize_color, color, r, g, b));\n    }\n}\n\nstatic void\ndrv_do_color(TERMINAL_CONTROL_BLOCK * TCB,\n\t     int old_pair,\n\t     int pair,\n\t     int reverse,\n\t     NCURSES_SP_OUTC outc)\n{\n    SCREEN *sp = TCB->csp;\n    int fg = COLOR_DEFAULT;\n    int bg = COLOR_DEFAULT;\n    int old_fg, old_bg;\n\n    AssertTCB();\n    if (sp == 0)\n\treturn;\n\n    if (pair < 0 || pair >= COLOR_PAIRS) {\n\treturn;\n    } else if (pair != 0) {\n\tif (set_color_pair) {\n\t    TPUTS_TRACE(\"set_color_pair\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TIPARM_1(set_color_pair, pair), 1, outc);\n\t    return;\n\t} else if (sp != 0) {\n\t    _nc_pair_content(SP_PARM, pair, &fg, &bg);\n\t}\n    }\n\n    if (old_pair >= 0\n\t&& sp != 0\n\t&& _nc_pair_content(SP_PARM, old_pair, &old_fg, &old_bg) != ERR) {\n\tif ((isDefaultColor(fg) && !isDefaultColor(old_fg))\n\t    || (isDefaultColor(bg) && !isDefaultColor(old_bg))) {\n#if NCURSES_EXT_FUNCS\n\t     \n\t    if (sp->_has_sgr_39_49\n\t\t&& isDefaultColor(old_bg)\n\t\t&& !isDefaultColor(old_fg)) {\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx \"\\033[39m\", 1, outc);\n\t    } else if (sp->_has_sgr_39_49\n\t\t       && isDefaultColor(old_fg)\n\t\t       && !isDefaultColor(old_bg)) {\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx \"\\033[49m\", 1, outc);\n\t    } else\n#endif\n\t\tdrv_rescol(TCB);\n\t}\n    } else {\n\tdrv_rescol(TCB);\n\tif (old_pair < 0)\n\t    return;\n    }\n\n#if NCURSES_EXT_FUNCS\n    if (isDefaultColor(fg))\n\tfg = default_fg(sp);\n    if (isDefaultColor(bg))\n\tbg = default_bg(sp);\n#endif\n\n    if (reverse) {\n\tint xx = fg;\n\tfg = bg;\n\tbg = xx;\n    }\n\n    TR(TRACE_ATTRS, (\"setting colors: pair = %d, fg = %d, bg = %d\", pair,\n\t\t     fg, bg));\n\n    if (!isDefaultColor(fg)) {\n\tdrv_setcolor(TCB, TRUE, fg, outc);\n    }\n    if (!isDefaultColor(bg)) {\n\tdrv_setcolor(TCB, FALSE, bg, outc);\n    }\n}\n\n#define xterm_kmous \"\\033[M\"\nstatic void\ninit_xterm_mouse(SCREEN *sp)\n{\n    sp->_mouse_type = M_XTERM;\n    sp->_mouse_xtermcap = NCURSES_SP_NAME(tigetstr) (NCURSES_SP_ARGx \"XM\");\n    if (!VALID_STRING(sp->_mouse_xtermcap))\n\tsp->_mouse_xtermcap = \"\\033[?1000%?%p1%{1}%=%th%el%;\";\n}\n\nstatic void\ndrv_initmouse(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n     \n    if (sp != 0) {\n\tif (NonEmpty(key_mouse)) {\n\t    init_xterm_mouse(sp);\n\t} else if (strstr(SP_TERMTYPE term_names, \"xterm\") != 0) {\n\t    if (_nc_add_to_try(&(sp->_keytry), xterm_kmous, KEY_MOUSE) == OK)\n\t\tinit_xterm_mouse(sp);\n\t}\n    }\n}\n\nstatic int\ndrv_testmouse(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int delay\n\t      EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc = 0;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n#if USE_SYSMOUSE\n    if ((sp->_mouse_type == M_SYSMOUSE)\n\t&& (sp->_sysmouse_head < sp->_sysmouse_tail)) {\n\trc = TW_MOUSE;\n    } else\n#endif\n    {\n#ifdef EXP_WIN32_DRIVER\n\trc = _nc_console_testmouse(sp,\n\t\t\t\t   _nc_console_handle(sp->_ifd),\n\t\t\t\t   delay\n\t\t\t\t   EVENTLIST_2nd(evl));\n#else\n\trc = TCBOf(sp)->drv->td_twait(TCBOf(sp),\n\t\t\t\t      TWAIT_MASK,\n\t\t\t\t      delay,\n\t\t\t\t      (int *) 0\n\t\t\t\t      EVENTLIST_2nd(evl));\n#endif\n#if USE_SYSMOUSE\n\tif ((sp->_mouse_type == M_SYSMOUSE)\n\t    && (sp->_sysmouse_head < sp->_sysmouse_tail)\n\t    && (rc == 0)\n\t    && (errno == EINTR)) {\n\t    rc |= TW_MOUSE;\n\t}\n#endif\n    }\n    return rc;\n}\n\nstatic int\ndrv_mvcur(TERMINAL_CONTROL_BLOCK * TCB, int yold, int xold, int ynew, int xnew)\n{\n    SCREEN *sp = TCB->csp;\n    AssertTCB();\n    return NCURSES_SP_NAME(_nc_mvcur) (sp, yold, xold, ynew, xnew);\n}\n\nstatic void\ndrv_hwlabel(TERMINAL_CONTROL_BLOCK * TCB, int labnum, char *text)\n{\n    SCREEN *sp = TCB->csp;\n\n    AssertTCB();\n    if (labnum > 0 && labnum <= num_labels) {\n\tNCURSES_PUTP2(\"plab_norm\",\n\t\t      TPARM_2(plab_norm, labnum, text));\n    }\n}\n\nstatic void\ndrv_hwlabelOnOff(TERMINAL_CONTROL_BLOCK * TCB, int OnFlag)\n{\n    SCREEN *sp = TCB->csp;\n\n    AssertTCB();\n    if (OnFlag) {\n\tNCURSES_PUTP2(\"label_on\", label_on);\n    } else {\n\tNCURSES_PUTP2(\"label_off\", label_off);\n    }\n}\n\nstatic chtype\ndrv_conattr(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    SCREEN *sp = TCB->csp;\n    chtype attrs = A_NORMAL;\n\n    AssertTCB();\n    if (enter_alt_charset_mode)\n\tattrs |= A_ALTCHARSET;\n\n    if (enter_blink_mode)\n\tattrs |= A_BLINK;\n\n    if (enter_bold_mode)\n\tattrs |= A_BOLD;\n\n    if (enter_dim_mode)\n\tattrs |= A_DIM;\n\n    if (enter_reverse_mode)\n\tattrs |= A_REVERSE;\n\n    if (enter_standout_mode)\n\tattrs |= A_STANDOUT;\n\n    if (enter_protected_mode)\n\tattrs |= A_PROTECT;\n\n    if (enter_secure_mode)\n\tattrs |= A_INVIS;\n\n    if (enter_underline_mode)\n\tattrs |= A_UNDERLINE;\n\n    if (sp && sp->_coloron)\n\tattrs |= A_COLOR;\n\n#if USE_ITALIC\n    if (enter_italics_mode)\n\tattrs |= A_ITALIC;\n#endif\n\n    return (attrs);\n}\n\nstatic void\ndrv_setfilter(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    AssertTCB();\n\n     \n    clear_screen     = ABSENT_STRING;\n    cursor_address   = ABSENT_STRING;\n    cursor_down      = ABSENT_STRING;\n    cursor_up        = ABSENT_STRING;\n    parm_down_cursor = ABSENT_STRING;\n    parm_up_cursor   = ABSENT_STRING;\n    row_address      = ABSENT_STRING;\n    cursor_home      = carriage_return;\n\n    if (back_color_erase)\n\tclr_eos = ABSENT_STRING;\n}\n\nstatic void\ndrv_initacs(TERMINAL_CONTROL_BLOCK * TCB, chtype *real_map, chtype *fake_map)\n{\n    SCREEN *sp = TCB->csp;\n\n    AssertTCB();\n    assert(sp != 0);\n    if (ena_acs != NULL) {\n\tNCURSES_PUTP2(\"ena_acs\", ena_acs);\n    }\n#if NCURSES_EXT_FUNCS\n     \n#define PCH_KLUDGE(a,b) (a != 0 && b != 0 && !strcmp(a,b))\n    if (PCH_KLUDGE(enter_pc_charset_mode, enter_alt_charset_mode) &&\n\tPCH_KLUDGE(exit_pc_charset_mode, exit_alt_charset_mode)) {\n\tsize_t i;\n\tfor (i = 1; i < ACS_LEN; ++i) {\n\t    if (real_map[i] == 0) {\n\t\treal_map[i] = (chtype) i;\n\t\tif (real_map != fake_map) {\n\t\t    if (sp != 0)\n\t\t\tsp->_screen_acs_map[i] = TRUE;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    if (acs_chars != NULL) {\n\tsize_t i = 0;\n\tsize_t length = strlen(acs_chars);\n\n\twhile (i + 1 < length) {\n\t    if (acs_chars[i] != 0 && UChar(acs_chars[i]) < ACS_LEN) {\n\t\treal_map[UChar(acs_chars[i])] = UChar(acs_chars[i + 1]) | A_ALTCHARSET;\n\t\tT((\"#%d real_map[%s] = %s\",\n\t\t   (int) i,\n\t\t   _tracechar(UChar(acs_chars[i])),\n\t\t   _tracechtype(real_map[UChar(acs_chars[i])])));\n\t\tif (sp != 0) {\n\t\t    sp->_screen_acs_map[UChar(acs_chars[i])] = TRUE;\n\t\t}\n\t    }\n\t    i += 2;\n\t}\n    }\n#ifdef TRACE\n     \n    if (USE_TRACEF(TRACE_CALLS)) {\n\tsize_t n, m;\n\tchar show[ACS_LEN * 2 + 1];\n\tfor (n = 1, m = 0; n < ACS_LEN; n++) {\n\t    if (real_map[n] != 0) {\n\t\tshow[m++] = (char) n;\n\t\tshow[m++] = (char) ChCharOf(real_map[n]);\n\t    }\n\t}\n\tshow[m] = 0;\n\tif (acs_chars == NULL || strcmp(acs_chars, show))\n\t    _tracef(\"%s acs_chars %s\",\n\t\t    (acs_chars == NULL) ? \"NULL\" : \"READ\",\n\t\t    _nc_visbuf(acs_chars));\n\t_tracef(\"%s acs_chars %s\",\n\t\t(acs_chars == NULL)\n\t\t? \"NULL\"\n\t\t: (strcmp(acs_chars, show)\n\t\t   ? \"DIFF\"\n\t\t   : \"SAME\"),\n\t\t_nc_visbuf(show));\n\t_nc_unlock_global(tracef);\n    }\n#endif  \n}\n\n#define ENSURE_TINFO(sp) (TCBOf(sp)->drv->isTerminfo)\n\nNCURSES_EXPORT(void)\n_nc_cookie_init(SCREEN *sp)\n{\n    bool support_cookies = USE_XMC_SUPPORT;\n    TERMINAL_CONTROL_BLOCK *TCB = (TERMINAL_CONTROL_BLOCK *) (sp->_term);\n\n    if (sp == 0 || !ENSURE_TINFO(sp))\n\treturn;\n\n#if USE_XMC_SUPPORT\n     \n    if (magic_cookie_glitch >= 0) {\n\tif (getenv(\"NCURSES_NO_MAGIC_COOKIE\") != 0) {\n\t    support_cookies = FALSE;\n\t}\n    }\n#endif\n\n    if (!support_cookies && magic_cookie_glitch >= 0) {\n\tT((\"will disable attributes to work w/o magic cookies\"));\n    }\n\n    if (magic_cookie_glitch > 0) {\t \n\n\tsp->_xmc_triggers = sp->_ok_attributes & XMC_CONFLICT;\n#if 0\n\t \n\tif (has_colors()) {\n\t    sp->_xmc_triggers |= A_COLOR;\n\t}\n#endif\n\tsp->_xmc_suppress = sp->_xmc_triggers & (chtype) ~(A_BOLD);\n\n\tT((\"magic cookie attributes %s\", _traceattr(sp->_xmc_suppress)));\n\t \n\tacs_chars = ABSENT_STRING;\n\tena_acs = ABSENT_STRING;\n\tenter_alt_charset_mode = ABSENT_STRING;\n\texit_alt_charset_mode = ABSENT_STRING;\n#if USE_XMC_SUPPORT\n\t \n\tif (support_cookies) {\n\t    clr_eol = ABSENT_STRING;\n\t    clr_eos = ABSENT_STRING;\n\t    set_attributes = ABSENT_STRING;\n\t}\n#endif\n    } else if (magic_cookie_glitch == 0) {\t \n    }\n\n     \n    if (!support_cookies && magic_cookie_glitch >= 0) {\n\tmagic_cookie_glitch = ABSENT_NUMERIC;\n\tset_attributes = ABSENT_STRING;\n\tenter_blink_mode = ABSENT_STRING;\n\tenter_bold_mode = ABSENT_STRING;\n\tenter_dim_mode = ABSENT_STRING;\n\tenter_reverse_mode = ABSENT_STRING;\n\tenter_standout_mode = ABSENT_STRING;\n\tenter_underline_mode = ABSENT_STRING;\n    }\n\n     \n#if !USE_WIDEC_SUPPORT\n    if (_nc_unicode_locale() && _nc_locale_breaks_acs(sp->_term)) {\n\tacs_chars = NULL;\n\tena_acs = NULL;\n\tenter_alt_charset_mode = NULL;\n\texit_alt_charset_mode = NULL;\n\tset_attributes = NULL;\n    }\n#endif\n}\n\nstatic int\ndrv_twait(TERMINAL_CONTROL_BLOCK * TCB,\n\t  int mode,\n\t  int milliseconds,\n\t  int *timeleft\n\t  EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n#ifdef EXP_WIN32_DRIVER\n    return _nc_console_twait(sp,\n\t\t\t     _nc_console_handle(sp->_ifd),\n\t\t\t     mode,\n\t\t\t     milliseconds,\n\t\t\t     timeleft EVENTLIST_2nd(evl));\n#else\n    return _nc_timed_wait(sp, mode, milliseconds, timeleft EVENTLIST_2nd(evl));\n#endif\n}\n\nstatic int\ndrv_read(TERMINAL_CONTROL_BLOCK * TCB, int *buf)\n{\n    SCREEN *sp;\n    int n;\n#ifndef EXP_WIN32_DRIVER\n    unsigned char c2 = 0;\n#endif\n\n    AssertTCB();\n    assert(buf);\n    SetSP();\n\n    _nc_set_read_thread(TRUE);\n#ifdef EXP_WIN32_DRIVER\n    n = _nc_console_read(sp,\n\t\t\t _nc_console_handle(sp->_ifd),\n\t\t\t buf);\n#else\n    n = (int) read(sp->_ifd, &c2, (size_t) 1);\n#endif\n    _nc_set_read_thread(FALSE);\n#ifndef EXP_WIN32_DRIVER\n    *buf = (int) c2;\n#endif\n    return n;\n}\n\nstatic int\ndrv_nap(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int ms)\n{\n#if HAVE_NANOSLEEP\n    {\n\tstruct timespec request, remaining;\n\trequest.tv_sec = ms / 1000;\n\trequest.tv_nsec = (ms % 1000) * 1000000;\n\twhile (nanosleep(&request, &remaining) == -1\n\t       && errno == EINTR) {\n\t    request = remaining;\n\t}\n    }\n#elif defined(EXP_WIN32_DRIVER)\n    Sleep((DWORD) ms);\n#else\n    _nc_timed_wait(0, 0, ms, (int *) 0 EVENTLIST_2nd(0));\n#endif\n    return OK;\n}\n\nstatic int\n__nc_putp(SCREEN *sp, const char *name GCC_UNUSED, const char *value)\n{\n    int rc = ERR;\n\n    if (value) {\n\trc = NCURSES_PUTP2(name, value);\n    }\n    return rc;\n}\n\nstatic int\n__nc_putp_flush(SCREEN *sp, const char *name, const char *value)\n{\n    int rc = __nc_putp(sp, name, value);\n    if (rc != ERR) {\n\tNCURSES_SP_NAME(_nc_flush) (sp);\n    }\n    return rc;\n}\n\nstatic int\ndrv_kpad(TERMINAL_CONTROL_BLOCK * TCB, int flag)\n{\n    int ret = ERR;\n    SCREEN *sp;\n\n    AssertTCB();\n\n    sp = TCB->csp;\n\n    if (sp) {\n\tif (flag) {\n\t    (void) __nc_putp_flush(sp, \"keypad_xmit\", keypad_xmit);\n\t} else if (!flag && keypad_local) {\n\t    (void) __nc_putp_flush(sp, \"keypad_local\", keypad_local);\n\t}\n\tif (flag && !sp->_tried) {\n\t    _nc_init_keytry(sp);\n\t    sp->_tried = TRUE;\n\t}\n\tret = OK;\n    }\n\n    return ret;\n}\n\nstatic int\ndrv_keyok(TERMINAL_CONTROL_BLOCK * TCB, int c, int flag)\n{\n    SCREEN *sp;\n    int code = ERR;\n    int count = 0;\n    char *s;\n\n    AssertTCB();\n    SetSP();\n\n    if (c >= 0) {\n\tunsigned ch = (unsigned) c;\n\tif (flag) {\n\t    while ((s = _nc_expand_try(sp->_key_ok,\n\t\t\t\t       ch, &count, (size_t) 0)) != 0) {\n\t\tif (_nc_remove_key(&(sp->_key_ok), ch)) {\n\t\t    code = _nc_add_to_try(&(sp->_keytry), s, ch);\n\t\t    free(s);\n\t\t    count = 0;\n\t\t    if (code != OK)\n\t\t\tbreak;\n\t\t} else {\n\t\t    free(s);\n\t\t}\n\t    }\n\t} else {\n\t    while ((s = _nc_expand_try(sp->_keytry,\n\t\t\t\t       ch, &count, (size_t) 0)) != 0) {\n\t\tif (_nc_remove_key(&(sp->_keytry), ch)) {\n\t\t    code = _nc_add_to_try(&(sp->_key_ok), s, ch);\n\t\t    free(s);\n\t\t    count = 0;\n\t\t    if (code != OK)\n\t\t\tbreak;\n\t\t} else {\n\t\t    free(s);\n\t\t}\n\t    }\n\t}\n    }\n    return (code);\n}\n\nstatic int\ndrv_cursorSet(TERMINAL_CONTROL_BLOCK * TCB, int vis)\n{\n    SCREEN *sp;\n    int code = ERR;\n\n    AssertTCB();\n    SetSP();\n\n    T((T_CALLED(\"tinfo:drv_cursorSet(%p,%d)\"), (void *) SP_PARM, vis));\n\n    if (SP_PARM != 0 && IsTermInfo(SP_PARM)) {\n\tswitch (vis) {\n\tcase 2:\n\t    code = NCURSES_PUTP2_FLUSH(\"cursor_visible\", cursor_visible);\n\t    break;\n\tcase 1:\n\t    code = NCURSES_PUTP2_FLUSH(\"cursor_normal\", cursor_normal);\n\t    break;\n\tcase 0:\n\t    code = NCURSES_PUTP2_FLUSH(\"cursor_invisible\", cursor_invisible);\n\t    break;\n\t}\n    } else {\n\tcode = ERR;\n    }\n    returnCode(code);\n}\n\nstatic bool\ndrv_kyExist(TERMINAL_CONTROL_BLOCK * TCB, int key)\n{\n    bool res = FALSE;\n\n    AssertTCB();\n    if (TCB->csp)\n\tres = TINFO_HAS_KEY(TCB->csp, key) == 0 ? FALSE : TRUE;\n\n    return res;\n}\n\nNCURSES_EXPORT_VAR (TERM_DRIVER) _nc_TINFO_DRIVER = {\n    TRUE,\n\tdrv_Name,\t\t \n\tdrv_CanHandle,\t\t \n\tdrv_init,\t\t \n\tdrv_release,\t\t \n\tdrv_size,\t\t \n\tdrv_sgmode,\t\t \n\tdrv_conattr,\t\t \n\tdrv_mvcur,\t\t \n\tdrv_mode,\t\t \n\tdrv_rescol,\t\t \n\tdrv_rescolors,\t\t \n\tdrv_setcolor,\t\t \n\tdrv_dobeepflash,\t \n\tdrv_initpair,\t\t \n\tdrv_initcolor,\t\t \n\tdrv_do_color,\t\t \n\tdrv_initmouse,\t\t \n\tdrv_testmouse,\t\t \n\tdrv_setfilter,\t\t \n\tdrv_hwlabel,\t\t \n\tdrv_hwlabelOnOff,\t \n\tdrv_doupdate,\t\t \n\tdrv_defaultcolors,\t \n\tdrv_print,\t\t \n\tdrv_getsize,\t\t \n\tdrv_setsize,\t\t \n\tdrv_initacs,\t\t \n\tdrv_screen_init,\t \n\tdrv_wrap,\t\t \n\tdrv_twait,\t\t \n\tdrv_read,\t\t \n\tdrv_nap,\t\t \n\tdrv_kpad,\t\t \n\tdrv_keyok,\t\t \n\tdrv_kyExist,\t\t \n\tdrv_cursorSet\t\t \n};\n\n#ifdef EXP_WIN32_DRIVER\n \n\ntypedef struct DriverEntry {\n    const char *name;\n    TERM_DRIVER *driver;\n} DRIVER_ENTRY;\n\nstatic DRIVER_ENTRY DriverTable[] =\n{\n#ifdef _NC_WINDOWS\n    {\"win32console\", &_nc_WIN_DRIVER},\n#endif\n    {\"tinfo\", &_nc_TINFO_DRIVER}\t \n};\n\nNCURSES_EXPORT(int)\n_nc_get_driver(TERMINAL_CONTROL_BLOCK * TCB, const char *name, int *errret)\n{\n    int code = ERR;\n    size_t i;\n    TERM_DRIVER *res = (TERM_DRIVER *) 0;\n    TERM_DRIVER *use = 0;\n\n    T((T_CALLED(\"_nc_get_driver(%p, %s, %p)\"),\n       (void *) TCB, NonNull(name), (void *) errret));\n\n    assert(TCB != 0);\n\n    for (i = 0; i < SIZEOF(DriverTable); i++) {\n\tres = DriverTable[i].driver;\n#ifdef _NC_WINDOWS\n\tif ((i + 1) == SIZEOF(DriverTable)) {\n\t     \n\t    if (name == 0 || *name == 0 || (strcmp(name, \"unknown\") == 0)) {\n\t\tname = MS_TERMINAL;\n\t\tT((\"Set TERM=%s\", name));\n\t    }\n\t}\n#endif\n\tif (strcmp(DriverTable[i].name, res->td_name(TCB)) == 0) {\n\t    if (res->td_CanHandle(TCB, name, errret)) {\n\t\tuse = res;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (use != 0) {\n\tTCB->drv = use;\n\tcode = OK;\n    }\n    returnCode(code);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}