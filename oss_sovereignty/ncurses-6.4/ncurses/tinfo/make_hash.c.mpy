{
  "module_name": "make_hash.c",
  "hash_id": "0c9b4348090315a86a2b8511d4f02c181a5c914eb480b60898baf7cf4044db76",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/make_hash.c",
  "human_readable_source": " \n\n \n\n \n\n#include <build.priv.h>\n\n#include <tic.h>\n#include <hashsize.h>\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: make_hash.c,v 1.33 2020/02/02 23:34:34 tom Exp $\")\n\n \n\n#undef MODULE_ID\n#define MODULE_ID(id)\t\t \n#include <tinfo/doalloc.c>\n\n#define L_PAREN \"(\"\n#define R_PAREN \")\"\n#define L_BRACE \"{\"\n#define R_BRACE \"}\"\n\nstatic const char *typenames[] =\n{\"BOOLEAN\", \"NUMBER\", \"STRING\"};\n\nstatic void\nfailed(const char *s)\n{\n    perror(s);\n    exit(EXIT_FAILURE);\n}\n\nstatic char *\nstrmalloc(char *s)\n{\n    size_t need = strlen(s) + 1;\n    char *result = malloc(need);\n    if (result == 0)\n\tfailed(\"strmalloc\");\n    _nc_STRCPY(result, s, need);\n    return result;\n}\n\n \n\nstatic int\nhash_function(const char *string)\n{\n    long sum = 0;\n\n    while (*string) {\n\tsum += (long) (UChar(*string) + (UChar(*(string + 1)) << 8));\n\tstring++;\n    }\n\n    return (int) (sum % HASHTABSIZE);\n}\n\n#define UNUSED -1\n\nstatic void\n_nc_make_hash_table(struct user_table_entry *table,\n\t\t    HashValue * hash_table,\n\t\t    unsigned tablesize)\n{\n    unsigned i;\n    int hashvalue;\n    int collisions = 0;\n\n    for (i = 0; i < HASHTABSIZE; i++) {\n\thash_table[i] = UNUSED;\n    }\n    for (i = 0; i < tablesize; i++) {\n\thashvalue = hash_function(table[i].ute_name);\n\n\tif (hash_table[hashvalue] >= 0)\n\t    collisions++;\n\n\tif (hash_table[hashvalue] != UNUSED) {\n\t    table[i].ute_link = hash_table[hashvalue];\n\t}\n\thash_table[hashvalue] = (HashValue) i;\n    }\n\n    printf(\"/* %d collisions out of %d entries */\\n\", collisions, tablesize);\n}\n\n \n\n#define MAX_COLUMNS BUFSIZ\t \n\nstatic int\ncount_columns(char **list)\n{\n    int result = 0;\n    if (list != 0) {\n\twhile (*list++) {\n\t    ++result;\n\t}\n    }\n    return result;\n}\n\nstatic char **\nparse_columns(char *buffer)\n{\n    static char **list;\n\n    int col = 0;\n\n    if (buffer == 0) {\n\tfree(list);\n\tlist = 0;\n\treturn 0;\n    }\n\n    if (*buffer != '#') {\n\tif (list == 0) {\n\t    list = typeCalloc(char *, (MAX_COLUMNS + 1));\n\t    if (list == 0)\n\t\treturn (0);\n\t}\n\twhile (*buffer != '\\0') {\n\t    char *s;\n\t    for (s = buffer; (*s != '\\0') && !isspace(UChar(*s)); s++)\n\t\t  ;\n\t    if (s != buffer) {\n\t\tchar mark = *s;\n\t\t*s = '\\0';\n\t\tif ((s - buffer) > 1\n\t\t    && (*buffer == '\"')\n\t\t    && (s[-1] == '\"')) {\t \n\t\t    assert(s > buffer + 1);\n\t\t    s[-1] = '\\0';\n\t\t    buffer++;\n\t\t}\n\t\tlist[col] = buffer;\n\t\tcol++;\n\t\tif (mark == '\\0')\n\t\t    break;\n\t\twhile (*++s && isspace(UChar(*s)))\n\t\t      ;\n\t\tbuffer = s;\n\t    } else\n\t\tbreak;\n\t}\n    }\n    return col ? list : 0;\n}\n\n#define SetType(n,t) \\\n\tif (is_user) \\\n\t    name_table[n].ute_type |= (int)(1 << (t)); \\\n\telse \\\n\t    name_table[n].ute_type = (t)\n\n#define GetType(n) \\\n\t(is_user \\\n\t ? get_type(name_table[n].ute_type) \\\n\t : typenames[name_table[n].ute_type])\n\nstatic char *\nget_type(int type_mask)\n{\n    static char result[80];\n    unsigned n;\n    _nc_STRCPY(result, L_PAREN, sizeof(result));\n    for (n = 0; n < 3; ++n) {\n\tif ((1 << n) & type_mask) {\n\t    size_t want = 5 + strlen(typenames[n]);\n\t    if (want > sizeof(result)) {\n\t\tfprintf(stderr, \"Buffer is not large enough for %s + %s\\n\",\n\t\t\tresult, typenames[n]);\n\t\texit(EXIT_FAILURE);\n\t    }\n\t    if (result[1])\n\t\t_nc_STRCAT(result, \"|\", sizeof(result));\n\t    _nc_STRCAT(result, \"1<<\", sizeof(result));\n\t    _nc_STRCAT(result, typenames[n], sizeof(result));\n\t}\n    }\n    _nc_STRCAT(result, R_PAREN, sizeof(result));\n    return result;\n}\n\nint\nmain(int argc, char **argv)\n{\n    unsigned tablesize = CAPTABSIZE;\n    struct user_table_entry *name_table = typeCalloc(struct\n\t\t\t\t\t\t     user_table_entry, tablesize);\n    HashValue *hash_table = typeCalloc(HashValue, HASHTABSIZE);\n    const char *root_name = \"\";\n    int column = 0;\n    int bigstring = 0;\n    unsigned n;\n    unsigned nn;\n    unsigned tableused = 0;\n    bool is_user;\n    const char *table_name;\n    char buffer[BUFSIZ];\n\n    short BoolCount = 0;\n    short NumCount = 0;\n    short StrCount = 0;\n\n     \n    if (argc <= 3\n\t|| (column = atoi(argv[1])) <= 0\n\t|| (column >= MAX_COLUMNS)\n\t|| *(root_name = argv[2]) == 0\n\t|| (bigstring = atoi(argv[3])) < 0\n\t|| name_table == 0\n\t|| hash_table == 0) {\n\tfprintf(stderr, \"usage: make_hash column root_name bigstring\\n\");\n\texit(EXIT_FAILURE);\n    }\n    is_user = (*root_name == 'u');\n    table_name = (is_user ? \"user\" : \"name\");\n\n     \n    for (n = 0; (n < tablesize) && fgets(buffer, BUFSIZ, stdin);) {\n\tchar **list;\n\tchar *nlp = strchr(buffer, '\\n');\n\tif (nlp)\n\t    *nlp = '\\0';\n\telse\n\t    buffer[sizeof(buffer) - 2] = '\\0';\n\tlist = parse_columns(buffer);\n\tif (list == 0)\t\t \n\t    continue;\n\tif (is_user) {\n\t    if (strcmp(list[0], \"userdef\"))\n\t\tcontinue;\n\t} else if (!strcmp(list[0], \"userdef\")) {\n\t    continue;\n\t}\n\tif (column < 0 || column > count_columns(list)) {\n\t    fprintf(stderr, \"expected %d columns, have %d:\\n%s\\n\",\n\t\t    column,\n\t\t    count_columns(list),\n\t\t    buffer);\n\t    exit(EXIT_FAILURE);\n\t}\n\tnn = tableused;\n\tif (is_user) {\n\t    unsigned j;\n\t    for (j = 0; j < tableused; ++j) {\n\t\tif (!strcmp(list[column], name_table[j].ute_name)) {\n\t\t    nn = j;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (nn == tableused) {\n\t    name_table[nn].ute_link = -1;\t \n\t    name_table[nn].ute_name = strmalloc(list[column]);\n\t    ++tableused;\n\t}\n\n\tif (!strcmp(list[2], \"bool\")) {\n\t    SetType(nn, BOOLEAN);\n\t    name_table[nn].ute_index = BoolCount++;\n\t} else if (!strcmp(list[2], \"num\")) {\n\t    SetType(nn, NUMBER);\n\t    name_table[nn].ute_index = NumCount++;\n\t} else if (!strcmp(list[2], \"str\")) {\n\t    SetType(nn, STRING);\n\t    name_table[nn].ute_index = StrCount++;\n\t    if (is_user) {\n\t\tif (*list[3] != '-') {\n\t\t    unsigned j;\n\t\t    name_table[nn].ute_argc = (unsigned) strlen(list[3]);\n\t\t    for (j = 0; j < name_table[nn].ute_argc; ++j) {\n\t\t\tif (list[3][j] == 's') {\n\t\t\t    name_table[nn].ute_args |= (1U << j);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t} else {\n\t    fprintf(stderr, \"Unknown type: %s\\n\", list[2]);\n\t    exit(EXIT_FAILURE);\n\t}\n\tn++;\n    }\n    if (tablesize > tableused)\n\ttablesize = tableused;\n    _nc_make_hash_table(name_table, hash_table, tablesize);\n\n     \n    if (bigstring) {\n\tint len = 0;\n\tint nxt;\n\n\tprintf(\"static const char %s_names_text[] = \\\\\\n\", root_name);\n\tfor (n = 0; n < tablesize; n++) {\n\t    nxt = (int) strlen(name_table[n].ute_name) + 5;\n\t    if (nxt + len > 72) {\n\t\tprintf(\"\\\\\\n\");\n\t\tlen = 0;\n\t    }\n\t    printf(\"\\\"%s\\\\0\\\" \", name_table[n].ute_name);\n\t    len += nxt;\n\t}\n\tprintf(\";\\n\\n\");\n\n\tlen = 0;\n\tprintf(\"static %s_table_data const %s_names_data[] =\\n\",\n\t       table_name,\n\t       root_name);\n\tprintf(\"%s\\n\", L_BRACE);\n\tfor (n = 0; n < tablesize; n++) {\n\t    printf(\"\\t%s %15d,\\t%10s,\", L_BRACE, len, GetType(n));\n\t    if (is_user)\n\t\tprintf(\"\\t%d,%d,\",\n\t\t       name_table[n].ute_argc,\n\t\t       name_table[n].ute_args);\n\t    printf(\"\\t%3d, %3d %s%c\\n\",\n\t\t   name_table[n].ute_index,\n\t\t   name_table[n].ute_link,\n\t\t   R_BRACE,\n\t\t   n < tablesize - 1 ? ',' : ' ');\n\t    len += (int) strlen(name_table[n].ute_name) + 1;\n\t}\n\tprintf(\"%s;\\n\\n\", R_BRACE);\n\tprintf(\"static struct %s_table_entry *_nc_%s_table = 0;\\n\\n\",\n\t       table_name,\n\t       root_name);\n    } else {\n\n\tprintf(\"static struct %s_table_entry const _nc_%s_table[] =\\n\",\n\t       table_name,\n\t       root_name);\n\tprintf(\"%s\\n\", L_BRACE);\n\tfor (n = 0; n < tablesize; n++) {\n\t    _nc_SPRINTF(buffer, _nc_SLIMIT(sizeof(buffer)) \"\\\"%s\\\"\",\n\t\t\tname_table[n].ute_name);\n\t    printf(\"\\t%s %15s,\\t%10s,\", L_BRACE, buffer, GetType(n));\n\t    if (is_user)\n\t\tprintf(\"\\t%d,%d,\",\n\t\t       name_table[n].ute_argc,\n\t\t       name_table[n].ute_args);\n\t    printf(\"\\t%3d, %3d %s%c\\n\",\n\t\t   name_table[n].ute_index,\n\t\t   name_table[n].ute_link,\n\t\t   R_BRACE,\n\t\t   n < tablesize - 1 ? ',' : ' ');\n\t}\n\tprintf(\"%s;\\n\\n\", R_BRACE);\n    }\n\n    printf(\"static const HashValue _nc_%s_hash_table[%d] =\\n\",\n\t   root_name,\n\t   HASHTABSIZE + 1);\n    printf(\"%s\\n\", L_BRACE);\n    for (n = 0; n < HASHTABSIZE; n++) {\n\tprintf(\"\\t%3d,\\n\", hash_table[n]);\n    }\n    printf(\"\\t0\\t/* base-of-table */\\n\");\n    printf(\"%s;\\n\\n\", R_BRACE);\n\n    if (!is_user) {\n\tprintf(\"#if (BOOLCOUNT!=%d)||(NUMCOUNT!=%d)||(STRCOUNT!=%d)\\n\",\n\t       BoolCount, NumCount, StrCount);\n\tprintf(\"#error\\t--> term.h and comp_captab.c disagree about the <--\\n\");\n\tprintf(\"#error\\t--> numbers of booleans, numbers and/or strings <--\\n\");\n\tprintf(\"#endif\\n\\n\");\n    }\n\n    free(hash_table);\n    for (n = 0; (n < tablesize); ++n) {\n\tfree((void *) name_table[n].ute_name);\n    }\n    free(name_table);\n    parse_columns(0);\n\n    return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}