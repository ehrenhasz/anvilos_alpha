{
  "module_name": "write_entry.c",
  "hash_id": "b51b1192560d959835fd42ad1b3fe5a5ab979a6abbf494e16ec27d6671af7b4a",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/write_entry.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <hashed_db.h>\n\n#include <tic.h>\n\n#if 1\n#define TRACE_OUT(p) DEBUG(2, p)\n#define TRACE_NUM(n) if (VALID_NUMERIC(Numbers[n])) { \\\n\tTRACE_OUT((\"put Numbers[%u]=%d\", (unsigned) (n), Numbers[n])); }\n#else\n#define TRACE_OUT(p)\t\t \n#define TRACE_NUM(n)\t\t \n#endif\n\nMODULE_ID(\"$Id: write_entry.c,v 1.120 2022/04/23 19:59:10 tom Exp $\")\n\nstatic int total_written;\nstatic int total_parts;\nstatic int total_size;\n\nstatic int make_db_root(const char *);\n\n#if !USE_HASHED_DB\nstatic void\nwrite_file(char *filename, TERMTYPE2 *tp)\n{\n    char buffer[MAX_ENTRY_SIZE];\n    unsigned limit = sizeof(buffer);\n    unsigned offset = 0;\n\n    if (_nc_write_object(tp, buffer, &offset, limit) == ERR) {\n\t_nc_warning(\"entry is larger than %u bytes\", limit);\n    } else {\n\tFILE *fp = ((_nc_access(filename, W_OK) == 0)\n\t\t    ? safe_fopen(filename, BIN_W)\n\t\t    : 0);\n\tsize_t actual;\n\n\tif (fp == 0) {\n\t    perror(filename);\n\t    _nc_syserr_abort(\"can't open %s/%s\", _nc_tic_dir(0), filename);\n\t}\n\n\tactual = fwrite(buffer, sizeof(char), (size_t) offset, fp);\n\tif (actual != offset) {\n\t    int myerr = ferror(fp) ? errno : 0;\n\t    if (myerr) {\n\t\t_nc_syserr_abort(\"error writing %s/%s: %s\",\n\t\t\t\t _nc_tic_dir(0),\n\t\t\t\t filename,\n\t\t\t\t strerror(myerr));\n\t    } else {\n\t\t_nc_syserr_abort(\"error writing %s/%s: %u bytes vs actual %lu\",\n\t\t\t\t _nc_tic_dir(0),\n\t\t\t\t filename,\n\t\t\t\t offset,\n\t\t\t\t (unsigned long) actual);\n\t    }\n\t} else {\n\t    fclose(fp);\n\t    DEBUG(1, (\"Created %s\", filename));\n\t}\n    }\n}\n\n \nstatic void\ncheck_writeable(int code)\n{\n    static const char dirnames[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    static bool verified[sizeof(dirnames)];\n\n    char dir[sizeof(LEAF_FMT)];\n    char *s = 0;\n\n    if (code == 0 || (s = (strchr) (dirnames, code)) == 0)\n\t_nc_err_abort(\"Illegal terminfo subdirectory \\\"\" LEAF_FMT \"\\\"\", code);\n\n    if (verified[s - dirnames])\n\treturn;\n\n    _nc_SPRINTF(dir, _nc_SLIMIT(sizeof(dir)) LEAF_FMT, code);\n    if (make_db_root(dir) < 0) {\n\t_nc_err_abort(\"%s/%s: permission denied\", _nc_tic_dir(0), dir);\n    }\n\n    verified[s - dirnames] = TRUE;\n}\n#endif  \n\nstatic int\nmake_db_path(char *dst, const char *src, size_t limit)\n{\n    int rc = -1;\n    const char *top = _nc_tic_dir(0);\n\n    if (src == top || _nc_is_abs_path(src)) {\n\tif (strlen(src) + 1 <= limit) {\n\t    _nc_STRCPY(dst, src, limit);\n\t    rc = 0;\n\t}\n    } else {\n\tif ((strlen(top) + strlen(src) + 6) <= limit) {\n\t    _nc_SPRINTF(dst, _nc_SLIMIT(limit) \"%s/%s\", top, src);\n\t    rc = 0;\n\t}\n    }\n#if USE_HASHED_DB\n    if (rc == 0) {\n\tstatic const char suffix[] = DBM_SUFFIX;\n\tsize_t have = strlen(dst);\n\tsize_t need = strlen(suffix);\n\tif (have > need && strcmp(dst + (int) (have - need), suffix)) {\n\t    if (have + need <= limit) {\n\t\t_nc_STRCAT(dst, suffix, limit);\n\t    } else {\n\t\trc = -1;\n\t    }\n\t} else if (_nc_is_dir_path(dst)) {\n\t    rc = -1;\n\t}\n    }\n#endif\n    return rc;\n}\n\n \nstatic int\nmake_db_root(const char *path)\n{\n    int rc;\n    char fullpath[PATH_MAX];\n\n    if ((rc = make_db_path(fullpath, path, sizeof(fullpath))) == 0) {\n#if USE_HASHED_DB\n\tDB *capdbp;\n\n\tif ((capdbp = _nc_db_open(fullpath, TRUE)) == NULL) {\n\t    rc = -1;\n\t} else if (_nc_db_close(capdbp) < 0) {\n\t    rc = -1;\n\t}\n#else\n\tstruct stat statbuf;\n\n\tif ((rc = stat(path, &statbuf)) == -1) {\n\t    rc = mkdir(path\n#ifndef _NC_WINDOWS\n\t\t       ,0777\n#endif\n\t\t);\n\t} else if (_nc_access(path, R_OK | W_OK | X_OK) < 0) {\n\t    rc = -1;\t\t \n\t} else if (!(S_ISDIR(statbuf.st_mode))) {\n\t    rc = -1;\t\t \n\t}\n#endif\n    }\n    return rc;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_set_writedir(const char *dir)\n{\n    const char *destination;\n    char actual[PATH_MAX];\n\n    if (dir == 0\n#ifndef USE_ROOT_ENVIRON\n\t&& use_terminfo_vars()\n#endif\n\t)\n\tdir = getenv(\"TERMINFO\");\n\n    if (dir != 0)\n\t(void) _nc_tic_dir(dir);\n\n    destination = _nc_tic_dir(0);\n    if (make_db_root(destination) < 0) {\n\tchar *home = _nc_home_terminfo();\n\n\tif (home != 0) {\n\t    destination = home;\n\t    if (make_db_root(destination) < 0)\n\t\t_nc_err_abort(\"%s: permission denied (errno %d)\",\n\t\t\t      destination, errno);\n\t}\n    }\n\n     \n#if USE_HASHED_DB\n    make_db_path(actual, destination, sizeof(actual));\n#else\n    if (chdir(_nc_tic_dir(destination)) < 0\n\t|| getcwd(actual, sizeof(actual)) == 0)\n\t_nc_err_abort(\"%s: not a directory\", destination);\n#endif\n    _nc_keep_tic_dir(actual);\n}\n\n \n\nNCURSES_EXPORT(void)\n_nc_write_entry(TERMTYPE2 *const tp)\n{\n#if USE_HASHED_DB\n\n    char buffer[MAX_ENTRY_SIZE + 1];\n    unsigned limit = sizeof(buffer);\n    unsigned offset = 0;\n\n#else  \n\n    struct stat statbuf;\n    char filename[PATH_MAX];\n    char linkname[PATH_MAX];\n#if USE_SYMLINKS\n    char symlinkname[PATH_MAX];\n#if !HAVE_LINK\n#undef HAVE_LINK\n#define HAVE_LINK 1\n#endif\n#endif  \n\n    unsigned limit2 = sizeof(filename) - (2 + LEAF_LEN);\n    char saved = '\\0';\n\n    static int call_count;\n    static time_t start_time;\t \n\n#endif  \n\n    char name_list[MAX_TERMINFO_LENGTH];\n    char *first_name, *other_names;\n    char *ptr;\n    char *term_names = tp->term_names;\n    size_t name_size = strlen(term_names);\n\n    if (name_size == 0) {\n\t_nc_syserr_abort(\"no terminal name found.\");\n    } else if (name_size >= sizeof(name_list) - 1) {\n\t_nc_syserr_abort(\"terminal name too long: %s\", term_names);\n    }\n\n    _nc_STRCPY(name_list, term_names, sizeof(name_list));\n    DEBUG(7, (\"Name list = '%s'\", name_list));\n\n    first_name = name_list;\n\n    ptr = &name_list[name_size - 1];\n    other_names = ptr + 1;\n\n    while (ptr > name_list && *ptr != '|')\n\tptr--;\n\n    if (ptr != name_list) {\n\t*ptr = '\\0';\n\n\tfor (ptr = name_list; *ptr != '\\0' && *ptr != '|'; ptr++)\n\t    continue;\n\n\tif (*ptr == '\\0')\n\t    other_names = ptr;\n\telse {\n\t    *ptr = '\\0';\n\t    other_names = ptr + 1;\n\t}\n    }\n\n    DEBUG(7, (\"First name = '%s'\", first_name));\n    DEBUG(7, (\"Other names = '%s'\", other_names));\n\n    _nc_set_type(first_name);\n\n#if USE_HASHED_DB\n    if (_nc_write_object(tp, buffer + 1, &offset, limit - 1) != ERR) {\n\tDB *capdb = _nc_db_open(_nc_tic_dir(0), TRUE);\n\tDBT key, data;\n\n\tif (capdb != 0) {\n\t    buffer[0] = 0;\n\n\t    memset(&key, 0, sizeof(key));\n\t    key.data = term_names;\n\t    key.size = name_size;\n\n\t    memset(&data, 0, sizeof(data));\n\t    data.data = buffer;\n\t    data.size = offset + 1;\n\n\t    _nc_db_put(capdb, &key, &data);\n\n\t    buffer[0] = 2;\n\n\t    key.data = name_list;\n\t    key.size = strlen(name_list);\n\n\t    _nc_STRCPY(buffer + 1,\n\t\t       term_names,\n\t\t       sizeof(buffer) - 1);\n\t    data.size = name_size + 1;\n\n\t    total_size += data.size;\n\t    total_parts++;\n\t    _nc_db_put(capdb, &key, &data);\n\n\t    while (*other_names != '\\0') {\n\t\tptr = other_names++;\n\t\tassert(ptr < buffer + sizeof(buffer) - 1);\n\t\twhile (*other_names != '|' && *other_names != '\\0')\n\t\t    other_names++;\n\n\t\tif (*other_names != '\\0')\n\t\t    *(other_names++) = '\\0';\n\n\t\tkey.data = ptr;\n\t\tkey.size = strlen(ptr);\n\n\t\ttotal_size += data.size;\n\t\ttotal_parts++;\n\t\t_nc_db_put(capdb, &key, &data);\n\t    }\n\t}\n    }\n#else  \n    if (call_count++ == 0) {\n\tstart_time = 0;\n    }\n\n    if (strlen(first_name) >= limit2) {\n\t_nc_warning(\"terminal name too long.\");\n\tsaved = first_name[limit2];\n\tfirst_name[limit2] = '\\0';\n    }\n\n    _nc_SPRINTF(filename, _nc_SLIMIT(sizeof(filename))\n\t\tLEAF_FMT \"/%.*s\", UChar(first_name[0]),\n\t\t(int) (sizeof(filename) - (LEAF_LEN + 2)),\n\t\tfirst_name);\n\n    if (saved)\n\tfirst_name[limit2] = saved;\n\n     \n    if (start_time > 0 &&\n\tstat(filename, &statbuf) >= 0\n\t&& statbuf.st_mtime >= start_time) {\n#if HAVE_LINK && !USE_SYMLINKS\n\t \n\tif (statbuf.st_nlink > 1) {\n\t    _nc_warning(\"name redefined.\");\n\t    unlink(filename);\n\t} else {\n\t    _nc_warning(\"name multiply defined.\");\n\t}\n#else\n\t_nc_warning(\"name multiply defined.\");\n#endif\n    }\n\n    check_writeable(first_name[0]);\n    write_file(filename, tp);\n\n    if (start_time == 0) {\n\tif (stat(filename, &statbuf) == -1\n\t    || (start_time = statbuf.st_mtime) == 0) {\n\t    _nc_syserr_abort(\"error obtaining time from %s/%s\",\n\t\t\t     _nc_tic_dir(0), filename);\n\t}\n    }\n    while (*other_names != '\\0') {\n\tptr = other_names++;\n\twhile (*other_names != '|' && *other_names != '\\0')\n\t    other_names++;\n\n\tif (*other_names != '\\0')\n\t    *(other_names++) = '\\0';\n\n\tif (strlen(ptr) > sizeof(linkname) - (2 + LEAF_LEN)) {\n\t    _nc_warning(\"terminal alias %s too long.\", ptr);\n\t    continue;\n\t}\n\tif (strchr(ptr, '/') != 0) {\n\t    _nc_warning(\"cannot link alias %s.\", ptr);\n\t    continue;\n\t}\n\n\tcheck_writeable(ptr[0]);\n\t_nc_SPRINTF(linkname, _nc_SLIMIT(sizeof(linkname))\n\t\t    LEAF_FMT \"/%.*s\", ptr[0],\n\t\t    (int) sizeof(linkname) - (2 + LEAF_LEN), ptr);\n\n\tif (strcmp(filename, linkname) == 0) {\n\t    _nc_warning(\"self-synonym ignored\");\n\t} else if (stat(linkname, &statbuf) >= 0 &&\n\t\t   statbuf.st_mtime < start_time) {\n\t    _nc_warning(\"alias %s multiply defined.\", ptr);\n\t} else if (_nc_access(linkname, W_OK) == 0)\n#if HAVE_LINK\n\t{\n\t    int code;\n#if USE_SYMLINKS\n#define MY_SIZE sizeof(symlinkname) - 1\n\t    if (first_name[0] == linkname[0]) {\n\t\t_nc_STRNCPY(symlinkname, first_name, MY_SIZE);\n\t    } else {\n\t\t_nc_STRCPY(symlinkname, \"../\", sizeof(symlinkname));\n\t\t_nc_STRNCPY(symlinkname + 3, filename, MY_SIZE - 3);\n\t    }\n\t    symlinkname[MY_SIZE] = '\\0';\n#endif  \n#if HAVE_REMOVE\n\t    code = remove(linkname);\n#else\n\t    code = unlink(linkname);\n#endif\n\t    if (code != 0 && errno == ENOENT)\n\t\tcode = 0;\n#if USE_SYMLINKS\n\t    if (symlink(symlinkname, linkname) < 0)\n#else\n\t    if (link(filename, linkname) < 0)\n#endif  \n\t    {\n\t\t \n\t\tif (code == 0 && errno == EEXIST)\n\t\t    _nc_warning(\"can't link %s to %s\", filename, linkname);\n\t\telse if (code == 0 && (errno == EPERM || errno == ENOENT))\n\t\t    write_file(linkname, tp);\n\t\telse {\n#if MIXEDCASE_FILENAMES\n\t\t    _nc_syserr_abort(\"can't link %s to %s\", filename, linkname);\n#else\n\t\t    _nc_warning(\"can't link %s to %s (errno=%d)\", filename,\n\t\t\t\tlinkname, errno);\n#endif\n\t\t}\n\t    } else {\n\t\tDEBUG(1, (\"Linked %s\", linkname));\n\t    }\n\t}\n#else  \n\t    write_file(linkname, tp);\n#endif  \n    }\n#endif  \n}\n\nstatic size_t\nfake_write(char *dst,\n\t   unsigned *offset,\n\t   size_t limit,\n\t   char *src,\n\t   size_t want,\n\t   size_t size)\n{\n    size_t have = (limit - *offset);\n\n    want *= size;\n    if (have > 0) {\n\tif (want > have)\n\t    want = have;\n\tmemcpy(dst + *offset, src, want);\n\t*offset += (unsigned) want;\n    } else {\n\twant = 0;\n    }\n    return (want / size);\n}\n\n#define Write(buf, size, count) fake_write(buffer, offset, (size_t) limit, (char *) buf, (size_t) count, (size_t) size)\n\n#undef LITTLE_ENDIAN\t\t \n#define HI(x)\t\t\t((x) / 256)\n#define LO(x)\t\t\t((x) % 256)\n#define LITTLE_ENDIAN(p, x)\t(p)[0] = (unsigned char)LO(x),  \\\n                                (p)[1] = (unsigned char)HI(x)\n\n#define WRITE_STRING(str) (Write(str, sizeof(char), strlen(str) + 1) == strlen(str) + 1)\n\nstatic int\ncompute_offsets(char **Strings, size_t strmax, short *offsets)\n{\n    int nextfree = 0;\n    size_t i;\n\n    for (i = 0; i < strmax; i++) {\n\tif (Strings[i] == ABSENT_STRING) {\n\t    offsets[i] = -1;\n\t} else if (Strings[i] == CANCELLED_STRING) {\n\t    offsets[i] = -2;\n\t} else {\n\t    offsets[i] = (short) nextfree;\n\t    nextfree += (int) strlen(Strings[i]) + 1;\n\t    TRACE_OUT((\"put Strings[%d]=%s(%d)\", (int) i,\n\t\t       _nc_visbuf(Strings[i]), (int) nextfree));\n\t}\n    }\n    return nextfree;\n}\n\nstatic size_t\nconvert_shorts(unsigned char *buf, short *Numbers, size_t count)\n{\n    size_t i;\n    for (i = 0; i < count; i++) {\n\tif (Numbers[i] == ABSENT_NUMERIC) {\t \n\t    buf[2 * i] = buf[2 * i + 1] = 0377;\n\t} else if (Numbers[i] == CANCELLED_NUMERIC) {\t \n\t    buf[2 * i] = 0376;\n\t    buf[2 * i + 1] = 0377;\n\t} else {\n\t    LITTLE_ENDIAN(buf + 2 * i, Numbers[i]);\n\t    TRACE_OUT((\"put Numbers[%u]=%d\", (unsigned) i, Numbers[i]));\n\t}\n    }\n    return SIZEOF_SHORT;\n}\n\n#if NCURSES_EXT_NUMBERS\nstatic size_t\nconvert_16bit(unsigned char *buf, NCURSES_INT2 *Numbers, size_t count)\n{\n    size_t i, j;\n    size_t size = SIZEOF_SHORT;\n    for (i = 0; i < count; i++) {\n\tunsigned value = (unsigned) Numbers[i];\n\tTRACE_NUM(i);\n\tfor (j = 0; j < size; ++j) {\n\t    *buf++ = value & 0xff;\n\t    value >>= 8;\n\t}\n    }\n    return size;\n}\n\nstatic size_t\nconvert_32bit(unsigned char *buf, NCURSES_INT2 *Numbers, size_t count)\n{\n    size_t i, j;\n    size_t size = SIZEOF_INT2;\n    for (i = 0; i < count; i++) {\n\tunsigned value = (unsigned) Numbers[i];\n\tTRACE_NUM(i);\n\tfor (j = 0; j < size; ++j) {\n\t    *buf++ = value & 0xff;\n\t    value >>= 8;\n\t}\n    }\n    return size;\n}\n#endif\n\n#define even_boundary(value) \\\n\t    ((value) % 2 != 0 && Write(&zero, sizeof(char), 1) != 1)\n\n#if NCURSES_XNAMES\nstatic unsigned\nextended_Booleans(TERMTYPE2 *tp)\n{\n    unsigned result = 0;\n    unsigned i;\n\n    for (i = 0; i < tp->ext_Booleans; ++i) {\n\tif (tp->Booleans[BOOLCOUNT + i] == TRUE)\n\t    result = (i + 1);\n    }\n    return result;\n}\n\nstatic unsigned\nextended_Numbers(TERMTYPE2 *tp)\n{\n    unsigned result = 0;\n    unsigned i;\n\n    for (i = 0; i < tp->ext_Numbers; ++i) {\n\tif (tp->Numbers[NUMCOUNT + i] != ABSENT_NUMERIC)\n\t    result = (i + 1);\n    }\n    return result;\n}\n\nstatic unsigned\nextended_Strings(TERMTYPE2 *tp)\n{\n    unsigned short result = 0;\n    unsigned short i;\n\n    for (i = 0; i < tp->ext_Strings; ++i) {\n\tif (tp->Strings[STRCOUNT + i] != ABSENT_STRING)\n\t    result = (unsigned short) (i + 1);\n    }\n    return result;\n}\n\n \nstatic bool\nextended_object(TERMTYPE2 *tp)\n{\n    bool result = FALSE;\n\n    if (_nc_user_definable) {\n\tresult = ((extended_Booleans(tp)\n\t\t   + extended_Numbers(tp)\n\t\t   + extended_Strings(tp)) != 0);\n    }\n    return result;\n}\n#endif\n\nNCURSES_EXPORT(int)\n_nc_write_object(TERMTYPE2 *tp, char *buffer, unsigned *offset, unsigned limit)\n{\n    char *namelist;\n    size_t namelen, boolmax, nummax, strmax, numlen;\n    char zero = '\\0';\n    size_t i;\n    int nextfree;\n    short offsets[MAX_ENTRY_SIZE / 2];\n    unsigned char buf[MAX_ENTRY_SIZE];\n    unsigned last_bool = BOOLWRITE;\n    unsigned last_num = NUMWRITE;\n    unsigned last_str = STRWRITE;\n#if NCURSES_EXT_NUMBERS\n    bool need_ints = FALSE;\n    size_t (*convert_numbers) (unsigned char *, NCURSES_INT2 *, size_t) = convert_32bit;\n#else\n#define convert_numbers convert_shorts\n#endif\n\n#if NCURSES_XNAMES\n     \n    if (_nc_user_definable) {\n\tlast_bool = BOOLCOUNT;\n\tlast_num = NUMCOUNT;\n\tlast_str = STRCOUNT;\n    }\n#endif\n\n    namelist = tp->term_names;\n    namelen = strlen(namelist) + 1;\n\n    boolmax = 0;\n    for (i = 0; i < last_bool; i++) {\n\tif (tp->Booleans[i] == TRUE) {\n\t    boolmax = i + 1;\n\t}\n    }\n\n    nummax = 0;\n    for (i = 0; i < last_num; i++) {\n\tif (tp->Numbers[i] != ABSENT_NUMERIC) {\n\t    nummax = i + 1;\n#if NCURSES_EXT_NUMBERS\n\t    if (tp->Numbers[i] > MAX_OF_TYPE(NCURSES_COLOR_T)) {\n\t\tneed_ints = TRUE;\n\t    }\n#endif\n\t}\n    }\n\n    strmax = 0;\n    for (i = 0; i < last_str; i++) {\n\tif (tp->Strings[i] != ABSENT_STRING)\n\t    strmax = i + 1;\n    }\n\n    nextfree = compute_offsets(tp->Strings, strmax, offsets);\n\n     \n#if NCURSES_EXT_NUMBERS\n    if (need_ints) {\n\tconvert_numbers = convert_32bit;\n\tLITTLE_ENDIAN(buf, MAGIC2);\n    } else {\n\tconvert_numbers = convert_16bit;\n\tLITTLE_ENDIAN(buf, MAGIC);\n    }\n#else\n    LITTLE_ENDIAN(buf, MAGIC);\n#endif\n    LITTLE_ENDIAN(buf + 2, min(namelen, MAX_NAME_SIZE + 1));\n    LITTLE_ENDIAN(buf + 4, boolmax);\n    LITTLE_ENDIAN(buf + 6, nummax);\n    LITTLE_ENDIAN(buf + 8, strmax);\n    LITTLE_ENDIAN(buf + 10, nextfree);\n\n     \n    TRACE_OUT((\"Header of %s @%d\", namelist, *offset));\n    if (Write(buf, 12, 1) != 1\n\t|| Write(namelist, sizeof(char), namelen) != namelen) {\n\treturn (ERR);\n    }\n\n    for (i = 0; i < boolmax; i++) {\n\tif (tp->Booleans[i] == TRUE) {\n\t    buf[i] = TRUE;\n\t} else {\n\t    buf[i] = FALSE;\n\t}\n    }\n    if (Write(buf, sizeof(char), boolmax) != boolmax) {\n\treturn (ERR);\n    }\n\n    if (even_boundary(namelen + boolmax)) {\n\treturn (ERR);\n    }\n\n    TRACE_OUT((\"Numerics begin at %04x\", *offset));\n\n     \n    numlen = convert_numbers(buf, tp->Numbers, nummax);\n    if (Write(buf, numlen, nummax) != nummax) {\n\treturn (ERR);\n    }\n\n    TRACE_OUT((\"String offsets begin at %04x\", *offset));\n\n     \n    convert_shorts(buf, offsets, strmax);\n    if (Write(buf, SIZEOF_SHORT, strmax) != strmax) {\n\treturn (ERR);\n    }\n\n    TRACE_OUT((\"String table begins at %04x\", *offset));\n\n     \n    for (i = 0; i < strmax; i++) {\n\tif (VALID_STRING(tp->Strings[i])) {\n\t    if (!WRITE_STRING(tp->Strings[i])) {\n\t\treturn (ERR);\n\t    }\n\t}\n    }\n\n#if NCURSES_XNAMES\n    if (extended_object(tp)) {\n\tunsigned ext_total = (unsigned) NUM_EXT_NAMES(tp);\n\tunsigned ext_usage = ext_total;\n\n\tif (even_boundary(nextfree)) {\n\t    return (ERR);\n\t}\n\n\tnextfree = compute_offsets(tp->Strings + STRCOUNT,\n\t\t\t\t   (size_t) tp->ext_Strings,\n\t\t\t\t   offsets);\n\tTRACE_OUT((\"after extended string capabilities, nextfree=%d\", nextfree));\n\n\tif (tp->ext_Strings >= SIZEOF(offsets)) {\n\t    return (ERR);\n\t}\n\n\tnextfree += compute_offsets(tp->ext_Names,\n\t\t\t\t    (size_t) ext_total,\n\t\t\t\t    offsets + tp->ext_Strings);\n\tTRACE_OUT((\"after extended capnames, nextfree=%d\", nextfree));\n\tstrmax = tp->ext_Strings + ext_total;\n\tfor (i = 0; i < tp->ext_Strings; ++i) {\n\t    if (VALID_STRING(tp->Strings[i + STRCOUNT])) {\n\t\text_usage++;\n\t    }\n\t}\n\tTRACE_OUT((\"will write %u/%lu strings\", ext_usage, (unsigned long) strmax));\n\n\t \n\tLITTLE_ENDIAN(buf + 0, tp->ext_Booleans);\n\tLITTLE_ENDIAN(buf + 2, tp->ext_Numbers);\n\tLITTLE_ENDIAN(buf + 4, tp->ext_Strings);\n\tLITTLE_ENDIAN(buf + 6, ext_usage);\n\tLITTLE_ENDIAN(buf + 8, nextfree);\n\tTRACE_OUT((\"WRITE extended-header @%d\", *offset));\n\tif (Write(buf, 10, 1) != 1) {\n\t    return (ERR);\n\t}\n\n\tTRACE_OUT((\"WRITE %d booleans @%d\", tp->ext_Booleans, *offset));\n\tif (tp->ext_Booleans\n\t    && Write(tp->Booleans + BOOLCOUNT, sizeof(char),\n\t\t     tp->ext_Booleans) != tp->ext_Booleans) {\n\t    return (ERR);\n\t}\n\n\tif (even_boundary(tp->ext_Booleans)) {\n\t    return (ERR);\n\t}\n\n\tTRACE_OUT((\"WRITE %d numbers @%d\", tp->ext_Numbers, *offset));\n\tif (tp->ext_Numbers) {\n\t    numlen = convert_numbers(buf, tp->Numbers + NUMCOUNT, (size_t) tp->ext_Numbers);\n\t    if (Write(buf, numlen, tp->ext_Numbers) != tp->ext_Numbers) {\n\t\treturn (ERR);\n\t    }\n\t}\n\n\t \n\tconvert_shorts(buf, offsets, strmax);\n\tTRACE_OUT((\"WRITE offsets @%d\", *offset));\n\tif (Write(buf, SIZEOF_SHORT, strmax) != strmax) {\n\t    return (ERR);\n\t}\n\n\t \n\tfor (i = 0; i < tp->ext_Strings; i++) {\n\t    if (VALID_STRING(tp->Strings[i + STRCOUNT])) {\n\t\tTRACE_OUT((\"WRITE ext_Strings[%d]=%s\", (int) i,\n\t\t\t   _nc_visbuf(tp->Strings[i + STRCOUNT])));\n\t\tif (!WRITE_STRING(tp->Strings[i + STRCOUNT])) {\n\t\t    return (ERR);\n\t\t}\n\t    }\n\t}\n\n\t \n\tfor (i = 0; i < ext_total; i++) {\n\t    TRACE_OUT((\"WRITE ext_Names[%d]=%s\", (int) i, tp->ext_Names[i]));\n\t    if (!WRITE_STRING(tp->ext_Names[i])) {\n\t\treturn (ERR);\n\t    }\n\t}\n\n    }\n#endif  \n\n    total_written++;\n    total_parts++;\n    total_size = total_size + (int) (*offset + 1);\n    return (OK);\n}\n\n \nNCURSES_EXPORT(int)\n_nc_tic_written(void)\n{\n    TR(TRACE_DATABASE, (\"_nc_tic_written %d entries, %d parts, %d size\",\n\t\t\ttotal_written, total_parts, total_size));\n    return total_written;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}