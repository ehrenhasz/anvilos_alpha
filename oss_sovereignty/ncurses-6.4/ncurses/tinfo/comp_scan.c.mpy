{
  "module_name": "comp_scan.c",
  "hash_id": "4bf6cd6577725968fcb02fa06d9124378be382c90557943c47740a9fd110b088",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/comp_scan.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: comp_scan.c,v 1.119 2022/08/07 00:20:26 tom Exp $\")\n\n \n#define MAXCAPLEN\t600\n\n#define iswhite(ch)\t(ch == ' '  ||  ch == '\\t')\n\nNCURSES_EXPORT_VAR (int) _nc_syntax = 0;          \nNCURSES_EXPORT_VAR (int) _nc_strict_bsd = 1;   \nNCURSES_EXPORT_VAR (long) _nc_curr_file_pos = 0;  \nNCURSES_EXPORT_VAR (long) _nc_comment_start = 0;  \nNCURSES_EXPORT_VAR (long) _nc_comment_end = 0;    \nNCURSES_EXPORT_VAR (long) _nc_start_line = 0;     \n\nNCURSES_EXPORT_VAR (struct token) _nc_curr_token =\n{\n    0, 0, 0\n};\n\n \n\nstatic bool first_column;\t \nstatic bool had_newline;\nstatic char separator;\t\t \nstatic int pushtype;\t\t \nstatic char *pushname;\n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT_VAR (bool) _nc_disable_period = FALSE;  \n#endif\n\n \n\n#define LEXBUFSIZ\t1024\n\nstatic char *bufptr;\t\t \nstatic char *bufstart;\t\t \nstatic FILE *yyin;\t\t \n\n \n\nNCURSES_EXPORT(void)\n_nc_reset_input(FILE *fp, char *buf)\n{\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"_nc_reset_input(fp=%p, buf=%p)\"), (void *) fp, buf));\n\n    pushtype = NO_PUSHBACK;\n    if (pushname != 0)\n\tpushname[0] = '\\0';\n    yyin = fp;\n    bufstart = bufptr = buf;\n    _nc_curr_file_pos = 0L;\n    if (fp != 0)\n\t_nc_curr_line = 0;\n    _nc_curr_col = 0;\n\n    returnVoidDB;\n}\n\n \nstatic int\nlast_char(int from_end)\n{\n    size_t len = strlen(bufptr);\n    int result = 0;\n\n    while (len--) {\n\tif (!isspace(UChar(bufptr[len]))) {\n\t    if (from_end <= (int) len)\n\t\tresult = bufptr[(int) len - from_end];\n\t    break;\n\t}\n    }\n    return result;\n}\n\n \nstatic int\nget_text(char *buffer, int length)\n{\n    int count = 0;\n    int limit = length - 1;\n\n    while (limit-- > 0) {\n\tint ch = fgetc(yyin);\n\n\tif (ch == '\\0') {\n\t    _nc_err_abort(\"This is not a text-file\");\n\t} else if (ch == EOF) {\n\t    break;\n\t}\n\t++count;\n\t*buffer++ = (char) ch;\n\tif (ch == '\\n')\n\t    break;\n    }\n    *buffer = '\\0';\n    return count;\n}\n\n \n\nstatic int\nnext_char(void)\n{\n    static char *result;\n    static size_t allocated;\n    int the_char;\n\n    if (!yyin) {\n\tif (result != 0) {\n\t    FreeAndNull(result);\n\t    FreeAndNull(pushname);\n\t    bufptr = 0;\n\t    bufstart = 0;\n\t    allocated = 0;\n\t}\n\t \n\tif (bufptr == 0 || *bufptr == '\\0')\n\t    return (EOF);\n\tif (*bufptr == '\\n') {\n\t    _nc_curr_line++;\n\t    _nc_curr_col = 0;\n\t} else if (*bufptr == '\\t') {\n\t    _nc_curr_col = (_nc_curr_col | 7);\n\t}\n    } else if (!bufptr || !*bufptr) {\n\t \n\tsize_t len;\n\n\tdo {\n\t    size_t used = 0;\n\t    bufstart = 0;\n\t    do {\n\t\tif (used + (LEXBUFSIZ / 4) >= allocated) {\n\t\t    allocated += (allocated + LEXBUFSIZ);\n\t\t    result = typeRealloc(char, allocated, result);\n\t\t    if (result == 0)\n\t\t\treturn (EOF);\n\t\t    if (bufstart)\n\t\t\tbufstart = result;\n\t\t}\n\t\tif (used == 0)\n\t\t    _nc_curr_file_pos = ftell(yyin);\n\n\t\tif (get_text(result + used, (int) (allocated - used))) {\n\t\t    bufstart = result;\n\t\t    if (used == 0) {\n\t\t\tif (_nc_curr_line == 0\n\t\t\t    && IS_TIC_MAGIC(result)) {\n\t\t\t    _nc_err_abort(\"This is a compiled terminal description, not a source\");\n\t\t\t}\n\t\t\t_nc_curr_line++;\n\t\t\t_nc_curr_col = 0;\n\t\t    }\n\t\t} else {\n\t\t    if (used != 0)\n\t\t\t_nc_STRCAT(result, \"\\n\", allocated);\n\t\t}\n\t\tif ((bufptr = bufstart) != 0) {\n\t\t    used = strlen(bufptr);\n\t\t    if (used == 0)\n\t\t\treturn (EOF);\n\t\t    while (iswhite(*bufptr)) {\n\t\t\tif (*bufptr == '\\t') {\n\t\t\t    _nc_curr_col = (_nc_curr_col | 7) + 1;\n\t\t\t} else {\n\t\t\t    _nc_curr_col++;\n\t\t\t}\n\t\t\tbufptr++;\n\t\t    }\n\n\t\t     \n\t\t    if ((len = strlen(bufptr)) > 1) {\n\t\t\tif (bufptr[len - 1] == '\\n'\n\t\t\t    && bufptr[len - 2] == '\\r') {\n\t\t\t    len--;\n\t\t\t    bufptr[len - 1] = '\\n';\n\t\t\t    bufptr[len] = '\\0';\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t    return (EOF);\n\t\t}\n\t    } while (bufptr[len - 1] != '\\n');\t \n\t} while (result[0] == '#');\t \n    } else if (*bufptr == '\\t') {\n\t_nc_curr_col = (_nc_curr_col | 7);\n    }\n\n    first_column = (bufptr == bufstart);\n    if (first_column)\n\thad_newline = FALSE;\n\n    _nc_curr_col++;\n    the_char = *bufptr++;\n    return UChar(the_char);\n}\n\nstatic void\npush_back(int c)\n \n{\n    if (bufptr == bufstart)\n\t_nc_syserr_abort(\"Can't backspace off beginning of line\");\n    *--bufptr = (char) c;\n    _nc_curr_col--;\n}\n\nstatic long\nstream_pos(void)\n \n{\n    return (yyin ? ftell(yyin) : (bufptr ? bufptr - bufstart : 0));\n}\n\nstatic bool\nend_of_stream(void)\n \n{\n    return ((yyin\n\t     ? (feof(yyin) && (bufptr == NULL || *bufptr == '\\0'))\n\t     : (bufptr && *bufptr == '\\0'))\n\t    ? TRUE : FALSE);\n}\n\n \nstatic NCURSES_INLINE int\neat_escaped_newline(int ch)\n{\n    if (ch == '\\\\')\n\twhile ((ch = next_char()) == '\\n' || iswhite(ch))\n\t    continue;\n    return ch;\n}\n\n#define TOK_BUF_SIZE MAX_ENTRY_SIZE\n\n#define OkToAdd() \\\n\t((tok_ptr - tok_buf) < (TOK_BUF_SIZE - 2))\n\n#define AddCh(ch) \\\n\t*tok_ptr++ = (char) ch; \\\n\t*tok_ptr = '\\0'\n\nstatic char *tok_buf;\n\n \n\nNCURSES_EXPORT(int)\n_nc_get_token(bool silent)\n{\n    static const char terminfo_punct[] = \"@%&*!#\";\n\n    char *after_name;\t\t \n    char *after_list;\t\t \n    char *numchk;\n    char *tok_ptr;\n    char *s;\n    char numbuf[80];\n    int ch, c0, c1;\n    int dot_flag = FALSE;\n    int type;\n    long number;\n    long token_start;\n    unsigned found;\n#ifdef TRACE\n    int old_line;\n    int old_col;\n#endif\n\n    DEBUG(3, (T_CALLED(\"_nc_get_token(silent=%d)\"), silent));\n\n    if (pushtype != NO_PUSHBACK) {\n\tint retval = pushtype;\n\n\t_nc_set_type(pushname != 0 ? pushname : \"\");\n\tDEBUG(3, (\"pushed-back token: `%s', class %d\",\n\t\t  _nc_curr_token.tk_name, pushtype));\n\n\tpushtype = NO_PUSHBACK;\n\tif (pushname != 0)\n\t    pushname[0] = '\\0';\n\n\t \n\tDEBUG(3, (T_RETURN(\"%d\"), retval));\n\treturn (retval);\n    }\n\n    if (end_of_stream()) {\n\tyyin = 0;\n\t(void) next_char();\t \n\tif (tok_buf != 0) {\n\t    if (_nc_curr_token.tk_name == tok_buf)\n\t\t_nc_curr_token.tk_name = 0;\n\t}\n\tDEBUG(3, (T_RETURN(\"%d\"), EOF));\n\treturn (EOF);\n    }\n\n  start_token:\n    token_start = stream_pos();\n    while ((ch = next_char()) == '\\n' || iswhite(ch)) {\n\tif (ch == '\\n')\n\t    had_newline = TRUE;\n\tcontinue;\n    }\n\n    ch = eat_escaped_newline(ch);\n    _nc_curr_token.tk_valstring = 0;\n\n#ifdef TRACE\n    old_line = _nc_curr_line;\n    old_col = _nc_curr_col;\n#endif\n    if (ch == EOF)\n\ttype = EOF;\n    else {\n\t \n\tif (separator == ':' && ch == ':')\n\t    ch = next_char();\n\n\tif (ch == '.'\n#if NCURSES_EXT_FUNCS\n\t    && !_nc_disable_period\n#endif\n\t    ) {\n\t    dot_flag = TRUE;\n\t    DEBUG(8, (\"dot-flag set\"));\n\n\t    while ((ch = next_char()) == '.' || iswhite(ch))\n\t\tcontinue;\n\t}\n\n\tif (ch == EOF) {\n\t    type = EOF;\n\t    goto end_of_token;\n\t}\n\n\t \n\tif (!isalnum(UChar(ch))\n#if NCURSES_EXT_FUNCS\n\t    && !(ch == '.' && _nc_disable_period)\n#endif\n\t    && ((strchr) (terminfo_punct, (char) ch) == 0)) {\n\t    if (!silent)\n\t\t_nc_warning(\"Illegal character (expected alphanumeric or %s) - '%s'\",\n\t\t\t    terminfo_punct, unctrl(UChar(ch)));\n\t    _nc_panic_mode(separator);\n\t    goto start_token;\n\t}\n\n\tif (tok_buf == 0)\n\t    tok_buf = typeMalloc(char, TOK_BUF_SIZE);\n\n#ifdef TRACE\n\told_line = _nc_curr_line;\n\told_col = _nc_curr_col;\n#endif\n\ttok_ptr = tok_buf;\n\tAddCh(ch);\n\n\tif (first_column) {\n\t    _nc_comment_start = token_start;\n\t    _nc_comment_end = _nc_curr_file_pos;\n\t    _nc_start_line = _nc_curr_line;\n\n\t    _nc_syntax = ERR;\n\t    after_name = 0;\n\t    after_list = 0;\n\t    while ((ch = next_char()) != '\\n') {\n\t\tif (ch == EOF) {\n\t\t    _nc_err_abort(MSG_NO_INPUTS);\n\t\t} else if (ch == '|') {\n\t\t    after_list = tok_ptr;\n\t\t    if (after_name == 0)\n\t\t\tafter_name = tok_ptr;\n\t\t} else if (ch == ':' && last_char(0) != ',') {\n\t\t    _nc_syntax = SYN_TERMCAP;\n\t\t    separator = ':';\n\t\t    break;\n\t\t} else if (ch == ',') {\n\t\t    _nc_syntax = SYN_TERMINFO;\n\t\t    separator = ',';\n\t\t     \n\t\t    if (after_name == 0)\n\t\t\tbreak;\n\t\t     \n\t\t    c0 = last_char(0);\n\t\t    c1 = last_char(1);\n\t\t    if (c1 != ':' && c0 != '\\\\' && c0 != ':') {\n\t\t\tbool capability = FALSE;\n\n\t\t\t \n\t\t\tfor (s = bufptr; isspace(UChar(*s)); ++s) {\n\t\t\t    ;\n\t\t\t}\n\t\t\tif (islower(UChar(*s))) {\n\t\t\t    char *name = s;\n\t\t\t    while (isalnum(UChar(*s))) {\n\t\t\t\t++s;\n\t\t\t    }\n\t\t\t    if (*s == '#' || *s == '=' || *s == '@') {\n\t\t\t\t \n\t\t\t\tcapability = TRUE;\n\t\t\t    } else if (*s == ',') {\n\t\t\t\tc0 = *s;\n\t\t\t\t*s = '\\0';\n\t\t\t\t \n\t\t\t\tif (_nc_find_entry(name,\n\t\t\t\t\t\t   _nc_get_hash_table(FALSE))) {\n\t\t\t\t    capability = TRUE;\n\t\t\t\t}\n\t\t\t\t*s = (char) c0;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (capability) {\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t} else\n\t\t    ch = eat_escaped_newline(ch);\n\n\t\tif (OkToAdd()) {\n\t\t    AddCh(ch);\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t    *tok_ptr = '\\0';\n\t    if (_nc_syntax == ERR) {\n\t\t \n\t\t_nc_syntax = SYN_TERMCAP;\n\t\tseparator = ':';\n\t    } else if (_nc_syntax == SYN_TERMINFO) {\n\t\t \n\t\tfor (--tok_ptr;\n\t\t     iswhite(*tok_ptr) || *tok_ptr == ',';\n\t\t     tok_ptr--)\n\t\t    continue;\n\t\ttok_ptr[1] = '\\0';\n\t    }\n\n\t     \n\t    if (after_name != 0) {\n\t\tch = *after_name;\n\t\t*after_name = '\\0';\n\t\t_nc_set_type(tok_buf);\n\t\t*after_name = (char) ch;\n\t    }\n\n\t     \n\t    if (after_list != 0) {\n\t\tif (!silent) {\n\t\t    if (*after_list == '\\0' || strchr(\"|\", after_list[1]) != NULL) {\n\t\t\t_nc_warning(\"empty longname field\");\n\t\t    } else if (strchr(after_list, ' ') == 0) {\n\t\t\t_nc_warning(\"older tic versions may treat the description field as an alias\");\n\t\t    }\n\t\t}\n\t    } else {\n\t\tafter_list = tok_buf + strlen(tok_buf);\n\t\tDEBUG(2, (\"missing description\"));\n\t    }\n\n\t     \n\t    for (s = tok_buf; s < after_list; ++s) {\n\t\tif (isspace(UChar(*s))) {\n\t\t    if (!silent)\n\t\t\t_nc_warning(\"whitespace in name or alias field\");\n\t\t    break;\n\t\t} else if (*s == '/') {\n\t\t    if (!silent)\n\t\t\t_nc_warning(\"slashes aren't allowed in names or aliases\");\n\t\t    break;\n\t\t} else if (strchr(\"$[]!*?\", *s)) {\n\t\t    if (!silent)\n\t\t\t_nc_warning(\"dubious character `%c' in name or alias field\", *s);\n\t\t    break;\n\t\t}\n\t    }\n\n\t    _nc_curr_token.tk_name = tok_buf;\n\t    type = NAMES;\n\t} else {\n\t    if (had_newline && _nc_syntax == SYN_TERMCAP) {\n\t\t_nc_warning(\"Missing backslash before newline\");\n\t\thad_newline = FALSE;\n\t    }\n\t    while ((ch = next_char()) != EOF) {\n\t\tif (!isalnum(UChar(ch))) {\n\t\t    if (_nc_syntax == SYN_TERMINFO) {\n\t\t\tif (ch != '_')\n\t\t\t    break;\n\t\t    } else {\t \n\t\t\tif (ch != ';')\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\tif (OkToAdd()) {\n\t\t    AddCh(ch);\n\t\t} else {\n\t\t    ch = EOF;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    *tok_ptr++ = '\\0';\t \n\t    switch (ch) {\n\t    case ',':\n\t    case ':':\n\t\tif (ch != separator)\n\t\t    _nc_err_abort(\"Separator inconsistent with syntax\");\n\t\t_nc_curr_token.tk_name = tok_buf;\n\t\ttype = BOOLEAN;\n\t\tbreak;\n\t    case '@':\n\t\tif ((ch = next_char()) != separator && !silent)\n\t\t    _nc_warning(\"Missing separator after `%s', have %s\",\n\t\t\t\ttok_buf, unctrl(UChar(ch)));\n\t\t_nc_curr_token.tk_name = tok_buf;\n\t\ttype = CANCEL;\n\t\tbreak;\n\n\t    case '#':\n\t\tfound = 0;\n\t\twhile (isalnum(ch = next_char())) {\n\t\t    numbuf[found++] = (char) ch;\n\t\t    if (found >= sizeof(numbuf) - 1)\n\t\t\tbreak;\n\t\t}\n\t\tnumbuf[found] = '\\0';\n\t\tnumber = strtol(numbuf, &numchk, 0);\n\t\tif (!silent) {\n\t\t    if (numchk == numbuf)\n\t\t\t_nc_warning(\"no value given for `%s'\", tok_buf);\n\t\t    if ((*numchk != '\\0') || (ch != separator))\n\t\t\t_nc_warning(\"Missing separator for `%s'\", tok_buf);\n\t\t    if (number < 0)\n\t\t\t_nc_warning(\"value of `%s' cannot be negative\", tok_buf);\n\t\t    if (number > MAX_OF_TYPE(NCURSES_INT2)) {\n\t\t\t_nc_warning(\"limiting value of `%s' from %#lx to %#x\",\n\t\t\t\t    tok_buf,\n\t\t\t\t    number, MAX_OF_TYPE(NCURSES_INT2));\n\t\t\tnumber = MAX_OF_TYPE(NCURSES_INT2);\n\t\t    }\n\t\t}\n\t\t_nc_curr_token.tk_name = tok_buf;\n\t\t_nc_curr_token.tk_valnumber = (int) number;\n\t\ttype = NUMBER;\n\t\tbreak;\n\n\t    case '=':\n\t\tch = _nc_trans_string(tok_ptr, tok_buf + TOK_BUF_SIZE);\n\t\tif (!silent && ch != separator)\n\t\t    _nc_warning(\"Missing separator\");\n\t\t_nc_curr_token.tk_name = tok_buf;\n\t\t_nc_curr_token.tk_valstring = tok_ptr;\n\t\ttype = STRING;\n\t\tbreak;\n\n\t    case EOF:\n\t\ttype = EOF;\n\t\tbreak;\n\t    default:\n\t\t \n\t\ttype = UNDEF;\n\t\tif (!silent)\n\t\t    _nc_warning(\"Illegal character - '%s'\", unctrl(UChar(ch)));\n\t    }\n\t}\t\t\t \n    }\t\t\t\t \n\n  end_of_token:\n\n#ifdef TRACE\n    if (dot_flag == TRUE)\n\tDEBUG(8, (\"Commented out \"));\n\n    if (_nc_tracing >= DEBUG_LEVEL(8)) {\n\t_tracef(\"parsed %d.%d to %d.%d\",\n\t\told_line, old_col,\n\t\t_nc_curr_line, _nc_curr_col);\n    }\n    if (_nc_tracing >= DEBUG_LEVEL(7)) {\n\tswitch (type) {\n\tcase BOOLEAN:\n\t    _tracef(\"Token: Boolean; name='%s'\",\n\t\t    _nc_curr_token.tk_name);\n\t    break;\n\n\tcase NUMBER:\n\t    _tracef(\"Token: Number;  name='%s', value=%d\",\n\t\t    _nc_curr_token.tk_name,\n\t\t    _nc_curr_token.tk_valnumber);\n\t    break;\n\n\tcase STRING:\n\t    _tracef(\"Token: String;  name='%s', value=%s\",\n\t\t    _nc_curr_token.tk_name,\n\t\t    _nc_visbuf(_nc_curr_token.tk_valstring));\n\t    break;\n\n\tcase CANCEL:\n\t    _tracef(\"Token: Cancel; name='%s'\",\n\t\t    _nc_curr_token.tk_name);\n\t    break;\n\n\tcase NAMES:\n\n\t    _tracef(\"Token: Names; value='%s'\",\n\t\t    _nc_curr_token.tk_name);\n\t    break;\n\n\tcase EOF:\n\t    _tracef(\"Token: End of file\");\n\t    break;\n\n\tdefault:\n\t    _nc_warning(\"Bad token type\");\n\t}\n    }\n#endif\n\n    if (dot_flag == TRUE)\t \n\ttype = _nc_get_token(silent);\n\n    DEBUG(3, (\"token: `%s', class %d\",\n\t      ((_nc_curr_token.tk_name != 0)\n\t       ? _nc_curr_token.tk_name\n\t       : \"<null>\"),\n\t      type));\n\n    DEBUG(3, (T_RETURN(\"%d\"), type));\n    return (type);\n}\n\n \n\nNCURSES_EXPORT(int)\n_nc_trans_string(char *ptr, char *last)\n{\n    int count = 0;\n    int number = 0;\n    int i, c;\n    int last_ch = '\\0';\n    bool ignored = FALSE;\n    bool long_warning = FALSE;\n\n    while ((c = next_char()) != separator && c != EOF) {\n\tif (ptr >= (last - 1)) {\n\t    if (c != EOF) {\n\t\twhile ((c = next_char()) != separator && c != EOF) {\n\t\t    ;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif ((_nc_syntax == SYN_TERMCAP) && c == '\\n')\n\t    break;\n\tif (c == '^' && last_ch != '%') {\n\t    c = next_char();\n\t    if (c == EOF)\n\t\t_nc_err_abort(MSG_NO_INPUTS);\n\n\t    if (!(is7bits(c) && isprint(c))) {\n\t\t_nc_warning(\"Illegal ^ character - '%s'\", unctrl(UChar(c)));\n\t    }\n\t    if (c == '?' && (_nc_syntax != SYN_TERMCAP)) {\n\t\t*(ptr++) = '\\177';\n\t    } else {\n\t\tif ((c &= 037) == 0)\n\t\t    c = 128;\n\t\t*(ptr++) = (char) (c);\n\t    }\n\t} else if (c == '\\\\') {\n\t    bool strict_bsd = ((_nc_syntax == SYN_TERMCAP) && _nc_strict_bsd);\n\n\t    c = next_char();\n\t    if (c == EOF)\n\t\t_nc_err_abort(MSG_NO_INPUTS);\n\n\t    if (isoctal(c) || (strict_bsd && isdigit(c))) {\n\t\tnumber = c - '0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t    c = next_char();\n\t\t    if (c == EOF)\n\t\t\t_nc_err_abort(MSG_NO_INPUTS);\n\n\t\t    if (!isoctal(c)) {\n\t\t\tif (isdigit(c)) {\n\t\t\t    if (!strict_bsd) {\n\t\t\t\t_nc_warning(\"Non-octal digit `%c' in \\\\ sequence\", c);\n\t\t\t\t \n\t\t\t    }\n\t\t\t} else {\n\t\t\t    push_back(c);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\n\t\t    number = number * 8 + c - '0';\n\t\t}\n\n\t\tnumber = UChar(number);\n\t\tif (number == 0 && !strict_bsd)\n\t\t    number = 0200;\n\t\t*(ptr++) = (char) number;\n\t    } else {\n\t\tswitch (c) {\n\t\tcase 'E':\n\t\t    *(ptr++) = '\\033';\n\t\t    break;\n\n\t\tcase 'n':\n\t\t    *(ptr++) = '\\n';\n\t\t    break;\n\n\t\tcase 'r':\n\t\t    *(ptr++) = '\\r';\n\t\t    break;\n\n\t\tcase 'b':\n\t\t    *(ptr++) = '\\010';\n\t\t    break;\n\n\t\tcase 'f':\n\t\t    *(ptr++) = '\\014';\n\t\t    break;\n\n\t\tcase 't':\n\t\t    *(ptr++) = '\\t';\n\t\t    break;\n\n\t\tcase '\\\\':\n\t\t    *(ptr++) = '\\\\';\n\t\t    break;\n\n\t\tcase '^':\n\t\t    *(ptr++) = '^';\n\t\t    break;\n\n\t\tcase ',':\n\t\t    *(ptr++) = ',';\n\t\t    break;\n\n\t\tcase '\\n':\n\t\t    continue;\n\n\t\tdefault:\n\t\t    if ((_nc_syntax == SYN_TERMINFO) || !_nc_strict_bsd) {\n\t\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\t    c = '\\007';\n\t\t\t    break;\n\t\t\tcase 'e':\n\t\t\t    c = '\\033';\n\t\t\t    break;\n\t\t\tcase 'l':\n\t\t\t    c = '\\n';\n\t\t\t    break;\n\t\t\tcase 's':\n\t\t\t    c = ' ';\n\t\t\t    break;\n\t\t\tcase ':':\n\t\t\t    c = ':';\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    _nc_warning(\"Illegal character '%s' in \\\\ sequence\",\n\t\t\t\t\tunctrl(UChar(c)));\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t     \n\t\tcase '|':\n\t\t    *(ptr++) = (char) c;\n\t\t}\t\t \n\t    }\t\t\t \n\t}\n\t \n\telse if (c == '\\n' && (_nc_syntax == SYN_TERMINFO)) {\n\t     \n\t    ignored = TRUE;\n\t} else {\n\t    *(ptr++) = (char) c;\n\t}\n\n\tif (!ignored) {\n\t    if (_nc_curr_col <= 1) {\n\t\tpush_back(c);\n\t\tc = '\\n';\n\t\tbreak;\n\t    }\n\t    last_ch = c;\n\t    count++;\n\t}\n\tignored = FALSE;\n\n\tif (count > MAXCAPLEN && !long_warning) {\n\t    _nc_warning(\"Very long string found.  Missing separator?\");\n\t    long_warning = TRUE;\n\t}\n    }\t\t\t\t \n\n    *ptr = '\\0';\n\n    return (c);\n}\n\n \n\nNCURSES_EXPORT(void)\n_nc_push_token(int tokclass)\n{\n     \n    pushtype = tokclass;\n    if (pushname == 0)\n\tpushname = typeMalloc(char, MAX_NAME_SIZE + 1);\n    _nc_get_type(pushname);\n\n    DEBUG(3, (\"pushing token: `%s', class %d\",\n\t      ((_nc_curr_token.tk_name != 0)\n\t       ? _nc_curr_token.tk_name\n\t       : \"<null>\"),\n\t      pushtype));\n}\n\n \nNCURSES_EXPORT(void)\n_nc_panic_mode(char ch)\n{\n    for (;;) {\n\tint c = next_char();\n\tif (c == ch)\n\t    return;\n\tif (c == EOF)\n\t    return;\n    }\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_comp_scan_leaks(void)\n{\n    if (pushname != 0) {\n\tFreeAndNull(pushname);\n    }\n    if (tok_buf != 0) {\n\tFreeAndNull(tok_buf);\n    }\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}