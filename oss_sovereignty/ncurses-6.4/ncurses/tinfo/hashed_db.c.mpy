{
  "module_name": "hashed_db.c",
  "hash_id": "0ceb282d800a97f9a03a72758d53fee44bf8ebc8a1516a95708777cdb84157e6",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/hashed_db.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n#include <tic.h>\n#include <hashed_db.h>\n\n#if USE_HASHED_DB\n\nMODULE_ID(\"$Id: hashed_db.c,v 1.19 2020/02/02 23:34:34 tom Exp $\")\n\n#if HASHED_DB_API >= 2\nstatic DBC *cursor;\n#endif\n\ntypedef struct _myconn {\n    struct _myconn *next;\n    DB *db;\n    char *path;\n    bool modify;\n} MYCONN;\n\nstatic MYCONN *connections;\n\nstatic void\ncleanup(void)\n{\n    while (connections != 0) {\n\t_nc_db_close(connections->db);\n    }\n}\n\nstatic DB *\nfind_connection(const char *path, bool modify)\n{\n    DB *result = 0;\n    MYCONN *p;\n\n    for (p = connections; p != 0; p = p->next) {\n\tif (!strcmp(p->path, path) && p->modify == modify) {\n\t    result = p->db;\n\t    break;\n\t}\n    }\n\n    return result;\n}\n\nstatic void\ndrop_connection(DB * db)\n{\n    MYCONN *p, *q;\n\n    for (p = connections, q = 0; p != 0; q = p, p = p->next) {\n\tif (p->db == db) {\n\t    if (q != 0)\n\t\tq->next = p->next;\n\t    else\n\t\tconnections = p->next;\n\t    free(p->path);\n\t    free(p);\n\t    break;\n\t}\n    }\n}\n\nstatic void\nmake_connection(DB * db, const char *path, bool modify)\n{\n    MYCONN *p = typeCalloc(MYCONN, 1);\n\n    if (p != 0) {\n\tp->db = db;\n\tp->path = strdup(path);\n\tp->modify = modify;\n\tif (p->path != 0) {\n\t    p->next = connections;\n\t    connections = p;\n\t} else {\n\t    free(p);\n\t}\n    }\n}\n\n \nNCURSES_EXPORT(DB *)\n_nc_db_open(const char *path, bool modify)\n{\n    DB *result = 0;\n    int code;\n\n    if (connections == 0)\n\tatexit(cleanup);\n\n    if ((result = find_connection(path, modify)) == 0) {\n\n#if HASHED_DB_API >= 4\n\tdb_create(&result, NULL, 0);\n\tif ((code = result->open(result,\n\t\t\t\t NULL,\n\t\t\t\t path,\n\t\t\t\t NULL,\n\t\t\t\t DB_HASH,\n\t\t\t\t modify ? DB_CREATE : DB_RDONLY,\n\t\t\t\t 0644)) != 0) {\n\t    result = 0;\n\t}\n#elif HASHED_DB_API >= 3\n\tdb_create(&result, NULL, 0);\n\tif ((code = result->open(result,\n\t\t\t\t path,\n\t\t\t\t NULL,\n\t\t\t\t DB_HASH,\n\t\t\t\t modify ? DB_CREATE : DB_RDONLY,\n\t\t\t\t 0644)) != 0) {\n\t    result = 0;\n\t}\n#elif HASHED_DB_API >= 2\n\tif ((code = db_open(path,\n\t\t\t    DB_HASH,\n\t\t\t    modify ? DB_CREATE : DB_RDONLY,\n\t\t\t    0644,\n\t\t\t    (DB_ENV *) 0,\n\t\t\t    (DB_INFO *) 0,\n\t\t\t    &result)) != 0) {\n\t    result = 0;\n\t}\n#else\n\tif ((result = dbopen(path,\n\t\t\t     modify ? (O_CREAT | O_RDWR) : O_RDONLY,\n\t\t\t     0644,\n\t\t\t     DB_HASH,\n\t\t\t     NULL)) == 0) {\n\t    code = errno;\n\t}\n#endif\n\tif (result != 0) {\n\t    make_connection(result, path, modify);\n\t    T((\"opened %s\", path));\n\t} else {\n\t    T((\"cannot open %s: %s\", path, strerror(code)));\n\t}\n    }\n    return result;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_db_close(DB * db)\n{\n    int result;\n\n    drop_connection(db);\n#if HASHED_DB_API >= 2\n    result = db->close(db, 0);\n#else\n    result = db->close(db);\n#endif\n    return result;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_db_put(DB * db, DBT * key, DBT * data)\n{\n    int result;\n#if HASHED_DB_API >= 2\n     \n    (void) db->del(db, NULL, key, 0);\n    result = db->put(db, NULL, key, data, DB_NOOVERWRITE);\n#else\n    result = db->put(db, key, data, R_NOOVERWRITE);\n#endif\n    return result;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_db_get(DB * db, DBT * key, DBT * data)\n{\n    int result;\n\n    memset(data, 0, sizeof(*data));\n#if HASHED_DB_API >= 2\n    result = db->get(db, NULL, key, data, 0);\n#else\n    result = db->get(db, key, data, 0);\n#endif\n    return result;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_db_first(DB * db, DBT * key, DBT * data)\n{\n    int result;\n\n    memset(key, 0, sizeof(*key));\n    memset(data, 0, sizeof(*data));\n#if HASHED_DB_API >= 2\n    if ((result = db->cursor(db, NULL, &cursor, 0)) == 0) {\n\tresult = cursor->c_get(cursor, key, data, DB_FIRST);\n    }\n#else\n    result = db->seq(db, key, data, 0);\n#endif\n    return result;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_db_next(DB * db, DBT * key, DBT * data)\n{\n    int result;\n\n#if HASHED_DB_API >= 2\n    (void) db;\n    if (cursor != 0) {\n\tresult = cursor->c_get(cursor, key, data, DB_NEXT);\n    } else {\n\tresult = -1;\n    }\n#else\n    result = db->seq(db, key, data, R_NEXT);\n#endif\n    return result;\n}\n\n \nNCURSES_EXPORT(bool)\n_nc_db_have_index(DBT * key, DBT * data, char **buffer, int *size)\n{\n    bool result = FALSE;\n    int used = (int) data->size - 1;\n    char *have = (char *) data->data;\n\n    (void) key;\n    if (*have++ == 2) {\n\tresult = TRUE;\n    }\n     \n    *buffer = have;\n    *size = used;\n    return result;\n}\n\n \nNCURSES_EXPORT(bool)\n_nc_db_have_data(DBT * key, DBT * data, char **buffer, int *size)\n{\n    bool result = FALSE;\n    int used = (int) data->size - 1;\n    char *have = (char *) data->data;\n\n    if (*have++ == 0) {\n\tif (data->size > key->size\n\t    && IS_TIC_MAGIC(have)) {\n\t    result = TRUE;\n\t}\n    }\n     \n    *buffer = have;\n    *size = used;\n    return result;\n}\n\n#else\n\nextern\nNCURSES_EXPORT(void)\n_nc_hashed_db(void);\n\nNCURSES_EXPORT(void)\n_nc_hashed_db(void)\n{\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}