{
  "module_name": "lib_setup.c",
  "hash_id": "4f49b1ecb090b1dfff2cc0589b1716c4292643956720428b913c591ccf49cd9d",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_setup.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <tic.h>\t\t \n\n#if HAVE_LOCALE_H\n#include <locale.h>\n#endif\n\nMODULE_ID(\"$Id: lib_setup.c,v 1.218 2022/08/13 18:12:22 tom Exp $\")\n\n \n\n#if HAVE_SIZECHANGE\n# if !defined(sun) || !TERMIOS\n#  if HAVE_SYS_IOCTL_H\n#   include <sys/ioctl.h>\n#  endif\n# endif\n#endif\n\n#if NEED_PTEM_H\n  \n# include <sys/stream.h>\n# include <sys/ptem.h>\n#endif\n\n#if HAVE_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n\n \n#ifdef TIOCGSIZE\n# define IOCTL_WINSIZE TIOCGSIZE\n# define STRUCT_WINSIZE struct ttysize\n# define WINSIZE_ROWS(n) (int)n.ts_lines\n# define WINSIZE_COLS(n) (int)n.ts_cols\n#else\n# ifdef TIOCGWINSZ\n#  define IOCTL_WINSIZE TIOCGWINSZ\n#  define STRUCT_WINSIZE struct winsize\n#  define WINSIZE_ROWS(n) (int)n.ws_row\n#  define WINSIZE_COLS(n) (int)n.ws_col\n# endif\n#endif\n\n \n#undef CUR\n#define CUR TerminalType(termp).\n\n \n#if USE_REENTRANT\n\nNCURSES_EXPORT(char *)\nNCURSES_PUBLIC_VAR(ttytype) (void)\n{\n    static char empty[] = \"\";\n    char *result = empty;\n\n#if NCURSES_SP_FUNCS\n    if (CURRENT_SCREEN) {\n\tTERMINAL *termp = TerminalOf(CURRENT_SCREEN);\n\tif (termp != 0) {\n\t    result = TerminalType(termp).term_names;\n\t}\n    }\n#else\n    if (cur_term != 0) {\n\tresult = TerminalType(cur_term).term_names;\n    }\n#endif\n    return result;\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Lines(SCREEN *sp)\n{\n    return ptrLines(sp);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(LINES) (void)\n{\n    return *_nc_ptr_Lines(CURRENT_SCREEN);\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Cols(SCREEN *sp)\n{\n    return ptrCols(sp);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(COLS) (void)\n{\n    return *_nc_ptr_Cols(CURRENT_SCREEN);\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Tabsize(SCREEN *sp)\n{\n    return ptrTabsize(sp);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(TABSIZE) (void)\n{\n    return *_nc_ptr_Tabsize(CURRENT_SCREEN);\n}\n#else\nNCURSES_EXPORT_VAR(char) ttytype[NAMESIZE] = \"\";\nNCURSES_EXPORT_VAR(int) LINES = 0;\nNCURSES_EXPORT_VAR(int) COLS = 0;\nNCURSES_EXPORT_VAR(int) TABSIZE = 8;\n#endif\n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(set_tabsize) (NCURSES_SP_DCLx int value)\n{\n    int code = OK;\n    if (value <= 0) {\n\tcode = ERR;\n    } else {\n#if USE_REENTRANT\n\tif (SP_PARM) {\n\t    SP_PARM->_TABSIZE = value;\n\t} else {\n\t    code = ERR;\n\t}\n#else\n\t(void) SP_PARM;\n\tTABSIZE = value;\n#endif\n    }\n    return code;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nset_tabsize(int value)\n{\n    return NCURSES_SP_NAME(set_tabsize) (CURRENT_SCREEN, value);\n}\n#endif\n#endif  \n\n#if USE_SIGWINCH\n \nNCURSES_EXPORT(int)\n_nc_handle_sigwinch(SCREEN *sp)\n{\n    SCREEN *scan;\n\n    if (_nc_globals.have_sigwinch) {\n\t_nc_globals.have_sigwinch = 0;\n\n\tfor (each_screen(scan)) {\n\t    scan->_sig_winch = TRUE;\n\t}\n    }\n\n    return (sp ? sp->_sig_winch : 0);\n}\n\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(use_env) (NCURSES_SP_DCLx bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_env(%p,%d)\"), (void *) SP_PARM, (int) f));\n#if NCURSES_SP_FUNCS\n    if (IsPreScreen(SP_PARM)) {\n\tSP_PARM->_use_env = f;\n    }\n#else\n    _nc_prescreen.use_env = f;\n#endif\n    returnVoid;\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(use_tioctl) (NCURSES_SP_DCLx bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_tioctl(%p,%d)\"), (void *) SP_PARM, (int) f));\n#if NCURSES_SP_FUNCS\n    if (IsPreScreen(SP_PARM)) {\n\tSP_PARM->use_tioctl = f;\n    }\n#else\n    _nc_prescreen.use_tioctl = f;\n#endif\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nuse_env(bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_env(%d)\"), (int) f));\n    _nc_prescreen.use_env = f;\n    returnVoid;\n}\n\nNCURSES_EXPORT(void)\nuse_tioctl(bool f)\n{\n    START_TRACE();\n    T((T_CALLED(\"use_tioctl(%d)\"), (int) f));\n    _nc_prescreen.use_tioctl = f;\n    returnVoid;\n}\n#endif\n\nNCURSES_EXPORT(void)\n_nc_get_screensize(SCREEN *sp,\n#ifdef USE_TERM_DRIVER\n\t\t   TERMINAL *termp,\n#endif\n\t\t   int *linep, int *colp)\n \n{\n#ifdef USE_TERM_DRIVER\n    TERMINAL_CONTROL_BLOCK *TCB;\n    int my_tabsize;\n\n    assert(termp != 0 && linep != 0 && colp != 0);\n    TCB = (TERMINAL_CONTROL_BLOCK *) termp;\n\n    my_tabsize = TCB->info.tabsize;\n    TCB->drv->td_size(TCB, linep, colp);\n\n#if USE_REENTRANT\n    if (sp != 0) {\n\tsp->_TABSIZE = my_tabsize;\n    }\n#else\n    (void) sp;\n    TABSIZE = my_tabsize;\n#endif\n    T((\"TABSIZE = %d\", my_tabsize));\n#else  \n    TERMINAL *termp = cur_term;\n    int my_tabsize;\n    bool useEnv = _nc_prescreen.use_env;\n    bool useTioctl = _nc_prescreen.use_tioctl;\n\n#ifdef EXP_WIN32_DRIVER\n     \n    _nc_console_size(linep, colp);\n    T((\"screen size: winconsole lines = %d columns = %d\", *linep, *colp));\n#else\n     \n    T((\"screen size: terminfo lines = %d columns = %d\", lines, columns));\n\n    *linep = (int) lines;\n    *colp = (int) columns;\n#endif\n\n#if NCURSES_SP_FUNCS\n    if (sp) {\n\tuseEnv = sp->_use_env;\n\tuseTioctl = sp->use_tioctl;\n    }\n#endif\n\n    if (useEnv || useTioctl) {\n#ifdef __EMX__\n\t{\n\t    int screendata[2];\n\t    _scrsize(screendata);\n\t    *colp = screendata[0];\n\t    *linep = ((sp != 0 && sp->_filtered)\n\t\t      ? 1\n\t\t      : screendata[1]);\n\t    T((\"EMX screen size: environment LINES = %d COLUMNS = %d\",\n\t       *linep, *colp));\n\t}\n#endif\n#if HAVE_SIZECHANGE\n\t \n\tif (NC_ISATTY(cur_term->Filedes)) {\n\t    STRUCT_WINSIZE size;\n\n\t    errno = 0;\n\t    do {\n\t\tif (ioctl(cur_term->Filedes, IOCTL_WINSIZE, &size) >= 0) {\n\t\t    *linep = ((sp != 0 && sp->_filtered)\n\t\t\t      ? 1\n\t\t\t      : WINSIZE_ROWS(size));\n\t\t    *colp = WINSIZE_COLS(size);\n\t\t    T((\"SYS screen size: environment LINES = %d COLUMNS = %d\",\n\t\t       *linep, *colp));\n\t\t    break;\n\t\t}\n\t    } while\n\t\t(errno == EINTR);\n\t}\n#endif  \n\n\tif (useEnv) {\n\t    int value;\n\n\t    if (useTioctl) {\n\t\t \n\t\tif ((sp == 0 || !sp->_filtered) && _nc_getenv_num(\"LINES\") > 0) {\n\t\t    _nc_setenv_num(\"LINES\", *linep);\n\t\t}\n\t\tif (_nc_getenv_num(\"COLUMNS\") > 0) {\n\t\t    _nc_setenv_num(\"COLUMNS\", *colp);\n\t\t}\n\t    }\n\n\t     \n\t    if ((value = _nc_getenv_num(\"LINES\")) > 0) {\n\t\t*linep = value;\n\t\tT((\"screen size: environment LINES = %d\", *linep));\n\t    }\n\t    if ((value = _nc_getenv_num(\"COLUMNS\")) > 0) {\n\t\t*colp = value;\n\t\tT((\"screen size: environment COLUMNS = %d\", *colp));\n\t    }\n\t}\n\n\t \n\tif (*linep <= 0) {\n\t    *linep = (int) lines;\n\t}\n\tif (*colp <= 0) {\n\t    *colp = (int) columns;\n\t}\n\n\t \n\tif (*linep <= 0) {\n\t    *linep = 24;\n\t}\n\tif (*colp <= 0) {\n\t    *colp = 80;\n\t}\n\n\t \n\tlines = (NCURSES_INT2) (*linep);\n\tcolumns = (NCURSES_INT2) (*colp);\n#if NCURSES_EXT_NUMBERS\n#define OldNumber(termp,name) \\\n\t(termp)->type.Numbers[(&name - (termp)->type2.Numbers)]\n\tOldNumber(termp, lines) = (short) (*linep);\n\tOldNumber(termp, columns) = (short) (*colp);\n#endif\n    }\n\n    T((\"screen size is %dx%d\", *linep, *colp));\n\n    if (VALID_NUMERIC(init_tabs))\n\tmy_tabsize = (int) init_tabs;\n    else\n\tmy_tabsize = 8;\n\n#if USE_REENTRANT\n    if (sp != 0)\n\tsp->_TABSIZE = my_tabsize;\n#else\n    TABSIZE = my_tabsize;\n#endif\n    T((\"TABSIZE = %d\", TABSIZE));\n#endif  \n}\n\n#if USE_SIZECHANGE\nNCURSES_EXPORT(void)\n_nc_update_screensize(SCREEN *sp)\n{\n    int new_lines;\n    int new_cols;\n\n#ifdef USE_TERM_DRIVER\n    int old_lines;\n    int old_cols;\n\n    assert(sp != 0);\n\n    CallDriver_2(sp, td_getsize, &old_lines, &old_cols);\n\n#else\n    TERMINAL *termp = cur_term;\n    int old_lines = lines;\n    int old_cols = columns;\n#endif\n\n    if (sp != 0) {\n\tTINFO_GET_SIZE(sp, sp->_term, &new_lines, &new_cols);\n\t \n\tif (sp->_resize != 0) {\n\t    if ((new_lines != old_lines) || (new_cols != old_cols)) {\n\t\tsp->_resize(NCURSES_SP_ARGx new_lines, new_cols);\n\t    } else if (sp->_sig_winch && (sp->_ungetch != 0)) {\n\t\tsp->_ungetch(SP_PARM, KEY_RESIZE);\t \n\t    }\n\t    sp->_sig_winch = FALSE;\n\t}\n    }\n}\n#endif  \n\n \n\n#if NCURSES_USE_DATABASE || NCURSES_USE_TERMCAP\n \nint\n_nc_setup_tinfo(const char *const tn, TERMTYPE2 *const tp)\n{\n    char filename[PATH_MAX];\n    int status = _nc_read_entry2(tn, filename, tp);\n\n     \n    if (status == TGETENT_YES) {\n\tunsigned n;\n\tfor_each_boolean(n, tp) {\n\t    if (!VALID_BOOLEAN(tp->Booleans[n]))\n\t\ttp->Booleans[n] = FALSE;\n\t}\n\tfor_each_string(n, tp) {\n\t    if (tp->Strings[n] == CANCELLED_STRING)\n\t\ttp->Strings[n] = ABSENT_STRING;\n\t}\n    }\n    return (status);\n}\n#endif\n\n \nvoid\n_nc_tinfo_cmdch(TERMINAL *termp, int proto)\n{\n    char *tmp;\n\n     \n    if ((tmp = getenv(\"CC\")) != 0 && strlen(tmp) == 1) {\n\tunsigned i;\n\tchar CC = *tmp;\n\n\tfor_each_string(i, &(termp->type)) {\n\t    for (tmp = termp->type.Strings[i]; tmp && *tmp; tmp++) {\n\t\tif (UChar(*tmp) == proto)\n\t\t    *tmp = CC;\n\t    }\n\t}\n    }\n}\n\n \nNCURSES_EXPORT(char *)\n_nc_get_locale(void)\n{\n    char *env;\n#if HAVE_LOCALE_H\n     \n    env = setlocale(LC_CTYPE, 0);\n#else\n    if (((env = getenv(\"LANG\")) != 0 && *env != '\\0')\n\t|| ((env = getenv(\"LC_CTYPE\")) != 0 && *env != '\\0')\n\t|| ((env = getenv(\"LC_ALL\")) != 0 && *env != '\\0')) {\n\t;\n    }\n#endif\n    T((\"_nc_get_locale %s\", _nc_visbuf(env)));\n    return env;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_unicode_locale(void)\n{\n    int result = 0;\n#if defined(_NC_WINDOWS) && USE_WIDEC_SUPPORT\n    result = 1;\n#elif HAVE_LANGINFO_CODESET\n    char *env = nl_langinfo(CODESET);\n    result = !strcmp(env, \"UTF-8\");\n    T((\"_nc_unicode_locale(%s) ->%d\", env, result));\n#else\n    char *env = _nc_get_locale();\n    if (env != 0) {\n\tif (strstr(env, \".UTF-8\") != 0) {\n\t    result = 1;\n\t    T((\"_nc_unicode_locale(%s) ->%d\", env, result));\n\t}\n    }\n#endif\n    return result;\n}\n\n#define CONTROL_N(s) ((s) != 0 && strstr(s, \"\\016\") != 0)\n#define CONTROL_O(s) ((s) != 0 && strstr(s, \"\\017\") != 0)\n\n \nNCURSES_EXPORT(int)\n_nc_locale_breaks_acs(TERMINAL *termp)\n{\n    const char *env_name = \"NCURSES_NO_UTF8_ACS\";\n    const char *env;\n    int value;\n    int result = 0;\n\n    T((T_CALLED(\"_nc_locale_breaks_acs:%d\"), result));\n    if (getenv(env_name) != 0) {\n\tresult = _nc_getenv_num(env_name);\n    } else if ((value = tigetnum(\"U8\")) >= 0) {\n\tresult = value;\t\t \n    } else if ((env = getenv(\"TERM\")) != 0) {\n\tif (strstr(env, \"linux\")) {\n\t    result = 1;\t\t \n\t} else if (strstr(env, \"screen\") != 0\n\t\t   && ((env = getenv(\"TERMCAP\")) != 0\n\t\t       && strstr(env, \"screen\") != 0)\n\t\t   && strstr(env, \"hhII00\") != 0) {\n\t    if (CONTROL_N(enter_alt_charset_mode) ||\n\t\tCONTROL_O(enter_alt_charset_mode) ||\n\t\tCONTROL_N(set_attributes) ||\n\t\tCONTROL_O(set_attributes)) {\n\t\tresult = 1;\n\t    }\n\t}\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(int)\nTINFO_SETUP_TERM(TERMINAL **tp,\n\t\t const char *tname,\n\t\t int Filedes,\n\t\t int *errret,\n\t\t int reuse)\n{\n#ifdef USE_TERM_DRIVER\n    TERMINAL_CONTROL_BLOCK *TCB = 0;\n#endif\n    TERMINAL *termp;\n    SCREEN *sp = 0;\n    char *myname;\n    int code = ERR;\n\n    START_TRACE();\n\n#ifdef USE_TERM_DRIVER\n    T((T_CALLED(\"_nc_setupterm_ex(%p,%s,%d,%p)\"),\n       (void *) tp, _nc_visbuf(tname), Filedes, (void *) errret));\n\n    if (tp == 0) {\n\tret_error0(TGETENT_ERR,\n\t\t   \"Invalid parameter, internal error.\\n\");\n    } else\n\ttermp = *tp;\n#else\n    termp = cur_term;\n    T((T_CALLED(\"setupterm(%s,%d,%p)\"), _nc_visbuf(tname), Filedes, (void *) errret));\n#endif\n\n    if (tname == 0) {\n\ttname = getenv(\"TERM\");\n#if defined(EXP_WIN32_DRIVER)\n\tif (!VALID_TERM_ENV(tname, NO_TERMINAL)) {\n\t    T((\"Failure with TERM=%s\", NonNull(tname)));\n\t    ret_error0(TGETENT_ERR, \"TERM environment variable not set.\\n\");\n\t}\n#elif defined(USE_TERM_DRIVER)\n\tif (!NonEmpty(tname))\n\t    tname = \"unknown\";\n#else\n\tif (!NonEmpty(tname)) {\n\t    T((\"Failure with TERM=%s\", NonNull(tname)));\n\t    ret_error0(TGETENT_ERR, \"TERM environment variable not set.\\n\");\n\t}\n#endif\n    }\n    myname = strdup(tname);\n\n    if (strlen(myname) > MAX_NAME_SIZE) {\n\tret_error(TGETENT_ERR,\n\t\t  \"TERM environment must be <= %d characters.\\n\",\n\t\t  MAX_NAME_SIZE,\n\t\t  free(myname));\n    }\n\n    T((\"your terminal name is %s\", myname));\n\n     \n    if (Filedes == STDOUT_FILENO && !NC_ISATTY(Filedes))\n\tFiledes = STDERR_FILENO;\n#if defined(EXP_WIN32_DRIVER)\n    if (Filedes != STDERR_FILENO && NC_ISATTY(Filedes))\n\t_setmode(Filedes, _O_BINARY);\n#endif\n\n     \n    if (reuse\n\t&& (termp != 0)\n\t&& termp->Filedes == Filedes\n\t&& termp->_termname != 0\n\t&& !strcmp(termp->_termname, myname)\n\t&& _nc_name_match(TerminalType(termp).term_names, myname, \"|\")) {\n\tT((\"reusing existing terminal information and mode-settings\"));\n\tcode = OK;\n#ifdef USE_TERM_DRIVER\n\tTCB = (TERMINAL_CONTROL_BLOCK *) termp;\n#endif\n    } else {\n#ifdef USE_TERM_DRIVER\n\tTERMINAL_CONTROL_BLOCK *my_tcb;\n\ttermp = 0;\n\tif ((my_tcb = typeCalloc(TERMINAL_CONTROL_BLOCK, 1)) != 0)\n\t    termp = &(my_tcb->term);\n#else\n\tint status;\n\n\ttermp = typeCalloc(TERMINAL, 1);\n#endif\n\tif (termp == 0) {\n\t    ret_error1(TGETENT_ERR,\n\t\t       \"Not enough memory to create terminal structure.\\n\",\n\t\t       myname, free(myname));\n\t}\n\t++_nc_globals.terminal_count;\n#if HAVE_SYSCONF\n\t{\n\t    long limit;\n#ifdef LINE_MAX\n\t    limit = LINE_MAX;\n#else\n\t    limit = _nc_globals.getstr_limit;\n#endif\n#ifdef _SC_LINE_MAX\n\t    if (limit < sysconf(_SC_LINE_MAX))\n\t\tlimit = sysconf(_SC_LINE_MAX);\n#endif\n\t    if (_nc_globals.getstr_limit < (int) limit)\n\t\t_nc_globals.getstr_limit = (int) limit;\n\t}\n#endif  \n\tT((\"using %d for getstr limit\", _nc_globals.getstr_limit));\n\n#ifdef USE_TERM_DRIVER\n\tINIT_TERM_DRIVER();\n\tTCB = (TERMINAL_CONTROL_BLOCK *) termp;\n\tcode = _nc_globals.term_driver(TCB, myname, errret);\n\tif (code == OK) {\n\t    termp->Filedes = (short) Filedes;\n\t    termp->_termname = strdup(myname);\n\t} else {\n\t    ret_error1(errret ? *errret : TGETENT_ERR,\n\t\t       \"Could not find any driver to handle terminal.\\n\",\n\t\t       myname, free(myname));\n\t}\n#else\n#if NCURSES_USE_DATABASE || NCURSES_USE_TERMCAP\n\tstatus = _nc_setup_tinfo(myname, &TerminalType(termp));\n\tT((\"_nc_setup_tinfo returns %d\", status));\n#else\n\tT((\"no database available\"));\n\tstatus = TGETENT_NO;\n#endif\n\n\t \n\tif (status != TGETENT_YES) {\n\t    const TERMTYPE2 *fallback = _nc_fallback2(myname);\n\n\t    if (fallback) {\n\t\tT((\"found fallback entry\"));\n\t\t_nc_copy_termtype2(&(TerminalType(termp)), fallback);\n\t\tstatus = TGETENT_YES;\n\t    }\n\t}\n\n\tif (status != TGETENT_YES) {\n\t    del_curterm(termp);\n\t    if (status == TGETENT_ERR) {\n\t\tfree(myname);\n\t\tret_error0(status, \"terminals database is inaccessible\\n\");\n\t    } else if (status == TGETENT_NO) {\n\t\tret_error1(status, \"unknown terminal type.\\n\",\n\t\t\t   myname, free(myname));\n\t    } else {\n\t\tfree(myname);\n\t\tret_error0(status, \"unexpected return-code\\n\");\n\t    }\n\t}\n#if NCURSES_EXT_NUMBERS\n\t_nc_export_termtype2(&termp->type, &TerminalType(termp));\n#endif\n#if !USE_REENTRANT\n\tsave_ttytype(termp);\n#endif\n\n\ttermp->Filedes = (short) Filedes;\n\ttermp->_termname = strdup(myname);\n\n\tset_curterm(termp);\n\n\tif (command_character)\n\t    _nc_tinfo_cmdch(termp, UChar(*command_character));\n\n\t \n\tif (NC_ISATTY(Filedes)) {\n\t    NCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(baudrate) (NCURSES_SP_ARG);\n\t}\n\tcode = OK;\n#endif\n    }\n\n#ifdef USE_TERM_DRIVER\n    *tp = termp;\n    NCURSES_SP_NAME(set_curterm) (sp, termp);\n    TCB->drv->td_init(TCB);\n#else\n    sp = SP;\n#endif\n\n     \n    TINFO_GET_SIZE(sp, termp, ptrLines(sp), ptrCols(sp));\n\n    if (errret)\n\t*errret = TGETENT_YES;\n\n#ifndef USE_TERM_DRIVER\n    if (generic_type) {\n\t \n\tif ((VALID_STRING(cursor_address)\n\t     || (VALID_STRING(cursor_down) && VALID_STRING(cursor_home)))\n\t    && VALID_STRING(clear_screen)) {\n\t    ret_error1(TGETENT_YES, \"terminal is not really generic.\\n\",\n\t\t       myname, free(myname));\n\t} else {\n\t    del_curterm(termp);\n\t    ret_error1(TGETENT_NO, \"I need something more specific.\\n\",\n\t\t       myname, free(myname));\n\t}\n    } else if (hard_copy) {\n\tret_error1(TGETENT_YES, \"I can't handle hardcopy terminals.\\n\",\n\t\t   myname, free(myname));\n    }\n#endif\n    free(myname);\n    returnCode(code);\n}\n\n#ifdef USE_PTHREADS\n \nNCURSES_EXPORT(SCREEN *)\n_nc_find_prescr(void)\n{\n    SCREEN *result = 0;\n    PRESCREEN_LIST *p;\n    pthread_t id = GetThreadID();\n    for (p = _nc_prescreen.allocated; p != 0; p = p->next) {\n\tif (p->id == id) {\n\t    result = p->sp;\n\t    break;\n\t}\n    }\n    return result;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_forget_prescr(void)\n{\n    PRESCREEN_LIST *p, *q;\n    pthread_t id = GetThreadID();\n    _nc_lock_global(screen);\n    for (p = _nc_prescreen.allocated, q = 0; p != 0; q = p, p = p->next) {\n\tif (p->id == id) {\n\t    if (q) {\n\t\tq->next = p->next;\n\t    } else {\n\t\t_nc_prescreen.allocated = p->next;\n\t    }\n\t    free(p);\n\t    break;\n\t}\n    }\n    _nc_unlock_global(screen);\n}\n#endif  \n\n#if NCURSES_SP_FUNCS\n \nNCURSES_EXPORT(SCREEN *)\nnew_prescr(void)\n{\n    SCREEN *sp;\n\n    START_TRACE();\n    T((T_CALLED(\"new_prescr()\")));\n\n    _nc_lock_global(screen);\n    if ((sp = _nc_find_prescr()) == 0) {\n\tsp = _nc_alloc_screen_sp();\n\tT((\"_nc_alloc_screen_sp %p\", (void *) sp));\n\tif (sp != 0) {\n#ifdef USE_PTHREADS\n\t    PRESCREEN_LIST *p = typeCalloc(PRESCREEN_LIST, 1);\n\t    if (p != 0) {\n\t\tp->id = GetThreadID();\n\t\tp->sp = sp;\n\t\tp->next = _nc_prescreen.allocated;\n\t\t_nc_prescreen.allocated = p;\n\t    }\n#else\n\t    _nc_prescreen.allocated = sp;\n#endif\n\t    sp->rsp = sp->rippedoff;\n\t    sp->_filtered = _nc_prescreen.filter_mode;\n\t    sp->_use_env = _nc_prescreen.use_env;\n#if NCURSES_NO_PADDING\n\t    sp->_no_padding = _nc_prescreen._no_padding;\n#endif\n\t    sp->slk_format = 0;\n\t    sp->_slk = 0;\n\t    sp->_prescreen = TRUE;\n\t    SP_PRE_INIT(sp);\n#if USE_REENTRANT\n\t    sp->_TABSIZE = _nc_prescreen._TABSIZE;\n\t    sp->_ESCDELAY = _nc_prescreen._ESCDELAY;\n#endif\n\t}\n    } else {\n\tT((\"_nc_alloc_screen_sp %p (reuse)\", (void *) sp));\n    }\n    _nc_unlock_global(screen);\n    returnSP(sp);\n}\n#endif\n\n#ifdef USE_TERM_DRIVER\n \nNCURSES_EXPORT(int)\n_nc_setupterm(const char *tname,\n\t      int Filedes,\n\t      int *errret,\n\t      int reuse)\n{\n    int rc = ERR;\n    TERMINAL *termp = 0;\n\n    _nc_init_pthreads();\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    if (TINFO_SETUP_TERM(&termp, tname, Filedes, errret, reuse) == OK) {\n\t_nc_forget_prescr();\n\tif (NCURSES_SP_NAME(set_curterm) (CURRENT_SCREEN_PRE, termp) != 0) {\n\t    rc = OK;\n\t}\n    }\n    _nc_unlock_global(prescreen);\n\n    return rc;\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nsetupterm(const char *tname, int Filedes, int *errret)\n{\n    START_TRACE();\n    return _nc_setupterm(tname, Filedes, errret, FALSE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}