{
  "module_name": "db_iterator.c",
  "hash_id": "0d00a0212548f65ec285cc222880b158a5b6c6490fbc0e2718e42ac3ea2842ca",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/db_iterator.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <time.h>\n#include <tic.h>\n\n#if USE_HASHED_DB\n#include <hashed_db.h>\n#endif\n\nMODULE_ID(\"$Id: db_iterator.c,v 1.49 2022/04/23 20:03:15 tom Exp $\")\n\n#define HaveTicDirectory _nc_globals.have_tic_directory\n#define KeepTicDirectory _nc_globals.keep_tic_directory\n#define TicDirectory     _nc_globals.tic_directory\n#define my_blob          _nc_globals.dbd_blob\n#define my_list          _nc_globals.dbd_list\n#define my_size          _nc_globals.dbd_size\n#define my_time          _nc_globals.dbd_time\n#define my_vars          _nc_globals.dbd_vars\n\nstatic void\nadd_to_blob(const char *text, size_t limit)\n{\n    (void) limit;\n\n    if (*text != '\\0') {\n\tchar *last = my_blob + strlen(my_blob);\n\tif (last != my_blob)\n\t    *last++ = NCURSES_PATHSEP;\n\t_nc_STRCPY(last, text, limit);\n    }\n}\n\nstatic bool\ncheck_existence(const char *name, struct stat *sb)\n{\n    bool result = FALSE;\n\n    if (quick_prefix(name)) {\n\tresult = TRUE;\n    } else if (stat(name, sb) == 0\n\t       && (S_ISDIR(sb->st_mode)\n\t\t   || (S_ISREG(sb->st_mode) && sb->st_size))) {\n\tresult = TRUE;\n    }\n#if USE_HASHED_DB\n    else if (strlen(name) < PATH_MAX - sizeof(DBM_SUFFIX)) {\n\tchar temp[PATH_MAX];\n\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp)) \"%s%s\", name, DBM_SUFFIX);\n\tif (stat(temp, sb) == 0 && S_ISREG(sb->st_mode) && sb->st_size) {\n\t    result = TRUE;\n\t}\n    }\n#endif\n    return result;\n}\n\n \nstatic void\ntrim_formatting(char *source)\n{\n    char *target = source;\n    char ch;\n\n    while ((ch = *source++) != '\\0') {\n\tif (ch == '\\\\' && *source == '\\n')\n\t    continue;\n\tif (ch == '\\n' || ch == '\\t')\n\t    continue;\n\t*target++ = ch;\n    }\n    *target = '\\0';\n}\n\n \nstatic bool\nupdate_getenv(const char *name, DBDIRS which)\n{\n    bool result = FALSE;\n\n    if (which < dbdLAST) {\n\tchar *value;\n\tchar *cached_value = my_vars[which].value;\n\tbool same_value;\n\n\tif ((value = getenv(name)) != 0) {\n\t    value = strdup(value);\n\t}\n\tsame_value = ((value == 0 && cached_value == 0) ||\n\t\t      (value != 0 &&\n\t\t       cached_value != 0 &&\n\t\t       strcmp(value, cached_value) == 0));\n\n\t \n\tmy_vars[which].name = name;\n\n\tif (!same_value) {\n\t    FreeIfNeeded(my_vars[which].value);\n\t    my_vars[which].value = value;\n\t    result = TRUE;\n\t} else {\n\t    free(value);\n\t}\n    }\n    return result;\n}\n\n#if NCURSES_USE_DATABASE || NCURSES_USE_TERMCAP\nstatic char *\ncache_getenv(const char *name, DBDIRS which)\n{\n    char *result = 0;\n\n    (void) update_getenv(name, which);\n    if (which < dbdLAST) {\n\tresult = my_vars[which].value;\n    }\n    return result;\n}\n#endif\n\n \nstatic bool\ncache_expired(void)\n{\n    bool result = FALSE;\n    time_t now = time((time_t *) 0);\n\n    if (now > my_time) {\n\tresult = TRUE;\n    } else {\n\tDBDIRS n;\n\tfor (n = (DBDIRS) 0; n < dbdLAST; ++n) {\n\t    if (my_vars[n].name != 0\n\t\t&& update_getenv(my_vars[n].name, n)) {\n\t\tresult = TRUE;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return result;\n}\n\nstatic void\nfree_cache(void)\n{\n    FreeAndNull(my_blob);\n    FreeAndNull(my_list);\n}\n\nstatic void\nupdate_tic_dir(const char *update)\n{\n    free((char *) TicDirectory);\n    TicDirectory = update;\n}\n\n \nNCURSES_EXPORT(const char *)\n_nc_tic_dir(const char *path)\n{\n    T((\"_nc_tic_dir %s\", NonNull(path)));\n    if (!KeepTicDirectory) {\n\tif (path != NULL) {\n\t    if (path != TicDirectory)\n\t\tupdate_tic_dir(strdup(path));\n\t    HaveTicDirectory = TRUE;\n\t} else if (HaveTicDirectory == 0) {\n\t    if (use_terminfo_vars()) {\n\t\tconst char *envp;\n\t\tif ((envp = getenv(\"TERMINFO\")) != 0)\n\t\t    return _nc_tic_dir(envp);\n\t    }\n\t}\n    }\n    return TicDirectory ? TicDirectory : TERMINFO;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_keep_tic_dir(const char *path)\n{\n    _nc_tic_dir(path);\n    KeepTicDirectory = TRUE;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_last_db(void)\n{\n    if (my_blob != 0 && cache_expired()) {\n\tfree_cache();\n    }\n}\n\n \nNCURSES_EXPORT(const char *)\n_nc_next_db(DBDIRS * state, int *offset)\n{\n    const char *result;\n\n    (void) offset;\n    if ((int) *state < my_size\n\t&& my_list != 0\n\t&& my_list[*state] != 0) {\n\tresult = my_list[*state];\n\t(*state)++;\n    } else {\n\tresult = 0;\n    }\n    if (result != 0) {\n\tT((\"_nc_next_db %d %s\", *state, result));\n    }\n    return result;\n}\n\nNCURSES_EXPORT(void)\n_nc_first_db(DBDIRS * state, int *offset)\n{\n    bool cache_has_expired = FALSE;\n    *state = dbdTIC;\n    *offset = 0;\n\n    T((T_CALLED(\"_nc_first_db\")));\n\n     \n    if (my_blob == 0 || (cache_has_expired = cache_expired())) {\n\tsize_t blobsize = 0;\n\tconst char *values[dbdLAST];\n\tstruct stat *my_stat;\n\tint j;\n\n\tif (cache_has_expired)\n\t    free_cache();\n\n\tfor (j = 0; j < dbdLAST; ++j)\n\t    values[j] = 0;\n\n\t \n\tvalues[dbdTIC] = TicDirectory;\n\n#if NCURSES_USE_DATABASE\n#ifdef TERMINFO_DIRS\n\tvalues[dbdCfgList] = TERMINFO_DIRS;\n#endif\n#ifdef TERMINFO\n\tvalues[dbdCfgOnce] = TERMINFO;\n#endif\n#endif\n\n#if NCURSES_USE_TERMCAP\n\tvalues[dbdCfgList2] = TERMPATH;\n#endif\n\n\tif (use_terminfo_vars()) {\n#if NCURSES_USE_DATABASE\n\t    values[dbdEnvOnce] = cache_getenv(\"TERMINFO\", dbdEnvOnce);\n\t    values[dbdHome] = _nc_home_terminfo();\n\t    (void) cache_getenv(\"HOME\", dbdHome);\n\t    values[dbdEnvList] = cache_getenv(\"TERMINFO_DIRS\", dbdEnvList);\n\n#endif\n#if NCURSES_USE_TERMCAP\n\t    values[dbdEnvOnce2] = cache_getenv(\"TERMCAP\", dbdEnvOnce2);\n\t     \n\t    if (values[dbdEnvOnce2] != 0\n\t\t&& *values[dbdEnvOnce2] != '/') {\n\t\tvalues[dbdEnvOnce2] = 0;\n\t    }\n\t    values[dbdEnvList2] = cache_getenv(\"TERMPATH\", dbdEnvList2);\n#endif  \n\t}\n\n\tfor (j = 0; j < dbdLAST; ++j) {\n\t    if (values[j] == 0)\n\t\tvalues[j] = \"\";\n\t    blobsize += 2 + strlen(values[j]);\n\t}\n\n\tmy_blob = malloc(blobsize);\n\tif (my_blob != 0) {\n\t    *my_blob = '\\0';\n\t    for (j = 0; j < dbdLAST; ++j) {\n\t\tadd_to_blob(values[j], blobsize);\n\t    }\n\n\t     \n\t    blobsize = 2;\n\t    for (j = 0; my_blob[j] != '\\0'; ++j) {\n\t\tif (my_blob[j] == NCURSES_PATHSEP)\n\t\t    ++blobsize;\n\t    }\n\t    my_list = typeCalloc(char *, blobsize);\n\t    my_stat = typeCalloc(struct stat, blobsize);\n\t    if (my_list != 0 && my_stat != 0) {\n\t\tint k = 0;\n\t\tmy_list[k++] = my_blob;\n\t\tfor (j = 0; my_blob[j] != '\\0'; ++j) {\n\t\t    if (my_blob[j] == NCURSES_PATHSEP\n\t\t\t&& ((&my_blob[j] - my_list[k - 1]) != 3\n\t\t\t    || !quick_prefix(my_list[k - 1]))) {\n\t\t\tmy_blob[j] = '\\0';\n\t\t\tmy_list[k++] = &my_blob[j + 1];\n\t\t    }\n\t\t}\n\n\t\t \n\t\tfor (j = 0; my_list[j] != 0; ++j) {\n#ifdef TERMINFO\n\t\t    if (*my_list[j] == '\\0')\n\t\t\tmy_list[j] = strdup(TERMINFO);\n#endif\n\t\t    trim_formatting(my_list[j]);\n\t\t    for (k = 0; k < j; ++k) {\n\t\t\tif (!strcmp(my_list[j], my_list[k])) {\n\t\t\t    T((\"duplicate %s\", my_list[j]));\n\t\t\t    k = j - 1;\n\t\t\t    while ((my_list[j] = my_list[j + 1]) != 0) {\n\t\t\t\t++j;\n\t\t\t    }\n\t\t\t    j = k;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t \n\t\tfor (j = 0; my_list[j] != 0; ++j) {\n\t\t    bool found = check_existence(my_list[j], &my_stat[j]);\n#if HAVE_LINK\n\t\t    if (found) {\n\t\t\tfor (k = 0; k < j; ++k) {\n\t\t\t    if (my_stat[j].st_dev == my_stat[k].st_dev\n\t\t\t\t&& my_stat[j].st_ino == my_stat[k].st_ino) {\n\t\t\t\tfound = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n#endif\n\t\t    if (!found) {\n\t\t\tT((\"not found %s\", my_list[j]));\n\t\t\tk = j;\n\t\t\twhile ((my_list[k] = my_list[k + 1]) != 0) {\n\t\t\t    ++k;\n\t\t\t}\n\t\t\t--j;\n\t\t    }\n\t\t}\n\t\tmy_size = j;\n\t\tmy_time = time((time_t *) 0);\n\t    } else {\n\t\tFreeAndNull(my_blob);\n\t    }\n\t    free(my_stat);\n\t}\n    }\n    returnVoid;\n}\n\n#if NO_LEAKS\nvoid\n_nc_db_iterator_leaks(void)\n{\n    DBDIRS which;\n\n    if (my_blob != 0)\n\tFreeAndNull(my_blob);\n    if (my_list != 0)\n\tFreeAndNull(my_list);\n    for (which = 0; (int) which < dbdLAST; ++which) {\n\tmy_vars[which].name = 0;\n\tFreeIfNeeded(my_vars[which].value);\n\tmy_vars[which].value = 0;\n    }\n    update_tic_dir(NULL);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}