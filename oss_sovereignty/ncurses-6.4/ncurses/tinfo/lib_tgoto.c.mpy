{
  "module_name": "lib_tgoto.c",
  "hash_id": "3e2a6f3320437e9b618cdfaf1cf35caa5b59e8cf0c8bee4901e06980c48e8e14",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_tgoto.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <termcap.h>\n\nMODULE_ID(\"$Id: lib_tgoto.c,v 1.21 2020/05/27 23:55:56 tom Exp $\")\n\n#if !PURE_TERMINFO\nstatic bool\nis_termcap(const char *string)\n{\n    bool result = TRUE;\n\n    if (string == 0 || *string == '\\0') {\n\tresult = FALSE;\t\t \n    } else {\n\twhile ((*string != '\\0') && result) {\n\t    if (*string == '%') {\n\t\tswitch (*++string) {\n\t\tcase 'p':\n\t\t    result = FALSE;\n\t\t    break;\n\t\tcase '\\0':\n\t\t    string--;\n\t\t    break;\n\t\t}\n\t    } else if (string[0] == '$' && string[1] == '<') {\n\t\tresult = FALSE;\n\t    }\n\t    string++;\n\t}\n    }\n    return result;\n}\n\nstatic char *\ntgoto_internal(const char *string, int x, int y)\n{\n    static char *result;\n    static size_t length;\n\n    int swap_arg;\n    int param[3];\n    size_t used = 0;\n    size_t need = 10;\n    int *value = param;\n    bool need_BC = FALSE;\n\n    if (BC)\n\tneed += strlen(BC);\n\n    param[0] = y;\n    param[1] = x;\n    param[2] = 0;\n\n    while (*string != 0) {\n\tif ((used + need) > length) {\n\t    length += (used + need);\n\t    if ((result = typeRealloc(char, length, result)) == 0) {\n\t\tlength = 0;\n\t\tbreak;\n\t    }\n\t}\n\tif (*string == '%') {\n\t    const char *fmt = 0;\n\n\t    switch (*++string) {\n\t    case '\\0':\n\t\tstring--;\n\t\tbreak;\n\t    case 'd':\n\t\tfmt = \"%d\";\n\t\tbreak;\n\t    case '2':\n\t\tfmt = \"%02d\";\n\t\t*value %= 100;\n\t\tbreak;\n\t    case '3':\n\t\tfmt = \"%03d\";\n\t\t*value %= 1000;\n\t\tbreak;\n\t    case '+':\n\t\t*value += UChar(*++string);\n\t\t \n\t    case '.':\n\t\t \n\t\tif (*value == 0) {\n\t\t    if (BC != 0) {\n\t\t\t*value += 1;\n\t\t\tneed_BC = TRUE;\n\t\t    } else {\n\t\t\t \n\t\t\t*value = 0200;\n\t\t    }\n\t\t}\n\t\tresult[used++] = (char) *value++;\n\t\tbreak;\n\t    case '%':\n\t\tresult[used++] = *string;\n\t\tbreak;\n\t    case 'r':\n\t\tswap_arg = param[0];\n\t\tparam[0] = param[1];\n\t\tparam[1] = swap_arg;\n\t\tbreak;\n\t    case 'i':\n\t\tparam[0] += 1;\n\t\tparam[1] += 1;\n\t\tbreak;\n\t    case '>':\n\t\tif (*value > string[1])\n\t\t    *value += string[2];\n\t\tstring += 2;\n\t\tbreak;\n\t    case 'n':\t\t \n\t\tparam[0] ^= 0140;\n\t\tparam[1] ^= 0140;\n\t\tbreak;\n\t    case 'B':\t\t \n\t\t*value = 16 * (*value / 10) + (*value % 10);\n\t\tbreak;\n\t    case 'D':\t\t \n\t\t*value -= 2 * (*value % 16);\n\t\tbreak;\n\t    }\n\t    if (fmt != 0) {\n\t\t_nc_SPRINTF(result + used, _nc_SLIMIT(length - used)\n\t\t\t    fmt, *value++);\n\t\tused += strlen(result + used);\n\t\tfmt = 0;\n\t    }\n\t    if (value - param > 2) {\n\t\tvalue = param + 2;\n\t\t*value = 0;\n\t    }\n\t} else {\n\t    result[used++] = *string;\n\t}\n\tstring++;\n    }\n    if (result != 0) {\n\tif (need_BC) {\n\t    _nc_STRCPY(result + used, BC, length - used);\n\t    used += strlen(BC);\n\t}\n\tresult[used] = '\\0';\n    }\n    return result;\n}\n#endif\n\n \nNCURSES_EXPORT(char *)\ntgoto(const char *string, int x, int y)\n{\n    char *result;\n\n    T((T_CALLED(\"tgoto(%s, %d, %d)\"), _nc_visbuf(string), x, y));\n#if !PURE_TERMINFO\n    if (is_termcap(string))\n\tresult = tgoto_internal(string, x, y);\n    else\n#endif\n\tresult = TIPARM_2(string, y, x);\n    returnPtr(result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}