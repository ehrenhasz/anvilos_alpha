{
  "module_name": "lib_raw.c",
  "hash_id": "c2ce04465fa1be1b1327079e8736a8e96c032c9de23940626de99ecbb8fdb6e9",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_raw.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_raw.c,v 1.26 2020/11/21 22:07:48 tom Exp $\")\n\n#if HAVE_SYS_TERMIO_H\n#include <sys/termio.h>\t\t \n#endif\n\n#ifdef __EMX__\n#include <io.h>\n#define _nc_setmode(mode) setmode(SP_PARM->_ifd, mode)\n#else\n#define _nc_setmode(mode)\t \n#endif\n\n#if USE_KLIBC_KBD\n#define INCL_KBD\n#include <os2.h>\n#endif\n\n#define COOKED_INPUT\t(IXON|BRKINT|PARMRK)\n\n#ifdef TRACE\n#define BEFORE(N)\tif (USE_TRACEF(TRACE_BITS)) _nc_locked_tracef(\"%s before bits: %s\", N, _nc_tracebits())\n#define AFTER(N)\tif (USE_TRACEF(TRACE_BITS)) _nc_locked_tracef(\"%s after bits: %s\", N, _nc_tracebits())\n#else\n#define BEFORE(s)\n#define AFTER(s)\n#endif  \n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(raw) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"raw(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"raw\");\n\t_nc_setmode(O_BINARY);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(ICANON | ISIG | IEXTEN);\n\tbuf.c_iflag &= (unsigned) ~(COOKED_INPUT);\n\tbuf.c_cc[VMIN] = 1;\n\tbuf.c_cc[VTIME] = 0;\n#elif defined(EXP_WIN32_DRIVER)\n\tbuf.dwFlagIn &= (unsigned long) ~CONMODE_NORAW;\n#else\n\tbuf.sg_flags |= RAW;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n#if USE_KLIBC_KBD\n\t    KBDINFO kbdinfo;\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    KbdGetStatus(&kbdinfo, 0);\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    kbdinfo.fsMask &= ~KEYBOARD_ASCII_MODE;\n\t    kbdinfo.fsMask |= KEYBOARD_BINARY_MODE;\n\t    KbdSetStatus(&kbdinfo, 0);\n#endif\n\t    if (SP_PARM) {\n\t\tSP_PARM->_raw = TRUE;\n\t\tSP_PARM->_cbreak = 1;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"raw\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nraw(void)\n{\n    return NCURSES_SP_NAME(raw) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(cbreak) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"cbreak(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"cbreak\");\n\t_nc_setmode(O_BINARY);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~ICANON;\n\tbuf.c_iflag &= (unsigned) ~ICRNL;\n\tbuf.c_lflag |= ISIG;\n\tbuf.c_cc[VMIN] = 1;\n\tbuf.c_cc[VTIME] = 0;\n#elif defined(EXP_WIN32_DRIVER)\n\tbuf.dwFlagIn |= CONMODE_NORAW;\n\tbuf.dwFlagIn &= (unsigned long) ~CONMODE_NOCBREAK;\n#else\n\tbuf.sg_flags |= CBREAK;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n\t    if (SP_PARM) {\n\t\tSP_PARM->_cbreak = 1;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"cbreak\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ncbreak(void)\n{\n    return NCURSES_SP_NAME(cbreak) (CURRENT_SCREEN);\n}\n#endif\n\n \nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(qiflush) (NCURSES_SP_DCL0)\n{\n    TERMINAL *termp;\n\n    T((T_CALLED(\"qiflush(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\tint result;\n\n\tBEFORE(\"qiflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag &= (unsigned) ~(NOFLSH);\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\tresult = ERR;\n\t \n#endif\n\tif (result == OK)\n\t    termp->Nttyb = buf;\n\tAFTER(\"qiflush\");\n    }\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nqiflush(void)\n{\n    NCURSES_SP_NAME(qiflush) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(noraw) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"noraw(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"noraw\");\n\t_nc_setmode(O_TEXT);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag |= ISIG | ICANON |\n\t    (termp->Ottyb.c_lflag & IEXTEN);\n\tbuf.c_iflag |= COOKED_INPUT;\n#elif defined(EXP_WIN32_DRIVER)\n\tbuf.dwFlagIn |= CONMODE_NORAW;\n#else\n\tbuf.sg_flags &= ~(RAW | CBREAK);\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n#if USE_KLIBC_KBD\n\t    KBDINFO kbdinfo;\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    KbdGetStatus(&kbdinfo, 0);\n\n\t    kbdinfo.cb = sizeof(kbdinfo);\n\t    kbdinfo.fsMask &= ~KEYBOARD_BINARY_MODE;\n\t    kbdinfo.fsMask |= KEYBOARD_ASCII_MODE;\n\t    KbdSetStatus(&kbdinfo, 0);\n#endif\n\t    if (SP_PARM) {\n\t\tSP_PARM->_raw = FALSE;\n\t\tSP_PARM->_cbreak = 0;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"noraw\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnoraw(void)\n{\n    return NCURSES_SP_NAME(noraw) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(nocbreak) (NCURSES_SP_DCL0)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"nocbreak(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"nocbreak\");\n\t_nc_setmode(O_TEXT);\n\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag |= ICANON;\n\tbuf.c_iflag |= ICRNL;\n#elif defined(EXP_WIN32_DRIVER)\n\tbuf.dwFlagIn |= (CONMODE_NOCBREAK | CONMODE_NORAW);\n#else\n\tbuf.sg_flags &= ~CBREAK;\n#endif\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n\tif (result == OK) {\n\t    if (SP_PARM) {\n\t\tSP_PARM->_cbreak = 0;\n\t    }\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"nocbreak\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nnocbreak(void)\n{\n    return NCURSES_SP_NAME(nocbreak) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(noqiflush) (NCURSES_SP_DCL0)\n{\n    TERMINAL *termp;\n\n    T((T_CALLED(\"noqiflush(%p)\"), (void *) SP_PARM));\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\tint result;\n\n\tBEFORE(\"noqiflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tbuf.c_lflag |= NOFLSH;\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\t \n\tresult = ERR;\n#endif\n\tif (result == OK)\n\t    termp->Nttyb = buf;\n\tAFTER(\"noqiflush\");\n    }\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\nnoqiflush(void)\n{\n    NCURSES_SP_NAME(noqiflush) (CURRENT_SCREEN);\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(intrflush) (NCURSES_SP_DCLx WINDOW *win GCC_UNUSED, bool flag)\n{\n    int result = ERR;\n    TERMINAL *termp;\n\n    T((T_CALLED(\"intrflush(%p,%d)\"), (void *) SP_PARM, flag));\n    if (SP_PARM == 0)\n\treturnCode(ERR);\n\n    if ((termp = TerminalOf(SP_PARM)) != 0) {\n\tTTY buf;\n\n\tBEFORE(\"intrflush\");\n\tbuf = termp->Nttyb;\n#ifdef TERMIOS\n\tif (flag)\n\t    buf.c_lflag &= (unsigned) ~(NOFLSH);\n\telse\n\t    buf.c_lflag |= (NOFLSH);\n\tresult = NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx &buf);\n#else\n\t \n#endif\n\tif (result == OK) {\n\t    termp->Nttyb = buf;\n\t}\n\tAFTER(\"intrflush\");\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nintrflush(WINDOW *win GCC_UNUSED, bool flag)\n{\n    return NCURSES_SP_NAME(intrflush) (CURRENT_SCREEN, win, flag);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}