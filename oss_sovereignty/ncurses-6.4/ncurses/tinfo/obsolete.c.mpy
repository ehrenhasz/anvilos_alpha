{
  "module_name": "obsolete.c",
  "hash_id": "43121b3f78a15e17f03964d78bfcd8b1b211eeca97e33333d8551f7e27e3f228",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/obsolete.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: obsolete.c,v 1.6 2020/02/02 23:34:34 tom Exp $\")\n\n \nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_set_buffer) (NCURSES_SP_DCLx FILE *ofp, int buffered)\n{\n#if NCURSES_SP_FUNCS\n    (void) SP_PARM;\n#endif\n    (void) ofp;\n    (void) buffered;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_set_buffer(FILE *ofp, int buffered)\n{\n    NCURSES_SP_NAME(_nc_set_buffer) (CURRENT_SCREEN, ofp, buffered);\n}\n#endif\n\n#if !HAVE_STRDUP\nNCURSES_EXPORT(char *)\n_nc_strdup(const char *s)\n{\n    char *result = 0;\n    if (s != 0) {\n\tsize_t need = strlen(s);\n\tresult = malloc(need + 1);\n\tif (result != 0) {\n\t    _nc_STRCPY(result, s, need);\n\t}\n    }\n    return result;\n}\n#endif\n\n#if USE_MY_MEMMOVE\n#define DST ((char *)s1)\n#define SRC ((const char *)s2)\nNCURSES_EXPORT(void *)\n_nc_memmove(void *s1, const void *s2, size_t n)\n{\n    if (n != 0) {\n\tif ((DST + n > SRC) && (SRC + n > DST)) {\n\t    static char *bfr;\n\t    static size_t length;\n\t    register size_t j;\n\t    if (length < n) {\n\t\tlength = (n * 3) / 2;\n\t\tbfr = typeRealloc(char, length, bfr);\n\t    }\n\t    for (j = 0; j < n; j++)\n\t\tbfr[j] = SRC[j];\n\t    s2 = bfr;\n\t}\n\twhile (n-- != 0)\n\t    DST[n] = SRC[n];\n    }\n    return s1;\n}\n#endif  \n\n#ifdef EXP_XTERM_1005\nNCURSES_EXPORT(int)\n_nc_conv_to_utf8(unsigned char *target, unsigned source, unsigned limit)\n{\n#define CH(n) UChar((source) >> ((n) * 8))\n    int rc = 0;\n\n    if (source <= 0x0000007f)\n\trc = 1;\n    else if (source <= 0x000007ff)\n\trc = 2;\n    else if (source <= 0x0000ffff)\n\trc = 3;\n    else if (source <= 0x001fffff)\n\trc = 4;\n    else if (source <= 0x03ffffff)\n\trc = 5;\n    else\t\t\t \n\trc = 6;\n\n    if ((unsigned) rc > limit) {\t \n\trc = 0;\n    }\n\n    if (target != 0) {\n\tswitch (rc) {\n\tcase 1:\n\t    target[0] = CH(0);\n\t    break;\n\n\tcase 2:\n\t    target[1] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[0] = UChar(0xc0 | (CH(0) >> 6) | ((CH(1) & 0x07) << 2));\n\t    break;\n\n\tcase 3:\n\t    target[2] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[1] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[0] = UChar(0xe0 | ((int) (CH(1) & 0xf0) >> 4));\n\t    break;\n\n\tcase 4:\n\t    target[3] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[2] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[1] = UChar(0x80 |\n\t\t\t      ((int) (CH(1) & 0xf0) >> 4) |\n\t\t\t      ((int) (CH(2) & 0x03) << 4));\n\t    target[0] = UChar(0xf0 | ((int) (CH(2) & 0x1f) >> 2));\n\t    break;\n\n\tcase 5:\n\t    target[4] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[3] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[2] = UChar(0x80 |\n\t\t\t      ((int) (CH(1) & 0xf0) >> 4) |\n\t\t\t      ((int) (CH(2) & 0x03) << 4));\n\t    target[1] = UChar(0x80 | (CH(2) >> 2));\n\t    target[0] = UChar(0xf8 | (CH(3) & 0x03));\n\t    break;\n\n\tcase 6:\n\t    target[5] = UChar(0x80 | (CH(0) & 0x3f));\n\t    target[4] = UChar(0x80 | (CH(0) >> 6) | ((CH(1) & 0x0f) << 2));\n\t    target[3] = UChar(0x80 | (CH(1) >> 4) | ((CH(2) & 0x03) << 4));\n\t    target[2] = UChar(0x80 | (CH(2) >> 2));\n\t    target[1] = UChar(0x80 | (CH(3) & 0x3f));\n\t    target[0] = UChar(0xfc | ((int) (CH(3) & 0x40) >> 6));\n\t    break;\n\t}\n    }\n\n    return rc;\t\t\t \n#undef CH\n}\n\nNCURSES_EXPORT(int)\n_nc_conv_to_utf32(unsigned *target, const char *source, unsigned limit)\n{\n#define CH(n) UChar((*target) >> ((n) * 8))\n    int rc = 0;\n    int j;\n    unsigned mask = 0;\n\n     \n    if ((*source & 0x80) == 0) {\n\trc = 1;\n\tmask = (unsigned) *source;\n    } else if ((*source & 0xe0) == 0xc0) {\n\trc = 2;\n\tmask = (unsigned) (*source & 0x1f);\n    } else if ((*source & 0xf0) == 0xe0) {\n\trc = 3;\n\tmask = (unsigned) (*source & 0x0f);\n    } else if ((*source & 0xf8) == 0xf0) {\n\trc = 4;\n\tmask = (unsigned) (*source & 0x07);\n    } else if ((*source & 0xfc) == 0xf8) {\n\trc = 5;\n\tmask = (unsigned) (*source & 0x03);\n    } else if ((*source & 0xfe) == 0xfc) {\n\trc = 6;\n\tmask = (unsigned) (*source & 0x01);\n    }\n\n    if ((unsigned) rc > limit) {\t \n\trc = 0;\n    }\n\n     \n    if (rc > 1) {\n\tfor (j = 1; j < rc; j++) {\n\t    if ((source[j] & 0xc0) != 0x80)\n\t\tbreak;\n\t}\n\tif (j != rc) {\n\t    rc = 0;\n\t}\n    }\n\n    if (target != 0) {\n\tint shift = 0;\n\t*target = 0;\n\tfor (j = 1; j < rc; j++) {\n\t    *target |= (unsigned) (source[rc - j] & 0x3f) << shift;\n\t    shift += 6;\n\t}\n\t*target |= mask << shift;\n    }\n    return rc;\n#undef CH\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}