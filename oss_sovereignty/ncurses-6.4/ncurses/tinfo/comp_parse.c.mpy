{
  "module_name": "comp_parse.c",
  "hash_id": "545dfad9196470b8b33e29ab0e5f450c5a695558cbc7406bbc0fbdebf86789c4",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/comp_parse.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: comp_parse.c,v 1.131 2022/10/23 13:15:58 tom Exp $\")\n\nstatic void sanity_check2(TERMTYPE2 *, bool);\nNCURSES_IMPEXP void (NCURSES_API *_nc_check_termtype2) (TERMTYPE2 *, bool) = sanity_check2;\n\nstatic void fixup_acsc(TERMTYPE2 *, int);\n\nstatic void\nenqueue(ENTRY * ep)\n \n{\n    ENTRY *newp;\n\n    DEBUG(2, (T_CALLED(\"enqueue(ep=%p)\"), (void *) ep));\n\n    newp = _nc_copy_entry(ep);\n    if (newp == 0)\n\t_nc_err_abort(MSG_NO_MEMORY);\n\n    newp->last = _nc_tail;\n    _nc_tail = newp;\n\n    newp->next = 0;\n    if (newp->last)\n\tnewp->last->next = newp;\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\n#define NAMEBUFFER_SIZE (MAX_NAME_SIZE + 2)\n\nstatic char *\nforce_bar(char *dst, char *src)\n{\n    if (strchr(src, '|') == 0) {\n\tsize_t len = strlen(src);\n\tif (len > MAX_NAME_SIZE)\n\t    len = MAX_NAME_SIZE;\n\t_nc_STRNCPY(dst, src, MAX_NAME_SIZE);\n\t_nc_STRCPY(dst + len, \"|\", NAMEBUFFER_SIZE - len);\n\tsrc = dst;\n    }\n    return src;\n}\n#define ForceBar(dst, src) ((strchr(src, '|') == 0) ? force_bar(dst, src) : src)\n\n#if NCURSES_USE_TERMCAP && NCURSES_XNAMES\nstatic char *\nskip_index(char *name)\n{\n    char *bar = strchr(name, '|');\n\n    if (bar != 0 && (bar - name) == 2)\n\tname = bar + 1;\n\n    return name;\n}\n#endif\n\nstatic bool\ncheck_collisions(char *n1, char *n2, int counter)\n{\n    char *pstart, *qstart, *pend, *qend;\n    char nc1[NAMEBUFFER_SIZE];\n    char nc2[NAMEBUFFER_SIZE];\n\n    n1 = ForceBar(nc1, n1);\n    n2 = ForceBar(nc2, n2);\n\n#if NCURSES_USE_TERMCAP && NCURSES_XNAMES\n    if ((_nc_syntax == SYN_TERMCAP) && _nc_user_definable) {\n\tn1 = skip_index(n1);\n\tn2 = skip_index(n2);\n    }\n#endif\n\n    for (pstart = n1; (pend = strchr(pstart, '|')); pstart = pend + 1) {\n\tfor (qstart = n2; (qend = strchr(qstart, '|')); qstart = qend + 1) {\n\t    if ((pend - pstart == qend - qstart)\n\t\t&& memcmp(pstart, qstart, (size_t) (pend - pstart)) == 0) {\n\t\tif (counter > 0)\n\t\t    (void) fprintf(stderr, \"Name collision '%.*s' between\\n\",\n\t\t\t\t   (int) (pend - pstart), pstart);\n\t\treturn (TRUE);\n\t    }\n\t}\n    }\n\n    return (FALSE);\n}\n\nstatic char *\nnext_name(char *name)\n{\n    if (*name != '\\0')\n\t++name;\n    return name;\n}\n\nstatic char *\nname_ending(char *name)\n{\n    if (*name == '\\0') {\n\tname = 0;\n    } else {\n\twhile (*name != '\\0' && *name != '|')\n\t    ++name;\n    }\n    return name;\n}\n\n \nstatic bool\nremove_collision(char *n1, char *n2)\n{\n    char *p2 = n2;\n    char *pstart, *qstart, *pend, *qend;\n    bool removed = FALSE;\n\n#if NCURSES_USE_TERMCAP && NCURSES_XNAMES\n    if ((_nc_syntax == SYN_TERMCAP) && _nc_user_definable) {\n\tn1 = skip_index(n1);\n\tp2 = n2 = skip_index(n2);\n    }\n#endif\n\n    for (pstart = n1; (pend = name_ending(pstart)); pstart = next_name(pend)) {\n\tfor (qstart = n2; (qend = name_ending(qstart)); qstart = next_name(qend)) {\n\t    if ((pend - pstart == qend - qstart)\n\t\t&& memcmp(pstart, qstart, (size_t) (pend - pstart)) == 0) {\n\t\tif (qstart != p2 || *qend == '|') {\n\t\t    if (*qend == '|')\n\t\t\t++qend;\n\t\t    while ((*qstart++ = *qend++) != '\\0') ;\n\t\t    fprintf(stderr, \"...now\\t%s\\n\", p2);\n\t\t    removed = TRUE;\n\t\t} else {\n\t\t    fprintf(stderr, \"Cannot remove alias '%.*s'\\n\",\n\t\t\t    (int) (qend - qstart), qstart);\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return removed;\n}\n\n \nNCURSES_EXPORT(bool)\n_nc_entry_match(char *n1, char *n2)\n{\n    return check_collisions(n1, n2, 0);\n}\n\n \n\nNCURSES_EXPORT(void)\n_nc_read_entry_source(FILE *fp, char *buf,\n\t\t      int literal, bool silent,\n\t\t      bool(*hook) (ENTRY *))\n \n{\n    ENTRY thisentry;\n    bool oldsuppress = _nc_suppress_warnings;\n    int immediate = 0;\n\n    DEBUG(2,\n\t  (T_CALLED(\"_nc_read_entry_source(\"\n\t\t    \"file=%p, buf=%p, literal=%d, silent=%d, hook=%#\"\n\t\t    PRIxPTR \")\"),\n\t   (void *) fp, buf, literal, silent, (intptr_t) hook));\n\n    if (silent)\n\t_nc_suppress_warnings = TRUE;\t \n\n    _nc_reset_input(fp, buf);\n    for (;;) {\n\tmemset(&thisentry, 0, sizeof(thisentry));\n\tif (_nc_parse_entry(&thisentry, literal, silent) == ERR)\n\t    break;\n\tif (!isalnum(UChar(thisentry.tterm.term_names[0])))\n\t    _nc_err_abort(\"terminal names must start with letter or digit\");\n\n\t \n\tif (hook != NULLHOOK && (*hook) (&thisentry)) {\n\t    immediate++;\n\t} else {\n\t    enqueue(&thisentry);\n\t     \n\t    FreeIfNeeded(thisentry.tterm.Booleans);\n\t    FreeIfNeeded(thisentry.tterm.Numbers);\n\t    FreeIfNeeded(thisentry.tterm.Strings);\n\t    FreeIfNeeded(thisentry.tterm.str_table);\n#if NCURSES_XNAMES\n\t    FreeIfNeeded(thisentry.tterm.ext_Names);\n\t    FreeIfNeeded(thisentry.tterm.ext_str_table);\n#endif\n\t}\n    }\n\n    if (_nc_tail) {\n\t \n\tfor (_nc_head = _nc_tail; _nc_head->last; _nc_head = _nc_head->last)\n\t    continue;\n\n\tDEBUG(2, (\"head = %s\", _nc_head->tterm.term_names));\n\tDEBUG(2, (\"tail = %s\", _nc_tail->tterm.term_names));\n    }\n#ifdef TRACE\n    else if (!immediate)\n\tDEBUG(2, (\"no entries parsed\"));\n#endif\n\n    _nc_suppress_warnings = oldsuppress;\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\n#if 0 && NCURSES_XNAMES\nstatic unsigned\nfind_capname(TERMTYPE2 *p, const char *name)\n{\n    unsigned num_names = NUM_EXT_NAMES(p);\n    unsigned n;\n    if (name != 0) {\n\tfor (n = 0; n < num_names; ++n) {\n\t    if (!strcmp(p->ext_Names[n], name))\n\t\tbreak;\n\t}\n    } else {\n\tn = num_names + 1;\n    }\n    return n;\n}\n\nstatic int\nextended_captype(TERMTYPE2 *p, unsigned which)\n{\n    int result = UNDEF;\n    unsigned limit = 0;\n    limit += p->ext_Booleans;\n    if (limit != 0 && which < limit) {\n\tresult = BOOLEAN;\n    } else {\n\tlimit += p->ext_Numbers;\n\tif (limit != 0 && which < limit) {\n\t    result = NUMBER;\n\t} else {\n\t    limit += p->ext_Strings;\n\t    if (limit != 0 && which < limit) {\n\t\tresult = ((p->Strings[STRCOUNT + which] != CANCELLED_STRING)\n\t\t\t  ? STRING\n\t\t\t  : CANCEL);\n\t    } else if (which >= limit) {\n\t\tresult = CANCEL;\n\t    }\n\t}\n    }\n    return result;\n}\n\nstatic const char *\nname_of_captype(int which)\n{\n    const char *result = \"?\";\n    switch (which) {\n    case BOOLEAN:\n\tresult = \"boolean\";\n\tbreak;\n    case NUMBER:\n\tresult = \"number\";\n\tbreak;\n    case STRING:\n\tresult = \"string\";\n\tbreak;\n    }\n    return result;\n}\n\n#define valid_TERMTYPE2(p) \\\n\t((p) != 0 && \\\n\t (p)->term_names != 0 && \\\n\t (p)->ext_Names != 0)\n\n \nstatic int\ninvalid_merge(TERMTYPE2 *to, TERMTYPE2 *from)\n{\n    int rc = FALSE;\n    if (valid_TERMTYPE2(to)\n\t&& valid_TERMTYPE2(from)) {\n\tchar *to_name = _nc_first_name(to->term_names);\n\tchar *from_name = strdup(_nc_first_name(from->term_names));\n\tunsigned num_names = NUM_EXT_NAMES(from);\n\tunsigned n;\n\n\tfor (n = 0; n < num_names; ++n) {\n\t    const char *capname = from->ext_Names[n];\n\t    int tt = extended_captype(to, find_capname(to, capname));\n\t    int tf = extended_captype(from, n);\n\n\t    if (tt <= STRING\n\t\t&& tf <= STRING\n\t\t&& (tt == STRING) != (tf == STRING)) {\n\t\tif (from_name != 0 && strcmp(to_name, from_name)) {\n\t\t    _nc_warning(\"merge of %s to %s changes type of %s from %s to %s\",\n\t\t\t\tfrom_name,\n\t\t\t\tto_name,\n\t\t\t\tfrom->ext_Names[n],\n\t\t\t\tname_of_captype(tf),\n\t\t\t\tname_of_captype(tt));\n\t\t} else {\n\t\t    _nc_warning(\"merge of %s changes type of %s from %s to %s\",\n\t\t\t\tto_name,\n\t\t\t\tfrom->ext_Names[n],\n\t\t\t\tname_of_captype(tf),\n\t\t\t\tname_of_captype(tt));\n\t\t}\n\t\trc = TRUE;\n\t    }\n\t}\n\tfree(from_name);\n    }\n    return rc;\n}\n#define validate_merge(p, q) \\\n\tif (invalid_merge(&((p)->tterm), &((q)->tterm))) \\\n\t\treturn FALSE\n#else\n#define validate_merge(p, q)\t \n#endif\n\nNCURSES_EXPORT(int)\n_nc_resolve_uses2(bool fullresolve, bool literal)\n \n{\n    ENTRY *qp, *rp, *lastread = 0;\n    bool keepgoing;\n    unsigned i, j;\n    int unresolved, total_unresolved, multiples;\n\n    DEBUG(2, (T_CALLED(\"_nc_resolve_uses2\")));\n\n     \n    multiples = 0;\n    for_entry_list(qp) {\n\tint matchcount = 0;\n\n\tfor_entry_list2(rp, qp->next) {\n\t    if (qp > rp\n\t\t&& check_collisions(qp->tterm.term_names,\n\t\t\t\t    rp->tterm.term_names,\n\t\t\t\t    matchcount + 1)) {\n\t\tif (!matchcount++) {\n\t\t    (void) fprintf(stderr, \"\\t%s\\n\", rp->tterm.term_names);\n\t\t}\n\t\t(void) fprintf(stderr, \"and\\t%s\\n\", qp->tterm.term_names);\n\t\tif (!remove_collision(rp->tterm.term_names,\n\t\t\t\t      qp->tterm.term_names)) {\n\t\t    ++multiples;\n\t\t}\n\t    }\n\t}\n    }\n    if (multiples > 0) {\n\tDEBUG(2, (T_RETURN(\"false\")));\n\treturn (FALSE);\n    }\n\n    DEBUG(2, (\"NO MULTIPLE NAME OCCURRENCES\"));\n\n     \n    total_unresolved = 0;\n    _nc_curr_col = -1;\n    for_entry_list(qp) {\n\tunresolved = 0;\n\tfor (i = 0; i < qp->nuses; i++) {\n\t    bool foundit;\n\t    char *child = _nc_first_name(qp->tterm.term_names);\n\t    char *lookfor = qp->uses[i].name;\n\t    long lookline = qp->uses[i].line;\n\n\t    if (lookfor == 0)\n\t\tcontinue;\n\n\t    foundit = FALSE;\n\n\t    _nc_set_type(child);\n\n\t     \n\t    for_entry_list(rp) {\n\t\tif (rp != qp\n\t\t    && _nc_name_match(rp->tterm.term_names, lookfor, \"|\")) {\n\t\t    DEBUG(2, (\"%s: resolving use=%s %p (in core)\",\n\t\t\t      child, lookfor, lookfor));\n\n\t\t    qp->uses[i].link = rp;\n\t\t    foundit = TRUE;\n\n\t\t     \n\t\t    for (j = 0; j < i; ++j) {\n\t\t\tif (qp->uses[j].link != NULL\n\t\t\t    && !strcmp(qp->uses[j].link->tterm.term_names,\n\t\t\t\t       rp->tterm.term_names)) {\n\t\t\t    _nc_warning(\"duplicate use=%s\", lookfor);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t     \n\t    if (!foundit) {\n\t\tTERMTYPE2 thisterm;\n\t\tchar filename[PATH_MAX];\n\n\t\tmemset(&thisterm, 0, sizeof(thisterm));\n\t\tif (_nc_read_entry2(lookfor, filename, &thisterm) == 1) {\n\t\t    DEBUG(2, (\"%s: resolving use=%s (compiled)\",\n\t\t\t      child, lookfor));\n\n\t\t    TYPE_MALLOC(ENTRY, 1, rp);\n\t\t    rp->tterm = thisterm;\n\t\t    rp->nuses = 0;\n\t\t    rp->next = lastread;\n\t\t    lastread = rp;\n\n\t\t    qp->uses[i].link = rp;\n\t\t    foundit = TRUE;\n\n\t\t     \n\t\t    for (j = 0; j < i; ++j) {\n\t\t\tif (qp->uses[j].link != NULL\n\t\t\t    && !strcmp(qp->uses[j].link->tterm.term_names,\n\t\t\t\t       rp->tterm.term_names)) {\n\t\t\t    _nc_warning(\"duplicate use=%s\", lookfor);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t     \n\t    if (!foundit) {\n\t\tunresolved++;\n\t\ttotal_unresolved++;\n\n\t\t_nc_curr_line = (int) lookline;\n\t\t_nc_warning(\"resolution of use=%s failed\", lookfor);\n\t\tqp->uses[i].link = 0;\n\t    }\n\t}\n    }\n    if (total_unresolved) {\n\t \n\t_nc_free_entries(lastread);\n\tDEBUG(2, (T_RETURN(\"false\")));\n\treturn (FALSE);\n    }\n\n    DEBUG(2, (\"NAME RESOLUTION COMPLETED OK\"));\n\n     \n    if (fullresolve) {\n\tdo {\n\t    ENTRY merged;\n\n\t    keepgoing = FALSE;\n\n\t    for_entry_list(qp) {\n\t\tif (qp->nuses > 0) {\n\t\t    DEBUG(2, (\"%s: attempting merge of %d entries\",\n\t\t\t      _nc_first_name(qp->tterm.term_names),\n\t\t\t      qp->nuses));\n\t\t     \n\t\t    for (i = 0; i < qp->nuses; i++) {\n\t\t\tif (qp->uses[i].link\n\t\t\t    && qp->uses[i].link->nuses) {\n\t\t\t    DEBUG(2, (\"%s: use entry %d unresolved\",\n\t\t\t\t      _nc_first_name(qp->tterm.term_names), i));\n\t\t\t    goto incomplete;\n\t\t\t}\n\t\t    }\n\n\t\t     \n\t\t    _nc_copy_termtype2(&(merged.tterm), &(qp->tterm));\n\n\t\t     \n\t\t    for (; qp->nuses; qp->nuses--) {\n\t\t\tint n = (int) (qp->nuses - 1);\n\t\t\tvalidate_merge(&merged, qp->uses[n].link);\n\t\t\t_nc_merge_entry(&merged, qp->uses[n].link);\n\t\t\tfree(qp->uses[n].name);\n\t\t    }\n\n\t\t     \n\t\t    validate_merge(&merged, qp);\n\t\t    _nc_merge_entry(&merged, qp);\n\n\t\t     \n\t\t    FreeIfNeeded(qp->tterm.Booleans);\n\t\t    FreeIfNeeded(qp->tterm.Numbers);\n\t\t    FreeIfNeeded(qp->tterm.Strings);\n\t\t    FreeIfNeeded(qp->tterm.str_table);\n#if NCURSES_XNAMES\n\t\t    FreeIfNeeded(qp->tterm.ext_Names);\n\t\t    FreeIfNeeded(qp->tterm.ext_str_table);\n#endif\n\t\t    qp->tterm = merged.tterm;\n\t\t    _nc_wrap_entry(qp, TRUE);\n\n\t\t     \n\t\t     \n\t\t  incomplete:\n\t\t    keepgoing = TRUE;\n\t\t}\n\t    }\n\t} while\n\t    (keepgoing);\n\n\tDEBUG(2, (\"MERGES COMPLETED OK\"));\n    }\n\n    DEBUG(2, (\"RESOLUTION FINISHED\"));\n\n    if (fullresolve) {\n\t_nc_curr_col = -1;\n\tfor_entry_list(qp) {\n\t    _nc_curr_line = (int) qp->startline;\n\t    _nc_set_type(_nc_first_name(qp->tterm.term_names));\n\t     \n\t    if (_nc_check_termtype2 != sanity_check2) {\n\t\tSCREEN *save_SP = SP;\n\t\tSCREEN fake_sp;\n\t\tTERMINAL fake_tm;\n\t\tTERMINAL *save_tm = cur_term;\n\n\t\t \n\t\tmemset(&fake_sp, 0, sizeof(fake_sp));\n\t\tmemset(&fake_tm, 0, sizeof(fake_tm));\n\t\tfake_sp._term = &fake_tm;\n\t\tTerminalType(&fake_tm) = qp->tterm;\n\t\t_nc_set_screen(&fake_sp);\n\t\tset_curterm(&fake_tm);\n\n\t\t_nc_check_termtype2(&qp->tterm, literal);\n\n\t\t \n#define TPS(name) fake_tm.tparm_state.name\n\t\tFreeAndNull(TPS(out_buff));\n\t\tFreeAndNull(TPS(fmt_buff));\n#undef TPS\n\n\t\t_nc_set_screen(save_SP);\n\t\tset_curterm(save_tm);\n\t    } else {\n\t\tfixup_acsc(&qp->tterm, literal);\n\t    }\n\t}\n\tDEBUG(2, (\"SANITY CHECK FINISHED\"));\n    }\n\n    DEBUG(2, (T_RETURN(\"true\")));\n    return (TRUE);\n}\n\n \n\n#undef CUR\n#define CUR tp->\n\nstatic void\nfixup_acsc(TERMTYPE2 *tp, int literal)\n{\n    if (!literal) {\n\tif (acs_chars == ABSENT_STRING\n\t    && PRESENT(enter_alt_charset_mode)\n\t    && PRESENT(exit_alt_charset_mode))\n\t    acs_chars = strdup(VT_ACSC);\n    }\n}\n\nstatic void\nsanity_check2(TERMTYPE2 *tp, bool literal)\n{\n    if (!PRESENT(exit_attribute_mode)) {\n#ifdef __UNUSED__\t\t \n\tbool terminal_entry = !strchr(tp->term_names, '+');\n\tif (terminal_entry &&\n\t    (PRESENT(set_attributes)\n\t     || PRESENT(enter_standout_mode)\n\t     || PRESENT(enter_underline_mode)\n\t     || PRESENT(enter_blink_mode)\n\t     || PRESENT(enter_bold_mode)\n\t     || PRESENT(enter_dim_mode)\n\t     || PRESENT(enter_secure_mode)\n\t     || PRESENT(enter_protected_mode)\n\t     || PRESENT(enter_reverse_mode)))\n\t    _nc_warning(\"no exit_attribute_mode\");\n#endif  \n\tPAIRED(enter_standout_mode, exit_standout_mode);\n\tPAIRED(enter_underline_mode, exit_underline_mode);\n#if defined(enter_italics_mode) && defined(exit_italics_mode)\n\tPAIRED(enter_italics_mode, exit_italics_mode);\n#endif\n    }\n\n     \n    if (!literal) {\n\tfixup_acsc(tp, literal);\n\tANDMISSING(enter_alt_charset_mode, acs_chars);\n\tANDMISSING(exit_alt_charset_mode, acs_chars);\n    }\n\n     \n    PAIRED(enter_alt_charset_mode, exit_alt_charset_mode);\n    ANDMISSING(enter_blink_mode, exit_attribute_mode);\n    ANDMISSING(enter_bold_mode, exit_attribute_mode);\n    PAIRED(exit_ca_mode, enter_ca_mode);\n    PAIRED(enter_delete_mode, exit_delete_mode);\n    ANDMISSING(enter_dim_mode, exit_attribute_mode);\n    PAIRED(enter_insert_mode, exit_insert_mode);\n    ANDMISSING(enter_secure_mode, exit_attribute_mode);\n    ANDMISSING(enter_protected_mode, exit_attribute_mode);\n    ANDMISSING(enter_reverse_mode, exit_attribute_mode);\n    PAIRED(from_status_line, to_status_line);\n    PAIRED(meta_off, meta_on);\n\n    PAIRED(prtr_on, prtr_off);\n    PAIRED(save_cursor, restore_cursor);\n    PAIRED(enter_xon_mode, exit_xon_mode);\n    PAIRED(enter_am_mode, exit_am_mode);\n    ANDMISSING(label_off, label_on);\n#if defined(display_clock) && defined(remove_clock)\n    PAIRED(display_clock, remove_clock);\n#endif\n    ANDMISSING(set_color_pair, initialize_pair);\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_leaks_tic(void)\n{\n    T((T_CALLED(\"_nc_leaks_tic()\")));\n    _nc_globals.leak_checking = TRUE;\n    _nc_alloc_entry_leaks();\n    _nc_captoinfo_leaks();\n    _nc_comp_scan_leaks();\n#if BROKEN_LINKER || USE_REENTRANT\n    _nc_names_leaks();\n    _nc_codes_leaks();\n#endif\n    _nc_tic_expand(0, FALSE, 0);\n    T((T_RETURN(\"\")));\n}\n\nNCURSES_EXPORT(void)\n_nc_free_tic(int code)\n{\n    T((T_CALLED(\"_nc_free_tic(%d)\"), code));\n    _nc_leaks_tic();\n    exit_terminfo(code);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}