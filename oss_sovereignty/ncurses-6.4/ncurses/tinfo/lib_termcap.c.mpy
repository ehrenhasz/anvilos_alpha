{
  "module_name": "lib_termcap.c",
  "hash_id": "98177217af0cc92ef81288b5edb25ab36a7f898b22a3d33b672a303541b3fd2e",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_termcap.c",
  "human_readable_source": " \n\n \n\n#define __INTERNAL_CAPS_VISIBLE\n#include <curses.priv.h>\n\n#include <termcap.h>\n#include <tic.h>\n#include <ctype.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_termcap.c,v 1.88 2020/02/02 23:34:34 tom Exp $\")\n\nNCURSES_EXPORT_VAR(char *) UP = 0;\nNCURSES_EXPORT_VAR(char *) BC = 0;\n\n#define MyCache  _nc_globals.tgetent_cache\n#define CacheInx _nc_globals.tgetent_index\n#define CacheSeq _nc_globals.tgetent_sequence\n\n#define FIX_SGR0 MyCache[CacheInx].fix_sgr0\n#define LAST_TRM MyCache[CacheInx].last_term\n#define LAST_BUF MyCache[CacheInx].last_bufp\n#define LAST_USE MyCache[CacheInx].last_used\n#define LAST_SEQ MyCache[CacheInx].sequence\n\n \n#define ValidCap(cap) (((cap)[0] != '\\0') && ((cap)[1] != '\\0'))\n#define SameCap(a,b)  (((a)[0] == (b)[0]) && ((a)[1] == (b)[1]))\n#define ValidExt(ext) (ValidCap(ext) && (ext)[2] == '\\0')\n\n \n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tgetent) (NCURSES_SP_DCLx char *bufp, const char *name)\n{\n    int rc = ERR;\n    int n;\n    bool found_cache = FALSE;\n#ifdef USE_TERM_DRIVER\n    TERMINAL *termp = 0;\n#endif\n\n    START_TRACE();\n    T((T_CALLED(\"tgetent()\")));\n\n    TINFO_SETUP_TERM(&termp, name, STDOUT_FILENO, &rc, TRUE);\n\n#ifdef USE_TERM_DRIVER\n    if (termp == 0 ||\n\t!((TERMINAL_CONTROL_BLOCK *) termp)->drv->isTerminfo)\n\treturnCode(rc);\n#endif\n\n     \n    for (n = 0; n < TGETENT_MAX; ++n) {\n\tbool same_result = (MyCache[n].last_used && MyCache[n].last_bufp == bufp);\n\tif (same_result) {\n\t    CacheInx = n;\n\t    if (FIX_SGR0 != 0) {\n\t\tFreeAndNull(FIX_SGR0);\n\t    }\n\t     \n\t    if (LAST_TRM != 0 && LAST_TRM != TerminalOf(SP_PARM)) {\n\t\tTERMINAL *trm = LAST_TRM;\n\t\tNCURSES_SP_NAME(del_curterm) (NCURSES_SP_ARGx LAST_TRM);\n\t\tfor (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx)\n\t\t    if (LAST_TRM == trm)\n\t\t\tLAST_TRM = 0;\n\t\tCacheInx = n;\n\t    }\n\t    found_cache = TRUE;\n\t    break;\n\t}\n    }\n    if (!found_cache) {\n\tint best = 0;\n\n\tfor (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {\n\t    if (LAST_SEQ < MyCache[best].sequence) {\n\t\tbest = CacheInx;\n\t    }\n\t}\n\tCacheInx = best;\n    }\n    if (rc == 1) {\n\tLAST_TRM = TerminalOf(SP_PARM);\n\tLAST_SEQ = ++CacheSeq;\n    } else {\n\tLAST_TRM = 0;\n    }\n\n    PC = 0;\n    UP = 0;\n    BC = 0;\n    FIX_SGR0 = 0;\t\t \n\n    if (rc == 1) {\n\n\tif (cursor_left)\n\t    if ((backspaces_with_bs = (char) !strcmp(cursor_left, \"\\b\")) == 0)\n\t\tbackspace_if_not_bs = cursor_left;\n\n\t \n\tif (pad_char != NULL)\n\t    PC = pad_char[0];\n\tif (cursor_up != NULL)\n\t    UP = cursor_up;\n\tif (backspace_if_not_bs != NULL)\n\t    BC = backspace_if_not_bs;\n\n\tif ((FIX_SGR0 = _nc_trim_sgr0(&TerminalType(TerminalOf(SP_PARM))))\n\t    != 0) {\n\t    if (!strcmp(FIX_SGR0, exit_attribute_mode)) {\n\t\tif (FIX_SGR0 != exit_attribute_mode) {\n\t\t    free(FIX_SGR0);\n\t\t}\n\t\tFIX_SGR0 = 0;\n\t    }\n\t}\n\tLAST_BUF = bufp;\n\tLAST_USE = TRUE;\n\n\tSetNoPadding(SP_PARM);\n\t(void) NCURSES_SP_NAME(baudrate) (NCURSES_SP_ARG);\t \n\n \n#include <capdefaults.c>\n \n\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ntgetent(char *bufp, const char *name)\n{\n    return NCURSES_SP_NAME(tgetent) (CURRENT_SCREEN, bufp, name);\n}\n#endif\n\n#if 0\nstatic bool\nsame_tcname(const char *a, const char *b)\n{\n    bool code = SameCap(a, b);\n    fprintf(stderr, \"compare(%s,%s) %s\\n\", a, b, code ? \"same\" : \"diff\");\n    return code;\n}\n\n#else\n#define same_tcname(a,b) SameCap(a,b)\n#endif\n\n \n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tgetflag) (NCURSES_SP_DCLx const char *id)\n{\n    int result = 0;\t\t \n\n    T((T_CALLED(\"tgetflag(%p, %s)\"), (void *) SP_PARM, id));\n    if (HasTInfoTerminal(SP_PARM) && ValidCap(id)) {\n\tTERMTYPE2 *tp = &TerminalType(TerminalOf(SP_PARM));\n\tstruct name_table_entry const *entry_ptr;\n\tint j = -1;\n\n\tentry_ptr = _nc_find_type_entry(id, BOOLEAN, TRUE);\n\tif (entry_ptr != 0) {\n\t    j = entry_ptr->nte_index;\n\t}\n#if NCURSES_XNAMES\n\telse {\n\t    int i;\n\t    for_each_ext_boolean(i, tp) {\n\t\tconst char *capname = ExtBoolname(tp, i, boolcodes);\n\t\tif (same_tcname(id, capname) && ValidExt(capname)) {\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tif (j >= 0) {\n\t     \n\t    result = tp->Booleans[j];\n\t}\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ntgetflag(const char *id)\n{\n    return NCURSES_SP_NAME(tgetflag) (CURRENT_SCREEN, id);\n}\n#endif\n\n \n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tgetnum) (NCURSES_SP_DCLx const char *id)\n{\n    int result = ABSENT_NUMERIC;\n\n    T((T_CALLED(\"tgetnum(%p, %s)\"), (void *) SP_PARM, id));\n    if (HasTInfoTerminal(SP_PARM) && ValidCap(id)) {\n\tTERMTYPE2 *tp = &TerminalType(TerminalOf(SP_PARM));\n\tstruct name_table_entry const *entry_ptr;\n\tint j = -1;\n\n\tentry_ptr = _nc_find_type_entry(id, NUMBER, TRUE);\n\tif (entry_ptr != 0) {\n\t    j = entry_ptr->nte_index;\n\t}\n#if NCURSES_XNAMES\n\telse {\n\t    int i;\n\t    for_each_ext_number(i, tp) {\n\t\tconst char *capname = ExtNumname(tp, i, numcodes);\n\t\tif (same_tcname(id, capname) && ValidExt(capname)) {\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tif (j >= 0) {\n\t    if (VALID_NUMERIC(tp->Numbers[j]))\n\t\tresult = tp->Numbers[j];\n\t}\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ntgetnum(const char *id)\n{\n    return NCURSES_SP_NAME(tgetnum) (CURRENT_SCREEN, id);\n}\n#endif\n\n \n\nNCURSES_EXPORT(char *)\nNCURSES_SP_NAME(tgetstr) (NCURSES_SP_DCLx const char *id, char **area)\n{\n    char *result = NULL;\n\n    T((T_CALLED(\"tgetstr(%s,%p)\"), id, (void *) area));\n    if (HasTInfoTerminal(SP_PARM) && ValidCap(id)) {\n\tTERMTYPE2 *tp = &TerminalType(TerminalOf(SP_PARM));\n\tstruct name_table_entry const *entry_ptr;\n\tint j = -1;\n\n\tentry_ptr = _nc_find_type_entry(id, STRING, TRUE);\n\tif (entry_ptr != 0) {\n\t    j = entry_ptr->nte_index;\n\t}\n#if NCURSES_XNAMES\n\telse {\n\t    int i;\n\t    for_each_ext_string(i, tp) {\n\t\tconst char *capname = ExtStrname(tp, i, strcodes);\n\t\tif (same_tcname(id, capname) && ValidExt(capname)) {\n\t\t    j = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tif (j >= 0) {\n\t    result = tp->Strings[j];\n\t    TR(TRACE_DATABASE, (\"found match %d: %s\", j, _nc_visbuf(result)));\n\t     \n\t    if (VALID_STRING(result)) {\n\t\tif (result == exit_attribute_mode\n\t\t    && FIX_SGR0 != 0) {\n\t\t    result = FIX_SGR0;\n\t\t    TR(TRACE_DATABASE, (\"altered to : %s\", _nc_visbuf(result)));\n\t\t}\n\t\tif (area != 0\n\t\t    && *area != 0) {\n\t\t    _nc_STRCPY(*area, result, 1024);\n\t\t    result = *area;\n\t\t    *area += strlen(*area) + 1;\n\t\t}\n\t    }\n\t}\n    }\n    returnPtr(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(char *)\ntgetstr(const char *id, char **area)\n{\n    return NCURSES_SP_NAME(tgetstr) (CURRENT_SCREEN, id, area);\n}\n#endif\n\n#if NO_LEAKS\n#undef CacheInx\n#define CacheInx num\nNCURSES_EXPORT(void)\n_nc_tgetent_leak(TERMINAL *termp)\n{\n    if (termp != 0) {\n\tint num;\n\tfor (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {\n\t    if (LAST_TRM == termp) {\n\t\tFreeAndNull(FIX_SGR0);\n\t\tif (LAST_TRM != 0) {\n\t\t    LAST_TRM = 0;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_tgetent_leaks(void)\n{\n    int num;\n    for (CacheInx = 0; CacheInx < TGETENT_MAX; ++CacheInx) {\n\tif (LAST_TRM != 0) {\n\t    del_curterm(LAST_TRM);\n\t    _nc_tgetent_leak(LAST_TRM);\n\t}\n    }\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}