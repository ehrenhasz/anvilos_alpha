{
  "module_name": "lib_tputs.c",
  "hash_id": "48e858654c792a8715f55014a0e588c609fe39fddbed8861f1a15a8604e2c8f1",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_tputs.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\n#include <ctype.h>\n#include <termcap.h>\t\t \n#include <tic.h>\n\nMODULE_ID(\"$Id: lib_tputs.c,v 1.109 2022/07/21 23:26:34 tom Exp $\")\n\nNCURSES_EXPORT_VAR(char) PC = 0;               \nNCURSES_EXPORT_VAR(NCURSES_OSPEED) ospeed = 0;         \n\nNCURSES_EXPORT_VAR(int) _nc_nulls_sent = 0;    \n\n#if NCURSES_NO_PADDING\nNCURSES_EXPORT(void)\n_nc_set_no_padding(SCREEN *sp)\n{\n    bool no_padding = (getenv(\"NCURSES_NO_PADDING\") != 0);\n\n    if (sp)\n\tsp->_no_padding = no_padding;\n    else\n\t_nc_prescreen._no_padding = no_padding;\n\n    TR(TRACE_CHARPUT | TRACE_MOVE, (\"padding will%s be used\",\n\t\t\t\t    GetNoPadding(sp) ? \" not\" : \"\"));\n}\n#endif\n\n#if NCURSES_SP_FUNCS\n#define SetOutCh(func) if (SP_PARM) SP_PARM->_outch = func; else _nc_prescreen._outch = func\n#define GetOutCh()     (SP_PARM ? SP_PARM->_outch : _nc_prescreen._outch)\n#else\n#define SetOutCh(func) static_outch = func\n#define GetOutCh()     static_outch\nstatic NCURSES_SP_OUTC static_outch = NCURSES_SP_NAME(_nc_outch);\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(delay_output) (NCURSES_SP_DCLx int ms)\n{\n    T((T_CALLED(\"delay_output(%p,%d)\"), (void *) SP_PARM, ms));\n\n    if (!HasTInfoTerminal(SP_PARM))\n\treturnCode(ERR);\n\n    if (no_pad_char) {\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n\tnapms(ms);\n    } else {\n\tNCURSES_SP_OUTC my_outch = GetOutCh();\n\tregister int nullcount;\n\n\tnullcount = (ms * _nc_baudrate(ospeed)) / (BAUDBYTE * 1000);\n\tfor (_nc_nulls_sent += nullcount; nullcount > 0; nullcount--)\n\t    my_outch(NCURSES_SP_ARGx PC);\n\tif (my_outch == NCURSES_SP_NAME(_nc_outch))\n\t    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    }\n\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndelay_output(int ms)\n{\n    return NCURSES_SP_NAME(delay_output) (CURRENT_SCREEN, ms);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"_nc_flush(%p)\"), (void *) SP_PARM));\n    if (SP_PARM != 0 && SP_PARM->_ofd >= 0) {\n\tTR(TRACE_CHARPUT, (\"ofd:%d inuse:%lu buffer:%p\",\n\t\t\t   SP_PARM->_ofd,\n\t\t\t   (unsigned long) SP_PARM->out_inuse,\n\t\t\t   SP_PARM->out_buffer));\n\tif (SP_PARM->out_inuse) {\n\t    char *buf = SP_PARM->out_buffer;\n\t    size_t amount = SP_PARM->out_inuse;\n\n\t    TR(TRACE_CHARPUT, (\"flushing %ld/%ld bytes\",\n\t\t\t       (unsigned long) amount, _nc_outchars));\n\t    while (amount) {\n\t\tssize_t res = write(SP_PARM->_ofd, buf, amount);\n\t\tif (res > 0) {\n\t\t     \n\t\t    amount -= (size_t) res;\n\t\t    buf += res;\n\t\t} else if (errno == EAGAIN) {\n\t\t    continue;\n\t\t} else if (errno == EINTR) {\n\t\t    continue;\n\t\t} else {\n\t\t    break;\t \n\t\t}\n\t    }\n\t} else if (SP_PARM->out_buffer == 0) {\n\t    TR(TRACE_CHARPUT, (\"flushing stdout\"));\n\t    fflush(stdout);\n\t}\n    } else {\n\tTR(TRACE_CHARPUT, (\"flushing stdout\"));\n\tfflush(stdout);\n    }\n    if (SP_PARM != 0)\n\tSP_PARM->out_inuse = 0;\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_flush(void)\n{\n    NCURSES_SP_NAME(_nc_flush) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_outch) (NCURSES_SP_DCLx int ch)\n{\n    int rc = OK;\n\n    COUNT_OUTCHARS(1);\n\n    if (HasTInfoTerminal(SP_PARM)\n\t&& SP_PARM != 0) {\n\tif (SP_PARM->out_buffer != 0) {\n\t    if (SP_PARM->out_inuse + 1 >= SP_PARM->out_limit)\n\t\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n\t    SP_PARM->out_buffer[SP_PARM->out_inuse++] = (char) ch;\n\t} else {\n\t    char tmp = (char) ch;\n\t     \n\t    if (write(fileno(NC_OUTPUT(SP_PARM)), &tmp, (size_t) 1) == -1)\n\t\trc = ERR;\n\t}\n    } else {\n\tchar tmp = (char) ch;\n\tif (write(fileno(stdout), &tmp, (size_t) 1) == -1)\n\t    rc = ERR;\n    }\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_outch(int ch)\n{\n    return NCURSES_SP_NAME(_nc_outch) (CURRENT_SCREEN, ch);\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_putchar) (NCURSES_SP_DCLx int ch)\n{\n    (void) SP_PARM;\n    return putchar(ch);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_putchar(int ch)\n{\n    return putchar(ch);\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(putp) (NCURSES_SP_DCLx const char *string)\n{\n    return NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t   string, 1, NCURSES_SP_NAME(_nc_putchar));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nputp(const char *string)\n{\n    return NCURSES_SP_NAME(putp) (CURRENT_SCREEN, string);\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_putp) (NCURSES_SP_DCLx\n\t\t\t   const char *name GCC_UNUSED,\n\t\t\t   const char *string)\n{\n    int rc = ERR;\n\n    if (string != 0) {\n\tTPUTS_TRACE(name);\n\trc = NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t     string, 1, NCURSES_SP_NAME(_nc_outch));\n    }\n    return rc;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_putp(const char *name, const char *string)\n{\n    return NCURSES_SP_NAME(_nc_putp) (CURRENT_SCREEN, name, string);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(tputs) (NCURSES_SP_DCLx\n\t\t\tconst char *string,\n\t\t\tint affcnt,\n\t\t\tNCURSES_SP_OUTC outc)\n{\n    NCURSES_SP_OUTC my_outch = GetOutCh();\n    bool always_delay = FALSE;\n    bool normal_delay = FALSE;\n    int number;\n#if BSD_TPUTS\n    int trailpad;\n#endif  \n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_TPUTS)) {\n\tchar addrbuf[32];\n\tTR_FUNC_BFR(1);\n\n\tif (outc == NCURSES_SP_NAME(_nc_outch)) {\n\t    _nc_STRCPY(addrbuf, \"_nc_outch\", sizeof(addrbuf));\n\t} else {\n\t    _nc_SPRINTF(addrbuf, _nc_SLIMIT(sizeof(addrbuf)) \"%s\",\n\t\t\tTR_FUNC_ARG(0, outc));\n\t}\n\tif (_nc_tputs_trace) {\n\t    _tracef(\"tputs(%s = %s, %d, %s) called\", _nc_tputs_trace,\n\t\t    _nc_visbuf(string), affcnt, addrbuf);\n\t} else {\n\t    _tracef(\"tputs(%s, %d, %s) called\", _nc_visbuf(string), affcnt, addrbuf);\n\t}\n\tTPUTS_TRACE(NULL);\n\t_nc_unlock_global(tracef);\n    }\n#endif  \n\n    if (!VALID_STRING(string))\n\treturn ERR;\n\n    if (SP_PARM != 0 && HasTInfoTerminal(SP_PARM)) {\n\tif (\n#if NCURSES_SP_FUNCS\n\t       (SP_PARM != 0 && SP_PARM->_term == 0)\n#else\n\t       cur_term == 0\n#endif\n\t    ) {\n\t    always_delay = FALSE;\n\t    normal_delay = TRUE;\n\t} else {\n\t    always_delay = (string == bell) || (string == flash_screen);\n\t    normal_delay =\n\t\t!xon_xoff\n\t\t&& padding_baud_rate\n#if NCURSES_NO_PADDING\n\t\t&& !GetNoPadding(SP_PARM)\n#endif\n\t\t&& (_nc_baudrate(ospeed) >= padding_baud_rate);\n\t}\n    }\n#if BSD_TPUTS\n     \n    trailpad = 0;\n    if (isdigit(UChar(*string))) {\n\twhile (isdigit(UChar(*string))) {\n\t    trailpad = trailpad * 10 + (*string - '0');\n\t    string++;\n\t}\n\ttrailpad *= 10;\n\tif (*string == '.') {\n\t    string++;\n\t    if (isdigit(UChar(*string))) {\n\t\ttrailpad += (*string - '0');\n\t\tstring++;\n\t    }\n\t    while (isdigit(UChar(*string)))\n\t\tstring++;\n\t}\n\n\tif (*string == '*') {\n\t    trailpad *= affcnt;\n\t    string++;\n\t}\n    }\n#endif  \n\n    SetOutCh(outc);\t\t \n    while (*string) {\n\tif (*string != '$')\n\t    (*outc) (NCURSES_SP_ARGx *string);\n\telse {\n\t    string++;\n\t    if (*string != '<') {\n\t\t(*outc) (NCURSES_SP_ARGx '$');\n\t\tif (*string)\n\t\t    (*outc) (NCURSES_SP_ARGx *string);\n\t    } else {\n\t\tbool mandatory;\n\n\t\tstring++;\n\t\tif ((!isdigit(UChar(*string)) && *string != '.')\n\t\t    || !strchr(string, '>')) {\n\t\t    (*outc) (NCURSES_SP_ARGx '$');\n\t\t    (*outc) (NCURSES_SP_ARGx '<');\n\t\t    continue;\n\t\t}\n\n\t\tnumber = 0;\n\t\twhile (isdigit(UChar(*string))) {\n\t\t    number = number * 10 + (*string - '0');\n\t\t    string++;\n\t\t}\n\t\tnumber *= 10;\n\t\tif (*string == '.') {\n\t\t    string++;\n\t\t    if (isdigit(UChar(*string))) {\n\t\t\tnumber += (*string - '0');\n\t\t\tstring++;\n\t\t    }\n\t\t    while (isdigit(UChar(*string)))\n\t\t\tstring++;\n\t\t}\n\n\t\tmandatory = FALSE;\n\t\twhile (*string == '*' || *string == '/') {\n\t\t    if (*string == '*') {\n\t\t\tnumber *= affcnt;\n\t\t\tstring++;\n\t\t    } else {\t \n\t\t\tmandatory = TRUE;\n\t\t\tstring++;\n\t\t    }\n\t\t}\n\n\t\tif (number > 0\n\t\t    && (always_delay\n\t\t\t|| normal_delay\n\t\t\t|| mandatory))\n\t\t    NCURSES_SP_NAME(delay_output) (NCURSES_SP_ARGx number / 10);\n\n\t    }\t\t\t \n\t}\t\t\t \n\n\tif (*string == '\\0')\n\t    break;\n\n\tstring++;\n    }\n\n#if BSD_TPUTS\n     \n    if (trailpad > 0\n\t&& (always_delay || normal_delay))\n\tNCURSES_SP_NAME(delay_output) (NCURSES_SP_ARGx trailpad / 10);\n#endif  \n\n    SetOutCh(my_outch);\n    return OK;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_outc_wrapper(SCREEN *sp, int c)\n{\n    if (0 == sp) {\n\treturn fputc(c, stdout);\n    } else {\n\treturn sp->jump(c);\n    }\n}\n\nNCURSES_EXPORT(int)\ntputs(const char *string, int affcnt, int (*outc) (int))\n{\n    SetSafeOutcWrapper(outc);\n    return NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx string, affcnt, _nc_outc_wrapper);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}