{
  "module_name": "lib_tparm.c",
  "hash_id": "a01f28cd70161b810373310095afa2994884c84236e6f8821ab1665fc9fb3df8",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_tparm.c",
  "human_readable_source": " \n\n \n\n \n\n#define entry _ncu_entry\n#define ENTRY _ncu_ENTRY\n\n#include <curses.priv.h>\n\n#undef entry\n#undef ENTRY\n\n#if HAVE_TSEARCH\n#include <search.h>\n#endif\n\n#include <ctype.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: lib_tparm.c,v 1.137 2021/11/20 23:29:15 tom Exp $\")\n\n \n\nNCURSES_EXPORT_VAR(int) _nc_tparm_err = 0;\n\n#define TPS(var) tps->var\n#define popcount _nc_popcount\t \n\n#define get_tparm_state(term) \\\n\t    (term != NULL \\\n\t      ? &(term->tparm_state) \\\n\t      : &(_nc_prescreen.tparm_state))\n\n#define isUPPER(c) ((c) >= 'A' && (c) <= 'Z')\n#define isLOWER(c) ((c) >= 'a' && (c) <= 'z')\n#define tc_BUMP()  if (level < 0 && number < 2) number++\n\ntypedef struct {\n    const char *format;\t\t \n    int tparm_type;\t\t \n    int num_actual;\n    int num_parsed;\n    int num_popped;\n    TPARM_ARG param[NUM_PARM];\n    char *p_is_s[NUM_PARM];\n} TPARM_DATA;\n\n#if HAVE_TSEARCH\n#define MyCache _nc_globals.cached_tparm\n#define MyCount _nc_globals.count_tparm\nstatic int which_tparm;\nstatic TPARM_DATA **delete_tparm;\n#endif  \n\nstatic char dummy[] = \"\";\t \n\n#if HAVE_TSEARCH\nstatic int\ncmp_format(const void *p, const void *q)\n{\n    const char *a = *(char *const *) p;\n    const char *b = *(char *const *) q;\n    return strcmp(a, b);\n}\n#endif\n\n#if HAVE_TSEARCH\nstatic void\nvisit_nodes(const void *nodep, VISIT which, int depth)\n{\n    (void) depth;\n    if (which == preorder || which == leaf) {\n\tdelete_tparm[which_tparm] = *(TPARM_DATA **) nodep;\n\twhich_tparm++;\n    }\n}\n#endif\n\nNCURSES_EXPORT(void)\n_nc_free_tparm(TERMINAL *termp)\n{\n    TPARM_STATE *tps = get_tparm_state(termp);\n#if HAVE_TSEARCH\n    if (MyCount != 0) {\n\tdelete_tparm = typeCalloc(TPARM_DATA *, MyCount);\n\twhich_tparm = 0;\n\ttwalk(MyCache, visit_nodes);\n\tfor (which_tparm = 0; which_tparm < MyCount; ++which_tparm) {\n\t    TPARM_DATA *ptr = delete_tparm[which_tparm];\n\t    if (ptr != NULL) {\n\t\ttdelete(ptr, &MyCache, cmp_format);\n\t\tfree((char *) ptr->format);\n\t\tfree(ptr);\n\t    }\n\t}\n\twhich_tparm = 0;\n\ttwalk(MyCache, visit_nodes);\n\tFreeAndNull(delete_tparm);\n\tMyCount = 0;\n\twhich_tparm = 0;\n    }\n#endif\n    FreeAndNull(TPS(out_buff));\n    TPS(out_size) = 0;\n    TPS(out_used) = 0;\n\n    FreeAndNull(TPS(fmt_buff));\n    TPS(fmt_size) = 0;\n}\n\nstatic int\ntparm_error(TPARM_STATE *tps, const char *message)\n{\n    (void) tps;\n    (void) message;\n    DEBUG(2, (\"%s: %s\", message, _nc_visbuf(TPS(tparam_base))));\n    return ++_nc_tparm_err;\n}\n\n#define get_space(tps, need) \\\n{ \\\n    size_t need2get = need + TPS(out_used); \\\n    if (need2get > TPS(out_size)) { \\\n\tTPS(out_size) = need2get * 2; \\\n\tTYPE_REALLOC(char, TPS(out_size), TPS(out_buff)); \\\n    } \\\n}\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE void\n  (get_space) (TPARM_STATE *tps, size_t need) {\n    get_space(tps, need);\n}\n\n#undef get_space\n#endif\n\n#define save_text(tps, fmt, s, len) \\\n{ \\\n    size_t s_len = (size_t) len + strlen(s) + strlen(fmt); \\\n    get_space(tps, s_len + 1); \\\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used), \\\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used)) \\\n\t\tfmt, s); \\\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used)); \\\n}\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE void\n  (save_text) (TPARM_STATE *tps, const char *fmt, const char *s, int len) {\n    save_text(tps, fmt, s, len);\n}\n\n#undef save_text\n#endif\n\n#define save_number(tps, fmt, number, len) \\\n{ \\\n    size_t s_len = (size_t) len + 30 + strlen(fmt); \\\n    get_space(tps, s_len + 1); \\\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used), \\\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used)) \\\n\t\tfmt, number); \\\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used)); \\\n}\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE void\n  (save_number) (TPARM_STATE *tps, const char *fmt, int number, int len) {\n    save_number(tps, fmt, number, len);\n}\n\n#undef save_number\n#endif\n\n#define save_char(tps, c) \\\n{ \\\n    get_space(tps, (size_t) 1); \\\n    TPS(out_buff)[TPS(out_used)++] = (char) ((c == 0) ? 0200 : c); \\\n}\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE void\n  (save_char) (TPARM_STATE *tps, int c) {\n    save_char(tps, c);\n}\n\n#undef save_char\n#endif\n\n#define npush(tps, x) \\\n{ \\\n    if (TPS(stack_ptr) < STACKSIZE) { \\\n\tTPS(stack)[TPS(stack_ptr)].num_type = TRUE; \\\n\tTPS(stack)[TPS(stack_ptr)].data.num = x; \\\n\tTPS(stack_ptr)++; \\\n    } else { \\\n\t(void) tparm_error(tps, \"npush: stack overflow\"); \\\n    } \\\n}\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE void\n  (npush) (TPARM_STATE *tps, int x) {\n    npush(tps, x);\n}\n\n#undef npush\n#endif\n\n#define spush(tps, x) \\\n{ \\\n    if (TPS(stack_ptr) < STACKSIZE) { \\\n\tTPS(stack)[TPS(stack_ptr)].num_type = FALSE; \\\n\tTPS(stack)[TPS(stack_ptr)].data.str = x; \\\n\tTPS(stack_ptr)++; \\\n    } else { \\\n\t(void) tparm_error(tps, \"spush: stack overflow\"); \\\n    } \\\n}\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE void\n  (spush) (TPARM_STATE *tps, char *x) {\n    spush(tps, x);\n}\n\n#undef spush\n#endif\n\n#define npop(tps) \\\n    ((TPS(stack_ptr)-- > 0) \\\n     ? ((TPS(stack)[TPS(stack_ptr)].num_type) \\\n\t ? TPS(stack)[TPS(stack_ptr)].data.num \\\n\t : 0) \\\n     : (tparm_error(tps, \"npop: stack underflow\"), \\\n        TPS(stack_ptr) = 0))\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE int\n  (npop) (TPARM_STATE *tps) {\n    return npop(tps);\n}\n#undef npop\n#endif\n\n#define spop(tps) \\\n    ((TPS(stack_ptr)-- > 0) \\\n     ? ((!TPS(stack)[TPS(stack_ptr)].num_type \\\n        && TPS(stack)[TPS(stack_ptr)].data.str != 0) \\\n         ? TPS(stack)[TPS(stack_ptr)].data.str \\\n         : dummy) \\\n     : (tparm_error(tps, \"spop: stack underflow\"), \\\n        dummy))\n\n#if NCURSES_EXPANDED\nstatic NCURSES_INLINE char *\n  (spop) (TPARM_STATE *tps) {\n    return spop(tps);\n}\n#undef spop\n#endif\n\nstatic NCURSES_INLINE const char *\nparse_format(const char *s, char *format, int *len)\n{\n    *len = 0;\n    if (format != 0) {\n\tbool done = FALSE;\n\tbool allowminus = FALSE;\n\tbool dot = FALSE;\n\tbool err = FALSE;\n\tchar *fmt = format;\n\tint my_width = 0;\n\tint my_prec = 0;\n\tint value = 0;\n\n\t*len = 0;\n\t*format++ = '%';\n\twhile (*s != '\\0' && !done) {\n\t    switch (*s) {\n\t    case 'c':\t\t \n\t    case 'd':\t\t \n\t    case 'o':\t\t \n\t    case 'x':\t\t \n\t    case 'X':\t\t \n\t    case 's':\n#ifdef EXP_XTERM_1005\n\t    case 'u':\n#endif\n\t\t*format++ = *s;\n\t\tdone = TRUE;\n\t\tbreak;\n\t    case '.':\n\t\t*format++ = *s++;\n\t\tif (dot) {\n\t\t    err = TRUE;\n\t\t} else {\t \n\t\t    dot = TRUE;\n\t\t    my_width = value;\n\t\t}\n\t\tvalue = 0;\n\t\tbreak;\n\t    case '#':\n\t\t*format++ = *s++;\n\t\tbreak;\n\t    case ' ':\n\t\t*format++ = *s++;\n\t\tbreak;\n\t    case ':':\n\t\ts++;\n\t\tallowminus = TRUE;\n\t\tbreak;\n\t    case '-':\n\t\tif (allowminus) {\n\t\t    *format++ = *s++;\n\t\t} else {\n\t\t    done = TRUE;\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tif (isdigit(UChar(*s))) {\n\t\t    value = (value * 10) + (*s - '0');\n\t\t    if (value > 10000)\n\t\t\terr = TRUE;\n\t\t    *format++ = *s++;\n\t\t} else {\n\t\t    done = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t \n\tif (err) {\n\t    my_width = my_prec = value = 0;\n\t    format = fmt;\n\t    *format++ = '%';\n\t    *format++ = *s;\n\t}\n\n\t \n\tif (dot)\n\t    my_prec = value;\n\telse\n\t    my_width = value;\n\n\t*format = '\\0';\n\t \n\t*len = (my_width > my_prec) ? my_width : my_prec;\n    }\n    return s;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_tparm_analyze(TERMINAL *term, const char *string, char **p_is_s, int *popcount)\n{\n    TPARM_STATE *tps = get_tparm_state(term);\n    size_t len2;\n    int i;\n    int lastpop = -1;\n    int len;\n    int number = 0;\n    int level = -1;\n    const char *cp = string;\n\n    if (cp == 0)\n\treturn 0;\n\n    if ((len2 = strlen(cp)) + 2 > TPS(fmt_size)) {\n\tTPS(fmt_size) += len2 + 2;\n\tTPS(fmt_buff) = typeRealloc(char, TPS(fmt_size), TPS(fmt_buff));\n\tif (TPS(fmt_buff) == 0)\n\t    return 0;\n    }\n\n    memset(p_is_s, 0, sizeof(p_is_s[0]) * NUM_PARM);\n    *popcount = 0;\n\n    while ((cp - string) < (int) len2) {\n\tif (*cp == '%') {\n\t    cp++;\n\t    cp = parse_format(cp, TPS(fmt_buff), &len);\n\t    switch (*cp) {\n\t    default:\n\t\tbreak;\n\n\t    case 'd':\t\t \n\t    case 'o':\t\t \n\t    case 'x':\t\t \n\t    case 'X':\t\t \n\t    case 'c':\t\t \n#ifdef EXP_XTERM_1005\n\t    case 'u':\n#endif\n\t\tif (lastpop <= 0) {\n\t\t    tc_BUMP();\n\t\t}\n\t\tlevel -= 1;\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case 'l':\n\t    case 's':\n\t\tif (lastpop > 0) {\n\t\t    level -= 1;\n\t\t    p_is_s[lastpop - 1] = dummy;\n\t\t}\n\t\ttc_BUMP();\n\t\tbreak;\n\n\t    case 'p':\n\t\tcp++;\n\t\ti = (UChar(*cp) - '0');\n\t\tif (i >= 0 && i <= NUM_PARM) {\n\t\t    ++level;\n\t\t    lastpop = i;\n\t\t    if (lastpop > *popcount)\n\t\t\t*popcount = lastpop;\n\t\t}\n\t\tbreak;\n\n\t    case 'P':\n\t\t++cp;\n\t\tbreak;\n\n\t    case 'g':\n\t\t++level;\n\t\tcp++;\n\t\tbreak;\n\n\t    case S_QUOTE:\n\t\t++level;\n\t\tcp += 2;\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case L_BRACE:\n\t\t++level;\n\t\tcp++;\n\t\twhile (isdigit(UChar(*cp))) {\n\t\t    cp++;\n\t\t}\n\t\tbreak;\n\n\t    case '+':\n\t    case '-':\n\t    case '*':\n\t    case '/':\n\t    case 'm':\n\t    case 'A':\n\t    case 'O':\n\t    case '&':\n\t    case '|':\n\t    case '^':\n\t    case '=':\n\t    case '<':\n\t    case '>':\n\t\ttc_BUMP();\n\t\tlevel -= 1;\t \n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case '!':\n\t    case '~':\n\t\ttc_BUMP();\n\t\tlastpop = -1;\n\t\tbreak;\n\n\t    case 'i':\n\t\t \n\t\tbreak;\n\t    }\n\t}\n\tif (*cp != '\\0')\n\t    cp++;\n    }\n\n    if (number > NUM_PARM)\n\tnumber = NUM_PARM;\n    return number;\n}\n\n \nstatic int\ntparm_setup(TERMINAL *term, const char *string, TPARM_DATA *result)\n{\n    TPARM_STATE *tps = get_tparm_state(term);\n    int rc = OK;\n\n    TPS(out_used) = 0;\n    memset(result, 0, sizeof(*result));\n\n    if (string == NULL) {\n\tTR(TRACE_CALLS, (\"%s: format is null\", TPS(tname)));\n\trc = ERR;\n    } else {\n#if HAVE_TSEARCH\n\tTPARM_DATA *fs;\n\tvoid *ft;\n\n\tresult->format = string;\n\tif ((ft = tfind(result, &MyCache, cmp_format)) != 0) {\n\t    size_t len2;\n\t    fs = *(TPARM_DATA **) ft;\n\t    *result = *fs;\n\t    if ((len2 = strlen(string)) + 2 > TPS(fmt_size)) {\n\t\tTPS(fmt_size) += len2 + 2;\n\t\tTPS(fmt_buff) = typeRealloc(char, TPS(fmt_size), TPS(fmt_buff));\n\t\tif (TPS(fmt_buff) == 0)\n\t\t    return ERR;\n\t    }\n\t} else\n#endif\n\t{\n\t     \n\t    result->num_parsed = _nc_tparm_analyze(term, string,\n\t\t\t\t\t\t   result->p_is_s,\n\t\t\t\t\t\t   &(result->num_popped));\n\t    if (TPS(fmt_buff) == 0) {\n\t\tTR(TRACE_CALLS, (\"%s: error in analysis\", TPS(tname)));\n\t\trc = ERR;\n\t    } else {\n\t\tint n;\n\n\t\tif (result->num_parsed > NUM_PARM)\n\t\t    result->num_parsed = NUM_PARM;\n\t\tif (result->num_popped > NUM_PARM)\n\t\t    result->num_popped = NUM_PARM;\n\t\tresult->num_actual = max(result->num_popped, result->num_parsed);\n\n\t\tfor (n = 0; n < result->num_actual; ++n) {\n\t\t    if (result->p_is_s[n])\n\t\t\tresult->tparm_type |= (1 << n);\n\t\t}\n#if HAVE_TSEARCH\n\t\tif ((fs = typeCalloc(TPARM_DATA, 1)) != 0) {\n\t\t    *fs = *result;\n\t\t    if ((fs->format = strdup(string)) != 0) {\n\t\t\tif (tsearch(fs, &MyCache, cmp_format) != 0) {\n\t\t\t    ++MyCount;\n\t\t\t} else {\n\t\t\t    free(fs);\n\t\t\t    rc = ERR;\n\t\t\t}\n\t\t    } else {\n\t\t\tfree(fs);\n\t\t\trc = ERR;\n\t\t    }\n\t\t} else {\n\t\t    rc = ERR;\n\t\t}\n#endif\n\t    }\n\t}\n    }\n\n    return rc;\n}\n\n \nstatic void\ntparm_copy_valist(TPARM_DATA *data, int use_TPARM_ARG, va_list ap)\n{\n    int i;\n\n    for (i = 0; i < data->num_actual; i++) {\n\tif (data->p_is_s[i] != 0) {\n\t    char *value = va_arg(ap, char *);\n\t    if (value == 0)\n\t\tvalue = dummy;\n\t    data->p_is_s[i] = value;\n\t    data->param[i] = 0;\n\t} else if (use_TPARM_ARG) {\n\t    data->param[i] = va_arg(ap, TPARM_ARG);\n\t} else {\n\t    data->param[i] = (TPARM_ARG) va_arg(ap, int);\n\t}\n    }\n}\n\n \nstatic bool\ntparm_tc_compat(TPARM_STATE *tps, TPARM_DATA *data)\n{\n    bool termcap_hack = FALSE;\n\n    TPS(stack_ptr) = 0;\n\n    if (data->num_popped == 0) {\n\tint i;\n\n\ttermcap_hack = TRUE;\n\tfor (i = data->num_parsed - 1; i >= 0; i--) {\n\t    if (data->p_is_s[i]) {\n\t\tspush(tps, data->p_is_s[i]);\n\t    } else {\n\t\tnpush(tps, (int) data->param[i]);\n\t    }\n\t}\n    }\n    return termcap_hack;\n}\n\n#ifdef TRACE\nstatic void\ntparm_trace_call(TPARM_STATE *tps, const char *string, TPARM_DATA *data)\n{\n    if (USE_TRACEF(TRACE_CALLS)) {\n\tint i;\n\tfor (i = 0; i < data->num_actual; i++) {\n\t    if (data->p_is_s[i] != 0) {\n\t\tsave_text(tps, \", %s\", _nc_visbuf(data->p_is_s[i]), 0);\n\t    } else if ((long) data->param[i] > MAX_OF_TYPE(NCURSES_INT2) ||\n\t\t       (long) data->param[i] < 0) {\n\t\t_tracef(\"BUG: problem with tparm parameter #%d of %d\",\n\t\t\ti + 1, data->num_actual);\n\t\tbreak;\n\t    } else {\n\t\tsave_number(tps, \", %d\", (int) data->param[i], 0);\n\t    }\n\t}\n\t_tracef(T_CALLED(\"%s(%s%s)\"), TPS(tname), _nc_visbuf(string), TPS(out_buff));\n\tTPS(out_used) = 0;\n\t_nc_unlock_global(tracef);\n    }\n}\n\n#else\n#define tparm_trace_call(tps, string, data)\t \n#endif  \n\n#define init_vars(name) \\\n\tif (!name##_used) { \\\n\t    name##_used = TRUE; \\\n\t    memset(name##_vars, 0, sizeof(name##_vars)); \\\n\t}\n\nstatic NCURSES_INLINE char *\ntparam_internal(TPARM_STATE *tps, const char *string, TPARM_DATA *data)\n{\n    int number;\n    int len;\n    int level;\n    int x, y;\n    int i;\n    const char *s;\n    const char *cp = string;\n    size_t len2 = strlen(cp);\n    bool incremented_two = FALSE;\n    bool termcap_hack = tparm_tc_compat(tps, data);\n     \n    bool dynamic_used = FALSE;\n    int dynamic_vars[NUM_VARS];\n\n    tparm_trace_call(tps, string, data);\n\n    while ((cp - string) < (int) len2) {\n\tif (*cp != '%') {\n\t    save_char(tps, UChar(*cp));\n\t} else {\n\t    TPS(tparam_base) = cp++;\n\t    cp = parse_format(cp, TPS(fmt_buff), &len);\n\t    switch (*cp) {\n\t    default:\n\t\tbreak;\n\t    case '%':\n\t\tsave_char(tps, '%');\n\t\tbreak;\n\n\t    case 'd':\t\t \n\t    case 'o':\t\t \n\t    case 'x':\t\t \n\t    case 'X':\t\t \n\t\tx = npop(tps);\n\t\tsave_number(tps, TPS(fmt_buff), x, len);\n\t\tbreak;\n\n\t    case 'c':\t\t \n\t\tx = npop(tps);\n\t\tsave_char(tps, x);\n\t\tbreak;\n\n#ifdef EXP_XTERM_1005\n\t    case 'u':\n\t\t{\n\t\t    unsigned char target[10];\n\t\t    unsigned source = (unsigned) npop(tps);\n\t\t    int rc = _nc_conv_to_utf8(target, source, (unsigned)\n\t\t\t\t\t      sizeof(target));\n\t\t    int n;\n\t\t    for (n = 0; n < rc; ++n) {\n\t\t\tsave_char(tps, target[n]);\n\t\t    }\n\t\t}\n\t\tbreak;\n#endif\n\t    case 'l':\n\t\ts = spop(tps);\n\t\tnpush(tps, (int) strlen(s));\n\t\tbreak;\n\n\t    case 's':\n\t\ts = spop(tps);\n\t\tsave_text(tps, TPS(fmt_buff), s, len);\n\t\tbreak;\n\n\t    case 'p':\n\t\tcp++;\n\t\ti = (UChar(*cp) - '1');\n\t\tif (i >= 0 && i < NUM_PARM) {\n\t\t    if (data->p_is_s[i]) {\n\t\t\tspush(tps, data->p_is_s[i]);\n\t\t    } else {\n\t\t\tnpush(tps, (int) data->param[i]);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case 'P':\n\t\tcp++;\n\t\tif (isUPPER(*cp)) {\n\t\t    i = (UChar(*cp) - 'A');\n\t\t    TPS(static_vars)[i] = npop(tps);\n\t\t} else if (isLOWER(*cp)) {\n\t\t    i = (UChar(*cp) - 'a');\n\t\t    init_vars(dynamic);\n\t\t    dynamic_vars[i] = npop(tps);\n\t\t}\n\t\tbreak;\n\n\t    case 'g':\n\t\tcp++;\n\t\tif (isUPPER(*cp)) {\n\t\t    i = (UChar(*cp) - 'A');\n\t\t    npush(tps, TPS(static_vars)[i]);\n\t\t} else if (isLOWER(*cp)) {\n\t\t    i = (UChar(*cp) - 'a');\n\t\t    init_vars(dynamic);\n\t\t    npush(tps, dynamic_vars[i]);\n\t\t}\n\t\tbreak;\n\n\t    case S_QUOTE:\n\t\tcp++;\n\t\tnpush(tps, UChar(*cp));\n\t\tcp++;\n\t\tbreak;\n\n\t    case L_BRACE:\n\t\tnumber = 0;\n\t\tcp++;\n\t\twhile (isdigit(UChar(*cp))) {\n\t\t    number = (number * 10) + (UChar(*cp) - '0');\n\t\t    cp++;\n\t\t}\n\t\tnpush(tps, number);\n\t\tbreak;\n\n\t    case '+':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x + y);\n\t\tbreak;\n\n\t    case '-':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x - y);\n\t\tbreak;\n\n\t    case '*':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x * y);\n\t\tbreak;\n\n\t    case '/':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, y ? (x / y) : 0);\n\t\tbreak;\n\n\t    case 'm':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, y ? (x % y) : 0);\n\t\tbreak;\n\n\t    case 'A':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, y && x);\n\t\tbreak;\n\n\t    case 'O':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, y || x);\n\t\tbreak;\n\n\t    case '&':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x & y);\n\t\tbreak;\n\n\t    case '|':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x | y);\n\t\tbreak;\n\n\t    case '^':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x ^ y);\n\t\tbreak;\n\n\t    case '=':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x == y);\n\t\tbreak;\n\n\t    case '<':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x < y);\n\t\tbreak;\n\n\t    case '>':\n\t\ty = npop(tps);\n\t\tx = npop(tps);\n\t\tnpush(tps, x > y);\n\t\tbreak;\n\n\t    case '!':\n\t\tx = npop(tps);\n\t\tnpush(tps, !x);\n\t\tbreak;\n\n\t    case '~':\n\t\tx = npop(tps);\n\t\tnpush(tps, ~x);\n\t\tbreak;\n\n\t    case 'i':\n\t\t \n\t\tif (!incremented_two) {\n\t\t    incremented_two = TRUE;\n\t\t    if (data->p_is_s[0] == 0) {\n\t\t\tdata->param[0]++;\n\t\t\tif (termcap_hack)\n\t\t\t    TPS(stack)[0].data.num = (int) data->param[0];\n\t\t    }\n\t\t    if (data->p_is_s[1] == 0) {\n\t\t\tdata->param[1]++;\n\t\t\tif (termcap_hack)\n\t\t\t    TPS(stack)[1].data.num = (int) data->param[1];\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '?':\n\t\tbreak;\n\n\t    case 't':\n\t\tx = npop(tps);\n\t\tif (!x) {\n\t\t     \n\t\t    cp++;\n\t\t    level = 0;\n\t\t    while (*cp) {\n\t\t\tif (*cp == '%') {\n\t\t\t    cp++;\n\t\t\t    if (*cp == '?')\n\t\t\t\tlevel++;\n\t\t\t    else if (*cp == ';') {\n\t\t\t\tif (level > 0)\n\t\t\t\t    level--;\n\t\t\t\telse\n\t\t\t\t    break;\n\t\t\t    } else if (*cp == 'e' && level == 0)\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*cp)\n\t\t\t    cp++;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case 'e':\n\t\t \n\t\tcp++;\n\t\tlevel = 0;\n\t\twhile (*cp) {\n\t\t    if (*cp == '%') {\n\t\t\tcp++;\n\t\t\tif (*cp == '?')\n\t\t\t    level++;\n\t\t\telse if (*cp == ';') {\n\t\t\t    if (level > 0)\n\t\t\t\tlevel--;\n\t\t\t    else\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    if (*cp)\n\t\t\tcp++;\n\t\t}\n\t\tbreak;\n\n\t    case ';':\n\t\tbreak;\n\n\t    }\t\t\t \n\t}\t\t\t \n\n\tif (*cp == '\\0')\n\t    break;\n\n\tcp++;\n    }\t\t\t\t \n\n    get_space(tps, (size_t) 1);\n    TPS(out_buff)[TPS(out_used)] = '\\0';\n\n    if (TPS(stack_ptr) && !_nc_tparm_err) {\n\tDEBUG(2, (\"tparm: stack has %d item%s on return\",\n\t\t  TPS(stack_ptr),\n\t\t  TPS(stack_ptr) == 1 ? \"\" : \"s\"));\n\t_nc_tparm_err++;\n    }\n\n    T((T_RETURN(\"%s\"), _nc_visbuf(TPS(out_buff))));\n    return (TPS(out_buff));\n}\n\n#if NCURSES_TPARM_VARARGS\n\nNCURSES_EXPORT(char *)\ntparm(const char *string, ...)\n{\n    TPARM_STATE *tps = get_tparm_state(cur_term);\n    TPARM_DATA myData;\n    char *result = NULL;\n\n    _nc_tparm_err = 0;\n#ifdef TRACE\n    tps->tname = \"tparm\";\n#endif  \n\n    if (tparm_setup(cur_term, string, &myData) == OK) {\n\tva_list ap;\n\n\tva_start(ap, string);\n\ttparm_copy_valist(&myData, TRUE, ap);\n\tva_end(ap);\n\n\tresult = tparam_internal(tps, string, &myData);\n    }\n    return result;\n}\n\n#else  \n\nNCURSES_EXPORT(char *)\ntparm(const char *string,\n      TPARM_ARG a1,\n      TPARM_ARG a2,\n      TPARM_ARG a3,\n      TPARM_ARG a4,\n      TPARM_ARG a5,\n      TPARM_ARG a6,\n      TPARM_ARG a7,\n      TPARM_ARG a8,\n      TPARM_ARG a9)\n{\n    TPARM_STATE *tps = get_tparm_state(cur_term);\n    TPARM_DATA myData;\n    char *result = NULL;\n\n    _nc_tparm_err = 0;\n#ifdef TRACE\n    tps->tname = \"tparm\";\n#endif  \n\n    if (tparm_setup(cur_term, string, &myData) == OK) {\n\n\tmyData.param[0] = a1;\n\tmyData.param[1] = a2;\n\tmyData.param[2] = a3;\n\tmyData.param[3] = a4;\n\tmyData.param[4] = a5;\n\tmyData.param[5] = a6;\n\tmyData.param[6] = a7;\n\tmyData.param[7] = a8;\n\tmyData.param[8] = a9;\n\n\tresult = tparam_internal(tps, string, &myData);\n    }\n    return result;\n}\n\n#endif  \n\nNCURSES_EXPORT(char *)\ntiparm(const char *string, ...)\n{\n    TPARM_STATE *tps = get_tparm_state(cur_term);\n    TPARM_DATA myData;\n    char *result = NULL;\n\n    _nc_tparm_err = 0;\n#ifdef TRACE\n    tps->tname = \"tiparm\";\n#endif  \n\n    if (tparm_setup(cur_term, string, &myData) == OK) {\n\tva_list ap;\n\n\tva_start(ap, string);\n\ttparm_copy_valist(&myData, FALSE, ap);\n\tva_end(ap);\n\n\tresult = tparam_internal(tps, string, &myData);\n    }\n    return result;\n}\n\n \nNCURSES_EXPORT(char *)\n_nc_tiparm(int expected, const char *string, ...)\n{\n    TPARM_STATE *tps = get_tparm_state(cur_term);\n    TPARM_DATA myData;\n    char *result = NULL;\n\n    _nc_tparm_err = 0;\n#ifdef TRACE\n    tps->tname = \"_nc_tiparm\";\n#endif  \n\n    if (tparm_setup(cur_term, string, &myData) == OK\n\t&& myData.num_actual <= expected\n\t&& myData.tparm_type == 0) {\n\tva_list ap;\n\n\tva_start(ap, string);\n\ttparm_copy_valist(&myData, FALSE, ap);\n\tva_end(ap);\n\n\tresult = tparam_internal(tps, string, &myData);\n    }\n    return result;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_reset_tparm(TERMINAL *term)\n{\n    TPARM_STATE *tps = get_tparm_state(term);\n    memset(TPS(static_vars), 0, sizeof(TPS(static_vars)));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}