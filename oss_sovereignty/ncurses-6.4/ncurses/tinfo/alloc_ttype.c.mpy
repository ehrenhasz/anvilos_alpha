{
  "module_name": "alloc_ttype.c",
  "hash_id": "e816958bfe69640b9c20ee382e97f4388355bd26bca6e0bccaca883b6bc56014",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/alloc_ttype.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: alloc_ttype.c,v 1.46 2022/09/17 21:44:35 tom Exp $\")\n\n#if NCURSES_XNAMES\n \nstatic int\nmerge_names(char **dst, char **a, int na, char **b, int nb)\n{\n    int n = 0;\n    while (na > 0 && nb > 0) {\n\tint cmp = strcmp(*a, *b);\n\tif (cmp < 0) {\n\t    dst[n++] = *a++;\n\t    na--;\n\t} else if (cmp > 0) {\n\t    dst[n++] = *b++;\n\t    nb--;\n\t} else {\n\t    dst[n++] = *a;\n\t    a++, b++;\n\t    na--, nb--;\n\t}\n    }\n    while (na-- > 0) {\n\tdst[n++] = *a++;\n    }\n    while (nb-- > 0) {\n\tdst[n++] = *b++;\n    }\n    DEBUG(4, (\"merge_names -> %d\", n));\n    return n;\n}\n\nstatic bool\nfind_name(char **table, int item, int length, const char *name)\n{\n    int n;\n    int result = -1;\n\n    for (n = item; n < length; ++n) {\n\tif (!strcmp(table[n], name)) {\n\t    DEBUG(4, (\"found name '%s' @%d\", name, n));\n\t    result = n;\n\t    break;\n\t}\n    }\n    if (result < 0) {\n\tDEBUG(4, (\"did not find name '%s'\", name));\n    }\n    return (result >= 0);\n}\n\n#define EXTEND_NUM(num, ext) \\\n\tDEBUG(4, (\"extending \" #num \" from %d to %d\", \\\n\t to->num, (unsigned short) (to->num + (ext - to->ext)))); \\\n\tto->num = (unsigned short) (to->num + (ext - to->ext))\n\nstatic void\nrealign_data(TERMTYPE2 *to, char **ext_Names,\n\t     int ext_Booleans,\n\t     int ext_Numbers,\n\t     int ext_Strings)\n{\n    int n, m, base;\n    int to_Booleans = to->ext_Booleans;\n    int to_Numbers = to->ext_Numbers;\n    int to_Strings = to->ext_Strings;\n    int to1, to2, from;\n\n    DEBUG(4, (\"realign_data %d/%d/%d vs %d/%d/%d\",\n\t      ext_Booleans,\n\t      ext_Numbers,\n\t      ext_Strings,\n\t      to->ext_Booleans,\n\t      to->ext_Numbers,\n\t      to->ext_Strings));\n\n    if (to->ext_Booleans != ext_Booleans) {\n\tto1 = 0;\n\tto2 = to_Booleans + to1;\n\tfrom = 0;\n\tEXTEND_NUM(num_Booleans, ext_Booleans);\n\tTYPE_REALLOC(NCURSES_SBOOL, to->num_Booleans, to->Booleans);\n\tfor (n = to->ext_Booleans - 1,\n\t     m = ext_Booleans - 1,\n\t     base = to->num_Booleans - (m + 1); m >= 0; m--) {\n\t    if (find_name(to->ext_Names, to1, to2, ext_Names[m + from])) {\n\t\tto->Booleans[base + m] = to->Booleans[base + n--];\n\t    } else {\n\t\tto->Booleans[base + m] = FALSE;\n\t    }\n\t}\n\tto->ext_Booleans = UShort(ext_Booleans);\n    }\n\n    if (to->ext_Numbers != ext_Numbers) {\n\tto1 = to_Booleans;\n\tto2 = to_Numbers + to1;\n\tfrom = ext_Booleans;\n\tEXTEND_NUM(num_Numbers, ext_Numbers);\n\tTYPE_REALLOC(NCURSES_INT2, to->num_Numbers, to->Numbers);\n\tfor (n = to->ext_Numbers - 1,\n\t     m = ext_Numbers - 1,\n\t     base = to->num_Numbers - (m + 1); m >= 0; m--) {\n\t    if (find_name(to->ext_Names, to1, to2, ext_Names[m + from])) {\n\t\tto->Numbers[base + m] = to->Numbers[base + n--];\n\t    } else {\n\t\tto->Numbers[base + m] = ABSENT_NUMERIC;\n\t    }\n\t}\n\tto->ext_Numbers = UShort(ext_Numbers);\n    }\n\n    if (to->ext_Strings != ext_Strings) {\n\tto1 = to_Booleans + to_Numbers;\n\tto2 = to_Strings + to1;\n\tfrom = ext_Booleans + ext_Numbers;\n\tEXTEND_NUM(num_Strings, ext_Strings);\n\tTYPE_REALLOC(char *, to->num_Strings, to->Strings);\n\tfor (n = to->ext_Strings - 1,\n\t     m = ext_Strings - 1,\n\t     base = to->num_Strings - (m + 1); m >= 0; m--) {\n\t    if (find_name(to->ext_Names, to1, to2, ext_Names[m + from])) {\n\t\tto->Strings[base + m] = to->Strings[base + n--];\n\t    } else {\n\t\tto->Strings[base + m] = ABSENT_STRING;\n\t    }\n\t}\n\tto->ext_Strings = UShort(ext_Strings);\n    }\n}\n\n \nstatic unsigned\n_nc_first_ext_name(TERMTYPE2 *tp, int token_type)\n{\n    unsigned first;\n\n    switch (token_type) {\n    case BOOLEAN:\n\tfirst = 0;\n\tbreak;\n    case NUMBER:\n\tfirst = tp->ext_Booleans;\n\tbreak;\n    case STRING:\n\tfirst = (unsigned) (tp->ext_Booleans + tp->ext_Numbers);\n\tbreak;\n    default:\n\tfirst = 0;\n\tbreak;\n    }\n    return first;\n}\n\n \nstatic unsigned\n_nc_last_ext_name(TERMTYPE2 *tp, int token_type)\n{\n    unsigned last;\n\n    switch (token_type) {\n    case BOOLEAN:\n\tlast = tp->ext_Booleans;\n\tbreak;\n    case NUMBER:\n\tlast = (unsigned) (tp->ext_Booleans + tp->ext_Numbers);\n\tbreak;\n    default:\n    case STRING:\n\tlast = NUM_EXT_NAMES(tp);\n\tbreak;\n    }\n    return last;\n}\n\n \nstatic int\n_nc_find_ext_name(TERMTYPE2 *tp, char *name, int token_type)\n{\n    unsigned j;\n    unsigned first = _nc_first_ext_name(tp, token_type);\n    unsigned last = _nc_last_ext_name(tp, token_type);\n\n    for (j = first; j < last; j++) {\n\tif (!strcmp(name, tp->ext_Names[j])) {\n\t    return (int) j;\n\t}\n    }\n    return -1;\n}\n\n \nstatic int\n_nc_ext_data_index(TERMTYPE2 *tp, int n, int token_type)\n{\n    switch (token_type) {\n    case BOOLEAN:\n\tn += (tp->num_Booleans - tp->ext_Booleans);\n\tbreak;\n    case NUMBER:\n\tn += (tp->num_Numbers - tp->ext_Numbers)\n\t    - (tp->ext_Booleans);\n\tbreak;\n    default:\n    case STRING:\n\tn += (tp->num_Strings - tp->ext_Strings)\n\t    - (tp->ext_Booleans + tp->ext_Numbers);\n    }\n    return n;\n}\n\n \nstatic bool\n_nc_del_ext_name(TERMTYPE2 *tp, char *name, int token_type)\n{\n    int first;\n\n    if ((first = _nc_find_ext_name(tp, name, token_type)) >= 0) {\n\tint j;\n\tint last = (int) NUM_EXT_NAMES(tp) - 1;\n\n\tfor (j = first; j < last; j++) {\n\t    tp->ext_Names[j] = tp->ext_Names[j + 1];\n\t}\n\tfirst = _nc_ext_data_index(tp, first, token_type);\n\tswitch (token_type) {\n\tcase BOOLEAN:\n\t    last = tp->num_Booleans - 1;\n\t    for (j = first; j < last; j++)\n\t\ttp->Booleans[j] = tp->Booleans[j + 1];\n\t    tp->ext_Booleans--;\n\t    tp->num_Booleans--;\n\t    break;\n\tcase NUMBER:\n\t    last = tp->num_Numbers - 1;\n\t    for (j = first; j < last; j++)\n\t\ttp->Numbers[j] = tp->Numbers[j + 1];\n\t    tp->ext_Numbers--;\n\t    tp->num_Numbers--;\n\t    break;\n\tcase STRING:\n\t    last = tp->num_Strings - 1;\n\t    for (j = first; j < last; j++)\n\t\ttp->Strings[j] = tp->Strings[j + 1];\n\t    tp->ext_Strings--;\n\t    tp->num_Strings--;\n\t    break;\n\t}\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n \nstatic int\n_nc_ins_ext_name(TERMTYPE2 *tp, char *name, int token_type)\n{\n    unsigned first = _nc_first_ext_name(tp, token_type);\n    unsigned last = _nc_last_ext_name(tp, token_type);\n    unsigned total = NUM_EXT_NAMES(tp) + 1;\n    unsigned j, k;\n\n    for (j = first; j < last; j++) {\n\tint cmp = strcmp(name, tp->ext_Names[j]);\n\tif (cmp == 0)\n\t     \n\t    return _nc_ext_data_index(tp, (int) j, token_type);\n\tif (cmp < 0) {\n\t    break;\n\t}\n    }\n\n    TYPE_REALLOC(char *, total, tp->ext_Names);\n    for (k = total - 1; k > j; k--)\n\ttp->ext_Names[k] = tp->ext_Names[k - 1];\n    tp->ext_Names[j] = name;\n    j = (unsigned) _nc_ext_data_index(tp, (int) j, token_type);\n\n    switch (token_type) {\n    case BOOLEAN:\n\ttp->ext_Booleans++;\n\ttp->num_Booleans++;\n\tTYPE_REALLOC(NCURSES_SBOOL, tp->num_Booleans, tp->Booleans);\n\tfor (k = (unsigned) (tp->num_Booleans - 1); k > j; k--)\n\t    tp->Booleans[k] = tp->Booleans[k - 1];\n\tbreak;\n    case NUMBER:\n\ttp->ext_Numbers++;\n\ttp->num_Numbers++;\n\tTYPE_REALLOC(NCURSES_INT2, tp->num_Numbers, tp->Numbers);\n\tfor (k = (unsigned) (tp->num_Numbers - 1); k > j; k--)\n\t    tp->Numbers[k] = tp->Numbers[k - 1];\n\tbreak;\n    case STRING:\n\ttp->ext_Strings++;\n\ttp->num_Strings++;\n\tTYPE_REALLOC(char *, tp->num_Strings, tp->Strings);\n\tfor (k = (unsigned) (tp->num_Strings - 1); k > j; k--)\n\t    tp->Strings[k] = tp->Strings[k - 1];\n\tbreak;\n    }\n    return (int) j;\n}\n\n \nstatic void\nadjust_cancels(TERMTYPE2 *to, TERMTYPE2 *from)\n{\n    int first = to->ext_Booleans + to->ext_Numbers;\n    int last = first + to->ext_Strings;\n    int j, k;\n\n    DEBUG(3, (T_CALLED(\"adjust_cancels(%s), from(%s)\"),\n\t      to ? NonNull(to->term_names) : \"?\",\n\t      from ? NonNull(from->term_names) : \"?\"));\n    for (j = first; j < last;) {\n\tchar *name = to->ext_Names[j];\n\tint j_str = to->num_Strings - first - to->ext_Strings;\n\n\tif (to->Strings[j + j_str] == CANCELLED_STRING) {\n\t    if (_nc_find_ext_name(from, to->ext_Names[j], BOOLEAN) >= 0) {\n\t\tif (_nc_del_ext_name(to, name, STRING)\n\t\t    || _nc_del_ext_name(to, name, NUMBER)) {\n\t\t    k = _nc_ins_ext_name(to, name, BOOLEAN);\n\t\t    to->Booleans[k] = FALSE;\n\t\t} else {\n\t\t    j++;\n\t\t}\n\t    } else if (_nc_find_ext_name(from, to->ext_Names[j], NUMBER) >= 0) {\n\t\tif (_nc_del_ext_name(to, name, STRING)\n\t\t    || _nc_del_ext_name(to, name, BOOLEAN)) {\n\t\t    k = _nc_ins_ext_name(to, name, NUMBER);\n\t\t    to->Numbers[k] = CANCELLED_NUMERIC;\n\t\t} else {\n\t\t    j++;\n\t\t}\n\t    } else if (_nc_find_ext_name(from, to->ext_Names[j], STRING) >= 0) {\n\t\tif (_nc_del_ext_name(to, name, NUMBER)\n\t\t    || _nc_del_ext_name(to, name, BOOLEAN)) {\n\t\t    k = _nc_ins_ext_name(to, name, STRING);\n\t\t    to->Strings[k] = CANCELLED_STRING;\n\t\t} else {\n\t\t    j++;\n\t\t}\n\t    } else {\n\t\tj++;\n\t    }\n\t} else {\n\t    j++;\n\t}\n    }\n    DEBUG(3, (T_RETURN(\"\")));\n}\n\nNCURSES_EXPORT(void)\n_nc_align_termtype(TERMTYPE2 *to, TERMTYPE2 *from)\n{\n    int na;\n    int nb;\n    char **ext_Names;\n\n    na = to ? ((int) NUM_EXT_NAMES(to)) : 0;\n    nb = from ? ((int) NUM_EXT_NAMES(from)) : 0;\n\n    DEBUG(2, (T_CALLED(\"_nc_align_termtype to(%d:%s), from(%d:%s)\"),\n\t      na, to ? NonNull(to->term_names) : \"?\",\n\t      nb, from ? NonNull(from->term_names) : \"?\"));\n\n    if (to != NULL && from != NULL && (na != 0 || nb != 0)) {\n\tint ext_Booleans, ext_Numbers, ext_Strings;\n\tbool used_ext_Names = FALSE;\n\n\tif ((na == nb)\t\t \n\t    &&(to->ext_Booleans == from->ext_Booleans)\n\t    && (to->ext_Numbers == from->ext_Numbers)\n\t    && (to->ext_Strings == from->ext_Strings)) {\n\t    int n;\n\t    bool same;\n\n\t    for (n = 0, same = TRUE; n < na; n++) {\n\t\tif (strcmp(to->ext_Names[n], from->ext_Names[n])) {\n\t\t    same = FALSE;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (same) {\n\t\tDEBUG(2, (T_RETURN(\"\")));\n\t\treturn;\n\t    }\n\t}\n\t \n\tTYPE_MALLOC(char *, (size_t)(na + nb), ext_Names);\n\n\tif (to->ext_Strings && (from->ext_Booleans + from->ext_Numbers))\n\t    adjust_cancels(to, from);\n\n\tif (from->ext_Strings && (to->ext_Booleans + to->ext_Numbers))\n\t    adjust_cancels(from, to);\n\n\text_Booleans = merge_names(ext_Names,\n\t\t\t\t   to->ext_Names,\n\t\t\t\t   to->ext_Booleans,\n\t\t\t\t   from->ext_Names,\n\t\t\t\t   from->ext_Booleans);\n\text_Numbers = merge_names(ext_Names + ext_Booleans,\n\t\t\t\t  to->ext_Names\n\t\t\t\t  + to->ext_Booleans,\n\t\t\t\t  to->ext_Numbers,\n\t\t\t\t  from->ext_Names\n\t\t\t\t  + from->ext_Booleans,\n\t\t\t\t  from->ext_Numbers);\n\text_Strings = merge_names(ext_Names + ext_Numbers + ext_Booleans,\n\t\t\t\t  to->ext_Names\n\t\t\t\t  + to->ext_Booleans\n\t\t\t\t  + to->ext_Numbers,\n\t\t\t\t  to->ext_Strings,\n\t\t\t\t  from->ext_Names\n\t\t\t\t  + from->ext_Booleans\n\t\t\t\t  + from->ext_Numbers,\n\t\t\t\t  from->ext_Strings);\n\t \n\tif (na != (ext_Booleans + ext_Numbers + ext_Strings)) {\n\t    realign_data(to, ext_Names, ext_Booleans, ext_Numbers, ext_Strings);\n\t    FreeIfNeeded(to->ext_Names);\n\t    to->ext_Names = ext_Names;\n\t    DEBUG(2, (\"realigned %d extended names for '%s' (to)\",\n\t\t      NUM_EXT_NAMES(to), to->term_names));\n\t    used_ext_Names = TRUE;\n\t}\n\tif (nb != (ext_Booleans + ext_Numbers + ext_Strings)) {\n\t    nb = (ext_Booleans + ext_Numbers + ext_Strings);\n\t    realign_data(from, ext_Names, ext_Booleans, ext_Numbers, ext_Strings);\n\t    TYPE_REALLOC(char *, (size_t) nb, from->ext_Names);\n\t    memcpy(from->ext_Names, ext_Names, sizeof(char *) * (size_t) nb);\n\t    DEBUG(2, (\"realigned %d extended names for '%s' (from)\",\n\t\t      NUM_EXT_NAMES(from), from->term_names));\n\t}\n\tif (!used_ext_Names)\n\t    free(ext_Names);\n    }\n    DEBUG(2, (T_RETURN(\"\")));\n}\n#endif\n\n#define srcINT 1\n#define dstINT 2\n\n \nstatic void\ncopy_termtype(TERMTYPE2 *dst, const TERMTYPE2 *src, int mode)\n{\n    unsigned i;\n    int pass;\n    char *new_table;\n#if NCURSES_EXT_NUMBERS\n    short *oldptr = 0;\n    int *newptr = 0;\n#endif\n\n    DEBUG(2, (T_CALLED(\"copy_termtype(dst=%p, src=%p, mode=%d)\"), (void *)\n\t      dst, (const void *) src, mode));\n    *dst = *src;\t\t \n\n    TYPE_MALLOC(NCURSES_SBOOL, NUM_BOOLEANS(dst), dst->Booleans);\n    TYPE_MALLOC(char *, NUM_STRINGS(dst), dst->Strings);\n\n    memcpy(dst->Booleans,\n\t   src->Booleans,\n\t   NUM_BOOLEANS(dst) * sizeof(dst->Booleans[0]));\n    memcpy(dst->Strings,\n\t   src->Strings,\n\t   NUM_STRINGS(dst) * sizeof(dst->Strings[0]));\n\n    new_table = NULL;\n    for (pass = 0; pass < 2; ++pass) {\n\tsize_t str_size = 0;\n\tif (src->term_names != NULL) {\n\t    if (pass) {\n\t\tdst->term_names = new_table + str_size;\n\t\tstrcpy(dst->term_names + str_size, src->term_names);\n\t    }\n\t    str_size += strlen(src->term_names) + 1;\n\t}\n\tfor_each_string(i, src) {\n\t    if (VALID_STRING(src->Strings[i])) {\n\t\tif (pass) {\n\t\t    strcpy(new_table + str_size, src->Strings[i]);\n\t\t    dst->Strings[i] = new_table + str_size;\n\t\t}\n\t\tstr_size += strlen(src->Strings[i]) + 1;\n\t    }\n\t}\n\tif (pass) {\n\t    dst->str_table = new_table;\n\t} else {\n\t    ++str_size;\n\t    if ((new_table = malloc(str_size)) == NULL)\n\t\t_nc_err_abort(MSG_NO_MEMORY);\n\t}\n    }\n\n#if NCURSES_EXT_NUMBERS\n    if ((mode & dstINT) == 0) {\n\tDEBUG(2, (\"...convert int ->short\"));\n\tTYPE_MALLOC(short, NUM_NUMBERS(dst), oldptr);\n\t((TERMTYPE *) dst)->Numbers = oldptr;\n    } else {\n\tDEBUG(2, (\"...copy without changing size\"));\n\tTYPE_MALLOC(int, NUM_NUMBERS(dst), newptr);\n\tdst->Numbers = newptr;\n    }\n    if ((mode == srcINT) && (oldptr != 0)) {\n\tDEBUG(2, (\"...copy int ->short\"));\n\tfor (i = 0; i < NUM_NUMBERS(dst); ++i) {\n\t    if (src->Numbers[i] > MAX_OF_TYPE(short)) {\n\t\toldptr[i] = MAX_OF_TYPE(short);\n\t    } else {\n\t\toldptr[i] = (short) src->Numbers[i];\n\t    }\n\t}\n    } else if ((mode == dstINT) && (newptr != 0)) {\n\tDEBUG(2, (\"...copy short ->int\"));\n\tfor (i = 0; i < NUM_NUMBERS(dst); ++i) {\n\t    newptr[i] = ((const short *) (src->Numbers))[i];\n\t}\n    } else {\n\tDEBUG(2, (\"...copy %s without change\",\n\t\t  (mode & dstINT)\n\t\t  ? \"int\"\n\t\t  : \"short\"));\n\tmemcpy(dst->Numbers,\n\t       src->Numbers,\n\t       NUM_NUMBERS(dst) * ((mode & dstINT)\n\t\t\t\t   ? sizeof(int)\n\t\t\t\t   : sizeof(short)));\n    }\n#else\n    (void) mode;\n    TYPE_MALLOC(short, NUM_NUMBERS(dst), dst->Numbers);\n    memcpy(dst->Numbers,\n\t   src->Numbers,\n\t   NUM_NUMBERS(dst) * sizeof(dst->Numbers[0]));\n#endif\n\n#if NCURSES_XNAMES\n    if ((i = NUM_EXT_NAMES(src)) != 0) {\n\tTYPE_MALLOC(char *, i, dst->ext_Names);\n\tmemcpy(dst->ext_Names, src->ext_Names, i * sizeof(char *));\n\n\tnew_table = NULL;\n\tfor (pass = 0; pass < 2; ++pass) {\n\t    size_t str_size = 0;\n\t    char *raw_data = src->ext_str_table;\n\t    if (raw_data != NULL) {\n\t\tfor (i = 0; i < src->ext_Strings; ++i) {\n\t\t    size_t skip = strlen(raw_data) + 1;\n\t\t    if (skip != 1) {\n\t\t\tif (pass) {\n\t\t\t    strcpy(new_table + str_size, raw_data);\n\t\t\t}\n\t\t\tstr_size += skip;\n\t\t\traw_data += skip;\n\t\t    }\n\t\t}\n\t    }\n\t    for (i = 0; i < NUM_EXT_NAMES(dst); ++i) {\n\t\tif (VALID_STRING(src->ext_Names[i])) {\n\t\t    if (pass) {\n\t\t\tstrcpy(new_table + str_size, src->ext_Names[i]);\n\t\t\tdst->ext_Names[i] = new_table + str_size;\n\t\t    }\n\t\t    str_size += strlen(src->ext_Names[i]) + 1;\n\t\t}\n\t    }\n\t    if (pass) {\n\t\tdst->ext_str_table = new_table;\n\t    } else {\n\t\t++str_size;\n\t\tif ((new_table = calloc(str_size, 1)) == NULL)\n\t\t    _nc_err_abort(MSG_NO_MEMORY);\n\t    }\n\t}\n    } else {\n\tdst->ext_Names = 0;\n    }\n#endif\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\n \nNCURSES_EXPORT(void)\n_nc_copy_termtype(TERMTYPE *dst, const TERMTYPE *src)\n{\n    DEBUG(2, (T_CALLED(\"_nc_copy_termtype(dst=%p, src=%p)\"), (void *) dst,\n\t      (const void *) src));\n    copy_termtype((TERMTYPE2 *) dst, (const TERMTYPE2 *) src, 0);\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\n#if NCURSES_EXT_NUMBERS\nNCURSES_EXPORT(void)\n_nc_copy_termtype2(TERMTYPE2 *dst, const TERMTYPE2 *src)\n{\n    DEBUG(2, (T_CALLED(\"_nc_copy_termtype2(dst=%p, src=%p)\"), (void *) dst,\n\t      (const void *) src));\n    copy_termtype(dst, src, srcINT | dstINT);\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\n \nNCURSES_EXPORT(void)\n_nc_export_termtype2(TERMTYPE *dst, const TERMTYPE2 *src)\n{\n    DEBUG(2, (T_CALLED(\"_nc_export_termtype2(dst=%p, src=%p)\"), (void *)\n\t      dst, (const void *) src));\n    copy_termtype((TERMTYPE2 *) dst, src, srcINT);\n    DEBUG(2, (T_RETURN(\"\")));\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}