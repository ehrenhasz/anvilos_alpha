{
  "module_name": "read_termcap.c",
  "hash_id": "7db86acf1f81429e44a8f1318d1bef541b7b3c03725978513ac22f635ff60b93",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/read_termcap.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <sys/types.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: read_termcap.c,v 1.102 2021/09/04 10:29:15 tom Exp $\")\n\n#if !PURE_TERMINFO\n\n#define TC_SUCCESS     0\n#define TC_NOT_FOUND  -1\n#define TC_SYS_ERR    -2\n#define TC_REF_LOOP   -3\n#define TC_UNRESOLVED -4\t \n\nstatic const char *\nget_termpath(void)\n{\n    const char *result;\n\n    if (!use_terminfo_vars() || (result = getenv(\"TERMPATH\")) == 0)\n\tresult = TERMPATH;\n    TR(TRACE_DATABASE, (\"TERMPATH is %s\", result));\n    return result;\n}\n\n \n#if USE_GETCAP\n\n#if HAVE_BSD_CGETENT\n#define _nc_cgetcap   cgetcap\n#define _nc_cgetent(buf, oline, db_array, name) cgetent(buf, db_array, name)\n#define _nc_cgetmatch cgetmatch\n#define _nc_cgetset   cgetset\n#else\nstatic int _nc_cgetmatch(char *, const char *);\nstatic int _nc_getent(char **, unsigned *, int *, int, char **, int, const char\n\t\t      *, int, char *);\nstatic int _nc_nfcmp(const char *, char *);\n\n \n\n \n\n#define\tBFRAG\t\t1024\n#define\tBSIZE\t\t1024\n#define\tMAX_RECURSION\t32\t \n\nstatic size_t topreclen;\t \nstatic char *toprec;\t\t \nstatic int gottoprec;\t\t \n\n \nstatic int\n_nc_cgetset(const char *ent)\n{\n    if (ent == 0) {\n\tFreeIfNeeded(toprec);\n\ttoprec = 0;\n\ttopreclen = 0;\n\treturn (0);\n    }\n    topreclen = strlen(ent);\n    if ((toprec = typeMalloc(char, topreclen + 1)) == 0) {\n\terrno = ENOMEM;\n\treturn (-1);\n    }\n    gottoprec = 0;\n    _nc_STRCPY(toprec, ent, topreclen);\n    return (0);\n}\n\n \nstatic char *\n_nc_cgetcap(char *buf, const char *cap, int type)\n{\n    register const char *cp;\n    register char *bp;\n\n    bp = buf;\n    for (;;) {\n\t \n\tfor (;;) {\n\t    if (*bp == '\\0')\n\t\treturn (0);\n\t    else if (*bp++ == ':')\n\t\tbreak;\n\t}\n\n\t \n\tfor (cp = cap; *cp == *bp && *bp != '\\0'; cp++, bp++)\n\t    continue;\n\tif (*cp != '\\0')\n\t    continue;\n\tif (*bp == '@')\n\t    return (0);\n\tif (type == ':') {\n\t    if (*bp != '\\0' && *bp != ':')\n\t\tcontinue;\n\t    return (bp);\n\t}\n\tif (*bp != type)\n\t    continue;\n\tbp++;\n\treturn (*bp == '@' ? 0 : bp);\n    }\n     \n}\n\n \nstatic int\n_nc_cgetent(char **buf, int *oline, char **db_array, const char *name)\n{\n    unsigned dummy;\n\n    return (_nc_getent(buf, &dummy, oline, 0, db_array, -1, name, 0, 0));\n}\n\n \n#define DOALLOC(size) typeRealloc(char, size, record)\nstatic int\n_nc_getent(\n\t      char **cap,\t \n\t      unsigned *len,\t \n\t      int *beginning,\t \n\t      int in_array,\t \n\t      char **db_array,\t \n\t      int fd,\n\t      const char *name,\n\t      int depth,\n\t      char *nfield)\n{\n    register char *r_end, *rp;\n    int myfd = FALSE;\n    char *record = 0;\n    int tc_not_resolved;\n    int current;\n    int lineno;\n\n     \n    if (depth > MAX_RECURSION)\n\treturn (TC_REF_LOOP);\n\n     \n    if (depth == 0 && toprec != 0 && _nc_cgetmatch(toprec, name) == 0) {\n\tif ((record = DOALLOC(topreclen + BFRAG)) == 0) {\n\t    errno = ENOMEM;\n\t    return (TC_SYS_ERR);\n\t}\n\t_nc_STRCPY(record, toprec, topreclen + BFRAG);\n\trp = record + topreclen + 1;\n\tr_end = rp + BFRAG;\n\tcurrent = in_array;\n    } else {\n\tint foundit;\n\n\t \n\tif ((record = DOALLOC(BFRAG)) == 0) {\n\t    errno = ENOMEM;\n\t    return (TC_SYS_ERR);\n\t}\n\trp = r_end = record + BFRAG;\n\tfoundit = FALSE;\n\n\t \n\tfor (current = in_array; db_array[current] != 0; current++) {\n\t    int eof = FALSE;\n\n\t     \n\t    if (fd >= 0) {\n\t\t(void) lseek(fd, (off_t) 0, SEEK_SET);\n\t    } else if ((_nc_access(db_array[current], R_OK) < 0)\n\t\t       || (fd = open(db_array[current], O_RDONLY, 0)) < 0) {\n\t\t \n\t\tif (errno == ENOENT)\n\t\t    continue;\n\t\tfree(record);\n\t\treturn (TC_SYS_ERR);\n\t    } else {\n\t\tmyfd = TRUE;\n\t    }\n\t    lineno = 0;\n\n\t     \n\t    {\n\t\tchar buf[2048];\n\t\tregister char *b_end = buf;\n\t\tregister char *bp = buf;\n\t\tregister int c;\n\n\t\t \n\n\t\tfor (;;) {\n\t\t    int first = lineno + 1;\n\n\t\t     \n\t\t    rp = record;\n\t\t    for (;;) {\n\t\t\tif (bp >= b_end) {\n\t\t\t    int n;\n\n\t\t\t    n = (int) read(fd, buf, sizeof(buf));\n\t\t\t    if (n <= 0) {\n\t\t\t\tif (myfd)\n\t\t\t\t    (void) close(fd);\n\t\t\t\tif (n < 0) {\n\t\t\t\t    free(record);\n\t\t\t\t    return (TC_SYS_ERR);\n\t\t\t\t}\n\t\t\t\tfd = -1;\n\t\t\t\teof = TRUE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    b_end = buf + n;\n\t\t\t    bp = buf;\n\t\t\t}\n\n\t\t\tc = *bp++;\n\t\t\tif (c == '\\n') {\n\t\t\t    lineno++;\n\t\t\t     \n\t\t\t    if (rp == record\n\t\t\t\t|| *record == '#'\n\t\t\t\t|| *(rp - 1) != '\\\\')\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*rp++ = (char) c;\n\n\t\t\t \n\t\t\tif (rp >= r_end) {\n\t\t\t    unsigned pos;\n\t\t\t    size_t newsize;\n\n\t\t\t    pos = (unsigned) (rp - record);\n\t\t\t    newsize = (size_t) (r_end - record + BFRAG);\n\t\t\t    record = DOALLOC(newsize);\n\t\t\t    if (record == 0) {\n\t\t\t\tif (myfd)\n\t\t\t\t    (void) close(fd);\n\t\t\t\terrno = ENOMEM;\n\t\t\t\treturn (TC_SYS_ERR);\n\t\t\t    }\n\t\t\t    r_end = record + newsize;\n\t\t\t    rp = record + pos;\n\t\t\t}\n\t\t    }\n\t\t     \n\t\t    *rp++ = '\\0';\n\n\t\t     \n\t\t    if (eof)\n\t\t\tbreak;\n\n\t\t     \n\t\t    if (*record == '\\0' || *record == '#')\n\t\t\tcontinue;\n\n\t\t     \n\t\t    if (_nc_cgetmatch(record, name) == 0\n\t\t\t&& (nfield == 0\n\t\t\t    || !_nc_nfcmp(nfield, record))) {\n\t\t\tfoundit = TRUE;\n\t\t\t*beginning = first;\n\t\t\tbreak;\t \n\t\t    }\n\t\t}\n\t    }\n\t    if (foundit)\n\t\tbreak;\n\t}\n\n\tif (!foundit) {\n\t    free(record);\n\t    return (TC_NOT_FOUND);\n\t}\n    }\n\n     \n    {\n\tregister char *newicap, *s;\n\tregister int newilen;\n\tunsigned ilen;\n\tint diff, iret, tclen, oline;\n\tchar *icap = 0, *scan, *tc, *tcstart, *tcend;\n\n\t \n\tscan = record;\n\ttc_not_resolved = FALSE;\n\tfor (;;) {\n\t    if ((tc = _nc_cgetcap(scan, \"tc\", '=')) == 0) {\n\t\tbreak;\n\t    }\n\n\t     \n\t    s = tc;\n\t    while (*s != '\\0') {\n\t\tif (*s++ == ':') {\n\t\t    *(s - 1) = '\\0';\n\t\t    break;\n\t\t}\n\t    }\n\t    tcstart = tc - 3;\n\t    tclen = (int) (s - tcstart);\n\t    tcend = s;\n\n\t    icap = 0;\n\t    iret = _nc_getent(&icap, &ilen, &oline, current, db_array, fd,\n\t\t\t      tc, depth + 1, 0);\n\t    newicap = icap;\t \n\t    newilen = (int) ilen;\n\t    if (iret != TC_SUCCESS) {\n\t\t \n\t\tif (iret < TC_NOT_FOUND) {\n\t\t    if (myfd)\n\t\t\t(void) close(fd);\n\t\t    free(record);\n\t\t    FreeIfNeeded(icap);\n\t\t    return (iret);\n\t\t}\n\t\tif (iret == TC_UNRESOLVED) {\n\t\t    tc_not_resolved = TRUE;\n\t\t     \n\t\t} else if (iret == TC_NOT_FOUND) {\n\t\t    *(s - 1) = ':';\n\t\t    scan = s - 1;\n\t\t    tc_not_resolved = TRUE;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t     \n\t    s = newicap;\n\t    while (*s != '\\0' && *s++ != ':') ;\n\t    newilen -= (int) (s - newicap);\n\t    newicap = s;\n\n\t     \n\t    s += newilen;\n\t    if (*(s - 1) != ':') {\n\t\t*s = ':';\t \n\t\tnewilen++;\n\t    }\n\n\t     \n\t    diff = newilen - tclen;\n\t    if (diff >= r_end - rp) {\n\t\tunsigned pos, tcpos, tcposend;\n\t\tsize_t newsize;\n\n\t\tpos = (unsigned) (rp - record);\n\t\tnewsize = (size_t) (r_end - record + diff + BFRAG);\n\t\ttcpos = (unsigned) (tcstart - record);\n\t\ttcposend = (unsigned) (tcend - record);\n\t\trecord = DOALLOC(newsize);\n\t\tif (record == 0) {\n\t\t    if (myfd)\n\t\t\t(void) close(fd);\n\t\t    free(icap);\n\t\t    errno = ENOMEM;\n\t\t    return (TC_SYS_ERR);\n\t\t}\n\t\tr_end = record + newsize;\n\t\trp = record + pos;\n\t\ttcstart = record + tcpos;\n\t\ttcend = record + tcposend;\n\t    }\n\n\t     \n\t    s = tcstart + newilen;\n\t    memmove(s, tcend, (size_t) (rp - tcend));\n\t    memmove(tcstart, newicap, (size_t) newilen);\n\t    rp += diff;\n\t    free(icap);\n\n\t     \n\t    scan = s - 1;\n\t}\n    }\n\n     \n    if (myfd)\n\t(void) close(fd);\n    *len = (unsigned) (rp - record - 1);\t \n    if (r_end > rp) {\n\tif ((record = DOALLOC((size_t) (rp - record))) == 0) {\n\t    errno = ENOMEM;\n\t    return (TC_SYS_ERR);\n\t}\n    }\n\n    *cap = record;\n    if (tc_not_resolved) {\n\treturn (TC_UNRESOLVED);\n    }\n    return (current);\n}\n\n \nstatic int\n_nc_cgetmatch(char *buf, const char *name)\n{\n    register const char *np;\n    register char *bp;\n\n     \n    bp = buf;\n    for (;;) {\n\t \n\tnp = name;\n\tfor (;;) {\n\t    if (*np == '\\0') {\n\t\tif (*bp == '|' || *bp == ':' || *bp == '\\0')\n\t\t    return (0);\n\t\telse\n\t\t    break;\n\t    } else if (*bp++ != *np++) {\n\t\tbreak;\n\t    }\n\t}\n\n\t \n\tbp--;\t\t\t \n\tfor (;;) {\n\t    if (*bp == '\\0' || *bp == ':')\n\t\treturn (-1);\t \n\t    else if (*bp++ == '|')\n\t\tbreak;\t\t \n\t}\n    }\n}\n\n \nstatic int\n_nc_nfcmp(const char *nf, char *rec)\n{\n    char *cp, tmp;\n    int ret;\n\n    for (cp = rec; *cp != ':'; cp++) ;\n\n    tmp = *(cp + 1);\n    *(cp + 1) = '\\0';\n    ret = strcmp(nf, rec);\n    *(cp + 1) = tmp;\n\n    return (ret);\n}\n#endif  \n\n \n#define USE_BSD_TGETENT 1\n\n#if USE_BSD_TGETENT\n \n\n \n\n#define\tPBUFSIZ\t\t512\t \n#define\tPVECSIZ\t\t32\t \n#define TBUFSIZ (2048*2)\n\n \nstatic char *\nget_tc_token(char **srcp, int *endp)\n{\n    int ch;\n    bool found = FALSE;\n    char *s, *base;\n    char *tok = 0;\n\n    *endp = TRUE;\n    for (s = base = *srcp; *s != '\\0';) {\n\tch = *s++;\n\tif (ch == '\\\\') {\n\t    if (*s == '\\0') {\n\t\tbreak;\n\t    } else if (*s++ == '\\n') {\n\t\twhile (isspace(UChar(*s)))\n\t\t    s++;\n\t    } else {\n\t\tfound = TRUE;\n\t    }\n\t} else if (ch == ':') {\n\t    if (found) {\n\t\ttok = base;\n\t\ts[-1] = '\\0';\n\t\t*srcp = s;\n\t\t*endp = FALSE;\n\t\tbreak;\n\t    }\n\t    base = s;\n\t} else if (isgraph(UChar(ch))) {\n\t    found = TRUE;\n\t}\n    }\n\n     \n    if (tok == 0 && found) {\n\ttok = base;\n    }\n\n    return tok;\n}\n\nstatic char *\ncopy_tc_token(char *dst, const char *src, size_t len)\n{\n    int ch;\n\n    while ((ch = *src++) != '\\0') {\n\tif (ch == '\\\\' && *src == '\\n') {\n\t    while (isspace(UChar(*src)))\n\t\tsrc++;\n\t    continue;\n\t}\n\tif (--len == 0) {\n\t    dst = 0;\n\t    break;\n\t}\n\t*dst++ = (char) ch;\n    }\n    return dst;\n}\n\n \nstatic int\n_nc_tgetent(char *bp, char **sourcename, int *lineno, const char *name)\n{\n    static char *the_source;\n\n    register char *p;\n    register char *cp;\n    char *dummy = NULL;\n    CGETENT_CONST char **fname;\n    char *home;\n    int i;\n    char pathbuf[PBUFSIZ];\t \n    CGETENT_CONST char *pathvec[PVECSIZ];\t \n    const char *termpath;\n    string_desc desc;\n\n    *lineno = 1;\n    fname = pathvec;\n    p = pathbuf;\n    cp = use_terminfo_vars()? getenv(\"TERMCAP\") : NULL;\n\n     \n    _nc_str_init(&desc, pathbuf, sizeof(pathbuf));\n    if (cp == NULL) {\n\t_nc_safe_strcpy(&desc, get_termpath());\n    } else if (!_nc_is_abs_path(cp)) {\t \n\tif ((termpath = get_termpath()) != 0) {\n\t    _nc_safe_strcat(&desc, termpath);\n\t} else {\n\t    char temp[PBUFSIZ];\n\t    temp[0] = 0;\n\t    if ((home = getenv(\"HOME\")) != 0 && *home != '\\0'\n\t\t&& strchr(home, ' ') == 0\n\t\t&& strlen(home) < sizeof(temp) - 10) {\t \n\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t    \"%s/\", home);\t \n\t    }\n\t     \n\t    _nc_STRCAT(temp, \".termcap\", sizeof(temp));\n\t    _nc_safe_strcat(&desc, temp);\n\t    _nc_safe_strcat(&desc, \" \");\n\t    _nc_safe_strcat(&desc, get_termpath());\n\t}\n    } else {\t\t\t \n\t_nc_safe_strcat(&desc, cp);\t \n    }\n\n    *fname++ = pathbuf;\t\t \n    while (*++p) {\n\tif (*p == ' ' || *p == NCURSES_PATHSEP) {\n\t    *p = '\\0';\n\t    while (*++p)\n\t\tif (*p != ' ' && *p != NCURSES_PATHSEP)\n\t\t    break;\n\t    if (*p == '\\0')\n\t\tbreak;\n\t    *fname++ = p;\n\t    if (fname >= pathvec + PVECSIZ) {\n\t\tfname--;\n\t\tbreak;\n\t    }\n\t}\n    }\n    *fname = 0;\t\t\t \n#if !HAVE_BSD_CGETENT\n    (void) _nc_cgetset(0);\n#endif\n    if (_nc_is_abs_path(cp)) {\n\tif (_nc_cgetset(cp) < 0) {\n\t    return (TC_SYS_ERR);\n\t}\n    }\n\n    i = _nc_cgetent(&dummy, lineno, pathvec, name);\n\n     \n    *bp = '\\0';\n    if (i >= 0) {\n\tchar *pd, *ps, *tok;\n\tint endflag = FALSE;\n\tchar *list[1023];\n\tsize_t n, count = 0;\n\n\tpd = bp;\n\tps = dummy;\n\twhile (!endflag && (tok = get_tc_token(&ps, &endflag)) != 0) {\n\t    bool ignore = FALSE;\n\n\t    for (n = 1; n < count; n++) {\n\t\tchar *s = list[n];\n\t\tif (s[0] == tok[0]\n\t\t    && s[1] == tok[1]) {\n\t\t    ignore = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (ignore != TRUE) {\n\t\tlist[count++] = tok;\n\t\tpd = copy_tc_token(pd, tok, (size_t) (TBUFSIZ - (2 + pd - bp)));\n\t\tif (pd == 0) {\n\t\t    i = -1;\n\t\t    break;\n\t\t}\n\t\t*pd++ = ':';\n\t\t*pd = '\\0';\n\t    }\n\t}\n    }\n\n    FreeIfNeeded(dummy);\n    FreeIfNeeded(the_source);\n    the_source = 0;\n\n     \n    if (i >= 0) {\n#if HAVE_BSD_CGETENT\n\tchar temp[PATH_MAX];\n\n\t_nc_str_init(&desc, temp, sizeof(temp));\n\t_nc_safe_strcpy(&desc, pathvec[i]);\n\t_nc_safe_strcat(&desc, \".db\");\n\tif (_nc_access(temp, R_OK) == 0) {\n\t    _nc_safe_strcpy(&desc, pathvec[i]);\n\t}\n\tif ((the_source = strdup(temp)) != 0)\n\t    *sourcename = the_source;\n#else\n\tif ((the_source = strdup(pathvec[i])) != 0)\n\t    *sourcename = the_source;\n#endif\n    }\n\n    return (i);\n}\n#endif  \n#endif  \n\n#define MAXPATHS\t32\n\n \n#if !USE_GETCAP\nstatic int\nadd_tc(char *termpaths[], char *path, int count)\n{\n    char *save = strchr(path, NCURSES_PATHSEP);\n    if (save != 0)\n\t*save = '\\0';\n    if (count < MAXPATHS\n\t&& _nc_access(path, R_OK) == 0) {\n\ttermpaths[count++] = path;\n\tTR(TRACE_DATABASE, (\"Adding termpath %s\", path));\n    }\n    termpaths[count] = 0;\n    if (save != 0)\n\t*save = NCURSES_PATHSEP;\n    return count;\n}\n#define ADD_TC(path, count) filecount = add_tc(termpaths, path, count)\n#endif  \n\nNCURSES_EXPORT(int)\n_nc_read_termcap_entry(const char *const tn, TERMTYPE2 *const tp)\n{\n    int found = TGETENT_NO;\n    ENTRY *ep;\n#if USE_GETCAP_CACHE\n    char cwd_buf[PATH_MAX];\n#endif\n#if USE_GETCAP\n    char *p, tc[TBUFSIZ];\n    char *tc_buf = 0;\n#define MY_SIZE sizeof(tc) - 1\n    int status;\n    static char *source;\n    static int lineno;\n\n    TR(TRACE_DATABASE, (\"read termcap entry for %s\", tn));\n\n    if (strlen(tn) == 0\n\t|| strcmp(tn, \".\") == 0\n\t|| strcmp(tn, \"..\") == 0\n\t|| _nc_pathlast(tn) != 0) {\n\tTR(TRACE_DATABASE, (\"illegal or missing entry name '%s'\", tn));\n\treturn TGETENT_NO;\n    }\n\n    if (use_terminfo_vars() && (p = getenv(\"TERMCAP\")) != 0\n\t&& !_nc_is_abs_path(p) && _nc_name_match(p, tn, \"|:\")) {\n\t \n\ttc_buf = strdup(p);\n\t_nc_set_source(\"TERMCAP\");\n    } else {\n\t \n\tif ((status = _nc_tgetent(tc, &source, &lineno, tn)) < 0)\n\t    return (status == TC_NOT_FOUND ? TGETENT_NO : TGETENT_ERR);\n\n\t_nc_curr_line = lineno;\n\t_nc_set_source(source);\n\ttc_buf = tc;\n    }\n    if (tc_buf == 0)\n\treturn (TGETENT_ERR);\n    _nc_read_entry_source((FILE *) 0, tc_buf, FALSE, TRUE, NULLHOOK);\n    if (tc_buf != tc)\n\tfree(tc_buf);\n#else\n     \n    FILE *fp;\n    char *tc, *termpaths[MAXPATHS];\n    int filecount = 0;\n    int j, k;\n    bool use_buffer = FALSE;\n    bool normal = TRUE;\n    char *tc_buf = 0;\n    char pathbuf[PATH_MAX];\n    char *copied = 0;\n    char *cp;\n    struct stat test_stat[MAXPATHS];\n\n    termpaths[filecount] = 0;\n    if (use_terminfo_vars() && (tc = getenv(\"TERMCAP\")) != 0) {\n\tif (_nc_is_abs_path(tc)) {\t \n\t    ADD_TC(tc, 0);\n\t    normal = FALSE;\n\t} else if (_nc_name_match(tc, tn, \"|:\")) {\t \n\t    tc_buf = strdup(tc);\n\t    use_buffer = (tc_buf != 0);\n\t    normal = FALSE;\n\t}\n    }\n\n    if (normal) {\t\t \n\tchar envhome[PATH_MAX], *h;\n\n\tcopied = strdup(get_termpath());\n\tfor (cp = copied; *cp; cp++) {\n\t    if (*cp == NCURSES_PATHSEP)\n\t\t*cp = '\\0';\n\t    else if (cp == copied || cp[-1] == '\\0') {\n\t\tADD_TC(cp, filecount);\n\t    }\n\t}\n\n#define PRIVATE_CAP \"%.*s/.termcap\"\n\n\tif (use_terminfo_vars() && (h = getenv(\"HOME\")) != NULL && *h != '\\0'\n\t    && (strlen(h) + sizeof(PRIVATE_CAP)) < PATH_MAX) {\n\t     \n\t    _nc_STRCPY(envhome, h, sizeof(envhome));\n\t    _nc_SPRINTF(pathbuf, _nc_SLIMIT(sizeof(pathbuf))\n\t\t\tPRIVATE_CAP,\n\t\t\t(int) (sizeof(pathbuf) - sizeof(PRIVATE_CAP)),\n\t\t\tenvhome);\n\t    ADD_TC(pathbuf, filecount);\n\t}\n    }\n\n     \n#if HAVE_LINK\n    for (j = 0; j < filecount; j++) {\n\tbool omit = FALSE;\n\tif (stat(termpaths[j], &test_stat[j]) != 0\n\t    || !S_ISREG(test_stat[j].st_mode)) {\n\t    omit = TRUE;\n\t} else {\n\t    for (k = 0; k < j; k++) {\n\t\tif (test_stat[k].st_dev == test_stat[j].st_dev\n\t\t    && test_stat[k].st_ino == test_stat[j].st_ino) {\n\t\t    omit = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tif (omit) {\n\t    TR(TRACE_DATABASE, (\"Path %s is a duplicate\", termpaths[j]));\n\t    for (k = j + 1; k < filecount; k++) {\n\t\ttermpaths[k - 1] = termpaths[k];\n\t\ttest_stat[k - 1] = test_stat[k];\n\t    }\n\t    --filecount;\n\t    --j;\n\t}\n    }\n#endif\n\n     \n    if (use_buffer) {\n\t_nc_set_source(\"TERMCAP\");\n\n\t \n\t_nc_read_entry_source((FILE *) 0, tc_buf, FALSE, FALSE, NULLHOOK);\n\tfree(tc_buf);\n    } else {\n\tint i;\n\n\tfor (i = 0; i < filecount; i++) {\n\n\t    TR(TRACE_DATABASE, (\"Looking for %s in %s\", tn, termpaths[i]));\n\t    if (_nc_access(termpaths[i], R_OK) == 0\n\t\t&& (fp = safe_fopen(termpaths[i], \"r\")) != (FILE *) 0) {\n\t\t_nc_set_source(termpaths[i]);\n\n\t\t \n\t\t_nc_read_entry_source(fp, (char *) 0, FALSE, TRUE, NULLHOOK);\n\n\t\t(void) fclose(fp);\n\t    }\n\t}\n    }\n    if (copied != 0)\n\tfree(copied);\n#endif  \n\n    if (_nc_head == 0)\n\treturn (TGETENT_ERR);\n\n     \n    if (_nc_resolve_uses2(TRUE, FALSE) != TRUE)\n\treturn (TGETENT_ERR);\n\n     \n#if USE_GETCAP_CACHE\n    if (getcwd(cwd_buf, sizeof(cwd_buf)) != 0) {\n\t_nc_set_writedir((char *) 0);\t \n#endif\n\tfor_entry_list(ep) {\n\t    if (_nc_name_match(ep->tterm.term_names, tn, \"|:\")) {\n\t\t \n\t\t*tp = ep->tterm;\n\t\t_nc_free_entry(_nc_head, &(ep->tterm));\n\n\t\t \n#if USE_GETCAP_CACHE\n\t\t(void) _nc_write_entry(tp);\n#endif\n\t\tfound = TGETENT_YES;\n\t\tbreak;\n\t    }\n\t}\n#if USE_GETCAP_CACHE\n\tchdir(cwd_buf);\n    }\n#endif\n\n    return (found);\n}\n#else\nextern\nNCURSES_EXPORT(void)\n_nc_read_termcap(void);\nNCURSES_EXPORT(void)\n_nc_read_termcap(void)\n{\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}