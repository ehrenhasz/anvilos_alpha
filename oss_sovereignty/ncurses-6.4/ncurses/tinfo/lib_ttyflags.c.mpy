{
  "module_name": "lib_ttyflags.c",
  "hash_id": "5cc47b1117c86497dacc6c578c0584181bc26f2e131949756a4e28b6e63064a3",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_ttyflags.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_ttyflags.c,v 1.36 2020/09/05 22:54:47 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_get_tty_mode) (NCURSES_SP_DCLx TTY * buf)\n{\n    TERMINAL *termp = TerminalOf(SP_PARM);\n    int result = OK;\n\n    if (buf == 0 || termp == 0) {\n\tresult = ERR;\n    } else {\n\n#ifdef USE_TERM_DRIVER\n\tif (SP_PARM != 0) {\n\t    result = CallDriver_2(SP_PARM, td_sgmode, FALSE, buf);\n\t} else {\n\t    result = ERR;\n\t}\n#else\n\tfor (;;) {\n\t    if (GET_TTY(termp->Filedes, buf) != 0) {\n\t\tif (errno == EINTR)\n\t\t    continue;\n\t\tresult = ERR;\n\t    }\n\t    break;\n\t}\n#endif\n\n\tTR(TRACE_BITS, (\"_nc_get_tty_mode(%d): %s\",\n\t\t\ttermp ? termp->Filedes : -1,\n\t\t\t_nc_trace_ttymode(buf)));\n    }\n    if (result == ERR && buf != 0)\n\tmemset(buf, 0, sizeof(*buf));\n\n    return (result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_get_tty_mode(TTY * buf)\n{\n    return NCURSES_SP_NAME(_nc_get_tty_mode) (CURRENT_SCREEN, buf);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_DCLx TTY * buf)\n{\n    int result = OK;\n\n    if (buf == 0 || SP_PARM == 0) {\n\tresult = ERR;\n    } else {\n\tTERMINAL *termp = TerminalOf(SP_PARM);\n\n\tif (0 == termp) {\n\t    result = ERR;\n\t} else {\n#ifdef USE_TERM_DRIVER\n\t    result = CallDriver_2(SP_PARM, td_sgmode, TRUE, buf);\n#else\n\t    for (;;) {\n\t\tif ((SET_TTY(termp->Filedes, buf) != 0)\n#if USE_KLIBC_KBD\n\t\t    && !NC_ISATTY(termp->Filedes)\n#endif\n\t\t    ) {\n\t\t    if (errno == EINTR)\n\t\t\tcontinue;\n\t\t    if ((errno == ENOTTY) && (SP_PARM != 0))\n\t\t\tSP_PARM->_notty = TRUE;\n\t\t    result = ERR;\n\t\t}\n\t\tbreak;\n\t    }\n#endif\n\t}\n\tTR(TRACE_BITS, (\"_nc_set_tty_mode(%d): %s\",\n\t\t\ttermp ? termp->Filedes : -1,\n\t\t\t_nc_trace_ttymode(buf)));\n    }\n    return (result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_set_tty_mode(TTY * buf)\n{\n    return NCURSES_SP_NAME(_nc_set_tty_mode) (CURRENT_SCREEN, buf);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"def_shell_mode(%p) ->term %p\"),\n       (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, FALSE, TRUE);\n#else\n\t \n\tif (_nc_get_tty_mode(&termp->Ottyb) == OK) {\n#ifdef TERMIOS\n\t    if (termp->Ottyb.c_oflag & OFLAGS_TABS)\n\t\ttab = back_tab = NULL;\n#elif defined(EXP_WIN32_DRIVER)\n\t     \n#else\n\t    if (termp->Ottyb.sg_flags & XTABS)\n\t\ttab = back_tab = NULL;\n#endif\n\t    rc = OK;\n\t}\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndef_shell_mode(void)\n{\n    return NCURSES_SP_NAME(def_shell_mode) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"def_prog_mode(%p) ->term %p\"), (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, TRUE, TRUE);\n#else\n\t \n\tif (_nc_get_tty_mode(&termp->Nttyb) == OK) {\n#ifdef TERMIOS\n\t    termp->Nttyb.c_oflag &= (unsigned) (~OFLAGS_TABS);\n#elif defined(EXP_WIN32_DRIVER)\n\t     \n#else\n\t    termp->Nttyb.sg_flags &= (unsigned) (~XTABS);\n#endif\n\t    rc = OK;\n\t}\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\ndef_prog_mode(void)\n{\n    return NCURSES_SP_NAME(def_prog_mode) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(reset_prog_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"reset_prog_mode(%p) ->term %p\"), (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, TRUE, FALSE);\n#else\n\tif (_nc_set_tty_mode(&termp->Nttyb) == OK) {\n\t    if (SP_PARM) {\n\t\tif (SP_PARM->_keypad_on)\n\t\t    _nc_keypad(SP_PARM, TRUE);\n\t    }\n\t    rc = OK;\n\t}\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nreset_prog_mode(void)\n{\n    return NCURSES_SP_NAME(reset_prog_mode) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(reset_shell_mode) (NCURSES_SP_DCL0)\n{\n    int rc = ERR;\n    TERMINAL *termp = TerminalOf(SP_PARM);\n\n    T((T_CALLED(\"reset_shell_mode(%p) ->term %p\"),\n       (void *) SP_PARM, (void *) termp));\n\n    if (termp != 0) {\n#ifdef USE_TERM_DRIVER\n\trc = CallDriver_2(SP_PARM, td_mode, FALSE, FALSE);\n#else\n\tif (SP_PARM) {\n\t    _nc_keypad(SP_PARM, FALSE);\n\t    _nc_flush();\n\t}\n\trc = _nc_set_tty_mode(&termp->Ottyb);\n#endif\n    }\n    returnCode(rc);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nreset_shell_mode(void)\n{\n    return NCURSES_SP_NAME(reset_shell_mode) (CURRENT_SCREEN);\n}\n#endif\n\nstatic TTY *\nsaved_tty(NCURSES_SP_DCL0)\n{\n    TTY *result = 0;\n\n    if (SP_PARM != 0) {\n\tresult = (TTY *) & (SP_PARM->_saved_tty);\n    } else {\n\tif (_nc_prescreen.saved_tty == 0) {\n\t    _nc_prescreen.saved_tty = typeCalloc(TTY, 1);\n\t}\n\tresult = _nc_prescreen.saved_tty;\n    }\n    return result;\n}\n\n \n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(savetty) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"savetty(%p)\"), (void *) SP_PARM));\n    returnCode(NCURSES_SP_NAME(_nc_get_tty_mode) (NCURSES_SP_ARGx saved_tty(NCURSES_SP_ARG)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nsavetty(void)\n{\n    return NCURSES_SP_NAME(savetty) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(resetty) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"resetty(%p)\"), (void *) SP_PARM));\n    returnCode(NCURSES_SP_NAME(_nc_set_tty_mode) (NCURSES_SP_ARGx saved_tty(NCURSES_SP_ARG)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nresetty(void)\n{\n    return NCURSES_SP_NAME(resetty) (CURRENT_SCREEN);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}