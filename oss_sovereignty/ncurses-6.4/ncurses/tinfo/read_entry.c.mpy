{
  "module_name": "read_entry.c",
  "hash_id": "3f4e025a4f8f4848a7f9196d9ec426b9cecdc1568fe04b248f656da643d9e5e2",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/read_entry.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <hashed_db.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: read_entry.c,v 1.164 2022/05/08 00:11:44 tom Exp $\")\n\n#define MyNumber(n) (short) LOW_MSB(n)\n\n#define SIZEOF_32BITS 4\n\n#if NCURSES_USE_DATABASE\n#if NCURSES_EXT_NUMBERS\nstatic size_t\nconvert_16bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i;\n    size_t j;\n    size_t size = SIZEOF_SHORT;\n    for (i = 0; i < count; i++) {\n\tunsigned mask = 0xff;\n\tunsigned char ch = 0;\n\tNumbers[i] = 0;\n\tfor (j = 0; j < size; ++j) {\n\t    ch = UChar(*buf++);\n\t    Numbers[i] |= (ch << (8 * j));\n\t    mask <<= 8;\n\t}\n\tif (ch & 0x80) {\n\t    while (mask != 0) {\n\t\tNumbers[i] |= (int) mask;\n\t\tmask <<= 8;\n\t    }\n\t}\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return size;\n}\n\nstatic size_t\nconvert_32bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i;\n    size_t j;\n    size_t size = SIZEOF_INT2;\n    unsigned char ch;\n\n    assert(sizeof(NCURSES_INT2) == size);\n    for (i = 0; i < count; i++) {\n\tNumbers[i] = 0;\n\tfor (j = 0; j < size; ++j) {\n\t    ch = UChar(*buf++);\n\t    Numbers[i] |= (ch << (8 * j));\n\t}\n\t \n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return size;\n}\n#else\nstatic size_t\nconvert_32bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i, j;\n    unsigned char ch;\n    for (i = 0; i < count; i++) {\n\tint value = 0;\n\tfor (j = 0; j < SIZEOF_32BITS; ++j) {\n\t    ch = UChar(*buf++);\n\t    value |= (ch << (8 * j));\n\t}\n\tif (value == -1)\n\t    Numbers[i] = ABSENT_NUMERIC;\n\telse if (value == -2)\n\t    Numbers[i] = CANCELLED_NUMERIC;\n\telse if (value > MAX_OF_TYPE(NCURSES_INT2))\n\t    Numbers[i] = MAX_OF_TYPE(NCURSES_INT2);\n\telse\n\t    Numbers[i] = (short) value;\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return SIZEOF_SHORT;\n}\n\nstatic size_t\nconvert_16bits(char *buf, NCURSES_INT2 *Numbers, int count)\n{\n    int i;\n    for (i = 0; i < count; i++) {\n\tif (IS_NEG1(buf + 2 * i))\n\t    Numbers[i] = ABSENT_NUMERIC;\n\telse if (IS_NEG2(buf + 2 * i))\n\t    Numbers[i] = CANCELLED_NUMERIC;\n\telse\n\t    Numbers[i] = MyNumber(buf + 2 * i);\n\tTR(TRACE_DATABASE, (\"get Numbers[%d]=%d\", i, Numbers[i]));\n    }\n    return SIZEOF_SHORT;\n}\n#endif\n\nstatic void\nconvert_strings(char *buf, char **Strings, int count, int size, char *table)\n{\n    int i;\n    char *p;\n    bool corrupt = FALSE;\n\n    for (i = 0; i < count; i++) {\n\tif (IS_NEG1(buf + 2 * i)) {\n\t    Strings[i] = ABSENT_STRING;\n\t} else if (IS_NEG2(buf + 2 * i)) {\n\t    Strings[i] = CANCELLED_STRING;\n\t} else if (MyNumber(buf + 2 * i) > size) {\n\t    Strings[i] = ABSENT_STRING;\n\t} else {\n\t    int nn = MyNumber(buf + 2 * i);\n\t    if (nn >= 0 && nn < size) {\n\t\tStrings[i] = (nn + table);\n\t\tTR(TRACE_DATABASE, (\"Strings[%d] = %s\", i,\n\t\t\t\t    _nc_visbuf(Strings[i])));\n\t    } else {\n\t\tif (!corrupt) {\n\t\t    corrupt = TRUE;\n\t\t    TR(TRACE_DATABASE,\n\t\t       (\"ignore out-of-range index %d to Strings[]\", nn));\n\t\t    _nc_warning(\"corrupt data found in convert_strings\");\n\t\t}\n\t\tStrings[i] = ABSENT_STRING;\n\t    }\n\t}\n\n\t \n\tif (VALID_STRING(Strings[i])) {\n\t    for (p = Strings[i]; p < table + size; p++)\n\t\tif (*p == '\\0')\n\t\t    break;\n\t     \n\t    if (p >= table + size)\n\t\tStrings[i] = ABSENT_STRING;\n\t}\n    }\n}\n\nstatic int\nfake_read(char *src, int *offset, int limit, char *dst, unsigned want)\n{\n    int have = (limit - *offset);\n\n    if (have > 0) {\n\tif ((int) want > have)\n\t    want = (unsigned) have;\n\tmemcpy(dst, src + *offset, (size_t) want);\n\t*offset += (int) want;\n    } else {\n\twant = 0;\n    }\n    return (int) want;\n}\n\n#define Read(buf, count) fake_read(buffer, &offset, limit, (char *) buf, (unsigned) count)\n\n#define read_shorts(buf, count) \\\n\t(Read(buf, (count)*SIZEOF_SHORT) == (int) (count)*SIZEOF_SHORT)\n\n#define read_numbers(buf, count) \\\n\t(Read(buf, (count)*(unsigned)size_of_numbers) == (int) (count)*size_of_numbers)\n\n#define even_boundary(value) \\\n    if ((value) % 2 != 0) Read(buf, 1)\n#endif\n\nNCURSES_EXPORT(void)\n_nc_init_termtype(TERMTYPE2 *const tp)\n{\n    unsigned i;\n\n    DEBUG(2, (T_CALLED(\"_nc_init_termtype(tp=%p)\"), (void *) tp));\n\n#if NCURSES_XNAMES\n    tp->num_Booleans = BOOLCOUNT;\n    tp->num_Numbers = NUMCOUNT;\n    tp->num_Strings = STRCOUNT;\n    tp->ext_Booleans = 0;\n    tp->ext_Numbers = 0;\n    tp->ext_Strings = 0;\n#endif\n    if (tp->Booleans == 0)\n\tTYPE_MALLOC(NCURSES_SBOOL, BOOLCOUNT, tp->Booleans);\n    if (tp->Numbers == 0)\n\tTYPE_MALLOC(NCURSES_INT2, NUMCOUNT, tp->Numbers);\n    if (tp->Strings == 0)\n\tTYPE_MALLOC(char *, STRCOUNT, tp->Strings);\n\n    for_each_boolean(i, tp)\n\ttp->Booleans[i] = FALSE;\n\n    for_each_number(i, tp)\n\ttp->Numbers[i] = ABSENT_NUMERIC;\n\n    for_each_string(i, tp)\n\ttp->Strings[i] = ABSENT_STRING;\n\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\n#if NCURSES_USE_DATABASE\n#if NCURSES_XNAMES\nstatic bool\nvalid_shorts(char *buffer, int limit)\n{\n    bool result = FALSE;\n    int n;\n    for (n = 0; n < limit; ++n) {\n\tif (MyNumber(buffer + (n * 2)) > 0) {\n\t    result = TRUE;\n\t    break;\n\t}\n    }\n    return result;\n}\n#endif\n\n \nNCURSES_EXPORT(int)\n_nc_read_termtype(TERMTYPE2 *ptr, char *buffer, int limit)\n{\n    int offset = 0;\n    int name_size, bool_count, num_count, str_count, str_size;\n    int i;\n    char buf[MAX_ENTRY_SIZE + 2];\n    char *string_table;\n    unsigned want, have;\n    size_t (*convert_numbers) (char *, NCURSES_INT2 *, int);\n    int size_of_numbers;\n    int max_entry_size = MAX_ENTRY_SIZE;\n\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"_nc_read_termtype(ptr=%p, buffer=%p, limit=%d)\"),\n\t(void *) ptr, buffer, limit));\n\n    TR(TRACE_DATABASE, (\"READ termtype header @%d\", offset));\n\n    memset(ptr, 0, sizeof(*ptr));\n\n     \n    if (!read_shorts(buf, 6)\n\t|| !IS_TIC_MAGIC(buf)) {\n\treturnDB(TGETENT_NO);\n    }\n#if NCURSES_EXT_NUMBERS\n    if (LOW_MSB(buf) == MAGIC2) {\n\tconvert_numbers = convert_32bits;\n\tsize_of_numbers = SIZEOF_INT2;\n    } else {\n\tmax_entry_size = MAX_ENTRY_SIZE1;\n\tconvert_numbers = convert_16bits;\n\tsize_of_numbers = SIZEOF_SHORT;\n    }\n#else\n    if (LOW_MSB(buf) == MAGIC2) {\n\tconvert_numbers = convert_32bits;\n\tsize_of_numbers = SIZEOF_32BITS;\n    } else {\n\tconvert_numbers = convert_16bits;\n\tsize_of_numbers = SIZEOF_INT2;\n    }\n#endif\n\n     \n    name_size  = MyNumber(buf + 2);\n    bool_count = MyNumber(buf + 4);\n    num_count  = MyNumber(buf + 6);\n    str_count  = MyNumber(buf + 8);\n    str_size   = MyNumber(buf + 10);\n\n    TR(TRACE_DATABASE,\n       (\"TERMTYPE name_size=%d, bool=%d/%d, num=%d/%d str=%d/%d(%d)\",\n\tname_size, bool_count, BOOLCOUNT, num_count, NUMCOUNT,\n\tstr_count, STRCOUNT, str_size));\n    if (name_size < 0\n\t|| bool_count < 0\n\t|| num_count < 0\n\t|| str_count < 0\n\t|| str_size < 0) {\n\treturnDB(TGETENT_NO);\n    }\n\n    want = (unsigned) (str_size + name_size + 1);\n     \n    if (str_count * SIZEOF_SHORT >= max_entry_size\n\t|| (string_table = typeMalloc(char, want)) == 0) {\n\treturnDB(TGETENT_NO);\n    }\n\n     \n    want = min(MAX_NAME_SIZE, (unsigned) name_size);\n    ptr->str_table = string_table;\n    ptr->term_names = string_table;\n    if ((have = (unsigned) Read(ptr->term_names, want)) != want) {\n\tmemset(ptr->term_names + have, 0, (size_t) (want - have));\n    }\n    ptr->term_names[want] = '\\0';\n    string_table += (want + 1);\n\n    if (have > MAX_NAME_SIZE)\n\toffset = (int) (have - MAX_NAME_SIZE);\n\n     \n    TYPE_CALLOC(NCURSES_SBOOL, max(BOOLCOUNT, bool_count), ptr->Booleans);\n    if (Read(ptr->Booleans, (unsigned) bool_count) < bool_count) {\n\treturnDB(TGETENT_NO);\n    }\n\n     \n    even_boundary(name_size + bool_count);\n\n     \n    TYPE_CALLOC(NCURSES_INT2, max(NUMCOUNT, num_count), ptr->Numbers);\n    if (!read_numbers(buf, num_count)) {\n\treturnDB(TGETENT_NO);\n    }\n    convert_numbers(buf, ptr->Numbers, num_count);\n\n    TYPE_CALLOC(char *, max(STRCOUNT, str_count), ptr->Strings);\n\n    if (str_count) {\n\t \n\tif (!read_shorts(buf, str_count)) {\n\t    returnDB(TGETENT_NO);\n\t}\n\t \n\tif (Read(string_table, (unsigned) str_size) != str_size) {\n\t    returnDB(TGETENT_NO);\n\t}\n\tconvert_strings(buf, ptr->Strings, str_count, str_size, string_table);\n    }\n#if NCURSES_XNAMES\n\n    ptr->num_Booleans = BOOLCOUNT;\n    ptr->num_Numbers = NUMCOUNT;\n    ptr->num_Strings = STRCOUNT;\n\n     \n    even_boundary(str_size);\n    TR(TRACE_DATABASE, (\"READ extended_header @%d\", offset));\n    if (_nc_user_definable && read_shorts(buf, 5) && valid_shorts(buf, 5)) {\n\tint ext_bool_count = MyNumber(buf + 0);\n\tint ext_num_count = MyNumber(buf + 2);\n\tint ext_str_count = MyNumber(buf + 4);\n\tint ext_str_usage = MyNumber(buf + 6);\n\tint ext_str_limit = MyNumber(buf + 8);\n\tunsigned need = (unsigned) (ext_bool_count + ext_num_count + ext_str_count);\n\tint base = 0;\n\n\tif ((int) need >= (max_entry_size / 2)\n\t    || ext_str_usage >= max_entry_size\n\t    || ext_str_limit >= max_entry_size\n\t    || ext_bool_count < 0\n\t    || ext_num_count < 0\n\t    || ext_str_count < 0\n\t    || ext_str_usage < 0\n\t    || ext_str_limit < 0) {\n\t    returnDB(TGETENT_NO);\n\t}\n\n\tptr->num_Booleans = UShort(BOOLCOUNT + ext_bool_count);\n\tptr->num_Numbers = UShort(NUMCOUNT + ext_num_count);\n\tptr->num_Strings = UShort(STRCOUNT + ext_str_count);\n\n\tTYPE_REALLOC(NCURSES_SBOOL, ptr->num_Booleans, ptr->Booleans);\n\tTYPE_REALLOC(NCURSES_INT2, ptr->num_Numbers, ptr->Numbers);\n\tTYPE_REALLOC(char *, ptr->num_Strings, ptr->Strings);\n\n\tTR(TRACE_DATABASE, (\"extended header: \"\n\t\t\t    \"bool %d, \"\n\t\t\t    \"number %d, \"\n\t\t\t    \"string %d(%d:%d)\",\n\t\t\t    ext_bool_count,\n\t\t\t    ext_num_count,\n\t\t\t    ext_str_count,\n\t\t\t    ext_str_usage,\n\t\t\t    ext_str_limit));\n\n\tTR(TRACE_DATABASE, (\"READ %d extended-booleans @%d\",\n\t\t\t    ext_bool_count, offset));\n\tif ((ptr->ext_Booleans = UShort(ext_bool_count)) != 0) {\n\t    if (Read(ptr->Booleans + BOOLCOUNT, (unsigned)\n\t\t     ext_bool_count) != ext_bool_count) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t}\n\teven_boundary(ext_bool_count);\n\n\tTR(TRACE_DATABASE, (\"READ %d extended-numbers @%d\",\n\t\t\t    ext_num_count, offset));\n\tif ((ptr->ext_Numbers = UShort(ext_num_count)) != 0) {\n\t    if (!read_numbers(buf, ext_num_count)) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    TR(TRACE_DATABASE, (\"Before converting extended-numbers\"));\n\t    convert_numbers(buf, ptr->Numbers + NUMCOUNT, ext_num_count);\n\t}\n\n\tTR(TRACE_DATABASE, (\"READ extended-offsets @%d\", offset));\n\tif ((ext_str_count + (int) need) >= (max_entry_size / 2)) {\n\t    returnDB(TGETENT_NO);\n\t}\n\tif ((ext_str_count || need)\n\t    && !read_shorts(buf, ext_str_count + (int) need)) {\n\t    returnDB(TGETENT_NO);\n\t}\n\n\tTR(TRACE_DATABASE, (\"READ %d bytes of extended-strings @%d\",\n\t\t\t    ext_str_limit, offset));\n\n\tif (ext_str_limit) {\n\t    ptr->ext_str_table = typeMalloc(char, (size_t) ext_str_limit);\n\t    if (ptr->ext_str_table == 0) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    if (Read(ptr->ext_str_table, (unsigned) ext_str_limit) != ext_str_limit) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    TR(TRACE_DATABASE, (\"first extended-string is %s\", _nc_visbuf(ptr->ext_str_table)));\n\t}\n\n\tif ((ptr->ext_Strings = UShort(ext_str_count)) != 0) {\n\t    int check = (ext_bool_count + ext_num_count + ext_str_count);\n\n\t    TR(TRACE_DATABASE,\n\t       (\"Before computing extended-string capabilities \"\n\t\t\"str_count=%d, ext_str_count=%d\",\n\t\tstr_count, ext_str_count));\n\t    convert_strings(buf, ptr->Strings + str_count, ext_str_count,\n\t\t\t    ext_str_limit, ptr->ext_str_table);\n\t    for (i = ext_str_count - 1; i >= 0; i--) {\n\t\tTR(TRACE_DATABASE, (\"MOVE from [%d:%d] %s\",\n\t\t\t\t    i, i + str_count,\n\t\t\t\t    _nc_visbuf(ptr->Strings[i + str_count])));\n\t\tptr->Strings[i + STRCOUNT] = ptr->Strings[i + str_count];\n\t\tif (VALID_STRING(ptr->Strings[i + STRCOUNT])) {\n\t\t    base += (int) (strlen(ptr->Strings[i + STRCOUNT]) + 1);\n\t\t    ++check;\n\t\t}\n\t\tTR(TRACE_DATABASE, (\"... to    [%d] %s\",\n\t\t\t\t    i + STRCOUNT,\n\t\t\t\t    _nc_visbuf(ptr->Strings[i + STRCOUNT])));\n\t    }\n\t    TR(TRACE_DATABASE, (\"Check table-size: %d/%d\", check, ext_str_usage));\n#if 0\n\t     \n\t    if (check != ext_str_usage)\n\t\treturnDB(TGETENT_NO);\n#endif\n\t}\n\n\tif (need) {\n\t    if (ext_str_count >= (max_entry_size / 2)) {\n\t\treturnDB(TGETENT_NO);\n\t    }\n\t    TYPE_CALLOC(char *, need, ptr->ext_Names);\n\t    TR(TRACE_DATABASE,\n\t       (\"ext_NAMES starting @%d in extended_strings, first = %s\",\n\t\tbase, _nc_visbuf(ptr->ext_str_table + base)));\n\t    convert_strings(buf + (2 * ext_str_count),\n\t\t\t    ptr->ext_Names,\n\t\t\t    (int) need,\n\t\t\t    ext_str_limit, ptr->ext_str_table + base);\n\t}\n\n\tTR(TRACE_DATABASE,\n\t   (\"...done reading terminfo bool %d(%d) num %d(%d) str %d(%d)\",\n\t    ptr->num_Booleans, ptr->ext_Booleans,\n\t    ptr->num_Numbers, ptr->ext_Numbers,\n\t    ptr->num_Strings, ptr->ext_Strings));\n\n\tTR(TRACE_DATABASE, (\"extend: num_Booleans:%d\", ptr->num_Booleans));\n    } else\n#endif  \n    {\n\tTR(TRACE_DATABASE, (\"...done reading terminfo bool %d num %d str %d\",\n\t\t\t    bool_count, num_count, str_count));\n#if NCURSES_XNAMES\n\tTR(TRACE_DATABASE, (\"normal: num_Booleans:%d\", ptr->num_Booleans));\n#endif\n    }\n\n    for (i = bool_count; i < BOOLCOUNT; i++)\n\tptr->Booleans[i] = FALSE;\n    for (i = num_count; i < NUMCOUNT; i++)\n\tptr->Numbers[i] = ABSENT_NUMERIC;\n    for (i = str_count; i < STRCOUNT; i++)\n\tptr->Strings[i] = ABSENT_STRING;\n\n    returnDB(TGETENT_YES);\n}\n\n \nNCURSES_EXPORT(int)\n_nc_read_file_entry(const char *const filename, TERMTYPE2 *ptr)\n \n{\n    FILE *fp = 0;\n    int code;\n\n    if (_nc_access(filename, R_OK) < 0\n\t|| (fp = safe_fopen(filename, BIN_R)) == 0) {\n\tTR(TRACE_DATABASE, (\"cannot open terminfo %s (errno=%d)\", filename, errno));\n\tcode = TGETENT_NO;\n    } else {\n\tint limit;\n\tchar buffer[MAX_ENTRY_SIZE + 1];\n\n\tif ((limit = (int) fread(buffer, sizeof(char), sizeof(buffer), fp))\n\t    > 0) {\n\n\t    TR(TRACE_DATABASE, (\"read terminfo %s\", filename));\n\t    if ((code = _nc_read_termtype(ptr, buffer, limit)) == TGETENT_NO) {\n\t\t_nc_free_termtype2(ptr);\n\t    }\n\t} else {\n\t    code = TGETENT_NO;\n\t}\n\tfclose(fp);\n    }\n\n    return (code);\n}\n\n#if USE_HASHED_DB\n \nstatic bool\nmake_db_filename(char *filename, unsigned limit, const char *const path)\n{\n    static const char suffix[] = DBM_SUFFIX;\n\n    size_t lens = sizeof(suffix) - 1;\n    size_t size = strlen(path);\n    size_t test = lens + size;\n    bool result = FALSE;\n\n    if (test < limit) {\n\tif (size >= lens\n\t    && !strcmp(path + size - lens, suffix))\n\t    _nc_STRCPY(filename, path, limit);\n\telse\n\t    _nc_SPRINTF(filename, _nc_SLIMIT(limit) \"%s%s\", path, suffix);\n\tresult = TRUE;\n    }\n    return result;\n}\n#endif\n\n \nstatic bool\nmake_dir_filename(char *filename,\n\t\t  unsigned limit,\n\t\t  const char *const path,\n\t\t  const char *name)\n{\n    bool result = FALSE;\n\n#if NCURSES_USE_TERMCAP\n    if (_nc_is_dir_path(path))\n#endif\n    {\n\tunsigned need = (unsigned) (LEAF_LEN + 3 + strlen(path) + strlen(name));\n\n\tif (need <= limit) {\n\t    _nc_SPRINTF(filename, _nc_SLIMIT(limit)\n\t\t\t\"%s/\" LEAF_FMT \"/%s\", path, *name, name);\n\t    result = TRUE;\n\t}\n    }\n    return result;\n}\n\nstatic int\nlookup_b64(int *target, const char **source)\n{\n    int result = 3;\n    int j;\n     \n    for (j = 0; j < 4; ++j) {\n\tint ch = UChar(**source);\n\t*source += 1;\n\tif (ch >= 'A' && ch <= 'Z') {\n\t    target[j] = (ch - 'A');\n\t} else if (ch >= 'a' && ch <= 'z') {\n\t    target[j] = 26 + (ch - 'a');\n\t} else if (ch >= '0' && ch <= '9') {\n\t    target[j] = 52 + (ch - '0');\n\t} else if (ch == '-' || ch == '+') {\n\t    target[j] = 62;\n\t} else if (ch == '_' || ch == '/') {\n\t    target[j] = 63;\n\t} else if (ch == '=') {\n\t    target[j] = 64;\n\t    result--;\n\t} else {\n\t    result = -1;\n\t    break;\n\t}\n    }\n    return result;\n}\n\nstatic int\ndecode_hex(const char **source)\n{\n    int result = 0;\n    int nibble;\n\n    for (nibble = 0; nibble < 2; ++nibble) {\n\tint ch = UChar(**source);\n\tresult <<= 4;\n\t*source += 1;\n\tif (ch >= '0' && ch <= '9') {\n\t    ch -= '0';\n\t} else if (ch >= 'A' && ch <= 'F') {\n\t    ch -= 'A';\n\t    ch += 10;\n\t} else if (ch >= 'a' && ch <= 'f') {\n\t    ch -= 'a';\n\t    ch += 10;\n\t} else {\n\t    result = -1;\n\t    break;\n\t}\n\tresult |= ch;\n    }\n    return result;\n}\n\nstatic int\ndecode_quickdump(char *target, const char *source)\n{\n    char *base = target;\n    int result = 0;\n\n    if (!strncmp(source, \"b64:\", (size_t) 4)) {\n\tsource += 4;\n\twhile (*source != '\\0') {\n\t    int bits[4];\n\t    int ch = lookup_b64(bits, &source);\n\t    if (ch < 0 || (ch + target - base) >= MAX_ENTRY_SIZE) {\n\t\tresult = 0;\n\t\tbreak;\n\t    }\n\t    result += ch;\n\t    *target++ = (char) ((bits[0] << 2) | (bits[1] >> 4));\n\t    if (bits[2] < 64) {\n\t\t*target++ = (char) ((bits[1] << 4) | (bits[2] >> 2));\n\t\tif (bits[3] < 64) {\n\t\t    *target++ = (char) ((bits[2] << 6) | bits[3]);\n\t\t}\n\t    }\n\t}\n    } else if (!strncmp(source, \"hex:\", (size_t) 4)) {\n\tsource += 4;\n\twhile (*source != '\\0') {\n\t    int ch = decode_hex(&source);\n\t    if (ch < 0 || (target - base) >= MAX_ENTRY_SIZE) {\n\t\tresult = 0;\n\t\tbreak;\n\t    }\n\t    *target++ = (char) ch;\n\t    ++result;\n\t}\n    }\n    return result;\n}\n\n \nstatic int\n_nc_read_tic_entry(char *filename,\n\t\t   unsigned limit,\n\t\t   const char *const path,\n\t\t   const char *name,\n\t\t   TERMTYPE2 *const tp)\n{\n    int code = TGETENT_NO;\n#if USE_HASHED_DB\n    DB *capdbp;\n#endif\n    char buffer[MAX_ENTRY_SIZE + 1];\n    int used;\n\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"_nc_read_tic_entry(file=%p, path=%s, name=%s)\"),\n\tfilename, path, name));\n\n    assert(TGETENT_YES == TRUE);\t \n\n    if ((used = decode_quickdump(buffer, path)) != 0\n\t&& (code = _nc_read_termtype(tp, buffer, used)) == TGETENT_YES\n\t&& (code = _nc_name_match(tp->term_names, name, \"|\")) == TGETENT_YES) {\n\tTR(TRACE_DATABASE, (\"loaded quick-dump for %s\", name));\n\t \n\t_nc_STRCPY(filename, \"$TERMINFO\", limit);\n    } else\n#if USE_HASHED_DB\n\tif (make_db_filename(filename, limit, path)\n\t    && (capdbp = _nc_db_open(filename, FALSE)) != 0) {\n\n\tDBT key, data;\n\tint reccnt = 0;\n\tchar *save = strdup(name);\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.data = save;\n\tkey.size = strlen(save);\n\n\t \n\twhile (_nc_db_get(capdbp, &key, &data) == 0) {\n\t    char *have = (char *) data.data;\n\t    used = (int) data.size - 1;\n\n\t    if (*have++ == 0) {\n\t\tif (data.size > key.size\n\t\t    && IS_TIC_MAGIC(have)) {\n\t\t    code = _nc_read_termtype(tp, have, used);\n\t\t    if (code == TGETENT_NO) {\n\t\t\t_nc_free_termtype2(tp);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    }\n\n\t     \n\t    if (++reccnt >= 3)\n\t\tbreak;\n\n\t     \n\t    key.data = have;\n\t    key.size = used;\n\t}\n\n\tfree(save);\n    } else\t\t\t \n#endif\n    if (make_dir_filename(filename, limit, path, name)) {\n\tcode = _nc_read_file_entry(filename, tp);\n    }\n#if NCURSES_USE_TERMCAP\n    if (code != TGETENT_YES) {\n\tcode = _nc_read_termcap_entry(name, tp);\n\t_nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)\n\t\t    \"%.*s\", PATH_MAX - 1, _nc_get_source());\n    }\n#endif\n    returnDB(code);\n}\n#endif  \n\n \nNCURSES_EXPORT(int)\n_nc_read_entry2(const char *const name, char *const filename, TERMTYPE2 *const tp)\n{\n    int code = TGETENT_NO;\n\n    if (name == 0)\n\treturn _nc_read_entry2(\"\", filename, tp);\n\n    _nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)\n\t\t\"%.*s\", PATH_MAX - 1, name);\n\n    if (strlen(name) == 0\n\t|| strcmp(name, \".\") == 0\n\t|| strcmp(name, \"..\") == 0\n\t|| _nc_pathlast(name) != 0\n\t|| strchr(name, NCURSES_PATHSEP) != 0) {\n\tTR(TRACE_DATABASE, (\"illegal or missing entry name '%s'\", name));\n    } else {\n#if NCURSES_USE_DATABASE\n\tDBDIRS state;\n\tint offset;\n\tconst char *path;\n\n\t_nc_first_db(&state, &offset);\n\tcode = TGETENT_ERR;\n\twhile ((path = _nc_next_db(&state, &offset)) != 0) {\n\t    code = _nc_read_tic_entry(filename, PATH_MAX, path, name, tp);\n\t    if (code == TGETENT_YES) {\n\t\t_nc_last_db();\n\t\tbreak;\n\t    }\n\t}\n#elif NCURSES_USE_TERMCAP\n\tif (code != TGETENT_YES) {\n\t    code = _nc_read_termcap_entry(name, tp);\n\t    _nc_SPRINTF(filename, _nc_SLIMIT(PATH_MAX)\n\t\t\t\"%.*s\", PATH_MAX - 1, _nc_get_source());\n\t}\n#endif\n    }\n    return code;\n}\n\n#if NCURSES_EXT_NUMBERS\n \nNCURSES_EXPORT(int)\n_nc_read_entry(const char *const name, char *const filename, TERMTYPE *const tp)\n{\n    TERMTYPE2 dummy;\n    int rc;\n    rc = _nc_read_entry2(name, filename, &dummy);\n    if (rc == TGETENT_YES)\n\t_nc_export_termtype2(tp, &dummy);\n    return rc;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}