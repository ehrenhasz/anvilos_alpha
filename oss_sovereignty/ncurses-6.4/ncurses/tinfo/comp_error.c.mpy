{
  "module_name": "comp_error.c",
  "hash_id": "a4e20c68a85854ebb9a5e6b8f5261b63fcbc064b7a4fe7b29178460a83e5f485",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/comp_error.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: comp_error.c,v 1.40 2020/02/02 23:34:34 tom Exp $\")\n\nNCURSES_EXPORT_VAR(bool) _nc_suppress_warnings = FALSE;\nNCURSES_EXPORT_VAR(int) _nc_curr_line = 0;  \nNCURSES_EXPORT_VAR(int) _nc_curr_col = 0;  \n\n#define SourceName\t_nc_globals.comp_sourcename\n#define TermType\t_nc_globals.comp_termtype\n\nNCURSES_EXPORT(const char *)\n_nc_get_source(void)\n{\n    return SourceName;\n}\n\nNCURSES_EXPORT(void)\n_nc_set_source(const char *const name)\n{\n    FreeIfNeeded(SourceName);\n    SourceName = strdup(name);\n}\n\nNCURSES_EXPORT(void)\n_nc_set_type(const char *const name)\n{\n#define MY_SIZE (size_t) MAX_NAME_SIZE\n    if (TermType == 0)\n\tTermType = typeMalloc(char, MY_SIZE + 1);\n    if (TermType != 0) {\n\tTermType[0] = '\\0';\n\tif (name) {\n\t    _nc_STRNCAT(TermType, name, MY_SIZE, MY_SIZE);\n\t}\n    }\n}\n\nNCURSES_EXPORT(void)\n_nc_get_type(char *name)\n{\n#if NO_LEAKS\n    if (name == 0 && TermType != 0) {\n\tFreeAndNull(TermType);\n\treturn;\n    }\n#endif\n    if (name != 0)\n\t_nc_STRCPY(name, TermType != 0 ? TermType : \"\", MAX_NAME_SIZE);\n}\n\nstatic NCURSES_INLINE void\nwhere_is_problem(void)\n{\n    fprintf(stderr, \"\\\"%s\\\"\", SourceName ? SourceName : \"?\");\n    if (_nc_curr_line >= 0)\n\tfprintf(stderr, \", line %d\", _nc_curr_line);\n    if (_nc_curr_col >= 0)\n\tfprintf(stderr, \", col %d\", _nc_curr_col);\n    if (TermType != 0 && TermType[0] != '\\0')\n\tfprintf(stderr, \", terminal '%s'\", TermType);\n    fputc(':', stderr);\n    fputc(' ', stderr);\n}\n\nNCURSES_EXPORT(void)\n_nc_warning(const char *const fmt, ...)\n{\n    va_list argp;\n\n    if (_nc_suppress_warnings)\n\treturn;\n\n    where_is_problem();\n    va_start(argp, fmt);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n}\n\nNCURSES_EXPORT(void)\n_nc_err_abort(const char *const fmt, ...)\n{\n    va_list argp;\n\n    where_is_problem();\n    va_start(argp, fmt);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n    exit(EXIT_FAILURE);\n}\n\nNCURSES_EXPORT(void)\n_nc_syserr_abort(const char *const fmt, ...)\n{\n    va_list argp;\n\n    where_is_problem();\n    va_start(argp, fmt);\n    vfprintf(stderr, fmt, argp);\n    fprintf(stderr, \"\\n\");\n    va_end(argp);\n\n#if defined(TRACE) || !defined(NDEBUG)\n     \n#ifndef USE_ROOT_ENVIRON\n    if (getuid() != ROOT_UID)\n#endif\n\tabort();\n#endif\n     \n    exit(EXIT_FAILURE);\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_comp_error_leaks(void)\n{\n    FreeAndNull(SourceName);\n    FreeAndNull(TermType);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}