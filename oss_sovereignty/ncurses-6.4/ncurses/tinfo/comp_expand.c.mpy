{
  "module_name": "comp_expand.c",
  "hash_id": "015d55164c64ea34d1bf62df0add282b858dc5d934cca4703cf733a399ea3cbb",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/comp_expand.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: comp_expand.c,v 1.34 2021/09/04 10:29:15 tom Exp $\")\n\n#if 0\n#define DEBUG_THIS(p) DEBUG(9, p)\n#else\n#define DEBUG_THIS(p)\t\t \n#endif\n\nstatic int\ntrailing_spaces(const char *src)\n{\n    while (*src == ' ')\n\tsrc++;\n    return *src == 0;\n}\n\n \n#define REALPRINT(s) (UChar(*(s)) < 127 && isprint(UChar(*(s))))\n\n#define P_LIMIT(p)   (length - (size_t)(p))\n\nNCURSES_EXPORT(char *)\n_nc_tic_expand(const char *srcp, bool tic_format, int numbers)\n{\n    static char *buffer;\n    static size_t length;\n\n    int bufp;\n    const char *str = VALID_STRING(srcp) ? srcp : \"\\0\\0\";\n    size_t need = (2 + strlen(str)) * 4;\n    int ch;\n    int octals = 0;\n    struct {\n\tint ch;\n\tint offset;\n    } fixups[MAX_TC_FIXUPS];\n\n    if (srcp == 0) {\n#if NO_LEAKS\n\tif (buffer != 0) {\n\t    FreeAndNull(buffer);\n\t    length = 0;\n\t}\n#endif\n\treturn 0;\n    }\n    if (buffer == 0 || need > length) {\n\tif ((buffer = typeRealloc(char, length = need, buffer)) == 0)\n\t      return 0;\n    }\n\n    DEBUG_THIS((\"_nc_tic_expand %s:%s:%s\",\n\t\ttic_format ? \"ti\" : \"tc\",\n\t\tnumbers ? \"#\" : \"\",\n\t\t_nc_visbuf(srcp)));\n    bufp = 0;\n    while ((ch = UChar(*str)) != 0) {\n\tif (ch == '%' && REALPRINT(str + 1)) {\n\t    buffer[bufp++] = *str++;\n\t     \n\t    switch (numbers) {\n\t    case -1:\n\t\tif (str[0] == S_QUOTE\n\t\t    && str[1] != '\\\\'\n\t\t    && REALPRINT(str + 1)\n\t\t    && str[2] == S_QUOTE) {\n\t\t    _nc_SPRINTF(buffer + bufp, _nc_SLIMIT(P_LIMIT(bufp))\n\t\t\t\t\"{%d}\", str[1]);\n\t\t    bufp += (int) strlen(buffer + bufp);\n\t\t    str += 2;\n\t\t} else {\n\t\t    buffer[bufp++] = *str;\n\t\t}\n\t\tbreak;\n\t\t \n\t    case 1:\n\t\tif (str[0] == L_BRACE\n\t\t    && isdigit(UChar(str[1]))) {\n\t\t    char *dst = 0;\n\t\t    long value = strtol(str + 1, &dst, 0);\n\t\t    if (dst != 0\n\t\t\t&& *dst == R_BRACE\n\t\t\t&& value < 127\n\t\t\t&& value != '\\\\'\t \n\t\t\t&& isprint((int) value)) {\n\t\t\tch = (int) value;\n\t\t\tbuffer[bufp++] = S_QUOTE;\n\t\t\tif (ch == '\\\\'\n\t\t\t    || ch == S_QUOTE)\n\t\t\t    buffer[bufp++] = '\\\\';\n\t\t\tbuffer[bufp++] = (char) ch;\n\t\t\tbuffer[bufp++] = S_QUOTE;\n\t\t\tstr = dst;\n\t\t    } else {\n\t\t\tbuffer[bufp++] = *str;\n\t\t    }\n\t\t} else {\n\t\t    buffer[bufp++] = *str;\n\t\t}\n\t\tbreak;\n\t    default:\n\t\tif (*str == ',')\t \n\t\t    buffer[bufp++] = '\\\\';\n\t\tbuffer[bufp++] = *str;\n\t\tbreak;\n\t    }\n\t} else if (ch == 128) {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = '0';\n\t} else if (ch == '\\033') {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = 'E';\n\t} else if (ch == '\\\\' && tic_format && (str == srcp || str[-1] != '^')) {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = '\\\\';\n\t} else if (ch == ' ' && tic_format && (str == srcp ||\n\t\t\t\t\t       trailing_spaces(str))) {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = 's';\n\t} else if ((ch == ',' || ch == '^') && tic_format) {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = (char) ch;\n\t} else if (REALPRINT(str)\n\t\t   && (ch != ','\n\t\t       && !(ch == ':' && !tic_format)\n\t\t       && !(ch == '!' && !tic_format)\n\t\t       && ch != '^'))\n\t    buffer[bufp++] = (char) ch;\n\telse if (ch == '\\r') {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = 'r';\n\t} else if (ch == '\\n') {\n\t    buffer[bufp++] = '\\\\';\n\t    buffer[bufp++] = 'n';\n\t}\n#define UnCtl(c) ((c) + '@')\n\telse if (UChar(ch) < 32\n\t\t && isdigit(UChar(str[1]))) {\n\t    _nc_SPRINTF(&buffer[bufp], _nc_SLIMIT(P_LIMIT(bufp))\n\t\t\t\"^%c\", UnCtl(ch));\n\t    bufp += 2;\n\t} else {\n\t    _nc_SPRINTF(&buffer[bufp], _nc_SLIMIT(P_LIMIT(bufp))\n\t\t\t\"\\\\%03o\", ch);\n\t    if ((octals < MAX_TC_FIXUPS) &&\n\t\t((tic_format && (ch == 127)) || ch < 32)) {\n\t\tfixups[octals].ch = UChar(ch);\n\t\tfixups[octals].offset = bufp;\n\t\t++octals;\n\t    }\n\t    bufp += 4;\n\t}\n\n\tstr++;\n    }\n\n    buffer[bufp] = '\\0';\n\n     \n    if (octals != 0 && (!tic_format || (bufp - (4 * octals)) < MIN_TC_FIXUPS)) {\n\twhile (--octals >= 0) {\n\t    char *p = buffer + fixups[octals].offset;\n\t    *p++ = '^';\n\t    *p++ = (char) ((fixups[octals].ch == 127)\n\t\t\t   ? '?'\n\t\t\t   : (fixups[octals].ch + (int) '@'));\n\t    while ((p[0] = p[2]) != 0) {\n\t\t++p;\n\t    }\n\t}\n    }\n    DEBUG_THIS((\"... %s\", _nc_visbuf(buffer)));\n    return (buffer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}