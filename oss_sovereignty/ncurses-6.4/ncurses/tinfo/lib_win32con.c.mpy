{
  "module_name": "lib_win32con.c",
  "hash_id": "2e6b94a60f46c97fe6542700196317cf0125ab60dc34824875e5113c60223b5f",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/lib_win32con.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_win32con.c,v 1.7 2021/09/04 10:54:35 tom Exp $\")\n\n#ifdef _NC_WINDOWS\n\n#ifdef _NC_MINGW\n#include <wchar.h>\n#else\n#include <tchar.h>\n#endif\n\n#include <io.h>\n\n#if USE_WIDEC_SUPPORT\n#define write_screen WriteConsoleOutputW\n#define read_screen  ReadConsoleOutputW\n#else\n#define write_screen WriteConsoleOutput\n#define read_screen  ReadConsoleOutput\n#endif\n\nstatic BOOL IsConsoleHandle(HANDLE hdl);\nstatic bool save_original_screen(void);\nstatic bool restore_original_screen(void) GCC_UNUSED;\nstatic bool read_screen_data(void);\nstatic int  Adjust(int milliseconds, int diff);\nstatic int  decode_mouse(SCREEN *sp, int mask);\nstatic bool handle_mouse(SCREEN *sp, MOUSE_EVENT_RECORD mer);\nstatic int  rkeycompare(const void *el1, const void *el2);\nstatic int  keycompare(const void *el1, const void *el2);\nstatic int  MapKey(WORD vKey);\nstatic int  AnsiKey(WORD vKey);\n\nstatic ULONGLONG tdiff(FILETIME fstart, FILETIME fend);\n\n#define GenMap(vKey,key) MAKELONG(key, vKey)\nstatic const LONG keylist[] =\n{\n    GenMap(VK_PRIOR, KEY_PPAGE),\n    GenMap(VK_NEXT, KEY_NPAGE),\n    GenMap(VK_END, KEY_END),\n    GenMap(VK_HOME, KEY_HOME),\n    GenMap(VK_LEFT, KEY_LEFT),\n    GenMap(VK_UP, KEY_UP),\n    GenMap(VK_RIGHT, KEY_RIGHT),\n    GenMap(VK_DOWN, KEY_DOWN),\n    GenMap(VK_DELETE, KEY_DC),\n    GenMap(VK_INSERT, KEY_IC)\n};\nstatic const LONG ansi_keys[] =\n{\n    GenMap(VK_PRIOR, 'I'),\n    GenMap(VK_NEXT, 'Q'),\n    GenMap(VK_END, 'O'),\n    GenMap(VK_HOME, 'H'),\n    GenMap(VK_LEFT, 'K'),\n    GenMap(VK_UP, 'H'),\n    GenMap(VK_RIGHT, 'M'),\n    GenMap(VK_DOWN, 'P'),\n    GenMap(VK_DELETE, 'S'),\n    GenMap(VK_INSERT, 'R')\n};\n#define array_length(a) (sizeof(a)/sizeof(a[0]))\n#define N_INI ((int)array_length(keylist))\n#define FKEYS 24\n#define MAPSIZE (FKEYS + N_INI)\n\n \nNCURSES_EXPORT_VAR(ConsoleInfo) _nc_CONSOLE;\nstatic bool console_initialized = FALSE;\n\n#define EnsureInit() (void)(console_initialized ? TRUE : _nc_console_checkinit(TRUE, TRUE))\n\n#define REQUIRED_MAX_V (DWORD)10\n#define REQUIRED_MIN_V (DWORD)0\n#define REQUIRED_BUILD (DWORD)17763\n \nNCURSES_EXPORT(int)\n_nc_console_vt_supported(void)\n{\n    OSVERSIONINFO osvi;\n    int res = 0;\n\n    T((T_CALLED(\"lib_win32con::_nc_console_vt_supported\")));\n    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));\n    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\n    GetVersionEx(&osvi);\n    T((\"GetVersionEx returnedMajor=%ld, Minor=%ld, Build=%ld\",\n       osvi.dwMajorVersion,\n       osvi.dwMinorVersion,\n       osvi.dwBuildNumber));\n    if (osvi.dwMajorVersion >= REQUIRED_MAX_V) {\n      if (osvi.dwMajorVersion == REQUIRED_MAX_V) {\n          if (((osvi.dwMinorVersion == REQUIRED_MIN_V) &&\n               (osvi.dwBuildNumber >= REQUIRED_BUILD)) ||\n              ((osvi.dwMinorVersion > REQUIRED_MIN_V)))\n              res = 1;\n      } else\n          res = 1;\n    }\n    returnCode(res);\n}\n\nNCURSES_EXPORT(void)\n_nc_console_size(int* Lines, int* Cols)\n{\n  EnsureInit();\n  if (Lines != NULL && Cols != NULL) {\n      if (WINCONSOLE.buffered) {\n          *Lines = (int) (WINCONSOLE.SBI.dwSize.Y);\n          *Cols = (int) (WINCONSOLE.SBI.dwSize.X);\n      } else {\n          *Lines = (int) (WINCONSOLE.SBI.srWindow.Bottom + 1 -\n                          WINCONSOLE.SBI.srWindow.Top);\n          *Cols = (int) (WINCONSOLE.SBI.srWindow.Right + 1 -\n                         WINCONSOLE.SBI.srWindow.Left);\n      }\n  }\n}\n\n \nNCURSES_EXPORT(HANDLE)\n_nc_console_handle(int fd)\n{\n    intptr_t value = _get_osfhandle(fd);\n    return (HANDLE) value;\n}\n\n \nstatic BOOL\nIsConsoleHandle(HANDLE hdl)\n{\n    DWORD dwFlag = 0;\n    BOOL result = FALSE;\n\n    T((T_CALLED(\"lib_win32con::IsConsoleHandle(HANDLE=%p\"), hdl));\n\n    EnsureInit();\n\n    if (!GetConsoleMode(hdl, &dwFlag)) {\n        T((\"GetConsoleMode failed\"));\n    } else {\n        result = TRUE;\n    }\n\n    returnBool(result);\n}\n\n \nNCURSES_EXPORT(int)\n_nc_console_test(int fd)\n{\n    int code = 0;\n    HANDLE hdl = INVALID_HANDLE_VALUE;\n    T((T_CALLED(\"lib_win32con::_nc_console_test(%d)\"), fd));\n    hdl = _nc_console_handle(fd);\n    code = (int) IsConsoleHandle(hdl);\n    returnCode(code);\n}\n\n#define OutHandle() ((WINCONSOLE.isTermInfoConsole || WINCONSOLE.progMode) ? WINCONSOLE.hdl : WINCONSOLE.out)\n\nNCURSES_EXPORT(void)\n_nc_console_selectActiveHandle(void)\n{\n    if (WINCONSOLE.lastOut != WINCONSOLE.hdl) {\n        WINCONSOLE.lastOut = WINCONSOLE.hdl;\n        SetConsoleActiveScreenBuffer(WINCONSOLE.lastOut);\n    }\n}\n\nNCURSES_EXPORT(HANDLE)\n_nc_console_fd2handle(int fd)\n{\n    HANDLE hdl = _nc_console_handle(fd);\n    if (hdl==WINCONSOLE.inp) {\n        T((\"lib_win32con:validateHandle %d -> WINCONSOLE.inp\", fd));\n    } else if (hdl==WINCONSOLE.hdl) {\n        T((\"lib_win32con:validateHandle %d -> WINCONSOLE.hdl\", fd));\n    } else if (hdl==WINCONSOLE.out) {\n        T((\"lib_win32con:validateHandle %d -> WINCONSOLE.out\", fd));\n    } else {\n        T((\"lib_win32con:validateHandle %d maps to unknown HANDLE\", fd));\n        hdl = INVALID_HANDLE_VALUE;\n    }\n#if 1\n    assert(hdl != INVALID_HANDLE_VALUE);\n#endif\n    if (hdl != INVALID_HANDLE_VALUE) {\n        if (hdl != WINCONSOLE.inp && (!WINCONSOLE.isTermInfoConsole && WINCONSOLE.progMode)) {\n            if (hdl==WINCONSOLE.out && hdl!=WINCONSOLE.hdl) {\n                T((\"lib_win32con:validateHandle forcing WINCONSOLE.out -> WINCONSOLE.hdl\"));\n                hdl = WINCONSOLE.hdl;\n            }\n        }\n    }\n    return hdl;\n}\n\nNCURSES_EXPORT(int)\n_nc_console_setmode(HANDLE hdl, const TTY *arg)\n{\n    DWORD dwFlag = 0;\n    int code = ERR;\n    HANDLE alt;\n\n    if (arg) {\n#ifdef TRACE\n        TTY TRCTTY;\n#define TRCTTYOUT(flag) TRCTTY.dwFlagOut = flag\n#define TRCTTYIN(flag)  TRCTTY.dwFlagIn = flag\n#else\n#define TRCTTYOUT(flag)\n#define TRCTTYIN(flag)\n#endif\n        T((\"lib_win32con:_nc_console_setmode %s\", _nc_trace_ttymode(arg)));\n        if (hdl==WINCONSOLE.inp) {\n            dwFlag = arg->dwFlagIn | ENABLE_MOUSE_INPUT | VT_FLAG_IN;\n            if (WINCONSOLE.isTermInfoConsole)\n                dwFlag |= (VT_FLAG_IN);\n            else\n                dwFlag &= (DWORD) ~(VT_FLAG_IN);\n            TRCTTYIN(dwFlag);\n            SetConsoleMode(hdl, dwFlag);\n\n            alt = OutHandle();\n            dwFlag = arg->dwFlagOut;\n            if (WINCONSOLE.isTermInfoConsole)\n                dwFlag |= (VT_FLAG_OUT);\n            else\n                dwFlag |= (VT_FLAG_OUT);\n            TRCTTYOUT(dwFlag);\n            SetConsoleMode(alt, dwFlag);\n        } else {\n            dwFlag = arg->dwFlagOut;\n            if (WINCONSOLE.isTermInfoConsole)\n                dwFlag |= (VT_FLAG_OUT);\n            else\n                dwFlag |= (VT_FLAG_OUT);\n            TRCTTYOUT(dwFlag);\n            SetConsoleMode(hdl, dwFlag);\n\n            alt = WINCONSOLE.inp;\n            dwFlag = arg->dwFlagIn | ENABLE_MOUSE_INPUT;\n            if (WINCONSOLE.isTermInfoConsole)\n                dwFlag |= (VT_FLAG_IN);\n            else\n                dwFlag &= (DWORD) ~(VT_FLAG_IN);\n            TRCTTYIN(dwFlag);\n            SetConsoleMode(alt, dwFlag);\n            T((\"effective mode set %s\", _nc_trace_ttymode(&TRCTTY)));\n        }\n        code = OK;\n    }\n    return(code);\n}\n\nNCURSES_EXPORT(int)\n_nc_console_getmode(HANDLE hdl, TTY *arg)\n{\n    int code = ERR;\n\n    if (arg) {\n        DWORD dwFlag = 0;\n        HANDLE alt;\n\n        if (hdl==WINCONSOLE.inp) {\n            if(GetConsoleMode(hdl, &dwFlag)) {\n                arg->dwFlagIn = dwFlag;\n                alt = OutHandle();\n                if (GetConsoleMode(alt, &dwFlag)) {\n                    arg->dwFlagOut = dwFlag;\n                    code = OK;\n                }\n            }\n        } else {\n            if (GetConsoleMode(hdl, &dwFlag)) {\n                arg->dwFlagOut = dwFlag;\n                alt = WINCONSOLE.inp;\n                if (GetConsoleMode(alt, &dwFlag)) {\n                    arg->dwFlagIn = dwFlag;\n                    code = OK;\n                }\n            }\n        }\n    }\n    T((\"lib_win32con:_nc_console_getmode %s\", _nc_trace_ttymode(arg)));\n    return(code);\n}\n\nNCURSES_EXPORT(int)\n_nc_console_flush(HANDLE hdl)\n{\n    int code = OK;\n\n    T((T_CALLED(\"lib_win32con::_nc_console_flush(hdl=%p\"), hdl));\n\n    if (hdl != INVALID_HANDLE_VALUE) {\n        if (hdl == WINCONSOLE.hdl ||\n            hdl == WINCONSOLE.inp ||\n            hdl == WINCONSOLE.out) {\n            if (!FlushConsoleInputBuffer(WINCONSOLE.inp))\n                code = ERR;\n        } else {\n            code = ERR;\n            T((\"_nc_console_flush not requesting a handle owned by console.\"));\n        }\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT(WORD)\n_nc_console_MapColor(bool fore, int color)\n{\n    static const int _cmap[] =\n        {0, 4, 2, 6, 1, 5, 3, 7};\n    int a;\n    if (color < 0 || color > 7)\n        a = fore ? 7 : 0;\n    else\n        a = _cmap[color];\n    if (!fore)\n        a = a << 4;\n    return (WORD) a;\n}\n\n\n \nstatic bool\nsave_original_screen(void)\n{\n    bool result = FALSE;\n\n    WINCONSOLE.save_region.Top = 0;\n    WINCONSOLE.save_region.Left = 0;\n    WINCONSOLE.save_region.Bottom = (SHORT) (WINCONSOLE.SBI.dwSize.Y - 1);\n    WINCONSOLE.save_region.Right = (SHORT) (WINCONSOLE.SBI.dwSize.X - 1);\n\n    if (read_screen_data()) {\n        result = TRUE;\n    } else {\n\n        WINCONSOLE.save_region.Top = WINCONSOLE.SBI.srWindow.Top;\n        WINCONSOLE.save_region.Left = WINCONSOLE.SBI.srWindow.Left;\n        WINCONSOLE.save_region.Bottom = WINCONSOLE.SBI.srWindow.Bottom;\n        WINCONSOLE.save_region.Right = WINCONSOLE.SBI.srWindow.Right;\n\n        WINCONSOLE.window_only = TRUE;\n\n        if (read_screen_data()) {\n            result = TRUE;\n        }\n    }\n\n    T((\"... save original screen contents %s\", result ? \"ok\" : \"err\"));\n    return result;\n}\n\nstatic bool\nrestore_original_screen(void)\n{\n    COORD bufferCoord;\n    bool result = FALSE;\n    SMALL_RECT save_region = WINCONSOLE.save_region;\n\n    T((\"... restoring %s\",\n       WINCONSOLE.window_only ? \"window\" : \"entire buffer\"));\n\n    bufferCoord.X = (SHORT) (WINCONSOLE.window_only ?\n                             WINCONSOLE.SBI.srWindow.Left : 0);\n    bufferCoord.Y = (SHORT) (WINCONSOLE.window_only ?\n                             WINCONSOLE.SBI.srWindow.Top : 0);\n\n    if (write_screen(WINCONSOLE.hdl,\n                     WINCONSOLE.save_screen,\n                     WINCONSOLE.save_size,\n                     bufferCoord,\n                     &save_region)) {\n        result = TRUE;\n        mvcur(-1, -1, LINES - 2, 0);\n        T((\"... restore original screen contents ok %dx%d (%d,%d - %d,%d)\",\n           WINCONSOLE.save_size.Y,\n           WINCONSOLE.save_size.X,\n           save_region.Top,\n           save_region.Left,\n           save_region.Bottom,\n           save_region.Right));\n    } else {\n        T((\"... restore original screen contents err\"));\n    }\n    return result;\n}\n\nstatic bool\nread_screen_data(void)\n{\n    bool result = FALSE;\n    COORD bufferCoord;\n    size_t want;\n\n    WINCONSOLE.save_size.X = (SHORT) (WINCONSOLE.save_region.Right\n                                      - WINCONSOLE.save_region.Left + 1);\n    WINCONSOLE.save_size.Y = (SHORT) (WINCONSOLE.save_region.Bottom\n                                      - WINCONSOLE.save_region.Top + 1);\n\n    want = (size_t) (WINCONSOLE.save_size.X * WINCONSOLE.save_size.Y);\n\n    if ((WINCONSOLE.save_screen = malloc(want * sizeof(CHAR_INFO))) != 0) {\n        bufferCoord.X = (SHORT) (WINCONSOLE.window_only ?\n                                 WINCONSOLE.SBI.srWindow.Left : 0);\n        bufferCoord.Y = (SHORT) (WINCONSOLE.window_only ?\n                                 WINCONSOLE.SBI.srWindow.Top : 0);\n\n        T((\"... reading console %s %dx%d into %d,%d - %d,%d at %d,%d\",\n           WINCONSOLE.window_only ? \"window\" : \"buffer\",\n           WINCONSOLE.save_size.Y, WINCONSOLE.save_size.X,\n           WINCONSOLE.save_region.Top,\n           WINCONSOLE.save_region.Left,\n           WINCONSOLE.save_region.Bottom,\n           WINCONSOLE.save_region.Right,\n           bufferCoord.Y,\n           bufferCoord.X));\n\n        if (read_screen(WINCONSOLE.hdl,\n                        WINCONSOLE.save_screen,\n                        WINCONSOLE.save_size,\n                        bufferCoord,\n                        &WINCONSOLE.save_region)) {\n            result = TRUE;\n        } else {\n            T((\" error %#lx\", (unsigned long) GetLastError()));\n            FreeAndNull(WINCONSOLE.save_screen);\n        }\n    }\n\n    return result;\n}\n\nNCURSES_EXPORT(bool)\n_nc_console_get_SBI(void)\n{\n    bool rc = FALSE;\n    if (GetConsoleScreenBufferInfo(WINCONSOLE.hdl, &(WINCONSOLE.SBI))) {\n        T((\"GetConsoleScreenBufferInfo\"));\n        T((\"... buffer(X:%d Y:%d)\",\n           WINCONSOLE.SBI.dwSize.X,\n           WINCONSOLE.SBI.dwSize.Y));\n        T((\"... window(X:%d Y:%d)\",\n           WINCONSOLE.SBI.dwMaximumWindowSize.X,\n           WINCONSOLE.SBI.dwMaximumWindowSize.Y));\n        T((\"... cursor(X:%d Y:%d)\",\n           WINCONSOLE.SBI.dwCursorPosition.X,\n           WINCONSOLE.SBI.dwCursorPosition.Y));\n        T((\"... display(Top:%d Bottom:%d Left:%d Right:%d)\",\n           WINCONSOLE.SBI.srWindow.Top,\n           WINCONSOLE.SBI.srWindow.Bottom,\n           WINCONSOLE.SBI.srWindow.Left,\n           WINCONSOLE.SBI.srWindow.Right));\n        if (WINCONSOLE.buffered) {\n            WINCONSOLE.origin.X = 0;\n            WINCONSOLE.origin.Y = 0;\n        } else {\n            WINCONSOLE.origin.X = WINCONSOLE.SBI.srWindow.Left;\n            WINCONSOLE.origin.Y = WINCONSOLE.SBI.srWindow.Top;\n        }\n        rc = TRUE;\n    } else {\n        T((\"GetConsoleScreenBufferInfo ERR\"));\n    }\n    return rc;\n}\n\n#define MIN_WIDE 80\n#define MIN_HIGH 24\n\n \nNCURSES_EXPORT(void)\n_nc_console_set_scrollback(bool normal, CONSOLE_SCREEN_BUFFER_INFO * info)\n{\n    SMALL_RECT rect;\n    COORD coord;\n    bool changed = FALSE;\n\n    T((T_CALLED(\"lib_win32con::_nc_console_set_scrollback(%s)\"),\n       (normal\n        ? \"normal\"\n        : \"application\")));\n\n    T((\"... SBI.srWindow %d,%d .. %d,%d\",\n       info->srWindow.Top,\n       info->srWindow.Left,\n       info->srWindow.Bottom,\n       info->srWindow.Right));\n    T((\"... SBI.dwSize %dx%d\",\n       info->dwSize.Y,\n       info->dwSize.X));\n\n    if (normal) {\n        rect = info->srWindow;\n        coord = info->dwSize;\n        if (memcmp(info, &WINCONSOLE.SBI, sizeof(*info)) != 0) {\n            changed = TRUE;\n            WINCONSOLE.SBI = *info;\n        }\n    } else {\n        int high = info->srWindow.Bottom - info->srWindow.Top + 1;\n        int wide = info->srWindow.Right - info->srWindow.Left + 1;\n\n        if (high < MIN_HIGH) {\n            T((\"... height %d < %d\", high, MIN_HIGH));\n            high = MIN_HIGH;\n            changed = TRUE;\n        }\n        if (wide < MIN_WIDE) {\n            T((\"... width %d < %d\", wide, MIN_WIDE));\n            wide = MIN_WIDE;\n            changed = TRUE;\n        }\n\n        rect.Left =\n            rect.Top = 0;\n        rect.Right = (SHORT) (wide - 1);\n        rect.Bottom = (SHORT) (high - 1);\n\n        coord.X = (SHORT) wide;\n        coord.Y = (SHORT) high;\n\n        if (info->dwSize.Y != high ||\n            info->dwSize.X != wide ||\n            info->srWindow.Top != 0 ||\n            info->srWindow.Left != 0) {\n            changed = TRUE;\n        }\n\n    }\n\n    if (changed) {\n        T((\"... coord %d,%d\", coord.Y, coord.X));\n        T((\"... rect %d,%d - %d,%d\",\n           rect.Top, rect.Left,\n           rect.Bottom, rect.Right));\n        SetConsoleScreenBufferSize(WINCONSOLE.hdl, coord);       \n        SetConsoleWindowInfo(WINCONSOLE.hdl, TRUE, &rect);       \n        _nc_console_get_SBI();\n    }\n    returnVoid;\n}\n\nstatic ULONGLONG\ntdiff(FILETIME fstart, FILETIME fend)\n{\n    ULARGE_INTEGER ustart;\n    ULARGE_INTEGER uend;\n    ULONGLONG diff;\n\n    ustart.LowPart = fstart.dwLowDateTime;\n    ustart.HighPart = fstart.dwHighDateTime;\n    uend.LowPart = fend.dwLowDateTime;\n    uend.HighPart = fend.dwHighDateTime;\n\n    diff = (uend.QuadPart - ustart.QuadPart) / 10000;\n    return diff;\n}\n\nstatic int\nAdjust(int milliseconds, int diff)\n{\n    if (milliseconds != INFINITY) {\n        milliseconds -= diff;\n        if (milliseconds < 0)\n            milliseconds = 0;\n    }\n    return milliseconds;\n}\n\n#define BUTTON_MASK (FROM_LEFT_1ST_BUTTON_PRESSED | \\\n                     FROM_LEFT_2ND_BUTTON_PRESSED | \\\n                     FROM_LEFT_3RD_BUTTON_PRESSED | \\\n                     FROM_LEFT_4TH_BUTTON_PRESSED | \\\n                     RIGHTMOST_BUTTON_PRESSED)\n\nstatic int\ndecode_mouse(SCREEN *sp, int mask)\n{\n    int result = 0;\n\n    (void) sp;\n    assert(sp && console_initialized);\n\n    if (mask & FROM_LEFT_1ST_BUTTON_PRESSED)\n        result |= BUTTON1_PRESSED;\n    if (mask & FROM_LEFT_2ND_BUTTON_PRESSED)\n        result |= BUTTON2_PRESSED;\n    if (mask & FROM_LEFT_3RD_BUTTON_PRESSED)\n        result |= BUTTON3_PRESSED;\n    if (mask & FROM_LEFT_4TH_BUTTON_PRESSED)\n        result |= BUTTON4_PRESSED;\n\n    if (mask & RIGHTMOST_BUTTON_PRESSED) {\n        switch (WINCONSOLE.numButtons) {\n        case 1:\n            result |= BUTTON1_PRESSED;\n            break;\n        case 2:\n            result |= BUTTON2_PRESSED;\n            break;\n        case 3:\n            result |= BUTTON3_PRESSED;\n            break;\n        case 4:\n            result |= BUTTON4_PRESSED;\n            break;\n        }\n    }\n\n    return result;\n}\n\n#define AdjustY() (WINCONSOLE.buffered ? 0 : (int) WINCONSOLE.SBI.srWindow.Top)\n\nstatic bool\nhandle_mouse(SCREEN *sp, MOUSE_EVENT_RECORD mer)\n{\n    MEVENT work;\n    bool result = FALSE;\n\n    assert(sp);\n\n    sp->_drv_mouse_old_buttons = sp->_drv_mouse_new_buttons;\n    sp->_drv_mouse_new_buttons = mer.dwButtonState & BUTTON_MASK;\n\n     \n    if (sp->_drv_mouse_new_buttons != sp->_drv_mouse_old_buttons) {\n        memset(&work, 0, sizeof(work));\n\n        if (sp->_drv_mouse_new_buttons) {\n            work.bstate |=\n                (mmask_t) decode_mouse(sp,\n                                       sp->_drv_mouse_new_buttons);\n        } else {\n             \n            work.bstate |=\n                (mmask_t) (decode_mouse(sp,\n                                        sp->_drv_mouse_old_buttons)\n                           >> 1);\n            result = TRUE;\n        }\n\n        work.x = mer.dwMousePosition.X;\n        work.y = mer.dwMousePosition.Y - AdjustY();\n\n        sp->_drv_mouse_fifo[sp->_drv_mouse_tail] = work;\n        sp->_drv_mouse_tail += 1;\n    }\n    return result;\n}\n\nstatic int\nrkeycompare(const void *el1, const void *el2)\n{\n    WORD key1 = (LOWORD((*((const LONG *) el1)))) & 0x7fff;\n    WORD key2 = (LOWORD((*((const LONG *) el2)))) & 0x7fff;\n\n    return ((key1 < key2) ? -1 : ((key1 == key2) ? 0 : 1));\n}\n\n\nstatic int\nkeycompare(const void *el1, const void *el2)\n{\n    WORD key1 = HIWORD((*((const LONG *) el1)));\n    WORD key2 = HIWORD((*((const LONG *) el2)));\n\n    return ((key1 < key2) ? -1 : ((key1 == key2) ? 0 : 1));\n}\n\nstatic int\nMapKey(WORD vKey)\n{\n    int code = -1;\n\n    if (!WINCONSOLE.isTermInfoConsole) {\n        WORD nKey = 0;\n        void *res;\n        LONG key = GenMap(vKey, 0);\n\n        res = bsearch(&key,\n                      WINCONSOLE.map,\n                      (size_t) (N_INI + FKEYS),\n                      sizeof(keylist[0]),\n                      keycompare);\n        if (res) {\n            key = *((LONG *) res);\n            nKey = LOWORD(key);\n            code = (int) (nKey & 0x7fff);\n            if (nKey & 0x8000)\n                code = -code;\n        }\n    }\n    return code;\n}\n\nstatic int\nAnsiKey(WORD vKey)\n{\n    int code = -1;\n\n    if (!WINCONSOLE.isTermInfoConsole) {\n        WORD nKey = 0;\n        void *res;\n        LONG key = GenMap(vKey, 0);\n\n        res = bsearch(&key,\n                      WINCONSOLE.ansi_map,\n                      (size_t) (N_INI + FKEYS),\n                      sizeof(keylist[0]),\n                      keycompare);\n        if (res) {\n            key = *((LONG *) res);\n            nKey = LOWORD(key);\n            code = (int) (nKey & 0x7fff);\n            if (nKey & 0x8000)\n                code = -code;\n        }\n    }\n    return code;\n}\n\nNCURSES_EXPORT(int)\n_nc_console_keyok(int keycode, int flag)\n{\n    int code = ERR;\n    WORD nKey;\n    WORD vKey;\n    void *res;\n    LONG key = GenMap(0, (WORD) keycode);\n\n    T((T_CALLED(\"lib_win32con::_nc_console_keyok(%d, %d)\"), keycode, flag));\n\n    res = bsearch(&key,\n                  WINCONSOLE.rmap,\n                  (size_t) (N_INI + FKEYS),\n                  sizeof(keylist[0]),\n                  rkeycompare);\n    if (res) {\n        key = *((LONG *) res);\n        vKey = HIWORD(key);\n        nKey = (LOWORD(key)) & 0x7fff;\n        if (!flag)\n            nKey |= 0x8000;\n        *(LONG *) res = GenMap(vKey, nKey);\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT(bool)\n_nc_console_keyExist(int keycode)\n{\n    WORD nKey;\n    void *res;\n    bool found = FALSE;\n    LONG key = GenMap(0, (WORD) keycode);\n\n    T((T_CALLED(\"lib_win32con::_nc_console_keyExist(%d)\"), keycode));\n    res = bsearch(&key,\n                  WINCONSOLE.rmap,\n                  (size_t) (N_INI + FKEYS),\n                  sizeof(keylist[0]),\n                  rkeycompare);\n    if (res) {\n        key = *((LONG *) res);\n        nKey = LOWORD(key);\n        if (!(nKey & 0x8000))\n            found = TRUE;\n    }\n    returnCode(found);\n}\n\nNCURSES_EXPORT(int)\n_nc_console_twait(\n    SCREEN *sp,\n    HANDLE hdl,\n    int mode,\n    int milliseconds,\n    int *timeleft\n    EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    INPUT_RECORD inp_rec;\n    BOOL b;\n    DWORD nRead = 0, rc = (DWORD) (-1);\n    int code = 0;\n    FILETIME fstart;\n    FILETIME fend;\n    int diff;\n    bool isNoDelay = (milliseconds == 0);\n\n#ifdef NCURSES_WGETCH_EVENTS\n    (void) evl;                  \n#endif\n\n#define IGNORE_CTRL_KEYS (SHIFT_PRESSED|LEFT_ALT_PRESSED|RIGHT_ALT_PRESSED| \\\n                          LEFT_CTRL_PRESSED|RIGHT_CTRL_PRESSED)\n#define CONSUME() ReadConsoleInput(hdl, &inp_rec, 1, &nRead)\n\n    assert(sp);\n\n    TR(TRACE_IEVENT, (\"start twait: hdl=%p, %d milliseconds, mode: %d\",\n                      hdl, milliseconds, mode));\n\n    if (milliseconds < 0)\n        milliseconds = INFINITY;\n\n    memset(&inp_rec, 0, sizeof(inp_rec));\n\n    while (true) {\n        if (!isNoDelay) {\n            GetSystemTimeAsFileTime(&fstart);\n            rc = WaitForSingleObject(hdl, (DWORD) milliseconds);\n            GetSystemTimeAsFileTime(&fend);\n            diff = (int) tdiff(fstart, fend);\n            milliseconds = Adjust(milliseconds, diff);\n            if (milliseconds< 0)\n                break;\n        }\n\n        if (isNoDelay || (rc == WAIT_OBJECT_0)) {\n            if (mode) {\n                nRead = 0;\n                b = GetNumberOfConsoleInputEvents(hdl, &nRead);\n                if (!b) {\n                    T((\"twait:err GetNumberOfConsoleInputEvents\"));\n                }\n                if (isNoDelay && b) {\n                    T((\"twait: Events Available: %ld\", nRead));\n                    if (nRead==0) {\n                        code = 0;\n                        goto end;\n                    } else {\n                        DWORD n = 0;\n                        INPUT_RECORD* pInpRec =\n                            TypeAlloca(INPUT_RECORD, nRead);\n                        if (pInpRec != NULL) {\n                            DWORD i;\n                            BOOL f;\n                            memset(pInpRec, 0, sizeof(INPUT_RECORD)*nRead);\n                            f = PeekConsoleInput(hdl, pInpRec, nRead, &n);\n                            if (f) {\n                                for(i = 0; i < n; i++) {\n                                    if (pInpRec[i].EventType==KEY_EVENT) {\n                                        if(pInpRec[i].Event.KeyEvent.bKeyDown) {\n                                          DWORD ctrlMask =\n                                              (pInpRec[i].Event.KeyEvent.dwControlKeyState &\n                                               IGNORE_CTRL_KEYS);\n                                          if (!ctrlMask) {\n                                              code = TW_INPUT;\n                                              goto end;\n                                          }\n                                        }\n                                    }\n                                }\n                            } else {\n                                T((\"twait:err PeekConsoleInput\"));\n                            }\n                            code = 0;\n                            goto end;\n                        } else {\n                            T((\"twait:err could not alloca input records\"));\n                        }\n                    }\n                }\n                if (b && nRead > 0) {\n                    b = PeekConsoleInput(hdl, &inp_rec, 1, &nRead);\n                    if (!b) {\n                        T((\"twait:err PeekConsoleInput\"));\n                    }\n                    if (b && nRead > 0) {\n                        switch (inp_rec.EventType) {\n                        case KEY_EVENT:\n                            if (mode & TW_INPUT) {\n                                WORD vk =\n                                    inp_rec.Event.KeyEvent.wVirtualKeyCode;\n                                char ch =\n                                    inp_rec.Event.KeyEvent.uChar.AsciiChar;\n                                T((\"twait:event KEY_EVENT\"));\n                                T((\"twait vk=%d, ch=%d, keydown=%d\",\n                                   vk, ch, inp_rec.Event.KeyEvent.bKeyDown));\n                                if (inp_rec.Event.KeyEvent.bKeyDown) {\n                                    T((\"twait:event KeyDown\"));\n                                    if (!WINCONSOLE.isTermInfoConsole &&\n                                        (0 == ch)) {\n                                        int nKey = MapKey(vk);\n                                        if (nKey < 0) {\n                                            CONSUME();\n                                            continue;\n                                        }\n                                    }\n                                    code = TW_INPUT;\n                                    goto end;\n                                } else {\n                                    CONSUME();\n                                }\n                            }\n                            continue;\n                        case MOUSE_EVENT:\n                            T((\"twait:event MOUSE_EVENT\"));\n                            if (decode_mouse(sp,\n                                             (inp_rec.Event.MouseEvent.dwButtonState\n                                              & BUTTON_MASK)) == 0) {\n                                CONSUME();\n                            } else if (mode & TW_MOUSE) {\n                                code = TW_MOUSE;\n                                goto end;\n                            }\n                            continue;\n                             \n                        default:\n                            T((\"twait:event Tyoe %d\", inp_rec.EventType));\n                            CONSUME();\n                            _nc_console_selectActiveHandle();\n                            continue;\n                        }\n                    }\n                }\n            }\n            continue;\n        } else {\n            if (rc != WAIT_TIMEOUT) {\n                code = -1;\n                break;\n            } else {\n                code = 0;\n                break;\n            }\n        }\n    }\nend:\n\n    TR(TRACE_IEVENT, (\"end twait: returned %d (%lu), remaining time %d msec\",\n                      code, GetLastError(), milliseconds));\n\n    if (timeleft)\n        *timeleft = milliseconds;\n\n    return code;\n}\n\nNCURSES_EXPORT(int)\n_nc_console_testmouse(\n                      SCREEN *sp,\n                      HANDLE hdl,\n                      int delay\n                      EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc = 0;\n\n    assert(sp);\n\n    if (sp->_drv_mouse_head < sp->_drv_mouse_tail) {\n        rc = TW_MOUSE;\n    } else {\n        rc = _nc_console_twait(sp,\n                               hdl,\n                               TWAIT_MASK,\n                               delay,\n                               (int *) 0\n                               EVENTLIST_2nd(evl));\n    }\n    return rc;\n}\n\nNCURSES_EXPORT(int)\n_nc_console_read(\n                 SCREEN *sp,\n                 HANDLE hdl,\n                 int *buf)\n{\n    int rc = -1;\n    INPUT_RECORD inp_rec;\n    BOOL b;\n    DWORD nRead;\n    WORD vk;\n\n    assert(sp);\n    assert(buf);\n\n    memset(&inp_rec, 0, sizeof(inp_rec));\n\n    T((T_CALLED(\"lib_win32con::_nc_console_read(%p)\"), sp));\n\n    while ((b = ReadConsoleInput(hdl, &inp_rec, 1, &nRead))) {\n        if (b && nRead > 0) {\n            if (rc < 0)\n                rc = 0;\n            rc = rc + (int) nRead;\n            if (inp_rec.EventType == KEY_EVENT) {\n                if (!inp_rec.Event.KeyEvent.bKeyDown)\n                    continue;\n                *buf = (int) inp_rec.Event.KeyEvent.uChar.AsciiChar;\n                vk = inp_rec.Event.KeyEvent.wVirtualKeyCode;\n                 \n                if (vk >= VK_F1 && vk <= VK_F12) {\n                    if (inp_rec.Event.KeyEvent.dwControlKeyState &\n                        SHIFT_PRESSED) {\n                        vk = (WORD) (vk + 12);\n                    }\n                }\n                if (*buf == 0) {\n                    int key = MapKey(vk);\n                    if (key < 0)\n                        continue;\n                    if (sp->_keypad_on) {\n                        *buf = key;\n                    } else {\n                        ungetch('\\0');\n                        *buf = AnsiKey(vk);\n                    }\n                }\n                break;\n            } else if (inp_rec.EventType == MOUSE_EVENT) {\n                if (handle_mouse(sp,\n                                 inp_rec.Event.MouseEvent)) {\n                    *buf = KEY_MOUSE;\n                    break;\n                }\n            }\n            continue;\n        }\n    }\n    returnCode(rc);\n}\n\n \nNCURSES_EXPORT(int)\n_nc_console_isatty(int fd)\n{\n    int result = 0;\n    T((T_CALLED(\"lib_win32con::_nc_console_isatty(%d\"), fd));\n\n    if (_isatty(fd))\n        result = 1;\n#ifdef _NC_CHECK_MINTTY\n    else {\n        if (_nc_console_checkmintty(fd, NULL)) {\n            result = 2;\n            fprintf(stderr, \"ncurses on Windows must run in a Windows console.\\n\");\n            fprintf(stderr, \"On newer versions of Windows, the calling program should create a PTY-like.\\n\");\n            fprintf(stderr, \"device using the CreatePseudoConsole Windows API call.\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif\n    returnCode(result);\n}\n\nNCURSES_EXPORT(bool)\n_nc_console_checkinit(bool initFlag, bool assumeTermInfo)\n{\n    bool res = FALSE;\n\n    T((T_CALLED(\"lib_win32con::_nc_console_checkinit(initFlag=%d, assumeTermInfo=%d)\"),\n       initFlag, assumeTermInfo));\n\n    if (!initFlag) {\n        res = console_initialized;\n    } else {\n         \n        if (!console_initialized) {\n            int i;\n            DWORD num_buttons;\n            WORD a;\n            BOOL buffered = FALSE;\n            BOOL b;\n\n            START_TRACE();\n            WINCONSOLE.isTermInfoConsole = assumeTermInfo;\n\n            WINCONSOLE.map = (LPDWORD)malloc(sizeof(DWORD)*MAPSIZE);\n            WINCONSOLE.rmap = (LPDWORD)malloc(sizeof(DWORD)*MAPSIZE);\n            WINCONSOLE.ansi_map = (LPDWORD)malloc(sizeof(DWORD)*MAPSIZE);\n\n            for (i = 0; i < (N_INI + FKEYS); i++) {\n                if (i < N_INI) {\n                    WINCONSOLE.rmap[i] = WINCONSOLE.map[i] =\n                        (DWORD) keylist[i];\n                    WINCONSOLE.ansi_map[i] = (DWORD) ansi_keys[i];\n                } else {\n                    WINCONSOLE.rmap[i] = WINCONSOLE.map[i] =\n                        (DWORD) GenMap((VK_F1 + (i - N_INI)),\n                                       (KEY_F(1) + (i - N_INI)));\n                    WINCONSOLE.ansi_map[i] =\n                        (DWORD) GenMap((VK_F1 + (i - N_INI)),\n                                       (';' + (i - N_INI)));\n                }\n            }\n            qsort(WINCONSOLE.ansi_map,\n                  (size_t) (MAPSIZE),\n                  sizeof(keylist[0]),\n                  keycompare);\n            qsort(WINCONSOLE.map,\n                  (size_t) (MAPSIZE),\n                  sizeof(keylist[0]),\n                  keycompare);\n            qsort(WINCONSOLE.rmap,\n                  (size_t) (MAPSIZE),\n                  sizeof(keylist[0]),\n                  rkeycompare);\n\n            if (GetNumberOfConsoleMouseButtons(&num_buttons)) {\n                WINCONSOLE.numButtons = (int) num_buttons;\n            } else {\n                WINCONSOLE.numButtons = 1;\n            }\n\n            a = _nc_console_MapColor(true, COLOR_WHITE) |\n                _nc_console_MapColor(false, COLOR_BLACK);\n            for (i = 0; i < CON_NUMPAIRS; i++)\n                WINCONSOLE.pairs[i] = a;\n\n            WINCONSOLE.inp = GetStdHandle(STD_INPUT_HANDLE);\n            WINCONSOLE.out = GetStdHandle(STD_OUTPUT_HANDLE);\n            WINCONSOLE.hdl = WINCONSOLE.out;\n\n            GetConsoleMode(WINCONSOLE.inp, &WINCONSOLE.originalMode.dwFlagIn);\n            GetConsoleMode(WINCONSOLE.out, &WINCONSOLE.originalMode.dwFlagOut);\n\n            if (!WINCONSOLE.isTermInfoConsole) {\n                b = AllocConsole();\n\n                if (!b)\n                    b = AttachConsole(ATTACH_PARENT_PROCESS);\n\n                if (getenv(\"NCGDB\") || getenv(\"NCURSES_CONSOLE2\")) {\n                    T((\"... will not buffer console\"));\n                } else {\n                    T((\"... creating console buffer\"));\n                    WINCONSOLE.hdl =\n                        CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,\n                                                  0,\n                                                  NULL,\n                                                  CONSOLE_TEXTMODE_BUFFER,\n                                                  NULL);\n                    buffered = TRUE;\n                }\n            }\n\n             \n            _setmode(fileno(stdin), _O_BINARY);\n            _setmode(fileno(stdout), _O_BINARY);\n\n            if (WINCONSOLE.hdl != INVALID_HANDLE_VALUE) {\n                WINCONSOLE.buffered = buffered;\n                _nc_console_get_SBI();\n                WINCONSOLE.save_SBI = WINCONSOLE.SBI;\n                if (!buffered) {\n                    save_original_screen();\n                    _nc_console_set_scrollback(FALSE, &WINCONSOLE.SBI);\n                }\n                GetConsoleCursorInfo(WINCONSOLE.hdl, &WINCONSOLE.save_CI);\n                T((\"... initial cursor is %svisible, %d%%\",\n                   (WINCONSOLE.save_CI.bVisible ? \"\" : \"not-\"),\n                   (int) WINCONSOLE.save_CI.dwSize));\n            }\n\n            WINCONSOLE.initialized = TRUE;\n            console_initialized = TRUE;\n        }\n        res = (WINCONSOLE.hdl != INVALID_HANDLE_VALUE);\n    }\n    returnBool(res);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}