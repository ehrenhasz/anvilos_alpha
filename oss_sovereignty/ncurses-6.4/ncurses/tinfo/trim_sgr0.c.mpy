{
  "module_name": "trim_sgr0.c",
  "hash_id": "e0b62aa31a5a08b8c757b296f9e3a541cebeeedc8d454847ca4198d2d1ed216f",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/trim_sgr0.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: trim_sgr0.c,v 1.21 2021/06/17 21:20:30 tom Exp $\")\n\n#undef CUR\n#define CUR tp->\n\n#define CSI       233\n#define ESC       033\t\t \n#define L_BRACK   '['\n\nstatic char *\nset_attribute_9(TERMTYPE2 *tp, int flag)\n{\n    const char *value;\n    char *result;\n\n    value = TIPARM_9(set_attributes, 0, 0, 0, 0, 0, 0, 0, 0, flag);\n    if (PRESENT(value))\n\tresult = strdup(value);\n    else\n\tresult = 0;\n    return result;\n}\n\nstatic int\nis_csi(const char *s)\n{\n    int result = 0;\n    if (s != 0) {\n\tif (UChar(s[0]) == CSI)\n\t    result = 1;\n\telse if (s[0] == ESC && s[1] == L_BRACK)\n\t    result = 2;\n    }\n    return result;\n}\n\nstatic char *\nskip_zero(char *s)\n{\n    if (s[0] == '0') {\n\tif (s[1] == ';')\n\t    s += 2;\n\telse if (isalpha(UChar(s[1])))\n\t    s += 1;\n    }\n    return s;\n}\n\nstatic const char *\nskip_delay(const char *s)\n{\n    if (s[0] == '$' && s[1] == '<') {\n\ts += 2;\n\twhile (isdigit(UChar(*s)) || *s == '/')\n\t    ++s;\n\tif (*s == '>')\n\t    ++s;\n    }\n    return s;\n}\n\n \nstatic bool\nrewrite_sgr(char *s, char *attr)\n{\n    if (s != 0) {\n\tif (PRESENT(attr)) {\n\t    size_t len_s = strlen(s);\n\t    size_t len_a = strlen(attr);\n\n\t    if (len_s > len_a && !strncmp(attr, s, len_a)) {\n\t\tunsigned n;\n\t\tTR(TRACE_DATABASE, (\"rewrite:\\n\\t%s\", s));\n\t\tfor (n = 0; n < len_s - len_a; ++n) {\n\t\t    s[n] = s[n + len_a];\n\t\t}\n\t\t_nc_STRCPY(s + n, attr, strlen(s) + 1);\n\t\tTR(TRACE_DATABASE, (\"to:\\n\\t%s\", s));\n\t    }\n\t}\n\treturn TRUE;\n    }\n    return FALSE;\t\t \n}\n\nstatic bool\nsimilar_sgr(char *a, char *b)\n{\n    bool result = FALSE;\n    if (a != 0 && b != 0) {\n\tint csi_a = is_csi(a);\n\tint csi_b = is_csi(b);\n\tsize_t len_a;\n\tsize_t len_b;\n\n\tTR(TRACE_DATABASE, (\"similar_sgr:\\n\\t%s\\n\\t%s\",\n\t\t\t    _nc_visbuf2(1, a),\n\t\t\t    _nc_visbuf2(2, b)));\n\tif (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {\n\t    a += csi_a;\n\t    b += csi_b;\n\t    if (*a != *b) {\n\t\ta = skip_zero(a);\n\t\tb = skip_zero(b);\n\t    }\n\t}\n\tlen_a = strlen(a);\n\tlen_b = strlen(b);\n\tif (len_a && len_b) {\n\t    if (len_a > len_b)\n\t\tresult = (strncmp(a, b, len_b) == 0);\n\t    else\n\t\tresult = (strncmp(a, b, len_a) == 0);\n\t}\n\tTR(TRACE_DATABASE, (\"...similar_sgr: %d\\n\\t%s\\n\\t%s\", result,\n\t\t\t    _nc_visbuf2(1, a),\n\t\t\t    _nc_visbuf2(2, b)));\n    }\n    return result;\n}\n\nstatic unsigned\nchop_out(char *string, unsigned i, unsigned j)\n{\n    TR(TRACE_DATABASE, (\"chop_out %d..%d from %s\", i, j, _nc_visbuf(string)));\n    while (string[j] != '\\0') {\n\tstring[i++] = string[j++];\n    }\n    string[i] = '\\0';\n    return i;\n}\n\n \nstatic unsigned\ncompare_part(const char *part, const char *full)\n{\n    const char *next_part;\n    const char *next_full;\n    unsigned used_full = 0;\n    unsigned used_delay = 0;\n\n    while (*part != 0) {\n\tif (*part != *full) {\n\t    used_full = 0;\n\t    break;\n\t}\n\n\t \n\tif (used_delay != 0) {\n\t    used_full += used_delay;\n\t    used_delay = 0;\n\t}\n\tif (*part == '$' && *full == '$') {\n\t    next_part = skip_delay(part);\n\t    next_full = skip_delay(full);\n\t    if (next_part != part && next_full != full) {\n\t\tused_delay += (unsigned) (next_full - full);\n\t\tfull = next_full;\n\t\tpart = next_part;\n\t\tcontinue;\n\t    }\n\t}\n\t++used_full;\n\t++part;\n\t++full;\n    }\n    return used_full;\n}\n\n \nNCURSES_EXPORT(char *)\n_nc_trim_sgr0(TERMTYPE2 *tp)\n{\n    char *result = exit_attribute_mode;\n\n    T((T_CALLED(\"_nc_trim_sgr0()\")));\n\n    if (PRESENT(exit_attribute_mode)\n\t&& PRESENT(set_attributes)) {\n\tbool found = FALSE;\n\tchar *on = set_attribute_9(tp, 1);\n\tchar *off = set_attribute_9(tp, 0);\n\tchar *end = strdup(exit_attribute_mode);\n\tchar *tmp;\n\tsize_t i, j, k;\n\n\tTR(TRACE_DATABASE, (\"checking if we can trim sgr0 based on sgr\"));\n\tTR(TRACE_DATABASE, (\"sgr0       %s\", _nc_visbuf(end)));\n\tTR(TRACE_DATABASE, (\"sgr(9:off) %s\", _nc_visbuf(off)));\n\tTR(TRACE_DATABASE, (\"sgr(9:on)  %s\", _nc_visbuf(on)));\n\n\tif (!rewrite_sgr(on, enter_alt_charset_mode)\n\t    || !rewrite_sgr(off, exit_alt_charset_mode)\n\t    || !rewrite_sgr(end, exit_alt_charset_mode)) {\n\t    FreeIfNeeded(off);\n\t} else if (similar_sgr(off, end)\n\t\t   && !similar_sgr(off, on)) {\n\t    TR(TRACE_DATABASE, (\"adjusting sgr(9:off) : %s\", _nc_visbuf(off)));\n\t    result = off;\n\t     \n\t    if (PRESENT(exit_alt_charset_mode)) {\n\t\tTR(TRACE_DATABASE, (\"scan for rmacs %s\", _nc_visbuf(exit_alt_charset_mode)));\n\t\tj = strlen(off);\n\t\tk = strlen(exit_alt_charset_mode);\n\t\tif (j > k) {\n\t\t    for (i = 0; i <= (j - k); ++i) {\n\t\t\tunsigned k2 = compare_part(exit_alt_charset_mode,\n\t\t\t\t\t\t   off + i);\n\t\t\tif (k2 != 0) {\n\t\t\t    found = TRUE;\n\t\t\t    chop_out(off, (unsigned) i, (unsigned) (i + k2));\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t     \n\t    if (!found) {\n\t\tif ((i = (size_t) is_csi(off)) != 0\n\t\t    && off[strlen(off) - 1] == 'm') {\n\t\t    TR(TRACE_DATABASE, (\"looking for SGR 10 in %s\",\n\t\t\t\t\t_nc_visbuf(off)));\n\t\t    tmp = skip_zero(off + i);\n\t\t    if (tmp[0] == '1'\n\t\t\t&& skip_zero(tmp + 1) != tmp + 1) {\n\t\t\ti = (size_t) (tmp - off);\n\t\t\tif (off[i - 1] == ';')\n\t\t\t    i--;\n\t\t\tj = (size_t) (skip_zero(tmp + 1) - off);\n\t\t\t(void) chop_out(off, (unsigned) i, (unsigned) j);\n\t\t\tfound = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!found\n\t\t&& (tmp = strstr(end, off)) != 0\n\t\t&& strcmp(end, off) != 0) {\n\t\ti = (size_t) (tmp - end);\n\t\tj = strlen(off);\n\t\ttmp = strdup(end);\n\t\tchop_out(tmp, (unsigned) i, (unsigned) j);\n\t\tfree(off);\n\t\tresult = tmp;\n\t    }\n\t    TR(TRACE_DATABASE, (\"...adjusted sgr0 : %s\", _nc_visbuf(result)));\n\t    if (!strcmp(result, exit_attribute_mode)) {\n\t\tTR(TRACE_DATABASE, (\"...same result, discard\"));\n\t\tfree(result);\n\t\tresult = exit_attribute_mode;\n\t    }\n\t} else {\n\t     \n\t    free(off);\n\t}\n\tFreeIfNeeded(end);\n\tFreeIfNeeded(on);\n    } else {\n\t \n    }\n\n    returnPtr(result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}