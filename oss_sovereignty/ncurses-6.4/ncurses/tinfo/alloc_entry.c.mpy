{
  "module_name": "alloc_entry.c",
  "hash_id": "aea37f877fc46b0aa8dc112b399658d07d9137cd061639bac41e9c663e35d2c5",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/alloc_entry.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#include <tic.h>\n\nMODULE_ID(\"$Id: alloc_entry.c,v 1.77 2022/10/15 19:37:33 tom Exp $\")\n\n#define ABSENT_OFFSET    -1\n#define CANCELLED_OFFSET -2\n\nstatic char *stringbuf;\t\t \nstatic size_t next_free;\t \n\nNCURSES_EXPORT(void)\n_nc_init_entry(ENTRY * const tp)\n \n{\n    DEBUG(2, (T_CALLED(\"_nc_init_entry(tp=%p)\"), (void *) tp));\n\n    if (tp == NULL) {\n#if NO_LEAKS\n\tif (stringbuf != NULL) {\n\t    FreeAndNull(stringbuf);\n\t}\n\treturn;\n#else\n\t_nc_err_abort(\"_nc_init_entry called without initialization\");\n#endif\n    }\n\n    if (stringbuf == NULL)\n\tTYPE_CALLOC(char, (size_t) MAX_ENTRY_SIZE, stringbuf);\n\n    next_free = 0;\n\n    _nc_init_termtype(&(tp->tterm));\n\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\nNCURSES_EXPORT(ENTRY *)\n_nc_copy_entry(ENTRY * oldp)\n{\n    ENTRY *newp;\n\n    DEBUG(2, (T_CALLED(\"_nc_copy_entry(oldp=%p)\"), (void *) oldp));\n\n    newp = typeCalloc(ENTRY, 1);\n    if (newp != NULL) {\n\t*newp = *oldp;\n\t_nc_copy_termtype2(&(newp->tterm), &(oldp->tterm));\n    }\n\n    DEBUG(2, (T_RETURN(\"%p\"), (void *) newp));\n    return (newp);\n}\n\n \nNCURSES_EXPORT(char *)\n_nc_save_str(const char *string)\n{\n    char *result = 0;\n    size_t old_next_free = next_free;\n\n    if (stringbuf != NULL) {\n\tsize_t len;\n\n\tif (!VALID_STRING(string))\n\t    string = \"\";\n\tlen = strlen(string) + 1;\n\n\tif (len == 1 && next_free != 0) {\n\t     \n\t    if (next_free < MAX_ENTRY_SIZE) {\n\t\tresult = (stringbuf + next_free - 1);\n\t    }\n\t} else if (next_free + len < MAX_ENTRY_SIZE) {\n\t    _nc_STRCPY(&stringbuf[next_free], string, MAX_ENTRY_SIZE);\n\t    DEBUG(7, (\"Saved string %s\", _nc_visbuf(string)));\n\t    DEBUG(7, (\"at location %d\", (int) next_free));\n\t    next_free += len;\n\t    result = (stringbuf + old_next_free);\n\t} else {\n\t    _nc_warning(\"Too much data, some is lost: %s\", string);\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(void)\n_nc_wrap_entry(ENTRY * const ep, bool copy_strings)\n \n{\n    int offsets[MAX_ENTRY_SIZE / sizeof(short)];\n    int useoffsets[MAX_USES];\n    unsigned i, n;\n    unsigned nuses;\n    TERMTYPE2 *tp;\n\n    DEBUG(2, (T_CALLED(\"_nc_wrap_entry(ep=%p, copy_strings=%d)\"), (void *)\n\t      ep, copy_strings));\n    if (ep == NULL || stringbuf == NULL)\n\t_nc_err_abort(\"_nc_wrap_entry called without initialization\");\n\n    nuses = ep->nuses;\n    tp = &(ep->tterm);\n    if (copy_strings) {\n\tnext_free = 0;\t\t \n\n\t \n\ttp->term_names = _nc_save_str(tp->term_names);\n\tfor_each_string(i, tp) {\n\t    if (tp->Strings[i] != ABSENT_STRING &&\n\t\ttp->Strings[i] != CANCELLED_STRING) {\n\t\ttp->Strings[i] = _nc_save_str(tp->Strings[i]);\n\t    }\n\t}\n\n\tfor (i = 0; i < nuses; i++) {\n\t    if (ep->uses[i].name == 0) {\n\t\tep->uses[i].name = _nc_save_str(ep->uses[i].name);\n\t    }\n\t}\n\n\tfree(tp->str_table);\n    }\n\n    assert(tp->term_names >= stringbuf);\n    n = (unsigned) (tp->term_names - stringbuf);\n    for_each_string(i, &(ep->tterm)) {\n\tif (i < SIZEOF(offsets)) {\n\t    if (tp->Strings[i] == ABSENT_STRING) {\n\t\toffsets[i] = ABSENT_OFFSET;\n\t    } else if (tp->Strings[i] == CANCELLED_STRING) {\n\t\toffsets[i] = CANCELLED_OFFSET;\n\t    } else {\n\t\toffsets[i] = (int) (tp->Strings[i] - stringbuf);\n\t    }\n\t}\n    }\n\n    for (i = 0; i < nuses; i++) {\n\tif (ep->uses[i].name == 0)\n\t    useoffsets[i] = ABSENT_OFFSET;\n\telse\n\t    useoffsets[i] = (int) (ep->uses[i].name - stringbuf);\n    }\n\n    TYPE_MALLOC(char, next_free, tp->str_table);\n    (void) memcpy(tp->str_table, stringbuf, next_free);\n\n    tp->term_names = tp->str_table + n;\n    for_each_string(i, &(ep->tterm)) {\n\tif (i < SIZEOF(offsets)) {\n\t    if (offsets[i] == ABSENT_OFFSET) {\n\t\ttp->Strings[i] = ABSENT_STRING;\n\t    } else if (offsets[i] == CANCELLED_OFFSET) {\n\t\ttp->Strings[i] = CANCELLED_STRING;\n\t    } else {\n\t\ttp->Strings[i] = tp->str_table + offsets[i];\n\t    }\n\t}\n    }\n\n#if NCURSES_XNAMES\n    if (!copy_strings) {\n\tif ((n = (unsigned) NUM_EXT_NAMES(tp)) != 0) {\n\t    if (n < SIZEOF(offsets)) {\n\t\tsize_t length = 0;\n\t\tsize_t offset;\n\t\tfor (i = 0; i < n; i++) {\n\t\t    length += strlen(tp->ext_Names[i]) + 1;\n\t\t    offsets[i] = (int) (tp->ext_Names[i] - stringbuf);\n\t\t}\n\t\tTYPE_MALLOC(char, length, tp->ext_str_table);\n\t\tfor (i = 0, offset = 0; i < n; i++) {\n\t\t    tp->ext_Names[i] = tp->ext_str_table + offset;\n\t\t    _nc_STRCPY(tp->ext_Names[i],\n\t\t\t       stringbuf + offsets[i],\n\t\t\t       length - offset);\n\t\t    offset += strlen(tp->ext_Names[i]) + 1;\n\t\t}\n\t    }\n\t}\n    }\n#endif\n\n    for (i = 0; i < nuses; i++) {\n\tif (useoffsets[i] == ABSENT_OFFSET) {\n\t    ep->uses[i].name = 0;\n\t} else {\n\t    ep->uses[i].name = strdup(tp->str_table + useoffsets[i]);\n\t}\n    }\n    DEBUG(2, (T_RETURN(\"\")));\n}\n\nNCURSES_EXPORT(void)\n_nc_merge_entry(ENTRY * const target, ENTRY * const source)\n \n{\n    TERMTYPE2 *to = &(target->tterm);\n    TERMTYPE2 *from = &(source->tterm);\n#if NCURSES_XNAMES\n    TERMTYPE2 copy;\n    size_t str_size;\n    char *str_table;\n#endif\n    unsigned i;\n\n    if (source == 0 || from == 0 || target == 0 || to == 0)\n\treturn;\n\n#if NCURSES_XNAMES\n    _nc_copy_termtype2(&copy, from);\n    from = &copy;\n    _nc_align_termtype(to, from);\n     \n    str_size = strlen(to->term_names) + 1;\n    for_each_string(i, from) {\n\tif (VALID_STRING(from->Strings[i]))\n\t    str_size += strlen(from->Strings[i]) + 1;\n    }\n    for_each_string(i, to) {\n\tif (VALID_STRING(to->Strings[i]))\n\t    str_size += strlen(to->Strings[i]) + 1;\n    }\n     \n    if (str_size != 0) {\n\tchar *str_copied;\n\tif ((str_table = malloc(str_size)) == NULL)\n\t    _nc_err_abort(MSG_NO_MEMORY);\n\tstr_copied = str_table;\n\tstrcpy(str_copied, to->term_names);\n\tto->term_names = str_copied;\n\tstr_copied += strlen(str_copied) + 1;\n\tfor_each_string(i, from) {\n\t    if (VALID_STRING(from->Strings[i])) {\n\t\tstrcpy(str_copied, from->Strings[i]);\n\t\tfrom->Strings[i] = str_copied;\n\t\tstr_copied += strlen(str_copied) + 1;\n\t    }\n\t}\n\tfor_each_string(i, to) {\n\t    if (VALID_STRING(to->Strings[i])) {\n\t\tstrcpy(str_copied, to->Strings[i]);\n\t\tto->Strings[i] = str_copied;\n\t\tstr_copied += strlen(str_copied) + 1;\n\t    }\n\t}\n\tfree(to->str_table);\n\tto->str_table = str_table;\n\tfree(from->str_table);\n    }\n     \n    str_size = 0;\n    for (i = 0; i < NUM_EXT_NAMES(from); ++i) {\n\tif (VALID_STRING(from->ext_Names[i]))\n\t    str_size += strlen(from->ext_Names[i]) + 1;\n    }\n    for (i = 0; i < NUM_EXT_NAMES(to); ++i) {\n\tif (VALID_STRING(to->ext_Names[i]))\n\t    str_size += strlen(to->ext_Names[i]) + 1;\n    }\n     \n    if (str_size != 0) {\n\tchar *str_copied;\n\tif ((str_table = malloc(str_size)) == NULL)\n\t    _nc_err_abort(MSG_NO_MEMORY);\n\tstr_copied = str_table;\n\tfor (i = 0; i < NUM_EXT_NAMES(from); ++i) {\n\t    if (VALID_STRING(from->ext_Names[i])) {\n\t\tstrcpy(str_copied, from->ext_Names[i]);\n\t\tfrom->ext_Names[i] = str_copied;\n\t\tstr_copied += strlen(str_copied) + 1;\n\t    }\n\t}\n\tfor (i = 0; i < NUM_EXT_NAMES(to); ++i) {\n\t    if (VALID_STRING(to->ext_Names[i])) {\n\t\tstrcpy(str_copied, to->ext_Names[i]);\n\t\tto->ext_Names[i] = str_copied;\n\t\tstr_copied += strlen(str_copied) + 1;\n\t    }\n\t}\n\tfree(to->ext_str_table);\n\tto->ext_str_table = str_table;\n\tfree(from->ext_str_table);\n    }\n#endif\n    for_each_boolean(i, from) {\n\tif (to->Booleans[i] != (NCURSES_SBOOL) CANCELLED_BOOLEAN) {\n\t    int mergebool = from->Booleans[i];\n\n\t    if (mergebool == CANCELLED_BOOLEAN)\n\t\tto->Booleans[i] = FALSE;\n\t    else if (mergebool == TRUE)\n\t\tto->Booleans[i] = (NCURSES_SBOOL) mergebool;\n\t}\n    }\n\n    for_each_number(i, from) {\n\tif (to->Numbers[i] != CANCELLED_NUMERIC) {\n\t    int mergenum = from->Numbers[i];\n\n\t    if (mergenum == CANCELLED_NUMERIC)\n\t\tto->Numbers[i] = ABSENT_NUMERIC;\n\t    else if (mergenum != ABSENT_NUMERIC)\n\t\tto->Numbers[i] = (NCURSES_INT2) mergenum;\n\t}\n    }\n\n     \n    for_each_string(i, from) {\n\tif (to->Strings[i] != CANCELLED_STRING) {\n\t    char *mergestring = from->Strings[i];\n\n\t    if (mergestring == CANCELLED_STRING)\n\t\tto->Strings[i] = ABSENT_STRING;\n\t    else if (mergestring != ABSENT_STRING)\n\t\tto->Strings[i] = mergestring;\n\t}\n    }\n#if NCURSES_XNAMES\n     \n    free(copy.Booleans);\n    free(copy.Numbers);\n    free(copy.Strings);\n    free(copy.ext_Names);\n#endif\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_alloc_entry_leaks(void)\n{\n    if (stringbuf != NULL) {\n\tFreeAndNull(stringbuf);\n    }\n    next_free = 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}