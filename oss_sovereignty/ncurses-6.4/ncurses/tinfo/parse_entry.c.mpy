{
  "module_name": "parse_entry.c",
  "hash_id": "5a12fcc756834490df7fb3108b0df6d91947528ed72de43ce5b387b004f07cee",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/parse_entry.c",
  "human_readable_source": " \n\n \n\n \n\n#define __INTERNAL_CAPS_VISIBLE\n#include <curses.priv.h>\n\n#include <ctype.h>\n#include <tic.h>\n\nMODULE_ID(\"$Id: parse_entry.c,v 1.107 2022/05/08 00:11:44 tom Exp $\")\n\n#ifdef LINT\nstatic short const parametrized[] =\n{0};\n#else\n#include <parametrized.h>\n#endif\n\nstatic void postprocess_termcap(TERMTYPE2 *, bool);\nstatic void postprocess_terminfo(TERMTYPE2 *);\nstatic struct name_table_entry const *lookup_fullname(const char *name);\n\n#if NCURSES_XNAMES\n\nstatic struct name_table_entry const *\n_nc_extend_names(ENTRY * entryp, const char *name, int token_type)\n{\n    static struct name_table_entry temp;\n    TERMTYPE2 *tp = &(entryp->tterm);\n    unsigned offset = 0;\n    unsigned actual;\n    unsigned tindex;\n    unsigned first, last, n;\n    bool found;\n\n    switch (token_type) {\n    case BOOLEAN:\n\tfirst = 0;\n\tlast = tp->ext_Booleans;\n\toffset = tp->ext_Booleans;\n\ttindex = tp->num_Booleans;\n\tbreak;\n    case NUMBER:\n\tfirst = tp->ext_Booleans;\n\tlast = tp->ext_Numbers + first;\n\toffset = (unsigned) (tp->ext_Booleans + tp->ext_Numbers);\n\ttindex = tp->num_Numbers;\n\tbreak;\n    case STRING:\n\tfirst = (unsigned) (tp->ext_Booleans + tp->ext_Numbers);\n\tlast = tp->ext_Strings + first;\n\toffset = (unsigned) (tp->ext_Booleans + tp->ext_Numbers + tp->ext_Strings);\n\ttindex = tp->num_Strings;\n\tbreak;\n    case CANCEL:\n\tactual = NUM_EXT_NAMES(tp);\n\tfor (n = 0; n < actual; n++) {\n\t    if (!strcmp(name, tp->ext_Names[n])) {\n\t\tif (n > (unsigned) (tp->ext_Booleans + tp->ext_Numbers)) {\n\t\t    token_type = STRING;\n\t\t} else if (n > tp->ext_Booleans) {\n\t\t    token_type = NUMBER;\n\t\t} else {\n\t\t    token_type = BOOLEAN;\n\t\t}\n\t\treturn _nc_extend_names(entryp, name, token_type);\n\t    }\n\t}\n\t \n\treturn _nc_extend_names(entryp, name, STRING);\n    default:\n\treturn 0;\n    }\n\n     \n    for (n = first, found = FALSE; n < last; n++) {\n\tint cmp = strcmp(tp->ext_Names[n], name);\n\tif (cmp == 0)\n\t    found = TRUE;\n\tif (cmp >= 0) {\n\t    offset = n;\n\t    tindex = n - first;\n\t    switch (token_type) {\n\t    case BOOLEAN:\n\t\ttindex += BOOLCOUNT;\n\t\tbreak;\n\t    case NUMBER:\n\t\ttindex += NUMCOUNT;\n\t\tbreak;\n\t    case STRING:\n\t\ttindex += STRCOUNT;\n\t\tbreak;\n\t    }\n\t    break;\n\t}\n    }\n\n#define for_each_value(max) \\\n\tfor (last = (unsigned) (max - 1); last > tindex; last--)\n\n    if (!found) {\n\tswitch (token_type) {\n\tcase BOOLEAN:\n\t    tp->ext_Booleans++;\n\t    tp->num_Booleans++;\n\t    TYPE_REALLOC(NCURSES_SBOOL, tp->num_Booleans, tp->Booleans);\n\t    for_each_value(tp->num_Booleans)\n\t\ttp->Booleans[last] = tp->Booleans[last - 1];\n\t    break;\n\tcase NUMBER:\n\t    tp->ext_Numbers++;\n\t    tp->num_Numbers++;\n\t    TYPE_REALLOC(NCURSES_INT2, tp->num_Numbers, tp->Numbers);\n\t    for_each_value(tp->num_Numbers)\n\t\ttp->Numbers[last] = tp->Numbers[last - 1];\n\t    break;\n\tcase STRING:\n\t    tp->ext_Strings++;\n\t    tp->num_Strings++;\n\t    TYPE_REALLOC(char *, tp->num_Strings, tp->Strings);\n\t    for_each_value(tp->num_Strings)\n\t\ttp->Strings[last] = tp->Strings[last - 1];\n\t    break;\n\t}\n\tactual = NUM_EXT_NAMES(tp);\n\tTYPE_REALLOC(char *, actual, tp->ext_Names);\n\twhile (--actual > offset)\n\t    tp->ext_Names[actual] = tp->ext_Names[actual - 1];\n\ttp->ext_Names[offset] = _nc_save_str(name);\n    }\n\n    temp.nte_name = tp->ext_Names[offset];\n    temp.nte_type = token_type;\n    temp.nte_index = (short) tindex;\n    temp.nte_link = -1;\n\n    return &temp;\n}\n\nstatic const char *\nusertype2s(int mask)\n{\n    const char *result = \"unknown\";\n    if (mask & (1 << BOOLEAN)) {\n\tresult = \"boolean\";\n    } else if (mask & (1 << NUMBER)) {\n\tresult = \"number\";\n    } else if (mask & (1 << STRING)) {\n\tresult = \"string\";\n    }\n    return result;\n}\n\nstatic bool\nexpected_type(const char *name, int token_type, bool silent)\n{\n    struct user_table_entry const *entry = _nc_find_user_entry(name);\n    bool result = TRUE;\n    if ((entry != 0) && (token_type != CANCEL)) {\n\tint have_type = (1 << token_type);\n\tif (!(entry->ute_type & have_type)) {\n\t    if (!silent)\n\t\t_nc_warning(\"expected %s-type for %s, have %s\",\n\t\t\t    usertype2s(entry->ute_type),\n\t\t\t    name,\n\t\t\t    usertype2s(have_type));\n\t    result = FALSE;\n\t}\n    }\n    return result;\n}\n#endif  \n\n \nstatic bool\nvalid_entryname(const char *name)\n{\n    bool result = TRUE;\n    bool first = TRUE;\n    int ch;\n    while ((ch = UChar(*name++)) != '\\0') {\n\tif (ch <= ' ' || ch > '~' || strchr(\"/\\\\|=,:\", ch) != NULL) {\n\t    result = FALSE;\n\t    break;\n\t}\n\tif (!first && strchr(\"#@\", ch) != NULL) {\n\t    result = FALSE;\n\t    break;\n\t}\n\tfirst = FALSE;\n    }\n    return result;\n}\n\n \n\n#define BAD_TC_USAGE if (!bad_tc_usage) \\\n \t{ bad_tc_usage = TRUE; \\\n\t _nc_warning(\"Legacy termcap allows only a trailing tc= clause\"); }\n\n#define MAX_NUMBER MAX_OF_TYPE(NCURSES_INT2)\n\nNCURSES_EXPORT(int)\n_nc_parse_entry(ENTRY * entryp, int literal, bool silent)\n{\n    int token_type;\n    struct name_table_entry const *entry_ptr;\n    char *ptr, *base;\n    const char *name;\n    bool bad_tc_usage = FALSE;\n\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"_nc_parse_entry(entry=%p, literal=%d, silent=%d)\"),\n\t(void *) entryp, literal, silent));\n\n    token_type = _nc_get_token(silent);\n\n    if (token_type == EOF)\n\treturnDB(EOF);\n    if (token_type != NAMES)\n\t_nc_err_abort(\"Entry does not start with terminal names in column one\");\n\n    _nc_init_entry(entryp);\n\n    entryp->cstart = _nc_comment_start;\n    entryp->cend = _nc_comment_end;\n    entryp->startline = _nc_start_line;\n    DEBUG(2, (\"Comment range is %ld to %ld\", entryp->cstart, entryp->cend));\n\n     \n#define ok_TC2(s) (isgraph(UChar(s)) && (s) != '|')\n    ptr = _nc_curr_token.tk_name;\n    if (_nc_syntax == SYN_TERMCAP\n#if NCURSES_XNAMES\n\t&& !_nc_user_definable\n#endif\n\t) {\n\tif (ok_TC2(ptr[0]) && ok_TC2(ptr[1]) && (ptr[2] == '|')) {\n\t    ptr += 3;\n\t    _nc_curr_token.tk_name[2] = '\\0';\n\t}\n    }\n\n    entryp->tterm.str_table = entryp->tterm.term_names = _nc_save_str(ptr);\n\n    if (entryp->tterm.str_table == 0)\n\treturnDB(ERR);\n\n    DEBUG(2, (\"Starting '%s'\", ptr));\n\n     \n    name = _nc_first_name(entryp->tterm.term_names);\n    if (!valid_entryname(name)) {\n\t_nc_warning(\"invalid entry name \\\"%s\\\"\", name);\n\tname = \"invalid\";\n    }\n    _nc_set_type(name);\n\n     \n    for (base = entryp->tterm.term_names; (ptr = strchr(base, '|')) != 0;\n\t base = ptr + 1) {\n\tif (ptr - base > MAX_ALIAS) {\n\t    _nc_warning(\"%s `%.*s' may be too long\",\n\t\t\t(base == entryp->tterm.term_names)\n\t\t\t? \"primary name\"\n\t\t\t: \"alias\",\n\t\t\t(int) (ptr - base), base);\n\t}\n    }\n\n    entryp->nuses = 0;\n\n    for (token_type = _nc_get_token(silent);\n\t token_type != EOF && token_type != NAMES;\n\t token_type = _nc_get_token(silent)) {\n\tbool is_use = (strcmp(_nc_curr_token.tk_name, \"use\") == 0);\n\tbool is_tc = !is_use && (strcmp(_nc_curr_token.tk_name, \"tc\") == 0);\n\tif (is_use || is_tc) {\n\t    if (!VALID_STRING(_nc_curr_token.tk_valstring)\n\t\t|| _nc_curr_token.tk_valstring[0] == '\\0') {\n\t\t_nc_warning(\"missing name for use-clause\");\n\t\tcontinue;\n\t    } else if (!valid_entryname(_nc_curr_token.tk_valstring)) {\n\t\t_nc_warning(\"invalid name for use-clause \\\"%s\\\"\",\n\t\t\t    _nc_curr_token.tk_valstring);\n\t\tcontinue;\n\t    } else if (entryp->nuses >= MAX_USES) {\n\t\t_nc_warning(\"too many use-clauses, ignored \\\"%s\\\"\",\n\t\t\t    _nc_curr_token.tk_valstring);\n\t\tcontinue;\n\t    }\n\t    entryp->uses[entryp->nuses].name = _nc_save_str(_nc_curr_token.tk_valstring);\n\t    entryp->uses[entryp->nuses].line = _nc_curr_line;\n\t    entryp->nuses++;\n\t    if (entryp->nuses > 1 && is_tc) {\n\t\tBAD_TC_USAGE\n\t    }\n\t} else {\n\t     \n\t    entry_ptr = _nc_find_entry(_nc_curr_token.tk_name,\n\t\t\t\t       _nc_get_hash_table(_nc_syntax));\n\n\t     \n\t    if (entry_ptr == NOTFOUND) {\n\t\tconst struct alias *ap;\n\n\t\tif (_nc_syntax == SYN_TERMCAP) {\n\t\t    if (entryp->nuses != 0) {\n\t\t\tBAD_TC_USAGE\n\t\t    }\n\t\t    for (ap = _nc_get_alias_table(TRUE); ap->from; ap++)\n\t\t\tif (strcmp(ap->from, _nc_curr_token.tk_name) == 0) {\n\t\t\t    if (ap->to == (char *) 0) {\n\t\t\t\t_nc_warning(\"%s (%s termcap extension) ignored\",\n\t\t\t\t\t    ap->from, ap->source);\n\t\t\t\tgoto nexttok;\n\t\t\t    }\n\n\t\t\t    entry_ptr = _nc_find_entry(ap->to,\n\t\t\t\t\t\t       _nc_get_hash_table(TRUE));\n\t\t\t    if (entry_ptr && !silent)\n\t\t\t\t_nc_warning(\"%s (%s termcap extension) aliased to %s\",\n\t\t\t\t\t    ap->from, ap->source, ap->to);\n\t\t\t    break;\n\t\t\t}\n\t\t} else {\t \n\t\t    for (ap = _nc_get_alias_table(FALSE); ap->from; ap++)\n\t\t\tif (strcmp(ap->from, _nc_curr_token.tk_name) == 0) {\n\t\t\t    if (ap->to == (char *) 0) {\n\t\t\t\t_nc_warning(\"%s (%s terminfo extension) ignored\",\n\t\t\t\t\t    ap->from, ap->source);\n\t\t\t\tgoto nexttok;\n\t\t\t    }\n\n\t\t\t    entry_ptr = _nc_find_entry(ap->to,\n\t\t\t\t\t\t       _nc_get_hash_table(FALSE));\n\t\t\t    if (entry_ptr && !silent)\n\t\t\t\t_nc_warning(\"%s (%s terminfo extension) aliased to %s\",\n\t\t\t\t\t    ap->from, ap->source, ap->to);\n\t\t\t    break;\n\t\t\t}\n\n\t\t    if (entry_ptr == NOTFOUND) {\n\t\t\tentry_ptr = lookup_fullname(_nc_curr_token.tk_name);\n\t\t    }\n\t\t}\n\t    }\n#if NCURSES_XNAMES\n\t     \n\t    if (entry_ptr == NOTFOUND\n\t\t&& _nc_user_definable) {\n\t\tif (expected_type(_nc_curr_token.tk_name, token_type, silent)) {\n\t\t    if ((entry_ptr = _nc_extend_names(entryp,\n\t\t\t\t\t\t      _nc_curr_token.tk_name,\n\t\t\t\t\t\t      token_type)) != 0) {\n\t\t\tif (_nc_tracing >= DEBUG_LEVEL(1)) {\n\t\t\t    _nc_warning(\"extended capability '%s'\",\n\t\t\t\t\t_nc_curr_token.tk_name);\n\t\t\t}\n\t\t    }\n\t\t} else {\n\t\t     \n\t\t    continue;\n\t\t}\n\t    }\n#endif  \n\n\t     \n\t    if (entry_ptr == NOTFOUND) {\n\t\tif (!silent)\n\t\t    _nc_warning(\"unknown capability '%s'\",\n\t\t\t\t_nc_curr_token.tk_name);\n\t\tcontinue;\n\t    }\n\n\t     \n\t    if (token_type == CANCEL) {\n\t\t \n\t\tif (!strcmp(\"ma\", _nc_curr_token.tk_name)) {\n\t\t    entry_ptr = _nc_find_type_entry(\"ma\", NUMBER,\n\t\t\t\t\t\t    _nc_syntax != 0);\n\t\t    assert(entry_ptr != 0);\n\t\t}\n\t    } else if (entry_ptr->nte_type != token_type) {\n\t\t \n\n\t\tif (token_type == NUMBER\n\t\t    && !strcmp(\"ma\", _nc_curr_token.tk_name)) {\n\t\t     \n\t\t    entry_ptr = _nc_find_type_entry(\"ma\", NUMBER,\n\t\t\t\t\t\t    _nc_syntax != 0);\n\t\t    assert(entry_ptr != 0);\n\n\t\t} else if (token_type == STRING\n\t\t\t   && !strcmp(\"MT\", _nc_curr_token.tk_name)) {\n\t\t     \n\t\t    entry_ptr = _nc_find_type_entry(\"MT\", STRING,\n\t\t\t\t\t\t    _nc_syntax != 0);\n\t\t    assert(entry_ptr != 0);\n\n\t\t} else if (token_type == BOOLEAN\n\t\t\t   && entry_ptr->nte_type == STRING) {\n\t\t     \n\t\t    token_type = STRING;\n\t\t} else {\n\t\t     \n\t\t    if (!silent) {\n\t\t\tconst char *type_name;\n\t\t\tswitch (entry_ptr->nte_type) {\n\t\t\tcase BOOLEAN:\n\t\t\t    type_name = \"boolean\";\n\t\t\t    break;\n\t\t\tcase STRING:\n\t\t\t    type_name = \"string\";\n\t\t\t    break;\n\t\t\tcase NUMBER:\n\t\t\t    type_name = \"numeric\";\n\t\t\t    break;\n\t\t\tdefault:\n\t\t\t    type_name = \"unknown\";\n\t\t\t    break;\n\t\t\t}\n\t\t\t_nc_warning(\"wrong type used for %s capability '%s'\",\n\t\t\t\t    type_name, _nc_curr_token.tk_name);\n\t\t    }\n\t\t    continue;\n\t\t}\n\t    }\n\n\t     \n\t    switch (token_type) {\n\t    case CANCEL:\n\t\tswitch (entry_ptr->nte_type) {\n\t\tcase BOOLEAN:\n\t\t    entryp->tterm.Booleans[entry_ptr->nte_index] = CANCELLED_BOOLEAN;\n\t\t    break;\n\n\t\tcase NUMBER:\n\t\t    entryp->tterm.Numbers[entry_ptr->nte_index] = CANCELLED_NUMERIC;\n\t\t    break;\n\n\t\tcase STRING:\n\t\t    entryp->tterm.Strings[entry_ptr->nte_index] = CANCELLED_STRING;\n\t\t    break;\n\t\t}\n\t\tbreak;\n\n\t    case BOOLEAN:\n\t\tentryp->tterm.Booleans[entry_ptr->nte_index] = TRUE;\n\t\tbreak;\n\n\t    case NUMBER:\n#if !NCURSES_EXT_NUMBERS\n\t\tif (_nc_curr_token.tk_valnumber > MAX_NUMBER) {\n\t\t    entryp->tterm.Numbers[entry_ptr->nte_index] = MAX_NUMBER;\n\t\t} else\n#endif\n\t\t{\n\t\t    entryp->tterm.Numbers[entry_ptr->nte_index] =\n\t\t\t(NCURSES_INT2) _nc_curr_token.tk_valnumber;\n\t\t}\n\t\tbreak;\n\n\t    case STRING:\n\t\tptr = _nc_curr_token.tk_valstring;\n\t\tif (_nc_syntax == SYN_TERMCAP) {\n\t\t    int n = entry_ptr->nte_index;\n\t\t    ptr = _nc_captoinfo(_nc_curr_token.tk_name,\n\t\t\t\t\tptr,\n\t\t\t\t\t(n < (int) SIZEOF(parametrized))\n\t\t\t\t\t? parametrized[n]\n\t\t\t\t\t: 0);\n\t\t}\n\t\tentryp->tterm.Strings[entry_ptr->nte_index] = _nc_save_str(ptr);\n\t\tbreak;\n\n\t    default:\n\t\tif (!silent)\n\t\t    _nc_warning(\"unknown token type\");\n\t\t_nc_panic_mode((char) ((_nc_syntax == SYN_TERMCAP) ? ':' : ','));\n\t\tcontinue;\n\t    }\n\t}\t\t\t \n      nexttok:\n\tcontinue;\t\t \n    }\t\t\t\t \n\n    _nc_push_token(token_type);\n    _nc_set_type(_nc_first_name(entryp->tterm.term_names));\n\n     \n    if (!literal) {\n\tif (_nc_syntax == SYN_TERMCAP) {\n\t    bool has_base_entry = FALSE;\n\n\t     \n\t    if (strchr(entryp->tterm.term_names, '+')) {\n\t\thas_base_entry = TRUE;\n\t    } else {\n\t\tunsigned i;\n\t\t \n\t\tfor (i = 0; i < entryp->nuses; i++) {\n\t\t    if (entryp->uses[i].name != 0\n\t\t\t&& !strchr(entryp->uses[i].name, '+'))\n\t\t\thas_base_entry = TRUE;\n\t\t}\n\t    }\n\n\t    postprocess_termcap(&entryp->tterm, has_base_entry);\n\t} else\n\t    postprocess_terminfo(&entryp->tterm);\n    }\n    _nc_wrap_entry(entryp, FALSE);\n\n    returnDB(OK);\n}\n\nNCURSES_EXPORT(int)\n_nc_capcmp(const char *s, const char *t)\n \n{\n    bool ok_s = VALID_STRING(s);\n    bool ok_t = VALID_STRING(t);\n\n    if (ok_s && ok_t) {\n\tfor (;;) {\n\t    if (s[0] == '$' && s[1] == '<') {\n\t\tfor (s += 2;; s++) {\n\t\t    if (!(isdigit(UChar(*s))\n\t\t\t  || *s == '.'\n\t\t\t  || *s == '*'\n\t\t\t  || *s == '/'\n\t\t\t  || *s == '>')) {\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (t[0] == '$' && t[1] == '<') {\n\t\tfor (t += 2;; t++) {\n\t\t    if (!(isdigit(UChar(*t))\n\t\t\t  || *t == '.'\n\t\t\t  || *t == '*'\n\t\t\t  || *t == '/'\n\t\t\t  || *t == '>')) {\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t     \n\n\t    if (*s == '\\0' && *t == '\\0')\n\t\treturn (0);\n\n\t    if (*s != *t)\n\t\treturn (*t - *s);\n\n\t     \n\t    s++, t++;\n\t}\n    } else if (ok_s || ok_t) {\n\treturn 1;\n    }\n    return 0;\n}\n\nstatic void\nappend_acs0(string_desc * dst, int code, char *src, size_t off)\n{\n    if (src != 0 && off < strlen(src)) {\n\tchar temp[3];\n\ttemp[0] = (char) code;\n\ttemp[1] = src[off];\n\ttemp[2] = 0;\n\t_nc_safe_strcat(dst, temp);\n    }\n}\n\nstatic void\nappend_acs(string_desc * dst, int code, char *src)\n{\n    if (VALID_STRING(src) && strlen(src) == 1) {\n\tappend_acs0(dst, code, src, 0);\n    }\n}\n\n \n#define DATA(from, to) { { from }, { to } }\ntypedef struct {\n    const char from[3];\n    const char to[6];\n} assoc;\nstatic assoc const ko_xlate[] =\n{\n    DATA(\"al\", \"kil1\"),\t\t \n    DATA(\"bt\", \"kcbt\"),\t\t \n    DATA(\"cd\", \"ked\"),\t\t \n    DATA(\"ce\", \"kel\"),\t\t \n    DATA(\"cl\", \"kclr\"),\t\t \n    DATA(\"ct\", \"tbc\"),\t\t \n    DATA(\"dc\", \"kdch1\"),\t \n    DATA(\"dl\", \"kdl1\"),\t\t \n    DATA(\"do\", \"kcud1\"),\t \n    DATA(\"ei\", \"krmir\"),\t \n    DATA(\"ho\", \"khome\"),\t \n    DATA(\"ic\", \"kich1\"),\t \n    DATA(\"im\", \"kIC\"),\t\t \n    DATA(\"le\", \"kcub1\"),\t \n    DATA(\"nd\", \"kcuf1\"),\t \n    DATA(\"nl\", \"kent\"),\t\t \n    DATA(\"st\", \"khts\"),\t\t \n    DATA(\"ta\", \"\"),\n    DATA(\"up\", \"kcuu1\"),\t \n};\n\n \n\nstatic const char C_CR[] = \"\\r\";\nstatic const char C_LF[] = \"\\n\";\nstatic const char C_BS[] = \"\\b\";\nstatic const char C_HT[] = \"\\t\";\n\n \n\n#undef CUR\n#define CUR tp->\n\nstatic void\npostprocess_termcap(TERMTYPE2 *tp, bool has_base)\n{\n    char buf[MAX_LINE * 2 + 2];\n    string_desc result;\n\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"postprocess_termcap(tp=%p, has_base=%d)\"),\n\t(void *) tp, has_base));\n\n     \n\n     \n    if (!has_base) {\n\tif (WANTED(init_3string) && PRESENT(termcap_init2))\n\t    init_3string = _nc_save_str(termcap_init2);\n\n\tif (WANTED(reset_2string) && PRESENT(termcap_reset))\n\t    reset_2string = _nc_save_str(termcap_reset);\n\n\tif (WANTED(carriage_return)) {\n\t    if (carriage_return_delay > 0) {\n\t\t_nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t    \"%s$<%d>\", C_CR, carriage_return_delay);\n\t\tcarriage_return = _nc_save_str(buf);\n\t    } else\n\t\tcarriage_return = _nc_save_str(C_CR);\n\t}\n\tif (WANTED(cursor_left)) {\n\t    if (backspace_delay > 0) {\n\t\t_nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t    \"%s$<%d>\", C_BS, backspace_delay);\n\t\tcursor_left = _nc_save_str(buf);\n\t    } else if (backspaces_with_bs == 1)\n\t\tcursor_left = _nc_save_str(C_BS);\n\t    else if (PRESENT(backspace_if_not_bs))\n\t\tcursor_left = backspace_if_not_bs;\n\t}\n\t \n\tif (WANTED(cursor_down)) {\n\t    if (PRESENT(linefeed_if_not_lf))\n\t\tcursor_down = linefeed_if_not_lf;\n\t    else if (linefeed_is_newline != 1) {\n\t\tif (new_line_delay > 0) {\n\t\t    _nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t\t\"%s$<%d>\", C_LF, new_line_delay);\n\t\t    cursor_down = _nc_save_str(buf);\n\t\t} else\n\t\t    cursor_down = _nc_save_str(C_LF);\n\t    }\n\t}\n\tif (WANTED(scroll_forward) && crt_no_scrolling != 1) {\n\t    if (PRESENT(linefeed_if_not_lf))\n\t\tcursor_down = linefeed_if_not_lf;\n\t    else if (linefeed_is_newline != 1) {\n\t\tif (new_line_delay > 0) {\n\t\t    _nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t\t\"%s$<%d>\", C_LF, new_line_delay);\n\t\t    scroll_forward = _nc_save_str(buf);\n\t\t} else\n\t\t    scroll_forward = _nc_save_str(C_LF);\n\t    }\n\t}\n\tif (WANTED(newline)) {\n\t    if (linefeed_is_newline == 1) {\n\t\tif (new_line_delay > 0) {\n\t\t    _nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t\t\"%s$<%d>\", C_LF, new_line_delay);\n\t\t    newline = _nc_save_str(buf);\n\t\t} else\n\t\t    newline = _nc_save_str(C_LF);\n\t    } else if (PRESENT(carriage_return) && PRESENT(scroll_forward)) {\n\t\t_nc_str_init(&result, buf, sizeof(buf));\n\t\tif (_nc_safe_strcat(&result, carriage_return)\n\t\t    && _nc_safe_strcat(&result, scroll_forward))\n\t\t    newline = _nc_save_str(buf);\n\t    } else if (PRESENT(carriage_return) && PRESENT(cursor_down)) {\n\t\t_nc_str_init(&result, buf, sizeof(buf));\n\t\tif (_nc_safe_strcat(&result, carriage_return)\n\t\t    && _nc_safe_strcat(&result, cursor_down))\n\t\t    newline = _nc_save_str(buf);\n\t    }\n\t}\n    }\n\n     \n\n    if (!has_base) {\n\t \n\tif (return_does_clr_eol == 1 || no_correctly_working_cr == 1)\n\t    carriage_return = ABSENT_STRING;\n\n\t \n\tif (WANTED(tab)) {\n\t    if (horizontal_tab_delay > 0) {\n\t\t_nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t    \"%s$<%d>\", C_HT, horizontal_tab_delay);\n\t\ttab = _nc_save_str(buf);\n\t    } else\n\t\ttab = _nc_save_str(C_HT);\n\t}\n\tif (init_tabs == ABSENT_NUMERIC && has_hardware_tabs == TRUE)\n\t    init_tabs = 8;\n\n\t \n\tif (WANTED(bell))\n\t    bell = _nc_save_str(\"\\007\");\n    }\n\n     \n    if (has_hardware_tabs == TRUE) {\n\tif (init_tabs != 8 && init_tabs != ABSENT_NUMERIC)\n\t    _nc_warning(\"hardware tabs with a width other than 8: %d\", init_tabs);\n\telse {\n\t    if (PRESENT(tab) && _nc_capcmp(tab, C_HT))\n\t\t_nc_warning(\"hardware tabs with a non-^I tab string %s\",\n\t\t\t    _nc_visbuf(tab));\n\t    else {\n\t\tif (WANTED(tab))\n\t\t    tab = _nc_save_str(C_HT);\n\t\tinit_tabs = 8;\n\t    }\n\t}\n    }\n     \n    if (PRESENT(other_non_function_keys)) {\n\tchar *base;\n\tchar *bp, *cp, *dp;\n\tstruct name_table_entry const *from_ptr;\n\tstruct name_table_entry const *to_ptr;\n\tchar buf2[MAX_TERMINFO_LENGTH];\n\tbool foundim;\n\n\t \n\tdp = strchr(other_non_function_keys, 'i');\n\tfoundim = (dp != 0) && (dp[1] == 'm');\n\n\t \n\tfor (base = other_non_function_keys;\n\t     (cp = strchr(base, ',')) != 0;\n\t     base = cp + 1) {\n\t    size_t len = (unsigned) (cp - base);\n\t    size_t n;\n\t    assoc const *ap = 0;\n\n\t    for (n = 0; n < SIZEOF(ko_xlate); ++n) {\n\t\tif (len == strlen(ko_xlate[n].from)\n\t\t    && strncmp(ko_xlate[n].from, base, len) == 0) {\n\t\t    ap = ko_xlate + n;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (ap == 0) {\n\t\t_nc_warning(\"unknown capability `%.*s' in ko string\",\n\t\t\t    (int) len, base);\n\t\tcontinue;\n\t    } else if (ap->to[0] == '\\0')\t \n\t\tcontinue;\n\n\t     \n\n\t    from_ptr = _nc_find_entry(ap->from, _nc_get_hash_table(TRUE));\n\t    to_ptr = _nc_find_entry(ap->to, _nc_get_hash_table(FALSE));\n\n\t    if (!from_ptr || !to_ptr)\t \n\t\t_nc_err_abort(\"ko translation table is invalid, I give up\");\n\n\t    if (WANTED(tp->Strings[from_ptr->nte_index])) {\n\t\t_nc_warning(\"no value for ko capability %s\", ap->from);\n\t\tcontinue;\n\t    }\n\n\t    if (tp->Strings[to_ptr->nte_index]) {\n\t\tconst char *s = tp->Strings[from_ptr->nte_index];\n\t\tconst char *t = tp->Strings[to_ptr->nte_index];\n\t\t \n\t\tif (VALID_STRING(s) && VALID_STRING(t) && strcmp(s, t) != 0)\n\t\t    _nc_warning(\"%s (%s) already has an explicit value %s, ignoring ko\",\n\t\t\t\tap->to, ap->from, t);\n\t\tcontinue;\n\t    }\n\n\t     \n\t    bp = tp->Strings[from_ptr->nte_index];\n\t    if (VALID_STRING(bp)) {\n\t\tfor (dp = buf2; *bp; bp++) {\n\t\t    if (bp[0] == '$' && bp[1] == '<') {\n\t\t\twhile (*bp && *bp != '>') {\n\t\t\t    ++bp;\n\t\t\t}\n\t\t    } else\n\t\t\t*dp++ = *bp;\n\t\t}\n\t\t*dp = '\\0';\n\n\t\ttp->Strings[to_ptr->nte_index] = _nc_save_str(buf2);\n\t    } else {\n\t\ttp->Strings[to_ptr->nte_index] = bp;\n\t    }\n\t}\n\n\t \n\tif (foundim && WANTED(key_ic) && PRESENT(key_sic)) {\n\t    key_ic = key_sic;\n\t    key_sic = ABSENT_STRING;\n\t}\n    }\n\n    if (!has_base) {\n\tif (!hard_copy) {\n\t    if (WANTED(key_backspace))\n\t\tkey_backspace = _nc_save_str(C_BS);\n\t    if (WANTED(key_left))\n\t\tkey_left = _nc_save_str(C_BS);\n\t    if (WANTED(key_down))\n\t\tkey_down = _nc_save_str(C_LF);\n\t}\n    }\n\n     \n    if (PRESENT(acs_ulcorner) ||\n\tPRESENT(acs_llcorner) ||\n\tPRESENT(acs_urcorner) ||\n\tPRESENT(acs_lrcorner) ||\n\tPRESENT(acs_ltee) ||\n\tPRESENT(acs_rtee) ||\n\tPRESENT(acs_btee) ||\n\tPRESENT(acs_ttee) ||\n\tPRESENT(acs_hline) ||\n\tPRESENT(acs_vline) ||\n\tPRESENT(acs_plus)) {\n\tchar buf2[MAX_TERMCAP_LENGTH];\n\n\t_nc_str_init(&result, buf2, sizeof(buf2));\n\t_nc_safe_strcat(&result, acs_chars);\n\n\tappend_acs(&result, 'j', acs_lrcorner);\n\tappend_acs(&result, 'k', acs_urcorner);\n\tappend_acs(&result, 'l', acs_ulcorner);\n\tappend_acs(&result, 'm', acs_llcorner);\n\tappend_acs(&result, 'n', acs_plus);\n\tappend_acs(&result, 'q', acs_hline);\n\tappend_acs(&result, 't', acs_ltee);\n\tappend_acs(&result, 'u', acs_rtee);\n\tappend_acs(&result, 'v', acs_btee);\n\tappend_acs(&result, 'w', acs_ttee);\n\tappend_acs(&result, 'x', acs_vline);\n\n\tif (buf2[0]) {\n\t    acs_chars = _nc_save_str(buf2);\n\t    _nc_warning(\"acsc string synthesized from XENIX capabilities\");\n\t}\n    } else if (acs_chars == ABSENT_STRING\n\t       && PRESENT(enter_alt_charset_mode)\n\t       && PRESENT(exit_alt_charset_mode)) {\n\tacs_chars = _nc_save_str(VT_ACSC);\n    }\n    returnVoidDB;\n}\n\nstatic void\npostprocess_terminfo(TERMTYPE2 *tp)\n{\n    TR(TRACE_DATABASE,\n       (T_CALLED(\"postprocess_terminfo(tp=%p)\"),\n\t(void *) tp));\n\n     \n\n     \n    if (PRESENT(box_chars_1)) {\n\tchar buf2[MAX_TERMCAP_LENGTH];\n\tstring_desc result;\n\n\t_nc_str_init(&result, buf2, sizeof(buf2));\n\t_nc_safe_strcat(&result, acs_chars);\n\n\tappend_acs0(&result, 'l', box_chars_1, 0);\t \n\tappend_acs0(&result, 'q', box_chars_1, 1);\t \n\tappend_acs0(&result, 'k', box_chars_1, 2);\t \n\tappend_acs0(&result, 'x', box_chars_1, 3);\t \n\tappend_acs0(&result, 'j', box_chars_1, 4);\t \n\tappend_acs0(&result, 'm', box_chars_1, 5);\t \n\tappend_acs0(&result, 'w', box_chars_1, 6);\t \n\tappend_acs0(&result, 'u', box_chars_1, 7);\t \n\tappend_acs0(&result, 'v', box_chars_1, 8);\t \n\tappend_acs0(&result, 't', box_chars_1, 9);\t \n\tappend_acs0(&result, 'n', box_chars_1, 10);\t \n\n\tif (buf2[0]) {\n\t    acs_chars = _nc_save_str(buf2);\n\t    _nc_warning(\"acsc string synthesized from AIX capabilities\");\n\t    box_chars_1 = ABSENT_STRING;\n\t}\n    }\n     \n    returnVoidDB;\n}\n\n \nstatic struct name_table_entry const *\nlookup_fullname(const char *find)\n{\n    int state = -1;\n\n    for (;;) {\n\tint count = 0;\n\tNCURSES_CONST char *const *names;\n\n\tswitch (++state) {\n\tcase BOOLEAN:\n\t    names = boolfnames;\n\t    break;\n\tcase STRING:\n\t    names = strfnames;\n\t    break;\n\tcase NUMBER:\n\t    names = numfnames;\n\t    break;\n\tdefault:\n\t    return NOTFOUND;\n\t}\n\n\tfor (count = 0; names[count] != 0; count++) {\n\t    if (!strcmp(names[count], find)) {\n\t\tstruct name_table_entry const *entry_ptr = _nc_get_table(FALSE);\n\t\twhile (entry_ptr->nte_type != state\n\t\t       || entry_ptr->nte_index != count)\n\t\t    entry_ptr++;\n\t\treturn entry_ptr;\n\t    }\n\t}\n    }\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}