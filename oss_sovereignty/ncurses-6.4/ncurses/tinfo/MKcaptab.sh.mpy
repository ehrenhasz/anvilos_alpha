{
  "module_name": "MKcaptab.sh",
  "hash_id": "bd34114d259b09978d6b7b9290e4d3c24f4e9792f1dbd337eacf08bf0c46d9b9",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/tinfo/MKcaptab.sh",
  "human_readable_source": "#!/bin/sh\n##############################################################################\n# Copyright 2019,2020 Thomas E. Dickey                                       #\n# Copyright 2007-2010,2011 Free Software Foundation, Inc.                    #\n#                                                                            #\n# Permission is hereby granted, free of charge, to any person obtaining a    #\n# copy of this software and associated documentation files (the \"Software\"), #\n# to deal in the Software without restriction, including without limitation  #\n# the rights to use, copy, modify, merge, publish, distribute, distribute    #\n# with modifications, sublicense, and/or sell copies of the Software, and to #\n# permit persons to whom the Software is furnished to do so, subject to the  #\n# following conditions:                                                      #\n#                                                                            #\n# The above copyright notice and this permission notice shall be included in #\n# all copies or substantial portions of the Software.                        #\n#                                                                            #\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR #\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   #\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    #\n# THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER      #\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    #\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        #\n# DEALINGS IN THE SOFTWARE.                                                  #\n#                                                                            #\n# Except as contained in this notice, the name(s) of the above copyright     #\n# holders shall not be used in advertising or otherwise to promote the sale, #\n# use or other dealings in this Software without prior written               #\n# authorization.                                                             #\n##############################################################################\n# $Id: MKcaptab.sh,v 1.19 2020/02/02 23:34:34 tom Exp $\n\nif test $# != 0\nthen\n\tAWK=\"$1\"; shift 1\nelse\n\tAWK=awk\nfi\n\nif test $# != 0\nthen\n\tOPT1=\"$1\"; shift 1\nelse\n\tOPT1=\"-0\"\nfi\n\nif test $# != 0\nthen\n\tOPT2=\"$1\"; shift 1\nelse\n\tOPT2=\"tinfo/MKcaptab.awk\"\nfi\n\ncat <<EOF\n/*\n * generated by $0\n */\n\nEOF\n\ncat <<'EOF'\n/*\n *\tcomp_captab.c -- The names of the capabilities indexed via a hash\n *\t\t         table for the compiler.\n *\n */\n\n#include <curses.priv.h>\n#include <tic.h>\n#include <hashsize.h>\n\n/* *INDENT-OFF* */\nEOF\n\ncat \"$@\" |./make_hash 1 info $OPT1\ncat \"$@\" |./make_hash 3 cap  $OPT1\n\ncat \"$@\" |$AWK -f $OPT2 bigstrings=$OPT1 tablename=capalias\n\ncat \"$@\" |$AWK -f $OPT2 bigstrings=$OPT1 tablename=infoalias\n\ncat <<EOF\n/* *INDENT-ON* */\n\n#if $OPT1\nstatic void\nnext_string(const char *strings, unsigned *offset)\n{\n    *offset += (unsigned) strlen(strings + *offset) + 1;\n}\n\nstatic const struct name_table_entry *\n_nc_build_names(struct name_table_entry **actual,\n\t\tconst name_table_data * source,\n\t\tconst char *strings)\n{\n    if (*actual == 0) {\n\t*actual = typeCalloc(struct name_table_entry, CAPTABSIZE);\n\tif (*actual != 0) {\n\t    unsigned n;\n\t    unsigned len = 0;\n\t    for (n = 0; n < CAPTABSIZE; ++n) {\n\t\t(*actual)[n].nte_name = strings + len;\n\t\t(*actual)[n].nte_type = source[n].nte_type;\n\t\t(*actual)[n].nte_index = source[n].nte_index;\n\t\t(*actual)[n].nte_link = source[n].nte_link;\n\t\tnext_string(strings, &len);\n\t    }\n\t}\n    }\n    return *actual;\n}\n\n#define add_alias(field) \\\\\n\tif (source[n].field >= 0) { \\\\\n\t\t(*actual)[n].field = strings + source[n].field; \\\\\n\t}\n\nstatic const struct alias *\n_nc_build_alias(struct alias **actual,\n\t\tconst alias_table_data * source,\n\t\tconst char *strings,\n\t\tsize_t tablesize)\n{\n    if (*actual == 0) {\n\t*actual = typeCalloc(struct alias, tablesize + 1);\n\tif (*actual != 0) {\n\t    size_t n;\n\t    for (n = 0; n < tablesize; ++n) {\n\t\tadd_alias(from);\n\t\tadd_alias(to);\n\t\tadd_alias(source);\n\t    }\n\t}\n    }\n    return *actual;\n}\n\n#define build_names(root) _nc_build_names(&_nc_##root##_table, \\\\\n\t\t\t\t\t  root##_names_data, \\\\\n\t\t\t\t\t  root##_names_text)\n#define build_alias(root) _nc_build_alias(&_nc_##root##alias_table, \\\\\n\t\t\t\t\t  root##alias_data, \\\\\n\t\t\t\t\t  root##alias_text, \\\\\n\t\t\t\t\t  SIZEOF(root##alias_data))\n#else\n#define build_names(root) _nc_ ## root ## _table\n#define build_alias(root) _nc_ ## root ## alias_table\n#endif\n\nNCURSES_EXPORT(const struct name_table_entry *)\n_nc_get_table(bool termcap)\n{\n    return termcap ? build_names(cap) : build_names(info);\n}\n\n/* entrypoint used by tack 1.07 */\nNCURSES_EXPORT(const HashValue *)\n_nc_get_hash_table(bool termcap)\n{\n    return termcap ? _nc_cap_hash_table : _nc_info_hash_table;\n}\n\nNCURSES_EXPORT(const struct alias *)\n_nc_get_alias_table(bool termcap)\n{\n    return termcap ? build_alias(cap) : build_alias(info);\n}\n\nstatic HashValue\ninfo_hash(const char *string)\n{\n    long sum = 0;\n\n    DEBUG(9, (\"hashing %s\", string));\n    while (*string) {\n\tsum += (long) (UChar(*string) + (UChar(*(string + 1)) << 8));\n\tstring++;\n    }\n\n    DEBUG(9, (\"sum is %ld\", sum));\n    return (HashValue) (sum % HASHTABSIZE);\n}\n\n#define TCAP_LEN 2\t\t/* only 1- or 2-character names are used */\n\nstatic HashValue\ntcap_hash(const char *string)\n{\n    char temp[TCAP_LEN + 1];\n    int limit = 0;\n\n    while (*string) {\n\ttemp[limit++] = *string++;\n\tif (limit >= TCAP_LEN)\n\t    break;\n    }\n    temp[limit] = '\\0';\n    return info_hash(temp);\n}\n\nstatic int\ncompare_tcap_names(const char *a, const char *b)\n{\n    return !strncmp(a, b, (size_t) TCAP_LEN);\n}\n\nstatic int\ncompare_info_names(const char *a, const char *b)\n{\n    return !strcmp(a, b);\n}\n\nstatic const HashData hash_data[2] =\n{\n    {HASHTABSIZE, _nc_info_hash_table, info_hash, compare_info_names},\n    {HASHTABSIZE, _nc_cap_hash_table, tcap_hash, compare_tcap_names}\n};\n\nNCURSES_EXPORT(const HashData *)\n_nc_get_hash_info(bool termcap)\n{\n    return &hash_data[(termcap != FALSE)];\n}\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_comp_captab_leaks(void)\n{\n#if $OPT1\n    FreeIfNeeded(_nc_cap_table);\n    FreeIfNeeded(_nc_info_table);\n    FreeIfNeeded(_nc_capalias_table);\n    FreeIfNeeded(_nc_infoalias_table);\n#endif\n}\n#endif /* NO_LEAKS */\nEOF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}