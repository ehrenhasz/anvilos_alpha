{
  "module_name": "lib_trace.c",
  "hash_id": "5faf70592a20c2e97cdd9fa811230747aa06decf083ae370a1bafab6d9834197",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/trace/lib_trace.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <tic.h>\n\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_trace.c,v 1.101 2022/09/17 14:57:02 tom Exp $\")\n\nNCURSES_EXPORT_VAR(unsigned) _nc_tracing = 0;  \n\n#ifdef TRACE\n\n#if USE_REENTRANT\nNCURSES_EXPORT(const char *)\nNCURSES_PUBLIC_VAR(_nc_tputs_trace) (void)\n{\n    return CURRENT_SCREEN ? CURRENT_SCREEN->_tputs_trace : _nc_prescreen._tputs_trace;\n}\nNCURSES_EXPORT(long)\nNCURSES_PUBLIC_VAR(_nc_outchars) (void)\n{\n    return CURRENT_SCREEN ? CURRENT_SCREEN->_outchars : _nc_prescreen._outchars;\n}\nNCURSES_EXPORT(void)\n_nc_set_tputs_trace(const char *s)\n{\n    if (CURRENT_SCREEN)\n\tCURRENT_SCREEN->_tputs_trace = s;\n    else\n\t_nc_prescreen._tputs_trace = s;\n}\nNCURSES_EXPORT(void)\n_nc_count_outchars(long increment)\n{\n    if (CURRENT_SCREEN)\n\tCURRENT_SCREEN->_outchars += increment;\n    else\n\t_nc_prescreen._outchars += increment;\n}\n#else\nNCURSES_EXPORT_VAR(const char *) _nc_tputs_trace = \"\";\nNCURSES_EXPORT_VAR(long) _nc_outchars = 0;\n#endif\n\n#define MyFP\t\t_nc_globals.trace_fp\n#define MyFD\t\t_nc_globals.trace_fd\n#define MyInit\t\t_nc_globals.trace_opened\n#define MyPath\t\t_nc_globals.trace_fname\n#define MyLevel\t\t_nc_globals.trace_level\n#define MyNested\t_nc_globals.nested_tracef\n#endif  \n\n#if USE_REENTRANT\n#define Locked(statement) { \\\n\t_nc_lock_global(tst_tracef); \\\n\tstatement; \\\n\t_nc_unlock_global(tst_tracef); \\\n    }\n#else\n#define Locked(statement) statement\n#endif\n\nNCURSES_EXPORT(unsigned)\ncurses_trace(unsigned tracelevel)\n{\n    unsigned result;\n\n#if defined(TRACE)\n    int bit;\n\n#define DATA(name) { name, #name }\n    static struct {\n\tunsigned mask;\n\tconst char *name;\n    } trace_names[] = {\n\tDATA(TRACE_TIMES),\n\t    DATA(TRACE_TPUTS),\n\t    DATA(TRACE_UPDATE),\n\t    DATA(TRACE_MOVE),\n\t    DATA(TRACE_CHARPUT),\n\t    DATA(TRACE_CALLS),\n\t    DATA(TRACE_VIRTPUT),\n\t    DATA(TRACE_IEVENT),\n\t    DATA(TRACE_BITS),\n\t    DATA(TRACE_ICALLS),\n\t    DATA(TRACE_CCALLS),\n\t    DATA(TRACE_DATABASE),\n\t    DATA(TRACE_ATTRS)\n    };\n#undef DATA\n\n    Locked(result = _nc_tracing);\n\n    if ((MyFP == 0) && tracelevel) {\n\tMyInit = TRUE;\n\tif (MyFD >= 0) {\n\t    MyFP = fdopen(MyFD, BIN_W);\n\t} else {\n\t    if (MyPath[0] == '\\0') {\n\t\tsize_t size = sizeof(MyPath) - 12;\n\t\tif (getcwd(MyPath, size) == 0) {\n\t\t    perror(\"curses: Can't get working directory\");\n\t\t    exit(EXIT_FAILURE);\n\t\t}\n\t\tMyPath[size] = '\\0';\n\t\tassert(strlen(MyPath) <= size);\n\t\t_nc_STRCAT(MyPath, \"/trace\", sizeof(MyPath));\n\t\tif (_nc_is_dir_path(MyPath)) {\n\t\t    _nc_STRCAT(MyPath, \".log\", sizeof(MyPath));\n\t\t}\n\t    }\n#define SAFE_MODE (O_CREAT | O_EXCL | O_RDWR)\n\t    if (_nc_access(MyPath, W_OK) < 0\n\t\t|| (MyFD = safe_open3(MyPath, SAFE_MODE, 0600)) < 0\n\t\t|| (MyFP = fdopen(MyFD, BIN_W)) == 0) {\n\t\t;\t\t \n\t    }\n\t}\n\tLocked(_nc_tracing = tracelevel);\n\t \n\tif (MyFP != 0) {\n#if HAVE_SETVBUF\t\t \n\t    (void) setvbuf(MyFP, (char *) 0, _IOLBF, (size_t) 0);\n#elif HAVE_SETBUF  \n\t    (void) setbuffer(MyFP, (char *) 0);\n#endif\n\t}\n\t_tracef(\"TRACING NCURSES version %s.%d (tracelevel=%#x)\",\n\t\tNCURSES_VERSION,\n\t\tNCURSES_VERSION_PATCH,\n\t\ttracelevel);\n\n#define SPECIAL_MASK(mask) \\\n\t    if ((tracelevel & mask) == mask) \\\n\t\t_tracef(\"- %s (%u)\", #mask, mask)\n\n\tfor (bit = 0; bit < TRACE_SHIFT; ++bit) {\n\t    unsigned mask = (1U << bit) & tracelevel;\n\t    if ((mask & trace_names[bit].mask) != 0) {\n\t\t_tracef(\"- %s (%u)\", trace_names[bit].name, mask);\n\t    }\n\t}\n\tSPECIAL_MASK(TRACE_MAXIMUM);\n\telse\n\tSPECIAL_MASK(TRACE_ORDINARY);\n\n\tif (tracelevel > TRACE_MAXIMUM) {\n\t    _tracef(\"- DEBUG_LEVEL(%u)\", tracelevel >> TRACE_SHIFT);\n\t}\n    } else if (tracelevel == 0) {\n\tif (MyFP != 0) {\n\t    MyFD = dup(MyFD);\t \n\t    fclose(MyFP);\n\t    MyFP = 0;\n\t}\n\tLocked(_nc_tracing = tracelevel);\n    } else if (_nc_tracing != tracelevel) {\n\tLocked(_nc_tracing = tracelevel);\n\t_tracef(\"tracelevel=%#x\", tracelevel);\n    }\n#else\n    (void) tracelevel;\n    result = 0;\n#endif\n    return result;\n}\n\n#if defined(TRACE)\nNCURSES_EXPORT(void)\ntrace(const unsigned int tracelevel)\n{\n    curses_trace(tracelevel);\n}\n\nstatic void\n_nc_va_tracef(const char *fmt, va_list ap)\n{\n    static const char Called[] = T_CALLED(\"\");\n    static const char Return[] = T_RETURN(\"\");\n\n    bool before = FALSE;\n    bool after = FALSE;\n    unsigned doit = _nc_tracing;\n    int save_err = errno;\n    FILE *fp = MyFP;\n\n#ifdef TRACE\n     \n    if (fp == 0 && !MyInit && _nc_tracing >= DEBUG_LEVEL(1))\n\tfp = stderr;\n#endif\n\n    if (strlen(fmt) >= sizeof(Called) - 1) {\n\tif (!strncmp(fmt, Called, sizeof(Called) - 1)) {\n\t    before = TRUE;\n\t    MyLevel++;\n\t} else if (!strncmp(fmt, Return, sizeof(Return) - 1)) {\n\t    after = TRUE;\n\t}\n\tif (before || after) {\n\t    if ((MyLevel <= 1)\n\t\t|| (doit & TRACE_ICALLS) != 0)\n\t\tdoit &= (TRACE_CALLS | TRACE_CCALLS);\n\t    else\n\t\tdoit = 0;\n\t}\n    }\n\n    if (doit != 0 && fp != 0) {\n#ifdef USE_PTHREADS\n\t \n# if USE_WEAK_SYMBOLS\n\tif ((pthread_self))\n# endif\n#ifdef _NC_WINDOWS\n\t    fprintf(fp, \"%#lx:\", (long) (intptr_t) pthread_self().p);\n#else\n\t    fprintf(fp, \"%#lx:\", (long) (intptr_t) pthread_self());\n#endif\n#endif\n\tif (before || after) {\n\t    int n;\n\t    for (n = 1; n < MyLevel; n++)\n\t\tfputs(\"+ \", fp);\n\t}\n\tvfprintf(fp, fmt, ap);\n\tfputc('\\n', fp);\n\tfflush(fp);\n    }\n\n    if (after && MyLevel)\n\tMyLevel--;\n\n    errno = save_err;\n}\n\nNCURSES_EXPORT(void)\n_tracef(const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    _nc_va_tracef(fmt, ap);\n    va_end(ap);\n}\n\n \nNCURSES_EXPORT(NCURSES_BOOL)\n_nc_retrace_bool(int code)\n{\n    T((T_RETURN(\"%s\"), code ? \"TRUE\" : \"FALSE\"));\n    return code;\n}\n\n \nNCURSES_EXPORT(char)\n_nc_retrace_char(int code)\n{\n    T((T_RETURN(\"%c\"), code));\n    return (char) code;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_retrace_int(int code)\n{\n    T((T_RETURN(\"%d\"), code));\n    return code;\n}\n\n \nNCURSES_EXPORT(unsigned)\n_nc_retrace_unsigned(unsigned code)\n{\n    T((T_RETURN(\"%#x\"), code));\n    return code;\n}\n\n \nNCURSES_EXPORT(char *)\n_nc_retrace_ptr(char *code)\n{\n    T((T_RETURN(\"%s\"), _nc_visbuf(code)));\n    return code;\n}\n\n \nNCURSES_EXPORT(const char *)\n_nc_retrace_cptr(const char *code)\n{\n    T((T_RETURN(\"%s\"), _nc_visbuf(code)));\n    return code;\n}\n\n \nNCURSES_EXPORT(NCURSES_CONST void *)\n_nc_retrace_cvoid_ptr(NCURSES_CONST void *code)\n{\n    T((T_RETURN(\"%p\"), code));\n    return code;\n}\n\n \nNCURSES_EXPORT(void *)\n_nc_retrace_void_ptr(void *code)\n{\n    T((T_RETURN(\"%p\"), code));\n    return code;\n}\n\n \nNCURSES_EXPORT(SCREEN *)\n_nc_retrace_sp(SCREEN *code)\n{\n    T((T_RETURN(\"%p\"), (void *) code));\n    return code;\n}\n\n \nNCURSES_EXPORT(WINDOW *)\n_nc_retrace_win(WINDOW *code)\n{\n    T((T_RETURN(\"%p\"), (void *) code));\n    return code;\n}\n\nNCURSES_EXPORT(char *)\n_nc_fmt_funcptr(char *target, const char *source, size_t size)\n{\n    size_t n;\n    char *dst = target;\n    bool leading = TRUE;\n\n    union {\n\tint value;\n\tchar bytes[sizeof(int)];\n    } byteorder;\n\n    byteorder.value = 0x1234;\n\n    *dst++ = '0';\n    *dst++ = 'x';\n\n    for (n = 0; n < size; ++n) {\n\tunsigned ch = ((byteorder.bytes[0] == 0x34)\n\t\t       ? UChar(source[size - n - 1])\n\t\t       : UChar(source[n]));\n\tif (ch != 0 || (n + 1) >= size)\n\t    leading = FALSE;\n\tif (!leading) {\n\t    _nc_SPRINTF(dst, _nc_SLIMIT(TR_FUNC_LEN - (size_t) (dst - target))\n\t\t\t\"%02x\", ch & 0xff);\n\t    dst += 2;\n\t}\n    }\n    *dst = '\\0';\n    return target;\n}\n\n#if USE_REENTRANT\n \nNCURSES_EXPORT(int)\n_nc_use_tracef(unsigned mask)\n{\n    bool result = FALSE;\n\n    _nc_lock_global(tst_tracef);\n    if (!MyNested++) {\n\tif ((result = (_nc_tracing & (mask))) != 0\n\t    && _nc_try_global(tracef) == 0) {\n\t     \n\t} else {\n\t     \n\t    MyNested = 0;\n\t}\n    } else {\n\t \n\tresult = (_nc_tracing & (mask));\n    }\n    _nc_unlock_global(tst_tracef);\n    return result;\n}\n\n \nNCURSES_EXPORT(void)\n_nc_locked_tracef(const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    _nc_va_tracef(fmt, ap);\n    va_end(ap);\n\n    if (--(MyNested) == 0) {\n\t_nc_unlock_global(tracef);\n    }\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}