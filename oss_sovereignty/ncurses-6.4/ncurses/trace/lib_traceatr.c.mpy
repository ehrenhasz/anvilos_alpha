{
  "module_name": "lib_traceatr.c",
  "hash_id": "b90f67ac1eec1cc912911e778f27a26646426816ce29fd19d931f66c7c5830bc",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/trace/lib_traceatr.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_traceatr.c,v 1.95 2022/06/11 22:40:56 tom Exp $\")\n\n#define COLOR_OF(c) ((c < 0) ? \"default\" : (c > 7 ? color_of(c) : colors[c].name))\n\n#define TRACE_BUF_SIZE(num) (_nc_globals.tracebuf_ptr[num].size)\n#define COLOR_BUF_SIZE(num) (sizeof(my_buffer[num]))\n\n#ifdef TRACE\n\nstatic const char l_brace[] = StringOf(L_BRACE);\nstatic const char r_brace[] = StringOf(R_BRACE);\n\n#ifndef USE_TERMLIB\n\n#define my_buffer _nc_globals.traceatr_color_buf\n#define my_select _nc_globals.traceatr_color_sel\n#define my_cached _nc_globals.traceatr_color_last\n\nstatic char *\ncolor_of(int c)\n{\n    if (c != my_cached) {\n\tmy_cached = c;\n\tmy_select = !my_select;\n\tif (isDefaultColor(c))\n\t    _nc_STRCPY(my_buffer[my_select], \"default\",\n\t\t       COLOR_BUF_SIZE(my_select));\n\telse\n\t    _nc_SPRINTF(my_buffer[my_select],\n\t\t\t_nc_SLIMIT(COLOR_BUF_SIZE(my_select))\n\t\t\t\"color%d\", c);\n    }\n    return my_buffer[my_select];\n}\n\n#undef my_buffer\n#undef my_select\n#endif  \n\nNCURSES_EXPORT(char *)\n_traceattr2(int bufnum, chtype newmode)\n{\n#define DATA(name) { name, { #name } }\n    static const struct {\n\tunsigned int val;\n\tconst char name[14];\n    } names[] =\n    {\n\tDATA(A_STANDOUT),\n\t    DATA(A_UNDERLINE),\n\t    DATA(A_REVERSE),\n\t    DATA(A_BLINK),\n\t    DATA(A_DIM),\n\t    DATA(A_BOLD),\n\t    DATA(A_ALTCHARSET),\n\t    DATA(A_INVIS),\n\t    DATA(A_PROTECT),\n\t    DATA(A_CHARTEXT),\n\t    DATA(A_NORMAL),\n\t    DATA(A_COLOR),\n#if USE_ITALIC\n\t    DATA(A_ITALIC),\n#endif\n    }\n#ifndef USE_TERMLIB\n    ,\n\tcolors[] =\n    {\n\tDATA(COLOR_BLACK),\n\t    DATA(COLOR_RED),\n\t    DATA(COLOR_GREEN),\n\t    DATA(COLOR_YELLOW),\n\t    DATA(COLOR_BLUE),\n\t    DATA(COLOR_MAGENTA),\n\t    DATA(COLOR_CYAN),\n\t    DATA(COLOR_WHITE),\n    }\n#endif  \n    ;\n#undef DATA\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\tsize_t n;\n\tunsigned save_nc_tracing = _nc_tracing;\n\n\t_nc_tracing = 0;\n\n\t_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));\n\n\tfor (n = 0; n < SIZEOF(names); n++) {\n\n\t    if ((newmode & names[n].val) != 0) {\n\t\tif (result[1] != '\\0')\n\t\t    (void) _nc_trace_bufcat(bufnum, \"|\");\n\t\tresult = _nc_trace_bufcat(bufnum, names[n].name);\n\n\t\tif (names[n].val == A_COLOR) {\n\t\t    char temp[80];\n\t\t    short pairnum = (short) PairNumber(newmode);\n#ifdef USE_TERMLIB\n\t\t     \n\t\t    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t\"{%d}\", pairnum);\n#else\n\t\t    NCURSES_COLOR_T fg, bg;\n\n\t\t    if (pair_content(pairnum, &fg, &bg) == OK) {\n\t\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t    \"{%d = {%s, %s}}\",\n\t\t\t\t    pairnum,\n\t\t\t\t    COLOR_OF(fg),\n\t\t\t\t    COLOR_OF(bg));\n\t\t    } else {\n\t\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t    \"{%d}\", pairnum);\n\t\t    }\n#endif\n\t\t    result = _nc_trace_bufcat(bufnum, temp);\n\t\t}\n\t    }\n\t}\n\tif (ChAttrOf(newmode) == A_NORMAL) {\n\t    if (result != 0 && result[1] != '\\0')\n\t\t(void) _nc_trace_bufcat(bufnum, \"|\");\n\t    (void) _nc_trace_bufcat(bufnum, \"A_NORMAL\");\n\t}\n\n\t_nc_tracing = save_nc_tracing;\n\tresult = _nc_trace_bufcat(bufnum, r_brace);\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_traceattr(attr_t newmode)\n{\n    return _traceattr2(0, newmode);\n}\n\n \nNCURSES_EXPORT(int)\n_nc_retrace_int_attr_t(attr_t code)\n{\n    T((T_RETURN(\"%s\"), _traceattr(code)));\n    return (int) code;\n}\n\n \nNCURSES_EXPORT(attr_t)\n_nc_retrace_attr_t(attr_t code)\n{\n    T((T_RETURN(\"%s\"), _traceattr(code)));\n    return code;\n}\n\nconst char *\n_nc_altcharset_name(attr_t attr, chtype ch)\n{\n#define DATA(code, name) { code, { #name } }\n    typedef struct {\n\tunsigned int val;\n\tconst char name[13];\n    } ALT_NAMES;\n#if NCURSES_SP_FUNCS\n    SCREEN *sp = CURRENT_SCREEN;\n#endif\n    static const ALT_NAMES names[] =\n    {\n\tDATA('l', ACS_ULCORNER),\t \n\tDATA('m', ACS_LLCORNER),\t \n\tDATA('k', ACS_URCORNER),\t \n\tDATA('j', ACS_LRCORNER),\t \n\tDATA('t', ACS_LTEE),\t \n\tDATA('u', ACS_RTEE),\t \n\tDATA('v', ACS_BTEE),\t \n\tDATA('w', ACS_TTEE),\t \n\tDATA('q', ACS_HLINE),\t \n\tDATA('x', ACS_VLINE),\t \n\tDATA('n', ACS_PLUS),\t \n\tDATA('o', ACS_S1),\t \n\tDATA('s', ACS_S9),\t \n\tDATA('`', ACS_DIAMOND),\t \n\tDATA('a', ACS_CKBOARD),\t \n\tDATA('f', ACS_DEGREE),\t \n\tDATA('g', ACS_PLMINUS),\t \n\tDATA('~', ACS_BULLET),\t \n\tDATA(',', ACS_LARROW),\t \n\tDATA('+', ACS_RARROW),\t \n\tDATA('.', ACS_DARROW),\t \n\tDATA('-', ACS_UARROW),\t \n\tDATA('h', ACS_BOARD),\t \n\tDATA('i', ACS_LANTERN),\t \n\tDATA('0', ACS_BLOCK),\t \n\tDATA('p', ACS_S3),\t \n\tDATA('r', ACS_S7),\t \n\tDATA('y', ACS_LEQUAL),\t \n\tDATA('z', ACS_GEQUAL),\t \n\tDATA('{', ACS_PI),\t \n\tDATA('|', ACS_NEQUAL),\t \n\tDATA('}', ACS_STERLING),\t \n    };\n#undef DATA\n\n    const char *result = 0;\n\n#if NCURSES_SP_FUNCS\n    (void) sp;\n#endif\n    if (SP_PARM != 0 && (attr & A_ALTCHARSET) && (acs_chars != 0)) {\n\tchar *cp;\n\tchar *found = 0;\n\n\tfor (cp = acs_chars; cp[0] && cp[1]; cp += 2) {\n\t    if (ChCharOf(UChar(cp[1])) == ChCharOf(ch)) {\n\t\tfound = cp;\n\t\t \n\t    }\n\t}\n\n\tif (found != 0) {\n\t    size_t n;\n\n\t    ch = ChCharOf(UChar(*found));\n\t    for (n = 0; n < SIZEOF(names); ++n) {\n\t\tif (names[n].val == ch) {\n\t\t    result = names[n].name;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_tracechtype2(int bufnum, chtype ch)\n{\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\tconst char *found;\n\tattr_t attr = ChAttrOf(ch);\n\n\t_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));\n\tif ((found = _nc_altcharset_name(attr, ch)) != 0) {\n\t    (void) _nc_trace_bufcat(bufnum, found);\n\t    attr &= ~A_ALTCHARSET;\n\t} else\n\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t    _nc_tracechar(CURRENT_SCREEN,\n\t\t\t\t\t\t  (int) ChCharOf(ch)));\n\n\tif (attr != A_NORMAL) {\n\t    (void) _nc_trace_bufcat(bufnum, \" | \");\n\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t    _traceattr2(bufnum + 20, attr));\n\t}\n\n\tresult = _nc_trace_bufcat(bufnum, r_brace);\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_tracechtype(chtype ch)\n{\n    return _tracechtype2(0, ch);\n}\n\n \nNCURSES_EXPORT(chtype)\n_nc_retrace_chtype(chtype code)\n{\n    T((T_RETURN(\"%s\"), _tracechtype(code)));\n    return code;\n}\n\n#if USE_WIDEC_SUPPORT\nNCURSES_EXPORT(char *)\n_tracecchar_t2(int bufnum, const cchar_t *ch)\n{\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\t_nc_STRCPY(result, l_brace, TRACE_BUF_SIZE(bufnum));\n\tif (ch != 0) {\n\t    const char *found;\n\t    attr_t attr = AttrOfD(ch);\n\n\t    if ((found = _nc_altcharset_name(attr, (chtype) CharOfD(ch))) != 0) {\n\t\t(void) _nc_trace_bufcat(bufnum, found);\n\t\tattr &= ~A_ALTCHARSET;\n\t    } else if (isWidecExt(CHDEREF(ch))) {\n\t\t(void) _nc_trace_bufcat(bufnum, \"{NAC}\");\n\t\tattr &= ~A_CHARTEXT;\n\t    } else {\n\t\tPUTC_DATA;\n\t\tint n;\n\n\t\t(void) _nc_trace_bufcat(bufnum, \"{ \");\n\t\tfor (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {\n\t\t    PUTC_ch = ch->chars[PUTC_i];\n\t\t    if (PUTC_ch == L'\\0') {\n\t\t\tif (PUTC_i == 0)\n\t\t\t    (void) _nc_trace_bufcat(bufnum, \"\\\\000\");\n\t\t\tbreak;\n\t\t    }\n\t\t    PUTC_INIT;\n\t\t    PUTC_n = (int) wcrtomb(PUTC_buf, ch->chars[PUTC_i], &PUT_st);\n\t\t    if (PUTC_n <= 0) {\n\t\t\tif (PUTC_ch != L'\\0') {\n\t\t\t     \n\t\t\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t\t\t    _nc_tracechar(CURRENT_SCREEN,\n\t\t\t\t\t\t\t\t  UChar(ch->chars[PUTC_i])));\n\t\t\t}\n\t\t\tbreak;\n\t\t    } else if (ch->chars[PUTC_i] > 255) {\n\t\t\tchar temp[80];\n\t\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t    \"{%d:\\\\u%lx}\",\n\t\t\t\t    _nc_wacs_width(ch->chars[PUTC_i]),\n\t\t\t\t    (unsigned long) ch->chars[PUTC_i]);\n\t\t\t(void) _nc_trace_bufcat(bufnum, temp);\n\t\t\tattr &= ~A_CHARTEXT;\t \n\t\t    } else {\n\t\t\tfor (n = 0; n < PUTC_n; n++) {\n\t\t\t    if (n)\n\t\t\t\t(void) _nc_trace_bufcat(bufnum, \", \");\n\t\t\t    (void) _nc_trace_bufcat(bufnum,\n\t\t\t\t\t\t    _nc_tracechar(CURRENT_SCREEN,\n\t\t\t\t\t\t\t\t  UChar(PUTC_buf[n])));\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t(void) _nc_trace_bufcat(bufnum, \" }\");\n\t    }\n\t    if (attr != A_NORMAL) {\n\t\t(void) _nc_trace_bufcat(bufnum, \" | \");\n\t\t(void) _nc_trace_bufcat(bufnum, _traceattr2(bufnum + 20, attr));\n\t    }\n#if NCURSES_EXT_COLORS\n\t     \n\t    if (ch->ext_color != PairNumber(attr)) {\n\t\tchar temp[80];\n\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t    \" X_COLOR{%d:%d}\", ch->ext_color, PairNumber(attr));\n\t\t(void) _nc_trace_bufcat(bufnum, temp);\n\t    }\n#endif\n\t}\n\n\tresult = _nc_trace_bufcat(bufnum, r_brace);\n    }\n    return result;\n}\n\nNCURSES_EXPORT(char *)\n_tracecchar_t(const cchar_t *ch)\n{\n    return _tracecchar_t2(0, ch);\n}\n#endif\n\n#else\nEMPTY_MODULE(_nc_lib_traceatr)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}