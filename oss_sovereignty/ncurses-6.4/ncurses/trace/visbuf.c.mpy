{
  "module_name": "visbuf.c",
  "hash_id": "5a9ed73a570c94f1b8da40f54e67b1d93ff89df611dfbfd99918513066416e2d",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/trace/visbuf.c",
  "human_readable_source": " \n\n \n\n \n\n#define NEED_NCURSES_CH_T\n#include <curses.priv.h>\n\n#include <tic.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: visbuf.c,v 1.53 2021/02/27 20:07:57 tom Exp $\")\n\n#define NUM_VISBUFS 4\n\n#define NormalLen(len) (size_t) (((size_t)(len) + 1) * 4)\n#define WideLen(len)   (size_t) (((size_t)(len) + 1) * 4 * (size_t) MB_CUR_MAX)\n\n#ifdef TRACE\nstatic const char d_quote[] = StringOf(D_QUOTE);\nstatic const char l_brace[] = StringOf(L_BRACE);\nstatic const char r_brace[] = StringOf(R_BRACE);\n#endif\n\n#if USE_STRING_HACKS && HAVE_SNPRINTF\n#define VisChar(tp, chr, limit) _nc_vischar(tp, chr, limit)\n#define LIMIT_ARG ,size_t limit\n#else\n#define VisChar(tp, chr, limit) _nc_vischar(tp, chr)\n#define LIMIT_ARG\t\t \n#endif\n\nstatic char *\n_nc_vischar(char *tp, unsigned c LIMIT_ARG)\n{\n    if (c == '\"' || c == '\\\\') {\n\t*tp++ = '\\\\';\n\t*tp++ = (char) c;\n    } else if (is7bits((int) c) && (isgraph((int) c) || c == ' ')) {\n\t*tp++ = (char) c;\n    } else if (c == '\\n') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'n';\n    } else if (c == '\\r') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'r';\n    } else if (c == '\\b') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'b';\n    } else if (c == '\\t') {\n\t*tp++ = '\\\\';\n\t*tp++ = 't';\n    } else if (c == '\\033') {\n\t*tp++ = '\\\\';\n\t*tp++ = 'e';\n    } else if (UChar(c) == 0x7f) {\n\t*tp++ = '\\\\';\n\t*tp++ = '^';\n\t*tp++ = '?';\n    } else if (is7bits(c) && iscntrl(UChar(c))) {\n\t*tp++ = '\\\\';\n\t*tp++ = '^';\n\t*tp++ = (char) ('@' + c);\n    } else {\n\t_nc_SPRINTF(tp, _nc_SLIMIT(limit)\n\t\t    \"\\\\%03lo\", (unsigned long) ChCharOf(c));\n\ttp += strlen(tp);\n    }\n    *tp = 0;\n    return tp;\n}\n\nstatic const char *\n_nc_visbuf2n(int bufnum, const char *buf, int len)\n{\n    const char *vbuf = 0;\n    char *tp;\n    int count;\n\n    if (buf == 0)\n\treturn (\"(null)\");\n    if (buf == CANCELLED_STRING)\n\treturn (\"(cancelled)\");\n\n    if (len < 0)\n\tlen = (int) strlen(buf);\n\n    count = len;\n#ifdef TRACE\n    vbuf = tp = _nc_trace_buf(bufnum, NormalLen(len));\n#else\n    {\n\tstatic char *mybuf[NUM_VISBUFS];\n\tint c;\n\n\tif (bufnum < 0) {\n\t    for (c = 0; c < NUM_VISBUFS; ++c) {\n\t\tFreeAndNull(mybuf[c]);\n\t    }\n\t    tp = 0;\n\t} else {\n\t    mybuf[bufnum] = typeRealloc(char, NormalLen(len), mybuf[bufnum]);\n\t    vbuf = tp = mybuf[bufnum];\n\t}\n    }\n#endif\n    if (tp != 0) {\n\tint c;\n\n\t*tp++ = D_QUOTE;\n\twhile ((--count >= 0) && (c = *buf++) != '\\0') {\n\t    tp = VisChar(tp, UChar(c), NormalLen(len));\n\t}\n\t*tp++ = D_QUOTE;\n\t*tp = '\\0';\n    } else {\n\tvbuf = (\"(_nc_visbuf2n failed)\");\n    }\n    return (vbuf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_visbuf2(int bufnum, const char *buf)\n{\n    return _nc_visbuf2n(bufnum, buf, -1);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_visbuf(const char *buf)\n{\n    return _nc_visbuf2(0, buf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_visbufn(const char *buf, int len)\n{\n    return _nc_visbuf2n(0, buf, len);\n}\n\n#ifdef TRACE\n#if USE_WIDEC_SUPPORT\n\n#if defined(USE_TERMLIB)\n#define _nc_wchstrlen _my_wchstrlen\nstatic int\n_nc_wchstrlen(const cchar_t *s)\n{\n    int result = 0;\n    while (CharOf(s[result]) != L'\\0') {\n\tresult++;\n    }\n    return result;\n}\n#endif\n\nstatic const char *\n_nc_viswbuf2n(int bufnum, const wchar_t *buf, int len)\n{\n    const char *vbuf;\n    char *tp;\n    int count;\n\n    if (buf == 0)\n\treturn (\"(null)\");\n\n    if (len < 0)\n\tlen = (int) wcslen(buf);\n\n    count = len;\n#ifdef TRACE\n    vbuf = tp = _nc_trace_buf(bufnum, WideLen(len));\n#else\n    {\n\tstatic char *mybuf[NUM_VISBUFS];\n\tmybuf[bufnum] = typeRealloc(char, WideLen(len), mybuf[bufnum]);\n\tvbuf = tp = mybuf[bufnum];\n    }\n#endif\n    if (tp != 0) {\n\twchar_t c;\n\n\t*tp++ = D_QUOTE;\n\twhile ((--count >= 0) && (c = *buf++) != '\\0') {\n\t    char temp[CCHARW_MAX + 80];\n\t    int j = wctomb(temp, c), k;\n\t    if (j <= 0) {\n\t\t_nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t    \"\\\\u%08X\", (unsigned) c);\n\t\tj = (int) strlen(temp);\n\t    }\n\t    for (k = 0; k < j; ++k) {\n\t\ttp = VisChar(tp, UChar(temp[k]), WideLen(len));\n\t    }\n\t}\n\t*tp++ = D_QUOTE;\n\t*tp = '\\0';\n    } else {\n\tvbuf = (\"(_nc_viswbuf2n failed)\");\n    }\n    return (vbuf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viswbuf2(int bufnum, const wchar_t *buf)\n{\n    return _nc_viswbuf2n(bufnum, buf, -1);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viswbuf(const wchar_t *buf)\n{\n    return _nc_viswbuf2(0, buf);\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viswbufn(const wchar_t *buf, int len)\n{\n    return _nc_viswbuf2n(0, buf, len);\n}\n\n \nNCURSES_EXPORT(const char *)\n_nc_viswibuf(const wint_t *buf)\n{\n    static wchar_t *mybuf;\n    static unsigned mylen;\n    unsigned n;\n\n    for (n = 0; buf[n] != 0; ++n) {\n\t;\t\t\t \n    }\n    if (mylen < ++n) {\n\tmylen = n + 80;\n\tif (mybuf != 0)\n\t    mybuf = typeRealloc(wchar_t, mylen, mybuf);\n\telse\n\t    mybuf = typeMalloc(wchar_t, mylen);\n    }\n    if (mybuf != 0) {\n\tfor (n = 0; buf[n] != 0; ++n) {\n\t    mybuf[n] = (wchar_t) buf[n];\n\t}\n\tmybuf[n] = L'\\0';\n    }\n\n    return _nc_viswbuf2(0, mybuf);\n}\n#endif  \n\n \nNCURSES_EXPORT(const char *)\n_nc_viscbuf2(int bufnum, const NCURSES_CH_T *buf, int len)\n{\n    char *result = _nc_trace_buf(bufnum, (size_t) BUFSIZ);\n\n    if (result != 0) {\n\tint first = 0;\n\n#if USE_WIDEC_SUPPORT\n\tif (len < 0)\n\t    len = _nc_wchstrlen(buf);\n#endif  \n\n\t \n\twhile (first < len) {\n\t    attr_t attr = AttrOf(buf[first]);\n\t    int last = len - 1;\n\t    int j;\n\n\t    for (j = first + 1; j < len; ++j) {\n\t\tif (!SameAttrOf(buf[j], buf[first])) {\n\t\t    last = j - 1;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    (void) _nc_trace_bufcat(bufnum, l_brace);\n\t    (void) _nc_trace_bufcat(bufnum, d_quote);\n\t    for (j = first; j <= last; ++j) {\n\t\tconst char *found = _nc_altcharset_name(attr, (chtype)\n\t\t\t\t\t\t\tCharOf(buf[j]));\n\t\tif (found != 0) {\n\t\t    (void) _nc_trace_bufcat(bufnum, found);\n\t\t    attr &= ~A_ALTCHARSET;\n\t\t} else\n#if USE_WIDEC_SUPPORT\n\t\tif (!isWidecExt(buf[j])) {\n\t\t    PUTC_DATA;\n\n\t\t    for (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {\n\t\t\tint k;\n\t\t\tchar temp[80];\n\n\t\t\tPUTC_ch = buf[j].chars[PUTC_i];\n\t\t\tif (PUTC_ch == L'\\0') {\n\t\t\t    if (PUTC_i == 0)\n\t\t\t\t(void) _nc_trace_bufcat(bufnum, \"\\\\000\");\n\t\t\t    break;\n\t\t\t}\n\t\t\tPUTC_INIT;\n\t\t\tPUTC_n = (int) wcrtomb(PUTC_buf,\n\t\t\t\t\t       buf[j].chars[PUTC_i], &PUT_st);\n\t\t\tif (PUTC_n <= 0 || buf[j].chars[PUTC_i] > 255) {\n\t\t\t    _nc_SPRINTF(temp, _nc_SLIMIT(sizeof(temp))\n\t\t\t\t\t\"{%d:\\\\u%lx}\",\n\t\t\t\t\t_nc_wacs_width(buf[j].chars[PUTC_i]),\n\t\t\t\t\t(unsigned long) buf[j].chars[PUTC_i]);\n\t\t\t    (void) _nc_trace_bufcat(bufnum, temp);\n\t\t\t    break;\n\t\t\t}\n\t\t\tfor (k = 0; k < PUTC_n; k++) {\n\t\t\t    VisChar(temp, UChar(PUTC_buf[k]), sizeof(temp));\n\t\t\t    (void) _nc_trace_bufcat(bufnum, temp);\n\t\t\t}\n\t\t    }\n\t\t}\n#else\n\t\t{\n\t\t    char temp[80];\n\t\t    VisChar(temp, UChar(buf[j]), sizeof(temp));\n\t\t    (void) _nc_trace_bufcat(bufnum, temp);\n\t\t}\n#endif  \n\t    }\n\t    (void) _nc_trace_bufcat(bufnum, d_quote);\n\t    if (attr != A_NORMAL) {\n\t\t(void) _nc_trace_bufcat(bufnum, \" | \");\n\t\t(void) _nc_trace_bufcat(bufnum, _traceattr2(bufnum + 20, attr));\n\t    }\n\t    result = _nc_trace_bufcat(bufnum, r_brace);\n\t    first = last + 1;\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(const char *)\n_nc_viscbuf(const NCURSES_CH_T *buf, int len)\n{\n    return _nc_viscbuf2(0, buf, len);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}