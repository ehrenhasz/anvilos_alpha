{
  "module_name": "lib_tracebits.c",
  "hash_id": "f26c2de85dd09f8d3f1aef8f4313bccb77b7167cee9203880b9d03b3aa57650e",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/trace/lib_tracebits.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_tracebits.c,v 1.31 2020/11/14 23:38:11 tom Exp $\")\n\n#if HAVE_SYS_TERMIO_H\n#include <sys/termio.h>\t\t \n#endif\n\n#ifdef __EMX__\n#include <io.h>\n#endif\n\n \n#ifndef TOSTOP\n#define TOSTOP 0\n#endif\n\n#ifndef IEXTEN\n#define IEXTEN 0\n#endif\n\n#ifndef ONLCR\n#define ONLCR 0\n#endif\n\n#ifndef OCRNL\n#define OCRNL 0\n#endif\n\n#ifndef ONOCR\n#define ONOCR 0\n#endif\n\n#ifndef ONLRET\n#define ONLRET 0\n#endif\n\n#ifdef TRACE\n\n#if defined(EXP_WIN32_DRIVER)\n#define BITNAMELEN 36\n#else\n#define BITNAMELEN 8\n#endif\n\ntypedef struct {\n    unsigned int val;\n    const char name[BITNAMELEN];\n} BITNAMES;\n\n#define TRACE_BUF_SIZE(num) (_nc_globals.tracebuf_ptr[num].size)\n\nstatic void\nlookup_bits(char *buf, const BITNAMES * table, const char *label, unsigned int val)\n{\n    const BITNAMES *sp;\n\n    _nc_STRCAT(buf, label, TRACE_BUF_SIZE(0));\n    _nc_STRCAT(buf, \": {\", TRACE_BUF_SIZE(0));\n    for (sp = table; sp->name[0]; sp++)\n\tif (sp->val != 0\n\t    && (val & sp->val) == sp->val) {\n\t    _nc_STRCAT(buf, sp->name, TRACE_BUF_SIZE(0));\n\t    _nc_STRCAT(buf, \", \", TRACE_BUF_SIZE(0));\n\t}\n    if (buf[strlen(buf) - 2] == ',')\n\tbuf[strlen(buf) - 2] = '\\0';\n    _nc_STRCAT(buf, \"} \", TRACE_BUF_SIZE(0));\n}\n\nNCURSES_EXPORT(char *)\n_nc_trace_ttymode(const TTY * tty)\n \n{\n    char *buf;\n\n#ifdef TERMIOS\n#define DATA(name)        { name, { #name } }\n#define DATA2(name,name2) { name, { #name2 } }\n#define DATAX()           { 0,    { \"\" } }\n    static const BITNAMES iflags[] =\n    {\n\tDATA(BRKINT),\n\tDATA(IGNBRK),\n\tDATA(IGNPAR),\n\tDATA(PARMRK),\n\tDATA(INPCK),\n\tDATA(ISTRIP),\n\tDATA(INLCR),\n\tDATA(IGNCR),\n\tDATA(ICRNL),\n\tDATA(IXON),\n\tDATA(IXOFF),\n\tDATAX()\n#define ALLIN\t(BRKINT|IGNBRK|IGNPAR|PARMRK|INPCK|ISTRIP|INLCR|IGNCR|ICRNL|IXON|IXOFF)\n    }, oflags[] =\n    {\n\tDATA(OPOST),\n\tDATA2(OFLAGS_TABS, XTABS),\n\tDATA(ONLCR),\n\tDATA(OCRNL),\n\tDATA(ONOCR),\n\tDATA(ONLRET),\n\tDATAX()\n#define ALLOUT\t(OPOST|OFLAGS_TABS|ONLCR|OCRNL|ONOCR|ONLRET|OFLAGS_TABS)\n    }, cflags[] =\n    {\n\tDATA(CLOCAL),\n\tDATA(CREAD),\n\tDATA(CSTOPB),\n#if !defined(CS5) || !defined(CS8)\n\tDATA(CSIZE),\n#endif\n\tDATA(HUPCL),\n\tDATA(PARENB),\n\tDATA2(PARODD | PARENB, PARODD),\n\tDATAX()\n#define ALLCTRL\t(CLOCAL|CREAD|CSIZE|CSTOPB|HUPCL|PARENB|PARODD)\n    }, lflags[] =\n    {\n\tDATA(ECHO),\n\tDATA2(ECHOE | ECHO, ECHOE),\n\tDATA2(ECHOK | ECHO, ECHOK),\n\tDATA(ECHONL),\n\tDATA(ICANON),\n\tDATA(ISIG),\n\tDATA(NOFLSH),\n\tDATA(TOSTOP),\n\tDATA(IEXTEN),\n\tDATAX()\n#define ALLLOCAL\t(ECHO|ECHONL|ICANON|ISIG|NOFLSH|TOSTOP|IEXTEN)\n    };\n\n    buf = _nc_trace_buf(0,\n\t\t\t8 + sizeof(iflags) +\n\t\t\t8 + sizeof(oflags) +\n\t\t\t8 + sizeof(cflags) +\n\t\t\t8 + sizeof(lflags) +\n\t\t\t8);\n    if (buf != 0) {\n\n\tif (tty->c_iflag & ALLIN)\n\t    lookup_bits(buf, iflags, \"iflags\", tty->c_iflag);\n\n\tif (tty->c_oflag & ALLOUT)\n\t    lookup_bits(buf, oflags, \"oflags\", tty->c_oflag);\n\n\tif (tty->c_cflag & ALLCTRL)\n\t    lookup_bits(buf, cflags, \"cflags\", tty->c_cflag);\n\n#if defined(CS5) && defined(CS8)\n\t{\n\t    static const struct {\n\t\tint value;\n\t\tconst char name[5];\n\t    } csizes[] = {\n#define CS_DATA(name) { name, { #name \" \" } }\n\t\tCS_DATA(CS5),\n#ifdef CS6\n\t\t    CS_DATA(CS6),\n#endif\n#ifdef CS7\n\t\t    CS_DATA(CS7),\n#endif\n\t\t    CS_DATA(CS8),\n\t    };\n\t    const char *result = \"CSIZE? \";\n\t    int value = (int) (tty->c_cflag & CSIZE);\n\t    unsigned n;\n\n\t    if (value != 0) {\n\t\tfor (n = 0; n < SIZEOF(csizes); n++) {\n\t\t    if (csizes[n].value == value) {\n\t\t\tresult = csizes[n].name;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    _nc_STRCAT(buf, result, TRACE_BUF_SIZE(0));\n\t}\n#endif\n\n\tif (tty->c_lflag & ALLLOCAL)\n\t    lookup_bits(buf, lflags, \"lflags\", tty->c_lflag);\n    }\n#elif defined(EXP_WIN32_DRIVER)\n#define DATA(name)        { name, { #name } }\n    static const BITNAMES dwFlagsOut[] =\n    {\n\tDATA(ENABLE_PROCESSED_OUTPUT),\n\tDATA(ENABLE_WRAP_AT_EOL_OUTPUT),\n\tDATA(ENABLE_VIRTUAL_TERMINAL_PROCESSING),\n\tDATA(DISABLE_NEWLINE_AUTO_RETURN),\n\tDATA(ENABLE_LVB_GRID_WORLDWIDE)\n    };\n    static const BITNAMES dwFlagsIn[] =\n    {\n\tDATA(ENABLE_PROCESSED_INPUT),\n\tDATA(ENABLE_LINE_INPUT),\n\tDATA(ENABLE_ECHO_INPUT),\n\tDATA(ENABLE_MOUSE_INPUT),\n\tDATA(ENABLE_INSERT_MODE),\n\tDATA(ENABLE_QUICK_EDIT_MODE),\n\tDATA(ENABLE_EXTENDED_FLAGS),\n\tDATA(ENABLE_AUTO_POSITION),\n\tDATA(ENABLE_VIRTUAL_TERMINAL_INPUT)\n    };\n\n    buf = _nc_trace_buf(0,\n\t\t\t8 + sizeof(dwFlagsOut) +\n\t\t\t8 + sizeof(dwFlagsIn));\n    if (buf != 0) {\n\tlookup_bits(buf, dwFlagsIn, \"dwIn\", tty->dwFlagIn);\n\tlookup_bits(buf, dwFlagsOut, \"dwOut\", tty->dwFlagOut);\n    }\n#else\n     \n#ifndef EVENP\n#define EVENP 0\n#endif\n#ifndef LCASE\n#define LCASE 0\n#endif\n#ifndef LLITOUT\n#define LLITOUT 0\n#endif\n#ifndef ODDP\n#define ODDP 0\n#endif\n#ifndef TANDEM\n#define TANDEM 0\n#endif\n\n    static const BITNAMES cflags[] =\n    {\n\tDATA(CBREAK),\n\tDATA(CRMOD),\n\tDATA(ECHO),\n\tDATA(EVENP),\n\tDATA(LCASE),\n\tDATA(LLITOUT),\n\tDATA(ODDP),\n\tDATA(RAW),\n\tDATA(TANDEM),\n\tDATA(XTABS),\n\tDATAX()\n#define ALLCTRL\t(CBREAK|CRMOD|ECHO|EVENP|LCASE|LLITOUT|ODDP|RAW|TANDEM|XTABS)\n    };\n\n    buf = _nc_trace_buf(0,\n\t\t\t8 + sizeof(cflags));\n    if (buf != 0) {\n\tif (tty->sg_flags & ALLCTRL) {\n\t    lookup_bits(buf, cflags, \"cflags\", tty->sg_flags);\n\t}\n    }\n#endif\n    return (buf);\n}\n\nNCURSES_EXPORT(char *)\n_nc_tracebits(void)\n{\n    return _nc_trace_ttymode(&(cur_term->Nttyb));\n}\n#else\nEMPTY_MODULE(_nc_empty_lib_tracebits)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}