{
  "module_name": "lib_tracedmp.c",
  "hash_id": "fe8074893806bcfaca890f24c6849c2cae08052acb01d8f08e75a493677242eb",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/trace/lib_tracedmp.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_tracedmp.c,v 1.36 2020/02/02 23:34:34 tom Exp $\")\n\n#ifdef TRACE\n\n#define my_buffer _nc_globals.tracedmp_buf\n#define my_length _nc_globals.tracedmp_used\n\nNCURSES_EXPORT(void)\n_tracedump(const char *name, WINDOW *win)\n{\n    int i, j, n, width;\n\n     \n    for (width = i = 0; i <= win->_maxy; ++i) {\n\tn = 0;\n\tfor (j = 0; j <= win->_maxx; ++j) {\n\t    if (CharOf(win->_line[i].text[j]) != L(' ')\n\t\t|| AttrOf(win->_line[i].text[j]) != A_NORMAL\n\t\t|| GetPair(win->_line[i].text[j]) != 0) {\n\t\tn = j;\n\t    }\n\t}\n\n\tif (n > width)\n\t    width = n;\n    }\n    if (width < win->_maxx)\n\t++width;\n    if (++width + 1 > (int) my_length) {\n\tmy_length = (unsigned) (2 * (width + 1));\n\tmy_buffer = typeRealloc(char, my_length, my_buffer);\n\tif (my_buffer == 0)\n\t    return;\n    }\n\n    for (n = 0; n <= win->_maxy; ++n) {\n\tchar *ep = my_buffer;\n\tbool havecolors;\n\n\t \n\tfor (j = 0; j < width; ++j) {\n\t    chtype test = (chtype) CharOf(win->_line[n].text[j]);\n\t    ep[j] = (char) ((UChar(test) == test\n#if USE_WIDEC_SUPPORT\n\t\t\t     && (win->_line[n].text[j].chars[1] == 0)\n#endif\n\t\t\t    )\n\t\t\t    ? (iscntrl(UChar(test))\n\t\t\t       ? '.'\n\t\t\t       : UChar(test))\n\t\t\t    : '?');\n\t}\n\tep[j] = '\\0';\n\t_tracef(\"%s[%2d] %3ld%3ld ='%s'\",\n\t\tname, n,\n\t\t(long) win->_line[n].firstchar,\n\t\t(long) win->_line[n].lastchar,\n\t\tep);\n\n\t \n\tif_WIDEC({\n\t    bool multicolumn = FALSE;\n\t    for (j = 0; j < width; ++j)\n\t\tif (WidecExt(win->_line[n].text[j]) != 0) {\n\t\t    multicolumn = TRUE;\n\t\t    break;\n\t\t}\n\t    if (multicolumn) {\n\t\tep = my_buffer;\n\t\tfor (j = 0; j < width; ++j) {\n\t\t    int test = WidecExt(win->_line[n].text[j]);\n\t\t    if (test) {\n\t\t\tep[j] = (char) (test + '0');\n\t\t    } else {\n\t\t\tep[j] = ' ';\n\t\t    }\n\t\t}\n\t\tep[j] = '\\0';\n\t\t_tracef(\"%*s[%2d]%*s='%s'\", (int) strlen(name),\n\t\t\t\"widec\", n, 8, \" \", my_buffer);\n\t    }\n\t});\n\n\t \n\thavecolors = FALSE;\n\tfor (j = 0; j < width; ++j)\n\t    if (GetPair(win->_line[n].text[j]) != 0) {\n\t\thavecolors = TRUE;\n\t\tbreak;\n\t    }\n\tif (havecolors) {\n\t    ep = my_buffer;\n\t    for (j = 0; j < width; ++j) {\n\t\tint pair = GetPair(win->_line[n].text[j]);\n\t\tif (pair >= 52)\n\t\t    ep[j] = '?';\n\t\telse if (pair >= 36)\n\t\t    ep[j] = (char) (pair + 'A');\n\t\telse if (pair >= 10)\n\t\t    ep[j] = (char) (pair + 'a');\n\t\telse if (pair >= 1)\n\t\t    ep[j] = (char) (pair + '0');\n\t\telse\n\t\t    ep[j] = ' ';\n\t    }\n\t    ep[j] = '\\0';\n\t    _tracef(\"%*s[%2d]%*s='%s'\", (int) strlen(name),\n\t\t    \"colors\", n, 8, \" \", my_buffer);\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t    const char *hex = \" 123456789ABCDEF\";\n\t    attr_t mask = (attr_t) (0xf << ((i + 4) * 4));\n\t    bool haveattrs = FALSE;\n\n\t    for (j = 0; j < width; ++j)\n\t\tif (AttrOf(win->_line[n].text[j]) & mask) {\n\t\t    haveattrs = TRUE;\n\t\t    break;\n\t\t}\n\t    if (haveattrs) {\n\t\tep = my_buffer;\n\t\tfor (j = 0; j < width; ++j)\n\t\t    ep[j] = hex[(AttrOf(win->_line[n].text[j]) & mask) >>\n\t\t\t\t((i + 4) * 4)];\n\t\tep[j] = '\\0';\n\t\t_tracef(\"%*s%d[%2d]%*s='%s'\", (int) strlen(name) -\n\t\t\t1, \"attrs\", i, n, 8, \" \", my_buffer);\n\t    }\n\t}\n    }\n#if NO_LEAKS\n    free(my_buffer);\n    my_buffer = 0;\n    my_length = 0;\n#endif\n}\n\n#else\nEMPTY_MODULE(_nc_lib_tracedmp)\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}