{
  "module_name": "curses.priv.h",
  "hash_id": "cd2fdd5fd6228a9cc8991891ae804e2a60e901e022cac9680b9224149a0284f2",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/curses.priv.h",
  "human_readable_source": " \n\n \n\n \n\n#ifndef CURSES_PRIV_H\n#define CURSES_PRIV_H 1\n \n\n#include <ncurses_dll.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <ncurses_cfg.h>\n\n#if USE_RCS_IDS\n#define MODULE_ID(id) static const char Ident[] = id;\n#else\n#define MODULE_ID(id)  \n#endif\n\n#include <stddef.h>\t\t \n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if HAVE_LIMITS_H\n# include <limits.h>\n#elif HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n\n#include <assert.h>\n#include <stdio.h>\n\n#include <errno.h>\n\n#if defined __hpux\n#  ifndef EILSEQ\n#    define EILSEQ 47\n#  endif\n#endif\n\n#ifndef PATH_MAX\n# if defined(_POSIX_PATH_MAX)\n#  define PATH_MAX _POSIX_PATH_MAX\n# elif defined(MAXPATHLEN)\n#  define PATH_MAX MAXPATHLEN\n# else\n#  define PATH_MAX 255\t \n# endif\n#endif\n\n#if DECL_ERRNO\nextern int errno;\n#endif\n\n \n#undef _NC_WINDOWS\n#if (defined(_WIN32) || defined(_WIN64))\n#define _NC_WINDOWS\n#else\n#undef EXP_WIN32_DRIVER\n#endif\n\n#undef _NC_MINGW\n#if (defined(__MINGW32__) || defined(__MINGW64__))\n#define _NC_MINGW\n#endif\n\n#undef _NC_MSC\n#ifdef _MSC_VER\n#define _NC_MSC\n#endif\n\n \n#if HAVE_WORKING_POLL\n#define USE_FUNC_POLL 1\n#if HAVE_POLL_H\n#include <poll.h>\n#else\n#include <sys/poll.h>\n#endif\n#else\n#define USE_FUNC_POLL 0\n#endif\n\n#if HAVE_INTTYPES_H\n# include <inttypes.h>\n#else\n# if HAVE_STDINT_H\n#  include <stdint.h>\n# endif\n#endif\n\n#ifndef PRIxPTR\n# define PRIxPTR\t\"lx\"\n#endif\n\n \n#include <signal.h>\n\n \n#if HAVE_LIBGPM && HAVE_GPM_H\n#define USE_GPM_SUPPORT 1\n#else\n#define USE_GPM_SUPPORT 0\n#endif\n\n \n#if defined(__QNX__) && !defined(__QNXNTO__)\n#define USE_QNX_MOUSE 1\n#else\n#define USE_QNX_MOUSE 0\n#endif\n\n \n#ifdef __EMX__\n#define USE_EMX_MOUSE 1\n#else\n#define USE_EMX_MOUSE 0\n#endif\n\n \n#if defined(__OS2__) && defined(__KLIBC__)\n#define USE_KLIBC_KBD   1\n#define USE_KLIBC_MOUSE 1\n#else\n#define USE_KLIBC_KBD   0\n#define USE_KLIBC_MOUSE 0\n#endif\n\n#define DEFAULT_MAXCLICK 166\n#define EV_MAX\t\t8\t \n\n \n#if !NCURSES_EXT_FUNCS\n#undef HAVE_SIZECHANGE\n#define HAVE_SIZECHANGE 0\n#endif\n\n#if HAVE_SIZECHANGE && USE_SIGWINCH && defined(SIGWINCH)\n#define USE_SIZECHANGE 1\n#else\n#define USE_SIZECHANGE 0\n#undef USE_SIGWINCH\n#define USE_SIGWINCH 0\n#endif\n\n \n#if defined(_NC_WINDOWS)\n#  ifdef NCURSES_PATHSEP\n#    undef NCURSES_PATHSEP\n#  endif\n#  define NCURSES_PATHSEP ';'\n#endif\n\n \n#if USE_OK_BCOPY\n#define memmove(d,s,n) bcopy(s,d,n)\n#elif USE_MY_MEMMOVE\n#define memmove(d,s,n) _nc_memmove(d,s,n)\nextern NCURSES_EXPORT(void *) _nc_memmove (void *, const void *, size_t);\n#endif\n\n \n#if defined(HAVE___VA_COPY)\n#define begin_va_copy(dst,src)\t__va_copy(dst, src)\n#define end_va_copy(dst)\tva_end(dst)\n#elif defined(va_copy) || defined(HAVE_VA_COPY)\n#define begin_va_copy(dst,src)\tva_copy(dst, src)\n#define end_va_copy(dst)\tva_end(dst)\n#else\n#define begin_va_copy(dst,src) (dst) = (src)\n#define end_va_copy(dst)\t \n#endif\n\n \n#ifndef S_ISDIR\n#define S_ISDIR(mode) ((mode & S_IFMT) == S_IFDIR)\n#endif\n\n#ifndef S_ISREG\n#define S_ISREG(mode) ((mode & S_IFMT) == S_IFREG)\n#endif\n\n \n#if USE_FOPEN_BIN_R\n#define BIN_R\t\"rb\"\n#define BIN_W\t\"wb\"\n#else\n#define BIN_R\t\"r\"\n#define BIN_W\t\"w\"\n#endif\n\n \n#if !USE_SCROLL_HINTS\n#if !USE_HASHMAP\n#define USE_SCROLL_HINTS 1\n#else\n#define USE_SCROLL_HINTS 0\n#endif\n#endif\n\n#if USE_SCROLL_HINTS\n#define if_USE_SCROLL_HINTS(stmt) stmt\n#else\n#define if_USE_SCROLL_HINTS(stmt)  \n#endif\n\n#include <nc_string.h>\n\n \n#ifdef USE_TERM_DRIVER\n#define NO_TERMINAL \"unknown\"\n#define USE_SP_RIPOFF     1\n#define USE_SP_TERMTYPE   1\n#define USE_SP_WINDOWLIST 1\n#else\n#define NO_TERMINAL 0\n#endif\n\n#define VALID_TERM_ENV(term_env, no_terminal) \\\n\t(term_env = (NonEmpty(term_env) \\\n\t\t     ? term_env \\\n\t\t     : no_terminal), \\\n\t NonEmpty(term_env))\n\n \n\n#define TRIES struct tries\ntypedef TRIES {\n\tTRIES    *child;             \n\tTRIES    *sibling;           \n\tunsigned char    ch;         \n\tunsigned short   value;      \n#undef TRIES\n} TRIES;\n\n \n#define StringOf(ch) {ch, 0}\n\n#define L_BRACE '{'\n#define R_BRACE '}'\n#define S_QUOTE '\\''\n#define D_QUOTE '\"'\n\n#define VT_ACSC \"``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~\"\n\n \n\n#define MAXCOLUMNS    135\n#define MAXLINES      66\n#define FIFO_SIZE     MAXCOLUMNS+2   \n\n#define ACS_LEN       128\n\n#define WINDOWLIST struct _win_list\n\n#if USE_WIDEC_SUPPORT\n#define _nc_bkgd    _bkgrnd\n#else\n#undef _XOPEN_SOURCE_EXTENDED\n#undef _XPG5\n#define _nc_bkgd    _bkgd\n#define wgetbkgrnd(win, wch)\t((*wch = win->_bkgd) != 0 ? OK : ERR)\n#define wbkgrnd\t    wbkgd\n#endif\n\n#undef NCURSES_OPAQUE\n#define NCURSES_INTERNALS 1\n#define NCURSES_OPAQUE 0\n\n#include <curses.h>\t \n\n#if !(defined(NCURSES_WGETCH_EVENTS) && defined(NEED_KEY_EVENT))\n#undef KEY_EVENT\t\t \n#endif\n\ntypedef struct\n{\n    int red, green, blue;\t \n    int r, g, b;\t\t \n    int init;\t\t\t \n}\ncolor_t;\n\ntypedef union {\n    struct {\n\tunsigned char red;\n\tunsigned char green;\n\tunsigned char blue;\n    } bits;\t\t\t \n    unsigned value;\n} rgb_bits_t;\n\n \n\n#define USE_SP_FUNC_SUPPORT     NCURSES_SP_FUNCS\n#define USE_EXT_SP_FUNC_SUPPORT (NCURSES_SP_FUNCS && NCURSES_EXT_FUNCS)\n\n#if NCURSES_SP_FUNCS\n#define SP_PARM         sp\t \n#define NCURSES_SP_ARG          SP_PARM\n#define NCURSES_SP_DCL  SCREEN *NCURSES_SP_ARG\n#define NCURSES_SP_DCL0 NCURSES_SP_DCL\n#define NCURSES_SP_ARGx         NCURSES_SP_ARG,\n#define NCURSES_SP_DCLx SCREEN *NCURSES_SP_ARGx\n#else\n#define SP_PARM         SP\t \n#define NCURSES_SP_ARG\n#define NCURSES_SP_DCL\n#define NCURSES_SP_DCL0 void\n#define NCURSES_SP_ARGx\n#define NCURSES_SP_DCLx\n#endif\n\n#include <nc_panel.h>\n\n#include <term.priv.h>\n#include <nc_termios.h>\n\n#define IsPreScreen(sp)      (((sp) != 0) && sp->_prescreen)\n#define HasTerminal(sp)      (((sp) != 0) && (0 != ((sp)->_term)))\n#define IsValidScreen(sp)    (HasTerminal(sp) && !IsPreScreen(sp))\n\n#if USE_REENTRANT\n#define CurTerm              _nc_prescreen._cur_term\n#else\n#define CurTerm              cur_term\n#endif\n\n#if NCURSES_SP_FUNCS\n#define TerminalOf(sp)       ((sp) ? ((sp)->_term ? (sp)->_term : CurTerm) : CurTerm)\n#else\n#define TerminalOf(sp)       CurTerm\n#endif\n\n \n#if NCURSES_EXT_COLORS && HAVE_INIT_EXTENDED_COLOR\n#define NCURSES_EXT_NUMBERS  1\n#define NCURSES_INT2         int\n#define SIZEOF_INT2          4\n#define TerminalType(tp)     (tp)->type2\n#else\n#define NCURSES_EXT_NUMBERS  0\n#define NCURSES_INT2         short\n#define SIZEOF_INT2          2\n#define TerminalType(tp)     (tp)->type\n#endif\n\n#define SIZEOF_SHORT         2\n\n#ifdef CUR\n#undef CUR\n#define CUR TerminalType(cur_term).\n#endif\n\n \n#ifdef USE_SP_TERMTYPE\n#undef CUR\n#endif\n\n#define SP_TERMTYPE TerminalType(TerminalOf(sp)).\n\n#include <term_entry.h>\n\n#include <nc_tparm.h>\n\n \n#if defined(A_ITALIC) && defined(exit_italics_mode)\n#define USE_ITALIC 1\n#else\n#define USE_ITALIC 0\n#undef  A_ITALIC\n#define A_ITALIC 0\n#endif\n\n \n#if 1\n#define ColorPair(n)\t\t(NCURSES_BITS(n, 0) & A_COLOR)\n#define PairNumber(a)\t\t(NCURSES_CAST(int,(((unsigned long)(a) & A_COLOR) >> NCURSES_ATTR_SHIFT)))\n#else\n#define ColorPair(pair)\t\tCOLOR_PAIR(pair)\n#define PairNumber(attr)\tPAIR_NUMBER(attr)\n#endif\n\n#define unColor(n)\t\tunColor2(AttrOf(n))\n#define unColor2(a)\t\t((a) & ALL_BUT_COLOR)\n\n \n#if NCURSES_EXT_COLORS\n#define if_EXT_COLORS(stmt)\tstmt\n#define SetPair(value,p)\tSetPair2((value).ext_color, AttrOf(value), p)\n#define SetPair2(c,a,p)\t\tc = (p), \\\n\t\t\t\ta = (unColor2(a) | ColorPair(oldColor(c)))\n#define GetPair(value)\t\tGetPair2((value).ext_color, AttrOf(value))\n#define GetPair2(c,a)\t\t((c) ? (c) : PairNumber(a))\n#define oldColor(p)\t\t(((p) > 255) ? 255 : (p))\n#define GET_WINDOW_PAIR(w)\tGetPair2((w)->_color, (w)->_attrs)\n#define SET_WINDOW_PAIR(w,p)\t(w)->_color = (p)\n#define SameAttrOf(a,b)\t\t(AttrOf(a) == AttrOf(b) && GetPair(a) == GetPair(b))\n\n#define VIDPUTS(sp,attr,pair)\tdo { \\\n\t\t\t\t    int vid_pair = pair; \\\n\t\t\t\t    NCURSES_SP_NAME(vid_puts)( \\\n\t\t\t\t\tNCURSES_SP_ARGx attr, \\\n\t\t\t\t\t(NCURSES_PAIRS_T) pair, \\\n\t\t\t\t\t&vid_pair, \\\n\t\t\t\t\tNCURSES_OUTC_FUNC); \\\n\t\t\t\t} while (0)\n\n#else  \n\n#define if_EXT_COLORS(stmt)\t \n#define SetPair(value,p)\tRemAttr(value, A_COLOR), \\\n\t\t\t\tSetAttr(value, AttrOf(value) | ColorPair(p))\n#define GetPair(value)\t\tPairNumber(AttrOf(value))\n#define GET_WINDOW_PAIR(w)\tPairNumber(WINDOW_ATTRS(w))\n#define SET_WINDOW_PAIR(w,p)\tWINDOW_ATTRS(w) &= ALL_BUT_COLOR, \\\n\t\t\t\tWINDOW_ATTRS(w) |= ColorPair(p)\n#define SameAttrOf(a,b)\t\t(AttrOf(a) == AttrOf(b))\n\n#define VIDPUTS(sp,attr,pair)\tNCURSES_SP_NAME(vidputs)(NCURSES_SP_ARGx attr, NCURSES_OUTC_FUNC)\n\n#endif  \n\n#define NCURSES_OUTC_FUNC       NCURSES_SP_NAME(_nc_outch)\n#define NCURSES_PUTP2(name,value)    NCURSES_SP_NAME(_nc_putp)(NCURSES_SP_ARGx name, value)\n#define NCURSES_PUTP2_FLUSH(name,value)    NCURSES_SP_NAME(_nc_putp_flush)(NCURSES_SP_ARGx name, value)\n\n#if NCURSES_NO_PADDING\n#define GetNoPadding(sp)\t((sp) ? (sp)->_no_padding : _nc_prescreen._no_padding)\n#define SetNoPadding(sp)\t_nc_set_no_padding(sp)\nextern NCURSES_EXPORT(void)     _nc_set_no_padding(SCREEN *);\n#else\n#define GetNoPadding(sp)\tFALSE\n#define SetNoPadding(sp)\t \n#endif\n\n#define WINDOW_ATTRS(w)\t\t((w)->_attrs)\n\n#define SCREEN_ATTRS(s)\t\t(*((s)->_current_attr))\n#define GET_SCREEN_PAIR(s)\tGetPair(SCREEN_ATTRS(s))\n#define SET_SCREEN_PAIR(s,p)\tSetPair(SCREEN_ATTRS(s), p)\n\n#if USE_REENTRANT || NCURSES_SP_FUNCS\nNCURSES_EXPORT(int *)        _nc_ptr_Lines (SCREEN *);\nNCURSES_EXPORT(int *)        _nc_ptr_Cols (SCREEN *);\nNCURSES_EXPORT(int *)        _nc_ptr_Tabsize (SCREEN *);\nNCURSES_EXPORT(int *)        _nc_ptr_Escdelay (SCREEN *);\n#endif\n\n#if USE_REENTRANT\n\n#define ptrLines(sp)         (sp ? &(sp->_LINES) : &(_nc_prescreen._LINES))\n#define ptrCols(sp)          (sp ? &(sp->_COLS) : &(_nc_prescreen._COLS))\n#define ptrTabsize(sp)       (sp ? &(sp->_TABSIZE) : &(_nc_prescreen._TABSIZE))\n#define ptrEscdelay(sp)      (sp ? &(sp->_ESCDELAY) : &(_nc_prescreen._ESCDELAY))\n\n#define SET_LINES(value)     *_nc_ptr_Lines(SP_PARM) = value\n#define SET_COLS(value)      *_nc_ptr_Cols(SP_PARM) = value\n#define SET_TABSIZE(value)   *_nc_ptr_Tabsize(SP_PARM) = value\n#define SET_ESCDELAY(value)  *_nc_ptr_Escdelay(SP_PARM) = value\n\n#else\n\n#define ptrLines(sp)         &LINES\n#define ptrCols(sp)          &COLS\n#define ptrTabsize(sp)       &TABSIZE\n#define ptrEscdelay(sp)      &ESCDELAY\n\n#define SET_LINES(value)     LINES = value\n#define SET_COLS(value)      COLS = value\n#define SET_TABSIZE(value)   TABSIZE = value\n#define SET_ESCDELAY(value)  ESCDELAY = value\n\n#endif\n\n#define IS_SUBWIN(w)         ((w)->_flags & _SUBWIN)\n#define IS_PAD(w)            ((w)->_flags & _ISPAD)\n#define IS_WRAPPED(w)        ((w)->_flags & _WRAPPED)\n\n#define HasHardTabs()\t(NonEmpty(clear_all_tabs) && NonEmpty(set_tab))\n\n#define TR_MUTEX(data) _tracef(\"%s@%d: me:%08lX COUNT:%2u/%2d/%6d/%2d/%s%9u: \" #data, \\\n\t    __FILE__, __LINE__, \\\n\t    (unsigned long) (pthread_self()), \\\n\t    data.__data.__lock, \\\n\t    data.__data.__count, \\\n\t    data.__data.__owner, \\\n\t    data.__data.__kind, \\\n\t    (data.__data.__nusers > 5) ? \" OOPS \" : \"\", \\\n\t    data.__data.__nusers)\n#define TR_GLOBAL_MUTEX(name) TR_MUTEX(_nc_globals.mutex_##name)\n\n#if USE_WEAK_SYMBOLS\n#if defined(__GNUC__)\n#  if defined __USE_ISOC99\n#    define _cat_pragma(exp)\t_Pragma(#exp)\n#    define _weak_pragma(exp)\t_cat_pragma(weak name)\n#  else\n#    define _weak_pragma(exp)\n#  endif\n#  define _declare(name)\t__extension__ extern __typeof__(name) name\n#  define weak_symbol(name)\t_weak_pragma(name) _declare(name) __attribute__((weak))\n#else\n#  undef USE_WEAK_SYMBOLS\n#  define USE_WEAK_SYMBOLS 0\n#endif\n#endif\n\n#ifdef USE_PTHREADS\n\n#if USE_REENTRANT\n#include <pthread.h>\nextern NCURSES_EXPORT(void) _nc_init_pthreads(void);\nextern NCURSES_EXPORT(void) _nc_mutex_init(pthread_mutex_t *);\nextern NCURSES_EXPORT(int) _nc_mutex_lock(pthread_mutex_t *);\nextern NCURSES_EXPORT(int) _nc_mutex_trylock(pthread_mutex_t *);\nextern NCURSES_EXPORT(int) _nc_mutex_unlock(pthread_mutex_t *);\n#define _nc_lock_global(name)\t_nc_mutex_lock(&_nc_globals.mutex_##name)\n#define _nc_try_global(name)    _nc_mutex_trylock(&_nc_globals.mutex_##name)\n#define _nc_unlock_global(name)\t_nc_mutex_unlock(&_nc_globals.mutex_##name)\n\n#else\n#error POSIX threads requires --enable-reentrant option\n#endif\n\n#ifdef USE_PTHREADS\n#  if USE_WEAK_SYMBOLS\nweak_symbol(pthread_sigmask);\nweak_symbol(pthread_kill);\nweak_symbol(pthread_self);\nweak_symbol(pthread_equal);\nweak_symbol(pthread_mutex_init);\nweak_symbol(pthread_mutex_lock);\nweak_symbol(pthread_mutex_unlock);\nweak_symbol(pthread_mutex_trylock);\nweak_symbol(pthread_mutexattr_settype);\nweak_symbol(pthread_mutexattr_init);\nextern NCURSES_EXPORT(int) _nc_sigprocmask(int, const sigset_t *, sigset_t *);\n#    undef  sigprocmask\n#    define sigprocmask(a, b, c) _nc_sigprocmask(a, b, c)\n#    define GetThreadID() (((pthread_self)) ? pthread_self() : (pthread_t) getpid())\n#  else\n#    define GetThreadID() pthread_self()\n#  endif\n#endif\n\n#if HAVE_NANOSLEEP\n#undef HAVE_NANOSLEEP\n#define HAVE_NANOSLEEP 0\t \n#endif\n\n#else  \n\n#if USE_PTHREADS_EINTR\n#  if USE_WEAK_SYMBOLS\n#include <pthread.h>\nweak_symbol(pthread_sigmask);\nweak_symbol(pthread_kill);\nweak_symbol(pthread_self);\nweak_symbol(pthread_equal);\nextern NCURSES_EXPORT(int) _nc_sigprocmask(int, const sigset_t *, sigset_t *);\n#    undef  sigprocmask\n#    define sigprocmask(a, b, c) _nc_sigprocmask(a, b, c)\n#  endif\n#endif  \n\n#define _nc_init_pthreads()\t \n#define _nc_mutex_init(obj)\t \n\n#define _nc_lock_global(name)\t \n#define _nc_try_global(name)    0\n#define _nc_unlock_global(name)\t \n#endif  \n\n#if USE_PTHREADS_EINTR\nextern NCURSES_EXPORT(void) _nc_set_read_thread(bool);\n#else\n#define _nc_set_read_thread(enable)\t \n#endif\n\n \n#if NCURSES_SP_FUNCS\n\n#define _nc_nonsp_lock_global(name)\t \n#define _nc_nonsp_try_global(name)    0\n#define _nc_nonsp_unlock_global(name)\t \n\n#define _nc_sp_lock_global(name)\t_nc_lock_global(name)\n#define _nc_sp_try_global(name)         _nc_try_global(name)\n#define _nc_sp_unlock_global(name)\t_nc_unlock_global(name)\n\n#else\n\n#define _nc_nonsp_lock_global(name)\t_nc_lock_global(name)\n#define _nc_nonsp_try_global(name)      _nc_try_global(name)\n#define _nc_nonsp_unlock_global(name)\t_nc_unlock_global(name)\n\n#define _nc_sp_lock_global(name)\t \n#define _nc_sp_try_global(name)    0\n#define _nc_sp_unlock_global(name)\t \n\n#endif\n\n#if HAVE_GETTIMEOFDAY\n# define PRECISE_GETTIME 1\n# define TimeType struct timeval\n#else\n# define PRECISE_GETTIME 0\n# define TimeType time_t\n#endif\n\n \n\n#define MAX_OF_TYPE(t)   (int)(((unsigned t)(~0))>>1)\n\n#include <new_pair.h>\n\n#define isDefaultColor(c)\t((c) < 0)\n#define COLOR_DEFAULT\t\t-1\n\n#if defined(USE_BUILD_CC) || (defined(USE_TERMLIB) && !defined(NEED_NCURSES_CH_T))\n\n#undef NCURSES_CH_T\t\t \n#define NCURSES_CH_T void\t \n\n#endif\t \n\n#ifndef USE_TERMLIB\nstruct ldat\n{\n\tNCURSES_CH_T\t*text;\t\t \n\tNCURSES_SIZE_T\tfirstchar;\t \n\tNCURSES_SIZE_T\tlastchar;\t \n\tNCURSES_SIZE_T\toldindex;\t \n};\n#endif\t \n\ntypedef enum {\n\tM_XTERM\t= -1\t\t \n\t,M_NONE = 0\t\t \n#if USE_GPM_SUPPORT\n\t,M_GPM\t\t\t \n#endif\n#if USE_SYSMOUSE\n\t,M_SYSMOUSE\t\t \n#endif\n#ifdef USE_TERM_DRIVER\n\t,M_TERM_DRIVER\t\t \n#endif\n} MouseType;\n\ntypedef enum {\n    \tMF_X10 = 0\t\t \n\t, MF_SGR1006\t\t \n#ifdef EXP_XTERM_1005\n\t, MF_XTERM_1005\t\t \n#endif\n} MouseFormat;\n\n \n\ntypedef struct {\n\tunsigned long hashval;\n\tint oldcount, newcount;\n\tint oldindex, newindex;\n} HASHMAP;\n\n \n\nstruct _SLK;\n\n#if !(defined(USE_TERMLIB) || defined(USE_BUILD_CC))\n\ntypedef struct\n{\n\tchar *ent_text;\t\t \n\tchar *form_text;\t \n\tint ent_x;\t\t \n\tchar dirty;\t\t \n\tchar visible;\t\t \n} slk_ent;\n\ntypedef struct _SLK {\n\tbool    dirty;\t\t \n\tbool    hidden;\t\t \n\tWINDOW  *win;\n\tslk_ent *ent;\n\tshort   maxlab;\t\t \n\tshort   labcnt;\t\t \n\tshort   maxlen;\t\t \n\tNCURSES_CH_T attr;\t \n} SLK;\n\n#endif\t \n\n#if USE_GPM_SUPPORT\n#undef buttons\t\t\t \n#include <gpm.h>\n#if USE_WEAK_SYMBOLS\nweak_symbol(Gpm_Wgetch);\n#endif\n\n#ifdef HAVE_LIBDL\n \ntypedef int *TYPE_gpm_fd;\ntypedef int (*TYPE_Gpm_Open) (Gpm_Connect *, int);\ntypedef int (*TYPE_Gpm_Close) (void);\ntypedef int (*TYPE_Gpm_GetEvent) (Gpm_Event *);\n\n#define my_gpm_fd       SP_PARM->_mouse_gpm_fd\n#define my_Gpm_Open     SP_PARM->_mouse_Gpm_Open\n#define my_Gpm_Close    SP_PARM->_mouse_Gpm_Close\n#define my_Gpm_GetEvent SP_PARM->_mouse_Gpm_GetEvent\n#else\n \n#define my_gpm_fd       &gpm_fd\n#define my_Gpm_Open     Gpm_Open\n#define my_Gpm_Close    Gpm_Close\n#define my_Gpm_GetEvent Gpm_GetEvent\n#endif  \n#endif  \n\n \n#define MAX_TC_FIXUPS\t10\n#define MIN_TC_FIXUPS\t4\n\n#define isoctal(c) ((c) >= '0' && (c) <= '7')\n\n \n#if MIXEDCASE_FILENAMES\n#define LEAF_FMT \"%c\"\n#define LEAF_LEN 1\n#else\n#define LEAF_FMT \"%02x\"\n#define LEAF_LEN 2\n#endif\n\n \n#define TRACEMSE_MAX\t(80 + (5 * 10) + (32 * 15))\n#define TRACEMSE_FMT\t\"id %2d  at (%2d, %2d, %2d) state %4lx = {\"  \n\n#ifdef USE_TERM_DRIVER\nstruct DriverTCB;  \n#define INIT_TERM_DRIVER()\t_nc_globals.term_driver = _nc_get_driver\n#else\n#define INIT_TERM_DRIVER()\t \n#endif\n\nextern NCURSES_EXPORT_VAR(NCURSES_GLOBALS) _nc_globals;\n\n \n#define my_getstr_limit\t(_nc_globals.getstr_limit - 1)\n#define _nc_getstr_limit(n) \\\n\t(((n) < 0) \\\n\t ? my_getstr_limit \\\n\t : (((n) > my_getstr_limit) \\\n\t    ? my_getstr_limit \\\n\t    : (n)))\n\n \n#ifdef USE_SP_RIPOFF\n#define safe_ripoff_sp     (sp)->rsp\n#define safe_ripoff_stack  (sp)->rippedoff\n#else\n#define safe_ripoff_sp\t   _nc_prescreen.rsp\n#define safe_ripoff_stack  _nc_prescreen.rippedoff\n#endif\n\nextern NCURSES_EXPORT_VAR(NCURSES_PRESCREEN) _nc_prescreen;\n\ntypedef enum {\n    ewInitial = 0,\n    ewRunning,\n    ewSuspend\n} ENDWIN;\n\n \ntypedef struct screen {\n\tint\t\t_ifd;\t\t \n\tint\t\t_ofd;\t\t \n\tFILE\t\t*_ofp;\t\t \n\tchar\t\t*out_buffer;\t \n\tsize_t\t\tout_limit;\t \n\tsize_t\t\tout_inuse;\t \n\tbool\t\t_filtered;\t \n\tbool\t\t_prescreen;\t \n\tbool\t\t_use_env;\t \n\tint\t\t_checkfd;\t \n\tTERMINAL\t*_term;\t\t \n\tTTY\t\t_saved_tty;\t \n\tNCURSES_SIZE_T\t_lines;\t\t \n\tNCURSES_SIZE_T\t_columns;\t \n\n\tNCURSES_SIZE_T\t_lines_avail;\t \n\tNCURSES_SIZE_T\t_topstolen;\t \n\n\tWINDOW\t\t*_curscr;\t \n\tWINDOW\t\t*_newscr;\t \n\tWINDOW\t\t*_stdscr;\t \n\n#define CurScreen(sp)  (sp)->_curscr\n#define NewScreen(sp)  (sp)->_newscr\n#define StdScreen(sp)  (sp)->_stdscr\n\n\tTRIES\t\t*_keytry;\t \n\tTRIES\t\t*_key_ok;\t \n\tbool\t\t_tried;\t\t \n\tbool\t\t_keypad_on;\t \n\n\tbool\t\t_called_wgetch;\t \n\tint\t\t_fifo[FIFO_SIZE];\t \n\tshort\t\t_fifohead,\t \n\t\t\t_fifotail,\t \n\t\t\t_fifopeek,\t \n\t\t\t_fifohold;\t \n\n\tint\t\t_endwin;\t \n\tNCURSES_CH_T\t*_current_attr;  \n\tint\t\t_coloron;\t \n\tint\t\t_color_defs;\t \n\tint\t\t_cursor;\t \n\tint\t\t_cursrow;\t \n\tint\t\t_curscol;\t \n\tbool\t\t_notty;\t\t \n\tint\t\t_nl;\t\t \n\tint\t\t_raw;\t\t \n\tint\t\t_cbreak;\t \n\t\t\t\t\t \n\tint\t\t_echo;\t\t \n\tint\t\t_use_meta;\t \n\tstruct _SLK\t*_slk;\t\t \n\tint\t\tslk_format;\t \n\t \n\tint\t\t_char_padding;\t \n\tint\t\t_cr_cost;\t \n\tint\t\t_cup_cost;\t \n\tint\t\t_home_cost;\t \n\tint\t\t_ll_cost;\t \n\tint\t\t_cub1_cost;\t \n\tint\t\t_cuf1_cost;\t \n\tint\t\t_cud1_cost;\t \n\tint\t\t_cuu1_cost;\t \n\tint\t\t_cub_cost;\t \n\tint\t\t_cuf_cost;\t \n\tint\t\t_cud_cost;\t \n\tint\t\t_cuu_cost;\t \n\tint\t\t_hpa_cost;\t \n\tint\t\t_vpa_cost;\t \n\t \n\tint\t\t_ed_cost;\t \n\tint\t\t_el_cost;\t \n\tint\t\t_el1_cost;\t \n\tint\t\t_dch1_cost;\t \n\tint\t\t_ich1_cost;\t \n\tint\t\t_dch_cost;\t \n\tint\t\t_ich_cost;\t \n\tint\t\t_ech_cost;\t \n\tint\t\t_rep_cost;\t \n\tint\t\t_hpa_ch_cost;\t \n\tint\t\t_cup_ch_cost;\t \n\tint\t\t_cuf_ch_cost;\t \n\tint\t\t_inline_cost;\t \n\tint\t\t_smir_cost;\t \n\tint\t\t_rmir_cost;\t \n\tint\t\t_ip_cost;\t \n\t \n\tchar *\t\t_address_cursor;\n\t \n\tint\t\t_scrolling;\t \n\n\t \n\trgb_bits_t\t_direct_color;\t \n\tcolor_t\t\t*_color_table;\t \n\tint\t\t_color_count;\t \n\tcolorpair_t\t*_color_pairs;\t \n\tint\t\t_pair_count;\t \n\tint\t\t_pair_limit;\t \n\tint\t\t_pair_alloc;\t \n\tchtype\t\t_ok_attributes;  \n\tchtype\t\t_xmc_suppress;\t \n\tchtype\t\t_xmc_triggers;\t \n\tchtype *\t_acs_map;\t \n\tbool *\t\t_screen_acs_map;\n\n\n\t \n\tbool\t\t_use_rmso;\t \n\tbool\t\t_use_rmul;\t \n\n\t \n\tbool\t\t_nc_sp_idlok;\n\tbool\t\t_nc_sp_idcok;\n\n\t \n\tbool\t\t_mouse_initialized;\n\tMouseType\t_mouse_type;\n\tint\t\t_maxclick;\n\tbool\t\t(*_mouse_event) (SCREEN *);\n\tbool\t\t(*_mouse_inline)(SCREEN *);\n\tbool\t\t(*_mouse_parse) (SCREEN *, int);\n\tvoid\t\t(*_mouse_resume)(SCREEN *);\n\tvoid\t\t(*_mouse_wrap)\t(SCREEN *);\n\tint\t\t_mouse_fd;\t \n\tbool\t\t_mouse_active;\t \n\tmmask_t\t\t_mouse_mask;\t \n\tmmask_t\t\t_mouse_mask2;\t \n\tmmask_t\t\t_mouse_bstate;\n\tMouseFormat\t_mouse_format;\t \n\tNCURSES_CONST char *_mouse_xtermcap;  \n\tMEVENT\t\t_mouse_events[EV_MAX];\t \n\tMEVENT\t\t*_mouse_eventp;\t \n\n\t \n\tstruct panelhook _panelHook;\n\n\tbool\t\t_sig_winch;\n\tSCREEN\t\t*_next_screen;\n\n\t \n\tunsigned long\t*oldhash, *newhash;\n\tHASHMAP\t\t*hashtab;\n\tint\t\thashtab_len;\n\tint\t\t*_oldnum_list;\n\tint\t\t_oldnum_size;\n\n\tNCURSES_SP_OUTC\t_outch;\t\t \n\tNCURSES_OUTC\tjump;\n\n\tripoff_t\trippedoff[N_RIPS];\n\tripoff_t\t*rsp;\n\n\tint\t\t_legacy_coding;\t \n\n#if NCURSES_NO_PADDING\n\tbool\t\t_no_padding;\t \n#endif\n\n#if USE_HARD_TABS\n\tint\t\t_ht_cost;\t \n\tint\t\t_cbt_cost;\t \n#endif  \n\n\t \n#if USE_ITALIC\n\tbool\t\t_use_ritm;\t \n#endif\n\n\t \n#if USE_KLIBC_KBD\n\tbool\t\t_extended_key;\t \n#endif\n\n\t \n#if NCURSES_EXT_FUNCS\n\tbool\t\t_assumed_color;  \n\tbool\t\t_default_color;  \n\tbool\t\t_has_sgr_39_49;  \n\tint\t\t_default_fg;\t \n\tint\t\t_default_bg;\t \n\tint\t\t_default_pairs;\t \n#endif\n\n\t \n#if USE_GPM_SUPPORT\n\tbool\t\t_mouse_gpm_loaded;\n\tbool\t\t_mouse_gpm_found;\n#ifdef HAVE_LIBDL\n\tvoid\t\t*_dlopen_gpm;\n\tTYPE_gpm_fd\t_mouse_gpm_fd;\n\tTYPE_Gpm_Open\t_mouse_Gpm_Open;\n\tTYPE_Gpm_Close\t_mouse_Gpm_Close;\n\tTYPE_Gpm_GetEvent _mouse_Gpm_GetEvent;\n#endif\n\tGpm_Connect\t_mouse_gpm_connect;\n#endif  \n\n#if USE_EMX_MOUSE\n\tint\t\t_emxmouse_wfd;\n\tint\t\t_emxmouse_thread;\n\tint\t\t_emxmouse_activated;\n\tchar\t\t_emxmouse_buttons[4];\n#endif\n\n#if USE_SYSMOUSE\n\tMEVENT\t\t_sysmouse_fifo[FIFO_SIZE];\n\tint\t\t_sysmouse_head;\n\tint\t\t_sysmouse_tail;\n\tint\t\t_sysmouse_char_width;\t \n\tint\t\t_sysmouse_char_height;\t \n\tint\t\t_sysmouse_old_buttons;\n\tint\t\t_sysmouse_new_buttons;\n#endif\n\n#if defined(USE_TERM_DRIVER) || defined(EXP_WIN32_DRIVER)\n\tMEVENT\t\t_drv_mouse_fifo[FIFO_SIZE];\n\tint\t\t_drv_mouse_head;\n\tint\t\t_drv_mouse_tail;\n\tint\t\t_drv_mouse_old_buttons;\n\tint\t\t_drv_mouse_new_buttons;\n#endif\n\t \n#if USE_SIZECHANGE\n\tint\t\t(*_resize)(NCURSES_SP_DCLx int y, int x);\n\tint\t\t(*_ungetch)(SCREEN *, int);\n#endif\n\n#ifdef USE_SP_WINDOWLIST\n\tWINDOWLIST*\t_windowlist;\n#define WindowList(sp)  (sp)->_windowlist\n#endif\n\n#if USE_REENTRANT\n\tchar\t\t_ttytype[NAMESIZE];\n\tint\t\t_ESCDELAY;\n\tint\t\t_TABSIZE;\n\tint\t\t_LINES;\n\tint\t\t_COLS;\n#endif\n\n#if NCURSES_SP_FUNCS\n\tbool\t\tuse_tioctl;\n#endif\n\n\t \n#if USE_WIDEC_SUPPORT\n\t \n\tbool\t\t_screen_acs_fix;\n\tbool\t\t_screen_unicode;\n#endif\n\n#if NCURSES_EXT_FUNCS && NCURSES_EXT_COLORS\n\tvoid\t\t*_ordered_pairs;  \n\tint\t\t_pairs_used;\t \n\tint\t\t_recent_pair;\t \n#endif\n\n#ifdef TRACE\n\tchar\t\ttracechr_buf[40];\n\tchar\t\ttracemse_buf[TRACEMSE_MAX];\n#if USE_REENTRANT\n\tlong\t\t_outchars;\n\tconst char\t*_tputs_trace;\n#endif\n#endif\n#undef SCREEN\n} SCREEN;\n\nextern NCURSES_EXPORT_VAR(SCREEN *) _nc_screen_chain;\nextern NCURSES_EXPORT_VAR(SIG_ATOMIC_T) _nc_have_sigwinch;\n\n\tWINDOWLIST {\n\tWINDOWLIST *next;\n\tSCREEN *screen;\t\t \n\tWINDOW\twin;\t\t \n#if NCURSES_WIDECHAR\n\tchar addch_work[(MB_LEN_MAX * 9) + 1];\n\tunsigned addch_used;\t \n\tint addch_x;\t\t \n\tint addch_y;\t\t \n#endif\n};\n\n#define WINDOW_EXT(w,m) (((WINDOWLIST *)((void *)((char *)(w) - offsetof(WINDOWLIST, win))))->m)\n\n#ifdef USE_SP_WINDOWLIST\n#define SP_INIT_WINDOWLIST(sp)\tWindowList(sp) = 0\n#else\n#define SP_INIT_WINDOWLIST(sp)\t \n#endif\n\n#define SP_PRE_INIT(sp)                         \\\n    sp->_cursrow = -1;                          \\\n    sp->_curscol = -1;                          \\\n    sp->_nl = TRUE;                             \\\n    sp->_raw = FALSE;                           \\\n    sp->_cbreak = 0;                            \\\n    sp->_echo = TRUE;                           \\\n    sp->_fifohead = -1;                         \\\n    sp->_endwin = ewSuspend;                    \\\n    sp->_cursor = -1;                           \\\n    SP_INIT_WINDOWLIST(sp);                     \\\n    sp->_outch = NCURSES_OUTC_FUNC;             \\\n    sp->jump = 0                                \\\n\n \n#ifndef UCHAR_MAX\n#define UCHAR_MAX 255\n#endif\n\n \n#define is7bits(c)\t((unsigned)(c) < 128)\n\n \n#define is8bits(c)\t((unsigned)(c) <= UCHAR_MAX)\n\n#ifndef min\n#define min(a,b)\t((a) > (b)  ?  (b)  :  (a))\n#endif\n\n#ifndef max\n#define max(a,b)\t((a) < (b)  ?  (b)  :  (a))\n#endif\n\n \n#ifndef STDIN_FILENO\n#define STDIN_FILENO 0\n#endif\n\n#ifndef STDOUT_FILENO\n#define STDOUT_FILENO 1\n#endif\n\n#ifndef STDERR_FILENO\n#define STDERR_FILENO 2\n#endif\n\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS 0\n#endif\n\n#ifndef EXIT_FAILURE\n#define EXIT_FAILURE 1\n#endif\n\n#ifndef R_OK\n#define\tR_OK\t4\t\t \n#endif\n#ifndef W_OK\n#define\tW_OK\t2\t\t \n#endif\n#ifndef X_OK\n#define\tX_OK\t1\t\t \n#endif\n#ifndef F_OK\n#define\tF_OK\t0\t\t \n#endif\n\n#if HAVE_FCNTL_H\n#include <fcntl.h>\t\t \n#endif\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#ifdef TRACE\n#if USE_REENTRANT\n#define COUNT_OUTCHARS(n) _nc_count_outchars(n);\n#else\n#define COUNT_OUTCHARS(n) _nc_outchars += (n);\n#endif\n#else\n#define COUNT_OUTCHARS(n)  \n#endif\n\n#define RESET_OUTCHARS() COUNT_OUTCHARS(-_nc_outchars)\n\n#define UChar(c)\t((unsigned char)(c))\n#define UShort(c)\t((unsigned short)(c))\n#define ChCharOf(c)\t((chtype)(c) & (chtype)A_CHARTEXT)\n#define ChAttrOf(c)\t((chtype)(c) & (chtype)A_ATTRIBUTES)\n\n#define TR_PUTC(c)\tTR(TRACE_CHARPUT, (\"PUTC %#x\", UChar(c)))\n\n#ifndef MB_LEN_MAX\n#define MB_LEN_MAX 8  \n#endif\n\n#if USE_WIDEC_SUPPORT  \n#define isEILSEQ(status) (((size_t)status == (size_t)-1) && (errno == EILSEQ))\n\n#define init_mb(state)\tmemset(&(state), 0, sizeof(state))\n\n#if NCURSES_EXT_COLORS\n#define NulColor\t, 0\n#else\n#define NulColor\t \n#endif\n\n#define NulChar\t\t0,0,0,0\t \n#define CharOf(c)\t((c).chars[0])\n#define AttrOf(c)\t((c).attr)\n\n#define AddAttr(c,a)\tAttrOf(c) |=  ((a) & A_ATTRIBUTES)\n#define RemAttr(c,a)\tAttrOf(c) &= ~((a) & A_ATTRIBUTES)\n#define SetAttr(c,a)\tAttrOf(c) =   ((a) & A_ATTRIBUTES) | WidecExt(c)\n\n#define NewChar2(c,a)\t{ a, { c, NulChar } NulColor }\n#define NewChar(ch)\tNewChar2(ChCharOf(ch), ChAttrOf(ch))\n\n#if CCHARW_MAX == 5\n#define CharEq(a,b)\t(((a).attr == (b).attr) \\\n\t\t       && (a).chars[0] == (b).chars[0] \\\n\t\t       && (a).chars[1] == (b).chars[1] \\\n\t\t       && (a).chars[2] == (b).chars[2] \\\n\t\t       && (a).chars[3] == (b).chars[3] \\\n\t\t       && (a).chars[4] == (b).chars[4] \\\n\t\t\tif_EXT_COLORS(&& (a).ext_color == (b).ext_color))\n#elif CCHARW_MAX > 0\n#error Inconsistent values for CCHARW_MAX\n#else\n#define CharEq(a,b)\t(!memcmp(&(a), &(b), sizeof(a)))\n#endif\n\n#define SetChar(ch,c,a) do {\t\t\t\t\t\t\t    \\\n\t\t\t    NCURSES_CH_T *_cp = &(ch);\t\t\t\t    \\\n\t\t\t    memset(_cp, 0, sizeof(ch));\t\t\t\t    \\\n\t\t\t    _cp->chars[0] = (wchar_t) (c);\t\t\t    \\\n\t\t\t    _cp->attr = (a);\t\t\t\t\t    \\\n\t\t\t    if_EXT_COLORS(SetPair(ch, PairNumber(a)));\t\t    \\\n\t\t\t} while (0)\n#define CHREF(wch)\t(&(wch))\n#define CHDEREF(wch)\t(*(wch))\n#define ARG_CH_T\tNCURSES_CH_T *\n#define CARG_CH_T\tconst NCURSES_CH_T *\n#define PUTC_DATA\tchar PUTC_buf[MB_LEN_MAX]; int PUTC_i, PUTC_n; \\\n\t\t\tmbstate_t PUT_st; wchar_t PUTC_ch\n#define PUTC_INIT\tinit_mb (PUT_st)\n#define PUTC(ch)\tdo { if(!isWidecExt(ch)) {\t\t\t\t    \\\n\t\t\tif (Charable(ch)) {\t\t\t\t\t    \\\n\t\t\t    TR_PUTC(CharOf(ch));\t\t\t\t    \\\n\t\t\t    NCURSES_OUTC_FUNC (NCURSES_SP_ARGx CharOf(ch));\t    \\\n\t\t\t    COUNT_OUTCHARS(1);\t\t\t\t\t    \\\n\t\t\t} else {\t\t\t\t\t\t    \\\n\t\t\t    for (PUTC_i = 0; PUTC_i < CCHARW_MAX; ++PUTC_i) {\t    \\\n\t\t\t\tPUTC_ch = (ch).chars[PUTC_i];\t\t\t    \\\n\t\t\t\tif (PUTC_ch == L'\\0')\t\t\t\t    \\\n\t\t\t\t    break;\t\t\t\t\t    \\\n\t\t\t\tPUTC_INIT;\t\t\t\t\t    \\\n\t\t\t\tPUTC_n = (int) wcrtomb(PUTC_buf,\t\t    \\\n\t\t\t\t\t\t       (ch).chars[PUTC_i], &PUT_st); \\\n\t\t\t\tif (PUTC_n <= 0) {\t\t\t\t    \\\n\t\t\t\t    if (PUTC_ch && is8bits(PUTC_ch) && PUTC_i == 0) { \\\n\t\t\t\t\tTR_PUTC(CharOf(ch));\t\t\t    \\\n\t\t\t\t\tNCURSES_OUTC_FUNC (NCURSES_SP_ARGx CharOf(ch)); \\\n\t\t\t\t    }\t\t\t\t\t\t    \\\n\t\t\t\t    break;\t\t\t\t\t    \\\n\t\t\t\t} else {\t\t\t\t\t    \\\n\t\t\t\t    int PUTC_j;\t\t\t\t\t    \\\n\t\t\t\t    for (PUTC_j = 0; PUTC_j < PUTC_n; ++PUTC_j) {   \\\n\t\t\t\t\tTR_PUTC(PUTC_buf[PUTC_j]);\t\t    \\\n\t\t\t\t\tNCURSES_OUTC_FUNC (NCURSES_SP_ARGx PUTC_buf[PUTC_j]); \\\n\t\t\t\t    }\t\t\t\t\t\t    \\\n\t\t\t\t}\t\t\t\t\t\t    \\\n\t\t\t    }\t\t\t\t\t\t\t    \\\n\t\t\t    COUNT_OUTCHARS(PUTC_i);\t\t\t\t    \\\n\t\t\t} } } while (0)\n\n#define BLANK\t\tNewChar2(' ', WA_NORMAL)\n#define ZEROS\t\tNewChar2('\\0', WA_NORMAL)\n#define ISBLANK(ch)\t((ch).chars[0] == L' ' && (ch).chars[1] == L'\\0')\n\n\t \n#define WidecExt(ch)\t(int) (AttrOf(ch) & A_CHARTEXT)\n#define isWidecBase(ch)\t(WidecExt(ch) == 1)\n#define isWidecExt(ch)\t(WidecExt(ch) > 1 && WidecExt(ch) < 32)\n#define SetWidecExt(dst, ext)\tAttrOf(dst) &= ~A_CHARTEXT,\t\t\\\n\t\t\t\tAttrOf(dst) |= (attr_t) (ext + 1)\n\n#define if_WIDEC(code)  code\n#define Charable(ch)\t(((SP_PARM->_legacy_coding)\t\t\t\\\n\t\t\t || (AttrOf(ch) & A_ALTCHARSET)\t\t\t\\\n\t\t\t || (!isWidecExt(ch))) &&\t\t\t\\\n\t\t\t     (ch).chars[1] == L'\\0' &&\t\t\t\\\n\t\t\t     _nc_is_charable(CharOf(ch)))\n\n#define L(ch)\t\tL ## ch\n#else  \n#define CharOf(c)\tChCharOf(c)\n#define AttrOf(c)\tChAttrOf(c)\n#define AddAttr(c,a)\tc |= (a)\n#define RemAttr(c,a)\tc &= ~((a) & A_ATTRIBUTES)\n#define SetAttr(c,a)\tc = ((c) & ~A_ATTRIBUTES) | (a)\n#define NewChar(ch)\t(ch)\n#define NewChar2(c,a)\t((c) | (a))\n#define CharEq(a,b)\t((a) == (b))\n#define SetChar(ch,c,a)\tch = (c) | (a)\n#define CHREF(wch)\twch\n#define CHDEREF(wch)\twch\n#define ARG_CH_T\tNCURSES_CH_T\n#define CARG_CH_T\tNCURSES_CH_T\n#define PUTC_DATA\t \n#define PUTC(ch)\t{ \\\n\t\t\t    TR_PUTC(ch); \\\n\t\t\t    NCURSES_OUTC_FUNC (NCURSES_SP_ARGx (int) ch); \\\n\t\t\t}\n\n#define BLANK\t\t(' '|A_NORMAL)\n#define ZEROS\t\t('\\0'|A_NORMAL)\n#define ISBLANK(ch)\t(CharOf(ch) == ' ')\n\n#define isWidecExt(ch)\t(0)\n#define if_WIDEC(code)  \n\n#define Charable(ch)\t((ch) >= ' ' && (ch) <= '~')\n#define L(ch)\t\tch\n#endif  \n\n#define AttrOfD(ch)\tAttrOf(CHDEREF(ch))\n#define CharOfD(ch)\tCharOf(CHDEREF(ch))\n#define SetChar2(wch,ch)    SetChar(wch,ChCharOf(ch),ChAttrOf(ch))\n\n#define BLANK_ATTR\tA_NORMAL\n#define BLANK_TEXT\tL(' ')\n\n#define CHANGED     -1\n\n#define LEGALYX(w, y, x) \\\n\t      ((w) != 0 && \\\n\t\t((x) >= 0 && (x) <= (w)->_maxx && \\\n\t\t (y) >= 0 && (y) <= (w)->_maxy))\n\n#define CHANGED_CELL(line,col) \\\n\tif (line->firstchar == _NOCHANGE) \\\n\t\tline->firstchar = line->lastchar = (NCURSES_SIZE_T) (col); \\\n\telse if ((col) < line->firstchar) \\\n\t\tline->firstchar = (NCURSES_SIZE_T) (col); \\\n\telse if ((col) > line->lastchar) \\\n\t\tline->lastchar = (NCURSES_SIZE_T) (col)\n\n#define CHANGED_RANGE(line,start,end) \\\n\tif (line->firstchar == _NOCHANGE \\\n\t || line->firstchar > (start)) \\\n\t\tline->firstchar = (NCURSES_SIZE_T) (start); \\\n\tif (line->lastchar == _NOCHANGE \\\n\t || line->lastchar < (end)) \\\n\t\tline->lastchar = (NCURSES_SIZE_T) (end)\n\n#define CHANGED_TO_EOL(line,start,end) \\\n\tif (line->firstchar == _NOCHANGE \\\n\t || line->firstchar > (start)) \\\n\t\tline->firstchar = (NCURSES_SIZE_T) (start); \\\n\tline->lastchar = (NCURSES_SIZE_T) (end)\n\n#define SIZEOF(v) (sizeof(v)/sizeof(v[0]))\n\n#define FreeIfNeeded(p)  if ((p) != 0) free(p)\n\n \n#define FreeAndNull(p)   do { free(p); p = 0; } while (0)\n\n#include <nc_alloc.h>\n#include <nc_access.h>\n\n \n#define TYPE_MALLOC(type, size, name) \\\n\tdo { \\\n\t    name = typeMalloc(type, size); \\\n\t    if (name == 0) \\\n\t\t_nc_err_abort(MSG_NO_MEMORY); \\\n\t} while (0)\n\n#define TYPE_CALLOC(type, size, name) \\\n\tdo { \\\n\t    name = typeCalloc(type, size); \\\n\t    if (name == 0) \\\n\t\t_nc_err_abort(MSG_NO_MEMORY); \\\n\t} while (0)\n\n#define TYPE_REALLOC(type, size, name) \\\n\tdo { \\\n\t    name = typeRealloc(type, size, name); \\\n\t    if (name == 0) \\\n\t\t_nc_err_abort(MSG_NO_MEMORY); \\\n\t} while (0)\n\n \n#ifdef TAB3\n# define OFLAGS_TABS TAB3\t \n#else\n# ifdef XTABS\n#  define OFLAGS_TABS XTABS\t \n# else\n#  ifdef OXTABS\n#   define OFLAGS_TABS OXTABS\t \n#  else\n#   define OFLAGS_TABS 0\n#  endif\n# endif\n#endif\n\n#ifdef __TANDEM\n#define ROOT_UID 65535\n#endif\n\n#ifndef ROOT_UID\n#define ROOT_UID 0\n#endif\n\n \n#define each_screen(p) p = _nc_screen_chain; p != 0; p = (p)->_next_screen\n#define each_window(sp,p) p = WindowList(sp); p != 0; p = (p)->next\n#define each_ripoff(p) p = safe_ripoff_stack; (p - safe_ripoff_stack) < N_RIPS; ++p\n\n \n#define T_CALLED(fmt) \"called {\" fmt\n#define T_CREATE(fmt) \"create :\" fmt\n#define T_RETURN(fmt) \"return }\" fmt\n\n#define NonNull(s)              ((s) != 0 ? s : \"<null>\")\n#define NonEmpty(s)             ((s) != 0 && *(s) != '\\0')\n\n#ifdef TRACE\n\n#if USE_REENTRANT\n#define TPUTS_TRACE(s)\t_nc_set_tputs_trace(s);\n#else\n#define TPUTS_TRACE(s)\t_nc_tputs_trace = s;\n#endif\n\n#ifdef HAVE_CONSISTENT_GETENV\n#define START_TRACE() \\\n\tif ((_nc_tracing & TRACE_MAXIMUM) == 0) { \\\n\t    int t = _nc_getenv_num(\"NCURSES_TRACE\"); \\\n\t    if (t >= 0) \\\n\t\tcurses_trace((unsigned) t); \\\n\t}\n#else\n#define START_TRACE()  \n#endif\n\n \n#if USE_REENTRANT\n#define USE_TRACEF(mask) _nc_use_tracef(mask)\nextern NCURSES_EXPORT(int)\t_nc_use_tracef (unsigned);\nextern NCURSES_EXPORT(void)\t_nc_locked_tracef (const char *, ...) GCC_PRINTFLIKE(1,2);\n#else\n#define USE_TRACEF(mask) (_nc_tracing & (mask))\n#define _nc_locked_tracef _tracef\n#endif\n\n#define TR(n, a)\tif (USE_TRACEF(n)) _nc_locked_tracef a\n#define T(a)\t\tTR(TRACE_CALLS, a)\n#define TRACE_RETURN(value,type)     return _nc_retrace_##type((type)(value))\n#define TRACE_RETURN1(value,dst)     return _nc_retrace_##dst(value)\n#define TRACE_RETURN2(value,dst,src) return _nc_retrace_##dst##_##src(value)\n#define TRACE_RETURN_SP(value,type)  return _nc_retrace_##type(SP_PARM, value)\n\ntypedef void VoidFunc(void);\n\n#define TR_FUNC_LEN\t\t((sizeof(void *) + sizeof(void (*)(void))) * 2 + 4)\n#define TR_FUNC_BFR(max)\tchar tr_func_data[max][TR_FUNC_LEN]\n#define TR_FUNC_ARG(num,func)\t_nc_fmt_funcptr(&tr_func_data[num][0], (const char *)&(func), sizeof((func)))\n\n#define returnAttr(code)\tTRACE_RETURN(code,attr_t)\n#define returnBits(code)\tTRACE_RETURN(code,unsigned)\n#define returnBool(code)\tTRACE_RETURN(code,bool)\n#define returnCPtr(code)\tTRACE_RETURN1(code,cptr)\n#define returnCVoidPtr(code)\tTRACE_RETURN1(code,cvoid_ptr)\n#define returnChar(code)\tTRACE_RETURN(code,char)\n#define returnChtype(code)\tTRACE_RETURN(code,chtype)\n#define returnCode(code)\tTRACE_RETURN(code,int)\n#define returnIntAttr(code)\tTRACE_RETURN2(code,int,attr_t)\n#define returnMMask(code)\tTRACE_RETURN_SP(code,mmask_t)\n#define returnPtr(code)\t\tTRACE_RETURN1(code,ptr)\n#define returnSP(code)\t\tTRACE_RETURN1(code,sp)\n#define returnVoid\t\tT((T_RETURN(\"\"))); return\n#define returnVoidPtr(code)\tTRACE_RETURN1(code,void_ptr)\n#define returnWin(code)\t\tTRACE_RETURN1(code,win)\n\n#define returnDB(rc)\t\tdo { TR(TRACE_DATABASE,(T_RETURN(\"code %d\"), (rc))); return (rc); } while (0)\n#define returnPtrDB(rc)\t\tdo { TR(TRACE_DATABASE,(T_RETURN(\"%p\"), (rc))); return (rc); } while (0)\n#define returnVoidDB\t\tdo { TR(TRACE_DATABASE,(T_RETURN(\"\"))); return; } while (0)\n\nextern NCURSES_EXPORT(NCURSES_BOOL)     _nc_retrace_bool (int);\nextern NCURSES_EXPORT(NCURSES_CONST void *) _nc_retrace_cvoid_ptr (NCURSES_CONST void *);\nextern NCURSES_EXPORT(SCREEN *)         _nc_retrace_sp (SCREEN *);\nextern NCURSES_EXPORT(WINDOW *)         _nc_retrace_win (WINDOW *);\nextern NCURSES_EXPORT(attr_t)           _nc_retrace_attr_t (attr_t);\nextern NCURSES_EXPORT(char *)           _nc_retrace_ptr (char *);\nextern NCURSES_EXPORT(char *)           _nc_trace_ttymode(const TTY *tty);\nextern NCURSES_EXPORT(char *)           _nc_varargs (const char *, va_list);\nextern NCURSES_EXPORT(chtype)           _nc_retrace_chtype (chtype);\nextern NCURSES_EXPORT(const char *)     _nc_altcharset_name(attr_t, chtype);\nextern NCURSES_EXPORT(const char *)     _nc_retrace_cptr (const char *);\nextern NCURSES_EXPORT(char)             _nc_retrace_char (int);\nextern NCURSES_EXPORT(int)              _nc_retrace_int (int);\nextern NCURSES_EXPORT(int)              _nc_retrace_int_attr_t (attr_t);\nextern NCURSES_EXPORT(mmask_t)          _nc_retrace_mmask_t (SCREEN *, mmask_t);\nextern NCURSES_EXPORT(unsigned)         _nc_retrace_unsigned (unsigned);\nextern NCURSES_EXPORT(void *)           _nc_retrace_void_ptr (void *);\nextern NCURSES_EXPORT(void)             _nc_fifo_dump (SCREEN *);\n\nextern NCURSES_EXPORT(char *)           _nc_fmt_funcptr(char *, const char *, size_t);\n\n#if USE_REENTRANT\nNCURSES_WRAPPED_VAR(long, _nc_outchars);\nNCURSES_WRAPPED_VAR(const char *, _nc_tputs_trace);\n#define _nc_outchars       NCURSES_PUBLIC_VAR(_nc_outchars())\n#define _nc_tputs_trace    NCURSES_PUBLIC_VAR(_nc_tputs_trace())\nextern NCURSES_EXPORT(void)\t\t_nc_set_tputs_trace (const char *);\nextern NCURSES_EXPORT(void)\t\t_nc_count_outchars (long);\n#else\nextern NCURSES_EXPORT_VAR(const char *) _nc_tputs_trace;\nextern NCURSES_EXPORT_VAR(long)         _nc_outchars;\n#endif\n\nextern NCURSES_EXPORT_VAR(unsigned)     _nc_tracing;\n\nextern NCURSES_EXPORT(char *) _nc_tracebits (void);\nextern NCURSES_EXPORT(char *) _tracemouse (const MEVENT *);\nextern NCURSES_EXPORT(void) _tracedump (const char *, WINDOW *);\n\n#if USE_WIDEC_SUPPORT\nextern NCURSES_EXPORT(const char *) _nc_viswbuf2 (int, const wchar_t *);\nextern NCURSES_EXPORT(const char *) _nc_viswbufn (const wchar_t *, int);\n#endif\n\nextern NCURSES_EXPORT(const char *) _nc_viscbuf2 (int, const NCURSES_CH_T *, int);\nextern NCURSES_EXPORT(const char *) _nc_viscbuf (const NCURSES_CH_T *, int);\n\n#else  \n\n#define START_TRACE()  \n\n#define T(a)\n#define TR(n, a)\n#define TPUTS_TRACE(s)\n#define TR_FUNC_BFR(max)\n\n#define returnAttr(code)\treturn code\n#define returnBits(code)\treturn code\n#define returnBool(code)\treturn code\n#define returnCPtr(code)\treturn code\n#define returnCVoidPtr(code)\treturn code\n#define returnChar(code)\treturn ((char) code)\n#define returnChtype(code)\treturn code\n#define returnCode(code)\treturn code\n#define returnIntAttr(code)\treturn code\n#define returnMMask(code)\treturn code\n#define returnPtr(code)\t\treturn code\n#define returnSP(code)\t\treturn code\n#define returnVoid\t\treturn\n#define returnVoidPtr(code)\treturn code\n#define returnWin(code)\t\treturn code\n\n#define returnDB(code)\t\treturn code\n#define returnPtrDB(rc)\t\treturn rc\n#define returnVoidDB\t\treturn\n\n#endif  \n\n \n#if defined(__GNUC__) && defined(_FORTIFY_SOURCE)\n#define IGNORE_RC(func) errno = (int) func\n#else\n#define IGNORE_RC(func) (void) func\n#endif  \n\n \n#define TGETENT_YES  1\t\t \n#define TGETENT_NO   0\t\t \n#define TGETENT_ERR -1\t\t \n\nextern NCURSES_EXPORT(const char *) _nc_visbuf2 (int, const char *);\nextern NCURSES_EXPORT(const char *) _nc_visbufn (const char *, int);\n\n#define EMPTY_MODULE(name) \\\nextern\tNCURSES_EXPORT(void) name (void); \\\n\tNCURSES_EXPORT(void) name (void) { }\n\n#define ALL_BUT_COLOR ((chtype)~(A_COLOR))\n#define NONBLANK_ATTR (A_BOLD | A_DIM | A_BLINK | A_ITALIC)\n#define TPARM_ATTR    (A_STANDOUT | A_UNDERLINE | A_REVERSE | A_BLINK | A_DIM | A_BOLD | A_ALTCHARSET | A_INVIS | A_PROTECT)\n#define XMC_CONFLICT  (A_STANDOUT | A_UNDERLINE | A_REVERSE | A_BLINK | A_DIM | A_BOLD | A_INVIS | A_PROTECT | A_ITALIC)\n#define XMC_CHANGES(c) ((c) & SP_PARM->_xmc_suppress)\n\n#define toggle_attr_on(S,at) {\\\n   if (PairNumber(at) > 0) {\\\n      (S) = ((S) & ALL_BUT_COLOR) | (attr_t) (at);\\\n   } else {\\\n      (S) |= (attr_t) (at);\\\n   }\\\n   TR(TRACE_ATTRS, (\"new attribute is %s\", _traceattr((S))));}\n\n\n#define toggle_attr_off(S,at) {\\\n   if (PairNumber(at) > 0) {\\\n      (S) &= ~(at|A_COLOR);\\\n   } else {\\\n      (S) &= ~(at);\\\n   }\\\n   TR(TRACE_ATTRS, (\"new attribute is %s\", _traceattr((S))));}\n\n#define DelCharCost(sp,count) \\\n\t\t((parm_dch != 0) \\\n\t\t? sp->_dch_cost \\\n\t\t: ((delete_character != 0) \\\n\t\t\t? (sp->_dch1_cost * count) \\\n\t\t\t: INFINITY))\n\n#define InsCharCost(sp,count) \\\n\t\t((parm_ich != 0) \\\n\t\t? sp->_ich_cost \\\n\t\t: ((enter_insert_mode && exit_insert_mode) \\\n\t\t  ? sp->_smir_cost + sp->_rmir_cost + (sp->_ip_cost * count) \\\n\t\t  : ((insert_character != 0) \\\n\t\t    ? ((sp->_ich1_cost + sp->_ip_cost) * count) \\\n\t\t    : INFINITY)))\n\n#if USE_XMC_SUPPORT\n#define UpdateAttrs(sp,c) if (!SameAttrOf(SCREEN_ATTRS(sp), c)) { \\\n\t\t\t\tattr_t chg = AttrOf(SCREEN_ATTRS(sp)); \\\n\t\t\t\tVIDPUTS(sp, AttrOf(c), GetPair(c)); \\\n\t\t\t\tif (magic_cookie_glitch > 0 \\\n\t\t\t\t && XMC_CHANGES((chg ^ AttrOf(SCREEN_ATTRS(sp))))) { \\\n\t\t\t\t\tT((\"%s @%d before glitch %d,%d\", \\\n\t\t\t\t\t\t__FILE__, __LINE__, \\\n\t\t\t\t\t\tsp->_cursrow, \\\n\t\t\t\t\t\tsp->_curscol)); \\\n\t\t\t\t\tNCURSES_SP_NAME(_nc_do_xmc_glitch)(NCURSES_SP_ARGx chg); \\\n\t\t\t\t} \\\n\t\t\t}\n#else\n#define UpdateAttrs(sp,c) if (!SameAttrOf(SCREEN_ATTRS(sp), c)) { \\\n\t\t\t\t    VIDPUTS(sp, AttrOf(c), GetPair(c)); \\\n\t\t\t}\n#endif\n\n \n#ifdef NCURSES_WGETCH_EVENTS\n#define EVENTLIST_0th(param) param\n#define EVENTLIST_1st(param) param\n#define EVENTLIST_2nd(param) , param\n#define TWAIT_MASK (TW_ANY | TW_EVENT)\n#else\n#define EVENTLIST_0th(param) void\n#define EVENTLIST_1st(param)  \n#define EVENTLIST_2nd(param)  \n#define TWAIT_MASK TW_ANY\n#endif\n\n#if NCURSES_EXPANDED && NCURSES_EXT_FUNCS\n\n#undef  toggle_attr_on\n#define toggle_attr_on(S,at) _nc_toggle_attr_on(&(S), at)\nextern NCURSES_EXPORT(void) _nc_toggle_attr_on (attr_t *, attr_t);\n\n#undef  toggle_attr_off\n#define toggle_attr_off(S,at) _nc_toggle_attr_off(&(S), at)\nextern NCURSES_EXPORT(void) _nc_toggle_attr_off (attr_t *, attr_t);\n\n#undef  DelCharCost\n#define DelCharCost(sp, count) NCURSES_SP_NAME(_nc_DelCharCost)(NCURSES_SP_ARGx count)\n\n#undef  InsCharCost\n#define InsCharCost(sp, count) NCURSES_SP_NAME(_nc_InsCharCost)(NCURSES_SP_ARGx count)\n\nextern NCURSES_EXPORT(int) NCURSES_SP_NAME(_nc_DelCharCost) (NCURSES_SP_DCLx int _c);\nextern NCURSES_EXPORT(int) NCURSES_SP_NAME(_nc_InsCharCost) (NCURSES_SP_DCLx int _c);\n\n#undef  UpdateAttrs\n#define UpdateAttrs(sp,c) NCURSES_SP_NAME(_nc_UpdateAttrs)(NCURSES_SP_ARGx CHREF(c))\n\n#if USE_WIDEC_SUPPORT || defined(NEED_NCURSES_CH_T)\nextern NCURSES_EXPORT(void) NCURSES_SP_NAME(_nc_UpdateAttrs) (NCURSES_SP_DCLx CARG_CH_T _c);\n#else\nextern NCURSES_EXPORT(void) NCURSES_SP_NAME(_nc_UpdateAttrs) (NCURSES_SP_DCLx chtype c);\n#endif\n\n#if NCURSES_SP_FUNCS\nextern NCURSES_EXPORT(int) _nc_DelCharCost (int);\nextern NCURSES_EXPORT(int) _nc_InsCharCost (int);\nextern NCURSES_EXPORT(void) _nc_UpdateAttrs (CARG_CH_T);\n#endif  \n\n#else\n\nextern NCURSES_EXPORT(void) _nc_expanded (void);\n\n#endif\n\n#if !NCURSES_EXT_FUNCS\n#define set_escdelay(value) ESCDELAY = value\n#endif\n\n#if !HAVE_GETCWD\n#define getcwd(buf,len) getwd(buf)\n#endif\n\n#define save_ttytype(termp) \\\n\tif (TerminalType(termp).term_names != 0) { \\\n\t    _nc_STRNCPY(ttytype, \\\n\t    \t\tTerminalType(termp).term_names, \\\n\t\t\tNAMESIZE - 1); \\\n\t    ttytype[NAMESIZE - 1] = '\\0'; \\\n\t}\n\n#if !NCURSES_WCWIDTH_GRAPHICS\nextern NCURSES_EXPORT(int) _nc_wacs_width(unsigned);\n#else\n#define _nc_wacs_width(ch) wcwidth(ch)\n#endif\n\n \n#if USE_WIDEC_SUPPORT\nextern NCURSES_EXPORT(bool) _nc_is_charable(wchar_t);\nextern NCURSES_EXPORT(int) _nc_to_char(wint_t);\nextern NCURSES_EXPORT(wint_t) _nc_to_widechar(int);\n#endif\n\n \ntypedef struct {\n\tshort\tnte_name;\t \n\tint\tnte_type;\t \n\tshort\tnte_index;\t \n\tshort\tnte_link;\t \n} name_table_data;\n\ntypedef struct\n{\n\tshort\tfrom;\n\tshort\tto;\n\tshort\tsource;\n} alias_table_data;\n\n \ntypedef struct {\n\tshort\tute_name;\t \n\tunsigned ute_type;\t \n\tunsigned ute_argc;\t \n\tunsigned ute_args;\t \n\tshort\tute_index;\t \n\tshort\tute_link;\t \n} user_table_data;\n\n \n#if USE_XMC_SUPPORT\nextern NCURSES_EXPORT(void) _nc_do_xmc_glitch (attr_t);\n#endif\n\n \n#if defined(TRACE) || defined(SCROLLDEBUG) || defined(HASHDEBUG)\nextern NCURSES_EXPORT(void) _nc_linedump (void);\n#endif\n\n \nextern NCURSES_EXPORT(void) _nc_init_acs (void);  \nextern NCURSES_EXPORT(int)  _nc_msec_cost (const char *const, int);   \n\n \n#if USE_WIDEC_SUPPORT\nNCURSES_EXPORT(int) _nc_build_wch(WINDOW *win, ARG_CH_T ch);\n#endif\n\n \n#if USE_WIDEC_SUPPORT && !(defined(USE_TERMLIB) || defined(USE_BUILD_CC))\nextern NCURSES_EXPORT(int) _nc_wchstrlen(const cchar_t *);\n#endif\n\n \nextern NCURSES_EXPORT(int) _nc_init_color(SCREEN *, int, int, int, int);\nextern NCURSES_EXPORT(int) _nc_init_pair(SCREEN *, int, int, int);\nextern NCURSES_EXPORT(int) _nc_pair_content(SCREEN *, int, int *, int *);\nextern NCURSES_EXPORT(bool) _nc_reset_colors(void);\nextern NCURSES_EXPORT(void) _nc_reserve_pairs(SCREEN *, int);\nextern NCURSES_EXPORT(void) _nc_change_pair(SCREEN *, int);\n\n#define ReservePairs(sp,want) \\\n\t    if ((sp->_color_pairs == 0) || (want >= sp->_pair_alloc)) \\\n\t\t_nc_reserve_pairs(sp, want)\n\n \nextern NCURSES_EXPORT(int) _nc_wgetch(WINDOW *, int *, int EVENTLIST_2nd(_nc_eventlist *));\n\n \nextern NCURSES_EXPORT(int) _nc_insert_ch(SCREEN *, WINDOW *, chtype);\n\n \n#define INFINITY\t1000000\t \n\nextern NCURSES_EXPORT(int) _nc_mvcur(int yold, int xold, int ynew, int xnew);\n\nextern NCURSES_EXPORT(void) _nc_mvcur_init (void);\nextern NCURSES_EXPORT(void) _nc_mvcur_resume (void);\nextern NCURSES_EXPORT(void) _nc_mvcur_wrap (void);\n\nextern NCURSES_EXPORT(int) _nc_scrolln (int, int, int, int);\n\nextern NCURSES_EXPORT(void) _nc_screen_init (void);\nextern NCURSES_EXPORT(void) _nc_screen_resume (void);\nextern NCURSES_EXPORT(void) _nc_screen_wrap (void);\n\n \nextern NCURSES_EXPORT(bool) _nc_has_mouse (SCREEN *);\n\n \n#define INFINITY\t1000000\t \n#define BAUDBYTE\t9\t \n\n \nextern NCURSES_EXPORT(char *) _nc_get_locale(void);\nextern NCURSES_EXPORT(int)    _nc_unicode_locale(void);\nextern NCURSES_EXPORT(int)    _nc_locale_breaks_acs(TERMINAL *);\nextern NCURSES_EXPORT(int)    _nc_setupterm(const char *, int, int *, int);\nextern NCURSES_EXPORT(void)   _nc_tinfo_cmdch(TERMINAL *, int);\n\n#ifdef USE_PTHREADS\nextern NCURSES_EXPORT(SCREEN *) _nc_find_prescr(void);\nextern NCURSES_EXPORT(void)   _nc_forget_prescr(void);\n#else\n#define _nc_find_prescr()     _nc_prescreen.allocated\n#define _nc_forget_prescr()   _nc_prescreen.allocated = 0\n#endif\n\n \nextern NCURSES_EXPORT(int)    _nc_ripoffline(int, int(*)(WINDOW*, int));\n\n \n#define ExitTerminfo(code)    exit_terminfo(code)\n\n#define SETUP_FAIL ERR\n\n#define ret_error(rc, fmt, p, q)\tif (errret) {\\\n\t\t\t\t\t    *errret = rc;\\\n\t\t\t\t\t    q;\\\n\t\t\t\t\t    returnCode(SETUP_FAIL);\\\n\t\t\t\t\t} else {\\\n\t\t\t\t\t    fprintf(stderr, fmt, p);\\\n\t\t\t\t\t    q;\\\n\t\t\t\t\t    ExitTerminfo(EXIT_FAILURE);\\\n\t\t\t\t\t}\n\n#define ret_error1(rc, fmt, p, q)\tret_error(rc, \"'%s': \" fmt, p, q)\n\n#define ret_error0(rc, msg)\t\tif (errret) {\\\n\t\t\t\t\t    *errret = rc;\\\n\t\t\t\t\t    returnCode(SETUP_FAIL);\\\n\t\t\t\t\t} else {\\\n\t\t\t\t\t    fprintf(stderr, msg);\\\n\t\t\t\t\t    ExitTerminfo(EXIT_FAILURE);\\\n\t\t\t\t\t}\n\n \n#if USE_SIGWINCH\nextern NCURSES_EXPORT(int) _nc_handle_sigwinch(SCREEN *);\n#else\n#define _nc_handle_sigwinch(a)  \n#endif\n\n \n#if USE_WIDEC_SUPPORT\nextern NCURSES_EXPORT(void) _nc_init_wacs(void);\n#endif\n\ntypedef struct {\n    char *s_head;\t \n    char *s_tail;\t \n    size_t s_size;\t \n    size_t s_init;\t \n} string_desc;\n\n \nextern NCURSES_EXPORT(string_desc *) _nc_str_init (string_desc *, char *, size_t);\nextern NCURSES_EXPORT(string_desc *) _nc_str_null (string_desc *, size_t);\nextern NCURSES_EXPORT(string_desc *) _nc_str_copy (string_desc *, string_desc *);\nextern NCURSES_EXPORT(bool) _nc_safe_strcat (string_desc *, const char *);\nextern NCURSES_EXPORT(bool) _nc_safe_strcpy (string_desc *, const char *);\n\n#if !HAVE_STRSTR\n#define strstr _nc_strstr\nextern NCURSES_EXPORT(char *) _nc_strstr (const char *, const char *);\n#endif\n\n \nextern NCURSES_EXPORT(char *) _nc_printf_string (const char *, va_list);\n\n \nextern NCURSES_EXPORT(int) _nc_add_to_try (TRIES **, const char *, unsigned);\nextern NCURSES_EXPORT(char *) _nc_expand_try (TRIES *, unsigned, int *, size_t);\nextern NCURSES_EXPORT(int) _nc_remove_key (TRIES **, unsigned);\nextern NCURSES_EXPORT(int) _nc_remove_string (TRIES **, const char *);\n\n \nextern NCURSES_EXPORT(SCREEN *) _nc_screen_of (WINDOW *);\nextern NCURSES_EXPORT(TERMINAL*) _nc_get_cur_term (void);\nextern NCURSES_EXPORT(WINDOW *) _nc_makenew (int, int, int, int, int);\nextern NCURSES_EXPORT(char *) _nc_trace_buf (int, size_t);\nextern NCURSES_EXPORT(char *) _nc_trace_bufcat (int, const char *);\nextern NCURSES_EXPORT(char *) _nc_tracechar (SCREEN *, int);\nextern NCURSES_EXPORT(char *) _nc_tracemouse (SCREEN *, MEVENT const *);\nextern NCURSES_EXPORT(char *) _nc_trace_mmask_t (SCREEN *, mmask_t);\nextern NCURSES_EXPORT(int) _nc_access (const char *, int);\nextern NCURSES_EXPORT(int) _nc_baudrate (int);\nextern NCURSES_EXPORT(int) _nc_freewin (WINDOW *);\nextern NCURSES_EXPORT(int) _nc_getenv_num (const char *);\nextern NCURSES_EXPORT(int) _nc_keypad (SCREEN *, int);\nextern NCURSES_EXPORT(int) _nc_ospeed (int);\nextern NCURSES_EXPORT(int) _nc_outch (int);\nextern NCURSES_EXPORT(int) _nc_putchar (int);\nextern NCURSES_EXPORT(int) _nc_putp(const char *, const char *);\nextern NCURSES_EXPORT(int) _nc_putp_flush(const char *, const char *);\nextern NCURSES_EXPORT(int) _nc_read_termcap_entry (const char *const, TERMTYPE2 *const);\nextern NCURSES_EXPORT(int) _nc_setup_tinfo(const char *, TERMTYPE2 *);\nextern NCURSES_EXPORT(int) _nc_setupscreen (int, int, FILE *, int, int);\nextern NCURSES_EXPORT(int) _nc_timed_wait (SCREEN *, int, int, int * EVENTLIST_2nd(_nc_eventlist *));\nextern NCURSES_EXPORT(void) _nc_init_termtype (TERMTYPE2 *const);\nextern NCURSES_EXPORT(void) _nc_do_color (int, int, int, NCURSES_OUTC);\nextern NCURSES_EXPORT(void) _nc_flush (void);\nextern NCURSES_EXPORT(void) _nc_free_entry (ENTRY *, TERMTYPE2 *);\nextern NCURSES_EXPORT(void) _nc_freeall (void);\nextern NCURSES_EXPORT(void) _nc_hash_map (void);\nextern NCURSES_EXPORT(void) _nc_init_keytry (SCREEN *);\nextern NCURSES_EXPORT(void) _nc_keep_tic_dir (const char *);\nextern NCURSES_EXPORT(void) _nc_make_oldhash (int i);\nextern NCURSES_EXPORT(void) _nc_scroll_oldhash (int n, int top, int bot);\nextern NCURSES_EXPORT(void) _nc_scroll_optimize (void);\nextern NCURSES_EXPORT(void) _nc_set_buffer (FILE *, int);\nextern NCURSES_EXPORT(void) _nc_setenv_num (const char *, int);\nextern NCURSES_EXPORT(void) _nc_signal_handler (int);\nextern NCURSES_EXPORT(void) _nc_synchook (WINDOW *);\nextern NCURSES_EXPORT(void) _nc_trace_tries (TRIES *);\n\n#if NCURSES_EXT_NUMBERS\nextern NCURSES_EXPORT(const TERMTYPE2 *) _nc_fallback2 (const char *);\n#else\n#define _nc_fallback2(tp) _nc_fallback(tp)\n#endif\n\n#if NCURSES_EXT_NUMBERS\nextern NCURSES_EXPORT(void) _nc_copy_termtype2 (TERMTYPE2 *, const TERMTYPE2 *);\nextern NCURSES_EXPORT(void) _nc_export_termtype2(TERMTYPE *, const TERMTYPE2 *);\n#else\n#define _nc_copy_termtype2(dst,src) _nc_copy_termtype((dst),(src))\n#define _nc_export_termtype2(dst,src)  \n#define _nc_free_termtype2(t) _nc_free_termtype(t)\n \n#define _nc_read_entry2 _nc_read_entry\n#endif\n\n#if NO_LEAKS\nextern NCURSES_EXPORT(void) _nc_alloc_entry_leaks(void);\nextern NCURSES_EXPORT(void) _nc_captoinfo_leaks(void);\nextern NCURSES_EXPORT(void) _nc_codes_leaks(void);\nextern NCURSES_EXPORT(void) _nc_comp_captab_leaks(void);\nextern NCURSES_EXPORT(void) _nc_comp_error_leaks(void);\nextern NCURSES_EXPORT(void) _nc_comp_scan_leaks(void);\nextern NCURSES_EXPORT(void) _nc_comp_userdefs_leaks(void);\nextern NCURSES_EXPORT(void) _nc_db_iterator_leaks(void);\nextern NCURSES_EXPORT(void) _nc_keyname_leaks(void);\nextern NCURSES_EXPORT(void) _nc_names_leaks(void);\nextern NCURSES_EXPORT(void) _nc_tgetent_leak(TERMINAL *);\nextern NCURSES_EXPORT(void) _nc_tgetent_leaks(void);\n#endif\n\n#if !(defined(USE_TERMLIB) || defined(USE_BUILD_CC))\nextern NCURSES_EXPORT(NCURSES_CH_T) _nc_render (WINDOW *, NCURSES_CH_T);\nextern NCURSES_EXPORT(int) _nc_waddch_nosync (WINDOW *, const NCURSES_CH_T);\nextern NCURSES_EXPORT(void) _nc_scroll_window (WINDOW *, int const, int const, int const, NCURSES_CH_T);\n#endif\n\n#if USE_WIDEC_SUPPORT\nextern NCURSES_EXPORT(int) _nc_insert_wch(WINDOW *, const cchar_t *);\n#endif\n\n#if USE_WIDEC_SUPPORT && !(defined(USE_TERMLIB) || defined(USE_BUILD_CC))\nextern NCURSES_EXPORT(size_t) _nc_wcrtomb (char *, wchar_t, mbstate_t *);\n#endif\n\n#if USE_SIZECHANGE\nextern NCURSES_EXPORT(void) _nc_update_screensize (SCREEN *);\n#endif\n\n#if HAVE_RESIZETERM\nextern NCURSES_EXPORT(void) _nc_resize_margins (WINDOW *);\n#else\n#define _nc_resize_margins(wp)  \n#endif\n\n#ifdef NCURSES_WGETCH_EVENTS\nextern NCURSES_EXPORT(int) _nc_eventlist_timeout(_nc_eventlist *);\n#else\n#define wgetch_events(win, evl) wgetch(win)\n#define wgetnstr_events(win, str, maxlen, evl) wgetnstr(win, str, maxlen)\n#endif\n\n \n#if USE_WIDEC_SUPPORT\n\n#if defined(_NC_WINDOWS) && !defined(_NC_MSC) && !defined(EXP_WIN32_DRIVER)\n \nextern int __MINGW_NOTHROW _nc_wctomb(char *, wchar_t);\n#define wctomb(s,wc) _nc_wctomb(s,wc)\n#define wcrtomb(s,wc,n) _nc_wctomb(s,wc)\n\nextern int __MINGW_NOTHROW _nc_mbtowc(wchar_t *, const char *, size_t);\n#define mbtowc(pwc,s,n) _nc_mbtowc(pwc,s,n)\n\nextern int __MINGW_NOTHROW _nc_mblen(const char *, size_t);\n#define mblen(s,n) _nc_mblen(s, n)\n\n#endif  \n\n#if HAVE_MBTOWC && HAVE_MBLEN\n#define reset_mbytes(state) IGNORE_RC(mblen(NULL, (size_t) 0)), IGNORE_RC(mbtowc(NULL, NULL, (size_t) 0))\n#define count_mbytes(buffer,length,state) mblen(buffer,length)\n#define check_mbytes(wch,buffer,length,state) \\\n\t(int) mbtowc(&(wch), buffer, length)\n#define state_unused\n#elif HAVE_MBRTOWC && HAVE_MBRLEN\n#define reset_mbytes(state) init_mb(state)\n#define count_mbytes(buffer,length,state) mbrlen(buffer,length,&(state))\n#define check_mbytes(wch,buffer,length,state) \\\n\t(int) mbrtowc(&(wch), buffer, length, &(state))\n#else\nmake an error\n#endif\n\n#endif  \n\n \n#if !HAVE_VSSCANF\nextern int vsscanf(const char *str, const char *format, va_list __arg);\n#endif\n\n \nextern NCURSES_EXPORT_VAR(int *) _nc_oldnums;\n\n#define USE_SETBUF_0 0\n\n#define NC_OUTPUT(sp) ((sp != 0 && sp->_ofp != 0) ? sp->_ofp : stdout)\n\n \n#define _nc_alloc_screen_sp() typeCalloc(SCREEN, 1)\n\n#if BROKEN_LINKER\n#define SP _nc_screen()\nextern NCURSES_EXPORT(SCREEN *) _nc_screen (void);\nextern NCURSES_EXPORT(int)      _nc_alloc_screen (void);\nextern NCURSES_EXPORT(void)     _nc_set_screen (SCREEN *);\n#define CURRENT_SCREEN          _nc_screen()\n#else\n \nextern NCURSES_EXPORT_VAR(SCREEN *) SP;\n#define CURRENT_SCREEN SP\n#define _nc_alloc_screen()      ((SP = _nc_alloc_screen_sp()) != 0)\n#define _nc_set_screen(sp)      SP = sp\n#endif\n\n#if NCURSES_SP_FUNCS\n#define CURRENT_SCREEN_PRE      (IsPreScreen(CURRENT_SCREEN) ? CURRENT_SCREEN : new_prescr())\n#else\n#define CURRENT_SCREEN_PRE      CURRENT_SCREEN\n#endif\n\n \n#define screen_lines(sp)        (sp)->_lines\n#define screen_columns(sp)      (sp)->_columns\n\nextern NCURSES_EXPORT(int) _nc_slk_initialize (WINDOW *, int);\nextern NCURSES_EXPORT(int) _nc_format_slks (NCURSES_SP_DCLx int _c);\n\n \n#define MAX_SKEY_OLD\t   8\t \n#define MAX_SKEY_LEN_OLD   8\t \n#define MAX_SKEY_PC       12     \n#define MAX_SKEY_LEN_PC    5\n\n \n#define SLK_STDFMT(fmt) (fmt < 3)\n \n#define SLK_LINES(fmt)  (SLK_STDFMT(fmt) ? 1 : ((fmt) - 2))\n\n#define MAX_SKEY(fmt)     (SLK_STDFMT(fmt)? MAX_SKEY_OLD : MAX_SKEY_PC)\n#define MAX_SKEY_LEN(fmt) (SLK_STDFMT(fmt)? MAX_SKEY_LEN_OLD : MAX_SKEY_LEN_PC)\n\n \n#define MSG_NO_MEMORY \"Out of memory\"\n#define MSG_NO_INPUTS \"Premature EOF\"\n\nextern NCURSES_EXPORT(int) _nc_set_tty_mode(TTY *);\nextern NCURSES_EXPORT(int) _nc_get_tty_mode(TTY *);\n\n \n#define TW_NONE    0\n#define TW_INPUT   1\n#define TW_MOUSE   2\n#define TW_ANY     (TW_INPUT | TW_MOUSE)\n#define TW_EVENT   4\n\n#define SetSafeOutcWrapper(outc)\t    \\\n    SCREEN* sp = CURRENT_SCREEN;            \\\n    struct screen outc_wrapper;\t\t    \\\n    if (sp==0) {                            \\\n\tsp = &outc_wrapper;                 \\\n\tmemset(sp,0,sizeof(struct screen)); \\\n\tsp->_outch = _nc_outc_wrapper;      \\\n    }\\\n    sp->jump = outc\n\n#ifdef USE_TERM_DRIVER\n\ntypedef struct _termInfo\n{\n    bool caninit;\n\n    bool hascolor;\n    bool initcolor;\n    bool canchange;\n\n    int  tabsize;\n\n    int  maxcolors;\n    int  maxpairs;\n    int  nocolorvideo;\n\n    int  numbuttons;\n    int  numlabels;\n    int  labelwidth;\n    int  labelheight;\n\n    const color_t* defaultPalette;\n} TerminalInfo;\n\ntypedef struct term_driver {\n    bool   isTerminfo;\n    const char* (*td_name)(struct DriverTCB*);\n    bool   (*td_CanHandle)(struct DriverTCB*, const char*, int*);\n    void   (*td_init)(struct DriverTCB*);\n    void   (*td_release)(struct DriverTCB*);\n    int    (*td_size)(struct DriverTCB*, int* Line, int *Cols);\n    int    (*td_sgmode)(struct DriverTCB*, int setFlag, TTY*);\n    chtype (*td_conattr)(struct DriverTCB*);\n    int    (*td_hwcur)(struct DriverTCB*, int yold, int xold, int y, int x);\n    int    (*td_mode)(struct DriverTCB*, int progFlag, int defFlag);\n    bool   (*td_rescol)(struct DriverTCB*);\n    bool   (*td_rescolors)(struct DriverTCB*);\n    void   (*td_color)(struct DriverTCB*, int fore, int color, int(*)(SCREEN*, int));\n    int    (*td_doBeepOrFlash)(struct DriverTCB*, int);\n    void   (*td_initpair)(struct DriverTCB*, int, int, int);\n    void   (*td_initcolor)(struct DriverTCB*, int, int, int, int);\n    void   (*td_docolor)(struct DriverTCB*, int, int, int, int(*)(SCREEN*, int));\n    void   (*td_initmouse)(struct DriverTCB*);\n    int    (*td_testmouse)(struct DriverTCB*, int EVENTLIST_2nd(_nc_eventlist*));\n    void   (*td_setfilter)(struct DriverTCB*);\n    void   (*td_hwlabel)(struct DriverTCB*, int, char*);\n    void   (*td_hwlabelOnOff)(struct DriverTCB*, int);\n    int    (*td_update)(struct DriverTCB*);\n    int    (*td_defaultcolors)(struct DriverTCB*, int, int);\n    int    (*td_print)(struct DriverTCB*, char*, int);\n    int    (*td_getsize)(struct DriverTCB*, int*, int*);\n    int    (*td_setsize)(struct DriverTCB*, int, int);\n    void   (*td_initacs)(struct DriverTCB*, chtype*, chtype*);\n    void   (*td_scinit)(SCREEN *);\n    void   (*td_scexit)(SCREEN *);\n    int    (*td_twait)(struct DriverTCB*, int, int, int* EVENTLIST_2nd(_nc_eventlist*));\n    int    (*td_read)(struct DriverTCB*, int*);\n    int    (*td_nap)(struct DriverTCB*, int);\n    int    (*td_kpad)(struct DriverTCB*, int);\n    int    (*td_kyOk)(struct DriverTCB*, int, int);\n    bool   (*td_kyExist)(struct DriverTCB*, int);\n    int    (*td_cursorSet)(struct DriverTCB*, int);\n} TERM_DRIVER;\n\ntypedef struct DriverTCB\n{\n    TERMINAL      term;    \n    TERM_DRIVER*  drv;     \n    SCREEN*       csp;     \n    TerminalInfo  info;    \n    void*         prop;    \n    long          magic;\n} TERMINAL_CONTROL_BLOCK;\n\n#define NCDRV_MAGIC(id) (0x47110000 | (id&0xffff))\n#define NCDRV_TINFO      0x01\n#define NCDRV_WINCONSOLE 0x02\n\n#define TCBOf(sp)    ((TERMINAL_CONTROL_BLOCK*)(TerminalOf(sp)))\n#define InfoOf(sp)   TCBOf(sp)->info\n#define CallDriver(sp,method)                        TCBOf(sp)->drv->method(TCBOf(sp))\n#define CallDriver_1(sp,method,arg1)                 TCBOf(sp)->drv->method(TCBOf(sp),arg1)\n#define CallDriver_2(sp,method,arg1,arg2)            TCBOf(sp)->drv->method(TCBOf(sp),arg1,arg2)\n#define CallDriver_3(sp,method,arg1,arg2,arg3)       TCBOf(sp)->drv->method(TCBOf(sp),arg1,arg2,arg3)\n#define CallDriver_4(sp,method,arg1,arg2,arg3,arg4)  TCBOf(sp)->drv->method(TCBOf(sp),arg1,arg2,arg3,arg4)\n\nextern NCURSES_EXPORT_VAR(const color_t*) _nc_cga_palette;\nextern NCURSES_EXPORT_VAR(const color_t*) _nc_hls_palette;\n\nextern NCURSES_EXPORT(int)      _nc_get_driver(TERMINAL_CONTROL_BLOCK*, const char*, int*);\nextern NCURSES_EXPORT(void)     _nc_get_screensize_ex(SCREEN *, TERMINAL *, int *, int *);\n#endif  \n\n \n#ifdef USE_TERM_DRIVER\n#define TINFO_HAS_KEY           _nc_tinfo_has_key\n#define TINFO_DOUPDATE          _nc_tinfo_doupdate\n#define TINFO_MVCUR             _nc_tinfo_mvcur\nextern NCURSES_EXPORT(int)      TINFO_HAS_KEY(SCREEN*, int);\nextern NCURSES_EXPORT(int)      TINFO_DOUPDATE(SCREEN *);\nextern NCURSES_EXPORT(int)      TINFO_MVCUR(SCREEN*, int, int, int, int);\n#else\n#define TINFO_HAS_KEY           NCURSES_SP_NAME(has_key)\n#define TINFO_DOUPDATE          NCURSES_SP_NAME(doupdate)\n#define TINFO_MVCUR             NCURSES_SP_NAME(_nc_mvcur)\n#endif\n\n#if defined(EXP_WIN32_DRIVER)\n#include <nc_win32.h>\n#endif\n\n \n#ifdef USE_TERM_DRIVER\nextern NCURSES_EXPORT(void)   _nc_get_screensize(SCREEN *, TERMINAL *, int *, int *);\nextern NCURSES_EXPORT(int)    _nc_setupterm_ex(TERMINAL **, const char *, int , int *, int);\n#define TINFO_GET_SIZE(sp, tp, lp, cp) \\\n\t_nc_get_screensize(sp, tp, lp, cp)\n#define TINFO_SET_CURTERM(sp, tp) \\\n\tNCURSES_SP_NAME(set_curterm)(sp, tp)\n#define TINFO_SETUP_TERM(tpp, name, fd, err, reuse) \\\n\t_nc_setupterm_ex(tpp, name, fd, err, reuse)\n#else  \nextern NCURSES_EXPORT(void)   _nc_get_screensize(SCREEN *, int *, int *);\n#define TINFO_GET_SIZE(sp, tp, lp, cp) \\\n\t_nc_get_screensize(sp, lp, cp)\n#define TINFO_SET_CURTERM(sp, tp) \\\n\tset_curterm(tp)\n#define TINFO_SETUP_TERM(tpp, name, fd, err, reuse) \\\n\t_nc_setupterm(name, fd, err, reuse)\n#endif  \n\n#ifdef EXP_WIN32_DRIVER\nextern NCURSES_EXPORT_VAR(TERM_DRIVER) _nc_TINFO_DRIVER;\n#else\n#ifdef USE_TERM_DRIVER\n#if defined(USE_WIN32CON_DRIVER)\n#include <nc_mingw.h>\nextern NCURSES_EXPORT_VAR(TERM_DRIVER) _nc_WIN_DRIVER;\nextern NCURSES_EXPORT(int)  _nc_mingw_isatty(int fd);\nextern NCURSES_EXPORT(int)  _nc_mingw_isconsole(int fd);\nextern NCURSES_EXPORT(int) _nc_mingw_console_read(\n    SCREEN *sp,\n    HANDLE  fd,\n    int *buf);\nextern NCURSES_EXPORT(int) _nc_mingw_testmouse(\n    SCREEN * sp,\n    HANDLE fd,\n    int delay EVENTLIST_2nd(_nc_eventlist*));\n#else\n#endif\nextern NCURSES_EXPORT_VAR(TERM_DRIVER) _nc_TINFO_DRIVER;\n#endif  \n#endif  \n\n#if defined(USE_TERM_DRIVER) && defined(EXP_WIN32_DRIVER)\n#define NC_ISATTY(fd) (0 != _nc_console_isatty(fd))\n#elif defined(USE_TERM_DRIVER) && defined(USE_WIN32CON_DRIVER)\n#define NC_ISATTY(fd) _nc_mingw_isatty(fd)\n#else\n#define NC_ISATTY(fd) isatty(fd)\n#endif\n\n#ifdef USE_TERM_DRIVER\n#  define IsTermInfo(sp)       ((TCBOf(sp) != 0) && ((TCBOf(sp)->drv->isTerminfo)))\n#  define HasTInfoTerminal(sp) ((0 != TerminalOf(sp)) && IsTermInfo(sp))\n#  if defined(EXP_WIN32_DRIVER)\n#    define IsTermInfoOnConsole(sp) (IsTermInfo(sp) && _nc_console_test(TerminalOf(sp)->Filedes))\n#  elif defined(USE_WIN32CON_DRIVER)\n#    define IsTermInfoOnConsole(sp) (IsTermInfo(sp) && _nc_mingw_isconsole(TerminalOf(sp)->Filedes))\n#  else\n#    define IsTermInfoOnConsole(sp) FALSE\n#  endif\n#else\n#  define IsTermInfo(sp)       TRUE\n#  define HasTInfoTerminal(sp) (0 != TerminalOf(sp))\n#  if defined(EXP_WIN32_DRIVER)\n#    define IsTermInfoOnConsole(sp) _nc_console_test(TerminalOf(sp)->Filedes)\n#  else\n#    define IsTermInfoOnConsole(sp) FALSE\n#  endif\n#endif\n\n#define IsValidTIScreen(sp)  (HasTInfoTerminal(sp))\n\n \n#if NCURSES_SP_FUNCS\nextern NCURSES_EXPORT(WINDOW *) _nc_curscr_of(SCREEN*);\nextern NCURSES_EXPORT(WINDOW *) _nc_newscr_of(SCREEN*);\nextern NCURSES_EXPORT(WINDOW *) _nc_stdscr_of(SCREEN*);\nextern NCURSES_EXPORT(int)      _nc_outc_wrapper(SCREEN*,int);\n\n#if USE_REENTRANT\nextern NCURSES_EXPORT(int)       NCURSES_SP_NAME(_nc_TABSIZE)(SCREEN*);\nextern NCURSES_EXPORT(char *)    NCURSES_SP_NAME(longname)(SCREEN*);\n#endif\n\n#if NCURSES_EXT_FUNCS\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_set_tabsize)(SCREEN*, int);\n#endif\n\n \nextern NCURSES_EXPORT(TERMINAL*) NCURSES_SP_NAME(_nc_get_cur_term) (SCREEN *sp);\nextern NCURSES_EXPORT(WINDOW *) NCURSES_SP_NAME(_nc_makenew) (SCREEN*, int, int, int, int, int);\nextern NCURSES_EXPORT(bool)     NCURSES_SP_NAME(_nc_reset_colors)(SCREEN*);\nextern NCURSES_EXPORT(char *)   NCURSES_SP_NAME(_nc_printf_string)(SCREEN*, const char *, va_list);\nextern NCURSES_EXPORT(chtype)   NCURSES_SP_NAME(_nc_acs_char)(SCREEN*,int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_get_tty_mode)(SCREEN*,TTY*);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_mcprint)(SCREEN*,char*, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_msec_cost)(SCREEN*, const char *, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_mvcur)(SCREEN*, int, int, int, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_outch)(SCREEN*, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_putchar)(SCREEN*, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_putp)(SCREEN*, const char *, const char*);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_putp_flush)(SCREEN*, const char *, const char *);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_ripoffline)(SCREEN*, int, int (*)(WINDOW *,int));\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_scrolln)(SCREEN*, int, int, int, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_set_tty_mode)(SCREEN*, TTY*);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_setupscreen)(SCREEN**, int, int, FILE *, int, int);\nextern NCURSES_EXPORT(int)      NCURSES_SP_NAME(_nc_tgetent)(SCREEN*,char*,const char *);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_do_color)(SCREEN*, int, int, int, NCURSES_SP_OUTC);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_do_xmc_glitch)(SCREEN*, attr_t);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_flush)(SCREEN*);\nextern GCC_NORETURN NCURSES_EXPORT(void) NCURSES_SP_NAME(_nc_free_and_exit)(SCREEN*, int);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_freeall)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_hash_map)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_init_acs)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_make_oldhash)(SCREEN*, int i);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_mvcur_init)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_mvcur_resume)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_mvcur_wrap)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_screen_init)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_screen_resume)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_screen_wrap)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_scroll_oldhash)(SCREEN*, int n, int top, int bot);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_scroll_optimize)(SCREEN*);\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_set_buffer)(SCREEN*, FILE *, int);\n\nextern NCURSES_EXPORT(void)     _nc_cookie_init(SCREEN *sp);\n\n#if defined(TRACE) || defined(SCROLLDEBUG) || defined(HASHDEBUG)\nextern NCURSES_EXPORT(void)     NCURSES_SP_NAME(_nc_linedump)(SCREEN*);\n#endif\n\n#if USE_WIDEC_SUPPORT\nextern NCURSES_EXPORT(wchar_t *) NCURSES_SP_NAME(_nc_wunctrl)(SCREEN*, cchar_t *);\n#endif\n\n#endif  \n\n#if NCURSES_SP_FUNCS\n\n#define safe_keyname NCURSES_SP_NAME(keyname)\n#define safe_unctrl  NCURSES_SP_NAME(unctrl)\n#define safe_ungetch NCURSES_SP_NAME(ungetch)\n\n#else\n\n#define safe_keyname _nc_keyname\n#define safe_unctrl  _nc_unctrl\n#define safe_ungetch _nc_ungetch\n\nextern NCURSES_EXPORT(NCURSES_CONST char *) _nc_keyname (SCREEN *, int);\nextern NCURSES_EXPORT(int) _nc_ungetch (SCREEN *, int);\nextern NCURSES_EXPORT(NCURSES_CONST char *) _nc_unctrl (SCREEN *, chtype);\n\n#endif\n\n#ifdef EXP_XTERM_1005\nNCURSES_EXPORT(int) _nc_conv_to_utf8(unsigned char *, unsigned, unsigned);\nNCURSES_EXPORT(int) _nc_conv_to_utf32(unsigned *, const char *, unsigned);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}