{
  "module_name": "lib_set_term.c",
  "hash_id": "421b6b767d28271b907a1f3e3149ecee5d87e045a2f9ba8fd65b837c9c064056",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_set_term.c",
  "human_readable_source": " \n\n \n\n \n\n#define NEW_PAIR_INTERNAL 1\n\n#include <curses.priv.h>\n#include <tic.h>\n#include <new_pair.h>\n\n#if USE_GPM_SUPPORT\n#ifdef HAVE_LIBDL\n \n#include <dlfcn.h>\n#endif\n#endif\n\n#undef CUR\n#define CUR SP_TERMTYPE\n\nMODULE_ID(\"$Id: lib_set_term.c,v 1.184 2022/12/10 21:34:12 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define MaxColors      InfoOf(sp).maxcolors\n#define NumLabels      InfoOf(sp).numlabels\n#else\n#define MaxColors      max_colors\n#define NumLabels      num_labels\n#endif\n\nNCURSES_EXPORT(SCREEN *)\nset_term(SCREEN *screenp)\n{\n    SCREEN *oldSP;\n    SCREEN *newSP;\n\n    T((T_CALLED(\"set_term(%p)\"), (void *) screenp));\n\n    _nc_lock_global(curses);\n\n    oldSP = CURRENT_SCREEN;\n    _nc_set_screen(screenp);\n    newSP = screenp;\n\n    if (newSP != 0) {\n\tTINFO_SET_CURTERM(newSP, newSP->_term);\n#if !USE_REENTRANT\n\tcurscr = CurScreen(newSP);\n\tnewscr = NewScreen(newSP);\n\tstdscr = StdScreen(newSP);\n\tCOLORS = newSP->_color_count;\n\tCOLOR_PAIRS = newSP->_pair_count;\n#endif\n    } else {\n\tTINFO_SET_CURTERM(oldSP, 0);\n#if !USE_REENTRANT\n\tcurscr = 0;\n\tnewscr = 0;\n\tstdscr = 0;\n\tCOLORS = 0;\n\tCOLOR_PAIRS = 0;\n#endif\n    }\n\n    _nc_unlock_global(curses);\n\n    T((T_RETURN(\"%p\"), (void *) oldSP));\n    return (oldSP);\n}\n\nstatic void\n_nc_free_keytry(TRIES * kt)\n{\n    if (kt != 0) {\n\t_nc_free_keytry(kt->child);\n\t_nc_free_keytry(kt->sibling);\n\tfree(kt);\n    }\n}\n\nstatic bool\ndelink_screen(SCREEN *sp)\n{\n    SCREEN *last = 0;\n    SCREEN *temp;\n    bool result = FALSE;\n\n    for (each_screen(temp)) {\n\tif (temp == sp) {\n\t    if (last)\n\t\tlast->_next_screen = sp->_next_screen;\n\t    else\n\t\t_nc_screen_chain = sp->_next_screen;\n\t    result = TRUE;\n\t    break;\n\t}\n\tlast = temp;\n    }\n    return result;\n}\n\n \nNCURSES_EXPORT(void)\ndelscreen(SCREEN *sp)\n{\n\n    T((T_CALLED(\"delscreen(%p)\"), (void *) sp));\n\n    _nc_lock_global(curses);\n    if (delink_screen(sp)) {\n\tWINDOWLIST *wl;\n\tbool is_current = (sp == CURRENT_SCREEN);\n\n#ifdef USE_SP_RIPOFF\n\tif (safe_ripoff_sp && safe_ripoff_sp != safe_ripoff_stack) {\n\t    ripoff_t *rop;\n\t    for (rop = safe_ripoff_stack;\n\t\t rop != safe_ripoff_sp && (rop - safe_ripoff_stack) < N_RIPS;\n\t\t rop++) {\n\t\tif (rop->win) {\n\t\t    (void) delwin(rop->win);\n\t\t    rop->win = 0;\n\t\t}\n\t    }\n\t}\n#endif\n\n\t \n      rescan:\n\tfor (each_window(sp, wl)) {\n\t    if (_nc_freewin(&(wl->win)) == OK) {\n\t\tgoto rescan;\n\t    }\n\t}\n\n\tif (sp->_slk != 0) {\n\n\t    if (sp->_slk->ent != 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < sp->_slk->labcnt; ++i) {\n\t\t    FreeIfNeeded(sp->_slk->ent[i].ent_text);\n\t\t    FreeIfNeeded(sp->_slk->ent[i].form_text);\n\t\t}\n\t\tfree(sp->_slk->ent);\n\t    }\n\t    free(sp->_slk);\n\t    sp->_slk = 0;\n\t}\n\n\t_nc_free_keytry(sp->_keytry);\n\tsp->_keytry = 0;\n\n\t_nc_free_keytry(sp->_key_ok);\n\tsp->_key_ok = 0;\n\n\tFreeIfNeeded(sp->_current_attr);\n\n\t_nc_free_ordered_pairs(sp);\n\tFreeIfNeeded(sp->_color_table);\n\tFreeIfNeeded(sp->_color_pairs);\n\n\tFreeIfNeeded(sp->_oldnum_list);\n\tFreeIfNeeded(sp->oldhash);\n\tFreeIfNeeded(sp->newhash);\n\tFreeIfNeeded(sp->hashtab);\n\n\tFreeIfNeeded(sp->_acs_map);\n\tFreeIfNeeded(sp->_screen_acs_map);\n\n\tNCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n\tNCURSES_SP_NAME(del_curterm) (NCURSES_SP_ARGx sp->_term);\n\tFreeIfNeeded(sp->out_buffer);\n\tif (_nc_find_prescr() == sp) {\n\t    _nc_forget_prescr();\n\t}\n#if USE_GPM_SUPPORT\n#ifdef HAVE_LIBDL\n\tif (sp->_dlopen_gpm != 0) {\n\t    dlclose(sp->_dlopen_gpm);\n\t    sp->_dlopen_gpm = 0;\n\t}\n#endif\n#endif  \n\tfree(sp);\n\n\t \n\tif (is_current) {\n#if !USE_REENTRANT\n\t    curscr = 0;\n\t    newscr = 0;\n\t    stdscr = 0;\n\t    COLORS = 0;\n\t    COLOR_PAIRS = 0;\n#endif\n\t    _nc_set_screen(0);\n#if USE_WIDEC_SUPPORT\n\t    if (SP == 0) {\n\t\tFreeIfNeeded(_nc_wacs);\n\t\t_nc_wacs = 0;\n\t    }\n#endif\n\t} else {\n\t    set_term(CURRENT_SCREEN);\n\t}\n    }\n    _nc_unlock_global(curses);\n\n    returnVoid;\n}\n\nstatic bool\nno_mouse_event(SCREEN *sp GCC_UNUSED)\n{\n    return FALSE;\n}\n\nstatic bool\nno_mouse_inline(SCREEN *sp GCC_UNUSED)\n{\n    return FALSE;\n}\n\nstatic bool\nno_mouse_parse(SCREEN *sp GCC_UNUSED, int code GCC_UNUSED)\n{\n    return TRUE;\n}\n\nstatic void\nno_mouse_resume(SCREEN *sp GCC_UNUSED)\n{\n}\n\nstatic void\nno_mouse_wrap(SCREEN *sp GCC_UNUSED)\n{\n}\n\n#if NCURSES_EXT_FUNCS && USE_COLORFGBG\nstatic const char *\nextract_fgbg(const char *src, int *result)\n{\n    const char *dst = 0;\n    char *tmp = 0;\n    long value = strtol(src, &tmp, 0);\n\n    if ((dst = tmp) == 0) {\n\tdst = src;\n    } else if (value >= 0) {\n\t*result = (int) value;\n    }\n    while (*dst != 0 && *dst != ';')\n\tdst++;\n    if (*dst == ';')\n\tdst++;\n    return dst;\n}\n#endif\n\n#define ReturnScreenError() do { _nc_set_screen(0); \\\n                            returnCode(ERR); } while (0)\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_setupscreen) (\n#if NCURSES_SP_FUNCS\n\t\t\t\t     SCREEN **spp,\n#endif\n\t\t\t\t     int slines,\n\t\t\t\t     int scolumns,\n\t\t\t\t     FILE *output,\n\t\t\t\t     int filtered,\n\t\t\t\t     int slk_format)\n{\n#ifndef USE_TERM_DRIVER\n    static const TTY null_TTY;\t \n#endif\n    char *env;\n    int bottom_stolen = 0;\n    SCREEN *sp;\n#ifndef USE_TERM_DRIVER\n    bool support_cookies = USE_XMC_SUPPORT;\n#endif\n\n    T((T_CALLED(\"_nc_setupscreen(%d, %d, %p, %d, %d)\"),\n       slines, scolumns, (void *) output, filtered, slk_format));\n\n    assert(CURRENT_SCREEN == 0);\t \n\n#if NCURSES_SP_FUNCS\n    assert(spp != 0);\n    sp = *spp;\n\n    if (!sp) {\n\tsp = _nc_alloc_screen_sp();\n\tT((\"_nc_alloc_screen_sp %p\", (void *) sp));\n\t*spp = sp;\n    }\n    if (sp == NULL) {\n\tReturnScreenError();\n    }\n    if ((sp->_acs_map = typeCalloc(chtype, ACS_LEN)) == NULL) {\n\tReturnScreenError();\n    }\n    if ((sp->_screen_acs_map = typeCalloc(bool, ACS_LEN)) == NULL) {\n\tfree(sp->_acs_map);\n\tReturnScreenError();\n    }\n\n    T((\"created SP %p\", (void *) sp));\n    sp->_next_screen = _nc_screen_chain;\n    _nc_screen_chain = sp;\n\n    if ((sp->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == 0) {\n\tReturnScreenError();\n    }\n#else\n    if (!_nc_alloc_screen()\n\t|| ((SP->_acs_map = typeCalloc(chtype, ACS_LEN)) == 0)\n\t|| ((SP->_screen_acs_map = typeCalloc(bool, ACS_LEN)) == 0)) {\n\treturnCode(ERR);\n    }\n\n    T((\"created SP %p\", (void *) SP));\n\n    sp = SP;\t\t\t \n    sp->_next_screen = _nc_screen_chain;\n    _nc_screen_chain = sp;\n\n    if ((sp->_current_attr = typeCalloc(NCURSES_CH_T, 1)) == 0) {\n\treturnCode(ERR);\n    }\n#endif\n\n     \n    _nc_set_screen(sp);\n    sp->_term = cur_term;\n#ifdef USE_TERM_DRIVER\n    TCBOf(sp)->csp = sp;\n    _nc_get_screensize(sp, sp->_term, &slines, &scolumns);\n#else\n    _nc_get_screensize(sp, &slines, &scolumns);\n#endif\n    SET_LINES(slines);\n    SET_COLS(scolumns);\n\n    T((T_CREATE(\"screen %s %dx%d\"),\n       NCURSES_SP_NAME(termname) (NCURSES_SP_ARG), slines, scolumns));\n\n    sp->_filtered = filtered;\n\n     \n    if (filtered) {\n\tslines = 1;\n\tSET_LINES(slines);\n#ifdef USE_TERM_DRIVER\n\tCallDriver(sp, td_setfilter);\n#else\n\t \n\tclear_screen     = ABSENT_STRING;\n\tcursor_address   = ABSENT_STRING;\n\tcursor_down      = ABSENT_STRING;\n\tcursor_up        = ABSENT_STRING;\n\tparm_down_cursor = ABSENT_STRING;\n\tparm_up_cursor   = ABSENT_STRING;\n\trow_address      = ABSENT_STRING;\n\tcursor_home      = carriage_return;\n\n\tif (back_color_erase)\n\t    clr_eos = ABSENT_STRING;\n\n#endif\n\tT((\"filter screensize %dx%d\", slines, scolumns));\n    }\n#ifdef __DJGPP__\n    T((\"setting output mode to binary\"));\n    fflush(output);\n    setmode(output, O_BINARY);\n#endif\n#if defined(EXP_WIN32_DRIVER)\n    T((\"setting output mode to binary\"));\n    fflush(output);\n    _setmode(fileno(output), _O_BINARY);\n#endif\n    sp->_lines = (NCURSES_SIZE_T) slines;\n    sp->_lines_avail = (NCURSES_SIZE_T) slines;\n    sp->_columns = (NCURSES_SIZE_T) scolumns;\n\n    fflush(output);\n    sp->_ofd = output ? fileno(output) : -1;\n    sp->_ofp = output;\n#if defined(EXP_WIN32_DRIVER)\n    if (output)\n\t_setmode(fileno(output), _O_BINARY);\n#endif\n    sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));\n    if ((sp->out_buffer = malloc(sp->out_limit)) == 0)\n\tsp->out_limit = 0;\n    sp->out_inuse = 0;\n\n    SP_PRE_INIT(sp);\n    SetNoPadding(sp);\n\n#if NCURSES_EXT_FUNCS\n    sp->_default_color = FALSE;\n    sp->_has_sgr_39_49 = FALSE;\n\n     \n#ifdef USE_ASSUMED_COLOR\n    sp->_default_fg = COLOR_WHITE;\n    sp->_default_bg = COLOR_BLACK;\n#else\n    sp->_default_fg = COLOR_DEFAULT;\n    sp->_default_bg = COLOR_DEFAULT;\n#endif\n\n     \n    if ((env = getenv(\"NCURSES_ASSUMED_COLORS\")) != 0) {\n\tint fg, bg;\n\tchar sep1, sep2;\n\tint count = sscanf(env, \"%d%c%d%c\", &fg, &sep1, &bg, &sep2);\n\tif (count >= 1) {\n\t    sp->_default_fg = ((fg >= 0 && fg < MaxColors) ? fg : COLOR_DEFAULT);\n\t    if (count >= 3) {\n\t\tsp->_default_bg = ((bg >= 0 && bg < MaxColors) ? bg : COLOR_DEFAULT);\n\t    }\n\t    TR(TRACE_CHARPUT | TRACE_MOVE,\n\t       (\"from environment assumed fg=%d, bg=%d\",\n\t\tsp->_default_fg,\n\t\tsp->_default_bg));\n\t}\n    }\n#if USE_COLORFGBG\n     \n    if (getenv(\"COLORFGBG\") != 0) {\n\tconst char *p = getenv(\"COLORFGBG\");\n\tTR(TRACE_CHARPUT | TRACE_MOVE, (\"decoding COLORFGBG %s\", p));\n\tp = extract_fgbg(p, &(sp->_default_fg));\n\tp = extract_fgbg(p, &(sp->_default_bg));\n\tif (*p)\t\t\t \n\t    extract_fgbg(p, &(sp->_default_bg));\n\tTR(TRACE_CHARPUT | TRACE_MOVE, (\"decoded fg=%d, bg=%d\",\n\t\t\t\t\tsp->_default_fg, sp->_default_bg));\n\tif (sp->_default_fg >= MaxColors) {\n\t    if (set_a_foreground != ABSENT_STRING\n\t\t&& !strcmp(set_a_foreground, \"\\033[3%p1%dm\")) {\n\t\tset_a_foreground = strdup(\"\\033[3%?%p1%{8}%>%t9%e%p1%d%;m\");\n\t    } else {\n\t\tsp->_default_fg %= MaxColors;\n\t    }\n\t}\n\tif (sp->_default_bg >= MaxColors) {\n\t    if (set_a_background != ABSENT_STRING\n\t\t&& !strcmp(set_a_background, \"\\033[4%p1%dm\")) {\n\t\tset_a_background = strdup(\"\\033[4%?%p1%{8}%>%t9%e%p1%d%;m\");\n\t    } else {\n\t\tsp->_default_bg %= MaxColors;\n\t    }\n\t}\n    }\n#endif\n#endif  \n\n    sp->_maxclick = DEFAULT_MAXCLICK;\n    sp->_mouse_event = no_mouse_event;\n    sp->_mouse_inline = no_mouse_inline;\n    sp->_mouse_parse = no_mouse_parse;\n    sp->_mouse_resume = no_mouse_resume;\n    sp->_mouse_wrap = no_mouse_wrap;\n    sp->_mouse_fd = -1;\n\n     \n    sp->_ok_attributes = NCURSES_SP_NAME(termattrs) (NCURSES_SP_ARG);\n    if (NCURSES_SP_NAME(has_colors) (NCURSES_SP_ARG)) {\n\tsp->_ok_attributes |= A_COLOR;\n    }\n#ifdef USE_TERM_DRIVER\n    _nc_cookie_init(sp);\n#else\n#if USE_XMC_SUPPORT\n     \n    if (magic_cookie_glitch >= 0) {\n\tif (getenv(\"NCURSES_NO_MAGIC_COOKIE\") != 0) {\n\t    support_cookies = FALSE;\n\t}\n    }\n#endif\n\n    if (!support_cookies && magic_cookie_glitch >= 0) {\n\tT((\"will disable attributes to work w/o magic cookies\"));\n    }\n\n    if (magic_cookie_glitch > 0) {\t \n\n\tsp->_xmc_triggers = sp->_ok_attributes & XMC_CONFLICT;\n#if 0\n\t \n\tif (has_colors()) {\n\t    sp->_xmc_triggers |= A_COLOR;\n\t}\n#endif\n\tsp->_xmc_suppress = sp->_xmc_triggers & (chtype) ~(A_BOLD);\n\n\tT((\"magic cookie attributes %s\", _traceattr(sp->_xmc_suppress)));\n\t \n\tacs_chars = ABSENT_STRING;\n\tena_acs = ABSENT_STRING;\n\tenter_alt_charset_mode = ABSENT_STRING;\n\texit_alt_charset_mode = ABSENT_STRING;\n#if USE_XMC_SUPPORT\n\t \n\tif (support_cookies) {\n\t    clr_eol = ABSENT_STRING;\n\t    clr_eos = ABSENT_STRING;\n\t    set_attributes = ABSENT_STRING;\n\t}\n#endif\n    } else if (magic_cookie_glitch == 0) {\t \n    }\n\n     \n    if (!support_cookies && magic_cookie_glitch >= 0) {\n\tmagic_cookie_glitch = ABSENT_NUMERIC;\n\tset_attributes = ABSENT_STRING;\n\tenter_blink_mode = ABSENT_STRING;\n\tenter_bold_mode = ABSENT_STRING;\n\tenter_dim_mode = ABSENT_STRING;\n\tenter_reverse_mode = ABSENT_STRING;\n\tenter_standout_mode = ABSENT_STRING;\n\tenter_underline_mode = ABSENT_STRING;\n    }\n\n     \n#if !USE_WIDEC_SUPPORT\n    if (_nc_unicode_locale() && _nc_locale_breaks_acs(sp->_term)) {\n\tacs_chars = NULL;\n\tena_acs = NULL;\n\tenter_alt_charset_mode = NULL;\n\texit_alt_charset_mode = NULL;\n\tset_attributes = NULL;\n    }\n#endif\n#endif\n\n    NCURSES_SP_NAME(_nc_init_acs) (NCURSES_SP_ARG);\n#if USE_WIDEC_SUPPORT\n    sp->_screen_unicode = _nc_unicode_locale();\n    if (_nc_wacs == 0) {\n\t_nc_init_wacs();\n    }\n    if (_nc_wacs == 0) {\n\tReturnScreenError();\n    }\n\n    sp->_screen_acs_fix = (sp->_screen_unicode\n\t\t\t   && _nc_locale_breaks_acs(sp->_term));\n#endif\n    env = _nc_get_locale();\n    sp->_legacy_coding = ((env == 0)\n\t\t\t  || !strcmp(env, \"C\")\n\t\t\t  || !strcmp(env, \"POSIX\"));\n    T((\"legacy-coding %d\", sp->_legacy_coding));\n\n    sp->_nc_sp_idcok = TRUE;\n    sp->_nc_sp_idlok = FALSE;\n\n    sp->oldhash = 0;\n    sp->newhash = 0;\n\n    T((\"creating newscr\"));\n    NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,\n\t\t\t\t\t     0, 0);\n    if (NewScreen(sp) == 0) {\n\tReturnScreenError();\n    }\n    T((\"creating curscr\"));\n    CurScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,\n\t\t\t\t\t     0, 0);\n    if (CurScreen(sp) == 0) {\n\tReturnScreenError();\n    }\n#if !USE_REENTRANT\n    newscr = NewScreen(sp);\n    curscr = CurScreen(sp);\n#endif\n#if USE_SIZECHANGE\n    sp->_resize = NCURSES_SP_NAME(resizeterm);\n    sp->_ungetch = safe_ungetch;\n#endif\n\n    NewScreen(sp)->_clear = TRUE;\n    CurScreen(sp)->_clear = FALSE;\n\n     \n#ifndef USE_TERM_DRIVER\n    if (cur_term != 0 &&\n\t!memcmp(&cur_term->Ottyb, &null_TTY, sizeof(TTY)))\n#endif\n    {\n\tNCURSES_SP_NAME(def_shell_mode) (NCURSES_SP_ARG);\n\tNCURSES_SP_NAME(def_prog_mode) (NCURSES_SP_ARG);\n    }\n\n    if (safe_ripoff_sp && safe_ripoff_sp != safe_ripoff_stack) {\n\tripoff_t *rop;\n\n\tfor (rop = safe_ripoff_stack;\n\t     rop != safe_ripoff_sp && (rop - safe_ripoff_stack) < N_RIPS;\n\t     rop++) {\n\n\t     \n\t    if (rop->hook == _nc_slk_initialize) {\n\t\tif (!TerminalOf(sp)) {\n\t\t    continue;\n\t\t}\n\t\tif (!(NumLabels <= 0 || !SLK_STDFMT(slk_format))) {\n\t\t    continue;\n\t\t}\n\t    }\n\t    if (rop->hook) {\n\t\tint count;\n\t\tWINDOW *w;\n\n\t\tcount = (rop->line < 0) ? -rop->line : rop->line;\n\t\tT((\"ripping off %i lines at %s\", count,\n\t\t   ((rop->line < 0)\n\t\t    ? \"bottom\"\n\t\t    : \"top\")));\n\n\t\tw = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx\n\t\t\t\t\t     count, scolumns,\n\t\t\t\t\t     ((rop->line < 0)\n\t\t\t\t\t      ? sp->_lines_avail - count\n\t\t\t\t\t      : 0),\n\t\t\t\t\t     0);\n\t\tif (w) {\n\t\t    rop->win = w;\n\t\t    rop->hook(w, scolumns);\n\t\t} else {\n\t\t    ReturnScreenError();\n\t\t}\n\t\tif (rop->line < 0) {\n\t\t    bottom_stolen += count;\n\t\t} else {\n\t\t    sp->_topstolen = (NCURSES_SIZE_T) (sp->_topstolen + count);\n\t\t}\n\t\tsp->_lines_avail = (NCURSES_SIZE_T) (sp->_lines_avail - count);\n\t    }\n\t}\n\t \n\tsafe_ripoff_sp = safe_ripoff_stack;\n    }\n\n    T((\"creating stdscr\"));\n    (void) bottom_stolen;\n    assert((sp->_lines_avail + sp->_topstolen + bottom_stolen) == slines);\n    if ((StdScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx\n\t\t\t\t\t\t  sp->_lines_avail,\n\t\t\t\t\t\t  scolumns, 0, 0)) == 0) {\n\tReturnScreenError();\n    }\n    SET_LINES(sp->_lines_avail);\n#if !USE_REENTRANT\n    stdscr = StdScreen(sp);\n#endif\n    sp->_prescreen = FALSE;\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_setupscreen(int slines GCC_UNUSED,\n\t\tint scolumns GCC_UNUSED,\n\t\tFILE *output,\n\t\tint filtered,\n\t\tint slk_format)\n{\n    SCREEN *sp = 0;\n    int rc = NCURSES_SP_NAME(_nc_setupscreen) (&sp,\n\t\t\t\t\t       slines,\n\t\t\t\t\t       scolumns,\n\t\t\t\t\t       output,\n\t\t\t\t\t       filtered,\n\t\t\t\t\t       slk_format);\n    if (rc != OK)\n\t_nc_set_screen(0);\n    return rc;\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(_nc_ripoffline) (NCURSES_SP_DCLx\n\t\t\t\t int line,\n\t\t\t\t int (*init) (WINDOW *, int))\n{\n    int code = ERR;\n    TR_FUNC_BFR(1);\n\n    START_TRACE();\n    T((T_CALLED(\"ripoffline(%p,%d,%s)\"),\n       (void *) SP_PARM, line,\n       TR_FUNC_ARG(0, init)));\n\n#if NCURSES_SP_FUNCS\n    if (SP_PARM != 0 && SP_PARM->_prescreen)\n#endif\n    {\n\tif (line == 0) {\n\t    code = OK;\n\t} else {\n\t    if (safe_ripoff_sp == 0) {\n\t\tsafe_ripoff_sp = safe_ripoff_stack;\n\t    }\n\t    if (safe_ripoff_sp < safe_ripoff_stack + N_RIPS) {\n\t\tsafe_ripoff_sp->line = line;\n\t\tsafe_ripoff_sp->hook = init;\n\t\t(safe_ripoff_sp)++;\n\t\tT((\"ripped-off %d:%d chunks\",\n\t\t   (int) (safe_ripoff_sp - safe_ripoff_stack), N_RIPS));\n\t\tcode = OK;\n\t    }\n\t}\n    }\n\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\n_nc_ripoffline(int line, int (*init) (WINDOW *, int))\n{\n    int rc;\n\n    _nc_init_pthreads();\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    rc = NCURSES_SP_NAME(_nc_ripoffline) (CURRENT_SCREEN_PRE, line, init);\n    _nc_unlock_global(prescreen);\n\n    return rc;\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(ripoffline) (NCURSES_SP_DCLx\n\t\t\t     int line,\n\t\t\t     int (*init) (WINDOW *, int))\n{\n    START_TRACE();\n    return NCURSES_SP_NAME(_nc_ripoffline) (NCURSES_SP_ARGx\n\t\t\t\t\t    (line < 0) ? -1 : 1,\n\t\t\t\t\t    init);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nripoffline(int line, int (*init) (WINDOW *, int))\n{\n    int rc;\n\n    _nc_init_pthreads();\n    _nc_lock_global(prescreen);\n    START_TRACE();\n    rc = NCURSES_SP_NAME(ripoffline) (CURRENT_SCREEN_PRE, line, init);\n    _nc_unlock_global(prescreen);\n\n    return rc;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}