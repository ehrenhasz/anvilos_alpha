{
  "module_name": "lib_addstr.c",
  "hash_id": "ace9ec7911ae1cde9f6441b9c586af1ac22117af3a3ddc00d3323d6e851bebbf",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_addstr.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_addstr.c,v 1.58 2022/06/11 20:12:04 tom Exp $\")\n\nNCURSES_EXPORT(int)\nwaddnstr(WINDOW *win, const char *astr, int n)\n{\n    const char *str = astr;\n    int code = ERR;\n\n    T((T_CALLED(\"waddnstr(%p,%s,%d)\"), (void *) win, _nc_visbufn(astr, n), n));\n\n    if (win && (str != 0)) {\n\tTR(TRACE_VIRTPUT | TRACE_ATTRS,\n\t   (\"... current %s\", _traceattr(WINDOW_ATTRS(win))));\n\tcode = OK;\n\n\tTR(TRACE_VIRTPUT, (\"str is not null, length = %d\",\n\t\t\t   ((n > 0) ? n : (int) strlen(str))));\n\tif (n < 0)\n\t    n = INT_MAX;\n\twhile ((*str != '\\0') && (n-- > 0)) {\n\t    NCURSES_CH_T ch;\n\t    TR(TRACE_VIRTPUT, (\"*str = %#o\", UChar(*str)));\n\t    SetChar(ch, UChar(*str++), A_NORMAL);\n\t    if (_nc_waddch_nosync(win, ch) == ERR) {\n\t\tcode = ERR;\n\t\tbreak;\n\t    }\n\t}\n\t_nc_synchook(win);\n    }\n    TR(TRACE_VIRTPUT, (\"waddnstr returns %d\", code));\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nwaddchnstr(WINDOW *win, const chtype *astr, int n)\n{\n    NCURSES_SIZE_T y, x;\n    int code = OK;\n    int i;\n    struct ldat *line;\n\n    T((T_CALLED(\"waddchnstr(%p,%p,%d)\"), (void *) win, (const void *) astr, n));\n\n    if (!win || !astr)\n\treturnCode(ERR);\n\n    y = win->_cury;\n    x = win->_curx;\n    if (n < 0) {\n\tconst chtype *str;\n\tn = 0;\n\tfor (str = (const chtype *) astr; *str != 0; str++)\n\t    n++;\n    }\n    if (n > win->_maxx - x + 1)\n\tn = win->_maxx - x + 1;\n    if (n == 0)\n\treturnCode(code);\n\n    line = &(win->_line[y]);\n    for (i = 0; i < n && ChCharOf(astr[i]) != '\\0'; ++i) {\n\tSetChar2(line->text[i + x], astr[i]);\n    }\n    CHANGED_RANGE(line, x, (NCURSES_SIZE_T) (x + n - 1));\n\n    _nc_synchook(win);\n    returnCode(code);\n}\n\n#if USE_WIDEC_SUPPORT\n\nNCURSES_EXPORT(int)\n_nc_wchstrlen(const cchar_t *s)\n{\n    int result = 0;\n    if (s != 0) {\n\twhile (CharOf(s[result]) != L'\\0') {\n\t    result++;\n\t}\n    }\n    return result;\n}\n\nNCURSES_EXPORT(int)\nwadd_wchnstr(WINDOW *win, const cchar_t *astr, int n)\n{\n    static const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n    NCURSES_SIZE_T y;\n    NCURSES_SIZE_T x;\n    int code = OK;\n    struct ldat *line;\n    int i, j, start, len, end;\n\n    T((T_CALLED(\"wadd_wchnstr(%p,%s,%d)\"),\n       (void *) win,\n       _nc_viscbuf(astr, n),\n       n));\n\n    if (!win)\n\treturnCode(ERR);\n\n    y = win->_cury;\n    x = win->_curx;\n    if (n < 0) {\n\tn = _nc_wchstrlen(astr);\n    }\n    if (n > win->_maxx - x + 1)\n\tn = win->_maxx - x + 1;\n    if (n == 0)\n\treturnCode(code);\n\n    line = &(win->_line[y]);\n    start = x;\n    end = x + n - 1;\n\n     \n    if (x > 0 && isWidecExt(line->text[x])) {\n\tfor (i = 0; i <= x; ++i) {\n\t    if (!isWidecExt(line->text[x - i])) {\n\t\t \n\t\tstart -= i;\n\t\twhile (i > 0) {\n\t\t    line->text[x - i--] = _nc_render(win, blank);\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n\n     \n    for (i = 0; i < n && CharOf(astr[i]) != L'\\0' && x <= win->_maxx; ++i) {\n\tif (isWidecExt(astr[i]))\n\t    continue;\n\n\tlen = _nc_wacs_width(CharOf(astr[i]));\n\n\tif (x + len - 1 <= win->_maxx) {\n\t    line->text[x] = _nc_render(win, astr[i]);\n\t    if (len > 1) {\n\t\tfor (j = 0; j < len; ++j) {\n\t\t    if (j != 0) {\n\t\t\tline->text[x + j] = line->text[x];\n\t\t    }\n\t\t    SetWidecExt(line->text[x + j], j);\n\t\t}\n\t    } else {\n\t\tlen = 1;\n\t    }\n\t    x = (NCURSES_SIZE_T) (x + len);\n\t    end += len - 1;\n\t} else {\n\t    break;\n\t}\n    }\n\n     \n    while (x <= win->_maxx && isWidecExt(line->text[x])) {\n\tline->text[x] = _nc_render(win, blank);\n\t++end;\n\t++x;\n    }\n    CHANGED_RANGE(line, start, end);\n\n    _nc_synchook(win);\n    returnCode(code);\n}\n\nNCURSES_EXPORT(int)\nwaddnwstr(WINDOW *win, const wchar_t *str, int n)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"waddnwstr(%p,%s,%d)\"), (void *) win, _nc_viswbufn(str, n), n));\n\n    if (win && (str != 0)) {\n\tTR(TRACE_VIRTPUT | TRACE_ATTRS,\n\t   (\"... current %s\", _traceattr(WINDOW_ATTRS(win))));\n\tcode = OK;\n\n\tTR(TRACE_VIRTPUT, (\"str is not null, length = %d\",\n\t\t\t   ((n > 0) ? n : (int) wcslen(str))));\n\tif (n < 0)\n\t    n = INT_MAX;\n\twhile ((*str != L('\\0')) && (n-- > 0)) {\n\t    NCURSES_CH_T ch;\n\t    TR(TRACE_VIRTPUT, (\"*str[0] = %#lx\", (unsigned long) *str));\n\t    SetChar(ch, *str++, A_NORMAL);\n\t    if (wadd_wch(win, &ch) == ERR) {\n\t\tcode = ERR;\n\t\tbreak;\n\t    }\n\t}\n\t_nc_synchook(win);\n    }\n    TR(TRACE_VIRTPUT, (\"waddnwstr returns %d\", code));\n    returnCode(code);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}