{
  "module_name": "lib_scroll.c",
  "hash_id": "46c1f4c2ee4808559c761e1a6709dfe7296978a444c73525df6f2ff8f5e455eb",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_scroll.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_scroll.c,v 1.32 2020/02/02 23:34:34 tom Exp $\")\n\nNCURSES_EXPORT(void)\n_nc_scroll_window(WINDOW *win,\n\t\t  int const n,\n\t\t  int const top,\n\t\t  int const bottom,\n\t\t  NCURSES_CH_T blank)\n{\n    int limit;\n    int line;\n    int j;\n    size_t to_copy = (sizeof(NCURSES_CH_T) * (size_t) (win->_maxx + 1));\n\n    TR(TRACE_MOVE, (\"_nc_scroll_window(%p, %d, %ld, %ld)\",\n\t\t    (void *) win, n, (long) top, (long) bottom));\n\n    if (top < 0\n\t|| bottom < top\n\t|| bottom > win->_maxy) {\n\tTR(TRACE_MOVE, (\"nothing to scroll\"));\n\treturn;\n    }\n\n     \n#define BottomLimit(n) ((n) >= 0 && (n) >= top)\n#define TopLimit(n)    ((n) <= win->_maxy && (n) <= bottom)\n\n     \n    if (n < 0) {\n\tlimit = top - n;\n\tfor (line = bottom; line >= limit && BottomLimit(line); line--) {\n\t    TR(TRACE_MOVE, (\"...copying %d to %d\", line + n, line));\n\t    memcpy(win->_line[line].text,\n\t\t   win->_line[line + n].text,\n\t\t   to_copy);\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex =\n\t\t\t\twin->_line[line + n].oldindex);\n\t}\n\tfor (line = top; line < limit && TopLimit(line); line++) {\n\t    TR(TRACE_MOVE, (\"...filling %d\", line));\n\t    for (j = 0; j <= win->_maxx; j++)\n\t\twin->_line[line].text[j] = blank;\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex = _NEWINDEX);\n\t}\n    }\n\n     \n    if (n > 0) {\n\tlimit = bottom - n;\n\tfor (line = top; line <= limit && TopLimit(line); line++) {\n\t    memcpy(win->_line[line].text,\n\t\t   win->_line[line + n].text,\n\t\t   to_copy);\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex =\n\t\t\t\twin->_line[line + n].oldindex);\n\t}\n\tfor (line = bottom; line > limit && BottomLimit(line); line--) {\n\t    for (j = 0; j <= win->_maxx; j++)\n\t\twin->_line[line].text[j] = blank;\n\t    if_USE_SCROLL_HINTS(win->_line[line].oldindex = _NEWINDEX);\n\t}\n    }\n    touchline(win, top, bottom - top + 1);\n\n    if_WIDEC({\n\tif (WINDOW_EXT(win, addch_used) != 0) {\n\t    int next = WINDOW_EXT(win, addch_y) + n;\n\t    if (next < 0 || next > win->_maxy) {\n\t\tTR(TRACE_VIRTPUT,\n\t\t   (\"Alert discarded multibyte on scroll\"));\n\t\tWINDOW_EXT(win, addch_y) = 0;\n\t    } else {\n\t\tTR(TRACE_VIRTPUT, (\"scrolled working position to %d,%d\",\n\t\t\t\t   WINDOW_EXT(win, addch_y),\n\t\t\t\t   WINDOW_EXT(win, addch_x)));\n\t\tWINDOW_EXT(win, addch_y) = next;\n\t    }\n\t}\n    })\n}\n\nNCURSES_EXPORT(int)\nwscrl(WINDOW *win, int n)\n{\n    T((T_CALLED(\"wscrl(%p,%d)\"), (void *) win, n));\n\n    if (!win || !win->_scroll) {\n\tTR(TRACE_MOVE, (\"...scrollok is false\"));\n\treturnCode(ERR);\n    }\n\n    if (n != 0) {\n\t_nc_scroll_window(win, n, win->_regtop, win->_regbottom, win->_nc_bkgd);\n\t_nc_synchook(win);\n    }\n    returnCode(OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}