{
  "module_name": "vsscanf.c",
  "hash_id": "d744e91b82d0d402a2da50f244df77997b2bc0dec42595698641c1b4566cdc89",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/vsscanf.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#if !HAVE_VSSCANF\n\nMODULE_ID(\"$Id: vsscanf.c,v 1.21 2020/02/02 23:34:34 tom Exp $\")\n\n#if !(HAVE_VFSCANF || HAVE__DOSCAN)\n\n#include <ctype.h>\n\n#define L_SQUARE '['\n#define R_SQUARE ']'\n\ntypedef enum {\n    cUnknown\n    ,cError\t\t\t \n    ,cAssigned\n    ,cChar\n    ,cInt\n    ,cFloat\n    ,cDouble\n    ,cPointer\n    ,cLong\n    ,cShort\n    ,cRange\n    ,cString\n} ChunkType;\n\ntypedef enum {\n    oUnknown\n    ,oShort\n    ,oLong\n} OtherType;\n\ntypedef enum {\n    sUnknown\n    ,sPercent\t\t\t \n    ,sNormal\t\t\t \n    ,sLeft\t\t\t \n    ,sRange\t\t\t \n    ,sFinal\t\t\t \n} ScanState;\n\nstatic ChunkType\nfinal_ch(int ch, OtherType other)\n{\n    ChunkType result = cUnknown;\n\n    switch (ch) {\n    case 'c':\n\tif (other == oUnknown)\n\t    result = cChar;\n\telse\n\t    result = cError;\n\tbreak;\n    case 'd':\n    case 'i':\n    case 'X':\n    case 'x':\n\tswitch (other) {\n\tcase oUnknown:\n\t    result = cInt;\n\t    break;\n\tcase oShort:\n\t    result = cShort;\n\t    break;\n\tcase oLong:\n\t    result = cLong;\n\t    break;\n\t}\n\tbreak;\n    case 'E':\n    case 'e':\n    case 'f':\n    case 'g':\n\tswitch (other) {\n\tcase oUnknown:\n\t    result = cFloat;\n\t    break;\n\tcase oShort:\n\t    result = cError;\n\t    break;\n\tcase oLong:\n\t    result = cDouble;\n\t    break;\n\t}\n\tbreak;\n    case 'n':\n\tif (other == oUnknown)\n\t    result = cAssigned;\n\telse\n\t    result = cError;\n\tbreak;\n    case 'p':\n\tif (other == oUnknown)\n\t    result = cPointer;\n\telse\n\t    result = cError;\n\tbreak;\n    case 's':\n\tif (other == oUnknown)\n\t    result = cString;\n\telse\n\t    result = cError;\n\tbreak;\n    }\n    return result;\n}\n\nstatic OtherType\nother_ch(int ch)\n{\n    OtherType result = oUnknown;\n    switch (ch) {\n    case 'h':\n\tresult = oShort;\n\tbreak;\n    case 'l':\n\tresult = oLong;\n\tbreak;\n    }\n    return result;\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nvsscanf(const char *str, const char *format, va_list ap)\n{\n#if HAVE_VFSCANF || HAVE__DOSCAN\n     \n    FILE strbuf;\n\n    strbuf._flag = _IOREAD;\n    strbuf._ptr = strbuf._base = (unsigned char *) str;\n    strbuf._cnt = strlen(str);\n    strbuf._file = _NFILE;\n\n#if HAVE_VFSCANF\n    return (vfscanf(&strbuf, format, ap));\n#else\n    return (_doscan(&strbuf, format, ap));\n#endif\n#else\n    static int can_convert = -1;\n\n    int assigned = 0;\n    int consumed = 0;\n\n    T((T_CALLED(\"vsscanf(%s,%s,...)\"),\n       _nc_visbuf2(1, str),\n       _nc_visbuf2(2, format)));\n\n     \n    if (can_convert < 0) {\n\tint check1;\n\tint check2;\n\tif (sscanf(\"123\", \"%d%n\", &check1, &check2) > 0\n\t    && check1 == 123\n\t    && check2 == 3) {\n\t    can_convert = 1;\n\t} else {\n\t    can_convert = 0;\n\t}\n    }\n\n    if (can_convert) {\n\tsize_t len_fmt = strlen(format) + 32;\n\tchar *my_fmt = malloc(len_fmt);\n\tChunkType chunk, ctest;\n\tOtherType other, otest;\n\tScanState state;\n\tunsigned n;\n\tint eaten;\n\tvoid *pointer;\n\n\tif (my_fmt != 0) {\n\t     \n\t    while (*format != '\\0') {\n\t\t \n\t\tstate = sUnknown;\n\t\tchunk = cUnknown;\n\t\tother = oUnknown;\n\t\tpointer = 0;\n\t\tfor (n = 0; format[n] != 0 && state != sFinal; ++n) {\n\t\t    my_fmt[n] = format[n];\n\t\t    switch (state) {\n\t\t    case sUnknown:\n\t\t\tif (format[n] == '%')\n\t\t\t    state = sPercent;\n\t\t\tbreak;\n\t\t    case sPercent:\n\t\t\tif (format[n] == '%') {\n\t\t\t    state = sUnknown;\n\t\t\t} else if (format[n] == L_SQUARE) {\n\t\t\t    state = sLeft;\n\t\t\t} else {\n\t\t\t    state = sNormal;\n\t\t\t    --n;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case sLeft:\n\t\t\tstate = sRange;\n\t\t\tif (format[n] == '^') {\n\t\t\t    ++n;\n\t\t\t    my_fmt[n] = format[n];\n\t\t\t}\n\t\t\tbreak;\n\t\t    case sRange:\n\t\t\tif (format[n] == R_SQUARE) {\n\t\t\t    state = sFinal;\n\t\t\t    chunk = cRange;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case sNormal:\n\t\t\tif (format[n] == '*') {\n\t\t\t    state = sUnknown;\n\t\t\t} else {\n\t\t\t    if ((ctest = final_ch(format[n], other)) != cUnknown) {\n\t\t\t\tstate = sFinal;\n\t\t\t\tchunk = ctest;\n\t\t\t    } else if ((otest = other_ch(format[n])) != oUnknown) {\n\t\t\t\tother = otest;\n\t\t\t    } else if (isalpha(UChar(format[n]))) {\n\t\t\t\tstate = sFinal;\n\t\t\t\tchunk = cError;\n\t\t\t    }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case sFinal:\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmy_fmt[n] = '\\0';\n\t\tformat += n;\n\n\t\tif (chunk == cUnknown\n\t\t    || chunk == cError) {\n\t\t    if (assigned == 0)\n\t\t\tassigned = EOF;\n\t\t    break;\n\t\t}\n\n\t\t \n\t\tif (chunk != cAssigned) {\n\t\t    _nc_STRCAT(my_fmt, \"%n\", len_fmt);\n\t\t}\n\n\t\tswitch (chunk) {\n\t\tcase cAssigned:\n\t\t    _nc_STRCAT(my_fmt, \"%n\", len_fmt);\n\t\t    pointer = &eaten;\n\t\t    break;\n\t\tcase cInt:\n\t\t    pointer = va_arg(ap, int *);\n\t\t    break;\n\t\tcase cShort:\n\t\t    pointer = va_arg(ap, short *);\n\t\t    break;\n\t\tcase cFloat:\n\t\t    pointer = va_arg(ap, float *);\n\t\t    break;\n\t\tcase cDouble:\n\t\t    pointer = va_arg(ap, double *);\n\t\t    break;\n\t\tcase cLong:\n\t\t    pointer = va_arg(ap, long *);\n\t\t    break;\n\t\tcase cPointer:\n\t\t    pointer = va_arg(ap, void *);\n\t\t    break;\n\t\tcase cChar:\n\t\tcase cRange:\n\t\tcase cString:\n\t\t    pointer = va_arg(ap, char *);\n\t\t    break;\n\t\tcase cError:\n\t\tcase cUnknown:\n\t\t    break;\n\t\t}\n\t\t \n\t\tT((\"...converting chunk #%d type %d(%s,%s)\",\n\t\t   assigned + 1, chunk,\n\t\t   _nc_visbuf2(1, str + consumed),\n\t\t   _nc_visbuf2(2, my_fmt)));\n\t\tif (sscanf(str + consumed, my_fmt, pointer, &eaten) > 0)\n\t\t    consumed += eaten;\n\t\telse\n\t\t    break;\n\t\t++assigned;\n\t    }\n\t    free(my_fmt);\n\t}\n    }\n    returnCode(assigned);\n#endif\n}\n#else\nextern\nNCURSES_EXPORT(void)\n_nc_vsscanf(void);\t\t \nNCURSES_EXPORT(void)\n_nc_vsscanf(void)\n{\n}\t\t\t\t \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}