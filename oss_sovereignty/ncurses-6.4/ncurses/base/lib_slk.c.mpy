{
  "module_name": "lib_slk.c",
  "hash_id": "93c070e7035d84e237e8847f81cf63fcad89b06d58ccbb89e05baa5614a5e706",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_slk.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <ctype.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_slk.c,v 1.50 2022/08/20 18:29:22 tom Exp $\")\n\n#ifdef USE_TERM_DRIVER\n#define NumLabels    InfoOf(SP_PARM).numlabels\n#define NoColorVideo InfoOf(SP_PARM).nocolorvideo\n#define LabelWidth   InfoOf(SP_PARM).labelwidth\n#define LabelHeight  InfoOf(SP_PARM).labelheight\n#else\n#define NumLabels    num_labels\n#define NoColorVideo no_color_video\n#define LabelWidth   label_width\n#define LabelHeight  label_height\n#endif\n\n \nstatic int\nslk_failed(NCURSES_SP_DCL0)\n{\n    if ((0 != SP_PARM) && SP_PARM->_slk) {\n\tFreeIfNeeded(SP_PARM->_slk->ent);\n\tfree(SP_PARM->_slk);\n\tSP_PARM->_slk = (SLK *) 0;\n    }\n    return ERR;\n}\n\nNCURSES_EXPORT(int)\n_nc_format_slks(NCURSES_SP_DCLx int cols)\n{\n    int gap, i, x;\n    int max_length;\n\n    if (!SP_PARM || !SP_PARM->_slk)\n\treturn ERR;\n\n    max_length = SP_PARM->_slk->maxlen;\n    if (SP_PARM->slk_format >= 3) {\t \n\tgap = (cols - 3 * (3 + 4 * max_length)) / 2;\n\n\tif (gap < 1)\n\t    gap = 1;\n\n\tfor (i = x = 0; i < SP_PARM->_slk->maxlab; i++) {\n\t    SP_PARM->_slk->ent[i].ent_x = x;\n\t    x += max_length;\n\t    x += (i == 3 || i == 7) ? gap : 1;\n\t}\n    } else {\n\tif (SP_PARM->slk_format == 2) {\t\t \n\t    gap = cols - (int) (SP_PARM->_slk->maxlab * max_length) - 6;\n\n\t    if (gap < 1)\n\t\tgap = 1;\n\t    for (i = x = 0; i < SP_PARM->_slk->maxlab; i++) {\n\t\tSP_PARM->_slk->ent[i].ent_x = x;\n\t\tx += max_length;\n\t\tx += (i == 3) ? gap : 1;\n\t    }\n\t} else {\n\t    if (SP_PARM->slk_format == 1) {\t \n\t\tgap = (cols - (SP_PARM->_slk->maxlab * max_length) - 5)\n\t\t    / 2;\n\n\t\tif (gap < 1)\n\t\t    gap = 1;\n\t\tfor (i = x = 0; i < SP_PARM->_slk->maxlab; i++) {\n\t\t    SP_PARM->_slk->ent[i].ent_x = x;\n\t\t    x += max_length;\n\t\t    x += (i == 2 || i == 4) ? gap : 1;\n\t\t}\n\t    } else {\n\t\treturn slk_failed(NCURSES_SP_ARG);\n\t    }\n\t}\n    }\n    SP_PARM->_slk->dirty = TRUE;\n\n    return OK;\n}\n\n \nNCURSES_EXPORT(int)\n_nc_slk_initialize(WINDOW *stwin, int cols)\n{\n    int i;\n    int res = OK;\n    size_t max_length;\n    SCREEN *sp;\n    int numlab;\n\n    T((T_CALLED(\"_nc_slk_initialize()\")));\n\n    assert(stwin);\n\n    sp = _nc_screen_of(stwin);\n    if (0 == sp)\n\treturnCode(ERR);\n\n    assert(TerminalOf(SP_PARM));\n\n    numlab = NumLabels;\n\n    if (SP_PARM->_slk) {\t \n\treturnCode(OK);\n    } else if ((SP_PARM->_slk = typeCalloc(SLK, 1)) == 0)\n\treturnCode(ERR);\n\n    if (!SP_PARM->slk_format)\n\tSP_PARM->slk_format = _nc_globals.slk_format;\n\n     \n    if ((NoColorVideo & 1) == 0)\n\tSetAttr(SP_PARM->_slk->attr, A_STANDOUT);\n    else\n\tSetAttr(SP_PARM->_slk->attr, A_REVERSE);\n\n    SP_PARM->_slk->maxlab = (short) ((numlab > 0)\n\t\t\t\t     ? numlab\n\t\t\t\t     : MAX_SKEY(SP_PARM->slk_format));\n    SP_PARM->_slk->maxlen = (short) ((numlab > 0)\n\t\t\t\t     ? LabelWidth * LabelHeight\n\t\t\t\t     : MAX_SKEY_LEN(SP_PARM->slk_format));\n    SP_PARM->_slk->labcnt = (short) ((SP_PARM->_slk->maxlab < MAX_SKEY(SP_PARM->slk_format))\n\t\t\t\t     ? MAX_SKEY(SP_PARM->slk_format)\n\t\t\t\t     : SP_PARM->_slk->maxlab);\n\n    if (SP_PARM->_slk->maxlen <= 0\n\t|| SP_PARM->_slk->labcnt <= 0\n\t|| (SP_PARM->_slk->ent = typeCalloc(slk_ent,\n\t\t\t\t\t    (size_t) SP_PARM->_slk->labcnt))\n\t== NULL) {\n\tfree(SP_PARM->_slk->ent);\n\treturnCode(slk_failed(NCURSES_SP_ARG));\n    }\n\n    max_length = (size_t) SP_PARM->_slk->maxlen;\n    for (i = 0; i < SP_PARM->_slk->labcnt; i++) {\n\tsize_t used = max_length + 1;\n\n\tSP_PARM->_slk->ent[i].ent_text = (char *) _nc_doalloc(0, used);\n\tif (SP_PARM->_slk->ent[i].ent_text == 0)\n\t    returnCode(slk_failed(NCURSES_SP_ARG));\n\tmemset(SP_PARM->_slk->ent[i].ent_text, 0, used);\n\n\tSP_PARM->_slk->ent[i].form_text = (char *) _nc_doalloc(0, used);\n\tif (SP_PARM->_slk->ent[i].form_text == 0)\n\t    returnCode(slk_failed(NCURSES_SP_ARG));\n\n\tif (used > 1) {\n\t    memset(SP_PARM->_slk->ent[i].form_text, ' ', used - 1);\n\t}\n\tSP_PARM->_slk->ent[i].form_text[used - 1] = '\\0';\n\n\tSP_PARM->_slk->ent[i].visible = (char) (i < SP_PARM->_slk->maxlab);\n    }\n\n    res = _nc_format_slks(NCURSES_SP_ARGx cols);\n\n    if ((SP_PARM->_slk->win = stwin) == NULL) {\n\treturnCode(slk_failed(NCURSES_SP_ARG));\n    }\n\n     \n    _nc_globals.slk_format = 0;\n    returnCode(res);\n}\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_restore) (NCURSES_SP_DCL0)\n{\n    T((T_CALLED(\"slk_restore(%p)\"), (void *) SP_PARM));\n\n    if (0 == SP_PARM)\n\treturnCode(ERR);\n    if (SP_PARM->_slk == NULL)\n\treturnCode(ERR);\n    SP_PARM->_slk->hidden = FALSE;\n    SP_PARM->_slk->dirty = TRUE;\n\n    returnCode(NCURSES_SP_NAME(slk_refresh) (NCURSES_SP_ARG));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_restore(void)\n{\n    return NCURSES_SP_NAME(slk_restore) (CURRENT_SCREEN);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}