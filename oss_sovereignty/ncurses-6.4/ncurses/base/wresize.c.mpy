{
  "module_name": "wresize.c",
  "hash_id": "4332604b040b51d0a3554e0fd3d6e359efd3aba577a3e74ca96979419e1262ad",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/wresize.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: wresize.c,v 1.42 2021/10/23 18:54:16 tom Exp $\")\n\nstatic int\ncleanup_lines(struct ldat *data, int length)\n{\n    while (--length >= 0)\n\tFreeAndNull(data[length].text);\n    free(data);\n    return ERR;\n}\n\n \nstatic void\nrepair_subwindows(WINDOW *cmp)\n{\n    WINDOWLIST *wp;\n    struct ldat *pline = cmp->_line;\n    int row;\n#ifdef USE_SP_WINDOWLIST\n    SCREEN *sp = _nc_screen_of(cmp);\n#endif\n\n    _nc_lock_global(curses);\n\n    for (each_window(SP_PARM, wp)) {\n\tWINDOW *tst = &(wp->win);\n\n\tif (tst->_parent == cmp) {\n\n#define REPAIR1(field, limit) \\\n\t    if (tst->field > cmp->limit) \\\n\t\ttst->field = cmp->limit\n\n\t    REPAIR1(_pary, _maxy);\n\t    REPAIR1(_parx, _maxx);\n\n#define REPAIR2(field, limit) \\\n\t    if (tst->limit + tst->field > cmp->limit) \\\n\t\ttst->limit = (NCURSES_SIZE_T) (cmp->limit - tst->field)\n\n\t    REPAIR2(_pary, _maxy);\n\t    REPAIR2(_parx, _maxx);\n\n#define REPAIR3(field, limit) \\\n\t    if (tst->field > tst->limit) \\\n\t\ttst->field = tst->limit\n\n\t    REPAIR3(_cury, _maxy);\n\t    REPAIR3(_curx, _maxx);\n\n\t    REPAIR3(_regtop, _maxy);\n\t    REPAIR3(_regbottom, _maxy);\n\n\t    for (row = 0; row <= tst->_maxy; ++row) {\n\t\ttst->_line[row].text = &pline[tst->_pary + row].text[tst->_parx];\n\t    }\n\t    repair_subwindows(tst);\n\t}\n    }\n    _nc_unlock_global(curses);\n}\n\n \nNCURSES_EXPORT(int)\nwresize(WINDOW *win, int ToLines, int ToCols)\n{\n    int col, row, size_x, size_y;\n    struct ldat *pline;\n    struct ldat *new_lines = 0;\n\n#ifdef TRACE\n    T((T_CALLED(\"wresize(%p,%d,%d)\"), (void *) win, ToLines, ToCols));\n    if (win) {\n\tTR(TRACE_UPDATE, (\"...beg (%ld, %ld), max(%ld,%ld), reg(%ld,%ld)\",\n\t\t\t  (long) win->_begy, (long) win->_begx,\n\t\t\t  (long) win->_maxy, (long) win->_maxx,\n\t\t\t  (long) win->_regtop, (long) win->_regbottom));\n\tif (USE_TRACEF(TRACE_UPDATE)) {\n\t    _tracedump(\"...before\", win);\n\t    _nc_unlock_global(tracef);\n\t}\n    }\n#endif\n\n    if (!win || --ToLines < 0 || --ToCols < 0)\n\treturnCode(ERR);\n\n    size_x = win->_maxx;\n    size_y = win->_maxy;\n\n    if (ToLines == size_y\n\t&& ToCols == size_x)\n\treturnCode(OK);\n\n    if (IS_SUBWIN(win)) {\n\t \n\tif (win->_pary + ToLines > win->_parent->_maxy\n\t    || win->_parx + ToCols > win->_parent->_maxx) {\n\t    returnCode(ERR);\n\t}\n\tpline = win->_parent->_line;\n    } else {\n\tpline = 0;\n    }\n\n     \n    new_lines = typeCalloc(struct ldat, (unsigned) (ToLines + 1));\n    if (new_lines == 0)\n\treturnCode(ERR);\n\n     \n    for (row = 0; row <= ToLines; ++row) {\n\tint begin = (row > size_y) ? 0 : (size_x + 1);\n\tint end = ToCols;\n\tNCURSES_CH_T *s;\n\n\tif (!IS_SUBWIN(win)) {\n\t    if (row <= size_y) {\n\t\tif (ToCols != size_x) {\n\t\t    s = typeMalloc(NCURSES_CH_T, (unsigned) ToCols + 1);\n\t\t    if (s == 0)\n\t\t\treturnCode(cleanup_lines(new_lines, row));\n\t\t    for (col = 0; col <= ToCols; ++col) {\n\t\t\tbool valid = (col <= size_x);\n\t\t\tif_WIDEC({\n\t\t\t    if (col == ToCols\n\t\t\t\t&& col < size_x\n\t\t\t\t&& isWidecBase(win->_line[row].text[col])) {\n\t\t\t\tvalid = FALSE;\n\t\t\t    }\n\t\t\t});\n\t\t\ts[col] = (valid\n\t\t\t\t  ? win->_line[row].text[col]\n\t\t\t\t  : win->_nc_bkgd);\n\t\t    }\n\t\t} else {\n\t\t    s = win->_line[row].text;\n\t\t}\n\t    } else {\n\t\ts = typeMalloc(NCURSES_CH_T, (unsigned) ToCols + 1);\n\t\tif (s == 0)\n\t\t    returnCode(cleanup_lines(new_lines, row));\n\t\tfor (col = 0; col <= ToCols; ++col)\n\t\t    s[col] = win->_nc_bkgd;\n\t    }\n\t} else if (pline != 0 && pline[win->_pary + row].text != 0) {\n\t    s = &pline[win->_pary + row].text[win->_parx];\n\t} else {\n\t    s = 0;\n\t}\n\n\tif_USE_SCROLL_HINTS(new_lines[row].oldindex = row);\n\tif (row <= size_y) {\n\t    new_lines[row].firstchar = win->_line[row].firstchar;\n\t    new_lines[row].lastchar = win->_line[row].lastchar;\n\t}\n\tif ((ToCols != size_x) || (row > size_y)) {\n\t    if (end >= begin) {\t \n\t\tif (new_lines[row].firstchar < begin)\n\t\t    new_lines[row].firstchar = (NCURSES_SIZE_T) begin;\n\t    } else {\t\t \n\t\tnew_lines[row].firstchar = 0;\n\t    }\n\t    new_lines[row].lastchar = (NCURSES_SIZE_T) ToCols;\n\t}\n\tnew_lines[row].text = s;\n    }\n\n     \n    if (!(win->_flags & _SUBWIN)) {\n\tif (ToCols == size_x) {\n\t    for (row = ToLines + 1; row <= size_y; row++) {\n\t\tFreeAndNull(win->_line[row].text);\n\t    }\n\t} else {\n\t    for (row = 0; row <= size_y; row++) {\n\t\tFreeAndNull(win->_line[row].text);\n\t    }\n\t}\n    }\n\n    FreeAndNull(win->_line);\n    win->_line = new_lines;\n\n     \n    win->_maxx = (NCURSES_SIZE_T) ToCols;\n    win->_maxy = (NCURSES_SIZE_T) ToLines;\n\n    if (win->_regtop > win->_maxy)\n\twin->_regtop = win->_maxy;\n    if (win->_regbottom > win->_maxy\n\t|| win->_regbottom == size_y)\n\twin->_regbottom = win->_maxy;\n\n    if (win->_curx > win->_maxx)\n\twin->_curx = win->_maxx;\n    if (win->_cury > win->_maxy)\n\twin->_cury = win->_maxy;\n\n     \n    repair_subwindows(win);\n\n#ifdef TRACE\n    TR(TRACE_UPDATE, (\"...beg (%ld, %ld), max(%ld,%ld), reg(%ld,%ld)\",\n\t\t      (long) win->_begy, (long) win->_begx,\n\t\t      (long) win->_maxy, (long) win->_maxx,\n\t\t      (long) win->_regtop, (long) win->_regbottom));\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\t_tracedump(\"...after:\", win);\n\t_nc_unlock_global(tracef);\n    }\n#endif\n    returnCode(OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}