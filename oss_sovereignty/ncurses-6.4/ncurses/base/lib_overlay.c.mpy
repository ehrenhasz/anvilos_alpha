{
  "module_name": "lib_overlay.c",
  "hash_id": "66754a6069f740ffa45b4bb450b72139f3d5155882ad35990ba08b7b92c48d85",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_overlay.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_overlay.c,v 1.33 2020/02/02 23:34:34 tom Exp $\")\n\nstatic int\noverlap(const WINDOW *const src, WINDOW *const dst, int const flag)\n{\n    int rc = ERR;\n\n    T((T_CALLED(\"overlap(%p,%p,%d)\"), (const void *) src, (void *) dst, flag));\n\n    if (src != 0 && dst != 0) {\n\tint sx1, sy1, sx2, sy2;\n\tint dx1, dy1, dx2, dy2;\n\n\t_nc_lock_global(curses);\n\n\tT((\"src : begy %ld, begx %ld, maxy %ld, maxx %ld\",\n\t   (long) src->_begy,\n\t   (long) src->_begx,\n\t   (long) src->_maxy,\n\t   (long) src->_maxx));\n\tT((\"dst : begy %ld, begx %ld, maxy %ld, maxx %ld\",\n\t   (long) dst->_begy,\n\t   (long) dst->_begx,\n\t   (long) dst->_maxy,\n\t   (long) dst->_maxx));\n\n\tsx1 = src->_begx;\n\tsy1 = src->_begy;\n\tsx2 = sx1 + src->_maxx;\n\tsy2 = sy1 + src->_maxy;\n\n\tdx1 = dst->_begx;\n\tdy1 = dst->_begy;\n\tdx2 = dx1 + dst->_maxx;\n\tdy2 = dy1 + dst->_maxy;\n\n\tif (dx2 >= sx1 && dx1 <= sx2 && dy2 >= sy1 && dy1 <= sy2) {\n\t    int sminrow = max(sy1, dy1) - sy1;\n\t    int smincol = max(sx1, dx1) - sx1;\n\t    int dminrow = max(sy1, dy1) - dy1;\n\t    int dmincol = max(sx1, dx1) - dx1;\n\t    int dmaxrow = min(sy2, dy2) - dy1;\n\t    int dmaxcol = min(sx2, dx2) - dx1;\n\n\t    rc = copywin(src, dst,\n\t\t\t sminrow, smincol,\n\t\t\t dminrow, dmincol,\n\t\t\t dmaxrow, dmaxcol,\n\t\t\t flag);\n\t}\n\t_nc_unlock_global(curses);\n    }\n    returnCode(rc);\n}\n\n \n\nNCURSES_EXPORT(int)\noverlay(const WINDOW *win1, WINDOW *win2)\n{\n    T((T_CALLED(\"overlay(%p,%p)\"), (const void *) win1, (void *) win2));\n    returnCode(overlap(win1, win2, TRUE));\n}\n\n \n\nNCURSES_EXPORT(int)\noverwrite(const WINDOW *win1, WINDOW *win2)\n{\n    T((T_CALLED(\"overwrite(%p,%p)\"), (const void *) win1, (void *) win2));\n    returnCode(overlap(win1, win2, FALSE));\n}\n\nNCURSES_EXPORT(int)\ncopywin(const WINDOW *src, WINDOW *dst,\n\tint sminrow, int smincol,\n\tint dminrow, int dmincol,\n\tint dmaxrow, int dmaxcol,\n\tint over)\n{\n    int rc = ERR;\n\n    T((T_CALLED(\"copywin(%p, %p, %d, %d, %d, %d, %d, %d, %d)\"),\n       (const void *) src,\n       (void *) dst,\n       sminrow, smincol,\n       dminrow, dmincol,\n       dmaxrow, dmaxcol, over));\n\n    if (src != 0\n\t&& dst != 0\n\t&& dmaxrow >= dminrow\n\t&& dmaxcol >= dmincol) {\n\tattr_t bk;\n\tattr_t mask;\n\n\t_nc_lock_global(curses);\n\n\tbk = AttrOf(dst->_nc_bkgd);\n\tmask = ~(attr_t) ((bk & A_COLOR) ? A_COLOR : 0);\n\n\t \n\tif ((sminrow + dmaxrow - dminrow) <= (src->_maxy + 1) &&\n\t    (smincol + dmaxcol - dmincol) <= (src->_maxx + 1)) {\n\n\t    T((\"rectangle exists in source\"));\n\n\t     \n\t    if (dmaxrow <= dst->_maxy && dmaxcol <= dst->_maxx) {\n\t\tint sx, sy, dx, dy;\n\t\tbool copied = FALSE;\n\n\t\tT((\"rectangle fits in destination\"));\n\n\t\tfor (dy = dminrow, sy = sminrow;\n\t\t     dy <= dmaxrow;\n\t\t     sy++, dy++) {\n\t\t    bool touched;\n\n\t\t    if (dy < 0 || sy < 0)\n\t\t\tcontinue;\n\n\t\t    touched = FALSE;\n\t\t    for (dx = dmincol, sx = smincol;\n\t\t\t dx <= dmaxcol;\n\t\t\t sx++, dx++) {\n\n\t\t\tif (dx < 0 || sx < 0)\n\t\t\t    continue;\n\t\t\tcopied = TRUE;\n\n\t\t\tif (over) {\n\t\t\t    if ((CharOf(src->_line[sy].text[sx]) != L(' ')) &&\n\t\t\t\t(!CharEq(dst->_line[dy].text[dx],\n\t\t\t\t\t src->_line[sy].text[sx]))) {\n\t\t\t\tdst->_line[dy].text[dx] =\n\t\t\t\t    src->_line[sy].text[sx];\n\t\t\t\tSetAttr(dst->_line[dy].text[dx],\n\t\t\t\t\t((AttrOf(src->_line[sy].text[sx]) &\n\t\t\t\t\t  mask) | bk));\n\t\t\t\ttouched = TRUE;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!CharEq(dst->_line[dy].text[dx],\n\t\t\t\t\tsrc->_line[sy].text[sx])) {\n\t\t\t\tdst->_line[dy].text[dx] =\n\t\t\t\t    src->_line[sy].text[sx];\n\t\t\t\ttouched = TRUE;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (touched) {\n\t\t\ttouchline(dst, dminrow, (dmaxrow - dminrow + 1));\n\t\t    }\n\t\t}\n\t\tT((\"finished copywin\"));\n\t\tif (copied)\n\t\t    rc = OK;\n\t    }\n\t}\n\t_nc_unlock_global(curses);\n    }\n    returnCode(rc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}