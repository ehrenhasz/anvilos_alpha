{
  "module_name": "lib_freeall.c",
  "hash_id": "de213f672bcd6ef0a21866d86b7e0d373fd623fabd308fd20afb1706cb5cf401",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_freeall.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n#include <tic.h>\n\n#if HAVE_NC_FREEALL\n\n#if HAVE_LIBDBMALLOC\nextern int malloc_errfd;\t \n#endif\n\nMODULE_ID(\"$Id: lib_freeall.c,v 1.76 2021/11/06 21:52:49 tom Exp $\")\n\n \nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_freeall) (NCURSES_SP_DCL0)\n{\n    static va_list empty_va;\n\n    T((T_CALLED(\"_nc_freeall()\")));\n#if NO_LEAKS\n    _nc_globals.leak_checking = TRUE;\n    if (SP_PARM != 0) {\n\tif (SP_PARM->_oldnum_list != 0) {\n\t    FreeAndNull(SP_PARM->_oldnum_list);\n\t}\n\tif (SP_PARM->_panelHook.destroy != 0) {\n\t    SP_PARM->_panelHook.destroy(SP_PARM->_panelHook.stdscr_pseudo_panel);\n\t}\n#if NCURSES_EXT_COLORS\n\t_nc_new_pair_leaks(SP_PARM);\n#endif\n    }\n#endif\n    if (SP_PARM != 0) {\n\t_nc_lock_global(curses);\n\n\twhile (WindowList(SP_PARM) != 0) {\n\t    WINDOWLIST *p, *q;\n\t    bool deleted = FALSE;\n\n\t     \n\t    for (each_window(SP_PARM, p)) {\n\t\tWINDOW *p_win = &(p->win);\n\t\tbool found = FALSE;\n\n\t\tif (IS_PAD(p_win))\n\t\t    continue;\n\n#ifndef USE_SP_WINDOWLIST\n\t\tif (p->screen != SP_PARM)\n\t\t    continue;\n#endif\n\n\t\tfor (each_window(SP_PARM, q)) {\n\t\t    WINDOW *q_win = &(q->win);\n\n#ifndef USE_SP_WINDOWLIST\n\t\t    if (q->screen != SP_PARM)\n\t\t\tcontinue;\n#endif\n\n\t\t    if ((p != q)\n\t\t\t&& IS_SUBWIN(q_win)\n\t\t\t&& (p_win == q_win->_parent)) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tif (!found) {\n\t\t    if (delwin(p_win) != ERR)\n\t\t\tdeleted = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\n\t     \n\t    if (!deleted)\n\t\tbreak;\n\t}\n\tdelscreen(SP_PARM);\n\t_nc_unlock_global(curses);\n    }\n\n    (void) _nc_printf_string(0, empty_va);\n#ifdef TRACE\n    (void) _nc_trace_buf(-1, (size_t) 0);\n#endif\n#if USE_WIDEC_SUPPORT\n    FreeIfNeeded(_nc_wacs);\n#endif\n    _nc_leaks_tinfo();\n\n#if HAVE_LIBDBMALLOC\n    malloc_dump(malloc_errfd);\n#elif HAVE_LIBDMALLOC\n#elif HAVE_LIBMPATROL\n    __mp_summary();\n#elif HAVE_PURIFY\n    purify_all_inuse();\n#endif\n    returnVoid;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_freeall(void)\n{\n    NCURSES_SP_NAME(_nc_freeall) (CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_free_and_exit) (NCURSES_SP_DCLx int code)\n{\n    T((T_CALLED(\"_nc_free_and_exit(%d)\"), code));\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n    NCURSES_SP_NAME(_nc_freeall) (NCURSES_SP_ARG);\n#ifdef TRACE\n    curses_trace(0);\t\t \n    {\n\tstatic va_list fake;\n\tfree(_nc_varargs(\"?\", fake));\n    }\n#endif\n    exit(code);\n}\n\n#else  \nNCURSES_EXPORT(void)\n_nc_freeall(void)\n{\n}\n\nNCURSES_EXPORT(void)\nNCURSES_SP_NAME(_nc_free_and_exit) (NCURSES_SP_DCLx int code)\n{\n    if (SP_PARM) {\n\tdelscreen(SP_PARM);\n    }\n    exit(code);\n}\n#endif  \n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(void)\n_nc_free_and_exit(int code)\n{\n    NCURSES_SP_NAME(_nc_free_and_exit) (CURRENT_SCREEN, code);\n}\n#endif\n\nNCURSES_EXPORT(void)\nexit_curses(int code)\n{\n#if NO_LEAKS\n#if NCURSES_SP_FUNCS\n    NCURSES_SP_NAME(_nc_free_and_exit) (CURRENT_SCREEN, code);\n#else\n    _nc_free_and_exit(code);\t \n#endif\n#endif\n    exit(code);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}