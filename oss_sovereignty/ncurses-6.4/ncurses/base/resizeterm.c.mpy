{
  "module_name": "resizeterm.c",
  "hash_id": "5558876e3c6da4bc4c0d6d1fa337b5fdeb0a6b2d1156ec662dc0c8fa4091fdae",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/resizeterm.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: resizeterm.c,v 1.52 2021/10/23 17:12:33 tom Exp $\")\n\n \n#if USE_REENTRANT\n#define EXTRA_ARGS ,     CurLines,     CurCols\n#define EXTRA_DCLS , int CurLines, int CurCols\n#else\nstatic int current_lines;\nstatic int current_cols;\n#define CurLines current_lines\n#define CurCols  current_cols\n#define EXTRA_ARGS\t\t \n#define EXTRA_DCLS\t\t \n#endif\n\n#if NCURSES_SP_FUNCS && !defined(USE_SP_WINDOWLIST)\n#define UNUSED_SP  (void) sp\n#else\n#define UNUSED_SP\t\t \n#endif\n\n#ifdef TRACE\nstatic void\nshow_window_sizes(const char *name)\n{\n    SCREEN *sp;\n    WINDOWLIST *wp;\n\n    _nc_lock_global(curses);\n    for (each_screen(sp)) {\n\t_tracef(\"%s resizing: %p: %2d x %2d (%2d x %2d)\", name, (void *) sp,\n\t\t*(ptrLines(sp)),\n\t\t*(ptrCols(sp)),\n\t\tscreen_lines(sp), screen_columns(sp));\n\tfor (each_window(sp, wp)) {\n\t    _tracef(\"  window %p is %2ld x %2ld at %2ld,%2ld\",\n\t\t    (void *) &(wp->win),\n\t\t    (long) wp->win._maxy + 1,\n\t\t    (long) wp->win._maxx + 1,\n\t\t    (long) wp->win._begy,\n\t\t    (long) wp->win._begx);\n\t}\n    }\n    _nc_unlock_global(curses);\n}\n#endif\n\n \nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(is_term_resized) (NCURSES_SP_DCLx int ToLines, int ToCols)\n{\n    T((T_CALLED(\"is_term_resized(%p, %d, %d)\"), (void *) SP_PARM, ToLines, ToCols));\n    returnCode(ToLines > 0\n\t       && ToCols > 0\n\t       && (ToLines != screen_lines(SP_PARM)\n\t\t   || ToCols != screen_columns(SP_PARM)));\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\nis_term_resized(int ToLines, int ToCols)\n{\n    return NCURSES_SP_NAME(is_term_resized) (CURRENT_SCREEN, ToLines, ToCols);\n}\n#endif\n\n \nstatic ripoff_t *\nripped_window(WINDOW *win)\n{\n    ripoff_t *result = 0;\n    ripoff_t *rop;\n\n    if (win != 0) {\n#ifdef USE_SP_RIPOFF\n\tSCREEN *sp = _nc_screen_of(win);\n#endif\n\tfor (each_ripoff(rop)) {\n\t    if (rop->win == win && rop->line != 0) {\n\t\tresult = rop;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return result;\n}\n\n \nstatic int\nripped_bottom(WINDOW *win)\n{\n    int result = 0;\n\n    if (win != 0) {\n\tripoff_t *rop;\n\n#ifdef USE_SP_RIPOFF\n\tSCREEN *sp = _nc_screen_of(win);\n#endif\n\tfor (each_ripoff(rop)) {\n\t    if (rop->line < 0) {\n\t\tresult -= rop->line;\n\t\tif (rop->win == win) {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\n \nstatic int\nchild_depth(WINDOW *cmp)\n{\n    int depth = 0;\n\n    if (cmp != 0) {\n#ifdef USE_SP_WINDOWLIST\n\tSCREEN *sp = _nc_screen_of(cmp);\n#endif\n\tWINDOWLIST *wp;\n\n\tfor (each_window(sp, wp)) {\n\t    WINDOW *tst = &(wp->win);\n\t    if (tst->_parent == cmp) {\n\t\tdepth = 1 + child_depth(tst);\n\t\tbreak;\n\t    }\n\t}\n    }\n    return depth;\n}\n\n \nstatic int\nparent_depth(WINDOW *cmp)\n{\n    int depth = 0;\n\n    if (cmp != 0) {\n\tWINDOW *tst;\n\twhile ((tst = cmp->_parent) != 0) {\n\t    ++depth;\n\t    cmp = tst;\n\t}\n    }\n    return depth;\n}\n\n \nstatic int\nadjust_window(WINDOW *win, int ToLines, int ToCols, int stolen EXTRA_DCLS)\n{\n    int result;\n    int bottom = CurLines + _nc_screen_of(win)->_topstolen - stolen;\n    int myLines = win->_maxy + 1;\n    int myCols = win->_maxx + 1;\n    ripoff_t *rop = ripped_window(win);\n\n    T((T_CALLED(\"adjust_window(%p,%d,%d)%s depth %d/%d currently %ldx%ld at %ld,%ld\"),\n       (void *) win, ToLines, ToCols,\n       (rop != 0) ? \" (rip)\" : \"\",\n       parent_depth(win),\n       child_depth(win),\n       (long) getmaxy(win), (long) getmaxx(win),\n       (long) getbegy(win) + win->_yoffset, (long) getbegx(win)));\n\n    if (rop != 0 && rop->line < 0) {\n\t \n\twin->_begy = (NCURSES_SIZE_T) (ToLines - ripped_bottom(win) - 0 - win->_yoffset);\n\tif (rop->hook == _nc_slk_initialize)\n\t    _nc_format_slks(\n#if NCURSES_SP_FUNCS\n\t\t\t       _nc_screen_of(win),\n#endif\n\t\t\t       ToCols);\n    } else if (win->_begy >= bottom) {\n\t \n\twin->_begy = (NCURSES_SIZE_T) (win->_begy + (ToLines - CurLines));\n    } else {\n\tif (myLines == (CurLines - stolen)\n\t    && ToLines != CurLines) {\n\t    myLines = ToLines - stolen;\n\t} else if (myLines == CurLines\n\t\t   && ToLines != CurLines) {\n\t    myLines = ToLines;\n\t}\n    }\n\n    if (myLines > ToLines) {\n\tmyLines = ToLines;\n    }\n\n    if (myCols > ToCols)\n\tmyCols = ToCols;\n\n    if (myCols == CurCols\n\t&& ToCols != CurCols)\n\tmyCols = ToCols;\n\n    result = wresize(win, myLines, myCols);\n    returnCode(result);\n}\n\n \nstatic int\ndecrease_size(NCURSES_SP_DCLx int ToLines, int ToCols, int stolen EXTRA_DCLS)\n{\n    bool found;\n    int depth = 0;\n    WINDOWLIST *wp;\n\n    T((T_CALLED(\"decrease_size(%p, %d, %d)\"), (void *) SP_PARM, ToLines, ToCols));\n    UNUSED_SP;\n\n    do {\n\tfound = FALSE;\n\tTR(TRACE_UPDATE, (\"decreasing size of windows to %dx%d, depth=%d\",\n\t\t\t  ToLines, ToCols, depth));\n\tfor (each_window(SP_PARM, wp)) {\n\t    WINDOW *win = &(wp->win);\n\n\t    if (!IS_PAD(win)) {\n\t\tif (child_depth(win) == depth) {\n\t\t    found = TRUE;\n\t\t    if (adjust_window(win, ToLines, ToCols,\n\t\t\t\t      stolen EXTRA_ARGS) != OK)\n\t\t\treturnCode(ERR);\n\t\t}\n\t    }\n\t}\n\t++depth;\n    } while (found);\n    returnCode(OK);\n}\n\n \nstatic int\nincrease_size(NCURSES_SP_DCLx int ToLines, int ToCols, int stolen EXTRA_DCLS)\n{\n    bool found;\n    int depth = 0;\n    WINDOWLIST *wp;\n\n    T((T_CALLED(\"increase_size(%p, %d, %d)\"), (void *) SP_PARM, ToLines, ToCols));\n    UNUSED_SP;\n\n    do {\n\tfound = FALSE;\n\tTR(TRACE_UPDATE, (\"increasing size of windows to %dx%d, depth=%d\",\n\t\t\t  ToLines, ToCols, depth));\n\tfor (each_window(SP_PARM, wp)) {\n\t    WINDOW *win = &(wp->win);\n\n\t    if (!IS_PAD(win)) {\n\t\tif (parent_depth(win) == depth) {\n\t\t    found = TRUE;\n\t\t    if (adjust_window(win, ToLines, ToCols,\n\t\t\t\t      stolen EXTRA_ARGS) != OK)\n\t\t\treturnCode(ERR);\n\t\t}\n\t    }\n\t}\n\t++depth;\n    } while (found);\n    returnCode(OK);\n}\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(resize_term) (NCURSES_SP_DCLx int ToLines, int ToCols)\n{\n    int result = OK EXTRA_ARGS;\n    int was_stolen;\n\n    T((T_CALLED(\"resize_term(%p,%d,%d) old(%d,%d)\"),\n       (void *) SP_PARM, ToLines, ToCols,\n       (SP_PARM == 0) ? -1 : screen_lines(SP_PARM),\n       (SP_PARM == 0) ? -1 : screen_columns(SP_PARM)));\n\n    if (SP_PARM == 0 || ToLines <= 0 || ToCols <= 0) {\n\treturnCode(ERR);\n    }\n\n    _nc_nonsp_lock_global(curses);\n\n    was_stolen = (screen_lines(SP_PARM) - SP_PARM->_lines_avail);\n    if (NCURSES_SP_NAME(is_term_resized) (NCURSES_SP_ARGx ToLines, ToCols)) {\n\tint myLines = CurLines = screen_lines(SP_PARM);\n\tint myCols = CurCols = screen_columns(SP_PARM);\n\n#ifdef TRACE\n\tif (USE_TRACEF(TRACE_UPDATE)) {\n\t    show_window_sizes(\"before\");\n\t    _nc_unlock_global(tracef);\n\t}\n#endif\n\tif (ToLines > screen_lines(SP_PARM)) {\n\t    result = increase_size(NCURSES_SP_ARGx\n\t\t\t\t   myLines = ToLines,\n\t\t\t\t   myCols,\n\t\t\t\t   was_stolen EXTRA_ARGS);\n\t    CurLines = myLines;\n\t    CurCols = myCols;\n\t}\n\n\tif ((result == OK)\n\t    && (ToCols > screen_columns(SP_PARM))) {\n\t    result = increase_size(NCURSES_SP_ARGx\n\t\t\t\t   myLines,\n\t\t\t\t   myCols = ToCols,\n\t\t\t\t   was_stolen EXTRA_ARGS);\n\t    CurLines = myLines;\n\t    CurCols = myCols;\n\t}\n\n\tif ((result == OK)\n\t    && (ToLines < myLines ||\n\t\tToCols < myCols)) {\n\t    result = decrease_size(NCURSES_SP_ARGx\n\t\t\t\t   ToLines,\n\t\t\t\t   ToCols,\n\t\t\t\t   was_stolen EXTRA_ARGS);\n\t}\n\n\tif (result == OK) {\n\t    screen_lines(SP_PARM) = (NCURSES_SIZE_T) ToLines;\n\t    screen_columns(SP_PARM) = (NCURSES_SIZE_T) ToCols;\n\n#ifdef USE_TERM_DRIVER\n\t    CallDriver_2(SP_PARM, td_setsize, ToLines, ToCols);\n#else\n\t    lines = (NCURSES_SIZE_T) ToLines;\n\t    columns = (NCURSES_SIZE_T) ToCols;\n#endif\n\n\t    SP_PARM->_lines_avail = (NCURSES_SIZE_T) (ToLines - was_stolen);\n\n\t    if (SP_PARM->oldhash) {\n\t\tFreeAndNull(SP_PARM->oldhash);\n\t    }\n\t    if (SP_PARM->newhash) {\n\t\tFreeAndNull(SP_PARM->newhash);\n\t    }\n#ifdef TRACE\n\t    if (USE_TRACEF(TRACE_UPDATE)) {\n\t\tSET_LINES(ToLines - was_stolen);\n\t\tSET_COLS(ToCols);\n\t\tshow_window_sizes(\"after\");\n\t\t_nc_unlock_global(tracef);\n\t    }\n#endif\n\t}\n    }\n\n    if (result == OK) {\n\t \n\tSET_LINES(ToLines - was_stolen);\n\tSET_COLS(ToCols);\n    }\n\n    _nc_nonsp_unlock_global(curses);\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nresize_term(int ToLines, int ToCols)\n{\n    int res;\n    _nc_sp_lock_global(curses);\n    res = NCURSES_SP_NAME(resize_term) (CURRENT_SCREEN, ToLines, ToCols);\n    _nc_sp_unlock_global(curses);\n    return (res);\n}\n#endif\n\n \nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(resizeterm) (NCURSES_SP_DCLx int ToLines, int ToCols)\n{\n    int result = ERR;\n\n    T((T_CALLED(\"resizeterm(%p, %d,%d) old(%d,%d)\"),\n       (void *) SP_PARM, ToLines, ToCols,\n       (SP_PARM == 0) ? -1 : screen_lines(SP_PARM),\n       (SP_PARM == 0) ? -1 : screen_columns(SP_PARM)));\n\n    if (SP_PARM != 0 && ToLines > 0 && ToCols > 0) {\n\tresult = OK;\n\tSP_PARM->_sig_winch = FALSE;\n\n\tif (NCURSES_SP_NAME(is_term_resized) (NCURSES_SP_ARGx ToLines, ToCols)) {\n#if USE_SIGWINCH\n\t    ripoff_t *rop;\n\t    bool slk_visible = (SP_PARM != 0\n\t\t\t\t&& SP_PARM->_slk != 0\n\t\t\t\t&& !(SP_PARM->_slk->hidden));\n\n\t    if (slk_visible) {\n\t\tslk_clear();\n\t    }\n#endif\n\t    result = NCURSES_SP_NAME(resize_term) (NCURSES_SP_ARGx ToLines, ToCols);\n\n#if USE_SIGWINCH\n\t    clearok(CurScreen(SP_PARM), TRUE);\t \n\n\t     \n\t    for (each_ripoff(rop)) {\n\t\tif (rop->win != StdScreen(SP_PARM)\n\t\t    && rop->win != 0\n\t\t    && rop->line < 0) {\n\n\t\t    if (rop->hook != _nc_slk_initialize) {\n\t\t\ttouchwin(rop->win);\n\t\t\twnoutrefresh(rop->win);\n\t\t    }\n\t\t}\n\t    }\n\n\t     \n\t    if (slk_visible) {\n\t\tNCURSES_SP_NAME(slk_restore) (NCURSES_SP_ARG);\n\t\tNCURSES_SP_NAME(slk_touch) (NCURSES_SP_ARG);\n\t\tNCURSES_SP_NAME(slk_refresh) (NCURSES_SP_ARG);\n\t    }\n#endif\n\t}\n#if USE_SIGWINCH\n\tsafe_ungetch(SP_PARM, KEY_RESIZE);\t \n#endif\n    }\n\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nresizeterm(int ToLines, int ToCols)\n{\n    return NCURSES_SP_NAME(resizeterm) (CURRENT_SCREEN, ToLines, ToCols);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}