{
  "module_name": "new_pair.c",
  "hash_id": "fc264ef9375b065e9e97f69a9ef10f03f69402e9e33e7c36057cdb9b6afe4b58",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/new_pair.c",
  "human_readable_source": " \n\n \n\n \n\n#define NEW_PAIR_INTERNAL 1\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\n#ifdef USE_TERM_DRIVER\n#define MaxColors      InfoOf(SP_PARM).maxcolors\n#else\n#define MaxColors      max_colors\n#endif\n\n#if NCURSES_EXT_COLORS\n\n \n#undef entry\n#define entry my_entry\n#undef ENTRY\n#define ENTRY my_ENTRY\n\n#include <search.h>\n\n#endif\n\nMODULE_ID(\"$Id: new_pair.c,v 1.23 2021/08/16 22:11:26 tom Exp $\")\n\n#if NCURSES_EXT_COLORS\n\n#ifdef NEW_PAIR_DEBUG\n\nstatic int\nprev_len(SCREEN *sp, int pair)\n{\n    int result = 1;\n    int base = pair;\n    colorpair_t *list = sp->_color_pairs;\n    while (list[pair].prev != base) {\n\tresult++;\n\tpair = list[pair].prev;\n    }\n    return result;\n}\n\nstatic int\nnext_len(SCREEN *sp, int pair)\n{\n    int result = 1;\n    int base = pair;\n    colorpair_t *list = sp->_color_pairs;\n    while (list[pair].next != base) {\n\tresult++;\n\tpair = list[pair].next;\n    }\n    return result;\n}\n\n \nstatic void\ndumpit(SCREEN *sp, int pair, const char *tag)\n{\n    colorpair_t *list = sp->_color_pairs;\n    char bigbuf[256 * 20];\n    char *p = bigbuf;\n    int n;\n    size_t have = sizeof(bigbuf);\n\n    _nc_STRCPY(p, tag, have);\n    for (n = 0; n < sp->_pair_alloc; ++n) {\n\tif (list[n].mode != cpFREE) {\n\t    p += strlen(p);\n\t    if ((size_t) (p - bigbuf) + 50 > have)\n\t\tbreak;\n\t    _nc_SPRINTF(p, _nc_SLIMIT(have - (p - bigbuf))\n\t\t\t\" %d%c(%d,%d)\",\n\t\t\tn, n == pair ? '@' : ':', list[n].next, list[n].prev);\n\t}\n    }\n    T((\"(%d/%d) %ld - %s\",\n       next_len(sp, 0),\n       prev_len(sp, 0),\n       strlen(bigbuf), bigbuf));\n\n    if (next_len(sp, 0) != prev_len(sp, 0)) {\n\tendwin();\n\tExitProgram(EXIT_FAILURE);\n    }\n}\n#else\n#define dumpit(sp, pair, tag)\t \n#endif\n\nstatic int\ncompare_data(const void *a, const void *b)\n{\n    const colorpair_t *p = (const colorpair_t *) a;\n    const colorpair_t *q = (const colorpair_t *) b;\n    return ((p->fg == q->fg)\n\t    ? (p->bg - q->bg)\n\t    : (p->fg - q->fg));\n}\n\nstatic int\n_nc_find_color_pair(SCREEN *sp, int fg, int bg)\n{\n    colorpair_t find;\n    int result = -1;\n\n    find.fg = fg;\n    find.bg = bg;\n    if (sp != 0) {\n\tvoid *pp;\n\tif ((pp = tfind(&find, &sp->_ordered_pairs, compare_data)) != 0) {\n\t    colorpair_t *temp = *(colorpair_t **) pp;\n\t    result = (int) (temp - sp->_color_pairs);\n\t}\n    }\n    return result;\n}\n\nstatic void\ndelink_color_pair(SCREEN *sp, int pair)\n{\n    colorpair_t *list = sp->_color_pairs;\n    int prev = list[pair].prev;\n    int next = list[pair].next;\n\n     \n    if (list[prev].next == pair &&\n\tlist[next].prev == pair) {\n\tlist[prev].next = next;\n\tlist[next].prev = prev;\n\tdumpit(sp, pair, \"delinked\");\n    }\n}\n\n \nNCURSES_EXPORT(void)\n_nc_free_ordered_pairs(SCREEN *sp)\n{\n    if (sp && sp->_ordered_pairs && sp->_pair_alloc) {\n\tint n;\n\tfor (n = 0; n < sp->_pair_alloc; ++n) {\n\t    tdelete(&sp->_color_pairs[n], &sp->_ordered_pairs, compare_data);\n\t}\n    }\n}\n\n \nNCURSES_EXPORT(void)\n_nc_reset_color_pair(SCREEN *sp, int pair, colorpair_t * next)\n{\n    colorpair_t *last;\n\n    if (ValidPair(sp, pair)) {\n\tbool used;\n\n\tReservePairs(sp, pair);\n\tlast = &(sp->_color_pairs[pair]);\n\tdelink_color_pair(sp, pair);\n\tif (last->mode > cpFREE &&\n\t    (last->fg != next->fg || last->bg != next->bg)) {\n\t     \n\t    tdelete(last, &sp->_ordered_pairs, compare_data);\n\t    used = FALSE;\n\t} else {\n\t    used = (last->mode != cpFREE);\n\t}\n\tif (!used) {\n\t     \n\t    *last = *next;\n\t    tsearch(last, &sp->_ordered_pairs, compare_data);\n\t}\n    }\n}\n\n \nNCURSES_EXPORT(void)\n_nc_set_color_pair(SCREEN *sp, int pair, int mode)\n{\n    if (ValidPair(sp, pair)) {\n\tcolorpair_t *list = sp->_color_pairs;\n\tdumpit(sp, pair, \"SET_PAIR\");\n\tlist[0].mode = cpKEEP;\n\tif (list[pair].mode <= cpFREE)\n\t    sp->_pairs_used++;\n\tlist[pair].mode = mode;\n\tif (list[0].next != pair) {\n\t     \n\t    list[pair].next = list[0].next;\n\t    list[list[pair].next].prev = pair;\n\t    list[pair].prev = 0;\n\t    list[0].next = pair;\n\t}\n\tdumpit(sp, pair, \"...after\");\n    }\n}\n\n \nNCURSES_EXPORT(void)\n_nc_copy_pairs(SCREEN *sp, colorpair_t * target, colorpair_t * source, int length)\n{\n    int n;\n    for (n = 0; n < length; ++n) {\n\tvoid *find = tfind(source + n, &sp->_ordered_pairs, compare_data);\n\tif (find != 0) {\n\t    tdelete(source + n, &sp->_ordered_pairs, compare_data);\n\t    tsearch(target + n, &sp->_ordered_pairs, compare_data);\n\t}\n    }\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(alloc_pair) (NCURSES_SP_DCLx int fg, int bg)\n{\n    int pair;\n\n    T((T_CALLED(\"alloc_pair(%d,%d)\"), fg, bg));\n    if (SP_PARM == 0) {\n\tpair = -1;\n    } else if ((pair = _nc_find_color_pair(SP_PARM, fg, bg)) < 0) {\n\t \n\tif (SP_PARM->_pairs_used + 1 < SP_PARM->_pair_limit) {\n\t    bool found = FALSE;\n\t    int hint = SP_PARM->_recent_pair;\n\n\t     \n\t    for (pair = hint + 1; pair < SP_PARM->_pair_alloc; pair++) {\n\t\tif (SP_PARM->_color_pairs[pair].mode == cpFREE) {\n\t\t    T((\"found gap %d\", pair));\n\t\t    found = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (!found && (SP_PARM->_pair_alloc < SP_PARM->_pair_limit)) {\n\t\tpair = SP_PARM->_pair_alloc;\n\t\tReservePairs(SP_PARM, pair);\n\t\tif (SP_PARM->_color_pairs == 0) {\n\t\t    pair = -1;\n\t\t} else {\n\t\t    found = TRUE;\n\t\t}\n\t    }\n\t    if (!found && SP_PARM->_color_pairs != NULL) {\n\t\tfor (pair = 1; pair <= hint; pair++) {\n\t\t    if (SP_PARM->_color_pairs[pair].mode == cpFREE) {\n\t\t\tT((\"found gap %d\", pair));\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (found) {\n\t\tSP_PARM->_recent_pair = pair;\n\t    } else {\n\t\tpair = ERR;\n\t    }\n\t} else {\n\t     \n\t    pair = SP_PARM->_color_pairs[0].prev;\n\t    T((\"reusing %d\", pair));\n\t}\n\n\tif (_nc_init_pair(SP_PARM, pair, fg, bg) == ERR)\n\t    pair = ERR;\n    }\n    returnCode(pair);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(find_pair) (NCURSES_SP_DCLx int fg, int bg)\n{\n    int pair;\n\n    T((T_CALLED(\"find_pair(%d,%d)\"), fg, bg));\n    pair = _nc_find_color_pair(SP_PARM, fg, bg);\n    returnCode(pair);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(free_pair) (NCURSES_SP_DCLx int pair)\n{\n    int result = ERR;\n    T((T_CALLED(\"free_pair(%d)\"), pair));\n    if (ValidPair(SP_PARM, pair) && pair < SP_PARM->_pair_alloc) {\n\tcolorpair_t *cp = &(SP_PARM->_color_pairs[pair]);\n\tif (pair != 0) {\n\t    _nc_change_pair(SP_PARM, pair);\n\t    delink_color_pair(SP_PARM, pair);\n\t    tdelete(cp, &SP_PARM->_ordered_pairs, compare_data);\n\t    cp->mode = cpFREE;\n\t    result = OK;\n\t    SP_PARM->_pairs_used--;\n\t}\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nalloc_pair(int f, int b)\n{\n    return NCURSES_SP_NAME(alloc_pair) (CURRENT_SCREEN, f, b);\n}\n\nNCURSES_EXPORT(int)\nfind_pair(int f, int b)\n{\n    return NCURSES_SP_NAME(find_pair) (CURRENT_SCREEN, f, b);\n}\n\nNCURSES_EXPORT(int)\nfree_pair(int pair)\n{\n    return NCURSES_SP_NAME(free_pair) (CURRENT_SCREEN, pair);\n}\n#endif\n\n#if NO_LEAKS\nNCURSES_EXPORT(void)\n_nc_new_pair_leaks(SCREEN *sp)\n{\n    if (sp->_color_pairs) {\n\twhile (sp->_color_pairs[0].next) {\n\t    free_pair(sp->_color_pairs[0].next);\n\t}\n    }\n}\n#endif\n\n#else\nvoid _nc_new_pair(void);\nvoid\n_nc_new_pair(void)\n{\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}