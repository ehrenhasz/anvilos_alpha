{
  "module_name": "lib_screen.c",
  "hash_id": "a93314f943154ea7e002c43fcf2b4bdf36dbec51d55f8496aad06b8ce5c74672",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_screen.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n\n#include <ctype.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_screen.c,v 1.104 2021/10/23 17:12:16 tom Exp $\")\n\n#define MAX_SIZE 0x3fff\t\t \n\n#define MARKER '\\\\'\n#define APPEND '+'\n#define GUTTER '|'\n#define L_CURL '{'\n#define R_CURL '}'\n\n#if USE_STRING_HACKS && HAVE_SNPRINTF\n#define ARG_SLIMIT(name) size_t name,\n#else\n#define ARG_SLIMIT(name)\t \n#endif\n\n#define CUR_SLIMIT _nc_SLIMIT(limit - (size_t) (target - base))\n#define TOP_SLIMIT _nc_SLIMIT(sizeof(buffer))\n\n \nstatic const char my_magic[] =\n{'\\210', '\\210', '\\210', '\\210', 0};\n\n#if NCURSES_EXT_PUTWIN\ntypedef enum {\n    pINT\t\t\t \n    ,pSHORT\t\t\t \n    ,pBOOL\t\t\t \n    ,pATTR\t\t\t \n    ,pCHAR\t\t\t \n    ,pSIZE\t\t\t \n#if NCURSES_WIDECHAR\n    ,pCCHAR\t\t\t \n#endif\n} PARAM_TYPE;\n\ntypedef struct {\n    const char name[11];\n    attr_t attr;\n} SCR_ATTRS;\n\ntypedef struct {\n    const char name[17];\n    PARAM_TYPE type;\n    size_t size;\n    size_t offset;\n} SCR_PARAMS;\n\n#define DATA(name) { { #name }, A_##name }\nstatic const SCR_ATTRS scr_attrs[] =\n{\n    DATA(NORMAL),\n    DATA(STANDOUT),\n    DATA(UNDERLINE),\n    DATA(REVERSE),\n    DATA(BLINK),\n    DATA(DIM),\n    DATA(BOLD),\n    DATA(ALTCHARSET),\n    DATA(INVIS),\n    DATA(PROTECT),\n    DATA(HORIZONTAL),\n    DATA(LEFT),\n    DATA(LOW),\n    DATA(RIGHT),\n    DATA(TOP),\n    DATA(VERTICAL),\n\n#ifdef A_ITALIC\n    DATA(ITALIC),\n#endif\n};\n#undef DATA\n\n#define sizeof2(type,name) sizeof(((type *)0)->name)\n#define DATA(name, type) { { #name }, type, sizeof2(WINDOW, name), offsetof(WINDOW, name) }\n\nstatic const SCR_PARAMS scr_params[] =\n{\n    DATA(_cury, pSIZE),\n    DATA(_curx, pSIZE),\n    DATA(_maxy, pSIZE),\n    DATA(_maxx, pSIZE),\n    DATA(_begy, pSIZE),\n    DATA(_begx, pSIZE),\n    DATA(_flags, pSHORT),\n    DATA(_attrs, pATTR),\n    DATA(_bkgd, pCHAR),\n    DATA(_notimeout, pBOOL),\n    DATA(_clear, pBOOL),\n    DATA(_leaveok, pBOOL),\n    DATA(_scroll, pBOOL),\n    DATA(_idlok, pBOOL),\n    DATA(_idcok, pBOOL),\n    DATA(_immed, pBOOL),\n    DATA(_sync, pBOOL),\n    DATA(_use_keypad, pBOOL),\n    DATA(_delay, pINT),\n    DATA(_regtop, pSIZE),\n    DATA(_regbottom, pSIZE),\n    DATA(_pad._pad_y, pSIZE),\n    DATA(_pad._pad_x, pSIZE),\n    DATA(_pad._pad_top, pSIZE),\n    DATA(_pad._pad_left, pSIZE),\n    DATA(_pad._pad_bottom, pSIZE),\n    DATA(_pad._pad_right, pSIZE),\n    DATA(_yoffset, pSIZE),\n#if NCURSES_WIDECHAR\n    DATA(_bkgrnd, pCCHAR),\n#if NCURSES_EXT_COLORS\n    DATA(_color, pINT),\n#endif\n#endif\n};\n#undef DATA\n\nstatic const NCURSES_CH_T blank = NewChar(BLANK_TEXT);\n\n \nstatic char *\nread_txt(FILE *fp)\n{\n    size_t limit = 1024;\n    char *result = malloc(limit);\n    char *buffer;\n\n    if (result != 0) {\n\tint ch = 0;\n\tsize_t used = 0;\n\n\tclearerr(fp);\n\tresult[used] = '\\0';\n\tdo {\n\t    if (used + 2 >= limit) {\n\t\tlimit += 1024;\n\t\tbuffer = realloc(result, limit);\n\t\tif (buffer == 0) {\n\t\t    free(result);\n\t\t    result = 0;\n\t\t    break;\n\t\t}\n\t\tresult = buffer;\n\t    }\n\t    ch = fgetc(fp);\n\t    if (ch == EOF)\n\t\tbreak;\n\t    result[used++] = (char) ch;\n\t    result[used] = '\\0';\n\t} while (ch != '\\n');\n\n\tif (ch == '\\n') {\n\t    result[--used] = '\\0';\n\t    TR(TRACE_IEVENT, (\"READ:%s\", result));\n\t} else if (used == 0) {\n\t    free(result);\n\t    result = 0;\n\t}\n    }\n    return result;\n}\n\nstatic char *\ndecode_attr(char *source, attr_t *target, int *color)\n{\n    bool found = FALSE;\n\n    TR(TRACE_IEVENT, (\"decode_attr   '%s'\", source));\n\n    while (*source) {\n\tif (source[0] == MARKER && source[1] == L_CURL) {\n\t    source += 2;\n\t    found = TRUE;\n\t} else if (source[0] == R_CURL) {\n\t    source++;\n\t    found = FALSE;\n\t} else if (found) {\n\t    size_t n;\n\t    char *next = source;\n\n\t    if (source[0] == GUTTER) {\n\t\t++next;\n\t    } else if (*next == 'C') {\n\t\tint value = 0;\n\t\tunsigned pair;\n\t\tnext++;\n\t\twhile (isdigit(UChar(*next))) {\n\t\t    value = value * 10 + (*next++ - '0');\n\t\t}\n\t\t*target &= ~A_COLOR;\n\t\tpair = (unsigned) ((value > 256)\n\t\t\t\t   ? COLOR_PAIR(255)\n\t\t\t\t   : COLOR_PAIR(value));\n\t\t*target |= pair;\n\t\t*color = value;\n\t    } else {\n\t\twhile (isalnum(UChar(*next))) {\n\t\t    ++next;\n\t\t}\n\t\tfor (n = 0; n < SIZEOF(scr_attrs); ++n) {\n\t\t    if ((size_t) (next - source) == strlen(scr_attrs[n].name)) {\n\t\t\tif (scr_attrs[n].attr) {\n\t\t\t    *target |= scr_attrs[n].attr;\n\t\t\t} else {\n\t\t\t    *target = A_NORMAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    source = next;\n\t} else {\n\t    break;\n\t}\n    }\n    return source;\n}\n\nstatic char *\ndecode_char(char *source, int *target)\n{\n    int limit = 0;\n    int base = 16;\n    const char digits[] = \"0123456789abcdef\";\n\n    TR(TRACE_IEVENT, (\"decode_char   '%s'\", source));\n    *target = ' ';\n    switch (*source) {\n    case MARKER:\n\tswitch (*++source) {\n\tcase APPEND:\n\t    break;\n\tcase MARKER:\n\t    *target = MARKER;\n\t    ++source;\n\t    break;\n\tcase 's':\n\t    *target = ' ';\n\t    ++source;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    base = 8;\n\t    limit = 3;\n\t    break;\n\tcase 'u':\n\t    limit = 4;\n\t    ++source;\n\t    break;\n\tcase 'U':\n\t    limit = 8;\n\t    ++source;\n\t    break;\n\t}\n\tif (limit) {\n\t    *target = 0;\n\t    while (limit-- > 0) {\n\t\tchar *find = strchr(digits, *source++);\n\t\tint ch = (find != 0) ? (int) (find - digits) : -1;\n\t\t*target *= base;\n\t\tif (ch >= 0 && ch < base) {\n\t\t    *target += ch;\n\t\t}\n\t    }\n\t}\n\tbreak;\n    default:\n\t*target = *source++;\n\tbreak;\n    }\n    return source;\n}\n\nstatic char *\ndecode_chtype(char *source, chtype fillin, chtype *target)\n{\n    attr_t attr = ChAttrOf(fillin);\n    int color = PAIR_NUMBER((int) attr);\n    int value;\n\n    TR(TRACE_IEVENT, (\"decode_chtype '%s'\", source));\n    source = decode_attr(source, &attr, &color);\n    source = decode_char(source, &value);\n    *target = (ChCharOf(value) | attr | (chtype) COLOR_PAIR(color));\n     \n    return source;\n}\n\n#if NCURSES_WIDECHAR\nstatic char *\ndecode_cchar(char *source, cchar_t *fillin, cchar_t *target)\n{\n    int color;\n    attr_t attr = fillin->attr;\n    wchar_t chars[CCHARW_MAX];\n    int append = 0;\n    int value = 0;\n\n    TR(TRACE_IEVENT, (\"decode_cchar  '%s'\", source));\n    *target = blank;\n#if NCURSES_EXT_COLORS\n    color = fillin->ext_color;\n#else\n    color = (int) PAIR_NUMBER(attr);\n#endif\n    source = decode_attr(source, &attr, &color);\n    memset(chars, 0, sizeof(chars));\n    source = decode_char(source, &value);\n    chars[0] = (wchar_t) value;\n     \n    while (source[0] == MARKER && source[1] == APPEND) {\n\tsource += 2;\n\tsource = decode_char(source, &value);\n\tif (++append < CCHARW_MAX) {\n\t    chars[append] = (wchar_t) value;\n\t}\n    }\n    setcchar(target, chars, attr, (short) color, &color);\n    return source;\n}\n#endif\n\nstatic int\nread_win(WINDOW *win, FILE *fp)\n{\n    int code = ERR;\n    size_t n;\n    int color;\n#if NCURSES_WIDECHAR\n    NCURSES_CH_T prior;\n#endif\n    chtype prior2;\n\n    memset(win, 0, sizeof(WINDOW));\n    for (;;) {\n\tchar *name;\n\tchar *value;\n\tchar *txt = read_txt(fp);\n\n\tif (txt == 0)\n\t    break;\n\tif (!strcmp(txt, \"rows:\")) {\n\t    free(txt);\n\t    code = OK;\n\t    break;\n\t}\n\tif ((value = strchr(txt, '=')) == 0) {\n\t    free(txt);\n\t    continue;\n\t}\n\t*value++ = '\\0';\n\tname = !strcmp(txt, \"flag\") ? value : txt;\n\tfor (n = 0; n < SIZEOF(scr_params); ++n) {\n\t    if (!strcmp(name, scr_params[n].name)) {\n\t\tvoid *data = (void *) ((char *) win + scr_params[n].offset);\n\n\t\tswitch (scr_params[n].type) {\n\t\tcase pATTR:\n\t\t    (void) decode_attr(value, data, &color);\n\t\t    break;\n\t\tcase pBOOL:\n\t\t    *(bool *) data = TRUE;\n\t\t    break;\n\t\tcase pCHAR:\n\t\t    prior2 = ' ';\n\t\t    decode_chtype(value, prior2, data);\n\t\t    break;\n\t\tcase pINT:\n\t\t    *(int *) data = atoi(value);\n\t\t    break;\n\t\tcase pSHORT:\n\t\t    *(short *) data = (short) atoi(value);\n\t\t    break;\n\t\tcase pSIZE:\n\t\t    *(NCURSES_SIZE_T *) data = (NCURSES_SIZE_T) atoi(value);\n\t\t    break;\n#if NCURSES_WIDECHAR\n\t\tcase pCCHAR:\n\t\t    prior = blank;\n\t\t    decode_cchar(value, &prior, data);\n\t\t    break;\n#endif\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tfree(txt);\n    }\n    return code;\n}\n\nstatic int\nread_row(char *source, NCURSES_CH_T *prior, NCURSES_CH_T *target, int length)\n{\n    while (*source != '\\0' && length > 0) {\n#if NCURSES_WIDECHAR\n\tint len;\n\n\tsource = decode_cchar(source, prior, target);\n\tlen = _nc_wacs_width(target->chars[0]);\n\tif (len > 1) {\n\t    int n;\n\n\t    SetWidecExt(CHDEREF(target), 0);\n\t    for (n = 1; n < len; ++n) {\n\t\ttarget[n] = target[0];\n\t\tSetWidecExt(CHDEREF(target), n);\n\t    }\n\t    target += (len - 1);\n\t    length -= (len - 1);\n\t}\n#else\n\tsource = decode_chtype(source, *prior, target);\n#endif\n\t*prior = *target;\n\t++target;\n\t--length;\n    }\n    while (length-- > 0) {\n\t*target++ = blank;\n    }\n     \n    return 0;\n}\n#endif  \n\n \nstatic int\nread_block(void *target, size_t length, FILE *fp)\n{\n    int result = 0;\n    char *buffer = target;\n\n    clearerr(fp);\n    while (length-- != 0) {\n\tint ch = fgetc(fp);\n\tif (ch == EOF) {\n\t    result = -1;\n\t    break;\n\t}\n\t*buffer++ = (char) ch;\n    }\n    return result;\n}\n\nNCURSES_EXPORT(WINDOW *)\nNCURSES_SP_NAME(getwin) (NCURSES_SP_DCLx FILE *filep)\n{\n    WINDOW tmp, *nwin;\n    bool old_format = FALSE;\n\n    T((T_CALLED(\"getwin(%p)\"), (void *) filep));\n\n    if (filep == 0) {\n\treturnWin(0);\n    }\n\n     \n    if (read_block(&tmp, (size_t) 4, filep) < 0) {\n\treturnWin(0);\n    }\n     \n    if (!memcmp(&tmp, my_magic, (size_t) 4)) {\n#if NCURSES_EXT_PUTWIN\n\tif (read_win(&tmp, filep) < 0)\n#endif\n\t    returnWin(0);\n    } else if (read_block(((char *) &tmp) + 4, sizeof(WINDOW) - 4, filep) < 0) {\n\treturnWin(0);\n    } else {\n\told_format = TRUE;\n    }\n\n     \n    if (tmp._maxy == 0 ||\n\ttmp._maxy > MAX_SIZE ||\n\ttmp._maxx == 0 ||\n\ttmp._maxx > MAX_SIZE) {\n\treturnWin(0);\n    }\n\n    if (IS_PAD(&tmp)) {\n\tnwin = NCURSES_SP_NAME(newpad) (NCURSES_SP_ARGx\n\t\t\t\t\ttmp._maxy + 1,\n\t\t\t\t\ttmp._maxx + 1);\n    } else {\n\tnwin = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx\n\t\t\t\t\ttmp._maxy + 1,\n\t\t\t\t\ttmp._maxx + 1, 0, 0);\n    }\n\n     \n    if (nwin != 0) {\n\tint n;\n\tsize_t linesize = sizeof(NCURSES_CH_T) * (size_t) (tmp._maxx + 1);\n\n\tnwin->_curx = tmp._curx;\n\tnwin->_cury = tmp._cury;\n\tnwin->_maxy = tmp._maxy;\n\tnwin->_maxx = tmp._maxx;\n\tnwin->_begy = tmp._begy;\n\tnwin->_begx = tmp._begx;\n\tnwin->_yoffset = tmp._yoffset;\n\tnwin->_flags = tmp._flags & ~(_SUBWIN);\n\n\tWINDOW_ATTRS(nwin) = WINDOW_ATTRS(&tmp);\n\tnwin->_nc_bkgd = tmp._nc_bkgd;\n\n\tnwin->_notimeout = tmp._notimeout;\n\tnwin->_clear = tmp._clear;\n\tnwin->_leaveok = tmp._leaveok;\n\tnwin->_idlok = tmp._idlok;\n\tnwin->_idcok = tmp._idcok;\n\tnwin->_immed = tmp._immed;\n\tnwin->_scroll = tmp._scroll;\n\tnwin->_sync = tmp._sync;\n\tnwin->_use_keypad = tmp._use_keypad;\n\tnwin->_delay = tmp._delay;\n\n\tnwin->_regtop = tmp._regtop;\n\tnwin->_regbottom = tmp._regbottom;\n\n\tif (IS_PAD(&tmp))\n\t    nwin->_pad = tmp._pad;\n\n\tif (old_format) {\n\t    T((\"reading old-format screen dump\"));\n\t    for (n = 0; n <= nwin->_maxy; n++) {\n\t\tif (read_block(nwin->_line[n].text, linesize, filep) < 0) {\n\t\t    delwin(nwin);\n\t\t    returnWin(0);\n\t\t}\n\t    }\n\t}\n#if NCURSES_EXT_PUTWIN\n\telse {\n\t    char *txt = 0;\n\t    bool success = TRUE;\n\t    NCURSES_CH_T prior = blank;\n\n\t    T((\"reading new-format screen dump\"));\n\t    for (n = 0; n <= nwin->_maxy; n++) {\n\t\tlong row;\n\t\tchar *next;\n\n\t\tif ((txt = read_txt(filep)) == 0) {\n\t\t    T((\"...failed to read string for row %d\", n + 1));\n\t\t    success = FALSE;\n\t\t    break;\n\t\t}\n\t\trow = strtol(txt, &next, 10);\n\t\tif (row != (n + 1) || *next != ':') {\n\t\t    T((\"...failed to read row-number %d\", n + 1));\n\t\t    success = FALSE;\n\t\t    break;\n\t\t}\n\n\t\tif (read_row(++next, &prior, nwin->_line[n].text, tmp._maxx\n\t\t\t     + 1) < 0) {\n\t\t    T((\"...failed to read cells for row %d\", n + 1));\n\t\t    success = FALSE;\n\t\t    break;\n\t\t}\n\t\tfree(txt);\n\t\ttxt = 0;\n\t    }\n\n\t    if (!success) {\n\t\tfree(txt);\n\t\tdelwin(nwin);\n\t\treturnWin(0);\n\t    }\n\t}\n#endif\n\ttouchwin(nwin);\n    }\n    returnWin(nwin);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(WINDOW *)\ngetwin(FILE *filep)\n{\n    return NCURSES_SP_NAME(getwin) (CURRENT_SCREEN, filep);\n}\n#endif\n\n#if NCURSES_EXT_PUTWIN\nstatic void\nencode_attr(char *target, ARG_SLIMIT(limit)\n\t    attr_t source,\n\t    attr_t prior,\n\t    int source_color,\n\t    int prior_color)\n{\n#if USE_STRING_HACKS && HAVE_SNPRINTF\n    char *base = target;\n#endif\n    source &= ~A_CHARTEXT;\n    prior &= ~A_CHARTEXT;\n\n    *target = '\\0';\n    if ((source != prior) || (source_color != prior_color)) {\n\tsize_t n;\n\tbool first = TRUE;\n\n\t*target++ = MARKER;\n\t*target++ = L_CURL;\n\n\tfor (n = 0; n < SIZEOF(scr_attrs); ++n) {\n\t    if ((source & scr_attrs[n].attr) != 0 ||\n\t\t((source & ALL_BUT_COLOR) == 0 &&\n\t\t (scr_attrs[n].attr == A_NORMAL))) {\n\t\tif (first) {\n\t\t    first = FALSE;\n\t\t} else {\n\t\t    *target++ = '|';\n\t\t}\n\t\t_nc_STRCPY(target, scr_attrs[n].name, limit);\n\t\ttarget += strlen(target);\n\t    }\n\t}\n\tif (source_color != prior_color) {\n\t    if (!first)\n\t\t*target++ = '|';\n\t    _nc_SPRINTF(target, CUR_SLIMIT \"C%d\", source_color);\n\t    target += strlen(target);\n\t}\n\n\t*target++ = R_CURL;\n\t*target = '\\0';\n    }\n}\n\nstatic void\nencode_cell(char *target, ARG_SLIMIT(limit) CARG_CH_T source, CARG_CH_T previous)\n{\n#if USE_STRING_HACKS && HAVE_SNPRINTF\n    char *base = target;\n#endif\n#if NCURSES_WIDECHAR\n    size_t n;\n    int source_pair = GetPair(*source);\n    int previous_pair = GetPair(*previous);\n\n    *target = '\\0';\n    if ((previous->attr != source->attr) || (previous_pair != source_pair)) {\n\tencode_attr(target, CUR_SLIMIT\n\t\t    source->attr,\n\t\t    previous->attr,\n\t\t    source_pair,\n\t\t    previous_pair);\n    }\n    target += strlen(target);\n#if NCURSES_EXT_COLORS\n    if (previous->ext_color != source->ext_color) {\n\t_nc_SPRINTF(target, CUR_SLIMIT\n\t\t    \"%c%cC%d%c\", MARKER, L_CURL, source->ext_color, R_CURL);\n    }\n#endif\n    for (n = 0; n < SIZEOF(source->chars); ++n) {\n\tunsigned uch = (unsigned) source->chars[n];\n\tif (uch == 0)\n\t    continue;\n\tif (n) {\n\t    *target++ = MARKER;\n\t    *target++ = APPEND;\n\t}\n\t*target++ = MARKER;\n\tif (uch > 0xffff) {\n\t    _nc_SPRINTF(target, CUR_SLIMIT \"U%08x\", uch);\n\t} else if (uch > 0xff) {\n\t    _nc_SPRINTF(target, CUR_SLIMIT \"u%04x\", uch);\n\t} else if (uch < 32 || uch >= 127) {\n\t    _nc_SPRINTF(target, CUR_SLIMIT \"%03o\", uch & 0xff);\n\t} else {\n\t    switch (uch) {\n\t    case ' ':\n\t\t_nc_STRCPY(target, \"s\", limit);\n\t\tbreak;\n\t    case MARKER:\n\t\t*target++ = MARKER;\n\t\t*target = '\\0';\n\t\tbreak;\n\t    default:\n\t\t--target;\n\t\t_nc_SPRINTF(target, CUR_SLIMIT \"%c\", uch);\n\t\tbreak;\n\t    }\n\t}\n\ttarget += strlen(target);\n    }\n#else\n    chtype ch = CharOfD(source);\n\n    *target = '\\0';\n    if (AttrOfD(previous) != AttrOfD(source)) {\n\tencode_attr(target, CUR_SLIMIT\n\t\t    AttrOfD(source),\n\t\t    AttrOfD(previous),\n\t\t    GetPair(source),\n\t\t    GetPair(previous));\n    }\n    target += strlen(target);\n    *target++ = MARKER;\n    if (ch < 32 || ch >= 127) {\n\t_nc_SPRINTF(target, CUR_SLIMIT \"%03o\", UChar(ch));\n    } else {\n\tswitch (ch) {\n\tcase ' ':\n\t    _nc_STRCPY(target, \"s\", limit);\n\t    break;\n\tcase MARKER:\n\t    *target++ = MARKER;\n\t    *target = '\\0';\n\t    break;\n\tdefault:\n\t    --target;\n\t    _nc_SPRINTF(target, CUR_SLIMIT \"%c\", UChar(ch));\n\t    break;\n\t}\n    }\n#endif\n}\n#endif\n\nNCURSES_EXPORT(int)\nputwin(WINDOW *win, FILE *filep)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"putwin(%p,%p)\"), (void *) win, (void *) filep));\n\n#if NCURSES_EXT_PUTWIN\n    if (win != 0) {\n\tconst char *version = curses_version();\n\tchar buffer[1024];\n\tNCURSES_CH_T last_cell;\n\tint y;\n\n\tmemset(&last_cell, 0, sizeof(last_cell));\n\n\tclearerr(filep);\n\n\t \n#define PUTS(s) if (fputs(s, filep) == EOF || ferror(filep)) returnCode(code)\n\tPUTS(my_magic);\n\tPUTS(version);\n\tPUTS(\"\\n\");\n\tfor (y = 0; y < (int) SIZEOF(scr_params); ++y) {\n\t    const char *name = scr_params[y].name;\n\t    const char *data = (char *) win + scr_params[y].offset;\n\t    const void *dp = (const void *) data;\n\t    attr_t attr;\n\n\t    *buffer = '\\0';\n\t    if (!strncmp(name, \"_pad.\", (size_t) 5) && !IS_PAD(win)) {\n\t\tcontinue;\n\t    }\n\t    switch (scr_params[y].type) {\n\t    case pATTR:\n\t\tattr = (*(const attr_t *) dp) & ~A_CHARTEXT;\n\t\tencode_attr(buffer, TOP_SLIMIT\n\t\t\t    (*(const attr_t *) dp) & ~A_CHARTEXT,\n\t\t\t    A_NORMAL,\n\t\t\t    COLOR_PAIR((int) attr),\n\t\t\t    0);\n\t\tbreak;\n\t    case pBOOL:\n\t\tif (!(*(const bool *) data)) {\n\t\t    continue;\n\t\t}\n\t\t_nc_STRCPY(buffer, name, sizeof(buffer));\n\t\tname = \"flag\";\n\t\tbreak;\n\t    case pCHAR:\n\t\tattr = (*(const attr_t *) dp);\n\t\tencode_attr(buffer, TOP_SLIMIT\n\t\t\t    * (const attr_t *) dp,\n\t\t\t    A_NORMAL,\n\t\t\t    COLOR_PAIR((int) attr),\n\t\t\t    0);\n\t\tbreak;\n\t    case pINT:\n\t\tif (!(*(const int *) dp))\n\t\t    continue;\n\t\t_nc_SPRINTF(buffer, TOP_SLIMIT\n\t\t\t    \"%d\", *(const int *) dp);\n\t\tbreak;\n\t    case pSHORT:\n\t\tif (!(*(const short *) dp))\n\t\t    continue;\n\t\t_nc_SPRINTF(buffer, TOP_SLIMIT\n\t\t\t    \"%d\", *(const short *) dp);\n\t\tbreak;\n\t    case pSIZE:\n\t\tif (!(*(const NCURSES_SIZE_T *) dp))\n\t\t    continue;\n\t\t_nc_SPRINTF(buffer, TOP_SLIMIT\n\t\t\t    \"%d\", *(const NCURSES_SIZE_T *) dp);\n\t\tbreak;\n#if NCURSES_WIDECHAR\n\t    case pCCHAR:\n\t\tencode_cell(buffer, TOP_SLIMIT\n\t\t\t    (CARG_CH_T) dp, CHREF(last_cell));\n\t\tbreak;\n#endif\n\t    }\n\t     \n\t    if (*buffer != '\\0') {\n\t\tif (fprintf(filep, \"%s=%s\\n\", name, buffer) <= 0\n\t\t    || ferror(filep))\n\t\t    returnCode(code);\n\t    }\n\t}\n\t \n\tfprintf(filep, \"rows:\\n\");\n\tfor (y = 0; y <= win->_maxy; y++) {\n\t    NCURSES_CH_T *data = win->_line[y].text;\n\t    int x;\n\t    if (fprintf(filep, \"%d:\", y + 1) <= 0\n\t\t|| ferror(filep))\n\t\treturnCode(code);\n\t    for (x = 0; x <= win->_maxx; x++) {\n#if NCURSES_WIDECHAR\n\t\tint len = _nc_wacs_width(data[x].chars[0]);\n\t\tencode_cell(buffer, TOP_SLIMIT CHREF(data[x]), CHREF(last_cell));\n\t\tlast_cell = data[x];\n\t\tPUTS(buffer);\n\t\tif (len > 1)\n\t\t    x += (len - 1);\n#else\n\t\tencode_cell(buffer, TOP_SLIMIT CHREF(data[x]), CHREF(last_cell));\n\t\tlast_cell = data[x];\n\t\tPUTS(buffer);\n#endif\n\t    }\n\t    PUTS(\"\\n\");\n\t}\n\tcode = OK;\n    }\n#else\n     \n    if (win != 0) {\n\tsize_t len = (size_t) (win->_maxx + 1);\n\tint y;\n\n\tclearerr(filep);\n\tif (fwrite(win, sizeof(WINDOW), (size_t) 1, filep) != 1\n\t    || ferror(filep))\n\t      returnCode(code);\n\n\tfor (y = 0; y <= win->_maxy; y++) {\n\t    if (fwrite(win->_line[y].text,\n\t\t       sizeof(NCURSES_CH_T), len, filep) != len\n\t\t|| ferror(filep)) {\n\t\treturnCode(code);\n\t    }\n\t}\n\tcode = OK;\n    }\n#endif\n    returnCode(code);\n}\n\n \nstatic WINDOW *\nreplace_window(WINDOW *target, FILE *source)\n{\n    WINDOW *result = getwin(source);\n#if NCURSES_EXT_FUNCS\n    if (result != NULL) {\n\tif (getmaxx(result) != getmaxx(target)\n\t    || getmaxy(result) != getmaxy(target)) {\n\t    int code = wresize(result,\n\t\t\t       1 + getmaxy(target),\n\t\t\t       1 + getmaxx(target));\n\t    if (code != OK) {\n\t\tdelwin(result);\n\t\tresult = NULL;\n\t    }\n\t}\n    }\n#endif\n    delwin(target);\n    return result;\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(scr_restore) (NCURSES_SP_DCLx const char *file)\n{\n    FILE *fp = 0;\n    int code = ERR;\n\n    T((T_CALLED(\"scr_restore(%p,%s)\"), (void *) SP_PARM, _nc_visbuf(file)));\n\n    if (_nc_access(file, R_OK) >= 0\n\t&& (fp = safe_fopen(file, BIN_R)) != 0) {\n\tNewScreen(SP_PARM) = replace_window(NewScreen(SP_PARM), fp);\n#if !USE_REENTRANT\n\tnewscr = NewScreen(SP_PARM);\n#endif\n\t(void) fclose(fp);\n\tif (NewScreen(SP_PARM) != 0) {\n\t    code = OK;\n\t}\n    }\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nscr_restore(const char *file)\n{\n    return NCURSES_SP_NAME(scr_restore) (CURRENT_SCREEN, file);\n}\n#endif\n\nNCURSES_EXPORT(int)\nscr_dump(const char *file)\n{\n    int result;\n    FILE *fp = 0;\n\n    T((T_CALLED(\"scr_dump(%s)\"), _nc_visbuf(file)));\n\n    if (_nc_access(file, W_OK) < 0\n\t|| (fp = safe_fopen(file, BIN_W)) == 0) {\n\tresult = ERR;\n    } else {\n\t(void) putwin(newscr, fp);\n\t(void) fclose(fp);\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(scr_init) (NCURSES_SP_DCLx const char *file)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"scr_init(%p,%s)\"), (void *) SP_PARM, _nc_visbuf(file)));\n\n    if (SP_PARM != 0 &&\n#ifdef USE_TERM_DRIVER\n\tInfoOf(SP_PARM).caninit\n#else\n\t!(exit_ca_mode && non_rev_rmcup)\n#endif\n\t) {\n\tFILE *fp = 0;\n\n\tif (_nc_access(file, R_OK) >= 0\n\t    && (fp = safe_fopen(file, BIN_R)) != 0) {\n\t    CurScreen(SP_PARM) = replace_window(CurScreen(SP_PARM), fp);\n#if !USE_REENTRANT\n\t    curscr = CurScreen(SP_PARM);\n#endif\n\t    (void) fclose(fp);\n\t    if (CurScreen(SP_PARM) != 0) {\n\t\tcode = OK;\n\t    }\n\t}\n    }\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nscr_init(const char *file)\n{\n    return NCURSES_SP_NAME(scr_init) (CURRENT_SCREEN, file);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(scr_set) (NCURSES_SP_DCLx const char *file)\n{\n    int code = ERR;\n\n    T((T_CALLED(\"scr_set(%p,%s)\"), (void *) SP_PARM, _nc_visbuf(file)));\n\n    if (NCURSES_SP_NAME(scr_init) (NCURSES_SP_ARGx file) == OK) {\n\tdelwin(NewScreen(SP_PARM));\n\tNewScreen(SP_PARM) = dupwin(curscr);\n#if !USE_REENTRANT\n\tnewscr = NewScreen(SP_PARM);\n#endif\n\tif (NewScreen(SP_PARM) != 0) {\n\t    code = OK;\n\t}\n    }\n    returnCode(code);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nscr_set(const char *file)\n{\n    return NCURSES_SP_NAME(scr_set) (CURRENT_SCREEN, file);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}