{
  "module_name": "lib_slkset.c",
  "hash_id": "ee8dbb69bd3715c473d74080b69acc1f9e91e37584758e3ae74f6127527664a5",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_slkset.c",
  "human_readable_source": " \n\n \n\n \n#include <curses.priv.h>\n#include <ctype.h>\n\n#if USE_WIDEC_SUPPORT\n#if HAVE_WCTYPE_H\n#include <wctype.h>\n#endif\n#endif\n\nMODULE_ID(\"$Id: lib_slkset.c,v 1.26 2020/02/02 23:34:34 tom Exp $\")\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(slk_set) (NCURSES_SP_DCLx int i, const char *astr, int format)\n{\n    SLK *slk;\n    int offset = 0;\n    int numchrs;\n    int numcols;\n    int limit;\n    const char *str = astr;\n    const char *p;\n\n    T((T_CALLED(\"slk_set(%p, %d, \\\"%s\\\", %d)\"), (void *) SP_PARM, i, str, format));\n\n    if (SP_PARM == 0\n\t|| (slk = SP_PARM->_slk) == 0\n\t|| i < 1\n\t|| i > slk->labcnt\n\t|| format < 0\n\t|| format > 2)\n\treturnCode(ERR);\n    if (str == 0)\n\tstr = \"\";\n    --i;\t\t\t \n\n    limit = MAX_SKEY_LEN(SP_PARM->slk_format);\n    while (isspace(UChar(*str)))\n\tstr++;\t\t\t \n    p = str;\n\n#if USE_WIDEC_SUPPORT\n    numcols = 0;\n    while (*p != 0) {\n\tmbstate_t state;\n\twchar_t wc;\n\tsize_t need;\n\n\tinit_mb(state);\n\tneed = mbrtowc(0, p, strlen(p), &state);\n\tif (need == (size_t) -1)\n\t    break;\n\tmbrtowc(&wc, p, need, &state);\n\tif (!iswprint((wint_t) wc))\n\t    break;\n\tif (_nc_wacs_width(wc) + numcols > limit)\n\t    break;\n\tnumcols += _nc_wacs_width(wc);\n\tp += need;\n    }\n    numchrs = (int) (p - str);\n#else\n    while (isprint(UChar(*p)))\n\tp++;\t\t\t \n\n    numcols = (int) (p - str);\n    if (numcols > limit)\n\tnumcols = limit;\n    numchrs = numcols;\n#endif\n\n    FreeIfNeeded(slk->ent[i].ent_text);\n    if ((slk->ent[i].ent_text = strdup(str)) == 0)\n\treturnCode(ERR);\n    slk->ent[i].ent_text[numchrs] = '\\0';\n\n    if ((slk->ent[i].form_text = (char *) _nc_doalloc(slk->ent[i].form_text,\n\t\t\t\t\t\t      (size_t) (limit +\n\t\t\t\t\t\t\t\tnumchrs + 1))\n\t) == 0)\n\treturnCode(ERR);\n\n    switch (format) {\n    case 0:\t\t\t \n\toffset = 0;\n\tbreak;\n    case 1:\t\t\t \n\toffset = (limit - numcols) / 2;\n\tbreak;\n    case 2:\t\t\t \n\toffset = limit - numcols;\n\tbreak;\n    }\n    if (offset <= 0)\n\toffset = 0;\n    else\n\tmemset(slk->ent[i].form_text, ' ', (size_t) offset);\n\n    memcpy(slk->ent[i].form_text + offset,\n\t   slk->ent[i].ent_text,\n\t   (size_t) numchrs);\n\n    if (offset < limit) {\n\tmemset(slk->ent[i].form_text + offset + numchrs,\n\t       ' ',\n\t       (size_t) (limit - (offset + numcols)));\n    }\n\n    slk->ent[i].form_text[numchrs - numcols + limit] = 0;\n    slk->ent[i].dirty = TRUE;\n    returnCode(OK);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nslk_set(int i, const char *astr, int format)\n{\n    return NCURSES_SP_NAME(slk_set) (CURRENT_SCREEN, i, astr, format);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}