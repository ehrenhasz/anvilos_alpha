{
  "module_name": "MKlib_gen.sh",
  "hash_id": "af80ba3e0cfb0869d5a2b6a49417312fdd7b893eb5b8187358bb1d350d6e1fcb",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/MKlib_gen.sh",
  "human_readable_source": "#!/bin/sh\n#\n# MKlib_gen.sh -- generate sources from curses.h macro definitions\n#\n# ($Id: MKlib_gen.sh,v 1.73 2022/10/01 13:14:20 tom Exp $)\n#\n##############################################################################\n# Copyright 2018-2021,2022 Thomas E. Dickey                                  #\n# Copyright 1998-2016,2017 Free Software Foundation, Inc.                    #\n#                                                                            #\n# Permission is hereby granted, free of charge, to any person obtaining a    #\n# copy of this software and associated documentation files (the \"Software\"), #\n# to deal in the Software without restriction, including without limitation  #\n# the rights to use, copy, modify, merge, publish, distribute, distribute    #\n# with modifications, sublicense, and/or sell copies of the Software, and to #\n# permit persons to whom the Software is furnished to do so, subject to the  #\n# following conditions:                                                      #\n#                                                                            #\n# The above copyright notice and this permission notice shall be included in #\n# all copies or substantial portions of the Software.                        #\n#                                                                            #\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR #\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   #\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    #\n# THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER      #\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    #\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        #\n# DEALINGS IN THE SOFTWARE.                                                  #\n#                                                                            #\n# Except as contained in this notice, the name(s) of the above copyright     #\n# holders shall not be used in advertising or otherwise to promote the sale, #\n# use or other dealings in this Software without prior written               #\n# authorization.                                                             #\n##############################################################################\n#\n# The XSI Curses standard requires all curses entry points to exist as\n# functions, even though many definitions would normally be shadowed\n# by macros.  Rather than hand-hack all that code, we actually\n# generate functions from the macros.\n#\n# This script accepts a file of prototypes on standard input.  It discards\n# any that don't have a `generated' comment attached. It then parses each\n# prototype (relying on the fact that none of the macros take function\n# pointer or array arguments) and generates C source from it.\n#\n# Here is what the pipeline stages are doing:\n#\n# 1. sed: extract prototypes of generated functions\n# 2. sed: decorate prototypes with generated arguments a1. a2,...z\n# 3. awk: generate the calls with args matching the formals\n# 4. sed: prefix function names in prototypes so the preprocessor won't expand\n#         them.\n# 5. cpp: macro-expand the file so the macro calls turn into C calls\n# 6. awk: strip the expansion junk off the front and add the new header\n# 7. sed: squeeze spaces, strip off gen_ prefix.\n#\n\n# keep the editing independent of locale:\nif test \"${LANGUAGE+set}\"    = set; then LANGUAGE=C;    export LANGUAGE;    fi\nif test \"${LANG+set}\"        = set; then LANG=C;        export LANG;        fi\nif test \"${LC_ALL+set}\"      = set; then LC_ALL=C;      export LC_ALL;      fi\nif test \"${LC_MESSAGES+set}\" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi\nif test \"${LC_CTYPE+set}\"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi\nif test \"${LC_COLLATE+set}\"  = set; then LC_COLLATE=C;  export LC_COLLATE;  fi\n\npreprocessor=\"$1 -DNCURSES_WATTR_MACROS -DNCURSES_INTERNALS -I../include\"\nAWK=\"$2\"\nUSE=\"$3\"\n\n# A patch discussed here:\n#\thttps://gcc.gnu.org/ml/gcc-patches/2014-06/msg02185.html\n#\n# introduces spurious #line markers into the preprocessor output.  The result\n# appears in gcc 5.0 and (with modification) in 5.1, making it necessary to\n# determine if we are using gcc, and if so, what version because the proposed\n# solution uses a nonstandard option.\n#\n# As illustrated in\n#\thttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=60723\n#\n# gcc developers chose to ignore the problems with this, and summarized those\n# as \"intriguing problems\" in\n#\thttps://gcc.gnu.org/gcc-5/porting_to.html\n\nPRG=`echo \"$1\" | \"$AWK\" '{ sub(/^[ \t]*/,\"\"); sub(/[ \t].*$/, \"\"); print; }' || exit 0`\nFSF=`(\"$PRG\" --version 2>/dev/null || exit 0) | ${FGREP-grep -F} \"Free Software Foundation\" | head -n 1`\nALL=`\"$PRG\" -dumpversion 2>/dev/null || exit 0`\nONE=`echo \"$ALL\" | sed -e 's/[^0-9].*$//'`\nif test -n \"$FSF\" && test -n \"$ALL\" && test -n \"$ONE\" ; then\n\tif test \"$ONE\" -ge 5 ; then\n\t\techo \".. adding -P option to work around $PRG $ALL\" >&2\n\t\tpreprocessor=\"$preprocessor -P\"\n\tfi\nfi\n\nPID=$$\nED1=sed1_${PID}.sed\nED2=sed2_${PID}.sed\nED3=sed3_${PID}.sed\nED4=sed4_${PID}.sed\nAW1=awk1_${PID}.awk\nAW2=awk2_${PID}.awk\nTMP=gen__${PID}.c\ntrap \"rm -f $ED1 $ED2 $ED3 $ED4 $AW1 $AW2 $TMP; exit 1\" 1 2 3 15\ntrap \"rm -f $ED1 $ED2 $ED3 $ED4 $AW1 $AW2 $TMP\" 0\n\nALL=$USE\nif test \"$USE\" = implemented ; then\n\tcat >$ED1 <<EOF1\n/^extern.*implemented/{\n\th\n\ts/GCC_DEPRECATED([^)]*)//\n\ts/NCURSES_SP_NAME(\\([^)]*\\))/NCURSES_SP_NAME___\\1/\n\th\n\ts/^.*implemented:\\([^ \t*]*\\).*/P_POUNDCif_USE_\\1_SUPPORT/p\n\tg\n\ts/^extern \\([^;]*\\);.*/\\1/p\n\tg\n\ts/^.*implemented:\\([^ \t*]*\\).*/P_POUNDCendif/p\n}\n/^extern.*generated/{\n\th\n\ts/^.*generated:\\([^ \t*]*\\).*/P_POUNDCif_USE_\\1_SUPPORT/p\n\tg\n\ts/^extern \\([^;]*\\);.*/\\1/p\n\tg\n\ts/^.*generated:\\([^ \t*]*\\).*/P_POUNDCendif/p\n}\nEOF1\nelse\n\tcat >$ED1 <<EOF1\n/^extern.*${ALL}/{\n\th\n\ts/^.*${ALL}:\\([^ \t*]*\\).*/P_POUNDCif_USE_\\1_SUPPORT/p\n\tg\n\ts/^extern \\([^;]*\\);.*/\\1/p\n\tg\n\ts/^.*${ALL}:\\([^ \t*]*\\).*/P_POUNDCendif/p\n}\nEOF1\nfi\n\ncat >$ED2 <<EOF2\n/^P_/b nc\n/(void)/b nc\n\ts/,/ a1% /\n\ts/,/ a2% /\n\ts/,/ a3% /\n\ts/,/ a4% /\n\ts/,/ a5% /\n\ts/,/ a6% /\n\ts/,/ a7% /\n\ts/,/ a8% /\n\ts/,/ a9% /\n\ts/,/ a10% /\n\ts/,/ a11% /\n\ts/,/ a12% /\n\ts/,/ a13% /\n\ts/,/ a14% /\n\ts/,/ a15% /\n\ts/*/ * /g\n\ts/%/ , /g\n\ts/)/ z)/\n\ts/\\.\\.\\. z)/...)/\n:nc\n\ts/(/ ( /\n\ts/)/ )/\nEOF2\n\ncat >$ED3 <<EOF3\n/^P_/{\n\ts/^P_POUNDCif_/#if /\n\ts/^P_POUNDCendif/#endif/\n\ts/^P_//\n\tb done\n}\n\ts/\t\t*/ /g\n\ts/  */ /g\n\ts/ ,/,/g\n\ts/( /(/g\n\ts/ )/)/g\n\ts/ gen_/ /\n\ts/^[ \t]*@[ \t]*@[ \t]*/\t/\n:done\nEOF3\n\nif test \"$USE\" = generated ; then\ncat >$ED4 <<EOF\n\ts/^\\(.*\\) \\(.*\\) (\\(.*\\))\\$/NCURSES_EXPORT(\\1) \\2 (\\3)/\n\t/attr_[sg]et.* z)/s,z),z GCC_UNUSED),\nEOF\nelse\ncat >$ED4 <<EOF\n/^\\(.*\\) \\(.*\\) (\\(.*\\))\\$/ {\n\th\n\ts/^\\(.*\\) \\(.*\\) (\\(.*\\))\\$/extern \\1 call_\\2 (\\3);/\n\tp\n\tg\n\ts/^\\(.*\\) \\(.*\\) (\\(.*\\))\\$/\\1 call_\\2 (\\3)/\n\t}\ns/\\([^_]\\)NCURSES_SP_NAME___\\([a-zA-Z][a-zA-Z_]*\\)/\\1NCURSES_SP_NAME(\\2)/g\nEOF\nfi\n\ncat >$AW1 <<\\EOF1\nBEGIN\t{\n\t\tskip=0;\n\t}\n/^P_POUNDCif/ {\n\t\tprint \"\\n\"\n\t\tprint $0\n\t\tskip=0;\n}\n/^P_POUNDCendif/ {\n\t\tprint $0\n\t\tskip=1;\n}\n$0 !~ /^P_/ {\n\tif (skip)\n\t\tprint \"\\n\"\n\tskip=1;\n\n\tfirst=$1\n\tfor (i = 1; i <= NF; i++) {\n\t\tif ( $i != \"NCURSES_CONST\" ) {\n\t\t\tfirst = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsecond = first + 1;\n\treturnCast = \"\";\n\tif ( $first == \"chtype\" ) {\n\t\treturnType = \"Chtype\";\n\t} else if ( $first == \"SCREEN\" ) {\n\t\treturnType = \"SP\";\n\t} else if ( $first == \"WINDOW\" ) {\n\t\treturnType = \"Win\";\n\t} else if ( $first == \"attr_t\" || $second == \"attrset\" || $second == \"standout\" || $second == \"standend\" || $second == \"wattrset\" || $second == \"wstandout\" || $second == \"wstandend\" ) {\n\t\treturnType = \"IntAttr\";\n\t\treturnCast = \"(attr_t)\";\n\t} else if ( $first == \"bool\" || $first == \"NCURSES_BOOL\" ) {\n\t\treturnType = \"Bool\";\n\t} else if ( $second == \"*\" ) {\n\t\treturnType = ($1 == \"NCURSES_CONST\") ? \"CPtr\" : \"Ptr\";\n\t} else {\n\t\treturnType = \"Code\";\n\t}\n\tmyfunc = second;\n\tfor (i = second; i <= NF; i++) {\n\t\tif ($i != \"*\") {\n\t\t\tmyfunc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (using == \"implemented\") {\n\t\tprintf \"#undef %s\\n\", $myfunc;\n\t}\n\tprint $0;\n\tprint \"{\";\n\targcount = 1;\n\tcheck = NF - 1;\n\tif ($check == \"void\")\n\t\targcount = 0;\n\tif (argcount != 0) {\n\t\tfor (i = 1; i <= NF; i++)\n\t\t\tif ($i == \",\")\n\t\t\t\targcount++;\n\t}\n\n\t# suppress trace-code for functions that we cannot do properly here,\n\t# since they return data.\n\tdotrace = 1;\n\tif ($myfunc ~ /innstr/)\n\t\tdotrace = 0;\n\tif ($myfunc ~ /innwstr/)\n\t\tdotrace = 0;\n\n\t# workaround functions that we do not parse properly\n\tif ($myfunc ~ /ripoffline/) {\n\t\tdotrace = 0;\n\t\targcount = 2;\n\t\tif ($myfunc ~ /NCURSES_SP_NAME/) {\n\t\t\targcount = 3;\n\t\t}\n\t}\n\tif ($myfunc ~ /wunctrl/) {\n\t\tdotrace = 0;\n\t}\n\n\tdo_getstr = 0;\n\tif ($myfunc ~ /get[n]?str/) {\n\t\tdo_getstr = 1;\n\t}\n\n\tcall = \"@@T((T_CALLED(\\\"\"\n\targs = \"\"\n\tcomma = \"\"\n\tnum = 0;\n\tpointer = 0;\n\tva_list = 0;\n\tvarargs = 0;\n\targtype = \"\"\n\tfor (i = myfunc; i <= NF; i++) {\n\t\tch = $i;\n\t\tif ( ch == \"*\" ) {\n\t\t\tpointer = 1;\n\t\t} else if ( ch == \"va_list\" ) {\n\t\t\tva_list = 1;\n\t\t} else if ( ch == \"...\" ) {\n\t\t\tvarargs = 1;\n\t\t} else if ( ch == \"char\" ) {\n\t\t\targtype = \"char\";\n\t\t} else if ( ch == \"int\" ) {\n\t\t\targtype = \"int\";\n\t\t} else if ( ch == \"short\" ) {\n\t\t\targtype = \"short\";\n\t\t} else if ( ch == \"chtype\" ) {\n\t\t\targtype = \"chtype\";\n\t\t} else if ( ch == \"attr_t\" || ch == \"NCURSES_ATTR_T\" ) {\n\t\t\targtype = \"attr\";\n\t\t}\n\n\t\tif ( ch == \",\" || ch == \")\" ) {\n\t\t\targcast = \"\";\n\t\t\tif (va_list) {\n\t\t\t\tcall = call \"%s\"\n\t\t\t} else if (varargs) {\n\t\t\t\tcall = call \"%s\"\n\t\t\t} else if (pointer) {\n\t\t\t\tif ( argtype == \"char\" ) {\n\t\t\t\t\tif (do_getstr) {\n\t\t\t\t\t\tcall = call \"%p\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcall = call \"%s\"\n\t\t\t\t\t}\n\t\t\t\t\tcomma = comma \"_nc_visbuf2(\" num \",\"\n\t\t\t\t\tpointer = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcall = call \"%p\"\n\t\t\t\t\tcomma = comma \"(const void *)\"\n\t\t\t\t}\n\t\t\t} else if (argcount != 0) {\n\t\t\t\tif ( argtype == \"int\" || argtype == \"short\" ) {\n\t\t\t\t\tcall = call \"%d\"\n\t\t\t\t\targtype = \"\"\n\t\t\t\t} else if ( argtype != \"\" ) {\n\t\t\t\t\tcall = call \"%s\"\n\t\t\t\t\tcomma = comma \"_trace\" argtype \"2(\" num \",\"\n\t\t\t\t\tif (argtype == \"attr\") {\n\t\t\t\t\t\targcast = \"(chtype)\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcall = call \"%#lx\"\n\t\t\t\t\tcomma = comma \"(long)\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch == \",\") {\n\t\t\t\targs = args comma \"a\" ++num;\n\t\t\t} else if ( argcount != 0 ) {\n\t\t\t\tif ( va_list ) {\n\t\t\t\t\targs = args comma \"\\\"va_list\\\"\"\n\t\t\t\t} else if ( varargs ) {\n\t\t\t\t\targs = args comma \"\\\"...\\\"\"\n\t\t\t\t} else {\n\t\t\t\t\targs = args comma argcast \"z\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tcall = call ch\n\t\t\tif (pointer == 0 && argcount != 0 && argtype != \"\" )\n\t\t\t\targs = args \")\"\n\t\t\tif (args != \"\")\n\t\t\t\tcomma = \", \"\n\t\t\tpointer = 0;\n\t\t\targtype = \"\"\n\t\t}\n\t\tif ( i == myfunc || ch == \"(\" )\n\t\t\tcall = call ch\n\t}\n\tcall = call \"\\\")\"\n\tif (args != \"\")\n\t\tcall = call \", \" args\n\tcall = call \")); \"\n\n\tif (dotrace)\n\t\tprintf \"%s\\n\\t@@\", call\n\n\tif (match($0, \"^void\")) {\n\t\tcall = \"\"\n\t} else if (dotrace) {\n\t\tcall = sprintf(\"return%s( \", returnType);\n\t\tif (returnCast != \"\") {\n\t\t\tcall = call returnCast;\n\t\t}\n\t} else {\n\t\tcall = \"@@return \";\n\t}\n\n\tcall = call $myfunc \"(\";\n\tfor (i = 1; i < argcount; i++) {\n\t\tif (i != 1)\n\t\t\tcall = call \", \";\n\t\tcall = call \"a\" i;\n\t}\n\tif ( argcount != 0 && $check != \"...\" ) {\n\t\tif (argcount != 1)\n\t\t\tcall = call \", \";\n\t\tcall = call \"z\";\n\t}\n\tif (!match($0, \"^void\"))\n\t\tcall = call \") \";\n\tif (dotrace) {\n\t\tcall = call \")\";\n\t}\n\tprint call \";\"\n\n\tif (match($0, \"^void\"))\n\t\tprint \"@@returnVoid;\"\n\tprint \"}\";\n}\nEOF1\n\ncat >$AW2 <<EOF1\nBEGIN\t\t{\n\t\tprintf \"/* This file was generated by $0 $USE */\\n\"\n\t\tprint \"\"\n\t\tprint \"/*\"\n\t\tprint \" * DO NOT EDIT THIS FILE BY HAND!\"\n\t\tif ( \"$USE\" == \"generated\" ) {\n\t\t\tprint \" *\"\n\t\t\tprint \" * This is a file of trivial functions generated from macro\"\n\t\t\tprint \" * definitions in curses.h to satisfy the XSI Curses requirement\"\n\t\t\tprint \" * that every macro also exist as a callable function.\"\n\t\t\tprint \" *\"\n\t\t\tprint \" * It will never be linked unless you call one of the entry\"\n\t\t\tprint \" * points with its normal macro definition disabled.  In that\"\n\t\t\tprint \" * case, if you have no shared libraries, it will indirectly\"\n\t\t\tprint \" * pull most of the rest of the library into your link image.\"\n\t\t}\n\t\tprint \" */\"\n\t\tprint \"#define NCURSES_ATTR_T int\"\n\t\tprint \"#include <ncurses_cfg.h>\"\n\t\tprint \"\"\n\t\tprint \"#undef NCURSES_NOMACROS\t/* _this_ file uses macros */\"\n\t\tprint \"#define NCURSES_NOMACROS 1\"\n\t\tprint \"\"\n\t\tprint \"#include <curses.priv.h>\"\n\t\tprint \"\"\n\t\t}\n/^DECLARATIONS/\t{start = 1; next;}\n\t\t{\n\t\tif (start) {\n\t\t\tif ( \"$USE\" == \"generated\" ) {\n\t\t\t\tprint \\$0;\n\t\t\t} else if ( \\$0 ~ /^[{}]?\\$/ ) {\n\t\t\t\tprint \\$0;\n\t\t\t} else if ( \\$0 ~ /;/ ) {\n\t\t\t\tprint \\$0;\n\t\t\t} else {\n\t\t\t\tcalls[start] = \\$0;\n\t\t\t\tprint \\$0;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t}\n\t\t}\nEND\t\t{\n\t\tif ( \"$USE\" != \"generated\" ) {\n\t\t\tprint \"int main(void)\"\n\t\t\tprint \"{\"\n\t\t\tfor (n = 1; n < start; ++n) {\n\t\t\t\tvalue = calls[n];\n\t\t\t\tif ( value !~ /P_POUNDC/ ) {\n\t\t\t\t\tgsub(/[ \\t]+/,\" \",value);\n\t\t\t\t\tsub(/^[0-9a-zA-Z_]+ /,\"\",value);\n\t\t\t\t\tsub(/^[*][ \\t]*/,\"\",value);\n\t\t\t\t\tgsub(\"struct[ \\t]*[0-9a-zA-Z_]+[ \\t]*[*]\",\"\",value);\n\t\t\t\t\tgsub(/[0-9a-zA-Z_]+[ \\t]*[*][ \\t]*/,\"\",value);\n\t\t\t\t\tgsub(/ (const) /,\" \",value);\n\t\t\t\t\tgsub(/ (int|short|attr_t|chtype|wchar_t|NCURSES_BOOL|NCURSES_OUTC|NCURSES_OUTC_sp|va_list) /,\" \",value);\n\t\t\t\t\tgsub(/ void /,\"\",value);\n\t\t\t\t\tsub(/^/,\"call_\",value);\n\t\t\t\t\tgsub(/ (a[0-9]|z) /, \" 0 \", value);\n\t\t\t\t\tgsub(/ int[ \\t]*[(][^)]+[)][(][^)]+[)]/, \"0\", value);\n\t\t\t\t\tprintf \"\\t%s;\\n\", value;\n\t\t\t\t} else {\n\t\t\t\t\tprint value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprint \"\treturn 0;\"\n\t\t\tprint \"}\"\n\t\t}\n\t\t}\nEOF1\n\ncat >$TMP <<EOF\n#include <ncurses_cfg.h>\n#undef NCURSES_NOMACROS\n#include <curses.h>\n#include <term.h>\n#include <unctrl.h>\n\nDECLARATIONS\n\nEOF\n\nsed -n -f $ED1 \\\n| sed -e 's/NCURSES_EXPORT(\\(.*\\)) \\(.*\\) (\\(.*\\))/\\1 \\2(\\3)/' \\\n| sed -f $ED2 \\\n| \"$AWK\" -f $AW1 using=\"$USE\" \\\n| sed \\\n\t-e 's/ [ ]*$//g' \\\n\t-e 's/^\\([a-zA-Z_][a-zA-Z_]*[ *]*\\)/\\1 gen_/' \\\n\t-e 's/gen_$//' \\\n\t-e 's/  / /g' >>$TMP\n\n$preprocessor $TMP 2>/dev/null \\\n| sed \\\n\t-e 's/  / /g' \\\n\t-e 's/^ //' \\\n\t-e 's/_Bool/NCURSES_BOOL/g' \\\n| \"$AWK\" -f $AW2 \\\n| sed -f $ED3 \\\n| sed \\\n\t-e 's/^.*T_CALLED.*returnCode( \\([a-z].*) \\));/\treturn \\1;/' \\\n\t-e 's/^.*T_CALLED.*returnCode( \\((wmove.*) \\));/\treturn \\1;/' \\\n\t-e 's/gen_//' \\\n\t-e 's/^[ \t]*#/#/' \\\n\t-e '/#ident/d' \\\n\t-e '/#line/d' \\\n| sed -f $ED4\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}