{
  "module_name": "MKkeyname.awk",
  "hash_id": "70e1b1d2405dbe635047c2cab7f7d7d8584025b28ca8fe12776ecfa3b6aa0bdd",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/MKkeyname.awk",
  "human_readable_source": "# $Id: MKkeyname.awk,v 1.51 2020/02/02 23:34:34 tom Exp $\n##############################################################################\n# Copyright 2020 Thomas E. Dickey                                            #\n# Copyright 1998-2016,2017 Free Software Foundation, Inc.                    #\n#                                                                            #\n# Permission is hereby granted, free of charge, to any person obtaining a    #\n# copy of this software and associated documentation files (the \"Software\"), #\n# to deal in the Software without restriction, including without limitation  #\n# the rights to use, copy, modify, merge, publish, distribute, distribute    #\n# with modifications, sublicense, and/or sell copies of the Software, and to #\n# permit persons to whom the Software is furnished to do so, subject to the  #\n# following conditions:                                                      #\n#                                                                            #\n# The above copyright notice and this permission notice shall be included in #\n# all copies or substantial portions of the Software.                        #\n#                                                                            #\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR #\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   #\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    #\n# THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER      #\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    #\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        #\n# DEALINGS IN THE SOFTWARE.                                                  #\n#                                                                            #\n# Except as contained in this notice, the name(s) of the above copyright     #\n# holders shall not be used in advertising or otherwise to promote the sale, #\n# use or other dealings in this Software without prior written               #\n# authorization.                                                             #\n##############################################################################\nBEGIN {\n\tprint \"/* generated by MKkeyname.awk */\"\n\tprint \"\"\n\tprint \"#include <curses.priv.h>\"\n\tprint \"#include <tic.h>\"\n\tprint \"\"\n\tfirst = 1;\n}\n\n/^[^#]/ {\n\t\tif (bigstrings) {\n\t\t\tif (first)  {\n\t\t\t\tprint \"struct kn { short offset; int code; };\"\n\t\t\t\tprint \"static const struct kn _nc_key_names[] = {\"\n\t\t\t}\n\t\t\tprintf \"\\t{ %d, %s },\\n\", offset, $1\n\t\t\toffset += length($1) + 1\n\t\t\tnames = names\"\\n\\t\\\"\"$1\"\\\\0\\\"\"\n\t\t} else {\n\t\t\tif (first) {\n\t\t\t\tprint \"struct kn { const char *name; int code; };\"\n\t\t\t\tprint \"static const struct kn _nc_key_names[] = {\"\n\t\t\t}\n\t\t\tprintf \"\\t{ \\\"%s\\\", %s },\\n\", $1, $1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\nEND {\n\tif (bigstrings) {\n\t\tprintf \"\\t{ -1, 0 }};\\n\"\n\t\tprint \"\"\n\t\tprint \"static const char key_names[] = \"names\";\"\n\t} else {\n\t\tprintf \"\\t{ 0, 0 }};\\n\"\n\t}\n\tprint \"\"\n\tprint \"#define SIZEOF_TABLE 256\"\n\tprint \"#define MyTable _nc_globals.keyname_table\"\n\tprint \"#define MyInit  _nc_globals.init_keyname\"\n\tprint \"\"\n\tprint \"NCURSES_EXPORT(NCURSES_CONST char *)\"\n\tprint \"safe_keyname (SCREEN *sp, int c)\"\n\tprint \"{\"\n\tprint \"\tchar name[20];\"\n\tprint \"\tNCURSES_CONST char *result = 0;\"\n\tprint \"\"\n\tprint \"\tif (c == -1) {\"\n\tprint \"\t\tresult = \\\"-1\\\";\"\n\tprint \"\t} else {\"\n\tprint \"\t\tint i;\"\n\tif (bigstrings) {\n\t\tprint \"\t\tfor (i = 0; _nc_key_names[i].offset != -1; i++) {\"\n\t\tprint \"\t\t\tif (_nc_key_names[i].code == c) {\"\n\t\tprint \"\t\t\t\tresult = (NCURSES_CONST char *)key_names + _nc_key_names[i].offset;\"\n\t\tprint \"\t\t\t\tbreak;\"\n\t\tprint \"\t\t\t}\"\n\t\tprint \"\t\t}\"\n\t} else {\n\t\tprint \"\t\tfor (i = 0; _nc_key_names[i].name != 0; i++) {\"\n\t\tprint \"\t\t\tif (_nc_key_names[i].code == c) {\"\n\t\tprint \"\t\t\t\tresult = (NCURSES_CONST char *)_nc_key_names[i].name;\"\n\t\tprint \"\t\t\t\tbreak;\"\n\t\tprint \"\t\t\t}\"\n\t\tprint \"\t\t}\"\n\t}\n\tprint \"\"\n\tprint \"\t\tif (result == 0 && (c >= 0 && c < SIZEOF_TABLE)) {\"\n\tprint \"\t\t\tif (MyTable == 0)\"\n\tprint \"\t\t\t\tMyTable = typeCalloc(char *, SIZEOF_TABLE);\"\n\tprint \"\"\n\tprint \"\t\t\tif (MyTable != 0) {\"\n\tprint \"\t\t\t\tint m_prefix = (sp == 0 || sp->_use_meta);\"\n\tprint \"\"\n\tprint \"\t\t\t\t/* if sense of meta() changed, discard cached data */\"\n\tprint \"\t\t\t\tif (MyInit != (m_prefix + 1)) {\"\n\tprint \"\t\t\t\t\tMyInit = m_prefix + 1;\"\n\tprint \"\t\t\t\t\tfor (i = 0; i < SIZEOF_TABLE; ++i) {\"\n\tprint \"\t\t\t\t\t\tif (MyTable[i]) {\"\n\tprint \"\t\t\t\t\t\t\tFreeAndNull(MyTable[i]);\"\n\tprint \"\t\t\t\t\t\t}\"\n\tprint \"\t\t\t\t\t}\"\n\tprint \"\t\t\t\t}\"\n\tprint \"\"\n\tprint \"\t\t\t\t/* create and cache result as needed */\"\n\tprint \"\t\t\t\tif (MyTable[c] == 0) {\"\n\tprint \"\t\t\t\t\tint cc = c;\"\n\tprint \"\t\t\t\t\tchar *p = name;\"\n\tprint \"#define P_LIMIT (sizeof(name) - (size_t) (p - name))\"\n\tprint \"\t\t\t\t\tif (cc >= 128 && m_prefix) {\"\n\tprint \"\t\t\t\t\t\t_nc_STRCPY(p, \\\"M-\\\", P_LIMIT);\"\n\tprint \"\t\t\t\t\t\tp += 2;\"\n\tprint \"\t\t\t\t\t\tcc -= 128;\"\n\tprint \"\t\t\t\t\t}\"\n\tprint \"\t\t\t\t\tif (cc < 32)\"\n\tprint \"\t\t\t\t\t\t_nc_SPRINTF(p, _nc_SLIMIT(P_LIMIT) \\\"^%c\\\", cc + '@');\"\n\tprint \"\t\t\t\t\telse if (cc == 127)\"\n\tprint \"\t\t\t\t\t\t_nc_STRCPY(p, \\\"^?\\\", P_LIMIT);\"\n\tprint \"\t\t\t\t\telse\"\n\tprint \"\t\t\t\t\t\t_nc_SPRINTF(p, _nc_SLIMIT(P_LIMIT) \\\"%c\\\", cc);\"\n\tprint \"\t\t\t\t\tMyTable[c] = strdup(name);\"\n\tprint \"\t\t\t\t}\"\n\tprint \"\t\t\t\tresult = MyTable[c];\"\n\tprint \"\t\t\t}\"\n\tprint \"#if NCURSES_EXT_FUNCS && NCURSES_XNAMES\"\n\tprint \"\t\t} else if (result == 0 && HasTerminal(sp)) {\"\n\tprint \"\t\t\tint j, k;\"\n\tprint \"\t\t\tchar * bound;\"\n\tprint \"\t\t\tTERMTYPE2 *tp = &TerminalType(TerminalOf(sp));\"\n\tprint \"\t\t\tunsigned save_trace = _nc_tracing;\"\n\tprint \"\"\n\tprint \"\t\t\t_nc_tracing = 0;\t/* prevent recursion via keybound() */\"\n\tprint \"\t\t\tfor (j = 0; (bound = NCURSES_SP_NAME(keybound)(NCURSES_SP_ARGx c, j)) != 0; ++j) {\"\n\tprint \"\t\t\t\tfor(k = STRCOUNT; k < (int) NUM_STRINGS(tp);  k++) {\"\n\tprint \"\t\t\t\t\tif (tp->Strings[k] != 0 && !strcmp(bound, tp->Strings[k])) {\"\n\tprint \"\t\t\t\t\t\tresult = ExtStrname(tp, k, strnames);\"\n\tprint \"\t\t\t\t\t\tbreak;\"\n\tprint \"\t\t\t\t\t}\"\n\tprint \"\t\t\t\t}\"\n\tprint \"\t\t\t\tfree(bound);\"\n\tprint \"\t\t\t\tif (result != 0)\"\n\tprint \"\t\t\t\t\tbreak;\"\n\tprint \"\t\t\t}\"\n\tprint \"\t\t\t_nc_tracing = save_trace;\"\n\tprint \"#endif\"\n\tprint \"\t\t}\"\n\tprint \"\t}\"\n\tprint \"\treturn result;\"\n\tprint \"}\"\n\tprint \"\"\n\tprint \"NCURSES_EXPORT(NCURSES_CONST char *)\"\n\tprint \"keyname (int c)\"\n\tprint \"{\"\n\tprint \"\treturn safe_keyname (CURRENT_SCREEN, c);\"\n\tprint \"}\"\n\tprint \"\"\n\tprint \"#if NO_LEAKS\"\n\tprint \"void _nc_keyname_leaks(void)\"\n\tprint \"{\"\n\tprint \"\tif (MyTable != 0) {\"\n\tprint \"\t\tint j;\"\n\tprint \"\t\tfor (j = 0; j < SIZEOF_TABLE; ++j) {\"\n\tprint \"\t\t\tFreeIfNeeded(MyTable[j]);\"\n\tprint \"\t\t}\"\n\tprint \"\t\tFreeAndNull(MyTable);\"\n\tprint \"\t}\"\n\tprint \"}\"\n\tprint \"#endif /* NO_LEAKS */\"\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}