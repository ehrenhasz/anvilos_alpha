{
  "module_name": "lib_mouse.c",
  "hash_id": "34e6c6df90c1f4be5da1fe3784483ced4d271429bdc4de3632d08994dd456be3",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_mouse.c",
  "human_readable_source": " \n\n \n\n \n\n#ifdef __EMX__\n#  include <io.h>\n#  define  INCL_DOS\n#  define  INCL_VIO\n#  define  INCL_KBD\n#  define  INCL_MOU\n#  define  INCL_DOSPROCESS\n#  include <os2.h>\t\t \n#endif\n\n#include <curses.priv.h>\n\n#ifndef CUR\n#define CUR SP_TERMTYPE\n#endif\n\nMODULE_ID(\"$Id: lib_mouse.c,v 1.197 2022/08/13 14:13:12 tom Exp $\")\n\n#include <tic.h>\n\n#if USE_GPM_SUPPORT\n#include <linux/keyboard.h>\t \n\n#ifdef HAVE_LIBDL\n \n#include <dlfcn.h>\n\n#ifdef RTLD_NOW\n#define my_RTLD RTLD_NOW\n#else\n#ifdef RTLD_LAZY\n#define my_RTLD RTLD_LAZY\n#else\nmake an error\n#endif\n#endif\t\t\t\t \n#endif\t\t\t\t \n\n#endif\t\t\t\t \n\n#if USE_SYSMOUSE\n#undef buttons\t\t\t \n#undef mouse_info\t\t \n#include <osreldate.h>\n#if defined(__DragonFly_version) || (defined(__FreeBSD__) && (__FreeBSD_version >= 400017))\n#include <sys/consio.h>\n#include <sys/fbio.h>\n#else\n#include <machine/console.h>\n#endif\n#endif\t\t\t\t \n\n#if USE_KLIBC_MOUSE\n#include <sys/socket.h>\n#define pipe(handles) socketpair(AF_LOCAL, SOCK_STREAM, 0, handles)\n#define DosWrite(hfile, pbuffer, cbwrite, pcbactual) \\\n\t\twrite(hfile, pbuffer, cbwrite)\n#define DosExit(action, result )\t \n#define DosCreateThread(ptid, pfn, param, flag, cbStack) \\\n\t\t(*(ptid) = _beginthread(pfn, NULL, cbStack, \\\n\t\t\t\t\t(void *)param), (*(ptid) == -1))\n#endif\n\n#define MY_TRACE TRACE_ICALLS|TRACE_IEVENT\n\n#define\tMASK_RELEASE(x)\t\t(mmask_t) NCURSES_MOUSE_MASK(x, 001)\n#define\tMASK_PRESS(x)\t\t(mmask_t) NCURSES_MOUSE_MASK(x, 002)\n#define\tMASK_CLICK(x)\t\t(mmask_t) NCURSES_MOUSE_MASK(x, 004)\n#define\tMASK_DOUBLE_CLICK(x)\t(mmask_t) NCURSES_MOUSE_MASK(x, 010)\n#define\tMASK_TRIPLE_CLICK(x)\t(mmask_t) NCURSES_MOUSE_MASK(x, 020)\n#define\tMASK_RESERVED_EVENT(x)\t(mmask_t) NCURSES_MOUSE_MASK(x, 040)\n\n#if NCURSES_MOUSE_VERSION == 1\n\n#define BUTTON_CLICKED        (BUTTON1_CLICKED        | BUTTON2_CLICKED        | BUTTON3_CLICKED        | BUTTON4_CLICKED)\n#define BUTTON_PRESSED        (BUTTON1_PRESSED        | BUTTON2_PRESSED        | BUTTON3_PRESSED        | BUTTON4_PRESSED)\n#define BUTTON_RELEASED       (BUTTON1_RELEASED       | BUTTON2_RELEASED       | BUTTON3_RELEASED       | BUTTON4_RELEASED)\n#define BUTTON_DOUBLE_CLICKED (BUTTON1_DOUBLE_CLICKED | BUTTON2_DOUBLE_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON4_DOUBLE_CLICKED)\n#define BUTTON_TRIPLE_CLICKED (BUTTON1_TRIPLE_CLICKED | BUTTON2_TRIPLE_CLICKED | BUTTON3_TRIPLE_CLICKED | BUTTON4_TRIPLE_CLICKED)\n\n#define MAX_BUTTONS  4\n\n#else\n\n#define BUTTON_CLICKED        (BUTTON1_CLICKED        | BUTTON2_CLICKED        | BUTTON3_CLICKED        | BUTTON4_CLICKED        | BUTTON5_CLICKED)\n#define BUTTON_PRESSED        (BUTTON1_PRESSED        | BUTTON2_PRESSED        | BUTTON3_PRESSED        | BUTTON4_PRESSED        | BUTTON5_PRESSED)\n#define BUTTON_RELEASED       (BUTTON1_RELEASED       | BUTTON2_RELEASED       | BUTTON3_RELEASED       | BUTTON4_RELEASED       | BUTTON5_RELEASED)\n#define BUTTON_DOUBLE_CLICKED (BUTTON1_DOUBLE_CLICKED | BUTTON2_DOUBLE_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON4_DOUBLE_CLICKED | BUTTON5_DOUBLE_CLICKED)\n#define BUTTON_TRIPLE_CLICKED (BUTTON1_TRIPLE_CLICKED | BUTTON2_TRIPLE_CLICKED | BUTTON3_TRIPLE_CLICKED | BUTTON4_TRIPLE_CLICKED | BUTTON5_TRIPLE_CLICKED)\n\n#if NCURSES_MOUSE_VERSION == 2\n#define MAX_BUTTONS  5\n#else\n#define MAX_BUTTONS  11\n#endif\n\n#endif\n\n#define INVALID_EVENT\t-1\n#define NORMAL_EVENT\t0\n\n#define ValidEvent(ep) ((ep)->id != INVALID_EVENT)\n#define Invalidate(ep) (ep)->id = INVALID_EVENT\n\n#if USE_GPM_SUPPORT\n\n#ifndef LIBGPM_SONAME\n#define LIBGPM_SONAME \"libgpm.so\"\n#endif\n\n#define GET_DLSYM(name) (my_##name = (TYPE_##name) dlsym(sp->_dlopen_gpm, #name))\n\n#endif\t\t\t\t \n\nstatic bool _nc_mouse_parse(SCREEN *, int);\nstatic void _nc_mouse_resume(SCREEN *);\nstatic void _nc_mouse_wrap(SCREEN *);\n\n \n\n#define FirstEV(sp)\t((sp)->_mouse_events)\n#define LastEV(sp)\t((sp)->_mouse_events + EV_MAX - 1)\n\n#undef  NEXT\n#define NEXT(ep)\t((ep >= LastEV(SP_PARM)) \\\n\t\t\t ? FirstEV(SP_PARM) \\\n\t\t\t : ep + 1)\n\n#undef  PREV\n#define PREV(ep)\t((ep <= FirstEV(SP_PARM)) \\\n\t\t\t ? LastEV(SP_PARM) \\\n\t\t\t : ep - 1)\n\n#define IndexEV(sp, ep)\t(ep - FirstEV(sp))\n\n#define RunParams(sp, eventp, runp) \\\n\t\t(long) IndexEV(sp, runp), \\\n\t\t(long) (IndexEV(sp, eventp) + (EV_MAX - 1)) % EV_MAX\n\n#ifdef TRACE\nstatic void\n_trace_slot(SCREEN *sp, const char *tag)\n{\n    MEVENT *ep;\n\n    _tracef(\"%s\", tag);\n\n    for (ep = FirstEV(sp); ep <= LastEV(sp); ep++)\n\t_tracef(\"mouse event queue slot %ld = %s\",\n\t\t(long) IndexEV(sp, ep),\n\t\t_nc_tracemouse(sp, ep));\n}\n#endif\n\n#if USE_EMX_MOUSE\n\n#  define TOP_ROW          0\n#  define LEFT_COL         0\n\n#  define M_FD(sp) sp->_mouse_fd\n\nstatic void\nwrite_event(SCREEN *sp, int down, int button, int x, int y)\n{\n    char buf[6];\n    unsigned long ignore;\n\n    _nc_STRCPY(buf, \"\\033[M\", sizeof(buf));\t \n    buf[3] = ' ' + (button - 1) + (down ? 0 : 0x40);\n    buf[4] = ' ' + x - LEFT_COL + 1;\n    buf[5] = ' ' + y - TOP_ROW + 1;\n    DosWrite(sp->_emxmouse_wfd, buf, 6, &ignore);\n}\n\nstatic void\n#if USE_KLIBC_MOUSE\nmouse_server(void *param)\n#else\nmouse_server(unsigned long param)\n#endif\n{\n    SCREEN *sp = (SCREEN *) param;\n    unsigned short fWait = MOU_WAIT;\n     \n    MOUEVENTINFO mouev;\n    HMOU hmou;\n    unsigned short mask = MOUSE_BN1_DOWN | MOUSE_BN2_DOWN | MOUSE_BN3_DOWN;\n    int nbuttons = 3;\n    int oldstate = 0;\n    char err[80];\n    unsigned long rc;\n\n     \n    if (MouOpen(NULL, &hmou) == 0) {\n\trc = MouSetEventMask(&mask, hmou);\n\tif (rc) {\t\t \n\t    mask = MOUSE_BN1_DOWN | MOUSE_BN2_DOWN;\n\t    rc = MouSetEventMask(&mask, hmou);\n\t    nbuttons = 2;\n\t}\n\tif (rc == 0 && MouDrawPtr(hmou) == 0) {\n\t    for (;;) {\n\t\t \n\t\trc = MouReadEventQue(&mouev, &fWait, hmou);\n\t\tif (rc) {\n\t\t    _nc_SPRINTF(err, _nc_SLIMIT(sizeof(err))\n\t\t\t\t\"Error reading mouse queue, rc=%lu.\\r\\n\", rc);\n\t\t    break;\n\t\t}\n\t\tif (!sp->_emxmouse_activated)\n\t\t    goto finish;\n\n\t\t \n\t\tif ((mouev.fs ^ oldstate) & MOUSE_BN1_DOWN)\n\t\t    write_event(sp, mouev.fs & MOUSE_BN1_DOWN,\n\t\t\t\tsp->_emxmouse_buttons[1], mouev.col, mouev.row);\n\t\tif ((mouev.fs ^ oldstate) & MOUSE_BN2_DOWN)\n\t\t    write_event(sp, mouev.fs & MOUSE_BN2_DOWN,\n\t\t\t\tsp->_emxmouse_buttons[3], mouev.col, mouev.row);\n\t\tif ((mouev.fs ^ oldstate) & MOUSE_BN3_DOWN)\n\t\t    write_event(sp, mouev.fs & MOUSE_BN3_DOWN,\n\t\t\t\tsp->_emxmouse_buttons[2], mouev.col, mouev.row);\n\n\t      finish:\n\t\toldstate = mouev.fs;\n\t    }\n\t} else {\n\t    _nc_SPRINTF(err, _nc_SLIMIT(sizeof(err))\n\t\t\t\"Error setting event mask, buttons=%d, rc=%lu.\\r\\n\",\n\t\t\tnbuttons, rc);\n\t}\n\n\tDosWrite(2, err, strlen(err), &rc);\n\tMouClose(hmou);\n    }\n    DosExit(EXIT_THREAD, 0L);\n}\n\n#endif  \n\n#if USE_SYSMOUSE\nstatic void\nsysmouse_server(SCREEN *sp)\n{\n    struct mouse_info the_mouse;\n    MEVENT *work;\n\n    the_mouse.operation = MOUSE_GETINFO;\n    if (sp != 0\n\t&& sp->_mouse_fd >= 0\n\t&& sp->_sysmouse_tail < FIFO_SIZE\n\t&& ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse) != -1) {\n\n\tif (sp->_sysmouse_head > sp->_sysmouse_tail) {\n\t    sp->_sysmouse_tail = 0;\n\t    sp->_sysmouse_head = 0;\n\t}\n\twork = &(sp->_sysmouse_fifo[sp->_sysmouse_tail]);\n\tmemset(work, 0, sizeof(*work));\n\twork->id = NORMAL_EVENT;\t \n\n\tsp->_sysmouse_old_buttons = sp->_sysmouse_new_buttons;\n\tsp->_sysmouse_new_buttons = the_mouse.u.data.buttons & 0x7;\n\n\tif (sp->_sysmouse_new_buttons) {\n\t    if (sp->_sysmouse_new_buttons & 1)\n\t\twork->bstate |= BUTTON1_PRESSED;\n\t    if (sp->_sysmouse_new_buttons & 2)\n\t\twork->bstate |= BUTTON2_PRESSED;\n\t    if (sp->_sysmouse_new_buttons & 4)\n\t\twork->bstate |= BUTTON3_PRESSED;\n\t} else {\n\t    if (sp->_sysmouse_old_buttons & 1)\n\t\twork->bstate |= BUTTON1_RELEASED;\n\t    if (sp->_sysmouse_old_buttons & 2)\n\t\twork->bstate |= BUTTON2_RELEASED;\n\t    if (sp->_sysmouse_old_buttons & 4)\n\t\twork->bstate |= BUTTON3_RELEASED;\n\t}\n\n\t \n\tthe_mouse.operation = MOUSE_HIDE;\n\tioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse);\n\tthe_mouse.operation = MOUSE_SHOW;\n\tioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse);\n\n\t \n\tif (sp->_sysmouse_new_buttons != sp->_sysmouse_old_buttons) {\n\t    sp->_sysmouse_tail += 1;\n\t}\n\twork->x = the_mouse.u.data.x / sp->_sysmouse_char_width;\n\twork->y = the_mouse.u.data.y / sp->_sysmouse_char_height;\n    }\n}\n\nstatic void\nhandle_sysmouse(int sig GCC_UNUSED)\n{\n    sysmouse_server(CURRENT_SCREEN);\n}\n#endif  \n\n#ifndef USE_TERM_DRIVER\n#define xterm_kmous \"\\033[M\"\n\nstatic void\ninit_xterm_mouse(SCREEN *sp)\n{\n    sp->_mouse_type = M_XTERM;\n    sp->_mouse_format = MF_X10;\n    sp->_mouse_xtermcap = tigetstr(\"XM\");\n    if (VALID_STRING(sp->_mouse_xtermcap)) {\n\tchar *code = strstr(sp->_mouse_xtermcap, \"[?\");\n\tif (code != 0) {\n\t    code += 2;\n\t    while ((*code >= '0') && (*code <= '9')) {\n\t\tchar *next = code;\n\t\twhile ((*next >= '0') && (*next <= '9')) {\n\t\t    ++next;\n\t\t}\n\t\tif (!strncmp(code, \"1006\", (size_t) (next - code))) {\n\t\t    sp->_mouse_format = MF_SGR1006;\n\t\t}\n#ifdef EXP_XTERM_1005\n\t\tif (!strncmp(code, \"1005\", (size_t) (next - code))) {\n\t\t    sp->_mouse_format = MF_XTERM_1005;\n\t\t}\n#endif\n\t\tif (*next == ';') {\n\t\t    while (*next == ';') {\n\t\t\t++next;\n\t\t    }\n\t\t    code = next;\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    } else {\n\tint code = tigetnum(\"XM\");\n\tswitch (code) {\n#ifdef EXP_XTERM_1005\n\tcase 1005:\n\t     \n\t    sp->_mouse_xtermcap = \"\\033[?1005;1000%?%p1%{1}%=%th%el%;\";\n\t    sp->_mouse_format = MF_XTERM_1005;\n\t    break;\n#endif\n\tcase 1006:\n\t     \n\t    sp->_mouse_xtermcap = \"\\033[?1006;1000%?%p1%{1}%=%th%el%;\";\n\t    sp->_mouse_format = MF_SGR1006;\n\t    break;\n\tdefault:\n\t    sp->_mouse_xtermcap = \"\\033[?1000%?%p1%{1}%=%th%el%;\";\n\t    break;\n\t}\n    }\n}\n#endif\n\nstatic void\nenable_xterm_mouse(SCREEN *sp, int enable)\n{\n#if USE_EMX_MOUSE\n    sp->_emxmouse_activated = enable;\n#else\n    NCURSES_PUTP2(\"xterm-mouse\", TIPARM_1(sp->_mouse_xtermcap, enable));\n#endif\n    sp->_mouse_active = enable;\n}\n\n#if USE_GPM_SUPPORT\nstatic bool\nallow_gpm_mouse(SCREEN *sp GCC_UNUSED)\n{\n    bool result = FALSE;\n\n#if USE_WEAK_SYMBOLS\n     \n    if ((Gpm_Wgetch) != 0) {\n\tif (!sp->_mouse_gpm_loaded) {\n\t    T((\"GPM library was already dlopen'd, not by us\"));\n\t}\n    } else\n#endif\n\t \n    if (NC_ISATTY(fileno(stdout))) {\n\tconst char *list = getenv(\"NCURSES_GPM_TERMS\");\n\tconst char *env = getenv(\"TERM\");\n\tif (list != 0) {\n\t    if (env != 0) {\n\t\tresult = _nc_name_match(list, env, \"|:\");\n\t    }\n\t} else {\n\t     \n\t    if (env != 0 && strstr(env, \"linux\") != 0) {\n\t\tresult = TRUE;\n\t    }\n\t}\n    }\n    return result;\n}\n\n#ifdef HAVE_LIBDL\nstatic void\nunload_gpm_library(SCREEN *sp)\n{\n    if (sp->_dlopen_gpm != 0) {\n\tT((\"unload GPM library\"));\n\tsp->_mouse_gpm_loaded = FALSE;\n\tsp->_mouse_fd = -1;\n    }\n}\n\nstatic void\nload_gpm_library(SCREEN *sp)\n{\n    sp->_mouse_gpm_found = FALSE;\n\n     \n    if (sp->_dlopen_gpm != 0) {\n\tsp->_mouse_gpm_found = TRUE;\n\tsp->_mouse_gpm_loaded = TRUE;\n    } else if ((sp->_dlopen_gpm = dlopen(LIBGPM_SONAME, my_RTLD)) != 0) {\n#if (defined(__GNUC__) && (__GNUC__ >= 5)) || defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\"\n#endif\n\tif (GET_DLSYM(gpm_fd) == 0 ||\n\t    GET_DLSYM(Gpm_Open) == 0 ||\n\t    GET_DLSYM(Gpm_Close) == 0 ||\n\t    GET_DLSYM(Gpm_GetEvent) == 0) {\n#if (defined(__GNUC__) && (__GNUC__ >= 5)) || defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n\t    T((\"GPM initialization failed: %s\", dlerror()));\n\t    unload_gpm_library(sp);\n\t    dlclose(sp->_dlopen_gpm);\n\t    sp->_dlopen_gpm = 0;\n\t} else {\n\t    sp->_mouse_gpm_found = TRUE;\n\t    sp->_mouse_gpm_loaded = TRUE;\n\t}\n    }\n}\n#endif  \n\nstatic bool\nenable_gpm_mouse(SCREEN *sp, bool enable)\n{\n    bool result;\n\n    T((T_CALLED(\"enable_gpm_mouse(%d)\"), enable));\n\n    if (enable && !sp->_mouse_active) {\n#ifdef HAVE_LIBDL\n\tif (sp->_mouse_gpm_found && !sp->_mouse_gpm_loaded) {\n\t    load_gpm_library(sp);\n\t}\n#endif\n\tif (sp->_mouse_gpm_loaded) {\n\t    int code;\n\n\t     \n\t    sp->_mouse_gpm_connect.eventMask = GPM_DOWN | GPM_UP;\n\t    sp->_mouse_gpm_connect.defaultMask =\n\t\t(unsigned short) (~(sp->_mouse_gpm_connect.eventMask | GPM_HARD));\n\t    sp->_mouse_gpm_connect.minMod = 0;\n\t    sp->_mouse_gpm_connect.maxMod =\n\t\t(unsigned short) (~((1 << KG_SHIFT) |\n\t\t\t\t    (1 << KG_SHIFTL) |\n\t\t\t\t    (1 << KG_SHIFTR)));\n\t     \n\t    code = my_Gpm_Open(&sp->_mouse_gpm_connect, 0);\n\t    result = (code >= 0);\n\n\t     \n\t    if (code == -2) {\n\t\tmy_Gpm_Close();\n\t    }\n\t} else {\n\t    result = FALSE;\n\t}\n\tsp->_mouse_active = result;\n\tT((\"GPM open %s\", result ? \"succeeded\" : \"failed\"));\n    } else {\n\tif (!enable && sp->_mouse_active) {\n\t     \n\t    my_Gpm_Close();\n\t    sp->_mouse_active = FALSE;\n\t    T((\"GPM closed\"));\n\t}\n\tresult = enable;\n    }\n#ifdef HAVE_LIBDL\n    if (!result) {\n\tunload_gpm_library(sp);\n    }\n#endif\n    returnBool(result);\n}\n#endif  \n\nstatic void\ninitialize_mousetype(SCREEN *sp)\n{\n    T((T_CALLED(\"initialize_mousetype()\")));\n\n     \n#if USE_GPM_SUPPORT\n    if (allow_gpm_mouse(sp)) {\n\tif (!sp->_mouse_gpm_loaded) {\n#ifdef HAVE_LIBDL\n\t    load_gpm_library(sp);\n#else  \n\t    sp->_mouse_gpm_found = TRUE;\n\t    sp->_mouse_gpm_loaded = TRUE;\n#endif\n\t}\n\n\t \n\tif (sp->_mouse_gpm_found && enable_gpm_mouse(sp, TRUE)) {\n\t    sp->_mouse_type = M_GPM;\n\t    sp->_mouse_fd = *(my_gpm_fd);\n\t    T((\"GPM mouse_fd %d\", sp->_mouse_fd));\n\t    returnVoid;\n\t}\n    }\n#endif  \n\n     \n#if USE_EMX_MOUSE\n    if (!sp->_emxmouse_thread\n\t&& strstr(SP_TERMTYPE term_names, \"xterm\") == 0\n\t&& NonEmpty(key_mouse)) {\n\tint handles[2];\n\n\tif (pipe(handles) < 0) {\n\t    perror(\"mouse pipe error\");\n\t    returnVoid;\n\t} else {\n\t    int rc;\n\n\t    if (!sp->_emxmouse_buttons[0]) {\n\t\tconst char *s = getenv(\"MOUSE_BUTTONS_123\");\n\n\t\tsp->_emxmouse_buttons[0] = 1;\n\t\tif (s && strlen(s) >= 3) {\n\t\t    sp->_emxmouse_buttons[1] = s[0] - '0';\n\t\t    sp->_emxmouse_buttons[2] = s[1] - '0';\n\t\t    sp->_emxmouse_buttons[3] = s[2] - '0';\n\t\t} else {\n\t\t    sp->_emxmouse_buttons[1] = 1;\n\t\t    sp->_emxmouse_buttons[2] = 3;\n\t\t    sp->_emxmouse_buttons[3] = 2;\n\t\t}\n\t    }\n\t    sp->_emxmouse_wfd = handles[1];\n\t    M_FD(sp) = handles[0];\n\t     \n\t    setmode(handles[0], O_BINARY);\n\t    setmode(handles[1], O_BINARY);\n\t     \n\t    rc = DosCreateThread((unsigned long *) &sp->_emxmouse_thread,\n\t\t\t\t mouse_server, (long) sp, 0, 8192);\n\t    if (rc) {\n\t\tprintf(\"mouse thread error %d=%#x\", rc, rc);\n\t    } else {\n\t\tsp->_mouse_type = M_XTERM;\n\t    }\n\t    returnVoid;\n\t}\n    }\n#endif  \n\n#if USE_SYSMOUSE\n    {\n\tstatic char dev_tty[] = \"/dev/tty\";\n\tstruct mouse_info the_mouse;\n\tchar *the_device = 0;\n\n\tif (NC_ISATTY(sp->_ifd))\n\t    the_device = ttyname(sp->_ifd);\n\tif (the_device == 0)\n\t    the_device = dev_tty;\n\n\tsp->_mouse_fd = open(the_device, O_RDWR);\n\n\tif (sp->_mouse_fd >= 0) {\n\t     \n\t    signal(SIGUSR2, SIG_IGN);\n\t    the_mouse.operation = MOUSE_MODE;\n\t    the_mouse.u.mode.mode = 0;\n\t    the_mouse.u.mode.signal = SIGUSR2;\n\t    if (ioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse) != -1) {\n\t\tsignal(SIGUSR2, handle_sysmouse);\n\t\tthe_mouse.operation = MOUSE_SHOW;\n\t\tioctl(sp->_mouse_fd, CONS_MOUSECTL, &the_mouse);\n\n#if defined(FBIO_MODEINFO) || defined(CONS_MODEINFO)\t \n\t\t{\n#ifndef FBIO_GETMODE\t\t \n#define FBIO_GETMODE    CONS_GET\n#define FBIO_MODEINFO   CONS_MODEINFO\n#endif  \n\t\t    video_info_t the_video;\n\n\t\t    if (ioctl(sp->_mouse_fd,\n\t\t\t      FBIO_GETMODE,\n\t\t\t      &the_video.vi_mode) != -1\n\t\t\t&& ioctl(sp->_mouse_fd,\n\t\t\t\t FBIO_MODEINFO,\n\t\t\t\t &the_video) != -1) {\n\t\t\tsp->_sysmouse_char_width = the_video.vi_cwidth;\n\t\t\tsp->_sysmouse_char_height = the_video.vi_cheight;\n\t\t    }\n\t\t}\n#endif  \n\n\t\tif (sp->_sysmouse_char_width <= 0)\n\t\t    sp->_sysmouse_char_width = 8;\n\t\tif (sp->_sysmouse_char_height <= 0)\n\t\t    sp->_sysmouse_char_height = 16;\n\t\tsp->_mouse_type = M_SYSMOUSE;\n\t\treturnVoid;\n\t    }\n\t}\n    }\n#endif  \n\n#ifdef USE_TERM_DRIVER\n    CallDriver(sp, td_initmouse);\n#else\n     \n    if (NonEmpty(key_mouse)) {\n\tinit_xterm_mouse(sp);\n    } else if (strstr(SP_TERMTYPE term_names, \"xterm\") != 0) {\n\tif (_nc_add_to_try(&(sp->_keytry), xterm_kmous, KEY_MOUSE) == OK)\n\t    init_xterm_mouse(sp);\n    }\n#endif\n\n    returnVoid;\n}\n\nstatic bool\n_nc_mouse_init(SCREEN *sp)\n \n{\n    bool result = FALSE;\n\n    if (sp != 0) {\n\tif (!sp->_mouse_initialized) {\n\t    int i;\n\n\t    sp->_mouse_initialized = TRUE;\n\n\t    TR(MY_TRACE, (\"_nc_mouse_init() called\"));\n\n\t    sp->_mouse_eventp = FirstEV(sp);\n\t    for (i = 0; i < EV_MAX; i++)\n\t\tInvalidate(sp->_mouse_events + i);\n\n\t    initialize_mousetype(sp);\n\n\t    T((\"_nc_mouse_init() set mousetype to %d\", sp->_mouse_type));\n\t}\n\tresult = sp->_mouse_initialized;\n    }\n    return result;\n}\n\n \nstatic bool\n_nc_mouse_event(SCREEN *sp)\n{\n    MEVENT *eventp = sp->_mouse_eventp;\n    bool result = FALSE;\n\n    (void) eventp;\n\n    switch (sp->_mouse_type) {\n    case M_XTERM:\n\t \n#if USE_EMX_MOUSE\n\t{\n\t    char kbuf[3];\n\n\t    int i, res = read(M_FD(sp), &kbuf, 3);\t \n\t    if (res != 3)\n\t\tprintf(\"Got %d chars instead of 3 for prefix.\\n\", res);\n\t    for (i = 0; i < res; i++) {\n\t\tif (kbuf[i] != key_mouse[i])\n\t\t    printf(\"Got char %d instead of %d for prefix.\\n\",\n\t\t\t   (int) kbuf[i], (int) key_mouse[i]);\n\t    }\n\t    result = TRUE;\n\t}\n#endif  \n\tbreak;\n\n#if USE_GPM_SUPPORT\n    case M_GPM:\n\tif (sp->_mouse_fd >= 0) {\n\t     \n\t    Gpm_Event ev;\n\n\t    switch (my_Gpm_GetEvent(&ev)) {\n\t    case 0:\n\t\t \n\t\tsp->_mouse_fd = -1;\n\t\tbreak;\n\t    case 1:\n\t\t \n\t\teventp->id = NORMAL_EVENT;\n\n\t\teventp->bstate = 0;\n\t\tswitch (ev.type & 0x0f) {\n\t\tcase (GPM_DOWN):\n\t\t    if (ev.buttons & GPM_B_LEFT)\n\t\t\teventp->bstate |= BUTTON1_PRESSED;\n\t\t    if (ev.buttons & GPM_B_MIDDLE)\n\t\t\teventp->bstate |= BUTTON2_PRESSED;\n\t\t    if (ev.buttons & GPM_B_RIGHT)\n\t\t\teventp->bstate |= BUTTON3_PRESSED;\n\t\t    break;\n\t\tcase (GPM_UP):\n\t\t    if (ev.buttons & GPM_B_LEFT)\n\t\t\teventp->bstate |= BUTTON1_RELEASED;\n\t\t    if (ev.buttons & GPM_B_MIDDLE)\n\t\t\teventp->bstate |= BUTTON2_RELEASED;\n\t\t    if (ev.buttons & GPM_B_RIGHT)\n\t\t\teventp->bstate |= BUTTON3_RELEASED;\n\t\t    break;\n\t\tdefault:\n\t\t    eventp->bstate |= REPORT_MOUSE_POSITION;\n\t\t    break;\n\t\t}\n\n\t\teventp->x = ev.x - 1;\n\t\teventp->y = ev.y - 1;\n\t\teventp->z = 0;\n\n\t\t \n\t\tsp->_mouse_eventp = NEXT(eventp);\n\t\tresult = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n#endif\n\n#if USE_SYSMOUSE\n    case M_SYSMOUSE:\n\tif (sp->_sysmouse_head < sp->_sysmouse_tail) {\n\t    *eventp = sp->_sysmouse_fifo[sp->_sysmouse_head];\n\n\t     \n\t    sp->_sysmouse_head += 1;\n\t    if (sp->_sysmouse_head == sp->_sysmouse_tail) {\n\t\tsp->_sysmouse_tail = 0;\n\t\tsp->_sysmouse_head = 0;\n\t    }\n\n\t     \n\t    sp->_mouse_eventp = eventp = NEXT(eventp);\n\t    result = TRUE;\n\t}\n\tbreak;\n#endif  \n\n#ifdef USE_TERM_DRIVER\n    case M_TERM_DRIVER:\n\twhile (sp->_drv_mouse_head < sp->_drv_mouse_tail) {\n\t    *eventp = sp->_drv_mouse_fifo[sp->_drv_mouse_head];\n\n\t     \n\t    sp->_drv_mouse_head += 1;\n\t    if (sp->_drv_mouse_head == sp->_drv_mouse_tail) {\n\t\tsp->_drv_mouse_tail = 0;\n\t\tsp->_drv_mouse_head = 0;\n\t    }\n\n\t     \n\t    sp->_mouse_eventp = eventp = NEXT(eventp);\n\t    result = TRUE;\n\t}\n\tbreak;\n#endif\n\n    case M_NONE:\n\tbreak;\n    }\n\n    return result;\t\t \n}\n\n#if USE_EMX_MOUSE\n#define PRESS_POSITION(n) \\\n    do { \\\n\t    eventp->bstate = MASK_PRESS(n); \\\n\t    sp->_mouse_bstate |= MASK_PRESS(n); \\\n\t    if (button & 0x40) { \\\n\t\t    eventp->bstate = MASK_RELEASE(n); \\\n\t\t    sp->_mouse_bstate &= ~MASK_PRESS(n); \\\n\t    } \\\n    } while (0)\n#else\n#define PRESS_POSITION(n) \\\n    do { \\\n\t    eventp->bstate = (mmask_t) ((sp->_mouse_bstate & MASK_PRESS(n)) \\\n\t\t\t\t    ? REPORT_MOUSE_POSITION \\\n\t\t\t\t    : MASK_PRESS(n)); \\\n\t    sp->_mouse_bstate |= MASK_PRESS(n); \\\n    } while (0)\n#endif\n\nstatic bool\nhandle_wheel(SCREEN *sp, MEVENT * eventp, int button, int wheel)\n{\n    bool result = TRUE;\n\n    switch (button & 3) {\n    case 0:\n\tif (wheel) {\n\t    eventp->bstate = MASK_PRESS(4);\n\t     \n\t} else {\n\t    PRESS_POSITION(1);\n\t}\n\tbreak;\n    case 1:\n\tif (wheel) {\n#if NCURSES_MOUSE_VERSION >= 2\n\t    eventp->bstate = MASK_PRESS(5);\n\t     \n#else\n\t     \n\t    eventp->bstate = REPORT_MOUSE_POSITION;\n#endif\n\t} else {\n\t    PRESS_POSITION(2);\n\t}\n\tbreak;\n    case 2:\n\tPRESS_POSITION(3);\n\tbreak;\n    default:\n\t \n\teventp->bstate = REPORT_MOUSE_POSITION;\n\tresult = FALSE;\n\tbreak;\n    }\n    return result;\n}\n\nstatic bool\ndecode_X10_bstate(SCREEN *sp, MEVENT * eventp, unsigned intro)\n{\n    bool result;\n    int button = 0;\n    int wheel = (intro & 96) == 96;\n\n    eventp->bstate = 0;\n\n    if (intro >= 96) {\n\tif (intro >= 160) {\n\t    button = (int) (intro - 152);\t \n\t} else {\n\t    button = (int) (intro - 92);\t \n\t}\n    } else {\n\tbutton = (intro & 3);\n    }\n\n    if (button > MAX_BUTTONS) {\n\teventp->bstate = REPORT_MOUSE_POSITION;\n    } else if (!handle_wheel(sp, eventp, (int) intro, wheel)) {\n\n\t \n\tif (sp->_mouse_bstate & BUTTON_PRESSED) {\n\t    int b;\n\n\t    eventp->bstate = BUTTON_RELEASED;\n\t    for (b = 1; b <= MAX_BUTTONS; ++b) {\n\t\tif (!(sp->_mouse_bstate & MASK_PRESS(b)))\n\t\t    eventp->bstate &= ~MASK_RELEASE(b);\n\t    }\n\t    sp->_mouse_bstate = 0;\n\t} else {\n\t     \n\t    eventp->bstate = REPORT_MOUSE_POSITION;\n\t}\n    }\n\n    if (intro & 4) {\n\teventp->bstate |= BUTTON_SHIFT;\n    }\n    if (intro & 8) {\n\teventp->bstate |= BUTTON_ALT;\n    }\n    if (intro & 16) {\n\teventp->bstate |= BUTTON_CTRL;\n    }\n    result = (eventp->bstate & REPORT_MOUSE_POSITION) ? TRUE : FALSE;\n    return result;\n}\n\n \nstatic bool\ndecode_xterm_X10(SCREEN *sp, MEVENT * eventp)\n{\n#define MAX_KBUF 3\n    unsigned char kbuf[MAX_KBUF + 1];\n    size_t grabbed;\n    int res;\n    bool result;\n\n    _nc_set_read_thread(TRUE);\n    for (grabbed = 0; grabbed < MAX_KBUF; grabbed += (size_t) res) {\n\n\t \n\tres = (int) read(\n#if USE_EMX_MOUSE\n\t\t\t    (M_FD(sp) >= 0) ? M_FD(sp) : sp->_ifd,\n#else\n\t\t\t    sp->_ifd,\n#endif\n\t\t\t    kbuf + grabbed, (size_t) (MAX_KBUF - (int) grabbed));\n\tif (res == -1)\n\t    break;\n    }\n    _nc_set_read_thread(FALSE);\n    kbuf[MAX_KBUF] = '\\0';\n\n    TR(TRACE_IEVENT,\n       (\"_nc_mouse_inline sees the following xterm data: '%s'\", kbuf));\n\n     \n    eventp->id = NORMAL_EVENT;\n\n    result = decode_X10_bstate(sp, eventp, kbuf[0]);\n\n    eventp->x = (kbuf[1] - ' ') - 1;\n    eventp->y = (kbuf[2] - ' ') - 1;\n\n    return result;\n}\n\n#ifdef EXP_XTERM_1005\n \nstatic bool\ndecode_xterm_1005(SCREEN *sp, MEVENT * eventp)\n{\n    char kbuf[80];\n    size_t grabbed;\n    size_t limit = (sizeof(kbuf) - 1);\n    unsigned coords[2];\n    bool result;\n\n    coords[0] = 0;\n    coords[1] = 0;\n\n    _nc_set_read_thread(TRUE);\n    for (grabbed = 0; grabbed < limit;) {\n\tint res;\n\n\tres = (int) read(\n#if USE_EMX_MOUSE\n\t\t\t    (M_FD(sp) >= 0) ? M_FD(sp) : sp->_ifd,\n#else\n\t\t\t    sp->_ifd,\n#endif\n\t\t\t    (kbuf + grabbed), (size_t) 1);\n\tif (res == -1)\n\t    break;\n\tgrabbed += (size_t) res;\n\tif (grabbed > 1) {\n\t    size_t check = 1;\n\t    int n;\n\n\t    for (n = 0; n < 2; ++n) {\n\t\tint rc;\n\n\t\tif (check >= grabbed)\n\t\t    break;\n\t\trc = _nc_conv_to_utf32(&coords[n], kbuf + check, (unsigned)\n\t\t\t\t       (grabbed - check));\n\t\tif (!rc)\n\t\t    break;\n\t\tcheck += (size_t) rc;\n\t    }\n\t    if (n >= 2)\n\t\tbreak;\n\t}\n    }\n    _nc_set_read_thread(FALSE);\n\n    TR(TRACE_IEVENT,\n       (\"_nc_mouse_inline sees the following xterm data: %s\",\n\t_nc_visbufn(kbuf, (int) grabbed)));\n\n     \n    eventp->id = NORMAL_EVENT;\n\n    result = decode_X10_bstate(sp, eventp, UChar(kbuf[0]));\n\n    eventp->x = (int) (coords[0] - ' ') - 1;\n    eventp->y = (int) (coords[1] - ' ') - 1;\n\n    return result;\n}\n#endif  \n\n \n#define isInter(c) ((c) >= 0x20 && (c) <= 0x2f)\n#define isParam(c) ((c) >= 0x30 && (c) <= 0x3f)\n#define isFinal(c) ((c) >= 0x40 && (c) <= 0x7e)\n\n#define MAX_PARAMS 9\n\ntypedef struct {\n    int nerror;\t\t\t \n    int nparam;\t\t\t \n    int params[MAX_PARAMS];\n    int final;\t\t\t \n} SGR_DATA;\n\nstatic bool\nread_SGR(SCREEN *sp, SGR_DATA * result)\n{\n    char kbuf[80];\t\t \n    int grabbed = 0;\n    int ch = 0;\n    int now = -1;\n    int marker = 1;\n\n    memset(result, 0, sizeof(*result));\n    _nc_set_read_thread(TRUE);\n\n    do {\n\tint res;\n\n\tres = (int) read(\n#if USE_EMX_MOUSE\n\t\t\t    (M_FD(sp) >= 0) ? M_FD(sp) : sp->_ifd,\n#else\n\t\t\t    sp->_ifd,\n#endif\n\t\t\t    (kbuf + grabbed), (size_t) 1);\n\tif (res == -1)\n\t    break;\n\tif ((grabbed + MAX_KBUF) >= (int) sizeof(kbuf)) {\n\t    result->nerror++;\n\t    break;\n\t}\n\tch = UChar(kbuf[grabbed]);\n\tkbuf[grabbed + 1] = 0;\n\tswitch (ch) {\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t    if (marker) {\n\t\t++now;\n\t\tresult->nparam = (now + 1);\n\t    }\n\t    marker = 0;\n\t    result->params[now] = (result->params[now] * 10) + (ch - '0');\n\t    break;\n\tcase ';':\n\t    if (marker) {\n\t\t++now;\n\t\tresult->nparam = (now + 1);\n\t    }\n\t    marker = 1;\n\t    break;\n\tdefault:\n\t    if (ch < 32 || ch > 126) {\n\t\t \n\t\tresult->nerror++;\n\t\tcontinue;\n\t    } else if (isFinal(ch)) {\n\t\tif (marker) {\n\t\t    result->nparam++;\n\t\t}\n\t\tresult->final = ch;\n\t    } else {\n\t\tresult->nerror++;\n\t    }\n\t    break;\n\t}\n\t++grabbed;\n    } while (!isFinal(ch));\n    _nc_set_read_thread(FALSE);\n\n    kbuf[++grabbed] = 0;\n    TR(TRACE_IEVENT,\n       (\"_nc_mouse_inline sees the following xterm data: '%s'\", kbuf));\n    return (grabbed > 0) && (result->nerror == 0);\n}\n\nstatic bool\ndecode_xterm_SGR1006(SCREEN *sp, MEVENT * eventp)\n{\n    SGR_DATA data;\n    bool result = FALSE;\n    if (read_SGR(sp, &data)) {\n\tint b = data.params[0];\n\tint b3 = 1 + (b & 3);\n\tint wheel = ((b & 64) == 64);\n\n\tif (b >= 132) {\n\t    b3 = MAX_BUTTONS + 1;\n\t} else if (b >= 128) {\n\t    b3 = (b - 120);\t \n\t} else if (b >= 64) {\n\t    b3 = (b - 60);\t \n\t}\n\n\teventp->id = NORMAL_EVENT;\n\tif (data.final == 'M') {\n\t    (void) handle_wheel(sp, eventp, b, wheel);\n\t} else if (b3 > MAX_BUTTONS) {\n\t    eventp->bstate = REPORT_MOUSE_POSITION;\n\t} else {\n\t    mmask_t pressed = (mmask_t) NCURSES_MOUSE_MASK(b3, NCURSES_BUTTON_PRESSED);\n\t    mmask_t release = (mmask_t) NCURSES_MOUSE_MASK(b3, NCURSES_BUTTON_RELEASED);\n\t    if (sp->_mouse_bstate & pressed) {\n\t\teventp->bstate = release;\n\t\tsp->_mouse_bstate &= ~pressed;\n\t    } else {\n\t\teventp->bstate = REPORT_MOUSE_POSITION;\n\t    }\n\t}\n\tif (b & 4) {\n\t    eventp->bstate |= BUTTON_SHIFT;\n\t}\n\tif (b & 8) {\n\t    eventp->bstate |= BUTTON_ALT;\n\t}\n\tif (b & 16) {\n\t    eventp->bstate |= BUTTON_CTRL;\n\t}\n\tresult = (eventp->bstate & REPORT_MOUSE_POSITION) ? TRUE : FALSE;\n\teventp->x = (data.params[1] ? (data.params[1] - 1) : 0);\n\teventp->y = (data.params[2] ? (data.params[2] - 1) : 0);\n    }\n    return result;\n}\n\nstatic bool\n_nc_mouse_inline(SCREEN *sp)\n \n{\n    bool result = FALSE;\n    MEVENT *eventp = sp->_mouse_eventp;\n\n    TR(MY_TRACE, (\"_nc_mouse_inline() called\"));\n\n    if (sp->_mouse_type == M_XTERM) {\n\tswitch (sp->_mouse_format) {\n\tcase MF_X10:\n\t    result = decode_xterm_X10(sp, eventp);\n\t    break;\n\tcase MF_SGR1006:\n\t    result = decode_xterm_SGR1006(sp, eventp);\n\t    break;\n#ifdef EXP_XTERM_1005\n\tcase MF_XTERM_1005:\n\t    result = decode_xterm_1005(sp, eventp);\n\t    break;\n#endif\n\t}\n\n\tTR(MY_TRACE,\n\t   (\"_nc_mouse_inline: primitive mouse-event %s has slot %ld\",\n\t    _nc_tracemouse(sp, eventp),\n\t    (long) IndexEV(sp, eventp)));\n\n\t \n\tsp->_mouse_eventp = NEXT(eventp);\n\n\tif (!result) {\n\t     \n\t    if (eventp->bstate & BUTTON_PRESSED) {\n\t\tint b;\n\n\t\tfor (b = 4; b <= MAX_BUTTONS; ++b) {\n\t\t    if ((eventp->bstate & MASK_PRESS(b))) {\n\t\t\tresult = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    return (result);\n}\n\nstatic void\nmouse_activate(SCREEN *sp, int on)\n{\n    if (!on && !sp->_mouse_initialized)\n\treturn;\n\n    if (!_nc_mouse_init(sp))\n\treturn;\n\n    if (on) {\n\tsp->_mouse_bstate = 0;\n\tswitch (sp->_mouse_type) {\n\tcase M_XTERM:\n#if NCURSES_EXT_FUNCS\n\t    NCURSES_SP_NAME(keyok) (NCURSES_SP_ARGx KEY_MOUSE, on);\n#endif\n\t    TPUTS_TRACE(\"xterm mouse initialization\");\n\t    enable_xterm_mouse(sp, 1);\n\t    break;\n#if USE_GPM_SUPPORT\n\tcase M_GPM:\n\t    if (enable_gpm_mouse(sp, TRUE)) {\n\t\tsp->_mouse_fd = *(my_gpm_fd);\n\t\tT((\"GPM mouse_fd %d\", sp->_mouse_fd));\n\t    }\n\t    break;\n#endif\n#if USE_SYSMOUSE\n\tcase M_SYSMOUSE:\n\t    signal(SIGUSR2, handle_sysmouse);\n\t    sp->_mouse_active = TRUE;\n\t    break;\n#endif\n#ifdef USE_TERM_DRIVER\n\tcase M_TERM_DRIVER:\n\t    sp->_mouse_active = TRUE;\n\t    break;\n#endif\n\tcase M_NONE:\n\t    return;\n\t}\n\t \n\tsp->_mouse_event = _nc_mouse_event;\n\tsp->_mouse_inline = _nc_mouse_inline;\n\tsp->_mouse_parse = _nc_mouse_parse;\n\tsp->_mouse_resume = _nc_mouse_resume;\n\tsp->_mouse_wrap = _nc_mouse_wrap;\n    } else {\n\n\tswitch (sp->_mouse_type) {\n\tcase M_XTERM:\n\t    TPUTS_TRACE(\"xterm mouse deinitialization\");\n\t    enable_xterm_mouse(sp, 0);\n\t    break;\n#if USE_GPM_SUPPORT\n\tcase M_GPM:\n\t    enable_gpm_mouse(sp, FALSE);\n\t    break;\n#endif\n#if USE_SYSMOUSE\n\tcase M_SYSMOUSE:\n\t    signal(SIGUSR2, SIG_IGN);\n\t    sp->_mouse_active = FALSE;\n\t    break;\n#endif\n#ifdef USE_TERM_DRIVER\n\tcase M_TERM_DRIVER:\n\t    sp->_mouse_active = FALSE;\n\t    break;\n#endif\n\tcase M_NONE:\n\t    return;\n\t}\n    }\n    NCURSES_SP_NAME(_nc_flush) (NCURSES_SP_ARG);\n}\n\n \n\nstatic bool\n_nc_mouse_parse(SCREEN *sp, int runcount)\n \n{\n    MEVENT *eventp = sp->_mouse_eventp;\n    MEVENT *next, *ep;\n    MEVENT *first_valid = NULL;\n    MEVENT *first_invalid = NULL;\n    int n;\n    int b;\n    bool merge;\n    bool endLoop;\n\n    TR(MY_TRACE, (\"_nc_mouse_parse(%d) called\", runcount));\n\n     \n\n     \n    ep = eventp;\n    for (n = runcount; n < EV_MAX; n++) {\n\tInvalidate(ep);\n\tep = NEXT(ep);\n    }\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_IEVENT)) {\n\t_trace_slot(sp, \"before mouse press/release merge:\");\n\t_tracef(\"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d\",\n\t\tRunParams(sp, eventp, ep),\n\t\truncount);\n\t_nc_unlock_global(tracef);\n    }\n#endif  \n\n     \n    endLoop = FALSE;\n    while (!endLoop) {\n\tnext = NEXT(ep);\n\tif (next == eventp) {\n\t     \n\t    endLoop = TRUE;\n\t} else {\n\n#define MASK_CHANGED(x) (!(ep->bstate & MASK_PRESS(x)) \\\n\t\t      == !(next->bstate & MASK_RELEASE(x)))\n\n\t    if (ValidEvent(ep) && ValidEvent(next)\n\t\t&& ep->x == next->x && ep->y == next->y\n\t\t&& (ep->bstate & BUTTON_PRESSED)\n\t\t&& (!(next->bstate & BUTTON_PRESSED))) {\n\t\tbool changed = TRUE;\n\n\t\tfor (b = 1; b <= MAX_BUTTONS; ++b) {\n\t\t    if (!MASK_CHANGED(b)) {\n\t\t\tchanged = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tif (changed) {\n\t\t    merge = FALSE;\n\t\t    for (b = 1; b <= MAX_BUTTONS; ++b) {\n\t\t\tif ((sp->_mouse_mask2 & MASK_CLICK(b))\n\t\t\t    && (ep->bstate & MASK_PRESS(b))) {\n\t\t\t    next->bstate &= ~MASK_RELEASE(b);\n\t\t\t    next->bstate |= MASK_CLICK(b);\n\t\t\t    merge = TRUE;\n\t\t\t}\n\t\t    }\n\t\t    if (merge) {\n\t\t\tInvalidate(ep);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t \n\tif (!ValidEvent(ep)) {\n\t    if ((first_valid != NULL) && (first_invalid == NULL)) {\n\t\tfirst_invalid = ep;\n\t    }\n\t} else {\n\t    if (first_valid == NULL) {\n\t\tfirst_valid = ep;\n\t    } else if (first_invalid != NULL) {\n\t\t*first_invalid = *ep;\n\t\tInvalidate(ep);\n\t\tfirst_invalid = NEXT(first_invalid);\n\t    }\n\t}\n\n\tep = next;\n    }\n\n    if (first_invalid != NULL) {\n\teventp = first_invalid;\n    }\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_IEVENT)) {\n\t_trace_slot(sp, \"before mouse click merge:\");\n\tif (first_valid == NULL) {\n\t    _tracef(\"_nc_mouse_parse: no valid event\");\n\t} else {\n\t    _tracef(\"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d\",\n\t\t    RunParams(sp, eventp, first_valid),\n\t\t    runcount);\n\t    _nc_unlock_global(tracef);\n\t}\n    }\n#endif  \n\n     \n    first_invalid = NULL;\n    endLoop = (first_valid == NULL);\n    ep = first_valid;\n    while (!endLoop) {\n\tnext = NEXT(ep);\n\n\tif (next == eventp) {\n\t     \n\t    endLoop = TRUE;\n\t} else if (!ValidEvent(next)) {\n\t    continue;\n\t} else {\n\t     \n\t    if ((ep->bstate & BUTTON_CLICKED)\n\t\t&& (next->bstate & BUTTON_CLICKED)) {\n\t\tmerge = FALSE;\n\t\tfor (b = 1; b <= MAX_BUTTONS; ++b) {\n\t\t    if ((sp->_mouse_mask2 & MASK_DOUBLE_CLICK(b))\n\t\t\t&& (ep->bstate & MASK_CLICK(b))\n\t\t\t&& (next->bstate & MASK_CLICK(b))) {\n\t\t\tnext->bstate &= ~MASK_CLICK(b);\n\t\t\tnext->bstate |= MASK_DOUBLE_CLICK(b);\n\t\t\tmerge = TRUE;\n\t\t    }\n\t\t}\n\t\tif (merge) {\n\t\t    Invalidate(ep);\n\t\t}\n\t    }\n\n\t     \n\t    if ((ep->bstate & BUTTON_DOUBLE_CLICKED)\n\t\t&& (next->bstate & BUTTON_CLICKED)) {\n\t\tmerge = FALSE;\n\t\tfor (b = 1; b <= MAX_BUTTONS; ++b) {\n\t\t    if ((sp->_mouse_mask2 & MASK_TRIPLE_CLICK(b))\n\t\t\t&& (ep->bstate & MASK_DOUBLE_CLICK(b))\n\t\t\t&& (next->bstate & MASK_CLICK(b))) {\n\t\t\tnext->bstate &= ~MASK_CLICK(b);\n\t\t\tnext->bstate |= MASK_TRIPLE_CLICK(b);\n\t\t\tmerge = TRUE;\n\t\t    }\n\t\t}\n\t\tif (merge) {\n\t\t    Invalidate(ep);\n\t\t}\n\t    }\n\t}\n\n\t \n\tif (!(ep->bstate & sp->_mouse_mask2)) {\n\t    Invalidate(ep);\n\t}\n\n\t \n\tif (!ValidEvent(ep)) {\n\t    if (ep == first_valid) {\n\t\tfirst_valid = next;\n\t    } else if (first_invalid == NULL) {\n\t\tfirst_invalid = ep;\n\t    }\n\t} else if (first_invalid != NULL) {\n\t    *first_invalid = *ep;\n\t    Invalidate(ep);\n\t    first_invalid = NEXT(first_invalid);\n\t}\n\n\tep = next;\n    }\n\n    if (first_invalid == NULL) {\n\tfirst_invalid = eventp;\n    }\n    sp->_mouse_eventp = first_invalid;\n\n#ifdef TRACE\n    if (first_valid != NULL) {\n\tif (USE_TRACEF(TRACE_IEVENT)) {\n\t    _trace_slot(sp, \"after mouse event queue compaction:\");\n\t    _tracef(\"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d\",\n\t\t    RunParams(sp, first_invalid, first_valid),\n\t\t    runcount);\n\t    _nc_unlock_global(tracef);\n\t}\n\tfor (ep = first_valid; ep != first_invalid; ep = NEXT(ep)) {\n\t    if (ValidEvent(ep))\n\t\tTR(MY_TRACE,\n\t\t   (\"_nc_mouse_parse: returning composite mouse event %s at slot %ld\",\n\t\t    _nc_tracemouse(sp, ep),\n\t\t    (long) IndexEV(sp, ep)));\n\t}\n    }\n#endif  \n\n     \n    ep = PREV(first_invalid);\n    return ValidEvent(ep) && ((ep->bstate & sp->_mouse_mask) != 0);\n}\n\nstatic void\n_nc_mouse_wrap(SCREEN *sp)\n \n{\n    TR(MY_TRACE, (\"_nc_mouse_wrap() called\"));\n\n    switch (sp->_mouse_type) {\n    case M_XTERM:\n\tif (sp->_mouse_mask)\n\t    mouse_activate(sp, FALSE);\n\tbreak;\n#if USE_GPM_SUPPORT\n\t \n    case M_GPM:\n\tif (sp->_mouse_mask)\n\t    mouse_activate(sp, FALSE);\n\tbreak;\n#endif\n#if USE_SYSMOUSE\n    case M_SYSMOUSE:\n\tmouse_activate(sp, FALSE);\n\tbreak;\n#endif\n#ifdef USE_TERM_DRIVER\n    case M_TERM_DRIVER:\n\tmouse_activate(sp, FALSE);\n\tbreak;\n#endif\n    case M_NONE:\n\tbreak;\n    }\n}\n\nstatic void\n_nc_mouse_resume(SCREEN *sp)\n \n{\n    TR(MY_TRACE, (\"_nc_mouse_resume() called\"));\n\n    switch (sp->_mouse_type) {\n    case M_XTERM:\n\t \n\tif (sp->_mouse_mask)\n\t    mouse_activate(sp, TRUE);\n\tbreak;\n\n#if USE_GPM_SUPPORT\n    case M_GPM:\n\t \n\tif (sp->_mouse_mask)\n\t    mouse_activate(sp, TRUE);\n\tbreak;\n#endif\n\n#if USE_SYSMOUSE\n    case M_SYSMOUSE:\n\tmouse_activate(sp, TRUE);\n\tbreak;\n#endif\n\n#ifdef USE_TERM_DRIVER\n    case M_TERM_DRIVER:\n\tmouse_activate(sp, TRUE);\n\tbreak;\n#endif\n\n    case M_NONE:\n\tbreak;\n    }\n}\n\n \n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(getmouse) (NCURSES_SP_DCLx MEVENT * aevent)\n{\n    int result = ERR;\n    MEVENT *eventp;\n\n    T((T_CALLED(\"getmouse(%p,%p)\"), (void *) SP_PARM, (void *) aevent));\n\n    if ((aevent != 0) &&\n\t(SP_PARM != 0) &&\n\t(SP_PARM->_mouse_type != M_NONE) &&\n\t(eventp = SP_PARM->_mouse_eventp) != 0) {\n\t \n\tMEVENT *prev = PREV(eventp);\n\n\t \n\twhile (ValidEvent(prev) && (!(prev->bstate & SP_PARM->_mouse_mask2))) {\n\t    Invalidate(prev);\n\t    prev = PREV(prev);\n\t}\n\tif (ValidEvent(prev)) {\n\t     \n\t    *aevent = *prev;\n\n\t    TR(TRACE_IEVENT, (\"getmouse: returning event %s from slot %ld\",\n\t\t\t      _nc_tracemouse(SP_PARM, prev),\n\t\t\t      (long) IndexEV(SP_PARM, prev)));\n\n\t    Invalidate(prev);\t \n\t    SP_PARM->_mouse_eventp = prev;\n\t    result = OK;\n\t} else {\n\t     \n\t    aevent->bstate = 0;\n\t    Invalidate(aevent);\n\t    aevent->x = 0;\n\t    aevent->y = 0;\n\t    aevent->z = 0;\n\t}\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\n \nNCURSES_EXPORT(int)\ngetmouse(MEVENT * aevent)\n{\n    return NCURSES_SP_NAME(getmouse) (CURRENT_SCREEN, aevent);\n}\n#endif\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(ungetmouse) (NCURSES_SP_DCLx MEVENT * aevent)\n{\n    int result = ERR;\n    MEVENT *eventp;\n\n    T((T_CALLED(\"ungetmouse(%p,%p)\"), (void *) SP_PARM, (void *) aevent));\n\n    if (aevent != 0 &&\n\tSP_PARM != 0 &&\n\t(eventp = SP_PARM->_mouse_eventp) != 0) {\n\n\t \n\t*eventp = *aevent;\n\n\t \n\tSP_PARM->_mouse_eventp = NEXT(eventp);\n\n\t \n\tresult = NCURSES_SP_NAME(ungetch) (NCURSES_SP_ARGx KEY_MOUSE);\n    }\n    returnCode(result);\n}\n\n#if NCURSES_SP_FUNCS\n \nNCURSES_EXPORT(int)\nungetmouse(MEVENT * aevent)\n{\n    return NCURSES_SP_NAME(ungetmouse) (CURRENT_SCREEN, aevent);\n}\n#endif\n\nNCURSES_EXPORT(mmask_t)\nNCURSES_SP_NAME(mousemask) (NCURSES_SP_DCLx mmask_t newmask, mmask_t * oldmask)\n \n{\n    mmask_t result = 0;\n\n    T((T_CALLED(\"mousemask(%p,%#lx,%p)\"),\n       (void *) SP_PARM,\n       (unsigned long) newmask,\n       (void *) oldmask));\n\n    if (SP_PARM != 0) {\n\tif (oldmask)\n\t    *oldmask = SP_PARM->_mouse_mask;\n\n\tif (newmask || SP_PARM->_mouse_initialized) {\n\t    _nc_mouse_init(SP_PARM);\n\n\t    if (SP_PARM->_mouse_type != M_NONE) {\n\t\tint b;\n\n\t\tresult = newmask &\n\t\t    (REPORT_MOUSE_POSITION\n\t\t     | BUTTON_ALT\n\t\t     | BUTTON_CTRL\n\t\t     | BUTTON_SHIFT\n\t\t     | BUTTON_PRESSED\n\t\t     | BUTTON_RELEASED\n\t\t     | BUTTON_CLICKED\n\t\t     | BUTTON_DOUBLE_CLICKED\n\t\t     | BUTTON_TRIPLE_CLICKED);\n\n\t\tmouse_activate(SP_PARM, (bool) (result != 0));\n\n\t\tSP_PARM->_mouse_mask = result;\n\t\tSP_PARM->_mouse_mask2 = result;\n\n\t\t \n\t\tfor (b = 1; b <= MAX_BUTTONS; ++b) {\n\t\t    if (SP_PARM->_mouse_mask2 & MASK_TRIPLE_CLICK(b))\n\t\t\tSP_PARM->_mouse_mask2 |= MASK_DOUBLE_CLICK(b);\n\t\t    if (SP_PARM->_mouse_mask2 & MASK_DOUBLE_CLICK(b))\n\t\t\tSP_PARM->_mouse_mask2 |= MASK_CLICK(b);\n\t\t    if (SP_PARM->_mouse_mask2 & MASK_CLICK(b))\n\t\t\tSP_PARM->_mouse_mask2 |= (MASK_PRESS(b) |\n\t\t\t\t\t\t  MASK_RELEASE(b));\n\t\t}\n\t    }\n\t}\n    }\n    returnMMask(result);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(mmask_t)\nmousemask(mmask_t newmask, mmask_t * oldmask)\n{\n    return NCURSES_SP_NAME(mousemask) (CURRENT_SCREEN, newmask, oldmask);\n}\n#endif\n\nNCURSES_EXPORT(bool)\nwenclose(const WINDOW *win, int y, int x)\n \n{\n    bool result = FALSE;\n\n    T((T_CALLED(\"wenclose(%p,%d,%d)\"), (const void *) win, y, x));\n\n    if (win != 0) {\n\ty -= win->_yoffset;\n\tresult = ((win->_begy <= y &&\n\t\t   win->_begx <= x &&\n\t\t   (win->_begx + win->_maxx) >= x &&\n\t\t   (win->_begy + win->_maxy) >= y) ? TRUE : FALSE);\n    }\n    returnBool(result);\n}\n\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(mouseinterval) (NCURSES_SP_DCLx int maxclick)\n \n{\n    int oldval;\n\n    T((T_CALLED(\"mouseinterval(%p,%d)\"), (void *) SP_PARM, maxclick));\n\n    if (SP_PARM != 0) {\n\toldval = SP_PARM->_maxclick;\n\tif (maxclick >= 0)\n\t    SP_PARM->_maxclick = maxclick;\n    } else {\n\toldval = DEFAULT_MAXCLICK;\n    }\n\n    returnCode(oldval);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nmouseinterval(int maxclick)\n{\n    return NCURSES_SP_NAME(mouseinterval) (CURRENT_SCREEN, maxclick);\n}\n#endif\n\n \nNCURSES_EXPORT(bool)\n_nc_has_mouse(SCREEN *sp)\n{\n    return (((0 == sp) || (sp->_mouse_type == M_NONE)) ? FALSE : TRUE);\n}\n\nNCURSES_EXPORT(bool)\nNCURSES_SP_NAME(has_mouse) (NCURSES_SP_DCL0)\n{\n    return _nc_has_mouse(SP_PARM);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(bool)\nhas_mouse(void)\n{\n    return _nc_has_mouse(CURRENT_SCREEN);\n}\n#endif\n\nNCURSES_EXPORT(bool)\nwmouse_trafo(const WINDOW *win, int *pY, int *pX, bool to_screen)\n{\n    bool result = FALSE;\n\n    T((T_CALLED(\"wmouse_trafo(%p,%p,%p,%d)\"),\n       (const void *) win,\n       (void *) pY,\n       (void *) pX,\n       to_screen));\n\n    if (win && pY && pX) {\n\tint y = *pY;\n\tint x = *pX;\n\n\tif (to_screen) {\n\t    y += win->_begy + win->_yoffset;\n\t    x += win->_begx;\n\t    if (wenclose(win, y, x))\n\t\tresult = TRUE;\n\t} else {\n\t    if (wenclose(win, y, x)) {\n\t\ty -= (win->_begy + win->_yoffset);\n\t\tx -= win->_begx;\n\t\tresult = TRUE;\n\t    }\n\t}\n\tif (result) {\n\t    *pX = x;\n\t    *pY = y;\n\t}\n    }\n    returnBool(result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}