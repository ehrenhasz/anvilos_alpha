{
  "module_name": "lib_newwin.c",
  "hash_id": "844d7990ca5b60732c3dcef0b0c9a61798ff00eb53d78f3059b8070f67ecddeb",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_newwin.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#include <stddef.h>\n\nMODULE_ID(\"$Id: lib_newwin.c,v 1.76 2021/10/23 18:53:38 tom Exp $\")\n\n#define window_is(name) ((sp)->_##name == win)\n\n#if USE_REENTRANT\n#define remove_window(name) \\\n\t\tsp->_##name = 0\n#else\n#define remove_window(name) \\\n\t\tsp->_##name = 0; \\\n\t\tif (win == name) \\\n\t\t    name = 0\n#endif\n\nstatic void\nremove_window_from_screen(WINDOW *win)\n{\n    SCREEN *sp;\n\n#ifdef USE_SP_WINDOWLIST\n    if ((sp = _nc_screen_of(win)) != 0) {\n\tif (window_is(curscr)) {\n\t    remove_window(curscr);\n\t} else if (window_is(stdscr)) {\n\t    remove_window(stdscr);\n\t} else if (window_is(newscr)) {\n\t    remove_window(newscr);\n\t}\n    }\n#else\n    for (each_screen(sp)) {\n\tif (window_is(curscr)) {\n\t    remove_window(curscr);\n\t    break;\n\t} else if (window_is(stdscr)) {\n\t    remove_window(stdscr);\n\t    break;\n\t} else if (window_is(newscr)) {\n\t    remove_window(newscr);\n\t    break;\n\t}\n    }\n#endif\n}\n\nNCURSES_EXPORT(int)\n_nc_freewin(WINDOW *win)\n{\n    int result = ERR;\n#ifdef USE_SP_WINDOWLIST\n    SCREEN *sp = _nc_screen_of(win);\t \n#endif\n\n    T((T_CALLED(\"_nc_freewin(%p)\"), (void *) win));\n\n    if (win != 0) {\n\n\tif (_nc_nonsp_try_global(curses) == 0) {\n\t    WINDOWLIST *p, *q;\n\n\t    q = 0;\n\t    for (each_window(sp, p)) {\n\n\t\tif (&(p->win) == win) {\n\t\t    remove_window_from_screen(win);\n\t\t    if (q == 0)\n\t\t\tWindowList(sp) = p->next;\n\t\t    else\n\t\t\tq->next = p->next;\n\n\t\t    if (!IS_SUBWIN(win)) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i <= win->_maxy; i++)\n\t\t\t    FreeIfNeeded(win->_line[i].text);\n\t\t    }\n\t\t    free(win->_line);\n\t\t    free(p);\n\n\t\t    result = OK;\n\t\t    T((\"...deleted win=%p\", (void *) win));\n\t\t    break;\n\t\t}\n\t\tq = p;\n\t    }\n\t    _nc_nonsp_unlock_global(curses);\n\t}\n    }\n    returnCode(result);\n}\n\nNCURSES_EXPORT(WINDOW *)\nNCURSES_SP_NAME(newwin) (NCURSES_SP_DCLx\n\t\t\t int num_lines, int num_columns, int begy, int begx)\n{\n    WINDOW *win;\n    NCURSES_CH_T *ptr;\n    int i;\n\n    T((T_CALLED(\"newwin(%p, %d,%d,%d,%d)\"), (void *) SP_PARM, num_lines, num_columns,\n       begy, begx));\n\n    if (begy < 0\n\t|| begx < 0\n\t|| num_lines < 0\n\t|| num_columns < 0\n\t|| SP_PARM == 0)\n\treturnWin(0);\n\n    if (num_lines == 0)\n\tnum_lines = SP_PARM->_lines_avail - begy;\n    if (num_columns == 0)\n\tnum_columns = screen_columns(SP_PARM) - begx;\n\n    win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx\n\t\t\t\t\tnum_lines, num_columns, begy, begx, 0);\n    if (win == 0)\n\treturnWin(0);\n\n    for (i = 0; i < num_lines; i++) {\n\twin->_line[i].text = typeCalloc(NCURSES_CH_T, (unsigned) num_columns);\n\tif (win->_line[i].text == 0) {\n\t    (void) _nc_freewin(win);\n\t    returnWin(0);\n\t}\n\tfor (ptr = win->_line[i].text;\n\t     ptr < win->_line[i].text + num_columns;\n\t     ptr++)\n\t    SetChar(*ptr, BLANK_TEXT, BLANK_ATTR);\n    }\n\n    returnWin(win);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(WINDOW *)\nnewwin(int num_lines, int num_columns, int begy, int begx)\n{\n    WINDOW *win;\n    _nc_sp_lock_global(curses);\n    win = NCURSES_SP_NAME(newwin) (CURRENT_SCREEN,\n\t\t\t\t   num_lines, num_columns, begy, begx);\n    _nc_sp_unlock_global(curses);\n    return (win);\n}\n#endif\n\nNCURSES_EXPORT(WINDOW *)\nderwin(WINDOW *orig, int num_lines, int num_columns, int begy, int begx)\n{\n    WINDOW *win;\n    int i;\n    int flags = _SUBWIN;\n#if NCURSES_SP_FUNCS\n    SCREEN *sp = _nc_screen_of(orig);\n#endif\n\n    T((T_CALLED(\"derwin(%p,%d,%d,%d,%d)\"), (void *) orig, num_lines, num_columns,\n       begy, begx));\n\n     \n    if (begy < 0 || begx < 0 || orig == 0 || num_lines < 0 || num_columns < 0)\n\treturnWin(0);\n    if (begy + num_lines > orig->_maxy + 1\n\t|| begx + num_columns > orig->_maxx + 1)\n\treturnWin(0);\n\n    if (num_lines == 0)\n\tnum_lines = orig->_maxy + 1 - begy;\n\n    if (num_columns == 0)\n\tnum_columns = orig->_maxx + 1 - begx;\n\n    if (IS_PAD(orig))\n\tflags |= _ISPAD;\n\n    win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx num_lines, num_columns,\n\t\t\t\t\torig->_begy + begy,\n\t\t\t\t\torig->_begx + begx, flags);\n    if (win == 0)\n\treturnWin(0);\n\n    win->_pary = begy;\n    win->_parx = begx;\n    WINDOW_ATTRS(win) = WINDOW_ATTRS(orig);\n    win->_nc_bkgd = orig->_nc_bkgd;\n\n    for (i = 0; i < num_lines; i++)\n\twin->_line[i].text = &orig->_line[begy++].text[begx];\n\n    win->_parent = orig;\n\n    returnWin(win);\n}\n\nNCURSES_EXPORT(WINDOW *)\nsubwin(WINDOW *w, int l, int c, int y, int x)\n{\n    WINDOW *result = 0;\n\n    T((T_CALLED(\"subwin(%p, %d, %d, %d, %d)\"), (void *) w, l, c, y, x));\n    if (w != 0) {\n\tT((\"parent has begy = %ld, begx = %ld\", (long) w->_begy, (long) w->_begx));\n\n\tresult = derwin(w, l, c, y - w->_begy, x - w->_begx);\n    }\n    returnWin(result);\n}\n\nstatic bool\ndimension_limit(int value)\n{\n    NCURSES_SIZE_T test = (NCURSES_SIZE_T) value;\n    return (test == value && value > 0);\n}\n\nNCURSES_EXPORT(WINDOW *)\nNCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_DCLx\n\t\t\t      int num_lines,\n\t\t\t      int num_columns,\n\t\t\t      int begy,\n\t\t\t      int begx,\n\t\t\t      int flags)\n{\n    int i;\n    WINDOWLIST *wp;\n    WINDOW *win;\n    bool is_padwin = (flags & _ISPAD);\n\n    T((T_CALLED(\"_nc_makenew(%p,%d,%d,%d,%d)\"),\n       (void *) SP_PARM, num_lines, num_columns, begy, begx));\n\n    if (SP_PARM == 0)\n\treturnWin(0);\n\n    if (!dimension_limit(num_lines) || !dimension_limit(num_columns))\n\treturnWin(0);\n\n    if ((wp = typeCalloc(WINDOWLIST, 1)) == 0)\n\treturnWin(0);\n\n    win = &(wp->win);\n\n    if ((win->_line = typeCalloc(struct ldat, ((unsigned) num_lines))) == 0) {\n\tfree(wp);\n\treturnWin(0);\n    }\n\n    _nc_nonsp_lock_global(curses);\n\n    win->_curx = 0;\n    win->_cury = 0;\n    win->_maxy = (NCURSES_SIZE_T) (num_lines - 1);\n    win->_maxx = (NCURSES_SIZE_T) (num_columns - 1);\n    win->_begy = (NCURSES_SIZE_T) begy;\n    win->_begx = (NCURSES_SIZE_T) begx;\n    win->_yoffset = SP_PARM->_topstolen;\n\n    win->_flags = (short) flags;\n    WINDOW_ATTRS(win) = A_NORMAL;\n    SetChar(win->_nc_bkgd, BLANK_TEXT, BLANK_ATTR);\n\n    win->_clear = (is_padwin\n\t\t   ? FALSE\n\t\t   : (num_lines == screen_lines(SP_PARM)\n\t\t      && num_columns == screen_columns(SP_PARM)));\n    win->_idlok = FALSE;\n    win->_idcok = TRUE;\n    win->_scroll = FALSE;\n    win->_leaveok = FALSE;\n    win->_use_keypad = FALSE;\n    win->_delay = -1;\n    win->_immed = FALSE;\n    win->_sync = 0;\n    win->_parx = -1;\n    win->_pary = -1;\n    win->_parent = 0;\n\n    win->_regtop = 0;\n    win->_regbottom = (NCURSES_SIZE_T) (num_lines - 1);\n\n    win->_pad._pad_y = -1;\n    win->_pad._pad_x = -1;\n    win->_pad._pad_top = -1;\n    win->_pad._pad_bottom = -1;\n    win->_pad._pad_left = -1;\n    win->_pad._pad_right = -1;\n\n    for (i = 0; i < num_lines; i++) {\n\t \n\twin->_line[i].firstchar = 0;\n\twin->_line[i].lastchar = (NCURSES_SIZE_T) (num_columns - 1);\n\n\tif_USE_SCROLL_HINTS(win->_line[i].oldindex = i);\n    }\n\n    if (!is_padwin && (begx + num_columns == screen_columns(SP_PARM))) {\n\twin->_flags |= _ENDLINE;\n\n\tif (begx == 0 && num_lines == screen_lines(SP_PARM) && begy == 0)\n\t    win->_flags |= _FULLWIN;\n\n\tif (begy + num_lines == screen_lines(SP_PARM))\n\t    win->_flags |= _SCROLLWIN;\n    }\n\n    wp->next = WindowList(SP_PARM);\n    wp->screen = SP_PARM;\n    WindowList(SP_PARM) = wp;\n\n    T((T_CREATE(\"window %p\"), (void *) win));\n\n    _nc_nonsp_unlock_global(curses);\n    returnWin(win);\n}\n\n \n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(WINDOW *)\n_nc_curscr_of(SCREEN *sp)\n{\n    return (sp == 0) ? NULL : CurScreen(sp);\n}\n\nNCURSES_EXPORT(WINDOW *)\n_nc_newscr_of(SCREEN *sp)\n{\n    return (sp == 0) ? NULL : NewScreen(sp);\n}\n\nNCURSES_EXPORT(WINDOW *)\n_nc_stdscr_of(SCREEN *sp)\n{\n    return (sp == 0) ? NULL : StdScreen(sp);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}