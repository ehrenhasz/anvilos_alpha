{
  "module_name": "lib_pad.c",
  "hash_id": "6c43ebd49d6cc08507abfc54630d451cce23f856f7e1976cb6bf6c0907c800aa",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_pad.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_pad.c,v 1.50 2021/10/23 22:57:27 tom Exp $\")\n\nNCURSES_EXPORT(WINDOW *)\nNCURSES_SP_NAME(newpad) (NCURSES_SP_DCLx int l, int c)\n{\n    WINDOW *win;\n    NCURSES_CH_T *ptr;\n    int i;\n\n    T((T_CALLED(\"newpad(%p,%d, %d)\"), (void *) SP_PARM, l, c));\n\n    if (l <= 0 || c <= 0)\n\treturnWin(0);\n\n    win = NCURSES_SP_NAME(_nc_makenew) (NCURSES_SP_ARGx l, c, 0, 0, _ISPAD);\n    if (win == NULL)\n\treturnWin(0);\n\n    for (i = 0; i < l; i++) {\n\tif_USE_SCROLL_HINTS(win->_line[i].oldindex = _NEWINDEX);\n\tif ((win->_line[i].text = typeCalloc(NCURSES_CH_T, ((size_t) c))) == 0) {\n\t    (void) _nc_freewin(win);\n\t    returnWin(0);\n\t}\n\tfor (ptr = win->_line[i].text; ptr < win->_line[i].text + c; ptr++)\n\t    SetChar(*ptr, BLANK_TEXT, BLANK_ATTR);\n    }\n\n    returnWin(win);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(WINDOW *)\nnewpad(int l, int c)\n{\n    return NCURSES_SP_NAME(newpad) (CURRENT_SCREEN, l, c);\n}\n#endif\n\nNCURSES_EXPORT(WINDOW *)\nsubpad(WINDOW *orig, int l, int c, int begy, int begx)\n{\n    WINDOW *win = (WINDOW *) 0;\n\n    T((T_CALLED(\"subpad(%d, %d)\"), l, c));\n\n    if (orig) {\n\tif (!IS_PAD(orig)\n\t    || ((win = derwin(orig, l, c, begy, begx)) == NULL))\n\t    returnWin(0);\n    }\n    returnWin(win);\n}\n\nNCURSES_EXPORT(int)\nprefresh(WINDOW *win,\n\t int pminrow,\n\t int pmincol,\n\t int sminrow,\n\t int smincol,\n\t int smaxrow,\n\t int smaxcol)\n{\n#if NCURSES_SP_FUNCS\n    SCREEN *sp = _nc_screen_of(win);\n#endif\n\n    T((T_CALLED(\"prefresh()\")));\n    if (pnoutrefresh(win, pminrow, pmincol, sminrow, smincol, smaxrow,\n\t\t     smaxcol) != ERR\n\t&& NCURSES_SP_NAME(doupdate) (NCURSES_SP_ARG) != ERR) {\n\treturnCode(OK);\n    }\n    returnCode(ERR);\n}\n\nNCURSES_EXPORT(int)\npnoutrefresh(WINDOW *win,\n\t     int pminrow,\n\t     int pmincol,\n\t     int sminrow,\n\t     int smincol,\n\t     int smaxrow,\n\t     int smaxcol)\n{\n    int i, j;\n    int m, n;\n    int pmaxrow;\n    int pmaxcol;\n    SCREEN *sp;\n\n#if USE_SCROLL_HINTS\n    const int my_len = 2;\t \n    NCURSES_SIZE_T displaced;\n    bool wide;\n#endif\n\n    T((T_CALLED(\"pnoutrefresh(%p, %d, %d, %d, %d, %d, %d)\"),\n       (void *) win, pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol));\n\n    if (win == 0)\n\treturnCode(ERR);\n\n    if (!IS_PAD(win))\n\treturnCode(ERR);\n\n    sp = _nc_screen_of(win);\n\n     \n    if (pminrow < 0)\n\tpminrow = 0;\n    if (pmincol < 0)\n\tpmincol = 0;\n    if (sminrow < 0)\n\tsminrow = 0;\n    if (smincol < 0)\n\tsmincol = 0;\n\n    pmaxrow = pminrow + smaxrow - sminrow;\n    pmaxcol = pmincol + smaxcol - smincol;\n\n    T((\" pminrow + smaxrow - sminrow %ld, win->_maxy %ld\",\n       (long) pmaxrow, (long) win->_maxy));\n    T((\" pmincol + smaxcol - smincol %ld, win->_maxx %ld\",\n       (long) pmaxcol, (long) win->_maxx));\n\n     \n    if (pmaxrow > win->_maxy) {\n\tsmaxrow -= (pmaxrow - win->_maxy);\n\tpmaxrow = pminrow + smaxrow - sminrow;\n    }\n    if (pmaxcol > win->_maxx) {\n\tsmaxcol -= (pmaxcol - win->_maxx);\n\tpmaxcol = pmincol + smaxcol - smincol;\n    }\n\n    if (smaxrow >= screen_lines(sp)\n\t|| smaxcol >= screen_columns(sp)\n\t|| sminrow > smaxrow\n\t|| smincol > smaxcol)\n\treturnCode(ERR);\n\n    T((\"pad being refreshed\"));\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_UPDATE)) {\n\t_tracedump(\"...pad\", win);\n\t_nc_unlock_global(tracef);\n    }\n#endif  \n#if USE_SCROLL_HINTS\n    if (win->_pad._pad_y >= 0) {\n\tdisplaced = pminrow - win->_pad._pad_y\n\t    - (sminrow - win->_pad._pad_top);\n\tT((\"pad being shifted by %d line(s)\", displaced));\n    } else\n\tdisplaced = 0;\n#endif\n\n     \n#if USE_SCROLL_HINTS\n    wide = (smincol < my_len && smaxcol > (NewScreen(sp)->_maxx - my_len));\n#endif\n\n    for (i = pminrow, m = sminrow + win->_yoffset;\n\t i <= pmaxrow && m <= NewScreen(sp)->_maxy;\n\t i++, m++) {\n\tregister struct ldat *nline = &NewScreen(sp)->_line[m];\n\tregister struct ldat *oline = &win->_line[i];\n\tfor (j = pmincol, n = smincol; j <= pmaxcol; j++, n++) {\n\t    NCURSES_CH_T ch = oline->text[j];\n#if USE_WIDEC_SUPPORT\n\t     \n\t    if (j == pmincol\n\t\t&& j > 0\n\t\t&& isWidecExt(ch)) {\n\t\tSetChar(ch, L(' '), AttrOf(oline->text[j - 1]));\n\t    }\n#endif\n\t    if (!CharEq(ch, nline->text[n])) {\n\t\tnline->text[n] = ch;\n\t\tCHANGED_CELL(nline, n);\n\t    }\n\t}\n\n#if USE_SCROLL_HINTS\n\tif (wide) {\n\t    int nind = m + displaced;\n\t    if (oline->oldindex < 0\n\t\t|| nind < sminrow\n\t\t|| nind > smaxrow) {\n\t\tnind = _NEWINDEX;\n\t    } else if (displaced) {\n\t\tregister struct ldat *pline = &CurScreen(sp)->_line[nind];\n\t\tfor (j = 0; j <= my_len; j++) {\n\t\t    int k = NewScreen(sp)->_maxx - j;\n\t\t    if (pline->text[j] != nline->text[j]\n\t\t\t|| pline->text[k] != nline->text[k]) {\n\t\t\tnind = _NEWINDEX;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    nline->oldindex = nind;\n\t}\n#endif  \n\toline->firstchar = oline->lastchar = _NOCHANGE;\n\tif_USE_SCROLL_HINTS(oline->oldindex = i);\n    }\n\n     \n#if USE_SCROLL_HINTS\n    for (i = pminrow - 1; (i >= 0) && (win->_line[i].oldindex >= 0); i--)\n\twin->_line[i].oldindex = _NEWINDEX;\n    for (i = pmaxrow + 1; (i <= win->_maxy)\n\t && (win->_line[i].oldindex >= 0); i++)\n\twin->_line[i].oldindex = _NEWINDEX;\n#endif\n\n    win->_begx = (NCURSES_SIZE_T) smincol;\n    win->_begy = (NCURSES_SIZE_T) sminrow;\n\n    if (win->_clear) {\n\twin->_clear = FALSE;\n\tNewScreen(sp)->_clear = TRUE;\n    }\n\n     \n    if (win->_leaveok == FALSE\n\t&& win->_cury >= pminrow\n\t&& win->_curx >= pmincol\n\t&& win->_cury <= pmaxrow\n\t&& win->_curx <= pmaxcol) {\n\tNewScreen(sp)->_cury = (NCURSES_SIZE_T) (win->_cury - pminrow\n\t\t\t\t\t\t + win->_begy + win->_yoffset);\n\tNewScreen(sp)->_curx = (NCURSES_SIZE_T) (win->_curx - pmincol\n\t\t\t\t\t\t + win->_begx);\n    }\n    NewScreen(sp)->_leaveok = win->_leaveok;\n    win->_flags &= ~_HASMOVED;\n\n     \n    win->_pad._pad_y = (NCURSES_SIZE_T) pminrow;\n    win->_pad._pad_x = (NCURSES_SIZE_T) pmincol;\n    win->_pad._pad_top = (NCURSES_SIZE_T) sminrow;\n    win->_pad._pad_left = (NCURSES_SIZE_T) smincol;\n    win->_pad._pad_bottom = (NCURSES_SIZE_T) smaxrow;\n    win->_pad._pad_right = (NCURSES_SIZE_T) smaxcol;\n\n    returnCode(OK);\n}\n\nNCURSES_EXPORT(int)\npechochar(WINDOW *pad, const chtype ch)\n{\n    T((T_CALLED(\"pechochar(%p, %s)\"), (void *) pad, _tracechtype(ch)));\n\n    if (pad == 0)\n\treturnCode(ERR);\n\n    if (!IS_PAD(pad))\n\treturnCode(wechochar(pad, ch));\n\n    waddch(pad, ch);\n    prefresh(pad, pad->_pad._pad_y,\n\t     pad->_pad._pad_x,\n\t     pad->_pad._pad_top,\n\t     pad->_pad._pad_left,\n\t     pad->_pad._pad_bottom,\n\t     pad->_pad._pad_right);\n\n    returnCode(OK);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}