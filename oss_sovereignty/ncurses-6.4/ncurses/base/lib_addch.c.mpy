{
  "module_name": "lib_addch.c",
  "hash_id": "78201bb422aedd7f8b56e0b704851f28d0ce5a5d82d64dc281a494043abbcf60",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_addch.c",
  "human_readable_source": " \n\n \n\n#include <curses.priv.h>\n#include <ctype.h>\n\nMODULE_ID(\"$Id: lib_addch.c,v 1.141 2022/06/12 15:16:41 tom Exp $\")\n\nstatic const NCURSES_CH_T blankchar = NewChar(BLANK_TEXT);\n\n \n\n \n#define COLOR_MASK(ch) (~(attr_t)(((ch) & A_COLOR) ? A_COLOR : 0))\n\nstatic NCURSES_INLINE NCURSES_CH_T\nrender_char(WINDOW *win, NCURSES_CH_T ch)\n \n{\n    attr_t a = WINDOW_ATTRS(win);\n    int pair = GetPair(ch);\n\n    if (ISBLANK(ch)\n\t&& AttrOf(ch) == A_NORMAL\n\t&& pair == 0) {\n\t \n\tch = win->_nc_bkgd;\n\tSetAttr(ch, a | AttrOf(win->_nc_bkgd));\n\tif ((pair = GET_WINDOW_PAIR(win)) == 0)\n\t    pair = GetPair(win->_nc_bkgd);\n\tSetPair(ch, pair);\n    } else {\n\t \n\ta |= AttrOf(win->_nc_bkgd) & COLOR_MASK(a);\n\t \n\tif (pair == 0) {\n\t    if ((pair = GET_WINDOW_PAIR(win)) == 0)\n\t\tpair = GetPair(win->_nc_bkgd);\n\t}\n\tAddAttr(ch, (a & COLOR_MASK(AttrOf(ch))));\n\tSetPair(ch, pair);\n    }\n\n    TR(TRACE_VIRTPUT,\n       (\"render_char bkg %s (%d), attrs %s (%d) -> ch %s (%d)\",\n\t_tracech_t2(1, CHREF(win->_nc_bkgd)),\n\tGetPair(win->_nc_bkgd),\n\t_traceattr(WINDOW_ATTRS(win)),\n\tGET_WINDOW_PAIR(win),\n\t_tracech_t2(3, CHREF(ch)),\n\tGetPair(ch)));\n\n    return (ch);\n}\n\nNCURSES_EXPORT(NCURSES_CH_T)\n_nc_render(WINDOW *win, NCURSES_CH_T ch)\n \n{\n    return render_char(win, ch);\n}\n\n \n#ifndef NDEBUG\t\t\t \n#define CHECK_POSITION(win, x, y) \\\n\tif (y > win->_maxy \\\n\t || x > win->_maxx \\\n\t || y < 0 \\\n\t || x < 0) { \\\n\t\tTR(TRACE_VIRTPUT, (\"Alert! Win=%p _curx = %d, _cury = %d \" \\\n\t\t\t\t   \"(_maxx = %d, _maxy = %d)\", win, x, y, \\\n\t\t\t\t   win->_maxx, win->_maxy)); \\\n\t\treturn(ERR); \\\n\t}\n#else\n#define CHECK_POSITION(win, x, y)\t \n#endif\n\nstatic bool\nnewline_forces_scroll(WINDOW *win, NCURSES_SIZE_T *ypos)\n{\n    bool result = FALSE;\n\n    if (*ypos >= win->_regtop && *ypos <= win->_regbottom) {\n\tif (*ypos == win->_regbottom) {\n\t    *ypos = win->_regbottom;\n\t    result = TRUE;\n\t} else if (*ypos < win->_maxy) {\n\t    *ypos = (NCURSES_SIZE_T) (*ypos + 1);\n\t}\n    } else if (*ypos < win->_maxy) {\n\t*ypos = (NCURSES_SIZE_T) (*ypos + 1);\n    }\n    return result;\n}\n\n \nstatic int\nwrap_to_next_line(WINDOW *win)\n{\n    win->_flags |= _WRAPPED;\n    if (newline_forces_scroll(win, &(win->_cury))) {\n\twin->_curx = win->_maxx;\n\tif (!win->_scroll)\n\t    return (ERR);\n\tscroll(win);\n    }\n    win->_curx = 0;\n    return (OK);\n}\n\n#if USE_WIDEC_SUPPORT\nstatic int waddch_literal(WINDOW *, NCURSES_CH_T);\n \nstatic void\nfill_cells(WINDOW *win, int count)\n{\n    NCURSES_CH_T blank = blankchar;\n    int save_x = win->_curx;\n    int save_y = win->_cury;\n\n    while (count-- > 0) {\n\tif (waddch_literal(win, blank) == ERR)\n\t    break;\n    }\n    win->_curx = (NCURSES_SIZE_T) save_x;\n    win->_cury = (NCURSES_SIZE_T) save_y;\n}\n#endif\n\n \n#if USE_WIDEC_SUPPORT\nNCURSES_EXPORT(int)\n_nc_build_wch(WINDOW *win, ARG_CH_T ch)\n{\n    char *buffer = WINDOW_EXT(win, addch_work);\n    int len;\n    int x = win->_curx;\n    int y = win->_cury;\n    mbstate_t state;\n    wchar_t result;\n\n    if ((WINDOW_EXT(win, addch_used) != 0) &&\n\t(WINDOW_EXT(win, addch_x) != x ||\n\t WINDOW_EXT(win, addch_y) != y)) {\n\t \n\tWINDOW_EXT(win, addch_used) = 0;\n\tTR(TRACE_VIRTPUT,\n\t   (\"Alert discarded multibyte on move (%d,%d) -> (%d,%d)\",\n\t    WINDOW_EXT(win, addch_y), WINDOW_EXT(win, addch_x),\n\t    y, x));\n    }\n    WINDOW_EXT(win, addch_x) = x;\n    WINDOW_EXT(win, addch_y) = y;\n\n     \n    if (!is8bits(CharOf(CHDEREF(ch)))) {\n\tif (WINDOW_EXT(win, addch_used) != 0) {\n\t     \n\t    WINDOW_EXT(win, addch_used) = 0;\n\t    TR(TRACE_VIRTPUT,\n\t       (\"Alert discarded incomplete multibyte\"));\n\t}\n\treturn 1;\n    }\n\n    init_mb(state);\n    buffer[WINDOW_EXT(win, addch_used)] = (char) CharOf(CHDEREF(ch));\n    WINDOW_EXT(win, addch_used) += 1;\n    buffer[WINDOW_EXT(win, addch_used)] = '\\0';\n    if ((len = (int) mbrtowc(&result,\n\t\t\t     buffer,\n\t\t\t     (size_t) WINDOW_EXT(win, addch_used),\n\t\t\t     &state)) > 0) {\n\tattr_t attrs = AttrOf(CHDEREF(ch));\n\tif_EXT_COLORS(int pair = GetPair(CHDEREF(ch)));\n\tSetChar(CHDEREF(ch), result, attrs);\n\tif_EXT_COLORS(SetPair(CHDEREF(ch), pair));\n\tWINDOW_EXT(win, addch_used) = 0;\n    } else if (len == -1) {\n\t \n\tTR(TRACE_VIRTPUT, (\"Alert! mbrtowc returns error\"));\n\t \n\tWINDOW_EXT(win, addch_used) = 0;\n    }\n    return len;\n}\n#endif  \n\nstatic\n#if !USE_WIDEC_SUPPORT\t\t \nNCURSES_INLINE\n#endif\nint\nwaddch_literal(WINDOW *win, NCURSES_CH_T ch)\n{\n    int x;\n    int y;\n    struct ldat *line;\n\n    x = win->_curx;\n    y = win->_cury;\n\n    CHECK_POSITION(win, x, y);\n\n    ch = render_char(win, ch);\n\n    line = win->_line + y;\n\n    CHANGED_CELL(line, x);\n\n     \n#if NCURSES_SP_FUNCS\n#define DeriveSP() SCREEN *sp = _nc_screen_of(win);\n#else\n#define DeriveSP()\t\t \n#endif\n    if_WIDEC({\n\tDeriveSP();\n\tif (WINDOW_EXT(win, addch_used) != 0 || !Charable(ch)) {\n\t    int len = _nc_build_wch(win, CHREF(ch));\n\n\t    if (len >= -1) {\n\t\tattr_t attr = AttrOf(ch);\n\n\t\t \n\t\tif (len == -1 && is8bits(CharOf(ch))) {\n\t\t    const char *s = NCURSES_SP_NAME(unctrl)\n\t\t      (NCURSES_SP_ARGx (chtype) CharOf(ch));\n\n\t\t    if (s[1] != '\\0') {\n\t\t\tint rc = OK;\n\t\t\twhile (*s != '\\0') {\n\t\t\t    rc = waddch(win, UChar(*s) | attr);\n\t\t\t    if (rc != OK)\n\t\t\t\tbreak;\n\t\t\t    ++s;\n\t\t\t}\n\t\t\treturn rc;\n\t\t    }\n\t\t}\n\t\tif (len == -1)\n\t\t    return waddch(win, ' ' | attr);\n\t    } else {\n\t\treturn OK;\n\t    }\n\t}\n    });\n\n     \n    if_WIDEC({\n\tint len = _nc_wacs_width(CharOf(ch));\n\tint i;\n\tint j;\n\n\tif (len == 0) {\t\t \n\t    if ((x > 0 && y >= 0)\n\t\t|| (win->_maxx >= 0 && win->_cury >= 1)) {\n\t\tNCURSES_CH_T *dst;\n\t\twchar_t *chars;\n\t\tif (x > 0 && y >= 0) {\n\t\t    for (j = x - 1; j >= 0; --j) {\n\t\t\tif (!isWidecExt(win->_line[y].text[j])) {\n\t\t\t    win->_curx = (NCURSES_SIZE_T) j;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    dst = &(win->_line[y].text[j]);\n\t\t} else {\n\t\t    dst = &(win->_line[y - 1].text[win->_maxx]);\n\t\t}\n\t\tchars = dst->chars;\n\t\tfor (i = 0; i < CCHARW_MAX; ++i) {\n\t\t    if (chars[i] == 0) {\n\t\t\tTR(TRACE_VIRTPUT,\n\t\t\t   (\"adding non-spacing %s (level %d)\",\n\t\t\t    _tracech_t(CHREF(ch)), i));\n\t\t\tchars[i] = CharOf(ch);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    goto testwrapping;\n\t} else if (len > 1) {\t \n\t     \n\t    if (len > win->_maxx + 1) {\n\t\tTR(TRACE_VIRTPUT, (\"character will not fit\"));\n\t\treturn ERR;\n\t    } else if (x + len > win->_maxx + 1) {\n\t\tint count = win->_maxx + 1 - x;\n\t\tTR(TRACE_VIRTPUT, (\"fill %d remaining cells\", count));\n\t\tfill_cells(win, count);\n\t\tif (wrap_to_next_line(win) == ERR)\n\t\t    return ERR;\n\t\tx = win->_curx;\n\t\ty = win->_cury;\n\t\tCHECK_POSITION(win, x, y);\n\t\tline = win->_line + y;\n\t    }\n\t     \n\t    for (i = 0; i < len; ++i) {\n\t\tif (isWidecBase(win->_line[y].text[x + i])) {\n\t\t    break;\n\t\t} else if (isWidecExt(win->_line[y].text[x + i])) {\n\t\t    for (j = i; x + j <= win->_maxx; ++j) {\n\t\t\tif (!isWidecExt(win->_line[y].text[x + j])) {\n\t\t\t    TR(TRACE_VIRTPUT, (\"fill %d orphan cells\", j));\n\t\t\t    fill_cells(win, j);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t     \n\t    for (i = 0; i < len; ++i) {\n\t\tNCURSES_CH_T value = ch;\n\t\tSetWidecExt(value, i);\n\t\tTR(TRACE_VIRTPUT, (\"multicolumn %d:%d (%d,%d)\",\n\t\t\t\t   i + 1, len,\n\t\t\t\t   win->_begy + y, win->_begx + x));\n\t\tline->text[x] = value;\n\t\tCHANGED_CELL(line, x);\n\t\t++x;\n\t    }\n\t    goto testwrapping;\n\t}\n    });\n\n     \n    line->text[x++] = ch;\n     \n    if_WIDEC(\n  testwrapping:\n    );\n\n    TR(TRACE_VIRTPUT, (\"cell (%d, %d..%d) = %s\",\n\t\t       win->_cury, win->_curx, x - 1,\n\t\t       _tracech_t(CHREF(line->text[win->_curx]))));\n\n    if (x > win->_maxx) {\n\treturn wrap_to_next_line(win);\n    }\n    win->_curx = (NCURSES_SIZE_T) x;\n    return OK;\n}\n\nstatic NCURSES_INLINE int\nwaddch_nosync(WINDOW *win, const NCURSES_CH_T ch)\n \n{\n    NCURSES_SIZE_T x, y;\n    chtype t = (chtype) CharOf(ch);\n#if USE_WIDEC_SUPPORT || NCURSES_SP_FUNCS || USE_REENTRANT\n    SCREEN *sp = _nc_screen_of(win);\n#endif\n    const char *s = NCURSES_SP_NAME(unctrl) (NCURSES_SP_ARGx t);\n    int tabsize = 8;\n\n     \n    if ((AttrOf(ch) & A_ALTCHARSET)\n\t|| (\n#if USE_WIDEC_SUPPORT\n\t       (sp != 0 && sp->_legacy_coding) &&\n#endif\n\t       s[1] == 0\n\t)\n\t|| (\n\t       (isprint((int) t) && !iscntrl((int) t))\n#if USE_WIDEC_SUPPORT\n\t       || ((sp == 0 || !sp->_legacy_coding) &&\n\t\t   (WINDOW_EXT(win, addch_used)\n\t\t    || !_nc_is_charable(CharOf(ch))))\n#endif\n\t)) {\n\treturn waddch_literal(win, ch);\n    }\n\n     \n    x = win->_curx;\n    y = win->_cury;\n    CHECK_POSITION(win, x, y);\n\n    switch (t) {\n    case '\\t':\n#if USE_REENTRANT\n\ttabsize = *ptrTabsize(sp);\n#else\n\ttabsize = TABSIZE;\n#endif\n\tx = (NCURSES_SIZE_T) (x + (tabsize - (x % tabsize)));\n\t \n\tif ((!win->_scroll && (y == win->_regbottom))\n\t    || (x <= win->_maxx)) {\n\t    NCURSES_CH_T blank = blankchar;\n\t    AddAttr(blank, AttrOf(ch));\n\t    while (win->_curx < x) {\n\t\tif (waddch_literal(win, blank) == ERR)\n\t\t    return (ERR);\n\t    }\n\t    break;\n\t} else {\n\t    wclrtoeol(win);\n\t    win->_flags |= _WRAPPED;\n\t    if (newline_forces_scroll(win, &y)) {\n\t\tx = win->_maxx;\n\t\tif (win->_scroll) {\n\t\t    scroll(win);\n\t\t    x = 0;\n\t\t}\n\t    } else {\n\t\tx = 0;\n\t    }\n\t}\n\tbreak;\n    case '\\n':\n\twclrtoeol(win);\n\tif (newline_forces_scroll(win, &y)) {\n\t    if (win->_scroll)\n\t\tscroll(win);\n\t    else\n\t\treturn (ERR);\n\t}\n\t \n    case '\\r':\n\tx = 0;\n\twin->_flags &= ~_WRAPPED;\n\tbreak;\n    case '\\b':\n\tif (x == 0)\n\t    return (OK);\n\tx--;\n\twin->_flags &= ~_WRAPPED;\n\tbreak;\n    default:\n\twhile (*s) {\n\t    NCURSES_CH_T sch;\n\t    SetChar(sch, UChar(*s++), AttrOf(ch));\n\t    if_EXT_COLORS(SetPair(sch, GetPair(ch)));\n\t    if (waddch_literal(win, sch) == ERR)\n\t\treturn ERR;\n\t}\n\treturn (OK);\n    }\n\n    win->_curx = x;\n    win->_cury = y;\n\n    return (OK);\n}\n\nNCURSES_EXPORT(int)\n_nc_waddch_nosync(WINDOW *win, const NCURSES_CH_T c)\n \n{\n    return (waddch_nosync(win, c));\n}\n\n \n\n \n\nNCURSES_EXPORT(int)\nwaddch(WINDOW *win, const chtype ch)\n{\n    int code = ERR;\n    NCURSES_CH_T wch;\n    SetChar2(wch, ch);\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED(\"waddch(%p, %s)\"), (void *) win,\n\t\t\t\t      _tracechtype(ch)));\n\n    if (win && (waddch_nosync(win, wch) != ERR)) {\n\t_nc_synchook(win);\n\tcode = OK;\n    }\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n\nNCURSES_EXPORT(int)\nwechochar(WINDOW *win, const chtype ch)\n{\n    int code = ERR;\n    NCURSES_CH_T wch;\n    SetChar2(wch, ch);\n\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_CALLED(\"wechochar(%p, %s)\"),\n\t\t\t\t      (void *) win,\n\t\t\t\t      _tracechtype(ch)));\n\n    if (win && (waddch_nosync(win, wch) != ERR)) {\n\tbool save_immed = win->_immed;\n\twin->_immed = TRUE;\n\t_nc_synchook(win);\n\twin->_immed = save_immed;\n\tcode = OK;\n    }\n    TR(TRACE_VIRTPUT | TRACE_CCALLS, (T_RETURN(\"%d\"), code));\n    return (code);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}