{
  "module_name": "lib_getch.c",
  "hash_id": "9b421e2af1fbd9f856739a0a6dd1f07f752a8747f5694166a8932971d4033ef7",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/base/lib_getch.c",
  "human_readable_source": " \n\n \n\n \n\n#define NEED_KEY_EVENT\n#include <curses.priv.h>\n\nMODULE_ID(\"$Id: lib_getch.c,v 1.145 2022/12/24 22:38:38 tom Exp $\")\n\n#include <fifo_defs.h>\n\n#if USE_REENTRANT\n#define GetEscdelay(sp) *_nc_ptr_Escdelay(sp)\nNCURSES_EXPORT(int)\nNCURSES_PUBLIC_VAR(ESCDELAY) (void)\n{\n    return *(_nc_ptr_Escdelay(CURRENT_SCREEN));\n}\n\nNCURSES_EXPORT(int *)\n_nc_ptr_Escdelay(SCREEN *sp)\n{\n    return ptrEscdelay(sp);\n}\n#else\n#define GetEscdelay(sp) ESCDELAY\nNCURSES_EXPORT_VAR(int) ESCDELAY = 1000;\n#endif\n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(set_escdelay) (NCURSES_SP_DCLx int value)\n{\n    int code = OK;\n    if (value < 0) {\n\tcode = ERR;\n    } else {\n#if USE_REENTRANT\n\tif (SP_PARM) {\n\t    SET_ESCDELAY(value);\n\t} else {\n\t    code = ERR;\n\t}\n#else\n\t(void) SP_PARM;\n\tESCDELAY = value;\n#endif\n    }\n    return code;\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nset_escdelay(int value)\n{\n    int code;\n    if (value < 0) {\n\tcode = ERR;\n    } else {\n#if USE_REENTRANT\n\tcode = NCURSES_SP_NAME(set_escdelay) (CURRENT_SCREEN, value);\n#else\n\tESCDELAY = value;\n\tcode = OK;\n#endif\n    }\n    return code;\n}\n#endif\n#endif  \n\n#if NCURSES_EXT_FUNCS\nNCURSES_EXPORT(int)\nNCURSES_SP_NAME(get_escdelay) (NCURSES_SP_DCL0)\n{\n#if !USE_REENTRANT\n    (void) SP_PARM;\n#endif\n    return GetEscdelay(SP_PARM);\n}\n\n#if NCURSES_SP_FUNCS\nNCURSES_EXPORT(int)\nget_escdelay(void)\n{\n    return NCURSES_SP_NAME(get_escdelay) (CURRENT_SCREEN);\n}\n#endif\n#endif  \n\nstatic int\n_nc_use_meta(WINDOW *win)\n{\n    SCREEN *sp = _nc_screen_of(win);\n    return (sp ? sp->_use_meta : 0);\n}\n\n#ifdef USE_TERM_DRIVER\n# if defined(_NC_WINDOWS) && !defined(EXP_WIN32_DRIVER)\nstatic HANDLE\n_nc_get_handle(int fd)\n{\n    intptr_t value = _get_osfhandle(fd);\n    return (HANDLE) value;\n}\n# endif\n#endif\n\n \nstatic int\ncheck_mouse_activity(SCREEN *sp, int delay EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc;\n\n#ifdef USE_TERM_DRIVER\n    TERMINAL_CONTROL_BLOCK *TCB = TCBOf(sp);\n    rc = TCBOf(sp)->drv->td_testmouse(TCBOf(sp), delay EVENTLIST_2nd(evl));\n# if defined(EXP_WIN32_DRIVER)\n     \n    if (IsTermInfoOnConsole(sp)) {\n\trc = _nc_console_testmouse(sp,\n\t\t\t\t   _nc_console_handle(sp->_ifd),\n\t\t\t\t   delay EVENTLIST_2nd(evl));\n    } else\n# elif defined(_NC_WINDOWS)\n     \n    if (IsTermInfoOnConsole(sp)) {\n\tHANDLE fd = _nc_get_handle(sp->_ifd);\n\trc = _nc_mingw_testmouse(sp, fd, delay EVENTLIST_2nd(evl));\n    } else\n# endif\n\trc = TCB->drv->td_testmouse(TCB, delay EVENTLIST_2nd(evl));\n#else  \n# if USE_SYSMOUSE\n    if ((sp->_mouse_type == M_SYSMOUSE)\n\t&& (sp->_sysmouse_head < sp->_sysmouse_tail)) {\n\trc = TW_MOUSE;\n    } else\n# endif\n    {\n# if defined(EXP_WIN32_DRIVER)\n\trc = _nc_console_testmouse(sp,\n\t\t\t\t   _nc_console_handle(sp->_ifd),\n\t\t\t\t   delay\n\t\t\t\t   EVENTLIST_2nd(evl));\n# else\n\trc = _nc_timed_wait(sp,\n\t\t\t    TWAIT_MASK,\n\t\t\t    delay,\n\t\t\t    (int *) 0\n\t\t\t    EVENTLIST_2nd(evl));\n# endif\n# if USE_SYSMOUSE\n\tif ((sp->_mouse_type == M_SYSMOUSE)\n\t    && (sp->_sysmouse_head < sp->_sysmouse_tail)\n\t    && (rc == 0)\n\t    && (errno == EINTR)) {\n\t    rc |= TW_MOUSE;\n\t}\n# endif\n    }\n#endif  \n    return rc;\n}\n\nstatic NCURSES_INLINE int\nfifo_peek(SCREEN *sp)\n{\n    int ch = (peek >= 0) ? sp->_fifo[peek] : ERR;\n    TR(TRACE_IEVENT, (\"peeking at %d\", peek));\n\n    p_inc();\n    return ch;\n}\n\nstatic NCURSES_INLINE int\nfifo_pull(SCREEN *sp)\n{\n    int ch = (head >= 0) ? sp->_fifo[head] : ERR;\n\n    TR(TRACE_IEVENT, (\"pulling %s from %d\", _nc_tracechar(sp, ch), head));\n\n    if (peek == head) {\n\th_inc();\n\tpeek = head;\n    } else {\n\th_inc();\n    }\n\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_IEVENT)) {\n\t_nc_fifo_dump(sp);\n\t_nc_unlock_global(tracef);\n    }\n#endif\n    return ch;\n}\n\nstatic NCURSES_INLINE int\nfifo_push(SCREEN *sp EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int n;\n    int ch = 0;\n    int mask = 0;\n\n    (void) mask;\n    if (tail < 0)\n\treturn ERR;\n\n#ifdef NCURSES_WGETCH_EVENTS\n    if (evl\n#if USE_GPM_SUPPORT || USE_EMX_MOUSE || USE_SYSMOUSE\n\t|| (sp->_mouse_fd >= 0)\n#endif\n\t) {\n\tmask = check_mouse_activity(sp, -1 EVENTLIST_2nd(evl));\n    } else\n\tmask = 0;\n\n    if (mask & TW_EVENT) {\n\tT((\"fifo_push: ungetch KEY_EVENT\"));\n\tsafe_ungetch(sp, KEY_EVENT);\n\treturn KEY_EVENT;\n    }\n#elif USE_GPM_SUPPORT || USE_EMX_MOUSE || USE_SYSMOUSE\n    if (sp->_mouse_fd >= 0) {\n\tmask = check_mouse_activity(sp, -1 EVENTLIST_2nd(evl));\n    }\n#endif\n\n#if USE_GPM_SUPPORT || USE_EMX_MOUSE\n    if ((sp->_mouse_fd >= 0) && (mask & TW_MOUSE)) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else\n#endif\n#if USE_SYSMOUSE\n\tif ((sp->_mouse_type == M_SYSMOUSE)\n\t    && (sp->_sysmouse_head < sp->_sysmouse_tail)) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else if ((sp->_mouse_type == M_SYSMOUSE)\n\t       && (mask <= 0) && errno == EINTR) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else\n#endif\n#ifdef USE_TERM_DRIVER\n\tif ((sp->_mouse_type == M_TERM_DRIVER)\n\t    && (sp->_drv_mouse_head < sp->_drv_mouse_tail)) {\n\tsp->_mouse_event(sp);\n\tch = KEY_MOUSE;\n\tn = 1;\n    } else\n#endif\n#if USE_KLIBC_KBD\n    if (NC_ISATTY(sp->_ifd) && sp->_cbreak) {\n\tch = _read_kbd(0, 1, !sp->_raw);\n\tn = (ch == -1) ? -1 : 1;\n\tsp->_extended_key = (ch == 0);\n    } else\n#endif\n    {\t\t\t\t \n#if defined(USE_TERM_DRIVER)\n\tint buf;\n# if defined(EXP_WIN32_DRIVER)\n\tif (NC_ISATTY(sp->_ifd) && IsTermInfoOnConsole(sp) && sp->_cbreak) {\n\t    _nc_set_read_thread(TRUE);\n\t    n = _nc_console_read(sp,\n\t\t\t\t _nc_console_handle(sp->_ifd),\n\t\t\t\t &buf);\n\t    _nc_set_read_thread(FALSE);\n\t} else\n# elif defined(_NC_WINDOWS)\n\tif (NC_ISATTY(sp->_ifd) && IsTermInfoOnConsole(sp) && sp->_cbreak)\n\t    n = _nc_mingw_console_read(sp,\n\t\t\t\t       _nc_get_handle(sp->_ifd),\n\t\t\t\t       &buf);\n\telse\n# endif\t \n\t    n = CallDriver_1(sp, td_read, &buf);\n\tch = buf;\n#else  \n#if defined(EXP_WIN32_DRIVER)\n\tint buf;\n#endif\n\tunsigned char c2 = 0;\n\n\t_nc_set_read_thread(TRUE);\n#if defined(EXP_WIN32_DRIVER)\n\tn = _nc_console_read(sp,\n\t\t\t     _nc_console_handle(sp->_ifd),\n\t\t\t     &buf);\n\tc2 = buf;\n#else\n\tn = (int) read(sp->_ifd, &c2, (size_t) 1);\n#endif\n\t_nc_set_read_thread(FALSE);\n\tch = c2;\n#endif  \n    }\n\n    if ((n == -1) || (n == 0)) {\n\tTR(TRACE_IEVENT, (\"read(%d,&ch,1)=%d, errno=%d\", sp->_ifd, n, errno));\n\tch = ERR;\n    }\n    TR(TRACE_IEVENT, (\"read %d characters\", n));\n\n    sp->_fifo[tail] = ch;\n    sp->_fifohold = 0;\n    if (head == -1)\n\thead = peek = tail;\n    t_inc();\n    TR(TRACE_IEVENT, (\"pushed %s at %d\", _nc_tracechar(sp, ch), tail));\n#ifdef TRACE\n    if (USE_TRACEF(TRACE_IEVENT)) {\n\t_nc_fifo_dump(sp);\n\t_nc_unlock_global(tracef);\n    }\n#endif\n    return ch;\n}\n\nstatic NCURSES_INLINE void\nfifo_clear(SCREEN *sp)\n{\n    memset(sp->_fifo, 0, sizeof(sp->_fifo));\n    head = -1;\n    tail = peek = 0;\n}\n\nstatic int kgetch(SCREEN *, bool EVENTLIST_2nd(_nc_eventlist *));\n\nstatic void\nrecur_wrefresh(WINDOW *win)\n{\n#ifdef USE_PTHREADS\n    SCREEN *sp = _nc_screen_of(win);\n    bool same_sp;\n\n    if (_nc_use_pthreads) {\n\t_nc_lock_global(curses);\n\tsame_sp = (sp == CURRENT_SCREEN);\n\t_nc_unlock_global(curses);\n    } else {\n\tsame_sp = (sp == CURRENT_SCREEN);\n    }\n\n    if (_nc_use_pthreads && !same_sp) {\n\tSCREEN *save_SP;\n\n\t \n\t_nc_lock_global(curses);\n\tsave_SP = CURRENT_SCREEN;\n\t_nc_set_screen(sp);\n\trecur_wrefresh(win);\n\t_nc_set_screen(save_SP);\n\t_nc_unlock_global(curses);\n    } else\n#endif\n\tif ((is_wintouched(win) || (win->_flags & _HASMOVED))\n\t    && !IS_PAD(win)) {\n\twrefresh(win);\n    }\n}\n\nstatic int\nrecur_wgetnstr(WINDOW *win, char *buf)\n{\n    SCREEN *sp = _nc_screen_of(win);\n    int rc;\n\n    if (sp != 0) {\n#ifdef USE_PTHREADS\n\tif (_nc_use_pthreads && sp != CURRENT_SCREEN) {\n\t    SCREEN *save_SP;\n\n\t     \n\t    _nc_lock_global(curses);\n\t    save_SP = CURRENT_SCREEN;\n\t    _nc_set_screen(sp);\n\t    rc = recur_wgetnstr(win, buf);\n\t    _nc_set_screen(save_SP);\n\t    _nc_unlock_global(curses);\n\t} else\n#endif\n\t{\n\t    sp->_called_wgetch = TRUE;\n\t    rc = wgetnstr(win, buf, MAXCOLUMNS);\n\t    sp->_called_wgetch = FALSE;\n\t}\n    } else {\n\trc = ERR;\n    }\n    return rc;\n}\n\nNCURSES_EXPORT(int)\n_nc_wgetch(WINDOW *win,\n\t   int *result,\n\t   int use_meta\n\t   EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    SCREEN *sp;\n    int ch;\n    int rc = 0;\n#ifdef NCURSES_WGETCH_EVENTS\n    int event_delay = -1;\n#endif\n\n    T((T_CALLED(\"_nc_wgetch(%p)\"), (void *) win));\n\n    *result = 0;\n\n    sp = _nc_screen_of(win);\n    if (win == 0 || sp == 0) {\n\treturnCode(ERR);\n    }\n\n    if (cooked_key_in_fifo()) {\n\trecur_wrefresh(win);\n\t*result = fifo_pull(sp);\n\treturnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);\n    }\n#ifdef NCURSES_WGETCH_EVENTS\n    if (evl && (evl->count == 0))\n\tevl = NULL;\n    event_delay = _nc_eventlist_timeout(evl);\n#endif\n\n     \n    if (head == -1 &&\n\t!sp->_notty &&\n\t!sp->_raw &&\n\t!sp->_cbreak &&\n\t!sp->_called_wgetch) {\n\tchar buf[MAXCOLUMNS], *bufp;\n\n\tTR(TRACE_IEVENT, (\"filling queue in cooked mode\"));\n\n\t \n#ifdef NCURSES_WGETCH_EVENTS\n\trc = recur_wgetnstr(win, buf);\n\tif (rc != KEY_EVENT && rc != ERR)\n\t    safe_ungetch(sp, '\\n');\n#else\n\tif (recur_wgetnstr(win, buf) != ERR)\n\t    safe_ungetch(sp, '\\n');\n#endif\n\tfor (bufp = buf + strlen(buf); bufp > buf; bufp--)\n\t    safe_ungetch(sp, bufp[-1]);\n\n#ifdef NCURSES_WGETCH_EVENTS\n\t \n\tif (rc == KEY_EVENT) {\n\t    *result = rc;\n\t} else\n#endif\n\t    *result = fifo_pull(sp);\n\treturnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);\n    }\n\n    if (win->_use_keypad != sp->_keypad_on)\n\t_nc_keypad(sp, win->_use_keypad);\n\n    recur_wrefresh(win);\n\n    if (win->_notimeout || (win->_delay >= 0) || (sp->_cbreak > 1)) {\n\tif (head == -1) {\t \n\t    int delay;\n\n\t    TR(TRACE_IEVENT, (\"timed delay in wgetch()\"));\n\t    if (sp->_cbreak > 1)\n\t\tdelay = (sp->_cbreak - 1) * 100;\n\t    else\n\t\tdelay = win->_delay;\n\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (event_delay >= 0 && delay > event_delay)\n\t\tdelay = event_delay;\n#endif\n\n\t    TR(TRACE_IEVENT, (\"delay is %d milliseconds\", delay));\n\n\t    rc = check_mouse_activity(sp, delay EVENTLIST_2nd(evl));\n\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (rc & TW_EVENT) {\n\t\t*result = KEY_EVENT;\n\t\treturnCode(KEY_CODE_YES);\n\t    }\n#endif\n\t    if (!rc) {\n\t\tgoto check_sigwinch;\n\t    }\n\t}\n\t \n    }\n\n    if (win->_use_keypad) {\n\t \n\tint runcount = 0;\n\n\tdo {\n\t    ch = kgetch(sp, win->_notimeout EVENTLIST_2nd(evl));\n\t    if (ch == KEY_MOUSE) {\n\t\t++runcount;\n\t\tif (sp->_mouse_inline(sp))\n\t\t    break;\n\t    }\n\t    if (sp->_maxclick < 0)\n\t\tbreak;\n\t} while\n\t    (ch == KEY_MOUSE\n\t     && (((rc = check_mouse_activity(sp, sp->_maxclick\n\t\t\t\t\t     EVENTLIST_2nd(evl))) != 0\n\t\t  && !(rc & TW_EVENT))\n\t\t || !sp->_mouse_parse(sp, runcount)));\n#ifdef NCURSES_WGETCH_EVENTS\n\tif ((rc & TW_EVENT) && !(ch == KEY_EVENT)) {\n\t    safe_ungetch(sp, ch);\n\t    ch = KEY_EVENT;\n\t}\n#endif\n\tif (runcount > 0 && ch != KEY_MOUSE) {\n#ifdef NCURSES_WGETCH_EVENTS\n\t     \n\t    if (ch == KEY_EVENT) {\n\t\tsafe_ungetch(sp, KEY_MOUSE);\t \n\t    } else\n#endif\n\t    {\n\t\t \n\t\tsafe_ungetch(sp, ch);\n\t\tch = KEY_MOUSE;\n\t    }\n\t}\n    } else {\n\tif (head == -1)\n\t    fifo_push(sp EVENTLIST_2nd(evl));\n\tch = fifo_pull(sp);\n    }\n\n    if (ch == ERR) {\n      check_sigwinch:\n#if USE_SIZECHANGE\n\tif (_nc_handle_sigwinch(sp)) {\n\t    _nc_update_screensize(sp);\n\t     \n\t    if (cooked_key_in_fifo()) {\n\t\t*result = fifo_pull(sp);\n\t\t \n\t\tif (fifo_peek(sp) == -1)\n\t\t    fifo_pull(sp);\n\t\treturnCode(*result >= KEY_MIN ? KEY_CODE_YES : OK);\n\t    }\n\t}\n#endif\n\treturnCode(ERR);\n    }\n\n     \n    if (sp->_echo && !IS_PAD(win)) {\n\tchtype backup = (chtype) ((ch == KEY_BACKSPACE) ? '\\b' : ch);\n\tif (backup < KEY_MIN)\n\t    wechochar(win, backup);\n    }\n\n     \n    if ((ch == '\\r') && sp->_nl)\n\tch = '\\n';\n\n     \n    if (!use_meta)\n\tif ((ch < KEY_MIN) && (ch & 0x80))\n\t    ch &= 0x7f;\n\n    T((\"wgetch returning : %s\", _nc_tracechar(sp, ch)));\n\n    *result = ch;\n    returnCode(ch >= KEY_MIN ? KEY_CODE_YES : OK);\n}\n\n#ifdef NCURSES_WGETCH_EVENTS\nNCURSES_EXPORT(int)\nwgetch_events(WINDOW *win, _nc_eventlist * evl)\n{\n    int code;\n    int value;\n\n    T((T_CALLED(\"wgetch_events(%p,%p)\"), (void *) win, (void *) evl));\n    code = _nc_wgetch(win,\n\t\t      &value,\n\t\t      _nc_use_meta(win)\n\t\t      EVENTLIST_2nd(evl));\n    if (code != ERR)\n\tcode = value;\n    returnCode(code);\n}\n#endif\n\nNCURSES_EXPORT(int)\nwgetch(WINDOW *win)\n{\n    int code;\n    int value;\n\n    T((T_CALLED(\"wgetch(%p)\"), (void *) win));\n    code = _nc_wgetch(win,\n\t\t      &value,\n\t\t      _nc_use_meta(win)\n\t\t      EVENTLIST_2nd((_nc_eventlist *) 0));\n    if (code != ERR)\n\tcode = value;\n    returnCode(code);\n}\n\n \n\nstatic int\nkgetch(SCREEN *sp, bool forever EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    TRIES *ptr;\n    int ch = 0;\n    int timeleft = forever ? 9999999 : GetEscdelay(sp);\n\n    TR(TRACE_IEVENT, (\"kgetch() called\"));\n\n    ptr = sp->_keytry;\n\n    for (;;) {\n\tif (cooked_key_in_fifo() && sp->_fifo[head] >= KEY_MIN) {\n\t    break;\n\t} else if (!raw_key_in_fifo()) {\n\t    ch = fifo_push(sp EVENTLIST_2nd(evl));\n\t    if (ch == ERR) {\n\t\tpeek = head;\t \n\t\treturn ERR;\n\t    }\n#ifdef NCURSES_WGETCH_EVENTS\n\t    else if (ch == KEY_EVENT) {\n\t\tpeek = head;\t \n\t\treturn fifo_pull(sp);\t \n\t    }\n#endif\n\t}\n\n\tch = fifo_peek(sp);\n\tif (ch >= KEY_MIN) {\n\t     \n\t    peek = head;\n\t     \n\t    t_dec();\t\t \n\t    return ch;\n\t}\n\n\tTR(TRACE_IEVENT, (\"ch: %s\", _nc_tracechar(sp, (unsigned char) ch)));\n\twhile ((ptr != NULL) && (ptr->ch != (unsigned char) ch))\n\t    ptr = ptr->sibling;\n\n\tif (ptr == NULL) {\n\t    TR(TRACE_IEVENT, (\"ptr is null\"));\n\t    break;\n\t}\n\tTR(TRACE_IEVENT, (\"ptr=%p, ch=%d, value=%d\",\n\t\t\t  (void *) ptr, ptr->ch, ptr->value));\n\n\tif (ptr->value != 0) {\t \n\t    TR(TRACE_IEVENT, (\"end of sequence\"));\n\t    if (peek == tail) {\n\t\tfifo_clear(sp);\n\t    } else {\n\t\thead = peek;\n\t    }\n\t    return (ptr->value);\n\t}\n\n\tptr = ptr->child;\n\n\tif (!raw_key_in_fifo()) {\n\t    int rc;\n\n\t    TR(TRACE_IEVENT, (\"waiting for rest of sequence\"));\n\t    rc = check_mouse_activity(sp, timeleft EVENTLIST_2nd(evl));\n#ifdef NCURSES_WGETCH_EVENTS\n\t    if (rc & TW_EVENT) {\n\t\tTR(TRACE_IEVENT, (\"interrupted by a user event\"));\n\t\t \n\t\tpeek = head;\t \n\t\treturn KEY_EVENT;\n\t    }\n#endif\n\t    if (!rc) {\n\t\tTR(TRACE_IEVENT, (\"ran out of time\"));\n\t\tbreak;\n\t    }\n\t}\n    }\n    ch = fifo_pull(sp);\n    peek = head;\n    return ch;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}