{
  "module_name": "win32_driver.c",
  "hash_id": "4aeca0b5df8a285613c754214c0b677d0b2a3a035811724449feb26798186d7b",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/win32con/win32_driver.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n#ifdef _NC_WINDOWS\n#if (defined(__MINGW32__) || defined(__MINGW64__))\n#include <wchar.h>\n#else\n#include <tchar.h>\n#endif\n#include <io.h>\n\n#define CUR TerminalType(my_term).\n\nMODULE_ID(\"$Id: win32_driver.c,v 1.2 2020/11/21 23:35:56 tom Exp $\")\n\n#define WINMAGIC NCDRV_MAGIC(NCDRV_WINCONSOLE)\n#define EXP_OPTIMIZE 0\n\nstatic bool console_initialized = FALSE;\n\n#define AssertTCB() assert(TCB != 0 && (TCB->magic == WINMAGIC))\n#define validateConsoleHandle() (AssertTCB() , console_initialized ||\\\n                                 (console_initialized=\\\n                                  _nc_console_checkinit(TRUE,FALSE)))\n#define SetSP() assert(TCB->csp != 0); sp = TCB->csp; (void) sp\n#define AdjustY() (WINCONSOLE.buffered ?\\\n                   0 : (int) WINCONSOLE.SBI.srWindow.Top)\n#define RevAttr(attr) (WORD) (((attr) & 0xff00) |   \\\n                              ((((attr) & 0x07) << 4) | \\\n                               (((attr) & 0x70) >> 4)))\n\n#if USE_WIDEC_SUPPORT\n#define write_screen WriteConsoleOutputW\n#define read_screen  ReadConsoleOutputW\n#else\n#define write_screen WriteConsoleOutput\n#define read_screen  ReadConsoleOutput\n#endif\n\nstatic WORD\nMapAttr(WORD res, attr_t ch)\n{\n    if (ch & A_COLOR) {\n\tint p;\n\n\tp = PairNumber(ch);\n\tif (p > 0 && p < CON_NUMPAIRS) {\n\t    WORD a;\n\t    a = WINCONSOLE.pairs[p];\n\t    res = (WORD) ((res & 0xff00) | a);\n\t}\n    }\n\n    if (ch & A_REVERSE) {\n\tres = RevAttr(res);\n    }\n\n    if (ch & A_STANDOUT) {\n\tres = RevAttr(res) | BACKGROUND_INTENSITY;\n    }\n\n    if (ch & A_BOLD)\n\tres |= FOREGROUND_INTENSITY;\n\n    if (ch & A_DIM)\n\tres |= BACKGROUND_INTENSITY;\n\n    return res;\n}\n\n#if 0\t\t\t\t \nstatic void\ndump_screen(const char *fn, int ln)\n{\n    int max_cells = (WINCONSOLE.SBI.dwSize.Y *\n\t\t     (1 + WINCONSOLE.SBI.dwSize.X)) + 1;\n    char output[max_cells];\n    CHAR_INFO save_screen[max_cells];\n    COORD save_size;\n    SMALL_RECT save_region;\n    COORD bufferCoord;\n\n    T((\"dump_screen %s@%d\", fn, ln));\n\n    save_region.Top = WINCONSOLE.SBI.srWindow.Top;\n    save_region.Left = WINCONSOLE.SBI.srWindow.Left;\n    save_region.Bottom = WINCONSOLE.SBI.srWindow.Bottom;\n    save_region.Right = WINCONSOLE.SBI.srWindow.Right;\n\n    save_size.X = (SHORT) (save_region.Right - save_region.Left + 1);\n    save_size.Y = (SHORT) (save_region.Bottom - save_region.Top + 1);\n\n    bufferCoord.X = bufferCoord.Y = 0;\n\n    if (read_screen(WINCONSOLE.hdl,\n\t\t    save_screen,\n\t\t    save_size,\n\t\t    bufferCoord,\n\t\t    &save_region)) {\n\tint i, j;\n\tint ij = 0;\n\tint k = 0;\n\n\tfor (i = save_region.Top; i <= save_region.Bottom; ++i) {\n\t    for (j = save_region.Left; j <= save_region.Right; ++j) {\n\t\toutput[k++] = save_screen[ij++].Char.AsciiChar;\n\t    }\n\t    output[k++] = '\\n';\n\t}\n\toutput[k] = 0;\n\n\tT((\"DUMP: %d,%d - %d,%d\",\n\t   save_region.Top,\n\t   save_region.Left,\n\t   save_region.Bottom,\n\t   save_region.Right));\n\tT((\"%s\", output));\n    }\n}\n\n#else\n#define dump_screen(fn,ln)\t \n#endif\n\n#if USE_WIDEC_SUPPORT\n \nstatic BOOL\ncon_write16(TERMINAL_CONTROL_BLOCK * TCB,\n\t    int y, int x, cchar_t *str, int limit)\n{\n    int actual = 0;\n    CHAR_INFO *ci = TypeAlloca(CHAR_INFO, limit);\n    COORD loc, siz;\n    SMALL_RECT rec;\n    int i;\n    cchar_t ch;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    for (i = actual = 0; i < limit; i++) {\n\tch = str[i];\n\tif (isWidecExt(ch))\n\t    continue;\n\tci[actual].Char.UnicodeChar = CharOf(ch);\n\tci[actual].Attributes = MapAttr(WINCONSOLE.SBI.wAttributes,\n\t\t\t\t\tAttrOf(ch));\n\tif (AttrOf(ch) & A_ALTCHARSET) {\n\t    if (_nc_wacs) {\n\t\tint which = CharOf(ch);\n\t\tif (which > 0\n\t\t    && which < ACS_LEN\n\t\t    && CharOf(_nc_wacs[which]) != 0) {\n\t\t    ci[actual].Char.UnicodeChar = CharOf(_nc_wacs[which]);\n\t\t} else {\n\t\t    ci[actual].Char.UnicodeChar = ' ';\n\t\t}\n\t    }\n\t}\n\t++actual;\n    }\n\n    loc.X = (SHORT) 0;\n    loc.Y = (SHORT) 0;\n    siz.X = (SHORT) actual;\n    siz.Y = 1;\n\n    rec.Left = (SHORT) x;\n    rec.Top = (SHORT) (y + AdjustY());\n    rec.Right = (SHORT) (x + limit - 1);\n    rec.Bottom = rec.Top;\n\n    return write_screen(WINCONSOLE.hdl, ci, siz, loc, &rec);\n}\n#define con_write(tcb, y, x, str, n) con_write16(tcb, y, x, str, n)\n#else\nstatic BOOL\ncon_write8(TERMINAL_CONTROL_BLOCK * TCB, int y, int x, chtype *str, int n)\n{\n    CHAR_INFO *ci = TypeAlloca(CHAR_INFO, n);\n    COORD loc, siz;\n    SMALL_RECT rec;\n    int i;\n    chtype ch;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    for (i = 0; i < n; i++) {\n\tch = str[i];\n\tci[i].Char.AsciiChar = ChCharOf(ch);\n\tci[i].Attributes = MapAttr(WINCONSOLE.SBI.wAttributes,\n\t\t\t\t   ChAttrOf(ch));\n\tif (ChAttrOf(ch) & A_ALTCHARSET) {\n\t    if (sp->_acs_map)\n\t\tci[i].Char.AsciiChar =\n\t\tChCharOf(NCURSES_SP_NAME(_nc_acs_char) (sp, ChCharOf(ch)));\n\t}\n    }\n\n    loc.X = (short) 0;\n    loc.Y = (short) 0;\n    siz.X = (short) n;\n    siz.Y = 1;\n\n    rec.Left = (short) x;\n    rec.Top = (short) y;\n    rec.Right = (short) (x + n - 1);\n    rec.Bottom = rec.Top;\n\n    return write_screen(WINCONSOLE.hdl, ci, siz, loc, &rec);\n}\n#define con_write(tcb, y, x, str, n) con_write8(tcb, y, x, str, n)\n#endif\n\n#if EXP_OPTIMIZE\n \nstatic int\nfind_end_of_change(SCREEN *sp, int row, int col)\n{\n    int result = col;\n    struct ldat *curdat = CurScreen(sp)->_line + row;\n    struct ldat *newdat = NewScreen(sp)->_line + row;\n\n    while (col <= newdat->lastchar) {\n#if USE_WIDEC_SUPPORT\n\tif (isWidecExt(curdat->text[col]) ||\n\t    isWidecExt(newdat->text[col])) {\n\t    result = col;\n\t} else if (memcmp(&curdat->text[col],\n\t\t\t  &newdat->text[col],\n\t\t\t  sizeof(curdat->text[0]))) {\n\t    result = col;\n\t} else {\n\t    break;\n\t}\n#else\n\tif (curdat->text[col] != newdat->text[col]) {\n\t    result = col;\n\t} else {\n\t    break;\n\t}\n#endif\n\t++col;\n    }\n    return result;\n}\n\n \nstatic int\nfind_next_change(SCREEN *sp, int row, int col)\n{\n    struct ldat *curdat = CurScreen(sp)->_line + row;\n    struct ldat *newdat = NewScreen(sp)->_line + row;\n    int result = newdat->lastchar + 1;\n\n    while (++col <= newdat->lastchar) {\n#if USE_WIDEC_SUPPORT\n\tif (isWidecExt(curdat->text[col]) !=\n\t    isWidecExt(newdat->text[col])) {\n\t    result = col;\n\t    break;\n\t} else if (memcmp(&curdat->text[col],\n\t\t\t  &newdat->text[col],\n\t\t\t  sizeof(curdat->text[0]))) {\n\t    result = col;\n\t    break;\n\t}\n#else\n\tif (curdat->text[col] != newdat->text[col]) {\n\t    result = col;\n\t    break;\n\t}\n#endif\n    }\n    return result;\n}\n\n#define EndChange(first) \\\n\tfind_end_of_change(sp, y, first)\n#define NextChange(last)                        \\\n\tfind_next_change(sp, y, last)\n\n#endif  \n\n#define MARK_NOCHANGE(win,row)                 \\\n    win->_line[row].firstchar = _NOCHANGE;     \\\n    win->_line[row].lastchar  = _NOCHANGE\n\nstatic bool\nrestore_original_screen(void)\n{\n    COORD bufferCoord;\n    bool result = FALSE;\n    SMALL_RECT save_region = WINCONSOLE.save_region;\n\n    T((\"... restoring %s\", WINCONSOLE.window_only ?\n       \"window\" : \"entire buffer\"));\n\n    bufferCoord.X = (SHORT) (WINCONSOLE.window_only ?\n\t\t\t     WINCONSOLE.SBI.srWindow.Left : 0);\n    bufferCoord.Y = (SHORT) (WINCONSOLE.window_only ?\n\t\t\t     WINCONSOLE.SBI.srWindow.Top : 0);\n\n    if (write_screen(WINCONSOLE.hdl,\n\t\t     WINCONSOLE.save_screen,\n\t\t     WINCONSOLE.save_size,\n\t\t     bufferCoord,\n\t\t     &save_region)) {\n\tresult = TRUE;\n\tmvcur(-1, -1, LINES - 2, 0);\n\tT((\"... restore original screen contents ok %dx%d (%d,%d - %d,%d)\",\n\t   WINCONSOLE.save_size.Y,\n\t   WINCONSOLE.save_size.X,\n\t   save_region.Top,\n\t   save_region.Left,\n\t   save_region.Bottom,\n\t   save_region.Right));\n    } else {\n\tT((\"... restore original screen contents err\"));\n    }\n    return result;\n}\n\nstatic const char *\nwcon_name(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    (void) TCB;\n    return \"win32console\";\n}\n\nstatic int\nwcon_doupdate(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    int result = ERR;\n    int y, nonempty, n, x0, x1, Width, Height;\n    SCREEN *sp;\n\n    T((T_CALLED(\"win32con::wcon_doupdate(%p)\"), TCB));\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tWidth = screen_columns(sp);\n\tHeight = screen_lines(sp);\n\tnonempty = min(Height, NewScreen(sp)->_maxy + 1);\n\n\tT((\"... %dx%d clear cur:%d new:%d\",\n\t   Height, Width,\n\t   CurScreen(sp)->_clear,\n\t   NewScreen(sp)->_clear));\n\n\tif (SP_PARM->_endwin == ewSuspend) {\n\n\t    T((\"coming back from shell mode\"));\n\t    NCURSES_SP_NAME(reset_prog_mode) (NCURSES_SP_ARG);\n\n\t    NCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_ARG);\n\t    SP_PARM->_mouse_resume(SP_PARM);\n\n\t    SP_PARM->_endwin = ewRunning;\n\t}\n\n\tif ((CurScreen(sp)->_clear || NewScreen(sp)->_clear)) {\n\t    int x;\n#if USE_WIDEC_SUPPORT\n\t    cchar_t *empty = TypeAlloca(cchar_t, Width);\n\t    wchar_t blank[2] =\n\t    {\n\t\tL' ', L'\\0'\n\t    };\n\n\t    for (x = 0; x < Width; x++)\n\t\tsetcchar(&empty[x], blank, 0, 0, 0);\n#else\n\t    chtype *empty = TypeAlloca(chtype, Width);\n\n\t    for (x = 0; x < Width; x++)\n\t\tempty[x] = ' ';\n#endif\n\n\t    for (y = 0; y < nonempty; y++) {\n\t\tcon_write(TCB, y, 0, empty, Width);\n\t\tmemcpy(empty,\n\t\t       CurScreen(sp)->_line[y].text,\n\t\t       (size_t) Width * sizeof(empty[0]));\n\t    }\n\t    CurScreen(sp)->_clear = FALSE;\n\t    NewScreen(sp)->_clear = FALSE;\n\t    touchwin(NewScreen(sp));\n\t    T((\"... cleared %dx%d lines @%d of screen\", nonempty, Width,\n\t       AdjustY()));\n\t}\n\n\tfor (y = 0; y < nonempty; y++) {\n\t    x0 = NewScreen(sp)->_line[y].firstchar;\n\t    if (x0 != _NOCHANGE) {\n#if EXP_OPTIMIZE\n\t\tint x2;\n\t\tint limit = NewScreen(sp)->_line[y].lastchar;\n\t\twhile ((x1 = EndChange(x0)) <= limit) {\n\t\t    while ((x2 = NextChange(x1)) <=\n\t\t\t   limit && x2 <= (x1 + 2)) {\n\t\t\tx1 = x2;\n\t\t    }\n\t\t    n = x1 - x0 + 1;\n\t\t    memcpy(&CurScreen(sp)->_line[y].text[x0],\n\t\t\t   &NewScreen(sp)->_line[y].text[x0],\n\t\t\t   n * sizeof(CurScreen(sp)->_line[y].text[x0]));\n\t\t    con_write(TCB,\n\t\t\t      y,\n\t\t\t      x0,\n\t\t\t      &CurScreen(sp)->_line[y].text[x0], n);\n\t\t    x0 = NextChange(x1);\n\t\t}\n\n\t\t \n\t\tif (y <= NewScreen(sp)->_maxy) {\n\t\t    MARK_NOCHANGE(NewScreen(sp), y);\n\t\t}\n\t\tif (y <= CurScreen(sp)->_maxy) {\n\t\t    MARK_NOCHANGE(CurScreen(sp), y);\n\t\t}\n#else\n\t\tx1 = NewScreen(sp)->_line[y].lastchar;\n\t\tn = x1 - x0 + 1;\n\t\tif (n > 0) {\n\t\t    memcpy(&CurScreen(sp)->_line[y].text[x0],\n\t\t\t   &NewScreen(sp)->_line[y].text[x0],\n\t\t\t   (size_t) n *\n\t\t\t   sizeof(CurScreen(sp)->_line[y].text[x0]));\n\t\t    con_write(TCB,\n\t\t\t      y,\n\t\t\t      x0,\n\t\t\t      &CurScreen(sp)->_line[y].text[x0], n);\n\n\t\t     \n\t\t    if (y <= NewScreen(sp)->_maxy) {\n\t\t\tMARK_NOCHANGE(NewScreen(sp), y);\n\t\t    }\n\t\t    if (y <= CurScreen(sp)->_maxy) {\n\t\t\tMARK_NOCHANGE(CurScreen(sp), y);\n\t\t    }\n\t\t}\n#endif\n\t    }\n\t}\n\n\t \n\tfor (y = nonempty; y <= NewScreen(sp)->_maxy; y++) {\n\t    MARK_NOCHANGE(NewScreen(sp), y);\n\t}\n\tfor (y = nonempty; y <= CurScreen(sp)->_maxy; y++) {\n\t    MARK_NOCHANGE(CurScreen(sp), y);\n\t}\n\n\tif (!NewScreen(sp)->_leaveok) {\n\t    CurScreen(sp)->_curx = NewScreen(sp)->_curx;\n\t    CurScreen(sp)->_cury = NewScreen(sp)->_cury;\n\n\t    TCB->drv->td_hwcur(TCB,\n\t\t\t       0,\n\t\t\t       0,\n\t\t\t       CurScreen(sp)->_cury,\n\t\t\t       CurScreen(sp)->_curx);\n\t}\n\t_nc_console_selectActiveHandle();\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nstatic bool\nwcon_CanHandle(TERMINAL_CONTROL_BLOCK * TCB,\n\t       const char *tname,\n\t       int *errret GCC_UNUSED)\n{\n    bool code = FALSE;\n\n    T((T_CALLED(\"win32con::wcon_CanHandle(%p)\"), TCB));\n\n    assert((TCB != 0) && (tname != 0));\n\n    TCB->magic = WINMAGIC;\n\n    if (tname == 0 || *tname == 0) {\n\tif (!_nc_console_vt_supported())\n\t    code = TRUE;\n    } else if (tname != 0 && *tname == '#') {\n\t \n\tsize_t n = strlen(tname + 1);\n\tif (n != 0\n\t    && ((strncmp(tname + 1, \"win32console\", n) == 0)\n\t\t|| (strncmp(tname + 1, \"win32con\", n) == 0))) {\n\t    code = TRUE;\n\t}\n    } else if (tname != 0 && stricmp(tname, \"unknown\") == 0) {\n\tcode = TRUE;\n    }\n\n     \n    if (code && (TerminalType(&TCB->term).Booleans == 0)) {\n\t_nc_init_termtype(&TerminalType(&TCB->term));\n#if NCURSES_EXT_NUMBERS\n\t_nc_export_termtype2(&TCB->term.type, &TerminalType(&TCB->term));\n#endif\n    }\n\n    if (!code) {\n\tif (_nc_console_test(0)) {\n\t    T((\"isTermInfoConsole=TRUE\"));\n\t    WINCONSOLE.isTermInfoConsole = TRUE;\n\t}\n    }\n    returnBool(code);\n}\n\nstatic int\nwcon_dobeepflash(TERMINAL_CONTROL_BLOCK * TCB,\n\t\t int beepFlag)\n{\n    SCREEN *sp;\n    int res = ERR;\n\n    int high = (WINCONSOLE.SBI.srWindow.Bottom -\n\t\tWINCONSOLE.SBI.srWindow.Top + 1);\n    int wide = (WINCONSOLE.SBI.srWindow.Right -\n\t\tWINCONSOLE.SBI.srWindow.Left + 1);\n    int max_cells = (high * wide);\n    int i;\n\n    CHAR_INFO *this_screen = TypeAlloca(CHAR_INFO, max_cells);\n    CHAR_INFO *that_screen = TypeAlloca(CHAR_INFO, max_cells);\n    COORD this_size;\n    SMALL_RECT this_region;\n    COORD bufferCoord;\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\tthis_region.Top = WINCONSOLE.SBI.srWindow.Top;\n\tthis_region.Left = WINCONSOLE.SBI.srWindow.Left;\n\tthis_region.Bottom = WINCONSOLE.SBI.srWindow.Bottom;\n\tthis_region.Right = WINCONSOLE.SBI.srWindow.Right;\n\n\tthis_size.X = (SHORT) wide;\n\tthis_size.Y = (SHORT) high;\n\n\tbufferCoord.X = this_region.Left;\n\tbufferCoord.Y = this_region.Top;\n\n\tif (!beepFlag &&\n\t    read_screen(WINCONSOLE.hdl,\n\t\t\tthis_screen,\n\t\t\tthis_size,\n\t\t\tbufferCoord,\n\t\t\t&this_region)) {\n\n\t    memcpy(that_screen,\n\t\t   this_screen,\n\t\t   sizeof(CHAR_INFO) * (size_t) max_cells);\n\n\t    for (i = 0; i < max_cells; i++) {\n\t\tthat_screen[i].Attributes =\n\t\t    RevAttr(that_screen[i].Attributes);\n\t    }\n\n\t    write_screen(WINCONSOLE.hdl, that_screen, this_size,\n\t\t\t bufferCoord, &this_region);\n\t    Sleep(200);\n\t    write_screen(WINCONSOLE.hdl, this_screen, this_size,\n\t\t\t bufferCoord, &this_region);\n\n\t} else {\n\t    MessageBeep(MB_ICONWARNING);\t \n\t}\n\tres = OK;\n    }\n    return res;\n}\n\nstatic int\nwcon_print(TERMINAL_CONTROL_BLOCK * TCB,\n\t   char *data GCC_UNUSED,\n\t   int len GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    return ERR;\n}\n\nstatic int\nwcon_defaultcolors(TERMINAL_CONTROL_BLOCK * TCB,\n\t\t   int fg GCC_UNUSED,\n\t\t   int bg GCC_UNUSED)\n{\n    SCREEN *sp;\n    int code = ERR;\n\n    AssertTCB();\n    SetSP();\n\n    return (code);\n}\n\nstatic void\nwcon_setcolor(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int fore,\n\t      int color,\n\t      int (*outc) (SCREEN *, int) GCC_UNUSED)\n{\n    (void) TCB;\n    if (validateConsoleHandle()) {\n\tWORD a = _nc_console_MapColor(fore, color);\n\ta |= (WORD) ((WINCONSOLE.SBI.wAttributes) & (fore ? 0xfff8 : 0xff8f));\n\tSetConsoleTextAttribute(WINCONSOLE.hdl, a);\n\t_nc_console_get_SBI();\n    }\n}\n\nstatic bool\nwcon_rescol(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    bool res = FALSE;\n\n    (void) TCB;\n    if (validateConsoleHandle()) {\n\tWORD a = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN;\n\tSetConsoleTextAttribute(WINCONSOLE.hdl, a);\n\t_nc_console_get_SBI();\n\tres = TRUE;\n    }\n    return res;\n}\n\nstatic bool\nwcon_rescolors(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    int result = FALSE;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    return result;\n}\n\nstatic int\nwcon_size(TERMINAL_CONTROL_BLOCK * TCB, int *Lines, int *Cols)\n{\n    int result = ERR;\n\n    T((T_CALLED(\"win32con::wcon_size(%p)\"), TCB));\n\n    if (validateConsoleHandle() &&\n\t(Lines != NULL) && (Cols != NULL)) {\n\t_nc_console_size(Lines, Cols);\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nstatic int\nwcon_setsize(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED,\n\t     int l GCC_UNUSED,\n\t     int c GCC_UNUSED)\n{\n    AssertTCB();\n    return ERR;\n}\n\nstatic int\nwcon_sgmode(TERMINAL_CONTROL_BLOCK * TCB, int setFlag, TTY * buf)\n{\n    int result = ERR;\n\n    T((T_CALLED(\"win32con::wcon_sgmode(TCB=(%p),setFlag=%d,TTY=(%p)\"),\n       TCB, setFlag, buf));\n    if (buf != NULL && validateConsoleHandle()) {\n\n\tif (setFlag) {\n\t    _nc_console_setmode(WINCONSOLE.hdl, buf);\n\t    TCB->term.Nttyb = *buf;\n\t} else {\n\t    _nc_console_getmode(WINCONSOLE.hdl, &(TCB->term.Nttyb));\n\t    *buf = TCB->term.Nttyb;\n\t}\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\n#define MIN_WIDE 80\n#define MIN_HIGH 24\n\nstatic int\nwcon_mode(TERMINAL_CONTROL_BLOCK * TCB, int progFlag, int defFlag)\n{\n    SCREEN *sp;\n    TERMINAL *_term = (TERMINAL *) TCB;\n    int code = ERR;\n\n    if (validateConsoleHandle()) {\n\tsp = TCB->csp;\n\n\tT((T_CALLED(\"win32con::wcon_mode(%p, progFlag=%d, defFlag=%d)\"),\n\t   TCB, progFlag, defFlag));\n\n\tWINCONSOLE.progMode = progFlag;\n\tWINCONSOLE.lastOut = progFlag ? WINCONSOLE.hdl : WINCONSOLE.out;\n\tSetConsoleActiveScreenBuffer(WINCONSOLE.lastOut);\n\n\tif (progFlag)    {\n\t    if (defFlag) {\n\t\tif ((wcon_sgmode(TCB, FALSE, &(_term->Nttyb)) == OK)) {\n\t\t    code = OK;\n\t\t}\n\t    } else {\n\t\t \n\t\tif (wcon_sgmode(TCB, TRUE, &(_term->Nttyb)) == OK) {\n\t\t    if (sp) {\n\t\t\tif (sp->_keypad_on)\n\t\t\t    _nc_keypad(sp, TRUE);\n\t\t    }\n\t\t    if (!WINCONSOLE.buffered) {\n\t\t\t_nc_console_set_scrollback(FALSE, &WINCONSOLE.SBI);\n\t\t    }\n\t\t    code = OK;\n\t\t}\n\t    }\n\t    T((\"... buffered:%d, clear:%d\",\n\t       WINCONSOLE.buffered, CurScreen(sp)->_clear));\n\t} else {\t\t \n\t    if (defFlag) {\n\t\t \n\t\tif (wcon_sgmode(TCB, FALSE, &(_term->Ottyb)) == OK) {\n\t\t    code = OK;\n\t\t}\n\t    } else {\n\t\t \n\t\tif (sp) {\n\t\t    _nc_keypad(sp, FALSE);\n\t\t    NCURSES_SP_NAME(_nc_flush) (sp);\n\t\t}\n\t\tcode = wcon_sgmode(TCB, TRUE, &(_term->Ottyb));\n\t\tif (!WINCONSOLE.buffered) {\n\t\t    _nc_console_set_scrollback(TRUE, &WINCONSOLE.save_SBI);\n\t\t    if (!restore_original_screen())\n\t\t\tcode = ERR;\n\t\t}\n\t\tSetConsoleCursorInfo(WINCONSOLE.hdl, &WINCONSOLE.save_CI);\n\t    }\n\t}\n\n    }\n    returnCode(code);\n}\n\nstatic void\nwcon_screen_init(SCREEN *sp GCC_UNUSED)\n{\n}\n\nstatic void\nwcon_wrap(SCREEN *sp GCC_UNUSED)\n{\n}\n\nstatic void\nwcon_release(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    T((T_CALLED(\"win32con::wcon_release(%p)\"), TCB));\n\n    AssertTCB();\n    if (TCB->prop)\n\tfree(TCB->prop);\n\n    returnVoid;\n}\n\nstatic void\nwcon_init(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    T((T_CALLED(\"win32con::wcon_init(%p)\"), TCB));\n\n    AssertTCB();\n\n    if (!(console_initialized = _nc_console_checkinit(TRUE, FALSE))) {\n\treturnVoid;\n    }\n\n    if (TCB) {\n\tTCB->info.initcolor = TRUE;\n\tTCB->info.canchange = FALSE;\n\tTCB->info.hascolor = TRUE;\n\tTCB->info.caninit = TRUE;\n\n\tTCB->info.maxpairs = CON_NUMPAIRS;\n\tTCB->info.maxcolors = 8;\n\tTCB->info.numlabels = 0;\n\tTCB->info.labelwidth = 0;\n\tTCB->info.labelheight = 0;\n\tTCB->info.nocolorvideo = 1;\n\tTCB->info.tabsize = 8;\n\n\tTCB->info.numbuttons = WINCONSOLE.numButtons;\n\tTCB->info.defaultPalette = _nc_cga_palette;\n\n    }\n    returnVoid;\n}\n\nstatic void\nwcon_initpair(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int pair,\n\t      int f,\n\t      int b)\n{\n    SCREEN *sp;\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tif ((pair > 0) && (pair < CON_NUMPAIRS) && (f >= 0) && (f < 8)\n\t    && (b >= 0) && (b < 8)) {\n\t    WINCONSOLE.pairs[pair] =\n\t\t_nc_console_MapColor(true, f) |\n\t\t_nc_console_MapColor(false, b);\n\t}\n    }\n}\n\nstatic void\nwcon_initcolor(TERMINAL_CONTROL_BLOCK * TCB,\n\t       int color GCC_UNUSED,\n\t       int r GCC_UNUSED,\n\t       int g GCC_UNUSED,\n\t       int b GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_do_color(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int old_pair GCC_UNUSED,\n\t      int pair GCC_UNUSED,\n\t      int reverse GCC_UNUSED,\n\t      int (*outc) (SCREEN *, int) GCC_UNUSED\n)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_initmouse(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    SCREEN *sp;\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tsp->_mouse_type = M_TERM_DRIVER;\n    }\n}\n\nstatic int\nwcon_testmouse(TERMINAL_CONTROL_BLOCK * TCB,\n\t       int delay\n\t       EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc = 0;\n    SCREEN *sp;\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tif (sp->_drv_mouse_head < sp->_drv_mouse_tail) {\n\t    rc = TW_MOUSE;\n\t} else {\n\t    rc = TCBOf(sp)->drv->td_twait(TCBOf(sp),\n\t\t\t\t\t  TWAIT_MASK,\n\t\t\t\t\t  delay,\n\t\t\t\t\t  (int *) 0\n\t\t\t\t\t  EVENTLIST_2nd(evl));\n\t}\n    }\n\n    return rc;\n}\n\nstatic int\nwcon_mvcur(TERMINAL_CONTROL_BLOCK * TCB,\n\t   int yold GCC_UNUSED, int xold GCC_UNUSED,\n\t   int y, int x)\n{\n    int ret = ERR;\n\n    (void) TCB;\n    if (validateConsoleHandle()) {\n\tCOORD loc;\n\tloc.X = (short) x;\n\tloc.Y = (short) (y + AdjustY());\n\tSetConsoleCursorPosition(WINCONSOLE.hdl, loc);\n\tret = OK;\n    }\n    return ret;\n}\n\nstatic void\nwcon_hwlabel(TERMINAL_CONTROL_BLOCK * TCB,\n\t     int labnum GCC_UNUSED,\n\t     char *text GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_hwlabelOnOff(TERMINAL_CONTROL_BLOCK * TCB,\n\t\t  int OnFlag GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic chtype\nwcon_conattr(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED)\n{\n    chtype res = A_NORMAL;\n    res |= (A_BOLD | A_DIM | A_REVERSE | A_STANDOUT | A_COLOR);\n    return res;\n}\n\nstatic void\nwcon_setfilter(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_initacs(TERMINAL_CONTROL_BLOCK * TCB,\n\t     chtype *real_map GCC_UNUSED,\n\t     chtype *fake_map GCC_UNUSED)\n{\n#define DATA(a,b) { a, b }\n    static struct {\n\tint acs_code;\n\tint use_code;\n    } table[] = {\n\tDATA('a', 0xb1),\t \n\t    DATA('f', 0xf8),\t \n\t    DATA('g', 0xf1),\t \n\t    DATA('j', 0xd9),\t \n\t    DATA('l', 0xda),\t \n\t    DATA('k', 0xbf),\t \n\t    DATA('m', 0xc0),\t \n\t    DATA('n', 0xc5),\t \n\t    DATA('q', 0xc4),\t \n\t    DATA('t', 0xc3),\t \n\t    DATA('u', 0xb4),\t \n\t    DATA('v', 0xc1),\t \n\t    DATA('w', 0xc2),\t \n\t    DATA('x', 0xb3),\t \n\t    DATA('y', 0xf3),\t \n\t    DATA('z', 0xf2),\t \n\t    DATA('0', 0xdb),\t \n\t    DATA('{', 0xe3),\t \n\t    DATA('}', 0x9c),\t \n\t    DATA(',', 0xae),\t \n\t    DATA('+', 0xaf),\t \n\t    DATA('~', 0xf9),\t \n    };\n#undef DATA\n    unsigned n;\n\n    SCREEN *sp;\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tfor (n = 0; n < SIZEOF(table); ++n) {\n\t    real_map[table[n].acs_code] =\n\t\t(chtype) table[n].use_code | A_ALTCHARSET;\n\t    if (sp != 0)\n\t\tsp->_screen_acs_map[table[n].acs_code] = TRUE;\n\t}\n    }\n}\n\nstatic int\nwcon_twait(TERMINAL_CONTROL_BLOCK * TCB,\n\t   int mode,\n\t   int milliseconds,\n\t   int *timeleft\n\t   EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    SCREEN *sp;\n    int code = 0;\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tcode = _nc_console_twait(sp,\n\t\t\t\t WINCONSOLE.inp,\n\t\t\t\t mode,\n\t\t\t\t milliseconds,\n\t\t\t\t timeleft EVENTLIST_2nd(evl));\n    }\n    return code;\n}\n\nstatic int\nwcon_read(TERMINAL_CONTROL_BLOCK * TCB, int *buf)\n{\n    SCREEN *sp;\n    int n = -1;\n\n    T((T_CALLED(\"win32con::wcon_read(%p)\"), TCB));\n\n    assert(buf);\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tn = _nc_console_read(sp, WINCONSOLE.inp, buf);\n    }\n    returnCode(n);\n}\n\nstatic int\nwcon_nap(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int ms)\n{\n    T((T_CALLED(\"win32con::wcon_nap(%p, %d)\"), TCB, ms));\n    Sleep((DWORD) ms);\n    returnCode(OK);\n}\n\nstatic int\nwcon_cursorSet(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int mode)\n{\n    int res = -1;\n\n    T((T_CALLED(\"win32con:wcon_cursorSet(%d)\"), mode));\n    if (validateConsoleHandle()) {\n\tCONSOLE_CURSOR_INFO this_CI = WINCONSOLE.save_CI;\n\tswitch (mode) {\n\tcase 0:\n\t    this_CI.bVisible = FALSE;\n\t    break;\n\tcase 1:\n\t    break;\n\tcase 2:\n\t    this_CI.dwSize = 100;\n\t    break;\n\t}\n\tSetConsoleCursorInfo(WINCONSOLE.hdl, &this_CI);\n    }\n    returnCode(res);\n}\n\nstatic bool\nwcon_kyExist(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int keycode)\n{\n    bool found = FALSE;\n\n    T((T_CALLED(\"win32con::wcon_kyExist(%d)\"), keycode));\n    found = _nc_console_keyExist(keycode);\n    returnBool(found);\n}\n\nstatic int\nwcon_kpad(TERMINAL_CONTROL_BLOCK * TCB, int flag GCC_UNUSED)\n{\n    SCREEN *sp;\n    int code = ERR;\n\n    T((T_CALLED(\"win32con::wcon_kpad(%p, %d)\"), TCB, flag));\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\n\tif (sp) {\n\t    code = OK;\n\t}\n    }\n    returnCode(code);\n}\n\nstatic int\nwcon_keyok(TERMINAL_CONTROL_BLOCK * TCB,\n\t   int keycode,\n\t   int flag)\n{\n    int code = ERR;\n    SCREEN *sp;\n\n    T((T_CALLED(\"win32con::wcon_keyok(%p, %d, %d)\"), TCB, keycode, flag));\n\n    if (validateConsoleHandle()) {\n\tSetSP();\n\tif (sp) {\n\t    code = _nc_console_keyok(keycode, flag);\n\t}\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT_VAR (TERM_DRIVER) _nc_WIN_DRIVER = {\n    FALSE,\n\twcon_name,\t\t \n\twcon_CanHandle,\t\t \n\twcon_init,\t\t \n\twcon_release,\t\t \n\twcon_size,\t\t \n\twcon_sgmode,\t\t \n\twcon_conattr,\t\t \n\twcon_mvcur,\t\t \n\twcon_mode,\t\t \n\twcon_rescol,\t\t \n\twcon_rescolors,\t\t \n\twcon_setcolor,\t\t \n\twcon_dobeepflash,\t \n\twcon_initpair,\t\t \n\twcon_initcolor,\t\t \n\twcon_do_color,\t\t \n\twcon_initmouse,\t\t \n\twcon_testmouse,\t\t \n\twcon_setfilter,\t\t \n\twcon_hwlabel,\t\t \n\twcon_hwlabelOnOff,\t \n\twcon_doupdate,\t\t \n\twcon_defaultcolors,\t \n\twcon_print,\t\t \n\twcon_size,\t\t \n\twcon_setsize,\t\t \n\twcon_initacs,\t\t \n\twcon_screen_init,\t \n\twcon_wrap,\t\t \n\twcon_twait,\t\t \n\twcon_read,\t\t \n\twcon_nap,\t\t \n\twcon_kpad,\t\t \n\twcon_keyok,\t\t \n\twcon_kyExist,\t\t \n\twcon_cursorSet\t\t \n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}