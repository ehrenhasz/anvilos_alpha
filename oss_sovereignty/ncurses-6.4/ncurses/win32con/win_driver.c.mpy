{
  "module_name": "win_driver.c",
  "hash_id": "a63e671a38334d5965dbde3a28710de974583b98ad8b1980ad7b36d190519e7f",
  "original_prompt": "Ingested from ncurses-6.4/ncurses/win32con/win_driver.c",
  "human_readable_source": " \n\n \n\n \n\n#include <curses.priv.h>\n\n#ifdef _WIN32\n#include <tchar.h>\n#else\n#include <windows.h>\n#include <wchar.h>\n#endif\n\n#include <io.h>\n\n#define PSAPI_VERSION 2\n#include <psapi.h>\n\n#define CUR TerminalType(my_term).\n\nMODULE_ID(\"$Id: win_driver.c,v 1.67 2021/09/04 10:54:35 tom Exp $\")\n\n#define TypeAlloca(type,count) (type*) _alloca(sizeof(type) * (size_t) (count))\n\n#define WINMAGIC NCDRV_MAGIC(NCDRV_WINCONSOLE)\n\n#define EXP_OPTIMIZE 0\n\n#define array_length(a) (sizeof(a)/sizeof(a[0]))\n\nstatic bool InitConsole(void);\nstatic bool okConsoleHandle(TERMINAL_CONTROL_BLOCK *);\n\n#define AssertTCB() assert(TCB != 0 && (TCB->magic == WINMAGIC))\n#define SetSP()     assert(TCB->csp != 0); sp = TCB->csp; (void) sp\n\n#define GenMap(vKey,key) MAKELONG(key, vKey)\n\n#define AdjustY() (CON.buffered ? 0 : (int) CON.SBI.srWindow.Top)\n\n#if USE_WIDEC_SUPPORT\n#define write_screen WriteConsoleOutputW\n#define read_screen  ReadConsoleOutputW\n#else\n#define write_screen WriteConsoleOutput\n#define read_screen  ReadConsoleOutput\n#endif\n\nstatic const LONG keylist[] =\n{\n    GenMap(VK_PRIOR, KEY_PPAGE),\n    GenMap(VK_NEXT, KEY_NPAGE),\n    GenMap(VK_END, KEY_END),\n    GenMap(VK_HOME, KEY_HOME),\n    GenMap(VK_LEFT, KEY_LEFT),\n    GenMap(VK_UP, KEY_UP),\n    GenMap(VK_RIGHT, KEY_RIGHT),\n    GenMap(VK_DOWN, KEY_DOWN),\n    GenMap(VK_DELETE, KEY_DC),\n    GenMap(VK_INSERT, KEY_IC)\n};\nstatic const LONG ansi_keys[] =\n{\n    GenMap(VK_PRIOR, 'I'),\n    GenMap(VK_NEXT, 'Q'),\n    GenMap(VK_END, 'O'),\n    GenMap(VK_HOME, 'H'),\n    GenMap(VK_LEFT, 'K'),\n    GenMap(VK_UP, 'H'),\n    GenMap(VK_RIGHT, 'M'),\n    GenMap(VK_DOWN, 'P'),\n    GenMap(VK_DELETE, 'S'),\n    GenMap(VK_INSERT, 'R')\n};\n#define N_INI ((int)array_length(keylist))\n#define FKEYS 24\n#define MAPSIZE (FKEYS + N_INI)\n#define NUMPAIRS 64\n\n \nstatic struct {\n    BOOL initialized;\n    BOOL buffered;\n    BOOL window_only;\n    BOOL progMode;\n    BOOL isMinTTY;\n    BOOL isTermInfoConsole;\n    HANDLE out;\n    HANDLE inp;\n    HANDLE hdl;\n    HANDLE lastOut;\n    int numButtons;\n    DWORD ansi_map[MAPSIZE];\n    DWORD map[MAPSIZE];\n    DWORD rmap[MAPSIZE];\n    WORD pairs[NUMPAIRS];\n    COORD origin;\n    CHAR_INFO *save_screen;\n    COORD save_size;\n    SMALL_RECT save_region;\n    CONSOLE_SCREEN_BUFFER_INFO SBI;\n    CONSOLE_SCREEN_BUFFER_INFO save_SBI;\n    CONSOLE_CURSOR_INFO save_CI;\n} CON;\n\nstatic BOOL console_initialized = FALSE;\n\nstatic WORD\nMapColor(bool fore, int color)\n{\n    static const int _cmap[] =\n    {0, 4, 2, 6, 1, 5, 3, 7};\n    int a;\n    if (color < 0 || color > 7)\n\ta = fore ? 7 : 0;\n    else\n\ta = _cmap[color];\n    if (!fore)\n\ta = a << 4;\n    return (WORD) a;\n}\n\n#define RevAttr(attr) \\\n\t       (WORD) (((attr) & 0xff00) | \\\n\t\t      ((((attr) & 0x07) << 4) | \\\n\t\t       (((attr) & 0x70) >> 4)))\n\nstatic WORD\nMapAttr(WORD res, attr_t ch)\n{\n    if (ch & A_COLOR) {\n\tint p;\n\n\tp = PairNumber(ch);\n\tif (p > 0 && p < NUMPAIRS) {\n\t    WORD a;\n\t    a = CON.pairs[p];\n\t    res = (WORD) ((res & 0xff00) | a);\n\t}\n    }\n\n    if (ch & A_REVERSE) {\n\tres = RevAttr(res);\n    }\n\n    if (ch & A_STANDOUT) {\n\tres = RevAttr(res) | BACKGROUND_INTENSITY;\n    }\n\n    if (ch & A_BOLD)\n\tres |= FOREGROUND_INTENSITY;\n\n    if (ch & A_DIM)\n\tres |= BACKGROUND_INTENSITY;\n\n    return res;\n}\n\n#if 0\t\t\t\t \nstatic void\ndump_screen(const char *fn, int ln)\n{\n    int max_cells = (CON.SBI.dwSize.Y * (1 + CON.SBI.dwSize.X)) + 1;\n    char output[max_cells];\n    CHAR_INFO save_screen[max_cells];\n    COORD save_size;\n    SMALL_RECT save_region;\n    COORD bufferCoord;\n\n    T((\"dump_screen %s@%d\", fn, ln));\n\n    save_region.Top = CON.SBI.srWindow.Top;\n    save_region.Left = CON.SBI.srWindow.Left;\n    save_region.Bottom = CON.SBI.srWindow.Bottom;\n    save_region.Right = CON.SBI.srWindow.Right;\n\n    save_size.X = (SHORT) (save_region.Right - save_region.Left + 1);\n    save_size.Y = (SHORT) (save_region.Bottom - save_region.Top + 1);\n\n    bufferCoord.X = bufferCoord.Y = 0;\n\n    if (read_screen(CON.hdl,\n\t\t    save_screen,\n\t\t    save_size,\n\t\t    bufferCoord,\n\t\t    &save_region)) {\n\tint i, j;\n\tint ij = 0;\n\tint k = 0;\n\n\tfor (i = save_region.Top; i <= save_region.Bottom; ++i) {\n\t    for (j = save_region.Left; j <= save_region.Right; ++j) {\n\t\toutput[k++] = save_screen[ij++].Char.AsciiChar;\n\t    }\n\t    output[k++] = '\\n';\n\t}\n\toutput[k] = 0;\n\n\tT((\"DUMP: %d,%d - %d,%d\",\n\t   save_region.Top,\n\t   save_region.Left,\n\t   save_region.Bottom,\n\t   save_region.Right));\n\tT((\"%s\", output));\n    }\n}\n\n#else\n#define dump_screen(fn,ln)\t \n#endif\n\n#if USE_WIDEC_SUPPORT\n \nstatic BOOL\ncon_write16(TERMINAL_CONTROL_BLOCK * TCB, int y, int x, cchar_t *str, int limit)\n{\n    int actual = 0;\n    CHAR_INFO *ci = TypeAlloca(CHAR_INFO, limit);\n    COORD loc, siz;\n    SMALL_RECT rec;\n    int i;\n    cchar_t ch;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    for (i = actual = 0; i < limit; i++) {\n\tch = str[i];\n\tif (isWidecExt(ch))\n\t    continue;\n\tci[actual].Char.UnicodeChar = CharOf(ch);\n\tci[actual].Attributes = MapAttr(CON.SBI.wAttributes,\n\t\t\t\t\tAttrOf(ch));\n\tif (AttrOf(ch) & A_ALTCHARSET) {\n\t    if (_nc_wacs) {\n\t\tint which = CharOf(ch);\n\t\tif (which > 0\n\t\t    && which < ACS_LEN\n\t\t    && CharOf(_nc_wacs[which]) != 0) {\n\t\t    ci[actual].Char.UnicodeChar = CharOf(_nc_wacs[which]);\n\t\t} else {\n\t\t    ci[actual].Char.UnicodeChar = ' ';\n\t\t}\n\t    }\n\t}\n\t++actual;\n    }\n\n    loc.X = (SHORT) 0;\n    loc.Y = (SHORT) 0;\n    siz.X = (SHORT) actual;\n    siz.Y = 1;\n\n    rec.Left = (SHORT) x;\n    rec.Top = (SHORT) (y + AdjustY());\n    rec.Right = (SHORT) (x + limit - 1);\n    rec.Bottom = rec.Top;\n\n    return write_screen(CON.hdl, ci, siz, loc, &rec);\n}\n#define con_write(tcb, y, x, str, n) con_write16(tcb, y, x, str, n)\n#else\nstatic BOOL\ncon_write8(TERMINAL_CONTROL_BLOCK * TCB, int y, int x, chtype *str, int n)\n{\n    CHAR_INFO *ci = TypeAlloca(CHAR_INFO, n);\n    COORD loc, siz;\n    SMALL_RECT rec;\n    int i;\n    chtype ch;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    for (i = 0; i < n; i++) {\n\tch = str[i];\n\tci[i].Char.AsciiChar = ChCharOf(ch);\n\tci[i].Attributes = MapAttr(CON.SBI.wAttributes,\n\t\t\t\t   ChAttrOf(ch));\n\tif (ChAttrOf(ch) & A_ALTCHARSET) {\n\t    if (sp->_acs_map)\n\t\tci[i].Char.AsciiChar =\n\t\tChCharOf(NCURSES_SP_NAME(_nc_acs_char) (sp, ChCharOf(ch)));\n\t}\n    }\n\n    loc.X = (short) 0;\n    loc.Y = (short) 0;\n    siz.X = (short) n;\n    siz.Y = 1;\n\n    rec.Left = (short) x;\n    rec.Top = (short) y;\n    rec.Right = (short) (x + n - 1);\n    rec.Bottom = rec.Top;\n\n    return write_screen(CON.hdl, ci, siz, loc, &rec);\n}\n#define con_write(tcb, y, x, str, n) con_write8(tcb, y, x, str, n)\n#endif\n\n#if EXP_OPTIMIZE\n \nstatic int\nfind_end_of_change(SCREEN *sp, int row, int col)\n{\n    int result = col;\n    struct ldat *curdat = CurScreen(sp)->_line + row;\n    struct ldat *newdat = NewScreen(sp)->_line + row;\n\n    while (col <= newdat->lastchar) {\n#if USE_WIDEC_SUPPORT\n\tif (isWidecExt(curdat->text[col]) || isWidecExt(newdat->text[col])) {\n\t    result = col;\n\t} else if (memcmp(&curdat->text[col],\n\t\t\t  &newdat->text[col],\n\t\t\t  sizeof(curdat->text[0]))) {\n\t    result = col;\n\t} else {\n\t    break;\n\t}\n#else\n\tif (curdat->text[col] != newdat->text[col]) {\n\t    result = col;\n\t} else {\n\t    break;\n\t}\n#endif\n\t++col;\n    }\n    return result;\n}\n\n \nstatic int\nfind_next_change(SCREEN *sp, int row, int col)\n{\n    struct ldat *curdat = CurScreen(sp)->_line + row;\n    struct ldat *newdat = NewScreen(sp)->_line + row;\n    int result = newdat->lastchar + 1;\n\n    while (++col <= newdat->lastchar) {\n#if USE_WIDEC_SUPPORT\n\tif (isWidecExt(curdat->text[col]) != isWidecExt(newdat->text[col])) {\n\t    result = col;\n\t    break;\n\t} else if (memcmp(&curdat->text[col],\n\t\t\t  &newdat->text[col],\n\t\t\t  sizeof(curdat->text[0]))) {\n\t    result = col;\n\t    break;\n\t}\n#else\n\tif (curdat->text[col] != newdat->text[col]) {\n\t    result = col;\n\t    break;\n\t}\n#endif\n    }\n    return result;\n}\n\n#define EndChange(first) \\\n\tfind_end_of_change(sp, y, first)\n#define NextChange(last) \\\n\tfind_next_change(sp, y, last)\n\n#endif  \n\n#define MARK_NOCHANGE(win,row) \\\n\t\twin->_line[row].firstchar = _NOCHANGE; \\\n\t\twin->_line[row].lastchar  = _NOCHANGE\n\nstatic void\nselectActiveHandle(void)\n{\n    if (CON.lastOut != CON.hdl) {\n\tCON.lastOut = CON.hdl;\n\tSetConsoleActiveScreenBuffer(CON.lastOut);\n    }\n}\n\nstatic bool\nrestore_original_screen(void)\n{\n    COORD bufferCoord;\n    bool result = FALSE;\n    SMALL_RECT save_region = CON.save_region;\n\n    T((\"... restoring %s\", CON.window_only ? \"window\" : \"entire buffer\"));\n\n    bufferCoord.X = (SHORT) (CON.window_only ? CON.SBI.srWindow.Left : 0);\n    bufferCoord.Y = (SHORT) (CON.window_only ? CON.SBI.srWindow.Top : 0);\n\n    if (write_screen(CON.hdl,\n\t\t     CON.save_screen,\n\t\t     CON.save_size,\n\t\t     bufferCoord,\n\t\t     &save_region)) {\n\tresult = TRUE;\n\tmvcur(-1, -1, LINES - 2, 0);\n\tT((\"... restore original screen contents ok %dx%d (%d,%d - %d,%d)\",\n\t   CON.save_size.Y,\n\t   CON.save_size.X,\n\t   save_region.Top,\n\t   save_region.Left,\n\t   save_region.Bottom,\n\t   save_region.Right));\n    } else {\n\tT((\"... restore original screen contents err\"));\n    }\n    return result;\n}\n\nstatic const char *\nwcon_name(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    (void) TCB;\n    return \"win32console\";\n}\n\nstatic int\nwcon_doupdate(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    int result = ERR;\n    int y, nonempty, n, x0, x1, Width, Height;\n    SCREEN *sp;\n\n    T((T_CALLED(\"win32con::wcon_doupdate(%p)\"), TCB));\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tWidth = screen_columns(sp);\n\tHeight = screen_lines(sp);\n\tnonempty = min(Height, NewScreen(sp)->_maxy + 1);\n\n\tT((\"... %dx%d clear cur:%d new:%d\",\n\t   Height, Width,\n\t   CurScreen(sp)->_clear,\n\t   NewScreen(sp)->_clear));\n\n\tif (SP_PARM->_endwin == ewSuspend) {\n\n\t    T((\"coming back from shell mode\"));\n\t    NCURSES_SP_NAME(reset_prog_mode) (NCURSES_SP_ARG);\n\n\t    NCURSES_SP_NAME(_nc_mvcur_resume) (NCURSES_SP_ARG);\n\t    NCURSES_SP_NAME(_nc_screen_resume) (NCURSES_SP_ARG);\n\t    SP_PARM->_mouse_resume(SP_PARM);\n\n\t    SP_PARM->_endwin = ewRunning;\n\t}\n\n\tif ((CurScreen(sp)->_clear || NewScreen(sp)->_clear)) {\n\t    int x;\n#if USE_WIDEC_SUPPORT\n\t    cchar_t *empty = TypeAlloca(cchar_t, Width);\n\t    wchar_t blank[2] =\n\t    {\n\t\tL' ', L'\\0'\n\t    };\n\n\t    for (x = 0; x < Width; x++)\n\t\tsetcchar(&empty[x], blank, 0, 0, 0);\n#else\n\t    chtype *empty = TypeAlloca(chtype, Width);\n\n\t    for (x = 0; x < Width; x++)\n\t\tempty[x] = ' ';\n#endif\n\n\t    for (y = 0; y < nonempty; y++) {\n\t\tcon_write(TCB, y, 0, empty, Width);\n\t\tmemcpy(empty,\n\t\t       CurScreen(sp)->_line[y].text,\n\t\t       (size_t) Width * sizeof(empty[0]));\n\t    }\n\t    CurScreen(sp)->_clear = FALSE;\n\t    NewScreen(sp)->_clear = FALSE;\n\t    touchwin(NewScreen(sp));\n\t    T((\"... cleared %dx%d lines @%d of screen\", nonempty, Width,\n\t       AdjustY()));\n\t}\n\n\tfor (y = 0; y < nonempty; y++) {\n\t    x0 = NewScreen(sp)->_line[y].firstchar;\n\t    if (x0 != _NOCHANGE) {\n#if EXP_OPTIMIZE\n\t\tint x2;\n\t\tint limit = NewScreen(sp)->_line[y].lastchar;\n\t\twhile ((x1 = EndChange(x0)) <= limit) {\n\t\t    while ((x2 = NextChange(x1)) <= limit && x2 <= (x1 + 2)) {\n\t\t\tx1 = x2;\n\t\t    }\n\t\t    n = x1 - x0 + 1;\n\t\t    memcpy(&CurScreen(sp)->_line[y].text[x0],\n\t\t\t   &NewScreen(sp)->_line[y].text[x0],\n\t\t\t   n * sizeof(CurScreen(sp)->_line[y].text[x0]));\n\t\t    con_write(TCB,\n\t\t\t      y,\n\t\t\t      x0,\n\t\t\t      &CurScreen(sp)->_line[y].text[x0], n);\n\t\t    x0 = NextChange(x1);\n\t\t}\n\n\t\t \n\t\tif (y <= NewScreen(sp)->_maxy) {\n\t\t    MARK_NOCHANGE(NewScreen(sp), y);\n\t\t}\n\t\tif (y <= CurScreen(sp)->_maxy) {\n\t\t    MARK_NOCHANGE(CurScreen(sp), y);\n\t\t}\n#else\n\t\tx1 = NewScreen(sp)->_line[y].lastchar;\n\t\tn = x1 - x0 + 1;\n\t\tif (n > 0) {\n\t\t    memcpy(&CurScreen(sp)->_line[y].text[x0],\n\t\t\t   &NewScreen(sp)->_line[y].text[x0],\n\t\t\t   (size_t) n * sizeof(CurScreen(sp)->_line[y].text[x0]));\n\t\t    con_write(TCB,\n\t\t\t      y,\n\t\t\t      x0,\n\t\t\t      &CurScreen(sp)->_line[y].text[x0], n);\n\n\t\t     \n\t\t    if (y <= NewScreen(sp)->_maxy) {\n\t\t\tMARK_NOCHANGE(NewScreen(sp), y);\n\t\t    }\n\t\t    if (y <= CurScreen(sp)->_maxy) {\n\t\t\tMARK_NOCHANGE(CurScreen(sp), y);\n\t\t    }\n\t\t}\n#endif\n\t    }\n\t}\n\n\t \n\tfor (y = nonempty; y <= NewScreen(sp)->_maxy; y++) {\n\t    MARK_NOCHANGE(NewScreen(sp), y);\n\t}\n\tfor (y = nonempty; y <= CurScreen(sp)->_maxy; y++) {\n\t    MARK_NOCHANGE(CurScreen(sp), y);\n\t}\n\n\tif (!NewScreen(sp)->_leaveok) {\n\t    CurScreen(sp)->_curx = NewScreen(sp)->_curx;\n\t    CurScreen(sp)->_cury = NewScreen(sp)->_cury;\n\n\t    TCB->drv->td_hwcur(TCB,\n\t\t\t       0, 0,\n\t\t\t       CurScreen(sp)->_cury, CurScreen(sp)->_curx);\n\t}\n\tselectActiveHandle();\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nstatic bool\nwcon_CanHandle(TERMINAL_CONTROL_BLOCK * TCB,\n\t       const char *tname,\n\t       int *errret GCC_UNUSED)\n{\n    bool code = FALSE;\n\n    T((T_CALLED(\"win32con::wcon_CanHandle(%p)\"), TCB));\n\n    assert((TCB != 0) && (tname != 0));\n\n    TCB->magic = WINMAGIC;\n\n    if (tname == 0 || *tname == 0)\n\tcode = TRUE;\n    else if (tname != 0 && *tname == '#') {\n\t \n\tsize_t n = strlen(tname + 1);\n\tif (n != 0\n\t    && ((strncmp(tname + 1, \"win32console\", n) == 0)\n\t\t|| (strncmp(tname + 1, \"win32con\", n) == 0))) {\n\t    code = TRUE;\n\t}\n    } else if (tname != 0 && stricmp(tname, \"unknown\") == 0) {\n\tcode = TRUE;\n    }\n\n     \n    if (code && (TerminalType(&TCB->term).Booleans == 0)) {\n\t_nc_init_termtype(&TerminalType(&TCB->term));\n#if NCURSES_EXT_NUMBERS\n\t_nc_export_termtype2(&TCB->term.type, &TerminalType(&TCB->term));\n#endif\n    }\n\n    if (!code) {\n\tif (_nc_mingw_isconsole(0))\n\t    CON.isTermInfoConsole = TRUE;\n    }\n    returnBool(code);\n}\n\nstatic int\nwcon_dobeepflash(TERMINAL_CONTROL_BLOCK * TCB,\n\t\t int beepFlag)\n{\n    SCREEN *sp;\n    int res = ERR;\n\n    int high = (CON.SBI.srWindow.Bottom - CON.SBI.srWindow.Top + 1);\n    int wide = (CON.SBI.srWindow.Right - CON.SBI.srWindow.Left + 1);\n    int max_cells = (high * wide);\n    int i;\n\n    CHAR_INFO *this_screen = TypeAlloca(CHAR_INFO, max_cells);\n    CHAR_INFO *that_screen = TypeAlloca(CHAR_INFO, max_cells);\n    COORD this_size;\n    SMALL_RECT this_region;\n    COORD bufferCoord;\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\tthis_region.Top = CON.SBI.srWindow.Top;\n\tthis_region.Left = CON.SBI.srWindow.Left;\n\tthis_region.Bottom = CON.SBI.srWindow.Bottom;\n\tthis_region.Right = CON.SBI.srWindow.Right;\n\n\tthis_size.X = (SHORT) wide;\n\tthis_size.Y = (SHORT) high;\n\n\tbufferCoord.X = this_region.Left;\n\tbufferCoord.Y = this_region.Top;\n\n\tif (!beepFlag &&\n\t    read_screen(CON.hdl,\n\t\t\tthis_screen,\n\t\t\tthis_size,\n\t\t\tbufferCoord,\n\t\t\t&this_region)) {\n\n\t    memcpy(that_screen,\n\t\t   this_screen,\n\t\t   sizeof(CHAR_INFO) * (size_t) max_cells);\n\n\t    for (i = 0; i < max_cells; i++) {\n\t\tthat_screen[i].Attributes = RevAttr(that_screen[i].Attributes);\n\t    }\n\n\t    write_screen(CON.hdl, that_screen, this_size, bufferCoord, &this_region);\n\t    Sleep(200);\n\t    write_screen(CON.hdl, this_screen, this_size, bufferCoord, &this_region);\n\n\t} else {\n\t    MessageBeep(MB_ICONWARNING);\t \n\t}\n\tres = OK;\n    }\n    return res;\n}\n\nstatic int\nwcon_print(TERMINAL_CONTROL_BLOCK * TCB,\n\t   char *data GCC_UNUSED,\n\t   int len GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    return ERR;\n}\n\nstatic int\nwcon_defaultcolors(TERMINAL_CONTROL_BLOCK * TCB,\n\t\t   int fg GCC_UNUSED,\n\t\t   int bg GCC_UNUSED)\n{\n    SCREEN *sp;\n    int code = ERR;\n\n    AssertTCB();\n    SetSP();\n\n    return (code);\n}\n\nstatic bool\nget_SBI(void)\n{\n    bool rc = FALSE;\n    if (GetConsoleScreenBufferInfo(CON.hdl, &(CON.SBI))) {\n\tT((\"GetConsoleScreenBufferInfo\"));\n\tT((\"... buffer(X:%d Y:%d)\",\n\t   CON.SBI.dwSize.X,\n\t   CON.SBI.dwSize.Y));\n\tT((\"... window(X:%d Y:%d)\",\n\t   CON.SBI.dwMaximumWindowSize.X,\n\t   CON.SBI.dwMaximumWindowSize.Y));\n\tT((\"... cursor(X:%d Y:%d)\",\n\t   CON.SBI.dwCursorPosition.X,\n\t   CON.SBI.dwCursorPosition.Y));\n\tT((\"... display(Top:%d Bottom:%d Left:%d Right:%d)\",\n\t   CON.SBI.srWindow.Top,\n\t   CON.SBI.srWindow.Bottom,\n\t   CON.SBI.srWindow.Left,\n\t   CON.SBI.srWindow.Right));\n\tif (CON.buffered) {\n\t    CON.origin.X = 0;\n\t    CON.origin.Y = 0;\n\t} else {\n\t    CON.origin.X = CON.SBI.srWindow.Left;\n\t    CON.origin.Y = CON.SBI.srWindow.Top;\n\t}\n\trc = TRUE;\n    } else {\n\tT((\"GetConsoleScreenBufferInfo ERR\"));\n    }\n    return rc;\n}\n\nstatic void\nwcon_setcolor(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int fore,\n\t      int color,\n\t      int (*outc) (SCREEN *, int) GCC_UNUSED)\n{\n    if (okConsoleHandle(TCB)) {\n\tWORD a = MapColor(fore, color);\n\ta |= (WORD) ((CON.SBI.wAttributes) & (fore ? 0xfff8 : 0xff8f));\n\tSetConsoleTextAttribute(CON.hdl, a);\n\tget_SBI();\n    }\n}\n\nstatic bool\nwcon_rescol(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    bool res = FALSE;\n\n    if (okConsoleHandle(TCB)) {\n\tWORD a = FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN;\n\tSetConsoleTextAttribute(CON.hdl, a);\n\tget_SBI();\n\tres = TRUE;\n    }\n    return res;\n}\n\nstatic bool\nwcon_rescolors(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    int result = FALSE;\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    return result;\n}\n\nstatic int\nwcon_size(TERMINAL_CONTROL_BLOCK * TCB, int *Lines, int *Cols)\n{\n    int result = ERR;\n\n    T((T_CALLED(\"win32con::wcon_size(%p)\"), TCB));\n\n    if (okConsoleHandle(TCB) &&\n\tLines != NULL &&\n\tCols != NULL) {\n\tif (CON.buffered) {\n\t    *Lines = (int) (CON.SBI.dwSize.Y);\n\t    *Cols = (int) (CON.SBI.dwSize.X);\n\t} else {\n\t    *Lines = (int) (CON.SBI.srWindow.Bottom + 1 -\n\t\t\t    CON.SBI.srWindow.Top);\n\t    *Cols = (int) (CON.SBI.srWindow.Right + 1 -\n\t\t\t   CON.SBI.srWindow.Left);\n\t}\n\tresult = OK;\n    }\n    returnCode(result);\n}\n\nstatic int\nwcon_setsize(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED,\n\t     int l GCC_UNUSED,\n\t     int c GCC_UNUSED)\n{\n    AssertTCB();\n    return ERR;\n}\n\nstatic int\nwcon_sgmode(TERMINAL_CONTROL_BLOCK * TCB, int setFlag, TTY * buf)\n{\n    DWORD dwFlag = 0;\n    tcflag_t iflag;\n    tcflag_t lflag;\n    int result = ERR;\n\n    if (buf != NULL && okConsoleHandle(TCB)) {\n\n\tif (setFlag) {\n\t    iflag = buf->c_iflag;\n\t    lflag = buf->c_lflag;\n\n\t    GetConsoleMode(CON.inp, &dwFlag);\n\n\t    if (lflag & ICANON)\n\t\tdwFlag |= ENABLE_LINE_INPUT;\n\t    else\n\t\tdwFlag &= (DWORD) (~ENABLE_LINE_INPUT);\n\n\t    if (lflag & ECHO)\n\t\tdwFlag |= ENABLE_ECHO_INPUT;\n\t    else\n\t\tdwFlag &= (DWORD) (~ENABLE_ECHO_INPUT);\n\n\t    if (iflag & BRKINT)\n\t\tdwFlag |= ENABLE_PROCESSED_INPUT;\n\t    else\n\t\tdwFlag &= (DWORD) (~ENABLE_PROCESSED_INPUT);\n\n\t    dwFlag |= ENABLE_MOUSE_INPUT;\n\n\t    buf->c_iflag = iflag;\n\t    buf->c_lflag = lflag;\n\t    SetConsoleMode(CON.inp, dwFlag);\n\t    TCB->term.Nttyb = *buf;\n\t} else {\n\t    iflag = TCB->term.Nttyb.c_iflag;\n\t    lflag = TCB->term.Nttyb.c_lflag;\n\t    GetConsoleMode(CON.inp, &dwFlag);\n\n\t    if (dwFlag & ENABLE_LINE_INPUT)\n\t\tlflag |= ICANON;\n\t    else\n\t\tlflag &= (tcflag_t) (~ICANON);\n\n\t    if (dwFlag & ENABLE_ECHO_INPUT)\n\t\tlflag |= ECHO;\n\t    else\n\t\tlflag &= (tcflag_t) (~ECHO);\n\n\t    if (dwFlag & ENABLE_PROCESSED_INPUT)\n\t\tiflag |= BRKINT;\n\t    else\n\t\tiflag &= (tcflag_t) (~BRKINT);\n\n\t    TCB->term.Nttyb.c_iflag = iflag;\n\t    TCB->term.Nttyb.c_lflag = lflag;\n\n\t    *buf = TCB->term.Nttyb;\n\t}\n\tresult = OK;\n    }\n    return result;\n}\n\n#define MIN_WIDE 80\n#define MIN_HIGH 24\n\n \nstatic void\nset_scrollback(bool normal, CONSOLE_SCREEN_BUFFER_INFO * info)\n{\n    SMALL_RECT rect;\n    COORD coord;\n    bool changed = FALSE;\n\n    T((T_CALLED(\"win32con::set_scrollback(%s)\"),\n       (normal\n\t? \"normal\"\n\t: \"application\")));\n\n    T((\"... SBI.srWindow %d,%d .. %d,%d\",\n       info->srWindow.Top,\n       info->srWindow.Left,\n       info->srWindow.Bottom,\n       info->srWindow.Right));\n    T((\"... SBI.dwSize %dx%d\",\n       info->dwSize.Y,\n       info->dwSize.X));\n\n    if (normal) {\n\trect = info->srWindow;\n\tcoord = info->dwSize;\n\tif (memcmp(info, &CON.SBI, sizeof(*info)) != 0) {\n\t    changed = TRUE;\n\t    CON.SBI = *info;\n\t}\n    } else {\n\tint high = info->srWindow.Bottom - info->srWindow.Top + 1;\n\tint wide = info->srWindow.Right - info->srWindow.Left + 1;\n\n\tif (high < MIN_HIGH) {\n\t    T((\"... height %d < %d\", high, MIN_HIGH));\n\t    high = MIN_HIGH;\n\t    changed = TRUE;\n\t}\n\tif (wide < MIN_WIDE) {\n\t    T((\"... width %d < %d\", wide, MIN_WIDE));\n\t    wide = MIN_WIDE;\n\t    changed = TRUE;\n\t}\n\n\trect.Left =\n\t    rect.Top = 0;\n\trect.Right = (SHORT) (wide - 1);\n\trect.Bottom = (SHORT) (high - 1);\n\n\tcoord.X = (SHORT) wide;\n\tcoord.Y = (SHORT) high;\n\n\tif (info->dwSize.Y != high ||\n\t    info->dwSize.X != wide ||\n\t    info->srWindow.Top != 0 ||\n\t    info->srWindow.Left != 0) {\n\t    changed = TRUE;\n\t}\n\n    }\n\n    if (changed) {\n\tT((\"... coord %d,%d\", coord.Y, coord.X));\n\tT((\"... rect %d,%d - %d,%d\",\n\t   rect.Top, rect.Left,\n\t   rect.Bottom, rect.Right));\n\tSetConsoleScreenBufferSize(CON.hdl, coord);\t \n\tSetConsoleWindowInfo(CON.hdl, TRUE, &rect);\t \n\tget_SBI();\n    }\n    returnVoid;\n}\n\nstatic int\nwcon_mode(TERMINAL_CONTROL_BLOCK * TCB, int progFlag, int defFlag)\n{\n    SCREEN *sp;\n    TERMINAL *_term = (TERMINAL *) TCB;\n    int code = ERR;\n\n    if (okConsoleHandle(TCB)) {\n\tsp = TCB->csp;\n\n\tT((T_CALLED(\"win32con::wcon_mode(%p, prog=%d, def=%d)\"),\n\t   TCB, progFlag, defFlag));\n\n\tCON.progMode = progFlag;\n\tCON.lastOut = progFlag ? CON.hdl : CON.out;\n\tSetConsoleActiveScreenBuffer(CON.lastOut);\n\n\tif (progFlag)    {\n\t    if (defFlag) {\n\t\tif ((wcon_sgmode(TCB, FALSE, &(_term->Nttyb)) == OK)) {\n\t\t    _term->Nttyb.c_oflag &= (tcflag_t) (~OFLAGS_TABS);\n\t\t    code = OK;\n\t\t}\n\t    } else {\n\t\t \n\t\tif (wcon_sgmode(TCB, TRUE, &(_term->Nttyb)) == OK) {\n\t\t    if (sp) {\n\t\t\tif (sp->_keypad_on)\n\t\t\t    _nc_keypad(sp, TRUE);\n\t\t    }\n\t\t    if (!CON.buffered) {\n\t\t\tset_scrollback(FALSE, &CON.SBI);\n\t\t    }\n\t\t    code = OK;\n\t\t}\n\t    }\n\t    T((\"... buffered:%d, clear:%d\", CON.buffered, CurScreen(sp)->_clear));\n\t} else {\t\t \n\t    if (defFlag) {\n\t\t \n\t\tif (wcon_sgmode(TCB, FALSE, &(_term->Ottyb)) == OK) {\n\t\t    code = OK;\n\t\t}\n\t    } else {\n\t\t \n\t\tif (sp) {\n\t\t    _nc_keypad(sp, FALSE);\n\t\t    NCURSES_SP_NAME(_nc_flush) (sp);\n\t\t}\n\t\tcode = wcon_sgmode(TCB, TRUE, &(_term->Ottyb));\n\t\tif (!CON.buffered) {\n\t\t    set_scrollback(TRUE, &CON.save_SBI);\n\t\t    if (!restore_original_screen())\n\t\t\tcode = ERR;\n\t\t}\n\t\tSetConsoleCursorInfo(CON.hdl, &CON.save_CI);\n\t    }\n\t}\n\n    }\n    returnCode(code);\n}\n\nstatic void\nwcon_screen_init(SCREEN *sp GCC_UNUSED)\n{\n}\n\nstatic void\nwcon_wrap(SCREEN *sp GCC_UNUSED)\n{\n}\n\nstatic int\nrkeycompare(const void *el1, const void *el2)\n{\n    WORD key1 = (LOWORD((*((const LONG *) el1)))) & 0x7fff;\n    WORD key2 = (LOWORD((*((const LONG *) el2)))) & 0x7fff;\n\n    return ((key1 < key2) ? -1 : ((key1 == key2) ? 0 : 1));\n}\n\nstatic int\nkeycompare(const void *el1, const void *el2)\n{\n    WORD key1 = HIWORD((*((const LONG *) el1)));\n    WORD key2 = HIWORD((*((const LONG *) el2)));\n\n    return ((key1 < key2) ? -1 : ((key1 == key2) ? 0 : 1));\n}\n\nstatic int\nMapKey(WORD vKey)\n{\n    WORD nKey = 0;\n    void *res;\n    LONG key = GenMap(vKey, 0);\n    int code = -1;\n\n    res = bsearch(&key,\n\t\t  CON.map,\n\t\t  (size_t) (N_INI + FKEYS),\n\t\t  sizeof(keylist[0]),\n\t\t  keycompare);\n    if (res) {\n\tkey = *((LONG *) res);\n\tnKey = LOWORD(key);\n\tcode = (int) (nKey & 0x7fff);\n\tif (nKey & 0x8000)\n\t    code = -code;\n    }\n    return code;\n}\n\nstatic int\nAnsiKey(WORD vKey)\n{\n    WORD nKey = 0;\n    void *res;\n    LONG key = GenMap(vKey, 0);\n    int code = -1;\n\n    res = bsearch(&key,\n\t\t  CON.ansi_map,\n\t\t  (size_t) (N_INI + FKEYS),\n\t\t  sizeof(keylist[0]),\n\t\t  keycompare);\n    if (res) {\n\tkey = *((LONG *) res);\n\tnKey = LOWORD(key);\n\tcode = (int) (nKey & 0x7fff);\n\tif (nKey & 0x8000)\n\t    code = -code;\n    }\n    return code;\n}\n\nstatic void\nwcon_release(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    T((T_CALLED(\"win32con::wcon_release(%p)\"), TCB));\n\n    AssertTCB();\n    if (TCB->prop)\n\tfree(TCB->prop);\n\n    returnVoid;\n}\n\nstatic bool\nread_screen_data(void)\n{\n    bool result = FALSE;\n    COORD bufferCoord;\n    size_t want;\n\n    CON.save_size.X = (SHORT) (CON.save_region.Right\n\t\t\t       - CON.save_region.Left + 1);\n    CON.save_size.Y = (SHORT) (CON.save_region.Bottom\n\t\t\t       - CON.save_region.Top + 1);\n\n    want = (size_t) (CON.save_size.X * CON.save_size.Y);\n\n    if ((CON.save_screen = malloc(want * sizeof(CHAR_INFO))) != 0) {\n\tbufferCoord.X = (SHORT) (CON.window_only ? CON.SBI.srWindow.Left : 0);\n\tbufferCoord.Y = (SHORT) (CON.window_only ? CON.SBI.srWindow.Top : 0);\n\n\tT((\"... reading console %s %dx%d into %d,%d - %d,%d at %d,%d\",\n\t   CON.window_only ? \"window\" : \"buffer\",\n\t   CON.save_size.Y, CON.save_size.X,\n\t   CON.save_region.Top,\n\t   CON.save_region.Left,\n\t   CON.save_region.Bottom,\n\t   CON.save_region.Right,\n\t   bufferCoord.Y,\n\t   bufferCoord.X));\n\n\tif (read_screen(CON.hdl,\n\t\t\tCON.save_screen,\n\t\t\tCON.save_size,\n\t\t\tbufferCoord,\n\t\t\t&CON.save_region)) {\n\t    result = TRUE;\n\t} else {\n\t    T((\" error %#lx\", (unsigned long) GetLastError()));\n\t    FreeAndNull(CON.save_screen);\n\t}\n    }\n\n    return result;\n}\n\n \nstatic bool\nsave_original_screen(void)\n{\n    bool result = FALSE;\n\n    CON.save_region.Top = 0;\n    CON.save_region.Left = 0;\n    CON.save_region.Bottom = (SHORT) (CON.SBI.dwSize.Y - 1);\n    CON.save_region.Right = (SHORT) (CON.SBI.dwSize.X - 1);\n\n    if (read_screen_data()) {\n\tresult = TRUE;\n    } else {\n\n\tCON.save_region.Top = CON.SBI.srWindow.Top;\n\tCON.save_region.Left = CON.SBI.srWindow.Left;\n\tCON.save_region.Bottom = CON.SBI.srWindow.Bottom;\n\tCON.save_region.Right = CON.SBI.srWindow.Right;\n\n\tCON.window_only = TRUE;\n\n\tif (read_screen_data()) {\n\t    result = TRUE;\n\t}\n    }\n\n    T((\"... save original screen contents %s\", result ? \"ok\" : \"err\"));\n    return result;\n}\n\nstatic void\nwcon_init(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    T((T_CALLED(\"win32con::wcon_init(%p)\"), TCB));\n\n    AssertTCB();\n\n    if (TCB) {\n\tif (!InitConsole()) {\n\t    returnVoid;\n\t}\n\n\tTCB->info.initcolor = TRUE;\n\tTCB->info.canchange = FALSE;\n\tTCB->info.hascolor = TRUE;\n\tTCB->info.caninit = TRUE;\n\n\tTCB->info.maxpairs = NUMPAIRS;\n\tTCB->info.maxcolors = 8;\n\tTCB->info.numlabels = 0;\n\tTCB->info.labelwidth = 0;\n\tTCB->info.labelheight = 0;\n\tTCB->info.nocolorvideo = 1;\n\tTCB->info.tabsize = 8;\n\n\tTCB->info.numbuttons = CON.numButtons;\n\tTCB->info.defaultPalette = _nc_cga_palette;\n\n    }\n    returnVoid;\n}\n\nstatic void\nwcon_initpair(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int pair,\n\t      int f,\n\t      int b)\n{\n    SCREEN *sp;\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tif ((pair > 0) && (pair < NUMPAIRS) && (f >= 0) && (f < 8)\n\t    && (b >= 0) && (b < 8)) {\n\t    CON.pairs[pair] = MapColor(true, f) | MapColor(false, b);\n\t}\n    }\n}\n\nstatic void\nwcon_initcolor(TERMINAL_CONTROL_BLOCK * TCB,\n\t       int color GCC_UNUSED,\n\t       int r GCC_UNUSED,\n\t       int g GCC_UNUSED,\n\t       int b GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_do_color(TERMINAL_CONTROL_BLOCK * TCB,\n\t      int old_pair GCC_UNUSED,\n\t      int pair GCC_UNUSED,\n\t      int reverse GCC_UNUSED,\n\t      int (*outc) (SCREEN *, int) GCC_UNUSED\n)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_initmouse(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    SCREEN *sp;\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tsp->_mouse_type = M_TERM_DRIVER;\n    }\n}\n\nstatic int\nwcon_testmouse(TERMINAL_CONTROL_BLOCK * TCB,\n\t       int delay\n\t       EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc = 0;\n    SCREEN *sp;\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tif (sp->_drv_mouse_head < sp->_drv_mouse_tail) {\n\t    rc = TW_MOUSE;\n\t} else {\n\t    rc = TCBOf(sp)->drv->td_twait(TCBOf(sp),\n\t\t\t\t\t  TWAIT_MASK,\n\t\t\t\t\t  delay,\n\t\t\t\t\t  (int *) 0\n\t\t\t\t\t  EVENTLIST_2nd(evl));\n\t}\n    }\n\n    return rc;\n}\n\nstatic int\nwcon_mvcur(TERMINAL_CONTROL_BLOCK * TCB,\n\t   int yold GCC_UNUSED, int xold GCC_UNUSED,\n\t   int y, int x)\n{\n    int ret = ERR;\n    if (okConsoleHandle(TCB)) {\n\tCOORD loc;\n\tloc.X = (short) x;\n\tloc.Y = (short) (y + AdjustY());\n\tSetConsoleCursorPosition(CON.hdl, loc);\n\tret = OK;\n    }\n    return ret;\n}\n\nstatic void\nwcon_hwlabel(TERMINAL_CONTROL_BLOCK * TCB,\n\t     int labnum GCC_UNUSED,\n\t     char *text GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_hwlabelOnOff(TERMINAL_CONTROL_BLOCK * TCB,\n\t\t  int OnFlag GCC_UNUSED)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic chtype\nwcon_conattr(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED)\n{\n    chtype res = A_NORMAL;\n    res |= (A_BOLD | A_DIM | A_REVERSE | A_STANDOUT | A_COLOR);\n    return res;\n}\n\nstatic void\nwcon_setfilter(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n}\n\nstatic void\nwcon_initacs(TERMINAL_CONTROL_BLOCK * TCB,\n\t     chtype *real_map GCC_UNUSED,\n\t     chtype *fake_map GCC_UNUSED)\n{\n#define DATA(a,b) { a, b }\n    static struct {\n\tint acs_code;\n\tint use_code;\n    } table[] = {\n\tDATA('a', 0xb1),\t \n\t    DATA('f', 0xf8),\t \n\t    DATA('g', 0xf1),\t \n\t    DATA('j', 0xd9),\t \n\t    DATA('l', 0xda),\t \n\t    DATA('k', 0xbf),\t \n\t    DATA('m', 0xc0),\t \n\t    DATA('n', 0xc5),\t \n\t    DATA('q', 0xc4),\t \n\t    DATA('t', 0xc3),\t \n\t    DATA('u', 0xb4),\t \n\t    DATA('v', 0xc1),\t \n\t    DATA('w', 0xc2),\t \n\t    DATA('x', 0xb3),\t \n\t    DATA('y', 0xf3),\t \n\t    DATA('z', 0xf2),\t \n\t    DATA('0', 0xdb),\t \n\t    DATA('{', 0xe3),\t \n\t    DATA('}', 0x9c),\t \n\t    DATA(',', 0xae),\t \n\t    DATA('+', 0xaf),\t \n\t    DATA('~', 0xf9),\t \n    };\n#undef DATA\n    unsigned n;\n\n    SCREEN *sp;\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tfor (n = 0; n < SIZEOF(table); ++n) {\n\t    real_map[table[n].acs_code] = (chtype) table[n].use_code | A_ALTCHARSET;\n\t    if (sp != 0)\n\t\tsp->_screen_acs_map[table[n].acs_code] = TRUE;\n\t}\n    }\n}\n\nstatic ULONGLONG\ntdiff(FILETIME fstart, FILETIME fend)\n{\n    ULARGE_INTEGER ustart;\n    ULARGE_INTEGER uend;\n    ULONGLONG diff;\n\n    ustart.LowPart = fstart.dwLowDateTime;\n    ustart.HighPart = fstart.dwHighDateTime;\n    uend.LowPart = fend.dwLowDateTime;\n    uend.HighPart = fend.dwHighDateTime;\n\n    diff = (uend.QuadPart - ustart.QuadPart) / 10000;\n    return diff;\n}\n\nstatic int\nAdjust(int milliseconds, int diff)\n{\n    if (milliseconds != INFINITY) {\n\tmilliseconds -= diff;\n\tif (milliseconds < 0)\n\t    milliseconds = 0;\n    }\n    return milliseconds;\n}\n\n#define BUTTON_MASK (FROM_LEFT_1ST_BUTTON_PRESSED | \\\n\t\t     FROM_LEFT_2ND_BUTTON_PRESSED | \\\n\t\t     FROM_LEFT_3RD_BUTTON_PRESSED | \\\n\t\t     FROM_LEFT_4TH_BUTTON_PRESSED | \\\n\t\t     RIGHTMOST_BUTTON_PRESSED)\n\nstatic int\ndecode_mouse(SCREEN *sp, int mask)\n{\n    int result = 0;\n\n    (void) sp;\n    assert(sp && console_initialized);\n\n    if (mask & FROM_LEFT_1ST_BUTTON_PRESSED)\n\tresult |= BUTTON1_PRESSED;\n    if (mask & FROM_LEFT_2ND_BUTTON_PRESSED)\n\tresult |= BUTTON2_PRESSED;\n    if (mask & FROM_LEFT_3RD_BUTTON_PRESSED)\n\tresult |= BUTTON3_PRESSED;\n    if (mask & FROM_LEFT_4TH_BUTTON_PRESSED)\n\tresult |= BUTTON4_PRESSED;\n\n    if (mask & RIGHTMOST_BUTTON_PRESSED) {\n\tswitch (CON.numButtons) {\n\tcase 1:\n\t    result |= BUTTON1_PRESSED;\n\t    break;\n\tcase 2:\n\t    result |= BUTTON2_PRESSED;\n\t    break;\n\tcase 3:\n\t    result |= BUTTON3_PRESSED;\n\t    break;\n\tcase 4:\n\t    result |= BUTTON4_PRESSED;\n\t    break;\n\t}\n    }\n\n    return result;\n}\n\nstatic int\nconsole_twait(\n\t\t SCREEN *sp,\n\t\t HANDLE fd,\n\t\t int mode,\n\t\t int milliseconds,\n\t\t int *timeleft\n\t\t EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    INPUT_RECORD inp_rec;\n    BOOL b;\n    DWORD nRead = 0, rc = (DWORD) (-1);\n    int code = 0;\n    FILETIME fstart;\n    FILETIME fend;\n    int diff;\n    bool isImmed = (milliseconds == 0);\n\n#ifdef NCURSES_WGETCH_EVENTS\n    (void) evl;\t\t\t \n#endif\n\n#define CONSUME() ReadConsoleInput(fd,&inp_rec,1,&nRead)\n\n    assert(sp);\n\n    TR(TRACE_IEVENT, (\"start twait: %d milliseconds, mode: %d\",\n\t\t      milliseconds, mode));\n\n    if (milliseconds < 0)\n\tmilliseconds = INFINITY;\n\n    memset(&inp_rec, 0, sizeof(inp_rec));\n\n    while (true) {\n\tGetSystemTimeAsFileTime(&fstart);\n\trc = WaitForSingleObject(fd, (DWORD) milliseconds);\n\tGetSystemTimeAsFileTime(&fend);\n\tdiff = (int) tdiff(fstart, fend);\n\tmilliseconds = Adjust(milliseconds, diff);\n\n\tif (!isImmed && milliseconds <= 0)\n\t    break;\n\n\tif (rc == WAIT_OBJECT_0) {\n\t    if (mode) {\n\t\tb = GetNumberOfConsoleInputEvents(fd, &nRead);\n\t\tif (b && nRead > 0) {\n\t\t    b = PeekConsoleInput(fd, &inp_rec, 1, &nRead);\n\t\t    if (b && nRead > 0) {\n\t\t\tswitch (inp_rec.EventType) {\n\t\t\tcase KEY_EVENT:\n\t\t\t    if (mode & TW_INPUT) {\n\t\t\t\tWORD vk = inp_rec.Event.KeyEvent.wVirtualKeyCode;\n\t\t\t\tchar ch = inp_rec.Event.KeyEvent.uChar.AsciiChar;\n\n\t\t\t\tif (inp_rec.Event.KeyEvent.bKeyDown) {\n\t\t\t\t    if (0 == ch) {\n\t\t\t\t\tint nKey = MapKey(vk);\n\t\t\t\t\tif (nKey < 0) {\n\t\t\t\t\t    CONSUME();\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    code = TW_INPUT;\n\t\t\t\t    goto end;\n\t\t\t\t} else {\n\t\t\t\t    CONSUME();\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    continue;\n\t\t\tcase MOUSE_EVENT:\n\t\t\t    if (decode_mouse(sp,\n\t\t\t\t\t     (inp_rec.Event.MouseEvent.dwButtonState\n\t\t\t\t\t      & BUTTON_MASK)) == 0) {\n\t\t\t\tCONSUME();\n\t\t\t    } else if (mode & TW_MOUSE) {\n\t\t\t\tcode = TW_MOUSE;\n\t\t\t\tgoto end;\n\t\t\t    }\n\t\t\t    continue;\n\t\t\t     \n\t\t\tdefault:\n\t\t\t    CONSUME();\n\t\t\t    selectActiveHandle();\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    continue;\n\t} else {\n\t    if (rc != WAIT_TIMEOUT) {\n\t\tcode = -1;\n\t\tbreak;\n\t    } else {\n\t\tcode = 0;\n\t\tbreak;\n\t    }\n\t}\n    }\n  end:\n\n    TR(TRACE_IEVENT, (\"end twait: returned %d (%d), remaining time %d msec\",\n\t\t      code, errno, milliseconds));\n\n    if (timeleft)\n\t*timeleft = milliseconds;\n\n    return code;\n}\n\nstatic int\nwcon_twait(TERMINAL_CONTROL_BLOCK * TCB,\n\t   int mode,\n\t   int milliseconds,\n\t   int *timeleft\n\t   EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    SCREEN *sp;\n    int code = 0;\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tcode = console_twait(sp,\n\t\t\t     CON.inp,\n\t\t\t     mode,\n\t\t\t     milliseconds,\n\t\t\t     timeleft EVENTLIST_2nd(evl));\n    }\n    return code;\n}\n\nstatic bool\nhandle_mouse(SCREEN *sp, MOUSE_EVENT_RECORD mer)\n{\n    MEVENT work;\n    bool result = FALSE;\n\n    assert(sp);\n\n    sp->_drv_mouse_old_buttons = sp->_drv_mouse_new_buttons;\n    sp->_drv_mouse_new_buttons = mer.dwButtonState & BUTTON_MASK;\n\n     \n    if (sp->_drv_mouse_new_buttons != sp->_drv_mouse_old_buttons) {\n\n\tmemset(&work, 0, sizeof(work));\n\n\tif (sp->_drv_mouse_new_buttons) {\n\n\t    work.bstate |= (mmask_t) decode_mouse(sp, sp->_drv_mouse_new_buttons);\n\n\t} else {\n\n\t     \n\t    work.bstate |= (mmask_t) (decode_mouse(sp,\n\t\t\t\t\t\t   sp->_drv_mouse_old_buttons)\n\t\t\t\t      >> 1);\n\n\t    result = TRUE;\n\t}\n\n\twork.x = mer.dwMousePosition.X;\n\twork.y = mer.dwMousePosition.Y - AdjustY();\n\n\tsp->_drv_mouse_fifo[sp->_drv_mouse_tail] = work;\n\tsp->_drv_mouse_tail += 1;\n    }\n\n    return result;\n}\n\nstatic int\nwcon_read(TERMINAL_CONTROL_BLOCK * TCB, int *buf)\n{\n    SCREEN *sp;\n    int n = -1;\n\n    T((T_CALLED(\"win32con::wcon_read(%p)\"), TCB));\n\n    assert(buf);\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tn = _nc_mingw_console_read(sp, CON.inp, buf);\n    }\n    returnCode(n);\n}\n\nstatic int\nwcon_nap(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int ms)\n{\n    T((T_CALLED(\"win32con::wcon_nap(%p, %d)\"), TCB, ms));\n    Sleep((DWORD) ms);\n    returnCode(OK);\n}\n\nstatic int\nwcon_cursorSet(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int mode)\n{\n    int res = -1;\n\n    T((T_CALLED(\"win32con:wcon_cursorSet(%d)\"), mode));\n    if (okConsoleHandle(TCB)) {\n\tCONSOLE_CURSOR_INFO this_CI = CON.save_CI;\n\tswitch (mode) {\n\tcase 0:\n\t    this_CI.bVisible = FALSE;\n\t    break;\n\tcase 1:\n\t    break;\n\tcase 2:\n\t    this_CI.dwSize = 100;\n\t    break;\n\t}\n\tSetConsoleCursorInfo(CON.hdl, &this_CI);\n    }\n    returnCode(res);\n}\n\nstatic bool\nwcon_kyExist(TERMINAL_CONTROL_BLOCK * TCB GCC_UNUSED, int keycode)\n{\n    WORD nKey;\n    void *res;\n    bool found = FALSE;\n    LONG key = GenMap(0, (WORD) keycode);\n\n    T((T_CALLED(\"win32con::wcon_kyExist(%d)\"), keycode));\n    res = bsearch(&key,\n\t\t  CON.rmap,\n\t\t  (size_t) (N_INI + FKEYS),\n\t\t  sizeof(keylist[0]),\n\t\t  rkeycompare);\n    if (res) {\n\tkey = *((LONG *) res);\n\tnKey = LOWORD(key);\n\tif (!(nKey & 0x8000))\n\t    found = TRUE;\n    }\n    returnCode(found);\n}\n\nstatic int\nwcon_kpad(TERMINAL_CONTROL_BLOCK * TCB, int flag GCC_UNUSED)\n{\n    SCREEN *sp;\n    int code = ERR;\n\n    T((T_CALLED(\"win32con::wcon_kpad(%p, %d)\"), TCB, flag));\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tif (sp) {\n\t    code = OK;\n\t}\n    }\n    returnCode(code);\n}\n\nstatic int\nwcon_keyok(TERMINAL_CONTROL_BLOCK * TCB,\n\t   int keycode,\n\t   int flag)\n{\n    int code = ERR;\n    SCREEN *sp;\n    WORD nKey;\n    WORD vKey;\n    void *res;\n    LONG key = GenMap(0, (WORD) keycode);\n\n    T((T_CALLED(\"win32con::wcon_keyok(%p, %d, %d)\"), TCB, keycode, flag));\n\n    if (okConsoleHandle(TCB)) {\n\tSetSP();\n\n\tif (sp) {\n\t    res = bsearch(&key,\n\t\t\t  CON.rmap,\n\t\t\t  (size_t) (N_INI + FKEYS),\n\t\t\t  sizeof(keylist[0]),\n\t\t\t  rkeycompare);\n\t    if (res) {\n\t\tkey = *((LONG *) res);\n\t\tvKey = HIWORD(key);\n\t\tnKey = (LOWORD(key)) & 0x7fff;\n\t\tif (!flag)\n\t\t    nKey |= 0x8000;\n\t\t*(LONG *) res = GenMap(vKey, nKey);\n\t    }\n\t}\n    }\n    returnCode(code);\n}\n\nNCURSES_EXPORT_VAR (TERM_DRIVER) _nc_WIN_DRIVER = {\n    FALSE,\n\twcon_name,\t\t \n\twcon_CanHandle,\t\t \n\twcon_init,\t\t \n\twcon_release,\t\t \n\twcon_size,\t\t \n\twcon_sgmode,\t\t \n\twcon_conattr,\t\t \n\twcon_mvcur,\t\t \n\twcon_mode,\t\t \n\twcon_rescol,\t\t \n\twcon_rescolors,\t\t \n\twcon_setcolor,\t\t \n\twcon_dobeepflash,\t \n\twcon_initpair,\t\t \n\twcon_initcolor,\t\t \n\twcon_do_color,\t\t \n\twcon_initmouse,\t\t \n\twcon_testmouse,\t\t \n\twcon_setfilter,\t\t \n\twcon_hwlabel,\t\t \n\twcon_hwlabelOnOff,\t \n\twcon_doupdate,\t\t \n\twcon_defaultcolors,\t \n\twcon_print,\t\t \n\twcon_size,\t\t \n\twcon_setsize,\t\t \n\twcon_initacs,\t\t \n\twcon_screen_init,\t \n\twcon_wrap,\t\t \n\twcon_twait,\t\t \n\twcon_read,\t\t \n\twcon_nap,\t\t \n\twcon_kpad,\t\t \n\twcon_keyok,\t\t \n\twcon_kyExist,\t\t \n\twcon_cursorSet\t\t \n};\n\n \n\nstatic HANDLE\nget_handle(int fd)\n{\n    intptr_t value = _get_osfhandle(fd);\n    return (HANDLE) value;\n}\n\n#if WINVER >= 0x0600\n \nstatic int\n_ismintty(int fd, LPHANDLE pMinTTY)\n{\n    HANDLE handle = get_handle(fd);\n    DWORD dw;\n    int code = 0;\n\n    T((T_CALLED(\"win32con::_ismintty(%d, %p)\"), fd, pMinTTY));\n\n    if (handle != INVALID_HANDLE_VALUE) {\n\tdw = GetFileType(handle);\n\tif (dw == FILE_TYPE_PIPE) {\n\t    if (GetNamedPipeInfo(handle, 0, 0, 0, 0)) {\n\t\tULONG pPid;\n\t\t \n\t\tif (GetNamedPipeServerProcessId(handle, &pPid)) {\n\t\t    TCHAR buf[MAX_PATH];\n\t\t    DWORD len = 0;\n\t\t     \n\t\t    HANDLE pHandle = OpenProcess(\n\t\t\t\t\t\t    PROCESS_CREATE_THREAD\n\t\t\t\t\t\t    | PROCESS_QUERY_INFORMATION\n\t\t\t\t\t\t    | PROCESS_VM_OPERATION\n\t\t\t\t\t\t    | PROCESS_VM_WRITE\n\t\t\t\t\t\t    | PROCESS_VM_READ,\n\t\t\t\t\t\t    FALSE,\n\t\t\t\t\t\t    pPid);\n\t\t    if (pMinTTY)\n\t\t\t*pMinTTY = INVALID_HANDLE_VALUE;\n\t\t    if (pHandle != INVALID_HANDLE_VALUE) {\n\t\t\tif ((len = GetProcessImageFileName(\n\t\t\t\t\t\t\t      pHandle,\n\t\t\t\t\t\t\t      buf,\n\t\t\t\t\t\t\t      (DWORD)\n\t\t\t\t\t\t\t      array_length(buf)))) {\n\t\t\t    TCHAR *pos = _tcsrchr(buf, _T('\\\\'));\n\t\t\t    if (pos) {\n\t\t\t\tpos++;\n\t\t\t\tif (_tcsnicmp(pos, _TEXT(\"mintty.exe\"), 10)\n\t\t\t\t    == 0) {\n\t\t\t\t    if (pMinTTY)\n\t\t\t\t\t*pMinTTY = pHandle;\n\t\t\t\t    code = 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    returnCode(code);\n}\n#endif\n\n \nstatic BOOL\nIsConsoleHandle(HANDLE hdl)\n{\n    DWORD dwFlag = 0;\n    BOOL result;\n\n    if (!GetConsoleMode(hdl, &dwFlag)) {\n\tresult = (int) WriteConsoleA(hdl, NULL, 0, &dwFlag, NULL);\n    } else {\n\tresult = (int) (dwFlag & ENABLE_PROCESSED_OUTPUT);\n    }\n    return result;\n}\n\n \nint\n_nc_mingw_isatty(int fd)\n{\n    int result = 0;\n\n#ifdef __MING32__\n#define SysISATTY(fd) _isatty(fd)\n#else\n#define SysISATTY(fd) isatty(fd)\n#endif\n    if (SysISATTY(fd)) {\n\tresult = 1;\n    } else {\n#if WINVER >= 0x0600\n\tresult = _ismintty(fd, NULL);\n#endif\n    }\n    return result;\n}\n\n \nint\n_nc_mingw_isconsole(int fd)\n{\n    HANDLE hdl = get_handle(fd);\n    int code = 0;\n\n    T((T_CALLED(\"win32con::_nc_mingw_isconsole(%d)\"), fd));\n\n    code = (int) IsConsoleHandle(hdl);\n\n    returnCode(code);\n}\n\n#define TC_PROLOGUE(fd) \\\n    SCREEN *sp;                                               \\\n    TERMINAL *term = 0;                                       \\\n    int code = ERR;                                           \\\n    if (_nc_screen_chain == 0)                                \\\n        return 0;                                             \\\n    for (each_screen(sp)) {                                   \\\n        if (sp->_term && (sp->_term->Filedes == fd)) {        \\\n            term = sp->_term;                                 \\\n            break;                                            \\\n        }                                                     \\\n    }                                                         \\\n    assert(term != 0)\n\nint\n_nc_mingw_tcsetattr(\n\t\t       int fd,\n\t\t       int optional_action GCC_UNUSED,\n\t\t       const struct termios *arg)\n{\n    TC_PROLOGUE(fd);\n\n    if (_nc_mingw_isconsole(fd)) {\n\tDWORD dwFlag = 0;\n\tHANDLE ofd = get_handle(fd);\n\tif (ofd != INVALID_HANDLE_VALUE) {\n\t    if (arg) {\n\t\tif (arg->c_lflag & ICANON)\n\t\t    dwFlag |= ENABLE_LINE_INPUT;\n\t\telse\n\t\t    dwFlag = dwFlag & (DWORD) (~ENABLE_LINE_INPUT);\n\n\t\tif (arg->c_lflag & ECHO)\n\t\t    dwFlag = dwFlag | ENABLE_ECHO_INPUT;\n\t\telse\n\t\t    dwFlag = dwFlag & (DWORD) (~ENABLE_ECHO_INPUT);\n\n\t\tif (arg->c_iflag & BRKINT)\n\t\t    dwFlag |= ENABLE_PROCESSED_INPUT;\n\t\telse\n\t\t    dwFlag = dwFlag & (DWORD) (~ENABLE_PROCESSED_INPUT);\n\t    }\n\t    dwFlag |= ENABLE_MOUSE_INPUT;\n\t    SetConsoleMode(ofd, dwFlag);\n\t    code = OK;\n\t}\n    }\n    if (arg)\n\tterm->Nttyb = *arg;\n\n    return code;\n}\n\nint\n_nc_mingw_tcgetattr(int fd, struct termios *arg)\n{\n    TC_PROLOGUE(fd);\n\n    if (_nc_mingw_isconsole(fd)) {\n\tif (arg)\n\t    *arg = term->Nttyb;\n    }\n    return code;\n}\n\nint\n_nc_mingw_tcflush(int fd, int queue)\n{\n    TC_PROLOGUE(fd);\n    (void) term;\n\n    if (_nc_mingw_isconsole(fd)) {\n\tif (queue == TCIFLUSH) {\n\t    BOOL b = FlushConsoleInputBuffer(GetStdHandle(STD_INPUT_HANDLE));\n\t    if (!b)\n\t\treturn (int) GetLastError();\n\t}\n    }\n    return code;\n}\n\nint\n_nc_mingw_testmouse(\n\t\t       SCREEN *sp,\n\t\t       HANDLE fd,\n\t\t       int delay\n\t\t       EVENTLIST_2nd(_nc_eventlist * evl))\n{\n    int rc = 0;\n\n    assert(sp);\n\n    if (sp->_drv_mouse_head < sp->_drv_mouse_tail) {\n\trc = TW_MOUSE;\n    } else {\n\trc = console_twait(sp,\n\t\t\t   fd,\n\t\t\t   TWAIT_MASK,\n\t\t\t   delay,\n\t\t\t   (int *) 0\n\t\t\t   EVENTLIST_2nd(evl));\n    }\n    return rc;\n}\n\nint\n_nc_mingw_console_read(\n\t\t\t  SCREEN *sp,\n\t\t\t  HANDLE fd,\n\t\t\t  int *buf)\n{\n    int rc = -1;\n    INPUT_RECORD inp_rec;\n    BOOL b;\n    DWORD nRead;\n    WORD vk;\n\n    assert(sp);\n    assert(buf);\n\n    memset(&inp_rec, 0, sizeof(inp_rec));\n\n    T((T_CALLED(\"_nc_mingw_console_read(%p)\"), sp));\n\n    while ((b = ReadConsoleInput(fd, &inp_rec, 1, &nRead))) {\n\tif (b && nRead > 0) {\n\t    if (rc < 0)\n\t\trc = 0;\n\t    rc = rc + (int) nRead;\n\t    if (inp_rec.EventType == KEY_EVENT) {\n\t\tif (!inp_rec.Event.KeyEvent.bKeyDown)\n\t\t    continue;\n\t\t*buf = (int) inp_rec.Event.KeyEvent.uChar.AsciiChar;\n\t\tvk = inp_rec.Event.KeyEvent.wVirtualKeyCode;\n\t\t \n\t\tif (vk >= VK_F1 && vk <= VK_F12) {\n\t\t    if (inp_rec.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED) {\n\t\t\tvk = (WORD) (vk + 12);\n\t\t    }\n\t\t}\n\t\tif (*buf == 0) {\n\t\t    int key = MapKey(vk);\n\t\t    if (key < 0)\n\t\t\tcontinue;\n\t\t    if (sp->_keypad_on) {\n\t\t\t*buf = key;\n\t\t    } else {\n\t\t\tungetch('\\0');\n\t\t\t*buf = AnsiKey(vk);\n\t\t    }\n\t\t}\n\t\tbreak;\n\t    } else if (inp_rec.EventType == MOUSE_EVENT) {\n\t\tif (handle_mouse(sp,\n\t\t\t\t inp_rec.Event.MouseEvent)) {\n\t\t    *buf = KEY_MOUSE;\n\t\t    break;\n\t\t}\n\t    }\n\t    continue;\n\t}\n    }\n    returnCode(rc);\n}\n\nstatic bool\nInitConsole(void)\n{\n     \n    if (!console_initialized) {\n\tint i;\n\tDWORD num_buttons;\n\tWORD a;\n\tBOOL buffered = TRUE;\n\tBOOL b;\n\n\tSTART_TRACE();\n\tif (_nc_mingw_isatty(0)) {\n\t    CON.isMinTTY = TRUE;\n\t}\n\n\tfor (i = 0; i < (N_INI + FKEYS); i++) {\n\t    if (i < N_INI) {\n\t\tCON.rmap[i] = CON.map[i] =\n\t\t    (DWORD) keylist[i];\n\t\tCON.ansi_map[i] = (DWORD) ansi_keys[i];\n\t    } else {\n\t\tCON.rmap[i] = CON.map[i] =\n\t\t    (DWORD) GenMap((VK_F1 + (i - N_INI)),\n\t\t\t\t   (KEY_F(1) + (i - N_INI)));\n\t\tCON.ansi_map[i] =\n\t\t    (DWORD) GenMap((VK_F1 + (i - N_INI)),\n\t\t\t\t   (';' + (i - N_INI)));\n\t    }\n\t}\n\tqsort(CON.ansi_map,\n\t      (size_t) (MAPSIZE),\n\t      sizeof(keylist[0]),\n\t      keycompare);\n\tqsort(CON.map,\n\t      (size_t) (MAPSIZE),\n\t      sizeof(keylist[0]),\n\t      keycompare);\n\tqsort(CON.rmap,\n\t      (size_t) (MAPSIZE),\n\t      sizeof(keylist[0]),\n\t      rkeycompare);\n\n\tif (GetNumberOfConsoleMouseButtons(&num_buttons)) {\n\t    CON.numButtons = (int) num_buttons;\n\t} else {\n\t    CON.numButtons = 1;\n\t}\n\n\ta = MapColor(true, COLOR_WHITE) | MapColor(false, COLOR_BLACK);\n\tfor (i = 0; i < NUMPAIRS; i++)\n\t    CON.pairs[i] = a;\n\n\tCON.inp = GetStdHandle(STD_INPUT_HANDLE);\n\tCON.out = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\tb = AllocConsole();\n\n\tif (!b)\n\t    b = AttachConsole(ATTACH_PARENT_PROCESS);\n\n\tif (getenv(\"NCGDB\") || getenv(\"NCURSES_CONSOLE2\")) {\n\t    T((\"... will not buffer console\"));\n\t    buffered = FALSE;\n\t    CON.hdl = CON.out;\n\t} else {\n\t    T((\"... creating console buffer\"));\n\t    CON.hdl = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tCONSOLE_TEXTMODE_BUFFER,\n\t\t\t\t\t\tNULL);\n\t}\n\n\tif (CON.hdl != INVALID_HANDLE_VALUE) {\n\t    CON.buffered = buffered;\n\t    get_SBI();\n\t    CON.save_SBI = CON.SBI;\n\t    if (!buffered) {\n\t\tsave_original_screen();\n\t\tset_scrollback(FALSE, &CON.SBI);\n\t    }\n\t    GetConsoleCursorInfo(CON.hdl, &CON.save_CI);\n\t    T((\"... initial cursor is %svisible, %d%%\",\n\t       (CON.save_CI.bVisible ? \"\" : \"not-\"),\n\t       (int) CON.save_CI.dwSize));\n\t}\n\n\tconsole_initialized = TRUE;\n    }\n    return (CON.hdl != INVALID_HANDLE_VALUE);\n}\n\nstatic bool\nokConsoleHandle(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    return ((TCB != 0) &&\n\t    (TCB->magic == WINMAGIC) &&\n\t    InitConsole());\n}\n\n \n#if 0\nstatic\n__attribute__((constructor))\n     void _enter_console(void)\n{\n    (void) InitConsole();\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}