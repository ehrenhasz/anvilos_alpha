{
  "module_name": "curs_inopts.3x",
  "hash_id": "75f7e482e1cae9bb30042ed49c93f9c221870334224181cf3211e95289bcd34d",
  "original_prompt": "Ingested from ncurses-6.4/man/curs_inopts.3x",
  "human_readable_source": ".\\\"***************************************************************************\n.\\\" Copyright 2018-2021,2022 Thomas E. Dickey                                *\n.\\\" Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *\n.\\\"                                                                          *\n.\\\" Permission is hereby granted, free of charge, to any person obtaining a  *\n.\\\" copy of this software and associated documentation files (the            *\n.\\\" \"Software\"), to deal in the Software without restriction, including      *\n.\\\" without limitation the rights to use, copy, modify, merge, publish,      *\n.\\\" distribute, distribute with modifications, sublicense, and/or sell       *\n.\\\" copies of the Software, and to permit persons to whom the Software is    *\n.\\\" furnished to do so, subject to the following conditions:                 *\n.\\\"                                                                          *\n.\\\" The above copyright notice and this permission notice shall be included  *\n.\\\" in all copies or substantial portions of the Software.                   *\n.\\\"                                                                          *\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n.\\\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n.\\\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n.\\\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n.\\\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n.\\\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n.\\\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n.\\\"                                                                          *\n.\\\" Except as contained in this notice, the name(s) of the above copyright   *\n.\\\" holders shall not be used in advertising or otherwise to promote the     *\n.\\\" sale, use or other dealings in this Software without prior written       *\n.\\\" authorization.                                                           *\n.\\\"***************************************************************************\n.\\\"\n.\\\" $Id: curs_inopts.3x,v 1.36 2022/02/12 20:07:29 tom Exp $\n.TH curs_inopts 3X \"\"\n.ie \\n(.g .ds `` \\(lq\n.el       .ds `` ``\n.ie \\n(.g .ds '' \\(rq\n.el       .ds '' ''\n.na\n.hy 0\n.SH NAME\n\\fBcbreak\\fP,\n\\fBnocbreak\\fP,\n\\fBecho\\fP,\n\\fBnoecho\\fP,\n\\fBhalfdelay\\fP,\n\\fBintrflush\\fP,\n\\fBkeypad\\fP,\n\\fBmeta\\fP,\n\\fBnl\\fP,\n\\fBnonl\\fP,\n\\fBnodelay\\fP,\n\\fBnotimeout\\fP,\n\\fBraw\\fP,\n\\fBnoraw\\fP,\n\\fBqiflush\\fP,\n\\fBnoqiflush\\fP,\n\\fBtimeout\\fP,\n\\fBwtimeout\\fP,\n\\fBtypeahead\\fP \\- \\fBcurses\\fP input options\n.ad\n.hy\n.SH SYNOPSIS\n\\fB#include <curses.h>\\fP\n.PP\n\\fBint cbreak(void);\\fP\n.br\n\\fBint nocbreak(void);\\fP\n.sp\n\\fBint echo(void);\\fP\n.br\n\\fBint noecho(void);\\fP\n.sp\n\\fBint intrflush(WINDOW *\\fIwin\\fB, bool \\fIbf\\fB);\\fR\n.br\n\\fBint keypad(WINDOW *\\fIwin\\fB, bool \\fIbf\\fB);\\fR\n.br\n\\fBint meta(WINDOW *\\fIwin\\fB, bool \\fIbf\\fB);\\fR\n.br\n\\fBint nodelay(WINDOW *\\fIwin\\fB, bool \\fIbf\\fB);\\fR\n.br\n\\fBint notimeout(WINDOW *\\fIwin\\fB, bool \\fIbf\\fB);\\fR\n.sp\n\\fBint nl(void);\\fP\n.br\n\\fBint nonl(void);\\fP\n.sp\n\\fBint raw(void);\\fP\n.br\n\\fBint noraw(void);\\fP\n.sp\n\\fBvoid qiflush(void);\\fP\n.br\n\\fBvoid noqiflush(void);\\fP\n.sp\n\\fBint halfdelay(int \\fItenths\\fB);\\fR\n.br\n\\fBvoid timeout(int \\fIdelay\\fB);\\fR\n.br\n\\fBvoid wtimeout(WINDOW *\\fIwin\\fB, int \\fIdelay\\fB);\\fR\n.sp\n\\fBint typeahead(int \\fIfd\\fB);\\fR\n.br\n.SH DESCRIPTION\nThe \\fBncurses\\fP library provides several functions which let an application\nchange the way input from the terminal is handled.\nSome are global, applying to all windows.\nOthers apply only to a specific window.\nWindow-specific settings are not automatically applied to new or derived\nwindows.\nAn application must apply these to each window, if the same behavior\nis needed.\n.\\\"\n.SS cbreak/nocbreak\nNormally, the tty driver buffers typed characters until a newline or carriage\nreturn is typed.\nThe \\fBcbreak\\fP routine disables line buffering and\nerase/kill character-processing (interrupt and flow control characters are\nunaffected), making characters typed by the user immediately available to the\nprogram.\nThe \\fBnocbreak\\fP routine returns the terminal to normal (cooked)\nmode.\n.PP\nInitially the terminal may or may not be in \\fBcbreak\\fP mode, as the mode is\ninherited; therefore, a program should call \\fBcbreak\\fP or \\fBnocbreak\\fP\nexplicitly.\nMost interactive programs using \\fBcurses\\fP set the \\fBcbreak\\fP\nmode.\nNote that \\fBcbreak\\fP overrides \\fBraw\\fP.\n[See \\fBcurs_getch\\fP(3X) for a\ndiscussion of how these routines interact with \\fBecho\\fP and \\fBnoecho\\fP.]\n.\\\"\n.SS echo/noecho\n.PP\nThe \\fBecho\\fP and \\fBnoecho\\fP routines control whether characters typed by\nthe user are echoed by \\fBgetch\\fP(3X) as they are typed.\nEchoing by the tty\ndriver is always disabled, but initially \\fBgetch\\fP is in echo mode, so\ncharacters typed are echoed.\nAuthors of most interactive programs prefer to do\ntheir own echoing in a controlled area of the screen, or not to echo at all, so\nthey disable echoing by calling \\fBnoecho\\fP.\n[See \\fBcurs_getch\\fP(3X) for a\ndiscussion of how these routines interact with \\fBcbreak\\fP and\n\\fBnocbreak\\fP.]\n.\\\"\n.SS halfdelay\n.PP\nThe \\fBhalfdelay\\fP routine is used for half-delay mode, which is similar to\n\\fBcbreak\\fP mode in that characters typed by the user are immediately\navailable to the program.\nHowever, after blocking for \\fItenths\\fP tenths of\nseconds, \\fBERR\\fP is returned if nothing has been typed.\nThe value of \\fItenths\\fP\nmust be a number between 1 and 255.\nUse \\fBnocbreak\\fP to leave half-delay\nmode.\n.\\\"\n.SS intrflush\n.PP\nIf the \\fBintrflush\\fP option is enabled (\\fIbf\\fP is \\fBTRUE\\fP), and an\ninterrupt key is pressed on the keyboard (interrupt, break, quit), all output in\nthe tty driver queue will be flushed, giving the effect of faster response to\nthe interrupt, but causing \\fBcurses\\fP to have the wrong idea of what is on\nthe screen.\nDisabling the option (\\fIbf\\fP is \\fBFALSE\\fP) prevents the\nflush.\nThe default for the option is inherited from the tty driver settings.\nThe window argument is ignored.\n.\\\"\n.SS keypad\n.PP\nThe \\fBkeypad\\fP option enables the keypad of the user's terminal.\nIf\nenabled (\\fIbf\\fP is \\fBTRUE\\fP), the user can press a function key\n(such as an arrow key) and \\fBwgetch\\fP(3X) returns a single value\nrepresenting the function key, as in \\fBKEY_LEFT\\fP.\nIf disabled\n(\\fIbf\\fP is \\fBFALSE\\fP), \\fBcurses\\fP does not treat function keys\nspecially and the program has to interpret the escape sequences\nitself.\nIf the keypad in the terminal can be turned on (made to\ntransmit) and off (made to work locally), turning on this option\ncauses the terminal keypad to be turned on when \\fBwgetch\\fP(3X) is\ncalled.\nThe default value for keypad is \\fBFALSE\\fP.\n.\\\"\n.SS meta\n.PP\nInitially, whether the terminal returns 7 or 8 significant bits on\ninput depends on the control mode of the tty driver [see \\fBtermios\\fP(3)].\nTo force 8 bits to be returned, invoke \\fBmeta\\fP(\\fIwin\\fP,\n\\fBTRUE\\fP); this is equivalent, under POSIX, to setting the CS8 flag\non the terminal.\nTo force 7 bits to be returned, invoke\n\\fBmeta\\fP(\\fIwin\\fP, \\fBFALSE\\fP); this is equivalent, under POSIX,\nto setting the CS7 flag on the terminal.\nThe window argument,\n\\fIwin\\fP, is always ignored.\nIf the terminfo capabilities \\fBsmm\\fP\n(meta_on) and \\fBrmm\\fP (meta_off) are defined for the terminal,\n\\fBsmm\\fP is sent to the terminal when \\fBmeta\\fP(\\fIwin\\fP,\n\\fBTRUE\\fP) is called and \\fBrmm\\fP is sent when \\fBmeta\\fP(\\fIwin\\fP,\n\\fBFALSE\\fP) is called.\n.\\\"\n.SS nl/nonl\n.PP\nThe \\fBnl\\fP and \\fBnonl\\fP routines control whether the underlying display\ndevice translates the return key into newline on input.\n.\\\"\n.SS nodelay\n.PP\nThe \\fBnodelay\\fP option causes \\fBgetch\\fP to be a non-blocking call.\nIf no input is ready, \\fBgetch\\fP returns \\fBERR\\fP.\nIf disabled\n(\\fIbf\\fP is \\fBFALSE\\fP), \\fBgetch\\fP waits until a key is pressed.\n.SS notimeout\n.PP\nWhen interpreting an escape sequence, \\fBwgetch\\fP(3X) sets a timer\nwhile waiting for the next character.\nIf \\fBnotimeout(\\fIwin\\fR,\n\\fBTRUE\\fP) is called, then \\fBwgetch\\fP does not set a timer.\nThe\npurpose of the timeout is to differentiate between sequences received\nfrom a function key and those typed by a user.\n.\\\"\n.SS raw/noraw\n.PP\nThe \\fBraw\\fP and \\fBnoraw\\fP routines place the terminal into or out of raw\nmode.\nRaw mode is similar to \\fBcbreak\\fP mode, in that characters typed are\nimmediately passed through to the user program.\nThe differences are that in\nraw mode, the interrupt, quit, suspend, and flow control characters are all\npassed through uninterpreted, instead of generating a signal.\nThe behavior of\nthe BREAK key depends on other bits in the tty driver that are not set by\n\\fBcurses\\fP.\n.\\\"\n.SS qiflush/noqiflush\n.PP\nWhen the \\fBnoqiflush\\fP routine is used, normal flush of input and\noutput queues associated with the \\fBINTR\\fP, \\fBQUIT\\fP and\n\\fBSUSP\\fP characters will not be done [see \\fBtermios\\fP(3)].\nWhen\n\\fBqiflush\\fP is called, the queues will be flushed when these control\ncharacters are read.\nYou may want to call \\fBnoqiflush\\fP in a signal\nhandler if you want output to continue as though the interrupt\nhad not occurred, after the handler exits.\n.\\\"\n.SS timeout/wtimeout\n.PP\nThe \\fBtimeout\\fP and \\fBwtimeout\\fP routines set blocking or\nnon-blocking read for a given window.\nIf \\fIdelay\\fP is negative,\nblocking read is used (i.e., waits indefinitely for\ninput).\nIf \\fIdelay\\fP is zero, then non-blocking read is used\n(i.e., read returns \\fBERR\\fP if no input is waiting).\nIf\n\\fIdelay\\fP is positive, then read blocks for \\fIdelay\\fP\nmilliseconds, and returns \\fBERR\\fP if there is still no input.\nHence, these routines provide the same functionality as \\fBnodelay\\fP,\nplus the additional capability of being able to block for only\n\\fIdelay\\fP milliseconds (where \\fIdelay\\fP is positive).\n.\\\"\n.SS typeahead\n.PP\nThe \\fBcurses\\fP library does \\*(``line-breakout optimization\\*(''\nby looking for typeahead periodically while updating the screen.\nIf input is found, and it is coming from a tty,\nthe current update is postponed until\n\\fBrefresh\\fP(3X) or \\fBdoupdate\\fP is called again.\nThis allows faster response to commands typed in advance.\nNormally, the input FILE\npointer passed to \\fBnewterm\\fP, or \\fBstdin\\fP in the case that\n\\fBinitscr\\fP was used, will be used to do this typeahead checking.\nThe \\fBtypeahead\\fP routine specifies that the file descriptor\n\\fIfd\\fP is to be used to check for typeahead instead.\nIf \\fIfd\\fP is\n\\-1, then no typeahead checking is done.\n.\\\"\n.SH RETURN VALUE\nAll routines that return an integer return \\fBERR\\fP upon failure and \\fBOK\\fP\n(SVr4 specifies only \\*(``an integer value other than \\fBERR\\fP\\*('')\nupon successful completion,\nunless otherwise noted in the preceding routine descriptions.\n.PP\nX/Open does not define any error conditions.\nIn this implementation,\nfunctions with a window parameter will return an error if it is null.\nAny function will also return an error if the terminal was not initialized.\nAlso,\n.RS\n.TP 5\n\\fBhalfdelay\\fP\nreturns an error\nif its parameter is outside the range 1..255.\n.RE\n.SH PORTABILITY\nThese functions are described in the XSI Curses standard, Issue 4.\n.PP\nThe ncurses library obeys the XPG4 standard and the historical practice of the\nAT&T curses implementations, in that the echo bit is cleared when curses\ninitializes the terminal state.\nBSD curses differed from this slightly; it\nleft the echo bit on at initialization, but the BSD \\fBraw\\fP call turned it\noff as a side-effect.\nFor best portability, set \\fBecho \\fPor \\fBnoecho\\fP explicitly\njust after initialization, even if your program remains in cooked mode.\n.PP\nThe XSI Curses standard is ambiguous on the question of whether \\fBraw\\fP\nshould disable the CRLF translations controlled by \\fBnl\\fP and \\fBnonl\\fP.\nBSD curses did turn off these translations; AT&T curses (at least as late as\nSVr1) did not.\nWe chose to do so, on the theory that a programmer requesting\nraw input wants a clean (ideally 8-bit clean) connection that the operating\nsystem will not alter.\n.PP\nWhen \\fBkeypad\\fP is first enabled,\nncurses loads the key-definitions for the current terminal description.\nIf the terminal description includes extended string capabilities,\ne.g., from using the \\fB\\-x\\fP option of \\fB@TIC@\\fP,\nthen ncurses also defines keys for the capabilities whose names\nbegin with \\*(``k\\*(''.\nThe corresponding keycodes are generated and (depending on previous\nloads of terminal descriptions) may differ from one execution of a\nprogram to the next.\nThe generated keycodes are recognized by the \\fBkeyname\\fP function\n(which will then return a name beginning with \\*(``k\\*('' denoting the\nterminfo capability name rather than \\*(``K\\*('', used for curses key-names).\nOn the other hand, an application can use \\fBdefine_key\\fP to establish\na specific keycode for a given string.\nThis makes it possible for an application to check for an extended\ncapability's presence with \\fBtigetstr\\fP,\nand reassign the keycode to match its own needs.\n.PP\nLow-level applications can use \\fBtigetstr\\fP to obtain the definition\nof any particular string capability.\nHigher-level applications which use the curses \\fBwgetch\\fP\nand similar functions to return keycodes rely upon the order in which\nthe strings are loaded.\nIf more than one key definition has the same string value,\nthen \\fBwgetch\\fP can return only one keycode.\nMost curses implementations (including ncurses)\nload key definitions in the order\ndefined by the array of string capability names.\nThe last key to be loaded determines the keycode which will be returned.\nIn ncurses, you may also have extended capabilities interpreted as\nkey definitions.\nThese are loaded after the predefined keys,\nand if a capability's value is the same as a previously-loaded\nkey definition,\nthe later definition is the one used.\n.SH NOTES\nNote that\n\\fBecho\\fP,\n\\fBnoecho\\fP,\n\\fBhalfdelay\\fP,\n\\fBintrflush\\fP,\n\\fBmeta\\fP,\n\\fBnl\\fP,\n\\fBnonl\\fP,\n\\fBnodelay\\fP,\n\\fBnotimeout\\fP,\n\\fBnoqiflush\\fP,\n\\fBqiflush\\fP,\n\\fBtimeout\\fP, and\n\\fBwtimeout\\fP may be macros.\n.PP\nThe \\fBnoraw\\fP and \\fBnocbreak\\fP calls follow historical practice in that\nthey attempt to restore to normal (\\*(``cooked\\*('') mode\nfrom raw and cbreak modes respectively.\nMixing raw/noraw and cbreak/nocbreak calls leads to tty driver\ncontrol states that are hard to predict or understand; it is not recommended.\n.SH SEE ALSO\n\\fBcurses\\fP(3X),\n\\fBcurs_getch\\fP(3X),\n\\fBcurs_initscr\\fP(3X),\n\\fBcurs_util\\fP(3X),\n\\fBdefine_key\\fP(3X),\n\\fBtermios\\fP(3)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}