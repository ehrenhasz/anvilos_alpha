{
  "module_name": "curs_initscr.3x",
  "hash_id": "166542fdf3115b96c47bb941cc6d62d041f25970e503f2f751d703214065f81d",
  "original_prompt": "Ingested from ncurses-6.4/man/curs_initscr.3x",
  "human_readable_source": ".\\\"***************************************************************************\n.\\\" Copyright 2018-2021,2022 Thomas E. Dickey                                *\n.\\\" Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *\n.\\\"                                                                          *\n.\\\" Permission is hereby granted, free of charge, to any person obtaining a  *\n.\\\" copy of this software and associated documentation files (the            *\n.\\\" \"Software\"), to deal in the Software without restriction, including      *\n.\\\" without limitation the rights to use, copy, modify, merge, publish,      *\n.\\\" distribute, distribute with modifications, sublicense, and/or sell       *\n.\\\" copies of the Software, and to permit persons to whom the Software is    *\n.\\\" furnished to do so, subject to the following conditions:                 *\n.\\\"                                                                          *\n.\\\" The above copyright notice and this permission notice shall be included  *\n.\\\" in all copies or substantial portions of the Software.                   *\n.\\\"                                                                          *\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n.\\\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n.\\\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n.\\\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n.\\\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n.\\\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n.\\\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n.\\\"                                                                          *\n.\\\" Except as contained in this notice, the name(s) of the above copyright   *\n.\\\" holders shall not be used in advertising or otherwise to promote the     *\n.\\\" sale, use or other dealings in this Software without prior written       *\n.\\\" authorization.                                                           *\n.\\\"***************************************************************************\n.\\\"\n.\\\" $Id: curs_initscr.3x,v 1.39 2022/07/24 15:46:49 tom Exp $\n.TH curs_initscr 3X \"\"\n.de bP\n.ie n  .IP \\(bu 4\n.el    .IP \\(bu 2\n..\n.ie \\n(.g .ds `` \\(lq\n.el       .ds `` ``\n.ie \\n(.g .ds '' \\(rq\n.el       .ds '' ''\n.na\n.hy 0\n.SH NAME\n\\fBinitscr\\fP,\n\\fBnewterm\\fP,\n\\fBendwin\\fP,\n\\fBisendwin\\fP,\n\\fBset_term\\fP,\n\\fBdelscreen\\fP \\- \\fBcurses\\fP screen initialization and manipulation routines\n.ad\n.hy\n.SH SYNOPSIS\n\\fB#include <curses.h>\\fP\n.sp\n\\fBWINDOW *initscr(void);\\fP\n.br\n\\fBint endwin(void);\\fP\n.sp\n\\fBbool isendwin(void);\\fP\n.sp\n\\fBSCREEN *newterm(const char *\\fItype\\fB, FILE *\\fIoutfd\\fB, FILE *\\fIinfd\\fB);\\fR\n.br\n\\fBSCREEN *set_term(SCREEN *\\fInew\\fB);\\fR\n.br\n\\fBvoid delscreen(SCREEN* \\fIsp\\fB);\\fR\n.br\n.SH DESCRIPTION\n.SS initscr\n\\fBinitscr\\fP is normally the first \\fBcurses\\fP routine to call when\ninitializing a program.\nA few special routines sometimes need to be called before it;\nthese are \\fBslk_init\\fP(3X), \\fBfilter\\fP, \\fBripoffline\\fP,\n\\fBuse_env\\fP.\nFor multiple-terminal applications,\n\\fBnewterm\\fP may be called before \\fBinitscr\\fP.\n.PP\nThe initscr code determines the terminal type and initializes all \\fBcurses\\fP\ndata structures.\n\\fBinitscr\\fP also causes the first call to \\fBrefresh\\fP(3X)\nto clear the screen.\nIf errors occur, \\fBinitscr\\fP writes an appropriate error\nmessage to standard error and exits;\notherwise, a pointer is returned to \\fBstdscr\\fP.\n.SS newterm\n.PP\nA program that outputs to more than one terminal should use the \\fBnewterm\\fP\nroutine for each terminal instead of \\fBinitscr\\fP.\nA program that needs to inspect capabilities,\nso it can continue to run in a line-oriented mode if the\nterminal cannot support a screen-oriented program, would also use\n\\fBnewterm\\fP.\nThe routine \\fBnewterm\\fP should be called once for each terminal.\nIt returns a variable of type \\fBSCREEN *\\fP which should be saved\nas a reference to that terminal.\n\\fBnewterm\\fP's arguments are\n.bP\nthe \\fItype\\fP of the terminal to be used in place of \\fB$TERM\\fP,\n.bP\na file pointer for output to the terminal, and\n.bP\nanother file pointer for input from the terminal\n.PP\nIf the \\fItype\\fP parameter is \\fBNULL\\fP, \\fB$TERM\\fP will be used.\n.SS endwin\n.PP\nThe program must also call\n\\fBendwin\\fP for each terminal being used before exiting from \\fBcurses\\fP.\nIf \\fBnewterm\\fP is called more than once for the same terminal, the first\nterminal referred to must be the last one for which \\fBendwin\\fP is called.\n.PP\nA program should always call \\fBendwin\\fP before exiting or escaping from\n\\fBcurses\\fP mode temporarily.\nThis routine\n.bP\nresets colors to correspond with the default color pair 0,\n.bP\nmoves the cursor to the lower left-hand corner of the screen,\n.bP\nclears the remainder of the line so that it uses the default colors,\n.bP\nsets the cursor to normal visibility (see \\fBcurs_set\\fP(3X)),\n.bP\nstops cursor-addressing mode using the \\fIexit_ca_mode\\fP terminal capability,\n.bP\nrestores tty modes (see \\fBreset_shell_mode\\fP(3X)).\n.PP\nCalling \\fBrefresh\\fP(3X) or \\fBdoupdate\\fP(3X) after a\ntemporary escape causes the program to resume visual mode.\n.SS isendwin\n.PP\nThe \\fBisendwin\\fP routine returns \\fBTRUE\\fP if \\fBendwin\\fP has been\ncalled without any subsequent calls to \\fBwrefresh\\fP,\nand \\fBFALSE\\fP otherwise.\n.SS set_term\n.PP\nThe \\fBset_term\\fP routine is used to switch between different terminals.\nThe screen reference \\fInew\\fP becomes the new current terminal.\nThe previous terminal is returned by the routine.\nThis is the only routine which manipulates \\fBSCREEN\\fP pointers;\nall other routines affect only the current terminal.\n.SS delscreen\n.PP\nThe \\fBdelscreen\\fP routine frees storage associated with the\n\\fBSCREEN\\fP data structure.\nThe \\fBendwin\\fP routine does not do\nthis, so \\fBdelscreen\\fP should be called after \\fBendwin\\fP if a\nparticular \\fBSCREEN\\fP is no longer needed.\n.SH RETURN VALUE\n\\fBendwin\\fP returns the integer \\fBERR\\fP upon failure and \\fBOK\\fP\nupon successful completion.\n.PP\nRoutines that return pointers always return \\fBNULL\\fP on error.\n.PP\nX/Open defines no error conditions.\nIn this implementation\n.bP\n\\fBendwin\\fP returns an error if the terminal was not initialized.\n.bP\n\\fBnewterm\\fP\nreturns an error if it cannot allocate the data structures for the screen,\nor for the top-level windows within the screen,\ni.e.,\n\\fBcurscr\\fP, \\fBnewscr\\fP, or \\fBstdscr\\fP.\n.bP\n\\fBset_term\\fP\nreturns no error.\n.SH PORTABILITY\nThese functions were described in the XSI Curses standard, Issue 4.\nAs of 2015, the current document is X/Open Curses, Issue 7.\n.SS Differences\nX/Open specifies that portable applications must not\ncall \\fBinitscr\\fP more than once:\n.bP\nThe portable way to use \\fBinitscr\\fP is once only,\nusing \\fBrefresh\\fP (see curs_refresh(3X))\nto restore the screen after \\fBendwin\\fP.\n.bP\nThis implementation allows using \\fBinitscr\\fP after \\fBendwin\\fP.\n.PP\nOld versions of curses, e.g., BSD 4.4, would return a null pointer\nfrom \\fBinitscr\\fP when an error is detected, rather than exiting.\nIt is safe but redundant to check the return value of \\fBinitscr\\fP\nin XSI Curses.\n.PP\nCalling \\fBendwin\\fP does not dispose of the memory allocated in \\fBinitscr\\fP\nor \\fBnewterm\\fP.\nDeleting a \\fBSCREEN\\fP provides a way to do this:\n.bP\nX/Open Curses does not say what happens to \\fBWINDOW\\fPs when \\fBdelscreen\\fP\n\\*(``frees storage associated with the \\fBSCREEN\\fP\\*(''\nnor does the SVr4 documentation help,\nadding that it should be called after \\fBendwin\\fP if a \\fBSCREEN\\fP\nis no longer needed.\n.bP\nHowever, \\fBWINDOW\\fPs are implicitly associated with a \\fBSCREEN\\fP.\nso that it is reasonable to expect \\fBdelscreen\\fP to deal with these.\n.bP\nSVr4 curses deletes the standard \\fBWINDOW\\fP structures\n\\fBstdscr\\fP and \\fBcurscr\\fP as well as a work area \\fBnewscr\\fP.\nSVr4 curses ignores other windows.\n.bP\nSince version 4.0 (1996), ncurses has maintained a list of all windows\nfor each screen,\nusing that information to delete those windows when \\fBdelscreen\\fP is called.\n.bP\nNetBSD copied this feature of ncurses in 2001.\nPDCurses follows the SVr4 model,\ndeleting only the standard \\fBWINDOW\\fP structures.\n.SS Unset TERM Variable\n.PP\nIf the TERM variable is missing or empty, \\fBinitscr\\fP uses the\nvalue \\*(``unknown\\*('',\nwhich normally corresponds to a terminal entry with the \\fIgeneric\\fP\n(\\fIgn\\fP) capability.\nGeneric entries are detected by \\fBsetupterm\\fP\n(see curs_terminfo(3X)) and cannot be used for full-screen operation.\nOther implementations may handle a missing/empty TERM variable differently.\n.SS Signal Handlers\n.PP\nQuoting from X/Open Curses, section 3.1.1:\n.RS 5\n.hy 0\n.PP\n.I Curses implementations may provide for special handling of the\n.I \\fBSIGINT\\fP,\n.I \\fBSIGQUIT\\fP and\n.I \\fBSIGTSTP\\fP signals\n.I if their disposition is \\fBSIG_DFL\\fP at the time\n\\fBinitscr\\fI is called \\fR...\n.PP\n.I Any special handling for these signals may remain in effect for the\n.I life of the process or until the process changes the disposition of\n.I the signal.\n.PP\n.I None of the Curses functions are required to be safe\n.I with respect to signals \\fP...\n.RE\n.hy\n.PP\nThis implementation establishes signal handlers during initialization,\ne.g., \\fBinitscr\\fP or \\fBnewterm\\fP.\nApplications which must handle these signals should set up the corresponding\nhandlers \\fIafter\\fP initializing the library:\n.TP 5\n.B SIGINT\nThe handler \\fIattempts\\fP to cleanup the screen on exit.\nAlthough it \\fIusually\\fP works as expected, there are limitations:\n.RS 5\n.bP\nWalking the \\fBSCREEN\\fP list is unsafe, since all list management\nis done without any signal blocking.\n.bP\nOn systems which have \\fBREENTRANT\\fP turned on, \\fBset_term\\fP uses\nfunctions which could deadlock or misbehave in other ways.\n.bP\n\\fBendwin\\fP calls other functions, many of which use stdio or\nother library functions which are clearly unsafe.\n.RE\n.TP 5\n.B SIGTERM\nThis uses the same handler as \\fBSIGINT\\fP, with the same limitations.\nIt is not mentioned in X/Open Curses, but is more suitable for this\npurpose than \\fBSIGQUIT\\fP (which is used in debugging).\n.TP 5\n.B SIGTSTP\nThis handles the \\fIstop\\fP signal, used in job control.\nWhen resuming the process, this implementation discards pending\ninput with \\fBflushinput\\fP (see curs_util(3X)), and repaints the screen\nassuming that it has been completely altered.\nIt also updates the saved terminal modes with \\fBdef_shell_mode\\fP\n(see \\fBcurs_kernel\\fP(3X)).\n.TP 5\n.B SIGWINCH\nThis handles the window-size changes which were ignored in\nthe standardization efforts.\nThe handler sets a (signal-safe) variable\nwhich is later tested in \\fBwgetch\\fP (see curs_getch(3X)).\nIf \\fBkeypad\\fP has been enabled for the corresponding window,\n\\fBwgetch\\fP returns the key symbol \\fBKEY_RESIZE\\fP.\nAt the same time, \\fBwgetch\\fP calls \\fBresizeterm\\fP to adjust the\nstandard screen \\fBstdscr\\fP,\nand update other data such as \\fBLINES\\fP and \\fBCOLS\\fP.\n.SH SEE ALSO\n\\fBcurses\\fP(3X),\n\\fBcurs_kernel\\fP(3X),\n\\fBcurs_refresh\\fP(3X),\n\\fBcurs_slk\\fP(3X),\n\\fBcurs_terminfo\\fP(3X),\n\\fBcurs_util\\fP(3X),\n\\fBcurs_variables\\fP(3X).\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}