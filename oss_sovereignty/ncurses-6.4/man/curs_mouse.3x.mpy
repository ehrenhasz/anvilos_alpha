{
  "module_name": "curs_mouse.3x",
  "hash_id": "1a4bb3e0625829733c95c6e296a1f60191b3ac01273f768a4e400e3e6a44d716",
  "original_prompt": "Ingested from ncurses-6.4/man/curs_mouse.3x",
  "human_readable_source": "'\\\" t\n.\\\"***************************************************************************\n.\\\" Copyright 2018-2022,2022 Thomas E. Dickey                                *\n.\\\" Copyright 1998-2015,2017 Free Software Foundation, Inc.                  *\n.\\\"                                                                          *\n.\\\" Permission is hereby granted, free of charge, to any person obtaining a  *\n.\\\" copy of this software and associated documentation files (the            *\n.\\\" \"Software\"), to deal in the Software without restriction, including      *\n.\\\" without limitation the rights to use, copy, modify, merge, publish,      *\n.\\\" distribute, distribute with modifications, sublicense, and/or sell       *\n.\\\" copies of the Software, and to permit persons to whom the Software is    *\n.\\\" furnished to do so, subject to the following conditions:                 *\n.\\\"                                                                          *\n.\\\" The above copyright notice and this permission notice shall be included  *\n.\\\" in all copies or substantial portions of the Software.                   *\n.\\\"                                                                          *\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n.\\\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n.\\\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n.\\\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n.\\\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n.\\\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n.\\\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n.\\\"                                                                          *\n.\\\" Except as contained in this notice, the name(s) of the above copyright   *\n.\\\" holders shall not be used in advertising or otherwise to promote the     *\n.\\\" sale, use or other dealings in this Software without prior written       *\n.\\\" authorization.                                                           *\n.\\\"***************************************************************************\n.\\\"\n.\\\" $Id: curs_mouse.3x,v 1.59 2022/02/12 20:05:11 tom Exp $\n.ie \\n(.g .ds `` \\(lq\n.el       .ds `` ``\n.ie \\n(.g .ds '' \\(rq\n.el       .ds '' ''\n.de NS\n.ie n  .sp\n.el    .sp .5\n.ie n  .in +4\n.el    .in +2\n.nf\n.ft C\t\t\t\\\" Courier\n..\n.de NE\n.fi\n.ft R\n.ie n  .in -4\n.el    .in -2\n..\n.de bP\n.ie n  .IP \\(bu 4\n.el    .IP \\(bu 2\n..\n.TH curs_mouse 3X \"\"\n.na\n.hy 0\n.SH NAME\n\\fBhas_mouse\\fP,\n\\fBgetmouse\\fP, \\fBungetmouse\\fP,\n\\fBmousemask\\fP, \\fBwenclose\\fP,\n\\fBmouse_trafo\\fP, \\fBwmouse_trafo\\fP,\n\\fBmouseinterval\\fP \\- mouse interface through curses\n.ad\n.hy\n.SH SYNOPSIS\n\\fB#include <curses.h>\\fP\n.PP\n\\fBtypedef unsigned long mmask_t;\\fP\n.PP\n.nf\n\\fBtypedef struct {\\fP\n\\fB    short id;         \\fI/* ID to distinguish multiple devices */\\fR\n\\fB    int x, y, z;      \\fI/* event coordinates */\\fR\n\\fB    mmask_t bstate;   \\fI/* button state bits */\\fR\n\\fB} MEVENT;\\fP\n.fi\n.PP\n\\fBbool has_mouse(void);\\fP\n.sp\n\\fBint getmouse(MEVENT *\\fIevent\\fB);\\fR\n.br\n\\fBint ungetmouse(MEVENT *\\fIevent\\fB);\\fR\n.sp\n\\fBmmask_t mousemask(mmask_t \\fInewmask\\fB, mmask_t *\\fIoldmask\\fB);\\fR\n.sp\n\\fBbool wenclose(const WINDOW *\\fIwin\\fB, int \\fIy\\fB, int \\fIx\\fB);\\fR\n.sp\n\\fBbool mouse_trafo(int* \\fIpY\\fB, int* \\fIpX\\fB, bool \\fIto_screen\\fB);\\fR\n.br\n\\fBbool wmouse_trafo(const WINDOW* \\fIwin\\fB,\\fR\n                  \\fBint* \\fIpY\\fB, int* \\fIpX\\fB, bool \\fIto_screen\\fB);\\fR\n.sp\n\\fBint mouseinterval(int \\fIerval\\fB);\\fR\n.br\n.SH DESCRIPTION\nThese functions provide an interface to mouse events from\n\\fBncurses\\fP(3X).\nMouse events are represented by \\fBKEY_MOUSE\\fP\npseudo-key values in the \\fBwgetch\\fP(3X) input stream.\n.SS mousemask\n.PP\nTo make mouse events visible, use the \\fBmousemask\\fP function.\nThis sets the mouse events to be reported.\nBy default, no mouse events are reported.\n.bP\nThe function returns an updated copy of \\fInewmask\\fP\nto indicate which of the specified mouse events can be reported.\n.IP\nIf the screen has not been initialized,\nor if the terminal does not support mouse-events,\nthis function returns 0.\n.bP\nIf \\fIoldmask\\fP is non-NULL,\nthis function fills the indicated location with the previous value of the\ncurrent screen's mouse event mask.\n.PP\nAs a side effect, setting a zero mousemask may turn off the mouse pointer;\nsetting a nonzero mask may turn it on.\nWhether this happens is device-dependent.\n.SS Mouse events\n.PP\nHere are the mouse event type masks which may be defined:\n.PP\n.TS\nl l\n_ _\nl l.\n\\fBName\\fP\t\\fBDescription\\fP\nBUTTON1_PRESSED\tmouse button 1 down\nBUTTON1_RELEASED\tmouse button 1 up\nBUTTON1_CLICKED\tmouse button 1 clicked\nBUTTON1_DOUBLE_CLICKED\tmouse button 1 double clicked\nBUTTON1_TRIPLE_CLICKED\tmouse button 1 triple clicked\n_\nBUTTON2_PRESSED\tmouse button 2 down\nBUTTON2_RELEASED\tmouse button 2 up\nBUTTON2_CLICKED\tmouse button 2 clicked\nBUTTON2_DOUBLE_CLICKED\tmouse button 2 double clicked\nBUTTON2_TRIPLE_CLICKED\tmouse button 2 triple clicked\n_\nBUTTON3_PRESSED\tmouse button 3 down\nBUTTON3_RELEASED\tmouse button 3 up\nBUTTON3_CLICKED\tmouse button 3 clicked\nBUTTON3_DOUBLE_CLICKED\tmouse button 3 double clicked\nBUTTON3_TRIPLE_CLICKED\tmouse button 3 triple clicked\n_\nBUTTON4_PRESSED\tmouse button 4 down\nBUTTON4_RELEASED\tmouse button 4 up\nBUTTON4_CLICKED\tmouse button 4 clicked\nBUTTON4_DOUBLE_CLICKED\tmouse button 4 double clicked\nBUTTON4_TRIPLE_CLICKED\tmouse button 4 triple clicked\n_\nBUTTON5_PRESSED\tmouse button 5 down\nBUTTON5_RELEASED\tmouse button 5 up\nBUTTON5_CLICKED\tmouse button 5 clicked\nBUTTON5_DOUBLE_CLICKED\tmouse button 5 double clicked\nBUTTON5_TRIPLE_CLICKED\tmouse button 5 triple clicked\n_\nBUTTON_SHIFT\tshift was down during button state change\nBUTTON_CTRL\tcontrol was down during button state change\nBUTTON_ALT\talt was down during button state change\nALL_MOUSE_EVENTS\treport all button state changes\nREPORT_MOUSE_POSITION\treport mouse movement\n_\n.TE\n.SS getmouse\n.PP\nOnce a class of mouse events has been made visible in a window,\ncalling the \\fBwgetch\\fP function on that window may return\n\\fBKEY_MOUSE\\fP as an indicator that a mouse event has been queued.\nTo read the event data and pop the event off the queue, call\n\\fBgetmouse\\fP.\nThis function will return \\fBOK\\fP if a mouse event\nis actually visible in the given window, \\fBERR\\fP otherwise.\nWhen \\fBgetmouse\\fP returns \\fBOK\\fP, the data deposited as y and\nx in the event structure coordinates will be screen-relative character-cell\ncoordinates.\nThe returned state mask will have exactly one bit set to\nindicate the event type.\nThe corresponding data in the queue is marked invalid.\nA subsequent call to \\fBgetmouse\\fP will retrieve the next older\nitem from the queue.\n.SS ungetmouse\n.PP\nThe \\fBungetmouse\\fP function behaves analogously to \\fBungetch\\fP.\nIt pushes\na \\fBKEY_MOUSE\\fP event onto the input queue, and associates with that event\nthe given state data and screen-relative character-cell coordinates.\n.SS wenclose\n.PP\nThe \\fBwenclose\\fP function tests whether a given pair of screen-relative\ncharacter-cell coordinates is enclosed by a given window, returning \\fBTRUE\\fP\nif it is and \\fBFALSE\\fP otherwise.\nIt is useful for determining what subset of\nthe screen windows enclose the location of a mouse event.\n.SS wmouse_trafo\n.PP\nThe \\fBwmouse_trafo\\fP function transforms a given pair of coordinates\nfrom stdscr-relative coordinates\nto coordinates relative to the given window or vice versa.\nThe resulting stdscr-relative coordinates are not always identical\nto window-relative coordinates due to the mechanism to reserve lines on top\nor bottom of the screen for other purposes\n(see the \\fBripoffline\\fP and \\fBslk_init\\fP(3X) calls, for example).\n.bP\nIf the parameter \\fIto_screen\\fP is \\fBTRUE\\fP, the pointers\n\\fIpY, pX\\fP must reference the coordinates of a location\ninside the window \\fIwin\\fP.\nThey are converted to window-relative coordinates and returned\nthrough the pointers.\nIf the conversion was successful, the function returns \\fBTRUE\\fP.\n.bP\nIf one of the parameters was NULL or the location is\nnot inside the window, \\fBFALSE\\fP is returned.\n.bP\nIf \\fIto_screen\\fP is\n\\fBFALSE\\fP, the pointers \\fIpY, pX\\fP must reference window-relative\ncoordinates.\nThey are converted to stdscr-relative coordinates if the\nwindow \\fIwin\\fP encloses this point.\nIn this case the function returns \\fBTRUE\\fP.\n.bP\nIf one of the parameters is NULL or the point is not inside the\nwindow, \\fBFALSE\\fP is returned.\nThe referenced coordinates\nare only replaced by the converted coordinates if the transformation was\nsuccessful.\n.SS mouse_trafo\n.PP\nThe \\fBmouse_trafo\\fP function performs the same translation\nas \\fBwmouse_trafo\\fP,\nusing stdscr for \\fIwin\\fP.\n.SS mouseinterval\n.PP\nThe \\fBmouseinterval\\fP function sets the maximum time (in thousands of a\nsecond) that can elapse between press and release events for them to\nbe recognized as a click.\nUse \\fBmouseinterval(0)\\fP to disable click resolution.\nThis function returns the previous interval value.\nUse \\fBmouseinterval(\\-1)\\fP to obtain the interval without altering it.\nThe default is one sixth of a second.\n.SS has_mouse\n.PP\nThe \\fBhas_mouse\\fP function returns \\fBTRUE\\fP if the mouse driver has been\nsuccessfully initialized.\n.PP\nNote that mouse events will be ignored when input is in cooked mode, and will\ncause an error beep when cooked mode is being simulated in a window by a\nfunction such as \\fBgetstr\\fP that expects a linefeed for input-loop\ntermination.\n.SH RETURN VALUE\n\\fBgetmouse\\fP and \\fBungetmouse\\fP\nreturn the integer \\fBERR\\fP upon failure or \\fBOK\\fP\nupon successful completion:\n.RS 3\n.TP 5\n\\fBgetmouse\\fP\nreturns an error.\n.bP\nIf no mouse driver was initialized, or\nif the mask parameter is zero,\n.bP\nIt returns an error if a mouse event was detected which did not match the\ncurrent \\fImousemask\\fP.\n.bP\nIt also returns an error if no more events remain in the queue.\n.TP 5\n\\fBungetmouse\\fP\nreturns an error if the FIFO is full.\n.RE\n.PP\n\\fBmousemask\\fP\nreturns the mask of reportable events.\n.PP\n\\fBmouseinterval\\fP\nreturns the previous interval value, unless\nthe terminal was not initialized.\nIn that case, it returns the maximum interval value (166).\n.PP\n\\fBwenclose\\fP and \\fBwmouse_trafo\\fP\nare boolean functions returning \\fBTRUE\\fP or \\fBFALSE\\fP depending\non their test result.\n.SH PORTABILITY\nThese calls were designed for \\fBncurses\\fP(3X), and are not found in SVr4\ncurses, 4.4BSD curses, or any other previous version of curses.\n.PP\nSVr4 curses had support for the mouse in a variant of \\fBxterm\\fP(1).\nIt is mentioned in a few places, but with no supporting documentation:\n.bP\nthe \\*(``libcurses\\*('' manual page lists functions for this feature\nwhich are prototyped in \\fBcurses.h\\fP:\n.NS\nextern int mouse_set(long int);\nextern int mouse_on(long int);\nextern int mouse_off(long int);\nextern int request_mouse_pos(void);\nextern int map_button(unsigned long);\nextern void wmouse_position(WINDOW *, int *, int *);\nextern unsigned long getmouse(void), getbmap(void);\n.NE\n.bP\nthe \\*(``terminfo\\*('' manual page lists capabilities for the feature\n.NS\nbuttons           btns    BT       Number of buttons on the mouse\nget_mouse         getm    Gm       Curses should get button events\nkey_mouse         kmous   Km       0631, Mouse event has occurred\nmouse_info        minfo   Mi       Mouse status information\nreq_mouse_pos     reqmp   RQ       Request mouse position report\n.NE\n.bP\nthe interface made assumptions (as does ncurses) about the escape sequences\nsent to and received from the terminal.\n.IP\nFor instance\nthe SVr4 curses library used the \\fBget_mouse\\fP capability to tell the\nterminal which mouse button events it should send,\npassing the mouse-button bit-mask to the terminal.\nAlso, it could ask the terminal\nwhere the mouse was using the \\fBreq_mouse_pos\\fP capability.\n.IP\nThose features required a terminal which had been modified to work with curses.\nThey were not part of the X Consortium's xterm.\n.PP\nWhen developing the xterm mouse support for ncurses in September 1995,\nEric Raymond was uninterested in using the same interface due to its\nlack of documentation.\nLater, in 1998, Mark Hesseling provided support in\nPDCurses 2.3 using the SVr4 interface.\nPDCurses, however, does not use video terminals,\nmaking it unnecessary to be concerned about compatibility with the\nescape sequences.\n.PP\nThe feature macro \\fBNCURSES_MOUSE_VERSION\\fP is provided so the preprocessor\ncan be used to test whether these features are present.\nIf the interface is changed, the value of \\fBNCURSES_MOUSE_VERSION\\fP will be\nincremented.\nThese values for \\fBNCURSES_MOUSE_VERSION\\fP may be\nspecified when configuring ncurses:\n.RS 3\n.TP 3\n1\nhas definitions for reserved events.\nThe mask uses 28 bits.\n.TP 3\n2\nadds definitions for button 5,\nremoves the definitions for reserved events.\nThe mask uses 29 bits.\n.RE\n.PP\nThe order of the \\fBMEVENT\\fP structure members is not guaranteed.\nAdditional fields may be added to the structure in the future.\n.PP\nUnder \\fBncurses\\fP(3X), these calls are implemented using either\nxterm's built-in mouse-tracking API or\nplatform-specific drivers including\n.RS 3\n.bP\nAlessandro Rubini's gpm server\n.bP\nFreeBSD sysmouse\n.bP\nOS/2 EMX\n.RE\n.PP\nIf you are using an unsupported configuration,\nmouse events will not be visible to\n\\fBncurses\\fP(3X) (and the \\fBmousemask\\fP function will always\nreturn \\fB0\\fP).\n.PP\nIf the terminfo entry contains a \\fBXM\\fP string,\nthis is used in the xterm mouse driver to control the\nway the terminal is initialized for mouse operation.\nThe default, if \\fBXM\\fP is not found,\ncorresponds to private mode 1000 of xterm:\n.PP\n.RS 3\n\\\\E[?1000%?%p1%{1}%=%th%el%;\n.RE\n.PP\nThe mouse driver also recognizes a newer xterm private mode 1006, e.g.,\n.PP\n.RS 3\n\\\\E[?1006;1000%?%p1%{1}%=%th%el%;\n.RE\n.PP\nThe \\fIz\\fP member in the event structure is not presently used.\nIt is intended\nfor use with touch screens (which may be pressure-sensitive) or with\n3D-mice/trackballs/power gloves.\n.PP\nThe \\fBALL_MOUSE_EVENTS\\fP class does not include \\fBREPORT_MOUSE_POSITION\\fP.\nThey are distinct.\nFor example, in xterm,\nwheel/scrolling mice send position reports as a sequence of\npresses of buttons 4 or 5 without matching button-releases.\n.SH BUGS\nMouse events under xterm will not in fact be ignored during cooked mode,\nif they have been enabled by \\fBmousemask\\fP.\nInstead, the xterm mouse\nreport sequence will appear in the string read.\n.PP\nMouse events under xterm will not be detected correctly in a window with\nits keypad bit off, since they are interpreted as a variety of function key.\nYour terminfo description should have \\fBkmous\\fP set to \\*(``\\\\E[M\\*(''\n(the beginning of the response from xterm for mouse clicks).\nOther values for \\fBkmous\\fP are permitted,\nbut under the same assumption,\ni.e., it is the beginning of the response.\n.PP\nBecause there are no standard terminal responses that would serve to identify\nterminals which support the xterm mouse protocol, \\fBncurses\\fP assumes that\nif \\fBkmous\\fP is defined in the terminal description,\nor if the terminal description's primary name or aliases\ncontain the string \\*(``xterm\\*('',\nthen the terminal may send mouse events.\nThe \\fBkmous\\fP capability is checked first,\nallowing the use of newer xterm mouse protocols\nsuch as xterm's private mode 1006.\n.SH SEE ALSO\n\\fBcurses\\fP(3X),\n\\fBcurs_inopts\\fP(3X),\n\\fBcurs_kernel\\fP(3X),\n\\fBcurs_slk\\fP(3X),\n\\fBcurs_variables\\fP(3X).\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}