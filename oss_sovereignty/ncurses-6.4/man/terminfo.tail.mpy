{
  "module_name": "terminfo.tail",
  "hash_id": "07bd575619a5c2999ef740d0efe3f5a597753244a05166fd21d7d5bf8252b038",
  "original_prompt": "Ingested from ncurses-6.4/man/terminfo.tail",
  "human_readable_source": ".\\\"***************************************************************************\n.\\\" Copyright 2018-2021,2022 Thomas E. Dickey                                *\n.\\\" Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *\n.\\\"                                                                          *\n.\\\" Permission is hereby granted, free of charge, to any person obtaining a  *\n.\\\" copy of this software and associated documentation files (the            *\n.\\\" \"Software\"), to deal in the Software without restriction, including      *\n.\\\" without limitation the rights to use, copy, modify, merge, publish,      *\n.\\\" distribute, distribute with modifications, sublicense, and/or sell       *\n.\\\" copies of the Software, and to permit persons to whom the Software is    *\n.\\\" furnished to do so, subject to the following conditions:                 *\n.\\\"                                                                          *\n.\\\" The above copyright notice and this permission notice shall be included  *\n.\\\" in all copies or substantial portions of the Software.                   *\n.\\\"                                                                          *\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n.\\\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n.\\\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n.\\\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n.\\\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n.\\\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n.\\\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n.\\\"                                                                          *\n.\\\" Except as contained in this notice, the name(s) of the above copyright   *\n.\\\" holders shall not be used in advertising or otherwise to promote the     *\n.\\\" sale, use or other dealings in this Software without prior written       *\n.\\\" authorization.                                                           *\n.\\\"***************************************************************************\n.\\\"\n.\\\" $Id: terminfo.tail,v 1.113 2022/12/10 19:51:10 tom Exp $\n.ps +1\n.SS User-Defined Capabilities\n.\nThe preceding section listed the \\fIpredefined\\fP capabilities.\nThey deal with some special features for terminals no longer\n(or possibly never) produced.\nOccasionally there are special features of newer terminals which\nare awkward or impossible to represent by reusing the predefined\ncapabilities.\n.PP\n\\fBncurses\\fP addresses this limitation by allowing user-defined capabilities.\nThe \\fB@TIC@\\fP and \\fB@INFOCMP@\\fP programs provide\nthe \\fB\\-x\\fP option for this purpose.\nWhen \\fB\\-x\\fP is set,\n\\fB@TIC@\\fP treats unknown capabilities as user-defined.\nThat is, if \\fB@TIC@\\fP encounters a capability name\nwhich it does not recognize,\nit infers its type (boolean, number or string) from the syntax\nand makes an extended table entry for that capability.\nThe \\fBuse_extended_names\\fP(3X) function makes this information\nconditionally available to applications.\nThe ncurses library provides the data leaving most of the behavior\nto applications:\n.bP\nUser-defined capability strings whose name begins\nwith \\*(``k\\*('' are treated as function keys.\n.bP\nThe types (boolean, number, string) determined by \\fB@TIC@\\fP\ncan be inferred by successful calls on \\fBtigetflag\\fP, etc.\n.bP\nIf the capability name happens to be two characters,\nthe capability is also available through the termcap interface.\n.PP\nWhile termcap is said to be extensible because it does not use a predefined set\nof capabilities,\nin practice it has been limited to the capabilities defined by\nterminfo implementations.\nAs a rule,\nuser-defined capabilities intended for use by termcap applications should\nbe limited to booleans and numbers to avoid running past the 1023 byte\nlimit assumed by termcap implementations and their applications.\nIn particular, providing extended sets of function keys (past the 60\nnumbered keys and the handful of special named keys) is best done using\nthe longer names available using terminfo.\n.\n.SS A Sample Entry\n.\nThe following entry, describing an ANSI-standard terminal, is representative\nof what a \\fBterminfo\\fP entry for a modern terminal typically looks like.\n.PP\n.nf\n.ft CW\n\\s-2ansi|ansi/pc-term compatible with color,\n        am, mc5i, mir, msgr,\n        colors#8, cols#80, it#8, lines#24, ncv#3, pairs#64,\n        acsc=+\\\\020\\\\,\\\\021-\\\\030.^Y0\\\\333`\\\\004a\\\\261f\\\\370g\\\\361h\\\\260\n             j\\\\331k\\\\277l\\\\332m\\\\300n\\\\305o~p\\\\304q\\\\304r\\\\304s_t\\\\303\n             u\\\\264v\\\\301w\\\\302x\\\\263y\\\\363z\\\\362{\\\\343|\\\\330}\\\\234~\\\\376,\n        bel=^G, blink=\\\\E[5m, bold=\\\\E[1m, cbt=\\\\E[Z, clear=\\\\E[H\\\\E[J,\n        cr=^M, cub=\\\\E[%p1%dD, cub1=\\\\E[D, cud=\\\\E[%p1%dB, cud1=\\\\E[B,\n        cuf=\\\\E[%p1%dC, cuf1=\\\\E[C, cup=\\\\E[%i%p1%d;%p2%dH,\n        cuu=\\\\E[%p1%dA, cuu1=\\\\E[A, dch=\\\\E[%p1%dP, dch1=\\\\E[P,\n        dl=\\\\E[%p1%dM, dl1=\\\\E[M, ech=\\\\E[%p1%dX, ed=\\\\E[J, el=\\\\E[K,\n        el1=\\\\E[1K, home=\\\\E[H, hpa=\\\\E[%i%p1%dG, ht=\\\\E[I, hts=\\\\EH,\n        ich=\\\\E[%p1%d@, il=\\\\E[%p1%dL, il1=\\\\E[L, ind=^J,\n        indn=\\\\E[%p1%dS, invis=\\\\E[8m, kbs=^H, kcbt=\\\\E[Z, kcub1=\\\\E[D,\n        kcud1=\\\\E[B, kcuf1=\\\\E[C, kcuu1=\\\\E[A, khome=\\\\E[H, kich1=\\\\E[L,\n        mc4=\\\\E[4i, mc5=\\\\E[5i, nel=\\\\r\\\\E[S, op=\\\\E[39;49m,\n        rep=%p1%c\\\\E[%p2%{1}%-%db, rev=\\\\E[7m, rin=\\\\E[%p1%dT,\n        rmacs=\\\\E[10m, rmpch=\\\\E[10m, rmso=\\\\E[m, rmul=\\\\E[m,\n        s0ds=\\\\E(B, s1ds=\\\\E)B, s2ds=\\\\E*B, s3ds=\\\\E+B,\n        setab=\\\\E[4%p1%dm, setaf=\\\\E[3%p1%dm,\n        sgr=\\\\E[0;10%?%p1%t;7%;\n                   %?%p2%t;4%;\n                   %?%p3%t;7%;\n                   %?%p4%t;5%;\n                   %?%p6%t;1%;\n                   %?%p7%t;8%;\n                   %?%p9%t;11%;m,\n        sgr0=\\\\E[0;10m, smacs=\\\\E[11m, smpch=\\\\E[11m, smso=\\\\E[7m,\n        smul=\\\\E[4m, tbc=\\\\E[3g, u6=\\\\E[%i%d;%dR, u7=\\\\E[6n,\n        u8=\\\\E[?%[;0123456789]c, u9=\\\\E[c, vpa=\\\\E[%i%p1%dd,\n.fi\n.ft R\n.PP\nEntries may continue onto multiple lines by placing white space at\nthe beginning of each line except the first.\nComments may be included on lines beginning with \\*(``#\\*(''.\nCapabilities in\n.I terminfo\nare of three types:\n.bP\nBoolean capabilities which indicate that the terminal has\nsome particular feature,\n.bP\nnumeric capabilities giving the size of the terminal\nor the size of particular delays, and\n.bP\nstring\ncapabilities, which give a sequence which can be used to perform particular\nterminal operations.\n.PP\n.SS Types of Capabilities\n.PP\nAll capabilities have names.\nFor instance, the fact that\nANSI-standard terminals have\n.I \"automatic margins\"\n(i.e., an automatic return and line-feed\nwhen the end of a line is reached) is indicated by the capability \\fBam\\fP.\nHence the description of ansi includes \\fBam\\fP.\nNumeric capabilities are followed by the character \\*(``#\\*('' and then a positive value.\nThus \\fBcols\\fP, which indicates the number of columns the terminal has,\ngives the value \\*(``80\\*('' for ansi.\nValues for numeric capabilities may be specified in decimal, octal or hexadecimal,\nusing the C programming language conventions (e.g., 255, 0377 and 0xff or 0xFF).\n.PP\nFinally, string valued capabilities, such as \\fBel\\fP (clear to end of line\nsequence) are given by the two-character code, an \\*(``=\\*('', and then a string\nending at the next following \\*(``,\\*(''.\n.PP\nA number of escape sequences are provided in the string valued capabilities\nfor easy encoding of characters there:\n.bP\nBoth \\fB\\eE\\fP and \\fB\\ee\\fP\nmap to an \\s-1ESCAPE\\s0 character,\n.bP\n\\fB^x\\fP maps to a control-x for any appropriate \\fIx\\fP, and\n.bP\nthe sequences\n.RS 6\n.PP\n\\fB\\en\\fP, \\fB\\el\\fP, \\fB\\er\\fP, \\fB\\et\\fP, \\fB\\eb\\fP, \\fB\\ef\\fP, and \\fB\\es\\fP\n.RE\n.IP\nproduce\n.RS 6\n.PP\n\\fInewline\\fP, \\fIline-feed\\fP, \\fIreturn\\fP, \\fItab\\fP, \\fIbackspace\\fP, \\fIform-feed\\fP, and \\fIspace\\fP,\n.RE\n.IP\nrespectively.\n.PP\nX/Open Curses does not say what \\*(``appropriate \\fIx\\fP\\*('' might be.\nIn practice, that is a printable ASCII graphic character.\nThe special case \\*(``^?\\*('' is interpreted as DEL (127).\nIn all other cases, the character value is AND'd with 0x1f,\nmapping to ASCII control codes in the range 0 through 31.\n.PP\nOther escapes include\n.bP\n\\fB\\e^\\fP for \\fB^\\fP,\n.bP\n\\fB\\e\\e\\fP for \\fB\\e\\fP,\n.bP\n\\fB\\e\\fP, for comma,\n.bP\n\\fB\\e:\\fP for \\fB:\\fP,\n.bP\nand \\fB\\e0\\fP for null.\n.IP\n\\fB\\e0\\fP will produce \\e200, which does not terminate a string but behaves\nas a null character on most terminals, providing CS7 is specified.\nSee \\fBstty\\fP(1).\n.IP\nThe reason for this quirk is to maintain binary compatibility of the\ncompiled terminfo files with other implementations,\ne.g., the SVr4 systems, which document this.\nCompiled terminfo files use null-terminated strings, with no lengths.\nModifying this would require a new binary format,\nwhich would not work with other implementations.\n.PP\nFinally, characters may be given as three octal digits after a \\fB\\e\\fP.\n.PP\nA delay in milliseconds may appear anywhere in a string capability, enclosed in\n$<..> brackets, as in \\fBel\\fP=\\eEK$<5>,\nand padding characters are supplied by \\fBtputs\\fP(3X)\nto provide this delay.\n.bP\nThe delay must be a number with at most one decimal\nplace of precision; it may be followed by suffixes \\*(``*\\*('' or \\*(``/\\*('' or both.\n.bP\nA \\*(``*\\*(''\nindicates that the padding required is proportional to the number of lines\naffected by the operation, and the amount given is the per-affected-unit\npadding required.\n(In the case of insert character, the factor is still the\nnumber of \\fIlines\\fP affected.)\n.IP\nNormally, padding is advisory if the device has the \\fBxon\\fP\ncapability; it is used for cost computation but does not trigger delays.\n.bP\nA \\*(``/\\*(''\nsuffix indicates that the padding is mandatory and forces a delay of the given\nnumber of milliseconds even on devices for which \\fBxon\\fP is present to\nindicate flow control.\n.PP\nSometimes individual capabilities must be commented out.\nTo do this, put a period before the capability name.\nFor example, see the second\n.B ind\nin the example above.\n.br\n.ne 5\n.PP\n.SS Fetching Compiled Descriptions\n.PP\nThe \\fBncurses\\fP library searches for terminal descriptions in several places.\nIt uses only the first description found.\nThe library has a compiled-in list of places to search\nwhich can be overridden by environment variables.\nBefore starting to search,\n\\fBncurses\\fP eliminates duplicates in its search list.\n.bP\nIf the environment variable TERMINFO is set, it is interpreted as the pathname\nof a directory containing the compiled description you are working on.\nOnly that directory is searched.\n.bP\nIf TERMINFO is not set,\n\\fBncurses\\fP will instead look in the directory \\fB$HOME/.terminfo\\fP\nfor a compiled description.\n.bP\nNext, if the environment variable TERMINFO_DIRS is set,\n\\fBncurses\\fP will interpret the contents of that variable\nas a list of colon-separated directories (or database files) to be searched.\n.IP\nAn empty directory name (i.e., if the variable begins or ends\nwith a colon, or contains adjacent colons)\nis interpreted as the system location \\fI\\*d\\fP.\n.bP\nFinally, \\fBncurses\\fP searches these compiled-in locations:\n.RS\n.bP\na list of directories (@TERMINFO_DIRS@), and\n.bP\nthe system terminfo directory, \\fI\\*d\\fP (the compiled-in default).\n.RE\n.SS Preparing Descriptions\n.PP\nWe now outline how to prepare descriptions of terminals.\nThe most effective way to prepare a terminal description is by imitating\nthe description of a similar terminal in\n.I terminfo\nand to build up a description gradually, using partial descriptions\nwith\n.I vi\nor some other screen-oriented program to check that they are correct.\nBe aware that a very unusual terminal may expose deficiencies in\nthe ability of the\n.I terminfo\nfile to describe it\nor bugs in the screen-handling code of the test program.\n.PP\nTo get the padding for insert line right (if the terminal manufacturer\ndid not document it) a severe test is to edit a large file at 9600 baud,\ndelete 16 or so lines from the middle of the screen, then hit the \\*(``u\\*(''\nkey several times quickly.\nIf the terminal messes up, more padding is usually needed.\nA similar test can be used for insert character.\n.PP\n.SS Basic Capabilities\n.PP\nThe number of columns on each line for the terminal is given by the\n\\fBcols\\fP numeric capability.\nIf the terminal is a \\s-1CRT\\s0, then the\nnumber of lines on the screen is given by the \\fBlines\\fP capability.\nIf the terminal wraps around to the beginning of the next line when\nit reaches the right margin, then it should have the \\fBam\\fP capability.\nIf the terminal can clear its screen, leaving the cursor in the home\nposition, then this is given by the \\fBclear\\fP string capability.\nIf the terminal overstrikes\n(rather than clearing a position when a character is struck over)\nthen it should have the \\fBos\\fP capability.\nIf the terminal is a printing terminal, with no soft copy unit,\ngive it both\n.B hc\nand\n.BR os .\n.RB ( os\napplies to storage scope terminals, such as \\s-1TEKTRONIX\\s+1 4010\nseries, as well as hard copy and APL terminals.)\nIf there is a code to move the cursor to the left edge of the current\nrow, give this as\n.BR cr .\n(Normally this will be carriage return, control/M.)\nIf there is a code to produce an audible signal (bell, beep, etc)\ngive this as\n.BR bel .\n.PP\nIf there is a code to move the cursor one position to the left\n(such as backspace) that capability should be given as\n.BR cub1 .\nSimilarly, codes to move to the right, up, and down should be\ngiven as\n.BR cuf1 ,\n.BR cuu1 ,\nand\n.BR cud1 .\nThese local cursor motions should not alter the text they pass over,\nfor example, you would not normally use \\*(``\\fBcuf1\\fP=\\ \\*('' because the\nspace would erase the character moved over.\n.PP\nA very important point here is that the local cursor motions encoded\nin\n.I terminfo\nare undefined at the left and top edges of a \\s-1CRT\\s0 terminal.\nPrograms should never attempt to backspace around the left edge,\nunless\n.B bw\nis given,\nand never attempt to go up locally off the top.\nIn order to scroll text up, a program will go to the bottom left corner\nof the screen and send the\n.B ind\n(index) string.\n.PP\nTo scroll text down, a program goes to the top left corner\nof the screen and sends the\n.B ri\n(reverse index) string.\nThe strings\n.B ind\nand\n.B ri\nare undefined when not on their respective corners of the screen.\n.PP\nParameterized versions of the scrolling sequences are\n.B indn\nand\n.B rin\nwhich have the same semantics as\n.B ind\nand\n.B ri\nexcept that they take one parameter, and scroll that many lines.\nThey are also undefined except at the appropriate edge of the screen.\n.PP\nThe \\fBam\\fP capability tells whether the cursor sticks at the right\nedge of the screen when text is output, but this does not necessarily\napply to a\n.B cuf1\nfrom the last column.\nThe only local motion which is defined from the left edge is if\n.B bw\nis given, then a\n.B cub1\nfrom the left edge will move to the right edge of the previous row.\nIf\n.B bw\nis not given, the effect is undefined.\nThis is useful for drawing a box around the edge of the screen, for example.\nIf the terminal has switch selectable automatic margins,\nthe\n.I terminfo\nfile usually assumes that this is on; i.e., \\fBam\\fP.\nIf the terminal has a command which moves to the first column of the next\nline, that command can be given as\n.B nel\n(newline).\nIt does not matter if the command clears the remainder of the current line,\nso if the terminal has no\n.B cr\nand\n.B lf\nit may still be possible to craft a working\n.B nel\nout of one or both of them.\n.PP\nThese capabilities suffice to describe hard-copy and \\*(``glass-tty\\*('' terminals.\nThus the model 33 teletype is described as\n.PP\n.DT\n.nf\n.ft CW\n.\\\".in -2\n\\s-133\\||\\|tty33\\||\\|tty\\||\\|model 33 teletype,\n        bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,\\s+1\n.\\\".in +2\n.ft R\n.fi\n.PP\nwhile the Lear Siegler \\s-1ADM-3\\s0 is described as\n.PP\n.DT\n.nf\n.ft CW\n.\\\".in -2\n\\s-1adm3\\||\\|3\\||\\|lsi adm3,\n        am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,\n        ind=^J, lines#24,\\s+1\n.\\\".in +2\n.ft R\n.fi\n.PP\n.SS Parameterized Strings\n.PP\nCursor addressing and other strings requiring parameters\nin the terminal are described by a\nparameterized string capability,\nwith \\fIprintf\\fP-like escapes such as \\fI%x\\fP in it.\nFor example, to address the cursor, the\n.B cup\ncapability is given, using two parameters:\nthe row and column to address to.\n(Rows and columns are numbered from zero and refer to the\nphysical screen visible to the user, not to any unseen memory.)\nIf the terminal has memory relative cursor addressing,\nthat can be indicated by\n.BR mrcup .\n.PP\nThe parameter mechanism uses a stack and special \\fB%\\fP codes\nto manipulate it.\nTypically a sequence will push one of the\nparameters onto the stack and then print it in some format.\nPrint (e.g., \\*(``%d\\*('') is a special case.\nOther operations, including \\*(``%t\\*('' pop their operand from the stack.\nIt is noted that more complex operations are often necessary,\ne.g., in the \\fBsgr\\fP string.\n.PP\nThe \\fB%\\fP encodings have the following meanings:\n.PP\n.TP 5\n\\fB%%\\fP\noutputs \\*(``%\\*(''\n.TP\n\\fB%\\fP\\fI[[\\fP:\\fI]flags][width[.precision]][\\fP\\fBdoxXs\\fP\\fI]\\fP\nas in \\fBprintf\\fP(3), flags are \\fI[\\-+#]\\fP and \\fIspace\\fP.\nUse a \\*(``:\\*('' to allow the next character to be a \\*(``\\-\\*('' flag,\navoiding interpreting \\*(``%\\-\\*('' as an operator.\n.TP\n\\f(CW%c\\fP\nprint \\fIpop()\\fP like %c in \\fBprintf\\fP\n.TP\n\\fB%s\\fP\nprint \\fIpop()\\fP like %s in \\fBprintf\\fP\n.TP\n\\fB%p\\fP\\fI[1\\-9]\\fP\npush \\fIi\\fP'th parameter\n.TP\n\\fB%P\\fP\\fI[a\\-z]\\fP\nset dynamic variable \\fI[a\\-z]\\fP to \\fIpop()\\fP\n.TP\n\\fB%g\\fP\\fI[a\\-z]\\fP\nget dynamic variable \\fI[a\\-z]\\fP and push it\n.TP\n\\fB%P\\fP\\fI[A\\-Z]\\fP\nset static variable \\fI[a\\-z]\\fP to \\fIpop()\\fP\n.TP\n\\fB%g\\fP\\fI[A\\-Z]\\fP\nget static variable \\fI[a\\-z]\\fP and push it\n.IP\nThe terms \\*(``static\\*('' and \\*(``dynamic\\*('' are misleading.\nHistorically, these are simply two different sets of variables,\nwhose values are not reset between calls to \\fBtparm\\fP(3X).\nHowever, that fact is not documented in other implementations.\nRelying on it will adversely impact portability to other implementations:\n.RS\n.bP\nSVr2 curses supported \\fIdynamic\\fP variables.\nThose are set only by a \\fB%P\\fP operator.\nA \\fB%g\\fP for a given variable without first setting it with \\fB%P\\fP\nwill give unpredictable results, because dynamic variables are\nan uninitialized local array on the stack in the \\fBtparm\\fP function.\n.bP\nSVr3.2 curses supported \\fIstatic\\fP variables.\nThose are an array in the \\fBTERMINAL\\fP\nstructure (declared in \\fBterm.h\\fP),\nand are zeroed automatically when the \\fBsetupterm\\fP function\nallocates the data.\n.bP\nSVr4 curses made no further improvements\nto the \\fIdynamic/static\\fP variable feature.\n.bP\nSolaris XPG4 curses does not distinguish between \\fIdynamic\\fP and\n\\fIstatic\\fP variables.\nThey are the same.\nLike SVr4 curses, XPG4 curses does not initialize these explicitly.\n.bP\nBefore version 6.3, ncurses stores both \\fIdynamic\\fP and \\fIstatic\\fP\nvariables in persistent storage, initialized to zeros.\n.bP\nBeginning with version 6.3, ncurses stores \\fIstatic\\fP and \\fIdynamic\\fP\nvariables in the same manner as SVr4.\n.RS\n.bP\nUnlike other implementations, ncurses zeros dynamic variables \nbefore the first \\fB%g\\fP or \\fB%P\\fP operator.\n.bP\nLike SVr2,\nthe scope of dynamic variables in ncurses\nis within the current call to\n\\fBtparm\\fP.\nUse static variables if persistent storage is needed.\n.RE\n.RE\n.TP\n\\fB%\\(aq\\fP\\fIc\\fP\\fB\\(aq\\fP\nchar constant \\fIc\\fP\n.TP\n\\fB%{\\fP\\fInn\\fP\\fB}\\fP\ninteger constant \\fInn\\fP\n.TP\n\\fB%l\\fP\npush strlen(pop)\n.TP\n\\fB%+\\fP, \\fB%\\-\\fP, \\fB%*\\fP, \\fB%/\\fP, \\fB%m\\fP\narithmetic (%m is \\fImod\\fP): \\fIpush(pop() op pop())\\fP\n.TP\n\\fB%&\\fP, \\fB%|\\fP, \\fB%^\\fP\nbit operations (AND, OR and exclusive-OR): \\fIpush(pop() op pop())\\fP\n.TP\n\\fB%=\\fP, \\fB%>\\fP, \\fB%<\\fP\nlogical operations: \\fIpush(pop() op pop())\\fP\n.TP\n\\fB%A\\fP, \\fB%O\\fP\nlogical AND and OR operations (for conditionals)\n.TP\n\\fB%!\\fP, \\fB%~\\fP\nunary operations (logical and bit complement): \\fIpush(op pop())\\fP\n.TP\n\\fB%i\\fP\nadd 1 to first two parameters (for ANSI terminals)\n.TP\n\\fB%?\\fP \\fIexpr\\fP \\fB%t\\fP \\fIthenpart\\fP \\fB%e\\fP \\fIelsepart\\fP \\fB%;\\fP\nThis forms an if-then-else.\nThe \\fB%e\\fP \\fIelsepart\\fP is optional.\nUsually the \\fB%?\\fP \\fIexpr\\fP part pushes a value onto the stack,\nand \\fB%t\\fP pops it from the stack, testing if it is nonzero (true).\nIf it is zero (false), control passes to the \\fB%e\\fP (else) part.\n.IP\nIt is possible to form else-if's a la Algol 68:\n.RS\n\\fB%?\\fP c\\d1\\u \\fB%t\\fP b\\d1\\u \\fB%e\\fP c\\d2\\u \\fB%t\\fP b\\d2\\u \\fB%e\\fP c\\d3\\u \\fB%t\\fP b\\d3\\u \\fB%e\\fP c\\d4\\u \\fB%t\\fP b\\d4\\u \\fB%e\\fP \\fB%;\\fP\n.RE\n.IP\nwhere c\\di\\u are conditions, b\\di\\u are bodies.\n.IP\nUse the \\fB\\-f\\fP option of \\fB@TIC@\\fP or \\fB@INFOCMP@\\fP to see\nthe structure of if-then-else's.\nSome strings, e.g., \\fBsgr\\fP can be very complicated when written\non one line.\nThe \\fB\\-f\\fP option splits the string into lines with the parts indented.\n.PP\nBinary operations are in postfix form with the operands in the usual order.\nThat is, to get x\\-5 one would use \\*(``%gx%{5}%\\-\\*(''.\n\\fB%P\\fP and \\fB%g\\fP variables are\npersistent across escape-string evaluations.\n.PP\nConsider the HP2645, which, to get to row 3 and column 12, needs\nto be sent \\eE&a12c03Y padded for 6 milliseconds.\nNote that the order\nof the rows and columns is inverted here, and that the row and column\nare printed as two digits.\nThus its \\fBcup\\fP capability is \\*(``cup=6\\eE&%p2%2dc%p1%2dY\\*(''.\n.PP\nThe Microterm \\s-1ACT-IV\\s0 needs the current row and column sent\npreceded by a \\fB^T\\fP, with the row and column simply encoded in binary,\n\\*(``cup=^T%p1%c%p2%c\\*(''.\nTerminals which use \\*(``%c\\*('' need to be able to\nbackspace the cursor (\\fBcub1\\fP),\nand to move the cursor up one line on the screen (\\fBcuu1\\fP).\nThis is necessary because it is not always safe to transmit \\fB\\en\\fP\n\\fB^D\\fP and \\fB\\er\\fP, as the system may change or discard them.\n(The library routines dealing with terminfo set tty modes so that\ntabs are never expanded, so \\et is safe to send.\nThis turns out to be essential for the Ann Arbor 4080.)\n.PP\nA final example is the \\s-1LSI ADM\\s0-3a, which uses row and column\noffset by a blank character, thus \\*(``cup=\\eE=%p1%\\(aq \\(aq%+%c%p2%\\(aq \\(aq%+%c\\*(''.\nAfter sending \\*(``\\eE=\\*('', this pushes the first parameter, pushes the\nASCII value for a space (32), adds them (pushing the sum on the stack\nin place of the two previous values) and outputs that value as a character.\nThen the same is done for the second parameter.\nMore complex arithmetic is possible using the stack.\n.PP\n.SS Cursor Motions\n.PP\nIf the terminal has a fast way to home the cursor\n(to very upper left corner of screen) then this can be given as\n\\fBhome\\fP; similarly a fast way of getting to the lower left-hand corner\ncan be given as \\fBll\\fP; this may involve going up with \\fBcuu1\\fP\nfrom the home position,\nbut a program should never do this itself (unless \\fBll\\fP does) because it\ncan make no assumption about the effect of moving up from the home position.\nNote that the home position is the same as addressing to (0,0):\nto the top left corner of the screen, not of memory.\n(Thus, the \\eEH sequence on HP terminals cannot be used for\n.BR home .)\n.PP\nIf the terminal has row or column absolute cursor addressing,\nthese can be given as single parameter capabilities\n.B hpa\n(horizontal position absolute)\nand\n.B vpa\n(vertical position absolute).\nSometimes these are shorter than the more general two parameter\nsequence (as with the hp2645) and can be used in preference to\n.BR cup .\nIf there are parameterized local motions (e.g., move\n.I n\nspaces to the right) these can be given as\n.BR cud ,\n.BR cub ,\n.BR cuf ,\nand\n.B cuu\nwith a single parameter indicating how many spaces to move.\nThese are primarily useful if the terminal does not have\n.BR cup ,\nsuch as the \\s-1TEKTRONIX\\s+1 4025.\n.PP\nIf the terminal needs to be in a special mode when running\na program that uses these capabilities,\nthe codes to enter and exit this mode can be given as \\fBsmcup\\fP and \\fBrmcup\\fP.\nThis arises, for example, from terminals like the Concept with more than\none page of memory.\nIf the terminal has only memory relative cursor addressing and not screen\nrelative cursor addressing, a one screen-sized window must be fixed into\nthe terminal for cursor addressing to work properly.\nThis is also used for the \\s-1TEKTRONIX\\s+1 4025,\nwhere\n.B smcup\nsets the command character to be the one used by terminfo.\nIf the \\fBsmcup\\fP sequence will not restore the screen after an\n\\fBrmcup\\fP sequence is output (to the state prior to outputting\n\\fBrmcup\\fP), specify \\fBnrrmc\\fP.\n.PP\n.SS Margins\nSVr4 (and X/Open Curses)\nlist several string capabilities for setting margins.\nTwo were intended for use with terminals,\nand another six were intended for use with printers.\n.bP\nThe two terminal capabilities assume that the terminal may have\nthe capability of setting the left and/or right margin at the current\ncursor column position.\n.bP\nThe printer capabilities assume that the printer may have\ntwo types of capability:\n.RS\n.bP\nthe ability to set a top and/or bottom margin using the current\nline position, and\n.bP\nparameterized capabilities for setting the top, bottom, left, right margins\ngiven the number of rows or columns.\n.RE\n.RE\n.PP\nIn practice, the categorization into \\*(``terminal\\*('' and \\*(``printer\\*(''\nis not suitable:\n.bP\nThe AT&T SVr4 terminal database uses \\fBsmgl\\fP four times,\nfor AT&T hardware.\n.IP\nThree of the four are printers.\nThey lack the ability to set left/right margins by specifying the column.\n.bP\nOther (non-AT&T) terminals may support margins\nbut using different assumptions from AT&T.\n.IP\nFor instance, the DEC VT420 supports left/right margins,\nbut only using a column parameter.\nAs an added complication, the VT420 uses two settings to fully enable\nleft/right margins (left/right margin mode, and origin mode).\nThe former enables the margins, which causes printed text\nto wrap within margins, but the latter is needed to prevent\ncursor-addressing outside those margins.\n.bP\nBoth DEC VT420 left/right margins are set with a single control sequence.\nIf either is omitted, the corresponding margin is set to the left or\nright edge of the display (rather than leaving the margin unmodified).\n.PP\nThese are the margin-related capabilities:\n.TS\ncenter;\nl l\n_ _\nlw8 lw18.\n\\fBName\tDescription\\fP\nsmgl\tSet left margin at current column\nsmgr\tSet right margin at current column\nsmgb\tSet bottom margin at current line\nsmgt\tSet top margin at current line\nsmgbp\tSet bottom margin at line \\fIN\\fP\nsmglp\tSet left margin at column \\fIN\\fP\nsmgrp\tSet right margin at column \\fIN\\fP\nsmgtp\tSet top margin at line \\fIN\\fP\nsmglr\tSet both left and right margins to \\fIL\\fP and \\fIR\\fP\nsmgtb\tSet both top and bottom margins to \\fIT\\fP and \\fIB\\fP\n.TE\n.PP\nWhen writing an application that\nuses these string capabilities,\nthe pairs should be first checked to see\nif each capability in the pair is set or only one is set:\n.bP\nIf both \\fBsmglp\\fP and \\fBsmgrp\\fP are set,\neach is used with a single argument, \\fIN\\fP,\nthat gives the column number of the left and right margin, respectively.\n.bP\nIf both \\fBsmgtp\\fP and \\fBsmgbp\\fP are set,\neach is used to set the top and bottom margin,\nrespectively:\n.RS 4\n.bP\n\\fBsmgtp\\fP is used with a single argument, \\fIN\\fP,\nthe line number of the top margin.\n.bP\n\\fBsmgbp\\fP is used with two arguments, \\fIN\\fP and \\fIM\\fP,\nthat give the line number of the bottom margin,\nthe first counting from the top of the\npage and the second counting from the bottom.\nThis accommodates the two styles of specifying\nthe bottom margin in different manufacturers' printers.\n.RE\n.IP\nWhen designing a terminfo entry for a\nprinter that has a settable bottom margin,\nonly the first or second argument should be used, depending on the printer.\nWhen developing an application that uses \\fBsmgbp\\fP to set the bottom margin,\nboth arguments must be given.\n.PP\nConversely, when only one capability in the pair is set:\n.bP \nIf only one of \\fBsmglp\\fP and \\fBsmgrp\\fP is set,\nthen it is used with two arguments,\nthe column number of the left and right margins, in that order.\n.bP\nLikewise, if only one of \\fBsmgtp\\fP and \\fBsmgbp\\fP is set, then it\nis used with two arguments that give the top and bottom margins,\nin that order, counting from the top of the page.\n.IP\nWhen designing a terminfo entry for a printer that requires setting both\nleft and right or top and bottom margins simultaneously,\nonly one capability in the pairs\n\\fBsmglp\\fP and \\fBsmgrp\\fP or\n\\fBsmgtp\\fP and \\fBsmgbp\\fP should be defined,\nleaving the other unset.\n.PP\nExcept for very old terminal descriptions, e.g., those developed for SVr4,\nthe scheme just described should be considered obsolete.\nAn improved set of capabilities was added late in the SVr4 releases\n(\\fBsmglr\\fP and \\fBsmgtb\\fP),\nwhich explicitly use two parameters for setting the left/right or top/bottom\nmargins.\n.PP\nWhen setting margins, the line- and column-values are zero-based.\n.PP\nThe \\fBmgc\\fP string capability should be defined.\nApplications such as \\fBtabs\\fP(1) rely upon this to reset all margins.\n.\\\"\n.SS Area Clears\n.PP\nIf the terminal can clear from the current position to the end of the\nline, leaving the cursor where it is, this should be given as \\fBel\\fP.\nIf the terminal can clear from the beginning of the line to the current\nposition inclusive, leaving\nthe cursor where it is, this should be given as \\fBel1\\fP.\nIf the terminal can clear from the current position to the end of the\ndisplay, then this should be given as \\fBed\\fP.\n\\fBEd\\fP is only defined from the first column of a line.\n(Thus, it can be simulated by a request to delete a large number of lines,\nif a true\n.B ed\nis not available.)\n.PP\n.\\\"\n.SS Insert/delete line and vertical motions\n.PP\nIf the terminal can open a new blank line before the line where the cursor\nis, this should be given as \\fBil1\\fP; this is done only from the first\nposition of a line.\nThe cursor must then appear on the newly blank line.\nIf the terminal can delete the line which the cursor is on, then this\nshould be given as \\fBdl1\\fP; this is done only from the first position on\nthe line to be deleted.\nVersions of\n.B il1\nand\n.B dl1\nwhich take a single parameter and insert or delete that many lines can\nbe given as\n.B il\nand\n.BR dl .\n.PP\nIf the terminal has a settable scrolling region (like the vt100)\nthe command to set this can be described with the\n.B csr\ncapability, which takes two parameters:\nthe top and bottom lines of the scrolling region.\nThe cursor position is, alas, undefined after using this command.\n.PP\nIt is possible to get the effect of insert or delete line using\n.B csr\non a properly chosen region; the\n.B sc\nand\n.B rc\n(save and restore cursor) commands may be useful for ensuring that\nyour synthesized insert/delete string does not move the cursor.\n(Note that the \\fBncurses\\fP(3X) library does this synthesis\nautomatically, so you need not compose insert/delete strings for\nan entry with \\fBcsr\\fP).\n.PP\nYet another way to construct insert and delete might be to use a combination of\nindex with the memory-lock feature found on some terminals (like the HP\\-700/90\nseries, which however also has insert/delete).\n.PP\nInserting lines at the top or bottom of the screen can also be\ndone using\n.B ri\nor\n.B ind\non many terminals without a true insert/delete line,\nand is often faster even on terminals with those features.\n.PP\nThe boolean \\fBnon_dest_scroll_region\\fP should be set if each scrolling\nwindow is effectively a view port on a screen-sized canvas.\nTo test for\nthis capability, create a scrolling region in the middle of the screen,\nwrite something to the bottom line, move the cursor to the top of the region,\nand do \\fBri\\fP followed by \\fBdl1\\fP or \\fBind\\fP.\nIf the data scrolled\noff the bottom of the region by the \\fBri\\fP re-appears, then scrolling\nis non-destructive.\nSystem V and XSI Curses expect that \\fBind\\fP, \\fBri\\fP,\n\\fBindn\\fP, and \\fBrin\\fP will simulate destructive scrolling; their\ndocumentation cautions you not to define \\fBcsr\\fP unless this is true.\nThis \\fBcurses\\fP implementation is more liberal and will do explicit erases\nafter scrolling if \\fBndsrc\\fP is defined.\n.PP\nIf the terminal has the ability to define a window as part of\nmemory, which all commands affect,\nit should be given as the parameterized string\n.BR wind .\nThe four parameters are the starting and ending lines in memory\nand the starting and ending columns in memory, in that order.\n.PP\nIf the terminal can retain display memory above, then the\n\\fBda\\fP capability should be given; if display memory can be retained\nbelow, then \\fBdb\\fP should be given.\nThese indicate\nthat deleting a line or scrolling may bring non-blank lines up from below\nor that scrolling back with \\fBri\\fP may bring down non-blank lines.\n.PP\n.SS Insert/Delete Character\n.PP\nThere are two basic kinds of intelligent terminals with respect to\ninsert/delete character which can be described using\n.I terminfo.\nThe most common insert/delete character operations affect only the characters\non the current line and shift characters off the end of the line rigidly.\nOther terminals, such as the Concept 100 and the Perkin Elmer Owl, make\na distinction between typed and untyped blanks on the screen, shifting\nupon an insert or delete only to an untyped blank on the screen which is\neither eliminated, or expanded to two untyped blanks.\n.PP\nYou can determine the\nkind of terminal you have by clearing the screen and then typing\ntext separated by cursor motions.\nType \\*(``abc\\ \\ \\ \\ def\\*('' using local\ncursor motions (not spaces) between the \\*(``abc\\*('' and the \\*(``def\\*(''.\nThen position the cursor before the \\*(``abc\\*('' and put the terminal in insert\nmode.\nIf typing characters causes the rest of the line to shift\nrigidly and characters to fall off the end, then your terminal does\nnot distinguish between blanks and untyped positions.\nIf the \\*(``abc\\*(''\nshifts over to the \\*(``def\\*('' which then move together around the end of the\ncurrent line and onto the next as you insert, you have the second type of\nterminal, and should give the capability \\fBin\\fP, which stands for\n\\*(``insert null\\*(''.\n.PP\nWhile these are two logically separate attributes (one line versus multi-line\ninsert mode, and special treatment of untyped spaces) we have seen no\nterminals whose insert mode cannot be described with the single attribute.\n.PP\nTerminfo can describe both terminals which have an insert mode, and terminals\nwhich send a simple sequence to open a blank position on the current line.\nGive as \\fBsmir\\fP the sequence to get into insert mode.\nGive as \\fBrmir\\fP the sequence to leave insert mode.\nNow give as \\fBich1\\fP any sequence needed to be sent just before sending\nthe character to be inserted.\nMost terminals with a true insert mode\nwill not give \\fBich1\\fP; terminals which send a sequence to open a screen\nposition should give it here.\n.PP\nIf your terminal has both, insert mode is usually preferable to \\fBich1\\fP.\nTechnically, you should not give both unless the terminal actually requires\nboth to be used in combination.\nAccordingly, some non-curses applications get\nconfused if both are present; the symptom is doubled characters in an update\nusing insert.\nThis requirement is now rare; most \\fBich\\fP sequences do not\nrequire previous smir, and most smir insert modes do not require \\fBich1\\fP\nbefore each character.\nTherefore, the new \\fBcurses\\fP actually assumes this\nis the case and uses either \\fBrmir\\fP/\\fBsmir\\fP or \\fBich\\fP/\\fBich1\\fP as\nappropriate (but not both).\nIf you have to write an entry to be used under\nnew curses for a terminal old enough to need both, include the\n\\fBrmir\\fP/\\fBsmir\\fP sequences in \\fBich1\\fP.\n.PP\nIf post insert padding is needed, give this as a number of milliseconds\nin \\fBip\\fP (a string option).\nAny other sequence which may need to be\nsent after an insert of a single character may also be given in \\fBip\\fP.\nIf your terminal needs both to be placed into an \\*(``insert mode\\*('' and\na special code to precede each inserted character, then both\n.BR smir / rmir\nand\n.B ich1\ncan be given, and both will be used.\nThe\n.B ich\ncapability, with one parameter,\n.IR n ,\nwill repeat the effects of\n.B ich1\n.I n\ntimes.\n.PP\nIf padding is necessary between characters typed while not\nin insert mode, give this as a number of milliseconds padding in \\fBrmp\\fP.\n.PP\nIt is occasionally necessary to move around while in insert mode\nto delete characters on the same line (e.g., if there is a tab after\nthe insertion position).\nIf your terminal allows motion while in\ninsert mode you can give the capability \\fBmir\\fP to speed up inserting\nin this case.\nOmitting \\fBmir\\fP will affect only speed.\nSome terminals\n(notably Datamedia's) must not have \\fBmir\\fP because of the way their\ninsert mode works.\n.PP\nFinally, you can specify\n.B dch1\nto delete a single character,\n.B dch\nwith one parameter,\n.IR n ,\nto delete\n.I n characters,\nand delete mode by giving \\fBsmdc\\fP and \\fBrmdc\\fP\nto enter and exit delete mode (any mode the terminal needs to be placed\nin for\n.B dch1\nto work).\n.PP\nA command to erase\n.I n\ncharacters (equivalent to outputting\n.I n\nblanks without moving the cursor)\ncan be given as\n.B ech\nwith one parameter.\n.PP\n.SS \"Highlighting, Underlining, and Visible Bells\"\n.PP\nIf your terminal has one or more kinds of display attributes,\nthese can be represented in a number of different ways.\nYou should choose one display form as\n\\f2standout mode\\fP,\nrepresenting a good, high contrast, easy-on-the-eyes,\nformat for highlighting error messages and other attention getters.\n(If you have a choice, reverse video plus half-bright is good,\nor reverse video alone.)\nThe sequences to enter and exit standout mode\nare given as \\fBsmso\\fP and \\fBrmso\\fP, respectively.\nIf the code to change into or out of standout\nmode leaves one or even two blank spaces on the screen,\nas the TVI 912 and Teleray 1061 do,\nthen \\fBxmc\\fP should be given to tell how many spaces are left.\n.PP\nCodes to begin underlining and end underlining can be given as \\fBsmul\\fP\nand \\fBrmul\\fP respectively.\nIf the terminal has a code to underline the current character and move\nthe cursor one space to the right,\nsuch as the Microterm Mime,\nthis can be given as \\fBuc\\fP.\n.PP\nOther capabilities to enter various highlighting modes include\n.B blink\n(blinking)\n.B bold\n(bold or extra bright)\n.B dim\n(dim or half-bright)\n.B invis\n(blanking or invisible text)\n.B prot\n(protected)\n.B rev\n(reverse video)\n.B sgr0\n(turn off\n.I all\nattribute modes)\n.B smacs\n(enter alternate character set mode)\nand\n.B rmacs\n(exit alternate character set mode).\nTurning on any of these modes singly may or may not turn off other modes.\n.PP\nIf there is a sequence to set arbitrary combinations of modes,\nthis should be given as\n.B sgr\n(set attributes),\ntaking 9 parameters.\nEach parameter is either 0 or nonzero, as the corresponding attribute is on or off.\nThe 9 parameters are, in order:\nstandout, underline, reverse, blink, dim, bold, blank, protect, alternate\ncharacter set.\nNot all modes need be supported by\n.BR sgr ,\nonly those for which corresponding separate attribute commands exist.\n.PP\nFor example, the DEC vt220 supports most of the modes:\n.PP\n.TS\ncenter;\nl l l\nl l l\nlw18 lw14 lw18.\n\\fBtparm parameter\tattribute\tescape sequence\\fP\n\nnone\tnone\t\\\\E[0m\np1\tstandout\t\\\\E[0;1;7m\np2\tunderline\t\\\\E[0;4m\np3\treverse\t\\\\E[0;7m\np4\tblink\t\\\\E[0;5m\np5\tdim\tnot available\np6\tbold\t\\\\E[0;1m\np7\tinvis\t\\\\E[0;8m\np8\tprotect\tnot used\np9\taltcharset\t^O (off) ^N (on)\n.TE\n.PP\nWe begin each escape sequence by turning off any existing modes, since\nthere is no quick way to determine whether they are active.\nStandout is set up to be the combination of reverse and bold.\nThe vt220 terminal has a protect mode,\nthough it is not commonly used in sgr\nbecause it protects characters on the screen from the host's erasures.\nThe altcharset mode also is different in that it is either ^O or ^N,\ndepending on whether it is off or on.\nIf all modes are turned on, the resulting sequence is \\\\E[0;1;4;5;7;8m^N.\n.PP\nSome sequences are common to different modes.\nFor example, ;7 is output when either p1 or p3 is true, that is, if\neither standout or reverse modes are turned on.\n.PP\nWriting out the above sequences, along with their dependencies yields\n.PP\n.ne 11\n.TS\ncenter;\nl l l\nl l l\nlw18 lw14 lw18.\n\\fBsequence\twhen to output\tterminfo translation\\fP\n\n.ft CW\n\\\\E[0\talways\t\\\\E[0\n;1\tif p1 or p6\t%?%p1%p6%|%t;1%;\n;4\tif p2\t%?%p2%|%t;4%;\n;5\tif p4\t%?%p4%|%t;5%;\n;7\tif p1 or p3\t%?%p1%p3%|%t;7%;\n;8\tif p7\t%?%p7%|%t;8%;\nm\talways\tm\n^N or ^O\tif p9 ^N, else ^O\t%?%p9%t^N%e^O%;\n.ft R\n.TE\n.PP\nPutting this all together into the sgr sequence gives:\n.PP\n.ft CW\n.nf\n    sgr=\\\\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p4%t;5%;\n        %?%p1%p3%|%t;7%;%?%p7%t;8%;m%?%p9%t\\\\016%e\\\\017%;,\n.fi\n.ft R\n.PP\nRemember that if you specify sgr, you must also specify sgr0.\nAlso, some implementations rely on sgr being given if sgr0 is,\nNot all terminfo entries necessarily have an sgr string, however.\nMany terminfo entries are derived from termcap entries\nwhich have no sgr string.\nThe only drawback to adding an sgr string is that termcap also\nassumes that sgr0 does not exit alternate character set mode.\n.PP\nTerminals with the \\*(``magic cookie\\*('' glitch\n.RB ( xmc )\ndeposit special \\*(``cookies\\*('' when they receive mode-setting sequences,\nwhich affect the display algorithm rather than having extra bits for\neach character.\nSome terminals, such as the HP 2621, automatically leave standout\nmode when they move to a new line or the cursor is addressed.\nPrograms using standout mode should exit standout mode before\nmoving the cursor or sending a newline,\nunless the\n.B msgr\ncapability, asserting that it is safe to move in standout mode, is present.\n.PP\nIf the terminal has\na way of flashing the screen to indicate an error quietly (a bell replacement)\nthen this can be given as \\fBflash\\fP; it must not move the cursor.\n.PP\nIf the cursor needs to be made more visible than normal when it is\nnot on the bottom line (to make, for example, a non-blinking underline into an\neasier to find block or blinking underline)\ngive this sequence as\n.BR cvvis .\nIf there is a way to make the cursor completely invisible, give that as\n.BR civis .\nThe capability\n.B cnorm\nshould be given which undoes the effects of both of these modes.\n.PP\nIf your terminal correctly generates underlined characters\n(with no special codes needed)\neven though it does not overstrike,\nthen you should give the capability \\fBul\\fP.\nIf a character overstriking another leaves both characters on the screen,\nspecify the capability \\fBos\\fP.\nIf overstrikes are erasable with a blank,\nthen this should be indicated by giving \\fBeo\\fP.\n.PP\n.SS Keypad and Function Keys\n.PP\nIf the terminal has a keypad that transmits codes when the keys are pressed,\nthis information can be given.\nNote that it is not possible to handle\nterminals where the keypad only works in local (this applies, for example,\nto the unshifted HP 2621 keys).\nIf the keypad can be set to transmit or not transmit,\ngive these codes as \\fBsmkx\\fP and \\fBrmkx\\fP.\nOtherwise the keypad is assumed to always transmit.\n.PP\nThe codes sent by the left arrow, right arrow, up arrow, down arrow,\nand home keys can be given as\n\\fBkcub1, kcuf1, kcuu1, kcud1, \\fRand\\fB khome\\fP respectively.\nIf there are function keys such as f0, f1, ..., f10, the codes they send\ncan be given as \\fBkf0, kf1, ..., kf10\\fP.\nIf these keys have labels other than the default f0 through f10, the labels\ncan be given as \\fBlf0, lf1, ..., lf10\\fP.\n.PP\nThe codes transmitted by certain other special keys can be given:\n.bP\n.B kll\n(home down),\n.bP\n.B kbs\n(backspace),\n.bP\n.B ktbc\n(clear all tabs),\n.bP\n.B kctab\n(clear the tab stop in this column),\n.bP\n.B kclr\n(clear screen or erase key),\n.bP\n.B kdch1\n(delete character),\n.bP\n.B kdl1\n(delete line),\n.bP\n.B krmir\n(exit insert mode),\n.bP\n.B kel\n(clear to end of line),\n.bP\n.B ked\n(clear to end of screen),\n.bP\n.B kich1\n(insert character or enter insert mode),\n.bP\n.B kil1\n(insert line),\n.bP\n.B knp\n(next page),\n.bP\n.B kpp\n(previous page),\n.bP\n.B kind\n(scroll forward/down),\n.bP\n.B kri\n(scroll backward/up),\n.bP\n.B khts\n(set a tab stop in this column).\n.PP\nIn addition, if the keypad has a 3 by 3 array of keys including the four\narrow keys, the other five keys can be given as\n.BR ka1 ,\n.BR ka3 ,\n.BR kb2 ,\n.BR kc1 ,\nand\n.BR kc3 .\nThese keys are useful when the effects of a 3 by 3 directional pad are needed.\n.PP\nStrings to program function keys can be given as\n.BR pfkey ,\n.BR pfloc ,\nand\n.BR pfx .\nA string to program screen labels should be specified as \\fBpln\\fP.\nEach of these strings takes two parameters: the function key number to\nprogram (from 0 to 10) and the string to program it with.\nFunction key numbers out of this range may program undefined keys in\na terminal dependent manner.\nThe difference between the capabilities is that\n.B pfkey\ncauses pressing the given key to be the same as the user typing the\ngiven string;\n.B pfloc\ncauses the string to be executed by the terminal in local; and\n.B pfx\ncauses the string to be transmitted to the computer.\n.PP\nThe capabilities \\fBnlab\\fP, \\fBlw\\fP and \\fBlh\\fP\ndefine the number of programmable\nscreen labels and their width and height.\nIf there are commands to turn the labels on and off,\ngive them in \\fBsmln\\fP and \\fBrmln\\fP.\n\\fBsmln\\fP is normally output after one or more pln\nsequences to make sure that the change becomes visible.\n.PP\n.SS Tabs and Initialization\n.PP\nA few capabilities are used only for tabs:\n.bP\nIf the terminal has hardware tabs, the command to advance to the next\ntab stop can be given as\n.B ht\n(usually control/I).\n.bP\nA \\*(``back-tab\\*('' command which moves leftward to the preceding tab stop can\nbe given as\n.BR cbt .\n.IP\nBy convention, if the teletype modes indicate that tabs are being\nexpanded by the computer rather than being sent to the terminal,\nprograms should not use\n.B ht\nor\n.B cbt\neven if they are present, since the user may not have the tab stops\nproperly set.\n.bP\nIf the terminal has hardware tabs which are initially set every\n.I n\nspaces when the terminal is powered up,\nthe numeric parameter\n.B it\nis given, showing the number of spaces the tabs are set to.\n.IP\nThe \\fBit\\fP capability is normally used by the \\fB@TSET@\\fP\ncommand to determine whether to set the mode for hardware tab expansion,\nand whether to set the tab stops.\nIf the terminal has tab stops that can be saved in non-volatile memory,\nthe terminfo description can assume that they are properly set.\n.PP\nOther capabilities\ninclude\n.bP\n.BR is1 ,\n.BR is2 ,\nand\n.BR is3 ,\ninitialization strings for the terminal,\n.bP\n.BR iprog ,\nthe path name of a program to be run to initialize the terminal,\n.bP\nand \\fBif\\fP, the name of a file containing long initialization strings.\n.PP\nThese strings are expected to set the terminal into modes consistent\nwith the rest of the terminfo description.\nThey are normally sent to the terminal, by the\n.I init\noption of the \\fB@TPUT@\\fP program, each time the user logs in.\nThey will be printed in the following order:\n.RS\n.TP\nrun the program\n.B iprog\n.TP\noutput\n.br\n\\fBis1\\fP and\n.br\n\\fBis2\\fP\n.TP\nset the margins using\n\\fBmgc\\fP or\n.br\n\\fBsmglp\\fP and \\fBsmgrp\\fP or\n.br\n\\fBsmgl\\fP and \\fBsmgr\\fP\n.TP\nset tabs using\n.B tbc\nand\n.B hts\n.TP\nprint the file\n\\fBif\\fP\n.TP\nand finally output\n\\fBis3\\fP.\n.RE\n.PP\nMost initialization is done with\n.BR is2 .\nSpecial terminal modes can be set up without duplicating strings\nby putting the common sequences in\n.B is2\nand special cases in\n.B is1\nand\n.BR is3 .\n.PP\nA set of sequences that does a harder reset from a totally unknown state\ncan be given as\n.BR rs1 ,\n.BR rs2 ,\n.B rf\nand\n.BR rs3 ,\nanalogous to\n.B is1 ,\n.B is2 ,\n.B if\nand\n.B is3\nrespectively.\nThese strings are output\nby \\fIreset\\fP option of \\fB@TPUT@\\fP,\nor by the \\fB@RESET@\\fP program\n(an alias of \\fB@TSET@\\fP),\nwhich is used when the terminal gets into a wedged state.\nCommands are normally placed in\n.BR rs1 ,\n.B rs2\n.B rs3\nand\n.B rf\nonly if they produce annoying effects on the screen and are not\nnecessary when logging in.\nFor example, the command to set the vt100 into 80-column mode would\nnormally be part of\n.BR is2 ,\nbut it causes an annoying glitch of the screen and is not normally\nneeded since the terminal is usually already in 80-column mode.\n.PP\nThe \\fB@RESET@\\fP program writes strings including\n.BR iprog ,\netc., in the same order as the\n.I init\nprogram, using\n.BR rs1 ,\netc., instead of\n.BR is1 ,\netc.\nIf any of\n.BR rs1 ,\n.BR rs2 ,\n.BR rs3 ,\nor\n.B rf\nreset capability strings are missing,\nthe \\fB@RESET@\\fP program\nfalls back upon the corresponding initialization capability string.\n.PP\nIf there are commands to set and clear tab stops, they can be given as\n.B tbc\n(clear all tab stops)\nand\n.B hts\n(set a tab stop in the current column of every row).\nIf a more complex sequence is needed to set the tabs than can be\ndescribed by this, the sequence can be placed in\n.B is2\nor\n.BR if .\n.PP\nThe \\fB@TPUT@ reset\\fP command uses the same capability strings\nas the \\fB@RESET@\\fP command,\nalthough the two programs (\\fB@TPUT@\\fP and \\fB@RESET@\\fP)\nprovide different command-line options.\n.PP\nIn practice, these terminfo capabilities are not often used in\ninitialization of tabs\n(though they are required for the \\fB@TABS@\\fP program):\n.bP\nAlmost all hardware terminals (at least those which supported tabs)\ninitialized those to every \\fIeight\\fP columns:\n.IP\nThe only exception was the AT&T 2300 series,\nwhich set tabs to every \\fIfive\\fP columns.\n.bP\nIn particular, developers of the hardware terminals which are commonly used\nas models for modern terminal emulators provided documentation demonstrating\nthat \\fIeight\\fP columns were the standard.\n.bP\nBecause of this, the terminal initialization programs\n\\fB@TPUT@\\fP and \\fB@TSET@\\fP\nuse the\n\\fBtbc\\fP (\\fBclear_all_tabs\\fP) and\n\\fBhts\\fP (\\fBset_tab\\fP) capabilities directly\nonly when the \\fBit\\fP (\\fBinit_tabs\\fP) capability\nis set to a value other than \\fIeight\\fP.\n.SS Delays and Padding\n.PP\nMany older and slower terminals do not support either XON/XOFF or DTR\nhandshaking, including hard copy terminals and some very archaic CRTs\n(including, for example, DEC VT100s).\nThese may require padding characters\nafter certain cursor motions and screen changes.\n.PP\nIf the terminal uses xon/xoff handshaking for flow control (that is,\nit automatically emits ^S back to the host when its input buffers are\nclose to full), set\n.BR xon .\nThis capability suppresses the emission of padding.\nYou can also set it\nfor memory-mapped console devices effectively that do not have a speed limit.\nPadding information should still be included so that routines can\nmake better decisions about relative costs, but actual pad characters will\nnot be transmitted.\n.PP\nIf \\fBpb\\fP (padding baud rate) is given, padding is suppressed at baud rates\nbelow the value of \\fBpb\\fP.\nIf the entry has no padding baud rate, then\nwhether padding is emitted or not is completely controlled by \\fBxon\\fP.\n.PP\nIf the terminal requires other than a null (zero) character as a pad,\nthen this can be given as \\fBpad\\fP.\nOnly the first character of the\n.B pad\nstring is used.\n.PP\n.SS Status Lines\nSome terminals have an extra \\*(``status line\\*('' which is not normally used by\nsoftware (and thus not counted in the terminal's \\fBlines\\fP capability).\n.PP\nThe simplest case is a status line which is cursor-addressable but not\npart of the main scrolling region on the screen; the Heathkit H19 has\na status line of this kind, as would a 24-line VT100 with a 23-line\nscrolling region set up on initialization.\nThis situation is indicated\nby the \\fBhs\\fP capability.\n.PP\nSome terminals with status lines need special sequences to access the\nstatus line.\nThese may be expressed as a string with single parameter\n\\fBtsl\\fP which takes the cursor to a given zero-origin column on the\nstatus line.\nThe capability \\fBfsl\\fP must return to the main-screen\ncursor positions before the last \\fBtsl\\fP.\nYou may need to embed the\nstring values of \\fBsc\\fP (save cursor) and \\fBrc\\fP (restore cursor)\nin \\fBtsl\\fP and \\fBfsl\\fP to accomplish this.\n.PP\nThe status line is normally assumed to be the same width as the width\nof the terminal.\nIf this is untrue, you can specify it with the numeric\ncapability \\fBwsl\\fP.\n.PP\nA command to erase or blank the status line may be specified as \\fBdsl\\fP.\n.PP\nThe boolean capability \\fBeslok\\fP specifies that escape sequences, tabs,\netc., work ordinarily in the status line.\n.PP\nThe \\fBncurses\\fP implementation does not yet use any of these capabilities.\nThey are documented here in case they ever become important.\n.PP\n.SS Line Graphics\n.PP\nMany terminals have alternate character sets useful for forms-drawing.\nTerminfo and \\fBcurses\\fP have built-in support\nfor most of the drawing characters\nsupported by the VT100, with some characters from the AT&T 4410v1 added.\nThis alternate character set may be specified by the \\fBacsc\\fP capability.\n.PP\n.TS H\ncenter expand;\nl l l l l\nl l l l l\n_ _ _ _ _\nlw25 lw10 lw6 lw6 lw6.\n.\\\".TH\n\\fBGlyph\tACS\tAscii\tacsc\tacsc\\fP\n\\fBName\tName\tDefault\tChar\tValue\\fP\narrow pointing right\tACS_RARROW\t>\t+\t0x2b\narrow pointing left\tACS_LARROW\t<\t,\t0x2c\narrow pointing up\tACS_UARROW\t^\t\\-\t0x2d\narrow pointing down\tACS_DARROW\tv\t.\t0x2e\nsolid square block\tACS_BLOCK\t#\t0\t0x30\ndiamond         \tACS_DIAMOND\t+\t`\t0x60\nchecker board (stipple)\tACS_CKBOARD\t:\ta\t0x61\ndegree symbol   \tACS_DEGREE\t\\e\tf\t0x66\nplus/minus      \tACS_PLMINUS\t#\tg\t0x67\nboard of squares\tACS_BOARD\t#\th\t0x68\nlantern symbol  \tACS_LANTERN\t#\ti\t0x69\nlower right corner\tACS_LRCORNER\t+\tj\t0x6a\nupper right corner\tACS_URCORNER\t+\tk\t0x6b\nupper left corner\tACS_ULCORNER\t+\tl\t0x6c\nlower left corner\tACS_LLCORNER\t+\tm\t0x6d\nlarge plus or crossover\tACS_PLUS\t+\tn\t0x6e\nscan line 1     \tACS_S1  \t~\to\t0x6f\nscan line 3     \tACS_S3  \t\\-\tp\t0x70\nhorizontal line \tACS_HLINE\t\\-\tq\t0x71\nscan line 7     \tACS_S7  \t\\-\tr\t0x72\nscan line 9     \tACS_S9  \t\\&_\ts\t0x73\ntee pointing right\tACS_LTEE\t+\tt\t0x74\ntee pointing left\tACS_RTEE\t+\tu\t0x75\ntee pointing up \tACS_BTEE\t+\tv\t0x76\ntee pointing down\tACS_TTEE\t+\tw\t0x77\nvertical line   \tACS_VLINE\t|\tx\t0x78\nless-than-or-equal-to\tACS_LEQUAL\t<\ty\t0x79\ngreater-than-or-equal-to\tACS_GEQUAL\t>\tz\t0x7a\ngreek pi        \tACS_PI\t*\t{\t0x7b\nnot-equal       \tACS_NEQUAL\t!\t|\t0x7c\nUK pound sign        \tACS_STERLING\tf\t}\t0x7d\nbullet          \tACS_BULLET\to\t~\t0x7e\n.TE\n.PP\nA few notes apply to the table itself:\n.bP\nX/Open Curses incorrectly states that the mapping for \\fIlantern\\fP is\nuppercase \\*(``I\\*('' although Unix implementations use the\nlowercase \\*(``i\\*('' mapping.\n.bP\nThe DEC VT100 implemented graphics using the alternate character set\nfeature, temporarily switching \\fImodes\\fP and sending characters\nin the range 0x60 (96) to 0x7e (126)\n(the \\fBacsc Value\\fP column in the table).\n.bP\nThe AT&T terminal added graphics characters outside that range.\n.IP\nSome of the characters within the range do not match the VT100;\npresumably they were used in the AT&T terminal:\n\\fIboard of squares\\fP replaces the VT100 \\fInewline\\fP symbol, while\n\\fIlantern symbol\\fP replaces the VT100 \\fIvertical tab\\fP symbol.\nThe other VT100 symbols for control characters (\\fIhorizontal tab\\fP,\n\\fIcarriage return\\fP and \\fIline-feed\\fP) are not (re)used in curses.\n.PP\nThe best way to define a new device's graphics set is to add a column\nto a copy of this table for your terminal, giving the character which\n(when emitted between \\fBsmacs\\fP/\\fBrmacs\\fP switches) will be rendered\nas the corresponding graphic.\nThen read off the VT100/your terminal\ncharacter pairs right to left in sequence; these become the ACSC string.\n.PP\n.SS Color Handling\n.PP\nThe curses library functions \\fBinit_pair\\fP and \\fBinit_color\\fP\nmanipulate the \\fIcolor pairs\\fP and \\fIcolor values\\fP discussed in this\nsection\n(see \\fBcurs_color\\fP(3X) for details on these and related functions).\n.PP\nMost color terminals are either \\*(``Tektronix-like\\*('' or \\*(``HP-like\\*('':\n.bP\nTektronix-like\nterminals have a predefined set of \\fIN\\fP colors\n(where \\fIN\\fP is usually 8),\nand can set\ncharacter-cell foreground and background characters independently, mixing them\ninto \\fIN\\fP\\ *\\ \\fIN\\fP color-pairs.\n.bP\nOn HP-like terminals, the user must set each color\npair up separately (foreground and background are not independently settable).\nUp to \\fIM\\fP color-pairs may be set up from 2*\\fIM\\fP different colors.\nANSI-compatible terminals are Tektronix-like.\n.PP\nSome basic color capabilities are independent of the color method.\nThe numeric\ncapabilities \\fBcolors\\fP and \\fBpairs\\fP specify the maximum numbers of colors\nand color-pairs that can be displayed simultaneously.\nThe \\fBop\\fP (original\npair) string resets foreground and background colors to their default values\nfor the terminal.\nThe \\fBoc\\fP string resets all colors or color-pairs to\ntheir default values for the terminal.\nSome terminals (including many PC\nterminal emulators) erase screen areas with the current background color rather\nthan the power-up default background; these should have the boolean capability\n\\fBbce\\fP.\n.PP\nWhile the curses library works with \\fIcolor pairs\\fP\n(reflecting the inability of some devices to set foreground\nand background colors independently),\nthere are separate capabilities for setting these features:\n.bP\nTo change the current foreground or background color on a Tektronix-type\nterminal, use \\fBsetaf\\fP (set ANSI foreground) and \\fBsetab\\fP (set ANSI\nbackground) or \\fBsetf\\fP (set foreground) and \\fBsetb\\fP (set background).\nThese take one parameter, the color number.\nThe SVr4 documentation describes\nonly \\fBsetaf\\fP/\\fBsetab\\fP; the XPG4 draft says that \"If the terminal\nsupports ANSI escape sequences to set background and foreground, they should\nbe coded as \\fBsetaf\\fP and \\fBsetab\\fP, respectively.\n.bP\nIf the terminal\nsupports other escape sequences to set background and foreground, they should\nbe coded as \\fBsetf\\fP and \\fBsetb\\fP, respectively.\nThe \\fBvidputs\\fP and the \\fBrefresh\\fP(3X) functions\nuse the \\fBsetaf\\fP and \\fBsetab\\fP capabilities if they are defined.\n.PP\nThe \\fBsetaf\\fP/\\fBsetab\\fP and \\fBsetf\\fP/\\fBsetb\\fP capabilities take a\nsingle numeric argument each.\nArgument values 0-7 of \\fBsetaf\\fP/\\fBsetab\\fP are portably defined as\nfollows (the middle column is the symbolic #define available in the header for\nthe \\fBcurses\\fP or \\fBncurses\\fP libraries).\nThe terminal hardware is free to\nmap these as it likes, but the RGB values indicate normal locations in color\nspace.\n.PP\n.TS H\ncenter;\nl c c c\nl l n l.\n\\fBColor\t#define \tValue\tRGB\\fP\nblack\t\\fBCOLOR_BLACK\\fP\t0\t0, 0, 0\nred\t\\fBCOLOR_RED\\ \\fP\t1\tmax,0,0\ngreen\t\\fBCOLOR_GREEN\\fP\t2\t0,max,0\nyellow\t\\fBCOLOR_YELLOW\\fP\t3\tmax,max,0\nblue\t\\fBCOLOR_BLUE\\fP\t4\t0,0,max\nmagenta\t\\fBCOLOR_MAGENTA\\fP\t5\tmax,0,max\ncyan\t\\fBCOLOR_CYAN\\fP\t6\t0,max,max\nwhite\t\\fBCOLOR_WHITE\\fP\t7\tmax,max,max\n.TE\n.PP\nThe argument values of \\fBsetf\\fP/\\fBsetb\\fP historically correspond to\na different mapping, i.e.,\n.TS H\ncenter;\nl c c c\nl l n l.\n\\fBColor\t#define \tValue\tRGB\\fP\nblack\t\\fBCOLOR_BLACK\\fP\t0\t0, 0, 0\nblue\t\\fBCOLOR_BLUE\\fP\t1\t0,0,max\ngreen\t\\fBCOLOR_GREEN\\fP\t2\t0,max,0\ncyan\t\\fBCOLOR_CYAN\\fP\t3\t0,max,max\nred\t\\fBCOLOR_RED\\ \\fP\t4\tmax,0,0\nmagenta\t\\fBCOLOR_MAGENTA\\fP\t5\tmax,0,max\nyellow\t\\fBCOLOR_YELLOW\\fP\t6\tmax,max,0\nwhite\t\\fBCOLOR_WHITE\\fP\t7\tmax,max,max\n.TE\n.PP\nIt is important to not confuse the two sets of color capabilities;\notherwise red/blue will be interchanged on the display.\n.PP\nOn an HP-like terminal, use \\fBscp\\fP with a color-pair number parameter to set\nwhich color pair is current.\n.PP\nSome terminals allow the \\fIcolor values\\fP to be modified:\n.bP\nOn a Tektronix-like terminal, the capability \\fBccc\\fP may be present to\nindicate that colors can be modified.\nIf so, the \\fBinitc\\fP capability will\ntake a color number (0 to \\fBcolors\\fP \\- 1)and three more parameters which\ndescribe the color.\nThese three parameters default to being interpreted as RGB\n(Red, Green, Blue) values.\nIf the boolean capability \\fBhls\\fP is present,\nthey are instead as HLS (Hue, Lightness, Saturation) indices.\nThe ranges are\nterminal-dependent.\n.bP\nOn an HP-like terminal, \\fBinitp\\fP may give a capability for changing a\ncolor-pair value.\nIt will take seven parameters; a color-pair number (0 to\n\\fBmax_pairs\\fP \\- 1), and two triples describing first background and then\nforeground colors.\nThese parameters must be (Red, Green, Blue) or\n(Hue, Lightness, Saturation) depending on \\fBhls\\fP.\n.PP\nOn some color terminals, colors collide with highlights.\nYou can register\nthese collisions with the \\fBncv\\fP capability.\nThis is a bit-mask of\nattributes not to be used when colors are enabled.\nThe correspondence with the\nattributes understood by \\fBcurses\\fP is as follows:\n.PP\n.TS\ncenter;\nl l l l\nlw20 lw2 lw10 lw10.\n\\fBAttribute\tBit\tDecimal\tSet by\\fP\nA_STANDOUT\t0\t1\tsgr\nA_UNDERLINE\t1\t2\tsgr\nA_REVERSE\t2\t4\tsgr\nA_BLINK   \t3\t8\tsgr\nA_DIM      \t4\t16\tsgr\nA_BOLD    \t5\t32\tsgr\nA_INVIS   \t6\t64\tsgr\nA_PROTECT\t7\t128\tsgr\nA_ALTCHARSET\t8\t256\tsgr\nA_HORIZONTAL\t9\t512\tsgr1\nA_LEFT\t10\t1024\tsgr1\nA_LOW\t11\t2048\tsgr1\nA_RIGHT\t12\t4096\tsgr1\nA_TOP\t13\t8192\tsgr1\nA_VERTICAL\t14\t16384\tsgr1\nA_ITALIC\t15\t32768\tsitm\n.TE\n.PP\nFor example, on many IBM PC consoles, the underline attribute collides with the\nforeground color blue and is not available in color mode.\nThese should have\nan \\fBncv\\fP capability of 2.\n.PP\nSVr4 curses does nothing with \\fBncv\\fP, ncurses recognizes it and optimizes\nthe output in favor of colors.\n.PP\n.SS Miscellaneous\nIf the terminal requires other than a null (zero) character as a pad, then this\ncan be given as pad.\nOnly the first character of the pad string is used.\nIf the terminal does not have a pad character, specify npc.\nNote that ncurses implements the termcap-compatible \\fBPC\\fP variable;\nthough the application may set this value to something other than\na null, ncurses will test \\fBnpc\\fP first and use napms if the terminal\nhas no pad character.\n.PP\nIf the terminal can move up or down half a line,\nthis can be indicated with\n.B hu\n(half-line up)\nand\n.B hd\n(half-line down).\nThis is primarily useful for superscripts and subscripts on hard-copy terminals.\nIf a hard-copy terminal can eject to the next page (form feed), give this as\n.B ff\n(usually control/L).\n.PP\nIf there is a command to repeat a given character a given number of\ntimes (to save time transmitting a large number of identical characters)\nthis can be indicated with the parameterized string\n.BR rep .\nThe first parameter is the character to be repeated and the second\nis the number of times to repeat it.\nThus, tparm(repeat_char, \\(aqx\\(aq, 10) is the same as \\*(``xxxxxxxxxx\\*(''.\n.PP\nIf the terminal has a settable command character, such as the \\s-1TEKTRONIX\\s+1 4025,\nthis can be indicated with\n.BR cmdch .\nA prototype command character is chosen which is used in all capabilities.\nThis character is given in the\n.B cmdch\ncapability to identify it.\nThe following convention is supported on some UNIX systems:\nThe environment is to be searched for a\n.B CC\nvariable, and if found, all\noccurrences of the prototype character are replaced with the character\nin the environment variable.\n.PP\nTerminal descriptions that do not represent a specific kind of known\nterminal, such as\n.IR switch ,\n.IR dialup ,\n.IR patch ,\nand\n.IR network ,\nshould include the\n.B gn\n(generic) capability so that programs can complain that they do not know\nhow to talk to the terminal.\n(This capability does not apply to\n.I virtual\nterminal descriptions for which the escape sequences are known.)\n.PP\nIf the terminal has a \\*(``meta key\\*('' which acts as a shift key,\nsetting the 8th bit of any character transmitted, this fact can\nbe indicated with\n.BR km .\nOtherwise, software will assume that the 8th bit is parity and it\nwill usually be cleared.\nIf strings exist to turn this \\*(``meta mode\\*('' on and off, they\ncan be given as\n.B smm\nand\n.BR rmm .\n.PP\nIf the terminal has more lines of memory than will fit on the screen\nat once, the number of lines of memory can be indicated with\n.BR lm .\nA value of\n.BR lm #0\nindicates that the number of lines is not fixed,\nbut that there is still more memory than fits on the screen.\n.PP\nIf the terminal is one of those supported by the \\s-1UNIX\\s+1 virtual\nterminal protocol, the terminal number can be given as\n.BR vt .\n.PP\nMedia copy\nstrings which control an auxiliary printer connected to the terminal\ncan be given as\n.BR mc0 :\nprint the contents of the screen,\n.BR mc4 :\nturn off the printer, and\n.BR mc5 :\nturn on the printer.\nWhen the printer is on, all text sent to the terminal will be sent\nto the printer.\nIt is undefined whether the text is also displayed on the terminal screen\nwhen the printer is on.\nA variation\n.B mc5p\ntakes one parameter, and leaves the printer on for as many characters\nas the value of the parameter, then turns the printer off.\nThe parameter should not exceed 255.\nAll text, including\n.BR mc4 ,\nis transparently passed to the printer while an\n.B mc5p\nis in effect.\n.PP\n.SS Glitches and Braindamage\n.PP\nHazeltine terminals, which do not allow \\*(``~\\*('' characters to be displayed should\nindicate \\fBhz\\fP.\n.PP\nTerminals which ignore a line-feed immediately after an \\fBam\\fP wrap,\nsuch as the Concept and vt100,\nshould indicate \\fBxenl\\fP.\n.PP\nIf\n.B el\nis required to get rid of standout\n(instead of merely writing normal text on top of it),\n\\fBxhp\\fP should be given.\n.PP\nTeleray terminals, where tabs turn all characters moved over to blanks,\nshould indicate \\fBxt\\fP (destructive tabs).\nNote: the variable indicating this is now \\*(``dest_tabs_magic_smso\\*(''; in\nolder versions, it was teleray_glitch.\nThis glitch is also taken to mean that it is not possible to position\nthe cursor on top of a \\*(``magic cookie\\*('',\nthat to erase standout mode it is instead necessary to use\ndelete and insert line.\nThe ncurses implementation ignores this glitch.\n.PP\nThe Beehive Superbee, which is unable to correctly transmit the escape\nor control/C characters, has\n.BR xsb ,\nindicating that the f1 key is used for escape and f2 for control/C.\n(Only certain Superbees have this problem, depending on the ROM.)\nNote that in older terminfo versions, this capability was called\n\\*(``beehive_glitch\\*(''; it is now \\*(``no_esc_ctl_c\\*(''.\n.PP\nOther specific terminal problems may be corrected by adding more\ncapabilities of the form \\fBx\\fP\\fIx\\fP.\n.PP\n.SS Pitfalls of Long Entries\n.PP\nLong terminfo entries are unlikely to be a problem; to date, no entry has even\napproached terminfo's 4096-byte string-table maximum.\nUnfortunately, the termcap\ntranslations are much more strictly limited (to 1023 bytes), thus termcap translations\nof long terminfo entries can cause problems.\n.PP\nThe man pages for 4.3BSD and older versions of \\fBtgetent\\fP instruct the user to\nallocate a 1024-byte buffer for the termcap entry.\nThe entry gets null-terminated by\nthe termcap library, so that makes the maximum safe length for a termcap entry\n1k\\-1 (1023) bytes.\nDepending on what the application and the termcap library\nbeing used does, and where in the termcap file the terminal type that \\fBtgetent\\fP\nis searching for is, several bad things can happen.\n.PP\nSome termcap libraries print a warning message or exit if they find an\nentry that's longer than 1023 bytes; others do not; others truncate the\nentries to 1023 bytes.\nSome application programs allocate more than\nthe recommended 1K for the termcap entry; others do not.\n.PP\nEach termcap entry has two important sizes associated with it: before\n\\*(``tc\\*('' expansion, and after \\*(``tc\\*('' expansion.\n\\*(``tc\\*('' is the capability that\ntacks on another termcap entry to the end of the current one, to add\non its capabilities.\nIf a termcap entry does not use the \\*(``tc\\*(''\ncapability, then of course the two lengths are the same.\n.PP\nThe \\*(``before tc expansion\\*('' length is the most important one, because it\naffects more than just users of that particular terminal.\nThis is the\nlength of the entry as it exists in /etc/termcap, minus the\nbackslash-newline pairs, which \\fBtgetent\\fP strips out while reading it.\nSome termcap libraries strip off the final newline, too (GNU termcap does not).\nNow suppose:\n.bP\na termcap entry before expansion is more than 1023 bytes long,\n.bP\nand the application has only allocated a 1k buffer,\n.bP\nand the termcap library (like the one in BSD/OS 1.1 and GNU) reads\nthe whole entry into the buffer, no matter what its length, to see\nif it is the entry it wants,\n.bP\nand \\fBtgetent\\fP is searching for a terminal type that either is the\nlong entry, appears in the termcap file after the long entry, or\ndoes not appear in the file at all (so that \\fBtgetent\\fP has to search\nthe whole termcap file).\n.PP\nThen \\fBtgetent\\fP will overwrite memory, perhaps its stack, and probably core dump\nthe program.\nPrograms like telnet are particularly vulnerable; modern telnets\npass along values like the terminal type automatically.\nThe results are almost\nas undesirable with a termcap library, like SunOS 4.1.3 and Ultrix 4.4, that\nprints warning messages when it reads an overly long termcap entry.\nIf a\ntermcap library truncates long entries, like OSF/1 3.0, it is immune to dying\nhere but will return incorrect data for the terminal.\n.PP\nThe \\*(``after tc expansion\\*('' length will have a similar effect to the\nabove, but only for people who actually set TERM to that terminal\ntype, since \\fBtgetent\\fP only does \\*(``tc\\*('' expansion once it is found the\nterminal type it was looking for, not while searching.\n.PP\nIn summary, a termcap entry that is longer than 1023 bytes can cause,\non various combinations of termcap libraries and applications, a core\ndump, warnings, or incorrect operation.\nIf it is too long even before\n\\*(``tc\\*('' expansion, it will have this effect even for users of some other\nterminal types and users whose TERM variable does not have a termcap\nentry.\n.PP\nWhen in \\-C (translate to termcap) mode, the \\fBncurses\\fP implementation of\n\\fB@TIC@\\fP(1M) issues warning messages when the pre-tc length of a termcap\ntranslation is too long.\nThe \\-c (check) option also checks resolved (after tc\nexpansion) lengths.\n.SS Binary Compatibility\nIt is not wise to count on portability of binary terminfo entries between\ncommercial UNIX versions.\nThe problem is that there are at least two versions\nof terminfo (under HP\\-UX and AIX) which diverged from System V terminfo after\nSVr1, and have added extension capabilities to the string table that (in the\nbinary format) collide with System V and XSI Curses extensions.\n.SH EXTENSIONS\n.PP\nSearching for terminal descriptions in\n\\fB$HOME/.terminfo\\fP and TERMINFO_DIRS\nis not supported by older implementations.\n.PP\nSome SVr4 \\fBcurses\\fP implementations, and all previous to SVr4, do not\ninterpret the %A and %O operators in parameter strings.\n.PP\nSVr4/XPG4 do not specify whether \\fBmsgr\\fP licenses movement while in\nan alternate-character-set mode (such modes may, among other things, map\nCR and NL to characters that do not trigger local motions).\nThe \\fBncurses\\fP implementation ignores \\fBmsgr\\fP in \\fBALTCHARSET\\fP\nmode.\nThis raises the possibility that an XPG4\nimplementation making the opposite interpretation may need terminfo\nentries made for \\fBncurses\\fP to have \\fBmsgr\\fP turned off.\n.PP\nThe \\fBncurses\\fP library handles insert-character and insert-character modes\nin a slightly non-standard way to get better update efficiency.\nSee\nthe \\fBInsert/Delete Character\\fP subsection above.\n.PP\nThe parameter substitutions for \\fBset_clock\\fP and \\fBdisplay_clock\\fP are\nnot documented in SVr4 or the XSI Curses standard.\nThey are deduced from the\ndocumentation for the AT&T 505 terminal.\n.PP\nBe careful assigning the \\fBkmous\\fP capability.\nThe \\fBncurses\\fP library wants to interpret it as \\fBKEY_MOUSE\\fP,\nfor use by terminals and emulators like xterm\nthat can return mouse-tracking information in the keyboard-input stream.\n.PP\nX/Open Curses does not mention italics.\nPortable applications must assume that numeric capabilities are\nsigned 16-bit values.\nThis includes the \\fIno_color_video\\fP (ncv) capability.\nThe 32768 mask value used for italics with ncv can be confused with\nan absent or cancelled ncv.\nIf italics should work with colors,\nthen the ncv value must be specified, even if it is zero.\n.PP\nDifferent commercial ports of terminfo and curses support different subsets of\nthe XSI Curses standard and (in some cases) different extension sets.\nHere\nis a summary, accurate as of October 1995:\n.bP\n\\fBSVR4, Solaris, ncurses\\fP \\-\\-\nThese support all SVr4 capabilities.\n.bP\n\\fBSGI\\fP \\-\\-\nSupports the SVr4 set, adds one undocumented extended string\ncapability (\\fBset_pglen\\fP).\n.bP\n\\fBSVr1, Ultrix\\fP \\-\\-\nThese support a restricted subset of terminfo capabilities.\nThe booleans end with \\fBxon_xoff\\fP;\nthe numerics with \\fBwidth_status_line\\fP;\nand the strings with \\fBprtr_non\\fP.\n.bP\n\\fBHP/UX\\fP \\-\\-\nSupports the SVr1 subset, plus the SVr[234] numerics \\fBnum_labels\\fP,\n\\fBlabel_height\\fP, \\fBlabel_width\\fP, plus function keys 11 through 63, plus\n\\fBplab_norm\\fP, \\fBlabel_on\\fP, and \\fBlabel_off\\fP, plus some incompatible\nextensions in the string table.\n.bP\n\\fBAIX\\fP \\-\\-\nSupports the SVr1 subset, plus function keys 11 through 63, plus a number\nof incompatible string table extensions.\n.bP\n\\fBOSF\\fP \\-\\-\nSupports both the SVr4 set and the AIX extensions.\n.SH FILES\n.TP 25\n\\*d/?/*\nfiles containing terminal descriptions\n.SH SEE ALSO\n\\fB@INFOCMP@\\fP(1M),\n\\fB@TABS@\\fP(1),\n\\fB@TIC@\\fP(1M),\n\\fBcurses\\fP(3X),\n\\fBcurs_color\\fP(3X),\n\\fBcurs_variables\\fP(3X),\n\\fBprintf\\fP(3),\n\\fBterm_variables\\fP(3X).\n\\fBterm\\fP(\\*n).\n\\fBuser_caps\\fP(5).\n.SH AUTHORS\nZeyd M. Ben-Halim, Eric S. Raymond, Thomas E. Dickey.\nBased on \\fIpcurses\\fP by Pavel Curtis.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}