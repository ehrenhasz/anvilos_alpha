{
  "module_name": "curs_getch.3x",
  "hash_id": "ecc20b81d6ad8c9a4f0de683027cdc5ddbe3061ef211ab05f95eeb5b9c1791af",
  "original_prompt": "Ingested from ncurses-6.4/man/curs_getch.3x",
  "human_readable_source": "'\\\" t\n.\\\"***************************************************************************\n.\\\" Copyright 2018-2021,2022 Thomas E. Dickey                                *\n.\\\" Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *\n.\\\"                                                                          *\n.\\\" Permission is hereby granted, free of charge, to any person obtaining a  *\n.\\\" copy of this software and associated documentation files (the            *\n.\\\" \"Software\"), to deal in the Software without restriction, including      *\n.\\\" without limitation the rights to use, copy, modify, merge, publish,      *\n.\\\" distribute, distribute with modifications, sublicense, and/or sell       *\n.\\\" copies of the Software, and to permit persons to whom the Software is    *\n.\\\" furnished to do so, subject to the following conditions:                 *\n.\\\"                                                                          *\n.\\\" The above copyright notice and this permission notice shall be included  *\n.\\\" in all copies or substantial portions of the Software.                   *\n.\\\"                                                                          *\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n.\\\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n.\\\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n.\\\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n.\\\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n.\\\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n.\\\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n.\\\"                                                                          *\n.\\\" Except as contained in this notice, the name(s) of the above copyright   *\n.\\\" holders shall not be used in advertising or otherwise to promote the     *\n.\\\" sale, use or other dealings in this Software without prior written       *\n.\\\" authorization.                                                           *\n.\\\"***************************************************************************\n.\\\"\n.\\\" $Id: curs_getch.3x,v 1.63 2022/02/12 20:07:45 tom Exp $\n.TH curs_getch 3X \"\"\n.na\n.hy 0\n.ie \\n(.g .ds `` \\(lq\n.el       .ds `` ``\n.ie \\n(.g .ds '' \\(rq\n.el       .ds '' ''\n.de bP\n.ie n  .IP \\(bu 4\n.el    .IP \\(bu 2\n..\n.SH NAME\n\\fBgetch\\fP,\n\\fBwgetch\\fP,\n\\fBmvgetch\\fP,\n\\fBmvwgetch\\fP,\n\\fBungetch\\fP,\n\\fBhas_key\\fP \\- get (or push back) characters from \\fBcurses\\fP terminal keyboard\n.ad\n.hy\n.SH SYNOPSIS\n.B #include <curses.h>\n.PP\n.B int getch(void);\n.br\n.B int wgetch(WINDOW *\\fIwin\\fB);\n.sp\n.B int mvgetch(int \\fIy\\fB, int \\fIx\\fB);\n.br\n.B int mvwgetch(WINDOW *\\fIwin\\fB, int \\fIy\\fB, int \\fIx\\fB);\n.sp\n.B int ungetch(int \\fIch\\fB);\n.sp\n/* extension */\n.br\n.B int has_key(int \\fIch\\fB);\n.br\n.SH DESCRIPTION\n.SS Reading characters\nThe \\fBgetch\\fP, \\fBwgetch\\fP, \\fBmvgetch\\fP and \\fBmvwgetch\\fP, routines read\na character from the window.\nIn no-delay mode, if no input is waiting, the value \\fBERR\\fP is returned.\nIn delay mode, the program waits until the system\npasses text through to the program.\nDepending on the setting of \\fBcbreak\\fP,\nthis is after one character (cbreak mode),\nor after the first newline (nocbreak mode).\nIn half-delay mode,\nthe program waits until a character is typed or the\nspecified timeout has been reached.\n.PP\nIf \\fBecho\\fP is enabled, and the window is not a pad,\nthen the character will also be echoed into the\ndesignated window according to the following rules:\n.bP\nIf the character is the current erase character, left arrow, or backspace,\nthe cursor is moved one space to the left and that screen position is erased\nas if \\fBdelch\\fP had been called.\n.bP\nIf the character value is any other \\fBKEY_\\fP define, the user is alerted\nwith a \\fBbeep\\fP call.\n.bP\nIf the character is a carriage-return,\nand if \\fBnl\\fP is enabled,\nit is translated to a line-feed after echoing.\n.bP\nOtherwise the character is simply output to the screen.\n.PP\nIf the window is not a pad, and it has been moved or modified since the last\ncall to \\fBwrefresh\\fP, \\fBwrefresh\\fP will be called before another character\nis read.\n.SS Keypad mode\n.PP\nIf \\fBkeypad\\fP is \\fBTRUE\\fP, and a function key is pressed, the token for\nthat function key is returned instead of the raw characters:\n.bP\nThe predefined function\nkeys are listed in \\fB<curses.h>\\fP as macros with values outside the range\nof 8-bit characters.\nTheir names begin with \\fBKEY_\\fP.\n.bP\nOther (user-defined) function keys which may be defined\nusing \\fBdefine_key\\fP(3X)\nhave no names, but also are expected to have values outside the range of\n8-bit characters.\n.PP\nThus, a variable\nintended to hold the return value of a function key must be of short size or\nlarger.\n.PP\nWhen a character that could be the beginning of a function key is received\n(which, on modern terminals, means an escape character),\n\\fBcurses\\fP sets a timer.\nIf the remainder of the sequence does not come in within the designated\ntime, the character is passed through;\notherwise, the function key value is returned.\nFor this reason, many terminals experience a delay between the time\na user presses the escape key and the escape is returned to the program.\n.PP\nIn \\fBncurses\\fP, the timer normally expires after\nthe value in \\fBESCDELAY\\fP (see \\fBcurs_variables\\fP(3X)).\nIf \\fBnotimeout\\fP is \\fBTRUE\\fP, the timer does not expire;\nit is an infinite (or very large) value.\nBecause function keys usually begin with an escape character,\nthe terminal may appear to hang in notimeout mode after pressing the escape key\nuntil another key is pressed.\n.SS Ungetting characters\n.PP\nThe \\fBungetch\\fP routine places \\fIch\\fP back onto the input queue to be\nreturned by the next call to \\fBwgetch\\fP.\nThere is just one input queue for all windows.\n.PP\n.SS Predefined key-codes\nThe following special keys are defined in \\fB<curses.h>\\fP.\n.bP\nExcept for the special case \\fBKEY_RESIZE\\fP,\nit is necessary to enable \\fBkeypad\\fP for \\fBgetch\\fP to return these codes.\n.bP\nNot all of these are necessarily supported on any particular terminal.\n.bP\nThe naming convention may seem obscure, with some apparent\nmisspellings (such as \\*(``RSUME\\*('' for \\*(``resume\\*('').\nThe names correspond to the long terminfo capability names for the keys,\nand were defined long ago, in the 1980s.\n.PP\n.TS\ncenter tab(/) ;\nl l .\n\\fBName\\fP/\\fBKey\\fP \\fBname\\fP\n_\nKEY_BREAK/Break key\nKEY_DOWN/The four arrow keys ...\nKEY_UP\nKEY_LEFT\nKEY_RIGHT\nKEY_HOME/Home key (upward+left arrow)\nKEY_BACKSPACE/Backspace\nKEY_F0/T{\nFunction keys; space for 64 keys is reserved.\nT}\nKEY_F(\\fIn\\fP)/T{\nFor 0 \\(<= \\fIn\\fP \\(<= 63\nT}\nKEY_DL/Delete line\nKEY_IL/Insert line\nKEY_DC/Delete character\nKEY_IC/Insert char or enter insert mode\nKEY_EIC/Exit insert char mode\nKEY_CLEAR/Clear screen\nKEY_EOS/Clear to end of screen\nKEY_EOL/Clear to end of line\nKEY_SF/Scroll 1 line forward\nKEY_SR/Scroll 1 line backward (reverse)\nKEY_NPAGE/Next page\nKEY_PPAGE/Previous page\nKEY_STAB/Set tab\nKEY_CTAB/Clear tab\nKEY_CATAB/Clear all tabs\nKEY_ENTER/Enter or send\nKEY_SRESET/Soft (partial) reset\nKEY_RESET/Reset or hard reset\nKEY_PRINT/Print or copy\nKEY_LL/Home down or bottom (lower left)\nKEY_A1/Upper left of keypad\nKEY_A3/Upper right of keypad\nKEY_B2/Center of keypad\nKEY_C1/Lower left of keypad\nKEY_C3/Lower right of keypad\nKEY_BTAB/Back tab key\nKEY_BEG/Beg(inning) key\nKEY_CANCEL/Cancel key\nKEY_CLOSE/Close key\nKEY_COMMAND/Cmd (command) key\nKEY_COPY/Copy key\nKEY_CREATE/Create key\nKEY_END/End key\nKEY_EXIT/Exit key\nKEY_FIND/Find key\nKEY_HELP/Help key\nKEY_MARK/Mark key\nKEY_MESSAGE/Message key\nKEY_MOUSE/Mouse event occurred\nKEY_MOVE/Move key\nKEY_NEXT/Next object key\nKEY_OPEN/Open key\nKEY_OPTIONS/Options key\nKEY_PREVIOUS/Previous object key\nKEY_REDO/Redo key\nKEY_REFERENCE/Ref(erence) key\nKEY_REFRESH/Refresh key\nKEY_REPLACE/Replace key\nKEY_RESIZE/Screen resized\nKEY_RESTART/Restart key\nKEY_RESUME/Resume key\nKEY_SAVE/Save key\nKEY_SBEG/Shifted beginning key\nKEY_SCANCEL/Shifted cancel key\nKEY_SCOMMAND/Shifted command key\nKEY_SCOPY/Shifted copy key\nKEY_SCREATE/Shifted create key\nKEY_SDC/Shifted delete char key\nKEY_SDL/Shifted delete line key\nKEY_SELECT/Select key\nKEY_SEND/Shifted end key\nKEY_SEOL/Shifted clear line key\nKEY_SEXIT/Shifted exit key\nKEY_SFIND/Shifted find key\nKEY_SHELP/Shifted help key\nKEY_SHOME/Shifted home key\nKEY_SIC/Shifted insert key\nKEY_SLEFT/Shifted left arrow key\nKEY_SMESSAGE/Shifted message key\nKEY_SMOVE/Shifted move key\nKEY_SNEXT/Shifted next key\nKEY_SOPTIONS/Shifted options key\nKEY_SPREVIOUS/Shifted prev key\nKEY_SPRINT/Shifted print key\nKEY_SREDO/Shifted redo key\nKEY_SREPLACE/Shifted replace key\nKEY_SRIGHT/Shifted right arrow key\nKEY_SRSUME/Shifted resume key\nKEY_SSAVE/Shifted save key\nKEY_SSUSPEND/Shifted suspend key\nKEY_SUNDO/Shifted undo key\nKEY_SUSPEND/Suspend key\nKEY_UNDO/Undo key\n.TE\n.PP\nKeypad is arranged like this:\n.br\n.TS\ncenter allbox tab(/) ;\nc c c .\n\\fBA1\\fP/\\fBup\\fP/\\fBA3\\fP\n\\fBleft\\fP/\\fBB2\\fP/\\fBright\\fP\n\\fBC1\\fP/\\fBdown\\fP/\\fBC3\\fP\n.TE\n.sp\nA few of these predefined values do \\fInot\\fP correspond to a real key:\n.bP\n.B KEY_RESIZE\nis returned when the \\fBSIGWINCH\\fP signal has been detected\n(see \\fBinitscr\\fP(3X) and \\fBresizeterm\\fP(3X)).\nThis code is returned whether or not \\fBkeypad\\fP has been enabled.\n.bP\n.B KEY_MOUSE\nis returned for mouse-events (see \\fBcurs_mouse\\fP(3X)).\nThis code relies upon whether or not \\fBkeypad\\fP(3X) has been enabled,\nbecause (e.g., with \\fBxterm\\fP(1) mouse prototocol) ncurses must\nread escape sequences,\njust like a function key.\n.SS Testing key-codes\n.PP\nThe \\fBhas_key\\fP routine takes a key-code value from the above list, and\nreturns \\fBTRUE\\fP or \\fBFALSE\\fP according to whether\nthe current terminal type recognizes a key with that value.\n.PP\nThe library also supports these extensions:\n.RS 3\n.TP 5\n.B define_key\ndefines a key-code for a given string (see \\fBdefine_key\\fP(3X)).\n.TP 5\n.B key_defined\nchecks if there is a key-code defined for a given\nstring (see \\fBkey_defined\\fP(3X)).\n.RE\n.PP\n.SH RETURN VALUE\nAll routines return the integer \\fBERR\\fP upon failure and an integer value\nother than \\fBERR\\fP (\\fBOK\\fP in the case of \\fBungetch\\fP) upon successful\ncompletion.\n.RS 3\n.TP 5\n\\fBungetch\\fP\nreturns \\fBERR\\fP\nif there is no more room in the FIFO.\n.TP\n\\fBwgetch\\fP\nreturns \\fBERR\\fP\nif the window pointer is null, or\nif its timeout expires without having any data, or\nif the execution was interrupted by a signal (\\fBerrno\\fP will be set to\n\\fBEINTR\\fP).\n.RE\n.PP\nFunctions with a \\*(``mv\\*('' prefix first perform a cursor movement using\n\\fBwmove\\fP, and return an error if the position is outside the window,\nor if the window pointer is null.\n.SH NOTES\nUse of the escape key by a programmer for a single character function is\ndiscouraged, as it will cause a delay of up to one second while the\nkeypad code looks for a following function-key sequence.\n.PP\nSome keys may be the same as commonly used control\nkeys, e.g.,\n\\fBKEY_ENTER\\fP versus control/M,\n\\fBKEY_BACKSPACE\\fP versus control/H.\nSome curses implementations may differ according to whether they\ntreat these control keys specially (and ignore the terminfo), or\nuse the terminfo definitions.\n\\fBNcurses\\fP uses the terminfo definition.\nIf it says that \\fBKEY_ENTER\\fP is control/M,\n\\fBgetch\\fP will return \\fBKEY_ENTER\\fP\nwhen you press control/M.\n.PP\nGenerally, \\fBKEY_ENTER\\fP denotes the character(s) sent by the \\fIEnter\\fP\nkey on the numeric keypad:\n.bP\nthe terminal description lists the most useful keys,\n.bP\nthe \\fIEnter\\fP key on the regular keyboard is already handled by\nthe standard ASCII characters for carriage-return and line-feed,\n.bP\ndepending on whether \\fBnl\\fP or \\fBnonl\\fP was called,\npressing \\*(``Enter\\*('' on the regular keyboard\nmay return either a carriage-return or line-feed, and finally\n.bP\n\\*(``Enter or send\\*('' is the standard description for this key.\n.PP\nWhen using \\fBgetch\\fP, \\fBwgetch\\fP, \\fBmvgetch\\fP, or\n\\fBmvwgetch\\fP, nocbreak mode (\\fBnocbreak\\fP) and echo mode\n(\\fBecho\\fP) should not be used at the same time.\nDepending on the\nstate of the tty driver when each character is typed, the program may\nproduce undesirable results.\n.PP\nNote that \\fBgetch\\fP, \\fBmvgetch\\fP, and \\fBmvwgetch\\fP may be macros.\n.PP\nHistorically, the set of keypad macros was largely defined by the extremely\nfunction-key-rich keyboard of the AT&T 7300, aka 3B1, aka Safari 4.\nModern\npersonal computers usually have only a small subset of these.\nIBM PC-style\nconsoles typically support little more than \\fBKEY_UP\\fP, \\fBKEY_DOWN\\fP,\n\\fBKEY_LEFT\\fP, \\fBKEY_RIGHT\\fP, \\fBKEY_HOME\\fP, \\fBKEY_END\\fP,\n\\fBKEY_NPAGE\\fP, \\fBKEY_PPAGE\\fP, and function keys 1 through 12.\nThe Ins key\nis usually mapped to \\fBKEY_IC\\fP.\n.SH PORTABILITY\nThe *get* functions are described in the XSI Curses standard, Issue 4.\nThey\nread single-byte characters only.\nThe standard specifies that they return\n\\fBERR\\fP on failure, but specifies no error conditions.\n.PP\nThe echo behavior of these functions on input of \\fBKEY_\\fP or backspace\ncharacters was not specified in the SVr4 documentation.\nThis description is\nadopted from the XSI Curses standard.\n.PP\nThe behavior of \\fBgetch\\fP and friends in the presence of handled signals is\nunspecified in the SVr4 and XSI Curses documentation.\nUnder historical curses\nimplementations, it varied depending on whether the operating system's\nimplementation of handled signal receipt interrupts a \\fBread\\fP(2) call in\nprogress or not, and also (in some implementations) depending on whether an\ninput timeout or non-blocking mode has been set.\n.PP\n\\fBKEY_MOUSE\\fP is mentioned in XSI Curses, along with a few related\nterminfo capabilities, but no higher-level functions use the feature.\nThe implementation in ncurses is an extension.\n.PP\n\\fBKEY_RESIZE\\fP is an extension first implemented for ncurses.\nNetBSD curses later added this extension.\n.PP\nProgrammers concerned about portability should be prepared for either of two\ncases: (a) signal receipt does not interrupt \\fBgetch\\fP; (b) signal receipt\ninterrupts \\fBgetch\\fP and causes it to return \\fBERR\\fP with \\fBerrno\\fP set to\n\\fBEINTR\\fP.\n.PP\nThe \\fBhas_key\\fP function is unique to \\fBncurses\\fP.\nWe recommend that\nany code using it be conditionalized on the \\fBNCURSES_VERSION\\fP feature macro.\n.SH SEE ALSO\n\\fBcurses\\fP(3X),\n\\fBcurs_inopts\\fP(3X),\n\\fBcurs_mouse\\fP(3X),\n\\fBcurs_move\\fP(3X),\n\\fBcurs_outopts\\fP(3X),\n\\fBcurs_refresh\\fP(3X),\n\\fBcurs_variables\\fP(3X),\n\\fBresizeterm\\fP(3X).\n.PP\nComparable functions in the wide-character (ncursesw) library are\ndescribed in\n\\fBcurs_get_wch\\fP(3X).\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}