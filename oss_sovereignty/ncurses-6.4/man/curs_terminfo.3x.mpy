{
  "module_name": "curs_terminfo.3x",
  "hash_id": "e16186f6a958b30f983b84cf49783466a078f1d0c993e7edbd4482f8f3f71525",
  "original_prompt": "Ingested from ncurses-6.4/man/curs_terminfo.3x",
  "human_readable_source": ".\\\"***************************************************************************\n.\\\" Copyright 2018-2022,2022 Thomas E. Dickey                                *\n.\\\" Copyright 1998-2016,2017 Free Software Foundation, Inc.                  *\n.\\\"                                                                          *\n.\\\" Permission is hereby granted, free of charge, to any person obtaining a  *\n.\\\" copy of this software and associated documentation files (the            *\n.\\\" \"Software\"), to deal in the Software without restriction, including      *\n.\\\" without limitation the rights to use, copy, modify, merge, publish,      *\n.\\\" distribute, distribute with modifications, sublicense, and/or sell       *\n.\\\" copies of the Software, and to permit persons to whom the Software is    *\n.\\\" furnished to do so, subject to the following conditions:                 *\n.\\\"                                                                          *\n.\\\" The above copyright notice and this permission notice shall be included  *\n.\\\" in all copies or substantial portions of the Software.                   *\n.\\\"                                                                          *\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *\n.\\\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *\n.\\\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *\n.\\\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *\n.\\\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *\n.\\\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *\n.\\\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *\n.\\\"                                                                          *\n.\\\" Except as contained in this notice, the name(s) of the above copyright   *\n.\\\" holders shall not be used in advertising or otherwise to promote the     *\n.\\\" sale, use or other dealings in this Software without prior written       *\n.\\\" authorization.                                                           *\n.\\\"***************************************************************************\n.\\\"\n.\\\" $Id: curs_terminfo.3x,v 1.82 2022/06/04 22:47:05 tom Exp $\n.TH curs_terminfo 3X \"\"\n.ie \\n(.g .ds `` \\(lq\n.el       .ds `` ``\n.ie \\n(.g .ds '' \\(rq\n.el       .ds '' ''\n.de bP\n.ie n  .IP \\(bu 4\n.el    .IP \\(bu 2\n..\n.ds n 5\n.na\n.hy 0\n.SH NAME\n\\fBdel_curterm\\fP,\n\\fBmvcur\\fP,\n\\fBputp\\fP,\n\\fBrestartterm\\fP,\n\\fBset_curterm\\fP,\n\\fBsetupterm\\fP,\n\\fBtigetflag\\fP,\n\\fBtigetnum\\fP,\n\\fBtigetstr\\fP,\n\\fBtiparm\\fP,\n\\fBtparm\\fP,\n\\fBtputs\\fP,\n\\fBvid_attr\\fP,\n\\fBvid_puts\\fP,\n\\fBvidattr\\fP,\n\\fBvidputs\\fP \\- \\fBcurses\\fP interfaces to terminfo database\n.ad\n.hy\n.SH SYNOPSIS\n.nf\n\\fB#include <curses.h>\\fP\n\\fB#include <term.h>\\fP\n.sp\n\\fBTERMINAL *cur_term;\\fP\n.sp\n\\fBconst char * const boolnames[];\\fP\n\\fBconst char * const boolcodes[];\\fP\n\\fBconst char * const boolfnames[];\\fP\n\\fBconst char * const numnames[];\\fP\n\\fBconst char * const numcodes[];\\fP\n\\fBconst char * const numfnames[];\\fP\n\\fBconst char * const strnames[];\\fP\n\\fBconst char * const strcodes[];\\fP\n\\fBconst char * const strfnames[];\\fP\n.sp\n\\fBint setupterm(const char *\\fIterm\\fB, int \\fIfiledes\\fB, int *\\fIerrret\\fB);\\fR\n.br\n\\fBTERMINAL *set_curterm(TERMINAL *\\fInterm\\fB);\\fR\n.br\n\\fBint del_curterm(TERMINAL *\\fIoterm\\fB);\\fR\n.br\n\\fBint restartterm(const char *\\fIterm\\fB, int \\fIfiledes\\fB, int *\\fIerrret\\fB);\\fR\n.sp\n\\fBchar *tparm(const char *\\fIstr\\fB, ...);\\fR\n.br\n\\fBint tputs(const char *\\fIstr\\fB, int \\fIaffcnt\\fB, int (*\\fIputc\\fB)(int));\\fR\n.br\n\\fBint putp(const char *\\fIstr\\fB);\\fR\n.sp\n\\fBint vidputs(chtype \\fIattrs\\fB, int (*\\fIputc\\fB)(int));\\fR\n.br\n\\fBint vidattr(chtype \\fIattrs\\fB);\\fR\n.br\n\\fBint vid_puts(attr_t \\fIattrs\\fB, short \\fIpair\\fB, void *\\fIopts\\fB, int (*\\fIputc\\fB)(int));\\fR\n.br\n\\fBint vid_attr(attr_t \\fIattrs\\fB, short \\fIpair\\fB, void *\\fIopts\\fB);\\fR\n.sp\n\\fBint mvcur(int \\fIoldrow\\fB, int \\fIoldcol\\fB, int \\fInewrow\\fR, int \\fInewcol\\fB);\\fR\n.sp\n\\fBint tigetflag(const char *\\fIcapname\\fB);\\fR\n.br\n\\fBint tigetnum(const char *\\fIcapname\\fB);\\fR\n.br\n\\fBchar *tigetstr(const char *\\fIcapname\\fB);\\fR\n.sp\n\\fBchar *tiparm(const char *\\fIstr\\fB, ...);\\fR\n.br\n.fi\n.SH DESCRIPTION\nThese low-level routines must be called by programs that have to deal\ndirectly with the \\fBterminfo\\fP database to handle certain terminal\ncapabilities, such as programming function keys.\nFor all other\nfunctionality, \\fBcurses\\fP routines are more suitable and their use is\nrecommended.\n.PP\nNone of these functions use (or are aware of) multibyte character strings\nsuch as UTF-8:\n.bP\ncapability names use the POSIX portable character set\n.bP\ncapability string values have no associated encoding;\nthey are strings of 8-bit characters.\n.SS Initialization\n.PP\nInitially, \\fBsetupterm\\fP should be called.\nThe high-level curses functions \\fBinitscr\\fP and\n\\fBnewterm\\fP call \\fBsetupterm\\fP to initialize the\nlow-level set of terminal-dependent variables\n[listed in \\fBterminfo\\fP(\\*n)].\n.PP\nApplications can use the\nterminal capabilities either directly (via header definitions),\nor by special functions.\nThe header files \\fBcurses.h\\fP and \\fBterm.h\\fP should be included (in this\norder) to get the definitions for these strings, numbers, and flags.\n.PP\nThe \\fBterminfo\\fP variables\n\\fBlines\\fP and \\fBcolumns\\fP are initialized by \\fBsetupterm\\fP as\nfollows:\n.bP\nIf \\fBuse_env(FALSE)\\fP has been called, values for\n\\fBlines\\fP and \\fBcolumns\\fP specified in \\fBterminfo\\fP are used.\n.bP\nOtherwise, if the environment variables \\fBLINES\\fP and \\fBCOLUMNS\\fP\nexist, their values are used.\nIf these environment variables do not\nexist and the program is running in a window, the current window size\nis used.\nOtherwise, if the environment variables do not exist, the\nvalues for \\fBlines\\fP and \\fBcolumns\\fP specified in the\n\\fBterminfo\\fP database are used.\n.PP\nParameterized strings should be passed through \\fBtparm\\fP to instantiate them.\nAll \\fBterminfo\\fP strings\n(including the output of \\fBtparm\\fP)\nshould be printed\nwith \\fBtputs\\fP or \\fBputp\\fP.\nCall \\fBreset_shell_mode\\fP to restore the\ntty modes before exiting [see \\fBcurs_kernel\\fP(3X)].\n.PP\nPrograms which use\ncursor addressing should\n.bP\noutput \\fBenter_ca_mode\\fP upon startup and\n.bP\noutput \\fBexit_ca_mode\\fP before exiting.\n.PP\nPrograms which execute shell subprocesses should\n.bP\ncall \\fBreset_shell_mode\\fP and\noutput \\fBexit_ca_mode\\fP before the shell\nis called and\n.bP\noutput \\fBenter_ca_mode\\fP and\ncall \\fBreset_prog_mode\\fP after returning from the shell.\n.PP\nThe \\fBsetupterm\\fP routine reads in the \\fBterminfo\\fP database,\ninitializing the \\fBterminfo\\fP structures, but does not set up the\noutput virtualization structures used by \\fBcurses\\fP.\nThese are its parameters:\n.RS 3\n.TP 5\n\\fIterm\\fP\nis the terminal type, a character string.\nIf \\fIterm\\fP is null, the environment variable \\fBTERM\\fP is used.\n.TP 5\n\\fIfiledes\\fP\nis the file descriptor used for all output.\n.TP 5\n\\fIerrret\\fP\npoints to an optional location where an error status can be returned to\nthe caller.\nIf \\fIerrret\\fP is not null,\nthen \\fBsetupterm\\fP returns \\fBOK\\fP or\n\\fBERR\\fP and stores a status value in the integer pointed to by\n\\fIerrret\\fP.\nA return value of \\fBOK\\fP combined with status of \\fB1\\fP in \\fIerrret\\fP\nis normal.\n.IP\nIf \\fBERR\\fP is returned, examine \\fIerrret\\fP:\n.RS\n.TP 5\n.B 1\nmeans that the terminal is hardcopy, cannot be used for curses applications.\n.IP\n\\fBsetupterm\\fP determines if the entry is a hardcopy type by\nchecking the \\fBhc\\fP (\\fBhardcopy\\fP) capability.\n.TP 5\n.B 0\nmeans that the terminal could not be found,\nor that it is a generic type,\nhaving too little information for curses applications to run.\n.IP\n\\fBsetupterm\\fP determines if the entry is a generic type by\nchecking the \\fBgn\\fP (\\fBgeneric\\fP) capability.\n.TP 5\n.B \\-1\nmeans that the \\fBterminfo\\fP database could not be found.\n.RE\n.IP\nIf \\fIerrret\\fP is\nnull, \\fBsetupterm\\fP prints an error message upon finding an error\nand exits.\nThus, the simplest call is:\n.sp\n      \\fBsetupterm((char *)0, 1, (int *)0);\\fP,\n.sp\nwhich uses all the defaults and sends the output to \\fBstdout\\fP.\n.RE\n.\\\" ***************************************************************************\n.SS The Terminal State\n.PP\nThe \\fBsetupterm\\fP routine stores its information about the terminal\nin a \\fBTERMINAL\\fP structure pointed to by the global variable \\fBcur_term\\fP.\nIf it detects an error,\nor decides that the terminal is unsuitable (hardcopy or generic),\nit discards this information,\nmaking it not available to applications.\n.PP\nIf \\fBsetupterm\\fP is called repeatedly for the same terminal type,\nit will reuse the information.\nIt maintains only one copy of a given terminal's capabilities in memory.\nIf it is called for different terminal types,\n\\fBsetupterm\\fP allocates new storage for each set of terminal capabilities.\n.PP\nThe \\fBset_curterm\\fP routine sets \\fBcur_term\\fP to\n\\fInterm\\fP, and makes all of the \\fBterminfo\\fP boolean, numeric, and\nstring variables use the values from \\fInterm\\fP.\nIt returns the old value of \\fBcur_term\\fP.\n.PP\nThe \\fBdel_curterm\\fP routine frees the space pointed to by\n\\fIoterm\\fP and makes it available for further use.\nIf \\fIoterm\\fP is\nthe same as \\fBcur_term\\fP, references to any of the \\fBterminfo\\fP\nboolean, numeric, and string variables thereafter may refer to invalid\nmemory locations until another \\fBsetupterm\\fP has been called.\n.PP\nThe \\fBrestartterm\\fP routine is similar to \\fBsetupterm\\fP and \\fBinitscr\\fP,\nexcept that it is called after restoring memory to a previous state (for\nexample, when reloading a game saved as a core image dump).\n\\fBrestartterm\\fP assumes that the windows and the input and output options\nare the same as when memory was saved,\nbut the terminal type and baud rate may be different.\nAccordingly, \\fBrestartterm\\fP saves various tty state bits,\ncalls \\fBsetupterm\\fP, and then restores the bits.\n.\\\" ***************************************************************************\n.SS Formatting Output\n.PP\nThe \\fBtparm\\fP routine instantiates the string \\fIstr\\fP with\nparameters \\fIpi\\fP.  A pointer is returned to the result of \\fIstr\\fP\nwith the parameters applied.\nApplication developers should keep in mind these quirks of the interface:\n.bP\nAlthough \\fBtparm\\fP's actual parameters may be integers or strings,\nthe prototype expects \\fBlong\\fP (integer) values.\n.bP\nAside from the \\fBset_attributes\\fP (\\fBsgr\\fP) capability,\nmost terminal capabilities require no more than one or two parameters.\n.bP\nPadding information is ignored by \\fBtparm\\fP;\nit is interpreted by \\fBtputs\\fP.\n.bP\nThe capability string is null-terminated.\nUse \\*(``\\\\200\\*('' where an ASCII NUL is needed in the output.\n.PP\n\\fBtiparm\\fP is a newer form of \\fBtparm\\fP which uses \\fI<stdarg.h>\\fP\nrather than a fixed-parameter list.\nIts numeric parameters are integers (int) rather than longs.\n.\\\" ***************************************************************************\n.SS Output Functions\n.PP\nThe \\fBtputs\\fP routine applies padding information\n(i.e., by interpreting marker embedded in the terminfo capability\nsuch as \\*(``$<5>\\*('' as 5 milliseconds)\nto the string\n\\fIstr\\fP and outputs it:\n.bP\nThe \\fIstr\\fP parameter must be a terminfo string\nvariable or the return value from\n\\fBtparm\\fP, \\fBtiparm\\fP, \\fBtgetstr\\fP, or \\fBtgoto\\fP.\n.IP\nThe \\fBtgetstr\\fP and \\fBtgoto\\fP functions are part of the \\fItermcap\\fP\ninterface,\nwhich happens to share this function name with the \\fIterminfo\\fP interface.\n.bP\n\\fIaffcnt\\fP is the number of lines affected, or 1 if\nnot applicable.\n.bP\n\\fIputc\\fP is a \\fBputchar\\fP-like routine to which\nthe characters are passed, one at a time.\n.PP\nThe \\fBputp\\fR routine calls \\fBtputs(\\fIstr\\fB, 1, putchar)\\fR.\nThe output of \\fBputp\\fP always goes to \\fBstdout\\fP, rather than\nthe \\fIfiledes\\fP specified in \\fBsetupterm\\fP.\n.PP\nThe \\fBvidputs\\fP routine displays the string on the terminal in the\nvideo attribute mode \\fIattrs\\fP, which is any combination of the\nattributes listed in \\fBcurses\\fP(3X).\nThe characters are passed to\nthe \\fBputchar\\fP-like routine \\fIputc\\fP.\n.PP\nThe \\fBvidattr\\fP routine is like the \\fBvidputs\\fP routine, except\nthat it outputs through \\fBputchar\\fP.\n.PP\nThe \\fBvid_attr\\fP and \\fBvid_puts\\fP routines correspond\nto vidattr and vidputs, respectively.\nThey use a set of arguments for representing the video attributes plus color,\ni.e.,\n.bP\n\\fIattrs\\fP of type \\fBattr_t\\fP for the attributes and\n.bP\n\\fIpair\\fP of type \\fBshort\\fP for the color-pair number.\n.PP\nThe \\fBvid_attr\\fP and \\fBvid_puts\\fP routines\nare designed to use the attribute constants with the \\fBWA_\\fP prefix.\n.PP\nX/Open Curses reserves the \\fIopts\\fP argument for future use,\nsaying that applications must provide a null pointer for that argument.\nAs an extension,\nthis implementation allows \\fIopts\\fP to be used as a pointer to \\fBint\\fP,\nwhich overrides the \\fIpair\\fP (\\fBshort\\fP) argument.\n.PP\nThe \\fBmvcur\\fP routine provides low-level cursor motion.\nIt takes effect immediately (rather than at the next refresh).\n.PP\nWhile \\fBputp\\fP and \\fBmvcur\\fP are low-level functions which\ndo not use the high-level curses state,\nthey are declared in \\fB<curses.h>\\fP because SystemV did this\n(see \\fIHISTORY\\fP).\n.\\\" ***************************************************************************\n.SS Terminal Capability Functions\n.PP\nThe \\fBtigetflag\\fP, \\fBtigetnum\\fP and \\fBtigetstr\\fP routines return\nthe value of the capability corresponding to the \\fBterminfo\\fP\n\\fIcapname\\fP passed to them, such as \\fBxenl\\fP.\nThe \\fIcapname\\fP for each capability is given in the table column entitled\n\\fIcapname\\fP code in the capabilities section of \\fBterminfo\\fP(\\*n).\n.PP\nThese routines return special values to denote errors.\n.PP\nThe \\fBtigetflag\\fP routine returns\n.TP\n\\fB\\-1\\fP\nif \\fIcapname\\fP is not a boolean capability,\nor\n.TP\n\\fB0\\fP\nif it is canceled or absent from the terminal description.\n.PP\nThe \\fBtigetnum\\fP routine returns\n.TP\n\\fB\\-2\\fP\nif \\fIcapname\\fP is not a numeric capability, or\n.TP\n\\fB\\-1\\fP\nif it is canceled or absent from the terminal description.\n.PP\nThe \\fBtigetstr\\fP routine returns\n.TP\n\\fB(char *)\\-1\\fP\nif \\fIcapname\\fP is not a string capability,\nor\n.TP\n\\fB0\\fP\nif it is canceled or absent from the terminal description.\n.\\\" ***************************************************************************\n.SS Terminal Capability Names\n.PP\nThese null-terminated arrays contain\n.bP\nthe short terminfo names (\\*(``codes\\*(''),\n.bP\nthe \\fBtermcap\\fP names (\\*(``names\\*(''), and\n.bP\nthe long terminfo names (\\*(``fnames\\*('')\n.PP\nfor each of the predefined \\fBterminfo\\fP variables:\n.sp\n.RS\n\\fBconst char *boolnames[]\\fP, \\fB*boolcodes[]\\fP, \\fB*boolfnames[]\\fP\n.br\n\\fBconst char *numnames[]\\fP, \\fB*numcodes[]\\fP, \\fB*numfnames[]\\fP\n.br\n\\fBconst char *strnames[]\\fP, \\fB*strcodes[]\\fP, \\fB*strfnames[]\\fP\n.RE\n.\\\" ***************************************************************************\n.SS Releasing Memory\nEach successful call to \\fBsetupterm\\fP allocates memory to hold the terminal\ndescription.\nAs a side-effect, it sets \\fBcur_term\\fP to point to this memory.\nIf an application calls\n.sp\n\t\\fBdel_curterm(cur_term);\\fP\n.sp\nthe memory will be freed.\n.PP\nThe formatting functions \\fBtparm\\fP and \\fBtiparm\\fP extend the storage\nallocated by \\fBsetupterm\\fP: \n.bP\nthe \\*(``static\\*('' terminfo variables [a-z].\nBefore ncurses 6.3, those were shared by all screens.\nWith ncurses 6.3, those are allocated per screen.\nSee \\fBterminfo\\fP(\\*n) for details.\n.bP\nto improve performance, ncurses 6.3 caches the result of analyzing terminfo\nstrings for their parameter types.\nThat is stored as a binary tree referenced from the \\fBTERMINAL\\fP structure.\n.PP\nThe higher-level \\fBinitscr\\fP and \\fBnewterm\\fP functions use \\fBsetupterm\\fP.\nNormally they do not free this memory, but it is possible to do that using\nthe \\fBdelscreen\\fP(3X) function.\n.\\\" ***************************************************************************\n.SH RETURN VALUE\nRoutines that return an integer return \\fBERR\\fP upon failure and \\fBOK\\fP\n(SVr4 only specifies \\*(``an integer value other than \\fBERR\\fP\\*('')\nupon successful completion,\nunless otherwise noted in the preceding routine descriptions.\n.PP\nRoutines that return pointers always return \\fBNULL\\fP on error.\n.PP\nX/Open defines no error conditions.\nIn this implementation\n.RS 3\n.TP 5\n\\fBdel_curterm\\fP\nreturns an error\nif its terminal parameter is null.\n.TP 5\n\\fBputp\\fP\ncalls \\fBtputs\\fP, returning the same error-codes.\n.TP 5\n\\fBrestartterm\\fP\nreturns an error\nif the associated call to \\fBsetupterm\\fP returns an error.\n.TP 5\n\\fBsetupterm\\fP\nreturns an error\nif it cannot allocate enough memory, or\ncreate the initial windows (stdscr, curscr, newscr).\nOther error conditions are documented above.\n.TP 5\n\\fBtputs\\fP\nreturns an error if the string parameter is null.\nIt does not detect I/O errors:\nX/Open states that \\fBtputs\\fP ignores the return value\nof the output function \\fIputc\\fP.\n.RE\n.\\\" ***************************************************************************\n.SS Compatibility macros\nThis implementation provides a few macros for compatibility with systems\nbefore SVr4 (see \\fIHISTORY\\fP).\nThose include\n\\fBcrmode\\fP,\n\\fBfixterm\\fP,\n\\fBgettmode\\fP,\n\\fBnocrmode\\fP,\n\\fBresetterm\\fP,\n\\fBsaveterm\\fP, and\n\\fBsetterm\\fP.\n.PP\nIn SVr4, those are found in \\fB<curses.h>\\fP,\nbut except for \\fBsetterm\\fP, are likewise macros.\nThe one function, \\fBsetterm\\fP, is mentioned in the manual page.\nThe manual page notes that the \\fBsetterm\\fP routine\nwas replaced by \\fBsetupterm\\fP, stating that the call:\n.sp\n      \\fBsetupterm(\\fIterm\\fB, 1, (int *)0)\\fR\n.sp\nprovides the same functionality as \\fBsetterm(\\fIterm\\fB)\\fR,\nand is not recommended for new programs.\nThis implementation provides each of those symbols\nas macros for BSD compatibility,\n.\\\" ***************************************************************************\n.SH HISTORY\n.PP\nSVr2 introduced the terminfo feature.\nIts programming manual mentioned these low-level functions:\n.TS\nl l\n_ _\nl l.\n\\fBFunction\\fP\t\\fBDescription\\fP\nfixterm\trestore tty to \\*(``in curses\\*('' state\ngettmode\testablish current tty modes\nmvcur\tlow level cursor motion\nputp\tT{\nutility function that uses \\fBtputs\\fP to send characters via \\fBputchar\\fP.\nT}\nresetterm\tset tty modes to \\*(``out of curses\\*('' state\nresetty\treset tty flags to stored value\nsaveterm\tsave current modes as \\*(``in curses\\*('' state\nsavetty\tstore current tty flags\nsetterm\testablish terminal with given type\nsetupterm\testablish terminal with given type\ntparm\tinstantiate a string expression with parameters\ntputs\tapply padding information to a string\nvidattr\tlike \\fBvidputs\\fP, but outputs through \\fBputchar\\fP\nvidputs\tT{\noutput a string to put terminal in a specified video attribute mode\nT}\n.TE\n.PP\nThe programming manual also mentioned\nfunctions provided for termcap compatibility\n(commenting that they \\*(``may go away at a later date\\*(''):\n.TS\nl l\n_ _\nl l.\n\\fBFunction\\fP\t\\fBDescription\\fP\ntgetent\tlook up termcap entry for given \\fIname\\fP\ntgetflag\tget boolean entry for given \\fIid\\fP\ntgetnum\tget numeric entry for given \\fIid\\fP\ntgetstr\tget string entry for given \\fIid\\fP\ntgoto\tapply parameters to given capability\ntputs\tT{\napply padding to capability, calling a function to put characters\nT}\n.TE\n.PP\nEarly terminfo programs obtained capability values from the\n\\fBTERMINAL\\fP structure initialized by \\fBsetupterm\\fP.\n.PP\nSVr3 extended terminfo by adding functions to retrieve capability values\n(like the termcap interface),\nand reusing tgoto and tputs:\n.TS\nl l\n_ _\nl l.\n\\fBFunction\\fP\t\\fBDescription\\fP\ntigetflag\tget boolean entry for given \\fIid\\fP\ntigetnum\tget numeric entry for given \\fIid\\fP\ntigetstr\tget string entry for given \\fIid\\fP\n.TE\n.PP\nSVr3 also replaced several of the SVr2 terminfo functions\nwhich had no counterpart in the termcap interface,\ndocumenting them as obsolete:\n.TS\nl l\n_ _\nl l.\n\\fBFunction\\fP\t\\fBReplaced by\\fP\ncrmode\tcbreak\nfixterm\treset_prog_mode\ngettmode\tN/A\nnocrmode\tnocbreak\nresetterm\treset_shell_mode\nsaveterm\tdef_prog_mode\nsetterm\tsetupterm\n.TE\n.PP\nSVr3 kept the \\fBmvcur\\fP, \\fBvidattr\\fP and \\fBvidputs\\fP functions,\nalong with \\fBputp\\fP, \\fBtparm\\fP and \\fBtputs\\fP.\nThe latter were needed to support padding,\nand handling functions such as \\fBvidattr\\fP\n(which used more than the two parameters supported by \\fBtgoto\\fP).\n.PP\nSVr3 introduced the functions for switching between terminal\ndescriptions, e.g., \\fBset_curterm\\fP.\nSome of that was incremental improvements to the SVr2 library:\n.bP\nThe \\fBTERMINAL\\fP type definition was introduced in SVr3.01,\nfor the \\fBterm\\fP structure provided in SVr2.\n.bP\nThe various global variables such as \\fBboolnames\\fP were mentioned\nin the programming manual at this point,\nthough the variables were provided in SVr2.\n.PP\nSVr4 added the \\fBvid_attr\\fP and \\fBvid_puts\\fP functions.\n.PP\nThere are other low-level functions declared in the curses header files\non Unix systems,\nbut none were documented.\nThe functions marked \\*(``obsolete\\*('' remained in use\nby the Unix \\fBvi\\fP(1) editor.\n.SH PORTABILITY\n.SS Legacy functions\n.PP\nX/Open notes that \\fBvidattr\\fP and \\fBvidputs\\fP may be macros.\n.PP\nThe function \\fBsetterm\\fP is not described by X/Open and must\nbe considered non-portable.\nAll other functions are as described by X/Open.\n.SS Legacy data\n.PP\n\\fBsetupterm\\fP copies the terminal name to the array \\fBttytype\\fP.\nThis is not part of X/Open Curses, but is assumed by some applications.\n.PP\nOther implementions may not declare the capability name arrays.\nSome provide them without declaring them.\nX/Open does not specify them.\n.PP\nExtended terminal capability names, e.g., as defined by \\fB@TIC@\\ \\-x\\fP,\nare not stored in the arrays described here.\n.SS Output buffering\n.PP\nOlder versions of \\fBncurses\\fP assumed that the file descriptor passed to\n\\fBsetupterm\\fP from \\fBinitscr\\fP or \\fBnewterm\\fP uses buffered I/O,\nand would write to the corresponding stream.\nIn addition to the limitation that the terminal was left in block-buffered\nmode on exit (like System V curses),\nit was problematic because \\fBncurses\\fP\ndid not allow a reliable way to cleanup on receiving SIGTSTP.\n.PP\nThe current version (ncurses6)\nuses output buffers managed directly by \\fBncurses\\fP.\nSome of the low-level functions described in this manual page write\nto the standard output.\nThey are not signal-safe.\nThe high-level functions in \\fBncurses\\fP use\nalternate versions of these functions\nusing the more reliable buffering scheme.\n.SS Function prototypes\n.PP\nThe X/Open Curses prototypes are based on the SVr4 curses header declarations,\nwhich were defined at the same time the C language was first standardized in\nthe late 1980s.\n.bP\nX/Open Curses uses \\fBconst\\fP less effectively than a later design might,\nin some cases applying it needlessly to values are already constant,\nand in most cases overlooking parameters which normally would use \\fBconst\\fP.\nUsing constant parameters for functions which do not use \\fBconst\\fP\nmay prevent the program from compiling.\nOn the other hand, \\fIwritable strings\\fP are an obsolescent feature.\n.IP\nAs an extension, this implementation can be configured to change the\nfunction prototypes to use the \\fBconst\\fP keyword.\nThe ncurses ABI 6 enables this feature by default.\n.bP\nX/Open Curses prototypes \\fBtparm\\fP with a fixed number of parameters,\nrather than a variable argument list.\n.IP\nThis implementation uses a variable argument list, but can be\nconfigured to use the fixed-parameter list.\nPortable applications should provide 9 parameters after the format;\nzeroes are fine for this purpose.\n.IP\nIn response to review comments by Thomas E. Dickey,\nX/Open Curses Issue 7 proposed the \\fBtiparm\\fP function in mid-2009.\n.SS Special TERM treatment\n.PP\nIf configured to use the terminal-driver,\ne.g., for the MinGW port,\n.bP\n\\fBsetupterm\\fP interprets a missing/empty TERM variable as the\nspecial value \\*(``unknown\\*(''.\n.bP\n\\fBsetupterm\\fP allows explicit use of the\nthe windows console driver by checking if $TERM is set to\n\\*(``#win32con\\*('' or an abbreviation of that string.\n.SS Other portability issues\n.PP\nIn System V Release 4, \\fBset_curterm\\fP has an \\fBint\\fP return type and\nreturns \\fBOK\\fP or \\fBERR\\fP.  We have chosen to implement the X/Open Curses\nsemantics.\n.PP\nIn System V Release 4, the third argument of \\fBtputs\\fP has the type\n\\fBint (*putc)(char)\\fP.\n.PP\nAt least one implementation of X/Open Curses (Solaris) returns a value\nother than \\fBOK\\fP/\\fBERR\\fP from \\fBtputs\\fP.\nThat returns the length of the string, and does no error-checking.\n.PP\nX/Open notes that after calling \\fBmvcur\\fP, the curses state may not match the\nactual terminal state, and that an application should touch and refresh\nthe window before resuming normal curses calls.\nBoth \\fBncurses\\fP and System V Release 4 curses implement \\fBmvcur\\fP using\nthe SCREEN data allocated in either \\fBinitscr\\fP or \\fBnewterm\\fP.\nSo though it is documented as a terminfo function,\n\\fBmvcur\\fP is really a curses function which is not well specified.\n.PP\nX/Open states that the old location must be given for \\fBmvcur\\fP.\nThis implementation allows the caller to use \\-1's for the old ordinates.\nIn that case, the old location is unknown.\n.SH SEE ALSO\n\\fBcurses\\fP(3X),\n\\fBcurs_initscr\\fP(3X),\n\\fBcurs_kernel\\fP(3X),\n\\fBcurs_memleaks\\fP(3X),\n\\fBcurs_termcap\\fP(3X),\n\\fBcurs_variables\\fP(3X),\n\\fBterm_variables\\fP(3X),\n\\fBputc\\fP(3),\n\\fBterminfo\\fP(\\*n)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}