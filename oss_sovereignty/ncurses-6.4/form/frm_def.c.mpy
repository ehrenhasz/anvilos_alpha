{
  "module_name": "frm_def.c",
  "hash_id": "ab4854b9dde180b112d902f099446ef531cf2c1ddf5b769ebe4f051a18e25e04",
  "original_prompt": "Ingested from ncurses-6.4/form/frm_def.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: frm_def.c,v 1.30 2021/03/27 23:49:58 tom Exp $\")\n\n \nstatic FORM default_form =\n{\n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  -1,\t\t\t\t \n  -1,\t\t\t\t \n  -1,\t\t\t\t \n  ALL_FORM_OPTS,\t\t \n  (WINDOW *)0,\t\t\t \n  (WINDOW *)0,\t\t\t \n  (WINDOW *)0,\t\t\t \n  (FIELD **)0,\t\t\t \n  (FIELD *)0,\t\t\t \n  (_PAGE *) 0,\t\t\t \n  (char *)0,\t\t\t \n  NULL,\t\t\t\t \n  NULL,\t\t\t\t \n  NULL,\t\t\t\t \n  NULL\t\t\t\t \n};\n\nFORM_EXPORT_VAR(FORM *) _nc_Default_Form = &default_form;\n\n \nstatic FIELD *\nInsert_Field_By_Position(FIELD *newfield, FIELD *head)\n{\n  FIELD *current, *newhead;\n\n  assert(newfield);\n\n  if (!head)\n    {\t\t\t\t \n      newhead = newfield->snext = newfield->sprev = newfield;\n    }\n  else\n    {\n      newhead = current = head;\n      while ((current->frow < newfield->frow) ||\n\t     ((current->frow == newfield->frow) &&\n\t      (current->fcol < newfield->fcol)))\n\t{\n\t  current = current->snext;\n\t  if (current == head)\n\t    {\t\t\t \n\t      head = (FIELD *)0;\n\t      break;\n\t    }\n\t}\n       \n      newfield->snext = current;\n      newfield->sprev = current->sprev;\n      newfield->snext->sprev = newfield;\n      newfield->sprev->snext = newfield;\n      if (current == head)\n\tnewhead = newfield;\n    }\n  return (newhead);\n}\n\n \nstatic void\nDisconnect_Fields(FORM *form)\n{\n  if (form->field)\n    {\n      FIELD **fields;\n\n      for (fields = form->field; *fields; fields++)\n\t{\n\t  if (form == (*fields)->form)\n\t    (*fields)->form = (FORM *)0;\n\t}\n\n      form->rows = form->cols = 0;\n      form->maxfield = form->maxpage = -1;\n      form->field = (FIELD **)0;\n      if (form->page)\n\tfree(form->page);\n      form->page = (_PAGE *) 0;\n    }\n}\n\n \nstatic int\nConnect_Fields(FORM *form, FIELD **fields)\n{\n  int field_cnt, j;\n  int page_nr;\n  _PAGE *pg;\n\n  T((T_CALLED(\"Connect_Fields(%p,%p)\"), (void *)form, (void *)fields));\n\n  assert(form);\n\n  form->field = fields;\n  form->maxfield = 0;\n  form->maxpage = 0;\n\n  if (!fields)\n    RETURN(E_OK);\n\n  page_nr = 0;\n   \n  for (field_cnt = 0; fields[field_cnt]; field_cnt++)\n    {\n      if (fields[field_cnt]->form)\n\tRETURN(E_CONNECTED);\n      if (field_cnt == 0 ||\n\t  (fields[field_cnt]->status & _NEWPAGE))\n\tpage_nr++;\n      fields[field_cnt]->form = form;\n    }\n  if (field_cnt == 0 || (short)field_cnt < 0)\n    RETURN(E_BAD_ARGUMENT);\n\n   \n  if ((pg = typeMalloc(_PAGE, page_nr)) != (_PAGE *) 0)\n    {\n      T((T_CREATE(\"_PAGE %p\"), (void *)pg));\n      form->page = pg;\n    }\n  else\n    RETURN(E_SYSTEM_ERROR);\n\n   \n  for (j = 0; j < field_cnt; j++)\n    {\n      int maximum_row_in_field;\n      int maximum_col_in_field;\n\n      if (j == 0)\n\tpg->pmin = (short)j;\n      else\n\t{\n\t  if (fields[j]->status & _NEWPAGE)\n\t    {\n\t      pg->pmax = (short)(j - 1);\n\t      pg++;\n\t      pg->pmin = (short)j;\n\t    }\n\t}\n\n      maximum_row_in_field = fields[j]->frow + fields[j]->rows;\n      maximum_col_in_field = fields[j]->fcol + fields[j]->cols;\n\n      if (form->rows < maximum_row_in_field)\n\tform->rows = (short)maximum_row_in_field;\n      if (form->cols < maximum_col_in_field)\n\tform->cols = (short)maximum_col_in_field;\n    }\n\n  pg->pmax = (short)(field_cnt - 1);\n  form->maxfield = (short)field_cnt;\n  form->maxpage = (short)page_nr;\n\n   \n  for (page_nr = 0; page_nr < form->maxpage; page_nr++)\n    {\n      FIELD *fld = (FIELD *)0;\n\n      for (j = form->page[page_nr].pmin; j <= form->page[page_nr].pmax; j++)\n\t{\n\t  fields[j]->index = (short)j;\n\t  fields[j]->page = (short)page_nr;\n\t  fld = Insert_Field_By_Position(fields[j], fld);\n\t}\n      if (fld)\n\t{\n\t  form->page[page_nr].smin = fld->index;\n\t  form->page[page_nr].smax = fld->sprev->index;\n\t}\n      else\n\t{\n\t  form->page[page_nr].smin = 0;\n\t  form->page[page_nr].smax = 0;\n\t}\n    }\n  RETURN(E_OK);\n}\n\n \nNCURSES_INLINE static int\nAssociate_Fields(FORM *form, FIELD **fields)\n{\n  int res = Connect_Fields(form, fields);\n\n  if (res == E_OK)\n    {\n      if (form->maxpage > 0)\n\t{\n\t  form->curpage = 0;\n\t  form_driver(form, FIRST_ACTIVE_MAGIC);\n\t}\n      else\n\t{\n\t  form->curpage = -1;\n\t  form->current = (FIELD *)0;\n\t}\n    }\n  return (res);\n}\n\n \nFORM_EXPORT(FORM *)\nNCURSES_SP_NAME(new_form) (NCURSES_SP_DCLx FIELD **fields)\n{\n  int err = E_SYSTEM_ERROR;\n  FORM *form = (FORM *)0;\n\n  T((T_CALLED(\"new_form(%p,%p)\"), (void *)SP_PARM, (void *)fields));\n\n  if (IsValidScreen(SP_PARM))\n    {\n      form = typeMalloc(FORM, 1);\n\n      if (form)\n\t{\n\t  T((T_CREATE(\"form %p\"), (void *)form));\n\t  *form = *_nc_Default_Form;\n\t   \n\t  form->win = StdScreen(SP_PARM);\n\t  form->sub = StdScreen(SP_PARM);\n\t  if ((err = Associate_Fields(form, fields)) != E_OK)\n\t    {\n\t      free_form(form);\n\t      form = (FORM *)0;\n\t    }\n\t}\n    }\n\n  if (!form)\n    SET_ERROR(err);\n\n  returnForm(form);\n}\n\n \n#if NCURSES_SP_FUNCS\nFORM_EXPORT(FORM *)\nnew_form(FIELD **fields)\n{\n  return NCURSES_SP_NAME(new_form) (CURRENT_SCREEN, fields);\n}\n#endif\n\n \nFORM_EXPORT(int)\nfree_form(FORM *form)\n{\n  T((T_CALLED(\"free_form(%p)\"), (void *)form));\n\n  if (!form)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (form->status & _POSTED)\n    RETURN(E_POSTED);\n\n  Disconnect_Fields(form);\n  if (form->page)\n    free(form->page);\n  free(form);\n\n  RETURN(E_OK);\n}\n\n \nFORM_EXPORT(int)\nset_form_fields(FORM *form, FIELD **fields)\n{\n  FIELD **old;\n  int res;\n\n  T((T_CALLED(\"set_form_fields(%p,%p)\"), (void *)form, (void *)fields));\n\n  if (!form)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (form->status & _POSTED)\n    RETURN(E_POSTED);\n\n  old = form->field;\n  Disconnect_Fields(form);\n\n  if ((res = Associate_Fields(form, fields)) != E_OK)\n    Connect_Fields(form, old);\n\n  RETURN(res);\n}\n\n \nFORM_EXPORT(FIELD **)\nform_fields(const FORM *form)\n{\n  T((T_CALLED(\"form_field(%p)\"), (const void *)form));\n  returnFieldPtr(Normalize_Form(form)->field);\n}\n\n \nFORM_EXPORT(int)\nfield_count(const FORM *form)\n{\n  T((T_CALLED(\"field_count(%p)\"), (const void *)form));\n\n  returnCode(Normalize_Form(form)->maxfield);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}