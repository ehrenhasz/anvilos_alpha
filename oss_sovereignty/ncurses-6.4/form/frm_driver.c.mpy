{
  "module_name": "frm_driver.c",
  "hash_id": "e8b0edc38922d9678d5614a67c6d25381ef5a715627af7cb1f36f191efff2543",
  "original_prompt": "Ingested from ncurses-6.4/form/frm_driver.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: frm_driver.c,v 1.135 2021/09/01 23:34:01 tom Exp $\")\n\n \n\n \n\n \n\n \n#define FRIENDLY_PREV_NEXT_WORD (1)\n \n#define FIX_FORM_INACTIVE_BUG (1)\n \n#define GROW_IF_NAVIGATE (1)\n\n#if USE_WIDEC_SUPPORT\n#define myADDNSTR(w, s, n) wide_waddnstr(w, s, n)\n#define myINSNSTR(w, s, n) wide_winsnstr(w, s, n)\n#define myINNSTR(w, s, n)  wide_winnstr(w, s, n)\n#define myWCWIDTH(w, y, x) cell_width(w, y, x)\n#else\n#define myADDNSTR(w, s, n) waddnstr(w, s, n)\n#define myINSNSTR(w, s, n) winsnstr(w, s, n)\n#define myINNSTR(w, s, n)  winnstr(w, s, n)\n#define myWCWIDTH(w, y, x) 1\n#endif\n\n \nstatic int Inter_Field_Navigation(int (*const fct) (FORM *), FORM *form);\nstatic int FN_Next_Field(FORM *form);\nstatic int FN_Previous_Field(FORM *form);\nstatic int FE_New_Line(FORM *);\nstatic int FE_Delete_Previous(FORM *);\n\n \n\n \n#define Position_Of_Row_In_Buffer(field,row) ((row)*(field)->dcols)\n\n \n#define Address_Of_Nth_Buffer(field,N) \\\n  ((field)->buf + (N)*(1+Buffer_Length(field)))\n\n \n#define Address_Of_Row_In_Nth_Buffer(field,N,row) \\\n  (Address_Of_Nth_Buffer(field,N) + Position_Of_Row_In_Buffer(field,row))\n\n \n#define Address_Of_Row_In_Buffer(field,row) \\\n  Address_Of_Row_In_Nth_Buffer(field,0,row)\n\n \n#define Address_Of_Current_Row_In_Nth_Buffer(form,N) \\\n   Address_Of_Row_In_Nth_Buffer((form)->current,N,(form)->currow)\n\n \n#define Address_Of_Current_Row_In_Buffer(form) \\\n   Address_Of_Current_Row_In_Nth_Buffer(form,0)\n\n \n#define Address_Of_Current_Position_In_Nth_Buffer(form,N) \\\n   (Address_Of_Current_Row_In_Nth_Buffer(form,N) + (form)->curcol)\n\n \n#define Address_Of_Current_Position_In_Buffer(form) \\\n  Address_Of_Current_Position_In_Nth_Buffer(form,0)\n\n \n#define Is_Scroll_Field(field)          \\\n   (((field)->drows > (field)->rows) || \\\n    ((field)->dcols > (field)->cols))\n\n \n#define Has_Invisible_Parts(field)     \\\n  (!(Field_Has_Option(field, O_PUBLIC)) || \\\n   Is_Scroll_Field(field))\n\n \n#define Justification_Allowed(field)        \\\n   (((field)->just != NO_JUSTIFICATION)  && \\\n    (Single_Line_Field(field))           && \\\n    ((Field_Has_Option(field, O_STATIC)  && \\\n     ((field)->dcols == (field)->cols))  || \\\n    Field_Has_Option(field, O_DYNAMIC_JUSTIFY)))\n\n \n#define Growable(field) ((field)->status & _MAY_GROW)\n\n \n#define Set_Field_Window_Attributes(field,win) \\\n(  wbkgdset((win),(chtype)((chtype)((field)->pad) | (field)->back)), \\\n   (void) wattrset((win), (int)(field)->fore) )\n\n \n#define Field_Really_Appears(field)         \\\n  ((field->form)                          &&\\\n   (field->form->status & _POSTED)        &&\\\n   (Field_Has_Option(field, O_VISIBLE))   &&\\\n   (field->page == field->form->curpage))\n\n \n#define First_Position_In_Current_Field(form) \\\n  (((form)->currow==0) && ((form)->curcol==0))\n\n#define Minimum(a,b) (((a)<=(b)) ? (a) : (b))\n#define Maximum(a,b) (((a)>=(b)) ? (a) : (b))\n\n \nstatic FIELD_CELL myBLANK = BLANK;\nstatic FIELD_CELL myZEROS;\n\n#ifdef TRACE\nstatic void\ncheck_pos(FORM *form, int lineno)\n{\n  if (form && form->w)\n    {\n      int y, x;\n\n      getyx(form->w, y, x);\n      if (y != form->currow || x != form->curcol)\n\t{\n\t  T((\"CHECKPOS %s@%d have position %d,%d vs want %d,%d\",\n\t     __FILE__, lineno,\n\t     y, x,\n\t     form->currow, form->curcol));\n\t}\n    }\n}\n#define CHECKPOS(form) check_pos(form, __LINE__)\n#else\n#define CHECKPOS(form)\t\t \n#endif\n\n \n#if USE_WIDEC_SUPPORT\n \nstatic int\nwide_waddnstr(WINDOW *w, const cchar_t *s, int n)\n{\n  int rc = OK;\n\n  while (n-- > 0)\n    {\n      if ((rc = wadd_wch(w, s)) != OK)\n\tbreak;\n      ++s;\n    }\n  return rc;\n}\n\n \nstatic int\nwide_winsnstr(WINDOW *w, const cchar_t *s, int n)\n{\n  int code = ERR;\n\n  while (n-- > 0)\n    {\n      int y, x;\n\n      getyx(w, y, x);\n      if ((code = wins_wch(w, s++)) != OK)\n\tbreak;\n      if ((code = wmove(w, y, x + 1)) != OK)\n\tbreak;\n    }\n  return code;\n}\n\n \nstatic int\nwide_winnstr(WINDOW *w, cchar_t *s, int n)\n{\n  int x;\n\n  win_wchnstr(w, s, n);\n   \n  for (x = 0; x < n; ++x)\n    {\n      RemAttr(s[x], A_ATTRIBUTES);\n      SetPair(s[x], 0);\n    }\n  return n;\n}\n\n \nstatic int\ncell_base(WINDOW *win, int y, int x)\n{\n  int result = x;\n\n  while (LEGALYX(win, y, x))\n    {\n      cchar_t *data = &(win->_line[y].text[x]);\n\n      if (isWidecBase(CHDEREF(data)) || !isWidecExt(CHDEREF(data)))\n\t{\n\t  result = x;\n\t  break;\n\t}\n      --x;\n    }\n  return result;\n}\n\n \nstatic int\ncell_width(WINDOW *win, int y, int x)\n{\n  int result = 1;\n\n  if (LEGALYX(win, y, x))\n    {\n      cchar_t *data = &(win->_line[y].text[x]);\n\n      if (isWidecExt(CHDEREF(data)))\n\t{\n\t   \n\t  result = cell_width(win, y, x - 1);\n\t}\n      else\n\t{\n\t  result = wcwidth(CharOf(CHDEREF(data)));\n\t}\n    }\n  return result;\n}\n\n \nstatic void\ndelete_char(FORM *form)\n{\n  int cells = cell_width(form->w, form->currow, form->curcol);\n\n  form->curcol = cell_base(form->w, form->currow, form->curcol);\n  wmove(form->w, form->currow, form->curcol);\n  while (cells-- > 0)\n    {\n      wdelch(form->w);\n    }\n}\n#define DeleteChar(form) delete_char(form)\n#else\n#define DeleteChar(form) \\\n\t  wmove((form)->w, (form)->currow, (form)->curcol), \\\n\t  wdelch((form)->w)\n#endif\n\n \nNCURSES_INLINE static FIELD_CELL *\nGet_Start_Of_Data(FIELD_CELL *buf, int blen)\n{\n  FIELD_CELL *p = buf;\n  FIELD_CELL *end = &buf[blen];\n\n  assert(buf && blen >= 0);\n  while ((p < end) && ISBLANK(*p))\n    p++;\n  return ((p == end) ? buf : p);\n}\n\n \nNCURSES_INLINE static FIELD_CELL *\nAfter_End_Of_Data(FIELD_CELL *buf, int blen)\n{\n  FIELD_CELL *p = &buf[blen];\n\n  assert(buf && blen >= 0);\n  while ((p > buf) && ISBLANK(p[-1]))\n    p--;\n  return (p);\n}\n\n \nNCURSES_INLINE static FIELD_CELL *\nGet_First_Whitespace_Character(FIELD_CELL *buf, int blen)\n{\n  FIELD_CELL *p = buf;\n  FIELD_CELL *end = &p[blen];\n\n  assert(buf && blen >= 0);\n  while ((p < end) && !ISBLANK(*p))\n    p++;\n  return ((p == end) ? buf : p);\n}\n\n \nNCURSES_INLINE static FIELD_CELL *\nAfter_Last_Whitespace_Character(FIELD_CELL *buf, int blen)\n{\n  FIELD_CELL *p = &buf[blen];\n\n  assert(buf && blen >= 0);\n  while ((p > buf) && !ISBLANK(p[-1]))\n    p--;\n  return (p);\n}\n\n \n#define USE_DIV_T (0)\n\n \nNCURSES_INLINE static void\nAdjust_Cursor_Position(FORM *form, const FIELD_CELL *pos)\n{\n  FIELD *field;\n  int idx;\n\n  field = form->current;\n  assert(pos >= field->buf && field->dcols > 0);\n  idx = (int)(pos - field->buf);\n#if USE_DIV_T\n  *((div_t *) & (form->currow)) = div(idx, field->dcols);\n#else\n  form->currow = idx / field->dcols;\n  form->curcol = idx - field->cols * form->currow;\n#endif\n  if (field->drows < form->currow)\n    form->currow = 0;\n}\n\n \nstatic void\nBuffer_To_Window(const FIELD *field, WINDOW *win)\n{\n  int width, height;\n  int y, x;\n  int row;\n  FIELD_CELL *pBuffer;\n\n  assert(win && field);\n\n  getyx(win, y, x);\n  width = getmaxx(win);\n  height = getmaxy(win);\n\n  for (row = 0, pBuffer = field->buf;\n       row < height;\n       row++, pBuffer += width)\n    {\n      int len;\n\n      if ((len = (int)(After_End_Of_Data(pBuffer, width) - pBuffer)) > 0)\n\t{\n\t  wmove(win, row, 0);\n\t  myADDNSTR(win, pBuffer, len);\n\t}\n    }\n  wmove(win, y, x);\n}\n\n \nFORM_EXPORT(void)\n_nc_get_fieldbuffer(FORM *form, FIELD *field, FIELD_CELL *buf)\n{\n  int pad;\n  int len = 0;\n  FIELD_CELL *p;\n  int row, height;\n  WINDOW *win;\n\n  assert(form && field && buf);\n\n  win = form->w;\n  assert(win);\n\n  pad = field->pad;\n  p = buf;\n  height = getmaxy(win);\n\n  for (row = 0; (row < height) && (row < field->drows); row++)\n    {\n      wmove(win, row, 0);\n      len += myINNSTR(win, p + len, field->dcols);\n    }\n  p[len] = myZEROS;\n\n   \n  if (pad != C_BLANK)\n    {\n      int i;\n\n      for (i = 0; i < len; i++, p++)\n\t{\n\t  if ((unsigned long)CharOf(*p) == ChCharOf(pad)\n#if USE_WIDEC_SUPPORT\n\t      && p->chars[1] == 0\n#endif\n\t    )\n\t    *p = myBLANK;\n\t}\n    }\n}\n\n \nstatic void\nWindow_To_Buffer(FORM *form, FIELD *field)\n{\n  _nc_get_fieldbuffer(form, field, field->buf);\n}\n\n \nNCURSES_INLINE static void\nSynchronize_Buffer(FORM *form)\n{\n  if (form->status & _WINDOW_MODIFIED)\n    {\n      ClrStatus(form, _WINDOW_MODIFIED);\n      SetStatus(form, _FCHECK_REQUIRED);\n      Window_To_Buffer(form, form->current);\n      wmove(form->w, form->currow, form->curcol);\n    }\n}\n\n \nstatic bool\nField_Grown(FIELD *field, int amount)\n{\n  bool result = FALSE;\n\n  if (field && Growable(field))\n    {\n      bool single_line_field = Single_Line_Field(field);\n      int old_buflen = Buffer_Length(field);\n      int new_buflen;\n      int old_dcols = field->dcols;\n      int old_drows = field->drows;\n      FIELD_CELL *oldbuf = field->buf;\n      FIELD_CELL *newbuf;\n\n      int growth;\n      FORM *form = field->form;\n      bool need_visual_update = ((form != (FORM *)0) &&\n\t\t\t\t (form->status & _POSTED) &&\n\t\t\t\t (form->current == field));\n\n      if (need_visual_update)\n\tSynchronize_Buffer(form);\n\n      if (single_line_field)\n\t{\n\t  growth = field->cols * amount;\n\t  if (field->maxgrow)\n\t    growth = Minimum(field->maxgrow - field->dcols, growth);\n\t  field->dcols += growth;\n\t  if (field->dcols == field->maxgrow)\n\t    ClrStatus(field, _MAY_GROW);\n\t}\n      else\n\t{\n\t  growth = (field->rows + field->nrow) * amount;\n\t  if (field->maxgrow)\n\t    growth = Minimum(field->maxgrow - field->drows, growth);\n\t  field->drows += growth;\n\t  if (field->drows == field->maxgrow)\n\t    ClrStatus(field, _MAY_GROW);\n\t}\n       \n      new_buflen = Buffer_Length(field);\n      newbuf = (FIELD_CELL *)malloc(Total_Buffer_Size(field));\n      if (!newbuf)\n\t{\n\t   \n\t  field->dcols = old_dcols;\n\t  field->drows = old_drows;\n\t  if ((single_line_field && (field->dcols != field->maxgrow)) ||\n\t      (!single_line_field && (field->drows != field->maxgrow)))\n\t    SetStatus(field, _MAY_GROW);\n\t}\n      else\n\t{\n\t   \n\t  int i, j;\n\n\t  result = TRUE;\t \n\n\t  T((T_CREATE(\"fieldcell %p\"), (void *)newbuf));\n\t  field->buf = newbuf;\n\t  for (i = 0; i <= field->nbuf; i++)\n\t    {\n\t      FIELD_CELL *new_bp = Address_Of_Nth_Buffer(field, i);\n\t      FIELD_CELL *old_bp = oldbuf + i * (1 + old_buflen);\n\n\t      for (j = 0; j < old_buflen; ++j)\n\t\tnew_bp[j] = old_bp[j];\n\t      while (j < new_buflen)\n\t\tnew_bp[j++] = myBLANK;\n\t      new_bp[new_buflen] = myZEROS;\n\t    }\n\n#if USE_WIDEC_SUPPORT && NCURSES_EXT_FUNCS\n\t  if (wresize(field->working, 1, Buffer_Length(field) + 1) == ERR)\n\t    result = FALSE;\n#endif\n\n\t  if (need_visual_update && result)\n\t    {\n\t      WINDOW *new_window = newpad(field->drows, field->dcols);\n\n\t      if (new_window != 0)\n\t\t{\n\t\t  assert(form != (FORM *)0);\n\t\t  if (form->w)\n\t\t    delwin(form->w);\n\t\t  form->w = new_window;\n\t\t  Set_Field_Window_Attributes(field, form->w);\n\t\t  werase(form->w);\n\t\t  Buffer_To_Window(field, form->w);\n\t\t  untouchwin(form->w);\n\t\t  wmove(form->w, form->currow, form->curcol);\n\t\t}\n\t      else\n\t\tresult = FALSE;\n\t    }\n\n\t  if (result)\n\t    {\n\t      free(oldbuf);\n\t       \n\t      if (field != field->link)\n\t\t{\n\t\t  FIELD *linked_field;\n\n\t\t  for (linked_field = field->link;\n\t\t       linked_field != field;\n\t\t       linked_field = linked_field->link)\n\t\t    {\n\t\t      linked_field->buf = field->buf;\n\t\t      linked_field->drows = field->drows;\n\t\t      linked_field->dcols = field->dcols;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t       \n\t      field->dcols = old_dcols;\n\t      field->drows = old_drows;\n\t      field->buf = oldbuf;\n\t      if ((single_line_field &&\n\t\t   (field->dcols != field->maxgrow)) ||\n\t\t  (!single_line_field &&\n\t\t   (field->drows != field->maxgrow)))\n\t\tSetStatus(field, _MAY_GROW);\n\t      free(newbuf);\n\t    }\n\t}\n    }\n  return (result);\n}\n\n#ifdef NCURSES_MOUSE_VERSION\n \nstatic int\nField_encloses(FIELD *field, int ry, int rx)\n{\n  T((T_CALLED(\"Field_encloses(%p)\"), (void *)field));\n  if (field != 0\n      && field->frow <= ry\n      && (field->frow + field->rows) > ry\n      && field->fcol <= rx\n      && (field->fcol + field->cols) > rx)\n    {\n      RETURN(E_OK);\n    }\n  RETURN(E_INVALID_FIELD);\n}\n#endif\n\n \nFORM_EXPORT(int)\n_nc_Position_Form_Cursor(FORM *form)\n{\n  FIELD *field;\n  WINDOW *formwin;\n\n  if (!form)\n    return (E_BAD_ARGUMENT);\n\n  if (!form->w || !form->current)\n    return (E_SYSTEM_ERROR);\n\n  field = form->current;\n  formwin = Get_Form_Window(form);\n\n  wmove(form->w, form->currow, form->curcol);\n  if (Has_Invisible_Parts(field))\n    {\n       \n      wmove(formwin,\n\t    field->frow + form->currow - form->toprow,\n\t    field->fcol + form->curcol - form->begincol);\n      wcursyncup(formwin);\n    }\n  else\n    wcursyncup(form->w);\n  return (E_OK);\n}\n\n \nstatic bool move_after_insert = TRUE;\nFORM_EXPORT(int)\n_nc_Refresh_Current_Field(FORM *form)\n{\n  WINDOW *formwin;\n  FIELD *field;\n  bool is_public;\n\n  T((T_CALLED(\"_nc_Refresh_Current_Field(%p)\"), (void *)form));\n\n  if (!form)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (!form->w || !form->current)\n    RETURN(E_SYSTEM_ERROR);\n\n  field = form->current;\n  formwin = Get_Form_Window(form);\n\n  is_public = Field_Has_Option(field, O_PUBLIC);\n\n  if (Is_Scroll_Field(field))\n    {\n       \n      if (Single_Line_Field(field))\n\t{\n\t   \n\t  if (form->curcol < form->begincol)\n\t    form->begincol = form->curcol;\n\t  else\n\t    {\n\t      if (form->curcol >= (form->begincol + field->cols))\n\t\tform->begincol = form->curcol - field->cols\n\t\t  + (move_after_insert ? 1 : 0);\n\t    }\n\t  if (is_public)\n\t    copywin(form->w,\n\t\t    formwin,\n\t\t    0,\n\t\t    form->begincol,\n\t\t    field->frow,\n\t\t    field->fcol,\n\t\t    field->frow,\n\t\t    field->cols + field->fcol - 1,\n\t\t    0);\n\t}\n      else\n\t{\n\t   \n\t  int first_modified_row, first_unmodified_row;\n\n\t  if (field->drows > field->rows)\n\t    {\n\t      int row_after_bottom = form->toprow + field->rows;\n\n\t      if (form->currow < form->toprow)\n\t\t{\n\t\t  form->toprow = form->currow;\n\t\t  SetStatus(field, _NEWTOP);\n\t\t}\n\t      if (form->currow >= row_after_bottom)\n\t\t{\n\t\t  form->toprow = form->currow - field->rows + 1;\n\t\t  SetStatus(field, _NEWTOP);\n\t\t}\n\t      if (field->status & _NEWTOP)\n\t\t{\n\t\t   \n\t\t  first_modified_row = form->toprow;\n\t\t  first_unmodified_row = first_modified_row + field->rows;\n\t\t  ClrStatus(field, _NEWTOP);\n\t\t}\n\t      else\n\t\t{\n\t\t   \n\t\t  first_modified_row = form->toprow;\n\t\t  while (first_modified_row < row_after_bottom)\n\t\t    {\n\t\t      if (is_linetouched(form->w, first_modified_row))\n\t\t\tbreak;\n\t\t      first_modified_row++;\n\t\t    }\n\t\t  first_unmodified_row = first_modified_row;\n\t\t  while (first_unmodified_row < row_after_bottom)\n\t\t    {\n\t\t      if (!is_linetouched(form->w, first_unmodified_row))\n\t\t\tbreak;\n\t\t      first_unmodified_row++;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      first_modified_row = form->toprow;\n\t      first_unmodified_row = first_modified_row + field->rows;\n\t    }\n\t  if (first_unmodified_row != first_modified_row && is_public)\n\t    copywin(form->w,\n\t\t    formwin,\n\t\t    first_modified_row,\n\t\t    0,\n\t\t    field->frow + first_modified_row - form->toprow,\n\t\t    field->fcol,\n\t\t    field->frow + first_unmodified_row - form->toprow - 1,\n\t\t    field->cols + field->fcol - 1,\n\t\t    0);\n\t}\n      if (is_public)\n\twsyncup(formwin);\n    }\n  else\n    {\n       \n      if (is_public)\n\twsyncup(form->w);\n    }\n  untouchwin(form->w);\n  returnCode(_nc_Position_Form_Cursor(form));\n}\n\n \nstatic void\nPerform_Justification(FIELD *field, WINDOW *win)\n{\n  FIELD_CELL *bp;\n  int len;\n\n  bp = (Field_Has_Option(field, O_NO_LEFT_STRIP)\n\t? field->buf\n\t: Get_Start_Of_Data(field->buf, Buffer_Length(field)));\n  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);\n\n  if (len > 0)\n    {\n      int col = 0;\n\n      assert(win && (field->drows == 1));\n\n      if (field->cols - len >= 0)\n\tswitch (field->just)\n\t  {\n\t  case JUSTIFY_LEFT:\n\t    break;\n\t  case JUSTIFY_CENTER:\n\t    col = (field->cols - len) / 2;\n\t    break;\n\t  case JUSTIFY_RIGHT:\n\t    col = field->cols - len;\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\n      wmove(win, 0, col);\n      myADDNSTR(win, bp, len);\n    }\n}\n\n \nstatic void\nUndo_Justification(FIELD *field, WINDOW *win)\n{\n  FIELD_CELL *bp;\n  int y, x;\n  int len;\n\n  getyx(win, y, x);\n\n  bp = (Field_Has_Option(field, O_NO_LEFT_STRIP)\n\t? field->buf\n\t: Get_Start_Of_Data(field->buf, Buffer_Length(field)));\n  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);\n\n  if (len > 0)\n    {\n      assert(win);\n      wmove(win, 0, 0);\n      myADDNSTR(win, bp, len);\n    }\n  wmove(win, y, x);\n}\n\n \nstatic bool\nCheck_Char(FORM *form,\n\t   FIELD *field,\n\t   FIELDTYPE *typ,\n\t   int ch,\n\t   TypeArgument *argp)\n{\n  if (typ)\n    {\n      if (typ->status & _LINKED_TYPE)\n\t{\n\t  assert(argp);\n\t  return (\n\t\t   Check_Char(form, field, typ->left, ch, argp->left) ||\n\t\t   Check_Char(form, field, typ->right, ch, argp->right));\n\t}\n      else\n\t{\n#if NCURSES_INTEROP_FUNCS\n\t  if (typ->charcheck.occheck)\n\t    {\n\t      if (typ->status & _GENERIC)\n\t\treturn typ->charcheck.gccheck(ch, form, field, (void *)argp);\n\t      else\n\t\treturn typ->charcheck.occheck(ch, (void *)argp);\n\t    }\n#else\n\t  if (typ->ccheck)\n\t    return typ->ccheck(ch, (void *)argp);\n#endif\n\t}\n    }\n  return (!iscntrl(UChar(ch)) ? TRUE : FALSE);\n}\n\n \nstatic int\nDisplay_Or_Erase_Field(FIELD *field, bool bEraseFlag)\n{\n  WINDOW *win;\n  WINDOW *fwin;\n\n  if (!field)\n    return E_SYSTEM_ERROR;\n\n  fwin = Get_Form_Window(field->form);\n  win = derwin(fwin,\n\t       field->rows, field->cols, field->frow, field->fcol);\n\n  if (!win)\n    return E_SYSTEM_ERROR;\n  else\n    {\n      if (Field_Has_Option(field, O_VISIBLE))\n\t{\n\t  Set_Field_Window_Attributes(field, win);\n\t}\n      else\n\t{\n\t  (void)wattrset(win, (int)WINDOW_ATTRS(fwin));\n\t}\n      werase(win);\n    }\n\n  if (!bEraseFlag)\n    {\n      if (Field_Has_Option(field, O_PUBLIC))\n\t{\n\t  if (Justification_Allowed(field))\n\t    Perform_Justification(field, win);\n\t  else\n\t    Buffer_To_Window(field, win);\n\t}\n      ClrStatus(field, _NEWTOP);\n    }\n  wsyncup(win);\n  delwin(win);\n  return E_OK;\n}\n\n \n#define Display_Field(field) Display_Or_Erase_Field(field,FALSE)\n#define Erase_Field(field)   Display_Or_Erase_Field(field,TRUE)\n\n \nstatic int\nSynchronize_Field(FIELD *field)\n{\n  FORM *form;\n  int res = E_OK;\n\n  if (!field)\n    return (E_BAD_ARGUMENT);\n\n  if (((form = field->form) != (FORM *)0)\n      && Field_Really_Appears(field))\n    {\n      if (field == form->current)\n\t{\n\t  form->currow = form->curcol = form->toprow = form->begincol = 0;\n\t  werase(form->w);\n\n\t  if ((Field_Has_Option(field, O_PUBLIC)) && Justification_Allowed(field))\n\t    Undo_Justification(field, form->w);\n\t  else\n\t    Buffer_To_Window(field, form->w);\n\n\t  SetStatus(field, _NEWTOP);\n\t  res = _nc_Refresh_Current_Field(form);\n\t}\n      else\n\tres = Display_Field(field);\n    }\n  SetStatus(field, _CHANGED);\n  return (res);\n}\n\n \nstatic int\nSynchronize_Linked_Fields(FIELD *field)\n{\n  FIELD *linked_field;\n  int res = E_OK;\n\n  if (!field)\n    return (E_BAD_ARGUMENT);\n\n  if (!field->link)\n    return (E_SYSTEM_ERROR);\n\n  for (linked_field = field->link;\n       (linked_field != field) && (linked_field != 0);\n       linked_field = linked_field->link)\n    {\n      int syncres;\n\n      if (((syncres = Synchronize_Field(linked_field)) != E_OK) &&\n\t  (res == E_OK))\n\tres = syncres;\n    }\n  return (res);\n}\n\n \nFORM_EXPORT(int)\n_nc_Synchronize_Attributes(FIELD *field)\n{\n  FORM *form;\n  int res = E_OK;\n\n  T((T_CALLED(\"_nc_Synchronize_Attributes(%p)\"), (void *)field));\n\n  if (!field)\n    returnCode(E_BAD_ARGUMENT);\n\n  CHECKPOS(field->form);\n  if (((form = field->form) != (FORM *)0)\n      && Field_Really_Appears(field))\n    {\n      if (form->current == field)\n\t{\n\t  Synchronize_Buffer(form);\n\t  Set_Field_Window_Attributes(field, form->w);\n\t  werase(form->w);\n\t  wmove(form->w, form->currow, form->curcol);\n\n\t  if (Field_Has_Option(field, O_PUBLIC))\n\t    {\n\t      if (Justification_Allowed(field))\n\t\tUndo_Justification(field, form->w);\n\t      else\n\t\tBuffer_To_Window(field, form->w);\n\t    }\n\t  else\n\t    {\n\t      WINDOW *formwin = Get_Form_Window(form);\n\n\t      copywin(form->w, formwin,\n\t\t      0, 0,\n\t\t      field->frow, field->fcol,\n\t\t      field->frow + field->rows - 1,\n\t\t      field->fcol + field->cols - 1, 0);\n\t      wsyncup(formwin);\n\t      Buffer_To_Window(field, form->w);\n\t      SetStatus(field, _NEWTOP);\t \n\t      _nc_Refresh_Current_Field(form);\n\t    }\n\t}\n      else\n\t{\n\t  res = Display_Field(field);\n\t}\n    }\n  CHECKPOS(form);\n  returnCode(res);\n}\n\n \nFORM_EXPORT(int)\n_nc_Synchronize_Options(FIELD *field, Field_Options newopts)\n{\n  Field_Options oldopts;\n  Field_Options changed_opts;\n  FORM *form;\n  int res = E_OK;\n\n  T((T_CALLED(\"_nc_Synchronize_Options(%p,%#x)\"), (void *)field, newopts));\n\n  if (!field)\n    returnCode(E_BAD_ARGUMENT);\n\n  oldopts = field->opts;\n  changed_opts = oldopts ^ newopts;\n  field->opts = newopts;\n  form = field->form;\n\n  if (form)\n    {\n      if (form->status & _POSTED)\n\t{\n\t  if (form->current == field)\n\t    {\n\t      field->opts = oldopts;\n\t      returnCode(E_CURRENT);\n\t    }\n\t  if (form->curpage == field->page)\n\t    {\n\t      if ((unsigned)changed_opts & O_VISIBLE)\n\t\t{\n\t\t  if ((unsigned)newopts & O_VISIBLE)\n\t\t    res = Display_Field(field);\n\t\t  else\n\t\t    res = Erase_Field(field);\n\t\t}\n\t      else\n\t\t{\n\t\t  if (((unsigned)changed_opts & O_PUBLIC) &&\n\t\t      ((unsigned)newopts & O_VISIBLE))\n\t\t    res = Display_Field(field);\n\t\t}\n\t    }\n\t}\n    }\n\n  if ((unsigned)changed_opts & O_STATIC)\n    {\n      bool single_line_field = Single_Line_Field(field);\n      int res2 = E_OK;\n\n      if ((unsigned)newopts & O_STATIC)\n\t{\n\t   \n\t  ClrStatus(field, _MAY_GROW);\n\t   \n\t  if (single_line_field &&\n\t      (field->cols == field->dcols) &&\n\t      (field->just != NO_JUSTIFICATION) &&\n\t      Field_Really_Appears(field))\n\t    {\n\t      res2 = Display_Field(field);\n\t    }\n\t}\n      else\n\t{\n\t   \n\t  if ((field->maxgrow == 0) ||\n\t      (single_line_field && (field->dcols < field->maxgrow)) ||\n\t      (!single_line_field && (field->drows < field->maxgrow)))\n\t    {\n\t      SetStatus(field, _MAY_GROW);\n\t       \n\t      if (single_line_field &&\n\t\t  (field->just != NO_JUSTIFICATION) &&\n\t\t  Field_Really_Appears(field))\n\t\t{\n\t\t  res2 = Display_Field(field);\n\t\t}\n\t    }\n\t}\n      if (res2 != E_OK)\n\tres = res2;\n    }\n\n  returnCode(res);\n}\n\n \nvoid\n_nc_Unset_Current_Field(FORM *form)\n{\n  FIELD *field = form->current;\n\n  _nc_Refresh_Current_Field(form);\n  if (Field_Has_Option(field, O_PUBLIC))\n    {\n      if (field->drows > field->rows)\n\t{\n\t  if (form->toprow == 0)\n\t    ClrStatus(field, _NEWTOP);\n\t  else\n\t    SetStatus(field, _NEWTOP);\n\t}\n      else\n\t{\n\t  if (Justification_Allowed(field))\n\t    {\n\t      Window_To_Buffer(form, field);\n\t      werase(form->w);\n\t      Perform_Justification(field, form->w);\n\t      if (Field_Has_Option(field, O_DYNAMIC_JUSTIFY) &&\n\t\t  (form->w->_parent == 0))\n\t\t{\n\t\t  copywin(form->w,\n\t\t\t  Get_Form_Window(form),\n\t\t\t  0,\n\t\t\t  0,\n\t\t\t  field->frow,\n\t\t\t  field->fcol,\n\t\t\t  field->frow,\n\t\t\t  field->cols + field->fcol - 1,\n\t\t\t  0);\n\t\t  wsyncup(Get_Form_Window(form));\n\t\t}\n\t      else\n\t\t{\n\t\t  wsyncup(form->w);\n\t\t}\n\t    }\n\t}\n    }\n  delwin(form->w);\n  form->w = (WINDOW *)0;\n  form->current = 0;\n}\n\n \nFORM_EXPORT(int)\n_nc_Set_Current_Field(FORM *form, FIELD *newfield)\n{\n  FIELD *field;\n  WINDOW *new_window;\n\n  T((T_CALLED(\"_nc_Set_Current_Field(%p,%p)\"), (void *)form, (void *)newfield));\n\n  if (!form || !newfield || (newfield->form != form))\n    returnCode(E_BAD_ARGUMENT);\n\n  if ((form->status & _IN_DRIVER))\n    returnCode(E_BAD_STATE);\n\n  if (!(form->field))\n    returnCode(E_NOT_CONNECTED);\n\n  field = form->current;\n\n  if ((field != newfield) ||\n      !(form->status & _POSTED))\n    {\n      if (field && (form->w) &&\n\t  (Field_Has_Option(field, O_VISIBLE)) &&\n\t  (field->form->curpage == field->page))\n\t_nc_Unset_Current_Field(form);\n\n      field = newfield;\n\n      if (Has_Invisible_Parts(field))\n\tnew_window = newpad(field->drows, field->dcols);\n      else\n\tnew_window = derwin(Get_Form_Window(form),\n\t\t\t    field->rows, field->cols, field->frow, field->fcol);\n\n      if (!new_window)\n\treturnCode(E_SYSTEM_ERROR);\n\n      form->current = field;\n\n      if (form->w)\n\tdelwin(form->w);\n      form->w = new_window;\n\n      ClrStatus(form, _WINDOW_MODIFIED);\n      Set_Field_Window_Attributes(field, form->w);\n\n      if (Has_Invisible_Parts(field))\n\t{\n\t  werase(form->w);\n\t  Buffer_To_Window(field, form->w);\n\t}\n      else\n\t{\n\t  if (Justification_Allowed(field))\n\t    {\n\t      werase(form->w);\n\t      Undo_Justification(field, form->w);\n\t      wsyncup(form->w);\n\t    }\n\t}\n\n      untouchwin(form->w);\n    }\n\n  form->currow = form->curcol = form->toprow = form->begincol = 0;\n  returnCode(E_OK);\n}\n\n \n\n \nstatic int\nIFN_Next_Character(FORM *form)\n{\n  FIELD *field = form->current;\n  int step = myWCWIDTH(form->w, form->currow, form->curcol);\n\n  T((T_CALLED(\"IFN_Next_Character(%p)\"), (void *)form));\n  if ((form->curcol += step) == field->dcols)\n    {\n      if ((++(form->currow)) == field->drows)\n\t{\n#if GROW_IF_NAVIGATE\n\t  if (!Single_Line_Field(field) && Field_Grown(field, 1))\n\t    {\n\t      form->curcol = 0;\n\t      returnCode(E_OK);\n\t    }\n#endif\n\t  form->currow--;\n#if GROW_IF_NAVIGATE\n\t  if (Single_Line_Field(field) && Field_Grown(field, 1))\n\t    returnCode(E_OK);\n#endif\n\t  form->curcol -= step;\n\t  returnCode(E_REQUEST_DENIED);\n\t}\n      form->curcol = 0;\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Previous_Character(FORM *form)\n{\n  int amount = myWCWIDTH(form->w, form->currow, form->curcol - 1);\n  int oldcol = form->curcol;\n\n  T((T_CALLED(\"IFN_Previous_Character(%p)\"), (void *)form));\n  if ((form->curcol -= amount) < 0)\n    {\n      if ((--(form->currow)) < 0)\n\t{\n\t  form->currow++;\n\t  form->curcol = oldcol;\n\t  returnCode(E_REQUEST_DENIED);\n\t}\n      form->curcol = form->current->dcols - 1;\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Next_Line(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"IFN_Next_Line(%p)\"), (void *)form));\n  if ((++(form->currow)) == field->drows)\n    {\n#if GROW_IF_NAVIGATE\n      if (!Single_Line_Field(field) && Field_Grown(field, 1))\n\treturnCode(E_OK);\n#endif\n      form->currow--;\n      returnCode(E_REQUEST_DENIED);\n    }\n  form->curcol = 0;\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Previous_Line(FORM *form)\n{\n  T((T_CALLED(\"IFN_Previous_Line(%p)\"), (void *)form));\n  if ((--(form->currow)) < 0)\n    {\n      form->currow++;\n      returnCode(E_REQUEST_DENIED);\n    }\n  form->curcol = 0;\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Next_Word(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *bp = Address_Of_Current_Position_In_Buffer(form);\n  FIELD_CELL *s;\n  FIELD_CELL *t;\n\n  T((T_CALLED(\"IFN_Next_Word(%p)\"), (void *)form));\n\n   \n  Synchronize_Buffer(form);\n\n   \n  s = Get_First_Whitespace_Character(bp, Buffer_Length(field) -\n\t\t\t\t     (int)(bp - field->buf));\n\n   \n  t = Get_Start_Of_Data(s, Buffer_Length(field) -\n\t\t\t(int)(s - field->buf));\n#if !FRIENDLY_PREV_NEXT_WORD\n  if (s == t)\n    returnCode(E_REQUEST_DENIED);\n  else\n#endif\n    {\n      Adjust_Cursor_Position(form, t);\n      returnCode(E_OK);\n    }\n}\n\n \nstatic int\nIFN_Previous_Word(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *bp = Address_Of_Current_Position_In_Buffer(form);\n  FIELD_CELL *s;\n  FIELD_CELL *t;\n  bool again = FALSE;\n\n  T((T_CALLED(\"IFN_Previous_Word(%p)\"), (void *)form));\n\n   \n  Synchronize_Buffer(form);\n\n  s = After_End_Of_Data(field->buf, (int)(bp - field->buf));\n   \n  if (s == bp)\n    again = TRUE;\n\n   \n  t = After_Last_Whitespace_Character(field->buf, (int)(s - field->buf));\n#if !FRIENDLY_PREV_NEXT_WORD\n  if (s == t)\n    returnCode(E_REQUEST_DENIED);\n#endif\n  if (again)\n    {\n       \n      s = After_End_Of_Data(field->buf, (int)(t - field->buf));\n      t = After_Last_Whitespace_Character(field->buf, (int)(s - field->buf));\n#if !FRIENDLY_PREV_NEXT_WORD\n      if (s == t)\n\treturnCode(E_REQUEST_DENIED);\n#endif\n    }\n  Adjust_Cursor_Position(form, t);\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Beginning_Of_Field(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"IFN_Beginning_Of_Field(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  Adjust_Cursor_Position(form,\n\t\t\t Get_Start_Of_Data(field->buf, Buffer_Length(field)));\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_End_Of_Field(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *pos;\n\n  T((T_CALLED(\"IFN_End_Of_Field(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  pos = After_End_Of_Data(field->buf, Buffer_Length(field));\n  if (pos == (field->buf + Buffer_Length(field)))\n    pos--;\n  Adjust_Cursor_Position(form, pos);\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Beginning_Of_Line(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"IFN_Beginning_Of_Line(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  Adjust_Cursor_Position(form,\n\t\t\t Get_Start_Of_Data(Address_Of_Current_Row_In_Buffer(form),\n\t\t\t\t\t   field->dcols));\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_End_Of_Line(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *pos;\n  FIELD_CELL *bp;\n\n  T((T_CALLED(\"IFN_End_Of_Line(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  bp = Address_Of_Current_Row_In_Buffer(form);\n  pos = After_End_Of_Data(bp, field->dcols);\n  if (pos == (bp + field->dcols))\n    pos--;\n  Adjust_Cursor_Position(form, pos);\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Left_Character(FORM *form)\n{\n  int amount = myWCWIDTH(form->w, form->currow, form->curcol - 1);\n  int oldcol = form->curcol;\n\n  T((T_CALLED(\"IFN_Left_Character(%p)\"), (void *)form));\n  if ((form->curcol -= amount) < 0)\n    {\n      form->curcol = oldcol;\n      returnCode(E_REQUEST_DENIED);\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Right_Character(FORM *form)\n{\n  int amount = myWCWIDTH(form->w, form->currow, form->curcol);\n  int oldcol = form->curcol;\n\n  T((T_CALLED(\"IFN_Right_Character(%p)\"), (void *)form));\n  if ((form->curcol += amount) >= form->current->dcols)\n    {\n#if GROW_IF_NAVIGATE\n      FIELD *field = form->current;\n\n      if (Single_Line_Field(field) && Field_Grown(field, 1))\n\treturnCode(E_OK);\n#endif\n      form->curcol = oldcol;\n      returnCode(E_REQUEST_DENIED);\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Up_Character(FORM *form)\n{\n  T((T_CALLED(\"IFN_Up_Character(%p)\"), (void *)form));\n  if ((--(form->currow)) < 0)\n    {\n      form->currow++;\n      returnCode(E_REQUEST_DENIED);\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nIFN_Down_Character(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"IFN_Down_Character(%p)\"), (void *)form));\n  if ((++(form->currow)) == field->drows)\n    {\n#if GROW_IF_NAVIGATE\n      if (!Single_Line_Field(field) && Field_Grown(field, 1))\n\treturnCode(E_OK);\n#endif\n      --(form->currow);\n      returnCode(E_REQUEST_DENIED);\n    }\n  returnCode(E_OK);\n}\n \n\n \n\n \nstatic int\nVSC_Generic(FORM *form, int nlines)\n{\n  FIELD *field = form->current;\n  int res = E_REQUEST_DENIED;\n  int rows_to_go = (nlines > 0 ? nlines : -nlines);\n\n  if (nlines > 0)\n    {\n      if ((rows_to_go + form->toprow) > (field->drows - field->rows))\n\trows_to_go = (field->drows - field->rows - form->toprow);\n\n      if (rows_to_go > 0)\n\t{\n\t  form->currow += rows_to_go;\n\t  form->toprow += rows_to_go;\n\t  res = E_OK;\n\t}\n    }\n  else\n    {\n      if (rows_to_go > form->toprow)\n\trows_to_go = form->toprow;\n\n      if (rows_to_go > 0)\n\t{\n\t  form->currow -= rows_to_go;\n\t  form->toprow -= rows_to_go;\n\t  res = E_OK;\n\t}\n    }\n  return (res);\n}\n \n\n \n\n \nstatic int\nVertical_Scrolling(int (*const fct) (FORM *), FORM *form)\n{\n  int res = E_REQUEST_DENIED;\n\n  if (!Single_Line_Field(form->current))\n    {\n      res = fct(form);\n      if (res == E_OK)\n\tSetStatus(form->current, _NEWTOP);\n    }\n  return (res);\n}\n\n \nstatic int\nVSC_Scroll_Line_Forward(FORM *form)\n{\n  T((T_CALLED(\"VSC_Scroll_Line_Forward(%p)\"), (void *)form));\n  returnCode(VSC_Generic(form, 1));\n}\n\n \nstatic int\nVSC_Scroll_Line_Backward(FORM *form)\n{\n  T((T_CALLED(\"VSC_Scroll_Line_Backward(%p)\"), (void *)form));\n  returnCode(VSC_Generic(form, -1));\n}\n\n \nstatic int\nVSC_Scroll_Page_Forward(FORM *form)\n{\n  T((T_CALLED(\"VSC_Scroll_Page_Forward(%p)\"), (void *)form));\n  returnCode(VSC_Generic(form, form->current->rows));\n}\n\n \nstatic int\nVSC_Scroll_Half_Page_Forward(FORM *form)\n{\n  T((T_CALLED(\"VSC_Scroll_Half_Page_Forward(%p)\"), (void *)form));\n  returnCode(VSC_Generic(form, (form->current->rows + 1) / 2));\n}\n\n \nstatic int\nVSC_Scroll_Page_Backward(FORM *form)\n{\n  T((T_CALLED(\"VSC_Scroll_Page_Backward(%p)\"), (void *)form));\n  returnCode(VSC_Generic(form, -(form->current->rows)));\n}\n\n \nstatic int\nVSC_Scroll_Half_Page_Backward(FORM *form)\n{\n  T((T_CALLED(\"VSC_Scroll_Half_Page_Backward(%p)\"), (void *)form));\n  returnCode(VSC_Generic(form, -((form->current->rows + 1) / 2)));\n}\n \n\n \n\n \nstatic int\nHSC_Generic(FORM *form, int ncolumns)\n{\n  FIELD *field = form->current;\n  int res = E_REQUEST_DENIED;\n  int cols_to_go = (ncolumns > 0 ? ncolumns : -ncolumns);\n\n  if (ncolumns > 0)\n    {\n      if ((cols_to_go + form->begincol) > (field->dcols - field->cols))\n\tcols_to_go = field->dcols - field->cols - form->begincol;\n\n      if (cols_to_go > 0)\n\t{\n\t  form->curcol += cols_to_go;\n\t  form->begincol += cols_to_go;\n\t  res = E_OK;\n\t}\n    }\n  else\n    {\n      if (cols_to_go > form->begincol)\n\tcols_to_go = form->begincol;\n\n      if (cols_to_go > 0)\n\t{\n\t  form->curcol -= cols_to_go;\n\t  form->begincol -= cols_to_go;\n\t  res = E_OK;\n\t}\n    }\n  return (res);\n}\n \n\n \n\n \nstatic int\nHorizontal_Scrolling(int (*const fct) (FORM *), FORM *form)\n{\n  if (Single_Line_Field(form->current))\n    return fct(form);\n  else\n    return (E_REQUEST_DENIED);\n}\n\n \nstatic int\nHSC_Scroll_Char_Forward(FORM *form)\n{\n  T((T_CALLED(\"HSC_Scroll_Char_Forward(%p)\"), (void *)form));\n  returnCode(HSC_Generic(form, 1));\n}\n\n \nstatic int\nHSC_Scroll_Char_Backward(FORM *form)\n{\n  T((T_CALLED(\"HSC_Scroll_Char_Backward(%p)\"), (void *)form));\n  returnCode(HSC_Generic(form, -1));\n}\n\n \nstatic int\nHSC_Horizontal_Line_Forward(FORM *form)\n{\n  T((T_CALLED(\"HSC_Horizontal_Line_Forward(%p)\"), (void *)form));\n  returnCode(HSC_Generic(form, form->current->cols));\n}\n\n \nstatic int\nHSC_Horizontal_Half_Line_Forward(FORM *form)\n{\n  T((T_CALLED(\"HSC_Horizontal_Half_Line_Forward(%p)\"), (void *)form));\n  returnCode(HSC_Generic(form, (form->current->cols + 1) / 2));\n}\n\n \nstatic int\nHSC_Horizontal_Line_Backward(FORM *form)\n{\n  T((T_CALLED(\"HSC_Horizontal_Line_Backward(%p)\"), (void *)form));\n  returnCode(HSC_Generic(form, -(form->current->cols)));\n}\n\n \nstatic int\nHSC_Horizontal_Half_Line_Backward(FORM *form)\n{\n  T((T_CALLED(\"HSC_Horizontal_Half_Line_Backward(%p)\"), (void *)form));\n  returnCode(HSC_Generic(form, -((form->current->cols + 1) / 2)));\n}\n\n \n\n \n\n \nNCURSES_INLINE static bool\nIs_There_Room_For_A_Line(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *begin_of_last_line, *s;\n\n  Synchronize_Buffer(form);\n  begin_of_last_line = Address_Of_Row_In_Buffer(field, (field->drows - 1));\n  s = After_End_Of_Data(begin_of_last_line, field->dcols);\n  return ((s == begin_of_last_line) ? TRUE : FALSE);\n}\n\n \nNCURSES_INLINE static bool\nIs_There_Room_For_A_Char_In_Line(FORM *form)\n{\n  int last_char_in_line;\n\n  wmove(form->w, form->currow, form->current->dcols - 1);\n  last_char_in_line = (int)(winch(form->w) & A_CHARTEXT);\n  wmove(form->w, form->currow, form->curcol);\n  return (((last_char_in_line == form->current->pad) ||\n\t   is_blank(last_char_in_line)) ? TRUE : FALSE);\n}\n\n#define There_Is_No_Room_For_A_Char_In_Line(f) \\\n  !Is_There_Room_For_A_Char_In_Line(f)\n\n \nstatic int\nInsert_String(FORM *form, int row, FIELD_CELL *txt, int len)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *bp = Address_Of_Row_In_Buffer(field, row);\n  int datalen = (int)(After_End_Of_Data(bp, field->dcols) - bp);\n  int freelen = field->dcols - datalen;\n  int requiredlen = len + 1;\n  int result = E_REQUEST_DENIED;\n\n  if (freelen >= requiredlen)\n    {\n      wmove(form->w, row, 0);\n      myINSNSTR(form->w, txt, len);\n      wmove(form->w, row, len);\n      myINSNSTR(form->w, &myBLANK, 1);\n      result = E_OK;\n    }\n  else\n    {\n       \n      if ((row == (field->drows - 1)) && Growable(field))\n\t{\n\t  if (!Field_Grown(field, 1))\n\t    return (E_SYSTEM_ERROR);\n\t   \n\t  bp = Address_Of_Row_In_Buffer(field, row);\n\t}\n\n      if (row < (field->drows - 1))\n\t{\n\t  FIELD_CELL *split;\n\n\t  split =\n\t    After_Last_Whitespace_Character(bp,\n\t\t\t\t\t    (int)(Get_Start_Of_Data(bp\n\t\t\t\t\t\t\t\t    + field->dcols\n\t\t\t\t\t\t\t\t    - requiredlen,\n\t\t\t\t\t\t\t\t    requiredlen)\n\t\t\t\t\t\t  - bp));\n\t   \n\t  datalen = (int)(split - bp);\t \n\t  freelen = field->dcols - (datalen + freelen);\t\t \n\n\t  if ((result = Insert_String(form, row + 1, split, freelen)) == E_OK)\n\t    {\n\t      wmove(form->w, row, datalen);\n\t      wclrtoeol(form->w);\n\t      wmove(form->w, row, 0);\n\t      myINSNSTR(form->w, txt, len);\n\t      wmove(form->w, row, len);\n\t      myINSNSTR(form->w, &myBLANK, 1);\n\t      return E_OK;\n\t    }\n\t}\n    }\n  return (result);\n}\n\n \nstatic int\nWrapping_Not_Necessary_Or_Wrapping_Ok(FORM *form)\n{\n  FIELD *field = form->current;\n  int result = E_REQUEST_DENIED;\n  bool Last_Row = ((field->drows - 1) == form->currow);\n\n  if ((Field_Has_Option(field, O_WRAP)) &&\t \n      (!Single_Line_Field(field)) &&\t \n      (There_Is_No_Room_For_A_Char_In_Line(form)) &&\t \n      (!Last_Row || Growable(field)))\t \n    {\n      FIELD_CELL *bp;\n      FIELD_CELL *split;\n      int chars_to_be_wrapped;\n      int chars_to_remain_on_line;\n\n      if (Last_Row)\n\t{\n\t   \n\t  if (!Field_Grown(field, 1))\n\t    return E_SYSTEM_ERROR;\n\t}\n      bp = Address_Of_Current_Row_In_Buffer(form);\n      Window_To_Buffer(form, field);\n      split = After_Last_Whitespace_Character(bp, field->dcols);\n       \n      chars_to_remain_on_line = (int)(split - bp);\n      chars_to_be_wrapped = field->dcols - chars_to_remain_on_line;\n      if (chars_to_remain_on_line > 0)\n\t{\n\t  if ((result = Insert_String(form, form->currow + 1, split,\n\t\t\t\t      chars_to_be_wrapped)) == E_OK)\n\t    {\n\t      wmove(form->w, form->currow, chars_to_remain_on_line);\n\t      wclrtoeol(form->w);\n\t      if (form->curcol >= chars_to_remain_on_line)\n\t\t{\n\t\t  form->currow++;\n\t\t  form->curcol -= chars_to_remain_on_line;\n\t\t}\n\t      return E_OK;\n\t    }\n\t}\n      else\n\treturn E_OK;\n      if (result != E_OK)\n\t{\n\t  DeleteChar(form);\n\t  Window_To_Buffer(form, field);\n\t  result = E_REQUEST_DENIED;\n\t}\n    }\n  else\n    result = E_OK;\t\t \n  return (result);\n}\n\n \n\n \nstatic int\nField_Editing(int (*const fct) (FORM *), FORM *form)\n{\n  int res = E_REQUEST_DENIED;\n\n   \n  if ((fct == FE_Delete_Previous) &&\n      ((unsigned)form->opts & O_BS_OVERLOAD) &&\n      First_Position_In_Current_Field(form))\n    {\n      res = Inter_Field_Navigation(FN_Previous_Field, form);\n    }\n  else\n    {\n      if (fct == FE_New_Line)\n\t{\n\t  if (((unsigned)form->opts & O_NL_OVERLOAD) &&\n\t      First_Position_In_Current_Field(form))\n\t    {\n\t      res = Inter_Field_Navigation(FN_Next_Field, form);\n\t    }\n\t  else\n\t     \n\t    res = fct(form);\n\t}\n      else\n\t{\n\t   \n\t  if ((unsigned)form->current->opts & O_EDIT)\n\t    {\n\t      res = fct(form);\n\t      if (res == E_OK)\n\t\tSetStatus(form, _WINDOW_MODIFIED);\n\t    }\n\t}\n    }\n  return res;\n}\n\n \nstatic int\nFE_New_Line(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *bp, *t;\n  bool Last_Row = ((field->drows - 1) == form->currow);\n\n  T((T_CALLED(\"FE_New_Line(%p)\"), (void *)form));\n  if (form->status & _OVLMODE)\n    {\n      if (Last_Row &&\n\t  (!(Growable(field) && !Single_Line_Field(field))))\n\t{\n\t  if (!((unsigned)form->opts & O_NL_OVERLOAD))\n\t    returnCode(E_REQUEST_DENIED);\n\t  wmove(form->w, form->currow, form->curcol);\n\t  wclrtoeol(form->w);\n\t   \n\t  SetStatus(form, _WINDOW_MODIFIED);\n\t  returnCode(Inter_Field_Navigation(FN_Next_Field, form));\n\t}\n      else\n\t{\n\t  if (Last_Row && !Field_Grown(field, 1))\n\t    {\n\t       \n\t      returnCode(E_SYSTEM_ERROR);\n\t    }\n\t  wmove(form->w, form->currow, form->curcol);\n\t  wclrtoeol(form->w);\n\t  form->currow++;\n\t  form->curcol = 0;\n\t  SetStatus(form, _WINDOW_MODIFIED);\n\t  returnCode(E_OK);\n\t}\n    }\n  else\n    {\n       \n      if (Last_Row &&\n\t  !(Growable(field) && !Single_Line_Field(field)))\n\t{\n\t  if (!((unsigned)form->opts & O_NL_OVERLOAD))\n\t    returnCode(E_REQUEST_DENIED);\n\t  returnCode(Inter_Field_Navigation(FN_Next_Field, form));\n\t}\n      else\n\t{\n\t  bool May_Do_It = !Last_Row && Is_There_Room_For_A_Line(form);\n\n\t  if (!(May_Do_It || Growable(field)))\n\t    returnCode(E_REQUEST_DENIED);\n\t  if (!May_Do_It && !Field_Grown(field, 1))\n\t    returnCode(E_SYSTEM_ERROR);\n\n\t  bp = Address_Of_Current_Position_In_Buffer(form);\n\t  t = After_End_Of_Data(bp, field->dcols - form->curcol);\n\t  wmove(form->w, form->currow, form->curcol);\n\t  wclrtoeol(form->w);\n\t  form->currow++;\n\t  form->curcol = 0;\n\t  wmove(form->w, form->currow, form->curcol);\n\t  winsertln(form->w);\n\t  myADDNSTR(form->w, bp, (int)(t - bp));\n\t  SetStatus(form, _WINDOW_MODIFIED);\n\t  returnCode(E_OK);\n\t}\n    }\n}\n\n \nstatic int\nFE_Insert_Character(FORM *form)\n{\n  FIELD *field = form->current;\n  int result = E_REQUEST_DENIED;\n\n  T((T_CALLED(\"FE_Insert_Character(%p)\"), (void *)form));\n  if (Check_Char(form, field, field->type, (int)C_BLANK,\n\t\t (TypeArgument *)(field->arg)))\n    {\n      bool There_Is_Room = Is_There_Room_For_A_Char_In_Line(form);\n\n      if (There_Is_Room ||\n\t  ((Single_Line_Field(field) && Growable(field))))\n\t{\n\t  if (!There_Is_Room && !Field_Grown(field, 1))\n\t    result = E_SYSTEM_ERROR;\n\t  else\n\t    {\n\t      winsch(form->w, (chtype)C_BLANK);\n\t      result = Wrapping_Not_Necessary_Or_Wrapping_Ok(form);\n\t    }\n\t}\n    }\n  returnCode(result);\n}\n\n \nstatic int\nFE_Insert_Line(FORM *form)\n{\n  FIELD *field = form->current;\n  int result = E_REQUEST_DENIED;\n\n  T((T_CALLED(\"FE_Insert_Line(%p)\"), (void *)form));\n  if (Check_Char(form, field,\n\t\t field->type, (int)C_BLANK, (TypeArgument *)(field->arg)))\n    {\n      bool Maybe_Done = (form->currow != (field->drows - 1)) &&\n      Is_There_Room_For_A_Line(form);\n\n      if (!Single_Line_Field(field) &&\n\t  (Maybe_Done || Growable(field)))\n\t{\n\t  if (!Maybe_Done && !Field_Grown(field, 1))\n\t    result = E_SYSTEM_ERROR;\n\t  else\n\t    {\n\t      form->curcol = 0;\n\t      winsertln(form->w);\n\t      result = E_OK;\n\t    }\n\t}\n    }\n  returnCode(result);\n}\n\n \nstatic int\nFE_Delete_Character(FORM *form)\n{\n  T((T_CALLED(\"FE_Delete_Character(%p)\"), (void *)form));\n  DeleteChar(form);\n  returnCode(E_OK);\n}\n\n \nstatic int\nFE_Delete_Previous(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"FE_Delete_Previous(%p)\"), (void *)form));\n  if (First_Position_In_Current_Field(form))\n    returnCode(E_REQUEST_DENIED);\n\n  if ((--(form->curcol)) < 0)\n    {\n      FIELD_CELL *this_line, *prev_line, *prev_end, *this_end;\n      int this_row = form->currow;\n\n      form->curcol++;\n      if (form->status & _OVLMODE)\n\treturnCode(E_REQUEST_DENIED);\n\n      prev_line = Address_Of_Row_In_Buffer(field, (form->currow - 1));\n      this_line = Address_Of_Row_In_Buffer(field, (form->currow));\n      Synchronize_Buffer(form);\n      prev_end = After_End_Of_Data(prev_line, field->dcols);\n      this_end = After_End_Of_Data(this_line, field->dcols);\n      if ((int)(this_end - this_line) >\n\t  (field->cols - (int)(prev_end - prev_line)))\n\treturnCode(E_REQUEST_DENIED);\n      wmove(form->w, form->currow, form->curcol);\n      wdeleteln(form->w);\n      Adjust_Cursor_Position(form, prev_end);\n       \n      if (form->currow == this_row && this_row > 0)\n\t{\n\t  form->currow -= 1;\n\t  form->curcol = field->dcols - 1;\n\t  DeleteChar(form);\n\t}\n      else\n\t{\n\t  wmove(form->w, form->currow, form->curcol);\n\t  myADDNSTR(form->w, this_line, (int)(this_end - this_line));\n\t}\n    }\n  else\n    {\n      DeleteChar(form);\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nFE_Delete_Line(FORM *form)\n{\n  T((T_CALLED(\"FE_Delete_Line(%p)\"), (void *)form));\n  form->curcol = 0;\n  wdeleteln(form->w);\n  returnCode(E_OK);\n}\n\n \nstatic int\nFE_Delete_Word(FORM *form)\n{\n  FIELD *field = form->current;\n  FIELD_CELL *bp = Address_Of_Current_Row_In_Buffer(form);\n  FIELD_CELL *ep = bp + field->dcols;\n  FIELD_CELL *cp = bp + form->curcol;\n  FIELD_CELL *s;\n\n  T((T_CALLED(\"FE_Delete_Word(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  if (ISBLANK(*cp))\n    returnCode(E_REQUEST_DENIED);\t \n\n   \n  Adjust_Cursor_Position(form,\n\t\t\t After_Last_Whitespace_Character(bp, form->curcol));\n  wmove(form->w, form->currow, form->curcol);\n  wclrtoeol(form->w);\n\n   \n  s = Get_First_Whitespace_Character(cp, (int)(ep - cp));\n   \n  s = Get_Start_Of_Data(s, (int)(ep - s));\n  if ((s != cp) && !ISBLANK(*s))\n    {\n       \n      myADDNSTR(form->w, s, (int)(s - After_End_Of_Data(s, (int)(ep - s))));\n    }\n  returnCode(E_OK);\n}\n\n \nstatic int\nFE_Clear_To_End_Of_Line(FORM *form)\n{\n  T((T_CALLED(\"FE_Clear_To_End_Of_Line(%p)\"), (void *)form));\n  wmove(form->w, form->currow, form->curcol);\n  wclrtoeol(form->w);\n  returnCode(E_OK);\n}\n\n \nstatic int\nFE_Clear_To_End_Of_Field(FORM *form)\n{\n  T((T_CALLED(\"FE_Clear_To_End_Of_Field(%p)\"), (void *)form));\n  wmove(form->w, form->currow, form->curcol);\n  wclrtobot(form->w);\n  returnCode(E_OK);\n}\n\n \nstatic int\nFE_Clear_Field(FORM *form)\n{\n  T((T_CALLED(\"FE_Clear_Field(%p)\"), (void *)form));\n  form->currow = form->curcol = 0;\n  werase(form->w);\n  returnCode(E_OK);\n}\n \n\n \n\n \nstatic int\nEM_Overlay_Mode(FORM *form)\n{\n  T((T_CALLED(\"EM_Overlay_Mode(%p)\"), (void *)form));\n  SetStatus(form, _OVLMODE);\n  returnCode(E_OK);\n}\n\n \nstatic int\nEM_Insert_Mode(FORM *form)\n{\n  T((T_CALLED(\"EM_Insert_Mode(%p)\"), (void *)form));\n  ClrStatus(form, _OVLMODE);\n  returnCode(E_OK);\n}\n\n \n\n \n\n \nstatic bool\nNext_Choice(FORM *form, FIELDTYPE *typ, FIELD *field, TypeArgument *argp)\n{\n  if (!typ || !(typ->status & _HAS_CHOICE))\n    return FALSE;\n\n  if (typ->status & _LINKED_TYPE)\n    {\n      assert(argp);\n      return (\n\t       Next_Choice(form, typ->left, field, argp->left) ||\n\t       Next_Choice(form, typ->right, field, argp->right));\n    }\n  else\n    {\n#if NCURSES_INTEROP_FUNCS\n      assert(typ->enum_next.onext);\n      if (typ->status & _GENERIC)\n\treturn typ->enum_next.gnext(form, field, (void *)argp);\n      else\n\treturn typ->enum_next.onext(field, (void *)argp);\n#else\n      assert(typ->next);\n      return typ->next(field, (void *)argp);\n#endif\n    }\n}\n\n \nstatic bool\nPrevious_Choice(FORM *form, FIELDTYPE *typ, FIELD *field, TypeArgument *argp)\n{\n  if (!typ || !(typ->status & _HAS_CHOICE))\n    return FALSE;\n\n  if (typ->status & _LINKED_TYPE)\n    {\n      assert(argp);\n      return (\n\t       Previous_Choice(form, typ->left, field, argp->left) ||\n\t       Previous_Choice(form, typ->right, field, argp->right));\n    }\n  else\n    {\n#if NCURSES_INTEROP_FUNCS\n      assert(typ->enum_prev.oprev);\n      if (typ->status & _GENERIC)\n\treturn typ->enum_prev.gprev(form, field, (void *)argp);\n      else\n\treturn typ->enum_prev.oprev(field, (void *)argp);\n#else\n      assert(typ->prev);\n      return typ->prev(field, (void *)argp);\n#endif\n    }\n}\n \n\n \n\n \nstatic int\nCR_Next_Choice(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"CR_Next_Choice(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  returnCode((Next_Choice(form, field->type, field, (TypeArgument *)(field->arg)))\n\t     ? E_OK\n\t     : E_REQUEST_DENIED);\n}\n\n \nstatic int\nCR_Previous_Choice(FORM *form)\n{\n  FIELD *field = form->current;\n\n  T((T_CALLED(\"CR_Previous_Choice(%p)\"), (void *)form));\n  Synchronize_Buffer(form);\n  returnCode((Previous_Choice(form, field->type, field, (TypeArgument *)(field->arg)))\n\t     ? E_OK\n\t     : E_REQUEST_DENIED);\n}\n \n\n \n\n \nstatic bool\nCheck_Field(FORM *form, FIELDTYPE *typ, FIELD *field, TypeArgument *argp)\n{\n  if (typ)\n    {\n      if (Field_Has_Option(field, O_NULLOK))\n\t{\n\t  FIELD_CELL *bp = field->buf;\n\n\t  assert(bp);\n\t  while (ISBLANK(*bp))\n\t    {\n\t      bp++;\n\t    }\n\t  if (CharOf(*bp) == 0)\n\t    return TRUE;\n\t}\n\n      if (typ->status & _LINKED_TYPE)\n\t{\n\t  assert(argp);\n\t  return (\n\t\t   Check_Field(form, typ->left, field, argp->left) ||\n\t\t   Check_Field(form, typ->right, field, argp->right));\n\t}\n      else\n\t{\n#if NCURSES_INTEROP_FUNCS\n\t  if (typ->fieldcheck.ofcheck)\n\t    {\n\t      if (typ->status & _GENERIC)\n\t\treturn typ->fieldcheck.gfcheck(form, field, (void *)argp);\n\t      else\n\t\treturn typ->fieldcheck.ofcheck(field, (void *)argp);\n\t    }\n#else\n\t  if (typ->fcheck)\n\t    return typ->fcheck(field, (void *)argp);\n#endif\n\t}\n    }\n  return TRUE;\n}\n\n \nFORM_EXPORT(bool)\n_nc_Internal_Validation(FORM *form)\n{\n  FIELD *field;\n\n  field = form->current;\n\n  Synchronize_Buffer(form);\n  if ((form->status & _FCHECK_REQUIRED) ||\n      (!(Field_Has_Option(field, O_PASSOK))))\n    {\n      if (!Check_Field(form, field->type, field, (TypeArgument *)(field->arg)))\n\treturn FALSE;\n      ClrStatus(form, _FCHECK_REQUIRED);\n      SetStatus(field, _CHANGED);\n      Synchronize_Linked_Fields(field);\n    }\n  return TRUE;\n}\n \n\n \n\n \nstatic int\nFV_Validation(FORM *form)\n{\n  T((T_CALLED(\"FV_Validation(%p)\"), (void *)form));\n  if (_nc_Internal_Validation(form))\n    returnCode(E_OK);\n  else\n    returnCode(E_INVALID_FIELD);\n}\n \n\n \n\n \nNCURSES_INLINE static FIELD *\nNext_Field_On_Page(FIELD *field)\n{\n  FORM *form = field->form;\n  FIELD **field_on_page = &form->field[field->index];\n  FIELD **first_on_page = &form->field[form->page[form->curpage].pmin];\n  FIELD **last_on_page = &form->field[form->page[form->curpage].pmax];\n\n  do\n    {\n      field_on_page =\n\t(field_on_page == last_on_page) ? first_on_page : field_on_page + 1;\n      if (Field_Is_Selectable(*field_on_page))\n\tbreak;\n    }\n  while (field != (*field_on_page));\n  return (*field_on_page);\n}\n\n \nFORM_EXPORT(FIELD *)\n_nc_First_Active_Field(FORM *form)\n{\n  FIELD **last_on_page = &form->field[form->page[form->curpage].pmax];\n  FIELD *proposed = Next_Field_On_Page(*last_on_page);\n\n  if (proposed == *last_on_page)\n    {\n       \n      if (Field_Is_Not_Selectable(proposed))\n\t{\n\t  FIELD **field = &form->field[proposed->index];\n\t  FIELD **first = &form->field[form->page[form->curpage].pmin];\n\n\t  do\n\t    {\n\t      field = (field == last_on_page) ? first : field + 1;\n\t      if (Field_Has_Option(*field, O_VISIBLE))\n\t\tbreak;\n\t    }\n\t  while (proposed != (*field));\n\n\t  proposed = *field;\n\n\t  if ((proposed == *last_on_page) &&\n\t      !((unsigned)proposed->opts & O_VISIBLE))\n\t    {\n\t       \n\t      proposed = *first;\n\t    }\n\t}\n    }\n  return (proposed);\n}\n\n \nNCURSES_INLINE static FIELD *\nPrevious_Field_On_Page(FIELD *field)\n{\n  FORM *form = field->form;\n  FIELD **field_on_page = &form->field[field->index];\n  FIELD **first_on_page = &form->field[form->page[form->curpage].pmin];\n  FIELD **last_on_page = &form->field[form->page[form->curpage].pmax];\n\n  do\n    {\n      field_on_page =\n\t(field_on_page == first_on_page) ? last_on_page : field_on_page - 1;\n      if (Field_Is_Selectable(*field_on_page))\n\tbreak;\n    }\n  while (field != (*field_on_page));\n\n  return (*field_on_page);\n}\n\n \nNCURSES_INLINE static FIELD *\nSorted_Next_Field(FIELD *field)\n{\n  FIELD *field_on_page = field;\n\n  do\n    {\n      field_on_page = field_on_page->snext;\n      if (Field_Is_Selectable(field_on_page))\n\tbreak;\n    }\n  while (field_on_page != field);\n\n  return (field_on_page);\n}\n\n \nNCURSES_INLINE static FIELD *\nSorted_Previous_Field(FIELD *field)\n{\n  FIELD *field_on_page = field;\n\n  do\n    {\n      field_on_page = field_on_page->sprev;\n      if (Field_Is_Selectable(field_on_page))\n\tbreak;\n    }\n  while (field_on_page != field);\n\n  return (field_on_page);\n}\n\n \nNCURSES_INLINE static FIELD *\nLeft_Neighbor_Field(FIELD *field)\n{\n  FIELD *field_on_page = field;\n\n   \n  do\n    {\n      field_on_page = Sorted_Previous_Field(field_on_page);\n    }\n  while (field_on_page->frow != field->frow);\n\n  return (field_on_page);\n}\n\n \nNCURSES_INLINE static FIELD *\nRight_Neighbor_Field(FIELD *field)\n{\n  FIELD *field_on_page = field;\n\n   \n  do\n    {\n      field_on_page = Sorted_Next_Field(field_on_page);\n    }\n  while (field_on_page->frow != field->frow);\n\n  return (field_on_page);\n}\n\n \nstatic FIELD *\nUpper_Neighbor_Field(FIELD *field)\n{\n  FIELD *field_on_page = field;\n  int frow = field->frow;\n  int fcol = field->fcol;\n\n   \n  do\n    {\n      field_on_page = Sorted_Previous_Field(field_on_page);\n    }\n  while (field_on_page->frow == frow && field_on_page->fcol != fcol);\n\n  if (field_on_page->frow != frow)\n    {\n       \n      frow = field_on_page->frow;\n\n       \n      while (field_on_page->frow == frow && field_on_page->fcol > fcol)\n\tfield_on_page = Sorted_Previous_Field(field_on_page);\n\n       \n      if (field_on_page->frow != frow)\n\tfield_on_page = Sorted_Next_Field(field_on_page);\n    }\n\n  return (field_on_page);\n}\n\n \nstatic FIELD *\nDown_Neighbor_Field(FIELD *field)\n{\n  FIELD *field_on_page = field;\n  int frow = field->frow;\n  int fcol = field->fcol;\n\n   \n  do\n    {\n      field_on_page = Sorted_Next_Field(field_on_page);\n    }\n  while (field_on_page->frow == frow && field_on_page->fcol != fcol);\n\n  if (field_on_page->frow != frow)\n    {\n       \n      frow = field_on_page->frow;\n\n       \n      while (field_on_page->frow == frow && field_on_page->fcol < fcol)\n\tfield_on_page = Sorted_Next_Field(field_on_page);\n\n       \n      if (field_on_page->frow != frow)\n\tfield_on_page = Sorted_Previous_Field(field_on_page);\n    }\n\n  return (field_on_page);\n}\n\n \n\n \nstatic int\nInter_Field_Navigation(int (*const fct) (FORM *), FORM *form)\n{\n  int res;\n\n  if (!_nc_Internal_Validation(form))\n    res = E_INVALID_FIELD;\n  else\n    {\n      Call_Hook(form, fieldterm);\n      res = fct(form);\n      Call_Hook(form, fieldinit);\n    }\n  return res;\n}\n\n \nstatic int\nFN_Next_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Next_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Next_Field_On_Page(form->current)));\n}\n\n \nstatic int\nFN_Previous_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Previous_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Previous_Field_On_Page(form->current)));\n}\n\n \nstatic int\nFN_First_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_First_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Next_Field_On_Page(form->field[form->page[form->curpage].pmax])));\n}\n\n \nstatic int\nFN_Last_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Last_Field(%p)\"), (void *)form));\n  returnCode(\n\t      _nc_Set_Current_Field(form,\n\t\t\t\t    Previous_Field_On_Page(form->field[form->page[form->curpage].pmin])));\n}\n\n \nstatic int\nFN_Sorted_Next_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Sorted_Next_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Sorted_Next_Field(form->current)));\n}\n\n \nstatic int\nFN_Sorted_Previous_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Sorted_Previous_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Sorted_Previous_Field(form->current)));\n}\n\n \nstatic int\nFN_Sorted_First_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Sorted_First_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Sorted_Next_Field(form->field[form->page[form->curpage].smax])));\n}\n\n \nstatic int\nFN_Sorted_Last_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Sorted_Last_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Sorted_Previous_Field(form->field[form->page[form->curpage].smin])));\n}\n\n \nstatic int\nFN_Left_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Left_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Left_Neighbor_Field(form->current)));\n}\n\n \nstatic int\nFN_Right_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Right_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Right_Neighbor_Field(form->current)));\n}\n\n \nstatic int\nFN_Up_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Up_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Upper_Neighbor_Field(form->current)));\n}\n\n \nstatic int\nFN_Down_Field(FORM *form)\n{\n  T((T_CALLED(\"FN_Down_Field(%p)\"), (void *)form));\n  returnCode(_nc_Set_Current_Field(form,\n\t\t\t\t   Down_Neighbor_Field(form->current)));\n}\n \n\n \n\n \nFORM_EXPORT(int)\n_nc_Set_Form_Page(FORM *form, int page, FIELD *field)\n{\n  int res = E_OK;\n\n  if ((form->curpage != page))\n    {\n      FIELD *last_field, *field_on_page;\n\n      werase(Get_Form_Window(form));\n      form->curpage = (short)page;\n      last_field = field_on_page = form->field[form->page[page].smin];\n      do\n\t{\n\t  if ((unsigned)field_on_page->opts & O_VISIBLE)\n\t    if ((res = Display_Field(field_on_page)) != E_OK)\n\t      return (res);\n\t  field_on_page = field_on_page->snext;\n\t}\n      while (field_on_page != last_field);\n\n      if (field)\n\tres = _nc_Set_Current_Field(form, field);\n      else\n\t \n\tres = FN_First_Field(form);\n    }\n  return (res);\n}\n\n \nNCURSES_INLINE static int\nNext_Page_Number(const FORM *form)\n{\n  return (form->curpage + 1) % form->maxpage;\n}\n\n \nNCURSES_INLINE static int\nPrevious_Page_Number(const FORM *form)\n{\n  return (form->curpage != 0 ? form->curpage - 1 : form->maxpage - 1);\n}\n\n \n\n \nstatic int\nPage_Navigation(int (*const fct) (FORM *), FORM *form)\n{\n  int res;\n\n  if (!_nc_Internal_Validation(form))\n    res = E_INVALID_FIELD;\n  else\n    {\n      Call_Hook(form, fieldterm);\n      Call_Hook(form, formterm);\n      res = fct(form);\n      Call_Hook(form, forminit);\n      Call_Hook(form, fieldinit);\n    }\n  return res;\n}\n\n \nstatic int\nPN_Next_Page(FORM *form)\n{\n  T((T_CALLED(\"PN_Next_Page(%p)\"), (void *)form));\n  returnCode(_nc_Set_Form_Page(form, Next_Page_Number(form), (FIELD *)0));\n}\n\n \nstatic int\nPN_Previous_Page(FORM *form)\n{\n  T((T_CALLED(\"PN_Previous_Page(%p)\"), (void *)form));\n  returnCode(_nc_Set_Form_Page(form, Previous_Page_Number(form), (FIELD *)0));\n}\n\n \nstatic int\nPN_First_Page(FORM *form)\n{\n  T((T_CALLED(\"PN_First_Page(%p)\"), (void *)form));\n  returnCode(_nc_Set_Form_Page(form, 0, (FIELD *)0));\n}\n\n \nstatic int\nPN_Last_Page(FORM *form)\n{\n  T((T_CALLED(\"PN_Last_Page(%p)\"), (void *)form));\n  returnCode(_nc_Set_Form_Page(form, form->maxpage - 1, (FIELD *)0));\n}\n\n \n\n \n\n# if USE_WIDEC_SUPPORT\n \nstatic int\nData_Entry_w(FORM *form, wchar_t c)\n{\n  FIELD *field = form->current;\n  int result = E_REQUEST_DENIED;\n\n  T((T_CALLED(\"Data_Entry(%p,%s)\"), (void *)form, _tracechtype((chtype)c)));\n  if ((Field_Has_Option(field, O_EDIT))\n#if FIX_FORM_INACTIVE_BUG\n      && (Field_Has_Option(field, O_ACTIVE))\n#endif\n    )\n    {\n      wchar_t given[2];\n      cchar_t temp_ch;\n\n      given[0] = c;\n      given[1] = 0;\n      setcchar(&temp_ch, given, 0, 0, (void *)0);\n      if ((Field_Has_Option(field, O_BLANK)) &&\n\t  First_Position_In_Current_Field(form) &&\n\t  !(form->status & _FCHECK_REQUIRED) &&\n\t  !(form->status & _WINDOW_MODIFIED))\n\twerase(form->w);\n\n      if (form->status & _OVLMODE)\n\t{\n\t  wadd_wch(form->w, &temp_ch);\n\t}\n      else\n\t \n\t{\n\t  bool There_Is_Room = Is_There_Room_For_A_Char_In_Line(form);\n\n\t  if (!(There_Is_Room ||\n\t\t((Single_Line_Field(field) && Growable(field)))))\n\t    RETURN(E_REQUEST_DENIED);\n\n\t  if (!There_Is_Room && !Field_Grown(field, 1))\n\t    RETURN(E_SYSTEM_ERROR);\n\n\t  wins_wch(form->w, &temp_ch);\n\t}\n\n      if ((result = Wrapping_Not_Necessary_Or_Wrapping_Ok(form)) == E_OK)\n\t{\n\t  bool End_Of_Field = (((field->drows - 1) == form->currow) &&\n\t\t\t       ((field->dcols - 1) == form->curcol));\n\n\t  form->status |= _WINDOW_MODIFIED;\n\t  if (End_Of_Field && !Growable(field) && (Field_Has_Option(field, O_AUTOSKIP)))\n\t    result = Inter_Field_Navigation(FN_Next_Field, form);\n\t  else\n\t    {\n\t      if (End_Of_Field && Growable(field) && !Field_Grown(field, 1))\n\t\tresult = E_SYSTEM_ERROR;\n\t      else\n\t\t{\n\t\t   \n\t\t  if (WINDOW_EXT(form->w, addch_used) == 0)\n\t\t    IFN_Next_Character(form);\n\n\t\t  result = E_OK;\n\t\t}\n\t    }\n\t}\n    }\n  RETURN(result);\n}\n# endif\n\n \nstatic int\nData_Entry(FORM *form, int c)\n{\n  FIELD *field = form->current;\n  int result = E_REQUEST_DENIED;\n\n  T((T_CALLED(\"Data_Entry(%p,%s)\"), (void *)form, _tracechtype((chtype)c)));\n  if ((Field_Has_Option(field, O_EDIT))\n#if FIX_FORM_INACTIVE_BUG\n      && (Field_Has_Option(field, O_ACTIVE))\n#endif\n    )\n    {\n      if ((Field_Has_Option(field, O_BLANK)) &&\n\t  First_Position_In_Current_Field(form) &&\n\t  !(form->status & _FCHECK_REQUIRED) &&\n\t  !(form->status & _WINDOW_MODIFIED))\n\twerase(form->w);\n\n      if (form->status & _OVLMODE)\n\t{\n\t  waddch(form->w, (chtype)c);\n\t}\n      else\n\t \n\t{\n\t  bool There_Is_Room = Is_There_Room_For_A_Char_In_Line(form);\n\n\t  if (!(There_Is_Room ||\n\t\t((Single_Line_Field(field) && Growable(field)))))\n\t    RETURN(E_REQUEST_DENIED);\n\n\t  if (!There_Is_Room && !Field_Grown(field, 1))\n\t    RETURN(E_SYSTEM_ERROR);\n\n\t  winsch(form->w, (chtype)c);\n\t}\n\n      if ((result = Wrapping_Not_Necessary_Or_Wrapping_Ok(form)) == E_OK)\n\t{\n\t  bool End_Of_Field = (((field->drows - 1) == form->currow) &&\n\t\t\t       ((field->dcols - 1) == form->curcol));\n\n\t  if (Field_Has_Option(field, O_EDGE_INSERT_STAY))\n\t    move_after_insert = !!(form->curcol\n\t\t\t\t   - form->begincol\n\t\t\t\t   - field->cols\n\t\t\t\t   + 1);\n\n\t  SetStatus(form, _WINDOW_MODIFIED);\n\t  if (End_Of_Field && !Growable(field) && (Field_Has_Option(field, O_AUTOSKIP)))\n\t    result = Inter_Field_Navigation(FN_Next_Field, form);\n\t  else\n\t    {\n\t      if (End_Of_Field && Growable(field) && !Field_Grown(field, 1))\n\t\tresult = E_SYSTEM_ERROR;\n\t      else\n\t\t{\n#if USE_WIDEC_SUPPORT\n\t\t   \n\t\t  if (WINDOW_EXT(form->w, addch_used) == 0)\n\t\t    IFN_Next_Character(form);\n#else\n\t\t  IFN_Next_Character(form);\n#endif\n\t\t  result = E_OK;\n\t\t}\n\t    }\n\t}\n    }\n  RETURN(result);\n}\n\n \ntypedef struct\n{\n  int keycode;\t\t\t \n  int (*cmd) (FORM *);\t\t \n}\nBinding_Info;\n\n \n#define ID_PN    (0x00000000)\t \n#define ID_FN    (0x00010000)\t \n#define ID_IFN   (0x00020000)\t \n#define ID_VSC   (0x00030000)\t \n#define ID_HSC   (0x00040000)\t \n#define ID_FE    (0x00050000)\t \n#define ID_EM    (0x00060000)\t \n#define ID_FV    (0x00070000)\t \n#define ID_CH    (0x00080000)\t \n#define ID_Mask  (0xffff0000)\n#define Key_Mask (0x0000ffff)\n#define ID_Shft  (16)\n\n \n \nstatic const Binding_Info bindings[MAX_FORM_COMMAND - MIN_FORM_COMMAND + 1] =\n{\n  { REQ_NEXT_PAGE    |ID_PN  ,PN_Next_Page},\n  { REQ_PREV_PAGE    |ID_PN  ,PN_Previous_Page},\n  { REQ_FIRST_PAGE   |ID_PN  ,PN_First_Page},\n  { REQ_LAST_PAGE    |ID_PN  ,PN_Last_Page},\n\n  { REQ_NEXT_FIELD   |ID_FN  ,FN_Next_Field},\n  { REQ_PREV_FIELD   |ID_FN  ,FN_Previous_Field},\n  { REQ_FIRST_FIELD  |ID_FN  ,FN_First_Field},\n  { REQ_LAST_FIELD   |ID_FN  ,FN_Last_Field},\n  { REQ_SNEXT_FIELD  |ID_FN  ,FN_Sorted_Next_Field},\n  { REQ_SPREV_FIELD  |ID_FN  ,FN_Sorted_Previous_Field},\n  { REQ_SFIRST_FIELD |ID_FN  ,FN_Sorted_First_Field},\n  { REQ_SLAST_FIELD  |ID_FN  ,FN_Sorted_Last_Field},\n  { REQ_LEFT_FIELD   |ID_FN  ,FN_Left_Field},\n  { REQ_RIGHT_FIELD  |ID_FN  ,FN_Right_Field},\n  { REQ_UP_FIELD     |ID_FN  ,FN_Up_Field},\n  { REQ_DOWN_FIELD   |ID_FN  ,FN_Down_Field},\n\n  { REQ_NEXT_CHAR    |ID_IFN ,IFN_Next_Character},\n  { REQ_PREV_CHAR    |ID_IFN ,IFN_Previous_Character},\n  { REQ_NEXT_LINE    |ID_IFN ,IFN_Next_Line},\n  { REQ_PREV_LINE    |ID_IFN ,IFN_Previous_Line},\n  { REQ_NEXT_WORD    |ID_IFN ,IFN_Next_Word},\n  { REQ_PREV_WORD    |ID_IFN ,IFN_Previous_Word},\n  { REQ_BEG_FIELD    |ID_IFN ,IFN_Beginning_Of_Field},\n  { REQ_END_FIELD    |ID_IFN ,IFN_End_Of_Field},\n  { REQ_BEG_LINE     |ID_IFN ,IFN_Beginning_Of_Line},\n  { REQ_END_LINE     |ID_IFN ,IFN_End_Of_Line},\n  { REQ_LEFT_CHAR    |ID_IFN ,IFN_Left_Character},\n  { REQ_RIGHT_CHAR   |ID_IFN ,IFN_Right_Character},\n  { REQ_UP_CHAR      |ID_IFN ,IFN_Up_Character},\n  { REQ_DOWN_CHAR    |ID_IFN ,IFN_Down_Character},\n\n  { REQ_NEW_LINE     |ID_FE  ,FE_New_Line},\n  { REQ_INS_CHAR     |ID_FE  ,FE_Insert_Character},\n  { REQ_INS_LINE     |ID_FE  ,FE_Insert_Line},\n  { REQ_DEL_CHAR     |ID_FE  ,FE_Delete_Character},\n  { REQ_DEL_PREV     |ID_FE  ,FE_Delete_Previous},\n  { REQ_DEL_LINE     |ID_FE  ,FE_Delete_Line},\n  { REQ_DEL_WORD     |ID_FE  ,FE_Delete_Word},\n  { REQ_CLR_EOL      |ID_FE  ,FE_Clear_To_End_Of_Line},\n  { REQ_CLR_EOF      |ID_FE  ,FE_Clear_To_End_Of_Field},\n  { REQ_CLR_FIELD    |ID_FE  ,FE_Clear_Field},\n\n  { REQ_OVL_MODE     |ID_EM  ,EM_Overlay_Mode},\n  { REQ_INS_MODE     |ID_EM  ,EM_Insert_Mode},\n\n  { REQ_SCR_FLINE    |ID_VSC ,VSC_Scroll_Line_Forward},\n  { REQ_SCR_BLINE    |ID_VSC ,VSC_Scroll_Line_Backward},\n  { REQ_SCR_FPAGE    |ID_VSC ,VSC_Scroll_Page_Forward},\n  { REQ_SCR_BPAGE    |ID_VSC ,VSC_Scroll_Page_Backward},\n  { REQ_SCR_FHPAGE   |ID_VSC ,VSC_Scroll_Half_Page_Forward},\n  { REQ_SCR_BHPAGE   |ID_VSC ,VSC_Scroll_Half_Page_Backward},\n\n  { REQ_SCR_FCHAR    |ID_HSC ,HSC_Scroll_Char_Forward},\n  { REQ_SCR_BCHAR    |ID_HSC ,HSC_Scroll_Char_Backward},\n  { REQ_SCR_HFLINE   |ID_HSC ,HSC_Horizontal_Line_Forward},\n  { REQ_SCR_HBLINE   |ID_HSC ,HSC_Horizontal_Line_Backward},\n  { REQ_SCR_HFHALF   |ID_HSC ,HSC_Horizontal_Half_Line_Forward},\n  { REQ_SCR_HBHALF   |ID_HSC ,HSC_Horizontal_Half_Line_Backward},\n\n  { REQ_VALIDATION   |ID_FV  ,FV_Validation},\n\n  { REQ_NEXT_CHOICE  |ID_CH  ,CR_Next_Choice},\n  { REQ_PREV_CHOICE  |ID_CH  ,CR_Previous_Choice}\n};\n \n\n \nFORM_EXPORT(int)\nform_driver(FORM *form, int c)\n{\n  const Binding_Info *BI = (Binding_Info *)0;\n  int res = E_UNKNOWN_COMMAND;\n\n  move_after_insert = TRUE;\n\n  T((T_CALLED(\"form_driver(%p,%d)\"), (void *)form, c));\n\n  if (!form)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (!(form->field) || !(form->current))\n    RETURN(E_NOT_CONNECTED);\n\n  assert(form->page);\n\n  if (c == FIRST_ACTIVE_MAGIC)\n    {\n      form->current = _nc_First_Active_Field(form);\n      RETURN(E_OK);\n    }\n\n  assert(form->current &&\n\t form->current->buf &&\n\t (form->current->form == form)\n    );\n\n  if (form->status & _IN_DRIVER)\n    RETURN(E_BAD_STATE);\n\n  if (!(form->status & _POSTED))\n    RETURN(E_NOT_POSTED);\n\n  if ((c >= MIN_FORM_COMMAND && c <= MAX_FORM_COMMAND) &&\n      ((bindings[c - MIN_FORM_COMMAND].keycode & Key_Mask) == c))\n    {\n      TR(TRACE_CALLS, (\"form_request %s\", form_request_name(c)));\n      BI = &(bindings[c - MIN_FORM_COMMAND]);\n    }\n\n  if (BI)\n    {\n      typedef int (*Generic_Method) (int (*const) (FORM *), FORM *);\n      static const Generic_Method Generic_Methods[] =\n      {\n\tPage_Navigation,\t \n\tInter_Field_Navigation,\t \n\tNULL,\t\t\t \n\tVertical_Scrolling,\t \n\tHorizontal_Scrolling,\t \n\tField_Editing,\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL\t\t\t \n      };\n      size_t nMethods = (sizeof(Generic_Methods) / sizeof(Generic_Methods[0]));\n      size_t method = (size_t)((BI->keycode >> ID_Shft) & 0xffff);\t \n\n      if ((method >= nMethods) || !(BI->cmd))\n\tres = E_SYSTEM_ERROR;\n      else\n\t{\n\t  Generic_Method fct = Generic_Methods[method];\n\n\t  if (fct)\n\t    {\n\t      res = fct(BI->cmd, form);\n\t    }\n\t  else\n\t    {\n\t      res = (BI->cmd) (form);\n\t    }\n\t}\n    }\n#ifdef NCURSES_MOUSE_VERSION\n  else if (KEY_MOUSE == c)\n    {\n      MEVENT event;\n      WINDOW *win = form->win ? form->win : StdScreen(Get_Form_Screen(form));\n      WINDOW *sub = form->sub ? form->sub : win;\n\n      getmouse(&event);\n      if ((event.bstate & (BUTTON1_CLICKED |\n\t\t\t   BUTTON1_DOUBLE_CLICKED |\n\t\t\t   BUTTON1_TRIPLE_CLICKED))\n\t  && wenclose(win, event.y, event.x))\n\t{\t\t\t \n\t  int ry = event.y, rx = event.x;\t \n\n\t  res = E_REQUEST_DENIED;\n\t  if (mouse_trafo(&ry, &rx, FALSE))\n\t    {\t\t\t \n\t      if (ry < sub->_begy)\n\t\t{\t\t \n\t\t  if (event.bstate & BUTTON1_CLICKED)\n\t\t    res = form_driver(form, REQ_PREV_FIELD);\n\t\t  else if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t    res = form_driver(form, REQ_PREV_PAGE);\n\t\t  else if (event.bstate & BUTTON1_TRIPLE_CLICKED)\n\t\t    res = form_driver(form, REQ_FIRST_FIELD);\n\t\t}\n\t      else if (ry > sub->_begy + sub->_maxy)\n\t\t{\t\t \n\t\t  if (event.bstate & BUTTON1_CLICKED)\n\t\t    res = form_driver(form, REQ_NEXT_FIELD);\n\t\t  else if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t    res = form_driver(form, REQ_NEXT_PAGE);\n\t\t  else if (event.bstate & BUTTON1_TRIPLE_CLICKED)\n\t\t    res = form_driver(form, REQ_LAST_FIELD);\n\t\t}\n\t      else if (wenclose(sub, event.y, event.x))\n\t\t{\t\t \n\t\t  ry = event.y;\n\t\t  rx = event.x;\n\t\t  if (wmouse_trafo(sub, &ry, &rx, FALSE))\n\t\t    {\n\t\t      int min_field = form->page[form->curpage].pmin;\n\t\t      int max_field = form->page[form->curpage].pmax;\n\t\t      int i;\n\n\t\t      for (i = min_field; i <= max_field; ++i)\n\t\t\t{\n\t\t\t  FIELD *field = form->field[i];\n\n\t\t\t  if (Field_Is_Selectable(field)\n\t\t\t      && Field_encloses(field, ry, rx) == E_OK)\n\t\t\t    {\n\t\t\t      res = _nc_Set_Current_Field(form, field);\n\t\t\t      if (res == E_OK)\n\t\t\t\tres = _nc_Position_Form_Cursor(form);\n\t\t\t      if (res == E_OK\n\t\t\t\t  && (event.bstate & BUTTON1_DOUBLE_CLICKED))\n\t\t\t\tres = E_UNKNOWN_COMMAND;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\tres = E_REQUEST_DENIED;\n    }\n#endif  \n  else if (!(c & (~(int)MAX_REGULAR_CHARACTER)))\n    {\n       \n#if USE_WIDEC_SUPPORT\n      if (!iscntrl(UChar(c)))\n#else\n      if (isprint(UChar(c)) &&\n\t  Check_Char(form, form->current, form->current->type, c,\n\t\t     (TypeArgument *)(form->current->arg)))\n#endif\n\tres = Data_Entry(form, c);\n    }\n  _nc_Refresh_Current_Field(form);\n  RETURN(res);\n}\n\n# if USE_WIDEC_SUPPORT\n \nFORM_EXPORT(int)\nform_driver_w(FORM *form, int type, wchar_t c)\n{\n  const Binding_Info *BI = (Binding_Info *)0;\n  int res = E_UNKNOWN_COMMAND;\n\n  T((T_CALLED(\"form_driver(%p,%d)\"), (void *)form, (int)c));\n\n  if (!form)\n    RETURN(E_BAD_ARGUMENT);\n\n  if (!(form->field))\n    RETURN(E_NOT_CONNECTED);\n\n  assert(form->page);\n\n  if (c == (wchar_t)FIRST_ACTIVE_MAGIC)\n    {\n      form->current = _nc_First_Active_Field(form);\n      RETURN(E_OK);\n    }\n\n  assert(form->current &&\n\t form->current->buf &&\n\t (form->current->form == form)\n    );\n\n  if (form->status & _IN_DRIVER)\n    RETURN(E_BAD_STATE);\n\n  if (!(form->status & _POSTED))\n    RETURN(E_NOT_POSTED);\n\n   \n  if (type == KEY_CODE_YES)\n    {\n      if ((c >= MIN_FORM_COMMAND && c <= MAX_FORM_COMMAND) &&\n\t  ((bindings[c - MIN_FORM_COMMAND].keycode & Key_Mask) == c))\n\tBI = &(bindings[c - MIN_FORM_COMMAND]);\n    }\n\n  if (BI)\n    {\n      typedef int (*Generic_Method) (int (*const) (FORM *), FORM *);\n      static const Generic_Method Generic_Methods[] =\n      {\n\tPage_Navigation,\t \n\tInter_Field_Navigation,\t \n\tNULL,\t\t\t \n\tVertical_Scrolling,\t \n\tHorizontal_Scrolling,\t \n\tField_Editing,\t\t \n\tNULL,\t\t\t \n\tNULL,\t\t\t \n\tNULL\t\t\t \n      };\n      size_t nMethods = (sizeof(Generic_Methods) / sizeof(Generic_Methods[0]));\n      size_t method = (size_t)(BI->keycode >> ID_Shft) & 0xffff;\t \n\n      if ((method >= nMethods) || !(BI->cmd))\n\tres = E_SYSTEM_ERROR;\n      else\n\t{\n\t  Generic_Method fct = Generic_Methods[method];\n\n\t  if (fct)\n\t    res = fct(BI->cmd, form);\n\t  else\n\t    res = (BI->cmd) (form);\n\t}\n    }\n#ifdef NCURSES_MOUSE_VERSION\n  else if (KEY_MOUSE == c)\n    {\n      MEVENT event;\n      WINDOW *win = form->win ? form->win : StdScreen(Get_Form_Screen(form));\n      WINDOW *sub = form->sub ? form->sub : win;\n\n      getmouse(&event);\n      if ((event.bstate & (BUTTON1_CLICKED |\n\t\t\t   BUTTON1_DOUBLE_CLICKED |\n\t\t\t   BUTTON1_TRIPLE_CLICKED))\n\t  && wenclose(win, event.y, event.x))\n\t{\t\t\t \n\t  int ry = event.y, rx = event.x;\t \n\n\t  res = E_REQUEST_DENIED;\n\t  if (mouse_trafo(&ry, &rx, FALSE))\n\t    {\t\t\t \n\t      if (ry < sub->_begy)\n\t\t{\t\t \n\t\t  if (event.bstate & BUTTON1_CLICKED)\n\t\t    res = form_driver(form, REQ_PREV_FIELD);\n\t\t  else if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t    res = form_driver(form, REQ_PREV_PAGE);\n\t\t  else if (event.bstate & BUTTON1_TRIPLE_CLICKED)\n\t\t    res = form_driver(form, REQ_FIRST_FIELD);\n\t\t}\n\t      else if (ry > sub->_begy + sub->_maxy)\n\t\t{\t\t \n\t\t  if (event.bstate & BUTTON1_CLICKED)\n\t\t    res = form_driver(form, REQ_NEXT_FIELD);\n\t\t  else if (event.bstate & BUTTON1_DOUBLE_CLICKED)\n\t\t    res = form_driver(form, REQ_NEXT_PAGE);\n\t\t  else if (event.bstate & BUTTON1_TRIPLE_CLICKED)\n\t\t    res = form_driver(form, REQ_LAST_FIELD);\n\t\t}\n\t      else if (wenclose(sub, event.y, event.x))\n\t\t{\t\t \n\t\t  ry = event.y;\n\t\t  rx = event.x;\n\t\t  if (wmouse_trafo(sub, &ry, &rx, FALSE))\n\t\t    {\n\t\t      int min_field = form->page[form->curpage].pmin;\n\t\t      int max_field = form->page[form->curpage].pmax;\n\t\t      int i;\n\n\t\t      for (i = min_field; i <= max_field; ++i)\n\t\t\t{\n\t\t\t  FIELD *field = form->field[i];\n\n\t\t\t  if (Field_Is_Selectable(field)\n\t\t\t      && Field_encloses(field, ry, rx) == E_OK)\n\t\t\t    {\n\t\t\t      res = _nc_Set_Current_Field(form, field);\n\t\t\t      if (res == E_OK)\n\t\t\t\tres = _nc_Position_Form_Cursor(form);\n\t\t\t      if (res == E_OK\n\t\t\t\t  && (event.bstate & BUTTON1_DOUBLE_CLICKED))\n\t\t\t\tres = E_UNKNOWN_COMMAND;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\tres = E_REQUEST_DENIED;\n    }\n#endif  \n  else if (type == OK)\n    {\n      res = Data_Entry_w(form, c);\n    }\n\n  _nc_Refresh_Current_Field(form);\n  RETURN(res);\n}\n# endif\t \n\n \n\n \nFORM_EXPORT(int)\nset_field_buffer(FIELD *field, int buffer, const char *value)\n{\n  FIELD_CELL *p;\n  int res = E_OK;\n  int i;\n  int len;\n\n#if USE_WIDEC_SUPPORT\n  FIELD_CELL *widevalue = 0;\n#endif\n\n  T((T_CALLED(\"set_field_buffer(%p,%d,%s)\"), (void *)field, buffer, _nc_visbuf(value)));\n\n  if (!field || !value || ((buffer < 0) || (buffer > field->nbuf)))\n    RETURN(E_BAD_ARGUMENT);\n\n  len = Buffer_Length(field);\n\n  if (Growable(field))\n    {\n       \n      int vlen = (int)strlen(value);\n\n      if (vlen > len)\n\t{\n\t  if (!Field_Grown(field,\n\t\t\t   (int)(1 + (vlen - len) / ((field->rows + field->nrow)\n\t\t\t\t\t\t     * field->cols))))\n\t    RETURN(E_SYSTEM_ERROR);\n\n#if !USE_WIDEC_SUPPORT\n\t  len = vlen;\n#endif\n\t}\n    }\n\n  p = Address_Of_Nth_Buffer(field, buffer);\n\n#if USE_WIDEC_SUPPORT\n   \n#if NCURSES_EXT_FUNCS\n  if (wresize(field->working, 1, Buffer_Length(field) + 1) == ERR)\n#endif\n    {\n      delwin(field->working);\n      field->working = newpad(1, Buffer_Length(field) + 1);\n    }\n  len = Buffer_Length(field);\n  wclear(field->working);\n  (void)mvwaddstr(field->working, 0, 0, value);\n\n  if ((widevalue = typeCalloc(FIELD_CELL, len + 1)) == 0)\n    {\n      RETURN(E_SYSTEM_ERROR);\n    }\n  else\n    {\n      for (i = 0; i < field->drows; ++i)\n\t{\n\t  (void)mvwin_wchnstr(field->working, 0, (int)i * field->dcols,\n\t\t\t      widevalue + ((int)i * field->dcols),\n\t\t\t      field->dcols);\n\t}\n      for (i = 0; i < len; ++i)\n\t{\n\t  if (CharEq(myZEROS, widevalue[i]))\n\t    {\n\t      while (i < len)\n\t\tp[i++] = myBLANK;\n\t      break;\n\t    }\n\t  p[i] = widevalue[i];\n\t}\n      free(widevalue);\n    }\n#else\n  for (i = 0; i < len; ++i)\n    {\n      if (value[i] == '\\0')\n\t{\n\t  while (i < len)\n\t    p[i++] = myBLANK;\n\t  break;\n\t}\n      p[i] = value[i];\n    }\n#endif\n\n  if (buffer == 0)\n    {\n      int syncres;\n\n      if (((syncres = Synchronize_Field(field)) != E_OK) &&\n\t  (res == E_OK))\n\tres = syncres;\n      if (((syncres = Synchronize_Linked_Fields(field)) != E_OK) &&\n\t  (res == E_OK))\n\tres = syncres;\n    }\n  RETURN(res);\n}\n\n \nFORM_EXPORT(char *)\nfield_buffer(const FIELD *field, int buffer)\n{\n  char *result = 0;\n\n  T((T_CALLED(\"field_buffer(%p,%d)\"), (const void *)field, buffer));\n\n  if (field && (buffer >= 0) && (buffer <= field->nbuf))\n    {\n#if USE_WIDEC_SUPPORT\n      FIELD_CELL *data = Address_Of_Nth_Buffer(field, buffer);\n      size_t need = 0;\n      int size = Buffer_Length(field);\n      int n;\n\n       \n      for (n = 0; n < size; ++n)\n\t{\n\t  if (!isWidecExt(data[n]) && data[n].chars[0] != L'\\0')\n\t    {\n\t      mbstate_t state;\n\t      size_t next;\n\n\t      init_mb(state);\n\t      next = _nc_wcrtomb(0, data[n].chars[0], &state);\n\t      if (next > 0)\n\t\tneed += next;\n\t    }\n\t}\n\n       \n      if (field->expanded[buffer] != 0)\n\tfree(field->expanded[buffer]);\n      field->expanded[buffer] = typeMalloc(char, need + 1);\n\n       \n      if ((result = field->expanded[buffer]) != 0)\n\t{\n\t  wclear(field->working);\n\t  wmove(field->working, 0, 0);\n\t  for (n = 0; n < size; ++n)\n\t    {\n\t      if (!isWidecExt(data[n]) && data[n].chars[0] != L'\\0')\n\t\twadd_wch(field->working, &data[n]);\n\t    }\n\t  wmove(field->working, 0, 0);\n\t  winnstr(field->working, result, (int)need);\n\t}\n#else\n      result = Address_Of_Nth_Buffer(field, buffer);\n#endif\n    }\n  returnPtr(result);\n}\n\n#if USE_WIDEC_SUPPORT\n\n \nFORM_EXPORT(wchar_t *)\n_nc_Widen_String(char *source, int *lengthp)\n{\n  wchar_t *result = 0;\n  wchar_t wch;\n  size_t given = strlen(source);\n  size_t tries;\n  int pass;\n  int status;\n\n#ifndef state_unused\n  mbstate_t state;\n#endif\n\n  for (pass = 0; pass < 2; ++pass)\n    {\n      unsigned need = 0;\n      size_t passed = 0;\n\n      while (passed < given)\n\t{\n\t  bool found = FALSE;\n\n\t  for (tries = 1, status = 0; tries <= (given - passed); ++tries)\n\t    {\n\t      int save = source[passed + tries];\n\n\t      source[passed + tries] = 0;\n\t      reset_mbytes(state);\n\t      status = check_mbytes(wch, source + passed, tries, state);\n\t      source[passed + tries] = (char)save;\n\n\t      if (status > 0)\n\t\t{\n\t\t  found = TRUE;\n\t\t  break;\n\t\t}\n\t    }\n\t  if (found)\n\t    {\n\t      if (pass)\n\t\t{\n\t\t  result[need] = wch;\n\t\t}\n\t      passed += (size_t)status;\n\t      ++need;\n\t    }\n\t  else\n\t    {\n\t      if (pass)\n\t\t{\n\t\t  result[need] = (wchar_t)source[passed];\n\t\t}\n\t      ++need;\n\t      ++passed;\n\t    }\n\t}\n\n      if (!pass)\n\t{\n\t  if (!need)\n\t    break;\n\t  result = typeCalloc(wchar_t, need);\n\n\t  *lengthp = (int)need;\n\t  if (result == 0)\n\t    break;\n\t}\n    }\n\n  return result;\n}\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}