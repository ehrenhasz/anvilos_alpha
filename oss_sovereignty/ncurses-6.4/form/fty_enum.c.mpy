{
  "module_name": "fty_enum.c",
  "hash_id": "78150bca4210ca51b7b3cbfc5fec7a2a6394afe75fbc82c2b8c6fbe8264c3d76",
  "original_prompt": "Ingested from ncurses-6.4/form/fty_enum.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: fty_enum.c,v 1.33 2021/06/17 21:11:08 tom Exp $\")\n\ntypedef struct\n  {\n    char **kwds;\n    int count;\n    bool checkcase;\n    bool checkunique;\n  }\nenumARG;\n\ntypedef struct\n  {\n    char **kwds;\n    int ccase;\n    int cunique;\n  }\nenumParams;\n\n \nstatic void *\nGeneric_Enum_Type(void *arg)\n{\n  enumARG *argp = (enumARG *)0;\n  enumParams *params = (enumParams *)arg;\n\n  if (params)\n    {\n      argp = typeMalloc(enumARG, 1);\n\n      if (argp)\n\t{\n\t  int cnt = 0;\n\t  char **kp = (char **)0;\n\t  char **kwds = (char **)0;\n\t  int ccase, cunique;\n\n\t  T((T_CREATE(\"enumARG %p\"), (void *)argp));\n\t  kwds = params->kwds;\n\t  ccase = params->ccase;\n\t  cunique = params->cunique;\n\n\t  argp->checkcase = ccase ? TRUE : FALSE;\n\t  argp->checkunique = cunique ? TRUE : FALSE;\n\t  argp->kwds = (char **)0;\n\n\t  kp = kwds;\n\t  while (kp && (*kp++))\n\t    cnt++;\n\t  argp->count = cnt;\n\n\t  if (cnt > 0)\n\t    {\n\t      char **kptarget;\n\n\t       \n\t      argp->kwds = typeMalloc(char *, cnt + 1);\n\n\t      kp = kwds;\n\t      if ((kptarget = argp->kwds) != 0)\n\t\t{\n\t\t  while (kp && (*kp))\n\t\t    {\n\t\t      (*kptarget++) = strdup(*kp++);\n\t\t    }\n\t\t  *kptarget = (char *)0;\n\t\t}\n\t    }\n\t}\n    }\n  return (void *)argp;\n}\n\n \nstatic void *\nMake_Enum_Type(va_list *ap)\n{\n  enumParams params;\n\n  params.kwds = va_arg(*ap, char **);\n  params.ccase = va_arg(*ap, int);\n  params.cunique = va_arg(*ap, int);\n\n  return Generic_Enum_Type((void *)&params);\n}\n\n \nstatic void *\nCopy_Enum_Type(const void *argp)\n{\n  enumARG *result = (enumARG *)0;\n\n  if (argp)\n    {\n      const enumARG *ap = (const enumARG *)argp;\n\n      result = typeMalloc(enumARG, 1);\n\n      if (result)\n\t{\n\t  T((T_CREATE(\"enumARG %p\"), (void *)result));\n\t  *result = *ap;\n\n\t  if (ap->count > 0)\n\t    {\n\t      char **kptarget;\n\t      char **kp = ap->kwds;\n\t      result->kwds = typeMalloc(char *, 1 + ap->count);\n\n\t      if ((kptarget = result->kwds) != 0)\n\t\t{\n\t\t  while (kp && (*kp))\n\t\t    {\n\t\t      (*kptarget++) = strdup(*kp++);\n\t\t    }\n\t\t  *kptarget = (char *)0;\n\t\t}\n\t    }\n\t}\n    }\n  return (void *)result;\n}\n\n \nstatic void\nFree_Enum_Type(void *argp)\n{\n  if (argp)\n    {\n      const enumARG *ap = (const enumARG *)argp;\n\n      if (ap->kwds && ap->count > 0)\n\t{\n\t  char **kp = ap->kwds;\n\t  int cnt = 0;\n\n\t  while (kp && (*kp))\n\t    {\n\t      free(*kp++);\n\t      cnt++;\n\t    }\n\t  assert(cnt == ap->count);\n\t  free(ap->kwds);\n\t}\n      free(argp);\n    }\n}\n\n#define SKIP_SPACE(x) while(((*(x))!='\\0') && (is_blank(*(x)))) (x)++\n#define NOMATCH 0\n#define PARTIAL 1\n#define EXACT   2\n\n \nstatic int\nCompare(const unsigned char *s, const unsigned char *buf,\n\tbool ccase)\n{\n  SKIP_SPACE(buf);\t\t \n  SKIP_SPACE(s);\n\n  if (*buf == '\\0')\n    {\n      return (((*s) != '\\0') ? NOMATCH : EXACT);\n    }\n  else\n    {\n      if (ccase)\n\t{\n\t  while (*s++ == *buf)\n\t    {\n\t      if (*buf++ == '\\0')\n\t\treturn EXACT;\n\t    }\n\t}\n      else\n\t{\n\t  while (toupper(*s++) == toupper(*buf))\n\t    {\n\t      if (*buf++ == '\\0')\n\t\treturn EXACT;\n\t    }\n\t}\n    }\n   \n  SKIP_SPACE(buf);\n  if (*buf)\n    return NOMATCH;\n\n   \n  return ((s[-1] != '\\0') ? PARTIAL : EXACT);\n}\n\n \nstatic bool\nCheck_Enum_Field(FIELD *field, const void *argp)\n{\n  char **kwds = ((const enumARG *)argp)->kwds;\n  bool ccase = ((const enumARG *)argp)->checkcase;\n  bool unique = ((const enumARG *)argp)->checkunique;\n  unsigned char *bp = (unsigned char *)field_buffer(field, 0);\n  char *s, *t, *p;\n\n  while (kwds && (s = (*kwds++)))\n    {\n      int res;\n\n      if ((res = Compare((unsigned char *)s, bp, ccase)) != NOMATCH)\n\t{\n\t  p = t = s;\t\t \n\t  if ((unique && res != EXACT))\n\t    {\n\t      while (kwds && (p = *kwds++))\n\t\t{\n\t\t  if ((res = Compare((unsigned char *)p, bp, ccase)) != NOMATCH)\n\t\t    {\n\t\t      if (res == EXACT)\n\t\t\t{\n\t\t\t  t = p;\n\t\t\t  break;\n\t\t\t}\n\t\t      else\n\t\t\tt = (char *)0;\n\t\t    }\n\t\t}\n\t    }\n\t  if (t)\n\t    {\n\t      set_field_buffer(field, 0, t);\n\t      return TRUE;\n\t    }\n\t  if (!p)\n\t    break;\n\t}\n    }\n  return FALSE;\n}\n\nstatic const char *dummy[] =\n{(char *)0};\n\n \nstatic bool\nNext_Enum(FIELD *field, const void *argp)\n{\n  const enumARG *args = (const enumARG *)argp;\n  char **kwds = args->kwds;\n  bool ccase = args->checkcase;\n  int cnt = args->count;\n  unsigned char *bp = (unsigned char *)field_buffer(field, 0);\n\n  if (kwds)\n    {\n      while (cnt--)\n\t{\n\t  if (Compare((unsigned char *)(*kwds++), bp, ccase) == EXACT)\n\t    break;\n\t}\n      if (cnt <= 0)\n\tkwds = args->kwds;\n      if ((cnt >= 0) || (Compare((const unsigned char *)dummy, bp, ccase) == EXACT))\n\t{\n\t  set_field_buffer(field, 0, *kwds);\n\t  return TRUE;\n\t}\n    }\n  return FALSE;\n}\n\n \nstatic bool\nPrevious_Enum(FIELD *field, const void *argp)\n{\n  const enumARG *args = (const enumARG *)argp;\n  int cnt = args->count;\n  char **kwds = &args->kwds[cnt - 1];\n  bool ccase = args->checkcase;\n  unsigned char *bp = (unsigned char *)field_buffer(field, 0);\n\n  if (kwds)\n    {\n      while (cnt--)\n\t{\n\t  if (Compare((unsigned char *)(*kwds--), bp, ccase) == EXACT)\n\t    break;\n\t}\n\n      if (cnt <= 0)\n\tkwds = &args->kwds[args->count - 1];\n\n      if ((cnt >= 0) || (Compare((const unsigned char *)dummy, bp, ccase) == EXACT))\n\t{\n\t  set_field_buffer(field, 0, *kwds);\n\t  return TRUE;\n\t}\n    }\n  return FALSE;\n}\n\nstatic FIELDTYPE typeENUM =\n{\n  _HAS_ARGS | _HAS_CHOICE | _RESIDENT,\n  1,\t\t\t\t \n  (FIELDTYPE *)0,\n  (FIELDTYPE *)0,\n  Make_Enum_Type,\n  Copy_Enum_Type,\n  Free_Enum_Type,\n  INIT_FT_FUNC(Check_Enum_Field),\n  INIT_FT_FUNC(NULL),\n  INIT_FT_FUNC(Next_Enum),\n  INIT_FT_FUNC(Previous_Enum),\n#if NCURSES_INTEROP_FUNCS\n  Generic_Enum_Type\n#endif\n};\n\nFORM_EXPORT_VAR(FIELDTYPE *) TYPE_ENUM = &typeENUM;\n\n#if NCURSES_INTEROP_FUNCS\n \nFORM_EXPORT(FIELDTYPE *)\n_nc_TYPE_ENUM(void)\n{\n  return TYPE_ENUM;\n}\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}