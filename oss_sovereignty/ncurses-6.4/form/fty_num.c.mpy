{
  "module_name": "fty_num.c",
  "hash_id": "6aa415fd60af707c36198eabf687c9739f3987b0c931087ee37768d294a14edb",
  "original_prompt": "Ingested from ncurses-6.4/form/fty_num.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: fty_num.c,v 1.37 2021/03/27 23:49:58 tom Exp $\")\n\n#if HAVE_LOCALE_H\n#include <locale.h>\n#endif\n\n#if HAVE_LOCALE_H && HAVE_LOCALECONV\n#define isDecimalPoint(c) ((c) == ((L && L->decimal_point) ? *(L->decimal_point) : '.'))\n#else\n#define isDecimalPoint(c) ((c) == '.')\n#endif\n\n#if USE_WIDEC_SUPPORT\n#define isDigit(c) (iswdigit((wint_t)(c)) || isdigit(UChar(c)))\n#else\n#define isDigit(c) isdigit(UChar(c))\n#endif\n\n#define thisARG numericARG\n\ntypedef struct\n  {\n    int precision;\n    double low;\n    double high;\n    struct lconv *L;\n  }\nthisARG;\n\ntypedef struct\n  {\n    int precision;\n    double low;\n    double high;\n  }\nthisPARM;\n\n \nstatic void *\nGeneric_This_Type(void *arg)\n{\n  thisARG *argn = (thisARG *)0;\n  thisPARM *args = (thisPARM *)arg;\n\n  if (args)\n    {\n      argn = typeMalloc(thisARG, 1);\n\n      if (argn)\n\t{\n\t  T((T_CREATE(\"thisARG %p\"), (void *)argn));\n\t  argn->precision = args->precision;\n\t  argn->low = args->low;\n\t  argn->high = args->high;\n\n#if HAVE_LOCALE_H && HAVE_LOCALECONV\n\t  argn->L = localeconv();\n#else\n\t  argn->L = NULL;\n#endif\n\t}\n    }\n  return (void *)argn;\n}\n\n \nstatic void *\nMake_This_Type(va_list *ap)\n{\n  thisPARM arg;\n\n  arg.precision = va_arg(*ap, int);\n  arg.low = va_arg(*ap, double);\n  arg.high = va_arg(*ap, double);\n\n  return Generic_This_Type((void *)&arg);\n}\n\n \nstatic void *\nCopy_This_Type(const void *argp)\n{\n  const thisARG *ap = (const thisARG *)argp;\n  thisARG *result = (thisARG *)0;\n\n  if (argp)\n    {\n      result = typeMalloc(thisARG, 1);\n\n      if (result)\n\t{\n\t  T((T_CREATE(\"thisARG %p\"), (void *)result));\n\t  *result = *ap;\n\t}\n    }\n  return (void *)result;\n}\n\n \nstatic void\nFree_This_Type(void *argp)\n{\n  if (argp)\n    free(argp);\n}\n\n \nstatic bool\nCheck_This_Field(FIELD *field, const void *argp)\n{\n  const thisARG *argn = (const thisARG *)argp;\n  double low = argn->low;\n  double high = argn->high;\n  int prec = argn->precision;\n  unsigned char *bp = (unsigned char *)field_buffer(field, 0);\n  char *s = (char *)bp;\n  struct lconv *L = argn->L;\n  bool result = FALSE;\n\n  while (*bp == ' ')\n    bp++;\n  if (*bp)\n    {\n      if (*bp == '-' || *bp == '+')\n\tbp++;\n#if USE_WIDEC_SUPPORT\n      if (*bp)\n\t{\n\t  int len;\n\t  wchar_t *list = _nc_Widen_String((char *)bp, &len);\n\n\t  if (list != 0)\n\t    {\n\t      bool blank = FALSE;\n\t      int state = 0;\n\t      int n;\n\n\t      result = TRUE;\n\t      for (n = 0; n < len; ++n)\n\t\t{\n\t\t  if (blank)\n\t\t    {\n\t\t      if (list[n] != ' ')\n\t\t\t{\n\t\t\t  result = FALSE;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else if (list[n] == ' ')\n\t\t    {\n\t\t      blank = TRUE;\n\t\t    }\n\t\t  else if (isDecimalPoint(list[n]))\n\t\t    {\n\t\t      if (++state > 1)\n\t\t\t{\n\t\t\t  result = FALSE;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else if (!isDigit(list[n]))\n\t\t    {\n\t\t      result = FALSE;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      free(list);\n\t    }\n\t}\n#else\n      while (*bp)\n\t{\n\t  if (!isdigit(UChar(*bp)))\n\t    break;\n\t  bp++;\n\t}\n      if (isDecimalPoint(*bp))\n\t{\n\t  bp++;\n\t  while (*bp)\n\t    {\n\t      if (!isdigit(UChar(*bp)))\n\t\tbreak;\n\t      bp++;\n\t    }\n\t}\n      while (*bp && *bp == ' ')\n\tbp++;\n      result = (*bp == '\\0');\n#endif\n      if (result)\n\t{\n\t  double val = atof(s);\n\n\t  if (low < high)\n\t    {\n\t      if (val < low || val > high)\n\t\tresult = FALSE;\n\t    }\n\t  if (result)\n\t    {\n\t      char buf[64];\n\n\t      _nc_SPRINTF(buf, _nc_SLIMIT(sizeof(buf))\n\t\t\t  \"%.*f\", (prec > 0 ? prec : 0), val);\n\t      set_field_buffer(field, 0, buf);\n\t    }\n\t}\n    }\n  return (result);\n}\n\n \nstatic bool\nCheck_This_Character(int c, const void *argp)\n{\n  const thisARG *argn = (const thisARG *)argp;\n  struct lconv *L = argn->L;\n\n  return ((isDigit(c) ||\n\t   c == '+' ||\n\t   c == '-' ||\n\t   isDecimalPoint(c))\n\t  ? TRUE\n\t  : FALSE);\n}\n\nstatic FIELDTYPE typeTHIS =\n{\n  _HAS_ARGS | _RESIDENT,\n  1,\t\t\t\t \n  (FIELDTYPE *)0,\n  (FIELDTYPE *)0,\n  Make_This_Type,\n  Copy_This_Type,\n  Free_This_Type,\n  INIT_FT_FUNC(Check_This_Field),\n  INIT_FT_FUNC(Check_This_Character),\n  INIT_FT_FUNC(NULL),\n  INIT_FT_FUNC(NULL),\n#if NCURSES_INTEROP_FUNCS\n  Generic_This_Type\n#endif\n};\n\nFORM_EXPORT_VAR(FIELDTYPE *) TYPE_NUMERIC = &typeTHIS;\n\n#if NCURSES_INTEROP_FUNCS\n \nFORM_EXPORT(FIELDTYPE *)\n_nc_TYPE_NUMERIC(void)\n{\n  return TYPE_NUMERIC;\n}\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}