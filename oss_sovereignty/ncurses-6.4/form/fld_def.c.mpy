{
  "module_name": "fld_def.c",
  "hash_id": "ca6261a38d5b8b96c7ce0ea8a9ca76f764123800f2262ae28ecfa3f9a93baade",
  "original_prompt": "Ingested from ncurses-6.4/form/fld_def.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: fld_def.c,v 1.44 2021/03/27 23:49:53 tom Exp $\")\n\n \nstatic FIELD default_field =\n{\n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  NO_JUSTIFICATION,\t\t \n  0,\t\t\t\t \n  0,\t\t\t\t \n  (int)' ',\t\t\t \n  A_NORMAL,\t\t\t \n  A_NORMAL,\t\t\t \n  STD_FIELD_OPTS,\t\t \n  (FIELD *)0,\t\t\t \n  (FIELD *)0,\t\t\t \n  (FIELD *)0,\t\t\t \n  (FORM *)0,\t\t\t \n  (FIELDTYPE *)0,\t\t \n  (char *)0,\t\t\t \n  (FIELD_CELL *)0,\t\t \n  (char *)0\t\t\t \n  NCURSES_FIELD_EXTENSION\n};\n\nFORM_EXPORT_VAR(FIELD *) _nc_Default_Field = &default_field;\n\n \nFORM_EXPORT(TypeArgument *)\n_nc_Make_Argument(const FIELDTYPE *typ, va_list *ap, int *err)\n{\n  TypeArgument *res = (TypeArgument *)0;\n\n  if (typ != 0 && (typ->status & _HAS_ARGS) != 0)\n    {\n      assert(err != 0 && ap != (va_list *)0);\n      if ((typ->status & _LINKED_TYPE) != 0)\n\t{\n\t  TypeArgument *p = typeMalloc(TypeArgument, 1);\n\n\t  if (p != 0)\n\t    {\n\t      p->left = _nc_Make_Argument(typ->left, ap, err);\n\t      p->right = _nc_Make_Argument(typ->right, ap, err);\n\t      return p;\n\t    }\n\t  else\n\t    {\n\t      *err += 1;\n\t    }\n\t}\n      else\n\t{\n\t  assert(typ->makearg != (void *)0);\n\t  if (!(res = (TypeArgument *)typ->makearg(ap)))\n\t    {\n\t      *err += 1;\n\t    }\n\t}\n    }\n  return res;\n}\n\n \nFORM_EXPORT(TypeArgument *)\n_nc_Copy_Argument(const FIELDTYPE *typ, const TypeArgument *argp, int *err)\n{\n  TypeArgument *res = (TypeArgument *)0;\n\n  if (typ != 0 && (typ->status & _HAS_ARGS) != 0)\n    {\n      assert(err != 0 && argp != 0);\n      if ((typ->status & _LINKED_TYPE) != 0)\n\t{\n\t  TypeArgument *p = typeMalloc(TypeArgument, 1);\n\n\t  if (p != 0)\n\t    {\n\t      p->left = _nc_Copy_Argument(typ, argp->left, err);\n\t      p->right = _nc_Copy_Argument(typ, argp->right, err);\n\t      return p;\n\t    }\n\t  *err += 1;\n\t}\n      else\n\t{\n\t  if (typ->copyarg != (void *)0)\n\t    {\n\t      if (!(res = (TypeArgument *)(typ->copyarg((const void *)argp))))\n\t\t{\n\t\t  *err += 1;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      res = (TypeArgument *)argp;\n\t    }\n\t}\n    }\n  return res;\n}\n\n \nFORM_EXPORT(void)\n_nc_Free_Argument(const FIELDTYPE *typ, TypeArgument *argp)\n{\n  if (typ != 0 && (typ->status & _HAS_ARGS) != 0)\n    {\n      if ((typ->status & _LINKED_TYPE) != 0)\n\t{\n\t  if (argp != 0)\n\t    {\n\t      _nc_Free_Argument(typ->left, argp->left);\n\t      _nc_Free_Argument(typ->right, argp->right);\n\t      free(argp);\n\t    }\n\t}\n      else\n\t{\n\t  if (typ->freearg != (void *)0)\n\t    {\n\t      typ->freearg((void *)argp);\n\t    }\n\t}\n    }\n}\n\n \nFORM_EXPORT(bool)\n_nc_Copy_Type(FIELD *dst, FIELD const *src)\n{\n  int err = 0;\n\n  assert(dst != 0 && src != 0);\n\n  dst->type = src->type;\n  dst->arg = (void *)_nc_Copy_Argument(src->type, (TypeArgument *)(src->arg), &err);\n\n  if (err != 0)\n    {\n      _nc_Free_Argument(dst->type, (TypeArgument *)(dst->arg));\n      dst->type = (FIELDTYPE *)0;\n      dst->arg = (void *)0;\n      return FALSE;\n    }\n  else\n    {\n      if (dst->type != 0)\n\t{\n\t  dst->type->ref++;\n\t}\n      return TRUE;\n    }\n}\n\n \nFORM_EXPORT(void)\n_nc_Free_Type(FIELD *field)\n{\n  assert(field != 0);\n  if (field->type != 0)\n    {\n      field->type->ref--;\n      _nc_Free_Argument(field->type, (TypeArgument *)(field->arg));\n    }\n}\n\n \nFORM_EXPORT(FIELD *)\nnew_field(int rows, int cols, int frow, int fcol, int nrow, int nbuf)\n{\n  static const FIELD_CELL blank = BLANK;\n  static const FIELD_CELL zeros = ZEROS;\n\n  FIELD *New_Field = (FIELD *)0;\n  int err = E_BAD_ARGUMENT;\n\n  T((T_CALLED(\"new_field(%d,%d,%d,%d,%d,%d)\"), rows, cols, frow, fcol, nrow, nbuf));\n  if (rows > 0 &&\n      cols > 0 &&\n      frow >= 0 &&\n      fcol >= 0 &&\n      nrow >= 0 &&\n      nbuf >= 0 &&\n      ((err = E_SYSTEM_ERROR) != 0) &&\t \n      (New_Field = typeMalloc(FIELD, 1)) != 0)\n    {\n      T((T_CREATE(\"field %p\"), (void *)New_Field));\n      *New_Field = default_field;\n      New_Field->rows = (short)rows;\n      New_Field->cols = (short)cols;\n      New_Field->drows = rows + nrow;\n      New_Field->dcols = cols;\n      New_Field->frow = (short)frow;\n      New_Field->fcol = (short)fcol;\n      New_Field->nrow = nrow;\n      New_Field->nbuf = (short)nbuf;\n      New_Field->link = New_Field;\n\n#if USE_WIDEC_SUPPORT\n      New_Field->working = newpad(1, Buffer_Length(New_Field) + 1);\n      New_Field->expanded = typeCalloc(char *, 1 + (unsigned)nbuf);\n#endif\n\n      if (_nc_Copy_Type(New_Field, &default_field))\n\t{\n\t  size_t len;\n\n\t  len = Total_Buffer_Size(New_Field);\n\t  if ((New_Field->buf = (FIELD_CELL *)malloc(len)))\n\t    {\n\t       \n\t      int i, j;\n\t      int cells = Buffer_Length(New_Field);\n\n\t      for (i = 0; i <= New_Field->nbuf; i++)\n\t\t{\n\t\t  FIELD_CELL *buffer = &(New_Field->buf[(cells + 1) * i]);\n\n\t\t  for (j = 0; j < cells; ++j)\n\t\t    {\n\t\t      buffer[j] = blank;\n\t\t    }\n\t\t  buffer[j] = zeros;\n\t\t}\n\t      returnField(New_Field);\n\t    }\n\t}\n    }\n\n  if (New_Field)\n    free_field(New_Field);\n\n  SET_ERROR(err);\n  returnField((FIELD *)0);\n}\n\n \nFORM_EXPORT(int)\nfree_field(FIELD *field)\n{\n  T((T_CALLED(\"free_field(%p)\"), (void *)field));\n  if (!field)\n    {\n      RETURN(E_BAD_ARGUMENT);\n    }\n  else if (field->form != 0)\n    {\n      RETURN(E_CONNECTED);\n    }\n  else if (field == field->link)\n    {\n      if (field->buf != 0)\n\tfree(field->buf);\n    }\n  else\n    {\n      FIELD *f;\n\n      for (f = field; f->link != field; f = f->link)\n\t{\n\t}\n      f->link = field->link;\n    }\n  _nc_Free_Type(field);\n#if USE_WIDEC_SUPPORT\n  if (field->expanded != 0)\n    {\n      int n;\n\n      for (n = 0; n <= field->nbuf; ++n)\n\t{\n\t  FreeIfNeeded(field->expanded[n]);\n\t}\n      free(field->expanded);\n      (void)delwin(field->working);\n    }\n#endif\n  free(field);\n  RETURN(E_OK);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}