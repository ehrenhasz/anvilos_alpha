{
  "module_name": "fty_regex.c",
  "hash_id": "8b33d2a8aba5cf7b28874d0d86d36a57500fa4488a74f376cc35f8b1d250e10b",
  "original_prompt": "Ingested from ncurses-6.4/form/fty_regex.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: fty_regex.c,v 1.33 2021/08/14 15:01:52 tom Exp $\")\n\n#if HAVE_REGEX_H_FUNCS || HAVE_LIB_PCRE2\t \n\n#if HAVE_PCRE2POSIX_H\n#include <pcre2posix.h>\n\n \n#if !defined(PCRE2regcomp) && defined(HAVE_PCRE2REGCOMP)\n\n#undef regcomp\n#undef regexec\n#undef regfree\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n  PCRE2POSIX_EXP_DECL int PCRE2regcomp(regex_t *, const char *, int);\n  PCRE2POSIX_EXP_DECL int PCRE2regexec(const regex_t *, const char *, size_t,\n\t\t\t\t       regmatch_t *, int);\n  PCRE2POSIX_EXP_DECL void PCRE2regfree(regex_t *);\n#ifdef __cplusplus\n}\t\t\t\t \n#endif\n#define regcomp(r,s,n)          PCRE2regcomp(r,s,n)\n#define regexec(r,s,n,m,x)      PCRE2regexec(r,s,n,m,x)\n#define regfree(r)              PCRE2regfree(r)\n#endif\n \n#elif HAVE_PCREPOSIX_H\n#include <pcreposix.h>\n#else\n#include <regex.h>\n#endif\n\ntypedef struct\n  {\n    regex_t *pRegExp;\n    unsigned long *refCount;\n  }\nRegExp_Arg;\n\n#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS\n#undef RETURN\nstatic int reg_errno;\n\nstatic char *\nRegEx_Init(char *instring)\n{\n  reg_errno = 0;\n  return instring;\n}\n\nstatic char *\nRegEx_Error(int code)\n{\n  reg_errno = code;\n  return 0;\n}\n\n#define INIT \t\tregister char *sp = RegEx_Init(instring);\n#define GETC()\t\t(*sp++)\n#define PEEKC()\t\t(*sp)\n#define UNGETC(c)\t(--sp)\n#define RETURN(c)\treturn(c)\n#define ERROR(c)\treturn RegEx_Error(c)\n\n#if HAVE_REGEXP_H_FUNCS\n#include <regexp.h>\n#else\n#include <regexpr.h>\n#endif\n\ntypedef struct\n{\n  char *compiled_expression;\n  unsigned long *refCount;\n}\nRegExp_Arg;\n\n \n#define MAX_RX_LEN   (2048)\n#define RX_INCREMENT (256)\n\n#endif\n\n#if HAVE_REGEX_H_FUNCS | HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS\n# define MAYBE_UNUSED\n#else\n# define MAYBE_UNUSED GCC_UNUSED\n#endif\n\n \nstatic void *\nGeneric_RegularExpression_Type(void *arg MAYBE_UNUSED)\n{\n#if HAVE_REGEX_H_FUNCS\n  char *rx = (char *)arg;\n  RegExp_Arg *preg = (RegExp_Arg *)0;\n\n  if (rx)\n    {\n      preg = typeCalloc(RegExp_Arg, 1);\n\n      if (preg)\n\t{\n\t  T((T_CREATE(\"RegExp_Arg %p\"), (void *)preg));\n\t  if (((preg->pRegExp = typeMalloc(regex_t, 1)) != 0)\n\t      && !regcomp(preg->pRegExp, rx,\n\t\t\t  (REG_EXTENDED | REG_NOSUB | REG_NEWLINE)))\n\t    {\n\t      T((T_CREATE(\"regex_t %p\"), (void *)preg->pRegExp));\n\t      if ((preg->refCount = typeMalloc(unsigned long, 1)) != 0)\n\t\t *(preg->refCount) = 1;\n\t    }\n\t  else\n\t    {\n\t      if (preg->pRegExp)\n\t\tfree(preg->pRegExp);\n\t      free(preg);\n\t      preg = (RegExp_Arg *)0;\n\t    }\n\t}\n    }\n  return ((void *)preg);\n#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS\n  char *rx = (char *)arg;\n  RegExp_Arg *pArg = (RegExp_Arg *)0;\n\n  if (rx)\n    {\n      pArg = typeMalloc(RegExp_Arg, 1);\n\n      if (pArg)\n\t{\n\t  int blen = RX_INCREMENT;\n\n\t  T((T_CREATE(\"RegExp_Arg %p\"), pArg));\n\t  pArg->compiled_expression = NULL;\n\t  if ((pArg->refCount = typeMalloc(unsigned long, 1)) != 0)\n\t     *(pArg->refCount) = 1;\n\n\t  do\n\t    {\n\t      char *buf = typeMalloc(char, blen);\n\n\t      if (buf)\n\t\t{\n#if HAVE_REGEXP_H_FUNCS\n\t\t  char *last_pos = compile(rx, buf, &buf[blen], '\\0');\n\n#else  \n\t\t  char *last_pos = compile(rx, buf, &buf[blen]);\n#endif\n\t\t  if (reg_errno)\n\t\t    {\n\t\t      free(buf);\n\t\t      if (reg_errno == 50)\n\t\t\tblen += RX_INCREMENT;\n\t\t      else\n\t\t\t{\n\t\t\t  free(pArg);\n\t\t\t  pArg = NULL;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      pArg->compiled_expression = buf;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  while (blen <= MAX_RX_LEN);\n\t}\n      if (pArg && !pArg->compiled_expression)\n\t{\n\t  free(pArg);\n\t  pArg = NULL;\n\t}\n    }\n  return (void *)pArg;\n#else\n  return 0;\n#endif\n}\n\n \nstatic void *\nMake_RegularExpression_Type(va_list *ap)\n{\n  char *rx = va_arg(*ap, char *);\n\n  return Generic_RegularExpression_Type((void *)rx);\n}\n\n \nstatic void *\nCopy_RegularExpression_Type(const void *argp MAYBE_UNUSED)\n{\n#if (HAVE_REGEX_H_FUNCS | HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS)\n  const RegExp_Arg *ap = (const RegExp_Arg *)argp;\n  const RegExp_Arg *result = (const RegExp_Arg *)0;\n\n  if (ap)\n    {\n      *(ap->refCount) += 1;\n      result = ap;\n    }\n  return (void *)result;\n#else\n  return 0;\n#endif\n}\n\n \nstatic void\nFree_RegularExpression_Type(void *argp MAYBE_UNUSED)\n{\n#if HAVE_REGEX_H_FUNCS | HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS\n  RegExp_Arg *ap = (RegExp_Arg *)argp;\n\n  if (ap)\n    {\n      if (--(*(ap->refCount)) == 0)\n\t{\n#if HAVE_REGEX_H_FUNCS\n\t  if (ap->pRegExp)\n\t    {\n\t      free(ap->refCount);\n\t      regfree(ap->pRegExp);\n\t      free(ap->pRegExp);\n\t    }\n#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS\n\t  if (ap->compiled_expression)\n\t    {\n\t      free(ap->refCount);\n\t      free(ap->compiled_expression);\n\t    }\n#endif\n\t  free(ap);\n\t}\n    }\n#endif\n}\n\n \nstatic bool\nCheck_RegularExpression_Field(FIELD *field MAYBE_UNUSED,\n\t\t\t      const void *argp MAYBE_UNUSED)\n{\n  bool match = FALSE;\n\n#if HAVE_REGEX_H_FUNCS\n  const RegExp_Arg *ap = (const RegExp_Arg *)argp;\n\n  if (ap && ap->pRegExp)\n    match = (regexec(ap->pRegExp, field_buffer(field, 0), 0, NULL, 0)\n\t     ? FALSE\n\t     : TRUE);\n#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS\n  RegExp_Arg *ap = (RegExp_Arg *)argp;\n\n  if (ap && ap->compiled_expression)\n    match = (step(field_buffer(field, 0), ap->compiled_expression)\n\t     ? TRUE\n\t     : FALSE);\n#endif\n  return match;\n}\n\nstatic FIELDTYPE typeREGEXP =\n{\n  _HAS_ARGS | _RESIDENT,\n  1,\t\t\t\t \n  (FIELDTYPE *)0,\n  (FIELDTYPE *)0,\n  Make_RegularExpression_Type,\n  Copy_RegularExpression_Type,\n  Free_RegularExpression_Type,\n  INIT_FT_FUNC(Check_RegularExpression_Field),\n  INIT_FT_FUNC(NULL),\n  INIT_FT_FUNC(NULL),\n  INIT_FT_FUNC(NULL),\n#if NCURSES_INTEROP_FUNCS\n  Generic_RegularExpression_Type\n#endif\n};\n\nFORM_EXPORT_VAR(FIELDTYPE *) TYPE_REGEXP = &typeREGEXP;\n\n#if NCURSES_INTEROP_FUNCS\n \nFORM_EXPORT(FIELDTYPE *)\n_nc_TYPE_REGEXP(void)\n{\n  return TYPE_REGEXP;\n}\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}