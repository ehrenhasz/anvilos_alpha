{
  "module_name": "form.priv.h",
  "hash_id": "4288f55f421bd4e285f69cf1fd80c27ed328ec226f73a88df051c302c50856f0",
  "original_prompt": "Ingested from ncurses-6.4/form/form.priv.h",
  "human_readable_source": " \n\n \n\n \n\n#ifndef FORM_PRIV_H\n#define FORM_PRIV_H 1\n \n#include \"curses.priv.h\"\n\n#define NCURSES_OPAQUE_FORM  0\n\n#include \"mf_common.h\"\n\n#if USE_WIDEC_SUPPORT\n#if HAVE_WCTYPE_H\n#include <wctype.h>\n#endif\n\n#ifndef MB_LEN_MAX\n#define MB_LEN_MAX 8  \n#endif\n\n#define FIELD_CELL NCURSES_CH_T\n\n#define NCURSES_FIELD_INTERNALS char** expanded; WINDOW *working;\n#define NCURSES_FIELD_EXTENSION , (char **)0, (WINDOW *)0\n\n#else\n\n#define FIELD_CELL char\n\n#define NCURSES_FIELD_EXTENSION  \n\n#endif\n\n#include \"form.h\"\n\n\t \nextern FORM_EXPORT_VAR(FORM *)      _nc_Default_Form;\nextern FORM_EXPORT_VAR(FIELD *)     _nc_Default_Field;\nextern FORM_EXPORT_VAR(FIELDTYPE *) _nc_Default_FieldType;\n\n \n#define _OVLMODE         (0x04U)  \n#define _WINDOW_MODIFIED (0x10U)  \n#define _FCHECK_REQUIRED (0x20U)  \n\n \n#define _CHANGED         (0x01U)  \n#define _NEWTOP          (0x02U)  \n#define _NEWPAGE         (0x04U)  \n#define _MAY_GROW        (0x08U)  \n\n \n#define _LINKED_TYPE     (0x01U)  \n#define _HAS_ARGS        (0x02U)  \n#define _HAS_CHOICE      (0x04U)  \n#define _RESIDENT        (0x08U)  \n#define _GENERIC         (0x10U)  \n\n \n#define O_SELECTABLE (O_ACTIVE | O_VISIBLE)\n\n \n#define Normalize_Form(form) \\\n  ((form) = (form != 0) ? (form) : _nc_Default_Form)\n\n \n#define Normalize_Field(field) \\\n  ((field) = (field != 0) ? (field) : _nc_Default_Field)\n\n#if NCURSES_SP_FUNCS\n#define Get_Form_Screen(form) \\\n  ((form)->win ? _nc_screen_of((form->win)):CURRENT_SCREEN)\n#else\n#define Get_Form_Screen(form) CURRENT_SCREEN\n#endif\n\n \n#define Get_Form_Window(form) \\\n  ((form)->sub \\\n   ? (form)->sub \\\n   : ((form)->win \\\n      ? (form)->win \\\n      : StdScreen(Get_Form_Screen(form))))\n\n \n#define Buffer_Length(field) ((field)->drows * (field)->dcols)\n\n \n#define Total_Buffer_Size(field) \\\n   ( (size_t)(Buffer_Length(field) + 1) * (size_t)(1+(field)->nbuf) * sizeof(FIELD_CELL) )\n\n \n#define Single_Line_Field(field) \\\n   (((field)->rows + (field)->nrow) == 1)\n\n#define Field_Has_Option(f,o)      ((((unsigned)(f)->opts) & o) != 0)\n\n \n#define Field_Is_Selectable(f)     (((unsigned)((f)->opts) & O_SELECTABLE)==O_SELECTABLE)\n#define Field_Is_Not_Selectable(f) (((unsigned)((f)->opts) & O_SELECTABLE)!=O_SELECTABLE)\n\ntypedef struct typearg\n  {\n    struct typearg *left;\n    struct typearg *right;\n  }\nTypeArgument;\n\n \n#define FIRST_ACTIVE_MAGIC (-291056)\n\n#define ALL_FORM_OPTS  (                \\\n\t\t\tO_NL_OVERLOAD  |\\\n\t\t\tO_BS_OVERLOAD   )\n\n#define STD_FIELD_OPTS (Field_Options)( \\\n\t\t\tO_VISIBLE |\\\n\t\t\tO_ACTIVE  |\\\n\t\t\tO_PUBLIC  |\\\n\t\t\tO_EDIT    |\\\n\t\t\tO_WRAP    |\\\n\t\t\tO_BLANK   |\\\n\t\t\tO_AUTOSKIP|\\\n\t\t\tO_NULLOK  |\\\n\t\t\tO_PASSOK  |\\\n\t\t\tO_STATIC)\n\n#define ALL_FIELD_OPTS (Field_Options)( \\\n\t\t\tSTD_FIELD_OPTS |\\\n\t\t\tO_DYNAMIC_JUSTIFY |\\\n\t\t\tO_NO_LEFT_STRIP |\\\n\t\t\tO_EDGE_INSERT_STAY |\\\n\t\t\tO_INPUT_LIMIT)\n\n#define C_BLANK ' '\n#define is_blank(c) ((c)==C_BLANK)\n\n#define C_ZEROS '\\0'\n\nextern FORM_EXPORT(TypeArgument *) _nc_Make_Argument (const FIELDTYPE*, va_list*, int*);\nextern FORM_EXPORT(TypeArgument *) _nc_Copy_Argument (const FIELDTYPE*, const TypeArgument*, int*);\nextern FORM_EXPORT(void) _nc_Free_Argument (const FIELDTYPE*, TypeArgument*);\nextern FORM_EXPORT(bool) _nc_Copy_Type (FIELD*, FIELD const *);\nextern FORM_EXPORT(void) _nc_Free_Type (FIELD *);\n\nextern FORM_EXPORT(int) _nc_Synchronize_Attributes (FIELD*);\nextern FORM_EXPORT(int) _nc_Synchronize_Options (FIELD*, Field_Options);\nextern FORM_EXPORT(int) _nc_Set_Form_Page (FORM*, int, FIELD*);\nextern FORM_EXPORT(int) _nc_Refresh_Current_Field (FORM*);\nextern FORM_EXPORT(FIELD *) _nc_First_Active_Field (FORM*);\nextern FORM_EXPORT(bool) _nc_Internal_Validation (FORM*);\nextern FORM_EXPORT(int) _nc_Set_Current_Field (FORM*, FIELD*);\nextern FORM_EXPORT(int) _nc_Position_Form_Cursor (FORM*);\nextern FORM_EXPORT(void) _nc_Unset_Current_Field(FORM *form);\n\n#if NCURSES_INTEROP_FUNCS\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_INTEGER(void);\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_ALNUM(void);\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_ALPHA(void);\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_ENUM(void);\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_NUMERIC(void);\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_REGEXP(void);\nextern FORM_EXPORT(FIELDTYPE *) _nc_TYPE_IPV4(void);\n\nextern FORM_EXPORT(FIELDTYPE *)\n_nc_generic_fieldtype(bool (*const field_check) (FORM*,\n\t\t\t\t\t\t FIELD *,\n\t\t\t\t\t\t const void *),\n\t\t      bool (*const char_check)  (int,\n\t\t\t\t\t\t FORM*,\n\t\t\t\t\t\t FIELD*,\n\t\t\t\t\t\t const void *),\n\t\t      bool (*const next)(FORM*,FIELD*,const void*),\n\t\t      bool (*const prev)(FORM*,FIELD*,const void*),\n\t\t      void (*freecallback)(void*));\nextern FORM_EXPORT(int) _nc_set_generic_fieldtype(FIELD*, FIELDTYPE*, int (*)(void**));\nextern FORM_EXPORT(WINDOW*) _nc_form_cursor(const FORM* , int* , int* );\n\n#define INIT_FT_FUNC(func) {func}\n#else\n#define INIT_FT_FUNC(func) func\n#endif\n\nextern FORM_EXPORT(void) _nc_get_fieldbuffer(FORM*, FIELD*, FIELD_CELL*);\n\n#if USE_WIDEC_SUPPORT\nextern FORM_EXPORT(wchar_t *) _nc_Widen_String(char *, int *);\n#endif\n\n#ifdef TRACE\n\n#define returnField(code)\tTRACE_RETURN1(code,field)\n#define returnFieldPtr(code)\tTRACE_RETURN1(code,field_ptr)\n#define returnForm(code)\tTRACE_RETURN1(code,form)\n#define returnFieldType(code)\tTRACE_RETURN1(code,field_type)\n#define returnFormHook(code)\tTRACE_RETURN1(code,form_hook)\n\nextern FORM_EXPORT(FIELD **)\t    _nc_retrace_field_ptr (FIELD **);\nextern FORM_EXPORT(FIELD *)\t    _nc_retrace_field (FIELD *);\nextern FORM_EXPORT(FIELDTYPE *)  _nc_retrace_field_type (FIELDTYPE *);\nextern FORM_EXPORT(FORM *)       _nc_retrace_form (FORM *);\nextern FORM_EXPORT(Form_Hook)    _nc_retrace_form_hook (Form_Hook);\n\n#else  \n\n#define returnFieldPtr(code)\treturn code\n#define returnFieldType(code)\treturn code\n#define returnField(code)\treturn code\n#define returnForm(code)\treturn code\n#define returnFormHook(code)\treturn code\n\n#endif  \n\n \n#if USE_WIDEC_SUPPORT\n#define Check_CTYPE_Field(result, buffer, width, ccheck) \\\n  while (*buffer && *buffer == ' ') \\\n    buffer++; \\\n  if (*buffer) \\\n    { \\\n      bool blank = FALSE; \\\n      int len; \\\n      int n; \\\n      wchar_t *list = _nc_Widen_String((char *)buffer, &len); \\\n      if (list != 0) \\\n\t{ \\\n\t  result = TRUE; \\\n\t  for (n = 0; n < len; ++n) \\\n\t    { \\\n\t      if (blank) \\\n\t\t{ \\\n\t\t  if (list[n] != ' ') \\\n\t\t    { \\\n\t\t      result = FALSE; \\\n\t\t      break; \\\n\t\t    } \\\n\t\t} \\\n\t      else if (list[n] == ' ') \\\n\t\t{ \\\n\t\t  blank = TRUE; \\\n\t\t  result = (n + 1 >= width); \\\n\t\t} \\\n\t      else if (!ccheck(list[n], NULL)) \\\n\t\t{ \\\n\t\t  result = FALSE; \\\n\t\t  break; \\\n\t\t} \\\n\t    } \\\n\t  free(list); \\\n\t} \\\n    }\n#else\n#define Check_CTYPE_Field(result, buffer, width, ccheck) \\\n  while (*buffer && *buffer == ' ') \\\n    buffer++; \\\n  if (*buffer) \\\n    { \\\n      unsigned char *s = buffer; \\\n      int l = -1; \\\n      while (*buffer && ccheck(*buffer, NULL)) \\\n\tbuffer++; \\\n      l = (int)(buffer - s); \\\n      while (*buffer && *buffer == ' ') \\\n\tbuffer++; \\\n      result = ((*buffer || (l < width)) ? FALSE : TRUE); \\\n    }\n#endif\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}