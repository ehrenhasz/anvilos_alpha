{
  "module_name": "fty_generic.c",
  "hash_id": "6c4c9a28c0cef5708abeb7dbff9dda71939c69a1edc2f8d5a73b2aeb6616c620",
  "original_prompt": "Ingested from ncurses-6.4/form/fty_generic.c",
  "human_readable_source": " \n\n \n\n#include \"form.priv.h\"\n\nMODULE_ID(\"$Id: fty_generic.c,v 1.15 2021/03/27 23:49:53 tom Exp $\")\n\n \n#if NCURSES_INTEROP_FUNCS\n\n \nstatic void *\nGeneric_This_Type(void *arg)\n{\n  return (arg);\n}\n\n \nFORM_EXPORT(FIELDTYPE *)\n_nc_generic_fieldtype(bool (*const field_check) (FORM *, FIELD *, const void *),\n\t\t      bool (*const char_check) (int, FORM *, FIELD *, const\n\t\t\t\t\t\tvoid *),\n\t\t      bool (*const next) (FORM *, FIELD *, const void *),\n\t\t      bool (*const prev) (FORM *, FIELD *, const void *),\n\t\t      void (*freecallback) (void *))\n{\n  int code = E_SYSTEM_ERROR;\n  FIELDTYPE *res = (FIELDTYPE *)0;\n\n  TR_FUNC_BFR(5);\n\n  T((T_CALLED(\"_nc_generic_fieldtype(%s,%s,%s,%s,%s)\"),\n     TR_FUNC_ARG(0, field_check),\n     TR_FUNC_ARG(1, char_check),\n     TR_FUNC_ARG(2, next),\n     TR_FUNC_ARG(3, prev),\n     TR_FUNC_ARG(4, freecallback)));\n\n  if (field_check || char_check)\n    {\n      res = typeMalloc(FIELDTYPE, 1);\n\n      if (res)\n\t{\n\t  *res = *_nc_Default_FieldType;\n\t  SetStatus(res, (_HAS_ARGS | _GENERIC));\n\t  res->fieldcheck.gfcheck = field_check;\n\t  res->charcheck.gccheck = char_check;\n\t  res->genericarg = Generic_This_Type;\n\t  res->freearg = freecallback;\n\t  res->enum_next.gnext = next;\n\t  res->enum_prev.gprev = prev;\n\t  code = E_OK;\n\t}\n    }\n  else\n    code = E_BAD_ARGUMENT;\n\n  if (E_OK != code)\n    SET_ERROR(code);\n\n  returnFieldType(res);\n}\n\n \nstatic TypeArgument *\nGenericArgument(const FIELDTYPE *typ,\n\t\tint (*argiterator) (void **), int *err)\n{\n  TypeArgument *res = (TypeArgument *)0;\n\n  if (typ != 0 && (typ->status & _HAS_ARGS) != 0 && err != 0 && argiterator != 0)\n    {\n      if (typ->status & _LINKED_TYPE)\n\t{\n\t   \n\t  TypeArgument *p = typeMalloc(TypeArgument, 1);\n\n\t  if (p)\n\t    {\n\t      p->left = GenericArgument(typ->left, argiterator, err);\n\t      p->right = GenericArgument(typ->right, argiterator, err);\n\t      return p;\n\t    }\n\t  else\n\t    *err += 1;\n\t}\n      else\n\t{\n\t  assert(typ->genericarg != (void *)0);\n\t  if (typ->genericarg == 0)\n\t    *err += 1;\n\t  else\n\t    {\n\t      void *argp;\n\t      int valid = argiterator(&argp);\n\n\t      if (valid == 0 || argp == 0 ||\n\t\t  !(res = (TypeArgument *)typ->genericarg(argp)))\n\t\t{\n\t\t  *err += 1;\n\t\t}\n\t    }\n\t}\n    }\n  return res;\n}\n\n \nFORM_EXPORT(int)\n_nc_set_generic_fieldtype(FIELD *field,\n\t\t\t  FIELDTYPE *ftyp,\n\t\t\t  int (*argiterator) (void **))\n{\n  int code = E_SYSTEM_ERROR;\n  int err = 0;\n\n  if (field)\n    {\n      if (field && field->type)\n\t_nc_Free_Type(field);\n\n      field->type = ftyp;\n      if (ftyp)\n\t{\n\t  if (argiterator)\n\t    {\n\t       \n\t      field->arg = (void *)GenericArgument(field->type, argiterator, &err);\n\n\t      if (err)\n\t\t{\n\t\t  _nc_Free_Argument(field->type, (TypeArgument *)(field->arg));\n\t\t  field->type = (FIELDTYPE *)0;\n\t\t  field->arg = (void *)0;\n\t\t}\n\t      else\n\t\t{\n\t\t  code = E_OK;\n\t\t  if (field->type)\n\t\t    field->type->ref++;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  field->arg = (void *)0;\n\t  code = E_OK;\n\t}\n    }\n  return code;\n}\n\n \nFORM_EXPORT(WINDOW *)\n_nc_form_cursor(const FORM *form, int *pRow, int *pCol)\n{\n  int code = E_SYSTEM_ERROR;\n  WINDOW *res = (WINDOW *)0;\n\n  if (form != 0 && pRow != 0 && pCol != 0)\n    {\n      *pRow = form->currow;\n      *pCol = form->curcol;\n      res = form->w;\n      code = E_OK;\n    }\n  if (code != E_OK)\n    SET_ERROR(code);\n  return res;\n}\n\n#else\nextern void _nc_fty_generic(void);\nvoid\n_nc_fty_generic(void)\n{\n}\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}