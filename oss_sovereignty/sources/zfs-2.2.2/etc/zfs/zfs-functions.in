









PATH=/sbin:/bin:/usr/bin:/usr/sbin


if [ -f /etc/rc.d/init.d/functions ]; then
	
	. /etc/rc.d/init.d/functions
elif [ -L /etc/init.d/functions.sh ]; then
	
	. /etc/init.d/functions.sh
elif [ -f /lib/lsb/init-functions ]; then
	
	. /lib/lsb/init-functions
fi




if type log_failure_msg > /dev/null 2>&1 ; then
	
	zfs_log_begin_msg() { log_begin_msg "$1"; }
	zfs_log_end_msg() { log_end_msg "$1"; }
	zfs_log_failure_msg() { log_failure_msg "$1"; }
	zfs_log_progress_msg() { log_progress_msg "$1"; }
elif type success > /dev/null 2>&1 ; then
	
	zfs_set_ifs() {
		
		
		local tIFS="$1"
		if [ -n "$tIFS" ]
		then
			TMP_IFS="$IFS"
			IFS="$tIFS"
		fi
	}

	zfs_log_begin_msg() { printf "%s" "$1 "; }
	zfs_log_end_msg() {
		
		zfs_set_ifs "$OLD_IFS"
		if [ "$1" -eq 0 ]; then
			success
		else
			failure
		fi
		echo
		zfs_set_ifs "$TMP_IFS"
	}
	zfs_log_failure_msg() {
		zfs_set_ifs "$OLD_IFS"
		failure
		echo
		zfs_set_ifs "$TMP_IFS"
	}
	zfs_log_progress_msg() { printf "%s" "$""$1"; }
elif type einfo > /dev/null 2>&1 ; then
	
	zfs_log_begin_msg() { ebegin "$1"; }
	zfs_log_end_msg() { eend "$1"; }
	zfs_log_failure_msg() { eend "$1"; }

	zfs_log_progress_msg() { :; }
else
	
	zfs_log_begin_msg() { printf "%s" "$1"; }
	zfs_log_end_msg() {
		ret=$1
		if [ "$ret" -ge 1 ]; then
			echo " failed!"
		else
			echo " success"
		fi
		return "$ret"
	}
	zfs_log_failure_msg() { echo "$1"; }
	zfs_log_progress_msg() { printf "%s" "$1"; }
fi


ZFS="@sbindir@/zfs"
ZED="@sbindir@/zed"
ZPOOL="@sbindir@/zpool"
ZPOOL_CACHE="@sysconfdir@/zfs/zpool.cache"


ZFS_LOAD_KEY='yes'
ZFS_UNLOAD_KEY='no'
ZFS_MOUNT='yes'
ZFS_UNMOUNT='yes'
ZFS_SHARE='yes'
ZFS_UNSHARE='yes'


if [ -f @initconfdir@/zfs ]; then
	. @initconfdir@/zfs
fi



export ZFS ZED ZPOOL ZPOOL_CACHE ZFS_LOAD_KEY ZFS_UNLOAD_KEY ZFS_MOUNT ZFS_UNMOUNT \
    ZFS_SHARE ZFS_UNSHARE

zfs_action()
{
	local MSG="$1";	shift
	local CMD="$*"
	local ret

	zfs_log_begin_msg "$MSG "
	$CMD
	ret=$?
	if [ "$ret" -eq 0 ]; then
		zfs_log_end_msg "$ret"
	else
		zfs_log_failure_msg "$ret"
	fi

	return "$ret"
}







zfs_daemon_start()
{
	local PIDFILE="$1";	shift
	local DAEMON_BIN="$1";	shift

	if type start-stop-daemon > /dev/null 2>&1 ; then
		
		start-stop-daemon --start --quiet --pidfile "$PIDFILE" \
		    --exec "$DAEMON_BIN" --test > /dev/null || return 1

		
		start-stop-daemon --start --quiet --exec "$DAEMON_BIN" -- \
		    "$@" || return 2

		
		
		
		
		if [ -f "$PIDFILE" ] && [ -d /run/sendsigs.omit.d ]
		then
			ln -sf "$PIDFILE" /run/sendsigs.omit.d/zed
		fi
	elif type daemon > /dev/null 2>&1 ; then
		
		
		daemon --pidfile "$PIDFILE" "$DAEMON_BIN" "$@"
		return $?
	else
		
		return 3
	fi

	return 0
}







zfs_daemon_stop()
{
	local PIDFILE="$1"
	local DAEMON_BIN="$2"
	local DAEMON_NAME="$3"

	if type start-stop-daemon > /dev/null 2>&1 ; then
		
		start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 \
		    --pidfile "$PIDFILE" --name "$DAEMON_NAME"
		ret="$?"
		[ "$ret" = 0 ] && rm -f "$PIDFILE"

		return "$ret"
	elif type killproc > /dev/null 2>&1 ; then
		
		killproc -p "$PIDFILE" "$DAEMON_NAME"
		ret="$?"
		[ "$ret" = 0 ] && rm -f "$PIDFILE"

		return "$ret"
	else
		
		return 3
	fi

	return 0
}


zfs_daemon_status()
{
	local PIDFILE="$1"
	local DAEMON_BIN="$2"
	local DAEMON_NAME="$3"

	if type status_of_proc > /dev/null 2>&1 ; then
		
		status_of_proc "$DAEMON_NAME" "$DAEMON_BIN"
		return $?
	elif type status > /dev/null 2>&1 ; then
		
		status -p "$PIDFILE" "$DAEMON_NAME"
		return $?
	else
		
		return 3
	fi

	return 0
}

zfs_daemon_reload()
{
	local PIDFILE="$1"
	local DAEMON_NAME="$2"

	if type start-stop-daemon > /dev/null 2>&1 ; then
		
		start-stop-daemon --stop --signal 1 --quiet \
		    --pidfile "$PIDFILE" --name "$DAEMON_NAME"
		return $?
	elif type killproc > /dev/null 2>&1 ; then
		
		killproc -p "$PIDFILE" "$DAEMON_NAME" -HUP
		return $?
	else
		
		return 3
	fi

	return 0
}

zfs_installed()
{
	if [ ! -x "$ZPOOL" ]; then
		return 1
	else
		
		"$ZPOOL" -? > /dev/null 2>&1
		return $?
	fi

	if [ ! -x "$ZFS" ]; then
		return 2
	else
		
		"$ZFS" -? > /dev/null 2>&1
		return $?
	fi

	return 0
}


udev_trigger()
{
	if [ -x /sbin/udevadm ]; then
		/sbin/udevadm trigger --action=change --subsystem-match=block
		/sbin/udevadm settle
	elif [ -x /sbin/udevsettle ]; then
		/sbin/udevtrigger
		/sbin/udevsettle
	fi
}


checksystem()
{
	if grep -qiE '(^|[^\\](\\\\)* )zfs=(off|no|0)( |$)' /proc/cmdline;
	then
		
		
		
		
		
		
		[ -n "$init" ] && exit 3
	fi

	
	zfs_installed || return 5

	
	udev_trigger

	return 0
}

get_root_pool()
{
	
	set -- $(mount | grep ' on / ')
	[ "$5" = "zfs" ] && echo "${1%%/*}"
}



check_boolean()
{
	local var="$1"

	echo "$var" | grep -Eiq "^yes$|^on$|^true$|^1$" && return 0 || return 1
}

check_module_loaded()
{
	module="$1"

	[ -r "/sys/module/${module}/version" ] && return 0 || return 1
}

load_module()
{
	module="$1"

	
	if ! check_module_loaded "$module"; then
		if ! /sbin/modprobe "$module"; then
			return 5
		fi
	fi
	return 0
}


read_mtab()
{
	local match="$1"
	local fs mntpnt fstype opts rest

	
	
	unset $(env | sed -e '/^MTAB_/!d' -e 's,=.*,,')

	while read -r fs mntpnt fstype opts rest; do
		if echo "$fs $mntpnt $fstype $opts" | grep -qE "$match"; then
			
			
			
			
			
			
			
			mntpnt=$(/bin/echo "$mntpnt" | sed 's,\\0,\\00,g')
			fs=$(/bin/echo "$fs" | sed 's,\\0,\\00,')

			
			mntpnt=$(printf '%b' "$mntpnt" | tr -d '/. -')
			fs=$(printf '%b' "$fs")

			
			eval export "MTAB_$mntpnt=\"$fs\""
		fi
	done < /proc/self/mounts
}

in_mtab()
{
	local mntpnt="$1"
	
	mntpnt=$(printf '%b' "$mntpnt" | tr -d '/. -')
	local var

	var="$(eval echo "MTAB_$mntpnt")"
	[ "$(eval echo "$""$var")" != "" ]
	return "$?"
}


read_fstab()
{
	local match="$1"
	local i var

	
	
	unset $(env | sed -e '/^FSTAB_/!d' -e 's,=.*,,')

	i=0
	while read -r fs mntpnt fstype opts; do
		echo "$fs" | grep -qE '^
		echo "$mntpnt" | grep -qE '^none|^swap' && continue
		echo "$fstype" | grep -qE '^swap' && continue

		if echo "$fs $mntpnt $fstype $opts" | grep -qE "$match"; then
			eval export "FSTAB_dev_$i=$fs"
			fs=$(printf '%b' "$fs" | tr '/' '_')
			eval export "FSTAB_$i=$mntpnt"

			i=$((i + 1))
		fi
	done < /etc/fstab
}

in_fstab()
{
	local var

	var="$(eval echo "FSTAB_$1")"
	[ "${var}" != "" ]
	return $?
}

is_mounted()
{
	local mntpt="$1"
	local mp

	while read -r _ mp _; do
		[ "$mp" = "$mntpt" ] && return 0
	done < /proc/self/mounts

	return 1
}
