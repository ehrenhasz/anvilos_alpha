{
  "module_name": "history.c",
  "hash_id": "01d147ce781084dd8c1476a38248af5585db16b5b154e5d8710bbfbd9ad885a3",
  "original_prompt": "Ingested from readline-8.2/history.c",
  "human_readable_source": " \n\n \n\n \n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <errno.h>\n\n#include \"history.h\"\n#include \"histlib.h\"\n\n#include \"xmalloc.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n \n#define DEFAULT_HISTORY_INITIAL_SIZE\t502\n\n#define MAX_HISTORY_INITIAL_SIZE\t8192\n\n \n#define DEFAULT_HISTORY_GROW_SIZE 50\n\nstatic char *hist_inittime (void);\n\n \n \n \n \n \n\n \nstatic HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;\n\n \nstatic int history_stifled;\n\n \nstatic int history_size;\n\n \nint history_max_entries;\nint max_input_history;\t \n\n \nint history_offset;\n\n \nint history_length;\n\n \nint history_base = 1;\n\n \nHISTORY_STATE *\nhistory_get_history_state (void)\n{\n  HISTORY_STATE *state;\n\n  state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));\n  state->entries = the_history;\n  state->offset = history_offset;\n  state->length = history_length;\n  state->size = history_size;\n  state->flags = 0;\n  if (history_stifled)\n    state->flags |= HS_STIFLED;\n\n  return (state);\n}\n\n \nvoid\nhistory_set_history_state (HISTORY_STATE *state)\n{\n  the_history = state->entries;\n  history_offset = state->offset;\n  history_length = state->length;\n  history_size = state->size;\n  if (state->flags & HS_STIFLED)\n    history_stifled = 1;\n}\n\n \nvoid\nusing_history (void)\n{\n  history_offset = history_length;\n}\n\n \nint\nhistory_total_bytes (void)\n{\n  register int i, result;\n\n  for (i = result = 0; the_history && the_history[i]; i++)\n    result += HISTENT_BYTES (the_history[i]);\n\n  return (result);\n}\n\n \nint\nwhere_history (void)\n{\n  return (history_offset);\n}\n\n \nint\nhistory_set_pos (int pos)\n{\n  if (pos > history_length || pos < 0 || !the_history)\n    return (0);\n  history_offset = pos;\n  return (1);\n}\n\n \nint\n_hs_at_end_of_history (void)\n{\n  return (the_history == 0 || history_offset == history_length);\n}\n \n \nHIST_ENTRY **\nhistory_list (void)\n{\n  return (the_history);\n}\n\n \nHIST_ENTRY *\ncurrent_history (void)\n{\n  return ((history_offset == history_length) || the_history == 0)\n\t\t? (HIST_ENTRY *)NULL\n\t\t: the_history[history_offset];\n}\n\n \nHIST_ENTRY *\nprevious_history (void)\n{\n  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;\n}\n\n \nHIST_ENTRY *\nnext_history (void)\n{\n  return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];\n}\n\n \nHIST_ENTRY *\nhistory_get (int offset)\n{\n  int local_index;\n\n  local_index = offset - history_base;\n  return (local_index >= history_length || local_index < 0 || the_history == 0)\n\t\t? (HIST_ENTRY *)NULL\n\t\t: the_history[local_index];\n}\n\nHIST_ENTRY *\nalloc_history_entry (char *string, char *ts)\n{\n  HIST_ENTRY *temp;\n\n  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));\n\n  temp->line = string ? savestring (string) : string;\n  temp->data = (char *)NULL;\n  temp->timestamp = ts;\n\n  return temp;\n}\n\ntime_t\nhistory_get_time (HIST_ENTRY *hist)\n{\n  char *ts;\n  time_t t;\n\n  if (hist == 0 || hist->timestamp == 0)\n    return 0;\n  ts = hist->timestamp;\n  if (ts[0] != history_comment_char)\n    return 0;\n  errno = 0;\n  t = (time_t) strtol (ts + 1, (char **)NULL, 10);\t\t \n  if (errno == ERANGE)\n    return (time_t)0;\n  return t;\n}\n\nstatic char *\nhist_inittime (void)\n{\n  time_t t;\n  char ts[64], *ret;\n\n  t = (time_t) time ((time_t *)0);\n#if defined (HAVE_VSNPRINTF)\t\t \n  snprintf (ts, sizeof (ts) - 1, \"X%lu\", (unsigned long) t);\n#else\n  sprintf (ts, \"X%lu\", (unsigned long) t);\n#endif\n  ret = savestring (ts);\n  ret[0] = history_comment_char;\n\n  return ret;\n}\n\n \nvoid\nadd_history (const char *string)\n{\n  HIST_ENTRY *temp;\n  int new_length;\n\n  if (history_stifled && (history_length == history_max_entries))\n    {\n      register int i;\n\n       \n      if (history_length == 0)\n\treturn;\n\n       \n      if (the_history[0])\n\t(void) free_history_entry (the_history[0]);\n\n       \n      memmove (the_history, the_history + 1, history_length * sizeof (HIST_ENTRY *));\n\n      new_length = history_length;\n      history_base++;\n    }\n  else\n    {\n      if (history_size == 0)\n\t{\n\t  if (history_stifled && history_max_entries > 0)\n\t    history_size = (history_max_entries > MAX_HISTORY_INITIAL_SIZE)\n\t\t\t\t? MAX_HISTORY_INITIAL_SIZE\n\t\t\t\t: history_max_entries + 2;\n\t  else\n\t    history_size = DEFAULT_HISTORY_INITIAL_SIZE;\n\t  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));\n\t  new_length = 1;\n\t}\n      else\n\t{\n\t  if (history_length == (history_size - 1))\n\t    {\n\t      history_size += DEFAULT_HISTORY_GROW_SIZE;\n\t      the_history = (HIST_ENTRY **)\n\t\txrealloc (the_history, history_size * sizeof (HIST_ENTRY *));\n\t    }\n\t  new_length = history_length + 1;\n\t}\n    }\n\n  temp = alloc_history_entry ((char *)string, hist_inittime ());\n\n  the_history[new_length] = (HIST_ENTRY *)NULL;\n  the_history[new_length - 1] = temp;\n  history_length = new_length;\n}\n\n \nvoid\nadd_history_time (const char *string)\n{\n  HIST_ENTRY *hs;\n\n  if (string == 0 || history_length < 1)\n    return;\n  hs = the_history[history_length - 1];\n  FREE (hs->timestamp);\n  hs->timestamp = savestring (string);\n}\n\n \nhistdata_t\nfree_history_entry (HIST_ENTRY *hist)\n{\n  histdata_t x;\n\n  if (hist == 0)\n    return ((histdata_t) 0);\n  FREE (hist->line);\n  FREE (hist->timestamp);\n  x = hist->data;\n  xfree (hist);\n  return (x);\n}\n\nHIST_ENTRY *\ncopy_history_entry (HIST_ENTRY *hist)\n{\n  HIST_ENTRY *ret;\n  char *ts;\n\n  if (hist == 0)\n    return hist;\n\n  ret = alloc_history_entry (hist->line, (char *)NULL);\n\n  ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;\n  ret->timestamp = ts;\n\n  ret->data = hist->data;\n\n  return ret;\n}\n  \n \nHIST_ENTRY *\nreplace_history_entry (int which, const char *line, histdata_t data)\n{\n  HIST_ENTRY *temp, *old_value;\n\n  if (which < 0 || which >= history_length)\n    return ((HIST_ENTRY *)NULL);\n\n  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));\n  old_value = the_history[which];\n\n  temp->line = savestring (line);\n  temp->data = data;\n  temp->timestamp = old_value->timestamp ? savestring (old_value->timestamp) : 0;\n  the_history[which] = temp;\n\n  return (old_value);\n}\n\n \nvoid\n_hs_append_history_line (int which, const char *line)\n{\n  HIST_ENTRY *hent;\n  size_t newlen, curlen, minlen;\n  char *newline;\n\n  hent = the_history[which];\n  curlen = strlen (hent->line);\n  minlen = curlen + strlen (line) + 2;\t \n  if (curlen > 256)\t\t \n    {\n      newlen = 512;\t\t \n       \n      while (newlen < minlen)\n\tnewlen <<= 1;\n    }\n  else\n    newlen = minlen;\n   \n  newline = realloc (hent->line, newlen);\n  if (newline)\n    {\n      hent->line = newline;\n      hent->line[curlen++] = '\\n';\n      strcpy (hent->line + curlen, line);\n    }\n}\n\n \nvoid\n_hs_replace_history_data (int which, histdata_t *old, histdata_t *new)\n{\n  HIST_ENTRY *entry;\n  register int i, last;\n\n  if (which < -2 || which >= history_length || history_length == 0 || the_history == 0)\n    return;\n\n  if (which >= 0)\n    {\n      entry = the_history[which];\n      if (entry && entry->data == old)\n\tentry->data = new;\n      return;\n    }\n\n  last = -1;\n  for (i = 0; i < history_length; i++)\n    {\n      entry = the_history[i];\n      if (entry == 0)\n\tcontinue;\n      if (entry->data == old)\n\t{\n\t  last = i;\n\t  if (which == -1)\n\t    entry->data = new;\n\t}\n    }\n  if (which == -2 && last >= 0)\n    {\n      entry = the_history[last];\n      entry->data = new;\t \n    }\n}      \n  \n \nHIST_ENTRY *\nremove_history (int which)\n{\n  HIST_ENTRY *return_value;\n  register int i;\n#if 1\n  int nentries;\n  HIST_ENTRY **start, **end;\n#endif\n\n  if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)\n    return ((HIST_ENTRY *)NULL);\n\n  return_value = the_history[which];\n\n#if 1\n   \n  nentries = history_length - which;\n  start = the_history + which;\n  end = start + 1;\n  memmove (start, end, nentries * sizeof (HIST_ENTRY *));\n#else\n  for (i = which; i < history_length; i++)\n    the_history[i] = the_history[i + 1];\n#endif\n\n  history_length--;\n\n  return (return_value);\n}\n\nHIST_ENTRY **\nremove_history_range (int first, int last)\n{\n  HIST_ENTRY **return_value;\n  register int i;\n  int nentries;\n  HIST_ENTRY **start, **end;\n\n  if (the_history == 0 || history_length == 0)\n    return ((HIST_ENTRY **)NULL);\n  if (first < 0 || first >= history_length || last < 0 || last >= history_length)\n    return ((HIST_ENTRY **)NULL);\n  if (first > last)\n    return (HIST_ENTRY **)NULL;\n\n  nentries = last - first + 1;\n  return_value = (HIST_ENTRY **)malloc ((nentries + 1) * sizeof (HIST_ENTRY *));\n  if (return_value == 0)\n    return return_value;\n\n   \n  for (i = first ; i <= last; i++)\n    return_value[i - first] = the_history[i];\n  return_value[i - first] = (HIST_ENTRY *)NULL;\n\n   \n  start = the_history + first;\n  end = the_history + last + 1;\n  memmove (start, end, (history_length - last) * sizeof (HIST_ENTRY *));\n\n  history_length -= nentries;\n\n  return (return_value);\n}\n\n \nvoid\nstifle_history (int max)\n{\n  register int i, j;\n\n  if (max < 0)\n    max = 0;\n\n  if (history_length > max)\n    {\n       \n      for (i = 0, j = history_length - max; i < j; i++)\n\tfree_history_entry (the_history[i]);\n\n      history_base = i;\n      for (j = 0, i = history_length - max; j < max; i++, j++)\n\tthe_history[j] = the_history[i];\n      the_history[j] = (HIST_ENTRY *)NULL;\n      history_length = j;\n    }\n\n  history_stifled = 1;\n  max_input_history = history_max_entries = max;\n}\n\n \nint\nunstifle_history (void)\n{\n  if (history_stifled)\n    {\n      history_stifled = 0;\n      return (history_max_entries);\n    }\n  else\n    return (-history_max_entries);\n}\n\nint\nhistory_is_stifled (void)\n{\n  return (history_stifled);\n}\n\nvoid\nclear_history (void)\n{\n  register int i;\n\n   \n  for (i = 0; i < history_length; i++)\n    {\n      free_history_entry (the_history[i]);\n      the_history[i] = (HIST_ENTRY *)NULL;\n    }\n\n  history_offset = history_length = 0;\n  history_base = 1;\t\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}