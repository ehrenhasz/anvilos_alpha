{
  "module_name": "mbutil.c",
  "hash_id": "e0c9b67a2689156ece8f7c977193a72f4e5987445abbe6a0fcd2cd9633db6392",
  "original_prompt": "Ingested from readline-8.2/mbutil.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"posixjmp.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\t    \n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n#include <ctype.h>\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#if defined (TIOCSTAT_IN_SYS_IOCTL)\n#  include <sys/ioctl.h>\n#endif  \n\n \n#include \"readline.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n \n#if defined (HANDLE_MULTIBYTE)\nint rl_byte_oriented = 0;\n#else\nint rl_byte_oriented = 1;\n#endif\n\n \nint _rl_utf8locale = 0;\n\n \n \n \n \n \n\n#if defined(HANDLE_MULTIBYTE)\n\n \n \n \n \n \n\n \nstatic int\n_rl_utf8_mblen (const char *s, size_t n)\n{\n  unsigned char c, c1, c2, c3;\n\n  if (s == 0)\n    return (0);\t \n  if (n <= 0)\n    return (-1);\n\n  c = (unsigned char)*s;\n  if (c < 0x80)\n    return (c != 0);\n  if (c >= 0xc2)\n    {\n      c1 = (unsigned char)s[1];\n      if (c < 0xe0)\n\t{\n\t  if (n == 1)\n\t    return -2;\n\t  if (n >= 2 && (c1 ^ 0x80) < 0x40)\n\t    return 2;\n\t}\n      else if (c < 0xf0)\n\t{\n\t  if (n == 1)\n\t    return -2;\n\t  if ((c1 ^ 0x80) < 0x40\n\t\t&& (c >= 0xe1 || c1 >= 0xa0)\n\t\t&& (c != 0xed || c1 < 0xa0))\n\t    {\n\t      if (n == 2)\n\t\treturn -2;\n\t      c2 = (unsigned char)s[2];\n\t      if ((c2 ^ 0x80) < 0x40)\n\t\treturn 3;\n\t    }\n\t}\n      else if (c < 0xf4)\n\t{\n\t  if (n == 1)\n\t    return -2;\n\t  if (((c1 ^ 0x80) < 0x40)\n\t\t&& (c >= 0xf1 || c1 >= 0x90)\n\t\t&& (c < 0xf4 || (c == 0xf4 && c1 < 0x90)))\n\t    {\n\t      if (n == 2)\n\t\treturn -2;\n\t      c2 = (unsigned char)s[2];\n\t      if ((c2 ^ 0x80) < 0x40)\n\t\t{\n\t\t  if (n == 3)\n\t\t    return -2;\n\t\t  c3 = (unsigned char)s[3];\n\t\t  if ((c3 ^ 0x80) < 0x40)\n\t\t    return 4;\n\t\t}\n\t    }\n\t}\n    }\n   \n  return -1;\n}\n\nstatic int\n_rl_find_next_mbchar_internal (char *string, int seed, int count, int find_non_zero)\n{\n  size_t tmp, len;\n  mbstate_t ps;\n  int point;\n  WCHAR_T wc;\n\n  tmp = 0;\n\n  memset(&ps, 0, sizeof (mbstate_t));\n  if (seed < 0)\n    seed = 0;\n  if (count <= 0)\n    return seed;\n\n  point = seed + _rl_adjust_point (string, seed, &ps);\n   \n  if (point == seed - 1)\t \n    return seed + 1;\n    \n   \n  if (seed < point)\n    count--;\n\n  while (count > 0)  \n    {\n      len = strlen (string + point);\n      if (len == 0)\n\tbreak;\n      if (_rl_utf8locale && UTF8_SINGLEBYTE(string[point]))\n\t{\n\t  tmp = 1;\n\t  wc = (WCHAR_T) string[point];\n\t  memset(&ps, 0, sizeof(mbstate_t));\n\t}\n      else\n\ttmp = MBRTOWC (&wc, string+point, len, &ps);\n      if (MB_INVALIDCH ((size_t)tmp))\n\t{\n\t   \n\t  point++;\n\t  count--;\n\t   \n\t  memset(&ps, 0, sizeof(mbstate_t));\n\t}\n      else if (MB_NULLWCH (tmp))\n\tbreak;\t\t\t \n      else\n\t{\n\t   \n\t  point += tmp;\n\t  if (find_non_zero)\n\t    {\n\t      if (WCWIDTH (wc) == 0)\n\t\tcontinue;\n\t      else\n\t\tcount--;\n\t    }\n\t  else\n\t    count--;\n\t}\n    }\n\n  if (find_non_zero)\n    {\n      tmp = MBRTOWC (&wc, string + point, strlen (string + point), &ps);\n      while (MB_NULLWCH (tmp) == 0 && MB_INVALIDCH (tmp) == 0 && WCWIDTH (wc) == 0)\n\t{\n\t  point += tmp;\n\t  tmp = MBRTOWC (&wc, string + point, strlen (string + point), &ps);\n\t}\n    }\n\n  return point;\n}\n\nstatic inline int\n_rl_test_nonzero (char *string, int ind, int len)\n{\n  size_t tmp;\n  WCHAR_T wc;\n  mbstate_t ps;\n\n  memset (&ps, 0, sizeof (mbstate_t));\n  tmp = MBRTOWC (&wc, string + ind, len - ind, &ps);\n   \n  return (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp) || WCWIDTH (wc) > 0);\n}\n\n \nstatic int\n_rl_find_prev_utf8char (char *string, int seed, int find_non_zero)\n{\n  char *s;\n  unsigned char b;\n  int save, prev;\n  size_t len;\n\n  if (find_non_zero)\n    len = RL_STRLEN (string);\n\n  prev = seed - 1;\n  while (prev >= 0)\n   {\n      b = (unsigned char)string[prev];\n      if (UTF8_SINGLEBYTE (b))\n\treturn (prev);\n\n      save = prev;\n\n       \n      if (UTF8_MBCHAR (b))\n\t{\n\t  while (prev > 0 && (b = (unsigned char)string[--prev]) && UTF8_MBCHAR (b))\n\t    ;\n\t}\n\n      if (UTF8_MBFIRSTCHAR (b))\n\t{\n\t  if (find_non_zero)\n\t    {\n\t      if (_rl_test_nonzero (string, prev, len))\n\t\treturn (prev);\n\t      else\t\t \n\t\tprev = prev - 1;\n\t    }\n\t  else\n\t    return (prev);\n\t}\n      else\n\treturn (save);\t\t\t \n    }\n\n  return ((prev < 0) ? 0 : prev);\n}  \n\n  int\n_rl_find_prev_mbchar_internal (char *string, int seed, int find_non_zero)\n{\n  mbstate_t ps;\n  int prev, non_zero_prev, point, length;\n  size_t tmp;\n  WCHAR_T wc;\n\n  if (_rl_utf8locale)\n    return (_rl_find_prev_utf8char (string, seed, find_non_zero));\n\n  memset(&ps, 0, sizeof(mbstate_t));\n  length = strlen(string);\n  \n  if (seed < 0)\n    return 0;\n  else if (length < seed)\n    return length;\n\n  prev = non_zero_prev = point = 0;\n  while (point < seed)\n    {\n      if (_rl_utf8locale && UTF8_SINGLEBYTE(string[point]))\n\t{\n\t  tmp = 1;\n\t  wc = (WCHAR_T) string[point];\n\t  memset(&ps, 0, sizeof(mbstate_t));\n\t}\n      else\n\ttmp = MBRTOWC (&wc, string + point, length - point, &ps);\n      if (MB_INVALIDCH ((size_t)tmp))\n\t{\n\t   \n\t  tmp = 1;\n\t   \n\t  memset(&ps, 0, sizeof (mbstate_t));\n\n\t   \n\t  prev = point;\n\t}\n      else if (MB_NULLWCH (tmp))\n\tbreak;\t\t\t \n      else\n\t{\n\t  if (find_non_zero)\n\t    {\n\t      if (WCWIDTH (wc) != 0)\n\t\tprev = point;\n\t    }\n\t  else\n\t    prev = point;  \n\t}\n\n      point += tmp;\n    }\n\n  return prev;\n}\n\n \nint\n_rl_get_char_len (char *src, mbstate_t *ps)\n{\n  size_t tmp, l;\n  int mb_cur_max;\n\n   \n  l = (size_t)strlen (src);\n  if (_rl_utf8locale && l > 0 && UTF8_SINGLEBYTE(*src))\n    tmp = (*src != 0) ? 1 : 0;\n  else\n    {\n      mb_cur_max = MB_CUR_MAX;\n      tmp = mbrlen((const char *)src, (l < mb_cur_max) ? l : mb_cur_max, ps);\n    }\n  if (tmp == (size_t)(-2))\n    {\n       \n      if (ps)\n\tmemset (ps, 0, sizeof(mbstate_t));\n      return -2;\n    }\n  else if (tmp == (size_t)(-1))\n    {\n       \n       \n      if (ps)\n\tmemset (ps, 0, sizeof(mbstate_t));\n      return -1;\n    }\n  else if (tmp == (size_t)0)\n    return 0;\n  else\n    return (int)tmp;\n}\n\n \nint\n_rl_compare_chars (char *buf1, int pos1, mbstate_t *ps1, char *buf2, int pos2, mbstate_t *ps2)\n{\n  int i, w1, w2;\n\n  if ((w1 = _rl_get_char_len (&buf1[pos1], ps1)) <= 0 || \n\t(w2 = _rl_get_char_len (&buf2[pos2], ps2)) <= 0 ||\n\t(w1 != w2) ||\n\t(buf1[pos1] != buf2[pos2]))\n    return 0;\n\n  for (i = 1; i < w1; i++)\n    if (buf1[pos1+i] != buf2[pos2+i])\n      return 0;\n\n  return 1;\n}\n\n \nint\n_rl_adjust_point (char *string, int point, mbstate_t *ps)\n{\n  size_t tmp;\n  int length, pos;\n\n  tmp = 0;\n  pos = 0;\n  length = strlen(string);\n  if (point < 0)\n    return -1;\n  if (length < point)\n    return -1;\n  \n  while (pos < point)\n    {\n      if (_rl_utf8locale && UTF8_SINGLEBYTE(string[pos]))\n\ttmp = 1;\n      else\n\ttmp = mbrlen (string + pos, length - pos, ps);\n      if (MB_INVALIDCH ((size_t)tmp))\n\t{\n\t   \n\t  pos++;\n\t   \n\t  if (ps)\n\t    memset (ps, 0, sizeof (mbstate_t));\n\t}\n      else if (MB_NULLWCH (tmp))\n\tpos++;\n      else\n\tpos += tmp;\n    }\n\n  return (pos - point);\n}\n\nint\n_rl_is_mbchar_matched (char *string, int seed, int end, char *mbchar, int length)\n{\n  int i;\n\n  if ((end - seed) < length)\n    return 0;\n\n  for (i = 0; i < length; i++)\n    if (string[seed + i] != mbchar[i])\n      return 0;\n  return 1;\n}\n\nWCHAR_T\n_rl_char_value (char *buf, int ind)\n{\n  size_t tmp;\n  WCHAR_T wc;\n  mbstate_t ps;\n  int l;\n\n  if (MB_LEN_MAX == 1 || rl_byte_oriented)\n    return ((WCHAR_T) buf[ind]);\n  if (_rl_utf8locale && UTF8_SINGLEBYTE(buf[ind]))\n    return ((WCHAR_T) buf[ind]);\n  l = strlen (buf);\n  if (ind >= l - 1)\n    return ((WCHAR_T) buf[ind]);\n  if (l < ind)\t\t\t \n    l = strlen (buf+ind);\n  memset (&ps, 0, sizeof (mbstate_t));\n  tmp = MBRTOWC (&wc, buf + ind, l - ind, &ps);\n  if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  \n    return ((WCHAR_T) buf[ind]);\n  return wc;\n}\n#endif  \n\n \n#undef _rl_find_next_mbchar\nint\n_rl_find_next_mbchar (char *string, int seed, int count, int flags)\n{\n#if defined (HANDLE_MULTIBYTE)\n  return _rl_find_next_mbchar_internal (string, seed, count, flags);\n#else\n  return (seed + count);\n#endif\n}\n\n \n#undef _rl_find_prev_mbchar\nint\n_rl_find_prev_mbchar (char *string, int seed, int flags)\n{\n#if defined (HANDLE_MULTIBYTE)\n  return _rl_find_prev_mbchar_internal (string, seed, flags);\n#else\n  return ((seed == 0) ? seed : seed - 1);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}