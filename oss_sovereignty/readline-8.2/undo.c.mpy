{
  "module_name": "undo.c",
  "hash_id": "84195fb18e67df3af6e860008db37e16288b587f667a5e8a3d18ec2cc64ee5cd",
  "original_prompt": "Ingested from readline-8.2/undo.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>            \n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n#include \"histlib.h\"\n\n \nint _rl_doing_an_undo = 0;\n\n \nint _rl_undo_group_level = 0;\n\n \nUNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;\n\n \n \n \n \n \n\nstatic UNDO_LIST *\nalloc_undo_entry (enum undo_code what, int start, int end, char *text)\n{\n  UNDO_LIST *temp;\n\n  temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));\n  temp->what = what;\n  temp->start = start;\n  temp->end = end;\n  temp->text = text;\n\n  temp->next = (UNDO_LIST *)NULL;\n  return temp;\n}\n\n \nvoid\nrl_add_undo (enum undo_code what, int start, int end, char *text)\n{\n  UNDO_LIST *temp;\n\n  temp = alloc_undo_entry (what, start, end, text);\n  temp->next = rl_undo_list;\n  rl_undo_list = temp;\n}\n\n \nvoid\n_rl_free_undo_list (UNDO_LIST *ul)\n{\n  UNDO_LIST *release;\n\n  while (ul)\n    {\n      release = ul;\n      ul = ul->next;\n\n      if (release->what == UNDO_DELETE)\n\txfree (release->text);\n\n      xfree (release);\n    }\n}\n\n \nvoid\nrl_free_undo_list (void)\n{\n  UNDO_LIST *release, *orig_list;\n\n  orig_list = rl_undo_list;\n  _rl_free_undo_list (rl_undo_list);\n  rl_undo_list = (UNDO_LIST *)NULL;\n  _hs_replace_history_data (-1, (histdata_t *)orig_list, (histdata_t *)NULL);\n}\n\nUNDO_LIST *\n_rl_copy_undo_entry (UNDO_LIST *entry)\n{\n  UNDO_LIST *new;\n\n  new = alloc_undo_entry (entry->what, entry->start, entry->end, (char *)NULL);\n  new->text = entry->text ? savestring (entry->text) : 0;\n  return new;\n}\n\nUNDO_LIST *\n_rl_copy_undo_list (UNDO_LIST *head)\n{\n  UNDO_LIST *list, *new, *roving, *c;\n\n  if (head == 0)\n    return head;\n\n  list = head;\n  new = 0;\n  while (list)\n    {\n      c = _rl_copy_undo_entry (list);\n      if (new == 0)\n\troving = new = c;\n      else\n\t{\n\t  roving->next = c;\n\t  roving = roving->next;\n\t}\n      list = list->next;\n    }\n\n  roving->next = 0;\n  return new;\n}\n\n \nint\nrl_do_undo (void)\n{\n  UNDO_LIST *release, *search;\n  int waiting_for_begin, start, end;\n  HIST_ENTRY *cur, *temp;\n\n#define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))\n\n  start = end = waiting_for_begin = 0;\n  do\n    {\n      if (rl_undo_list == 0)\n\treturn (0);\n\n      _rl_doing_an_undo = 1;\n      RL_SETSTATE(RL_STATE_UNDOING);\n\n       \n      if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)\n\t{\n\t  start = TRANS (rl_undo_list->start);\n\t  end = TRANS (rl_undo_list->end);\n\t}\n\n      switch (rl_undo_list->what)\n\t{\n\t \n\tcase UNDO_DELETE:\n\t  rl_point = start;\n\t  _rl_fix_point (1);\n\t  rl_insert_text (rl_undo_list->text);\n\t  xfree (rl_undo_list->text);\n\t  break;\n\n\t \n\tcase UNDO_INSERT:\n\t  rl_delete_text (start, end);\n\t  rl_point = start;\n\t  _rl_fix_point (1);\n\t  break;\n\n\t \n\tcase UNDO_END:\n\t  waiting_for_begin++;\n\t  break;\n\n\t \n\tcase UNDO_BEGIN:\n\t  if (waiting_for_begin)\n\t    waiting_for_begin--;\n\t  else\n\t    rl_ding ();\n\t  break;\n\t}\n\n      _rl_doing_an_undo = 0;\n      RL_UNSETSTATE(RL_STATE_UNDOING);\n\n      release = rl_undo_list;\n      rl_undo_list = rl_undo_list->next;\n      release->next = 0;\t \n\n       \n      cur = current_history ();\n      if (cur && cur->data && (UNDO_LIST *)cur->data == release)\n\t{\n\t  temp = replace_history_entry (where_history (), rl_line_buffer, (histdata_t)rl_undo_list);\n\t  xfree (temp->line);\n\t  FREE (temp->timestamp);\n\t  xfree (temp);\n\t}\n\n       \n      _hs_replace_history_data (-1, (histdata_t *)release, (histdata_t *)rl_undo_list);\n\n       \n      if (_rl_saved_line_for_history && _rl_saved_line_for_history->data)\n\t{\n\t   \n\t  search = (UNDO_LIST *)_rl_saved_line_for_history->data;\n\t  if (search == release)\n\t    _rl_saved_line_for_history->data = rl_undo_list;\n\t  else\n\t    {\n\t      while (search->next)\n\t\t{\n\t\t  if (search->next == release)\n\t\t    {\n\t\t      search->next = rl_undo_list;\n\t\t      break;\n\t\t    }\n\t\t  search = search->next;\n\t\t}\n\t    }\n\t}\n\n      xfree (release);\n    }\n  while (waiting_for_begin);\n\n  return (1);\n}\n#undef TRANS\n\nint\n_rl_fix_last_undo_of_type (int type, int start, int end)\n{\n  UNDO_LIST *rl;\n\n  for (rl = rl_undo_list; rl; rl = rl->next)\n    {\n      if (rl->what == type)\n\t{\n\t  rl->start = start;\n\t  rl->end = end;\n\t  return 0;\n\t}\n    }\n  return 1;\n}\n\n \nint\nrl_begin_undo_group (void)\n{\n  rl_add_undo (UNDO_BEGIN, 0, 0, 0);\n  _rl_undo_group_level++;\n  return 0;\n}\n\n \nint\nrl_end_undo_group (void)\n{\n  rl_add_undo (UNDO_END, 0, 0, 0);\n  _rl_undo_group_level--;\n  return 0;\n}\n\n \nint\nrl_modifying (int start, int end)\n{\n  if (start > end)\n    {\n      SWAP (start, end);\n    }\n\n  if (start != end)\n    {\n      char *temp = rl_copy_text (start, end);\n      rl_begin_undo_group ();\n      rl_add_undo (UNDO_DELETE, start, end, temp);\n      rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);\n      rl_end_undo_group ();\n    }\n  return 0;\n}\n\n \nint\nrl_revert_line (int count, int key)\n{\n  if (rl_undo_list == 0)\n    rl_ding ();\n  else\n    {\n      while (rl_undo_list)\n\trl_do_undo ();\n#if defined (VI_MODE)\n      if (rl_editing_mode == vi_mode)\n\trl_point = rl_mark = 0;\t\t \n#endif\n    }\n    \n  return 0;\n}\n\n \nint\nrl_undo_command (int count, int key)\n{\n  if (count < 0)\n    return 0;\t \n\n  while (count)\n    {\n      if (rl_do_undo ())\n\tcount--;\n      else\n\t{\n\t  rl_ding ();\n\t  break;\n\t}\n    }\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}