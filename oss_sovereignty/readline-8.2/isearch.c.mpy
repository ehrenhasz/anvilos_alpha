{
  "module_name": "isearch.c",
  "hash_id": "47ae326a0f557d7ed521c0f242c7c7c2bfaa14bd5e8d0134e696f5aa03a696c3",
  "original_prompt": "Ingested from readline-8.2/isearch.c",
  "human_readable_source": " \n\n \n \n \n \n \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif\n\n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n \nchar *_rl_isearch_terminators = (char *)NULL;\n\n_rl_search_cxt *_rl_iscxt = 0;\n\nstatic int rl_search_history (int, int);\n\nstatic _rl_search_cxt *_rl_isearch_init (int);\nstatic void _rl_isearch_fini (_rl_search_cxt *);\n\n \n \n\n \nstatic char *last_isearch_string;\nstatic int last_isearch_string_len;\n\nstatic char * const default_isearch_terminators = \"\\033\\012\";\n\n_rl_search_cxt *\n_rl_scxt_alloc (int type, int flags)\n{\n  _rl_search_cxt *cxt;\n\n  cxt = (_rl_search_cxt *)xmalloc (sizeof (_rl_search_cxt));\n\n  cxt->type = type;\n  cxt->sflags = flags;\n\n  cxt->search_string = 0;\n  cxt->search_string_size = cxt->search_string_index = 0;\n\n  cxt->lines = 0;\n  cxt->allocated_line = 0;\n  cxt->hlen = cxt->hindex = 0;\n\n  cxt->save_point = rl_point;\n  cxt->save_mark = rl_mark;\n  cxt->save_line = where_history ();\n  cxt->last_found_line = cxt->save_line;\n  cxt->prev_line_found = 0;\n\n  cxt->save_undo_list = 0;\n\n  cxt->keymap = _rl_keymap;\n  cxt->okeymap = _rl_keymap;\n\n  cxt->history_pos = 0;\n  cxt->direction = 0;\n\n  cxt->prevc = cxt->lastc = 0;\n\n  cxt->sline = 0;\n  cxt->sline_len = cxt->sline_index = 0;\n\n  cxt->search_terminators = 0;\n\n  return cxt;\n}\n\nvoid\n_rl_scxt_dispose (_rl_search_cxt *cxt, int flags)\n{\n  FREE (cxt->search_string);\n  FREE (cxt->allocated_line);\n  FREE (cxt->lines);\n\n  xfree (cxt);\n}\n\n \nint\nrl_reverse_search_history (int sign, int key)\n{\n  return (rl_search_history (-sign, key));\n}\n\n \nint\nrl_forward_search_history (int sign, int key)\n{\n  return (rl_search_history (sign, key));\n}\n\n \nstatic void\nrl_display_search (char *search_string, int flags, int where)\n{\n  char *message;\n  int msglen, searchlen;\n\n  searchlen = (search_string && *search_string) ? strlen (search_string) : 0;\n\n  message = (char *)xmalloc (searchlen + 64);\n  msglen = 0;\n\n#if defined (NOTDEF)\n  if (where != -1)\n    {\n      sprintf (message, \"[%d]\", where + history_base);\n      msglen = strlen (message);\n    }\n#endif  \n\n  message[msglen++] = '(';\n\n  if (flags & SF_FAILED)\n    {\n      strcpy (message + msglen, \"failed \");\n      msglen += 7;\n    }\n\n  if (flags & SF_REVERSE)\n    {\n      strcpy (message + msglen, \"reverse-\");\n      msglen += 8;\n    }\n\n  strcpy (message + msglen, \"i-search)`\");\n  msglen += 10;\n\n  if (search_string && *search_string)\n    {\n      strcpy (message + msglen, search_string);\n      msglen += searchlen;\n    }\n  else\n    _rl_optimize_redisplay ();\n\n  strcpy (message + msglen, \"': \");\n\n  rl_message (\"%s\", message);\n  xfree (message);\n#if 0\n   \n  (*rl_redisplay_function) ();\n#endif\n}\n\nstatic _rl_search_cxt *\n_rl_isearch_init (int direction)\n{\n  _rl_search_cxt *cxt;\n  register int i;\n  HIST_ENTRY **hlist;\n\n  cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);\n  if (direction < 0)\n    cxt->sflags |= SF_REVERSE;\n\n  cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators\n\t\t\t\t\t\t: default_isearch_terminators;\n\n   \n  hlist = history_list ();\n  rl_maybe_replace_line ();\n  i = 0;\n  if (hlist)\n    for (i = 0; hlist[i]; i++);\n\n   \n  cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));\n  for (i = 0; i < cxt->hlen; i++)\n    cxt->lines[i] = hlist[i]->line;\n\n  if (_rl_saved_line_for_history)\n    cxt->lines[i] = _rl_saved_line_for_history->line;\n  else\n    {\n       \n      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));\n      strcpy (cxt->allocated_line, &rl_line_buffer[0]);\n      cxt->lines[i] = cxt->allocated_line;\n    }\n\n  cxt->hlen++;\n\n   \n  cxt->history_pos = cxt->save_line;\n\n  rl_save_prompt ();\n\n   \n  cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);\n  cxt->search_string[cxt->search_string_index = 0] = '\\0';\n\n   \n  cxt->direction = (direction >= 0) ? 1 : -1;\n\n  cxt->sline = rl_line_buffer;\n  cxt->sline_len = strlen (cxt->sline);\n  cxt->sline_index = rl_point;\n\n  _rl_iscxt = cxt;\t\t \n\n   \n  _rl_init_executing_keyseq ();\n\n  return cxt;\n}\n\nstatic void\n_rl_isearch_fini (_rl_search_cxt *cxt)\n{\n   \n  rl_replace_line (cxt->lines[cxt->save_line], 0);\n\n  rl_restore_prompt ();\n\n   \n  FREE (last_isearch_string);\n  last_isearch_string = cxt->search_string;\n  last_isearch_string_len = cxt->search_string_index;\n  cxt->search_string = 0;\n  cxt->search_string_size = 0;\n  cxt->search_string_index = 0;\n\n  if (cxt->last_found_line < cxt->save_line)\n    rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);\n  else\n    rl_get_next_history (cxt->last_found_line - cxt->save_line, 0);\n\n   \n  if (cxt->sline_index < 0)\n    {\n      if (cxt->last_found_line == cxt->save_line)\n\tcxt->sline_index = cxt->save_point;\n      else\n\tcxt->sline_index = strlen (rl_line_buffer);\n      rl_mark = cxt->save_mark;\n      rl_deactivate_mark ();\n    }\n\n  rl_point = cxt->sline_index;\n   \n  _rl_fix_point (0);\n  rl_deactivate_mark ();\n\n \n  rl_clear_message ();\n}\n\n \nint\n_rl_search_getchar (_rl_search_cxt *cxt)\n{\n  int c;\n\n   \n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  c = cxt->lastc = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n#if defined (HANDLE_MULTIBYTE)\n   \n  if (c >= 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);\n#endif\n\n  RL_CHECK_SIGNALS ();\n  return c;\n}\n\n#define ENDSRCH_CHAR(c) \\\n  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))\n\n \nint\n_rl_isearch_dispatch (_rl_search_cxt *cxt, int c)\n{\n  int n, wstart, wlen, limit, cval, incr;\n  char *paste;\n  size_t pastelen;\n  int j;\n  rl_command_func_t *f;\n\n  f = (rl_command_func_t *)NULL;\n\n  if (c < 0)\n    {\n      cxt->sflags |= SF_FAILED;\n      cxt->history_pos = cxt->last_found_line;\n      return -1;\n    }\n\n  _rl_add_executing_keyseq (c);\n\n   \n  if (_rl_enable_bracketed_paste && c == ESC && strchr (cxt->search_terminators, c) && (n = _rl_nchars_available ()) > (BRACK_PASTE_SLEN-1))\n    {\n      j = _rl_read_bracketed_paste_prefix (c);\n      if (j == 1)\n\t{\n\t  cxt->lastc = -7;\t\t \n\t  goto opcode_dispatch;\t\n        }\n      else if (_rl_pushed_input_available ())\t \n\tc = cxt->lastc = rl_read_key ();\n      else\n\tc = cxt->lastc;\t\t\t \n    }\n\n   \n  if (c >= 0 && cxt->keymap[c].type == ISKMAP && strchr (cxt->search_terminators, cxt->lastc) == 0)\n    {\n       \n      if (_rl_keyseq_timeout > 0 &&\n\t    RL_ISSTATE (RL_STATE_CALLBACK) == 0 &&\n\t    RL_ISSTATE (RL_STATE_INPUTPENDING) == 0 &&\n\t    _rl_pushed_input_available () == 0 &&\n\t    ((Keymap)(cxt->keymap[c].function))[ANYOTHERKEY].function &&\n\t    _rl_input_queued (_rl_keyseq_timeout*1000) == 0)\n\tgoto add_character;\n\n      cxt->okeymap = cxt->keymap;\n      cxt->keymap = FUNCTION_TO_KEYMAP (cxt->keymap, c);\n      cxt->sflags |= SF_CHGKMAP;\n       \n      cxt->prevc = c;\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  if (cxt->mb[1] == 0)\n\t    {\n\t      cxt->pmb[0] = c;\t\t \n\t      cxt->pmb[1] = '\\0';\n\t    }\n\t  else\n\t    memcpy (cxt->pmb, cxt->mb, sizeof (cxt->pmb));\n\t}\n#endif\n      return 1;\n    }\n\nadd_character:\n\n   \n  if (c >= 0 && cxt->keymap[c].type == ISFUNC)\n    {\n       \n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && cxt->mb[1])\n\tf = rl_function_of_keyseq (cxt->mb, cxt->keymap, (int *)NULL);\n      else\n#endif\n\t{\n\t  f = cxt->keymap[c].function;\n\t  if (f == rl_do_lowercase_version)\n\t    f = cxt->keymap[_rl_to_lower (c)].function;\n\t}\n\n      if (f == rl_reverse_search_history)\n\tcxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;\n      else if (f == rl_forward_search_history)\n\tcxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -1;\n      else if (f == rl_rubout)\n\tcxt->lastc = -3;\n      else if (c == CTRL ('G') || f == rl_abort)\n\tcxt->lastc = -4;\n      else if (c == CTRL ('W') || f == rl_unix_word_rubout)\t \n\tcxt->lastc = -5;\n      else if (c == CTRL ('Y') || f == rl_yank)\t \n\tcxt->lastc = -6;\n      else if (f == rl_bracketed_paste_begin)\n\tcxt->lastc = -7;\n    }\n\n   \n  if (cxt->sflags & SF_CHGKMAP)\n    {\n      cxt->keymap = cxt->okeymap;\n      cxt->sflags &= ~SF_CHGKMAP;\n       \n       \n      if (cxt->lastc > 0 && ENDSRCH_CHAR (cxt->prevc))\n\t{\n\t  rl_stuff_char (cxt->lastc);\n\t  rl_execute_next (cxt->prevc);\n\t   \n\t  return (0);\n\t}\n       \n      else if (cxt->lastc > 0 && cxt->prevc > 0 &&\n\t       cxt->keymap[cxt->prevc].type == ISKMAP &&\n\t       (f == 0 || f == rl_insert))\n\t{\n\t   \n\t   \n\t  rl_execute_next (cxt->lastc);\n\t   \n\t  cxt->lastc = cxt->prevc;\n#if defined (HANDLE_MULTIBYTE)\n\t   \n\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t    {  \n\t      if (cxt->pmb[1] == 0)\t  \n\t\t{\n\t\t  cxt->mb[0] = cxt->lastc;\t \n\t\t  cxt->mb[1] = '\\0';\n\t\t}\n\t      else\n\t\tmemcpy (cxt->mb, cxt->pmb, sizeof (cxt->mb));\n\t    }\n#endif\n\t  cxt->prevc = 0;\t  \n\t}\n      else if (cxt->lastc > 0 && cxt->prevc > 0 && f && f != rl_insert)\n\t{\n\t  _rl_term_executing_keyseq ();\t\t \n\n\t  _rl_pending_command.map = cxt->keymap;\n\t  _rl_pending_command.count = 1;\t \n\t  _rl_pending_command.key = cxt->lastc;\n\t  _rl_pending_command.func = f;\n\t  _rl_command_to_execute = &_rl_pending_command;\n\n\t  return (0);\n\t}\n    }\n\n   \n  if (cxt->lastc > 0 && strchr (cxt->search_terminators, cxt->lastc))\n    {\n       \n      if (cxt->lastc == ESC && (_rl_pushed_input_available () || _rl_input_available ()))\n\trl_execute_next (ESC);\n      return (0);\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    {\n      if (cxt->lastc >= 0 && (cxt->mb[0] && cxt->mb[1] == '\\0') && ENDSRCH_CHAR (cxt->lastc))\n\t{\n\t   \n\t  rl_execute_next (cxt->lastc);\n\t  return (0);\n\t}\n    }\n  else\n#endif\n    if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))\n      {\n\t \n\trl_execute_next (cxt->lastc);\n\treturn (0);\n      }\n\n  _rl_init_executing_keyseq ();\n\nopcode_dispatch:\n   \n  switch (cxt->lastc)\n    {\n     \n    case -1:\n      if (cxt->search_string_index == 0)\n\t{\n\t  if (last_isearch_string)\n\t    {\n\t      cxt->search_string_size = 64 + last_isearch_string_len;\n\t      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n\t      strcpy (cxt->search_string, last_isearch_string);\n\t      cxt->search_string_index = last_isearch_string_len;\n\t      rl_display_search (cxt->search_string, cxt->sflags, -1);\n\t      break;\n\t    }\n\t   \n\t  return (1);\n\t}\n      else if ((cxt->sflags & SF_REVERSE) && cxt->sline_index >= 0)\n\tcxt->sline_index--;\n      else if (cxt->sline_index != cxt->sline_len)\n\tcxt->sline_index++;\n      else\n\trl_ding ();\n      break;\n\n     \n    case -2:\n      cxt->direction = -cxt->direction;\n      if (cxt->direction < 0)\n\tcxt->sflags |= SF_REVERSE;\n      else\n\tcxt->sflags &= ~SF_REVERSE;\n      break;\n\n     \n    case -3:\t \n       \n      if (cxt->search_string_index == 0)\n\trl_ding ();\n      else if (MB_CUR_MAX == 1 || rl_byte_oriented)\n\tcxt->search_string[--cxt->search_string_index] = '\\0';\n      else\n\t{\n\t  wstart = _rl_find_prev_mbchar (cxt->search_string, cxt->search_string_index, MB_FIND_NONZERO);\n\t  if (wstart >= 0)\n\t    cxt->search_string[cxt->search_string_index = wstart] = '\\0';\n\t  else\n\t    cxt->search_string[cxt->search_string_index = 0] = '\\0';\n\t}\n\n      if (cxt->search_string_index == 0)\n\trl_ding ();\n\n      break;\n\n    case -4:\t \n      rl_replace_line (cxt->lines[cxt->save_line], 0);\n      rl_point = cxt->save_point;\n      rl_mark = cxt->save_mark;\n      rl_deactivate_mark ();\n      rl_restore_prompt();\n      rl_clear_message ();\n\n      _rl_fix_point (1);\t \n      return -1;\n\n    case -5:\t \n       \n      wstart = rl_point + cxt->search_string_index;\n      if (wstart >= rl_end)\n\t{\n\t  rl_ding ();\n\t  break;\n\t}\n\n       \n      cval = _rl_char_value (rl_line_buffer, wstart);\n      if (_rl_walphabetic (cval) == 0)\n\t{\n\t  rl_ding ();\n\t  break;\n\t}\n      n = MB_NEXTCHAR (rl_line_buffer, wstart, 1, MB_FIND_NONZERO);;\n      while (n < rl_end)\n\t{\n\t  cval = _rl_char_value (rl_line_buffer, n);\n\t  if (_rl_walphabetic (cval) == 0)\n\t    break;\n\t  n = MB_NEXTCHAR (rl_line_buffer, n, 1, MB_FIND_NONZERO);;\n\t}\n      wlen = n - wstart + 1;\n      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)\n\t{\n\t  cxt->search_string_size += wlen + 1;\n\t  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n\t}\n      for (; wstart < n; wstart++)\n\tcxt->search_string[cxt->search_string_index++] = rl_line_buffer[wstart];\n      cxt->search_string[cxt->search_string_index] = '\\0';\n      break;\n\n    case -6:\t \n       \n      wstart = rl_point + cxt->search_string_index;\n      if (wstart >= rl_end)\n\t{\n\t  rl_ding ();\n\t  break;\n\t}\n      n = rl_end - wstart + 1;\n      if (cxt->search_string_index + n + 1 >= cxt->search_string_size)\n\t{\n\t  cxt->search_string_size += n + 1;\n\t  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n\t}\n      for (n = wstart; n < rl_end; n++)\n\tcxt->search_string[cxt->search_string_index++] = rl_line_buffer[n];\n      cxt->search_string[cxt->search_string_index] = '\\0';\n      break;\n\n    case -7:\t \n      paste = _rl_bracketed_text (&pastelen);\n      if (paste == 0 || *paste == 0)\n\t{\n\t  xfree (paste);\n\t  break;\n\t}\n      if (_rl_enable_active_region)\n\trl_activate_mark ();\n      if (cxt->search_string_index + pastelen + 1 >= cxt->search_string_size)\n\t{\n\t  cxt->search_string_size += pastelen + 2;\n\t  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n\t}\n      memcpy (cxt->search_string + cxt->search_string_index, paste, pastelen);\n      cxt->search_string_index += pastelen;\n      cxt->search_string[cxt->search_string_index] = '\\0';\n      xfree (paste);\n      break;\n\n     \n    default:\n#if defined (HANDLE_MULTIBYTE)\n      wlen = (cxt->mb[0] == 0 || cxt->mb[1] == 0) ? 1 : RL_STRLEN (cxt->mb);\n#else\n      wlen = 1;\n#endif\n      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)\n\t{\n\t  cxt->search_string_size += 128;\t \n\t  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  int j;\n\n\t  if (cxt->mb[0] == 0 || cxt->mb[1] == 0)\n\t    cxt->search_string[cxt->search_string_index++] = cxt->mb[0];\n\t  else\n\t    for (j = 0; j < wlen; )\n\t      cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];\n\t}\n      else\n#endif\n\tcxt->search_string[cxt->search_string_index++] = cxt->lastc;\t \n      cxt->search_string[cxt->search_string_index] = '\\0';\n      break;\n    }\n\n  for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )\n    {\n      if (cxt->search_string_index == 0)\n\t{\n\t  cxt->sflags |= SF_FAILED;\n\t  break;\n\t}\n\n      limit = cxt->sline_len - cxt->search_string_index + 1;\n\n       \n      while ((cxt->sflags & SF_REVERSE) ? (cxt->sline_index >= 0) : (cxt->sline_index < limit))\n\t{\n\t  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))\n\t    {\n\t      cxt->sflags |= SF_FOUND;\n\t      break;\n\t    }\n\t  else\n\t    cxt->sline_index += cxt->direction;\n\n\t  if (cxt->sline_index < 0)\n\t    {\n\t      cxt->sline_index = 0;\n\t      break;\n\t    }\n\t}\n      if (cxt->sflags & SF_FOUND)\n\tbreak;\n\n       \n      do\n\t{\n\t   \n\t  cxt->history_pos += cxt->direction;\n\n\t   \n\t  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))\n\t    {\n\t      cxt->sflags |= SF_FAILED;\n\t      break;\n\t    }\n\n\t   \n\t  cxt->sline = cxt->lines[cxt->history_pos];\n\t  cxt->sline_len = strlen (cxt->sline);\n\t}\n      while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||\n\t     (cxt->search_string_index > cxt->sline_len));\n\n      if (cxt->sflags & SF_FAILED)\n\t{\n\t   \n\t  if (cxt->sline_index < 0)\n\t    cxt->sline_index = 0;\n\t  break;\n\t}\n\n       \n      cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;\n    }\n\n   \n  cxt->keymap = cxt->okeymap = _rl_keymap;\n\n  if (cxt->sflags & SF_FAILED)\n    {\n       \n      rl_ding ();\n      cxt->history_pos = cxt->last_found_line;\n      rl_deactivate_mark ();\n      rl_display_search (cxt->search_string, cxt->sflags, (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);\n      return 1;\n    }\n\n   \n  if (cxt->sflags & SF_FOUND)\n    {\n      cxt->prev_line_found = cxt->lines[cxt->history_pos];\n      rl_replace_line (cxt->lines[cxt->history_pos], 0);\n      if (_rl_enable_active_region)\n\trl_activate_mark ();\t\n      rl_point = cxt->sline_index;\n      if (rl_mark_active_p () && cxt->search_string_index > 0)\n\trl_mark = rl_point + cxt->search_string_index;\n      cxt->last_found_line = cxt->history_pos;\n      rl_display_search (cxt->search_string, cxt->sflags, (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);\n    }\n\n  return 1;\n}\n\nint\n_rl_isearch_cleanup (_rl_search_cxt *cxt, int r)\n{\n  if (r >= 0)\n    _rl_isearch_fini (cxt);\n  _rl_scxt_dispose (cxt, 0);\n  _rl_iscxt = 0;\n\n  RL_UNSETSTATE(RL_STATE_ISEARCH);\n\n  return (r != 0);\n}\n\n \nstatic int\nrl_search_history (int direction, int invoking_key)\n{\n  _rl_search_cxt *cxt;\t\t \n  int c, r;\n\n  RL_SETSTATE(RL_STATE_ISEARCH);\n  cxt = _rl_isearch_init (direction);\n\n  rl_display_search (cxt->search_string, cxt->sflags, -1);\n\n   \n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    return (0);\n\n  r = -1;\n  for (;;)\n    {\n      c = _rl_search_getchar (cxt);\n       \n      r = _rl_isearch_dispatch (cxt, cxt->lastc);\n      if (r <= 0)\n        break;\n    }\n\n   \n  return (_rl_isearch_cleanup (cxt, r));\n}\n\n#if defined (READLINE_CALLBACKS)\n \nint\n_rl_isearch_callback (_rl_search_cxt *cxt)\n{\n  int c, r;\n\n  c = _rl_search_getchar (cxt);\n   \n  r = _rl_isearch_dispatch (cxt, cxt->lastc);\n\n  return (r <= 0) ? _rl_isearch_cleanup (cxt, r) : 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}