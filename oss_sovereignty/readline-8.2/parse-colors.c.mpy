{
  "module_name": "parse-colors.c",
  "hash_id": "ae0fa710ec8b511fdab868561e75ae537f1228692af3d29f77f68c333d34fef2",
  "original_prompt": "Ingested from readline-8.2/parse-colors.c",
  "human_readable_source": " \n\n \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n \n#if defined (HAVE_STRING_H)\n#  include <string.h>\n#else  \n#  include <strings.h>\n#endif  \n\n \n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include \"rldefs.h\"\t \n#include \"readline.h\"\n#include \"rlprivate.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n#include \"colors.h\"\n#include \"parse-colors.h\"\n\n#if defined (COLOR_SUPPORT)\n\nstatic bool get_funky_string (char **dest, const char **src, bool equals_end, size_t *output_count);\n\nstruct bin_str _rl_color_indicator[] =\n  {\n    { LEN_STR_PAIR (\"\\033[\") },          \n    { LEN_STR_PAIR (\"m\") },              \n    { 0, NULL },                         \n    { LEN_STR_PAIR (\"0\") },              \n    { 0, NULL },                         \n    { 0, NULL },                         \n    { LEN_STR_PAIR (\"01;34\") },          \n    { LEN_STR_PAIR (\"01;36\") },          \n    { LEN_STR_PAIR (\"33\") },             \n    { LEN_STR_PAIR (\"01;35\") },          \n    { LEN_STR_PAIR (\"01;33\") },          \n    { LEN_STR_PAIR (\"01;33\") },          \n    { 0, NULL },                         \n    { 0, NULL },                         \n    { LEN_STR_PAIR (\"01;32\") },          \n    { LEN_STR_PAIR (\"01;35\") },          \n    { LEN_STR_PAIR (\"37;41\") },          \n    { LEN_STR_PAIR (\"30;43\") },          \n    { LEN_STR_PAIR (\"37;44\") },          \n    { LEN_STR_PAIR (\"34;42\") },          \n    { LEN_STR_PAIR (\"30;42\") },          \n    { LEN_STR_PAIR (\"30;41\") },          \n    { 0, NULL },                         \n    { LEN_STR_PAIR (\"\\033[K\") },         \n  };\n\n \n\nstatic bool\nget_funky_string (char **dest, const char **src, bool equals_end, size_t *output_count) {\n  char num;\t\t\t \n  size_t count;\t\t\t \n  enum {\n    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR\n  } state;\n  const char *p;\n  char *q;\n\n  p = *src;\t\t\t \n  q = *dest;\t\t\t \n\n  count = 0;\t\t\t \n  num = 0;\n\n  state = ST_GND;\t\t \n  while (state < ST_END)\n    {\n      switch (state)\n        {\n        case ST_GND:\t\t \n          switch (*p)\n            {\n            case ':':\n            case '\\0':\n              state = ST_END;\t \n              break;\n            case '\\\\':\n              state = ST_BACKSLASH;  \n              ++p;\n              break;\n            case '^':\n              state = ST_CARET;  \n              ++p;\n              break;\n            case '=':\n              if (equals_end)\n                {\n                  state = ST_END;  \n                  break;\n                }\n               \n            default:\n              *(q++) = *(p++);\n              ++count;\n              break;\n            }\n          break;\n\n        case ST_BACKSLASH:\t \n          switch (*p)\n            {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n              state = ST_OCTAL;\t \n              num = *p - '0';\n              break;\n            case 'x':\n            case 'X':\n              state = ST_HEX;\t \n              num = 0;\n              break;\n            case 'a':\t\t \n              num = '\\a';\n              break;\n            case 'b':\t\t \n              num = '\\b';\n              break;\n            case 'e':\t\t \n              num = 27;\n              break;\n            case 'f':\t\t \n              num = '\\f';\n              break;\n            case 'n':\t\t \n              num = '\\n';\n              break;\n            case 'r':\t\t \n              num = '\\r';\n              break;\n            case 't':\t\t \n              num = '\\t';\n              break;\n            case 'v':\t\t \n              num = '\\v';\n              break;\n            case '?':\t\t \n              num = 127;\n              break;\n            case '_':\t\t \n              num = ' ';\n              break;\n            case '\\0':\t\t \n              state = ST_ERROR;\t \n              break;\n            default:\t\t \n              num = *p;\n              break;\n            }\n          if (state == ST_BACKSLASH)\n            {\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n            }\n          ++p;\n          break;\n\n        case ST_OCTAL:\t\t \n          if (*p < '0' || *p > '7')\n            {\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n            }\n          else\n            num = (num << 3) + (*(p++) - '0');\n          break;\n\n        case ST_HEX:\t\t \n          switch (*p)\n            {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              num = (num << 4) + (*(p++) - '0');\n              break;\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n              num = (num << 4) + (*(p++) - 'a') + 10;\n              break;\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n              num = (num << 4) + (*(p++) - 'A') + 10;\n              break;\n            default:\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n              break;\n            }\n          break;\n\n        case ST_CARET:\t\t \n          state = ST_GND;\t \n          if (*p >= '@' && *p <= '~')\n            {\n              *(q++) = *(p++) & 037;\n              ++count;\n            }\n          else if (*p == '?')\n            {\n              *(q++) = 127;\n              ++count;\n            }\n          else\n            state = ST_ERROR;\n          break;\n\n        default:\n\t   \n           \n          state = ST_ERROR;\n          break;\n        }\n    }\n\n  *dest = q;\n  *src = p;\n  *output_count = count;\n\n  return state != ST_ERROR;\n}\n#endif  \n\nvoid _rl_parse_colors(void)\n{\n#if defined (COLOR_SUPPORT)\n  const char *p;\t\t \n  char *buf;\t\t\t \n  int state;\t\t\t \n  int ind_no;\t\t\t \n  char label[3];\t\t \n  COLOR_EXT_TYPE *ext;\t\t \n\n  p = sh_get_env_value (\"LS_COLORS\");\n  if (p == 0 || *p == '\\0')\n    {\n      _rl_color_ext_list = NULL;\n      return;\n    }\n\n  ext = NULL;\n  strcpy (label, \"??\");\n\n   \n  buf = color_buf = savestring (p);\n\n  state = 1;\n  while (state > 0)\n    {\n      switch (state)\n        {\n        case 1:\t\t \n          switch (*p)\n            {\n            case ':':\n              ++p;\n              break;\n\n            case '*':\n               \n\n              ext = (COLOR_EXT_TYPE *)xmalloc (sizeof *ext);\n              ext->next = _rl_color_ext_list;\n              _rl_color_ext_list = ext;\n\n              ++p;\n              ext->ext.string = buf;\n\n              state = (get_funky_string (&buf, &p, true, &ext->ext.len)\n                       ? 4 : -1);\n              break;\n\n            case '\\0':\n              state = 0;\t \n              break;\n\n            default:\t \n              label[0] = *(p++);\n              state = 2;\n              break;\n            }\n          break;\n\n        case 2:\t\t \n          if (*p)\n            {\n              label[1] = *(p++);\n              state = 3;\n            }\n          else\n            state = -1;\t \n          break;\n\n        case 3:\t\t \n          state = -1;\t \n          if (*(p++) == '=') \n            {\n              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)\n                {\n                  if (STREQ (label, indicator_name[ind_no]))\n                    {\n                      _rl_color_indicator[ind_no].string = buf;\n                      state = (get_funky_string (&buf, &p, false,\n                                                 &_rl_color_indicator[ind_no].len)\n                               ? 1 : -1);\n                      break;\n                    }\n                }\n              if (state == -1)\n\t\t{\n                  _rl_errmsg (\"LS_COLORS: unrecognized prefix: %s\", label);\n                   \n                  while (p && *p && *p != ':')\n\t\t    p++;\n\t\t  if (p && *p == ':')\n\t\t    state = 1;\n\t\t  else if (p && *p == 0)\n\t\t    state = 0;\n\t\t}\n            }\n          break;\n\n        case 4:\t\t \n          if (*(p++) == '=')\n            {\n              ext->seq.string = buf;\n              state = (get_funky_string (&buf, &p, false, &ext->seq.len)\n                       ? 1 : -1);\n            }\n          else\n            state = -1;\n           \n          if (state == -1 && ext->ext.string)\n\t    _rl_errmsg (\"LS_COLORS: syntax error: %s\", ext->ext.string);\n          break;\n        }\n    }\n\n  if (state < 0)\n    {\n      COLOR_EXT_TYPE *e;\n      COLOR_EXT_TYPE *e2;\n\n      _rl_errmsg (\"unparsable value for LS_COLORS environment variable\");\n      free (color_buf);\n      for (e = _rl_color_ext_list; e != NULL;  )\n        {\n          e2 = e;\n          e = e->next;\n          free (e2);\n        }\n      _rl_color_ext_list = NULL;\n      _rl_colored_stats = 0;\t \n    }\n#else  \n  ;\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}