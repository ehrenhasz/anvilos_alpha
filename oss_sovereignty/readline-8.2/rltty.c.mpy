{
  "module_name": "rltty.c",
  "hash_id": "e0c1835888cb595653892466cca7de1bb051da9aa8a2d969cbaea5a6925ac29a",
  "original_prompt": "Ingested from readline-8.2/rltty.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#include \"rldefs.h\"\n\n#include \"rltty.h\"\n#if defined (HAVE_SYS_IOCTL_H)\n#  include <sys/ioctl.h>\t\t \n#endif\n\n#include \"readline.h\"\n#include \"rlprivate.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\nrl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;\nrl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;\n\nstatic void set_winsize (int);\n\n \n \n \n \n \n\n \n#define TPX_PREPPED\t0x01\n#define TPX_BRACKPASTE\t0x02\n#define TPX_METAKEY\t0x04\n\nstatic int terminal_prepped;\n\nstatic _RL_TTY_CHARS _rl_tty_chars, _rl_last_tty_chars;\n\n \n#if defined (__ksr1__)\nstatic int ksrflow;\n#endif\n\n \nstatic void\nset_winsize (tty)\n     int tty;\n{\n#if defined (TIOCGWINSZ)\n  struct winsize w;\n\n  if (ioctl (tty, TIOCGWINSZ, &w) == 0)\n      (void) ioctl (tty, TIOCSWINSZ, &w);\n#endif  \n}\n\n#if defined (NO_TTY_DRIVER)\n \n#elif defined (NEW_TTY_DRIVER)\n\n \n#define SGTTY_SET\t0x01\n#define LFLAG_SET\t0x02\n#define TCHARS_SET\t0x04\n#define LTCHARS_SET\t0x08\n\nstruct bsdtty {\n  struct sgttyb sgttyb;\t \n  int lflag;\t\t \n#if defined (TIOCGETC)\n  struct tchars tchars;\t \n#endif\n#if defined (TIOCGLTC)\n  struct ltchars ltchars;  \n#endif\n  int flags;\t\t \n};\n\n#define TIOTYPE struct bsdtty\n\nstatic TIOTYPE otio;\n\nstatic void save_tty_chars (TIOTYPE *);\nstatic int _get_tty_settings (int, TIOTYPE *);\nstatic int get_tty_settings (int, TIOTYPE *);\nstatic int _set_tty_settings (int, TIOTYPE *);\nstatic int set_tty_settings (int, TIOTYPE *);\n\nstatic void prepare_terminal_settings (int, TIOTYPE, TIOTYPE *);\n\nstatic void set_special_char (Keymap, TIOTYPE *, int, rl_command_func_t *);\n\nstatic void\nsave_tty_chars (TIOTYPE *tiop)\n{\n  _rl_last_tty_chars = _rl_tty_chars;\n\n  if (tiop->flags & SGTTY_SET)\n    {\n      _rl_tty_chars.t_erase = tiop->sgttyb.sg_erase;\n      _rl_tty_chars.t_kill = tiop->sgttyb.sg_kill;\n    }\n\n  if (tiop->flags & TCHARS_SET)\n    {\n      _rl_intr_char = _rl_tty_chars.t_intr = tiop->tchars.t_intrc;\n      _rl_quit_char = _rl_tty_chars.t_quit = tiop->tchars.t_quitc;\n\n      _rl_tty_chars.t_start = tiop->tchars.t_startc;\n      _rl_tty_chars.t_stop = tiop->tchars.t_stopc;\n      _rl_tty_chars.t_eof = tiop->tchars.t_eofc;\n      _rl_tty_chars.t_eol = '\\n';\n      _rl_tty_chars.t_eol2 = tiop->tchars.t_brkc;\n    }\n\n  if (tiop->flags & LTCHARS_SET)\n    {\n      _rl_susp_char = _rl_tty_chars.t_susp = tiop->ltchars.t_suspc;\n\n      _rl_tty_chars.t_dsusp = tiop->ltchars.t_dsuspc;\n      _rl_tty_chars.t_reprint = tiop->ltchars.t_rprntc;\n      _rl_tty_chars.t_flush = tiop->ltchars.t_flushc;\n      _rl_tty_chars.t_werase = tiop->ltchars.t_werasc;\n      _rl_tty_chars.t_lnext = tiop->ltchars.t_lnextc;\n    }\n\n  _rl_tty_chars.t_status = -1;\n}\n\nstatic int\nget_tty_settings (int tty, TIOTYPE *tiop)\n{\n  set_winsize (tty);\n\n  tiop->flags = tiop->lflag = 0;\n\n  errno = 0;\n  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)\n    return -1;\n  tiop->flags |= SGTTY_SET;\n\n#if defined (TIOCLGET)\n  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)\n    tiop->flags |= LFLAG_SET;\n#endif\n\n#if defined (TIOCGETC)\n  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)\n    tiop->flags |= TCHARS_SET;\n#endif\n\n#if defined (TIOCGLTC)\n  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)\n    tiop->flags |= LTCHARS_SET;\n#endif\n\n  return 0;\n}\n\nstatic int\nset_tty_settings (int tty, TIOTYPE *tiop)\n{\n  if (tiop->flags & SGTTY_SET)\n    {\n      ioctl (tty, TIOCSETN, &(tiop->sgttyb));\n      tiop->flags &= ~SGTTY_SET;\n    }\n  _rl_echoing_p = 1;\n\n#if defined (TIOCLSET)\n  if (tiop->flags & LFLAG_SET)\n    {\n      ioctl (tty, TIOCLSET, &(tiop->lflag));\n      tiop->flags &= ~LFLAG_SET;\n    }\n#endif\n\n#if defined (TIOCSETC)\n  if (tiop->flags & TCHARS_SET)\n    {\n      ioctl (tty, TIOCSETC, &(tiop->tchars));\n      tiop->flags &= ~TCHARS_SET;\n    }\n#endif\n\n#if defined (TIOCSLTC)\n  if (tiop->flags & LTCHARS_SET)\n    {\n      ioctl (tty, TIOCSLTC, &(tiop->ltchars));\n      tiop->flags &= ~LTCHARS_SET;\n    }\n#endif\n\n  return 0;\n}\n\nstatic void\nprepare_terminal_settings (int meta_flag, TIOTYPE oldtio, TIOTYPE *tiop)\n{\n  _rl_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);\n  _rl_echoctl = (oldtio.sgttyb.sg_flags & ECHOCTL);\n\n   \n  tiop->sgttyb = oldtio.sgttyb;\n  tiop->lflag = oldtio.lflag;\n#if defined (TIOCGETC)\n  tiop->tchars = oldtio.tchars;\n#endif\n#if defined (TIOCGLTC)\n  tiop->ltchars = oldtio.ltchars;\n#endif\n  tiop->flags = oldtio.flags;\n\n   \n  tiop->sgttyb.sg_flags &= ~(ECHO | CRMOD);\n  tiop->sgttyb.sg_flags |= CBREAK;\n\n   \n#if !defined (ANYP)\n#  define ANYP (EVENP | ODDP)\n#endif\n  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||\n      ((oldtio.sgttyb.sg_flags & ANYP) == 0))\n    {\n      tiop->sgttyb.sg_flags |= ANYP;\n\n       \n#if defined (TIOCLGET)\n#  if defined (LPASS8)\n      tiop->lflag |= LPASS8;\n#  endif  \n#endif  \n    }\n\n#if defined (TIOCGETC)\n#  if defined (USE_XON_XOFF)\n   \n  tiop->tchars.t_stopc = -1;  \n  tiop->tchars.t_startc = -1;  \n\n   \n  if (oldtio.tchars.t_startc != -1)\n    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);\n#  endif  \n\n   \n  if (oldtio.tchars.t_eofc != -1)\n    _rl_eof_char = oldtio.tchars.t_eofc;\n\n#  if defined (NO_KILL_INTR)\n   \n  tiop->tchars.t_quitc = -1;  \n  tiop->tchars.t_intrc = -1;  \n#  endif  \n#endif  \n\n#if defined (TIOCGLTC)\n   \n  tiop->ltchars.t_dsuspc = -1;\t \n  tiop->ltchars.t_lnextc = -1;\t \n#endif  \n}\n\n#else   \n\n#if !defined (VMIN)\n#  define VMIN VEOF\n#endif\n\n#if !defined (VTIME)\n#  define VTIME VEOL\n#endif\n\n#if defined (TERMIOS_TTY_DRIVER)\n#  define TIOTYPE struct termios\n#  define DRAIN_OUTPUT(fd)\ttcdrain (fd)\n#  define GETATTR(tty, tiop)\t(tcgetattr (tty, tiop))\n#  ifdef M_UNIX\n#    define SETATTR(tty, tiop)\t(tcsetattr (tty, TCSANOW, tiop))\n#  else\n#    define SETATTR(tty, tiop)\t(tcsetattr (tty, TCSADRAIN, tiop))\n#  endif  \n#else\n#  define TIOTYPE struct termio\n#  define DRAIN_OUTPUT(fd)\n#  define GETATTR(tty, tiop)\t(ioctl (tty, TCGETA, tiop))\n#  define SETATTR(tty, tiop)\t(ioctl (tty, TCSETAW, tiop))\n#endif  \n\nstatic TIOTYPE otio;\n\nstatic void save_tty_chars (TIOTYPE *);\nstatic int _get_tty_settings (int, TIOTYPE *);\nstatic int get_tty_settings (int, TIOTYPE *);\nstatic int _set_tty_settings (int, TIOTYPE *);\nstatic int set_tty_settings (int, TIOTYPE *);\n\nstatic void prepare_terminal_settings (int, TIOTYPE, TIOTYPE *);\n\nstatic void set_special_char (Keymap, TIOTYPE *, int, rl_command_func_t *);\nstatic void _rl_bind_tty_special_chars (Keymap, TIOTYPE);\n\n#if defined (FLUSHO)\n#  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)\n#else\n#  define OUTPUT_BEING_FLUSHED(tp)  0\n#endif\n\nstatic void\nsave_tty_chars (TIOTYPE *tiop)\n{\n  _rl_last_tty_chars = _rl_tty_chars;\n\n  _rl_tty_chars.t_eof = tiop->c_cc[VEOF];\n  _rl_tty_chars.t_eol = tiop->c_cc[VEOL];\n#ifdef VEOL2\n  _rl_tty_chars.t_eol2 = tiop->c_cc[VEOL2];\n#endif\n  _rl_tty_chars.t_erase = tiop->c_cc[VERASE];\n#ifdef VWERASE\n  _rl_tty_chars.t_werase = tiop->c_cc[VWERASE];\n#endif\n  _rl_tty_chars.t_kill = tiop->c_cc[VKILL];\n#ifdef VREPRINT\n  _rl_tty_chars.t_reprint = tiop->c_cc[VREPRINT];\n#endif\n  _rl_intr_char = _rl_tty_chars.t_intr = tiop->c_cc[VINTR];\n  _rl_quit_char = _rl_tty_chars.t_quit = tiop->c_cc[VQUIT];\n#ifdef VSUSP\n  _rl_susp_char = _rl_tty_chars.t_susp = tiop->c_cc[VSUSP];\n#endif\n#ifdef VDSUSP\n  _rl_tty_chars.t_dsusp = tiop->c_cc[VDSUSP];\n#endif\n#ifdef VSTART\n  _rl_tty_chars.t_start = tiop->c_cc[VSTART];\n#endif\n#ifdef VSTOP\n  _rl_tty_chars.t_stop = tiop->c_cc[VSTOP];\n#endif\n#ifdef VLNEXT\n  _rl_tty_chars.t_lnext = tiop->c_cc[VLNEXT];\n#endif\n#ifdef VDISCARD\n  _rl_tty_chars.t_flush = tiop->c_cc[VDISCARD];\n#endif\n#ifdef VSTATUS\n  _rl_tty_chars.t_status = tiop->c_cc[VSTATUS];\n#endif\n}\n\n#if defined (_AIX) || defined (_AIX41)\n \nstatic void\nrltty_warning (char *msg)\n{\n  _rl_errmsg (\"warning: %s\", msg);\n}\n#endif\n\n#if defined (_AIX)\nvoid\nsetopost (TIOTYPE *tp)\n{\n  if ((tp->c_oflag & OPOST) == 0)\n    {\n      _rl_errmsg (\"warning: turning on OPOST for terminal\\r\");\n      tp->c_oflag |= OPOST|ONLCR;\n    }\n}\n#endif\n\nstatic int\n_get_tty_settings (int tty, TIOTYPE *tiop)\n{\n  int ioctl_ret;\n\n  while (1)\n    {\n      ioctl_ret = GETATTR (tty, tiop);\n      if (ioctl_ret < 0)\n\t{\n\t  if (errno != EINTR)\n\t    return -1;\n\t  else\n\t    continue;\n\t}\n      if (OUTPUT_BEING_FLUSHED (tiop))\n\t{\n#if defined (FLUSHO)\n\t  _rl_errmsg (\"warning: turning off output flushing\");\n\t  tiop->c_lflag &= ~FLUSHO;\n\t  break;\n#else\n\t  continue;\n#endif\n\t}\n      break;\n    }\n\n  return 0;\n}\n\nstatic int\nget_tty_settings (int tty, TIOTYPE *tiop)\n{\n  set_winsize (tty);\n\n  errno = 0;\n  if (_get_tty_settings (tty, tiop) < 0)\n    return -1;\n\n#if defined (_AIX)\n  setopost(tiop);\n#endif\n\n  return 0;\n}\n\nstatic int\n_set_tty_settings (int tty, TIOTYPE *tiop)\n{\n  while (SETATTR (tty, tiop) < 0)\n    {\n      if (errno != EINTR)\n\treturn -1;\n      errno = 0;\n    }\n  return 0;\n}\n\nstatic int\nset_tty_settings (int tty, TIOTYPE *tiop)\n{\n  if (_set_tty_settings (tty, tiop) < 0)\n    return -1;\n    \n#if 0\n\n#if defined (TERMIOS_TTY_DRIVER)\n#  if defined (__ksr1__)\n  if (ksrflow)\n    {\n      ksrflow = 0;\n      tcflow (tty, TCOON);\n    }\n#  else  \n  tcflow (tty, TCOON);\t\t \n#  endif  \n#else\n  ioctl (tty, TCXONC, 1);\t \n#endif  \n\n#endif  \n\n  return 0;\n}\n\nstatic void\nprepare_terminal_settings (int meta_flag, TIOTYPE oldtio, TIOTYPE *tiop)\n{\n  int sc;\n  Keymap kmap;\n\n  _rl_echoing_p = (oldtio.c_lflag & ECHO);\n#if defined (ECHOCTL)\n  _rl_echoctl = (oldtio.c_lflag & ECHOCTL);\n#endif\n\n  tiop->c_lflag &= ~(ICANON | ECHO);\n\n  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)\n    _rl_eof_char = oldtio.c_cc[VEOF];\n\n#if defined (USE_XON_XOFF)\n#if defined (IXANY)\n  tiop->c_iflag &= ~(IXON | IXANY);\n#else\n   \n  tiop->c_iflag &= ~IXON;\n#endif  \n#endif  \n\n   \n  if (((tiop->c_cflag & CSIZE) == CS8) || meta_flag)\n    tiop->c_iflag &= ~(ISTRIP | INPCK);\n\n   \n  tiop->c_iflag &= ~(ICRNL | INLCR);\n\n#if !defined (HANDLE_SIGNALS)\n  tiop->c_lflag &= ~ISIG;\n#else\n  tiop->c_lflag |= ISIG;\n#endif\n\n  tiop->c_cc[VMIN] = 1;\n  tiop->c_cc[VTIME] = 0;\n\n#if defined (FLUSHO)\n  if (OUTPUT_BEING_FLUSHED (tiop))\n    {\n      tiop->c_lflag &= ~FLUSHO;\n      oldtio.c_lflag &= ~FLUSHO;\n    }\n#endif\n\n   \n#if defined (TERMIOS_TTY_DRIVER) && defined (_POSIX_VDISABLE)\n\n#if defined (VLNEXT)\n  tiop->c_cc[VLNEXT] = _POSIX_VDISABLE;\n#endif\n\n#if defined (VDSUSP)\n  tiop->c_cc[VDSUSP] = _POSIX_VDISABLE;\n#endif\n\n   \n#if defined (VI_MODE)\n      kmap = (rl_editing_mode == vi_mode) ? vi_insertion_keymap : _rl_keymap;\n#else\n      kmap = _rl_keymap;\n#endif\n#if defined (VDISCARD)\n  sc = tiop->c_cc[VDISCARD];\n  if (sc != _POSIX_VDISABLE && kmap[(unsigned char)sc].type == ISFUNC)\n    tiop->c_cc[VDISCARD] = _POSIX_VDISABLE;\n#endif  \n\n#endif  \n}\n#endif   \n\n \n#if defined (NO_TTY_DRIVER)\nvoid\nrl_prep_terminal (int meta_flag)\n{\n  _rl_echoing_p = 1;\n}\n\nvoid\nrl_deprep_terminal (void)\n{\n}\n\n#else  \nvoid\nrl_prep_terminal (int meta_flag)\n{\n  int tty, nprep;\n  TIOTYPE tio;\n\n  if (terminal_prepped)\n    return;\n\n   \n  _rl_block_sigint ();\n\n  tty = rl_instream ? fileno (rl_instream) : fileno (stdin);\n\n  if (get_tty_settings (tty, &tio) < 0)\n    {\n#if defined (ENOTSUP)\n       \n      if (errno == ENOTTY || errno == EINVAL || errno == ENOTSUP)\n#else\n      if (errno == ENOTTY || errno == EINVAL)\n#endif\n\t_rl_echoing_p = 1;\t\t \n\n      _rl_release_sigint ();\n      return;\n    }\n\n  otio = tio;\n\n  if (_rl_bind_stty_chars)\n    {\n#if defined (VI_MODE)\n       \n      if (rl_editing_mode == vi_mode)\n\trl_tty_unset_default_bindings (vi_insertion_keymap);\n      else\n#endif\n\trl_tty_unset_default_bindings (_rl_keymap);\n    }\n  save_tty_chars (&otio);\n  RL_SETSTATE(RL_STATE_TTYCSAVED);\n  if (_rl_bind_stty_chars)\n    {\n#if defined (VI_MODE)\n       \n      if (rl_editing_mode == vi_mode)\n\t_rl_bind_tty_special_chars (vi_insertion_keymap, tio);\n      else\n#endif\n\t_rl_bind_tty_special_chars (_rl_keymap, tio);\n    }\n\n  prepare_terminal_settings (meta_flag, otio, &tio);\n\n  if (set_tty_settings (tty, &tio) < 0)\n    {\n      _rl_release_sigint ();\n      return;\n    }\n\n  if (_rl_enable_keypad)\n    _rl_control_keypad (1);\n\n  nprep = TPX_PREPPED;\n\n  if (_rl_enable_bracketed_paste)\n    {\n      fprintf (rl_outstream, BRACK_PASTE_INIT);\n      nprep |= TPX_BRACKPASTE;\n    }\n\n  fflush (rl_outstream);\n  terminal_prepped = nprep;\n  RL_SETSTATE(RL_STATE_TERMPREPPED);\n\n  _rl_release_sigint ();\n}\n\n \nvoid\nrl_deprep_terminal (void)\n{\n  int tty;\n\n  if (terminal_prepped == 0)\n    return;\n\n   \n  _rl_block_sigint ();\n\n  tty = rl_instream ? fileno (rl_instream) : fileno (stdin);\n\n  if (terminal_prepped & TPX_BRACKPASTE)\n    {\n      fprintf (rl_outstream, BRACK_PASTE_FINI);\n       \n      _rl_last_c_pos = 0;\n      if (rl_eof_found && (RL_ISSTATE (RL_STATE_TIMEOUT) == 0))\n \tfprintf (rl_outstream, \"\\n\");\n      else if (_rl_echoing_p == 0)\n \tfprintf (rl_outstream, \"\\n\");\n    }\n\n  if (_rl_enable_keypad)\n    _rl_control_keypad (0);\n\n  fflush (rl_outstream);\n\n  if (set_tty_settings (tty, &otio) < 0)\n    {\n      _rl_release_sigint ();\n      return;\n    }\n\n  terminal_prepped = 0;\n  RL_UNSETSTATE(RL_STATE_TERMPREPPED);\n\n  _rl_release_sigint ();\n}\n#endif  \n\n \nint\nrl_tty_set_echoing (int u)\n{\n  int o;\n\n  o = _rl_echoing_p;\n  _rl_echoing_p = u;\n  return o;\n}\n\f\n \n \n \n \n \n\nint\nrl_restart_output (int count, int key)\n{\n#if defined (__MINGW32__)\n  return 0;\n#else  \n\n  int fildes = fileno (rl_outstream);\n#if defined (TIOCSTART)\n#if defined (apollo)\n  ioctl (&fildes, TIOCSTART, 0);\n#else\n  ioctl (fildes, TIOCSTART, 0);\n#endif  \n\n#else  \n#  if defined (TERMIOS_TTY_DRIVER)\n#    if defined (__ksr1__)\n  if (ksrflow)\n    {\n      ksrflow = 0;\n      tcflow (fildes, TCOON);\n    }\n#    else  \n  tcflow (fildes, TCOON);\t\t \n#    endif  \n#  else  \n#    if defined (TCXONC)\n  ioctl (fildes, TCXONC, TCOON);\n#    endif  \n#  endif  \n#endif  \n\n  return 0;\n#endif  \n}\n\nint\nrl_stop_output (int count, int key)\n{\n#if defined (__MINGW32__)\n  return 0;\n#else\n\n  int fildes = fileno (rl_instream);\n\n#if defined (TIOCSTOP)\n# if defined (apollo)\n  ioctl (&fildes, TIOCSTOP, 0);\n# else\n  ioctl (fildes, TIOCSTOP, 0);\n# endif  \n#else  \n# if defined (TERMIOS_TTY_DRIVER)\n#  if defined (__ksr1__)\n  ksrflow = 1;\n#  endif  \n  tcflow (fildes, TCOOFF);\n# else\n#   if defined (TCXONC)\n  ioctl (fildes, TCXONC, TCOON);\n#   endif  \n# endif  \n#endif  \n\n  return 0;\n#endif  \n}\n\n \n \n \n \n \n\n#if !defined (NO_TTY_DRIVER)\n#define SET_SPECIAL(sc, func)\tset_special_char(kmap, &ttybuff, sc, func)\n#endif\n\n#if defined (NO_TTY_DRIVER)\n\n#define SET_SPECIAL(sc, func)\n#define RESET_SPECIAL(c)\n\n#elif defined (NEW_TTY_DRIVER)\nstatic void\nset_special_char (Keymap kmap, TIOTYPE *tiop, int sc, rl_command_func_t *func)\n{\n  if (sc != -1 && kmap[(unsigned char)sc].type == ISFUNC)\n    kmap[(unsigned char)sc].function = func;\n}\n\n#define RESET_SPECIAL(c) \\\n  if (c != -1 && kmap[(unsigned char)c].type == ISFUNC) \\\n    kmap[(unsigned char)c].function = rl_insert;\n\nstatic void\n_rl_bind_tty_special_chars (Keymap kmap, TIOTYPE ttybuff)\n{\n  if (ttybuff.flags & SGTTY_SET)\n    {\n      SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);\n      SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);\n    }\n\n#  if defined (TIOCGLTC)\n  if (ttybuff.flags & LTCHARS_SET)\n    {\n      SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);\n      SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);\n    }\n#  endif  \n}\n\n#else  \nstatic void\nset_special_char (Keymap kmap, TIOTYPE *tiop, int sc, rl_command_func_t *func)\n{\n  unsigned char uc;\n\n  uc = tiop->c_cc[sc];\n  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC)\n    kmap[uc].function = func;\n}\n\n \n#define RESET_SPECIAL(uc) \\\n  if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \\\n    kmap[uc].function = rl_insert;\n\nstatic void\n_rl_bind_tty_special_chars (Keymap kmap, TIOTYPE ttybuff)\n{\n  SET_SPECIAL (VERASE, rl_rubout);\n  SET_SPECIAL (VKILL, rl_unix_line_discard);\n\n#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)\n  SET_SPECIAL (VLNEXT, rl_quoted_insert);\n#  endif  \n\n#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)\n#    if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    SET_SPECIAL (VWERASE, rl_vi_unix_word_rubout);\n  else\n#    endif\n  SET_SPECIAL (VWERASE, rl_unix_word_rubout);\n#  endif  \n}\n\n#endif  \n\n \nvoid\nrltty_set_default_bindings (Keymap kmap)\n{\n#if !defined (NO_TTY_DRIVER)\n  TIOTYPE ttybuff;\n  int tty;\n\n  tty = fileno (rl_instream);\n\n  if (get_tty_settings (tty, &ttybuff) == 0)\n    _rl_bind_tty_special_chars (kmap, ttybuff);\n#endif\n}\n\n \nvoid\nrl_tty_set_default_bindings (Keymap kmap)\n{\n  rltty_set_default_bindings (kmap);\n}\n\n \nvoid\nrl_tty_unset_default_bindings (Keymap kmap)\n{\n   \n  if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)\n    return;\n\n  RESET_SPECIAL (_rl_tty_chars.t_erase);\n  RESET_SPECIAL (_rl_tty_chars.t_kill);\n\n#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)\n  RESET_SPECIAL (_rl_tty_chars.t_lnext);\n#  endif  \n\n#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)\n  RESET_SPECIAL (_rl_tty_chars.t_werase);\n#  endif  \n}\n\n#if defined (HANDLE_SIGNALS)\n\n#if defined (NEW_TTY_DRIVER) || defined (NO_TTY_DRIVER)\nint\n_rl_disable_tty_signals (void)\n{\n  return 0;\n}\n\nint\n_rl_restore_tty_signals (void)\n{\n  return 0;\n}\n#else\n\nstatic TIOTYPE sigstty, nosigstty;\nstatic int tty_sigs_disabled = 0;\n\nint\n_rl_disable_tty_signals (void)\n{\n  if (tty_sigs_disabled)\n    return 0;\n\n  if (_get_tty_settings (fileno (rl_instream), &sigstty) < 0)\n    return -1;\n\n  nosigstty = sigstty;\n\n  nosigstty.c_lflag &= ~ISIG;\n  nosigstty.c_iflag &= ~IXON;\n\n  if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)\n    return (_set_tty_settings (fileno (rl_instream), &sigstty));\n\n  tty_sigs_disabled = 1;\n  return 0;\n}\n\nint\n_rl_restore_tty_signals (void)\n{\n  int r;\n\n  if (tty_sigs_disabled == 0)\n    return 0;\n\n  r = _set_tty_settings (fileno (rl_instream), &sigstty);\n\n  if (r == 0)\n    tty_sigs_disabled = 0;\n\n  return r;\n}\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}