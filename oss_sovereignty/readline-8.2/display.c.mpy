{
  "module_name": "display.c",
  "hash_id": "2ed64d32ef70b17bcfdcaf0a3b49e500983afe5812fa4e8f94884575e569f83a",
  "original_prompt": "Ingested from readline-8.2/display.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#include \"posixstat.h\"\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n\n#ifdef __MSDOS__\n#  include <pc.h>\n#endif\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n \n#include \"tcap.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n#if !defined (strchr) && !defined (__STDC__)\nextern char *strchr (), *strrchr ();\n#endif  \n\nstatic void putc_face (int, int, char *);\nstatic void puts_face (const char *, const char *, int);\nstatic void norm_face (char *, int);\n\nstatic void update_line (char *, char *, char *, char *, int, int, int, int);\nstatic void space_to_eol (int);\nstatic void delete_chars (int);\nstatic void insert_some_chars (char *, int, int);\nstatic void open_some_spaces (int);\nstatic void cr (void);\nstatic void redraw_prompt (char *);\nstatic void _rl_move_cursor_relative (int, const char *, const char *);\n\n \n#define PMT_MULTILINE\t0x01\n\nstatic char *expand_prompt (char *, int, int *, int *, int *, int *);\n\n#define DEFAULT_LINE_BUFFER_SIZE\t1024\n\n \nstruct line_state\n  {\n    char *line;\n    char *lface;\n    int *lbreaks;\n    int lbsize;\n#if defined (HANDLE_MULTIBYTE)\n    int wbsize;\n    int *wrapped_line;\n#endif\n  };\n\n \nstatic struct line_state line_state_array[2];\nstatic struct line_state *line_state_visible = &line_state_array[0];\nstatic struct line_state *line_state_invisible = &line_state_array[1];\nstatic int line_structures_initialized = 0;\n\n \n#define inv_lbreaks\t(line_state_invisible->lbreaks)\n#define inv_lbsize\t(line_state_invisible->lbsize)\n#define vis_lbreaks\t(line_state_visible->lbreaks)\n#define vis_lbsize\t(line_state_visible->lbsize)\n\n#define visible_line\t(line_state_visible->line)\n#define vis_face\t(line_state_visible->lface)\n#define invisible_line\t(line_state_invisible->line)\n#define inv_face\t(line_state_invisible->lface)\n\n#if defined (HANDLE_MULTIBYTE)\nstatic int _rl_col_width (const char *, int, int, int);\n#else\n#  define _rl_col_width(l, s, e, f)\t(((e) <= (s)) ? 0 : (e) - (s))\n#endif\n\n \n#define CR_FASTER(new, cur) (((new) + 1) < ((cur) - (new)))\n\n \n \n#define PROMPT_ENDING_INDEX \\\n  ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) ? prompt_physical_chars : prompt_last_invisible+1)\n\n#define FACE_NORMAL\t'0'\n#define FACE_STANDOUT\t'1'\n#define FACE_INVALID\t((char)1)\n  \n \n \n \n \n \n\n \n\n \n\n \n\n \nrl_voidfunc_t *rl_redisplay_function = rl_redisplay;\n\n \n \nint rl_display_fixed = 0;\n\n \nchar *rl_display_prompt = (char *)NULL;\n\n \nchar *_rl_emacs_mode_str;\nint _rl_emacs_modestr_len;\n\nchar *_rl_vi_ins_mode_str;\nint _rl_vi_ins_modestr_len;\n\nchar *_rl_vi_cmd_mode_str;\nint _rl_vi_cmd_modestr_len;\n\n \n\n \nint _rl_suppress_redisplay = 0;\nint _rl_want_redisplay = 0;\n\n \n \nint _rl_last_c_pos = 0;\nint _rl_last_v_pos = 0;\n\n \nint _rl_vis_botlin = 0;\n\nstatic int _rl_quick_redisplay = 0;\n\n \nstatic int cpos_adjusted;\n\n \nstatic int cpos_buffer_position;\n\n \nstatic int displaying_prompt_first_line;\n \nstatic int prompt_multibyte_chars;\n\nstatic int _rl_inv_botlin = 0;\n\n \n \nstatic int last_lmargin;\n\n \nstatic char *msg_buf = 0;\nstatic int msg_bufsiz = 0;\n\n \nstatic int forced_display;\n\n \nstatic int line_size  = 0;\n\n \nstatic int horizontal_scrolling_autoset = 0;\t \n\n \n\nstatic char *local_prompt, *local_prompt_prefix;\nstatic int local_prompt_len;\nstatic int prompt_prefix_length;\n \nstatic int prompt_visible_length;\n\n \nstatic int visible_wrap_offset;\n\n \nstatic int wrap_offset;\n\n \nstatic int prompt_last_invisible;\n\n \nstatic int visible_first_line_len;\n\n \nstatic int prompt_invis_chars_first_line;\n\nstatic int prompt_last_screen_line;\n\nstatic int prompt_physical_chars;\n\n \nstatic int *local_prompt_newlines;\n\n \nstatic int modmark;\n\nstatic int line_totbytes;\n\n \n\n \n\nstatic char *saved_local_prompt;\nstatic char *saved_local_prefix;\nstatic int *saved_local_prompt_newlines;\n\nstatic int saved_last_invisible;\nstatic int saved_visible_length;\nstatic int saved_prefix_length;\nstatic int saved_local_length;\nstatic int saved_invis_chars_first_line;\nstatic int saved_physical_chars;\n\n \n\nstatic char *\nprompt_modestr (int *lenp)\n{\n  if (rl_editing_mode == emacs_mode)\n    {\n      if (lenp)\n\t*lenp = _rl_emacs_mode_str ? _rl_emacs_modestr_len : RL_EMACS_MODESTR_DEFLEN;\n      return _rl_emacs_mode_str ? _rl_emacs_mode_str : RL_EMACS_MODESTR_DEFAULT;\n    }\n  else if (_rl_keymap == vi_insertion_keymap)\n    {\n      if (lenp)\n\t*lenp = _rl_vi_ins_mode_str ? _rl_vi_ins_modestr_len : RL_VI_INS_MODESTR_DEFLEN;\n      return _rl_vi_ins_mode_str ? _rl_vi_ins_mode_str : RL_VI_INS_MODESTR_DEFAULT;\t\t \n    }\n  else\n    {\n      if (lenp)\n\t*lenp = _rl_vi_cmd_mode_str ? _rl_vi_cmd_modestr_len : RL_VI_CMD_MODESTR_DEFLEN;\n      return _rl_vi_cmd_mode_str ? _rl_vi_cmd_mode_str : RL_VI_CMD_MODESTR_DEFAULT;\t\t \n    }\n}\n\n \n\n \t\n\n \n\n \n#define APPROX_DIV(n, d)\t(((n) < (d)) ? 1 : ((n) / (d)) + 1)\n\nstatic char *\nexpand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)\n{\n  char *r, *ret, *p, *igstart, *nprompt, *ms;\n  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;\n  int mlen, newlines, newlines_guess, bound, can_add_invis;\n  int mb_cur_max;\n\n   \n  ms = (((pmt == rl_prompt) ^ (flags & PMT_MULTILINE)) && _rl_show_mode_in_prompt) ? prompt_modestr (&mlen) : 0;\n  if (ms)\n    {\n      l = strlen (pmt);\n      nprompt = (char *)xmalloc (l + mlen + 1);\n      memcpy (nprompt, ms, mlen);\n      strcpy (nprompt + mlen, pmt);\n    }\n  else\n    nprompt = pmt;\n\n  can_add_invis = 0;\n  mb_cur_max = MB_CUR_MAX;\n\n  if (_rl_screenwidth == 0)\n    _rl_get_screen_size (0, 0);\t \n\n   \n  if ((mb_cur_max <= 1 || rl_byte_oriented) && strchr (nprompt, RL_PROMPT_START_IGNORE) == 0)\n    {\n      l = strlen (nprompt);\n      if (l < (_rl_screenwidth > 0 ? _rl_screenwidth : 80))\n        {\n\t  r = (nprompt == pmt) ? savestring (pmt) : nprompt;\n\t  if (lp)\n\t    *lp = l;\n\t  if (lip)\n\t    *lip = 0;\n\t  if (niflp)\n\t    *niflp = 0;\n\t  if (vlp)\n\t    *vlp = l;\n\n\t  local_prompt_newlines = (int *) xrealloc (local_prompt_newlines, sizeof (int) * 2);\n\t  local_prompt_newlines[0] = 0;\n\t  local_prompt_newlines[1] = -1;\n\n\t  return r;\n        }\n    }\n\n  l = strlen (nprompt);\t\t\t \n  r = ret = (char *)xmalloc (l + 1);\n\n   \n  newlines_guess = (_rl_screenwidth > 0) ? APPROX_DIV(l,  _rl_screenwidth) : APPROX_DIV(l, 80);\n  local_prompt_newlines = (int *) xrealloc (local_prompt_newlines, sizeof (int) * (newlines_guess + 1));\n  local_prompt_newlines[newlines = 0] = 0;\n  for (rl = 1; rl <= newlines_guess; rl++)\n    local_prompt_newlines[rl] = -1;\n\n  rl = physchars = 0;\t \n  invfl = 0;\t\t \n  invflset = 0;\t\t \n  igstart = 0;\t\t \n\n  for (ignoring = last = ninvis = 0, p = nprompt; p && *p; p++)\n    {\n       \n      if (ignoring == 0 && *p == RL_PROMPT_START_IGNORE)\t\t \n\t{\n\t  ignoring = 1;\n\t  igstart = p;\n\t  continue;\n\t}\n      else if (ignoring && *p == RL_PROMPT_END_IGNORE)\n\t{\n\t  ignoring = 0;\n\t   \n\t  if (can_add_invis)\n\t    {\n\t      local_prompt_newlines[newlines] = r - ret;\n\t       \n\t      if (invflset && newlines == 1)\n\t\tinvfl = ninvis;\n\t    }\n\t  if (p != (igstart + 1))\n\t    last = r - ret - 1;\n\t  continue;\n\t}\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    {\n\t      pind = p - nprompt;\n\t      ind = _rl_find_next_mbchar (nprompt, pind, 1, MB_FIND_NONZERO);\n\t      l = ind - pind;\n\t      while (l--)\n\t        *r++ = *p++;\n\t      if (!ignoring)\n\t\t{\n\t\t   \n\t\t  rl += ind - pind;\n\t\t  physchars += _rl_col_width (nprompt, pind, ind, 0);\n\t\t}\n\t      else\n\t\tninvis += ind - pind;\n\t      p--;\t\t\t \n\t    }\n\t  else\n#endif\n\t    {\n\t      *r++ = *p;\n\t      if (!ignoring)\n\t\t{\n\t\t  rl++;\t\t\t \n\t\t  physchars++;\n\t\t}\n\t      else\n\t\tninvis++;\t\t \n\t    }\n\n\t  if (invflset == 0 && physchars >= _rl_screenwidth)\n\t    {\n\t      invfl = ninvis;\n\t      invflset = 1;\n\t    }\n\n\t  if (physchars >= (bound = (newlines + 1) * _rl_screenwidth) && local_prompt_newlines[newlines+1] == -1)\n\t    {\n\t      int new;\n\t      if (physchars > bound)\t\t \n\t\t{\n#if defined (HANDLE_MULTIBYTE)\n\t\t  *r = '\\0';\t \n\t\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t    new = _rl_find_prev_mbchar (ret, r - ret, MB_FIND_ANY);\n\t\t  else\n#endif\n\t\t    new = r - ret - (physchars - bound);\t \n\t\t}\n\t      else\n\t        new = r - ret;\n\t      local_prompt_newlines[++newlines] = new;\n\t    }\n\n\t   \n\t  if (ignoring == 0)\n\t    can_add_invis = (physchars == bound); \n\t}\n    }\n\n  if (rl <= _rl_screenwidth)\n    invfl = ninvis;\n\n  *r = '\\0';\n  if (lp)\n    *lp = rl;\n  if (lip)\n    *lip = last;\n  if (niflp)\n    *niflp = invfl;\n  if  (vlp)\n    *vlp = physchars;\n\n  if (nprompt != pmt)\n    xfree (nprompt);\n\n  return ret;\n}\n\n \nchar *\n_rl_strip_prompt (char *pmt)\n{\n  char *ret;\n\n  ret = expand_prompt (pmt, 0, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);\n  return ret;\n}\n\nvoid\n_rl_reset_prompt (void)\n{\n  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);\n}\n\n \nint\nrl_expand_prompt (char *prompt)\n{\n  char *p, *t;\n  int c;\n\n   \n  FREE (local_prompt);\n  FREE (local_prompt_prefix);\n\n  local_prompt = local_prompt_prefix = (char *)0;\n  local_prompt_len = 0;\n  prompt_last_invisible = prompt_invis_chars_first_line = 0;\n  prompt_visible_length = prompt_physical_chars = 0;\n\n  if (prompt == 0 || *prompt == 0)\n    return (0);\n\n  p = strrchr (prompt, '\\n');\n  if (p == 0)\n    {\n       \n      local_prompt = expand_prompt (prompt, 0, &prompt_visible_length,\n\t\t\t\t\t       &prompt_last_invisible,\n\t\t\t\t\t       &prompt_invis_chars_first_line,\n\t\t\t\t\t       &prompt_physical_chars);\n      local_prompt_prefix = (char *)0;\n      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n      return (prompt_visible_length);\n    }\n  else\n    {\n       \n      t = ++p;\n      c = *t; *t = '\\0';\n       \n      local_prompt_prefix = expand_prompt (prompt, PMT_MULTILINE,\n\t\t\t\t\t\t   &prompt_prefix_length,\n\t\t\t\t\t\t   (int *)NULL,\n\t\t\t\t\t\t   (int *)NULL,\n\t\t\t\t\t\t   (int *)NULL);\n      *t = c;\n\n      local_prompt = expand_prompt (p, PMT_MULTILINE,\n\t\t\t\t       &prompt_visible_length,\n\t\t\t\t       &prompt_last_invisible,\n\t\t\t\t       &prompt_invis_chars_first_line,\n\t\t\t\t       &prompt_physical_chars);\n      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n      return (prompt_prefix_length);\n    }\n}\n\n \nstatic void\nrealloc_line (int minsize)\n{\n  int minimum_size;\n  int newsize, delta;\n\n  minimum_size = DEFAULT_LINE_BUFFER_SIZE;\n  if (minsize < minimum_size)\n    minsize = minimum_size;\n  if (minsize <= _rl_screenwidth)\t \n    minsize = _rl_screenwidth + 1;\n  if (line_size >= minsize)\n    return;\n\n  newsize = minimum_size;\n  while (newsize < minsize)\n    newsize *= 2;\n\n  visible_line = (char *)xrealloc (visible_line, newsize);\n  vis_face = (char *)xrealloc (vis_face, newsize);\n\n  invisible_line = (char *)xrealloc (invisible_line, newsize);\n  inv_face = (char *)xrealloc (inv_face, newsize);\n\n  delta = newsize - line_size;  \n  memset (visible_line + line_size, 0, delta);\n  memset (vis_face + line_size, FACE_NORMAL, delta);\n  memset (invisible_line + line_size, 1, delta);\n  memset (inv_face + line_size, FACE_INVALID, delta);\n\n  line_size = newsize;\n}\n\n \nstatic void\ninit_line_structures (int minsize)\n{\n  if (invisible_line == 0)\t \n    {\n      if (line_size > minsize)\n\tminsize = line_size;\n    }\n   realloc_line (minsize); \n\n  if (vis_lbreaks == 0)\n    {\n       \n      inv_lbsize = vis_lbsize = 256;\n\n#if defined (HANDLE_MULTIBYTE)\n      line_state_visible->wbsize = vis_lbsize;\n      line_state_visible->wrapped_line = (int *)xmalloc (line_state_visible->wbsize * sizeof (int));\n\n      line_state_invisible->wbsize = inv_lbsize;\n      line_state_invisible->wrapped_line = (int *)xmalloc (line_state_invisible->wbsize * sizeof (int));\n#endif\n\n      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));\n      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));\n      inv_lbreaks[0] = vis_lbreaks[0] = 0;\n    }\n\n  line_structures_initialized = 1;\n}\n\n \nstatic void\t\t \ninvis_addc (int *outp, char c, char face)\n{\n  realloc_line (*outp + 1);\n  invisible_line[*outp] = c;\n  inv_face[*outp] = face;\n  *outp += 1;\n}\n\nstatic void\ninvis_adds (int *outp, const char *str, int n, char face)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    invis_addc (outp, str[i], face);\n}\n\nstatic void\ninvis_nul (int *outp)\n{\n  invis_addc (outp, '\\0', 0);\n  *outp -= 1;\n}\n\nstatic void\nset_active_region (int *beg, int *end)\n{\n  if (rl_point >= 0 && rl_point <= rl_end && rl_mark >= 0 && rl_mark <= rl_end)\n    {\n      *beg = (rl_mark < rl_point) ? rl_mark : rl_point;\n      *end = (rl_mark < rl_point) ? rl_point : rl_mark;\n    }\n}\n\n \nvoid\n_rl_optimize_redisplay (void)\n{\n  if (_rl_vis_botlin == 0)\n    _rl_quick_redisplay = 1;\n}  \n\n \nvoid\nrl_redisplay (void)\n{\n  int in, out, c, linenum, cursor_linenum;\n  int inv_botlin, lb_botlin, lb_linenum, o_cpos;\n  int newlines, lpos, temp, n0, num, prompt_lines_estimate;\n  char *prompt_this_line;\n  char cur_face;\n  int hl_begin, hl_end;\n  int mb_cur_max = MB_CUR_MAX;\n#if defined (HANDLE_MULTIBYTE)\n  WCHAR_T wc;\n  size_t wc_bytes;\n  int wc_width;\n  mbstate_t ps;\n  int _rl_wrapped_multicolumn = 0;\n#endif\n\n  if (_rl_echoing_p == 0)\n    return;\n\n   \n  _rl_block_sigint ();  \n  RL_SETSTATE (RL_STATE_REDISPLAYING);\n\n  cur_face = FACE_NORMAL;\n   \n  hl_begin = hl_end = -1;\n\n  if (rl_mark_active_p ())\n    set_active_region (&hl_begin, &hl_end);\n\n  if (!rl_display_prompt)\n    rl_display_prompt = \"\";\n\n  if (line_structures_initialized == 0)\n    {\n      init_line_structures (0);\n      rl_on_new_line ();\n    }\n  else if (line_size <= _rl_screenwidth)\n    init_line_structures (_rl_screenwidth + 1);\n\n   \n  if (_rl_screenheight <= 1)\n    {\n      if (_rl_horizontal_scroll_mode == 0)\n\t horizontal_scrolling_autoset = 1;\n      _rl_horizontal_scroll_mode = 1;\n    }\n  else if (horizontal_scrolling_autoset)\n    _rl_horizontal_scroll_mode = 0;\n\n   \n  cpos_buffer_position = -1;\n\n  prompt_multibyte_chars = prompt_visible_length - prompt_physical_chars;\n\n  out = inv_botlin = 0;\n\n   \n  modmark = 0;\n  if (_rl_mark_modified_lines && current_history () && rl_undo_list)\n    {\n      invis_addc (&out, '*', cur_face);\n      invis_nul (&out);\n      modmark = 1;\n    }\n\n   \n  if (visible_line[0] != invisible_line[0])\n    rl_display_fixed = 0;\n\n   \n   \n  if (rl_display_prompt == rl_prompt || local_prompt)\n    {\n      if (local_prompt_prefix && forced_display)\n\t_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));\n\n      if (local_prompt_len > 0)\n\tinvis_adds (&out, local_prompt, local_prompt_len, cur_face);\n      invis_nul (&out);\n      wrap_offset = local_prompt_len - prompt_visible_length;\n    }\n  else\n    {\n      int pmtlen;\n      prompt_this_line = strrchr (rl_display_prompt, '\\n');\n      if (!prompt_this_line)\n\tprompt_this_line = rl_display_prompt;\n      else\n\t{\n\t  prompt_this_line++;\n\t  pmtlen = prompt_this_line - rl_display_prompt;\t \n\t  if (forced_display)\n\t    {\n\t      _rl_output_some_chars (rl_display_prompt, pmtlen);\n\t       \n\t      if (pmtlen < 2 || prompt_this_line[-2] != '\\r')\n\t\tcr ();\n\t    }\n\t}\n\n      prompt_physical_chars = pmtlen = strlen (prompt_this_line);\t \n      invis_adds (&out, prompt_this_line, pmtlen, cur_face);\n      invis_nul (&out);\n      wrap_offset = prompt_invis_chars_first_line = 0;\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n#define CHECK_INV_LBREAKS() \\\n      do { \\\n\tif (newlines >= (inv_lbsize - 2)) \\\n\t  { \\\n\t    inv_lbsize *= 2; \\\n\t    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t  } \\\n\tif (newlines >= (line_state_invisible->wbsize - 2)) \\\n\t  { \\\n\t    line_state_invisible->wbsize *= 2; \\\n\t    line_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \\\n\t  } \\\n      } while (0)\n#else\n#define CHECK_INV_LBREAKS() \\\n      do { \\\n\tif (newlines >= (inv_lbsize - 2)) \\\n\t  { \\\n\t    inv_lbsize *= 2; \\\n\t    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t  } \\\n      } while (0)\n#endif  \n\n#if defined (HANDLE_MULTIBYTE)\t  \n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    if (newlines >= (line_state_invisible->wbsize - 2)) \\\n\t      { \\\n\t\tline_state_invisible->wbsize *= 2; \\\n\t\tline_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \\\n\t      } \\\n\t    line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#else\n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#endif\n\n   \n  inv_lbreaks[newlines = 0] = 0;\n   \n  lpos = prompt_physical_chars + modmark;\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (line_state_invisible->wrapped_line, 0, line_state_invisible->wbsize * sizeof (int));\n  num = 0;\n#endif\n\n   \n\n   \n  prompt_lines_estimate = lpos / _rl_screenwidth;\n\n   \n  if (lpos >= _rl_screenwidth)\n    {\n      temp = 0;\n\n       \n      while (local_prompt_newlines[newlines+1] != -1)\n\t{\n\t  temp = local_prompt_newlines[newlines+1];\n\t  inv_lbreaks[++newlines] = temp;\n\t}  \n\n       \n      if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n        lpos = _rl_col_width (local_prompt, temp, local_prompt_len, 1) - (wrap_offset - prompt_invis_chars_first_line);\n      else\n        lpos -= (_rl_screenwidth * newlines);\n    }\n\n  prompt_last_screen_line = newlines;\n\n   \n  lb_linenum = 0;\n#if defined (HANDLE_MULTIBYTE)\n  in = 0;\n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    {\n      memset (&ps, 0, sizeof (mbstate_t));\n      if (_rl_utf8locale && UTF8_SINGLEBYTE(rl_line_buffer[0]))\n\t{\n\t  wc = (WCHAR_T)rl_line_buffer[0];\n\t  wc_bytes = 1;\n\t}\n      else\n\twc_bytes = MBRTOWC (&wc, rl_line_buffer, rl_end, &ps);\n    }\n  else\n    wc_bytes = 1;\n  while (in < rl_end)\n#else\n  for (in = 0; in < rl_end; in++)\n#endif\n    {\n      if (in == hl_begin)\n\tcur_face = FACE_STANDOUT;\n      else if (in == hl_end)\n\tcur_face = FACE_NORMAL;\n\n      c = (unsigned char)rl_line_buffer[in];\n\n#if defined (HANDLE_MULTIBYTE)\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  if (MB_INVALIDCH (wc_bytes))\n\t    {\n\t       \n\t      wc_bytes = 1;\n\t       \n\t      wc_width = 1;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t    }\n\t  else if (MB_NULLWCH (wc_bytes))\n\t    break;\t\t\t \n\t  else\n\t    {\n\t      temp = WCWIDTH (wc);\n\t      wc_width = (temp >= 0) ? temp : 1;\n\t    }\n\t}\n#endif\n\n      if (in == rl_point)\n\t{\n\t  cpos_buffer_position = out;\n\t  lb_linenum = newlines;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (META_CHAR (c) && _rl_output_meta_chars == 0)\t \n#else\n      if (META_CHAR (c))\n#endif\n\t{\n\t  if (_rl_output_meta_chars == 0)\n\t    {\n\t      char obuf[5];\n\t      int olen;\n\n\t      olen = sprintf (obuf, \"\\\\%o\", c);\n\t  \n\t      if (lpos + olen >= _rl_screenwidth)\n\t\t{\n\t\t  temp = _rl_screenwidth - lpos;\n\t\t  CHECK_INV_LBREAKS ();\n\t\t  inv_lbreaks[++newlines] = out + temp;\n#if defined (HANDLE_MULTIBYTE)\n\t\t  line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn;\n#endif\n\t\t  lpos = olen - temp;\n\t\t}\n\t      else\n\t\tlpos += olen;\n\n\t      for (temp = 0; temp < olen; temp++)\n\t\t{\n\t\t  invis_addc (&out, obuf[temp], cur_face);\n\t\t  CHECK_LPOS ();\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      invis_addc (&out, c, cur_face);\n\t      CHECK_LPOS();\n\t    }\n\t}\n#if defined (DISPLAY_TABS)\n      else if (c == '\\t')\n\t{\n\t  register int newout;\n\n\t  newout = out + 8 - lpos % 8;\n\t  temp = newout - out;\n\t  if (lpos + temp >= _rl_screenwidth)\n\t    {\n\t      register int temp2;\n\t      temp2 = _rl_screenwidth - lpos;\n\t      CHECK_INV_LBREAKS ();\n\t      inv_lbreaks[++newlines] = out + temp2;\n#if defined (HANDLE_MULTIBYTE)\n\t      line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn;\n#endif\n\t      lpos = temp - temp2;\n\t      while (out < newout)\n\t\tinvis_addc (&out, ' ', cur_face);\n\t    }\n\t  else\n\t    {\n\t      while (out < newout)\n\t\tinvis_addc (&out, ' ', cur_face);\n\t      lpos += temp;\n\t    }\n\t}\n#endif\n      else if (c == '\\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n\t{\n\t  invis_addc (&out, '\\0', cur_face);\n\t  CHECK_INV_LBREAKS ();\n\t  inv_lbreaks[++newlines] = out;\n#if defined (HANDLE_MULTIBYTE)\n\t  line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn;\n#endif\n\t  lpos = 0;\n\t}\n      else if (CTRL_CHAR (c) || c == RUBOUT)\n\t{\n\t  invis_addc (&out, '^', cur_face);\n\t  CHECK_LPOS();\n\t  invis_addc (&out, CTRL_CHAR (c) ? UNCTRL (c) : '?', cur_face);\n\t  CHECK_LPOS();\n\t}\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    {\n\t      register int i;\n\n\t      _rl_wrapped_multicolumn = 0;\n\n\t      if (_rl_screenwidth < lpos + wc_width)\n\t\tfor (i = lpos; i < _rl_screenwidth; i++)\n\t\t  {\n\t\t     \n\t\t    invis_addc (&out, ' ', cur_face);\n\t\t    _rl_wrapped_multicolumn++;\n\t\t    CHECK_LPOS();\n\t\t  }\n\t      if (in == rl_point)\n\t\t{\n\t\t  cpos_buffer_position = out;\n\t\t  lb_linenum = newlines;\n\t\t}\n\t      for (i = in; i < in+wc_bytes; i++)\n\t\tinvis_addc (&out, rl_line_buffer[i], cur_face);\n\t      for (i = 0; i < wc_width; i++)\n\t\tCHECK_LPOS();\n\t    }\n\t  else\n\t    {\n\t      invis_addc (&out, c, cur_face);\n\t      CHECK_LPOS();\n\t    }\n#else\n\t  invis_addc (&out, c, cur_face);\n\t  CHECK_LPOS();\n#endif\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  in += wc_bytes;\n\t  if (_rl_utf8locale && UTF8_SINGLEBYTE(rl_line_buffer[in]))\n\t    {\n\t      wc = (WCHAR_T)rl_line_buffer[in];\n\t      wc_bytes = 1;\n\t      memset (&ps, 0, sizeof (mbstate_t));\t \n\t    }\n\t  else\n\t    wc_bytes = MBRTOWC (&wc, rl_line_buffer + in, rl_end - in, &ps);\n\t}\n      else\n        in++;\n#endif\n    }\n  invis_nul (&out);\n  line_totbytes = out;\n  if (cpos_buffer_position < 0)\n    {\n      cpos_buffer_position = out;\n      lb_linenum = newlines;\n    }\n\n   \n  if (_rl_quick_redisplay && newlines > 0)\n    _rl_quick_redisplay = 0;\n\n  inv_botlin = lb_botlin = _rl_inv_botlin = newlines;\n  CHECK_INV_LBREAKS ();\n  inv_lbreaks[newlines+1] = out;\n#if defined (HANDLE_MULTIBYTE)\n   \n  line_state_invisible->wrapped_line[newlines+1] = _rl_wrapped_multicolumn;\n#endif\n  cursor_linenum = lb_linenum;\n\n   \n\n   \n\n   \n  displaying_prompt_first_line = 1;\n  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n    {\n      int nleft, pos, changed_screen_line, tx;\n\n      if (!rl_display_fixed || forced_display)\n\t{\n\t  forced_display = 0;\n\n\t   \n\t  if (out >= _rl_screenchars)\n\t    {\n#if defined (HANDLE_MULTIBYTE)\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\tout = _rl_find_prev_mbchar (invisible_line, _rl_screenchars, MB_FIND_ANY);\n\t      else\n#endif\n\t\tout = _rl_screenchars - 1;\n\t    }\n\n\t   \n\n#define INVIS_FIRST()\t(prompt_physical_chars > _rl_screenwidth ? prompt_invis_chars_first_line : wrap_offset)\n#define WRAP_OFFSET(line, offset)  ((line == 0) \\\n\t\t\t\t\t? (offset ? INVIS_FIRST() : 0) \\\n\t\t\t\t\t: ((line == prompt_last_screen_line) ? wrap_offset-prompt_invis_chars_first_line : 0))\n#define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)\n#define VIS_LLEN(l)\t((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))\n#define INV_LLEN(l)\t(inv_lbreaks[l+1] - inv_lbreaks[l])\n#define VIS_CHARS(line) (visible_line + vis_lbreaks[line])\n#define VIS_FACE(line) (vis_face + vis_lbreaks[line])\n#define VIS_LINE(line) ((line) > _rl_vis_botlin) ? \"\" : VIS_CHARS(line)\n#define VIS_LINE_FACE(line) ((line) > _rl_vis_botlin) ? \"\" : VIS_FACE(line)\n#define INV_LINE(line) (invisible_line + inv_lbreaks[line])\n#define INV_LINE_FACE(line) (inv_face + inv_lbreaks[line])\n\n#define OLD_CPOS_IN_PROMPT() (cpos_adjusted == 0 && \\\n\t\t\t_rl_last_c_pos != o_cpos && \\\n\t\t\t_rl_last_c_pos > wrap_offset && \\\n\t\t\to_cpos < prompt_last_invisible)\n\n\n\t   \n\t  if (rl_mark_active_p () && inv_botlin > _rl_screenheight)\n\t    {\n\t      int extra;\n\n\t      extra = inv_botlin - _rl_screenheight;\n\t      for (linenum = 0; linenum <= extra; linenum++)\n\t\tnorm_face (INV_LINE_FACE(linenum), INV_LLEN (linenum));\n\t    }\n\n\t   \n\t  for (linenum = 0; linenum <= inv_botlin; linenum++)\n\t    {\n\t       \n\t      o_cpos = _rl_last_c_pos;\n\t      cpos_adjusted = 0;\n\t      update_line (VIS_LINE(linenum), VIS_LINE_FACE(linenum),\n\t\t\t   INV_LINE(linenum), INV_LINE_FACE(linenum),\n\t\t\t   linenum,\n\t\t\t   VIS_LLEN(linenum), INV_LLEN(linenum), inv_botlin);\n\n\t       \n\t      if (linenum == 0 && (mb_cur_max > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n\t\t_rl_last_c_pos -= prompt_invis_chars_first_line;\t \n\t      else if (cpos_adjusted == 0 &&\n\t\t\tlinenum == prompt_last_screen_line &&\n\t\t\tprompt_physical_chars > _rl_screenwidth &&\n\t\t\t(mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\t\t_rl_last_c_pos != o_cpos &&\n\t\t\t_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))\t \n\t\t \n\t\t \n\t\t_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);\n\n\t       \n\t      if (linenum == 0 &&\n\t\t  inv_botlin == 0 && _rl_last_c_pos == out &&\n\t\t  (wrap_offset > visible_wrap_offset) &&\n\t\t  (_rl_last_c_pos < visible_first_line_len))\n\t\t{\n\t\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t    nleft = _rl_screenwidth - _rl_last_c_pos;\n\t\t  else\n\t\t    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;\n\t\t  if (nleft)\n\t\t    _rl_clear_to_eol (nleft);\n\t\t}\n#if 0\n\t       \n\t      else if (linenum == 0 &&\n\t\t       linenum == prompt_last_screen_line &&\n\t\t       _rl_last_c_pos == out &&\n\t\t       _rl_last_c_pos < visible_first_line_len &&\n\t\t       visible_wrap_offset &&\n\t\t       visible_wrap_offset != wrap_offset)\n\t\t{\n\t\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t    nleft = _rl_screenwidth - _rl_last_c_pos;\n\t\t  else\n\t\t    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;\n\t\t  if (nleft)\n\t\t    _rl_clear_to_eol (nleft);\n\t\t}\n#endif\n\n\t       \n\t      if (linenum == 0)\n\t\tvisible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;\n\t    }\n\n\t   \n\t  if (_rl_vis_botlin > inv_botlin)\n\t    {\n\t      char *tt;\n\t      for (; linenum <= _rl_vis_botlin; linenum++)\n\t\t{\n\t\t  tt = VIS_CHARS (linenum);\n\t\t  _rl_move_vert (linenum);\n\t\t  _rl_move_cursor_relative (0, tt, VIS_FACE(linenum));\n\t\t  _rl_clear_to_eol\n\t\t    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);\n\t\t}\n\t    }\n\t  _rl_vis_botlin = inv_botlin;\n\n\t   \n\t  changed_screen_line = _rl_last_v_pos != cursor_linenum;\n\t  if (changed_screen_line)\n\t    {\n\t      _rl_move_vert (cursor_linenum);\n\t       \n\t      if ((mb_cur_max == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)\n\t\t_rl_last_c_pos += wrap_offset;\n\t    }\n\n\t   \n\n\t   \n\t   \n\t  nleft = prompt_visible_length + wrap_offset;\n\t  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&\n\t      _rl_last_c_pos < PROMPT_ENDING_INDEX && local_prompt)\n\t    {\n\t      _rl_cr ();\n\t      if (modmark)\n\t\t_rl_output_some_chars (\"*\", 1);\n\n\t      _rl_output_some_chars (local_prompt, nleft);\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft, 1) - wrap_offset + modmark;\n\t      else\n\t\t_rl_last_c_pos = nleft + modmark;\n\t    }\n\n\t   \n\t  pos = inv_lbreaks[cursor_linenum];\n\t   \n\t  nleft = cpos_buffer_position - pos;\n\n\t   \n\n\t   \n\t  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)\n\t    {\n\t       \n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\ttx = _rl_col_width (&visible_line[pos], 0, nleft, 1) - visible_wrap_offset;\n\t      else\n\t\ttx = nleft;\n\t      if (tx >= 0 && _rl_last_c_pos > tx)\n\t\t{\n\t          _rl_backspace (_rl_last_c_pos - tx);\t \n\t          _rl_last_c_pos = tx;\n\t\t}\n\t    }\n\n\t   \n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    _rl_move_cursor_relative (nleft, &invisible_line[pos], &inv_face[pos]);\n\t  else if (nleft != _rl_last_c_pos)\n\t    _rl_move_cursor_relative (nleft, &invisible_line[pos], &inv_face[pos]);\n\t}\n    }\n  else\t\t\t\t \n    {\n#define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)\n      int lmargin, ndisp, nleft, phys_c_pos, t;\n\n       \n      _rl_last_v_pos = 0;\n\n       \n\n       \n      ndisp = cpos_buffer_position - wrap_offset;\n      nleft  = prompt_visible_length + wrap_offset;\n       \n      phys_c_pos = cpos_buffer_position - (last_lmargin ? last_lmargin : wrap_offset);\n      t = _rl_screenwidth / 3;\n\n       \n\n       \n      if (phys_c_pos > _rl_screenwidth - 2)\n\t{\n\t  lmargin = cpos_buffer_position - (2 * t);\n\t  if (lmargin < 0)\n\t    lmargin = 0;\n\t   \n\t  if (wrap_offset && lmargin > 0 && lmargin < nleft)\n\t    lmargin = nleft;\n\t}\n      else if (ndisp < _rl_screenwidth - 2)\t\t \n\tlmargin = 0;\n      else if (phys_c_pos < 1)\n\t{\n\t   \n\t  lmargin = ((cpos_buffer_position - 1) / t) * t;\t \n\t  if (wrap_offset && lmargin > 0 && lmargin < nleft)\n\t    lmargin = nleft;\n\t}\n      else\n\tlmargin = last_lmargin;\n\n      displaying_prompt_first_line = lmargin < nleft;\n\n       \n      if (lmargin > 0)\n\tinvisible_line[lmargin] = '<';\n\n       \n      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;\n      if (t > 0 && t < out)\n\tinvisible_line[t - 1] = '>';\n\n      if (rl_display_fixed == 0 || forced_display || lmargin != last_lmargin)\n\t{\n\t  forced_display = 0;\n\t  o_cpos = _rl_last_c_pos;\n\t  cpos_adjusted = 0;\n\t  update_line (&visible_line[last_lmargin], &vis_face[last_lmargin],\n\t\t       &invisible_line[lmargin], &inv_face[lmargin],\n\t\t       0,\n\t\t       _rl_screenwidth + visible_wrap_offset,\n\t\t       _rl_screenwidth + (lmargin ? 0 : wrap_offset),\n\t\t       0);\n\n\t  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\tdisplaying_prompt_first_line && OLD_CPOS_IN_PROMPT())\n\t    _rl_last_c_pos -= prompt_invis_chars_first_line;\t \n\n\t   \n\t  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);\n\t  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&\n\t      (_rl_last_c_pos == out) && displaying_prompt_first_line &&\n\t      t < visible_first_line_len)\n\t    {\n\t      nleft = _rl_screenwidth - t;\n\t      _rl_clear_to_eol (nleft);\n\t    }\n\t  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);\n\t  if (visible_first_line_len > _rl_screenwidth)\n\t    visible_first_line_len = _rl_screenwidth;\n\n\t  _rl_move_cursor_relative (cpos_buffer_position - lmargin, &invisible_line[lmargin], &inv_face[lmargin]);\n\t  last_lmargin = lmargin;\n\t}\n    }\n  fflush (rl_outstream);\n\n   \n  {\n    struct line_state *vtemp = line_state_visible;\n\n    line_state_visible = line_state_invisible;\n    line_state_invisible = vtemp;\n\n    rl_display_fixed = 0;\n     \n    if (_rl_horizontal_scroll_mode && last_lmargin)\n      visible_wrap_offset = 0;\n    else\n      visible_wrap_offset = wrap_offset;\n\n    _rl_quick_redisplay = 0;\n  }\n\n  RL_UNSETSTATE (RL_STATE_REDISPLAYING);\n  _rl_release_sigint ();\n}\n\nstatic void\nputc_face (int c, int face, char *cur_face)\n{\n  char cf;\n  cf = *cur_face;\n  if (cf != face)\n    {\n      if (cf != FACE_NORMAL && cf != FACE_STANDOUT)\n\treturn;\n      if (face != FACE_NORMAL && face != FACE_STANDOUT)\n\treturn;\n      if (face == FACE_STANDOUT && cf == FACE_NORMAL)\n\t_rl_region_color_on ();\n      if (face == FACE_NORMAL && cf == FACE_STANDOUT)\n\t_rl_region_color_off ();\n      *cur_face = face;\n    }\n  if (c != EOF)\n    putc (c, rl_outstream);\n}\n\nstatic void\nputs_face (const char *str, const char *face, int n)\n{\n  int i;\n  char cur_face;\n\n  for (cur_face = FACE_NORMAL, i = 0; i < n; i++)\n    putc_face ((unsigned char) str[i], face[i], &cur_face);\n  putc_face (EOF, FACE_NORMAL, &cur_face);\n}\n\nstatic void\nnorm_face (char *face, int n)\n{\n  memset (face, FACE_NORMAL, n);\n}\n\n#define ADJUST_CPOS(x) do { _rl_last_c_pos -= (x) ; cpos_adjusted = 1; } while (0)\n\n \nstatic void\nupdate_line (char *old, char *old_face, char *new, char *new_face, int current_line, int omax, int nmax, int inv_botlin)\n{\n  char *ofd, *ols, *oe, *nfd, *nls, *ne;\n  char *ofdf, *nfdf, *olsf, *nlsf;\n  int temp, lendiff, wsatend, od, nd, twidth, o_cpos;\n  int current_invis_chars;\n  int col_lendiff, col_temp;\n  int bytes_to_insert;\n  int mb_cur_max = MB_CUR_MAX;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps_new, ps_old;\n  int new_offset, old_offset;\n#endif\n\n   \n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    temp = _rl_last_c_pos;\n  else\n    temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);\n  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode\n\t&& _rl_last_v_pos == current_line - 1)\n    {\n       \n       \n#if defined (HANDLE_MULTIBYTE)\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  WCHAR_T wc;\n\t  mbstate_t ps;\n\t  int oldwidth, newwidth;\n\t  int oldbytes, newbytes;\n\t  size_t ret;\n\n\t   \n\t   \n\t   \n\t  if (current_line < line_state_invisible->wbsize && line_state_invisible->wrapped_line[current_line] > 0)\n\t    _rl_clear_to_eol (line_state_invisible->wrapped_line[current_line]);\n\n\t   \n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t  ret = MBRTOWC (&wc, old, mb_cur_max, &ps);\n\t  oldbytes = ret;\n\t  if (MB_INVALIDCH (ret))\n\t    {\n\t      oldwidth = 1;\n\t      oldbytes = 1;\n\t    }\n\t  else if (MB_NULLWCH (ret))\n\t    oldwidth = 0;\n\t  else\n\t    oldwidth = WCWIDTH (wc);\n\t  if (oldwidth < 0)\n\t    oldwidth = 1;\n\n\t   \n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t  ret = MBRTOWC (&wc, new, mb_cur_max, &ps);\n\t  newbytes = ret;\n\t  if (MB_INVALIDCH (ret))\n\t    {\n\t      newwidth = 1;\n\t      newbytes = 1;\n\t    }\n\t  else if (MB_NULLWCH (ret))\n\t    newwidth = 0;\n\t  else\n\t    newwidth = WCWIDTH (wc);\n\t  if (newwidth < 0)\n\t    newwidth = 1;\n\n\t   \n\t  while (newbytes < nmax && newwidth < oldwidth)\n\t    {\n\t      int t;\n\n\t      ret = MBRTOWC (&wc, new+newbytes, mb_cur_max, &ps);\n\t      if (MB_INVALIDCH (ret))\n\t\t{\n\t\t  newwidth += 1;\n\t\t  newbytes += 1;\n\t\t}\n\t      else if (MB_NULLWCH (ret))\n\t        break;\n\t      else\n\t\t{\n\t\t  t = WCWIDTH (wc);\n\t\t  newwidth += (t >= 0) ? t : 1;\n\t\t  newbytes += ret;\n\t\t}\n\t    }\n\t   \n\t  while (oldbytes < omax && oldwidth < newwidth)\n\t    {\n\t      int t;\n\n\t      ret = MBRTOWC (&wc, old+oldbytes, mb_cur_max, &ps);\n\t      if (MB_INVALIDCH (ret))\n\t\t{\n\t\t  oldwidth += 1;\n\t\t  oldbytes += 1;\n\t\t}\n\t      else if (MB_NULLWCH (ret))\n\t        break;\n\t      else\n\t\t{\n\t\t  t = WCWIDTH (wc);\n\t\t  oldwidth += (t >= 0) ? t : 1;\n\t\t  oldbytes += ret;\n\t\t}\n\t    }\n\t   \n\t  if (newwidth > 0)\n\t    {\n\t      int count, i, j;\n\t      char *optr;\n\n\t      puts_face (new, new_face, newbytes);\n\t      _rl_last_c_pos = newwidth;\n\t      _rl_last_v_pos++;\n\n\t       \n\t      if (newwidth != oldwidth || newbytes > oldbytes)\n\t\t{\n\t\t  oe = old + omax;\n\t\t  ne = new + nmax;\n\t\t  nd = newbytes;\n\t\t  nfd = new + nd;\n\t\t  ofdf = old_face + oldbytes;\n\t\t  nfdf = new_face + newbytes;\n\n\t\t  goto dumb_update;\n\t\t}\n\t      if (oldbytes != 0 && newbytes != 0)\n\t\t{\n\t\t   \n\t\t   \n\n\t\t   \n\t\t  if (oldbytes != newbytes)\n\t\t    {\n\t\t      memmove (old+newbytes, old+oldbytes, strlen (old+oldbytes) + 1);\n\t\t      memmove (old_face+newbytes, old_face+oldbytes, strlen (old+oldbytes) + 1);\n\t\t    }\n\t\t  memcpy (old, new, newbytes);\n\t\t  memcpy (old_face, new_face, newbytes);\n\t\t  j = newbytes - oldbytes;\n\t\t  omax += j;\n\t\t   \n\t\t  for (i = current_line+1; j != 0 && i <= inv_botlin+1 && i <=_rl_vis_botlin+1; i++)\n\t\t    vis_lbreaks[i] += j;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      putc (' ', rl_outstream);\n\t      _rl_last_c_pos = 1;\n\t      _rl_last_v_pos++;\n\t      if (old[0] && new[0])\n\t\t{\n\t\t  old[0] = new[0];\n\t\t  old_face[0] = new_face[0];\n\t\t}\n\t    }\n\t}\n      else\n#endif\n\t{\n\t  if (new[0])\n\t    puts_face (new, new_face, 1);\n\t  else\n\t    putc (' ', rl_outstream);\n\t  _rl_last_c_pos = 1;\n\t  _rl_last_v_pos++;\n\t  if (old[0] && new[0])\n\t    {\n\t      old[0] = new[0];\n\t      old_face[0] = new_face[0];\n\t    }\n\t}\n    }\n\n   \n  if (_rl_quick_redisplay)\n    {\n      nfd = new;\n      nfdf = new_face;\n      ofd = old;\n      ofdf = old_face;\n      for (od = 0, oe = ofd; od < omax && *oe; oe++, od++);\n      for (nd = 0, ne = nfd; nd < nmax && *ne; ne++, nd++);\n      od = nd = 0;\n      _rl_move_cursor_relative (0, old, old_face);\n\n      bytes_to_insert = ne - nfd;\n      if (bytes_to_insert < local_prompt_len)\t \n\tgoto dumb_update;\n\n       \n      _rl_output_some_chars (nfd, local_prompt_len);\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t_rl_last_c_pos = prompt_physical_chars;\n      else\n\t_rl_last_c_pos = local_prompt_len;\n\n      bytes_to_insert -= local_prompt_len;\n      if (bytes_to_insert > 0)\n\t{\n\t  puts_face (new+local_prompt_len, nfdf+local_prompt_len, bytes_to_insert);\n\t  if (mb_cur_max > 1 && rl_byte_oriented)\n\t    _rl_last_c_pos += _rl_col_width (new, local_prompt_len, ne-new, 1);\n\t  else\n\t    _rl_last_c_pos += bytes_to_insert;\n\t}\n\n       \n      if (nmax < omax)\n\tgoto clear_rest_of_line;\n      else if ((nmax - W_OFFSET(current_line, wrap_offset)) < (omax - W_OFFSET (current_line, visible_wrap_offset)))\n\tgoto clear_rest_of_line;\n      else\n\treturn;\n    }\n\n   \n#if defined (HANDLE_MULTIBYTE)\n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    {\n       \n      temp = (omax < nmax) ? omax : nmax;\n      if (memcmp (old, new, temp) == 0 && memcmp (old_face, new_face, temp) == 0)\n\t{\n\t  new_offset = old_offset = temp;\t \n\t  ofd = old + temp;\n\t  ofdf = old_face + temp;\n\t  nfd = new + temp;\n\t  nfdf = new_face + temp;\n\t}\n      else\n\t{      \n\t  memset (&ps_new, 0, sizeof(mbstate_t));\n\t  memset (&ps_old, 0, sizeof(mbstate_t));\n\n\t   \n\t  if (omax == nmax && memcmp (new, old, omax) == 0 && memcmp (new_face, old_face, omax) == 0)\n\t    {\n\t      old_offset = omax;\n\t      new_offset = nmax;\n\t      ofd = old + omax;\n\t      ofdf = old_face + omax;\n\t      nfd = new + nmax;\n\t      nfdf = new_face + nmax;\n\t    }\n\t  else\n\t    {\n\t       \n\t      new_offset = old_offset = 0;\n\t      for (ofd = old, ofdf = old_face, nfd = new, nfdf = new_face;\n\t\t    (ofd - old < omax) && *ofd &&\n\t\t    _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new) &&\n\t\t    *ofdf == *nfdf; )\n\t\t{\n\t\t  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);\n\t\t  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);\n\n\t\t  ofd = old + old_offset;\n\t\t  ofdf = old_face + old_offset;\n\t\t  nfd = new + new_offset;\n\t\t  nfdf = new_face + new_offset;\n\t\t}\n\t    }\n\t}\n    }\n  else\n#endif\n  for (ofd = old, ofdf = old_face, nfd = new, nfdf = new_face;\n       (ofd - old < omax) && *ofd && (*ofd == *nfd) && (*ofdf == *nfdf);\n       ofd++, nfd++, ofdf++, nfdf++)\n    ;\n\n   \n  for (od = ofd - old, oe = ofd; od < omax && *oe; oe++, od++);\n  for (nd = nfd - new, ne = nfd; nd < nmax && *ne; ne++, nd++);\n\n   \n  if (ofd == oe && nfd == ne)\n    return;\n\n#if defined (HANDLE_MULTIBYTE)\n  if (mb_cur_max > 1 && rl_byte_oriented == 0 && _rl_utf8locale)\n    {\n      WCHAR_T wc;\n      mbstate_t ps = { 0 };\n      int t;\n\n       \n      t = MBRTOWC (&wc, ofd, mb_cur_max, &ps);\n      if (t > 0 && UNICODE_COMBINING_CHAR (wc) && WCWIDTH (wc) == 0)\n\t{\n\t  old_offset = _rl_find_prev_mbchar (old, ofd - old, MB_FIND_ANY);\n\t  new_offset = _rl_find_prev_mbchar (new, nfd - new, MB_FIND_ANY);\n\t  ofd = old + old_offset;\t \n\t  ofdf = old_face + old_offset;\n\t  nfd = new + new_offset;\n\t  nfdf = new_face + new_offset;\n\t}\n    }\n#endif\n\n  wsatend = 1;\t\t\t \n\n#if defined (HANDLE_MULTIBYTE)\n   \n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    {\n      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);\n      olsf = old_face + (ols - old);\n      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);\n      nlsf = new_face + (nls - new);\n\n      while ((ols > ofd) && (nls > nfd))\n\t{\n\t  memset (&ps_old, 0, sizeof (mbstate_t));\n\t  memset (&ps_new, 0, sizeof (mbstate_t));\n\n\t  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0 ||\n\t\t*olsf != *nlsf)\n\t    break;\n\n\t  if (*ols == ' ')\n\t    wsatend = 0;\n\n\t  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);\n\t  olsf = old_face + (ols - old);\n\t  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);\n\t  nlsf = new_face + (nls - new);\n\t}\n    }\n  else\n    {\n#endif  \n  ols = oe - 1;\t\t\t \n  olsf = old_face + (ols - old);\n  nls = ne - 1;\n  nlsf = new_face + (nls - new);\n  while ((ols > ofd) && (nls > nfd) && (*ols == *nls) && (*olsf == *nlsf))\n    {\n      if (*ols != ' ')\n\twsatend = 0;\n      ols--; olsf--;\n      nls--; nlsf--;\n    }\n#if defined (HANDLE_MULTIBYTE)\n    }\n#endif\n\n  if (wsatend)\n    {\n      ols = oe;\n      olsf = old_face + (ols - old);\n      nls = ne;\n      nlsf = new_face + (nls - new);\n    }\n#if defined (HANDLE_MULTIBYTE)\n   \n  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0 || *olsf != *nlsf)\n#else\n  else if (*ols != *nls || *olsf != *nlsf)\n#endif\n    {\n      if (*ols)\t\t\t \n\t{\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);\n\t  else\n\t    ols++;\n\t}\n      if (*nls)\n\t{\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);\n\t  else\n\t    nls++;\n\t}\n      olsf = old_face + (ols - old);\n      nlsf = new_face + (nls - new);\n    }\n\n   \n  current_invis_chars = W_OFFSET (current_line, wrap_offset);\n  if (_rl_last_v_pos != current_line)\n    {\n      _rl_move_vert (current_line);\n       \n      if (current_line == 0)\n\tvisible_wrap_offset = prompt_invis_chars_first_line;\t \n#if 0\t\t \n      else if (current_line == prompt_last_screen_line && wrap_offset > prompt_invis_chars_first_line)\n\tvisible_wrap_offset = wrap_offset - prompt_invis_chars_first_line\n#endif\n      if ((mb_cur_max == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)\n\t_rl_last_c_pos += visible_wrap_offset;\n    }\n\n   \n\n  lendiff = local_prompt_len;\n  if (lendiff > nmax)\n    lendiff = nmax;\n  od = ofd - old;\t \n  nd = nfd - new;\t \n  if (current_line == 0 && !_rl_horizontal_scroll_mode &&\n      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&\n      (((od > 0 || nd > 0) && (od <= prompt_last_invisible || nd <= prompt_last_invisible)) ||\n\t\t((od >= lendiff) && _rl_last_c_pos < PROMPT_ENDING_INDEX)))\n    {\n      _rl_cr ();\n      if (modmark)\n\t_rl_output_some_chars (\"*\", 1);\n      _rl_output_some_chars (local_prompt, lendiff);\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t   \n\t  if (lendiff == local_prompt_len)\n\t    _rl_last_c_pos = prompt_physical_chars + modmark;\n\t  else\n\t     \n\t    _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff, 1) - wrap_offset + modmark;\n\t  cpos_adjusted = 1;\n\t}\n      else\n\t_rl_last_c_pos = lendiff + modmark;\n\n       \n      if ((od <= prompt_last_invisible || nd <= prompt_last_invisible) &&\n          omax == nmax &&\n\t  lendiff > (ols-old) && lendiff > (nls-new))\n\treturn;\n\n       \n      if ((od <= prompt_last_invisible || nd <= prompt_last_invisible))\n\t{\n\t  nfd = new + lendiff;\t \n\t  nfdf = new_face + lendiff;\n\t  nd = lendiff;\n\n\t   \ndumb_update:\n\t  temp = ne - nfd;\n\t  if (temp > 0)\n\t    {\n\t      puts_face (nfd, nfdf, temp);\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t{\n\t\t  _rl_last_c_pos += _rl_col_width (new, nd, ne - new, 1);\n\t\t   \n\t\t  if (wrap_offset > prompt_invis_chars_first_line &&\n\t\t      current_line == prompt_last_screen_line &&\n\t\t      prompt_physical_chars > _rl_screenwidth &&\n\t\t      _rl_horizontal_scroll_mode == 0)\n\t\t    ADJUST_CPOS (wrap_offset - prompt_invis_chars_first_line);\n\n\t\t   \n\t\t  else if (current_line == 0 &&\n\t\t\t   nfd == new &&\n\t\t\t   prompt_invis_chars_first_line &&\n\t\t\t   local_prompt_len <= temp &&\n\t\t\t   wrap_offset >= prompt_invis_chars_first_line &&\n\t\t\t   _rl_horizontal_scroll_mode == 0)\n\t\t    ADJUST_CPOS (prompt_invis_chars_first_line);\n\t\t}\n\t      else\n\t\t_rl_last_c_pos += temp;\n\t    }\n\t   \n\t  if (nmax < omax)\n\t    goto clear_rest_of_line;\t \n\t  else if ((nmax - W_OFFSET(current_line, wrap_offset)) < (omax - W_OFFSET (current_line, visible_wrap_offset)))\n\t    goto clear_rest_of_line;\n\t  else\n\t    return;\n\t}\n    }\n\n  o_cpos = _rl_last_c_pos;\n\n   \n  _rl_move_cursor_relative (od, old, old_face);\n\n#if defined (HANDLE_MULTIBYTE)\n   \n  if (current_line == 0 && mb_cur_max > 1 && rl_byte_oriented == 0 &&\n      (_rl_last_c_pos > 0 || o_cpos > 0) &&\n      _rl_last_c_pos == prompt_physical_chars)\n    cpos_adjusted = 1;\n#endif\n\n   \n  lendiff = (nls - nfd) - (ols - ofd);\n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    {\n      int newchars, newwidth, newind;\n      int oldchars, oldwidth, oldind;\n\n      newchars = nls - new;\n      oldchars = ols - old;\n\n       \n      if (current_line == 0 && nfd == new && newchars > prompt_last_invisible &&\n\t  newchars <= local_prompt_len &&\n\t  local_prompt_len <= nmax &&\n\t  current_invis_chars != visible_wrap_offset)\n\t{\n\t  while (newchars < nmax && oldchars < omax &&  newchars < local_prompt_len)\n\t    {\n#if defined (HANDLE_MULTIBYTE)\n\t      newind = _rl_find_next_mbchar (new, newchars, 1, MB_FIND_NONZERO);\n\t      oldind = _rl_find_next_mbchar (old, oldchars, 1, MB_FIND_NONZERO);\n\n\t      nls += newind - newchars;\n\t      ols += oldind - oldchars;\n\n\t      newchars = newind;\n\t      oldchars = oldind;\n#else\n\t      nls++; ols++;\n\t      newchars++; oldchars++;\n#endif\n\t    }\n\t  newwidth = (newchars == local_prompt_len) ? prompt_physical_chars + wrap_offset\n\t  \t\t\t\t\t    : _rl_col_width (new, 0, nls - new, 1);\n\t   \n\t  lendiff = (nls - nfd) - (ols - ofd);\n\n\t  nlsf = new_face + (nls - new);\n\t  olsf = old_face + (ols - old);\n\t}\n      else\n\tnewwidth = _rl_col_width (new, nfd - new, nls - new, 1);\n\n      oldwidth = _rl_col_width (old, ofd - old, ols - old, 1);\n\n      col_lendiff = newwidth - oldwidth;\n    }\n  else\n    col_lendiff = lendiff;\n\n   \n     \n   \n  if (current_line == 0 && current_invis_chars != visible_wrap_offset)\n    {\n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  lendiff += visible_wrap_offset - current_invis_chars;\n\t  col_lendiff += visible_wrap_offset - current_invis_chars;\n\t}\n      else\n\t{\n\t  lendiff += visible_wrap_offset - current_invis_chars;\n\t  col_lendiff = lendiff;\n\t}\n    }\n\n   \n   \n  temp = ne - nfd;\n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    col_temp = _rl_col_width (new, nfd - new, ne - new, 1);\n  else\n    col_temp = temp;\n\n   \n  bytes_to_insert = nls - nfd;\n\n   \n  if (col_lendiff > 0)\t \n    {\n       \n      int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;\n\n       \n      if (lendiff < 0)\n\t{\n\t  puts_face (nfd, nfdf, temp);\n\t  _rl_last_c_pos += col_temp;\n\t   \n\t  if (current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n\t    ADJUST_CPOS (wrap_offset);\t \n\t  return;\n\t}\n       \n      else if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))\n\t{\n\t   \n\t   \n\t  if (*ols && ((_rl_horizontal_scroll_mode &&\n\t\t\t_rl_last_c_pos == 0 &&\n\t\t\tlendiff > prompt_visible_length &&\n\t\t\tcurrent_invis_chars > 0) == 0) &&\n\t\t      (((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\t        current_line == 0 && wrap_offset &&\n\t\t        ((nfd - new) <= prompt_last_invisible) &&\n\t\t        (col_lendiff < prompt_visible_length)) == 0) &&\n\t\t      (visible_wrap_offset >= current_invis_chars))\n\t    {\n\t      open_some_spaces (col_lendiff);\n\t      puts_face (nfd, nfdf, bytes_to_insert);\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t_rl_last_c_pos += _rl_col_width (nfd, 0, bytes_to_insert, 1);\n\t      else\n\t\t_rl_last_c_pos += bytes_to_insert;\n\t    }\n\t  else if ((mb_cur_max == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)\n\t    {\n\t       \n\t      puts_face (nfd, nfdf, temp);\n\t      _rl_last_c_pos += col_temp;\n\t      return;\n\t    }\n\t  else\t \n\t    {\n\t      puts_face (nfd, nfdf, temp);\n\t      _rl_last_c_pos += col_temp;\n\t       \n\t      if ((mb_cur_max > 1 && rl_byte_oriented == 0) && current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n\t\tADJUST_CPOS (wrap_offset);\t \n\t      return;\n\t    }\n\n\t  if (bytes_to_insert > lendiff)\n\t    {\n\t       \n\t      if ((mb_cur_max > 1 && rl_byte_oriented == 0) && current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n\t\tADJUST_CPOS (wrap_offset);\t \n\t    }\n\t}\n      else\n\t{\n\t   \n\t  puts_face (nfd, nfdf, temp);\n\t  _rl_last_c_pos += col_temp;\n\t   \n\t   \n\t  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\tcurrent_line == prompt_last_screen_line && wrap_offset &&\n\t\tdisplaying_prompt_first_line &&\n\t\twrap_offset != prompt_invis_chars_first_line &&\n\t\t((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth+prompt_invis_chars_first_line))))\n\t    ADJUST_CPOS (wrap_offset - prompt_invis_chars_first_line);\n\n\t   \n\t  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n\t\tcurrent_line == 0 && wrap_offset &&\n\t\tdisplaying_prompt_first_line &&\n\t\twrap_offset == prompt_invis_chars_first_line &&\n\t\tvisible_wrap_offset != current_invis_chars &&\n\t\tvisible_wrap_offset != prompt_invis_chars_first_line &&\n\t\t((nfd-new) < prompt_last_invisible))\n\t    ADJUST_CPOS (prompt_invis_chars_first_line);\n\t}\n    }\n  else\t\t\t\t \n    {\n       \n      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)\n\t{\n\t   \n\t  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&\n\t      displaying_prompt_first_line &&\n\t      -lendiff == visible_wrap_offset)\n\t    col_lendiff = 0;\n\n\t   \n\t  if (_rl_horizontal_scroll_mode && displaying_prompt_first_line == 0 &&\n\t\tcol_lendiff && _rl_last_c_pos < -col_lendiff)\n\t    col_lendiff = 0;\n\n\t  if (col_lendiff)\n\t    delete_chars (-col_lendiff);  \n\n\t   \n\t  if (bytes_to_insert > 0)\n\t    {\n\t       \n\t      puts_face (nfd, nfdf, bytes_to_insert);\n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t{\n\t\t   \n\t\t  _rl_last_c_pos += _rl_col_width (nfd, 0, bytes_to_insert, 1);\n\t\t  if (current_line == 0 && wrap_offset &&\n\t\t\tdisplaying_prompt_first_line &&\n\t\t\tprompt_invis_chars_first_line &&\n\t\t\t_rl_last_c_pos >= prompt_invis_chars_first_line &&\n\t\t\t((nfd - new) <= prompt_last_invisible))\n\t\t    ADJUST_CPOS (prompt_invis_chars_first_line);\n\n#if 1\n#ifdef HANDLE_MULTIBYTE\n\t\t   \n\t\t   \n\t\t  if (_rl_last_c_pos == _rl_screenwidth &&\n\t\t\tline_state_invisible->wrapped_line[current_line+1] &&\n\t\t\tnfd[bytes_to_insert-1] != ' ')\n\t\t    line_state_invisible->wrapped_line[current_line+1] = 0;\n#endif\n#endif\n\t\t}\n\t      else\n\t\t_rl_last_c_pos += bytes_to_insert;\n\n\t       \n\t      if (_rl_horizontal_scroll_mode && ((oe-old) > (ne-new)))\n\t\t{\n\t\t  _rl_move_cursor_relative (ne-new, new, new_face);\n\t\t  goto clear_rest_of_line;\n\t\t}\n\t    }\n\t}\n       \n      else\n\t{\n\t  if (temp > 0)\n\t    {\n\t       \n\t      puts_face (nfd, nfdf, temp);\n\t      _rl_last_c_pos += col_temp;\t\t \n\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t\t{\n\t\t  if (current_line == 0 && wrap_offset &&\n\t\t\tdisplaying_prompt_first_line &&\n\t\t\t_rl_last_c_pos > wrap_offset &&\n\t\t\t((nfd - new) <= prompt_last_invisible))\n\t\t    ADJUST_CPOS (wrap_offset);\t \n\t\t}\n\t    }\nclear_rest_of_line:\n\t  lendiff = (oe - old) - (ne - new);\n\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t    col_lendiff = _rl_col_width (old, 0, oe - old, 1) - _rl_col_width (new, 0, ne - new, 1);\n\t  else\n\t    col_lendiff = lendiff;\n\n\t   \n\t  if (col_lendiff && ((mb_cur_max == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))\n\t    {\t  \n\t      if (_rl_term_autowrap && current_line < inv_botlin)\n\t\tspace_to_eol (col_lendiff);\n\t      else\n\t\t_rl_clear_to_eol (col_lendiff);\n\t    }\n\t}\n    }\n}\n\n \nint\nrl_on_new_line (void)\n{\n  if (visible_line)\n    visible_line[0] = '\\0';\n\n  _rl_last_c_pos = _rl_last_v_pos = 0;\n  _rl_vis_botlin = last_lmargin = 0;\n  if (vis_lbreaks)\n    vis_lbreaks[0] = vis_lbreaks[1] = 0;\n  visible_wrap_offset = 0;\n  return 0;\n}\n\n \nint\nrl_clear_visible_line (void)\n{\n  int curr_line;\n\n   \n  _rl_cr ();\n  _rl_last_c_pos = 0;\n\n   \n  _rl_move_vert (_rl_vis_botlin);\n\n   \n  for (curr_line = _rl_last_v_pos; curr_line >= 0; curr_line--)\n    {\n      _rl_move_vert (curr_line);\n      _rl_clear_to_eol (_rl_screenwidth);\n      _rl_cr ();\t\t \n    }\n\n  return 0;\n}\n\n \nint\nrl_on_new_line_with_prompt (void)\n{\n  int prompt_size, i, l, real_screenwidth, newlines;\n  char *prompt_last_line, *lprompt;\n\n   \n  prompt_size = strlen (rl_prompt) + 1;\n  init_line_structures (prompt_size);\n\n   \n  lprompt = local_prompt ? local_prompt : rl_prompt;\n  strcpy (visible_line, lprompt);\n  strcpy (invisible_line, lprompt);\n\n   \n  prompt_last_line = strrchr (rl_prompt, '\\n');\n  if (!prompt_last_line)\n    prompt_last_line = rl_prompt;\n\n  l = strlen (prompt_last_line);\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    _rl_last_c_pos = _rl_col_width (prompt_last_line, 0, l, 1);\t \n  else\n    _rl_last_c_pos = l;\n\n   \n  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);\n  _rl_last_v_pos = l / real_screenwidth;\n   \n  if (l > 0 && (l % real_screenwidth) == 0)\n    _rl_output_some_chars (\"\\n\", 1);\n  last_lmargin = 0;\n\n  newlines = 0; i = 0;\n  while (i <= l)\n    {\n      _rl_vis_botlin = newlines;\n      vis_lbreaks[newlines++] = i;\n      i += real_screenwidth;\n    }\n  vis_lbreaks[newlines] = l;\n  visible_wrap_offset = 0;\n\n  rl_display_prompt = rl_prompt;\t \n\n  return 0;\n}\n\n \nint\nrl_forced_update_display (void)\n{\n  register char *temp;\n\n  if (visible_line)\n    {\n      temp = visible_line;\n      while (*temp)\n\t*temp++ = '\\0';\n    }\n  rl_on_new_line ();\n  forced_display++;\n  (*rl_redisplay_function) ();\n  return 0;\n}\n\n \nvoid\nrl_redraw_prompt_last_line (void)\n{\n  char *t;\n\n  t = strrchr (rl_display_prompt, '\\n');\n  if (t)\n    redraw_prompt (++t);\n  else\n    rl_forced_update_display ();\n}\n\n \nstatic void\n_rl_move_cursor_relative (int new, const char *data, const char *dataf)\n{\n  register int i;\n  int woff;\t\t\t \n  int cpos, dpos;\t\t \n  int adjust;\n  int in_invisline;\n  int mb_cur_max = MB_CUR_MAX;\n\n  woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);\n  cpos = _rl_last_c_pos;\n\n  if (cpos == 0 && cpos == new)\n    return;\n\n#if defined (HANDLE_MULTIBYTE)\n   \n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    {\n      adjust = 1;\n       \n       \n      if (new == local_prompt_len && memcmp (data, local_prompt, new) == 0)\n\t{\n\t  dpos = prompt_physical_chars;\n\t  cpos_adjusted = 1;\n\t  adjust = 0;\n\t}\n       \n      else if (new > local_prompt_len && local_prompt && memcmp (data, local_prompt, local_prompt_len) == 0)\n\t{\n\t  dpos = prompt_physical_chars + _rl_col_width (data, local_prompt_len, new, 1);\n\t  cpos_adjusted = 1;\n\t  adjust = 0;\n\t}\n      else\n        dpos = _rl_col_width (data, 0, new, 1);\n\n      if (displaying_prompt_first_line == 0)\n\tadjust = 0;\n\n       \n      in_invisline = 0;\n      if (data > invisible_line && data < invisible_line+inv_lbreaks[_rl_inv_botlin+1])\n\tin_invisline = data - invisible_line;\n\n       \n       \n      if (adjust && ((new > prompt_last_invisible) ||\t\t \n\t\t     (new+in_invisline > prompt_last_invisible) ||\t \n\t  (prompt_physical_chars >= _rl_screenwidth &&\t\t \n\t   _rl_last_v_pos == prompt_last_screen_line &&\n\t   wrap_offset >= woff && dpos >= woff &&\n\t   new > (prompt_last_invisible-(vis_lbreaks[_rl_last_v_pos])-wrap_offset))))\n\t    \n\t{\n\t  dpos -= woff;\n\t   \n\t  cpos_adjusted = 1;\n\t}\n    }\n  else\n#endif\n    dpos = new;\n\n   \n  if (cpos == dpos)\n    return;\n\n   \n   \n#if defined (HANDLE_MULTIBYTE)\n  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n    i = _rl_last_c_pos;\n  else\n#endif\n  i = _rl_last_c_pos - woff;\n  if (dpos == 0 || CR_FASTER (dpos, _rl_last_c_pos) ||\n      (_rl_term_autowrap && i == _rl_screenwidth))\n    {\n      _rl_cr ();\n      cpos = _rl_last_c_pos = 0;\n    }\n\n  if (cpos < dpos)\n    {\n       \n\n       \n\n       \n      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n\t{\n\t  if (_rl_term_forward_char)\n\t    {\n\t      for (i = cpos; i < dpos; i++)\n\t        tputs (_rl_term_forward_char, 1, _rl_output_character_function);\n\t    }\n\t  else\n\t    {\n\t      _rl_cr ();\n\t      puts_face (data, dataf, new);\n\t    }\n\t}\n      else\n\tputs_face (data + cpos, dataf + cpos, new - cpos);\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n   \n#endif\n  else if (cpos > dpos)\n    _rl_backspace (cpos - dpos);\n\n  _rl_last_c_pos = dpos;\n}\n\n \nvoid\n_rl_move_vert (int to)\n{\n  register int delta, i;\n\n  if (_rl_last_v_pos == to || to > _rl_screenheight)\n    return;\n\n  if ((delta = to - _rl_last_v_pos) > 0)\n    {\n      for (i = 0; i < delta; i++)\n\tputc ('\\n', rl_outstream);\n      _rl_cr ();\n      _rl_last_c_pos = 0;\n    }\n  else\n    {\t\t\t \n#ifdef __DJGPP__\n      int row, col;\n\n      fflush (rl_outstream);\n      ScreenGetCursor (&row, &col);\n      ScreenSetCursor (row + delta, col);\n      i = -delta;\n#else\n      if (_rl_term_up && *_rl_term_up)\n\tfor (i = 0; i < -delta; i++)\n\t  tputs (_rl_term_up, 1, _rl_output_character_function);\n#endif  \n    }\n\n  _rl_last_v_pos = to;\t\t \n}\n\n \nint\nrl_show_char (int c)\n{\n  int n = 1;\n  if (META_CHAR (c) && (_rl_output_meta_chars == 0))\n    {\n      fprintf (rl_outstream, \"M-\");\n      n += 2;\n      c = UNMETA (c);\n    }\n\n#if defined (DISPLAY_TABS)\n  if ((CTRL_CHAR (c) && c != '\\t') || c == RUBOUT)\n#else\n  if (CTRL_CHAR (c) || c == RUBOUT)\n#endif  \n    {\n      fprintf (rl_outstream, \"C-\");\n      n += 2;\n      c = CTRL_CHAR (c) ? UNCTRL (c) : '?';\n    }\n\n  putc (c, rl_outstream);\n  fflush (rl_outstream);\n  return n;\n}\n\nint\nrl_character_len (int c, int pos)\n{\n  unsigned char uc;\n\n  uc = (unsigned char)c;\n\n  if (META_CHAR (uc))\n    return ((_rl_output_meta_chars == 0) ? 4 : 1);\n\n  if (uc == '\\t')\n    {\n#if defined (DISPLAY_TABS)\n      return (((pos | 7) + 1) - pos);\n#else\n      return (2);\n#endif  \n    }\n\n  if (CTRL_CHAR (c) || c == RUBOUT)\n    return (2);\n\n  return ((ISPRINT (uc)) ? 1 : 2);\n}\n \nstatic int msg_saved_prompt = 0;\n\n#if defined (USE_VARARGS)\nint\n#if defined (PREFER_STDARG)\nrl_message (const char *format, ...)\n#else\nrl_message (va_alist)\n     va_dcl\n#endif\n{\n  va_list args;\n#if defined (PREFER_VARARGS)\n  char *format;\n#endif\n#if defined (HAVE_VSNPRINTF)\n  int bneed;\n#endif\n\n#if defined (PREFER_STDARG)\n  va_start (args, format);\n#else\n  va_start (args);\n  format = va_arg (args, char *);\n#endif\n\n  if (msg_buf == 0)\n    msg_buf = xmalloc (msg_bufsiz = 128);\n\n#if defined (HAVE_VSNPRINTF)\n  bneed = vsnprintf (msg_buf, msg_bufsiz, format, args);\n  if (bneed >= msg_bufsiz - 1)\n    {\n      msg_bufsiz = bneed + 1;\n      msg_buf = xrealloc (msg_buf, msg_bufsiz);\n      va_end (args);\n\n#if defined (PREFER_STDARG)\n      va_start (args, format);\n#else\n      va_start (args);\n      format = va_arg (args, char *);\n#endif\n      vsnprintf (msg_buf, msg_bufsiz - 1, format, args);\n    }\n#else\n  vsprintf (msg_buf, format, args);\n  msg_buf[msg_bufsiz - 1] = '\\0';\t \n#endif\n  va_end (args);\n\n  if (saved_local_prompt == 0)\n    {\n      rl_save_prompt ();\n      msg_saved_prompt = 1;\n    }\n  else if (local_prompt != saved_local_prompt)\n    {\n      FREE (local_prompt);\n      FREE (local_prompt_prefix);\n      local_prompt = (char *)NULL;\n    }\n  rl_display_prompt = msg_buf;\n  local_prompt = expand_prompt (msg_buf, 0, &prompt_visible_length,\n\t\t\t\t\t    &prompt_last_invisible,\n\t\t\t\t\t    &prompt_invis_chars_first_line,\n\t\t\t\t\t    &prompt_physical_chars);\n  local_prompt_prefix = (char *)NULL;\n  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n  (*rl_redisplay_function) ();\n\n  return 0;\n}\n#else  \nint\nrl_message (format, arg1, arg2)\n     char *format;\n{\n  if (msg_buf == 0)\n    msg_buf = xmalloc (msg_bufsiz = 128);\n\n  sprintf (msg_buf, format, arg1, arg2);\n  msg_buf[msg_bufsiz - 1] = '\\0';\t \n\n  rl_display_prompt = msg_buf;\n  if (saved_local_prompt == 0)\n    {\n      rl_save_prompt ();\n      msg_saved_prompt = 1;\n    }\n  else if (local_prompt != saved_local_prompt)\n    {\n      FREE (local_prompt);\n      FREE (local_prompt_prefix);\n      local_prompt = (char *)NULL;\n    }\n  local_prompt = expand_prompt (msg_buf, 0, &prompt_visible_length,\n\t\t\t\t\t    &prompt_last_invisible,\n\t\t\t\t\t    &prompt_invis_chars_first_line,\n\t\t\t\t\t    &prompt_physical_chars);\n  local_prompt_prefix = (char *)NULL;\n  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n  (*rl_redisplay_function) ();\n      \n  return 0;\n}\n#endif  \n\n \nint\nrl_clear_message (void)\n{\n  rl_display_prompt = rl_prompt;\n  if (msg_saved_prompt)\n    {\n      rl_restore_prompt ();\n      msg_saved_prompt = 0;\n    }\n  (*rl_redisplay_function) ();\n  return 0;\n}\n\nint\nrl_reset_line_state (void)\n{\n  rl_on_new_line ();\n\n  rl_display_prompt = rl_prompt ? rl_prompt : \"\";\n  forced_display = 1;\n  return 0;\n}\n\n \nvoid\nrl_save_prompt (void)\n{\n  saved_local_prompt = local_prompt;\n  saved_local_prefix = local_prompt_prefix;\n  saved_prefix_length = prompt_prefix_length;\n  saved_local_length = local_prompt_len;\n  saved_last_invisible = prompt_last_invisible;\n  saved_visible_length = prompt_visible_length;\n  saved_invis_chars_first_line = prompt_invis_chars_first_line;\n  saved_physical_chars = prompt_physical_chars;\n  saved_local_prompt_newlines = local_prompt_newlines;\n\n  local_prompt = local_prompt_prefix = (char *)0;\n  local_prompt_len = 0;\n  local_prompt_newlines = (int *)0;\n\n  prompt_last_invisible = prompt_visible_length = prompt_prefix_length = 0;\n  prompt_invis_chars_first_line = prompt_physical_chars = 0;\n}\n\nvoid\nrl_restore_prompt (void)\n{\n  FREE (local_prompt);\n  FREE (local_prompt_prefix);\n  FREE (local_prompt_newlines);\n\n  local_prompt = saved_local_prompt;\n  local_prompt_prefix = saved_local_prefix;\n  local_prompt_len = saved_local_length;\n  local_prompt_newlines = saved_local_prompt_newlines;\n\n  prompt_prefix_length = saved_prefix_length;\n  prompt_last_invisible = saved_last_invisible;\n  prompt_visible_length = saved_visible_length;\n  prompt_invis_chars_first_line = saved_invis_chars_first_line;\n  prompt_physical_chars = saved_physical_chars;\n\n   \n  saved_local_prompt = saved_local_prefix = (char *)0;\n  saved_local_length = 0;\n  saved_last_invisible = saved_visible_length = saved_prefix_length = 0;\n  saved_invis_chars_first_line = saved_physical_chars = 0;\n  saved_local_prompt_newlines = 0;\n}\n\nchar *\n_rl_make_prompt_for_search (int pchar)\n{\n  int len;\n  char *pmt, *p;\n\n  rl_save_prompt ();\n\n   \n  p = rl_prompt ? strrchr (rl_prompt, '\\n') : 0;\n  if (p == 0)\n    {\n      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;\n      pmt = (char *)xmalloc (len + 2);\n      if (len)\n\tstrcpy (pmt, rl_prompt);\n      pmt[len] = pchar;\n      pmt[len+1] = '\\0';\n    }\n  else\n    {\n      p++;\n      len = strlen (p);\n      pmt = (char *)xmalloc (len + 2);\n      if (len)\n\tstrcpy (pmt, p);\n      pmt[len] = pchar;\n      pmt[len+1] = '\\0';\n    }  \n\n   \n  prompt_physical_chars = saved_physical_chars + 1;\n  return pmt;\n}\n\n \nvoid\n_rl_erase_at_end_of_line (int l)\n{\n  register int i;\n\n  _rl_backspace (l);\n  for (i = 0; i < l; i++)\n    putc (' ', rl_outstream);\n  _rl_backspace (l);\n  for (i = 0; i < l; i++)\n    visible_line[--_rl_last_c_pos] = '\\0';\n  rl_display_fixed++;\n}\n\n \nvoid\n_rl_clear_to_eol (int count)\n{\n#ifndef __MSDOS__\n  if (_rl_term_clreol)\n    tputs (_rl_term_clreol, 1, _rl_output_character_function);\n  else\n#endif\n    if (count)\n      space_to_eol (count);\n}\n\n \nstatic void\nspace_to_eol (int count)\n{\n  register int i;\n\n  for (i = 0; i < count; i++)\n    putc (' ', rl_outstream);\n\n  _rl_last_c_pos += count;\n}\n\nvoid\n_rl_clear_screen (int clrscr)\n{\n#if defined (__DJGPP__)\n  ScreenClear ();\n  ScreenSetCursor (0, 0);\n#else\n  if (_rl_term_clrpag)\n    {\n      tputs (_rl_term_clrpag, 1, _rl_output_character_function);\n      if (clrscr && _rl_term_clrscroll)\n\ttputs (_rl_term_clrscroll, 1, _rl_output_character_function);\n    }\n  else\n    rl_crlf ();\n#endif  \n}\n\n \nstatic void\ninsert_some_chars (char *string, int count, int col)\n{\n  open_some_spaces (col);\n  _rl_output_some_chars (string, count);\n}\n\n \nstatic void\nopen_some_spaces (int col)\n{\n#if !defined (__MSDOS__) && (!defined (__MINGW32__) || defined (NCURSES_VERSION))\n  char *buffer;\n  register int i;\n\n   \n  if (_rl_term_IC)\n    {\n      buffer = tgoto (_rl_term_IC, 0, col);\n      tputs (buffer, 1, _rl_output_character_function);\n    }\n  else if (_rl_term_im && *_rl_term_im)\n    {\n      tputs (_rl_term_im, 1, _rl_output_character_function);\n       \n      for (i = col; i--; )\n\t_rl_output_character_function (' ');\n       \n      if (_rl_term_ei && *_rl_term_ei)\n\ttputs (_rl_term_ei, 1, _rl_output_character_function);\n       \n      _rl_backspace (col);\n    }\n  else if (_rl_term_ic && *_rl_term_ic)\n    {\n       \n      for (i = col; i--; )\n\ttputs (_rl_term_ic, 1, _rl_output_character_function);\n    }\n#endif  \n}\n\n \nstatic void\ndelete_chars (int count)\n{\n  if (count > _rl_screenwidth)\t \n    return;\n\n#if !defined (__MSDOS__) && (!defined (__MINGW32__) || defined (NCURSES_VERSION))\n  if (_rl_term_DC && *_rl_term_DC)\n    {\n      char *buffer;\n      buffer = tgoto (_rl_term_DC, count, count);\n      tputs (buffer, count, _rl_output_character_function);\n    }\n  else\n    {\n      if (_rl_term_dc && *_rl_term_dc)\n\twhile (count--)\n\t  tputs (_rl_term_dc, 1, _rl_output_character_function);\n    }\n#endif  \n}\n\nvoid\n_rl_update_final (void)\n{\n  int full_lines, woff, botline_length;\n\n  if (line_structures_initialized == 0)\n    return;\n\n  full_lines = 0;\n   \n  if (_rl_vis_botlin && _rl_last_c_pos == 0 &&\n\tvisible_line[vis_lbreaks[_rl_vis_botlin]] == 0)\n    {\n      _rl_vis_botlin--;\n      full_lines = 1;\n    }\n  _rl_move_vert (_rl_vis_botlin);\n  woff = W_OFFSET(_rl_vis_botlin, wrap_offset);\n  botline_length = VIS_LLEN(_rl_vis_botlin) - woff;\n   \n  if (full_lines && _rl_term_autowrap && botline_length == _rl_screenwidth)\n    {\n      char *last_line, *last_face;\n\n       \n      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];  \n      last_face = &vis_face[vis_lbreaks[_rl_vis_botlin]];  \n      cpos_buffer_position = -1;\t \n      _rl_move_cursor_relative (_rl_screenwidth - 1 + woff, last_line, last_face);\t \n      _rl_clear_to_eol (0);\n      puts_face (&last_line[_rl_screenwidth - 1 + woff],\n\t\t &last_face[_rl_screenwidth - 1 + woff], 1);\n    }\n  _rl_vis_botlin = 0;\n  if (botline_length > 0 || _rl_last_c_pos > 0)\n    rl_crlf ();\n  fflush (rl_outstream);\n  rl_display_fixed++;\n}\n\n \nstatic void\ncr (void)\n{\n  _rl_cr ();\n  _rl_last_c_pos = 0;\n}\n\n \nstatic void\nredraw_prompt (char *t)\n{\n  char *oldp;\n\n  oldp = rl_display_prompt;\n  rl_save_prompt ();\n\n  rl_display_prompt = t;\n  local_prompt = expand_prompt (t, PMT_MULTILINE,\n\t\t\t\t   &prompt_visible_length,\n\t\t\t\t   &prompt_last_invisible,\n\t\t\t\t   &prompt_invis_chars_first_line,\n\t\t\t\t   &prompt_physical_chars);\n  local_prompt_prefix = (char *)NULL;\n  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n\n  rl_forced_update_display ();\n\n  rl_display_prompt = oldp;\n  rl_restore_prompt();\n}\n      \n \nvoid\n_rl_redisplay_after_sigwinch (void)\n{\n  char *t;\n\n   \n  if (_rl_term_cr)\n    {\n      rl_clear_visible_line ();\n      if (_rl_last_v_pos > 0)\n\t_rl_move_vert (0);\n    }\n  else\n    rl_crlf ();\n\n  if (_rl_screenwidth < prompt_visible_length)\n    _rl_reset_prompt ();\t\t \n\n   \n  t = strrchr (rl_display_prompt, '\\n');\n  if (t)\n    redraw_prompt (++t);\n  else\n    rl_forced_update_display ();\n}\n\nvoid\n_rl_clean_up_for_exit (void)\n{\n  if (_rl_echoing_p)\n    {\n      if (_rl_vis_botlin > 0)\t \n\t_rl_move_vert (_rl_vis_botlin);\n      _rl_vis_botlin = 0;\n      fflush (rl_outstream);\n      rl_restart_output (1, 0);\n    }\n}\n\nvoid\n_rl_erase_entire_line (void)\n{\n  cr ();\n  _rl_clear_to_eol (0);\n  cr ();\n  fflush (rl_outstream);\n}\n\nvoid\n_rl_ttyflush (void)\n{\n  fflush (rl_outstream);\n}\n\n \nint\n_rl_current_display_line (void)\n{\n  int ret, nleft;\n\n   \n  if (rl_display_prompt == rl_prompt)\n    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;\n  else\n    nleft = _rl_last_c_pos - _rl_screenwidth;\n\n  if (nleft > 0)\n    ret = 1 + nleft / _rl_screenwidth;\n  else\n    ret = 0;\n\n  return ret;\n}\n\nvoid\n_rl_refresh_line (void)\n{\n  rl_clear_visible_line ();\n  rl_redraw_prompt_last_line ();\n  rl_keep_mark_active ();\n}\n\n#if defined (HANDLE_MULTIBYTE)\n \nstatic int\n_rl_col_width (const char *str, int start, int end, int flags)\n{\n  WCHAR_T wc;\n  mbstate_t ps;\n  int tmp, point, width, max;\n\n  if (end <= start)\n    return 0;\n  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n     \n    return (end - start);\n\n  memset (&ps, 0, sizeof (mbstate_t));\n\n  point = 0;\n  max = end;\n\n   \n   \n  if (flags && start == 0 && end == local_prompt_len && memcmp (str, local_prompt, local_prompt_len) == 0)\n    return (prompt_physical_chars + wrap_offset);\n   \n  else if (flags && start == 0 && local_prompt_len > 0 && end > local_prompt_len && local_prompt && memcmp (str, local_prompt, local_prompt_len) == 0)\n    {\n      tmp = prompt_physical_chars + wrap_offset;\n       \n      tmp += _rl_col_width (str, local_prompt_len, end, flags);\n      return (tmp);\n    }\n\n  while (point < start)\n    {\n      if (_rl_utf8locale && UTF8_SINGLEBYTE(str[point]))\n\t{\n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t  tmp = 1;\n\t}\n      else\n\ttmp = mbrlen (str + point, max, &ps);\n      if (MB_INVALIDCH ((size_t)tmp))\n\t{\n\t   \n\t  point++;\n\t  max--;\n\n\t   \n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t}\n      else if (MB_NULLWCH (tmp))\n\tbreak;\t\t \n      else\n\t{\n\t  point += tmp;\n\t  max -= tmp;\n\t}\n    }\n\n   \n  width = point - start;\n\n  while (point < end)\n    {\n      if (_rl_utf8locale && UTF8_SINGLEBYTE(str[point]))\n\t{\n\t  tmp = 1;\n\t  wc = (WCHAR_T) str[point];\n\t}\n      else\n\ttmp = MBRTOWC (&wc, str + point, max, &ps);\n      if (MB_INVALIDCH ((size_t)tmp))\n\t{\n\t   \n\t  point++;\n\t  max--;\n\n\t   \n\t  width++;\n\n\t   \n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t}\n      else if (MB_NULLWCH (tmp))\n\tbreak;\t\t\t \n      else\n\t{\n\t  point += tmp;\n\t  max -= tmp;\n\t  tmp = WCWIDTH(wc);\n\t  width += (tmp >= 0) ? tmp : 1;\n\t}\n    }\n\n  width += point - end;\n\n  return width;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}