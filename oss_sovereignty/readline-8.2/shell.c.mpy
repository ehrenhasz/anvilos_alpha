{
  "module_name": "shell.c",
  "hash_id": "fe42d4d3d838c2a82dbecd8d43596e3d339e63e159e0fca76dc9b637e31e807f",
  "original_prompt": "Ingested from readline-8.2/shell.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_STRING_H)\n#  include <string.h>\n#else\n#  include <strings.h>\n#endif  \n\n#if defined (HAVE_LIMITS_H)\n#  include <limits.h>\n#endif\n\n#if defined (HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#if defined (HAVE_PWD_H)\n#include <pwd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"rlstdc.h\"\n#include \"rlshell.h\"\n#include \"rldefs.h\"\n\n#include \"xmalloc.h\"\n\n#if defined (HAVE_GETPWUID) && !defined (HAVE_GETPW_DECLS)\nextern struct passwd *getpwuid (uid_t);\n#endif  \n\n#ifndef NULL\n#  define NULL 0\n#endif\n\n#ifndef CHAR_BIT\n#  define CHAR_BIT 8\n#endif\n\n \n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n \n#define INT_STRLEN_BOUND(t) \\\n  ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 \\\n   + 1 + TYPE_SIGNED (t))\n\n \n\n \nchar *\nsh_single_quote (char *string)\n{\n  register int c;\n  char *result, *r, *s;\n\n  result = (char *)xmalloc (3 + (4 * strlen (string)));\n  r = result;\n  *r++ = '\\'';\n\n  for (s = string; s && (c = *s); s++)\n    {\n      *r++ = c;\n\n      if (c == '\\'')\n\t{\n\t  *r++ = '\\\\';\t \n\t  *r++ = '\\'';\n\t  *r++ = '\\'';\t \n\t}\n    }\n\n  *r++ = '\\'';\n  *r = '\\0';\n\n  return (result);\n}\n\n \nstatic char setenv_buf[INT_STRLEN_BOUND (int) + 1];\nstatic char putenv_buf1[INT_STRLEN_BOUND (int) + 6 + 1];\t \nstatic char putenv_buf2[INT_STRLEN_BOUND (int) + 8 + 1];\t \n\nvoid\nsh_set_lines_and_columns (int lines, int cols)\n{\n#if defined (HAVE_SETENV)\n  sprintf (setenv_buf, \"%d\", lines);\n  setenv (\"LINES\", setenv_buf, 1);\n\n  sprintf (setenv_buf, \"%d\", cols);\n  setenv (\"COLUMNS\", setenv_buf, 1);\n#else  \n#  if defined (HAVE_PUTENV)\n  sprintf (putenv_buf1, \"LINES=%d\", lines);\n  putenv (putenv_buf1);\n\n  sprintf (putenv_buf2, \"COLUMNS=%d\", cols);\n  putenv (putenv_buf2);\n#  endif  \n#endif  \n}\n\nchar *\nsh_get_env_value (const char *varname)\n{\n  return ((char *)getenv (varname));\n}\n\nchar *\nsh_get_home_dir (void)\n{\n  static char *home_dir = (char *)NULL;\n  struct passwd *entry;\n\n  if (home_dir)\n    return (home_dir);\n\n  home_dir = (char *)NULL;\n#if defined (HAVE_GETPWUID)\n#  if defined (__TANDEM)\n  entry = getpwnam (getlogin ());\n#  else\n  entry = getpwuid (getuid ());\n#  endif\n  if (entry)\n    home_dir = savestring (entry->pw_dir);\n#endif\n\n#if defined (HAVE_GETPWENT)\n  endpwent ();\t\t \n#endif\n\n  return (home_dir);\n}\n\n#if !defined (O_NDELAY)\n#  if defined (FNDELAY)\n#    define O_NDELAY FNDELAY\n#  endif\n#endif\n\nint\nsh_unset_nodelay_mode (int fd)\n{\n#if defined (HAVE_FCNTL)\n  int flags, bflags;\n\n  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)\n    return -1;\n\n  bflags = 0;\n\n#ifdef O_NONBLOCK\n  bflags |= O_NONBLOCK;\n#endif\n\n#ifdef O_NDELAY\n  bflags |= O_NDELAY;\n#endif\n\n  if (flags & bflags)\n    {\n      flags &= ~bflags;\n      return (fcntl (fd, F_SETFL, flags));\n    }\n#endif\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}