{
  "module_name": "vi_mode.c",
  "hash_id": "218c6ed779d3b32f561b42a9061866fdf1e03d97628f0f029643fb4353b8ad6c",
  "original_prompt": "Ingested from readline-8.2/vi_mode.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n \n \n \n \n \n#include \"rlconf.h\"\n\n#if defined (VI_MODE)\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n#ifndef member\n#define member(c, s) ((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)\n#endif\n\n \n#if defined (HANDLE_MULTIBYTE)\n#define INCREMENT_POS(start) \\\n  do { \\\n\tif (MB_CUR_MAX == 1 || rl_byte_oriented) \\\n\t  start++; \\\n\telse \\\n\t  start = _rl_find_next_mbchar (rl_line_buffer, start, 1, MB_FIND_ANY); \\\n  } while (0)\n#else  \n#define INCREMENT_POS(start)    (start)++\n#endif  \n\n \nint _rl_vi_last_command = 'i';\t \n\n_rl_vimotion_cxt *_rl_vimvcxt = 0;\n\n \nint _rl_vi_redoing;\n\n \nstatic int _rl_vi_doing_insert;\n\n \nstatic const char * const vi_motion = \" hl^$0ftFT;,%wbeWBE|`\";\n\n \nstatic Keymap vi_replace_map;\n\n \nstatic int vi_replace_count;\n\n \nstatic int vi_continued_command;\nstatic char *vi_insert_buffer;\nstatic int vi_insert_buffer_size;\n\nstatic int _rl_vi_last_repeat = 1;\nstatic int _rl_vi_last_arg_sign = 1;\nstatic int _rl_vi_last_motion;\n#if defined (HANDLE_MULTIBYTE)\nstatic char _rl_vi_last_search_mbchar[MB_LEN_MAX];\nstatic int _rl_vi_last_search_mblen;\n#else\nstatic int _rl_vi_last_search_char;\n#endif\nstatic char _rl_vi_last_replacement[MB_LEN_MAX+1];\t \n\nstatic int _rl_vi_last_key_before_insert;\n\n \nstatic const char * const vi_textmod = \"_*\\\\AaIiCcDdPpYyRrSsXx~\";\n\n \nstatic int vi_mark_chars['z' - 'a' + 1];\n\nstatic void _rl_vi_replace_insert (int);\nstatic void _rl_vi_save_replace (void);\nstatic void _rl_vi_stuff_insert (int);\nstatic void _rl_vi_save_insert (UNDO_LIST *);\n\nstatic void vi_save_insert_buffer (int, int);\n\nstatic inline void _rl_vi_backup (void);\n\nstatic int _rl_vi_arg_dispatch (int);\nstatic int rl_digit_loop1 (void);\n\nstatic int _rl_vi_set_mark (void);\nstatic int _rl_vi_goto_mark (void);\n\nstatic inline int _rl_vi_advance_point (void);\nstatic inline int _rl_vi_backup_point (void);\n\nstatic void _rl_vi_append_forward (int);\n\nstatic int _rl_vi_callback_getchar (char *, int);\n\n#if defined (READLINE_CALLBACKS)\nstatic int _rl_vi_callback_set_mark (_rl_callback_generic_arg *);\nstatic int _rl_vi_callback_goto_mark (_rl_callback_generic_arg *);\nstatic int _rl_vi_callback_change_char (_rl_callback_generic_arg *);\nstatic int _rl_vi_callback_char_search (_rl_callback_generic_arg *);\n#endif\n\nstatic int rl_domove_read_callback (_rl_vimotion_cxt *);\nstatic int rl_domove_motion_callback (_rl_vimotion_cxt *);\nstatic int rl_vi_domove_getchar (_rl_vimotion_cxt *);\n\nstatic int vi_change_dispatch (_rl_vimotion_cxt *);\nstatic int vi_delete_dispatch (_rl_vimotion_cxt *);\nstatic int vi_yank_dispatch (_rl_vimotion_cxt *);\n\nstatic int vidomove_dispatch (_rl_vimotion_cxt *);\n\nvoid\n_rl_vi_initialize_line (void)\n{\n  register int i, n;\n\n  n = sizeof (vi_mark_chars) / sizeof (vi_mark_chars[0]);\n  for (i = 0; i < n; i++)\n    vi_mark_chars[i] = -1;\n\n  RL_UNSETSTATE(RL_STATE_VICMDONCE);\n}\n\nvoid\n_rl_vi_reset_last (void)\n{\n  _rl_vi_last_command = 'i';\n  _rl_vi_last_repeat = 1;\n  _rl_vi_last_arg_sign = 1;\n  _rl_vi_last_motion = 0;\n}\n\nvoid\n_rl_vi_set_last (int key, int repeat, int sign)\n{\n  _rl_vi_last_command = key;\n  _rl_vi_last_repeat = repeat;\n  _rl_vi_last_arg_sign = sign;\n}\n\n \nvoid\nrl_vi_start_inserting (int key, int repeat, int sign)\n{\n  _rl_vi_set_last (key, repeat, sign);\n  rl_begin_undo_group ();\t\t \n  rl_vi_insertion_mode (1, key);\n}\n\n \nint\n_rl_vi_textmod_command (int c)\n{\n  return (member (c, vi_textmod));\n}\n\nint\n_rl_vi_motion_command (int c)\n{\n  return (member (c, vi_motion));\n}\n\nstatic void\n_rl_vi_replace_insert (int count)\n{\n  int nchars;\n\n  nchars = strlen (vi_insert_buffer);\n\n  rl_begin_undo_group ();\n  while (count--)\n     \n    _rl_replace_text (vi_insert_buffer, rl_point, rl_point+nchars-1);\n  rl_end_undo_group ();\n}\n\nstatic void\n_rl_vi_stuff_insert (int count)\n{\n  rl_begin_undo_group ();\n  while (count--)\n    rl_insert_text (vi_insert_buffer);\n  rl_end_undo_group ();\n}\n\n \nint\nrl_vi_redo (int count, int c)\n{\n  int r;\n\n  if (rl_explicit_arg == 0)\n    {\n      rl_numeric_arg = _rl_vi_last_repeat;\n      rl_arg_sign = _rl_vi_last_arg_sign;\n    }\n\n  r = 0;\n  _rl_vi_redoing = 1;\n   \n  if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)\n    {\n      _rl_vi_stuff_insert (count);\n       \n      if (rl_point > 0)\n\t_rl_vi_backup ();\n    }\n  else if (_rl_vi_last_command == 'R' && vi_insert_buffer && *vi_insert_buffer)\n    {\n      _rl_vi_replace_insert (count);\n       \n      if (rl_point > 0)\n\t_rl_vi_backup ();\n    }\n   \n  else if (_rl_vi_last_command == 'I' && vi_insert_buffer && *vi_insert_buffer)\n    {\n      rl_beg_of_line (1, 'I');\n      _rl_vi_stuff_insert (count);\n      if (rl_point > 0)\n\t_rl_vi_backup ();\n    }\n   \n  else if (_rl_vi_last_command == 'a' && vi_insert_buffer && *vi_insert_buffer)\n    {\n      _rl_vi_append_forward ('a');\n      _rl_vi_stuff_insert (count);\n      if (rl_point > 0)\n\t_rl_vi_backup ();\n    }\n   \n  else if (_rl_vi_last_command == 'A' && vi_insert_buffer && *vi_insert_buffer)\n    {\n      rl_end_of_line (1, 'A');\n      _rl_vi_stuff_insert (count);\n      if (rl_point > 0)\n\t_rl_vi_backup ();\n    }\n  else if (_rl_vi_last_command == '.' && _rl_keymap == vi_movement_keymap)\n    {\n      rl_ding ();\n      r = 0;\n    }\n  else\n    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);\n\n  _rl_vi_redoing = 0;\n\n  return (r);\n}\n\n \nint\nrl_vi_undo (int count, int key)\n{\n  return (rl_undo_command (count, key));\n}\n    \n \nint\nrl_vi_yank_arg (int count, int key)\n{\n   \n  if (rl_explicit_arg)\n    rl_yank_nth_arg (count - 1, key);\n  else\n    rl_yank_nth_arg ('$', key);\n\n  return (0);\n}\n\n \nint\nrl_vi_fetch_history (int count, int c)\n{\n  return (rl_fetch_history (count, c));\n}\n\n \nint\nrl_vi_search_again (int count, int key)\n{\n  switch (key)\n    {\n    case 'n':\n      rl_noninc_reverse_search_again (count, key);\n      break;\n\n    case 'N':\n      rl_noninc_forward_search_again (count, key);\n      break;\n    }\n  return (0);\n}\n\n \nint\nrl_vi_search (int count, int key)\n{\n  switch (key)\n    {\n    case '?':\n      _rl_free_saved_history_line ();\n      rl_noninc_forward_search (count, key);\n      break;\n\n    case '/':\n      _rl_free_saved_history_line ();\n      rl_noninc_reverse_search (count, key);\n      break;\n\n    default:\n      rl_ding ();\n      break;\n    }\n  return (0);\n}\n\n \nint\nrl_vi_complete (int ignore, int key)\n{\n  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))\n    {\n      if (!whitespace (rl_line_buffer[rl_point + 1]))\n\trl_vi_end_word (1, 'E');\n      _rl_vi_advance_point ();\n    }\n\n  if (key == '*')\n    rl_complete_internal ('*');\t \n  else if (key == '=')\n    rl_complete_internal ('?');\t \n  else if (key == '\\\\')\n    rl_complete_internal (TAB);\t \n  else\n    rl_complete (0, key);\n\n  if (key == '*' || key == '\\\\')\n    rl_vi_start_inserting (key, 1, rl_arg_sign);\n\n  return (0);\n}\n\n \nint\nrl_vi_tilde_expand (int ignore, int key)\n{\n  rl_tilde_expand (0, key);\n  rl_vi_start_inserting (key, 1, rl_arg_sign);\n  return (0);\n}\n\n \nint\nrl_vi_prev_word (int count, int key)\n{\n  if (count < 0)\n    return (rl_vi_next_word (-count, key));\n\n  if (rl_point == 0)\n    {\n      rl_ding ();\n      return (0);\n    }\n\n  if (_rl_uppercase_p (key))\n    rl_vi_bWord (count, key);\n  else\n    rl_vi_bword (count, key);\n\n  return (0);\n}\n\n \nint\nrl_vi_next_word (int count, int key)\n{\n  if (count < 0)\n    return (rl_vi_prev_word (-count, key));\n\n  if (rl_point >= (rl_end - 1))\n    {\n      rl_ding ();\n      return (0);\n    }\n\n  if (_rl_uppercase_p (key))\n    rl_vi_fWord (count, key);\n  else\n    rl_vi_fword (count, key);\n  return (0);\n}\n\nstatic inline int\n_rl_vi_advance_point (void)\n{\n  int point;\n\n  point = rl_point;\n  if (rl_point < rl_end)\n#if defined (HANDLE_MULTIBYTE)\n    {\n      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n\trl_point++;\n      else\n\t{\n\t  point = rl_point;\n\t  rl_point = _rl_forward_char_internal (1);\n\t  if (point == rl_point || rl_point > rl_end)\n\t    rl_point = rl_end;\n\t}\n    }\n#else\n    rl_point++;\n#endif\n\n  return point;\n}\n\n \nstatic inline void\n_rl_vi_backup (void)\n{\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n  else\n    rl_point--;\n}\n\n \nstatic inline int\n_rl_vi_backup_point (void)\n{\n  int point;\n\n  point = rl_point;\n  if (rl_point > 0)\n#if defined (HANDLE_MULTIBYTE)\n    {\n      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n\trl_point--;\n      else\n\t{\n\t  point = rl_point;\n\t  rl_point = _rl_backward_char_internal (1);\n\t  if (rl_point < 0)\n\t    rl_point = 0;\t\t \n\t}\n    }\n#else\n    rl_point--;\n#endif\n  return point;\n}\n\n \nint\nrl_vi_end_word (int count, int key)\n{\n  if (count < 0)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  if (_rl_uppercase_p (key))\n    rl_vi_eWord (count, key);\n  else\n    rl_vi_eword (count, key);\n  return (0);\n}\n\n \nint\nrl_vi_fWord (int count, int ignore)\n{\n  while (count-- && rl_point < (rl_end - 1))\n    {\n       \n      while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n\t_rl_vi_advance_point ();\n\n       \n      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n\t_rl_vi_advance_point ();\n    }\n  return (0);\n}\n\nint\nrl_vi_bWord (int count, int ignore)\n{\n  while (count-- && rl_point > 0)\n    {\n       \n      if (!whitespace (rl_line_buffer[rl_point]) &&\n\t  whitespace (rl_line_buffer[rl_point - 1]))\n\trl_point--;\n\n      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))\n\t_rl_vi_backup_point ();\n\n      if (rl_point > 0)\n\t{\n\t  do\n\t    _rl_vi_backup_point ();\n\t  while (rl_point > 0 && !whitespace (rl_line_buffer[rl_point]));\n\t  if (rl_point > 0)\t \n\t    rl_point++;\t\t\n\n\t  if (rl_point < 0)\n\t    rl_point = 0;\n\t}\n    }\n  return (0);\n}\n\nint\nrl_vi_eWord (int count, int ignore)\n{\n  int opoint;\n\n  while (count-- && rl_point < (rl_end - 1))\n    {\n      if (whitespace (rl_line_buffer[rl_point]) == 0)\n\t_rl_vi_advance_point ();\n\n       \n      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n\t_rl_vi_advance_point ();\n\n      if (rl_point && rl_point < rl_end)\n\t{\n\t  opoint = rl_point;\n\n\t   \n\t  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n\t    opoint = _rl_vi_advance_point ();\t \n\n\t   \n\t  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))\n\t    opoint = _rl_vi_advance_point ();\n\n\t   \n\t  rl_point = opoint;\n\t}\n    }\n  return (0);\n}\n\nint\nrl_vi_fword (int count, int ignore)\n{\n  int opoint;\n\n  while (count-- && rl_point < (rl_end - 1))\n    {\n       \n      if (_rl_isident (rl_line_buffer[rl_point]))\n\t{\n\t  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)\n\t    _rl_vi_advance_point ();\n\t}\n      else  \n\t{\n\t  while (!_rl_isident (rl_line_buffer[rl_point]) &&\n\t\t !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n\t    _rl_vi_advance_point ();\n\t}\n\n      opoint = rl_point;\n\n       \n      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n\topoint = _rl_vi_advance_point ();\n    }\n  return (0);\n}\n\nint\nrl_vi_bword (int count, int ignore)\n{\n  int opoint;\n\n  while (count-- && rl_point > 0)\n    {\n      int prev_is_ident, cur_is_ident;\n\n       \n      if (!whitespace (rl_line_buffer[rl_point]) &&\n\t  whitespace (rl_line_buffer[rl_point - 1]))\n\tif (--rl_point == 0)\n\t  break;\n\n       \n      cur_is_ident = _rl_isident (rl_line_buffer[rl_point]);\n      opoint = _rl_vi_backup_point ();\n      prev_is_ident = _rl_isident (rl_line_buffer[rl_point]);\n      if ((cur_is_ident && !prev_is_ident) || (!cur_is_ident && prev_is_ident))\n\t;\t \n      else\n\trl_point = opoint;\n\n      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))\n\t_rl_vi_backup_point ();\n\n      if (rl_point > 0)\n\t{\n\t  opoint = rl_point;\n\t  if (_rl_isident (rl_line_buffer[rl_point]))\n\t    do\n\t      opoint = _rl_vi_backup_point ();\n\t    while (rl_point > 0 && _rl_isident (rl_line_buffer[rl_point]));\n\t  else\n\t    do\n\t      opoint = _rl_vi_backup_point ();\n\t    while (rl_point > 0 && !_rl_isident (rl_line_buffer[rl_point]) &&\n\t\t   !whitespace (rl_line_buffer[rl_point]));\n\n\t  if (rl_point > 0)\n\t    rl_point = opoint;\n\n\t  if (rl_point < 0)\n\t    rl_point = 0;\n\t}\n    }\n  return (0);\n}\n\nint\nrl_vi_eword (int count, int ignore)\n{\n  int opoint;\n\n  while (count-- && rl_point < (rl_end - 1))\n    {\n      if (whitespace (rl_line_buffer[rl_point]) == 0)\n\t_rl_vi_advance_point ();\n\n      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n\t_rl_vi_advance_point ();\n\n      opoint = rl_point;\n      if (rl_point < rl_end)\n\t{\n\t  if (_rl_isident (rl_line_buffer[rl_point]))\n\t    do\n\t      {\n\t\topoint = _rl_vi_advance_point ();\n\t      }\n\t    while (rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));\n\t  else\n\t    do\n\t      {\n\t\topoint = _rl_vi_advance_point ();\n\t      }\n\t    while (rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])\n\t\t   && !whitespace (rl_line_buffer[rl_point]));\n\t}\n      rl_point = opoint;\n    }\n  return (0);\n}\n\nint\nrl_vi_insert_beg (int count, int key)\n{\n  rl_beg_of_line (1, key);\n  rl_vi_insert_mode (1, key);\n  return (0);\n}\n\nstatic void\n_rl_vi_append_forward (int key)\n{\n  _rl_vi_advance_point ();\n}\n\nint\nrl_vi_append_mode (int count, int key)\n{\n  _rl_vi_append_forward (key);\n  rl_vi_start_inserting (key, 1, rl_arg_sign);\n  return (0);\n}\n\nint\nrl_vi_append_eol (int count, int key)\n{\n  rl_end_of_line (1, key);\n  rl_vi_append_mode (1, key);\n  return (0);\n}\n\n \nint\nrl_vi_eof_maybe (int count, int c)\n{\n  return (rl_newline (1, '\\n'));\n}\n\n \n\n \nint\nrl_vi_insertion_mode (int count, int key)\n{\n  _rl_keymap = vi_insertion_keymap;\n  _rl_vi_last_key_before_insert = key;\n  if (_rl_show_mode_in_prompt)\n    _rl_reset_prompt ();\n  return (0);\n}\n\nint\nrl_vi_insert_mode (int count, int key)\n{\n  rl_vi_start_inserting (key, 1, rl_arg_sign);\n  return (0);\n}\n\nstatic void\nvi_save_insert_buffer (int start, int len)\n{\n   \n  if (len >= vi_insert_buffer_size)\n    {\n      vi_insert_buffer_size += (len + 32) - (len % 32);\n      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);\n    }\n  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);\n  vi_insert_buffer[len-1] = '\\0';\n}\n\nstatic void\n_rl_vi_save_replace (void)\n{\n  int len, start, end;\n  UNDO_LIST *up;\n\n  up = rl_undo_list;\n  if (up == 0 || up->what != UNDO_END || vi_replace_count <= 0)\n    {\n      if (vi_insert_buffer_size >= 1)\n\tvi_insert_buffer[0] = '\\0';\n      return;\n    }\n   \n  end = rl_point;\n  start = end - vi_replace_count + 1;\n  len = vi_replace_count + 1;\n\n  if (start < 0)\n    {\n      len = end + 1;\n      start = 0;\n    }\n\n  vi_save_insert_buffer (start, len);  \n}\n\nstatic void\n_rl_vi_save_insert (UNDO_LIST *up)\n{\n  int len, start, end;\n\n  if (up == 0 || up->what != UNDO_INSERT)\n    {\n      if (vi_insert_buffer_size >= 1)\n\tvi_insert_buffer[0] = '\\0';\n      return;\n    }\n\n  start = up->start;\n  end = up->end;\n  len = end - start + 1;\n\n  vi_save_insert_buffer (start, len);\n}\n    \nvoid\n_rl_vi_done_inserting (void)\n{\n  if (_rl_vi_doing_insert)\n    {\n       \n      rl_end_undo_group ();\t \n       \n      _rl_vi_doing_insert = 0;\n      if (_rl_vi_last_key_before_insert == 'R')\n\t_rl_vi_save_replace ();\t\t \n      else\n\t_rl_vi_save_insert (rl_undo_list->next);\n       \n      if (_rl_undo_group_level > 0)\n\trl_end_undo_group ();\t \n    }\n  else\n    {\n      if (rl_undo_list && (_rl_vi_last_key_before_insert == 'i' ||\n\t\t\t   _rl_vi_last_key_before_insert == 'a' ||\n\t\t\t   _rl_vi_last_key_before_insert == 'I' ||\n\t\t\t   _rl_vi_last_key_before_insert == 'A'))\n\t_rl_vi_save_insert (rl_undo_list);\n       \n      else if (_rl_vi_last_key_before_insert == 'C')\n\trl_end_undo_group ();\n    }\n\n   \n  while (_rl_undo_group_level > 0)\n    rl_end_undo_group ();\n}\n\nint\nrl_vi_movement_mode (int count, int key)\n{\n  if (rl_point > 0)\n    rl_backward_char (1, key);\n\n  _rl_keymap = vi_movement_keymap;\n  _rl_vi_done_inserting ();\n\n   \n  if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)\n    rl_free_undo_list ();\n\n  if (_rl_show_mode_in_prompt)\n    _rl_reset_prompt ();\n\n  RL_SETSTATE (RL_STATE_VICMDONCE);\n  return (0);\n}\n\nint\nrl_vi_arg_digit (int count, int c)\n{\n  if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)\n    return (rl_beg_of_line (1, c));\n  else\n    return (rl_digit_argument (count, c));\n}\n\n \n#if defined (HANDLE_MULTIBYTE)\nstatic int\n_rl_vi_change_mbchar_case (int count)\n{\n  WCHAR_T wc;\n  char mb[MB_LEN_MAX+1];\n  int mlen, p;\n  size_t m;\n  mbstate_t ps;\n\n  memset (&ps, 0, sizeof (mbstate_t));\n  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)\n    count--;\n  while (count-- && rl_point < rl_end)\n    {\n      m = MBRTOWC (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);\n      if (MB_INVALIDCH (m))\n\twc = (WCHAR_T)rl_line_buffer[rl_point];\n      else if (MB_NULLWCH (m))\n\twc = L'\\0';\n      if (iswupper (wc))\n\twc = towlower (wc);\n      else if (iswlower (wc))\n\twc = towupper (wc);\n      else\n\t{\n\t   \n\t  rl_forward_char (1, 0);\n\t  continue;\n\t}\n\n       \n      if (wc)\n\t{\n\t  p = rl_point;\n\t  mlen = WCRTOMB (mb, wc, &ps);\n\t  if (mlen >= 0)\n\t    mb[mlen] = '\\0';\n\t  rl_begin_undo_group ();\n\t  rl_vi_delete (1, 0);\n\t  if (rl_point < p)\t \n\t    _rl_vi_advance_point ();\n\t  rl_insert_text (mb);\n\t  rl_end_undo_group ();\n\t  rl_vi_check ();\n\t}\n      else\n\trl_forward_char (1, 0);\n    }\n\n  return 0;\n}\n#endif\n\nint\nrl_vi_change_case (int count, int ignore)\n{\n  int c, p;\n\n   \n  if (rl_point >= rl_end)\n    return (0);\n\n  c = 0;\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    return (_rl_vi_change_mbchar_case (count));\n#endif\n\n  while (count-- && rl_point < rl_end)\n    {\n      if (_rl_uppercase_p (rl_line_buffer[rl_point]))\n\tc = _rl_to_lower (rl_line_buffer[rl_point]);\n      else if (_rl_lowercase_p (rl_line_buffer[rl_point]))\n\tc = _rl_to_upper (rl_line_buffer[rl_point]);\n      else\n\t{\n\t   \n\t  rl_forward_char (1, c);\n\t  continue;\n\t}\n\n       \n      if (c)\n\t{\n\t  p = rl_point;\n\t  rl_begin_undo_group ();\n\t  rl_vi_delete (1, c);\n\t  if (rl_point < p)\t \n\t    rl_point++;\n\t  _rl_insert_char (1, c);\n\t  rl_end_undo_group ();\n\t  rl_vi_check ();\n\t}\n      else\n\trl_forward_char (1, c);\n    }\n  return (0);\n}\n\nint\nrl_vi_put (int count, int key)\n{\n  if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))\n    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n\n  while (count--)\n    rl_yank (1, key);\n\n  rl_backward_char (1, key);\n  return (0);\n}\n\n \nint\nrl_vi_check (void)\n{\n  if (rl_point && rl_point == rl_end)\n    _rl_vi_backup ();\n  return (0);\n}\n\n \nint\nrl_vi_column (int count, int key)\n{\n  if (count > rl_end)\n    rl_end_of_line (1, key);\n  else\n    {\n      rl_point = 0;\n      rl_point = _rl_forward_char_internal (count - 1);\n    }\n  return (0);\n}\n\n \nstatic int\n_rl_vi_arg_dispatch (int c)\n{\n  int key;\n\n  key = c;\n  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)\n    {\n      rl_numeric_arg *= 4;\n      return 1;\n    }\n\n  c = UNMETA (c);\n\n  if (_rl_digit_p (c))\n    {\n      if (rl_explicit_arg)\n\trl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);\n      else\n\trl_numeric_arg = _rl_digit_value (c);\n      rl_explicit_arg = 1;\n      return 1;\t\t \n    }\n  else\n    {\n      rl_clear_message ();\n      rl_stuff_char (key);\n      return 0;\t\t \n    }\n}\n\n \nstatic int\nrl_digit_loop1 (void)\n{\n  int c, r;\n\n  while (1)\n    {\n      if (_rl_arg_overflow ())\n\treturn 1;\n\n      c = _rl_arg_getchar ();\n\n      r = _rl_vi_arg_dispatch (c);\n      if (r <= 0)\n\tbreak;\n    }\n\n  RL_UNSETSTATE(RL_STATE_NUMERICARG);\n  return (0);\n}\n\n \nstatic void\n_rl_mvcxt_init (_rl_vimotion_cxt *m, int op, int key)\n{\n  m->op = op;\n  m->state = m->flags = 0;\n  m->ncxt = 0;\n  m->numeric_arg = -1;\n  m->start = rl_point;\n  m->end = rl_end;\n  m->key = key;\n  m->motion = -1;\n}\n\nstatic _rl_vimotion_cxt *\n_rl_mvcxt_alloc (int op, int key)\n{\n  _rl_vimotion_cxt *m;\n\n  m = xmalloc (sizeof (_rl_vimotion_cxt));\n  _rl_mvcxt_init (m, op, key);\n  return m;\n}\n\nstatic void\n_rl_mvcxt_dispose (_rl_vimotion_cxt *m)\n{\n  xfree (m);\n}\n\nstatic int\nrl_domove_motion_callback (_rl_vimotion_cxt *m)\n{\n  int c;\n\n  _rl_vi_last_motion = c = m->motion;\n\n   \n  rl_extend_line_buffer (rl_end + 1);\n  rl_line_buffer[rl_end++] = ' ';\n  rl_line_buffer[rl_end] = '\\0';\n\n  _rl_dispatch (c, _rl_keymap);\n\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n       \n      if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n\treturn 0;\n      else\n\treturn (_rl_vi_domove_motion_cleanup (c, m));\n    }\n#endif\n\n  return (_rl_vi_domove_motion_cleanup (c, m));\n}\n\nint\n_rl_vi_domove_motion_cleanup (int c, _rl_vimotion_cxt *m)\n{\n  int r;\n\n   \n  rl_end = m->end;\n  rl_line_buffer[rl_end] = '\\0';\n  _rl_fix_point (0);\n\n   \n  if (rl_mark == rl_point)\n    {\n       \n      if (_rl_to_upper (m->key) == 'C' && _rl_vi_motion_command (c))\n\treturn (vidomove_dispatch (m));\n      RL_UNSETSTATE (RL_STATE_VIMOTION);\n      return (-1);\n    }\n\n   \n  if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&\n      !whitespace (rl_line_buffer[rl_point]))\n    rl_point--;\t\t \n\n   \n  if (m->key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))\n    {\n       \n      while (rl_point > rl_mark && whitespace (rl_line_buffer[rl_point]))\n\trl_point--;\n\n       \n      if (rl_point == rl_mark)\n\t_rl_vi_advance_point ();\n      else\n\t{\n\t   \n\t  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))\n\t    _rl_vi_advance_point ();\n\t}\n    }\n\n  if (rl_mark < rl_point)\n    SWAP (rl_point, rl_mark);\n\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    (*rl_redisplay_function)();\t\t \n#endif\n\n  r = vidomove_dispatch (m);\n\n  return (r);\n}\n\n#define RL_VIMOVENUMARG()\t(RL_ISSTATE (RL_STATE_VIMOTION) && RL_ISSTATE (RL_STATE_NUMERICARG))\n\nstatic int\nrl_domove_read_callback (_rl_vimotion_cxt *m)\n{\n  int c, save;\n\n  c = m->motion;\n\n  if (member (c, vi_motion))\n    {\n#if defined (READLINE_CALLBACKS)\n       \n      if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())\n\tRL_UNSETSTATE (RL_STATE_NUMERICARG);\n#endif\n       \n      return (rl_domove_motion_callback (m));\n    }\n  else if (m->key == c && (m->key == 'd' || m->key == 'y' || m->key == 'c'))\n    {\n      rl_mark = rl_end;\n      rl_beg_of_line (1, c);\n      _rl_vi_last_motion = c;\n      RL_UNSETSTATE (RL_STATE_VIMOTION);\n      return (vidomove_dispatch (m));\n    }\n#if defined (READLINE_CALLBACKS)\n   \n   \n  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())\n    {\n      return (_rl_vi_arg_dispatch (c));\n    }\n   \n  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_VIMOTION) && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0))\n    {\n      RL_SETSTATE (RL_STATE_NUMERICARG);\n      return (_rl_vi_arg_dispatch (c));\n    }\n#endif\n  else if (_rl_digit_p (c))\n    {\n       \n      save = rl_numeric_arg;\n      rl_numeric_arg = _rl_digit_value (c);\n      rl_explicit_arg = 1;\n      RL_SETSTATE (RL_STATE_NUMERICARG);\n      rl_digit_loop1 ();\n      rl_numeric_arg *= save;\n      c = rl_vi_domove_getchar (m);\n      if (c < 0)\n\t{\n\t  m->motion = 0;\n\t  return -1;\n\t}\n      m->motion = c;\n      return (rl_domove_motion_callback (m));\n    }\n  else\n    {\n      RL_UNSETSTATE (RL_STATE_VIMOTION);\n      RL_UNSETSTATE (RL_STATE_NUMERICARG);\n      return (1);\n    }\n}\n\nstatic int\nrl_vi_domove_getchar (_rl_vimotion_cxt *m)\n{\n  return (_rl_bracketed_read_key ());\n}\n\n#if defined (READLINE_CALLBACKS)\nint\n_rl_vi_domove_callback (_rl_vimotion_cxt *m)\n{\n  int c, r;\n\n  m->motion = c = rl_vi_domove_getchar (m);\n  if (c < 0)\n    return 1;\t\t \n  r = rl_domove_read_callback (m);\n\n  return ((r == 0) ? r : 1);\t \n}\n#endif\n\n \nint\nrl_vi_domove (int x, int *ignore)\n{\n  int r;\n  _rl_vimotion_cxt *m;\n\n  m = _rl_vimvcxt;\n  *ignore = m->motion = rl_vi_domove_getchar (m);\n\n  if (m->motion < 0)\n    {\n      m->motion = 0;\n      return -1;\n    }\n\n  return (rl_domove_read_callback (m));\n}\n\nstatic int\nvi_delete_dispatch (_rl_vimotion_cxt *m)\n{\n   \n  if (((strchr (\" l|h^0bBFT`\", m->motion) == 0) && (rl_point >= m->start)) &&\n      (rl_mark < rl_end))\n    INCREMENT_POS (rl_mark);\n\n  rl_kill_text (rl_point, rl_mark);\n  return (0);\n}\n\nint\nrl_vi_delete_to (int count, int key)\n{\n  int c, r;\n  _rl_vimotion_cxt *savecxt;\n\n  savecxt = 0;\n  if (_rl_vi_redoing)\n    {\n      savecxt = _rl_vimvcxt;\n      _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);\n    }\n  else if (_rl_vimvcxt)\n    _rl_mvcxt_init (_rl_vimvcxt, VIM_DELETE, key);\n  else\n    _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);\n\n  _rl_vimvcxt->start = rl_point;\n\n  rl_mark = rl_point;\n  if (_rl_uppercase_p (key))\n    {\n      _rl_vimvcxt->motion = '$';\n      r = rl_domove_motion_callback (_rl_vimvcxt);\n    }\n  else if (_rl_vi_redoing && _rl_vi_last_motion != 'd')\t \n    {\n      _rl_vimvcxt->motion = _rl_vi_last_motion;\n      r = rl_domove_motion_callback (_rl_vimvcxt);\n    }\n  else if (_rl_vi_redoing)\t\t \n    {\n      _rl_vimvcxt->motion = _rl_vi_last_motion;\n      rl_mark = rl_end;\n      rl_beg_of_line (1, key);\n      RL_UNSETSTATE (RL_STATE_VIMOTION);\n      r = vidomove_dispatch (_rl_vimvcxt);\n    }\n#if defined (READLINE_CALLBACKS)\n  else if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      RL_SETSTATE (RL_STATE_VIMOTION);\n      return (0);\n    }\n#endif\n  else\n    r = rl_vi_domove (key, &c);\n\n  if (r < 0)\n    {\n      rl_ding ();\n      r = -1;\n    }\n\n  _rl_mvcxt_dispose (_rl_vimvcxt);\n  _rl_vimvcxt = savecxt;\n\n  return r;\n}\n\nstatic int\nvi_change_dispatch (_rl_vimotion_cxt *m)\n{\n   \n  if (((strchr (\" l|hwW^0bBFT`\", m->motion) == 0) && (rl_point >= m->start)) &&\n      (rl_mark < rl_end))\n    INCREMENT_POS (rl_mark);\n\n   \n  if ((_rl_to_upper (m->motion) == 'W') && rl_point < m->start)\n    rl_point = m->start;\n\n  if (_rl_vi_redoing)\n    {\n      if (vi_insert_buffer && *vi_insert_buffer)\n\trl_begin_undo_group ();\n      rl_delete_text (rl_point, rl_mark);\n      if (vi_insert_buffer && *vi_insert_buffer)\n\t{\n\t  rl_insert_text (vi_insert_buffer);\n\t  rl_end_undo_group ();\n\t}\n    }\n  else\n    {\n      rl_begin_undo_group ();\t\t \n      rl_kill_text (rl_point, rl_mark);\n       \n      if (_rl_uppercase_p (m->key) == 0)\n\t_rl_vi_doing_insert = 1;\n       \n      rl_vi_start_inserting (m->key, rl_numeric_arg, rl_arg_sign);\n    }\n\n  return (0);\n}\n\nint\nrl_vi_change_to (int count, int key)\n{\n  int c, r;\n  _rl_vimotion_cxt *savecxt;\n\n  savecxt = 0;\n  if (_rl_vi_redoing)\n    {\n      savecxt = _rl_vimvcxt;\n      _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);\n    }\n  else if (_rl_vimvcxt)\n    _rl_mvcxt_init (_rl_vimvcxt, VIM_CHANGE, key);\n  else\n    _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);\n  _rl_vimvcxt->start = rl_point;\n\n  rl_mark = rl_point;\n  if (_rl_uppercase_p (key))\n    {\n      _rl_vimvcxt->motion = '$';\n      r = rl_domove_motion_callback (_rl_vimvcxt);\n    }\n  else if (_rl_vi_redoing && _rl_vi_last_motion != 'c')\t \n    {\n      _rl_vimvcxt->motion = _rl_vi_last_motion;\n      r = rl_domove_motion_callback (_rl_vimvcxt);\n    }\n  else if (_rl_vi_redoing)\t\t \n    {\n      _rl_vimvcxt->motion = _rl_vi_last_motion;\n      rl_mark = rl_end;\n      rl_beg_of_line (1, key);\n      RL_UNSETSTATE (RL_STATE_VIMOTION);\n      r = vidomove_dispatch (_rl_vimvcxt);\n    }\n#if defined (READLINE_CALLBACKS)\n  else if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      RL_SETSTATE (RL_STATE_VIMOTION);\n      return (0);\n    }\n#endif\n  else\n    r = rl_vi_domove (key, &c);\n\n  if (r < 0)\n    {\n      rl_ding ();\n      r = -1;\t \n    }\n\n  _rl_mvcxt_dispose (_rl_vimvcxt);\n  _rl_vimvcxt = savecxt;\n\n  return r;\n}\n\nstatic int\nvi_yank_dispatch (_rl_vimotion_cxt *m)\n{\n   \n  if (((strchr (\" l|h^0%bBFT`\", m->motion) == 0) && (rl_point >= m->start)) &&\n      (rl_mark < rl_end))\n    INCREMENT_POS (rl_mark);\n\n  rl_begin_undo_group ();\n  rl_kill_text (rl_point, rl_mark);\n  rl_end_undo_group ();\n  rl_do_undo ();\n  rl_point = m->start;\n\n  _rl_fix_point (1);\n\n  return (0);\n}\n\nint\nrl_vi_yank_to (int count, int key)\n{\n  int c, r;\n  _rl_vimotion_cxt *savecxt;\n\n  savecxt = 0;\n  if (_rl_vi_redoing)\n    {\n      savecxt = _rl_vimvcxt;\n      _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);\n    }\n  else if (_rl_vimvcxt)\n    _rl_mvcxt_init (_rl_vimvcxt, VIM_YANK, key);\n  else\n    _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);\n  _rl_vimvcxt->start = rl_point;\n\n  rl_mark = rl_point;\n  if (_rl_uppercase_p (key))\n    {\n      _rl_vimvcxt->motion = '$';\n      r = rl_domove_motion_callback (_rl_vimvcxt);\n    }\n  else if (_rl_vi_redoing && _rl_vi_last_motion != 'y')\t \n    {\n      _rl_vimvcxt->motion = _rl_vi_last_motion;\n      r = rl_domove_motion_callback (_rl_vimvcxt);\n    }\n  else if (_rl_vi_redoing)\t\t\t \n    {\n      _rl_vimvcxt->motion = _rl_vi_last_motion;\n      rl_mark = rl_end;\n      rl_beg_of_line (1, key);\n      RL_UNSETSTATE (RL_STATE_VIMOTION);\n      r = vidomove_dispatch (_rl_vimvcxt);\n    }\n#if defined (READLINE_CALLBACKS)\n  else if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      RL_SETSTATE (RL_STATE_VIMOTION);\n      return (0);\n    }\n#endif\n  else\n    r = rl_vi_domove (key, &c);\n\n  if (r < 0)\n    {\n      rl_ding ();\n      r = -1;\n    }\n\n  _rl_mvcxt_dispose (_rl_vimvcxt);\n  _rl_vimvcxt = savecxt;\n\n  return r;\n}\n\nstatic int\nvidomove_dispatch (_rl_vimotion_cxt *m)\n{\n  int r;\n\n  switch (m->op)\n    {\n    case VIM_DELETE:\n      r = vi_delete_dispatch (m);\n      break;\n    case VIM_CHANGE:\n      r = vi_change_dispatch (m);\n      break;\n    case VIM_YANK:\n      r = vi_yank_dispatch (m);\n      break;\n    default:\n      _rl_errmsg (\"vidomove_dispatch: unknown operator %d\", m->op);\n      r = 1;\n      break;\n    }\n\n  RL_UNSETSTATE (RL_STATE_VIMOTION);\n  return r;\n}\n\nint\nrl_vi_rubout (int count, int key)\n{\n  int opoint;\n\n  if (count < 0)\n    return (rl_vi_delete (-count, key));\n\n  if (rl_point == 0)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  opoint = rl_point;\n  if (count > 1 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    rl_backward_char (count, key);\n  else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n  else\n    rl_point -= count;\n\n  if (rl_point < 0)\n    rl_point = 0;\n\n  rl_kill_text (rl_point, opoint);\n  \n  return (0);\n}\n\nint\nrl_vi_delete (int count, int key)\n{\n  int end;\n\n  if (count < 0)\n    return (rl_vi_rubout (-count, key));\n\n  if (rl_end == 0)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);\n  else\n    end = rl_point + count;\n\n  if (end >= rl_end)\n    end = rl_end;\n\n  rl_kill_text (rl_point, end);\n  \n  if (rl_point > 0 && rl_point == rl_end)\n    rl_backward_char (1, key);\n\n  return (0);\n}\n\n \n\n#define vi_unix_word_boundary(c)\t(whitespace(c) || ispunct(c))\n\nint\nrl_vi_unix_word_rubout (int count, int key)\n{\n  int orig_point;\n\n  if (rl_point == 0)\n    rl_ding ();\n  else\n    {\n      orig_point = rl_point;\n      if (count <= 0)\n\tcount = 1;\n\n      while (count--)\n\t{\n\t   \n\n\t   \n\t  if (rl_point > 0 && (rl_line_buffer[rl_point] == 0) &&\n\t\twhitespace (rl_line_buffer[rl_point - 1]))\n\t    while (--rl_point > 0 && whitespace (rl_line_buffer[rl_point]))\n\t      ;\n\n\t   \n\t  if (rl_point > 0 && (vi_unix_word_boundary (rl_line_buffer[rl_point]) == 0) &&\n\t\tvi_unix_word_boundary (rl_line_buffer[rl_point - 1]))\n\t    rl_point--;\n\n\t   \n\t  if (rl_point > 0 && vi_unix_word_boundary (rl_line_buffer[rl_point]))\n\t    while (rl_point && vi_unix_word_boundary (rl_line_buffer[rl_point - 1]))\n\t      rl_point--;\n\t  else if (rl_point > 0 && vi_unix_word_boundary (rl_line_buffer[rl_point]) == 0)\n\t    while (rl_point > 0 && (vi_unix_word_boundary (rl_line_buffer[rl_point - 1]) == 0))\n\t      _rl_vi_backup_point ();\n\t}\n\n      rl_kill_text (orig_point, rl_point);\n    }\n\n  return 0;\n}\n\n\nint\nrl_vi_back_to_indent (int count, int key)\n{\n  rl_beg_of_line (1, key);\n  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n    rl_point++;\n  return (0);\n}\n\nint\nrl_vi_first_print (int count, int key)\n{\n  return (rl_vi_back_to_indent (1, key));\n}\n\nstatic int _rl_cs_dir, _rl_cs_orig_dir;\n\n#if defined (READLINE_CALLBACKS)\nstatic int\n_rl_vi_callback_char_search (_rl_callback_generic_arg *data)\n{\n  int c;\n#if defined (HANDLE_MULTIBYTE)\n  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);\n#else\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  c = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n#endif\n\n  if (c <= 0)\n    {\n      RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n      return -1;\n    }\n\n#if !defined (HANDLE_MULTIBYTE)\n  _rl_vi_last_search_char = c;\n#endif\n\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n  RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n\n#if defined (HANDLE_MULTIBYTE)\n  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));\n#else\n  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_char));\n#endif  \n}\n#endif\n\nint\nrl_vi_char_search (int count, int key)\n{\n  int c;\n#if defined (HANDLE_MULTIBYTE)\n  static char *target;\n  static int tlen;\n#else\n  static char target;\n#endif\n\n  if (key == ';' || key == ',')\n    {\n      if (_rl_cs_orig_dir == 0)\n\treturn 1;\n#if defined (HANDLE_MULTIBYTE)\n      if (_rl_vi_last_search_mblen == 0)\n\treturn 1;\n#else\n      if (_rl_vi_last_search_char == 0)\n\treturn 1;\n#endif\n      _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;\n    }\n  else\n    {\n      switch (key)\n\t{\n\tcase 't':\n\t  _rl_cs_orig_dir = _rl_cs_dir = FTO;\n\t  break;\n\n\tcase 'T':\n\t  _rl_cs_orig_dir = _rl_cs_dir = BTO;\n\t  break;\n\n\tcase 'f':\n\t  _rl_cs_orig_dir = _rl_cs_dir = FFIND;\n\t  break;\n\n\tcase 'F':\n\t  _rl_cs_orig_dir = _rl_cs_dir = BFIND;\n\t  break;\n\t}\n\n      if (_rl_vi_redoing)\n\t{\n\t   \n\t}\n#if defined (READLINE_CALLBACKS)\n      else if (RL_ISSTATE (RL_STATE_CALLBACK))\n\t{\n\t  _rl_callback_data = _rl_callback_data_alloc (count);\n\t  _rl_callback_data->i1 = _rl_cs_dir;\n\t  _rl_callback_data->i2 = key;\n\t  _rl_callback_func = _rl_vi_callback_char_search;\n\t  RL_SETSTATE (RL_STATE_CHARSEARCH);\n\t  return (0);\n\t}\n#endif\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  c = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);\n\t  if (c <= 0)\n\t    return -1;\n\t  _rl_vi_last_search_mblen = c;\n#else\n\t  RL_SETSTATE(RL_STATE_MOREINPUT);\n\t  c = rl_read_key ();\n\t  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\t  if (c < 0)\n\t    return -1;\n\t  _rl_vi_last_search_char = c;\n#endif\n\t}\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  target = _rl_vi_last_search_mbchar;\n  tlen = _rl_vi_last_search_mblen;\n#else\n  target = _rl_vi_last_search_char;\n#endif\n\n#if defined (HANDLE_MULTIBYTE)\n  return (_rl_char_search_internal (count, _rl_cs_dir, target, tlen));\n#else\n  return (_rl_char_search_internal (count, _rl_cs_dir, target));\n#endif\n}\n\n \nint\nrl_vi_match (int ignore, int key)\n{\n  int count = 1, brack, pos, tmp, pre;\n\n  pos = rl_point;\n  if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)\n    {\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)\n\t    {\n\t      pre = rl_point;\n\t      rl_forward_char (1, key);\n\t      if (pre == rl_point)\n\t\tbreak;\n\t    }\n\t}\n      else\n\twhile ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&\n\t\trl_point < rl_end - 1)\n\t  rl_forward_char (1, key);\n\n      if (brack <= 0)\n\t{\n\t  rl_point = pos;\n\t  rl_ding ();\n\t  return 1;\n\t}\n    }\n\n  pos = rl_point;\n\n  if (brack < 0)\n    {\n      while (count)\n\t{\n\t  tmp = pos;\n\t  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n\t    pos--;\n\t  else\n\t    {\n\t      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);\n\t      if (tmp == pos)\n\t\tpos--;\n\t    }\n\t  if (pos >= 0)\n\t    {\n\t      int b = rl_vi_bracktype (rl_line_buffer[pos]);\n\t      if (b == -brack)\n\t\tcount--;\n\t      else if (b == brack)\n\t\tcount++;\n\t    }\n\t  else\n\t    {\n\t      rl_ding ();\n\t      return 1;\n\t    }\n\t}\n    }\n  else\n    {\t\t\t \n      while (count)\n\t{\n\t  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n\t    pos++;\n\t  else\n\t    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);\n\n\t  if (pos < rl_end)\n\t    {\n\t      int b = rl_vi_bracktype (rl_line_buffer[pos]);\n\t      if (b == -brack)\n\t\tcount--;\n\t      else if (b == brack)\n\t\tcount++;\n\t    }\n\t  else\n\t    {\n\t      rl_ding ();\n\t      return 1;\n\t    }\n\t}\n    }\n  rl_point = pos;\n  return (0);\n}\n\nint\nrl_vi_bracktype (int c)\n{\n  switch (c)\n    {\n    case '(': return  1;\n    case ')': return -1;\n    case '[': return  2;\n    case ']': return -2;\n    case '{': return  3;\n    case '}': return -3;\n    default:  return  0;\n    }\n}\n\nstatic int\n_rl_vi_change_char (int count, int c, char *mb)\n{\n  int p;\n\n  if (c == '\\033' || c == CTRL ('C'))\n    return -1;\n\n  rl_begin_undo_group ();\n  while (count-- && rl_point < rl_end)\n    {\n      p = rl_point;\n      rl_vi_delete (1, c);\n      if (rl_point < p)\t\t \n\t_rl_vi_append_forward (c);\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_insert_text (mb);\n      else\n#endif\n\t_rl_insert_char (1, c);\n    }\n\n   \n  rl_backward_char (1, c);\n\n  rl_end_undo_group ();\n\n  return (0);\n}\n\nstatic int\n_rl_vi_callback_getchar (char *mb, int mlen)\n{\n  return (_rl_bracketed_read_mbstring (mb, mlen));\n}\n\n#if defined (READLINE_CALLBACKS)\nstatic int\n_rl_vi_callback_change_char (_rl_callback_generic_arg *data)\n{\n  int c;\n  char mb[MB_LEN_MAX+1];\n\n  c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);\n  if (c < 0)\n    return -1;\n\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    strncpy (_rl_vi_last_replacement, mb, MB_LEN_MAX);\n  else\n#endif\n    _rl_vi_last_replacement[0] = c;\n  _rl_vi_last_replacement[MB_LEN_MAX] = '\\0';\t \n\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n\n  return (_rl_vi_change_char (data->count, c, mb));\n}\n#endif\n\nint\nrl_vi_change_char (int count, int key)\n{\n  int c;\n  char mb[MB_LEN_MAX+1];\n\n  if (_rl_vi_redoing)\n    {\n      strncpy (mb, _rl_vi_last_replacement, MB_LEN_MAX);\n      c = (unsigned char)_rl_vi_last_replacement[0];\t \n      mb[MB_LEN_MAX] = '\\0';\n    }\n#if defined (READLINE_CALLBACKS)\n  else if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_callback_data = _rl_callback_data_alloc (count);\n      _rl_callback_func = _rl_vi_callback_change_char;\n      return (0);\n    }\n#endif\n  else\n    {\n      c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);\n      if (c < 0)\n\treturn -1;\n#ifdef HANDLE_MULTIBYTE\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\tstrncpy (_rl_vi_last_replacement, mb, MB_LEN_MAX);\n      else\n#endif\n\t_rl_vi_last_replacement[0] = c;\n      _rl_vi_last_replacement[MB_LEN_MAX] = '\\0';\t       \n    }\n\n  if (c < 0)\n    return -1;\n\n  return (_rl_vi_change_char (count, c, mb));\n}\n\nint\nrl_vi_subst (int count, int key)\n{\n   \n  if (_rl_vi_redoing == 0)\n    rl_stuff_char ((key == 'S') ? 'c' : 'l');\t \n\n  return (rl_vi_change_to (count, 'c'));\n}\n\nint\nrl_vi_overstrike (int count, int key)\n{\n  if (_rl_vi_doing_insert == 0)\n    {\n      _rl_vi_doing_insert = 1;\n      rl_begin_undo_group ();\n    }\n\n  if (count > 0)\n    {\n      if (_rl_overwrite_char (count, key) != 0)\n\treturn (1);\n      vi_replace_count += count;\n    }\n\n  return (0);\n}\n\nint\nrl_vi_overstrike_delete (int count, int key)\n{\n  int i, s;\n\n  for (i = 0; i < count; i++)\n    {\n      if (vi_replace_count == 0)\n\t{\n\t  rl_ding ();\n\t  break;\n\t}\n      s = rl_point;\n\n      if (rl_do_undo ())\n\tvi_replace_count--;\t\t \n\n      if (rl_point == s)\n\trl_backward_char (1, key);\n    }\n\n  if (vi_replace_count == 0 && _rl_vi_doing_insert)\n    {\n      rl_end_undo_group ();\n      rl_do_undo ();\n      _rl_vi_doing_insert = 0;\n    }\n  return (0);\n}\n\nstatic int\nrl_vi_overstrike_kill_line (int count, int key)\n{\n  int r, end;\n\n  end = rl_end;\n  r = rl_unix_line_discard (count, key);\n  vi_replace_count -= end - rl_end;\n  return r;\n}\n\nstatic int\nrl_vi_overstrike_kill_word (int count, int key)\n{\n  int r, end;\n\n  end = rl_end;\n  r = rl_vi_unix_word_rubout (count, key);\n  vi_replace_count -= end - rl_end;\n  return r;\n}\n\nstatic int\nrl_vi_overstrike_yank (int count, int key)\n{\n  int r, end;\n\n  end = rl_end;\n  r = rl_yank (count, key);\n  vi_replace_count += rl_end - end;\n  return r;\n}\n\n \nstatic int\nrl_vi_overstrike_bracketed_paste (int count, int key)\n{\n  int r;\n  char *pbuf;\n  size_t pblen;\n\n  pbuf = _rl_bracketed_text (&pblen);\n  if (pblen == 0)\n    {\n      xfree (pbuf);\n      return 0;\n    }\n  r = pblen;\n  while (--r >= 0)\n    _rl_unget_char ((unsigned char)pbuf[r]);\n  xfree (pbuf);\n\n  while (_rl_pushed_input_available ())\n    {\n      key = rl_read_key ();\n      r = rl_vi_overstrike (1, key);\n    }\n\n  return r;\n}\n\nint\nrl_vi_replace (int count, int key)\n{\n  int i;\n\n  vi_replace_count = 0;\n\n  if (vi_replace_map == 0)\n    {\n      vi_replace_map = rl_make_bare_keymap ();\n\n      for (i = 0; i < ' '; i++)\n\tif (vi_insertion_keymap[i].type == ISFUNC)\n\t  vi_replace_map[i].function = vi_insertion_keymap[i].function;\n\n      for (i = ' '; i < KEYMAP_SIZE; i++)\n\tvi_replace_map[i].function = rl_vi_overstrike;\n\n      vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;\n\n       \n      vi_replace_map[ESC].function = rl_vi_movement_mode;\n      vi_replace_map[RETURN].function = rl_newline;\n      vi_replace_map[NEWLINE].function = rl_newline;\n\n       \n      if (vi_insertion_keymap[CTRL ('H')].type == ISFUNC &&\n\t  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)\n\tvi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;\n\n       \n      if (vi_insertion_keymap[CTRL ('U')].type == ISFUNC &&\n\t  vi_insertion_keymap[CTRL ('U')].function == rl_unix_line_discard)\n\tvi_replace_map[CTRL ('U')].function = rl_vi_overstrike_kill_line;\n\n       \n      if (vi_insertion_keymap[CTRL ('W')].type == ISFUNC &&\n\t  vi_insertion_keymap[CTRL ('W')].function == rl_vi_unix_word_rubout)\n\tvi_replace_map[CTRL ('W')].function = rl_vi_overstrike_kill_word;\n\n       \n      if (vi_insertion_keymap[CTRL ('Y')].type == ISFUNC &&\n\t  vi_insertion_keymap[CTRL ('Y')].function == rl_yank)\n\tvi_replace_map[CTRL ('Y')].function = rl_vi_overstrike_yank;\n\n       \n      vi_replace_map[ANYOTHERKEY].type = ISFUNC;\n      vi_replace_map[ANYOTHERKEY].function = (rl_command_func_t *)NULL;\n    }\n\n  rl_vi_start_inserting (key, 1, rl_arg_sign);\n\n  _rl_vi_last_key_before_insert = 'R';\t \n  _rl_keymap = vi_replace_map;\n\n  if (_rl_enable_bracketed_paste)\n    rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_vi_overstrike_bracketed_paste);\n\n  return (0);\n}\n\n#if 0\n \nint\nrl_vi_possible_completions (void)\n{\n  int save_pos = rl_point;\n\n  if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')\n    {\n      while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&\n\t     rl_line_buffer[rl_point] != ';')\n\t_rl_vi_advance_point ();\n    }\n  else if (rl_line_buffer[rl_point - 1] == ';')\n    {\n      rl_ding ();\n      return (0);\n    }\n\n  rl_possible_completions ();\n  rl_point = save_pos;\n\n  return (0);\n}\n#endif\n\n \nstatic int\n_rl_vi_set_mark (void)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  if (ch < 0 || ch < 'a' || ch > 'z')\t \n    {\n      rl_ding ();\n      return 1;\n    }\n  ch -= 'a';\n  vi_mark_chars[ch] = rl_point;\n  return 0;\n}\n\n#if defined (READLINE_CALLBACKS)\nstatic int\n_rl_vi_callback_set_mark (_rl_callback_generic_arg *data)\n{\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n\n  return (_rl_vi_set_mark ());\n}\n#endif\n\nint\nrl_vi_set_mark (int count, int key)\n{\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_callback_data = 0;\n      _rl_callback_func = _rl_vi_callback_set_mark;\n      return (0);\n    }\n#endif\n\n  return (_rl_vi_set_mark ());\n}\n\nstatic int\n_rl_vi_goto_mark (void)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  if (ch == '`')\n    {\n      rl_point = rl_mark;\n      _rl_fix_point (1);\n      return 0;\n    }\n  else if (ch < 0 || ch < 'a' || ch > 'z')\t \n    {\n      rl_ding ();\n      return 1;\n    }\n\n  ch -= 'a';\n  if (vi_mark_chars[ch] == -1)\n    {\n      rl_ding ();\n      return 1;\n    }\n  rl_point = vi_mark_chars[ch];\n  _rl_fix_point (1);\n  return 0;\n}\n\n#if defined (READLINE_CALLBACKS)\nstatic int\n_rl_vi_callback_goto_mark (_rl_callback_generic_arg *data)\n{\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n\n  return (_rl_vi_goto_mark ());\n}\n#endif\n\nint\nrl_vi_goto_mark (int count, int key)\n{\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_callback_data = 0;\n      _rl_callback_func = _rl_vi_callback_goto_mark;\n      return (0);\n    }\n#endif\n\n  return (_rl_vi_goto_mark ());\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}