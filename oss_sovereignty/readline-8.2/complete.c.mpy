{
  "module_name": "complete.c",
  "hash_id": "5079d8fc01bbe5c425d551e71d68e3c9e00f5480f02842514764454f75d6de24",
  "original_prompt": "Ingested from readline-8.2/complete.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (__TANDEM)\n#  define _XOPEN_SOURCE_EXTENDED 1\n#endif\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#if defined (__TANDEM)\n#  include <sys/stat.h>\n#endif\n#include <fcntl.h>\n#if defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n\n#include <signal.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#if defined (HAVE_PWD_H)\n#include <pwd.h>\n#endif\n\n#include \"posixdir.h\"\n#include \"posixstat.h\"\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n \n#include \"readline.h\"\n#include \"xmalloc.h\"\n#include \"rlprivate.h\"\n\n#if defined (COLOR_SUPPORT)\n#  include \"colors.h\"\n#endif\n\n#ifdef __STDC__\ntypedef int QSFUNC (const void *, const void *);\n#else\ntypedef int QSFUNC ();\n#endif\n\n#ifdef HAVE_LSTAT\n#  define LSTAT lstat\n#else\n#  define LSTAT stat\n#endif\n\n \n#define HIDDEN_FILE(fname)\t((fname)[0] == '.')\n\n \n#if defined (HAVE_GETPWENT) && (!defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE))\nextern struct passwd *getpwent (void);\n#endif  \n\n \nrl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;\n\n#if defined (VISIBLE_STATS) || defined (COLOR_SUPPORT)\n#  if !defined (X_OK)\n#    define X_OK 1\n#  endif\n#endif\n\n#if defined (VISIBLE_STATS)\nstatic int stat_char (char *);\n#endif\n\n#if defined (COLOR_SUPPORT)\nstatic int colored_stat_start (const char *);\nstatic void colored_stat_end (void);\nstatic int colored_prefix_start (void);\nstatic void colored_prefix_end (void);\n#endif\n\nstatic int path_isdir (const char *);\n\nstatic char *rl_quote_filename (char *, int, char *);\n\nstatic void _rl_complete_sigcleanup (int, void *);\n\nstatic void set_completion_defaults (int);\nstatic int get_y_or_n (int);\nstatic int _rl_internal_pager (int);\nstatic char *printable_part (char *);\nstatic int fnwidth (const char *);\nstatic int fnprint (const char *, int, const char *);\nstatic int print_filename (char *, char *, int);\n\nstatic char **gen_completion_matches (char *, int, int, rl_compentry_func_t *, int, int);\n\nstatic char **remove_duplicate_matches (char **);\nstatic void insert_match (char *, int, int, char *);\nstatic int append_to_match (char *, int, int, int);\nstatic void insert_all_matches (char **, int, char *);\nstatic int complete_fncmp (const char *, int, const char *, int);\nstatic void display_matches (char **);\nstatic int compute_lcd_of_matches (char **, int, const char *);\nstatic int postprocess_matches (char ***, int);\nstatic int compare_match (char *, const char *);\nstatic int complete_get_screenwidth (void);\n\nstatic char *make_quoted_replacement (char *, int, char *);\n\n \n \n \n \n \n\n \n\n \nint _rl_complete_show_all = 0;\n\n \nint _rl_complete_show_unmodified = 0;\n\n \nint _rl_complete_mark_directories = 1;\n\n \nint _rl_complete_mark_symlink_dirs = 0;\n\n \nint _rl_print_completions_horizontally;\n\n \n#if (defined (__MSDOS__) && !defined (__DJGPP__)) || (defined (_WIN32) && !defined (__CYGWIN__))\nint _rl_completion_case_fold = 1;\n#else\nint _rl_completion_case_fold = 0;\n#endif\n\n \nint _rl_completion_case_map = 0;\n\n \nint _rl_match_hidden_files = 1;\n\n \nint _rl_completion_prefix_display_length = 0;\n\n \nint _rl_completion_columns = -1;\n\n#if defined (COLOR_SUPPORT)\n \nint _rl_colored_stats = 0;\n\n \nint _rl_colored_completion_prefix = 0;\n#endif\n\n \nint _rl_skip_completed_text = 0;\n\n \nint _rl_menu_complete_prefix_first = 0;\n\n \n\n#if defined (VISIBLE_STATS)\n \nint rl_visible_stats = 0;\n#endif  \n\n \nrl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;\n\nrl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;\n\nrl_icppfunc_t *rl_filename_stat_hook = (rl_icppfunc_t *)NULL;\n\n \nrl_dequote_func_t *rl_filename_rewrite_hook = (rl_dequote_func_t *)NULL;\n\n \nint rl_complete_with_tilde_expansion = 0;\n\n \nrl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;\n\n \nrl_compentry_func_t *rl_menu_completion_entry_function = (rl_compentry_func_t *)NULL;\n\n \nrl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;\n\n \nint rl_attempted_completion_over = 0;\n\n \nint rl_completion_type = 0;\n\n \nint rl_completion_query_items = 100;\n\nint _rl_page_completions = 1;\n\n \nconst char *rl_basic_word_break_characters = \" \\t\\n\\\"\\\\'`@$><=;|&{(\";  \n\n \nconst char *rl_basic_quote_characters = \"\\\"'\";\n\n \nconst char *rl_completer_word_break_characters = 0;\n\n \nrl_cpvfunc_t *rl_completion_word_break_hook = (rl_cpvfunc_t *)NULL;\n\n \nconst char *rl_completer_quote_characters = (const char *)NULL;\n\n \nconst char *rl_filename_quote_characters = (const char *)NULL;\n\n \nconst char *rl_special_prefixes = (const char *)NULL;\n\n \nint rl_ignore_completion_duplicates = 1;\n\n \nint rl_filename_completion_desired = 0;\n\n \nint rl_filename_quoting_desired = 1;\n\n \nrl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;\n\n \nrl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;\n         \n \nrl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;\n\n \nrl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;\n\n \nint rl_completion_suppress_append = 0;\n\n \nint rl_completion_append_character = ' ';\n\n \nint rl_completion_suppress_quote = 0;\n\n \nint rl_completion_quote_character;\n\n \nint rl_completion_found_quote;\n\n \nint rl_completion_mark_symlink_dirs;\n\n \nint rl_inhibit_completion;\n\n \nint rl_completion_invoking_key;\n\n \nint rl_sort_completion_matches = 1;\n\n \n\n \nstatic int completion_changed_buffer;\nstatic int last_completion_failed = 0;\n\n \nstatic int completion_y_or_n;\n\nstatic int _rl_complete_display_matches_interrupt = 0;\n\n \n \n \n \n \n\n \nint\nrl_complete (int ignore, int invoking_key)\n{\n  rl_completion_invoking_key = invoking_key;\n\n  if (rl_inhibit_completion)\n    return (_rl_insert_char (ignore, invoking_key));\n#if 0\n  else if (rl_last_func == rl_complete && completion_changed_buffer == 0 && last_completion_failed == 0)\n#else\n  else if (rl_last_func == rl_complete && completion_changed_buffer == 0)\n#endif\n    return (rl_complete_internal ('?'));\n  else if (_rl_complete_show_all)\n    return (rl_complete_internal ('!'));\n  else if (_rl_complete_show_unmodified)\n    return (rl_complete_internal ('@'));\n  else\n    return (rl_complete_internal (TAB));\n}\n\n \nint\nrl_possible_completions (int ignore, int invoking_key)\n{\n  rl_completion_invoking_key = invoking_key;\n  return (rl_complete_internal ('?'));\n}\n\nint\nrl_insert_completions (int ignore, int invoking_key)\n{\n  rl_completion_invoking_key = invoking_key;\n  return (rl_complete_internal ('*'));\n}\n\n \nint\nrl_completion_mode (rl_command_func_t *cfunc)\n{\n  if (rl_last_func == cfunc && !completion_changed_buffer)\n    return '?';\n  else if (_rl_complete_show_all)\n    return '!';\n  else if (_rl_complete_show_unmodified)\n    return '@';\n  else\n    return TAB;\n}\n\n \n \n \n \n \n\n \nvoid\n_rl_reset_completion_state (void)\n{\n  rl_completion_found_quote = 0;\n  rl_completion_quote_character = 0;\n}\n\nstatic void\n_rl_complete_sigcleanup (int sig, void *ptr)\n{\n  if (sig == SIGINT)\t \n    {\n      _rl_free_match_list ((char **)ptr);\n      _rl_complete_display_matches_interrupt = 1;\n    }\n}\n\n \nstatic void\nset_completion_defaults (int what_to_do)\n{\n   \n  rl_filename_completion_desired = 0;\n  rl_filename_quoting_desired = 1;\n  rl_completion_type = what_to_do;\n  rl_completion_suppress_append = rl_completion_suppress_quote = 0;\n  rl_completion_append_character = ' ';\n\n   \n  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;\n\n   \n  _rl_complete_display_matches_interrupt = 0;\n}\n\n \nstatic int\nget_y_or_n (int for_pager)\n{\n  int c;\n\n   \n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    return 1;\n#endif\n\n  for (;;)\n    {\n      RL_SETSTATE(RL_STATE_MOREINPUT);\n      c = rl_read_key ();\n      RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n      if (c == 'y' || c == 'Y' || c == ' ')\n\treturn (1);\n      if (c == 'n' || c == 'N' || c == RUBOUT)\n\treturn (0);\n      if (c == ABORT_CHAR || c < 0)\n\t_rl_abort_internal ();\n      if (for_pager && (c == NEWLINE || c == RETURN))\n\treturn (2);\n      if (for_pager && (c == 'q' || c == 'Q'))\n\treturn (0);\n      rl_ding ();\n    }\n}\n\nstatic int\n_rl_internal_pager (int lines)\n{\n  int i;\n\n  fprintf (rl_outstream, \"--More--\");\n  fflush (rl_outstream);\n  i = get_y_or_n (1);\n  _rl_erase_entire_line ();\n  if (i == 0)\n    return -1;\n  else if (i == 2)\n    return (lines - 1);\n  else\n    return 0;\n}\n\nstatic int\npath_isdir (const char *filename)\n{\n  struct stat finfo;\n\n  return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));\n}\n\n#if defined (VISIBLE_STATS)\n \nstatic int\nstat_char (char *filename)\n{\n  struct stat finfo;\n  int character, r;\n  char *f;\n  const char *fn;\n\n   \n#if __CYGWIN__\n  if (filename[0] == '/' && filename[1] == '/' && strchr (filename+2, '/') == 0)\n    return '/';\n#endif\n\n  f = 0;\n  if (rl_filename_stat_hook)\n    {\n      f = savestring (filename);\n      (*rl_filename_stat_hook) (&f);\n      fn = f;\n    }\n  else\n    fn = filename;\n    \n#if defined (HAVE_LSTAT) && defined (S_ISLNK)\n  r = lstat (fn, &finfo);\n#else\n  r = stat (fn, &finfo);\n#endif\n\n  if (r == -1)\n    {\n      xfree (f);\n      return (0);\n    }\n\n  character = 0;\n  if (S_ISDIR (finfo.st_mode))\n    character = '/';\n#if defined (S_ISCHR)\n  else if (S_ISCHR (finfo.st_mode))\n    character = '%';\n#endif  \n#if defined (S_ISBLK)\n  else if (S_ISBLK (finfo.st_mode))\n    character = '#';\n#endif  \n#if defined (S_ISLNK)\n  else if (S_ISLNK (finfo.st_mode))\n    character = '@';\n#endif  \n#if defined (S_ISSOCK)\n  else if (S_ISSOCK (finfo.st_mode))\n    character = '=';\n#endif  \n#if defined (S_ISFIFO)\n  else if (S_ISFIFO (finfo.st_mode))\n    character = '|';\n#endif\n  else if (S_ISREG (finfo.st_mode))\n    {\n#if defined (_WIN32) && !defined (__CYGWIN__)\n      char *ext;\n\n       \n      ext = strrchr (fn, '.');\n      if (ext && (_rl_stricmp (ext, \".exe\") == 0 ||\n\t\t  _rl_stricmp (ext, \".cmd\") == 0 ||\n\t\t  _rl_stricmp (ext, \".bat\") == 0 ||\n\t\t  _rl_stricmp (ext, \".com\") == 0))\n\tcharacter = '*';\n#else\n      if (access (filename, X_OK) == 0)\n\tcharacter = '*';\n#endif\n    }\n\n  xfree (f);\n  return (character);\n}\n#endif  \n\n#if defined (COLOR_SUPPORT)\nstatic int\ncolored_stat_start (const char *filename)\n{\n  _rl_set_normal_color ();\n  return (_rl_print_color_indicator (filename));\n}\n\nstatic void\ncolored_stat_end (void)\n{\n  _rl_prep_non_filename_text ();\n  _rl_put_indicator (&_rl_color_indicator[C_CLR_TO_EOL]);\n}\n\nstatic int\ncolored_prefix_start (void)\n{\n  _rl_set_normal_color ();\n  return (_rl_print_prefix_color ());\n}\n\nstatic void\ncolored_prefix_end (void)\n{\n  colored_stat_end ();\t\t \n}\n#endif\n\n \nstatic char *\nprintable_part (char *pathname)\n{\n  char *temp, *x;\n\n  if (rl_filename_completion_desired == 0)\t \n    return (pathname);\n\n  temp = strrchr (pathname, '/');\n#if defined (__MSDOS__) || defined (_WIN32)\n  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')\n    temp = pathname + 1;\n#endif\n\n  if (temp == 0 || *temp == '\\0')\n    return (pathname);\n  else if (temp[1] == 0 && temp == pathname)\n    return (pathname);\n   \n  else if (temp[1] == '\\0')\n    {\n      for (x = temp - 1; x > pathname; x--)\n        if (*x == '/')\n          break;\n      return ((*x == '/') ? x + 1 : pathname);\n    }\n  else\n    return ++temp;\n}\n\n \nstatic int\nfnwidth (const char *string)\n{\n  int width, pos;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n  int left, w;\n  size_t clen;\n  WCHAR_T wc;\n\n  left = strlen (string) + 1;\n  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n  width = pos = 0;\n  while (string[pos])\n    {\n      if (CTRL_CHAR (string[pos]) || string[pos] == RUBOUT)\n\t{\n\t  width += 2;\n\t  pos++;\n\t}\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  clen = MBRTOWC (&wc, string + pos, left - pos, &ps);\n\t  if (MB_INVALIDCH (clen))\n\t    {\n\t      width++;\n\t      pos++;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t    }\n\t  else if (MB_NULLWCH (clen))\n\t    break;\n\t  else\n\t    {\n\t      pos += clen;\n\t      w = WCWIDTH (wc);\n\t      width += (w >= 0) ? w : 1;\n\t    }\n#else\n\t  width++;\n\t  pos++;\n#endif\n\t}\n    }\n\n  return width;\n}\n\n#define ELLIPSIS_LEN\t3\n\nstatic int\nfnprint (const char *to_print, int prefix_bytes, const char *real_pathname)\n{\n  int printed_len, w;\n  const char *s;\n  int common_prefix_len, print_len;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n  const char *end;\n  size_t tlen;\n  int width;\n  WCHAR_T wc;\n\n  print_len = strlen (to_print);\n  end = to_print + print_len + 1;\n  memset (&ps, 0, sizeof (mbstate_t));\n#else\n  print_len = strlen (to_print);\n#endif\n\n  printed_len = common_prefix_len = 0;\n\n   \n  if (_rl_completion_prefix_display_length > 0 && prefix_bytes >= print_len)\n    prefix_bytes = 0;\n\n#if defined (COLOR_SUPPORT)\n  if (_rl_colored_stats && (prefix_bytes == 0 || _rl_colored_completion_prefix <= 0))\n    colored_stat_start (real_pathname);\n#endif\n\n  if (prefix_bytes && _rl_completion_prefix_display_length > 0 &&\n      prefix_bytes > _rl_completion_prefix_display_length)\n    {\n      char ellipsis;\n\n      ellipsis = (to_print[prefix_bytes] == '.') ? '_' : '.';\n      for (w = 0; w < ELLIPSIS_LEN; w++)\n\tputc (ellipsis, rl_outstream);\n      printed_len = ELLIPSIS_LEN;\n    }\n#if defined (COLOR_SUPPORT)\n  else if (prefix_bytes && _rl_colored_completion_prefix > 0)\n    {\n      common_prefix_len = prefix_bytes;\n      prefix_bytes = 0;\n       \n      colored_prefix_start ();\n    }\n#endif\n\n  s = to_print + prefix_bytes;\n  while (*s)\n    {\n      if (CTRL_CHAR (*s))\n        {\n          putc ('^', rl_outstream);\n          putc (UNCTRL (*s), rl_outstream);\n          printed_len += 2;\n          s++;\n#if defined (HANDLE_MULTIBYTE)\n\t  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n        }\n      else if (*s == RUBOUT)\n\t{\n\t  putc ('^', rl_outstream);\n\t  putc ('?', rl_outstream);\n\t  printed_len += 2;\n\t  s++;\n#if defined (HANDLE_MULTIBYTE)\n\t  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\t}\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  tlen = MBRTOWC (&wc, s, end - s, &ps);\n\t  if (MB_INVALIDCH (tlen))\n\t    {\n\t      tlen = 1;\n\t      width = 1;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t    }\n\t  else if (MB_NULLWCH (tlen))\n\t    break;\n\t  else\n\t    {\n\t      w = WCWIDTH (wc);\n\t      width = (w >= 0) ? w : 1;\n\t    }\n\t  fwrite (s, 1, tlen, rl_outstream);\n\t  s += tlen;\n\t  printed_len += width;\n#else\n\t  putc (*s, rl_outstream);\n\t  s++;\n\t  printed_len++;\n#endif\n\t}\n      if (common_prefix_len > 0 && (s - to_print) >= common_prefix_len)\n\t{\n#if defined (COLOR_SUPPORT)\n\t   \n\t   \n\t  colored_prefix_end ();\n\t  if (_rl_colored_stats)\n\t    colored_stat_start (real_pathname);\t\t \n#endif\n\t  common_prefix_len = 0;\n\t}\n    }\n\n#if defined (COLOR_SUPPORT)\n   \n  if (_rl_colored_stats)\n    colored_stat_end ();\n#endif\n\n  return printed_len;\n}\n\n \n\nstatic int\nprint_filename (char *to_print, char *full_pathname, int prefix_bytes)\n{\n  int printed_len, extension_char, slen, tlen;\n  char *s, c, *new_full_pathname, *dn;\n\n  extension_char = 0;\n#if defined (COLOR_SUPPORT)\n   \n  if (_rl_colored_stats == 0 || rl_filename_completion_desired == 0)\n#endif\n    printed_len = fnprint (to_print, prefix_bytes, to_print);\n\n  if (rl_filename_completion_desired && (\n#if defined (VISIBLE_STATS)\n     rl_visible_stats ||\n#endif\n#if defined (COLOR_SUPPORT)\n     _rl_colored_stats ||\n#endif\n     _rl_complete_mark_directories))\n    {\n       \n      if (to_print != full_pathname)\n\t{\n\t   \n\t  c = to_print[-1];\n\t  to_print[-1] = '\\0';\n\n\t   \n\t  if (full_pathname == 0 || *full_pathname == 0)\n\t    dn = \"/\";\n\t  else if (full_pathname[0] != '/')\n\t    dn = full_pathname;\n\t  else if (full_pathname[1] == 0)\n\t    dn = \"//\";\t\t \n\t  else\n\t    dn = full_pathname;\n\t  s = tilde_expand (dn);\n\t  if (rl_directory_completion_hook)\n\t    (*rl_directory_completion_hook) (&s);\n\n\t  slen = strlen (s);\n\t  tlen = strlen (to_print);\n\t  new_full_pathname = (char *)xmalloc (slen + tlen + 2);\n\t  strcpy (new_full_pathname, s);\n\t  if (s[slen - 1] == '/')\n\t    slen--;\n\t  else\n\t    new_full_pathname[slen] = '/';\n\t  strcpy (new_full_pathname + slen + 1, to_print);\n\n#if defined (VISIBLE_STATS)\n\t  if (rl_visible_stats)\n\t    extension_char = stat_char (new_full_pathname);\n\t  else\n#endif\n\t  if (_rl_complete_mark_directories)\n\t    {\n\t      dn = 0;\n\t      if (rl_directory_completion_hook == 0 && rl_filename_stat_hook)\n\t\t{\n\t\t  dn = savestring (new_full_pathname);\n\t\t  (*rl_filename_stat_hook) (&dn);\n\t\t  xfree (new_full_pathname);\n\t\t  new_full_pathname = dn;\n\t\t}\n\t      if (path_isdir (new_full_pathname))\n\t\textension_char = '/';\n\t    }\n\n\t   \n#if defined (COLOR_SUPPORT)\n\t  if (_rl_colored_stats)\n\t    printed_len = fnprint (to_print, prefix_bytes, new_full_pathname);\n#endif\n\n\t  xfree (new_full_pathname);\n\t  to_print[-1] = c;\n\t}\n      else\n\t{\n\t  s = tilde_expand (full_pathname);\n#if defined (VISIBLE_STATS)\n\t  if (rl_visible_stats)\n\t    extension_char = stat_char (s);\n\t  else\n#endif\n\t    if (_rl_complete_mark_directories && path_isdir (s))\n\t      extension_char = '/';\n\n\t   \n#if defined (COLOR_SUPPORT)\n\t  if (_rl_colored_stats)\n\t    printed_len = fnprint (to_print, prefix_bytes, s);\n#endif\n\t}\n\n      xfree (s);\n      if (extension_char)\n\t{\n\t  putc (extension_char, rl_outstream);\n\t  printed_len++;\n\t}\n    }\n\n  return printed_len;\n}\n\nstatic char *\nrl_quote_filename (char *s, int rtype, char *qcp)\n{\n  char *r;\n\n  r = (char *)xmalloc (strlen (s) + 2);\n  *r = *rl_completer_quote_characters;\n  strcpy (r + 1, s);\n  if (qcp)\n    *qcp = *rl_completer_quote_characters;\n  return r;\n}\n\n \n\nchar\n_rl_find_completion_word (int *fp, int *dp)\n{\n  int scan, end, found_quote, delimiter, pass_next, isbrk;\n  char quote_char;\n  const char *brkchars;\n\n  end = rl_point;\n  found_quote = delimiter = 0;\n  quote_char = '\\0';\n\n  brkchars = 0;\n  if (rl_completion_word_break_hook)\n    brkchars = (*rl_completion_word_break_hook) ();\n  if (brkchars == 0)\n    brkchars = rl_completer_word_break_characters;\n\n  if (rl_completer_quote_characters)\n    {\n       \n       \n      for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))\n\t{\n\t  if (pass_next)\n\t    {\n\t      pass_next = 0;\n\t      continue;\n\t    }\n\n\t   \n\t  if (quote_char != '\\'' && rl_line_buffer[scan] == '\\\\')\n\t    {\n\t      pass_next = 1;\n\t      found_quote |= RL_QF_BACKSLASH;\n\t      continue;\n\t    }\n\n\t  if (quote_char != '\\0')\n\t    {\n\t       \n\t      if (rl_line_buffer[scan] == quote_char)\n\t\t{\n\t\t   \n\t\t  quote_char = '\\0';\n\t\t  rl_point = end;\n\t\t}\n\t    }\n\t  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))\n\t    {\n\t       \n\t      quote_char = rl_line_buffer[scan];\n\t      rl_point = scan + 1;\n\t       \n\t      if (quote_char == '\\'')\n\t\tfound_quote |= RL_QF_SINGLE_QUOTE;\n\t      else if (quote_char == '\"')\n\t\tfound_quote |= RL_QF_DOUBLE_QUOTE;\n\t      else\n\t\tfound_quote |= RL_QF_OTHER_QUOTE;      \n\t    }\n\t}\n    }\n\n  if (rl_point == end && quote_char == '\\0')\n    {\n       \n      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))\n\t{\n\t  scan = rl_line_buffer[rl_point];\n\n\t  if (strchr (brkchars, scan) == 0)\n\t    continue;\n\n\t   \n\t  if (rl_char_is_quoted_p && found_quote &&\n\t      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))\n\t    continue;\n\n\t   \n\t  break;\n\t}\n    }\n\n   \n  scan = rl_line_buffer[rl_point];\n\n   \n  if (scan)\n    {\n      if (rl_char_is_quoted_p)\n\tisbrk = (found_quote == 0 ||\n\t\t(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&\n\t\tstrchr (brkchars, scan) != 0;\n      else\n\tisbrk = strchr (brkchars, scan) != 0;\n\n      if (isbrk)\n\t{\n\t   \n\t  if (rl_basic_quote_characters &&\n\t      strchr (rl_basic_quote_characters, scan) &&\n\t      (end - rl_point) > 1)\n\t    delimiter = scan;\n\n\t   \n\t  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)\n\t    rl_point++;\n\t}\n    }\n\n  if (fp)\n    *fp = found_quote;\n  if (dp)\n    *dp = delimiter;\n\n  return (quote_char);\n}\n\nstatic char **\ngen_completion_matches (char *text, int start, int end, rl_compentry_func_t *our_func, int found_quote, int quote_char)\n{\n  char **matches;\n\n  rl_completion_found_quote = found_quote;\n  rl_completion_quote_character = quote_char;\n\n   \n  if (rl_attempted_completion_function)\n    {\n      matches = (*rl_attempted_completion_function) (text, start, end);\n      if (RL_SIG_RECEIVED())\n\t{\n\t  _rl_free_match_list (matches);\n\t  matches = 0;\n\t  RL_CHECK_SIGNALS ();\n\t}\n\n      if (matches || rl_attempted_completion_over)\n\t{\n\t  rl_attempted_completion_over = 0;\n\t  return (matches);\n\t}\n    }\n\n   \n\n   \n  matches = rl_completion_matches (text, our_func);\n  if (RL_SIG_RECEIVED())\n    {\n      _rl_free_match_list (matches);\n      matches = 0;\n      RL_CHECK_SIGNALS ();\n    }\n  return matches;  \n}\n\n \nstatic char **\nremove_duplicate_matches (char **matches)\n{\n  char *lowest_common;\n  int i, j, newlen;\n  char dead_slot;\n  char **temp_array;\n\n   \n  for (i = 0; matches[i]; i++)\n    ;\n\n   \n  if (i && rl_sort_completion_matches)\n    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);\n\n   \n  lowest_common = savestring (matches[0]);\n\n  for (i = newlen = 0; matches[i + 1]; i++)\n    {\n      if (strcmp (matches[i], matches[i + 1]) == 0)\n\t{\n\t  xfree (matches[i]);\n\t  matches[i] = (char *)&dead_slot;\n\t}\n      else\n\tnewlen++;\n    }\n\n   \n  temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));\n  for (i = j = 1; matches[i]; i++)\n    {\n      if (matches[i] != (char *)&dead_slot)\n\ttemp_array[j++] = matches[i];\n    }\n  temp_array[j] = (char *)NULL;\n\n  if (matches[0] != (char *)&dead_slot)\n    xfree (matches[0]);\n\n   \n  temp_array[0] = lowest_common;\n\n   \n  if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)\n    {\n      xfree (temp_array[1]);\n      temp_array[1] = (char *)NULL;\n    }\n  return (temp_array);\n}\n\n \nstatic int\ncompute_lcd_of_matches (char **match_list, int matches, const char *text)\n{\n  register int i, c1, c2, si;\n  int low;\t\t \n  int lx;\n  char *dtext;\t\t \n#if defined (HANDLE_MULTIBYTE)\n  int v;\n  size_t v1, v2;\n  mbstate_t ps1, ps2;\n  WCHAR_T wc1, wc2;\n#endif\n\n   \n  if (matches == 1)\n    {\n      match_list[0] = match_list[1];\n      match_list[1] = (char *)NULL;\n      return 1;\n    }\n\n  for (i = 1, low = 100000; i < matches; i++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  memset (&ps1, 0, sizeof (mbstate_t));\n\t  memset (&ps2, 0, sizeof (mbstate_t));\n\t}\n#endif\n      for (si = 0; (c1 = match_list[i][si]) && (c2 = match_list[i + 1][si]); si++)\n\t{\n\t    if (_rl_completion_case_fold)\n\t      {\n\t        c1 = _rl_to_lower (c1);\n\t        c2 = _rl_to_lower (c2);\n\t      }\n#if defined (HANDLE_MULTIBYTE)\n\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t      {\n\t\tv1 = MBRTOWC (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);\n\t\tv2 = MBRTOWC (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);\n\t\tif (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n\t\t  {\n\t\t    if (c1 != c2)\t \n\t\t      break;\n\t\t    continue;\n\t\t  }\n\t\tif (_rl_completion_case_fold)\n\t\t  {\n\t\t    wc1 = towlower (wc1);\n\t\t    wc2 = towlower (wc2);\n\t\t  }\n\t\tif (wc1 != wc2)\n\t\t  break;\n\t\telse if (v1 > 1)\n\t\t  si += v1 - 1;\n\t      }\n\t    else\n#endif\n\t    if (c1 != c2)\n\t      break;\n\t}\n\n      if (low > si)\n\tlow = si;\n    }\n\n   \n  if (low == 0 && text && *text)\n    {\n      match_list[0] = (char *)xmalloc (strlen (text) + 1);\n      strcpy (match_list[0], text);\n    }\n  else\n    {\n      match_list[0] = (char *)xmalloc (low + 1);\n\n       \n\n       \n      if (_rl_completion_case_fold)\n\t{\n\t   \n\t  dtext = (char *)NULL;\n\t  if (rl_filename_completion_desired &&\n\t      rl_filename_dequoting_function &&\n\t      rl_completion_found_quote &&\n\t      rl_filename_quoting_desired)\n\t    {\n\t      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);\n\t      text = dtext;\n\t    }\n\n\t   \n\t  if (rl_sort_completion_matches)\n\t    qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);\n\n\t  si = strlen (text);\n\t  lx = (si <= low) ? si : low;\t \n\t   \n\t  for (i = 1; i <= matches; i++)\n\t    if (strncmp (match_list[i], text, lx) == 0)\n\t      {\n\t\tstrncpy (match_list[0], match_list[i], low);\n\t\tbreak;\n\t      }\n\t   \n\t  if (i > matches)\n\t    strncpy (match_list[0], match_list[1], low);\n\n\t  FREE (dtext);\n\t}\n      else\n        strncpy (match_list[0], match_list[1], low);\n\n      match_list[0][low] = '\\0';\n    }\n\n  return matches;\n}\n\nstatic int\npostprocess_matches (char ***matchesp, int matching_filenames)\n{\n  char *t, **matches, **temp_matches;\n  int nmatch, i;\n\n  matches = *matchesp;\n\n  if (matches == 0)\n    return 0;\n\n   \n  if (rl_ignore_completion_duplicates)\n    {\n      temp_matches = remove_duplicate_matches (matches);\n      xfree (matches);\n      matches = temp_matches;\n    }\n\n   \n  if (rl_ignore_some_completions_function && matching_filenames)\n    {\n      for (nmatch = 1; matches[nmatch]; nmatch++)\n\t;\n      (void)(*rl_ignore_some_completions_function) (matches);\n      if (matches == 0 || matches[0] == 0)\n\t{\n\t  FREE (matches);\n\t  *matchesp = (char **)0;\n\t  return 0;\n        }\n      else\n\t{\n\t   \n\t  for (i = 1; matches[i]; i++)\n\t    ;\n\t  if (i > 1 && i < nmatch)\n\t    {\n\t      t = matches[0];\n\t      compute_lcd_of_matches (matches, i - 1, t);\n\t      FREE (t);\n\t    }\n\t}\n    }\n\n  *matchesp = matches;\n  return (1);\n}\n\nstatic int\ncomplete_get_screenwidth (void)\n{\n  int cols;\n  char *envcols;\n\n  cols = _rl_completion_columns;\n  if (cols >= 0 && cols <= _rl_screenwidth)\n    return cols;\n  envcols = getenv (\"COLUMNS\");\n  if (envcols && *envcols)\n    cols = atoi (envcols);\n  if (cols >= 0 && cols <= _rl_screenwidth)\n    return cols;\n  return _rl_screenwidth;\n}\n\n \nvoid\nrl_display_match_list (char **matches, int len, int max)\n{\n  int count, limit, printed_len, lines, cols;\n  int i, j, k, l, common_length, sind;\n  char *temp, *t;\n\n   \n  common_length = sind = 0;\n  if (_rl_completion_prefix_display_length > 0)\n    {\n      t = printable_part (matches[0]);\n       \n      temp = rl_filename_completion_desired ? strrchr (t, '/') : 0;\n      common_length = temp ? fnwidth (temp) : fnwidth (t);\n      sind = temp ? strlen (temp) : strlen (t);\n      if (common_length > max || sind > max)\n\tcommon_length = sind = 0;\n\n      if (common_length > _rl_completion_prefix_display_length && common_length > ELLIPSIS_LEN)\n\tmax -= common_length - ELLIPSIS_LEN;\n      else if (_rl_colored_completion_prefix <= 0)\n\tcommon_length = sind = 0;\n    }\n#if defined (COLOR_SUPPORT)\n  else if (_rl_colored_completion_prefix > 0)\n    {\n      t = printable_part (matches[0]);\n      temp = rl_filename_completion_desired ? strrchr (t, '/') : 0;\n      common_length = temp ? fnwidth (temp) : fnwidth (t);\n      sind = temp ? RL_STRLEN (temp+1) : RL_STRLEN (t);\t\t \n      if (common_length > max || sind > max)\n\tcommon_length = sind = 0;\n    }\n#endif\n\n   \n  cols = complete_get_screenwidth ();\n  max += 2;\n  limit = cols / max;\n  if (limit != 1 && (limit * max == cols))\n    limit--;\n\n   \n  if (cols < _rl_screenwidth && limit < 0)\n    limit = 1;\n\n   \n  if (limit == 0)\n    limit = 1;\n\n   \n  count = (len + (limit - 1)) / limit;\n\n   \n\n   \n  if (rl_ignore_completion_duplicates == 0 && rl_sort_completion_matches)\n    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);\n\n  rl_crlf ();\n\n  lines = 0;\n  if (_rl_print_completions_horizontally == 0)\n    {\n       \n      for (i = 1; i <= count; i++)\n\t{\n\t  for (j = 0, l = i; j < limit; j++)\n\t    {\n\t      if (l > len || matches[l] == 0)\n\t\tbreak;\n\t      else\n\t\t{\n\t\t  temp = printable_part (matches[l]);\n\t\t  printed_len = print_filename (temp, matches[l], sind);\n\n\t\t  if (j + 1 < limit)\n\t\t    {\n\t\t      if (max <= printed_len)\n\t\t\tputc (' ', rl_outstream);\n\t\t      else\n\t\t\tfor (k = 0; k < max - printed_len; k++)\n\t\t\t  putc (' ', rl_outstream);\n\t\t    }\n\t\t}\n\t      l += count;\n\t    }\n\t  rl_crlf ();\n#if defined (SIGWINCH)\n\t  if (RL_SIG_RECEIVED () && RL_SIGWINCH_RECEIVED() == 0)\n#else\n\t  if (RL_SIG_RECEIVED ())\n#endif\n\t    return;\n\t  lines++;\n\t  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)\n\t    {\n\t      lines = _rl_internal_pager (lines);\n\t      if (lines < 0)\n\t\treturn;\n\t    }\n\t}\n    }\n  else\n    {\n       \n      for (i = 1; matches[i]; i++)\n\t{\n\t  temp = printable_part (matches[i]);\n\t  printed_len = print_filename (temp, matches[i], sind);\n\t   \n#if defined (SIGWINCH)\n\t  if (RL_SIG_RECEIVED () && RL_SIGWINCH_RECEIVED() == 0)\n#else\n\t  if (RL_SIG_RECEIVED ())\n#endif\n\t    return;\n\t  if (matches[i+1])\n\t    {\n\t      if (limit == 1 || (i && (limit > 1) && (i % limit) == 0))\n\t\t{\n\t\t  rl_crlf ();\n\t\t  lines++;\n\t\t  if (_rl_page_completions && lines >= _rl_screenheight - 1)\n\t\t    {\n\t\t      lines = _rl_internal_pager (lines);\n\t\t      if (lines < 0)\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t      else if (max <= printed_len)\n\t\tputc (' ', rl_outstream);\n\t      else\n\t\tfor (k = 0; k < max - printed_len; k++)\n\t\t  putc (' ', rl_outstream);\n\t    }\n\t}\n      rl_crlf ();\n    }\n}\n\n \nstatic void\ndisplay_matches (char **matches)\n{\n  int len, max, i;\n  char *temp;\n\n   \n  _rl_move_vert (_rl_vis_botlin);\n\n   \n  if (matches[1] == 0)\n    {\n      temp = printable_part (matches[0]);\n      rl_crlf ();\n      print_filename (temp, matches[0], 0);\n      rl_crlf ();\n\n      rl_forced_update_display ();\n      rl_display_fixed = 1;\n\n      return;\n    }\n\n   \n  for (max = 0, i = 1; matches[i]; i++)\n    {\n      temp = printable_part (matches[i]);\n      len = fnwidth (temp);\n\n      if (len > max)\n\tmax = len;\n    }\n\n  len = i - 1;\n\n   \n  if (rl_completion_display_matches_hook)\n    {\n      (*rl_completion_display_matches_hook) (matches, len, max);\n      return;\n    }\n\t\n   \n  if (rl_completion_query_items > 0 && len >= rl_completion_query_items)\n    {\n      rl_crlf ();\n      fprintf (rl_outstream, \"Display all %d possibilities? (y or n)\", len);\n      fflush (rl_outstream);\n      if ((completion_y_or_n = get_y_or_n (0)) == 0)\n\t{\n\t  rl_crlf ();\n\n\t  rl_forced_update_display ();\n\t  rl_display_fixed = 1;\n\n\t  return;\n\t}\n    }\n\n  rl_display_match_list (matches, len, max);\n\n  rl_forced_update_display ();\n  rl_display_fixed = 1;\n}\n\n \nstatic char *\nmake_quoted_replacement (char *match, int mtype, char *qc)\n{\n  int should_quote, do_replace;\n  char *replacement;\n\n   \n  replacement = match;\n\n  should_quote = match && rl_completer_quote_characters &&\n\t\t\trl_filename_completion_desired &&\n\t\t\trl_filename_quoting_desired;\n\n  if (should_quote)\n    should_quote = should_quote && (!qc || !*qc ||\n\t\t     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));\n\n  if (should_quote)\n    {\n       \n      should_quote = rl_filename_quote_characters\n\t\t\t? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)\n\t\t\t: 0;\n\n      do_replace = should_quote ? mtype : NO_MATCH;\n       \n      if (do_replace != NO_MATCH && rl_filename_quoting_function)\n\treplacement = (*rl_filename_quoting_function) (match, do_replace, qc);\n    }\n  return (replacement);\n}\n\nstatic void\ninsert_match (char *match, int start, int mtype, char *qc)\n{\n  char *replacement, *r;\n  char oqc;\n  int end, rlen;\n\n  oqc = qc ? *qc : '\\0';\n  replacement = make_quoted_replacement (match, mtype, qc);\n\n   \n  if (replacement)\n    {\n      rlen = strlen (replacement);\n       \n      if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&\n\t    replacement[0] == *qc)\n\tstart--;\n       \n      else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&\n\t    replacement[0] != oqc)\n\tstart--;\n      end = rl_point - 1;\n       \n      if (qc && *qc && end && rl_line_buffer[rl_point] == *qc && replacement[rlen - 1] == *qc)\n        end++;\n      if (_rl_skip_completed_text)\n\t{\n\t  r = replacement;\n\t  while (start < rl_end && *r && rl_line_buffer[start] == *r)\n\t    {\n\t      start++;\n\t      r++;\n\t    }\n\t  if (start <= end || *r)\n\t    _rl_replace_text (r, start, end);\n\t  rl_point = start + strlen (r);\n\t}\n      else\n\t_rl_replace_text (replacement, start, end);\n      if (replacement != match)\n        xfree (replacement);\n    }\n}\n\n \nstatic int\nappend_to_match (char *text, int delimiter, int quote_char, int nontrivial_match)\n{\n  char temp_string[4], *filename, *fn;\n  int temp_string_index, s;\n  struct stat finfo;\n\n  temp_string_index = 0;\n  if (quote_char && rl_point && rl_completion_suppress_quote == 0 &&\n      rl_line_buffer[rl_point - 1] != quote_char)\n    temp_string[temp_string_index++] = quote_char;\n\n  if (delimiter)\n    temp_string[temp_string_index++] = delimiter;\n  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)\n    temp_string[temp_string_index++] = rl_completion_append_character;\n\n  temp_string[temp_string_index++] = '\\0';\n\n  if (rl_filename_completion_desired)\n    {\n      filename = tilde_expand (text);\n      if (rl_filename_stat_hook)\n        {\n          fn = savestring (filename);\n\t  (*rl_filename_stat_hook) (&fn);\n\t  xfree (filename);\n\t  filename = fn;\n        }\n      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)\n\t\t? LSTAT (filename, &finfo)\n\t\t: stat (filename, &finfo);\n      if (s == 0 && S_ISDIR (finfo.st_mode))\n\t{\n\t  if (_rl_complete_mark_directories  )\n\t    {\n\t       \n\t      if (rl_point && rl_line_buffer[rl_point] == '\\0' && rl_line_buffer[rl_point - 1] == '/')\n\t\t;\n\t      else if (rl_line_buffer[rl_point] != '/')\n\t\trl_insert_text (\"/\");\n\t    }\n\t}\n#ifdef S_ISLNK\n       \n      else if (s == 0 && S_ISLNK (finfo.st_mode) && path_isdir (filename))\n\t;\n#endif\n      else\n\t{\n\t  if (rl_point == rl_end && temp_string_index)\n\t    rl_insert_text (temp_string);\n\t}\n      xfree (filename);\n    }\n  else\n    {\n      if (rl_point == rl_end && temp_string_index)\n\trl_insert_text (temp_string);\n    }\n\n  return (temp_string_index);\n}\n\nstatic void\ninsert_all_matches (char **matches, int point, char *qc)\n{\n  int i;\n  char *rp;\n\n  rl_begin_undo_group ();\n   \n  if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)\n    point--;\n  rl_delete_text (point, rl_point);\n  rl_point = point;\n\n  if (matches[1])\n    {\n      for (i = 1; matches[i]; i++)\n\t{\n\t  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);\n\t  rl_insert_text (rp);\n\t  rl_insert_text (\" \");\n\t  if (rp != matches[i])\n\t    xfree (rp);\n\t}\n    }\n  else\n    {\n      rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);\n      rl_insert_text (rp);\n      rl_insert_text (\" \");\n      if (rp != matches[0])\n\txfree (rp);\n    }\n  rl_end_undo_group ();\n}\n\nvoid\n_rl_free_match_list (char **matches)\n{\n  register int i;\n\n  if (matches == 0)\n    return;\n\n  for (i = 0; matches[i]; i++)\n    xfree (matches[i]);\n  xfree (matches);\n}\n\n \nstatic int\ncompare_match (char *text, const char *match)\n{\n  char *temp;\n  int r;\n\n  if (rl_filename_completion_desired && rl_filename_quoting_desired && \n      rl_completion_found_quote && rl_filename_dequoting_function)\n    {\n      temp = (*rl_filename_dequoting_function) (text, rl_completion_quote_character);\n      r = strcmp (temp, match);\n      xfree (temp);\n      return r;\n    }      \n  return (strcmp (text, match));\n}\n\n \nint\nrl_complete_internal (int what_to_do)\n{\n  char **matches;\n  rl_compentry_func_t *our_func;\n  int start, end, delimiter, found_quote, i, nontrivial_lcd;\n  char *text, *saved_line_buffer;\n  char quote_char;\n  int tlen, mlen, saved_last_completion_failed;\n\n  RL_SETSTATE(RL_STATE_COMPLETING);\n\n  saved_last_completion_failed = last_completion_failed;\n\n  set_completion_defaults (what_to_do);\n\n  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;\n  our_func = rl_completion_entry_function\n\t\t? rl_completion_entry_function\n\t\t: rl_filename_completion_function;\n   \n  end = rl_point;\n  found_quote = delimiter = 0;\n  quote_char = '\\0';\n\n  if (rl_point)\n     \n    quote_char = _rl_find_completion_word (&found_quote, &delimiter);\n\n  start = rl_point;\n  rl_point = end;\n\n  text = rl_copy_text (start, end);\n  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);\n   \n  nontrivial_lcd = matches && compare_match (text, matches[0]) != 0;\n  if (what_to_do == '!' || what_to_do == '@')\n    tlen = strlen (text);\n  xfree (text);\n\n  if (matches == 0)\n    {\n      rl_ding ();\n      FREE (saved_line_buffer);\n      completion_changed_buffer = 0;\n      last_completion_failed = 1;\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_reset_completion_state ();\n      return (0);\n    }\n\n   \n  i = rl_filename_completion_desired;\n\n  if (postprocess_matches (&matches, i) == 0)\n    {\n      rl_ding ();\n      FREE (saved_line_buffer);\n      completion_changed_buffer = 0;\n      last_completion_failed = 1;\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_reset_completion_state ();\n      return (0);\n    }\n\n  if (matches && matches[0] && *matches[0])\n    last_completion_failed = 0;\n\n  switch (what_to_do)\n    {\n    case TAB:\n    case '!':\n    case '@':\n       \n      if (what_to_do == TAB)\n        {\n          if (*matches[0])\n\t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n        }\n      else if (*matches[0] && matches[1] == 0)\n\t \n\tinsert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n      else if (*matches[0])\t \n\t{\n\t  mlen = *matches[0] ? strlen (matches[0]) : 0;\n\t  if (mlen >= tlen)\n\t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n\t}\n\n       \n      if (matches[1])\n\t{\n\t  if (what_to_do == '!')\n\t    {\n\t      display_matches (matches);\n\t      break;\n\t    }\n\t  else if (what_to_do == '@')\n\t    {\n\t      if (nontrivial_lcd == 0)\n\t\tdisplay_matches (matches);\n\t      break;\n\t    }\n\t  else if (rl_editing_mode != vi_mode)\n\t    rl_ding ();\t \n\t}\n      else\n\tappend_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);\n\n      break;\n\n    case '*':\n      insert_all_matches (matches, start, &quote_char);\n      break;\n\n    case '?':\n       \n      if (saved_last_completion_failed && matches[0] && *matches[0] && matches[1] == 0)\n\t{\n\t  insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n\t  append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);\n\t  break;\n\t}\n      \n      if (rl_completion_display_matches_hook == 0)\n\t{\n\t  _rl_sigcleanup = _rl_complete_sigcleanup;\n\t  _rl_sigcleanarg = matches;\n\t  _rl_complete_display_matches_interrupt = 0;\n\t}\n      display_matches (matches);\n      if (_rl_complete_display_matches_interrupt)\n        {\n          matches = 0;\t\t \n          _rl_complete_display_matches_interrupt = 0;\n\t  if (rl_signal_event_hook)\n\t    (*rl_signal_event_hook) ();\t\t \n        }\n      _rl_sigcleanup = 0;\n      _rl_sigcleanarg = 0;\n      break;\n\n    default:\n      _rl_ttymsg (\"bad value %d for what_to_do in rl_complete\", what_to_do);\n      rl_ding ();\n      FREE (saved_line_buffer);\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_free_match_list (matches);\n      _rl_reset_completion_state ();\n      return 1;\n    }\n\n  _rl_free_match_list (matches);\n\n   \n  if (saved_line_buffer)\n    {\n      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;\n      xfree (saved_line_buffer);\n    }\n\n  RL_UNSETSTATE(RL_STATE_COMPLETING);\n  _rl_reset_completion_state ();\n\n  RL_CHECK_SIGNALS ();\n  return 0;\n}\n\n \n \n \n \n \n\n \nchar **\nrl_completion_matches (const char *text, rl_compentry_func_t *entry_function)\n{\n  register int i;\n\n   \n  int match_list_size;\n\n   \n  char **match_list;\n\n   \n  int matches;\n\n   \n  char *string;\n\n  matches = 0;\n  match_list_size = 10;\n  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));\n  match_list[1] = (char *)NULL;\n\n  while (string = (*entry_function) (text, matches))\n    {\n      if (RL_SIG_RECEIVED ())\n\t{\n\t   \n\t  if (entry_function == rl_filename_completion_function)\n\t    {\n\t      for (i = 1; match_list[i]; i++)\n\t\txfree (match_list[i]);\n\t    }\n\t  xfree (match_list);\n\t  match_list = 0;\n\t  match_list_size = 0;\n\t  matches = 0;\n\t  RL_CHECK_SIGNALS ();\n\t}\n\n      if (matches + 1 >= match_list_size)\n\tmatch_list = (char **)xrealloc\n\t  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));\n\n      if (match_list == 0)\n\treturn (match_list);\n\n      match_list[++matches] = string;\n      match_list[matches + 1] = (char *)NULL;\n    }\n\n   \n  if (matches)\n    compute_lcd_of_matches (match_list, matches, text);\n  else\t\t\t\t \n    {\n      xfree (match_list);\n      match_list = (char **)NULL;\n    }\n  return (match_list);\n}\n\n \nchar *\nrl_username_completion_function (const char *text, int state)\n{\n#if defined (__WIN32__) || defined (__OPENNT)\n  return (char *)NULL;\n#else  \n  static char *username = (char *)NULL;\n  static struct passwd *entry;\n  static int namelen, first_char, first_char_loc;\n  char *value;\n\n  if (state == 0)\n    {\n      FREE (username);\n\n      first_char = *text;\n      first_char_loc = first_char == '~';\n\n      username = savestring (&text[first_char_loc]);\n      namelen = strlen (username);\n#if defined (HAVE_GETPWENT)\n      setpwent ();\n#endif\n    }\n\n#if defined (HAVE_GETPWENT)\n  while (entry = getpwent ())\n    {\n       \n      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))\n\tbreak;\n    }\n#endif\n\n  if (entry == 0)\n    {\n#if defined (HAVE_GETPWENT)\n      endpwent ();\n#endif\n      return ((char *)NULL);\n    }\n  else\n    {\n      value = (char *)xmalloc (2 + strlen (entry->pw_name));\n\n      *value = *text;\n\n      strcpy (value + first_char_loc, entry->pw_name);\n\n      if (first_char == '~')\n\trl_filename_completion_desired = 1;\n\n      return (value);\n    }\n#endif  \n}\n\n \nstatic int\ncomplete_fncmp (const char *convfn, int convlen, const char *filename, int filename_len)\n{\n  register char *s1, *s2;\n  int d, len;\n#if defined (HANDLE_MULTIBYTE)\n  size_t v1, v2;\n  mbstate_t ps1, ps2;\n  WCHAR_T wc1, wc2;\n#endif\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (&ps1, 0, sizeof (mbstate_t));\n  memset (&ps2, 0, sizeof (mbstate_t));\n#endif\n\n  if (filename_len == 0)\n    return 1;\n  if (convlen < filename_len)\n    return 0;\n\n  len = filename_len;\n  s1 = (char *)convfn;\n  s2 = (char *)filename;\n\n   \n  if (_rl_completion_case_fold && _rl_completion_case_map)\n    {\n       \n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  do\n\t    {\n\t      v1 = MBRTOWC (&wc1, s1, convlen, &ps1);\n\t      v2 = MBRTOWC (&wc2, s2, filename_len, &ps2);\n\t      if (v1 == 0 && v2 == 0)\n\t\treturn 1;\n\t      else if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n\t\t{\n\t\t  if (*s1 != *s2)\t\t \n\t\t    return 0;\n\t\t  else if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))\n\t\t    return 0;\n\t\t  s1++; s2++; len--;\n\t\t  continue;\n\t\t}\n\t      wc1 = towlower (wc1);\n\t      wc2 = towlower (wc2);\n\t      s1 += v1;\n\t      s2 += v1;\n\t      len -= v1;\n\t      if ((wc1 == L'-' || wc1 == L'_') && (wc2 == L'-' || wc2 == L'_'))\n\t        continue;\n\t      if (wc1 != wc2)\n\t\treturn 0;\n\t    }\n\t  while (len != 0);\n\t}\n      else\n#endif\n\t{\n\tdo\n\t  {\n\t    d = _rl_to_lower (*s1) - _rl_to_lower (*s2);\n\t     \n\t    if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))\n\t      d = 0;\n\t    if (d != 0)\n\t      return 0;\n\t    s1++; s2++;\t \n\t  }\n\twhile (--len != 0);\n\t}\n\n      return 1;\n    }\n  else if (_rl_completion_case_fold)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  do\n\t    {\n\t      v1 = MBRTOWC (&wc1, s1, convlen, &ps1);\n\t      v2 = MBRTOWC (&wc2, s2, filename_len, &ps2);\n\t      if (v1 == 0 && v2 == 0)\n\t\treturn 1;\n\t      else if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n\t\t{\n\t\t  if (*s1 != *s2)\t\t \n\t\t    return 0;\n\t\t  s1++; s2++; len--;\n\t\t  continue;\n\t\t}\n\t      wc1 = towlower (wc1);\n\t      wc2 = towlower (wc2);\n\t      if (wc1 != wc2)\n\t\treturn 0;\n\t      s1 += v1;\n\t      s2 += v1;\n\t      len -= v1;\n\t    }\n\t  while (len != 0);\n\t  return 1;\n\t}\n      else\n#endif\n      if ((_rl_to_lower (convfn[0]) == _rl_to_lower (filename[0])) &&\n\t  (convlen >= filename_len) &&\n\t  (_rl_strnicmp (filename, convfn, filename_len) == 0))\n\treturn 1;\n    }\n  else\n    {\n      if ((convfn[0] == filename[0]) &&\n\t  (convlen >= filename_len) &&\n\t  (strncmp (filename, convfn, filename_len) == 0))\n\treturn 1;\n    }\n  return 0;\n}\n\n \nchar *\nrl_filename_completion_function (const char *text, int state)\n{\n  static DIR *directory = (DIR *)NULL;\n  static char *filename = (char *)NULL;\n  static char *dirname = (char *)NULL;\n  static char *users_dirname = (char *)NULL;\n  static int filename_len;\n  char *temp, *dentry, *convfn;\n  int dirlen, dentlen, convlen;\n  int tilde_dirname;\n  struct dirent *entry;\n\n   \n  if (state == 0)\n    {\n       \n      if (directory)\n\t{\n\t  closedir (directory);\n\t  directory = (DIR *)NULL;\n\t}\n      FREE (dirname);\n      FREE (filename);\n      FREE (users_dirname);\n\n      filename = savestring (text);\n      if (*text == 0)\n\ttext = \".\";\n      dirname = savestring (text);\n\n      temp = strrchr (dirname, '/');\n\n#if defined (__MSDOS__) || defined (_WIN32)\n       \n      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')\n        temp = strrchr (dirname + 3, '/');\n#endif\n\n      if (temp)\n\t{\n\t  strcpy (filename, ++temp);\n\t  *temp = '\\0';\n\t}\n#if defined (__MSDOS__) || (defined (_WIN32) && !defined (__CYGWIN__))\n       \n      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')\n        {\n          strcpy (filename, dirname + 2);\n          dirname[2] = '\\0';\n        }\n#endif\n      else\n\t{\n\t  dirname[0] = '.';\n\t  dirname[1] = '\\0';\n\t}\n\n       \n\n       \n      if (rl_completion_found_quote && rl_filename_dequoting_function)\n\tusers_dirname = (*rl_filename_dequoting_function) (dirname, rl_completion_quote_character);\n      else\n\tusers_dirname = savestring (dirname);\n\n      tilde_dirname = 0;\n      if (*dirname == '~')\n\t{\n\t  temp = tilde_expand (dirname);\n\t  xfree (dirname);\n\t  dirname = temp;\n\t  tilde_dirname = 1;\n\t}\n\n       \n      if (rl_directory_rewrite_hook)\n\t(*rl_directory_rewrite_hook) (&dirname);\n      else if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))\n\t{\n\t  xfree (users_dirname);\n\t  users_dirname = savestring (dirname);\n\t}\n      else if (tilde_dirname == 0 && rl_completion_found_quote && rl_filename_dequoting_function)\n\t{\n\t   \n\t  xfree (dirname);\n\t  dirname = savestring (users_dirname);\n\t}\n      directory = opendir (dirname);\n\n       \n      if (*filename && rl_completion_found_quote && rl_filename_dequoting_function)\n\t{\n\t   \n\t  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);\n\t  xfree (filename);\n\t  filename = temp;\n\t}\n      filename_len = strlen (filename);\n\n      rl_filename_completion_desired = 1;\n    }\n\n   \n   \n\n   \n\n  entry = (struct dirent *)NULL;\n  while (directory && (entry = readdir (directory)))\n    {\n      convfn = dentry = entry->d_name;\n      convlen = dentlen = D_NAMLEN (entry);\n\n      if (rl_filename_rewrite_hook)\n\t{\n\t  convfn = (*rl_filename_rewrite_hook) (dentry, dentlen);\n\t  convlen = (convfn == dentry) ? dentlen : strlen (convfn);\n\t}\n\n       \n      if (filename_len == 0)\n\t{\n\t  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))\n\t    continue;\n\n\t  if (convfn[0] != '.' ||\n\t       (convfn[1] && (convfn[1] != '.' || convfn[2])))\n\t    break;\n\t}\n      else\n\t{\n\t  if (complete_fncmp (convfn, convlen, filename, filename_len))\n\t    break;\n\t}\n    }\n\n  if (entry == 0)\n    {\n      if (directory)\n\t{\n\t  closedir (directory);\n\t  directory = (DIR *)NULL;\n\t}\n      if (dirname)\n\t{\n\t  xfree (dirname);\n\t  dirname = (char *)NULL;\n\t}\n      if (filename)\n\t{\n\t  xfree (filename);\n\t  filename = (char *)NULL;\n\t}\n      if (users_dirname)\n\t{\n\t  xfree (users_dirname);\n\t  users_dirname = (char *)NULL;\n\t}\n\n      return (char *)NULL;\n    }\n  else\n    {\n       \n      if (dirname && (dirname[0] != '.' || dirname[1]))\n\t{\n\t  if (rl_complete_with_tilde_expansion && *users_dirname == '~')\n\t    {\n\t      dirlen = strlen (dirname);\n\t      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));\n\t      strcpy (temp, dirname);\n\t       \n\t      if (dirname[dirlen - 1] != '/')\n\t        {\n\t          temp[dirlen++] = '/';\n\t          temp[dirlen] = '\\0';\n\t        }\n\t    }\n\t  else\n\t    {\n\t      dirlen = strlen (users_dirname);\n\t      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));\n\t      strcpy (temp, users_dirname);\n\t       \n\t      if (users_dirname[dirlen - 1] != '/')\n\t\ttemp[dirlen++] = '/';\n\t    }\n\n\t  strcpy (temp + dirlen, convfn);\n\t}\n      else\n\ttemp = savestring (convfn);\n\n      if (convfn != dentry)\n\txfree (convfn);\n\n      return (temp);\n    }\n}\n\n \nint\nrl_old_menu_complete (int count, int invoking_key)\n{\n  rl_compentry_func_t *our_func;\n  int matching_filenames, found_quote;\n\n  static char *orig_text;\n  static char **matches = (char **)0;\n  static int match_list_index = 0;\n  static int match_list_size = 0;\n  static int orig_start, orig_end;\n  static char quote_char;\n  static int delimiter;\n\n   \n  if (rl_last_func != rl_old_menu_complete)\n    {\n       \n      FREE (orig_text);\n      if (matches)\n\t_rl_free_match_list (matches);\n\n      match_list_index = match_list_size = 0;\n      matches = (char **)NULL;\n\n      rl_completion_invoking_key = invoking_key;\n\n      RL_SETSTATE(RL_STATE_COMPLETING);\n\n       \n      set_completion_defaults ('%');\n\n      our_func = rl_menu_completion_entry_function;\n      if (our_func == 0)\n\tour_func = rl_completion_entry_function\n\t\t\t? rl_completion_entry_function\n\t\t\t: rl_filename_completion_function;\n\n       \n      orig_end = rl_point;\n      found_quote = delimiter = 0;\n      quote_char = '\\0';\n\n      if (rl_point)\n\t \n\tquote_char = _rl_find_completion_word (&found_quote, &delimiter);\n\n      orig_start = rl_point;\n      rl_point = orig_end;\n\n      orig_text = rl_copy_text (orig_start, orig_end);\n      matches = gen_completion_matches (orig_text, orig_start, orig_end,\n\t\t\t\t\tour_func, found_quote, quote_char);\n\n       \n      matching_filenames = rl_filename_completion_desired;\n\n      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)\n\t{\n\t  rl_ding ();\n\t  FREE (matches);\n\t  matches = (char **)0;\n\t  FREE (orig_text);\n\t  orig_text = (char *)0;\n\t  completion_changed_buffer = 0;\n\t  RL_UNSETSTATE(RL_STATE_COMPLETING);\n\t  return (0);\n\t}\n\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n\n      for (match_list_size = 0; matches[match_list_size]; match_list_size++)\n        ;\n       \n\n      if (match_list_size > 1 && _rl_complete_show_all)\n\tdisplay_matches (matches);\n    }\n\n   \n\n  if (matches == 0 || match_list_size == 0) \n    {\n      rl_ding ();\n      FREE (matches);\n      matches = (char **)0;\n      completion_changed_buffer = 0;\n      return (0);\n    }\n\n  match_list_index += count;\n  if (match_list_index < 0)\n    {\n      while (match_list_index < 0)\n\tmatch_list_index += match_list_size;\n    }\n  else\n    match_list_index %= match_list_size;\n\n  if (match_list_index == 0 && match_list_size > 1)\n    {\n      rl_ding ();\n      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);\n    }\n  else\n    {\n      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);\n      append_to_match (matches[match_list_index], delimiter, quote_char,\n\t\t       compare_match (orig_text, matches[match_list_index]));\n    }\n\n  completion_changed_buffer = 1;\n  return (0);\n}\n\n \n \nint\nrl_menu_complete (int count, int ignore)\n{\n  rl_compentry_func_t *our_func;\n  int matching_filenames, found_quote;\n\n  static char *orig_text;\n  static char **matches = (char **)0;\n  static int match_list_index = 0;\n  static int match_list_size = 0;\n  static int nontrivial_lcd = 0;\n  static int full_completion = 0;\t \n  static int orig_start, orig_end;\n  static char quote_char;\n  static int delimiter, cstate;\n\n   \n  if ((rl_last_func != rl_menu_complete && rl_last_func != rl_backward_menu_complete) || full_completion)\n    {\n       \n      FREE (orig_text);\n      if (matches)\n\t_rl_free_match_list (matches);\n\n      match_list_index = match_list_size = 0;\n      matches = (char **)NULL;\n\n      full_completion = 0;\n\n      RL_SETSTATE(RL_STATE_COMPLETING);\n\n       \n      set_completion_defaults ('%');\n\n      our_func = rl_menu_completion_entry_function;\n      if (our_func == 0)\n\tour_func = rl_completion_entry_function\n\t\t\t? rl_completion_entry_function\n\t\t\t: rl_filename_completion_function;\n\n       \n      orig_end = rl_point;\n      found_quote = delimiter = 0;\n      quote_char = '\\0';\n\n      if (rl_point)\n\t \n\tquote_char = _rl_find_completion_word (&found_quote, &delimiter);\n\n      orig_start = rl_point;\n      rl_point = orig_end;\n\n      orig_text = rl_copy_text (orig_start, orig_end);\n      matches = gen_completion_matches (orig_text, orig_start, orig_end,\n\t\t\t\t\tour_func, found_quote, quote_char);\n\n      nontrivial_lcd = matches && compare_match (orig_text, matches[0]) != 0;\n\n       \n      matching_filenames = rl_filename_completion_desired;\n\n      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)\n\t{\n\t  rl_ding ();\n\t  FREE (matches);\n\t  matches = (char **)0;\n\t  FREE (orig_text);\n\t  orig_text = (char *)0;\n\t  completion_changed_buffer = 0;\n\t  RL_UNSETSTATE(RL_STATE_COMPLETING);\n\t  return (0);\n\t}\n\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n\n      for (match_list_size = 0; matches[match_list_size]; match_list_size++)\n        ;\n\n      if (match_list_size == 0) \n\t{\n\t  rl_ding ();\n\t  FREE (matches);\n\t  matches = (char **)0;\n\t  match_list_index = 0;\n\t  completion_changed_buffer = 0;\n\t  return (0);\n        }\n\n       \n      if (*matches[0])\n\t{\n\t  insert_match (matches[0], orig_start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n\t  orig_end = orig_start + strlen (matches[0]);\n\t  completion_changed_buffer = STREQ (orig_text, matches[0]) == 0;\n\t}\n\n      if (match_list_size > 1 && _rl_complete_show_all)\n\t{\n\t  display_matches (matches);\n\t   \n\t  if (rl_completion_query_items > 0 && match_list_size >= rl_completion_query_items)\n\t    {\n\t      rl_ding ();\n\t      FREE (matches);\n\t      matches = (char **)0;\n\t      full_completion = 1;\n\t      return (0);\n\t    }\n\t  else if (_rl_menu_complete_prefix_first)\n\t    {\n\t      rl_ding ();\n\t      return (0);\n\t    }\n\t}\n      else if (match_list_size <= 1)\n\t{\n\t  append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);\n\t  full_completion = 1;\n\t  return (0);\n\t}\n      else if (_rl_menu_complete_prefix_first && match_list_size > 1)\n\t{\n\t  rl_ding ();\n\t  return (0);\n\t}\n    }\n\n   \n\n  if (matches == 0 || match_list_size == 0) \n    {\n      rl_ding ();\n      FREE (matches);\n      matches = (char **)0;\n      completion_changed_buffer = 0;\n      return (0);\n    }\n\n  match_list_index += count;\n  if (match_list_index < 0)\n    {\n      while (match_list_index < 0)\n\tmatch_list_index += match_list_size;\n    }\n  else\n    match_list_index %= match_list_size;\n\n  if (match_list_index == 0 && match_list_size > 1)\n    {\n      rl_ding ();\n      insert_match (matches[0], orig_start, MULT_MATCH, &quote_char);\n    }\n  else\n    {\n      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);\n      append_to_match (matches[match_list_index], delimiter, quote_char,\n\t\t       compare_match (orig_text, matches[match_list_index]));\n    }\n\n  completion_changed_buffer = 1;\n  return (0);\n}\n\nint\nrl_backward_menu_complete (int count, int key)\n{\n   \n  return (rl_menu_complete (-count, key));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}