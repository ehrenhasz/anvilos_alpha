{
  "module_name": "util.c",
  "hash_id": "231db313a470d3bd7ea9906ccff371ac452f5d906d3905a2edac01a8416f7e13",
  "original_prompt": "Ingested from readline-8.2/util.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"posixjmp.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>            \n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n#include <ctype.h>\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#if defined (TIOCSTAT_IN_SYS_IOCTL)\n#  include <sys/ioctl.h>\n#endif  \n\n \n#include \"readline.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n#include \"rlshell.h\"\n\n \n \n \n \n \n\n \n\nint _rl_allow_pathname_alphabetic_chars = 0;\nstatic const char * const pathname_alphabetic_chars = \"/-_=~.#$\";\n\nint\nrl_alphabetic (int c)\n{\n  if (_rl_alphabetic_p (c))\n    return (1);\n\n  return (_rl_allow_pathname_alphabetic_chars &&\n\t    strchr (pathname_alphabetic_chars, c) != NULL);\n}\n\n#if defined (HANDLE_MULTIBYTE)\nint\n_rl_walphabetic (WCHAR_T wc)\n{\n  int c;\n\n  if (iswalnum (wc))\n    return (1);     \n\n  c = wc & 0177;\n  return (_rl_allow_pathname_alphabetic_chars &&\n\t    strchr (pathname_alphabetic_chars, c) != NULL);\n}\n#endif\n\n \nint\n_rl_abort_internal (void)\n{\n  if (RL_ISSTATE (RL_STATE_TIMEOUT) == 0)\n    rl_ding ();\t\t\t \n  rl_clear_message ();\n  _rl_reset_argument ();\n  rl_clear_pending_input ();\n  rl_deactivate_mark ();\n\n  while (rl_executing_macro)\n    _rl_pop_executing_macro ();\n  _rl_kill_kbd_macro ();\n\n  RL_UNSETSTATE (RL_STATE_MULTIKEY);\t \n\n  rl_last_func = (rl_command_func_t *)NULL;\n\n  _rl_longjmp (_rl_top_level, 1);\n  return (0);\n}\n\nint\nrl_abort (int count, int key)\n{\n  return (_rl_abort_internal ());\n}\n\nint\n_rl_null_function (int count, int key)\n{\n  return 0;\n}\n\nint\nrl_tty_status (int count, int key)\n{\n#if defined (TIOCSTAT)\n  ioctl (1, TIOCSTAT, (char *)0);\n  rl_refresh_line (count, key);\n#else\n  rl_ding ();\n#endif\n  return 0;\n}\n\n \nchar *\nrl_copy_text (int from, int to)\n{\n  register int length;\n  char *copy;\n\n   \n  if (from > to)\n    SWAP (from, to);\n\n  length = to - from;\n  copy = (char *)xmalloc (1 + length);\n  strncpy (copy, rl_line_buffer + from, length);\n  copy[length] = '\\0';\n  return (copy);\n}\n\n \nvoid\nrl_extend_line_buffer (int len)\n{\n  while (len >= rl_line_buffer_len)\n    {\n      rl_line_buffer_len += DEFAULT_BUFFER_SIZE;\n      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);\n    }\n\n  _rl_set_the_line ();\n}\n\n\n \nint\nrl_tilde_expand (int ignore, int key)\n{\n  register int start, end;\n  char *homedir, *temp;\n  int len;\n\n  end = rl_point;\n  start = end - 1;\n\n  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')\n    {\n      homedir = tilde_expand (\"~\");\n      _rl_replace_text (homedir, start, end);\n      xfree (homedir);\n      return (0);\n    }\n  else if (start >= 0 && rl_line_buffer[start] != '~')\n    {\n      for (; start >= 0 && !whitespace (rl_line_buffer[start]); start--)\n        ;\n      start++;\n    }\n  else if (start < 0)\n    start = 0;\n\n  end = start;\n  do\n    end++;\n  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);\n\n  if (whitespace (rl_line_buffer[end]) || end >= rl_end)\n    end--;\n\n   \n  if (rl_line_buffer[start] == '~')\n    {\n      len = end - start + 1;\n      temp = (char *)xmalloc (len + 1);\n      strncpy (temp, rl_line_buffer + start, len);\n      temp[len] = '\\0';\n      homedir = tilde_expand (temp);\n      xfree (temp);\n\n      _rl_replace_text (homedir, start, end);\n      xfree (homedir);\n    }\n\n  return (0);\n}\n\n#if defined (USE_VARARGS)\nvoid\n#if defined (PREFER_STDARG)\n_rl_ttymsg (const char *format, ...)\n#else\n_rl_ttymsg (va_alist)\n     va_dcl\n#endif\n{\n  va_list args;\n#if defined (PREFER_VARARGS)\n  char *format;\n#endif\n\n#if defined (PREFER_STDARG)\n  va_start (args, format);\n#else\n  va_start (args);\n  format = va_arg (args, char *);\n#endif\n\n  fprintf (stderr, \"readline: \");\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n  fflush (stderr);\n\n  va_end (args);\n\n  rl_forced_update_display ();\n}\n\nvoid\n#if defined (PREFER_STDARG)\n_rl_errmsg (const char *format, ...)\n#else\n_rl_errmsg (va_alist)\n     va_dcl\n#endif\n{\n  va_list args;\n#if defined (PREFER_VARARGS)\n  char *format;\n#endif\n\n#if defined (PREFER_STDARG)\n  va_start (args, format);\n#else\n  va_start (args);\n  format = va_arg (args, char *);\n#endif\n\n  fprintf (stderr, \"readline: \");\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n  fflush (stderr);\n\n  va_end (args);\n}\n\n#else  \nvoid\n_rl_ttymsg (format, arg1, arg2)\n     char *format;\n{\n  fprintf (stderr, \"readline: \");\n  fprintf (stderr, format, arg1, arg2);\n  fprintf (stderr, \"\\n\");\n\n  rl_forced_update_display ();\n}\n\nvoid\n_rl_errmsg (format, arg1, arg2)\n     char *format;\n{\n  fprintf (stderr, \"readline: \");\n  fprintf (stderr, format, arg1, arg2);\n  fprintf (stderr, \"\\n\");\n}\n#endif  \n\n \n \n \n \n \n\n \nchar *\n_rl_strindex (const char *s1, const char *s2)\n{\n  register int i, l, len;\n\n  for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)\n    if (_rl_strnicmp (s1 + i, s2, l) == 0)\n      return ((char *) (s1 + i));\n  return ((char *)NULL);\n}\n\n#ifndef HAVE_STRPBRK\n \nchar *\n_rl_strpbrk (const char *string1, const char *string2)\n{\n  register const char *scan;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n  register int i, v;\n\n  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n  for (; *string1; string1++)\n    {\n      for (scan = string2; *scan; scan++)\n\t{\n\t  if (*string1 == *scan)\n\t    return ((char *)string1);\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  v = _rl_get_char_len (string1, &ps);\n\t  if (v > 1)\n\t    string1 += v - 1;\t \n\t}\n#endif\n    }\n  return ((char *)NULL);\n}\n#endif\n\n#if !defined (HAVE_STRCASECMP)\n \nint\n_rl_strnicmp (const char *string1, const char *string2, int count)\n{\n  register const char *s1;\n  register const char *s2;\n  register int d;\n\n  if (count <= 0 || (string1 == string2))\n    return 0;\n\n  s1 = string1;\n  s2 = string2;\n  do\n    {\n      d = _rl_to_lower (*s1) - _rl_to_lower (*s2);\t \n      if (d != 0)\n\treturn d;\n      if (*s1++ == '\\0')\n        break;\n      s2++;\n    }\n  while (--count != 0);\n\n  return (0);\n}\n\n \nint\n_rl_stricmp (const char *string1, const char *string2)\n{\n  register const char *s1;\n  register const char *s2;\n  register int d;\n\n  s1 = string1;\n  s2 = string2;\n\n  if (s1 == s2)\n    return 0;\n\n  while ((d = _rl_to_lower (*s1) - _rl_to_lower (*s2)) == 0)\n    {\n      if (*s1++ == '\\0')\n        return 0;\n      s2++;\n    }\n\n  return (d);\n}\n#endif  \n\n \nint\n_rl_qsort_string_compare (char **s1, char **s2)\n{\n#if defined (HAVE_STRCOLL)\n  return (strcoll (*s1, *s2));\n#else\n  int result;\n\n  result = **s1 - **s2;\n  if (result == 0)\n    result = strcmp (*s1, *s2);\n\n  return result;\n#endif\n}\n\n \n#define FUNCTION_FOR_MACRO(f)\tint (f) (int c) { return f (c); }\n\nFUNCTION_FOR_MACRO (_rl_digit_p)\nFUNCTION_FOR_MACRO (_rl_digit_value)\nFUNCTION_FOR_MACRO (_rl_lowercase_p)\nFUNCTION_FOR_MACRO (_rl_pure_alphabetic)\nFUNCTION_FOR_MACRO (_rl_to_lower)\nFUNCTION_FOR_MACRO (_rl_to_upper)\nFUNCTION_FOR_MACRO (_rl_uppercase_p)\n\n \nvoid\nrl_free (void *mem)\n{\n  if (mem)\n    free (mem);\n}\n\n \n#undef _rl_savestring\nchar *\n_rl_savestring (const char *s)\n{\n  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));\n}\n\n#if defined (DEBUG)\n#if defined (USE_VARARGS)\nstatic FILE *_rl_tracefp;\n\nvoid\n#if defined (PREFER_STDARG)\n_rl_trace (const char *format, ...)\n#else\n_rl_trace (va_alist)\n     va_dcl\n#endif\n{\n  va_list args;\n#if defined (PREFER_VARARGS)\n  char *format;\n#endif\n\n#if defined (PREFER_STDARG)\n  va_start (args, format);\n#else\n  va_start (args);\n  format = va_arg (args, char *);\n#endif\n\n  if (_rl_tracefp == 0)\n    _rl_tropen ();\n  vfprintf (_rl_tracefp, format, args);\n  fprintf (_rl_tracefp, \"\\n\");\n  fflush (_rl_tracefp);\n\n  va_end (args);\n}\n\nint\n_rl_tropen (void)\n{\n  char fnbuf[128], *x;\n\n  if (_rl_tracefp)\n    fclose (_rl_tracefp);\n#if defined (_WIN32) && !defined (__CYGWIN__)\n  x = sh_get_env_value (\"TEMP\");\n  if (x == 0)\n    x = \".\";\n#else\n  x = \"/var/tmp\";\n#endif\n  snprintf (fnbuf, sizeof (fnbuf), \"%s/rltrace.%ld\", x, (long)getpid());\n  unlink(fnbuf);\n  _rl_tracefp = fopen (fnbuf, \"w+\");\n  return _rl_tracefp != 0;\n}\n\nint\n_rl_trclose (void)\n{\n  int r;\n\n  r = fclose (_rl_tracefp);\n  _rl_tracefp = 0;\n  return r;\n}\n\nvoid\n_rl_settracefp (FILE *fp)\n{\n  _rl_tracefp = fp;\n}\n#endif\n#endif  \n\n\n#if HAVE_DECL_AUDIT_USER_TTY && defined (HAVE_LIBAUDIT_H) && defined (ENABLE_TTY_AUDIT_SUPPORT)\n#include <sys/socket.h>\n#include <libaudit.h>\n#include <linux/audit.h>\n#include <linux/netlink.h>\n\n \nvoid\n_rl_audit_tty (char *string)\n{\n  struct audit_message req;\n  struct sockaddr_nl addr;\n  size_t size;\n  int fd;\n\n  fd = socket (PF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n  if (fd < 0)\n    return;\n  size = strlen (string) + 1;\n\n  if (NLMSG_SPACE (size) > MAX_AUDIT_MESSAGE_LENGTH)\n    return;\n\n  memset (&req, 0, sizeof(req));\n  req.nlh.nlmsg_len = NLMSG_SPACE (size);\n  req.nlh.nlmsg_type = AUDIT_USER_TTY;\n  req.nlh.nlmsg_flags = NLM_F_REQUEST;\n  req.nlh.nlmsg_seq = 0;\n  if (size && string)\n    memcpy (NLMSG_DATA(&req.nlh), string, size);\n  memset (&addr, 0, sizeof(addr));\n\n  addr.nl_family = AF_NETLINK;\n  addr.nl_pid = 0;\n  addr.nl_groups = 0;\n\n  sendto (fd, &req, req.nlh.nlmsg_len, 0, (struct sockaddr*)&addr, sizeof(addr));\n  close (fd);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}