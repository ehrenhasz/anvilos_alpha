{
  "module_name": "rlmbutil.h",
  "hash_id": "3e0bdc496467a0f79e15ce296a3ba16e0cd1519a7073b3653d485a89f3af197d",
  "original_prompt": "Ingested from readline-8.2/rlmbutil.h",
  "human_readable_source": " \n\n \n\n#if !defined (_RL_MBUTIL_H_)\n#define _RL_MBUTIL_H_\n\n#include \"rlstdc.h\"\n\n \n \n \n\n \n    \n#if defined (HAVE_WCTYPE_H) && defined (HAVE_WCHAR_H) && defined (HAVE_LOCALE_H)\n#  include <wchar.h>\n#  include <wctype.h>\n#  if defined (HAVE_ISWCTYPE) && \\\n      defined (HAVE_ISWLOWER) && \\\n      defined (HAVE_ISWUPPER) && \\\n      defined (HAVE_MBSRTOWCS) && \\\n      defined (HAVE_MBRTOWC) && \\\n      defined (HAVE_MBRLEN) && \\\n      defined (HAVE_TOWLOWER) && \\\n      defined (HAVE_TOWUPPER) && \\\n      defined (HAVE_WCHAR_T) && \\\n      defined (HAVE_WCWIDTH)\n      \n#    define HANDLE_MULTIBYTE      1\n#  endif\n#endif\n\n \n#if defined (NO_MULTIBYTE_SUPPORT)\n#  undef HANDLE_MULTIBYTE\n#endif\n\n \n#if HANDLE_MULTIBYTE && !defined (HAVE_MBSTATE_T)\n#  define wcsrtombs(dest, src, len, ps) (wcsrtombs) (dest, src, len, 0)\n#  define mbsrtowcs(dest, src, len, ps) (mbsrtowcs) (dest, src, len, 0)\n#  define wcrtomb(s, wc, ps) (wcrtomb) (s, wc, 0)\n#  define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)\n#  define mbrlen(s, n, ps) (mbrlen) (s, n, 0)\n#  define mbstate_t int\n#endif\n\n \n#ifdef HANDLE_MULTIBYTE\n#  include <limits.h>\n#  if defined(MB_LEN_MAX) && (MB_LEN_MAX < 16)\n#    undef MB_LEN_MAX\n#  endif\n#  if !defined (MB_LEN_MAX)\n#    define MB_LEN_MAX 16\n#  endif\n#endif\n\n \n \n \n\n \n#ifdef WCHAR_T_BROKEN\n#  define WCHAR_T char32_t\n#  define MBRTOWC mbrtoc32\n#  define WCRTOMB c32rtomb\n#else\t \n#  define WCHAR_T wchar_t\n#  define MBRTOWC mbrtowc\n#  define WCRTOMB wcrtomb\n#endif\n\n \n\n#define MB_FIND_ANY\t0x00\n#define MB_FIND_NONZERO\t0x01\n\nextern int _rl_find_prev_mbchar (char *, int, int);\nextern int _rl_find_next_mbchar (char *, int, int, int);\n\n#ifdef HANDLE_MULTIBYTE\n\nextern int _rl_compare_chars (char *, int, mbstate_t *, char *, int, mbstate_t *);\nextern int _rl_get_char_len (char *, mbstate_t *);\nextern int _rl_adjust_point (char *, int, mbstate_t *);\n\nextern int _rl_read_mbchar (char *, int);\nextern int _rl_read_mbstring (int, char *, int);\n\nextern int _rl_is_mbchar_matched (char *, int, int, char *, int);\n\nextern WCHAR_T _rl_char_value (char *, int);\nextern int _rl_walphabetic (WCHAR_T);\n\n#define _rl_to_wupper(wc)\t(iswlower (wc) ? towupper (wc) : (wc))\n#define _rl_to_wlower(wc)\t(iswupper (wc) ? towlower (wc) : (wc))\n\n#define MB_NEXTCHAR(b,s,c,f) \\\n\t((MB_CUR_MAX > 1 && rl_byte_oriented == 0) \\\n\t\t? _rl_find_next_mbchar ((b), (s), (c), (f)) \\\n\t\t: ((s) + (c)))\n#define MB_PREVCHAR(b,s,f) \\\n\t((MB_CUR_MAX > 1 && rl_byte_oriented == 0) \\\n\t\t? _rl_find_prev_mbchar ((b), (s), (f)) \\\n\t\t: ((s) - 1))\n\n#define MB_INVALIDCH(x)\t\t((x) == (size_t)-1 || (x) == (size_t)-2)\n#define MB_NULLWCH(x)\t\t((x) == 0)\n\n \nstatic inline int\n_rl_wcwidth (WCHAR_T wc)\n{\n  switch (wc)\n    {\n    case ' ': case '!': case '\"': case '#': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return wcwidth (wc);\n    }\n}\n\n \n#define UNICODE_COMBINING_CHAR(x) ((x) >= 768 && (x) <= 879)\n\n#if defined (WCWIDTH_BROKEN)\n#  define WCWIDTH(wc)\t((_rl_utf8locale && UNICODE_COMBINING_CHAR(wc)) ? 0 : _rl_wcwidth(wc))\n#else\n#  define WCWIDTH(wc)\t_rl_wcwidth(wc)\n#endif\n\n#if defined (WCWIDTH_BROKEN)\n#  define IS_COMBINING_CHAR(x)\t(WCWIDTH(x) == 0 && iswcntrl(x) == 0)\n#else\n#  define IS_COMBINING_CHAR(x)\t(WCWIDTH(x) == 0)\n#endif\n\n#define UTF8_SINGLEBYTE(c)\t(((c) & 0x80) == 0)\n#define UTF8_MBFIRSTCHAR(c)\t(((c) & 0xc0) == 0xc0)\n#define UTF8_MBCHAR(c)\t\t(((c) & 0xc0) == 0x80)\n\n#else  \n\n#undef MB_LEN_MAX\n#undef MB_CUR_MAX\n\n#define MB_LEN_MAX\t1\n#define MB_CUR_MAX\t1\n\n#define _rl_find_prev_mbchar(b, i, f)\t\t(((i) == 0) ? (i) : ((i) - 1))\n#define _rl_find_next_mbchar(b, i1, i2, f)\t((i1) + (i2))\n\n#define _rl_char_value(buf,ind)\t((buf)[(ind)])\n\n#define _rl_walphabetic(c)\t(rl_alphabetic (c))\n\n#define _rl_to_wupper(c)\t(_rl_to_upper (c))\n#define _rl_to_wlower(c)\t(_rl_to_lower (c))\n\n#define MB_NEXTCHAR(b,s,c,f)\t((s) + (c))\n#define MB_PREVCHAR(b,s,f)\t((s) - 1)\n\n#define MB_INVALIDCH(x)\t\t(0)\n#define MB_NULLWCH(x)\t\t(0)\n\n#define UTF8_SINGLEBYTE(c)\t(1)\n\n#if !defined (HAVE_WCHAR_T) && !defined (wchar_t)\n#  define wchar_t int\n#endif\n\n#endif  \n\nextern int rl_byte_oriented;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}