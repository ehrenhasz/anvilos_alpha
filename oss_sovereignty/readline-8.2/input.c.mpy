{
  "module_name": "input.c",
  "hash_id": "30f82bcb3f5c974b827499ba63ed22e333770f0457c24277e9bc76046a2fa560",
  "original_prompt": "Ingested from readline-8.2/input.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (__TANDEM)\n#  define _XOPEN_SOURCE_EXTENDED 1\n#  define _TANDEM_SOURCE 1\n#  include <floss.h>\n#endif\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include <fcntl.h>\n#if defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <signal.h>\n\n#include \"posixselect.h\"\n#include \"posixtime.h\"\n\n#if defined (FIONREAD_IN_SYS_IOCTL)\n#  include <sys/ioctl.h>\n#endif\n\n#include <stdio.h>\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n \n#include \"readline.h\"\n\n#include \"rlprivate.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n \n#if !defined (O_NDELAY) && defined (O_NONBLOCK)\n#  define O_NDELAY O_NONBLOCK\t \n#endif\n\n#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\nextern sigset_t _rl_orig_sigset;\n#endif\n\n \nrl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;\n\n \nrl_hook_func_t *rl_signal_event_hook = (rl_hook_func_t *)NULL;\n\n \nrl_hook_func_t *rl_timeout_event_hook = (rl_hook_func_t *)NULL;\n\n \nrl_hook_func_t *rl_input_available_hook = (rl_hook_func_t *)NULL;\n\nrl_getc_func_t *rl_getc_function = rl_getc;\n\nstatic int _keyboard_input_timeout = 100000;\t\t \n\nstatic int ibuffer_space (void);\nstatic int rl_get_char (int *);\nstatic int rl_gather_tyi (void);\n\n \n#if defined (_WIN32) && !defined (__CYGWIN__)\n#include <io.h>\n#include <conio.h>\n#define WIN32_LEAN_AND_MEAN 1\n#include <windows.h>\n\nint\nwin32_isatty (int fd)\n{\n  if (_isatty(fd))\n    {\n      HANDLE h;\n      DWORD ignored;\n\n      if ((h = (HANDLE) _get_osfhandle (fd)) == INVALID_HANDLE_VALUE)\n\t{\n\t  errno = EBADF;\n\t  return 0;\n\t}\n      if (GetConsoleMode (h, &ignored) != 0)\n\treturn 1;\n    }\n  errno = ENOTTY;\n  return 0;\n}\n\n#define isatty(x)\twin32_isatty(x)\n#endif\n\n \n\n \n#if (defined (HAVE_PSELECT) || defined (HAVE_SELECT)) && !defined (__MINGW32__)\n#  define RL_TIMEOUT_USE_SELECT\n#else\n#  define RL_TIMEOUT_USE_SIGALRM\n#endif\n\nint rl_set_timeout (unsigned int, unsigned int);\nint rl_timeout_remaining (unsigned int *, unsigned int *);\n\nint _rl_timeout_init (void);\nint _rl_timeout_sigalrm_handler (void);\nint _rl_timeout_select (int, fd_set *, fd_set *, fd_set *, const struct timeval *, const sigset_t *);\n\nstatic void _rl_timeout_handle (void);\n#if defined (RL_TIMEOUT_USE_SIGALRM)\nstatic int set_alarm (unsigned int *, unsigned int *);\nstatic void reset_alarm (void);\n#endif\n\n \nstatic struct timeval timeout_point;\nstatic struct timeval timeout_duration;\n\n \n \n \n \n \n\nstatic int pop_index, push_index;\nstatic unsigned char ibuffer[512];\nstatic int ibuffer_len = sizeof (ibuffer) - 1;\n\n#define any_typein (push_index != pop_index)\n\nint\n_rl_any_typein (void)\n{\n  return any_typein;\n}\n\nint\n_rl_pushed_input_available (void)\n{\n  return (push_index != pop_index);\n}\n\n \nstatic int\nibuffer_space (void)\n{\n  if (pop_index > push_index)\n    return (pop_index - push_index - 1);\n  else\n    return (ibuffer_len - (push_index - pop_index));\n}\n\n \nstatic int\nrl_get_char (int *key)\n{\n  if (push_index == pop_index)\n    return (0);\n\n  *key = ibuffer[pop_index++];\n#if 0\n  if (pop_index >= ibuffer_len)\n#else\n  if (pop_index > ibuffer_len)\n#endif\n    pop_index = 0;\n\n  return (1);\n}\n\n \nint\n_rl_unget_char (int key)\n{\n  if (ibuffer_space ())\n    {\n      pop_index--;\n      if (pop_index < 0)\n\tpop_index = ibuffer_len;\n      ibuffer[pop_index] = key;\n      return (1);\n    }\n  return (0);\n}\n\n \nstatic int\nrl_gather_tyi (void)\n{\n  int tty;\n  register int tem, result;\n  int chars_avail, k;\n  char input;\n#if defined(HAVE_SELECT)\n  fd_set readfds, exceptfds;\n  struct timeval timeout;\n#endif\n\n  chars_avail = 0;\n  input = 0;\n  tty = fileno (rl_instream);\n\n#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n  FD_ZERO (&readfds);\n  FD_ZERO (&exceptfds);\n  FD_SET (tty, &readfds);\n  FD_SET (tty, &exceptfds);\n  USEC_TO_TIMEVAL (_keyboard_input_timeout, timeout);\n#if defined (RL_TIMEOUT_USE_SELECT)\n  result = _rl_timeout_select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout, NULL);\n#else\n  result = select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);\n#endif\n  if (result <= 0)\n    return 0;\t \n#endif\n\n  result = -1;\n  errno = 0;\n#if defined (FIONREAD)\n  result = ioctl (tty, FIONREAD, &chars_avail);\n  if (result == -1 && errno == EIO)\n    return -1;\n  if (result == -1)\n    chars_avail = 0;\n#endif\n\n#if defined (O_NDELAY)\n  if (result == -1)\n    {\n      tem = fcntl (tty, F_GETFL, 0);\n\n      fcntl (tty, F_SETFL, (tem | O_NDELAY));\n      chars_avail = read (tty, &input, 1);\n\n      fcntl (tty, F_SETFL, tem);\n      if (chars_avail == -1 && errno == EAGAIN)\n\treturn 0;\n      if (chars_avail == -1 && errno == EIO)\n\treturn -1;\n      if (chars_avail == 0)\t \n\t{\n\t  rl_stuff_char (EOF);\n\t  return (0);\n\t}\n    }\n#endif  \n\n#if defined (__MINGW32__)\n   \n   chars_avail = isatty (tty) ? _kbhit () : 0;\n   result = 0;\n#endif\n\n   \n  if (chars_avail <= 0)\n    return 0;\n\n  tem = ibuffer_space ();\n\n  if (chars_avail > tem)\n    chars_avail = tem;\n\n   \n  if (tem < ibuffer_len)\n    chars_avail = 0;\n\n  if (result != -1)\n    {\n      while (chars_avail--)\n\t{\n\t  RL_CHECK_SIGNALS ();\n\t  k = (*rl_getc_function) (rl_instream);\n\t  if (rl_stuff_char (k) == 0)\n\t    break;\t\t\t \n\t  if (k == NEWLINE || k == RETURN)\n\t    break;\n\t}\n    }\n  else\n    {\n      if (chars_avail)\n\trl_stuff_char (input);\n    }\n\n  return 1;\n}\n\nint\nrl_set_keyboard_input_timeout (int u)\n{\n  int o;\n\n  o = _keyboard_input_timeout;\n  if (u >= 0)\n    _keyboard_input_timeout = u;\n  return (o);\n}\n\n \nint\n_rl_input_available (void)\n{\n#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n  fd_set readfds, exceptfds;\n  struct timeval timeout;\n#endif\n#if !defined (HAVE_SELECT) && defined (FIONREAD)\n  int chars_avail;\n#endif\n  int tty;\n\n  if (rl_input_available_hook)\n    return (*rl_input_available_hook) ();\n\n  tty = fileno (rl_instream);\n\n#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n  FD_ZERO (&readfds);\n  FD_ZERO (&exceptfds);\n  FD_SET (tty, &readfds);\n  FD_SET (tty, &exceptfds);\n  USEC_TO_TIMEVAL (_keyboard_input_timeout, timeout);\n#  if defined (RL_TIMEOUT_USE_SELECT)\n  return (_rl_timeout_select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout, NULL) > 0);\n#  else\n  return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);\n#  endif\n#else\n\n#if defined (FIONREAD)\n  if (ioctl (tty, FIONREAD, &chars_avail) == 0)\n    return (chars_avail);\n#endif\n\n#endif\n\n#if defined (__MINGW32__)\n  if (isatty (tty))\n    return (_kbhit ());\n#endif\n\n  return 0;\n}\n\nint\n_rl_nchars_available ()\n{\n  int chars_avail, fd, result;\n  \n  chars_avail = 0;\n     \n#if defined (FIONREAD)\n  fd = fileno (rl_instream);\n  errno = 0;    \n  result = ioctl (fd, FIONREAD, &chars_avail);    \n  if (result == -1 && errno == EIO)    \n    return -1;    \n#endif\n\n  return chars_avail;\n}\n\nint\n_rl_input_queued (int t)\n{\n  int old_timeout, r;\n\n  old_timeout = rl_set_keyboard_input_timeout (t);\n  r = _rl_input_available ();\n  rl_set_keyboard_input_timeout (old_timeout);\n  return r;\n}\n\nvoid\n_rl_insert_typein (int c)\n{    \t\n  int key, t, i;\n  char *string;\n\n  i = key = 0;\n  string = (char *)xmalloc (ibuffer_len + 1);\n  string[i++] = (char) c;\n\n  while ((t = rl_get_char (&key)) &&\n\t _rl_keymap[key].type == ISFUNC &&\n\t _rl_keymap[key].function == rl_insert)\n    string[i++] = key;\n\n  if (t)\n    _rl_unget_char (key);\n\n  string[i] = '\\0';\n  rl_insert_text (string);\n  xfree (string);\n}\n\n \nint\nrl_stuff_char (int key)\n{\n  if (ibuffer_space () == 0)\n    return 0;\n\n  if (key == EOF)\n    {\n      key = NEWLINE;\n      rl_pending_input = EOF;\n      RL_SETSTATE (RL_STATE_INPUTPENDING);\n    }\n  ibuffer[push_index++] = key;\n#if 0\n  if (push_index >= ibuffer_len)\n#else\n  if (push_index > ibuffer_len)\n#endif\n    push_index = 0;\n\n  return 1;\n}\n\n \nint\nrl_execute_next (int c)\n{\n  rl_pending_input = c;\n  RL_SETSTATE (RL_STATE_INPUTPENDING);\n  return 0;\n}\n\n \nint\nrl_clear_pending_input (void)\n{\n  rl_pending_input = 0;\n  RL_UNSETSTATE (RL_STATE_INPUTPENDING);\n  return 0;\n}\n\n \n \n \n \n \n\n#if defined (RL_TIMEOUT_USE_SIGALRM)\n#  if defined (HAVE_SETITIMER)\n\nstatic int\nset_alarm (unsigned int *secs, unsigned int *usecs)\n{\n  struct itimerval it;\n\n  timerclear (&it.it_interval);\n  timerset (&it.it_value, *secs, *usecs);\n  return setitimer (ITIMER_REAL, &it, NULL);\n}\n\nstatic void\nreset_alarm ()\n{\n  struct itimerval it;\n\n  timerclear (&it.it_interval);\n  timerclear (&it.it_value);\n  setitimer (ITIMER_REAL, &it, NULL);\n}\n#  else\nstatic int\nset_alarm (unsigned int *secs, unsigned int *usecs)\n{\n  if (*secs == 0 || *usecs >= USEC_PER_SEC / 2)\n    (*secs)++;\n  *usecs = 0;\n\n  return alarm (*secs);\n}\nstatic void\nreset_alarm ()\n{\n  alarm (0);\n}\n#  endif\n#endif\n\n \nint\nrl_set_timeout (unsigned int secs, unsigned int usecs)\n{\n  timeout_duration.tv_sec = secs + usecs / USEC_PER_SEC;\n  timeout_duration.tv_usec = usecs % USEC_PER_SEC;\n\n  return 0;\n}\n\n \nint\n_rl_timeout_init (void)\n{\n  unsigned int secs, usecs;\n\n   \n  RL_UNSETSTATE(RL_STATE_TIMEOUT);\n  timerclear (&timeout_point);\n\n   \n  if (timerisunset (&timeout_duration))\n    return 0;\n\n   \n  if (gettimeofday(&timeout_point, 0) != 0)\n    {\n      timerclear (&timeout_point);\n      return -1;\n    }\n\n  secs = timeout_duration.tv_sec;\n  usecs = timeout_duration.tv_usec;\n\n#if defined (RL_TIMEOUT_USE_SIGALRM)\n   \n  if (set_alarm (&secs, &usecs) < 0)\n    return -1;\n#endif\n\n  timeout_point.tv_sec += secs;\n  timeout_point.tv_usec += usecs;\n  if (timeout_point.tv_usec >= USEC_PER_SEC)\n    {\n      timeout_point.tv_sec++;\n      timeout_point.tv_usec -= USEC_PER_SEC;\n    }\n\n  return 0;\n}\n\n \nint\nrl_timeout_remaining (unsigned int *secs, unsigned int *usecs)\n{\n  struct timeval current_time;\n\n   \n  if (timerisunset (&timeout_point))\n    {\n      errno = 0;\n      return -1;\n    }\n\n   \n  if (gettimeofday(&current_time, 0) != 0)\n    return -1;\n\n   \n   \n  if (current_time.tv_sec > timeout_point.tv_sec ||\n\t(current_time.tv_sec == timeout_point.tv_sec &&\n\t current_time.tv_usec >= timeout_point.tv_usec))\n    return 0;\n\n  if (secs && usecs)\n    {\n      *secs = timeout_point.tv_sec - current_time.tv_sec;\n      *usecs = timeout_point.tv_usec - current_time.tv_usec;\n      if (timeout_point.tv_usec < current_time.tv_usec)\n\t{\n\t  (*secs)--;\n\t  *usecs += USEC_PER_SEC;\n\t}\n    }\n\n  return 1;\n}\n\n \n\n#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\nint\n_rl_timeout_select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout, const sigset_t *sigmask)\n{\n  int result;\n#if defined (HAVE_PSELECT)\n  struct timespec ts;\n#else\n  sigset_t origmask;\n  struct timeval tv;\n#endif\n  int tmout_status;\n  struct timeval tmout;\n  unsigned int sec, usec;\n\n   \n  tmout_status = rl_timeout_remaining (&sec, &usec);\n  tmout.tv_sec = sec;\n  tmout.tv_usec = usec;\n\n  if (tmout_status == 0)\n    _rl_timeout_handle ();\n  else if (tmout_status == 1)\n    {\n      if (timeout == NULL || timercmp (&tmout, timeout, <))\n\ttimeout = &tmout;\n      else\n\ttmout_status = -1;\n    }\n\n#if defined (HAVE_PSELECT)\n  if (timeout)\n    {\n      TIMEVAL_TO_TIMESPEC (timeout, &ts);\n      result = pselect (nfds, readfds, writefds, exceptfds, &ts, sigmask);\n    }\n  else\n    result = pselect (nfds, readfds, writefds, exceptfds, NULL, sigmask);\n#else\n  if (sigmask)\n    sigprocmask (SIG_SETMASK, sigmask, &origmask);\n\n  if (timeout)\n    {\n      tv.tv_sec = timeout->tv_sec;\n      tv.tv_usec = timeout->tv_usec;\n      result = select (nfds, readfds, writefds, exceptfds, &tv);\n    }\n  else\n    result = select (nfds, readfds, writefds, exceptfds, NULL);\n\n  if (sigmask)\n    sigprocmask (SIG_SETMASK, &origmask, NULL);\n#endif\n\n  if (tmout_status == 1 && result == 0)\n    _rl_timeout_handle ();\n\n  return result;\n}\n#endif\n\nstatic void\n_rl_timeout_handle ()\n{\n  if (rl_timeout_event_hook)\n    (*rl_timeout_event_hook) ();\n\n  RL_SETSTATE(RL_STATE_TIMEOUT);\n  _rl_abort_internal ();\n}\n\nint\n_rl_timeout_handle_sigalrm ()\n{\n#if defined (RL_TIMEOUT_USE_SIGALRM)\n  if (timerisunset (&timeout_point))\n    return -1;\n\n   \n  if (gettimeofday(&timeout_point, 0) != 0)\n    timerclear (&timeout_point);\n\n  reset_alarm ();\n\n  _rl_timeout_handle ();\n#endif\n  return -1;\n}\n \n \n \n \n \n\n \nint\nrl_read_key (void)\n{\n  int c, r;\n\n  if (rl_pending_input)\n    {\n      c = rl_pending_input;\t \n      rl_clear_pending_input ();\n    }\n  else\n    {\n       \n      if (c = _rl_next_macro_key ())\n\treturn ((unsigned char)c);\n\n       \n      if (rl_event_hook)\n\t{\n\t  while (rl_event_hook)\n\t    {\n\t      if (rl_get_char (&c) != 0)\n\t\tbreak;\n\t\t\n\t      if ((r = rl_gather_tyi ()) < 0)\t \n\t\t{\n\t\t  rl_done = 1;\n\t\t  RL_SETSTATE (RL_STATE_DONE);\n\t\t  return (errno == EIO ? (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF) : '\\n');\n\t\t}\n\t      else if (r > 0)\t\t\t \n\t\tcontinue;\n\n\t      RL_CHECK_SIGNALS ();\n\t      if (rl_done)\t\t \n\t\treturn ('\\n');\n\t      (*rl_event_hook) ();\n\t    }\n\t}\n      else\n\t{\n\t  if (rl_get_char (&c) == 0)\n\t    c = (*rl_getc_function) (rl_instream);\n \n\t  RL_CHECK_SIGNALS ();\n\t}\n    }\n\n  return (c);\n}\n\nint\nrl_getc (FILE *stream)\n{\n  int result;\n  unsigned char c;\n  int fd;\n#if defined (HAVE_PSELECT)\n  sigset_t empty_set;\n  fd_set readfds;\n#endif\n\n  fd = fileno (stream);\n  while (1)\n    {\n      RL_CHECK_SIGNALS ();\n\n       \n\n#if defined (__MINGW32__)\n      if (isatty (fd)\n\treturn (_getch ());\t \n#endif\n      result = 0;\n#if defined (HAVE_PSELECT) || defined (HAVE_SELECT)\n       \n      FD_ZERO (&readfds);\n      FD_SET (fd, &readfds);\n#  if defined (HANDLE_SIGNALS)\n      result = _rl_timeout_select (fd + 1, &readfds, NULL, NULL, NULL, &_rl_orig_sigset);\n#  else\n      sigemptyset (&empty_set);\n      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &empty_set);\n      result = _rl_timeout_select (fd + 1, &readfds, NULL, NULL, NULL, &empty_set);\n#  endif  \n      if (result == 0)\n        _rl_timeout_handle ();\t\t \n#endif\n      if (result >= 0)\n\tresult = read (fd, &c, sizeof (unsigned char));\n\n      if (result == sizeof (unsigned char))\n\treturn (c);\n\n       \n      if (result == 0)\n\treturn (EOF);\n\n#if defined (__BEOS__)\n      if (errno == EINTR)\n\tcontinue;\n#endif\n\n#if defined (EWOULDBLOCK)\n#  define X_EWOULDBLOCK EWOULDBLOCK\n#else\n#  define X_EWOULDBLOCK -99\n#endif\n\n#if defined (EAGAIN)\n#  define X_EAGAIN EAGAIN\n#else\n#  define X_EAGAIN -99\n#endif\n\n      if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)\n\t{\n\t  if (sh_unset_nodelay_mode (fd) < 0)\n\t    return (EOF);\n\t  continue;\n\t}\n\n#undef X_EWOULDBLOCK\n#undef X_EAGAIN\n\n \n\nhandle_error:\n       \n      if (errno != EINTR)\n\treturn (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);\n       \n#if defined (SIGHUP)\n      else if (_rl_caught_signal == SIGHUP || _rl_caught_signal == SIGTERM)\n#else\n      else if (_rl_caught_signal == SIGTERM)\n#endif\n\treturn (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);\n       \n#if defined (SIGQUIT)\n      else if (_rl_caught_signal == SIGINT || _rl_caught_signal == SIGQUIT)\n#else\n      else if (_rl_caught_signal == SIGINT)\n#endif\n        RL_CHECK_SIGNALS ();\n#if defined (SIGTSTP)\n      else if (_rl_caught_signal == SIGTSTP)\n\tRL_CHECK_SIGNALS ();\n#endif\n       \n#if defined (SIGWINCH)\n      else if (_rl_caught_signal == SIGWINCH)\n\tRL_CHECK_SIGNALS ();\n#endif  \n#if defined (SIGALRM)\n      else if (_rl_caught_signal == SIGALRM\n#  if defined (SIGVTALRM)\n\t\t|| _rl_caught_signal == SIGVTALRM\n#  endif\n\t      )\n        RL_CHECK_SIGNALS ();\n#endif   \n\n      if (rl_signal_event_hook)\n\t(*rl_signal_event_hook) ();\n    }\n}\n\n#if defined (HANDLE_MULTIBYTE)\n \nint\n_rl_read_mbchar (char *mbchar, int size)\n{\n  int mb_len, c;\n  size_t mbchar_bytes_length;\n  WCHAR_T wc;\n  mbstate_t ps, ps_back;\n\n  memset(&ps, 0, sizeof (mbstate_t));\n  memset(&ps_back, 0, sizeof (mbstate_t));\n\n  mb_len = 0;  \n  while (mb_len < size)\n    {\n      c = (mb_len == 0) ? _rl_bracketed_read_key () : rl_read_key ();\n\n      if (c < 0)\n\tbreak;\n\n      mbchar[mb_len++] = c;\n\n      mbchar_bytes_length = MBRTOWC (&wc, mbchar, mb_len, &ps);\n      if (mbchar_bytes_length == (size_t)(-1))\n\tbreak;\t\t \n      else if (mbchar_bytes_length == (size_t)(-2))\n\t{\n\t   \n\t  ps = ps_back;\n\t  continue;\n\t} \n      else if (mbchar_bytes_length == 0)\n\t{\n\t  mbchar[0] = '\\0';\t \n\t  mb_len = 1;\n\t  break;\n\t}\n      else if (mbchar_bytes_length > (size_t)(0))\n\tbreak;\n    }\n\n  return mb_len;\n}\n\n \nint\n_rl_read_mbstring (int first, char *mb, int mlen)\n{\n  int i, c, n;\n  mbstate_t ps;\n\n  c = first;\n  memset (mb, 0, mlen);\n  for (i = 0; c >= 0 && i < mlen; i++)\n    {\n      mb[i] = (char)c;\n      memset (&ps, 0, sizeof (mbstate_t));\n      n = _rl_get_char_len (mb, &ps);\n      if (n == -2)\n\t{\n\t   \n\t  RL_SETSTATE (RL_STATE_MOREINPUT);\n\t  c = rl_read_key ();\n\t  RL_UNSETSTATE (RL_STATE_MOREINPUT);\n\t}\n      else\n\tbreak;\n    }\n  return c;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}