{
  "module_name": "bind.c",
  "hash_id": "641fbd10701abbc9f419cbde0b86276de126c499cc3c0cf11f8973fe26c81399",
  "original_prompt": "Ingested from readline-8.2/bind.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (__TANDEM)\n#  include <floss.h>\n#endif\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#if defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#include \"posixstat.h\"\n\n \n#include \"rldefs.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n#if !defined (strchr) && !defined (__STDC__)\nextern char *strchr (), *strrchr ();\n#endif  \n\n \nKeymap rl_binding_keymap;\n\nstatic int _rl_skip_to_delim (char *, int, int);\n\n#if defined (USE_VARARGS) && defined (PREFER_STDARG)\nstatic void _rl_init_file_error (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));\n#else\nstatic void _rl_init_file_error ();\n#endif\n\nstatic rl_command_func_t *_rl_function_of_keyseq_internal (const char *, size_t, Keymap, int *);\n\nstatic char *_rl_read_file (char *, size_t *);\nstatic int _rl_read_init_file (const char *, int);\nstatic int glean_key_from_name (char *);\n\nstatic int find_boolean_var (const char *);\nstatic int find_string_var (const char *);\n\nstatic const char *boolean_varname (int);\nstatic const char *string_varname (int);\n\nstatic char *_rl_get_string_variable_value (const char *);\nstatic int substring_member_of_array (const char *, const char * const *);\n\nstatic int _rl_get_keymap_by_name (const char *);\nstatic int _rl_get_keymap_by_map (Keymap);\n\nstatic int currently_reading_init_file;\n\n \nstatic int _rl_prefer_visible_bell = 1;\n\n#define OP_EQ\t1\n#define OP_NE\t2\n#define OP_GT\t3\n#define OP_GE\t4\n#define OP_LT\t5\n#define OP_LE\t6\n\n#define OPSTART(c)\t((c) == '=' || (c) == '!' || (c) == '<' || (c) == '>')\n#define CMPSTART(c)\t((c) == '=' || (c) == '!')\n\n \n \n \n \n \n\n \nint\nrl_add_defun (const char *name, rl_command_func_t *function, int key)\n{\n  if (key != -1)\n    rl_bind_key (key, function);\n  rl_add_funmap_entry (name, function);\n  return 0;\n}\n\n \nint\nrl_bind_key (int key, rl_command_func_t *function)\n{\n  char keyseq[4];\n  int l;\n\n  if (key < 0 || key > largest_char)\n    return (key);\n\n   \n  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)\n    {\n      if (_rl_keymap[ESC].type == ISKMAP)\n\t{\n\t  Keymap escmap;\n\n\t  escmap = FUNCTION_TO_KEYMAP (_rl_keymap, ESC);\n\t  key = UNMETA (key);\n\t  escmap[key].type = ISFUNC;\n\t  escmap[key].function = function;\n\t  return (0);\n\t}\n\n       \n      keyseq[0] = ESC;\n      l = 1;\n      key = UNMETA(key);\n      goto bind_keyseq;\n    }\n\n   \n  if (_rl_keymap[key].type != ISKMAP)\n    {\n      if (_rl_keymap[key].type == ISMACR)\n\txfree ((char *)_rl_keymap[key].function);\n      _rl_keymap[key].type = ISFUNC;\n      _rl_keymap[key].function = function;\n    }\n  else\n    {\n      l = 0;\nbind_keyseq:\n      if (key == '\\\\')\n\t{\n\t  keyseq[l++] = '\\\\';\n\t  keyseq[l++] = '\\\\';\n\t}\n      else if (key == '\\0')\t  \n\t{\n\t  keyseq[l++] = '\\\\';\n\t  keyseq[l++] = '0';\n\t}\n      else\n\tkeyseq[l++] = key;\n      keyseq[l] = '\\0';\n      rl_bind_keyseq (keyseq, function);\n    }\n  rl_binding_keymap = _rl_keymap;\n  return (0);\n}\n\n \nint\nrl_bind_key_in_map (int key, rl_command_func_t *function, Keymap map)\n{\n  int result;\n  Keymap oldmap;\n\n  oldmap = _rl_keymap;\n  _rl_keymap = map;\n  result = rl_bind_key (key, function);\n  _rl_keymap = oldmap;\n  return (result);\n}\n\n \nint\nrl_bind_key_if_unbound_in_map (int key, rl_command_func_t *default_func, Keymap kmap)\n{\n  char *keyseq;\n\n  keyseq = rl_untranslate_keyseq ((unsigned char)key);\n  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));\n}\n\nint\nrl_bind_key_if_unbound (int key, rl_command_func_t *default_func)\n{\n  char *keyseq;\n\n  keyseq = rl_untranslate_keyseq ((unsigned char)key);\n  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));\n}\n\n \nint\nrl_unbind_key (int key)\n{\n  return (rl_bind_key (key, (rl_command_func_t *)NULL));\n}\n\n \nint\nrl_unbind_key_in_map (int key, Keymap map)\n{\n  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));\n}\n\n \nint\nrl_unbind_function_in_map (rl_command_func_t *func, Keymap map)\n{\n  register int i, rval;\n\n  for (i = rval = 0; i < KEYMAP_SIZE; i++)\n    {\n      if (map[i].type == ISFUNC && map[i].function == func)\n\t{\n\t  map[i].function = (rl_command_func_t *)NULL;\n\t  rval = 1;\n\t}\n      else if (map[i].type == ISKMAP)\t\t \n\t{\n\t  int r;\n\t  r = rl_unbind_function_in_map (func, FUNCTION_TO_KEYMAP (map, i));\n\t  if (r == 1)\n\t    rval = 1;\n\t}\n    }\n  return rval;\n}\n\n \nint\nrl_unbind_command_in_map (const char *command, Keymap map)\n{\n  rl_command_func_t *func;\n\n  func = rl_named_function (command);\n  if (func == 0)\n    return 0;\n  return (rl_unbind_function_in_map (func, map));\n}\n\n \nint\nrl_bind_keyseq (const char *keyseq, rl_command_func_t *function)\n{\n  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));\n}\n\n \nint\nrl_bind_keyseq_in_map (const char *keyseq, rl_command_func_t *function, Keymap map)\n{\n  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));\n}\n\n \nint\nrl_set_key (const char *keyseq, rl_command_func_t *function, Keymap map)\n{\n  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));\n}\n\n \nint\nrl_bind_keyseq_if_unbound_in_map (const char *keyseq, rl_command_func_t *default_func, Keymap kmap)\n{\n  rl_command_func_t *func;\n  char *keys;\n  int keys_len;\n\n  if (keyseq)\n    {\n       \n      keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));\n      if (rl_translate_keyseq (keyseq, keys, &keys_len))\n\t{\n\t  xfree (keys);\n\t  return -1;\n\t}\n      func = rl_function_of_keyseq_len (keys, keys_len, kmap, (int *)NULL);\n      xfree (keys);\n#if defined (VI_MODE)\n      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)\n#else\n      if (!func || func == rl_do_lowercase_version)\n#endif\n\treturn (rl_bind_keyseq_in_map (keyseq, default_func, kmap));\n      else\n\treturn 1;\n    }\n  return 0;\n}\n\nint\nrl_bind_keyseq_if_unbound (const char *keyseq, rl_command_func_t *default_func)\n{\n  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));\n}\n\n \nint\nrl_macro_bind (const char *keyseq, const char *macro, Keymap map)\n{\n  char *macro_keys;\n  int macro_keys_len;\n\n  macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);\n\n  if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))\n    {\n      xfree (macro_keys);\n      return -1;\n    }\n  rl_generic_bind (ISMACR, keyseq, macro_keys, map);\n  return 0;\n}\n\n \nint\nrl_generic_bind (int type, const char *keyseq, char *data, Keymap map)\n{\n  char *keys;\n  int keys_len, prevkey, ic;\n  register int i;\n  KEYMAP_ENTRY k;\n  Keymap prevmap;  \n\n  k.function = 0;\n\n   \n  if (keyseq == 0 || *keyseq == 0)\n    {\n      if (type == ISMACR)\n\txfree (data);\n      return -1;\n    }\n\n  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));\n\n   \n  if (rl_translate_keyseq (keyseq, keys, &keys_len))\n    {\n      xfree (keys);\n      return -1;\n    }\n\n  prevmap = map;\n  prevkey = keys[0];\n\n   \n  for (i = 0; i < keys_len; i++)\n    {\n      unsigned char uc = keys[i];\n\n      if (i > 0)\n\tprevkey = ic;\n\n      ic = uc;\n      if (ic < 0 || ic >= KEYMAP_SIZE)\n        {\n          xfree (keys);\n\t  return -1;\n        }\n\n       \n#if 0\n      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)\n\t{\n\t  ic = UNMETA (ic);\n\t  if (map[ESC].type == ISKMAP)\n\t    {\n\t      prevmap = map;\n\t      map = FUNCTION_TO_KEYMAP (map, ESC);\n\t    }\n\t}\n#endif\n\n      if ((i + 1) < keys_len)\n\t{\n\t  if (map[ic].type != ISKMAP)\n\t    {\n\t       \n\t      k = map[ic];\n\n\t      map[ic].type = ISKMAP;\n\t      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());\n\t    }\n\t  prevmap = map;\n\t  map = FUNCTION_TO_KEYMAP (map, ic);\n\t   \n\t  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))\n\t    {\n\t      map[ANYOTHERKEY] = k;\n\t      k.function = 0;\n\t    }\n\t}\n      else\n\t{\n\t  if (map[ic].type == ISKMAP)\n\t    {\n\t      prevmap = map;\n\t      map = FUNCTION_TO_KEYMAP (map, ic);\n\t      ic = ANYOTHERKEY;\n\t       \n\t      if (type == ISFUNC && data == 0)\n\t\tdata = (char *)_rl_null_function;\n\t    }\n\t  if (map[ic].type == ISMACR)\n\t    xfree ((char *)map[ic].function);\n\n\t  map[ic].function = KEYMAP_TO_FUNCTION (data);\n\t  map[ic].type = type;\n\t}\n\n      rl_binding_keymap = map;\n\n    }\n\n   \n   \n  if (type == ISFUNC && data == 0 &&\n      prevmap[prevkey].type == ISKMAP &&\n      (FUNCTION_TO_KEYMAP(prevmap, prevkey) == rl_binding_keymap) &&\n      rl_binding_keymap[ANYOTHERKEY].type == ISFUNC &&\n      rl_empty_keymap (rl_binding_keymap))\n    {\n      prevmap[prevkey].type = rl_binding_keymap[ANYOTHERKEY].type;\n      prevmap[prevkey].function = rl_binding_keymap[ANYOTHERKEY].function;\n      rl_discard_keymap (rl_binding_keymap);\n      rl_binding_keymap = prevmap;\n    }\n\n  xfree (keys);\n  return 0;\n}\n\n \nint\nrl_translate_keyseq (const char *seq, char *array, int *len)\n{\n  register int i, l, temp;\n  int has_control, has_meta;\n  unsigned char c;\n\n  has_control = 0;\n  has_meta = 0;\n\n   \n  for (i = l = 0; (c = seq[i]) || has_control || has_meta; i++)\n    {\n       \n      if (c == '\\\\' && seq[i + 1] != '\\0')\n\t{\n\t  c = seq[++i];\n\n\t   \n\t  if (c == 'C' && seq[i + 1] == '-')\n\t    {\n\t      i++;\n\t      has_control = 1;\n\t      continue;\n\t    }\n\t  else if (c == 'M' && seq[i + 1] == '-')\n\t    {\n\t      i++;\n\t      has_meta = 1;\n\t      continue;\n\t    }\t      \n\n\t   \n\t  switch (c)\n\t    {\n\t    case 'a':\n\t      c = '\\007';\n\t      break;\n\t    case 'b':\n\t      c = '\\b';\n\t      break;\n\t    case 'd':\n\t      c = RUBOUT;\t \n\t      break;\n\t    case 'e':\n\t      c = ESC;\n\t      break;\n\t    case 'f':\n\t      c = '\\f';\n\t      break;\n\t    case 'n':\n\t      c = NEWLINE;\n\t      break;\n\t    case 'r':\n\t      c = RETURN;\n\t      break;\n\t    case 't':\n\t      c = TAB;\n\t      break;\n\t    case 'v':\n\t      c = 0x0B;\n\t      break;\n\t    case '\\\\':\n\t      c = '\\\\';\n\t      break;\n\t    case '0': case '1': case '2': case '3':\n\t    case '4': case '5': case '6': case '7':\n\t      i++;\n\t      for (temp = 2, c -= '0'; ISOCTAL ((unsigned char)seq[i]) && temp--; i++)\n\t        c = (c * 8) + OCTVALUE (seq[i]);\n\t      i--;\t \n\t      c &= largest_char;\n\t      break;\n\t    case 'x':\n\t      i++;\n\t      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)\n\t        c = (c * 16) + HEXVALUE (seq[i]);\n\t      if (temp == 2)\n\t        c = 'x';\n\t      i--;\t \n\t      c &= largest_char;\n\t      break;\n\t    default:\t \n\t      c &= largest_char;\n\t      break;\t \n\t    }\n\t}\n\n       \n      if (has_control)\n\t{\n\t   \n\t  c = (c == '?') ? RUBOUT : CTRL (_rl_to_upper (c));\n\t  has_control = 0;\n\t}\n      if (has_meta)\n\t{\n\t  c = META (c);\n\t  has_meta = 0;\n\t}\n\n       \n      if (META_CHAR (c) && _rl_convert_meta_chars_to_ascii)\n\t{\n\t  array[l++] = ESC;\t \n\t  array[l++] = UNMETA (c);\n\t}\n      else\n\tarray[l++] = (c);\n\n       \n      if (seq[i] == '\\0')\n\tbreak;\n    }\n\n  *len = l;\n  array[l] = '\\0';\n  return (0);\n}\n\nstatic int\n_rl_isescape (int c)\n{\n  switch (c)\n    {\n    case '\\007':\n    case '\\b':\n    case '\\f':\n    case '\\n':\n    case '\\r':\n    case TAB:\n    case 0x0b:  return (1);\n    default: return (0);\n    }\n}\n\nstatic int\n_rl_escchar (int c)\n{\n  switch (c)\n    {\n    case '\\007':  return ('a');\n    case '\\b':  return ('b');\n    case '\\f':  return ('f');\n    case '\\n':  return ('n');\n    case '\\r':  return ('r');\n    case TAB:  return ('t');\n    case 0x0b:  return ('v');\n    default: return (c);\n    }\n}\n\nchar *\nrl_untranslate_keyseq (int seq)\n{\n  static char kseq[16];\n  int i, c;\n\n  i = 0;\n  c = seq;\n  if (META_CHAR (c))\n    {\n      kseq[i++] = '\\\\';\n      kseq[i++] = 'M';\n      kseq[i++] = '-';\n      c = UNMETA (c);\n    }\n  else if (c == ESC)\n    {\n      kseq[i++] = '\\\\';\n      c = 'e';\n    }\n  else if (CTRL_CHAR (c))\n    {\n      kseq[i++] = '\\\\';\n      kseq[i++] = 'C';\n      kseq[i++] = '-';\n      c = _rl_to_lower (UNCTRL (c));\n    }\n  else if (c == RUBOUT)\n    {\n      kseq[i++] = '\\\\';\n      kseq[i++] = 'C';\n      kseq[i++] = '-';\n      c = '?';\n    }\n\n  if (c == ESC)\n    {\n      kseq[i++] = '\\\\';\n      c = 'e';\n    }\n  else if (c == '\\\\' || c == '\"')\n    {\n      kseq[i++] = '\\\\';\n    }\n\n  kseq[i++] = (unsigned char) c;\n  kseq[i] = '\\0';\n  return kseq;\n}\n\nchar *\n_rl_untranslate_macro_value (char *seq, int use_escapes)\n{\n  char *ret, *r, *s;\n  int c;\n\n  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);\n  for (s = seq; *s; s++)\n    {\n      c = *s;\n      if (META_CHAR (c))\n\t{\n\t  *r++ = '\\\\';\n\t  *r++ = 'M';\n\t  *r++ = '-';\n\t  c = UNMETA (c);\n\t}\n      else if (c == ESC)\n\t{\n\t  *r++ = '\\\\';\n\t  c = 'e';\n\t}\n      else if (CTRL_CHAR (c))\n\t{\n\t  *r++ = '\\\\';\n\t  if (use_escapes && _rl_isescape (c))\n\t    c = _rl_escchar (c);\n\t  else\n\t    {\n\t      *r++ = 'C';\n\t      *r++ = '-';\n\t      c = _rl_to_lower (UNCTRL (c));\n\t    }\n\t}\n      else if (c == RUBOUT)\n \t{\n \t  *r++ = '\\\\';\n \t  *r++ = 'C';\n \t  *r++ = '-';\n \t  c = '?';\n \t}\n\n      if (c == ESC)\n\t{\n\t  *r++ = '\\\\';\n\t  c = 'e';\n\t}\n      else if (c == '\\\\' || c == '\"')\n\t*r++ = '\\\\';\n\n      *r++ = (unsigned char)c;\n    }\n  *r = '\\0';\n  return ret;\n}\n\n \nrl_command_func_t *\nrl_named_function (const char *string)\n{\n  register int i;\n\n  rl_initialize_funmap ();\n\n  for (i = 0; funmap[i]; i++)\n    if (_rl_stricmp (funmap[i]->name, string) == 0)\n      return (funmap[i]->function);\n  return ((rl_command_func_t *)NULL);\n}\n\n \nstatic rl_command_func_t *\n_rl_function_of_keyseq_internal (const char *keyseq, size_t len, Keymap map, int *type)\n{\n  register int i;\n\n  if (map == 0)\n    map = _rl_keymap;\n\n  for (i = 0; keyseq && i < len; i++)\n    {\n      unsigned char ic = keyseq[i];\n\n      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)\n\t{\n\t  if (map[ESC].type == ISKMAP)\n\t    {\n\t      map = FUNCTION_TO_KEYMAP (map, ESC);\n\t      ic = UNMETA (ic);\n\t    }\n\t   \n\t  else\n\t    {\n\t      if (type)\n\t\t*type = map[ESC].type;\n\n\t      return (map[ESC].function);\n\t    }\n\t}\n\n      if (map[ic].type == ISKMAP)\n\t{\n\t   \n\t  if (i + 1 == len)\n\t    {\n\t      if (type)\n\t\t*type = ISKMAP;\n\n\t      return (map[ic].function);\n\t    }\n\t  else\n\t    map = FUNCTION_TO_KEYMAP (map, ic);\n\t}\n       \n      else if (map[ic].type != ISKMAP && i+1 < len)\n\treturn ((rl_command_func_t *)NULL);\n      else\t \n\t{\n\t  if (type)\n\t    *type = map[ic].type;\n\n\t  return (map[ic].function);\n\t}\n    }\n  return ((rl_command_func_t *) NULL);\n}\n\nrl_command_func_t *\nrl_function_of_keyseq (const char *keyseq, Keymap map, int *type)\n{\n  return _rl_function_of_keyseq_internal (keyseq, strlen (keyseq), map, type);\n}\n\nrl_command_func_t *\nrl_function_of_keyseq_len (const char *keyseq, size_t len, Keymap map, int *type)\n{\n  return _rl_function_of_keyseq_internal (keyseq, len, map, type);\n}\n\n \nint\nrl_trim_arg_from_keyseq\t(const char *keyseq, size_t len, Keymap map)\n{\n  register int i, j, parsing_digits;\n  unsigned char ic;\n  Keymap map0;\n\n  if (map == 0)\n    map = _rl_keymap;\n  map0 = map;\n\n   \n  for (i = j = parsing_digits = 0; keyseq && i < len; i++)\n    {\n      ic = keyseq[i];\n\n      if (parsing_digits)\n\t{\n\t  if (_rl_digit_p (ic))\n\t    {\n\t      j = i + 1;\n\t      continue;\n\t    }\n\t  parsing_digits = 0;\n\t}\n\n      if (map[ic].type == ISKMAP)\n\t{\n\t  if (i + 1 == len)\n\t    return -1;\n\t  map = FUNCTION_TO_KEYMAP (map, ic);\n\t  continue;\n\t}\n      if (map[ic].type == ISFUNC)\n\t{\n#if defined (VI_MODE)\n\t  if (map[ic].function != rl_digit_argument && map[ic].function != rl_universal_argument && map[ic].function != rl_vi_arg_digit)\n#else\n\t  if (map[ic].function != rl_digit_argument && map[ic].function != rl_universal_argument)\n#endif\n\t    return (j);\n\n\t   \n\t  if (i + 1 == len)\n\t    return -1;\n\n\t  parsing_digits = 1;\n\n\t   \n\t   \n\t  if (map[ic].function == rl_universal_argument && (i + 1 == '-'))\n\t    {\n\t      i++;\n\t      parsing_digits = 2;\n\t    }\n\t  if (map[ic].function == rl_digit_argument && ic == '-')\n\t    {\n\t      parsing_digits = 2;\n\t    }\n\n\t  map = map0;\n\t  j = i + 1;\n\t}\n    }\n\n   \n  return -1;\n}\n  \n \nstatic char *last_readline_init_file = (char *)NULL;\n\n \nstatic const char *current_readline_init_file;\nstatic int current_readline_init_include_level;\nstatic int current_readline_init_lineno;\n\n \nstatic char *\n_rl_read_file (char *filename, size_t *sizep)\n{\n  struct stat finfo;\n  size_t file_size;\n  char *buffer;\n  int i, file;\n\n  file = -1;\n  if (((file = open (filename, O_RDONLY, 0666)) < 0) || (fstat (file, &finfo) < 0))\n    {\n      if (file >= 0)\n\tclose (file);\n      return ((char *)NULL);\n    }\n\n  file_size = (size_t)finfo.st_size;\n\n   \n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      if (file >= 0)\n\tclose (file);\n#if defined (EFBIG)\n      errno = EFBIG;\n#endif\n      return ((char *)NULL);\n    }\n\n   \n  buffer = (char *)xmalloc (file_size + 1);\n  i = read (file, buffer, file_size);\n  close (file);\n\n  if (i < 0)\n    {\n      xfree (buffer);\n      return ((char *)NULL);\n    }\n\n  RL_CHECK_SIGNALS ();\n\n  buffer[i] = '\\0';\n  if (sizep)\n    *sizep = i;\n\n  return (buffer);\n}\n\n \nint\nrl_re_read_init_file (int count, int ignore)\n{\n  int r;\n  r = rl_read_init_file ((const char *)NULL);\n  rl_set_keymap_from_edit_mode ();\n  return r;\n}\n\n \nint\nrl_read_init_file (const char *filename)\n{\n   \n  if (filename == 0)\n    filename = last_readline_init_file;\n  if (filename == 0)\n    filename = sh_get_env_value (\"INPUTRC\");\n  if (filename == 0 || *filename == 0)\n    {\n      filename = DEFAULT_INPUTRC;\n       \n      if (_rl_read_init_file (filename, 0) == 0)\n\treturn 0;\n      filename = SYS_INPUTRC;\n    }\n\n#if defined (__MSDOS__)\n  if (_rl_read_init_file (filename, 0) == 0)\n    return 0;\n  filename = \"~/_inputrc\";\n#endif\n  return (_rl_read_init_file (filename, 0));\n}\n\nstatic int\n_rl_read_init_file (const char *filename, int include_level)\n{\n  register int i;\n  char *buffer, *openname, *line, *end;\n  size_t file_size;\n\n  current_readline_init_file = filename;\n  current_readline_init_include_level = include_level;\n\n  openname = tilde_expand (filename);\n  buffer = _rl_read_file (openname, &file_size);\n  xfree (openname);\n\n  RL_CHECK_SIGNALS ();\n  if (buffer == 0)\n    return (errno);\n  \n  if (include_level == 0 && filename != last_readline_init_file)\n    {\n      FREE (last_readline_init_file);\n      last_readline_init_file = savestring (filename);\n    }\n\n  currently_reading_init_file = 1;\n\n   \n  current_readline_init_lineno = 1;\n  line = buffer;\n  end = buffer + file_size;\n  while (line < end)\n    {\n       \n      for (i = 0; line + i != end && line[i] != '\\n'; i++);\n\n#if defined (__CYGWIN__)\n       \n      if (line[i] == '\\n' && line[i-1] == '\\r')\n\tline[i - 1] = '\\0';\n#endif\n\n       \n      line[i] = '\\0';\n\n       \n      while (*line && whitespace (*line))\n        {\n\t  line++;\n\t  i--;\n        }\n\n       \n      if (*line && *line != '#')\n\trl_parse_and_bind (line);\n\n       \n      line += i + 1;\n      current_readline_init_lineno++;\n    }\n\n  xfree (buffer);\n  currently_reading_init_file = 0;\n  return (0);\n}\n\nstatic void\n#if defined (PREFER_STDARG)\n_rl_init_file_error (const char *format, ...)\n#else\n_rl_init_file_error (va_alist)\n     va_dcl\n#endif\n{\n  va_list args;\n#if defined (PREFER_VARARGS)\n  char *format;\n#endif\n\n#if defined (PREFER_STDARG)\n  va_start (args, format);\n#else\n  va_start (args);\n  format = va_arg (args, char *);\n#endif\n\n  fprintf (stderr, \"readline: \");\n  if (currently_reading_init_file)\n    fprintf (stderr, \"%s: line %d: \", current_readline_init_file,\n\t\t     current_readline_init_lineno);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n  fflush (stderr);\n\n  va_end (args);\n}\n\n \n \n \n \n \n\nstatic int\nparse_comparison_op (s, indp)\n     const char *s;\n     int *indp;\n{\n  int i, peekc, op;\n\n  if (OPSTART (s[*indp]) == 0)\n    return -1;\n  i = *indp;\n  peekc = s[i] ? s[i+1] : 0;\n  op = -1;\n\n  if (s[i] == '=')\n    {\n      op = OP_EQ;\n      if (peekc == '=')\n        i++;\n      i++;\n    }\n  else if (s[i] == '!' && peekc == '=')\n    {\n      op = OP_NE;\n      i += 2;\n    }\n  else if (s[i] == '<' && peekc == '=')\n    {\n      op = OP_LE;\n      i += 2;\n    }\n  else if (s[i] == '>' && peekc == '=')\n    {\n      op = OP_GE;\n      i += 2;\n    }\n  else if (s[i] == '<')\n    {\n      op = OP_LT;\n      i += 1;\n    }\n  else if (s[i] == '>')\n    {\n      op = OP_GT;\n      i += 1;\n    }\n\n  *indp = i;\n  return op;        \n}\n\n \n \n \n \n \n\ntypedef int _rl_parser_func_t (char *);\n\n \nconst char * const _rl_possible_control_prefixes[] = {\n  \"Control-\", \"C-\", \"CTRL-\", (const char *)NULL\n};\n\nconst char * const _rl_possible_meta_prefixes[] = {\n  \"Meta\", \"M-\", (const char *)NULL\n};\n\n \nstatic int parser_if (char *);\nstatic int parser_else (char *);\nstatic int parser_endif (char *);\nstatic int parser_include (char *);\n\n \n\n \nconst char *rl_readline_name = \"other\";\n\n \nstatic unsigned char *if_stack = (unsigned char *)NULL;\nstatic int if_stack_depth;\nstatic int if_stack_size;\n\n \nstatic int\nparser_if (char *args)\n{\n  int i, llen, boolvar, strvar;\n\n  boolvar = strvar = -1;\n\n   \n  if (if_stack_depth + 1 >= if_stack_size)\n    {\n      if (!if_stack)\n\tif_stack = (unsigned char *)xmalloc (if_stack_size = 20);\n      else\n\tif_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);\n    }\n  if_stack[if_stack_depth++] = _rl_parsing_conditionalized_out;\n\n   \n  if (_rl_parsing_conditionalized_out)\n    return 0;\n\n  llen = strlen (args);\n\n   \n  for (i = 0; args[i] && !whitespace (args[i]); i++);\n\n  if (args[i])\n    args[i++] = '\\0';\n\n   \n  if (rl_terminal_name && _rl_strnicmp (args, \"term=\", 5) == 0)\n    {\n      char *tem, *tname;\n\n       \n      tname = savestring (rl_terminal_name);\n      tem = strchr (tname, '-');\n      if (tem)\n\t*tem = '\\0';\n\n       \n      _rl_parsing_conditionalized_out = _rl_stricmp (args + 5, tname) &&\n\t\t\t\t\t_rl_stricmp (args + 5, rl_terminal_name);\n      xfree (tname);\n    }\n#if defined (VI_MODE)\n  else if (_rl_strnicmp (args, \"mode=\", 5) == 0)\n    {\n      int mode;\n\n      if (_rl_stricmp (args + 5, \"emacs\") == 0)\n\tmode = emacs_mode;\n      else if (_rl_stricmp (args + 5, \"vi\") == 0)\n\tmode = vi_mode;\n      else\n\tmode = no_mode;\n\n      _rl_parsing_conditionalized_out = mode != rl_editing_mode;\n    }\n#endif  \n  else if (_rl_strnicmp (args, \"version\", 7) == 0)\n    {\n      int rlversion, versionarg, op, previ, major, minor, opresult;\n\n      _rl_parsing_conditionalized_out = 1;\n      rlversion = RL_VERSION_MAJOR*10 + RL_VERSION_MINOR;\n       \n      if (i > 0 && i <= llen && args[i-1] == '\\0')\n        args[i-1] = ' ';\n      args[llen] = '\\0';\t\t \n      for (i = 7; whitespace (args[i]); i++)\n\t;\n      if (OPSTART(args[i]) == 0)\n\t{\n\t  _rl_init_file_error (\"comparison operator expected, found `%s'\", args[i] ? args + i : \"end-of-line\");\n\t  return 0;\n\t}\n      previ = i;\n      op = parse_comparison_op (args, &i);\n      if (op <= 0)\n\t{\n\t  _rl_init_file_error (\"comparison operator expected, found `%s'\", args+previ);\n\t  return 0;\n\t}\n      for ( ; args[i] && whitespace (args[i]); i++)\n\t;\n      if (args[i] == 0 || _rl_digit_p (args[i]) == 0)\n\t{\n\t  _rl_init_file_error (\"numeric argument expected, found `%s'\", args+i);\n\t  return 0;\n\t}\n      major = minor = 0;\n      previ = i;\n      for ( ; args[i] && _rl_digit_p (args[i]); i++)\n\tmajor = major*10 + _rl_digit_value (args[i]);\n      if (args[i] == '.')\n\t{\n\t  if (args[i + 1] && _rl_digit_p (args [i + 1]) == 0)\n\t    {\n\t      _rl_init_file_error (\"numeric argument expected, found `%s'\", args+previ);\n\t      return 0;\n\t    }\n\t  for (++i; args[i] && _rl_digit_p (args[i]); i++)\n\t    minor = minor*10 + _rl_digit_value (args[i]);\n\t}\n       \n      previ = i;\n      for ( ; args[i] && whitespace (args[i]); i++)\n\t;\n      if (args[i] && args[i] != '#')\n\t{\n\t  _rl_init_file_error (\"trailing garbage on line: `%s'\", args+previ);\n\t  return 0;\n\t}\n      versionarg = major*10 + minor;\n\n      switch (op)\n\t{\n\tcase OP_EQ:\n \t  opresult = rlversion == versionarg;\n\t  break;\n\tcase OP_NE:\n\t  opresult = rlversion != versionarg;\n\t  break;\n\tcase OP_GT:\n\t  opresult = rlversion > versionarg;\n\t  break;\n\tcase OP_GE:\n\t  opresult = rlversion >= versionarg;\n\t  break;\n\tcase OP_LT:\n\t  opresult = rlversion < versionarg;\n\t  break;\n\tcase OP_LE:\n\t  opresult = rlversion <= versionarg;\n\t  break;\n\t}\n      _rl_parsing_conditionalized_out = 1 - opresult;\n    }\n   \n  else if (_rl_stricmp (args, rl_readline_name) == 0)\n    _rl_parsing_conditionalized_out = 0;\n  else if ((boolvar = find_boolean_var (args)) >= 0 || (strvar = find_string_var (args)) >= 0)\n    {\n      int op, previ;\n      size_t vlen;\n      const char *vname;\n      char *valuearg, *vval, prevc;\n\n      _rl_parsing_conditionalized_out = 1;\n      vname = (boolvar >= 0) ? boolean_varname (boolvar) : string_varname (strvar);\n      vlen = strlen (vname);\n      if (i > 0 && i <= llen && args[i-1] == '\\0')\n        args[i-1] = ' ';\n      args[llen] = '\\0';\t\t \n      for (i = vlen; whitespace (args[i]); i++)\n\t;\n      if (CMPSTART(args[i]) == 0)\n\t{\n\t  _rl_init_file_error (\"equality comparison operator expected, found `%s'\", args[i] ? args + i : \"end-of-line\");\n\t  return 0;\n\t}\n      previ = i;\n      op = parse_comparison_op (args, &i);\n      if (op != OP_EQ && op != OP_NE)\n\t{\n\t  _rl_init_file_error (\"equality comparison operator expected, found `%s'\", args+previ);\n\t  return 0;\n\t}\n      for ( ; args[i] && whitespace (args[i]); i++)\n\t;\n      if (args[i] == 0)\n\t{\n\t  _rl_init_file_error (\"argument expected, found `%s'\", args+i);\n\t  return 0;\n\t}\n      previ = i;\n      valuearg = args + i;\n      for ( ; args[i] && whitespace (args[i]) == 0; i++)\n\t;\n      prevc = args[i];\n      args[i] = '\\0';\t\t \n      vval = rl_variable_value (vname);\n      if (op == OP_EQ)\n        _rl_parsing_conditionalized_out = _rl_stricmp (vval, valuearg) != 0;\n      else if (op == OP_NE)\n        _rl_parsing_conditionalized_out = _rl_stricmp (vval, valuearg) == 0;\n      args[i] = prevc;\n    }\n  else\n    _rl_parsing_conditionalized_out = 1;\n  return 0;\n}\n\n \nstatic int\nparser_else (char *args)\n{\n  register int i;\n\n  if (if_stack_depth == 0)\n    {\n      _rl_init_file_error (\"$else found without matching $if\");\n      return 0;\n    }\n\n#if 0\n   \n  for (i = 0; i < if_stack_depth - 1; i++)\n#else\n   \n  for (i = 0; i < if_stack_depth; i++)\n#endif\n    if (if_stack[i] == 1)\n      return 0;\n\n   \n  _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;\n  return 0;\n}\n\n \nstatic int\nparser_endif (char *args)\n{\n  if (if_stack_depth)\n    _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];\n  else\n    _rl_init_file_error (\"$endif without matching $if\");\n  return 0;\n}\n\nstatic int\nparser_include (char *args)\n{\n  const char *old_init_file;\n  char *e;\n  int old_line_number, old_include_level, r;\n\n  if (_rl_parsing_conditionalized_out)\n    return (0);\n\n  old_init_file = current_readline_init_file;\n  old_line_number = current_readline_init_lineno;\n  old_include_level = current_readline_init_include_level;\n\n  e = strchr (args, '\\n');\n  if (e)\n    *e = '\\0';\n  r = _rl_read_init_file ((const char *)args, old_include_level + 1);\n\n  current_readline_init_file = old_init_file;\n  current_readline_init_lineno = old_line_number;\n  current_readline_init_include_level = old_include_level;\n\n  return r;\n}\n  \n \nstatic const struct {\n  const char * const name;\n  _rl_parser_func_t *function;\n} parser_directives [] = {\n  { \"if\", parser_if },\n  { \"endif\", parser_endif },\n  { \"else\", parser_else },\n  { \"include\", parser_include },\n  { (char *)0x0, (_rl_parser_func_t *)0x0 }\n};\n\n \nstatic int\nhandle_parser_directive (char *statement)\n{\n  register int i;\n  char *directive, *args;\n\n   \n\n   \n  for (i = 0; whitespace (statement[i]); i++);\n\n  directive = &statement[i];\n\n  for (; statement[i] && !whitespace (statement[i]); i++);\n\n  if (statement[i])\n    statement[i++] = '\\0';\n\n  for (; statement[i] && whitespace (statement[i]); i++);\n\n  args = &statement[i];\n\n   \n  for (i = 0; parser_directives[i].name; i++)\n    if (_rl_stricmp (directive, parser_directives[i].name) == 0)\n      {\n\t(*parser_directives[i].function) (args);\n\treturn (0);\n      }\n\n   \n  _rl_init_file_error (\"%s: unknown parser directive\", directive);\n  return (1);\n}\n\n \nstatic int\n_rl_skip_to_delim (char *string, int start, int delim)\n{\n  int i, c, passc;\n\n  for (i = start,passc = 0; c = string[i]; i++)\n    {\n      if (passc)\n\t{\n\t  passc = 0;\n\t  if (c == 0)\n\t    break;\n\t  continue;\n\t}\n\n      if (c == '\\\\')\n\t{\n\t  passc = 1;\n\t  continue;\n\t}\n\n      if (c == delim)\n\tbreak;\n    }\n\n  return i;\n}\n\n \nint\nrl_parse_and_bind (char *string)\n{\n  char *funname, *kname;\n  register int c, i;\n  int key, equivalency, foundmod, foundsep;\n\n  while (string && whitespace (*string))\n    string++;\n\n  if (string == 0 || *string == 0 || *string == '#')\n    return 0;\n\n   \n  if (*string == '$')\n    {\n      handle_parser_directive (&string[1]);\n      return 0;\n    }\n\n   \n  if (_rl_parsing_conditionalized_out)\n    return 0;\n\n  i = 0;\n   \n  if (*string == '\"')\n    {\n      i = _rl_skip_to_delim (string, 1, '\"');\n\n       \n      if (string[i] == '\\0')\n        {\n          _rl_init_file_error (\"%s: no closing `\\\"' in key binding\", string);\n          return 1;\n        }\n      else\n        i++;\t \n    }\n\n   \n  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\\t'; i++ );\n\n  if (i == 0)\n    {\n      _rl_init_file_error (\"`%s': invalid key binding: missing key sequence\", string);\n      return 1;\n    }\n\n  equivalency = (c == ':' && string[i + 1] == '=');\n\n  foundsep = c != 0;\n\n   \n  if (string[i])\n    string[i++] = '\\0';\n\n   \n  if (equivalency)\n    string[i++] = '\\0';\n\n   \n  if (_rl_stricmp (string, \"set\") == 0)\n    {\n      char *var, *value, *e;\n      int s;\n\n      var = string + i;\n       \n      while (*var && whitespace (*var)) var++;\n\n       \n      value = var;\n      while (*value && whitespace (*value) == 0) value++;\n      if (*value)\n\t*value++ = '\\0';\n      while (*value && whitespace (*value)) value++;\n\n       \n      if (find_boolean_var (var) >= 0)\n\t{\n\t   \n\t  for (e = value; *e && whitespace (*e) == 0; e++)\n\t    ;\n\t  if (e > value)\n\t    *e = '\\0';\t\t \n\t}\n      else if ((i = find_string_var (var)) >= 0)\n\t{\n\t   \n\t  if (*value == '\"')\n\t    {\n\t      i = _rl_skip_to_delim (value, 1, *value);\n\t      value[i] = '\\0';\n\t      value++;\t \n\t    }\n\t  else\n\t    {\n\t       \n\t      e = value + strlen (value) - 1;\n\t      while (e >= value && whitespace (*e))\n\t\te--;\n\t      e++;\t\t \n\t  \n\t      if (*e && e >= value)\n\t\t*e = '\\0';\n\t    }\n\t}\n      else\n\t{\n\t   \n\t  _rl_init_file_error (\"%s: unknown variable name\", var);\n\t  return 1;\n\t}\n\n      rl_variable_bind (var, value);\n      return 0;\n    }\n\n   \n  for (; string[i] && whitespace (string[i]); i++);\n  funname = &string[i];\n\n   \n   \n   \n  if (*funname == '\\'' || *funname == '\"')\n    {\n      i = _rl_skip_to_delim (string, i+1, *funname);\n      if (string[i])\n\ti++;\n      else\n\t{\n\t  _rl_init_file_error (\"`%s': missing closing quote for macro\", funname);\n\t  return 1;\n\t}\n    }\n\n   \n  for (; string[i] && whitespace (string[i]) == 0; i++);\n\n   \n  string[i] = '\\0';\n\n   \n  if (equivalency)\n    {\n      return 0;\n    }\n\n  if (foundsep == 0)\n    {\n      _rl_init_file_error (\"%s: no key sequence terminator\", string);\n      return 1;\n    }\n\n   \n  if (*string == '\"')\n    {\n      char *seq;\n      register int j, k, passc;\n\n      seq = (char *)xmalloc (1 + strlen (string));\n      for (j = 1, k = passc = 0; string[j]; j++)\n\t{\n\t   \n\t  if (passc || (string[j] == '\\\\'))\n\t    {\n\t      seq[k++] = string[j];\n\t      passc = !passc;\n\t      continue;\n\t    }\n\n\t  if (string[j] == '\"')\n\t    break;\n\n\t  seq[k++] = string[j];\n\t}\n      seq[k] = '\\0';\n\n       \n      if (*funname == '\\'' || *funname == '\"')\n\t{\n\t  j = strlen (funname);\n\n\t   \n\t  if (j && funname[j - 1] == *funname)\n\t    funname[j - 1] = '\\0';\n\n\t  rl_macro_bind (seq, &funname[1], _rl_keymap);\n\t}\n      else\n\trl_bind_keyseq (seq, rl_named_function (funname));\n\n      xfree (seq);\n      return 0;\n    }\n\n   \n  kname = strrchr (string, '-');\n  if (kname == 0)\n    kname = string;\n  else\n    kname++;\n\n  key = glean_key_from_name (kname);\n\n   \n  foundmod = 0;\n  if (substring_member_of_array (string, _rl_possible_control_prefixes))\n    {\n      key = CTRL (_rl_to_upper (key));\n      foundmod = 1;\n    }\n\n  if (substring_member_of_array (string, _rl_possible_meta_prefixes))\n    {\n      key = META (key);\n      foundmod = 1;\n    }\n\n  if (foundmod == 0 && kname != string)\n    {\n      _rl_init_file_error (\"%s: unknown key modifier\", string);\n      return 1;\n    }\n\n   \n  if (*funname == '\\'' || *funname == '\"')\n    {\n      char useq[2];\n      int fl = strlen (funname);\n\n      useq[0] = key; useq[1] = '\\0';\n      if (fl && funname[fl - 1] == *funname)\n\tfunname[fl - 1] = '\\0';\n\n      rl_macro_bind (useq, &funname[1], _rl_keymap);\n    }\n#if defined (PREFIX_META_HACK)\n   \n  else if (_rl_stricmp (funname, \"prefix-meta\") == 0)\n    {\n      char seq[2];\n\n      seq[0] = key;\n      seq[1] = '\\0';\n      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);\n    }\n#endif  \n  else\n    rl_bind_key (key, rl_named_function (funname));\n\n  return 0;\n}\n\n \n\n#define V_SPECIAL\t0x1\n\nstatic const struct {\n  const char * const name;\n  int *value;\n  int flags;\n} boolean_varlist [] = {\n  { \"bind-tty-special-chars\",\t&_rl_bind_stty_chars,\t\t0 },\n  { \"blink-matching-paren\",\t&rl_blink_matching_paren,\tV_SPECIAL },\n  { \"byte-oriented\",\t\t&rl_byte_oriented,\t\t0 },\n#if defined (COLOR_SUPPORT)\n  { \"colored-completion-prefix\",&_rl_colored_completion_prefix,\t0 },\n  { \"colored-stats\",\t\t&_rl_colored_stats,\t\t0 },\n#endif\n  { \"completion-ignore-case\",\t&_rl_completion_case_fold,\t0 },\n  { \"completion-map-case\",\t&_rl_completion_case_map,\t0 },\n  { \"convert-meta\",\t\t&_rl_convert_meta_chars_to_ascii, 0 },\n  { \"disable-completion\",\t&rl_inhibit_completion,\t\t0 },\n  { \"echo-control-characters\",\t&_rl_echo_control_chars,\t0 },\n  { \"enable-active-region\",\t&_rl_enable_active_region,\t0 },\n  { \"enable-bracketed-paste\",\t&_rl_enable_bracketed_paste,\tV_SPECIAL },\n  { \"enable-keypad\",\t\t&_rl_enable_keypad,\t\t0 },\n  { \"enable-meta-key\",\t\t&_rl_enable_meta,\t\t0 },\n  { \"expand-tilde\",\t\t&rl_complete_with_tilde_expansion, 0 },\n  { \"history-preserve-point\",\t&_rl_history_preserve_point,\t0 },\n  { \"horizontal-scroll-mode\",\t&_rl_horizontal_scroll_mode,\t0 },\n  { \"input-meta\",\t\t&_rl_meta_flag,\t\t\t0 },\n  { \"mark-directories\",\t\t&_rl_complete_mark_directories,\t0 },\n  { \"mark-modified-lines\",\t&_rl_mark_modified_lines,\t0 },\n  { \"mark-symlinked-directories\", &_rl_complete_mark_symlink_dirs, 0 },\n  { \"match-hidden-files\",\t&_rl_match_hidden_files,\t0 },\n  { \"menu-complete-display-prefix\", &_rl_menu_complete_prefix_first, 0 },\n  { \"meta-flag\",\t\t&_rl_meta_flag,\t\t\t0 },\n  { \"output-meta\",\t\t&_rl_output_meta_chars,\t\t0 },\n  { \"page-completions\",\t\t&_rl_page_completions,\t\t0 },\n  { \"prefer-visible-bell\",\t&_rl_prefer_visible_bell,\tV_SPECIAL },\n  { \"print-completions-horizontally\", &_rl_print_completions_horizontally, 0 },\n  { \"revert-all-at-newline\",\t&_rl_revert_all_at_newline,\t0 },\n  { \"show-all-if-ambiguous\",\t&_rl_complete_show_all,\t\t0 },\n  { \"show-all-if-unmodified\",\t&_rl_complete_show_unmodified,\t0 },\n  { \"show-mode-in-prompt\",\t&_rl_show_mode_in_prompt,\t0 },\n  { \"skip-completed-text\",\t&_rl_skip_completed_text,\t0 },\n#if defined (VISIBLE_STATS)\n  { \"visible-stats\",\t\t&rl_visible_stats,\t\t0 },\n#endif  \n  { (char *)NULL, (int *)NULL, 0 }\n};\n\nstatic int\nfind_boolean_var (const char *name)\n{\n  register int i;\n\n  for (i = 0; boolean_varlist[i].name; i++)\n    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)\n      return i;\n  return -1;\n}\n\nstatic const char *\nboolean_varname (int i)\n{\n  return ((i >= 0) ? boolean_varlist[i].name : (char *)NULL);\n}  \n\n \nstatic void\nhack_special_boolean_var (int i)\n{\n  const char *name;\n\n  name = boolean_varlist[i].name;\n\n  if (_rl_stricmp (name, \"blink-matching-paren\") == 0)\n    _rl_enable_paren_matching (rl_blink_matching_paren);\n  else if (_rl_stricmp (name, \"prefer-visible-bell\") == 0)\n    {\n      if (_rl_prefer_visible_bell)\n\t_rl_bell_preference = VISIBLE_BELL;\n      else\n\t_rl_bell_preference = AUDIBLE_BELL;\n    }\n  else if (_rl_stricmp (name, \"show-mode-in-prompt\") == 0)\n    _rl_reset_prompt ();\n  else if (_rl_stricmp (name, \"enable-bracketed-paste\") == 0)\n    _rl_enable_active_region = _rl_enable_bracketed_paste;\n}\n\ntypedef int _rl_sv_func_t (const char *);\n\n \n#define V_BELLSTYLE\t0\n#define V_COMBEGIN\t1\n#define V_EDITMODE\t2\n#define V_ISRCHTERM\t3\n#define V_KEYMAP\t4\n\n#define\tV_STRING\t1\n#define V_INT\t\t2\n\n \nstatic int sv_region_start_color (const char *);\nstatic int sv_region_end_color (const char *);\nstatic int sv_bell_style (const char *);\nstatic int sv_combegin (const char *);\nstatic int sv_dispprefix (const char *);\nstatic int sv_compquery (const char *);\nstatic int sv_compwidth (const char *);\nstatic int sv_editmode (const char *);\nstatic int sv_emacs_modestr (const char *);\nstatic int sv_histsize (const char *);\nstatic int sv_isrchterm (const char *);\nstatic int sv_keymap (const char *);\nstatic int sv_seqtimeout (const char *);\nstatic int sv_viins_modestr (const char *);\nstatic int sv_vicmd_modestr (const char *);\n\nstatic const struct {\n  const char * const name;\n  int flags;\n  _rl_sv_func_t *set_func;\n} string_varlist[] = {\n  { \"active-region-end-color\", V_STRING, sv_region_end_color },\n  { \"active-region-start-color\", V_STRING, sv_region_start_color },\n  { \"bell-style\",\tV_STRING,\tsv_bell_style },\n  { \"comment-begin\",\tV_STRING,\tsv_combegin },\n  { \"completion-display-width\", V_INT,\tsv_compwidth },\n  { \"completion-prefix-display-length\", V_INT,\tsv_dispprefix },\n  { \"completion-query-items\", V_INT,\tsv_compquery },\n  { \"editing-mode\",\tV_STRING,\tsv_editmode },\n  { \"emacs-mode-string\", V_STRING,\tsv_emacs_modestr },  \n  { \"history-size\",\tV_INT,\t\tsv_histsize },\n  { \"isearch-terminators\", V_STRING,\tsv_isrchterm },\n  { \"keymap\",\t\tV_STRING,\tsv_keymap },\n  { \"keyseq-timeout\",\tV_INT,\t\tsv_seqtimeout },\n  { \"vi-cmd-mode-string\", V_STRING,\tsv_vicmd_modestr }, \n  { \"vi-ins-mode-string\", V_STRING,\tsv_viins_modestr }, \n  { (char *)NULL,\t0, (_rl_sv_func_t *)0 }\n};\n\nstatic int\nfind_string_var (const char *name)\n{\n  register int i;\n\n  for (i = 0; string_varlist[i].name; i++)\n    if (_rl_stricmp (name, string_varlist[i].name) == 0)\n      return i;\n  return -1;\n}\n\nstatic const char *\nstring_varname (int i)\n{\n  return ((i >= 0) ? string_varlist[i].name : (char *)NULL);\n}  \n\n \nstatic int\nbool_to_int (const char *value)\n{\n  return (value == 0 || *value == '\\0' ||\n\t\t(_rl_stricmp (value, \"on\") == 0) ||\n\t\t(value[0] == '1' && value[1] == '\\0'));\n}\n\nchar *\nrl_variable_value (const char *name)\n{\n  register int i;\n\n   \n  i = find_boolean_var (name);\n  if (i >= 0)\n    return (*boolean_varlist[i].value ? \"on\" : \"off\");\n\n  i = find_string_var (name);\n  if (i >= 0)\n    return (_rl_get_string_variable_value (string_varlist[i].name));\n\n   \n  return (char *)NULL;\n}\n\nint\nrl_variable_bind (const char *name, const char *value)\n{\n  register int i;\n  int\tv;\n\n   \n  i = find_boolean_var (name);\n  if (i >= 0)\n    {\n      *boolean_varlist[i].value = bool_to_int (value);\n      if (boolean_varlist[i].flags & V_SPECIAL)\n\thack_special_boolean_var (i);\n      return 0;\n    }\n\n  i = find_string_var (name);\n\n   \n  if (i < 0 || string_varlist[i].set_func == 0)\n    {\n      if (i < 0)\n\t_rl_init_file_error (\"%s: unknown variable name\", name);\n      return 0;\n    }\n\n  v = (*string_varlist[i].set_func) (value);\n  if (v != 0)\n    _rl_init_file_error (\"%s: could not set value to `%s'\", name, value);\n  return v;\n}\n\nstatic int\nsv_editmode (const char *value)\n{\n  if (_rl_strnicmp (value, \"vi\", 2) == 0)\n    {\n#if defined (VI_MODE)\n      _rl_keymap = vi_insertion_keymap;\n      rl_editing_mode = vi_mode;\n#endif  \n      return 0;\n    }\n  else if (_rl_strnicmp (value, \"emacs\", 5) == 0)\n    {\n      _rl_keymap = emacs_standard_keymap;\n      rl_editing_mode = emacs_mode;\n      return 0;\n    }\n  return 1;\n}\n\nstatic int\nsv_combegin (const char *value)\n{\n  if (value && *value)\n    {\n      FREE (_rl_comment_begin);\n      _rl_comment_begin = savestring (value);\n      return 0;\n    }\n  return 1;\n}\n\nstatic int\nsv_dispprefix (const char *value)\n{\n  int nval = 0;\n\n  if (value && *value)\n    {\n      nval = atoi (value);\n      if (nval < 0)\n\tnval = 0;\n    }\n  _rl_completion_prefix_display_length = nval;\n  return 0;\n}\n\nstatic int\nsv_compquery (const char *value)\n{\n  int nval = 100;\n\n  if (value && *value)\n    {\n      nval = atoi (value);\n      if (nval < 0)\n\tnval = 0;\n    }\n  rl_completion_query_items = nval;\n  return 0;\n}\n\nstatic int\nsv_compwidth (const char *value)\n{\n  int nval = -1;\n\n  if (value && *value)\n    nval = atoi (value);\n\n  _rl_completion_columns = nval;\n  return 0;\n}\n\nstatic int\nsv_histsize (const char *value)\n{\n  int nval;\n\n  nval = 500;\n  if (value && *value)\n    {\n      nval = atoi (value);\n      if (nval < 0)\n\t{\n\t  unstifle_history ();\n\t  return 0;\n\t}\n    }\n  stifle_history (nval);\n  return 0;\n}\n\nstatic int\nsv_keymap (const char *value)\n{\n  Keymap kmap;\n\n  kmap = rl_get_keymap_by_name (value);\n  if (kmap)\n    {\n      rl_set_keymap (kmap);\n      return 0;\n    }\n  return 1;\n}\n\nstatic int\nsv_seqtimeout (const char *value)\n{\n  int nval;\n\n  nval = 0;\n  if (value && *value)\n    {\n      nval = atoi (value);\n      if (nval < 0)\n\tnval = 0;\n    }\n  _rl_keyseq_timeout = nval;\n  return 0;\n}\n\nstatic int\nsv_region_start_color (const char *value)\n{\n  return (_rl_reset_region_color (0, value));\n}\n\nstatic int\nsv_region_end_color (const char *value)\n{\n  return (_rl_reset_region_color (1, value));\n}\n\nstatic int\nsv_bell_style (const char *value)\n{\n  if (value == 0 || *value == '\\0')\n    _rl_bell_preference = AUDIBLE_BELL;\n  else if (_rl_stricmp (value, \"none\") == 0 || _rl_stricmp (value, \"off\") == 0)\n    _rl_bell_preference = NO_BELL;\n  else if (_rl_stricmp (value, \"audible\") == 0 || _rl_stricmp (value, \"on\") == 0)\n    _rl_bell_preference = AUDIBLE_BELL;\n  else if (_rl_stricmp (value, \"visible\") == 0)\n    _rl_bell_preference = VISIBLE_BELL;\n  else\n    return 1;\n  return 0;\n}\n\nstatic int\nsv_isrchterm (const char *value)\n{\n  int beg, end, delim;\n  char *v;\n\n  if (value == 0)\n    return 1;\n\n   \n  v = savestring (value);\n  FREE (_rl_isearch_terminators);\n  if (v[0] == '\"' || v[0] == '\\'')\n    {\n      delim = v[0];\n      for (beg = end = 1; v[end] && v[end] != delim; end++)\n\t;\n    }\n  else\n    {\n      for (beg = end = 0; v[end] && whitespace (v[end]) == 0; end++)\n\t;\n    }\n\n  v[end] = '\\0';\n\n   \n  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);\n  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);\n  _rl_isearch_terminators[end] = '\\0';\n\n  xfree (v);\n  return 0;\n}\n\nextern char *_rl_emacs_mode_str;\n\nstatic int\nsv_emacs_modestr (const char *value)\n{\n  if (value && *value)\n    {\n      FREE (_rl_emacs_mode_str);\n      _rl_emacs_mode_str = (char *)xmalloc (2 * strlen (value) + 1);\n      rl_translate_keyseq (value, _rl_emacs_mode_str, &_rl_emacs_modestr_len);\n      _rl_emacs_mode_str[_rl_emacs_modestr_len] = '\\0';\n      return 0;\n    }\n  else if (value)\n    {\n      FREE (_rl_emacs_mode_str);\n      _rl_emacs_mode_str = (char *)xmalloc (1);\n      _rl_emacs_mode_str[_rl_emacs_modestr_len = 0] = '\\0';\n      return 0;\n    }\n  else if (value == 0)\n    {\n      FREE (_rl_emacs_mode_str);\n      _rl_emacs_mode_str = 0;\t \n      _rl_emacs_modestr_len = 0;\n      return 0;\n    }\n  return 1;\n}\n\nstatic int\nsv_viins_modestr (const char *value)\n{\n  if (value && *value)\n    {\n      FREE (_rl_vi_ins_mode_str);\n      _rl_vi_ins_mode_str = (char *)xmalloc (2 * strlen (value) + 1);\n      rl_translate_keyseq (value, _rl_vi_ins_mode_str, &_rl_vi_ins_modestr_len);\n      _rl_vi_ins_mode_str[_rl_vi_ins_modestr_len] = '\\0';\n      return 0;\n    }\n  else if (value)\n    {\n      FREE (_rl_vi_ins_mode_str);\n      _rl_vi_ins_mode_str = (char *)xmalloc (1);\n      _rl_vi_ins_mode_str[_rl_vi_ins_modestr_len = 0] = '\\0';\n      return 0;\n    }\n  else if (value == 0)\n    {\n      FREE (_rl_vi_ins_mode_str);\n      _rl_vi_ins_mode_str = 0;\t \n      _rl_vi_ins_modestr_len = 0;\n      return 0;\n    }\n  return 1;\n}\n\nstatic int\nsv_vicmd_modestr (const char *value)\n{\n  if (value && *value)\n    {\n      FREE (_rl_vi_cmd_mode_str);\n      _rl_vi_cmd_mode_str = (char *)xmalloc (2 * strlen (value) + 1);\n      rl_translate_keyseq (value, _rl_vi_cmd_mode_str, &_rl_vi_cmd_modestr_len);\n      _rl_vi_cmd_mode_str[_rl_vi_cmd_modestr_len] = '\\0';\n      return 0;\n    }\n  else if (value)\n    {\n      FREE (_rl_vi_cmd_mode_str);\n      _rl_vi_cmd_mode_str = (char *)xmalloc (1);\n      _rl_vi_cmd_mode_str[_rl_vi_cmd_modestr_len = 0] = '\\0';\n      return 0;\n    }\n  else if (value == 0)\n    {\n      FREE (_rl_vi_cmd_mode_str);\n      _rl_vi_cmd_mode_str = 0;\t \n      _rl_vi_cmd_modestr_len = 0;\n      return 0;\n    }\n  return 1;\n}\n\n \n\ntypedef struct {\n  const char * const name;\n  int value;\n} assoc_list;\n\nstatic const assoc_list name_key_alist[] = {\n  { \"DEL\", 0x7f },\n  { \"ESC\", '\\033' },\n  { \"Escape\", '\\033' },\n  { \"LFD\", '\\n' },\n  { \"Newline\", '\\n' },\n  { \"RET\", '\\r' },\n  { \"Return\", '\\r' },\n  { \"Rubout\", 0x7f },\n  { \"SPC\", ' ' },\n  { \"Space\", ' ' },\n  { \"Tab\", 0x09 },\n  { (char *)0x0, 0 }\n};\n\nstatic int\nglean_key_from_name (char *name)\n{\n  register int i;\n\n  for (i = 0; name_key_alist[i].name; i++)\n    if (_rl_stricmp (name, name_key_alist[i].name) == 0)\n      return (name_key_alist[i].value);\n\n  return (*(unsigned char *)name);\t \n}\n\n \nstruct name_and_keymap {\n  char *name;\n  Keymap map;\n};\n\nstatic struct name_and_keymap builtin_keymap_names[] = {\n  { \"emacs\", emacs_standard_keymap },\n  { \"emacs-standard\", emacs_standard_keymap },\n  { \"emacs-meta\", emacs_meta_keymap },\n  { \"emacs-ctlx\", emacs_ctlx_keymap },\n#if defined (VI_MODE)\n  { \"vi\", vi_movement_keymap },\n  { \"vi-move\", vi_movement_keymap },\n  { \"vi-command\", vi_movement_keymap },\n  { \"vi-insert\", vi_insertion_keymap },\n#endif  \n  { (char *)0x0, (Keymap)0x0 }\n};\n\n \n#define NUM_BUILTIN_KEYMAPS (sizeof (builtin_keymap_names) / sizeof (builtin_keymap_names[0]) - 1)\n\nstatic struct name_and_keymap *keymap_names = builtin_keymap_names;\n\nstatic int\n_rl_get_keymap_by_name (const char *name)\n{\n  register int i;\n\n  for (i = 0; keymap_names[i].name; i++)\n    if (_rl_stricmp (name, keymap_names[i].name) == 0)\n      return (i);\n  return -1;\n}\n\nKeymap\nrl_get_keymap_by_name (const char *name)\n{\n  int i;\n\n  i = _rl_get_keymap_by_name (name);\n  return ((i >= 0) ? keymap_names[i].map : (Keymap) NULL);\n}\n\nstatic int\n_rl_get_keymap_by_map (Keymap map)\n{\n  register int i;\n\n  for (i = 0; keymap_names[i].name; i++)\n    if (map == keymap_names[i].map)\n      return (i);\n  return -1;\n}\n\nchar *\nrl_get_keymap_name (Keymap map)\n{\n  int i;\n\n  i = _rl_get_keymap_by_map (map);\n  return ((i >= 0) ? keymap_names[i].name : (char *)NULL);\n}\n\nint\nrl_set_keymap_name (const char *name, Keymap map)\n{\n  int i, ni, mi;\n\n   \n  mi = _rl_get_keymap_by_map (map);\n  if (mi >= 0 && mi < NUM_BUILTIN_KEYMAPS)\n    return -1;\n\n   \n  ni = _rl_get_keymap_by_name (name);\n  if (ni >= 0 && ni < NUM_BUILTIN_KEYMAPS)\n    return -1;\n\n   \n  if (mi >= 0)\t \n    {\n      xfree (keymap_names[mi].name);\n      keymap_names[mi].name = savestring (name);\n      return mi;\n    }\n\n   \n  if (ni >= 0)\n    {\n      keymap_names[ni].map = map;\n      return ni;\n    }\n\n  for (i = 0; keymap_names[i].name; i++)\n    ;\n\n  if (keymap_names == builtin_keymap_names)\n    {\n      keymap_names = xmalloc ((i + 2) * sizeof (struct name_and_keymap));\n      memcpy (keymap_names, builtin_keymap_names, i * sizeof (struct name_and_keymap));\n    }\n  else\n    keymap_names = xrealloc (keymap_names, (i + 2) * sizeof (struct name_and_keymap));\n\n  keymap_names[i].name = savestring (name);\n  keymap_names[i].map = map;\n\n  keymap_names[i+1].name = NULL;\n  keymap_names[i+1].map = NULL;\n\n  return i;\n}\n\nvoid\nrl_set_keymap (Keymap map)\n{\n  if (map)\n    _rl_keymap = map;\n}\n\nKeymap\nrl_get_keymap (void)\n{\n  return (_rl_keymap);\n}\n\nvoid\nrl_set_keymap_from_edit_mode (void)\n{\n  if (rl_editing_mode == emacs_mode)\n    _rl_keymap = emacs_standard_keymap;\n#if defined (VI_MODE)\n  else if (rl_editing_mode == vi_mode)\n    _rl_keymap = vi_insertion_keymap;\n#endif  \n}\n\nchar *\nrl_get_keymap_name_from_edit_mode (void)\n{\n  if (rl_editing_mode == emacs_mode)\n    return \"emacs\";\n#if defined (VI_MODE)\n  else if (rl_editing_mode == vi_mode)\n    return \"vi\";\n#endif  \n  else\n    return \"none\";\n}\n\n \n \n \n \n \n\n \n\n \nvoid\nrl_list_funmap_names (void)\n{\n  register int i;\n  const char **funmap_names;\n\n  funmap_names = rl_funmap_names ();\n\n  if (!funmap_names)\n    return;\n\n  for (i = 0; funmap_names[i]; i++)\n    fprintf (rl_outstream, \"%s\\n\", funmap_names[i]);\n\n  xfree (funmap_names);\n}\n\nstatic char *\n_rl_get_keyname (int key)\n{\n  char *keyname;\n  int i, c;\n\n  keyname = (char *)xmalloc (8);\n\n  c = key;\n   \n\n#if 1\n   \n   \n\n   \n  if (c == ESC)\n    {\n      keyname[0] = '\\\\';\n      keyname[1] = 'e';\n      keyname[2] = '\\0';\n      return keyname;\n    }\n#endif\n\n   \n  if (key == RUBOUT)\n    {\n      keyname[0] = '\\\\';\n      keyname[1] = 'C';\n      keyname[2] = '-';\n      keyname[3] = '?';\n      keyname[4] = '\\0';\n      return keyname;\n    }\n\n  i = 0;\n   \n  if (CTRL_CHAR (c))\n    {\n      keyname[i++] = '\\\\';\n      keyname[i++] = 'C';\n      keyname[i++] = '-';\n      c = _rl_to_lower (UNCTRL (c));\n    }\n\n   \n  if (c >= 128 && c <= 159)\n    {\n      keyname[i++] = '\\\\';\n      keyname[i++] = '2';\n      c -= 128;\n      keyname[i++] = (c / 8) + '0';\n      c = (c % 8) + '0';\n    }\n   \n  else if (c >= 160)\n    {\n      keyname[i++] = '\\\\';\n      keyname[i++] = '0' + ((((unsigned char)c) >> 6) & 0x07);\n      keyname[i++] = '0' + ((((unsigned char)c) >> 3) & 0x07);\n      c = (c % 8) + '0';\n    }\n\n   \n  if (c == '\\\\' || c == '\"')\n    keyname[i++] = '\\\\';\n\n   \n  keyname[i++] = (char) c;\n  keyname[i] = '\\0';\n\n  return keyname;\n}\n\n \nchar **\nrl_invoking_keyseqs_in_map (rl_command_func_t *function, Keymap map)\n{\n  register int key;\n  char **result;\n  int result_index, result_size;\n\n  result = (char **)NULL;\n  result_index = result_size = 0;\n\n  for (key = 0; key < KEYMAP_SIZE; key++)\n    {\n      switch (map[key].type)\n\t{\n\tcase ISMACR:\n\t   \n\tcase ISFUNC:\n\t   \n\t  if (map[key].function == function)\n\t    {\n\t      char *keyname;\n\n\t      keyname = _rl_get_keyname (key);\n\n\t      if (result_index + 2 > result_size)\n\t        {\n\t          result_size += 10;\n\t\t  result = (char **)xrealloc (result, result_size * sizeof (char *));\n\t        }\n\n\t      result[result_index++] = keyname;\n\t      result[result_index] = (char *)NULL;\n\t    }\n\t  break;\n\n\tcase ISKMAP:\n\t  {\n\t    char **seqs;\n\t    register int i;\n\n\t     \n\t    if (map[key].function)\n\t      seqs =\n\t        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));\n\t    else\n\t      break;\n\n\t    if (seqs == 0)\n\t      break;\n\n\t    for (i = 0; seqs[i]; i++)\n\t      {\n\t\tchar *keyname = (char *)xmalloc (6 + strlen (seqs[i]));\n\n\t\tif (key == ESC)\n\t\t  {\n\t\t     \n\t\t    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)\n\t\t      sprintf (keyname, \"\\\\M-\");\n\t\t    else\n\t\t      sprintf (keyname, \"\\\\e\");\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    int c = key, l = 0;\n\t\t    if (CTRL_CHAR (c) || c == RUBOUT)\n\t\t      {\n\t\t\tkeyname[l++] = '\\\\';\n\t\t\tkeyname[l++] = 'C';\n\t\t\tkeyname[l++] = '-';\n\t\t\tc = (c == RUBOUT) ? '?' : _rl_to_lower (UNCTRL (c));\n\t\t      }\n\n\t\t    if (c == '\\\\' || c == '\"')\n\t\t      keyname[l++] = '\\\\';\n\n\t\t    keyname[l++] = (char) c;\n\t\t    keyname[l++] = '\\0';\n\t\t  }\n\t\t\n\t\tstrcat (keyname, seqs[i]);\n\t\txfree (seqs[i]);\n\n\t\tif (result_index + 2 > result_size)\n\t\t  {\n\t\t    result_size += 10;\n\t\t    result = (char **)xrealloc (result, result_size * sizeof (char *));\n\t\t  }\n\n\t\tresult[result_index++] = keyname;\n\t\tresult[result_index] = (char *)NULL;\n\t      }\n\n\t    xfree (seqs);\n\t  }\n\t  break;\n\t}\n    }\n  return (result);\n}\n\n \nchar **\nrl_invoking_keyseqs (rl_command_func_t *function)\n{\n  return (rl_invoking_keyseqs_in_map (function, _rl_keymap));\n}\n\n \nvoid\nrl_function_dumper (int print_readably)\n{\n  register int i;\n  const char **names;\n  const char *name;\n\n  names = rl_funmap_names ();\n\n  fprintf (rl_outstream, \"\\n\");\n\n  for (i = 0; name = names[i]; i++)\n    {\n      rl_command_func_t *function;\n      char **invokers;\n\n      function = rl_named_function (name);\n      invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);\n\n      if (print_readably)\n\t{\n\t  if (!invokers)\n\t    fprintf (rl_outstream, \"# %s (not bound)\\n\", name);\n\t  else\n\t    {\n\t      register int j;\n\n\t      for (j = 0; invokers[j]; j++)\n\t\t{\n\t\t  fprintf (rl_outstream, \"\\\"%s\\\": %s\\n\",\n\t\t\t   invokers[j], name);\n\t\t  xfree (invokers[j]);\n\t\t}\n\n\t      xfree (invokers);\n\t    }\n\t}\n      else\n\t{\n\t  if (!invokers)\n\t    fprintf (rl_outstream, \"%s is not bound to any keys\\n\",\n\t\t     name);\n\t  else\n\t    {\n\t      register int j;\n\n\t      fprintf (rl_outstream, \"%s can be found on \", name);\n\n\t      for (j = 0; invokers[j] && j < 5; j++)\n\t\t{\n\t\t  fprintf (rl_outstream, \"\\\"%s\\\"%s\", invokers[j],\n\t\t\t   invokers[j + 1] ? \", \" : \".\\n\");\n\t\t}\n\n\t      if (j == 5 && invokers[j])\n\t\tfprintf (rl_outstream, \"...\\n\");\n\n\t      for (j = 0; invokers[j]; j++)\n\t\txfree (invokers[j]);\n\n\t      xfree (invokers);\n\t    }\n\t}\n    }\n\n  xfree (names);\n}\n\n \nint\nrl_dump_functions (int count, int key)\n{\n  if (rl_dispatching)\n    fprintf (rl_outstream, \"\\r\\n\");\n  rl_function_dumper (rl_explicit_arg);\n  rl_on_new_line ();\n  return (0);\n}\n\nstatic void\n_rl_macro_dumper_internal (int print_readably, Keymap map, char *prefix)\n{\n  register int key;\n  char *keyname, *out;\n  int prefix_len;\n\n  for (key = 0; key < KEYMAP_SIZE; key++)\n    {\n      switch (map[key].type)\n\t{\n\tcase ISMACR:\n\t  keyname = _rl_get_keyname (key);\n\t  out = _rl_untranslate_macro_value ((char *)map[key].function, 0);\n\n\t  if (print_readably)\n\t    fprintf (rl_outstream, \"\\\"%s%s\\\": \\\"%s\\\"\\n\", prefix ? prefix : \"\",\n\t\t\t\t\t\t         keyname,\n\t\t\t\t\t\t         out ? out : \"\");\n\t  else\n\t    fprintf (rl_outstream, \"%s%s outputs %s\\n\", prefix ? prefix : \"\",\n\t\t\t\t\t\t\tkeyname,\n\t\t\t\t\t\t\tout ? out : \"\");\n\t  xfree (keyname);\n\t  xfree (out);\n\t  break;\n\tcase ISFUNC:\n\t  break;\n\tcase ISKMAP:\n\t  prefix_len = prefix ? strlen (prefix) : 0;\n\t  if (key == ESC)\n\t    {\n\t      keyname = (char *)xmalloc (3 + prefix_len);\n\t      if (prefix)\n\t\tstrcpy (keyname, prefix);\n\t      keyname[prefix_len] = '\\\\';\n\t      keyname[prefix_len + 1] = 'e';\n\t      keyname[prefix_len + 2] = '\\0';\n\t    }\n\t  else\n\t    {\n\t      keyname = _rl_get_keyname (key);\n\t      if (prefix)\n\t\t{\n\t\t  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);\n\t\t  strcpy (out, prefix);\n\t\t  strcpy (out + prefix_len, keyname);\n\t\t  xfree (keyname);\n\t\t  keyname = out;\n\t\t}\n\t    }\n\n\t  _rl_macro_dumper_internal (print_readably, FUNCTION_TO_KEYMAP (map, key), keyname);\n\t  xfree (keyname);\n\t  break;\n\t}\n    }\n}\n\nvoid\nrl_macro_dumper (int print_readably)\n{\n  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);\n}\n\nint\nrl_dump_macros (int count, int key)\n{\n  if (rl_dispatching)\n    fprintf (rl_outstream, \"\\r\\n\");\n  rl_macro_dumper (rl_explicit_arg);\n  rl_on_new_line ();\n  return (0);\n}\n\nstatic char *\n_rl_get_string_variable_value (const char *name)\n{\n  static char numbuf[32];\n  char *ret;\n\n  if (_rl_stricmp (name, \"bell-style\") == 0)\n    {\n      switch (_rl_bell_preference)\n\t{\n\t  case NO_BELL:\n\t    return \"none\";\n\t  case VISIBLE_BELL:\n\t    return \"visible\";\n\t  case AUDIBLE_BELL:\n\t  default:\n\t    return \"audible\";\n\t}\n    }\n  else if (_rl_stricmp (name, \"comment-begin\") == 0)\n    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);\n  else if (_rl_stricmp (name, \"completion-display-width\") == 0)\n    {\n      sprintf (numbuf, \"%d\", _rl_completion_columns);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"completion-prefix-display-length\") == 0)\n    {\n      sprintf (numbuf, \"%d\", _rl_completion_prefix_display_length);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"completion-query-items\") == 0)\n    {\n      sprintf (numbuf, \"%d\", rl_completion_query_items);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"editing-mode\") == 0)\n    return (rl_get_keymap_name_from_edit_mode ());\n  else if (_rl_stricmp (name, \"history-size\") == 0)\n    {\n      sprintf (numbuf, \"%d\", history_is_stifled() ? history_max_entries : 0);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"isearch-terminators\") == 0)\n    {\n      if (_rl_isearch_terminators == 0)\n\treturn 0;\n      ret = _rl_untranslate_macro_value (_rl_isearch_terminators, 0);\n      if (ret)\n\t{\n\t  strncpy (numbuf, ret, sizeof (numbuf) - 1);\n\t  xfree (ret);\n\t  numbuf[sizeof(numbuf) - 1] = '\\0';\n\t}\n      else\n\tnumbuf[0] = '\\0';\n      return numbuf;\n    }\n  else if (_rl_stricmp (name, \"keymap\") == 0)\n    {\n      ret = rl_get_keymap_name (_rl_keymap);\n      if (ret == 0)\n\tret = rl_get_keymap_name_from_edit_mode ();\n      return (ret ? ret : \"none\");\n    }\n  else if (_rl_stricmp (name, \"keyseq-timeout\") == 0)\n    {\n      sprintf (numbuf, \"%d\", _rl_keyseq_timeout);    \n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"emacs-mode-string\") == 0)\n    return (_rl_emacs_mode_str ? _rl_emacs_mode_str : RL_EMACS_MODESTR_DEFAULT);\n  else if (_rl_stricmp (name, \"vi-cmd-mode-string\") == 0)\n    return (_rl_vi_cmd_mode_str ? _rl_vi_cmd_mode_str : RL_VI_CMD_MODESTR_DEFAULT);\n  else if (_rl_stricmp (name, \"vi-ins-mode-string\") == 0)\n    return (_rl_vi_ins_mode_str ? _rl_vi_ins_mode_str : RL_VI_INS_MODESTR_DEFAULT);\n  else\n    return (0);\n}\n\nvoid\nrl_variable_dumper (int print_readably)\n{\n  int i;\n  char *v;\n\n  for (i = 0; boolean_varlist[i].name; i++)\n    {\n      if (print_readably)\n        fprintf (rl_outstream, \"set %s %s\\n\", boolean_varlist[i].name,\n\t\t\t       *boolean_varlist[i].value ? \"on\" : \"off\");\n      else\n        fprintf (rl_outstream, \"%s is set to `%s'\\n\", boolean_varlist[i].name,\n\t\t\t       *boolean_varlist[i].value ? \"on\" : \"off\");\n    }\n\n  for (i = 0; string_varlist[i].name; i++)\n    {\n      v = _rl_get_string_variable_value (string_varlist[i].name);\n      if (v == 0)\t \n\tcontinue;\n      if (print_readably)\n        fprintf (rl_outstream, \"set %s %s\\n\", string_varlist[i].name, v);\n      else\n        fprintf (rl_outstream, \"%s is set to `%s'\\n\", string_varlist[i].name, v);\n    }\n}\n\n \nint\nrl_dump_variables (int count, int key)\n{\n  if (rl_dispatching)\n    fprintf (rl_outstream, \"\\r\\n\");\n  rl_variable_dumper (rl_explicit_arg);\n  rl_on_new_line ();\n  return (0);\n}\n\n \nstatic int\nsubstring_member_of_array (const char *string, const char * const *array)\n{\n  while (*array)\n    {\n      if (_rl_strindex (string, *array))\n\treturn (1);\n      array++;\n    }\n  return (0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}