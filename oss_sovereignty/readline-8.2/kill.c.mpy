{
  "module_name": "kill.c",
  "hash_id": "3b201ebc4435ded6f7c37cfaceb257b35a3ed459839dd67e7edb21b9f82d6d0f",
  "original_prompt": "Ingested from readline-8.2/kill.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>            \n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n \n \n \n \n \n\n \n#define DEFAULT_MAX_KILLS 10\n\n \nstatic int rl_max_kills =  DEFAULT_MAX_KILLS;\n\n \nstatic char **rl_kill_ring = (char **)NULL;\n\n \nstatic int rl_kill_index;\n\n \nstatic int rl_kill_ring_length;\n\nstatic int _rl_copy_to_kill_ring (char *, int);\nstatic int region_kill_internal (int);\nstatic int _rl_copy_word_as_kill (int, int);\nstatic int rl_yank_nth_arg_internal (int, int, int);\n\n \nint\nrl_set_retained_kills (int num)\n{\n  return 0;\n}\n\n \nstatic int\n_rl_copy_to_kill_ring (char *text, int append)\n{\n  char *old, *new;\n  int slot;\n\n   \n  if (_rl_last_command_was_kill == 0 || rl_kill_ring == 0)\n    {\n       \n      if (rl_kill_ring == 0)\n\t{\n\t   \n\t  rl_kill_ring = (char **)\n\t    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));\n\t  rl_kill_ring[slot = 0] = (char *)NULL;\n\t}\n      else\n\t{\n\t   \n\t  slot = rl_kill_ring_length;\n\t  if (slot == rl_max_kills)\n\t    {\n\t      register int i;\n\t      xfree (rl_kill_ring[0]);\n\t      for (i = 0; i < slot; i++)\n\t\trl_kill_ring[i] = rl_kill_ring[i + 1];\n\t    }\n\t  else\n\t    {\n\t      slot = rl_kill_ring_length += 1;\n\t      rl_kill_ring = (char **)xrealloc (rl_kill_ring, (slot + 1) * sizeof (char *));\n\t    }\n\t  rl_kill_ring[--slot] = (char *)NULL;\n\t}\n    }\n  else\n    slot = rl_kill_ring_length - 1;\n\n   \n  if (_rl_last_command_was_kill && rl_kill_ring[slot] && rl_editing_mode != vi_mode)\n    {\n      old = rl_kill_ring[slot];\n      new = (char *)xmalloc (1 + strlen (old) + strlen (text));\n\n      if (append)\n\t{\n\t  strcpy (new, old);\n\t  strcat (new, text);\n\t}\n      else\n\t{\n\t  strcpy (new, text);\n\t  strcat (new, old);\n\t}\n      xfree (old);\n      xfree (text);\n      rl_kill_ring[slot] = new;\n    }\n  else\n    rl_kill_ring[slot] = text;\n\n  rl_kill_index = slot;\n  return 0;\n}\n\n \nint\nrl_kill_text (int from, int to)\n{\n  char *text;\n\n   \n  if (from == to)\n    {\n      _rl_last_command_was_kill++;\n      return 0;\n    }\n\n  text = rl_copy_text (from, to);\n\n   \n  rl_delete_text (from, to);\n\n  _rl_copy_to_kill_ring (text, from < to);\n\n  _rl_last_command_was_kill++;\n  return 0;\n}\n\n \n\n \n \n \n \n \n\n \nint\nrl_kill_word (int count, int key)\n{\n  int orig_point;\n\n  if (count < 0)\n    return (rl_backward_kill_word (-count, key));\n  else\n    {\n      orig_point = rl_point;\n      rl_forward_word (count, key);\n\n      if (rl_point != orig_point)\n\trl_kill_text (orig_point, rl_point);\n\n      rl_point = orig_point;\n      if (rl_editing_mode == emacs_mode)\n\trl_mark = rl_point;\n    }\n  return 0;\n}\n\n \nint\nrl_backward_kill_word (int count, int key)\n{\n  int orig_point;\n\n  if (count < 0)\n    return (rl_kill_word (-count, key));\n  else\n    {\n      orig_point = rl_point;\n      rl_backward_word (count, key);\n\n      if (rl_point != orig_point)\n\trl_kill_text (orig_point, rl_point);\n\n      if (rl_editing_mode == emacs_mode)\n\trl_mark = rl_point;\n    }\n  return 0;\n}\n\n \nint\nrl_kill_line (int direction, int key)\n{\n  int orig_point;\n\n  if (direction < 0)\n    return (rl_backward_kill_line (1, key));\n  else\n    {\n      orig_point = rl_point;\n      rl_end_of_line (1, key);\n      if (orig_point != rl_point)\n\trl_kill_text (orig_point, rl_point);\n      rl_point = orig_point;\n      if (rl_editing_mode == emacs_mode)\n\trl_mark = rl_point;\n    }\n  return 0;\n}\n\n \nint\nrl_backward_kill_line (int direction, int key)\n{\n  int orig_point;\n\n  if (direction < 0)\n    return (rl_kill_line (1, key));\n  else\n    {\n      if (rl_point == 0)\n\trl_ding ();\n      else\n\t{\n\t  orig_point = rl_point;\n\t  rl_beg_of_line (1, key);\n\t  if (rl_point != orig_point)\n\t    rl_kill_text (orig_point, rl_point);\n\t  if (rl_editing_mode == emacs_mode)\n\t    rl_mark = rl_point;\n\t}\n    }\n  return 0;\n}\n\n \nint\nrl_kill_full_line (int count, int key)\n{\n  rl_begin_undo_group ();\n  rl_point = 0;\n  rl_kill_text (rl_point, rl_end);\n  rl_mark = 0;\n  rl_end_undo_group ();\n  return 0;\n}\n\n \n\n \nint\nrl_unix_word_rubout (int count, int key)\n{\n  int orig_point;\n\n  if (rl_point == 0)\n    rl_ding ();\n  else\n    {\n      orig_point = rl_point;\n      if (count <= 0)\n\tcount = 1;\n\n      while (count--)\n\t{\n\t  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))\n\t    rl_point--;\n\n\t  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))\n\t    rl_point--;\t\t \n\t}\n\n      rl_kill_text (orig_point, rl_point);\n      if (rl_editing_mode == emacs_mode)\n\trl_mark = rl_point;\n    }\n\n  return 0;\n}\n\n \nint\nrl_unix_filename_rubout (int count, int key)\n{\n  int orig_point, c;\n\n  if (rl_point == 0)\n    rl_ding ();\n  else\n    {\n      orig_point = rl_point;\n      if (count <= 0)\n\tcount = 1;\n\n      while (count--)\n\t{\n\t  c = rl_line_buffer[rl_point - 1];\n\n\t   \n\t  while (rl_point && whitespace (c))\n\t    {\n\t      rl_point--;\n\t      c = rl_line_buffer[rl_point - 1];\n\t    }\n\n\t   \n\t  if (c == '/')\n\t    {\n\t      int i;\n\n\t      i = rl_point - 1;\n\t      while (i > 0 && c == '/')\n\t\tc = rl_line_buffer[--i];\n\t      if (i == 0 || whitespace (c))\n\t\t{\n\t\t  rl_point = i + whitespace (c);\n\t\t  continue;\t \n\t\t}\n\t      c = '/';\n\t    }\n\n\t  while (rl_point && (whitespace (c) || c == '/'))\n\t    {\n\t      rl_point--;\n\t      c = rl_line_buffer[rl_point - 1];\n\t    }\n\n\t  while (rl_point && (whitespace (c) == 0) && c != '/')\n\t    {\n\t      rl_point--;\t \n\t      c = rl_line_buffer[rl_point - 1];\n\t    }\n\t}\n\n      rl_kill_text (orig_point, rl_point);\n      if (rl_editing_mode == emacs_mode)\n\trl_mark = rl_point;\n    }\n\n  return 0;\n}\n\n \nint\nrl_unix_line_discard (int count, int key)\n{\n  if (rl_point == 0)\n    rl_ding ();\n  else\n    {\n      rl_kill_text (rl_point, 0);\n      rl_point = 0;\n      if (rl_editing_mode == emacs_mode)\n\trl_mark = rl_point;\n    }\n  return 0;\n}\n\n \nstatic int\nregion_kill_internal (int delete)\n{\n  char *text;\n\n  if (rl_mark != rl_point)\n    {\n      text = rl_copy_text (rl_point, rl_mark);\n      if (delete)\n\trl_delete_text (rl_point, rl_mark);\n      _rl_copy_to_kill_ring (text, rl_point < rl_mark);\n    }\n\n  _rl_fix_point (1);\n  _rl_last_command_was_kill++;\n  return 0;\n}\n\n \nint\nrl_copy_region_to_kill (int count, int key)\n{\n  return (region_kill_internal (0));\n}\n\n \nint\nrl_kill_region (int count, int key)\n{\n  int r, npoint;\n\n  npoint = (rl_point < rl_mark) ? rl_point : rl_mark;\n  r = region_kill_internal (1);\n  rl_point = npoint;\n  _rl_fix_point (1);\n  return r;\n}\n\n \nstatic int\n_rl_copy_word_as_kill (int count, int dir)\n{\n  int om, op, r;\n\n  om = rl_mark;\n  op = rl_point;\n\n  if (dir > 0)\n    rl_forward_word (count, 0);\n  else\n    rl_backward_word (count, 0);\n\n  rl_mark = rl_point;\n\n  if (dir > 0)\n    rl_backward_word (count, 0);\n  else\n    rl_forward_word (count, 0);\n\n  r = region_kill_internal (0);\n\n  rl_mark = om;\n  rl_point = op;\n\n  return r;\n}\n\nint\nrl_copy_forward_word (int count, int key)\n{\n  if (count < 0)\n    return (rl_copy_backward_word (-count, key));\n\n  return (_rl_copy_word_as_kill (count, 1));\n}\n\nint\nrl_copy_backward_word (int count, int key)\n{\n  if (count < 0)\n    return (rl_copy_forward_word (-count, key));\n\n  return (_rl_copy_word_as_kill (count, -1));\n}\n  \n \nint\nrl_yank (int count, int key)\n{\n  if (rl_kill_ring == 0)\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n\n  _rl_set_mark_at_pos (rl_point);\n  rl_insert_text (rl_kill_ring[rl_kill_index]);\n  return 0;\n}\n\n \nint\nrl_yank_pop (int count, int key)\n{\n  int l, n;\n\n  if (((rl_last_func != rl_yank_pop) && (rl_last_func != rl_yank)) ||\n      !rl_kill_ring)\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n\n  l = strlen (rl_kill_ring[rl_kill_index]);\n  n = rl_point - l;\n  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))\n    {\n      rl_delete_text (n, rl_point);\n      rl_point = n;\n      rl_kill_index--;\n      if (rl_kill_index < 0)\n\trl_kill_index = rl_kill_ring_length - 1;\n      rl_yank (1, 0);\n      return 0;\n    }\n  else\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n}\n\n#if defined (VI_MODE)\nint\nrl_vi_yank_pop (int count, int key)\n{\n  int l, n, origpoint;\n\n  if (((rl_last_func != rl_vi_yank_pop) && (rl_last_func != rl_vi_put)) ||\n      !rl_kill_ring)\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n\n  l = strlen (rl_kill_ring[rl_kill_index]);\n#if 0  \n  origpoint = rl_point;\n  n = rl_point - l + 1;\n#else\n  n = rl_point - l;\n#endif\n  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))\n    {\n#if 0  \n      rl_delete_text (n, n + l);\t\t \n      rl_point = origpoint - l;\n#else\n      rl_delete_text (n, rl_point);\n      rl_point = n;\n#endif\n      rl_kill_index--;\n      if (rl_kill_index < 0)\n\trl_kill_index = rl_kill_ring_length - 1;\n      rl_vi_put (1, 'p');\n      return 0;\n    }\n  else\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n}\n#endif  \n\n \nstatic int\nrl_yank_nth_arg_internal (int count, int key, int history_skip)\n{\n  register HIST_ENTRY *entry;\n  char *arg;\n  int i, pos;\n\n  pos = where_history ();\n\n  if (history_skip)\n    {\n      for (i = 0; i < history_skip; i++)\n\tentry = previous_history ();\n    }\n\n  entry = previous_history ();\n\n  history_set_pos (pos);\n\n  if (entry == 0)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  arg = history_arg_extract (count, count, entry->line);\n  if (!arg || !*arg)\n    {\n      rl_ding ();\n      FREE (arg);\n      return 1;\n    }\n\n  rl_begin_undo_group ();\n\n  _rl_set_mark_at_pos (rl_point);\n\n#if defined (VI_MODE)\n   \n  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)\n    {\n      rl_vi_append_mode (1, key);\n      rl_insert_text (\" \");\n    }\n#endif  \n\n  rl_insert_text (arg);\n  xfree (arg);\n\n  rl_end_undo_group ();\n  return 0;\n}\n\n \nint\nrl_yank_nth_arg (int count, int key)\n{\n  return (rl_yank_nth_arg_internal (count, key, 0));\n}\n\n \nint\nrl_yank_last_arg (int count, int key)\n{\n  static int history_skip = 0;\n  static int explicit_arg_p = 0;\n  static int count_passed = 1;\n  static int direction = 1;\n  static int undo_needed = 0;\n  int retval;\n\n  if (rl_last_func != rl_yank_last_arg)\n    {\n      history_skip = 0;\n      explicit_arg_p = rl_explicit_arg;\n      count_passed = count;\n      direction = 1;\n    }\n  else\n    {\n      if (undo_needed)\n\trl_do_undo ();\n      if (count < 0)\t\t \n        direction = -direction;\n      history_skip += direction;\n      if (history_skip < 0)\n\thistory_skip = 0;\n    }\n \n  if (explicit_arg_p)\n    retval = rl_yank_nth_arg_internal (count_passed, key, history_skip);\n  else\n    retval = rl_yank_nth_arg_internal ('$', key, history_skip);\n\n  undo_needed = retval == 0;\n  return retval;\n}\n\n \nchar *\n_rl_bracketed_text (size_t *lenp)\n{\n  int c;\n  size_t len, cap;\n  char *buf;\n\n  len = 0;\n  buf = xmalloc (cap = 64);\n  buf[0] = '\\0';\n\n  RL_SETSTATE (RL_STATE_MOREINPUT);\n  while ((c = rl_read_key ()) >= 0)\n    {\n      if (RL_ISSTATE (RL_STATE_MACRODEF))\n\t_rl_add_macro_char (c);\n\n      if (c == '\\r')\t\t \n\tc = '\\n';\n\n      if (len == cap)\n\tbuf = xrealloc (buf, cap *= 2);\n\n      buf[len++] = c;\n      if (len >= BRACK_PASTE_SLEN && c == BRACK_PASTE_LAST &&\n\t  STREQN (buf + len - BRACK_PASTE_SLEN, BRACK_PASTE_SUFF, BRACK_PASTE_SLEN))\n\t{\n\t  len -= BRACK_PASTE_SLEN;\n\t  break;\n\t}\n    }\n  RL_UNSETSTATE (RL_STATE_MOREINPUT);\n\n  if (c >= 0)\n    {\n      if (len == cap)\n\tbuf = xrealloc (buf, cap + 1);\n      buf[len] = '\\0';\n    }\n\n  if (lenp)\n    *lenp = len;\n  return (buf);\n}\n\n \nint\nrl_bracketed_paste_begin (int count, int key)\n{\n  int retval, c;\n  size_t len, cap;\n  char *buf;\n\n  buf = _rl_bracketed_text (&len);\n  rl_mark = rl_point;\n  retval = rl_insert_text (buf) == len ? 0 : 1;\n  if (_rl_enable_active_region)\n    rl_activate_mark ();\n\n  xfree (buf);\n  return (retval);\n}\n\nint\n_rl_read_bracketed_paste_prefix (int c)\n{\n  char pbuf[BRACK_PASTE_SLEN+1], *pbpref;\n  int key, ind, j;\n\n  pbpref = BRACK_PASTE_PREF;\t\t \n  if (c != pbpref[0])\n    return (0);\n  pbuf[ind = 0] = c;\n  while (ind < BRACK_PASTE_SLEN-1 &&\n\t (RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n         _rl_pushed_input_available () == 0 &&\n         _rl_input_queued (0))\n    {\n      key = rl_read_key ();\t\t \n      if (key < 0)\n\tbreak;\n      pbuf[++ind] = key;\n      if (pbuf[ind] != pbpref[ind])\n        break;\n    }\n\n  if (ind < BRACK_PASTE_SLEN-1)\t\t \n    {\n      while (ind >= 0)\n\t_rl_unget_char (pbuf[ind--]);\n      return (key < 0 ? key : 0);\n    }\n  return (key < 0 ? key : 1);\n}\n\n \nint\n_rl_bracketed_read_key ()\n{\n  int c, r;\n  char *pbuf;\n  size_t pblen;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  c = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  if (c < 0)\n    return -1;\n\n   \n  if (_rl_enable_bracketed_paste && c == ESC && (r = _rl_read_bracketed_paste_prefix (c)) == 1)\n    {\n      pbuf = _rl_bracketed_text (&pblen);\n      if (pblen == 0)\n\t{\n\t  xfree (pbuf);\n\t  return 0;\t\t \n\t}\n      c = (unsigned char)pbuf[0];\n      if (pblen > 1)\n\t{\n\t  while (--pblen > 0)\n\t    _rl_unget_char ((unsigned char)pbuf[pblen]);\n\t}\n      xfree (pbuf);\n    }\n\n  return c;\n}\n\n \nint\n_rl_bracketed_read_mbstring (char *mb, int mlen)\n{\n  int c, r;\n\n  c = _rl_bracketed_read_key ();\n  if (c < 0)\n    return -1;\n\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    c = _rl_read_mbstring (c, mb, mlen);\n  else\n#endif\n    mb[0] = c;\n  mb[mlen] = '\\0';\t\t \n\n  return c;\n}\n\n \n#if defined (_WIN32)\n#include <windows.h>\n\nint\nrl_paste_from_clipboard (int count, int key)\n{\n  char *data, *ptr;\n  int len;\n\n  if (OpenClipboard (NULL) == 0)\n    return (0);\n\n  data = (char *)GetClipboardData (CF_TEXT);\n  if (data)\n    {\n      ptr = strchr (data, '\\r');\n      if (ptr)\n\t{\n\t  len = ptr - data;\n\t  ptr = (char *)xmalloc (len + 1);\n\t  ptr[len] = '\\0';\n\t  strncpy (ptr, data, len);\n\t}\n      else\n        ptr = data;\n      _rl_set_mark_at_pos (rl_point);\n      rl_insert_text (ptr);\n      if (ptr != data)\n\txfree (ptr);\n      CloseClipboard ();\n    }\n  return (0);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}