{
  "module_name": "macro.c",
  "hash_id": "cba50df903131c7aa56203fe7daa3d305e45f13aa0a35266ae70c58615c9c67c",
  "original_prompt": "Ingested from readline-8.2/macro.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>            \n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n#define MAX_MACRO_LEVEL 16\n\n \n \n \n \n \n\n \nchar *rl_executing_macro = (char *)NULL;\n\n \nstatic int executing_macro_index;\n\n \nstatic char *current_macro = (char *)NULL;\n\n \nstatic int current_macro_size;\n\n \nstatic int current_macro_index;\n\n \nstruct saved_macro {\n  struct saved_macro *next;\n  char *string;\n  int sindex;\n};\n\n \nstatic struct saved_macro *macro_list = (struct saved_macro *)NULL;\n\nstatic int macro_level = 0;\n\n \nvoid\n_rl_with_macro_input (char *string)\n{\n  if (macro_level > MAX_MACRO_LEVEL)\n    {\n      _rl_errmsg (\"maximum macro execution nesting level exceeded\");\n      _rl_abort_internal ();\n      return;\n    }\n\n#if 0\n  if (rl_executing_macro)\t\t \n#endif\n    _rl_push_executing_macro ();\n  rl_executing_macro = string;\n  executing_macro_index = 0;\n  RL_SETSTATE(RL_STATE_MACROINPUT);\n}\n\n \nint\n_rl_next_macro_key (void)\n{\n  int c;\n\n  if (rl_executing_macro == 0)\n    return (0);\n\n  if (rl_executing_macro[executing_macro_index] == 0)\n    {\n      _rl_pop_executing_macro ();\n      return (_rl_next_macro_key ());\n    }\n\n#if defined (READLINE_CALLBACKS)\n  c = rl_executing_macro[executing_macro_index++];\n  if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_READCMD|RL_STATE_MOREINPUT) && rl_executing_macro[executing_macro_index] == 0)\n      _rl_pop_executing_macro ();\n  return c;\n#else\n   \n  return (rl_executing_macro[executing_macro_index++]);\n#endif\n}\n\nint\n_rl_peek_macro_key (void)\n{\n  if (rl_executing_macro == 0)\n    return (0);\n  if (rl_executing_macro[executing_macro_index] == 0 && (macro_list == 0 || macro_list->string == 0))\n    return (0);\n  if (rl_executing_macro[executing_macro_index] == 0 && macro_list && macro_list->string)\n    return (macro_list->string[0]);\n  return (rl_executing_macro[executing_macro_index]);\n}\n\nint\n_rl_prev_macro_key (void)\n{\n  if (rl_executing_macro == 0)\n    return (0);\n\n  if (executing_macro_index == 0)\n    return (0);\n\n  executing_macro_index--;\n  return (rl_executing_macro[executing_macro_index]);\n}\n\n \nvoid\n_rl_push_executing_macro (void)\n{\n  struct saved_macro *saver;\n\n  saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));\n  saver->next = macro_list;\n  saver->sindex = executing_macro_index;\n  saver->string = rl_executing_macro;\n\n  macro_list = saver;\n\n  macro_level++;\n}\n\n \nvoid\n_rl_pop_executing_macro (void)\n{\n  struct saved_macro *macro;\n\n  FREE (rl_executing_macro);\n  rl_executing_macro = (char *)NULL;\n  executing_macro_index = 0;\n\n  if (macro_list)\n    {\n      macro = macro_list;\n      rl_executing_macro = macro_list->string;\n      executing_macro_index = macro_list->sindex;\n      macro_list = macro_list->next;\n      xfree (macro);\n    }\n\n  macro_level--;\n\n  if (rl_executing_macro == 0)\n    RL_UNSETSTATE(RL_STATE_MACROINPUT);\n}\n\n \nvoid\n_rl_add_macro_char (int c)\n{\n  if (current_macro_index + 1 >= current_macro_size)\n    {\n      if (current_macro == 0)\n\tcurrent_macro = (char *)xmalloc (current_macro_size = 25);\n      else\n\tcurrent_macro = (char *)xrealloc (current_macro, current_macro_size += 25);\n    }\n\n  current_macro[current_macro_index++] = c;\n  current_macro[current_macro_index] = '\\0';\n}\n\nvoid\n_rl_kill_kbd_macro (void)\n{\n  if (current_macro)\n    {\n      xfree (current_macro);\n      current_macro = (char *) NULL;\n    }\n  current_macro_size = current_macro_index = 0;\n\n  FREE (rl_executing_macro);\n  rl_executing_macro = (char *) NULL;\n  executing_macro_index = 0;\n\n  RL_UNSETSTATE(RL_STATE_MACRODEF);\n}\n\n \nint\nrl_start_kbd_macro (int ignore1, int ignore2)\n{\n  if (RL_ISSTATE (RL_STATE_MACRODEF))\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n\n  if (rl_explicit_arg)\n    {\n      if (current_macro)\n\t_rl_with_macro_input (savestring (current_macro));\n    }\n  else\n    current_macro_index = 0;\n\n  RL_SETSTATE(RL_STATE_MACRODEF);\n  return 0;\n}\n\n \nint\nrl_end_kbd_macro (int count, int ignore)\n{\n  if (RL_ISSTATE (RL_STATE_MACRODEF) == 0)\n    {\n      _rl_abort_internal ();\n      return 1;\n    }\n\n  current_macro_index -= rl_key_sequence_length;\n  if (current_macro_index < 0)\n    current_macro_index = 0;\n  current_macro[current_macro_index] = '\\0';\n\n  RL_UNSETSTATE(RL_STATE_MACRODEF);\n\n  return (rl_call_last_kbd_macro (--count, 0));\n}\n\n \nint\nrl_call_last_kbd_macro (int count, int ignore)\n{\n  if (current_macro == 0)\n    _rl_abort_internal ();\n\n  if (RL_ISSTATE (RL_STATE_MACRODEF))\n    {\n      rl_ding ();\t\t \n      current_macro[--current_macro_index] = '\\0';\t \n      return 0;\n    }\n\n  while (count--)\n    _rl_with_macro_input (savestring (current_macro));\n  return 0;\n}\n\nint\nrl_print_last_kbd_macro (int count, int ignore)\n{\n  char *m;\n\n  if (current_macro == 0)\n    {\n      rl_ding ();\n      return 0;\n    }\n  m = _rl_untranslate_macro_value (current_macro, 1);\n  rl_crlf ();\n  printf (\"%s\", m);\n  fflush (stdout);\n  rl_crlf ();\n  FREE (m);\n  rl_forced_update_display ();\n  rl_display_fixed = 1;\n\n  return 0;\n}\n\nvoid\nrl_push_macro_input (char *macro)\n{\n  _rl_with_macro_input (macro);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}