{
  "module_name": "histexpand.c",
  "hash_id": "a03feb8ebb09154d281bd38b3b2c1378df8e895a50be4c8dee06d3faf04440a5",
  "original_prompt": "Ingested from readline-8.2/histexpand.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  ifndef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"rlmbutil.h\"\n\n#include \"history.h\"\n#include \"histlib.h\"\n#include \"chardefs.h\"\n\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n#define HISTORY_WORD_DELIMITERS\t\t\" \\t\\n;&()|<>\"\n#define HISTORY_QUOTE_CHARACTERS\t\"\\\"'`\"\n#define HISTORY_EVENT_DELIMITERS\t\"^$*%-\"\n\n#define slashify_in_quotes \"\\\\`\\\"$\"\n\n#define fielddelim(c)\t(whitespace(c) || (c) == '\\n')\n\ntypedef int _hist_search_func_t (const char *, int);\n\nstatic char error_pointer;\n\nstatic char *subst_lhs;\nstatic char *subst_rhs;\nstatic int subst_lhs_len;\nstatic int subst_rhs_len;\n\n \nstatic char *history_event_delimiter_chars = HISTORY_EVENT_DELIMITERS;\n\nstatic char *get_history_word_specifier (char *, char *, int *);\nstatic int history_tokenize_word (const char *, int);\nstatic char **history_tokenize_internal (const char *, int, int *);\nstatic char *history_substring (const char *, int, int);\nstatic void freewords (char **, int);\nstatic char *history_find_word (char *, int);\n\nstatic char *quote_breaks (char *);\n\n \n \nchar history_expansion_char = '!';\n\n \nchar history_subst_char = '^';\n\n \nchar history_comment_char = '\\0';\n\n \nchar *history_no_expand_chars = \" \\t\\n\\r=\";\n\n \nint history_quotes_inhibit_expansion = 0;\n\n \nchar *history_word_delimiters = HISTORY_WORD_DELIMITERS;\n\n \nrl_linebuf_func_t *history_inhibit_expansion_function;\n\nint history_quoting_state = 0;\n\n \n \n \n \n \n\n \n\n \nstatic char *search_string;\n \nstatic char *search_match;\n\n \nchar *\nget_history_event (const char *string, int *caller_index, int delimiting_quote)\n{\n  register int i;\n  register char c;\n  HIST_ENTRY *entry;\n  int which, sign, local_index, substring_okay;\n  _hist_search_func_t *search_func;\n  char *temp;\n\n   \n\n  i = *caller_index;\n\n  if (string[i] != history_expansion_char)\n    return ((char *)NULL);\n\n   \n  i++;\n\n  sign = 1;\n  substring_okay = 0;\n\n#define RETURN_ENTRY(e, w) \\\n\treturn ((e = history_get (w)) ? e->line : (char *)NULL)\n\n   \n  if (string[i] == history_expansion_char)\n    {\n      i++;\n      which = history_base + (history_length - 1);\n      *caller_index = i;\n      RETURN_ENTRY (entry, which);\n    }\n\n   \n  if (string[i] == '-' && _rl_digit_p (string[i+1]))\n    {\n      sign = -1;\n      i++;\n    }\n\n  if (_rl_digit_p (string[i]))\n    {\n       \n      for (which = 0; _rl_digit_p (string[i]); i++)\n\twhich = (which * 10) + _rl_digit_value (string[i]);\n\n      *caller_index = i;\n\n      if (sign < 0)\n\twhich = (history_length + history_base) - which;\n\n      RETURN_ENTRY (entry, which);\n    }\n\n   \n  if (string[i] == '?')\n    {\n      substring_okay++;\n      i++;\n    }\n\n   \n  for (local_index = i; c = string[i]; i++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  int v;\n\t  mbstate_t ps;\n\n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t   \n\t  _rl_adjust_point ((char *)string, i, &ps);\n\t  if ((v = _rl_get_char_len ((char *)string + i, &ps)) > 1)\n\t    {\n\t      i += v - 1;\n\t      continue;\n\t    }\n        }\n\n#endif  \n      if ((!substring_okay &&\n\t    (whitespace (c) || c == ':' ||\n\t    (i > local_index && history_event_delimiter_chars && c == '-') ||\n\t    (c != '-' && history_event_delimiter_chars && member (c, history_event_delimiter_chars)) ||\n\t    (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||\n\t    string[i] == delimiting_quote)) ||\n\t  string[i] == '\\n' ||\n\t  (substring_okay && string[i] == '?'))\n\tbreak;\n    }\n\n  which = i - local_index;\n  temp = (char *)xmalloc (1 + which);\n  if (which)\n    strncpy (temp, string + local_index, which);\n  temp[which] = '\\0';\n\n  if (substring_okay && string[i] == '?')\n    i++;\n\n  *caller_index = i;\n\n#define FAIL_SEARCH() \\\n  do { \\\n    history_offset = history_length; xfree (temp) ; return (char *)NULL; \\\n  } while (0)\n\n   \n  if (*temp == '\\0' && substring_okay)\n    {\n      if (search_string)\n        {\n          xfree (temp);\n          temp = savestring (search_string);\n        }\n      else\n        FAIL_SEARCH ();\n    }\n\n  search_func = substring_okay ? history_search : history_search_prefix;\n  while (1)\n    {\n      local_index = (*search_func) (temp, -1);\n\n      if (local_index < 0)\n\tFAIL_SEARCH ();\n\n      if (local_index == 0 || substring_okay)\n\t{\n\t  entry = current_history ();\n\t  if (entry == 0)\n\t    FAIL_SEARCH ();\n\t  history_offset = history_length;\n\t\n\t   \n\t  if (substring_okay)\n\t    {\n\t      FREE (search_string);\n\t      search_string = temp;\n\n\t      FREE (search_match);\n\t      search_match = history_find_word (entry->line, local_index);\n\t    }\n\t  else\n\t    xfree (temp);\n\n\t  return (entry->line);\n\t}\n\n      if (history_offset)\n\thistory_offset--;\n      else\n\tFAIL_SEARCH ();\n    }\n#undef FAIL_SEARCH\n#undef RETURN_ENTRY\n}\n\n \n\n \nstatic void\nhist_string_extract_single_quoted (char *string, int *sindex, int flags)\n{\n  register int i;\n\n  for (i = *sindex; string[i] && string[i] != '\\''; i++)\n    {\n      if ((flags & 1) && string[i] == '\\\\' && string[i+1])\n        i++;\n    }\n\n  *sindex = i;\n}\n\nstatic char *\nquote_breaks (char *s)\n{\n  register char *p, *r;\n  char *ret;\n  int len = 3;\n\n  for (p = s; p && *p; p++, len++)\n    {\n      if (*p == '\\'')\n\tlen += 3;\n      else if (whitespace (*p) || *p == '\\n')\n\tlen += 2;\n    }\n\n  r = ret = (char *)xmalloc (len);\n  *r++ = '\\'';\n  for (p = s; p && *p; )\n    {\n      if (*p == '\\'')\n\t{\n\t  *r++ = '\\'';\n\t  *r++ = '\\\\';\n\t  *r++ = '\\'';\n\t  *r++ = '\\'';\n\t  p++;\n\t}\n      else if (whitespace (*p) || *p == '\\n')\n\t{\n\t  *r++ = '\\'';\n\t  *r++ = *p++;\n\t  *r++ = '\\'';\n\t}\n      else\n\t*r++ = *p++;\n    }\n  *r++ = '\\'';\n  *r = '\\0';\n  return ret;\n}\n\nstatic char *\nhist_error(char *s, int start, int current, int errtype)\n{\n  char *temp;\n  const char *emsg;\n  int ll, elen;\n\n  ll = current - start;\n\n  switch (errtype)\n    {\n    case EVENT_NOT_FOUND:\n      emsg = \"event not found\";\n      elen = 15;\n      break;\n    case BAD_WORD_SPEC:\n      emsg = \"bad word specifier\";\n      elen = 18;\n      break;\n    case SUBST_FAILED:\n      emsg = \"substitution failed\";\n      elen = 19;\n      break;\n    case BAD_MODIFIER:\n      emsg = \"unrecognized history modifier\";\n      elen = 29;\n      break;\n    case NO_PREV_SUBST:\n      emsg = \"no previous substitution\";\n      elen = 24;\n      break;\n    default:\n      emsg = \"unknown expansion error\";\n      elen = 23;\n      break;\n    }\n\n  temp = (char *)xmalloc (ll + elen + 3);\n  if (s[start])\n    strncpy (temp, s + start, ll);\n  else\n    ll = 0;\n  temp[ll] = ':';\n  temp[ll + 1] = ' ';\n  strcpy (temp + ll + 2, emsg);\n  return (temp);\n}\n\n \n\nstatic char *\nget_subst_pattern (char *str, int *iptr, int delimiter, int is_rhs, int *lenptr)\n{\n  register int si, i, j, k;\n  char *s;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n#endif\n\n  s = (char *)NULL;\n  i = *iptr;\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (&ps, 0, sizeof (mbstate_t));\n  _rl_adjust_point (str, i, &ps);\n#endif\n\n  for (si = i; str[si] && str[si] != delimiter; si++)\n#if defined (HANDLE_MULTIBYTE)\n    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n      {\n\tint v;\n\tif ((v = _rl_get_char_len (str + si, &ps)) > 1)\n\t  si += v - 1;\n\telse if (str[si] == '\\\\' && str[si + 1] == delimiter)\n\t  si++;\n      }\n    else\n#endif  \n      if (str[si] == '\\\\' && str[si + 1] == delimiter)\n\tsi++;\n\n  if (si > i || is_rhs)\n    {\n      s = (char *)xmalloc (si - i + 1);\n      for (j = 0, k = i; k < si; j++, k++)\n\t{\n\t   \n\t  if (str[k] == '\\\\' && str[k + 1] == delimiter)\n\t    k++;\n\t  s[j] = str[k];\n\t}\n      s[j] = '\\0';\n      if (lenptr)\n\t*lenptr = j;\n    }\n\n  i = si;\n  if (str[i])\n    i++;\n  *iptr = i;\n\n  return s;\n}\n\nstatic void\npostproc_subst_rhs (void)\n{\n  char *new;\n  int i, j, new_size;\n\n  new = (char *)xmalloc (new_size = subst_rhs_len + subst_lhs_len);\n  for (i = j = 0; i < subst_rhs_len; i++)\n    {\n      if (subst_rhs[i] == '&')\n\t{\n\t  if (j + subst_lhs_len >= new_size)\n\t    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));\n\t  strcpy (new + j, subst_lhs);\n\t  j += subst_lhs_len;\n\t}\n      else\n\t{\n\t   \n\t  if (subst_rhs[i] == '\\\\' && subst_rhs[i + 1] == '&')\n\t    i++;\n\t  if (j >= new_size)\n\t    new = (char *)xrealloc (new, new_size *= 2);\n\t  new[j++] = subst_rhs[i];\n\t}\n    }\n  new[j] = '\\0';\n  xfree (subst_rhs);\n  subst_rhs = new;\n  subst_rhs_len = j;\n}\n\n \n \nstatic int\nhistory_expand_internal (char *string, int start, int qc, int *end_index_ptr, char **ret_string, char *current_line)\n{\n  int i, n, starting_index;\n  int substitute_globally, subst_bywords, want_quotes, print_only;\n  char *event, *temp, *result, *tstr, *t, c, *word_spec;\n  int result_len;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n\n  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n  result = (char *)xmalloc (result_len = 128);\n\n  i = start;\n\n   \n\n  if (member (string[i + 1], \":$*%^\"))\n    {\n      char fake_s[3];\n      int fake_i = 0;\n      i++;\n      fake_s[0] = fake_s[1] = history_expansion_char;\n      fake_s[2] = '\\0';\n      event = get_history_event (fake_s, &fake_i, 0);\n    }\n  else if (string[i + 1] == '#')\n    {\n      i += 2;\n      event = current_line;\n    }\n  else\n    event = get_history_event (string, &i, qc);\n\t  \n  if (event == 0)\n    {\n      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);\n      xfree (result);\n      return (-1);\n    }\n\n   \n  starting_index = i;\n  word_spec = get_history_word_specifier (string, event, &i);\n\n   \n  if (word_spec == (char *)&error_pointer)\n    {\n      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);\n      xfree (result);\n      return (-1);\n    }\n\n   \n  temp = word_spec ? savestring (word_spec) : savestring (event);\n  FREE (word_spec);\n\n   \n  want_quotes = substitute_globally = subst_bywords = print_only = 0;\n  starting_index = i;\n\n  while (string[i] == ':')\n    {\n      c = string[i + 1];\n\n      if (c == 'g' || c == 'a')\n\t{\n\t  substitute_globally = 1;\n\t  i++;\n\t  c = string[i + 1];\n\t}\n      else if (c == 'G')\n\t{\n\t  subst_bywords = 1;\n\t  i++;\n\t  c = string[i + 1];\n\t}\n\n      switch (c)\n\t{\n\tdefault:\n\t  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);\n\t  xfree (result);\n\t  xfree (temp);\n\t  return -1;\n\n\tcase 'q':\n\t  want_quotes = 'q';\n\t  break;\n\n\tcase 'x':\n\t  want_quotes = 'x';\n\t  break;\n\n\t   \n\tcase 'p':\n\t  print_only = 1;\n\t  break;\n\n\t   \n\tcase 't':\n\t  tstr = strrchr (temp, '/');\n\t  if (tstr)\n\t    {\n\t      tstr++;\n\t      t = savestring (tstr);\n\t      xfree (temp);\n\t      temp = t;\n\t    }\n\t  break;\n\n\t   \n\tcase 'h':\n\t  tstr = strrchr (temp, '/');\n\t  if (tstr)\n\t    *tstr = '\\0';\n\t  break;\n\n\t   \n\tcase 'r':\n\t  tstr = strrchr (temp, '.');\n\t  if (tstr)\n\t    *tstr = '\\0';\n\t  break;\n\n\t   \n\tcase 'e':\n\t  tstr = strrchr (temp, '.');\n\t  if (tstr)\n\t    {\n\t      t = savestring (tstr);\n\t      xfree (temp);\n\t      temp = t;\n\t    }\n\t  break;\n\n\t \n\n\tcase '&':\n\tcase 's':\n\t  {\n\t    char *new_event;\n\t    int delimiter, failed, si, l_temp, ws, we;\n\n\t    if (c == 's')\n\t      {\n\t\tif (i + 2 < (int)strlen (string))\n\t\t  {\n#if defined (HANDLE_MULTIBYTE)\n\t\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t\t      {\n\t\t\t_rl_adjust_point (string, i + 2, &ps);\n\t\t\tif (_rl_get_char_len (string + i + 2, &ps) > 1)\n\t\t\t  delimiter = 0;\n\t\t\telse\n\t\t\t  delimiter = string[i + 2];\n\t\t      }\n\t\t    else\n#endif  \n\t\t      delimiter = string[i + 2];\n\t\t  }\n\t\telse\n\t\t  break;\t \n\n\t\ti += 3;\n\n\t\tt = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);\n\t\t \n\t\tif (t)\n\t\t  {\n\t\t    FREE (subst_lhs);\n\t\t    subst_lhs = t;\n\t\t  }\n\t\telse if (!subst_lhs)\n\t\t  {\n\t\t    if (search_string && *search_string)\n\t\t      {\n\t\t\tsubst_lhs = savestring (search_string);\n\t\t\tsubst_lhs_len = strlen (subst_lhs);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tsubst_lhs = (char *) NULL;\n\t\t\tsubst_lhs_len = 0;\n\t\t      }\n\t\t  }\n\n\t\tFREE (subst_rhs);\n\t\tsubst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);\n\n\t\t \n\t\tif (member ('&', subst_rhs))\n\t\t  postproc_subst_rhs ();\n\t      }\n\t    else\n\t      i += 2;\n\n\t     \n\t    if (subst_lhs_len == 0)\n\t      {\n\t\t*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);\n\t\txfree (result);\n\t\txfree (temp);\n\t\treturn -1;\n\t      }\n\n\t    l_temp = strlen (temp);\n\t     \n\t    if (subst_lhs_len > l_temp)\n\t      {\n\t\t*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);\n\t\txfree (result);\n\t\txfree (temp);\n\t\treturn (-1);\n\t      }\n\n\t     \n\t     \n\n\t    si = we = 0;\n\t    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)\n\t      {\n\t\t \n\t\tif (subst_bywords && si > we)\n\t\t  {\n\t\t    for (; temp[si] && fielddelim (temp[si]); si++)\n\t\t      ;\n\t\t    ws = si;\n\t\t    we = history_tokenize_word (temp, si);\n\t\t  }\n\n\t\tif (STREQN (temp+si, subst_lhs, subst_lhs_len))\n\t\t  {\n\t\t    int len = subst_rhs_len - subst_lhs_len + l_temp;\n\t\t    new_event = (char *)xmalloc (1 + len);\n\t\t    strncpy (new_event, temp, si);\n\t\t    strncpy (new_event + si, subst_rhs, subst_rhs_len);\n\t\t    strncpy (new_event + si + subst_rhs_len,\n\t\t\t     temp + si + subst_lhs_len,\n\t\t\t     l_temp - (si + subst_lhs_len));\n\t\t    new_event[len] = '\\0';\n\t\t    xfree (temp);\n\t\t    temp = new_event;\n\n\t\t    failed = 0;\n\n\t\t    if (substitute_globally)\n\t\t      {\n\t\t\t \n\t\t\tsi += subst_rhs_len - 1;\n\t\t\tl_temp = strlen (temp);\n\t\t\tsubstitute_globally++;\n\t\t\tcontinue;\n\t\t      }\n\t\t    else if (subst_bywords)\n\t\t      {\n\t\t\tsi = we;\n\t\t\tl_temp = strlen (temp);\n\t\t\tcontinue;\n\t\t      }\n\t\t    else\n\t\t      break;\n\t\t  }\n\t      }\n\n\t    if (substitute_globally > 1)\n\t      {\n\t\tsubstitute_globally = 0;\n\t\tcontinue;\t \n\t      }\n\n\t    if (failed == 0)\n\t      continue;\t\t \n\n\t    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);\n\t    xfree (result);\n\t    xfree (temp);\n\t    return (-1);\n\t  }\n\t}\n      i += 2;\n    }\n   \n   \n  --i;\n\n  if (want_quotes)\n    {\n      char *x;\n\n      if (want_quotes == 'q')\n\tx = sh_single_quote (temp);\n      else if (want_quotes == 'x')\n\tx = quote_breaks (temp);\n      else\n\tx = savestring (temp);\n\n      xfree (temp);\n      temp = x;\n    }\n\n  n = strlen (temp);\n  if (n >= result_len)\n    result = (char *)xrealloc (result, n + 2);\n  strcpy (result, temp);\n  xfree (temp);\n\n  *end_index_ptr = i;\n  *ret_string = result;\n  return (print_only);\n}\n\n \n\n#define ADD_STRING(s) \\\n\tdo \\\n\t  { \\\n\t    int sl = strlen (s); \\\n\t    j += sl; \\\n\t    if (j >= result_len) \\\n\t      { \\\n\t\twhile (j >= result_len) \\\n\t\t  result_len += 128; \\\n\t\tresult = (char *)xrealloc (result, result_len); \\\n\t      } \\\n\t    strcpy (result + j - sl, s); \\\n\t  } \\\n\twhile (0)\n\n#define ADD_CHAR(c) \\\n\tdo \\\n\t  { \\\n\t    if (j >= result_len - 1) \\\n\t      result = (char *)xrealloc (result, result_len += 64); \\\n\t    result[j++] = c; \\\n\t    result[j] = '\\0'; \\\n\t  } \\\n\twhile (0)\n\nint\nhistory_expand (char *hstring, char **output)\n{\n  register int j;\n  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, squote, flag;\n  char *string;\n\n   \n  int result_len;\n  char *result;\n\n#if defined (HANDLE_MULTIBYTE)\n  char mb[MB_LEN_MAX];\n  mbstate_t ps;\n#endif\n\n   \n  char *temp;\n\n  if (output == 0)\n    return 0;\n\n   \n  if (history_expansion_char == 0)\n    {\n      *output = savestring (hstring);\n      return (0);\n    }\n    \n   \n  result = (char *)xmalloc (result_len = 256);\n  result[0] = '\\0';\n\n  only_printing = modified = 0;\n  l = strlen (hstring);\n\n   \n\n   \n\n   \n  if (hstring[0] == history_subst_char)\n    {\n      string = (char *)xmalloc (l + 5);\n\n      string[0] = string[1] = history_expansion_char;\n      string[2] = ':';\n      string[3] = 's';\n      strcpy (string + 4, hstring);\n      l += 4;\n    }\n  else\n    {\n#if defined (HANDLE_MULTIBYTE)\n      memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n      string = hstring;\n       \n\n       \n      dquote = history_quoting_state == '\"';\n      squote = history_quoting_state == '\\'';\n\n       \n      i = 0;\n      if (squote && history_quotes_inhibit_expansion)\n\t{\n\t  hist_string_extract_single_quoted (string, &i, 0);\n\t  squote = 0;\n\t  if (string[i])\n\t    i++;\n\t}\n\n      for ( ; string[i]; i++)\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t    {\n\t      int v;\n\t      v = _rl_get_char_len (string + i, &ps);\n\t      if (v > 1)\n\t\t{\n\t\t  i += v - 1;\n\t\t  continue;\n\t\t}\n\t    }\n#endif  \n\n\t  cc = string[i + 1];\n\t   \n\t  if (history_comment_char && string[i] == history_comment_char &&\n\t      dquote == 0 &&\n\t      (i == 0 || member (string[i - 1], history_word_delimiters)))\n\t    {\n\t      while (string[i])\n\t\ti++;\n\t      break;\n\t    }\n\t  else if (string[i] == history_expansion_char)\n\t    {\n\t      if (cc == 0 || member (cc, history_no_expand_chars))\n\t\tcontinue;\n\t       \n\t      else if (dquote && cc == '\"')\n\t\tcontinue;\n\t       \n\t      else if (history_inhibit_expansion_function &&\n\t\t\t(*history_inhibit_expansion_function) (string, i))\n\t\tcontinue;\n\t      else\n\t\tbreak;\n\t    }\n\t   \n\t  else if (dquote && string[i] == '\\\\' && cc == '\"')\n\t    i++;\n\t   \n\t  else if (history_quotes_inhibit_expansion && string[i] == '\"')\n\t    {\n\t      dquote = 1 - dquote;\n\t    }\n\t  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\\'')\n\t    {\n\t       \n\t      flag = (i > 0 && string[i - 1] == '$');\n\t      i++;\n\t      hist_string_extract_single_quoted (string, &i, flag);\n\t    }\n\t  else if (history_quotes_inhibit_expansion && string[i] == '\\\\')\n\t    {\n\t       \n\t      if (cc == '\\'' || cc == history_expansion_char)\n\t\ti++;\n\t    }\n\t  \n\t}\n\t  \n      if (string[i] != history_expansion_char)\n\t{\n\t  xfree (result);\n\t  *output = savestring (string);\n\t  return (0);\n\t}\n    }\n\n   \n  dquote = history_quoting_state == '\"';\n  squote = history_quoting_state == '\\'';\n\n   \n  i = j = 0;\n  if (squote && history_quotes_inhibit_expansion)\n    {\n      int c;\n\n      hist_string_extract_single_quoted (string, &i, 0);\n      squote = 0;\n      for (c = 0; c < i; c++)\n\tADD_CHAR (string[c]);      \n      if (string[i])\n\t{\n\t  ADD_CHAR (string[i]);\n\t  i++;\n\t}\n    }\n\n  for (passc = 0; i < l; i++)\n    {\n      int qc, tchar = string[i];\n\n      if (passc)\n\t{\n\t  passc = 0;\n\t  ADD_CHAR (tchar);\n\t  continue;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  int k, c;\n\n\t  c = tchar;\n\t  memset (mb, 0, sizeof (mb));\n\t  for (k = 0; k < MB_LEN_MAX; k++)\n\t    {\n\t      mb[k] = (char)c;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t      if (_rl_get_char_len (mb, &ps) == -2)\n\t\tc = string[++i];\n\t      else\n\t\tbreak;\n\t    }\n\t  if (strlen (mb) > 1)\n\t    {\n\t      ADD_STRING (mb);\n\t      continue;\n\t    }\n\t}\n#endif  \n\n      if (tchar == history_expansion_char)\n\ttchar = -3;\n      else if (tchar == history_comment_char)\n\ttchar = -2;\n\n      switch (tchar)\n\t{\n\tdefault:\n\t  ADD_CHAR (string[i]);\n\t  break;\n\n\tcase '\\\\':\n\t  passc++;\n\t  ADD_CHAR (tchar);\n\t  break;\n\n\tcase '\"':\n\t  dquote = 1 - dquote;\n\t  ADD_CHAR (tchar);\n\t  break;\n\t  \n\tcase '\\'':\n\t  {\n\t     \n\t    if (squote)\n\t      {\n\t        squote = 0;\n\t        ADD_CHAR (tchar);\n\t      }\n\t    else if (dquote == 0 && history_quotes_inhibit_expansion)\n\t      {\n\t\tint quote, slen;\n\n\t\tflag = (i > 0 && string[i - 1] == '$');\n\t\tquote = i++;\n\t\thist_string_extract_single_quoted (string, &i, flag);\n\n\t\tslen = i - quote + 2;\n\t\ttemp = (char *)xmalloc (slen);\n\t\tstrncpy (temp, string + quote, slen);\n\t\ttemp[slen - 1] = '\\0';\n\t\tADD_STRING (temp);\n\t\txfree (temp);\n\t      }\n\t    else if (dquote == 0 && squote == 0 && history_quotes_inhibit_expansion == 0)\n\t      {\n\t        squote = 1;\n\t        ADD_CHAR (string[i]);\n\t      }\n\t    else\n\t      ADD_CHAR (string[i]);\n\t    break;\n\t  }\n\n\tcase -2:\t\t \n\t  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&\n\t      (i == 0 || member (string[i - 1], history_word_delimiters)))\n\t    {\n\t      temp = (char *)xmalloc (l - i + 1);\n\t      strcpy (temp, string + i);\n\t      ADD_STRING (temp);\n\t      xfree (temp);\n\t      i = l;\n\t    }\n\t  else\n\t    ADD_CHAR (string[i]);\n\t  break;\n\n\tcase -3:\t\t \n\t  cc = string[i + 1];\n\n\t   \n\t  if (cc == 0 || member (cc, history_no_expand_chars) ||\n\t\t\t (dquote && cc == '\"'))\n\t    {\n\t      ADD_CHAR (string[i]);\n\t      break;\n\t    }\n\n\t   \n\t   \n\t  if (history_inhibit_expansion_function)\n\t    {\n\t      int save_j, temp;\n\n\t      save_j = j;\n\t      ADD_CHAR (string[i]);\n\t      ADD_CHAR (cc);\n\n\t      temp = (*history_inhibit_expansion_function) (result, save_j);\n\t      if (temp)\n\t\t{\n\t\t  result[--j] = '\\0';\t \n\t\t  break;\n\t\t}\n\t      else\n\t        result[j = save_j] = '\\0';\n\t    }\n\n#if defined (NO_BANG_HASH_MODIFIERS)\n\t   \n\t  if (cc == '#')\n\t    {\n\t      if (result)\n\t\t{\n\t\t  temp = (char *)xmalloc (1 + strlen (result));\n\t\t  strcpy (temp, result);\n\t\t  ADD_STRING (temp);\n\t\t  xfree (temp);\n\t\t}\n\t      i++;\n\t      break;\n\t    }\n#endif\n\t  qc = squote ? '\\'' : (dquote ? '\"' : 0);\n\t  r = history_expand_internal (string, i, qc, &eindex, &temp, result);\n\t  if (r < 0)\n\t    {\n\t      *output = temp;\n\t      xfree (result);\n\t      if (string != hstring)\n\t\txfree (string);\n\t      return -1;\n\t    }\n\t  else\n\t    {\n\t      if (temp)\n\t\t{\n\t\t  modified++;\n\t\t  if (*temp)\n\t\t    ADD_STRING (temp);\n\t\t  xfree (temp);\n\t\t}\n\t      only_printing += r == 1;\n\t      i = eindex;\n\t    }\n\t  break;\n\t}\n    }\n\n  *output = result;\n  if (string != hstring)\n    xfree (string);\n\n  if (only_printing)\n    {\n#if 0\n      add_history (result);\n#endif\n      return (2);\n    }\n\n  return (modified != 0);\n}\n\n \nstatic char *\nget_history_word_specifier (char *spec, char *from, int *caller_index)\n{\n  register int i = *caller_index;\n  int first, last;\n  int expecting_word_spec = 0;\n  char *result;\n\n   \n  first = last = 0;\n  result = (char *)NULL;\n\n   \n  if (spec[i] == ':')\n    {\n      i++;\n      expecting_word_spec++;\n    }\n\n   \n\n   \n  if (spec[i] == '%')\n    {\n      *caller_index = i + 1;\n      return (search_match ? savestring (search_match) : savestring (\"\"));\n    }\n\n   \n  if (spec[i] == '*')\n    {\n      *caller_index = i + 1;\n      result = history_arg_extract (1, '$', from);\n      return (result ? result : savestring (\"\"));\n    }\n\n   \n  if (spec[i] == '$')\n    {\n      *caller_index = i + 1;\n      return (history_arg_extract ('$', '$', from));\n    }\n\n   \n\n  if (spec[i] == '-')\n    first = 0;\n  else if (spec[i] == '^')\n    {\n      first = 1;\n      i++;\n    }\n  else if (_rl_digit_p (spec[i]) && expecting_word_spec)\n    {\n      for (first = 0; _rl_digit_p (spec[i]); i++)\n\tfirst = (first * 10) + _rl_digit_value (spec[i]);\n    }\n  else\n    return ((char *)NULL);\t \n\n  if (spec[i] == '^' || spec[i] == '*')\n    {\n      last = (spec[i] == '^') ? 1 : '$';\t \n      i++;\n    }\n  else if (spec[i] != '-')\n    last = first;\n  else\n    {\n      i++;\n\n      if (_rl_digit_p (spec[i]))\n\t{\n\t  for (last = 0; _rl_digit_p (spec[i]); i++)\n\t    last = (last * 10) + _rl_digit_value (spec[i]);\n\t}\n      else if (spec[i] == '$')\n\t{\n\t  i++;\n\t  last = '$';\n\t}\n      else if (spec[i] == '^')\n\t{\n\t  i++;\n\t  last = 1;\n\t}\n#if 0\n      else if (!spec[i] || spec[i] == ':')\n\t \n#else\n      else\n\t \n#endif\n\tlast = -1;\t\t \n    }\n\n  *caller_index = i;\n\n  if (last >= first || last == '$' || last < 0)\n    result = history_arg_extract (first, last, from);\n\n  return (result ? result : (char *)&error_pointer);\n}\n\n \nchar *\nhistory_arg_extract (int first, int last, const char *string)\n{\n  register int i, len;\n  char *result;\n  int size, offset;\n  char **list;\n\n   \n  if ((list = history_tokenize (string)) == NULL)\n    return ((char *)NULL);\n\n  for (len = 0; list[len]; len++)\n    ;\n\n  if (last < 0)\n    last = len + last - 1;\n\n  if (first < 0)\n    first = len + first - 1;\n\n  if (last == '$')\n    last = len - 1;\n\n  if (first == '$')\n    first = len - 1;\n\n  last++;\n\n  if (first >= len || last > len || first < 0 || last < 0 || first > last)\n    result = ((char *)NULL);\n  else\n    {\n      for (size = 0, i = first; i < last; i++)\n\tsize += strlen (list[i]) + 1;\n      result = (char *)xmalloc (size + 1);\n      result[0] = '\\0';\n\n      for (i = first, offset = 0; i < last; i++)\n\t{\n\t  strcpy (result + offset, list[i]);\n\t  offset += strlen (list[i]);\n\t  if (i + 1 < last)\n\t    {\n      \t      result[offset++] = ' ';\n\t      result[offset] = 0;\n\t    }\n\t}\n    }\n\n  for (i = 0; i < len; i++)\n    xfree (list[i]);\n  xfree (list);\n\n  return (result);\n}\n\nstatic int\nhistory_tokenize_word (const char *string, int ind)\n{\n  register int i, j;\n  int delimiter, nestdelim, delimopen;\n\n  i = ind;\n  delimiter = nestdelim = 0;\n\n  if (member (string[i], \"()\\n\"))\t \n    {\n      i++;\n      return i;\n    }\n\n  if (ISDIGIT (string[i]))\n    {\n      j = i;\n      while (string[j] && ISDIGIT (string[j]))\n\tj++;\n      if (string[j] == 0)\n\treturn (j);\n      if (string[j] == '<' || string[j] == '>')\n\ti = j;\t\t\t \n      else\n\t{\n\t  i = j;\n\t  goto get_word;\t \n\t}\n    }\n\n  if (member (string[i], \"<>;&|\"))\n    {\n      int peek = string[i + 1];\n\n      if (peek == string[i])\n\t{\n\t  if (peek == '<' && string[i + 2] == '-')\n\t    i++;\n\t  else if (peek == '<' && string[i + 2] == '<')\n\t    i++;\n\t  i += 2;\n\t  return i;\n\t}\n      else if (peek == '&' && (string[i] == '>' || string[i] == '<'))\n\t{\n\t  j = i + 2;\n\t  while (string[j] && ISDIGIT (string[j]))\t \n\t    j++;\n\t  if (string[j] =='-')\t\t \n\t    j++;\n\t  return j;\n\t}\n      else if ((peek == '>' && string[i] == '&') || (peek == '|' && string[i] == '>'))\n\t{\n\t  i += 2;\n\t  return i;\n\t}\n       \n      else if (peek == '(' && (string[i] == '>' || string[i] == '<'))  \n\t{\n\t  i += 2;\n\t  delimopen = '(';\n\t  delimiter = ')';\n\t  nestdelim = 1;\n\t  goto get_word;\n\t}\n\n      i++;\n      return i;\n    }\n\nget_word:\n   \n\n  if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))\n    delimiter = string[i++];\n\n  for (; string[i]; i++)\n    {\n      if (string[i] == '\\\\' && string[i + 1] == '\\n')\n\t{\n\t  i++;\n\t  continue;\n\t}\n\n      if (string[i] == '\\\\' && delimiter != '\\'' &&\n\t  (delimiter != '\"' || member (string[i], slashify_in_quotes)))\n\t{\n\t  i++;\n\t  continue;\n\t}\n\n       \n      if (nestdelim && string[i] == delimopen)\n\t{\n\t  nestdelim++;\n\t  continue;\n\t}\n      if (nestdelim && string[i] == delimiter)\n\t{\n\t  nestdelim--;\n\t  if (nestdelim == 0)\n\t    delimiter = 0;\n\t  continue;\n\t}\n      \n      if (delimiter && string[i] == delimiter)\n\t{\n\t  delimiter = 0;\n\t  continue;\n\t}\n\n       \n      if (nestdelim == 0 && delimiter == 0 && member (string[i], \"<>$!@?+*\") && string[i+1] == '(')  \n\t{\n\t  i += 2;\n\t  delimopen = '(';\n\t  delimiter = ')';\n\t  nestdelim = 1;\n\t  continue;\n\t}\n      \n      if (delimiter == 0 && (member (string[i], history_word_delimiters)))\n\tbreak;\n\n      if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))\n\tdelimiter = string[i];\n    }\n\n  return i;\n}\n\nstatic char *\nhistory_substring (const char *string, int start, int end)\n{\n  register int len;\n  register char *result;\n\n  len = end - start;\n  result = (char *)xmalloc (len + 1);\n  strncpy (result, string + start, len);\n  result[len] = '\\0';\n  return result;\n}\n\n \nstatic char **\nhistory_tokenize_internal (const char *string, int wind, int *indp)\n{\n  char **result;\n  register int i, start, result_index, size;\n\n   \n  if (indp && wind != -1)\n    *indp = -1;\n\n   \n  for (i = result_index = size = 0, result = (char **)NULL; string[i]; )\n    {\n       \n      for (; string[i] && fielddelim (string[i]); i++)\n\t;\n      if (string[i] == 0 || string[i] == history_comment_char)\n\treturn (result);\n\n      start = i;\n\n      i = history_tokenize_word (string, start);\n\n       \n      if (i == start && history_word_delimiters)\n\t{\n\t  i++;\n\t  while (string[i] && member (string[i], history_word_delimiters))\n\t    i++;\n\t}\n\n       \n      if (indp && wind != -1 && wind >= start && wind < i)\n        *indp = result_index;\n\n      if (result_index + 2 >= size)\n\tresult = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));\n\n      result[result_index++] = history_substring (string, start, i);\n      result[result_index] = (char *)NULL;\n    }\n\n  return (result);\n}\n\n \nchar **\nhistory_tokenize (const char *string)\n{\n  return (history_tokenize_internal (string, -1, (int *)NULL));\n}\n\n \nstatic void\nfreewords (char **words, int start)\n{\n  register int i;\n\n  for (i = start; words[i]; i++)\n    xfree (words[i]);\n}\n\n \nstatic char *\nhistory_find_word (char *line, int ind)\n{\n  char **words, *s;\n  int i, wind;\n\n  words = history_tokenize_internal (line, ind, &wind);\n  if (wind == -1 || words == 0)\n    {\n      if (words)\n\tfreewords (words, 0);\n      FREE (words);\n      return ((char *)NULL);\n    }\n  s = words[wind];\n  for (i = 0; i < wind; i++)\n    xfree (words[i]);\n  freewords (words, wind + 1);\n  xfree (words);\n  return s;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}