{
  "module_name": "chardev_mem.py",
  "hash_id": "ac693be67bf7cc4ea59fc1e05bdaf1e3af019480d7cccaab39746b61d848125a",
  "original_prompt": "Ingested from sys_09_Anvil/chardev_mem.py",
  "human_readable_source": "import sys\n\n# MicroJSON helper (RFC-0002)\ndef log_event(event_id, data):\n    try:\n        import json\n        print(json.dumps({\"@ID\": event_id, \"data\": data}))\n    except ImportError:\n        # Fallback manual construction\n        print('{\"@ID\": ' + str(event_id) + ', \"data\": \"' + str(data) + '\"}')\n\nclass CharDevMem:\n    \"\"\"\n    Recoded implementation of Linux drivers/char/mem.c (null/zero/full subset).\n    \"\"\"\n    MODE_NULL = 0\n    MODE_ZERO = 1\n    MODE_FULL = 2\n\n    def __init__(self, mode=MODE_NULL):\n        self.mode = mode\n\n    def read(self, count):\n        if count < 0:\n            return b''\n        \n        if self.mode == self.MODE_NULL:\n            return b'' # EOF immediately\n        elif self.mode == self.MODE_ZERO:\n            return b'\\x00' * count\n        elif self.mode == self.MODE_FULL:\n            return b'\\x00' * count\n        return b''\n\n    def write(self, data):\n        if self.mode == self.MODE_NULL:\n            return len(data) # Accept and discard\n        elif self.mode == self.MODE_ZERO:\n            return len(data) # Accept and discard\n        elif self.mode == self.MODE_FULL:\n            # ENOSPC = 28\n            raise OSError(28) \n        return 0\n\ndef test():\n    # Test /dev/null behavior\n    dev_null = CharDevMem(CharDevMem.MODE_NULL)\n    if dev_null.read(10) != b'':\n        log_event(9001, \"FAIL: null read not empty\")\n        sys.exit(1)\n    if dev_null.write(b'hello') != 5:\n        log_event(9001, \"FAIL: null write length mismatch\")\n        sys.exit(1)\n        \n    # Test /dev/zero behavior\n    dev_zero = CharDevMem(CharDevMem.MODE_ZERO)\n    zeros = dev_zero.read(5)\n    if len(zeros) != 5 or zeros != b'\\x00\\x00\\x00\\x00\\x00':\n        log_event(9001, \"FAIL: zero read mismatch\")\n        sys.exit(1)\n    if dev_zero.write(b'data') != 4:\n        log_event(9001, \"FAIL: zero write length mismatch\")\n        sys.exit(1)\n\n    # Test /dev/full behavior\n    dev_full = CharDevMem(CharDevMem.MODE_FULL)\n    try:\n        dev_full.write(b'test')\n        log_event(9001, \"FAIL: full did not raise ENOSPC\")\n        sys.exit(1)\n    except OSError as e:\n        # In some micropython ports, errno is args[0]\n        errno = e.errno if hasattr(e, 'errno') else (e.args[0] if e.args else 0)\n        if errno != 28:\n            log_event(9001, \"FAIL: full raised wrong error \" + str(errno))\n            sys.exit(1)\n    except Exception as e:\n        log_event(9001, \"FAIL: full raised wrong exception type \" + str(type(e)))\n        sys.exit(1)\n\n    log_event(1001, \"SUCCESS: CharDevMem verification passed\")\n\nif __name__ == '__main__':\n    test()",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}