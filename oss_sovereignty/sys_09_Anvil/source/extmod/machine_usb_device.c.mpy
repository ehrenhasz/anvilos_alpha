{
  "module_name": "machine_usb_device.c",
  "hash_id": "826d724673aa4e59dada9d741219a1cc3384d7c74e3047d2b2d383e489ebd261",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_usb_device.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n\n#if MICROPY_HW_ENABLE_USB_RUNTIME_DEVICE\n\n#include \"mp_usbd.h\"\n#include \"py/mperrno.h\"\n#include \"py/objstr.h\"\n\n\n\n\n\n#ifndef NO_QSTR\n#include \"device/usbd_pvt.h\"\n#endif\n\n#define HAS_BUILTIN_DRIVERS (MICROPY_HW_USB_CDC || MICROPY_HW_USB_MSC)\n\nconst mp_obj_type_t machine_usb_device_type;\n\nstatic mp_obj_t usb_device_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type;\n    (void)n_args;\n    (void)n_kw;\n    (void)args;\n\n    if (MP_STATE_VM(usbd) == MP_OBJ_NULL) {\n        mp_obj_usb_device_t *o = m_new0(mp_obj_usb_device_t, 1);\n        o->base.type = &machine_usb_device_type;\n        o->desc_dev = mp_const_none;\n        o->desc_cfg = mp_const_none;\n        o->desc_strs = mp_const_none;\n        o->open_itf_cb = mp_const_none;\n        o->reset_cb = mp_const_none;\n        o->control_xfer_cb = mp_const_none;\n        o->xfer_cb = mp_const_none;\n        for (int i = 0; i < CFG_TUD_ENDPPOINT_MAX; i++) {\n            o->xfer_data[i][0] = mp_const_none;\n            o->xfer_data[i][1] = mp_const_none;\n        }\n        o->builtin_driver = MP_OBJ_FROM_PTR(&mp_type_usb_device_builtin_none);\n        o->active = false; \n        o->trigger = false;\n        o->control_data = MP_OBJ_TO_PTR(mp_obj_new_memoryview('B', 0, NULL));\n        o->num_pend_excs = 0;\n        for (int i = 0; i < MP_USBD_MAX_PEND_EXCS; i++) {\n            o->pend_excs[i] = mp_const_none;\n        }\n\n        MP_STATE_VM(usbd) = MP_OBJ_FROM_PTR(o);\n    }\n\n    return MP_STATE_VM(usbd);\n}\n\n\n\nstatic void usb_device_check_active(mp_obj_usb_device_t *usbd) {\n    if (!usbd->active || usbd->trigger) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n}\n\nstatic mp_obj_t usb_device_submit_xfer(mp_obj_t self, mp_obj_t ep, mp_obj_t buffer) {\n    mp_obj_usb_device_t *usbd = (mp_obj_usb_device_t *)MP_OBJ_TO_PTR(self);\n    int ep_addr;\n    mp_buffer_info_t buf_info = { 0 };\n    bool result;\n\n    usb_device_check_active(usbd);\n\n    \n    ep_addr = mp_obj_get_int(ep);\n    mp_get_buffer_raise(buffer, &buf_info, ep_addr & TUSB_DIR_IN_MASK ? MP_BUFFER_READ : MP_BUFFER_RW);\n\n    uint8_t ep_num = tu_edpt_number(ep_addr);\n    uint8_t ep_dir = tu_edpt_dir(ep_addr);\n\n    if (ep_num == 0 || ep_num >= CFG_TUD_ENDPPOINT_MAX) {\n        \n        \n        \n        \n        \n        mp_raise_ValueError(\"ep\");\n    }\n\n    if (!usbd_edpt_claim(USBD_RHPORT, ep_addr)) {\n        mp_raise_OSError(MP_EBUSY);\n    }\n\n    result = usbd_edpt_xfer(USBD_RHPORT, ep_addr, buf_info.buf, buf_info.len);\n\n    if (result) {\n        \n        usbd->xfer_data[ep_num][ep_dir] = buffer;\n    }\n\n    return mp_obj_new_bool(result);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(usb_device_submit_xfer_obj, usb_device_submit_xfer);\n\nstatic mp_obj_t usb_device_active(size_t n_args, const mp_obj_t *args) {\n    mp_obj_usb_device_t *usbd = (mp_obj_usb_device_t *)MP_OBJ_TO_PTR(args[0]);\n\n    bool result = usbd->active;\n    if (n_args == 2) {\n        bool value = mp_obj_is_true(args[1]);\n\n        if (value != result) {\n            if (value\n                && !mp_usb_device_builtin_enabled(usbd)\n                && usbd->desc_dev == mp_const_none) {\n                \n                \n                mp_raise_OSError(MP_EINVAL);\n            }\n\n            \n            \n            usbd->active = value;\n            usbd->trigger = true;\n            if (value) {\n                mp_usbd_init(); \n            }\n            mp_usbd_schedule_task();\n        }\n    }\n\n    return mp_obj_new_bool(result);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(usb_device_active_obj, 1, 2, usb_device_active);\n\nstatic mp_obj_t usb_device_stall(size_t n_args, const mp_obj_t *args) {\n    mp_obj_usb_device_t *self = (mp_obj_usb_device_t *)MP_OBJ_TO_PTR(args[0]);\n    int epnum = mp_obj_get_int(args[1]);\n\n    usb_device_check_active(self);\n\n    mp_obj_t res = mp_obj_new_bool(usbd_edpt_stalled(USBD_RHPORT, epnum));\n\n    if (n_args == 3) { \n        mp_obj_t stall = args[2];\n        if (mp_obj_is_true(stall)) {\n            usbd_edpt_stall(USBD_RHPORT, epnum);\n        } else {\n            usbd_edpt_clear_stall(USBD_RHPORT, epnum);\n        }\n    }\n\n    return res;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(usb_device_stall_obj, 2, 3, usb_device_stall);\n\n\n\nstatic mp_obj_t usb_device_config(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    mp_obj_usb_device_t *self = (mp_obj_usb_device_t *)MP_OBJ_TO_PTR(pos_args[0]);\n\n    enum { ARG_desc_dev, ARG_desc_cfg, ARG_desc_strs, ARG_open_itf_cb,\n           ARG_reset_cb, ARG_control_xfer_cb, ARG_xfer_cb, ARG_active };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_desc_dev, MP_ARG_OBJ | MP_ARG_REQUIRED },\n        { MP_QSTR_desc_cfg, MP_ARG_OBJ | MP_ARG_REQUIRED },\n        { MP_QSTR_desc_strs, MP_ARG_OBJ | MP_ARG_REQUIRED },\n        { MP_QSTR_open_itf_cb, MP_ARG_OBJ, {.u_obj = mp_const_none} },\n        { MP_QSTR_reset_cb, MP_ARG_OBJ, {.u_obj = mp_const_none} },\n        { MP_QSTR_control_xfer_cb, MP_ARG_OBJ, {.u_obj = mp_const_none} },\n        { MP_QSTR_xfer_cb, MP_ARG_OBJ, {.u_obj = mp_const_none} },\n    };\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    mp_obj_t desc_dev = args[ARG_desc_dev].u_obj;\n    mp_obj_t desc_cfg = args[ARG_desc_cfg].u_obj;\n    mp_obj_t desc_strs = args[ARG_desc_strs].u_obj;\n    if (!MP_OBJ_TYPE_HAS_SLOT(mp_obj_get_type(desc_dev), buffer)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"desc_dev\"));\n    }\n    if (!MP_OBJ_TYPE_HAS_SLOT(mp_obj_get_type(desc_cfg), buffer)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"desc_cfg\"));\n    }\n    if (desc_strs != mp_const_none\n        && !MP_OBJ_TYPE_HAS_SLOT(mp_obj_get_type(desc_strs), subscr)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"desc_strs\"));\n    }\n\n    self->desc_dev = desc_dev;\n    self->desc_cfg = desc_cfg;\n    self->desc_strs = desc_strs;\n    self->open_itf_cb = args[ARG_open_itf_cb].u_obj;\n    self->reset_cb = args[ARG_reset_cb].u_obj;\n    self->control_xfer_cb = args[ARG_control_xfer_cb].u_obj;\n    self->xfer_cb = args[ARG_xfer_cb].u_obj;\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(usb_device_config_obj, 1, usb_device_config);\n\nstatic const MP_DEFINE_BYTES_OBJ(builtin_default_desc_dev_obj,\n    &mp_usbd_builtin_desc_dev, sizeof(tusb_desc_device_t));\n\n#if HAS_BUILTIN_DRIVERS\n\n\nstatic const MP_DEFINE_BYTES_OBJ(builtin_default_desc_cfg_obj,\n    mp_usbd_builtin_desc_cfg, MP_USBD_BUILTIN_DESC_CFG_LEN);\n\nstatic const mp_rom_map_elem_t usb_device_builtin_default_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_itf_max), MP_OBJ_NEW_SMALL_INT(USBD_ITF_BUILTIN_MAX) },\n    { MP_ROM_QSTR(MP_QSTR_ep_max), MP_OBJ_NEW_SMALL_INT(USBD_EP_BUILTIN_MAX) },\n    { MP_ROM_QSTR(MP_QSTR_str_max), MP_OBJ_NEW_SMALL_INT(USBD_STR_BUILTIN_MAX) },\n    { MP_ROM_QSTR(MP_QSTR_desc_dev), MP_ROM_PTR(&builtin_default_desc_dev_obj)  },\n    { MP_ROM_QSTR(MP_QSTR_desc_cfg), MP_ROM_PTR(&builtin_default_desc_cfg_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(usb_device_builtin_default_dict, usb_device_builtin_default_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_usb_device_builtin_default,\n    MP_QSTR_BUILTIN_DEFAULT,\n    MP_TYPE_FLAG_NONE,\n    locals_dict, &usb_device_builtin_default_dict\n    );\n#endif \n\n\nstatic const mp_rom_map_elem_t usb_device_builtin_none_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_itf_max), MP_OBJ_NEW_SMALL_INT(0) },\n    { MP_ROM_QSTR(MP_QSTR_ep_max), MP_OBJ_NEW_SMALL_INT(0) },\n    { MP_ROM_QSTR(MP_QSTR_str_max), MP_OBJ_NEW_SMALL_INT(1) },\n    { MP_ROM_QSTR(MP_QSTR_desc_dev), MP_ROM_PTR(&builtin_default_desc_dev_obj)  },\n    { MP_ROM_QSTR(MP_QSTR_desc_cfg), mp_const_empty_bytes },\n};\nstatic MP_DEFINE_CONST_DICT(usb_device_builtin_none_dict, usb_device_builtin_none_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_usb_device_builtin_none,\n    MP_QSTR_BUILTIN_NONE,\n    MP_TYPE_FLAG_NONE,\n    locals_dict, &usb_device_builtin_none_dict\n    );\n\nstatic const mp_rom_map_elem_t usb_device_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_config), MP_ROM_PTR(&usb_device_config_obj) },\n    { MP_ROM_QSTR(MP_QSTR_submit_xfer), MP_ROM_PTR(&usb_device_submit_xfer_obj) },\n    { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&usb_device_active_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stall), MP_ROM_PTR(&usb_device_stall_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_BUILTIN_NONE), MP_ROM_PTR(&mp_type_usb_device_builtin_none) },\n\n    #if !HAS_BUILTIN_DRIVERS\n    \n    { MP_ROM_QSTR(MP_QSTR_BUILTIN_DEFAULT), MP_ROM_PTR(&mp_type_usb_device_builtin_none) },\n    #else\n    { MP_ROM_QSTR(MP_QSTR_BUILTIN_DEFAULT), MP_ROM_PTR(&mp_type_usb_device_builtin_default) },\n\n    \n    \n    #if MICROPY_HW_USB_CDC && !MICROPY_HW_USB_MSC\n    { MP_ROM_QSTR(MP_QSTR_BUILTIN_CDC), MP_ROM_PTR(&mp_type_usb_device_builtin_default) },\n    #endif\n    #if MICROPY_HW_USB_MSC && !MICROPY_HW_USB_CDC\n    { MP_ROM_QSTR(MP_QSTR_BUILTIN_MSC), MP_ROM_PTR(&mp_type_usb_device_builtin_default) },\n    #endif\n    #if MICROPY_HW_USB_CDC && MICROPY_HW_USB_MSC\n    { MP_ROM_QSTR(MP_QSTR_BUILTIN_CDC_MSC), MP_ROM_PTR(&mp_type_usb_device_builtin_default) },\n    #endif\n    #endif \n};\nstatic MP_DEFINE_CONST_DICT(usb_device_locals_dict, usb_device_locals_dict_table);\n\nstatic void usb_device_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    mp_obj_usb_device_t *self = MP_OBJ_TO_PTR(self_in);\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR_builtin_driver) {\n            dest[0] = self->builtin_driver;\n        } else {\n            \n            dest[1] = MP_OBJ_SENTINEL;\n        }\n    } else if (dest[1] != MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR_builtin_driver) {\n            if (self->active) {\n                mp_raise_OSError(MP_EINVAL); \n            }\n            \n            \n            self->builtin_driver = dest[1];\n            dest[0] = MP_OBJ_NULL;\n        }\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    machine_usb_device_type,\n    MP_QSTR_USBDevice,\n    MP_TYPE_FLAG_NONE,\n    make_new, usb_device_make_new,\n    locals_dict, &usb_device_locals_dict,\n    attr, &usb_device_attr\n    );\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t usbd);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}