{
  "module_name": "vfs_fat_file.c",
  "hash_id": "2c775ae211ddf7be41e0be796308a88b070fd3c0b96753790a1b7e7c4904706f",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_fat_file.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n#if MICROPY_VFS && MICROPY_VFS_FAT\n\n#include <stdio.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"lib/oofatfs/ff.h\"\n#include \"extmod/vfs_fat.h\"\n\n\nconst byte fresult_to_errno_table[20] = {\n    [FR_OK] = 0,\n    [FR_DISK_ERR] = MP_EIO,\n    [FR_INT_ERR] = MP_EIO,\n    [FR_NOT_READY] = MP_EBUSY,\n    [FR_NO_FILE] = MP_ENOENT,\n    [FR_NO_PATH] = MP_ENOENT,\n    [FR_INVALID_NAME] = MP_EINVAL,\n    [FR_DENIED] = MP_EACCES,\n    [FR_EXIST] = MP_EEXIST,\n    [FR_INVALID_OBJECT] = MP_EINVAL,\n    [FR_WRITE_PROTECTED] = MP_EROFS,\n    [FR_INVALID_DRIVE] = MP_ENODEV,\n    [FR_NOT_ENABLED] = MP_ENODEV,\n    [FR_NO_FILESYSTEM] = MP_ENODEV,\n    [FR_MKFS_ABORTED] = MP_EIO,\n    [FR_TIMEOUT] = MP_EIO,\n    [FR_LOCKED] = MP_EIO,\n    [FR_NOT_ENOUGH_CORE] = MP_ENOMEM,\n    [FR_TOO_MANY_OPEN_FILES] = MP_EMFILE,\n    [FR_INVALID_PARAMETER] = MP_EINVAL,\n};\n\ntypedef struct _pyb_file_obj_t {\n    mp_obj_base_t base;\n    FIL fp;\n} pyb_file_obj_t;\n\nstatic void file_obj_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_printf(print, \"<io.%s %p>\", mp_obj_get_type_str(self_in), MP_OBJ_TO_PTR(self_in));\n}\n\nstatic mp_uint_t file_obj_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    pyb_file_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    UINT sz_out;\n    FRESULT res = f_read(&self->fp, buf, size, &sz_out);\n    if (res != FR_OK) {\n        *errcode = fresult_to_errno_table[res];\n        return MP_STREAM_ERROR;\n    }\n    return sz_out;\n}\n\nstatic mp_uint_t file_obj_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    pyb_file_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    UINT sz_out;\n    FRESULT res = f_write(&self->fp, buf, size, &sz_out);\n    if (res != FR_OK) {\n        *errcode = fresult_to_errno_table[res];\n        return MP_STREAM_ERROR;\n    }\n    if (sz_out != size) {\n        \n        *errcode = MP_ENOSPC;\n        return MP_STREAM_ERROR;\n    }\n    return sz_out;\n}\n\nstatic mp_uint_t file_obj_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    pyb_file_obj_t *self = MP_OBJ_TO_PTR(o_in);\n\n    if (request == MP_STREAM_SEEK) {\n        struct mp_stream_seek_t *s = (struct mp_stream_seek_t *)(uintptr_t)arg;\n\n        switch (s->whence) {\n            case 0: \n                f_lseek(&self->fp, s->offset);\n                break;\n\n            case 1: \n                f_lseek(&self->fp, f_tell(&self->fp) + s->offset);\n                break;\n\n            case 2: \n                f_lseek(&self->fp, f_size(&self->fp) + s->offset);\n                break;\n        }\n\n        s->offset = f_tell(&self->fp);\n        return 0;\n\n    } else if (request == MP_STREAM_FLUSH) {\n        FRESULT res = f_sync(&self->fp);\n        if (res != FR_OK) {\n            *errcode = fresult_to_errno_table[res];\n            return MP_STREAM_ERROR;\n        }\n        return 0;\n\n    } else if (request == MP_STREAM_CLOSE) {\n        \n        if (self->fp.obj.fs != NULL) {\n            FRESULT res = f_close(&self->fp);\n            if (res != FR_OK) {\n                *errcode = fresult_to_errno_table[res];\n                return MP_STREAM_ERROR;\n            }\n        }\n        return 0;\n\n    } else {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n}\n\n\n\nstatic const mp_rom_map_elem_t vfs_fat_rawfile_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readlines), MP_ROM_PTR(&mp_stream_unbuffered_readlines_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_flush), MP_ROM_PTR(&mp_stream_flush_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_seek), MP_ROM_PTR(&mp_stream_seek_obj) },\n    { MP_ROM_QSTR(MP_QSTR_tell), MP_ROM_PTR(&mp_stream_tell_obj) },\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&mp_identity_obj) },\n    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&mp_stream___exit___obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(vfs_fat_rawfile_locals_dict, vfs_fat_rawfile_locals_dict_table);\n\nstatic const mp_stream_p_t vfs_fat_fileio_stream_p = {\n    .read = file_obj_read,\n    .write = file_obj_write,\n    .ioctl = file_obj_ioctl,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_vfs_fat_fileio,\n    MP_QSTR_FileIO,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    print, file_obj_print,\n    protocol, &vfs_fat_fileio_stream_p,\n    locals_dict, &vfs_fat_rawfile_locals_dict\n    );\n\nstatic const mp_stream_p_t vfs_fat_textio_stream_p = {\n    .read = file_obj_read,\n    .write = file_obj_write,\n    .ioctl = file_obj_ioctl,\n    .is_text = true,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_vfs_fat_textio,\n    MP_QSTR_TextIOWrapper,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    print, file_obj_print,\n    protocol, &vfs_fat_textio_stream_p,\n    locals_dict, &vfs_fat_rawfile_locals_dict\n    );\n\n\nstatic mp_obj_t fat_vfs_open(mp_obj_t self_in, mp_obj_t path_in, mp_obj_t mode_in) {\n    fs_user_mount_t *self = MP_OBJ_TO_PTR(self_in);\n\n    const mp_obj_type_t *type = &mp_type_vfs_fat_textio;\n    int mode = 0;\n    const char *mode_s = mp_obj_str_get_str(mode_in);\n    \n    while (*mode_s) {\n        switch (*mode_s++) {\n            case 'r':\n                mode |= FA_READ;\n                break;\n            case 'w':\n                mode |= FA_WRITE | FA_CREATE_ALWAYS;\n                break;\n            case 'x':\n                mode |= FA_WRITE | FA_CREATE_NEW;\n                break;\n            case 'a':\n                mode |= FA_WRITE | FA_OPEN_ALWAYS;\n                break;\n            case '+':\n                mode |= FA_READ | FA_WRITE;\n                break;\n            case 'b':\n                type = &mp_type_vfs_fat_fileio;\n                break;\n            case 't':\n                type = &mp_type_vfs_fat_textio;\n                break;\n        }\n    }\n\n    pyb_file_obj_t *o = mp_obj_malloc_with_finaliser(pyb_file_obj_t, type);\n\n    const char *fname = mp_obj_str_get_str(path_in);\n    FRESULT res = f_open(&self->fatfs, &o->fp, fname, mode);\n    if (res != FR_OK) {\n        m_del_obj(pyb_file_obj_t, o);\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    \n    if ((mode & FA_OPEN_ALWAYS) != 0) {\n        f_lseek(&o->fp, f_size(&o->fp));\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\nMP_DEFINE_CONST_FUN_OBJ_3(fat_vfs_open_obj, fat_vfs_open);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}