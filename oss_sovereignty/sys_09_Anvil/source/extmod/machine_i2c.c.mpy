{
  "module_name": "machine_i2c.c",
  "hash_id": "1557b9041bd9ccf8c6c2a0e53d5c5d3c3de4a9f358487db9139c2d79016ad88d",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_i2c.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n#include \"py/runtime.h\"\n#include \"extmod/modmachine.h\"\n\n#define SOFT_I2C_DEFAULT_TIMEOUT_US (50000) \n\n#if MICROPY_PY_MACHINE_SOFTI2C\n\ntypedef mp_machine_soft_i2c_obj_t machine_i2c_obj_t;\n\nstatic void mp_hal_i2c_delay(machine_i2c_obj_t *self) {\n    \n    \n    mp_hal_delay_us_fast(self->us_delay);\n}\n\nstatic void mp_hal_i2c_scl_low(machine_i2c_obj_t *self) {\n    mp_hal_pin_od_low(self->scl);\n}\n\nstatic int mp_hal_i2c_scl_release(machine_i2c_obj_t *self) {\n    uint32_t count = self->us_timeout;\n\n    mp_hal_pin_od_high(self->scl);\n    mp_hal_i2c_delay(self);\n    \n    for (; mp_hal_pin_read(self->scl) == 0 && count; --count) {\n        mp_hal_delay_us_fast(1);\n    }\n    if (count == 0) {\n        return -MP_ETIMEDOUT;\n    }\n    return 0; \n}\n\nstatic void mp_hal_i2c_sda_low(machine_i2c_obj_t *self) {\n    mp_hal_pin_od_low(self->sda);\n}\n\nstatic void mp_hal_i2c_sda_release(machine_i2c_obj_t *self) {\n    mp_hal_pin_od_high(self->sda);\n}\n\nstatic int mp_hal_i2c_sda_read(machine_i2c_obj_t *self) {\n    return mp_hal_pin_read(self->sda);\n}\n\nstatic int mp_hal_i2c_start(machine_i2c_obj_t *self) {\n    mp_hal_i2c_sda_release(self);\n    mp_hal_i2c_delay(self);\n    int ret = mp_hal_i2c_scl_release(self);\n    if (ret != 0) {\n        return ret;\n    }\n    mp_hal_i2c_sda_low(self);\n    mp_hal_i2c_delay(self);\n    return 0; \n}\n\nstatic int mp_hal_i2c_stop(machine_i2c_obj_t *self) {\n    mp_hal_i2c_delay(self);\n    mp_hal_i2c_sda_low(self);\n    mp_hal_i2c_delay(self);\n    int ret = mp_hal_i2c_scl_release(self);\n    mp_hal_i2c_sda_release(self);\n    mp_hal_i2c_delay(self);\n    return ret;\n}\n\nstatic void mp_hal_i2c_init(machine_i2c_obj_t *self, uint32_t freq) {\n    self->us_delay = 500000 / freq;\n    if (self->us_delay == 0) {\n        self->us_delay = 1;\n    }\n    mp_hal_pin_open_drain(self->scl);\n    mp_hal_pin_open_drain(self->sda);\n    mp_hal_i2c_stop(self); \n}\n\n\n\n\n\nstatic int mp_hal_i2c_write_byte(machine_i2c_obj_t *self, uint8_t val) {\n    mp_hal_i2c_delay(self);\n    mp_hal_i2c_scl_low(self);\n\n    for (int i = 7; i >= 0; i--) {\n        if ((val >> i) & 1) {\n            mp_hal_i2c_sda_release(self);\n        } else {\n            mp_hal_i2c_sda_low(self);\n        }\n        mp_hal_i2c_delay(self);\n        int ret = mp_hal_i2c_scl_release(self);\n        if (ret != 0) {\n            mp_hal_i2c_sda_release(self);\n            return ret;\n        }\n        mp_hal_i2c_scl_low(self);\n    }\n\n    mp_hal_i2c_sda_release(self);\n    mp_hal_i2c_delay(self);\n    int ret = mp_hal_i2c_scl_release(self);\n    if (ret != 0) {\n        return ret;\n    }\n\n    int ack = mp_hal_i2c_sda_read(self);\n    mp_hal_i2c_delay(self);\n    mp_hal_i2c_scl_low(self);\n\n    return ack;\n}\n\n\n\n\nstatic int mp_hal_i2c_read_byte(machine_i2c_obj_t *self, uint8_t *val, int nack) {\n    mp_hal_i2c_delay(self);\n    mp_hal_i2c_scl_low(self);\n    mp_hal_i2c_delay(self);\n\n    uint8_t data = 0;\n    for (int i = 7; i >= 0; i--) {\n        int ret = mp_hal_i2c_scl_release(self);\n        if (ret != 0) {\n            return ret;\n        }\n        data = (data << 1) | mp_hal_i2c_sda_read(self);\n        mp_hal_i2c_scl_low(self);\n        mp_hal_i2c_delay(self);\n    }\n    *val = data;\n\n    \n    if (!nack) {\n        mp_hal_i2c_sda_low(self);\n    }\n    mp_hal_i2c_delay(self);\n    int ret = mp_hal_i2c_scl_release(self);\n    if (ret != 0) {\n        mp_hal_i2c_sda_release(self);\n        return ret;\n    }\n    mp_hal_i2c_scl_low(self);\n    mp_hal_i2c_sda_release(self);\n\n    return 0; \n}\n\n\n\n\nint mp_machine_soft_i2c_transfer(mp_obj_base_t *self_in, uint16_t addr, size_t n, mp_machine_i2c_buf_t *bufs, unsigned int flags) {\n    machine_i2c_obj_t *self = (machine_i2c_obj_t *)self_in;\n\n    \n    int ret = mp_hal_i2c_start(self);\n    if (ret != 0) {\n        return ret;\n    }\n\n    \n    ret = mp_hal_i2c_write_byte(self, (addr << 1) | (flags & MP_MACHINE_I2C_FLAG_READ));\n    if (ret < 0) {\n        return ret;\n    } else if (ret != 0) {\n        \n        mp_hal_i2c_stop(self);\n        return -MP_ENODEV;\n    }\n\n    int transfer_ret = 0;\n    for (; n--; ++bufs) {\n        size_t len = bufs->len;\n        uint8_t *buf = bufs->buf;\n        if (flags & MP_MACHINE_I2C_FLAG_READ) {\n            \n            while (len--) {\n                ret = mp_hal_i2c_read_byte(self, buf++, (n | len) == 0);\n                if (ret != 0) {\n                    return ret;\n                }\n            }\n        } else {\n            \n            while (len--) {\n                ret = mp_hal_i2c_write_byte(self, *buf++);\n                if (ret < 0) {\n                    return ret;\n                } else if (ret != 0) {\n                    \n                    n = 0;\n                    break;\n                }\n                ++transfer_ret; \n            }\n        }\n    }\n\n    \n    if (flags & MP_MACHINE_I2C_FLAG_STOP) {\n        ret = mp_hal_i2c_stop(self);\n        if (ret != 0) {\n            return ret;\n        }\n    }\n\n    return transfer_ret;\n}\n\n#endif \n\n \n\n\n#if MICROPY_PY_MACHINE_I2C || MICROPY_PY_MACHINE_SOFTI2C\n\n\nint mp_machine_i2c_transfer_adaptor(mp_obj_base_t *self, uint16_t addr, size_t n, mp_machine_i2c_buf_t *bufs, unsigned int flags) {\n    size_t len;\n    uint8_t *buf;\n    if (n == 1) {\n        \n        len = bufs[0].len;\n        buf = bufs[0].buf;\n    } else {\n        \n        len = 0;\n        for (size_t i = 0; i < n; ++i) {\n            len += bufs[i].len;\n        }\n        buf = m_new(uint8_t, len);\n        if (!(flags & MP_MACHINE_I2C_FLAG_READ)) {\n            len = 0;\n            for (size_t i = 0; i < n; ++i) {\n                memcpy(buf + len, bufs[i].buf, bufs[i].len);\n                len += bufs[i].len;\n            }\n        }\n    }\n\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    int ret = i2c_p->transfer_single(self, addr, len, buf, flags);\n\n    if (n > 1) {\n        if (flags & MP_MACHINE_I2C_FLAG_READ) {\n            \n            len = 0;\n            for (size_t i = 0; i < n; ++i) {\n                memcpy(bufs[i].buf, buf + len, bufs[i].len);\n                len += bufs[i].len;\n            }\n        }\n        m_del(uint8_t, buf, len);\n    }\n\n    return ret;\n}\n\nstatic int mp_machine_i2c_readfrom(mp_obj_base_t *self, uint16_t addr, uint8_t *dest, size_t len, bool stop) {\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    mp_machine_i2c_buf_t buf = {.len = len, .buf = dest};\n    unsigned int flags = MP_MACHINE_I2C_FLAG_READ | (stop ? MP_MACHINE_I2C_FLAG_STOP : 0);\n    return i2c_p->transfer(self, addr, 1, &buf, flags);\n}\n\nstatic int mp_machine_i2c_writeto(mp_obj_base_t *self, uint16_t addr, const uint8_t *src, size_t len, bool stop) {\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    mp_machine_i2c_buf_t buf = {.len = len, .buf = (uint8_t *)src};\n    unsigned int flags = stop ? MP_MACHINE_I2C_FLAG_STOP : 0;\n    return i2c_p->transfer(self, addr, 1, &buf, flags);\n}\n\n \n\n\nstatic mp_obj_t machine_i2c_init(size_t n_args, const mp_obj_t *args, mp_map_t *kw_args) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    if (i2c_p->init == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"I2C operation not supported\"));\n    }\n    i2c_p->init(self, n_args - 1, args + 1, kw_args);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(machine_i2c_init_obj, 1, machine_i2c_init);\n\nstatic mp_obj_t machine_i2c_scan(mp_obj_t self_in) {\n    mp_obj_base_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t list = mp_obj_new_list(0, NULL);\n    \n    for (int addr = 0x08; addr < 0x78; ++addr) {\n        int ret = mp_machine_i2c_writeto(self, addr, NULL, 0, true);\n        if (ret == 0) {\n            mp_obj_list_append(list, MP_OBJ_NEW_SMALL_INT(addr));\n        }\n        \n        \n        \n        mp_event_handle_nowait();\n    }\n    return list;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(machine_i2c_scan_obj, machine_i2c_scan);\n\nstatic mp_obj_t machine_i2c_start(mp_obj_t self_in) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(self_in);\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    if (i2c_p->start == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"I2C operation not supported\"));\n    }\n    int ret = i2c_p->start(self);\n    if (ret != 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(machine_i2c_start_obj, machine_i2c_start);\n\nstatic mp_obj_t machine_i2c_stop(mp_obj_t self_in) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(self_in);\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    if (i2c_p->stop == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"I2C operation not supported\"));\n    }\n    int ret = i2c_p->stop(self);\n    if (ret != 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(machine_i2c_stop_obj, machine_i2c_stop);\n\nstatic mp_obj_t machine_i2c_readinto(size_t n_args, const mp_obj_t *args) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    if (i2c_p->read == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"I2C operation not supported\"));\n    }\n\n    \n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_WRITE);\n\n    \n    bool nack = (n_args == 2) ? true : mp_obj_is_true(args[2]);\n\n    \n    int ret = i2c_p->read(self, bufinfo.buf, bufinfo.len, nack);\n    if (ret != 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(machine_i2c_readinto_obj, 2, 3, machine_i2c_readinto);\n\nstatic mp_obj_t machine_i2c_write(mp_obj_t self_in, mp_obj_t buf_in) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(self_in);\n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    if (i2c_p->write == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"I2C operation not supported\"));\n    }\n\n    \n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf_in, &bufinfo, MP_BUFFER_READ);\n\n    \n    int ret = i2c_p->write(self, bufinfo.buf, bufinfo.len);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    \n    return MP_OBJ_NEW_SMALL_INT(ret);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(machine_i2c_write_obj, machine_i2c_write);\n\nstatic mp_obj_t machine_i2c_readfrom(size_t n_args, const mp_obj_t *args) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_int_t addr = mp_obj_get_int(args[1]);\n    vstr_t vstr;\n    vstr_init_len(&vstr, mp_obj_get_int(args[2]));\n    bool stop = (n_args == 3) ? true : mp_obj_is_true(args[3]);\n    int ret = mp_machine_i2c_readfrom(self, addr, (uint8_t *)vstr.buf, vstr.len, stop);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(machine_i2c_readfrom_obj, 3, 4, machine_i2c_readfrom);\n\nstatic mp_obj_t machine_i2c_readfrom_into(size_t n_args, const mp_obj_t *args) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_int_t addr = mp_obj_get_int(args[1]);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[2], &bufinfo, MP_BUFFER_WRITE);\n    bool stop = (n_args == 3) ? true : mp_obj_is_true(args[3]);\n    int ret = mp_machine_i2c_readfrom(self, addr, bufinfo.buf, bufinfo.len, stop);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(machine_i2c_readfrom_into_obj, 3, 4, machine_i2c_readfrom_into);\n\nstatic mp_obj_t machine_i2c_writeto(size_t n_args, const mp_obj_t *args) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_int_t addr = mp_obj_get_int(args[1]);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[2], &bufinfo, MP_BUFFER_READ);\n    bool stop = (n_args == 3) ? true : mp_obj_is_true(args[3]);\n    int ret = mp_machine_i2c_writeto(self, addr, bufinfo.buf, bufinfo.len, stop);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    \n    return MP_OBJ_NEW_SMALL_INT(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(machine_i2c_writeto_obj, 3, 4, machine_i2c_writeto);\n\nstatic mp_obj_t machine_i2c_writevto(size_t n_args, const mp_obj_t *args) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_int_t addr = mp_obj_get_int(args[1]);\n\n    \n    size_t nitems;\n    const mp_obj_t *items;\n    mp_obj_get_array(args[2], &nitems, (mp_obj_t **)&items);\n\n    \n    bool stop = (n_args == 3) ? true : mp_obj_is_true(args[3]);\n\n    \n    size_t alloc = nitems == 0 ? 1 : nitems;\n    size_t nbufs = 0;\n    mp_machine_i2c_buf_t *bufs = mp_local_alloc(alloc * sizeof(mp_machine_i2c_buf_t));\n    for (; nitems--; ++items) {\n        mp_buffer_info_t bufinfo;\n        mp_get_buffer_raise(*items, &bufinfo, MP_BUFFER_READ);\n        if (bufinfo.len > 0) {\n            bufs[nbufs].len = bufinfo.len;\n            bufs[nbufs++].buf = bufinfo.buf;\n        }\n    }\n\n    \n    if (nbufs == 0) {\n        bufs[0].len = 0;\n        bufs[0].buf = NULL;\n        nbufs = 1;\n    }\n\n    \n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    int ret = i2c_p->transfer(self, addr, nbufs, bufs, stop ? MP_MACHINE_I2C_FLAG_STOP : 0);\n    mp_local_free(bufs);\n\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    \n    return MP_OBJ_NEW_SMALL_INT(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(machine_i2c_writevto_obj, 3, 4, machine_i2c_writevto);\n\nstatic size_t fill_memaddr_buf(uint8_t *memaddr_buf, uint32_t memaddr, uint8_t addrsize) {\n    size_t memaddr_len = 0;\n    if ((addrsize & 7) != 0 || addrsize > 32) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid addrsize\"));\n    }\n    for (int16_t i = addrsize - 8; i >= 0; i -= 8) {\n        memaddr_buf[memaddr_len++] = memaddr >> i;\n    }\n    return memaddr_len;\n}\n\nstatic int read_mem(mp_obj_t self_in, uint16_t addr, uint32_t memaddr, uint8_t addrsize, uint8_t *buf, size_t len) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(self_in);\n\n    \n    uint8_t memaddr_buf[4];\n    size_t memaddr_len = fill_memaddr_buf(&memaddr_buf[0], memaddr, addrsize);\n\n    #if MICROPY_PY_MACHINE_I2C_TRANSFER_WRITE1\n    \n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    if (i2c_p->transfer_supports_write1) {\n        \n        mp_machine_i2c_buf_t bufs[2] = {\n            {.len = memaddr_len, .buf = memaddr_buf},\n            {.len = len, .buf = buf},\n        };\n\n        \n        return i2c_p->transfer(self, addr, 2, bufs,\n            MP_MACHINE_I2C_FLAG_WRITE1 | MP_MACHINE_I2C_FLAG_READ | MP_MACHINE_I2C_FLAG_STOP);\n    }\n    #endif\n\n    int ret = mp_machine_i2c_writeto(self, addr, memaddr_buf, memaddr_len, false);\n    if (ret != memaddr_len) {\n        \n        mp_machine_i2c_writeto(self, addr, NULL, 0, true);\n        return ret;\n    }\n    return mp_machine_i2c_readfrom(self, addr, buf, len, true);\n}\n\nstatic int write_mem(mp_obj_t self_in, uint16_t addr, uint32_t memaddr, uint8_t addrsize, const uint8_t *buf, size_t len) {\n    mp_obj_base_t *self = (mp_obj_base_t *)MP_OBJ_TO_PTR(self_in);\n\n    \n    uint8_t memaddr_buf[4];\n    size_t memaddr_len = fill_memaddr_buf(&memaddr_buf[0], memaddr, addrsize);\n\n    \n    mp_machine_i2c_buf_t bufs[2] = {\n        {.len = memaddr_len, .buf = memaddr_buf},\n        {.len = len, .buf = (uint8_t *)buf},\n    };\n\n    \n    mp_machine_i2c_p_t *i2c_p = (mp_machine_i2c_p_t *)MP_OBJ_TYPE_GET_SLOT(self->type, protocol);\n    return i2c_p->transfer(self, addr, 2, bufs, MP_MACHINE_I2C_FLAG_STOP);\n}\n\nstatic const mp_arg_t machine_i2c_mem_allowed_args[] = {\n    { MP_QSTR_addr,    MP_ARG_REQUIRED | MP_ARG_INT, {.u_int = 0} },\n    { MP_QSTR_memaddr, MP_ARG_REQUIRED | MP_ARG_INT, {.u_int = 0} },\n    { MP_QSTR_arg,     MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n    { MP_QSTR_addrsize, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 8} },\n};\n\nstatic mp_obj_t machine_i2c_readfrom_mem(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_addr, ARG_memaddr, ARG_n, ARG_addrsize };\n    mp_arg_val_t args[MP_ARRAY_SIZE(machine_i2c_mem_allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,\n        MP_ARRAY_SIZE(machine_i2c_mem_allowed_args), machine_i2c_mem_allowed_args, args);\n\n    \n    vstr_t vstr;\n    vstr_init_len(&vstr, mp_obj_get_int(args[ARG_n].u_obj));\n\n    \n    int ret = read_mem(pos_args[0], args[ARG_addr].u_int, args[ARG_memaddr].u_int,\n        args[ARG_addrsize].u_int, (uint8_t *)vstr.buf, vstr.len);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(machine_i2c_readfrom_mem_obj, 1, machine_i2c_readfrom_mem);\n\n\nstatic mp_obj_t machine_i2c_readfrom_mem_into(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_addr, ARG_memaddr, ARG_buf, ARG_addrsize };\n    mp_arg_val_t args[MP_ARRAY_SIZE(machine_i2c_mem_allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,\n        MP_ARRAY_SIZE(machine_i2c_mem_allowed_args), machine_i2c_mem_allowed_args, args);\n\n    \n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[ARG_buf].u_obj, &bufinfo, MP_BUFFER_WRITE);\n\n    \n    int ret = read_mem(pos_args[0], args[ARG_addr].u_int, args[ARG_memaddr].u_int,\n        args[ARG_addrsize].u_int, bufinfo.buf, bufinfo.len);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(machine_i2c_readfrom_mem_into_obj, 1, machine_i2c_readfrom_mem_into);\n\nstatic mp_obj_t machine_i2c_writeto_mem(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_addr, ARG_memaddr, ARG_buf, ARG_addrsize };\n    mp_arg_val_t args[MP_ARRAY_SIZE(machine_i2c_mem_allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,\n        MP_ARRAY_SIZE(machine_i2c_mem_allowed_args), machine_i2c_mem_allowed_args, args);\n\n    \n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[ARG_buf].u_obj, &bufinfo, MP_BUFFER_READ);\n\n    \n    int ret = write_mem(pos_args[0], args[ARG_addr].u_int, args[ARG_memaddr].u_int,\n        args[ARG_addrsize].u_int, bufinfo.buf, bufinfo.len);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(machine_i2c_writeto_mem_obj, 1, machine_i2c_writeto_mem);\n\nstatic const mp_rom_map_elem_t machine_i2c_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&machine_i2c_init_obj) },\n    { MP_ROM_QSTR(MP_QSTR_scan), MP_ROM_PTR(&machine_i2c_scan_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&machine_i2c_start_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stop), MP_ROM_PTR(&machine_i2c_stop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&machine_i2c_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&machine_i2c_write_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_readfrom), MP_ROM_PTR(&machine_i2c_readfrom_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readfrom_into), MP_ROM_PTR(&machine_i2c_readfrom_into_obj) },\n    { MP_ROM_QSTR(MP_QSTR_writeto), MP_ROM_PTR(&machine_i2c_writeto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_writevto), MP_ROM_PTR(&machine_i2c_writevto_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_readfrom_mem), MP_ROM_PTR(&machine_i2c_readfrom_mem_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readfrom_mem_into), MP_ROM_PTR(&machine_i2c_readfrom_mem_into_obj) },\n    { MP_ROM_QSTR(MP_QSTR_writeto_mem), MP_ROM_PTR(&machine_i2c_writeto_mem_obj) },\n};\nMP_DEFINE_CONST_DICT(mp_machine_i2c_locals_dict, machine_i2c_locals_dict_table);\n\n#endif \n\n \n\n\n#if MICROPY_PY_MACHINE_SOFTI2C\n\nstatic void mp_machine_soft_i2c_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mp_machine_soft_i2c_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"SoftI2C(scl=\" MP_HAL_PIN_FMT \", sda=\" MP_HAL_PIN_FMT \", freq=%u)\",\n        mp_hal_pin_name(self->scl), mp_hal_pin_name(self->sda), 500000 / self->us_delay);\n}\n\nstatic void mp_machine_soft_i2c_init(mp_obj_base_t *self_in, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_scl, ARG_sda, ARG_freq, ARG_timeout };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_scl, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_sda, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_freq, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 400000} },\n        { MP_QSTR_timeout, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = SOFT_I2C_DEFAULT_TIMEOUT_US} },\n    };\n\n    mp_machine_soft_i2c_obj_t *self = (mp_machine_soft_i2c_obj_t *)self_in;\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    self->scl = mp_hal_get_pin_obj(args[ARG_scl].u_obj);\n    self->sda = mp_hal_get_pin_obj(args[ARG_sda].u_obj);\n    self->us_timeout = args[ARG_timeout].u_int;\n    mp_hal_i2c_init(self, args[ARG_freq].u_int);\n}\n\nstatic mp_obj_t mp_machine_soft_i2c_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n    machine_i2c_obj_t *self = mp_obj_malloc(machine_i2c_obj_t, &mp_machine_soft_i2c_type);\n    mp_map_t kw_args;\n    mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);\n    mp_machine_soft_i2c_init(&self->base, n_args, args, &kw_args);\n    return MP_OBJ_FROM_PTR(self);\n}\n\nint mp_machine_soft_i2c_read(mp_obj_base_t *self_in, uint8_t *dest, size_t len, bool nack) {\n    machine_i2c_obj_t *self = (machine_i2c_obj_t *)self_in;\n    while (len--) {\n        int ret = mp_hal_i2c_read_byte(self, dest++, nack && (len == 0));\n        if (ret != 0) {\n            return ret;\n        }\n    }\n    return 0; \n}\n\nint mp_machine_soft_i2c_write(mp_obj_base_t *self_in, const uint8_t *src, size_t len) {\n    machine_i2c_obj_t *self = (machine_i2c_obj_t *)self_in;\n    int num_acks = 0;\n    while (len--) {\n        int ret = mp_hal_i2c_write_byte(self, *src++);\n        if (ret < 0) {\n            return ret;\n        } else if (ret != 0) {\n            \n            break;\n        }\n        ++num_acks;\n    }\n    return num_acks;\n}\n\nstatic const mp_machine_i2c_p_t mp_machine_soft_i2c_p = {\n    .init = mp_machine_soft_i2c_init,\n    .start = (int (*)(mp_obj_base_t *))mp_hal_i2c_start,\n    .stop = (int (*)(mp_obj_base_t *))mp_hal_i2c_stop,\n    .read = mp_machine_soft_i2c_read,\n    .write = mp_machine_soft_i2c_write,\n    .transfer = mp_machine_soft_i2c_transfer,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_machine_soft_i2c_type,\n    MP_QSTR_SoftI2C,\n    MP_TYPE_FLAG_NONE,\n    make_new, mp_machine_soft_i2c_make_new,\n    print, mp_machine_soft_i2c_print,\n    protocol, &mp_machine_soft_i2c_p,\n    locals_dict, &mp_machine_i2c_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}