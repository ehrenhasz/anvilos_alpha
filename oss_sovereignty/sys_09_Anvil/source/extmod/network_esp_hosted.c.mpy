{
  "module_name": "network_esp_hosted.c",
  "hash_id": "c72b6aa7879cc823bc1409490803216ff407d7b81e50a68f48091a2d86e06c02",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/network_esp_hosted.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK && MICROPY_PY_NETWORK_ESP_HOSTED\n\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n#include \"py/objtuple.h\"\n#include \"py/objlist.h\"\n#include \"py/stream.h\"\n#include \"py/runtime.h\"\n#include \"py/misc.h\"\n#include \"py/mperrno.h\"\n#include \"shared/netutils/netutils.h\"\n#include \"extmod/modnetwork.h\"\n#include \"modmachine.h\"\n\n#include \"esp_hosted_wifi.h\"\n#include \"esp_hosted_hal.h\"\n\ntypedef struct _esp_hosted_obj_t {\n    mp_obj_base_t base;\n    uint32_t itf;\n} esp_hosted_obj_t;\n\nstatic esp_hosted_obj_t esp_hosted_sta_if = {{(mp_obj_type_t *)&mod_network_esp_hosted_type}, ESP_HOSTED_STA_IF};\nstatic esp_hosted_obj_t esp_hosted_ap_if = {{(mp_obj_type_t *)&mod_network_esp_hosted_type}, ESP_HOSTED_AP_IF};\n\nstatic mp_obj_t network_esp_hosted_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n    mp_obj_t esp_hosted_obj;\n    \n    if (n_args == 0 || mp_obj_get_int(args[0]) == ESP_HOSTED_STA_IF) {\n        esp_hosted_obj = MP_OBJ_FROM_PTR(&esp_hosted_sta_if);\n    } else {\n        esp_hosted_obj = MP_OBJ_FROM_PTR(&esp_hosted_ap_if);\n    }\n    \n    mod_network_register_nic(esp_hosted_obj);\n    return esp_hosted_obj;\n}\n\nstatic mp_obj_t network_esp_hosted_active(size_t n_args, const mp_obj_t *args) {\n    esp_hosted_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (n_args == 2) {\n        bool active = mp_obj_is_true(args[1]);\n        if (active) {\n            \n            \n            \n            \n            if (self->itf == ESP_HOSTED_STA_IF && esp_hosted_wifi_link_status(ESP_HOSTED_AP_IF)) {\n                esp_hosted_wifi_disable(ESP_HOSTED_AP_IF);\n            } else if (self->itf == ESP_HOSTED_AP_IF && esp_hosted_wifi_link_status(ESP_HOSTED_STA_IF)) {\n                esp_hosted_wifi_disable(ESP_HOSTED_STA_IF);\n            }\n            if (esp_hosted_wifi_init(self->itf) != 0) {\n                mp_raise_msg_varg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to initialize ESP32 module\"));\n            }\n        } else {\n            esp_hosted_wifi_disable(self->itf);\n        }\n        return mp_const_none;\n    }\n    return mp_obj_new_bool(esp_hosted_wifi_link_status(self->itf));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_esp_hosted_active_obj, 1, 2, network_esp_hosted_active);\n\nstatic int esp_hosted_scan_callback(esp_hosted_scan_result_t *scan_result, void *arg) {\n    mp_obj_t scan_list = (mp_obj_t)arg;\n    mp_obj_t ap[6] = {\n        mp_obj_new_bytes((uint8_t *)scan_result->ssid, strlen(scan_result->ssid)),\n        mp_obj_new_bytes(scan_result->bssid, sizeof(scan_result->bssid)),\n        mp_obj_new_int(scan_result->channel),\n        mp_obj_new_int(scan_result->rssi),\n        mp_obj_new_int(scan_result->security),\n        MP_OBJ_NEW_SMALL_INT(1),\n    };\n    mp_obj_list_append(scan_list, mp_obj_new_tuple(MP_ARRAY_SIZE(ap), ap));\n    return 0;\n}\n\nstatic mp_obj_t network_esp_hosted_scan(mp_obj_t self_in) {\n    mp_obj_t scan_list;\n    scan_list = mp_obj_new_list(0, NULL);\n    esp_hosted_wifi_scan(esp_hosted_scan_callback, scan_list, 10000);\n    return scan_list;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_esp_hosted_scan_obj, network_esp_hosted_scan);\n\nstatic mp_obj_t network_esp_hosted_connect(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_ssid, ARG_key, ARG_security, ARG_bssid, ARG_channel };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_ssid,     MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_key,      MP_ARG_OBJ, {.u_obj = MP_ROM_NONE} },\n        { MP_QSTR_security, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = ESP_HOSTED_SEC_WPA_WPA2_PSK} },\n        { MP_QSTR_bssid, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_channel,  MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 0} },\n    };\n\n    \n    esp_hosted_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    const char *ssid = NULL;\n    if (args[ARG_ssid].u_obj != mp_const_none) {\n        ssid = mp_obj_str_get_str(args[ARG_ssid].u_obj);\n    } else {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"SSID can't be empty!\"));\n    }\n\n    \n    const char *bssid = NULL;\n    if (args[ARG_bssid].u_obj != mp_const_none) {\n        bssid = mp_obj_str_get_str(args[ARG_bssid].u_obj);\n    }\n\n    \n    const char *key = NULL;\n    mp_uint_t security = ESP_HOSTED_SEC_OPEN;\n    if (args[ARG_key].u_obj != mp_const_none) {\n        key = mp_obj_str_get_str(args[ARG_key].u_obj);\n        security = args[ARG_security].u_int;\n        if (security != ESP_HOSTED_SEC_OPEN && strlen(key) == 0) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Key can't be empty!\"));\n        }\n    }\n\n    \n    mp_uint_t channel = args[ARG_channel].u_int;\n\n    \n    if (esp_hosted_wifi_is_connected(self->itf)) {\n        esp_hosted_wifi_disconnect(self->itf);\n    }\n\n    if (self->itf == ESP_HOSTED_STA_IF) {\n        \n        if (esp_hosted_wifi_connect(ssid, bssid, security, key, channel) != 0) {\n            mp_raise_msg_varg(&mp_type_OSError,\n                MP_ERROR_TEXT(\"could not connect to ssid=%s, sec=%d, key=%s\\n\"), ssid, security, key);\n        }\n    } else {\n        \n        if (esp_hosted_wifi_start_ap(ssid, security, key, channel) != 0) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"failed to start in AP mode\"));\n        }\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_esp_hosted_connect_obj, 1, network_esp_hosted_connect);\n\nstatic mp_obj_t network_esp_hosted_disconnect(mp_obj_t self_in) {\n    esp_hosted_obj_t *self = self_in;\n    esp_hosted_wifi_disconnect(self->itf);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_esp_hosted_disconnect_obj, network_esp_hosted_disconnect);\n\nstatic mp_obj_t network_esp_hosted_isconnected(mp_obj_t self_in) {\n    esp_hosted_obj_t *self = self_in;\n    return mp_obj_new_bool(esp_hosted_wifi_is_connected(self->itf));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_esp_hosted_isconnected_obj, network_esp_hosted_isconnected);\n\nstatic mp_obj_t network_esp_hosted_ifconfig(size_t n_args, const mp_obj_t *args) {\n    esp_hosted_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    void *netif = esp_hosted_wifi_get_netif(self->itf);\n    return mod_network_nic_ifconfig(netif, n_args - 1, args + 1);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_esp_hosted_ifconfig_obj, 1, 2, network_esp_hosted_ifconfig);\n\nstatic mp_obj_t network_esp_hosted_ipconfig(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    esp_hosted_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    void *netif = esp_hosted_wifi_get_netif(self->itf);\n    return mod_network_nic_ipconfig(netif, n_args - 1, args + 1, kwargs);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_esp_hosted_ipconfig_obj, 1, network_esp_hosted_ipconfig);\n\nstatic mp_obj_t network_esp_hosted_config(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    esp_hosted_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (kwargs->used == 0) {\n        \n        if (n_args != 2) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[1])) {\n            case MP_QSTR_mac: {\n                uint8_t buf[6];\n                esp_hosted_wifi_get_mac(self->itf, buf);\n                return mp_obj_new_bytes(buf, 6);\n            }\n            case MP_QSTR_ssid:\n            case MP_QSTR_essid: {\n                esp_hosted_netinfo_t netinfo;\n                esp_hosted_wifi_netinfo(&netinfo);\n                return mp_obj_new_str(netinfo.ssid, strlen(netinfo.ssid));\n            }\n            case MP_QSTR_security: {\n                esp_hosted_netinfo_t netinfo;\n                esp_hosted_wifi_netinfo(&netinfo);\n                return mp_obj_new_int(netinfo.security);\n            }\n            case MP_QSTR_bssid: {\n                esp_hosted_netinfo_t netinfo;\n                esp_hosted_wifi_netinfo(&netinfo);\n                return mp_obj_new_bytes(netinfo.bssid, 6);\n            }\n            case MP_QSTR_channel: {\n                esp_hosted_netinfo_t netinfo;\n                esp_hosted_wifi_netinfo(&netinfo);\n                return mp_obj_new_int(netinfo.channel);\n            }\n            default:\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n        }\n    } else {\n        if (self->itf != MOD_NETWORK_AP_IF) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"AP required\"));\n        }\n        \n        return network_esp_hosted_connect(n_args, args, kwargs);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_esp_hosted_config_obj, 1, network_esp_hosted_config);\n\nstatic mp_obj_t network_esp_hosted_status(size_t n_args, const mp_obj_t *args) {\n    esp_hosted_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (n_args == 1) {\n        \n        return mp_obj_new_bool(esp_hosted_wifi_link_status(self->itf));\n    }\n\n    \n    switch (mp_obj_str_get_qstr(args[1])) {\n        case MP_QSTR_rssi: {\n            esp_hosted_netinfo_t netinfo;\n            esp_hosted_wifi_netinfo(&netinfo);\n            return mp_obj_new_int(netinfo.rssi);\n        }\n        case MP_QSTR_stations: {\n            if (self->itf != MOD_NETWORK_AP_IF) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"AP required\"));\n            }\n\n            size_t sta_count = 0;\n            uint8_t sta_macs[ESP_HOSTED_MAX_AP_CLIENTS * 6];\n\n            mp_obj_t sta_list = mp_obj_new_list(0, NULL);\n            if (esp_hosted_wifi_get_stations(sta_macs, &sta_count) == 0) {\n                for (int i = 0; i < sta_count; i++) {\n                    mp_obj_list_append(sta_list, mp_obj_new_bytes(&sta_macs[i * 6], 6));\n                }\n            }\n            return sta_list;\n        }\n    }\n\n    mp_raise_ValueError(MP_ERROR_TEXT(\"unknown status param\"));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_esp_hosted_status_obj, 1, 2, network_esp_hosted_status);\n\nstatic const mp_rom_map_elem_t network_esp_hosted_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_active),              MP_ROM_PTR(&network_esp_hosted_active_obj) },\n    { MP_ROM_QSTR(MP_QSTR_scan),                MP_ROM_PTR(&network_esp_hosted_scan_obj) },\n    { MP_ROM_QSTR(MP_QSTR_connect),             MP_ROM_PTR(&network_esp_hosted_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_disconnect),          MP_ROM_PTR(&network_esp_hosted_disconnect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isconnected),         MP_ROM_PTR(&network_esp_hosted_isconnected_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ifconfig),            MP_ROM_PTR(&network_esp_hosted_ifconfig_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ipconfig),            MP_ROM_PTR(&network_esp_hosted_ipconfig_obj) },\n    { MP_ROM_QSTR(MP_QSTR_config),              MP_ROM_PTR(&network_esp_hosted_config_obj) },\n    { MP_ROM_QSTR(MP_QSTR_status),              MP_ROM_PTR(&network_esp_hosted_status_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_IF_STA),              MP_ROM_INT(MOD_NETWORK_STA_IF) },\n    { MP_ROM_QSTR(MP_QSTR_IF_AP),               MP_ROM_INT(MOD_NETWORK_AP_IF) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_OPEN),            MP_ROM_INT(ESP_HOSTED_SEC_OPEN) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_WEP),             MP_ROM_INT(ESP_HOSTED_SEC_WEP) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_WPA_WPA2),        MP_ROM_INT(ESP_HOSTED_SEC_WPA_WPA2_PSK) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_OPEN),                MP_ROM_INT(ESP_HOSTED_SEC_OPEN) },\n    { MP_ROM_QSTR(MP_QSTR_WEP),                 MP_ROM_INT(ESP_HOSTED_SEC_WEP) },\n    { MP_ROM_QSTR(MP_QSTR_WPA_PSK),             MP_ROM_INT(ESP_HOSTED_SEC_WPA_WPA2_PSK) },\n};\nstatic MP_DEFINE_CONST_DICT(network_esp_hosted_locals_dict, network_esp_hosted_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mod_network_esp_hosted_type,\n    MP_QSTR_ESPHOSTED,\n    MP_TYPE_FLAG_NONE,\n    make_new, network_esp_hosted_make_new,\n    locals_dict, &network_esp_hosted_locals_dict\n    );\n\nMP_REGISTER_ROOT_POINTER(struct _machine_spi_obj_t *mp_wifi_spi);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}