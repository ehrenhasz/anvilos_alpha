{
  "module_name": "modasyncio.c",
  "hash_id": "3703b9c8686af58839db2e4eabd64cb26408ce1ec79a9ab12880fee5a10551b7",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modasyncio.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/smallint.h\"\n#include \"py/pairheap.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_ASYNCIO\n\n\n#define TASK_PAIRHEAP(task) ((task) ? &(task)->pairheap : NULL)\n\n#define TASK_STATE_RUNNING_NOT_WAITED_ON (mp_const_true)\n#define TASK_STATE_DONE_NOT_WAITED_ON (mp_const_none)\n#define TASK_STATE_DONE_WAS_WAITED_ON (mp_const_false)\n\n#define TASK_IS_DONE(task) ( \\\n    (task)->state == TASK_STATE_DONE_NOT_WAITED_ON \\\n    || (task)->state == TASK_STATE_DONE_WAS_WAITED_ON)\n\ntypedef struct _mp_obj_task_t {\n    mp_pairheap_t pairheap;\n    mp_obj_t coro;\n    mp_obj_t data;\n    mp_obj_t state;\n    mp_obj_t ph_key;\n} mp_obj_task_t;\n\ntypedef struct _mp_obj_task_queue_t {\n    mp_obj_base_t base;\n    mp_obj_task_t *heap;\n} mp_obj_task_queue_t;\n\nstatic const mp_obj_type_t task_queue_type;\nstatic const mp_obj_type_t task_type;\n\nstatic mp_obj_t task_queue_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args);\n\n \n\n\nstatic mp_obj_t ticks(void) {\n    return MP_OBJ_NEW_SMALL_INT(mp_hal_ticks_ms() & (MICROPY_PY_TIME_TICKS_PERIOD - 1));\n}\n\nstatic mp_int_t ticks_diff(mp_obj_t t1_in, mp_obj_t t0_in) {\n    mp_uint_t t0 = MP_OBJ_SMALL_INT_VALUE(t0_in);\n    mp_uint_t t1 = MP_OBJ_SMALL_INT_VALUE(t1_in);\n    mp_int_t diff = ((t1 - t0 + MICROPY_PY_TIME_TICKS_PERIOD / 2) & (MICROPY_PY_TIME_TICKS_PERIOD - 1))\n        - MICROPY_PY_TIME_TICKS_PERIOD / 2;\n    return diff;\n}\n\nstatic int task_lt(mp_pairheap_t *n1, mp_pairheap_t *n2) {\n    mp_obj_task_t *t1 = (mp_obj_task_t *)n1;\n    mp_obj_task_t *t2 = (mp_obj_task_t *)n2;\n    return MP_OBJ_SMALL_INT_VALUE(ticks_diff(t1->ph_key, t2->ph_key)) < 0;\n}\n\n \n\n\nstatic mp_obj_t task_queue_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)args;\n    mp_arg_check_num(n_args, n_kw, 0, 0, false);\n    mp_obj_task_queue_t *self = mp_obj_malloc(mp_obj_task_queue_t, type);\n    self->heap = (mp_obj_task_t *)mp_pairheap_new(task_lt);\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_obj_t task_queue_peek(mp_obj_t self_in) {\n    mp_obj_task_queue_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->heap == NULL) {\n        return mp_const_none;\n    } else {\n        return MP_OBJ_FROM_PTR(self->heap);\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(task_queue_peek_obj, task_queue_peek);\n\nstatic mp_obj_t task_queue_push(size_t n_args, const mp_obj_t *args) {\n    mp_obj_task_queue_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_obj_task_t *task = MP_OBJ_TO_PTR(args[1]);\n    task->data = mp_const_none;\n    if (n_args == 2) {\n        task->ph_key = ticks();\n    } else {\n        assert(mp_obj_is_small_int(args[2]));\n        task->ph_key = args[2];\n    }\n    self->heap = (mp_obj_task_t *)mp_pairheap_push(task_lt, TASK_PAIRHEAP(self->heap), TASK_PAIRHEAP(task));\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(task_queue_push_obj, 2, 3, task_queue_push);\n\nstatic mp_obj_t task_queue_pop(mp_obj_t self_in) {\n    mp_obj_task_queue_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_task_t *head = (mp_obj_task_t *)mp_pairheap_peek(task_lt, &self->heap->pairheap);\n    if (head == NULL) {\n        mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"empty heap\"));\n    }\n    self->heap = (mp_obj_task_t *)mp_pairheap_pop(task_lt, &self->heap->pairheap);\n    return MP_OBJ_FROM_PTR(head);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(task_queue_pop_obj, task_queue_pop);\n\nstatic mp_obj_t task_queue_remove(mp_obj_t self_in, mp_obj_t task_in) {\n    mp_obj_task_queue_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_task_t *task = MP_OBJ_TO_PTR(task_in);\n    self->heap = (mp_obj_task_t *)mp_pairheap_delete(task_lt, &self->heap->pairheap, &task->pairheap);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(task_queue_remove_obj, task_queue_remove);\n\nstatic const mp_rom_map_elem_t task_queue_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_peek), MP_ROM_PTR(&task_queue_peek_obj) },\n    { MP_ROM_QSTR(MP_QSTR_push), MP_ROM_PTR(&task_queue_push_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&task_queue_pop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&task_queue_remove_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(task_queue_locals_dict, task_queue_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    task_queue_type,\n    MP_QSTR_TaskQueue,\n    MP_TYPE_FLAG_NONE,\n    make_new, task_queue_make_new,\n    locals_dict, &task_queue_locals_dict\n    );\n\n \n\n\n\nmp_obj_t mp_asyncio_context = MP_OBJ_NULL;\n\nstatic mp_obj_t task_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 1, 2, false);\n    mp_obj_task_t *self = m_new_obj(mp_obj_task_t);\n    self->pairheap.base.type = type;\n    mp_pairheap_init_node(task_lt, &self->pairheap);\n    self->coro = args[0];\n    self->data = mp_const_none;\n    self->state = TASK_STATE_RUNNING_NOT_WAITED_ON;\n    self->ph_key = MP_OBJ_NEW_SMALL_INT(0);\n    if (n_args == 2) {\n        mp_asyncio_context = args[1];\n    }\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_obj_t task_done(mp_obj_t self_in) {\n    mp_obj_task_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_bool(TASK_IS_DONE(self));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(task_done_obj, task_done);\n\nstatic mp_obj_t task_cancel(mp_obj_t self_in) {\n    mp_obj_task_t *self = MP_OBJ_TO_PTR(self_in);\n    \n    if (TASK_IS_DONE(self)) {\n        return mp_const_false;\n    }\n    \n    mp_obj_t cur_task = mp_obj_dict_get(mp_asyncio_context, MP_OBJ_NEW_QSTR(MP_QSTR_cur_task));\n    if (self_in == cur_task) {\n        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"can't cancel self\"));\n    }\n    \n    while (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(self->data)), MP_OBJ_FROM_PTR(&task_type))) {\n        self = MP_OBJ_TO_PTR(self->data);\n    }\n\n    mp_obj_t _task_queue = mp_obj_dict_get(mp_asyncio_context, MP_OBJ_NEW_QSTR(MP_QSTR__task_queue));\n\n    \n    mp_obj_t dest[3];\n    mp_load_method_maybe(self->data, MP_QSTR_remove, dest);\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        dest[2] = MP_OBJ_FROM_PTR(self);\n        mp_call_method_n_kw(1, 0, dest);\n        \n        dest[0] = _task_queue;\n        dest[1] = MP_OBJ_FROM_PTR(self);\n        task_queue_push(2, dest);\n    } else if (ticks_diff(self->ph_key, ticks()) > 0) {\n        \n        \n        task_queue_remove(_task_queue, MP_OBJ_FROM_PTR(self));\n        \n        dest[0] = _task_queue;\n        dest[1] = MP_OBJ_FROM_PTR(self);\n        task_queue_push(2, dest);\n    }\n\n    self->data = mp_obj_dict_get(mp_asyncio_context, MP_OBJ_NEW_QSTR(MP_QSTR_CancelledError));\n\n    return mp_const_true;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(task_cancel_obj, task_cancel);\n\nstatic void task_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    mp_obj_task_t *self = MP_OBJ_TO_PTR(self_in);\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR_coro) {\n            dest[0] = self->coro;\n        } else if (attr == MP_QSTR_data) {\n            dest[0] = self->data;\n        } else if (attr == MP_QSTR_state) {\n            dest[0] = self->state;\n        } else if (attr == MP_QSTR_done) {\n            dest[0] = MP_OBJ_FROM_PTR(&task_done_obj);\n            dest[1] = self_in;\n        } else if (attr == MP_QSTR_cancel) {\n            dest[0] = MP_OBJ_FROM_PTR(&task_cancel_obj);\n            dest[1] = self_in;\n        } else if (attr == MP_QSTR_ph_key) {\n            dest[0] = self->ph_key;\n        }\n    } else if (dest[1] != MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR_data) {\n            self->data = dest[1];\n            dest[0] = MP_OBJ_NULL;\n        } else if (attr == MP_QSTR_state) {\n            self->state = dest[1];\n            dest[0] = MP_OBJ_NULL;\n        }\n    }\n}\n\nstatic mp_obj_t task_getiter(mp_obj_t self_in, mp_obj_iter_buf_t *iter_buf) {\n    (void)iter_buf;\n    mp_obj_task_t *self = MP_OBJ_TO_PTR(self_in);\n    if (TASK_IS_DONE(self)) {\n        \n        self->state = TASK_STATE_DONE_WAS_WAITED_ON;\n    } else if (self->state == TASK_STATE_RUNNING_NOT_WAITED_ON) {\n        \n        self->state = task_queue_make_new(&task_queue_type, 0, 0, NULL);\n    } else if (mp_obj_get_type(self->state) != &task_queue_type) {\n        \n        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"can't wait\"));\n    }\n    return self_in;\n}\n\nstatic mp_obj_t task_iternext(mp_obj_t self_in) {\n    mp_obj_task_t *self = MP_OBJ_TO_PTR(self_in);\n    if (TASK_IS_DONE(self)) {\n        \n        nlr_raise(self->data);\n    } else {\n        \n        mp_obj_t cur_task = mp_obj_dict_get(mp_asyncio_context, MP_OBJ_NEW_QSTR(MP_QSTR_cur_task));\n        mp_obj_t args[2] = { self->state, cur_task };\n        task_queue_push(2, args);\n        \n        ((mp_obj_task_t *)MP_OBJ_TO_PTR(cur_task))->data = self_in;\n    }\n    return mp_const_none;\n}\n\nstatic const mp_getiter_iternext_custom_t task_getiter_iternext = {\n    .getiter = task_getiter,\n    .iternext = task_iternext,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    task_type,\n    MP_QSTR_Task,\n    MP_TYPE_FLAG_ITER_IS_CUSTOM,\n    make_new, task_make_new,\n    attr, task_attr,\n    iter, &task_getiter_iternext\n    );\n\n \n\n\nstatic const mp_rom_map_elem_t mp_module_asyncio_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR__asyncio) },\n    { MP_ROM_QSTR(MP_QSTR_TaskQueue), MP_ROM_PTR(&task_queue_type) },\n    { MP_ROM_QSTR(MP_QSTR_Task), MP_ROM_PTR(&task_type) },\n};\nstatic MP_DEFINE_CONST_DICT(mp_module_asyncio_globals, mp_module_asyncio_globals_table);\n\nconst mp_obj_module_t mp_module_asyncio = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_asyncio_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR__asyncio, mp_module_asyncio);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}