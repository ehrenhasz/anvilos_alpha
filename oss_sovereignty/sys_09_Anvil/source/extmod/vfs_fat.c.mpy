{
  "module_name": "vfs_fat.c",
  "hash_id": "9591e73fac63444af429e311a1dc85f650de8facbc6dc6186c6dec0966dcf898",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_fat.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n#if MICROPY_VFS_FAT\n\n#if !MICROPY_ENABLE_FINALISER\n#error \"MICROPY_VFS_FAT requires MICROPY_ENABLE_FINALISER\"\n#endif\n\n#if !MICROPY_VFS\n#error \"with MICROPY_VFS_FAT enabled, must also enable MICROPY_VFS\"\n#endif\n\n#include <string.h>\n#include \"py/runtime.h\"\n#include \"py/mperrno.h\"\n#include \"lib/oofatfs/ff.h\"\n#include \"extmod/vfs_fat.h\"\n#include \"shared/timeutils/timeutils.h\"\n\n#if FF_MAX_SS == FF_MIN_SS\n#define SECSIZE(fs) (FF_MIN_SS)\n#else\n#define SECSIZE(fs) ((fs)->ssize)\n#endif\n\n#define mp_obj_fat_vfs_t fs_user_mount_t\n\nstatic mp_import_stat_t fat_vfs_import_stat(void *vfs_in, const char *path) {\n    fs_user_mount_t *vfs = vfs_in;\n    FILINFO fno;\n    assert(vfs != NULL);\n    FRESULT res = f_stat(&vfs->fatfs, path, &fno);\n    if (res == FR_OK) {\n        if ((fno.fattrib & AM_DIR) != 0) {\n            return MP_IMPORT_STAT_DIR;\n        } else {\n            return MP_IMPORT_STAT_FILE;\n        }\n    }\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\nstatic mp_obj_t fat_vfs_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 1, 1, false);\n\n    \n    fs_user_mount_t *vfs = mp_obj_malloc(fs_user_mount_t, type);\n    vfs->fatfs.drv = vfs;\n\n    \n    vfs->blockdev.flags = MP_BLOCKDEV_FLAG_FREE_OBJ;\n    vfs->blockdev.block_size = FF_MIN_SS; \n    mp_vfs_blockdev_init(&vfs->blockdev, args[0]);\n\n    \n    FRESULT res = f_mount(&vfs->fatfs);\n    if (res == FR_NO_FILESYSTEM) {\n        \n        vfs->blockdev.flags |= MP_BLOCKDEV_FLAG_NO_FILESYSTEM;\n    } else if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    return MP_OBJ_FROM_PTR(vfs);\n}\n\n#if _FS_REENTRANT\nstatic mp_obj_t fat_vfs_del(mp_obj_t self_in) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(self_in);\n    \n    f_umount(&self->fatfs);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(fat_vfs_del_obj, fat_vfs_del);\n#endif\n\nstatic mp_obj_t fat_vfs_mkfs(mp_obj_t bdev_in) {\n    \n    fs_user_mount_t *vfs = MP_OBJ_TO_PTR(fat_vfs_make_new(&mp_fat_vfs_type, 1, 0, &bdev_in));\n\n    \n    uint8_t working_buf[FF_MAX_SS];\n    FRESULT res = f_mkfs(&vfs->fatfs, FM_FAT | FM_SFD, 0, working_buf, sizeof(working_buf));\n    if (res == FR_MKFS_ABORTED) { \n        res = f_mkfs(&vfs->fatfs, FM_FAT32, 0, working_buf, sizeof(working_buf));\n    }\n    if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(fat_vfs_mkfs_fun_obj, fat_vfs_mkfs);\nstatic MP_DEFINE_CONST_STATICMETHOD_OBJ(fat_vfs_mkfs_obj, MP_ROM_PTR(&fat_vfs_mkfs_fun_obj));\n\ntypedef struct _mp_vfs_fat_ilistdir_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_fun_1_t finaliser;\n    bool is_str;\n    FF_DIR dir;\n} mp_vfs_fat_ilistdir_it_t;\n\nstatic mp_obj_t mp_vfs_fat_ilistdir_it_iternext(mp_obj_t self_in) {\n    mp_vfs_fat_ilistdir_it_t *self = MP_OBJ_TO_PTR(self_in);\n\n    for (;;) {\n        FILINFO fno;\n        FRESULT res = f_readdir(&self->dir, &fno);\n        char *fn = fno.fname;\n        if (res != FR_OK || fn[0] == 0) {\n            \n            break;\n        }\n\n        \n\n        \n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(4, NULL));\n        if (self->is_str) {\n            t->items[0] = mp_obj_new_str(fn, strlen(fn));\n        } else {\n            t->items[0] = mp_obj_new_bytes((const byte *)fn, strlen(fn));\n        }\n        if (fno.fattrib & AM_DIR) {\n            \n            t->items[1] = MP_OBJ_NEW_SMALL_INT(MP_S_IFDIR);\n        } else {\n            \n            t->items[1] = MP_OBJ_NEW_SMALL_INT(MP_S_IFREG);\n        }\n        t->items[2] = MP_OBJ_NEW_SMALL_INT(0); \n        t->items[3] = mp_obj_new_int_from_uint(fno.fsize);\n\n        return MP_OBJ_FROM_PTR(t);\n    }\n\n    \n    f_closedir(&self->dir);\n\n    return MP_OBJ_STOP_ITERATION;\n}\n\nstatic mp_obj_t mp_vfs_fat_ilistdir_it_del(mp_obj_t self_in) {\n    mp_vfs_fat_ilistdir_it_t *self = MP_OBJ_TO_PTR(self_in);\n    \n    f_closedir(&self->dir);\n    return mp_const_none;\n}\n\nstatic mp_obj_t fat_vfs_ilistdir_func(size_t n_args, const mp_obj_t *args) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(args[0]);\n    bool is_str_type = true;\n    const char *path;\n    if (n_args == 2) {\n        if (mp_obj_get_type(args[1]) == &mp_type_bytes) {\n            is_str_type = false;\n        }\n        path = mp_obj_str_get_str(args[1]);\n    } else {\n        path = \"\";\n    }\n\n    \n    mp_vfs_fat_ilistdir_it_t *iter = mp_obj_malloc_with_finaliser(mp_vfs_fat_ilistdir_it_t, &mp_type_polymorph_iter_with_finaliser);\n    iter->iternext = mp_vfs_fat_ilistdir_it_iternext;\n    iter->finaliser = mp_vfs_fat_ilistdir_it_del;\n    iter->is_str = is_str_type;\n    FRESULT res = f_opendir(&self->fatfs, &iter->dir, path);\n    if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    return MP_OBJ_FROM_PTR(iter);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(fat_vfs_ilistdir_obj, 1, 2, fat_vfs_ilistdir_func);\n\nstatic mp_obj_t fat_vfs_remove_internal(mp_obj_t vfs_in, mp_obj_t path_in, mp_int_t attr) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    const char *path = mp_obj_str_get_str(path_in);\n\n    FILINFO fno;\n    FRESULT res = f_stat(&self->fatfs, path, &fno);\n\n    if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    \n    if ((fno.fattrib & AM_DIR) == attr) {\n        res = f_unlink(&self->fatfs, path);\n\n        if (res != FR_OK) {\n            mp_raise_OSError(fresult_to_errno_table[res]);\n        }\n        return mp_const_none;\n    } else {\n        mp_raise_OSError(attr ? MP_ENOTDIR : MP_EISDIR);\n    }\n}\n\nstatic mp_obj_t fat_vfs_remove(mp_obj_t vfs_in, mp_obj_t path_in) {\n    return fat_vfs_remove_internal(vfs_in, path_in, 0); \n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_remove_obj, fat_vfs_remove);\n\nstatic mp_obj_t fat_vfs_rmdir(mp_obj_t vfs_in, mp_obj_t path_in) {\n    return fat_vfs_remove_internal(vfs_in, path_in, AM_DIR);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_rmdir_obj, fat_vfs_rmdir);\n\nstatic mp_obj_t fat_vfs_rename(mp_obj_t vfs_in, mp_obj_t path_in, mp_obj_t path_out) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    const char *old_path = mp_obj_str_get_str(path_in);\n    const char *new_path = mp_obj_str_get_str(path_out);\n    FRESULT res = f_rename(&self->fatfs, old_path, new_path);\n    if (res == FR_EXIST) {\n        \n        fat_vfs_remove_internal(vfs_in, path_out, 0); \n        \n        res = f_rename(&self->fatfs, old_path, new_path);\n    }\n    if (res == FR_OK) {\n        return mp_const_none;\n    } else {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(fat_vfs_rename_obj, fat_vfs_rename);\n\nstatic mp_obj_t fat_vfs_mkdir(mp_obj_t vfs_in, mp_obj_t path_o) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    const char *path = mp_obj_str_get_str(path_o);\n    FRESULT res = f_mkdir(&self->fatfs, path);\n    if (res == FR_OK) {\n        return mp_const_none;\n    } else {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_mkdir_obj, fat_vfs_mkdir);\n\n\nstatic mp_obj_t fat_vfs_chdir(mp_obj_t vfs_in, mp_obj_t path_in) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    const char *path;\n    path = mp_obj_str_get_str(path_in);\n\n    FRESULT res = f_chdir(&self->fatfs, path);\n\n    if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_chdir_obj, fat_vfs_chdir);\n\n\nstatic mp_obj_t fat_vfs_getcwd(mp_obj_t vfs_in) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    char buf[MICROPY_ALLOC_PATH_MAX + 1];\n    FRESULT res = f_getcwd(&self->fatfs, buf, sizeof(buf));\n    if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n    return mp_obj_new_str(buf, strlen(buf));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(fat_vfs_getcwd_obj, fat_vfs_getcwd);\n\n\nstatic mp_obj_t fat_vfs_stat(mp_obj_t vfs_in, mp_obj_t path_in) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    const char *path = mp_obj_str_get_str(path_in);\n\n    FILINFO fno;\n    if (path[0] == 0 || (path[0] == '/' && path[1] == 0)) {\n        \n        fno.fsize = 0;\n        fno.fdate = 0x2821; \n        fno.ftime = 0;\n        fno.fattrib = AM_DIR;\n    } else {\n        FRESULT res = f_stat(&self->fatfs, path, &fno);\n        if (res != FR_OK) {\n            mp_raise_OSError(fresult_to_errno_table[res]);\n        }\n    }\n\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n    mp_int_t mode = 0;\n    if (fno.fattrib & AM_DIR) {\n        mode |= MP_S_IFDIR;\n    } else {\n        mode |= MP_S_IFREG;\n    }\n    mp_int_t seconds = timeutils_seconds_since_epoch(\n        1980 + ((fno.fdate >> 9) & 0x7f),\n        (fno.fdate >> 5) & 0x0f,\n        fno.fdate & 0x1f,\n        (fno.ftime >> 11) & 0x1f,\n        (fno.ftime >> 5) & 0x3f,\n        2 * (fno.ftime & 0x1f)\n        );\n    t->items[0] = MP_OBJ_NEW_SMALL_INT(mode); \n    t->items[1] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[2] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[3] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[4] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[5] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[6] = mp_obj_new_int_from_uint(fno.fsize); \n    t->items[7] = mp_obj_new_int_from_uint(seconds); \n    t->items[8] = mp_obj_new_int_from_uint(seconds); \n    t->items[9] = mp_obj_new_int_from_uint(seconds); \n\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_stat_obj, fat_vfs_stat);\n\n\nstatic mp_obj_t fat_vfs_statvfs(mp_obj_t vfs_in, mp_obj_t path_in) {\n    mp_obj_fat_vfs_t *self = MP_OBJ_TO_PTR(vfs_in);\n    (void)path_in;\n\n    DWORD nclst;\n    FATFS *fatfs = &self->fatfs;\n    FRESULT res = f_getfree(fatfs, &nclst);\n    if (FR_OK != res) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n\n    t->items[0] = MP_OBJ_NEW_SMALL_INT(fatfs->csize * SECSIZE(fatfs)); \n    t->items[1] = t->items[0]; \n    t->items[2] = MP_OBJ_NEW_SMALL_INT((fatfs->n_fatent - 2)); \n    t->items[3] = MP_OBJ_NEW_SMALL_INT(nclst); \n    t->items[4] = t->items[3]; \n    t->items[5] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[6] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[7] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[8] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[9] = MP_OBJ_NEW_SMALL_INT(FF_MAX_LFN); \n\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(fat_vfs_statvfs_obj, fat_vfs_statvfs);\n\nstatic mp_obj_t vfs_fat_mount(mp_obj_t self_in, mp_obj_t readonly, mp_obj_t mkfs) {\n    fs_user_mount_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    \n    \n    \n    if (mp_obj_is_true(readonly)) {\n        self->blockdev.writeblocks[0] = MP_OBJ_NULL;\n    }\n\n    \n    FRESULT res = (self->blockdev.flags & MP_BLOCKDEV_FLAG_NO_FILESYSTEM) ? FR_NO_FILESYSTEM : FR_OK;\n    if (res == FR_NO_FILESYSTEM && mp_obj_is_true(mkfs)) {\n        uint8_t working_buf[FF_MAX_SS];\n        res = f_mkfs(&self->fatfs, FM_FAT | FM_SFD, 0, working_buf, sizeof(working_buf));\n    }\n    if (res != FR_OK) {\n        mp_raise_OSError(fresult_to_errno_table[res]);\n    }\n    self->blockdev.flags &= ~MP_BLOCKDEV_FLAG_NO_FILESYSTEM;\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(vfs_fat_mount_obj, vfs_fat_mount);\n\nstatic mp_obj_t vfs_fat_umount(mp_obj_t self_in) {\n    (void)self_in;\n    \n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(fat_vfs_umount_obj, vfs_fat_umount);\n\nstatic const mp_rom_map_elem_t fat_vfs_locals_dict_table[] = {\n    #if _FS_REENTRANT\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&fat_vfs_del_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_mkfs), MP_ROM_PTR(&fat_vfs_mkfs_obj) },\n    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&fat_vfs_open_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ilistdir), MP_ROM_PTR(&fat_vfs_ilistdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mkdir), MP_ROM_PTR(&fat_vfs_mkdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rmdir), MP_ROM_PTR(&fat_vfs_rmdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_chdir), MP_ROM_PTR(&fat_vfs_chdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_getcwd), MP_ROM_PTR(&fat_vfs_getcwd_obj) },\n    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&fat_vfs_remove_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rename), MP_ROM_PTR(&fat_vfs_rename_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stat), MP_ROM_PTR(&fat_vfs_stat_obj) },\n    { MP_ROM_QSTR(MP_QSTR_statvfs), MP_ROM_PTR(&fat_vfs_statvfs_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mount), MP_ROM_PTR(&vfs_fat_mount_obj) },\n    { MP_ROM_QSTR(MP_QSTR_umount), MP_ROM_PTR(&fat_vfs_umount_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(fat_vfs_locals_dict, fat_vfs_locals_dict_table);\n\nstatic const mp_vfs_proto_t fat_vfs_proto = {\n    .import_stat = fat_vfs_import_stat,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_fat_vfs_type,\n    MP_QSTR_VfsFat,\n    MP_TYPE_FLAG_NONE,\n    make_new, fat_vfs_make_new,\n    protocol, &fat_vfs_proto,\n    locals_dict, &fat_vfs_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}