{
  "module_name": "vfs_reader.c",
  "hash_id": "63497298700e3637c217cc93e909b995b9c4dccc6514fe4796855526924e7326",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_reader.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/reader.h\"\n#include \"extmod/vfs.h\"\n\n#if MICROPY_READER_VFS\n\n#ifndef MICROPY_READER_VFS_DEFAULT_BUFFER_SIZE\n#define MICROPY_READER_VFS_DEFAULT_BUFFER_SIZE (2 * MICROPY_BYTES_PER_GC_BLOCK - offsetof(mp_reader_vfs_t, buf))\n#endif\n#define MICROPY_READER_VFS_MIN_BUFFER_SIZE (MICROPY_BYTES_PER_GC_BLOCK - offsetof(mp_reader_vfs_t, buf))\n#define MICROPY_READER_VFS_MAX_BUFFER_SIZE (255)\n\ntypedef struct _mp_reader_vfs_t {\n    mp_obj_t file;\n    uint8_t bufpos;\n    uint8_t buflen;\n    uint8_t bufsize;\n    byte buf[];\n} mp_reader_vfs_t;\n\nstatic mp_uint_t mp_reader_vfs_readbyte(void *data) {\n    mp_reader_vfs_t *reader = (mp_reader_vfs_t *)data;\n    if (reader->bufpos >= reader->buflen) {\n        if (reader->buflen < reader->bufsize) {\n            return MP_READER_EOF;\n        } else {\n            int errcode;\n            reader->buflen = mp_stream_rw(reader->file, reader->buf, reader->bufsize, &errcode, MP_STREAM_RW_READ | MP_STREAM_RW_ONCE);\n            if (errcode != 0) {\n                \n                return MP_READER_EOF;\n            }\n            if (reader->buflen == 0) {\n                return MP_READER_EOF;\n            }\n            reader->bufpos = 0;\n        }\n    }\n    return reader->buf[reader->bufpos++];\n}\n\nstatic void mp_reader_vfs_close(void *data) {\n    mp_reader_vfs_t *reader = (mp_reader_vfs_t *)data;\n    mp_stream_close(reader->file);\n    m_del_obj(mp_reader_vfs_t, reader);\n}\n\nvoid mp_reader_new_file(mp_reader_t *reader, qstr filename) {\n    mp_obj_t args[2] = {\n        MP_OBJ_NEW_QSTR(filename),\n        MP_OBJ_NEW_QSTR(MP_QSTR_rb),\n    };\n    mp_obj_t file = mp_vfs_open(MP_ARRAY_SIZE(args), &args[0], (mp_map_t *)&mp_const_empty_map);\n\n    const mp_stream_p_t *stream_p = mp_get_stream(file);\n    int errcode = 0;\n    mp_uint_t bufsize = stream_p->ioctl(file, MP_STREAM_GET_BUFFER_SIZE, 0, &errcode);\n    if (bufsize == MP_STREAM_ERROR || bufsize == 0) {\n        \n        \n        bufsize = MICROPY_READER_VFS_DEFAULT_BUFFER_SIZE;\n    } else {\n        bufsize = MIN(MICROPY_READER_VFS_MAX_BUFFER_SIZE, MAX(MICROPY_READER_VFS_MIN_BUFFER_SIZE, bufsize));\n    }\n\n    mp_reader_vfs_t *rf = m_new_obj_var(mp_reader_vfs_t, buf, byte, bufsize);\n    rf->file = file;\n    rf->bufsize = bufsize;\n    rf->buflen = mp_stream_rw(rf->file, rf->buf, rf->bufsize, &errcode, MP_STREAM_RW_READ | MP_STREAM_RW_ONCE);\n    if (errcode != 0) {\n        mp_raise_OSError(errcode);\n    }\n    rf->bufpos = 0;\n    reader->data = rf;\n    reader->readbyte = mp_reader_vfs_readbyte;\n    reader->close = mp_reader_vfs_close;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}