{
  "module_name": "network_cyw43.c",
  "hash_id": "0702afd65b90bdb5f7e4b3e9ba9c2bf57f98d407c99c01f82fd4e5dbb3197ef2",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/network_cyw43.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include \"py/runtime.h\"\n#include \"py/objstr.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK_CYW43\n\n#include \"lwip/netif.h\"\n#include \"extmod/network_cyw43.h\"\n#include \"modnetwork.h\"\n\n#include \"lib/cyw43-driver/src/cyw43.h\"\n#include \"lib/cyw43-driver/src/cyw43_country.h\"\n\n\n#define CYW43_PM_VALUE(pm_mode, pm2_sleep_ret_ms, li_beacon_period, li_dtim_period, li_assoc) \\\n    ((li_assoc) << 20 \\\n        | (li_dtim_period) << 16 \\\n        | (li_beacon_period) << 12 \\\n        | ((pm2_sleep_ret_ms) / 10) << 4 \\\n        | (pm_mode))\n\n#define PM_NONE         (CYW43_PM_VALUE(CYW43_NO_POWERSAVE_MODE, 10, 0, 0, 0))\n#define PM_PERFORMANCE  (CYW43_PM_VALUE(CYW43_PM2_POWERSAVE_MODE, 200, 1, 1, 10))\n#define PM_POWERSAVE    (CYW43_PM_VALUE(CYW43_PM1_POWERSAVE_MODE, 10, 0, 0, 0))\n\ntypedef struct _network_cyw43_obj_t {\n    mp_obj_base_t base;\n    cyw43_t *cyw;\n    int itf;\n} network_cyw43_obj_t;\n\nstatic const network_cyw43_obj_t network_cyw43_wl_sta = { { &mp_network_cyw43_type }, &cyw43_state, CYW43_ITF_STA };\nstatic const network_cyw43_obj_t network_cyw43_wl_ap = { { &mp_network_cyw43_type }, &cyw43_state, CYW43_ITF_AP };\n\nstatic void network_cyw43_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    struct netif *netif = &self->cyw->netif[self->itf];\n    int status = cyw43_tcpip_link_status(self->cyw, self->itf);\n    const char *status_str;\n    if (status == CYW43_LINK_DOWN) {\n        status_str = \"down\";\n    } else if (status == CYW43_LINK_JOIN || status == CYW43_LINK_NOIP) {\n        status_str = \"join\";\n    } else if (status == CYW43_LINK_UP) {\n        status_str = \"up\";\n    } else if (status == CYW43_LINK_NONET) {\n        status_str = \"nonet\";\n    } else if (status == CYW43_LINK_BADAUTH) {\n        status_str = \"badauth\";\n    } else {\n        status_str = \"fail\";\n    }\n    ip4_addr_t *addr = ip_2_ip4(&netif->ip_addr);\n    mp_printf(print, \"<CYW43 %s %s %u.%u.%u.%u>\",\n        self->itf == CYW43_ITF_STA ? \"STA\" : \"AP\",\n        status_str,\n        addr->addr & 0xff,\n        addr->addr >> 8 & 0xff,\n        addr->addr >> 16 & 0xff,\n        addr->addr >> 24\n        );\n}\n\nstatic mp_obj_t network_cyw43_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n    if (n_args == 0 || mp_obj_get_int(args[0]) == MOD_NETWORK_STA_IF) {\n        return MP_OBJ_FROM_PTR(&network_cyw43_wl_sta);\n    } else {\n        return MP_OBJ_FROM_PTR(&network_cyw43_wl_ap);\n    }\n}\n\nstatic mp_obj_t network_cyw43_send_ethernet(mp_obj_t self_in, mp_obj_t buf_in) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t buf;\n    mp_get_buffer_raise(buf_in, &buf, MP_BUFFER_READ);\n    int ret = cyw43_send_ethernet(self->cyw, self->itf, buf.len, buf.buf, false);\n    if (ret) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(network_cyw43_send_ethernet_obj, network_cyw43_send_ethernet);\n\nstatic mp_obj_t network_cyw43_ioctl(mp_obj_t self_in, mp_obj_t cmd_in, mp_obj_t buf_in) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t buf;\n    mp_get_buffer_raise(buf_in, &buf, MP_BUFFER_READ | MP_BUFFER_WRITE);\n    cyw43_ioctl(self->cyw, mp_obj_get_int(cmd_in), buf.len, buf.buf, self->itf);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(network_cyw43_ioctl_obj, network_cyw43_ioctl);\n\n \n\n\nstatic mp_obj_t network_cyw43_deinit(mp_obj_t self_in) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    cyw43_deinit(self->cyw);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_cyw43_deinit_obj, network_cyw43_deinit);\n\nstatic mp_obj_t network_cyw43_active(size_t n_args, const mp_obj_t *args) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    if (n_args == 1) {\n        return mp_obj_new_bool(cyw43_tcpip_link_status(self->cyw, self->itf));\n    } else {\n        uint32_t country = CYW43_COUNTRY(mod_network_country_code[0], mod_network_country_code[1], 0);\n        cyw43_wifi_set_up(self->cyw, self->itf, mp_obj_is_true(args[1]), country);\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_cyw43_active_obj, 1, 2, network_cyw43_active);\n\nstatic int network_cyw43_scan_cb(void *env, const cyw43_ev_scan_result_t *res) {\n    mp_obj_t list = MP_OBJ_FROM_PTR(env);\n\n    \n    bool found = false;\n    size_t len;\n    mp_obj_t *items;\n    mp_obj_get_array(list, &len, &items);\n    for (size_t i = 0; i < len; ++i) {\n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(items[i]);\n        if (memcmp(res->bssid, ((mp_obj_str_t *)MP_OBJ_TO_PTR(t->items[1]))->data, sizeof(res->bssid)) == 0) {\n            if (res->rssi > MP_OBJ_SMALL_INT_VALUE(t->items[3])) {\n                t->items[3] = MP_OBJ_NEW_SMALL_INT(res->rssi);\n            }\n            t->items[5] = MP_OBJ_NEW_SMALL_INT(MP_OBJ_SMALL_INT_VALUE(t->items[5]) + 1);\n            found = true;\n            break;\n        }\n    }\n\n    \n    if (!found) {\n        mp_obj_t tuple[6] = {\n            mp_obj_new_bytes(res->ssid, res->ssid_len),\n            mp_obj_new_bytes(res->bssid, sizeof(res->bssid)),\n            MP_OBJ_NEW_SMALL_INT(res->channel),\n            MP_OBJ_NEW_SMALL_INT(res->rssi),\n            MP_OBJ_NEW_SMALL_INT(res->auth_mode),\n            \n            MP_OBJ_NEW_SMALL_INT(1), \n        };\n        mp_obj_list_append(list, mp_obj_new_tuple(6, tuple));\n    }\n\n    return 0; \n}\n\nstatic mp_obj_t network_cyw43_scan(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_passive, ARG_ssid, ARG_essid, ARG_bssid };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_passive, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },\n        { MP_QSTR_ssid, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_essid, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_bssid, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n    };\n\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    if (args[ARG_essid].u_obj != mp_const_none) {\n        args[ARG_ssid].u_obj = args[ARG_essid].u_obj;\n    }\n\n    cyw43_wifi_scan_options_t opts;\n    opts.scan_type = args[ARG_passive].u_bool ? 1 : 0;\n    if (args[ARG_ssid].u_obj == mp_const_none) {\n        opts.ssid_len = 0;\n    } else {\n        mp_buffer_info_t ssid;\n        mp_get_buffer_raise(args[ARG_ssid].u_obj, &ssid, MP_BUFFER_READ);\n        opts.ssid_len = MIN(ssid.len, sizeof(opts.ssid));\n        memcpy(opts.ssid, ssid.buf, opts.ssid_len);\n    }\n    if (args[ARG_bssid].u_obj == mp_const_none) {\n        memset(opts.bssid, 0xff, sizeof(opts.bssid));\n    } else {\n        mp_buffer_info_t bssid;\n        mp_get_buffer_raise(args[ARG_bssid].u_obj, &bssid, MP_BUFFER_READ);\n        memcpy(opts.bssid, bssid.buf, sizeof(opts.bssid));\n    }\n\n    mp_obj_t res = mp_obj_new_list(0, NULL);\n    int scan_res = cyw43_wifi_scan(self->cyw, &opts, MP_OBJ_TO_PTR(res), network_cyw43_scan_cb);\n\n    if (scan_res < 0) {\n        mp_raise_OSError(-scan_res);\n    }\n\n    \n    uint32_t start = mp_hal_ticks_ms();\n    const uint32_t TIMEOUT = 10000;\n    while (cyw43_wifi_scan_active(self->cyw)) {\n        uint32_t elapsed = mp_hal_ticks_ms() - start;\n        if (elapsed >= TIMEOUT) {\n            break;\n        }\n        mp_event_wait_ms(TIMEOUT - elapsed);\n    }\n\n    return res;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_cyw43_scan_obj, 1, network_cyw43_scan);\n\nstatic mp_obj_t network_cyw43_connect(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_ssid, ARG_key, ARG_auth, ARG_security, ARG_bssid, ARG_channel };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_ssid, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_key, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_auth, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_security, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_bssid, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_channel, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = CYW43_CHANNEL_NONE} },\n    };\n\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    if (args[ARG_auth].u_int != -1) {\n        args[ARG_security] = args[ARG_auth];\n    }\n\n    \n    mp_buffer_info_t ssid;\n    mp_get_buffer_raise(args[ARG_ssid].u_obj, &ssid, MP_BUFFER_READ);\n\n    \n    mp_buffer_info_t key;\n    key.buf = NULL;\n    if (args[ARG_key].u_obj != mp_const_none) {\n        mp_get_buffer_raise(args[ARG_key].u_obj, &key, MP_BUFFER_READ);\n    }\n\n    \n    mp_buffer_info_t bssid;\n    bssid.buf = NULL;\n    if (args[ARG_bssid].u_obj != mp_const_none) {\n        mp_get_buffer_raise(args[ARG_bssid].u_obj, &bssid, MP_BUFFER_READ);\n        if (bssid.len != 6) {\n            mp_raise_ValueError(NULL);\n        }\n    }\n\n    \n    uint32_t auth_type;\n    if (args[ARG_security].u_int == -1) {\n        if (key.buf == NULL || key.len == 0) {\n            \n            auth_type = CYW43_AUTH_OPEN;\n        } else {\n            \n            \n            auth_type = CYW43_AUTH_WPA2_MIXED_PSK;\n        }\n    } else {\n        auth_type = args[ARG_security].u_int;\n    }\n\n    \n    int ret = cyw43_wifi_join(self->cyw, ssid.len, ssid.buf, key.len, key.buf,\n        auth_type, bssid.buf, args[ARG_channel].u_int);\n    if (ret != 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_cyw43_connect_obj, 1, network_cyw43_connect);\n\nstatic mp_obj_t network_cyw43_disconnect(mp_obj_t self_in) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    cyw43_wifi_leave(self->cyw, self->itf);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_cyw43_disconnect_obj, network_cyw43_disconnect);\n\nstatic mp_obj_t network_cyw43_isconnected(mp_obj_t self_in) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_bool(cyw43_tcpip_link_status(self->cyw, self->itf) == 3);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_cyw43_isconnected_obj, network_cyw43_isconnected);\n\nstatic mp_obj_t network_cyw43_ifconfig(size_t n_args, const mp_obj_t *args) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    return mod_network_nic_ifconfig(&self->cyw->netif[self->itf], n_args - 1, args + 1);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_cyw43_ifconfig_obj, 1, 2, network_cyw43_ifconfig);\n\nstatic mp_obj_t network_cyw43_ipconfig(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    return mod_network_nic_ipconfig(&self->cyw->netif[self->itf], n_args - 1, args + 1, kwargs);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_cyw43_ipconfig_obj, 1, network_cyw43_ipconfig);\n\nstatic mp_obj_t network_cyw43_status(size_t n_args, const mp_obj_t *args) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    (void)self;\n\n    if (n_args == 1) {\n        \n        return MP_OBJ_NEW_SMALL_INT(cyw43_tcpip_link_status(self->cyw, self->itf));\n    }\n\n    \n    switch (mp_obj_str_get_qstr(args[1])) {\n        case MP_QSTR_rssi: {\n            if (self->itf != CYW43_ITF_STA) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"STA required\"));\n            }\n            int32_t rssi;\n            cyw43_wifi_get_rssi(self->cyw, &rssi);\n            return mp_obj_new_int(rssi);\n        }\n        case MP_QSTR_stations: {\n            \n            if (self->itf != CYW43_ITF_AP) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"AP required\"));\n            }\n            int num_stas;\n            uint8_t macs[32 * 6];\n            cyw43_wifi_ap_get_stas(self->cyw, &num_stas, macs);\n            mp_obj_t list = mp_obj_new_list(num_stas, NULL);\n            for (int i = 0; i < num_stas; ++i) {\n                mp_obj_t tuple[1] = {\n                    mp_obj_new_bytes(&macs[i * 6], 6),\n                };\n                ((mp_obj_list_t *)MP_OBJ_TO_PTR(list))->items[i] = mp_obj_new_tuple(1, tuple);\n            }\n            return list;\n        }\n    }\n\n    mp_raise_ValueError(MP_ERROR_TEXT(\"unknown status param\"));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_cyw43_status_obj, 1, 2, network_cyw43_status);\n\nstatic inline uint32_t nw_get_le32(const uint8_t *buf) {\n    return buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24;\n}\n\nstatic inline void nw_put_le32(uint8_t *buf, uint32_t x) {\n    buf[0] = x;\n    buf[1] = x >> 8;\n    buf[2] = x >> 16;\n    buf[3] = x >> 24;\n}\n\nstatic mp_obj_t network_cyw43_config(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    network_cyw43_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (kwargs->used == 0) {\n        \n        if (n_args != 2) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[1])) {\n            case MP_QSTR_antenna: {\n                uint8_t buf[4];\n                cyw43_ioctl(self->cyw, CYW43_IOCTL_GET_ANTDIV, 4, buf, self->itf);\n                return MP_OBJ_NEW_SMALL_INT(nw_get_le32(buf));\n            }\n            case MP_QSTR_channel: {\n                uint8_t buf[4];\n                cyw43_ioctl(self->cyw, CYW43_IOCTL_GET_CHANNEL, 4, buf, self->itf);\n                return MP_OBJ_NEW_SMALL_INT(nw_get_le32(buf));\n            }\n            case MP_QSTR_ssid:\n            case MP_QSTR_essid: {\n                if (self->itf == CYW43_ITF_STA) {\n                    uint8_t buf[36];\n                    cyw43_ioctl(self->cyw, CYW43_IOCTL_GET_SSID, 36, buf, self->itf);\n                    return mp_obj_new_str((const char *)buf + 4, nw_get_le32(buf));\n                } else {\n                    size_t len;\n                    const uint8_t *buf;\n                    cyw43_wifi_ap_get_ssid(self->cyw, &len, &buf);\n                    return mp_obj_new_str((const char *)buf, len);\n                }\n            }\n            case MP_QSTR_security: {\n                return MP_OBJ_NEW_SMALL_INT(cyw43_wifi_ap_get_auth(self->cyw));\n            }\n            case MP_QSTR_mac: {\n                uint8_t buf[6];\n                cyw43_wifi_get_mac(self->cyw, self->itf, buf);\n                return mp_obj_new_bytes(buf, 6);\n            }\n            case MP_QSTR_pm: {\n                uint32_t pm;\n                cyw43_wifi_get_pm(self->cyw, &pm);\n                return MP_OBJ_NEW_SMALL_INT(pm);\n            }\n            case MP_QSTR_txpower: {\n                uint8_t buf[13];\n                memcpy(buf, \"qtxpower\\x00\\x00\\x00\\x00\\x00\", 13);\n                cyw43_ioctl(self->cyw, CYW43_IOCTL_GET_VAR, 13, buf, self->itf);\n                return MP_OBJ_NEW_SMALL_INT(nw_get_le32(buf) / 4);\n            }\n            case MP_QSTR_hostname: {\n                \n                return mod_network_hostname(0, NULL);\n            }\n            default:\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n        }\n    } else {\n        \n        if (n_args != 1) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't specify pos and kw args\"));\n        }\n\n        for (size_t i = 0; i < kwargs->alloc; ++i) {\n            if (MP_MAP_SLOT_IS_FILLED(kwargs, i)) {\n                mp_map_elem_t *e = &kwargs->table[i];\n                switch (mp_obj_str_get_qstr(e->key)) {\n                    case MP_QSTR_antenna: {\n                        uint8_t buf[4];\n                        nw_put_le32(buf, mp_obj_get_int(e->value));\n                        cyw43_ioctl(self->cyw, CYW43_IOCTL_SET_ANTDIV, 4, buf, self->itf);\n                        break;\n                    }\n                    case MP_QSTR_channel: {\n                        cyw43_wifi_ap_set_channel(self->cyw, mp_obj_get_int(e->value));\n                        break;\n                    }\n                    case MP_QSTR_ssid:\n                    case MP_QSTR_essid: {\n                        size_t len;\n                        const char *str = mp_obj_str_get_data(e->value, &len);\n                        cyw43_wifi_ap_set_ssid(self->cyw, len, (const uint8_t *)str);\n                        break;\n                    }\n                    case MP_QSTR_monitor: {\n                        mp_int_t value = mp_obj_get_int(e->value);\n                        uint8_t buf[9 + 4];\n                        memcpy(buf, \"allmulti\\x00\", 9);\n                        nw_put_le32(buf + 9, value);\n                        cyw43_ioctl(self->cyw, CYW43_IOCTL_SET_VAR, 9 + 4, buf, self->itf);\n                        nw_put_le32(buf, value);\n                        cyw43_ioctl(self->cyw, CYW43_IOCTL_SET_MONITOR, 4, buf, self->itf);\n                        if (value) {\n                            self->cyw->trace_flags |= CYW43_TRACE_MAC;\n                        } else {\n                            self->cyw->trace_flags &= ~CYW43_TRACE_MAC;\n                        }\n                        break;\n                    }\n                    case MP_QSTR_security: {\n                        cyw43_wifi_ap_set_auth(self->cyw, mp_obj_get_int(e->value));\n                        break;\n                    }\n                    case MP_QSTR_key:\n                    case MP_QSTR_password: {\n                        size_t len;\n                        const char *str = mp_obj_str_get_data(e->value, &len);\n                        cyw43_wifi_ap_set_password(self->cyw, len, (const uint8_t *)str);\n                        break;\n                    }\n                    case MP_QSTR_pm: {\n                        cyw43_wifi_pm(self->cyw, mp_obj_get_int(e->value));\n                        break;\n                    }\n                    case MP_QSTR_trace: {\n                        self->cyw->trace_flags = mp_obj_get_int(e->value);\n                        break;\n                    }\n                    case MP_QSTR_txpower: {\n                        mp_int_t dbm = mp_obj_get_int(e->value);\n                        uint8_t buf[9 + 4];\n                        memcpy(buf, \"qtxpower\\x00\", 9);\n                        nw_put_le32(buf + 9, dbm * 4);\n                        cyw43_ioctl(self->cyw, CYW43_IOCTL_SET_VAR, 9 + 4, buf, self->itf);\n                        break;\n                    }\n                    case MP_QSTR_hostname: {\n                        \n                        mod_network_hostname(1, &e->value);\n                        break;\n                    }\n                    default:\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n                }\n            }\n        }\n\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_cyw43_config_obj, 1, network_cyw43_config);\n\n \n\n\nstatic const mp_rom_map_elem_t network_cyw43_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_send_ethernet), MP_ROM_PTR(&network_cyw43_send_ethernet_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ioctl), MP_ROM_PTR(&network_cyw43_ioctl_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&network_cyw43_deinit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&network_cyw43_active_obj) },\n    { MP_ROM_QSTR(MP_QSTR_scan), MP_ROM_PTR(&network_cyw43_scan_obj) },\n    { MP_ROM_QSTR(MP_QSTR_connect), MP_ROM_PTR(&network_cyw43_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_disconnect), MP_ROM_PTR(&network_cyw43_disconnect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isconnected), MP_ROM_PTR(&network_cyw43_isconnected_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ifconfig), MP_ROM_PTR(&network_cyw43_ifconfig_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ipconfig), MP_ROM_PTR(&network_cyw43_ipconfig_obj) },\n    { MP_ROM_QSTR(MP_QSTR_status), MP_ROM_PTR(&network_cyw43_status_obj) },\n    { MP_ROM_QSTR(MP_QSTR_config), MP_ROM_PTR(&network_cyw43_config_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_IF_STA), MP_ROM_INT(MOD_NETWORK_STA_IF) },\n    { MP_ROM_QSTR(MP_QSTR_IF_AP), MP_ROM_INT(MOD_NETWORK_AP_IF) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_OPEN), MP_ROM_INT(CYW43_AUTH_OPEN) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_WPA_WPA2), MP_ROM_INT(CYW43_AUTH_WPA2_MIXED_PSK) },\n\n    { MP_ROM_QSTR(MP_QSTR_PM_NONE), MP_ROM_INT(PM_NONE) },\n    { MP_ROM_QSTR(MP_QSTR_PM_PERFORMANCE), MP_ROM_INT(PM_PERFORMANCE) },\n    { MP_ROM_QSTR(MP_QSTR_PM_POWERSAVE), MP_ROM_INT(PM_POWERSAVE) },\n};\nstatic MP_DEFINE_CONST_DICT(network_cyw43_locals_dict, network_cyw43_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_network_cyw43_type,\n    MP_QSTR_CYW43,\n    MP_TYPE_FLAG_NONE,\n    make_new, network_cyw43_make_new,\n    print, network_cyw43_print,\n    locals_dict, &network_cyw43_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}