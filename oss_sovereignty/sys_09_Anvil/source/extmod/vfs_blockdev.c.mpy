{
  "module_name": "vfs_blockdev.c",
  "hash_id": "a98a65bd096c2f37bad31cd2d799c04de3dfa4473b85f389a6e4857d7621b468",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_blockdev.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n#include \"py/objarray.h\"\n#include \"py/mperrno.h\"\n#include \"extmod/vfs.h\"\n\n#if MICROPY_VFS\n\nvoid mp_vfs_blockdev_init(mp_vfs_blockdev_t *self, mp_obj_t bdev) {\n    mp_load_method(bdev, MP_QSTR_readblocks, self->readblocks);\n    mp_load_method_maybe(bdev, MP_QSTR_writeblocks, self->writeblocks);\n    mp_load_method_maybe(bdev, MP_QSTR_ioctl, self->u.ioctl);\n    if (self->u.ioctl[0] != MP_OBJ_NULL) {\n        \n        self->flags |= MP_BLOCKDEV_FLAG_HAVE_IOCTL;\n    } else {\n        \n        mp_load_method_maybe(bdev, MP_QSTR_sync, self->u.old.sync);\n        mp_load_method(bdev, MP_QSTR_count, self->u.old.count);\n    }\n}\n\nint mp_vfs_blockdev_read(mp_vfs_blockdev_t *self, size_t block_num, size_t num_blocks, uint8_t *buf) {\n    if (self->flags & MP_BLOCKDEV_FLAG_NATIVE) {\n        mp_uint_t (*f)(uint8_t *, uint32_t, uint32_t) = (void *)(uintptr_t)self->readblocks[2];\n        return f(buf, block_num, num_blocks);\n    } else {\n        mp_obj_array_t ar = {{&mp_type_bytearray}, BYTEARRAY_TYPECODE, 0, num_blocks *self->block_size, buf};\n        self->readblocks[2] = MP_OBJ_NEW_SMALL_INT(block_num);\n        self->readblocks[3] = MP_OBJ_FROM_PTR(&ar);\n        mp_call_method_n_kw(2, 0, self->readblocks);\n        \n        return 0;\n    }\n}\n\nint mp_vfs_blockdev_read_ext(mp_vfs_blockdev_t *self, size_t block_num, size_t block_off, size_t len, uint8_t *buf) {\n    mp_obj_array_t ar = {{&mp_type_bytearray}, BYTEARRAY_TYPECODE, 0, len, buf};\n    self->readblocks[2] = MP_OBJ_NEW_SMALL_INT(block_num);\n    self->readblocks[3] = MP_OBJ_FROM_PTR(&ar);\n    self->readblocks[4] = MP_OBJ_NEW_SMALL_INT(block_off);\n    mp_obj_t ret = mp_call_method_n_kw(3, 0, self->readblocks);\n    if (ret == mp_const_none) {\n        return 0;\n    } else {\n        return MP_OBJ_SMALL_INT_VALUE(ret);\n    }\n}\n\nint mp_vfs_blockdev_write(mp_vfs_blockdev_t *self, size_t block_num, size_t num_blocks, const uint8_t *buf) {\n    if (self->writeblocks[0] == MP_OBJ_NULL) {\n        \n        return -MP_EROFS;\n    }\n\n    if (self->flags & MP_BLOCKDEV_FLAG_NATIVE) {\n        mp_uint_t (*f)(const uint8_t *, uint32_t, uint32_t) = (void *)(uintptr_t)self->writeblocks[2];\n        return f(buf, block_num, num_blocks);\n    } else {\n        mp_obj_array_t ar = {{&mp_type_bytearray}, BYTEARRAY_TYPECODE, 0, num_blocks *self->block_size, (void *)buf};\n        self->writeblocks[2] = MP_OBJ_NEW_SMALL_INT(block_num);\n        self->writeblocks[3] = MP_OBJ_FROM_PTR(&ar);\n        mp_call_method_n_kw(2, 0, self->writeblocks);\n        \n        return 0;\n    }\n}\n\nint mp_vfs_blockdev_write_ext(mp_vfs_blockdev_t *self, size_t block_num, size_t block_off, size_t len, const uint8_t *buf) {\n    if (self->writeblocks[0] == MP_OBJ_NULL) {\n        \n        return -MP_EROFS;\n    }\n\n    mp_obj_array_t ar = {{&mp_type_bytearray}, BYTEARRAY_TYPECODE, 0, len, (void *)buf};\n    self->writeblocks[2] = MP_OBJ_NEW_SMALL_INT(block_num);\n    self->writeblocks[3] = MP_OBJ_FROM_PTR(&ar);\n    self->writeblocks[4] = MP_OBJ_NEW_SMALL_INT(block_off);\n    mp_obj_t ret = mp_call_method_n_kw(3, 0, self->writeblocks);\n    if (ret == mp_const_none) {\n        return 0;\n    } else {\n        return MP_OBJ_SMALL_INT_VALUE(ret);\n    }\n}\n\nmp_obj_t mp_vfs_blockdev_ioctl(mp_vfs_blockdev_t *self, uintptr_t cmd, uintptr_t arg) {\n    if (self->flags & MP_BLOCKDEV_FLAG_HAVE_IOCTL) {\n        \n        self->u.ioctl[2] = MP_OBJ_NEW_SMALL_INT(cmd);\n        self->u.ioctl[3] = MP_OBJ_NEW_SMALL_INT(arg);\n        return mp_call_method_n_kw(2, 0, self->u.ioctl);\n    } else {\n        \n        switch (cmd) {\n            case MP_BLOCKDEV_IOCTL_SYNC:\n                if (self->u.old.sync[0] != MP_OBJ_NULL) {\n                    mp_call_method_n_kw(0, 0, self->u.old.sync);\n                }\n                break;\n\n            case MP_BLOCKDEV_IOCTL_BLOCK_COUNT:\n                return mp_call_method_n_kw(0, 0, self->u.old.count);\n\n            case MP_BLOCKDEV_IOCTL_BLOCK_SIZE:\n                \n                break;\n\n            case MP_BLOCKDEV_IOCTL_INIT:\n                \n                break;\n        }\n        return mp_const_none;\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}