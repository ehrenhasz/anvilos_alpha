{
  "module_name": "vfs_lfsx_file.c",
  "hash_id": "a611cfa9eb1a9485d4eafdeb50fb7009288be29ba4be7f290da787a7a8db4164",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_lfsx_file.c",
  "human_readable_source": " \n\n\n#if defined(LFS_BUILD_VERSION)\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"extmod/vfs.h\"\n\nstatic void MP_VFS_LFSx(check_open)(MP_OBJ_VFS_LFSx_FILE * self) {\n    if (self->vfs == NULL) {\n        mp_raise_ValueError(NULL);\n    }\n}\n\nstatic void MP_VFS_LFSx(file_print)(const mp_print_t * print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)self_in;\n    (void)kind;\n    mp_printf(print, \"<io.%s>\", mp_obj_get_type_str(self_in));\n}\n\nmp_obj_t MP_VFS_LFSx(file_open)(mp_obj_t self_in, mp_obj_t path_in, mp_obj_t mode_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n\n    int flags = 0;\n    const mp_obj_type_t *type = &MP_TYPE_VFS_LFSx_(_textio);\n    const char *mode_str = mp_obj_str_get_str(mode_in);\n    for (; *mode_str; ++mode_str) {\n        int new_flags = 0;\n        switch (*mode_str) {\n            case 'r':\n                new_flags = LFSx_MACRO(_O_RDONLY);\n                break;\n            case 'w':\n                new_flags = LFSx_MACRO(_O_WRONLY) | LFSx_MACRO(_O_CREAT) | LFSx_MACRO(_O_TRUNC);\n                break;\n            case 'x':\n                new_flags = LFSx_MACRO(_O_WRONLY) | LFSx_MACRO(_O_CREAT) | LFSx_MACRO(_O_EXCL);\n                break;\n            case 'a':\n                new_flags = LFSx_MACRO(_O_WRONLY) | LFSx_MACRO(_O_CREAT) | LFSx_MACRO(_O_APPEND);\n                break;\n            case '+':\n                flags |= LFSx_MACRO(_O_RDWR);\n                break;\n            case 'b':\n                type = &MP_TYPE_VFS_LFSx_(_fileio);\n                break;\n            case 't':\n                type = &MP_TYPE_VFS_LFSx_(_textio);\n                break;\n        }\n        if (new_flags) {\n            if (flags) {\n                mp_raise_ValueError(NULL);\n            }\n            flags = new_flags;\n        }\n    }\n    if (flags == 0) {\n        flags = LFSx_MACRO(_O_RDONLY);\n    }\n\n    #if LFS_BUILD_VERSION == 1\n    MP_OBJ_VFS_LFSx_FILE *o = mp_obj_malloc_var_with_finaliser(MP_OBJ_VFS_LFSx_FILE, uint8_t, self->lfs.cfg->prog_size, type);\n    #else\n    MP_OBJ_VFS_LFSx_FILE *o = mp_obj_malloc_var_with_finaliser(MP_OBJ_VFS_LFSx_FILE, uint8_t, self->lfs.cfg->cache_size, type);\n    #endif\n    o->vfs = self;\n    #if !MICROPY_GC_CONSERVATIVE_CLEAR\n    memset(&o->file, 0, sizeof(o->file));\n    memset(&o->cfg, 0, sizeof(o->cfg));\n    #endif\n    o->cfg.buffer = &o->file_buffer[0];\n\n    #if LFS_BUILD_VERSION == 2\n    if (self->enable_mtime) {\n        lfs_get_mtime(&o->mtime[0]);\n        o->attrs[0].type = LFS_ATTR_MTIME;\n        o->attrs[0].buffer = &o->mtime[0];\n        o->attrs[0].size = sizeof(o->mtime);\n        o->cfg.attrs = &o->attrs[0];\n        o->cfg.attr_count = MP_ARRAY_SIZE(o->attrs);\n    }\n    #endif\n\n    const char *path = MP_VFS_LFSx(make_path)(self, path_in);\n    int ret = LFSx_API(file_opencfg)(&self->lfs, &o->file, path, flags, &o->cfg);\n    if (ret < 0) {\n        o->vfs = NULL;\n        mp_raise_OSError(-ret);\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_uint_t MP_VFS_LFSx(file_read)(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    MP_OBJ_VFS_LFSx_FILE *self = MP_OBJ_TO_PTR(self_in);\n    MP_VFS_LFSx(check_open)(self);\n    LFSx_API(ssize_t) sz = LFSx_API(file_read)(&self->vfs->lfs, &self->file, buf, size);\n    if (sz < 0) {\n        *errcode = -sz;\n        return MP_STREAM_ERROR;\n    }\n    return sz;\n}\n\nstatic mp_uint_t MP_VFS_LFSx(file_write)(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    MP_OBJ_VFS_LFSx_FILE *self = MP_OBJ_TO_PTR(self_in);\n    MP_VFS_LFSx(check_open)(self);\n    #if LFS_BUILD_VERSION == 2\n    if (self->vfs->enable_mtime) {\n        lfs_get_mtime(&self->mtime[0]);\n    }\n    #endif\n    LFSx_API(ssize_t) sz = LFSx_API(file_write)(&self->vfs->lfs, &self->file, buf, size);\n    if (sz < 0) {\n        *errcode = -sz;\n        return MP_STREAM_ERROR;\n    }\n    return sz;\n}\n\nstatic mp_uint_t MP_VFS_LFSx(file_ioctl)(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    MP_OBJ_VFS_LFSx_FILE *self = MP_OBJ_TO_PTR(self_in);\n\n    if (request != MP_STREAM_CLOSE) {\n        MP_VFS_LFSx(check_open)(self);\n    }\n\n    if (request == MP_STREAM_SEEK) {\n        struct mp_stream_seek_t *s = (struct mp_stream_seek_t *)(uintptr_t)arg;\n        int res = LFSx_API(file_seek)(&self->vfs->lfs, &self->file, s->offset, s->whence);\n        if (res < 0) {\n            *errcode = -res;\n            return MP_STREAM_ERROR;\n        }\n        res = LFSx_API(file_tell)(&self->vfs->lfs, &self->file);\n        if (res < 0) {\n            *errcode = -res;\n            return MP_STREAM_ERROR;\n        }\n        s->offset = res;\n        return 0;\n    } else if (request == MP_STREAM_FLUSH) {\n        int res = LFSx_API(file_sync)(&self->vfs->lfs, &self->file);\n        if (res < 0) {\n            *errcode = -res;\n            return MP_STREAM_ERROR;\n        }\n        return 0;\n    } else if (request == MP_STREAM_CLOSE) {\n        if (self->vfs == NULL) {\n            return 0;\n        }\n        int res = LFSx_API(file_close)(&self->vfs->lfs, &self->file);\n        self->vfs = NULL; \n        if (res < 0) {\n            *errcode = -res;\n            return MP_STREAM_ERROR;\n        }\n        return 0;\n    } else {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic const mp_rom_map_elem_t MP_VFS_LFSx(file_locals_dict_table)[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readlines), MP_ROM_PTR(&mp_stream_unbuffered_readlines_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_flush), MP_ROM_PTR(&mp_stream_flush_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_seek), MP_ROM_PTR(&mp_stream_seek_obj) },\n    { MP_ROM_QSTR(MP_QSTR_tell), MP_ROM_PTR(&mp_stream_tell_obj) },\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&mp_identity_obj) },\n    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&mp_stream___exit___obj) },\n};\nstatic MP_DEFINE_CONST_DICT(MP_VFS_LFSx(file_locals_dict), MP_VFS_LFSx(file_locals_dict_table));\n\nstatic const mp_stream_p_t MP_VFS_LFSx(fileio_stream_p) = {\n    .read = MP_VFS_LFSx(file_read),\n    .write = MP_VFS_LFSx(file_write),\n    .ioctl = MP_VFS_LFSx(file_ioctl),\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    MP_TYPE_VFS_LFSx_(_fileio),\n    MP_QSTR_FileIO,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    print, MP_VFS_LFSx(file_print),\n    protocol, &MP_VFS_LFSx(fileio_stream_p),\n    locals_dict, &MP_VFS_LFSx(file_locals_dict)\n    );\n\nstatic const mp_stream_p_t MP_VFS_LFSx(textio_stream_p) = {\n    .read = MP_VFS_LFSx(file_read),\n    .write = MP_VFS_LFSx(file_write),\n    .ioctl = MP_VFS_LFSx(file_ioctl),\n    .is_text = true,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    MP_TYPE_VFS_LFSx_(_textio),\n    MP_QSTR_TextIOWrapper,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    print, MP_VFS_LFSx(file_print),\n    protocol, &MP_VFS_LFSx(textio_stream_p),\n    locals_dict, &MP_VFS_LFSx(file_locals_dict)\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}