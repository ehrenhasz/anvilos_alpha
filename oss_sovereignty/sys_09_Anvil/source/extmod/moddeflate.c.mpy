{
  "module_name": "moddeflate.c",
  "hash_id": "685f141972891cea8eeef9adbde1c378880ce992a2d876baa28dacf7ddbbefce",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/moddeflate.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_PY_DEFLATE\n\n#include \"lib/uzlib/uzlib.h\"\n\n#if 0 \n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\ntypedef enum {\n    DEFLATEIO_FORMAT_MIN = 0,\n    DEFLATEIO_FORMAT_AUTO = DEFLATEIO_FORMAT_MIN, \n    DEFLATEIO_FORMAT_RAW = 1,\n    DEFLATEIO_FORMAT_ZLIB = 2,\n    DEFLATEIO_FORMAT_GZIP = 3,\n    DEFLATEIO_FORMAT_MAX = DEFLATEIO_FORMAT_GZIP,\n} deflateio_format_t;\n\n\n\nconst int DEFLATEIO_DEFAULT_WBITS = 8;\n\ntypedef struct {\n    void *window;\n    uzlib_uncomp_t decomp;\n    bool eof;\n} mp_obj_deflateio_read_t;\n\n#if MICROPY_PY_DEFLATE_COMPRESS\ntypedef struct {\n    void *window;\n    size_t input_len;\n    uint32_t input_checksum;\n    uzlib_lz77_state_t lz77;\n} mp_obj_deflateio_write_t;\n#endif\n\ntypedef struct {\n    mp_obj_base_t base;\n    mp_obj_t stream;\n    uint8_t format : 2;\n    uint8_t window_bits : 4;\n    bool close : 1;\n    mp_obj_deflateio_read_t *read;\n    #if MICROPY_PY_DEFLATE_COMPRESS\n    mp_obj_deflateio_write_t *write;\n    #endif\n} mp_obj_deflateio_t;\n\nstatic int deflateio_read_stream(void *data) {\n    mp_obj_deflateio_t *self = data;\n    const mp_stream_p_t *stream = mp_get_stream(self->stream);\n    int err;\n    byte c;\n    mp_uint_t out_sz = stream->read(self->stream, &c, 1, &err);\n    if (out_sz == MP_STREAM_ERROR) {\n        mp_raise_OSError(err);\n    }\n    if (out_sz == 0) {\n        mp_raise_type(&mp_type_EOFError);\n    }\n    return c;\n}\n\nstatic bool deflateio_init_read(mp_obj_deflateio_t *self) {\n    if (self->read) {\n        return true;\n    }\n\n    mp_get_stream_raise(self->stream, MP_STREAM_OP_READ);\n\n    self->read = m_new_obj(mp_obj_deflateio_read_t);\n    memset(&self->read->decomp, 0, sizeof(self->read->decomp));\n    self->read->decomp.source_read_data = self;\n    self->read->decomp.source_read_cb = deflateio_read_stream;\n    self->read->eof = false;\n\n    \n    int wbits = self->window_bits;\n\n    if (self->format == DEFLATEIO_FORMAT_RAW) {\n        if (wbits == 0) {\n            \n            \n            wbits = DEFLATEIO_DEFAULT_WBITS;\n        }\n    } else {\n        \n        int header_wbits;\n        int header_type = uzlib_parse_zlib_gzip_header(&self->read->decomp, &header_wbits);\n        if (header_type < 0) {\n            \n            return false;\n        }\n        if ((self->format == DEFLATEIO_FORMAT_ZLIB && header_type != UZLIB_HEADER_ZLIB) || (self->format == DEFLATEIO_FORMAT_GZIP && header_type != UZLIB_HEADER_GZIP)) {\n            \n            return false;\n        }\n        \n        if (wbits == 0 || header_wbits < wbits) {\n            \n            \n            wbits = header_wbits;\n        }\n    }\n\n    size_t window_len = 1 << wbits;\n    self->read->window = m_new(uint8_t, window_len);\n\n    uzlib_uncompress_init(&self->read->decomp, self->read->window, window_len);\n\n    return true;\n}\n\n#if MICROPY_PY_DEFLATE_COMPRESS\nstatic void deflateio_out_byte(void *data, uint8_t b) {\n    mp_obj_deflateio_t *self = data;\n    const mp_stream_p_t *stream = mp_get_stream(self->stream);\n    int err;\n    mp_uint_t ret = stream->write(self->stream, &b, 1, &err);\n    if (ret == MP_STREAM_ERROR) {\n        mp_raise_OSError(err);\n    }\n}\n\nstatic bool deflateio_init_write(mp_obj_deflateio_t *self) {\n    if (self->write) {\n        return true;\n    }\n\n    const mp_stream_p_t *stream = mp_get_stream_raise(self->stream, MP_STREAM_OP_WRITE);\n\n    self->write = m_new_obj(mp_obj_deflateio_write_t);\n    self->write->input_len = 0;\n\n    int wbits = self->window_bits;\n    if (wbits == 0) {\n        \n        wbits = DEFLATEIO_DEFAULT_WBITS;\n    }\n    size_t window_len = 1 << wbits;\n    self->write->window = m_new(uint8_t, window_len);\n\n    uzlib_lz77_init(&self->write->lz77, self->write->window, window_len);\n    self->write->lz77.dest_write_data = self;\n    self->write->lz77.dest_write_cb = deflateio_out_byte;\n\n    \n    mp_uint_t ret = 0;\n    int err;\n    if (self->format == DEFLATEIO_FORMAT_ZLIB) {\n        \n        \n        uint8_t buf[] = { 0x08, 0x80 }; \n        buf[0] |= MAX(wbits - 8, 1) << 4; \n        buf[1] |= 31 - ((buf[0] * 256 + buf[1]) % 31); \n        ret = stream->write(self->stream, buf, sizeof(buf), &err);\n\n        self->write->input_checksum = 1; \n    } else if (self->format == DEFLATEIO_FORMAT_GZIP) {\n        \n        \n        uint8_t buf[] = { 0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03 }; \n        ret = stream->write(self->stream, buf, sizeof(buf), &err);\n\n        self->write->input_checksum = ~0; \n    }\n    if (ret == MP_STREAM_ERROR) {\n        return false;\n    }\n\n    \n    uzlib_start_block(&self->write->lz77);\n\n    return true;\n}\n#endif\n\nstatic mp_obj_t deflateio_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args_in) {\n    \n    mp_arg_check_num(n_args, n_kw, 1, 4, false);\n\n    mp_int_t format = n_args > 1 ? mp_obj_get_int(args_in[1]) : DEFLATEIO_FORMAT_AUTO;\n    mp_int_t wbits = n_args > 2 ? mp_obj_get_int(args_in[2]) : 0;\n\n    if (format < DEFLATEIO_FORMAT_MIN || format > DEFLATEIO_FORMAT_MAX) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"format\"));\n    }\n    if (wbits != 0 && (wbits < 5 || wbits > 15)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"wbits\"));\n    }\n\n    mp_obj_deflateio_t *self = mp_obj_malloc(mp_obj_deflateio_t, type);\n    self->stream = args_in[0];\n    self->format = format;\n    self->window_bits = wbits;\n    self->read = NULL;\n    #if MICROPY_PY_DEFLATE_COMPRESS\n    self->write = NULL;\n    #endif\n    self->close = n_args > 3 ? mp_obj_is_true(args_in[3]) : false;\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_uint_t deflateio_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_deflateio_t *self = MP_OBJ_TO_PTR(o_in);\n\n    if (self->stream == MP_OBJ_NULL || !deflateio_init_read(self)) {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n\n    if (self->read->eof) {\n        return 0;\n    }\n\n    self->read->decomp.dest = buf;\n    self->read->decomp.dest_limit = (uint8_t *)buf + size;\n    int st = uzlib_uncompress_chksum(&self->read->decomp);\n    if (st == UZLIB_DONE) {\n        self->read->eof = true;\n    }\n    if (st < 0) {\n        DEBUG_printf(\"uncompress error=\" INT_FMT \"\\n\", st);\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n    return self->read->decomp.dest - (uint8_t *)buf;\n}\n\n#if MICROPY_PY_DEFLATE_COMPRESS\nstatic mp_uint_t deflateio_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_deflateio_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->stream == MP_OBJ_NULL || !deflateio_init_write(self)) {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n\n    self->write->input_len += size;\n    if (self->format == DEFLATEIO_FORMAT_ZLIB) {\n        self->write->input_checksum = uzlib_adler32(buf, size, self->write->input_checksum);\n    } else if (self->format == DEFLATEIO_FORMAT_GZIP) {\n        self->write->input_checksum = uzlib_crc32(buf, size, self->write->input_checksum);\n    }\n\n    uzlib_lz77_compress(&self->write->lz77, buf, size);\n    return size;\n}\n\nstatic inline void put_le32(char *buf, uint32_t value) {\n    buf[0] = value & 0xff;\n    buf[1] = value >> 8 & 0xff;\n    buf[2] = value >> 16 & 0xff;\n    buf[3] = value >> 24 & 0xff;\n}\n\nstatic inline void put_be32(char *buf, uint32_t value) {\n    buf[3] = value & 0xff;\n    buf[2] = value >> 8 & 0xff;\n    buf[1] = value >> 16 & 0xff;\n    buf[0] = value >> 24 & 0xff;\n}\n#endif\n\nstatic mp_uint_t deflateio_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    if (request == MP_STREAM_CLOSE) {\n        mp_obj_deflateio_t *self = MP_OBJ_TO_PTR(self_in);\n\n        mp_uint_t ret = 0;\n\n        if (self->stream != MP_OBJ_NULL) {\n            #if MICROPY_PY_DEFLATE_COMPRESS\n            if (self->write) {\n                uzlib_finish_block(&self->write->lz77);\n\n                const mp_stream_p_t *stream = mp_get_stream(self->stream);\n\n                \n                if (self->format == DEFLATEIO_FORMAT_ZLIB || self->format == DEFLATEIO_FORMAT_GZIP) {\n                    char footer[8];\n                    size_t footer_len;\n                    if (self->format == DEFLATEIO_FORMAT_ZLIB) {\n                        put_be32(&footer[0], self->write->input_checksum);\n                        footer_len = 4;\n                    } else { \n                        put_le32(&footer[0], ~self->write->input_checksum);\n                        put_le32(&footer[4], self->write->input_len);\n                        footer_len = 8;\n                    }\n                    if (stream->write(self->stream, footer, footer_len, errcode) == MP_STREAM_ERROR) {\n                        ret = MP_STREAM_ERROR;\n                    }\n                }\n            }\n            #endif\n\n            \n            \n            if (self->close) {\n                mp_stream_close(self->stream);\n            }\n\n            \n            self->stream = MP_OBJ_NULL;\n        }\n\n        return ret;\n    } else {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic const mp_stream_p_t deflateio_stream_p = {\n    .read = deflateio_read,\n    #if MICROPY_PY_DEFLATE_COMPRESS\n    .write = deflateio_write,\n    #endif\n    .ioctl = deflateio_ioctl,\n};\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_rom_map_elem_t deflateio_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    #if MICROPY_PY_DEFLATE_COMPRESS\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&mp_identity_obj) },\n    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&mp_stream___exit___obj) },\n};\nstatic MP_DEFINE_CONST_DICT(deflateio_locals_dict, deflateio_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    deflateio_type,\n    MP_QSTR_DeflateIO,\n    MP_TYPE_FLAG_NONE,\n    make_new, deflateio_make_new,\n    protocol, &deflateio_stream_p,\n    locals_dict, &deflateio_locals_dict\n    );\n\nstatic const mp_rom_map_elem_t mp_module_deflate_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_deflate) },\n    { MP_ROM_QSTR(MP_QSTR_DeflateIO), MP_ROM_PTR(&deflateio_type) },\n    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_INT(DEFLATEIO_FORMAT_AUTO) },\n    { MP_ROM_QSTR(MP_QSTR_RAW), MP_ROM_INT(DEFLATEIO_FORMAT_RAW) },\n    { MP_ROM_QSTR(MP_QSTR_ZLIB), MP_ROM_INT(DEFLATEIO_FORMAT_ZLIB) },\n    { MP_ROM_QSTR(MP_QSTR_GZIP), MP_ROM_INT(DEFLATEIO_FORMAT_GZIP) },\n};\nstatic MP_DEFINE_CONST_DICT(mp_module_deflate_globals, mp_module_deflate_globals_table);\n\nconst mp_obj_module_t mp_module_deflate = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_deflate_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_deflate, mp_module_deflate);\n#endif \n\n\n\n\n#include \"lib/uzlib/tinflate.c\"\n#include \"lib/uzlib/header.c\"\n#include \"lib/uzlib/adler32.c\"\n#include \"lib/uzlib/crc32.c\"\n\n#if MICROPY_PY_DEFLATE_COMPRESS\n#include \"lib/uzlib/lz77.c\"\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}