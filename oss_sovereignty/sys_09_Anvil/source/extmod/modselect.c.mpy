{
  "module_name": "modselect.c",
  "hash_id": "2a84a571bcd57704dd6e6b4a8e85141030e3783ab651a38f74488c5a476d4c76",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modselect.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n#include \"py/runtime.h\"\n#include \"py/obj.h\"\n#include \"py/objlist.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_SELECT\n\n#if MICROPY_PY_SELECT_SELECT && MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n#error \"select.select is not supported with MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\"\n#endif\n\n#if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\n#include <string.h>\n#include <poll.h>\n\n#if !((MP_STREAM_POLL_RD) == (POLLIN) && \\\n    (MP_STREAM_POLL_WR) == (POLLOUT) && \\\n    (MP_STREAM_POLL_ERR) == (POLLERR) && \\\n    (MP_STREAM_POLL_HUP) == (POLLHUP) && \\\n    (MP_STREAM_POLL_NVAL) == (POLLNVAL))\n#error \"With MICROPY_PY_SELECT_POSIX_OPTIMISATIONS enabled, POLL constants must match\"\n#endif\n\n\n\n\n#define MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS (1)\n\n#endif\n\n\n#define FLAG_ONESHOT (1)\n\n\ntypedef struct _poll_obj_t {\n    mp_obj_t obj;\n    mp_uint_t (*ioctl)(mp_obj_t obj, mp_uint_t request, uintptr_t arg, int *errcode);\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    \n    \n    \n    \n    \n    \n    struct pollfd *pollfd;\n    uint16_t nonfd_events;\n    uint16_t nonfd_revents;\n    #else\n    mp_uint_t events;\n    mp_uint_t revents;\n    #endif\n} poll_obj_t;\n\n\ntypedef struct _poll_set_t {\n    \n    mp_map_t map;\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    \n    unsigned short alloc; \n    unsigned short max_used; \n    unsigned short used; \n    struct pollfd *pollfds;\n    #endif\n} poll_set_t;\n\nstatic void poll_set_init(poll_set_t *poll_set, size_t n) {\n    mp_map_init(&poll_set->map, n);\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    poll_set->alloc = 0;\n    poll_set->max_used = 0;\n    poll_set->used = 0;\n    poll_set->pollfds = NULL;\n    #endif\n}\n\n#if MICROPY_PY_SELECT_SELECT\nstatic void poll_set_deinit(poll_set_t *poll_set) {\n    mp_map_deinit(&poll_set->map);\n}\n#endif\n\n#if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\nstatic mp_uint_t poll_obj_get_events(poll_obj_t *poll_obj) {\n    assert(poll_obj->pollfd == NULL);\n    return poll_obj->nonfd_events;\n}\n\nstatic void poll_obj_set_events(poll_obj_t *poll_obj, mp_uint_t events) {\n    if (poll_obj->pollfd != NULL) {\n        poll_obj->pollfd->events = events;\n    } else {\n        poll_obj->nonfd_events = events;\n    }\n}\n\nstatic mp_uint_t poll_obj_get_revents(poll_obj_t *poll_obj) {\n    if (poll_obj->pollfd != NULL) {\n        return poll_obj->pollfd->revents;\n    } else {\n        return poll_obj->nonfd_revents;\n    }\n}\n\nstatic void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n    if (poll_obj->pollfd != NULL) {\n        poll_obj->pollfd->revents = revents;\n    } else {\n        poll_obj->nonfd_revents = revents;\n    }\n}\n\n\n#define POLL_SET_ALLOC_INCREMENT (4)\n\nstatic struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n\n    if (poll_set->used == poll_set->max_used) {\n        \n        if (poll_set->max_used >= poll_set->alloc) {\n            size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;\n            \n            struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);\n            if (!new_fds) {\n                \n                new_fds = m_new(struct pollfd, new_alloc);\n                memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);\n\n                \n                \n                for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n                    if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n                        continue;\n                    }\n\n                    poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n                    if (!poll_obj) {\n                        \n                        \n                        \n                        continue;\n                    }\n\n                    poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);\n                }\n\n                \n                m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);\n            }\n\n            poll_set->pollfds = new_fds;\n            poll_set->alloc = new_alloc;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        \n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n\n    free_slot->fd = fd;\n    ++poll_set->used;\n\n    return free_slot;\n}\n\nstatic inline bool poll_set_all_are_fds(poll_set_t *poll_set) {\n    return poll_set->map.used == poll_set->used;\n}\n\n#else\n\nstatic inline mp_uint_t poll_obj_get_events(poll_obj_t *poll_obj) {\n    return poll_obj->events;\n}\n\nstatic inline void poll_obj_set_events(poll_obj_t *poll_obj, mp_uint_t events) {\n    poll_obj->events = events;\n}\n\nstatic inline mp_uint_t poll_obj_get_revents(poll_obj_t *poll_obj) {\n    return poll_obj->revents;\n}\n\nstatic inline void poll_obj_set_revents(poll_obj_t *poll_obj, mp_uint_t revents) {\n    poll_obj->revents = revents;\n}\n\n#endif\n\nstatic void poll_set_add_obj(poll_set_t *poll_set, const mp_obj_t *obj, mp_uint_t obj_len, mp_uint_t events, bool or_events) {\n    for (mp_uint_t i = 0; i < obj_len; i++) {\n        mp_map_elem_t *elem = mp_map_lookup(&poll_set->map, mp_obj_id(obj[i]), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n        if (elem->value == MP_OBJ_NULL) {\n            \n\n            \n            \n\n            poll_obj_t *poll_obj = m_new_obj(poll_obj_t);\n            poll_obj->obj = obj[i];\n\n            #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n            int fd = -1;\n            if (mp_obj_is_int(obj[i])) {\n                \n                fd = mp_obj_get_int(obj[i]);\n                if (fd < 0) {\n                    mp_raise_ValueError(NULL);\n                }\n                poll_obj->ioctl = NULL;\n            } else {\n                \n                const mp_stream_p_t *stream_p = mp_get_stream_raise(obj[i], MP_STREAM_OP_IOCTL);\n                poll_obj->ioctl = stream_p->ioctl;\n                int err;\n                mp_uint_t res = stream_p->ioctl(obj[i], MP_STREAM_GET_FILENO, 0, &err);\n                if (res != MP_STREAM_ERROR) {\n                    fd = res;\n                }\n            }\n            if (fd >= 0) {\n                \n                poll_obj->pollfd = poll_set_add_fd(poll_set, fd);\n            } else {\n                \n                poll_obj->pollfd = NULL;\n            }\n            #else\n            const mp_stream_p_t *stream_p = mp_get_stream_raise(obj[i], MP_STREAM_OP_IOCTL);\n            poll_obj->ioctl = stream_p->ioctl;\n            #endif\n\n            poll_obj_set_events(poll_obj, events);\n            poll_obj_set_revents(poll_obj, 0);\n            elem->value = MP_OBJ_FROM_PTR(poll_obj);\n        } else {\n            \n            poll_obj_t *poll_obj = (poll_obj_t *)MP_OBJ_TO_PTR(elem->value);\n            #if MICROPY_PY_SELECT_SELECT\n            if (or_events) {\n                events |= poll_obj_get_events(poll_obj);\n            }\n            #else\n            (void)or_events;\n            #endif\n            poll_obj_set_events(poll_obj, events);\n        }\n    }\n}\n\n\nstatic mp_uint_t poll_set_poll_once(poll_set_t *poll_set, size_t *rwx_num) {\n    mp_uint_t n_ready = 0;\n    for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&poll_set->map, i)) {\n            continue;\n        }\n\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);\n\n        #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n        if (poll_obj->pollfd != NULL) {\n            \n            continue;\n        }\n        #endif\n\n        int errcode;\n        mp_int_t ret = poll_obj->ioctl(poll_obj->obj, MP_STREAM_POLL, poll_obj_get_events(poll_obj), &errcode);\n        poll_obj_set_revents(poll_obj, ret);\n\n        if (ret == -1) {\n            \n            mp_raise_OSError(errcode);\n        }\n\n        if (ret != 0) {\n            \n            n_ready += 1;\n            #if MICROPY_PY_SELECT_SELECT\n            if (rwx_num != NULL) {\n                if (ret & MP_STREAM_POLL_RD) {\n                    rwx_num[0] += 1;\n                }\n                if (ret & MP_STREAM_POLL_WR) {\n                    rwx_num[1] += 1;\n                }\n                if ((ret & ~(MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)) != 0) {\n                    rwx_num[2] += 1;\n                }\n            }\n            #else\n            (void)rwx_num;\n            #endif\n        }\n    }\n    return n_ready;\n}\n\nstatic mp_uint_t poll_set_poll_until_ready_or_timeout(poll_set_t *poll_set, size_t *rwx_num, mp_uint_t timeout) {\n    mp_uint_t start_ticks = mp_hal_ticks_ms();\n    bool has_timeout = timeout != (mp_uint_t)-1;\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n\n    for (;;) {\n        MP_THREAD_GIL_EXIT();\n\n        \n        int t = MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS;\n        if (poll_set_all_are_fds(poll_set)) {\n            \n            \n            if (timeout == (mp_uint_t)-1) {\n                t = -1;\n            } else {\n                mp_uint_t delta = mp_hal_ticks_ms() - start_ticks;\n                if (delta >= timeout) {\n                    t = 0;\n                } else {\n                    t = timeout - delta;\n                }\n            }\n        }\n\n        \n        int n_ready = poll(poll_set->pollfds, poll_set->max_used, t);\n\n        MP_THREAD_GIL_ENTER();\n\n        \n        \n        if (n_ready == -1) {\n            int err = errno;\n            if (err != EINTR) {\n                mp_raise_OSError(err);\n            }\n            n_ready = 0;\n        }\n\n        \n        if (!poll_set_all_are_fds(poll_set)) {\n            n_ready += poll_set_poll_once(poll_set, rwx_num);\n        }\n\n        \n        if (n_ready > 0 || (has_timeout && mp_hal_ticks_ms() - start_ticks >= timeout)) {\n            return n_ready;\n        }\n\n        \n        mp_event_handle_nowait();\n    }\n\n    #else\n\n    for (;;) {\n        \n        mp_uint_t n_ready = poll_set_poll_once(poll_set, rwx_num);\n        uint32_t elapsed = mp_hal_ticks_ms() - start_ticks;\n        if (n_ready > 0 || (has_timeout && elapsed >= timeout)) {\n            return n_ready;\n        }\n        if (has_timeout) {\n            mp_event_wait_ms(timeout - elapsed);\n        } else {\n            mp_event_wait_indefinite();\n        }\n    }\n\n    #endif\n}\n\n#if MICROPY_PY_SELECT_SELECT\n\nstatic mp_obj_t select_select(size_t n_args, const mp_obj_t *args) {\n    \n    size_t rwx_len[3];\n    mp_obj_t *r_array, *w_array, *x_array;\n    mp_obj_get_array(args[0], &rwx_len[0], &r_array);\n    mp_obj_get_array(args[1], &rwx_len[1], &w_array);\n    mp_obj_get_array(args[2], &rwx_len[2], &x_array);\n\n    \n    mp_uint_t timeout = -1;\n    if (n_args == 4) {\n        if (args[3] != mp_const_none) {\n            #if MICROPY_PY_BUILTINS_FLOAT\n            float timeout_f = mp_obj_get_float_to_f(args[3]);\n            if (timeout_f >= 0) {\n                timeout = (mp_uint_t)(timeout_f * 1000);\n            }\n            #else\n            timeout = mp_obj_get_int(args[3]) * 1000;\n            #endif\n        }\n    }\n\n    \n    poll_set_t poll_set;\n    poll_set_init(&poll_set, rwx_len[0] + rwx_len[1] + rwx_len[2]);\n    poll_set_add_obj(&poll_set, r_array, rwx_len[0], MP_STREAM_POLL_RD, true);\n    poll_set_add_obj(&poll_set, w_array, rwx_len[1], MP_STREAM_POLL_WR, true);\n    poll_set_add_obj(&poll_set, x_array, rwx_len[2], MP_STREAM_POLL_ERR | MP_STREAM_POLL_HUP, true);\n\n    \n    rwx_len[0] = rwx_len[1] = rwx_len[2] = 0;\n    poll_set_poll_until_ready_or_timeout(&poll_set, rwx_len, timeout);\n\n    \n    mp_obj_t list_array[3];\n    list_array[0] = mp_obj_new_list(rwx_len[0], NULL);\n    list_array[1] = mp_obj_new_list(rwx_len[1], NULL);\n    list_array[2] = mp_obj_new_list(rwx_len[2], NULL);\n    rwx_len[0] = rwx_len[1] = rwx_len[2] = 0;\n    for (mp_uint_t i = 0; i < poll_set.map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set.map.table[i].value);\n        if (poll_obj->revents & MP_STREAM_POLL_RD) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[0]))->items[rwx_len[0]++] = poll_obj->obj;\n        }\n        if (poll_obj->revents & MP_STREAM_POLL_WR) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[1]))->items[rwx_len[1]++] = poll_obj->obj;\n        }\n        if ((poll_obj->revents & ~(MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)) != 0) {\n            ((mp_obj_list_t *)MP_OBJ_TO_PTR(list_array[2]))->items[rwx_len[2]++] = poll_obj->obj;\n        }\n    }\n    poll_set_deinit(&poll_set);\n    return mp_obj_new_tuple(3, list_array);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_select_select_obj, 3, 4, select_select);\n#endif \n\ntypedef struct _mp_obj_poll_t {\n    mp_obj_base_t base;\n    poll_set_t poll_set;\n    short iter_cnt;\n    short iter_idx;\n    int flags;\n    \n    mp_obj_t ret_tuple;\n} mp_obj_poll_t;\n\n\nstatic mp_obj_t poll_register(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_uint_t events;\n    if (n_args == 3) {\n        events = mp_obj_get_int(args[2]);\n    } else {\n        events = MP_STREAM_POLL_RD | MP_STREAM_POLL_WR;\n    }\n    poll_set_add_obj(&self->poll_set, &args[1], 1, events, false);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_register_obj, 2, 3, poll_register);\n\n\nstatic mp_obj_t poll_unregister(mp_obj_t self_in, mp_obj_t obj_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->poll_set.map, mp_obj_id(obj_in), MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n\n    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS\n    if (elem != NULL) {\n        poll_obj_t *poll_obj = (poll_obj_t *)MP_OBJ_TO_PTR(elem->value);\n        if (poll_obj->pollfd != NULL) {\n            poll_obj->pollfd->fd = -1;\n            --self->poll_set.used;\n        }\n        elem->value = MP_OBJ_NULL;\n    }\n    #else\n    (void)elem;\n    #endif\n\n    \n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_2(poll_unregister_obj, poll_unregister);\n\n\nstatic mp_obj_t poll_modify(mp_obj_t self_in, mp_obj_t obj_in, mp_obj_t eventmask_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->poll_set.map, mp_obj_id(obj_in), MP_MAP_LOOKUP);\n    if (elem == NULL) {\n        mp_raise_OSError(MP_ENOENT);\n    }\n    poll_obj_set_events((poll_obj_t *)MP_OBJ_TO_PTR(elem->value), mp_obj_get_int(eventmask_in));\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_3(poll_modify_obj, poll_modify);\n\nstatic mp_uint_t poll_poll_internal(uint n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    \n    mp_uint_t timeout = -1;\n    int flags = 0;\n    if (n_args >= 2) {\n        if (args[1] != mp_const_none) {\n            mp_int_t timeout_i = mp_obj_get_int(args[1]);\n            if (timeout_i >= 0) {\n                timeout = timeout_i;\n            }\n        }\n        if (n_args >= 3) {\n            flags = mp_obj_get_int(args[2]);\n        }\n    }\n\n    self->flags = flags;\n\n    return poll_set_poll_until_ready_or_timeout(&self->poll_set, NULL, timeout);\n}\n\nstatic mp_obj_t poll_poll(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_uint_t n_ready = poll_poll_internal(n_args, args);\n\n    \n    mp_obj_list_t *ret_list = MP_OBJ_TO_PTR(mp_obj_new_list(n_ready, NULL));\n    n_ready = 0;\n    for (mp_uint_t i = 0; i < self->poll_set.map.alloc; ++i) {\n        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);\n        if (poll_obj_get_revents(poll_obj) != 0) {\n            mp_obj_t tuple[2] = {poll_obj->obj, MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj))};\n            ret_list->items[n_ready++] = mp_obj_new_tuple(2, tuple);\n        }\n    }\n    return MP_OBJ_FROM_PTR(ret_list);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_poll_obj, 1, 2, poll_poll);\n\nstatic mp_obj_t poll_ipoll(size_t n_args, const mp_obj_t *args) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (self->ret_tuple == MP_OBJ_NULL) {\n        self->ret_tuple = mp_obj_new_tuple(2, NULL);\n    }\n\n    int n_ready = poll_poll_internal(n_args, args);\n    self->iter_cnt = n_ready;\n    self->iter_idx = 0;\n\n    return args[0];\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(poll_ipoll_obj, 1, 3, poll_ipoll);\n\nstatic mp_obj_t poll_iternext(mp_obj_t self_in) {\n    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->iter_cnt == 0) {\n        return MP_OBJ_STOP_ITERATION;\n    }\n\n    self->iter_cnt--;\n\n    for (mp_uint_t i = self->iter_idx; i < self->poll_set.map.alloc; ++i) {\n        self->iter_idx++;\n        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {\n            continue;\n        }\n        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);\n        if (poll_obj_get_revents(poll_obj) != 0) {\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->ret_tuple);\n            t->items[0] = poll_obj->obj;\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj));\n            if (self->flags & FLAG_ONESHOT) {\n                \n                poll_obj_set_events(poll_obj, 0);\n            }\n            return MP_OBJ_FROM_PTR(t);\n        }\n    }\n\n    assert(!\"inconsistent number of poll active entries\");\n    self->iter_cnt = 0;\n    return MP_OBJ_STOP_ITERATION;\n}\n\nstatic const mp_rom_map_elem_t poll_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&poll_register_obj) },\n    { MP_ROM_QSTR(MP_QSTR_unregister), MP_ROM_PTR(&poll_unregister_obj) },\n    { MP_ROM_QSTR(MP_QSTR_modify), MP_ROM_PTR(&poll_modify_obj) },\n    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&poll_poll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ipoll), MP_ROM_PTR(&poll_ipoll_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(poll_locals_dict, poll_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_poll,\n    MP_QSTR_poll,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    iter, poll_iternext,\n    locals_dict, &poll_locals_dict\n    );\n\n\nstatic mp_obj_t select_poll(void) {\n    mp_obj_poll_t *poll = mp_obj_malloc(mp_obj_poll_t, &mp_type_poll);\n    poll_set_init(&poll->poll_set, 0);\n    poll->iter_cnt = 0;\n    poll->ret_tuple = MP_OBJ_NULL;\n    return MP_OBJ_FROM_PTR(poll);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_select_poll_obj, select_poll);\n\nstatic const mp_rom_map_elem_t mp_module_select_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_select) },\n    #if MICROPY_PY_SELECT_SELECT\n    { MP_ROM_QSTR(MP_QSTR_select), MP_ROM_PTR(&mp_select_select_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&mp_select_poll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_POLLIN), MP_ROM_INT(MP_STREAM_POLL_RD) },\n    { MP_ROM_QSTR(MP_QSTR_POLLOUT), MP_ROM_INT(MP_STREAM_POLL_WR) },\n    { MP_ROM_QSTR(MP_QSTR_POLLERR), MP_ROM_INT(MP_STREAM_POLL_ERR) },\n    { MP_ROM_QSTR(MP_QSTR_POLLHUP), MP_ROM_INT(MP_STREAM_POLL_HUP) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_select_globals, mp_module_select_globals_table);\n\nconst mp_obj_module_t mp_module_select = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_select_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_select, mp_module_select);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}