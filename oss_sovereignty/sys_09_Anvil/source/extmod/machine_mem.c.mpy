{
  "module_name": "machine_mem.c",
  "hash_id": "558c3eb4456cd97bb69b4c258218019becd4e9f362cd0db96cbfb6b15c0cfa1d",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_mem.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"extmod/modmachine.h\"\n\n#if MICROPY_PY_MACHINE_MEMX\n\n\n\n\n\n\n\n\n\n\n#if !defined(MICROPY_MACHINE_MEM_GET_READ_ADDR) || !defined(MICROPY_MACHINE_MEM_GET_WRITE_ADDR)\nstatic uintptr_t machine_mem_get_addr(mp_obj_t addr_o, uint align) {\n    uintptr_t addr = mp_obj_get_int_truncated(addr_o);\n    if ((addr & (align - 1)) != 0) {\n        mp_raise_msg_varg(&mp_type_ValueError, MP_ERROR_TEXT(\"address %08x is not aligned to %d bytes\"), addr, align);\n    }\n    return addr;\n}\n#if !defined(MICROPY_MACHINE_MEM_GET_READ_ADDR)\n#define MICROPY_MACHINE_MEM_GET_READ_ADDR machine_mem_get_addr\n#endif\n#if !defined(MICROPY_MACHINE_MEM_GET_WRITE_ADDR)\n#define MICROPY_MACHINE_MEM_GET_WRITE_ADDR machine_mem_get_addr\n#endif\n#endif\n\nstatic void machine_mem_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    machine_mem_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<%u-bit memory>\", 8 * self->elem_size);\n}\n\nstatic mp_obj_t machine_mem_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    \n    machine_mem_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (value == MP_OBJ_NULL) {\n        \n        return MP_OBJ_NULL; \n    } else if (value == MP_OBJ_SENTINEL) {\n        \n        uintptr_t addr = MICROPY_MACHINE_MEM_GET_READ_ADDR(index, self->elem_size);\n        uint32_t val;\n        switch (self->elem_size) {\n            case 1:\n                val = (*(uint8_t *)addr);\n                break;\n            case 2:\n                val = (*(uint16_t *)addr);\n                break;\n            default:\n                val = (*(uint32_t *)addr);\n                break;\n        }\n        return mp_obj_new_int(val);\n    } else {\n        \n        uintptr_t addr = MICROPY_MACHINE_MEM_GET_WRITE_ADDR(index, self->elem_size);\n        uint32_t val = mp_obj_get_int_truncated(value);\n        switch (self->elem_size) {\n            case 1:\n                (*(uint8_t *)addr) = val;\n                break;\n            case 2:\n                (*(uint16_t *)addr) = val;\n                break;\n            default:\n                (*(uint32_t *)addr) = val;\n                break;\n        }\n        return mp_const_none;\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    machine_mem_type,\n    MP_QSTR_mem,\n    MP_TYPE_FLAG_NONE,\n    print, machine_mem_print,\n    subscr, machine_mem_subscr\n    );\n\nconst machine_mem_obj_t machine_mem8_obj = {{&machine_mem_type}, 1};\nconst machine_mem_obj_t machine_mem16_obj = {{&machine_mem_type}, 2};\nconst machine_mem_obj_t machine_mem32_obj = {{&machine_mem_type}, 4};\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}