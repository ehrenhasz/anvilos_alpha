{
  "module_name": "moductypes.c",
  "hash_id": "e6531c96756cef9c2e5505e3463536301acef9913ce99615e4c51f51f1af5a1a",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/moductypes.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <string.h>\n#include <stdint.h>\n\n#include \"py/runtime.h\"\n#include \"py/objtuple.h\"\n#include \"py/binary.h\"\n\n#if MICROPY_PY_UCTYPES\n\n\n\n\n\n\n#define LAYOUT_LITTLE_ENDIAN (0)\n#define LAYOUT_BIG_ENDIAN    (1)\n#define LAYOUT_NATIVE        (2)\n\n#define VAL_TYPE_BITS 4\n#define BITF_LEN_BITS 5\n#define BITF_OFF_BITS 5\n#define OFFSET_BITS 17\n#define LEN_BITS (OFFSET_BITS + BITF_OFF_BITS)\n#if VAL_TYPE_BITS + BITF_LEN_BITS + BITF_OFF_BITS + OFFSET_BITS != 31\n#error Invalid encoding field length\n#endif\n\nenum {\n    UINT8, INT8, UINT16, INT16,\n    UINT32, INT32, UINT64, INT64,\n\n    BFUINT8, BFINT8, BFUINT16, BFINT16,\n    BFUINT32, BFINT32,\n\n    FLOAT32, FLOAT64,\n};\n\n#define AGG_TYPE_BITS 2\n\nenum {\n    STRUCT, PTR, ARRAY,\n};\n\n\n#define TYPE2SMALLINT(x, nbits) ((((int)x) << (32 - nbits)) >> 1)\n#define GET_TYPE(x, nbits) (((x) >> (31 - nbits)) & ((1 << nbits) - 1))\n\n#define GET_SCALAR_SIZE(val_type) (1 << ((val_type) >> 1))\n#define VALUE_MASK(type_nbits) ~((int)0x80000000 >> type_nbits)\n\n#define IS_SCALAR_ARRAY(tuple_desc) ((tuple_desc)->len == 2)\n\n#define IS_SCALAR_ARRAY_OF_BYTES(tuple_desc) (GET_TYPE(MP_OBJ_SMALL_INT_VALUE((tuple_desc)->items[1]), VAL_TYPE_BITS) == UINT8)\n\n\nstatic const mp_obj_type_t uctypes_struct_type;\n\ntypedef struct _mp_obj_uctypes_struct_t {\n    mp_obj_base_t base;\n    mp_obj_t desc;\n    byte *addr;\n    uint32_t flags;\n} mp_obj_uctypes_struct_t;\n\nstatic NORETURN void syntax_error(void) {\n    mp_raise_TypeError(MP_ERROR_TEXT(\"syntax error in uctypes descriptor\"));\n}\n\nstatic mp_obj_t uctypes_struct_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 2, 3, false);\n    mp_obj_uctypes_struct_t *o = mp_obj_malloc(mp_obj_uctypes_struct_t, type);\n    o->addr = (void *)(uintptr_t)mp_obj_get_int_truncated(args[0]);\n    o->desc = args[1];\n    o->flags = LAYOUT_NATIVE;\n    if (n_args == 3) {\n        o->flags = mp_obj_get_int(args[2]);\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic void uctypes_struct_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);\n    const char *typen = \"unk\";\n    if (mp_obj_is_dict_or_ordereddict(self->desc)) {\n        typen = \"STRUCT\";\n    } else if (mp_obj_is_type(self->desc, &mp_type_tuple)) {\n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->desc);\n        mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);\n        uint agg_type = GET_TYPE(offset, AGG_TYPE_BITS);\n        switch (agg_type) {\n            case PTR:\n                typen = \"PTR\";\n                break;\n            case ARRAY:\n                typen = \"ARRAY\";\n                break;\n        }\n    } else {\n        typen = \"ERROR\";\n    }\n    mp_printf(print, \"<struct %s %p>\", typen, self->addr);\n}\n\n\nstatic mp_uint_t uctypes_struct_size(mp_obj_t desc_in, int layout_type, mp_uint_t *max_field_size);\n\n\nstatic inline mp_uint_t uctypes_struct_scalar_size(int val_type) {\n    if (val_type == FLOAT32) {\n        return 4;\n    } else {\n        return GET_SCALAR_SIZE(val_type & 7);\n    }\n}\n\n\nstatic mp_uint_t uctypes_struct_agg_size(mp_obj_tuple_t *t, int layout_type, mp_uint_t *max_field_size) {\n    mp_uint_t total_size = 0;\n\n    mp_int_t offset_ = MP_OBJ_SMALL_INT_VALUE(t->items[0]);\n    mp_uint_t agg_type = GET_TYPE(offset_, AGG_TYPE_BITS);\n\n    switch (agg_type) {\n        case STRUCT:\n            return uctypes_struct_size(t->items[1], layout_type, max_field_size);\n        case PTR:\n            if (sizeof(void *) > *max_field_size) {\n                *max_field_size = sizeof(void *);\n            }\n            return sizeof(void *);\n        case ARRAY: {\n            mp_int_t arr_sz = MP_OBJ_SMALL_INT_VALUE(t->items[1]);\n            uint val_type = GET_TYPE(arr_sz, VAL_TYPE_BITS);\n            arr_sz &= VALUE_MASK(VAL_TYPE_BITS);\n            mp_uint_t item_s;\n            if (t->len == 2) {\n                \n                item_s = uctypes_struct_scalar_size(val_type);\n                if (item_s > *max_field_size) {\n                    *max_field_size = item_s;\n                }\n            } else {\n                \n                item_s = uctypes_struct_size(t->items[2], layout_type, max_field_size);\n            }\n\n            return item_s * arr_sz;\n        }\n        default:\n            assert(0);\n    }\n\n    return total_size;\n}\n\nstatic mp_uint_t uctypes_struct_size(mp_obj_t desc_in, int layout_type, mp_uint_t *max_field_size) {\n    if (!mp_obj_is_dict_or_ordereddict(desc_in)) {\n        if (mp_obj_is_type(desc_in, &mp_type_tuple)) {\n            return uctypes_struct_agg_size((mp_obj_tuple_t *)MP_OBJ_TO_PTR(desc_in), layout_type, max_field_size);\n        } else if (mp_obj_is_small_int(desc_in)) {\n            \n            \n            \n            \n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't unambiguously get sizeof scalar\"));\n        }\n        syntax_error();\n    }\n\n    mp_obj_dict_t *d = MP_OBJ_TO_PTR(desc_in);\n    mp_uint_t total_size = 0;\n\n    for (mp_uint_t i = 0; i < d->map.alloc; i++) {\n        if (mp_map_slot_is_filled(&d->map, i)) {\n            mp_obj_t v = d->map.table[i].value;\n            if (mp_obj_is_small_int(v)) {\n                mp_uint_t offset = MP_OBJ_SMALL_INT_VALUE(v);\n                mp_uint_t val_type = GET_TYPE(offset, VAL_TYPE_BITS);\n                offset &= VALUE_MASK(VAL_TYPE_BITS);\n                if (val_type >= BFUINT8 && val_type <= BFINT32) {\n                    offset &= (1 << OFFSET_BITS) - 1;\n                }\n                mp_uint_t s = uctypes_struct_scalar_size(val_type);\n                if (s > *max_field_size) {\n                    *max_field_size = s;\n                }\n                if (offset + s > total_size) {\n                    total_size = offset + s;\n                }\n            } else {\n                if (!mp_obj_is_type(v, &mp_type_tuple)) {\n                    syntax_error();\n                }\n                mp_obj_tuple_t *t = MP_OBJ_TO_PTR(v);\n                mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);\n                offset &= VALUE_MASK(AGG_TYPE_BITS);\n                mp_uint_t s = uctypes_struct_agg_size(t, layout_type, max_field_size);\n                if (offset + s > total_size) {\n                    total_size = offset + s;\n                }\n            }\n        }\n    }\n\n    \n    if (layout_type == LAYOUT_NATIVE) {\n        total_size = (total_size + *max_field_size - 1) & ~(*max_field_size - 1);\n    }\n    return total_size;\n}\n\nstatic mp_obj_t uctypes_struct_sizeof(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t obj_in = args[0];\n    mp_uint_t max_field_size = 0;\n    if (mp_obj_is_type(obj_in, &mp_type_bytearray)) {\n        return mp_obj_len(obj_in);\n    }\n    int layout_type = LAYOUT_NATIVE;\n    \n    \n    if (mp_obj_is_type(obj_in, &uctypes_struct_type)) {\n        if (n_args != 1) {\n            mp_raise_TypeError(NULL);\n        }\n        \n        mp_obj_uctypes_struct_t *obj = MP_OBJ_TO_PTR(obj_in);\n        obj_in = obj->desc;\n        layout_type = obj->flags;\n    } else {\n        if (n_args == 2) {\n            layout_type = mp_obj_get_int(args[1]);\n        }\n    }\n    mp_uint_t size = uctypes_struct_size(obj_in, layout_type, &max_field_size);\n    return MP_OBJ_NEW_SMALL_INT(size);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(uctypes_struct_sizeof_obj, 1, 2, uctypes_struct_sizeof);\n\nstatic inline mp_obj_t get_unaligned(uint val_type, byte *p, int big_endian) {\n    char struct_type = big_endian ? '>' : '<';\n    static const char type2char[16] = \"BbHhIiQq------fd\";\n    return mp_binary_get_val(struct_type, type2char[val_type], p, &p);\n}\n\nstatic inline void set_unaligned(uint val_type, byte *p, int big_endian, mp_obj_t val) {\n    char struct_type = big_endian ? '>' : '<';\n    static const char type2char[16] = \"BbHhIiQq------fd\";\n    mp_binary_set_val(struct_type, type2char[val_type], val, p, &p);\n}\n\nstatic inline mp_uint_t get_aligned_basic(uint val_type, void *p) {\n    switch (val_type) {\n        case UINT8:\n            return *(uint8_t *)p;\n        case UINT16:\n            return *(uint16_t *)p;\n        case UINT32:\n            return *(uint32_t *)p;\n    }\n    assert(0);\n    return 0;\n}\n\nstatic inline void set_aligned_basic(uint val_type, void *p, mp_uint_t v) {\n    switch (val_type) {\n        case UINT8:\n            *(uint8_t *)p = (uint8_t)v;\n            return;\n        case UINT16:\n            *(uint16_t *)p = (uint16_t)v;\n            return;\n        case UINT32:\n            *(uint32_t *)p = (uint32_t)v;\n            return;\n    }\n    assert(0);\n}\n\nstatic mp_obj_t get_aligned(uint val_type, void *p, mp_int_t index) {\n    switch (val_type) {\n        case UINT8:\n            return MP_OBJ_NEW_SMALL_INT(((uint8_t *)p)[index]);\n        case INT8:\n            return MP_OBJ_NEW_SMALL_INT(((int8_t *)p)[index]);\n        case UINT16:\n            return MP_OBJ_NEW_SMALL_INT(((uint16_t *)p)[index]);\n        case INT16:\n            return MP_OBJ_NEW_SMALL_INT(((int16_t *)p)[index]);\n        case UINT32:\n            return mp_obj_new_int_from_uint(((uint32_t *)p)[index]);\n        case INT32:\n            return mp_obj_new_int(((int32_t *)p)[index]);\n        case UINT64:\n            return mp_obj_new_int_from_ull(((uint64_t *)p)[index]);\n        case INT64:\n            return mp_obj_new_int_from_ll(((int64_t *)p)[index]);\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case FLOAT32:\n            return mp_obj_new_float_from_f(((float *)p)[index]);\n        case FLOAT64:\n            return mp_obj_new_float_from_d(((double *)p)[index]);\n        #endif\n        default:\n            assert(0);\n            return MP_OBJ_NULL;\n    }\n}\n\nstatic void set_aligned(uint val_type, void *p, mp_int_t index, mp_obj_t val) {\n    #if MICROPY_PY_BUILTINS_FLOAT\n    if (val_type == FLOAT32 || val_type == FLOAT64) {\n        if (val_type == FLOAT32) {\n            ((float *)p)[index] = mp_obj_get_float_to_f(val);\n        } else {\n            ((double *)p)[index] = mp_obj_get_float_to_d(val);\n        }\n        return;\n    }\n    #endif\n    mp_int_t v = mp_obj_get_int_truncated(val);\n    switch (val_type) {\n        case UINT8:\n            ((uint8_t *)p)[index] = (uint8_t)v;\n            return;\n        case INT8:\n            ((int8_t *)p)[index] = (int8_t)v;\n            return;\n        case UINT16:\n            ((uint16_t *)p)[index] = (uint16_t)v;\n            return;\n        case INT16:\n            ((int16_t *)p)[index] = (int16_t)v;\n            return;\n        case UINT32:\n            ((uint32_t *)p)[index] = (uint32_t)v;\n            return;\n        case INT32:\n            ((int32_t *)p)[index] = (int32_t)v;\n            return;\n        case INT64:\n        case UINT64:\n            if (sizeof(mp_int_t) == 8) {\n                ((uint64_t *)p)[index] = (uint64_t)v;\n            } else {\n                \n                set_unaligned(val_type, (void *)&((uint64_t *)p)[index], MP_ENDIANNESS_BIG, val);\n            }\n            return;\n        default:\n            assert(0);\n    }\n}\n\nstatic mp_obj_t uctypes_struct_attr_op(mp_obj_t self_in, qstr attr, mp_obj_t set_val) {\n    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (!mp_obj_is_dict_or_ordereddict(self->desc)) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"struct: no fields\"));\n    }\n\n    mp_obj_t deref = mp_obj_dict_get(self->desc, MP_OBJ_NEW_QSTR(attr));\n    if (mp_obj_is_small_int(deref)) {\n        mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(deref);\n        mp_uint_t val_type = GET_TYPE(offset, VAL_TYPE_BITS);\n        offset &= VALUE_MASK(VAL_TYPE_BITS);\n\n        if (val_type <= INT64 || val_type == FLOAT32 || val_type == FLOAT64) {\n            if (self->flags == LAYOUT_NATIVE) {\n                if (set_val == MP_OBJ_NULL) {\n                    return get_aligned(val_type, self->addr + offset, 0);\n                } else {\n                    set_aligned(val_type, self->addr + offset, 0, set_val);\n                    return set_val; \n                }\n            } else {\n                if (set_val == MP_OBJ_NULL) {\n                    return get_unaligned(val_type, self->addr + offset, self->flags);\n                } else {\n                    set_unaligned(val_type, self->addr + offset, self->flags, set_val);\n                    return set_val; \n                }\n            }\n        } else if (val_type >= BFUINT8 && val_type <= BFINT32) {\n            uint bit_offset = (offset >> OFFSET_BITS) & 31;\n            uint bit_len = (offset >> LEN_BITS) & 31;\n            offset &= (1 << OFFSET_BITS) - 1;\n            mp_uint_t val;\n            if (self->flags == LAYOUT_NATIVE) {\n                val = get_aligned_basic(val_type & 6, self->addr + offset);\n            } else {\n                val = mp_binary_get_int(GET_SCALAR_SIZE(val_type & 7), val_type & 1, self->flags, self->addr + offset);\n            }\n            if (set_val == MP_OBJ_NULL) {\n                val >>= bit_offset;\n                val &= (1 << bit_len) - 1;\n                \n                assert((val_type & 1) == 0);\n                return mp_obj_new_int(val);\n            } else {\n                mp_uint_t set_val_int = (mp_uint_t)mp_obj_get_int(set_val);\n                mp_uint_t mask = (1 << bit_len) - 1;\n                set_val_int &= mask;\n                set_val_int <<= bit_offset;\n                mask <<= bit_offset;\n                val = (val & ~mask) | set_val_int;\n\n                if (self->flags == LAYOUT_NATIVE) {\n                    set_aligned_basic(val_type & 6, self->addr + offset, val);\n                } else {\n                    mp_binary_set_int(GET_SCALAR_SIZE(val_type & 7), self->flags == LAYOUT_BIG_ENDIAN,\n                        self->addr + offset, val);\n                }\n                return set_val; \n            }\n        }\n\n        assert(0);\n        return MP_OBJ_NULL;\n    }\n\n    if (!mp_obj_is_type(deref, &mp_type_tuple)) {\n        syntax_error();\n    }\n\n    if (set_val != MP_OBJ_NULL) {\n        \n        syntax_error();\n    }\n\n    mp_obj_tuple_t *sub = MP_OBJ_TO_PTR(deref);\n    mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(sub->items[0]);\n    mp_uint_t agg_type = GET_TYPE(offset, AGG_TYPE_BITS);\n    offset &= VALUE_MASK(AGG_TYPE_BITS);\n\n    switch (agg_type) {\n        case STRUCT: {\n            mp_obj_uctypes_struct_t *o = mp_obj_malloc(mp_obj_uctypes_struct_t, &uctypes_struct_type);\n            o->desc = sub->items[1];\n            o->addr = self->addr + offset;\n            o->flags = self->flags;\n            return MP_OBJ_FROM_PTR(o);\n        }\n        case ARRAY: {\n            mp_uint_t dummy;\n            if (IS_SCALAR_ARRAY(sub) && IS_SCALAR_ARRAY_OF_BYTES(sub)) {\n                return mp_obj_new_bytearray_by_ref(uctypes_struct_agg_size(sub, self->flags, &dummy), self->addr + offset);\n            }\n            \n            MP_FALLTHROUGH\n        }\n        case PTR: {\n            mp_obj_uctypes_struct_t *o = mp_obj_malloc(mp_obj_uctypes_struct_t, &uctypes_struct_type);\n            o->desc = MP_OBJ_FROM_PTR(sub);\n            o->addr = self->addr + offset;\n            o->flags = self->flags;\n            return MP_OBJ_FROM_PTR(o);\n        }\n    }\n\n    \n    return MP_OBJ_NULL;\n}\n\nstatic void uctypes_struct_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        mp_obj_t val = uctypes_struct_attr_op(self_in, attr, MP_OBJ_NULL);\n        dest[0] = val;\n    } else {\n        \n        if (uctypes_struct_attr_op(self_in, attr, dest[1]) != MP_OBJ_NULL) {\n            dest[0] = MP_OBJ_NULL; \n        }\n    }\n}\n\nstatic mp_obj_t uctypes_struct_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value) {\n    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (value == MP_OBJ_NULL) {\n        \n        return MP_OBJ_NULL; \n    } else {\n        \n        if (!mp_obj_is_type(self->desc, &mp_type_tuple)) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"struct: can't index\"));\n        }\n\n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->desc);\n        mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);\n        uint agg_type = GET_TYPE(offset, AGG_TYPE_BITS);\n\n        mp_int_t index = MP_OBJ_SMALL_INT_VALUE(index_in);\n\n        if (agg_type == ARRAY) {\n            mp_int_t arr_sz = MP_OBJ_SMALL_INT_VALUE(t->items[1]);\n            uint val_type = GET_TYPE(arr_sz, VAL_TYPE_BITS);\n            arr_sz &= VALUE_MASK(VAL_TYPE_BITS);\n            if (index >= arr_sz) {\n                mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"struct: index out of range\"));\n            }\n\n            if (t->len == 2) {\n                \n                if (self->flags == LAYOUT_NATIVE) {\n                    if (value == MP_OBJ_SENTINEL) {\n                        return get_aligned(val_type, self->addr, index);\n                    } else {\n                        set_aligned(val_type, self->addr, index, value);\n                        return value; \n                    }\n                } else {\n                    byte *p = self->addr + uctypes_struct_scalar_size(val_type) * index;\n                    if (value == MP_OBJ_SENTINEL) {\n                        return get_unaligned(val_type, p, self->flags);\n                    } else {\n                        set_unaligned(val_type, p, self->flags, value);\n                        return value; \n                    }\n                }\n            } else if (value == MP_OBJ_SENTINEL) {\n                mp_uint_t dummy = 0;\n                mp_uint_t size = uctypes_struct_size(t->items[2], self->flags, &dummy);\n                mp_obj_uctypes_struct_t *o = mp_obj_malloc(mp_obj_uctypes_struct_t, &uctypes_struct_type);\n                o->desc = t->items[2];\n                o->addr = self->addr + size * index;\n                o->flags = self->flags;\n                return MP_OBJ_FROM_PTR(o);\n            } else {\n                return MP_OBJ_NULL; \n            }\n\n        } else if (agg_type == PTR) {\n            byte *p = *(void **)self->addr;\n            if (mp_obj_is_small_int(t->items[1])) {\n                uint val_type = GET_TYPE(MP_OBJ_SMALL_INT_VALUE(t->items[1]), VAL_TYPE_BITS);\n                return get_aligned(val_type, p, index);\n            } else {\n                mp_uint_t dummy = 0;\n                mp_uint_t size = uctypes_struct_size(t->items[1], self->flags, &dummy);\n                mp_obj_uctypes_struct_t *o = mp_obj_malloc(mp_obj_uctypes_struct_t, &uctypes_struct_type);\n                o->desc = t->items[1];\n                o->addr = p + size * index;\n                o->flags = self->flags;\n                return MP_OBJ_FROM_PTR(o);\n            }\n        }\n\n        assert(0);\n        return MP_OBJ_NULL;\n    }\n}\n\nstatic mp_obj_t uctypes_struct_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_INT_MAYBE:\n            if (mp_obj_is_type(self->desc, &mp_type_tuple)) {\n                mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->desc);\n                mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);\n                uint agg_type = GET_TYPE(offset, AGG_TYPE_BITS);\n                if (agg_type == PTR) {\n                    byte *p = *(void **)self->addr;\n                    return mp_obj_new_int((mp_int_t)(uintptr_t)p);\n                }\n            }\n            MP_FALLTHROUGH\n\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_int_t uctypes_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    (void)flags;\n    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_uint_t max_field_size = 0;\n    mp_uint_t size = uctypes_struct_size(self->desc, self->flags, &max_field_size);\n\n    bufinfo->buf = self->addr;\n    bufinfo->len = size;\n    bufinfo->typecode = BYTEARRAY_TYPECODE;\n    return 0;\n}\n\n\n\nstatic mp_obj_t uctypes_struct_addressof(mp_obj_t buf) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf, &bufinfo, MP_BUFFER_READ);\n    return mp_obj_new_int((mp_int_t)(uintptr_t)bufinfo.buf);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(uctypes_struct_addressof_obj, uctypes_struct_addressof);\n\n\n\nstatic mp_obj_t uctypes_struct_bytearray_at(mp_obj_t ptr, mp_obj_t size) {\n    return mp_obj_new_bytearray_by_ref(mp_obj_int_get_truncated(size), (void *)(uintptr_t)mp_obj_int_get_truncated(ptr));\n}\nMP_DEFINE_CONST_FUN_OBJ_2(uctypes_struct_bytearray_at_obj, uctypes_struct_bytearray_at);\n\n\n\nstatic mp_obj_t uctypes_struct_bytes_at(mp_obj_t ptr, mp_obj_t size) {\n    return mp_obj_new_bytes((void *)(uintptr_t)mp_obj_int_get_truncated(ptr), mp_obj_int_get_truncated(size));\n}\nMP_DEFINE_CONST_FUN_OBJ_2(uctypes_struct_bytes_at_obj, uctypes_struct_bytes_at);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    uctypes_struct_type,\n    MP_QSTR_struct,\n    MP_TYPE_FLAG_NONE,\n    make_new, uctypes_struct_make_new,\n    print, uctypes_struct_print,\n    attr, uctypes_struct_attr,\n    subscr, uctypes_struct_subscr,\n    unary_op, uctypes_struct_unary_op,\n    buffer, uctypes_get_buffer\n    );\n\nstatic const mp_rom_map_elem_t mp_module_uctypes_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uctypes) },\n    { MP_ROM_QSTR(MP_QSTR_struct), MP_ROM_PTR(&uctypes_struct_type) },\n    { MP_ROM_QSTR(MP_QSTR_sizeof), MP_ROM_PTR(&uctypes_struct_sizeof_obj) },\n    { MP_ROM_QSTR(MP_QSTR_addressof), MP_ROM_PTR(&uctypes_struct_addressof_obj) },\n    { MP_ROM_QSTR(MP_QSTR_bytes_at), MP_ROM_PTR(&uctypes_struct_bytes_at_obj) },\n    { MP_ROM_QSTR(MP_QSTR_bytearray_at), MP_ROM_PTR(&uctypes_struct_bytearray_at_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_NATIVE), MP_ROM_INT(LAYOUT_NATIVE) },\n    { MP_ROM_QSTR(MP_QSTR_LITTLE_ENDIAN), MP_ROM_INT(LAYOUT_LITTLE_ENDIAN) },\n    { MP_ROM_QSTR(MP_QSTR_BIG_ENDIAN), MP_ROM_INT(LAYOUT_BIG_ENDIAN) },\n\n    { MP_ROM_QSTR(MP_QSTR_VOID), MP_ROM_INT(TYPE2SMALLINT(UINT8, VAL_TYPE_BITS)) },\n\n    { MP_ROM_QSTR(MP_QSTR_UINT8), MP_ROM_INT(TYPE2SMALLINT(UINT8, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_INT8), MP_ROM_INT(TYPE2SMALLINT(INT8, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_UINT16), MP_ROM_INT(TYPE2SMALLINT(UINT16, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_INT16), MP_ROM_INT(TYPE2SMALLINT(INT16, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_UINT32), MP_ROM_INT(TYPE2SMALLINT(UINT32, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_INT32), MP_ROM_INT(TYPE2SMALLINT(INT32, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_UINT64), MP_ROM_INT(TYPE2SMALLINT(UINT64, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_INT64), MP_ROM_INT(TYPE2SMALLINT(INT64, VAL_TYPE_BITS)) },\n\n    { MP_ROM_QSTR(MP_QSTR_BFUINT8), MP_ROM_INT(TYPE2SMALLINT(BFUINT8, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_BFINT8), MP_ROM_INT(TYPE2SMALLINT(BFINT8, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_BFUINT16), MP_ROM_INT(TYPE2SMALLINT(BFUINT16, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_BFINT16), MP_ROM_INT(TYPE2SMALLINT(BFINT16, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_BFUINT32), MP_ROM_INT(TYPE2SMALLINT(BFUINT32, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_BFINT32), MP_ROM_INT(TYPE2SMALLINT(BFINT32, VAL_TYPE_BITS)) },\n\n    { MP_ROM_QSTR(MP_QSTR_BF_POS), MP_ROM_INT(OFFSET_BITS) },\n    { MP_ROM_QSTR(MP_QSTR_BF_LEN), MP_ROM_INT(LEN_BITS) },\n\n    #if MICROPY_PY_BUILTINS_FLOAT\n    { MP_ROM_QSTR(MP_QSTR_FLOAT32), MP_ROM_INT(TYPE2SMALLINT(FLOAT32, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_FLOAT64), MP_ROM_INT(TYPE2SMALLINT(FLOAT64, VAL_TYPE_BITS)) },\n    #endif\n\n    #if MICROPY_PY_UCTYPES_NATIVE_C_TYPES\n    \n    \n    #if __SIZEOF_SHORT__ == 2\n    { MP_ROM_QSTR(MP_QSTR_SHORT), MP_ROM_INT(TYPE2SMALLINT(INT16, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_USHORT), MP_ROM_INT(TYPE2SMALLINT(UINT16, VAL_TYPE_BITS)) },\n    #endif\n    #if __SIZEOF_INT__ == 4\n    { MP_ROM_QSTR(MP_QSTR_INT), MP_ROM_INT(TYPE2SMALLINT(INT32, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_UINT), MP_ROM_INT(TYPE2SMALLINT(UINT32, VAL_TYPE_BITS)) },\n    #endif\n    #if __SIZEOF_LONG__ == 4\n    { MP_ROM_QSTR(MP_QSTR_LONG), MP_ROM_INT(TYPE2SMALLINT(INT32, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_ULONG), MP_ROM_INT(TYPE2SMALLINT(UINT32, VAL_TYPE_BITS)) },\n    #elif __SIZEOF_LONG__ == 8\n    { MP_ROM_QSTR(MP_QSTR_LONG), MP_ROM_INT(TYPE2SMALLINT(INT64, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_ULONG), MP_ROM_INT(TYPE2SMALLINT(UINT64, VAL_TYPE_BITS)) },\n    #endif\n    #if __SIZEOF_LONG_LONG__ == 8\n    { MP_ROM_QSTR(MP_QSTR_LONGLONG), MP_ROM_INT(TYPE2SMALLINT(INT64, VAL_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_ULONGLONG), MP_ROM_INT(TYPE2SMALLINT(UINT64, VAL_TYPE_BITS)) },\n    #endif\n    #endif \n\n    { MP_ROM_QSTR(MP_QSTR_PTR), MP_ROM_INT(TYPE2SMALLINT(PTR, AGG_TYPE_BITS)) },\n    { MP_ROM_QSTR(MP_QSTR_ARRAY), MP_ROM_INT(TYPE2SMALLINT(ARRAY, AGG_TYPE_BITS)) },\n};\nstatic MP_DEFINE_CONST_DICT(mp_module_uctypes_globals, mp_module_uctypes_globals_table);\n\nconst mp_obj_module_t mp_module_uctypes = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_uctypes_globals,\n};\n\n\n\nMP_REGISTER_MODULE(MP_QSTR_uctypes, mp_module_uctypes);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}