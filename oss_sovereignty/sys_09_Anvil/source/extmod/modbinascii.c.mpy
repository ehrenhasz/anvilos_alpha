{
  "module_name": "modbinascii.c",
  "hash_id": "d26800100ad3648c77893e6742cd326082a1b265c98329b844522fa2bed87c37",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modbinascii.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n#include \"py/objstr.h\"\n\n#if MICROPY_PY_BINASCII\n\n#if MICROPY_PY_BUILTINS_BYTES_HEX\nstatic mp_obj_t bytes_hex_as_bytes(size_t n_args, const mp_obj_t *args) {\n    return mp_obj_bytes_hex(n_args, args, &mp_type_bytes);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bytes_hex_as_bytes_obj, 1, 2, bytes_hex_as_bytes);\n\nstatic mp_obj_t bytes_fromhex_bytes(mp_obj_t data) {\n    return mp_obj_bytes_fromhex(MP_OBJ_FROM_PTR(&mp_type_bytes), data);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(bytes_fromhex_obj, bytes_fromhex_bytes);\n#endif\n\n\n\n\nstatic int mod_binascii_sextet(byte ch) {\n    if (ch >= 'A' && ch <= 'Z') {\n        return ch - 'A';\n    } else if (ch >= 'a' && ch <= 'z') {\n        return ch - 'a' + 26;\n    } else if (ch >= '0' && ch <= '9') {\n        return ch - '0' + 52;\n    } else if (ch == '+') {\n        return 62;\n    } else if (ch == '/') {\n        return 63;\n    } else {\n        return -1;\n    }\n}\n\nstatic mp_obj_t mod_binascii_a2b_base64(mp_obj_t data) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(data, &bufinfo, MP_BUFFER_READ);\n    byte *in = bufinfo.buf;\n\n    vstr_t vstr;\n    vstr_init(&vstr, (bufinfo.len * 3) / 4 + 1); \n    byte *out = (byte *)vstr.buf;\n\n    uint shift = 0;\n    int nbits = 0; \n    bool hadpad = false; \n    for (size_t i = 0; i < bufinfo.len; i++) {\n        if (in[i] == '=') {\n            if ((nbits == 2) || ((nbits == 4) && hadpad)) {\n                nbits = 0;\n                break;\n            }\n            hadpad = true;\n        }\n\n        int sextet = mod_binascii_sextet(in[i]);\n        if (sextet == -1) {\n            continue;\n        }\n        hadpad = false;\n        shift = (shift << 6) | sextet;\n        nbits += 6;\n\n        if (nbits >= 8) {\n            nbits -= 8;\n            out[vstr.len++] = (shift >> nbits) & 0xFF;\n        }\n    }\n\n    if (nbits) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"incorrect padding\"));\n    }\n\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_binascii_a2b_base64_obj, mod_binascii_a2b_base64);\n\nstatic mp_obj_t mod_binascii_b2a_base64(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_newline };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_newline, MP_ARG_BOOL, {.u_bool = true} },\n    };\n\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n    uint8_t newline = args[ARG_newline].u_bool;\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(pos_args[0], &bufinfo, MP_BUFFER_READ);\n\n    vstr_t vstr;\n    vstr_init_len(&vstr, ((bufinfo.len != 0) ? (((bufinfo.len - 1) / 3) + 1) * 4 : 0) + newline);\n\n    \n    byte *in = bufinfo.buf, *out = (byte *)vstr.buf;\n    mp_uint_t i;\n    for (i = bufinfo.len; i >= 3; i -= 3) {\n        *out++ = (in[0] & 0xFC) >> 2;\n        *out++ = (in[0] & 0x03) << 4 | (in[1] & 0xF0) >> 4;\n        *out++ = (in[1] & 0x0F) << 2 | (in[2] & 0xC0) >> 6;\n        *out++ = in[2] & 0x3F;\n        in += 3;\n    }\n    if (i != 0) {\n        *out++ = (in[0] & 0xFC) >> 2;\n        if (i == 2) {\n            *out++ = (in[0] & 0x03) << 4 | (in[1] & 0xF0) >> 4;\n            *out++ = (in[1] & 0x0F) << 2;\n        } else {\n            *out++ = (in[0] & 0x03) << 4;\n            *out++ = 64;\n        }\n        *out = 64;\n    }\n\n    \n    out = (byte *)vstr.buf;\n    for (mp_uint_t j = vstr.len - newline; j--;) {\n        if (*out < 26) {\n            *out += 'A';\n        } else if (*out < 52) {\n            *out += 'a' - 26;\n        } else if (*out < 62) {\n            *out += '0' - 52;\n        } else if (*out == 62) {\n            *out = '+';\n        } else if (*out == 63) {\n            *out = '/';\n        } else {\n            *out = '=';\n        }\n        out++;\n    }\n    if (newline) {\n        *out = '\\n';\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(mod_binascii_b2a_base64_obj, 1, mod_binascii_b2a_base64);\n\n#if MICROPY_PY_BINASCII_CRC32 && MICROPY_PY_DEFLATE\n#include \"lib/uzlib/uzlib.h\"\n\nstatic mp_obj_t mod_binascii_crc32(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[0], &bufinfo, MP_BUFFER_READ);\n    uint32_t crc = (n_args > 1) ? mp_obj_get_int_truncated(args[1]) : 0;\n    crc = uzlib_crc32(bufinfo.buf, bufinfo.len, crc ^ 0xffffffff);\n    return mp_obj_new_int_from_uint(crc ^ 0xffffffff);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_binascii_crc32_obj, 1, 2, mod_binascii_crc32);\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_binascii_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_binascii) },\n    #if MICROPY_PY_BUILTINS_BYTES_HEX\n    { MP_ROM_QSTR(MP_QSTR_hexlify), MP_ROM_PTR(&bytes_hex_as_bytes_obj) },\n    { MP_ROM_QSTR(MP_QSTR_unhexlify), MP_ROM_PTR(&bytes_fromhex_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_a2b_base64), MP_ROM_PTR(&mod_binascii_a2b_base64_obj) },\n    { MP_ROM_QSTR(MP_QSTR_b2a_base64), MP_ROM_PTR(&mod_binascii_b2a_base64_obj) },\n    #if MICROPY_PY_BINASCII_CRC32 && MICROPY_PY_DEFLATE\n    { MP_ROM_QSTR(MP_QSTR_crc32), MP_ROM_PTR(&mod_binascii_crc32_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_binascii_globals, mp_module_binascii_globals_table);\n\nconst mp_obj_module_t mp_module_binascii = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_binascii_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_binascii, mp_module_binascii);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}