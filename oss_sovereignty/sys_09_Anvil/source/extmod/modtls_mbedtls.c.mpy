{
  "module_name": "modtls_mbedtls.c",
  "hash_id": "94150bcf26aa51141774e1cd454725d0c37b0ac9990a57a5f1b8acef26de4bd5",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modtls_mbedtls.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n#if MICROPY_PY_SSL && MICROPY_SSL_MBEDTLS\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h> \n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/objstr.h\"\n#include \"py/reader.h\"\n#include \"extmod/vfs.h\"\n\n\n#include \"mbedtls/platform.h\"\n#include \"mbedtls/ssl.h\"\n#include \"mbedtls/x509_crt.h\"\n#include \"mbedtls/pk.h\"\n#include \"mbedtls/entropy.h\"\n#include \"mbedtls/ctr_drbg.h\"\n#include \"mbedtls/debug.h\"\n#include \"mbedtls/error.h\"\n#if MBEDTLS_VERSION_NUMBER >= 0x03000000\n#include \"mbedtls/build_info.h\"\n#else\n#include \"mbedtls/version.h\"\n#endif\n\n#define MP_STREAM_POLL_RDWR (MP_STREAM_POLL_RD | MP_STREAM_POLL_WR)\n\n\ntypedef struct _mp_obj_ssl_context_t {\n    mp_obj_base_t base;\n    mbedtls_entropy_context entropy;\n    mbedtls_ctr_drbg_context ctr_drbg;\n    mbedtls_ssl_config conf;\n    mbedtls_x509_crt cacert;\n    mbedtls_x509_crt cert;\n    mbedtls_pk_context pkey;\n    int authmode;\n    int *ciphersuites;\n    mp_obj_t handler;\n} mp_obj_ssl_context_t;\n\n\ntypedef struct _mp_obj_ssl_socket_t {\n    mp_obj_base_t base;\n    mp_obj_ssl_context_t *ssl_context;\n    mp_obj_t sock;\n    mbedtls_ssl_context ssl;\n\n    uintptr_t poll_mask; \n    int last_error; \n} mp_obj_ssl_socket_t;\n\nstatic const mp_obj_type_t ssl_context_type;\nstatic const mp_obj_type_t ssl_socket_type;\n\nstatic const MP_DEFINE_STR_OBJ(mbedtls_version_obj, MBEDTLS_VERSION_STRING_FULL);\n\nstatic mp_obj_t ssl_socket_make_new(mp_obj_ssl_context_t *ssl_context, mp_obj_t sock,\n    bool server_side, bool do_handshake_on_connect, mp_obj_t server_hostname);\n\n \n\n\n#ifdef MBEDTLS_DEBUG_C\nstatic void mbedtls_debug(void *ctx, int level, const char *file, int line, const char *str) {\n    (void)ctx;\n    (void)level;\n    mp_printf(&mp_plat_print, \"DBG:%s:%04d: %s\\n\", file, line, str);\n}\n#endif\n\nstatic NORETURN void mbedtls_raise_error(int err) {\n    \n    if (err == MBEDTLS_ERR_SSL_ALLOC_FAILED) {\n        mp_raise_OSError(MP_ENOMEM);\n    } else if (err == MBEDTLS_ERR_PK_BAD_INPUT_DATA) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid key\"));\n    } else if (err == MBEDTLS_ERR_X509_BAD_INPUT_DATA) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid cert\"));\n    }\n\n    \n    \n    \n    \n    if (err < 0 && err > -256) {\n        mp_raise_OSError(-err);\n    }\n\n    #if defined(MBEDTLS_ERROR_C)\n    \n    \n    \n\n    \n    #define ERR_STR_MAX 80  \n    mp_obj_str_t *o_str = m_new_obj_maybe(mp_obj_str_t);\n    byte *o_str_buf = m_new_maybe(byte, ERR_STR_MAX);\n    if (o_str == NULL || o_str_buf == NULL) {\n        mp_raise_OSError(err);\n    }\n\n    \n    mbedtls_strerror(err, (char *)o_str_buf, ERR_STR_MAX);\n    size_t len = strlen((char *)o_str_buf);\n\n    \n    o_str->base.type = &mp_type_str;\n    o_str->data = o_str_buf;\n    o_str->len = len;\n    o_str->hash = qstr_compute_hash(o_str->data, o_str->len);\n    \n    mp_obj_t args[2] = { MP_OBJ_NEW_SMALL_INT(err), MP_OBJ_FROM_PTR(o_str)};\n    nlr_raise(mp_obj_exception_make_new(&mp_type_OSError, 2, 0, args));\n    #else\n    \n    mp_raise_OSError(err); \n    #endif\n}\n\nstatic void ssl_check_async_handshake_failure(mp_obj_ssl_socket_t *sslsock, int *errcode) {\n    if (\n        #if MBEDTLS_VERSION_NUMBER >= 0x03000000\n        (*errcode < 0) && (mbedtls_ssl_is_handshake_over(&sslsock->ssl) == 0) && (*errcode != MBEDTLS_ERR_SSL_CONN_EOF)\n        #else\n        (*errcode < 0) && (*errcode != MBEDTLS_ERR_SSL_CONN_EOF)\n        #endif\n        ) {\n        \n        \n        \n\n        if (*errcode == MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) {\n            \n            \n            \n            mbedtls_ssl_send_alert_message(&sslsock->ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE);\n        }\n\n        if (*errcode == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {\n            \n            char xcbuf[256];\n            uint32_t flags = mbedtls_ssl_get_verify_result(&sslsock->ssl);\n            int ret = mbedtls_x509_crt_verify_info(xcbuf, sizeof(xcbuf), \"\\n\", flags);\n            \n            \n            if (ret > 0) {\n                sslsock->sock = MP_OBJ_NULL;\n                mbedtls_ssl_free(&sslsock->ssl);\n                mp_raise_msg_varg(&mp_type_ValueError, MP_ERROR_TEXT(\"%s\"), xcbuf);\n            }\n        }\n\n        sslsock->sock = MP_OBJ_NULL;\n        mbedtls_ssl_free(&sslsock->ssl);\n        mbedtls_raise_error(*errcode);\n    }\n}\n\nstatic int ssl_sock_cert_verify(void *ptr, mbedtls_x509_crt *crt, int depth, uint32_t *flags) {\n    mp_obj_ssl_context_t *o = ptr;\n    if (o->handler == mp_const_none) {\n        return 0;\n    }\n    mp_obj_array_t cert;\n    mp_obj_memoryview_init(&cert, 'B', 0, crt->raw.len, crt->raw.p);\n    return mp_obj_get_int(mp_call_function_2(o->handler, MP_OBJ_FROM_PTR(&cert), MP_OBJ_NEW_SMALL_INT(depth)));\n}\n\n \n\n\nstatic mp_obj_t ssl_context_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 1, 1, false);\n\n    \n    mp_int_t endpoint = mp_obj_get_int(args[0]);\n\n    \n    #if MICROPY_PY_SSL_FINALISER\n    mp_obj_ssl_context_t *self = mp_obj_malloc_with_finaliser(mp_obj_ssl_context_t, type_in);\n    #else\n    mp_obj_ssl_context_t *self = mp_obj_malloc(mp_obj_ssl_context_t, type_in);\n    #endif\n\n    \n    mbedtls_ssl_config_init(&self->conf);\n    mbedtls_entropy_init(&self->entropy);\n    mbedtls_ctr_drbg_init(&self->ctr_drbg);\n    mbedtls_x509_crt_init(&self->cacert);\n    mbedtls_x509_crt_init(&self->cert);\n    mbedtls_pk_init(&self->pkey);\n    self->ciphersuites = NULL;\n    self->handler = mp_const_none;\n\n    #ifdef MBEDTLS_DEBUG_C\n    \n    mbedtls_debug_set_threshold(3);\n    #endif\n\n    \n    \n    #if defined(MBEDTLS_SSL_PROTO_TLS1_3) || defined(MBEDTLS_USE_PSA_CRYPTO)\n    psa_crypto_init();\n    #endif\n\n    const byte seed[] = \"upy\";\n    int ret = mbedtls_ctr_drbg_seed(&self->ctr_drbg, mbedtls_entropy_func, &self->entropy, seed, sizeof(seed));\n    if (ret != 0) {\n        mbedtls_raise_error(ret);\n    }\n\n    ret = mbedtls_ssl_config_defaults(&self->conf, endpoint,\n        MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);\n    if (ret != 0) {\n        mbedtls_raise_error(ret);\n    }\n\n    if (endpoint == MBEDTLS_SSL_IS_CLIENT) {\n        self->authmode = MBEDTLS_SSL_VERIFY_REQUIRED;\n    } else {\n        self->authmode = MBEDTLS_SSL_VERIFY_NONE;\n    }\n    mbedtls_ssl_conf_authmode(&self->conf, self->authmode);\n    mbedtls_ssl_conf_verify(&self->conf, &ssl_sock_cert_verify, self);\n    mbedtls_ssl_conf_rng(&self->conf, mbedtls_ctr_drbg_random, &self->ctr_drbg);\n    #ifdef MBEDTLS_DEBUG_C\n    mbedtls_ssl_conf_dbg(&self->conf, mbedtls_debug, NULL);\n    #endif\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic void ssl_context_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    mp_obj_ssl_context_t *self = MP_OBJ_TO_PTR(self_in);\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR_verify_mode) {\n            dest[0] = MP_OBJ_NEW_SMALL_INT(self->authmode);\n        } else if (attr == MP_QSTR_verify_callback) {\n            dest[0] = self->handler;\n        } else {\n            \n            dest[1] = MP_OBJ_SENTINEL;\n        }\n    } else if (dest[1] != MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR_verify_mode) {\n            self->authmode = mp_obj_get_int(dest[1]);\n            dest[0] = MP_OBJ_NULL;\n            mbedtls_ssl_conf_authmode(&self->conf, self->authmode);\n        } else if (attr == MP_QSTR_verify_callback) {\n            dest[0] = MP_OBJ_NULL;\n            self->handler = dest[1];\n        }\n    }\n}\n\n#if MICROPY_PY_SSL_FINALISER\nstatic mp_obj_t ssl_context___del__(mp_obj_t self_in) {\n    mp_obj_ssl_context_t *self = MP_OBJ_TO_PTR(self_in);\n    mbedtls_pk_free(&self->pkey);\n    mbedtls_x509_crt_free(&self->cert);\n    mbedtls_x509_crt_free(&self->cacert);\n    mbedtls_ctr_drbg_free(&self->ctr_drbg);\n    mbedtls_entropy_free(&self->entropy);\n    mbedtls_ssl_config_free(&self->conf);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(ssl_context___del___obj, ssl_context___del__);\n#endif\n\n\nstatic mp_obj_t ssl_context_get_ciphers(mp_obj_t self_in) {\n    mp_obj_t list = mp_obj_new_list(0, NULL);\n    for (const int *cipher_list = mbedtls_ssl_list_ciphersuites(); *cipher_list; ++cipher_list) {\n        const char *cipher_name = mbedtls_ssl_get_ciphersuite_name(*cipher_list);\n        mp_obj_list_append(list, MP_OBJ_FROM_PTR(mp_obj_new_str(cipher_name, strlen(cipher_name))));\n    }\n    return list;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(ssl_context_get_ciphers_obj, ssl_context_get_ciphers);\n\n\nstatic mp_obj_t ssl_context_set_ciphers(mp_obj_t self_in, mp_obj_t ciphersuite) {\n    mp_obj_ssl_context_t *ssl_context = MP_OBJ_TO_PTR(self_in);\n\n    \n    size_t len = 0;\n    mp_obj_t *ciphers;\n    mp_obj_get_array(ciphersuite, &len, &ciphers);\n    if (len == 0) {\n        mbedtls_raise_error(MBEDTLS_ERR_SSL_BAD_CONFIG);\n    }\n\n    \n    ssl_context->ciphersuites = m_new(int, len + 1);\n    for (size_t i = 0; i < len; ++i) {\n        const char *ciphername = mp_obj_str_get_str(ciphers[i]);\n        const int id = mbedtls_ssl_get_ciphersuite_id(ciphername);\n        if (id == 0) {\n            mbedtls_raise_error(MBEDTLS_ERR_SSL_BAD_CONFIG);\n        }\n        ssl_context->ciphersuites[i] = id;\n    }\n    ssl_context->ciphersuites[len] = 0;\n\n    \n    mbedtls_ssl_conf_ciphersuites(&ssl_context->conf, (const int *)ssl_context->ciphersuites);\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(ssl_context_set_ciphers_obj, ssl_context_set_ciphers);\n\nstatic void ssl_context_load_key(mp_obj_ssl_context_t *self, mp_obj_t key_obj, mp_obj_t cert_obj) {\n    size_t key_len;\n    const byte *key = (const byte *)mp_obj_str_get_data(key_obj, &key_len);\n    \n    int ret;\n    #if MBEDTLS_VERSION_NUMBER >= 0x03000000\n    ret = mbedtls_pk_parse_key(&self->pkey, key, key_len + 1, NULL, 0, mbedtls_ctr_drbg_random, &self->ctr_drbg);\n    #else\n    ret = mbedtls_pk_parse_key(&self->pkey, key, key_len + 1, NULL, 0);\n    #endif\n    if (ret != 0) {\n        mbedtls_raise_error(MBEDTLS_ERR_PK_BAD_INPUT_DATA); \n    }\n\n    size_t cert_len;\n    const byte *cert = (const byte *)mp_obj_str_get_data(cert_obj, &cert_len);\n    \n    ret = mbedtls_x509_crt_parse(&self->cert, cert, cert_len + 1);\n    if (ret != 0) {\n        mbedtls_raise_error(MBEDTLS_ERR_X509_BAD_INPUT_DATA); \n    }\n\n    ret = mbedtls_ssl_conf_own_cert(&self->conf, &self->cert, &self->pkey);\n    if (ret != 0) {\n        mbedtls_raise_error(ret);\n    }\n}\n\n\nstatic mp_obj_t ssl_context_load_cert_chain(mp_obj_t self_in, mp_obj_t cert, mp_obj_t pkey) {\n    mp_obj_ssl_context_t *self = MP_OBJ_TO_PTR(self_in);\n    ssl_context_load_key(self, pkey, cert);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(ssl_context_load_cert_chain_obj, ssl_context_load_cert_chain);\n\nstatic void ssl_context_load_cadata(mp_obj_ssl_context_t *self, mp_obj_t cadata_obj) {\n    size_t cacert_len;\n    const byte *cacert = (const byte *)mp_obj_str_get_data(cadata_obj, &cacert_len);\n    \n    int ret = mbedtls_x509_crt_parse(&self->cacert, cacert, cacert_len + 1);\n    if (ret != 0) {\n        mbedtls_raise_error(MBEDTLS_ERR_X509_BAD_INPUT_DATA); \n    }\n\n    mbedtls_ssl_conf_ca_chain(&self->conf, &self->cacert, NULL);\n}\n\n\nstatic mp_obj_t ssl_context_load_verify_locations(mp_obj_t self_in, mp_obj_t cadata) {\n\n    mp_obj_ssl_context_t *self = MP_OBJ_TO_PTR(self_in);\n    ssl_context_load_cadata(self, cadata);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(ssl_context_load_verify_locations_obj, ssl_context_load_verify_locations);\n\nstatic mp_obj_t ssl_context_wrap_socket(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_server_side, ARG_do_handshake_on_connect, ARG_server_hostname };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_server_side, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },\n        { MP_QSTR_do_handshake_on_connect, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = true} },\n        { MP_QSTR_server_hostname, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n    };\n\n    \n    mp_obj_ssl_context_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n    mp_obj_t sock = pos_args[1];\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 2, pos_args + 2, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    return ssl_socket_make_new(self, sock, args[ARG_server_side].u_bool,\n        args[ARG_do_handshake_on_connect].u_bool, args[ARG_server_hostname].u_obj);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(ssl_context_wrap_socket_obj, 2, ssl_context_wrap_socket);\n\nstatic const mp_rom_map_elem_t ssl_context_locals_dict_table[] = {\n    #if MICROPY_PY_SSL_FINALISER\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&ssl_context___del___obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_get_ciphers), MP_ROM_PTR(&ssl_context_get_ciphers_obj)},\n    { MP_ROM_QSTR(MP_QSTR_set_ciphers), MP_ROM_PTR(&ssl_context_set_ciphers_obj)},\n    { MP_ROM_QSTR(MP_QSTR_load_cert_chain), MP_ROM_PTR(&ssl_context_load_cert_chain_obj)},\n    { MP_ROM_QSTR(MP_QSTR_load_verify_locations), MP_ROM_PTR(&ssl_context_load_verify_locations_obj)},\n    { MP_ROM_QSTR(MP_QSTR_wrap_socket), MP_ROM_PTR(&ssl_context_wrap_socket_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(ssl_context_locals_dict, ssl_context_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    ssl_context_type,\n    MP_QSTR_SSLContext,\n    MP_TYPE_FLAG_NONE,\n    make_new, ssl_context_make_new,\n    attr, ssl_context_attr,\n    locals_dict, &ssl_context_locals_dict\n    );\n\n \n\n\nstatic int _mbedtls_ssl_send(void *ctx, const byte *buf, size_t len) {\n    mp_obj_t sock = *(mp_obj_t *)ctx;\n\n    const mp_stream_p_t *sock_stream = mp_get_stream(sock);\n    int err;\n\n    mp_uint_t out_sz = sock_stream->write(sock, buf, len, &err);\n    if (out_sz == MP_STREAM_ERROR) {\n        if (mp_is_nonblocking_error(err)) {\n            return MBEDTLS_ERR_SSL_WANT_WRITE;\n        }\n        return -err; \n    } else {\n        return out_sz;\n    }\n}\n\n\nstatic int _mbedtls_ssl_recv(void *ctx, byte *buf, size_t len) {\n    mp_obj_t sock = *(mp_obj_t *)ctx;\n\n    const mp_stream_p_t *sock_stream = mp_get_stream(sock);\n    int err;\n\n    mp_uint_t out_sz = sock_stream->read(sock, buf, len, &err);\n    if (out_sz == MP_STREAM_ERROR) {\n        if (mp_is_nonblocking_error(err)) {\n            return MBEDTLS_ERR_SSL_WANT_READ;\n        }\n        return -err;\n    } else {\n        return out_sz;\n    }\n}\n\nstatic mp_obj_t ssl_socket_make_new(mp_obj_ssl_context_t *ssl_context, mp_obj_t sock,\n    bool server_side, bool do_handshake_on_connect, mp_obj_t server_hostname) {\n\n    \n    mp_get_stream_raise(sock, MP_STREAM_OP_READ | MP_STREAM_OP_WRITE | MP_STREAM_OP_IOCTL);\n\n    #if MICROPY_PY_SSL_FINALISER\n    mp_obj_ssl_socket_t *o = mp_obj_malloc_with_finaliser(mp_obj_ssl_socket_t, &ssl_socket_type);\n    #else\n    mp_obj_ssl_socket_t *o = mp_obj_malloc(mp_obj_ssl_socket_t, &ssl_socket_type);\n    #endif\n    o->ssl_context = ssl_context;\n    o->sock = sock;\n    o->poll_mask = 0;\n    o->last_error = 0;\n\n    int ret;\n    uint32_t flags = 0;\n\n    mbedtls_ssl_init(&o->ssl);\n\n    ret = mbedtls_ssl_setup(&o->ssl, &ssl_context->conf);\n    if (ret != 0) {\n        goto cleanup;\n    }\n\n    if (server_hostname != mp_const_none) {\n        const char *sni = mp_obj_str_get_str(server_hostname);\n        ret = mbedtls_ssl_set_hostname(&o->ssl, sni);\n        if (ret != 0) {\n            goto cleanup;\n        }\n    } else if (ssl_context->authmode == MBEDTLS_SSL_VERIFY_REQUIRED && server_side == false) {\n\n        o->sock = MP_OBJ_NULL;\n        mbedtls_ssl_free(&o->ssl);\n        mp_raise_ValueError(MP_ERROR_TEXT(\"CERT_REQUIRED requires server_hostname\"));\n    }\n\n    mbedtls_ssl_set_bio(&o->ssl, &o->sock, _mbedtls_ssl_send, _mbedtls_ssl_recv, NULL);\n\n    if (do_handshake_on_connect) {\n        while ((ret = mbedtls_ssl_handshake(&o->ssl)) != 0) {\n            if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n                goto cleanup;\n            }\n            mp_event_wait_ms(1);\n        }\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n\ncleanup:\n    if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {\n        flags = mbedtls_ssl_get_verify_result(&o->ssl);\n    }\n\n    o->sock = MP_OBJ_NULL;\n    mbedtls_ssl_free(&o->ssl);\n\n    if (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {\n        char xcbuf[256];\n        int ret_info = mbedtls_x509_crt_verify_info(xcbuf, sizeof(xcbuf), \"\\n\", flags);\n        \n        \n        if (ret_info > 0) {\n            mp_raise_msg_varg(&mp_type_ValueError, MP_ERROR_TEXT(\"%s\"), xcbuf);\n        }\n    }\n\n    mbedtls_raise_error(ret);\n}\n\n#if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)\nstatic mp_obj_t mod_ssl_getpeercert(mp_obj_t o_in, mp_obj_t binary_form) {\n    mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(o_in);\n    if (!mp_obj_is_true(binary_form)) {\n        mp_raise_NotImplementedError(NULL);\n    }\n    const mbedtls_x509_crt *peer_cert = mbedtls_ssl_get_peer_cert(&o->ssl);\n    if (peer_cert == NULL) {\n        return mp_const_none;\n    }\n    return mp_obj_new_bytes(peer_cert->raw.p, peer_cert->raw.len);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mod_ssl_getpeercert_obj, mod_ssl_getpeercert);\n#endif\n\nstatic mp_obj_t mod_ssl_cipher(mp_obj_t o_in) {\n    mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(o_in);\n    const char *cipher_suite = mbedtls_ssl_get_ciphersuite(&o->ssl);\n    const char *tls_version = mbedtls_ssl_get_version(&o->ssl);\n    mp_obj_t tuple[2] = {mp_obj_new_str(cipher_suite, strlen(cipher_suite)),\n                         mp_obj_new_str(tls_version, strlen(tls_version))};\n\n    return mp_obj_new_tuple(2, tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_ssl_cipher_obj, mod_ssl_cipher);\n\nstatic mp_uint_t socket_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(o_in);\n    o->poll_mask = 0;\n\n    if (o->last_error) {\n        *errcode = o->last_error;\n        return MP_STREAM_ERROR;\n    }\n\n    int ret = mbedtls_ssl_read(&o->ssl, buf, size);\n    if (ret == MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) {\n        \n        return 0;\n    }\n    if (ret >= 0) {\n        return ret;\n    }\n    if (ret == MBEDTLS_ERR_SSL_WANT_READ) {\n        ret = MP_EWOULDBLOCK;\n    } else if (ret == MBEDTLS_ERR_SSL_WANT_WRITE) {\n        \n        \n        \n        ret = MP_EWOULDBLOCK;\n        o->poll_mask = MP_STREAM_POLL_WR;\n    #if defined(MBEDTLS_SSL_PROTO_TLS1_3)\n    } else if (ret == MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET) {\n        \n        \n        \n        \n        ret = MP_EWOULDBLOCK;\n    #endif\n    } else {\n        o->last_error = ret;\n    }\n    ssl_check_async_handshake_failure(o, &ret);\n    *errcode = ret;\n    return MP_STREAM_ERROR;\n}\n\nstatic mp_uint_t socket_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(o_in);\n    o->poll_mask = 0;\n\n    if (o->last_error) {\n        *errcode = o->last_error;\n        return MP_STREAM_ERROR;\n    }\n\n    int ret = mbedtls_ssl_write(&o->ssl, buf, size);\n    if (ret >= 0) {\n        return ret;\n    }\n    if (ret == MBEDTLS_ERR_SSL_WANT_WRITE) {\n        ret = MP_EWOULDBLOCK;\n    } else if (ret == MBEDTLS_ERR_SSL_WANT_READ) {\n        \n        \n        \n        ret = MP_EWOULDBLOCK;\n        o->poll_mask = MP_STREAM_POLL_RD;\n    } else {\n        o->last_error = ret;\n    }\n    ssl_check_async_handshake_failure(o, &ret);\n    *errcode = ret;\n    return MP_STREAM_ERROR;\n}\n\nstatic mp_obj_t socket_setblocking(mp_obj_t self_in, mp_obj_t flag_in) {\n    mp_obj_ssl_socket_t *o = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t sock = o->sock;\n    mp_obj_t dest[3];\n    mp_load_method(sock, MP_QSTR_setblocking, dest);\n    dest[2] = flag_in;\n    return mp_call_method_n_kw(1, 0, dest);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_setblocking_obj, socket_setblocking);\n\nstatic mp_uint_t socket_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mp_obj_ssl_socket_t *self = MP_OBJ_TO_PTR(o_in);\n    mp_uint_t ret = 0;\n    uintptr_t saved_arg = 0;\n    mp_obj_t sock = self->sock;\n\n    if (request == MP_STREAM_CLOSE) {\n        if (sock == MP_OBJ_NULL) {\n            \n            return 0;\n        }\n        self->sock = MP_OBJ_NULL;\n        mbedtls_ssl_free(&self->ssl);\n    } else if (request == MP_STREAM_POLL) {\n        if (sock == MP_OBJ_NULL || self->last_error != 0) {\n            \n            return MP_STREAM_POLL_NVAL;\n        }\n\n        \n        \n        if (self->poll_mask && (arg & MP_STREAM_POLL_RDWR)) {\n            saved_arg = arg & MP_STREAM_POLL_RDWR;\n            arg = (arg & ~saved_arg) | self->poll_mask;\n        }\n\n        \n        int has_pending = 0;\n        if (arg & MP_STREAM_POLL_RD) {\n            has_pending = mbedtls_ssl_check_pending(&self->ssl);\n            if (has_pending) {\n                ret |= MP_STREAM_POLL_RD;\n                if (arg == MP_STREAM_POLL_RD) {\n                    \n                    return MP_STREAM_POLL_RD;\n                }\n            }\n        }\n    } else {\n        \n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n\n    \n    ret |= mp_get_stream(sock)->ioctl(sock, request, arg, errcode);\n\n    if (request == MP_STREAM_POLL) {\n        \n        \n        if (ret & self->poll_mask) {\n            ret |= saved_arg;\n        }\n    }\n    return ret;\n}\n\nstatic const mp_rom_map_elem_t ssl_socket_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setblocking), MP_ROM_PTR(&socket_setblocking_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    #if MICROPY_PY_SSL_FINALISER\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&mp_stream_close_obj) },\n    #endif\n    #if MICROPY_UNIX_COVERAGE\n    { MP_ROM_QSTR(MP_QSTR_ioctl), MP_ROM_PTR(&mp_stream_ioctl_obj) },\n    #endif\n    #if defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)\n    { MP_ROM_QSTR(MP_QSTR_getpeercert), MP_ROM_PTR(&mod_ssl_getpeercert_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_cipher), MP_ROM_PTR(&mod_ssl_cipher_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(ssl_socket_locals_dict, ssl_socket_locals_dict_table);\n\nstatic const mp_stream_p_t ssl_socket_stream_p = {\n    .read = socket_read,\n    .write = socket_write,\n    .ioctl = socket_ioctl,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    ssl_socket_type,\n    MP_QSTR_SSLSocket,\n    MP_TYPE_FLAG_NONE,\n    protocol, &ssl_socket_stream_p,\n    locals_dict, &ssl_socket_locals_dict\n    );\n\n \n\n\nstatic const mp_rom_map_elem_t mp_module_tls_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_tls) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_SSLContext), MP_ROM_PTR(&ssl_context_type) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_MBEDTLS_VERSION), MP_ROM_PTR(&mbedtls_version_obj)},\n    { MP_ROM_QSTR(MP_QSTR_PROTOCOL_TLS_CLIENT), MP_ROM_INT(MBEDTLS_SSL_IS_CLIENT) },\n    { MP_ROM_QSTR(MP_QSTR_PROTOCOL_TLS_SERVER), MP_ROM_INT(MBEDTLS_SSL_IS_SERVER) },\n    { MP_ROM_QSTR(MP_QSTR_CERT_NONE), MP_ROM_INT(MBEDTLS_SSL_VERIFY_NONE) },\n    { MP_ROM_QSTR(MP_QSTR_CERT_OPTIONAL), MP_ROM_INT(MBEDTLS_SSL_VERIFY_OPTIONAL) },\n    { MP_ROM_QSTR(MP_QSTR_CERT_REQUIRED), MP_ROM_INT(MBEDTLS_SSL_VERIFY_REQUIRED) },\n};\nstatic MP_DEFINE_CONST_DICT(mp_module_tls_globals, mp_module_tls_globals_table);\n\nconst mp_obj_module_t mp_module_tls = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_tls_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_tls, mp_module_tls);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}