{
  "module_name": "modsocket.c",
  "hash_id": "5e1178d9fd7981e8645572e25521e41fd6d577b37a48c6e7d5feb7e0d58467f2",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modsocket.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/objtuple.h\"\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_PY_NETWORK && MICROPY_PY_SOCKET && !MICROPY_PY_LWIP\n\n#include \"shared/netutils/netutils.h\"\n#include \"modnetwork.h\"\n\n \n\n\nstatic const mp_obj_type_t socket_type;\n\nstatic void socket_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<socket fd=%d timeout=%d domain=%d type=%d proto=%d bound=%b>\",\n        self->fileno, self->timeout, self->domain, self->type, self->proto, self->bound);\n}\n\n\nstatic mp_obj_t socket_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 3, false);\n\n    \n    mod_network_socket_obj_t *s = mp_obj_malloc_with_finaliser(mod_network_socket_obj_t, &socket_type);\n    s->nic = MP_OBJ_NULL;\n    s->nic_protocol = NULL;\n    s->domain = MOD_NETWORK_AF_INET;\n    s->type = MOD_NETWORK_SOCK_STREAM;\n    s->proto = 0;\n    s->bound = false;\n    s->fileno = -1;\n    if (n_args > 0) {\n        s->domain = mp_obj_get_int(args[0]);\n        if (n_args > 1) {\n            s->type = mp_obj_get_int(args[1]);\n            if (n_args > 2) {\n                s->proto = mp_obj_get_int(args[2]);\n            }\n        }\n    }\n    s->timeout = -1;\n    s->callback = MP_OBJ_NULL;\n    s->state = MOD_NETWORK_SS_NEW;\n    #if MICROPY_PY_SOCKET_EXTENDED_STATE\n    s->_private = NULL;\n    #endif\n\n    return MP_OBJ_FROM_PTR(s);\n}\n\nstatic void socket_select_nic(mod_network_socket_obj_t *self, const byte *ip) {\n    if (self->nic == MP_OBJ_NULL) {\n        \n        self->nic = mod_network_find_nic(ip);\n        self->nic_protocol = (mod_network_nic_protocol_t *)MP_OBJ_TYPE_GET_SLOT(mp_obj_get_type(self->nic), protocol);\n\n        \n        int _errno;\n        if (self->nic_protocol->socket(self, &_errno) != 0) {\n            mp_raise_OSError(_errno);\n        }\n\n        #if MICROPY_PY_SOCKET_EXTENDED_STATE\n        \n        if (self->timeout != -1 && self->nic_protocol->settimeout(self, self->timeout, &_errno) != 0) {\n            mp_raise_OSError(_errno);\n        }\n        #endif\n    }\n}\n\n\nstatic mp_obj_t socket_bind(mp_obj_t self_in, mp_obj_t addr_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    uint8_t ip[MOD_NETWORK_IPADDR_BUF_SIZE];\n    mp_uint_t port = netutils_parse_inet_addr(addr_in, ip, NETUTILS_BIG);\n\n    \n    socket_select_nic(self, ip);\n\n    \n    int _errno;\n    if (self->nic_protocol->bind(self, ip, port, &_errno) != 0) {\n        mp_raise_OSError(_errno);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_bind_obj, socket_bind);\n\n\nstatic mp_obj_t socket_listen(size_t n_args, const mp_obj_t *args) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (self->nic == MP_OBJ_NULL) {\n        \n        \n        mp_raise_OSError(MP_ENOTCONN);\n    }\n\n    mp_int_t backlog = MICROPY_PY_SOCKET_LISTEN_BACKLOG_DEFAULT;\n    if (n_args > 1) {\n        backlog = mp_obj_get_int(args[1]);\n        backlog = (backlog < 0) ? 0 : backlog;\n    }\n\n    int _errno;\n    if (self->nic_protocol->listen(self, backlog, &_errno) != 0) {\n        mp_raise_OSError(_errno);\n    }\n\n    \n    self->state = MOD_NETWORK_SS_LISTENING;\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_listen_obj, 1, 2, socket_listen);\n\n\nstatic mp_obj_t socket_accept(mp_obj_t self_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->nic == MP_OBJ_NULL) {\n        \n        mp_raise_OSError(MP_EINVAL);\n    }\n\n    \n    \n    mod_network_socket_obj_t *socket2 = mp_obj_malloc_with_finaliser(mod_network_socket_obj_t, &socket_type);\n    socket2->nic = MP_OBJ_NULL;\n    socket2->nic_protocol = NULL;\n\n    \n    socket2->domain = self->domain;\n    socket2->type = self->type;\n    socket2->proto = self->proto;\n    socket2->bound = false;\n    socket2->fileno = -1;\n    socket2->timeout = -1;\n    socket2->callback = MP_OBJ_NULL;\n    socket2->state = MOD_NETWORK_SS_NEW;\n    #if MICROPY_PY_SOCKET_EXTENDED_STATE\n    socket2->_private = NULL;\n    #endif\n\n    \n    uint8_t ip[MOD_NETWORK_IPADDR_BUF_SIZE];\n    mp_uint_t port;\n    int _errno;\n    if (self->nic_protocol->accept(self, socket2, ip, &port, &_errno) != 0) {\n        mp_raise_OSError(_errno);\n    }\n\n    \n    socket2->nic = self->nic;\n    socket2->nic_protocol = self->nic_protocol;\n\n    \n    mp_obj_tuple_t *client = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));\n    client->items[0] = MP_OBJ_FROM_PTR(socket2);\n    client->items[1] = netutils_format_inet_addr(ip, port, NETUTILS_BIG);\n\n    return MP_OBJ_FROM_PTR(client);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(socket_accept_obj, socket_accept);\n\n\nstatic mp_obj_t socket_connect(mp_obj_t self_in, mp_obj_t addr_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    uint8_t ip[MOD_NETWORK_IPADDR_BUF_SIZE];\n    mp_uint_t port = netutils_parse_inet_addr(addr_in, ip, NETUTILS_BIG);\n\n    \n    socket_select_nic(self, ip);\n\n    \n    int _errno;\n    if (self->nic_protocol->connect(self, ip, port, &_errno) != 0) {\n        mp_raise_OSError(_errno);\n    }\n\n    \n    self->state = MOD_NETWORK_SS_CONNECTED;\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_connect_obj, socket_connect);\n\n\nstatic mp_obj_t socket_send(mp_obj_t self_in, mp_obj_t buf_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->nic == MP_OBJ_NULL) {\n        \n        mp_raise_OSError(MP_EPIPE);\n    }\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf_in, &bufinfo, MP_BUFFER_READ);\n    int _errno;\n    mp_uint_t ret = self->nic_protocol->send(self, bufinfo.buf, bufinfo.len, &_errno);\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n    return mp_obj_new_int_from_uint(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_send_obj, socket_send);\n\nstatic mp_obj_t socket_sendall(mp_obj_t self_in, mp_obj_t buf_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->nic == MP_OBJ_NULL) {\n        \n        mp_raise_OSError(MP_EPIPE);\n    }\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf_in, &bufinfo, MP_BUFFER_READ);\n\n    int _errno;\n    mp_uint_t ret = 0;\n    if (self->timeout == 0) {\n        ret = self->nic_protocol->send(self, bufinfo.buf, bufinfo.len, &_errno);\n        if (ret == -1) {\n            mp_raise_OSError(_errno);\n        } else if (bufinfo.len > ret) {\n            mp_raise_OSError(MP_EAGAIN);\n        }\n    } else {\n        \n        \n        while (bufinfo.len != 0) {\n            ret = self->nic_protocol->send(self, bufinfo.buf, bufinfo.len, &_errno);\n            if (ret == -1) {\n                mp_raise_OSError(_errno);\n            }\n            bufinfo.len -= ret;\n            bufinfo.buf = (char *)bufinfo.buf + ret;\n        }\n    }\n    return mp_obj_new_int_from_uint(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_sendall_obj, socket_sendall);\n\n\nstatic mp_obj_t socket_recv(mp_obj_t self_in, mp_obj_t len_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->nic == MP_OBJ_NULL) {\n        \n        mp_raise_OSError(MP_ENOTCONN);\n    }\n    mp_int_t len = mp_obj_get_int(len_in);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    int _errno;\n    mp_uint_t ret = self->nic_protocol->recv(self, (byte *)vstr.buf, len, &_errno);\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n    if (ret == 0) {\n        return mp_const_empty_bytes;\n    }\n    vstr.len = ret;\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_recv_obj, socket_recv);\n\n\nstatic mp_obj_t socket_sendto(mp_obj_t self_in, mp_obj_t data_in, mp_obj_t addr_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(data_in, &bufinfo, MP_BUFFER_READ);\n\n    \n    uint8_t ip[MOD_NETWORK_IPADDR_BUF_SIZE];\n    mp_uint_t port = netutils_parse_inet_addr(addr_in, ip, NETUTILS_BIG);\n\n    \n    socket_select_nic(self, ip);\n\n    \n    int _errno;\n    mp_int_t ret = self->nic_protocol->sendto(self, bufinfo.buf, bufinfo.len, ip, port, &_errno);\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n\n    return mp_obj_new_int(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(socket_sendto_obj, socket_sendto);\n\n\nstatic mp_obj_t socket_recvfrom(mp_obj_t self_in, mp_obj_t len_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->nic == MP_OBJ_NULL) {\n        \n        mp_raise_OSError(MP_ENOTCONN);\n    }\n    vstr_t vstr;\n    vstr_init_len(&vstr, mp_obj_get_int(len_in));\n    byte ip[4];\n    mp_uint_t port;\n    int _errno;\n    mp_int_t ret = self->nic_protocol->recvfrom(self, (byte *)vstr.buf, vstr.len, ip, &port, &_errno);\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n    mp_obj_t tuple[2];\n    if (ret == 0) {\n        tuple[0] = mp_const_empty_bytes;\n    } else {\n        vstr.len = ret;\n        tuple[0] = mp_obj_new_bytes_from_vstr(&vstr);\n    }\n    tuple[1] = netutils_format_inet_addr(ip, port, NETUTILS_BIG);\n    return mp_obj_new_tuple(2, tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_recvfrom_obj, socket_recvfrom);\n\n\nstatic mp_obj_t socket_setsockopt(size_t n_args, const mp_obj_t *args) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (self->nic == MP_OBJ_NULL) {\n        \n        uint8_t ip[4] = {0, 0, 0, 0};\n        socket_select_nic(self, ip);\n    }\n\n    mp_int_t level = mp_obj_get_int(args[1]);\n    mp_int_t opt = mp_obj_get_int(args[2]);\n\n    const void *optval;\n    mp_uint_t optlen;\n    mp_int_t val;\n    if (mp_obj_is_integer(args[3])) {\n        val = mp_obj_get_int_truncated(args[3]);\n        optval = &val;\n        optlen = sizeof(val);\n    } else if (opt == 20 && args[3] == mp_const_none) {\n        optval = MP_OBJ_NULL;\n        optlen = 0;\n    } else if (opt == 20 && mp_obj_is_callable(args[3])) {\n        optval = args[3];\n        optlen = sizeof(optval);\n    } else {\n        mp_buffer_info_t bufinfo;\n        mp_get_buffer_raise(args[3], &bufinfo, MP_BUFFER_READ);\n        optval = bufinfo.buf;\n        optlen = bufinfo.len;\n    }\n\n    int _errno;\n    if (self->nic_protocol->setsockopt(self, level, opt, optval, optlen, &_errno) != 0) {\n        mp_raise_OSError(_errno);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_setsockopt_obj, 4, 4, socket_setsockopt);\n\nstatic mp_obj_t socket_makefile(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    return args[0];\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_makefile_obj, 1, 3, socket_makefile);\n\n\n\n\n\nstatic mp_obj_t socket_settimeout(mp_obj_t self_in, mp_obj_t timeout_in) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_uint_t timeout;\n    if (timeout_in == mp_const_none) {\n        timeout = -1;\n    } else {\n        #if MICROPY_PY_BUILTINS_FLOAT\n        timeout = (mp_uint_t)(MICROPY_FLOAT_CONST(1000.0) * mp_obj_get_float(timeout_in));\n        #else\n        timeout = 1000 * mp_obj_get_int(timeout_in);\n        #endif\n    }\n    if (self->nic == MP_OBJ_NULL) {\n        #if MICROPY_PY_SOCKET_EXTENDED_STATE\n        \n        self->timeout = timeout;\n        #else\n        \n        mp_raise_OSError(MP_ENOTCONN);\n        #endif\n    } else {\n        int _errno;\n        if (self->nic_protocol->settimeout(self, timeout, &_errno) != 0) {\n            mp_raise_OSError(_errno);\n        }\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_settimeout_obj, socket_settimeout);\n\n\nstatic mp_obj_t socket_setblocking(mp_obj_t self_in, mp_obj_t blocking) {\n    if (mp_obj_is_true(blocking)) {\n        return socket_settimeout(self_in, mp_const_none);\n    } else {\n        return socket_settimeout(self_in, MP_OBJ_NEW_SMALL_INT(0));\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_setblocking_obj, socket_setblocking);\n\nstatic const mp_rom_map_elem_t socket_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_bind), MP_ROM_PTR(&socket_bind_obj) },\n    { MP_ROM_QSTR(MP_QSTR_listen), MP_ROM_PTR(&socket_listen_obj) },\n    { MP_ROM_QSTR(MP_QSTR_accept), MP_ROM_PTR(&socket_accept_obj) },\n    { MP_ROM_QSTR(MP_QSTR_connect), MP_ROM_PTR(&socket_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_send), MP_ROM_PTR(&socket_send_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sendall), MP_ROM_PTR(&socket_sendall_obj) },\n    { MP_ROM_QSTR(MP_QSTR_recv), MP_ROM_PTR(&socket_recv_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sendto), MP_ROM_PTR(&socket_sendto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_recvfrom), MP_ROM_PTR(&socket_recvfrom_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setsockopt), MP_ROM_PTR(&socket_setsockopt_obj) },\n    { MP_ROM_QSTR(MP_QSTR_makefile), MP_ROM_PTR(&socket_makefile_obj) },\n    { MP_ROM_QSTR(MP_QSTR_settimeout), MP_ROM_PTR(&socket_settimeout_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setblocking), MP_ROM_PTR(&socket_setblocking_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(socket_locals_dict, socket_locals_dict_table);\n\nmp_uint_t socket_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->nic == MP_OBJ_NULL) {\n        return MP_STREAM_ERROR;\n    }\n    mp_int_t ret = self->nic_protocol->recv(self, (byte *)buf, size, errcode);\n    if (ret < 0) {\n        ret = MP_STREAM_ERROR;\n    }\n    return ret;\n}\n\nmp_uint_t socket_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->nic == MP_OBJ_NULL) {\n        return MP_STREAM_ERROR;\n    }\n    mp_int_t ret = self->nic_protocol->send(self, buf, size, errcode);\n    if (ret < 0) {\n        ret = MP_STREAM_ERROR;\n    }\n    return ret;\n}\n\nmp_uint_t socket_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mod_network_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (request == MP_STREAM_CLOSE) {\n        if (self->nic != MP_OBJ_NULL) {\n            self->nic_protocol->close(self);\n            self->nic = MP_OBJ_NULL;\n        }\n        self->state = MOD_NETWORK_SS_CLOSED;\n        return 0;\n    }\n    if (self->nic == MP_OBJ_NULL) {\n        if (request == MP_STREAM_POLL) {\n            if (self->state == MOD_NETWORK_SS_NEW) {\n                \n                return MP_STREAM_POLL_HUP | MP_STREAM_POLL_WR;\n            } else if (self->state == MOD_NETWORK_SS_CLOSED) {\n                \n                return MP_STREAM_POLL_NVAL;\n            }\n        }\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n    return self->nic_protocol->ioctl(self, request, arg, errcode);\n}\n\nstatic const mp_stream_p_t socket_stream_p = {\n    .read = socket_read,\n    .write = socket_write,\n    .ioctl = socket_ioctl,\n    .is_text = false,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    socket_type,\n    MP_QSTR_socket,\n    MP_TYPE_FLAG_NONE,\n    make_new, socket_make_new,\n    protocol, &socket_stream_p,\n    locals_dict, &socket_locals_dict,\n    print, socket_print\n    );\n\n \n\n\n\nstatic mp_obj_t mod_socket_getaddrinfo(size_t n_args, const mp_obj_t *args) {\n    size_t hlen;\n    const char *host = mp_obj_str_get_data(args[0], &hlen);\n    mp_int_t port = mp_obj_get_int(args[1]);\n    uint8_t out_ip[MOD_NETWORK_IPADDR_BUF_SIZE];\n    bool have_ip = false;\n\n    \n    if (n_args > 2) {\n        mp_int_t family = mp_obj_get_int(args[2]);\n        mp_int_t type = 0;\n        mp_int_t proto = 0;\n        mp_int_t flags = 0;\n        if (n_args > 3) {\n            type = mp_obj_get_int(args[3]);\n            if (n_args > 4) {\n                proto = mp_obj_get_int(args[4]);\n                if (n_args > 5) {\n                    flags = mp_obj_get_int(args[5]);\n                }\n            }\n        }\n        if (!((family == 0 || family == MOD_NETWORK_AF_INET)\n              && (type == 0 || type == MOD_NETWORK_SOCK_STREAM)\n              && proto == 0\n              && flags == 0)) {\n            mp_warning(MP_WARN_CAT(RuntimeWarning), \"unsupported getaddrinfo constraints\");\n        }\n    }\n\n    if (hlen > 0) {\n        \n        nlr_buf_t nlr;\n        if (nlr_push(&nlr) == 0) {\n            netutils_parse_ipv4_addr(args[0], out_ip, NETUTILS_BIG);\n            have_ip = true;\n            nlr_pop();\n        } else {\n            \n        }\n    }\n\n    if (!have_ip) {\n        \n        for (mp_uint_t i = 0; i < MP_STATE_PORT(mod_network_nic_list).len; i++) {\n            mp_obj_t nic = MP_STATE_PORT(mod_network_nic_list).items[i];\n            mod_network_nic_protocol_t *nic_protocol = (mod_network_nic_protocol_t *)MP_OBJ_TYPE_GET_SLOT(mp_obj_get_type(nic), protocol);\n            if (nic_protocol->gethostbyname != NULL) {\n                int ret = nic_protocol->gethostbyname(nic, host, hlen, out_ip);\n                if (ret != 0) {\n                    mp_raise_OSError(ret);\n                }\n                have_ip = true;\n                break;\n            }\n        }\n    }\n\n    if (!have_ip) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"no available NIC\"));\n    }\n\n    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(mp_obj_new_tuple(5, NULL));\n    tuple->items[0] = MP_OBJ_NEW_SMALL_INT(MOD_NETWORK_AF_INET);\n    tuple->items[1] = MP_OBJ_NEW_SMALL_INT(MOD_NETWORK_SOCK_STREAM);\n    tuple->items[2] = MP_OBJ_NEW_SMALL_INT(0);\n    tuple->items[3] = MP_OBJ_NEW_QSTR(MP_QSTR_);\n    tuple->items[4] = netutils_format_inet_addr(out_ip, port, NETUTILS_BIG);\n    return mp_obj_new_list(1, (mp_obj_t *)&tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_socket_getaddrinfo_obj, 2, 6, mod_socket_getaddrinfo);\n\nstatic const mp_rom_map_elem_t mp_module_socket_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_socket) },\n\n    { MP_ROM_QSTR(MP_QSTR_socket), MP_ROM_PTR(&socket_type) },\n    { MP_ROM_QSTR(MP_QSTR_getaddrinfo), MP_ROM_PTR(&mod_socket_getaddrinfo_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_AF_INET), MP_ROM_INT(MOD_NETWORK_AF_INET) },\n    { MP_ROM_QSTR(MP_QSTR_AF_INET6), MP_ROM_INT(MOD_NETWORK_AF_INET6) },\n\n    { MP_ROM_QSTR(MP_QSTR_SOCK_STREAM), MP_ROM_INT(MOD_NETWORK_SOCK_STREAM) },\n    { MP_ROM_QSTR(MP_QSTR_SOCK_DGRAM), MP_ROM_INT(MOD_NETWORK_SOCK_DGRAM) },\n    { MP_ROM_QSTR(MP_QSTR_SOCK_RAW), MP_ROM_INT(MOD_NETWORK_SOCK_RAW) },\n\n    { MP_ROM_QSTR(MP_QSTR_SOL_SOCKET), MP_ROM_INT(MOD_NETWORK_SOL_SOCKET) },\n    { MP_ROM_QSTR(MP_QSTR_SO_REUSEADDR), MP_ROM_INT(MOD_NETWORK_SO_REUSEADDR) },\n    { MP_ROM_QSTR(MP_QSTR_SO_BROADCAST), MP_ROM_INT(MOD_NETWORK_SO_BROADCAST) },\n    { MP_ROM_QSTR(MP_QSTR_SO_KEEPALIVE), MP_ROM_INT(MOD_NETWORK_SO_KEEPALIVE) },\n    { MP_ROM_QSTR(MP_QSTR_SO_SNDTIMEO), MP_ROM_INT(MOD_NETWORK_SO_SNDTIMEO) },\n    { MP_ROM_QSTR(MP_QSTR_SO_RCVTIMEO), MP_ROM_INT(MOD_NETWORK_SO_RCVTIMEO) },\n\n     \n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_socket_globals, mp_module_socket_globals_table);\n\nconst mp_obj_module_t mp_module_socket = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_socket_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_socket, mp_module_socket);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}