{
  "module_name": "network_lwip.c",
  "hash_id": "270feb6349cfba3e71cbd3eb395f2c2e9dda0d8451a8c14b2b81b7c4d9d4d792",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/network_lwip.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/mphal.h\"\n#include \"py/parsenum.h\"\n\n#if MICROPY_PY_NETWORK && MICROPY_PY_LWIP\n\n#include \"shared/netutils/netutils.h\"\n#include \"extmod/modnetwork.h\"\n\n#include \"lwip/init.h\"\n\n#if LWIP_VERSION_MAJOR >= 2\n\n#include \"lwip/netif.h\"\n#include \"lwip/timeouts.h\"\n#include \"lwip/dns.h\"\n#include \"lwip/dhcp.h\"\n#include \"lwip/nd6.h\"\n#include \"lwip/dhcp6.h\"\n#include \"lwip/prot/dhcp.h\"\n#include \"lwip/prot/dhcp6.h\"\n#include <string.h>\n#include <stdlib.h>\n\nint mp_mod_network_prefer_dns_use_ip_version = 4;\n\n\n\n\n\nmp_obj_t mod_network_nic_ifconfig(struct netif *netif, size_t n_args, const mp_obj_t *args) {\n    if (n_args == 0) {\n        \n        const ip_addr_t *dns = dns_getserver(0);\n        mp_obj_t tuple[4] = {\n            netutils_format_ipv4_addr((uint8_t *)&netif->ip_addr, NETUTILS_BIG),\n            netutils_format_ipv4_addr((uint8_t *)&netif->netmask, NETUTILS_BIG),\n            netutils_format_ipv4_addr((uint8_t *)&netif->gw, NETUTILS_BIG),\n            netutils_format_ipv4_addr((uint8_t *)dns, NETUTILS_BIG),\n        };\n        return mp_obj_new_tuple(4, tuple);\n    } else if (args[0] == MP_OBJ_NEW_QSTR(MP_QSTR_dhcp)) {\n        \n        if (dhcp_supplied_address(netif)) {\n            dhcp_renew(netif);\n        } else {\n            dhcp_stop(netif);\n            dhcp_start(netif);\n        }\n\n        \n        uint32_t start = mp_hal_ticks_ms();\n        while (!dhcp_supplied_address(netif)) {\n            if (mp_hal_ticks_ms() - start > 10000) {\n                mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"timeout waiting for DHCP to get IP address\"));\n            }\n            mp_hal_delay_ms(100);\n        }\n\n        return mp_const_none;\n    } else {\n        \n        dhcp_release(netif);\n        dhcp_stop(netif);\n        \n        mp_obj_t *items;\n        mp_obj_get_array_fixed_n(args[0], 4, &items);\n        netutils_parse_ipv4_addr(items[0], (uint8_t *)&netif->ip_addr, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[1], (uint8_t *)&netif->netmask, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[2], (uint8_t *)&netif->gw, NETUTILS_BIG);\n        ip_addr_t dns;\n        netutils_parse_ipv4_addr(items[3], (uint8_t *)&dns, NETUTILS_BIG);\n        dns_setserver(0, &dns);\n        return mp_const_none;\n    }\n}\n\n\nmp_obj_t mod_network_ipconfig(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    if (kwargs->used == 0) {\n        \n        if (n_args != 1) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[0])) {\n            case MP_QSTR_dns: {\n                char addr_str[IPADDR_STRLEN_MAX];\n                ipaddr_ntoa_r(dns_getserver(0), addr_str, sizeof(addr_str));\n                return mp_obj_new_str(addr_str, strlen(addr_str));\n            }\n            case MP_QSTR_prefer: {\n                return MP_OBJ_NEW_SMALL_INT(mp_mod_network_prefer_dns_use_ip_version);\n            }\n            default: {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unexpected key\"));\n                break;\n            }\n        }\n    } else {\n        \n        if (n_args != 0) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't specify pos and kw args\"));\n        }\n\n        for (size_t i = 0; i < kwargs->alloc; ++i) {\n            if (MP_MAP_SLOT_IS_FILLED(kwargs, i)) {\n                mp_map_elem_t *e = &kwargs->table[i];\n                switch (mp_obj_str_get_qstr(e->key)) {\n                    case MP_QSTR_dns: {\n                        ip_addr_t dns;\n                        size_t addr_len;\n                        const char *addr_str = mp_obj_str_get_data(e->value, &addr_len);\n                        if (!ipaddr_aton(addr_str, &dns)) {\n                            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid arguments as dns server\"));\n                        }\n                        dns_setserver(0, &dns);\n                        break;\n                    }\n                    case MP_QSTR_prefer: {\n                        int value = mp_obj_get_int(e->value);\n                        if (value != 4 && value != 6) {\n                            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid prefer argument\"));\n                        }\n                        mp_mod_network_prefer_dns_use_ip_version = value;\n                        break;\n                    }\n                    default: {\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"unexpected key\"));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return mp_const_none;\n}\n\nmp_obj_t mod_network_nic_ipconfig(struct netif *netif, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n\n    if (kwargs->used == 0) {\n        \n        if (n_args != 1) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[0])) {\n            case MP_QSTR_dhcp4: {\n                struct dhcp *dhcp = netif_dhcp_data(netif);\n                return mp_obj_new_bool(dhcp != NULL && dhcp->state != DHCP_STATE_OFF);\n            }\n            case MP_QSTR_has_dhcp4: {\n                return mp_obj_new_bool(dhcp_supplied_address(netif));\n            }\n            #if LWIP_IPV6_DHCP6\n            case MP_QSTR_dhcp6: {\n                struct dhcp6 *dhcp = netif_dhcp6_data(netif);\n                return mp_obj_new_bool(dhcp != NULL && dhcp->state != DHCP6_STATE_OFF);\n            }\n            #endif\n            #if LWIP_IPV6_AUTOCONFIG\n            case MP_QSTR_autoconf6: {\n                return netif->ip6_autoconfig_enabled ?  mp_const_true : mp_const_false;\n            }\n            case MP_QSTR_has_autoconf6: {\n                int found = 0;\n                for (int i = 1; i < LWIP_IPV6_NUM_ADDRESSES; i++) {\n                    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&\n                        !netif_ip6_addr_isstatic(netif, i)) {\n                        found = 1;\n                        break;\n                    }\n                }\n                if (found) {\n                    break;\n                }\n                return mp_obj_new_bool(found);\n            }\n            #endif\n            case MP_QSTR_addr4: {\n                mp_obj_t tuple[2] = {\n                    netutils_format_ipv4_addr((uint8_t *)&netif->ip_addr, NETUTILS_BIG),\n                    netutils_format_ipv4_addr((uint8_t *)&netif->netmask, NETUTILS_BIG),\n                };\n                return mp_obj_new_tuple(2, tuple);\n            }\n            #if LWIP_IPV6\n            case MP_QSTR_addr6: {\n                mp_obj_t addrs[LWIP_IPV6_NUM_ADDRESSES];\n                size_t n_addrs = 0;\n                for (int i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {\n                    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i))) {\n                        char addr_str[IPADDR_STRLEN_MAX];\n                        ipaddr_ntoa_r(netif_ip_addr6(netif, i), addr_str, sizeof(addr_str));\n                        mp_obj_t tuple[4] = {\n                            mp_obj_new_str(addr_str, strlen(addr_str)),\n                            MP_OBJ_NEW_SMALL_INT(netif_ip6_addr_state(netif, i)),\n                            MP_OBJ_NEW_SMALL_INT(netif_ip6_addr_pref_life(netif, i)), \n                            MP_OBJ_NEW_SMALL_INT(netif_ip6_addr_valid_life(netif, i))\n                        };\n                        addrs[n_addrs++] = mp_obj_new_tuple(4, tuple);\n                    }\n                }\n                return mp_obj_new_list(n_addrs, addrs);\n            }\n            #endif\n            case MP_QSTR_gw4: {\n                return netutils_format_ipv4_addr((uint8_t *)&netif->gw, NETUTILS_BIG);\n            }\n            default: {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unexpected key\"));\n                break;\n            }\n        }\n        return mp_const_none;\n    } else {\n        \n        if (n_args != 0) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't specify pos and kw args\"));\n        }\n\n        for (size_t i = 0; i < kwargs->alloc; ++i) {\n            if (MP_MAP_SLOT_IS_FILLED(kwargs, i)) {\n                mp_map_elem_t *e = &kwargs->table[i];\n                switch (mp_obj_str_get_qstr(e->key)) {\n                    case MP_QSTR_dhcp4: {\n                        if (mp_obj_is_true(e->value)) {\n                            if (dhcp_supplied_address(netif)) {\n                                dhcp_renew(netif);\n                            } else {\n                                dhcp_release_and_stop(netif);\n                                dhcp_start(netif);\n                            }\n                        } else {\n                            dhcp_release_and_stop(netif);\n                        }\n                        break;\n                    }\n                    #if LWIP_IPV6_DHCP6\n                    case MP_QSTR_dhcp6: {\n                        dhcp6_disable(netif);\n                        dhcp6_enable_stateless(netif);\n                        break;\n                    }\n                    #endif\n                    #if LWIP_IPV6_AUTOCONFIG\n                    case MP_QSTR_autoconf6: {\n                        netif_set_ip6_autoconfig_enabled(netif, mp_obj_is_true(e->value));\n                        if (mp_obj_is_true(e->value)) {\n                            nd6_restart_netif(netif);\n                        } else {\n                            \n                            for (i = 1; i < LWIP_IPV6_NUM_ADDRESSES; i++) {\n                                if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&\n                                    !netif_ip6_addr_isstatic(netif, i)) {\n                                    netif_ip6_addr_set_state(netif, i, IP6_ADDR_INVALID);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    #endif\n                    case MP_QSTR_addr4:\n                    case MP_QSTR_addr6: {\n                        ip_addr_t ip_addr;\n                        ip_addr_t netmask;\n                        int prefix_bits = 32;\n                        if (e->value != mp_const_none && mp_obj_is_str(e->value)) {\n                            size_t addr_len;\n                            const char *input_str = mp_obj_str_get_data(e->value, &addr_len);\n                            char plain_ip[IPADDR_STRLEN_MAX];\n                            char *split = strchr(input_str, '/');\n                            const char *addr_str = input_str;\n                            if (split) {\n                                int to_copy = sizeof(plain_ip) - 1;\n                                if (split - addr_str < to_copy) {\n                                    to_copy = split - addr_str;\n                                }\n                                memcpy(plain_ip, addr_str, to_copy);\n                                mp_obj_t prefix_obj = mp_parse_num_integer(split + 1, strlen(split + 1), 10, NULL);\n                                prefix_bits = mp_obj_get_int(prefix_obj);\n                            }\n                            if (mp_obj_str_get_qstr(args[0]) == MP_QSTR_addr4) {\n                                uint32_t mask = -(1u << (32 - prefix_bits));\n                                ip_addr_set_ip4_u32_val(netmask, ((mask & 0xFF) << 24) | ((mask & 0xFF00) << 8) | ((mask >> 8) & 0xFF00) | ((mask >> 24) & 0xFF));\n                            }\n                            if (!ipaddr_aton(addr_str, &ip_addr)) {\n                                mp_raise_ValueError(MP_ERROR_TEXT(\"invalid arguments\"));\n                            }\n                            if ((mp_obj_str_get_qstr(args[0]) == MP_QSTR_addr6) != IP_IS_V6(&ip_addr)\n                                || (mp_obj_str_get_qstr(args[0]) == MP_QSTR_addr4) != IP_IS_V4(&ip_addr)) {\n                                mp_raise_ValueError(MP_ERROR_TEXT(\"invalid address type\"));\n                            }\n                        } else if (e->value != mp_const_none) {\n                            mp_obj_t *items;\n                            mp_obj_get_array_fixed_n(e->value, 2, &items);\n                            size_t addr_len;\n                            const char *ip_addr_str = mp_obj_str_get_data(items[0], &addr_len);\n                            const char *netmask_str = mp_obj_str_get_data(items[1], &addr_len);\n                            if (!ipaddr_aton(ip_addr_str, &ip_addr)) {\n                                mp_raise_ValueError(MP_ERROR_TEXT(\"invalid arguments\"));\n                            }\n                            if (!ipaddr_aton(netmask_str, &netmask)) {\n                                mp_raise_ValueError(MP_ERROR_TEXT(\"invalid arguments\"));\n                            }\n                            if (!IP_IS_V4(&ip_addr) || !IP_IS_V4(&netmask)) {\n                                mp_raise_ValueError(MP_ERROR_TEXT(\"invalid address type\"));\n                            }\n                        }\n                        if (mp_obj_str_get_qstr(args[0]) == MP_QSTR_addr4) {\n                            if (e->value != mp_const_none) {\n                                netif->ip_addr = ip_addr;\n                                netif->netmask = netmask;\n                            } else {\n                                ip4_addr_set_any(ip_2_ip4(&netif->ip_addr));\n                                ip4_addr_set_any(ip_2_ip4(&netif->netmask));\n                            }\n                        #if LWIP_IPV6\n                        } else if (mp_obj_str_get_qstr(args[0]) == MP_QSTR_addr6) {\n                            \n                            for (i = 1; i < LWIP_IPV6_NUM_ADDRESSES; i++) {\n                                if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&\n                                    netif_ip6_addr_isstatic(netif, i)) {\n                                    netif_ip6_addr_set_state(netif, i, IP6_ADDR_INVALID);\n                                }\n                            }\n                            if (e->value != mp_const_none) {\n                                s8_t free_idx;\n                                netif_add_ip6_address(netif, ip_2_ip6(&ip_addr), &free_idx);\n                                netif_ip6_addr_set_valid_life(netif, free_idx, IP6_ADDR_LIFE_STATIC);\n                                netif_ip6_addr_set_pref_life(netif, free_idx, IP6_ADDR_LIFE_STATIC);\n                                netif_ip6_addr_set_state(netif, free_idx, IP6_ADDR_PREFERRED);\n                            }\n                        #endif\n                        }\n                        break;\n                    }\n                    case MP_QSTR_gw4: {\n                        ip_addr_t ip_addr;\n                        size_t addr_len;\n                        const char *addr_str = mp_obj_str_get_data(e->value, &addr_len);\n                        if (!ipaddr_aton(addr_str, &ip_addr)) {\n                            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid arguments\"));\n                        }\n                        if (IP_IS_V4(&ip_addr)) {\n                            netif->gw = ip_addr;\n                        } else {\n                            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid address type\"));\n                        }\n                        break;\n                    }\n                    default: {\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"unexpected key\"));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return mp_const_none;\n}\n\n#endif \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}