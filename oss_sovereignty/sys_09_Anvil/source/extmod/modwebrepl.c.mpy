{
  "module_name": "modwebrepl.c",
  "hash_id": "5b8b627d61c3150e01434504233a10315775025c50b0d5e0d16e30b20965d333",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modwebrepl.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/builtin.h\"\n#ifdef MICROPY_PY_WEBREPL_DELAY\n#include \"py/mphal.h\"\n#endif\n#include \"extmod/modwebsocket.h\"\n\n#if MICROPY_PY_WEBREPL\n\n#if 0 \n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\nstruct webrepl_file {\n    char sig[2];\n    char type;\n    char flags;\n    uint64_t offset;\n    uint32_t size;\n    uint16_t fname_len;\n    char fname[64];\n} __attribute__((packed));\n\nenum { PUT_FILE = 1, GET_FILE, GET_VER };\nenum { STATE_PASSWD, STATE_NORMAL };\n\ntypedef struct _mp_obj_webrepl_t {\n    mp_obj_base_t base;\n    mp_obj_t sock;\n    byte state;\n    byte hdr_to_recv;\n    uint32_t data_to_recv;\n    struct webrepl_file hdr;\n    mp_obj_t cur_file;\n} mp_obj_webrepl_t;\n\nstatic const char passwd_prompt[] = \"Password: \";\nstatic const char connected_prompt[] = \"\\r\\nWebREPL connected\\r\\n>>> \";\nstatic const char denied_prompt[] = \"\\r\\nAccess denied\\r\\n\";\n\nstatic char webrepl_passwd[10];\n\nstatic void write_webrepl(mp_obj_t websock, const void *buf, size_t len) {\n    const mp_stream_p_t *sock_stream = mp_get_stream(websock);\n    int err;\n    int old_opts = sock_stream->ioctl(websock, MP_STREAM_SET_DATA_OPTS, FRAME_BIN, &err);\n    sock_stream->write(websock, buf, len, &err);\n    sock_stream->ioctl(websock, MP_STREAM_SET_DATA_OPTS, old_opts, &err);\n}\n\n#define SSTR(s) s, sizeof(s) - 1\nstatic void write_webrepl_str(mp_obj_t websock, const char *str, int sz) {\n    int err;\n    const mp_stream_p_t *sock_stream = mp_get_stream(websock);\n    sock_stream->write(websock, str, sz, &err);\n}\n\nstatic void write_webrepl_resp(mp_obj_t websock, uint16_t code) {\n    char buf[4] = {'W', 'B', code & 0xff, code >> 8};\n    write_webrepl(websock, buf, sizeof(buf));\n}\n\nstatic mp_obj_t webrepl_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 1, 2, false);\n    mp_get_stream_raise(args[0], MP_STREAM_OP_READ | MP_STREAM_OP_WRITE | MP_STREAM_OP_IOCTL);\n    DEBUG_printf(\"sizeof(struct webrepl_file) = %lu\\n\", sizeof(struct webrepl_file));\n    mp_obj_webrepl_t *o = mp_obj_malloc(mp_obj_webrepl_t, type);\n    o->sock = args[0];\n    o->hdr_to_recv = sizeof(struct webrepl_file);\n    o->data_to_recv = 0;\n    o->state = STATE_PASSWD;\n    write_webrepl_str(args[0], SSTR(passwd_prompt));\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic void check_file_op_finished(mp_obj_webrepl_t *self) {\n    if (self->data_to_recv == 0) {\n        mp_stream_close(self->cur_file);\n        self->hdr_to_recv = sizeof(struct webrepl_file);\n        DEBUG_printf(\"webrepl: Finished file operation %d\\n\", self->hdr.type);\n        write_webrepl_resp(self->sock, 0);\n    }\n}\n\nstatic int write_file_chunk(mp_obj_webrepl_t *self) {\n    const mp_stream_p_t *file_stream = mp_get_stream(self->cur_file);\n    byte readbuf[2 + 256];\n    int err;\n    mp_uint_t out_sz = file_stream->read(self->cur_file, readbuf + 2, sizeof(readbuf) - 2, &err);\n    if (out_sz == MP_STREAM_ERROR) {\n        return out_sz;\n    }\n    readbuf[0] = out_sz;\n    readbuf[1] = out_sz >> 8;\n    DEBUG_printf(\"webrepl: Sending %d bytes of file\\n\", out_sz);\n    write_webrepl(self->sock, readbuf, 2 + out_sz);\n    return out_sz;\n}\n\nstatic void handle_op(mp_obj_webrepl_t *self) {\n\n    \n\n    switch (self->hdr.type) {\n        case GET_VER: {\n            static const char ver[] = {MICROPY_VERSION_MAJOR, MICROPY_VERSION_MINOR, MICROPY_VERSION_MICRO};\n            write_webrepl(self->sock, ver, sizeof(ver));\n            self->hdr_to_recv = sizeof(struct webrepl_file);\n            return;\n        }\n    }\n\n    \n\n    mp_obj_t open_args[2] = {\n        mp_obj_new_str(self->hdr.fname, strlen(self->hdr.fname)),\n        MP_OBJ_NEW_QSTR(MP_QSTR_rb)\n    };\n\n    if (self->hdr.type == PUT_FILE) {\n        open_args[1] = MP_OBJ_NEW_QSTR(MP_QSTR_wb);\n    }\n\n    self->cur_file = mp_builtin_open(2, open_args, (mp_map_t *)&mp_const_empty_map);\n\n    #if 0\n    struct mp_stream_seek_t seek = { .offset = self->hdr.offset, .whence = 0 };\n    int err;\n    mp_uint_t res = file_stream->ioctl(self->cur_file, MP_STREAM_SEEK, (uintptr_t)&seek, &err);\n    assert(res != MP_STREAM_ERROR);\n    #endif\n\n    write_webrepl_resp(self->sock, 0);\n\n    if (self->hdr.type == PUT_FILE) {\n        self->data_to_recv = self->hdr.size;\n        check_file_op_finished(self);\n    } else if (self->hdr.type == GET_FILE) {\n        self->data_to_recv = 1;\n    }\n}\n\nstatic mp_uint_t _webrepl_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode);\n\nstatic mp_uint_t webrepl_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    mp_uint_t out_sz;\n    do {\n        out_sz = _webrepl_read(self_in, buf, size, errcode);\n    } while (out_sz == -2);\n    return out_sz;\n}\n\nstatic mp_uint_t _webrepl_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    \n    assert(size == 1);\n    mp_obj_webrepl_t *self = MP_OBJ_TO_PTR(self_in);\n    const mp_stream_p_t *sock_stream = mp_get_stream(self->sock);\n    mp_uint_t out_sz = sock_stream->read(self->sock, buf, size, errcode);\n    \n    if (out_sz == 0 || out_sz == MP_STREAM_ERROR) {\n        return out_sz;\n    }\n\n    if (self->state == STATE_PASSWD) {\n        char c = *(char *)buf;\n        if (c == '\\r' || c == '\\n') {\n            self->hdr.fname[self->data_to_recv] = 0;\n            DEBUG_printf(\"webrepl: entered password: %s\\n\", self->hdr.fname);\n\n            if (strcmp(self->hdr.fname, webrepl_passwd) != 0) {\n                write_webrepl_str(self->sock, SSTR(denied_prompt));\n                return 0;\n            }\n\n            self->state = STATE_NORMAL;\n            self->data_to_recv = 0;\n            write_webrepl_str(self->sock, SSTR(connected_prompt));\n        } else if (self->data_to_recv < 10) {\n            self->hdr.fname[self->data_to_recv++] = c;\n        }\n        return -2;\n    }\n\n    \n    int err;\n    if (sock_stream->ioctl(self->sock, MP_STREAM_GET_DATA_OPTS, 0, &err) == 1) {\n        return out_sz;\n    }\n\n    DEBUG_printf(\"webrepl: received bin data, hdr_to_recv: %d, data_to_recv=%d\\n\", self->hdr_to_recv, self->data_to_recv);\n\n    if (self->hdr_to_recv != 0) {\n        char *p = (char *)&self->hdr + sizeof(self->hdr) - self->hdr_to_recv;\n        *p++ = *(char *)buf;\n        if (--self->hdr_to_recv != 0) {\n            mp_uint_t hdr_sz = sock_stream->read(self->sock, p, self->hdr_to_recv, errcode);\n            if (hdr_sz == MP_STREAM_ERROR) {\n                return hdr_sz;\n            }\n            self->hdr_to_recv -= hdr_sz;\n            if (self->hdr_to_recv != 0) {\n                return -2;\n            }\n        }\n\n        DEBUG_printf(\"webrepl: op: %d, file: %s, chunk @%x, sz=%d\\n\", self->hdr.type, self->hdr.fname, (uint32_t)self->hdr.offset, self->hdr.size);\n\n        handle_op(self);\n\n        return -2;\n    }\n\n    if (self->data_to_recv != 0) {\n        \n        #if MICROPY_PY_WEBREPL_STATIC_FILEBUF\n        static\n        #endif\n        byte filebuf[512];\n        filebuf[0] = *(byte *)buf;\n        mp_uint_t buf_sz = 1;\n        if (--self->data_to_recv != 0) {\n            size_t to_read = MIN(sizeof(filebuf) - 1, self->data_to_recv);\n            mp_uint_t sz = sock_stream->read(self->sock, filebuf + 1, to_read, errcode);\n            if (sz == MP_STREAM_ERROR) {\n                return sz;\n            }\n            self->data_to_recv -= sz;\n            buf_sz += sz;\n        }\n\n        if (self->hdr.type == PUT_FILE) {\n            DEBUG_printf(\"webrepl: Writing %lu bytes to file\\n\", buf_sz);\n            int err;\n            mp_uint_t res = mp_stream_write_exactly(self->cur_file, filebuf, buf_sz, &err);\n            if (err != 0 || res != buf_sz) {\n                assert(0);\n            }\n        } else if (self->hdr.type == GET_FILE) {\n            assert(buf_sz == 1);\n            assert(self->data_to_recv == 0);\n            assert(filebuf[0] == 0);\n            mp_uint_t out_sz = write_file_chunk(self);\n            if (out_sz != 0) {\n                self->data_to_recv = 1;\n            }\n        }\n\n        check_file_op_finished(self);\n\n        #ifdef MICROPY_PY_WEBREPL_DELAY\n        \n        \n        \n        \n        mp_hal_delay_ms(MICROPY_PY_WEBREPL_DELAY);\n        #endif\n    }\n\n    return -2;\n}\n\nstatic mp_uint_t webrepl_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_webrepl_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->state == STATE_PASSWD) {\n        \n        return size;\n    }\n    const mp_stream_p_t *stream_p = mp_get_stream(self->sock);\n    return stream_p->write(self->sock, buf, size, errcode);\n}\n\nstatic mp_uint_t webrepl_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mp_obj_webrepl_t *self = MP_OBJ_TO_PTR(o_in);\n    (void)arg;\n    switch (request) {\n        case MP_STREAM_CLOSE:\n            \n            mp_stream_close(self->sock);\n            return 0;\n\n        default:\n            *errcode = MP_EINVAL;\n            return MP_STREAM_ERROR;\n    }\n}\n\nstatic mp_obj_t webrepl_set_password(mp_obj_t passwd_in) {\n    size_t len;\n    const char *passwd = mp_obj_str_get_data(passwd_in, &len);\n    if (len > sizeof(webrepl_passwd) - 1) {\n        mp_raise_ValueError(NULL);\n    }\n    strcpy(webrepl_passwd, passwd);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(webrepl_set_password_obj, webrepl_set_password);\n\nstatic const mp_rom_map_elem_t webrepl_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(webrepl_locals_dict, webrepl_locals_dict_table);\n\nstatic const mp_stream_p_t webrepl_stream_p = {\n    .read = webrepl_read,\n    .write = webrepl_write,\n    .ioctl = webrepl_ioctl,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    webrepl_type,\n    MP_QSTR__webrepl,\n    MP_TYPE_FLAG_NONE,\n    make_new, webrepl_make_new,\n    protocol, &webrepl_stream_p,\n    locals_dict, &webrepl_locals_dict\n    );\n\nstatic const mp_rom_map_elem_t webrepl_module_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR__webrepl) },\n    { MP_ROM_QSTR(MP_QSTR__webrepl), MP_ROM_PTR(&webrepl_type) },\n    { MP_ROM_QSTR(MP_QSTR_password), MP_ROM_PTR(&webrepl_set_password_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(webrepl_module_globals, webrepl_module_globals_table);\n\nconst mp_obj_module_t mp_module_webrepl = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&webrepl_module_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR__webrepl, mp_module_webrepl);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}