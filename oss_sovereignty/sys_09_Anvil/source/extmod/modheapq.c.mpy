{
  "module_name": "modheapq.c",
  "hash_id": "960b2a13d99868e732b376aee32a0ac958b1085c512d0dc3e90dfdfd9255e6d4",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modheapq.c",
  "human_readable_source": " \n\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_HEAPQ\n\n\n\nstatic mp_obj_list_t *heapq_get_heap(mp_obj_t heap_in) {\n    if (!mp_obj_is_type(heap_in, &mp_type_list)) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"heap must be a list\"));\n    }\n    return MP_OBJ_TO_PTR(heap_in);\n}\n\nstatic void heapq_heap_siftdown(mp_obj_list_t *heap, mp_uint_t start_pos, mp_uint_t pos) {\n    mp_obj_t item = heap->items[pos];\n    while (pos > start_pos) {\n        mp_uint_t parent_pos = (pos - 1) >> 1;\n        mp_obj_t parent = heap->items[parent_pos];\n        if (mp_binary_op(MP_BINARY_OP_LESS, item, parent) == mp_const_true) {\n            heap->items[pos] = parent;\n            pos = parent_pos;\n        } else {\n            break;\n        }\n    }\n    heap->items[pos] = item;\n}\n\nstatic void heapq_heap_siftup(mp_obj_list_t *heap, mp_uint_t pos) {\n    mp_uint_t start_pos = pos;\n    mp_uint_t end_pos = heap->len;\n    mp_obj_t item = heap->items[pos];\n    for (mp_uint_t child_pos = 2 * pos + 1; child_pos < end_pos; child_pos = 2 * pos + 1) {\n        \n        if (child_pos + 1 < end_pos && mp_binary_op(MP_BINARY_OP_LESS, heap->items[child_pos], heap->items[child_pos + 1]) == mp_const_false) {\n            child_pos += 1;\n        }\n        \n        heap->items[pos] = heap->items[child_pos];\n        pos = child_pos;\n    }\n    heap->items[pos] = item;\n    heapq_heap_siftdown(heap, start_pos, pos);\n}\n\nstatic mp_obj_t mod_heapq_heappush(mp_obj_t heap_in, mp_obj_t item) {\n    mp_obj_list_t *heap = heapq_get_heap(heap_in);\n    mp_obj_list_append(heap_in, item);\n    heapq_heap_siftdown(heap, 0, heap->len - 1);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mod_heapq_heappush_obj, mod_heapq_heappush);\n\nstatic mp_obj_t mod_heapq_heappop(mp_obj_t heap_in) {\n    mp_obj_list_t *heap = heapq_get_heap(heap_in);\n    if (heap->len == 0) {\n        mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"empty heap\"));\n    }\n    mp_obj_t item = heap->items[0];\n    heap->len -= 1;\n    heap->items[0] = heap->items[heap->len];\n    heap->items[heap->len] = MP_OBJ_NULL; \n    if (heap->len) {\n        heapq_heap_siftup(heap, 0);\n    }\n    return item;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_heapq_heappop_obj, mod_heapq_heappop);\n\nstatic mp_obj_t mod_heapq_heapify(mp_obj_t heap_in) {\n    mp_obj_list_t *heap = heapq_get_heap(heap_in);\n    for (mp_uint_t i = heap->len / 2; i > 0;) {\n        heapq_heap_siftup(heap, --i);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_heapq_heapify_obj, mod_heapq_heapify);\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_rom_map_elem_t mp_module_heapq_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_heapq) },\n    { MP_ROM_QSTR(MP_QSTR_heappush), MP_ROM_PTR(&mod_heapq_heappush_obj) },\n    { MP_ROM_QSTR(MP_QSTR_heappop), MP_ROM_PTR(&mod_heapq_heappop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_heapify), MP_ROM_PTR(&mod_heapq_heapify_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_heapq_globals, mp_module_heapq_globals_table);\n\nconst mp_obj_module_t mp_module_heapq = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_heapq_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_heapq, mp_module_heapq);\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}