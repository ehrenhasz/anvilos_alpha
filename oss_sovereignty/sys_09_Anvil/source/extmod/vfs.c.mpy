{
  "module_name": "vfs.c",
  "hash_id": "ae833ede84bd9b00257cab38ad2485f6cdfabcc762512ba4b2c85032d27a145b",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/objstr.h\"\n#include \"py/mperrno.h\"\n#include \"extmod/vfs.h\"\n\n#if MICROPY_VFS\n\n#if MICROPY_VFS_FAT\n#include \"extmod/vfs_fat.h\"\n#endif\n\n#if MICROPY_VFS_LFS1 || MICROPY_VFS_LFS2\n#include \"extmod/vfs_lfs.h\"\n#endif\n\n#if MICROPY_VFS_POSIX\n#include \"extmod/vfs_posix.h\"\n#endif\n\n\n\n#define PROXY_MAX_ARGS (2)\n\n\n\n\n\nmp_vfs_mount_t *mp_vfs_lookup_path(const char *path, const char **path_out) {\n    if (*path == '/' || MP_STATE_VM(vfs_cur) == MP_VFS_ROOT) {\n        \n        bool is_abs = 0;\n        if (*path == '/') {\n            ++path;\n            is_abs = 1;\n        }\n        if (*path == '\\0') {\n            \n            return MP_VFS_ROOT;\n        }\n        for (mp_vfs_mount_t *vfs = MP_STATE_VM(vfs_mount_table); vfs != NULL; vfs = vfs->next) {\n            size_t len = vfs->len - 1;\n            if (len == 0) {\n                *path_out = path - is_abs;\n                return vfs;\n            }\n            if (strncmp(path, vfs->str + 1, len) == 0) {\n                if (path[len] == '/') {\n                    *path_out = path + len;\n                    return vfs;\n                } else if (path[len] == '\\0') {\n                    *path_out = \"/\";\n                    return vfs;\n                }\n            }\n        }\n\n        \n        return MP_VFS_NONE;\n    }\n\n    \n    *path_out = path;\n    return MP_STATE_VM(vfs_cur);\n}\n\n\nstatic mp_vfs_mount_t *lookup_path(mp_obj_t path_in, mp_obj_t *path_out) {\n    const char *path = mp_obj_str_get_str(path_in);\n    const char *p_out;\n    mp_vfs_mount_t *vfs = mp_vfs_lookup_path(path, &p_out);\n    if (vfs != MP_VFS_NONE && vfs != MP_VFS_ROOT) {\n        *path_out = mp_obj_new_str_of_type(mp_obj_get_type(path_in),\n            (const byte *)p_out, strlen(p_out));\n    } else {\n        *path_out = MP_OBJ_NULL;\n    }\n    return vfs;\n}\n\nstatic mp_obj_t mp_vfs_proxy_call(mp_vfs_mount_t *vfs, qstr meth_name, size_t n_args, const mp_obj_t *args) {\n    assert(n_args <= PROXY_MAX_ARGS);\n    if (vfs == MP_VFS_NONE) {\n        \n        mp_raise_OSError(MP_ENODEV);\n    }\n    if (vfs == MP_VFS_ROOT) {\n        \n        mp_raise_OSError(MP_EPERM);\n    }\n    mp_obj_t meth[2 + PROXY_MAX_ARGS];\n    mp_load_method(vfs->obj, meth_name, meth);\n    if (args != NULL) {\n        memcpy(meth + 2, args, n_args * sizeof(*args));\n    }\n    return mp_call_method_n_kw(n_args, 0, meth);\n}\n\nmp_import_stat_t mp_vfs_import_stat(const char *path) {\n    const char *path_out;\n    mp_vfs_mount_t *vfs = mp_vfs_lookup_path(path, &path_out);\n    if (vfs == MP_VFS_NONE || vfs == MP_VFS_ROOT) {\n        return MP_IMPORT_STAT_NO_EXIST;\n    }\n\n    \n    const mp_obj_type_t *type = mp_obj_get_type(vfs->obj);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, protocol)) {\n        const mp_vfs_proto_t *proto = MP_OBJ_TYPE_GET_SLOT(type, protocol);\n        return proto->import_stat(MP_OBJ_TO_PTR(vfs->obj), path_out);\n    }\n\n    \n    mp_obj_t path_o = mp_obj_new_str(path_out, strlen(path_out));\n    mp_obj_t stat;\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        stat = mp_vfs_proxy_call(vfs, MP_QSTR_stat, 1, &path_o);\n        nlr_pop();\n    } else {\n        \n        return MP_IMPORT_STAT_NO_EXIST;\n    }\n    mp_obj_t *items;\n    mp_obj_get_array_fixed_n(stat, 10, &items);\n    mp_int_t st_mode = mp_obj_get_int(items[0]);\n    if (st_mode & MP_S_IFDIR) {\n        return MP_IMPORT_STAT_DIR;\n    } else {\n        return MP_IMPORT_STAT_FILE;\n    }\n}\n\nstatic mp_obj_t mp_vfs_autodetect(mp_obj_t bdev_obj) {\n    #if MICROPY_VFS_LFS1 || MICROPY_VFS_LFS2\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        \n        \n        mp_vfs_blockdev_t blockdev;\n        mp_vfs_blockdev_init(&blockdev, bdev_obj);\n        uint8_t buf[44];\n        for (size_t block_num = 0; block_num <= 1; ++block_num) {\n            mp_vfs_blockdev_read_ext(&blockdev, block_num, 8, sizeof(buf), buf);\n            #if MICROPY_VFS_LFS1\n            if (memcmp(&buf[32], \"littlefs\", 8) == 0) {\n                \n                mp_obj_t vfs = MP_OBJ_TYPE_GET_SLOT(&mp_type_vfs_lfs1, make_new)(&mp_type_vfs_lfs1, 1, 0, &bdev_obj);\n                nlr_pop();\n                return vfs;\n            }\n            #endif\n            #if MICROPY_VFS_LFS2\n            if (memcmp(&buf[0], \"littlefs\", 8) == 0) {\n                \n                mp_obj_t vfs = MP_OBJ_TYPE_GET_SLOT(&mp_type_vfs_lfs2, make_new)(&mp_type_vfs_lfs2, 1, 0, &bdev_obj);\n                nlr_pop();\n                return vfs;\n            }\n            #endif\n        }\n        nlr_pop();\n    } else {\n        \n    }\n    #endif\n\n    #if MICROPY_VFS_FAT\n    return MP_OBJ_TYPE_GET_SLOT(&mp_fat_vfs_type, make_new)(&mp_fat_vfs_type, 1, 0, &bdev_obj);\n    #endif\n\n    \n    mp_raise_OSError(MP_ENODEV);\n}\n\nmp_obj_t mp_vfs_mount(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_readonly, ARG_mkfs };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_readonly, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_FALSE} },\n        { MP_QSTR_mkfs, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_FALSE} },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 2, pos_args + 2, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    size_t mnt_len;\n    const char *mnt_str = mp_obj_str_get_data(pos_args[1], &mnt_len);\n\n    \n    mp_obj_t vfs_obj = pos_args[0];\n    mp_obj_t dest[2];\n    mp_load_method_maybe(vfs_obj, MP_QSTR_mount, dest);\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        \n        vfs_obj = mp_vfs_autodetect(vfs_obj);\n    }\n\n    \n    mp_vfs_mount_t *vfs = m_new_obj(mp_vfs_mount_t);\n    vfs->str = mnt_str;\n    vfs->len = mnt_len;\n    vfs->obj = vfs_obj;\n    vfs->next = NULL;\n\n    \n    mp_vfs_proxy_call(vfs, MP_QSTR_mount, 2, (mp_obj_t *)&args);\n\n    \n    const char *path_out;\n    mp_vfs_mount_t *existing_mount = mp_vfs_lookup_path(mp_obj_str_get_str(pos_args[1]), &path_out);\n    if (existing_mount != MP_VFS_NONE && existing_mount != MP_VFS_ROOT) {\n        if (vfs->len != 1 && existing_mount->len == 1) {\n            \n        } else {\n            \n            mp_raise_OSError(MP_EPERM);\n        }\n    }\n\n    \n    mp_vfs_mount_t **vfsp = &MP_STATE_VM(vfs_mount_table);\n    while (*vfsp != NULL) {\n        if ((*vfsp)->len == 1) {\n            \n            vfs->next = *vfsp;\n            break;\n        }\n        vfsp = &(*vfsp)->next;\n    }\n    *vfsp = vfs;\n\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_vfs_mount_obj, 2, mp_vfs_mount);\n\nmp_obj_t mp_vfs_umount(mp_obj_t mnt_in) {\n    \n    mp_vfs_mount_t *vfs = NULL;\n    size_t mnt_len;\n    const char *mnt_str = NULL;\n    if (mp_obj_is_str(mnt_in)) {\n        mnt_str = mp_obj_str_get_data(mnt_in, &mnt_len);\n    }\n    for (mp_vfs_mount_t **vfsp = &MP_STATE_VM(vfs_mount_table); *vfsp != NULL; vfsp = &(*vfsp)->next) {\n        if ((mnt_str != NULL && !memcmp(mnt_str, (*vfsp)->str, mnt_len + 1)) || (*vfsp)->obj == mnt_in) {\n            vfs = *vfsp;\n            *vfsp = (*vfsp)->next;\n            break;\n        }\n    }\n\n    if (vfs == NULL) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n\n    \n    if (MP_STATE_VM(vfs_cur) == vfs) {\n        MP_STATE_VM(vfs_cur) = MP_VFS_ROOT;\n    }\n\n    \n    mp_vfs_proxy_call(vfs, MP_QSTR_umount, 0, NULL);\n\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_umount_obj, mp_vfs_umount);\n\n\nmp_obj_t mp_vfs_open(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_file, ARG_mode, ARG_encoding };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_file, MP_ARG_OBJ | MP_ARG_REQUIRED, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_mode, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_QSTR(MP_QSTR_r)} },\n        { MP_QSTR_buffering, MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_encoding, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    #if MICROPY_VFS_POSIX\n    \n    if (mp_obj_is_small_int(args[ARG_file].u_obj)) {\n        return mp_vfs_posix_file_open(&mp_type_vfs_posix_textio, args[ARG_file].u_obj, args[ARG_mode].u_obj);\n    }\n    #endif\n\n    mp_vfs_mount_t *vfs = lookup_path(args[ARG_file].u_obj, &args[ARG_file].u_obj);\n    return mp_vfs_proxy_call(vfs, MP_QSTR_open, 2, (mp_obj_t *)&args);\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_vfs_open_obj, 0, mp_vfs_open);\n\nmp_obj_t mp_vfs_chdir(mp_obj_t path_in) {\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n    if (vfs == MP_VFS_ROOT) {\n        \n        \n        \n        for (vfs = MP_STATE_VM(vfs_mount_table); vfs != NULL; vfs = vfs->next) {\n            if (vfs->len == 1) {\n                mp_obj_t root = MP_OBJ_NEW_QSTR(MP_QSTR__slash_);\n                mp_vfs_proxy_call(vfs, MP_QSTR_chdir, 1, &root);\n                break;\n            }\n        }\n        vfs = MP_VFS_ROOT;\n    } else {\n        mp_vfs_proxy_call(vfs, MP_QSTR_chdir, 1, &path_out);\n    }\n    MP_STATE_VM(vfs_cur) = vfs;\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_chdir_obj, mp_vfs_chdir);\n\nmp_obj_t mp_vfs_getcwd(void) {\n    if (MP_STATE_VM(vfs_cur) == MP_VFS_ROOT) {\n        return MP_OBJ_NEW_QSTR(MP_QSTR__slash_);\n    }\n    mp_obj_t cwd_o = mp_vfs_proxy_call(MP_STATE_VM(vfs_cur), MP_QSTR_getcwd, 0, NULL);\n    if (MP_STATE_VM(vfs_cur)->len == 1) {\n        \n        return cwd_o;\n    }\n    const char *cwd = mp_obj_str_get_str(cwd_o);\n    vstr_t vstr;\n    vstr_init(&vstr, MP_STATE_VM(vfs_cur)->len + strlen(cwd) + 1);\n    vstr_add_strn(&vstr, MP_STATE_VM(vfs_cur)->str, MP_STATE_VM(vfs_cur)->len);\n    if (!(cwd[0] == '/' && cwd[1] == 0)) {\n        vstr_add_str(&vstr, cwd);\n    }\n    return mp_obj_new_str_from_vstr(&vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_vfs_getcwd_obj, mp_vfs_getcwd);\n\ntypedef struct _mp_vfs_ilistdir_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    union {\n        mp_vfs_mount_t *vfs;\n        mp_obj_t iter;\n    } cur;\n    bool is_str;\n    bool is_iter;\n} mp_vfs_ilistdir_it_t;\n\nstatic mp_obj_t mp_vfs_ilistdir_it_iternext(mp_obj_t self_in) {\n    mp_vfs_ilistdir_it_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->is_iter) {\n        \n        return mp_iternext(self->cur.iter);\n    } else if (self->cur.vfs == NULL) {\n        \n        return MP_OBJ_STOP_ITERATION;\n    } else {\n        \n        mp_vfs_mount_t *vfs = self->cur.vfs;\n        self->cur.vfs = vfs->next;\n        if (vfs->len == 1) {\n            \n            mp_obj_t root = MP_OBJ_NEW_QSTR(MP_QSTR__slash_);\n            self->is_iter = true;\n            self->cur.iter = mp_vfs_proxy_call(vfs, MP_QSTR_ilistdir, 1, &root);\n            return mp_iternext(self->cur.iter);\n        } else {\n            \n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(3, NULL));\n            t->items[0] = mp_obj_new_str_of_type(\n                self->is_str ? &mp_type_str : &mp_type_bytes,\n                (const byte *)vfs->str + 1, vfs->len - 1);\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(MP_S_IFDIR);\n            t->items[2] = MP_OBJ_NEW_SMALL_INT(0); \n            return MP_OBJ_FROM_PTR(t);\n        }\n    }\n}\n\nmp_obj_t mp_vfs_ilistdir(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t path_in;\n    if (n_args == 1) {\n        path_in = args[0];\n    } else {\n        path_in = MP_OBJ_NEW_QSTR(MP_QSTR_);\n    }\n\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n\n    if (vfs == MP_VFS_ROOT) {\n        \n        mp_vfs_ilistdir_it_t *iter = mp_obj_malloc(mp_vfs_ilistdir_it_t, &mp_type_polymorph_iter);\n        iter->iternext = mp_vfs_ilistdir_it_iternext;\n        iter->cur.vfs = MP_STATE_VM(vfs_mount_table);\n        iter->is_str = mp_obj_get_type(path_in) == &mp_type_str;\n        iter->is_iter = false;\n        return MP_OBJ_FROM_PTR(iter);\n    }\n\n    return mp_vfs_proxy_call(vfs, MP_QSTR_ilistdir, 1, &path_out);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_vfs_ilistdir_obj, 0, 1, mp_vfs_ilistdir);\n\nmp_obj_t mp_vfs_listdir(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t iter = mp_vfs_ilistdir(n_args, args);\n    mp_obj_t dir_list = mp_obj_new_list(0, NULL);\n    mp_obj_t next;\n    while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        mp_obj_list_append(dir_list, mp_obj_subscr(next, MP_OBJ_NEW_SMALL_INT(0), MP_OBJ_SENTINEL));\n    }\n    return dir_list;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_vfs_listdir_obj, 0, 1, mp_vfs_listdir);\n\nmp_obj_t mp_vfs_mkdir(mp_obj_t path_in) {\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n    if (vfs == MP_VFS_ROOT || (vfs != MP_VFS_NONE && !strcmp(mp_obj_str_get_str(path_out), \"/\"))) {\n        mp_raise_OSError(MP_EEXIST);\n    }\n    return mp_vfs_proxy_call(vfs, MP_QSTR_mkdir, 1, &path_out);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_mkdir_obj, mp_vfs_mkdir);\n\nmp_obj_t mp_vfs_remove(mp_obj_t path_in) {\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n    return mp_vfs_proxy_call(vfs, MP_QSTR_remove, 1, &path_out);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_remove_obj, mp_vfs_remove);\n\nmp_obj_t mp_vfs_rename(mp_obj_t old_path_in, mp_obj_t new_path_in) {\n    mp_obj_t args[2];\n    mp_vfs_mount_t *old_vfs = lookup_path(old_path_in, &args[0]);\n    mp_vfs_mount_t *new_vfs = lookup_path(new_path_in, &args[1]);\n    if (old_vfs != new_vfs) {\n        \n        mp_raise_OSError(MP_EPERM);\n    }\n    return mp_vfs_proxy_call(old_vfs, MP_QSTR_rename, 2, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_vfs_rename_obj, mp_vfs_rename);\n\nmp_obj_t mp_vfs_rmdir(mp_obj_t path_in) {\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n    return mp_vfs_proxy_call(vfs, MP_QSTR_rmdir, 1, &path_out);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_rmdir_obj, mp_vfs_rmdir);\n\nmp_obj_t mp_vfs_stat(mp_obj_t path_in) {\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n    if (vfs == MP_VFS_ROOT) {\n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n        t->items[0] = MP_OBJ_NEW_SMALL_INT(MP_S_IFDIR); \n        for (int i = 1; i <= 9; ++i) {\n            t->items[i] = MP_OBJ_NEW_SMALL_INT(0); \n        }\n        return MP_OBJ_FROM_PTR(t);\n    }\n    return mp_vfs_proxy_call(vfs, MP_QSTR_stat, 1, &path_out);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_stat_obj, mp_vfs_stat);\n\nmp_obj_t mp_vfs_statvfs(mp_obj_t path_in) {\n    mp_obj_t path_out;\n    mp_vfs_mount_t *vfs = lookup_path(path_in, &path_out);\n    if (vfs == MP_VFS_ROOT) {\n        \n        for (vfs = MP_STATE_VM(vfs_mount_table); vfs != NULL; vfs = vfs->next) {\n            if (vfs->len == 1) {\n                break;\n            }\n        }\n\n        \n        if (vfs == NULL) {\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n\n            \n            for (int i = 0; i <= 8; ++i) {\n                t->items[i] = MP_OBJ_NEW_SMALL_INT(0);\n            }\n\n            \n            t->items[9] = MP_OBJ_NEW_SMALL_INT(MICROPY_ALLOC_PATH_MAX);\n\n            return MP_OBJ_FROM_PTR(t);\n        }\n\n        \n        path_out = MP_OBJ_NEW_QSTR(MP_QSTR__slash_);\n    }\n    return mp_vfs_proxy_call(vfs, MP_QSTR_statvfs, 1, &path_out);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_vfs_statvfs_obj, mp_vfs_statvfs);\n\n\nint mp_vfs_mount_and_chdir_protected(mp_obj_t bdev, mp_obj_t mount_point) {\n    nlr_buf_t nlr;\n    mp_int_t ret = -MP_EIO;\n    if (nlr_push(&nlr) == 0) {\n        mp_obj_t args[] = { bdev, mount_point };\n        mp_vfs_mount(2, args, (mp_map_t *)&mp_const_empty_map);\n        mp_vfs_chdir(mount_point);\n        ret = 0; \n        nlr_pop();\n    } else {\n        mp_obj_base_t *exc = nlr.ret_val;\n        if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(exc->type), MP_OBJ_FROM_PTR(&mp_type_OSError))) {\n            mp_obj_t v = mp_obj_exception_get_value(MP_OBJ_FROM_PTR(exc));\n            mp_obj_get_int_maybe(v, &ret); \n            ret = -ret;\n        }\n    }\n    return ret;\n}\n\nMP_REGISTER_ROOT_POINTER(struct _mp_vfs_mount_t *vfs_cur);\nMP_REGISTER_ROOT_POINTER(struct _mp_vfs_mount_t *vfs_mount_table);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}