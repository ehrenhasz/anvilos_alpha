{
  "module_name": "modbluetooth.c",
  "hash_id": "3fcb7bc35862c71bb6a84324c12d719c96cebb8a4f74d3142b9fdbfee241f9b7",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modbluetooth.c",
  "human_readable_source": " \n\n#include \"py/binary.h\"\n#include \"py/gc.h\"\n#include \"py/misc.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n#include \"py/obj.h\"\n#include \"py/objarray.h\"\n#include \"py/qstr.h\"\n#include \"py/runtime.h\"\n#include \"extmod/modbluetooth.h\"\n#include <string.h>\n\n#if MICROPY_PY_BLUETOOTH\n\n#if !MICROPY_ENABLE_SCHEDULER\n#error modbluetooth requires MICROPY_ENABLE_SCHEDULER\n#endif\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS && !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n#error l2cap channels require synchronous modbluetooth events\n#endif\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING && !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n#error pairing and bonding require synchronous modbluetooth events\n#endif\n\n\n#define MICROPY_PY_BLUETOOTH_USE_GATTC_EVENT_DATA_REASSEMBLY MICROPY_BLUETOOTH_NIMBLE\n\n#define MP_BLUETOOTH_CONNECT_DEFAULT_SCAN_DURATION_MS 2000\n\n#define MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_TUPLE_LEN 5\n\n#if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n\n\n#define MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_BYTES_LEN(ringbuf_size) (MAX((int)((ringbuf_size) / 2), (int)(ringbuf_size) - 64))\n#endif\n\n\n\ntypedef struct {\n    mp_obj_base_t base;\n    mp_obj_t irq_handler;\n    #if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n    bool irq_scheduled;\n    mp_obj_t irq_data_tuple;\n    uint8_t irq_data_addr_bytes[6];\n    uint16_t irq_data_data_alloc;\n    mp_obj_array_t irq_data_addr;\n    mp_obj_array_t irq_data_data;\n    mp_obj_bluetooth_uuid_t irq_data_uuid;\n    ringbuf_t ringbuf;\n    #endif\n} mp_obj_bluetooth_ble_t;\n\nstatic const mp_obj_type_t mp_type_bluetooth_ble;\n\n\nstatic mp_obj_t bluetooth_handle_errno(int err) {\n    if (err != 0) {\n        mp_raise_OSError(err);\n    }\n    return mp_const_none;\n}\n\n\n\n\n\nstatic mp_obj_t bluetooth_uuid_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {\n    (void)type;\n\n    mp_arg_check_num(n_args, n_kw, 1, 1, false);\n\n    mp_obj_bluetooth_uuid_t *self = mp_obj_malloc(mp_obj_bluetooth_uuid_t, &mp_type_bluetooth_uuid);\n\n    if (mp_obj_is_int(all_args[0])) {\n        self->type = MP_BLUETOOTH_UUID_TYPE_16;\n        mp_int_t value = mp_obj_get_int(all_args[0]);\n        if (value > 65535) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid UUID\"));\n        }\n        self->data[0] = value & 0xff;\n        self->data[1] = (value >> 8) & 0xff;\n    } else {\n        mp_buffer_info_t uuid_bufinfo = {0};\n        mp_get_buffer_raise(all_args[0], &uuid_bufinfo, MP_BUFFER_READ);\n        if (uuid_bufinfo.len == 2 || uuid_bufinfo.len == 4 || uuid_bufinfo.len == 16) {\n            \n            self->type = uuid_bufinfo.len;\n            memcpy(self->data, uuid_bufinfo.buf, self->type);\n        } else {\n            \n            self->type = MP_BLUETOOTH_UUID_TYPE_128;\n            int uuid_i = 32;\n            for (size_t i = 0; i < uuid_bufinfo.len; i++) {\n                char c = ((char *)uuid_bufinfo.buf)[i];\n                if (c == '-') {\n                    continue;\n                }\n                if (!unichar_isxdigit(c)) {\n                    mp_raise_ValueError(MP_ERROR_TEXT(\"invalid char in UUID\"));\n                }\n                c = unichar_xdigit_value(c);\n                uuid_i--;\n                if (uuid_i < 0) {\n                    mp_raise_ValueError(MP_ERROR_TEXT(\"UUID too long\"));\n                }\n                if (uuid_i % 2 == 0) {\n                    \n                    self->data[uuid_i / 2] |= c;\n                } else {\n                    \n                    self->data[uuid_i / 2] = c << 4;\n                }\n            }\n            if (uuid_i > 0) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"UUID too short\"));\n            }\n        }\n    }\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_obj_t bluetooth_uuid_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_bluetooth_uuid_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_HASH: {\n            \n            return MP_OBJ_NEW_SMALL_INT(qstr_compute_hash(self->data, self->type));\n        }\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_obj_t bluetooth_uuid_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    if (!mp_obj_is_type(rhs_in, &mp_type_bluetooth_uuid)) {\n        return MP_OBJ_NULL;\n    }\n\n    mp_obj_bluetooth_uuid_t *lhs = MP_OBJ_TO_PTR(lhs_in);\n    mp_obj_bluetooth_uuid_t *rhs = MP_OBJ_TO_PTR(rhs_in);\n    switch (op) {\n        case MP_BINARY_OP_EQUAL:\n        case MP_BINARY_OP_LESS:\n        case MP_BINARY_OP_LESS_EQUAL:\n        case MP_BINARY_OP_MORE:\n        case MP_BINARY_OP_MORE_EQUAL:\n            if (lhs->type == rhs->type) {\n                return mp_obj_new_bool(mp_seq_cmp_bytes(op, lhs->data, lhs->type, rhs->data, rhs->type));\n            } else {\n                return mp_binary_op(op, MP_OBJ_NEW_SMALL_INT(lhs->type), MP_OBJ_NEW_SMALL_INT(rhs->type));\n            }\n\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\nstatic void bluetooth_uuid_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n\n    mp_obj_bluetooth_uuid_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"UUID(%s\", self->type <= 4 ? \"0x\" : \"'\");\n    for (int i = 0; i < self->type; ++i) {\n        if (i == 4 || i == 6 || i == 8 || i == 10) {\n            mp_printf(print, \"-\");\n        }\n        mp_printf(print, \"%02x\", self->data[self->type - 1 - i]);\n    }\n    if (self->type == MP_BLUETOOTH_UUID_TYPE_128) {\n        mp_printf(print, \"'\");\n    }\n    mp_printf(print, \")\");\n}\n\nstatic mp_int_t bluetooth_uuid_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    mp_obj_bluetooth_uuid_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (flags != MP_BUFFER_READ) {\n        return 1;\n    }\n\n    bufinfo->buf = self->data;\n    bufinfo->len = self->type;\n    bufinfo->typecode = 'B';\n    return 0;\n}\n\n#if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\nstatic void ringbuf_put_uuid(ringbuf_t *ringbuf, mp_obj_bluetooth_uuid_t *uuid) {\n    assert(ringbuf_free(ringbuf) >= (size_t)uuid->type + 1);\n    ringbuf_put(ringbuf, uuid->type);\n    for (int i = 0; i < uuid->type; ++i) {\n        ringbuf_put(ringbuf, uuid->data[i]);\n    }\n}\n#endif\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nstatic void ringbuf_get_uuid(ringbuf_t *ringbuf, mp_obj_bluetooth_uuid_t *uuid) {\n    assert(ringbuf_avail(ringbuf) >= 1);\n    uuid->type = ringbuf_get(ringbuf);\n    assert(ringbuf_avail(ringbuf) >= uuid->type);\n    for (int i = 0; i < uuid->type; ++i) {\n        uuid->data[i] = ringbuf_get(ringbuf);\n    }\n}\n#endif\n\n#endif \n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bluetooth_uuid,\n    MP_QSTR_UUID,\n    MP_TYPE_FLAG_NONE,\n    make_new, bluetooth_uuid_make_new,\n    unary_op, bluetooth_uuid_unary_op,\n    binary_op, bluetooth_uuid_binary_op,\n    print, bluetooth_uuid_print,\n    buffer, bluetooth_uuid_get_buffer\n    );\n\n\n\n\n\nstatic mp_obj_t bluetooth_ble_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {\n    (void)type;\n    (void)n_args;\n    (void)n_kw;\n    (void)all_args;\n    if (MP_STATE_VM(bluetooth) == MP_OBJ_NULL) {\n        mp_obj_bluetooth_ble_t *o = m_new0(mp_obj_bluetooth_ble_t, 1);\n        o->base.type = &mp_type_bluetooth_ble;\n\n        o->irq_handler = mp_const_none;\n\n        #if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n        \n        o->irq_data_tuple = mp_obj_new_tuple(MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_TUPLE_LEN, NULL);\n\n        \n        mp_obj_memoryview_init(&o->irq_data_addr, 'B', 0, 0, o->irq_data_addr_bytes);\n        o->irq_data_data_alloc = MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_BYTES_LEN(MICROPY_PY_BLUETOOTH_RINGBUF_SIZE);\n        mp_obj_memoryview_init(&o->irq_data_data, 'B', 0, 0, m_new(uint8_t, o->irq_data_data_alloc));\n        o->irq_data_uuid.base.type = &mp_type_bluetooth_uuid;\n\n        \n        ringbuf_alloc(&o->ringbuf, MICROPY_PY_BLUETOOTH_RINGBUF_SIZE);\n        #endif\n\n        MP_STATE_VM(bluetooth) = MP_OBJ_FROM_PTR(o);\n    }\n    return MP_STATE_VM(bluetooth);\n}\n\nstatic mp_obj_t bluetooth_ble_active(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 2) {\n        \n        if (mp_obj_is_true(args[1])) {\n            int err = mp_bluetooth_init();\n            bluetooth_handle_errno(err);\n        } else {\n            mp_bluetooth_deinit();\n        }\n    }\n    \n    return mp_obj_new_bool(mp_bluetooth_is_active());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_active_obj, 1, 2, bluetooth_ble_active);\n\nstatic mp_obj_t bluetooth_ble_config(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    if (kwargs->used == 0) {\n        \n        if (n_args != 2) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[1])) {\n            case MP_QSTR_gap_name: {\n                const uint8_t *buf;\n                size_t len = mp_bluetooth_gap_get_device_name(&buf);\n                return mp_obj_new_bytes(buf, len);\n            }\n            case MP_QSTR_mac: {\n                uint8_t addr_type;\n                uint8_t addr[6];\n                mp_bluetooth_get_current_address(&addr_type, addr);\n                mp_obj_t items[] = { MP_OBJ_NEW_SMALL_INT(addr_type), mp_obj_new_bytes(addr, MP_ARRAY_SIZE(addr)) };\n                return mp_obj_new_tuple(2, items);\n            }\n            #if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n            case MP_QSTR_rxbuf: {\n                mp_obj_bluetooth_ble_t *self = MP_OBJ_TO_PTR(args[0]);\n                return mp_obj_new_int(self->ringbuf.size);\n            }\n            #endif\n            case MP_QSTR_mtu:\n                return mp_obj_new_int(mp_bluetooth_get_preferred_mtu());\n            default:\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n        }\n    } else {\n        \n        if (n_args != 1) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't specify pos and kw args\"));\n        }\n\n        for (size_t i = 0; i < kwargs->alloc; ++i) {\n            if (MP_MAP_SLOT_IS_FILLED(kwargs, i)) {\n                mp_map_elem_t *e = &kwargs->table[i];\n                switch (mp_obj_str_get_qstr(e->key)) {\n                    case MP_QSTR_gap_name: {\n                        mp_buffer_info_t bufinfo;\n                        mp_get_buffer_raise(e->value, &bufinfo, MP_BUFFER_READ);\n                        bluetooth_handle_errno(mp_bluetooth_gap_set_device_name(bufinfo.buf, bufinfo.len));\n                        break;\n                    }\n                    #if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n                    case MP_QSTR_rxbuf: {\n                        \n                        mp_int_t ringbuf_alloc = mp_obj_get_int(e->value);\n                        if (ringbuf_alloc < 16 || ringbuf_alloc > 0xffff) {\n                            mp_raise_ValueError(NULL);\n                        }\n                        size_t irq_data_alloc = MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_BYTES_LEN(ringbuf_alloc);\n\n                        \n                        uint8_t *ringbuf = m_new(uint8_t, ringbuf_alloc);\n                        uint8_t *irq_data = m_new(uint8_t, irq_data_alloc);\n\n                        \n                        mp_obj_bluetooth_ble_t *self = MP_OBJ_TO_PTR(args[0]);\n                        uint8_t *old_ringbuf_buf = self->ringbuf.buf;\n                        size_t old_ringbuf_alloc = self->ringbuf.size;\n                        uint8_t *old_irq_data_buf = (uint8_t *)self->irq_data_data.items;\n                        size_t old_irq_data_alloc = self->irq_data_data_alloc;\n\n                        \n                        MICROPY_PY_BLUETOOTH_ENTER\n                        self->ringbuf.size = ringbuf_alloc;\n                        self->ringbuf.buf = ringbuf;\n                        self->ringbuf.iget = 0;\n                        self->ringbuf.iput = 0;\n                        self->irq_data_data_alloc = irq_data_alloc;\n                        self->irq_data_data.items = irq_data;\n                        MICROPY_PY_BLUETOOTH_EXIT\n\n                        \n                        m_del(uint8_t, old_ringbuf_buf, old_ringbuf_alloc);\n                        m_del(uint8_t, old_irq_data_buf, old_irq_data_alloc);\n                        break;\n                    }\n                    #endif\n                    case MP_QSTR_mtu: {\n                        mp_int_t mtu = mp_obj_get_int(e->value);\n                        bluetooth_handle_errno(mp_bluetooth_set_preferred_mtu(mtu));\n                        break;\n                    }\n                    case MP_QSTR_addr_mode: {\n                        mp_int_t addr_mode = mp_obj_get_int(e->value);\n                        mp_bluetooth_set_address_mode(addr_mode);\n                        break;\n                    }\n                    #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n                    case MP_QSTR_bond: {\n                        bool bonding_enabled = mp_obj_is_true(e->value);\n                        mp_bluetooth_set_bonding(bonding_enabled);\n                        break;\n                    }\n                    case MP_QSTR_mitm: {\n                        bool mitm_protection = mp_obj_is_true(e->value);\n                        mp_bluetooth_set_mitm_protection(mitm_protection);\n                        break;\n                    }\n                    case MP_QSTR_io: {\n                        mp_int_t io_capability = mp_obj_get_int(e->value);\n                        mp_bluetooth_set_io_capability(io_capability);\n                        break;\n                    }\n                    case MP_QSTR_le_secure: {\n                        bool le_secure_required = mp_obj_is_true(e->value);\n                        mp_bluetooth_set_le_secure(le_secure_required);\n                        break;\n                    }\n                    #endif \n                    default:\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n                }\n            }\n        }\n\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(bluetooth_ble_config_obj, 1, bluetooth_ble_config);\n\nstatic mp_obj_t bluetooth_ble_irq(mp_obj_t self_in, mp_obj_t handler_in) {\n    (void)self_in;\n    if (handler_in != mp_const_none && !mp_obj_is_callable(handler_in)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid handler\"));\n    }\n\n    \n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    o->irq_handler = handler_in;\n    MICROPY_PY_BLUETOOTH_EXIT\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bluetooth_ble_irq_obj, bluetooth_ble_irq);\n\n\n\n\n\nstatic mp_obj_t bluetooth_ble_gap_advertise(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_interval_us, ARG_adv_data, ARG_resp_data, ARG_connectable };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_interval_us, MP_ARG_OBJ, {.u_obj = MP_OBJ_NEW_SMALL_INT(500000)} },\n        { MP_QSTR_adv_data, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_resp_data, MP_ARG_OBJ | MP_ARG_KW_ONLY, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_connectable, MP_ARG_OBJ | MP_ARG_KW_ONLY, {.u_rom_obj = MP_ROM_TRUE} },\n    };\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    if (args[ARG_interval_us].u_obj == mp_const_none) {\n        mp_bluetooth_gap_advertise_stop();\n        return mp_const_none;\n    }\n\n    mp_int_t interval_us = mp_obj_get_int(args[ARG_interval_us].u_obj);\n    bool connectable = mp_obj_is_true(args[ARG_connectable].u_obj);\n\n    mp_buffer_info_t adv_bufinfo = {0};\n    if (args[ARG_adv_data].u_obj != mp_const_none) {\n        mp_get_buffer_raise(args[ARG_adv_data].u_obj, &adv_bufinfo, MP_BUFFER_READ);\n    }\n\n    mp_buffer_info_t resp_bufinfo = {0};\n    if (args[ARG_resp_data].u_obj != mp_const_none) {\n        mp_get_buffer_raise(args[ARG_resp_data].u_obj, &resp_bufinfo, MP_BUFFER_READ);\n    }\n\n    return bluetooth_handle_errno(mp_bluetooth_gap_advertise_start(connectable, interval_us, adv_bufinfo.buf, adv_bufinfo.len, resp_bufinfo.buf, resp_bufinfo.len));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(bluetooth_ble_gap_advertise_obj, 1, bluetooth_ble_gap_advertise);\n\nstatic int bluetooth_gatts_register_service(mp_obj_t uuid_in, mp_obj_t characteristics_in, uint16_t **handles, size_t *num_handles) {\n    if (!mp_obj_is_type(uuid_in, &mp_type_bluetooth_uuid)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid service UUID\"));\n    }\n    mp_obj_bluetooth_uuid_t *service_uuid = MP_OBJ_TO_PTR(uuid_in);\n\n    mp_obj_t len_in = mp_obj_len(characteristics_in);\n    size_t len = mp_obj_get_int(len_in);\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(characteristics_in, &iter_buf);\n    mp_obj_t characteristic_obj;\n\n    \n    mp_obj_bluetooth_uuid_t **characteristic_uuids = m_new(mp_obj_bluetooth_uuid_t *, len);\n    uint16_t *characteristic_flags = m_new(uint16_t, len);\n\n    \n    mp_obj_bluetooth_uuid_t **descriptor_uuids = NULL;\n    uint16_t *descriptor_flags = NULL;\n    \n    uint8_t *num_descriptors = m_new(uint8_t, len);\n\n    \n    \n    *num_handles = len;\n    *handles = m_new(uint16_t, *num_handles);\n\n    \n\n    int characteristic_index = 0; \n    int handle_index = 0; \n    int descriptor_index = 0; \n    while ((characteristic_obj = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        \n        size_t characteristic_len;\n        mp_obj_t *characteristic_items;\n        mp_obj_get_array(characteristic_obj, &characteristic_len, &characteristic_items);\n\n        if (characteristic_len < 2 || characteristic_len > 3) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid characteristic tuple\"));\n        }\n        mp_obj_t uuid_obj = characteristic_items[0];\n        if (!mp_obj_is_type(uuid_obj, &mp_type_bluetooth_uuid)) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid characteristic UUID\"));\n        }\n\n        (*handles)[handle_index++] = 0xffff;\n\n        \n        if (characteristic_len >= 3) {\n            mp_int_t n = mp_obj_get_int(mp_obj_len(characteristic_items[2]));\n            if (n) {\n                num_descriptors[characteristic_index] = n;\n\n                \n                descriptor_uuids = m_renew(mp_obj_bluetooth_uuid_t *, descriptor_uuids, descriptor_index, descriptor_index + num_descriptors[characteristic_index]);\n                descriptor_flags = m_renew(uint16_t, descriptor_flags, descriptor_index, descriptor_index + num_descriptors[characteristic_index]);\n\n                \n                *handles = m_renew(uint16_t, *handles, *num_handles, *num_handles + num_descriptors[characteristic_index]);\n\n                mp_obj_iter_buf_t iter_buf_desc;\n                mp_obj_t iterable_desc = mp_getiter(characteristic_items[2], &iter_buf_desc);\n                mp_obj_t descriptor_obj;\n\n                \n                while ((descriptor_obj = mp_iternext(iterable_desc)) != MP_OBJ_STOP_ITERATION) {\n                    \n                    mp_obj_t *descriptor_items;\n                    mp_obj_get_array_fixed_n(descriptor_obj, 2, &descriptor_items);\n                    mp_obj_t desc_uuid_obj = descriptor_items[0];\n                    if (!mp_obj_is_type(desc_uuid_obj, &mp_type_bluetooth_uuid)) {\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid descriptor UUID\"));\n                    }\n\n                    descriptor_uuids[descriptor_index] = MP_OBJ_TO_PTR(desc_uuid_obj);\n                    descriptor_flags[descriptor_index] = mp_obj_get_int(descriptor_items[1]);\n                    ++descriptor_index;\n\n                    (*handles)[handle_index++] = 0xffff;\n                }\n\n                \n                *num_handles += num_descriptors[characteristic_index];\n            }\n        }\n\n        characteristic_uuids[characteristic_index] = MP_OBJ_TO_PTR(uuid_obj);\n        characteristic_flags[characteristic_index] = mp_obj_get_int(characteristic_items[1]);\n        ++characteristic_index;\n    }\n\n    \n    return mp_bluetooth_gatts_register_service(service_uuid, characteristic_uuids, characteristic_flags, descriptor_uuids, descriptor_flags, num_descriptors, *handles, len);\n}\n\nstatic mp_obj_t bluetooth_ble_gatts_register_services(mp_obj_t self_in, mp_obj_t services_in) {\n    (void)self_in;\n    mp_obj_t len_in = mp_obj_len(services_in);\n    size_t len = mp_obj_get_int(len_in);\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(services_in, &iter_buf);\n    mp_obj_t service_tuple_obj;\n\n    mp_obj_tuple_t *result = MP_OBJ_TO_PTR(mp_obj_new_tuple(len, NULL));\n\n    uint16_t **handles = m_new0(uint16_t *, len);\n    size_t *num_handles = m_new0(size_t, len);\n\n    \n    bool append = false;\n    int err = mp_bluetooth_gatts_register_service_begin(append);\n    if (err != 0) {\n        return bluetooth_handle_errno(err);\n    }\n\n    size_t i = 0;\n    while ((service_tuple_obj = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        \n        mp_obj_t *service_items;\n        mp_obj_get_array_fixed_n(service_tuple_obj, 2, &service_items);\n        err = bluetooth_gatts_register_service(service_items[0], service_items[1], &handles[i], &num_handles[i]);\n        if (err != 0) {\n            return bluetooth_handle_errno(err);\n        }\n\n        ++i;\n    }\n\n    \n    err = mp_bluetooth_gatts_register_service_end();\n    if (err != 0) {\n        return bluetooth_handle_errno(err);\n    }\n\n    \n    \n    for (i = 0; i < len; ++i) {\n        mp_obj_tuple_t *service_handles = MP_OBJ_TO_PTR(mp_obj_new_tuple(num_handles[i], NULL));\n        for (size_t j = 0; j < num_handles[i]; ++j) {\n            service_handles->items[j] = MP_OBJ_NEW_SMALL_INT(handles[i][j]);\n        }\n        result->items[i] = MP_OBJ_FROM_PTR(service_handles);\n    }\n\n    \n    m_del(uint16_t *, handles, len);\n    m_del(size_t, num_handles, len);\n\n    return MP_OBJ_FROM_PTR(result);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bluetooth_ble_gatts_register_services_obj, bluetooth_ble_gatts_register_services);\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nstatic mp_obj_t bluetooth_ble_gap_connect(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 2) {\n        if (args[1] == mp_const_none) {\n            int err = mp_bluetooth_gap_peripheral_connect_cancel();\n            return bluetooth_handle_errno(err);\n        }\n        mp_raise_TypeError(MP_ERROR_TEXT(\"invalid addr\"));\n    }\n    uint8_t addr_type = mp_obj_get_int(args[1]);\n    mp_buffer_info_t bufinfo = {0};\n    mp_get_buffer_raise(args[2], &bufinfo, MP_BUFFER_READ);\n    if (bufinfo.len != 6) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid addr\"));\n    }\n    mp_int_t scan_duration_ms = MP_BLUETOOTH_CONNECT_DEFAULT_SCAN_DURATION_MS;\n    mp_int_t min_conn_interval_us = 0;\n    mp_int_t max_conn_interval_us = 0;\n    if (n_args >= 4 && args[3] != mp_const_none) {\n        scan_duration_ms = mp_obj_get_int(args[3]);\n    }\n    if (n_args >= 5 && args[4] != mp_const_none) {\n        min_conn_interval_us = mp_obj_get_int(args[4]);\n    }\n    if (n_args >= 6 && args[5] != mp_const_none) {\n        max_conn_interval_us = mp_obj_get_int(args[5]);\n    }\n\n    int err = mp_bluetooth_gap_peripheral_connect(addr_type, bufinfo.buf, scan_duration_ms, min_conn_interval_us, max_conn_interval_us);\n    return bluetooth_handle_errno(err);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gap_connect_obj, 2, 6, bluetooth_ble_gap_connect);\n\nstatic mp_obj_t bluetooth_ble_gap_scan(size_t n_args, const mp_obj_t *args) {\n    \n    mp_int_t duration_ms = 0;\n    mp_int_t interval_us = 1280000;\n    mp_int_t window_us = 11250;\n    bool active_scan = false;\n    if (n_args > 1) {\n        if (args[1] == mp_const_none) {\n            \n            return bluetooth_handle_errno(mp_bluetooth_gap_scan_stop());\n        }\n        duration_ms = mp_obj_get_int(args[1]);\n        if (n_args > 2) {\n            interval_us = mp_obj_get_int(args[2]);\n            if (n_args > 3) {\n                window_us = mp_obj_get_int(args[3]);\n                if (n_args > 4) {\n                    active_scan = mp_obj_is_true(args[4]);\n                }\n            }\n        }\n    }\n    return bluetooth_handle_errno(mp_bluetooth_gap_scan_start(duration_ms, interval_us, window_us, active_scan));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gap_scan_obj, 1, 5, bluetooth_ble_gap_scan);\n#endif \n\nstatic mp_obj_t bluetooth_ble_gap_disconnect(mp_obj_t self_in, mp_obj_t conn_handle_in) {\n    (void)self_in;\n    uint16_t conn_handle = mp_obj_get_int(conn_handle_in);\n    int err = mp_bluetooth_gap_disconnect(conn_handle);\n    if (err == 0) {\n        return mp_const_true;\n    } else if (err == MP_ENOTCONN) {\n        return mp_const_false;\n    } else {\n        return bluetooth_handle_errno(err);\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bluetooth_ble_gap_disconnect_obj, bluetooth_ble_gap_disconnect);\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nstatic mp_obj_t bluetooth_ble_gap_pair(mp_obj_t self_in, mp_obj_t conn_handle_in) {\n    (void)self_in;\n    uint16_t conn_handle = mp_obj_get_int(conn_handle_in);\n    return bluetooth_handle_errno(mp_bluetooth_gap_pair(conn_handle));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bluetooth_ble_gap_pair_obj, bluetooth_ble_gap_pair);\n\nstatic mp_obj_t bluetooth_ble_gap_passkey(size_t n_args, const mp_obj_t *args) {\n    uint16_t conn_handle = mp_obj_get_int(args[1]);\n    uint8_t action = mp_obj_get_int(args[2]);\n    mp_int_t passkey = mp_obj_get_int(args[3]);\n    return bluetooth_handle_errno(mp_bluetooth_gap_passkey(conn_handle, action, passkey));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gap_passkey_obj, 4, 4, bluetooth_ble_gap_passkey);\n#endif \n\n\n\n\n\nstatic mp_obj_t bluetooth_ble_gatts_read(mp_obj_t self_in, mp_obj_t value_handle_in) {\n    (void)self_in;\n    size_t len = 0;\n    const uint8_t *buf;\n    mp_bluetooth_gatts_read(mp_obj_get_int(value_handle_in), &buf, &len);\n    return mp_obj_new_bytes(buf, len);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bluetooth_ble_gatts_read_obj, bluetooth_ble_gatts_read);\n\nstatic mp_obj_t bluetooth_ble_gatts_write(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo = {0};\n    mp_get_buffer_raise(args[2], &bufinfo, MP_BUFFER_READ);\n    bool send_update = false;\n    if (n_args > 3) {\n        send_update = mp_obj_is_true(args[3]);\n    }\n    bluetooth_handle_errno(mp_bluetooth_gatts_write(mp_obj_get_int(args[1]), bufinfo.buf, bufinfo.len, send_update));\n    return MP_OBJ_NEW_SMALL_INT(bufinfo.len);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gatts_write_obj, 3, 4, bluetooth_ble_gatts_write);\n\nstatic mp_obj_t bluetooth_ble_gatts_notify_indicate(size_t n_args, const mp_obj_t *args, int gatts_op) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t value_handle = mp_obj_get_int(args[2]);\n\n    const uint8_t *value = NULL;\n    size_t value_len = 0;\n    if (n_args == 4 && args[3] != mp_const_none) {\n        mp_buffer_info_t bufinfo = {0};\n        mp_get_buffer_raise(args[3], &bufinfo, MP_BUFFER_READ);\n        value = bufinfo.buf;\n        value_len = bufinfo.len;\n    }\n    return bluetooth_handle_errno(mp_bluetooth_gatts_notify_indicate(conn_handle, value_handle, gatts_op, value, value_len));\n}\n\nstatic mp_obj_t bluetooth_ble_gatts_notify(size_t n_args, const mp_obj_t *args) {\n    return bluetooth_ble_gatts_notify_indicate(n_args, args, MP_BLUETOOTH_GATTS_OP_NOTIFY);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gatts_notify_obj, 3, 4, bluetooth_ble_gatts_notify);\n\nstatic mp_obj_t bluetooth_ble_gatts_indicate(size_t n_args, const mp_obj_t *args) {\n    return bluetooth_ble_gatts_notify_indicate(n_args, args, MP_BLUETOOTH_GATTS_OP_INDICATE);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gatts_indicate_obj, 3, 4, bluetooth_ble_gatts_indicate);\n\nstatic mp_obj_t bluetooth_ble_gatts_set_buffer(size_t n_args, const mp_obj_t *args) {\n    mp_int_t value_handle = mp_obj_get_int(args[1]);\n    mp_int_t len = mp_obj_get_int(args[2]);\n    bool append = n_args >= 4 && mp_obj_is_true(args[3]);\n    return bluetooth_handle_errno(mp_bluetooth_gatts_set_buffer(value_handle, len, append));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gatts_set_buffer_obj, 3, 4, bluetooth_ble_gatts_set_buffer);\n\n\n\n\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n\nstatic mp_obj_t bluetooth_ble_gattc_discover_services(size_t n_args, const mp_obj_t *args) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_obj_bluetooth_uuid_t *uuid = NULL;\n    if (n_args == 3 && args[2] != mp_const_none) {\n        if (!mp_obj_is_type(args[2], &mp_type_bluetooth_uuid)) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"UUID\"));\n        }\n        uuid = MP_OBJ_TO_PTR(args[2]);\n    }\n    return bluetooth_handle_errno(mp_bluetooth_gattc_discover_primary_services(conn_handle, uuid));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gattc_discover_services_obj, 2, 3, bluetooth_ble_gattc_discover_services);\n\nstatic mp_obj_t bluetooth_ble_gattc_discover_characteristics(size_t n_args, const mp_obj_t *args) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t start_handle = mp_obj_get_int(args[2]);\n    mp_int_t end_handle = mp_obj_get_int(args[3]);\n    mp_obj_bluetooth_uuid_t *uuid = NULL;\n    if (n_args == 5 && args[4] != mp_const_none) {\n        if (!mp_obj_is_type(args[4], &mp_type_bluetooth_uuid)) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"UUID\"));\n        }\n        uuid = MP_OBJ_TO_PTR(args[4]);\n    }\n    return bluetooth_handle_errno(mp_bluetooth_gattc_discover_characteristics(conn_handle, start_handle, end_handle, uuid));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gattc_discover_characteristics_obj, 4, 5, bluetooth_ble_gattc_discover_characteristics);\n\nstatic mp_obj_t bluetooth_ble_gattc_discover_descriptors(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t start_handle = mp_obj_get_int(args[2]);\n    mp_int_t end_handle = mp_obj_get_int(args[3]);\n    return bluetooth_handle_errno(mp_bluetooth_gattc_discover_descriptors(conn_handle, start_handle, end_handle));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gattc_discover_descriptors_obj, 4, 4, bluetooth_ble_gattc_discover_descriptors);\n\nstatic mp_obj_t bluetooth_ble_gattc_read(mp_obj_t self_in, mp_obj_t conn_handle_in, mp_obj_t value_handle_in) {\n    (void)self_in;\n    mp_int_t conn_handle = mp_obj_get_int(conn_handle_in);\n    mp_int_t value_handle = mp_obj_get_int(value_handle_in);\n    return bluetooth_handle_errno(mp_bluetooth_gattc_read(conn_handle, value_handle));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(bluetooth_ble_gattc_read_obj, bluetooth_ble_gattc_read);\n\nstatic mp_obj_t bluetooth_ble_gattc_write(size_t n_args, const mp_obj_t *args) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t value_handle = mp_obj_get_int(args[2]);\n    mp_obj_t data = args[3];\n    mp_buffer_info_t bufinfo = {0};\n    mp_get_buffer_raise(data, &bufinfo, MP_BUFFER_READ);\n    unsigned int mode = MP_BLUETOOTH_WRITE_MODE_NO_RESPONSE;\n    if (n_args == 5) {\n        mode = mp_obj_get_int(args[4]);\n    }\n    return bluetooth_handle_errno(mp_bluetooth_gattc_write(conn_handle, value_handle, bufinfo.buf, bufinfo.len, mode));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_gattc_write_obj, 4, 5, bluetooth_ble_gattc_write);\n\nstatic mp_obj_t bluetooth_ble_gattc_exchange_mtu(mp_obj_t self_in, mp_obj_t conn_handle_in) {\n    (void)self_in;\n    uint16_t conn_handle = mp_obj_get_int(conn_handle_in);\n    return bluetooth_handle_errno(mp_bluetooth_gattc_exchange_mtu(conn_handle));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bluetooth_ble_gattc_exchange_mtu_obj, bluetooth_ble_gattc_exchange_mtu);\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\n\nstatic mp_obj_t bluetooth_ble_l2cap_listen(mp_obj_t self_in, mp_obj_t psm_in, mp_obj_t mtu_in) {\n    (void)self_in;\n    mp_int_t psm = mp_obj_get_int(psm_in);\n    mp_int_t mtu = MAX(32, MIN(UINT16_MAX, mp_obj_get_int(mtu_in)));\n    return bluetooth_handle_errno(mp_bluetooth_l2cap_listen(psm, mtu));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(bluetooth_ble_l2cap_listen_obj, bluetooth_ble_l2cap_listen);\n\nstatic mp_obj_t bluetooth_ble_l2cap_connect(size_t n_args, const mp_obj_t *args) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t psm = mp_obj_get_int(args[2]);\n    mp_int_t mtu = MAX(32, MIN(UINT16_MAX, mp_obj_get_int(args[3])));\n    return bluetooth_handle_errno(mp_bluetooth_l2cap_connect(conn_handle, psm, mtu));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_l2cap_connect_obj, 4, 4, bluetooth_ble_l2cap_connect);\n\nstatic mp_obj_t bluetooth_ble_l2cap_disconnect(mp_obj_t self_in, mp_obj_t conn_handle_in, mp_obj_t cid_in) {\n    (void)self_in;\n    mp_int_t conn_handle = mp_obj_get_int(conn_handle_in);\n    mp_int_t cid = mp_obj_get_int(cid_in);\n    return bluetooth_handle_errno(mp_bluetooth_l2cap_disconnect(conn_handle, cid));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(bluetooth_ble_l2cap_disconnect_obj, bluetooth_ble_l2cap_disconnect);\n\nstatic mp_obj_t bluetooth_ble_l2cap_send(size_t n_args, const mp_obj_t *args) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t cid = mp_obj_get_int(args[2]);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[3], &bufinfo, MP_BUFFER_READ);\n    bool stalled = false;\n    bluetooth_handle_errno(mp_bluetooth_l2cap_send(conn_handle, cid, bufinfo.buf, bufinfo.len, &stalled));\n    \n    return mp_obj_new_bool(!stalled);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_l2cap_send_obj, 4, 4, bluetooth_ble_l2cap_send);\n\nstatic mp_obj_t bluetooth_ble_l2cap_recvinto(size_t n_args, const mp_obj_t *args) {\n    mp_int_t conn_handle = mp_obj_get_int(args[1]);\n    mp_int_t cid = mp_obj_get_int(args[2]);\n    mp_buffer_info_t bufinfo = {0};\n    if (args[3] != mp_const_none) {\n        mp_get_buffer_raise(args[3], &bufinfo, MP_BUFFER_WRITE);\n    }\n    bluetooth_handle_errno(mp_bluetooth_l2cap_recvinto(conn_handle, cid, bufinfo.buf, &bufinfo.len));\n    return MP_OBJ_NEW_SMALL_INT(bufinfo.len);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_l2cap_recvinto_obj, 4, 4, bluetooth_ble_l2cap_recvinto);\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_HCI_CMD\n\nstatic mp_obj_t bluetooth_ble_hci_cmd(size_t n_args, const mp_obj_t *args) {\n    mp_int_t ogf = mp_obj_get_int(args[1]);\n    mp_int_t ocf = mp_obj_get_int(args[2]);\n    mp_buffer_info_t bufinfo_request = {0};\n    mp_buffer_info_t bufinfo_response = {0};\n    mp_get_buffer_raise(args[3], &bufinfo_request, MP_BUFFER_READ);\n    mp_get_buffer_raise(args[4], &bufinfo_response, MP_BUFFER_WRITE);\n    uint8_t status = 0;\n    bluetooth_handle_errno(mp_bluetooth_hci_cmd(ogf, ocf, bufinfo_request.buf, bufinfo_request.len, bufinfo_response.buf, bufinfo_response.len, &status));\n    return MP_OBJ_NEW_SMALL_INT(status);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bluetooth_ble_hci_cmd_obj, 5, 5, bluetooth_ble_hci_cmd);\n\n#endif \n\n\n\n\n\nstatic const mp_rom_map_elem_t bluetooth_ble_locals_dict_table[] = {\n    \n    { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&bluetooth_ble_active_obj) },\n    { MP_ROM_QSTR(MP_QSTR_config), MP_ROM_PTR(&bluetooth_ble_config_obj) },\n    { MP_ROM_QSTR(MP_QSTR_irq), MP_ROM_PTR(&bluetooth_ble_irq_obj) },\n    \n    { MP_ROM_QSTR(MP_QSTR_gap_advertise), MP_ROM_PTR(&bluetooth_ble_gap_advertise_obj) },\n    #if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n    { MP_ROM_QSTR(MP_QSTR_gap_connect), MP_ROM_PTR(&bluetooth_ble_gap_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gap_scan), MP_ROM_PTR(&bluetooth_ble_gap_scan_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_gap_disconnect), MP_ROM_PTR(&bluetooth_ble_gap_disconnect_obj) },\n    #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n    { MP_ROM_QSTR(MP_QSTR_gap_pair), MP_ROM_PTR(&bluetooth_ble_gap_pair_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gap_passkey), MP_ROM_PTR(&bluetooth_ble_gap_passkey_obj) },\n    #endif\n    \n    { MP_ROM_QSTR(MP_QSTR_gatts_register_services), MP_ROM_PTR(&bluetooth_ble_gatts_register_services_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gatts_read), MP_ROM_PTR(&bluetooth_ble_gatts_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gatts_write), MP_ROM_PTR(&bluetooth_ble_gatts_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gatts_notify), MP_ROM_PTR(&bluetooth_ble_gatts_notify_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gatts_indicate), MP_ROM_PTR(&bluetooth_ble_gatts_indicate_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gatts_set_buffer), MP_ROM_PTR(&bluetooth_ble_gatts_set_buffer_obj) },\n    #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n    \n    { MP_ROM_QSTR(MP_QSTR_gattc_discover_services), MP_ROM_PTR(&bluetooth_ble_gattc_discover_services_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gattc_discover_characteristics), MP_ROM_PTR(&bluetooth_ble_gattc_discover_characteristics_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gattc_discover_descriptors), MP_ROM_PTR(&bluetooth_ble_gattc_discover_descriptors_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gattc_read), MP_ROM_PTR(&bluetooth_ble_gattc_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gattc_write), MP_ROM_PTR(&bluetooth_ble_gattc_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gattc_exchange_mtu), MP_ROM_PTR(&bluetooth_ble_gattc_exchange_mtu_obj) },\n    #endif\n    #if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\n    { MP_ROM_QSTR(MP_QSTR_l2cap_listen), MP_ROM_PTR(&bluetooth_ble_l2cap_listen_obj) },\n    { MP_ROM_QSTR(MP_QSTR_l2cap_connect), MP_ROM_PTR(&bluetooth_ble_l2cap_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_l2cap_disconnect), MP_ROM_PTR(&bluetooth_ble_l2cap_disconnect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_l2cap_send), MP_ROM_PTR(&bluetooth_ble_l2cap_send_obj) },\n    { MP_ROM_QSTR(MP_QSTR_l2cap_recvinto), MP_ROM_PTR(&bluetooth_ble_l2cap_recvinto_obj) },\n    #endif\n    #if MICROPY_PY_BLUETOOTH_ENABLE_HCI_CMD\n    { MP_ROM_QSTR(MP_QSTR_hci_cmd), MP_ROM_PTR(&bluetooth_ble_hci_cmd_obj) },\n    #endif\n};\nstatic MP_DEFINE_CONST_DICT(bluetooth_ble_locals_dict, bluetooth_ble_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bluetooth_ble,\n    MP_QSTR_BLE,\n    MP_TYPE_FLAG_NONE,\n    make_new, bluetooth_ble_make_new,\n    locals_dict, &bluetooth_ble_locals_dict\n    );\n\nstatic const mp_rom_map_elem_t mp_module_bluetooth_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_bluetooth) },\n    { MP_ROM_QSTR(MP_QSTR_BLE), MP_ROM_PTR(&mp_type_bluetooth_ble) },\n    { MP_ROM_QSTR(MP_QSTR_UUID), MP_ROM_PTR(&mp_type_bluetooth_uuid) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_FLAG_READ), MP_ROM_INT(MP_BLUETOOTH_CHARACTERISTIC_FLAG_READ) },\n    { MP_ROM_QSTR(MP_QSTR_FLAG_WRITE), MP_ROM_INT(MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE) },\n    { MP_ROM_QSTR(MP_QSTR_FLAG_NOTIFY), MP_ROM_INT(MP_BLUETOOTH_CHARACTERISTIC_FLAG_NOTIFY) },\n    { MP_ROM_QSTR(MP_QSTR_FLAG_INDICATE), MP_ROM_INT(MP_BLUETOOTH_CHARACTERISTIC_FLAG_INDICATE) },\n    { MP_ROM_QSTR(MP_QSTR_FLAG_WRITE_NO_RESPONSE), MP_ROM_INT(MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE_NO_RESPONSE) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_bluetooth_globals, mp_module_bluetooth_globals_table);\n\nconst mp_obj_module_t mp_module_bluetooth = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_bluetooth_globals,\n};\n\n\n\n\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_bluetooth, mp_module_bluetooth);\n\n\n\n#if !MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\nstatic void ringbuf_extract(ringbuf_t *ringbuf, mp_obj_tuple_t *data_tuple, size_t n_u16, size_t n_u8, mp_obj_array_t *bytes_addr, size_t n_i8, mp_obj_bluetooth_uuid_t *uuid, mp_obj_array_t *bytes_data) {\n    assert(ringbuf_avail(ringbuf) >= n_u16 * 2 + n_u8 + (bytes_addr ? 6 : 0) + n_i8 + (uuid ? 1 : 0) + (bytes_data ? 1 : 0));\n    size_t j = 0;\n\n    for (size_t i = 0; i < n_u16; ++i) {\n        data_tuple->items[j++] = MP_OBJ_NEW_SMALL_INT(ringbuf_get16(ringbuf));\n    }\n    for (size_t i = 0; i < n_u8; ++i) {\n        data_tuple->items[j++] = MP_OBJ_NEW_SMALL_INT(ringbuf_get(ringbuf));\n    }\n    if (bytes_addr) {\n        bytes_addr->len = 6;\n        for (size_t i = 0; i < bytes_addr->len; ++i) {\n            ((uint8_t *)bytes_addr->items)[i] = ringbuf_get(ringbuf);\n        }\n        data_tuple->items[j++] = MP_OBJ_FROM_PTR(bytes_addr);\n    }\n    for (size_t i = 0; i < n_i8; ++i) {\n        \n        data_tuple->items[j++] = MP_OBJ_NEW_SMALL_INT((int8_t)ringbuf_get(ringbuf));\n    }\n    #if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n    if (uuid) {\n        ringbuf_get_uuid(ringbuf, uuid);\n        data_tuple->items[j++] = MP_OBJ_FROM_PTR(uuid);\n    }\n    #endif\n    \n    \n    \n    if (bytes_data) {\n        bytes_data->len = ringbuf_get16(ringbuf);\n        for (size_t i = 0; i < bytes_data->len; ++i) {\n            ((uint8_t *)bytes_data->items)[i] = ringbuf_get(ringbuf);\n        }\n        data_tuple->items[j++] = MP_OBJ_FROM_PTR(bytes_data);\n    }\n\n    data_tuple->len = j;\n}\n\nstatic mp_obj_t bluetooth_ble_invoke_irq(mp_obj_t none_in) {\n    (void)none_in;\n    \n\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    o->irq_scheduled = false;\n\n    for (;;) {\n        MICROPY_PY_BLUETOOTH_ENTER\n\n        mp_int_t event = ringbuf_get(&o->ringbuf);\n        if (event < 0) {\n            \n            MICROPY_PY_BLUETOOTH_EXIT\n            break;\n        }\n\n        \n        \n        \n\n        mp_obj_t handler = handler = o->irq_handler;\n        mp_obj_tuple_t *data_tuple = MP_OBJ_TO_PTR(o->irq_data_tuple);\n\n        if (event == MP_BLUETOOTH_IRQ_CENTRAL_CONNECT || event == MP_BLUETOOTH_IRQ_PERIPHERAL_CONNECT || event == MP_BLUETOOTH_IRQ_CENTRAL_DISCONNECT || event == MP_BLUETOOTH_IRQ_PERIPHERAL_DISCONNECT) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 1, 1, &o->irq_data_addr, 0, NULL, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_CONNECTION_UPDATE) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 5, 0, NULL, 0, NULL, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTS_WRITE) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 2, 0, NULL, 0, NULL, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTS_INDICATE_DONE) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 2, 1, NULL, 0, NULL, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_MTU_EXCHANGED) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 2, 0, NULL, 0, NULL, NULL);\n        #if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n        } else if (event == MP_BLUETOOTH_IRQ_SCAN_RESULT) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 0, 1, &o->irq_data_addr, 2, NULL, &o->irq_data_data);\n        } else if (event == MP_BLUETOOTH_IRQ_SCAN_DONE) {\n            \n            data_tuple->len = 0;\n        #endif\n        #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n        } else if (event == MP_BLUETOOTH_IRQ_GATTC_SERVICE_RESULT) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 3, 0, NULL, 0, &o->irq_data_uuid, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTC_CHARACTERISTIC_RESULT) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 3, 1, NULL, 0, &o->irq_data_uuid, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTC_DESCRIPTOR_RESULT) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 2, 0, NULL, 0, &o->irq_data_uuid, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTC_SERVICE_DONE || event == MP_BLUETOOTH_IRQ_GATTC_CHARACTERISTIC_DONE || event == MP_BLUETOOTH_IRQ_GATTC_DESCRIPTOR_DONE) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 2, 0, NULL, 0, NULL, NULL);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTC_READ_RESULT || event == MP_BLUETOOTH_IRQ_GATTC_NOTIFY || event == MP_BLUETOOTH_IRQ_GATTC_INDICATE) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 2, 0, NULL, 0, NULL, &o->irq_data_data);\n        } else if (event == MP_BLUETOOTH_IRQ_GATTC_READ_DONE || event == MP_BLUETOOTH_IRQ_GATTC_WRITE_DONE) {\n            \n            ringbuf_extract(&o->ringbuf, data_tuple, 3, 0, NULL, 0, NULL, NULL);\n        #endif \n        }\n\n        MICROPY_PY_BLUETOOTH_EXIT\n\n        mp_call_function_2(handler, MP_OBJ_NEW_SMALL_INT(event), MP_OBJ_FROM_PTR(data_tuple));\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(bluetooth_ble_invoke_irq_obj, bluetooth_ble_invoke_irq);\n#endif \n\n\n\n\n\n#if MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n\nstatic mp_obj_t invoke_irq_handler_run(uint16_t event,\n    const mp_int_t *numeric, size_t n_unsigned, size_t n_signed,\n    const uint8_t *addr,\n    const mp_obj_bluetooth_uuid_t *uuid,\n    const uint8_t **data, uint16_t *data_len, size_t n_data) {\n\n    mp_obj_array_t mv_addr;\n    mp_obj_array_t mv_data[2];\n    assert(n_data <= 2);\n\n    mp_obj_tuple_t *data_tuple = mp_local_alloc(sizeof(mp_obj_tuple_t) + sizeof(mp_obj_t) * MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_TUPLE_LEN);\n    data_tuple->base.type = &mp_type_tuple;\n    data_tuple->len = 0;\n\n    for (size_t i = 0; i < n_unsigned; ++i) {\n        data_tuple->items[data_tuple->len++] = MP_OBJ_NEW_SMALL_INT(numeric[i]);\n    }\n    if (addr) {\n        mp_obj_memoryview_init(&mv_addr, 'B', 0, 6, (void *)addr);\n        data_tuple->items[data_tuple->len++] = MP_OBJ_FROM_PTR(&mv_addr);\n    }\n    for (size_t i = 0; i < n_signed; ++i) {\n        data_tuple->items[data_tuple->len++] = MP_OBJ_NEW_SMALL_INT(numeric[i + n_unsigned]);\n    }\n    #if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n    if (uuid) {\n        data_tuple->items[data_tuple->len++] = MP_OBJ_FROM_PTR(uuid);\n    }\n    #endif\n\n    #if MICROPY_PY_BLUETOOTH_USE_GATTC_EVENT_DATA_REASSEMBLY\n    void *buf_to_free = NULL;\n    uint16_t buf_to_free_len = 0;\n    if (event == MP_BLUETOOTH_IRQ_GATTC_NOTIFY || event == MP_BLUETOOTH_IRQ_GATTC_INDICATE || event == MP_BLUETOOTH_IRQ_GATTC_READ_RESULT) {\n        if (n_data > 1) {\n            \n            \n            \n            uint16_t total_len = 0;\n            for (size_t i = 0; i < n_data; ++i) {\n                total_len += data_len[i];\n            }\n            uint8_t *buf = m_new(uint8_t, total_len);\n            uint8_t *p = buf;\n            for (size_t i = 0; i < n_data; ++i) {\n                memcpy(p, data[i], data_len[i]);\n                p += data_len[i];\n            }\n            data[0] = buf;\n            data_len[0] = total_len;\n            n_data = 1;\n            buf_to_free = buf;\n            buf_to_free_len = total_len;\n        }\n    }\n    #endif\n\n    for (size_t i = 0; i < n_data; ++i) {\n        if (data[i]) {\n            mp_obj_memoryview_init(&mv_data[i], 'B', 0, data_len[i], (void *)data[i]);\n            data_tuple->items[data_tuple->len++] = MP_OBJ_FROM_PTR(&mv_data[i]);\n        } else {\n            data_tuple->items[data_tuple->len++] = mp_const_none;\n        }\n    }\n\n    assert(data_tuple->len <= MICROPY_PY_BLUETOOTH_MAX_EVENT_DATA_TUPLE_LEN);\n\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    mp_obj_t result = mp_call_function_2(o->irq_handler, MP_OBJ_NEW_SMALL_INT(event), MP_OBJ_FROM_PTR(data_tuple));\n\n    #if MICROPY_PY_BLUETOOTH_USE_GATTC_EVENT_DATA_REASSEMBLY\n    if (buf_to_free != NULL) {\n        m_del(uint8_t, (uint8_t *)buf_to_free, buf_to_free_len);\n    }\n    #endif\n\n    mp_local_free(data_tuple);\n\n    return result;\n}\n\nstatic mp_obj_t invoke_irq_handler_run_protected(uint16_t event,\n    const mp_int_t *numeric, size_t n_unsigned, size_t n_signed,\n    const uint8_t *addr,\n    const mp_obj_bluetooth_uuid_t *uuid,\n    const uint8_t **data, uint16_t *data_len, size_t n_data) {\n\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (o->irq_handler == mp_const_none) {\n        return mp_const_none;\n    }\n\n    mp_obj_t result = mp_const_none;\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        result = invoke_irq_handler_run(event, numeric, n_unsigned, n_signed, addr, uuid, data, data_len, n_data);\n        nlr_pop();\n    } else {\n        \n        mp_printf(MICROPY_ERROR_PRINTER, \"Unhandled exception in IRQ callback handler\\n\");\n        mp_obj_print_exception(MICROPY_ERROR_PRINTER, MP_OBJ_FROM_PTR(nlr.ret_val));\n\n        \n        o->irq_handler = mp_const_none;\n    }\n\n    return result;\n}\n\n#if MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS_WITH_INTERLOCK\n\n\n\n\n\n#if MICROPY_ENABLE_PYSTACK\n#error not supported\n#endif\n\nstatic mp_obj_t invoke_irq_handler(uint16_t event,\n    const mp_int_t *numeric, size_t n_unsigned, size_t n_signed,\n    const uint8_t *addr,\n    const mp_obj_bluetooth_uuid_t *uuid,\n    const uint8_t **data, uint16_t *data_len, size_t n_data) {\n\n    \n    \n    \n    mp_state_thread_t *ts_orig = mp_thread_get_state();\n\n    mp_state_thread_t ts;\n    if (ts_orig == NULL) {\n        mp_thread_init_state(&ts, MICROPY_PY_BLUETOOTH_SYNC_EVENT_STACK_SIZE, NULL, NULL);\n        MP_THREAD_GIL_ENTER();\n    }\n\n    mp_sched_lock();\n    mp_obj_t result = invoke_irq_handler_run_protected(event, numeric, n_unsigned, n_signed, addr, uuid, data, data_len, n_data);\n    mp_sched_unlock();\n\n    if (ts_orig == NULL) {\n        MP_THREAD_GIL_EXIT();\n        mp_thread_set_state(ts_orig);\n    }\n\n    return result;\n}\n\n#else\n\n\n\n\nstatic mp_obj_t invoke_irq_handler(uint16_t event,\n    const mp_int_t *numeric, size_t n_unsigned, size_t n_signed,\n    const uint8_t *addr,\n    const mp_obj_bluetooth_uuid_t *uuid,\n    const uint8_t **data, uint16_t *data_len, size_t n_data) {\n    return invoke_irq_handler_run_protected(event, numeric, n_unsigned, n_signed, addr, uuid, data, data_len, n_data);\n}\n\n#endif\n\n#define NULL_NUMERIC NULL\n#define NULL_ADDR NULL\n#define NULL_UUID NULL\n#define NULL_DATA NULL\n#define NULL_DATA_LEN NULL\n\nvoid mp_bluetooth_gap_on_connected_disconnected(uint8_t event, uint16_t conn_handle, uint8_t addr_type, const uint8_t *addr) {\n    mp_int_t args[] = {conn_handle, addr_type};\n    invoke_irq_handler(event, args, 2, 0, addr, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gap_on_connection_update(uint16_t conn_handle, uint16_t conn_interval, uint16_t conn_latency, uint16_t supervision_timeout, uint16_t status) {\n    mp_int_t args[] = {conn_handle, conn_interval, conn_latency, supervision_timeout, status};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_CONNECTION_UPDATE, args, 5, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nvoid mp_bluetooth_gatts_on_encryption_update(uint16_t conn_handle, bool encrypted, bool authenticated, bool bonded, uint8_t key_size) {\n    mp_int_t args[] = {conn_handle, encrypted, authenticated, bonded, key_size};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_ENCRYPTION_UPDATE, args, 5, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nbool mp_bluetooth_gap_on_get_secret(uint8_t type, uint8_t index, const uint8_t *key, uint16_t key_len, const uint8_t **value, size_t *value_len) {\n    mp_int_t args[] = {type, index};\n    mp_obj_t result = invoke_irq_handler(MP_BLUETOOTH_IRQ_GET_SECRET, args, 2, 0, NULL_ADDR, NULL_UUID, &key, &key_len, 1);\n    if (result == mp_const_none) {\n        return false;\n    }\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(result, &bufinfo, MP_BUFFER_READ);\n    *value = bufinfo.buf;\n    *value_len = bufinfo.len;\n    return true;\n}\n\nbool mp_bluetooth_gap_on_set_secret(uint8_t type, const uint8_t *key, size_t key_len, const uint8_t *value, size_t value_len) {\n    mp_int_t args[] = { type };\n    const uint8_t *data[] = {key, value};\n    uint16_t data_len[] = {key_len, value_len};\n    mp_obj_t result = invoke_irq_handler(MP_BLUETOOTH_IRQ_SET_SECRET, args, 1, 0, NULL_ADDR, NULL_UUID, data, data_len, 2);\n    return mp_obj_is_true(result);\n}\n\nvoid mp_bluetooth_gap_on_passkey_action(uint16_t conn_handle, uint8_t action, mp_int_t passkey) {\n    mp_int_t args[] = { conn_handle, action, passkey };\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_PASSKEY_ACTION, args, 2, 1, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n#endif \n\nvoid mp_bluetooth_gatts_on_write(uint16_t conn_handle, uint16_t value_handle) {\n    mp_int_t args[] = {conn_handle, value_handle};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_GATTS_WRITE, args, 2, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gatts_on_indicate_complete(uint16_t conn_handle, uint16_t value_handle, uint8_t status) {\n    mp_int_t args[] = {conn_handle, value_handle, status};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_GATTS_INDICATE_DONE, args, 3, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nmp_int_t mp_bluetooth_gatts_on_read_request(uint16_t conn_handle, uint16_t value_handle) {\n    mp_int_t args[] = {conn_handle, value_handle};\n    mp_obj_t result = invoke_irq_handler(MP_BLUETOOTH_IRQ_GATTS_READ_REQUEST, args, 2, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n    \n    mp_int_t ret = 0;\n    mp_obj_get_int_maybe(result, &ret);\n    return ret;\n}\n\nvoid mp_bluetooth_gatts_on_mtu_exchanged(uint16_t conn_handle, uint16_t value) {\n    mp_int_t args[] = {conn_handle, value};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_MTU_EXCHANGED, args, 2, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\nmp_int_t mp_bluetooth_on_l2cap_accept(uint16_t conn_handle, uint16_t cid, uint16_t psm, uint16_t our_mtu, uint16_t peer_mtu) {\n    mp_int_t args[] = {conn_handle, cid, psm, our_mtu, peer_mtu};\n    mp_obj_t result = invoke_irq_handler(MP_BLUETOOTH_IRQ_L2CAP_ACCEPT, args, 5, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n    \n    mp_int_t ret = 0;\n    mp_obj_get_int_maybe(result, &ret);\n    return ret;\n}\n\nvoid mp_bluetooth_on_l2cap_connect(uint16_t conn_handle, uint16_t cid, uint16_t psm, uint16_t our_mtu, uint16_t peer_mtu) {\n    mp_int_t args[] = {conn_handle, cid, psm, our_mtu, peer_mtu};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_L2CAP_CONNECT, args, 5, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_on_l2cap_disconnect(uint16_t conn_handle, uint16_t cid, uint16_t psm, uint16_t status) {\n    mp_int_t args[] = {conn_handle, cid, psm, status};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_L2CAP_DISCONNECT, args, 4, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_on_l2cap_send_ready(uint16_t conn_handle, uint16_t cid, uint8_t status) {\n    mp_int_t args[] = {conn_handle, cid, status};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_L2CAP_SEND_READY, args, 3, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_on_l2cap_recv(uint16_t conn_handle, uint16_t cid) {\n    mp_int_t args[] = {conn_handle, cid};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_L2CAP_RECV, args, 2, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nvoid mp_bluetooth_gap_on_scan_complete(void) {\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_SCAN_DONE, NULL_NUMERIC, 0, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gap_on_scan_result(uint8_t addr_type, const uint8_t *addr, uint8_t adv_type, const int8_t rssi, const uint8_t *data, uint16_t data_len) {\n    mp_int_t args[] = {addr_type, adv_type, rssi};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_SCAN_RESULT, args, 1, 2, addr, NULL_UUID, &data, &data_len, 1);\n}\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\nvoid mp_bluetooth_gattc_on_primary_service_result(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, mp_obj_bluetooth_uuid_t *service_uuid) {\n    mp_int_t args[] = {conn_handle, start_handle, end_handle};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_GATTC_SERVICE_RESULT, args, 3, 0, NULL_ADDR, service_uuid, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gattc_on_characteristic_result(uint16_t conn_handle, uint16_t value_handle, uint16_t end_handle, uint8_t properties, mp_obj_bluetooth_uuid_t *characteristic_uuid) {\n    \n    mp_int_t args[] = {conn_handle, end_handle, value_handle, properties};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_GATTC_CHARACTERISTIC_RESULT, args, 4, 0, NULL_ADDR, characteristic_uuid, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gattc_on_descriptor_result(uint16_t conn_handle, uint16_t handle, mp_obj_bluetooth_uuid_t *descriptor_uuid) {\n    mp_int_t args[] = {conn_handle, handle};\n    invoke_irq_handler(MP_BLUETOOTH_IRQ_GATTC_DESCRIPTOR_RESULT, args, 2, 0, NULL_ADDR, descriptor_uuid, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gattc_on_discover_complete(uint8_t event, uint16_t conn_handle, uint16_t status) {\n    mp_int_t args[] = {conn_handle, status};\n    invoke_irq_handler(event, args, 2, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\nvoid mp_bluetooth_gattc_on_data_available(uint8_t event, uint16_t conn_handle, uint16_t value_handle, const uint8_t **data, uint16_t *data_len, size_t num) {\n    mp_int_t args[] = {conn_handle, value_handle};\n    invoke_irq_handler(event, args, 2, 0, NULL_ADDR, NULL_UUID, data, data_len, num);\n}\n\nvoid mp_bluetooth_gattc_on_read_write_status(uint8_t event, uint16_t conn_handle, uint16_t value_handle, uint16_t status) {\n    mp_int_t args[] = {conn_handle, value_handle, status};\n    invoke_irq_handler(event, args, 3, 0, NULL_ADDR, NULL_UUID, NULL_DATA, NULL_DATA_LEN, 0);\n}\n\n#endif \n\n#else \n\n\n\nstatic bool enqueue_irq(mp_obj_bluetooth_ble_t *o, size_t len, uint8_t event) {\n    if (!o || o->irq_handler == mp_const_none) {\n        return false;\n    }\n\n    \n    if (ringbuf_free(&o->ringbuf) < len + 1) {\n        \n\n        \n        if (event == MP_BLUETOOTH_IRQ_SCAN_RESULT || ringbuf_peek(&o->ringbuf) != MP_BLUETOOTH_IRQ_SCAN_RESULT) {\n            return false;\n        }\n\n        \n\n        \n        int n = 1 + 1 + 6 + 1 + 1;\n        for (int i = 0; i < n; ++i) {\n            ringbuf_get(&o->ringbuf);\n        }\n        \n        n = ringbuf_get(&o->ringbuf);\n        for (int i = 0; i < n; ++i) {\n            ringbuf_get(&o->ringbuf);\n        }\n    }\n\n    \n    ringbuf_put(&o->ringbuf, event);\n    return true;\n}\n\n\nstatic void schedule_ringbuf(mp_uint_t atomic_state) {\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (!o->irq_scheduled) {\n        o->irq_scheduled = true;\n        MICROPY_PY_BLUETOOTH_EXIT\n        mp_sched_schedule(MP_OBJ_FROM_PTR(&bluetooth_ble_invoke_irq_obj), mp_const_none);\n    } else {\n        MICROPY_PY_BLUETOOTH_EXIT\n    }\n}\n\nvoid mp_bluetooth_gap_on_connected_disconnected(uint8_t event, uint16_t conn_handle, uint8_t addr_type, const uint8_t *addr) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 1 + 6, event)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put(&o->ringbuf, addr_type);\n        for (int i = 0; i < 6; ++i) {\n            ringbuf_put(&o->ringbuf, addr[i]);\n        }\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gap_on_connection_update(uint16_t conn_handle, uint16_t conn_interval, uint16_t conn_latency, uint16_t supervision_timeout, uint16_t status) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2 + 2 + 2 + 2, MP_BLUETOOTH_IRQ_CONNECTION_UPDATE)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, conn_interval);\n        ringbuf_put16(&o->ringbuf, conn_latency);\n        ringbuf_put16(&o->ringbuf, supervision_timeout);\n        ringbuf_put16(&o->ringbuf, status);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gatts_on_write(uint16_t conn_handle, uint16_t value_handle) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2, MP_BLUETOOTH_IRQ_GATTS_WRITE)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, value_handle);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gatts_on_indicate_complete(uint16_t conn_handle, uint16_t value_handle, uint8_t status) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2 + 1, MP_BLUETOOTH_IRQ_GATTS_INDICATE_DONE)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, value_handle);\n        ringbuf_put(&o->ringbuf, status);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nmp_int_t mp_bluetooth_gatts_on_read_request(uint16_t conn_handle, uint16_t value_handle) {\n    (void)conn_handle;\n    (void)value_handle;\n    \n    return MP_BLUETOOTH_GATTS_NO_ERROR;\n}\n\nvoid mp_bluetooth_gatts_on_mtu_exchanged(uint16_t conn_handle, uint16_t value) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2, MP_BLUETOOTH_IRQ_MTU_EXCHANGED)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, value);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nvoid mp_bluetooth_gap_on_scan_complete(void) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 0, MP_BLUETOOTH_IRQ_SCAN_DONE)) {\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gap_on_scan_result(uint8_t addr_type, const uint8_t *addr, uint8_t adv_type, const int8_t rssi, const uint8_t *data, uint16_t data_len) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    data_len = MIN(o->irq_data_data_alloc, data_len);\n    if (enqueue_irq(o, 1 + 6 + 1 + 1 + 2 + data_len, MP_BLUETOOTH_IRQ_SCAN_RESULT)) {\n        ringbuf_put(&o->ringbuf, addr_type);\n        for (int i = 0; i < 6; ++i) {\n            ringbuf_put(&o->ringbuf, addr[i]);\n        }\n        \n        ringbuf_put(&o->ringbuf, adv_type);\n        \n        ringbuf_put(&o->ringbuf, (uint8_t)rssi);\n        \n        data_len = MIN(UINT16_MAX, data_len);\n        ringbuf_put16(&o->ringbuf, data_len);\n        for (size_t i = 0; i < data_len; ++i) {\n            ringbuf_put(&o->ringbuf, data[i]);\n        }\n    }\n    schedule_ringbuf(atomic_state);\n}\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\nvoid mp_bluetooth_gattc_on_primary_service_result(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, mp_obj_bluetooth_uuid_t *service_uuid) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2 + 2 + 1 + service_uuid->type, MP_BLUETOOTH_IRQ_GATTC_SERVICE_RESULT)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, start_handle);\n        ringbuf_put16(&o->ringbuf, end_handle);\n        ringbuf_put_uuid(&o->ringbuf, service_uuid);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gattc_on_characteristic_result(uint16_t conn_handle, uint16_t value_handle, uint16_t end_handle, uint8_t properties, mp_obj_bluetooth_uuid_t *characteristic_uuid) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2 + 2 + 1 + characteristic_uuid->type, MP_BLUETOOTH_IRQ_GATTC_CHARACTERISTIC_RESULT)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        \n        ringbuf_put16(&o->ringbuf, end_handle);\n        ringbuf_put16(&o->ringbuf, value_handle);\n        ringbuf_put(&o->ringbuf, properties);\n        ringbuf_put_uuid(&o->ringbuf, characteristic_uuid);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gattc_on_descriptor_result(uint16_t conn_handle, uint16_t handle, mp_obj_bluetooth_uuid_t *descriptor_uuid) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2 + 1 + descriptor_uuid->type, MP_BLUETOOTH_IRQ_GATTC_DESCRIPTOR_RESULT)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, handle);\n        ringbuf_put_uuid(&o->ringbuf, descriptor_uuid);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gattc_on_discover_complete(uint8_t event, uint16_t conn_handle, uint16_t status) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2, event)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, status);\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gattc_on_data_available(uint8_t event, uint16_t conn_handle, uint16_t value_handle, const uint8_t **data, uint16_t *data_len, size_t num) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n\n    \n    uint16_t total_len = 0;\n    for (size_t i = 0; i < num; ++i) {\n        total_len += data_len[i];\n    }\n\n    \n    total_len = MIN(o->irq_data_data_alloc, total_len);\n\n    if (enqueue_irq(o, 2 + 2 + 2 + total_len, event)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, value_handle);\n\n        ringbuf_put16(&o->ringbuf, total_len);\n\n        \n        uint16_t copied_bytes = 0;\n        for (size_t i = 0; i < num; ++i) {\n            for (size_t j = 0; i < data_len[i] && copied_bytes < total_len; ++j) {\n                ringbuf_put(&o->ringbuf, data[i][j]);\n                ++copied_bytes;\n            }\n        }\n    }\n    schedule_ringbuf(atomic_state);\n}\n\nvoid mp_bluetooth_gattc_on_read_write_status(uint8_t event, uint16_t conn_handle, uint16_t value_handle, uint16_t status) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_obj_bluetooth_ble_t *o = MP_OBJ_TO_PTR(MP_STATE_VM(bluetooth));\n    if (enqueue_irq(o, 2 + 2 + 2, event)) {\n        ringbuf_put16(&o->ringbuf, conn_handle);\n        ringbuf_put16(&o->ringbuf, value_handle);\n        ringbuf_put16(&o->ringbuf, status);\n    }\n    schedule_ringbuf(atomic_state);\n}\n#endif \n\n#endif \n\n\n\n\n\nvoid mp_bluetooth_gatts_db_create_entry(mp_gatts_db_t db, uint16_t handle, size_t len) {\n    mp_map_elem_t *elem = mp_map_lookup(db, MP_OBJ_NEW_SMALL_INT(handle), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n    mp_bluetooth_gatts_db_entry_t *entry = m_new(mp_bluetooth_gatts_db_entry_t, 1);\n    entry->data = m_new(uint8_t, len);\n    entry->data_alloc = len;\n    entry->data_len = 0;\n    entry->append = false;\n    elem->value = MP_OBJ_FROM_PTR(entry);\n}\n\nmp_bluetooth_gatts_db_entry_t *mp_bluetooth_gatts_db_lookup(mp_gatts_db_t db, uint16_t handle) {\n    mp_map_elem_t *elem = mp_map_lookup(db, MP_OBJ_NEW_SMALL_INT(handle), MP_MAP_LOOKUP);\n    if (!elem) {\n        return NULL;\n    }\n    return MP_OBJ_TO_PTR(elem->value);\n}\n\nint mp_bluetooth_gatts_db_read(mp_gatts_db_t db, uint16_t handle, const uint8_t **value, size_t *value_len) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_bluetooth_gatts_db_entry_t *entry = mp_bluetooth_gatts_db_lookup(db, handle);\n    if (entry) {\n        *value = entry->data;\n        *value_len = entry->data_len;\n        if (entry->append) {\n            entry->data_len = 0;\n        }\n    }\n    MICROPY_PY_BLUETOOTH_EXIT\n    return entry ? 0 : MP_EINVAL;\n}\n\nint mp_bluetooth_gatts_db_write(mp_gatts_db_t db, uint16_t handle, const uint8_t *value, size_t value_len) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_bluetooth_gatts_db_entry_t *entry = mp_bluetooth_gatts_db_lookup(db, handle);\n    if (entry) {\n        if (value_len > entry->data_alloc) {\n            uint8_t *data = m_new_maybe(uint8_t, value_len);\n            if (data) {\n                entry->data = data;\n                entry->data_alloc = value_len;\n            } else {\n                MICROPY_PY_BLUETOOTH_EXIT\n                return MP_ENOMEM;\n            }\n        }\n\n        memcpy(entry->data, value, value_len);\n        entry->data_len = value_len;\n    }\n    MICROPY_PY_BLUETOOTH_EXIT\n    return entry ? 0 : MP_EINVAL;\n}\n\nint mp_bluetooth_gatts_db_resize(mp_gatts_db_t db, uint16_t handle, size_t len, bool append) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    mp_bluetooth_gatts_db_entry_t *entry = mp_bluetooth_gatts_db_lookup(db, handle);\n    if (entry) {\n        uint8_t *data = m_renew_maybe(uint8_t, entry->data, entry->data_alloc, len, true);\n        if (data) {\n            entry->data = data;\n            entry->data_alloc = len;\n            entry->data_len = 0;\n            entry->append = append;\n        } else {\n            MICROPY_PY_BLUETOOTH_EXIT\n            return MP_ENOMEM;\n        }\n    }\n    MICROPY_PY_BLUETOOTH_EXIT\n    return entry ? 0 : MP_EINVAL;\n}\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t bluetooth);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}