{
  "module_name": "machine_spi.c",
  "hash_id": "1912f4c50936ad5ef7c27cce42cc5cd92e50a873c043e52b5adfce6ddcf246ef",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_spi.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_MACHINE_SPI || MICROPY_PY_MACHINE_SOFTSPI\n\n#include \"extmod/modmachine.h\"\n\n\n#ifndef MICROPY_PY_MACHINE_SPI_MSB\n#define MICROPY_PY_MACHINE_SPI_MSB (0)\n#define MICROPY_PY_MACHINE_SPI_LSB (1)\n#endif\n\n \n\n\nstatic mp_obj_t machine_spi_init(size_t n_args, const mp_obj_t *args, mp_map_t *kw_args) {\n    mp_obj_base_t *s = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n    mp_machine_spi_p_t *spi_p = (mp_machine_spi_p_t *)MP_OBJ_TYPE_GET_SLOT(s->type, protocol);\n    spi_p->init(s, n_args - 1, args + 1, kw_args);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(machine_spi_init_obj, 1, machine_spi_init);\n\nstatic mp_obj_t machine_spi_deinit(mp_obj_t self) {\n    mp_obj_base_t *s = (mp_obj_base_t *)MP_OBJ_TO_PTR(self);\n    mp_machine_spi_p_t *spi_p = (mp_machine_spi_p_t *)MP_OBJ_TYPE_GET_SLOT(s->type, protocol);\n    if (spi_p->deinit != NULL) {\n        spi_p->deinit(s);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(machine_spi_deinit_obj, machine_spi_deinit);\n\nstatic void mp_machine_spi_transfer(mp_obj_t self, size_t len, const void *src, void *dest) {\n    mp_obj_base_t *s = (mp_obj_base_t *)MP_OBJ_TO_PTR(self);\n    mp_machine_spi_p_t *spi_p = (mp_machine_spi_p_t *)MP_OBJ_TYPE_GET_SLOT(s->type, protocol);\n    spi_p->transfer(s, len, src, dest);\n}\n\nstatic mp_obj_t mp_machine_spi_read(size_t n_args, const mp_obj_t *args) {\n    vstr_t vstr;\n    vstr_init_len(&vstr, mp_obj_get_int(args[1]));\n    memset(vstr.buf, n_args == 3 ? mp_obj_get_int(args[2]) : 0, vstr.len);\n    mp_machine_spi_transfer(args[0], vstr.len, vstr.buf, vstr.buf);\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_machine_spi_read_obj, 2, 3, mp_machine_spi_read);\n\nstatic mp_obj_t mp_machine_spi_readinto(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_WRITE);\n    memset(bufinfo.buf, n_args == 3 ? mp_obj_get_int(args[2]) : 0, bufinfo.len);\n    mp_machine_spi_transfer(args[0], bufinfo.len, bufinfo.buf, bufinfo.buf);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_machine_spi_readinto_obj, 2, 3, mp_machine_spi_readinto);\n\nstatic mp_obj_t mp_machine_spi_write(mp_obj_t self, mp_obj_t wr_buf) {\n    mp_buffer_info_t src;\n    mp_get_buffer_raise(wr_buf, &src, MP_BUFFER_READ);\n    mp_machine_spi_transfer(self, src.len, (const uint8_t *)src.buf, NULL);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_machine_spi_write_obj, mp_machine_spi_write);\n\nstatic mp_obj_t mp_machine_spi_write_readinto(mp_obj_t self, mp_obj_t wr_buf, mp_obj_t rd_buf) {\n    mp_buffer_info_t src;\n    mp_get_buffer_raise(wr_buf, &src, MP_BUFFER_READ);\n    mp_buffer_info_t dest;\n    mp_get_buffer_raise(rd_buf, &dest, MP_BUFFER_WRITE);\n    if (src.len != dest.len) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"buffers must be the same length\"));\n    }\n    mp_machine_spi_transfer(self, src.len, src.buf, dest.buf);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_3(mp_machine_spi_write_readinto_obj, mp_machine_spi_write_readinto);\n\nstatic const mp_rom_map_elem_t machine_spi_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&machine_spi_init_obj) },\n    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&machine_spi_deinit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_machine_spi_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_machine_spi_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_machine_spi_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write_readinto), MP_ROM_PTR(&mp_machine_spi_write_readinto_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_MSB), MP_ROM_INT(MICROPY_PY_MACHINE_SPI_MSB) },\n    { MP_ROM_QSTR(MP_QSTR_LSB), MP_ROM_INT(MICROPY_PY_MACHINE_SPI_LSB) },\n};\nMP_DEFINE_CONST_DICT(mp_machine_spi_locals_dict, machine_spi_locals_dict_table);\n\n#endif \n\n \n\n\n#if MICROPY_PY_MACHINE_SOFTSPI\n\nstatic uint32_t baudrate_from_delay_half(uint32_t delay_half) {\n    #ifdef MICROPY_HW_SOFTSPI_MIN_DELAY\n    if (delay_half == MICROPY_HW_SOFTSPI_MIN_DELAY) {\n        return MICROPY_HW_SOFTSPI_MAX_BAUDRATE;\n    } else\n    #endif\n    {\n        return 500000 / delay_half;\n    }\n}\n\nstatic uint32_t baudrate_to_delay_half(uint32_t baudrate) {\n    #ifdef MICROPY_HW_SOFTSPI_MIN_DELAY\n    if (baudrate >= MICROPY_HW_SOFTSPI_MAX_BAUDRATE) {\n        return MICROPY_HW_SOFTSPI_MIN_DELAY;\n    } else\n    #endif\n    {\n        uint32_t delay_half = 500000 / baudrate;\n        \n        if (500000 % baudrate != 0) {\n            delay_half += 1;\n        }\n        return delay_half;\n    }\n}\n\nstatic void mp_machine_soft_spi_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mp_machine_soft_spi_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"SoftSPI(baudrate=%u, polarity=%u, phase=%u,\"\n        \" sck=\" MP_HAL_PIN_FMT \", mosi=\" MP_HAL_PIN_FMT \", miso=\" MP_HAL_PIN_FMT \")\",\n        baudrate_from_delay_half(self->spi.delay_half), self->spi.polarity, self->spi.phase,\n        mp_hal_pin_name(self->spi.sck), mp_hal_pin_name(self->spi.mosi), mp_hal_pin_name(self->spi.miso));\n}\n\nstatic mp_obj_t mp_machine_soft_spi_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {\n    enum { ARG_baudrate, ARG_polarity, ARG_phase, ARG_bits, ARG_firstbit, ARG_sck, ARG_mosi, ARG_miso };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_baudrate, MP_ARG_INT, {.u_int = 500000} },\n        { MP_QSTR_polarity, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 0} },\n        { MP_QSTR_phase,    MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 0} },\n        { MP_QSTR_bits,     MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 8} },\n        { MP_QSTR_firstbit, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = MICROPY_PY_MACHINE_SPI_MSB} },\n        { MP_QSTR_sck,      MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_mosi,     MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_miso,     MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n    };\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    mp_machine_soft_spi_obj_t *self = mp_obj_malloc(mp_machine_soft_spi_obj_t, &mp_machine_soft_spi_type);\n\n    \n    self->spi.delay_half = baudrate_to_delay_half(args[ARG_baudrate].u_int);\n    self->spi.polarity = args[ARG_polarity].u_int;\n    self->spi.phase = args[ARG_phase].u_int;\n    if (args[ARG_bits].u_int != 8) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"bits must be 8\"));\n    }\n    if (args[ARG_firstbit].u_int != MICROPY_PY_MACHINE_SPI_MSB) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"firstbit must be MSB\"));\n    }\n    if (args[ARG_sck].u_obj == MP_OBJ_NULL\n        || args[ARG_mosi].u_obj == MP_OBJ_NULL\n        || args[ARG_miso].u_obj == MP_OBJ_NULL) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"must specify all of sck/mosi/miso\"));\n    }\n    self->spi.sck = mp_hal_get_pin_obj(args[ARG_sck].u_obj);\n    self->spi.mosi = mp_hal_get_pin_obj(args[ARG_mosi].u_obj);\n    self->spi.miso = mp_hal_get_pin_obj(args[ARG_miso].u_obj);\n\n    \n    mp_soft_spi_ioctl(&self->spi, MP_SPI_IOCTL_INIT);\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic void mp_machine_soft_spi_init(mp_obj_base_t *self_in, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    mp_machine_soft_spi_obj_t *self = (mp_machine_soft_spi_obj_t *)self_in;\n\n    enum { ARG_baudrate, ARG_polarity, ARG_phase, ARG_sck, ARG_mosi, ARG_miso };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_baudrate, MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_polarity, MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_phase, MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_sck, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_mosi, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_miso, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n    };\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    if (args[ARG_baudrate].u_int != -1) {\n        self->spi.delay_half = baudrate_to_delay_half(args[ARG_baudrate].u_int);\n    }\n    if (args[ARG_polarity].u_int != -1) {\n        self->spi.polarity = args[ARG_polarity].u_int;\n    }\n    if (args[ARG_phase].u_int != -1) {\n        self->spi.phase = args[ARG_phase].u_int;\n    }\n    if (args[ARG_sck].u_obj != MP_OBJ_NULL) {\n        self->spi.sck = mp_hal_get_pin_obj(args[ARG_sck].u_obj);\n    }\n    if (args[ARG_mosi].u_obj != MP_OBJ_NULL) {\n        self->spi.mosi = mp_hal_get_pin_obj(args[ARG_mosi].u_obj);\n    }\n    if (args[ARG_miso].u_obj != MP_OBJ_NULL) {\n        self->spi.miso = mp_hal_get_pin_obj(args[ARG_miso].u_obj);\n    }\n\n    \n    mp_soft_spi_ioctl(&self->spi, MP_SPI_IOCTL_INIT);\n}\n\nstatic void mp_machine_soft_spi_transfer(mp_obj_base_t *self_in, size_t len, const uint8_t *src, uint8_t *dest) {\n    mp_machine_soft_spi_obj_t *self = (mp_machine_soft_spi_obj_t *)self_in;\n    mp_soft_spi_transfer(&self->spi, len, src, dest);\n}\n\nconst mp_machine_spi_p_t mp_machine_soft_spi_p = {\n    .init = mp_machine_soft_spi_init,\n    .deinit = NULL,\n    .transfer = mp_machine_soft_spi_transfer,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_machine_soft_spi_type,\n    MP_QSTR_SoftSPI,\n    MP_TYPE_FLAG_NONE,\n    make_new, mp_machine_soft_spi_make_new,\n    print, mp_machine_soft_spi_print,\n    protocol, &mp_machine_soft_spi_p,\n    locals_dict, &mp_machine_spi_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}