{
  "module_name": "vfs_lfsx.c",
  "hash_id": "8281a02cdd561bfe44513783632deec8af015c29b5447f5c38d183eb83902c49",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_lfsx.c",
  "human_readable_source": " \n\n\n#if defined(LFS_BUILD_VERSION)\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/binary.h\"\n#include \"py/objarray.h\"\n#include \"py/objstr.h\"\n#include \"py/mperrno.h\"\n#include \"extmod/vfs.h\"\n#include \"shared/timeutils/timeutils.h\"\n\n#if !MICROPY_ENABLE_FINALISER\n#error \"MICROPY_VFS_LFS requires MICROPY_ENABLE_FINALISER\"\n#endif\n\nstatic int MP_VFS_LFSx(dev_ioctl)(const struct LFSx_API (config) * c, int cmd, int arg, bool must_return_int) {\n    mp_obj_t ret = mp_vfs_blockdev_ioctl(c->context, cmd, arg);\n    int ret_i = 0;\n    if (must_return_int || ret != mp_const_none) {\n        ret_i = mp_obj_get_int(ret);\n    }\n    return ret_i;\n}\n\nstatic int MP_VFS_LFSx(dev_read)(const struct LFSx_API (config) * c, LFSx_API(block_t) block, LFSx_API(off_t) off, void *buffer, LFSx_API(size_t) size) {\n    return mp_vfs_blockdev_read_ext(c->context, block, off, size, buffer);\n}\n\nstatic int MP_VFS_LFSx(dev_prog)(const struct LFSx_API (config) * c, LFSx_API(block_t) block, LFSx_API(off_t) off, const void *buffer, LFSx_API(size_t) size) {\n    return mp_vfs_blockdev_write_ext(c->context, block, off, size, buffer);\n}\n\nstatic int MP_VFS_LFSx(dev_erase)(const struct LFSx_API (config) * c, LFSx_API(block_t) block) {\n    return MP_VFS_LFSx(dev_ioctl)(c, MP_BLOCKDEV_IOCTL_BLOCK_ERASE, block, true);\n}\n\nstatic int MP_VFS_LFSx(dev_sync)(const struct LFSx_API (config) * c) {\n    return MP_VFS_LFSx(dev_ioctl)(c, MP_BLOCKDEV_IOCTL_SYNC, 0, false);\n}\n\nstatic void MP_VFS_LFSx(init_config)(MP_OBJ_VFS_LFSx * self, mp_obj_t bdev, size_t read_size, size_t prog_size, size_t lookahead) {\n    self->blockdev.flags = MP_BLOCKDEV_FLAG_FREE_OBJ;\n    mp_vfs_blockdev_init(&self->blockdev, bdev);\n\n    struct LFSx_API (config) * config = &self->config;\n    memset(config, 0, sizeof(*config));\n\n    config->context = &self->blockdev;\n\n    config->read = MP_VFS_LFSx(dev_read);\n    config->prog = MP_VFS_LFSx(dev_prog);\n    config->erase = MP_VFS_LFSx(dev_erase);\n    config->sync = MP_VFS_LFSx(dev_sync);\n\n    MP_VFS_LFSx(dev_ioctl)(config, MP_BLOCKDEV_IOCTL_INIT, 1, false); \n    int bs = MP_VFS_LFSx(dev_ioctl)(config, MP_BLOCKDEV_IOCTL_BLOCK_SIZE, 0, true); \n    int bc = MP_VFS_LFSx(dev_ioctl)(config, MP_BLOCKDEV_IOCTL_BLOCK_COUNT, 0, true); \n    self->blockdev.block_size = bs;\n\n    config->read_size = read_size;\n    config->prog_size = prog_size;\n    config->block_size = bs;\n    config->block_count = bc;\n\n    #if LFS_BUILD_VERSION == 1\n    config->lookahead = lookahead;\n    config->read_buffer = m_new(uint8_t, config->read_size);\n    config->prog_buffer = m_new(uint8_t, config->prog_size);\n    config->lookahead_buffer = m_new(uint8_t, config->lookahead / 8);\n    #else\n    config->block_cycles = 100;\n    config->cache_size = MIN(config->block_size, (4 * MAX(read_size, prog_size)));\n    config->lookahead_size = lookahead;\n    config->read_buffer = m_new(uint8_t, config->cache_size);\n    config->prog_buffer = m_new(uint8_t, config->cache_size);\n    config->lookahead_buffer = m_new(uint8_t, config->lookahead_size);\n    #endif\n}\n\nconst char *MP_VFS_LFSx(make_path)(MP_OBJ_VFS_LFSx * self, mp_obj_t path_in) {\n    const char *path = mp_obj_str_get_str(path_in);\n    if (path[0] != '/') {\n        size_t l = vstr_len(&self->cur_dir);\n        if (l > 0) {\n            vstr_add_str(&self->cur_dir, path);\n            path = vstr_null_terminated_str(&self->cur_dir);\n            self->cur_dir.len = l;\n        }\n    }\n    return path;\n}\n\nstatic mp_obj_t MP_VFS_LFSx(make_new)(const mp_obj_type_t * type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {\n    mp_arg_val_t args[MP_ARRAY_SIZE(lfs_make_allowed_args)];\n    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(lfs_make_allowed_args), lfs_make_allowed_args, args);\n\n    MP_OBJ_VFS_LFSx *self = m_new0(MP_OBJ_VFS_LFSx, 1);\n    self->base.type = type;\n    vstr_init(&self->cur_dir, 16);\n    vstr_add_byte(&self->cur_dir, '/');\n    #if LFS_BUILD_VERSION == 2\n    self->enable_mtime = args[LFS_MAKE_ARG_mtime].u_bool;\n    #endif\n    MP_VFS_LFSx(init_config)(self, args[LFS_MAKE_ARG_bdev].u_obj,\n        args[LFS_MAKE_ARG_readsize].u_int, args[LFS_MAKE_ARG_progsize].u_int, args[LFS_MAKE_ARG_lookahead].u_int);\n    int ret = LFSx_API(mount)(&self->lfs, &self->config);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_obj_t MP_VFS_LFSx(mkfs)(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    mp_arg_val_t args[MP_ARRAY_SIZE(lfs_make_allowed_args)];\n    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(lfs_make_allowed_args), lfs_make_allowed_args, args);\n\n    MP_OBJ_VFS_LFSx self;\n    MP_VFS_LFSx(init_config)(&self, args[LFS_MAKE_ARG_bdev].u_obj,\n        args[LFS_MAKE_ARG_readsize].u_int, args[LFS_MAKE_ARG_progsize].u_int, args[LFS_MAKE_ARG_lookahead].u_int);\n    int ret = LFSx_API(format)(&self.lfs, &self.config);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(MP_VFS_LFSx(mkfs_fun_obj), 0, MP_VFS_LFSx(mkfs));\nstatic MP_DEFINE_CONST_STATICMETHOD_OBJ(MP_VFS_LFSx(mkfs_obj), MP_ROM_PTR(&MP_VFS_LFSx(mkfs_fun_obj)));\n\n\nstatic MP_DEFINE_CONST_FUN_OBJ_3(MP_VFS_LFSx(open_obj), MP_VFS_LFSx(file_open));\n\ntypedef struct MP_VFS_LFSx (_ilistdir_it_t) {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_fun_1_t finaliser;\n    bool is_str;\n    MP_OBJ_VFS_LFSx *vfs;\n    LFSx_API(dir_t) dir;\n} MP_VFS_LFSx(ilistdir_it_t);\n\nstatic mp_obj_t MP_VFS_LFSx(ilistdir_it_iternext)(mp_obj_t self_in) {\n    MP_VFS_LFSx(ilistdir_it_t) * self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->vfs == NULL) {\n        return MP_OBJ_STOP_ITERATION;\n    }\n\n    struct LFSx_API (info) info;\n    for (;;) {\n        int ret = LFSx_API(dir_read)(&self->vfs->lfs, &self->dir, &info);\n        if (ret == 0) {\n            LFSx_API(dir_close)(&self->vfs->lfs, &self->dir);\n            self->vfs = NULL;\n            return MP_OBJ_STOP_ITERATION;\n        }\n        if (!(info.name[0] == '.' && (info.name[1] == '\\0'\n                                      || (info.name[1] == '.' && info.name[2] == '\\0')))) {\n            break;\n        }\n    }\n\n    \n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(4, NULL));\n    if (self->is_str) {\n        t->items[0] = mp_obj_new_str(info.name, strlen(info.name));\n    } else {\n        t->items[0] = mp_obj_new_bytes((const byte *)info.name, strlen(info.name));\n    }\n    t->items[1] = MP_OBJ_NEW_SMALL_INT(info.type == LFSx_MACRO(_TYPE_REG) ? MP_S_IFREG : MP_S_IFDIR);\n    t->items[2] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[3] = MP_OBJ_NEW_SMALL_INT(info.size);\n\n    return MP_OBJ_FROM_PTR(t);\n}\n\nstatic mp_obj_t MP_VFS_LFSx(ilistdir_it_del)(mp_obj_t self_in) {\n    MP_VFS_LFSx(ilistdir_it_t) * self = MP_OBJ_TO_PTR(self_in);\n    if (self->vfs != NULL) {\n        LFSx_API(dir_close)(&self->vfs->lfs, &self->dir);\n    }\n    return mp_const_none;\n}\n\nstatic mp_obj_t MP_VFS_LFSx(ilistdir_func)(size_t n_args, const mp_obj_t *args) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(args[0]);\n    bool is_str_type = true;\n    const char *path;\n    if (n_args == 2) {\n        if (mp_obj_get_type(args[1]) == &mp_type_bytes) {\n            is_str_type = false;\n        }\n        path = MP_VFS_LFSx(make_path)(self, args[1]);\n    } else {\n        path = vstr_null_terminated_str(&self->cur_dir);\n    }\n\n    MP_VFS_LFSx(ilistdir_it_t) * iter = mp_obj_malloc_with_finaliser(MP_VFS_LFSx(ilistdir_it_t), &mp_type_polymorph_iter_with_finaliser);\n\n    iter->iternext = MP_VFS_LFSx(ilistdir_it_iternext);\n    iter->finaliser = MP_VFS_LFSx(ilistdir_it_del);\n    iter->is_str = is_str_type;\n    int ret = LFSx_API(dir_open)(&self->lfs, &iter->dir, path);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    iter->vfs = self;\n    return MP_OBJ_FROM_PTR(iter);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(MP_VFS_LFSx(ilistdir_obj), 1, 2, MP_VFS_LFSx(ilistdir_func));\n\nstatic mp_obj_t MP_VFS_LFSx(remove)(mp_obj_t self_in, mp_obj_t path_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    const char *path = MP_VFS_LFSx(make_path)(self, path_in);\n    int ret = LFSx_API(remove)(&self->lfs, path);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(MP_VFS_LFSx(remove_obj), MP_VFS_LFSx(remove));\n\nstatic mp_obj_t MP_VFS_LFSx(rmdir)(mp_obj_t self_in, mp_obj_t path_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    const char *path = MP_VFS_LFSx(make_path)(self, path_in);\n    int ret = LFSx_API(remove)(&self->lfs, path);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(MP_VFS_LFSx(rmdir_obj), MP_VFS_LFSx(rmdir));\n\nstatic mp_obj_t MP_VFS_LFSx(rename)(mp_obj_t self_in, mp_obj_t path_old_in, mp_obj_t path_new_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    const char *path_old = MP_VFS_LFSx(make_path)(self, path_old_in);\n    const char *path = mp_obj_str_get_str(path_new_in);\n    vstr_t path_new;\n    vstr_init(&path_new, vstr_len(&self->cur_dir));\n    if (path[0] != '/') {\n        vstr_add_strn(&path_new, vstr_str(&self->cur_dir), vstr_len(&self->cur_dir));\n    }\n    vstr_add_str(&path_new, path);\n    int ret = LFSx_API(rename)(&self->lfs, path_old, vstr_null_terminated_str(&path_new));\n    vstr_clear(&path_new);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(MP_VFS_LFSx(rename_obj), MP_VFS_LFSx(rename));\n\nstatic mp_obj_t MP_VFS_LFSx(mkdir)(mp_obj_t self_in, mp_obj_t path_o) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    const char *path = MP_VFS_LFSx(make_path)(self, path_o);\n    int ret = LFSx_API(mkdir)(&self->lfs, path);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(MP_VFS_LFSx(mkdir_obj), MP_VFS_LFSx(mkdir));\n\nstatic mp_obj_t MP_VFS_LFSx(chdir)(mp_obj_t self_in, mp_obj_t path_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    const char *path = MP_VFS_LFSx(make_path)(self, path_in);\n    if (path[1] != '\\0') {\n        \n        struct LFSx_API (info) info;\n        int ret = LFSx_API(stat)(&self->lfs, path, &info);\n        if (ret < 0 || info.type != LFSx_MACRO(_TYPE_DIR)) {\n            mp_raise_OSError(-MP_ENOENT);\n        }\n    }\n\n    \n    if (path == vstr_str(&self->cur_dir)) {\n        self->cur_dir.len = strlen(path);\n    } else {\n        vstr_reset(&self->cur_dir);\n        vstr_add_str(&self->cur_dir, path);\n    }\n\n    \n    \n    if (vstr_len(&self->cur_dir) != 1) {\n        vstr_add_byte(&self->cur_dir, '/');\n\n        #define CWD_LEN (vstr_len(&self->cur_dir))\n        size_t to = 1;\n        size_t from = 1;\n        char *cwd = vstr_str(&self->cur_dir);\n        while (from < CWD_LEN) {\n            for (; from < CWD_LEN && cwd[from] == '/'; ++from) {\n                \n            }\n            if (from > to) {\n                \n                vstr_cut_out_bytes(&self->cur_dir, to, from - to);\n                from = to;\n            }\n            for (; from < CWD_LEN && cwd[from] != '/'; ++from) {\n                \n            }\n            if ((from - to) == 1 && cwd[to] == '.') {\n                \n                vstr_cut_out_bytes(&self->cur_dir, to, ++from - to);\n                from = to;\n            } else if ((from - to) == 2 && cwd[to] == '.' && cwd[to + 1] == '.') {\n                \n                if (to > 1) {\n                    \n                    for (--to; to > 1 && cwd[to - 1] != '/'; --to) {\n                        \n                    }\n                }\n                vstr_cut_out_bytes(&self->cur_dir, to, ++from - to);\n                from = to;\n            } else {\n                \n                to = ++from;\n            }\n        }\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(MP_VFS_LFSx(chdir_obj), MP_VFS_LFSx(chdir));\n\nstatic mp_obj_t MP_VFS_LFSx(getcwd)(mp_obj_t self_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    if (vstr_len(&self->cur_dir) == 1) {\n        return MP_OBJ_NEW_QSTR(MP_QSTR__slash_);\n    } else {\n        \n        return mp_obj_new_str(self->cur_dir.buf, self->cur_dir.len - 1);\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(MP_VFS_LFSx(getcwd_obj), MP_VFS_LFSx(getcwd));\n\nstatic mp_obj_t MP_VFS_LFSx(stat)(mp_obj_t self_in, mp_obj_t path_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    const char *path = MP_VFS_LFSx(make_path)(self, path_in);\n    struct LFSx_API (info) info;\n    int ret = LFSx_API(stat)(&self->lfs, path, &info);\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    mp_uint_t mtime = 0;\n    #if LFS_BUILD_VERSION == 2\n    uint8_t mtime_buf[8];\n    lfs2_ssize_t sz = lfs2_getattr(&self->lfs, path, LFS_ATTR_MTIME, &mtime_buf, sizeof(mtime_buf));\n    if (sz == sizeof(mtime_buf)) {\n        uint64_t ns = 0;\n        for (size_t i = sizeof(mtime_buf); i > 0; --i) {\n            ns = ns << 8 | mtime_buf[i - 1];\n        }\n        \n        mtime = timeutils_seconds_since_epoch_from_nanoseconds_since_1970(ns);\n    }\n    #endif\n\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n    t->items[0] = MP_OBJ_NEW_SMALL_INT(info.type == LFSx_MACRO(_TYPE_REG) ? MP_S_IFREG : MP_S_IFDIR); \n    t->items[1] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[2] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[3] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[4] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[5] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[6] = mp_obj_new_int_from_uint(info.size); \n    t->items[7] = mp_obj_new_int_from_uint(mtime); \n    t->items[8] = mp_obj_new_int_from_uint(mtime); \n    t->items[9] = mp_obj_new_int_from_uint(mtime); \n\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(MP_VFS_LFSx(stat_obj), MP_VFS_LFSx(stat));\n\nstatic int LFSx_API(traverse_cb)(void *data, LFSx_API(block_t) bl) {\n    (void)bl;\n    uint32_t *n = (uint32_t *)data;\n    *n += 1;\n    return LFSx_MACRO(_ERR_OK);\n}\n\nstatic mp_obj_t MP_VFS_LFSx(statvfs)(mp_obj_t self_in, mp_obj_t path_in) {\n    (void)path_in;\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    uint32_t n_used_blocks = 0;\n    #if LFS_BUILD_VERSION == 1\n    int ret = LFSx_API(traverse)(&self->lfs, LFSx_API(traverse_cb), &n_used_blocks);\n    #else\n    int ret = LFSx_API(fs_traverse)(&self->lfs, LFSx_API(traverse_cb), &n_used_blocks);\n    #endif\n    if (ret < 0) {\n        mp_raise_OSError(-ret);\n    }\n\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n    t->items[0] = MP_OBJ_NEW_SMALL_INT(self->lfs.cfg->block_size); \n    t->items[1] = t->items[0]; \n    t->items[2] = MP_OBJ_NEW_SMALL_INT(self->lfs.cfg->block_count); \n    t->items[3] = MP_OBJ_NEW_SMALL_INT(self->lfs.cfg->block_count - n_used_blocks); \n    t->items[4] = t->items[3]; \n    t->items[5] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[6] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[7] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[8] = MP_OBJ_NEW_SMALL_INT(0); \n    t->items[9] = MP_OBJ_NEW_SMALL_INT(LFSx_MACRO(_NAME_MAX)); \n\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(MP_VFS_LFSx(statvfs_obj), MP_VFS_LFSx(statvfs));\n\nstatic mp_obj_t MP_VFS_LFSx(mount)(mp_obj_t self_in, mp_obj_t readonly, mp_obj_t mkfs) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    (void)mkfs;\n\n    \n    if (mp_obj_is_true(readonly)) {\n        self->blockdev.writeblocks[0] = MP_OBJ_NULL;\n    }\n\n    \n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(MP_VFS_LFSx(mount_obj), MP_VFS_LFSx(mount));\n\nstatic mp_obj_t MP_VFS_LFSx(umount)(mp_obj_t self_in) {\n    MP_OBJ_VFS_LFSx *self = MP_OBJ_TO_PTR(self_in);\n    \n    LFSx_API(unmount)(&self->lfs);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(MP_VFS_LFSx(umount_obj), MP_VFS_LFSx(umount));\n\nstatic const mp_rom_map_elem_t MP_VFS_LFSx(locals_dict_table)[] = {\n    { MP_ROM_QSTR(MP_QSTR_mkfs), MP_ROM_PTR(&MP_VFS_LFSx(mkfs_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&MP_VFS_LFSx(open_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_ilistdir), MP_ROM_PTR(&MP_VFS_LFSx(ilistdir_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_mkdir), MP_ROM_PTR(&MP_VFS_LFSx(mkdir_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_rmdir), MP_ROM_PTR(&MP_VFS_LFSx(rmdir_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_chdir), MP_ROM_PTR(&MP_VFS_LFSx(chdir_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_getcwd), MP_ROM_PTR(&MP_VFS_LFSx(getcwd_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&MP_VFS_LFSx(remove_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_rename), MP_ROM_PTR(&MP_VFS_LFSx(rename_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_stat), MP_ROM_PTR(&MP_VFS_LFSx(stat_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_statvfs), MP_ROM_PTR(&MP_VFS_LFSx(statvfs_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_mount), MP_ROM_PTR(&MP_VFS_LFSx(mount_obj)) },\n    { MP_ROM_QSTR(MP_QSTR_umount), MP_ROM_PTR(&MP_VFS_LFSx(umount_obj)) },\n};\nstatic MP_DEFINE_CONST_DICT(MP_VFS_LFSx(locals_dict), MP_VFS_LFSx(locals_dict_table));\n\nstatic mp_import_stat_t MP_VFS_LFSx(import_stat)(void *self_in, const char *path) {\n    MP_OBJ_VFS_LFSx *self = self_in;\n    struct LFSx_API (info) info;\n    mp_obj_str_t path_obj = { { &mp_type_str }, 0, 0, (const byte *)path };\n    path = MP_VFS_LFSx(make_path)(self, MP_OBJ_FROM_PTR(&path_obj));\n    int ret = LFSx_API(stat)(&self->lfs, path, &info);\n    if (ret == 0) {\n        if (info.type == LFSx_MACRO(_TYPE_REG)) {\n            return MP_IMPORT_STAT_FILE;\n        } else {\n            return MP_IMPORT_STAT_DIR;\n        }\n    }\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\nstatic const mp_vfs_proto_t MP_VFS_LFSx(proto) = {\n    .import_stat = MP_VFS_LFSx(import_stat),\n};\n\n#if LFS_BUILD_VERSION == 1\n#define VFS_LFSx_QSTR MP_QSTR_VfsLfs1\n#else\n#define VFS_LFSx_QSTR MP_QSTR_VfsLfs2\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    MP_TYPE_VFS_LFSx,\n    VFS_LFSx_QSTR,\n    MP_TYPE_FLAG_NONE,\n    make_new, MP_VFS_LFSx(make_new),\n    protocol, &MP_VFS_LFSx(proto),\n    locals_dict, &MP_VFS_LFSx(locals_dict)\n    );\n\n#undef VFS_LFSx_QSTR\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}