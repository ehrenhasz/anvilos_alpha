{
  "module_name": "lock.py",
  "hash_id": "9afba3021a5c586b9b1605b8d4c51a31ba31148da870a2b9431e1c7acc39a3cd",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/asyncio/lock.py",
  "human_readable_source": "# MicroPython asyncio module\n# MIT license; Copyright (c) 2019-2020 Damien P. George\n\nfrom . import core\n\n\n# Lock class for primitive mutex capability\nclass Lock:\n    def __init__(self):\n        # The state can take the following values:\n        # - 0: unlocked\n        # - 1: locked\n        # - <Task>: unlocked but this task has been scheduled to acquire the lock next\n        self.state = 0\n        # Queue of Tasks waiting to acquire this Lock\n        self.waiting = core.TaskQueue()\n\n    def locked(self):\n        return self.state == 1\n\n    def release(self):\n        if self.state != 1:\n            raise RuntimeError(\"Lock not acquired\")\n        if self.waiting.peek():\n            # Task(s) waiting on lock, schedule next Task\n            self.state = self.waiting.pop()\n            core._task_queue.push(self.state)\n        else:\n            # No Task waiting so unlock\n            self.state = 0\n\n    # async\n    def acquire(self):\n        if self.state != 0:\n            # Lock unavailable, put the calling Task on the waiting queue\n            self.waiting.push(core.cur_task)\n            # Set calling task's data to the lock's queue so it can be removed if needed\n            core.cur_task.data = self.waiting\n            try:\n                yield\n            except core.CancelledError as er:\n                if self.state == core.cur_task:\n                    # Cancelled while pending on resume, schedule next waiting Task\n                    self.state = 1\n                    self.release()\n                raise er\n        # Lock available, set it as locked\n        self.state = 1\n        return True\n\n    async def __aenter__(self):\n        return await self.acquire()\n\n    async def __aexit__(self, exc_type, exc, tb):\n        return self.release()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}