{
  "module_name": "core.py",
  "hash_id": "d3d3a2e8f124382424c3a5089e65749f3b93e733d918453d425f9641f78c293e",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/asyncio/core.py",
  "human_readable_source": "# MicroPython asyncio module\n# MIT license; Copyright (c) 2019 Damien P. George\n\nfrom time import ticks_ms as ticks, ticks_diff, ticks_add\nimport sys, select\n\n# Import TaskQueue and Task, preferring built-in C code over Python code\ntry:\n    from _asyncio import TaskQueue, Task\nexcept:\n    from .task import TaskQueue, Task\n\n\n################################################################################\n# Exceptions\n\n\nclass CancelledError(BaseException):\n    pass\n\n\nclass TimeoutError(Exception):\n    pass\n\n\n# Used when calling Loop.call_exception_handler\n_exc_context = {\"message\": \"Task exception wasn't retrieved\", \"exception\": None, \"future\": None}\n\n\n################################################################################\n# Sleep functions\n\n\n# \"Yield\" once, then raise StopIteration\nclass SingletonGenerator:\n    def __init__(self):\n        self.state = None\n        self.exc = StopIteration()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.state is not None:\n            _task_queue.push(cur_task, self.state)\n            self.state = None\n            return None\n        else:\n            self.exc.__traceback__ = None\n            raise self.exc\n\n\n# Pause task execution for the given time (integer in milliseconds, uPy extension)\n# Use a SingletonGenerator to do it without allocating on the heap\ndef sleep_ms(t, sgen=SingletonGenerator()):\n    assert sgen.state is None\n    sgen.state = ticks_add(ticks(), max(0, t))\n    return sgen\n\n\n# Pause task execution for the given time (in seconds)\ndef sleep(t):\n    return sleep_ms(int(t * 1000))\n\n\n################################################################################\n# Queue and poller for stream IO\n\n\nclass IOQueue:\n    def __init__(self):\n        self.poller = select.poll()\n        self.map = {}  # maps id(stream) to [task_waiting_read, task_waiting_write, stream]\n\n    def _enqueue(self, s, idx):\n        if id(s) not in self.map:\n            entry = [None, None, s]\n            entry[idx] = cur_task\n            self.map[id(s)] = entry\n            self.poller.register(s, select.POLLIN if idx == 0 else select.POLLOUT)\n        else:\n            sm = self.map[id(s)]\n            assert sm[idx] is None\n            assert sm[1 - idx] is not None\n            sm[idx] = cur_task\n            self.poller.modify(s, select.POLLIN | select.POLLOUT)\n        # Link task to this IOQueue so it can be removed if needed\n        cur_task.data = self\n\n    def _dequeue(self, s):\n        del self.map[id(s)]\n        self.poller.unregister(s)\n\n    def queue_read(self, s):\n        self._enqueue(s, 0)\n\n    def queue_write(self, s):\n        self._enqueue(s, 1)\n\n    def remove(self, task):\n        while True:\n            del_s = None\n            for k in self.map:  # Iterate without allocating on the heap\n                q0, q1, s = self.map[k]\n                if q0 is task or q1 is task:\n                    del_s = s\n                    break\n            if del_s is not None:\n                self._dequeue(s)\n            else:\n                break\n\n    def wait_io_event(self, dt):\n        for s, ev in self.poller.ipoll(dt):\n            sm = self.map[id(s)]\n            # print('poll', s, sm, ev)\n            if ev & ~select.POLLOUT and sm[0] is not None:\n                # POLLIN or error\n                _task_queue.push(sm[0])\n                sm[0] = None\n            if ev & ~select.POLLIN and sm[1] is not None:\n                # POLLOUT or error\n                _task_queue.push(sm[1])\n                sm[1] = None\n            if sm[0] is None and sm[1] is None:\n                self._dequeue(s)\n            elif sm[0] is None:\n                self.poller.modify(s, select.POLLOUT)\n            else:\n                self.poller.modify(s, select.POLLIN)\n\n\n################################################################################\n# Main run loop\n\n\n# Ensure the awaitable is a task\ndef _promote_to_task(aw):\n    return aw if isinstance(aw, Task) else create_task(aw)\n\n\n# Create and schedule a new task from a coroutine\ndef create_task(coro):\n    if not hasattr(coro, \"send\"):\n        raise TypeError(\"coroutine expected\")\n    t = Task(coro, globals())\n    _task_queue.push(t)\n    return t\n\n\n# Keep scheduling tasks until there are none left to schedule\ndef run_until_complete(main_task=None):\n    global cur_task\n    excs_all = (CancelledError, Exception)  # To prevent heap allocation in loop\n    excs_stop = (CancelledError, StopIteration)  # To prevent heap allocation in loop\n    while True:\n        # Wait until the head of _task_queue is ready to run\n        dt = 1\n        while dt > 0:\n            dt = -1\n            t = _task_queue.peek()\n            if t:\n                # A task waiting on _task_queue; \"ph_key\" is time to schedule task at\n                dt = max(0, ticks_diff(t.ph_key, ticks()))\n            elif not _io_queue.map:\n                # No tasks can be woken so finished running\n                cur_task = None\n                return\n            # print('(poll {})'.format(dt), len(_io_queue.map))\n            _io_queue.wait_io_event(dt)\n\n        # Get next task to run and continue it\n        t = _task_queue.pop()\n        cur_task = t\n        try:\n            # Continue running the coroutine, it's responsible for rescheduling itself\n            exc = t.data\n            if not exc:\n                t.coro.send(None)\n            else:\n                # If the task is finished and on the run queue and gets here, then it\n                # had an exception and was not await'ed on.  Throwing into it now will\n                # raise StopIteration and the code below will catch this and run the\n                # call_exception_handler function.\n                t.data = None\n                t.coro.throw(exc)\n        except excs_all as er:\n            # Check the task is not on any event queue\n            assert t.data is None\n            # This task is done, check if it's the main task and then loop should stop\n            if t is main_task:\n                cur_task = None\n                if isinstance(er, StopIteration):\n                    return er.value\n                raise er\n            if t.state:\n                # Task was running but is now finished.\n                waiting = False\n                if t.state is True:\n                    # \"None\" indicates that the task is complete and not await'ed on (yet).\n                    t.state = None\n                elif callable(t.state):\n                    # The task has a callback registered to be called on completion.\n                    t.state(t, er)\n                    t.state = False\n                    waiting = True\n                else:\n                    # Schedule any other tasks waiting on the completion of this task.\n                    while t.state.peek():\n                        _task_queue.push(t.state.pop())\n                        waiting = True\n                    # \"False\" indicates that the task is complete and has been await'ed on.\n                    t.state = False\n                if not waiting and not isinstance(er, excs_stop):\n                    # An exception ended this detached task, so queue it for later\n                    # execution to handle the uncaught exception if no other task retrieves\n                    # the exception in the meantime (this is handled by Task.throw).\n                    _task_queue.push(t)\n                # Save return value of coro to pass up to caller.\n                t.data = er\n            elif t.state is None:\n                # Task is already finished and nothing await'ed on the task,\n                # so call the exception handler.\n\n                # Save exception raised by the coro for later use.\n                t.data = exc\n\n                # Create exception context and call the exception handler.\n                _exc_context[\"exception\"] = exc\n                _exc_context[\"future\"] = t\n                Loop.call_exception_handler(_exc_context)\n\n\n# Create a new task from a coroutine and run it until it finishes\ndef run(coro):\n    return run_until_complete(create_task(coro))\n\n\n################################################################################\n# Event loop wrapper\n\n\nasync def _stopper():\n    pass\n\n\ncur_task = None\n_stop_task = None\n\n\nclass Loop:\n    _exc_handler = None\n\n    def create_task(coro):\n        return create_task(coro)\n\n    def run_forever():\n        global _stop_task\n        _stop_task = Task(_stopper(), globals())\n        run_until_complete(_stop_task)\n        # TODO should keep running until .stop() is called, even if there're no tasks left\n\n    def run_until_complete(aw):\n        return run_until_complete(_promote_to_task(aw))\n\n    def stop():\n        global _stop_task\n        if _stop_task is not None:\n            _task_queue.push(_stop_task)\n            # If stop() is called again, do nothing\n            _stop_task = None\n\n    def close():\n        pass\n\n    def set_exception_handler(handler):\n        Loop._exc_handler = handler\n\n    def get_exception_handler():\n        return Loop._exc_handler\n\n    def default_exception_handler(loop, context):\n        print(context[\"message\"], file=sys.stderr)\n        print(\"future:\", context[\"future\"], \"coro=\", context[\"future\"].coro, file=sys.stderr)\n        sys.print_exception(context[\"exception\"], sys.stderr)\n\n    def call_exception_handler(context):\n        (Loop._exc_handler or Loop.default_exception_handler)(Loop, context)\n\n\n# The runq_len and waitq_len arguments are for legacy uasyncio compatibility\ndef get_event_loop(runq_len=0, waitq_len=0):\n    return Loop\n\n\ndef current_task():\n    if cur_task is None:\n        raise RuntimeError(\"no running event loop\")\n    return cur_task\n\n\ndef new_event_loop():\n    global _task_queue, _io_queue\n    # TaskQueue of Task instances\n    _task_queue = TaskQueue()\n    # Task queue and poller for stream IO\n    _io_queue = IOQueue()\n    return Loop\n\n\n# Initialise default event loop\nnew_event_loop()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}