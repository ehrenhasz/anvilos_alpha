{
  "module_name": "funcs.py",
  "hash_id": "d6cb8867c71875f44356fd1faf628fc9bf3621bebe1c349cf3fa9595fabdfb5f",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/asyncio/funcs.py",
  "human_readable_source": "# MicroPython asyncio module\n# MIT license; Copyright (c) 2019-2022 Damien P. George\n\nfrom . import core\n\n\nasync def _run(waiter, aw):\n    try:\n        result = await aw\n        status = True\n    except BaseException as er:\n        result = None\n        status = er\n    if waiter.data is None:\n        # The waiter is still waiting, cancel it.\n        if waiter.cancel():\n            # Waiter was cancelled by us, change its CancelledError to an instance of\n            # CancelledError that contains the status and result of waiting on aw.\n            # If the wait_for task subsequently gets cancelled externally then this\n            # instance will be reset to a CancelledError instance without arguments.\n            waiter.data = core.CancelledError(status, result)\n\n\nasync def wait_for(aw, timeout, sleep=core.sleep):\n    aw = core._promote_to_task(aw)\n    if timeout is None:\n        return await aw\n\n    # Run aw in a separate runner task that manages its exceptions.\n    runner_task = core.create_task(_run(core.cur_task, aw))\n\n    try:\n        # Wait for the timeout to elapse.\n        await sleep(timeout)\n    except core.CancelledError as er:\n        status = er.value\n        if status is None:\n            # This wait_for was cancelled externally, so cancel aw and re-raise.\n            runner_task.cancel()\n            raise er\n        elif status is True:\n            # aw completed successfully and cancelled the sleep, so return aw's result.\n            return er.args[1]\n        else:\n            # aw raised an exception, propagate it out to the caller.\n            raise status\n\n    # The sleep finished before aw, so cancel aw and raise TimeoutError.\n    runner_task.cancel()\n    await runner_task\n    raise core.TimeoutError\n\n\ndef wait_for_ms(aw, timeout):\n    return wait_for(aw, timeout, core.sleep_ms)\n\n\nclass _Remove:\n    @staticmethod\n    def remove(t):\n        pass\n\n\n# async\ndef gather(*aws, return_exceptions=False):\n    def done(t, er):\n        # Sub-task \"t\" has finished, with exception \"er\".\n        nonlocal state\n        if gather_task.data is not _Remove:\n            # The main gather task has already been scheduled, so do nothing.\n            # This happens if another sub-task already raised an exception and\n            # woke the main gather task (via this done function), or if the main\n            # gather task was cancelled externally.\n            return\n        elif not return_exceptions and not isinstance(er, StopIteration):\n            # A sub-task raised an exception, indicate that to the gather task.\n            state = er\n        else:\n            state -= 1\n            if state:\n                # Still some sub-tasks running.\n                return\n        # Gather waiting is done, schedule the main gather task.\n        core._task_queue.push(gather_task)\n\n    # Prepare the sub-tasks for the gather.\n    # The `state` variable counts the number of tasks to wait for, and can be negative\n    # if the gather should not run at all (because a task already had an exception).\n    ts = [core._promote_to_task(aw) for aw in aws]\n    state = 0\n    for i in range(len(ts)):\n        if ts[i].state is True:\n            # Task is running, register the callback to call when the task is done.\n            ts[i].state = done\n            state += 1\n        elif not ts[i].state:\n            # Task finished already.\n            if not isinstance(ts[i].data, StopIteration):\n                # Task finished by raising an exception.\n                if not return_exceptions:\n                    # Do not run this gather at all.\n                    state = -len(ts)\n        else:\n            # Task being waited on, gather not currently supported for this case.\n            raise RuntimeError(\"can't gather\")\n\n    # Set the state for execution of the gather.\n    gather_task = core.cur_task\n    cancel_all = False\n\n    # Wait for a sub-task to need attention (if there are any to wait for).\n    if state > 0:\n        gather_task.data = _Remove\n        try:\n            yield\n        except core.CancelledError as er:\n            cancel_all = True\n            state = er\n\n    # Clean up tasks.\n    for i in range(len(ts)):\n        if ts[i].state is done:\n            # Sub-task is still running, deregister the callback and cancel if needed.\n            ts[i].state = True\n            if cancel_all:\n                ts[i].cancel()\n        elif isinstance(ts[i].data, StopIteration):\n            # Sub-task ran to completion, get its return value.\n            ts[i] = ts[i].data.value\n        else:\n            # Sub-task had an exception.\n            if return_exceptions:\n                # Get the sub-task exception to return in the list of return values.\n                ts[i] = ts[i].data\n            elif isinstance(state, int):\n                # Raise the sub-task exception, if there is not already an exception to raise.\n                state = ts[i].data\n\n    # Either this gather was cancelled, or one of the sub-tasks raised an exception with\n    # return_exceptions==False, so reraise the exception here.\n    if state:\n        raise state\n\n    # Return the list of return values of each sub-task.\n    return ts\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}