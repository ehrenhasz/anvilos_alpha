{
  "module_name": "stream.py",
  "hash_id": "3e1bf8798ae8e04cc018ae2155a8d272f301d361dea2611d0a9592ae03178a4d",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/asyncio/stream.py",
  "human_readable_source": "# MicroPython asyncio module\n# MIT license; Copyright (c) 2019-2020 Damien P. George\n\nfrom . import core\n\n\nclass Stream:\n    def __init__(self, s, e={}):\n        self.s = s\n        self.e = e\n        self.out_buf = b\"\"\n\n    def get_extra_info(self, v):\n        return self.e[v]\n\n    def close(self):\n        pass\n\n    async def wait_closed(self):\n        # TODO yield?\n        self.s.close()\n\n    # async\n    def read(self, n=-1):\n        r = b\"\"\n        while True:\n            yield core._io_queue.queue_read(self.s)\n            r2 = self.s.read(n)\n            if r2 is not None:\n                if n >= 0:\n                    return r2\n                if not len(r2):\n                    return r\n                r += r2\n\n    # async\n    def readinto(self, buf):\n        yield core._io_queue.queue_read(self.s)\n        return self.s.readinto(buf)\n\n    # async\n    def readexactly(self, n):\n        r = b\"\"\n        while n:\n            yield core._io_queue.queue_read(self.s)\n            r2 = self.s.read(n)\n            if r2 is not None:\n                if not len(r2):\n                    raise EOFError\n                r += r2\n                n -= len(r2)\n        return r\n\n    # async\n    def readline(self):\n        l = b\"\"\n        while True:\n            yield core._io_queue.queue_read(self.s)\n            l2 = self.s.readline()  # may do multiple reads but won't block\n            if l2 is None:\n                continue\n            l += l2\n            if not l2 or l[-1] == 10:  # \\n (check l in case l2 is str)\n                return l\n\n    def write(self, buf):\n        if not self.out_buf:\n            # Try to write immediately to the underlying stream.\n            ret = self.s.write(buf)\n            if ret == len(buf):\n                return\n            if ret is not None:\n                buf = buf[ret:]\n        self.out_buf += buf\n\n    # async\n    def drain(self):\n        if not self.out_buf:\n            # Drain must always yield, so a tight loop of write+drain can't block the scheduler.\n            return (yield from core.sleep_ms(0))\n        mv = memoryview(self.out_buf)\n        off = 0\n        while off < len(mv):\n            yield core._io_queue.queue_write(self.s)\n            ret = self.s.write(mv[off:])\n            if ret is not None:\n                off += ret\n        self.out_buf = b\"\"\n\n\n# Stream can be used for both reading and writing to save code size\nStreamReader = Stream\nStreamWriter = Stream\n\n\n# Create a TCP stream connection to a remote host\n#\n# async\ndef open_connection(host, port, ssl=None, server_hostname=None):\n    from errno import EINPROGRESS\n    import socket\n\n    ai = socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM)[0]  # TODO this is blocking!\n    s = socket.socket(ai[0], ai[1], ai[2])\n    s.setblocking(False)\n    try:\n        s.connect(ai[-1])\n    except OSError as er:\n        if er.errno != EINPROGRESS:\n            raise er\n    # wrap with SSL, if requested\n    if ssl:\n        if ssl is True:\n            import ssl as _ssl\n\n            ssl = _ssl.SSLContext(_ssl.PROTOCOL_TLS_CLIENT)\n        if not server_hostname:\n            server_hostname = host\n        s = ssl.wrap_socket(s, server_hostname=server_hostname, do_handshake_on_connect=False)\n        s.setblocking(False)\n    ss = Stream(s)\n    yield core._io_queue.queue_write(s)\n    return ss, ss\n\n\n# Class representing a TCP stream server, can be closed and used in \"async with\"\nclass Server:\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        self.close()\n        await self.wait_closed()\n\n    def close(self):\n        # Note: the _serve task must have already started by now due to the sleep\n        # in start_server, so `state` won't be clobbered at the start of _serve.\n        self.state = True\n        self.task.cancel()\n\n    async def wait_closed(self):\n        await self.task\n\n    async def _serve(self, s, cb, ssl):\n        self.state = False\n        # Accept incoming connections\n        while True:\n            try:\n                yield core._io_queue.queue_read(s)\n            except core.CancelledError as er:\n                # The server task was cancelled, shutdown server and close socket.\n                s.close()\n                if self.state:\n                    # If the server was explicitly closed, ignore the cancellation.\n                    return\n                else:\n                    # Otherwise e.g. the parent task was cancelled, propagate\n                    # cancellation.\n                    raise er\n            try:\n                s2, addr = s.accept()\n            except:\n                # Ignore a failed accept\n                continue\n            if ssl:\n                try:\n                    s2 = ssl.wrap_socket(s2, server_side=True, do_handshake_on_connect=False)\n                except OSError as e:\n                    core.sys.print_exception(e)\n                    s2.close()\n                    continue\n            s2.setblocking(False)\n            s2s = Stream(s2, {\"peername\": addr})\n            core.create_task(cb(s2s, s2s))\n\n\n# Helper function to start a TCP stream server, running as a new task\n# TODO could use an accept-callback on socket read activity instead of creating a task\nasync def start_server(cb, host, port, backlog=5, ssl=None):\n    import socket\n\n    # Create and bind server socket.\n    host = socket.getaddrinfo(host, port)[0]  # TODO this is blocking!\n    s = socket.socket()\n    s.setblocking(False)\n    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    s.bind(host[-1])\n    s.listen(backlog)\n\n    # Create and return server object and task.\n    srv = Server()\n    srv.task = core.create_task(srv._serve(s, cb, ssl))\n    try:\n        # Ensure that the _serve task has been scheduled so that it gets to\n        # handle cancellation.\n        await core.sleep_ms(0)\n    except core.CancelledError as er:\n        # If the parent task is cancelled during this first sleep, then\n        # we will leak the task and it will sit waiting for the socket, so\n        # cancel it.\n        srv.task.cancel()\n        raise er\n    return srv\n\n\n################################################################################\n# Legacy uasyncio compatibility\n\n\nasync def stream_awrite(self, buf, off=0, sz=-1):\n    if off != 0 or sz != -1:\n        buf = memoryview(buf)\n        if sz == -1:\n            sz = len(buf)\n        buf = buf[off : off + sz]\n    self.write(buf)\n    await self.drain()\n\n\nStream.aclose = Stream.wait_closed\nStream.awrite = stream_awrite\nStream.awritestr = stream_awrite  # TODO explicitly convert to bytes?\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}