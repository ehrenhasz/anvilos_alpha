{
  "module_name": "task.py",
  "hash_id": "46999c6993ea84ab0e813bd9fb417b0bafc8fd00b52daf4062d79fff1576fdde",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/asyncio/task.py",
  "human_readable_source": "# MicroPython asyncio module\n# MIT license; Copyright (c) 2019-2020 Damien P. George\n\n# This file contains the core TaskQueue based on a pairing heap, and the core Task class.\n# They can optionally be replaced by C implementations.\n\nfrom . import core\n\n\n# pairing-heap meld of 2 heaps; O(1)\ndef ph_meld(h1, h2):\n    if h1 is None:\n        return h2\n    if h2 is None:\n        return h1\n    lt = core.ticks_diff(h1.ph_key, h2.ph_key) < 0\n    if lt:\n        if h1.ph_child is None:\n            h1.ph_child = h2\n        else:\n            h1.ph_child_last.ph_next = h2\n        h1.ph_child_last = h2\n        h2.ph_next = None\n        h2.ph_rightmost_parent = h1\n        return h1\n    else:\n        h1.ph_next = h2.ph_child\n        h2.ph_child = h1\n        if h1.ph_next is None:\n            h2.ph_child_last = h1\n            h1.ph_rightmost_parent = h2\n        return h2\n\n\n# pairing-heap pairing operation; amortised O(log N)\ndef ph_pairing(child):\n    heap = None\n    while child is not None:\n        n1 = child\n        child = child.ph_next\n        n1.ph_next = None\n        if child is not None:\n            n2 = child\n            child = child.ph_next\n            n2.ph_next = None\n            n1 = ph_meld(n1, n2)\n        heap = ph_meld(heap, n1)\n    return heap\n\n\n# pairing-heap delete of a node; stable, amortised O(log N)\ndef ph_delete(heap, node):\n    if node is heap:\n        child = heap.ph_child\n        node.ph_child = None\n        return ph_pairing(child)\n    # Find parent of node\n    parent = node\n    while parent.ph_next is not None:\n        parent = parent.ph_next\n    parent = parent.ph_rightmost_parent\n    # Replace node with pairing of its children\n    if node is parent.ph_child and node.ph_child is None:\n        parent.ph_child = node.ph_next\n        node.ph_next = None\n        return heap\n    elif node is parent.ph_child:\n        child = node.ph_child\n        next = node.ph_next\n        node.ph_child = None\n        node.ph_next = None\n        node = ph_pairing(child)\n        parent.ph_child = node\n    else:\n        n = parent.ph_child\n        while node is not n.ph_next:\n            n = n.ph_next\n        child = node.ph_child\n        next = node.ph_next\n        node.ph_child = None\n        node.ph_next = None\n        node = ph_pairing(child)\n        if node is None:\n            node = n\n        else:\n            n.ph_next = node\n    node.ph_next = next\n    if next is None:\n        node.ph_rightmost_parent = parent\n        parent.ph_child_last = node\n    return heap\n\n\n# TaskQueue class based on the above pairing-heap functions.\nclass TaskQueue:\n    def __init__(self):\n        self.heap = None\n\n    def peek(self):\n        return self.heap\n\n    def push(self, v, key=None):\n        assert v.ph_child is None\n        assert v.ph_next is None\n        v.data = None\n        v.ph_key = key if key is not None else core.ticks()\n        self.heap = ph_meld(v, self.heap)\n\n    def pop(self):\n        v = self.heap\n        assert v.ph_next is None\n        self.heap = ph_pairing(v.ph_child)\n        v.ph_child = None\n        return v\n\n    def remove(self, v):\n        self.heap = ph_delete(self.heap, v)\n\n\n# Task class representing a coroutine, can be waited on and cancelled.\nclass Task:\n    def __init__(self, coro, globals=None):\n        self.coro = coro  # Coroutine of this Task\n        self.data = None  # General data for queue it is waiting on\n        self.state = True  # None, False, True, a callable, or a TaskQueue instance\n        self.ph_key = 0  # Pairing heap\n        self.ph_child = None  # Paring heap\n        self.ph_child_last = None  # Paring heap\n        self.ph_next = None  # Paring heap\n        self.ph_rightmost_parent = None  # Paring heap\n\n    def __iter__(self):\n        if not self.state:\n            # Task finished, signal that is has been await'ed on.\n            self.state = False\n        elif self.state is True:\n            # Allocated head of linked list of Tasks waiting on completion of this task.\n            self.state = TaskQueue()\n        elif type(self.state) is not TaskQueue:\n            # Task has state used for another purpose, so can't also wait on it.\n            raise RuntimeError(\"can't wait\")\n        return self\n\n    def __next__(self):\n        if not self.state:\n            # Task finished, raise return value to caller so it can continue.\n            raise self.data\n        else:\n            # Put calling task on waiting queue.\n            self.state.push(core.cur_task)\n            # Set calling task's data to this task that it waits on, to double-link it.\n            core.cur_task.data = self\n\n    def done(self):\n        return not self.state\n\n    def cancel(self):\n        # Check if task is already finished.\n        if not self.state:\n            return False\n        # Can't cancel self (not supported yet).\n        if self is core.cur_task:\n            raise RuntimeError(\"can't cancel self\")\n        # If Task waits on another task then forward the cancel to the one it's waiting on.\n        while isinstance(self.data, Task):\n            self = self.data\n        # Reschedule Task as a cancelled task.\n        if hasattr(self.data, \"remove\"):\n            # Not on the main running queue, remove the task from the queue it's on.\n            self.data.remove(self)\n            core._task_queue.push(self)\n        elif core.ticks_diff(self.ph_key, core.ticks()) > 0:\n            # On the main running queue but scheduled in the future, so bring it forward to now.\n            core._task_queue.remove(self)\n            core._task_queue.push(self)\n        self.data = core.CancelledError\n        return True\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}