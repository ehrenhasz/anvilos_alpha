{
  "module_name": "event.py",
  "hash_id": "5a5f1737ebfd2bd5f8342c21adcc8565cc8316bbcc95d8dbe45bdbb4c90550bc",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/asyncio/event.py",
  "human_readable_source": "# MicroPython asyncio module\n# MIT license; Copyright (c) 2019-2020 Damien P. George\n\nfrom . import core\n\n\n# Event class for primitive events that can be waited on, set, and cleared\nclass Event:\n    def __init__(self):\n        self.state = False  # False=unset; True=set\n        self.waiting = core.TaskQueue()  # Queue of Tasks waiting on completion of this event\n\n    def is_set(self):\n        return self.state\n\n    def set(self):\n        # Event becomes set, schedule any tasks waiting on it\n        # Note: This must not be called from anything except the thread running\n        # the asyncio loop (i.e. neither hard or soft IRQ, or a different thread).\n        while self.waiting.peek():\n            core._task_queue.push(self.waiting.pop())\n        self.state = True\n\n    def clear(self):\n        self.state = False\n\n    # async\n    def wait(self):\n        if not self.state:\n            # Event not set, put the calling task on the event's waiting queue\n            self.waiting.push(core.cur_task)\n            # Set calling task's data to the event's queue so it can be removed if needed\n            core.cur_task.data = self.waiting\n            yield\n        return True\n\n\n# MicroPython-extension: This can be set from outside the asyncio event loop,\n# such as other threads, IRQs or scheduler context. Implementation is a stream\n# that asyncio will poll until a flag is set.\n# Note: Unlike Event, this is self-clearing after a wait().\ntry:\n    import io\n\n    class ThreadSafeFlag(io.IOBase):\n        def __init__(self):\n            self.state = 0\n\n        def ioctl(self, req, flags):\n            if req == 3:  # MP_STREAM_POLL\n                return self.state * flags\n            return -1  # Other requests are unsupported\n\n        def set(self):\n            self.state = 1\n\n        def clear(self):\n            self.state = 0\n\n        async def wait(self):\n            if not self.state:\n                yield core._io_queue.queue_read(self)\n            self.state = 0\n\nexcept ImportError:\n    pass\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}