{
  "module_name": "vfs.h",
  "hash_id": "298f02b3571f0a3e8e3e7cacfb5cef9aa29ceaced3b149e1cb279561f9a3a9a8",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_EXTMOD_VFS_H\n#define MICROPY_INCLUDED_EXTMOD_VFS_H\n\n#include \"py/builtin.h\"\n#include \"py/obj.h\"\n\n\n\n#define MP_VFS_NONE ((mp_vfs_mount_t *)1)\n#define MP_VFS_ROOT ((mp_vfs_mount_t *)0)\n\n\n#define MP_S_IFDIR (0x4000)\n#define MP_S_IFREG (0x8000)\n\n\n#define MP_BLOCKDEV_FLAG_NATIVE         (0x0001) \n#define MP_BLOCKDEV_FLAG_FREE_OBJ       (0x0002) \n#define MP_BLOCKDEV_FLAG_HAVE_IOCTL     (0x0004) \n#define MP_BLOCKDEV_FLAG_NO_FILESYSTEM  (0x0008) \n\n\n#define MP_BLOCKDEV_IOCTL_INIT          (1)\n#define MP_BLOCKDEV_IOCTL_DEINIT        (2)\n#define MP_BLOCKDEV_IOCTL_SYNC          (3)\n#define MP_BLOCKDEV_IOCTL_BLOCK_COUNT   (4)\n#define MP_BLOCKDEV_IOCTL_BLOCK_SIZE    (5)\n#define MP_BLOCKDEV_IOCTL_BLOCK_ERASE   (6)\n\n\ntypedef struct _mp_vfs_proto_t {\n    mp_import_stat_t (*import_stat)(void *self, const char *path);\n} mp_vfs_proto_t;\n\ntypedef struct _mp_vfs_blockdev_t {\n    uint16_t flags;\n    size_t block_size;\n    mp_obj_t readblocks[5];\n    mp_obj_t writeblocks[5];\n    \n    union {\n        mp_obj_t ioctl[4];\n        struct {\n            mp_obj_t sync[2];\n            mp_obj_t count[2];\n        } old;\n    } u;\n} mp_vfs_blockdev_t;\n\ntypedef struct _mp_vfs_mount_t {\n    const char *str; \n    size_t len;\n    mp_obj_t obj;\n    struct _mp_vfs_mount_t *next;\n} mp_vfs_mount_t;\n\nvoid mp_vfs_blockdev_init(mp_vfs_blockdev_t *self, mp_obj_t bdev);\nint mp_vfs_blockdev_read(mp_vfs_blockdev_t *self, size_t block_num, size_t num_blocks, uint8_t *buf);\nint mp_vfs_blockdev_read_ext(mp_vfs_blockdev_t *self, size_t block_num, size_t block_off, size_t len, uint8_t *buf);\nint mp_vfs_blockdev_write(mp_vfs_blockdev_t *self, size_t block_num, size_t num_blocks, const uint8_t *buf);\nint mp_vfs_blockdev_write_ext(mp_vfs_blockdev_t *self, size_t block_num, size_t block_off, size_t len, const uint8_t *buf);\nmp_obj_t mp_vfs_blockdev_ioctl(mp_vfs_blockdev_t *self, uintptr_t cmd, uintptr_t arg);\n\nmp_vfs_mount_t *mp_vfs_lookup_path(const char *path, const char **path_out);\nmp_import_stat_t mp_vfs_import_stat(const char *path);\nmp_obj_t mp_vfs_mount(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args);\nmp_obj_t mp_vfs_umount(mp_obj_t mnt_in);\nmp_obj_t mp_vfs_open(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args);\nmp_obj_t mp_vfs_chdir(mp_obj_t path_in);\nmp_obj_t mp_vfs_getcwd(void);\nmp_obj_t mp_vfs_ilistdir(size_t n_args, const mp_obj_t *args);\nmp_obj_t mp_vfs_listdir(size_t n_args, const mp_obj_t *args);\nmp_obj_t mp_vfs_mkdir(mp_obj_t path_in);\nmp_obj_t mp_vfs_remove(mp_obj_t path_in);\nmp_obj_t mp_vfs_rename(mp_obj_t old_path_in, mp_obj_t new_path_in);\nmp_obj_t mp_vfs_rmdir(mp_obj_t path_in);\nmp_obj_t mp_vfs_stat(mp_obj_t path_in);\nmp_obj_t mp_vfs_statvfs(mp_obj_t path_in);\n\nint mp_vfs_mount_and_chdir_protected(mp_obj_t bdev, mp_obj_t mount_point);\n\nMP_DECLARE_CONST_FUN_OBJ_KW(mp_vfs_mount_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_umount_obj);\nMP_DECLARE_CONST_FUN_OBJ_KW(mp_vfs_open_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_chdir_obj);\nMP_DECLARE_CONST_FUN_OBJ_0(mp_vfs_getcwd_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(mp_vfs_ilistdir_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(mp_vfs_listdir_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_mkdir_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_remove_obj);\nMP_DECLARE_CONST_FUN_OBJ_2(mp_vfs_rename_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_rmdir_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_stat_obj);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_vfs_statvfs_obj);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}