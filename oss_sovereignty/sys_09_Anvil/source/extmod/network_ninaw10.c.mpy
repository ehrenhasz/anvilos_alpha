{
  "module_name": "network_ninaw10.c",
  "hash_id": "466c395521c516b5a6744eac1e425432503997e7f80d080953905c900ee7fea5",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/network_ninaw10.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK && MICROPY_PY_NETWORK_NINAW10\n\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdint.h>\n\n#include \"py/objtuple.h\"\n#include \"py/objlist.h\"\n#include \"py/stream.h\"\n#include \"py/runtime.h\"\n#include \"py/misc.h\"\n#include \"py/mperrno.h\"\n#include \"shared/netutils/netutils.h\"\n#include \"shared/runtime/softtimer.h\"\n#include \"extmod/modnetwork.h\"\n#include \"modmachine.h\"\n\n#include \"nina_wifi_drv.h\"\n\ntypedef struct _nina_obj_t {\n    mp_obj_base_t base;\n    bool active;\n    bool poll_enable;\n    uint32_t itf;\n    mp_uint_t security;\n    char ssid[NINA_MAX_SSID_LEN + 1];\n    char key[NINA_MAX_WPA_LEN + 1];\n} nina_obj_t;\n\n\n#define BIND_PORT_RANGE_MIN     (65000)\n#define BIND_PORT_RANGE_MAX     (65535)\n\n#define SOCKET_IOCTL_FIONREAD   (0x4004667F)\n#define SOCKET_IOCTL_FIONBIO    (0x8004667E)\n\n#define SOCKET_POLL_RD          (0x01)\n#define SOCKET_POLL_WR          (0x02)\n#define SOCKET_POLL_ERR         (0x04)\n\n#define SO_ACCEPTCONN           (0x0002)\n#define SO_ERROR                (0x1007)\n#define SO_TYPE                 (0x1008)\n#define SO_NO_CHECK             (0x100a)\n#define NINAW10_POLL_INTERVAL   (100)\n\n#define is_nonblocking_error(errno) ((errno) == MP_EAGAIN || (errno) == MP_EWOULDBLOCK || (errno) == MP_EINPROGRESS)\n\n#define debug_printf(...) \n\nstatic uint16_t bind_port = BIND_PORT_RANGE_MIN;\nconst mp_obj_type_t mod_network_nic_type_nina;\nstatic nina_obj_t network_nina_wl_sta = {{(mp_obj_type_t *)&mod_network_nic_type_nina}, false, false, MOD_NETWORK_STA_IF};\nstatic nina_obj_t network_nina_wl_ap = {{(mp_obj_type_t *)&mod_network_nic_type_nina}, false, false, MOD_NETWORK_AP_IF};\nstatic mp_sched_node_t mp_wifi_poll_node;\nstatic soft_timer_entry_t mp_wifi_poll_timer;\nstatic void network_ninaw10_deinit(void);\n\nstatic bool network_ninaw10_poll_list_is_empty(void) {\n    return MP_STATE_PORT(mp_wifi_poll_list) == NULL ||\n           MP_STATE_PORT(mp_wifi_poll_list)->len == 0;\n}\n\nstatic void network_ninaw10_poll_list_insert(mp_obj_t socket) {\n    if (MP_STATE_PORT(mp_wifi_poll_list) == NULL) {\n        MP_STATE_PORT(mp_wifi_poll_list) = mp_obj_new_list(0, NULL);\n    }\n    mp_obj_list_append(MP_STATE_PORT(mp_wifi_poll_list), socket);\n}\n\nstatic void network_ninaw10_poll_list_remove(mp_obj_t socket) {\n    if (MP_STATE_PORT(mp_wifi_poll_list) == NULL) {\n        return;\n    }\n    mp_obj_list_remove(MP_STATE_PORT(mp_wifi_poll_list), socket);\n    if (MP_STATE_PORT(mp_wifi_poll_list)->len == 0) {\n        MP_STATE_PORT(mp_wifi_poll_list) = NULL;\n    }\n}\n\nstatic void network_ninaw10_poll_sockets(mp_sched_node_t *node) {\n    (void)node;\n    for (mp_uint_t i = 0; MP_STATE_PORT(mp_wifi_poll_list) && i < MP_STATE_PORT(mp_wifi_poll_list)->len;) {\n        mod_network_socket_obj_t *socket = MP_STATE_PORT(mp_wifi_poll_list)->items[i];\n        uint8_t flags = 0;\n        if (socket->callback == MP_OBJ_NULL || nina_socket_poll(socket->fileno, &flags) < 0) {\n            \n            socket->callback = MP_OBJ_NULL;\n            network_ninaw10_poll_list_remove(socket);\n            \n            continue;\n        }\n        if (flags & SOCKET_POLL_RD) {\n            mp_call_function_1(socket->callback, MP_OBJ_FROM_PTR(socket));\n        }\n        i++;\n        debug_printf(\"poll_sockets(%d) -> flags %d\\n\", socket->fileno, flags);\n    }\n\n    if (!network_ninaw10_poll_list_is_empty()) {\n        \n        soft_timer_reinsert(&mp_wifi_poll_timer, NINAW10_POLL_INTERVAL);\n    }\n}\n\nstatic void network_ninaw10_poll_connect(mp_sched_node_t *node) {\n    nina_obj_t *self = &network_nina_wl_sta;\n\n    int status = nina_connection_status();\n    if (status == NINA_STATUS_CONNECTED) {\n        \n        self->poll_enable = false;\n    } else if (status != NINA_STATUS_NO_SSID_AVAIL) {\n        \n        \n        int reason = nina_connection_reason();\n        if (reason == NINA_ESP_REASON_AUTH_EXPIRE ||\n            reason == NINA_ESP_REASON_ASSOC_EXPIRE ||\n            reason == NINA_ESP_REASON_NOT_AUTHED ||\n            reason == NINA_ESP_REASON_4WAY_HANDSHAKE_TIMEOUT ||\n            reason >= NINA_ESP_REASON_BEACON_TIMEOUT) {\n            debug_printf(\"poll_connect() status: %d reason %d\\n\", status, reason);\n            if (nina_connect(self->ssid, self->security, self->key, 0) != 0) {\n                mp_raise_msg_varg(&mp_type_OSError,\n                    MP_ERROR_TEXT(\"could not connect to ssid=%s, sec=%d, key=%s\"),\n                    self->ssid, self->security, self->key);\n            }\n        } else {\n            \n            self->poll_enable = false;\n        }\n    }\n\n    \n    soft_timer_reinsert(&mp_wifi_poll_timer, NINAW10_POLL_INTERVAL);\n}\n\nstatic void network_ninaw10_timer_callback(soft_timer_entry_t *self) {\n    debug_printf(\"timer_callback() poll status STA: %d AP: %d SOCKETS: %d\\n\",\n        network_nina_wl_sta.poll_enable, network_nina_wl_ap.poll_enable, !network_ninaw10_poll_list_is_empty());\n    if (network_nina_wl_sta.poll_enable) {\n        mp_sched_schedule_node(&mp_wifi_poll_node, network_ninaw10_poll_connect);\n    } else if (!network_ninaw10_poll_list_is_empty()) {\n        mp_sched_schedule_node(&mp_wifi_poll_node, network_ninaw10_poll_sockets);\n    }\n}\n\nstatic mp_obj_t network_ninaw10_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n    mp_obj_t nina_obj;\n    if (n_args == 0 || mp_obj_get_int(args[0]) == MOD_NETWORK_STA_IF) {\n        nina_obj = MP_OBJ_FROM_PTR(&network_nina_wl_sta);\n    } else {\n        nina_obj = MP_OBJ_FROM_PTR(&network_nina_wl_ap);\n    }\n    \n    mod_network_register_nic(nina_obj);\n    return nina_obj;\n}\n\nstatic mp_obj_t network_ninaw10_active(size_t n_args, const mp_obj_t *args) {\n    nina_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    if (n_args == 2) {\n        bool active = mp_obj_is_true(args[1]);\n        if (active && !self->active) {\n            int error = 0;\n            if ((error = nina_init()) != 0) {\n                mp_raise_msg_varg(&mp_type_OSError,\n                    MP_ERROR_TEXT(\"failed to initialize Nina-W10 module, error: %d\"), error);\n            }\n            \n            uint8_t semver[NINA_FW_VER_LEN];\n            if (nina_fw_version(semver) != 0) {\n                nina_deinit();\n                mp_raise_msg_varg(&mp_type_OSError,\n                    MP_ERROR_TEXT(\"failed to read firmware version, error: %d\"), error);\n            }\n            \n            uint32_t fwmin = (NINA_FW_VER_MIN_MAJOR * 100) +\n                (NINA_FW_VER_MIN_MINOR * 10) +\n                (NINA_FW_VER_MIN_PATCH * 1);\n\n            uint32_t fwver = (semver[NINA_FW_VER_MAJOR_OFFS] - 48) * 100 +\n                (semver[NINA_FW_VER_MINOR_OFFS] - 48) * 10 +\n                (semver[NINA_FW_VER_PATCH_OFFS] - 48) * 1;\n\n            if (fwver < fwmin) {\n                mp_raise_msg_varg(&mp_type_OSError,\n                    MP_ERROR_TEXT(\"firmware version mismatch, minimum supported firmware is v%d.%d.%d found v%d.%d.%d\"),\n                    NINA_FW_VER_MIN_MAJOR, NINA_FW_VER_MIN_MINOR, NINA_FW_VER_MIN_PATCH, semver[NINA_FW_VER_MAJOR_OFFS] - 48,\n                    semver[NINA_FW_VER_MINOR_OFFS] - 48, semver[NINA_FW_VER_PATCH_OFFS] - 48);\n            }\n            soft_timer_static_init(&mp_wifi_poll_timer, SOFT_TIMER_MODE_ONE_SHOT, 0, network_ninaw10_timer_callback);\n        } else if (!active && self->active) {\n            network_ninaw10_deinit();\n            nina_deinit();\n        }\n        self->active = active;\n        return mp_const_none;\n    }\n    return mp_obj_new_bool(self->active);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_ninaw10_active_obj, 1, 2, network_ninaw10_active);\n\nstatic int nina_scan_callback(nina_scan_result_t *scan_result, void *arg) {\n    mp_obj_t scan_list = (mp_obj_t)arg;\n    mp_obj_t ap[6] = {\n        mp_obj_new_bytes((uint8_t *)scan_result->ssid, strlen(scan_result->ssid)),\n        mp_obj_new_bytes(scan_result->bssid, sizeof(scan_result->bssid)),\n        mp_obj_new_int(scan_result->channel),\n        mp_obj_new_int(scan_result->rssi),\n        mp_obj_new_int(scan_result->security),\n        MP_OBJ_NEW_SMALL_INT(1), \n    };\n    mp_obj_list_append(scan_list, mp_obj_new_tuple(MP_ARRAY_SIZE(ap), ap));\n    return 0;\n}\n\nstatic mp_obj_t network_ninaw10_scan(mp_obj_t self_in) {\n    mp_obj_t scan_list;\n    scan_list = mp_obj_new_list(0, NULL);\n    nina_scan(nina_scan_callback, scan_list, 10000);\n    return scan_list;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_ninaw10_scan_obj, network_ninaw10_scan);\n\nstatic mp_obj_t network_ninaw10_connect(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_ssid, ARG_key, ARG_security, ARG_channel };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_ssid,     MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_key,      MP_ARG_OBJ, {.u_obj = mp_const_none} },\n        { MP_QSTR_security, MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_channel,  MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 1} },\n    };\n\n    \n    nina_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    \n    const char *ssid = mp_obj_str_get_str(args[ARG_ssid].u_obj);\n\n    if (strlen(ssid) == 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"SSID can't be empty\"));\n    }\n\n    \n    const char *key = NULL;\n    if (args[ARG_key].u_obj != mp_const_none) {\n        key = mp_obj_str_get_str(args[ARG_key].u_obj);\n    }\n\n    \n    mp_uint_t security = args[ARG_security].u_int;\n    if (security == -1 && self->itf == MOD_NETWORK_STA_IF) {\n        security = NINA_SEC_WPA_PSK;\n    } else if (security == -1 && self->itf == MOD_NETWORK_AP_IF) {\n        security = NINA_SEC_WEP;\n    }\n\n    \n    if (security != NINA_SEC_OPEN && strlen(key) == 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"key can't be empty\"));\n    }\n\n    \n    if (!self->active) {\n        network_ninaw10_active(2, (mp_obj_t [2]) { pos_args[0], mp_const_true });\n    }\n\n    \n    if (nina_isconnected()) {\n        nina_disconnect();\n    }\n\n    if (self->itf == MOD_NETWORK_STA_IF) {\n        \n        if (nina_connect(ssid, security, key, 0) != 0) {\n            mp_raise_msg_varg(&mp_type_OSError,\n                MP_ERROR_TEXT(\"could not connect to ssid=%s, sec=%d, key=%s\"), ssid, security, key);\n        }\n\n        \n        self->security = security;\n        strncpy(self->key, key, NINA_MAX_WPA_LEN);\n        strncpy(self->ssid, ssid, NINA_MAX_SSID_LEN);\n        self->poll_enable = true;\n        soft_timer_reinsert(&mp_wifi_poll_timer, NINAW10_POLL_INTERVAL);\n    } else {\n        mp_uint_t channel = args[ARG_channel].u_int;\n\n        if (security != NINA_SEC_OPEN && security != NINA_SEC_WEP) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"AP mode only supports WEP or OPEN security modes\"));\n        }\n\n        \n        if (nina_start_ap(ssid, security, key, channel) != 0) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"failed to start in AP mode\"));\n        }\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_ninaw10_connect_obj, 1, network_ninaw10_connect);\n\nstatic mp_obj_t network_ninaw10_disconnect(mp_obj_t self_in) {\n    nina_disconnect();\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_ninaw10_disconnect_obj, network_ninaw10_disconnect);\n\nstatic mp_obj_t network_ninaw10_isconnected(mp_obj_t self_in) {\n    return mp_obj_new_bool(nina_isconnected());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(network_ninaw10_isconnected_obj, network_ninaw10_isconnected);\n\nstatic mp_obj_t network_ninaw10_ifconfig(size_t n_args, const mp_obj_t *args) {\n    nina_ifconfig_t ifconfig;\n    if (n_args == 1) {\n        \n        nina_ifconfig(&ifconfig, false);\n        mp_obj_t tuple[4] = {\n            netutils_format_ipv4_addr(ifconfig.ip_addr, NETUTILS_BIG),\n            netutils_format_ipv4_addr(ifconfig.subnet_addr, NETUTILS_BIG),\n            netutils_format_ipv4_addr(ifconfig.gateway_addr, NETUTILS_BIG),\n            netutils_format_ipv4_addr(ifconfig.dns_addr, NETUTILS_BIG),\n        };\n        return mp_obj_new_tuple(4, tuple);\n    } else {\n        \n        mp_obj_t *items;\n        mp_obj_get_array_fixed_n(args[1], 4, &items);\n        netutils_parse_ipv4_addr(items[0], ifconfig.ip_addr, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[1], ifconfig.subnet_addr, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[2], ifconfig.gateway_addr, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[3], ifconfig.dns_addr, NETUTILS_BIG);\n        nina_ifconfig(&ifconfig, true);\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_ninaw10_ifconfig_obj, 1, 2, network_ninaw10_ifconfig);\n\nstatic mp_obj_t network_ninaw10_config(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    nina_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    (void)self;\n\n    if (kwargs->used == 0) {\n        \n        if (n_args != 2) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[1])) {\n            case MP_QSTR_ssid: {\n                nina_netinfo_t netinfo;\n                nina_netinfo(&netinfo);\n                return mp_obj_new_str(netinfo.ssid, strlen(netinfo.ssid));\n            }\n            case MP_QSTR_security: {\n                nina_netinfo_t netinfo;\n                nina_netinfo(&netinfo);\n                return mp_obj_new_int(netinfo.security);\n            }\n            case MP_QSTR_mac:\n            case MP_QSTR_bssid: {\n                nina_netinfo_t netinfo;\n                nina_netinfo(&netinfo);\n                return mp_obj_new_bytes(netinfo.bssid, 6);\n            }\n            case MP_QSTR_fw_version: {\n                uint8_t fwver[NINA_FW_VER_LEN];\n                nina_fw_version(fwver);\n                return mp_obj_new_tuple(3, (mp_obj_t []) {\n                    mp_obj_new_int(fwver[NINA_FW_VER_MAJOR_OFFS] - 48),\n                    mp_obj_new_int(fwver[NINA_FW_VER_MINOR_OFFS] - 48),\n                    mp_obj_new_int(fwver[NINA_FW_VER_PATCH_OFFS] - 48)\n                });\n            }\n            default:\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n        }\n    } else {\n        if (self->itf != MOD_NETWORK_AP_IF) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"AP required\"));\n        }\n        \n        return network_ninaw10_connect(n_args, args, kwargs);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(network_ninaw10_config_obj, 1, network_ninaw10_config);\n\nstatic mp_obj_t network_ninaw10_status(size_t n_args, const mp_obj_t *args) {\n    nina_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    (void)self;\n\n    if (n_args == 1) {\n        \n        return mp_obj_new_bool(nina_isconnected());\n    }\n\n    \n    switch (mp_obj_str_get_qstr(args[1])) {\n        case MP_QSTR_rssi: {\n            nina_netinfo_t netinfo;\n            nina_netinfo(&netinfo);\n            return mp_obj_new_int(netinfo.rssi);\n        }\n        case MP_QSTR_stations: {\n            if (self->itf != MOD_NETWORK_AP_IF) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"AP required\"));\n            }\n            uint32_t sta_ip = 0;\n            mp_obj_t sta_list = mp_obj_new_list(0, NULL);\n            if (nina_connected_sta(&sta_ip) == 0) {\n                mp_obj_list_append(sta_list,\n                    netutils_format_inet_addr((uint8_t *)&sta_ip, 0, NETUTILS_BIG));\n            }\n            return sta_list;\n        }\n    }\n\n    mp_raise_ValueError(MP_ERROR_TEXT(\"unknown status param\"));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(network_ninaw10_status_obj, 1, 2, network_ninaw10_status);\n\nstatic mp_obj_t network_ninaw10_ioctl(mp_obj_t self_in, mp_obj_t cmd_in, mp_obj_t buf_in) {\n    debug_printf(\"ioctl(%d)\\n\", mp_obj_get_int(cmd_in));\n    nina_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t buf;\n    mp_get_buffer_raise(buf_in, &buf, MP_BUFFER_READ | MP_BUFFER_WRITE);\n    int ret = nina_ioctl(mp_obj_get_int(cmd_in), buf.len, buf.buf, self->itf);\n    if (ret != 0) {\n        mp_raise_msg_varg(&mp_type_OSError,\n            MP_ERROR_TEXT(\"ioctl %d failed %d\"), mp_obj_get_int(cmd_in), ret);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(network_ninaw10_ioctl_obj, network_ninaw10_ioctl);\n\nstatic int network_ninaw10_gethostbyname(mp_obj_t nic, const char *name, mp_uint_t len, uint8_t *out_ip) {\n    debug_printf(\"gethostbyname(%s)\\n\", name);\n    return nina_gethostbyname(name, out_ip);\n}\n\nstatic int network_ninaw10_socket_poll(mod_network_socket_obj_t *socket, uint32_t rwf, int *_errno) {\n    uint8_t flags = 0;\n    debug_printf(\"socket_polling_rw(%d, %d, %d)\\n\", socket->fileno, socket->timeout, rwf);\n    if (socket->timeout == 0) {\n        \n        return 0;\n    }\n    mp_uint_t start = mp_hal_ticks_ms();\n    for (; !(flags & rwf); mp_hal_delay_ms(5)) {\n        if (nina_socket_poll(socket->fileno, &flags) < 0) {\n            nina_socket_errno(_errno);\n            debug_printf(\"socket_poll(%d) -> errno %d flags %d\\n\", socket->fileno, *_errno, flags);\n            return -1;\n        }\n        if (!(flags & rwf) && socket->timeout != -1 &&\n            mp_hal_ticks_ms() - start > socket->timeout) {\n            *_errno = MP_ETIMEDOUT;\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int network_ninaw10_socket_setblocking(mod_network_socket_obj_t *socket, bool blocking, int *_errno) {\n    uint32_t nonblocking = !blocking;\n    \n    if (nina_socket_ioctl(socket->fileno, SOCKET_IOCTL_FIONBIO, &nonblocking, sizeof(nonblocking)) < 0) {\n        nina_socket_errno(_errno);\n        nina_socket_close(socket->fileno);\n        return -1;\n    }\n    return 0;\n}\n\nstatic int network_ninaw10_socket_listening(mod_network_socket_obj_t *socket, int *_errno) {\n    int listening = 0;\n    if (nina_socket_getsockopt(socket->fileno, MOD_NETWORK_SOL_SOCKET,\n        SO_ACCEPTCONN, &listening, sizeof(listening)) < 0) {\n        nina_socket_errno(_errno);\n        debug_printf(\"socket_getsockopt() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n    return listening;\n}\n\nstatic int network_ninaw10_socket_socket(mod_network_socket_obj_t *socket, int *_errno) {\n    debug_printf(\"socket_socket(%d %d %d)\\n\", socket->domain, socket->type, socket->proto);\n\n    uint8_t socket_type;\n\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM:\n            socket_type = NINA_SOCKET_TYPE_TCP;\n            break;\n\n        case MOD_NETWORK_SOCK_DGRAM:\n            socket_type = NINA_SOCKET_TYPE_UDP;\n            break;\n\n        case MOD_NETWORK_SOCK_RAW:\n            socket_type = NINA_SOCKET_TYPE_RAW;\n            break;\n\n        default:\n            *_errno = MP_EINVAL;\n            return -1;\n    }\n\n    if (socket->domain != MOD_NETWORK_AF_INET) {\n        *_errno = MP_EAFNOSUPPORT;\n        return -1;\n    }\n\n    \n    int fd = nina_socket_socket(socket_type, socket->proto);\n    if (fd < 0) {\n        nina_socket_errno(_errno);\n        debug_printf(\"socket_socket() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n\n    \n    socket->fileno = fd;\n    socket->bound = false;\n    socket->callback = MP_OBJ_NULL;\n    return network_ninaw10_socket_setblocking(socket, false, _errno);\n}\n\nstatic void network_ninaw10_socket_close(mod_network_socket_obj_t *socket) {\n    debug_printf(\"socket_close(%d)\\n\", socket->fileno);\n    if (socket->callback != MP_OBJ_NULL) {\n        socket->callback = MP_OBJ_NULL;\n        network_ninaw10_poll_list_remove(socket);\n    }\n    if (socket->fileno >= 0) {\n        nina_socket_close(socket->fileno);\n        socket->fileno = -1; \n    }\n}\n\nstatic int network_ninaw10_socket_bind(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {\n    debug_printf(\"socket_bind(%d, %d)\\n\", socket->fileno, port);\n\n    int ret = nina_socket_bind(socket->fileno, ip, port);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        network_ninaw10_socket_close(socket);\n        debug_printf(\"socket_bind(%d, %d) -> errno: %d\\n\", socket->fileno, port, *_errno);\n        return -1;\n    }\n\n    \n    socket->bound = true;\n    return 0;\n}\n\nstatic int network_ninaw10_socket_listen(mod_network_socket_obj_t *socket, mp_int_t backlog, int *_errno) {\n    debug_printf(\"socket_listen(%d, %d)\\n\", socket->fileno, backlog);\n    int ret = nina_socket_listen(socket->fileno, backlog);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        network_ninaw10_socket_close(socket);\n        debug_printf(\"socket_listen() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n    return 0;\n}\n\nstatic int network_ninaw10_socket_accept(mod_network_socket_obj_t *socket,\n    mod_network_socket_obj_t *socket2, byte *ip, mp_uint_t *port, int *_errno) {\n    debug_printf(\"socket_accept(%d)\\n\", socket->fileno);\n\n    if (network_ninaw10_socket_poll(socket, SOCKET_POLL_RD, _errno) != 0) {\n        return -1;\n    }\n\n    *port = 0;\n    int fd = 0;\n    int ret = nina_socket_accept(socket->fileno, ip, (uint16_t *)port, &fd);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        \n        if (!is_nonblocking_error(*_errno)) {\n            network_ninaw10_socket_close(socket);\n        }\n        debug_printf(\"socket_accept() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n\n    \n    socket2->fileno = fd;\n    socket2->bound = false;\n    socket2->timeout = -1;\n    socket2->callback = MP_OBJ_NULL;\n    return network_ninaw10_socket_setblocking(socket2, false, _errno);\n}\n\nstatic int network_ninaw10_socket_connect(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {\n    debug_printf(\"socket_connect(%d)\\n\", socket->fileno);\n\n    int ret = nina_socket_connect(socket->fileno, ip, port);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        debug_printf(\"socket_connect() -> errno %d\\n\", *_errno);\n\n        \n        if (!is_nonblocking_error(*_errno)) {\n            network_ninaw10_socket_close(socket);\n            return -1;\n        }\n\n        \n        if (socket->timeout == 0 ||\n            network_ninaw10_socket_poll(socket, SOCKET_POLL_WR, _errno) != 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic mp_uint_t network_ninaw10_socket_send(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, int *_errno) {\n    debug_printf(\"socket_send(%d, %d)\\n\", socket->fileno, len);\n\n    if (network_ninaw10_socket_poll(socket, SOCKET_POLL_WR, _errno) != 0) {\n        return -1;\n    }\n\n    int ret = nina_socket_send(socket->fileno, buf, len);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        \n        if (!is_nonblocking_error(*_errno)) {\n            network_ninaw10_socket_close(socket);\n        }\n        debug_printf(\"socket_send() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n    return ret;\n}\n\nstatic mp_uint_t network_ninaw10_socket_recv(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, int *_errno) {\n    debug_printf(\"socket_recv(%d)\\n\", socket->fileno);\n    \n    if (network_ninaw10_socket_listening(socket, _errno) == 1) {\n        *_errno = MP_ENOTCONN;\n        return -1;\n    }\n\n    if (network_ninaw10_socket_poll(socket, SOCKET_POLL_RD, _errno) != 0) {\n        return -1;\n    }\n\n    int ret = nina_socket_recv(socket->fileno, buf, len);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        if (*_errno == MP_ENOTCONN) {\n            *_errno = 0;\n            return 0;\n        }\n        \n        if (!is_nonblocking_error(*_errno)) {\n            network_ninaw10_socket_close(socket);\n        }\n        debug_printf(\"socket_recv() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n    return ret;\n}\n\nstatic mp_uint_t network_ninaw10_socket_auto_bind(mod_network_socket_obj_t *socket, int *_errno) {\n    debug_printf(\"socket_autobind(%d)\\n\", socket->fileno);\n    if (socket->bound == false && socket->type != MOD_NETWORK_SOCK_RAW) {\n        if (network_ninaw10_socket_bind(socket, NULL, bind_port, _errno) != 0) {\n            nina_socket_errno(_errno);\n            debug_printf(\"socket_bind() -> errno %d\\n\", *_errno);\n            return -1;\n        }\n        bind_port++;\n        bind_port = MIN(MAX(bind_port, BIND_PORT_RANGE_MIN), BIND_PORT_RANGE_MAX);\n    }\n    return 0;\n}\n\nstatic mp_uint_t network_ninaw10_socket_sendto(mod_network_socket_obj_t *socket,\n    const byte *buf, mp_uint_t len, byte *ip, mp_uint_t port, int *_errno) {\n    debug_printf(\"socket_sendto(%d)\\n\", socket->fileno);\n    \n    if (network_ninaw10_socket_auto_bind(socket, _errno) != 0) {\n        return -1;\n    }\n\n    if (network_ninaw10_socket_poll(socket, SOCKET_POLL_WR, _errno) != 0) {\n        return -1;\n    }\n\n    int ret = nina_socket_sendto(socket->fileno, buf, len, ip, port);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        \n        if (!is_nonblocking_error(*_errno)) {\n            network_ninaw10_socket_close(socket);\n        }\n        return -1;\n    }\n    return ret;\n}\n\nstatic mp_uint_t network_ninaw10_socket_recvfrom(mod_network_socket_obj_t *socket,\n    byte *buf, mp_uint_t len, byte *ip, mp_uint_t *port, int *_errno) {\n    debug_printf(\"socket_recvfrom(%d)\\n\", socket->fileno);\n    \n    if (network_ninaw10_socket_auto_bind(socket, _errno) != 0) {\n        return -1;\n    }\n\n    if (network_ninaw10_socket_poll(socket, SOCKET_POLL_RD, _errno) != 0) {\n        return -1;\n    }\n\n    *port = 0;\n    int ret = nina_socket_recvfrom(socket->fileno, buf, len, ip, (uint16_t *)port);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        \n        if (!is_nonblocking_error(*_errno)) {\n            network_ninaw10_socket_close(socket);\n        }\n        debug_printf(\"socket_recvfrom() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n    return ret;\n}\n\nstatic int network_ninaw10_socket_setsockopt(mod_network_socket_obj_t *socket, mp_uint_t\n    level, mp_uint_t opt, const void *optval, mp_uint_t optlen, int *_errno) {\n    debug_printf(\"socket_setsockopt(%d, %d)\\n\", socket->fileno, opt);\n    if (opt == 20) {\n        mp_sched_lock();\n        socket->callback = (void *)optval;\n        if (socket->callback != MP_OBJ_NULL) {\n            network_ninaw10_poll_list_insert(socket);\n            soft_timer_reinsert(&mp_wifi_poll_timer, NINAW10_POLL_INTERVAL);\n        }\n        mp_sched_unlock();\n        return 0;\n    }\n    int ret = nina_socket_setsockopt(socket->fileno, level, opt, optval, optlen);\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        network_ninaw10_socket_close(socket);\n        debug_printf(\"socket_setsockopt() -> errno %d\\n\", *_errno);\n        return -1;\n    }\n    return 0;\n}\n\nstatic int network_ninaw10_socket_settimeout(mod_network_socket_obj_t *socket, mp_uint_t timeout_ms, int *_errno) {\n    debug_printf(\"socket_settimeout(%d, %d)\\n\", socket->fileno, timeout_ms);\n    #if 0\n    if (timeout_ms == 0 || timeout_ms == UINT32_MAX) {\n        \n        uint32_t nonblocking = (timeout_ms == 0);\n        ret |= nina_socket_ioctl(socket->fileno, SOCKET_IOCTL_FIONBIO, &nonblocking, sizeof(nonblocking));\n    } else {\n        \n        uint32_t tv[2] = {\n            (timeout_ms / 1000),\n            (timeout_ms % 1000) * 1000,\n        };\n        ret |= nina_socket_setsockopt(socket->fileno, MOD_NETWORK_SOL_SOCKET, MOD_NETWORK_SO_SNDTIMEO, tv, sizeof(tv));\n        ret |= nina_socket_setsockopt(socket->fileno, MOD_NETWORK_SOL_SOCKET, MOD_NETWORK_SO_RCVTIMEO, tv, sizeof(tv));\n    }\n    if (ret < 0) {\n        nina_socket_errno(_errno);\n        debug_printf(\"socket_settimeout() -> errno %d\\n\", *_errno);\n    }\n    #endif\n    socket->timeout = timeout_ms;\n    return 0;\n}\n\nstatic int network_ninaw10_socket_ioctl(mod_network_socket_obj_t *socket, mp_uint_t request, mp_uint_t arg, int *_errno) {\n    mp_uint_t ret = 0;\n    debug_printf(\"socket_ioctl(%d, %d)\\n\", socket->fileno, request);\n    if (request == MP_STREAM_POLL) {\n        uint8_t flags = 0;\n        if (nina_socket_poll(socket->fileno, &flags) < 0) {\n            nina_socket_errno(_errno);\n            ret = MP_STREAM_ERROR;\n            debug_printf(\"socket_ioctl() -> errno %d\\n\", *_errno);\n        }\n        if ((arg & MP_STREAM_POLL_RD) && (flags & SOCKET_POLL_RD)) {\n            ret |= MP_STREAM_POLL_RD;\n        }\n        if ((arg & MP_STREAM_POLL_WR) && (flags & SOCKET_POLL_WR)) {\n            ret |= MP_STREAM_POLL_WR;\n        }\n    } else {\n        \n        *_errno = MP_EINVAL;\n        ret = MP_STREAM_ERROR;\n    }\n    return ret;\n}\n\nstatic void network_ninaw10_deinit(void) {\n    \n    \n    \n    soft_timer_remove(&mp_wifi_poll_timer);\n    MP_STATE_PORT(mp_wifi_poll_list) = NULL;\n}\n\nstatic const mp_rom_map_elem_t nina_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_active),              MP_ROM_PTR(&network_ninaw10_active_obj) },\n    { MP_ROM_QSTR(MP_QSTR_scan),                MP_ROM_PTR(&network_ninaw10_scan_obj) },\n    { MP_ROM_QSTR(MP_QSTR_connect),             MP_ROM_PTR(&network_ninaw10_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_disconnect),          MP_ROM_PTR(&network_ninaw10_disconnect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isconnected),         MP_ROM_PTR(&network_ninaw10_isconnected_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ifconfig),            MP_ROM_PTR(&network_ninaw10_ifconfig_obj) },\n    { MP_ROM_QSTR(MP_QSTR_config),              MP_ROM_PTR(&network_ninaw10_config_obj) },\n    { MP_ROM_QSTR(MP_QSTR_status),              MP_ROM_PTR(&network_ninaw10_status_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ioctl),               MP_ROM_PTR(&network_ninaw10_ioctl_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_IF_STA),              MP_ROM_INT(MOD_NETWORK_STA_IF) },\n    { MP_ROM_QSTR(MP_QSTR_IF_AP),               MP_ROM_INT(MOD_NETWORK_AP_IF) },\n\n    { MP_ROM_QSTR(MP_QSTR_SEC_OPEN),            MP_ROM_INT(NINA_SEC_OPEN) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_WEP),             MP_ROM_INT(NINA_SEC_WEP) },\n    { MP_ROM_QSTR(MP_QSTR_SEC_WPA_WPA2),        MP_ROM_INT(NINA_SEC_WPA_PSK) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_OPEN),                MP_ROM_INT(NINA_SEC_OPEN) },\n    { MP_ROM_QSTR(MP_QSTR_WEP),                 MP_ROM_INT(NINA_SEC_WEP) },\n    { MP_ROM_QSTR(MP_QSTR_WPA_PSK),             MP_ROM_INT(NINA_SEC_WPA_PSK) },\n};\n\nstatic MP_DEFINE_CONST_DICT(nina_locals_dict, nina_locals_dict_table);\n\nstatic const mod_network_nic_protocol_t mod_network_nic_protocol_nina = {\n    .gethostbyname = network_ninaw10_gethostbyname,\n    .deinit = network_ninaw10_deinit,\n    .socket = network_ninaw10_socket_socket,\n    .close = network_ninaw10_socket_close,\n    .bind = network_ninaw10_socket_bind,\n    .listen = network_ninaw10_socket_listen,\n    .accept = network_ninaw10_socket_accept,\n    .connect = network_ninaw10_socket_connect,\n    .send = network_ninaw10_socket_send,\n    .recv = network_ninaw10_socket_recv,\n    .sendto = network_ninaw10_socket_sendto,\n    .recvfrom = network_ninaw10_socket_recvfrom,\n    .setsockopt = network_ninaw10_socket_setsockopt,\n    .settimeout = network_ninaw10_socket_settimeout,\n    .ioctl = network_ninaw10_socket_ioctl,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mod_network_nic_type_nina,\n    MP_QSTR_nina,\n    MP_TYPE_FLAG_NONE,\n    make_new, network_ninaw10_make_new,\n    locals_dict, &nina_locals_dict,\n    protocol, &mod_network_nic_protocol_nina\n    );\n\nMP_REGISTER_ROOT_POINTER(struct _machine_spi_obj_t *mp_wifi_spi);\nMP_REGISTER_ROOT_POINTER(struct _mp_obj_list_t *mp_wifi_poll_list);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}