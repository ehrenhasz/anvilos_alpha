{
  "module_name": "machine_i2s.c",
  "hash_id": "7aabb877754b8f17384ed645b61c25d523cba2000a7c47949d020af6a1371776",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_i2s.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n\n#if MICROPY_PY_MACHINE_I2S\n\n#include \"extmod/modmachine.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define NUM_I2S_USER_FORMATS (4)\n#define I2S_RX_FRAME_SIZE_IN_BYTES (8)\n\ntypedef enum {\n    MONO,\n    STEREO\n} format_t;\n\ntypedef enum {\n    BLOCKING,\n    NON_BLOCKING,\n    ASYNCIO\n} io_mode_t;\n\n\nenum {\n    ARG_sck,\n    ARG_ws,\n    ARG_sd,\n    #if MICROPY_PY_MACHINE_I2S_MCK\n    ARG_mck,\n    #endif\n    ARG_mode,\n    ARG_bits,\n    ARG_format,\n    ARG_rate,\n    ARG_ibuf,\n};\n\n#if MICROPY_PY_MACHINE_I2S_RING_BUF\n\ntypedef struct _ring_buf_t {\n    uint8_t *buffer;\n    size_t head;\n    size_t tail;\n    size_t size;\n} ring_buf_t;\n\ntypedef struct _non_blocking_descriptor_t {\n    mp_buffer_info_t appbuf;\n    uint32_t index;\n    bool copy_in_progress;\n} non_blocking_descriptor_t;\n\nstatic void ringbuf_init(ring_buf_t *rbuf, uint8_t *buffer, size_t size);\nstatic bool ringbuf_push(ring_buf_t *rbuf, uint8_t data);\nstatic bool ringbuf_pop(ring_buf_t *rbuf, uint8_t *data);\nstatic size_t ringbuf_available_data(ring_buf_t *rbuf);\nstatic size_t ringbuf_available_space(ring_buf_t *rbuf);\nstatic void fill_appbuf_from_ringbuf_non_blocking(machine_i2s_obj_t *self);\nstatic void copy_appbuf_to_ringbuf_non_blocking(machine_i2s_obj_t *self);\n\n#endif \n\n\nstatic void mp_machine_i2s_init_helper(machine_i2s_obj_t *self, mp_arg_val_t *args);\nstatic machine_i2s_obj_t *mp_machine_i2s_make_new_instance(mp_int_t i2s_id);\nstatic void mp_machine_i2s_deinit(machine_i2s_obj_t *self);\nstatic void mp_machine_i2s_irq_update(machine_i2s_obj_t *self);\n\n\n#include MICROPY_PY_MACHINE_I2S_INCLUDEFILE\n\n#if MICROPY_PY_MACHINE_I2S_RING_BUF\n\n\n\n\n\n\n\nstatic void ringbuf_init(ring_buf_t *rbuf, uint8_t *buffer, size_t size) {\n    rbuf->buffer = buffer;\n    rbuf->size = size;\n    rbuf->head = 0;\n    rbuf->tail = 0;\n}\n\nstatic bool ringbuf_push(ring_buf_t *rbuf, uint8_t data) {\n    size_t next_tail = (rbuf->tail + 1) % rbuf->size;\n\n    if (next_tail != rbuf->head) {\n        rbuf->buffer[rbuf->tail] = data;\n        rbuf->tail = next_tail;\n        return true;\n    }\n\n    \n    return false;\n}\n\nstatic bool ringbuf_pop(ring_buf_t *rbuf, uint8_t *data) {\n    if (rbuf->head == rbuf->tail) {\n        \n        return false;\n    }\n\n    *data = rbuf->buffer[rbuf->head];\n    rbuf->head = (rbuf->head + 1) % rbuf->size;\n    return true;\n}\n\nstatic bool ringbuf_is_empty(ring_buf_t *rbuf) {\n    return rbuf->head == rbuf->tail;\n}\n\nstatic bool ringbuf_is_full(ring_buf_t *rbuf) {\n    return ((rbuf->tail + 1) % rbuf->size) == rbuf->head;\n}\n\nstatic size_t ringbuf_available_data(ring_buf_t *rbuf) {\n    return (rbuf->tail - rbuf->head + rbuf->size) % rbuf->size;\n}\n\nstatic size_t ringbuf_available_space(ring_buf_t *rbuf) {\n    return rbuf->size - ringbuf_available_data(rbuf) - 1;\n}\n\nstatic uint32_t fill_appbuf_from_ringbuf(machine_i2s_obj_t *self, mp_buffer_info_t *appbuf) {\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    uint32_t num_bytes_copied_to_appbuf = 0;\n    uint8_t *app_p = (uint8_t *)appbuf->buf;\n    uint8_t appbuf_sample_size_in_bytes = (self->bits == 16? 2 : 4) * (self->format == STEREO ? 2: 1);\n    uint32_t num_bytes_needed_from_ringbuf = appbuf->len * (I2S_RX_FRAME_SIZE_IN_BYTES / appbuf_sample_size_in_bytes);\n    uint8_t discard_byte;\n    while (num_bytes_needed_from_ringbuf) {\n\n        uint8_t f_index = get_frame_mapping_index(self->bits, self->format);\n\n        for (uint8_t i = 0; i < I2S_RX_FRAME_SIZE_IN_BYTES; i++) {\n            int8_t r_to_a_mapping = i2s_frame_map[f_index][i];\n            if (r_to_a_mapping != -1) {\n                if (self->io_mode == BLOCKING) {\n                    \n                    while (ringbuf_pop(&self->ring_buffer, app_p + r_to_a_mapping) == false) {\n                        ;\n                    }\n                    num_bytes_copied_to_appbuf++;\n                } else if (self->io_mode == ASYNCIO) {\n                    if (ringbuf_pop(&self->ring_buffer, app_p + r_to_a_mapping) == false) {\n                        \n                        goto exit;\n                    } else {\n                        num_bytes_copied_to_appbuf++;\n                    }\n                } else {\n                    return 0;  \n                }\n            } else { \n                \n                if (self->io_mode == BLOCKING) {\n                    \n                    while (ringbuf_pop(&self->ring_buffer, &discard_byte) == false) {\n                        ;\n                    }\n                } else if (self->io_mode == ASYNCIO) {\n                    if (ringbuf_pop(&self->ring_buffer, &discard_byte) == false) {\n                        \n                        goto exit;\n                    }\n                } else {\n                    return 0;  \n                }\n            }\n            num_bytes_needed_from_ringbuf--;\n        }\n        app_p += appbuf_sample_size_in_bytes;\n    }\nexit:\n    return num_bytes_copied_to_appbuf;\n}\n\n\nstatic void fill_appbuf_from_ringbuf_non_blocking(machine_i2s_obj_t *self) {\n\n    \n    \n\n    uint32_t num_bytes_copied_to_appbuf = 0;\n    uint8_t *app_p = &(((uint8_t *)self->non_blocking_descriptor.appbuf.buf)[self->non_blocking_descriptor.index]);\n\n    uint8_t appbuf_sample_size_in_bytes = (self->bits == 16? 2 : 4) * (self->format == STEREO ? 2: 1);\n    uint32_t num_bytes_remaining_to_copy_to_appbuf = self->non_blocking_descriptor.appbuf.len - self->non_blocking_descriptor.index;\n    uint32_t num_bytes_remaining_to_copy_from_ring_buffer = num_bytes_remaining_to_copy_to_appbuf *\n        (I2S_RX_FRAME_SIZE_IN_BYTES / appbuf_sample_size_in_bytes);\n    uint32_t num_bytes_needed_from_ringbuf = MIN(SIZEOF_NON_BLOCKING_COPY_IN_BYTES, num_bytes_remaining_to_copy_from_ring_buffer);\n    uint8_t discard_byte;\n    if (ringbuf_available_data(&self->ring_buffer) >= num_bytes_needed_from_ringbuf) {\n        while (num_bytes_needed_from_ringbuf) {\n\n            uint8_t f_index = get_frame_mapping_index(self->bits, self->format);\n\n            for (uint8_t i = 0; i < I2S_RX_FRAME_SIZE_IN_BYTES; i++) {\n                int8_t r_to_a_mapping = i2s_frame_map[f_index][i];\n                if (r_to_a_mapping != -1) {\n                    ringbuf_pop(&self->ring_buffer, app_p + r_to_a_mapping);\n                    num_bytes_copied_to_appbuf++;\n                } else { \n                    \n                    ringbuf_pop(&self->ring_buffer, &discard_byte);\n                }\n                num_bytes_needed_from_ringbuf--;\n            }\n            app_p += appbuf_sample_size_in_bytes;\n        }\n        self->non_blocking_descriptor.index += num_bytes_copied_to_appbuf;\n\n        if (self->non_blocking_descriptor.index >= self->non_blocking_descriptor.appbuf.len) {\n            self->non_blocking_descriptor.copy_in_progress = false;\n            mp_sched_schedule(self->callback_for_non_blocking, MP_OBJ_FROM_PTR(self));\n        }\n    }\n}\n\nstatic uint32_t copy_appbuf_to_ringbuf(machine_i2s_obj_t *self, mp_buffer_info_t *appbuf) {\n\n    \n    \n    \n\n    uint32_t a_index = 0;\n\n    while (a_index < appbuf->len) {\n        if (self->io_mode == BLOCKING) {\n            \n            while (ringbuf_push(&self->ring_buffer, ((uint8_t *)appbuf->buf)[a_index]) == false) {\n                ;\n            }\n            a_index++;\n        } else if (self->io_mode == ASYNCIO) {\n            if (ringbuf_push(&self->ring_buffer, ((uint8_t *)appbuf->buf)[a_index]) == false) {\n                \n                break;\n            } else {\n                a_index++;\n            }\n        } else {\n            return 0;  \n        }\n    }\n\n    return a_index;\n}\n\n\nstatic void copy_appbuf_to_ringbuf_non_blocking(machine_i2s_obj_t *self) {\n\n    \n    uint32_t num_bytes_remaining_to_copy = self->non_blocking_descriptor.appbuf.len - self->non_blocking_descriptor.index;\n    uint32_t num_bytes_to_copy = MIN(SIZEOF_NON_BLOCKING_COPY_IN_BYTES, num_bytes_remaining_to_copy);\n\n    if (ringbuf_available_space(&self->ring_buffer) >= num_bytes_to_copy) {\n        for (uint32_t i = 0; i < num_bytes_to_copy; i++) {\n            ringbuf_push(&self->ring_buffer,\n                ((uint8_t *)self->non_blocking_descriptor.appbuf.buf)[self->non_blocking_descriptor.index + i]);\n        }\n\n        self->non_blocking_descriptor.index += num_bytes_to_copy;\n        if (self->non_blocking_descriptor.index >= self->non_blocking_descriptor.appbuf.len) {\n            self->non_blocking_descriptor.copy_in_progress = false;\n            mp_sched_schedule(self->callback_for_non_blocking, MP_OBJ_FROM_PTR(self));\n        }\n    }\n}\n\n#endif \n\nMP_NOINLINE static void machine_i2s_init_helper(machine_i2s_obj_t *self, size_t n_pos_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_sck,      MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_OBJ,   {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_ws,       MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_OBJ,   {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_sd,       MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_OBJ,   {.u_obj = MP_OBJ_NULL} },\n        #if MICROPY_PY_MACHINE_I2S_MCK\n        { MP_QSTR_mck,      MP_ARG_KW_ONLY | MP_ARG_OBJ,   {.u_obj = mp_const_none} },\n        #endif\n        { MP_QSTR_mode,     MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_INT,   {.u_int = -1} },\n        { MP_QSTR_bits,     MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_INT,   {.u_int = -1} },\n        { MP_QSTR_format,   MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_INT,   {.u_int = -1} },\n        { MP_QSTR_rate,     MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_INT,   {.u_int = -1} },\n        { MP_QSTR_ibuf,     MP_ARG_KW_ONLY | MP_ARG_REQUIRED | MP_ARG_INT,   {.u_int = -1} },\n    };\n\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_pos_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    mp_machine_i2s_init_helper(self, args);\n}\n\nstatic void machine_i2s_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"I2S(id=%u,\\n\"\n        \"sck=\"MP_HAL_PIN_FMT \",\\n\"\n        \"ws=\"MP_HAL_PIN_FMT \",\\n\"\n        \"sd=\"MP_HAL_PIN_FMT \",\\n\"\n        #if MICROPY_PY_MACHINE_I2S_MCK\n        \"mck=\"MP_HAL_PIN_FMT \",\\n\"\n        #endif\n        \"mode=%u,\\n\"\n        \"bits=%u, format=%u,\\n\"\n        \"rate=%d, ibuf=%d)\",\n        self->i2s_id,\n        mp_hal_pin_name(self->sck),\n        mp_hal_pin_name(self->ws),\n        mp_hal_pin_name(self->sd),\n        #if MICROPY_PY_MACHINE_I2S_MCK\n        mp_hal_pin_name(self->mck),\n        #endif\n        self->mode,\n        self->bits, self->format,\n        self->rate, self->ibuf\n        );\n}\n\nstatic mp_obj_t machine_i2s_make_new(const mp_obj_type_t *type, size_t n_pos_args, size_t n_kw_args, const mp_obj_t *args) {\n    mp_arg_check_num(n_pos_args, n_kw_args, 1, MP_OBJ_FUN_ARGS_MAX, true);\n    mp_int_t i2s_id = mp_obj_get_int(args[0]);\n\n    machine_i2s_obj_t *self = mp_machine_i2s_make_new_instance(i2s_id);\n\n    mp_map_t kw_args;\n    mp_map_init_fixed_table(&kw_args, n_kw_args, args + n_pos_args);\n    machine_i2s_init_helper(self, n_pos_args - 1, args + 1, &kw_args);\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\n\nstatic mp_obj_t machine_i2s_init(size_t n_pos_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n    mp_machine_i2s_deinit(self);\n    machine_i2s_init_helper(self, n_pos_args - 1, pos_args + 1, kw_args);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(machine_i2s_init_obj, 1, machine_i2s_init);\n\n\nstatic mp_obj_t machine_i2s_deinit(mp_obj_t self_in) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_machine_i2s_deinit(self);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(machine_i2s_deinit_obj, machine_i2s_deinit);\n\n\nstatic mp_obj_t machine_i2s_irq(mp_obj_t self_in, mp_obj_t handler) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    if (handler != mp_const_none && !mp_obj_is_callable(handler)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid callback\"));\n    }\n\n    if (handler != mp_const_none) {\n        self->io_mode = NON_BLOCKING;\n    } else {\n        self->io_mode = BLOCKING;\n    }\n\n    self->callback_for_non_blocking = handler;\n\n    mp_machine_i2s_irq_update(self);\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(machine_i2s_irq_obj, machine_i2s_irq);\n\n\n\nstatic mp_obj_t machine_i2s_shift(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_buf, ARG_bits, ARG_shift};\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_buf,    MP_ARG_REQUIRED | MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_bits,   MP_ARG_REQUIRED | MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = -1} },\n        { MP_QSTR_shift,  MP_ARG_REQUIRED | MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = -1} },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[ARG_buf].u_obj, &bufinfo, MP_BUFFER_RW);\n\n    int16_t *buf_16 = bufinfo.buf;\n    int32_t *buf_32 = bufinfo.buf;\n\n    uint8_t bits = args[ARG_bits].u_int;\n    int8_t shift = args[ARG_shift].u_int;\n\n    uint32_t num_audio_samples;\n    switch (bits) {\n        case 16:\n            num_audio_samples = bufinfo.len / sizeof(uint16_t);\n            break;\n\n        case 32:\n            num_audio_samples = bufinfo.len / sizeof(uint32_t);\n            break;\n\n        default:\n            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid bits\"));\n            break;\n    }\n\n    for (uint32_t i = 0; i < num_audio_samples; i++) {\n        switch (bits) {\n            case 16:\n                if (shift >= 0) {\n                    buf_16[i] = buf_16[i] << shift;\n                } else {\n                    buf_16[i] = buf_16[i] >> abs(shift);\n                }\n                break;\n            case 32:\n                if (shift >= 0) {\n                    buf_32[i] = buf_32[i] << shift;\n                } else {\n                    buf_32[i] = buf_32[i] >> abs(shift);\n                }\n                break;\n        }\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(machine_i2s_shift_fun_obj, 0, machine_i2s_shift);\nstatic MP_DEFINE_CONST_STATICMETHOD_OBJ(machine_i2s_shift_obj, MP_ROM_PTR(&machine_i2s_shift_fun_obj));\n\nstatic const mp_rom_map_elem_t machine_i2s_locals_dict_table[] = {\n    \n    { MP_ROM_QSTR(MP_QSTR_init),            MP_ROM_PTR(&machine_i2s_init_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto),        MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write),           MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_deinit),          MP_ROM_PTR(&machine_i2s_deinit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_irq),             MP_ROM_PTR(&machine_i2s_irq_obj) },\n    #if MICROPY_PY_MACHINE_I2S_FINALISER\n    { MP_ROM_QSTR(MP_QSTR___del__),         MP_ROM_PTR(&machine_i2s_deinit_obj) },\n    #endif\n\n    \n    { MP_ROM_QSTR(MP_QSTR_shift),           MP_ROM_PTR(&machine_i2s_shift_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_RX),              MP_ROM_INT(MICROPY_PY_MACHINE_I2S_CONSTANT_RX) },\n    { MP_ROM_QSTR(MP_QSTR_TX),              MP_ROM_INT(MICROPY_PY_MACHINE_I2S_CONSTANT_TX) },\n    { MP_ROM_QSTR(MP_QSTR_STEREO),          MP_ROM_INT(STEREO) },\n    { MP_ROM_QSTR(MP_QSTR_MONO),            MP_ROM_INT(MONO) },\n};\nMP_DEFINE_CONST_DICT(machine_i2s_locals_dict, machine_i2s_locals_dict_table);\n\nstatic mp_uint_t machine_i2s_stream_read(mp_obj_t self_in, void *buf_in, mp_uint_t size, int *errcode) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->mode != MICROPY_PY_MACHINE_I2S_CONSTANT_RX) {\n        *errcode = MP_EPERM;\n        return MP_STREAM_ERROR;\n    }\n\n    uint8_t appbuf_sample_size_in_bytes = (self->bits / 8) * (self->format == STEREO ? 2: 1);\n    if (size % appbuf_sample_size_in_bytes != 0) {\n        *errcode = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n\n    if (size == 0) {\n        return 0;\n    }\n\n    if (self->io_mode == NON_BLOCKING) {\n        #if MICROPY_PY_MACHINE_I2S_RING_BUF\n        self->non_blocking_descriptor.appbuf.buf = (void *)buf_in;\n        self->non_blocking_descriptor.appbuf.len = size;\n        self->non_blocking_descriptor.index = 0;\n        self->non_blocking_descriptor.copy_in_progress = true;\n        #else\n        non_blocking_descriptor_t descriptor;\n        descriptor.appbuf.buf = (void *)buf_in;\n        descriptor.appbuf.len = size;\n        descriptor.callback = self->callback_for_non_blocking;\n        descriptor.direction = I2S_RX_TRANSFER;\n        \n        xQueueSend(self->non_blocking_mode_queue, &descriptor, 0);\n        #endif\n\n        return size;\n    } else { \n        mp_buffer_info_t appbuf;\n        appbuf.buf = (void *)buf_in;\n        appbuf.len = size;\n        #if MICROPY_PY_MACHINE_I2S_RING_BUF\n        uint32_t num_bytes_read = fill_appbuf_from_ringbuf(self, &appbuf);\n        #else\n        uint32_t num_bytes_read = fill_appbuf_from_dma(self, &appbuf);\n        #endif\n        return num_bytes_read;\n    }\n}\n\nstatic mp_uint_t machine_i2s_stream_write(mp_obj_t self_in, const void *buf_in, mp_uint_t size, int *errcode) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->mode != MICROPY_PY_MACHINE_I2S_CONSTANT_TX) {\n        *errcode = MP_EPERM;\n        return MP_STREAM_ERROR;\n    }\n\n    if (size == 0) {\n        return 0;\n    }\n\n    if (self->io_mode == NON_BLOCKING) {\n        #if MICROPY_PY_MACHINE_I2S_RING_BUF\n        self->non_blocking_descriptor.appbuf.buf = (void *)buf_in;\n        self->non_blocking_descriptor.appbuf.len = size;\n        self->non_blocking_descriptor.index = 0;\n        self->non_blocking_descriptor.copy_in_progress = true;\n        #else\n        non_blocking_descriptor_t descriptor;\n        descriptor.appbuf.buf = (void *)buf_in;\n        descriptor.appbuf.len = size;\n        descriptor.callback = self->callback_for_non_blocking;\n        descriptor.direction = I2S_TX_TRANSFER;\n        \n        xQueueSend(self->non_blocking_mode_queue, &descriptor, 0);\n        #endif\n\n        return size;\n    } else { \n        mp_buffer_info_t appbuf;\n        appbuf.buf = (void *)buf_in;\n        appbuf.len = size;\n        #if MICROPY_PY_MACHINE_I2S_RING_BUF\n        uint32_t num_bytes_written = copy_appbuf_to_ringbuf(self, &appbuf);\n        #else\n        uint32_t num_bytes_written = copy_appbuf_to_dma(self, &appbuf);\n        #endif\n\n        return num_bytes_written;\n    }\n}\n\nstatic mp_uint_t machine_i2s_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    machine_i2s_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_uint_t ret;\n    uintptr_t flags = arg;\n    self->io_mode = ASYNCIO; \n\n    if (request == MP_STREAM_POLL) {\n        ret = 0;\n\n        if (flags & MP_STREAM_POLL_RD) {\n            if (self->mode != MICROPY_PY_MACHINE_I2S_CONSTANT_RX) {\n                *errcode = MP_EPERM;\n                return MP_STREAM_ERROR;\n            }\n\n            #if MICROPY_PY_MACHINE_I2S_RING_BUF\n            if (!ringbuf_is_empty(&self->ring_buffer)) {\n                ret |= MP_STREAM_POLL_RD;\n            }\n            #else\n            if (self->dma_buffer_status == DMA_MEMORY_NOT_EMPTY) {\n                ret |= MP_STREAM_POLL_RD;\n            }\n            #endif\n        }\n\n        if (flags & MP_STREAM_POLL_WR) {\n            if (self->mode != MICROPY_PY_MACHINE_I2S_CONSTANT_TX) {\n                *errcode = MP_EPERM;\n                return MP_STREAM_ERROR;\n            }\n\n            #if MICROPY_PY_MACHINE_I2S_RING_BUF\n            if (!ringbuf_is_full(&self->ring_buffer)) {\n                ret |= MP_STREAM_POLL_WR;\n            }\n            #else\n            if (self->dma_buffer_status == DMA_MEMORY_NOT_FULL) {\n                ret |= MP_STREAM_POLL_WR;\n            }\n            #endif\n        }\n    } else {\n        *errcode = MP_EINVAL;\n        ret = MP_STREAM_ERROR;\n    }\n\n    return ret;\n}\n\nstatic const mp_stream_p_t i2s_stream_p = {\n    .read = machine_i2s_stream_read,\n    .write = machine_i2s_stream_write,\n    .ioctl = machine_i2s_ioctl,\n    .is_text = false,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    machine_i2s_type,\n    MP_QSTR_I2S,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    make_new, machine_i2s_make_new,\n    print, machine_i2s_print,\n    protocol, &i2s_stream_p,\n    locals_dict, &machine_i2s_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}