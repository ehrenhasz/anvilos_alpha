{
  "module_name": "modjson.c",
  "hash_id": "6a2dc4bf5f980dd9adf64703143c63bbdb57977276f23ace53b90207124ec0cf",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modjson.c",
  "human_readable_source": " \n\n#include <stdio.h>\n\n#include \"py/objlist.h\"\n#include \"py/objstringio.h\"\n#include \"py/parsenum.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n\n#if MICROPY_PY_JSON\n\n#if MICROPY_PY_JSON_SEPARATORS\n\nenum {\n    DUMP_MODE_TO_STRING = 1,\n    DUMP_MODE_TO_STREAM = 2,\n};\n\nstatic mp_obj_t mod_json_dump_helper(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args, unsigned int mode) {\n    enum { ARG_separators };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_separators, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n    };\n\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - mode, pos_args + mode, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    mp_print_ext_t print_ext;\n\n    if (args[ARG_separators].u_obj == mp_const_none) {\n        print_ext.item_separator = \", \";\n        print_ext.key_separator = \": \";\n    } else {\n        mp_obj_t *items;\n        mp_obj_get_array_fixed_n(args[ARG_separators].u_obj, 2, &items);\n        print_ext.item_separator = mp_obj_str_get_str(items[0]);\n        print_ext.key_separator = mp_obj_str_get_str(items[1]);\n    }\n\n    if (mode == DUMP_MODE_TO_STRING) {\n        \n        vstr_t vstr;\n        vstr_init_print(&vstr, 8, &print_ext.base);\n        mp_obj_print_helper(&print_ext.base, pos_args[0], PRINT_JSON);\n        return mp_obj_new_str_from_utf8_vstr(&vstr);\n    } else {\n        \n        print_ext.base.data = MP_OBJ_TO_PTR(pos_args[1]);\n        print_ext.base.print_strn = mp_stream_write_adaptor;\n        mp_get_stream_raise(pos_args[1], MP_STREAM_OP_WRITE);\n        mp_obj_print_helper(&print_ext.base, pos_args[0], PRINT_JSON);\n        return mp_const_none;\n    }\n}\n\nstatic mp_obj_t mod_json_dump(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    return mod_json_dump_helper(n_args, pos_args, kw_args, DUMP_MODE_TO_STREAM);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(mod_json_dump_obj, 2, mod_json_dump);\n\nstatic mp_obj_t mod_json_dumps(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    return mod_json_dump_helper(n_args, pos_args, kw_args, DUMP_MODE_TO_STRING);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(mod_json_dumps_obj, 1, mod_json_dumps);\n\n#else\n\nstatic mp_obj_t mod_json_dump(mp_obj_t obj, mp_obj_t stream) {\n    mp_get_stream_raise(stream, MP_STREAM_OP_WRITE);\n    mp_print_t print = {MP_OBJ_TO_PTR(stream), mp_stream_write_adaptor};\n    mp_obj_print_helper(&print, obj, PRINT_JSON);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mod_json_dump_obj, mod_json_dump);\n\nstatic mp_obj_t mod_json_dumps(mp_obj_t obj) {\n    vstr_t vstr;\n    mp_print_t print;\n    vstr_init_print(&vstr, 8, &print);\n    mp_obj_print_helper(&print, obj, PRINT_JSON);\n    return mp_obj_new_str_from_utf8_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_json_dumps_obj, mod_json_dumps);\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntypedef struct _json_stream_t {\n    mp_obj_t stream_obj;\n    mp_uint_t (*read)(mp_obj_t obj, void *buf, mp_uint_t size, int *errcode);\n    int errcode;\n    byte cur;\n} json_stream_t;\n\n#define S_EOF (0) \n#define S_END(s) ((s).cur == S_EOF)\n#define S_CUR(s) ((s).cur)\n#define S_NEXT(s) (json_stream_next(&(s)))\n\nstatic byte json_stream_next(json_stream_t *s) {\n    mp_uint_t ret = s->read(s->stream_obj, &s->cur, 1, &s->errcode);\n    if (s->errcode != 0) {\n        mp_raise_OSError(s->errcode);\n    }\n    if (ret == 0) {\n        s->cur = S_EOF;\n    }\n    return s->cur;\n}\n\nstatic mp_obj_t mod_json_load(mp_obj_t stream_obj) {\n    const mp_stream_p_t *stream_p = mp_get_stream_raise(stream_obj, MP_STREAM_OP_READ);\n    json_stream_t s = {stream_obj, stream_p->read, 0, 0};\n    vstr_t vstr;\n    vstr_init(&vstr, 8);\n    mp_obj_list_t stack; \n    stack.len = 0;\n    stack.items = NULL;\n    mp_obj_t stack_top = MP_OBJ_NULL;\n    const mp_obj_type_t *stack_top_type = NULL;\n    mp_obj_t stack_key = MP_OBJ_NULL;\n    S_NEXT(s);\n    for (;;) {\n    cont:\n        if (S_END(s)) {\n            break;\n        }\n        mp_obj_t next = MP_OBJ_NULL;\n        bool enter = false;\n        byte cur = S_CUR(s);\n        S_NEXT(s);\n        switch (cur) {\n            case ',':\n            case ':':\n            case ' ':\n            case '\\t':\n            case '\\n':\n            case '\\r':\n                goto cont;\n            case 'n':\n                if (S_CUR(s) == 'u' && S_NEXT(s) == 'l' && S_NEXT(s) == 'l') {\n                    S_NEXT(s);\n                    next = mp_const_none;\n                } else {\n                    goto fail;\n                }\n                break;\n            case 'f':\n                if (S_CUR(s) == 'a' && S_NEXT(s) == 'l' && S_NEXT(s) == 's' && S_NEXT(s) == 'e') {\n                    S_NEXT(s);\n                    next = mp_const_false;\n                } else {\n                    goto fail;\n                }\n                break;\n            case 't':\n                if (S_CUR(s) == 'r' && S_NEXT(s) == 'u' && S_NEXT(s) == 'e') {\n                    S_NEXT(s);\n                    next = mp_const_true;\n                } else {\n                    goto fail;\n                }\n                break;\n            case '\"':\n                vstr_reset(&vstr);\n                for (; !S_END(s) && S_CUR(s) != '\"';) {\n                    byte c = S_CUR(s);\n                    if (c == '\\\\') {\n                        c = S_NEXT(s);\n                        switch (c) {\n                            case 'b':\n                                c = 0x08;\n                                break;\n                            case 'f':\n                                c = 0x0c;\n                                break;\n                            case 'n':\n                                c = 0x0a;\n                                break;\n                            case 'r':\n                                c = 0x0d;\n                                break;\n                            case 't':\n                                c = 0x09;\n                                break;\n                            case 'u': {\n                                mp_uint_t num = 0;\n                                for (int i = 0; i < 4; i++) {\n                                    c = (S_NEXT(s) | 0x20) - '0';\n                                    if (c > 9) {\n                                        c -= ('a' - ('9' + 1));\n                                    }\n                                    num = (num << 4) | c;\n                                }\n                                vstr_add_char(&vstr, num);\n                                goto str_cont;\n                            }\n                        }\n                    }\n                    vstr_add_byte(&vstr, c);\n                str_cont:\n                    S_NEXT(s);\n                }\n                if (S_END(s)) {\n                    goto fail;\n                }\n                S_NEXT(s);\n                next = mp_obj_new_str(vstr.buf, vstr.len);\n                break;\n            case '-':\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9': {\n                bool flt = false;\n                vstr_reset(&vstr);\n                for (;;) {\n                    vstr_add_byte(&vstr, cur);\n                    cur = S_CUR(s);\n                    if (cur == '.' || cur == 'E' || cur == 'e') {\n                        flt = true;\n                    } else if (cur == '+' || cur == '-' || unichar_isdigit(cur)) {\n                        \n                    } else {\n                        break;\n                    }\n                    S_NEXT(s);\n                }\n                if (flt) {\n                    next = mp_parse_num_float(vstr.buf, vstr.len, false, NULL);\n                } else {\n                    next = mp_parse_num_integer(vstr.buf, vstr.len, 10, NULL);\n                }\n                break;\n            }\n            case '[':\n                next = mp_obj_new_list(0, NULL);\n                enter = true;\n                break;\n            case '{':\n                next = mp_obj_new_dict(0);\n                enter = true;\n                break;\n            case '}':\n            case ']': {\n                if (stack_top == MP_OBJ_NULL) {\n                    \n                    goto fail;\n                }\n                if (stack.len == 0) {\n                    \n                    goto success;\n                }\n                stack.len -= 1;\n                stack_top = stack.items[stack.len];\n                stack_top_type = mp_obj_get_type(stack_top);\n                goto cont;\n            }\n            default:\n                goto fail;\n        }\n        if (stack_top == MP_OBJ_NULL) {\n            stack_top = next;\n            stack_top_type = mp_obj_get_type(stack_top);\n            if (!enter) {\n                \n                goto success;\n            }\n        } else {\n            \n            if (stack_top_type == &mp_type_list) {\n                mp_obj_list_append(stack_top, next);\n            } else {\n                if (stack_key == MP_OBJ_NULL) {\n                    stack_key = next;\n                    if (enter) {\n                        goto fail;\n                    }\n                } else {\n                    mp_obj_dict_store(stack_top, stack_key, next);\n                    stack_key = MP_OBJ_NULL;\n                }\n            }\n            if (enter) {\n                if (stack.items == NULL) {\n                    mp_obj_list_init(&stack, 1);\n                    stack.items[0] = stack_top;\n                } else {\n                    mp_obj_list_append(MP_OBJ_FROM_PTR(&stack), stack_top);\n                }\n                stack_top = next;\n                stack_top_type = mp_obj_get_type(stack_top);\n            }\n        }\n    }\nsuccess:\n    \n    while (unichar_isspace(S_CUR(s))) {\n        S_NEXT(s);\n    }\n    if (!S_END(s)) {\n        \n        goto fail;\n    }\n    if (stack_top == MP_OBJ_NULL || stack.len != 0) {\n        \n        goto fail;\n    }\n    vstr_clear(&vstr);\n    return stack_top;\n\nfail:\n    mp_raise_ValueError(MP_ERROR_TEXT(\"syntax error in JSON\"));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_json_load_obj, mod_json_load);\n\nstatic mp_obj_t mod_json_loads(mp_obj_t obj) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(obj, &bufinfo, MP_BUFFER_READ);\n    vstr_t vstr = {bufinfo.len, bufinfo.len, (char *)bufinfo.buf, true};\n    mp_obj_stringio_t sio = {{&mp_type_stringio}, &vstr, 0, MP_OBJ_NULL};\n    return mod_json_load(MP_OBJ_FROM_PTR(&sio));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_json_loads_obj, mod_json_loads);\n\nstatic const mp_rom_map_elem_t mp_module_json_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_json) },\n    { MP_ROM_QSTR(MP_QSTR_dump), MP_ROM_PTR(&mod_json_dump_obj) },\n    { MP_ROM_QSTR(MP_QSTR_dumps), MP_ROM_PTR(&mod_json_dumps_obj) },\n    { MP_ROM_QSTR(MP_QSTR_load), MP_ROM_PTR(&mod_json_load_obj) },\n    { MP_ROM_QSTR(MP_QSTR_loads), MP_ROM_PTR(&mod_json_loads_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_json_globals, mp_module_json_globals_table);\n\nconst mp_obj_module_t mp_module_json = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_json_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_json, mp_module_json);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}