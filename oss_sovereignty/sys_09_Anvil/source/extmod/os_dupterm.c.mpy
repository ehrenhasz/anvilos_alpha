{
  "module_name": "os_dupterm.c",
  "hash_id": "0b7e94a049f30a78bcdcb23684844dc27e6c73e55c09782f66e8213ec8fab0e8",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/os_dupterm.c",
  "human_readable_source": " \n\n#include <string.h>\n#include \"py/mpconfig.h\"\n\n#include \"py/runtime.h\"\n#include \"py/objtuple.h\"\n#include \"py/objarray.h\"\n#include \"py/stream.h\"\n#include \"extmod/misc.h\"\n\n#if MICROPY_PY_OS_DUPTERM\n\n#include \"shared/runtime/interrupt_char.h\"\n\nvoid mp_os_deactivate(size_t dupterm_idx, const char *msg, mp_obj_t exc) {\n    mp_obj_t term = MP_STATE_VM(dupterm_objs[dupterm_idx]);\n    MP_STATE_VM(dupterm_objs[dupterm_idx]) = MP_OBJ_NULL;\n    mp_printf(&mp_plat_print, msg);\n    if (exc != MP_OBJ_NULL) {\n        mp_obj_print_exception(&mp_plat_print, exc);\n    }\n    if (term == MP_OBJ_NULL) {\n        \n        return;\n    }\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_stream_close(term);\n        nlr_pop();\n    } else {\n        \n    }\n}\n\nuintptr_t mp_os_dupterm_poll(uintptr_t poll_flags) {\n    uintptr_t poll_flags_out = 0;\n\n    for (size_t idx = 0; idx < MICROPY_PY_OS_DUPTERM; ++idx) {\n        mp_obj_t s = MP_STATE_VM(dupterm_objs[idx]);\n        if (s == MP_OBJ_NULL) {\n            continue;\n        }\n\n        int errcode = 0;\n        mp_uint_t ret = 0;\n        const mp_stream_p_t *stream_p = mp_get_stream(s);\n        #if MICROPY_PY_OS_DUPTERM_BUILTIN_STREAM\n        if (mp_os_dupterm_is_builtin_stream(s)) {\n            ret = stream_p->ioctl(s, MP_STREAM_POLL, poll_flags, &errcode);\n        } else\n        #endif\n        {\n            nlr_buf_t nlr;\n            if (nlr_push(&nlr) == 0) {\n                ret = stream_p->ioctl(s, MP_STREAM_POLL, poll_flags, &errcode);\n                nlr_pop();\n            } else {\n                \n            }\n        }\n\n        if (ret != MP_STREAM_ERROR) {\n            poll_flags_out |= ret;\n            if (poll_flags_out == poll_flags) {\n                \n                break;\n            }\n        }\n    }\n\n    return poll_flags_out;\n}\n\nint mp_os_dupterm_rx_chr(void) {\n    #if MICROPY_PY_OS_DUPTERM_NOTIFY\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    mp_sched_lock();\n    #endif\n\n    int ret = -1; \n    for (size_t idx = 0; idx < MICROPY_PY_OS_DUPTERM; ++idx) {\n        if (MP_STATE_VM(dupterm_objs[idx]) == MP_OBJ_NULL) {\n            continue;\n        }\n\n        #if MICROPY_PY_OS_DUPTERM_BUILTIN_STREAM\n        if (mp_os_dupterm_is_builtin_stream(MP_STATE_VM(dupterm_objs[idx]))) {\n            byte buf[1];\n            int errcode = 0;\n            const mp_stream_p_t *stream_p = mp_get_stream(MP_STATE_VM(dupterm_objs[idx]));\n            mp_uint_t out_sz = stream_p->read(MP_STATE_VM(dupterm_objs[idx]), buf, 1, &errcode);\n            if (errcode == 0 && out_sz != 0) {\n                ret = buf[0];\n                break;\n            } else {\n                continue;\n            }\n        }\n        #endif\n\n        nlr_buf_t nlr;\n        if (nlr_push(&nlr) == 0) {\n            byte buf[1];\n            int errcode;\n            const mp_stream_p_t *stream_p = mp_get_stream(MP_STATE_VM(dupterm_objs[idx]));\n            mp_uint_t out_sz = stream_p->read(MP_STATE_VM(dupterm_objs[idx]), buf, 1, &errcode);\n            if (out_sz == 0) {\n                nlr_pop();\n                mp_os_deactivate(idx, \"dupterm: EOF received, deactivating\\n\", MP_OBJ_NULL);\n            } else if (out_sz == MP_STREAM_ERROR) {\n                \n                if (mp_is_nonblocking_error(errcode)) {\n                    nlr_pop();\n                } else {\n                    mp_raise_OSError(errcode);\n                }\n            } else {\n                \n                nlr_pop();\n                ret = buf[0];\n                if (ret == mp_interrupt_char) {\n                    \n                    mp_sched_keyboard_interrupt();\n                    ret = -2;\n                }\n                break;\n            }\n        } else {\n            mp_os_deactivate(idx, \"dupterm: Exception in read() method, deactivating: \", MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n    }\n\n    #if MICROPY_PY_OS_DUPTERM_NOTIFY\n    mp_sched_unlock();\n    #endif\n\n    return ret;\n}\n\nint mp_os_dupterm_tx_strn(const char *str, size_t len) {\n    \n    int ret = len;\n    bool did_write = false;\n    for (size_t idx = 0; idx < MICROPY_PY_OS_DUPTERM; ++idx) {\n        if (MP_STATE_VM(dupterm_objs[idx]) == MP_OBJ_NULL) {\n            continue;\n        }\n        did_write = true;\n\n        #if MICROPY_PY_OS_DUPTERM_BUILTIN_STREAM\n        if (mp_os_dupterm_is_builtin_stream(MP_STATE_VM(dupterm_objs[idx]))) {\n            int errcode = 0;\n            const mp_stream_p_t *stream_p = mp_get_stream(MP_STATE_VM(dupterm_objs[idx]));\n            mp_uint_t written = stream_p->write(MP_STATE_VM(dupterm_objs[idx]), str, len, &errcode);\n            int write_res = MAX(0, written);\n            ret = MIN(write_res, ret);\n            continue;\n        }\n        #endif\n\n        nlr_buf_t nlr;\n        if (nlr_push(&nlr) == 0) {\n            mp_obj_t written = mp_stream_write(MP_STATE_VM(dupterm_objs[idx]), str, len, MP_STREAM_RW_WRITE);\n            if (written == mp_const_none) {\n                ret = 0;\n            } else if (mp_obj_is_small_int(written)) {\n                int written_int = MAX(0, MP_OBJ_SMALL_INT_VALUE(written));\n                ret = MIN(written_int, ret);\n            }\n            nlr_pop();\n        } else {\n            mp_os_deactivate(idx, \"dupterm: Exception in write() method, deactivating: \", MP_OBJ_FROM_PTR(nlr.ret_val));\n            ret = 0;\n        }\n    }\n    return did_write ? ret : -1;\n}\n\nstatic mp_obj_t mp_os_dupterm(size_t n_args, const mp_obj_t *args) {\n    mp_int_t idx = 0;\n    if (n_args == 2) {\n        idx = mp_obj_get_int(args[1]);\n    }\n\n    if (idx < 0 || idx >= MICROPY_PY_OS_DUPTERM) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid dupterm index\"));\n    }\n\n    mp_obj_t previous_obj = MP_STATE_VM(dupterm_objs[idx]);\n    if (previous_obj == MP_OBJ_NULL) {\n        previous_obj = mp_const_none;\n    }\n    if (args[0] == mp_const_none) {\n        MP_STATE_VM(dupterm_objs[idx]) = MP_OBJ_NULL;\n    } else {\n        mp_get_stream_raise(args[0], MP_STREAM_OP_READ | MP_STREAM_OP_WRITE | MP_STREAM_OP_IOCTL);\n        MP_STATE_VM(dupterm_objs[idx]) = args[0];\n    }\n\n    #if MICROPY_PY_OS_DUPTERM_STREAM_DETACHED_ATTACHED\n    mp_os_dupterm_stream_detached_attached(previous_obj, args[0]);\n    #endif\n\n    return previous_obj;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_os_dupterm_obj, 1, 2, mp_os_dupterm);\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t dupterm_objs[MICROPY_PY_OS_DUPTERM]);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}