{
  "module_name": "machine_signal.c",
  "hash_id": "ca5dc8e4f49c985a9d4b7e0e676cec60ca58dd2e095a50a1ca8ec98a82b5ab20",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_signal.c",
  "human_readable_source": " \n\n#include <string.h>\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_MACHINE_SIGNAL\n\n#include \"extmod/modmachine.h\"\n#include \"extmod/virtpin.h\"\n\n\n\ntypedef struct _machine_signal_t {\n    mp_obj_base_t base;\n    mp_obj_t pin;\n    bool invert;\n} machine_signal_t;\n\nstatic mp_obj_t signal_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_t pin;\n    bool invert = false;\n\n    #if defined(MICROPY_PY_MACHINE_PIN_MAKE_NEW)\n    mp_pin_p_t *pin_p = NULL;\n\n    if (n_args > 0 && mp_obj_is_obj(args[0])) {\n        mp_obj_base_t *pin_base = (mp_obj_base_t *)MP_OBJ_TO_PTR(args[0]);\n        pin_p = (mp_pin_p_t *)MP_OBJ_TYPE_GET_SLOT_OR_NULL(pin_base->type, protocol);\n    }\n\n    if (pin_p == NULL) {\n        \n        \n        \n        mp_obj_t *pin_args = mp_local_alloc((n_args + n_kw * 2) * sizeof(mp_obj_t));\n        memcpy(pin_args, args, n_args * sizeof(mp_obj_t));\n        const mp_obj_t *src = args + n_args;\n        mp_obj_t *dst = pin_args + n_args;\n        mp_obj_t *sig_value = NULL;\n        for (size_t cnt = n_kw; cnt; cnt--) {\n            if (*src == MP_OBJ_NEW_QSTR(MP_QSTR_invert)) {\n                invert = mp_obj_is_true(src[1]);\n                n_kw--;\n            } else {\n                *dst++ = *src;\n                *dst++ = src[1];\n            }\n            if (*src == MP_OBJ_NEW_QSTR(MP_QSTR_value)) {\n                \n                \n                \n                sig_value = dst - 1;\n            }\n            src += 2;\n        }\n\n        if (invert && sig_value != NULL) {\n            *sig_value = mp_obj_is_true(*sig_value) ? MP_OBJ_NEW_SMALL_INT(0) : MP_OBJ_NEW_SMALL_INT(1);\n        }\n\n        \n        \n        \n        pin = MICROPY_PY_MACHINE_PIN_MAKE_NEW(NULL, n_args, n_kw, pin_args);\n\n        mp_local_free(pin_args);\n    } else\n    #endif\n    \n    {\n        if (n_args == 1) {\n            pin = args[0];\n            if (n_kw == 0) {\n            } else if (n_kw == 1 && args[1] == MP_OBJ_NEW_QSTR(MP_QSTR_invert)) {\n                invert = mp_obj_is_true(args[2]);\n            } else {\n                goto error;\n            }\n        } else {\n        error:\n            mp_raise_TypeError(NULL);\n        }\n    }\n\n    machine_signal_t *o = mp_obj_malloc(machine_signal_t, type);\n    o->pin = pin;\n    o->invert = invert;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_uint_t signal_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    (void)errcode;\n    machine_signal_t *self = MP_OBJ_TO_PTR(self_in);\n\n    switch (request) {\n        case MP_PIN_READ: {\n            return mp_virtual_pin_read(self->pin) ^ self->invert;\n        }\n        case MP_PIN_WRITE: {\n            mp_virtual_pin_write(self->pin, arg ^ self->invert);\n            return 0;\n        }\n    }\n    return -1;\n}\n\n\nstatic mp_obj_t signal_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n    if (n_args == 0) {\n        \n        return MP_OBJ_NEW_SMALL_INT(mp_virtual_pin_read(self_in));\n    } else {\n        \n        mp_virtual_pin_write(self_in, mp_obj_is_true(args[0]));\n        return mp_const_none;\n    }\n}\n\nstatic mp_obj_t signal_value(size_t n_args, const mp_obj_t *args) {\n    return signal_call(args[0], n_args - 1, 0, args + 1);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(signal_value_obj, 1, 2, signal_value);\n\nstatic mp_obj_t signal_on(mp_obj_t self_in) {\n    mp_virtual_pin_write(self_in, 1);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(signal_on_obj, signal_on);\n\nstatic mp_obj_t signal_off(mp_obj_t self_in) {\n    mp_virtual_pin_write(self_in, 0);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(signal_off_obj, signal_off);\n\nstatic const mp_rom_map_elem_t signal_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_value), MP_ROM_PTR(&signal_value_obj) },\n    { MP_ROM_QSTR(MP_QSTR_on), MP_ROM_PTR(&signal_on_obj) },\n    { MP_ROM_QSTR(MP_QSTR_off), MP_ROM_PTR(&signal_off_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(signal_locals_dict, signal_locals_dict_table);\n\nstatic const mp_pin_p_t signal_pin_p = {\n    .ioctl = signal_ioctl,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    machine_signal_type,\n    MP_QSTR_Signal,\n    MP_TYPE_FLAG_NONE,\n    make_new, signal_make_new,\n    call, signal_call,\n    protocol, &signal_pin_p,\n    locals_dict, &signal_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}