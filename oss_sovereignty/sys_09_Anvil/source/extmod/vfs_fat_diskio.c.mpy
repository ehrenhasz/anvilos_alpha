{
  "module_name": "vfs_fat_diskio.c",
  "hash_id": "205ec7b2e373354d5de9d26e71cbb3b9082ec90ccd26c8b08bc0bc23f6ee2170",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_fat_diskio.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n#if MICROPY_VFS && MICROPY_VFS_FAT\n\n#include <stdint.h>\n#include <stdio.h>\n\n#include \"py/mphal.h\"\n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n#include \"py/objarray.h\"\n#include \"py/mperrno.h\"\n#include \"lib/oofatfs/ff.h\"\n#include \"lib/oofatfs/diskio.h\"\n#include \"extmod/vfs_fat.h\"\n\ntypedef void *bdev_t;\nstatic fs_user_mount_t *disk_get_device(void *bdev) {\n    return (fs_user_mount_t *)bdev;\n}\n\n \n \n \n\nDRESULT disk_read(\n    bdev_t pdrv,       \n    BYTE *buff,         \n    DWORD sector,     \n    UINT count         \n    ) {\n    fs_user_mount_t *vfs = disk_get_device(pdrv);\n    if (vfs == NULL) {\n        return RES_PARERR;\n    }\n\n    int ret = mp_vfs_blockdev_read(&vfs->blockdev, sector, count, buff);\n\n    return ret == 0 ? RES_OK : RES_ERROR;\n}\n\n \n \n \n\nDRESULT disk_write(\n    bdev_t pdrv,           \n    const BYTE *buff,     \n    DWORD sector,         \n    UINT count             \n    ) {\n    fs_user_mount_t *vfs = disk_get_device(pdrv);\n    if (vfs == NULL) {\n        return RES_PARERR;\n    }\n\n    int ret = mp_vfs_blockdev_write(&vfs->blockdev, sector, count, buff);\n\n    if (ret == -MP_EROFS) {\n        \n        return RES_WRPRT;\n    }\n\n    return ret == 0 ? RES_OK : RES_ERROR;\n}\n\n\n \n \n \n\nDRESULT disk_ioctl(\n    bdev_t pdrv,       \n    BYTE cmd,         \n    void *buff         \n    ) {\n    fs_user_mount_t *vfs = disk_get_device(pdrv);\n    if (vfs == NULL) {\n        return RES_PARERR;\n    }\n\n    \n    static const uint8_t op_map[8] = {\n        [CTRL_SYNC] = MP_BLOCKDEV_IOCTL_SYNC,\n        [GET_SECTOR_COUNT] = MP_BLOCKDEV_IOCTL_BLOCK_COUNT,\n        [GET_SECTOR_SIZE] = MP_BLOCKDEV_IOCTL_BLOCK_SIZE,\n        [IOCTL_INIT] = MP_BLOCKDEV_IOCTL_INIT,\n    };\n    uint8_t bp_op = op_map[cmd & 7];\n    mp_obj_t ret = mp_const_none;\n    if (bp_op != 0) {\n        ret = mp_vfs_blockdev_ioctl(&vfs->blockdev, bp_op, 0);\n    }\n\n    \n    switch (cmd) {\n        case CTRL_SYNC:\n            return RES_OK;\n\n        case GET_SECTOR_COUNT: {\n            *((DWORD *)buff) = mp_obj_get_int(ret);\n            return RES_OK;\n        }\n\n        case GET_SECTOR_SIZE: {\n            if (ret == mp_const_none) {\n                \n                *((WORD *)buff) = 512;\n            } else {\n                *((WORD *)buff) = mp_obj_get_int(ret);\n            }\n            \n            vfs->blockdev.block_size = *((WORD *)buff);\n            return RES_OK;\n        }\n\n        case GET_BLOCK_SIZE:\n            *((DWORD *)buff) = 1; \n            return RES_OK;\n\n        case IOCTL_INIT:\n        case IOCTL_STATUS: {\n            DSTATUS stat;\n            if (ret != mp_const_none && MP_OBJ_SMALL_INT_VALUE(ret) != 0) {\n                \n                stat = STA_NOINIT;\n            } else if (vfs->blockdev.writeblocks[0] == MP_OBJ_NULL) {\n                stat = STA_PROTECT;\n            } else {\n                stat = 0;\n            }\n            *((DSTATUS *)buff) = stat;\n            return RES_OK;\n        }\n\n        default:\n            return RES_PARERR;\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}