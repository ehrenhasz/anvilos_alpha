{
  "module_name": "nimble_npl_os.c",
  "hash_id": "c9ad5095ce8cc1a70447ea69e541310d71c5fa22c696e5e5a2b1236720762158",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/nimble/nimble/nimble_npl_os.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include \"py/mphal.h\"\n#include \"py/runtime.h\"\n#include \"nimble/ble.h\"\n#include \"nimble/nimble_npl.h\"\n#include \"extmod/nimble/hal/hal_uart.h\"\n\n#include \"extmod/modbluetooth.h\"\n#include \"extmod/nimble/modbluetooth_nimble.h\"\n\n#define DEBUG_OS_printf(...) \n#define DEBUG_MALLOC_printf(...) \n#define DEBUG_EVENT_printf(...) \n#define DEBUG_MUTEX_printf(...) \n#define DEBUG_SEM_printf(...) \n#define DEBUG_CALLOUT_printf(...) \n#define DEBUG_TIME_printf(...) \n#define DEBUG_CRIT_printf(...) \n\nbool ble_npl_os_started(void) {\n    DEBUG_OS_printf(\"ble_npl_os_started\\n\");\n    return true;\n}\n\nvoid *ble_npl_get_current_task_id(void) {\n    DEBUG_OS_printf(\"ble_npl_get_current_task_id\\n\");\n    return NULL;\n}\n\n \n\n\n\n\n\ntypedef struct _mp_bluetooth_nimble_malloc_t {\n    struct _mp_bluetooth_nimble_malloc_t *prev;\n    struct _mp_bluetooth_nimble_malloc_t *next;\n    size_t size;\n    uint8_t data[];\n} mp_bluetooth_nimble_malloc_t;\n\n\nstatic void *m_malloc_bluetooth(size_t size) {\n    size += sizeof(mp_bluetooth_nimble_malloc_t);\n    mp_bluetooth_nimble_malloc_t *alloc = m_malloc0(size);\n    alloc->size = size;\n    alloc->next = MP_STATE_PORT(bluetooth_nimble_memory);\n    if (alloc->next) {\n        alloc->next->prev = alloc;\n    }\n    MP_STATE_PORT(bluetooth_nimble_memory) = alloc;\n    return alloc->data;\n}\n\nstatic mp_bluetooth_nimble_malloc_t* get_nimble_malloc(void *ptr) {\n    return (mp_bluetooth_nimble_malloc_t*)((uintptr_t)ptr - sizeof(mp_bluetooth_nimble_malloc_t));\n}\n\nstatic void m_free_bluetooth(void *ptr) {\n    mp_bluetooth_nimble_malloc_t *alloc = get_nimble_malloc(ptr);\n    if (alloc->next) {\n        alloc->next->prev = alloc->prev;\n    }\n    if (alloc->prev) {\n        alloc->prev->next = alloc->next;\n    } else {\n        MP_STATE_PORT(bluetooth_nimble_memory) = NULL;\n    }\n    m_free(alloc\n    #if MICROPY_MALLOC_USES_ALLOCATED_SIZE\n           , alloc->size\n    #endif\n    );\n}\n\n\n\nstatic bool is_valid_nimble_malloc(void *ptr) {\n    DEBUG_MALLOC_printf(\"NIMBLE is_valid_nimble_malloc(%p)\\n\", ptr);\n    mp_bluetooth_nimble_malloc_t *alloc = MP_STATE_PORT(bluetooth_nimble_memory);\n    while (alloc) {\n        DEBUG_MALLOC_printf(\"NIMBLE   checking: %p\\n\", alloc->data);\n        if (alloc->data == ptr) {\n            return true;\n        }\n        alloc = alloc->next;\n    }\n    return false;\n}\n\nvoid *nimble_malloc(size_t size) {\n    DEBUG_MALLOC_printf(\"NIMBLE malloc(%u)\\n\", (uint)size);\n    void* ptr = m_malloc_bluetooth(size);\n    DEBUG_MALLOC_printf(\"  --> %p\\n\", ptr);\n    return ptr;\n}\n\n\nvoid nimble_free(void *ptr) {\n    DEBUG_MALLOC_printf(\"NIMBLE free(%p)\\n\", ptr);\n\n    if (ptr) {\n        \n        \n        \n        \n        \n        \n        if (is_valid_nimble_malloc(ptr)) {\n            m_free_bluetooth(ptr);\n        }\n    }\n}\n\n\nvoid *nimble_realloc(void *ptr, size_t new_size) {\n    DEBUG_MALLOC_printf(\"NIMBLE realloc(%p, %u)\\n\", ptr, (uint)new_size);\n\n    if (!ptr) {\n        return nimble_malloc(new_size);\n    }\n\n    assert(is_valid_nimble_malloc(ptr));\n\n    \n    mp_bluetooth_nimble_malloc_t *alloc = get_nimble_malloc(ptr);\n    size_t old_size = alloc->size - sizeof(mp_bluetooth_nimble_malloc_t);\n    if (old_size >= new_size) {\n        return ptr;\n    }\n\n    \n    void *ptr2 = m_malloc_bluetooth(new_size);\n\n    \n    memcpy(ptr2, ptr, old_size);\n    m_free_bluetooth(ptr);\n\n    DEBUG_MALLOC_printf(\"  --> %p\\n\", ptr2);\n\n    return ptr2;\n}\n\n\nint nimble_sprintf(char *str, const char *fmt, ...) {\n    str[0] = 0;\n    return 0;\n}\n\n \n\n\nstruct ble_npl_eventq *global_eventq = NULL;\n\n\nvoid mp_bluetooth_nimble_os_eventq_run_all(void) {\n    if (mp_bluetooth_nimble_ble_state == MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF) {\n        return;\n    }\n\n    \n    while (true) {\n        struct ble_npl_event *ev = NULL;\n\n        os_sr_t sr;\n        OS_ENTER_CRITICAL(sr);\n        \n        for (struct ble_npl_eventq *evq = global_eventq; evq != NULL; evq = evq->nextq) {\n            ev = evq->head;\n            if (ev) {\n                \n                evq->head = ev->next;\n                if (ev->next) {\n                    ev->next->prev = NULL;\n                    ev->next = NULL;\n                }\n                ev->prev = NULL;\n\n                ev->pending = false;\n\n                \n                break;\n            }\n        }\n        OS_EXIT_CRITICAL(sr);\n\n        if (!ev) {\n            break;\n        }\n\n        \n        DEBUG_EVENT_printf(\"event_run(%p)\\n\", ev);\n        ev->fn(ev);\n        DEBUG_EVENT_printf(\"event_run(%p) done\\n\", ev);\n\n        if (ev->pending) {\n            \n            \n            \n            break;\n        }\n    }\n}\n\nvoid ble_npl_eventq_init(struct ble_npl_eventq *evq) {\n    DEBUG_EVENT_printf(\"ble_npl_eventq_init(%p)\\n\", evq);\n    os_sr_t sr;\n    OS_ENTER_CRITICAL(sr);\n    evq->head = NULL;\n    struct ble_npl_eventq **evq2;\n    for (evq2 = &global_eventq; *evq2 != NULL; evq2 = &(*evq2)->nextq) {\n    }\n    *evq2 = evq;\n    evq->nextq = NULL;\n    OS_EXIT_CRITICAL(sr);\n}\n\nvoid ble_npl_eventq_put(struct ble_npl_eventq *evq, struct ble_npl_event *ev) {\n    DEBUG_EVENT_printf(\"ble_npl_eventq_put(%p, %p (%p, %p))\\n\", evq, ev, ev->fn, ev->arg);\n    os_sr_t sr;\n    OS_ENTER_CRITICAL(sr);\n    ev->next = NULL;\n    ev->pending = true;\n    if (evq->head == NULL) {\n        \n        evq->head = ev;\n        ev->prev = NULL;\n    } else {\n        \n        struct ble_npl_event *tail = evq->head;\n        while (true) {\n            if (tail == ev) {\n                DEBUG_EVENT_printf(\"  --> already in queue\\n\");\n                \n                \n                break;\n            }\n            if (tail->next == NULL) {\n                \n                tail->next = ev;\n                ev->prev = tail;\n                break;\n            }\n            DEBUG_EVENT_printf(\"  --> %p\\n\", tail->next);\n            tail = tail->next;\n        }\n    }\n    OS_EXIT_CRITICAL(sr);\n}\n\nvoid ble_npl_event_init(struct ble_npl_event *ev, ble_npl_event_fn *fn, void *arg) {\n    DEBUG_EVENT_printf(\"ble_npl_event_init(%p, %p, %p)\\n\", ev, fn, arg);\n    ev->fn = fn;\n    ev->arg = arg;\n    ev->next = NULL;\n    ev->pending = false;\n}\n\nvoid *ble_npl_event_get_arg(struct ble_npl_event *ev) {\n    DEBUG_EVENT_printf(\"ble_npl_event_get_arg(%p) -> %p\\n\", ev, ev->arg);\n    return ev->arg;\n}\n\nvoid ble_npl_event_set_arg(struct ble_npl_event *ev, void *arg) {\n    DEBUG_EVENT_printf(\"ble_npl_event_set_arg(%p, %p)\\n\", ev, arg);\n    ev->arg = arg;\n}\n\n \n\n\nble_npl_error_t ble_npl_mutex_init(struct ble_npl_mutex *mu) {\n    DEBUG_MUTEX_printf(\"ble_npl_mutex_init(%p)\\n\", mu);\n    mu->locked = 0;\n    return BLE_NPL_OK;\n}\n\nble_npl_error_t ble_npl_mutex_pend(struct ble_npl_mutex *mu, ble_npl_time_t timeout) {\n    DEBUG_MUTEX_printf(\"ble_npl_mutex_pend(%p, %u) locked=%u\\n\", mu, (uint)timeout, (uint)mu->locked);\n\n    \n    \n\n    ++mu->locked;\n\n    return BLE_NPL_OK;\n}\n\nble_npl_error_t ble_npl_mutex_release(struct ble_npl_mutex *mu) {\n    DEBUG_MUTEX_printf(\"ble_npl_mutex_release(%p) locked=%u\\n\", mu, (uint)mu->locked);\n    assert(mu->locked > 0);\n\n    --mu->locked;\n\n    return BLE_NPL_OK;\n}\n\n \n\n\nble_npl_error_t ble_npl_sem_init(struct ble_npl_sem *sem, uint16_t tokens) {\n    DEBUG_SEM_printf(\"ble_npl_sem_init(%p, %u)\\n\", sem, (uint)tokens);\n    sem->count = tokens;\n    return BLE_NPL_OK;\n}\n\nble_npl_error_t ble_npl_sem_pend(struct ble_npl_sem *sem, ble_npl_time_t timeout) {\n    DEBUG_SEM_printf(\"ble_npl_sem_pend(%p, %u) count=%u\\n\", sem, (uint)timeout, (uint)sem->count);\n\n    \n    \n    \n    \n    \n\n    if (sem->count == 0) {\n        uint32_t t0 = mp_hal_ticks_ms();\n        while (sem->count == 0 && mp_hal_ticks_ms() - t0 < timeout) {\n            if (sem->count != 0) {\n                break;\n            }\n\n            mp_bluetooth_nimble_hci_uart_wfi();\n        }\n\n        if (sem->count == 0) {\n            DEBUG_SEM_printf(\"ble_npl_sem_pend: semaphore timeout\\n\");\n            return BLE_NPL_TIMEOUT;\n        }\n\n        DEBUG_SEM_printf(\"ble_npl_sem_pend: acquired in %u ms\\n\", (int)(mp_hal_ticks_ms() - t0));\n    }\n    sem->count -= 1;\n    return BLE_NPL_OK;\n}\n\nble_npl_error_t ble_npl_sem_release(struct ble_npl_sem *sem) {\n    DEBUG_SEM_printf(\"ble_npl_sem_release(%p)\\n\", sem);\n    sem->count += 1;\n    return BLE_NPL_OK;\n}\n\nuint16_t ble_npl_sem_get_count(struct ble_npl_sem *sem) {\n    DEBUG_SEM_printf(\"ble_npl_sem_get_count(%p)\\n\", sem);\n    return sem->count;\n}\n\n \n\n\nstatic struct ble_npl_callout *global_callout = NULL;\n\nvoid mp_bluetooth_nimble_os_callout_process(void) {\n    os_sr_t sr;\n    OS_ENTER_CRITICAL(sr);\n    uint32_t tnow = mp_hal_ticks_ms();\n    for (struct ble_npl_callout *c = global_callout; c != NULL; c = c->nextc) {\n        if (!c->active) {\n            continue;\n        }\n        if ((int32_t)(tnow - c->ticks) >= 0) {\n            DEBUG_CALLOUT_printf(\"callout_run(%p) tnow=%u ticks=%u evq=%p\\n\", c, (uint)tnow, (uint)c->ticks, c->evq);\n            c->active = false;\n            if (c->evq) {\n                \n                ble_npl_eventq_put(c->evq, &c->ev);\n            } else {\n                \n                OS_EXIT_CRITICAL(sr);\n                c->ev.fn(&c->ev);\n                OS_ENTER_CRITICAL(sr);\n            }\n            DEBUG_CALLOUT_printf(\"callout_run(%p) done\\n\", c);\n        }\n    }\n    OS_EXIT_CRITICAL(sr);\n}\n\nvoid ble_npl_callout_init(struct ble_npl_callout *c, struct ble_npl_eventq *evq, ble_npl_event_fn *ev_cb, void *ev_arg) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_init(%p, %p, %p, %p)\\n\", c, evq, ev_cb, ev_arg);\n    os_sr_t sr;\n    OS_ENTER_CRITICAL(sr);\n    c->active = false;\n    c->ticks = 0;\n    c->evq = evq;\n    ble_npl_event_init(&c->ev, ev_cb, ev_arg);\n\n    struct ble_npl_callout **c2;\n    for (c2 = &global_callout; *c2 != NULL; c2 = &(*c2)->nextc) {\n        if (c == *c2) {\n            \n            OS_EXIT_CRITICAL(sr);\n            return;\n        }\n    }\n    *c2 = c;\n    c->nextc = NULL;\n    OS_EXIT_CRITICAL(sr);\n}\n\nble_npl_error_t ble_npl_callout_reset(struct ble_npl_callout *c, ble_npl_time_t ticks) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_reset(%p, %u) tnow=%u\\n\", c, (uint)ticks, (uint)mp_hal_ticks_ms());\n    os_sr_t sr;\n    OS_ENTER_CRITICAL(sr);\n    c->active = true;\n    c->ticks = ble_npl_time_get() + ticks;\n    OS_EXIT_CRITICAL(sr);\n    return BLE_NPL_OK;\n}\n\nvoid ble_npl_callout_stop(struct ble_npl_callout *c) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_stop(%p)\\n\", c);\n    c->active = false;\n}\n\nbool ble_npl_callout_is_active(struct ble_npl_callout *c) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_is_active(%p)\\n\", c);\n    return c->active;\n}\n\nble_npl_time_t ble_npl_callout_get_ticks(struct ble_npl_callout *c) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_get_ticks(%p)\\n\", c);\n    return c->ticks;\n}\n\nble_npl_time_t ble_npl_callout_remaining_ticks(struct ble_npl_callout *c, ble_npl_time_t now) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_remaining_ticks(%p, %u)\\n\", c, (uint)now);\n    if (c->ticks > now) {\n        return c->ticks - now;\n    } else {\n        return 0;\n    }\n}\n\nvoid *ble_npl_callout_get_arg(struct ble_npl_callout *c) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_get_arg(%p)\\n\", c);\n    return ble_npl_event_get_arg(&c->ev);\n}\n\nvoid ble_npl_callout_set_arg(struct ble_npl_callout *c, void *arg) {\n    DEBUG_CALLOUT_printf(\"ble_npl_callout_set_arg(%p, %p)\\n\", c, arg);\n    ble_npl_event_set_arg(&c->ev, arg);\n}\n\n \n\n\nuint32_t ble_npl_time_get(void) {\n    DEBUG_TIME_printf(\"ble_npl_time_get -> %u\\n\", (uint)mp_hal_ticks_ms());\n    return mp_hal_ticks_ms();\n}\n\nble_npl_error_t ble_npl_time_ms_to_ticks(uint32_t ms, ble_npl_time_t *out_ticks) {\n    DEBUG_TIME_printf(\"ble_npl_time_ms_to_ticks(%u)\\n\", (uint)ms);\n    *out_ticks = ms;\n    return BLE_NPL_OK;\n}\n\nble_npl_time_t ble_npl_time_ms_to_ticks32(uint32_t ms) {\n    DEBUG_TIME_printf(\"ble_npl_time_ms_to_ticks32(%u)\\n\", (uint)ms);\n    return ms;\n}\n\nuint32_t ble_npl_time_ticks_to_ms32(ble_npl_time_t ticks) {\n    DEBUG_TIME_printf(\"ble_npl_time_ticks_to_ms32(%u)\\n\", (uint)ticks);\n    return ticks;\n}\n\nvoid ble_npl_time_delay(ble_npl_time_t ticks) {\n    mp_hal_delay_ms(ticks + 1);\n}\n\n \n\n\n\n\n\n\n\n\n\n\nuint32_t ble_npl_hw_enter_critical(void) {\n    DEBUG_CRIT_printf(\"ble_npl_hw_enter_critical()\\n\");\n    MICROPY_PY_BLUETOOTH_ENTER\n    return atomic_state;\n}\n\nvoid ble_npl_hw_exit_critical(uint32_t atomic_state) {\n    MICROPY_PY_BLUETOOTH_EXIT\n    DEBUG_CRIT_printf(\"ble_npl_hw_exit_critical(%u)\\n\", (uint)atomic_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}