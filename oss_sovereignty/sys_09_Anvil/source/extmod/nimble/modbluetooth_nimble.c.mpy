{
  "module_name": "modbluetooth_nimble.c",
  "hash_id": "7c28ff17677a0f543d877ebc0a0a035ba432fa2c539ad2a895faa393d2daf3e9",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/nimble/modbluetooth_nimble.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_BLUETOOTH && MICROPY_BLUETOOTH_NIMBLE\n\n#include \"extmod/nimble/modbluetooth_nimble.h\"\n#include \"extmod/modbluetooth.h\"\n#include \"extmod/mpbthci.h\"\n\n#include \"host/ble_hs.h\"\n#include \"host/util/util.h\"\n#include \"nimble/ble.h\"\n#include \"nimble/nimble_port.h\"\n#include \"services/gap/ble_svc_gap.h\"\n#include \"services/gatt/ble_svc_gatt.h\"\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\n\n\n#include \"nimble/host/src/ble_l2cap_priv.h\"\n#endif\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_HCI_CMD || MICROPY_BLUETOOTH_USE_ZEPHYR_STATIC_ADDRESS\n\n#include \"nimble/host/src/ble_hs_hci_priv.h\"\n#endif\n\n#define DEBUG_printf(...) \n\n#define ERRNO_BLUETOOTH_NOT_ACTIVE MP_ENODEV\n\nstatic uint8_t nimble_address_mode = BLE_OWN_ADDR_RANDOM;\n\n#define NIMBLE_STARTUP_TIMEOUT 2000\n\n\nstatic int8_t ble_hs_err_to_errno_table[] = {\n    [BLE_HS_EAGAIN] = MP_EAGAIN,\n    [BLE_HS_EALREADY] = MP_EALREADY,\n    [BLE_HS_EINVAL] = MP_EINVAL,\n    [BLE_HS_ENOENT] = MP_ENOENT,\n    [BLE_HS_ENOMEM] = MP_ENOMEM,\n    [BLE_HS_ENOTCONN] = MP_ENOTCONN,\n    [BLE_HS_ENOTSUP] = MP_EOPNOTSUPP,\n    [BLE_HS_ETIMEOUT] = MP_ETIMEDOUT,\n    [BLE_HS_EDONE] = MP_EIO,               \n    [BLE_HS_EBUSY] = MP_EBUSY,\n    [BLE_HS_EBADDATA] = MP_EINVAL,\n};\n\nstatic int ble_hs_err_to_errno(int err);\n\nstatic ble_uuid_t *create_nimble_uuid(const mp_obj_bluetooth_uuid_t *uuid, ble_uuid_any_t *storage);\nstatic void reverse_addr_byte_order(uint8_t *addr_out, const uint8_t *addr_in);\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nstatic mp_obj_bluetooth_uuid_t create_mp_uuid(const ble_uuid_any_t *uuid);\nstatic ble_addr_t create_nimble_addr(uint8_t addr_type, const uint8_t *addr);\n#endif\n\nstatic void reset_cb(int reason);\n\nstatic bool has_public_address(void);\nstatic void set_random_address(bool nrpa);\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nstatic int load_irk(void);\n#endif\n\nstatic void sync_cb(void);\n\n#if !MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY\nstatic void ble_hs_shutdown_stop_cb(int status, void *arg);\n#endif\n\n\nstatic void gatts_register_cb(struct ble_gatt_register_ctxt *ctxt, void *arg);\n\n\nstatic int central_gap_event_cb(struct ble_gap_event *event, void *arg);\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n\nstatic int peripheral_gap_event_cb(struct ble_gap_event *event, void *arg);\n#endif\n\nstatic int commmon_gap_event_cb(struct ble_gap_event *event, void *arg);\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n\nstatic int gap_scan_cb(struct ble_gap_event *event, void *arg);\n#endif\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n\nstatic void gattc_on_data_available(uint8_t event, uint16_t conn_handle, uint16_t value_handle, const struct os_mbuf *om);\n\n\nstatic int ble_gattc_service_cb(uint16_t conn_handle, const struct ble_gatt_error *error, const struct ble_gatt_svc *service, void *arg);\nstatic int ble_gattc_characteristic_cb(uint16_t conn_handle, const struct ble_gatt_error *error, const struct ble_gatt_chr *characteristic, void *arg);\nstatic int ble_gattc_descriptor_cb(uint16_t conn_handle, const struct ble_gatt_error *error, uint16_t characteristic_val_handle, const struct ble_gatt_dsc *descriptor, void *arg);\n\n\nstatic int ble_gattc_attr_read_cb(uint16_t conn_handle, const struct ble_gatt_error *error, struct ble_gatt_attr *attr, void *arg);\nstatic int ble_gattc_attr_write_cb(uint16_t conn_handle, const struct ble_gatt_error *error, struct ble_gatt_attr *attr, void *arg);\n#endif\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n\nstatic int ble_secret_store_read(int obj_type, const union ble_store_key *key, union ble_store_value *value);\nstatic int ble_secret_store_write(int obj_type, const union ble_store_value *val);\nstatic int ble_secret_store_delete(int obj_type, const union ble_store_key *key);\n#endif\n\nstatic int ble_hs_err_to_errno(int err) {\n    DEBUG_printf(\"ble_hs_err_to_errno: %d\\n\", err);\n    if (!err) {\n        return 0;\n    }\n    if (err >= 0 && (unsigned)err < MP_ARRAY_SIZE(ble_hs_err_to_errno_table) && ble_hs_err_to_errno_table[err]) {\n        \n        return ble_hs_err_to_errno_table[err];\n    } else {\n        \n        return -err;\n    }\n}\n\n\nstatic ble_uuid_t *create_nimble_uuid(const mp_obj_bluetooth_uuid_t *uuid, ble_uuid_any_t *storage) {\n    if (uuid->type == MP_BLUETOOTH_UUID_TYPE_16) {\n        ble_uuid16_t *result = storage ? &storage->u16 : m_new(ble_uuid16_t, 1);\n        result->u.type = BLE_UUID_TYPE_16;\n        result->value = (uuid->data[1] << 8) | uuid->data[0];\n        return (ble_uuid_t *)result;\n    } else if (uuid->type == MP_BLUETOOTH_UUID_TYPE_32) {\n        ble_uuid32_t *result = storage ? &storage->u32 : m_new(ble_uuid32_t, 1);\n        result->u.type = BLE_UUID_TYPE_32;\n        result->value = (uuid->data[1] << 24) | (uuid->data[1] << 16) | (uuid->data[1] << 8) | uuid->data[0];\n        return (ble_uuid_t *)result;\n    } else if (uuid->type == MP_BLUETOOTH_UUID_TYPE_128) {\n        ble_uuid128_t *result = storage ? &storage->u128 : m_new(ble_uuid128_t, 1);\n        result->u.type = BLE_UUID_TYPE_128;\n        memcpy(result->value, uuid->data, 16);\n        return (ble_uuid_t *)result;\n    } else {\n        return NULL;\n    }\n}\n\n\nstatic void reverse_addr_byte_order(uint8_t *addr_out, const uint8_t *addr_in) {\n    for (int i = 0; i < 6; ++i) {\n        addr_out[i] = addr_in[5 - i];\n    }\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n\nstatic mp_obj_bluetooth_uuid_t create_mp_uuid(const ble_uuid_any_t *uuid) {\n    mp_obj_bluetooth_uuid_t result;\n    result.base.type = &mp_type_bluetooth_uuid;\n    switch (uuid->u.type) {\n        case BLE_UUID_TYPE_16:\n            result.type = MP_BLUETOOTH_UUID_TYPE_16;\n            result.data[0] = uuid->u16.value & 0xff;\n            result.data[1] = (uuid->u16.value >> 8) & 0xff;\n            break;\n        case BLE_UUID_TYPE_32:\n            result.type = MP_BLUETOOTH_UUID_TYPE_32;\n            result.data[0] = uuid->u32.value & 0xff;\n            result.data[1] = (uuid->u32.value >> 8) & 0xff;\n            result.data[2] = (uuid->u32.value >> 16) & 0xff;\n            result.data[3] = (uuid->u32.value >> 24) & 0xff;\n            break;\n        case BLE_UUID_TYPE_128:\n            result.type = MP_BLUETOOTH_UUID_TYPE_128;\n            memcpy(result.data, uuid->u128.value, 16);\n            break;\n        default:\n            assert(false);\n    }\n    return result;\n}\n\nstatic ble_addr_t create_nimble_addr(uint8_t addr_type, const uint8_t *addr) {\n    ble_addr_t addr_nimble;\n    addr_nimble.type = addr_type;\n    \n    reverse_addr_byte_order(addr_nimble.val, addr);\n    return addr_nimble;\n}\n\n#endif \n\nvolatile int mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF;\n\nstatic void reset_cb(int reason) {\n    (void)reason;\n}\n\nstatic bool has_public_address(void) {\n    return ble_hs_id_copy_addr(BLE_ADDR_PUBLIC, NULL, NULL) == 0;\n}\n\nstatic void set_random_address(bool nrpa) {\n    int rc;\n    (void)rc;\n    ble_addr_t addr;\n    #if MICROPY_BLUETOOTH_USE_MP_HAL_GET_MAC_STATIC_ADDRESS\n    if (!nrpa) {\n        DEBUG_printf(\"set_random_address: Generating static address using mp_hal_get_mac\\n\");\n        uint8_t hal_mac_addr[6];\n        mp_hal_get_mac(MP_HAL_MAC_BDADDR, hal_mac_addr);\n        addr = create_nimble_addr(BLE_ADDR_RANDOM, hal_mac_addr);\n        \n        addr.val[5] |= 0xc0;\n    } else\n    #elif MICROPY_BLUETOOTH_USE_ZEPHYR_STATIC_ADDRESS\n    if (!nrpa) {\n        DEBUG_printf(\"set_random_address: Generating static address from Zephyr controller\\n\");\n        uint8_t buf[23];\n        rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_VENDOR, 0x09), NULL, 0, buf, sizeof(buf));\n        assert(rc == 0);\n        memcpy(addr.val, buf + 1, 6);\n    } else\n    #endif\n    {\n        DEBUG_printf(\"set_random_address: Generating random static address\\n\");\n        rc = ble_hs_id_gen_rnd(nrpa ? 1 : 0, &addr);\n        assert(rc == 0);\n    }\n    rc = ble_hs_id_set_rnd(addr.val);\n    assert(rc == 0);\n    rc = ble_hs_util_ensure_addr(1);\n    assert(rc == 0);\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n\n#include \"nimble/host/src/ble_hs_pvcy_priv.h\"\n\n#include \"nimble/host/src/ble_hs_hci_priv.h\"\n\n#include \"nimble/host/src/ble_hs_priv.h\"\n\n\n#define SECRET_TYPE_OUR_IRK 10\n\nstatic int load_irk(void) {\n    \n    \n\n    \n    \n    \n    const uint8_t key[3] = {'i', 'r', 'k'};\n\n    int rc;\n    const uint8_t *irk;\n    size_t irk_len;\n    if (mp_bluetooth_gap_on_get_secret(SECRET_TYPE_OUR_IRK, 0, key, sizeof(key), &irk, &irk_len) && irk_len == 16) {\n        DEBUG_printf(\"load_irk: Applying IRK from store.\\n\");\n        rc = ble_hs_pvcy_set_our_irk(irk);\n        if (rc) {\n            return rc;\n        }\n    } else {\n        DEBUG_printf(\"load_irk: Generating new IRK.\\n\");\n        uint8_t rand_irk[16];\n        rc = ble_hs_hci_util_rand(rand_irk, 16);\n        if (rc) {\n            return rc;\n        }\n        DEBUG_printf(\"load_irk: Saving new IRK.\\n\");\n        if (!mp_bluetooth_gap_on_set_secret(SECRET_TYPE_OUR_IRK, key, sizeof(key), rand_irk, 16)) {\n            \n            \n            return 0;\n        }\n        DEBUG_printf(\"load_irk: Applying new IRK.\\n\");\n        rc = ble_hs_pvcy_set_our_irk(rand_irk);\n        if (rc) {\n            return rc;\n        }\n    }\n\n    \n    rc = ble_hs_misc_restore_irks();\n    return rc;\n}\n#endif\n\nstatic void sync_cb(void) {\n    int rc;\n    (void)rc;\n\n    DEBUG_printf(\"sync_cb: state=%d\\n\", mp_bluetooth_nimble_ble_state);\n\n    if (mp_bluetooth_nimble_ble_state != MP_BLUETOOTH_NIMBLE_BLE_STATE_WAITING_FOR_SYNC) {\n        return;\n    }\n\n    #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n    rc = load_irk();\n    assert(rc == 0);\n    #endif\n\n    if (has_public_address()) {\n        nimble_address_mode = BLE_OWN_ADDR_PUBLIC;\n    } else {\n        nimble_address_mode = BLE_OWN_ADDR_RANDOM;\n        set_random_address(false);\n    }\n\n    if (MP_BLUETOOTH_DEFAULT_ATTR_LEN > 20) {\n        DEBUG_printf(\"sync_cb: Setting MTU\\n\");\n        rc = ble_att_set_preferred_mtu(MP_BLUETOOTH_DEFAULT_ATTR_LEN + 3);\n        assert(rc == 0);\n    }\n\n    mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_ACTIVE;\n}\n\nstatic void gatts_register_cb(struct ble_gatt_register_ctxt *ctxt, void *arg) {\n    if (!mp_bluetooth_is_active()) {\n        return;\n    }\n    switch (ctxt->op) {\n        case BLE_GATT_REGISTER_OP_SVC:\n            \n            DEBUG_printf(\"gatts_register_cb: svc uuid=%p handle=%d\\n\", &ctxt->svc.svc_def->uuid, ctxt->svc.handle);\n            break;\n\n        case BLE_GATT_REGISTER_OP_CHR:\n            \n            DEBUG_printf(\"gatts_register_cb: chr uuid=%p def_handle=%d val_handle=%d\\n\", &ctxt->chr.chr_def->uuid, ctxt->chr.def_handle, ctxt->chr.val_handle);\n\n            \n            \n            \n\n            \n            \n            mp_bluetooth_gatts_db_create_entry(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, ctxt->chr.val_handle, MP_BLUETOOTH_DEFAULT_ATTR_LEN);\n            break;\n\n        case BLE_GATT_REGISTER_OP_DSC:\n            \n            \n            DEBUG_printf(\"gatts_register_cb: dsc uuid=%p handle=%d\\n\", &ctxt->dsc.dsc_def->uuid, ctxt->dsc.handle);\n\n            \n            mp_bluetooth_gatts_db_create_entry(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, ctxt->dsc.handle, MP_BLUETOOTH_DEFAULT_ATTR_LEN);\n\n            \n            *((uint16_t *)ctxt->dsc.dsc_def->arg) = ctxt->dsc.handle;\n            break;\n\n        default:\n            DEBUG_printf(\"gatts_register_cb: unknown op %d\\n\", ctxt->op);\n            break;\n    }\n}\n\nstatic int commmon_gap_event_cb(struct ble_gap_event *event, void *arg) {\n    struct ble_gap_conn_desc desc;\n\n    switch (event->type) {\n        #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n        case BLE_GAP_EVENT_NOTIFY_RX: {\n            uint16_t ev = event->notify_rx.indication == 0 ? MP_BLUETOOTH_IRQ_GATTC_NOTIFY : MP_BLUETOOTH_IRQ_GATTC_INDICATE;\n            gattc_on_data_available(ev, event->notify_rx.conn_handle, event->notify_rx.attr_handle, event->notify_rx.om);\n            return 0;\n        }\n        #endif \n\n        case BLE_GAP_EVENT_CONN_UPDATE: {\n            DEBUG_printf(\"commmon_gap_event_cb: connection update: status=%d\\n\", event->conn_update.status);\n            if (ble_gap_conn_find(event->conn_update.conn_handle, &desc) == 0) {\n                mp_bluetooth_gap_on_connection_update(event->conn_update.conn_handle, desc.conn_itvl, desc.conn_latency, desc.supervision_timeout, event->conn_update.status == 0 ? 0 : 1);\n            }\n            return 0;\n        }\n\n        case BLE_GAP_EVENT_MTU: {\n            if (event->mtu.channel_id == BLE_L2CAP_CID_ATT) {\n                DEBUG_printf(\"commmon_gap_event_cb: mtu update: conn_handle=%d cid=%d mtu=%d\\n\", event->mtu.conn_handle, event->mtu.channel_id, event->mtu.value);\n                mp_bluetooth_gatts_on_mtu_exchanged(event->mtu.conn_handle, event->mtu.value);\n            }\n            return 0;\n        }\n\n        case BLE_GAP_EVENT_ENC_CHANGE: {\n            DEBUG_printf(\"commmon_gap_event_cb: enc change: status=%d\\n\", event->enc_change.status);\n            #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n            if (ble_gap_conn_find(event->enc_change.conn_handle, &desc) == 0) {\n                mp_bluetooth_gatts_on_encryption_update(event->conn_update.conn_handle,\n                    desc.sec_state.encrypted, desc.sec_state.authenticated,\n                    desc.sec_state.bonded, desc.sec_state.key_size);\n            }\n            #endif\n            return 0;\n        }\n\n        default:\n            DEBUG_printf(\"commmon_gap_event_cb: unknown type %d\\n\", event->type);\n            return 0;\n    }\n}\n\nstatic int central_gap_event_cb(struct ble_gap_event *event, void *arg) {\n    DEBUG_printf(\"central_gap_event_cb: type=%d\\n\", event->type);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    struct ble_gap_conn_desc desc;\n    uint8_t addr[6] = {0};\n\n    switch (event->type) {\n        case BLE_GAP_EVENT_CONNECT:\n            DEBUG_printf(\"central_gap_event_cb: connect: status=%d\\n\", event->connect.status);\n            if (event->connect.status == 0) {\n                \n                ble_gap_conn_find(event->connect.conn_handle, &desc);\n                reverse_addr_byte_order(addr, desc.peer_id_addr.val);\n                mp_bluetooth_gap_on_connected_disconnected(MP_BLUETOOTH_IRQ_CENTRAL_CONNECT, event->connect.conn_handle, desc.peer_id_addr.type, addr);\n            } else {\n                \n                mp_bluetooth_gap_on_connected_disconnected(MP_BLUETOOTH_IRQ_CENTRAL_DISCONNECT, event->connect.conn_handle, 0xff, addr);\n            }\n            return 0;\n\n        case BLE_GAP_EVENT_DISCONNECT:\n            \n            DEBUG_printf(\"central_gap_event_cb: disconnect: reason=%d\\n\", event->disconnect.reason);\n            reverse_addr_byte_order(addr, event->disconnect.conn.peer_id_addr.val);\n            mp_bluetooth_gap_on_connected_disconnected(MP_BLUETOOTH_IRQ_CENTRAL_DISCONNECT, event->disconnect.conn.conn_handle, event->disconnect.conn.peer_id_addr.type, addr);\n            return 0;\n\n        case BLE_GAP_EVENT_NOTIFY_TX: {\n            DEBUG_printf(\"central_gap_event_cb: notify_tx: %d %d\\n\", event->notify_tx.indication, event->notify_tx.status);\n            \n            if (event->notify_tx.indication && event->notify_tx.status != 0) {\n                \n                mp_bluetooth_gatts_on_indicate_complete(event->notify_tx.conn_handle, event->notify_tx.attr_handle, event->notify_tx.status == BLE_HS_EDONE ? 0 : event->notify_tx.status);\n            }\n            return 0;\n        }\n\n        case BLE_GAP_EVENT_PHY_UPDATE_COMPLETE:\n            DEBUG_printf(\"central_gap_event_cb: phy update: %d\\n\", event->phy_updated.tx_phy);\n            return 0;\n\n        case BLE_GAP_EVENT_REPEAT_PAIRING: {\n            \n            DEBUG_printf(\"central_gap_event_cb: repeat pairing: conn_handle=%d\\n\", event->repeat_pairing.conn_handle);\n\n            \n            \n\n            \n            int rc = ble_gap_conn_find(event->repeat_pairing.conn_handle, &desc);\n            if (rc == 0) {\n                ble_store_util_delete_peer(&desc.peer_id_addr);\n            }\n\n            \n            return BLE_GAP_REPEAT_PAIRING_RETRY;\n        }\n\n        case BLE_GAP_EVENT_PASSKEY_ACTION: {\n            DEBUG_printf(\"central_gap_event_cb: passkey action: conn_handle=%d action=%d num=\" UINT_FMT \"\\n\", event->passkey.conn_handle, event->passkey.params.action, (mp_uint_t)event->passkey.params.numcmp);\n\n            #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n            mp_bluetooth_gap_on_passkey_action(event->passkey.conn_handle, event->passkey.params.action, event->passkey.params.numcmp);\n            #endif\n\n            return 0;\n        }\n\n        case BLE_GAP_EVENT_SUBSCRIBE: {\n            DEBUG_printf(\"central_gap_event_cb: subscribe: handle=%d, reason=%d notify=%d indicate=%d \\n\", event->subscribe.attr_handle, event->subscribe.reason, event->subscribe.cur_notify, event->subscribe.cur_indicate);\n            return 0;\n        }\n    }\n\n    return commmon_gap_event_cb(event, arg);\n}\n\n#if !MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY\n\n\n\n\n\n\n\n\n#include \"transport/uart/ble_hci_uart.h\"\n\nvoid mp_bluetooth_nimble_port_hci_init(void) {\n    DEBUG_printf(\"mp_bluetooth_nimble_port_hci_init (nimble default)\\n\");\n    \n    ble_hci_uart_init();\n    mp_bluetooth_hci_controller_init();\n}\n\nvoid mp_bluetooth_nimble_port_hci_deinit(void) {\n    DEBUG_printf(\"mp_bluetooth_nimble_port_hci_deinit (nimble default)\\n\");\n    mp_bluetooth_hci_controller_deinit();\n    mp_bluetooth_hci_uart_deinit();\n}\n\nvoid mp_bluetooth_nimble_port_start(void) {\n    DEBUG_printf(\"mp_bluetooth_nimble_port_start (nimble default)\\n\");\n    \n    \n}\n\n\nstatic void ble_hs_shutdown_stop_cb(int status, void *arg) {\n    (void)status;\n    (void)arg;\n    mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF;\n}\n\nstatic struct ble_hs_stop_listener ble_hs_shutdown_stop_listener;\n\nvoid mp_bluetooth_nimble_port_shutdown(void) {\n    DEBUG_printf(\"mp_bluetooth_nimble_port_shutdown (nimble default)\\n\");\n    \n\n    mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_STOPPING;\n\n    ble_hs_stop(&ble_hs_shutdown_stop_listener, ble_hs_shutdown_stop_cb, NULL);\n\n    while (mp_bluetooth_nimble_ble_state != MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF) {\n        mp_event_wait_indefinite();\n    }\n}\n\n#endif \n\nvoid nimble_reset_gatts_bss(void) {\n    \n    \n    \n    \n    \n    extern uint16_t ble_hs_max_attrs;\n    extern uint16_t ble_hs_max_services;\n    extern uint16_t ble_hs_max_client_configs;\n    ble_hs_max_attrs = 0;\n    ble_hs_max_services = 0;\n    ble_hs_max_client_configs = 0;\n}\n\nint mp_bluetooth_init(void) {\n    DEBUG_printf(\"mp_bluetooth_init\\n\");\n    \n    mp_bluetooth_deinit();\n\n    nimble_reset_gatts_bss();\n\n    mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_STARTING;\n\n    MP_STATE_PORT(bluetooth_nimble_root_pointers) = m_new0(mp_bluetooth_nimble_root_pointers_t, 1);\n    mp_bluetooth_gatts_db_create(&MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db);\n\n    #if !MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY\n    \n    MP_STATE_PORT(bluetooth_nimble_memory) = NULL;\n    #endif\n\n    \n    \n    mp_bluetooth_nimble_port_hci_init();\n\n    \n    mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_WAITING_FOR_SYNC;\n\n    \n    DEBUG_printf(\"mp_bluetooth_init: nimble_port_init\\n\");\n    nimble_port_init();\n\n    ble_hs_cfg.reset_cb = reset_cb;\n    ble_hs_cfg.sync_cb = sync_cb;\n    ble_hs_cfg.gatts_register_cb = gatts_register_cb;\n    ble_hs_cfg.store_status_cb = ble_store_util_status_rr;\n\n    #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n    ble_hs_cfg.sm_our_key_dist = BLE_SM_PAIR_KEY_DIST_ENC | BLE_SM_PAIR_KEY_DIST_ID | BLE_SM_PAIR_KEY_DIST_SIGN;\n    ble_hs_cfg.sm_their_key_dist = BLE_SM_PAIR_KEY_DIST_ENC | BLE_SM_PAIR_KEY_DIST_ID | BLE_SM_PAIR_KEY_DIST_SIGN;\n    ble_hs_cfg.store_read_cb = ble_secret_store_read;\n    ble_hs_cfg.store_write_cb = ble_secret_store_write;\n    ble_hs_cfg.store_delete_cb = ble_secret_store_delete;\n    #endif \n\n    \n    mp_bluetooth_nimble_port_start();\n\n    \n    \n    mp_uint_t timeout_start_ticks_ms = mp_hal_ticks_ms();\n    while (mp_bluetooth_nimble_ble_state != MP_BLUETOOTH_NIMBLE_BLE_STATE_ACTIVE) {\n        uint32_t elapsed = mp_hal_ticks_ms() - timeout_start_ticks_ms;\n        if (elapsed > NIMBLE_STARTUP_TIMEOUT) {\n            break;\n        }\n        mp_event_wait_ms(NIMBLE_STARTUP_TIMEOUT - elapsed);\n    }\n\n    if (mp_bluetooth_nimble_ble_state != MP_BLUETOOTH_NIMBLE_BLE_STATE_ACTIVE) {\n        mp_bluetooth_deinit();\n        return MP_ETIMEDOUT;\n    }\n\n    DEBUG_printf(\"mp_bluetooth_init: starting services\\n\");\n\n    \n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n    \n    \n    \n    \n    ble_gatts_start();\n\n    DEBUG_printf(\"mp_bluetooth_init: ready\\n\");\n\n    return 0;\n}\n\nvoid mp_bluetooth_deinit(void) {\n    DEBUG_printf(\"mp_bluetooth_deinit %d\\n\", mp_bluetooth_nimble_ble_state);\n    if (mp_bluetooth_nimble_ble_state == MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF) {\n        return;\n    }\n\n    \n    \n    if (mp_bluetooth_nimble_ble_state == MP_BLUETOOTH_NIMBLE_BLE_STATE_ACTIVE) {\n        mp_bluetooth_gap_advertise_stop();\n        #if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n        mp_bluetooth_gap_scan_stop();\n        #endif\n\n        DEBUG_printf(\"mp_bluetooth_deinit: starting port shutdown\\n\");\n\n        mp_bluetooth_nimble_port_shutdown();\n        assert(mp_bluetooth_nimble_ble_state == MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF);\n    } else {\n        mp_bluetooth_nimble_ble_state = MP_BLUETOOTH_NIMBLE_BLE_STATE_OFF;\n    }\n\n    \n    mp_bluetooth_nimble_port_hci_deinit();\n\n    MP_STATE_PORT(bluetooth_nimble_root_pointers) = NULL;\n\n    #if !MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY\n    \n    MP_STATE_PORT(bluetooth_nimble_memory) = NULL;\n    #endif\n\n    DEBUG_printf(\"mp_bluetooth_deinit: shut down\\n\");\n}\n\nbool mp_bluetooth_is_active(void) {\n    return mp_bluetooth_nimble_ble_state == MP_BLUETOOTH_NIMBLE_BLE_STATE_ACTIVE;\n}\n\nvoid mp_bluetooth_get_current_address(uint8_t *addr_type, uint8_t *addr) {\n    if (!mp_bluetooth_is_active()) {\n        mp_raise_OSError(ERRNO_BLUETOOTH_NOT_ACTIVE);\n    }\n\n    uint8_t addr_le[6];\n\n    switch (nimble_address_mode) {\n        case BLE_OWN_ADDR_PUBLIC:\n            *addr_type = BLE_ADDR_PUBLIC;\n            break;\n        case BLE_OWN_ADDR_RANDOM:\n            *addr_type = BLE_ADDR_RANDOM;\n            break;\n        case BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT:\n        case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:\n        default:\n            \n            \n            mp_raise_OSError(MP_EINVAL);\n    }\n\n    int rc = ble_hs_id_copy_addr(*addr_type, addr_le, NULL);\n    if (rc != 0) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n    reverse_addr_byte_order(addr, addr_le);\n}\n\nvoid mp_bluetooth_set_address_mode(uint8_t addr_mode) {\n    if (!mp_bluetooth_is_active()) {\n        mp_raise_OSError(ERRNO_BLUETOOTH_NOT_ACTIVE);\n    }\n    switch (addr_mode) {\n        case MP_BLUETOOTH_ADDRESS_MODE_PUBLIC:\n            if (!has_public_address()) {\n                \n                mp_raise_OSError(MP_EINVAL);\n            }\n            nimble_address_mode = BLE_OWN_ADDR_PUBLIC;\n            break;\n        case MP_BLUETOOTH_ADDRESS_MODE_RANDOM:\n            \n            set_random_address(false);\n            nimble_address_mode = BLE_OWN_ADDR_RANDOM;\n            break;\n        case MP_BLUETOOTH_ADDRESS_MODE_RPA:\n            if (has_public_address()) {\n                nimble_address_mode = BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT;\n            } else {\n                \n                set_random_address(false);\n                nimble_address_mode = BLE_OWN_ADDR_RPA_RANDOM_DEFAULT;\n            }\n            break;\n        case MP_BLUETOOTH_ADDRESS_MODE_NRPA:\n            \n            set_random_address(true);\n            \n            nimble_address_mode = BLE_OWN_ADDR_RANDOM;\n            break;\n    }\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nvoid mp_bluetooth_set_bonding(bool enabled) {\n    ble_hs_cfg.sm_bonding = enabled;\n}\n\nvoid mp_bluetooth_set_mitm_protection(bool enabled) {\n    ble_hs_cfg.sm_mitm = enabled;\n}\n\nvoid mp_bluetooth_set_le_secure(bool enabled) {\n    ble_hs_cfg.sm_sc = enabled;\n}\n\nvoid mp_bluetooth_set_io_capability(uint8_t capability) {\n    ble_hs_cfg.sm_io_cap = capability;\n}\n#endif \n\nsize_t mp_bluetooth_gap_get_device_name(const uint8_t **buf) {\n    const char *name = ble_svc_gap_device_name();\n    *buf = (const uint8_t *)name;\n    return strlen(name);\n}\n\nint mp_bluetooth_gap_set_device_name(const uint8_t *buf, size_t len) {\n    char tmp_buf[MYNEWT_VAL(BLE_SVC_GAP_DEVICE_NAME_MAX_LENGTH) + 1];\n    if (len + 1 > sizeof(tmp_buf)) {\n        return MP_EINVAL;\n    }\n    memcpy(tmp_buf, buf, len);\n    tmp_buf[len] = '\\0';\n    return ble_hs_err_to_errno(ble_svc_gap_device_name_set(tmp_buf));\n}\n\nint mp_bluetooth_gap_advertise_start(bool connectable, int32_t interval_us, const uint8_t *adv_data, size_t adv_data_len, const uint8_t *sr_data, size_t sr_data_len) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    mp_bluetooth_gap_advertise_stop();\n\n    int ret;\n    if (adv_data) {\n        ret = ble_gap_adv_set_data(adv_data, adv_data_len);\n        if (ret != 0) {\n            return ble_hs_err_to_errno(ret);\n        }\n    }\n\n    if (sr_data) {\n        ret = ble_gap_adv_rsp_set_data(sr_data, sr_data_len);\n        if (ret != 0) {\n            return ble_hs_err_to_errno(ret);\n        }\n    }\n\n    struct ble_gap_adv_params adv_params = {\n        .conn_mode = connectable ? BLE_GAP_CONN_MODE_UND : BLE_GAP_CONN_MODE_NON,\n        .disc_mode = BLE_GAP_DISC_MODE_GEN,\n        .itvl_min = interval_us / BLE_HCI_ADV_ITVL, \n        .itvl_max = interval_us / BLE_HCI_ADV_ITVL,\n        .channel_map = 7, \n    };\n\n    ret = ble_gap_adv_start(nimble_address_mode, NULL, BLE_HS_FOREVER, &adv_params, central_gap_event_cb, NULL);\n    if (ret == 0) {\n        return 0;\n    }\n    DEBUG_printf(\"ble_gap_adv_start: %d\\n\", ret);\n\n    return ble_hs_err_to_errno(ret);\n}\n\nvoid mp_bluetooth_gap_advertise_stop(void) {\n    if (ble_gap_adv_active()) {\n        ble_gap_adv_stop();\n    }\n}\n\nstatic int characteristic_access_cb(uint16_t conn_handle, uint16_t value_handle, struct ble_gatt_access_ctxt *ctxt, void *arg) {\n    DEBUG_printf(\"characteristic_access_cb: conn_handle=%u value_handle=%u op=%u\\n\", conn_handle, value_handle, ctxt->op);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    mp_bluetooth_gatts_db_entry_t *entry;\n    switch (ctxt->op) {\n        case BLE_GATT_ACCESS_OP_READ_CHR:\n        case BLE_GATT_ACCESS_OP_READ_DSC: {\n            DEBUG_printf(\"write for %d %d (op=%d)\\n\", conn_handle, value_handle, ctxt->op);\n            \n            \n            \n            int req = mp_bluetooth_gatts_on_read_request(conn_handle, value_handle);\n            if (req) {\n                return req;\n            }\n\n            entry = mp_bluetooth_gatts_db_lookup(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, value_handle);\n            if (!entry) {\n                return BLE_ATT_ERR_ATTR_NOT_FOUND;\n            }\n\n            if (os_mbuf_append(ctxt->om, entry->data, entry->data_len)) {\n                return BLE_ATT_ERR_INSUFFICIENT_RES;\n            }\n\n            return 0;\n        }\n        case BLE_GATT_ACCESS_OP_WRITE_CHR:\n        case BLE_GATT_ACCESS_OP_WRITE_DSC:\n            DEBUG_printf(\"write for %d %d (op=%d)\\n\", conn_handle, value_handle, ctxt->op);\n            entry = mp_bluetooth_gatts_db_lookup(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, value_handle);\n            if (!entry) {\n                return BLE_ATT_ERR_ATTR_NOT_FOUND;\n            }\n\n            size_t offset = 0;\n            if (entry->append) {\n                offset = entry->data_len;\n            }\n            entry->data_len = MIN(entry->data_alloc, OS_MBUF_PKTLEN(ctxt->om) + offset);\n            os_mbuf_copydata(ctxt->om, 0, entry->data_len - offset, entry->data + offset);\n\n            \n\n            mp_bluetooth_gatts_on_write(conn_handle, value_handle);\n\n            return 0;\n    }\n    return BLE_ATT_ERR_UNLIKELY;\n}\n\nint mp_bluetooth_gatts_register_service_begin(bool append) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    if (append) {\n        \n        \n        return MP_EOPNOTSUPP;\n    }\n\n    nimble_reset_gatts_bss();\n\n    int ret = ble_gatts_reset();\n    if (ret != 0) {\n        return ble_hs_err_to_errno(ret);\n    }\n\n    \n    mp_bluetooth_gatts_db_reset(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db);\n\n    \n    ble_svc_gap_init();\n    ble_svc_gatt_init();\n\n    \n    for (size_t i = 0; i < MP_STATE_PORT(bluetooth_nimble_root_pointers)->n_services; ++i) {\n        MP_STATE_PORT(bluetooth_nimble_root_pointers)->services[i] = NULL;\n    }\n    MP_STATE_PORT(bluetooth_nimble_root_pointers)->n_services = 0;\n\n    return 0;\n}\n\nint mp_bluetooth_gatts_register_service_end(void) {\n    int ret = ble_gatts_start();\n    if (ret != 0) {\n        return ble_hs_err_to_errno(ret);\n    }\n\n    return 0;\n}\n\nint mp_bluetooth_gatts_register_service(mp_obj_bluetooth_uuid_t *service_uuid, mp_obj_bluetooth_uuid_t **characteristic_uuids, uint16_t *characteristic_flags, mp_obj_bluetooth_uuid_t **descriptor_uuids, uint16_t *descriptor_flags, uint8_t *num_descriptors, uint16_t *handles, size_t num_characteristics) {\n    if (MP_STATE_PORT(bluetooth_nimble_root_pointers)->n_services == MP_BLUETOOTH_NIMBLE_MAX_SERVICES) {\n        return MP_E2BIG;\n    }\n    size_t handle_index = 0;\n    size_t descriptor_index = 0;\n\n    struct ble_gatt_chr_def *characteristics = m_new(struct ble_gatt_chr_def, num_characteristics + 1);\n    for (size_t i = 0; i < num_characteristics; ++i) {\n        characteristics[i].uuid = create_nimble_uuid(characteristic_uuids[i], NULL);\n        characteristics[i].access_cb = characteristic_access_cb;\n        characteristics[i].arg = NULL;\n        \n        characteristics[i].flags = characteristic_flags[i];\n        characteristics[i].min_key_size = 0;\n        characteristics[i].val_handle = &handles[handle_index];\n        ++handle_index;\n\n        if (num_descriptors[i] == 0) {\n            characteristics[i].descriptors = NULL;\n        } else {\n            struct ble_gatt_dsc_def *descriptors = m_new(struct ble_gatt_dsc_def, num_descriptors[i] + 1);\n\n            for (size_t j = 0; j < num_descriptors[i]; ++j) {\n                descriptors[j].uuid = create_nimble_uuid(descriptor_uuids[descriptor_index], NULL);\n                descriptors[j].access_cb = characteristic_access_cb;\n                \n                uint8_t desc_att_flags = 0;\n                if (descriptor_flags[descriptor_index] & MP_BLUETOOTH_CHARACTERISTIC_FLAG_READ) {\n                    desc_att_flags |= BLE_ATT_F_READ;\n                }\n                if (descriptor_flags[descriptor_index] & (MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE | MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE_NO_RESPONSE)) {\n                    desc_att_flags |= BLE_ATT_F_WRITE;\n                }\n                descriptors[j].att_flags = desc_att_flags;\n                descriptors[j].min_key_size = 0;\n                \n                descriptors[j].arg = &handles[handle_index];\n                ++descriptor_index;\n                ++handle_index;\n            }\n            descriptors[num_descriptors[i]].uuid = NULL; \n\n            characteristics[i].descriptors = descriptors;\n        }\n    }\n    characteristics[num_characteristics].uuid = NULL; \n\n    struct ble_gatt_svc_def *service = m_new(struct ble_gatt_svc_def, 2);\n    service[0].type = BLE_GATT_SVC_TYPE_PRIMARY;\n    service[0].uuid = create_nimble_uuid(service_uuid, NULL);\n    service[0].includes = NULL;\n    service[0].characteristics = characteristics;\n    service[1].type = 0; \n\n    MP_STATE_PORT(bluetooth_nimble_root_pointers)->services[MP_STATE_PORT(bluetooth_nimble_root_pointers)->n_services++] = service;\n\n    \n\n    int ret = ble_gatts_count_cfg(service);\n    if (ret != 0) {\n        return ble_hs_err_to_errno(ret);\n    }\n\n    ret = ble_gatts_add_svcs(service);\n    if (ret != 0) {\n        return ble_hs_err_to_errno(ret);\n    }\n\n    return 0;\n}\n\nint mp_bluetooth_gap_disconnect(uint16_t conn_handle) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    return ble_hs_err_to_errno(ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM));\n}\n\nint mp_bluetooth_gatts_read(uint16_t value_handle, const uint8_t **value, size_t *value_len) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    return mp_bluetooth_gatts_db_read(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, value_handle, value, value_len);\n}\n\nint mp_bluetooth_gatts_write(uint16_t value_handle, const uint8_t *value, size_t value_len, bool send_update) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    int err = mp_bluetooth_gatts_db_write(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, value_handle, value, value_len);\n    if (err == 0 && send_update) {\n        ble_gatts_chr_updated(value_handle);\n    }\n    return err;\n}\n\nint mp_bluetooth_gatts_notify_indicate(uint16_t conn_handle, uint16_t value_handle, int gatts_op, const uint8_t *value, size_t value_len) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    int err = BLE_HS_EINVAL;\n\n    \n    \n    struct os_mbuf *om = NULL;\n\n    if (value) {\n        om = ble_hs_mbuf_from_flat(value, value_len);\n        if (om == NULL) {\n            return MP_ENOMEM;\n        }\n    }\n\n    \n    \n    \n\n    switch (gatts_op) {\n        case MP_BLUETOOTH_GATTS_OP_NOTIFY:\n            err = ble_gattc_notify_custom(conn_handle, value_handle, om);\n            break;\n        case MP_BLUETOOTH_GATTS_OP_INDICATE:\n            \n            \n            err = ble_gattc_indicate_custom(conn_handle, value_handle, om);\n            break;\n    }\n\n    return ble_hs_err_to_errno(err);\n}\n\nint mp_bluetooth_gatts_set_buffer(uint16_t value_handle, size_t len, bool append) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    return mp_bluetooth_gatts_db_resize(MP_STATE_PORT(bluetooth_nimble_root_pointers)->gatts_db, value_handle, len, append);\n}\n\nint mp_bluetooth_get_preferred_mtu(void) {\n    if (!mp_bluetooth_is_active()) {\n        mp_raise_OSError(ERRNO_BLUETOOTH_NOT_ACTIVE);\n    }\n    return ble_att_preferred_mtu();\n}\n\nint mp_bluetooth_set_preferred_mtu(uint16_t mtu) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    if (ble_att_set_preferred_mtu(mtu)) {\n        return MP_EINVAL;\n    }\n    return 0;\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nint mp_bluetooth_gap_pair(uint16_t conn_handle) {\n    DEBUG_printf(\"mp_bluetooth_gap_pair: conn_handle=%d\\n\", conn_handle);\n    return ble_hs_err_to_errno(ble_gap_security_initiate(conn_handle));\n}\n\nint mp_bluetooth_gap_passkey(uint16_t conn_handle, uint8_t action, mp_int_t passkey) {\n    struct ble_sm_io io = {0};\n\n    switch (action) {\n        case MP_BLUETOOTH_PASSKEY_ACTION_INPUT: {\n            io.passkey = passkey;\n            break;\n        }\n        case MP_BLUETOOTH_PASSKEY_ACTION_DISPLAY: {\n            io.passkey = passkey;\n            break;\n        }\n        case MP_BLUETOOTH_PASSKEY_ACTION_NUMERIC_COMPARISON: {\n            io.numcmp_accept = passkey != 0;\n            break;\n        }\n        default: {\n            return MP_EINVAL;\n        }\n    }\n\n    io.action = action;\n\n    DEBUG_printf(\"mp_bluetooth_gap_passkey: injecting IO: conn_handle=%d, action=%d, passkey=\" UINT_FMT \", numcmp_accept=%d\\n\", conn_handle, io.action, (mp_uint_t)io.passkey, io.numcmp_accept);\n    return ble_hs_err_to_errno(ble_sm_inject_io(conn_handle, &io));\n}\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n\nstatic int gap_scan_cb(struct ble_gap_event *event, void *arg) {\n    DEBUG_printf(\"gap_scan_cb: event=%d type=%d\\n\", event->type, event->type == BLE_GAP_EVENT_DISC ? event->disc.event_type : -1);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n\n    if (event->type == BLE_GAP_EVENT_DISC_COMPLETE) {\n        mp_bluetooth_gap_on_scan_complete();\n        return 0;\n    }\n\n    if (event->type != BLE_GAP_EVENT_DISC) {\n        return 0;\n    }\n\n    uint8_t addr[6];\n    reverse_addr_byte_order(addr, event->disc.addr.val);\n    mp_bluetooth_gap_on_scan_result(event->disc.addr.type, addr, event->disc.event_type, event->disc.rssi, event->disc.data, event->disc.length_data);\n\n    return 0;\n}\n\nint mp_bluetooth_gap_scan_start(int32_t duration_ms, int32_t interval_us, int32_t window_us, bool active_scan) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    if (duration_ms == 0) {\n        duration_ms = BLE_HS_FOREVER;\n    }\n    struct ble_gap_disc_params discover_params = {\n        .itvl = MAX(BLE_HCI_SCAN_ITVL_MIN, MIN(BLE_HCI_SCAN_ITVL_MAX, interval_us / BLE_HCI_SCAN_ITVL)),\n        .window = MAX(BLE_HCI_SCAN_WINDOW_MIN, MIN(BLE_HCI_SCAN_WINDOW_MAX, window_us / BLE_HCI_SCAN_ITVL)),\n        .filter_policy = BLE_HCI_CONN_FILT_NO_WL,\n        .limited = 0,\n        .passive = active_scan ? 0 : 1,\n        .filter_duplicates = 0,\n    };\n    int err = ble_gap_disc(nimble_address_mode, duration_ms, &discover_params, gap_scan_cb, NULL);\n    return ble_hs_err_to_errno(err);\n}\n\nint mp_bluetooth_gap_scan_stop(void) {\n    DEBUG_printf(\"mp_bluetooth_gap_scan_stop\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    if (!ble_gap_disc_active()) {\n        return 0;\n    }\n    int err = ble_gap_disc_cancel();\n    if (err == 0) {\n        mp_bluetooth_gap_on_scan_complete();\n        return 0;\n    }\n    return ble_hs_err_to_errno(err);\n}\n\n\nstatic int peripheral_gap_event_cb(struct ble_gap_event *event, void *arg) {\n    DEBUG_printf(\"peripheral_gap_event_cb: event=%d\\n\", event->type);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    struct ble_gap_conn_desc desc;\n    uint8_t addr[6] = {0};\n\n    switch (event->type) {\n        case BLE_GAP_EVENT_CONNECT:\n            DEBUG_printf(\"peripheral_gap_event_cb: status=%d\\n\", event->connect.status);\n            if (event->connect.status == 0) {\n                \n                ble_gap_conn_find(event->connect.conn_handle, &desc);\n                reverse_addr_byte_order(addr, desc.peer_id_addr.val);\n                mp_bluetooth_gap_on_connected_disconnected(MP_BLUETOOTH_IRQ_PERIPHERAL_CONNECT, event->connect.conn_handle, desc.peer_id_addr.type, addr);\n            } else {\n                \n                mp_bluetooth_gap_on_connected_disconnected(MP_BLUETOOTH_IRQ_PERIPHERAL_DISCONNECT, event->connect.conn_handle, 0xff, addr);\n            }\n            return 0;\n\n        case BLE_GAP_EVENT_DISCONNECT:\n            \n            DEBUG_printf(\"peripheral_gap_event_cb: reason=%d\\n\", event->disconnect.reason);\n            reverse_addr_byte_order(addr, event->disconnect.conn.peer_id_addr.val);\n            mp_bluetooth_gap_on_connected_disconnected(MP_BLUETOOTH_IRQ_PERIPHERAL_DISCONNECT, event->disconnect.conn.conn_handle, event->disconnect.conn.peer_id_addr.type, addr);\n            return 0;\n    }\n\n    return commmon_gap_event_cb(event, arg);\n}\n\nint mp_bluetooth_gap_peripheral_connect(uint8_t addr_type, const uint8_t *addr, int32_t duration_ms, int32_t min_conn_interval_us, int32_t max_conn_interval_us) {\n    DEBUG_printf(\"mp_bluetooth_gap_peripheral_connect\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    if (ble_gap_disc_active()) {\n        mp_bluetooth_gap_scan_stop();\n    }\n\n    uint16_t conn_interval_min = min_conn_interval_us ? min_conn_interval_us / BLE_HCI_CONN_ITVL : BLE_GAP_INITIAL_CONN_ITVL_MIN;\n    uint16_t conn_interval_max = max_conn_interval_us ? max_conn_interval_us / BLE_HCI_CONN_ITVL : BLE_GAP_INITIAL_CONN_ITVL_MAX;\n\n    const struct ble_gap_conn_params params = {\n        .scan_itvl = 0x0010,\n        .scan_window = 0x0010,\n        .itvl_min = conn_interval_min,\n        .itvl_max = conn_interval_max,\n        .latency = BLE_GAP_INITIAL_CONN_LATENCY,\n        .supervision_timeout = BLE_GAP_INITIAL_SUPERVISION_TIMEOUT,\n        .min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN,\n        .max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN,\n    };\n\n    ble_addr_t addr_nimble = create_nimble_addr(addr_type, addr);\n    int err = ble_gap_connect(nimble_address_mode, &addr_nimble, duration_ms, &params, &peripheral_gap_event_cb, NULL);\n    return ble_hs_err_to_errno(err);\n}\n\nint mp_bluetooth_gap_peripheral_connect_cancel(void) {\n    DEBUG_printf(\"mp_bluetooth_gap_peripheral_connect_cancel\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    int err = ble_gap_conn_cancel();\n    return ble_hs_err_to_errno(err);\n}\n\nstatic int ble_gattc_service_cb(uint16_t conn_handle, const struct ble_gatt_error *error, const struct ble_gatt_svc *service, void *arg) {\n    DEBUG_printf(\"ble_gattc_service_cb: conn_handle=%d status=%d start_handle=%d\\n\", conn_handle, error->status, service ? service->start_handle : -1);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    if (error->status == 0) {\n        mp_obj_bluetooth_uuid_t service_uuid = create_mp_uuid(&service->uuid);\n        mp_bluetooth_gattc_on_primary_service_result(conn_handle, service->start_handle, service->end_handle, &service_uuid);\n    } else {\n        mp_bluetooth_gattc_on_discover_complete(MP_BLUETOOTH_IRQ_GATTC_SERVICE_DONE, conn_handle, error->status == BLE_HS_EDONE ? 0 : error->status);\n    }\n    return 0;\n}\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n\nstatic void gattc_on_data_available(uint8_t event, uint16_t conn_handle, uint16_t value_handle, const struct os_mbuf *om) {\n    \n    \n    \n    \n    \n    \n\n    \n    size_t n = 0;\n    const struct os_mbuf *elem = om;\n    while (elem) {\n        n += 1;\n        elem = SLIST_NEXT(elem, om_next);\n    }\n\n    \n    const uint8_t **data = mp_local_alloc(sizeof(uint8_t *) * n);\n    uint16_t *data_len = mp_local_alloc(sizeof(uint16_t) * n);\n    for (size_t i = 0; i < n; ++i) {\n        data[i] = OS_MBUF_DATA(om, const uint8_t *);\n        data_len[i] = om->om_len;\n        om = SLIST_NEXT(om, om_next);\n    }\n\n    \n    mp_bluetooth_gattc_on_data_available(event, conn_handle, value_handle, data, data_len, n);\n\n    mp_local_free(data_len);\n    mp_local_free(data);\n}\n\nint mp_bluetooth_gattc_discover_primary_services(uint16_t conn_handle, const mp_obj_bluetooth_uuid_t *uuid) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    int err;\n    if (uuid) {\n        ble_uuid_any_t nimble_uuid;\n        create_nimble_uuid(uuid, &nimble_uuid);\n        err = ble_gattc_disc_svc_by_uuid(conn_handle, &nimble_uuid.u, &ble_gattc_service_cb, NULL);\n    } else {\n        err = ble_gattc_disc_all_svcs(conn_handle, &ble_gattc_service_cb, NULL);\n    }\n    return ble_hs_err_to_errno(err);\n}\n\nstatic bool match_char_uuid(const mp_obj_bluetooth_uuid_t *filter_uuid, const ble_uuid_any_t *result_uuid) {\n    if (!filter_uuid) {\n        return true;\n    }\n    ble_uuid_any_t filter_uuid_nimble;\n    create_nimble_uuid(filter_uuid, &filter_uuid_nimble);\n    return ble_uuid_cmp(&result_uuid->u, &filter_uuid_nimble.u) == 0;\n}\n\nstatic int ble_gattc_characteristic_cb(uint16_t conn_handle, const struct ble_gatt_error *error, const struct ble_gatt_chr *characteristic, void *arg) {\n    DEBUG_printf(\"ble_gattc_characteristic_cb: conn_handle=%d status=%d def_handle=%d val_handle=%d\\n\", conn_handle, error->status, characteristic ? characteristic->def_handle : -1, characteristic ? characteristic->val_handle : -1);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n\n    mp_bluetooth_nimble_pending_characteristic_t *pending = &MP_STATE_PORT(bluetooth_nimble_root_pointers)->pending_char_result;\n    if (pending->ready) {\n        \n        pending->ready = 0;\n\n        \n        \n        \n        uint16_t end_handle = MP_STATE_PORT(bluetooth_nimble_root_pointers)->char_disc_end_handle;\n        if (error->status == 0) {\n            end_handle = characteristic->def_handle - 1;\n        }\n\n        \n        mp_bluetooth_gattc_on_characteristic_result(conn_handle, pending->value_handle, end_handle, pending->properties, &pending->uuid);\n    }\n\n    if (error->status == 0) {\n        \n        if (match_char_uuid(MP_STATE_PORT(bluetooth_nimble_root_pointers)->char_filter_uuid, &characteristic->uuid)) {\n            pending->value_handle = characteristic->val_handle;\n            pending->properties = characteristic->properties;\n            pending->uuid = create_mp_uuid(&characteristic->uuid);\n            pending->ready = 1;\n        }\n    } else {\n        \n        MP_STATE_PORT(bluetooth_nimble_root_pointers)->char_disc_end_handle = 0;\n\n        \n        mp_bluetooth_gattc_on_discover_complete(MP_BLUETOOTH_IRQ_GATTC_CHARACTERISTIC_DONE, conn_handle, error->status == BLE_HS_EDONE ? 0 : error->status);\n    }\n    return 0;\n}\n\nint mp_bluetooth_gattc_discover_characteristics(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, const mp_obj_bluetooth_uuid_t *uuid) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    if (MP_STATE_PORT(bluetooth_nimble_root_pointers)->char_disc_end_handle) {\n        \n        \n        return MP_EBUSY;\n    }\n\n    \n    \n    MP_STATE_PORT(bluetooth_nimble_root_pointers)->char_filter_uuid = uuid;\n\n    int err = ble_gattc_disc_all_chrs(conn_handle, start_handle, end_handle, &ble_gattc_characteristic_cb, NULL);\n    if (!err) {\n        \n        MP_STATE_PORT(bluetooth_nimble_root_pointers)->char_disc_end_handle = end_handle;\n    }\n    return ble_hs_err_to_errno(err);\n}\n\nstatic int ble_gattc_descriptor_cb(uint16_t conn_handle, const struct ble_gatt_error *error, uint16_t characteristic_val_handle, const struct ble_gatt_dsc *descriptor, void *arg) {\n    DEBUG_printf(\"ble_gattc_descriptor_cb: conn_handle=%d status=%d chr_handle=%d dsc_handle=%d\\n\", conn_handle, error->status, characteristic_val_handle, descriptor ? descriptor->handle : -1);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    if (error->status == 0) {\n        mp_obj_bluetooth_uuid_t descriptor_uuid = create_mp_uuid(&descriptor->uuid);\n        mp_bluetooth_gattc_on_descriptor_result(conn_handle, descriptor->handle, &descriptor_uuid);\n    } else {\n        mp_bluetooth_gattc_on_discover_complete(MP_BLUETOOTH_IRQ_GATTC_DESCRIPTOR_DONE, conn_handle, error->status == BLE_HS_EDONE ? 0 : error->status);\n    }\n    return 0;\n}\n\nint mp_bluetooth_gattc_discover_descriptors(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    int err = ble_gattc_disc_all_dscs(conn_handle, start_handle, end_handle, &ble_gattc_descriptor_cb, NULL);\n    return ble_hs_err_to_errno(err);\n}\n\nstatic int ble_gattc_attr_read_cb(uint16_t conn_handle, const struct ble_gatt_error *error, struct ble_gatt_attr *attr, void *arg) {\n    uint16_t handle = attr ? attr->handle : (error ? error->att_handle : 0xffff);\n    DEBUG_printf(\"ble_gattc_attr_read_cb: conn_handle=%d status=%d handle=%d\\n\", conn_handle, error->status, handle);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    if (error->status == 0) {\n        gattc_on_data_available(MP_BLUETOOTH_IRQ_GATTC_READ_RESULT, conn_handle, attr->handle, attr->om);\n    }\n    mp_bluetooth_gattc_on_read_write_status(MP_BLUETOOTH_IRQ_GATTC_READ_DONE, conn_handle, handle, error->status);\n    return 0;\n}\n\n\nint mp_bluetooth_gattc_read(uint16_t conn_handle, uint16_t value_handle) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    int err = ble_gattc_read(conn_handle, value_handle, &ble_gattc_attr_read_cb, NULL);\n    return ble_hs_err_to_errno(err);\n}\n\nstatic int ble_gattc_attr_write_cb(uint16_t conn_handle, const struct ble_gatt_error *error, struct ble_gatt_attr *attr, void *arg) {\n    uint16_t handle = attr ? attr->handle : (error ? error->att_handle : 0xffff);\n    DEBUG_printf(\"ble_gattc_attr_write_cb: conn_handle=%d status=%d handle=%d\\n\", conn_handle, error->status, handle);\n    if (!mp_bluetooth_is_active()) {\n        return 0;\n    }\n    mp_bluetooth_gattc_on_read_write_status(MP_BLUETOOTH_IRQ_GATTC_WRITE_DONE, conn_handle, handle, error->status);\n    return 0;\n}\n\n\nint mp_bluetooth_gattc_write(uint16_t conn_handle, uint16_t value_handle, const uint8_t *value, size_t value_len, unsigned int mode) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    int err;\n    if (mode == MP_BLUETOOTH_WRITE_MODE_NO_RESPONSE) {\n        err = ble_gattc_write_no_rsp_flat(conn_handle, value_handle, value, value_len);\n    } else if (mode == MP_BLUETOOTH_WRITE_MODE_WITH_RESPONSE) {\n        err = ble_gattc_write_flat(conn_handle, value_handle, value, value_len, &ble_gattc_attr_write_cb, NULL);\n    } else {\n        err = BLE_HS_EINVAL;\n    }\n    return ble_hs_err_to_errno(err);\n}\n\nint mp_bluetooth_gattc_exchange_mtu(uint16_t conn_handle) {\n    DEBUG_printf(\"mp_bluetooth_exchange_mtu: conn_handle=%d mtu=%d\\n\", conn_handle, ble_att_preferred_mtu());\n\n    \n    return ble_hs_err_to_errno(ble_gattc_exchange_mtu(conn_handle, NULL, NULL));\n}\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\nstatic void unstall_l2cap_channel(void);\n#endif\n\nvoid mp_bluetooth_nimble_sent_hci_packet(void) {\n    #if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\n    if (os_msys_num_free() >= os_msys_count() * 3 / 4) {\n        unstall_l2cap_channel();\n    }\n    #endif\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\n\n\n\n\n\n#define L2CAP_BUF_BLOCK_SIZE (128)\n\n\n\n\n\n\n#define L2CAP_BUF_SIZE_MTUS_PER_CHANNEL (3)\n\ntypedef struct _mp_bluetooth_nimble_l2cap_channel_t {\n    struct ble_l2cap_chan *chan;\n    struct os_mbuf_pool sdu_mbuf_pool;\n    struct os_mempool sdu_mempool;\n    struct os_mbuf *rx_pending;\n    bool irq_in_progress;\n    bool mem_stalled;\n    uint16_t mtu;\n    os_membuf_t sdu_mem[];\n} mp_bluetooth_nimble_l2cap_channel_t;\n\nstatic void destroy_l2cap_channel();\nstatic int l2cap_channel_event(struct ble_l2cap_event *event, void *arg);\nstatic mp_bluetooth_nimble_l2cap_channel_t *get_l2cap_channel_for_conn_cid(uint16_t conn_handle, uint16_t cid);\nstatic int create_l2cap_channel(uint16_t mtu, mp_bluetooth_nimble_l2cap_channel_t **out);\n\nstatic void destroy_l2cap_channel() {\n    \n    \n    if (!MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_listening) {\n        MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_chan = NULL;\n    }\n}\n\nstatic void unstall_l2cap_channel(void) {\n    \n    \n    \n    mp_bluetooth_nimble_l2cap_channel_t *chan = MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_chan;\n    if (!chan || !chan->mem_stalled) {\n        return;\n    }\n    DEBUG_printf(\"unstall_l2cap_channel: count %d, free: %d\\n\", os_msys_count(), os_msys_num_free());\n    chan->mem_stalled = false;\n    mp_bluetooth_on_l2cap_send_ready(chan->chan->conn_handle, chan->chan->scid, 0);\n}\n\nstatic int l2cap_channel_event(struct ble_l2cap_event *event, void *arg) {\n    DEBUG_printf(\"l2cap_channel_event: type=%d\\n\", event->type);\n    mp_bluetooth_nimble_l2cap_channel_t *chan = (mp_bluetooth_nimble_l2cap_channel_t *)arg;\n    struct ble_l2cap_chan_info info;\n\n    switch (event->type) {\n        case BLE_L2CAP_EVENT_COC_CONNECTED: {\n            DEBUG_printf(\"l2cap_channel_event: connect: conn_handle=%d status=%d\\n\", event->connect.conn_handle, event->connect.status);\n            chan->chan = event->connect.chan;\n\n            ble_l2cap_get_chan_info(event->connect.chan, &info);\n            if (event->connect.status == 0) {\n                mp_bluetooth_on_l2cap_connect(event->connect.conn_handle, info.scid, info.psm, info.our_coc_mtu, info.peer_coc_mtu);\n            } else {\n                mp_bluetooth_on_l2cap_disconnect(event->connect.conn_handle, info.scid, info.psm, event->connect.status);\n                destroy_l2cap_channel();\n            }\n            break;\n        }\n        case BLE_L2CAP_EVENT_COC_DISCONNECTED: {\n            DEBUG_printf(\"l2cap_channel_event: disconnect: conn_handle=%d\\n\", event->disconnect.conn_handle);\n            ble_l2cap_get_chan_info(event->disconnect.chan, &info);\n            mp_bluetooth_on_l2cap_disconnect(event->disconnect.conn_handle, info.scid, info.psm, 0);\n            destroy_l2cap_channel();\n            break;\n        }\n        case BLE_L2CAP_EVENT_COC_ACCEPT: {\n            DEBUG_printf(\"l2cap_channel_event: accept: conn_handle=%d peer_sdu_size=%d\\n\", event->accept.conn_handle, event->accept.peer_sdu_size);\n            chan->chan = event->accept.chan;\n            ble_l2cap_get_chan_info(event->accept.chan, &info);\n            int ret = mp_bluetooth_on_l2cap_accept(event->accept.conn_handle, info.scid, info.psm, info.our_coc_mtu, info.peer_coc_mtu);\n            if (ret != 0) {\n                return ret;\n            }\n            struct os_mbuf *sdu_rx = os_mbuf_get_pkthdr(&chan->sdu_mbuf_pool, 0);\n            assert(sdu_rx);\n            return ble_l2cap_recv_ready(chan->chan, sdu_rx);\n        }\n        case BLE_L2CAP_EVENT_COC_DATA_RECEIVED: {\n            DEBUG_printf(\"l2cap_channel_event: receive: conn_handle=%d len=%d\\n\", event->receive.conn_handle, OS_MBUF_PKTLEN(event->receive.sdu_rx));\n\n            if (chan->rx_pending) {\n                \n                \n                \n                \n                \n                DEBUG_printf(\"l2cap_channel_event: receive: appending to rx pending\\n\");\n                \n                \n                os_mbuf_concat(chan->rx_pending, event->receive.sdu_rx);\n            } else {\n                \n                \n                DEBUG_printf(\"l2cap_event: receive: new payload\\n\");\n                \n                chan->rx_pending = event->receive.sdu_rx;\n            }\n\n            struct os_mbuf *sdu_rx = os_mbuf_get_pkthdr(&chan->sdu_mbuf_pool, 0);\n            assert(sdu_rx);\n\n            \n            \n            \n            \n            \n\n            \n            \n            \n            chan->chan->coc_rx.sdu = sdu_rx;\n\n            ble_l2cap_get_chan_info(event->receive.chan, &info);\n\n            \n            chan->irq_in_progress = true;\n\n            mp_bluetooth_on_l2cap_recv(event->receive.conn_handle, info.scid);\n            chan->irq_in_progress = false;\n\n            \n            \n            \n            if (!chan->rx_pending) {\n                struct os_mbuf *sdu_rx = chan->chan->coc_rx.sdu;\n                assert(sdu_rx);\n                if (sdu_rx) {\n                    ble_l2cap_recv_ready(chan->chan, sdu_rx);\n                }\n            }\n            break;\n        }\n        case BLE_L2CAP_EVENT_COC_TX_UNSTALLED: {\n            DEBUG_printf(\"l2cap_channel_event: tx_unstalled: conn_handle=%d status=%d\\n\", event->tx_unstalled.conn_handle, event->tx_unstalled.status);\n            assert(event->tx_unstalled.conn_handle == chan->chan->conn_handle);\n            \n            if (!chan->mem_stalled) {\n                ble_l2cap_get_chan_info(event->receive.chan, &info);\n                \n                mp_bluetooth_on_l2cap_send_ready(event->tx_unstalled.conn_handle, info.scid, event->tx_unstalled.status == 0 ? 0 : 1);\n            }\n            break;\n        }\n        case BLE_L2CAP_EVENT_COC_RECONFIG_COMPLETED: {\n            DEBUG_printf(\"l2cap_channel_event: reconfig_completed: conn_handle=%d\\n\", event->reconfigured.conn_handle);\n            break;\n        }\n        case BLE_L2CAP_EVENT_COC_PEER_RECONFIGURED: {\n            DEBUG_printf(\"l2cap_channel_event: peer_reconfigured: conn_handle=%d\\n\", event->reconfigured.conn_handle);\n            break;\n        }\n        default: {\n            DEBUG_printf(\"l2cap_channel_event: unknown event\\n\");\n            break;\n        }\n    }\n\n    return 0;\n}\n\nstatic mp_bluetooth_nimble_l2cap_channel_t *get_l2cap_channel_for_conn_cid(uint16_t conn_handle, uint16_t cid) {\n    \n    \n    mp_bluetooth_nimble_l2cap_channel_t *chan = MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_chan;\n\n    if (!chan) {\n        return NULL;\n    }\n\n    struct ble_l2cap_chan_info info;\n    ble_l2cap_get_chan_info(chan->chan, &info);\n\n    if (info.scid != cid || ble_l2cap_get_conn_handle(chan->chan) != conn_handle) {\n        return NULL;\n    }\n\n    return chan;\n}\n\nstatic int create_l2cap_channel(uint16_t mtu, mp_bluetooth_nimble_l2cap_channel_t **out) {\n    if (MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_chan) {\n        \n        \n        DEBUG_printf(\"create_l2cap_channel: channel already in use\\n\");\n        return MP_EALREADY;\n    }\n\n    \n    \n    \n    const size_t buf_blocks = MP_CEIL_DIVIDE(mtu, L2CAP_BUF_BLOCK_SIZE) * L2CAP_BUF_SIZE_MTUS_PER_CHANNEL;\n\n    mp_bluetooth_nimble_l2cap_channel_t *chan = m_new_obj_var(mp_bluetooth_nimble_l2cap_channel_t, sdu_mem, uint8_t, OS_MEMPOOL_SIZE(buf_blocks, L2CAP_BUF_BLOCK_SIZE) * sizeof(os_membuf_t));\n    MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_chan = chan;\n\n    \n    chan->chan = NULL;\n\n    chan->mtu = mtu;\n    chan->rx_pending = NULL;\n    chan->irq_in_progress = false;\n\n    int err = os_mempool_init(&chan->sdu_mempool, buf_blocks, L2CAP_BUF_BLOCK_SIZE, chan->sdu_mem, \"l2cap_sdu_pool\");\n    if (err != 0) {\n        DEBUG_printf(\"mp_bluetooth_l2cap_connect: os_mempool_init failed %d\\n\", err);\n        return MP_ENOMEM;\n    }\n\n    err = os_mbuf_pool_init(&chan->sdu_mbuf_pool, &chan->sdu_mempool, L2CAP_BUF_BLOCK_SIZE, buf_blocks);\n    if (err != 0) {\n        DEBUG_printf(\"mp_bluetooth_l2cap_connect: os_mbuf_pool_init failed %d\\n\", err);\n        return MP_ENOMEM;\n    }\n\n    *out = chan;\n    return 0;\n}\n\nint mp_bluetooth_l2cap_listen(uint16_t psm, uint16_t mtu) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_listen: psm=%d, mtu=%d\\n\", psm, mtu);\n\n    mp_bluetooth_nimble_l2cap_channel_t *chan;\n    int err = create_l2cap_channel(mtu, &chan);\n    if (err != 0) {\n        return err;\n    }\n\n    MP_STATE_PORT(bluetooth_nimble_root_pointers)->l2cap_listening = true;\n\n    return ble_hs_err_to_errno(ble_l2cap_create_server(psm, mtu, &l2cap_channel_event, chan));\n}\n\nint mp_bluetooth_l2cap_connect(uint16_t conn_handle, uint16_t psm, uint16_t mtu) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_connect: conn_handle=%d, psm=%d, mtu=%d\\n\", conn_handle, psm, mtu);\n\n    mp_bluetooth_nimble_l2cap_channel_t *chan;\n    int err = create_l2cap_channel(mtu, &chan);\n    if (err != 0) {\n        return err;\n    }\n\n    struct os_mbuf *sdu_rx = os_mbuf_get_pkthdr(&chan->sdu_mbuf_pool, 0);\n    assert(sdu_rx);\n    return ble_hs_err_to_errno(ble_l2cap_connect(conn_handle, psm, mtu, sdu_rx, &l2cap_channel_event, chan));\n}\n\nint mp_bluetooth_l2cap_disconnect(uint16_t conn_handle, uint16_t cid) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_disconnect: conn_handle=%d, cid=%d\\n\", conn_handle, cid);\n    mp_bluetooth_nimble_l2cap_channel_t *chan = get_l2cap_channel_for_conn_cid(conn_handle, cid);\n    if (!chan) {\n        return MP_EINVAL;\n    }\n    return ble_hs_err_to_errno(ble_l2cap_disconnect(chan->chan));\n}\n\nint mp_bluetooth_l2cap_send(uint16_t conn_handle, uint16_t cid, const uint8_t *buf, size_t len, bool *stalled) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_send: conn_handle=%d, cid=%d, len=%d\\n\", conn_handle, cid, (int)len);\n\n    mp_bluetooth_nimble_l2cap_channel_t *chan = get_l2cap_channel_for_conn_cid(conn_handle, cid);\n    if (!chan) {\n        return MP_EINVAL;\n    }\n\n    struct ble_l2cap_chan_info info;\n    ble_l2cap_get_chan_info(chan->chan, &info);\n    if (len > info.peer_coc_mtu) {\n        \n        \n        return MP_EINVAL;\n    }\n\n    if (len > (L2CAP_BUF_SIZE_MTUS_PER_CHANNEL - 1) * info.our_coc_mtu) {\n        \n        \n        return MP_EINVAL;\n    }\n\n    \n    struct os_mbuf *sdu_tx = os_mbuf_get_pkthdr(&chan->sdu_mbuf_pool, 0);\n    if (sdu_tx == NULL) {\n        return MP_ENOMEM;\n    }\n    int err = os_mbuf_append(sdu_tx, buf, len);\n    if (err) {\n        os_mbuf_free_chain(sdu_tx);\n        return MP_ENOMEM;\n    }\n\n    *stalled = false;\n\n    err = ble_l2cap_send(chan->chan, sdu_tx);\n    if (err == BLE_HS_ESTALLED) {\n        \n        \n        DEBUG_printf(\"mp_bluetooth_l2cap_send: credit stall\\n\");\n        *stalled = true;\n        err = 0;\n    } else {\n        if (err) {\n            \n            \n            os_mbuf_free_chain(sdu_tx);\n        }\n    }\n\n    if (os_msys_num_free() <= os_msys_count() / 2) {\n        \n        \n        DEBUG_printf(\"mp_bluetooth_l2cap_send: forcing mem stall: count %d, free: %d\\n\", os_msys_count(), os_msys_num_free());\n        chan->mem_stalled = true;\n        *stalled = true;\n    }\n\n    \n    return ble_hs_err_to_errno(err);\n}\n\nint mp_bluetooth_l2cap_recvinto(uint16_t conn_handle, uint16_t cid, uint8_t *buf, size_t *len) {\n    mp_bluetooth_nimble_l2cap_channel_t *chan = get_l2cap_channel_for_conn_cid(conn_handle, cid);\n    if (!chan) {\n        return MP_EINVAL;\n    }\n\n    MICROPY_PY_BLUETOOTH_ENTER\n    if (chan->rx_pending) {\n        size_t avail = OS_MBUF_PKTLEN(chan->rx_pending);\n\n        if (buf == NULL) {\n            \n            *len = avail;\n        } else {\n            \n            \n            *len = min(*len, avail);\n\n            \n            os_mbuf_copydata(chan->rx_pending, 0, *len, buf);\n\n            if (*len == avail) {\n                \n                os_mbuf_free_chain(chan->rx_pending);\n                chan->rx_pending = NULL;\n\n                \n                \n                if (!chan->irq_in_progress) {\n                    \n                    \n                    \n                    struct os_mbuf *sdu_rx = chan->chan->coc_rx.sdu;\n                    assert(sdu_rx);\n                    if (sdu_rx) {\n                        ble_l2cap_recv_ready(chan->chan, sdu_rx);\n                    }\n                }\n            } else {\n                \n                \n                os_mbuf_adj(chan->rx_pending, *len);\n                \n                chan->rx_pending = os_mbuf_trim_front(chan->rx_pending);\n            }\n        }\n    } else {\n        \n        *len = 0;\n    }\n\n    MICROPY_PY_BLUETOOTH_EXIT\n    return 0;\n}\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_HCI_CMD\n\nint mp_bluetooth_hci_cmd(uint16_t ogf, uint16_t ocf, const uint8_t *req, size_t req_len, uint8_t *resp, size_t resp_len, uint8_t *status) {\n    int rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(ogf, ocf), req, req_len, resp, resp_len);\n    if (rc < BLE_HS_ERR_HCI_BASE || rc >= BLE_HS_ERR_HCI_BASE + 0x100) {\n        \n        return ble_hs_err_to_errno(rc);\n    } else {\n        \n        *status = rc - BLE_HS_ERR_HCI_BASE;\n        return 0;\n    }\n}\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n\nstatic int ble_secret_store_read(int obj_type, const union ble_store_key *key, union ble_store_value *value) {\n    DEBUG_printf(\"ble_secret_store_read: %d\\n\", obj_type);\n    const uint8_t *key_data;\n    size_t key_data_len;\n\n    switch (obj_type) {\n        case BLE_STORE_OBJ_TYPE_PEER_SEC: {\n            if (ble_addr_cmp(&key->sec.peer_addr, BLE_ADDR_ANY)) {\n                \n                \n                assert(key->sec.idx == 0);\n                assert(!key->sec.ediv_rand_present);\n                key_data = (const uint8_t *)&key->sec.peer_addr;\n                key_data_len = sizeof(ble_addr_t);\n            } else {\n                \n                \n                assert(!key->sec.ediv_rand_present);\n                key_data = NULL;\n                key_data_len = 0;\n            }\n            break;\n        }\n        case BLE_STORE_OBJ_TYPE_OUR_SEC: {\n            \n            \n            assert(ble_addr_cmp(&key->sec.peer_addr, BLE_ADDR_ANY)); \n            assert(key->sec.idx == 0);\n            assert(key->sec.ediv_rand_present);\n            key_data = (const uint8_t *)&key->sec.peer_addr;\n            key_data_len = sizeof(ble_addr_t);\n            break;\n        }\n        case BLE_STORE_OBJ_TYPE_CCCD: {\n            \n            DEBUG_printf(\"ble_secret_store_read: CCCD not supported.\\n\");\n            return -1;\n        }\n        default:\n            return BLE_HS_ENOTSUP;\n    }\n\n    const uint8_t *value_data;\n    size_t value_data_len;\n    if (!mp_bluetooth_gap_on_get_secret(obj_type, key->sec.idx, key_data, key_data_len, &value_data, &value_data_len)) {\n        DEBUG_printf(\"ble_secret_store_read: Key not found: type=%d, index=%u, key=0x%p, len=\" UINT_FMT \"\\n\", obj_type, key->sec.idx, key_data, key_data_len);\n        return BLE_HS_ENOENT;\n    }\n\n    if (value_data_len != sizeof(struct ble_store_value_sec)) {\n        DEBUG_printf(\"ble_secret_store_read: Invalid key data: actual=\" UINT_FMT \" expected=\" UINT_FMT \"\\n\", value_data_len, sizeof(struct ble_store_value_sec));\n        return BLE_HS_ENOENT;\n    }\n\n    memcpy((uint8_t *)&value->sec, value_data, sizeof(struct ble_store_value_sec));\n\n    DEBUG_printf(\"ble_secret_store_read: found secret\\n\");\n\n    if (obj_type == BLE_STORE_OBJ_TYPE_OUR_SEC) {\n        \n    }\n\n    return 0;\n}\n\nstatic int ble_secret_store_write(int obj_type, const union ble_store_value *val) {\n    DEBUG_printf(\"ble_secret_store_write: %d\\n\", obj_type);\n    switch (obj_type) {\n        case BLE_STORE_OBJ_TYPE_PEER_SEC:\n        case BLE_STORE_OBJ_TYPE_OUR_SEC: {\n            \n\n            struct ble_store_key_sec key_sec;\n            const struct ble_store_value_sec *value_sec = &val->sec;\n            ble_store_key_from_value_sec(&key_sec, value_sec);\n\n            assert(ble_addr_cmp(&key_sec.peer_addr, BLE_ADDR_ANY)); \n            assert(key_sec.ediv_rand_present);\n\n            if (!mp_bluetooth_gap_on_set_secret(obj_type, (const uint8_t *)&key_sec.peer_addr, sizeof(ble_addr_t), (const uint8_t *)value_sec, sizeof(struct ble_store_value_sec))) {\n                DEBUG_printf(\"Failed to write key: type=%d\\n\", obj_type);\n                return BLE_HS_ESTORE_CAP;\n            }\n\n            DEBUG_printf(\"ble_secret_store_write: wrote secret\\n\");\n\n            return 0;\n        }\n        case BLE_STORE_OBJ_TYPE_CCCD: {\n            \n            DEBUG_printf(\"ble_secret_store_write: CCCD not supported.\\n\");\n            \n            return 0;\n        }\n        default:\n            return BLE_HS_ENOTSUP;\n    }\n}\n\nstatic int ble_secret_store_delete(int obj_type, const union ble_store_key *key) {\n    DEBUG_printf(\"ble_secret_store_delete: %d\\n\", obj_type);\n    switch (obj_type) {\n        case BLE_STORE_OBJ_TYPE_PEER_SEC:\n        case BLE_STORE_OBJ_TYPE_OUR_SEC: {\n            \n\n            assert(ble_addr_cmp(&key->sec.peer_addr, BLE_ADDR_ANY)); \n            \n\n            if (!mp_bluetooth_gap_on_set_secret(obj_type, (const uint8_t *)&key->sec.peer_addr, sizeof(ble_addr_t), NULL, 0)) {\n                DEBUG_printf(\"Failed to delete key: type=%d\\n\", obj_type);\n                return BLE_HS_ENOENT;\n            }\n\n            DEBUG_printf(\"ble_secret_store_delete: deleted secret\\n\");\n\n            return 0;\n        }\n        case BLE_STORE_OBJ_TYPE_CCCD: {\n            \n            DEBUG_printf(\"ble_secret_store_delete: CCCD not supported.\\n\");\n            \n            return BLE_HS_ENOENT;\n        }\n        default:\n            return BLE_HS_ENOTSUP;\n    }\n}\n\n#endif \n\n#if !MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY\nMP_REGISTER_ROOT_POINTER(struct _mp_bluetooth_nimble_malloc_t *bluetooth_nimble_memory);\n#endif\nMP_REGISTER_ROOT_POINTER(struct _mp_bluetooth_nimble_root_pointers_t *bluetooth_nimble_root_pointers);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}