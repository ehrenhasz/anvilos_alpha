{
  "module_name": "nimble.mk",
  "hash_id": "995d6e352e3b1e035d7f5529dff13ec823d22355fc1159b4655269fe9a27bcdb",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/nimble/nimble.mk",
  "human_readable_source": "# Makefile directives for Apache Mynewt NimBLE component\n\nifeq ($(MICROPY_BLUETOOTH_NIMBLE),1)\n\nEXTMOD_DIR = extmod\nNIMBLE_EXTMOD_DIR = $(EXTMOD_DIR)/nimble\n\nSRC_EXTMOD_C += $(NIMBLE_EXTMOD_DIR)/modbluetooth_nimble.c\n\nCFLAGS_EXTMOD += -DMICROPY_BLUETOOTH_NIMBLE=1\n\n# Use NimBLE from the submodule in lib/mynewt-nimble by default,\n# allowing a port to use their own system version (e.g. ESP32).\nMICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY ?= 0\n\nCFLAGS_EXTMOD += -DMICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY=$(MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY)\n\nifeq ($(MICROPY_BLUETOOTH_NIMBLE_BINDINGS_ONLY),0)\n\nGIT_SUBMODULES += lib/mynewt-nimble\n\n# On all ports where we provide the full implementation (i.e. not just\n# bindings like on ESP32), then we don't need to use the ringbuffer. In this\n# case, all NimBLE events are run by the MicroPython scheduler. On Unix, the\n# scheduler is also responsible for polling the UART, whereas on STM32 the\n# UART is also polled by the RX IRQ.\nCFLAGS_EXTMOD += -DMICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS=1\n\n# Without the ringbuffer, and with the full implementation, we can also\n# enable pairing and bonding. This requires both synchronous events and\n# some customisation of the key store.\nCFLAGS_EXTMOD += -DMICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING=1\n\nNIMBLE_LIB_DIR = lib/mynewt-nimble\n\nSRC_THIRDPARTY_C += $(addprefix $(NIMBLE_LIB_DIR)/, \\\n\t$(addprefix ext/tinycrypt/src/, \\\n\t\taes_encrypt.c \\\n\t\tcmac_mode.c \\\n\t\tecc.c \\\n\t\tecc_dh.c \\\n\t\tutils.c \\\n\t\t) \\\n\tnimble/host/services/gap/src/ble_svc_gap.c \\\n\tnimble/host/services/gatt/src/ble_svc_gatt.c \\\n\t$(addprefix nimble/host/src/, \\\n\t\tble_att.c \\\n\t\tble_att_clt.c \\\n\t\tble_att_cmd.c \\\n\t\tble_att_svr.c \\\n\t\tble_eddystone.c \\\n\t\tble_gap.c \\\n\t\tble_gattc.c \\\n\t\tble_gatts.c \\\n\t\tble_hs_adv.c \\\n\t\tble_hs_atomic.c \\\n\t\tble_hs.c \\\n\t\tble_hs_cfg.c \\\n\t\tble_hs_conn.c \\\n\t\tble_hs_flow.c \\\n\t\tble_hs_hci.c \\\n\t\tble_hs_hci_cmd.c \\\n\t\tble_hs_hci_evt.c \\\n\t\tble_hs_hci_util.c \\\n\t\tble_hs_id.c \\\n\t\tble_hs_log.c \\\n\t\tble_hs_mbuf.c \\\n\t\tble_hs_misc.c \\\n\t\tble_hs_mqueue.c \\\n\t\tble_hs_pvcy.c \\\n\t\tble_hs_startup.c \\\n\t\tble_hs_stop.c \\\n\t\tble_ibeacon.c \\\n\t\tble_l2cap.c \\\n\t\tble_l2cap_coc.c \\\n\t\tble_l2cap_sig.c \\\n\t\tble_l2cap_sig_cmd.c \\\n\t\tble_monitor.c \\\n\t\tble_sm_alg.c \\\n\t\tble_sm.c \\\n\t\tble_sm_cmd.c \\\n\t\tble_sm_lgcy.c \\\n\t\tble_sm_sc.c \\\n\t\tble_store.c \\\n\t\tble_store_util.c \\\n\t\tble_uuid.c \\\n\t\t) \\\n\tnimble/host/util/src/addr.c \\\n\tnimble/transport/uart/src/ble_hci_uart.c \\\n\t$(addprefix porting/nimble/src/, \\\n\t\tendian.c \\\n\t\tmem.c \\\n\t\tnimble_port.c \\\n\t\tos_mbuf.c \\\n\t\tos_mempool.c \\\n\t\tos_msys_init.c \\\n\t\t) \\\n\t)\n\t# nimble/host/store/ram/src/ble_store_ram.c \\\n\nSRC_THIRDPARTY_C += $(addprefix $(NIMBLE_EXTMOD_DIR)/, \\\n\tnimble/nimble_npl_os.c \\\n\thal/hal_uart.c \\\n\t)\n\nINC += -I$(TOP)/$(NIMBLE_EXTMOD_DIR)\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/ext/tinycrypt/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/host/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/host/services/gap/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/host/services/gatt/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/host/store/ram/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/host/util/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/nimble/transport/uart/include\nINC += -I$(TOP)/$(NIMBLE_LIB_DIR)/porting/nimble/include\n\n$(BUILD)/$(NIMBLE_LIB_DIR)/%.o: CFLAGS += -Wno-maybe-uninitialized -Wno-pointer-arith -Wno-unused-but-set-variable -Wno-format -Wno-sign-compare -Wno-old-style-declaration\n\nendif\n\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}