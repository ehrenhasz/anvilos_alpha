{
  "module_name": "modbluetooth_btstack.c",
  "hash_id": "58b7da897cadb26989e2e4b78225f00a88eef10e2f014f28f99aa5760b41227b",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/btstack/modbluetooth_btstack.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_BLUETOOTH && MICROPY_BLUETOOTH_BTSTACK\n\n#include \"extmod/btstack/modbluetooth_btstack.h\"\n#include \"extmod/modbluetooth.h\"\n\n#include \"lib/btstack/src/btstack.h\"\n\n#define DEBUG_printf(...) \n\n#ifndef MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME\n#define MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME \"MPY BTSTACK\"\n#endif\n\n\n\nstatic const uint32_t BTSTACK_INIT_DEINIT_TIMEOUT_MS = 15000;\n\n\n\n\n\nstatic const uint16_t BTSTACK_GAP_DEVICE_NAME_HANDLE = 3;\n\nvolatile int mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_OFF;\n\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nstatic uint8_t mp_bluetooth_btstack_sm_auth_req = 0;\n#endif\n\n#define ERRNO_BLUETOOTH_NOT_ACTIVE MP_ENODEV\n\nstatic int btstack_error_to_errno(int err) {\n    DEBUG_printf(\"  --> btstack error: %d\\n\", err);\n    if (err == ERROR_CODE_SUCCESS) {\n        return 0;\n    } else if (err == BTSTACK_ACL_BUFFERS_FULL || err == BTSTACK_MEMORY_ALLOC_FAILED) {\n        return MP_ENOMEM;\n    } else if (err == GATT_CLIENT_IN_WRONG_STATE) {\n        return MP_EALREADY;\n    } else if (err == GATT_CLIENT_BUSY) {\n        return MP_EBUSY;\n    } else if (err == GATT_CLIENT_NOT_CONNECTED) {\n        return MP_ENOTCONN;\n    } else {\n        return MP_EINVAL;\n    }\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nstatic mp_obj_bluetooth_uuid_t create_mp_uuid(uint16_t uuid16, const uint8_t *uuid128) {\n    mp_obj_bluetooth_uuid_t result;\n    result.base.type = &mp_type_bluetooth_uuid;\n    if (uuid16 != 0) {\n        result.data[0] = uuid16 & 0xff;\n        result.data[1] = (uuid16 >> 8) & 0xff;\n        result.type = MP_BLUETOOTH_UUID_TYPE_16;\n    } else {\n        reverse_128(uuid128, result.data);\n        result.type = MP_BLUETOOTH_UUID_TYPE_128;\n    }\n    return result;\n}\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\ntypedef struct _mp_btstack_active_connection_t {\n    btstack_linked_item_t *next; \n\n    uint16_t conn_handle;\n\n    \n    uint16_t pending_value_handle;\n\n    \n    uint8_t *pending_write_value;\n    size_t pending_write_value_len;\n} mp_btstack_active_connection_t;\n\nstatic mp_btstack_active_connection_t *create_active_connection(uint16_t conn_handle) {\n    DEBUG_printf(\"create_active_connection: conn_handle=%d\\n\", conn_handle);\n    mp_btstack_active_connection_t *conn = m_new(mp_btstack_active_connection_t, 1);\n    conn->conn_handle = conn_handle;\n    conn->pending_value_handle = 0xffff;\n    conn->pending_write_value = NULL;\n    conn->pending_write_value_len = 0;\n    bool added = btstack_linked_list_add(&MP_STATE_PORT(bluetooth_btstack_root_pointers)->active_connections, (btstack_linked_item_t *)conn);\n    (void)added;\n    assert(added);\n    return conn;\n}\n\nstatic mp_btstack_active_connection_t *find_active_connection(uint16_t conn_handle) {\n    DEBUG_printf(\"find_active_connection: conn_handle=%d\\n\", conn_handle);\n    btstack_linked_list_iterator_t it;\n    btstack_linked_list_iterator_init(&it, &MP_STATE_PORT(bluetooth_btstack_root_pointers)->active_connections);\n    mp_btstack_active_connection_t *conn = NULL;\n    while (btstack_linked_list_iterator_has_next(&it)) {\n        conn = (mp_btstack_active_connection_t *)btstack_linked_list_iterator_next(&it);\n        DEBUG_printf(\"  --> iter conn %d\\n\", conn->conn_handle);\n        if (conn->conn_handle == conn_handle) {\n            break;\n        }\n    }\n    return conn;\n}\n\nstatic void remove_active_connection(uint16_t conn_handle) {\n    DEBUG_printf(\"remove_active_connection: conn_handle=%d\\n\", conn_handle);\n    mp_btstack_active_connection_t *conn = find_active_connection(conn_handle);\n    if (conn) {\n        bool removed = btstack_linked_list_remove(&MP_STATE_PORT(bluetooth_btstack_root_pointers)->active_connections, (btstack_linked_item_t *)conn);\n        (void)removed;\n        assert(removed);\n        m_del(mp_btstack_active_connection_t, conn, 1);\n    }\n}\n#endif\n\n\n\nstatic void btstack_packet_handler_att_server(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    DEBUG_printf(\"btstack_packet_handler_att_server(packet_type=%u, packet=%p)\\n\", packet_type, packet);\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n\n    uint8_t event_type = hci_event_packet_get_type(packet);\n\n    if (event_type == ATT_EVENT_CONNECTED) {\n        DEBUG_printf(\"  --> att connected\\n\");\n        \n        \n    } else if (event_type == ATT_EVENT_DISCONNECTED) {\n        DEBUG_printf(\"  --> att disconnected\\n\");\n    } else if (event_type == ATT_EVENT_HANDLE_VALUE_INDICATION_COMPLETE) {\n        DEBUG_printf(\"  --> att indication complete\\n\");\n        uint16_t conn_handle = att_event_handle_value_indication_complete_get_conn_handle(packet);\n        uint16_t value_handle = att_event_handle_value_indication_complete_get_attribute_handle(packet);\n        uint8_t status = att_event_handle_value_indication_complete_get_status(packet);\n        mp_bluetooth_gatts_on_indicate_complete(conn_handle, value_handle, status);\n    } else if (event_type == ATT_EVENT_MTU_EXCHANGE_COMPLETE) {\n        DEBUG_printf(\"  --> att mtu exchange complete\\n\");\n        \n        uint16_t conn_handle = att_event_mtu_exchange_complete_get_handle(packet);\n        uint16_t mtu = att_event_mtu_exchange_complete_get_MTU(packet);\n        mp_bluetooth_gatts_on_mtu_exchanged(conn_handle, mtu);\n    } else if (event_type == HCI_EVENT_LE_META || event_type == HCI_EVENT_DISCONNECTION_COMPLETE) {\n        \n        DEBUG_printf(\"  --> hci att server event type: le_meta/disconnection (0x%02x)\\n\", event_type);\n    } else {\n        DEBUG_printf(\"  --> hci att server event type: unknown (0x%02x)\\n\", event_type);\n    }\n}\n\n#if MICROPY_BLUETOOTH_USE_ZEPHYR_STATIC_ADDRESS\n\nstatic uint8_t controller_static_addr[6] = {0};\nstatic bool controller_static_addr_available = false;\n\nstatic const uint8_t read_static_address_command_complete_prefix[] = { 0x0e, 0x1b, 0x01, 0x09, 0xfc };\n#endif\n\nstatic void btstack_packet_handler_generic(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    DEBUG_printf(\"btstack_packet_handler_generic(packet_type=%u, packet=%p)\\n\", packet_type, packet);\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n\n    uint8_t event_type = hci_event_packet_get_type(packet);\n\n    if (event_type == HCI_EVENT_LE_META) {\n        DEBUG_printf(\"  --> hci le meta\\n\");\n        switch (hci_event_le_meta_get_subevent_code(packet)) {\n            case HCI_SUBEVENT_LE_CONNECTION_COMPLETE: {\n                uint16_t conn_handle = hci_subevent_le_connection_complete_get_connection_handle(packet);\n                uint8_t addr_type = hci_subevent_le_connection_complete_get_peer_address_type(packet);\n                bd_addr_t addr;\n                hci_subevent_le_connection_complete_get_peer_address(packet, addr);\n                uint16_t irq_event;\n                if (hci_subevent_le_connection_complete_get_role(packet) == 0) {\n                    \n                    irq_event = MP_BLUETOOTH_IRQ_PERIPHERAL_CONNECT;\n                } else {\n                    \n                    irq_event = MP_BLUETOOTH_IRQ_CENTRAL_CONNECT;\n                }\n                #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n                create_active_connection(conn_handle);\n                #endif\n                mp_bluetooth_gap_on_connected_disconnected(irq_event, conn_handle, addr_type, addr);\n                break;\n            }\n            case HCI_SUBEVENT_LE_CONNECTION_UPDATE_COMPLETE: {\n                uint8_t status = hci_subevent_le_connection_update_complete_get_status(packet);\n                uint16_t conn_handle = hci_subevent_le_connection_update_complete_get_connection_handle(packet);\n                uint16_t conn_interval = hci_subevent_le_connection_update_complete_get_conn_interval(packet);\n                uint16_t conn_latency = hci_subevent_le_connection_update_complete_get_conn_latency(packet);\n                uint16_t supervision_timeout = hci_subevent_le_connection_update_complete_get_supervision_timeout(packet);\n                DEBUG_printf(\"- LE Connection %04x: connection update - connection interval %u.%02u ms, latency %u, timeout %u\\n\",\n                    conn_handle, conn_interval * 125 / 100, 25 * (conn_interval & 3), conn_latency, supervision_timeout);\n                mp_bluetooth_gap_on_connection_update(conn_handle, conn_interval, conn_latency, supervision_timeout, status);\n                break;\n            }\n        }\n    } else if (event_type == BTSTACK_EVENT_STATE) {\n        uint8_t state = btstack_event_state_get_state(packet);\n        DEBUG_printf(\"  --> btstack event state 0x%02x\\n\", state);\n        if (state == HCI_STATE_WORKING) {\n            \n            mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_ACTIVE;\n        } else if (state == HCI_STATE_HALTING) {\n            \n            mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_HALTING;\n        } else if (state == HCI_STATE_OFF) {\n            \n            mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_OFF;\n        }\n    } else if (event_type == BTSTACK_EVENT_POWERON_FAILED) {\n        \n        mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_OFF;\n    } else if (event_type == HCI_EVENT_TRANSPORT_PACKET_SENT) {\n        DEBUG_printf(\"  --> hci transport packet sent\\n\");\n    } else if (event_type == HCI_EVENT_COMMAND_COMPLETE) {\n        DEBUG_printf(\"  --> hci command complete\\n\");\n        #if MICROPY_BLUETOOTH_USE_ZEPHYR_STATIC_ADDRESS\n        if (memcmp(packet, read_static_address_command_complete_prefix, sizeof(read_static_address_command_complete_prefix)) == 0) {\n            DEBUG_printf(\"  --> static address available\\n\");\n            reverse_48(&packet[7], controller_static_addr);\n            controller_static_addr_available = true;\n        }\n        #endif \n    } else if (event_type == HCI_EVENT_COMMAND_STATUS) {\n        DEBUG_printf(\"  --> hci command status\\n\");\n    } else if (event_type == HCI_EVENT_NUMBER_OF_COMPLETED_PACKETS) {\n        DEBUG_printf(\"  --> hci number of completed packets\\n\");\n    } else if (event_type == BTSTACK_EVENT_NR_CONNECTIONS_CHANGED) {\n        DEBUG_printf(\"  --> btstack # conns changed\\n\");\n    } else if (event_type == HCI_EVENT_VENDOR_SPECIFIC) {\n        DEBUG_printf(\"  --> hci vendor specific\\n\");\n    } else if (event_type == SM_EVENT_AUTHORIZATION_RESULT ||\n               event_type == SM_EVENT_PAIRING_COMPLETE ||\n               \n               event_type == HCI_EVENT_ENCRYPTION_CHANGE) {\n        DEBUG_printf(\"  --> enc/auth/pair/bond change\\n\");\n        #if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n        uint16_t conn_handle;\n        switch (event_type) {\n            case SM_EVENT_AUTHORIZATION_RESULT:\n                conn_handle = sm_event_authorization_result_get_handle(packet);\n                break;\n            case SM_EVENT_PAIRING_COMPLETE:\n                conn_handle = sm_event_pairing_complete_get_handle(packet);\n                break;\n            case HCI_EVENT_ENCRYPTION_CHANGE:\n                conn_handle = hci_event_encryption_change_get_connection_handle(packet);\n                break;\n            default:\n                return;\n        }\n\n        hci_connection_t *hci_con = hci_connection_for_handle(conn_handle);\n        sm_connection_t *desc = &hci_con->sm_connection;\n        mp_bluetooth_gatts_on_encryption_update(conn_handle,\n            desc->sm_connection_encrypted,\n            desc->sm_connection_authenticated,\n            desc->sm_le_db_index != -1,\n            desc->sm_actual_encryption_key_size);\n        #endif \n    } else if (event_type == HCI_EVENT_DISCONNECTION_COMPLETE) {\n        DEBUG_printf(\"  --> hci disconnect complete\\n\");\n        uint16_t conn_handle = hci_event_disconnection_complete_get_connection_handle(packet);\n        const hci_connection_t *conn = hci_connection_for_handle(conn_handle);\n        uint16_t irq_event;\n        if (conn == NULL || conn->role == 0) {\n            \n            irq_event = MP_BLUETOOTH_IRQ_PERIPHERAL_DISCONNECT;\n        } else {\n            \n            irq_event = MP_BLUETOOTH_IRQ_CENTRAL_DISCONNECT;\n        }\n        uint8_t addr[6] = {0};\n        mp_bluetooth_gap_on_connected_disconnected(irq_event, conn_handle, 0xff, addr);\n        #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n        remove_active_connection(conn_handle);\n        #endif\n    #if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\n    } else if (event_type == GAP_EVENT_ADVERTISING_REPORT) {\n        DEBUG_printf(\"  --> gap advertising report\\n\");\n        bd_addr_t address;\n        gap_event_advertising_report_get_address(packet, address);\n        uint8_t adv_event_type = gap_event_advertising_report_get_advertising_event_type(packet);\n        uint8_t address_type = gap_event_advertising_report_get_address_type(packet);\n        int8_t rssi = gap_event_advertising_report_get_rssi(packet);\n        uint8_t length = gap_event_advertising_report_get_data_length(packet);\n        const uint8_t *data = gap_event_advertising_report_get_data(packet);\n        mp_bluetooth_gap_on_scan_result(address_type, address, adv_event_type, rssi, data, length);\n    #endif \n    #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n    } else if (event_type == GATT_EVENT_MTU) {\n        \n        DEBUG_printf(\"  --> gatt event mtu\\n\");\n        uint16_t conn_handle = gatt_event_mtu_get_handle(packet);\n        uint16_t mtu = gatt_event_mtu_get_MTU(packet);\n        mp_bluetooth_gatts_on_mtu_exchanged(conn_handle, mtu);\n    } else if (event_type == GATT_EVENT_NOTIFICATION) {\n        DEBUG_printf(\"  --> gatt notification\\n\");\n        uint16_t conn_handle = gatt_event_notification_get_handle(packet);\n        uint16_t value_handle = gatt_event_notification_get_value_handle(packet);\n        uint16_t len = gatt_event_notification_get_value_length(packet);\n        const uint8_t *data = gatt_event_notification_get_value(packet);\n        mp_bluetooth_gattc_on_data_available(MP_BLUETOOTH_IRQ_GATTC_NOTIFY, conn_handle, value_handle, &data, &len, 1);\n    } else if (event_type == GATT_EVENT_INDICATION) {\n        DEBUG_printf(\"  --> gatt indication\\n\");\n        uint16_t conn_handle = gatt_event_indication_get_handle(packet);\n        uint16_t value_handle = gatt_event_indication_get_value_handle(packet);\n        uint16_t len = gatt_event_indication_get_value_length(packet);\n        const uint8_t *data = gatt_event_indication_get_value(packet);\n        mp_bluetooth_gattc_on_data_available(MP_BLUETOOTH_IRQ_GATTC_INDICATE, conn_handle, value_handle, &data, &len, 1);\n    } else if (event_type == GATT_EVENT_CAN_WRITE_WITHOUT_RESPONSE) {\n        uint16_t conn_handle = gatt_event_can_write_without_response_get_handle(packet);\n        DEBUG_printf(\"  --> gatt can write without response %d\\n\", conn_handle);\n        mp_btstack_active_connection_t *conn = find_active_connection(conn_handle);\n        if (!conn || conn->pending_value_handle == 0xffff || !conn->pending_write_value) {\n            return;\n        }\n        DEBUG_printf(\"  --> ready for value_handle=%d len=%lu\\n\", conn->pending_value_handle, conn->pending_write_value_len);\n        int err = gatt_client_write_value_of_characteristic_without_response(conn_handle, conn->pending_value_handle, conn->pending_write_value_len, conn->pending_write_value);\n        (void)err;\n        assert(err == ERROR_CODE_SUCCESS);\n        conn->pending_value_handle = 0xffff;\n        m_del(uint8_t, conn->pending_write_value, conn->pending_write_value_len);\n        conn->pending_write_value = NULL;\n        conn->pending_write_value_len = 0;\n    #endif \n    } else {\n        DEBUG_printf(\"  --> hci event type: unknown (0x%02x)\\n\", event_type);\n    }\n}\n\nstatic btstack_packet_callback_registration_t hci_event_callback_registration = {\n    .callback = &btstack_packet_handler_generic\n};\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n\nstatic void btstack_packet_handler_discover_services(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n    uint8_t event_type = hci_event_packet_get_type(packet);\n    if (event_type == GATT_EVENT_SERVICE_QUERY_RESULT) {\n        DEBUG_printf(\"  --> gatt service query result\\n\");\n        uint16_t conn_handle = gatt_event_service_query_result_get_handle(packet);\n        gatt_client_service_t service;\n        gatt_event_service_query_result_get_service(packet, &service);\n        mp_obj_bluetooth_uuid_t service_uuid = create_mp_uuid(service.uuid16, service.uuid128);\n        mp_bluetooth_gattc_on_primary_service_result(conn_handle, service.start_group_handle, service.end_group_handle, &service_uuid);\n    } else if (event_type == GATT_EVENT_QUERY_COMPLETE) {\n        uint16_t conn_handle = gatt_event_query_complete_get_handle(packet);\n        uint16_t status = gatt_event_query_complete_get_att_status(packet);\n        DEBUG_printf(\"  --> gatt query services complete conn_handle=%d status=%d\\n\", conn_handle, status);\n        mp_bluetooth_gattc_on_discover_complete(MP_BLUETOOTH_IRQ_GATTC_SERVICE_DONE, conn_handle, status);\n    }\n}\n\n\nstatic void btstack_packet_handler_discover_characteristics(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n    uint8_t event_type = hci_event_packet_get_type(packet);\n    if (event_type == GATT_EVENT_CHARACTERISTIC_QUERY_RESULT) {\n        DEBUG_printf(\"  --> gatt characteristic query result\\n\");\n        uint16_t conn_handle = gatt_event_characteristic_query_result_get_handle(packet);\n        gatt_client_characteristic_t characteristic;\n        gatt_event_characteristic_query_result_get_characteristic(packet, &characteristic);\n        mp_obj_bluetooth_uuid_t characteristic_uuid = create_mp_uuid(characteristic.uuid16, characteristic.uuid128);\n        mp_bluetooth_gattc_on_characteristic_result(conn_handle, characteristic.value_handle, characteristic.end_handle, characteristic.properties, &characteristic_uuid);\n    } else if (event_type == GATT_EVENT_QUERY_COMPLETE) {\n        uint16_t conn_handle = gatt_event_query_complete_get_handle(packet);\n        uint16_t status = gatt_event_query_complete_get_att_status(packet);\n        DEBUG_printf(\"  --> gatt query characteristics complete conn_handle=%d status=%d\\n\", conn_handle, status);\n        mp_bluetooth_gattc_on_discover_complete(MP_BLUETOOTH_IRQ_GATTC_CHARACTERISTIC_DONE, conn_handle, status);\n    }\n}\n\n\nstatic void btstack_packet_handler_discover_descriptors(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n    uint8_t event_type = hci_event_packet_get_type(packet);\n    if (event_type == GATT_EVENT_ALL_CHARACTERISTIC_DESCRIPTORS_QUERY_RESULT) {\n        DEBUG_printf(\"  --> gatt descriptor query result\\n\");\n        uint16_t conn_handle = gatt_event_all_characteristic_descriptors_query_result_get_handle(packet);\n        gatt_client_characteristic_descriptor_t descriptor;\n        gatt_event_all_characteristic_descriptors_query_result_get_characteristic_descriptor(packet, &descriptor);\n        mp_obj_bluetooth_uuid_t descriptor_uuid = create_mp_uuid(descriptor.uuid16, descriptor.uuid128);\n        mp_bluetooth_gattc_on_descriptor_result(conn_handle, descriptor.handle, &descriptor_uuid);\n    } else if (event_type == GATT_EVENT_QUERY_COMPLETE) {\n        uint16_t conn_handle = gatt_event_query_complete_get_handle(packet);\n        uint16_t status = gatt_event_query_complete_get_att_status(packet);\n        DEBUG_printf(\"  --> gatt query descriptors complete conn_handle=%d status=%d\\n\", conn_handle, status);\n        mp_bluetooth_gattc_on_discover_complete(MP_BLUETOOTH_IRQ_GATTC_DESCRIPTOR_DONE, conn_handle, status);\n    }\n}\n\n\nstatic void btstack_packet_handler_read(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n    uint8_t event_type = hci_event_packet_get_type(packet);\n    if (event_type == GATT_EVENT_QUERY_COMPLETE) {\n        uint16_t conn_handle = gatt_event_query_complete_get_handle(packet);\n        uint16_t status = gatt_event_query_complete_get_att_status(packet);\n        DEBUG_printf(\"  --> gatt query read complete conn_handle=%d status=%d\\n\", conn_handle, status);\n        mp_btstack_active_connection_t *conn = find_active_connection(conn_handle);\n        if (!conn) {\n            return;\n        }\n        uint16_t value_handle = conn->pending_value_handle;\n        conn->pending_value_handle = 0xffff;\n        mp_bluetooth_gattc_on_read_write_status(MP_BLUETOOTH_IRQ_GATTC_READ_DONE, conn_handle, value_handle, status);\n    } else if (event_type == GATT_EVENT_CHARACTERISTIC_VALUE_QUERY_RESULT) {\n        DEBUG_printf(\"  --> gatt characteristic value query result\\n\");\n        uint16_t conn_handle = gatt_event_characteristic_value_query_result_get_handle(packet);\n        uint16_t value_handle = gatt_event_characteristic_value_query_result_get_value_handle(packet);\n        uint16_t len = gatt_event_characteristic_value_query_result_get_value_length(packet);\n        const uint8_t *data = gatt_event_characteristic_value_query_result_get_value(packet);\n        mp_bluetooth_gattc_on_data_available(MP_BLUETOOTH_IRQ_GATTC_READ_RESULT, conn_handle, value_handle, &data, &len, 1);\n    }\n}\n\n\nstatic void btstack_packet_handler_write_with_response(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size) {\n    (void)channel;\n    (void)size;\n    if (packet_type != HCI_EVENT_PACKET) {\n        return;\n    }\n    uint8_t event_type = hci_event_packet_get_type(packet);\n    if (event_type == GATT_EVENT_QUERY_COMPLETE) {\n        uint16_t conn_handle = gatt_event_query_complete_get_handle(packet);\n        uint16_t status = gatt_event_query_complete_get_att_status(packet);\n        DEBUG_printf(\"  --> gatt query write complete conn_handle=%d status=%d\\n\", conn_handle, status);\n        mp_btstack_active_connection_t *conn = find_active_connection(conn_handle);\n        if (!conn) {\n            return;\n        }\n        uint16_t value_handle = conn->pending_value_handle;\n        conn->pending_value_handle = 0xffff;\n        m_del(uint8_t, conn->pending_write_value, conn->pending_write_value_len);\n        conn->pending_write_value = NULL;\n        conn->pending_write_value_len = 0;\n        mp_bluetooth_gattc_on_read_write_status(MP_BLUETOOTH_IRQ_GATTC_WRITE_DONE, conn_handle, value_handle, status);\n    }\n}\n#endif \n\nstatic btstack_timer_source_t btstack_init_deinit_timeout;\n\nstatic void btstack_init_deinit_timeout_handler(btstack_timer_source_t *ds) {\n    (void)ds;\n\n    \n    \n    \n    mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_TIMEOUT;\n}\n\n#if !MICROPY_BLUETOOTH_USE_MP_HAL_GET_MAC_STATIC_ADDRESS\nstatic void btstack_static_address_ready(void *arg) {\n    DEBUG_printf(\"btstack_static_address_ready.\\n\");\n    *(volatile bool *)arg = true;\n}\n#endif\n\nstatic bool set_public_address(void) {\n    bd_addr_t local_addr;\n    gap_local_bd_addr(local_addr);\n    bd_addr_t null_addr = {0};\n    if (memcmp(local_addr, null_addr, 6) == 0) {\n        DEBUG_printf(\"set_public_address: No public address available.\\n\");\n        return false;\n    }\n    DEBUG_printf(\"set_public_address: Using controller's public address.\\n\");\n    gap_random_address_set_mode(GAP_RANDOM_ADDRESS_TYPE_OFF);\n    return true;\n}\n\nstatic void set_random_address(void) {\n    #if MICROPY_BLUETOOTH_USE_ZEPHYR_STATIC_ADDRESS\n    if (controller_static_addr_available) {\n        DEBUG_printf(\"set_random_address: Using static address supplied by controller.\\n\");\n        gap_random_address_set(controller_static_addr);\n    } else\n    #endif \n    {\n        bd_addr_t static_addr;\n\n        #if MICROPY_BLUETOOTH_USE_MP_HAL_GET_MAC_STATIC_ADDRESS\n\n        DEBUG_printf(\"set_random_address: Generating static address using mp_hal_get_mac\\n\");\n        mp_hal_get_mac(MP_HAL_MAC_BDADDR, static_addr);\n\n        #else\n\n        DEBUG_printf(\"set_random_address: Generating random static address.\\n\");\n        btstack_crypto_random_t sm_crypto_random_request;\n        volatile bool ready = false;\n        btstack_crypto_random_generate(&sm_crypto_random_request, static_addr, 6, &btstack_static_address_ready, (void *)&ready);\n        while (!ready) {\n            mp_event_wait_indefinite();\n        }\n\n        #endif \n        \n        static_addr[0] |= 0xc0;\n\n        DEBUG_printf(\"set_random_address: Address generated.\\n\");\n        gap_random_address_set(static_addr);\n    }\n\n    \n    while (true) {\n        uint8_t addr_type;\n        bd_addr_t addr;\n        gap_le_get_own_address(&addr_type, addr);\n\n        bd_addr_t null_addr = {0};\n        if (memcmp(addr, null_addr, 6) != 0) {\n            break;\n        }\n\n        mp_event_wait_indefinite();\n    }\n    DEBUG_printf(\"set_random_address: Address loaded by controller\\n\");\n}\n\nstatic void deinit_stack(void) {\n    mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_OFF;\n\n    \n    sm_deinit();\n    l2cap_deinit();\n    hci_deinit();\n    btstack_memory_deinit();\n    btstack_run_loop_deinit();\n\n    MP_STATE_PORT(bluetooth_btstack_root_pointers) = NULL;\n}\n\nint mp_bluetooth_init(void) {\n    DEBUG_printf(\"mp_bluetooth_init\\n\");\n\n    if (mp_bluetooth_btstack_state == MP_BLUETOOTH_BTSTACK_STATE_ACTIVE) {\n        return 0;\n    }\n\n    \n    mp_bluetooth_deinit();\n\n    btstack_memory_init();\n\n    #if MICROPY_BLUETOOTH_USE_ZEPHYR_STATIC_ADDRESS\n    controller_static_addr_available = false;\n    #endif\n\n    MP_STATE_PORT(bluetooth_btstack_root_pointers) = m_new0(mp_bluetooth_btstack_root_pointers_t, 1);\n    mp_bluetooth_gatts_db_create(&MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db);\n\n    \n    const char *gap_name = MICROPY_PY_BLUETOOTH_DEFAULT_GAP_NAME;\n    size_t gap_len = strlen(gap_name);\n    mp_bluetooth_gatts_db_create_entry(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, BTSTACK_GAP_DEVICE_NAME_HANDLE, gap_len);\n    mp_bluetooth_gap_set_device_name((const uint8_t *)gap_name, gap_len);\n\n    mp_bluetooth_btstack_port_init();\n    mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_STARTING;\n\n    l2cap_init();\n    le_device_db_init();\n    sm_init();\n\n    \n    \n    sm_key_t dummy_key;\n    memset(dummy_key, 0, sizeof(dummy_key));\n    sm_set_er(dummy_key);\n    sm_set_ir(dummy_key);\n\n    #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n    gatt_client_init();\n\n    \n    gatt_client_mtu_enable_auto_negotiation(false);\n    #endif \n\n    \n    hci_add_event_handler(&hci_event_callback_registration);\n\n    \n    att_server_register_packet_handler(&btstack_packet_handler_att_server);\n\n    \n    btstack_run_loop_set_timer(&btstack_init_deinit_timeout, BTSTACK_INIT_DEINIT_TIMEOUT_MS);\n    btstack_run_loop_set_timer_handler(&btstack_init_deinit_timeout, btstack_init_deinit_timeout_handler);\n    btstack_run_loop_add_timer(&btstack_init_deinit_timeout);\n\n    DEBUG_printf(\"mp_bluetooth_init: waiting for stack startup\\n\");\n\n    \n    mp_bluetooth_btstack_port_start();\n    while (mp_bluetooth_btstack_state == MP_BLUETOOTH_BTSTACK_STATE_STARTING) {\n        mp_event_wait_indefinite();\n    }\n    btstack_run_loop_remove_timer(&btstack_init_deinit_timeout);\n\n    \n    if (mp_bluetooth_btstack_state != MP_BLUETOOTH_BTSTACK_STATE_ACTIVE) {\n        DEBUG_printf(\"mp_bluetooth_init: stack startup timed out\\n\");\n\n        bool timeout = mp_bluetooth_btstack_state == MP_BLUETOOTH_BTSTACK_STATE_TIMEOUT;\n\n        \n        mp_bluetooth_btstack_state = MP_BLUETOOTH_BTSTACK_STATE_OFF;\n        \n        mp_bluetooth_btstack_port_deinit();\n\n        \n        deinit_stack();\n\n        return timeout ? MP_ETIMEDOUT : MP_EINVAL;\n    }\n\n    DEBUG_printf(\"mp_bluetooth_init: stack startup complete\\n\");\n\n    \n    \n    \n    \n    \n    \n\n    if (!set_public_address()) {\n        set_random_address();\n    }\n\n    #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n    \n    gatt_client_listen_for_characteristic_value_updates(&MP_STATE_PORT(bluetooth_btstack_root_pointers)->notification, &btstack_packet_handler_generic, GATT_CLIENT_ANY_CONNECTION, NULL);\n    #endif \n\n    \n    \n    \n    \n    mp_bluetooth_gatts_register_service_begin(false);\n    mp_bluetooth_gatts_register_service_end();\n\n    return 0;\n}\n\nvoid mp_bluetooth_deinit(void) {\n    DEBUG_printf(\"mp_bluetooth_deinit\\n\");\n\n    \n    if (!MP_STATE_PORT(bluetooth_btstack_root_pointers)) {\n        return;\n    }\n\n    mp_bluetooth_gap_advertise_stop();\n\n    #if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n    \n    gatt_client_stop_listening_for_characteristic_value_updates(&MP_STATE_PORT(bluetooth_btstack_root_pointers)->notification);\n    #endif \n\n    \n    btstack_run_loop_set_timer(&btstack_init_deinit_timeout, BTSTACK_INIT_DEINIT_TIMEOUT_MS);\n    btstack_run_loop_add_timer(&btstack_init_deinit_timeout);\n\n    \n    \n    \n    mp_bluetooth_btstack_port_deinit();\n    while (mp_bluetooth_btstack_state == MP_BLUETOOTH_BTSTACK_STATE_ACTIVE) {\n        mp_event_wait_indefinite();\n    }\n    btstack_run_loop_remove_timer(&btstack_init_deinit_timeout);\n\n    \n    deinit_stack();\n\n    DEBUG_printf(\"mp_bluetooth_deinit: complete\\n\");\n}\n\nbool mp_bluetooth_is_active(void) {\n    return mp_bluetooth_btstack_state == MP_BLUETOOTH_BTSTACK_STATE_ACTIVE;\n}\n\nvoid mp_bluetooth_get_current_address(uint8_t *addr_type, uint8_t *addr) {\n    if (!mp_bluetooth_is_active()) {\n        mp_raise_OSError(ERRNO_BLUETOOTH_NOT_ACTIVE);\n    }\n\n    DEBUG_printf(\"mp_bluetooth_get_current_address\\n\");\n    gap_le_get_own_address(addr_type, addr);\n}\n\nvoid mp_bluetooth_set_address_mode(uint8_t addr_mode) {\n    if (!mp_bluetooth_is_active()) {\n        mp_raise_OSError(ERRNO_BLUETOOTH_NOT_ACTIVE);\n    }\n\n    switch (addr_mode) {\n        case MP_BLUETOOTH_ADDRESS_MODE_PUBLIC: {\n            DEBUG_printf(\"mp_bluetooth_set_address_mode: public\\n\");\n            if (!set_public_address()) {\n                \n                mp_raise_OSError(MP_EINVAL);\n            }\n            break;\n        }\n        case MP_BLUETOOTH_ADDRESS_MODE_RANDOM: {\n            DEBUG_printf(\"mp_bluetooth_set_address_mode: random\\n\");\n            set_random_address();\n            break;\n        }\n        case MP_BLUETOOTH_ADDRESS_MODE_RPA:\n        case MP_BLUETOOTH_ADDRESS_MODE_NRPA:\n            \n            mp_raise_OSError(MP_EINVAL);\n    }\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\nvoid mp_bluetooth_set_bonding(bool enabled) {\n    if (enabled) {\n        mp_bluetooth_btstack_sm_auth_req |= SM_AUTHREQ_BONDING;\n    } else {\n        mp_bluetooth_btstack_sm_auth_req &= ~SM_AUTHREQ_BONDING;\n    }\n    sm_set_authentication_requirements(mp_bluetooth_btstack_sm_auth_req);\n}\n\nvoid mp_bluetooth_set_mitm_protection(bool enabled) {\n    if (enabled) {\n        mp_bluetooth_btstack_sm_auth_req |= SM_AUTHREQ_MITM_PROTECTION;\n    } else {\n        mp_bluetooth_btstack_sm_auth_req &= ~SM_AUTHREQ_MITM_PROTECTION;\n    }\n    sm_set_authentication_requirements(mp_bluetooth_btstack_sm_auth_req);\n}\n\nvoid mp_bluetooth_set_le_secure(bool enabled) {\n    if (enabled) {\n        mp_bluetooth_btstack_sm_auth_req |= SM_AUTHREQ_SECURE_CONNECTION;\n    } else {\n        mp_bluetooth_btstack_sm_auth_req &= ~SM_AUTHREQ_SECURE_CONNECTION;\n    }\n    sm_set_authentication_requirements(mp_bluetooth_btstack_sm_auth_req);\n}\n\nvoid mp_bluetooth_set_io_capability(uint8_t capability) {\n    sm_set_io_capabilities(capability);\n}\n#endif \n\nsize_t mp_bluetooth_gap_get_device_name(const uint8_t **buf) {\n    const uint8_t *value = NULL;\n    size_t value_len = 0;\n    mp_bluetooth_gatts_db_read(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, BTSTACK_GAP_DEVICE_NAME_HANDLE, &value, &value_len);\n    *buf = value;\n    return value_len;\n}\n\nint mp_bluetooth_gap_set_device_name(const uint8_t *buf, size_t len) {\n    return mp_bluetooth_gatts_db_write(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, BTSTACK_GAP_DEVICE_NAME_HANDLE, buf, len);\n}\n\nint mp_bluetooth_gap_advertise_start(bool connectable, int32_t interval_us, const uint8_t *adv_data, size_t adv_data_len, const uint8_t *sr_data, size_t sr_data_len) {\n    DEBUG_printf(\"mp_bluetooth_gap_advertise_start\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    uint16_t adv_int_min = interval_us / 625;\n    uint16_t adv_int_max = interval_us / 625;\n    uint8_t adv_type = connectable ? 0 : 2;\n    bd_addr_t null_addr = {0};\n\n    uint8_t direct_address_type = 0;\n    uint8_t channel_map = 0x07; \n    uint8_t filter_policy = 0x00; \n\n    gap_advertisements_set_params(adv_int_min, adv_int_max, adv_type, direct_address_type, null_addr, channel_map, filter_policy);\n\n    \n    size_t total_bytes = adv_data_len + sr_data_len;\n    if (total_bytes > MP_STATE_PORT(bluetooth_btstack_root_pointers)->adv_data_alloc) {\n        \n        MP_STATE_PORT(bluetooth_btstack_root_pointers)->adv_data = m_new(uint8_t, total_bytes);\n        MP_STATE_PORT(bluetooth_btstack_root_pointers)->adv_data_alloc = total_bytes;\n    }\n    uint8_t *data = MP_STATE_PORT(bluetooth_btstack_root_pointers)->adv_data;\n\n    if (adv_data) {\n        memcpy(data, (uint8_t *)adv_data, adv_data_len);\n        gap_advertisements_set_data(adv_data_len, data);\n        data += adv_data_len;\n    }\n    if (sr_data) {\n        memcpy(data, (uint8_t *)sr_data, sr_data_len);\n        gap_scan_response_set_data(sr_data_len, data);\n    }\n\n    gap_advertisements_enable(true);\n    return 0;\n}\n\nvoid mp_bluetooth_gap_advertise_stop(void) {\n    DEBUG_printf(\"mp_bluetooth_gap_advertise_stop\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return;\n    }\n\n    gap_advertisements_enable(false);\n    MP_STATE_PORT(bluetooth_btstack_root_pointers)->adv_data_alloc = 0;\n    MP_STATE_PORT(bluetooth_btstack_root_pointers)->adv_data = NULL;\n}\n\nint mp_bluetooth_gatts_register_service_begin(bool append) {\n    DEBUG_printf(\"mp_bluetooth_gatts_register_service_begin\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    if (!append) {\n        \n        \n        \n        att_db_util_init();\n\n        att_db_util_add_service_uuid16(GAP_SERVICE_UUID);\n        uint16_t handle = att_db_util_add_characteristic_uuid16(GAP_DEVICE_NAME_UUID, ATT_PROPERTY_READ | ATT_PROPERTY_DYNAMIC, ATT_SECURITY_NONE, ATT_SECURITY_NONE, NULL, 0);\n        (void)handle;\n        assert(handle == BTSTACK_GAP_DEVICE_NAME_HANDLE);\n\n        att_db_util_add_service_uuid16(0x1801);\n        att_db_util_add_characteristic_uuid16(0x2a05, ATT_PROPERTY_READ, ATT_SECURITY_NONE, ATT_SECURITY_NONE, NULL, 0);\n    }\n\n    return 0;\n}\n\nstatic uint16_t att_read_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t offset, uint8_t *buffer, uint16_t buffer_size) {\n    \n    \n    (void)connection_handle;\n    DEBUG_printf(\"att_read_callback (handle: %u, offset: %u, buffer: %p, size: %u)\\n\", att_handle, offset, buffer, buffer_size);\n    mp_bluetooth_gatts_db_entry_t *entry = mp_bluetooth_gatts_db_lookup(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, att_handle);\n    if (!entry) {\n        DEBUG_printf(\"att_read_callback handle not found\\n\");\n        return 0;\n    }\n\n    \n    \n    \n    if ((buffer == NULL) && (buffer_size == 0)) {\n        if (!mp_bluetooth_gatts_on_read_request(connection_handle, att_handle)) {\n            DEBUG_printf(\"att_read_callback: read request denied\\n\");\n            return 0;\n        }\n    }\n\n    uint16_t ret = att_read_callback_handle_blob(entry->data, entry->data_len, offset, buffer, buffer_size);\n    return ret;\n}\n\nstatic int att_write_callback(hci_con_handle_t connection_handle, uint16_t att_handle, uint16_t transaction_mode, uint16_t offset, uint8_t *buffer, uint16_t buffer_size) {\n    (void)offset;\n    (void)transaction_mode;\n    DEBUG_printf(\"att_write_callback (handle: %u, mode: %u, offset: %u, buffer: %p, size: %u)\\n\", att_handle, transaction_mode, offset, buffer, buffer_size);\n    mp_bluetooth_gatts_db_entry_t *entry = mp_bluetooth_gatts_db_lookup(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, att_handle);\n    if (!entry) {\n        DEBUG_printf(\"att_write_callback handle not found\\n\");\n        return 0; \n    }\n\n    \n    size_t append_offset = 0;\n    if (entry->append) {\n        append_offset = entry->data_len;\n    }\n    entry->data_len = MIN(entry->data_alloc, buffer_size + append_offset);\n    memcpy(entry->data + append_offset, buffer, entry->data_len - append_offset);\n\n    uint16_t handle_uuid = att_uuid_for_handle(att_handle);\n    if (handle_uuid != GATT_CLIENT_CHARACTERISTICS_CONFIGURATION) {\n        \n        mp_bluetooth_gatts_on_write(connection_handle, att_handle);\n    }\n\n    return 0;\n}\n\nstatic inline uint16_t get_uuid16(const mp_obj_bluetooth_uuid_t *uuid) {\n    return (uuid->data[1] << 8) | uuid->data[0];\n}\n\n\nstatic void get_characteristic_permissions(uint16_t flags, uint16_t *read_permission, uint16_t *write_permission) {\n    if (flags & MP_BLUETOOTH_CHARACTERISTIC_FLAG_READ_ENCRYPTED) {\n        *read_permission = ATT_SECURITY_ENCRYPTED;\n    } else if (flags & MP_BLUETOOTH_CHARACTERISTIC_FLAG_READ_AUTHENTICATED) {\n        *read_permission = ATT_SECURITY_AUTHENTICATED;\n    } else if (flags & MP_BLUETOOTH_CHARACTERISTIC_FLAG_READ_AUTHORIZED) {\n        *read_permission = ATT_SECURITY_AUTHORIZED;\n    } else {\n        *read_permission = ATT_SECURITY_NONE;\n    }\n\n    if (flags & MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE_ENCRYPTED) {\n        *write_permission = ATT_SECURITY_ENCRYPTED;\n    } else if (flags & MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE_AUTHENTICATED) {\n        *write_permission = ATT_SECURITY_AUTHENTICATED;\n    } else if (flags & MP_BLUETOOTH_CHARACTERISTIC_FLAG_WRITE_AUTHORIZED) {\n        *write_permission = ATT_SECURITY_AUTHORIZED;\n    } else {\n        *write_permission = ATT_SECURITY_NONE;\n    }\n}\n\nint mp_bluetooth_gatts_register_service(mp_obj_bluetooth_uuid_t *service_uuid, mp_obj_bluetooth_uuid_t **characteristic_uuids, uint16_t *characteristic_flags, mp_obj_bluetooth_uuid_t **descriptor_uuids, uint16_t *descriptor_flags, uint8_t *num_descriptors, uint16_t *handles, size_t num_characteristics) {\n    DEBUG_printf(\"mp_bluetooth_gatts_register_service\\n\");\n    \n    \n\n    \n    \n\n    if (service_uuid->type == MP_BLUETOOTH_UUID_TYPE_16) {\n        att_db_util_add_service_uuid16(get_uuid16(service_uuid));\n    } else if (service_uuid->type == MP_BLUETOOTH_UUID_TYPE_128) {\n        uint8_t buffer[16];\n        reverse_128(service_uuid->data, buffer);\n        att_db_util_add_service_uuid128(buffer);\n    } else {\n        return MP_EINVAL;\n    }\n\n    size_t handle_index = 0;\n    size_t descriptor_index = 0;\n    static uint8_t cccd_buf[2] = {0};\n\n    for (size_t i = 0; i < num_characteristics; ++i) {\n        uint16_t props = (characteristic_flags[i] & 0x7f) | ATT_PROPERTY_DYNAMIC;\n        uint16_t read_permission, write_permission;\n        get_characteristic_permissions(characteristic_flags[i], &read_permission, &write_permission);\n        if (characteristic_uuids[i]->type == MP_BLUETOOTH_UUID_TYPE_16) {\n            handles[handle_index] = att_db_util_add_characteristic_uuid16(get_uuid16(characteristic_uuids[i]), props, read_permission, write_permission, NULL, 0);\n        } else if (characteristic_uuids[i]->type == MP_BLUETOOTH_UUID_TYPE_128) {\n            uint8_t buffer[16];\n            reverse_128(characteristic_uuids[i]->data, buffer);\n            handles[handle_index] = att_db_util_add_characteristic_uuid128(buffer, props, read_permission, write_permission, NULL, 0);\n        } else {\n            return MP_EINVAL;\n        }\n        mp_bluetooth_gatts_db_create_entry(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, handles[handle_index], MP_BLUETOOTH_DEFAULT_ATTR_LEN);\n        \n        if (props & (ATT_PROPERTY_NOTIFY | ATT_PROPERTY_INDICATE)) {\n            \n            mp_bluetooth_gatts_db_create_entry(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, handles[handle_index] + 1, MP_BLUETOOTH_CCCD_LEN);\n            int ret = mp_bluetooth_gatts_db_write(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, handles[handle_index] + 1, cccd_buf, sizeof(cccd_buf));\n            if (ret) {\n                return ret;\n            }\n        }\n        DEBUG_printf(\"mp_bluetooth_gatts_register_service: Registered char with handle %u\\n\", handles[handle_index]);\n        ++handle_index;\n\n        for (size_t j = 0; j < num_descriptors[i]; ++j) {\n            props = (descriptor_flags[descriptor_index] & 0x7f) | ATT_PROPERTY_DYNAMIC;\n            get_characteristic_permissions(descriptor_flags[descriptor_index], &read_permission, &write_permission);\n\n            if (descriptor_uuids[descriptor_index]->type == MP_BLUETOOTH_UUID_TYPE_16) {\n                handles[handle_index] = att_db_util_add_descriptor_uuid16(get_uuid16(descriptor_uuids[descriptor_index]), props, read_permission, write_permission, NULL, 0);\n            } else if (descriptor_uuids[descriptor_index]->type == MP_BLUETOOTH_UUID_TYPE_128) {\n                uint8_t buffer[16];\n                reverse_128(descriptor_uuids[descriptor_index]->data, buffer);\n                handles[handle_index] = att_db_util_add_descriptor_uuid128(buffer, props, read_permission, write_permission, NULL, 0);\n            } else {\n                return MP_EINVAL;\n            }\n            mp_bluetooth_gatts_db_create_entry(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, handles[handle_index], MP_BLUETOOTH_DEFAULT_ATTR_LEN);\n            DEBUG_printf(\"mp_bluetooth_gatts_register_service: Registered desc with handle %u\\n\", handles[handle_index]);\n            ++descriptor_index;\n            ++handle_index;\n        }\n    }\n\n    return 0;\n}\n\nint mp_bluetooth_gatts_register_service_end(void) {\n    DEBUG_printf(\"mp_bluetooth_gatts_register_service_end\\n\");\n    att_server_init(att_db_util_get_address(), &att_read_callback, &att_write_callback);\n    return 0;\n}\n\nint mp_bluetooth_gatts_read(uint16_t value_handle, const uint8_t **value, size_t *value_len) {\n    DEBUG_printf(\"mp_bluetooth_gatts_read\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    return mp_bluetooth_gatts_db_read(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, value_handle, value, value_len);\n}\n\nint mp_bluetooth_gatts_write(uint16_t value_handle, const uint8_t *value, size_t value_len, bool send_update) {\n    DEBUG_printf(\"mp_bluetooth_gatts_write\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    if (send_update) {\n        DEBUG_printf(\"  --> send_update\\n\");\n        \n        \n        uint16_t next_handle_uuid = att_uuid_for_handle(value_handle + 1);\n        if (next_handle_uuid != GATT_CLIENT_CHARACTERISTICS_CONFIGURATION) {\n            return MP_EINVAL;\n        }\n        DEBUG_printf(\"  --> got handle for cccd: %d\\n\", value_handle + 1);\n    }\n    int err = mp_bluetooth_gatts_db_write(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, value_handle, value, value_len);\n    if (!send_update || err) {\n        return err;\n    }\n\n    \n    const uint8_t *cccd;\n    size_t cccd_len;\n    err = mp_bluetooth_gatts_db_read(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, value_handle + 1, &cccd, &cccd_len);\n    if (cccd_len != 2 || err) {\n        return err;\n    }\n\n    \n    btstack_linked_list_iterator_t it;\n    hci_connections_get_iterator(&it);\n    while (btstack_linked_list_iterator_has_next(&it)) {\n        hci_connection_t *connection = (hci_connection_t *)btstack_linked_list_iterator_next(&it);\n        if (cccd[0] & 1) {\n            err = mp_bluetooth_gatts_notify_indicate(connection->con_handle, value_handle, MP_BLUETOOTH_GATTS_OP_NOTIFY, value, value_len);\n            if (err) {\n                return err;\n            }\n        }\n        if (cccd[0] & 2) {\n            err = mp_bluetooth_gatts_notify_indicate(connection->con_handle, value_handle, MP_BLUETOOTH_GATTS_OP_INDICATE, value, value_len);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    return 0;\n}\n\n#if !MICROPY_TRACKED_ALLOC\n#error \"btstack requires MICROPY_TRACKED_ALLOC\"\n#endif\n\ntypedef struct {\n    btstack_context_callback_registration_t btstack_registration;\n    int gatts_op;\n    uint16_t conn_handle;\n    uint16_t value_handle;\n    size_t value_len;\n    uint8_t value[];\n} notify_indicate_pending_op_t;\n\n\n\nstatic void btstack_notify_indicate_ready_handler(void *context) {\n    MICROPY_PY_BLUETOOTH_ENTER\n    notify_indicate_pending_op_t *pending_op = (notify_indicate_pending_op_t *)context;\n    DEBUG_printf(\"btstack_notify_indicate_ready_handler gatts_op=%d conn_handle=%d value_handle=%d len=%lu\\n\", pending_op->gatts_op, pending_op->conn_handle, pending_op->value_handle, pending_op->value_len);\n    int err = ERROR_CODE_SUCCESS;\n    switch (pending_op->gatts_op) {\n        case MP_BLUETOOTH_GATTS_OP_NOTIFY:\n            err = att_server_notify(pending_op->conn_handle, pending_op->value_handle, pending_op->value, pending_op->value_len);\n            DEBUG_printf(\"btstack_notify_indicate_ready_handler: sending notification err=%d\\n\", err);\n            break;\n        case MP_BLUETOOTH_GATTS_OP_INDICATE:\n            err = att_server_indicate(pending_op->conn_handle, pending_op->value_handle, pending_op->value, pending_op->value_len);\n            DEBUG_printf(\"btstack_notify_indicate_ready_handler: sending indication err=%d\\n\", err);\n            break;\n    }\n    assert(err == ERROR_CODE_SUCCESS);\n    (void)err;\n    MICROPY_PY_BLUETOOTH_EXIT\n    m_tracked_free(pending_op);\n}\n\nint mp_bluetooth_gatts_notify_indicate(uint16_t conn_handle, uint16_t value_handle, int gatts_op, const uint8_t *value, size_t value_len) {\n    DEBUG_printf(\"mp_bluetooth_gatts_notify_indicate: gatts_op=%d\\n\", gatts_op);\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    if (!value) {\n        \n        mp_bluetooth_gatts_db_read(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, value_handle, &value, &value_len);\n    }\n\n    \n    \n    uint16_t current_mtu = att_server_get_mtu(conn_handle);\n    if (current_mtu) {\n        current_mtu -= 3;\n        value_len = MIN(value_len, current_mtu);\n    }\n\n    int err = ERROR_CODE_UNKNOWN_HCI_COMMAND;\n\n    \n    MICROPY_PY_BLUETOOTH_ENTER\n    switch (gatts_op) {\n        case MP_BLUETOOTH_GATTS_OP_NOTIFY:\n            err = att_server_notify(conn_handle, value_handle, value, value_len);\n            break;\n        case MP_BLUETOOTH_GATTS_OP_INDICATE:\n            \n            \n            err = att_server_indicate(conn_handle, value_handle, value, value_len);\n            break;\n    }\n    MICROPY_PY_BLUETOOTH_EXIT\n\n    if (err == BTSTACK_ACL_BUFFERS_FULL || err == ATT_HANDLE_VALUE_INDICATION_IN_PROGRESS) {\n        DEBUG_printf(\"mp_bluetooth_gatts_notify_indicate: ACL buffer full / indication in progress, scheduling callback\\n\");\n\n        \n        notify_indicate_pending_op_t *pending_op = m_tracked_calloc(1, sizeof(notify_indicate_pending_op_t) + value_len);\n        pending_op->btstack_registration.context = pending_op;\n        pending_op->btstack_registration.callback = &btstack_notify_indicate_ready_handler;\n        pending_op->gatts_op = gatts_op;\n        pending_op->conn_handle = conn_handle;\n        pending_op->value_handle = value_handle;\n        pending_op->value_len = value_len;\n        memcpy(pending_op->value, value, value_len);\n\n        MICROPY_PY_BLUETOOTH_ENTER\n        switch (gatts_op) {\n            case MP_BLUETOOTH_GATTS_OP_NOTIFY:\n                err = att_server_request_to_send_notification(&pending_op->btstack_registration, conn_handle);\n                break;\n            case MP_BLUETOOTH_GATTS_OP_INDICATE:\n                err = att_server_request_to_send_indication(&pending_op->btstack_registration, conn_handle);\n                break;\n        }\n        MICROPY_PY_BLUETOOTH_EXIT\n\n        if (err != ERROR_CODE_SUCCESS) {\n            m_tracked_free(pending_op);\n        }\n    }\n\n    return btstack_error_to_errno(err);\n}\n\nint mp_bluetooth_gatts_set_buffer(uint16_t value_handle, size_t len, bool append) {\n    DEBUG_printf(\"mp_bluetooth_gatts_set_buffer\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    return mp_bluetooth_gatts_db_resize(MP_STATE_PORT(bluetooth_btstack_root_pointers)->gatts_db, value_handle, len, append);\n}\n\nint mp_bluetooth_get_preferred_mtu(void) {\n    if (!mp_bluetooth_is_active()) {\n        mp_raise_OSError(ERRNO_BLUETOOTH_NOT_ACTIVE);\n    }\n    return l2cap_max_le_mtu();\n}\n\nint mp_bluetooth_set_preferred_mtu(uint16_t mtu) {\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    l2cap_set_max_le_mtu(mtu);\n    if (l2cap_max_le_mtu() != mtu) {\n        return MP_EINVAL;\n    }\n    return 0;\n}\n\nint mp_bluetooth_gap_disconnect(uint16_t conn_handle) {\n    DEBUG_printf(\"mp_bluetooth_gap_disconnect\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    gap_disconnect(conn_handle);\n    return 0;\n}\n\n#if MICROPY_PY_BLUETOOTH_ENABLE_PAIRING_BONDING\n\nint mp_bluetooth_gap_pair(uint16_t conn_handle) {\n    DEBUG_printf(\"mp_bluetooth_gap_pair: conn_handle=%d\\n\", conn_handle);\n    sm_request_pairing(conn_handle);\n    return 0;\n}\n\nint mp_bluetooth_gap_passkey(uint16_t conn_handle, uint8_t action, mp_int_t passkey) {\n    DEBUG_printf(\"mp_bluetooth_gap_passkey: conn_handle=%d action=%d passkey=%d\\n\", conn_handle, action, (int)passkey);\n    return MP_EOPNOTSUPP;\n}\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE\nstatic btstack_timer_source_t scan_duration_timeout;\n\nstatic void scan_duration_timeout_handler(btstack_timer_source_t *ds) {\n    (void)ds;\n    mp_bluetooth_gap_scan_stop();\n}\n\nint mp_bluetooth_gap_scan_start(int32_t duration_ms, int32_t interval_us, int32_t window_us, bool active_scan) {\n    DEBUG_printf(\"mp_bluetooth_gap_scan_start\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    if (duration_ms > 0) {\n        btstack_run_loop_set_timer(&scan_duration_timeout, duration_ms);\n        btstack_run_loop_set_timer_handler(&scan_duration_timeout, scan_duration_timeout_handler);\n        btstack_run_loop_add_timer(&scan_duration_timeout);\n    }\n\n    gap_set_scan_parameters(active_scan ? 1 : 0, interval_us / 625, window_us / 625);\n    gap_start_scan();\n\n    return 0;\n}\n\nint mp_bluetooth_gap_scan_stop(void) {\n    DEBUG_printf(\"mp_bluetooth_gap_scan_stop\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n    btstack_run_loop_remove_timer(&scan_duration_timeout);\n    gap_stop_scan();\n    mp_bluetooth_gap_on_scan_complete();\n    return 0;\n}\n\nint mp_bluetooth_gap_peripheral_connect(uint8_t addr_type, const uint8_t *addr, int32_t duration_ms, int32_t min_conn_interval_us, int32_t max_conn_interval_us) {\n    DEBUG_printf(\"mp_bluetooth_gap_peripheral_connect\\n\");\n\n    uint16_t conn_scan_interval = 60000 / 625;\n    uint16_t conn_scan_window = 30000 / 625;\n    uint16_t conn_interval_min = (min_conn_interval_us ? min_conn_interval_us : 10000) / 1250;\n    uint16_t conn_interval_max = (max_conn_interval_us ? max_conn_interval_us : 30000) / 1250;\n    uint16_t conn_latency = 4;\n    uint16_t supervision_timeout = duration_ms / 10; \n    uint16_t min_ce_length = 10000 / 625;\n    uint16_t max_ce_length = 30000 / 625;\n\n    gap_set_connection_parameters(conn_scan_interval, conn_scan_window, conn_interval_min, conn_interval_max, conn_latency, supervision_timeout, min_ce_length, max_ce_length);\n\n    bd_addr_t btstack_addr;\n    memcpy(btstack_addr, addr, BD_ADDR_LEN);\n    return btstack_error_to_errno(gap_connect(btstack_addr, addr_type));\n}\n\nint mp_bluetooth_gap_peripheral_connect_cancel(void) {\n    DEBUG_printf(\"mp_bluetooth_gap_peripheral_connect_cancel\\n\");\n    return btstack_error_to_errno(gap_connect_cancel());\n}\n\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_GATT_CLIENT\n\nint mp_bluetooth_gattc_discover_primary_services(uint16_t conn_handle, const mp_obj_bluetooth_uuid_t *uuid) {\n    DEBUG_printf(\"mp_bluetooth_gattc_discover_primary_services\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    uint8_t err;\n    if (uuid) {\n        if (uuid->type == MP_BLUETOOTH_UUID_TYPE_16) {\n            err = gatt_client_discover_primary_services_by_uuid16(&btstack_packet_handler_discover_services, conn_handle, get_uuid16(uuid));\n        } else if (uuid->type == MP_BLUETOOTH_UUID_TYPE_128) {\n            uint8_t buffer[16];\n            reverse_128(uuid->data, buffer);\n            err = gatt_client_discover_primary_services_by_uuid128(&btstack_packet_handler_discover_services, conn_handle, buffer);\n        } else {\n            DEBUG_printf(\"  --> unknown UUID size\\n\");\n            return MP_EINVAL;\n        }\n    } else {\n        err = gatt_client_discover_primary_services(&btstack_packet_handler_discover_services, conn_handle);\n    }\n    return btstack_error_to_errno(err);\n}\n\nint mp_bluetooth_gattc_discover_characteristics(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle, const mp_obj_bluetooth_uuid_t *uuid) {\n    DEBUG_printf(\"mp_bluetooth_gattc_discover_characteristics\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    gatt_client_service_t service = {\n        \n        .start_group_handle = start_handle,\n        .end_group_handle = end_handle,\n        .uuid16 = 0,\n        .uuid128 = {0},\n    };\n    uint8_t err;\n    if (uuid) {\n        if (uuid->type == MP_BLUETOOTH_UUID_TYPE_16) {\n            err = gatt_client_discover_characteristics_for_service_by_uuid16(&btstack_packet_handler_discover_characteristics, conn_handle, &service, get_uuid16(uuid));\n        } else if (uuid->type == MP_BLUETOOTH_UUID_TYPE_128) {\n            uint8_t buffer[16];\n            reverse_128(uuid->data, buffer);\n            err = gatt_client_discover_characteristics_for_service_by_uuid128(&btstack_packet_handler_discover_characteristics, conn_handle, &service, buffer);\n        } else {\n            DEBUG_printf(\"  --> unknown UUID size\\n\");\n            return MP_EINVAL;\n        }\n    } else {\n        err = gatt_client_discover_characteristics_for_service(&btstack_packet_handler_discover_characteristics, conn_handle, &service);\n    }\n    return btstack_error_to_errno(err);\n}\n\nint mp_bluetooth_gattc_discover_descriptors(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle) {\n    DEBUG_printf(\"mp_bluetooth_gattc_discover_descriptors\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    gatt_client_characteristic_t characteristic = {\n        \n        .start_handle = 0,\n        .value_handle = start_handle,\n        .end_handle = end_handle,\n        .properties = 0,\n        .uuid16 = 0,\n        .uuid128 = {0},\n    };\n    return btstack_error_to_errno(gatt_client_discover_characteristic_descriptors(&btstack_packet_handler_discover_descriptors, conn_handle, &characteristic));\n}\n\nint mp_bluetooth_gattc_read(uint16_t conn_handle, uint16_t value_handle) {\n    DEBUG_printf(\"mp_bluetooth_gattc_read\\n\");\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    \n    mp_btstack_active_connection_t *conn = find_active_connection(conn_handle);\n    if (!conn) {\n        DEBUG_printf(\"  --> no active connection %d\\n\", conn_handle);\n        return MP_ENOTCONN;\n    }\n    if (conn->pending_value_handle != 0xffff) {\n        \n        DEBUG_printf(\"--> busy\\n\");\n        return MP_EALREADY;\n    }\n    conn->pending_value_handle = value_handle;\n    int err = gatt_client_read_value_of_characteristic_using_value_handle(&btstack_packet_handler_read, conn_handle, value_handle);\n    if (err != ERROR_CODE_SUCCESS) {\n        DEBUG_printf(\"--> can't send read %d\\n\", err);\n        conn->pending_value_handle = 0xffff;\n    }\n    return btstack_error_to_errno(err);\n}\n\nint mp_bluetooth_gattc_write(uint16_t conn_handle, uint16_t value_handle, const uint8_t *value, size_t value_len, unsigned int mode) {\n    DEBUG_printf(\"mp_bluetooth_gattc_write\\n\");\n\n    if (!mp_bluetooth_is_active()) {\n        return ERRNO_BLUETOOTH_NOT_ACTIVE;\n    }\n\n    \n    \n    \n    \n    \n\n    int err;\n\n    if (mode == MP_BLUETOOTH_WRITE_MODE_NO_RESPONSE) {\n        \n        err = gatt_client_write_value_of_characteristic_without_response(conn_handle, value_handle, value_len, (uint8_t *)value);\n        if (err != GATT_CLIENT_BUSY) {\n            DEBUG_printf(\"--> can't send write-without-response %d\\n\", err);\n            return btstack_error_to_errno(err);\n        }\n    }\n\n    \n    mp_btstack_active_connection_t *conn = find_active_connection(conn_handle);\n    if (!conn) {\n        DEBUG_printf(\"  --> no active connection %d\\n\", conn_handle);\n        return MP_ENOTCONN;\n    }\n    if (conn->pending_value_handle != 0xffff) {\n        \n        DEBUG_printf(\"  --> busy\\n\");\n        return MP_EALREADY;\n    }\n    conn->pending_value_handle = value_handle;\n    conn->pending_write_value_len = value_len;\n    conn->pending_write_value = m_new(uint8_t, value_len);\n    memcpy(conn->pending_write_value, value, value_len);\n\n    if (mode == MP_BLUETOOTH_WRITE_MODE_NO_RESPONSE) {\n        DEBUG_printf(\"  --> client busy\\n\");\n        \n        \n        \n        \n        \n        err = gatt_client_request_can_write_without_response_event(&btstack_packet_handler_generic, conn_handle);\n    } else if (mode == MP_BLUETOOTH_WRITE_MODE_WITH_RESPONSE) {\n        \n        \n        err = gatt_client_write_value_of_characteristic(&btstack_packet_handler_write_with_response, conn_handle, value_handle, value_len, conn->pending_write_value);\n    } else {\n        return MP_EINVAL;\n    }\n\n    if (err != ERROR_CODE_SUCCESS) {\n        DEBUG_printf(\"--> write failed %d\\n\", err);\n        \n        \n        m_del(uint8_t, conn->pending_write_value, value_len);\n        conn->pending_write_value_len = 0;\n        conn->pending_value_handle = 0xffff;\n    }\n\n    return btstack_error_to_errno(err);\n}\n\nint mp_bluetooth_gattc_exchange_mtu(uint16_t conn_handle) {\n    DEBUG_printf(\"mp_bluetooth_gattc_exchange_mtu: conn_handle=%d mtu=%d\\n\", conn_handle, l2cap_max_le_mtu());\n\n    gatt_client_send_mtu_negotiation(&btstack_packet_handler_generic, conn_handle);\n\n    return 0;\n}\n#endif \n\n#if MICROPY_PY_BLUETOOTH_ENABLE_L2CAP_CHANNELS\n\nint mp_bluetooth_l2cap_listen(uint16_t psm, uint16_t mtu) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_listen: psm=%d, mtu=%d\\n\", psm, mtu);\n    return MP_EOPNOTSUPP;\n}\n\nint mp_bluetooth_l2cap_connect(uint16_t conn_handle, uint16_t psm, uint16_t mtu) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_connect: conn_handle=%d, psm=%d, mtu=%d\\n\", conn_handle, psm, mtu);\n    return MP_EOPNOTSUPP;\n}\n\nint mp_bluetooth_l2cap_disconnect(uint16_t conn_handle, uint16_t cid) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_disconnect: conn_handle=%d, cid=%d\\n\", conn_handle, cid);\n    return MP_EOPNOTSUPP;\n}\n\nint mp_bluetooth_l2cap_send(uint16_t conn_handle, uint16_t cid, const uint8_t *buf, size_t len, bool *stalled) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_send: conn_handle=%d, cid=%d, len=%d\\n\", conn_handle, cid, (int)len);\n    return MP_EOPNOTSUPP;\n}\n\nint mp_bluetooth_l2cap_recvinto(uint16_t conn_handle, uint16_t cid, uint8_t *buf, size_t *len) {\n    DEBUG_printf(\"mp_bluetooth_l2cap_recvinto: conn_handle=%d, cid=%d, len=%d\\n\", conn_handle, cid, (int)*len);\n    return MP_EOPNOTSUPP;\n}\n\n#endif \n\nMP_REGISTER_ROOT_POINTER(struct _mp_bluetooth_btstack_root_pointers_t *bluetooth_btstack_root_pointers);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}