{
  "module_name": "modopenamp.c",
  "hash_id": "0a6add98924070b1117a6420e7c6b9622f0f8c2172b89c31c7cb459533d27e12",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modopenamp.c",
  "human_readable_source": " \n\n#if MICROPY_PY_OPENAMP\n\n#include <stdarg.h>\n#include \"py/obj.h\"\n#include \"py/nlr.h\"\n#include \"py/runtime.h\"\n#include \"py/mpprint.h\"\n\n#include \"metal/sys.h\"\n#include \"metal/alloc.h\"\n#include \"metal/errno.h\"\n#include \"metal/io.h\"\n#include \"metal/device.h\"\n#include \"metal/utilities.h\"\n\n#include \"openamp/open_amp.h\"\n#include \"openamp/remoteproc.h\"\n#include \"openamp/remoteproc_loader.h\"\n#include \"modopenamp.h\"\n\n#if !MICROPY_ENABLE_FINALISER\n#error \"MICROPY_PY_OPENAMP requires MICROPY_ENABLE_FINALISER\"\n#endif\n\n#if MICROPY_PY_OPENAMP_RSC_TABLE_ENABLE\n#define VIRTIO_DEV_ID           0xFF\n#define VIRTIO_DEV_FEATURES     (1 << VIRTIO_RPMSG_F_NS)\n\n#define VRING0_ID               0    \n#define VRING1_ID               1    \n#define VRING_NOTIFY_ID         VRING0_ID\n\n#define VRING_COUNT             2\n#define VRING_ALIGNMENT         32\n \n#define VRING_NUM_BUFFS         64\n\n \n \n \n#define VRING_RX_ADDR           (METAL_SHM_ADDR)\n#define VRING_TX_ADDR           (METAL_SHM_ADDR + 0x1000)\n#define VRING_BUFF_ADDR         (METAL_SHM_ADDR + 0x2000)\n#define VRING_BUFF_SIZE         (METAL_SHM_SIZE - 0x2000)\n\nstatic const char openamp_trace_buf[128];\n#define MICROPY_PY_OPENAMP_TRACE_BUF       ((uint32_t)openamp_trace_buf)\n#define MICROPY_PY_OPENAMP_TRACE_BUF_LEN   sizeof(MICROPY_PY_OPENAMP_TRACE_BUF)\n\n#endif  \n\n#if MICROPY_PY_OPENAMP_REMOTEPROC\nextern mp_obj_type_t openamp_remoteproc_type;\n#endif\n\nstatic struct metal_device shm_device = {\n    .name = METAL_SHM_NAME,\n     \n     \n    \n    \n    .num_regions = METAL_MAX_DEVICE_REGIONS,\n    .regions = { { 0 } },\n    .node = { NULL },\n    .irq_num = 0,\n    .irq_info = NULL\n};\nstatic metal_phys_addr_t shm_physmap[] = { 0 };\n\n\ntypedef struct _virtio_dev_obj_t {\n    mp_obj_base_t base;\n    struct rpmsg_virtio_device rvdev;\n    struct rpmsg_virtio_shm_pool shm_pool;\n    mp_obj_t ns_callback;\n} virtio_dev_obj_t;\n\nstatic mp_obj_t virtio_dev_deinit(mp_obj_t self_in) {\n    virtio_dev_obj_t *virtio_device = MP_OBJ_TO_PTR(self_in);\n    rpmsg_deinit_vdev(&virtio_device->rvdev);\n    metal_finish();\n    MP_STATE_PORT(virtio_device) = NULL;\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(virtio_dev_deinit_obj, virtio_dev_deinit);\n\nstatic const mp_rom_map_elem_t virtio_dev_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_VirtIODev) },\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&virtio_dev_deinit_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(virtio_dev_locals_dict, virtio_dev_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    virtio_dev_type,\n    MP_QSTR_VirtIODev,\n    MP_TYPE_FLAG_NONE,\n    locals_dict, &virtio_dev_locals_dict\n    );\n\n\ntypedef struct _endpoint_obj_t {\n    mp_obj_base_t base;\n    mp_obj_t name;\n    mp_obj_t callback;\n    struct rpmsg_endpoint ep;\n} endpoint_obj_t;\n\nstatic const mp_obj_type_t endpoint_type;\n\nstatic int endpoint_recv_callback(struct rpmsg_endpoint *ept, void *data, size_t len, uint32_t src, void *priv) {\n    metal_log(METAL_LOG_DEBUG, \"endpoint_recv_callback() message received src: %lu msg len: %d\\n\", src, len);\n    endpoint_obj_t *self = metal_container_of(ept, endpoint_obj_t, ep);\n    if (self->callback != mp_const_none) {\n        mp_call_function_2(self->callback, mp_obj_new_int(src), mp_obj_new_bytearray_by_ref(len, data));\n    }\n    return 0;\n}\n\nstatic mp_obj_t endpoint_send(uint n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_src, ARG_dest, ARG_timeout };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_src, MP_ARG_INT | MP_ARG_KW_ONLY,  {.u_int = -1 } },\n        { MP_QSTR_dest, MP_ARG_INT | MP_ARG_KW_ONLY,  {.u_int = -1 } },\n        { MP_QSTR_timeout, MP_ARG_INT | MP_ARG_KW_ONLY,  {.u_int = -1 } },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 2, pos_args + 2, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    endpoint_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n\n    if (is_rpmsg_ept_ready(&self->ep) == false) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Endpoint not ready\"));\n    }\n\n    uint32_t src = self->ep.addr;\n    if (args[ARG_src].u_int != -1) {\n        src = args[ARG_src].u_int;\n    }\n\n    uint32_t dest = self->ep.dest_addr;\n    if (args[ARG_dest].u_int != -1) {\n        dest = args[ARG_dest].u_int;\n    }\n\n    mp_buffer_info_t rbuf;\n    mp_get_buffer_raise(pos_args[1], &rbuf, MP_BUFFER_READ);\n    metal_log(METAL_LOG_DEBUG, \"endpoint_send() msg len: %d\\n\", rbuf.len);\n\n    int bytes = 0;\n    mp_int_t timeout = args[ARG_timeout].u_int;\n    for (mp_uint_t start = mp_hal_ticks_ms(); ;) {\n        bytes = rpmsg_send_offchannel_raw(&self->ep, src, dest, rbuf.buf, rbuf.len, false);\n        if (bytes > 0 || timeout == 0) {\n            MICROPY_EVENT_POLL_HOOK\n            break;\n        }\n        if (timeout > 0 && (mp_hal_ticks_ms() - start > timeout)) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"timeout waiting for a free buffer\"));\n        }\n        MICROPY_EVENT_POLL_HOOK\n    }\n    return mp_obj_new_int(bytes);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(endpoint_send_obj, 2, endpoint_send);\n\nstatic mp_obj_t endpoint_is_ready(mp_obj_t self_in) {\n    endpoint_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    return is_rpmsg_ept_ready(&self->ep) ? mp_const_true : mp_const_false;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(endpoint_is_ready_obj, endpoint_is_ready);\n\nstatic mp_obj_t endpoint_deinit(mp_obj_t self_in) {\n    endpoint_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    rpmsg_destroy_ept(&self->ep);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(endpoint_deinit_obj, endpoint_deinit);\n\nstatic mp_obj_t endpoint_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {\n    enum { ARG_name, ARG_callback, ARG_src, ARG_dest };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_name, MP_ARG_OBJ | MP_ARG_REQUIRED,  {.u_rom_obj = MP_ROM_NONE } },\n        { MP_QSTR_callback, MP_ARG_OBJ | MP_ARG_REQUIRED, {.u_rom_obj = MP_ROM_NONE } },\n        { MP_QSTR_src, MP_ARG_INT | MP_ARG_KW_ONLY,  {.u_int = RPMSG_ADDR_ANY } },\n        { MP_QSTR_dest, MP_ARG_INT | MP_ARG_KW_ONLY,  {.u_int = RPMSG_ADDR_ANY } },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    endpoint_obj_t *self = mp_obj_malloc_with_finaliser(endpoint_obj_t, &endpoint_type);\n    self->name = args[ARG_name].u_obj;\n    self->callback = args[ARG_callback].u_obj;\n\n    if (MP_STATE_PORT(virtio_device) == NULL) {\n        openamp_init();\n    }\n\n    if (rpmsg_create_ept(&self->ep, &MP_STATE_PORT(virtio_device)->rvdev.rdev, mp_obj_str_get_str(self->name),\n        args[ARG_src].u_int, args[ARG_dest].u_int, endpoint_recv_callback, NULL) != 0) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to create RPMsg endpoint\"));\n    }\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic const mp_rom_map_elem_t endpoint_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_Endpoint) },\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&endpoint_deinit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_send), MP_ROM_PTR(&endpoint_send_obj) },\n    { MP_ROM_QSTR(MP_QSTR_is_ready), MP_ROM_PTR(&endpoint_is_ready_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(endpoint_locals_dict, endpoint_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    endpoint_type,\n    MP_QSTR_Endpoint,\n    MP_TYPE_FLAG_NONE,\n    make_new, endpoint_make_new,\n    locals_dict, &endpoint_locals_dict\n    );\n\n\nvoid openamp_remoteproc_notified(mp_sched_node_t *node) {\n    (void)node;\n    rproc_virtio_notified(MP_STATE_PORT(virtio_device)->rvdev.vdev, VRING_NOTIFY_ID);\n}\n\nstatic void openamp_ns_callback(struct rpmsg_device *rdev, const char *name, uint32_t dest) {\n    metal_log(METAL_LOG_DEBUG, \"rpmsg_new_service_callback() new service request name: %s dest %lu\\n\", name, dest);\n    \n    \n    virtio_dev_obj_t *virtio_device = metal_container_of(rdev, virtio_dev_obj_t, rvdev);\n    if (virtio_device->ns_callback != mp_const_none) {\n        mp_call_function_2(virtio_device->ns_callback, mp_obj_new_int(dest), mp_obj_new_str(name, strlen(name)));\n    }\n}\n\n#if MICROPY_PY_OPENAMP_RSC_TABLE_ENABLE\n\n\n\nstatic void openamp_rsc_table_init(openamp_rsc_table_t **rsc_table_out) {\n    openamp_rsc_table_t *rsc_table = METAL_RSC_ADDR;\n    memset(rsc_table, 0, METAL_RSC_SIZE);\n\n    rsc_table->version = 1;\n    rsc_table->num = MP_ARRAY_SIZE(rsc_table->offset);\n    rsc_table->offset[0] = offsetof(openamp_rsc_table_t, vdev);\n    #if MICROPY_PY_OPENAMP_TRACE_BUF_ENABLE\n    rsc_table->offset[1] = offsetof(openamp_rsc_table_t, trace);\n    #endif\n    rsc_table->vdev = (struct fw_rsc_vdev) {\n        RSC_VDEV, VIRTIO_ID_RPMSG, 0, VIRTIO_DEV_FEATURES, 0, 0, 0, VRING_COUNT, {0, 0}\n    };\n    rsc_table->vring0 = (struct fw_rsc_vdev_vring) {\n        VRING_TX_ADDR, VRING_ALIGNMENT, VRING_NUM_BUFFS, VRING0_ID, 0\n    };\n    rsc_table->vring1 = (struct fw_rsc_vdev_vring) {\n        VRING_RX_ADDR, VRING_ALIGNMENT, VRING_NUM_BUFFS, VRING1_ID, 0\n    };\n    #if MICROPY_PY_OPENAMP_TRACE_BUF_ENABLE\n    rsc_table->trace = (struct fw_rsc_trace) {\n        RSC_TRACE, MICROPY_PY_OPENAMP_TRACE_BUF, MICROPY_PY_OPENAMP_TRACE_BUF_LEN, 0, \"trace_buf\"\n    };\n    #endif\n    #ifdef VIRTIO_USE_DCACHE\n    \n    metal_cache_flush((uint32_t *)rsc_table, sizeof(openamp_rsc_table_t));\n    #endif\n    *rsc_table_out = rsc_table;\n}\n#endif \n\nstatic mp_obj_t openamp_new_service_callback(mp_obj_t ns_callback) {\n    if (MP_STATE_PORT(virtio_device) == NULL) {\n        openamp_init();\n    }\n    if (ns_callback != mp_const_none && !mp_obj_is_callable(ns_callback)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"invalid callback\"));\n    }\n    MP_STATE_PORT(virtio_device)->ns_callback = ns_callback;\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(openamp_new_service_callback_obj, openamp_new_service_callback);\n\nvoid openamp_metal_log_handler(enum metal_log_level level, const char *fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    mp_vprintf(&mp_plat_print, fmt, args);\n    va_end(args);\n}\n\nvoid openamp_init(void) {\n    if (MP_STATE_PORT(virtio_device) != NULL) {\n        \n        return;\n    }\n\n    struct metal_device *device;\n    struct metal_init_params metal_params = { 0 };\n\n    #if METAL_LOG_HANDLER_ENABLE\n    \n    \n    metal_params.log_level = METAL_LOG_DEBUG;\n    metal_params.log_handler = openamp_metal_log_handler;\n    #endif\n\n    \n    metal_init(&metal_params);\n\n    \n    openamp_rsc_table_t *rsc_table;\n    openamp_rsc_table_init(&rsc_table);\n\n    if (metal_register_generic_device(&shm_device) != 0) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to register metal device\"));\n    }\n\n    if (metal_device_open(\"generic\", METAL_SHM_NAME, &device) != 0) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to open metal device\"));\n    }\n\n    \n    metal_io_init(&device->regions[0], (void *)METAL_SHM_ADDR, (void *)shm_physmap, METAL_SHM_SIZE, -1U, 0, NULL);\n    struct metal_io_region *shm_io = metal_device_io_region(device, 0);\n    if (shm_io == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to initialize device io region\"));\n    }\n\n    \n    metal_io_init(&device->regions[1], (void *)rsc_table, (void *)rsc_table, sizeof(*rsc_table), -1U, 0, NULL);\n    struct metal_io_region *rsc_io = metal_device_io_region(device, 1);\n    if (rsc_io == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to initialize device io region\"));\n    }\n\n    \n    struct virtio_device *vdev = rproc_virtio_create_vdev(RPMSG_HOST, VIRTIO_DEV_ID,\n        &rsc_table->vdev, rsc_io, NULL, metal_rproc_notify, NULL);\n    if (vdev == NULL) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to create virtio device\"));\n    }\n\n    \n    struct fw_rsc_vdev_vring *vring_rsc = &rsc_table->vring0;\n    for (int i = 0; i < VRING_COUNT; i++, vring_rsc++) {\n        if (rproc_virtio_init_vring(vdev, vring_rsc->notifyid, vring_rsc->notifyid,\n            (void *)vring_rsc->da, shm_io, vring_rsc->num, vring_rsc->align) != 0) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"Failed to initialize vrings\"));\n        }\n    }\n\n    virtio_dev_obj_t *virtio_device = mp_obj_malloc_with_finaliser(virtio_dev_obj_t, &virtio_dev_type);\n    virtio_device->ns_callback = mp_const_none;\n\n    \n    \n    rpmsg_virtio_init_shm_pool(&virtio_device->shm_pool, (void *)VRING_BUFF_ADDR, (size_t)VRING_BUFF_SIZE);\n    rpmsg_init_vdev(&virtio_device->rvdev, vdev, openamp_ns_callback, shm_io, &virtio_device->shm_pool);\n\n    MP_STATE_PORT(virtio_device) = virtio_device;\n}\n\nstatic const mp_rom_map_elem_t globals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_openamp) },\n    { MP_ROM_QSTR(MP_QSTR_ENDPOINT_ADDR_ANY), MP_ROM_INT(RPMSG_ADDR_ANY) },\n    { MP_ROM_QSTR(MP_QSTR_new_service_callback), MP_ROM_PTR(&openamp_new_service_callback_obj) },\n    { MP_ROM_QSTR(MP_QSTR_Endpoint), MP_ROM_PTR(&endpoint_type) },\n    #if MICROPY_PY_OPENAMP_REMOTEPROC\n    { MP_ROM_QSTR(MP_QSTR_RemoteProc), MP_ROM_PTR(&openamp_remoteproc_type) },\n    #endif\n};\nstatic MP_DEFINE_CONST_DICT(globals_dict, globals_dict_table);\n\nconst mp_obj_module_t openamp_module = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_t)&globals_dict,\n};\n\nMP_REGISTER_ROOT_POINTER(struct _virtio_dev_obj_t *virtio_device);\nMP_REGISTER_MODULE(MP_QSTR_openamp, openamp_module);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}