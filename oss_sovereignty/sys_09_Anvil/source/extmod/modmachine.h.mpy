{
  "module_name": "modmachine.h",
  "hash_id": "42ef040e8de97d7dd3fc6f6fc5cc4c8408477545683228bd44047b2cb0ec0e66",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modmachine.h",
  "human_readable_source": " \n\n#ifndef MICROPY_INCLUDED_EXTMOD_MODMACHINE_H\n#define MICROPY_INCLUDED_EXTMOD_MODMACHINE_H\n\n#include \"py/mphal.h\"\n#include \"py/obj.h\"\n\n#if MICROPY_PY_MACHINE_SPI || MICROPY_PY_MACHINE_SOFTSPI\n#include \"drivers/bus/spi.h\"\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_ADC_INIT\n#define MICROPY_PY_MACHINE_ADC_INIT (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_ADC_DEINIT\n#define MICROPY_PY_MACHINE_ADC_DEINIT (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_ADC_BLOCK\n#define MICROPY_PY_MACHINE_ADC_BLOCK (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_ADC_READ_UV\n#define MICROPY_PY_MACHINE_ADC_READ_UV (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_ADC_ATTEN_WIDTH\n#define MICROPY_PY_MACHINE_ADC_ATTEN_WIDTH (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_ADC_READ\n#define MICROPY_PY_MACHINE_ADC_READ (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_UART_SENDBREAK\n#define MICROPY_PY_MACHINE_UART_SENDBREAK (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_UART_READCHAR_WRITECHAR\n#define MICROPY_PY_MACHINE_UART_READCHAR_WRITECHAR (0)\n#endif\n\n\n\n#ifndef MICROPY_PY_MACHINE_UART_IRQ\n#define MICROPY_PY_MACHINE_UART_IRQ (0)\n#endif\n\n\n#define MP_MACHINE_I2C_CHECK_FOR_LEGACY_SOFTI2C_CONSTRUCTION(n_args, n_kw, all_args) \\\n    do { \\\n        if (n_args == 0 || all_args[0] == MP_OBJ_NEW_SMALL_INT(-1)) { \\\n            mp_print_str(MICROPY_ERROR_PRINTER, \"Warning: I2C(-1, ...) is deprecated, use SoftI2C(...) instead\\n\"); \\\n            if (n_args != 0) { \\\n                --n_args; \\\n                ++all_args; \\\n            } \\\n            return MP_OBJ_TYPE_GET_SLOT(&mp_machine_soft_i2c_type, make_new)(&mp_machine_soft_i2c_type, n_args, n_kw, all_args); \\\n        } \\\n    } while (0)\n\n\n#define MP_MACHINE_SPI_CHECK_FOR_LEGACY_SOFTSPI_CONSTRUCTION(n_args, n_kw, all_args) \\\n    do { \\\n        if (n_args == 0 || all_args[0] == MP_OBJ_NEW_SMALL_INT(-1)) { \\\n            mp_print_str(MICROPY_ERROR_PRINTER, \"Warning: SPI(-1, ...) is deprecated, use SoftSPI(...) instead\\n\"); \\\n            if (n_args != 0) { \\\n                --n_args; \\\n                ++all_args; \\\n            } \\\n            return MP_OBJ_TYPE_GET_SLOT(&mp_machine_soft_spi_type, make_new)(&mp_machine_soft_spi_type, n_args, n_kw, all_args); \\\n        } \\\n    } while (0)\n\n#if MICROPY_PY_MACHINE_I2C || MICROPY_PY_MACHINE_SOFTI2C\n\n#define MP_MACHINE_I2C_FLAG_READ (0x01) \n#define MP_MACHINE_I2C_FLAG_STOP (0x02)\n\n#if MICROPY_PY_MACHINE_I2C_TRANSFER_WRITE1\n\n#define MP_MACHINE_I2C_FLAG_WRITE1 (0x04)\n#endif\n\n#endif\n\n\ntypedef struct _machine_adc_obj_t machine_adc_obj_t;\ntypedef struct _machine_adc_block_obj_t machine_adc_block_obj_t;\ntypedef struct _machine_i2s_obj_t machine_i2s_obj_t;\ntypedef struct _machine_pwm_obj_t machine_pwm_obj_t;\ntypedef struct _machine_uart_obj_t machine_uart_obj_t;\ntypedef struct _machine_wdt_obj_t machine_wdt_obj_t;\n\ntypedef struct _machine_mem_obj_t {\n    mp_obj_base_t base;\n    unsigned elem_size; \n} machine_mem_obj_t;\n\n#if MICROPY_PY_MACHINE_I2C || MICROPY_PY_MACHINE_SOFTI2C\n\ntypedef struct _mp_machine_i2c_buf_t {\n    size_t len;\n    uint8_t *buf;\n} mp_machine_i2c_buf_t;\n\n\n\n\n\n\ntypedef struct _mp_machine_i2c_p_t {\n    #if MICROPY_PY_MACHINE_I2C_TRANSFER_WRITE1\n    bool transfer_supports_write1;\n    #endif\n    void (*init)(mp_obj_base_t *obj, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args);\n    int (*start)(mp_obj_base_t *obj);\n    int (*stop)(mp_obj_base_t *obj);\n    int (*read)(mp_obj_base_t *obj, uint8_t *dest, size_t len, bool nack);\n    int (*write)(mp_obj_base_t *obj, const uint8_t *src, size_t len);\n    int (*transfer)(mp_obj_base_t *obj, uint16_t addr, size_t n, mp_machine_i2c_buf_t *bufs, unsigned int flags);\n    int (*transfer_single)(mp_obj_base_t *obj, uint16_t addr, size_t len, uint8_t *buf, unsigned int flags);\n} mp_machine_i2c_p_t;\n\n\ntypedef struct _mp_machine_soft_i2c_obj_t {\n    mp_obj_base_t base;\n    uint32_t us_delay;\n    uint32_t us_timeout;\n    mp_hal_pin_obj_t scl;\n    mp_hal_pin_obj_t sda;\n} mp_machine_soft_i2c_obj_t;\n\n#endif\n\n#if MICROPY_PY_MACHINE_SPI || MICROPY_PY_MACHINE_SOFTSPI\n\n\ntypedef struct _mp_machine_spi_p_t {\n    void (*init)(mp_obj_base_t *obj, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args);\n    void (*deinit)(mp_obj_base_t *obj); \n    void (*transfer)(mp_obj_base_t *obj, size_t len, const uint8_t *src, uint8_t *dest);\n} mp_machine_spi_p_t;\n\n\ntypedef struct _mp_machine_soft_spi_obj_t {\n    mp_obj_base_t base;\n    mp_soft_spi_obj_t spi;\n} mp_machine_soft_spi_obj_t;\n\n#endif\n\n\nextern const machine_mem_obj_t machine_mem8_obj;\nextern const machine_mem_obj_t machine_mem16_obj;\nextern const machine_mem_obj_t machine_mem32_obj;\n\n\n\n\nextern const mp_obj_type_t machine_adc_type;\nextern const mp_obj_type_t machine_adc_block_type;\nextern const mp_obj_type_t machine_i2c_type;\nextern const mp_obj_type_t machine_i2s_type;\nextern const mp_obj_type_t machine_mem_type;\nextern const mp_obj_type_t machine_pin_type;\nextern const mp_obj_type_t machine_pinbase_type;\nextern const mp_obj_type_t machine_pwm_type;\nextern const mp_obj_type_t machine_rtc_type;\nextern const mp_obj_type_t machine_signal_type;\nextern const mp_obj_type_t machine_spi_type;\nextern const mp_obj_type_t machine_timer_type;\nextern const mp_obj_type_t machine_uart_type;\nextern const mp_obj_type_t machine_usbd_type;\nextern const mp_obj_type_t machine_wdt_type;\n\n#if MICROPY_PY_MACHINE_SOFTI2C\nextern const mp_obj_type_t mp_machine_soft_i2c_type;\n#endif\n#if MICROPY_PY_MACHINE_I2C || MICROPY_PY_MACHINE_SOFTI2C\nextern const mp_obj_dict_t mp_machine_i2c_locals_dict;\n#endif\n\n#if MICROPY_PY_MACHINE_SOFTSPI\nextern const mp_obj_type_t mp_machine_soft_spi_type;\nextern const mp_machine_spi_p_t mp_machine_soft_spi_p;\n#endif\n#if MICROPY_PY_MACHINE_SPI || MICROPY_PY_MACHINE_SOFTSPI\nextern const mp_obj_dict_t mp_machine_spi_locals_dict;\n#endif\n\n#if MICROPY_HW_ENABLE_USB_RUNTIME_DEVICE\nextern const mp_obj_type_t machine_usb_device_type;\n#endif\n\n#if defined(MICROPY_MACHINE_MEM_GET_READ_ADDR)\nuintptr_t MICROPY_MACHINE_MEM_GET_READ_ADDR(mp_obj_t addr_o, uint align);\n#endif\n#if defined(MICROPY_MACHINE_MEM_GET_WRITE_ADDR)\nuintptr_t MICROPY_MACHINE_MEM_GET_WRITE_ADDR(mp_obj_t addr_o, uint align);\n#endif\n\nNORETURN mp_obj_t machine_bootloader(size_t n_args, const mp_obj_t *args);\nvoid machine_bitstream_high_low(mp_hal_pin_obj_t pin, uint32_t *timing_ns, const uint8_t *buf, size_t len);\nmp_uint_t machine_time_pulse_us(mp_hal_pin_obj_t pin, int pulse_level, mp_uint_t timeout_us);\n\nMP_DECLARE_CONST_FUN_OBJ_0(machine_unique_id_obj);\nMP_DECLARE_CONST_FUN_OBJ_0(machine_reset_obj);\nMP_DECLARE_CONST_FUN_OBJ_0(machine_reset_cause_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(machine_freq_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(machine_lightsleep_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(machine_deepsleep_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(machine_bootloader_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(machine_bitstream_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(machine_time_pulse_us_obj);\n\n#if MICROPY_PY_MACHINE_I2C\nint mp_machine_i2c_transfer_adaptor(mp_obj_base_t *self, uint16_t addr, size_t n, mp_machine_i2c_buf_t *bufs, unsigned int flags);\nint mp_machine_soft_i2c_transfer(mp_obj_base_t *self, uint16_t addr, size_t n, mp_machine_i2c_buf_t *bufs, unsigned int flags);\n#endif\n\n#if MICROPY_PY_MACHINE_SPI\nmp_obj_t mp_machine_spi_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(mp_machine_spi_read_obj);\nMP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(mp_machine_spi_readinto_obj);\nMP_DECLARE_CONST_FUN_OBJ_2(mp_machine_spi_write_obj);\nMP_DECLARE_CONST_FUN_OBJ_3(mp_machine_spi_write_readinto_obj);\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}