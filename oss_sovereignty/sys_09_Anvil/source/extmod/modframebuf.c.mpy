{
  "module_name": "modframebuf.c",
  "hash_id": "d89f7dbb6ecea58653dbbf8f9c6d84c2783d6e001d7248c9adb6b83a5d9545f2",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modframebuf.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n\n#if MICROPY_PY_FRAMEBUF\n\n#include \"extmod/font_petme128_8x8.h\"\n\ntypedef struct _mp_obj_framebuf_t {\n    mp_obj_base_t base;\n    mp_obj_t buf_obj; \n    void *buf;\n    uint16_t width, height, stride;\n    uint8_t format;\n} mp_obj_framebuf_t;\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_obj_type_t mp_type_framebuf;\n#endif\n\ntypedef void (*setpixel_t)(const mp_obj_framebuf_t *, unsigned int, unsigned int, uint32_t);\ntypedef uint32_t (*getpixel_t)(const mp_obj_framebuf_t *, unsigned int, unsigned int);\ntypedef void (*fill_rect_t)(const mp_obj_framebuf_t *, unsigned int, unsigned int, unsigned int, unsigned int, uint32_t);\n\ntypedef struct _mp_framebuf_p_t {\n    setpixel_t setpixel;\n    getpixel_t getpixel;\n    fill_rect_t fill_rect;\n} mp_framebuf_p_t;\n\n\n#define FRAMEBUF_MVLSB    (0)\n#define FRAMEBUF_RGB565   (1)\n#define FRAMEBUF_GS2_HMSB (5)\n#define FRAMEBUF_GS4_HMSB (2)\n#define FRAMEBUF_GS8      (6)\n#define FRAMEBUF_MHLSB    (3)\n#define FRAMEBUF_MHMSB    (4)\n\n\n\nstatic void mono_horiz_setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    size_t index = (x + y * fb->stride) >> 3;\n    unsigned int offset = fb->format == FRAMEBUF_MHMSB ? x & 0x07 : 7 - (x & 0x07);\n    ((uint8_t *)fb->buf)[index] = (((uint8_t *)fb->buf)[index] & ~(0x01 << offset)) | ((col != 0) << offset);\n}\n\nstatic uint32_t mono_horiz_getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    size_t index = (x + y * fb->stride) >> 3;\n    unsigned int offset = fb->format == FRAMEBUF_MHMSB ? x & 0x07 : 7 - (x & 0x07);\n    return (((uint8_t *)fb->buf)[index] >> (offset)) & 0x01;\n}\n\nstatic void mono_horiz_fill_rect(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, unsigned int w, unsigned int h, uint32_t col) {\n    unsigned int reverse = fb->format == FRAMEBUF_MHMSB;\n    unsigned int advance = fb->stride >> 3;\n    while (w--) {\n        uint8_t *b = &((uint8_t *)fb->buf)[(x >> 3) + y * advance];\n        unsigned int offset = reverse ?  x & 7 : 7 - (x & 7);\n        for (unsigned int hh = h; hh; --hh) {\n            *b = (*b & ~(0x01 << offset)) | ((col != 0) << offset);\n            b += advance;\n        }\n        ++x;\n    }\n}\n\n\n\nstatic void mvlsb_setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    size_t index = (y >> 3) * fb->stride + x;\n    uint8_t offset = y & 0x07;\n    ((uint8_t *)fb->buf)[index] = (((uint8_t *)fb->buf)[index] & ~(0x01 << offset)) | ((col != 0) << offset);\n}\n\nstatic uint32_t mvlsb_getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    return (((uint8_t *)fb->buf)[(y >> 3) * fb->stride + x] >> (y & 0x07)) & 0x01;\n}\n\nstatic void mvlsb_fill_rect(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, unsigned int w, unsigned int h, uint32_t col) {\n    while (h--) {\n        uint8_t *b = &((uint8_t *)fb->buf)[(y >> 3) * fb->stride + x];\n        uint8_t offset = y & 0x07;\n        for (unsigned int ww = w; ww; --ww) {\n            *b = (*b & ~(0x01 << offset)) | ((col != 0) << offset);\n            ++b;\n        }\n        ++y;\n    }\n}\n\n\n\nstatic void rgb565_setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    ((uint16_t *)fb->buf)[x + y * fb->stride] = col;\n}\n\nstatic uint32_t rgb565_getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    return ((uint16_t *)fb->buf)[x + y * fb->stride];\n}\n\nstatic void rgb565_fill_rect(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, unsigned int w, unsigned int h, uint32_t col) {\n    uint16_t *b = &((uint16_t *)fb->buf)[x + y * fb->stride];\n    while (h--) {\n        for (unsigned int ww = w; ww; --ww) {\n            *b++ = col;\n        }\n        b += fb->stride - w;\n    }\n}\n\n\n\nstatic void gs2_hmsb_setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    uint8_t *pixel = &((uint8_t *)fb->buf)[(x + y * fb->stride) >> 2];\n    uint8_t shift = (x & 0x3) << 1;\n    uint8_t mask = 0x3 << shift;\n    uint8_t color = (col & 0x3) << shift;\n    *pixel = color | (*pixel & (~mask));\n}\n\nstatic uint32_t gs2_hmsb_getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    uint8_t pixel = ((uint8_t *)fb->buf)[(x + y * fb->stride) >> 2];\n    uint8_t shift = (x & 0x3) << 1;\n    return (pixel >> shift) & 0x3;\n}\n\nstatic void gs2_hmsb_fill_rect(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, unsigned int w, unsigned int h, uint32_t col) {\n    for (unsigned int xx = x; xx < x + w; xx++) {\n        for (unsigned int yy = y; yy < y + h; yy++) {\n            gs2_hmsb_setpixel(fb, xx, yy, col);\n        }\n    }\n}\n\n\n\nstatic void gs4_hmsb_setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    uint8_t *pixel = &((uint8_t *)fb->buf)[(x + y * fb->stride) >> 1];\n\n    if (x % 2) {\n        *pixel = ((uint8_t)col & 0x0f) | (*pixel & 0xf0);\n    } else {\n        *pixel = ((uint8_t)col << 4) | (*pixel & 0x0f);\n    }\n}\n\nstatic uint32_t gs4_hmsb_getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    if (x % 2) {\n        return ((uint8_t *)fb->buf)[(x + y * fb->stride) >> 1] & 0x0f;\n    }\n\n    return ((uint8_t *)fb->buf)[(x + y * fb->stride) >> 1] >> 4;\n}\n\nstatic void gs4_hmsb_fill_rect(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, unsigned int w, unsigned int h, uint32_t col) {\n    col &= 0x0f;\n    uint8_t *pixel_pair = &((uint8_t *)fb->buf)[(x + y * fb->stride) >> 1];\n    uint8_t col_shifted_left = col << 4;\n    uint8_t col_pixel_pair = col_shifted_left | col;\n    unsigned int pixel_count_till_next_line = (fb->stride - w) >> 1;\n    bool odd_x = (x % 2 == 1);\n\n    while (h--) {\n        unsigned int ww = w;\n\n        if (odd_x && ww > 0) {\n            *pixel_pair = (*pixel_pair & 0xf0) | col;\n            pixel_pair++;\n            ww--;\n        }\n\n        memset(pixel_pair, col_pixel_pair, ww >> 1);\n        pixel_pair += ww >> 1;\n\n        if (ww % 2) {\n            *pixel_pair = col_shifted_left | (*pixel_pair & 0x0f);\n            if (!odd_x) {\n                pixel_pair++;\n            }\n        }\n\n        pixel_pair += pixel_count_till_next_line;\n    }\n}\n\n\n\nstatic void gs8_setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    uint8_t *pixel = &((uint8_t *)fb->buf)[(x + y * fb->stride)];\n    *pixel = col & 0xff;\n}\n\nstatic uint32_t gs8_getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    return ((uint8_t *)fb->buf)[(x + y * fb->stride)];\n}\n\nstatic void gs8_fill_rect(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, unsigned int w, unsigned int h, uint32_t col) {\n    uint8_t *pixel = &((uint8_t *)fb->buf)[(x + y * fb->stride)];\n    while (h--) {\n        memset(pixel, col, w);\n        pixel += fb->stride;\n    }\n}\n\nstatic mp_framebuf_p_t formats[] = {\n    [FRAMEBUF_MVLSB] = {mvlsb_setpixel, mvlsb_getpixel, mvlsb_fill_rect},\n    [FRAMEBUF_RGB565] = {rgb565_setpixel, rgb565_getpixel, rgb565_fill_rect},\n    [FRAMEBUF_GS2_HMSB] = {gs2_hmsb_setpixel, gs2_hmsb_getpixel, gs2_hmsb_fill_rect},\n    [FRAMEBUF_GS4_HMSB] = {gs4_hmsb_setpixel, gs4_hmsb_getpixel, gs4_hmsb_fill_rect},\n    [FRAMEBUF_GS8] = {gs8_setpixel, gs8_getpixel, gs8_fill_rect},\n    [FRAMEBUF_MHLSB] = {mono_horiz_setpixel, mono_horiz_getpixel, mono_horiz_fill_rect},\n    [FRAMEBUF_MHMSB] = {mono_horiz_setpixel, mono_horiz_getpixel, mono_horiz_fill_rect},\n};\n\nstatic inline void setpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y, uint32_t col) {\n    formats[fb->format].setpixel(fb, x, y, col);\n}\n\nstatic void setpixel_checked(const mp_obj_framebuf_t *fb, mp_int_t x, mp_int_t y, mp_int_t col, mp_int_t mask) {\n    if (mask && 0 <= x && x < fb->width && 0 <= y && y < fb->height) {\n        setpixel(fb, x, y, col);\n    }\n}\n\nstatic inline uint32_t getpixel(const mp_obj_framebuf_t *fb, unsigned int x, unsigned int y) {\n    return formats[fb->format].getpixel(fb, x, y);\n}\n\nstatic void fill_rect(const mp_obj_framebuf_t *fb, int x, int y, int w, int h, uint32_t col) {\n    if (h < 1 || w < 1 || x + w <= 0 || y + h <= 0 || y >= fb->height || x >= fb->width) {\n        \n        return;\n    }\n\n    \n    int xend = MIN(fb->width, x + w);\n    int yend = MIN(fb->height, y + h);\n    x = MAX(x, 0);\n    y = MAX(y, 0);\n\n    formats[fb->format].fill_rect(fb, x, y, xend - x, yend - y, col);\n}\n\nstatic mp_obj_t framebuf_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args_in) {\n    mp_arg_check_num(n_args, n_kw, 4, 5, false);\n\n    mp_int_t width = mp_obj_get_int(args_in[1]);\n    mp_int_t height = mp_obj_get_int(args_in[2]);\n    mp_int_t format = mp_obj_get_int(args_in[3]);\n    mp_int_t stride = n_args >= 5 ? mp_obj_get_int(args_in[4]) : width;\n\n    if (width < 1 || height < 1 || width > 0xffff || height > 0xffff || stride > 0xffff || stride < width) {\n        mp_raise_ValueError(NULL);\n    }\n\n    size_t height_required = height;\n    size_t bpp = 1;\n\n    switch (format) {\n        case FRAMEBUF_MVLSB:\n            height_required = (height + 7) & ~7;\n            break;\n        case FRAMEBUF_MHLSB:\n        case FRAMEBUF_MHMSB:\n            stride = (stride + 7) & ~7;\n            break;\n        case FRAMEBUF_GS2_HMSB:\n            stride = (stride + 3) & ~3;\n            bpp = 2;\n            break;\n        case FRAMEBUF_GS4_HMSB:\n            stride = (stride + 1) & ~1;\n            bpp = 4;\n            break;\n        case FRAMEBUF_GS8:\n            bpp = 8;\n            break;\n        case FRAMEBUF_RGB565:\n            bpp = 16;\n            break;\n        default:\n            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid format\"));\n    }\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args_in[0], &bufinfo, MP_BUFFER_WRITE);\n\n    if (height_required * stride * bpp / 8 > bufinfo.len) {\n        mp_raise_ValueError(NULL);\n    }\n\n    mp_obj_framebuf_t *o = mp_obj_malloc(mp_obj_framebuf_t, type);\n    o->buf_obj = args_in[0];\n    o->buf = bufinfo.buf;\n    o->width = width;\n    o->height = height;\n    o->format = format;\n    o->stride = stride;\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic void framebuf_args(const mp_obj_t *args_in, mp_int_t *args_out, int n) {\n    for (int i = 0; i < n; ++i) {\n        args_out[i] = mp_obj_get_int(args_in[i + 1]);\n    }\n}\n\nstatic mp_int_t framebuf_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_get_buffer(self->buf_obj, bufinfo, flags) ? 0 : 1;\n}\n\nstatic mp_obj_t framebuf_fill(mp_obj_t self_in, mp_obj_t col_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_int_t col = mp_obj_get_int(col_in);\n    formats[self->format].fill_rect(self, 0, 0, self->width, self->height, col);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(framebuf_fill_obj, framebuf_fill);\n\nstatic mp_obj_t framebuf_fill_rect(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t args[5]; \n    framebuf_args(args_in, args, 5);\n    fill_rect(self, args[0], args[1], args[2], args[3], args[4]);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_fill_rect_obj, 6, 6, framebuf_fill_rect);\n\nstatic mp_obj_t framebuf_pixel(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t x = mp_obj_get_int(args_in[1]);\n    mp_int_t y = mp_obj_get_int(args_in[2]);\n    if (0 <= x && x < self->width && 0 <= y && y < self->height) {\n        if (n_args == 3) {\n            \n            return MP_OBJ_NEW_SMALL_INT(getpixel(self, x, y));\n        } else {\n            \n            setpixel(self, x, y, mp_obj_get_int(args_in[3]));\n        }\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_pixel_obj, 3, 4, framebuf_pixel);\n\nstatic mp_obj_t framebuf_hline(size_t n_args, const mp_obj_t *args_in) {\n    (void)n_args;\n\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t args[4]; \n    framebuf_args(args_in, args, 4);\n\n    fill_rect(self, args[0], args[1], args[2], 1, args[3]);\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_hline_obj, 5, 5, framebuf_hline);\n\nstatic mp_obj_t framebuf_vline(size_t n_args, const mp_obj_t *args_in) {\n    (void)n_args;\n\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t args[4]; \n    framebuf_args(args_in, args, 4);\n\n    fill_rect(self, args[0], args[1], 1, args[2], args[3]);\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_vline_obj, 5, 5, framebuf_vline);\n\nstatic mp_obj_t framebuf_rect(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t args[5]; \n    framebuf_args(args_in, args, 5);\n    if (n_args > 6 && mp_obj_is_true(args_in[6])) {\n        fill_rect(self, args[0], args[1], args[2], args[3], args[4]);\n    } else {\n        fill_rect(self, args[0], args[1], args[2], 1, args[4]);\n        fill_rect(self, args[0], args[1] + args[3] - 1, args[2], 1, args[4]);\n        fill_rect(self, args[0], args[1], 1, args[3], args[4]);\n        fill_rect(self, args[0] + args[2] - 1, args[1], 1, args[3], args[4]);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_rect_obj, 6, 7, framebuf_rect);\n\nstatic void line(const mp_obj_framebuf_t *fb, mp_int_t x1, mp_int_t y1, mp_int_t x2, mp_int_t y2, mp_int_t col) {\n    mp_int_t dx = x2 - x1;\n    mp_int_t sx;\n    if (dx > 0) {\n        sx = 1;\n    } else {\n        dx = -dx;\n        sx = -1;\n    }\n\n    mp_int_t dy = y2 - y1;\n    mp_int_t sy;\n    if (dy > 0) {\n        sy = 1;\n    } else {\n        dy = -dy;\n        sy = -1;\n    }\n\n    bool steep;\n    if (dy > dx) {\n        mp_int_t temp;\n        temp = x1;\n        x1 = y1;\n        y1 = temp;\n        temp = dx;\n        dx = dy;\n        dy = temp;\n        temp = sx;\n        sx = sy;\n        sy = temp;\n        steep = true;\n    } else {\n        steep = false;\n    }\n\n    mp_int_t e = 2 * dy - dx;\n    for (mp_int_t i = 0; i < dx; ++i) {\n        if (steep) {\n            if (0 <= y1 && y1 < fb->width && 0 <= x1 && x1 < fb->height) {\n                setpixel(fb, y1, x1, col);\n            }\n        } else {\n            if (0 <= x1 && x1 < fb->width && 0 <= y1 && y1 < fb->height) {\n                setpixel(fb, x1, y1, col);\n            }\n        }\n        while (e >= 0) {\n            y1 += sy;\n            e -= 2 * dx;\n        }\n        x1 += sx;\n        e += 2 * dy;\n    }\n\n    if (0 <= x2 && x2 < fb->width && 0 <= y2 && y2 < fb->height) {\n        setpixel(fb, x2, y2, col);\n    }\n}\n\nstatic mp_obj_t framebuf_line(size_t n_args, const mp_obj_t *args_in) {\n    (void)n_args;\n\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t args[5]; \n    framebuf_args(args_in, args, 5);\n\n    line(self, args[0], args[1], args[2], args[3], args[4]);\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_line_obj, 6, 6, framebuf_line);\n\n\n\n#define ELLIPSE_MASK_FILL (0x10)\n#define ELLIPSE_MASK_ALL (0x0f)\n#define ELLIPSE_MASK_Q1 (0x01)\n#define ELLIPSE_MASK_Q2 (0x02)\n#define ELLIPSE_MASK_Q3 (0x04)\n#define ELLIPSE_MASK_Q4 (0x08)\n\nstatic void draw_ellipse_points(const mp_obj_framebuf_t *fb, mp_int_t cx, mp_int_t cy, mp_int_t x, mp_int_t y, mp_int_t col, mp_int_t mask) {\n    if (mask & ELLIPSE_MASK_FILL) {\n        if (mask & ELLIPSE_MASK_Q1) {\n            fill_rect(fb, cx, cy - y, x + 1, 1, col);\n        }\n        if (mask & ELLIPSE_MASK_Q2) {\n            fill_rect(fb, cx - x, cy - y, x + 1, 1, col);\n        }\n        if (mask & ELLIPSE_MASK_Q3) {\n            fill_rect(fb, cx - x, cy + y, x + 1, 1, col);\n        }\n        if (mask & ELLIPSE_MASK_Q4) {\n            fill_rect(fb, cx, cy + y, x + 1, 1, col);\n        }\n    } else {\n        setpixel_checked(fb, cx + x, cy - y, col, mask & ELLIPSE_MASK_Q1);\n        setpixel_checked(fb, cx - x, cy - y, col, mask & ELLIPSE_MASK_Q2);\n        setpixel_checked(fb, cx - x, cy + y, col, mask & ELLIPSE_MASK_Q3);\n        setpixel_checked(fb, cx + x, cy + y, col, mask & ELLIPSE_MASK_Q4);\n    }\n}\n\nstatic mp_obj_t framebuf_ellipse(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_int_t args[5];\n    framebuf_args(args_in, args, 5); \n    mp_int_t mask = (n_args > 6 && mp_obj_is_true(args_in[6])) ? ELLIPSE_MASK_FILL : 0;\n    if (n_args > 7) {\n        mask |= mp_obj_get_int(args_in[7]) & ELLIPSE_MASK_ALL;\n    } else {\n        mask |= ELLIPSE_MASK_ALL;\n    }\n    mp_int_t two_asquare = 2 * args[2] * args[2];\n    mp_int_t two_bsquare = 2 * args[3] * args[3];\n    mp_int_t x = args[2];\n    mp_int_t y = 0;\n    mp_int_t xchange = args[3] * args[3] * (1 - 2 * args[2]);\n    mp_int_t ychange = args[2] * args[2];\n    mp_int_t ellipse_error = 0;\n    mp_int_t stoppingx = two_bsquare * args[2];\n    mp_int_t stoppingy = 0;\n    while (stoppingx >= stoppingy) {   \n        draw_ellipse_points(self, args[0], args[1], x, y, args[4], mask);\n        y += 1;\n        stoppingy += two_asquare;\n        ellipse_error += ychange;\n        ychange += two_asquare;\n        if ((2 * ellipse_error + xchange) > 0) {\n            x -= 1;\n            stoppingx -= two_bsquare;\n            ellipse_error += xchange;\n            xchange += two_bsquare;\n        }\n    }\n    \n    x = 0;\n    y = args[3];\n    xchange = args[3] * args[3];\n    ychange = args[2] * args[2] * (1 - 2 * args[3]);\n    ellipse_error = 0;\n    stoppingx = 0;\n    stoppingy = two_asquare * args[3];\n    while (stoppingx <= stoppingy) {  \n        draw_ellipse_points(self, args[0], args[1], x, y, args[4], mask);\n        x += 1;\n        stoppingx += two_bsquare;\n        ellipse_error += xchange;\n        xchange += two_bsquare;\n        if ((2 * ellipse_error + ychange) > 0) {\n            y -= 1;\n            stoppingy -= two_asquare;\n            ellipse_error += ychange;\n            ychange += two_asquare;\n        }\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_ellipse_obj, 6, 8, framebuf_ellipse);\n\n#if MICROPY_PY_ARRAY\n\nstatic mp_int_t poly_int(mp_buffer_info_t *bufinfo, size_t index) {\n    return mp_obj_get_int(mp_binary_get_val_array(bufinfo->typecode, bufinfo->buf, index));\n}\n\nstatic mp_obj_t framebuf_poly(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n\n    mp_int_t x = mp_obj_get_int(args_in[1]);\n    mp_int_t y = mp_obj_get_int(args_in[2]);\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args_in[3], &bufinfo, MP_BUFFER_READ);\n    \n    int n_poly = bufinfo.len / (mp_binary_get_size('@', bufinfo.typecode, NULL) * 2);\n\n    if (n_poly == 0) {\n        return mp_const_none;\n    }\n\n    mp_int_t col = mp_obj_get_int(args_in[4]);\n    bool fill = n_args > 5 && mp_obj_is_true(args_in[5]);\n\n    if (fill) {\n        \n\n        \n        \n        \n\n        \n        \n        mp_int_t y_min = INT_MAX, y_max = INT_MIN;\n        for (int i = 0; i < n_poly; i++) {\n            mp_int_t py = poly_int(&bufinfo, i * 2 + 1);\n            y_min = MIN(y_min, py);\n            y_max = MAX(y_max, py);\n        }\n\n        for (mp_int_t row = y_min; row <= y_max; row++) {\n            \n            mp_int_t nodes[n_poly];\n            int n_nodes = 0;\n            mp_int_t px1 = poly_int(&bufinfo, 0);\n            mp_int_t py1 = poly_int(&bufinfo, 1);\n            int i = n_poly * 2 - 1;\n            do {\n                mp_int_t py2 = poly_int(&bufinfo, i--);\n                mp_int_t px2 = poly_int(&bufinfo, i--);\n\n                \n                \n                \n                \n                if (py1 != py2 && ((py1 > row && py2 <= row) || (py1 <= row && py2 > row))) {\n                    mp_int_t node = (32 * px1 + 32 * (px2 - px1) * (row - py1) / (py2 - py1) + 16) / 32;\n                    nodes[n_nodes++] = node;\n                } else if (row == MAX(py1, py2)) {\n                    \n                    if (py1 < py2) {\n                        setpixel_checked(self, x + px2, y + py2, col, 1);\n                    } else if (py2 < py1) {\n                        setpixel_checked(self, x + px1, y + py1, col, 1);\n                    } else {\n                        \n                        \n                        \n                        line(self, x + px1, y + py1, x + px2, y + py2, col);\n                    }\n                }\n\n                px1 = px2;\n                py1 = py2;\n            } while (i >= 0);\n\n            if (!n_nodes) {\n                continue;\n            }\n\n            \n            i = 0;\n            while (i < n_nodes - 1) {\n                if (nodes[i] > nodes[i + 1]) {\n                    mp_int_t swap = nodes[i];\n                    nodes[i] = nodes[i + 1];\n                    nodes[i + 1] = swap;\n                    if (i) {\n                        i--;\n                    }\n                } else {\n                    i++;\n                }\n            }\n\n            \n            for (i = 0; i < n_nodes; i += 2) {\n                fill_rect(self, x + nodes[i], y + row, (nodes[i + 1] - nodes[i]) + 1, 1, col);\n            }\n        }\n    } else {\n        \n        mp_int_t px1 = poly_int(&bufinfo, 0);\n        mp_int_t py1 = poly_int(&bufinfo, 1);\n        int i = n_poly * 2 - 1;\n        do {\n            mp_int_t py2 = poly_int(&bufinfo, i--);\n            mp_int_t px2 = poly_int(&bufinfo, i--);\n            line(self, x + px1, y + py1, x + px2, y + py2, col);\n            px1 = px2;\n            py1 = py2;\n        } while (i >= 0);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_poly_obj, 5, 6, framebuf_poly);\n\n#endif \n\nstatic mp_obj_t framebuf_blit(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    mp_obj_t source_in = mp_obj_cast_to_native_base(args_in[1], MP_OBJ_FROM_PTR(&mp_type_framebuf));\n    if (source_in == MP_OBJ_NULL) {\n        mp_raise_TypeError(NULL);\n    }\n    mp_obj_framebuf_t *source = MP_OBJ_TO_PTR(source_in);\n\n    mp_int_t x = mp_obj_get_int(args_in[2]);\n    mp_int_t y = mp_obj_get_int(args_in[3]);\n    mp_int_t key = -1;\n    if (n_args > 4) {\n        key = mp_obj_get_int(args_in[4]);\n    }\n    mp_obj_framebuf_t *palette = NULL;\n    if (n_args > 5 && args_in[5] != mp_const_none) {\n        palette = MP_OBJ_TO_PTR(mp_obj_cast_to_native_base(args_in[5], MP_OBJ_FROM_PTR(&mp_type_framebuf)));\n    }\n\n    if (\n        (x >= self->width) ||\n        (y >= self->height) ||\n        (-x >= source->width) ||\n        (-y >= source->height)\n        ) {\n        \n        return mp_const_none;\n    }\n\n    \n    int x0 = MAX(0, x);\n    int y0 = MAX(0, y);\n    int x1 = MAX(0, -x);\n    int y1 = MAX(0, -y);\n    int x0end = MIN(self->width, x + source->width);\n    int y0end = MIN(self->height, y + source->height);\n\n    for (; y0 < y0end; ++y0) {\n        int cx1 = x1;\n        for (int cx0 = x0; cx0 < x0end; ++cx0) {\n            uint32_t col = getpixel(source, cx1, y1);\n            if (palette) {\n                col = getpixel(palette, col, 0);\n            }\n            if (col != (uint32_t)key) {\n                setpixel(self, cx0, y0, col);\n            }\n            ++cx1;\n        }\n        ++y1;\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_blit_obj, 4, 6, framebuf_blit);\n\nstatic mp_obj_t framebuf_scroll(mp_obj_t self_in, mp_obj_t xstep_in, mp_obj_t ystep_in) {\n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_int_t xstep = mp_obj_get_int(xstep_in);\n    mp_int_t ystep = mp_obj_get_int(ystep_in);\n    int sx, y, xend, yend, dx, dy;\n    if (xstep < 0) {\n        sx = 0;\n        xend = self->width + xstep;\n        if (xend <= 0) {\n            return mp_const_none;\n        }\n        dx = 1;\n    } else {\n        sx = self->width - 1;\n        xend = xstep - 1;\n        if (xend >= sx) {\n            return mp_const_none;\n        }\n        dx = -1;\n    }\n    if (ystep < 0) {\n        y = 0;\n        yend = self->height + ystep;\n        if (yend <= 0) {\n            return mp_const_none;\n        }\n        dy = 1;\n    } else {\n        y = self->height - 1;\n        yend = ystep - 1;\n        if (yend >= y) {\n            return mp_const_none;\n        }\n        dy = -1;\n    }\n    for (; y != yend; y += dy) {\n        for (int x = sx; x != xend; x += dx) {\n            setpixel(self, x, y, getpixel(self, x - xstep, y - ystep));\n        }\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(framebuf_scroll_obj, framebuf_scroll);\n\nstatic mp_obj_t framebuf_text(size_t n_args, const mp_obj_t *args_in) {\n    \n    mp_obj_framebuf_t *self = MP_OBJ_TO_PTR(args_in[0]);\n    const char *str = mp_obj_str_get_str(args_in[1]);\n    mp_int_t x0 = mp_obj_get_int(args_in[2]);\n    mp_int_t y0 = mp_obj_get_int(args_in[3]);\n    mp_int_t col = 1;\n    if (n_args >= 5) {\n        col = mp_obj_get_int(args_in[4]);\n    }\n\n    \n    for (; *str; ++str) {\n        \n        int chr = *(uint8_t *)str;\n        if (chr < 32 || chr > 127) {\n            chr = 127;\n        }\n        \n        const uint8_t *chr_data = &font_petme128_8x8[(chr - 32) * 8];\n        \n        for (int j = 0; j < 8; j++, x0++) {\n            if (0 <= x0 && x0 < self->width) { \n                uint vline_data = chr_data[j]; \n                for (int y = y0; vline_data; vline_data >>= 1, y++) { \n                    if (vline_data & 1) { \n                        if (0 <= y && y < self->height) { \n                            setpixel(self, x0, y, col);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(framebuf_text_obj, 4, 5, framebuf_text);\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_rom_map_elem_t framebuf_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_fill), MP_ROM_PTR(&framebuf_fill_obj) },\n    { MP_ROM_QSTR(MP_QSTR_fill_rect), MP_ROM_PTR(&framebuf_fill_rect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pixel), MP_ROM_PTR(&framebuf_pixel_obj) },\n    { MP_ROM_QSTR(MP_QSTR_hline), MP_ROM_PTR(&framebuf_hline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_vline), MP_ROM_PTR(&framebuf_vline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rect), MP_ROM_PTR(&framebuf_rect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_line), MP_ROM_PTR(&framebuf_line_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ellipse), MP_ROM_PTR(&framebuf_ellipse_obj) },\n    #if MICROPY_PY_ARRAY\n    { MP_ROM_QSTR(MP_QSTR_poly), MP_ROM_PTR(&framebuf_poly_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_blit), MP_ROM_PTR(&framebuf_blit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_scroll), MP_ROM_PTR(&framebuf_scroll_obj) },\n    { MP_ROM_QSTR(MP_QSTR_text), MP_ROM_PTR(&framebuf_text_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(framebuf_locals_dict, framebuf_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_framebuf,\n    MP_QSTR_FrameBuffer,\n    MP_TYPE_FLAG_NONE,\n    make_new, framebuf_make_new,\n    buffer, framebuf_get_buffer,\n    locals_dict, &framebuf_locals_dict\n    );\n#endif\n\n#if !MICROPY_ENABLE_DYNRUNTIME\n\n\nstatic mp_obj_t legacy_framebuffer1(size_t n_args, const mp_obj_t *args_in) {\n    mp_obj_t args[] = {args_in[0], args_in[1], args_in[2], MP_OBJ_NEW_SMALL_INT(FRAMEBUF_MVLSB), n_args >= 4 ? args_in[3] : args_in[1] };\n    return framebuf_make_new(&mp_type_framebuf, 5, 0, args);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(legacy_framebuffer1_obj, 3, 4, legacy_framebuffer1);\n\nstatic const mp_rom_map_elem_t framebuf_module_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_framebuf) },\n    { MP_ROM_QSTR(MP_QSTR_FrameBuffer), MP_ROM_PTR(&mp_type_framebuf) },\n    { MP_ROM_QSTR(MP_QSTR_FrameBuffer1), MP_ROM_PTR(&legacy_framebuffer1_obj) },\n    { MP_ROM_QSTR(MP_QSTR_MVLSB), MP_ROM_INT(FRAMEBUF_MVLSB) },\n    { MP_ROM_QSTR(MP_QSTR_MONO_VLSB), MP_ROM_INT(FRAMEBUF_MVLSB) },\n    { MP_ROM_QSTR(MP_QSTR_RGB565), MP_ROM_INT(FRAMEBUF_RGB565) },\n    { MP_ROM_QSTR(MP_QSTR_GS2_HMSB), MP_ROM_INT(FRAMEBUF_GS2_HMSB) },\n    { MP_ROM_QSTR(MP_QSTR_GS4_HMSB), MP_ROM_INT(FRAMEBUF_GS4_HMSB) },\n    { MP_ROM_QSTR(MP_QSTR_GS8), MP_ROM_INT(FRAMEBUF_GS8) },\n    { MP_ROM_QSTR(MP_QSTR_MONO_HLSB), MP_ROM_INT(FRAMEBUF_MHLSB) },\n    { MP_ROM_QSTR(MP_QSTR_MONO_HMSB), MP_ROM_INT(FRAMEBUF_MHMSB) },\n};\n\nstatic MP_DEFINE_CONST_DICT(framebuf_module_globals, framebuf_module_globals_table);\n\nconst mp_obj_module_t mp_module_framebuf = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&framebuf_module_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_framebuf, mp_module_framebuf);\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}