{
  "module_name": "modwebsocket.c",
  "hash_id": "43ffb42924ae629a5548e339e1adc7e5d0ac22a0a722feeb039f187a5e97f04e",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modwebsocket.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"extmod/modwebsocket.h\"\n\n#if MICROPY_PY_WEBSOCKET\n\nenum { FRAME_HEADER, FRAME_OPT, PAYLOAD, CONTROL };\n\nenum { BLOCKING_WRITE = 0x80 };\n\ntypedef struct _mp_obj_websocket_t {\n    mp_obj_base_t base;\n    mp_obj_t sock;\n    uint32_t msg_sz;\n    byte mask[4];\n    byte state;\n    byte to_recv;\n    byte mask_pos;\n    byte buf_pos;\n    byte buf[6];\n    byte opts;\n    \n    byte ws_flags;\n    \n    byte last_flags;\n} mp_obj_websocket_t;\n\nstatic mp_uint_t websocket_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode);\nstatic mp_uint_t websocket_write_raw(mp_obj_t self_in, const byte *header, int hdr_sz, const void *buf, mp_uint_t size, int *errcode);\n\nstatic mp_obj_t websocket_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 1, 2, false);\n    mp_get_stream_raise(args[0], MP_STREAM_OP_READ | MP_STREAM_OP_WRITE | MP_STREAM_OP_IOCTL);\n    mp_obj_websocket_t *o = mp_obj_malloc(mp_obj_websocket_t, type);\n    o->sock = args[0];\n    o->state = FRAME_HEADER;\n    o->to_recv = 2;\n    o->mask_pos = 0;\n    o->buf_pos = 0;\n    o->opts = FRAME_TXT;\n    if (n_args > 1 && args[1] == mp_const_true) {\n        o->opts |= BLOCKING_WRITE;\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_uint_t websocket_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_websocket_t *self = MP_OBJ_TO_PTR(self_in);\n    const mp_stream_p_t *stream_p = mp_get_stream(self->sock);\n    while (1) {\n        if (self->to_recv != 0) {\n            mp_uint_t out_sz = stream_p->read(self->sock, self->buf + self->buf_pos, self->to_recv, errcode);\n            if (out_sz == 0 || out_sz == MP_STREAM_ERROR) {\n                return out_sz;\n            }\n            self->buf_pos += out_sz;\n            self->to_recv -= out_sz;\n            if (self->to_recv != 0) {\n                *errcode = MP_EAGAIN;\n                return MP_STREAM_ERROR;\n            }\n        }\n\n        switch (self->state) {\n            case FRAME_HEADER: {\n                \n                assert(self->buf[0] & 0x80);\n\n                \n                \n                \n                byte frame_type = self->buf[0];\n                self->last_flags = frame_type;\n                frame_type &= FRAME_OPCODE_MASK;\n\n                if ((self->buf[0] & FRAME_OPCODE_MASK) == FRAME_CONT) {\n                    \n                    self->ws_flags = (self->ws_flags & FRAME_OPCODE_MASK) | (self->buf[0] & ~FRAME_OPCODE_MASK);\n                } else {\n                    self->ws_flags = self->buf[0];\n                }\n\n                \n                \n                memset(self->mask, 0, sizeof(self->mask));\n\n                int to_recv = 0;\n                size_t sz = self->buf[1] & 0x7f;\n                if (sz == 126) {\n                    \n                    to_recv += 2;\n                } else if (sz == 127) {\n                    \n                    assert(0);\n                }\n                if (self->buf[1] & 0x80) {\n                    \n                    to_recv += 4;\n                }\n\n                self->buf_pos = 0;\n                self->to_recv = to_recv;\n                self->msg_sz = sz; \n                if (to_recv != 0) {\n                    self->state = FRAME_OPT;\n                } else {\n                    if (frame_type >= FRAME_CLOSE) {\n                        self->state = CONTROL;\n                    } else {\n                        self->state = PAYLOAD;\n                    }\n                }\n                continue;\n            }\n\n            case FRAME_OPT: {\n                if ((self->buf_pos & 3) == 2) {\n                    \n                    self->msg_sz = (self->buf[0] << 8) | self->buf[1];\n                }\n                if (self->buf_pos >= 4) {\n                    \n                    memcpy(self->mask, self->buf + self->buf_pos - 4, 4);\n                }\n                self->buf_pos = 0;\n                if ((self->last_flags & FRAME_OPCODE_MASK) >= FRAME_CLOSE) {\n                    self->state = CONTROL;\n                } else {\n                    self->state = PAYLOAD;\n                }\n                continue;\n            }\n\n            case PAYLOAD:\n            case CONTROL: {\n                mp_uint_t out_sz = 0;\n                if (self->msg_sz == 0) {\n                    \n                    goto no_payload;\n                }\n\n                size_t sz = MIN(size, self->msg_sz);\n                out_sz = stream_p->read(self->sock, buf, sz, errcode);\n                if (out_sz == 0 || out_sz == MP_STREAM_ERROR) {\n                    return out_sz;\n                }\n\n                sz = out_sz;\n                for (byte *p = buf; sz--; p++) {\n                    *p ^= self->mask[self->mask_pos++ & 3];\n                }\n\n                self->msg_sz -= out_sz;\n                if (self->msg_sz == 0) {\n                    byte last_state;\n                no_payload:\n                    last_state = self->state;\n                    self->state = FRAME_HEADER;\n                    self->to_recv = 2;\n                    self->mask_pos = 0;\n                    self->buf_pos = 0;\n\n                    \n                    if (last_state == CONTROL) {\n                        byte frame_type = self->last_flags & FRAME_OPCODE_MASK;\n                        if (frame_type == FRAME_CLOSE) {\n                            static const byte close_resp[2] = {0x88, 0};\n                            int err;\n                            websocket_write_raw(self_in, close_resp, sizeof(close_resp), close_resp, 0, &err);\n                            return 0;\n                        }\n\n                        \n                        continue;\n                    }\n                }\n\n                if (out_sz != 0) {\n                    return out_sz;\n                }\n                \n                continue;\n            }\n\n        }\n    }\n}\n\nstatic mp_uint_t websocket_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_websocket_t *self = MP_OBJ_TO_PTR(self_in);\n    assert(size < 0x10000);\n    byte header[4] = {0x80 | (self->opts & FRAME_OPCODE_MASK)};\n    int hdr_sz;\n    if (size < 126) {\n        header[1] = size;\n        hdr_sz = 2;\n    } else {\n        header[1] = 126;\n        header[2] = size >> 8;\n        header[3] = size & 0xff;\n        hdr_sz = 4;\n    }\n\n    return websocket_write_raw(self_in, header, hdr_sz, buf, size, errcode);\n}\nstatic mp_uint_t websocket_write_raw(mp_obj_t self_in, const byte *header, int hdr_sz, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_websocket_t *self = MP_OBJ_TO_PTR(self_in);\n\n    mp_obj_t dest[3];\n    if (self->opts & BLOCKING_WRITE) {\n        mp_load_method(self->sock, MP_QSTR_setblocking, dest);\n        dest[2] = mp_const_true;\n        mp_call_method_n_kw(1, 0, dest);\n    }\n\n    mp_uint_t out_sz = mp_stream_write_exactly(self->sock, header, hdr_sz, errcode);\n    if (*errcode == 0) {\n        out_sz = mp_stream_write_exactly(self->sock, buf, size, errcode);\n    }\n\n    if (self->opts & BLOCKING_WRITE) {\n        dest[2] = mp_const_false;\n        mp_call_method_n_kw(1, 0, dest);\n    }\n\n    if (*errcode != 0) {\n        return MP_STREAM_ERROR;\n    }\n    return out_sz;\n}\n\nstatic mp_uint_t websocket_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mp_obj_websocket_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (request) {\n        case MP_STREAM_CLOSE:\n            \n            \n            mp_stream_close(self->sock);\n            return 0;\n        case MP_STREAM_GET_DATA_OPTS:\n            return self->ws_flags & FRAME_OPCODE_MASK;\n        case MP_STREAM_SET_DATA_OPTS: {\n            int cur = self->opts & FRAME_OPCODE_MASK;\n            self->opts = (self->opts & ~FRAME_OPCODE_MASK) | (arg & FRAME_OPCODE_MASK);\n            return cur;\n        }\n        default:\n            *errcode = MP_EINVAL;\n            return MP_STREAM_ERROR;\n    }\n}\n\nstatic const mp_rom_map_elem_t websocket_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ioctl), MP_ROM_PTR(&mp_stream_ioctl_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(websocket_locals_dict, websocket_locals_dict_table);\n\nstatic const mp_stream_p_t websocket_stream_p = {\n    .read = websocket_read,\n    .write = websocket_write,\n    .ioctl = websocket_ioctl,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    websocket_type,\n    MP_QSTR_websocket,\n    MP_TYPE_FLAG_NONE,\n    make_new, websocket_make_new,\n    protocol, &websocket_stream_p,\n    locals_dict, &websocket_locals_dict\n    );\n\nstatic const mp_rom_map_elem_t websocket_module_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_websocket) },\n    { MP_ROM_QSTR(MP_QSTR_websocket), MP_ROM_PTR(&websocket_type) },\n};\n\nstatic MP_DEFINE_CONST_DICT(websocket_module_globals, websocket_module_globals_table);\n\nconst mp_obj_module_t mp_module_websocket = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&websocket_module_globals,\n};\n\n\n\n\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_websocket, mp_module_websocket);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}