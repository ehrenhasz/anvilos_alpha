{
  "module_name": "machine_timer.c",
  "hash_id": "fb011ce4b9dd15a0d285550fe2a73a7493603dbcdc3460550940e1be44d56457",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/machine_timer.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_MACHINE_TIMER\n\n#include \"shared/runtime/softtimer.h\"\n\ntypedef soft_timer_entry_t machine_timer_obj_t;\n\nconst mp_obj_type_t machine_timer_type;\n\nstatic void machine_timer_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    machine_timer_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    qstr mode = self->mode == SOFT_TIMER_MODE_ONE_SHOT ? MP_QSTR_ONE_SHOT : MP_QSTR_PERIODIC;\n    mp_printf(print, \"Timer(mode=%q, period=%u)\", mode, self->delta_ms);\n}\n\nstatic mp_obj_t machine_timer_init_helper(machine_timer_obj_t *self, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_mode, ARG_callback, ARG_period, ARG_tick_hz, ARG_freq, };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_mode,         MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = SOFT_TIMER_MODE_PERIODIC} },\n        { MP_QSTR_callback,     MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_period,       MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 0xffffffff} },\n        { MP_QSTR_tick_hz,      MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 1000} },\n        { MP_QSTR_freq,         MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    self->mode = args[ARG_mode].u_int;\n\n    uint64_t delta_ms = self->delta_ms;\n    if (args[ARG_freq].u_obj != mp_const_none) {\n        \n        #if MICROPY_PY_BUILTINS_FLOAT\n        delta_ms = (uint32_t)(MICROPY_FLOAT_CONST(1000.0) / mp_obj_get_float(args[ARG_freq].u_obj));\n        #else\n        delta_ms = 1000 / mp_obj_get_int(args[ARG_freq].u_obj);\n        #endif\n    } else if (args[ARG_period].u_int != 0xffffffff) {\n        \n        delta_ms = (uint64_t)args[ARG_period].u_int * 1000 / args[ARG_tick_hz].u_int;\n    }\n\n    if (delta_ms < 1) {\n        delta_ms = 1;\n    } else if (delta_ms >= 0x40000000) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"period too large\"));\n    }\n    self->delta_ms = (uint32_t)delta_ms;\n\n    if (args[ARG_callback].u_obj != MP_OBJ_NULL) {\n        self->py_callback = args[ARG_callback].u_obj;\n    }\n\n    if (self->py_callback != mp_const_none) {\n        soft_timer_insert(self, self->delta_ms);\n    }\n\n    return mp_const_none;\n}\n\nstatic mp_obj_t machine_timer_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    machine_timer_obj_t *self = m_new_obj(machine_timer_obj_t);\n    self->pairheap.base.type = &machine_timer_type;\n    self->flags = SOFT_TIMER_FLAG_PY_CALLBACK | SOFT_TIMER_FLAG_GC_ALLOCATED;\n    self->delta_ms = 1000;\n    self->py_callback = mp_const_none;\n\n    \n    mp_int_t id = -1;\n    if (n_args > 0) {\n        id = mp_obj_get_int(args[0]);\n        --n_args;\n        ++args;\n    }\n    if (id != -1) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"Timer doesn't exist\"));\n    }\n\n    if (n_args > 0 || n_kw > 0) {\n        \n        mp_map_t kw_args;\n        mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);\n        machine_timer_init_helper(self, n_args, args, &kw_args);\n    }\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_obj_t machine_timer_init(size_t n_args, const mp_obj_t *args, mp_map_t *kw_args) {\n    machine_timer_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    soft_timer_remove(self);\n    return machine_timer_init_helper(self, n_args - 1, args + 1, kw_args);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(machine_timer_init_obj, 1, machine_timer_init);\n\nstatic mp_obj_t machine_timer_deinit(mp_obj_t self_in) {\n    machine_timer_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    soft_timer_remove(self);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(machine_timer_deinit_obj, machine_timer_deinit);\n\nstatic const mp_rom_map_elem_t machine_timer_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&machine_timer_init_obj) },\n    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&machine_timer_deinit_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_ONE_SHOT), MP_ROM_INT(SOFT_TIMER_MODE_ONE_SHOT) },\n    { MP_ROM_QSTR(MP_QSTR_PERIODIC), MP_ROM_INT(SOFT_TIMER_MODE_PERIODIC) },\n};\nstatic MP_DEFINE_CONST_DICT(machine_timer_locals_dict, machine_timer_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    machine_timer_type,\n    MP_QSTR_Timer,\n    MP_TYPE_FLAG_NONE,\n    make_new, machine_timer_make_new,\n    print, machine_timer_print,\n    locals_dict, &machine_timer_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}