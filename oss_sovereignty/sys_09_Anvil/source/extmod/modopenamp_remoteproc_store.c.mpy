{
  "module_name": "modopenamp_remoteproc_store.c",
  "hash_id": "6e3a0106d8fb05ad69fd604136543f35e333b8e894f68fb45eca509e73f380bc",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modopenamp_remoteproc_store.c",
  "human_readable_source": " \n\n#if MICROPY_PY_OPENAMP_REMOTEPROC\n\n#include \"py/obj.h\"\n#include \"py/nlr.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"extmod/vfs.h\"\n\n#include \"metal/sys.h\"\n#include \"metal/alloc.h\"\n#include \"metal/errno.h\"\n#include \"metal/io.h\"\n\n#include \"openamp/remoteproc.h\"\n#include \"openamp/remoteproc_loader.h\"\n\n#include \"modopenamp.h\"\n#include \"modopenamp_remoteproc.h\"\n\n#if MICROPY_PY_OPENAMP_REMOTEPROC_STORE_ENABLE\n\n \n \n \n#define RPROC_FILE_STORE_BUF_SIZE   (1024)\n\ntypedef struct openamp_remoteproc_filestore {\n    size_t len;\n    uint8_t *buf;\n    mp_obj_t file;\n} openamp_remoteproc_filestore_t;\n\nvoid *mp_openamp_remoteproc_store_alloc(void) {\n     \n    openamp_remoteproc_filestore_t *fstore;\n    fstore = metal_allocate_memory(sizeof(openamp_remoteproc_filestore_t));\n    fstore->len = RPROC_FILE_STORE_BUF_SIZE;\n    fstore->buf = metal_allocate_memory(RPROC_FILE_STORE_BUF_SIZE);\n    return fstore;\n}\n\nstatic int openamp_remoteproc_store_open(void *store, const char *path, const void **image_data) {\n    metal_log(METAL_LOG_DEBUG, \"store_open(): %s\\n\", path);\n    mp_obj_t args[2] = {\n        mp_obj_new_str(path, strlen(path)),\n        MP_OBJ_NEW_QSTR(MP_QSTR_rb),\n    };\n\n    openamp_remoteproc_filestore_t *fstore = store;\n    fstore->file = mp_vfs_open(MP_ARRAY_SIZE(args), args, (mp_map_t *)&mp_const_empty_map);\n\n    int error = 0;\n    mp_uint_t bytes = mp_stream_read_exactly(fstore->file, fstore->buf, RPROC_FILE_STORE_BUF_SIZE, &error);\n    if (error != 0 || bytes != RPROC_FILE_STORE_BUF_SIZE) {\n        return -EINVAL;\n    }\n    *image_data = fstore->buf;\n    return bytes;\n}\n\nstatic void openamp_remoteproc_store_close(void *store) {\n    metal_log(METAL_LOG_DEBUG, \"store_close()\\n\");\n    openamp_remoteproc_filestore_t *fstore = store;\n    mp_stream_close(fstore->file);\n    metal_free_memory(fstore->buf);\n    metal_free_memory(fstore);\n}\n\nstatic int openamp_remoteproc_store_load(void *store, size_t offset, size_t size,\n    const void **data, metal_phys_addr_t pa,\n    struct metal_io_region *io,\n    char is_blocking) {\n\n    int error = 0;\n    openamp_remoteproc_filestore_t *fstore = store;\n\n    if (mp_stream_seek(fstore->file, offset, MP_SEEK_SET, &error) == -1) {\n        return -EINVAL;\n    }\n\n    if (pa == METAL_BAD_PHYS) {\n        if (size > fstore->len) {\n             \n            fstore->len = size;\n            fstore->buf = metal_allocate_memory(size);\n            metal_log(METAL_LOG_DEBUG, \"store_load() realloc to %lu\\n\", fstore->len);\n        }\n        *data = fstore->buf;\n        metal_log(METAL_LOG_DEBUG, \"store_load(): pa 0x%lx offset %u size %u \\n\", (uint32_t)pa, offset, size);\n    } else {\n        void *va = metal_io_phys_to_virt(io, pa);\n        if (va == NULL) {\n            return -EINVAL;\n        }\n        *data = va;\n        metal_log(METAL_LOG_DEBUG, \"store_load(): pa 0x%lx va 0x%p offset %u size %u \\n\", (uint32_t)pa, va, offset, size);\n    }\n\n    mp_uint_t bytes = mp_stream_read_exactly(fstore->file, (void *)*data, size, &error);\n    if (bytes != size || error != 0) {\n        return -EINVAL;\n    }\n\n    return bytes;\n}\n\nconst struct image_store_ops openamp_remoteproc_store_ops = {\n    .open = openamp_remoteproc_store_open,\n    .close = openamp_remoteproc_store_close,\n    .load = openamp_remoteproc_store_load,\n    .features = SUPPORT_SEEK,\n};\n\n#endif \n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}