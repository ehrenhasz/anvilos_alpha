{
  "module_name": "modopenamp_remoteproc.c",
  "hash_id": "1b27b0913ec029540ff16abf4b30e5511cfa3046564d51fdb24be1248b325d3e",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modopenamp_remoteproc.c",
  "human_readable_source": " \n\n#if MICROPY_PY_OPENAMP_REMOTEPROC\n\n#include \"py/obj.h\"\n#include \"py/nlr.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"extmod/vfs.h\"\n\n#include \"metal/sys.h\"\n#include \"metal/alloc.h\"\n#include \"metal/errno.h\"\n#include \"metal/io.h\"\n\n#include \"openamp/open_amp.h\"\n#include \"openamp/remoteproc.h\"\n#include \"openamp/remoteproc_loader.h\"\n\n#include \"modopenamp.h\"\n#include \"modopenamp_remoteproc.h\"\n\n#if !MICROPY_PY_OPENAMP\n#error \"MICROPY_PY_OPENAMP_REMOTEPROC requires MICROPY_PY_OPENAMP\"\n#endif\n\ntypedef struct openamp_remoteproc_obj {\n    mp_obj_base_t base;\n    struct remoteproc rproc;\n} openamp_remoteproc_obj_t;\n\nconst mp_obj_type_t openamp_remoteproc_type;\n\n\nextern struct image_store_ops openamp_remoteproc_store_ops;\n\n\nconst struct remoteproc_ops openamp_remoteproc_ops = {\n    .init = mp_openamp_remoteproc_init,\n    .mmap = mp_openamp_remoteproc_mmap,\n    .start = mp_openamp_remoteproc_start,\n    .stop = mp_openamp_remoteproc_stop,\n    .config = mp_openamp_remoteproc_config,\n    .remove = mp_openamp_remoteproc_remove,\n    .shutdown = mp_openamp_remoteproc_shutdown,\n};\n\nstatic mp_obj_t openamp_remoteproc_start(mp_obj_t self_in) {\n    openamp_remoteproc_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    int error = remoteproc_start(&self->rproc);\n    if (error != 0) {\n        self->rproc.state = RPROC_ERROR;\n        mp_raise_OSError(error);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(openamp_remoteproc_start_obj, openamp_remoteproc_start);\n\nstatic mp_obj_t openamp_remoteproc_stop(mp_obj_t self_in) {\n    openamp_remoteproc_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    int error = remoteproc_stop(&self->rproc);\n    if (error != 0) {\n        mp_raise_OSError(error);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(openamp_remoteproc_stop_obj, openamp_remoteproc_stop);\n\nstatic mp_obj_t openamp_remoteproc_shutdown(mp_obj_t self_in) {\n    openamp_remoteproc_obj_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    int error = remoteproc_shutdown(&self->rproc);\n    if (error != 0) {\n        mp_raise_OSError(error);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(openamp_remoteproc_shutdown_obj, openamp_remoteproc_shutdown);\n\nmp_obj_t openamp_remoteproc_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *all_args) {\n    enum { ARG_entry };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_entry, MP_ARG_OBJ | MP_ARG_REQUIRED,  {.u_rom_obj = MP_ROM_NONE } },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    openamp_remoteproc_obj_t *self = mp_obj_malloc_with_finaliser(openamp_remoteproc_obj_t, &openamp_remoteproc_type);\n\n    \n    if (MP_STATE_PORT(virtio_device) == NULL) {\n        openamp_init();\n    }\n\n    \n    \n    \n    remoteproc_init(&self->rproc, &openamp_remoteproc_ops, NULL);\n\n    \n    int error = remoteproc_config(&self->rproc, NULL);\n    if (error != 0) {\n        mp_raise_OSError(error);\n    }\n\n    if (mp_obj_is_int(args[ARG_entry].u_obj)) {\n        self->rproc.bootaddr = mp_obj_get_int(args[ARG_entry].u_obj);\n    } else {\n        #if MICROPY_PY_OPENAMP_REMOTEPROC_ELFLD_ENABLE\n        \n        const char *path = mp_obj_str_get_str(args[ARG_entry].u_obj);\n        int error = remoteproc_load(&self->rproc, path, self->rproc.priv, &openamp_remoteproc_store_ops, NULL);\n        if (error != 0) {\n            mp_raise_OSError(error);\n        }\n        #else\n        mp_raise_TypeError(MP_ERROR_TEXT(\"loading firmware is not supported.\"));\n        #endif\n    }\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic const mp_rom_map_elem_t openamp_remoteproc_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_RemoteProc) },\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&openamp_remoteproc_shutdown_obj) },\n    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&openamp_remoteproc_start_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stop), MP_ROM_PTR(&openamp_remoteproc_stop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_shutdown), MP_ROM_PTR(&openamp_remoteproc_shutdown_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(openamp_remoteproc_dict, openamp_remoteproc_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    openamp_remoteproc_type,\n    MP_QSTR_RemoteProc,\n    MP_TYPE_FLAG_NONE,\n    make_new, openamp_remoteproc_make_new,\n    locals_dict, &openamp_remoteproc_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}