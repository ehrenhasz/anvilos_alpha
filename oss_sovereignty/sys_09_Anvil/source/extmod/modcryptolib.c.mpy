{
  "module_name": "modcryptolib.c",
  "hash_id": "c69a763eb774e5563001a97d707f36afa6ac9d32654ee05f7487b0a1ea4acf0a",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modcryptolib.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n\n#if MICROPY_PY_CRYPTOLIB\n\n#include <assert.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n\n\n\n\n\n\n\nenum {\n    UCRYPTOLIB_MODE_ECB = 1,\n    UCRYPTOLIB_MODE_CBC = 2,\n    UCRYPTOLIB_MODE_CTR = 6,\n};\n\nstruct ctr_params {\n    \n\n    size_t offset; \n    \n    uint8_t encrypted_counter[16];\n};\n\n#if MICROPY_SSL_AXTLS\n#include \"lib/axtls/crypto/crypto.h\"\n\n#define AES_CTX_IMPL AES_CTX\n#endif\n\n#if MICROPY_SSL_MBEDTLS\n#include <mbedtls/aes.h>\n\n\n\n\nstruct mbedtls_aes_ctx_with_key {\n    union {\n        mbedtls_aes_context mbedtls_ctx;\n        struct {\n            uint8_t key[32];\n            uint8_t keysize;\n        } init_data;\n    } u;\n    unsigned char iv[16];\n};\n#define AES_CTX_IMPL struct mbedtls_aes_ctx_with_key\n#endif\n\ntypedef struct _mp_obj_aes_t {\n    mp_obj_base_t base;\n    AES_CTX_IMPL ctx;\n    uint8_t block_mode : 6;\n#define AES_KEYTYPE_NONE 0\n#define AES_KEYTYPE_ENC  1\n#define AES_KEYTYPE_DEC  2\n    uint8_t key_type : 2;\n    struct ctr_params ctr_params[]; \n} mp_obj_aes_t;\n\nstatic inline bool is_ctr_mode(int block_mode) {\n    #if MICROPY_PY_CRYPTOLIB_CTR\n    return block_mode == UCRYPTOLIB_MODE_CTR;\n    #else\n    return false;\n    #endif\n}\n\nstatic inline struct ctr_params *ctr_params_from_aes(mp_obj_aes_t *o) {\n    return &o->ctr_params[0];\n}\n\n#if MICROPY_SSL_AXTLS\nstatic void aes_initial_set_key_impl(AES_CTX_IMPL *ctx, const uint8_t *key, size_t keysize, const uint8_t iv[16]) {\n    assert(16 == keysize || 32 == keysize);\n    AES_set_key(ctx, key, iv, (16 == keysize) ? AES_MODE_128 : AES_MODE_256);\n}\n\nstatic void aes_final_set_key_impl(AES_CTX_IMPL *ctx, bool encrypt) {\n    if (!encrypt) {\n        AES_convert_key(ctx);\n    }\n}\n\nstatic void aes_process_ecb_impl(AES_CTX_IMPL *ctx, const uint8_t in[16], uint8_t out[16], bool encrypt) {\n    memcpy(out, in, 16);\n    \n    uint32_t *p = (uint32_t *)out;\n    \n    for (int i = 0; i < 4; i++) {\n        p[i] = MP_HTOBE32(p[i]);\n    }\n    if (encrypt) {\n        AES_encrypt(ctx, p);\n    } else {\n        AES_decrypt(ctx, p);\n    }\n    for (int i = 0; i < 4; i++) {\n        p[i] = MP_BE32TOH(p[i]);\n    }\n}\n\nstatic void aes_process_cbc_impl(AES_CTX_IMPL *ctx, const uint8_t *in, uint8_t *out, size_t in_len, bool encrypt) {\n    if (encrypt) {\n        AES_cbc_encrypt(ctx, in, out, in_len);\n    } else {\n        AES_cbc_decrypt(ctx, in, out, in_len);\n    }\n}\n\n#if MICROPY_PY_CRYPTOLIB_CTR\n\nstatic void aes_process_ctr_impl(AES_CTX_IMPL *ctx, const uint8_t *in, uint8_t *out, size_t in_len, struct ctr_params *ctr_params) {\n    size_t n = ctr_params->offset;\n    uint8_t *const counter = ctx->iv;\n\n    while (in_len--) {\n        if (n == 0) {\n            aes_process_ecb_impl(ctx, counter, ctr_params->encrypted_counter, true);\n\n            \n            for (int i = 15; i >= 0; --i) {\n                if (++counter[i] != 0) {\n                    break;\n                }\n            }\n        }\n\n        *out++ = *in++ ^ ctr_params->encrypted_counter[n];\n        n = (n + 1) & 0xf;\n    }\n\n    ctr_params->offset = n;\n}\n#endif\n\n#endif\n\n#if MICROPY_SSL_MBEDTLS\nstatic void aes_initial_set_key_impl(AES_CTX_IMPL *ctx, const uint8_t *key, size_t keysize, const uint8_t iv[16]) {\n    ctx->u.init_data.keysize = keysize;\n    memcpy(ctx->u.init_data.key, key, keysize);\n\n    if (NULL != iv) {\n        memcpy(ctx->iv, iv, sizeof(ctx->iv));\n    }\n}\n\nstatic void aes_final_set_key_impl(AES_CTX_IMPL *ctx, bool encrypt) {\n    \n    uint8_t key[32];\n    uint8_t keysize = ctx->u.init_data.keysize;\n    memcpy(key, ctx->u.init_data.key, keysize);\n    \n    mbedtls_aes_init(&ctx->u.mbedtls_ctx);\n\n    \n    assert(16 == keysize || 32 == keysize);\n    if (encrypt) {\n        mbedtls_aes_setkey_enc(&ctx->u.mbedtls_ctx, key, keysize * 8);\n    } else {\n        mbedtls_aes_setkey_dec(&ctx->u.mbedtls_ctx, key, keysize * 8);\n    }\n}\n\nstatic void aes_process_ecb_impl(AES_CTX_IMPL *ctx, const uint8_t in[16], uint8_t out[16], bool encrypt) {\n    mbedtls_aes_crypt_ecb(&ctx->u.mbedtls_ctx, encrypt ? MBEDTLS_AES_ENCRYPT : MBEDTLS_AES_DECRYPT, in, out);\n}\n\nstatic void aes_process_cbc_impl(AES_CTX_IMPL *ctx, const uint8_t *in, uint8_t *out, size_t in_len, bool encrypt) {\n    mbedtls_aes_crypt_cbc(&ctx->u.mbedtls_ctx, encrypt ? MBEDTLS_AES_ENCRYPT : MBEDTLS_AES_DECRYPT, in_len, ctx->iv, in, out);\n}\n\n#if MICROPY_PY_CRYPTOLIB_CTR\nstatic void aes_process_ctr_impl(AES_CTX_IMPL *ctx, const uint8_t *in, uint8_t *out, size_t in_len, struct ctr_params *ctr_params) {\n    mbedtls_aes_crypt_ctr(&ctx->u.mbedtls_ctx, in_len, &ctr_params->offset, ctx->iv, ctr_params->encrypted_counter, in, out);\n}\n#endif\n\n#endif\n\nstatic mp_obj_t cryptolib_aes_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 2, 3, false);\n\n    const mp_int_t block_mode = mp_obj_get_int(args[1]);\n\n    switch (block_mode) {\n        case UCRYPTOLIB_MODE_ECB:\n        case UCRYPTOLIB_MODE_CBC:\n        #if MICROPY_PY_CRYPTOLIB_CTR\n        case UCRYPTOLIB_MODE_CTR:\n        #endif\n            break;\n\n        default:\n            mp_raise_ValueError(MP_ERROR_TEXT(\"mode\"));\n    }\n\n    mp_obj_aes_t *o = mp_obj_malloc_var(mp_obj_aes_t, ctr_params, struct ctr_params, !!is_ctr_mode(block_mode), type);\n\n    o->block_mode = block_mode;\n    o->key_type = AES_KEYTYPE_NONE;\n\n    mp_buffer_info_t keyinfo;\n    mp_get_buffer_raise(args[0], &keyinfo, MP_BUFFER_READ);\n    if (32 != keyinfo.len && 16 != keyinfo.len) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"key\"));\n    }\n\n    mp_buffer_info_t ivinfo;\n    ivinfo.buf = NULL;\n    if (n_args > 2 && args[2] != mp_const_none) {\n        mp_get_buffer_raise(args[2], &ivinfo, MP_BUFFER_READ);\n\n        if (16 != ivinfo.len) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"IV\"));\n        }\n    } else if (o->block_mode == UCRYPTOLIB_MODE_CBC || is_ctr_mode(o->block_mode)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"IV\"));\n    }\n\n    if (is_ctr_mode(block_mode)) {\n        ctr_params_from_aes(o)->offset = 0;\n    }\n\n    aes_initial_set_key_impl(&o->ctx, keyinfo.buf, keyinfo.len, ivinfo.buf);\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_obj_t aes_process(size_t n_args, const mp_obj_t *args, bool encrypt) {\n    mp_obj_aes_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    mp_obj_t in_buf = args[1];\n    mp_obj_t out_buf = MP_OBJ_NULL;\n    if (n_args > 2) {\n        out_buf = args[2];\n    }\n\n    mp_buffer_info_t in_bufinfo;\n    mp_get_buffer_raise(in_buf, &in_bufinfo, MP_BUFFER_READ);\n\n    if (!is_ctr_mode(self->block_mode) && in_bufinfo.len % 16 != 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"blksize % 16\"));\n    }\n\n    vstr_t vstr;\n    mp_buffer_info_t out_bufinfo;\n    uint8_t *out_buf_ptr;\n\n    if (out_buf != MP_OBJ_NULL) {\n        mp_get_buffer_raise(out_buf, &out_bufinfo, MP_BUFFER_WRITE);\n        if (out_bufinfo.len < in_bufinfo.len) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"output too small\"));\n        }\n        out_buf_ptr = out_bufinfo.buf;\n    } else {\n        vstr_init_len(&vstr, in_bufinfo.len);\n        out_buf_ptr = (uint8_t *)vstr.buf;\n    }\n\n    if (AES_KEYTYPE_NONE == self->key_type) {\n        \n        const bool encrypt_mode = encrypt || is_ctr_mode(self->block_mode);\n        aes_final_set_key_impl(&self->ctx, encrypt_mode);\n        self->key_type = encrypt ? AES_KEYTYPE_ENC : AES_KEYTYPE_DEC;\n    } else {\n        if ((encrypt && self->key_type == AES_KEYTYPE_DEC) ||\n            (!encrypt && self->key_type == AES_KEYTYPE_ENC)) {\n\n            mp_raise_ValueError(MP_ERROR_TEXT(\"can't encrypt & decrypt\"));\n        }\n    }\n\n    switch (self->block_mode) {\n        case UCRYPTOLIB_MODE_ECB: {\n            uint8_t *in = in_bufinfo.buf, *out = out_buf_ptr;\n            uint8_t *top = in + in_bufinfo.len;\n            for (; in < top; in += 16, out += 16) {\n                aes_process_ecb_impl(&self->ctx, in, out, encrypt);\n            }\n            break;\n        }\n\n        case UCRYPTOLIB_MODE_CBC:\n            aes_process_cbc_impl(&self->ctx, in_bufinfo.buf, out_buf_ptr, in_bufinfo.len, encrypt);\n            break;\n\n        #if MICROPY_PY_CRYPTOLIB_CTR\n        case UCRYPTOLIB_MODE_CTR:\n            aes_process_ctr_impl(&self->ctx, in_bufinfo.buf, out_buf_ptr, in_bufinfo.len,\n                ctr_params_from_aes(self));\n            break;\n        #endif\n    }\n\n    if (out_buf != MP_OBJ_NULL) {\n        return out_buf;\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\n\nstatic mp_obj_t cryptolib_aes_encrypt(size_t n_args, const mp_obj_t *args) {\n    return aes_process(n_args, args, true);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(cryptolib_aes_encrypt_obj, 2, 3, cryptolib_aes_encrypt);\n\nstatic mp_obj_t cryptolib_aes_decrypt(size_t n_args, const mp_obj_t *args) {\n    return aes_process(n_args, args, false);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(cryptolib_aes_decrypt_obj, 2, 3, cryptolib_aes_decrypt);\n\nstatic const mp_rom_map_elem_t cryptolib_aes_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_encrypt), MP_ROM_PTR(&cryptolib_aes_encrypt_obj) },\n    { MP_ROM_QSTR(MP_QSTR_decrypt), MP_ROM_PTR(&cryptolib_aes_decrypt_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(cryptolib_aes_locals_dict, cryptolib_aes_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    cryptolib_aes_type,\n    MP_QSTR_aes,\n    MP_TYPE_FLAG_NONE,\n    make_new, cryptolib_aes_make_new,\n    locals_dict, &cryptolib_aes_locals_dict\n    );\n\nstatic const mp_rom_map_elem_t mp_module_cryptolib_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_cryptolib) },\n    { MP_ROM_QSTR(MP_QSTR_aes), MP_ROM_PTR(&cryptolib_aes_type) },\n    #if MICROPY_PY_CRYPTOLIB_CONSTS\n    { MP_ROM_QSTR(MP_QSTR_MODE_ECB), MP_ROM_INT(UCRYPTOLIB_MODE_ECB) },\n    { MP_ROM_QSTR(MP_QSTR_MODE_CBC), MP_ROM_INT(UCRYPTOLIB_MODE_CBC) },\n    #if MICROPY_PY_CRYPTOLIB_CTR\n    { MP_ROM_QSTR(MP_QSTR_MODE_CTR), MP_ROM_INT(UCRYPTOLIB_MODE_CTR) },\n    #endif\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_cryptolib_globals, mp_module_cryptolib_globals_table);\n\nconst mp_obj_module_t mp_module_cryptolib = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_cryptolib_globals,\n};\n\n\n\n\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_cryptolib, mp_module_cryptolib);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}