{
  "module_name": "network_wiznet5k.c",
  "hash_id": "a9a8b31bab4f18e52535f95bd8b6673b8f8afca87fcc221c979821c9e491cbf4",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/network_wiznet5k.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK_WIZNET5K\n\n#include \"shared/netutils/netutils.h\"\n#include \"extmod/modnetwork.h\"\n#include \"extmod/modmachine.h\"\n#include \"extmod/virtpin.h\"\n#include \"modmachine.h\"\n#include \"drivers/bus/spi.h\"\n\n#include \"lib/wiznet5k/Ethernet/wizchip_conf.h\"\n\n\n\n\n\n#define WIZNET5K_WITH_LWIP_STACK (MICROPY_PY_LWIP)\n#define WIZNET5K_PROVIDED_STACK (!MICROPY_PY_LWIP)\n\n#if WIZNET5K_WITH_LWIP_STACK\n\n\n#include \"shared/netutils/netutils.h\"\n#include \"lib/wiznet5k/Ethernet/wizchip_conf.h\"\n#include \"lib/wiznet5k/Ethernet/socket.h\"\n#include \"lwip/err.h\"\n#include \"lwip/dns.h\"\n#include \"lwip/dhcp.h\"\n#include \"netif/etharp.h\"\n\n#define TRACE_ETH_TX (0x0002)\n#define TRACE_ETH_RX (0x0004)\n\n#else \n\n\n\n#include \"lib/wiznet5k/Ethernet/socket.h\"\n#include \"lib/wiznet5k/Internet/DNS/dns.h\"\n#include \"lib/wiznet5k/Internet/DHCP/dhcp.h\"\n\n#endif\n\n#ifndef printf\n#define printf(...) mp_printf(MP_PYTHON_PRINTER, __VA_ARGS__)\n#endif\n\n#ifndef MICROPY_HW_WIZNET_SPI_BAUDRATE\n#define MICROPY_HW_WIZNET_SPI_BAUDRATE  (2000000)\n#endif\n\n#ifndef WIZCHIP_SREG_ADDR\n#if (_WIZCHIP_ == 5500)\n#define WIZCHIP_SREG_ADDR(sn, addr)    (_W5500_IO_BASE_ + (addr << 8) + (WIZCHIP_SREG_BLOCK(sn) << 3))\n#else\n#define WIZCHIP_SREG_ADDR(sn, addr)    (_WIZCHIP_IO_BASE_ + WIZCHIP_SREG_BLOCK(sn) + (addr))\n#endif\n#endif\n\ntypedef struct _wiznet5k_obj_t {\n    mp_obj_base_t base;\n    mp_uint_t cris_state;\n    mp_obj_base_t *spi;\n    void (*spi_transfer)(mp_obj_base_t *obj, size_t len, const uint8_t *src, uint8_t *dest);\n    mp_hal_pin_obj_t cs;\n    mp_hal_pin_obj_t rst;\n    #if WIZNET5K_WITH_LWIP_STACK\n    mp_hal_pin_obj_t pin_intn;\n    bool use_interrupt;\n    uint8_t eth_frame[1514];\n    uint32_t trace_flags;\n    struct netif netif;\n    struct dhcp dhcp_struct;\n    #else \n    wiz_NetInfo netinfo;\n    uint8_t socket_used;\n    bool active;\n    #endif\n} wiznet5k_obj_t;\n\n#if WIZNET5K_WITH_LWIP_STACK\n#define IS_ACTIVE(self) (self->netif.flags & NETIF_FLAG_UP)\n#else \n#define IS_ACTIVE(self) (self->active)\n#endif\n\n\nstatic wiznet5k_obj_t wiznet5k_obj;\n\nstatic void wiz_cris_enter(void) {\n    wiznet5k_obj.cris_state = MICROPY_BEGIN_ATOMIC_SECTION();\n}\n\nstatic void wiz_cris_exit(void) {\n    MICROPY_END_ATOMIC_SECTION(wiznet5k_obj.cris_state);\n}\n\nstatic void wiz_cs_select(void) {\n    mp_hal_pin_low(wiznet5k_obj.cs);\n}\n\nstatic void wiz_cs_deselect(void) {\n    mp_hal_pin_high(wiznet5k_obj.cs);\n}\n\nvoid mpy_wiznet_yield(void) {\n    \n    #if MICROPY_PY_THREAD\n    MICROPY_THREAD_YIELD();\n    #else\n    mp_handle_pending(true);\n    #endif\n}\n\nstatic void wiz_spi_read(uint8_t *buf, uint16_t len) {\n    wiznet5k_obj.spi_transfer(wiznet5k_obj.spi, len, buf, buf);\n}\n\nstatic void wiz_spi_write(const uint8_t *buf, uint16_t len) {\n    wiznet5k_obj.spi_transfer(wiznet5k_obj.spi, len, buf, NULL);\n}\n\nstatic uint8_t wiz_spi_readbyte() {\n    uint8_t buf = 0;\n    wiznet5k_obj.spi_transfer(wiznet5k_obj.spi, 1, &buf, &buf);\n    return buf;\n}\n\nstatic void wiz_spi_writebyte(const uint8_t buf) {\n    wiznet5k_obj.spi_transfer(wiznet5k_obj.spi, 1, &buf, NULL);\n}\n\nstatic void wiznet5k_get_mac_address(wiznet5k_obj_t *self, uint8_t mac[6]) {\n    (void)self;\n    getSHAR(mac);\n}\n\n#if WIZNET5K_WITH_LWIP_STACK\n\nvoid wiznet5k_try_poll(void);\nstatic void wiznet5k_lwip_init(wiznet5k_obj_t *self);\n\nstatic mp_obj_t mpy_wiznet_read_int(mp_obj_t none_in) {\n    (void)none_in;\n    \n    if (mp_hal_pin_read(wiznet5k_obj.cs)) {\n        wiznet5k_try_poll();\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mpy_wiznet_read_int_obj, mpy_wiznet_read_int);\n\nstatic void wiznet5k_config_interrupt(bool enabled) {\n    if (!wiznet5k_obj.use_interrupt) {\n        return;\n    }\n    mp_hal_pin_interrupt(\n        wiznet5k_obj.pin_intn,\n        MP_OBJ_FROM_PTR(&mpy_wiznet_read_int_obj),\n        (enabled)? MP_HAL_PIN_TRIGGER_FALL : MP_HAL_PIN_TRIGGER_NONE,\n        true\n        );\n}\n\nvoid wiznet5k_deinit(void) {\n    for (struct netif *netif = netif_list; netif != NULL; netif = netif->next) {\n        if (netif == &wiznet5k_obj.netif) {\n            netif_remove(netif);\n            netif->flags = 0;\n            break;\n        }\n    }\n}\n\nstatic void wiznet5k_init(void) {\n    \n\n    \n    #if _WIZCHIP_ < W5200\n    uint8_t sn_size[8] = {8, 0, 0, 0, 8, 0, 0, 0};\n    #else\n    uint8_t sn_size[16] = {16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0};\n    #endif\n    ctlwizchip(CW_INIT_WIZCHIP, sn_size);\n\n    if (wiznet5k_obj.use_interrupt) {\n        \n        wizchip_setinterruptmask(IK_SOCK_0);\n        \n        setSn_IMR(0, Sn_IR_RECV);\n        #if _WIZCHIP_ == W5100S\n        \n        setMR2(getMR2() | MR2_G_IEN);\n        #endif\n\n        mp_hal_pin_input(wiznet5k_obj.pin_intn);\n        wiznet5k_config_interrupt(true);\n    }\n\n    \n    wiznet5k_deinit();\n\n    \n    wiznet5k_lwip_init(&wiznet5k_obj);\n\n    netif_set_link_up(&wiznet5k_obj.netif);\n    netif_set_up(&wiznet5k_obj.netif);\n\n    \n    mod_network_register_nic(&wiznet5k_obj);\n}\n\nstatic void wiznet5k_send_ethernet(wiznet5k_obj_t *self, size_t len, const uint8_t *buf) {\n    uint8_t ip[4] = {1, 1, 1, 1}; \n    int ret = WIZCHIP_EXPORT(sendto)(0, (byte *)buf, len, ip, 11); \n    if (ret != len) {\n        printf(\"wiznet5k_send_ethernet: fatal error %d\\n\", ret);\n        netif_set_link_down(&self->netif);\n        netif_set_down(&self->netif);\n    }\n}\n\n\nstatic uint16_t wiznet5k_recv_ethernet(wiznet5k_obj_t *self) {\n    uint16_t len = getSn_RX_RSR(0);\n    if (len == 0) {\n        return 0;\n    }\n\n    byte ip[4];\n    uint16_t port;\n    int ret = WIZCHIP_EXPORT(recvfrom)(0, self->eth_frame, 1514, ip, &port);\n    if (ret <= 0) {\n        printf(\"wiznet5k_recv_ethernet: fatal error len=%u ret=%d\\n\", len, ret);\n        netif_set_link_down(&self->netif);\n        netif_set_down(&self->netif);\n        return 0;\n    }\n\n    return ret;\n}\n\n \n\n\nstatic err_t wiznet5k_netif_output(struct netif *netif, struct pbuf *p) {\n    wiznet5k_obj_t *self = netif->state;\n    pbuf_copy_partial(p, self->eth_frame, p->tot_len, 0);\n    if (self->trace_flags & TRACE_ETH_TX) {\n        netutils_ethernet_trace(MP_PYTHON_PRINTER, p->tot_len, self->eth_frame, NETUTILS_TRACE_IS_TX | NETUTILS_TRACE_NEWLINE);\n    }\n    wiznet5k_send_ethernet(self, p->tot_len, self->eth_frame);\n    return ERR_OK;\n}\n\nstatic err_t wiznet5k_netif_init(struct netif *netif) {\n    netif->linkoutput = wiznet5k_netif_output;\n    netif->output = etharp_output;\n    netif->mtu = 1500;\n    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET | NETIF_FLAG_IGMP;\n    wiznet5k_get_mac_address(netif->state, netif->hwaddr);\n    netif->hwaddr_len = sizeof(netif->hwaddr);\n    int ret = WIZCHIP_EXPORT(socket)(0, Sn_MR_MACRAW, 0, 0);\n    if (ret != 0) {\n        printf(\"WIZNET fatal error in netifinit: %d\\n\", ret);\n        return ERR_IF;\n    }\n\n    \n    setSn_MR(0, getSn_MR(0) | Sn_MR_MFEN);\n\n    return ERR_OK;\n}\n\nstatic void wiznet5k_lwip_init(wiznet5k_obj_t *self) {\n    ip_addr_t ipconfig[4];\n    IP_ADDR4(&ipconfig[0], 0, 0, 0, 0);\n    IP_ADDR4(&ipconfig[1], 0, 0, 0, 0);\n    IP_ADDR4(&ipconfig[2], 0, 0, 0, 0);\n    IP_ADDR4(&ipconfig[3], 0, 0, 0, 0);\n    netif_add(&self->netif, ip_2_ip4(&ipconfig[0]), ip_2_ip4(&ipconfig[1]), ip_2_ip4(&ipconfig[2]), self, wiznet5k_netif_init, ethernet_input);\n    self->netif.name[0] = 'e';\n    self->netif.name[1] = '0';\n    netif_set_default(&self->netif);\n    dns_setserver(0, &ipconfig[3]);\n    dhcp_set_struct(&self->netif, &self->dhcp_struct);\n    \n    \n    \n    self->netif.flags |= NETIF_FLAG_UP;\n    dhcp_start(&self->netif);\n    self->netif.flags &= ~NETIF_FLAG_UP;\n}\n\nvoid wiznet5k_poll(void) {\n    wiznet5k_obj_t *self = &wiznet5k_obj;\n    if ((self->netif.flags & (NETIF_FLAG_UP | NETIF_FLAG_LINK_UP)) == (NETIF_FLAG_UP | NETIF_FLAG_LINK_UP)) {\n        uint16_t len;\n        while ((len = wiznet5k_recv_ethernet(self)) > 0) {\n            if (self->trace_flags & TRACE_ETH_RX) {\n                netutils_ethernet_trace(MP_PYTHON_PRINTER, len, self->eth_frame, NETUTILS_TRACE_NEWLINE);\n            }\n            struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);\n            if (p != NULL) {\n                pbuf_take(p, self->eth_frame, len);\n                if (self->netif.input(p, &self->netif) != ERR_OK) {\n                    pbuf_free(p);\n                }\n            }\n        }\n    }\n    wizchip_clrinterrupt(IK_SOCK_0);\n    #if _WIZCHIP_ == W5100S\n    setSn_IR(0, Sn_IR_RECV); \n    #endif\n}\n\n#endif \n\n#if WIZNET5K_PROVIDED_STACK\n\nstatic void wiz_dhcp_assign(void) {\n    getIPfromDHCP(wiznet5k_obj.netinfo.ip);\n    getGWfromDHCP(wiznet5k_obj.netinfo.gw);\n    getSNfromDHCP(wiznet5k_obj.netinfo.sn);\n    getDNSfromDHCP(wiznet5k_obj.netinfo.dns);\n    ctlnetwork(CN_SET_NETINFO, (void *)&wiznet5k_obj.netinfo);\n}\n\nstatic void wiz_dhcp_update(void) {\n    ;\n}\n\n\nstatic void wiz_dhcp_conflict(void) {\n    ;\n}\n\nstatic void wiznet5k_init(void) {\n    \n\n    reg_dhcp_cbfunc(wiz_dhcp_assign, wiz_dhcp_update, wiz_dhcp_conflict);\n\n    uint8_t sn_size[16] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};         \n    ctlwizchip(CW_INIT_WIZCHIP, sn_size);\n\n    ctlnetwork(CN_SET_NETINFO, (void *)&wiznet5k_obj.netinfo);\n\n    \n    wiz_NetInfo netinfo = {\n        .mac = {0, 0, 0, 0, 0, 0},\n        .ip = {192, 168, 0, 18},\n        .sn = {255, 255, 255, 0},\n        .gw = {192, 168, 0, 1},\n        .dns = {8, 8, 8, 8}, \n        .dhcp = NETINFO_STATIC,\n    };\n    wiznet5k_obj.netinfo = netinfo;\n\n    \n    mod_network_register_nic(&wiznet5k_obj);\n\n    wiznet5k_obj.active = true;\n}\n\nstatic int wiznet5k_gethostbyname(mp_obj_t nic, const char *name, mp_uint_t len, uint8_t *out_ip) {\n    uint8_t dns_ip[MOD_NETWORK_IPADDR_BUF_SIZE] = {8, 8, 8, 8};\n    uint8_t *buf = m_new(uint8_t, MAX_DNS_BUF_SIZE);\n    DNS_init(2, buf);\n    if (wiznet5k_obj.netinfo.dns[0]) {\n        memcpy(dns_ip, wiznet5k_obj.netinfo.dns, MOD_NETWORK_IPADDR_BUF_SIZE);\n    }\n    mp_int_t ret = DNS_run(dns_ip, (uint8_t *)name, out_ip);\n    m_del(uint8_t, buf, MAX_DNS_BUF_SIZE);\n    if (ret == 1) {\n        \n        return 0;\n    } else {\n        \n        return -2;\n    }\n}\n\nstatic int wiznet5k_socket_socket(mod_network_socket_obj_t *socket, int *_errno) {\n    if (socket->domain != MOD_NETWORK_AF_INET) {\n        *_errno = MP_EAFNOSUPPORT;\n        return -1;\n    }\n\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM:\n            socket->type = Sn_MR_TCP;\n            break;\n        case MOD_NETWORK_SOCK_DGRAM:\n            socket->type = Sn_MR_UDP;\n            break;\n        default:\n            *_errno = MP_EINVAL;\n            return -1;\n    }\n\n    if (socket->fileno == -1) {\n        \n        for (mp_uint_t sn = 0; sn < _WIZCHIP_SOCK_NUM_; sn++) {\n            if ((wiznet5k_obj.socket_used & (1 << sn)) == 0) {\n                wiznet5k_obj.socket_used |= (1 << sn);\n                socket->fileno = sn;\n                break;\n            }\n        }\n        if (socket->fileno == -1) {\n            \n            *_errno = MP_EMFILE;\n            return -1;\n        }\n    }\n\n    \n    \n    \n\n    \n    socket->domain = 0;\n\n    return 0;\n}\n\nstatic void wiznet5k_socket_close(mod_network_socket_obj_t *socket) {\n    uint8_t sn = (uint8_t)socket->fileno;\n    if (sn < _WIZCHIP_SOCK_NUM_) {\n        wiznet5k_obj.socket_used &= ~(1 << sn);\n        WIZCHIP_EXPORT(close)(sn);\n    }\n}\n\nstatic int wiznet5k_socket_bind(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {\n    \n    mp_int_t ret = WIZCHIP_EXPORT(socket)(socket->fileno, socket->type, port, 0);\n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n\n    \n    socket->domain = 1;\n\n    \n    return 0;\n}\n\nstatic int wiznet5k_socket_listen(mod_network_socket_obj_t *socket, mp_int_t backlog, int *_errno) {\n    mp_int_t ret = WIZCHIP_EXPORT(listen)(socket->fileno);\n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n    return 0;\n}\n\nstatic int wiznet5k_socket_accept(mod_network_socket_obj_t *socket, mod_network_socket_obj_t *socket2, byte *ip, mp_uint_t *port, int *_errno) {\n    for (;;) {\n        int sr = getSn_SR((uint8_t)socket->fileno);\n        if (sr == SOCK_ESTABLISHED) {\n            socket2->domain = socket->domain;\n            socket2->type = socket->type;\n            socket2->fileno = socket->fileno;\n            getSn_DIPR((uint8_t)socket2->fileno, ip);\n            *port = getSn_PORT(socket2->fileno);\n\n            \n            \n            \n            socket->domain = MOD_NETWORK_AF_INET;\n            socket->fileno = -1;\n            int _errno2;\n            if (wiznet5k_socket_socket(socket, &_errno2) != 0) {\n                \n            } else if (wiznet5k_socket_bind(socket, NULL, *port, &_errno2) != 0) {\n                \n            } else if (wiznet5k_socket_listen(socket, 0, &_errno2) != 0) {\n                \n            }\n\n            return 0;\n        }\n        if (sr == SOCK_CLOSED || sr == SOCK_CLOSE_WAIT) {\n            wiznet5k_socket_close(socket);\n            *_errno = MP_ENOTCONN; \n            return -1;\n        }\n        mp_hal_delay_ms(1);\n    }\n}\n\nstatic int wiznet5k_socket_connect(mod_network_socket_obj_t *socket, byte *ip, mp_uint_t port, int *_errno) {\n    \n    if (wiznet5k_socket_bind(socket, ip, 0, _errno) != 0) {\n        return -1;\n    }\n\n    \n    MP_THREAD_GIL_EXIT();\n    mp_int_t ret = WIZCHIP_EXPORT(connect)(socket->fileno, ip, port);\n    MP_THREAD_GIL_ENTER();\n\n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n\n    \n    return 0;\n}\n\nstatic mp_uint_t wiznet5k_socket_send(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, int *_errno) {\n    MP_THREAD_GIL_EXIT();\n    mp_int_t ret = WIZCHIP_EXPORT(send)(socket->fileno, (byte *)buf, len);\n    MP_THREAD_GIL_ENTER();\n\n    \n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n    return ret;\n}\n\nstatic mp_uint_t wiznet5k_socket_recv(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, int *_errno) {\n    MP_THREAD_GIL_EXIT();\n    mp_int_t ret = WIZCHIP_EXPORT(recv)(socket->fileno, buf, len);\n    MP_THREAD_GIL_ENTER();\n\n    \n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n    return ret;\n}\n\nstatic mp_uint_t wiznet5k_socket_sendto(mod_network_socket_obj_t *socket, const byte *buf, mp_uint_t len, byte *ip, mp_uint_t port, int *_errno) {\n    if (socket->domain == 0) {\n        \n        if (wiznet5k_socket_bind(socket, ip, 0, _errno) != 0) {\n            return -1;\n        }\n    }\n\n    MP_THREAD_GIL_EXIT();\n    mp_int_t ret = WIZCHIP_EXPORT(sendto)(socket->fileno, (byte *)buf, len, ip, port);\n    MP_THREAD_GIL_ENTER();\n\n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n    return ret;\n}\n\nstatic mp_uint_t wiznet5k_socket_recvfrom(mod_network_socket_obj_t *socket, byte *buf, mp_uint_t len, byte *ip, mp_uint_t *port, int *_errno) {\n    uint16_t port2;\n    MP_THREAD_GIL_EXIT();\n    mp_int_t ret = WIZCHIP_EXPORT(recvfrom)(socket->fileno, buf, len, ip, &port2);\n    MP_THREAD_GIL_ENTER();\n    *port = port2;\n    if (ret < 0) {\n        wiznet5k_socket_close(socket);\n        *_errno = -ret;\n        return -1;\n    }\n    return ret;\n}\n\nstatic int wiznet5k_socket_setsockopt(mod_network_socket_obj_t *socket, mp_uint_t level, mp_uint_t opt, const void *optval, mp_uint_t optlen, int *_errno) {\n    \n    *_errno = MP_EINVAL;\n    return -1;\n}\n\nstatic int wiznet5k_socket_settimeout(mod_network_socket_obj_t *socket, mp_uint_t timeout_ms, int *_errno) {\n    \n    *_errno = MP_EINVAL;\n    return -1;\n\n     \n}\n\nstatic int wiznet5k_socket_ioctl(mod_network_socket_obj_t *socket, mp_uint_t request, mp_uint_t arg, int *_errno) {\n    if (request == MP_STREAM_POLL) {\n        int ret = 0;\n        if (arg & MP_STREAM_POLL_RD && getSn_RX_RSR(socket->fileno) != 0) {\n            ret |= MP_STREAM_POLL_RD;\n        }\n        if (arg & MP_STREAM_POLL_WR && getSn_TX_FSR(socket->fileno) != 0) {\n            ret |= MP_STREAM_POLL_WR;\n        }\n        return ret;\n    } else {\n        *_errno = MP_EINVAL;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic void wiznet5k_dhcp_init(wiznet5k_obj_t *self) {\n    uint8_t test_buf[2048];\n    uint8_t ret = 0;\n    uint8_t dhcp_retry = 0;\n\n    while (ret != DHCP_IP_LEASED) {\n        mp_uint_t timeout = mp_hal_ticks_ms() + 3000;\n        DHCP_init(1, test_buf);\n\n        while (1) {\n            ret = DHCP_run();\n            if (ret == DHCP_IP_LEASED) {\n                break;\n            } else if (ret == DHCP_FAILED || mp_hal_ticks_ms() > timeout) {\n                dhcp_retry++;\n                break;\n            }\n            mpy_wiznet_yield();\n        }\n\n        if (dhcp_retry > 3) {\n            mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"timeout waiting for DHCP to get IP address\"));\n            break;\n        }\n    }\n\n    if (ret == DHCP_IP_LEASED) {\n        ctlnetwork(CN_GET_NETINFO, &self->netinfo);\n    }\n}\n\n#endif \n\n \n\n\n\n\nstatic mp_obj_t wiznet5k_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_base_t *spi;\n    mp_hal_pin_obj_t cs;\n    mp_hal_pin_obj_t rst;\n\n    #if WIZNET5K_WITH_LWIP_STACK\n    mp_hal_pin_obj_t pin_intn = (mp_hal_pin_obj_t)NULL;\n    bool use_interrupt = false;\n\n    \n    wiznet5k_obj.netif.flags = 0;\n    #endif\n\n    #ifdef MICROPY_HW_WIZNET_SPI_ID\n    \n    if (n_args == 0 && n_kw == 0) {\n        \n        mp_obj_t spi_obj = MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_SPI_SCK);\n        mp_obj_t miso_obj = MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_SPI_MISO);\n        mp_obj_t mosi_obj = MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_SPI_MOSI);\n        mp_obj_t args[] = {\n            MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_SPI_ID),\n            MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_SPI_BAUDRATE),\n            MP_ROM_QSTR(MP_QSTR_sck), mp_pin_make_new(NULL, 1, 0, &spi_obj),\n            MP_ROM_QSTR(MP_QSTR_miso), mp_pin_make_new(NULL, 1, 0, &miso_obj),\n            MP_ROM_QSTR(MP_QSTR_mosi), mp_pin_make_new(NULL, 1, 0, &mosi_obj),\n        };\n        spi = MP_OBJ_TO_PTR(MP_OBJ_TYPE_GET_SLOT(&machine_spi_type, make_new)((mp_obj_t)&machine_spi_type, 2, 3, args));\n\n        cs = mp_hal_get_pin_obj(mp_pin_make_new(NULL, 1, 0, (mp_obj_t[]) {MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_PIN_CS)}));\n        rst = mp_hal_get_pin_obj(mp_pin_make_new(NULL, 1, 0, (mp_obj_t[]) {MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_PIN_RST)}));\n        #if WIZNET5K_WITH_LWIP_STACK && defined(MICROPY_HW_WIZNET_PIN_INTN)\n        pin_intn = mp_hal_get_pin_obj(mp_pin_make_new(NULL, 1, 0, (mp_obj_t[]) {MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIZNET_PIN_INTN)}));\n        use_interrupt = true;\n        #endif\n\n    } else\n    #endif\n    {\n        \n        #if WIZNET5K_WITH_LWIP_STACK\n        mp_arg_check_num(n_args, n_kw, 3, 4, false);\n        #else\n        mp_arg_check_num(n_args, n_kw, 3, 3, false);\n        #endif\n        spi = mp_hal_get_spi_obj(args[0]);\n        cs = mp_hal_get_pin_obj(args[1]);\n        rst = mp_hal_get_pin_obj(args[2]);\n        #if WIZNET5K_WITH_LWIP_STACK\n        if (n_args > 3) {\n            pin_intn = mp_hal_get_pin_obj(args[3]);\n            use_interrupt = true;\n        }\n        #endif\n    }\n\n    mp_hal_pin_output(cs);\n    mp_hal_pin_output(rst);\n\n    \n    wiznet5k_obj.base.type = (mp_obj_type_t *)&mod_network_nic_type_wiznet5k;\n    wiznet5k_obj.cris_state = 0;\n    wiznet5k_obj.spi = spi;\n    wiznet5k_obj.spi_transfer = ((mp_machine_spi_p_t *)MP_OBJ_TYPE_GET_SLOT(spi->type, protocol))->transfer;\n    wiznet5k_obj.cs = cs;\n    wiznet5k_obj.rst = rst;\n    #if WIZNET5K_WITH_LWIP_STACK\n    wiznet5k_obj.pin_intn = pin_intn;\n    wiznet5k_obj.use_interrupt = use_interrupt;\n    wiznet5k_obj.trace_flags = 0;\n    #else \n    wiznet5k_obj.active = false;\n    wiznet5k_obj.socket_used = 0;\n    #endif\n\n    \n    return MP_OBJ_FROM_PTR(&wiznet5k_obj);\n}\n\n\n\nstatic mp_obj_t wiznet5k_regs(mp_obj_t self_in) {\n    (void)self_in;\n    printf(\"Wiz CREG:\");\n    for (int i = 0; i < 0x50; ++i) {\n        if (i % 16 == 0) {\n            printf(\"\\n  %04x:\", i);\n        }\n        #if _WIZCHIP_ == 5500\n        uint32_t reg = _W5500_IO_BASE_ | i << 8;\n        #else\n        uint32_t reg = i;\n        #endif\n        printf(\" %02x\", WIZCHIP_READ(reg));\n    }\n    for (int sn = 0; sn < 4; ++sn) {\n        printf(\"\\nWiz SREG[%d]:\", sn);\n        for (int i = 0; i < 0x30; ++i) {\n            if (i % 16 == 0) {\n                printf(\"\\n  %04x:\", i);\n            }\n            #if _WIZCHIP_ == 5500\n            uint32_t reg = _W5500_IO_BASE_ | i << 8 | WIZCHIP_SREG_BLOCK(sn) << 3;\n            #else\n            uint32_t reg = WIZCHIP_SREG_ADDR(sn, i);\n            #endif\n            printf(\" %02x\", WIZCHIP_READ(reg));\n        }\n    }\n    printf(\"\\n\");\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(wiznet5k_regs_obj, wiznet5k_regs);\n\nstatic mp_obj_t wiznet5k_isconnected(mp_obj_t self_in) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_bool(\n        wizphy_getphylink() == PHY_LINK_ON\n        && IS_ACTIVE(self)\n        #if WIZNET5K_WITH_LWIP_STACK\n        && ip_2_ip4(&self->netif.ip_addr)->addr != 0\n        #endif\n        );\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(wiznet5k_isconnected_obj, wiznet5k_isconnected);\n\nstatic mp_obj_t wiznet5k_active(size_t n_args, const mp_obj_t *args) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    if (n_args == 1) {\n        return mp_obj_new_bool(IS_ACTIVE(self));\n    } else {\n        if (mp_obj_is_true(args[1])) {\n            if (!IS_ACTIVE(self)) {\n                 \n                \n                mp_hal_pin_low(wiznet5k_obj.rst);\n                mp_hal_delay_ms(1); \n                mp_hal_pin_high(wiznet5k_obj.rst);\n                mp_hal_delay_ms(160); \n\n                \n                reg_wizchip_cris_cbfunc(wiz_cris_enter, wiz_cris_exit);\n                reg_wizchip_cs_cbfunc(wiz_cs_select, wiz_cs_deselect);\n                reg_wizchip_spi_cbfunc(wiz_spi_readbyte, wiz_spi_writebyte);\n                reg_wizchip_spiburst_cbfunc(wiz_spi_read, wiz_spi_write);\n\n                \n                wiznet5k_init();\n\n                \n                #if WIZNET5K_WITH_LWIP_STACK\n                uint8_t *mac = self->netif.hwaddr;\n                #else \n                uint8_t *mac = wiznet5k_obj.netinfo.mac;\n                #endif\n                getSHAR(mac);\n                if ((mac[0] | mac[1] | mac[2] | mac[3] | mac[4] | mac[5]) == 0) {\n                    mp_hal_get_mac(MP_HAL_MAC_ETH0, mac);\n                    setSHAR(mac);\n                }\n\n                \n                mp_hal_delay_ms(250);\n\n            }\n        } else {\n            #if WIZNET5K_WITH_LWIP_STACK\n            netif_set_down(&self->netif);\n            netif_set_link_down(&self->netif);\n            wiznet5k_deinit();\n            #else \n            self->active = false;\n            wizchip_sw_reset();\n            #endif\n        }\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_active_obj, 1, 2, wiznet5k_active);\n\n#if WIZNET5K_PROVIDED_STACK\n\n\nstatic mp_obj_t wiznet5k_ifconfig(size_t n_args, const mp_obj_t *args) {\n    wiz_NetInfo netinfo;\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    ctlnetwork(CN_GET_NETINFO, &netinfo);\n    if (n_args == 1) {\n        \n        mp_obj_t tuple[4] = {\n            netutils_format_ipv4_addr(netinfo.ip, NETUTILS_BIG),\n            netutils_format_ipv4_addr(netinfo.sn, NETUTILS_BIG),\n            netutils_format_ipv4_addr(netinfo.gw, NETUTILS_BIG),\n            netutils_format_ipv4_addr(netinfo.dns, NETUTILS_BIG),\n        };\n        return mp_obj_new_tuple(4, tuple);\n    } else if (args[1] == MP_OBJ_NEW_QSTR(MP_QSTR_dhcp)) {\n        \n        self->netinfo.dhcp = NETINFO_DHCP;\n        wiznet5k_dhcp_init((void *)self);\n        mp_obj_t tuple[4] = {\n            netutils_format_ipv4_addr(self->netinfo.ip, NETUTILS_BIG),\n            netutils_format_ipv4_addr(self->netinfo.sn, NETUTILS_BIG),\n            netutils_format_ipv4_addr(self->netinfo.gw, NETUTILS_BIG),\n            netutils_format_ipv4_addr(self->netinfo.dns, NETUTILS_BIG),\n\n        };\n        return mp_obj_new_tuple(4, tuple);\n\n    } else {\n        \n        self->netinfo.dhcp = NETINFO_STATIC;\n        mp_obj_t *items;\n        mp_obj_get_array_fixed_n(args[1], 4, &items);\n        netutils_parse_ipv4_addr(items[0], netinfo.ip, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[1], netinfo.sn, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[2], netinfo.gw, NETUTILS_BIG);\n        netutils_parse_ipv4_addr(items[3], netinfo.dns, NETUTILS_BIG);\n        ctlnetwork(CN_SET_NETINFO, &netinfo);\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_ifconfig_obj, 1, 2, wiznet5k_ifconfig);\n#endif \n\n#if WIZNET5K_WITH_LWIP_STACK\n\nstatic mp_obj_t wiznet5k_ifconfig(size_t n_args, const mp_obj_t *args) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    return mod_network_nic_ifconfig(&self->netif, n_args - 1, args + 1);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_ifconfig_obj, 1, 2, wiznet5k_ifconfig);\n\nstatic mp_obj_t network_wiznet5k_ipconfig(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    return mod_network_nic_ipconfig(&self->netif, n_args - 1, args + 1, kwargs);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(wiznet5k_ipconfig_obj, 1, network_wiznet5k_ipconfig);\n\nstatic mp_obj_t send_ethernet_wrapper(mp_obj_t self_in, mp_obj_t buf_in) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t buf;\n    mp_get_buffer_raise(buf_in, &buf, MP_BUFFER_READ);\n    wiznet5k_send_ethernet(self, buf.len, buf.buf);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(send_ethernet_obj, send_ethernet_wrapper);\n\n#endif \n\nstatic mp_obj_t wiznet5k_status(size_t n_args, const mp_obj_t *args) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n    (void)self;\n\n    if (n_args == 1) {\n        \n        if (wizphy_getphylink() == PHY_LINK_ON) {\n            if (IS_ACTIVE(self)) {\n                return MP_OBJ_NEW_SMALL_INT(2);\n            } else {\n                return MP_OBJ_NEW_SMALL_INT(1);\n            }\n        } else {\n            return MP_OBJ_NEW_SMALL_INT(0);\n        }\n    }\n    mp_raise_ValueError(MP_ERROR_TEXT(\"unknown status param\"));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(wiznet5k_status_obj, 1, 2, wiznet5k_status);\n\nstatic mp_obj_t wiznet5k_config(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    wiznet5k_obj_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    if (kwargs->used == 0) {\n        \n        if (n_args != 2) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"must query one param\"));\n        }\n\n        switch (mp_obj_str_get_qstr(args[1])) {\n            case MP_QSTR_mac: {\n                uint8_t buf[6];\n                wiznet5k_get_mac_address(self, buf);\n                return mp_obj_new_bytes(buf, 6);\n            }\n            default:\n                mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n        }\n    } else {\n        \n        if (n_args != 1) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't specify pos and kw args\"));\n        }\n\n        for (size_t i = 0; i < kwargs->alloc; ++i) {\n            if (MP_MAP_SLOT_IS_FILLED(kwargs, i)) {\n                mp_map_elem_t *e = &kwargs->table[i];\n                switch (mp_obj_str_get_qstr(e->key)) {\n                    case MP_QSTR_mac: {\n                        mp_buffer_info_t buf;\n                        mp_get_buffer_raise(e->value, &buf, MP_BUFFER_READ);\n                        if (buf.len != 6) {\n                            mp_raise_ValueError(NULL);\n                        }\n                        setSHAR(buf.buf);\n                        #if WIZNET5K_WITH_LWIP_STACK\n                        memcpy(self->netif.hwaddr, buf.buf, 6);\n                        #endif\n                        break;\n                    }\n                    #if WIZNET5K_WITH_LWIP_STACK\n                    case MP_QSTR_trace: {\n                        self->trace_flags = mp_obj_get_int(e->value);\n                        break;\n                    }\n                    #endif\n                    default:\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"unknown config param\"));\n                }\n            }\n        }\n\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(wiznet5k_config_obj, 1, wiznet5k_config);\n\nstatic const mp_rom_map_elem_t wiznet5k_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_regs), MP_ROM_PTR(&wiznet5k_regs_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isconnected), MP_ROM_PTR(&wiznet5k_isconnected_obj) },\n    { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&wiznet5k_active_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ifconfig), MP_ROM_PTR(&wiznet5k_ifconfig_obj) },\n    #if WIZNET5K_WITH_LWIP_STACK\n    { MP_ROM_QSTR(MP_QSTR_ipconfig), MP_ROM_PTR(&wiznet5k_ipconfig_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_status), MP_ROM_PTR(&wiznet5k_status_obj) },\n    { MP_ROM_QSTR(MP_QSTR_config), MP_ROM_PTR(&wiznet5k_config_obj) },\n    #if WIZNET5K_WITH_LWIP_STACK\n    { MP_ROM_QSTR(MP_QSTR_send_ethernet), MP_ROM_PTR(&send_ethernet_obj) },\n    #endif\n};\nstatic MP_DEFINE_CONST_DICT(wiznet5k_locals_dict, wiznet5k_locals_dict_table);\n\n#if WIZNET5K_WITH_LWIP_STACK\n#define NIC_TYPE_WIZNET_PROTOCOL\n#else \nconst mod_network_nic_protocol_t mod_network_nic_protocol_wiznet = {\n    .gethostbyname = wiznet5k_gethostbyname,\n    .socket = wiznet5k_socket_socket,\n    .close = wiznet5k_socket_close,\n    .bind = wiznet5k_socket_bind,\n    .listen = wiznet5k_socket_listen,\n    .accept = wiznet5k_socket_accept,\n    .connect = wiznet5k_socket_connect,\n    .send = wiznet5k_socket_send,\n    .recv = wiznet5k_socket_recv,\n    .sendto = wiznet5k_socket_sendto,\n    .recvfrom = wiznet5k_socket_recvfrom,\n    .setsockopt = wiznet5k_socket_setsockopt,\n    .settimeout = wiznet5k_socket_settimeout,\n    .ioctl = wiznet5k_socket_ioctl,\n};\n#define NIC_TYPE_WIZNET_PROTOCOL protocol, &mod_network_nic_protocol_wiznet,\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mod_network_nic_type_wiznet5k,\n    MP_QSTR_WIZNET5K,\n    MP_TYPE_FLAG_NONE,\n    make_new, wiznet5k_make_new,\n    NIC_TYPE_WIZNET_PROTOCOL\n    locals_dict, &wiznet5k_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}