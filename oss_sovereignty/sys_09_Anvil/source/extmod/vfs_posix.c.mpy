{
  "module_name": "vfs_posix.c",
  "hash_id": "07e4e0b3d9bbfb4c267457e6f7d264663963c0bcaaa326a083f00cad25063390",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/vfs_posix.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n#include \"py/mpthread.h\"\n#include \"extmod/vfs.h\"\n#include \"extmod/vfs_posix.h\"\n\n#if MICROPY_VFS_POSIX\n\n#if !MICROPY_ENABLE_FINALISER\n#error \"MICROPY_VFS_POSIX requires MICROPY_ENABLE_FINALISER\"\n#endif\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#ifdef _MSC_VER\n#include <direct.h> \n#endif\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\ntypedef struct _mp_obj_vfs_posix_t {\n    mp_obj_base_t base;\n    vstr_t root;\n    size_t root_len;\n    bool readonly;\n} mp_obj_vfs_posix_t;\n\nstatic const char *vfs_posix_get_path_str(mp_obj_vfs_posix_t *self, mp_obj_t path) {\n    const char *path_str = mp_obj_str_get_str(path);\n    if (self->root_len == 0 || path_str[0] != '/') {\n        return path_str;\n    } else {\n        self->root.len = self->root_len - 1;\n        vstr_add_str(&self->root, path_str);\n        return vstr_null_terminated_str(&self->root);\n    }\n}\n\nstatic mp_obj_t vfs_posix_get_path_obj(mp_obj_vfs_posix_t *self, mp_obj_t path) {\n    const char *path_str = mp_obj_str_get_str(path);\n    if (self->root_len == 0 || path_str[0] != '/') {\n        return path;\n    } else {\n        self->root.len = self->root_len - 1;\n        vstr_add_str(&self->root, path_str);\n        return mp_obj_new_str(self->root.buf, self->root.len);\n    }\n}\n\nstatic mp_obj_t vfs_posix_fun1_helper(mp_obj_t self_in, mp_obj_t path_in, int (*f)(const char *)) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    int ret = f(vfs_posix_get_path_str(self, path_in));\n    if (ret != 0) {\n        mp_raise_OSError(errno);\n    }\n    return mp_const_none;\n}\n\nstatic mp_import_stat_t mp_vfs_posix_import_stat(void *self_in, const char *path) {\n    mp_obj_vfs_posix_t *self = self_in;\n    if (self->root_len != 0) {\n        self->root.len = self->root_len;\n        vstr_add_str(&self->root, path);\n        path = vstr_null_terminated_str(&self->root);\n    }\n    struct stat st;\n    if (stat(path, &st) == 0) {\n        if (S_ISDIR(st.st_mode)) {\n            return MP_IMPORT_STAT_DIR;\n        } else if (S_ISREG(st.st_mode)) {\n            return MP_IMPORT_STAT_FILE;\n        }\n    }\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\nstatic mp_obj_t vfs_posix_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n\n    mp_obj_vfs_posix_t *vfs = mp_obj_malloc(mp_obj_vfs_posix_t, type);\n    vstr_init(&vfs->root, 0);\n    if (n_args == 1) {\n        const char *root = mp_obj_str_get_str(args[0]);\n        \n        #ifdef _WIN32\n        char buf[MICROPY_ALLOC_PATH_MAX + 1];\n        DWORD result = GetFullPathNameA(root, sizeof(buf), buf, NULL);\n        if (result > 0 && result < sizeof(buf)) {\n            vstr_add_str(&vfs->root, buf);\n        } else {\n            mp_raise_OSError(GetLastError());\n        }\n        #else\n        if (root[0] != '\\0' && root[0] != '/') {\n            char buf[MICROPY_ALLOC_PATH_MAX + 1];\n            const char *cwd = getcwd(buf, sizeof(buf));\n            if (cwd == NULL) {\n                mp_raise_OSError(errno);\n            }\n            vstr_add_str(&vfs->root, cwd);\n            vstr_add_char(&vfs->root, '/');\n        }\n        vstr_add_str(&vfs->root, root);\n        #endif\n        vstr_add_char(&vfs->root, '/');\n    }\n    vfs->root_len = vfs->root.len;\n    vfs->readonly = false;\n\n    return MP_OBJ_FROM_PTR(vfs);\n}\n\nstatic mp_obj_t vfs_posix_mount(mp_obj_t self_in, mp_obj_t readonly, mp_obj_t mkfs) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    if (mp_obj_is_true(readonly)) {\n        self->readonly = true;\n    }\n    if (mp_obj_is_true(mkfs)) {\n        mp_raise_OSError(MP_EPERM);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(vfs_posix_mount_obj, vfs_posix_mount);\n\nstatic mp_obj_t vfs_posix_umount(mp_obj_t self_in) {\n    (void)self_in;\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(vfs_posix_umount_obj, vfs_posix_umount);\n\nstatic mp_obj_t vfs_posix_open(mp_obj_t self_in, mp_obj_t path_in, mp_obj_t mode_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    const char *mode = mp_obj_str_get_str(mode_in);\n    if (self->readonly\n        && (strchr(mode, 'w') != NULL || strchr(mode, 'a') != NULL || strchr(mode, '+') != NULL)) {\n        mp_raise_OSError(MP_EROFS);\n    }\n    if (!mp_obj_is_small_int(path_in)) {\n        path_in = vfs_posix_get_path_obj(self, path_in);\n    }\n    return mp_vfs_posix_file_open(&mp_type_vfs_posix_textio, path_in, mode_in);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(vfs_posix_open_obj, vfs_posix_open);\n\nstatic mp_obj_t vfs_posix_chdir(mp_obj_t self_in, mp_obj_t path_in) {\n    return vfs_posix_fun1_helper(self_in, path_in, chdir);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_chdir_obj, vfs_posix_chdir);\n\nstatic mp_obj_t vfs_posix_getcwd(mp_obj_t self_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    char buf[MICROPY_ALLOC_PATH_MAX + 1];\n    const char *ret = getcwd(buf, sizeof(buf));\n    if (ret == NULL) {\n        mp_raise_OSError(errno);\n    }\n    if (self->root_len > 0) {\n        ret += self->root_len - 1;\n        #ifdef _WIN32\n        if (*ret == '\\\\') {\n            *(char *)ret = '/';\n        }\n        #endif\n    }\n    return mp_obj_new_str(ret, strlen(ret));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(vfs_posix_getcwd_obj, vfs_posix_getcwd);\n\ntypedef struct _vfs_posix_ilistdir_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_fun_1_t finaliser;\n    bool is_str;\n    DIR *dir;\n} vfs_posix_ilistdir_it_t;\n\nstatic mp_obj_t vfs_posix_ilistdir_it_iternext(mp_obj_t self_in) {\n    vfs_posix_ilistdir_it_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->dir == NULL) {\n        return MP_OBJ_STOP_ITERATION;\n    }\n\n    for (;;) {\n        MP_THREAD_GIL_EXIT();\n        struct dirent *dirent = readdir(self->dir);\n        if (dirent == NULL) {\n            closedir(self->dir);\n            MP_THREAD_GIL_ENTER();\n            self->dir = NULL;\n            return MP_OBJ_STOP_ITERATION;\n        }\n        MP_THREAD_GIL_ENTER();\n        const char *fn = dirent->d_name;\n\n        if (fn[0] == '.' && (fn[1] == 0 || (fn[1] == '.' && fn[2] == 0))) {\n            \n            continue;\n        }\n\n        \n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(3, NULL));\n\n        if (self->is_str) {\n            t->items[0] = mp_obj_new_str(fn, strlen(fn));\n        } else {\n            t->items[0] = mp_obj_new_bytes((const byte *)fn, strlen(fn));\n        }\n\n        #ifdef _DIRENT_HAVE_D_TYPE\n        #ifdef DTTOIF\n        t->items[1] = MP_OBJ_NEW_SMALL_INT(DTTOIF(dirent->d_type));\n        #else\n        if (dirent->d_type == DT_DIR) {\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(MP_S_IFDIR);\n        } else if (dirent->d_type == DT_REG) {\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(MP_S_IFREG);\n        } else {\n            t->items[1] = MP_OBJ_NEW_SMALL_INT(dirent->d_type);\n        }\n        #endif\n        #else\n        \n        t->items[1] = MP_OBJ_NEW_SMALL_INT(0);\n        #endif\n\n        #ifdef _DIRENT_HAVE_D_INO\n        t->items[2] = MP_OBJ_NEW_SMALL_INT(dirent->d_ino);\n        #else\n        t->items[2] = MP_OBJ_NEW_SMALL_INT(0);\n        #endif\n\n        return MP_OBJ_FROM_PTR(t);\n    }\n}\n\nstatic mp_obj_t vfs_posix_ilistdir_it_del(mp_obj_t self_in) {\n    vfs_posix_ilistdir_it_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->dir != NULL) {\n        MP_THREAD_GIL_EXIT();\n        closedir(self->dir);\n        MP_THREAD_GIL_ENTER();\n    }\n    return mp_const_none;\n}\n\nstatic mp_obj_t vfs_posix_ilistdir(mp_obj_t self_in, mp_obj_t path_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    vfs_posix_ilistdir_it_t *iter = mp_obj_malloc_with_finaliser(vfs_posix_ilistdir_it_t, &mp_type_polymorph_iter_with_finaliser);\n    iter->iternext = vfs_posix_ilistdir_it_iternext;\n    iter->finaliser = vfs_posix_ilistdir_it_del;\n    iter->is_str = mp_obj_get_type(path_in) == &mp_type_str;\n    const char *path = vfs_posix_get_path_str(self, path_in);\n    if (path[0] == '\\0') {\n        path = \".\";\n    }\n    MP_THREAD_GIL_EXIT();\n    iter->dir = opendir(path);\n    MP_THREAD_GIL_ENTER();\n    if (iter->dir == NULL) {\n        mp_raise_OSError(errno);\n    }\n    return MP_OBJ_FROM_PTR(iter);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_ilistdir_obj, vfs_posix_ilistdir);\n\ntypedef struct _mp_obj_listdir_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    DIR *dir;\n} mp_obj_listdir_t;\n\nstatic mp_obj_t vfs_posix_mkdir(mp_obj_t self_in, mp_obj_t path_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    const char *path = vfs_posix_get_path_str(self, path_in);\n    MP_THREAD_GIL_EXIT();\n    #ifdef _WIN32\n    int ret = mkdir(path);\n    #else\n    int ret = mkdir(path, 0777);\n    #endif\n    MP_THREAD_GIL_ENTER();\n    if (ret != 0) {\n        mp_raise_OSError(errno);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_mkdir_obj, vfs_posix_mkdir);\n\nstatic mp_obj_t vfs_posix_remove(mp_obj_t self_in, mp_obj_t path_in) {\n    return vfs_posix_fun1_helper(self_in, path_in, unlink);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_remove_obj, vfs_posix_remove);\n\nstatic mp_obj_t vfs_posix_rename(mp_obj_t self_in, mp_obj_t old_path_in, mp_obj_t new_path_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    const char *old_path = vfs_posix_get_path_str(self, old_path_in);\n    const char *new_path = vfs_posix_get_path_str(self, new_path_in);\n    MP_THREAD_GIL_EXIT();\n    int ret = rename(old_path, new_path);\n    MP_THREAD_GIL_ENTER();\n    if (ret != 0) {\n        mp_raise_OSError(errno);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(vfs_posix_rename_obj, vfs_posix_rename);\n\nstatic mp_obj_t vfs_posix_rmdir(mp_obj_t self_in, mp_obj_t path_in) {\n    return vfs_posix_fun1_helper(self_in, path_in, rmdir);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_rmdir_obj, vfs_posix_rmdir);\n\nstatic mp_obj_t vfs_posix_stat(mp_obj_t self_in, mp_obj_t path_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    struct stat sb;\n    const char *path = vfs_posix_get_path_str(self, path_in);\n    int ret;\n    MP_HAL_RETRY_SYSCALL(ret, stat(path, &sb), mp_raise_OSError(err));\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n    t->items[0] = MP_OBJ_NEW_SMALL_INT(sb.st_mode);\n    t->items[1] = mp_obj_new_int_from_uint(sb.st_ino);\n    t->items[2] = mp_obj_new_int_from_uint(sb.st_dev);\n    t->items[3] = mp_obj_new_int_from_uint(sb.st_nlink);\n    t->items[4] = mp_obj_new_int_from_uint(sb.st_uid);\n    t->items[5] = mp_obj_new_int_from_uint(sb.st_gid);\n    t->items[6] = mp_obj_new_int_from_uint(sb.st_size);\n    t->items[7] = mp_obj_new_int_from_uint(sb.st_atime);\n    t->items[8] = mp_obj_new_int_from_uint(sb.st_mtime);\n    t->items[9] = mp_obj_new_int_from_uint(sb.st_ctime);\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_stat_obj, vfs_posix_stat);\n\n#if MICROPY_PY_OS_STATVFS\n\n#ifdef __ANDROID__\n#define USE_STATFS 1\n#endif\n\n#if USE_STATFS\n#include <sys/vfs.h>\n#define STRUCT_STATVFS struct statfs\n#define STATVFS statfs\n#define F_FAVAIL sb.f_ffree\n#define F_NAMEMAX sb.f_namelen\n#define F_FLAG sb.f_flags\n#else\n#include <sys/statvfs.h>\n#define STRUCT_STATVFS struct statvfs\n#define STATVFS statvfs\n#define F_FAVAIL sb.f_favail\n#define F_NAMEMAX sb.f_namemax\n#define F_FLAG sb.f_flag\n#endif\n\nstatic mp_obj_t vfs_posix_statvfs(mp_obj_t self_in, mp_obj_t path_in) {\n    mp_obj_vfs_posix_t *self = MP_OBJ_TO_PTR(self_in);\n    STRUCT_STATVFS sb;\n    const char *path = vfs_posix_get_path_str(self, path_in);\n    int ret;\n    MP_HAL_RETRY_SYSCALL(ret, STATVFS(path, &sb), mp_raise_OSError(err));\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(10, NULL));\n    t->items[0] = MP_OBJ_NEW_SMALL_INT(sb.f_bsize);\n    t->items[1] = MP_OBJ_NEW_SMALL_INT(sb.f_frsize);\n    t->items[2] = MP_OBJ_NEW_SMALL_INT(sb.f_blocks);\n    t->items[3] = MP_OBJ_NEW_SMALL_INT(sb.f_bfree);\n    t->items[4] = MP_OBJ_NEW_SMALL_INT(sb.f_bavail);\n    t->items[5] = MP_OBJ_NEW_SMALL_INT(sb.f_files);\n    t->items[6] = MP_OBJ_NEW_SMALL_INT(sb.f_ffree);\n    t->items[7] = MP_OBJ_NEW_SMALL_INT(F_FAVAIL);\n    t->items[8] = MP_OBJ_NEW_SMALL_INT(F_FLAG);\n    t->items[9] = MP_OBJ_NEW_SMALL_INT(F_NAMEMAX);\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(vfs_posix_statvfs_obj, vfs_posix_statvfs);\n\n#endif\n\nstatic const mp_rom_map_elem_t vfs_posix_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_mount), MP_ROM_PTR(&vfs_posix_mount_obj) },\n    { MP_ROM_QSTR(MP_QSTR_umount), MP_ROM_PTR(&vfs_posix_umount_obj) },\n    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&vfs_posix_open_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_chdir), MP_ROM_PTR(&vfs_posix_chdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_getcwd), MP_ROM_PTR(&vfs_posix_getcwd_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ilistdir), MP_ROM_PTR(&vfs_posix_ilistdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mkdir), MP_ROM_PTR(&vfs_posix_mkdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&vfs_posix_remove_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rename), MP_ROM_PTR(&vfs_posix_rename_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rmdir), MP_ROM_PTR(&vfs_posix_rmdir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stat), MP_ROM_PTR(&vfs_posix_stat_obj) },\n    #if MICROPY_PY_OS_STATVFS\n    { MP_ROM_QSTR(MP_QSTR_statvfs), MP_ROM_PTR(&vfs_posix_statvfs_obj) },\n    #endif\n};\nstatic MP_DEFINE_CONST_DICT(vfs_posix_locals_dict, vfs_posix_locals_dict_table);\n\nstatic const mp_vfs_proto_t vfs_posix_proto = {\n    .import_stat = mp_vfs_posix_import_stat,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_vfs_posix,\n    MP_QSTR_VfsPosix,\n    MP_TYPE_FLAG_NONE,\n    make_new, vfs_posix_make_new,\n    protocol, &vfs_posix_proto,\n    locals_dict, &vfs_posix_locals_dict\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}