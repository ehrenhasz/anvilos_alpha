{
  "module_name": "modnetwork.c",
  "hash_id": "aa9c67d0aebae4744b7f852c2dbfca6d76a220e841dc6781f4cc1795623213aa",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modnetwork.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK\n\n#include \"shared/netutils/netutils.h\"\n#include \"extmod/modnetwork.h\"\n\n#if MICROPY_PY_NETWORK_CYW43\n\n#include \"lib/cyw43-driver/src/cyw43.h\"\n#endif\n\n#ifdef MICROPY_PY_NETWORK_INCLUDEFILE\n#include MICROPY_PY_NETWORK_INCLUDEFILE\n#endif\n\n\n\n\n\nchar mod_network_country_code[2] = \"XX\";\n\n#ifndef MICROPY_PY_NETWORK_HOSTNAME_DEFAULT\n#error \"MICROPY_PY_NETWORK_HOSTNAME_DEFAULT must be set in mpconfigport.h or mpconfigboard.h\"\n#endif\n\nchar mod_network_hostname_data[MICROPY_PY_NETWORK_HOSTNAME_MAX_LEN + 1] = MICROPY_PY_NETWORK_HOSTNAME_DEFAULT;\n\n#ifdef MICROPY_PORT_NETWORK_INTERFACES\n\nvoid mod_network_init(void) {\n    mp_obj_list_init(&MP_STATE_PORT(mod_network_nic_list), 0);\n}\n\nvoid mod_network_deinit(void) {\n    #if !MICROPY_PY_LWIP\n    for (mp_uint_t i = 0; i < MP_STATE_PORT(mod_network_nic_list).len; i++) {\n        mp_obj_t nic = MP_STATE_PORT(mod_network_nic_list).items[i];\n        const mod_network_nic_protocol_t *nic_protocol = MP_OBJ_TYPE_GET_SLOT(mp_obj_get_type(nic), protocol);\n        if (nic_protocol->deinit) {\n            nic_protocol->deinit();\n        }\n    }\n    #endif\n}\n\nvoid mod_network_register_nic(mp_obj_t nic) {\n    for (mp_uint_t i = 0; i < MP_STATE_PORT(mod_network_nic_list).len; i++) {\n        if (MP_STATE_PORT(mod_network_nic_list).items[i] == nic) {\n            \n            return;\n        }\n    }\n    \n    mp_obj_list_append(MP_OBJ_FROM_PTR(&MP_STATE_PORT(mod_network_nic_list)), nic);\n}\n\nmp_obj_t mod_network_find_nic(const uint8_t *ip) {\n    \n    for (mp_uint_t i = 0; i < MP_STATE_PORT(mod_network_nic_list).len; i++) {\n        mp_obj_t nic = MP_STATE_PORT(mod_network_nic_list).items[i];\n        \n        \n        return nic;\n    }\n\n    mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"no available NIC\"));\n}\n\nstatic mp_obj_t network_route(void) {\n    return MP_OBJ_FROM_PTR(&MP_STATE_PORT(mod_network_nic_list));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(network_route_obj, network_route);\n\nMP_REGISTER_ROOT_POINTER(mp_obj_list_t mod_network_nic_list);\n\n#endif \n\nstatic mp_obj_t network_country(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 0) {\n        return mp_obj_new_str(mod_network_country_code, 2);\n    } else {\n        size_t len;\n        const char *str = mp_obj_str_get_data(args[0], &len);\n        if (len != 2) {\n            mp_raise_ValueError(NULL);\n        }\n        mod_network_country_code[0] = str[0];\n        mod_network_country_code[1] = str[1];\n        return mp_const_none;\n    }\n}\n\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_network_country_obj, 0, 1, network_country);\n\nmp_obj_t mod_network_hostname(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 0) {\n        return mp_obj_new_str(mod_network_hostname_data, strlen(mod_network_hostname_data));\n    } else {\n        size_t len;\n        const char *str = mp_obj_str_get_data(args[0], &len);\n        if (len > MICROPY_PY_NETWORK_HOSTNAME_MAX_LEN) {\n            mp_raise_ValueError(NULL);\n        }\n        memcpy(mod_network_hostname_data, str, len);\n        mod_network_hostname_data[len] = 0;\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_network_hostname_obj, 0, 1, mod_network_hostname);\n\n#if LWIP_VERSION_MAJOR >= 2\nMP_DEFINE_CONST_FUN_OBJ_KW(mod_network_ipconfig_obj, 0, mod_network_ipconfig);\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_network_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_network) },\n    { MP_ROM_QSTR(MP_QSTR_country), MP_ROM_PTR(&mod_network_country_obj) },\n    { MP_ROM_QSTR(MP_QSTR_hostname), MP_ROM_PTR(&mod_network_hostname_obj) },\n    #if LWIP_VERSION_MAJOR >= 2\n    { MP_ROM_QSTR(MP_QSTR_ipconfig), MP_ROM_PTR(&mod_network_ipconfig_obj) },\n    #endif\n\n    \n    #ifdef MICROPY_PORT_NETWORK_INTERFACES\n    { MP_ROM_QSTR(MP_QSTR_route), MP_ROM_PTR(&network_route_obj) },\n    MICROPY_PORT_NETWORK_INTERFACES\n    #endif\n\n    \n    #ifdef MICROPY_PY_NETWORK_MODULE_GLOBALS_INCLUDEFILE\n    #include MICROPY_PY_NETWORK_MODULE_GLOBALS_INCLUDEFILE\n    #else\n    \n    { MP_ROM_QSTR(MP_QSTR_STA_IF), MP_ROM_INT(MOD_NETWORK_STA_IF) },\n    { MP_ROM_QSTR(MP_QSTR_AP_IF), MP_ROM_INT(MOD_NETWORK_AP_IF) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_network_globals, mp_module_network_globals_table);\n\nconst mp_obj_module_t mp_module_network = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_network_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_network, mp_module_network);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}