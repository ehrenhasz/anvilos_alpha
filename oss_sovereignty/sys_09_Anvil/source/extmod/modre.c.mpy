{
  "module_name": "modre.c",
  "hash_id": "f4d865c486500ba08f30a5fe9c6f7ce5a08a02e0fec0ff4d39cedc7d41a56e25",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modre.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n#include \"py/objstr.h\"\n#include \"py/stackctrl.h\"\n\n#if MICROPY_PY_BUILTINS_STR_UNICODE\n#include \"py/unicode.h\"\n#endif\n\n#if MICROPY_PY_RE\n\n#define re1_5_stack_chk() MP_STACK_CHECK()\n\n#include \"lib/re1.5/re1.5.h\"\n\n#define FLAG_DEBUG 0x1000\n\ntypedef struct _mp_obj_re_t {\n    mp_obj_base_t base;\n    ByteProg re;\n} mp_obj_re_t;\n\ntypedef struct _mp_obj_match_t {\n    mp_obj_base_t base;\n    int num_matches;\n    mp_obj_t str;\n    const char *caps[0];\n} mp_obj_match_t;\n\nstatic mp_obj_t mod_re_compile(size_t n_args, const mp_obj_t *args);\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_obj_type_t re_type;\n#endif\n\nstatic void match_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_match_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<match num=%d>\", self->num_matches);\n}\n\nstatic mp_obj_t match_group(mp_obj_t self_in, mp_obj_t no_in) {\n    mp_obj_match_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_int_t no = mp_obj_get_int(no_in);\n    if (no < 0 || no >= self->num_matches) {\n        mp_raise_type_arg(&mp_type_IndexError, no_in);\n    }\n\n    const char *start = self->caps[no * 2];\n    if (start == NULL) {\n        \n        return mp_const_none;\n    }\n    return mp_obj_new_str_of_type(mp_obj_get_type(self->str),\n        (const byte *)start, self->caps[no * 2 + 1] - start);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(match_group_obj, match_group);\n\n#if MICROPY_PY_RE_MATCH_GROUPS\n\nstatic mp_obj_t match_groups(mp_obj_t self_in) {\n    mp_obj_match_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->num_matches <= 1) {\n        return mp_const_empty_tuple;\n    }\n    mp_obj_tuple_t *groups = MP_OBJ_TO_PTR(mp_obj_new_tuple(self->num_matches - 1, NULL));\n    for (int i = 1; i < self->num_matches; ++i) {\n        groups->items[i - 1] = match_group(self_in, MP_OBJ_NEW_SMALL_INT(i));\n    }\n    return MP_OBJ_FROM_PTR(groups);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(match_groups_obj, match_groups);\n\n#endif\n\n#if MICROPY_PY_RE_MATCH_SPAN_START_END\n\nstatic void match_span_helper(size_t n_args, const mp_obj_t *args, mp_obj_t span[2]) {\n    mp_obj_match_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    mp_int_t no = 0;\n    if (n_args == 2) {\n        no = mp_obj_get_int(args[1]);\n        if (no < 0 || no >= self->num_matches) {\n            mp_raise_type_arg(&mp_type_IndexError, args[1]);\n        }\n    }\n\n    mp_int_t s = -1;\n    mp_int_t e = -1;\n    const char *start = self->caps[no * 2];\n    if (start != NULL) {\n        \n        const char *begin = mp_obj_str_get_str(self->str);\n        s = start - begin;\n        e = self->caps[no * 2 + 1] - begin;\n    }\n\n    #if MICROPY_PY_BUILTINS_STR_UNICODE\n    if (mp_obj_get_type(self->str) == &mp_type_str) {\n        const byte *begin = (const byte *)mp_obj_str_get_str(self->str);\n        if (s != -1) {\n            s = utf8_ptr_to_index(begin, begin + s);\n        }\n        if (e != -1) {\n            e = utf8_ptr_to_index(begin, begin + e);\n        }\n    }\n    #endif\n\n    span[0] = mp_obj_new_int(s);\n    span[1] = mp_obj_new_int(e);\n}\n\nstatic mp_obj_t match_span(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t span[2];\n    match_span_helper(n_args, args, span);\n    return mp_obj_new_tuple(2, span);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(match_span_obj, 1, 2, match_span);\n\nstatic mp_obj_t match_start(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t span[2];\n    match_span_helper(n_args, args, span);\n    return span[0];\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(match_start_obj, 1, 2, match_start);\n\nstatic mp_obj_t match_end(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t span[2];\n    match_span_helper(n_args, args, span);\n    return span[1];\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(match_end_obj, 1, 2, match_end);\n\n#endif\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_rom_map_elem_t match_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_group), MP_ROM_PTR(&match_group_obj) },\n    #if MICROPY_PY_RE_MATCH_GROUPS\n    { MP_ROM_QSTR(MP_QSTR_groups), MP_ROM_PTR(&match_groups_obj) },\n    #endif\n    #if MICROPY_PY_RE_MATCH_SPAN_START_END\n    { MP_ROM_QSTR(MP_QSTR_span), MP_ROM_PTR(&match_span_obj) },\n    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&match_start_obj) },\n    { MP_ROM_QSTR(MP_QSTR_end), MP_ROM_PTR(&match_end_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(match_locals_dict, match_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    match_type,\n    MP_QSTR_match,\n    MP_TYPE_FLAG_NONE,\n    print, match_print,\n    locals_dict, &match_locals_dict\n    );\n#endif\n\nstatic void re_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_re_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<re %p>\", self);\n}\n\nstatic mp_obj_t re_exec(bool is_anchored, uint n_args, const mp_obj_t *args) {\n    (void)n_args;\n    mp_obj_re_t *self;\n    if (mp_obj_is_type(args[0], (mp_obj_type_t *)&re_type)) {\n        self = MP_OBJ_TO_PTR(args[0]);\n    } else {\n        self = MP_OBJ_TO_PTR(mod_re_compile(1, args));\n    }\n    Subject subj;\n    size_t len;\n    subj.begin_line = subj.begin = mp_obj_str_get_data(args[1], &len);\n    subj.end = subj.begin + len;\n    int caps_num = (self->re.sub + 1) * 2;\n    mp_obj_match_t *match = m_new_obj_var(mp_obj_match_t, caps, char *, caps_num);\n    \n    memset((char *)match->caps, 0, caps_num * sizeof(char *));\n    int res = re1_5_recursiveloopprog(&self->re, &subj, match->caps, caps_num, is_anchored);\n    if (res == 0) {\n        m_del_var(mp_obj_match_t, caps, char *, caps_num, match);\n        return mp_const_none;\n    }\n\n    match->base.type = (mp_obj_type_t *)&match_type;\n    match->num_matches = caps_num / 2; \n    match->str = args[1];\n    return MP_OBJ_FROM_PTR(match);\n}\n\nstatic mp_obj_t re_match(size_t n_args, const mp_obj_t *args) {\n    return re_exec(true, n_args, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_match_obj, 2, 4, re_match);\n\nstatic mp_obj_t re_search(size_t n_args, const mp_obj_t *args) {\n    return re_exec(false, n_args, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_search_obj, 2, 4, re_search);\n\nstatic mp_obj_t re_split(size_t n_args, const mp_obj_t *args) {\n    mp_obj_re_t *self = MP_OBJ_TO_PTR(args[0]);\n    Subject subj;\n    size_t len;\n    const mp_obj_type_t *str_type = mp_obj_get_type(args[1]);\n    subj.begin_line = subj.begin = mp_obj_str_get_data(args[1], &len);\n    subj.end = subj.begin + len;\n    int caps_num = (self->re.sub + 1) * 2;\n\n    int maxsplit = 0;\n    if (n_args > 2) {\n        maxsplit = mp_obj_get_int(args[2]);\n    }\n\n    mp_obj_t retval = mp_obj_new_list(0, NULL);\n    const char **caps = mp_local_alloc(caps_num * sizeof(char *));\n    while (true) {\n        \n        memset((char **)caps, 0, caps_num * sizeof(char *));\n        int res = re1_5_recursiveloopprog(&self->re, &subj, caps, caps_num, false);\n\n        \n        if (!res || caps[0] == caps[1]) {\n            break;\n        }\n\n        mp_obj_t s = mp_obj_new_str_of_type(str_type, (const byte *)subj.begin, caps[0] - subj.begin);\n        mp_obj_list_append(retval, s);\n        if (self->re.sub > 0) {\n            mp_raise_NotImplementedError(MP_ERROR_TEXT(\"splitting with sub-captures\"));\n        }\n        subj.begin = caps[1];\n        if (maxsplit > 0 && --maxsplit == 0) {\n            break;\n        }\n    }\n    \n    mp_local_free((char **)caps);\n\n    mp_obj_t s = mp_obj_new_str_of_type(str_type, (const byte *)subj.begin, subj.end - subj.begin);\n    mp_obj_list_append(retval, s);\n    return retval;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_split_obj, 2, 3, re_split);\n\n#if MICROPY_PY_RE_SUB\n\nstatic mp_obj_t re_sub_helper(size_t n_args, const mp_obj_t *args) {\n    mp_obj_re_t *self;\n    if (mp_obj_is_type(args[0], (mp_obj_type_t *)&re_type)) {\n        self = MP_OBJ_TO_PTR(args[0]);\n    } else {\n        self = MP_OBJ_TO_PTR(mod_re_compile(1, args));\n    }\n    mp_obj_t replace = args[1];\n    mp_obj_t where = args[2];\n    mp_int_t count = 0;\n    if (n_args > 3) {\n        count = mp_obj_get_int(args[3]);\n        \n    }\n\n    size_t where_len;\n    const char *where_str = mp_obj_str_get_data(where, &where_len);\n    Subject subj;\n    subj.begin_line = subj.begin = where_str;\n    subj.end = subj.begin + where_len;\n    int caps_num = (self->re.sub + 1) * 2;\n\n    vstr_t vstr_return;\n    vstr_return.buf = NULL; \n    mp_obj_match_t *match = mp_local_alloc(sizeof(mp_obj_match_t) + caps_num * sizeof(char *));\n    match->base.type = (mp_obj_type_t *)&match_type;\n    match->num_matches = caps_num / 2; \n    match->str = where;\n\n    for (;;) {\n        \n        memset((char *)match->caps, 0, caps_num * sizeof(char *));\n        int res = re1_5_recursiveloopprog(&self->re, &subj, match->caps, caps_num, false);\n\n        \n        if (!res || match->caps[0] == match->caps[1]) {\n            break;\n        }\n\n        \n        if (vstr_return.buf == NULL) {\n            vstr_init(&vstr_return, match->caps[0] - subj.begin);\n        }\n\n        \n        vstr_add_strn(&vstr_return, subj.begin, match->caps[0] - subj.begin);\n\n        \n        const char *repl = mp_obj_str_get_str((mp_obj_is_callable(replace) ? mp_call_function_1(replace, MP_OBJ_FROM_PTR(match)) : replace));\n\n        \n        while (*repl != '\\0') {\n            if (*repl == '\\\\') {\n                ++repl;\n                bool is_g_format = false;\n                if (*repl == 'g' && repl[1] == '<') {\n                    \n                    repl += 2;\n                    is_g_format = true;\n                }\n\n                if ('0' <= *repl && *repl <= '9') {\n                    \n                    unsigned int match_no = 0;\n                    do {\n                        match_no = match_no * 10 + (*repl++ - '0');\n                    } while ('0' <= *repl && *repl <= '9');\n                    if (is_g_format && *repl == '>') {\n                        ++repl;\n                    }\n\n                    if (match_no >= (unsigned int)match->num_matches) {\n                        mp_raise_type_arg(&mp_type_IndexError, MP_OBJ_NEW_SMALL_INT(match_no));\n                    }\n\n                    const char *start_match = match->caps[match_no * 2];\n                    if (start_match != NULL) {\n                        \n                        const char *end_match = match->caps[match_no * 2 + 1];\n                        vstr_add_strn(&vstr_return, start_match, end_match - start_match);\n                    }\n                } else if (*repl == '\\\\') {\n                    \n                    vstr_add_byte(&vstr_return, *repl++);\n                }\n            } else {\n                \n                vstr_add_byte(&vstr_return, *repl++);\n            }\n        }\n\n        \n        subj.begin = match->caps[1];\n\n        \n        if (count > 0 && --count == 0) {\n            break;\n        }\n    }\n\n    mp_local_free(match);\n\n    if (vstr_return.buf == NULL) {\n        \n        return where;\n    }\n\n    \n    vstr_add_strn(&vstr_return, subj.begin, subj.end - subj.begin);\n\n    if (mp_obj_get_type(where) == &mp_type_str) {\n        return mp_obj_new_str_from_utf8_vstr(&vstr_return);\n    } else {\n        return mp_obj_new_bytes_from_vstr(&vstr_return);\n    }\n}\n\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_sub_obj, 3, 5, re_sub_helper);\n\n#endif\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_rom_map_elem_t re_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_match), MP_ROM_PTR(&re_match_obj) },\n    { MP_ROM_QSTR(MP_QSTR_search), MP_ROM_PTR(&re_search_obj) },\n    { MP_ROM_QSTR(MP_QSTR_split), MP_ROM_PTR(&re_split_obj) },\n    #if MICROPY_PY_RE_SUB\n    { MP_ROM_QSTR(MP_QSTR_sub), MP_ROM_PTR(&re_sub_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(re_locals_dict, re_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    re_type,\n    MP_QSTR_re,\n    MP_TYPE_FLAG_NONE,\n    print, re_print,\n    locals_dict, &re_locals_dict\n    );\n#endif\n\nstatic mp_obj_t mod_re_compile(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    const char *re_str = mp_obj_str_get_str(args[0]);\n    int size = re1_5_sizecode(re_str);\n    if (size == -1) {\n        goto error;\n    }\n    mp_obj_re_t *o = mp_obj_malloc_var(mp_obj_re_t, re.insts, char, size, (mp_obj_type_t *)&re_type);\n    #if MICROPY_PY_RE_DEBUG\n    int flags = 0;\n    if (n_args > 1) {\n        flags = mp_obj_get_int(args[1]);\n    }\n    #endif\n    int error = re1_5_compilecode(&o->re, re_str);\n    if (error != 0) {\n    error:\n        mp_raise_ValueError(MP_ERROR_TEXT(\"error in regex\"));\n    }\n    #if MICROPY_PY_RE_DEBUG\n    if (flags & FLAG_DEBUG) {\n        re1_5_dumpcode(&o->re);\n    }\n    #endif\n    return MP_OBJ_FROM_PTR(o);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_re_compile_obj, 1, 2, mod_re_compile);\n\n#if !MICROPY_ENABLE_DYNRUNTIME\nstatic const mp_rom_map_elem_t mp_module_re_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_re) },\n    { MP_ROM_QSTR(MP_QSTR_compile), MP_ROM_PTR(&mod_re_compile_obj) },\n    { MP_ROM_QSTR(MP_QSTR_match), MP_ROM_PTR(&re_match_obj) },\n    { MP_ROM_QSTR(MP_QSTR_search), MP_ROM_PTR(&re_search_obj) },\n    #if MICROPY_PY_RE_SUB\n    { MP_ROM_QSTR(MP_QSTR_sub), MP_ROM_PTR(&re_sub_obj) },\n    #endif\n    #if MICROPY_PY_RE_DEBUG\n    { MP_ROM_QSTR(MP_QSTR_DEBUG), MP_ROM_INT(FLAG_DEBUG) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_re_globals, mp_module_re_globals_table);\n\nconst mp_obj_module_t mp_module_re = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_re_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_re, mp_module_re);\n#endif\n\n\n\n\n#define re1_5_fatal(x) assert(!x)\n\n#include \"lib/re1.5/compilecode.c\"\n#include \"lib/re1.5/recursiveloop.c\"\n#include \"lib/re1.5/charclass.c\"\n\n#if MICROPY_PY_RE_DEBUG\n\n#define printf(...) mp_printf(&mp_plat_print, __VA_ARGS__)\n#include \"lib/re1.5/dumpcode.c\"\n#undef printf\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}