{
  "module_name": "modlwip.c",
  "hash_id": "fcc3aac644b9450ae09dd910db7b185cfe46caabbadb95af94ea3c73b44dbb97",
  "original_prompt": "Ingested from sys_09_Anvil/source/extmod/modlwip.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <stdio.h>\n\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_LWIP\n\n#include \"shared/netutils/netutils.h\"\n#include \"modnetwork.h\"\n\n#include \"lwip/init.h\"\n#include \"lwip/tcp.h\"\n#include \"lwip/udp.h\"\n#include \"lwip/raw.h\"\n#include \"lwip/dns.h\"\n#include \"lwip/igmp.h\"\n#if LWIP_VERSION_MAJOR < 2\n#include \"lwip/timers.h\"\n#include \"lwip/tcp_impl.h\"\n#else\n#include \"lwip/timeouts.h\"\n#include \"lwip/priv/tcp_priv.h\"\n#endif\n\n#if 0 \n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\n\n\n#define MICROPY_PY_LWIP_TCP_CLOSE_TIMEOUT_MS (10000)\n\n\n\n#define IP_ADD_MEMBERSHIP 0x400\n#define IP_DROP_MEMBERSHIP 0x401\n\n#define TCP_NODELAY TF_NODELAY\n\n\n#ifndef ip_set_option\n#define ip_set_option(pcb, opt)   ((pcb)->so_options |= (opt))\n#endif\n#ifndef ip_reset_option\n#define ip_reset_option(pcb, opt) ((pcb)->so_options &= ~(opt))\n#endif\n#ifndef tcp_set_flags\n#define tcp_set_flags(pcb, set_flags) do { (pcb)->flags |= (set_flags); } while (0)\n#endif\n#ifndef tcp_clear_flags\n#define tcp_clear_flags(pcb, clear_flags) do { (pcb)->flags &= ~(clear_flags); } while (0)\n#endif\n\n\n#ifndef MICROPY_PY_LWIP_ENTER\n#define MICROPY_PY_LWIP_ENTER\n#define MICROPY_PY_LWIP_REENTER\n#define MICROPY_PY_LWIP_EXIT\n#endif\n\n#ifdef MICROPY_PY_LWIP_SLIP\n#include \"netif/slipif.h\"\n#include \"lwip/sio.h\"\n#endif\n\n#ifdef MICROPY_PY_LWIP_SLIP\n \n\n\n\ntypedef struct _lwip_slip_obj_t {\n    mp_obj_base_t base;\n    struct netif lwip_netif;\n} lwip_slip_obj_t;\n\n\nstatic lwip_slip_obj_t lwip_slip_obj;\n\n\nvoid mod_lwip_register_poll(void (*poll)(void *arg), void *poll_arg);\nvoid mod_lwip_deregister_poll(void (*poll)(void *arg), void *poll_arg);\n\nstatic void slip_lwip_poll(void *netif) {\n    slipif_poll((struct netif *)netif);\n}\n\nstatic const mp_obj_type_t lwip_slip_type;\n\n\nsio_fd_t sio_open(u8_t dvnum) {\n    \n    return (sio_fd_t)1;\n}\n\nvoid sio_send(u8_t c, sio_fd_t fd) {\n    mp_obj_type_t *type = mp_obj_get_type(MP_STATE_VM(lwip_slip_stream));\n    int error;\n    type->stream_p->write(MP_STATE_VM(lwip_slip_stream), &c, 1, &error);\n}\n\nu32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len) {\n    mp_obj_type_t *type = mp_obj_get_type(MP_STATE_VM(lwip_slip_stream));\n    int error;\n    mp_uint_t out_sz = type->stream_p->read(MP_STATE_VM(lwip_slip_stream), data, len, &error);\n    if (out_sz == MP_STREAM_ERROR) {\n        if (mp_is_nonblocking_error(error)) {\n            return 0;\n        }\n        \n        return 0;\n    }\n    return out_sz;\n}\n\n\nstatic mp_obj_t lwip_slip_make_new(mp_obj_t type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 3, 3, false);\n\n    lwip_slip_obj.base.type = &lwip_slip_type;\n\n    MP_STATE_VM(lwip_slip_stream) = args[0];\n\n    ip_addr_t iplocal, ipremote;\n    if (!ipaddr_aton(mp_obj_str_get_str(args[1]), &iplocal)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"not a valid local IP\"));\n    }\n    if (!ipaddr_aton(mp_obj_str_get_str(args[2]), &ipremote)) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"not a valid remote IP\"));\n    }\n\n    struct netif *n = &lwip_slip_obj.lwip_netif;\n    if (netif_add(n, &iplocal, IP_ADDR_BROADCAST, &ipremote, NULL, slipif_init, ip_input) == NULL) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"out of memory\"));\n    }\n    netif_set_up(n);\n    netif_set_default(n);\n    mod_lwip_register_poll(slip_lwip_poll, n);\n\n    return (mp_obj_t)&lwip_slip_obj;\n}\n\nstatic mp_obj_t lwip_slip_status(mp_obj_t self_in) {\n    \n    return mp_const_none;\n}\n\nstatic MP_DEFINE_CONST_FUN_OBJ_1(lwip_slip_status_obj, lwip_slip_status);\n\nstatic const mp_rom_map_elem_t lwip_slip_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_status), MP_ROM_PTR(&lwip_slip_status_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(lwip_slip_locals_dict, lwip_slip_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    lwip_slip_type,\n    MP_QSTR_slip,\n    MP_TYPE_FLAG_NONE,\n    make_new, lwip_slip_make_new,\n    locals_dict, &lwip_slip_locals_dict\n    );\n\n#endif \n\n \n\n\n\n\n\n#define LWIP_VERSION_MACRO (LWIP_VERSION_MAJOR << 24 | LWIP_VERSION_MINOR << 16 \\\n        | LWIP_VERSION_REVISION << 8 | LWIP_VERSION_RC)\n\n\n#define _ERR_BADF -16\n\n\n#if LWIP_VERSION_MACRO < 0x01040100\nstatic const int error_lookup_table[] = {\n    0,                 \n    MP_ENOMEM,         \n    MP_ENOBUFS,        \n    MP_EWOULDBLOCK,    \n    MP_EHOSTUNREACH,   \n    MP_EINPROGRESS,    \n    MP_EINVAL,         \n    MP_EWOULDBLOCK,    \n\n    MP_ECONNABORTED,   \n    MP_ECONNRESET,     \n    MP_ENOTCONN,       \n    MP_ENOTCONN,       \n    MP_EIO,            \n    MP_EADDRINUSE,     \n    -1,                \n    MP_EALREADY,       \n    MP_EBADF,          \n};\n#elif LWIP_VERSION_MACRO < 0x02000000\nstatic const int error_lookup_table[] = {\n    0,                 \n    MP_ENOMEM,         \n    MP_ENOBUFS,        \n    MP_EWOULDBLOCK,    \n    MP_EHOSTUNREACH,   \n    MP_EINPROGRESS,    \n    MP_EINVAL,         \n    MP_EWOULDBLOCK,    \n\n    MP_EADDRINUSE,     \n    MP_EALREADY,       \n    MP_ECONNABORTED,   \n    MP_ECONNRESET,     \n    MP_ENOTCONN,       \n    MP_ENOTCONN,       \n    MP_EIO,            \n    -1,                \n    MP_EBADF,          \n};\n#else\n\n#undef _ERR_BADF\n#define _ERR_BADF -17\nstatic const int error_lookup_table[] = {\n    0,                 \n    MP_ENOMEM,         \n    MP_ENOBUFS,        \n    MP_EWOULDBLOCK,    \n    MP_EHOSTUNREACH,   \n    MP_EINPROGRESS,    \n    MP_EINVAL,         \n    MP_EWOULDBLOCK,    \n    MP_EADDRINUSE,     \n    MP_EALREADY,       \n    MP_EALREADY,       \n    MP_ENOTCONN,       \n    -1,                \n    MP_ECONNABORTED,   \n    MP_ECONNRESET,     \n    MP_ENOTCONN,       \n    MP_EIO,            \n    MP_EBADF,          \n};\n#endif\n\n \n\n\n#define MOD_NETWORK_AF_INET (2)\n#define MOD_NETWORK_AF_INET6 (10)\n\n#define MOD_NETWORK_SOCK_STREAM (1)\n#define MOD_NETWORK_SOCK_DGRAM (2)\n#define MOD_NETWORK_SOCK_RAW (3)\n\ntypedef struct _lwip_socket_obj_t {\n    mp_obj_base_t base;\n\n    volatile union {\n        struct tcp_pcb *tcp;\n        struct udp_pcb *udp;\n        struct raw_pcb *raw;\n    } pcb;\n    volatile union {\n        struct pbuf *pbuf;\n        struct {\n            uint8_t alloc;\n            uint8_t iget;\n            uint8_t iput;\n            union {\n                struct tcp_pcb *item; \n                struct tcp_pcb **array; \n            } tcp;\n        } connection;\n    } incoming;\n    mp_obj_t callback;\n    byte peer[4];\n    mp_uint_t peer_port;\n    mp_uint_t timeout;\n    uint16_t recv_offset;\n\n    uint8_t domain;\n    uint8_t type;\n\n    #define STATE_NEW 0\n    #define STATE_LISTENING 1\n    #define STATE_CONNECTING 2\n    #define STATE_CONNECTED 3\n    #define STATE_PEER_CLOSED 4\n    #define STATE_ACTIVE_UDP 5\n    \n    int8_t state;\n} lwip_socket_obj_t;\n\nstatic inline void poll_sockets(void) {\n    mp_event_wait_ms(1);\n}\n\nstatic struct tcp_pcb *volatile *lwip_socket_incoming_array(lwip_socket_obj_t *socket) {\n    if (socket->incoming.connection.alloc == 0) {\n        return &socket->incoming.connection.tcp.item;\n    } else {\n        return &socket->incoming.connection.tcp.array[0];\n    }\n}\n\nstatic void lwip_socket_free_incoming(lwip_socket_obj_t *socket) {\n    bool socket_is_listener =\n        socket->type == MOD_NETWORK_SOCK_STREAM\n        && socket->pcb.tcp->state == LISTEN;\n\n    if (!socket_is_listener) {\n        if (socket->incoming.pbuf != NULL) {\n            pbuf_free(socket->incoming.pbuf);\n            socket->incoming.pbuf = NULL;\n        }\n    } else {\n        uint8_t alloc = socket->incoming.connection.alloc;\n        struct tcp_pcb *volatile *tcp_array = lwip_socket_incoming_array(socket);\n        for (uint8_t i = 0; i < alloc; ++i) {\n            \n            if (tcp_array[i] != NULL) {\n                tcp_poll(tcp_array[i], NULL, 0);\n                tcp_abort(tcp_array[i]);\n                tcp_array[i] = NULL;\n            }\n        }\n    }\n}\n\n#if LWIP_VERSION_MAJOR < 2\n#define IPADDR_STRLEN_MAX 46\n#endif\nmp_obj_t lwip_format_inet_addr(const ip_addr_t *ip, mp_uint_t port) {\n    char ipstr[IPADDR_STRLEN_MAX];\n    ipaddr_ntoa_r(ip, ipstr, sizeof(ipstr));\n    mp_obj_t tuple[2] = {\n        tuple[0] = mp_obj_new_str(ipstr, strlen(ipstr)),\n        tuple[1] = mp_obj_new_int(port),\n    };\n    return mp_obj_new_tuple(2, tuple);\n}\n\nmp_uint_t lwip_parse_inet_addr(mp_obj_t addr_in, ip_addr_t *out_ip) {\n    mp_obj_t *addr_items;\n    mp_obj_get_array_fixed_n(addr_in, 2, &addr_items);\n    size_t addr_len;\n    const char *addr_str = mp_obj_str_get_data(addr_items[0], &addr_len);\n    if (*addr_str == 0) {\n        #if LWIP_IPV6\n        *out_ip = *IP6_ADDR_ANY;\n        #else\n        *out_ip = *IP_ADDR_ANY;\n        #endif\n    } else {\n        if (!ipaddr_aton(addr_str, out_ip)) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"invalid arguments\"));\n        }\n    }\n    return mp_obj_get_int(addr_items[1]);\n}\n\n \n\n\nstatic inline void exec_user_callback(lwip_socket_obj_t *socket) {\n    if (socket->callback != MP_OBJ_NULL) {\n        \n        mp_sched_schedule(socket->callback, MP_OBJ_FROM_PTR(socket));\n    }\n}\n\n#if MICROPY_PY_LWIP_SOCK_RAW\n\n#if LWIP_VERSION_MAJOR < 2\nstatic u8_t _lwip_raw_incoming(void *arg, struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *addr)\n#else\nstatic u8_t _lwip_raw_incoming(void *arg, struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *addr)\n#endif\n{\n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)arg;\n\n    if (socket->incoming.pbuf != NULL) {\n        pbuf_free(p);\n    } else {\n        socket->incoming.pbuf = p;\n        memcpy(&socket->peer, addr, sizeof(socket->peer));\n    }\n    return 1; \n}\n#endif\n\n\n\n#if LWIP_VERSION_MAJOR < 2\nstatic void _lwip_udp_incoming(void *arg, struct udp_pcb *upcb, struct pbuf *p, ip_addr_t *addr, u16_t port)\n#else\nstatic void _lwip_udp_incoming(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)\n#endif\n{\n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)arg;\n\n    if (socket->incoming.pbuf != NULL) {\n        \n        pbuf_free(p);\n    } else {\n        socket->incoming.pbuf = p;\n        socket->peer_port = (mp_uint_t)port;\n        memcpy(&socket->peer, addr, sizeof(socket->peer));\n    }\n}\n\n\nstatic void _lwip_tcp_error(void *arg, err_t err) {\n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)arg;\n\n    \n    lwip_socket_free_incoming(socket);\n    \n    socket->state = err;\n    \n    socket->pcb.tcp = NULL;\n}\n\n\nstatic err_t _lwip_tcp_connected(void *arg, struct tcp_pcb *tpcb, err_t err) {\n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)arg;\n\n    socket->state = STATE_CONNECTED;\n    return ERR_OK;\n}\n\n\n\nstatic void _lwip_tcp_err_unaccepted(void *arg, err_t err) {\n    struct tcp_pcb *pcb = (struct tcp_pcb *)arg;\n\n    \n    \n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)pcb->connected;\n\n    \n    uint8_t alloc = socket->incoming.connection.alloc;\n    struct tcp_pcb **tcp_array = (struct tcp_pcb **)lwip_socket_incoming_array(socket);\n\n    \n    struct tcp_pcb **shift_down = NULL;\n    uint8_t i = socket->incoming.connection.iget;\n    do {\n        if (shift_down == NULL) {\n            if (tcp_array[i] == pcb) {\n                shift_down = &tcp_array[i];\n            }\n        } else {\n            *shift_down = tcp_array[i];\n            shift_down = &tcp_array[i];\n        }\n        if (++i >= alloc) {\n            i = 0;\n        }\n    } while (i != socket->incoming.connection.iput);\n\n    \n    if (shift_down != NULL) {\n        *shift_down = NULL;\n        socket->incoming.connection.iput = shift_down - tcp_array;\n    }\n}\n\n\n\n\n\n\nstatic err_t _lwip_tcp_recv_unaccepted(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err) {\n    return ERR_BUF;\n}\n\n\nstatic err_t _lwip_tcp_accept(void *arg, struct tcp_pcb *newpcb, err_t err) {\n    \n    if (err != ERR_OK) {\n        return ERR_OK;\n    }\n\n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)arg;\n    tcp_recv(newpcb, _lwip_tcp_recv_unaccepted);\n\n    \n    struct tcp_pcb *volatile *slot = &lwip_socket_incoming_array(socket)[socket->incoming.connection.iput];\n    if (*slot == NULL) {\n        \n        *slot = newpcb;\n        if (++socket->incoming.connection.iput >= socket->incoming.connection.alloc) {\n            socket->incoming.connection.iput = 0;\n        }\n\n        \n        exec_user_callback(socket);\n\n        \n        \n        \n        \n        newpcb->connected = (void *)socket;\n        tcp_arg(newpcb, newpcb);\n        tcp_err(newpcb, _lwip_tcp_err_unaccepted);\n\n        return ERR_OK;\n    }\n\n    DEBUG_printf(\"_lwip_tcp_accept: No room to queue pcb waiting for accept\\n\");\n    return ERR_BUF;\n}\n\n\nstatic err_t _lwip_tcp_recv(void *arg, struct tcp_pcb *tcpb, struct pbuf *p, err_t err) {\n    lwip_socket_obj_t *socket = (lwip_socket_obj_t *)arg;\n\n    if (p == NULL) {\n        \n        DEBUG_printf(\"_lwip_tcp_recv[%p]: other side closed connection\\n\", socket);\n        socket->state = STATE_PEER_CLOSED;\n        exec_user_callback(socket);\n        return ERR_OK;\n    }\n\n    if (socket->incoming.pbuf == NULL) {\n        socket->incoming.pbuf = p;\n    } else {\n        #ifdef SOCKET_SINGLE_PBUF\n        return ERR_BUF;\n        #else\n        pbuf_cat(socket->incoming.pbuf, p);\n        #endif\n    }\n\n    exec_user_callback(socket);\n\n    return ERR_OK;\n}\n\n \n\n\n\n\nstatic mp_uint_t lwip_raw_udp_send(lwip_socket_obj_t *socket, const byte *buf, mp_uint_t len, ip_addr_t *ip, mp_uint_t port, int *_errno) {\n    if (len > 0xffff) {\n        \n        len = 0xffff;\n    }\n\n    MICROPY_PY_LWIP_ENTER\n\n    \n    struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);\n    if (p == NULL) {\n        MICROPY_PY_LWIP_EXIT\n        *_errno = MP_ENOMEM;\n        return -1;\n    }\n\n    memcpy(p->payload, buf, len);\n\n    err_t err;\n    if (ip == NULL) {\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        if (socket->type == MOD_NETWORK_SOCK_RAW) {\n            err = raw_send(socket->pcb.raw, p);\n        } else\n        #endif\n        {\n            err = udp_send(socket->pcb.udp, p);\n        }\n    } else {\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        if (socket->type == MOD_NETWORK_SOCK_RAW) {\n            err = raw_sendto(socket->pcb.raw, p, ip);\n        } else\n        #endif\n        {\n            err = udp_sendto(socket->pcb.udp, p, ip, port);\n        }\n    }\n\n    pbuf_free(p);\n\n    MICROPY_PY_LWIP_EXIT\n\n    \n    \n    \n    if (err != ERR_OK && err != 1) {\n        *_errno = error_lookup_table[-err];\n        return -1;\n    }\n\n    return len;\n}\n\n\nstatic mp_uint_t lwip_raw_udp_receive(lwip_socket_obj_t *socket, byte *buf, mp_uint_t len, byte *ip, mp_uint_t *port, int *_errno) {\n\n    if (socket->incoming.pbuf == NULL) {\n        if (socket->timeout == 0) {\n            \n            *_errno = MP_EAGAIN;\n            return -1;\n        }\n\n        \n        mp_uint_t start = mp_hal_ticks_ms();\n        while (socket->incoming.pbuf == NULL) {\n            if (socket->timeout != -1 && mp_hal_ticks_ms() - start > socket->timeout) {\n                *_errno = MP_ETIMEDOUT;\n                return -1;\n            }\n            poll_sockets();\n        }\n    }\n\n    if (ip != NULL) {\n        memcpy(ip, &socket->peer, sizeof(socket->peer));\n        *port = socket->peer_port;\n    }\n\n    struct pbuf *p = socket->incoming.pbuf;\n\n    MICROPY_PY_LWIP_ENTER\n\n    u16_t result = pbuf_copy_partial(p, buf, ((p->tot_len > len) ? len : p->tot_len), 0);\n    pbuf_free(p);\n    socket->incoming.pbuf = NULL;\n\n    MICROPY_PY_LWIP_EXIT\n\n    return (mp_uint_t)result;\n}\n\n\n#define STREAM_ERROR_CHECK(socket) \\\n    if (socket->state < 0) { \\\n        *_errno = error_lookup_table[-socket->state]; \\\n        return MP_STREAM_ERROR; \\\n    } \\\n    assert(socket->pcb.tcp);\n\n\n#define STREAM_ERROR_CHECK_WITH_LOCK(socket) \\\n    if (socket->state < 0) { \\\n        *_errno = error_lookup_table[-socket->state]; \\\n        MICROPY_PY_LWIP_EXIT \\\n        return MP_STREAM_ERROR; \\\n    } \\\n    assert(socket->pcb.tcp);\n\n\n\nstatic mp_uint_t lwip_tcp_send(lwip_socket_obj_t *socket, const byte *buf, mp_uint_t len, int *_errno) {\n    \n    STREAM_ERROR_CHECK(socket);\n\n    MICROPY_PY_LWIP_ENTER\n\n    u16_t available = tcp_sndbuf(socket->pcb.tcp);\n\n    if (available == 0) {\n        \n        if (socket->timeout == 0) {\n            MICROPY_PY_LWIP_EXIT\n            *_errno = MP_EAGAIN;\n            return MP_STREAM_ERROR;\n        }\n\n        mp_uint_t start = mp_hal_ticks_ms();\n        \n        \n        \n        \n        \n        \n        while (socket->state >= STATE_CONNECTED && (available = tcp_sndbuf(socket->pcb.tcp)) < 16) {\n            MICROPY_PY_LWIP_EXIT\n            if (socket->timeout != -1 && mp_hal_ticks_ms() - start > socket->timeout) {\n                *_errno = MP_ETIMEDOUT;\n                return MP_STREAM_ERROR;\n            }\n            poll_sockets();\n            MICROPY_PY_LWIP_REENTER\n        }\n\n        \n        STREAM_ERROR_CHECK_WITH_LOCK(socket);\n    }\n\n    u16_t write_len = MIN(available, len);\n\n    \n    \n    \n    \n    \n    err_t err;\n    for (int i = 0; i < 200; ++i) {\n        err = tcp_write(socket->pcb.tcp, buf, write_len, TCP_WRITE_FLAG_COPY);\n        if (err != ERR_MEM) {\n            break;\n        }\n        err = tcp_output(socket->pcb.tcp);\n        if (err != ERR_OK) {\n            break;\n        }\n        MICROPY_PY_LWIP_EXIT\n        mp_hal_delay_ms(50);\n        MICROPY_PY_LWIP_REENTER\n    }\n\n    \n    \n    if (err == ERR_OK) {\n        err = tcp_output_nagle(socket->pcb.tcp);\n    }\n\n    MICROPY_PY_LWIP_EXIT\n\n    if (err != ERR_OK) {\n        *_errno = error_lookup_table[-err];\n        return MP_STREAM_ERROR;\n    }\n\n    return write_len;\n}\n\n\nstatic mp_uint_t lwip_tcp_receive(lwip_socket_obj_t *socket, byte *buf, mp_uint_t len, int *_errno) {\n    \n    STREAM_ERROR_CHECK(socket);\n\n    if (socket->incoming.pbuf == NULL) {\n\n        \n        if (socket->timeout == 0) {\n            if (socket->state == STATE_PEER_CLOSED) {\n                return 0;\n            }\n            *_errno = MP_EAGAIN;\n            return -1;\n        }\n\n        mp_uint_t start = mp_hal_ticks_ms();\n        while (socket->state == STATE_CONNECTED && socket->incoming.pbuf == NULL) {\n            if (socket->timeout != -1 && mp_hal_ticks_ms() - start > socket->timeout) {\n                *_errno = MP_ETIMEDOUT;\n                return -1;\n            }\n            poll_sockets();\n        }\n\n        if (socket->state == STATE_PEER_CLOSED) {\n            if (socket->incoming.pbuf == NULL) {\n                \n                return 0;\n            }\n        } else if (socket->state != STATE_CONNECTED) {\n            if (socket->state >= STATE_NEW) {\n                *_errno = MP_ENOTCONN;\n            } else {\n                *_errno = error_lookup_table[-socket->state];\n            }\n            return -1;\n        }\n    }\n\n    MICROPY_PY_LWIP_ENTER\n\n    assert(socket->pcb.tcp != NULL);\n\n    struct pbuf *p = socket->incoming.pbuf;\n\n    mp_uint_t remaining = p->len - socket->recv_offset;\n    if (len > remaining) {\n        len = remaining;\n    }\n\n    memcpy(buf, (byte *)p->payload + socket->recv_offset, len);\n\n    remaining -= len;\n    if (remaining == 0) {\n        socket->incoming.pbuf = p->next;\n        \n        \n        \n        pbuf_ref(p->next);\n        pbuf_free(p);\n        socket->recv_offset = 0;\n    } else {\n        socket->recv_offset += len;\n    }\n    tcp_recved(socket->pcb.tcp, len);\n\n    MICROPY_PY_LWIP_EXIT\n\n    return len;\n}\n\n \n\n\nstatic const mp_obj_type_t lwip_socket_type;\n\nstatic void lwip_socket_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    lwip_socket_obj_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<socket state=%d timeout=%d incoming=%p off=%d>\", self->state, self->timeout,\n        self->incoming.pbuf, self->recv_offset);\n}\n\n\nstatic mp_obj_t lwip_socket_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 4, false);\n\n    lwip_socket_obj_t *socket = mp_obj_malloc_with_finaliser(lwip_socket_obj_t, &lwip_socket_type);\n    socket->timeout = -1;\n    socket->recv_offset = 0;\n    socket->domain = MOD_NETWORK_AF_INET;\n    socket->type = MOD_NETWORK_SOCK_STREAM;\n    socket->callback = MP_OBJ_NULL;\n    socket->state = STATE_NEW;\n\n    if (n_args >= 1) {\n        socket->domain = mp_obj_get_int(args[0]);\n        if (n_args >= 2) {\n            socket->type = mp_obj_get_int(args[1]);\n        }\n    }\n\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM:\n            socket->pcb.tcp = tcp_new();\n            socket->incoming.connection.alloc = 0;\n            socket->incoming.connection.tcp.item = NULL;\n            break;\n        case MOD_NETWORK_SOCK_DGRAM:\n            socket->pcb.udp = udp_new();\n            socket->incoming.pbuf = NULL;\n            break;\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW: {\n            mp_int_t proto = n_args <= 2 ? 0 : mp_obj_get_int(args[2]);\n            socket->pcb.raw = raw_new(proto);\n            break;\n        }\n        #endif\n        default:\n            mp_raise_OSError(MP_EINVAL);\n    }\n\n    if (socket->pcb.tcp == NULL) {\n        mp_raise_OSError(MP_ENOMEM);\n    }\n\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            \n            tcp_arg(socket->pcb.tcp, (void *)socket);\n            \n            tcp_err(socket->pcb.tcp, _lwip_tcp_error);\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM: {\n            socket->state = STATE_ACTIVE_UDP;\n            \n            \n            udp_recv(socket->pcb.udp, _lwip_udp_incoming, (void *)socket);\n            break;\n        }\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW: {\n            \n            \n            raw_recv(socket->pcb.raw, _lwip_raw_incoming, (void *)socket);\n            break;\n        }\n        #endif\n    }\n\n    return MP_OBJ_FROM_PTR(socket);\n}\n\nstatic mp_obj_t lwip_socket_bind(mp_obj_t self_in, mp_obj_t addr_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n\n    ip_addr_t bind_addr;\n    mp_uint_t port = lwip_parse_inet_addr(addr_in, &bind_addr);\n\n    err_t err = ERR_ARG;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            err = tcp_bind(socket->pcb.tcp, &bind_addr, port);\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM: {\n            err = udp_bind(socket->pcb.udp, &bind_addr, port);\n            break;\n        }\n    }\n\n    if (err != ERR_OK) {\n        mp_raise_OSError(error_lookup_table[-err]);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_bind_obj, lwip_socket_bind);\n\nstatic mp_obj_t lwip_socket_listen(size_t n_args, const mp_obj_t *args) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(args[0]);\n\n    mp_int_t backlog = MICROPY_PY_SOCKET_LISTEN_BACKLOG_DEFAULT;\n    if (n_args > 1) {\n        backlog = mp_obj_get_int(args[1]);\n        backlog = (backlog < 0) ? 0 : backlog;\n    }\n\n    if (socket->pcb.tcp == NULL) {\n        mp_raise_OSError(MP_EBADF);\n    }\n    if (socket->type != MOD_NETWORK_SOCK_STREAM) {\n        mp_raise_OSError(MP_EOPNOTSUPP);\n    }\n    #if LWIP_IPV6\n    if (ip_addr_cmp(&socket->pcb.tcp->local_ip, IP6_ADDR_ANY)) {\n        IP_SET_TYPE_VAL(socket->pcb.tcp->local_ip,  IPADDR_TYPE_ANY);\n        IP_SET_TYPE_VAL(socket->pcb.tcp->remote_ip, IPADDR_TYPE_ANY);\n    }\n    #endif\n\n    struct tcp_pcb *new_pcb;\n    #if LWIP_VERSION_MACRO < 0x02000100\n    new_pcb = tcp_listen_with_backlog(socket->pcb.tcp, (u8_t)backlog);\n    #else\n    err_t error;\n    new_pcb = tcp_listen_with_backlog_and_err(socket->pcb.tcp, (u8_t)backlog, &error);\n    #endif\n\n    if (new_pcb == NULL) {\n        #if LWIP_VERSION_MACRO < 0x02000100\n        mp_raise_OSError(MP_ENOMEM);\n        #else\n        mp_raise_OSError(error_lookup_table[-error]);\n        #endif\n    }\n    socket->pcb.tcp = new_pcb;\n\n    \n    if (backlog <= 1) {\n        socket->incoming.connection.alloc = 0;\n        socket->incoming.connection.tcp.item = NULL;\n    } else {\n        socket->incoming.connection.alloc = backlog;\n        socket->incoming.connection.tcp.array = m_new0(struct tcp_pcb *, backlog);\n    }\n    socket->incoming.connection.iget = 0;\n    socket->incoming.connection.iput = 0;\n\n    tcp_accept(new_pcb, _lwip_tcp_accept);\n\n    \n    socket->state = STATE_LISTENING;\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(lwip_socket_listen_obj, 1, 2, lwip_socket_listen);\n\nstatic mp_obj_t lwip_socket_accept(mp_obj_t self_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n\n    if (socket->type != MOD_NETWORK_SOCK_STREAM) {\n        mp_raise_OSError(MP_EOPNOTSUPP);\n    }\n\n    \n    \n    lwip_socket_obj_t *socket2 = mp_obj_malloc_with_finaliser(lwip_socket_obj_t, &lwip_socket_type);\n\n    MICROPY_PY_LWIP_ENTER\n\n    if (socket->pcb.tcp == NULL) {\n        MICROPY_PY_LWIP_EXIT\n        m_del_obj(lwip_socket_obj_t, socket2);\n        mp_raise_OSError(MP_EBADF);\n    }\n\n    \n    struct tcp_pcb *listener = socket->pcb.tcp;\n    if (listener->state != LISTEN) {\n        MICROPY_PY_LWIP_EXIT\n        m_del_obj(lwip_socket_obj_t, socket2);\n        mp_raise_OSError(MP_EINVAL);\n    }\n\n    \n    struct tcp_pcb *volatile *incoming_connection = &lwip_socket_incoming_array(socket)[socket->incoming.connection.iget];\n    if (*incoming_connection == NULL) {\n        if (socket->timeout == 0) {\n            MICROPY_PY_LWIP_EXIT\n            m_del_obj(lwip_socket_obj_t, socket2);\n            mp_raise_OSError(MP_EAGAIN);\n        } else if (socket->timeout != -1) {\n            mp_uint_t retries = socket->timeout / 100;\n            while (*incoming_connection == NULL) {\n                MICROPY_PY_LWIP_EXIT\n                if (retries-- == 0) {\n                    m_del_obj(lwip_socket_obj_t, socket2);\n                    mp_raise_OSError(MP_ETIMEDOUT);\n                }\n                mp_hal_delay_ms(100);\n                MICROPY_PY_LWIP_REENTER\n            }\n        } else {\n            while (*incoming_connection == NULL) {\n                MICROPY_PY_LWIP_EXIT\n                poll_sockets();\n                MICROPY_PY_LWIP_REENTER\n            }\n        }\n    }\n\n    \n    socket2->pcb.tcp = *incoming_connection;\n    if (++socket->incoming.connection.iget >= socket->incoming.connection.alloc) {\n        socket->incoming.connection.iget = 0;\n    }\n    *incoming_connection = NULL;\n\n    \n    socket2->domain = MOD_NETWORK_AF_INET;\n    socket2->type = MOD_NETWORK_SOCK_STREAM;\n    socket2->incoming.pbuf = NULL;\n    socket2->timeout = socket->timeout;\n    socket2->state = STATE_CONNECTED;\n    socket2->recv_offset = 0;\n    socket2->callback = MP_OBJ_NULL;\n    tcp_arg(socket2->pcb.tcp, (void *)socket2);\n    tcp_err(socket2->pcb.tcp, _lwip_tcp_error);\n    tcp_recv(socket2->pcb.tcp, _lwip_tcp_recv);\n\n    tcp_accepted(listener);\n\n    MICROPY_PY_LWIP_EXIT\n\n    \n    mp_uint_t port = (mp_uint_t)socket2->pcb.tcp->remote_port;\n    mp_obj_tuple_t *client = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));\n    client->items[0] = MP_OBJ_FROM_PTR(socket2);\n    client->items[1] = lwip_format_inet_addr(&socket2->pcb.tcp->remote_ip, port);\n\n    return MP_OBJ_FROM_PTR(client);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(lwip_socket_accept_obj, lwip_socket_accept);\n\nstatic mp_obj_t lwip_socket_connect(mp_obj_t self_in, mp_obj_t addr_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n\n    if (socket->pcb.tcp == NULL) {\n        mp_raise_OSError(MP_EBADF);\n    }\n\n    \n    ip_addr_t dest;\n    mp_uint_t port = lwip_parse_inet_addr(addr_in, &dest);\n\n    err_t err = ERR_ARG;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            if (socket->state != STATE_NEW) {\n                if (socket->state == STATE_CONNECTED) {\n                    mp_raise_OSError(MP_EISCONN);\n                } else {\n                    mp_raise_OSError(MP_EALREADY);\n                }\n            }\n\n            \n            MICROPY_PY_LWIP_ENTER\n            tcp_recv(socket->pcb.tcp, _lwip_tcp_recv);\n            socket->state = STATE_CONNECTING;\n            err = tcp_connect(socket->pcb.tcp, &dest, port, _lwip_tcp_connected);\n            if (err != ERR_OK) {\n                MICROPY_PY_LWIP_EXIT\n                socket->state = STATE_NEW;\n                mp_raise_OSError(error_lookup_table[-err]);\n            }\n            socket->peer_port = (mp_uint_t)port;\n            memcpy(socket->peer, &dest, sizeof(socket->peer));\n            MICROPY_PY_LWIP_EXIT\n\n            \n            if (socket->timeout != -1) {\n                for (mp_uint_t retries = socket->timeout / 100; retries--;) {\n                    mp_hal_delay_ms(100);\n                    if (socket->state != STATE_CONNECTING) {\n                        break;\n                    }\n                }\n                if (socket->state == STATE_CONNECTING) {\n                    mp_raise_OSError(MP_EINPROGRESS);\n                }\n            } else {\n                while (socket->state == STATE_CONNECTING) {\n                    poll_sockets();\n                }\n            }\n            if (socket->state == STATE_CONNECTED) {\n                err = ERR_OK;\n            } else {\n                err = socket->state;\n            }\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM: {\n            err = udp_connect(socket->pcb.udp, &dest, port);\n            break;\n        }\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW: {\n            err = raw_connect(socket->pcb.raw, &dest);\n            break;\n        }\n        #endif\n    }\n\n    if (err != ERR_OK) {\n        mp_raise_OSError(error_lookup_table[-err]);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_connect_obj, lwip_socket_connect);\n\nstatic void lwip_socket_check_connected(lwip_socket_obj_t *socket) {\n    if (socket->pcb.tcp == NULL) {\n        \n        int _errno = error_lookup_table[-socket->state];\n        socket->state = _ERR_BADF;\n        mp_raise_OSError(_errno);\n    }\n}\n\nstatic mp_obj_t lwip_socket_send(mp_obj_t self_in, mp_obj_t buf_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    int _errno;\n\n    lwip_socket_check_connected(socket);\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf_in, &bufinfo, MP_BUFFER_READ);\n\n    mp_uint_t ret = 0;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            ret = lwip_tcp_send(socket, bufinfo.buf, bufinfo.len, &_errno);\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM:\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW:\n        #endif\n            ret = lwip_raw_udp_send(socket, bufinfo.buf, bufinfo.len, NULL, 0, &_errno);\n            break;\n    }\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n\n    return mp_obj_new_int_from_uint(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_send_obj, lwip_socket_send);\n\nstatic mp_obj_t lwip_socket_recv(mp_obj_t self_in, mp_obj_t len_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    int _errno;\n\n    lwip_socket_check_connected(socket);\n\n    mp_int_t len = mp_obj_get_int(len_in);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n\n    mp_uint_t ret = 0;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            ret = lwip_tcp_receive(socket, (byte *)vstr.buf, len, &_errno);\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM:\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW:\n        #endif\n            ret = lwip_raw_udp_receive(socket, (byte *)vstr.buf, len, NULL, NULL, &_errno);\n            break;\n    }\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n\n    if (ret == 0) {\n        return mp_const_empty_bytes;\n    }\n    vstr.len = ret;\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_recv_obj, lwip_socket_recv);\n\nstatic mp_obj_t lwip_socket_sendto(mp_obj_t self_in, mp_obj_t data_in, mp_obj_t addr_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    int _errno;\n\n    lwip_socket_check_connected(socket);\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(data_in, &bufinfo, MP_BUFFER_READ);\n\n    ip_addr_t ip;\n    mp_uint_t port = lwip_parse_inet_addr(addr_in, &ip);\n\n    mp_uint_t ret = 0;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            ret = lwip_tcp_send(socket, bufinfo.buf, bufinfo.len, &_errno);\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM:\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW:\n        #endif\n            ret = lwip_raw_udp_send(socket, bufinfo.buf, bufinfo.len, &ip, port, &_errno);\n            break;\n    }\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n\n    return mp_obj_new_int_from_uint(ret);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(lwip_socket_sendto_obj, lwip_socket_sendto);\n\nstatic mp_obj_t lwip_socket_recvfrom(mp_obj_t self_in, mp_obj_t len_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    int _errno;\n\n    lwip_socket_check_connected(socket);\n\n    mp_int_t len = mp_obj_get_int(len_in);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    byte ip[4];\n    mp_uint_t port;\n\n    mp_uint_t ret = 0;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            memcpy(ip, &socket->peer, sizeof(socket->peer));\n            port = (mp_uint_t)socket->peer_port;\n            ret = lwip_tcp_receive(socket, (byte *)vstr.buf, len, &_errno);\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM:\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW:\n        #endif\n            ret = lwip_raw_udp_receive(socket, (byte *)vstr.buf, len, ip, &port, &_errno);\n            break;\n    }\n    if (ret == -1) {\n        mp_raise_OSError(_errno);\n    }\n\n    mp_obj_t tuple[2];\n    if (ret == 0) {\n        tuple[0] = mp_const_empty_bytes;\n    } else {\n        vstr.len = ret;\n        tuple[0] = mp_obj_new_bytes_from_vstr(&vstr);\n    }\n    tuple[1] = netutils_format_inet_addr(ip, port, NETUTILS_BIG);\n    return mp_obj_new_tuple(2, tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_recvfrom_obj, lwip_socket_recvfrom);\n\nstatic mp_obj_t lwip_socket_sendall(mp_obj_t self_in, mp_obj_t buf_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    lwip_socket_check_connected(socket);\n\n    int _errno;\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf_in, &bufinfo, MP_BUFFER_READ);\n\n    mp_uint_t ret = 0;\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM: {\n            if (socket->timeout == 0) {\n                \n                \n                \n                \n                \n                if (bufinfo.len > tcp_sndbuf(socket->pcb.tcp)) {\n                    mp_raise_OSError(MP_EAGAIN);\n                }\n            }\n            \n            \n            while (bufinfo.len != 0) {\n                ret = lwip_tcp_send(socket, bufinfo.buf, bufinfo.len, &_errno);\n                if (ret == -1) {\n                    mp_raise_OSError(_errno);\n                }\n                bufinfo.len -= ret;\n                bufinfo.buf = (char *)bufinfo.buf + ret;\n            }\n            break;\n        }\n        case MOD_NETWORK_SOCK_DGRAM:\n            mp_raise_NotImplementedError(NULL);\n            break;\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_sendall_obj, lwip_socket_sendall);\n\nstatic mp_obj_t lwip_socket_settimeout(mp_obj_t self_in, mp_obj_t timeout_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    mp_uint_t timeout;\n    if (timeout_in == mp_const_none) {\n        timeout = -1;\n    } else {\n        #if MICROPY_PY_BUILTINS_FLOAT\n        timeout = (mp_uint_t)(MICROPY_FLOAT_CONST(1000.0) * mp_obj_get_float(timeout_in));\n        #else\n        timeout = 1000 * mp_obj_get_int(timeout_in);\n        #endif\n    }\n    socket->timeout = timeout;\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_settimeout_obj, lwip_socket_settimeout);\n\nstatic mp_obj_t lwip_socket_setblocking(mp_obj_t self_in, mp_obj_t flag_in) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    bool val = mp_obj_is_true(flag_in);\n    if (val) {\n        socket->timeout = -1;\n    } else {\n        socket->timeout = 0;\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(lwip_socket_setblocking_obj, lwip_socket_setblocking);\n\n#if LWIP_VERSION_MAJOR < 2\n#define MP_IGMP_IP_ADDR_TYPE ip_addr_t\n#else\n#define MP_IGMP_IP_ADDR_TYPE ip4_addr_t\n#endif\n\nstatic mp_obj_t lwip_socket_setsockopt(size_t n_args, const mp_obj_t *args) {\n    (void)n_args; \n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(args[0]);\n\n    int opt = mp_obj_get_int(args[2]);\n    if (opt == 20) {\n        if (args[3] == mp_const_none) {\n            socket->callback = MP_OBJ_NULL;\n        } else {\n            socket->callback = args[3];\n        }\n        return mp_const_none;\n    }\n\n    switch (opt) {\n        \n        case SOF_REUSEADDR:\n        case SOF_BROADCAST: {\n            mp_int_t val = mp_obj_get_int(args[3]);\n            \n            if (val) {\n                ip_set_option(socket->pcb.tcp, opt);\n            } else {\n                ip_reset_option(socket->pcb.tcp, opt);\n            }\n            break;\n        }\n\n        \n        case IP_ADD_MEMBERSHIP:\n        case IP_DROP_MEMBERSHIP: {\n            mp_buffer_info_t bufinfo;\n            mp_get_buffer_raise(args[3], &bufinfo, MP_BUFFER_READ);\n            if (bufinfo.len != sizeof(ip_addr_t) * 2) {\n                mp_raise_ValueError(NULL);\n            }\n\n            \n            err_t err;\n            if (opt == IP_ADD_MEMBERSHIP) {\n                err = igmp_joingroup((MP_IGMP_IP_ADDR_TYPE *)bufinfo.buf + 1, bufinfo.buf);\n            } else {\n                err = igmp_leavegroup((MP_IGMP_IP_ADDR_TYPE *)bufinfo.buf + 1, bufinfo.buf);\n            }\n            if (err != ERR_OK) {\n                mp_raise_OSError(error_lookup_table[-err]);\n            }\n            break;\n        }\n\n        \n        case TCP_NODELAY: {\n            mp_int_t val = mp_obj_get_int(args[3]);\n            if (val) {\n                tcp_set_flags(socket->pcb.tcp, opt);\n            } else {\n                tcp_clear_flags(socket->pcb.tcp, opt);\n            }\n            break;\n        }\n\n        default:\n            printf(\"Warning: lwip.setsockopt() not implemented\\n\");\n    }\n    return mp_const_none;\n}\n\n#undef MP_IGMP_IP_ADDR_TYPE\n\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(lwip_socket_setsockopt_obj, 4, 4, lwip_socket_setsockopt);\n\nstatic mp_obj_t lwip_socket_makefile(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    return args[0];\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(lwip_socket_makefile_obj, 1, 3, lwip_socket_makefile);\n\nstatic mp_uint_t lwip_socket_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM:\n            return lwip_tcp_receive(socket, buf, size, errcode);\n        case MOD_NETWORK_SOCK_DGRAM:\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW:\n        #endif\n            return lwip_raw_udp_receive(socket, buf, size, NULL, NULL, errcode);\n    }\n    \n    return MP_STREAM_ERROR;\n}\n\nstatic mp_uint_t lwip_socket_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n\n    switch (socket->type) {\n        case MOD_NETWORK_SOCK_STREAM:\n            return lwip_tcp_send(socket, buf, size, errcode);\n        case MOD_NETWORK_SOCK_DGRAM:\n        #if MICROPY_PY_LWIP_SOCK_RAW\n        case MOD_NETWORK_SOCK_RAW:\n        #endif\n            return lwip_raw_udp_send(socket, buf, size, NULL, 0, errcode);\n    }\n    \n    return MP_STREAM_ERROR;\n}\n\nstatic err_t _lwip_tcp_close_poll(void *arg, struct tcp_pcb *pcb) {\n    \n    tcp_poll(pcb, NULL, 0);\n    tcp_abort(pcb);\n    return ERR_OK;\n}\n\nstatic mp_uint_t lwip_socket_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    lwip_socket_obj_t *socket = MP_OBJ_TO_PTR(self_in);\n    mp_uint_t ret;\n\n    MICROPY_PY_LWIP_ENTER\n\n    if (request == MP_STREAM_POLL) {\n        uintptr_t flags = arg;\n        ret = 0;\n\n        if (flags & MP_STREAM_POLL_RD) {\n            if (socket->state == STATE_LISTENING) {\n                \n                if (lwip_socket_incoming_array(socket)[socket->incoming.connection.iget] != NULL) {\n                    ret |= MP_STREAM_POLL_RD;\n                }\n            } else {\n                \n                if (socket->incoming.pbuf != NULL) {\n                    ret |= MP_STREAM_POLL_RD;\n                }\n            }\n        }\n\n        if (flags & MP_STREAM_POLL_WR) {\n            if (socket->type == MOD_NETWORK_SOCK_DGRAM && socket->pcb.udp != NULL) {\n                \n                ret |= MP_STREAM_POLL_WR;\n            #if MICROPY_PY_LWIP_SOCK_RAW\n            } else if (socket->type == MOD_NETWORK_SOCK_RAW && socket->pcb.raw != NULL) {\n                \n                ret |= MP_STREAM_POLL_WR;\n            #endif\n            } else if (socket->pcb.tcp != NULL && tcp_sndbuf(socket->pcb.tcp) > 0) {\n                \n                \n                ret |= MP_STREAM_POLL_WR;\n            }\n        }\n\n        if (socket->state == STATE_NEW) {\n            \n            ret |= MP_STREAM_POLL_HUP;\n        } else if (socket->state == STATE_PEER_CLOSED) {\n            \n            \n            \n            ret |= flags & (MP_STREAM_POLL_RD | MP_STREAM_POLL_WR);\n        } else if (socket->state == ERR_RST) {\n            \n            ret |= flags & MP_STREAM_POLL_WR;\n            ret |= MP_STREAM_POLL_HUP;\n        } else if (socket->state == _ERR_BADF) {\n            ret |= MP_STREAM_POLL_NVAL;\n        } else if (socket->state < 0) {\n            \n            \n            ret |= MP_STREAM_POLL_ERR;\n        }\n\n    } else if (request == MP_STREAM_CLOSE) {\n        if (socket->pcb.tcp == NULL) {\n            MICROPY_PY_LWIP_EXIT\n            return 0;\n        }\n\n        \n        lwip_socket_free_incoming(socket);\n\n        switch (socket->type) {\n            case MOD_NETWORK_SOCK_STREAM: {\n                \n                tcp_arg(socket->pcb.tcp, NULL);\n                tcp_err(socket->pcb.tcp, NULL);\n                tcp_recv(socket->pcb.tcp, NULL);\n\n                if (socket->pcb.tcp->state != LISTEN) {\n                    \n                    \n                    \n                    tcp_poll(socket->pcb.tcp, _lwip_tcp_close_poll, MICROPY_PY_LWIP_TCP_CLOSE_TIMEOUT_MS / 500);\n                }\n                if (tcp_close(socket->pcb.tcp) != ERR_OK) {\n                    DEBUG_printf(\"lwip_close: had to call tcp_abort()\\n\");\n                    tcp_abort(socket->pcb.tcp);\n                }\n                break;\n            }\n            case MOD_NETWORK_SOCK_DGRAM:\n                udp_recv(socket->pcb.udp, NULL, NULL);\n                udp_remove(socket->pcb.udp);\n                break;\n            #if MICROPY_PY_LWIP_SOCK_RAW\n            case MOD_NETWORK_SOCK_RAW:\n                raw_recv(socket->pcb.raw, NULL, NULL);\n                raw_remove(socket->pcb.raw);\n                break;\n            #endif\n        }\n\n        socket->pcb.tcp = NULL;\n        socket->state = _ERR_BADF;\n        ret = 0;\n\n    } else {\n        *errcode = MP_EINVAL;\n        ret = MP_STREAM_ERROR;\n    }\n\n    MICROPY_PY_LWIP_EXIT\n\n    return ret;\n}\n\nstatic const mp_rom_map_elem_t lwip_socket_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_bind), MP_ROM_PTR(&lwip_socket_bind_obj) },\n    { MP_ROM_QSTR(MP_QSTR_listen), MP_ROM_PTR(&lwip_socket_listen_obj) },\n    { MP_ROM_QSTR(MP_QSTR_accept), MP_ROM_PTR(&lwip_socket_accept_obj) },\n    { MP_ROM_QSTR(MP_QSTR_connect), MP_ROM_PTR(&lwip_socket_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_send), MP_ROM_PTR(&lwip_socket_send_obj) },\n    { MP_ROM_QSTR(MP_QSTR_recv), MP_ROM_PTR(&lwip_socket_recv_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sendto), MP_ROM_PTR(&lwip_socket_sendto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_recvfrom), MP_ROM_PTR(&lwip_socket_recvfrom_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sendall), MP_ROM_PTR(&lwip_socket_sendall_obj) },\n    { MP_ROM_QSTR(MP_QSTR_settimeout), MP_ROM_PTR(&lwip_socket_settimeout_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setblocking), MP_ROM_PTR(&lwip_socket_setblocking_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setsockopt), MP_ROM_PTR(&lwip_socket_setsockopt_obj) },\n    { MP_ROM_QSTR(MP_QSTR_makefile), MP_ROM_PTR(&lwip_socket_makefile_obj) },\n\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(lwip_socket_locals_dict, lwip_socket_locals_dict_table);\n\nstatic const mp_stream_p_t lwip_socket_stream_p = {\n    .read = lwip_socket_read,\n    .write = lwip_socket_write,\n    .ioctl = lwip_socket_ioctl,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    lwip_socket_type,\n    MP_QSTR_socket,\n    MP_TYPE_FLAG_NONE,\n    make_new, lwip_socket_make_new,\n    print, lwip_socket_print,\n    protocol, &lwip_socket_stream_p,\n    locals_dict, &lwip_socket_locals_dict\n    );\n\n \n\n\n\nsys_prot_t sys_arch_protect() {\n    return (sys_prot_t)MICROPY_BEGIN_ATOMIC_SECTION();\n}\n\nvoid sys_arch_unprotect(sys_prot_t state) {\n    MICROPY_END_ATOMIC_SECTION((mp_uint_t)state);\n}\n\n \n\n\n\ntypedef struct nic_poll {\n    void (*poll)(void *arg);\n    void *poll_arg;\n} nic_poll_t;\n\nstatic nic_poll_t lwip_poll_list;\n\nvoid mod_lwip_register_poll(void (*poll)(void *arg), void *poll_arg) {\n    lwip_poll_list.poll = poll;\n    lwip_poll_list.poll_arg = poll_arg;\n}\n\nvoid mod_lwip_deregister_poll(void (*poll)(void *arg), void *poll_arg) {\n    lwip_poll_list.poll = NULL;\n}\n\n \n\n\nstatic mp_obj_t mod_lwip_reset() {\n    lwip_init();\n    lwip_poll_list.poll = NULL;\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mod_lwip_reset_obj, mod_lwip_reset);\n\nstatic mp_obj_t mod_lwip_callback() {\n    if (lwip_poll_list.poll != NULL) {\n        lwip_poll_list.poll(lwip_poll_list.poll_arg);\n    }\n    sys_check_timeouts();\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mod_lwip_callback_obj, mod_lwip_callback);\n\ntypedef struct _getaddrinfo_state_t {\n    volatile int status;\n    volatile ip_addr_t ipaddr;\n} getaddrinfo_state_t;\n\n\n#if LWIP_VERSION_MAJOR < 2\nstatic void lwip_getaddrinfo_cb(const char *name, ip_addr_t *ipaddr, void *arg)\n#else\nstatic void lwip_getaddrinfo_cb(const char *name, const ip_addr_t *ipaddr, void *arg)\n#endif\n{\n    getaddrinfo_state_t *state = arg;\n    if (ipaddr != NULL) {\n        state->status = 1;\n        state->ipaddr = *ipaddr;\n    } else {\n        \n        state->status = -2;\n    }\n}\n\n\nstatic mp_obj_t lwip_getaddrinfo(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t host_in = args[0], port_in = args[1];\n    const char *host = mp_obj_str_get_str(host_in);\n    mp_int_t port = mp_obj_get_int(port_in);\n\n    \n    if (n_args > 2) {\n        mp_int_t family = mp_obj_get_int(args[2]);\n        mp_int_t type = 0;\n        mp_int_t proto = 0;\n        mp_int_t flags = 0;\n        if (n_args > 3) {\n            type = mp_obj_get_int(args[3]);\n            if (n_args > 4) {\n                proto = mp_obj_get_int(args[4]);\n                if (n_args > 5) {\n                    flags = mp_obj_get_int(args[5]);\n                }\n            }\n        }\n        if (!((family == 0 || family == MOD_NETWORK_AF_INET)\n              && (type == 0 || type == MOD_NETWORK_SOCK_STREAM)\n              && proto == 0\n              && flags == 0)) {\n            mp_warning(MP_WARN_CAT(RuntimeWarning), \"unsupported getaddrinfo constraints\");\n        }\n    }\n\n    getaddrinfo_state_t state;\n    state.status = 0;\n\n    MICROPY_PY_LWIP_ENTER\n    #if LWIP_VERSION_MAJOR < 2\n    err_t ret = dns_gethostbyname(host, (ip_addr_t *)&state.ipaddr, lwip_getaddrinfo_cb, &state);\n    #else\n    err_t ret = dns_gethostbyname_addrtype(host, (ip_addr_t *)&state.ipaddr, lwip_getaddrinfo_cb, &state, mp_mod_network_prefer_dns_use_ip_version == 4 ? LWIP_DNS_ADDRTYPE_IPV4_IPV6 : LWIP_DNS_ADDRTYPE_IPV6_IPV4);\n    #endif\n    MICROPY_PY_LWIP_EXIT\n\n    switch (ret) {\n        case ERR_OK:\n            \n            state.status = 1;\n            break;\n        case ERR_INPROGRESS:\n            while (state.status == 0) {\n                poll_sockets();\n            }\n            break;\n        default:\n            state.status = ret;\n    }\n\n    if (state.status < 0) {\n        \n        \n        mp_raise_OSError(state.status);\n    }\n\n    ip_addr_t ipcopy = state.ipaddr;\n    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(mp_obj_new_tuple(5, NULL));\n    tuple->items[0] = MP_OBJ_NEW_SMALL_INT(MOD_NETWORK_AF_INET);\n    tuple->items[1] = MP_OBJ_NEW_SMALL_INT(MOD_NETWORK_SOCK_STREAM);\n    tuple->items[2] = MP_OBJ_NEW_SMALL_INT(0);\n    tuple->items[3] = MP_OBJ_NEW_QSTR(MP_QSTR_);\n    tuple->items[4] = lwip_format_inet_addr(&ipcopy, port);\n    return mp_obj_new_list(1, (mp_obj_t *)&tuple);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(lwip_getaddrinfo_obj, 2, 6, lwip_getaddrinfo);\n\n\n\nstatic mp_obj_t lwip_print_pcbs() {\n    tcp_debug_print_pcbs();\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_0(lwip_print_pcbs_obj, lwip_print_pcbs);\n\nstatic const mp_rom_map_elem_t mp_module_lwip_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_lwip) },\n    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mod_lwip_reset_obj) },\n    { MP_ROM_QSTR(MP_QSTR_callback), MP_ROM_PTR(&mod_lwip_callback_obj) },\n    { MP_ROM_QSTR(MP_QSTR_getaddrinfo), MP_ROM_PTR(&lwip_getaddrinfo_obj) },\n    { MP_ROM_QSTR(MP_QSTR_print_pcbs), MP_ROM_PTR(&lwip_print_pcbs_obj) },\n    \n    { MP_ROM_QSTR(MP_QSTR_socket), MP_ROM_PTR(&lwip_socket_type) },\n    #ifdef MICROPY_PY_LWIP_SLIP\n    { MP_ROM_QSTR(MP_QSTR_slip), MP_ROM_PTR(&lwip_slip_type) },\n    #endif\n    \n    { MP_ROM_QSTR(MP_QSTR_AF_INET), MP_ROM_INT(MOD_NETWORK_AF_INET) },\n    { MP_ROM_QSTR(MP_QSTR_AF_INET6), MP_ROM_INT(MOD_NETWORK_AF_INET6) },\n\n    { MP_ROM_QSTR(MP_QSTR_SOCK_STREAM), MP_ROM_INT(MOD_NETWORK_SOCK_STREAM) },\n    { MP_ROM_QSTR(MP_QSTR_SOCK_DGRAM), MP_ROM_INT(MOD_NETWORK_SOCK_DGRAM) },\n    #if MICROPY_PY_LWIP_SOCK_RAW\n    { MP_ROM_QSTR(MP_QSTR_SOCK_RAW), MP_ROM_INT(MOD_NETWORK_SOCK_RAW) },\n    #endif\n\n    { MP_ROM_QSTR(MP_QSTR_SOL_SOCKET), MP_ROM_INT(1) },\n    { MP_ROM_QSTR(MP_QSTR_SO_REUSEADDR), MP_ROM_INT(SOF_REUSEADDR) },\n    { MP_ROM_QSTR(MP_QSTR_SO_BROADCAST), MP_ROM_INT(SOF_BROADCAST) },\n\n    { MP_ROM_QSTR(MP_QSTR_IPPROTO_IP), MP_ROM_INT(0) },\n    { MP_ROM_QSTR(MP_QSTR_IP_ADD_MEMBERSHIP), MP_ROM_INT(IP_ADD_MEMBERSHIP) },\n    { MP_ROM_QSTR(MP_QSTR_IP_DROP_MEMBERSHIP), MP_ROM_INT(IP_DROP_MEMBERSHIP) },\n\n    { MP_ROM_QSTR(MP_QSTR_IPPROTO_TCP), MP_ROM_INT(IP_PROTO_TCP) },\n    { MP_ROM_QSTR(MP_QSTR_TCP_NODELAY), MP_ROM_INT(TCP_NODELAY) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_lwip_globals, mp_module_lwip_globals_table);\n\nconst mp_obj_module_t mp_module_lwip = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_lwip_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_lwip, mp_module_lwip);\n\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_socket, mp_module_lwip);\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t lwip_slip_stream);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}