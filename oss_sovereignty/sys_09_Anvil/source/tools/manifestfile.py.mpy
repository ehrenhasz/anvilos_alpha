{
  "module_name": "manifestfile.py",
  "hash_id": "85fbff6d30f2b590d29dd2b2d86b8f49c1fdc73fd8ce2843634426ace63d44b4",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/manifestfile.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2022 Jim Mussared\n# Copyright (c) 2019 Damien P. George\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom __future__ import print_function\nimport contextlib\nimport os\nimport sys\nimport glob\nimport tempfile\nfrom collections import namedtuple\n\n__all__ = [\"ManifestFileError\", \"ManifestFile\"]\n\n# Allow freeze*() etc.\nMODE_FREEZE = 1\n# Only allow include/require/module/package.\nMODE_COMPILE = 2\n# Same as compile, but handles require(..., pypi=\"name\") as a requirements.txt entry.\nMODE_PYPROJECT = 3\n\n# In compile mode, .py -> KIND_COMPILE_AS_MPY\n# In freeze mode, .py -> KIND_FREEZE_AS_MPY, .mpy->KIND_FREEZE_MPY\nKIND_AUTO = 1\n# Freeze-mode only, .py -> KIND_FREEZE_AS_MPY, .mpy->KIND_FREEZE_MPY\nKIND_FREEZE_AUTO = 2\n\n# Freeze-mode only, The .py file will be frozen as text.\nKIND_FREEZE_AS_STR = 3\n# Freeze-mode only, The .py file will be compiled and frozen as bytecode.\nKIND_FREEZE_AS_MPY = 4\n# Freeze-mode only, The .mpy file will be frozen directly.\nKIND_FREEZE_MPY = 5\n# Compile mode only, the .py file should be compiled to .mpy.\nKIND_COMPILE_AS_MPY = 6\n\n# File on the local filesystem.\nFILE_TYPE_LOCAL = 1\n# URL to file. (TODO)\nFILE_TYPE_HTTP = 2\n\n# Default list of libraries in micropython-lib to search for library packages.\nBASE_LIBRARY_NAMES = (\"micropython\", \"python-stdlib\", \"python-ecosys\")\n\n\nclass ManifestFileError(Exception):\n    pass\n\n\nclass ManifestIgnoreException(Exception):\n    pass\n\n\nclass ManifestUsePyPIException(Exception):\n    def __init__(self, pypi_name):\n        self.pypi_name = pypi_name\n\n\n# The set of files that this manifest references.\nManifestOutput = namedtuple(\n    \"ManifestOutput\",\n    [\n        \"file_type\",  # FILE_TYPE_*.\n        \"full_path\",  # The input file full path.\n        \"target_path\",  # The target path on the device.\n        \"timestamp\",  # Last modified date of the input file.\n        \"kind\",  # KIND_*.\n        \"metadata\",  # Metadata for the containing package.\n        \"opt\",  # Optimisation level (or None).\n    ],\n)\n\n\n# Represents the metadata for a package.\nclass ManifestPackageMetadata:\n    def __init__(self, is_require=False):\n        self._is_require = is_require\n        self._initialised = False\n\n        self.version = None\n        self.description = None\n        self.license = None\n        self.author = None\n\n        # Annotate a package as being from the python standard library.\n        self.stdlib = False\n\n        # Allows a python-ecosys package to be annotated with the\n        # corresponding name in PyPI. e.g. micropython-lib/requests is based\n        # on pypi/requests.\n        self.pypi = None\n        # For a micropython package, this is the name that we will publish it\n        # to PyPI as. e.g. micropython-lib/senml publishes as\n        # pypi/micropython-senml.\n        self.pypi_publish = None\n\n    def update(\n        self,\n        mode,\n        description=None,\n        version=None,\n        license=None,\n        author=None,\n        stdlib=False,\n        pypi=None,\n        pypi_publish=None,\n    ):\n        if self._initialised:\n            raise ManifestFileError(\"Duplicate call to metadata().\")\n\n        # In MODE_PYPROJECT, if this manifest is being evaluated as a result\n        # of a require(), then figure out if it should be replaced by a PyPI\n        # dependency instead.\n        if mode == MODE_PYPROJECT and self._is_require:\n            if stdlib:\n                # No dependency required at all for CPython.\n                raise ManifestIgnoreException\n            if pypi_publish or pypi:\n                # In the case where a package is both based on a PyPI package and\n                # provides one, preference depending on the published one.\n                # (This should be pretty rare).\n                raise ManifestUsePyPIException(pypi_publish or pypi)\n\n        self.description = description\n        self.version = version\n        self.license = license\n        self.author = author\n        self.pypi = pypi\n        self.pypi_publish = pypi_publish\n        self._initialised = True\n\n    def check_initialised(self, mode):\n        # Ensure that metadata() is the first thing a manifest.py does.\n        # This is to ensure that we early-exit if it should be replaced by a pypi dependency.\n        if mode in (MODE_COMPILE, MODE_PYPROJECT):\n            if not self._initialised:\n                raise ManifestFileError(\"metadata() must be the first command in a manifest file.\")\n\n    def __str__(self):\n        return \"version={} description={} license={} author={} pypi={} pypi_publish={}\".format(\n            self.version, self.description, self.license, self.author, self.pypi, self.pypi_publish\n        )\n\n\n# Turns a dict of options into a object with attributes used to turn the\n# kwargs passed to include() and require into the \"options\" global in the\n# included manifest.\n#   options = IncludeOptions(foo=\"bar\", blah=\"stuff\")\n#   options.foo # \"bar\"\n#   options.blah # \"stuff\"\nclass IncludeOptions:\n    def __init__(self, **kwargs):\n        self._kwargs = kwargs\n        self._defaults = {}\n\n    def defaults(self, **kwargs):\n        self._defaults = kwargs\n\n    def __getattr__(self, name):\n        return self._kwargs.get(name, self._defaults.get(name, None))\n\n\nclass ManifestFile:\n    def __init__(self, mode, path_vars=None):\n        # See MODE_* constants above.\n        self._mode = mode\n        # Path substitution variables.\n        self._path_vars = path_vars or {}\n        # List of files (as ManifestFileResult) references by this manifest.\n        self._manifest_files = []\n        # List of PyPI dependencies (when mode=MODE_PYPROJECT).\n        self._pypi_dependencies = []\n        # Don't allow including the same file twice.\n        self._visited = set()\n        # Stack of metadata for each level.\n        self._metadata = [ManifestPackageMetadata()]\n        # Registered external libraries.\n        self._libraries = {}\n        # List of directories to search for packages.\n        self._library_dirs = []\n        # Add default micropython-lib libraries if $(MPY_LIB_DIR) has been specified.\n        if self._path_vars[\"MPY_LIB_DIR\"]:\n            for lib in BASE_LIBRARY_NAMES:\n                self.add_library(lib, os.path.join(\"$(MPY_LIB_DIR)\", lib))\n\n    def _resolve_path(self, path):\n        # Convert path to an absolute path, applying variable substitutions.\n        for name, value in self._path_vars.items():\n            if value is not None:\n                path = path.replace(\"$({})\".format(name), value)\n        return os.path.abspath(path)\n\n    def _manifest_globals(self, kwargs):\n        # This is the \"API\" available to a manifest file.\n        g = {\n            \"metadata\": self.metadata,\n            \"include\": self.include,\n            \"require\": self.require,\n            \"add_library\": self.add_library,\n            \"package\": self.package,\n            \"module\": self.module,\n            \"options\": IncludeOptions(**kwargs),\n        }\n\n        # Extra legacy functions only for freeze mode.\n        if self._mode == MODE_FREEZE:\n            g.update(\n                {\n                    \"freeze\": self.freeze,\n                    \"freeze_as_str\": self.freeze_as_str,\n                    \"freeze_as_mpy\": self.freeze_as_mpy,\n                    \"freeze_mpy\": self.freeze_mpy,\n                }\n            )\n\n        return g\n\n    def files(self):\n        return self._manifest_files\n\n    def pypi_dependencies(self):\n        # In MODE_PYPROJECT, this will return a list suitable for requirements.txt.\n        return self._pypi_dependencies\n\n    def execute(self, manifest_file):\n        if manifest_file.endswith(\".py\"):\n            # Execute file from filesystem.\n            self.include(manifest_file)\n        else:\n            # Execute manifest code snippet.\n            try:\n                exec(manifest_file, self._manifest_globals({}))\n            except Exception as er:\n                raise ManifestFileError(\"Error in manifest: {}\".format(er))\n\n    def _add_file(self, full_path, target_path, kind=KIND_AUTO, opt=None):\n        # Check file exists and get timestamp.\n        try:\n            stat = os.stat(full_path)\n            timestamp = stat.st_mtime\n        except OSError:\n            raise ManifestFileError(\"Cannot stat {}\".format(full_path))\n\n        # Map the AUTO kinds to their actual kind based on mode and extension.\n        _, ext = os.path.splitext(full_path)\n        if self._mode == MODE_FREEZE:\n            if kind in (\n                KIND_AUTO,\n                KIND_FREEZE_AUTO,\n            ):\n                if ext.lower() == \".py\":\n                    kind = KIND_FREEZE_AS_MPY\n                elif ext.lower() == \".mpy\":\n                    kind = KIND_FREEZE_MPY\n        else:\n            if kind != KIND_AUTO:\n                raise ManifestFileError(\"Not in freeze mode\")\n            if ext.lower() != \".py\":\n                raise ManifestFileError(\"Expected .py file\")\n            kind = KIND_COMPILE_AS_MPY\n\n        self._manifest_files.append(\n            ManifestOutput(\n                FILE_TYPE_LOCAL, full_path, target_path, timestamp, kind, self._metadata[-1], opt\n            )\n        )\n\n    def _search(self, base_path, package_path, files, exts, kind, opt=None, strict=False):\n        base_path = self._resolve_path(base_path)\n\n        if files is not None:\n            # Use explicit list of files (relative to package_path).\n            for file in files:\n                if package_path:\n                    file = os.path.join(package_path, file)\n                self._add_file(os.path.join(base_path, file), file, kind=kind, opt=opt)\n        else:\n            if base_path:\n                prev_cwd = os.getcwd()\n                os.chdir(self._resolve_path(base_path))\n\n            # Find all candidate files.\n            for dirpath, _, filenames in os.walk(package_path or \".\", followlinks=True):\n                for file in filenames:\n                    file = os.path.relpath(os.path.join(dirpath, file), \".\")\n                    _, ext = os.path.splitext(file)\n                    if ext.lower() in exts:\n                        self._add_file(\n                            os.path.join(base_path, file),\n                            file,\n                            kind=kind,\n                            opt=opt,\n                        )\n                    elif strict:\n                        raise ManifestFileError(\"Unexpected file type\")\n\n            if base_path:\n                os.chdir(prev_cwd)\n\n    def metadata(self, **kwargs):\n        \"\"\"\n        From within a manifest file, use this to set the metadata for the\n        package described by current manifest.\n\n        After executing a manifest file (via execute()), call this\n        to obtain the metadata for the top-level manifest file.\n\n        See ManifestPackageMetadata.update() for valid kwargs.\n        \"\"\"\n        if kwargs:\n            self._metadata[-1].update(self._mode, **kwargs)\n        return self._metadata[-1]\n\n    def include(self, manifest_path, is_require=False, **kwargs):\n        \"\"\"\n        Include another manifest.\n\n        The manifest argument can be a string (filename) or an iterable of\n        strings.\n\n        Relative paths are resolved with respect to the current manifest file.\n\n        If the path is to a directory, then it implicitly includes the\n        manifest.py file inside that directory.\n\n        Optional kwargs can be provided which will be available to the\n        included script via the `options` variable.\n\n        e.g. include(\"path.py\", extra_features=True)\n\n        in path.py:\n            options.defaults(standard_features=True)\n\n            # freeze minimal modules.\n            if options.standard_features:\n                # freeze standard modules.\n            if options.extra_features:\n                # freeze extra modules.\n        \"\"\"\n        if is_require:\n            self._metadata[-1].check_initialised(self._mode)\n\n        if not isinstance(manifest_path, str):\n            for m in manifest_path:\n                self.include(m, **kwargs)\n        else:\n            manifest_path = self._resolve_path(manifest_path)\n            # Including a directory grabs the manifest.py inside it.\n            if os.path.isdir(manifest_path):\n                manifest_path = os.path.join(manifest_path, \"manifest.py\")\n            if manifest_path in self._visited:\n                return\n            self._visited.add(manifest_path)\n            if is_require:\n                # This include is the result of require(\"name\"), so push a new\n                # package metadata onto the stack.\n                self._metadata.append(ManifestPackageMetadata(is_require=True))\n            try:\n                with open(manifest_path) as f:\n                    # Make paths relative to this manifest file while processing it.\n                    # Applies to includes and input files.\n                    prev_cwd = os.getcwd()\n                    os.chdir(os.path.dirname(manifest_path))\n                    try:\n                        exec(f.read(), self._manifest_globals(kwargs))\n                    finally:\n                        os.chdir(prev_cwd)\n            except ManifestIgnoreException:\n                # e.g. MODE_PYPROJECT and this was a stdlib dependency. No-op.\n                pass\n            except ManifestUsePyPIException as e:\n                # e.g. MODE_PYPROJECT and this was a package from\n                # python-ecosys. Add PyPI dependency instead.\n                self._pypi_dependencies.append(e.pypi_name)\n            except Exception as e:\n                raise ManifestFileError(\"Error in manifest file: {}: {}\".format(manifest_path, e))\n            if is_require:\n                self._metadata.pop()\n\n    def _require_from_path(self, library_path, name, version, extra_kwargs):\n        for root, dirnames, filenames in os.walk(library_path):\n            if os.path.basename(root) == name and \"manifest.py\" in filenames:\n                self.include(root, is_require=True, **extra_kwargs)\n                return True\n        return False\n\n    def require(self, name, version=None, pypi=None, library=None, **kwargs):\n        \"\"\"\n        Require a package by name from micropython-lib.\n\n        Optionally specify pipy=\"package-name\" to indicate that this should\n        use the named package from PyPI when building for CPython.\n\n        Optionally specify library=\"name\" to reference a package from a\n        library that has been previously registered with add_library(). Otherwise\n        the list of library paths will be used.\n        \"\"\"\n        self._metadata[-1].check_initialised(self._mode)\n\n        if self._mode == MODE_PYPROJECT and pypi:\n            # In PYPROJECT mode, allow overriding the PyPI dependency name\n            # explicitly. Otherwise if the dependent package has metadata\n            # (pypi_publish) or metadata(pypi) we will use that.\n            self._pypi_dependencies.append(pypi)\n            return\n\n        if library is not None:\n            # Find package in external library.\n            if library not in self._libraries:\n                raise ValueError(\"Unknown library '{}' for require('{}').\".format(library, name))\n            library_path = self._libraries[library]\n            # Search for {library_path}/**/{name}/manifest.py.\n            if self._require_from_path(library_path, name, version, kwargs):\n                return\n            raise ValueError(\n                \"Package '{}' not found in external library '{}' ({}).\".format(\n                    name, library, library_path\n                )\n            )\n\n        for lib_dir in self._library_dirs:\n            # Search for {lib_dir}/**/{name}/manifest.py.\n            if self._require_from_path(lib_dir, name, version, kwargs):\n                return\n\n        raise ValueError(\"Package '{}' not found in any known library.\".format(name))\n\n    def add_library(self, library, library_path, prepend=False):\n        \"\"\"\n        Register the path to an external named library.\n\n        The path will be automatically searched when using require().  By default the\n        added library is added to the end of the list of libraries to search.  Pass\n        `prepend=True` to add it to the start of the list.\n\n        Additionally, the added library can be explicitly requested by using\n        `require(\"name\", library=\"library\")`.\n        \"\"\"\n        library_path = self._resolve_path(library_path)\n        self._libraries[library] = library_path\n        self._library_dirs.insert(0 if prepend else len(self._library_dirs), library_path)\n\n    def package(self, package_path, files=None, base_path=\".\", opt=None):\n        \"\"\"\n        Define a package, optionally restricting to a set of files.\n\n        Simple case, a package in the current directory:\n            package(\"foo\")\n        will include all .py files in foo, and will be stored as foo/bar/baz.py.\n\n        If the package isn't in the current directory, use base_path:\n            package(\"foo\", base_path=\"src\")\n\n        To restrict to certain files in the package use files (note: paths should be relative to the package):\n            package(\"foo\", files=[\"bar/baz.py\"])\n        \"\"\"\n        self._metadata[-1].check_initialised(self._mode)\n\n        # Include \"base_path/package_path/**/*.py\" --> \"package_path/**/*.py\"\n        self._search(base_path, package_path, files, exts=(\".py\",), kind=KIND_AUTO, opt=opt)\n\n    def module(self, module_path, base_path=\".\", opt=None):\n        \"\"\"\n        Include a single Python file as a module.\n\n        If the file is in the current directory:\n            module(\"foo.py\")\n\n        Otherwise use base_path to locate the file:\n            module(\"foo.py\", \"src/drivers\")\n        \"\"\"\n        self._metadata[-1].check_initialised(self._mode)\n\n        # Include \"base_path/module_path\" --> \"module_path\"\n        base_path = self._resolve_path(base_path)\n        _, ext = os.path.splitext(module_path)\n        if ext.lower() != \".py\":\n            raise ManifestFileError(\"module must be .py file\")\n        # TODO: version None\n        self._add_file(os.path.join(base_path, module_path), module_path, opt=opt)\n\n    def _freeze_internal(self, path, script, exts, kind, opt):\n        if script is None:\n            self._search(path, None, None, exts=exts, kind=kind, opt=opt)\n        elif isinstance(script, str) and os.path.isdir(os.path.join(path, script)):\n            self._search(path, script, None, exts=exts, kind=kind, opt=opt)\n        elif not isinstance(script, str):\n            self._search(path, None, script, exts=exts, kind=kind, opt=opt)\n        else:\n            self._search(path, None, (script,), exts=exts, kind=kind, opt=opt)\n\n    def freeze(self, path, script=None, opt=None):\n        \"\"\"\n        Freeze the input, automatically determining its type.  A .py script\n        will be compiled to a .mpy first then frozen, and a .mpy file will be\n        frozen directly.\n\n        `path` must be a directory, which is the base directory to _search for\n        files from.  When importing the resulting frozen modules, the name of\n        the module will start after `path`, ie `path` is excluded from the\n        module name.\n\n        If `path` is relative, it is resolved to the current manifest.py.\n        Use $(MPY_DIR), $(MPY_LIB_DIR), $(PORT_DIR), $(BOARD_DIR) if you need\n        to access specific paths.\n\n        If `script` is None all files in `path` will be frozen.\n\n        If `script` is an iterable then freeze() is called on all items of the\n        iterable (with the same `path` and `opt` passed through).\n\n        If `script` is a string then it specifies the file or directory to\n        freeze, and can include extra directories before the file or last\n        directory.  The file or directory will be _searched for in `path`.  If\n        `script` is a directory then all files in that directory will be frozen.\n\n        `opt` is the optimisation level to pass to mpy-cross when compiling .py\n        to .mpy.\n        \"\"\"\n        self._freeze_internal(\n            path,\n            script,\n            exts=(\n                \".py\",\n                \".mpy\",\n            ),\n            kind=KIND_FREEZE_AUTO,\n            opt=opt,\n        )\n\n    def freeze_as_str(self, path):\n        \"\"\"\n        Freeze the given `path` and all .py scripts within it as a string,\n        which will be compiled upon import.\n        \"\"\"\n        self._search(path, None, None, exts=(\".py\",), kind=KIND_FREEZE_AS_STR)\n\n    def freeze_as_mpy(self, path, script=None, opt=None):\n        \"\"\"\n        Freeze the input (see above) by first compiling the .py scripts to\n        .mpy files, then freezing the resulting .mpy files.\n        \"\"\"\n        self._freeze_internal(path, script, exts=(\".py\",), kind=KIND_FREEZE_AS_MPY, opt=opt)\n\n    def freeze_mpy(self, path, script=None, opt=None):\n        \"\"\"\n        Freeze the input (see above), which must be .mpy files that are\n        frozen directly.\n        \"\"\"\n        self._freeze_internal(path, script, exts=(\".mpy\",), kind=KIND_FREEZE_MPY, opt=opt)\n\n\n# Generate a temporary file with a line appended to the end that adds __version__.\n@contextlib.contextmanager\ndef tagged_py_file(path, metadata):\n    dest_fd, dest_path = tempfile.mkstemp(suffix=\".py\", text=True)\n    try:\n        with os.fdopen(dest_fd, \"w\") as dest:\n            with open(path, \"r\") as src:\n                contents = src.read()\n                dest.write(contents)\n\n                # Don't overwrite a version definition if the file already has one in it.\n                if metadata.version and \"__version__ =\" not in contents:\n                    dest.write(\"\\n\\n__version__ = {}\\n\".format(repr(metadata.version)))\n        yield dest_path\n    finally:\n        os.unlink(dest_path)\n\n\ndef main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"List the files referenced by a manifest.\")\n    cmd_parser.add_argument(\"--freeze\", action=\"store_true\", help=\"freeze mode\")\n    cmd_parser.add_argument(\"--compile\", action=\"store_true\", help=\"compile mode\")\n    cmd_parser.add_argument(\"--pyproject\", action=\"store_true\", help=\"pyproject mode\")\n    cmd_parser.add_argument(\n        \"--lib\",\n        default=os.path.join(os.path.dirname(__file__), \"../lib/micropython-lib\"),\n        help=\"path to micropython-lib repo\",\n    )\n    cmd_parser.add_argument(\n        \"--unix-ffi\", action=\"store_true\", help=\"prepend unix-ffi to the library path\"\n    )\n    cmd_parser.add_argument(\"--port\", default=None, help=\"path to port dir\")\n    cmd_parser.add_argument(\"--board\", default=None, help=\"path to board dir\")\n    cmd_parser.add_argument(\n        \"--top\",\n        default=os.path.join(os.path.dirname(__file__), \"..\"),\n        help=\"path to micropython repo\",\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"+\", help=\"input manifest.py\")\n    args = cmd_parser.parse_args()\n\n    path_vars = {\n        \"MPY_DIR\": os.path.abspath(args.top) if args.top else None,\n        \"BOARD_DIR\": os.path.abspath(args.board) if args.board else None,\n        \"PORT_DIR\": os.path.abspath(args.port) if args.port else None,\n        \"MPY_LIB_DIR\": os.path.abspath(args.lib) if args.lib else None,\n    }\n\n    mode = None\n    if args.freeze:\n        mode = MODE_FREEZE\n    elif args.compile:\n        mode = MODE_COMPILE\n    elif args.pyproject:\n        mode = MODE_PYPROJECT\n    else:\n        print(\"Error: No mode specified.\", file=sys.stderr)\n        exit(1)\n\n    m = ManifestFile(mode, path_vars)\n    if args.unix_ffi:\n        m.add_library(\"unix-ffi\", os.path.join(\"$(MPY_LIB_DIR)\", \"unix-ffi\"), prepend=True)\n    for manifest_file in args.files:\n        try:\n            m.execute(manifest_file)\n        except ManifestFileError as er:\n            print(er, file=sys.stderr)\n            exit(1)\n    print(m.metadata())\n    for f in m.files():\n        print(f)\n    if mode == MODE_PYPROJECT:\n        for r in m.pypi_dependencies():\n            print(\"pypi-require:\", r)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}