{
  "module_name": "pydfu.py",
  "hash_id": "99e8f61e022e5f149b19a5b86f92615f4cf616c56f9139ebb2eece06fe7ffdb8",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/pydfu.py",
  "human_readable_source": "#!/usr/bin/env python\n# This file is part of the OpenMV project.\n# Copyright (c) 2013/2014 Ibrahim Abdelkader <i.abdalkader@gmail.com>\n# This work is licensed under the MIT license, see the file LICENSE for\n# details.\n\n\"\"\"This module implements enough functionality to program the STM32F4xx over\nDFU, without requiring dfu-util.\n\nSee app note AN3156 for a description of the DFU protocol.\nSee document UM0391 for a description of the DFuse file.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport collections\nimport inspect\nimport re\nimport struct\nimport sys\nimport usb.core\nimport usb.util\nimport zlib\n\n# USB request __TIMEOUT\n__TIMEOUT = 4000\n\n# DFU commands\n__DFU_DETACH = 0\n__DFU_DNLOAD = 1\n__DFU_UPLOAD = 2\n__DFU_GETSTATUS = 3\n__DFU_CLRSTATUS = 4\n__DFU_GETSTATE = 5\n__DFU_ABORT = 6\n\n# DFU status\n__DFU_STATE_APP_IDLE = 0x00\n__DFU_STATE_APP_DETACH = 0x01\n__DFU_STATE_DFU_IDLE = 0x02\n__DFU_STATE_DFU_DOWNLOAD_SYNC = 0x03\n__DFU_STATE_DFU_DOWNLOAD_BUSY = 0x04\n__DFU_STATE_DFU_DOWNLOAD_IDLE = 0x05\n__DFU_STATE_DFU_MANIFEST_SYNC = 0x06\n__DFU_STATE_DFU_MANIFEST = 0x07\n__DFU_STATE_DFU_MANIFEST_WAIT_RESET = 0x08\n__DFU_STATE_DFU_UPLOAD_IDLE = 0x09\n__DFU_STATE_DFU_ERROR = 0x0A\n\n_DFU_DESCRIPTOR_TYPE = 0x21\n\n__DFU_STATUS_STR = {\n    __DFU_STATE_APP_IDLE: \"STATE_APP_IDLE\",\n    __DFU_STATE_APP_DETACH: \"STATE_APP_DETACH\",\n    __DFU_STATE_DFU_IDLE: \"STATE_DFU_IDLE\",\n    __DFU_STATE_DFU_DOWNLOAD_SYNC: \"STATE_DFU_DOWNLOAD_SYNC\",\n    __DFU_STATE_DFU_DOWNLOAD_BUSY: \"STATE_DFU_DOWNLOAD_BUSY\",\n    __DFU_STATE_DFU_DOWNLOAD_IDLE: \"STATE_DFU_DOWNLOAD_IDLE\",\n    __DFU_STATE_DFU_MANIFEST_SYNC: \"STATE_DFU_MANIFEST_SYNC\",\n    __DFU_STATE_DFU_MANIFEST: \"STATE_DFU_MANIFEST\",\n    __DFU_STATE_DFU_MANIFEST_WAIT_RESET: \"STATE_DFU_MANIFEST_WAIT_RESET\",\n    __DFU_STATE_DFU_UPLOAD_IDLE: \"STATE_DFU_UPLOAD_IDLE\",\n    __DFU_STATE_DFU_ERROR: \"STATE_DFU_ERROR\",\n}\n\n# USB device handle\n__dev = None\n\n# Configuration descriptor of the device\n__cfg_descr = None\n\n__verbose = None\n\n# USB DFU interface\n__DFU_INTERFACE = 0\n\n# Python 3 deprecated getargspec in favour of getfullargspec, but\n# Python 2 doesn't have the latter, so detect which one to use\ngetargspec = getattr(inspect, \"getfullargspec\", getattr(inspect, \"getargspec\", None))\n\nif \"length\" in getargspec(usb.util.get_string).args:\n    # PyUSB 1.0.0.b1 has the length argument\n    def get_string(dev, index):\n        return usb.util.get_string(dev, 255, index)\n\nelse:\n    # PyUSB 1.0.0.b2 dropped the length argument\n    def get_string(dev, index):\n        return usb.util.get_string(dev, index)\n\n\ndef find_dfu_cfg_descr(descr):\n    if len(descr) == 9 and descr[0] == 9 and descr[1] == _DFU_DESCRIPTOR_TYPE:\n        nt = collections.namedtuple(\n            \"CfgDescr\",\n            [\n                \"bLength\",\n                \"bDescriptorType\",\n                \"bmAttributes\",\n                \"wDetachTimeOut\",\n                \"wTransferSize\",\n                \"bcdDFUVersion\",\n            ],\n        )\n        return nt(*struct.unpack(\"<BBBHHH\", bytearray(descr)))\n    return None\n\n\ndef init(**kwargs):\n    \"\"\"Initializes the found DFU device so that we can program it.\"\"\"\n    global __dev, __cfg_descr\n    devices = get_dfu_devices(**kwargs)\n    if not devices:\n        raise ValueError(\"No DFU device found\")\n    if len(devices) > 1:\n        raise ValueError(\"Multiple DFU devices found\")\n    __dev = devices[0]\n    __dev.set_configuration()\n\n    # Claim DFU interface\n    usb.util.claim_interface(__dev, __DFU_INTERFACE)\n\n    # Find the DFU configuration descriptor, either in the device or interfaces\n    __cfg_descr = None\n    for cfg in __dev.configurations():\n        __cfg_descr = find_dfu_cfg_descr(cfg.extra_descriptors)\n        if __cfg_descr:\n            break\n        for itf in cfg.interfaces():\n            __cfg_descr = find_dfu_cfg_descr(itf.extra_descriptors)\n            if __cfg_descr:\n                break\n\n    # Get device into idle state\n    for attempt in range(4):\n        status = get_status()\n        if status == __DFU_STATE_DFU_IDLE:\n            break\n        elif status == __DFU_STATE_DFU_DOWNLOAD_IDLE or status == __DFU_STATE_DFU_UPLOAD_IDLE:\n            abort_request()\n        else:\n            clr_status()\n\n\ndef abort_request():\n    \"\"\"Sends an abort request.\"\"\"\n    __dev.ctrl_transfer(0x21, __DFU_ABORT, 0, __DFU_INTERFACE, None, __TIMEOUT)\n\n\ndef clr_status():\n    \"\"\"Clears any error status (perhaps left over from a previous session).\"\"\"\n    __dev.ctrl_transfer(0x21, __DFU_CLRSTATUS, 0, __DFU_INTERFACE, None, __TIMEOUT)\n\n\ndef get_status():\n    \"\"\"Get the status of the last operation.\"\"\"\n    stat = __dev.ctrl_transfer(0xA1, __DFU_GETSTATUS, 0, __DFU_INTERFACE, 6, 20000)\n\n    # firmware can provide an optional string for any error\n    if stat[5]:\n        message = get_string(__dev, stat[5])\n        if message:\n            print(message)\n\n    return stat[4]\n\n\ndef check_status(stage, expected):\n    status = get_status()\n    if status != expected:\n        raise SystemExit(\"DFU: %s failed (%s)\" % (stage, __DFU_STATUS_STR.get(status, status)))\n\n\ndef mass_erase():\n    \"\"\"Performs a MASS erase (i.e. erases the entire device).\"\"\"\n    # Send DNLOAD with first byte=0x41\n    __dev.ctrl_transfer(0x21, __DFU_DNLOAD, 0, __DFU_INTERFACE, \"\\x41\", __TIMEOUT)\n\n    # Execute last command\n    check_status(\"erase\", __DFU_STATE_DFU_DOWNLOAD_BUSY)\n\n    # Check command state\n    check_status(\"erase\", __DFU_STATE_DFU_DOWNLOAD_IDLE)\n\n\ndef page_erase(addr):\n    \"\"\"Erases a single page.\"\"\"\n    if __verbose:\n        print(\"Erasing page: 0x%x...\" % (addr))\n\n    # Send DNLOAD with first byte=0x41 and page address\n    buf = struct.pack(\"<BI\", 0x41, addr)\n    __dev.ctrl_transfer(0x21, __DFU_DNLOAD, 0, __DFU_INTERFACE, buf, __TIMEOUT)\n\n    # Execute last command\n    check_status(\"erase\", __DFU_STATE_DFU_DOWNLOAD_BUSY)\n\n    # Check command state\n    check_status(\"erase\", __DFU_STATE_DFU_DOWNLOAD_IDLE)\n\n\ndef set_address(addr):\n    \"\"\"Sets the address for the next operation.\"\"\"\n    # Send DNLOAD with first byte=0x21 and page address\n    buf = struct.pack(\"<BI\", 0x21, addr)\n    __dev.ctrl_transfer(0x21, __DFU_DNLOAD, 0, __DFU_INTERFACE, buf, __TIMEOUT)\n\n    # Execute last command\n    check_status(\"set address\", __DFU_STATE_DFU_DOWNLOAD_BUSY)\n\n    # Check command state\n    check_status(\"set address\", __DFU_STATE_DFU_DOWNLOAD_IDLE)\n\n\ndef write_memory(addr, buf, progress=None, progress_addr=0, progress_size=0):\n    \"\"\"Writes a buffer into memory. This routine assumes that memory has\n    already been erased.\n    \"\"\"\n\n    xfer_count = 0\n    xfer_bytes = 0\n    xfer_total = len(buf)\n    xfer_base = addr\n\n    while xfer_bytes < xfer_total:\n        if __verbose and xfer_count % 512 == 0:\n            print(\n                \"Addr 0x%x %dKBs/%dKBs...\"\n                % (xfer_base + xfer_bytes, xfer_bytes // 1024, xfer_total // 1024)\n            )\n        if progress and xfer_count % 2 == 0:\n            progress(progress_addr, xfer_base + xfer_bytes - progress_addr, progress_size)\n\n        # Set mem write address\n        set_address(xfer_base + xfer_bytes)\n\n        # Send DNLOAD with fw data\n        chunk = min(__cfg_descr.wTransferSize, xfer_total - xfer_bytes)\n        __dev.ctrl_transfer(\n            0x21, __DFU_DNLOAD, 2, __DFU_INTERFACE, buf[xfer_bytes : xfer_bytes + chunk], __TIMEOUT\n        )\n\n        # Execute last command\n        check_status(\"write memory\", __DFU_STATE_DFU_DOWNLOAD_BUSY)\n\n        # Check command state\n        check_status(\"write memory\", __DFU_STATE_DFU_DOWNLOAD_IDLE)\n\n        xfer_count += 1\n        xfer_bytes += chunk\n\n\ndef write_page(buf, xfer_offset):\n    \"\"\"Writes a single page. This routine assumes that memory has already\n    been erased.\n    \"\"\"\n\n    xfer_base = 0x08000000\n\n    # Set mem write address\n    set_address(xfer_base + xfer_offset)\n\n    # Send DNLOAD with fw data\n    __dev.ctrl_transfer(0x21, __DFU_DNLOAD, 2, __DFU_INTERFACE, buf, __TIMEOUT)\n\n    # Execute last command\n    check_status(\"write memory\", __DFU_STATE_DFU_DOWNLOAD_BUSY)\n\n    # Check command state\n    check_status(\"write memory\", __DFU_STATE_DFU_DOWNLOAD_IDLE)\n\n    if __verbose:\n        print(\"Write: 0x%x \" % (xfer_base + xfer_offset))\n\n\ndef exit_dfu():\n    \"\"\"Exit DFU mode, and start running the program.\"\"\"\n    # Set jump address\n    set_address(0x08000000)\n\n    # Send DNLOAD with 0 length to exit DFU\n    __dev.ctrl_transfer(0x21, __DFU_DNLOAD, 0, __DFU_INTERFACE, None, __TIMEOUT)\n\n    try:\n        # Execute last command\n        if get_status() != __DFU_STATE_DFU_MANIFEST:\n            print(\"Failed to reset device\")\n\n        # Release device\n        usb.util.dispose_resources(__dev)\n    except:\n        pass\n\n\ndef named(values, names):\n    \"\"\"Creates a dict with `names` as fields, and `values` as values.\"\"\"\n    return dict(zip(names.split(), values))\n\n\ndef consume(fmt, data, names):\n    \"\"\"Parses the struct defined by `fmt` from `data`, stores the parsed fields\n    into a named tuple using `names`. Returns the named tuple, and the data\n    with the struct stripped off.\"\"\"\n\n    size = struct.calcsize(fmt)\n    return named(struct.unpack(fmt, data[:size]), names), data[size:]\n\n\ndef cstring(string):\n    \"\"\"Extracts a null-terminated string from a byte array.\"\"\"\n    return string.decode(\"utf-8\").split(\"\\0\", 1)[0]\n\n\ndef compute_crc(data):\n    \"\"\"Computes the CRC32 value for the data passed in.\"\"\"\n    return 0xFFFFFFFF & -zlib.crc32(data) - 1\n\n\ndef read_dfu_file(filename):\n    \"\"\"Reads a DFU file, and parses the individual elements from the file.\n    Returns an array of elements. Each element is a dictionary with the\n    following keys:\n        num     - The element index.\n        address - The address that the element data should be written to.\n        size    - The size of the element data.\n        data    - The element data.\n    If an error occurs while parsing the file, then None is returned.\n    \"\"\"\n\n    print(\"File: {}\".format(filename))\n    with open(filename, \"rb\") as fin:\n        data = fin.read()\n    crc = compute_crc(data[:-4])\n    elements = []\n\n    # Decode the DFU Prefix\n    #\n    # <5sBIB\n    #   <   little endian           Endianness\n    #   5s  char[5]     signature   \"DfuSe\"\n    #   B   uint8_t     version     1\n    #   I   uint32_t    size        Size of the DFU file (without suffix)\n    #   B   uint8_t     targets     Number of targets\n    dfu_prefix, data = consume(\"<5sBIB\", data, \"signature version size targets\")\n    print(\n        \"    %(signature)s v%(version)d, image size: %(size)d, \"\n        \"targets: %(targets)d\" % dfu_prefix\n    )\n    for target_idx in range(dfu_prefix[\"targets\"]):\n        # Decode the Image Prefix\n        #\n        # <6sBI255s2I\n        #   <       little endian           Endianness\n        #   6s      char[6]     signature   \"Target\"\n        #   B       uint8_t     altsetting\n        #   I       uint32_t    named       Bool indicating if a name was used\n        #   255s    char[255]   name        Name of the target\n        #   I       uint32_t    size        Size of image (without prefix)\n        #   I       uint32_t    elements    Number of elements in the image\n        img_prefix, data = consume(\n            \"<6sBI255s2I\", data, \"signature altsetting named name \" \"size elements\"\n        )\n        img_prefix[\"num\"] = target_idx\n        if img_prefix[\"named\"]:\n            img_prefix[\"name\"] = cstring(img_prefix[\"name\"])\n        else:\n            img_prefix[\"name\"] = \"\"\n        print(\n            \"    %(signature)s %(num)d, alt setting: %(altsetting)s, \"\n            'name: \"%(name)s\", size: %(size)d, elements: %(elements)d' % img_prefix\n        )\n\n        target_size = img_prefix[\"size\"]\n        target_data = data[:target_size]\n        data = data[target_size:]\n        for elem_idx in range(img_prefix[\"elements\"]):\n            # Decode target prefix\n            #\n            # <2I\n            #   <   little endian           Endianness\n            #   I   uint32_t    element     Address\n            #   I   uint32_t    element     Size\n            elem_prefix, target_data = consume(\"<2I\", target_data, \"addr size\")\n            elem_prefix[\"num\"] = elem_idx\n            print(\"      %(num)d, address: 0x%(addr)08x, size: %(size)d\" % elem_prefix)\n            elem_size = elem_prefix[\"size\"]\n            elem_data = target_data[:elem_size]\n            target_data = target_data[elem_size:]\n            elem_prefix[\"data\"] = elem_data\n            elements.append(elem_prefix)\n\n        if len(target_data):\n            print(\"target %d PARSE ERROR\" % target_idx)\n\n    # Decode DFU Suffix\n    #\n    # <4H3sBI\n    #   <   little endian           Endianness\n    #   H   uint16_t    device      Firmware version\n    #   H   uint16_t    product\n    #   H   uint16_t    vendor\n    #   H   uint16_t    dfu         0x11a   (DFU file format version)\n    #   3s  char[3]     ufd         \"UFD\"\n    #   B   uint8_t     len         16\n    #   I   uint32_t    crc32       Checksum\n    dfu_suffix = named(\n        struct.unpack(\"<4H3sBI\", data[:16]), \"device product vendor dfu ufd len crc\"\n    )\n    print(\n        \"    usb: %(vendor)04x:%(product)04x, device: 0x%(device)04x, \"\n        \"dfu: 0x%(dfu)04x, %(ufd)s, %(len)d, 0x%(crc)08x\" % dfu_suffix\n    )\n    if crc != dfu_suffix[\"crc\"]:\n        print(\"CRC ERROR: computed crc32 is 0x%08x\" % crc)\n        return\n    data = data[16:]\n    if data:\n        print(\"PARSE ERROR\")\n        return\n\n    return elements\n\n\nclass FilterDFU(object):\n    \"\"\"Class for filtering USB devices to identify devices which are in DFU\n    mode.\n    \"\"\"\n\n    def __call__(self, device):\n        for cfg in device:\n            for intf in cfg:\n                return intf.bInterfaceClass == 0xFE and intf.bInterfaceSubClass == 1\n\n\ndef get_dfu_devices(*args, **kwargs):\n    \"\"\"Returns a list of USB devices which are currently in DFU mode.\n    Additional filters (like idProduct and idVendor) can be passed in\n    to refine the search.\n    \"\"\"\n\n    # Convert to list for compatibility with newer PyUSB\n    return list(usb.core.find(*args, find_all=True, custom_match=FilterDFU(), **kwargs))\n\n\ndef get_memory_layout(device):\n    \"\"\"Returns an array which identifies the memory layout. Each entry\n    of the array will contain a dictionary with the following keys:\n        addr        - Address of this memory segment.\n        last_addr   - Last address contained within the memory segment.\n        size        - Size of the segment, in bytes.\n        num_pages   - Number of pages in the segment.\n        page_size   - Size of each page, in bytes.\n    \"\"\"\n\n    cfg = device[0]\n    intf = cfg[(0, 0)]\n    mem_layout_str = get_string(device, intf.iInterface)\n    mem_layout = mem_layout_str.split(\"/\")\n    result = []\n    for mem_layout_index in range(1, len(mem_layout), 2):\n        addr = int(mem_layout[mem_layout_index], 0)\n        segments = mem_layout[mem_layout_index + 1].split(\",\")\n        seg_re = re.compile(r\"(\\d+)\\*(\\d+)(.)(.)\")\n        for segment in segments:\n            seg_match = seg_re.match(segment)\n            num_pages = int(seg_match.groups()[0], 10)\n            page_size = int(seg_match.groups()[1], 10)\n            multiplier = seg_match.groups()[2]\n            if multiplier == \"K\":\n                page_size *= 1024\n            if multiplier == \"M\":\n                page_size *= 1024 * 1024\n            size = num_pages * page_size\n            last_addr = addr + size - 1\n            result.append(\n                named(\n                    (addr, last_addr, size, num_pages, page_size),\n                    \"addr last_addr size num_pages page_size\",\n                )\n            )\n            addr += size\n    return result\n\n\ndef list_dfu_devices(*args, **kwargs):\n    \"\"\"Prints a list of devices detected in DFU mode.\"\"\"\n    devices = get_dfu_devices(*args, **kwargs)\n    if not devices:\n        raise SystemExit(\"No DFU capable devices found\")\n    for device in devices:\n        print(\n            \"Bus {} Device {:03d}: ID {:04x}:{:04x}\".format(\n                device.bus, device.address, device.idVendor, device.idProduct\n            )\n        )\n        layout = get_memory_layout(device)\n        print(\"Memory Layout\")\n        for entry in layout:\n            print(\n                \"    0x{:x} {:2d} pages of {:3d}K bytes\".format(\n                    entry[\"addr\"], entry[\"num_pages\"], entry[\"page_size\"] // 1024\n                )\n            )\n\n\ndef write_elements(elements, mass_erase_used, progress=None):\n    \"\"\"Writes the indicated elements into the target memory,\n    erasing as needed.\n    \"\"\"\n\n    mem_layout = get_memory_layout(__dev)\n    for elem in elements:\n        addr = elem[\"addr\"]\n        size = elem[\"size\"]\n        data = elem[\"data\"]\n        elem_size = size\n        elem_addr = addr\n        if progress and elem_size:\n            progress(elem_addr, 0, elem_size)\n        while size > 0:\n            write_size = size\n            if not mass_erase_used:\n                for segment in mem_layout:\n                    if addr >= segment[\"addr\"] and addr <= segment[\"last_addr\"]:\n                        # We found the page containing the address we want to\n                        # write, erase it\n                        page_size = segment[\"page_size\"]\n                        page_addr = addr & ~(page_size - 1)\n                        if addr + write_size > page_addr + page_size:\n                            write_size = page_addr + page_size - addr\n                        page_erase(page_addr)\n                        break\n            write_memory(addr, data[:write_size], progress, elem_addr, elem_size)\n            data = data[write_size:]\n            addr += write_size\n            size -= write_size\n            if progress:\n                progress(elem_addr, addr - elem_addr, elem_size)\n\n\ndef cli_progress(addr, offset, size):\n    \"\"\"Prints a progress report suitable for use on the command line.\"\"\"\n    width = 25\n    done = offset * width // size\n    print(\n        \"\\r0x{:08x} {:7d} [{}{}] {:3d}% \".format(\n            addr, size, \"=\" * done, \" \" * (width - done), offset * 100 // size\n        ),\n        end=\"\",\n    )\n    try:\n        sys.stdout.flush()\n    except OSError:\n        pass  # Ignore Windows CLI \"WinError 87\" on Python 3.6\n    if offset == size:\n        print(\"\")\n\n\ndef main():\n    \"\"\"Test program for verifying this files functionality.\"\"\"\n    global __verbose\n    # Parse CMD args\n    parser = argparse.ArgumentParser(description=\"DFU Python Util\")\n    parser.add_argument(\n        \"-l\", \"--list\", help=\"list available DFU devices\", action=\"store_true\", default=False\n    )\n    parser.add_argument(\"--vid\", help=\"USB Vendor ID\", type=lambda x: int(x, 0), default=None)\n    parser.add_argument(\"--pid\", help=\"USB Product ID\", type=lambda x: int(x, 0), default=None)\n    parser.add_argument(\n        \"-m\", \"--mass-erase\", help=\"mass erase device\", action=\"store_true\", default=False\n    )\n    parser.add_argument(\n        \"-u\", \"--upload\", help=\"read file from DFU device\", dest=\"path\", default=False\n    )\n    parser.add_argument(\"-x\", \"--exit\", help=\"Exit DFU\", action=\"store_true\", default=False)\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\", default=False\n    )\n    args = parser.parse_args()\n\n    __verbose = args.verbose\n\n    kwargs = {}\n    if args.vid:\n        kwargs[\"idVendor\"] = args.vid\n\n    if args.pid:\n        kwargs[\"idProduct\"] = args.pid\n\n    if args.list:\n        list_dfu_devices(**kwargs)\n        return\n\n    init(**kwargs)\n\n    command_run = False\n    if args.mass_erase:\n        print(\"Mass erase...\")\n        mass_erase()\n        command_run = True\n\n    if args.path:\n        elements = read_dfu_file(args.path)\n        if not elements:\n            print(\"No data in dfu file\")\n            return\n        print(\"Writing memory...\")\n        write_elements(elements, args.mass_erase, progress=cli_progress)\n\n        print(\"Exiting DFU...\")\n        exit_dfu()\n        command_run = True\n\n    if args.exit:\n        print(\"Exiting DFU...\")\n        exit_dfu()\n        command_run = True\n\n    if command_run:\n        print(\"Finished\")\n    else:\n        print(\"No command specified\")\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}