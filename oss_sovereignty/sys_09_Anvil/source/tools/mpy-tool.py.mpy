{
  "module_name": "mpy-tool.py",
  "hash_id": "48a5231fe96ee4dfcf4e66dc4e8f5e9708e41b859373d7c65b9b26e1ab05badc",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpy-tool.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2016-2019 Damien P. George\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n# Python 2/3 compatibility code\nfrom __future__ import print_function\nimport platform\n\nif platform.python_version_tuple()[0] == \"2\":\n    from binascii import hexlify as hexlify_py2\n\n    str_cons = lambda val, enc=None: str(val)\n    bytes_cons = lambda val, enc=None: bytearray(val)\n    is_str_type = lambda o: isinstance(o, str)\n    is_bytes_type = lambda o: type(o) is bytearray\n    is_int_type = lambda o: isinstance(o, int) or isinstance(o, long)  # noqa: F821\n\n    def hexlify_to_str(b):\n        x = hexlify_py2(b)\n        return \":\".join(x[i : i + 2] for i in range(0, len(x), 2))\n\nelse:\n    from binascii import hexlify\n\n    str_cons = str\n    bytes_cons = bytes\n    is_str_type = lambda o: isinstance(o, str)\n    is_bytes_type = lambda o: isinstance(o, bytes)\n    is_int_type = lambda o: isinstance(o, int)\n\n    def hexlify_to_str(b):\n        return str(hexlify(b, \":\"), \"ascii\")\n\n\n# end compatibility code\n\nimport sys\nimport struct\n\nsys.path.append(sys.path[0] + \"/../py\")\nimport makeqstrdata as qstrutil\n\n# Threshold of str length below which it will be turned into a qstr when freezing.\n# This helps to reduce frozen code size because qstrs are more efficient to encode\n# as objects than full mp_obj_str_t instances.\nPERSISTENT_STR_INTERN_THRESHOLD = 25\n\n\nclass MPYReadError(Exception):\n    def __init__(self, filename, msg):\n        self.filename = filename\n        self.msg = msg\n\n    def __str__(self):\n        return \"%s: %s\" % (self.filename, self.msg)\n\n\nclass FreezeError(Exception):\n    def __init__(self, rawcode, msg):\n        self.rawcode = rawcode\n        self.msg = msg\n\n    def __str__(self):\n        return \"error while freezing %s: %s\" % (self.rawcode.source_file, self.msg)\n\n\nclass Config:\n    MPY_VERSION = 6\n    MPY_SUB_VERSION = 3\n    MICROPY_LONGINT_IMPL_NONE = 0\n    MICROPY_LONGINT_IMPL_LONGLONG = 1\n    MICROPY_LONGINT_IMPL_MPZ = 2\n\n\nconfig = Config()\n\n\nMP_CODE_BYTECODE = 2\nMP_CODE_NATIVE_PY = 3\nMP_CODE_NATIVE_VIPER = 4\nMP_CODE_NATIVE_ASM = 5\n\nMP_NATIVE_ARCH_NONE = 0\nMP_NATIVE_ARCH_X86 = 1\nMP_NATIVE_ARCH_X64 = 2\nMP_NATIVE_ARCH_ARMV6 = 3\nMP_NATIVE_ARCH_ARMV6M = 4\nMP_NATIVE_ARCH_ARMV7M = 5\nMP_NATIVE_ARCH_ARMV7EM = 6\nMP_NATIVE_ARCH_ARMV7EMSP = 7\nMP_NATIVE_ARCH_ARMV7EMDP = 8\nMP_NATIVE_ARCH_XTENSA = 9\nMP_NATIVE_ARCH_XTENSAWIN = 10\n\nMP_PERSISTENT_OBJ_FUN_TABLE = 0\nMP_PERSISTENT_OBJ_NONE = 1\nMP_PERSISTENT_OBJ_FALSE = 2\nMP_PERSISTENT_OBJ_TRUE = 3\nMP_PERSISTENT_OBJ_ELLIPSIS = 4\nMP_PERSISTENT_OBJ_STR = 5\nMP_PERSISTENT_OBJ_BYTES = 6\nMP_PERSISTENT_OBJ_INT = 7\nMP_PERSISTENT_OBJ_FLOAT = 8\nMP_PERSISTENT_OBJ_COMPLEX = 9\nMP_PERSISTENT_OBJ_TUPLE = 10\n\nMP_SCOPE_FLAG_GENERATOR = 0x01\nMP_SCOPE_FLAG_VIPERRELOC = 0x10\nMP_SCOPE_FLAG_VIPERRODATA = 0x20\nMP_SCOPE_FLAG_VIPERBSS = 0x40\n\nMP_BC_MASK_EXTRA_BYTE = 0x9E\n\nMP_BC_FORMAT_BYTE = 0\nMP_BC_FORMAT_QSTR = 1\nMP_BC_FORMAT_VAR_UINT = 2\nMP_BC_FORMAT_OFFSET = 3\n\nmp_unary_op_method_name = (\n    \"__pos__\",\n    \"__neg__\",\n    \"__invert__\",\n    \"<not>\",\n)\n\nmp_binary_op_method_name = (\n    \"__lt__\",\n    \"__gt__\",\n    \"__eq__\",\n    \"__le__\",\n    \"__ge__\",\n    \"__ne__\",\n    \"<in>\",\n    \"<is>\",\n    \"<exception match>\",\n    \"__ior__\",\n    \"__ixor__\",\n    \"__iand__\",\n    \"__ilshift__\",\n    \"__irshift__\",\n    \"__iadd__\",\n    \"__isub__\",\n    \"__imul__\",\n    \"__imatmul__\",\n    \"__ifloordiv__\",\n    \"__itruediv__\",\n    \"__imod__\",\n    \"__ipow__\",\n    \"__or__\",\n    \"__xor__\",\n    \"__and__\",\n    \"__lshift__\",\n    \"__rshift__\",\n    \"__add__\",\n    \"__sub__\",\n    \"__mul__\",\n    \"__matmul__\",\n    \"__floordiv__\",\n    \"__truediv__\",\n    \"__mod__\",\n    \"__pow__\",\n)\n\n\nclass Opcode:\n    # fmt: off\n    # Load, Store, Delete, Import, Make, Build, Unpack, Call, Jump, Exception, For, sTack, Return, Yield, Op\n    MP_BC_BASE_RESERVED               = (0x00) # ----------------\n    MP_BC_BASE_QSTR_O                 = (0x10) # LLLLLLSSSDDII---\n    MP_BC_BASE_VINT_E                 = (0x20) # MMLLLLSSDDBBBBBB\n    MP_BC_BASE_VINT_O                 = (0x30) # UUMMCCCC--------\n    MP_BC_BASE_JUMP_E                 = (0x40) # J-JJJJJEEEEF----\n    MP_BC_BASE_BYTE_O                 = (0x50) # LLLLSSDTTTTTEEFF\n    MP_BC_BASE_BYTE_E                 = (0x60) # --BREEEYYI------\n    MP_BC_LOAD_CONST_SMALL_INT_MULTI  = (0x70) # LLLLLLLLLLLLLLLL\n    #                                 = (0x80) # LLLLLLLLLLLLLLLL\n    #                                 = (0x90) # LLLLLLLLLLLLLLLL\n    #                                 = (0xa0) # LLLLLLLLLLLLLLLL\n    MP_BC_LOAD_FAST_MULTI             = (0xb0) # LLLLLLLLLLLLLLLL\n    MP_BC_STORE_FAST_MULTI            = (0xc0) # SSSSSSSSSSSSSSSS\n    MP_BC_UNARY_OP_MULTI              = (0xd0) # OOOOOOO\n    MP_BC_BINARY_OP_MULTI             = (0xd7) #        OOOOOOOOO\n    #                                 = (0xe0) # OOOOOOOOOOOOOOOO\n    #                                 = (0xf0) # OOOOOOOOOO------\n\n    MP_BC_LOAD_CONST_SMALL_INT_MULTI_NUM = 64\n    MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS = 16\n    MP_BC_LOAD_FAST_MULTI_NUM         = 16\n    MP_BC_STORE_FAST_MULTI_NUM        = 16\n    MP_BC_UNARY_OP_MULTI_NUM          = 4  # MP_UNARY_OP_NUM_BYTECODE\n    MP_BC_BINARY_OP_MULTI_NUM         = 35  # MP_BINARY_OP_NUM_BYTECODE\n\n    MP_BC_LOAD_CONST_FALSE            = (MP_BC_BASE_BYTE_O + 0x00)\n    MP_BC_LOAD_CONST_NONE             = (MP_BC_BASE_BYTE_O + 0x01)\n    MP_BC_LOAD_CONST_TRUE             = (MP_BC_BASE_BYTE_O + 0x02)\n    MP_BC_LOAD_CONST_SMALL_INT        = (MP_BC_BASE_VINT_E + 0x02) # signed var-int\n    MP_BC_LOAD_CONST_STRING           = (MP_BC_BASE_QSTR_O + 0x00) # qstr\n    MP_BC_LOAD_CONST_OBJ              = (MP_BC_BASE_VINT_E + 0x03) # ptr\n    MP_BC_LOAD_NULL                   = (MP_BC_BASE_BYTE_O + 0x03)\n\n    MP_BC_LOAD_FAST_N                 = (MP_BC_BASE_VINT_E + 0x04) # uint\n    MP_BC_LOAD_DEREF                  = (MP_BC_BASE_VINT_E + 0x05) # uint\n    MP_BC_LOAD_NAME                   = (MP_BC_BASE_QSTR_O + 0x01) # qstr\n    MP_BC_LOAD_GLOBAL                 = (MP_BC_BASE_QSTR_O + 0x02) # qstr\n    MP_BC_LOAD_ATTR                   = (MP_BC_BASE_QSTR_O + 0x03) # qstr\n    MP_BC_LOAD_METHOD                 = (MP_BC_BASE_QSTR_O + 0x04) # qstr\n    MP_BC_LOAD_SUPER_METHOD           = (MP_BC_BASE_QSTR_O + 0x05) # qstr\n    MP_BC_LOAD_BUILD_CLASS            = (MP_BC_BASE_BYTE_O + 0x04)\n    MP_BC_LOAD_SUBSCR                 = (MP_BC_BASE_BYTE_O + 0x05)\n\n    MP_BC_STORE_FAST_N                = (MP_BC_BASE_VINT_E + 0x06) # uint\n    MP_BC_STORE_DEREF                 = (MP_BC_BASE_VINT_E + 0x07) # uint\n    MP_BC_STORE_NAME                  = (MP_BC_BASE_QSTR_O + 0x06) # qstr\n    MP_BC_STORE_GLOBAL                = (MP_BC_BASE_QSTR_O + 0x07) # qstr\n    MP_BC_STORE_ATTR                  = (MP_BC_BASE_QSTR_O + 0x08) # qstr\n    MP_BC_STORE_SUBSCR                = (MP_BC_BASE_BYTE_O + 0x06)\n\n    MP_BC_DELETE_FAST                 = (MP_BC_BASE_VINT_E + 0x08) # uint\n    MP_BC_DELETE_DEREF                = (MP_BC_BASE_VINT_E + 0x09) # uint\n    MP_BC_DELETE_NAME                 = (MP_BC_BASE_QSTR_O + 0x09) # qstr\n    MP_BC_DELETE_GLOBAL               = (MP_BC_BASE_QSTR_O + 0x0a) # qstr\n\n    MP_BC_DUP_TOP                     = (MP_BC_BASE_BYTE_O + 0x07)\n    MP_BC_DUP_TOP_TWO                 = (MP_BC_BASE_BYTE_O + 0x08)\n    MP_BC_POP_TOP                     = (MP_BC_BASE_BYTE_O + 0x09)\n    MP_BC_ROT_TWO                     = (MP_BC_BASE_BYTE_O + 0x0a)\n    MP_BC_ROT_THREE                   = (MP_BC_BASE_BYTE_O + 0x0b)\n\n    MP_BC_UNWIND_JUMP                 = (MP_BC_BASE_JUMP_E + 0x00) # signed relative bytecode offset; then a byte\n    MP_BC_JUMP                        = (MP_BC_BASE_JUMP_E + 0x02) # signed relative bytecode offset\n    MP_BC_POP_JUMP_IF_TRUE            = (MP_BC_BASE_JUMP_E + 0x03) # signed relative bytecode offset\n    MP_BC_POP_JUMP_IF_FALSE           = (MP_BC_BASE_JUMP_E + 0x04) # signed relative bytecode offset\n    MP_BC_JUMP_IF_TRUE_OR_POP         = (MP_BC_BASE_JUMP_E + 0x05) # unsigned relative bytecode offset\n    MP_BC_JUMP_IF_FALSE_OR_POP        = (MP_BC_BASE_JUMP_E + 0x06) # unsigned relative bytecode offset\n    MP_BC_SETUP_WITH                  = (MP_BC_BASE_JUMP_E + 0x07) # unsigned relative bytecode offset\n    MP_BC_SETUP_EXCEPT                = (MP_BC_BASE_JUMP_E + 0x08) # unsigned relative bytecode offset\n    MP_BC_SETUP_FINALLY               = (MP_BC_BASE_JUMP_E + 0x09) # unsigned relative bytecode offset\n    MP_BC_POP_EXCEPT_JUMP             = (MP_BC_BASE_JUMP_E + 0x0a) # unsigned relative bytecode offset\n    MP_BC_FOR_ITER                    = (MP_BC_BASE_JUMP_E + 0x0b) # unsigned relative bytecode offset\n    MP_BC_WITH_CLEANUP                = (MP_BC_BASE_BYTE_O + 0x0c)\n    MP_BC_END_FINALLY                 = (MP_BC_BASE_BYTE_O + 0x0d)\n    MP_BC_GET_ITER                    = (MP_BC_BASE_BYTE_O + 0x0e)\n    MP_BC_GET_ITER_STACK              = (MP_BC_BASE_BYTE_O + 0x0f)\n\n    MP_BC_BUILD_TUPLE                 = (MP_BC_BASE_VINT_E + 0x0a) # uint\n    MP_BC_BUILD_LIST                  = (MP_BC_BASE_VINT_E + 0x0b) # uint\n    MP_BC_BUILD_MAP                   = (MP_BC_BASE_VINT_E + 0x0c) # uint\n    MP_BC_STORE_MAP                   = (MP_BC_BASE_BYTE_E + 0x02)\n    MP_BC_BUILD_SET                   = (MP_BC_BASE_VINT_E + 0x0d) # uint\n    MP_BC_BUILD_SLICE                 = (MP_BC_BASE_VINT_E + 0x0e) # uint\n    MP_BC_STORE_COMP                  = (MP_BC_BASE_VINT_E + 0x0f) # uint\n    MP_BC_UNPACK_SEQUENCE             = (MP_BC_BASE_VINT_O + 0x00) # uint\n    MP_BC_UNPACK_EX                   = (MP_BC_BASE_VINT_O + 0x01) # uint\n\n    MP_BC_RETURN_VALUE                = (MP_BC_BASE_BYTE_E + 0x03)\n    MP_BC_RAISE_LAST                  = (MP_BC_BASE_BYTE_E + 0x04)\n    MP_BC_RAISE_OBJ                   = (MP_BC_BASE_BYTE_E + 0x05)\n    MP_BC_RAISE_FROM                  = (MP_BC_BASE_BYTE_E + 0x06)\n    MP_BC_YIELD_VALUE                 = (MP_BC_BASE_BYTE_E + 0x07)\n    MP_BC_YIELD_FROM                  = (MP_BC_BASE_BYTE_E + 0x08)\n\n    MP_BC_MAKE_FUNCTION               = (MP_BC_BASE_VINT_O + 0x02) # uint\n    MP_BC_MAKE_FUNCTION_DEFARGS       = (MP_BC_BASE_VINT_O + 0x03) # uint\n    MP_BC_MAKE_CLOSURE                = (MP_BC_BASE_VINT_E + 0x00) # uint; extra byte\n    MP_BC_MAKE_CLOSURE_DEFARGS        = (MP_BC_BASE_VINT_E + 0x01) # uint; extra byte\n    MP_BC_CALL_FUNCTION               = (MP_BC_BASE_VINT_O + 0x04) # uint\n    MP_BC_CALL_FUNCTION_VAR_KW        = (MP_BC_BASE_VINT_O + 0x05) # uint\n    MP_BC_CALL_METHOD                 = (MP_BC_BASE_VINT_O + 0x06) # uint\n    MP_BC_CALL_METHOD_VAR_KW          = (MP_BC_BASE_VINT_O + 0x07) # uint\n\n    MP_BC_IMPORT_NAME                 = (MP_BC_BASE_QSTR_O + 0x0b) # qstr\n    MP_BC_IMPORT_FROM                 = (MP_BC_BASE_QSTR_O + 0x0c) # qstr\n    MP_BC_IMPORT_STAR                 = (MP_BC_BASE_BYTE_E + 0x09)\n    # fmt: on\n\n    # Create sets of related opcodes.\n    ALL_OFFSET_SIGNED = (\n        MP_BC_UNWIND_JUMP,\n        MP_BC_JUMP,\n        MP_BC_POP_JUMP_IF_TRUE,\n        MP_BC_POP_JUMP_IF_FALSE,\n    )\n\n    # Create a dict mapping opcode value to opcode name.\n    mapping = [\"unknown\" for _ in range(256)]\n    for op_name in list(locals()):\n        if op_name.startswith(\"MP_BC_\"):\n            mapping[locals()[op_name]] = op_name[len(\"MP_BC_\") :]\n    for i in range(MP_BC_LOAD_CONST_SMALL_INT_MULTI_NUM):\n        name = \"LOAD_CONST_SMALL_INT %d\" % (i - MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS)\n        mapping[MP_BC_LOAD_CONST_SMALL_INT_MULTI + i] = name\n    for i in range(MP_BC_LOAD_FAST_MULTI_NUM):\n        mapping[MP_BC_LOAD_FAST_MULTI + i] = \"LOAD_FAST %d\" % i\n    for i in range(MP_BC_STORE_FAST_MULTI_NUM):\n        mapping[MP_BC_STORE_FAST_MULTI + i] = \"STORE_FAST %d\" % i\n    for i in range(MP_BC_UNARY_OP_MULTI_NUM):\n        mapping[MP_BC_UNARY_OP_MULTI + i] = \"UNARY_OP %d %s\" % (i, mp_unary_op_method_name[i])\n    for i in range(MP_BC_BINARY_OP_MULTI_NUM):\n        mapping[MP_BC_BINARY_OP_MULTI + i] = \"BINARY_OP %d %s\" % (i, mp_binary_op_method_name[i])\n\n    def __init__(self, offset, fmt, opcode_byte, arg, extra_arg):\n        self.offset = offset\n        self.fmt = fmt\n        self.opcode_byte = opcode_byte\n        self.arg = arg\n        self.extra_arg = extra_arg\n\n\n# This definition of a small int covers all possible targets, in the sense that every\n# target can encode as a small int, an integer that passes this test.  The minimum is set\n# by MICROPY_OBJ_REPR_B on a 16-bit machine, where there are 14 bits for the small int.\ndef mp_small_int_fits(i):\n    return -0x2000 <= i <= 0x1FFF\n\n\ndef mp_encode_uint(val, signed=False):\n    encoded = bytearray([val & 0x7F])\n    val >>= 7\n    while val != 0 and val != -1:\n        encoded.insert(0, 0x80 | (val & 0x7F))\n        val >>= 7\n    if signed:\n        if val == -1 and encoded[0] & 0x40 == 0:\n            encoded.insert(0, 0xFF)\n        elif val == 0 and encoded[0] & 0x40 != 0:\n            encoded.insert(0, 0x80)\n    return encoded\n\n\ndef mp_opcode_decode(bytecode, ip):\n    opcode = bytecode[ip]\n    ip_start = ip\n    f = (0x000003A4 >> (2 * ((opcode) >> 4))) & 3\n    ip += 1\n    arg = None\n    extra_arg = None\n    if f in (MP_BC_FORMAT_QSTR, MP_BC_FORMAT_VAR_UINT):\n        arg = bytecode[ip] & 0x7F\n        if opcode == Opcode.MP_BC_LOAD_CONST_SMALL_INT and arg & 0x40 != 0:\n            arg |= -1 << 7\n        while bytecode[ip] & 0x80 != 0:\n            ip += 1\n            arg = arg << 7 | bytecode[ip] & 0x7F\n        ip += 1\n    elif f == MP_BC_FORMAT_OFFSET:\n        if bytecode[ip] & 0x80 == 0:\n            arg = bytecode[ip]\n            ip += 1\n            if opcode in Opcode.ALL_OFFSET_SIGNED:\n                arg -= 0x40\n        else:\n            arg = bytecode[ip] & 0x7F | bytecode[ip + 1] << 7\n            ip += 2\n            if opcode in Opcode.ALL_OFFSET_SIGNED:\n                arg -= 0x4000\n    if opcode & MP_BC_MASK_EXTRA_BYTE == 0:\n        extra_arg = bytecode[ip]\n        ip += 1\n    return f, ip - ip_start, arg, extra_arg\n\n\ndef mp_opcode_encode(opcode):\n    overflow = False\n    encoded = bytearray([opcode.opcode_byte])\n    if opcode.fmt in (MP_BC_FORMAT_QSTR, MP_BC_FORMAT_VAR_UINT):\n        signed = opcode.opcode_byte == Opcode.MP_BC_LOAD_CONST_SMALL_INT\n        encoded.extend(mp_encode_uint(opcode.arg, signed))\n    elif opcode.fmt == MP_BC_FORMAT_OFFSET:\n        is_signed = opcode.opcode_byte in Opcode.ALL_OFFSET_SIGNED\n\n        # The -2 accounts for this jump opcode taking 2 bytes (at least).\n        bytecode_offset = opcode.target.offset - opcode.offset - 2\n\n        # Check if the bytecode_offset is small enough to use a 1-byte encoding.\n        if (is_signed and -64 <= bytecode_offset <= 63) or (\n            not is_signed and bytecode_offset <= 127\n        ):\n            # Use a 1-byte jump offset.\n            if is_signed:\n                bytecode_offset += 0x40\n            overflow = not (0 <= bytecode_offset <= 0x7F)\n            encoded.append(bytecode_offset & 0x7F)\n        else:\n            bytecode_offset -= 1\n            if is_signed:\n                bytecode_offset += 0x4000\n            overflow = not (0 <= bytecode_offset <= 0x7FFF)\n            encoded.append(0x80 | (bytecode_offset & 0x7F))\n            encoded.append((bytecode_offset >> 7) & 0xFF)\n    if opcode.extra_arg is not None:\n        encoded.append(opcode.extra_arg)\n    return overflow, encoded\n\n\ndef read_prelude_sig(read_byte):\n    z = read_byte()\n    # xSSSSEAA\n    S = (z >> 3) & 0xF\n    E = (z >> 2) & 0x1\n    F = 0\n    A = z & 0x3\n    K = 0\n    D = 0\n    n = 0\n    while z & 0x80:\n        z = read_byte()\n        # xFSSKAED\n        S |= (z & 0x30) << (2 * n)\n        E |= (z & 0x02) << n\n        F |= ((z & 0x40) >> 6) << n\n        A |= (z & 0x4) << n\n        K |= ((z & 0x08) >> 3) << n\n        D |= (z & 0x1) << n\n        n += 1\n    S += 1\n    return S, E, F, A, K, D\n\n\ndef read_prelude_size(read_byte):\n    I = 0\n    C = 0\n    n = 0\n    while True:\n        z = read_byte()\n        # xIIIIIIC\n        I |= ((z & 0x7E) >> 1) << (6 * n)\n        C |= (z & 1) << n\n        if not (z & 0x80):\n            break\n        n += 1\n    return I, C\n\n\n# See py/bc.h:MP_BC_PRELUDE_SIZE_ENCODE macro.\ndef encode_prelude_size(I, C):\n    # Encode bit-wise as: xIIIIIIC\n    encoded = bytearray()\n    while True:\n        z = (I & 0x3F) << 1 | (C & 1)\n        C >>= 1\n        I >>= 6\n        if C | I:\n            z |= 0x80\n        encoded.append(z)\n        if not C | I:\n            return encoded\n\n\ndef extract_prelude(bytecode, ip):\n    def local_read_byte():\n        b = bytecode[ip_ref[0]]\n        ip_ref[0] += 1\n        return b\n\n    ip_ref = [ip]  # to close over ip in Python 2 and 3\n\n    # Read prelude signature.\n    (\n        n_state,\n        n_exc_stack,\n        scope_flags,\n        n_pos_args,\n        n_kwonly_args,\n        n_def_pos_args,\n    ) = read_prelude_sig(local_read_byte)\n\n    offset_prelude_size = ip_ref[0]\n\n    # Read prelude size.\n    n_info, n_cell = read_prelude_size(local_read_byte)\n\n    offset_source_info = ip_ref[0]\n\n    # Extract simple_name and argument qstrs (var uints).\n    args = []\n    for arg_num in range(1 + n_pos_args + n_kwonly_args):\n        value = 0\n        while True:\n            b = local_read_byte()\n            value = (value << 7) | (b & 0x7F)\n            if b & 0x80 == 0:\n                break\n        args.append(value)\n\n    offset_line_info = ip_ref[0]\n    offset_closure_info = offset_source_info + n_info\n    offset_opcodes = offset_source_info + n_info + n_cell\n\n    return (\n        offset_prelude_size,\n        offset_source_info,\n        offset_line_info,\n        offset_closure_info,\n        offset_opcodes,\n        (n_state, n_exc_stack, scope_flags, n_pos_args, n_kwonly_args, n_def_pos_args),\n        (n_info, n_cell),\n        args,\n    )\n\n\nclass QStrType:\n    def __init__(self, str):\n        self.str = str\n        self.qstr_esc = qstrutil.qstr_escape(self.str)\n        self.qstr_id = \"MP_QSTR_\" + self.qstr_esc\n\n\nclass GlobalQStrList:\n    def __init__(self):\n        # Initialise global list of qstrs with static qstrs\n        self.qstrs = [None]  # MP_QSTRnull should never be referenced\n        for n in qstrutil.static_qstr_list:\n            self.qstrs.append(QStrType(n))\n\n    def add(self, s):\n        q = QStrType(s)\n        self.qstrs.append(q)\n        return q\n\n    def get_by_index(self, i):\n        return self.qstrs[i]\n\n    def find_by_str(self, s):\n        for q in self.qstrs:\n            if q is not None and q.str == s:\n                return q\n        return None\n\n\nclass MPFunTable:\n    def __repr__(self):\n        return \"mp_fun_table\"\n\n\nclass CompiledModule:\n    def __init__(\n        self,\n        mpy_source_file,\n        mpy_segments,\n        header,\n        qstr_table,\n        obj_table,\n        raw_code,\n        qstr_table_file_offset,\n        obj_table_file_offset,\n        raw_code_file_offset,\n        escaped_name,\n    ):\n        self.mpy_source_file = mpy_source_file\n        self.mpy_segments = mpy_segments\n        self.source_file = qstr_table[0]\n        self.header = header\n        self.qstr_table = qstr_table\n        self.obj_table = obj_table\n        self.raw_code = raw_code\n        self.qstr_table_file_offset = qstr_table_file_offset\n        self.obj_table_file_offset = obj_table_file_offset\n        self.raw_code_file_offset = raw_code_file_offset\n        self.escaped_name = escaped_name\n\n    def hexdump(self):\n        with open(self.mpy_source_file, \"rb\") as f:\n            WIDTH = 16\n            COL_OFF = \"\\033[0m\"\n            COL_TABLE = (\n                (\"\", \"\"),  # META\n                (\"\\033[0;31m\", \"\\033[0;91m\"),  # QSTR\n                (\"\\033[0;32m\", \"\\033[0;92m\"),  # OBJ\n                (\"\\033[0;34m\", \"\\033[0;94m\"),  # CODE\n            )\n            cur_col = \"\"\n            cur_col_index = 0\n            offset = 0\n            segment_index = 0\n            while True:\n                data = bytes_cons(f.read(WIDTH))\n                if not data:\n                    break\n\n                # Print out the hex dump of this line of data.\n                line_hex = cur_col\n                line_chr = cur_col\n                line_comment = \"\"\n                for i in range(len(data)):\n                    # Determine the colour of the data, if any, and the line comment.\n                    while segment_index < len(self.mpy_segments):\n                        if offset + i == self.mpy_segments[segment_index].start:\n                            cur_col = COL_TABLE[self.mpy_segments[segment_index].kind][\n                                cur_col_index\n                            ]\n                            cur_col_index = 1 - cur_col_index\n                            line_hex += cur_col\n                            line_chr += cur_col\n                            line_comment += \" %s%s%s\" % (\n                                cur_col,\n                                self.mpy_segments[segment_index].name,\n                                COL_OFF,\n                            )\n                        if offset + i == self.mpy_segments[segment_index].end:\n                            cur_col = \"\"\n                            line_hex += COL_OFF\n                            line_chr += COL_OFF\n                            segment_index += 1\n                        else:\n                            break\n\n                    # Add to the hex part of the line.\n                    if i % 2 == 0:\n                        line_hex += \" \"\n                    line_hex += \"%02x\" % data[i]\n\n                    # Add to the characters part of the line.\n                    if 0x20 <= data[i] <= 0x7E:\n                        line_chr += \"%s\" % chr(data[i])\n                    else:\n                        line_chr += \".\"\n\n                # Print out this line.\n                if cur_col:\n                    line_hex += COL_OFF\n                    line_chr += COL_OFF\n                pad = \" \" * ((WIDTH - len(data)) * 5 // 2)\n                print(\"%08x:%s%s  %s %s\" % (offset, line_hex, pad, line_chr, line_comment))\n                offset += WIDTH\n\n    def disassemble(self):\n        print(\"mpy_source_file:\", self.mpy_source_file)\n        print(\"source_file:\", self.source_file.str)\n        print(\"header:\", hexlify_to_str(self.header))\n        print(\"qstr_table[%u]:\" % len(self.qstr_table))\n        for q in self.qstr_table:\n            print(\"    %s\" % q.str)\n        print(\"obj_table:\", self.obj_table)\n        self.raw_code.disassemble()\n\n    def freeze(self, compiled_module_index):\n        print()\n        print(\"/\" * 80)\n        print(\"// frozen module %s\" % self.escaped_name)\n        print(\"// - original source file: %s\" % self.mpy_source_file)\n        print(\"// - frozen file name: %s\" % self.source_file.str)\n        print(\"// - .mpy header: %s\" % \":\".join(\"%02x\" % b for b in self.header))\n        print()\n\n        self.raw_code.freeze()\n        print()\n\n        self.freeze_constants()\n\n        print()\n        print(\"static const mp_frozen_module_t frozen_module_%s = {\" % self.escaped_name)\n        print(\"    .constants = {\")\n        if len(self.qstr_table):\n            print(\n                \"        .qstr_table = (qstr_short_t *)&const_qstr_table_data_%s,\"\n                % self.escaped_name\n            )\n        else:\n            print(\"        .qstr_table = NULL,\")\n        if len(self.obj_table):\n            print(\"        .obj_table = (mp_obj_t *)&const_obj_table_data_%s,\" % self.escaped_name)\n        else:\n            print(\"        .obj_table = NULL,\")\n        print(\"    },\")\n        print(\"    .proto_fun = &proto_fun_%s,\" % self.raw_code.escaped_name)\n        print(\"};\")\n\n    def freeze_constant_obj(self, obj_name, obj):\n        global const_str_content, const_int_content, const_obj_content\n\n        if isinstance(obj, MPFunTable):\n            return \"&mp_fun_table\"\n        elif obj is None:\n            return \"MP_ROM_NONE\"\n        elif obj is False:\n            return \"MP_ROM_FALSE\"\n        elif obj is True:\n            return \"MP_ROM_TRUE\"\n        elif obj is Ellipsis:\n            return \"MP_ROM_PTR(&mp_const_ellipsis_obj)\"\n        elif is_str_type(obj) or is_bytes_type(obj):\n            if len(obj) == 0:\n                if is_str_type(obj):\n                    return \"MP_ROM_QSTR(MP_QSTR_)\"\n                else:\n                    return \"MP_ROM_PTR(&mp_const_empty_bytes_obj)\"\n            if is_str_type(obj):\n                q = global_qstrs.find_by_str(obj)\n                if q:\n                    return \"MP_ROM_QSTR(%s)\" % q.qstr_id\n                obj = bytes_cons(obj, \"utf8\")\n                obj_type = \"mp_type_str\"\n            else:\n                obj_type = \"mp_type_bytes\"\n            print(\n                'static const mp_obj_str_t %s = {{&%s}, %u, %u, (const byte*)\"%s\"};'\n                % (\n                    obj_name,\n                    obj_type,\n                    qstrutil.compute_hash(obj, config.MICROPY_QSTR_BYTES_IN_HASH),\n                    len(obj),\n                    \"\".join((\"\\\\x%02x\" % b) for b in obj),\n                )\n            )\n            const_str_content += len(obj)\n            const_obj_content += 4 * 4\n            return \"MP_ROM_PTR(&%s)\" % obj_name\n        elif is_int_type(obj):\n            if mp_small_int_fits(obj):\n                # Encode directly as a small integer object.\n                return \"MP_ROM_INT(%d)\" % obj\n            elif config.MICROPY_LONGINT_IMPL == config.MICROPY_LONGINT_IMPL_NONE:\n                raise FreezeError(self, \"target does not support long int\")\n            elif config.MICROPY_LONGINT_IMPL == config.MICROPY_LONGINT_IMPL_LONGLONG:\n                # TODO\n                raise FreezeError(self, \"freezing int to long-long is not implemented\")\n            elif config.MICROPY_LONGINT_IMPL == config.MICROPY_LONGINT_IMPL_MPZ:\n                neg = 0\n                if obj < 0:\n                    obj = -obj\n                    neg = 1\n                bits_per_dig = config.MPZ_DIG_SIZE\n                digs = []\n                z = obj\n                while z:\n                    digs.append(z & ((1 << bits_per_dig) - 1))\n                    z >>= bits_per_dig\n                ndigs = len(digs)\n                digs = \",\".join((\"%#x\" % d) for d in digs)\n                print(\n                    \"static const mp_obj_int_t %s = {{&mp_type_int}, \"\n                    \"{.neg=%u, .fixed_dig=1, .alloc=%u, .len=%u, .dig=(uint%u_t*)(const uint%u_t[]){%s}}};\"\n                    % (obj_name, neg, ndigs, ndigs, bits_per_dig, bits_per_dig, digs)\n                )\n                const_int_content += (digs.count(\",\") + 1) * bits_per_dig // 8\n                const_obj_content += 4 * 4\n                return \"MP_ROM_PTR(&%s)\" % obj_name\n        elif isinstance(obj, float):\n            macro_name = \"%s_macro\" % obj_name\n            print(\n                \"#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B\"\n            )\n            print(\n                \"static const mp_obj_float_t %s = {{&mp_type_float}, (mp_float_t)%.16g};\"\n                % (obj_name, obj)\n            )\n            print(\"#define %s MP_ROM_PTR(&%s)\" % (macro_name, obj_name))\n            print(\"#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C\")\n            n = struct.unpack(\"<I\", struct.pack(\"<f\", obj))[0]\n            n = ((n & ~0x3) | 2) + 0x80800000\n            print(\"#define %s ((mp_rom_obj_t)(0x%08x))\" % (macro_name, n))\n            print(\"#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\")\n            n = struct.unpack(\"<Q\", struct.pack(\"<d\", obj))[0]\n            n += 0x8004000000000000\n            print(\"#define %s ((mp_rom_obj_t)(0x%016x))\" % (macro_name, n))\n            print(\"#endif\")\n            const_obj_content += 3 * 4\n            return macro_name\n        elif isinstance(obj, complex):\n            print(\n                \"static const mp_obj_complex_t %s = {{&mp_type_complex}, (mp_float_t)%.16g, (mp_float_t)%.16g};\"\n                % (obj_name, obj.real, obj.imag)\n            )\n            return \"MP_ROM_PTR(&%s)\" % obj_name\n        elif type(obj) is tuple:\n            if len(obj) == 0:\n                return \"MP_ROM_PTR(&mp_const_empty_tuple_obj)\"\n            else:\n                obj_refs = []\n                for i, sub_obj in enumerate(obj):\n                    sub_obj_name = \"%s_%u\" % (obj_name, i)\n                    obj_refs.append(self.freeze_constant_obj(sub_obj_name, sub_obj))\n                print(\n                    \"static const mp_rom_obj_tuple_t %s = {{&mp_type_tuple}, %d, {\"\n                    % (obj_name, len(obj))\n                )\n                for ref in obj_refs:\n                    print(\"    %s,\" % ref)\n                print(\"}};\")\n                return \"MP_ROM_PTR(&%s)\" % obj_name\n        else:\n            raise FreezeError(self, \"freezing of object %r is not implemented\" % (obj,))\n\n    def freeze_constants(self):\n        if len(self.qstr_table):\n            print(\n                \"static const qstr_short_t const_qstr_table_data_%s[%u] = {\"\n                % (self.escaped_name, len(self.qstr_table))\n            )\n            for q in self.qstr_table:\n                print(\"    %s,\" % q.qstr_id)\n            print(\"};\")\n\n        if not len(self.obj_table):\n            return\n\n        # generate constant objects\n        print()\n        print(\"// constants\")\n        obj_refs = []\n        for i, obj in enumerate(self.obj_table):\n            obj_name = \"const_obj_%s_%u\" % (self.escaped_name, i)\n            obj_refs.append(self.freeze_constant_obj(obj_name, obj))\n\n        # generate constant table\n        print()\n        print(\"// constant table\")\n        print(\n            \"static const mp_rom_obj_t const_obj_table_data_%s[%u] = {\"\n            % (self.escaped_name, len(self.obj_table))\n        )\n        for ref in obj_refs:\n            print(\"    %s,\" % ref)\n        print(\"};\")\n\n        global const_table_ptr_content\n        const_table_ptr_content += len(self.obj_table)\n\n\nclass RawCode(object):\n    # a set of all escaped names, to make sure they are unique\n    escaped_names = set()\n\n    # convert code kind number to string\n    code_kind_str = {\n        MP_CODE_BYTECODE: \"MP_CODE_BYTECODE\",\n        MP_CODE_NATIVE_PY: \"MP_CODE_NATIVE_PY\",\n        MP_CODE_NATIVE_VIPER: \"MP_CODE_NATIVE_VIPER\",\n        MP_CODE_NATIVE_ASM: \"MP_CODE_NATIVE_ASM\",\n    }\n\n    def __init__(self, parent_name, qstr_table, fun_data, prelude_offset, code_kind):\n        self.qstr_table = qstr_table\n        self.fun_data = fun_data\n        self.prelude_offset = prelude_offset\n        self.code_kind = code_kind\n\n        if code_kind in (MP_CODE_BYTECODE, MP_CODE_NATIVE_PY):\n            (\n                self.offset_prelude_size,\n                self.offset_source_info,\n                self.offset_line_info,\n                self.offset_closure_info,\n                self.offset_opcodes,\n                self.prelude_signature,\n                self.prelude_size,\n                self.names,\n            ) = extract_prelude(self.fun_data, prelude_offset)\n            self.scope_flags = self.prelude_signature[2]\n            self.n_pos_args = self.prelude_signature[3]\n            self.simple_name = self.qstr_table[self.names[0]]\n        else:\n            self.simple_name = self.qstr_table[0]\n\n        escaped_name = parent_name + \"_\" + self.simple_name.qstr_esc\n\n        # make sure the escaped name is unique\n        i = 2\n        unique_escaped_name = escaped_name\n        while unique_escaped_name in self.escaped_names:\n            unique_escaped_name = escaped_name + str(i)\n            i += 1\n        self.escaped_names.add(unique_escaped_name)\n        self.escaped_name = unique_escaped_name\n\n    def disassemble_children(self):\n        print(\"  children:\", [rc.simple_name.str for rc in self.children])\n        for rc in self.children:\n            rc.disassemble()\n\n    def freeze_children(self, prelude_ptr=None):\n        # Freeze children and generate table of children.\n        if len(self.children):\n            for rc in self.children:\n                print(\"// child of %s\" % self.escaped_name)\n                rc.freeze()\n                print()\n            print(\"static const mp_raw_code_t *const children_%s[] = {\" % self.escaped_name)\n            for rc in self.children:\n                print(\"    (const mp_raw_code_t *)&proto_fun_%s,\" % rc.escaped_name)\n            if prelude_ptr:\n                print(\"    (void *)%s,\" % prelude_ptr)\n            print(\"};\")\n            print()\n\n    def freeze_raw_code(self, prelude_ptr=None, type_sig=0):\n        # Generate mp_raw_code_t.\n        if self.code_kind == MP_CODE_NATIVE_ASM:\n            raw_code_type = \"mp_raw_code_t\"\n        else:\n            raw_code_type = \"mp_raw_code_truncated_t\"\n\n        empty_children = len(self.children) == 0 and prelude_ptr is None\n        generate_minimal = self.code_kind == MP_CODE_BYTECODE and empty_children\n\n        if generate_minimal:\n            print(\"#if MICROPY_PERSISTENT_CODE_SAVE\")\n\n        print(\"static const %s proto_fun_%s = {\" % (raw_code_type, self.escaped_name))\n        print(\"    .proto_fun_indicator[0] = MP_PROTO_FUN_INDICATOR_RAW_CODE_0,\")\n        print(\"    .proto_fun_indicator[1] = MP_PROTO_FUN_INDICATOR_RAW_CODE_1,\")\n        print(\"    .kind = %s,\" % RawCode.code_kind_str[self.code_kind])\n        print(\"    .is_generator = %d,\" % bool(self.scope_flags & MP_SCOPE_FLAG_GENERATOR))\n        print(\"    .fun_data = fun_data_%s,\" % self.escaped_name)\n        if len(self.children):\n            print(\"    .children = (void *)&children_%s,\" % self.escaped_name)\n        elif prelude_ptr:\n            print(\"    .children = (void *)%s,\" % prelude_ptr)\n        else:\n            print(\"    .children = NULL,\")\n        print(\"    #if MICROPY_PERSISTENT_CODE_SAVE\")\n        print(\"    .fun_data_len = %u,\" % len(self.fun_data))\n        print(\"    .n_children = %u,\" % len(self.children))\n        print(\"    #if MICROPY_EMIT_MACHINE_CODE\")\n        print(\"    .prelude_offset = %u,\" % self.prelude_offset)\n        print(\"    #endif\")\n        if self.code_kind == MP_CODE_BYTECODE:\n            print(\"    #if MICROPY_PY_SYS_SETTRACE\")\n            print(\"    .line_of_definition = %u,\" % 0)  # TODO\n            print(\"    .prelude = {\")\n            print(\"        .n_state = %u,\" % self.prelude_signature[0])\n            print(\"        .n_exc_stack = %u,\" % self.prelude_signature[1])\n            print(\"        .scope_flags = %u,\" % self.prelude_signature[2])\n            print(\"        .n_pos_args = %u,\" % self.prelude_signature[3])\n            print(\"        .n_kwonly_args = %u,\" % self.prelude_signature[4])\n            print(\"        .n_def_pos_args = %u,\" % self.prelude_signature[5])\n            print(\"        .qstr_block_name_idx = %u,\" % self.names[0])\n            print(\n                \"        .line_info = fun_data_%s + %u,\"\n                % (self.escaped_name, self.offset_line_info)\n            )\n            print(\n                \"        .line_info_top = fun_data_%s + %u,\"\n                % (self.escaped_name, self.offset_closure_info)\n            )\n            print(\n                \"        .opcodes = fun_data_%s + %u,\" % (self.escaped_name, self.offset_opcodes)\n            )\n            print(\"    },\")\n            print(\"    #endif\")\n        print(\"    #endif\")\n        if self.code_kind == MP_CODE_NATIVE_ASM:\n            print(\"    .asm_n_pos_args = %u,\" % self.n_pos_args)\n            print(\"    .asm_type_sig = %u,\" % type_sig)\n        print(\"};\")\n\n        if generate_minimal:\n            print(\"#else\")\n            print(\"#define proto_fun_%s fun_data_%s[0]\" % (self.escaped_name, self.escaped_name))\n            print(\"#endif\")\n\n        global raw_code_count, raw_code_content\n        raw_code_count += 1\n        raw_code_content += 4 * 4\n\n\nclass RawCodeBytecode(RawCode):\n    def __init__(self, parent_name, qstr_table, obj_table, fun_data):\n        self.obj_table = obj_table\n        super(RawCodeBytecode, self).__init__(\n            parent_name, qstr_table, fun_data, 0, MP_CODE_BYTECODE\n        )\n\n    def disassemble(self):\n        bc = self.fun_data\n        print(\"simple_name:\", self.simple_name.str)\n        print(\"  raw bytecode:\", len(bc), hexlify_to_str(bc))\n        print(\"  prelude:\", self.prelude_signature)\n        print(\"  args:\", [self.qstr_table[i].str for i in self.names[1:]])\n        print(\"  line info:\", hexlify_to_str(bc[self.offset_line_info : self.offset_opcodes]))\n        ip = self.offset_opcodes\n        while ip < len(bc):\n            fmt, sz, arg, _ = mp_opcode_decode(bc, ip)\n            if bc[ip] == Opcode.MP_BC_LOAD_CONST_OBJ:\n                arg = repr(self.obj_table[arg])\n            if fmt == MP_BC_FORMAT_QSTR:\n                arg = self.qstr_table[arg].str\n            elif fmt in (MP_BC_FORMAT_VAR_UINT, MP_BC_FORMAT_OFFSET):\n                pass\n            else:\n                arg = \"\"\n            print(\n                \"  %-11s %s %s\" % (hexlify_to_str(bc[ip : ip + sz]), Opcode.mapping[bc[ip]], arg)\n            )\n            ip += sz\n        self.disassemble_children()\n\n    def freeze(self):\n        # generate bytecode data\n        bc = self.fun_data\n        print(\n            \"// frozen bytecode for file %s, scope %s\"\n            % (self.qstr_table[0].str, self.escaped_name)\n        )\n        print(\"static const byte fun_data_%s[%u] = {\" % (self.escaped_name, len(bc)))\n\n        print(\"    \", end=\"\")\n        for b in bc[: self.offset_source_info]:\n            print(\"0x%02x,\" % b, end=\"\")\n        print(\" // prelude\")\n\n        print(\"    \", end=\"\")\n        for b in bc[self.offset_source_info : self.offset_line_info]:\n            print(\"0x%02x,\" % b, end=\"\")\n        print(\" // names: %s\" % \", \".join(self.qstr_table[i].str for i in self.names))\n\n        print(\"    \", end=\"\")\n        for b in bc[self.offset_line_info : self.offset_opcodes]:\n            print(\"0x%02x,\" % b, end=\"\")\n        print(\" // code info\")\n\n        ip = self.offset_opcodes\n        while ip < len(bc):\n            fmt, sz, arg, _ = mp_opcode_decode(bc, ip)\n            opcode_name = Opcode.mapping[bc[ip]]\n            if fmt == MP_BC_FORMAT_QSTR:\n                opcode_name += \" \" + repr(self.qstr_table[arg].str)\n            elif fmt in (MP_BC_FORMAT_VAR_UINT, MP_BC_FORMAT_OFFSET):\n                opcode_name += \" %u\" % arg\n            print(\n                \"    %s, // %s\" % (\",\".join(\"0x%02x\" % b for b in bc[ip : ip + sz]), opcode_name)\n            )\n            ip += sz\n\n        print(\"};\")\n\n        self.freeze_children()\n        self.freeze_raw_code()\n\n        global bc_content\n        bc_content += len(bc)\n\n\nclass RawCodeNative(RawCode):\n    def __init__(\n        self,\n        parent_name,\n        qstr_table,\n        kind,\n        fun_data,\n        prelude_offset,\n        scope_flags,\n        n_pos_args,\n        type_sig,\n    ):\n        super(RawCodeNative, self).__init__(\n            parent_name, qstr_table, fun_data, prelude_offset, kind\n        )\n\n        if kind in (MP_CODE_NATIVE_VIPER, MP_CODE_NATIVE_ASM):\n            self.scope_flags = scope_flags\n            self.n_pos_args = n_pos_args\n\n        self.type_sig = type_sig\n        if config.native_arch in (\n            MP_NATIVE_ARCH_X86,\n            MP_NATIVE_ARCH_X64,\n            MP_NATIVE_ARCH_XTENSA,\n            MP_NATIVE_ARCH_XTENSAWIN,\n        ):\n            self.fun_data_attributes = '__attribute__((section(\".text,\\\\\"ax\\\\\",@progbits # \")))'\n        else:\n            self.fun_data_attributes = '__attribute__((section(\".text,\\\\\"ax\\\\\",%progbits @ \")))'\n\n        # Allow single-byte alignment by default for x86/x64.\n        # ARM needs word alignment, ARM Thumb needs halfword, due to instruction size.\n        # Xtensa needs word alignment due to the 32-bit constant table embedded in the code.\n        if config.native_arch in (\n            MP_NATIVE_ARCH_ARMV6,\n            MP_NATIVE_ARCH_XTENSA,\n            MP_NATIVE_ARCH_XTENSAWIN,\n        ):\n            # ARMV6 or Xtensa -- four byte align.\n            self.fun_data_attributes += \" __attribute__ ((aligned (4)))\"\n        elif MP_NATIVE_ARCH_ARMV6M <= config.native_arch <= MP_NATIVE_ARCH_ARMV7EMDP:\n            # ARMVxxM -- two byte align.\n            self.fun_data_attributes += \" __attribute__ ((aligned (2)))\"\n\n    def disassemble(self):\n        fun_data = self.fun_data\n        print(\"simple_name:\", self.simple_name.str)\n        print(\n            \"  raw data:\",\n            len(fun_data),\n            hexlify_to_str(fun_data[:32]),\n            \"...\" if len(fun_data) > 32 else \"\",\n        )\n        if self.code_kind != MP_CODE_NATIVE_PY:\n            return\n        print(\"  prelude:\", self.prelude_signature)\n        print(\"  args:\", [self.qstr_table[i].str for i in self.names[1:]])\n        print(\"  line info:\", fun_data[self.offset_line_info : self.offset_opcodes])\n        ip = 0\n        while ip < self.prelude_offset:\n            sz = 16\n            print(\" \", hexlify_to_str(fun_data[ip : min(ip + sz, self.prelude_offset)]))\n            ip += sz\n        self.disassemble_children()\n\n    def freeze(self):\n        if self.scope_flags & ~0x0F:\n            raise FreezeError(\"unable to freeze code with relocations\")\n\n        # generate native code data\n        print()\n        print(\n            \"// frozen native code for file %s, scope %s\"\n            % (self.qstr_table[0].str, self.escaped_name)\n        )\n        print(\n            \"static const byte fun_data_%s[%u] %s = {\"\n            % (self.escaped_name, len(self.fun_data), self.fun_data_attributes)\n        )\n\n        i_top = len(self.fun_data)\n        i = 0\n        while i < i_top:\n            # copy machine code (max 16 bytes)\n            i16 = min(i + 16, i_top)\n            print(\"   \", end=\"\")\n            for ii in range(i, i16):\n                print(\" 0x%02x,\" % self.fun_data[ii], end=\"\")\n            print()\n            i = i16\n\n        print(\"};\")\n\n        prelude_ptr = None\n        if self.code_kind == MP_CODE_NATIVE_PY:\n            prelude_ptr = \"fun_data_%s_prelude_macro\" % self.escaped_name\n            print(\"#if MICROPY_EMIT_NATIVE_PRELUDE_SEPARATE_FROM_MACHINE_CODE\")\n            n = len(self.fun_data) - self.prelude_offset\n            print(\"static const byte fun_data_%s_prelude[%u] = {\" % (self.escaped_name, n), end=\"\")\n            for i in range(n):\n                print(\" 0x%02x,\" % self.fun_data[self.prelude_offset + i], end=\"\")\n            print(\"};\")\n            print(\"#define %s &fun_data_%s_prelude[0]\" % (prelude_ptr, self.escaped_name))\n            print(\"#else\")\n            print(\n                \"#define %s &fun_data_%s[%u]\"\n                % (prelude_ptr, self.escaped_name, self.prelude_offset)\n            )\n            print(\"#endif\")\n\n        self.freeze_children(prelude_ptr)\n        self.freeze_raw_code(prelude_ptr, self.type_sig)\n\n\nclass MPYSegment:\n    META = 0\n    QSTR = 1\n    OBJ = 2\n    CODE = 3\n\n    def __init__(self, kind, name, start, end):\n        self.kind = kind\n        self.name = name\n        self.start = start\n        self.end = end\n\n\nclass MPYReader:\n    def __init__(self, filename, fileobj):\n        self.filename = filename\n        self.fileobj = fileobj\n\n    def tell(self):\n        return self.fileobj.tell()\n\n    def read_byte(self):\n        return bytes_cons(self.fileobj.read(1))[0]\n\n    def read_bytes(self, n):\n        return bytes_cons(self.fileobj.read(n))\n\n    def read_uint(self):\n        i = 0\n        while True:\n            b = self.read_byte()\n            i = (i << 7) | (b & 0x7F)\n            if b & 0x80 == 0:\n                break\n        return i\n\n\ndef read_qstr(reader, segments):\n    start_pos = reader.tell()\n    ln = reader.read_uint()\n    if ln & 1:\n        # static qstr\n        q = global_qstrs.get_by_index(ln >> 1)\n        segments.append(MPYSegment(MPYSegment.META, q.str, start_pos, start_pos))\n        return q\n    ln >>= 1\n    start_pos = reader.tell()\n    data = str_cons(reader.read_bytes(ln), \"utf8\")\n    reader.read_byte()  # read and discard null terminator\n    segments.append(MPYSegment(MPYSegment.QSTR, data, start_pos, reader.tell()))\n    return global_qstrs.add(data)\n\n\ndef read_obj(reader, segments):\n    obj_type = reader.read_byte()\n    if obj_type == MP_PERSISTENT_OBJ_FUN_TABLE:\n        return MPFunTable()\n    elif obj_type == MP_PERSISTENT_OBJ_NONE:\n        return None\n    elif obj_type == MP_PERSISTENT_OBJ_FALSE:\n        return False\n    elif obj_type == MP_PERSISTENT_OBJ_TRUE:\n        return True\n    elif obj_type == MP_PERSISTENT_OBJ_ELLIPSIS:\n        return Ellipsis\n    elif obj_type == MP_PERSISTENT_OBJ_TUPLE:\n        ln = reader.read_uint()\n        return tuple(read_obj(reader, segments) for _ in range(ln))\n    else:\n        ln = reader.read_uint()\n        start_pos = reader.tell()\n        buf = reader.read_bytes(ln)\n        if obj_type in (MP_PERSISTENT_OBJ_STR, MP_PERSISTENT_OBJ_BYTES):\n            reader.read_byte()  # read and discard null terminator\n        if obj_type == MP_PERSISTENT_OBJ_STR:\n            obj = str_cons(buf, \"utf8\")\n            if len(obj) < PERSISTENT_STR_INTERN_THRESHOLD:\n                if not global_qstrs.find_by_str(obj):\n                    global_qstrs.add(obj)\n        elif obj_type == MP_PERSISTENT_OBJ_BYTES:\n            obj = buf\n        elif obj_type == MP_PERSISTENT_OBJ_INT:\n            obj = int(str_cons(buf, \"ascii\"), 10)\n        elif obj_type == MP_PERSISTENT_OBJ_FLOAT:\n            obj = float(str_cons(buf, \"ascii\"))\n        elif obj_type == MP_PERSISTENT_OBJ_COMPLEX:\n            obj = complex(str_cons(buf, \"ascii\"))\n        else:\n            raise MPYReadError(reader.filename, \"corrupt .mpy file\")\n        segments.append(MPYSegment(MPYSegment.OBJ, obj, start_pos, reader.tell()))\n        return obj\n\n\ndef read_raw_code(reader, parent_name, qstr_table, obj_table, segments):\n    # Read raw code header.\n    kind_len = reader.read_uint()\n    kind = (kind_len & 3) + MP_CODE_BYTECODE\n    has_children = (kind_len >> 2) & 1\n    fun_data_len = kind_len >> 3\n\n    # Read the body of the raw code.\n    file_offset = reader.tell()\n    fun_data = reader.read_bytes(fun_data_len)\n    segments_len = len(segments)\n\n    if kind == MP_CODE_BYTECODE:\n        # Create bytecode raw code.\n        rc = RawCodeBytecode(parent_name, qstr_table, obj_table, fun_data)\n    else:\n        # Create native raw code.\n        native_scope_flags = 0\n        native_n_pos_args = 0\n        native_type_sig = 0\n        if kind == MP_CODE_NATIVE_PY:\n            prelude_offset = reader.read_uint()\n        else:\n            prelude_offset = 0\n            native_scope_flags = reader.read_uint()\n            if kind == MP_CODE_NATIVE_VIPER:\n                # Read any additional sections for native viper.\n                if native_scope_flags & MP_SCOPE_FLAG_VIPERRODATA:\n                    rodata_size = reader.read_uint()\n                if native_scope_flags & MP_SCOPE_FLAG_VIPERBSS:\n                    reader.read_uint()  # bss_size\n                if native_scope_flags & MP_SCOPE_FLAG_VIPERRODATA:\n                    reader.read_bytes(rodata_size)\n                if native_scope_flags & MP_SCOPE_FLAG_VIPERRELOC:\n                    while True:\n                        op = reader.read_byte()\n                        if op == 0xFF:\n                            break\n                        if op & 1:\n                            reader.read_uint()  # addr\n                        op >>= 1\n                        if op <= 5 and op & 1:\n                            reader.read_uint()  # n\n            else:\n                assert kind == MP_CODE_NATIVE_ASM\n                native_n_pos_args = reader.read_uint()\n                native_type_sig = reader.read_uint()\n\n        rc = RawCodeNative(\n            parent_name,\n            qstr_table,\n            kind,\n            fun_data,\n            prelude_offset,\n            native_scope_flags,\n            native_n_pos_args,\n            native_type_sig,\n        )\n\n    # Add a segment for the raw code data.\n    segments.insert(\n        segments_len,\n        MPYSegment(MPYSegment.CODE, rc.simple_name.str, file_offset, file_offset + fun_data_len),\n    )\n\n    # Read children, if there are any.\n    rc.children = []\n    if has_children:\n        # Make a pretty parent name (otherwise all identifiers will include _lt_module_gt_).\n        if not rc.escaped_name.endswith(\"_lt_module_gt_\"):\n            parent_name = rc.escaped_name\n\n        # Read all the child raw codes.\n        n_children = reader.read_uint()\n        for _ in range(n_children):\n            rc.children.append(read_raw_code(reader, parent_name, qstr_table, obj_table, segments))\n\n    return rc\n\n\ndef read_mpy(filename):\n    with open(filename, \"rb\") as fileobj:\n        reader = MPYReader(filename, fileobj)\n        segments = []\n\n        # Read and verify the header.\n        header = reader.read_bytes(4)\n        if header[0] != ord(\"M\"):\n            raise MPYReadError(filename, \"not a valid .mpy file\")\n        if header[1] != config.MPY_VERSION:\n            raise MPYReadError(filename, \"incompatible .mpy version\")\n        feature_byte = header[2]\n        mpy_native_arch = feature_byte >> 2\n        if mpy_native_arch != MP_NATIVE_ARCH_NONE:\n            mpy_sub_version = feature_byte & 3\n            if mpy_sub_version != config.MPY_SUB_VERSION:\n                raise MPYReadError(filename, \"incompatible .mpy sub-version\")\n            if config.native_arch == MP_NATIVE_ARCH_NONE:\n                config.native_arch = mpy_native_arch\n            elif config.native_arch != mpy_native_arch:\n                raise MPYReadError(filename, \"native architecture mismatch\")\n        config.mp_small_int_bits = header[3]\n\n        # Read number of qstrs, and number of objects.\n        n_qstr = reader.read_uint()\n        n_obj = reader.read_uint()\n\n        # Read qstrs and construct qstr table.\n        qstr_table_file_offset = reader.tell()\n        qstr_table = []\n        for i in range(n_qstr):\n            qstr_table.append(read_qstr(reader, segments))\n\n        # Read objects and construct object table.\n        obj_table_file_offset = reader.tell()\n        obj_table = []\n        for i in range(n_obj):\n            obj_table.append(read_obj(reader, segments))\n\n        # Compute the compiled-module escaped name.\n        cm_escaped_name = qstr_table[0].str.replace(\"/\", \"_\")[:-3]\n\n        # Read the outer raw code, which will in turn read all its children.\n        raw_code_file_offset = reader.tell()\n        raw_code = read_raw_code(reader, cm_escaped_name, qstr_table, obj_table, segments)\n\n    # Create the outer-level compiled module representing the whole .mpy file.\n    return CompiledModule(\n        filename,\n        segments,\n        header,\n        qstr_table,\n        obj_table,\n        raw_code,\n        qstr_table_file_offset,\n        obj_table_file_offset,\n        raw_code_file_offset,\n        cm_escaped_name,\n    )\n\n\ndef hexdump_mpy(compiled_modules):\n    for cm in compiled_modules:\n        cm.hexdump()\n\n\ndef disassemble_mpy(compiled_modules):\n    for cm in compiled_modules:\n        cm.disassemble()\n\n\ndef freeze_mpy(firmware_qstr_idents, compiled_modules):\n    # add to qstrs\n    new = {}\n    for q in global_qstrs.qstrs:\n        # don't add duplicates that are already in the firmware\n        if q is None or q.qstr_esc in firmware_qstr_idents or q.qstr_esc in new:\n            continue\n        new[q.qstr_esc] = (len(new), q.qstr_esc, q.str, bytes_cons(q.str, \"utf8\"))\n    # Sort by string value (because this is a sorted pool).\n    new = sorted(new.values(), key=lambda x: x[2])\n\n    print('#include \"py/mpconfig.h\"')\n    print('#include \"py/objint.h\"')\n    print('#include \"py/objstr.h\"')\n    print('#include \"py/emitglue.h\"')\n    print('#include \"py/nativeglue.h\"')\n    print()\n\n    print(\"#if MICROPY_LONGINT_IMPL != %u\" % config.MICROPY_LONGINT_IMPL)\n    print('#error \"incompatible MICROPY_LONGINT_IMPL\"')\n    print(\"#endif\")\n    print()\n\n    if config.MICROPY_LONGINT_IMPL == config.MICROPY_LONGINT_IMPL_MPZ:\n        print(\"#if MPZ_DIG_SIZE != %u\" % config.MPZ_DIG_SIZE)\n        print('#error \"incompatible MPZ_DIG_SIZE\"')\n        print(\"#endif\")\n        print()\n\n    print(\"#if MICROPY_PY_BUILTINS_FLOAT\")\n    print(\"typedef struct _mp_obj_float_t {\")\n    print(\"    mp_obj_base_t base;\")\n    print(\"    mp_float_t value;\")\n    print(\"} mp_obj_float_t;\")\n    print(\"#endif\")\n    print()\n\n    print(\"#if MICROPY_PY_BUILTINS_COMPLEX\")\n    print(\"typedef struct _mp_obj_complex_t {\")\n    print(\"    mp_obj_base_t base;\")\n    print(\"    mp_float_t real;\")\n    print(\"    mp_float_t imag;\")\n    print(\"} mp_obj_complex_t;\")\n    print(\"#endif\")\n    print()\n\n    if len(new) > 0:\n        print(\"enum {\")\n        for i in range(len(new)):\n            if i == 0:\n                print(\"    MP_QSTR_%s = MP_QSTRnumber_of,\" % new[i][1])\n            else:\n                print(\"    MP_QSTR_%s,\" % new[i][1])\n        print(\"};\")\n\n    # As in qstr.c, set so that the first dynamically allocated pool is twice this size; must be <= the len\n    qstr_pool_alloc = min(len(new), 10)\n\n    global \\\n        bc_content, \\\n        const_str_content, \\\n        const_int_content, \\\n        const_obj_content, \\\n        const_table_qstr_content, \\\n        const_table_ptr_content, \\\n        raw_code_count, \\\n        raw_code_content\n    qstr_content = 0\n    bc_content = 0\n    const_str_content = 0\n    const_int_content = 0\n    const_obj_content = 0\n    const_table_qstr_content = 0\n    const_table_ptr_content = 0\n    raw_code_count = 0\n    raw_code_content = 0\n\n    if config.MICROPY_QSTR_BYTES_IN_HASH:\n        print()\n        print(\"const qstr_hash_t mp_qstr_frozen_const_hashes[] = {\")\n        for _, _, _, qbytes in new:\n            qhash = qstrutil.compute_hash(qbytes, config.MICROPY_QSTR_BYTES_IN_HASH)\n            print(\"    %d,\" % qhash)\n            qstr_content += config.MICROPY_QSTR_BYTES_IN_HASH\n        print(\"};\")\n    print()\n    print(\"const qstr_len_t mp_qstr_frozen_const_lengths[] = {\")\n    for _, _, _, qbytes in new:\n        print(\"    %d,\" % len(qbytes))\n        qstr_content += config.MICROPY_QSTR_BYTES_IN_LEN\n        qstr_content += len(qbytes) + 1  # include NUL\n    print(\"};\")\n    print()\n    print(\"extern const qstr_pool_t mp_qstr_const_pool;\")\n    print(\"const qstr_pool_t mp_qstr_frozen_const_pool = {\")\n    print(\"    &mp_qstr_const_pool, // previous pool\")\n    print(\"    MP_QSTRnumber_of, // previous pool size\")\n    print(\"    true, // is_sorted\")\n    print(\"    %u, // allocated entries\" % qstr_pool_alloc)\n    print(\"    %u, // used entries\" % len(new))\n    if config.MICROPY_QSTR_BYTES_IN_HASH:\n        print(\"    (qstr_hash_t *)mp_qstr_frozen_const_hashes,\")\n    print(\"    (qstr_len_t *)mp_qstr_frozen_const_lengths,\")\n    print(\"    {\")\n    for _, _, qstr, qbytes in new:\n        print('        \"%s\",' % qstrutil.escape_bytes(qstr, qbytes))\n    print(\"    },\")\n    print(\"};\")\n\n    # Freeze all modules.\n    for idx, cm in enumerate(compiled_modules):\n        cm.freeze(idx)\n\n    # Print separator, separating individual modules from global data structures.\n    print()\n    print(\"/\" * 80)\n    print(\"// collection of all frozen modules\")\n\n    # Define the string of frozen module names.\n    print()\n    print(\"const char mp_frozen_names[] = {\")\n    print(\"    #ifdef MP_FROZEN_STR_NAMES\")\n    # makemanifest.py might also include some frozen string content.\n    print(\"    MP_FROZEN_STR_NAMES\")\n    print(\"    #endif\")\n    mp_frozen_mpy_names_content = 1\n    for cm in compiled_modules:\n        module_name = cm.source_file.str\n        print('    \"%s\\\\0\"' % module_name)\n        mp_frozen_mpy_names_content += len(cm.source_file.str) + 1\n    print('    \"\\\\0\"')\n    print(\"};\")\n\n    # Define the array of pointers to frozen module content.\n    print()\n    print(\"const mp_frozen_module_t *const mp_frozen_mpy_content[] = {\")\n    for cm in compiled_modules:\n        print(\"    &frozen_module_%s,\" % cm.escaped_name)\n    print(\"};\")\n    mp_frozen_mpy_content_size = len(compiled_modules * 4)\n\n    # If a port defines MICROPY_FROZEN_LIST_ITEM then list all modules wrapped in that macro.\n    print()\n    print(\"#ifdef MICROPY_FROZEN_LIST_ITEM\")\n    for cm in compiled_modules:\n        module_name = cm.source_file.str\n        if module_name.endswith(\"/__init__.py\"):\n            short_name = module_name[: -len(\"/__init__.py\")]\n        else:\n            short_name = module_name[: -len(\".py\")]\n        print('MICROPY_FROZEN_LIST_ITEM(\"%s\", \"%s\")' % (short_name, module_name))\n    print(\"#endif\")\n\n    print()\n    print(\"/*\")\n    print(\"byte sizes:\")\n    print(\"qstr content: %d unique, %d bytes\" % (len(new), qstr_content))\n    print(\"bc content: %d\" % bc_content)\n    print(\"const str content: %d\" % const_str_content)\n    print(\"const int content: %d\" % const_int_content)\n    print(\"const obj content: %d\" % const_obj_content)\n    print(\n        \"const table qstr content: %d entries, %d bytes\"\n        % (const_table_qstr_content, const_table_qstr_content * 4)\n    )\n    print(\n        \"const table ptr content: %d entries, %d bytes\"\n        % (const_table_ptr_content, const_table_ptr_content * 4)\n    )\n    print(\"raw code content: %d * 4 = %d\" % (raw_code_count, raw_code_content))\n    print(\"mp_frozen_mpy_names_content: %d\" % mp_frozen_mpy_names_content)\n    print(\"mp_frozen_mpy_content_size: %d\" % mp_frozen_mpy_content_size)\n    print(\n        \"total: %d\"\n        % (\n            qstr_content\n            + bc_content\n            + const_str_content\n            + const_int_content\n            + const_obj_content\n            + const_table_qstr_content * 4\n            + const_table_ptr_content * 4\n            + raw_code_content\n            + mp_frozen_mpy_names_content\n            + mp_frozen_mpy_content_size\n        )\n    )\n    print(\"*/\")\n\n\ndef adjust_bytecode_qstr_obj_indices(bytecode_in, qstr_table_base, obj_table_base):\n    # Expand bytcode to a list of opcodes.\n    opcodes = []\n    labels = {}\n    ip = 0\n    while ip < len(bytecode_in):\n        fmt, sz, arg, extra_arg = mp_opcode_decode(bytecode_in, ip)\n        opcode = Opcode(ip, fmt, bytecode_in[ip], arg, extra_arg)\n        labels[ip] = opcode\n        opcodes.append(opcode)\n        ip += sz\n        if fmt == MP_BC_FORMAT_OFFSET:\n            opcode.arg += ip\n\n    # Link jump opcodes to their destination.\n    for opcode in opcodes:\n        if opcode.fmt == MP_BC_FORMAT_OFFSET:\n            opcode.target = labels[opcode.arg]\n\n    # Adjust bytcode as required.\n    for opcode in opcodes:\n        if opcode.fmt == MP_BC_FORMAT_QSTR:\n            opcode.arg += qstr_table_base\n        elif opcode.opcode_byte == Opcode.MP_BC_LOAD_CONST_OBJ:\n            opcode.arg += obj_table_base\n\n    # Write out new bytecode.\n    offset_changed = True\n    while offset_changed:\n        offset_changed = False\n        overflow = False\n        bytecode_out = b\"\"\n        for opcode in opcodes:\n            ip = len(bytecode_out)\n            if opcode.offset != ip:\n                offset_changed = True\n                opcode.offset = ip\n            opcode_overflow, encoded_opcode = mp_opcode_encode(opcode)\n            if opcode_overflow:\n                overflow = True\n            bytecode_out += encoded_opcode\n\n    if overflow:\n        raise Exception(\"bytecode overflow\")\n\n    return bytecode_out\n\n\ndef rewrite_raw_code(rc, qstr_table_base, obj_table_base):\n    if rc.code_kind != MP_CODE_BYTECODE:\n        raise Exception(\"can only rewrite bytecode\")\n\n    source_info = bytearray()\n    for arg in rc.names:\n        source_info.extend(mp_encode_uint(qstr_table_base + arg))\n\n    closure_info = rc.fun_data[rc.offset_closure_info : rc.offset_opcodes]\n\n    bytecode_in = memoryview(rc.fun_data)[rc.offset_opcodes :]\n    bytecode_out = adjust_bytecode_qstr_obj_indices(bytecode_in, qstr_table_base, obj_table_base)\n\n    prelude_signature = rc.fun_data[: rc.offset_prelude_size]\n    prelude_size = encode_prelude_size(len(source_info), len(closure_info))\n\n    fun_data = prelude_signature + prelude_size + source_info + closure_info + bytecode_out\n\n    output = mp_encode_uint(len(fun_data) << 3 | bool(len(rc.children)) << 2)\n    output += fun_data\n\n    if rc.children:\n        output += mp_encode_uint(len(rc.children))\n        for child in rc.children:\n            output += rewrite_raw_code(child, qstr_table_base, obj_table_base)\n\n    return output\n\n\ndef merge_mpy(compiled_modules, output_file):\n    merged_mpy = bytearray()\n\n    if len(compiled_modules) == 1:\n        with open(compiled_modules[0].mpy_source_file, \"rb\") as f:\n            merged_mpy.extend(f.read())\n    else:\n        main_cm_idx = None\n        for idx, cm in enumerate(compiled_modules):\n            feature_byte = cm.header[2]\n            mpy_native_arch = feature_byte >> 2\n            if mpy_native_arch:\n                # Must use qstr_table and obj_table from this raw_code\n                if main_cm_idx is not None:\n                    raise Exception(\"can't merge files when more than one contains native code\")\n                main_cm_idx = idx\n        if main_cm_idx is not None:\n            # Shift main_cm to front of list.\n            compiled_modules.insert(0, compiled_modules.pop(main_cm_idx))\n\n        header = bytearray(4)\n        header[0] = ord(\"M\")\n        header[1] = config.MPY_VERSION\n        header[2] = config.native_arch << 2 | config.MPY_SUB_VERSION if config.native_arch else 0\n        header[3] = config.mp_small_int_bits\n        merged_mpy.extend(header)\n\n        n_qstr = 0\n        n_obj = 0\n        for cm in compiled_modules:\n            n_qstr += len(cm.qstr_table)\n            n_obj += len(cm.obj_table)\n        merged_mpy.extend(mp_encode_uint(n_qstr))\n        merged_mpy.extend(mp_encode_uint(n_obj))\n\n        # Copy verbatim the qstr and object tables from all compiled modules.\n        def copy_section(file, offset, offset2):\n            with open(file, \"rb\") as f:\n                f.seek(offset)\n                merged_mpy.extend(f.read(offset2 - offset))\n\n        for cm in compiled_modules:\n            copy_section(cm.mpy_source_file, cm.qstr_table_file_offset, cm.obj_table_file_offset)\n        for cm in compiled_modules:\n            copy_section(cm.mpy_source_file, cm.obj_table_file_offset, cm.raw_code_file_offset)\n\n        bytecode = bytearray()\n        bytecode.append(0b00000000)  # prelude signature\n        bytecode.append(0b00000010)  # prelude size (n_info=1, n_cell=0)\n        bytecode.extend(b\"\\x00\")  # simple_name: qstr index 0 (will use source filename)\n        for idx in range(len(compiled_modules)):\n            bytecode.append(Opcode.MP_BC_MAKE_FUNCTION)\n            bytecode.extend(mp_encode_uint(idx))  # index of raw code\n            bytecode.append(Opcode.MP_BC_CALL_FUNCTION)\n            bytecode.append(0)  # 0 arguments\n            bytecode.append(Opcode.MP_BC_POP_TOP)\n        bytecode.append(Opcode.MP_BC_LOAD_CONST_NONE)\n        bytecode.append(Opcode.MP_BC_RETURN_VALUE)\n\n        merged_mpy.extend(mp_encode_uint(len(bytecode) << 3 | 1 << 2))  # length, has_children\n        merged_mpy.extend(bytecode)\n        merged_mpy.extend(mp_encode_uint(len(compiled_modules)))  # n_children\n\n        qstr_table_base = 0\n        obj_table_base = 0\n        for cm in compiled_modules:\n            if qstr_table_base == 0 and obj_table_base == 0:\n                with open(cm.mpy_source_file, \"rb\") as f:\n                    f.seek(cm.raw_code_file_offset)\n                    merged_mpy.extend(f.read())\n            else:\n                merged_mpy.extend(rewrite_raw_code(cm.raw_code, qstr_table_base, obj_table_base))\n            qstr_table_base += len(cm.qstr_table)\n            obj_table_base += len(cm.obj_table)\n\n    if output_file is None:\n        sys.stdout.buffer.write(merged_mpy)\n    else:\n        with open(output_file, \"wb\") as f:\n            f.write(merged_mpy)\n\n\ndef main():\n    global global_qstrs\n\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"A tool to work with MicroPython .mpy files.\")\n    cmd_parser.add_argument(\n        \"-x\", \"--hexdump\", action=\"store_true\", help=\"output an annotated hex dump of files\"\n    )\n    cmd_parser.add_argument(\n        \"-d\", \"--disassemble\", action=\"store_true\", help=\"output disassembled contents of files\"\n    )\n    cmd_parser.add_argument(\"-f\", \"--freeze\", action=\"store_true\", help=\"freeze files\")\n    cmd_parser.add_argument(\n        \"--merge\", action=\"store_true\", help=\"merge multiple .mpy files into one\"\n    )\n    cmd_parser.add_argument(\"-q\", \"--qstr-header\", help=\"qstr header file to freeze against\")\n    cmd_parser.add_argument(\n        \"-mlongint-impl\",\n        choices=[\"none\", \"longlong\", \"mpz\"],\n        default=\"mpz\",\n        help=\"long-int implementation used by target (default mpz)\",\n    )\n    cmd_parser.add_argument(\n        \"-mmpz-dig-size\",\n        metavar=\"N\",\n        type=int,\n        default=16,\n        help=\"mpz digit size used by target (default 16)\",\n    )\n    cmd_parser.add_argument(\"-o\", \"--output\", default=None, help=\"output file\")\n    cmd_parser.add_argument(\"files\", nargs=\"+\", help=\"input .mpy files\")\n    args = cmd_parser.parse_args()\n\n    # set config values relevant to target machine\n    config.MICROPY_LONGINT_IMPL = {\n        \"none\": config.MICROPY_LONGINT_IMPL_NONE,\n        \"longlong\": config.MICROPY_LONGINT_IMPL_LONGLONG,\n        \"mpz\": config.MICROPY_LONGINT_IMPL_MPZ,\n    }[args.mlongint_impl]\n    config.MPZ_DIG_SIZE = args.mmpz_dig_size\n    config.native_arch = MP_NATIVE_ARCH_NONE\n\n    # set config values for qstrs, and get the existing base set of qstrs\n    # already in the firmware\n    if args.qstr_header:\n        qcfgs, extra_qstrs = qstrutil.parse_input_headers([args.qstr_header])\n        firmware_qstr_idents = set(qstrutil.static_qstr_list_ident) | set(extra_qstrs.keys())\n        config.MICROPY_QSTR_BYTES_IN_LEN = int(qcfgs[\"BYTES_IN_LEN\"])\n        config.MICROPY_QSTR_BYTES_IN_HASH = int(qcfgs[\"BYTES_IN_HASH\"])\n    else:\n        config.MICROPY_QSTR_BYTES_IN_LEN = 1\n        config.MICROPY_QSTR_BYTES_IN_HASH = 1\n        firmware_qstr_idents = set(qstrutil.static_qstr_list_ident)\n\n    # Create initial list of global qstrs.\n    global_qstrs = GlobalQStrList()\n\n    # Load all .mpy files.\n    try:\n        compiled_modules = [read_mpy(file) for file in args.files]\n    except MPYReadError as er:\n        print(er, file=sys.stderr)\n        sys.exit(1)\n\n    if args.hexdump:\n        hexdump_mpy(compiled_modules)\n\n    if args.disassemble:\n        if args.hexdump:\n            print()\n        disassemble_mpy(compiled_modules)\n\n    if args.freeze:\n        try:\n            freeze_mpy(firmware_qstr_idents, compiled_modules)\n        except FreezeError as er:\n            print(er, file=sys.stderr)\n            sys.exit(1)\n\n    if args.merge:\n        merge_mpy(compiled_modules, args.output)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}