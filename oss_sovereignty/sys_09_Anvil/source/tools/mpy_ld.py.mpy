{
  "module_name": "mpy_ld.py",
  "hash_id": "18216499c7cf8c28db41be9748d984153a805b3d31dd17cbcd2b976a3df8be1e",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpy_ld.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2019 Damien P. George\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\"\"\"\nLink .o files to .mpy\n\"\"\"\n\nimport sys, os, struct, re\nfrom elftools.elf import elffile\n\nsys.path.append(os.path.dirname(__file__) + \"/../py\")\nimport makeqstrdata as qstrutil\n\n# MicroPython constants\nMPY_VERSION = 6\nMPY_SUB_VERSION = 3\nMP_CODE_BYTECODE = 2\nMP_CODE_NATIVE_VIPER = 4\nMP_NATIVE_ARCH_X86 = 1\nMP_NATIVE_ARCH_X64 = 2\nMP_NATIVE_ARCH_ARMV6M = 4\nMP_NATIVE_ARCH_ARMV7M = 5\nMP_NATIVE_ARCH_ARMV7EMSP = 7\nMP_NATIVE_ARCH_ARMV7EMDP = 8\nMP_NATIVE_ARCH_XTENSA = 9\nMP_NATIVE_ARCH_XTENSAWIN = 10\nMP_PERSISTENT_OBJ_STR = 5\nMP_SCOPE_FLAG_VIPERRELOC = 0x10\nMP_SCOPE_FLAG_VIPERRODATA = 0x20\nMP_SCOPE_FLAG_VIPERBSS = 0x40\nMP_SMALL_INT_BITS = 31\nMP_FUN_TABLE_MP_TYPE_TYPE_OFFSET = 73\n\n# ELF constants\nR_386_32 = 1\nR_X86_64_64 = 1\nR_XTENSA_32 = 1\nR_386_PC32 = 2\nR_X86_64_PC32 = 2\nR_ARM_ABS32 = 2\nR_386_GOT32 = 3\nR_ARM_REL32 = 3\nR_386_PLT32 = 4\nR_X86_64_PLT32 = 4\nR_XTENSA_PLT = 6\nR_386_GOTOFF = 9\nR_386_GOTPC = 10\nR_ARM_THM_CALL = 10\nR_XTENSA_DIFF32 = 19\nR_XTENSA_SLOT0_OP = 20\nR_ARM_BASE_PREL = 25  # aka R_ARM_GOTPC\nR_ARM_GOT_BREL = 26  # aka R_ARM_GOT32\nR_ARM_THM_JUMP24 = 30\nR_X86_64_GOTPCREL = 9\nR_X86_64_REX_GOTPCRELX = 42\nR_386_GOT32X = 43\nR_XTENSA_PDIFF32 = 59\n\n################################################################################\n# Architecture configuration\n\n\ndef asm_jump_x86(entry):\n    return struct.pack(\"<BI\", 0xE9, entry - 5)\n\n\ndef asm_jump_thumb(entry):\n    # Only signed values that fit in 12 bits are supported\n    b_off = entry - 4\n    assert b_off >> 11 == 0 or b_off >> 11 == -1, b_off\n    return struct.pack(\"<H\", 0xE000 | (b_off >> 1 & 0x07FF))\n\n\ndef asm_jump_thumb2(entry):\n    b_off = entry - 4\n    if b_off >> 11 == 0 or b_off >> 11 == -1:\n        # Signed value fits in 12 bits\n        b0 = 0xE000 | (b_off >> 1 & 0x07FF)\n        b1 = 0\n    else:\n        # Use large jump\n        b0 = 0xF000 | (b_off >> 12 & 0x07FF)\n        b1 = 0xB800 | (b_off >> 1 & 0x7FF)\n    return struct.pack(\"<HH\", b0, b1)\n\n\ndef asm_jump_xtensa(entry):\n    jump_offset = entry - 4\n    jump_op = jump_offset << 6 | 6\n    return struct.pack(\"<BH\", jump_op & 0xFF, jump_op >> 8)\n\n\nclass ArchData:\n    def __init__(self, name, mpy_feature, word_size, arch_got, asm_jump, *, separate_rodata=False):\n        self.name = name\n        self.mpy_feature = mpy_feature\n        self.qstr_entry_size = 2\n        self.word_size = word_size\n        self.arch_got = arch_got\n        self.asm_jump = asm_jump\n        self.separate_rodata = separate_rodata\n\n\nARCH_DATA = {\n    \"x86\": ArchData(\n        \"EM_386\",\n        MP_NATIVE_ARCH_X86 << 2,\n        4,\n        (R_386_PC32, R_386_GOT32, R_386_GOT32X),\n        asm_jump_x86,\n    ),\n    \"x64\": ArchData(\n        \"EM_X86_64\",\n        MP_NATIVE_ARCH_X64 << 2,\n        8,\n        (R_X86_64_GOTPCREL, R_X86_64_REX_GOTPCRELX),\n        asm_jump_x86,\n    ),\n    \"armv6m\": ArchData(\n        \"EM_ARM\",\n        MP_NATIVE_ARCH_ARMV6M << 2,\n        4,\n        (R_ARM_GOT_BREL,),\n        asm_jump_thumb,\n    ),\n    \"armv7m\": ArchData(\n        \"EM_ARM\",\n        MP_NATIVE_ARCH_ARMV7M << 2,\n        4,\n        (R_ARM_GOT_BREL,),\n        asm_jump_thumb2,\n    ),\n    \"armv7emsp\": ArchData(\n        \"EM_ARM\",\n        MP_NATIVE_ARCH_ARMV7EMSP << 2,\n        4,\n        (R_ARM_GOT_BREL,),\n        asm_jump_thumb2,\n    ),\n    \"armv7emdp\": ArchData(\n        \"EM_ARM\",\n        MP_NATIVE_ARCH_ARMV7EMDP << 2,\n        4,\n        (R_ARM_GOT_BREL,),\n        asm_jump_thumb2,\n    ),\n    \"xtensa\": ArchData(\n        \"EM_XTENSA\",\n        MP_NATIVE_ARCH_XTENSA << 2,\n        4,\n        (R_XTENSA_32, R_XTENSA_PLT),\n        asm_jump_xtensa,\n    ),\n    \"xtensawin\": ArchData(\n        \"EM_XTENSA\",\n        MP_NATIVE_ARCH_XTENSAWIN << 2,\n        4,\n        (R_XTENSA_32, R_XTENSA_PLT),\n        asm_jump_xtensa,\n        separate_rodata=True,\n    ),\n}\n\n################################################################################\n# Helper functions\n\n\ndef align_to(value, align):\n    return (value + align - 1) & ~(align - 1)\n\n\ndef unpack_u24le(data, offset):\n    return data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16\n\n\ndef pack_u24le(data, offset, value):\n    data[offset] = value & 0xFF\n    data[offset + 1] = value >> 8 & 0xFF\n    data[offset + 2] = value >> 16 & 0xFF\n\n\ndef xxd(text):\n    for i in range(0, len(text), 16):\n        print(\"{:08x}:\".format(i), end=\"\")\n        for j in range(4):\n            off = i + j * 4\n            if off < len(text):\n                d = int.from_bytes(text[off : off + 4], \"little\")\n                print(\" {:08x}\".format(d), end=\"\")\n        print()\n\n\n# Smaller numbers are enabled first\nLOG_LEVEL_1 = 1\nLOG_LEVEL_2 = 2\nLOG_LEVEL_3 = 3\nlog_level = LOG_LEVEL_1\n\n\ndef log(level, msg):\n    if level <= log_level:\n        print(msg)\n\n\n################################################################################\n# Qstr extraction\n\n\ndef extract_qstrs(source_files):\n    def read_qstrs(f):\n        with open(f) as f:\n            vals = set()\n            for line in f:\n                for m in re.finditer(r\"MP_QSTR_[A-Za-z0-9_]*\", line):\n                    vals.add(m.group())\n            return vals\n\n    static_qstrs = [\"MP_QSTR_\" + qstrutil.qstr_escape(q) for q in qstrutil.static_qstr_list]\n\n    qstr_vals = set()\n    for f in source_files:\n        vals = read_qstrs(f)\n        qstr_vals.update(vals)\n    qstr_vals.difference_update(static_qstrs)\n\n    return static_qstrs, qstr_vals\n\n\n################################################################################\n# Linker\n\n\nclass LinkError(Exception):\n    pass\n\n\nclass Section:\n    def __init__(self, name, data, alignment, filename=None):\n        self.filename = filename\n        self.name = name\n        self.data = data\n        self.alignment = alignment\n        self.addr = 0\n        self.reloc = []\n\n    @staticmethod\n    def from_elfsec(elfsec, filename):\n        assert elfsec.header.sh_addr == 0\n        return Section(elfsec.name, elfsec.data(), elfsec.data_alignment, filename)\n\n\nclass GOTEntry:\n    def __init__(self, name, sym, link_addr=0):\n        self.name = name\n        self.sym = sym\n        self.offset = None\n        self.link_addr = link_addr\n\n    def isexternal(self):\n        return self.sec_name.startswith(\".external\")\n\n    def istext(self):\n        return self.sec_name.startswith(\".text\")\n\n    def isrodata(self):\n        return self.sec_name.startswith((\".rodata\", \".data.rel.ro\"))\n\n    def isbss(self):\n        return self.sec_name.startswith(\".bss\")\n\n\nclass LiteralEntry:\n    def __init__(self, value, offset):\n        self.value = value\n        self.offset = offset\n\n\nclass LinkEnv:\n    def __init__(self, arch):\n        self.arch = ARCH_DATA[arch]\n        self.sections = []  # list of sections in order of output\n        self.literal_sections = []  # list of literal sections (xtensa only)\n        self.known_syms = {}  # dict of symbols that are defined\n        self.unresolved_syms = []  # list of unresolved symbols\n        self.mpy_relocs = []  # list of relocations needed in the output .mpy file\n\n    def check_arch(self, arch_name):\n        if arch_name != self.arch.name:\n            raise LinkError(\"incompatible arch\")\n\n    def print_sections(self):\n        log(LOG_LEVEL_2, \"sections:\")\n        for sec in self.sections:\n            log(LOG_LEVEL_2, \"  {:08x} {} size={}\".format(sec.addr, sec.name, len(sec.data)))\n\n    def find_addr(self, name):\n        if name in self.known_syms:\n            s = self.known_syms[name]\n            return s.section.addr + s[\"st_value\"]\n        raise LinkError(\"unknown symbol: {}\".format(name))\n\n\ndef build_got_generic(env):\n    env.got_entries = {}\n    for sec in env.sections:\n        for r in sec.reloc:\n            s = r.sym\n            if not (\n                s.entry[\"st_info\"][\"bind\"] == \"STB_GLOBAL\"\n                and r[\"r_info_type\"] in env.arch.arch_got\n            ):\n                continue\n            s_type = s.entry[\"st_info\"][\"type\"]\n            assert s_type in (\"STT_NOTYPE\", \"STT_FUNC\", \"STT_OBJECT\"), s_type\n            assert s.name\n            if s.name in env.got_entries:\n                continue\n            env.got_entries[s.name] = GOTEntry(s.name, s)\n\n\ndef build_got_xtensa(env):\n    env.got_entries = {}\n    env.lit_entries = {}\n    env.xt_literals = {}\n\n    # Extract the values from the literal table\n    for sec in env.literal_sections:\n        assert len(sec.data) % env.arch.word_size == 0\n\n        # Look through literal relocations to find any global pointers that should be GOT entries\n        for r in sec.reloc:\n            s = r.sym\n            s_type = s.entry[\"st_info\"][\"type\"]\n            assert s_type in (\"STT_NOTYPE\", \"STT_FUNC\", \"STT_OBJECT\", \"STT_SECTION\"), s_type\n            assert r[\"r_info_type\"] in env.arch.arch_got\n            assert r[\"r_offset\"] % env.arch.word_size == 0\n            # This entry is a global pointer\n            existing = struct.unpack_from(\"<I\", sec.data, r[\"r_offset\"])[0]\n            if s_type == \"STT_SECTION\":\n                assert r[\"r_addend\"] == 0\n                name = \"{}+0x{:x}\".format(s.section.name, existing)\n            else:\n                assert existing == 0\n                name = s.name\n                if r[\"r_addend\"] != 0:\n                    name = \"{}+0x{:x}\".format(name, r[\"r_addend\"])\n            idx = \"{}+0x{:x}\".format(sec.filename, r[\"r_offset\"])\n            env.xt_literals[idx] = name\n            if name in env.got_entries:\n                # Deduplicate GOT entries\n                continue\n            env.got_entries[name] = GOTEntry(name, s, existing)\n\n        # Go through all literal entries finding those that aren't global pointers so must be actual literals\n        for i in range(0, len(sec.data), env.arch.word_size):\n            idx = \"{}+0x{:x}\".format(sec.filename, i)\n            if idx not in env.xt_literals:\n                # This entry is an actual literal\n                value = struct.unpack_from(\"<I\", sec.data, i)[0]\n                env.xt_literals[idx] = value\n                if value in env.lit_entries:\n                    # Deduplicate literals\n                    continue\n                env.lit_entries[value] = LiteralEntry(\n                    value, len(env.lit_entries) * env.arch.word_size\n                )\n\n\ndef populate_got(env):\n    # Compute GOT destination addresses\n    for got_entry in env.got_entries.values():\n        sym = got_entry.sym\n        if hasattr(sym, \"resolved\"):\n            sym = sym.resolved\n        sec = sym.section\n        addr = sym[\"st_value\"]\n        got_entry.sec_name = sec.name\n        got_entry.link_addr += sec.addr + addr\n\n    # Get sorted GOT, sorted by external, text, rodata, bss so relocations can be combined\n    got_list = sorted(\n        env.got_entries.values(),\n        key=lambda g: g.isexternal() + 2 * g.istext() + 3 * g.isrodata() + 4 * g.isbss(),\n    )\n\n    # Layout and populate the GOT\n    offset = 0\n    for got_entry in got_list:\n        got_entry.offset = offset\n        offset += env.arch.word_size\n        o = env.got_section.addr + got_entry.offset\n        env.full_text[o : o + env.arch.word_size] = got_entry.link_addr.to_bytes(\n            env.arch.word_size, \"little\"\n        )\n\n    # Create a relocation for each GOT entry\n    for got_entry in got_list:\n        if got_entry.name in (\"mp_native_qstr_table\", \"mp_native_obj_table\", \"mp_fun_table\"):\n            dest = got_entry.name\n        elif got_entry.name.startswith(\"mp_fun_table+0x\"):\n            dest = int(got_entry.name.split(\"+\")[1], 16) // env.arch.word_size\n        elif got_entry.sec_name == \".external.mp_fun_table\":\n            dest = got_entry.sym.mp_fun_table_offset\n        elif got_entry.sec_name.startswith(\".text\"):\n            dest = \".text\"\n        elif got_entry.sec_name.startswith(\".rodata\"):\n            dest = \".rodata\"\n        elif got_entry.sec_name.startswith(\".data.rel.ro\"):\n            dest = \".data.rel.ro\"\n        elif got_entry.sec_name.startswith(\".bss\"):\n            dest = \".bss\"\n        else:\n            assert 0, (got_entry.name, got_entry.sec_name)\n        env.mpy_relocs.append((\".text\", env.got_section.addr + got_entry.offset, dest))\n\n    # Print out the final GOT\n    log(LOG_LEVEL_2, \"GOT: {:08x}\".format(env.got_section.addr))\n    for g in got_list:\n        log(\n            LOG_LEVEL_2,\n            \"  {:08x} {} -> {}+{:08x}\".format(g.offset, g.name, g.sec_name, g.link_addr),\n        )\n\n\ndef populate_lit(env):\n    log(LOG_LEVEL_2, \"LIT: {:08x}\".format(env.lit_section.addr))\n    for lit_entry in env.lit_entries.values():\n        value = lit_entry.value\n        log(LOG_LEVEL_2, \"  {:08x} = {:08x}\".format(lit_entry.offset, value))\n        o = env.lit_section.addr + lit_entry.offset\n        env.full_text[o : o + env.arch.word_size] = value.to_bytes(env.arch.word_size, \"little\")\n\n\ndef do_relocation_text(env, text_addr, r):\n    # Extract relevant info about symbol that's being relocated\n    s = r.sym\n    s_bind = s.entry[\"st_info\"][\"bind\"]\n    s_type = s.entry[\"st_info\"][\"type\"]\n    r_offset = r[\"r_offset\"] + text_addr\n    r_info_type = r[\"r_info_type\"]\n    try:\n        # only for RELA sections\n        r_addend = r[\"r_addend\"]\n    except KeyError:\n        r_addend = 0\n\n    # Default relocation type and name for logging\n    reloc_type = \"le32\"\n    log_name = None\n\n    if (\n        env.arch.name == \"EM_386\"\n        and r_info_type in (R_386_PC32, R_386_PLT32)\n        or env.arch.name == \"EM_X86_64\"\n        and r_info_type in (R_X86_64_PC32, R_X86_64_PLT32)\n        or env.arch.name == \"EM_ARM\"\n        and r_info_type in (R_ARM_REL32, R_ARM_THM_CALL, R_ARM_THM_JUMP24)\n        or s_bind == \"STB_LOCAL\"\n        and env.arch.name == \"EM_XTENSA\"\n        and r_info_type == R_XTENSA_32  # not GOT\n    ):\n        # Standard relocation to fixed location within text/rodata\n        if hasattr(s, \"resolved\"):\n            s = s.resolved\n\n        sec = s.section\n\n        if env.arch.separate_rodata and sec.name.startswith(\".rodata\"):\n            raise LinkError(\"fixed relocation to rodata with rodata referenced via GOT\")\n\n        if sec.name.startswith(\".bss\"):\n            raise LinkError(\n                \"{}: fixed relocation to bss (bss variables can't be static)\".format(s.filename)\n            )\n\n        if sec.name.startswith(\".external\"):\n            raise LinkError(\n                \"{}: fixed relocation to external symbol: {}\".format(s.filename, s.name)\n            )\n\n        addr = sec.addr + s[\"st_value\"]\n        reloc = addr - r_offset + r_addend\n\n        if r_info_type in (R_ARM_THM_CALL, R_ARM_THM_JUMP24):\n            # Both relocations have the same bit pattern to rewrite:\n            #   R_ARM_THM_CALL: bl\n            #   R_ARM_THM_JUMP24: b.w\n            reloc_type = \"thumb_b\"\n\n    elif (\n        env.arch.name == \"EM_386\"\n        and r_info_type == R_386_GOTPC\n        or env.arch.name == \"EM_ARM\"\n        and r_info_type == R_ARM_BASE_PREL\n    ):\n        # Relocation to GOT address itself\n        assert s.name == \"_GLOBAL_OFFSET_TABLE_\"\n        addr = env.got_section.addr\n        reloc = addr - r_offset + r_addend\n\n    elif (\n        env.arch.name == \"EM_386\"\n        and r_info_type in (R_386_GOT32, R_386_GOT32X)\n        or env.arch.name == \"EM_ARM\"\n        and r_info_type == R_ARM_GOT_BREL\n    ):\n        # Relcation pointing to GOT\n        reloc = addr = env.got_entries[s.name].offset\n\n    elif env.arch.name == \"EM_X86_64\" and r_info_type in (\n        R_X86_64_GOTPCREL,\n        R_X86_64_REX_GOTPCRELX,\n    ):\n        # Relcation pointing to GOT\n        got_entry = env.got_entries[s.name]\n        addr = env.got_section.addr + got_entry.offset\n        reloc = addr - r_offset + r_addend\n\n    elif env.arch.name == \"EM_386\" and r_info_type == R_386_GOTOFF:\n        # Relocation relative to GOT\n        addr = s.section.addr + s[\"st_value\"]\n        reloc = addr - env.got_section.addr + r_addend\n\n    elif env.arch.name == \"EM_XTENSA\" and r_info_type == R_XTENSA_SLOT0_OP:\n        # Relocation pointing to GOT, xtensa specific\n        sec = s.section\n        if sec.name.startswith(\".text\"):\n            # it looks like R_XTENSA_SLOT0_OP into .text is already correctly relocated\n            return\n        assert sec.name.startswith(\".literal\"), sec.name\n        lit_idx = \"{}+0x{:x}\".format(sec.filename, r_addend)\n        lit_ptr = env.xt_literals[lit_idx]\n        if isinstance(lit_ptr, str):\n            addr = env.got_section.addr + env.got_entries[lit_ptr].offset\n            log_name = \"GOT {}\".format(lit_ptr)\n        else:\n            addr = env.lit_section.addr + env.lit_entries[lit_ptr].offset\n            log_name = \"LIT\"\n        reloc = addr - r_offset\n        reloc_type = \"xtensa_l32r\"\n\n    elif env.arch.name == \"EM_XTENSA\" and r_info_type in (R_XTENSA_DIFF32, R_XTENSA_PDIFF32):\n        if s.section.name.startswith(\".text\"):\n            # it looks like R_XTENSA_[P]DIFF32 into .text is already correctly relocated\n            return\n        assert 0\n\n    else:\n        # Unknown/unsupported relocation\n        assert 0, r_info_type\n\n    # Write relocation\n    if reloc_type == \"le32\":\n        (existing,) = struct.unpack_from(\"<I\", env.full_text, r_offset)\n        struct.pack_into(\"<I\", env.full_text, r_offset, (existing + reloc) & 0xFFFFFFFF)\n    elif reloc_type == \"thumb_b\":\n        b_h, b_l = struct.unpack_from(\"<HH\", env.full_text, r_offset)\n        existing = (b_h & 0x7FF) << 12 | (b_l & 0x7FF) << 1\n        if existing >= 0x400000:  # 2's complement\n            existing -= 0x800000\n        new = existing + reloc\n        b_h = (b_h & 0xF800) | (new >> 12) & 0x7FF\n        b_l = (b_l & 0xF800) | (new >> 1) & 0x7FF\n        struct.pack_into(\"<HH\", env.full_text, r_offset, b_h, b_l)\n    elif reloc_type == \"xtensa_l32r\":\n        l32r = unpack_u24le(env.full_text, r_offset)\n        assert l32r & 0xF == 1  # RI16 encoded l32r\n        l32r_imm16 = l32r >> 8\n        l32r_imm16 = (l32r_imm16 + reloc >> 2) & 0xFFFF\n        l32r = l32r & 0xFF | l32r_imm16 << 8\n        pack_u24le(env.full_text, r_offset, l32r)\n    else:\n        assert 0, reloc_type\n\n    # Log information about relocation\n    if log_name is None:\n        if s_type == \"STT_SECTION\":\n            log_name = s.section.name\n        else:\n            log_name = s.name\n    log(LOG_LEVEL_3, \"  {:08x} {} -> {:08x}\".format(r_offset, log_name, addr))\n\n\ndef do_relocation_data(env, text_addr, r):\n    s = r.sym\n    s_type = s.entry[\"st_info\"][\"type\"]\n    r_offset = r[\"r_offset\"] + text_addr\n    r_info_type = r[\"r_info_type\"]\n    try:\n        # only for RELA sections\n        r_addend = r[\"r_addend\"]\n    except KeyError:\n        r_addend = 0\n\n    if (\n        env.arch.name == \"EM_386\"\n        and r_info_type == R_386_32\n        or env.arch.name == \"EM_X86_64\"\n        and r_info_type == R_X86_64_64\n        or env.arch.name == \"EM_ARM\"\n        and r_info_type == R_ARM_ABS32\n        or env.arch.name == \"EM_XTENSA\"\n        and r_info_type == R_XTENSA_32\n    ):\n        # Relocation in data.rel.ro to internal/external symbol\n        if env.arch.word_size == 4:\n            struct_type = \"<I\"\n        elif env.arch.word_size == 8:\n            struct_type = \"<Q\"\n        sec = s.section\n        assert r_offset % env.arch.word_size == 0\n        addr = sec.addr + s[\"st_value\"] + r_addend\n        if s_type == \"STT_SECTION\":\n            log_name = sec.name\n        else:\n            log_name = s.name\n        log(LOG_LEVEL_3, \"  {:08x} -> {} {:08x}\".format(r_offset, log_name, addr))\n        if env.arch.separate_rodata:\n            data = env.full_rodata\n        else:\n            data = env.full_text\n        (existing,) = struct.unpack_from(struct_type, data, r_offset)\n        if sec.name.startswith((\".text\", \".rodata\", \".data.rel.ro\", \".bss\")):\n            struct.pack_into(struct_type, data, r_offset, existing + addr)\n            kind = sec.name\n        elif sec.name == \".external.mp_fun_table\":\n            assert addr == 0\n            kind = s.mp_fun_table_offset\n        else:\n            assert 0, sec.name\n        if env.arch.separate_rodata:\n            base = \".rodata\"\n        else:\n            base = \".text\"\n        env.mpy_relocs.append((base, r_offset, kind))\n\n    else:\n        # Unknown/unsupported relocation\n        assert 0, r_info_type\n\n\ndef load_object_file(env, felf):\n    with open(felf, \"rb\") as f:\n        elf = elffile.ELFFile(f)\n        env.check_arch(elf[\"e_machine\"])\n\n        # Get symbol table\n        symtab = list(elf.get_section_by_name(\".symtab\").iter_symbols())\n\n        # Load needed sections from ELF file\n        sections_shndx = {}  # maps elf shndx to Section object\n        for idx, s in enumerate(elf.iter_sections()):\n            if s.header.sh_type in (\"SHT_PROGBITS\", \"SHT_NOBITS\"):\n                if s.data_size == 0:\n                    # Ignore empty sections\n                    pass\n                elif s.name.startswith((\".literal\", \".text\", \".rodata\", \".data.rel.ro\", \".bss\")):\n                    sec = Section.from_elfsec(s, felf)\n                    sections_shndx[idx] = sec\n                    if s.name.startswith(\".literal\"):\n                        env.literal_sections.append(sec)\n                    else:\n                        env.sections.append(sec)\n                elif s.name.startswith(\".data\"):\n                    raise LinkError(\"{}: {} non-empty\".format(felf, s.name))\n                else:\n                    # Ignore section\n                    pass\n            elif s.header.sh_type in (\"SHT_REL\", \"SHT_RELA\"):\n                shndx = s.header.sh_info\n                if shndx in sections_shndx:\n                    sec = sections_shndx[shndx]\n                    sec.reloc_name = s.name\n                    sec.reloc = list(s.iter_relocations())\n                    for r in sec.reloc:\n                        r.sym = symtab[r[\"r_info_sym\"]]\n\n        # Link symbols to their sections, and update known and unresolved symbols\n        for sym in symtab:\n            sym.filename = felf\n            shndx = sym.entry[\"st_shndx\"]\n            if shndx in sections_shndx:\n                # Symbol with associated section\n                sym.section = sections_shndx[shndx]\n                if sym[\"st_info\"][\"bind\"] == \"STB_GLOBAL\":\n                    # Defined global symbol\n                    if sym.name in env.known_syms and not sym.name.startswith(\n                        \"__x86.get_pc_thunk.\"\n                    ):\n                        raise LinkError(\"duplicate symbol: {}\".format(sym.name))\n                    env.known_syms[sym.name] = sym\n            elif sym.entry[\"st_shndx\"] == \"SHN_UNDEF\" and sym[\"st_info\"][\"bind\"] == \"STB_GLOBAL\":\n                # Undefined global symbol, needs resolving\n                env.unresolved_syms.append(sym)\n\n\ndef link_objects(env, native_qstr_vals_len):\n    # Build GOT information\n    if env.arch.name == \"EM_XTENSA\":\n        build_got_xtensa(env)\n    else:\n        build_got_generic(env)\n\n    # Creat GOT section\n    got_size = len(env.got_entries) * env.arch.word_size\n    env.got_section = Section(\"GOT\", bytearray(got_size), env.arch.word_size)\n    if env.arch.name == \"EM_XTENSA\":\n        env.sections.insert(0, env.got_section)\n    else:\n        env.sections.append(env.got_section)\n\n    # Create optional literal section\n    if env.arch.name == \"EM_XTENSA\":\n        lit_size = len(env.lit_entries) * env.arch.word_size\n        env.lit_section = Section(\"LIT\", bytearray(lit_size), env.arch.word_size)\n        env.sections.insert(1, env.lit_section)\n\n    # Create section to contain mp_native_qstr_table\n    env.qstr_table_section = Section(\n        \".external.qstr_table\",\n        bytearray(native_qstr_vals_len * env.arch.qstr_entry_size),\n        env.arch.qstr_entry_size,\n    )\n\n    # Create section to contain mp_native_obj_table\n    env.obj_table_section = Section(\n        \".external.obj_table\",\n        bytearray(0 * env.arch.word_size),  # currently empty\n        env.arch.word_size,\n    )\n\n    # Resolve unknown symbols\n    mp_fun_table_sec = Section(\".external.mp_fun_table\", b\"\", 0)\n    fun_table = {\n        key: MP_FUN_TABLE_MP_TYPE_TYPE_OFFSET + idx\n        for idx, key in enumerate(\n            [\n                \"mp_type_type\",\n                \"mp_type_str\",\n                \"mp_type_list\",\n                \"mp_type_dict\",\n                \"mp_type_fun_builtin_0\",\n                \"mp_type_fun_builtin_1\",\n                \"mp_type_fun_builtin_2\",\n                \"mp_type_fun_builtin_3\",\n                \"mp_type_fun_builtin_var\",\n                \"mp_type_Exception\",\n                \"mp_stream_read_obj\",\n                \"mp_stream_readinto_obj\",\n                \"mp_stream_unbuffered_readline_obj\",\n                \"mp_stream_write_obj\",\n            ]\n        )\n    }\n    for sym in env.unresolved_syms:\n        assert sym[\"st_value\"] == 0\n        if sym.name == \"_GLOBAL_OFFSET_TABLE_\":\n            pass\n        elif sym.name == \"mp_fun_table\":\n            sym.section = Section(\".external\", b\"\", 0)\n        elif sym.name == \"mp_native_qstr_table\":\n            sym.section = env.qstr_table_section\n        elif sym.name == \"mp_native_obj_table\":\n            sym.section = env.obj_table_section\n        elif sym.name in env.known_syms:\n            sym.resolved = env.known_syms[sym.name]\n        else:\n            if sym.name in fun_table:\n                sym.section = mp_fun_table_sec\n                sym.mp_fun_table_offset = fun_table[sym.name]\n            else:\n                raise LinkError(\"{}: undefined symbol: {}\".format(sym.filename, sym.name))\n\n    # Align sections, assign their addresses, and create full_text\n    env.full_text = bytearray(env.arch.asm_jump(8))  # dummy, to be filled in later\n    env.full_rodata = bytearray(0)\n    env.full_bss = bytearray(0)\n    for sec in env.sections:\n        if env.arch.separate_rodata and sec.name.startswith((\".rodata\", \".data.rel.ro\")):\n            data = env.full_rodata\n        elif sec.name.startswith(\".bss\"):\n            data = env.full_bss\n        else:\n            data = env.full_text\n        sec.addr = align_to(len(data), sec.alignment)\n        data.extend(b\"\\x00\" * (sec.addr - len(data)))\n        data.extend(sec.data)\n\n    env.print_sections()\n\n    populate_got(env)\n    if env.arch.name == \"EM_XTENSA\":\n        populate_lit(env)\n\n    # Fill in relocations\n    for sec in env.sections:\n        if not sec.reloc:\n            continue\n        log(\n            LOG_LEVEL_3,\n            \"{}: {} relocations via {}:\".format(sec.filename, sec.name, sec.reloc_name),\n        )\n        for r in sec.reloc:\n            if sec.name.startswith((\".text\", \".rodata\")):\n                do_relocation_text(env, sec.addr, r)\n            elif sec.name.startswith(\".data.rel.ro\"):\n                do_relocation_data(env, sec.addr, r)\n            else:\n                assert 0, sec.name\n\n\n################################################################################\n# .mpy output\n\n\nclass MPYOutput:\n    def open(self, fname):\n        self.f = open(fname, \"wb\")\n        self.prev_base = -1\n        self.prev_offset = -1\n\n    def close(self):\n        self.f.close()\n\n    def write_bytes(self, buf):\n        self.f.write(buf)\n\n    def write_uint(self, val):\n        b = bytearray()\n        b.insert(0, val & 0x7F)\n        val >>= 7\n        while val:\n            b.insert(0, 0x80 | (val & 0x7F))\n            val >>= 7\n        self.write_bytes(b)\n\n    def write_qstr(self, s):\n        if s in qstrutil.static_qstr_list:\n            self.write_uint((qstrutil.static_qstr_list.index(s) + 1) << 1 | 1)\n        else:\n            s = bytes(s, \"ascii\")\n            self.write_uint(len(s) << 1)\n            self.write_bytes(s)\n            self.write_bytes(b\"\\x00\")\n\n    def write_reloc(self, base, offset, dest, n):\n        need_offset = not (base == self.prev_base and offset == self.prev_offset + 1)\n        self.prev_offset = offset + n - 1\n        if dest <= 2:\n            dest = (dest << 1) | (n > 1)\n        else:\n            assert 6 <= dest <= 127\n            assert n == 1\n        dest = dest << 1 | need_offset\n        assert 0 <= dest <= 0xFE, dest\n        self.write_bytes(bytes([dest]))\n        if need_offset:\n            if base == \".text\":\n                base = 0\n            elif base == \".rodata\":\n                base = 1\n            self.write_uint(offset << 1 | base)\n        if n > 1:\n            self.write_uint(n)\n\n\ndef build_mpy(env, entry_offset, fmpy, native_qstr_vals):\n    # Write jump instruction to start of text\n    jump = env.arch.asm_jump(entry_offset)\n    env.full_text[: len(jump)] = jump\n\n    log(LOG_LEVEL_1, \"arch:         {}\".format(env.arch.name))\n    log(LOG_LEVEL_1, \"text size:    {}\".format(len(env.full_text)))\n    if len(env.full_rodata):\n        log(LOG_LEVEL_1, \"rodata size:  {}\".format(len(env.full_rodata)))\n    log(LOG_LEVEL_1, \"bss size:     {}\".format(len(env.full_bss)))\n    log(LOG_LEVEL_1, \"GOT entries:  {}\".format(len(env.got_entries)))\n\n    # xxd(env.full_text)\n\n    out = MPYOutput()\n    out.open(fmpy)\n\n    # MPY: header\n    out.write_bytes(\n        bytearray(\n            [ord(\"M\"), MPY_VERSION, env.arch.mpy_feature | MPY_SUB_VERSION, MP_SMALL_INT_BITS]\n        )\n    )\n\n    # MPY: n_qstr\n    out.write_uint(1 + len(native_qstr_vals))\n\n    # MPY: n_obj\n    out.write_uint(0)\n\n    # MPY: qstr table\n    out.write_qstr(fmpy)  # filename\n    for q in native_qstr_vals:\n        out.write_qstr(q)\n\n    # MPY: object table\n    # <empty>\n\n    # MPY: kind/len\n    out.write_uint(len(env.full_text) << 3 | (MP_CODE_NATIVE_VIPER - MP_CODE_BYTECODE))\n\n    # MPY: machine code\n    out.write_bytes(env.full_text)\n\n    # MPY: scope_flags\n    scope_flags = MP_SCOPE_FLAG_VIPERRELOC\n    if len(env.full_rodata):\n        scope_flags |= MP_SCOPE_FLAG_VIPERRODATA\n    if len(env.full_bss):\n        scope_flags |= MP_SCOPE_FLAG_VIPERBSS\n    out.write_uint(scope_flags)\n\n    # MPY: bss and/or rodata\n    if len(env.full_rodata):\n        rodata_const_table_idx = 1\n        out.write_uint(len(env.full_rodata))\n    if len(env.full_bss):\n        bss_const_table_idx = 2\n        out.write_uint(len(env.full_bss))\n    if len(env.full_rodata):\n        out.write_bytes(env.full_rodata)\n\n    # MPY: relocation information\n    # See py/persistentcode.c:mp_native_relocate for meaning of the `kind` integer values.\n    prev_kind = None\n    prev_base = None\n    prev_offset = None\n    prev_n = None\n    for base, addr, kind in env.mpy_relocs:\n        if isinstance(kind, str) and kind.startswith(\".text\"):\n            kind = 0\n        elif isinstance(kind, str) and kind.startswith((\".rodata\", \".data.rel.ro\")):\n            if env.arch.separate_rodata:\n                kind = rodata_const_table_idx\n            else:\n                kind = 0\n        elif isinstance(kind, str) and kind.startswith(\".bss\"):\n            kind = bss_const_table_idx\n        elif kind == \"mp_native_qstr_table\":\n            kind = 6\n        elif kind == \"mp_native_obj_table\":\n            kind = 7\n        elif kind == \"mp_fun_table\":\n            kind = 8\n        else:\n            kind = 9 + kind\n        assert addr % env.arch.word_size == 0, addr\n        offset = addr // env.arch.word_size\n        if kind == prev_kind and base == prev_base and offset == prev_offset + 1:\n            prev_n += 1\n            prev_offset += 1\n        else:\n            if prev_kind is not None:\n                out.write_reloc(prev_base, prev_offset - prev_n + 1, prev_kind, prev_n)\n            prev_kind = kind\n            prev_base = base\n            prev_offset = offset\n            prev_n = 1\n    if prev_kind is not None:\n        out.write_reloc(prev_base, prev_offset - prev_n + 1, prev_kind, prev_n)\n\n    # MPY: sentinel for end of relocations\n    out.write_bytes(b\"\\xff\")\n\n    out.close()\n\n\n################################################################################\n# main\n\n\ndef do_preprocess(args):\n    if args.output is None:\n        assert args.files[0].endswith(\".c\")\n        args.output = args.files[0][:-1] + \"config.h\"\n    static_qstrs, qstr_vals = extract_qstrs(args.files)\n    with open(args.output, \"w\") as f:\n        print(\n            \"#include <stdint.h>\\n\"\n            \"typedef uintptr_t mp_uint_t;\\n\"\n            \"typedef intptr_t mp_int_t;\\n\"\n            \"typedef uintptr_t mp_off_t;\",\n            file=f,\n        )\n        for i, q in enumerate(static_qstrs):\n            print(\"#define %s (%u)\" % (q, i + 1), file=f)\n        for i, q in enumerate(sorted(qstr_vals)):\n            print(\"#define %s (mp_native_qstr_table[%d])\" % (q, i + 1), file=f)\n        print(\"extern const uint16_t mp_native_qstr_table[];\", file=f)\n        print(\"extern const mp_uint_t mp_native_obj_table[];\", file=f)\n\n\ndef do_link(args):\n    if args.output is None:\n        assert args.files[0].endswith(\".o\")\n        args.output = args.files[0][:-1] + \"mpy\"\n    native_qstr_vals = []\n    if args.qstrs is not None:\n        with open(args.qstrs) as f:\n            for l in f:\n                m = re.match(r\"#define MP_QSTR_([A-Za-z0-9_]*) \\(mp_native_\", l)\n                if m:\n                    native_qstr_vals.append(m.group(1))\n    log(LOG_LEVEL_2, \"qstr vals: \" + \", \".join(native_qstr_vals))\n    env = LinkEnv(args.arch)\n    try:\n        for file in args.files:\n            load_object_file(env, file)\n        link_objects(env, len(native_qstr_vals))\n        build_mpy(env, env.find_addr(\"mpy_init\"), args.output, native_qstr_vals)\n    except LinkError as er:\n        print(\"LinkError:\", er.args[0])\n        sys.exit(1)\n\n\ndef main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"Run scripts on the pyboard.\")\n    cmd_parser.add_argument(\n        \"--verbose\", \"-v\", action=\"count\", default=1, help=\"increase verbosity\"\n    )\n    cmd_parser.add_argument(\"--arch\", default=\"x64\", help=\"architecture\")\n    cmd_parser.add_argument(\"--preprocess\", action=\"store_true\", help=\"preprocess source files\")\n    cmd_parser.add_argument(\"--qstrs\", default=None, help=\"file defining additional qstrs\")\n    cmd_parser.add_argument(\n        \"--output\", \"-o\", default=None, help=\"output .mpy file (default to input with .o->.mpy)\"\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"+\", help=\"input files\")\n    args = cmd_parser.parse_args()\n\n    global log_level\n    log_level = args.verbose\n\n    if args.preprocess:\n        do_preprocess(args)\n    else:\n        do_link(args)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}