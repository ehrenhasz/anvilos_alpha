{
  "module_name": "hci_trace_to_pcap.py",
  "hash_id": "e3566e53170c62915149e1d91ff2afaf4f962552edc47b998df4a6e67c1c9e3d",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/hci_trace_to_pcap.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2023 Jim Mussared\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n# Simple script to take the output printed when HCI_TRACE is enabled in\n# unix/mpbthciport.c, extmod/btstack/btstack_hci_uart.c,\n# extmod/nimble/hal/hal_uart.c and turn it into a .pcap file suitable for use\n# with Wireshark.\n\nimport re\nimport sys\nimport struct\n\n# pcap file header:\n# typedef struct pcap_hdr_s {\n#     guint32 magic_number;   /* magic number */\n#     guint16 version_major;  /* major version number */\n#     guint16 version_minor;  /* minor version number */\n#     gint32  thiszone;       /* GMT to local correction */\n#     guint32 sigfigs;        /* accuracy of timestamps */\n#     guint32 snaplen;        /* max length of captured packets, in octets */\n#     guint32 network;        /* data link type */\n# } pcap_hdr_t;\n\n# pcap record header\n# typedef struct pcaprec_hdr_s {\n#     guint32 ts_sec;         /* timestamp seconds */\n#     guint32 ts_usec;        /* timestamp microseconds */\n#     guint32 incl_len;       /* number of octets of packet saved in file */\n#     guint32 orig_len;       /* actual length of packet */\n# } pcaprec_hdr_t;\n\n_LINKTYPE_BLUETOOTH_HCI_H4_WITH_PHDR = 201  # \"!I\" direction, followed by data\nsys.stdout.buffer.write(\n    struct.pack(\"!IHHiIII\", 0xA1B2C3D4, 2, 4, 0, 0, 65535, _LINKTYPE_BLUETOOTH_HCI_H4_WITH_PHDR)\n)\n\n_DIR_CONTROLLER_TO_HOST = 1\n_DIR_HOST_TO_CONTROLLER = 0\n\nreassemble_timestamp = 0\nreassemble_packet = bytearray()\n\nwith open(sys.argv[1], \"r\") as f:\n    for line in f:\n        line = line.strip()\n        m = re.match(\"([<>]) \\\\[ *([0-9]+)\\\\] ([A-Fa-f0-9:]+)\", line)\n        if not m:\n            continue\n\n        timestamp = int(m.group(2))\n        data = bytes.fromhex(m.group(3).replace(\":\", \"\"))\n\n        if m.group(1) == \"<\":\n            # Host to controller.\n            # These are always complete.\n            sys.stdout.buffer.write(\n                struct.pack(\n                    \"!IIIII\",\n                    timestamp // 1000,\n                    timestamp % 1000 * 1000,\n                    len(data) + 4,\n                    len(data) + 4,\n                    _DIR_HOST_TO_CONTROLLER,\n                )\n            )\n            sys.stdout.buffer.write(data)\n        if m.group(1) == \">\":\n            # Controller to host.\n            # Several of the sources print byte-at-a-time so need to reconstruct packets.\n\n            if not reassemble_packet:\n                # Use the timestamp of the first fragment.\n                reassemble_timestamp = timestamp\n\n            reassemble_packet.extend(data)\n\n            if len(reassemble_packet) > 4:\n                plen = 0\n                if reassemble_packet[0] == 1:\n                    # command\n                    plen = 3 + reassemble_packet[3]\n                elif reassemble_packet[0] == 2:\n                    # acl\n                    plen = 5 + reassemble_packet[3] + (reassemble_packet[4] << 8)\n                elif reassemble_packet[0] == 4:\n                    # event\n                    plen = 3 + reassemble_packet[2]\n\n                if len(reassemble_packet) >= plen:\n                    # Got a complete packet.\n                    data = reassemble_packet[0:plen]\n                    reassemble_packet = reassemble_packet[plen:]\n                    reassemble_timestamp = timestamp\n                    sys.stdout.buffer.write(\n                        struct.pack(\n                            \"!IIIII\",\n                            reassemble_timestamp // 1000,\n                            reassemble_timestamp % 1000 * 1000,\n                            len(data) + 4,\n                            len(data) + 4,\n                            _DIR_CONTROLLER_TO_HOST,\n                        )\n                    )\n                    sys.stdout.buffer.write(data)\n\nif reassemble_packet:\n    print(\n        \"Error: Unknown byte in HCI stream. Remainder:\",\n        reassemble_packet.hex(\":\"),\n        file=sys.stderr,\n    )\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}