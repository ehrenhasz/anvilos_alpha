{
  "module_name": "uf2conv.py",
  "hash_id": "8f47fcd14415cdba7790c450ab8694f19bd294a51d1264110a2c617ffa6d2c6c",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/uf2conv.py",
  "human_readable_source": "#!/usr/bin/env python3\n\n# Microsoft UF2\n#\n# The MIT License (MIT)\n#\n# Copyright (c) Microsoft Corporation\n#\n# All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport sys\nimport struct\nimport subprocess\nimport re\nimport os\nimport os.path\nimport argparse\nimport json\n\n\nUF2_MAGIC_START0 = 0x0A324655  # \"UF2\\n\"\nUF2_MAGIC_START1 = 0x9E5D5157  # Randomly selected\nUF2_MAGIC_END = 0x0AB16F30  # Ditto\n\nINFO_FILE = \"/INFO_UF2.TXT\"\n\nappstartaddr = 0x2000\nfamilyid = 0x0\n\n\ndef is_uf2(buf):\n    w = struct.unpack(\"<II\", buf[0:8])\n    return w[0] == UF2_MAGIC_START0 and w[1] == UF2_MAGIC_START1\n\n\ndef is_hex(buf):\n    try:\n        w = buf[0:30].decode(\"utf-8\")\n    except UnicodeDecodeError:\n        return False\n    if w[0] == \":\" and re.match(b\"^[:0-9a-fA-F\\r\\n]+$\", buf):\n        return True\n    return False\n\n\ndef convert_from_uf2(buf):\n    global appstartaddr\n    global familyid\n    numblocks = len(buf) // 512\n    curraddr = None\n    currfamilyid = None\n    families_found = {}\n    prev_flag = None\n    all_flags_same = True\n    outp = []\n    for blockno in range(numblocks):\n        ptr = blockno * 512\n        block = buf[ptr : ptr + 512]\n        hd = struct.unpack(b\"<IIIIIIII\", block[0:32])\n        if hd[0] != UF2_MAGIC_START0 or hd[1] != UF2_MAGIC_START1:\n            print(\"Skipping block at \" + ptr + \"; bad magic\")\n            continue\n        if hd[2] & 1:\n            # NO-flash flag set; skip block\n            continue\n        datalen = hd[4]\n        if datalen > 476:\n            assert False, \"Invalid UF2 data size at \" + ptr\n        newaddr = hd[3]\n        if (hd[2] & 0x2000) and (currfamilyid is None):\n            currfamilyid = hd[7]\n        if curraddr is None or ((hd[2] & 0x2000) and hd[7] != currfamilyid):\n            currfamilyid = hd[7]\n            curraddr = newaddr\n            if familyid == 0x0 or familyid == hd[7]:\n                appstartaddr = newaddr\n        padding = newaddr - curraddr\n        if padding < 0:\n            assert False, \"Block out of order at \" + ptr\n        if padding > 10 * 1024 * 1024:\n            assert False, \"More than 10M of padding needed at \" + ptr\n        if padding % 4 != 0:\n            assert False, \"Non-word padding size at \" + ptr\n        while padding > 0:\n            padding -= 4\n            outp += b\"\\x00\\x00\\x00\\x00\"\n        if familyid == 0x0 or ((hd[2] & 0x2000) and familyid == hd[7]):\n            outp.append(block[32 : 32 + datalen])\n        curraddr = newaddr + datalen\n        if hd[2] & 0x2000:\n            if hd[7] in families_found.keys():\n                if families_found[hd[7]] > newaddr:\n                    families_found[hd[7]] = newaddr\n            else:\n                families_found[hd[7]] = newaddr\n        if prev_flag is None:\n            prev_flag = hd[2]\n        if prev_flag != hd[2]:\n            all_flags_same = False\n        if blockno == (numblocks - 1):\n            print(\"--- UF2 File Header Info ---\")\n            families = load_families()\n            for family_hex in families_found.keys():\n                family_short_name = \"\"\n                for name, value in families.items():\n                    if value == family_hex:\n                        family_short_name = name\n                print(\n                    \"Family ID is {:s}, hex value is 0x{:08x}\".format(\n                        family_short_name, family_hex\n                    )\n                )\n                print(\"Target Address is 0x{:08x}\".format(families_found[family_hex]))\n            if all_flags_same:\n                print(\"All block flag values consistent, 0x{:04x}\".format(hd[2]))\n            else:\n                print(\"Flags were not all the same\")\n            print(\"----------------------------\")\n            if len(families_found) > 1 and familyid == 0x0:\n                outp = []\n                appstartaddr = 0x0\n    return b\"\".join(outp)\n\n\ndef convert_to_carray(file_content):\n    outp = \"const unsigned long bindata_len = %d;\\n\" % len(file_content)\n    outp += \"const unsigned char bindata[] __attribute__((aligned(16))) = {\"\n    for i in range(len(file_content)):\n        if i % 16 == 0:\n            outp += \"\\n\"\n        outp += \"0x%02x, \" % file_content[i]\n    outp += \"\\n};\\n\"\n    return bytes(outp, \"utf-8\")\n\n\ndef convert_to_uf2(file_content):\n    global familyid\n    datapadding = b\"\"\n    while len(datapadding) < 512 - 256 - 32 - 4:\n        datapadding += b\"\\x00\\x00\\x00\\x00\"\n    numblocks = (len(file_content) + 255) // 256\n    outp = []\n    for blockno in range(numblocks):\n        ptr = 256 * blockno\n        chunk = file_content[ptr : ptr + 256]\n        flags = 0x0\n        if familyid:\n            flags |= 0x2000\n        hd = struct.pack(\n            b\"<IIIIIIII\",\n            UF2_MAGIC_START0,\n            UF2_MAGIC_START1,\n            flags,\n            ptr + appstartaddr,\n            256,\n            blockno,\n            numblocks,\n            familyid,\n        )\n        while len(chunk) < 256:\n            chunk += b\"\\x00\"\n        block = hd + chunk + datapadding + struct.pack(b\"<I\", UF2_MAGIC_END)\n        assert len(block) == 512\n        outp.append(block)\n    return b\"\".join(outp)\n\n\nclass Block:\n    def __init__(self, addr):\n        self.addr = addr\n        self.bytes = bytearray(256)\n\n    def encode(self, blockno, numblocks):\n        global familyid\n        flags = 0x0\n        if familyid:\n            flags |= 0x2000\n        hd = struct.pack(\n            \"<IIIIIIII\",\n            UF2_MAGIC_START0,\n            UF2_MAGIC_START1,\n            flags,\n            self.addr,\n            256,\n            blockno,\n            numblocks,\n            familyid,\n        )\n        hd += self.bytes[0:256]\n        while len(hd) < 512 - 4:\n            hd += b\"\\x00\"\n        hd += struct.pack(\"<I\", UF2_MAGIC_END)\n        return hd\n\n\ndef convert_from_hex_to_uf2(buf):\n    global appstartaddr\n    appstartaddr = None\n    upper = 0\n    currblock = None\n    blocks = []\n    for line in buf.split(\"\\n\"):\n        if line[0] != \":\":\n            continue\n        i = 1\n        rec = []\n        while i < len(line) - 1:\n            rec.append(int(line[i : i + 2], 16))\n            i += 2\n        tp = rec[3]\n        if tp == 4:\n            upper = ((rec[4] << 8) | rec[5]) << 16\n        elif tp == 2:\n            upper = ((rec[4] << 8) | rec[5]) << 4\n        elif tp == 1:\n            break\n        elif tp == 0:\n            addr = upper + ((rec[1] << 8) | rec[2])\n            if appstartaddr is None:\n                appstartaddr = addr\n            i = 4\n            while i < len(rec) - 1:\n                if not currblock or currblock.addr & ~0xFF != addr & ~0xFF:\n                    currblock = Block(addr & ~0xFF)\n                    blocks.append(currblock)\n                currblock.bytes[addr & 0xFF] = rec[i]\n                addr += 1\n                i += 1\n    numblocks = len(blocks)\n    resfile = b\"\"\n    for i in range(0, numblocks):\n        resfile += blocks[i].encode(i, numblocks)\n    return resfile\n\n\ndef to_str(b):\n    return b.decode(\"utf-8\")\n\n\ndef get_drives():\n    drives = []\n    if sys.platform == \"win32\":\n        r = subprocess.check_output(\n            [\n                \"wmic\",\n                \"PATH\",\n                \"Win32_LogicalDisk\",\n                \"get\",\n                \"DeviceID,\",\n                \"VolumeName,\",\n                \"FileSystem,\",\n                \"DriveType\",\n            ]\n        )\n        for line in to_str(r).split(\"\\n\"):\n            words = re.split(r\"\\s+\", line)\n            if len(words) >= 3 and words[1] == \"2\" and words[2] == \"FAT\":\n                drives.append(words[0])\n    else:\n        rootpath = \"/media\"\n        if sys.platform == \"darwin\":\n            rootpath = \"/Volumes\"\n        elif sys.platform == \"linux\":\n            tmp = rootpath + \"/\" + os.environ[\"USER\"]\n            if os.path.isdir(tmp):\n                rootpath = tmp\n        for d in os.listdir(rootpath):\n            drives.append(os.path.join(rootpath, d))\n\n    def has_info(d):\n        try:\n            return os.path.isfile(d + INFO_FILE)\n        except:\n            return False\n\n    return list(filter(has_info, drives))\n\n\ndef board_id(path):\n    with open(path + INFO_FILE, mode=\"r\") as file:\n        file_content = file.read()\n    return re.search(\"Board-ID: ([^\\r\\n]*)\", file_content).group(1)\n\n\ndef list_drives():\n    for d in get_drives():\n        print(d, board_id(d))\n\n\ndef write_file(name, buf):\n    with open(name, \"wb\") as f:\n        f.write(buf)\n    print(\"Wrote %d bytes to %s\" % (len(buf), name))\n\n\ndef load_families():\n    # The expectation is that the `uf2families.json` file is in the same\n    # directory as this script. Make a path that works using `__file__`\n    # which contains the full path to this script.\n    filename = \"uf2families.json\"\n    pathname = os.path.join(os.path.dirname(os.path.abspath(__file__)), filename)\n    with open(pathname) as f:\n        raw_families = json.load(f)\n\n    families = {}\n    for family in raw_families:\n        families[family[\"short_name\"]] = int(family[\"id\"], 0)\n\n    return families\n\n\ndef main():\n    global appstartaddr, familyid\n\n    def error(msg):\n        print(msg)\n        sys.exit(1)\n\n    parser = argparse.ArgumentParser(description=\"Convert to UF2 or flash directly.\")\n    parser.add_argument(\n        \"input\", metavar=\"INPUT\", type=str, nargs=\"?\", help=\"input file (HEX, BIN or UF2)\"\n    )\n    parser.add_argument(\n        \"-b\",\n        \"--base\",\n        dest=\"base\",\n        type=str,\n        default=\"0x2000\",\n        help=\"set base address of application for BIN format (default: 0x2000)\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        metavar=\"FILE\",\n        dest=\"output\",\n        type=str,\n        help='write output to named file; defaults to \"flash.uf2\" or \"flash.bin\" where sensible',\n    )\n    parser.add_argument(\"-d\", \"--device\", dest=\"device_path\", help=\"select a device path to flash\")\n    parser.add_argument(\"-l\", \"--list\", action=\"store_true\", help=\"list connected devices\")\n    parser.add_argument(\"-c\", \"--convert\", action=\"store_true\", help=\"do not flash, just convert\")\n    parser.add_argument(\"-D\", \"--deploy\", action=\"store_true\", help=\"just flash, do not convert\")\n    parser.add_argument(\n        \"-f\",\n        \"--family\",\n        dest=\"family\",\n        type=str,\n        default=\"0x0\",\n        help=\"specify familyID - number or name (default: 0x0)\",\n    )\n    parser.add_argument(\n        \"-C\", \"--carray\", action=\"store_true\", help=\"convert binary file to a C array, not UF2\"\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--info\",\n        action=\"store_true\",\n        help=\"display header information from UF2, do not convert\",\n    )\n    args = parser.parse_args()\n    appstartaddr = int(args.base, 0)\n\n    families = load_families()\n\n    if args.family.upper() in families:\n        familyid = families[args.family.upper()]\n    else:\n        try:\n            familyid = int(args.family, 0)\n        except ValueError:\n            error(\"Family ID needs to be a number or one of: \" + \", \".join(families.keys()))\n\n    if args.list:\n        list_drives()\n    else:\n        if not args.input:\n            error(\"Need input file\")\n        with open(args.input, mode=\"rb\") as f:\n            inpbuf = f.read()\n        from_uf2 = is_uf2(inpbuf)\n        ext = \"uf2\"\n        if args.deploy:\n            outbuf = inpbuf\n        elif from_uf2 and not args.info:\n            outbuf = convert_from_uf2(inpbuf)\n            ext = \"bin\"\n        elif from_uf2 and args.info:\n            outbuf = \"\"\n            convert_from_uf2(inpbuf)\n        elif is_hex(inpbuf):\n            outbuf = convert_from_hex_to_uf2(inpbuf.decode(\"utf-8\"))\n        elif args.carray:\n            outbuf = convert_to_carray(inpbuf)\n            ext = \"h\"\n        else:\n            outbuf = convert_to_uf2(inpbuf)\n        if not args.deploy and not args.info:\n            print(\n                \"Converted to %s, output size: %d, start address: 0x%x\"\n                % (ext, len(outbuf), appstartaddr)\n            )\n        if args.convert or ext != \"uf2\":\n            drives = []\n            if args.output is None:\n                args.output = \"flash.\" + ext\n        else:\n            drives = get_drives()\n\n        if args.output:\n            write_file(args.output, outbuf)\n        else:\n            if len(drives) == 0:\n                error(\"No drive to deploy.\")\n        for d in drives:\n            print(\"Flashing %s (%s)\" % (d, board_id(d)))\n            write_file(d + \"/NEW.UF2\", outbuf)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}