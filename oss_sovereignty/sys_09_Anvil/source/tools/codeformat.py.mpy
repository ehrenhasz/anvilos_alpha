{
  "module_name": "codeformat.py",
  "hash_id": "d757011aa974d3c9d1d2e5e52b81965bb994a1ea9045fb5a114dc0a5a4452def",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/codeformat.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2020 Damien P. George\n# Copyright (c) 2020 Jim Mussared\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport argparse\nimport glob\nimport itertools\nimport os\nimport re\nimport subprocess\n\n# Relative to top-level repo dir.\nPATHS = [\n    \"drivers/ninaw10/*.[ch]\",\n    \"extmod/*.[ch]\",\n    \"extmod/btstack/*.[ch]\",\n    \"extmod/nimble/*.[ch]\",\n    \"lib/mbedtls_errors/tester.c\",\n    \"shared/netutils/*.[ch]\",\n    \"shared/timeutils/*.[ch]\",\n    \"shared/runtime/*.[ch]\",\n    \"shared/tinyusb/*.[ch]\",\n    \"mpy-cross/*.[ch]\",\n    \"ports/**/*.[ch]\",\n    \"py/*.[ch]\",\n]\n\nEXCLUSIONS = [\n    # The cc3200 port is not fully formatted yet.\n    \"ports/cc3200/*/*.[ch]\",\n    # ESP-IDF downloads 3rd party code.\n    \"ports/esp32/managed_components/*\",\n    # The nrf port is not fully formatted yet.\n    \"ports/nrf/boards/*.[ch]\",\n    \"ports/nrf/device/*.[ch]\",\n    \"ports/nrf/drivers/*.[ch]\",\n    \"ports/nrf/modules/ble/*.[ch]\",\n    \"ports/nrf/modules/board/*.[ch]\",\n    \"ports/nrf/modules/music/*.[ch]\",\n    \"ports/nrf/modules/ubluepy/*.[ch]\",\n    \"ports/nrf/modules/os/*.[ch]\",\n    # STM32 USB dev/host code is mostly 3rd party.\n    \"ports/stm32/usbdev/**/*.[ch]\",\n    \"ports/stm32/usbhost/**/*.[ch]\",\n    # STM32 build includes generated Python code.\n    \"ports/*/build*\",\n]\n\n# Path to repo top-level dir.\nTOP = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\n\nUNCRUSTIFY_CFG = os.path.join(TOP, \"tools/uncrustify.cfg\")\n\n\ndef list_files(paths, exclusions=None, prefix=\"\"):\n    files = set()\n    for pattern in paths:\n        files.update(glob.glob(os.path.join(prefix, pattern), recursive=True))\n    for pattern in exclusions or []:\n        files.difference_update(glob.fnmatch.filter(files, os.path.join(prefix, pattern)))\n    return sorted(files)\n\n\ndef fixup_c(filename):\n    # Read file.\n    with open(filename) as f:\n        lines = f.readlines()\n\n    # Write out file with fixups.\n    with open(filename, \"w\", newline=\"\") as f:\n        dedent_stack = []\n        while lines:\n            # Get next line.\n            l = lines.pop(0)\n\n            # Dedent #'s to match indent of following line (not previous line).\n            m = re.match(r\"( +)#(if |ifdef |ifndef |elif |else|endif)\", l)\n            if m:\n                indent = len(m.group(1))\n                directive = m.group(2)\n                if directive in (\"if \", \"ifdef \", \"ifndef \"):\n                    l_next = lines[0]\n                    indent_next = len(re.match(r\"( *)\", l_next).group(1))\n                    if indent - 4 == indent_next and re.match(r\" +(} else |case )\", l_next):\n                        # This #-line (and all associated ones) needs dedenting by 4 spaces.\n                        l = l[4:]\n                        dedent_stack.append(indent - 4)\n                    else:\n                        # This #-line does not need dedenting.\n                        dedent_stack.append(-1)\n                else:\n                    if dedent_stack[-1] >= 0:\n                        # This associated #-line needs dedenting to match the #if.\n                        indent_diff = indent - dedent_stack[-1]\n                        assert indent_diff >= 0\n                        l = l[indent_diff:]\n                    if directive == \"endif\":\n                        dedent_stack.pop()\n\n            # Write out line.\n            f.write(l)\n\n        assert not dedent_stack, filename\n\n\ndef main():\n    cmd_parser = argparse.ArgumentParser(description=\"Auto-format C and Python files.\")\n    cmd_parser.add_argument(\"-c\", action=\"store_true\", help=\"Format C code only\")\n    cmd_parser.add_argument(\"-p\", action=\"store_true\", help=\"Format Python code only\")\n    cmd_parser.add_argument(\"-v\", action=\"store_true\", help=\"Enable verbose output\")\n    cmd_parser.add_argument(\n        \"-f\",\n        action=\"store_true\",\n        help=\"Filter files provided on the command line against the default list of files to check.\",\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"*\", help=\"Run on specific globs\")\n    args = cmd_parser.parse_args()\n\n    # Setting only one of -c or -p disables the other. If both or neither are set, then do both.\n    format_c = args.c or not args.p\n    format_py = args.p or not args.c\n\n    # Expand the globs passed on the command line, or use the default globs above.\n    files = []\n    if args.files:\n        files = list_files(args.files)\n        if args.f:\n            # Filter against the default list of files. This is a little fiddly\n            # because we need to apply both the inclusion globs given in PATHS\n            # as well as the EXCLUSIONS, and use absolute paths\n            files = set(os.path.abspath(f) for f in files)\n            all_files = set(list_files(PATHS, EXCLUSIONS, TOP))\n            if args.v:  # In verbose mode, log any files we're skipping\n                for f in files - all_files:\n                    print(\"Not checking: {}\".format(f))\n            files = list(files & all_files)\n    else:\n        files = list_files(PATHS, EXCLUSIONS, TOP)\n\n    # Run tool on N files at a time (to avoid making the command line too long).\n    def batch(cmd, N=200):\n        files_iter = iter(files)\n        while True:\n            file_args = list(itertools.islice(files_iter, N))\n            if not file_args:\n                break\n            subprocess.check_call(cmd + file_args)\n\n    # Format C files with uncrustify.\n    if format_c:\n        command = [\"uncrustify\", \"-c\", UNCRUSTIFY_CFG, \"-lC\", \"--no-backup\"]\n        if not args.v:\n            command.append(\"-q\")\n        batch(command)\n        for file in files:\n            fixup_c(file)\n\n    # Format Python files with \"ruff format\" (using config in pyproject.toml).\n    if format_py:\n        command = [\"ruff\", \"format\"]\n        if args.v:\n            command.append(\"-v\")\n        else:\n            command.append(\"-q\")\n        command.append(\".\")\n        subprocess.check_call(command, cwd=TOP)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}