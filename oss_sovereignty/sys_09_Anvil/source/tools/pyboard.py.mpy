{
  "module_name": "pyboard.py",
  "hash_id": "80e4d04fc51f77465f64ed599194026f1c0a5c3ec5d5be6d851b2c1f9abe289a",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/pyboard.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2014-2021 Damien P. George\n# Copyright (c) 2017 Paul Sokolovsky\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\"\"\"\npyboard interface\n\nThis module provides the Pyboard class, used to communicate with and\ncontrol a MicroPython device over a communication channel. Both real\nboards and emulated devices (e.g. running in QEMU) are supported.\nVarious communication channels are supported, including a serial\nconnection, telnet-style network connection, external process\nconnection.\n\nExample usage:\n\n    import pyboard\n    pyb = pyboard.Pyboard('/dev/ttyACM0')\n\nOr:\n\n    pyb = pyboard.Pyboard('192.168.1.1')\n\nThen:\n\n    pyb.enter_raw_repl()\n    pyb.exec('import pyb')\n    pyb.exec('pyb.LED(1).on()')\n    pyb.exit_raw_repl()\n\nNote: if using Python2 then pyb.exec must be written as pyb.exec_.\nTo run a script from the local machine on the board and print out the results:\n\n    import pyboard\n    pyboard.execfile('test.py', device='/dev/ttyACM0')\n\nThis script can also be run directly.  To execute a local script, use:\n\n    ./pyboard.py test.py\n\nOr:\n\n    python pyboard.py test.py\n\n\"\"\"\n\nimport ast\nimport errno\nimport os\nimport struct\nimport sys\nimport time\n\nfrom collections import namedtuple\n\ntry:\n    stdout = sys.stdout.buffer\nexcept AttributeError:\n    # Python2 doesn't have buffer attr\n    stdout = sys.stdout\n\n\ndef stdout_write_bytes(b):\n    b = b.replace(b\"\\x04\", b\"\")\n    stdout.write(b)\n    stdout.flush()\n\n\nclass PyboardError(Exception):\n    def convert(self, info):\n        if len(self.args) >= 3:\n            if b\"OSError\" in self.args[2] and b\"ENOENT\" in self.args[2]:\n                return OSError(errno.ENOENT, info)\n\n        return self\n\n\nlistdir_result = namedtuple(\"dir_result\", [\"name\", \"st_mode\", \"st_ino\", \"st_size\"])\n\n\nclass TelnetToSerial:\n    def __init__(self, ip, user, password, read_timeout=None):\n        self.tn = None\n        import telnetlib\n\n        self.tn = telnetlib.Telnet(ip, timeout=15)\n        self.read_timeout = read_timeout\n        if b\"Login as:\" in self.tn.read_until(b\"Login as:\", timeout=read_timeout):\n            self.tn.write(bytes(user, \"ascii\") + b\"\\r\\n\")\n\n            if b\"Password:\" in self.tn.read_until(b\"Password:\", timeout=read_timeout):\n                # needed because of internal implementation details of the telnet server\n                time.sleep(0.2)\n                self.tn.write(bytes(password, \"ascii\") + b\"\\r\\n\")\n\n                if b\"for more information.\" in self.tn.read_until(\n                    b'Type \"help()\" for more information.', timeout=read_timeout\n                ):\n                    # login successful\n                    from collections import deque\n\n                    self.fifo = deque()\n                    return\n\n        raise PyboardError(\"Failed to establish a telnet connection with the board\")\n\n    def __del__(self):\n        self.close()\n\n    def close(self):\n        if self.tn:\n            self.tn.close()\n\n    def read(self, size=1):\n        while len(self.fifo) < size:\n            timeout_count = 0\n            data = self.tn.read_eager()\n            if len(data):\n                self.fifo.extend(data)\n                timeout_count = 0\n            else:\n                time.sleep(0.25)\n                if self.read_timeout is not None and timeout_count > 4 * self.read_timeout:\n                    break\n                timeout_count += 1\n\n        data = b\"\"\n        while len(data) < size and len(self.fifo) > 0:\n            data += bytes([self.fifo.popleft()])\n        return data\n\n    def write(self, data):\n        self.tn.write(data)\n        return len(data)\n\n    def inWaiting(self):\n        n_waiting = len(self.fifo)\n        if not n_waiting:\n            data = self.tn.read_eager()\n            self.fifo.extend(data)\n            return len(data)\n        else:\n            return n_waiting\n\n\nclass ProcessToSerial:\n    \"Execute a process and emulate serial connection using its stdin/stdout.\"\n\n    def __init__(self, cmd):\n        import subprocess\n\n        self.subp = subprocess.Popen(\n            cmd,\n            bufsize=0,\n            shell=True,\n            preexec_fn=os.setsid,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n        )\n\n        # Initially was implemented with selectors, but that adds Python3\n        # dependency. However, there can be race conditions communicating\n        # with a particular child process (like QEMU), and selectors may\n        # still work better in that case, so left inplace for now.\n        #\n        # import selectors\n        # self.sel = selectors.DefaultSelector()\n        # self.sel.register(self.subp.stdout, selectors.EVENT_READ)\n\n        import select\n\n        self.poll = select.poll()\n        self.poll.register(self.subp.stdout.fileno())\n\n    def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)\n\n    def read(self, size=1):\n        data = b\"\"\n        while len(data) < size:\n            data += self.subp.stdout.read(size - len(data))\n        return data\n\n    def write(self, data):\n        self.subp.stdin.write(data)\n        return len(data)\n\n    def inWaiting(self):\n        # res = self.sel.select(0)\n        res = self.poll.poll(0)\n        if res:\n            return 1\n        return 0\n\n\nclass ProcessPtyToTerminal:\n    \"\"\"Execute a process which creates a PTY and prints slave PTY as\n    first line of its output, and emulate serial connection using\n    this PTY.\"\"\"\n\n    def __init__(self, cmd):\n        import subprocess\n        import re\n        import serial\n\n        self.subp = subprocess.Popen(\n            cmd.split(),\n            bufsize=0,\n            shell=False,\n            preexec_fn=os.setsid,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        pty_line = self.subp.stderr.readline().decode(\"utf-8\")\n        m = re.search(r\"/dev/pts/[0-9]+\", pty_line)\n        if not m:\n            print(\"Error: unable to find PTY device in startup line:\", pty_line)\n            self.close()\n            sys.exit(1)\n        pty = m.group()\n        # rtscts, dsrdtr params are to workaround pyserial bug:\n        # http://stackoverflow.com/questions/34831131/pyserial-does-not-play-well-with-virtual-port\n        self.serial = serial.Serial(pty, interCharTimeout=1, rtscts=True, dsrdtr=True)\n\n    def close(self):\n        import signal\n\n        os.killpg(os.getpgid(self.subp.pid), signal.SIGTERM)\n\n    def read(self, size=1):\n        return self.serial.read(size)\n\n    def write(self, data):\n        return self.serial.write(data)\n\n    def inWaiting(self):\n        return self.serial.inWaiting()\n\n\nclass Pyboard:\n    def __init__(\n        self, device, baudrate=115200, user=\"micro\", password=\"python\", wait=0, exclusive=True\n    ):\n        self.in_raw_repl = False\n        self.use_raw_paste = True\n        if device.startswith(\"exec:\"):\n            self.serial = ProcessToSerial(device[len(\"exec:\") :])\n        elif device.startswith(\"execpty:\"):\n            self.serial = ProcessPtyToTerminal(device[len(\"qemupty:\") :])\n        elif device and device[0].isdigit() and device[-1].isdigit() and device.count(\".\") == 3:\n            # device looks like an IP address\n            self.serial = TelnetToSerial(device, user, password, read_timeout=10)\n        else:\n            import serial\n            import serial.tools.list_ports\n\n            # Set options, and exclusive if pyserial supports it\n            serial_kwargs = {\"baudrate\": baudrate, \"interCharTimeout\": 1}\n            if serial.__version__ >= \"3.3\":\n                serial_kwargs[\"exclusive\"] = exclusive\n\n            delayed = False\n            for attempt in range(wait + 1):\n                try:\n                    if os.name == \"nt\":\n                        self.serial = serial.Serial(**serial_kwargs)\n                        self.serial.port = device\n                        portinfo = list(serial.tools.list_ports.grep(device))  # type: ignore\n                        if portinfo and portinfo[0].manufacturer != \"Microsoft\":\n                            # ESP8266/ESP32 boards use RTS/CTS for flashing and boot mode selection.\n                            # DTR False: to avoid using the reset button will hang the MCU in bootloader mode\n                            # RTS False: to prevent pulses on rts on serial.close() that would POWERON_RESET an ESPxx\n                            self.serial.dtr = False  # DTR False = gpio0 High = Normal boot\n                            self.serial.rts = False  # RTS False = EN High = MCU enabled\n                        self.serial.open()\n                    else:\n                        self.serial = serial.Serial(device, **serial_kwargs)\n                    break\n                except (OSError, IOError):  # Py2 and Py3 have different errors\n                    if wait == 0:\n                        continue\n                    if attempt == 0:\n                        sys.stdout.write(\"Waiting {} seconds for pyboard \".format(wait))\n                        delayed = True\n                time.sleep(1)\n                sys.stdout.write(\".\")\n                sys.stdout.flush()\n            else:\n                if delayed:\n                    print(\"\")\n                raise PyboardError(\"failed to access \" + device)\n            if delayed:\n                print(\"\")\n\n    def close(self):\n        self.serial.close()\n\n    def read_until(self, min_num_bytes, ending, timeout=10, data_consumer=None):\n        # if data_consumer is used then data is not accumulated and the ending must be 1 byte long\n        assert data_consumer is None or len(ending) == 1\n\n        data = self.serial.read(min_num_bytes)\n        if data_consumer:\n            data_consumer(data)\n        timeout_count = 0\n        while True:\n            if data.endswith(ending):\n                break\n            elif self.serial.inWaiting() > 0:\n                new_data = self.serial.read(1)\n                if data_consumer:\n                    data_consumer(new_data)\n                    data = new_data\n                else:\n                    data = data + new_data\n                timeout_count = 0\n            else:\n                timeout_count += 1\n                if timeout is not None and timeout_count >= 100 * timeout:\n                    break\n                time.sleep(0.01)\n        return data\n\n    def enter_raw_repl(self, soft_reset=True):\n        self.serial.write(b\"\\r\\x03\\x03\")  # ctrl-C twice: interrupt any running program\n\n        # flush input (without relying on serial.flushInput())\n        n = self.serial.inWaiting()\n        while n > 0:\n            self.serial.read(n)\n            n = self.serial.inWaiting()\n\n        self.serial.write(b\"\\r\\x01\")  # ctrl-A: enter raw REPL\n\n        if soft_reset:\n            data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n>\")\n            if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n>\"):\n                print(data)\n                raise PyboardError(\"could not enter raw repl\")\n\n            self.serial.write(b\"\\x04\")  # ctrl-D: soft reset\n\n            # Waiting for \"soft reboot\" independently to \"raw REPL\" (done below)\n            # allows boot.py to print, which will show up after \"soft reboot\"\n            # and before \"raw REPL\".\n            data = self.read_until(1, b\"soft reboot\\r\\n\")\n            if not data.endswith(b\"soft reboot\\r\\n\"):\n                print(data)\n                raise PyboardError(\"could not enter raw repl\")\n\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n\"):\n            print(data)\n            raise PyboardError(\"could not enter raw repl\")\n\n        self.in_raw_repl = True\n\n    def exit_raw_repl(self):\n        self.serial.write(b\"\\r\\x02\")  # ctrl-B: enter friendly REPL\n        self.in_raw_repl = False\n\n    def follow(self, timeout, data_consumer=None):\n        # wait for normal output\n        data = self.read_until(1, b\"\\x04\", timeout=timeout, data_consumer=data_consumer)\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for first EOF reception\")\n        data = data[:-1]\n\n        # wait for error output\n        data_err = self.read_until(1, b\"\\x04\", timeout=timeout)\n        if not data_err.endswith(b\"\\x04\"):\n            raise PyboardError(\"timeout waiting for second EOF reception\")\n        data_err = data_err[:-1]\n\n        # return normal and error output\n        return data, data_err\n\n    def raw_paste_write(self, command_bytes):\n        # Read initial header, with window size.\n        data = self.serial.read(2)\n        window_size = struct.unpack(\"<H\", data)[0]\n        window_remain = window_size\n\n        # Write out the command_bytes data.\n        i = 0\n        while i < len(command_bytes):\n            while window_remain == 0 or self.serial.inWaiting():\n                data = self.serial.read(1)\n                if data == b\"\\x01\":\n                    # Device indicated that a new window of data can be sent.\n                    window_remain += window_size\n                elif data == b\"\\x04\":\n                    # Device indicated abrupt end.  Acknowledge it and finish.\n                    self.serial.write(b\"\\x04\")\n                    return\n                else:\n                    # Unexpected data from device.\n                    raise PyboardError(\"unexpected read during raw paste: {}\".format(data))\n            # Send out as much data as possible that fits within the allowed window.\n            b = command_bytes[i : min(i + window_remain, len(command_bytes))]\n            self.serial.write(b)\n            window_remain -= len(b)\n            i += len(b)\n\n        # Indicate end of data.\n        self.serial.write(b\"\\x04\")\n\n        # Wait for device to acknowledge end of data.\n        data = self.read_until(1, b\"\\x04\")\n        if not data.endswith(b\"\\x04\"):\n            raise PyboardError(\"could not complete raw paste: {}\".format(data))\n\n    def exec_raw_no_follow(self, command):\n        if isinstance(command, bytes):\n            command_bytes = command\n        else:\n            command_bytes = bytes(command, encoding=\"utf8\")\n\n        # check we have a prompt\n        data = self.read_until(1, b\">\")\n        if not data.endswith(b\">\"):\n            raise PyboardError(\"could not enter raw repl\")\n\n        if self.use_raw_paste:\n            # Try to enter raw-paste mode.\n            self.serial.write(b\"\\x05A\\x01\")\n            data = self.serial.read(2)\n            if data == b\"R\\x00\":\n                # Device understood raw-paste command but doesn't support it.\n                pass\n            elif data == b\"R\\x01\":\n                # Device supports raw-paste mode, write out the command using this mode.\n                return self.raw_paste_write(command_bytes)\n            else:\n                # Device doesn't support raw-paste, fall back to normal raw REPL.\n                data = self.read_until(1, b\"w REPL; CTRL-B to exit\\r\\n>\")\n                if not data.endswith(b\"w REPL; CTRL-B to exit\\r\\n>\"):\n                    print(data)\n                    raise PyboardError(\"could not enter raw repl\")\n            # Don't try to use raw-paste mode again for this connection.\n            self.use_raw_paste = False\n\n        # Write command using standard raw REPL, 256 bytes every 10ms.\n        for i in range(0, len(command_bytes), 256):\n            self.serial.write(command_bytes[i : min(i + 256, len(command_bytes))])\n            time.sleep(0.01)\n        self.serial.write(b\"\\x04\")\n\n        # check if we could exec command\n        data = self.serial.read(2)\n        if data != b\"OK\":\n            raise PyboardError(\"could not exec command (response: %r)\" % data)\n\n    def exec_raw(self, command, timeout=10, data_consumer=None):\n        self.exec_raw_no_follow(command)\n        return self.follow(timeout, data_consumer)\n\n    def eval(self, expression, parse=False):\n        if parse:\n            ret = self.exec_(\"print(repr({}))\".format(expression))\n            ret = ret.strip()\n            return ast.literal_eval(ret.decode())\n        else:\n            ret = self.exec_(\"print({})\".format(expression))\n            ret = ret.strip()\n            return ret\n\n    # In Python3, call as pyboard.exec(), see the setattr call below.\n    def exec_(self, command, data_consumer=None):\n        ret, ret_err = self.exec_raw(command, data_consumer=data_consumer)\n        if ret_err:\n            raise PyboardError(\"exception\", ret, ret_err)\n        return ret\n\n    def execfile(self, filename):\n        with open(filename, \"rb\") as f:\n            pyfile = f.read()\n        return self.exec_(pyfile)\n\n    def get_time(self):\n        t = str(self.eval(\"pyb.RTC().datetime()\"), encoding=\"utf8\")[1:-1].split(\", \")\n        return int(t[4]) * 3600 + int(t[5]) * 60 + int(t[6])\n\n    def fs_exists(self, src):\n        try:\n            self.exec_(\"import os\\nos.stat(%s)\" % ((\"'%s'\" % src) if src else \"\"))\n            return True\n        except PyboardError:\n            return False\n\n    def fs_ls(self, src):\n        cmd = (\n            \"import os\\nfor f in os.ilistdir(%s):\\n\"\n            \" print('{:12} {}{}'.format(f[3]if len(f)>3 else 0,f[0],'/'if f[1]&0x4000 else ''))\"\n            % ((\"'%s'\" % src) if src else \"\")\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)\n\n    def fs_listdir(self, src=\"\"):\n        buf = bytearray()\n\n        def repr_consumer(b):\n            buf.extend(b.replace(b\"\\x04\", b\"\"))\n\n        cmd = \"import os\\nfor f in os.ilistdir(%s):\\n\" \" print(repr(f), end=',')\" % (\n            (\"'%s'\" % src) if src else \"\"\n        )\n        try:\n            buf.extend(b\"[\")\n            self.exec_(cmd, data_consumer=repr_consumer)\n            buf.extend(b\"]\")\n        except PyboardError as e:\n            raise e.convert(src)\n\n        return [\n            listdir_result(*f) if len(f) == 4 else listdir_result(*(f + (0,)))\n            for f in ast.literal_eval(buf.decode())\n        ]\n\n    def fs_stat(self, src):\n        try:\n            self.exec_(\"import os\")\n            return os.stat_result(self.eval(\"os.stat(%s)\" % (\"'%s'\" % src), parse=True))\n        except PyboardError as e:\n            raise e.convert(src)\n\n    def fs_cat(self, src, chunk_size=256):\n        cmd = (\n            \"with open('%s') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        self.exec_(cmd, data_consumer=stdout_write_bytes)\n\n    def fs_readfile(self, src, chunk_size=256):\n        buf = bytearray()\n\n        def repr_consumer(b):\n            buf.extend(b.replace(b\"\\x04\", b\"\"))\n\n        cmd = (\n            \"with open('%s', 'rb') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        try:\n            self.exec_(cmd, data_consumer=repr_consumer)\n        except PyboardError as e:\n            raise e.convert(src)\n        return ast.literal_eval(buf.decode())\n\n    def fs_writefile(self, dest, data, chunk_size=256):\n        self.exec_(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        while data:\n            chunk = data[:chunk_size]\n            self.exec_(\"w(\" + repr(chunk) + \")\")\n            data = data[len(chunk) :]\n        self.exec_(\"f.close()\")\n\n    def fs_cp(self, src, dest, chunk_size=256, progress_callback=None):\n        if progress_callback:\n            src_size = self.fs_stat(src).st_size\n            written = 0\n        self.exec_(\"fr=open('%s','rb')\\nr=fr.read\\nfw=open('%s','wb')\\nw=fw.write\" % (src, dest))\n        while True:\n            data_len = int(self.exec_(\"d=r(%u)\\nw(d)\\nprint(len(d))\" % chunk_size))\n            if not data_len:\n                break\n            if progress_callback:\n                written += data_len\n                progress_callback(written, src_size)\n        self.exec_(\"fr.close()\\nfw.close()\")\n\n    def fs_get(self, src, dest, chunk_size=256, progress_callback=None):\n        if progress_callback:\n            src_size = self.fs_stat(src).st_size\n            written = 0\n        self.exec_(\"f=open('%s','rb')\\nr=f.read\" % src)\n        with open(dest, \"wb\") as f:\n            while True:\n                data = bytearray()\n                self.exec_(\"print(r(%u))\" % chunk_size, data_consumer=lambda d: data.extend(d))\n                assert data.endswith(b\"\\r\\n\\x04\")\n                try:\n                    data = ast.literal_eval(str(data[:-3], \"ascii\"))\n                    if not isinstance(data, bytes):\n                        raise ValueError(\"Not bytes\")\n                except (UnicodeError, ValueError) as e:\n                    raise PyboardError(\"fs_get: Could not interpret received data: %s\" % str(e))\n                if not data:\n                    break\n                f.write(data)\n                if progress_callback:\n                    written += len(data)\n                    progress_callback(written, src_size)\n        self.exec_(\"f.close()\")\n\n    def fs_put(self, src, dest, chunk_size=256, progress_callback=None):\n        if progress_callback:\n            src_size = os.path.getsize(src)\n            written = 0\n        self.exec_(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        with open(src, \"rb\") as f:\n            while True:\n                data = f.read(chunk_size)\n                if not data:\n                    break\n                if sys.version_info < (3,):\n                    self.exec_(\"w(b\" + repr(data) + \")\")\n                else:\n                    self.exec_(\"w(\" + repr(data) + \")\")\n                if progress_callback:\n                    written += len(data)\n                    progress_callback(written, src_size)\n        self.exec_(\"f.close()\")\n\n    def fs_mkdir(self, dir):\n        self.exec_(\"import os\\nos.mkdir('%s')\" % dir)\n\n    def fs_rmdir(self, dir):\n        self.exec_(\"import os\\nos.rmdir('%s')\" % dir)\n\n    def fs_rm(self, src):\n        self.exec_(\"import os\\nos.remove('%s')\" % src)\n\n    def fs_touch(self, src):\n        self.exec_(\"f=open('%s','a')\\nf.close()\" % src)\n\n\n# in Python2 exec is a keyword so one must use \"exec_\"\n# but for Python3 we want to provide the nicer version \"exec\"\nsetattr(Pyboard, \"exec\", Pyboard.exec_)\n\n\ndef execfile(filename, device=\"/dev/ttyACM0\", baudrate=115200, user=\"micro\", password=\"python\"):\n    pyb = Pyboard(device, baudrate, user, password)\n    pyb.enter_raw_repl()\n    output = pyb.execfile(filename)\n    stdout_write_bytes(output)\n    pyb.exit_raw_repl()\n    pyb.close()\n\n\ndef filesystem_command(pyb, args, progress_callback=None, verbose=False):\n    def fname_remote(src):\n        if src.startswith(\":\"):\n            src = src[1:]\n        # Convert all path separators to \"/\", because that's what a remote device uses.\n        return src.replace(os.path.sep, \"/\")\n\n    def fname_cp_dest(src, dest):\n        _, src = os.path.split(src)\n        if dest is None or dest == \"\":\n            dest = src\n        elif dest == \".\":\n            dest = \"./\" + src\n        elif dest.endswith(\"/\"):\n            dest += src\n        return dest\n\n    cmd = args[0]\n    args = args[1:]\n    try:\n        if cmd == \"cp\":\n            if len(args) == 1:\n                raise PyboardError(\n                    \"cp: missing destination file operand after '{}'\".format(args[0])\n                )\n            srcs = args[:-1]\n            dest = args[-1]\n            if dest.startswith(\":\"):\n                op_remote_src = pyb.fs_cp\n                op_local_src = pyb.fs_put\n            else:\n                op_remote_src = pyb.fs_get\n                op_local_src = lambda src, dest, **_: __import__(\"shutil\").copy(src, dest)\n            for src in srcs:\n                if verbose:\n                    print(\"cp %s %s\" % (src, dest))\n                if src.startswith(\":\"):\n                    op = op_remote_src\n                else:\n                    op = op_local_src\n                src2 = fname_remote(src)\n                dest2 = fname_cp_dest(src2, fname_remote(dest))\n                op(src2, dest2, progress_callback=progress_callback)\n        else:\n            ops = {\n                \"cat\": pyb.fs_cat,\n                \"ls\": pyb.fs_ls,\n                \"mkdir\": pyb.fs_mkdir,\n                \"rm\": pyb.fs_rm,\n                \"rmdir\": pyb.fs_rmdir,\n                \"touch\": pyb.fs_touch,\n            }\n            if cmd not in ops:\n                raise PyboardError(\"'{}' is not a filesystem command\".format(cmd))\n            if cmd == \"ls\" and not args:\n                args = [\"\"]\n            for src in args:\n                src = fname_remote(src)\n                if verbose:\n                    print(\"%s :%s\" % (cmd, src))\n                ops[cmd](src)\n    except PyboardError as er:\n        if len(er.args) > 1:\n            print(str(er.args[2], \"ascii\"))\n        else:\n            print(er)\n        pyb.exit_raw_repl()\n        pyb.close()\n        sys.exit(1)\n\n\n_injected_import_hook_code = \"\"\"\\\nimport os, io\nclass _FS:\n  class File(io.IOBase):\n    def __init__(self):\n      self.off = 0\n    def ioctl(self, request, arg):\n      return 0\n    def readinto(self, buf):\n      buf[:] = memoryview(_injected_buf)[self.off:self.off + len(buf)]\n      self.off += len(buf)\n      return len(buf)\n  mount = umount = chdir = lambda *args: None\n  def stat(self, path):\n    if path == '_injected.mpy':\n      return tuple(0 for _ in range(10))\n    else:\n      raise OSError(-2) # ENOENT\n  def open(self, path, mode):\n    return self.File()\nos.mount(_FS(), '/_')\nos.chdir('/_')\nfrom _injected import *\nos.umount('/_')\ndel _injected_buf, _FS\n\"\"\"\n\n\ndef main():\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(description=\"Run scripts on the pyboard.\")\n    cmd_parser.add_argument(\n        \"-d\",\n        \"--device\",\n        default=os.environ.get(\"PYBOARD_DEVICE\", \"/dev/ttyACM0\"),\n        help=\"the serial device or the IP address of the pyboard\",\n    )\n    cmd_parser.add_argument(\n        \"-b\",\n        \"--baudrate\",\n        default=os.environ.get(\"PYBOARD_BAUDRATE\", \"115200\"),\n        help=\"the baud rate of the serial device\",\n    )\n    cmd_parser.add_argument(\"-u\", \"--user\", default=\"micro\", help=\"the telnet login username\")\n    cmd_parser.add_argument(\"-p\", \"--password\", default=\"python\", help=\"the telnet login password\")\n    cmd_parser.add_argument(\"-c\", \"--command\", help=\"program passed in as string\")\n    cmd_parser.add_argument(\n        \"-w\",\n        \"--wait\",\n        default=0,\n        type=int,\n        help=\"seconds to wait for USB connected board to become available\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--soft-reset\",\n        default=True,\n        action=\"store_true\",\n        help=\"Whether to perform a soft reset when connecting to the board [default]\",\n    )\n    group.add_argument(\n        \"--no-soft-reset\",\n        action=\"store_false\",\n        dest=\"soft_reset\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--follow\",\n        action=\"store_true\",\n        default=None,\n        help=\"follow the output after running the scripts [default if no scripts given]\",\n    )\n    group.add_argument(\n        \"--no-follow\",\n        action=\"store_false\",\n        dest=\"follow\",\n    )\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--exclusive\",\n        action=\"store_true\",\n        default=True,\n        help=\"Open the serial device for exclusive access [default]\",\n    )\n    group.add_argument(\n        \"--no-exclusive\",\n        action=\"store_false\",\n        dest=\"exclusive\",\n    )\n    cmd_parser.add_argument(\n        \"-f\",\n        \"--filesystem\",\n        action=\"store_true\",\n        help=\"perform a filesystem action: \"\n        \"cp local :device | cp :device local | cat path | ls [path] | rm path | mkdir path | rmdir path\",\n    )\n    cmd_parser.add_argument(\"files\", nargs=\"*\", help=\"input files\")\n    args = cmd_parser.parse_args()\n\n    # open the connection to the pyboard\n    try:\n        pyb = Pyboard(\n            args.device, args.baudrate, args.user, args.password, args.wait, args.exclusive\n        )\n    except PyboardError as er:\n        print(er)\n        sys.exit(1)\n\n    # run any command or file(s)\n    if args.command is not None or args.filesystem or len(args.files):\n        # we must enter raw-REPL mode to execute commands\n        # this will do a soft-reset of the board\n        try:\n            pyb.enter_raw_repl(args.soft_reset)\n        except PyboardError as er:\n            print(er)\n            pyb.close()\n            sys.exit(1)\n\n        def execbuffer(buf):\n            try:\n                if args.follow is None or args.follow:\n                    ret, ret_err = pyb.exec_raw(\n                        buf, timeout=None, data_consumer=stdout_write_bytes\n                    )\n                else:\n                    pyb.exec_raw_no_follow(buf)\n                    ret_err = None\n            except PyboardError as er:\n                print(er)\n                pyb.close()\n                sys.exit(1)\n            except KeyboardInterrupt:\n                sys.exit(1)\n            if ret_err:\n                pyb.exit_raw_repl()\n                pyb.close()\n                stdout_write_bytes(ret_err)\n                sys.exit(1)\n\n        # do filesystem commands, if given\n        if args.filesystem:\n            filesystem_command(pyb, args.files, verbose=True)\n            del args.files[:]\n\n        # run the command, if given\n        if args.command is not None:\n            execbuffer(args.command.encode(\"utf-8\"))\n\n        # run any files\n        for filename in args.files:\n            with open(filename, \"rb\") as f:\n                pyfile = f.read()\n                if filename.endswith(\".mpy\") and pyfile[0] == ord(\"M\"):\n                    pyb.exec_(\"_injected_buf=\" + repr(pyfile))\n                    pyfile = _injected_import_hook_code\n                execbuffer(pyfile)\n\n        # exiting raw-REPL just drops to friendly-REPL mode\n        pyb.exit_raw_repl()\n\n    # if asked explicitly, or no files given, then follow the output\n    if args.follow or (args.command is None and not args.filesystem and len(args.files) == 0):\n        try:\n            ret, ret_err = pyb.follow(timeout=None, data_consumer=stdout_write_bytes)\n        except PyboardError as er:\n            print(er)\n            sys.exit(1)\n        except KeyboardInterrupt:\n            sys.exit(1)\n        if ret_err:\n            pyb.close()\n            stdout_write_bytes(ret_err)\n            sys.exit(1)\n\n    # close the connection to the pyboard\n    pyb.close()\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}