{
  "module_name": "metrics.py",
  "hash_id": "7a6d82eada25c094eb4f09f8cda614b31db3f2693d934e655355a22548a9b1ec",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/metrics.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2020 Damien P. George\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n\"\"\"\nThis script is used to compute metrics, like code size, of the various ports.\n\nTypical usage is:\n\n    $ ./tools/metrics.py build | tee size0\n    <wait for build to complete>\n    $ git switch new-feature-branch\n    $ ./tools/metrics.py build | tee size1\n    <wait for build to complete>\n    $ ./tools/metrics.py diff size0 size1\n\nOther commands:\n\n    $ ./tools/metrics.py sizes # print all firmware sizes\n    $ ./tools/metrics.py clean # clean all ports\n\n\"\"\"\n\nimport collections, sys, re, subprocess\n\nMAKE_FLAGS = [\"-j3\", \"CFLAGS_EXTRA=-DNDEBUG\"]\n\n\nclass PortData:\n    def __init__(self, name, dir, output, make_flags=None):\n        self.name = name\n        self.dir = dir\n        self.output = output\n        self.make_flags = make_flags\n        self.needs_mpy_cross = dir not in (\"bare-arm\", \"minimal\")\n\n\nport_data = {\n    \"b\": PortData(\"bare-arm\", \"bare-arm\", \"build/firmware.elf\"),\n    \"m\": PortData(\"minimal x86\", \"minimal\", \"build/firmware.elf\"),\n    \"u\": PortData(\"unix x64\", \"unix\", \"build-standard/micropython\"),\n    \"n\": PortData(\"unix nanbox\", \"unix\", \"build-nanbox/micropython\", \"VARIANT=nanbox\"),\n    \"s\": PortData(\"stm32\", \"stm32\", \"build-PYBV10/firmware.elf\", \"BOARD=PYBV10\"),\n    \"c\": PortData(\"cc3200\", \"cc3200\", \"build/WIPY/release/application.axf\", \"BTARGET=application\"),\n    \"8\": PortData(\"esp8266\", \"esp8266\", \"build-ESP8266_GENERIC/firmware.elf\"),\n    \"3\": PortData(\"esp32\", \"esp32\", \"build-ESP32_GENERIC/micropython.elf\"),\n    \"x\": PortData(\"mimxrt\", \"mimxrt\", \"build-TEENSY40/firmware.elf\"),\n    \"e\": PortData(\"renesas-ra\", \"renesas-ra\", \"build-EK_RA6M2/firmware.elf\"),\n    \"r\": PortData(\"nrf\", \"nrf\", \"build-PCA10040/firmware.elf\"),\n    \"p\": PortData(\"rp2\", \"rp2\", \"build-RPI_PICO/firmware.elf\"),\n    \"d\": PortData(\"samd\", \"samd\", \"build-ADAFRUIT_ITSYBITSY_M4_EXPRESS/firmware.elf\"),\n}\n\n\ndef syscmd(*args):\n    sys.stdout.flush()\n    a2 = []\n    for a in args:\n        if isinstance(a, str):\n            a2.append(a)\n        elif a:\n            a2.extend(a)\n    subprocess.check_call(a2)\n\n\ndef parse_port_list(args):\n    if not args:\n        return list(port_data.values())\n    else:\n        ports = []\n        for arg in args:\n            for port_char in arg:\n                try:\n                    ports.append(port_data[port_char])\n                except KeyError:\n                    print(\"unknown port:\", port_char)\n                    sys.exit(1)\n        return ports\n\n\ndef read_build_log(filename):\n    data = collections.OrderedDict()\n    lines = []\n    found_sizes = False\n    with open(filename) as f:\n        for line in f:\n            line = line.strip()\n            if line.strip() == \"COMPUTING SIZES\":\n                found_sizes = True\n            elif found_sizes:\n                lines.append(line)\n    is_size_line = False\n    for line in lines:\n        if is_size_line:\n            fields = line.split()\n            data[fields[-1]] = [int(f) for f in fields[:-2]]\n            is_size_line = False\n        else:\n            is_size_line = line.startswith(\"text\\t \")\n    return data\n\n\ndef do_diff(args):\n    \"\"\"Compute the difference between firmware sizes.\"\"\"\n\n    # Parse arguments.\n    error_threshold = None\n    if len(args) >= 2 and args[0] == \"--error-threshold\":\n        args.pop(0)\n        error_threshold = int(args.pop(0))\n\n    if len(args) != 2:\n        print(\"usage: %s diff [--error-threshold <x>] <out1> <out2>\" % sys.argv[0])\n        sys.exit(1)\n\n    data1 = read_build_log(args[0])\n    data2 = read_build_log(args[1])\n\n    max_delta = None\n    for key, value1 in data1.items():\n        value2 = data2[key]\n        for port in port_data.values():\n            if key == \"ports/{}/{}\".format(port.dir, port.output):\n                name = port.name\n                break\n        data = [v2 - v1 for v1, v2 in zip(value1, value2)]\n        warn = \"\"\n        board = re.search(r\"/build-([A-Za-z0-9_]+)/\", key)\n        if board:\n            board = board.group(1)\n        else:\n            board = \"\"\n        if name == \"cc3200\":\n            delta = data[0]\n            percent = 100 * delta / value1[0]\n            if data[1] != 0:\n                warn += \" %+u(data)\" % data[1]\n        else:\n            delta = data[3]\n            percent = 100 * delta / value1[3]\n            if data[1] != 0:\n                warn += \" %+u(data)\" % data[1]\n            if data[2] != 0:\n                warn += \" %+u(bss)\" % data[2]\n        if warn:\n            warn = \"[incl%s]\" % warn\n        print(\"%11s: %+5u %+.3f%% %s%s\" % (name, delta, percent, board, warn))\n        max_delta = delta if max_delta is None else max(max_delta, delta)\n\n    if error_threshold is not None and max_delta is not None:\n        if max_delta > error_threshold:\n            sys.exit(1)\n\n\ndef do_clean(args):\n    \"\"\"Clean ports.\"\"\"\n\n    ports = parse_port_list(args)\n\n    print(\"CLEANING\")\n    for port in ports:\n        syscmd(\"make\", \"-C\", \"ports/{}\".format(port.dir), port.make_flags, \"clean\")\n\n\ndef do_build(args):\n    \"\"\"Build ports and print firmware sizes.\"\"\"\n\n    ports = parse_port_list(args)\n\n    if any(port.needs_mpy_cross for port in ports):\n        print(\"BUILDING MPY-CROSS\")\n        syscmd(\"make\", \"-C\", \"mpy-cross\", MAKE_FLAGS)\n\n    print(\"BUILDING PORTS\")\n    for port in ports:\n        syscmd(\"make\", \"-C\", \"ports/{}\".format(port.dir), MAKE_FLAGS, port.make_flags)\n\n    do_sizes(args)\n\n\ndef do_sizes(args):\n    \"\"\"Compute and print sizes of firmware.\"\"\"\n\n    ports = parse_port_list(args)\n\n    print(\"COMPUTING SIZES\")\n    for port in ports:\n        syscmd(\"size\", \"ports/{}/{}\".format(port.dir, port.output))\n\n\ndef main():\n    # Get command to execute\n    if len(sys.argv) == 1:\n        print(\"Available commands:\")\n        for cmd in globals():\n            if cmd.startswith(\"do_\"):\n                print(\"   {:9} {}\".format(cmd[3:], globals()[cmd].__doc__))\n        sys.exit(1)\n    cmd = sys.argv.pop(1)\n\n    # Dispatch to desired command\n    try:\n        cmd = globals()[\"do_{}\".format(cmd)]\n    except KeyError:\n        print(\"{}: unknown command '{}'\".format(sys.argv[0], cmd))\n        sys.exit(1)\n    cmd(sys.argv[1:])\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}