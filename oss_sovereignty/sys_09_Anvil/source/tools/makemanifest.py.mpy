{
  "module_name": "makemanifest.py",
  "hash_id": "fc77b518a4d17c50b9fae1c0e3795430462f39dd0ab53d182d903d0cfd889d23",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/makemanifest.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2019 Damien P. George\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom __future__ import print_function\nimport sys\nimport os\nimport subprocess\n\n# Always use the mpy-cross from this repo.\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), \"../mpy-cross\"))\nimport mpy_cross\n\nimport manifestfile\n\nVARS = {}\n\n\nclass FreezeError(Exception):\n    pass\n\n\ndef system(cmd):\n    try:\n        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        return 0, output\n    except subprocess.CalledProcessError as er:\n        return -1, er.output\n\n\ndef get_timestamp(path, default=None):\n    try:\n        stat = os.stat(path)\n        return stat.st_mtime\n    except OSError:\n        if default is None:\n            raise FreezeError(\"cannot stat {}\".format(path))\n        return default\n\n\ndef mkdir(filename):\n    path = os.path.dirname(filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)\n\n\n# Formerly make-frozen.py.\n# This generates:\n# - MP_FROZEN_STR_NAMES macro\n# - mp_frozen_str_sizes\n# - mp_frozen_str_content\ndef generate_frozen_str_content(modules):\n    output = [\n        b\"#include <stdint.h>\\n\",\n        b\"#define MP_FROZEN_STR_NAMES \\\\\\n\",\n    ]\n\n    for _, target_path in modules:\n        print(\"STR\", target_path)\n        output.append(b'\"%s\\\\0\" \\\\\\n' % target_path.encode())\n    output.append(b\"\\n\")\n\n    output.append(b\"const uint32_t mp_frozen_str_sizes[] = { \")\n\n    for full_path, _ in modules:\n        st = os.stat(full_path)\n        output.append(b\"%d, \" % st.st_size)\n    output.append(b\"0 };\\n\")\n\n    output.append(b\"const char mp_frozen_str_content[] = {\\n\")\n    for full_path, _ in modules:\n        with open(full_path, \"rb\") as f:\n            data = f.read()\n\n            # We need to properly escape the script data to create a C string.\n            # When C parses hex characters of the form \\x00 it keeps parsing the hex\n            # data until it encounters a non-hex character.  Thus one must create\n            # strings of the form \"data\\x01\" \"abc\" to properly encode this kind of\n            # data.  We could just encode all characters as hex digits but it's nice\n            # to be able to read the resulting C code as ASCII when possible.\n\n            data = bytearray(data)  # so Python2 extracts each byte as an integer\n            esc_dict = {ord(\"\\n\"): b\"\\\\n\", ord(\"\\r\"): b\"\\\\r\", ord('\"'): b'\\\\\"', ord(\"\\\\\"): b\"\\\\\\\\\"}\n            output.append(b'\"')\n            break_str = False\n            for c in data:\n                try:\n                    output.append(esc_dict[c])\n                except KeyError:\n                    if 32 <= c <= 126:\n                        if break_str:\n                            output.append(b'\" \"')\n                            break_str = False\n                        output.append(chr(c).encode())\n                    else:\n                        output.append(b\"\\\\x%02x\" % c)\n                        break_str = True\n            output.append(b'\\\\0\"\\n')\n\n    output.append(b'\"\\\\0\"\\n};\\n\\n')\n    return b\"\".join(output)\n\n\ndef main():\n    # Parse arguments\n    import argparse\n\n    cmd_parser = argparse.ArgumentParser(\n        description=\"A tool to generate frozen content in MicroPython firmware images.\"\n    )\n    cmd_parser.add_argument(\"-o\", \"--output\", help=\"output path\")\n    cmd_parser.add_argument(\"-b\", \"--build-dir\", help=\"output path\")\n    cmd_parser.add_argument(\n        \"-f\", \"--mpy-cross-flags\", default=\"\", help=\"flags to pass to mpy-cross\"\n    )\n    cmd_parser.add_argument(\"-v\", \"--var\", action=\"append\", help=\"variables to substitute\")\n    cmd_parser.add_argument(\"--mpy-tool-flags\", default=\"\", help=\"flags to pass to mpy-tool\")\n    cmd_parser.add_argument(\"files\", nargs=\"+\", help=\"input manifest list\")\n    args = cmd_parser.parse_args()\n\n    # Extract variables for substitution.\n    for var in args.var:\n        name, value = var.split(\"=\", 1)\n        if os.path.exists(value):\n            value = os.path.abspath(value)\n        VARS[name] = value\n\n    if \"MPY_DIR\" not in VARS or \"PORT_DIR\" not in VARS:\n        print(\"MPY_DIR and PORT_DIR variables must be specified\")\n        sys.exit(1)\n\n    # Get paths to tools\n    MPY_CROSS = VARS[\"MPY_DIR\"] + \"/mpy-cross/build/mpy-cross\"\n    if sys.platform == \"win32\":\n        MPY_CROSS += \".exe\"\n    MPY_CROSS = os.getenv(\"MICROPY_MPYCROSS\", MPY_CROSS)\n    MPY_TOOL = VARS[\"MPY_DIR\"] + \"/tools/mpy-tool.py\"\n\n    # Ensure mpy-cross is built\n    if not os.path.exists(MPY_CROSS):\n        print(\"mpy-cross not found at {}, please build it first\".format(MPY_CROSS))\n        sys.exit(1)\n\n    manifest = manifestfile.ManifestFile(manifestfile.MODE_FREEZE, VARS)\n\n    # Include top-level inputs, to generate the manifest\n    for input_manifest in args.files:\n        try:\n            manifest.execute(input_manifest)\n        except manifestfile.ManifestFileError as er:\n            print('freeze error executing \"{}\": {}'.format(input_manifest, er.args[0]))\n            sys.exit(1)\n\n    # Process the manifest\n    str_paths = []\n    mpy_files = []\n    ts_newest = 0\n    for result in manifest.files():\n        if result.kind == manifestfile.KIND_FREEZE_AS_STR:\n            str_paths.append(\n                (\n                    result.full_path,\n                    result.target_path,\n                )\n            )\n            ts_outfile = result.timestamp\n        elif result.kind == manifestfile.KIND_FREEZE_AS_MPY:\n            outfile = \"{}/frozen_mpy/{}.mpy\".format(args.build_dir, result.target_path[:-3])\n            ts_outfile = get_timestamp(outfile, 0)\n            if result.timestamp >= ts_outfile:\n                print(\"MPY\", result.target_path)\n                mkdir(outfile)\n                # Add __version__ to the end of the file before compiling.\n                with manifestfile.tagged_py_file(result.full_path, result.metadata) as tagged_path:\n                    try:\n                        mpy_cross.compile(\n                            tagged_path,\n                            dest=outfile,\n                            src_path=result.target_path,\n                            opt=result.opt,\n                            mpy_cross=MPY_CROSS,\n                            extra_args=args.mpy_cross_flags.split(),\n                        )\n                    except mpy_cross.CrossCompileError as ex:\n                        print(\"error compiling {}:\".format(result.target_path))\n                        print(ex.args[0])\n                        raise SystemExit(1)\n                ts_outfile = get_timestamp(outfile)\n            mpy_files.append(outfile)\n        else:\n            assert result.kind == manifestfile.KIND_FREEZE_MPY\n            mpy_files.append(result.full_path)\n            ts_outfile = result.timestamp\n        ts_newest = max(ts_newest, ts_outfile)\n\n    # Check if output file needs generating\n    if ts_newest < get_timestamp(args.output, 0):\n        # No files are newer than output file so it does not need updating\n        return\n\n    # Freeze paths as strings\n    output_str = generate_frozen_str_content(str_paths)\n\n    # Freeze .mpy files\n    if mpy_files:\n        res, output_mpy = system(\n            [\n                sys.executable,\n                MPY_TOOL,\n                \"-f\",\n                \"-q\",\n                args.build_dir + \"/genhdr/qstrdefs.preprocessed.h\",\n            ]\n            + args.mpy_tool_flags.split()\n            + mpy_files\n        )\n        if res != 0:\n            print(\"error freezing mpy {}:\".format(mpy_files))\n            print(output_mpy.decode())\n            sys.exit(1)\n    else:\n        output_mpy = (\n            b'#include \"py/emitglue.h\"\\n'\n            b\"extern const qstr_pool_t mp_qstr_const_pool;\\n\"\n            b\"const qstr_pool_t mp_qstr_frozen_const_pool = {\\n\"\n            b\"    (qstr_pool_t*)&mp_qstr_const_pool, MP_QSTRnumber_of, 0, 0\\n\"\n            b\"};\\n\"\n            b'const char mp_frozen_names[] = { MP_FROZEN_STR_NAMES \"\\\\0\"};\\n'\n            b\"const mp_raw_code_t *const mp_frozen_mpy_content[] = {NULL};\\n\"\n        )\n\n    # Generate output\n    print(\"GEN\", args.output)\n    mkdir(args.output)\n    with open(args.output, \"wb\") as f:\n        f.write(b\"//\\n// Content for MICROPY_MODULE_FROZEN_STR\\n//\\n\")\n        f.write(output_str)\n        f.write(b\"//\\n// Content for MICROPY_MODULE_FROZEN_MPY\\n//\\n\")\n        f.write(output_mpy)\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}