{
  "module_name": "dfu.py",
  "hash_id": "1d37effd9d345f769cc59eebe571c1d1ccb3ed8fbea092859232064ca06660d5",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/dfu.py",
  "human_readable_source": "#!/usr/bin/python\n\n# Written by Antonio Galea - 2010/11/18\n# Distributed under Gnu LGPL 3.0\n# see http://www.gnu.org/licenses/lgpl-3.0.txt\n\nimport sys, struct, zlib, os\nfrom optparse import OptionParser\n\nDEFAULT_DEVICE = \"0x0483:0xdf11\"\n\n\ndef named(tuple, names):\n    return dict(zip(names.split(), tuple))\n\n\ndef consume(fmt, data, names):\n    n = struct.calcsize(fmt)\n    return named(struct.unpack(fmt, data[:n]), names), data[n:]\n\n\ndef cstring(string):\n    return string.split(b\"\\0\", 1)[0]\n\n\ndef compute_crc(data):\n    return 0xFFFFFFFF & -zlib.crc32(data) - 1\n\n\ndef parse(file, dump_images=False):\n    print('File: \"%s\"' % file)\n    data = open(file, \"rb\").read()\n    crc = compute_crc(data[:-4])\n    prefix, data = consume(\"<5sBIB\", data, \"signature version size targets\")\n    print(\"%(signature)s v%(version)d, image size: %(size)d, targets: %(targets)d\" % prefix)\n    for t in range(prefix[\"targets\"]):\n        tprefix, data = consume(\n            \"<6sBI255s2I\", data, \"signature altsetting named name size elements\"\n        )\n        tprefix[\"num\"] = t\n        if tprefix[\"named\"]:\n            tprefix[\"name\"] = cstring(tprefix[\"name\"])\n        else:\n            tprefix[\"name\"] = \"\"\n        print(\n            '%(signature)s %(num)d, alt setting: %(altsetting)s, name: \"%(name)s\", size: %(size)d, elements: %(elements)d'\n            % tprefix\n        )\n        tsize = tprefix[\"size\"]\n        target, data = data[:tsize], data[tsize:]\n        for e in range(tprefix[\"elements\"]):\n            eprefix, target = consume(\"<2I\", target, \"address size\")\n            eprefix[\"num\"] = e\n            print(\"  %(num)d, address: 0x%(address)08x, size: %(size)d\" % eprefix)\n            esize = eprefix[\"size\"]\n            image, target = target[:esize], target[esize:]\n            if dump_images:\n                out = \"%s.target%d.image%d.bin\" % (file, t, e)\n                open(out, \"wb\").write(image)\n                print('    DUMPED IMAGE TO \"%s\"' % out)\n        if len(target):\n            print(\"target %d: PARSE ERROR\" % t)\n    suffix = named(struct.unpack(\"<4H3sBI\", data[:16]), \"device product vendor dfu ufd len crc\")\n    print(\n        \"usb: %(vendor)04x:%(product)04x, device: 0x%(device)04x, dfu: 0x%(dfu)04x, %(ufd)s, %(len)d, 0x%(crc)08x\"\n        % suffix\n    )\n    if crc != suffix[\"crc\"]:\n        print(\"CRC ERROR: computed crc32 is 0x%08x\" % crc)\n    data = data[16:]\n    if data:\n        print(\"PARSE ERROR\")\n\n\ndef build(file, targets, device=DEFAULT_DEVICE):\n    data = b\"\"\n    for t, target in enumerate(targets):\n        tdata = b\"\"\n        for image in target:\n            # pad image to 8 bytes (needed at least for L476)\n            pad = (8 - len(image[\"data\"]) % 8) % 8\n            image[\"data\"] = image[\"data\"] + bytes(bytearray(8)[0:pad])\n            #\n            tdata += struct.pack(\"<2I\", image[\"address\"], len(image[\"data\"])) + image[\"data\"]\n        tdata = (\n            struct.pack(\"<6sBI255s2I\", b\"Target\", 0, 1, b\"ST...\", len(tdata), len(target)) + tdata\n        )\n        data += tdata\n    data = struct.pack(\"<5sBIB\", b\"DfuSe\", 1, len(data) + 11, len(targets)) + data\n    v, d = map(lambda x: int(x, 0) & 0xFFFF, device.split(\":\", 1))\n    data += struct.pack(\"<4H3sB\", 0, d, v, 0x011A, b\"UFD\", 16)\n    crc = compute_crc(data)\n    data += struct.pack(\"<I\", crc)\n    open(file, \"wb\").write(data)\n\n\nif __name__ == \"__main__\":\n    usage = \"\"\"\n%prog [-d|--dump] infile.dfu\n%prog {-b|--build} address:file.bin [-b address:file.bin ...] [{-D|--device}=vendor:device] outfile.dfu\"\"\"\n    parser = OptionParser(usage=usage)\n    parser.add_option(\n        \"-b\",\n        \"--build\",\n        action=\"append\",\n        dest=\"binfiles\",\n        help=\"build a DFU file from given BINFILES\",\n        metavar=\"BINFILES\",\n    )\n    parser.add_option(\n        \"-D\",\n        \"--device\",\n        action=\"store\",\n        dest=\"device\",\n        help=\"build for DEVICE, defaults to %s\" % DEFAULT_DEVICE,\n        metavar=\"DEVICE\",\n    )\n    parser.add_option(\n        \"-d\",\n        \"--dump\",\n        action=\"store_true\",\n        dest=\"dump_images\",\n        default=False,\n        help=\"dump contained images to current directory\",\n    )\n    (options, args) = parser.parse_args()\n\n    if options.binfiles and len(args) == 1:\n        target = []\n        for arg in options.binfiles:\n            try:\n                address, binfile = arg.split(\":\", 1)\n            except ValueError:\n                print(\"Address:file couple '%s' invalid.\" % arg)\n                sys.exit(1)\n            try:\n                address = int(address, 0) & 0xFFFFFFFF\n            except ValueError:\n                print(\"Address %s invalid.\" % address)\n                sys.exit(1)\n            if not os.path.isfile(binfile):\n                print(\"Unreadable file '%s'.\" % binfile)\n                sys.exit(1)\n            target.append({\"address\": address, \"data\": open(binfile, \"rb\").read()})\n        outfile = args[0]\n        device = DEFAULT_DEVICE\n        if options.device:\n            device = options.device\n        try:\n            v, d = map(lambda x: int(x, 0) & 0xFFFF, device.split(\":\", 1))\n        except:\n            print(\"Invalid device '%s'.\" % device)\n            sys.exit(1)\n        build(outfile, [target], device)\n    elif len(args) == 1:\n        infile = args[0]\n        if not os.path.isfile(infile):\n            print(\"Unreadable file '%s'.\" % infile)\n            sys.exit(1)\n        parse(infile, dump_images=options.dump_images)\n    else:\n        parser.print_help()\n        sys.exit(1)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}