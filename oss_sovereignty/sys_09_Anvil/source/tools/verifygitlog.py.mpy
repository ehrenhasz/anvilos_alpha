{
  "module_name": "verifygitlog.py",
  "hash_id": "8610a1f1ad0fc442a0ca0c66ab7cf01c238f63b0d623e598fe591cf968e2c77f",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/verifygitlog.py",
  "human_readable_source": "#!/usr/bin/env python3\n\nimport re\nimport subprocess\nimport sys\n\nverbosity = 0  # Show what's going on, 0 1 or 2.\nsuggestions = 1  # Set to 0 to not include lengthy suggestions in error messages.\n\nignore_prefixes = []\n\n\ndef verbose(*args):\n    if verbosity:\n        print(*args)\n\n\ndef very_verbose(*args):\n    if verbosity > 1:\n        print(*args)\n\n\nclass ErrorCollection:\n    # Track errors and warnings as the program runs\n    def __init__(self):\n        self.has_errors = False\n        self.has_warnings = False\n        self.prefix = \"\"\n\n    def error(self, text):\n        print(\"error: {}{}\".format(self.prefix, text))\n        self.has_errors = True\n\n    def warning(self, text):\n        print(\"warning: {}{}\".format(self.prefix, text))\n        self.has_warnings = True\n\n\ndef git_log(pretty_format, *args):\n    # Delete pretty argument from user args so it doesn't interfere with what we do.\n    args = [\"git\", \"log\"] + [arg for arg in args if \"--pretty\" not in args]\n    args.append(\"--pretty=format:\" + pretty_format)\n    very_verbose(\"git_log\", *args)\n    # Generator yielding each output line.\n    for line in subprocess.Popen(args, stdout=subprocess.PIPE).stdout:\n        yield line.decode().rstrip(\"\\r\\n\")\n\n\ndef diagnose_subject_line(subject_line, subject_line_format, err):\n    err.error(\"Subject line: \" + subject_line)\n    if not subject_line.endswith(\".\"):\n        err.error('* must end with \".\"')\n    if not re.match(r\"^[^!]+: \", subject_line):\n        err.error('* must start with \"path: \"')\n    if re.match(r\"^[^!]+: *$\", subject_line):\n        err.error(\"* must contain a subject after the path.\")\n    m = re.match(r\"^[^!]+: ([a-z][^ ]*)\", subject_line)\n    if m:\n        err.error('* first word of subject (\"{}\") must be capitalised.'.format(m.group(1)))\n    if re.match(r\"^[^!]+: [^ ]+$\", subject_line):\n        err.error(\"* subject must contain more than one word.\")\n    err.error(\"* must match: \" + repr(subject_line_format))\n    err.error('* Example: \"py/runtime: Add support for foo to bar.\"')\n\n\ndef verify(sha, err):\n    verbose(\"verify\", sha)\n    err.prefix = \"commit \" + sha + \": \"\n\n    # Author and committer email.\n    for line in git_log(\"%ae%n%ce\", sha, \"-n1\"):\n        very_verbose(\"email\", line)\n        if \"noreply\" in line:\n            err.error(\"Unwanted email address: \" + line)\n\n    # Message body.\n    raw_body = list(git_log(\"%B\", sha, \"-n1\"))\n    verify_message_body(raw_body, err)\n\n\ndef verify_message_body(raw_body, err):\n    if not raw_body:\n        err.error(\"Message is empty\")\n        return\n\n    # Subject line.\n    subject_line = raw_body[0]\n    for prefix in ignore_prefixes:\n        if subject_line.startswith(prefix):\n            verbose(\"Skipping ignored commit message\")\n            return\n    very_verbose(\"subject_line\", subject_line)\n    subject_line_format = r\"^[^!]+: [A-Z]+.+ .+\\.$\"\n    if not re.match(subject_line_format, subject_line):\n        diagnose_subject_line(subject_line, subject_line_format, err)\n    if len(subject_line) >= 73:\n        err.error(\"Subject line must be 72 or fewer characters: \" + subject_line)\n\n    # Second one divides subject and body.\n    if len(raw_body) > 1 and raw_body[1]:\n        err.error(\"Second message line must be empty: \" + raw_body[1])\n\n    # Message body lines.\n    for line in raw_body[2:]:\n        # Long lines with URLs are exempt from the line length rule.\n        if len(line) >= 76 and \"://\" not in line:\n            err.error(\"Message lines should be 75 or less characters: \" + line)\n\n    if not raw_body[-1].startswith(\"Signed-off-by: \") or \"@\" not in raw_body[-1]:\n        err.error('Message must be signed-off. Use \"git commit -s\".')\n\n\ndef run(args):\n    verbose(\"run\", *args)\n\n    err = ErrorCollection()\n\n    if \"--check-file\" in args:\n        filename = args[-1]\n        verbose(\"checking commit message from\", filename)\n        with open(args[-1]) as f:\n            # Remove comment lines as well as any empty lines at the end.\n            lines = [line.rstrip(\"\\r\\n\") for line in f if not line.startswith(\"#\")]\n            while not lines[-1]:\n                lines.pop()\n            verify_message_body(lines, err)\n    else:  # Normal operation, pass arguments to git log\n        for sha in git_log(\"%h\", *args):\n            verify(sha, err)\n\n    if err.has_errors or err.has_warnings:\n        if suggestions:\n            print(\"See https://github.com/micropython/micropython/blob/master/CODECONVENTIONS.md\")\n    else:\n        print(\"ok\")\n    if err.has_errors:\n        sys.exit(1)\n\n\ndef show_help():\n    print(\"usage: verifygitlog.py [-v -n -h --check-file] ...\")\n    print(\"-v  : increase verbosity, can be specified multiple times\")\n    print(\"-n  : do not print multi-line suggestions\")\n    print(\"-h  : print this help message and exit\")\n    print(\n        \"--check-file : Pass a single argument which is a file containing a candidate commit message\"\n    )\n    print(\n        \"--ignore-rebase : Skip checking commits with git rebase autosquash prefixes or WIP as a prefix\"\n    )\n    print(\"... : arguments passed to git log to retrieve commits to verify\")\n    print(\"      see https://www.git-scm.com/docs/git-log\")\n    print(\"      passing no arguments at all will verify all commits\")\n    print(\"examples:\")\n    print(\"verifygitlog.py -n10  # Check last 10 commits\")\n    print(\"verifygitlog.py -v master..HEAD  # Check commits since master\")\n\n\nif __name__ == \"__main__\":\n    args = sys.argv[1:]\n    verbosity = args.count(\"-v\")\n    suggestions = args.count(\"-n\") == 0\n    if \"--ignore-rebase\" in args:\n        args.remove(\"--ignore-rebase\")\n        ignore_prefixes = [\"squash!\", \"fixup!\", \"amend!\", \"WIP\"]\n\n    if \"-h\" in args:\n        show_help()\n    else:\n        args = [arg for arg in args if arg not in [\"-v\", \"-n\", \"-h\"]]\n        run(args)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}