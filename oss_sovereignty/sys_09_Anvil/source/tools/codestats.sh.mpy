{
  "module_name": "codestats.sh",
  "hash_id": "c823c192310dada5f0d30273f5e8c93da349786ea55826715397dfea63e77e86",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/codestats.sh",
  "human_readable_source": "#!/bin/sh\n#\n# This script generates statistics (build size, speed) for successive\n# revisions of the code.  It checks out git commits one an a time, compiles\n# various ports to determine their size, and runs pystone on the unix port.\n# Results are collected in the output file.\n#\n# Note: you will need to copy this file out of the tools directory before\n# executing because it does not exist in old revisions of the repository.\n\n# check that we are in the root directory of the repository\nif [ ! -d py -o ! -d ports/unix -o ! -d ports/stm32 ]; then\n    echo \"script must be run from root of the repository\"\n    exit 1\nfi\n\n# output file for the data; data is appended if file already exists\noutput=codestats.dat\n\n# utility programs\nRM=/bin/rm\nAWK=awk\nMAKE=\"make -j2\"\n\n# these are the binaries that are built; some have 2 or 3 depending on version\nbin_unix=ports/unix/build-standard/micropython\nbin_stm32=ports/stm32/build-PYBV10/firmware.elf\nbin_barearm_1=ports/bare-arm/build/flash.elf\nbin_barearm_2=ports/bare-arm/build/firmware.elf\nbin_minimal=ports/minimal/build/firmware.elf\nbin_cc3200_1=ports/cc3200/build/LAUNCHXL/application.axf\nbin_cc3200_2=ports/cc3200/build/LAUNCHXL/release/application.axf\nbin_cc3200_3=ports/cc3200/build/WIPY/release/application.axf\n\n# start at zero size; if build fails reuse previous valid size\nsize_unix=\"0\"\nsize_stm32=\"0\"\nsize_barearm=\"0\"\nsize_minimal=\"0\"\nsize_cc3200=\"0\"\n\n# start at zero pystones\npystones=\"0\"\n\n# this code runs pystone and averages the results\npystoneavg=/tmp/pystoneavg.py\ncat > $pystoneavg << EOF\nimport pystone\nsamples = [pystone.pystones(300000)[1] for i in range(5)]\nsamples.sort()\nstones = sum(samples[1:-1]) / (len(samples) - 2) # exclude smallest and largest\nprint(\"stones %g\" % stones)\nEOF\n\nfunction get_size() {\n    if [ -r $2 ]; then\n        size $2 | tail -n1 | $AWK '{print $1}'\n    else\n        echo $1\n    fi\n}\n\nfunction get_size2() {\n    if [ -r $2 ]; then\n        size $2 | tail -n1 | $AWK '{print $1}'\n    elif [ -r $3 ]; then\n        size $3 | tail -n1 | $AWK '{print $1}'\n    else\n        echo $1\n    fi\n}\n\nfunction get_size3() {\n    if [ -r $2 ]; then\n        size $2 | tail -n1 | $AWK '{print $1}'\n    elif [ -r $3 ]; then\n        size $3 | tail -n1 | $AWK '{print $1}'\n    elif [ -r $4 ]; then\n        size $4 | tail -n1 | $AWK '{print $1}'\n    else\n        echo $1\n    fi\n}\n\n# get the last revision in the data file; or start at v1.0 if no file\nif [ -r $output ]; then\n    last_rev=$(tail -n1 $output | $AWK '{print $1}')\nelse\n    echo \"# hash size_unix size_stm32 size_barearm size_minimal size_cc3200 pystones\" > $output\n    last_rev=\"v1.0\"\nfi\n\n# get a list of hashes between last revision (exclusive) and master\nhashes=$(git log --format=format:\"%H\" --reverse ${last_rev}..master)\n#hashes=$(git log --format=format:\"%H\" --reverse ${last_rev}..master | $AWK '{if (NR % 10 == 0) print $0}') # do every 10th one\n\nfor hash in $hashes; do\n\n    #### checkout the revision ####\n\n    git checkout $hash\n    if [ $? -ne 0 ]; then\n        echo \"aborting\"\n        exit 1\n    fi\n\n    #### apply patches to get it to build ####\n\n    if grep -q '#if defined(MP_CLOCKS_PER_SEC) && (MP_CLOCKS_PER_SEC == 1000000) // POSIX' unix/modtime.c; then\n        echo apply patch\n        git apply - << EOF\ndiff --git a/unix/modtime.c b/unix/modtime.c\nindex 77d2945..dae0644 100644\n--- a/unix/modtime.c\n+++ b/unix/modtime.c\n@@ -55,10 +55,8 @@ void msec_sleep_tv(struct timeval *tv) {\n #define MP_CLOCKS_PER_SEC CLOCKS_PER_SEC\n #endif\n\n-#if defined(MP_CLOCKS_PER_SEC) && (MP_CLOCKS_PER_SEC == 1000000) // POSIX\n-#define CLOCK_DIV 1000.0\n-#elif defined(MP_CLOCKS_PER_SEC) && (MP_CLOCKS_PER_SEC == 1000) // WIN32\n-#define CLOCK_DIV 1.0\n+#if defined(MP_CLOCKS_PER_SEC)\n+#define CLOCK_DIV (MP_CLOCKS_PER_SEC / 1000.0F)\n #else\n #error Unsupported clock() implementation\n #endif\nEOF\n    fi\n\n    #### unix ####\n\n    $RM $bin_unix\n    $MAKE -C ports/unix CFLAGS_EXTRA=-DNDEBUG\n    size_unix=$(get_size $size_unix $bin_unix)\n\n    # undo patch if it was applied\n    git checkout unix/modtime.c\n\n    #### stm32 ####\n\n    $RM $bin_stm32\n    $MAKE -C ports/stm32 board=PYBV10\n    size_stm32=$(get_size $size_stm32 $bin_stm32)\n\n    #### bare-arm ####\n\n    $RM $bin_barearm_1 $bin_barearm_2\n    $MAKE -C ports/bare-arm\n    size_barearm=$(get_size2 $size_barearm $bin_barearm_1 $bin_barearm_2)\n\n    #### minimal ####\n\n    if [ -r ports/minimal/Makefile ]; then\n        $RM $bin_minimal\n        $MAKE -C ports/minimal CROSS=1\n        size_minimal=$(get_size $size_minimal $bin_minimal)\n    fi\n\n    #### cc3200 ####\n\n    if [ -r ports/cc3200/Makefile ]; then\n        $RM $bin_cc3200_1 $bin_cc3200_2 $bin_cc3200_3\n        $MAKE -C ports/cc3200 BTARGET=application\n        size_cc3200=$(get_size3 $size_cc3200 $bin_cc3200_1 $bin_cc3200_2 $bin_cc3200_3)\n    fi\n\n    #### run pystone ####\n\n    if [ -x $bin_unix ]; then\n        new_pystones=$($bin_unix $pystoneavg)\n        # only update the variable if pystone executed successfully\n        if echo $new_pystones | grep -q \"^stones\"; then\n            pystones=$(echo $new_pystones | $AWK '{print $2}')\n        fi\n    fi\n\n    #### output data for this commit ####\n\n    echo \"$hash $size_unix $size_stm32 $size_barearm $size_minimal $size_cc3200 $pystones\" >> $output\n\ndone\n\n# checkout master and cleanup\ngit checkout master\n$RM $pystoneavg\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}