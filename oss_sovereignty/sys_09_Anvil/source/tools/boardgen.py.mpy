{
  "module_name": "boardgen.py",
  "hash_id": "c990e965d2a0944ecbf9fce6a8a37e7b31d07537a7b22d26e47067bbd6e1d65c",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/boardgen.py",
  "human_readable_source": "# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2023 Jim Mussared\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n# This script contains common functionality to assist a port in implementing\n# make-pins.py, which is used to emit compile-time definitions of pin, AF, and\n# ADC objects based on inputs from the vendor HAL/SDK and the board\n# definition's pins.csv.\n\n# The pins.csv file can contain empty lines, comments (a line beginning with \"#\")\n# or pin definition lines.  Pin definition lines must be of the form:\n#\n#     board,cpu\n#\n# Where \"board\" is the user-facing name of the pin as specified by the particular\n# board layout and markings, and \"cpu\" is the corresponding name of the CPU/MCU\n# pin.\n#\n# The \"board\" entry may be absent if the CPU pin has no additional name, and both\n# entries may start with \"-\" to hide them from the corresponding Python dict of\n# pins, and hence hide them from the user (but they are still accessible in C).\n#\n# For example, take the following pins.csv file:\n#\n#     X1,PA0\n#     -X2,PA1\n#     X3,-PA2\n#     -X4,-PA3\n#     ,PA4\n#     ,-PA5\n#\n# The first row here configures:\n# - The CPU pin PA0 is labelled X1.\n# - The Python user can access both by the names Pin(\"X1\") and Pin(\"A0\").\n# - The Python user can access both by the members Pin.board.X1 and Pin.cpu.A0.\n# - In C code they are available as pyb_pin_X1 and pin_A0.\n#\n# Prefixing the names with \"-\" hides them from the user.  The following table\n# summarises the various possibilities:\n#\n#     pins.csv entry | board name | cpu name | C board name | C cpu name\n#     ---------------+------------+----------+--------------+-----------\n#     X1,PA0           \"X1\"         \"A0\"       pyb_pin_X1     pin_A0\n#     -X2,PA1          -            \"A1\"       pyb_pin_X2     pin_A1\n#     X3,-PA2          \"X3\"         -          pyb_pin_X3     pin_A2\n#     -X4,-PA3         -            -          pyb_pin_X4     pin_A3\n#     ,PA4             -            \"A4\"       -              pin_A4\n#     ,-PA5            -            -          -              pin_A5\n\nimport argparse\nimport csv\nimport os\nimport sys\n\n\nclass PinGeneratorError(Exception):\n    pass\n\n\n# A port should define a subclass of Pin that knows how to validate cpu/board\n# names and emits the required structures.\nclass Pin:\n    def __init__(self, cpu_pin_name):\n        self._cpu_pin_name = cpu_pin_name\n        # Optional aliases for the board from pins.csv. Each entry is a tuple\n        # of (name, hidden). Hidden board pins are in pins.csv with with a \"-\"\n        # prefix and will available to C but not Python.\n        self._board_pin_names = set()\n        # An unavailable pin is one that is not explicitly mentioned at all in\n        # pins.csv (or added explicitly with PinGenerator.add_cpu_pin).\n        self._available = False\n        # A hidden pin is one that is in pins.csv with a \"-\" prefix and will\n        # be still available to C but not Python.\n        self._hidden = False\n        # Reference to the PinGenerator instance.\n        self._generator = None\n\n    # The name of the pin to use in MP_QSTR_{} or pin_{}. Defaults to the cpu name.\n    def name(self):\n        return self._cpu_pin_name\n\n    # Add a board alias (e.g. from pins.csv).\n    def add_board_pin_name(self, board_pin_name, hidden=False):\n        self._board_pin_names.add(\n            (\n                board_pin_name,\n                hidden,\n            )\n        )\n\n    # Override this to handle an af specified in af.csv.\n    def add_af(self, af_idx, af_name, af):\n        raise NotImplementedError\n\n    # Override this to verify that naming matches the MCU standard (e.g. \"GPIOn\" or \"PXn\").\n    @staticmethod\n    def validate_cpu_pin_name(cpu_pin_name):\n        if not cpu_pin_name.strip():\n            raise PinGeneratorError(\"Missing cpu pin name\")\n\n    # Override this to provide additional validation of board names.\n    @staticmethod\n    def validate_board_pin_name(board_pin_name):\n        # TODO: ensure this is a valid Python/C identifier and can be used as MP_QSTR_foo.\n        pass\n\n    # Must be implemented when using NumericPinGenerator.\n    # Returns the integer index, or None to exclude this pin from the table.\n    def index(self):\n        raise NotImplementedError\n\n    # Can be overridden when using NumericPinGenerator.\n    # Returns a string which is a C expression that evaluates to the index\n    # e.g. `GPIO_NUM_7`.\n    # This is used whenever the index is emitted in source code and defaults\n    # to just returning the pin index as a literal.\n    # Return None to exclude this pin from the table.\n    def index_name(self):\n        i = self.index()\n        return str(i) if i is not None else None\n\n    # Returns an expression that defines the pin. e.g. `{ .base { ... }, .x }`.\n    # This is used as the RHS of the `const machine_pin_obj_t\n    # pin_EXT_GPIO0_obj =` statements for named pins, and elements of\n    # `machine_pin_obj_table` for numeric pins.\n    # This will typically might be implemented as an invocation of a macro\n    # defined in the port-specific prefix.\n    def definition(self):\n        raise NotImplementedError\n\n    # Whether the pin object should be declared as \"const\". This should be True\n    # for most pins, but some special cases (e.g. external pins on rp2) might\n    # need mutable pin objects (e.g. to track current pin state).\n    def is_const(self):\n        return True\n\n    # Optionally return a preprocessor expression that can be used to suppress\n    # this pin (e.g. `MICROPY_HW_ENABLE_GPIOn`).\n    def enable_macro(self):\n        return None\n\n    # Override this to output any additional per-pin definitions or other\n    # content that should appear at the start of the source output.\n    # This could be used to define additional objects such as IRQs or AFs.\n    def print_source(self, out_source):\n        pass\n\n\n# A port should define a subclass of PinGenerator (or NumericPinGenerator).\nclass PinGenerator:\n    def __init__(self, pin_type, enable_af=False):\n        self._pins = []\n        self._pin_type = pin_type\n        self._enable_af = enable_af\n\n    # Allows a port to define a known cpu pin (without relying on it being in the\n    # csv file).\n    def add_cpu_pin(self, cpu_pin_name, available=True):\n        pin = self._pin_type(cpu_pin_name)\n        pin._available = available\n        self._pins.append(pin)\n        pin._generator = self\n        return pin\n\n    # Iterate just the available pins (i.e. ones in pins.csv).\n    def available_pins(self, exclude_hidden=False):\n        for pin in self._pins:\n            if not pin._available:\n                continue\n            if exclude_hidden and pin._hidden:\n                continue\n            yield pin\n\n    # Allows a port to add additional command-line arguments to be handled.\n    def extra_args(self, parser):\n        pass\n\n    # Load board->cpu mapping from csv.\n    def parse_board_csv(self, filename):\n        with open(filename, \"r\") as csvfile:\n            rows = csv.reader(csvfile)\n            for linenum, row in enumerate(rows):\n                try:\n                    # Skip empty lines, and lines starting with \"#\".\n                    if len(row) == 0 or row[0].startswith(\"#\"):\n                        continue\n\n                    # Lines must be pairs of names.\n                    if len(row) != 2:\n                        raise PinGeneratorError(\"Expecting two entries in each row\")\n                    board_pin_name, cpu_pin_name = (x.strip() for x in row)\n\n                    # All rows must include a cpu name.\n                    cpu_hidden = False\n                    if cpu_pin_name.startswith(\"-\"):\n                        cpu_hidden = True\n                        cpu_pin_name = cpu_pin_name[1:]\n                    self._pin_type.validate_cpu_pin_name(cpu_pin_name)\n                    pin = self.find_pin_by_cpu_pin_name(cpu_pin_name, create=True)\n                    pin._available = True  # It's in pins.csv so must be available.\n                    pin._hidden = cpu_hidden  # Optionally don't make available to Python.\n\n                    # Rows can optionally alias to a board name.\n                    if board_pin_name:\n                        board_hidden = False\n                        if board_pin_name.startswith(\"-\"):\n                            board_hidden = True\n                            board_pin_name = board_pin_name[1:]\n                        self._pin_type.validate_board_pin_name(board_pin_name)\n                        pin.add_board_pin_name(board_pin_name, board_hidden)\n\n                # Inject \"file:line: \" into the exception.\n                except PinGeneratorError as er:\n                    raise PinGeneratorError(\"{}:{}: {}\".format(filename, linenum, er))\n\n    def parse_af_csv(self, filename, header_rows=1, pin_col=0, af_col=1):\n        headings = {}\n        with open(filename, \"r\") as csvfile:\n            rows = csv.reader(csvfile)\n            for linenum, row in enumerate(rows):\n                try:\n                    # Skip empty lines, and lines starting with \"#\".\n                    if len(row) == 0 or row[0].startswith(\"#\"):\n                        continue\n\n                    # Consume `header_rows` non-blank/comment rows at the start.\n                    if header_rows:\n                        if not headings:\n                            # If this is the first header row then initialise\n                            # the headings dict.\n                            for af_idx, header in enumerate(row[af_col:]):\n                                headings[af_idx] = header.strip()\n                        header_rows -= 1\n                        continue\n\n                    # Lines must be pairs of names.\n                    if len(row) <= max(pin_col, af_col):\n                        raise PinGeneratorError(\n                            \"Expecting {} entries in each row\".format(max(pin_col, af_col))\n                        )\n\n                    cpu_pin_name = row[pin_col].strip()\n                    if cpu_pin_name == \"-\":\n                        continue\n                    self._pin_type.validate_cpu_pin_name(cpu_pin_name)\n                    pin = self.find_pin_by_cpu_pin_name(cpu_pin_name, create=True)\n\n                    for af_idx, af in enumerate(row[af_col:]):\n                        af = af.strip()\n                        if not af:\n                            continue\n                        pin.add_af(af_idx, headings.get(af_idx, \"\"), af)\n\n                # Inject \"file:line: \" into the exception.\n                except PinGeneratorError as er:\n                    raise PinGeneratorError(\"{}:{}: {}\".format(filename, linenum, er))\n\n    # Find an existing pin.\n    def find_pin_by_cpu_pin_name(self, cpu_pin_name, create=True):\n        for pin in self._pins:\n            if pin._cpu_pin_name == cpu_pin_name:\n                return pin\n        if create:\n            return self.add_cpu_pin(cpu_pin_name, available=False)\n        else:\n            raise PinGeneratorError(\"Unknown cpu pin {}\".format(cpu_pin_name))\n\n    # Print the locals dict for Pin.board.\n    def print_board_locals_dict(self, out_source):\n        print(file=out_source)\n        print(\n            \"static const mp_rom_map_elem_t machine_pin_board_pins_locals_dict_table[] = {\",\n            file=out_source,\n        )\n        for pin in self.available_pins():\n            for board_pin_name, board_hidden in pin._board_pin_names:\n                if board_hidden:\n                    # Don't include hidden pins in Pins.board.\n                    continue\n\n                # We don't use the enable macro for board pins, because they\n                # shouldn't be referenced in pins.csv unless they're\n                # available.\n                print(\n                    \"    {{ MP_ROM_QSTR(MP_QSTR_{:s}), MP_ROM_PTR(pin_{:s}) }},\".format(\n                        board_pin_name,\n                        pin.name(),\n                    ),\n                    file=out_source,\n                )\n        print(\"};\", file=out_source)\n        print(\n            \"MP_DEFINE_CONST_DICT(machine_pin_board_pins_locals_dict, machine_pin_board_pins_locals_dict_table);\",\n            file=out_source,\n        )\n\n    # Print the locals dict for Pin.cpu.\n    def print_cpu_locals_dict(self, out_source):\n        print(file=out_source)\n        print(\n            \"static const mp_rom_map_elem_t machine_pin_cpu_pins_locals_dict_table[] = {\",\n            file=out_source,\n        )\n        for pin in self.available_pins(exclude_hidden=True):\n            m = pin.enable_macro()\n            if m:\n                print(\"    #if {}\".format(m), file=out_source)\n            print(\n                \"    {{ MP_ROM_QSTR(MP_QSTR_{:s}), MP_ROM_PTR(pin_{:s}) }},\".format(\n                    pin.name(),\n                    pin.name(),\n                ),\n                file=out_source,\n            )\n            if m:\n                print(\"    #endif\", file=out_source)\n        print(\"};\", file=out_source)\n        print(\n            \"MP_DEFINE_CONST_DICT(machine_pin_cpu_pins_locals_dict, machine_pin_cpu_pins_locals_dict_table);\",\n            file=out_source,\n        )\n\n    # NumericPinGenerator can override this to use an entry in machine_pin_obj_table.\n    def _cpu_pin_pointer(self, pin):\n        return \"&pin_{:s}_obj\".format(pin.name())\n\n    # Allow a port to prefix the board pin macro names with something.\n    # e.g. STM32 does pyb_pin_NAME whereas other ports using pin_NAME.\n    def board_name_define_prefix(self):\n        return \"\"\n\n    # Print the pin_CPUNAME and pin_BOARDNAME macros.\n    def print_defines(self, out_header, cpu=True, board=True):\n        # Provide #defines for each cpu pin.\n        for pin in self.available_pins():\n            print(file=out_header)\n            m = pin.enable_macro()\n            if m:\n                print(\"#if {}\".format(m), file=out_header)\n\n            # #define pin_CPUNAME (...)\n            if cpu:\n                print(\n                    \"#define pin_{:s} ({:s})\".format(pin.name(), self._cpu_pin_pointer(pin)),\n                    file=out_header,\n                )\n\n            # #define pin_BOARDNAME (pin_CPUNAME)\n            if board:\n                for board_pin_name, _board_hidden in pin._board_pin_names:\n                    # Note: Hidden board pins are still available to C via the macro.\n                    # Note: The RHS isn't wrapped in (), which is necessary to make the\n                    # STATIC_AF_ macro work on STM32.\n                    print(\n                        \"#define {:s}pin_{:s} pin_{:s}\".format(\n                            self.board_name_define_prefix(),\n                            board_pin_name,\n                            pin.name(),\n                        ),\n                        file=out_header,\n                    )\n\n            if m:\n                print(\"#endif\", file=out_header)\n\n    def print_pin_objects(self, out_source):\n        print(file=out_source)\n        for pin in self.available_pins():\n            m = pin.enable_macro()\n            if m:\n                print(\"#if {}\".format(m), file=out_source)\n            print(\n                \"{:s}machine_pin_obj_t pin_{:s}_obj = {:s};\".format(\n                    \"const \" if pin.is_const() else \"\",\n                    pin.name(),\n                    pin.definition(),\n                ),\n                file=out_source,\n            )\n            if m:\n                print(\"#endif\", file=out_source)\n\n    def print_pin_object_externs(self, out_header):\n        print(file=out_header)\n        for pin in self.available_pins():\n            m = pin.enable_macro()\n            if m:\n                print(\"#if {}\".format(m), file=out_header)\n            print(\n                \"extern {:s}machine_pin_obj_t pin_{:s}_obj;\".format(\n                    \"const \" if pin.is_const() else \"\",\n                    pin.name(),\n                ),\n                file=out_header,\n            )\n            if m:\n                print(\"#endif\", file=out_header)\n\n    def print_source(self, out_source):\n        self.print_pin_objects(out_source)\n        self.print_cpu_locals_dict(out_source)\n        self.print_board_locals_dict(out_source)\n\n    def print_header(self, out_header):\n        self.print_pin_object_externs(out_header)\n        self.print_defines(out_header)\n\n    # A port can override this if it has extra input files (e.g. af.csv) to load.\n    def load_inputs(self, out_source):\n        # Optionally load pins.csv to get cpu->board name mappings.\n        if self._enable_af and self.args.af_csv:\n            print(\"// --af-csv {:s}\".format(self.args.af_csv), file=out_source)\n            self.parse_af_csv(self.args.af_csv)\n\n        # Optionally load pins.csv to get cpu->board name mappings.\n        if self.args.board_csv:\n            print(\"// --board-csv {:s}\".format(self.args.board_csv), file=out_source)\n            self.parse_board_csv(self.args.board_csv)\n\n        # Prepend the prefix file to the start of the output.\n        if self.args.prefix:\n            print(\"// --prefix {:s}\".format(self.args.prefix), file=out_source)\n            print(file=out_source)\n            with open(self.args.prefix, \"r\") as prefix_file:\n                print(prefix_file.read(), end=\"\", file=out_source)\n\n    # A port can override this to do extra work after the main source+header\n    # have been written, such as generating additional header files.\n    def generate_extra_files(self):\n        pass\n\n    def main(self):\n        parser = argparse.ArgumentParser(description=\"Generate board specific pin file\")\n        parser.add_argument(\"--board-csv\")\n        if self._enable_af:\n            parser.add_argument(\"--af-csv\")\n        parser.add_argument(\"--prefix\")\n        parser.add_argument(\"--output-source\")\n        parser.add_argument(\"--output-header\")\n        self.extra_args(parser)\n        self.args = parser.parse_args()\n\n        try:\n            with open(self.args.output_source, \"w\") as out_source:\n                print(\"// This file was automatically generated by make-pins.py\", file=out_source)\n                print(\"//\", file=out_source)\n\n                # Load additional files (including port-specific ones).\n                self.load_inputs(out_source)\n\n                # Allow a port to print arbitrary per-pin content.\n                for pin in self.available_pins():\n                    pin.print_source(out_source)\n\n                # Print the tables and dictionaries.\n                self.print_source(out_source)\n\n            with open(self.args.output_header, \"w\") as out_header:\n                self.print_header(out_header)\n\n            self.generate_extra_files()\n        except PinGeneratorError as er:\n            print(er)\n            sys.exit(1)\n\n\n# For ports that use numeric pin identifiers (e.g. ESP32, rp2).\n# This emits the machine_pin_obj_t instances as an array (machine_pin_obj_table).\nclass NumericPinGenerator(PinGenerator):\n    # This should return a const expression that is the number of GPIO pins\n    # for this board.\n    def cpu_table_size(self):\n        raise NotImplementedError\n\n    def print_cpu_table(self, out_source):\n        # Print machine_pin_obj_table, where each element is `[n] = {obj}`.\n        print(file=out_source)\n        print(\n            \"const machine_pin_obj_t machine_pin_obj_table[{}] = {{\".format(self.cpu_table_size()),\n            file=out_source,\n        )\n        for pin in self.available_pins():\n            n = pin.index_name()\n            if n is None:\n                continue\n\n            m = pin.enable_macro()\n            if m:\n                print(\"    #if {}\".format(m), file=out_source)\n            print(\n                \"    [{:s}] = {:s},\".format(\n                    pin.index_name(),\n                    pin.definition(),\n                ),\n                file=out_source,\n            )\n            if m:\n                print(\"    #endif\", file=out_source)\n        print(\"};\", file=out_source)\n\n        # For pins that do not have an index, print them out in the same style as PinGenerator.\n        print(file=out_source)\n        for pin in self.available_pins():\n            n = pin.index_name()\n            if n is not None:\n                continue\n\n            m = pin.enable_macro()\n            if m:\n                print(\"#if {}\".format(m), file=out_source)\n            print(\n                \"{:s}machine_pin_obj_t pin_{:s}_obj = {:s};\".format(\n                    \"const \" if pin.is_const() else \"\",\n                    pin.name(),\n                    pin.definition(),\n                ),\n                file=out_source,\n            )\n            if m:\n                print(\"#endif\", file=out_source)\n\n    # Replace PinGenerator's implementation to print the numeric table.\n    def print_source(self, out_source):\n        self.print_cpu_table(out_source)\n        self.print_board_locals_dict(out_source)\n\n    # Replace PinGenerator's implementation to only print the defines.\n    def print_header(self, out_header):\n        self.print_defines(out_header)\n\n    def _cpu_pin_pointer(self, pin):\n        n = pin.index_name()\n        if n is not None:\n            return \"&machine_pin_obj_table[{:s}]\".format(pin.index_name())\n        else:\n            return super()._cpu_pin_pointer(pin)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}