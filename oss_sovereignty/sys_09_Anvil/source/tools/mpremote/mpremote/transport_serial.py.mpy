{
  "module_name": "transport_serial.py",
  "hash_id": "3b8e7e5ca261ad88b587113ec7b98063c07375865bcf34e96c92bd53b1b76492",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpremote/mpremote/transport_serial.py",
  "human_readable_source": "#!/usr/bin/env python3\n#\n# This file is part of the MicroPython project, http://micropython.org/\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2014-2021 Damien P. George\n# Copyright (c) 2017 Paul Sokolovsky\n# Copyright (c) 2023 Jim Mussared\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\n# This is based on the serial-only parts of tools/pyboard.py, with Python 2\n# support removed, and is currently in the process of being refactored to\n# support multiple transports (webrepl, socket, BLE, etc). At the moment,\n# SerialTransport is just the old Pyboard+PyboardExtended class without any\n# of this refactoring. The API is going to change significantly.\n\n# Once the API is stabilised, the idea is that mpremote can be used both\n# as a command line tool and a library for interacting with devices.\n\nimport ast, io, errno, os, re, struct, sys, time\nfrom collections import namedtuple\nfrom errno import EPERM\nfrom .console import VT_ENABLED\nfrom .transport import TransportError, Transport\n\n\ndef stdout_write_bytes(b):\n    b = b.replace(b\"\\x04\", b\"\")\n    sys.stdout.buffer.write(b)\n    sys.stdout.buffer.flush()\n\n\nlistdir_result = namedtuple(\"dir_result\", [\"name\", \"st_mode\", \"st_ino\", \"st_size\"])\n\n\ndef reraise_filesystem_error(e, info):\n    if len(e.args) >= 3:\n        if b\"OSError\" in e.args[2] and b\"ENOENT\" in e.args[2]:\n            raise FileNotFoundError(info)\n    raise\n\n\nclass SerialTransport(Transport):\n    def __init__(self, device, baudrate=115200, wait=0, exclusive=True):\n        self.in_raw_repl = False\n        self.use_raw_paste = True\n        self.device_name = device\n        self.mounted = False\n\n        import serial\n        import serial.tools.list_ports\n\n        # Set options, and exclusive if pyserial supports it\n        serial_kwargs = {\"baudrate\": baudrate, \"interCharTimeout\": 1}\n        if serial.__version__ >= \"3.3\":\n            serial_kwargs[\"exclusive\"] = exclusive\n\n        delayed = False\n        for attempt in range(wait + 1):\n            try:\n                if device.startswith(\"rfc2217://\"):\n                    self.serial = serial.serial_for_url(device, **serial_kwargs)\n                elif os.name == \"nt\":\n                    self.serial = serial.Serial(**serial_kwargs)\n                    self.serial.port = device\n                    portinfo = list(serial.tools.list_ports.grep(device))  # type: ignore\n                    if portinfo and portinfo[0].manufacturer != \"Microsoft\":\n                        # ESP8266/ESP32 boards use RTS/CTS for flashing and boot mode selection.\n                        # DTR False: to avoid using the reset button will hang the MCU in bootloader mode\n                        # RTS False: to prevent pulses on rts on serial.close() that would POWERON_RESET an ESPxx\n                        self.serial.dtr = False  # DTR False = gpio0 High = Normal boot\n                        self.serial.rts = False  # RTS False = EN High = MCU enabled\n                    self.serial.open()\n                else:\n                    self.serial = serial.Serial(device, **serial_kwargs)\n                break\n            except OSError:\n                if wait == 0:\n                    continue\n                if attempt == 0:\n                    sys.stdout.write(\"Waiting {} seconds for pyboard \".format(wait))\n                    delayed = True\n            time.sleep(1)\n            sys.stdout.write(\".\")\n            sys.stdout.flush()\n        else:\n            if delayed:\n                print(\"\")\n            raise TransportError(\"failed to access \" + device)\n        if delayed:\n            print(\"\")\n\n    def close(self):\n        self.serial.close()\n\n    def read_until(self, min_num_bytes, ending, timeout=10, data_consumer=None):\n        # if data_consumer is used then data is not accumulated and the ending must be 1 byte long\n        assert data_consumer is None or len(ending) == 1\n\n        data = self.serial.read(min_num_bytes)\n        if data_consumer:\n            data_consumer(data)\n        timeout_count = 0\n        while True:\n            if data.endswith(ending):\n                break\n            elif self.serial.inWaiting() > 0:\n                new_data = self.serial.read(1)\n                if data_consumer:\n                    data_consumer(new_data)\n                    data = new_data\n                else:\n                    data = data + new_data\n                timeout_count = 0\n            else:\n                timeout_count += 1\n                if timeout is not None and timeout_count >= 100 * timeout:\n                    break\n                time.sleep(0.01)\n        return data\n\n    def enter_raw_repl(self, soft_reset=True):\n        self.serial.write(b\"\\r\\x03\\x03\")  # ctrl-C twice: interrupt any running program\n\n        # flush input (without relying on serial.flushInput())\n        n = self.serial.inWaiting()\n        while n > 0:\n            self.serial.read(n)\n            n = self.serial.inWaiting()\n\n        self.serial.write(b\"\\r\\x01\")  # ctrl-A: enter raw REPL\n\n        if soft_reset:\n            data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n>\")\n            if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n>\"):\n                print(data)\n                raise TransportError(\"could not enter raw repl\")\n\n            self.serial.write(b\"\\x04\")  # ctrl-D: soft reset\n\n            # Waiting for \"soft reboot\" independently to \"raw REPL\" (done below)\n            # allows boot.py to print, which will show up after \"soft reboot\"\n            # and before \"raw REPL\".\n            data = self.read_until(1, b\"soft reboot\\r\\n\")\n            if not data.endswith(b\"soft reboot\\r\\n\"):\n                print(data)\n                raise TransportError(\"could not enter raw repl\")\n\n        data = self.read_until(1, b\"raw REPL; CTRL-B to exit\\r\\n\")\n        if not data.endswith(b\"raw REPL; CTRL-B to exit\\r\\n\"):\n            print(data)\n            raise TransportError(\"could not enter raw repl\")\n\n        self.in_raw_repl = True\n\n    def exit_raw_repl(self):\n        self.serial.write(b\"\\r\\x02\")  # ctrl-B: enter friendly REPL\n        self.in_raw_repl = False\n\n    def follow(self, timeout, data_consumer=None):\n        # wait for normal output\n        data = self.read_until(1, b\"\\x04\", timeout=timeout, data_consumer=data_consumer)\n        if not data.endswith(b\"\\x04\"):\n            raise TransportError(\"timeout waiting for first EOF reception\")\n        data = data[:-1]\n\n        # wait for error output\n        data_err = self.read_until(1, b\"\\x04\", timeout=timeout)\n        if not data_err.endswith(b\"\\x04\"):\n            raise TransportError(\"timeout waiting for second EOF reception\")\n        data_err = data_err[:-1]\n\n        # return normal and error output\n        return data, data_err\n\n    def raw_paste_write(self, command_bytes):\n        # Read initial header, with window size.\n        data = self.serial.read(2)\n        window_size = struct.unpack(\"<H\", data)[0]\n        window_remain = window_size\n\n        # Write out the command_bytes data.\n        i = 0\n        while i < len(command_bytes):\n            while window_remain == 0 or self.serial.inWaiting():\n                data = self.serial.read(1)\n                if data == b\"\\x01\":\n                    # Device indicated that a new window of data can be sent.\n                    window_remain += window_size\n                elif data == b\"\\x04\":\n                    # Device indicated abrupt end.  Acknowledge it and finish.\n                    self.serial.write(b\"\\x04\")\n                    return\n                else:\n                    # Unexpected data from device.\n                    raise TransportError(\"unexpected read during raw paste: {}\".format(data))\n            # Send out as much data as possible that fits within the allowed window.\n            b = command_bytes[i : min(i + window_remain, len(command_bytes))]\n            self.serial.write(b)\n            window_remain -= len(b)\n            i += len(b)\n\n        # Indicate end of data.\n        self.serial.write(b\"\\x04\")\n\n        # Wait for device to acknowledge end of data.\n        data = self.read_until(1, b\"\\x04\")\n        if not data.endswith(b\"\\x04\"):\n            raise TransportError(\"could not complete raw paste: {}\".format(data))\n\n    def exec_raw_no_follow(self, command):\n        if isinstance(command, bytes):\n            command_bytes = command\n        else:\n            command_bytes = bytes(command, encoding=\"utf8\")\n\n        # check we have a prompt\n        data = self.read_until(1, b\">\")\n        if not data.endswith(b\">\"):\n            raise TransportError(\"could not enter raw repl\")\n\n        if self.use_raw_paste:\n            # Try to enter raw-paste mode.\n            self.serial.write(b\"\\x05A\\x01\")\n            data = self.serial.read(2)\n            if data == b\"R\\x00\":\n                # Device understood raw-paste command but doesn't support it.\n                pass\n            elif data == b\"R\\x01\":\n                # Device supports raw-paste mode, write out the command using this mode.\n                return self.raw_paste_write(command_bytes)\n            else:\n                # Device doesn't support raw-paste, fall back to normal raw REPL.\n                data = self.read_until(1, b\"w REPL; CTRL-B to exit\\r\\n>\")\n                if not data.endswith(b\"w REPL; CTRL-B to exit\\r\\n>\"):\n                    print(data)\n                    raise TransportError(\"could not enter raw repl\")\n            # Don't try to use raw-paste mode again for this connection.\n            self.use_raw_paste = False\n\n        # Write command using standard raw REPL, 256 bytes every 10ms.\n        for i in range(0, len(command_bytes), 256):\n            self.serial.write(command_bytes[i : min(i + 256, len(command_bytes))])\n            time.sleep(0.01)\n        self.serial.write(b\"\\x04\")\n\n        # check if we could exec command\n        data = self.serial.read(2)\n        if data != b\"OK\":\n            raise TransportError(\"could not exec command (response: %r)\" % data)\n\n    def exec_raw(self, command, timeout=10, data_consumer=None):\n        self.exec_raw_no_follow(command)\n        return self.follow(timeout, data_consumer)\n\n    def eval(self, expression, parse=False):\n        if parse:\n            ret = self.exec(\"print(repr({}))\".format(expression))\n            ret = ret.strip()\n            return ast.literal_eval(ret.decode())\n        else:\n            ret = self.exec(\"print({})\".format(expression))\n            ret = ret.strip()\n            return ret\n\n    def exec(self, command, data_consumer=None):\n        ret, ret_err = self.exec_raw(command, data_consumer=data_consumer)\n        if ret_err:\n            raise TransportError(\"exception\", ret, ret_err)\n        return ret\n\n    def execfile(self, filename):\n        with open(filename, \"rb\") as f:\n            pyfile = f.read()\n        return self.exec(pyfile)\n\n    def fs_exists(self, src):\n        try:\n            self.exec(\"import os\\nos.stat(%s)\" % ((\"'%s'\" % src) if src else \"\"))\n            return True\n        except TransportError:\n            return False\n\n    def fs_ls(self, src):\n        cmd = (\n            \"import os\\nfor f in os.ilistdir(%s):\\n\"\n            \" print('{:12} {}{}'.format(f[3]if len(f)>3 else 0,f[0],'/'if f[1]&0x4000 else ''))\"\n            % ((\"'%s'\" % src) if src else \"\")\n        )\n        self.exec(cmd, data_consumer=stdout_write_bytes)\n\n    def fs_listdir(self, src=\"\"):\n        buf = bytearray()\n\n        def repr_consumer(b):\n            buf.extend(b.replace(b\"\\x04\", b\"\"))\n\n        cmd = \"import os\\nfor f in os.ilistdir(%s):\\n\" \" print(repr(f), end=',')\" % (\n            (\"'%s'\" % src) if src else \"\"\n        )\n        try:\n            buf.extend(b\"[\")\n            self.exec(cmd, data_consumer=repr_consumer)\n            buf.extend(b\"]\")\n        except TransportError as e:\n            reraise_filesystem_error(e, src)\n\n        return [\n            listdir_result(*f) if len(f) == 4 else listdir_result(*(f + (0,)))\n            for f in ast.literal_eval(buf.decode())\n        ]\n\n    def fs_stat(self, src):\n        try:\n            self.exec(\"import os\")\n            return os.stat_result(self.eval(\"os.stat(%s)\" % (\"'%s'\" % src), parse=True))\n        except TransportError as e:\n            reraise_filesystem_error(e, src)\n\n    def fs_cat(self, src, chunk_size=256):\n        cmd = (\n            \"with open('%s') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        self.exec(cmd, data_consumer=stdout_write_bytes)\n\n    def fs_readfile(self, src, chunk_size=256):\n        buf = bytearray()\n\n        def repr_consumer(b):\n            buf.extend(b.replace(b\"\\x04\", b\"\"))\n\n        cmd = (\n            \"with open('%s', 'rb') as f:\\n while 1:\\n\"\n            \"  b=f.read(%u)\\n  if not b:break\\n  print(b,end='')\" % (src, chunk_size)\n        )\n        try:\n            self.exec(cmd, data_consumer=repr_consumer)\n        except TransportError as e:\n            reraise_filesystem_error(e, src)\n        return ast.literal_eval(buf.decode())\n\n    def fs_writefile(self, dest, data, chunk_size=256):\n        self.exec(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        while data:\n            chunk = data[:chunk_size]\n            self.exec(\"w(\" + repr(chunk) + \")\")\n            data = data[len(chunk) :]\n        self.exec(\"f.close()\")\n\n    def fs_cp(self, src, dest, chunk_size=256, progress_callback=None):\n        if progress_callback:\n            src_size = self.fs_stat(src).st_size\n            written = 0\n        self.exec(\"fr=open('%s','rb')\\nr=fr.read\\nfw=open('%s','wb')\\nw=fw.write\" % (src, dest))\n        while True:\n            data_len = int(self.exec(\"d=r(%u)\\nw(d)\\nprint(len(d))\" % chunk_size))\n            if not data_len:\n                break\n            if progress_callback:\n                written += data_len\n                progress_callback(written, src_size)\n        self.exec(\"fr.close()\\nfw.close()\")\n\n    def fs_get(self, src, dest, chunk_size=256, progress_callback=None):\n        if progress_callback:\n            src_size = self.fs_stat(src).st_size\n            written = 0\n        self.exec(\"f=open('%s','rb')\\nr=f.read\" % src)\n        with open(dest, \"wb\") as f:\n            while True:\n                data = bytearray()\n                self.exec(\"print(r(%u))\" % chunk_size, data_consumer=lambda d: data.extend(d))\n                assert data.endswith(b\"\\r\\n\\x04\")\n                try:\n                    data = ast.literal_eval(str(data[:-3], \"ascii\"))\n                    if not isinstance(data, bytes):\n                        raise ValueError(\"Not bytes\")\n                except (UnicodeError, ValueError) as e:\n                    raise TransportError(\"fs_get: Could not interpret received data: %s\" % str(e))\n                if not data:\n                    break\n                f.write(data)\n                if progress_callback:\n                    written += len(data)\n                    progress_callback(written, src_size)\n        self.exec(\"f.close()\")\n\n    def fs_put(self, src, dest, chunk_size=256, progress_callback=None):\n        if progress_callback:\n            src_size = os.path.getsize(src)\n            written = 0\n        self.exec(\"f=open('%s','wb')\\nw=f.write\" % dest)\n        with open(src, \"rb\") as f:\n            while True:\n                data = f.read(chunk_size)\n                if not data:\n                    break\n                if sys.version_info < (3,):\n                    self.exec(\"w(b\" + repr(data) + \")\")\n                else:\n                    self.exec(\"w(\" + repr(data) + \")\")\n                if progress_callback:\n                    written += len(data)\n                    progress_callback(written, src_size)\n        self.exec(\"f.close()\")\n\n    def fs_mkdir(self, dir):\n        self.exec(\"import os\\nos.mkdir('%s')\" % dir)\n\n    def fs_rmdir(self, dir):\n        self.exec(\"import os\\nos.rmdir('%s')\" % dir)\n\n    def fs_rm(self, src):\n        self.exec(\"import os\\nos.remove('%s')\" % src)\n\n    def fs_touch(self, src):\n        self.exec(\"f=open('%s','a')\\nf.close()\" % src)\n\n    def filesystem_command(self, args, progress_callback=None, verbose=False):\n        def fname_remote(src):\n            if src.startswith(\":\"):\n                src = src[1:]\n            # Convert all path separators to \"/\", because that's what a remote device uses.\n            return src.replace(os.path.sep, \"/\")\n\n        def fname_cp_dest(src, dest):\n            _, src = os.path.split(src)\n            if dest is None or dest == \"\":\n                dest = src\n            elif dest == \".\":\n                dest = \"./\" + src\n            elif dest.endswith(\"/\"):\n                dest += src\n            return dest\n\n        cmd = args[0]\n        args = args[1:]\n        try:\n            if cmd == \"cp\":\n                srcs = args[:-1]\n                dest = args[-1]\n                if dest.startswith(\":\"):\n                    op_remote_src = self.fs_cp\n                    op_local_src = self.fs_put\n                else:\n                    op_remote_src = self.fs_get\n                    op_local_src = lambda src, dest, **_: __import__(\"shutil\").copy(src, dest)\n                for src in srcs:\n                    if verbose:\n                        print(\"cp %s %s\" % (src, dest))\n                    if src.startswith(\":\"):\n                        op = op_remote_src\n                    else:\n                        op = op_local_src\n                    src2 = fname_remote(src)\n                    dest2 = fname_cp_dest(src2, fname_remote(dest))\n                    op(src2, dest2, progress_callback=progress_callback)\n            else:\n                ops = {\n                    \"cat\": self.fs_cat,\n                    \"ls\": self.fs_ls,\n                    \"mkdir\": self.fs_mkdir,\n                    \"rm\": self.fs_rm,\n                    \"rmdir\": self.fs_rmdir,\n                    \"touch\": self.fs_touch,\n                }\n                if cmd not in ops:\n                    raise TransportError(\"'{}' is not a filesystem command\".format(cmd))\n                if cmd == \"ls\" and not args:\n                    args = [\"\"]\n                for src in args:\n                    src = fname_remote(src)\n                    if verbose:\n                        print(\"%s :%s\" % (cmd, src))\n                    ops[cmd](src)\n        except TransportError as er:\n            if len(er.args) > 1:\n                print(str(er.args[2], \"ascii\"))\n            else:\n                print(er)\n            self.exit_raw_repl()\n            self.close()\n            sys.exit(1)\n\n    def mount_local(self, path, unsafe_links=False):\n        fout = self.serial\n        if self.eval('\"RemoteFS\" in globals()') == b\"False\":\n            self.exec(fs_hook_code)\n        self.exec(\"__mount()\")\n        self.mounted = True\n        self.cmd = PyboardCommand(self.serial, fout, path, unsafe_links=unsafe_links)\n        self.serial = SerialIntercept(self.serial, self.cmd)\n\n    def write_ctrl_d(self, out_callback):\n        self.serial.write(b\"\\x04\")\n        if not self.mounted:\n            return\n\n        # Read response from the device until it is quiet (with a timeout).\n        INITIAL_TIMEOUT = 0.5\n        BANNER_TIMEOUT = 2\n        QUIET_TIMEOUT = 0.1\n        FULL_TIMEOUT = 5\n        t_start = t_last_activity = time.monotonic()\n        data_all = b\"\"\n        soft_reboot_started = False\n        soft_reboot_banner = False\n        while True:\n            t = time.monotonic()\n            n = self.serial.inWaiting()\n            if n > 0:\n                data = self.serial.read(n)\n                out_callback(data)\n                data_all += data\n                t_last_activity = t\n            else:\n                if len(data_all) == 0:\n                    if t - t_start > INITIAL_TIMEOUT:\n                        return\n                else:\n                    if t - t_start > FULL_TIMEOUT:\n                        if soft_reboot_started:\n                            break\n                        return\n\n                    next_data_timeout = QUIET_TIMEOUT\n\n                    if not soft_reboot_started and data_all.find(b\"MPY: soft reboot\") != -1:\n                        soft_reboot_started = True\n\n                    if soft_reboot_started and not soft_reboot_banner:\n                        # Once soft reboot has been initiated, give some more time for the startup\n                        # banner to be shown\n                        if data_all.find(b\"\\nMicroPython \") != -1:\n                            soft_reboot_banner = True\n                        elif data_all.find(b\"\\nraw REPL; CTRL-B to exit\\r\\n\") != -1:\n                            soft_reboot_banner = True\n                        else:\n                            next_data_timeout = BANNER_TIMEOUT\n\n                    if t - t_last_activity > next_data_timeout:\n                        break\n\n        if not soft_reboot_started:\n            return\n\n        if not soft_reboot_banner:\n            out_callback(b\"Warning: Could not remount local filesystem\\r\\n\")\n            return\n\n        # Determine type of prompt\n        if data_all.endswith(b\">\"):\n            in_friendly_repl = False\n            prompt = b\">\"\n        else:\n            in_friendly_repl = True\n            prompt = data_all.rsplit(b\"\\r\\n\", 1)[-1]\n\n        # Clear state while board remounts, it will be re-set once mounted.\n        self.mounted = False\n        self.serial = self.serial.orig_serial\n\n        # Provide a message about the remount.\n        out_callback(bytes(f\"\\r\\nRemount local directory {self.cmd.root} at /remote\\r\\n\", \"utf8\"))\n\n        # Enter raw REPL and re-mount the remote filesystem.\n        self.serial.write(b\"\\x01\")\n        self.exec(fs_hook_code)\n        self.exec(\"__mount()\")\n        self.mounted = True\n\n        # Exit raw REPL if needed, and wait for the friendly REPL prompt.\n        if in_friendly_repl:\n            self.exit_raw_repl()\n        self.read_until(len(prompt), prompt)\n        out_callback(prompt)\n        self.serial = SerialIntercept(self.serial, self.cmd)\n\n    def umount_local(self):\n        if self.mounted:\n            self.exec('os.umount(\"/remote\")')\n            self.mounted = False\n            self.serial = self.serial.orig_serial\n\n\nfs_hook_cmds = {\n    \"CMD_STAT\": 1,\n    \"CMD_ILISTDIR_START\": 2,\n    \"CMD_ILISTDIR_NEXT\": 3,\n    \"CMD_OPEN\": 4,\n    \"CMD_CLOSE\": 5,\n    \"CMD_READ\": 6,\n    \"CMD_WRITE\": 7,\n    \"CMD_SEEK\": 8,\n    \"CMD_REMOVE\": 9,\n    \"CMD_RENAME\": 10,\n    \"CMD_MKDIR\": 11,\n    \"CMD_RMDIR\": 12,\n}\n\nfs_hook_code = \"\"\"\\\nimport os, io, struct, micropython\n\nSEEK_SET = 0\n\nclass RemoteCommand:\n    def __init__(self):\n        import select, sys\n        self.buf4 = bytearray(4)\n        self.fout = sys.stdout.buffer\n        self.fin = sys.stdin.buffer\n        self.poller = select.poll()\n        self.poller.register(self.fin, select.POLLIN)\n\n    def poll_in(self):\n        for _ in self.poller.ipoll(1000):\n            return\n        self.end()\n        raise Exception('timeout waiting for remote')\n\n    def rd(self, n):\n        buf = bytearray(n)\n        self.rd_into(buf, n)\n        return buf\n\n    def rd_into(self, buf, n):\n        # implement reading with a timeout in case other side disappears\n        if n == 0:\n            return\n        self.poll_in()\n        r = self.fin.readinto(buf, n)\n        if r < n:\n            mv = memoryview(buf)\n            while r < n:\n                self.poll_in()\n                r += self.fin.readinto(mv[r:], n - r)\n\n    def begin(self, type):\n        micropython.kbd_intr(-1)\n        buf4 = self.buf4\n        buf4[0] = 0x18\n        buf4[1] = type\n        self.fout.write(buf4, 2)\n        # Wait for sync byte 0x18, but don't get stuck forever\n        for i in range(30):\n            self.poller.poll(1000)\n            self.fin.readinto(buf4, 1)\n            if buf4[0] == 0x18:\n                break\n\n    def end(self):\n        micropython.kbd_intr(3)\n\n    def rd_s8(self):\n        self.rd_into(self.buf4, 1)\n        n = self.buf4[0]\n        if n & 0x80:\n            n -= 0x100\n        return n\n\n    def rd_s32(self):\n        buf4 = self.buf4\n        self.rd_into(buf4, 4)\n        n = buf4[0] | buf4[1] << 8 | buf4[2] << 16 | buf4[3] << 24\n        if buf4[3] & 0x80:\n            n -= 0x100000000\n        return n\n\n    def rd_u32(self):\n        buf4 = self.buf4\n        self.rd_into(buf4, 4)\n        return buf4[0] | buf4[1] << 8 | buf4[2] << 16 | buf4[3] << 24\n\n    def rd_bytes(self, buf):\n        # TODO if n is large (eg >256) then we may miss bytes on stdin\n        n = self.rd_s32()\n        if buf is None:\n            ret = buf = bytearray(n)\n        else:\n            ret = n\n        self.rd_into(buf, n)\n        return ret\n\n    def rd_str(self):\n        n = self.rd_s32()\n        if n == 0:\n            return ''\n        else:\n            return str(self.rd(n), 'utf8')\n\n    def wr_s8(self, i):\n        self.buf4[0] = i\n        self.fout.write(self.buf4, 1)\n\n    def wr_s32(self, i):\n        struct.pack_into('<i', self.buf4, 0, i)\n        self.fout.write(self.buf4)\n\n    def wr_bytes(self, b):\n        self.wr_s32(len(b))\n        self.fout.write(b)\n\n    # str and bytes act the same in MicroPython\n    wr_str = wr_bytes\n\n\nclass RemoteFile(io.IOBase):\n    def __init__(self, cmd, fd, is_text):\n        self.cmd = cmd\n        self.fd = fd\n        self.is_text = is_text\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, a, b, c):\n        self.close()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        l = self.readline()\n        if not l:\n            raise StopIteration\n        return l\n\n    def ioctl(self, request, arg):\n        if request == 1:  # FLUSH\n            self.flush()\n        elif request == 2:  # SEEK\n            # This assumes a 32-bit bare-metal machine.\n            import machine\n            machine.mem32[arg] = self.seek(machine.mem32[arg], machine.mem32[arg + 4])\n        elif request == 4:  # CLOSE\n            self.close()\n        elif request == 11:  # BUFFER_SIZE\n            # This is used as the vfs_reader buffer. n + 4 should be less than 255 to\n            # fit in stdin ringbuffer on supported ports. n + 7 should be multiple of 16\n            # to efficiently use gc blocks in mp_reader_vfs_t.\n            return 249\n        else:\n            return -1\n        return 0\n\n    def flush(self):\n        pass\n\n    def close(self):\n        if self.fd is None:\n            return\n        c = self.cmd\n        c.begin(CMD_CLOSE)\n        c.wr_s8(self.fd)\n        c.end()\n        self.fd = None\n\n    def read(self, n=-1):\n        c = self.cmd\n        c.begin(CMD_READ)\n        c.wr_s8(self.fd)\n        c.wr_s32(n)\n        data = c.rd_bytes(None)\n        c.end()\n        if self.is_text:\n            data = str(data, 'utf8')\n        else:\n            data = bytes(data)\n        return data\n\n    def readinto(self, buf):\n        c = self.cmd\n        c.begin(CMD_READ)\n        c.wr_s8(self.fd)\n        c.wr_s32(len(buf))\n        n = c.rd_bytes(buf)\n        c.end()\n        return n\n\n    def readline(self):\n        l = ''\n        while 1:\n            c = self.read(1)\n            l += c\n            if c == '\\\\n' or c == '':\n                return l\n\n    def readlines(self):\n        ls = []\n        while 1:\n            l = self.readline()\n            if not l:\n                return ls\n            ls.append(l)\n\n    def write(self, buf):\n        c = self.cmd\n        c.begin(CMD_WRITE)\n        c.wr_s8(self.fd)\n        c.wr_bytes(buf)\n        n = c.rd_s32()\n        c.end()\n        return n\n\n    def seek(self, n, whence=SEEK_SET):\n        c = self.cmd\n        c.begin(CMD_SEEK)\n        c.wr_s8(self.fd)\n        c.wr_s32(n)\n        c.wr_s8(whence)\n        n = c.rd_s32()\n        c.end()\n        if n < 0:\n            raise OSError(n)\n        return n\n\n\nclass RemoteFS:\n    def __init__(self, cmd):\n        self.cmd = cmd\n\n    def mount(self, readonly, mkfs):\n        pass\n\n    def umount(self):\n        pass\n\n    def chdir(self, path):\n        if not path.startswith(\"/\"):\n            path = self.path + path\n        if not path.endswith(\"/\"):\n            path += \"/\"\n        if path != \"/\":\n            self.stat(path)\n        self.path = path\n\n    def getcwd(self):\n        return self.path\n\n    def remove(self, path):\n        c = self.cmd\n        c.begin(CMD_REMOVE)\n        c.wr_str(self.path + path)\n        res = c.rd_s32()\n        c.end()\n        if res < 0:\n            raise OSError(-res)\n\n    def rename(self, old, new):\n        c = self.cmd\n        c.begin(CMD_RENAME)\n        c.wr_str(self.path + old)\n        c.wr_str(self.path + new)\n        res = c.rd_s32()\n        c.end()\n        if res < 0:\n            raise OSError(-res)\n\n    def mkdir(self, path):\n        c = self.cmd\n        c.begin(CMD_MKDIR)\n        c.wr_str(self.path + path)\n        res = c.rd_s32()\n        c.end()\n        if res < 0:\n            raise OSError(-res)\n\n    def rmdir(self, path):\n        c = self.cmd\n        c.begin(CMD_RMDIR)\n        c.wr_str(self.path + path)\n        res = c.rd_s32()\n        c.end()\n        if res < 0:\n            raise OSError(-res)\n\n    def stat(self, path):\n        c = self.cmd\n        c.begin(CMD_STAT)\n        c.wr_str(self.path + path)\n        res = c.rd_s8()\n        if res < 0:\n            c.end()\n            raise OSError(-res)\n        mode = c.rd_u32()\n        size = c.rd_u32()\n        atime = c.rd_u32()\n        mtime = c.rd_u32()\n        ctime = c.rd_u32()\n        c.end()\n        return mode, 0, 0, 0, 0, 0, size, atime, mtime, ctime\n\n    def ilistdir(self, path):\n        c = self.cmd\n        c.begin(CMD_ILISTDIR_START)\n        c.wr_str(self.path + path)\n        res = c.rd_s8()\n        c.end()\n        if res < 0:\n            raise OSError(-res)\n        def next():\n            while True:\n                c.begin(CMD_ILISTDIR_NEXT)\n                name = c.rd_str()\n                if name:\n                    type = c.rd_u32()\n                    c.end()\n                    yield (name, type, 0)\n                else:\n                    c.end()\n                    break\n        return next()\n\n    def open(self, path, mode):\n        c = self.cmd\n        c.begin(CMD_OPEN)\n        c.wr_str(self.path + path)\n        c.wr_str(mode)\n        fd = c.rd_s8()\n        c.end()\n        if fd < 0:\n            raise OSError(-fd)\n        return RemoteFile(c, fd, mode.find('b') == -1)\n\n\ndef __mount():\n    os.mount(RemoteFS(RemoteCommand()), '/remote')\n    os.chdir('/remote')\n\"\"\"\n\n# Apply basic compression on hook code.\nfor key, value in fs_hook_cmds.items():\n    fs_hook_code = re.sub(key, str(value), fs_hook_code)\nfs_hook_code = re.sub(\" *#.*$\", \"\", fs_hook_code, flags=re.MULTILINE)\nfs_hook_code = re.sub(\"\\n\\n+\", \"\\n\", fs_hook_code)\nfs_hook_code = re.sub(\"    \", \" \", fs_hook_code)\nfs_hook_code = re.sub(\"rd_\", \"r\", fs_hook_code)\nfs_hook_code = re.sub(\"wr_\", \"w\", fs_hook_code)\nfs_hook_code = re.sub(\"buf4\", \"b4\", fs_hook_code)\n\n\nclass PyboardCommand:\n    def __init__(self, fin, fout, path, unsafe_links=False):\n        self.fin = fin\n        self.fout = fout\n        self.root = path + \"/\"\n        self.data_ilistdir = [\"\", []]\n        self.data_files = []\n        self.unsafe_links = unsafe_links\n\n    def rd_s8(self):\n        return struct.unpack(\"<b\", self.fin.read(1))[0]\n\n    def rd_s32(self):\n        return struct.unpack(\"<i\", self.fin.read(4))[0]\n\n    def rd_bytes(self):\n        n = self.rd_s32()\n        return self.fin.read(n)\n\n    def rd_str(self):\n        n = self.rd_s32()\n        if n == 0:\n            return \"\"\n        else:\n            return str(self.fin.read(n), \"utf8\")\n\n    def wr_s8(self, i):\n        self.fout.write(struct.pack(\"<b\", i))\n\n    def wr_s32(self, i):\n        self.fout.write(struct.pack(\"<i\", i))\n\n    def wr_u32(self, i):\n        self.fout.write(struct.pack(\"<I\", i))\n\n    def wr_bytes(self, b):\n        self.wr_s32(len(b))\n        self.fout.write(b)\n\n    def wr_str(self, s):\n        b = bytes(s, \"utf8\")\n        self.wr_s32(len(b))\n        self.fout.write(b)\n\n    def log_cmd(self, msg):\n        print(f\"[{msg}]\", end=\"\\r\\n\")\n\n    def path_check(self, path):\n        if not self.unsafe_links:\n            parent = os.path.realpath(self.root)\n            child = os.path.realpath(path)\n        else:\n            parent = os.path.abspath(self.root)\n            child = os.path.abspath(path)\n        if parent != os.path.commonpath([parent, child]):\n            raise OSError(EPERM, \"\")  # File is outside mounted dir\n\n    def do_stat(self):\n        path = self.root + self.rd_str()\n        # self.log_cmd(f\"stat {path}\")\n        try:\n            self.path_check(path)\n            stat = os.stat(path)\n        except OSError as er:\n            self.wr_s8(-abs(er.errno))\n        else:\n            self.wr_s8(0)\n            # Note: st_ino would need to be 64-bit if added here\n            self.wr_u32(stat.st_mode)\n            self.wr_u32(stat.st_size)\n            self.wr_u32(int(stat.st_atime))\n            self.wr_u32(int(stat.st_mtime))\n            self.wr_u32(int(stat.st_ctime))\n\n    def do_ilistdir_start(self):\n        path = self.root + self.rd_str()\n        try:\n            self.path_check(path)\n            self.data_ilistdir[0] = path\n            self.data_ilistdir[1] = os.listdir(path)\n            self.wr_s8(0)\n        except OSError as er:\n            self.wr_s8(-abs(er.errno))\n\n    def do_ilistdir_next(self):\n        if self.data_ilistdir[1]:\n            entry = self.data_ilistdir[1].pop(0)\n            try:\n                stat = os.lstat(self.data_ilistdir[0] + \"/\" + entry)\n                mode = stat.st_mode & 0xC000\n            except OSError:\n                mode = 0\n            self.wr_str(entry)\n            self.wr_u32(mode)\n        else:\n            self.wr_str(\"\")\n\n    def do_open(self):\n        path = self.root + self.rd_str()\n        mode = self.rd_str()\n        # self.log_cmd(f\"open {path} {mode}\")\n        try:\n            self.path_check(path)\n            f = open(path, mode)\n        except OSError as er:\n            self.wr_s8(-abs(er.errno))\n        else:\n            is_text = mode.find(\"b\") == -1\n            try:\n                fd = self.data_files.index(None)\n                self.data_files[fd] = (f, is_text)\n            except ValueError:\n                fd = len(self.data_files)\n                self.data_files.append((f, is_text))\n            self.wr_s8(fd)\n\n    def do_close(self):\n        fd = self.rd_s8()\n        # self.log_cmd(f\"close {fd}\")\n        self.data_files[fd][0].close()\n        self.data_files[fd] = None\n\n    def do_read(self):\n        fd = self.rd_s8()\n        n = self.rd_s32()\n        buf = self.data_files[fd][0].read(n)\n        if self.data_files[fd][1]:\n            buf = bytes(buf, \"utf8\")\n        self.wr_bytes(buf)\n        # self.log_cmd(f\"read {fd} {n} -> {len(buf)}\")\n\n    def do_seek(self):\n        fd = self.rd_s8()\n        n = self.rd_s32()\n        whence = self.rd_s8()\n        # self.log_cmd(f\"seek {fd} {n}\")\n        try:\n            n = self.data_files[fd][0].seek(n, whence)\n        except io.UnsupportedOperation:\n            n = -1\n        self.wr_s32(n)\n\n    def do_write(self):\n        fd = self.rd_s8()\n        buf = self.rd_bytes()\n        if self.data_files[fd][1]:\n            buf = str(buf, \"utf8\")\n        n = self.data_files[fd][0].write(buf)\n        self.wr_s32(n)\n        # self.log_cmd(f\"write {fd} {len(buf)} -> {n}\")\n\n    def do_remove(self):\n        path = self.root + self.rd_str()\n        # self.log_cmd(f\"remove {path}\")\n        try:\n            self.path_check(path)\n            os.remove(path)\n            ret = 0\n        except OSError as er:\n            ret = -abs(er.errno)\n        self.wr_s32(ret)\n\n    def do_rename(self):\n        old = self.root + self.rd_str()\n        new = self.root + self.rd_str()\n        # self.log_cmd(f\"rename {old} {new}\")\n        try:\n            self.path_check(old)\n            self.path_check(new)\n            os.rename(old, new)\n            ret = 0\n        except OSError as er:\n            ret = -abs(er.errno)\n        self.wr_s32(ret)\n\n    def do_mkdir(self):\n        path = self.root + self.rd_str()\n        # self.log_cmd(f\"mkdir {path}\")\n        try:\n            self.path_check(path)\n            os.mkdir(path)\n            ret = 0\n        except OSError as er:\n            ret = -abs(er.errno)\n        self.wr_s32(ret)\n\n    def do_rmdir(self):\n        path = self.root + self.rd_str()\n        # self.log_cmd(f\"rmdir {path}\")\n        try:\n            self.path_check(path)\n            os.rmdir(path)\n            ret = 0\n        except OSError as er:\n            ret = -abs(er.errno)\n        self.wr_s32(ret)\n\n    cmd_table = {\n        fs_hook_cmds[\"CMD_STAT\"]: do_stat,\n        fs_hook_cmds[\"CMD_ILISTDIR_START\"]: do_ilistdir_start,\n        fs_hook_cmds[\"CMD_ILISTDIR_NEXT\"]: do_ilistdir_next,\n        fs_hook_cmds[\"CMD_OPEN\"]: do_open,\n        fs_hook_cmds[\"CMD_CLOSE\"]: do_close,\n        fs_hook_cmds[\"CMD_READ\"]: do_read,\n        fs_hook_cmds[\"CMD_WRITE\"]: do_write,\n        fs_hook_cmds[\"CMD_SEEK\"]: do_seek,\n        fs_hook_cmds[\"CMD_REMOVE\"]: do_remove,\n        fs_hook_cmds[\"CMD_RENAME\"]: do_rename,\n        fs_hook_cmds[\"CMD_MKDIR\"]: do_mkdir,\n        fs_hook_cmds[\"CMD_RMDIR\"]: do_rmdir,\n    }\n\n\nclass SerialIntercept:\n    def __init__(self, serial, cmd):\n        self.orig_serial = serial\n        self.cmd = cmd\n        self.buf = b\"\"\n        self.orig_serial.timeout = 5.0\n\n    def _check_input(self, blocking):\n        if blocking or self.orig_serial.inWaiting() > 0:\n            c = self.orig_serial.read(1)\n            if c == b\"\\x18\":\n                # a special command\n                c = self.orig_serial.read(1)[0]\n                self.orig_serial.write(b\"\\x18\")  # Acknowledge command\n                PyboardCommand.cmd_table[c](self.cmd)\n            elif not VT_ENABLED and c == b\"\\x1b\":\n                # ESC code, ignore these on windows\n                esctype = self.orig_serial.read(1)\n                if esctype == b\"[\":  # CSI\n                    while not (0x40 < self.orig_serial.read(1)[0] < 0x7E):\n                        # Looking for \"final byte\" of escape sequence\n                        pass\n            else:\n                self.buf += c\n\n    @property\n    def fd(self):\n        return self.orig_serial.fd\n\n    def close(self):\n        self.orig_serial.close()\n\n    def inWaiting(self):\n        self._check_input(False)\n        return len(self.buf)\n\n    def read(self, n):\n        while len(self.buf) < n:\n            self._check_input(True)\n        out = self.buf[:n]\n        self.buf = self.buf[n:]\n        return out\n\n    def write(self, buf):\n        self.orig_serial.write(buf)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}