{
  "module_name": "commands.py",
  "hash_id": "e6c20cc15e0212ebab4eee7e659b9202a949d4a80a3524760584bafe7e4ad640",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpremote/mpremote/commands.py",
  "human_readable_source": "import os\nimport sys\nimport tempfile\n\nimport serial.tools.list_ports\n\nfrom .transport import TransportError\nfrom .transport_serial import SerialTransport, stdout_write_bytes\n\n\nclass CommandError(Exception):\n    pass\n\n\ndef do_connect(state, args=None):\n    dev = args.device[0] if args else \"auto\"\n    do_disconnect(state)\n\n    try:\n        if dev == \"list\":\n            # List attached devices.\n            for p in sorted(serial.tools.list_ports.comports()):\n                print(\n                    \"{} {} {:04x}:{:04x} {} {}\".format(\n                        p.device,\n                        p.serial_number,\n                        p.vid if isinstance(p.vid, int) else 0,\n                        p.pid if isinstance(p.pid, int) else 0,\n                        p.manufacturer,\n                        p.product,\n                    )\n                )\n            # Don't do implicit REPL command.\n            state.did_action()\n        elif dev == \"auto\":\n            # Auto-detect and auto-connect to the first available USB serial port.\n            for p in sorted(serial.tools.list_ports.comports()):\n                if p.vid is not None and p.pid is not None:\n                    try:\n                        state.transport = SerialTransport(p.device, baudrate=115200)\n                        return\n                    except TransportError as er:\n                        if not er.args[0].startswith(\"failed to access\"):\n                            raise er\n            raise TransportError(\"no device found\")\n        elif dev.startswith(\"id:\"):\n            # Search for a device with the given serial number.\n            serial_number = dev[len(\"id:\") :]\n            dev = None\n            for p in serial.tools.list_ports.comports():\n                if p.serial_number == serial_number:\n                    state.transport = SerialTransport(p.device, baudrate=115200)\n                    return\n            raise TransportError(\"no device with serial number {}\".format(serial_number))\n        else:\n            # Connect to the given device.\n            if dev.startswith(\"port:\"):\n                dev = dev[len(\"port:\") :]\n            state.transport = SerialTransport(dev, baudrate=115200)\n            return\n    except TransportError as er:\n        msg = er.args[0]\n        if msg.startswith(\"failed to access\"):\n            msg += \" (it may be in use by another program)\"\n        print(msg)\n        sys.exit(1)\n\n\ndef do_disconnect(state, _args=None):\n    if not state.transport:\n        return\n\n    try:\n        if state.transport.mounted:\n            if not state.transport.in_raw_repl:\n                state.transport.enter_raw_repl(soft_reset=False)\n            state.transport.umount_local()\n        if state.transport.in_raw_repl:\n            state.transport.exit_raw_repl()\n    except OSError:\n        # Ignore any OSError exceptions when shutting down, eg:\n        # - filesystem_command will close the connection if it had an error\n        # - umounting will fail if serial port disappeared\n        pass\n    state.transport.close()\n    state.transport = None\n    state._auto_soft_reset = True\n\n\ndef show_progress_bar(size, total_size, op=\"copying\"):\n    if not sys.stdout.isatty():\n        return\n    verbose_size = 2048\n    bar_length = 20\n    if total_size < verbose_size:\n        return\n    elif size >= total_size:\n        # Clear progress bar when copy completes\n        print(\"\\r\" + \" \" * (13 + len(op) + bar_length) + \"\\r\", end=\"\")\n    else:\n        bar = size * bar_length // total_size\n        progress = size * 100 // total_size\n        print(\n            \"\\r ... {} {:3d}% [{}{}]\".format(op, progress, \"#\" * bar, \"-\" * (bar_length - bar)),\n            end=\"\",\n        )\n\n\ndef do_filesystem(state, args):\n    state.ensure_raw_repl()\n    state.did_action()\n\n    def _list_recursive(files, path):\n        if os.path.isdir(path):\n            for entry in os.listdir(path):\n                _list_recursive(files, \"/\".join((path, entry)))\n        else:\n            files.append(os.path.split(path))\n\n    command = args.command[0]\n    paths = args.path\n\n    if command == \"cat\":\n        # Don't be verbose by default when using cat, so output can be\n        # redirected to something.\n        verbose = args.verbose is True\n    else:\n        verbose = args.verbose is not False\n\n    if command == \"cp\" and args.recursive:\n        if paths[-1] != \":\":\n            raise CommandError(\"'cp -r' destination must be ':'\")\n        paths.pop()\n        src_files = []\n        for path in paths:\n            if path.startswith(\":\"):\n                raise CommandError(\"'cp -r' source files must be local\")\n            _list_recursive(src_files, path)\n        known_dirs = {\"\"}\n        state.transport.exec(\"import os\")\n        for dir, file in src_files:\n            dir_parts = dir.split(\"/\")\n            for i in range(len(dir_parts)):\n                d = \"/\".join(dir_parts[: i + 1])\n                if d not in known_dirs:\n                    state.transport.exec(\n                        \"try:\\n os.mkdir('%s')\\nexcept OSError as e:\\n print(e)\" % d\n                    )\n                    known_dirs.add(d)\n            state.transport.filesystem_command(\n                [\"cp\", \"/\".join((dir, file)), \":\" + dir + \"/\"],\n                progress_callback=show_progress_bar,\n                verbose=verbose,\n            )\n    else:\n        if args.recursive:\n            raise CommandError(\"'-r' only supported for 'cp'\")\n        try:\n            state.transport.filesystem_command(\n                [command] + paths, progress_callback=show_progress_bar, verbose=verbose\n            )\n        except OSError as er:\n            raise CommandError(er)\n\n\ndef do_edit(state, args):\n    state.ensure_raw_repl()\n    state.did_action()\n\n    if not os.getenv(\"EDITOR\"):\n        raise TransportError(\"edit: $EDITOR not set\")\n    for src in args.files:\n        src = src.lstrip(\":\")\n        dest_fd, dest = tempfile.mkstemp(suffix=os.path.basename(src))\n        try:\n            print(\"edit :%s\" % (src,))\n            os.close(dest_fd)\n            state.transport.fs_touch(src)\n            state.transport.fs_get(src, dest, progress_callback=show_progress_bar)\n            if os.system('%s \"%s\"' % (os.getenv(\"EDITOR\"), dest)) == 0:\n                state.transport.fs_put(dest, src, progress_callback=show_progress_bar)\n        finally:\n            os.unlink(dest)\n\n\ndef _do_execbuffer(state, buf, follow):\n    state.ensure_raw_repl()\n    state.did_action()\n\n    try:\n        state.transport.exec_raw_no_follow(buf)\n        if follow:\n            ret, ret_err = state.transport.follow(timeout=None, data_consumer=stdout_write_bytes)\n            if ret_err:\n                stdout_write_bytes(ret_err)\n                sys.exit(1)\n    except TransportError as er:\n        print(er)\n        sys.exit(1)\n    except KeyboardInterrupt:\n        sys.exit(1)\n\n\ndef do_exec(state, args):\n    _do_execbuffer(state, args.expr[0], args.follow)\n\n\ndef do_eval(state, args):\n    buf = \"print(\" + args.expr[0] + \")\"\n    _do_execbuffer(state, buf, True)\n\n\ndef do_run(state, args):\n    filename = args.path[0]\n    try:\n        with open(filename, \"rb\") as f:\n            buf = f.read()\n    except OSError:\n        raise CommandError(f\"could not read file '{filename}'\")\n    _do_execbuffer(state, buf, args.follow)\n\n\ndef do_mount(state, args):\n    state.ensure_raw_repl()\n    path = args.path[0]\n    state.transport.mount_local(path, unsafe_links=args.unsafe_links)\n    print(f\"Local directory {path} is mounted at /remote\")\n\n\ndef do_umount(state, path):\n    state.ensure_raw_repl()\n    state.transport.umount_local()\n\n\ndef do_resume(state, _args=None):\n    state._auto_soft_reset = False\n\n\ndef do_soft_reset(state, _args=None):\n    state.ensure_raw_repl(soft_reset=True)\n    state.did_action()\n\n\ndef do_rtc(state, args):\n    if args.set:\n        import datetime\n\n        now = datetime.datetime.now()\n        timetuple = \"({}, {}, {}, {}, {}, {}, {}, {})\".format(\n            now.year,\n            now.month,\n            now.day,\n            now.weekday(),\n            now.hour,\n            now.minute,\n            now.second,\n            now.microsecond,\n        )\n        _do_execbuffer(state, \"import machine; machine.RTC().datetime({})\".format(timetuple), True)\n    else:\n        _do_execbuffer(state, \"import machine; print(machine.RTC().datetime())\", True)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}