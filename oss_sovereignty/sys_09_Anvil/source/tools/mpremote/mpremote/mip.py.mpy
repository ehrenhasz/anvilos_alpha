{
  "module_name": "mip.py",
  "hash_id": "e91d46bdb33b90a8cc5a1547adff3e16e7294d74ddd64bfabb1bfdacb1355095",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpremote/mpremote/mip.py",
  "human_readable_source": "# Micropython package installer\n# Ported from micropython-lib/micropython/mip/mip.py.\n# MIT license; Copyright (c) 2022 Jim Mussared\n\nimport urllib.error\nimport urllib.request\nimport json\nimport tempfile\nimport os\n\nfrom .commands import CommandError, show_progress_bar\n\n\n_PACKAGE_INDEX = \"https://micropython.org/pi/v2\"\n_CHUNK_SIZE = 128\n\n\n# This implements os.makedirs(os.dirname(path))\ndef _ensure_path_exists(transport, path):\n    import os\n\n    split = path.split(\"/\")\n\n    # Handle paths starting with \"/\".\n    if not split[0]:\n        split.pop(0)\n        split[0] = \"/\" + split[0]\n\n    prefix = \"\"\n    for i in range(len(split) - 1):\n        prefix += split[i]\n        if not transport.fs_exists(prefix):\n            transport.fs_mkdir(prefix)\n        prefix += \"/\"\n\n\n# Copy from src (stream) to dest (function-taking-bytes)\ndef _chunk(src, dest, length=None, op=\"downloading\"):\n    buf = memoryview(bytearray(_CHUNK_SIZE))\n    total = 0\n    if length:\n        show_progress_bar(0, length, op)\n    while True:\n        n = src.readinto(buf)\n        if n == 0:\n            break\n        dest(buf if n == _CHUNK_SIZE else buf[:n])\n        total += n\n        if length:\n            show_progress_bar(total, length, op)\n\n\ndef _rewrite_url(url, branch=None):\n    if not branch:\n        branch = \"HEAD\"\n    if url.startswith(\"github:\"):\n        url = url[7:].split(\"/\")\n        url = (\n            \"https://raw.githubusercontent.com/\"\n            + url[0]\n            + \"/\"\n            + url[1]\n            + \"/\"\n            + branch\n            + \"/\"\n            + \"/\".join(url[2:])\n        )\n    elif url.startswith(\"gitlab:\"):\n        url = url[7:].split(\"/\")\n        url = (\n            \"https://gitlab.com/\"\n            + url[0]\n            + \"/\"\n            + url[1]\n            + \"/-/raw/\"\n            + branch\n            + \"/\"\n            + \"/\".join(url[2:])\n        )\n    return url\n\n\ndef _download_file(transport, url, dest):\n    try:\n        with urllib.request.urlopen(url) as src:\n            fd, path = tempfile.mkstemp()\n            try:\n                print(\"Installing:\", dest)\n                with os.fdopen(fd, \"wb\") as f:\n                    _chunk(src, f.write, src.length)\n                _ensure_path_exists(transport, dest)\n                transport.fs_put(path, dest, progress_callback=show_progress_bar)\n            finally:\n                os.unlink(path)\n    except urllib.error.HTTPError as e:\n        if e.status == 404:\n            raise CommandError(f\"File not found: {url}\")\n        else:\n            raise CommandError(f\"Error {e.status} requesting {url}\")\n    except urllib.error.URLError as e:\n        raise CommandError(f\"{e.reason} requesting {url}\")\n\n\ndef _install_json(transport, package_json_url, index, target, version, mpy):\n    try:\n        with urllib.request.urlopen(_rewrite_url(package_json_url, version)) as response:\n            package_json = json.load(response)\n    except urllib.error.HTTPError as e:\n        if e.status == 404:\n            raise CommandError(f\"Package not found: {package_json_url}\")\n        else:\n            raise CommandError(f\"Error {e.status} requesting {package_json_url}\")\n    except urllib.error.URLError as e:\n        raise CommandError(f\"{e.reason} requesting {package_json_url}\")\n    for target_path, short_hash in package_json.get(\"hashes\", ()):\n        fs_target_path = target + \"/\" + target_path\n        file_url = f\"{index}/file/{short_hash[:2]}/{short_hash}\"\n        _download_file(transport, file_url, fs_target_path)\n    for target_path, url in package_json.get(\"urls\", ()):\n        fs_target_path = target + \"/\" + target_path\n        _download_file(transport, _rewrite_url(url, version), fs_target_path)\n    for dep, dep_version in package_json.get(\"deps\", ()):\n        _install_package(transport, dep, index, target, dep_version, mpy)\n\n\ndef _install_package(transport, package, index, target, version, mpy):\n    if (\n        package.startswith(\"http://\")\n        or package.startswith(\"https://\")\n        or package.startswith(\"github:\")\n        or package.startswith(\"gitlab:\")\n    ):\n        if package.endswith(\".py\") or package.endswith(\".mpy\"):\n            print(f\"Downloading {package} to {target}\")\n            _download_file(\n                transport, _rewrite_url(package, version), target + \"/\" + package.rsplit(\"/\")[-1]\n            )\n            return\n        else:\n            if not package.endswith(\".json\"):\n                if not package.endswith(\"/\"):\n                    package += \"/\"\n                package += \"package.json\"\n            print(f\"Installing {package} to {target}\")\n    else:\n        if not version:\n            version = \"latest\"\n        print(f\"Installing {package} ({version}) from {index} to {target}\")\n\n        mpy_version = \"py\"\n        if mpy:\n            transport.exec(\"import sys\")\n            mpy_version = (\n                int(transport.eval(\"getattr(sys.implementation, '_mpy', 0) & 0xFF\").decode())\n                or \"py\"\n            )\n\n        package = f\"{index}/package/{mpy_version}/{package}/{version}.json\"\n\n    _install_json(transport, package, index, target, version, mpy)\n\n\ndef do_mip(state, args):\n    state.did_action()\n\n    if args.command[0] == \"install\":\n        state.ensure_raw_repl()\n\n        for package in args.packages:\n            version = None\n            if \"@\" in package:\n                package, version = package.split(\"@\")\n\n            print(\"Install\", package)\n\n            if args.index is None:\n                args.index = _PACKAGE_INDEX\n\n            if args.target is None:\n                state.transport.exec(\"import sys\")\n                lib_paths = (\n                    state.transport.eval(\"'\\\\n'.join(p for p in sys.path if p.endswith('/lib'))\")\n                    .decode()\n                    .split(\"\\n\")\n                )\n                if lib_paths and lib_paths[0]:\n                    args.target = lib_paths[0]\n                else:\n                    raise CommandError(\n                        \"Unable to find lib dir in sys.path, use --target to override\"\n                    )\n\n            if args.mpy is None:\n                args.mpy = True\n\n            try:\n                _install_package(\n                    state.transport,\n                    package,\n                    args.index.rstrip(\"/\"),\n                    args.target,\n                    version,\n                    args.mpy,\n                )\n            except CommandError:\n                print(\"Package may be partially installed\")\n                raise\n            print(\"Done\")\n    else:\n        raise CommandError(f\"mip: '{args.command[0]}' is not a command\")\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}