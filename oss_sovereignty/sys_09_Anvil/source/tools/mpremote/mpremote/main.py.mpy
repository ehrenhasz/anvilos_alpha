{
  "module_name": "main.py",
  "hash_id": "b8c749143b9b264d0ed85fd2bb566ff6e0847363bee8e928299c72c32b8d4823",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpremote/mpremote/main.py",
  "human_readable_source": "\"\"\"\nMicroPython Remote - Interaction and automation tool for MicroPython\nMIT license; Copyright (c) 2019-2022 Damien P. George\n\nThis program provides a set of utilities to interact with and automate a\nMicroPython device over a serial connection.  Commands supported are:\n\n    mpremote                         -- auto-detect, connect and enter REPL\n    mpremote <device-shortcut>       -- connect to given device\n    mpremote connect <device>        -- connect to given device\n    mpremote disconnect              -- disconnect current device\n    mpremote mount <local-dir>       -- mount local directory on device\n    mpremote eval <string>           -- evaluate and print the string\n    mpremote exec <string>           -- execute the string\n    mpremote run <script>            -- run the given local script\n    mpremote fs <command> <args...>  -- execute filesystem commands on the device\n    mpremote repl                    -- enter REPL\n\"\"\"\n\nimport argparse\nimport os, sys, time\nfrom collections.abc import Mapping\nfrom textwrap import dedent\n\nfrom .commands import (\n    CommandError,\n    do_connect,\n    do_disconnect,\n    do_edit,\n    do_filesystem,\n    do_mount,\n    do_umount,\n    do_exec,\n    do_eval,\n    do_run,\n    do_resume,\n    do_rtc,\n    do_soft_reset,\n)\nfrom .mip import do_mip\nfrom .repl import do_repl\n\n_PROG = \"mpremote\"\n\n\ndef do_sleep(state, args):\n    time.sleep(args.ms[0])\n\n\ndef do_help(state, _args=None):\n    def print_commands_help(cmds, help_key):\n        max_command_len = max(len(cmd) for cmd in cmds.keys())\n        for cmd in sorted(cmds.keys()):\n            help_message_lines = dedent(help_key(cmds[cmd])).split(\"\\n\")\n            help_message = help_message_lines[0]\n            for line in help_message_lines[1:]:\n                help_message = \"{}\\n{}{}\".format(help_message, \" \" * (max_command_len + 4), line)\n            print(\"  \", cmd, \" \" * (max_command_len - len(cmd) + 2), help_message, sep=\"\")\n\n    print(_PROG, \"-- MicroPython remote control\")\n    print(\"See https://docs.micropython.org/en/latest/reference/mpremote.html\")\n\n    print(\"\\nList of commands:\")\n    print_commands_help(\n        _COMMANDS, lambda x: x[1]().description\n    )  # extract description from argparse\n\n    print(\"\\nList of shortcuts:\")\n    print_commands_help(_command_expansions, lambda x: x[2])  # (args, sub, help_message)\n\n    sys.exit(0)\n\n\ndef do_version(state, _args=None):\n    from . import __version__\n\n    print(f\"{_PROG} {__version__}\")\n    sys.exit(0)\n\n\ndef _bool_flag(cmd_parser, name, short_name, default, description):\n    # In Python 3.9+ this can be replaced with argparse.BooleanOptionalAction.\n    group = cmd_parser.add_mutually_exclusive_group()\n    group.add_argument(\n        \"--\" + name,\n        \"-\" + short_name,\n        action=\"store_true\",\n        default=default,\n        help=description,\n    )\n    group.add_argument(\n        \"--no-\" + name,\n        action=\"store_false\",\n        dest=name,\n    )\n\n\ndef argparse_connect():\n    cmd_parser = argparse.ArgumentParser(description=\"connect to given device\")\n    cmd_parser.add_argument(\n        \"device\", nargs=1, help=\"Either list, auto, id:x, port:x, or any valid device name/path\"\n    )\n    return cmd_parser\n\n\ndef argparse_sleep():\n    cmd_parser = argparse.ArgumentParser(description=\"sleep before executing next command\")\n    cmd_parser.add_argument(\"ms\", nargs=1, type=float, help=\"milliseconds to sleep for\")\n    return cmd_parser\n\n\ndef argparse_edit():\n    cmd_parser = argparse.ArgumentParser(description=\"edit files on the device\")\n    cmd_parser.add_argument(\"files\", nargs=\"+\", help=\"list of remote paths\")\n    return cmd_parser\n\n\ndef argparse_mount():\n    cmd_parser = argparse.ArgumentParser(description=\"mount local directory on device\")\n    _bool_flag(\n        cmd_parser,\n        \"unsafe-links\",\n        \"l\",\n        False,\n        \"follow symbolic links pointing outside of local directory\",\n    )\n    cmd_parser.add_argument(\"path\", nargs=1, help=\"local path to mount\")\n    return cmd_parser\n\n\ndef argparse_repl():\n    cmd_parser = argparse.ArgumentParser(description=\"connect to given device\")\n    _bool_flag(cmd_parser, \"escape-non-printable\", \"e\", False, \"escape non-printable characters\")\n    cmd_parser.add_argument(\n        \"--capture\",\n        type=str,\n        required=False,\n        help=\"saves a copy of the REPL session to the specified path\",\n    )\n    cmd_parser.add_argument(\n        \"--inject-code\", type=str, required=False, help=\"code to be run when Ctrl-J is pressed\"\n    )\n    cmd_parser.add_argument(\n        \"--inject-file\",\n        type=str,\n        required=False,\n        help=\"path to file to be run when Ctrl-K is pressed\",\n    )\n    return cmd_parser\n\n\ndef argparse_eval():\n    cmd_parser = argparse.ArgumentParser(description=\"evaluate and print the string\")\n    cmd_parser.add_argument(\"expr\", nargs=1, help=\"expression to execute\")\n    return cmd_parser\n\n\ndef argparse_exec():\n    cmd_parser = argparse.ArgumentParser(description=\"execute the string\")\n    _bool_flag(\n        cmd_parser, \"follow\", \"f\", True, \"follow output until the expression completes (default)\"\n    )\n    cmd_parser.add_argument(\"expr\", nargs=1, help=\"expression to execute\")\n    return cmd_parser\n\n\ndef argparse_run():\n    cmd_parser = argparse.ArgumentParser(description=\"run the given local script\")\n    _bool_flag(\n        cmd_parser, \"follow\", \"f\", True, \"follow output until the script completes (default)\"\n    )\n    cmd_parser.add_argument(\"path\", nargs=1, help=\"path to script to execute\")\n    return cmd_parser\n\n\ndef argparse_rtc():\n    cmd_parser = argparse.ArgumentParser(description=\"get (default) or set the device RTC\")\n    _bool_flag(cmd_parser, \"set\", \"s\", False, \"set the RTC to the current local time\")\n    return cmd_parser\n\n\ndef argparse_filesystem():\n    cmd_parser = argparse.ArgumentParser(description=\"execute filesystem commands on the device\")\n    _bool_flag(cmd_parser, \"recursive\", \"r\", False, \"recursive copy (for cp command only)\")\n    _bool_flag(\n        cmd_parser,\n        \"verbose\",\n        \"v\",\n        None,\n        \"enable verbose output (defaults to True for all commands except cat)\",\n    )\n    cmd_parser.add_argument(\n        \"command\", nargs=1, help=\"filesystem command (e.g. cat, cp, ls, rm, touch)\"\n    )\n    cmd_parser.add_argument(\"path\", nargs=\"+\", help=\"local and remote paths\")\n    return cmd_parser\n\n\ndef argparse_mip():\n    cmd_parser = argparse.ArgumentParser(\n        description=\"install packages from micropython-lib or third-party sources\"\n    )\n    _bool_flag(cmd_parser, \"mpy\", \"m\", True, \"download as compiled .mpy files (default)\")\n    cmd_parser.add_argument(\n        \"--target\", type=str, required=False, help=\"destination direction on the device\"\n    )\n    cmd_parser.add_argument(\n        \"--index\",\n        type=str,\n        required=False,\n        help=\"package index to use (defaults to micropython-lib)\",\n    )\n    cmd_parser.add_argument(\"command\", nargs=1, help=\"mip command (e.g. install)\")\n    cmd_parser.add_argument(\n        \"packages\",\n        nargs=\"+\",\n        help=\"list package specifications, e.g. name, name@version, github:org/repo, github:org/repo@branch, gitlab:org/repo, gitlab:org/repo@branch\",\n    )\n    return cmd_parser\n\n\ndef argparse_none(description):\n    return lambda: argparse.ArgumentParser(description=description)\n\n\n# Map of \"command\" to tuple of (handler_func, argparse_func).\n_COMMANDS = {\n    \"connect\": (\n        do_connect,\n        argparse_connect,\n    ),\n    \"sleep\": (\n        do_sleep,\n        argparse_sleep,\n    ),\n    \"disconnect\": (\n        do_disconnect,\n        argparse_none(\"disconnect current device\"),\n    ),\n    \"edit\": (\n        do_edit,\n        argparse_edit,\n    ),\n    \"resume\": (\n        do_resume,\n        argparse_none(\"resume a previous mpremote session (will not auto soft-reset)\"),\n    ),\n    \"soft-reset\": (\n        do_soft_reset,\n        argparse_none(\"perform a soft-reset of the device\"),\n    ),\n    \"mount\": (\n        do_mount,\n        argparse_mount,\n    ),\n    \"umount\": (\n        do_umount,\n        argparse_none(\"unmount the local directory\"),\n    ),\n    \"repl\": (\n        do_repl,\n        argparse_repl,\n    ),\n    \"eval\": (\n        do_eval,\n        argparse_eval,\n    ),\n    \"exec\": (\n        do_exec,\n        argparse_exec,\n    ),\n    \"run\": (\n        do_run,\n        argparse_run,\n    ),\n    \"rtc\": (\n        do_rtc,\n        argparse_rtc,\n    ),\n    \"fs\": (\n        do_filesystem,\n        argparse_filesystem,\n    ),\n    \"mip\": (\n        do_mip,\n        argparse_mip,\n    ),\n    \"help\": (\n        do_help,\n        argparse_none(\"print help and exit\"),\n    ),\n    \"version\": (\n        do_version,\n        argparse_none(\"print version and exit\"),\n    ),\n}\n\n# Additional commands aliases.\n# The value can either be:\n#   - A command string.\n#   - A list of command strings, each command will be executed sequentially.\n#   - A dict of command: { [], help: \"\"}\n_BUILTIN_COMMAND_EXPANSIONS = {\n    # Device connection shortcuts.\n    \"devs\": {\n        \"command\": \"connect list\",\n        \"help\": \"list available serial ports\",\n    },\n    # Filesystem shortcuts (use `cp` instead of `fs cp`).\n    \"cat\": \"fs cat\",\n    \"ls\": \"fs ls\",\n    \"cp\": \"fs cp\",\n    \"rm\": \"fs rm\",\n    \"touch\": \"fs touch\",\n    \"mkdir\": \"fs mkdir\",\n    \"rmdir\": \"fs rmdir\",\n    # Disk used/free.\n    \"df\": [\n        \"exec\",\n        \"import os\\nprint('mount \\\\tsize \\\\tused \\\\tavail \\\\tuse%')\\nfor _m in [''] + os.listdir('/'):\\n _s = os.stat('/' + _m)\\n if not _s[0] & 1 << 14: continue\\n _s = os.statvfs(_m)\\n if _s[0]:\\n  _size = _s[0] * _s[2]; _free = _s[0] * _s[3]; print(_m, _size, _size - _free, _free, int(100 * (_size - _free) / _size), sep='\\\\t')\",\n    ],\n    # Other shortcuts.\n    \"reset\": {\n        \"command\": [\n            \"exec\",\n            \"--no-follow\",\n            \"import time, machine; time.sleep_ms(100); machine.reset()\",\n        ],\n        \"help\": \"hard reset the device\",\n    },\n    \"bootloader\": {\n        \"command\": [\n            \"exec\",\n            \"--no-follow\",\n            \"import time, machine; time.sleep_ms(100); machine.bootloader()\",\n        ],\n        \"help\": \"make the device enter its bootloader\",\n    },\n    # Simple aliases.\n    \"--help\": \"help\",\n    \"--version\": \"version\",\n}\n\n# Add \"a0\", \"a1\", ..., \"u0\", \"u1\", ..., \"c0\", \"c1\", ... as aliases\n# for \"connect /dev/ttyACMn\" (and /dev/ttyUSBn, COMn) etc.\nfor port_num in range(4):\n    for prefix, port in [(\"a\", \"/dev/ttyACM\"), (\"u\", \"/dev/ttyUSB\"), (\"c\", \"COM\")]:\n        _BUILTIN_COMMAND_EXPANSIONS[\"{}{}\".format(prefix, port_num)] = {\n            \"command\": \"connect {}{}\".format(port, port_num),\n            \"help\": 'connect to serial port \"{}{}\"'.format(port, port_num),\n        }\n\n\ndef load_user_config():\n    # Create empty config object.\n    config = __build_class__(lambda: None, \"Config\")()\n    config.commands = {}\n\n    # Get config file name.\n    path = os.getenv(\"XDG_CONFIG_HOME\")\n    if path is None:\n        path = os.getenv(\"HOME\")\n        if path is None:\n            return config\n        path = os.path.join(path, \".config\")\n    path = os.path.join(path, _PROG)\n    config_file = os.path.join(path, \"config.py\")\n\n    # Check if config file exists.\n    if not os.path.exists(config_file):\n        return config\n\n    # Exec the config file in its directory.\n    with open(config_file) as f:\n        config_data = f.read()\n    prev_cwd = os.getcwd()\n    os.chdir(path)\n    exec(config_data, config.__dict__)\n    os.chdir(prev_cwd)\n\n    return config\n\n\ndef prepare_command_expansions(config):\n    global _command_expansions\n\n    _command_expansions = {}\n\n    for command_set in (_BUILTIN_COMMAND_EXPANSIONS, config.commands):\n        for cmd, sub in command_set.items():\n            cmd = cmd.split()\n            if len(cmd) == 1:\n                args = ()\n            else:\n                args = tuple(c.split(\"=\") for c in cmd[1:])\n\n            help_message = \"\"\n            if isinstance(sub, Mapping):\n                help_message = sub.get(\"help\", \"\")\n                sub = sub[\"command\"]\n            if isinstance(sub, str):\n                sub = sub.split()\n            _command_expansions[cmd[0]] = (args, sub, help_message)\n\n\ndef do_command_expansion(args):\n    def usage_error(cmd, exp_args, msg):\n        print(f\"Command {cmd} {msg}; signature is:\")\n        print(\"   \", cmd, \" \".join(\"=\".join(a) for a in exp_args))\n        sys.exit(1)\n\n    last_arg_idx = len(args)\n    pre = []\n    while args and args[0] in _command_expansions:\n        cmd = args.pop(0)\n        exp_args, exp_sub, _ = _command_expansions[cmd]\n        for exp_arg in exp_args:\n            if args and args[0] == \"+\":\n                break\n            exp_arg_name = exp_arg[0]\n            if args and \"=\" not in args[0]:\n                # Argument given without a name.\n                value = args.pop(0)\n            elif args and args[0].startswith(exp_arg_name + \"=\"):\n                # Argument given with correct name.\n                value = args.pop(0).split(\"=\", 1)[1]\n            else:\n                # No argument given, or argument given with a different name.\n                if len(exp_arg) == 1:\n                    # Required argument (it has no default).\n                    usage_error(cmd, exp_args, f\"missing argument {exp_arg_name}\")\n                else:\n                    # Optional argument with a default.\n                    value = exp_arg[1]\n            pre.append(f\"{exp_arg_name}={value}\")\n\n        args[0:0] = exp_sub\n        last_arg_idx = len(exp_sub)\n\n    if last_arg_idx < len(args) and \"=\" in args[last_arg_idx]:\n        # Extra unknown arguments given.\n        arg = args[last_arg_idx].split(\"=\", 1)[0]\n        usage_error(cmd, exp_args, f\"given unexpected argument {arg}\")\n\n    # Insert expansion with optional setting of arguments.\n    if pre:\n        args[0:0] = [\"exec\", \";\".join(pre)]\n\n\nclass State:\n    def __init__(self):\n        self.transport = None\n        self._did_action = False\n        self._auto_soft_reset = True\n\n    def did_action(self):\n        self._did_action = True\n\n    def run_repl_on_completion(self):\n        return not self._did_action\n\n    def ensure_connected(self):\n        if self.transport is None:\n            do_connect(self)\n\n    def ensure_raw_repl(self, soft_reset=None):\n        self.ensure_connected()\n        soft_reset = self._auto_soft_reset if soft_reset is None else soft_reset\n        if soft_reset or not self.transport.in_raw_repl:\n            self.transport.enter_raw_repl(soft_reset=soft_reset)\n            self._auto_soft_reset = False\n\n    def ensure_friendly_repl(self):\n        self.ensure_connected()\n        if self.transport.in_raw_repl:\n            self.transport.exit_raw_repl()\n\n\ndef main():\n    config = load_user_config()\n    prepare_command_expansions(config)\n\n    remaining_args = sys.argv[1:]\n    state = State()\n\n    try:\n        while remaining_args:\n            # Skip the terminator.\n            if remaining_args[0] == \"+\":\n                remaining_args.pop(0)\n                continue\n\n            # Rewrite the front of the list with any matching expansion.\n            do_command_expansion(remaining_args)\n\n            # The (potentially rewritten) command must now be a base command.\n            cmd = remaining_args.pop(0)\n            try:\n                handler_func, parser_func = _COMMANDS[cmd]\n            except KeyError:\n                raise CommandError(f\"'{cmd}' is not a command\")\n\n            # If this command (or any down the chain) has a terminator, then\n            # limit the arguments passed for this command. They will be added\n            # back after processing this command.\n            try:\n                terminator = remaining_args.index(\"+\")\n                command_args = remaining_args[:terminator]\n                extra_args = remaining_args[terminator:]\n            except ValueError:\n                command_args = remaining_args\n                extra_args = []\n\n            # Special case: \"fs ls\" allowed have no path specified.\n            if cmd == \"fs\" and len(command_args) == 1 and command_args[0] == \"ls\":\n                command_args.append(\"\")\n\n            # Use the command-specific argument parser.\n            cmd_parser = parser_func()\n            cmd_parser.prog = cmd\n            # Catch all for unhandled positional arguments (this is the next command).\n            cmd_parser.add_argument(\n                \"next_command\", nargs=argparse.REMAINDER, help=f\"Next {_PROG} command\"\n            )\n            args = cmd_parser.parse_args(command_args)\n\n            # Execute command.\n            handler_func(state, args)\n\n            # Get any leftover unprocessed args.\n            remaining_args = args.next_command + extra_args\n\n        # If no commands were \"actions\" then implicitly finish with the REPL\n        # using default args.\n        if state.run_repl_on_completion():\n            do_repl(state, argparse_repl().parse_args([]))\n\n        return 0\n    except CommandError as e:\n        print(f\"{_PROG}: {e}\", file=sys.stderr)\n        return 1\n    finally:\n        do_disconnect(state)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}