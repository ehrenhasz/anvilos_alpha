{
  "module_name": "console.py",
  "hash_id": "768739f487d5928b22aa57b142566b2d1b109adcc56f986b9bbab61da6ca9cc5",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/mpremote/mpremote/console.py",
  "human_readable_source": "import sys, time\n\ntry:\n    import select, termios\nexcept ImportError:\n    termios = None\n    select = None\n    import msvcrt, signal\n\n\nclass ConsolePosix:\n    def __init__(self):\n        self.infd = sys.stdin.fileno()\n        self.infile = sys.stdin.buffer\n        self.outfile = sys.stdout.buffer\n        if hasattr(self.infile, \"raw\"):\n            self.infile = self.infile.raw\n        if hasattr(self.outfile, \"raw\"):\n            self.outfile = self.outfile.raw\n\n        self.orig_attr = termios.tcgetattr(self.infd)\n\n    def enter(self):\n        # attr is: [iflag, oflag, cflag, lflag, ispeed, ospeed, cc]\n        attr = termios.tcgetattr(self.infd)\n        attr[0] &= ~(\n            termios.BRKINT | termios.ICRNL | termios.INPCK | termios.ISTRIP | termios.IXON\n        )\n        attr[1] = 0\n        attr[2] = attr[2] & ~(termios.CSIZE | termios.PARENB) | termios.CS8\n        attr[3] = 0\n        attr[6][termios.VMIN] = 1\n        attr[6][termios.VTIME] = 0\n        termios.tcsetattr(self.infd, termios.TCSANOW, attr)\n\n    def exit(self):\n        termios.tcsetattr(self.infd, termios.TCSANOW, self.orig_attr)\n\n    def waitchar(self, pyb_serial):\n        # TODO pyb_serial might not have fd\n        select.select([self.infd, pyb_serial.fd], [], [])\n\n    def readchar(self):\n        res = select.select([self.infd], [], [], 0)\n        if res[0]:\n            return self.infile.read(1)\n        else:\n            return None\n\n    def write(self, buf):\n        self.outfile.write(buf)\n\n\nclass ConsoleWindows:\n    KEY_MAP = {\n        b\"H\": b\"A\",  # UP\n        b\"P\": b\"B\",  # DOWN\n        b\"M\": b\"C\",  # RIGHT\n        b\"K\": b\"D\",  # LEFT\n        b\"G\": b\"H\",  # POS1\n        b\"O\": b\"F\",  # END\n        b\"Q\": b\"6~\",  # PGDN\n        b\"I\": b\"5~\",  # PGUP\n        b\"s\": b\"1;5D\",  # CTRL-LEFT,\n        b\"t\": b\"1;5C\",  # CTRL-RIGHT,\n        b\"\\x8d\": b\"1;5A\",  #  CTRL-UP,\n        b\"\\x91\": b\"1;5B\",  # CTRL-DOWN,\n        b\"w\": b\"1;5H\",  # CTRL-POS1\n        b\"u\": b\"1;5F\",  # CTRL-END\n        b\"\\x98\": b\"1;3A\",  #  ALT-UP,\n        b\"\\xa0\": b\"1;3B\",  # ALT-DOWN,\n        b\"\\x9d\": b\"1;3C\",  #  ALT-RIGHT,\n        b\"\\x9b\": b\"1;3D\",  # ALT-LEFT,\n        b\"\\x97\": b\"1;3H\",  #  ALT-POS1,\n        b\"\\x9f\": b\"1;3F\",  # ALT-END,\n        b\"S\": b\"3~\",  # DEL,\n        b\"\\x93\": b\"3;5~\",  # CTRL-DEL\n        b\"R\": b\"2~\",  # INS\n        b\"\\x92\": b\"2;5~\",  # CTRL-INS\n        b\"\\x94\": b\"Z\",  # Ctrl-Tab = BACKTAB,\n    }\n\n    def __init__(self):\n        self.ctrl_c = 0\n\n    def _sigint_handler(self, signo, frame):\n        self.ctrl_c += 1\n\n    def enter(self):\n        signal.signal(signal.SIGINT, self._sigint_handler)\n\n    def exit(self):\n        signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    def inWaiting(self):\n        return 1 if self.ctrl_c or msvcrt.kbhit() else 0\n\n    def waitchar(self, pyb_serial):\n        while not (self.inWaiting() or pyb_serial.inWaiting()):\n            time.sleep(0.01)\n\n    def readchar(self):\n        if self.ctrl_c:\n            self.ctrl_c -= 1\n            return b\"\\x03\"\n        if msvcrt.kbhit():\n            ch = msvcrt.getch()\n            while ch in b\"\\x00\\xe0\":  # arrow or function key prefix?\n                if not msvcrt.kbhit():\n                    return None\n                ch = msvcrt.getch()  # second call returns the actual key code\n                try:\n                    ch = b\"\\x1b[\" + self.KEY_MAP[ch]\n                except KeyError:\n                    return None\n            return ch\n\n    def write(self, buf):\n        buf = buf.decode() if isinstance(buf, bytes) else buf\n        sys.stdout.write(buf)\n        sys.stdout.flush()\n        # for b in buf:\n        #     if isinstance(b, bytes):\n        #         msvcrt.putch(b)\n        #     else:\n        #         msvcrt.putwch(b)\n\n\nif termios:\n    Console = ConsolePosix\n    VT_ENABLED = True\nelse:\n    Console = ConsoleWindows\n\n    # Windows VT mode ( >= win10 only)\n    # https://bugs.python.org/msg291732\n    import ctypes, os\n    from ctypes import wintypes\n\n    kernel32 = ctypes.WinDLL(\"kernel32\", use_last_error=True)\n\n    ERROR_INVALID_PARAMETER = 0x0057\n    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004\n\n    def _check_bool(result, func, args):\n        if not result:\n            raise ctypes.WinError(ctypes.get_last_error())\n        return args\n\n    LPDWORD = ctypes.POINTER(wintypes.DWORD)\n    kernel32.GetConsoleMode.errcheck = _check_bool\n    kernel32.GetConsoleMode.argtypes = (wintypes.HANDLE, LPDWORD)\n    kernel32.SetConsoleMode.errcheck = _check_bool\n    kernel32.SetConsoleMode.argtypes = (wintypes.HANDLE, wintypes.DWORD)\n\n    def set_conout_mode(new_mode, mask=0xFFFFFFFF):\n        # don't assume StandardOutput is a console.\n        # open CONOUT$ instead\n        fdout = os.open(\"CONOUT$\", os.O_RDWR)\n        try:\n            hout = msvcrt.get_osfhandle(fdout)\n            old_mode = wintypes.DWORD()\n            kernel32.GetConsoleMode(hout, ctypes.byref(old_mode))\n            mode = (new_mode & mask) | (old_mode.value & ~mask)\n            kernel32.SetConsoleMode(hout, mode)\n            return old_mode.value\n        finally:\n            os.close(fdout)\n\n    # def enable_vt_mode():\n    mode = mask = ENABLE_VIRTUAL_TERMINAL_PROCESSING\n    try:\n        set_conout_mode(mode, mask)\n        VT_ENABLED = True\n    except WindowsError:\n        VT_ENABLED = False\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}