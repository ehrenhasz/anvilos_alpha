{
  "module_name": "cc1",
  "hash_id": "385c836da315f8f13d6dc7b21be45a82b6dd67d5ef3620158e6647ac906ee2f5",
  "original_prompt": "Ingested from sys_09_Anvil/source/tools/cc1",
  "human_readable_source": "#!/usr/bin/env python3\n\n\"\"\"\nThis is a middle-processor for MicroPython source files.  It takes the output\nof the C preprocessor, has the option to change it, then feeds this into the\nC compiler.\n\nIt currently has the ability to reorder static hash tables so they are actually\nhashed, resulting in faster lookup times at runtime.\n\nTo use, configure the Python variables below, and add the following line to the\nMakefile:\n\nCFLAGS += -no-integrated-cpp -B$(shell pwd)/../tools\n\"\"\"\n\nimport sys\nimport os\nimport re\n\n################################################################################\n# these are the configuration variables\n# TODO somehow make them externally configurable\n\n# this is the path to the true C compiler\ncc1_path = '/usr/lib/gcc/x86_64-unknown-linux-gnu/5.3.0/cc1'\n#cc1_path = '/usr/lib/gcc/arm-none-eabi/5.3.0/cc1'\n\n# this must be the same as MICROPY_QSTR_BYTES_IN_HASH\nbytes_in_qstr_hash = 2\n\n# this must be 1 or more (can be a decimal)\n# larger uses more code size but yields faster lookups\ntable_size_mult = 1\n\n# these control output during processing\nprint_stats = True\nprint_debug = False\n\n# end configuration variables\n################################################################################\n\n# precompile regexs\nre_preproc_line = re.compile(r'# [0-9]+ ')\nre_map_entry = re.compile(r'\\{.+?\\(MP_QSTR_([A-Za-z0-9_]+)\\).+\\},')\nre_mp_obj_dict_t = re.compile(r'(?P<head>(static )?const mp_obj_dict_t (?P<id>[a-z0-9_]+) = \\{ \\.base = \\{&mp_type_dict\\}, \\.map = \\{ \\.all_keys_are_qstrs = 1, \\.is_fixed = 1, \\.is_ordered = )1(?P<tail>, \\.used = .+ };)$')\nre_mp_map_t = re.compile(r'(?P<head>(static )?const mp_map_t (?P<id>[a-z0-9_]+) = \\{ \\.all_keys_are_qstrs = 1, \\.is_fixed = 1, \\.is_ordered = )1(?P<tail>, \\.used = .+ };)$')\nre_mp_rom_map_elem_t = re.compile(r'static const mp_rom_map_elem_t [a-z_0-9]+\\[\\] = {$')\n\n# this must match the equivalent function in qstr.c\ndef compute_hash(qstr):\n    hash = 5381\n    for char in qstr:\n        hash = (hash * 33) ^ ord(char)\n    # Make sure that valid hash is never zero, zero means \"hash not computed\"\n    return (hash & ((1 << (8 * bytes_in_qstr_hash)) - 1)) or 1\n\n# this algo must match the equivalent in map.c\ndef hash_insert(map, key, value):\n    hash = compute_hash(key)\n    pos = hash % len(map)\n    start_pos = pos\n    if print_debug:\n        print('  insert %s: start at %u/%u -- ' % (key, pos, len(map)), end='')\n    while True:\n        if map[pos] is None:\n            # found empty slot, so key is not in table\n            if print_debug:\n                print('put at %u' % pos)\n            map[pos] = (key, value)\n            return\n        else:\n            # not yet found, keep searching\n            if map[pos][0] == key:\n                raise AssertionError(\"duplicate key '%s'\" % (key,))\n            pos = (pos + 1) % len(map)\n            assert pos != start_pos\n\ndef hash_find(map, key):\n    hash = compute_hash(key)\n    pos = hash % len(map)\n    start_pos = pos\n    attempts = 0\n    while True:\n        attempts += 1\n        if map[pos] is None:\n            return attempts, None\n        elif map[pos][0] == key:\n            return attempts, map[pos][1]\n        else:\n            pos = (pos + 1) % len(map)\n            if pos == start_pos:\n                return attempts, None\n\ndef process_map_table(file, line, output):\n    output.append(line)\n\n    # consume all lines that are entries of the table and concat them\n    # (we do it this way because there can be multiple entries on one line)\n    table_contents = []\n    while True:\n        line = file.readline()\n        if len(line) == 0:\n            print('unexpected end of input')\n            sys.exit(1)\n        line = line.strip()\n        if len(line) == 0:\n            # empty line\n            continue\n        if re_preproc_line.match(line):\n            # preprocessor line number comment\n            continue\n        if line == '};':\n            # end of table (we assume it appears on a single line)\n            break\n        table_contents.append(line)\n\n    # make combined string of entries\n    entries_str = ''.join(table_contents)\n\n    # split into individual entries\n    entries = []\n    while entries_str:\n        # look for single entry, by matching nested braces\n        match = None\n        if entries_str[0] == '{':\n            nested_braces = 0\n            for i in range(len(entries_str)):\n                if entries_str[i] == '{':\n                    nested_braces += 1\n                elif entries_str[i] == '}':\n                    nested_braces -= 1\n                    if nested_braces == 0:\n                        match = re_map_entry.match(entries_str[:i + 2])\n                        break\n\n        if not match:\n            print('unknown line in table:', entries_str)\n            sys.exit(1)\n\n        # extract single entry\n        line = match.group(0)\n        qstr = match.group(1)\n        entries_str = entries_str[len(line):].lstrip()\n\n        # add the qstr and the whole line to list of all entries\n        entries.append((qstr, line))\n\n    # sort entries so hash table construction is deterministic\n    entries.sort()\n\n    # create hash table\n    map = [None] * int(len(entries) * table_size_mult)\n    for qstr, line in entries:\n        # We assume that qstr does not have any escape sequences in it.\n        # This is reasonably safe, since keys in a module or class dict\n        # should be standard identifiers.\n        # TODO verify this and raise an error if escape sequence found\n        hash_insert(map, qstr, line)\n\n    # compute statistics\n    total_attempts = 0\n    for qstr, _ in entries:\n        attempts, line = hash_find(map, qstr)\n        assert line is not None\n        if print_debug:\n            print('  %s lookup took %u attempts' % (qstr, attempts))\n        total_attempts += attempts\n    if len(entries):\n        stats = len(map), len(entries) / len(map), total_attempts / len(entries)\n    else:\n        stats = 0, 0, 0\n    if print_debug:\n        print('  table stats: size=%d, load=%.2f, avg_lookups=%.1f' % stats)\n\n    # output hash table\n    for row in map:\n        if row is None:\n            output.append('{ 0, 0 },\\n')\n        else:\n            output.append(row[1] + '\\n')\n    output.append('};\\n')\n\n    # skip to next non-blank line\n    while True:\n        line = file.readline()\n        if len(line) == 0:\n            print('unexpected end of input')\n            sys.exit(1)\n        line = line.strip()\n        if len(line) == 0:\n            continue\n        break\n\n    # transform the is_ordered param from 1 to 0\n    match = re_mp_obj_dict_t.match(line)\n    if match is None:\n        match = re_mp_map_t.match(line)\n    if match is None:\n        print('expecting mp_obj_dict_t or mp_map_t definition')\n        print(output[0])\n        print(line)\n        sys.exit(1)\n    line = match.group('head') + '0' + match.group('tail') + '\\n'\n    output.append(line)\n\n    return (match.group('id'),) + stats\n\ndef process_file(filename):\n    output = []\n    file_changed = False\n    with open(filename, 'rt') as f:\n        while True:\n            line = f.readline()\n            if not line:\n                break\n            if re_mp_rom_map_elem_t.match(line):\n                file_changed = True\n                stats = process_map_table(f, line, output)\n                if print_stats:\n                    print('  [%s: size=%d, load=%.2f, avg_lookups=%.1f]' % stats)\n            else:\n                output.append(line)\n\n    if file_changed:\n        if print_debug:\n            print('  modifying static maps in', output[0].strip())\n        with open(filename, 'wt') as f:\n            for line in output:\n                f.write(line)\n\ndef main():\n    # run actual C compiler\n    # need to quote args that have special characters in them\n    def quote(s):\n        if s.find('<') != -1 or s.find('>') != -1:\n            return \"'\" + s + \"'\"\n        else:\n            return s\n    ret = os.system(cc1_path + ' ' + ' '.join(quote(s) for s in sys.argv[1:]))\n    if ret != 0:\n        ret = (ret & 0x7f) or 127 # make it in range 0-127, but non-zero\n        sys.exit(ret)\n\n    if sys.argv[1] == '-E':\n        # CPP has been run, now do our processing stage\n        for i, arg in enumerate(sys.argv):\n            if arg == '-o':\n                return process_file(sys.argv[i + 1])\n\n        print('%s: could not find \"-o\" option' % (sys.argv[0],))\n        sys.exit(1)\n    elif sys.argv[1] == '-fpreprocessed':\n        # compiler has been run, nothing more to do\n        return\n    else:\n        # unknown processing stage\n        print('%s: unknown first option \"%s\"' % (sys.argv[0], sys.argv[1]))\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}