{
  "module_name": "anvil.py",
  "hash_id": "121071a976e1270ac6b3fc8dc0c241de043bd8e77866a9cc49751caaac678f98",
  "original_prompt": "Ingested from sys_09_Anvil/source/anvil.py",
  "human_readable_source": "#!/usr/bin/env python3\nimport sys\nimport os\nimport re\n\n# Anvil Sovereign Compiler (Stage 1: Transpiler)\n# Converts .anv (Rust-subset) to .c (ANSI C)\n\ndef log(msg):\n    print(f\">> [ANVIL] {msg}\", file=sys.stderr)\n\nTYPE_MAP = {\n    \"u8\": \"uint8_t\",\n    \"u16\": \"uint16_t\",\n    \"u32\": \"uint32_t\",\n    \"u64\": \"uint64_t\",\n    \"i8\": \"int8_t\",\n    \"i16\": \"int16_t\",\n    \"i32\": \"int32_t\",\n    \"i64\": \"int64_t\",\n    \"usize\": \"size_t\",\n    \"bool\": \"int\",\n    \"void\": \"void\",\n    \"&str\": \"const char*\",\n    \"&[u8]\": \"const uint8_t*\",\n    \"Vec<u8>\": \"uint8_t*\"\n}\n\ndef map_type(t, context=\"\"):\n    t = t.strip()\n    if t == \"Self\": return context\n    if t in TYPE_MAP: return TYPE_MAP[t]\n    if t.startswith(\"*const \"): return \"const \" + map_type(t[7:], context) + \"*\"\n    if t.startswith(\"*mut \"): return map_type(t[5:], context) + \"*\"\n    if t.startswith(\"&\"): return map_type(t[1:], context) + \"*\" \n    return t\n\ndef find_blocks(text):\n    blocks = []\n    i = 0\n    n = len(text)\n    while i < n:\n        while i < n and text[i].isspace(): i += 1\n        if i >= n: break\n        start = i\n        brace_open = text.find('{', i)\n        if brace_open == -1: break\n        sig = text[i:brace_open].strip()\n        btype = None\n        bname = None\n        if sig.startswith(\"struct \"):\n            btype = \"struct\"\n            bname = sig[7:].strip()\n        elif sig.startswith(\"impl \"):\n            btype = \"impl\"\n            bname = sig[5:].strip()\n        elif sig.startswith(\"fn \"):\n            btype = \"fn\"\n            m = re.match(r'fn\\s+(\\w+)', sig)\n            if m: bname = m.group(1)\n        count = 1\n        j = brace_open + 1\n        while j < n and count > 0:\n            if text[j] == '{': count += 1\n            elif text[j] == '}': count -= 1\n            j += 1\n        if count == 0:\n            body = text[brace_open+1 : j-1]\n            if btype:\n                blocks.append((btype, bname, body, sig))\n            i = j\n        else:\n            break\n    return blocks\n\ndef generate_header(sources):\n    header = \"#ifndef ANVIL_KERNEL_H\\n#define ANVIL_KERNEL_H\\n\"\n    header += \"#include <stdint.h>\\n#include <stddef.h>\\n\"\n    header += \"#define copy_nonoverlapping(src, dst, count) __builtin_memcpy(dst, src, (count) * sizeof(*(src)))\\n\\n\"\n    \n    # 1. Struct Forward Decls & Definitions\n    for src in sources:\n        blocks = find_blocks(src)\n        for btype, bname, body, sig in blocks:\n            if btype == \"struct\":\n                 header += \"typedef struct %s %s;\\n\" % (bname, bname)\n                 \n    for src in sources:\n        blocks = find_blocks(src)\n        for btype, bname, body, sig in blocks:\n            if btype == \"struct\":\n                 fields = []\n                 for f in body.split(','):\n                    if ':' in f:\n                        parts = f.split(':')\n                        fname = parts[0]\n                        ftype = parts[1]\n                        c_type = map_type(ftype)\n                        arr_match = re.match(r'\\[(.+);(.+)\\]', ftype.strip())\n                        if arr_match:\n                            base_type = map_type(arr_match.group(1))\n                            count = arr_match.group(2)\n                            fields.append(\"    %s %s[%s];\" % (base_type, fname.strip(), count))\n                        else:\n                            fields.append(\"    %s %s;\" % (c_type, fname.strip()))\n                 header += \"struct %s {\\n%s\\n};\\n\" % (bname, \"\\n\".join(fields))\n\n    # 2. Function Prototypes\n    for src in sources:\n        blocks = find_blocks(src)\n        for btype, bname, body, sig in blocks:\n            if btype == \"impl\":\n                 struct_name = bname\n                 inner_blocks = find_blocks(body)\n                 for ibtype, ibname, ibody, isig in inner_blocks:\n                     if ibtype == \"fn\":\n                         m = re.match(r'fn\\s+(\\w+)\\((.*)\\)(.*)', isig, re.DOTALL)\n                         if m:\n                             name = m.group(1)\n                             args = m.group(2)\n                             ret_type = m.group(3).strip() if m.group(3) else None\n                             if ret_type and ret_type.startswith(\"->\"): ret_type = ret_type[2:].strip()\n                             \n                             c_ret = map_type(ret_type, struct_name) if ret_type else \"void\"\n                             c_name = f\"{struct_name}_{name}\"\n                             c_args = []\n                             if args:\n                                for a in args.split(','):\n                                    if ':' in a:\n                                        aname, atype = a.split(':')\n                                        if aname.strip() == \"self\": c_args.append(f\"{struct_name}* self\")\n                                        else: c_args.append(f\"{map_type(atype, struct_name)} {aname.strip()}\")\n                                    elif a.strip() == \"self\": c_args.append(f\"{struct_name} self\")\n                                    elif a.strip() == \"&self\": c_args.append(f\"{struct_name}* self\")\n                                    elif a.strip() == \"&mut self\": c_args.append(f\"{struct_name}* self\")\n                             header += \"%s %s(%s);\\n\" % (c_ret, c_name, ', '.join(c_args))\n\n            elif btype == \"fn\":\n                 m = re.match(r'fn\\s+(\\w+)\\((.*)\\)(.*)', sig, re.DOTALL)\n                 if m:\n                     name = m.group(1)\n                     args = m.group(2)\n                     ret_type = m.group(3).strip() if m.group(3) else None\n                     if ret_type and ret_type.startswith(\"->\"): ret_type = ret_type[2:].strip()\n                     c_ret = map_type(ret_type) if ret_type else \"void\"\n                     c_args = []\n                     if args:\n                        for a in args.split(','):\n                            if ':' in a:\n                                aname, atype = a.split(':')\n                                c_args.append(f\"{map_type(atype)} {aname.strip()}\")\n                     header += \"%s %s(%s);\\n\" % (c_ret, name, ', '.join(c_args))\n\n    header += \"#endif\\n\"\n    return header\n\ndef replace_asm(text):\n    out = \"\"\n    i = 0\n    n = len(text)\n    while i < n:\n        match = re.search(r'asm!\\(', text[i:])\n        if not match:\n            out += text[i:]\n            break\n        \n        start = i + match.start()\n        out += text[i:start]\n        \n        open_idx = start + 4\n        depth = 1\n        j = open_idx + 1\n        in_quote = False\n        while j < n and depth > 0:\n            if text[j] == '\"' and text[j-1] != '\\\\':\n                in_quote = not in_quote\n            if not in_quote:\n                if text[j] == '(': depth += 1\n                elif text[j] == ')': depth -= 1\n            j += 1\n            \n        if depth == 0:\n            asm_content = text[open_idx+1:j-1]\n            out += parse_asm_content(asm_content)\n            i = j\n        else:\n            out += text[start:]\n            break\n    return out\n\ndef parse_asm_content(content):\n    parts = []\n    depth = 0\n    in_quote = False\n    curr = \"\"\n    for char in content:\n        if char == '\"' and (len(curr)==0 or curr[-1] != '\\\\'):\n            in_quote = not in_quote\n            curr += char\n        elif char == ',' and depth == 0 and not in_quote:\n            parts.append(curr.strip())\n            curr = \"\"\n        else:\n            if not in_quote:\n                if char == '(': depth += 1\n                elif char == ')': depth -= 1\n            curr += char\n    parts.append(curr.strip())\n    \n    template = parts[0]\n    # Escape % for C asm\n    if template.startswith('\"') and template.endswith('\"'):\n         inner = template[1:-1]\n         inner = inner.replace('%', '%%')\n         template = f'\"{inner}\"'\n\n    inputs = []\n    outputs = []\n    \n    reg_map = {\"al\":\"a\", \"ax\":\"a\", \"eax\":\"a\", \"rax\":\"a\",\n               \"bl\":\"b\", \"bx\":\"b\", \"ebx\":\"b\", \"rbx\":\"b\",\n               \"cl\":\"c\", \"cx\":\"c\", \"ecx\":\"c\", \"rcx\":\"c\",\n               \"dl\":\"d\", \"dx\":\"d\", \"edx\":\"d\", \"rdx\":\"d\",\n               \"si\":\"S\", \"rsi\":\"S\", \"di\":\"D\", \"rdi\":\"D\"}\n\n    for p in parts[1:]:\n        if p.startswith(\"in\"):\n            m = re.match(r'in\\(\"(\\w+)\"\\)\\s*(.+)', p)\n            if m:\n                reg = reg_map.get(m.group(1), \"r\")\n                inputs.append(f'\"{reg}\"({m.group(2)})')\n        elif p.startswith(\"out\"):\n            m = re.match(r'out\\(\"(\\w+)\"\\)\\s*(.+)', p)\n            if m:\n                reg = reg_map.get(m.group(1), \"r\")\n                outputs.append(f'\"={reg}\"({m.group(2)})')\n    \n    return f'__asm__ volatile({template} : {\", \".join(outputs)} : {\", \".join(inputs)} : );'\n\ndef do_transpile_fn(name, args, ret_type, body, context=\"\"):\n    c_ret = map_type(ret_type, context) if ret_type else \"void\"\n    c_name = f\"{context}_{name}\" if context else name\n    \n    c_args = []\n    if args:\n        for a in args.split(','):\n            if ':' in a:\n                aname, atype = a.split(':')\n                aname = aname.strip()\n                if aname == \"self\": \n                    c_args.append(f\"{context}* self\")\n                else:\n                    c_args.append(f\"{map_type(atype, context)} {aname}\")\n            elif a.strip() == \"self\":\n                 c_args.append(f\"{context} self\") \n            elif a.strip() == \"&self\":\n                 c_args.append(f\"{context}* self\") \n            elif a.strip() == \"&mut self\":\n                 c_args.append(f\"{context}* self\") \n    \n    c_args_str = \", \".join(c_args)\n    \n    c_body = body\n    \n    # 1. ASM Parser (Manual)\n    c_body = replace_asm(c_body)\n\n    # 2. Block/Unsafe/Loop\n    c_body = c_body.replace(\"unsafe{\", \"{\")\n    c_body = c_body.replace(\"loop{\", \"while(1){\") \n    \n    # 3. Let bindings\n    c_body = re.sub(r'let\\s+mut\\s+(\\w+)\\s*:\\s*([^=;]+);', lambda m: f\"{map_type(m.group(2), context)} {m.group(1)};\", c_body)\n    c_body = re.sub(r'let\\s+mut\\s+(\\w+)\\s*:\\s*([^=]+)\\s*=\\s*(.+?);', lambda m: f\"{map_type(m.group(2), context)} {m.group(1)} = {m.group(3)};\", c_body)\n    c_body = re.sub(r'let\\s+mut\\s+(\\w+)\\s*=\\s*(.+?);', lambda m: f\"__auto_type {m.group(1)} = {m.group(2)};\", c_body)\n    c_body = re.sub(r'let\\s+(\\w+)\\s*:\\s*([^=]+)\\s*=\\s*(.+?);', lambda m: f\"{map_type(m.group(2), context)} {m.group(1)} = {m.group(3)};\", c_body)\n    c_body = re.sub(r'let\\s+(\\w+)\\s*=\\s*(.+?);', lambda m: f\"__auto_type {m.group(1)} = {m.group(2)};\", c_body)\n    \n    # 4. Casts\n    c_body = re.sub(r'(0x[0-9a-fA-F]+)as', r'\\1 as', c_body)\n    c_body = re.sub(r'(\\d)as\\b', r'\\1 as', c_body)\n    c_body = re.sub(r'\\)as\\b\\s*[\\w]+', ')', c_body)\n    c_body = re.sub(r'(\\w+)\\s+as\\s*([\\w\\*\\s]+)', lambda m: f\"({map_type(m.group(2), context)}){m.group(1)}\", c_body)\n    \n    # Control Flow\n    c_body = re.sub(r'if\\s+(.+?)\\{', r'if (\\1) {', c_body)\n    c_body = re.sub(r'while\\s+(.+?)\\{', r'while (\\1) {', c_body)\n\n    # 5. Struct Literal\n    c_body = re.sub(r'\\b([A-Z]\\w*)\\{', r'(\\1){', c_body)\n    c_body = re.sub(r'\\[.+?;.+?\\]', '{{0}}', c_body)\n    c_body = re.sub(r'(\\w+):(?!:)', r'.\\1 =', c_body) # Keys\n    \n    # 6. Pointers\n    c_body = c_body.replace(\"self.\", \"self->\")\n    c_body = c_body.replace(\"&mut \", \"&\") # Ref mut -> Addr\n    # *ptr.add(x) -> ptr[x]\n    c_body = re.sub(r'\\*\\s*([\\w\\.\\->]+)\\.add\\((.+?)\\)', r'\\1[\\2]', c_body)\n    # ptr.add(x) -> ptr + x\n    c_body = re.sub(r'\\.add\\((.+?)\\)', r' + \\1', c_body)\n    \n    # Match -> Switch\n    c_body = re.sub(r'match\\s+(.+?)\\{', r'switch(\\1){', c_body)\n    c_body = re.sub(r'(\\d)\\s*=>\\s*\\{', r'case \\1: {', c_body)\n    c_body = re.sub(r'_\\s*=>\\s*\\{', r'default: {', c_body)\n\n    c_body = c_body.replace(\"core::ptr::\", \"\") \n    c_body = c_body.replace(\"::\", \"__\") \n    c_body = c_body.replace(\".as_mut_ptr()\", \"\")\n    c_body = c_body.replace(\".as_ptr()\", \"\")\n\n    # 7. Implicit Return\n    if c_ret != \"void\":\n        c_body = c_body.strip()\n        if not c_body.endswith(';'):\n             if c_body.endswith('}'):\n                 if c_body.lstrip().startswith('(') or c_body.lstrip().startswith(c_ret):\n                      c_body = f\"return {c_body};\"\n                 elif c_body.startswith(\"switch\"):\n                      pass \n             else:\n                 last_semi = c_body.rfind(';')\n                 if last_semi != -1:\n                     last_chunk = c_body[last_semi+1:].strip()\n                     if not last_chunk.startswith(\"}\"): \n                        c_body = c_body[:last_semi+1] + f\"\\nreturn {last_chunk};\"\n                 else:\n                     c_body = f\"return {c_body};\"\n\n    return f\"{c_ret} {c_name}({c_args_str}) {{\\n{c_body}\\n}}\\n\"\n\ndef transpile(source):\n    c_code = '#include \"kernel.h\"\\n\\n'\n    blocks = find_blocks(source)\n    for btype, bname, body, sig in blocks:\n        if btype == \"impl\":\n             struct_name = bname\n             inner_blocks = find_blocks(body)\n             for ibtype, ibname, ibody, isig in inner_blocks:\n                 if ibtype == \"fn\":\n                     m = re.match(r'fn\\s+(\\w+)\\((.*)\\)(.*)', isig, re.DOTALL)\n                     if m:\n                         name = m.group(1)\n                         args = m.group(2)\n                         ret_type = m.group(3).strip() if m.group(3) else None\n                         if ret_type and ret_type.startswith(\"->\"): ret_type = ret_type[2:].strip()\n                         c_code += do_transpile_fn(name, args, ret_type, ibody, struct_name)\n\n    for btype, bname, body, sig in blocks:\n        if btype == \"fn\":\n             m = re.match(r'fn\\s+(\\w+)\\((.*)\\)(.*)', sig, re.DOTALL)\n             if m:\n                 name = m.group(1)\n                 args = m.group(2)\n                 ret_type = m.group(3).strip() if m.group(3) else None\n                 if ret_type and ret_type.startswith(\"->\"): ret_type = ret_type[2:].strip()\n                 c_code += do_transpile_fn(name, args, ret_type, body, \"\")\n\n    return c_code\n\ndef main():\n    if len(sys.argv) < 2:\n        print(\"Usage: anvil <command> [args]\")\n        return\n    cmd = sys.argv[1]\n    \n    if cmd == \"transpile\":\n        if len(sys.argv) < 4: return\n        in_path = sys.argv[2]\n        out_path = sys.argv[3]\n        with open(in_path, 'r') as f: src = f.read()\n        c_src = transpile(src)\n        with open(out_path, 'w') as f: f.write(c_src)\n        log(f\"Transpiled {in_path}\")\n        \n    elif cmd == \"header\":\n        if len(sys.argv) < 4: return\n        out_path = sys.argv[2]\n        in_files = sys.argv[3:]\n        sources = []\n        for p in in_files:\n            with open(p, 'r') as f: sources.append(f.read())\n        header = generate_header(sources)\n        with open(out_path, 'w') as f: f.write(header)\n        log(f\"Generated {out_path}\")\n\nif __name__ == \"__main__\":\n    main()",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}