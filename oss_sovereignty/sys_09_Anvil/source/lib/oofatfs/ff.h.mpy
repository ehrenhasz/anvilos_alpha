{
  "module_name": "ff.h",
  "hash_id": "8505c4c5b3219d875a8e753543fff87d078474746e5d7ac3d39fa44451a8bf29",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/oofatfs/ff.h",
  "human_readable_source": " \n\n \n\n\n#ifndef FF_DEFINED\n#define FF_DEFINED  86604    \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include FFCONF_H        \n\n#if FF_DEFINED != FFCONF_DEF\n#error Wrong configuration file (ffconf.h).\n#endif\n\n\n \n\n#if defined(_WIN32)  \n#define FF_INTDEF 2\n#include <windows.h>\ntypedef unsigned __int64 QWORD;\n#elif (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__cplusplus)     \n#define FF_INTDEF 2\n#include <stdint.h>\ntypedef unsigned int    UINT;    \ntypedef unsigned char   BYTE;    \ntypedef uint16_t        WORD;    \ntypedef uint16_t        WCHAR;   \ntypedef uint32_t        DWORD;   \ntypedef uint64_t        QWORD;   \n#else    \n#define FF_INTDEF 1\ntypedef unsigned int    UINT;    \ntypedef unsigned char   BYTE;    \ntypedef unsigned short  WORD;    \ntypedef unsigned short  WCHAR;   \ntypedef unsigned long   DWORD;   \n#endif\n\n\n \n\n#if FF_STR_VOLUME_ID\n#ifndef FF_VOLUME_STRS\nextern const char* VolumeStr[FF_VOLUMES];    \n#endif\n#endif\n\n\n\n \n\n#ifndef _INC_TCHAR\n#define _INC_TCHAR\n\n#if FF_USE_LFN && FF_LFN_UNICODE == 1    \ntypedef WCHAR TCHAR;\n#define _T(x) L ## x\n#define _TEXT(x) L ## x\n#elif FF_USE_LFN && FF_LFN_UNICODE == 2  \ntypedef char TCHAR;\n#define _T(x) u8 ## x\n#define _TEXT(x) u8 ## x\n#elif FF_USE_LFN && FF_LFN_UNICODE == 3  \ntypedef DWORD TCHAR;\n#define _T(x) U ## x\n#define _TEXT(x) U ## x\n#elif FF_USE_LFN && (FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3)\n#error Wrong FF_LFN_UNICODE setting\n#else                                    \ntypedef char TCHAR;\n#define _T(x) x\n#define _TEXT(x) x\n#endif\n\n#endif\n\n\n\n \n\n#if FF_FS_EXFAT\n#if FF_INTDEF != 2\n#error exFAT feature wants C99 or later\n#endif\ntypedef QWORD FSIZE_t;\n#else\ntypedef DWORD FSIZE_t;\n#endif\n\n\n\n \n\ntypedef struct {\n    void    *drv;           \n#if FF_MULTI_PARTITION       \n    BYTE    part;           \n#endif\n    BYTE    fs_type;         \n    BYTE    n_fats;          \n    BYTE    wflag;           \n    BYTE    fsi_flag;        \n    WORD    id;              \n    WORD    n_rootdir;       \n    WORD    csize;           \n#if FF_MAX_SS != FF_MIN_SS\n    WORD    ssize;           \n#endif\n#if FF_USE_LFN\n    WCHAR*  lfnbuf;          \n#endif\n#if FF_FS_EXFAT\n    BYTE*   dirbuf;          \n#endif\n#if FF_FS_REENTRANT\n    FF_SYNC_t   sobj;        \n#endif\n#if !FF_FS_READONLY\n    DWORD   last_clst;       \n    DWORD   free_clst;       \n#endif\n#if FF_FS_RPATH\n    DWORD   cdir;            \n#if FF_FS_EXFAT\n    DWORD   cdc_scl;         \n    DWORD   cdc_size;        \n    DWORD   cdc_ofs;         \n#endif\n#endif\n    DWORD   n_fatent;        \n    DWORD   fsize;           \n    DWORD   volbase;         \n    DWORD   fatbase;         \n    DWORD   dirbase;         \n    DWORD   database;        \n#if FF_FS_EXFAT\n    DWORD   bitbase;         \n#endif\n    DWORD   winsect;         \n    BYTE    win[FF_MAX_SS];  \n} FATFS;\n\n\n\n \n\ntypedef struct {\n    FATFS*  fs;              \n    WORD    id;              \n    BYTE    attr;            \n    BYTE    stat;            \n    DWORD   sclust;          \n    FSIZE_t objsize;         \n#if FF_FS_EXFAT\n    DWORD   n_cont;          \n    DWORD   n_frag;          \n    DWORD   c_scl;           \n    DWORD   c_size;          \n    DWORD   c_ofs;           \n#endif\n#if FF_FS_LOCK\n    UINT    lockid;          \n#endif\n} FFOBJID;\n\n\n\n \n\ntypedef struct {\n    FFOBJID obj;             \n    BYTE    flag;            \n    BYTE    err;             \n    FSIZE_t fptr;            \n    DWORD   clust;           \n    DWORD   sect;            \n#if !FF_FS_READONLY\n    DWORD   dir_sect;        \n    BYTE*   dir_ptr;         \n#endif\n#if FF_USE_FASTSEEK\n    DWORD*  cltbl;           \n#endif\n#if !FF_FS_TINY\n    BYTE    buf[FF_MAX_SS];  \n#endif\n} FIL;\n\n\n\n \n\ntypedef struct {\n    FFOBJID obj;             \n    DWORD   dptr;            \n    DWORD   clust;           \n    DWORD   sect;            \n    BYTE*   dir;             \n    BYTE    fn[12];          \n#if FF_USE_LFN\n    DWORD   blk_ofs;         \n#endif\n#if FF_USE_FIND\n    const TCHAR* pat;        \n#endif\n} FF_DIR;\n\n\n\n \n\ntypedef struct {\n    FSIZE_t fsize;           \n    WORD    fdate;           \n    WORD    ftime;           \n    BYTE    fattrib;         \n#if FF_USE_LFN\n    TCHAR   altname[FF_SFN_BUF + 1]; \n    TCHAR   fname[FF_LFN_BUF + 1];   \n#else\n    TCHAR   fname[12 + 1];   \n#endif\n} FILINFO;\n\n\n\n \n\ntypedef enum {\n    FR_OK = 0,               \n    FR_DISK_ERR,             \n    FR_INT_ERR,              \n    FR_NOT_READY,            \n    FR_NO_FILE,              \n    FR_NO_PATH,              \n    FR_INVALID_NAME,         \n    FR_DENIED,               \n    FR_EXIST,                \n    FR_INVALID_OBJECT,       \n    FR_WRITE_PROTECTED,      \n    FR_INVALID_DRIVE,        \n    FR_NOT_ENABLED,          \n    FR_NO_FILESYSTEM,        \n    FR_MKFS_ABORTED,         \n    FR_TIMEOUT,              \n    FR_LOCKED,               \n    FR_NOT_ENOUGH_CORE,      \n    FR_TOO_MANY_OPEN_FILES,  \n    FR_INVALID_PARAMETER     \n} FRESULT;\n\n\n\n \n \n\nFRESULT f_open (FATFS *fs, FIL* fp, const TCHAR* path, BYTE mode);   \nFRESULT f_close (FIL* fp);                                           \nFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);            \nFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);     \nFRESULT f_lseek (FIL* fp, FSIZE_t ofs);                              \nFRESULT f_truncate (FIL* fp);                                        \nFRESULT f_sync (FIL* fp);                                            \nFRESULT f_opendir (FATFS *fs, FF_DIR* dp, const TCHAR* path);        \nFRESULT f_closedir (FF_DIR* dp);                                     \nFRESULT f_readdir (FF_DIR* dp, FILINFO* fno);                        \nFRESULT f_findfirst (FF_DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);  \nFRESULT f_findnext (FF_DIR* dp, FILINFO* fno);                       \nFRESULT f_mkdir (FATFS *fs, const TCHAR* path);                      \nFRESULT f_unlink (FATFS *fs, const TCHAR* path);                     \nFRESULT f_rename (FATFS *fs, const TCHAR* path_old, const TCHAR* path_new);  \nFRESULT f_stat (FATFS *fs, const TCHAR* path, FILINFO* fno);         \nFRESULT f_chmod (FATFS *fs, const TCHAR* path, BYTE attr, BYTE mask);  \nFRESULT f_utime (FATFS *fs, const TCHAR* path, const FILINFO* fno);  \nFRESULT f_chdir (FATFS *fs, const TCHAR* path);                      \nFRESULT f_getcwd (FATFS *fs, TCHAR* buff, UINT len);                 \nFRESULT f_getfree (FATFS *fs, DWORD* nclst);                         \nFRESULT f_getlabel (FATFS *fs, TCHAR* label, DWORD* vsn);            \nFRESULT f_setlabel (FATFS *fs, const TCHAR* label);                  \nFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);  \nFRESULT f_expand (FIL* fp, FSIZE_t szf, BYTE opt);                   \nFRESULT f_mount (FATFS* fs);                                         \nFRESULT f_umount (FATFS* fs);                                        \nFRESULT f_mkfs (FATFS *fs, BYTE opt, DWORD au, void* work, UINT len);  \nFRESULT f_fdisk (void *pdrv, const DWORD* szt, void* work);          \nFRESULT f_setcp (WORD cp);                                           \n\n#define f_eof(fp) ((int)((fp)->fptr == (fp)->obj.objsize))\n#define f_error(fp) ((fp)->err)\n#define f_tell(fp) ((fp)->fptr)\n#define f_size(fp) ((fp)->obj.objsize)\n#define f_rewind(fp) f_lseek((fp), 0)\n#define f_rewinddir(dp) f_readdir((dp), 0)\n#define f_rmdir(path) f_unlink(path)\n#define f_unmount(path) f_mount(0, path, 0)\n\n#ifndef EOF\n#define EOF (-1)\n#endif\n\n\n\n\n \n \n\n \n#if !FF_FS_READONLY && !FF_FS_NORTC\nDWORD get_fattime (void);\n#endif\n\n \n#if FF_USE_LFN >= 1                      \nWCHAR ff_oem2uni (WCHAR oem, WORD cp);   \nWCHAR ff_uni2oem (DWORD uni, WORD cp);   \nDWORD ff_wtoupper (DWORD uni);           \n#endif\n#if FF_USE_LFN == 3                      \nvoid* ff_memalloc (UINT msize);          \nvoid ff_memfree (void* mblock);          \n#endif\n\n \n#if FF_FS_REENTRANT\nint ff_cre_syncobj (FATFS *fatfs, FF_SYNC_t* sobj);  \nint ff_req_grant (FF_SYNC_t sobj);       \nvoid ff_rel_grant (FF_SYNC_t sobj);      \nint ff_del_syncobj (FF_SYNC_t sobj);     \n#endif\n\n\n\n\n \n \n\n\n \n#define FA_READ             0x01\n#define FA_WRITE            0x02\n#define FA_OPEN_EXISTING    0x00\n#define FA_CREATE_NEW       0x04\n#define FA_CREATE_ALWAYS    0x08\n#define FA_OPEN_ALWAYS      0x10\n#define FA_OPEN_APPEND      0x30\n\n \n#define CREATE_LINKMAP  ((FSIZE_t)0 - 1)\n\n \n#define FM_FAT      0x01\n#define FM_FAT32    0x02\n#define FM_EXFAT    0x04\n#define FM_ANY      0x07\n#define FM_SFD      0x08\n\n \n#define FS_FAT12    1\n#define FS_FAT16    2\n#define FS_FAT32    3\n#define FS_EXFAT    4\n\n \n#define AM_RDO  0x01     \n#define AM_HID  0x02     \n#define AM_SYS  0x04     \n#define AM_DIR  0x10     \n#define AM_ARC  0x20     \n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}