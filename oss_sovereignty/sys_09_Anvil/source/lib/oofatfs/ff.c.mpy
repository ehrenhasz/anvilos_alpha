{
  "module_name": "ff.c",
  "hash_id": "815ab58cf2a5e3a0b700bed3e9c8c629366da8336d7556fe8f0453e716b3054f",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/oofatfs/ff.c",
  "human_readable_source": " \n\n \n\n\n#include <string.h>\n\n#include \"ff.h\"          \n#include \"diskio.h\"      \n\n\n#define DIR FF_DIR\n\n \n\n#if FF_DEFINED != 86604  \n#error Wrong include file (ff.h).\n#endif\n\n\n \n#define MAX_DIR     0x200000         \n#define MAX_DIR_EX  0x10000000       \n#define MAX_FAT12   0xFF5            \n#define MAX_FAT16   0xFFF5           \n#define MAX_FAT32   0x0FFFFFF5       \n#define MAX_EXFAT   0x7FFFFFFD       \n\n\n \n#define IsUpper(c)      ((c) >= 'A' && (c) <= 'Z')\n#define IsLower(c)      ((c) >= 'a' && (c) <= 'z')\n#define IsDigit(c)      ((c) >= '0' && (c) <= '9')\n#define IsSurrogate(c)  ((c) >= 0xD800 && (c) <= 0xDFFF)\n#define IsSurrogateH(c) ((c) >= 0xD800 && (c) <= 0xDBFF)\n#define IsSurrogateL(c) ((c) >= 0xDC00 && (c) <= 0xDFFF)\n\n\n \n#define FA_SEEKEND  0x20     \n#define FA_MODIFIED 0x40     \n#define FA_DIRTY    0x80     \n\n\n \n#define AM_VOL      0x08     \n#define AM_LFN      0x0F     \n#define AM_MASK     0x3F     \n\n\n \n#define NSFLAG      11       \n#define NS_LOSS     0x01     \n#define NS_LFN      0x02     \n#define NS_LAST     0x04     \n#define NS_BODY     0x08     \n#define NS_EXT      0x10     \n#define NS_DOT      0x20     \n#define NS_NOLFN    0x40     \n#define NS_NONAME   0x80     \n\n\n \n#define ET_BITMAP   0x81     \n#define ET_UPCASE   0x82     \n#define ET_VLABEL   0x83     \n#define ET_FILEDIR  0x85     \n#define ET_STREAM   0xC0     \n#define ET_FILENAME 0xC1     \n\n\n \n\n#define BS_JmpBoot          0        \n#define BS_OEMName          3        \n#define BPB_BytsPerSec      11       \n#define BPB_SecPerClus      13       \n#define BPB_RsvdSecCnt      14       \n#define BPB_NumFATs         16       \n#define BPB_RootEntCnt      17       \n#define BPB_TotSec16        19       \n#define BPB_Media           21       \n#define BPB_FATSz16         22       \n#define BPB_SecPerTrk       24       \n#define BPB_NumHeads        26       \n#define BPB_HiddSec         28       \n#define BPB_TotSec32        32       \n#define BS_DrvNum           36       \n#define BS_NTres            37       \n#define BS_BootSig          38       \n#define BS_VolID            39       \n#define BS_VolLab           43       \n#define BS_FilSysType       54       \n#define BS_BootCode         62       \n#define BS_55AA             510      \n\n#define BPB_FATSz32         36       \n#define BPB_ExtFlags32      40       \n#define BPB_FSVer32         42       \n#define BPB_RootClus32      44       \n#define BPB_FSInfo32        48       \n#define BPB_BkBootSec32     50       \n#define BS_DrvNum32         64       \n#define BS_NTres32          65       \n#define BS_BootSig32        66       \n#define BS_VolID32          67       \n#define BS_VolLab32         71       \n#define BS_FilSysType32     82       \n#define BS_BootCode32       90       \n\n#define BPB_ZeroedEx        11       \n#define BPB_VolOfsEx        64       \n#define BPB_TotSecEx        72       \n#define BPB_FatOfsEx        80       \n#define BPB_FatSzEx         84       \n#define BPB_DataOfsEx       88       \n#define BPB_NumClusEx       92       \n#define BPB_RootClusEx      96       \n#define BPB_VolIDEx         100      \n#define BPB_FSVerEx         104      \n#define BPB_VolFlagEx       106      \n#define BPB_BytsPerSecEx    108      \n#define BPB_SecPerClusEx    109      \n#define BPB_NumFATsEx       110      \n#define BPB_DrvNumEx        111      \n#define BPB_PercInUseEx     112      \n#define BPB_RsvdEx          113      \n#define BS_BootCodeEx       120      \n\n#define DIR_Name            0        \n#define DIR_Attr            11       \n#define DIR_NTres           12       \n#define DIR_CrtTime10       13       \n#define DIR_CrtTime         14       \n#define DIR_LstAccDate      18       \n#define DIR_FstClusHI       20       \n#define DIR_ModTime         22       \n#define DIR_FstClusLO       26       \n#define DIR_FileSize        28       \n#define LDIR_Ord            0        \n#define LDIR_Attr           11       \n#define LDIR_Type           12       \n#define LDIR_Chksum         13       \n#define LDIR_FstClusLO      26       \n#define XDIR_Type           0        \n#define XDIR_NumLabel       1        \n#define XDIR_Label          2        \n#define XDIR_CaseSum        4        \n#define XDIR_NumSec         1        \n#define XDIR_SetSum         2        \n#define XDIR_Attr           4        \n#define XDIR_CrtTime        8        \n#define XDIR_ModTime        12       \n#define XDIR_AccTime        16       \n#define XDIR_CrtTime10      20       \n#define XDIR_ModTime10      21       \n#define XDIR_CrtTZ          22       \n#define XDIR_ModTZ          23       \n#define XDIR_AccTZ          24       \n#define XDIR_GenFlags       33       \n#define XDIR_NumName        35       \n#define XDIR_NameHash       36       \n#define XDIR_ValidFileSize  40       \n#define XDIR_FstClus        52       \n#define XDIR_FileSize       56       \n\n#define SZDIRE              32       \n#define DDEM                0xE5     \n#define RDDEM               0x05     \n#define LLEF                0x40     \n\n#define FSI_LeadSig         0        \n#define FSI_StrucSig        484      \n#define FSI_Free_Count      488      \n#define FSI_Nxt_Free        492      \n\n#define MBR_Table           446      \n#define SZ_PTE              16       \n#define PTE_Boot            0        \n#define PTE_StHead          1        \n#define PTE_StSec           2        \n#define PTE_StCyl           3        \n#define PTE_System          4        \n#define PTE_EdHead          5        \n#define PTE_EdSec           6        \n#define PTE_EdCyl           7        \n#define PTE_StLba           8        \n#define PTE_SizLba          12       \n\n\n \n#define ABORT(fs, res)      { fp->err = (BYTE)(res); LEAVE_FF(fs, res); }\n\n\n \n#if FF_FS_REENTRANT\n#if FF_USE_LFN == 1\n#error Static LFN work area cannot be used at thread-safe configuration\n#endif\n#define LEAVE_FF(fs, res)   { unlock_fs(fs, res); return res; }\n#else\n#define LEAVE_FF(fs, res)   return res\n#endif\n\n\n \n#if FF_MULTI_PARTITION\n#define LD2PT(fs) (fs->part)     \n#else\n#define LD2PT(fs) 0              \n#endif\n\n\n \n#if (FF_MAX_SS < FF_MIN_SS) || (FF_MAX_SS != 512 && FF_MAX_SS != 1024 && FF_MAX_SS != 2048 && FF_MAX_SS != 4096) || (FF_MIN_SS != 512 && FF_MIN_SS != 1024 && FF_MIN_SS != 2048 && FF_MIN_SS != 4096)\n#error Wrong sector size configuration\n#endif\n#if FF_MAX_SS == FF_MIN_SS\n#define SS(fs)  ((UINT)FF_MAX_SS)    \n#else\n#define SS(fs)  ((fs)->ssize)    \n#endif\n\n\n \n#if FF_FS_NORTC == 1\n#if FF_NORTC_YEAR < 1980 || FF_NORTC_YEAR > 2107 || FF_NORTC_MON < 1 || FF_NORTC_MON > 12 || FF_NORTC_MDAY < 1 || FF_NORTC_MDAY > 31\n#error Invalid FF_FS_NORTC settings\n#endif\n#define GET_FATTIME()   ((DWORD)(FF_NORTC_YEAR - 1980) << 25 | (DWORD)FF_NORTC_MON << 21 | (DWORD)FF_NORTC_MDAY << 16)\n#else\n#define GET_FATTIME()   get_fattime()\n#endif\n\n\n \n#if FF_FS_LOCK != 0\n#if FF_FS_READONLY\n#error FF_FS_LOCK must be 0 at read-only configuration\n#endif\ntypedef struct {\n    FATFS *fs;       \n    DWORD clu;       \n    DWORD ofs;       \n    WORD ctr;        \n} FILESEM;\n#endif\n\n\n \n#define TBL_CT437  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT720  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT737  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \\\n                    0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT771  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}\n#define TBL_CT775  {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \\\n                    0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT850  {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \\\n                    0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \\\n                    0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \\\n                    0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT852  {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \\\n                    0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \\\n                    0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}\n#define TBL_CT855  {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \\\n                    0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \\\n                    0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \\\n                    0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \\\n                    0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT857  {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \\\n                    0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT860  {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \\\n                    0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT861  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \\\n                    0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT862  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT863  {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \\\n                    0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \\\n                    0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT864  {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT865  {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \\\n                    0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \\\n                    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT866  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \\\n                    0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}\n#define TBL_CT869  {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \\\n                    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \\\n                    0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \\\n                    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \\\n                    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \\\n                    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \\\n                    0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \\\n                    0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}\n\n\n \n#define TBL_DC932 {0x81, 0x9F, 0xE0, 0xFC, 0x40, 0x7E, 0x80, 0xFC, 0x00, 0x00}\n#define TBL_DC936 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0x80, 0xFE, 0x00, 0x00}\n#define TBL_DC949 {0x81, 0xFE, 0x00, 0x00, 0x41, 0x5A, 0x61, 0x7A, 0x81, 0xFE}\n#define TBL_DC950 {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0xA1, 0xFE, 0x00, 0x00}\n\n\n \n#define MERGE_2STR(a, b) a ## b\n#define MKCVTBL(hd, cp) MERGE_2STR(hd, cp)\n\n\n\n\n \n \n\n \n \n \n\n#if FF_VOLUMES < 1 || FF_VOLUMES > 10\n#error Wrong FF_VOLUMES setting\n#endif\nstatic WORD Fsid;                    \n\n#if FF_FS_LOCK != 0\nstatic FILESEM Files[FF_FS_LOCK];    \n#endif\n\n#if FF_STR_VOLUME_ID\n#ifdef FF_VOLUME_STRS\nstatic const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};   \n#endif\n#endif\n\n\n \n \n \n\n#if FF_USE_LFN == 0      \n#if FF_FS_EXFAT\n#error LFN must be enabled when enable exFAT\n#endif\n#define DEF_NAMBUF\n#define INIT_NAMBUF(fs)\n#define FREE_NAMBUF()\n#define LEAVE_MKFS(res) return res\n\n#else                    \n#if FF_MAX_LFN < 12 || FF_MAX_LFN > 255\n#error Wrong setting of FF_MAX_LFN\n#endif\n#if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12\n#error Wrong setting of FF_LFN_BUF or FF_SFN_BUF\n#endif\n#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3\n#error Wrong setting of FF_LFN_UNICODE\n#endif\nstatic const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};    \n#define MAXDIRB(nc) ((nc + 44U) / 15 * SZDIRE)   \n\n#if FF_USE_LFN == 1      \n#if FF_FS_EXFAT\nstatic BYTE DirBuf[MAXDIRB(FF_MAX_LFN)];     \n#endif\nstatic WCHAR LfnBuf[FF_MAX_LFN + 1];         \n#define DEF_NAMBUF\n#define INIT_NAMBUF(fs)\n#define FREE_NAMBUF()\n#define LEAVE_MKFS(res) return res\n\n#elif FF_USE_LFN == 2    \n#if FF_FS_EXFAT\n#define DEF_NAMBUF      WCHAR lbuf[FF_MAX_LFN+1]; BYTE dbuf[MAXDIRB(FF_MAX_LFN)];    \n#define INIT_NAMBUF(fs) { (fs)->lfnbuf = lbuf; (fs)->dirbuf = dbuf; }\n#define FREE_NAMBUF()\n#else\n#define DEF_NAMBUF      WCHAR lbuf[FF_MAX_LFN+1];    \n#define INIT_NAMBUF(fs) { (fs)->lfnbuf = lbuf; }\n#define FREE_NAMBUF()\n#endif\n#define LEAVE_MKFS(res) return res\n\n#elif FF_USE_LFN == 3    \n#if FF_FS_EXFAT\n#define DEF_NAMBUF      WCHAR *lfn;  \n#define INIT_NAMBUF(fs) { lfn = ff_memalloc((FF_MAX_LFN+1)*2 + MAXDIRB(FF_MAX_LFN)); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+FF_MAX_LFN+1); }\n#define FREE_NAMBUF()   ff_memfree(lfn)\n#else\n#define DEF_NAMBUF      WCHAR *lfn;  \n#define INIT_NAMBUF(fs) { lfn = ff_memalloc((FF_MAX_LFN+1)*2); if (!lfn) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); (fs)->lfnbuf = lfn; }\n#define FREE_NAMBUF()   ff_memfree(lfn)\n#endif\n#define LEAVE_MKFS(res) { if (!work) ff_memfree(buf); return res; }\n#define MAX_MALLOC  0x8000   \n\n#else\n#error Wrong setting of FF_USE_LFN\n\n#endif   \n#endif   \n\n\n\n \n \n \n\n#if FF_CODE_PAGE == 0        \n#define CODEPAGE CodePage\nstatic WORD CodePage;    \nstatic const BYTE *ExCvt, *DbcTbl;   \n\nstatic const BYTE Ct437[] = TBL_CT437;\nstatic const BYTE Ct720[] = TBL_CT720;\nstatic const BYTE Ct737[] = TBL_CT737;\nstatic const BYTE Ct771[] = TBL_CT771;\nstatic const BYTE Ct775[] = TBL_CT775;\nstatic const BYTE Ct850[] = TBL_CT850;\nstatic const BYTE Ct852[] = TBL_CT852;\nstatic const BYTE Ct855[] = TBL_CT855;\nstatic const BYTE Ct857[] = TBL_CT857;\nstatic const BYTE Ct860[] = TBL_CT860;\nstatic const BYTE Ct861[] = TBL_CT861;\nstatic const BYTE Ct862[] = TBL_CT862;\nstatic const BYTE Ct863[] = TBL_CT863;\nstatic const BYTE Ct864[] = TBL_CT864;\nstatic const BYTE Ct865[] = TBL_CT865;\nstatic const BYTE Ct866[] = TBL_CT866;\nstatic const BYTE Ct869[] = TBL_CT869;\nstatic const BYTE Dc932[] = TBL_DC932;\nstatic const BYTE Dc936[] = TBL_DC936;\nstatic const BYTE Dc949[] = TBL_DC949;\nstatic const BYTE Dc950[] = TBL_DC950;\n\n#elif FF_CODE_PAGE < 900     \n#define CODEPAGE FF_CODE_PAGE\nstatic const BYTE ExCvt[] = MKCVTBL(TBL_CT, FF_CODE_PAGE);\n\n#else                    \n#define CODEPAGE FF_CODE_PAGE\nstatic const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_CODE_PAGE);\n\n#endif\n\n\n\n\n \n\n\n \n \n \n\nstatic WORD ld_word (const BYTE* ptr)    \n{\n    WORD rv;\n\n    rv = ptr[1];\n    rv = rv << 8 | ptr[0];\n    return rv;\n}\n\nstatic DWORD ld_dword (const BYTE* ptr)  \n{\n    DWORD rv;\n\n    rv = ptr[3];\n    rv = rv << 8 | ptr[2];\n    rv = rv << 8 | ptr[1];\n    rv = rv << 8 | ptr[0];\n    return rv;\n}\n\n#if FF_FS_EXFAT\nstatic QWORD ld_qword (const BYTE* ptr)  \n{\n    QWORD rv;\n\n    rv = ptr[7];\n    rv = rv << 8 | ptr[6];\n    rv = rv << 8 | ptr[5];\n    rv = rv << 8 | ptr[4];\n    rv = rv << 8 | ptr[3];\n    rv = rv << 8 | ptr[2];\n    rv = rv << 8 | ptr[1];\n    rv = rv << 8 | ptr[0];\n    return rv;\n}\n#endif\n\n#if !FF_FS_READONLY\nstatic void st_word (BYTE* ptr, WORD val)    \n{\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val;\n}\n\nstatic void st_dword (BYTE* ptr, DWORD val)  \n{\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val;\n}\n\n#if FF_FS_EXFAT\nstatic void st_qword (BYTE* ptr, QWORD val)  \n{\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val; val >>= 8;\n    *ptr++ = (BYTE)val;\n}\n#endif\n#endif   \n\n\n\n \n \n \n\n\n\n\n#define mem_cpy memcpy\n#define mem_set memset\n#define mem_cmp memcmp\n\n\n \nstatic int chk_chr (const char* str, int chr)    \n{\n    while (*str && *str != chr) str++;\n    return *str;\n}\n\n\n \nstatic int dbc_1st (BYTE c)\n{\n#if FF_CODE_PAGE == 0        \n    if (DbcTbl && c >= DbcTbl[0]) {\n        if (c <= DbcTbl[1]) return 1;                    \n        if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;  \n    }\n#elif FF_CODE_PAGE >= 900    \n    if (c >= DbcTbl[0]) {\n        if (c <= DbcTbl[1]) return 1;\n        if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;\n    }\n#else                        \n    if (c != 0) return 0;    \n#endif\n    return 0;\n}\n\n\n \nstatic int dbc_2nd (BYTE c)\n{\n#if FF_CODE_PAGE == 0        \n    if (DbcTbl && c >= DbcTbl[4]) {\n        if (c <= DbcTbl[5]) return 1;                    \n        if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;  \n        if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;  \n    }\n#elif FF_CODE_PAGE >= 900    \n    if (c >= DbcTbl[4]) {\n        if (c <= DbcTbl[5]) return 1;\n        if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;\n        if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;\n    }\n#else                        \n    if (c != 0) return 0;    \n#endif\n    return 0;\n}\n\n\n#if FF_USE_LFN\n\n \nstatic DWORD tchar2uni (     \n    const TCHAR** str        \n)\n{\n    DWORD uc;\n    const TCHAR *p = *str;\n\n#if FF_LFN_UNICODE == 1      \n    WCHAR wc;\n\n    uc = *p++;   \n    if (IsSurrogate(uc)) {   \n        wc = *p++;       \n        if (!IsSurrogateH(uc) || !IsSurrogateL(wc)) return 0xFFFFFFFF;   \n        uc = uc << 16 | wc;\n    }\n\n#elif FF_LFN_UNICODE == 2    \n    BYTE b;\n    int nf;\n\n    uc = (BYTE)*p++;     \n    if (uc & 0x80) {     \n        if ((uc & 0xE0) == 0xC0) {   \n            uc &= 0x1F; nf = 1;\n        } else {\n            if ((uc & 0xF0) == 0xE0) {   \n                uc &= 0x0F; nf = 2;\n            } else {\n                if ((uc & 0xF8) == 0xF0) {   \n                    uc &= 0x07; nf = 3;\n                } else {                     \n                    return 0xFFFFFFFF;\n                }\n            }\n        }\n        do {     \n            b = (BYTE)*p++;\n            if ((b & 0xC0) != 0x80) return 0xFFFFFFFF;   \n            uc = uc << 6 | (b & 0x3F);\n        } while (--nf != 0);\n        if (uc < 0x80 || IsSurrogate(uc) || uc >= 0x110000) return 0xFFFFFFFF;   \n        if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);  \n    }\n\n#elif FF_LFN_UNICODE == 3    \n    uc = (TCHAR)*p++;    \n    if (uc >= 0x110000) return 0xFFFFFFFF;   \n    if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);  \n\n#else        \n    BYTE b;\n    WCHAR wc;\n\n    wc = (BYTE)*p++;             \n    if (dbc_1st((BYTE)wc)) {     \n        b = (BYTE)*p++;          \n        if (!dbc_2nd(b)) return 0xFFFFFFFF;  \n        wc = (wc << 8) + b;      \n    }\n    if (wc != 0) {\n        wc = ff_oem2uni(wc, CODEPAGE);   \n        if (wc == 0) return 0xFFFFFFFF;  \n    }\n    uc = wc;\n\n#endif\n    *str = p;    \n    return uc;\n}\n\n\n \nstatic BYTE put_utf (    \n    DWORD chr,   \n    TCHAR* buf,  \n    UINT szb     \n)\n{\n#if FF_LFN_UNICODE == 1  \n    WCHAR hs, wc;\n\n    hs = (WCHAR)(chr >> 16);\n    wc = (WCHAR)chr;\n    if (hs == 0) {   \n        if (szb < 1 || IsSurrogate(wc)) return 0;    \n        *buf = wc;\n        return 1;\n    }\n    if (szb < 2 || !IsSurrogateH(hs) || !IsSurrogateL(wc)) return 0;     \n    *buf++ = hs;\n    *buf++ = wc;\n    return 2;\n\n#elif FF_LFN_UNICODE == 2    \n    DWORD hc;\n\n    if (chr < 0x80) {    \n        if (szb < 1) return 0;   \n        *buf = (TCHAR)chr;\n        return 1;\n    }\n    if (chr < 0x800) {   \n        if (szb < 2) return 0;   \n        *buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));\n        *buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));\n        return 2;\n    }\n    if (chr < 0x10000) {     \n        if (szb < 3 || IsSurrogate(chr)) return 0;   \n        *buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));\n        *buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));\n        *buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));\n        return 3;\n    }\n     \n    if (szb < 4) return 0;   \n    hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;     \n    chr = (chr & 0xFFFF) - 0xDC00;                   \n    if (hc >= 0x100000 || chr >= 0x400) return 0;    \n    chr = (hc | chr) + 0x10000;\n    *buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));\n    *buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));\n    *buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));\n    *buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));\n    return 4;\n\n#elif FF_LFN_UNICODE == 3    \n    DWORD hc;\n\n    if (szb < 1) return 0;   \n    if (chr >= 0x10000) {    \n        hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;     \n        chr = (chr & 0xFFFF) - 0xDC00;                   \n        if (hc >= 0x100000 || chr >= 0x400) return 0;    \n        chr = (hc | chr) + 0x10000;\n    }\n    *buf++ = (TCHAR)chr;\n    return 1;\n\n#else                        \n    WCHAR wc;\n\n    wc = ff_uni2oem(chr, CODEPAGE);\n    if (wc >= 0x100) {   \n        if (szb < 2) return 0;\n        *buf++ = (char)(wc >> 8);    \n        *buf++ = (TCHAR)wc;          \n        return 2;\n    }\n    if (wc == 0 || szb < 1) return 0;    \n    *buf++ = (TCHAR)wc;                  \n    return 1;\n#endif\n}\n#endif   \n\n\n#if FF_FS_REENTRANT\n \n \n \nstatic int lock_fs (         \n    FATFS* fs        \n)\n{\n    return ff_req_grant(fs->sobj);\n}\n\n\nstatic void unlock_fs (\n    FATFS* fs,       \n    FRESULT res      \n)\n{\n    if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {\n        ff_rel_grant(fs->sobj);\n    }\n}\n\n#endif\n\n\n\n#if FF_FS_LOCK != 0\n \n \n \n\nstatic FRESULT chk_lock (    \n    DIR* dp,         \n    int acc          \n)\n{\n    UINT i, be;\n\n     \n    be = 0;\n    for (i = 0; i < FF_FS_LOCK; i++) {\n        if (Files[i].fs) {   \n            if (Files[i].fs == dp->obj.fs &&         \n                Files[i].clu == dp->obj.sclust &&\n                Files[i].ofs == dp->dptr) break;\n        } else {             \n            be = 1;\n        }\n    }\n    if (i == FF_FS_LOCK) {   \n        return (!be && acc != 2) ? FR_TOO_MANY_OPEN_FILES : FR_OK;   \n    }\n\n     \n    return (acc != 0 || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;\n}\n\n\nstatic int enq_lock (void)   \n{\n    UINT i;\n\n    for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;\n    return (i == FF_FS_LOCK) ? 0 : 1;\n}\n\n\nstatic UINT inc_lock (   \n    DIR* dp,     \n    int acc      \n)\n{\n    UINT i;\n\n\n    for (i = 0; i < FF_FS_LOCK; i++) {   \n        if (Files[i].fs == dp->obj.fs &&\n            Files[i].clu == dp->obj.sclust &&\n            Files[i].ofs == dp->dptr) break;\n    }\n\n    if (i == FF_FS_LOCK) {               \n        for (i = 0; i < FF_FS_LOCK && Files[i].fs; i++) ;\n        if (i == FF_FS_LOCK) return 0;   \n        Files[i].fs = dp->obj.fs;\n        Files[i].clu = dp->obj.sclust;\n        Files[i].ofs = dp->dptr;\n        Files[i].ctr = 0;\n    }\n\n    if (acc >= 1 && Files[i].ctr) return 0;  \n\n    Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;   \n\n    return i + 1;    \n}\n\n\nstatic FRESULT dec_lock (    \n    UINT i           \n)\n{\n    WORD n;\n    FRESULT res;\n\n\n    if (--i < FF_FS_LOCK) {  \n        n = Files[i].ctr;\n        if (n == 0x100) n = 0;       \n        if (n > 0) n--;              \n        Files[i].ctr = n;\n        if (n == 0) Files[i].fs = 0;     \n        res = FR_OK;\n    } else {\n        res = FR_INT_ERR;            \n    }\n    return res;\n}\n\n\nstatic void clear_lock (     \n    FATFS *fs\n)\n{\n    UINT i;\n\n    for (i = 0; i < FF_FS_LOCK; i++) {\n        if (Files[i].fs == fs) Files[i].fs = 0;\n    }\n}\n\n#endif   \n\n\n\n \n \n \n#if !FF_FS_READONLY\nstatic FRESULT sync_window (     \n    FATFS* fs            \n)\n{\n    FRESULT res = FR_OK;\n\n\n    if (fs->wflag) {     \n        if (disk_write(fs->drv, fs->win, fs->winsect, 1) == RES_OK) {    \n            fs->wflag = 0;   \n            if (fs->winsect - fs->fatbase < fs->fsize) {     \n                if (fs->n_fats == 2) disk_write(fs->drv, fs->win, fs->winsect + fs->fsize, 1);  \n            }\n        } else {\n            res = FR_DISK_ERR;\n        }\n    }\n    return res;\n}\n#endif\n\n\nstatic FRESULT move_window (     \n    FATFS* fs,           \n    DWORD sector         \n)\n{\n    FRESULT res = FR_OK;\n\n\n    if (sector != fs->winsect) {     \n#if !FF_FS_READONLY\n        res = sync_window(fs);       \n#endif\n        if (res == FR_OK) {          \n            if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {\n                sector = 0xFFFFFFFF;     \n                res = FR_DISK_ERR;\n            }\n            fs->winsect = sector;\n        }\n    }\n    return res;\n}\n\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic FRESULT sync_fs (     \n    FATFS* fs        \n)\n{\n    FRESULT res;\n\n\n    res = sync_window(fs);\n    if (res == FR_OK) {\n        if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {  \n             \n            mem_set(fs->win, 0, sizeof fs->win);\n            st_word(fs->win + BS_55AA, 0xAA55);\n            st_dword(fs->win + FSI_LeadSig, 0x41615252);\n            st_dword(fs->win + FSI_StrucSig, 0x61417272);\n            st_dword(fs->win + FSI_Free_Count, fs->free_clst);\n            st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);\n             \n            fs->winsect = fs->volbase + 1;\n            disk_write(fs->drv, fs->win, fs->winsect, 1);\n            fs->fsi_flag = 0;\n        }\n         \n        if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;\n    }\n\n    return res;\n}\n\n#endif\n\n\n\n \n \n \n\nstatic DWORD clst2sect (     \n    FATFS* fs,       \n    DWORD clst       \n)\n{\n    clst -= 2;       \n    if (clst >= fs->n_fatent - 2) return 0;      \n    return fs->database + fs->csize * clst;      \n}\n\n\n\n\n \n \n \n\nstatic DWORD get_fat (       \n    FFOBJID* obj,    \n    DWORD clst       \n)\n{\n    UINT wc, bc;\n    DWORD val;\n    FATFS *fs = obj->fs;\n\n\n    if (clst < 2 || clst >= fs->n_fatent) {  \n        val = 1;     \n\n    } else {\n        val = 0xFFFFFFFF;    \n\n        switch (fs->fs_type) {\n        case FS_FAT12 :\n            bc = (UINT)clst; bc += bc / 2;\n            if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;\n            wc = fs->win[bc++ % SS(fs)];         \n            if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;\n            wc |= fs->win[bc % SS(fs)] << 8;     \n            val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);     \n            break;\n\n        case FS_FAT16 :\n            if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;\n            val = ld_word(fs->win + clst * 2 % SS(fs));      \n            break;\n\n        case FS_FAT32 :\n            if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;\n            val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;    \n            break;\n#if FF_FS_EXFAT\n        case FS_EXFAT :\n            if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {     \n                DWORD cofs = clst - obj->sclust;     \n                DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;   \n\n                if (obj->stat == 2 && cofs <= clen) {    \n                    val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;    \n                    break;\n                }\n                if (obj->stat == 3 && cofs < obj->n_cont) {  \n                    val = clst + 1;      \n                    break;\n                }\n                if (obj->stat != 2) {    \n                    if (obj->n_frag != 0) {  \n                        val = 0x7FFFFFFF;    \n                    } else {\n                        if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;\n                        val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;\n                    }\n                    break;\n                }\n            }\n             \n#endif\n        default:\n            val = 1;     \n        }\n    }\n\n    return val;\n}\n\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic FRESULT put_fat (     \n    FATFS* fs,       \n    DWORD clst,      \n    DWORD val        \n)\n{\n    UINT bc;\n    BYTE *p;\n    FRESULT res = FR_INT_ERR;\n\n\n    if (clst >= 2 && clst < fs->n_fatent) {  \n        switch (fs->fs_type) {\n        case FS_FAT12 :\n            bc = (UINT)clst; bc += bc / 2;   \n            res = move_window(fs, fs->fatbase + (bc / SS(fs)));\n            if (res != FR_OK) break;\n            p = fs->win + bc++ % SS(fs);\n            *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;      \n            fs->wflag = 1;\n            res = move_window(fs, fs->fatbase + (bc / SS(fs)));\n            if (res != FR_OK) break;\n            p = fs->win + bc % SS(fs);\n            *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));  \n            fs->wflag = 1;\n            break;\n\n        case FS_FAT16 :\n            res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));\n            if (res != FR_OK) break;\n            st_word(fs->win + clst * 2 % SS(fs), (WORD)val);     \n            fs->wflag = 1;\n            break;\n\n        case FS_FAT32 :\n#if FF_FS_EXFAT\n        case FS_EXFAT :\n#endif\n            res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));\n            if (res != FR_OK) break;\n            if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {\n                val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);\n            }\n            st_dword(fs->win + clst * 4 % SS(fs), val);\n            fs->wflag = 1;\n            break;\n        }\n    }\n    return res;\n}\n\n#endif  \n\n\n\n\n#if FF_FS_EXFAT && !FF_FS_READONLY\n \n \n \n\n \n \n \n\nstatic DWORD find_bitmap (   \n    FATFS* fs,   \n    DWORD clst,  \n    DWORD ncl    \n)\n{\n    BYTE bm, bv;\n    UINT i;\n    DWORD val, scl, ctr;\n\n\n    clst -= 2;   \n    if (clst >= fs->n_fatent - 2) clst = 0;\n    scl = val = clst; ctr = 0;\n    for (;;) {\n        if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;\n        i = val / 8 % SS(fs); bm = 1 << (val % 8);\n        do {\n            do {\n                bv = fs->win[i] & bm; bm <<= 1;      \n                if (++val >= fs->n_fatent - 2) {     \n                    val = 0; bm = 0; i = SS(fs);\n                }\n                if (bv == 0) {   \n                    if (++ctr == ncl) return scl + 2;    \n                } else {\n                    scl = val; ctr = 0;      \n                }\n                if (val == clst) return 0;   \n            } while (bm != 0);\n            bm = 1;\n        } while (++i < SS(fs));\n    }\n}\n\n\n \n \n \n\nstatic FRESULT change_bitmap (\n    FATFS* fs,   \n    DWORD clst,  \n    DWORD ncl,   \n    int bv       \n)\n{\n    BYTE bm;\n    UINT i;\n    DWORD sect;\n\n\n    clst -= 2;   \n    sect = fs->bitbase + clst / 8 / SS(fs);  \n    i = clst / 8 % SS(fs);                   \n    bm = 1 << (clst % 8);                    \n    for (;;) {\n        if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;\n        do {\n            do {\n                if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;  \n                fs->win[i] ^= bm;    \n                fs->wflag = 1;\n                if (--ncl == 0) return FR_OK;    \n            } while (bm <<= 1);      \n            bm = 1;\n        } while (++i < SS(fs));      \n        i = 0;\n    }\n}\n\n\n \n \n \n\nstatic FRESULT fill_first_frag (\n    FFOBJID* obj     \n)\n{\n    FRESULT res;\n    DWORD cl, n;\n\n\n    if (obj->stat == 3) {    \n        for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {  \n            res = put_fat(obj->fs, cl, cl + 1);\n            if (res != FR_OK) return res;\n        }\n        obj->stat = 0;   \n    }\n    return FR_OK;\n}\n\n\n \n \n \n\nstatic FRESULT fill_last_frag (\n    FFOBJID* obj,    \n    DWORD lcl,       \n    DWORD term       \n)\n{\n    FRESULT res;\n\n\n    while (obj->n_frag > 0) {    \n        res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);\n        if (res != FR_OK) return res;\n        obj->n_frag--;\n    }\n    return FR_OK;\n}\n\n#endif   \n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic FRESULT remove_chain (    \n    FFOBJID* obj,        \n    DWORD clst,          \n    DWORD pclst          \n)\n{\n    FRESULT res = FR_OK;\n    DWORD nxt;\n    FATFS *fs = obj->fs;\n#if FF_FS_EXFAT || FF_USE_TRIM\n    DWORD scl = clst, ecl = clst;\n#endif\n#if FF_USE_TRIM\n    DWORD rt[2];\n#endif\n\n    if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;     \n\n     \n    if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {\n        res = put_fat(fs, pclst, 0xFFFFFFFF);\n        if (res != FR_OK) return res;\n    }\n\n     \n    do {\n        nxt = get_fat(obj, clst);            \n        if (nxt == 0) break;                 \n        if (nxt == 1) return FR_INT_ERR;     \n        if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;   \n        if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {\n            res = put_fat(fs, clst, 0);      \n            if (res != FR_OK) return res;\n        }\n        if (fs->free_clst < fs->n_fatent - 2) {  \n            fs->free_clst++;\n            fs->fsi_flag |= 1;\n        }\n#if FF_FS_EXFAT || FF_USE_TRIM\n        if (ecl + 1 == nxt) {    \n            ecl = nxt;\n        } else {                 \n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {\n                res = change_bitmap(fs, scl, ecl - scl + 1, 0);  \n                if (res != FR_OK) return res;\n            }\n#endif\n#if FF_USE_TRIM\n            rt[0] = clst2sect(fs, scl);                  \n            rt[1] = clst2sect(fs, ecl) + fs->csize - 1;  \n            disk_ioctl(fs->drv, CTRL_TRIM, rt);          \n#endif\n            scl = ecl = nxt;\n        }\n#endif\n        clst = nxt;                  \n    } while (clst < fs->n_fatent);   \n\n#if FF_FS_EXFAT\n     \n    if (fs->fs_type == FS_EXFAT) {\n        if (pclst == 0) {    \n            obj->stat = 0;       \n        } else {\n            if (obj->stat == 0) {    \n                clst = obj->sclust;      \n                while (clst != pclst) {\n                    nxt = get_fat(obj, clst);\n                    if (nxt < 2) return FR_INT_ERR;\n                    if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;\n                    if (nxt != clst + 1) break;  \n                    clst++;\n                }\n                if (clst == pclst) {     \n                    obj->stat = 2;       \n                }\n            } else {\n                if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {  \n                    obj->stat = 2;   \n                }\n            }\n        }\n    }\n#endif\n    return FR_OK;\n}\n\n\n\n\n \n \n \n\nstatic DWORD create_chain (  \n    FFOBJID* obj,        \n    DWORD clst           \n)\n{\n    DWORD cs, ncl, scl;\n    FRESULT res;\n    FATFS *fs = obj->fs;\n\n\n    if (clst == 0) {     \n        scl = fs->last_clst;                 \n        if (scl == 0 || scl >= fs->n_fatent) scl = 1;\n    }\n    else {               \n        cs = get_fat(obj, clst);             \n        if (cs < 2) return 1;                \n        if (cs == 0xFFFFFFFF) return cs;     \n        if (cs < fs->n_fatent) return cs;    \n        scl = clst;                          \n    }\n    if (fs->free_clst == 0) return 0;        \n\n#if FF_FS_EXFAT\n    if (fs->fs_type == FS_EXFAT) {   \n        ncl = find_bitmap(fs, scl, 1);               \n        if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;   \n        res = change_bitmap(fs, ncl, 1, 1);          \n        if (res == FR_INT_ERR) return 1;\n        if (res == FR_DISK_ERR) return 0xFFFFFFFF;\n        if (clst == 0) {                             \n            obj->stat = 2;                           \n        } else {                                     \n            if (obj->stat == 2 && ncl != scl + 1) {  \n                obj->n_cont = scl - obj->sclust;     \n                obj->stat = 3;                       \n            }\n        }\n        if (obj->stat != 2) {    \n            if (ncl == clst + 1) {   \n                obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;     \n            } else {                 \n                if (obj->n_frag == 0) obj->n_frag = 1;\n                res = fill_last_frag(obj, clst, ncl);    \n                if (res == FR_OK) obj->n_frag = 1;\n            }\n        }\n    } else\n#endif\n    {    \n        ncl = 0;\n        if (scl == clst) {                       \n            ncl = scl + 1;                       \n            if (ncl >= fs->n_fatent) ncl = 2;\n            cs = get_fat(obj, ncl);              \n            if (cs == 1 || cs == 0xFFFFFFFF) return cs;  \n            if (cs != 0) {                       \n                cs = fs->last_clst;              \n                if (cs >= 2 && cs < fs->n_fatent) scl = cs;\n                ncl = 0;\n            }\n        }\n        if (ncl == 0) {  \n            ncl = scl;   \n            for (;;) {\n                ncl++;                           \n                if (ncl >= fs->n_fatent) {       \n                    ncl = 2;\n                    if (ncl > scl) return 0;     \n                }\n                cs = get_fat(obj, ncl);          \n                if (cs == 0) break;              \n                if (cs == 1 || cs == 0xFFFFFFFF) return cs;  \n                if (ncl == scl) return 0;        \n            }\n        }\n        res = put_fat(fs, ncl, 0xFFFFFFFF);      \n        if (res == FR_OK && clst != 0) {\n            res = put_fat(fs, clst, ncl);        \n        }\n    }\n\n    if (res == FR_OK) {          \n        fs->last_clst = ncl;\n        if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;\n        fs->fsi_flag |= 1;\n    } else {\n        ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;     \n    }\n\n    return ncl;      \n}\n\n#endif  \n\n\n\n\n#if FF_USE_FASTSEEK\n \n \n \n\nstatic DWORD clmt_clust (    \n    FIL* fp,         \n    FSIZE_t ofs      \n)\n{\n    DWORD cl, ncl, *tbl;\n    FATFS *fs = fp->obj.fs;\n\n\n    tbl = fp->cltbl + 1;     \n    cl = (DWORD)(ofs / SS(fs) / fs->csize);  \n    for (;;) {\n        ncl = *tbl++;            \n        if (ncl == 0) return 0;  \n        if (cl < ncl) break;     \n        cl -= ncl; tbl++;        \n    }\n    return cl + *tbl;    \n}\n\n#endif   \n\n\n\n\n \n \n \n\n#if !FF_FS_READONLY\nstatic FRESULT dir_clear (   \n    FATFS *fs,       \n    DWORD clst       \n)\n{\n    DWORD sect;\n    UINT n, szb;\n    BYTE *ibuf;\n\n\n    if (sync_window(fs) != FR_OK) return FR_DISK_ERR;    \n    sect = clst2sect(fs, clst);      \n    fs->winsect = sect;              \n    mem_set(fs->win, 0, sizeof fs->win);     \n#if FF_USE_LFN == 3      \n     \n    for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;\n    if (szb > SS(fs)) {      \n        mem_set(ibuf, 0, szb);\n        szb /= SS(fs);       \n        for (n = 0; n < fs->csize && disk_write(fs->drv, ibuf, sect + n, szb) == RES_OK; n += szb) ;    \n        ff_memfree(ibuf);\n    } else\n#endif\n    {\n        ibuf = fs->win; szb = 1;     \n        for (n = 0; n < fs->csize && disk_write(fs->drv, ibuf, sect + n, szb) == RES_OK; n += szb) ;    \n    }\n    return (n == fs->csize) ? FR_OK : FR_DISK_ERR;\n}\n#endif   \n\n\n\n\n \n \n \n\nstatic FRESULT dir_sdi (     \n    DIR* dp,         \n    DWORD ofs        \n)\n{\n    DWORD csz, clst;\n    FATFS *fs = dp->obj.fs;\n\n\n    if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {   \n        return FR_INT_ERR;\n    }\n    dp->dptr = ofs;              \n    clst = dp->obj.sclust;       \n    if (clst == 0 && fs->fs_type >= FS_FAT32) {  \n        clst = fs->dirbase;\n        if (FF_FS_EXFAT) dp->obj.stat = 0;   \n    }\n\n    if (clst == 0) {     \n        if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;    \n        dp->sect = fs->dirbase;\n\n    } else {             \n        csz = (DWORD)fs->csize * SS(fs);     \n        while (ofs >= csz) {                 \n            clst = get_fat(&dp->obj, clst);              \n            if (clst == 0xFFFFFFFF) return FR_DISK_ERR;  \n            if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;     \n            ofs -= csz;\n        }\n        dp->sect = clst2sect(fs, clst);\n    }\n    dp->clust = clst;                    \n    if (dp->sect == 0) return FR_INT_ERR;\n    dp->sect += ofs / SS(fs);            \n    dp->dir = fs->win + (ofs % SS(fs));  \n\n    return FR_OK;\n}\n\n\n\n\n \n \n \n\nstatic FRESULT dir_next (    \n    DIR* dp,                 \n    int stretch              \n)\n{\n    DWORD ofs, clst;\n    FATFS *fs = dp->obj.fs;\n\n\n    ofs = dp->dptr + SZDIRE;     \n    if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;   \n    if (dp->sect == 0) return FR_NO_FILE;    \n\n    if (ofs % SS(fs) == 0) {     \n        dp->sect++;              \n\n        if (dp->clust == 0) {    \n            if (ofs / SZDIRE >= fs->n_rootdir) {     \n                dp->sect = 0; return FR_NO_FILE;\n            }\n        }\n        else {                   \n            if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {     \n                clst = get_fat(&dp->obj, dp->clust);         \n                if (clst <= 1) return FR_INT_ERR;            \n                if (clst == 0xFFFFFFFF) return FR_DISK_ERR;  \n                if (clst >= fs->n_fatent) {                  \n#if !FF_FS_READONLY\n                    if (!stretch) {                              \n                        dp->sect = 0; return FR_NO_FILE;\n                    }\n                    clst = create_chain(&dp->obj, dp->clust);    \n                    if (clst == 0) return FR_DENIED;             \n                    if (clst == 1) return FR_INT_ERR;            \n                    if (clst == 0xFFFFFFFF) return FR_DISK_ERR;  \n                    if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;    \n                    if (FF_FS_EXFAT) dp->obj.stat |= 4;          \n#else\n                    if (!stretch) dp->sect = 0;                  \n                    dp->sect = 0; return FR_NO_FILE;             \n#endif\n                }\n                dp->clust = clst;        \n                dp->sect = clst2sect(fs, clst);\n            }\n        }\n    }\n    dp->dptr = ofs;                      \n    dp->dir = fs->win + ofs % SS(fs);    \n\n    return FR_OK;\n}\n\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic FRESULT dir_alloc (   \n    DIR* dp,                 \n    UINT nent                \n)\n{\n    FRESULT res;\n    UINT n;\n    FATFS *fs = dp->obj.fs;\n\n\n    res = dir_sdi(dp, 0);\n    if (res == FR_OK) {\n        n = 0;\n        do {\n            res = move_window(fs, dp->sect);\n            if (res != FR_OK) break;\n#if FF_FS_EXFAT\n            if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {\n#else\n            if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {\n#endif\n                if (++n == nent) break;  \n            } else {\n                n = 0;                   \n            }\n            res = dir_next(dp, 1);\n        } while (res == FR_OK);  \n    }\n\n    if (res == FR_NO_FILE) res = FR_DENIED;  \n    return res;\n}\n\n#endif   \n\n\n\n\n \n \n \n\nstatic DWORD ld_clust (  \n    FATFS* fs,           \n    const BYTE* dir      \n)\n{\n    DWORD cl;\n\n    cl = ld_word(dir + DIR_FstClusLO);\n    if (fs->fs_type == FS_FAT32) {\n        cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;\n    }\n\n    return cl;\n}\n\n\n#if !FF_FS_READONLY\nstatic void st_clust (\n    FATFS* fs,   \n    BYTE* dir,   \n    DWORD cl     \n)\n{\n    st_word(dir + DIR_FstClusLO, (WORD)cl);\n    if (fs->fs_type == FS_FAT32) {\n        st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));\n    }\n}\n#endif\n\n\n\n#if FF_USE_LFN\n \n \n \n\nstatic int cmp_lfn (         \n    const WCHAR* lfnbuf,     \n    BYTE* dir                \n)\n{\n    UINT i, s;\n    WCHAR wc, uc;\n\n\n    if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;    \n\n    i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;   \n\n    for (wc = 1, s = 0; s < 13; s++) {       \n        uc = ld_word(dir + LfnOfs[s]);       \n        if (wc != 0) {\n            if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {  \n                return 0;                    \n            }\n            wc = uc;\n        } else {\n            if (uc != 0xFFFF) return 0;      \n        }\n    }\n\n    if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;     \n\n    return 1;        \n}\n\n\n#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT\n \n \n \n\nstatic int pick_lfn (    \n    WCHAR* lfnbuf,       \n    BYTE* dir            \n)\n{\n    UINT i, s;\n    WCHAR wc, uc;\n\n\n    if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;    \n\n    i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;  \n\n    for (wc = 1, s = 0; s < 13; s++) {       \n        uc = ld_word(dir + LfnOfs[s]);       \n        if (wc != 0) {\n            if (i >= FF_MAX_LFN + 1) return 0;  \n            lfnbuf[i++] = wc = uc;           \n        } else {\n            if (uc != 0xFFFF) return 0;      \n        }\n    }\n\n    if (dir[LDIR_Ord] & LLEF && wc != 0) {   \n        if (i >= FF_MAX_LFN + 1) return 0;   \n        lfnbuf[i] = 0;\n    }\n\n    return 1;        \n}\n#endif\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic void put_lfn (\n    const WCHAR* lfn,    \n    BYTE* dir,           \n    BYTE ord,            \n    BYTE sum             \n)\n{\n    UINT i, s;\n    WCHAR wc;\n\n\n    dir[LDIR_Chksum] = sum;          \n    dir[LDIR_Attr] = AM_LFN;         \n    dir[LDIR_Type] = 0;\n    st_word(dir + LDIR_FstClusLO, 0);\n\n    i = (ord - 1) * 13;              \n    s = wc = 0;\n    do {\n        if (wc != 0xFFFF) wc = lfn[i++];     \n        st_word(dir + LfnOfs[s], wc);        \n        if (wc == 0) wc = 0xFFFF;        \n    } while (++s < 13);\n    if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;    \n    dir[LDIR_Ord] = ord;             \n}\n\n#endif   \n#endif   \n\n\n\n#if FF_USE_LFN && !FF_FS_READONLY\n \n \n \n\nstatic void gen_numname (\n    BYTE* dst,           \n    const BYTE* src,     \n    const WCHAR* lfn,    \n    UINT seq             \n)\n{\n    BYTE ns[8], c;\n    UINT i, j;\n    WCHAR wc;\n    DWORD sr;\n\n\n    mem_cpy(dst, src, 11);\n\n    if (seq > 5) {   \n        sr = seq;\n        while (*lfn) {   \n            wc = *lfn++;\n            for (i = 0; i < 16; i++) {\n                sr = (sr << 1) + (wc & 1);\n                wc >>= 1;\n                if (sr & 0x10000) sr ^= 0x11021;\n            }\n        }\n        seq = (UINT)sr;\n    }\n\n     \n    i = 7;\n    do {\n        c = (BYTE)((seq % 16) + '0');\n        if (c > '9') c += 7;\n        ns[i--] = c;\n        seq /= 16;\n    } while (seq);\n    ns[i] = '~';\n\n     \n    for (j = 0; j < i && dst[j] != ' '; j++) {\n        if (dbc_1st(dst[j])) {\n            if (j == i - 1) break;\n            j++;\n        }\n    }\n    do {\n        dst[j++] = (i < 8) ? ns[i++] : ' ';\n    } while (j < 8);\n}\n#endif   \n\n\n\n#if FF_USE_LFN\n \n \n \n\nstatic BYTE sum_sfn (\n    const BYTE* dir      \n)\n{\n    BYTE sum = 0;\n    UINT n = 11;\n\n    do {\n        sum = (sum >> 1) + (sum << 7) + *dir++;\n    } while (--n);\n    return sum;\n}\n\n#endif   \n\n\n\n#if FF_FS_EXFAT\n \n \n \n\nstatic WORD xdir_sum (   \n    const BYTE* dir      \n)\n{\n    UINT i, szblk;\n    WORD sum;\n\n\n    szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;     \n    for (i = sum = 0; i < szblk; i++) {\n        if (i == XDIR_SetSum) {  \n            i++;\n        } else {\n            sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];\n        }\n    }\n    return sum;\n}\n\n\n\nstatic WORD xname_sum (  \n    const WCHAR* name    \n)\n{\n    WCHAR chr;\n    WORD sum = 0;\n\n\n    while ((chr = *name++) != 0) {\n        chr = (WCHAR)ff_wtoupper(chr);       \n        sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);\n        sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);\n    }\n    return sum;\n}\n\n\n#if !FF_FS_READONLY && FF_USE_MKFS\nstatic DWORD xsum32 (    \n    BYTE  dat,           \n    DWORD sum            \n)\n{\n    sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;\n    return sum;\n}\n#endif\n\n\n#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2\n \n \n \n\nstatic void get_xfileinfo (\n    BYTE* dirb,          \n    FILINFO* fno         \n)\n{\n    WCHAR wc, hs;\n    UINT di, si, nc;\n\n     \n    si = SZDIRE * 2;     \n    nc = 0; hs = 0; di = 0;\n    while (nc < dirb[XDIR_NumName]) {\n        if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }    \n        if ((si % SZDIRE) == 0) si += 2;         \n        wc = ld_word(dirb + si); si += 2; nc++;  \n        if (hs == 0 && IsSurrogate(wc)) {    \n            hs = wc; continue;   \n        }\n        wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);    \n        if (wc == 0) { di = 0; break; }  \n        di += wc;\n        hs = 0;\n    }\n    if (hs != 0) di = 0;                     \n    if (di == 0) fno->fname[di++] = '?';     \n    fno->fname[di] = 0;                      \n    fno->altname[0] = 0;                     \n\n    fno->fattrib = dirb[XDIR_Attr];          \n    fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);   \n    fno->ftime = ld_word(dirb + XDIR_ModTime + 0);   \n    fno->fdate = ld_word(dirb + XDIR_ModTime + 2);   \n}\n\n#endif   \n\n\n \n \n \n\nstatic FRESULT load_xdir (   \n    DIR* dp                  \n)\n{\n    FRESULT res;\n    UINT i, sz_ent;\n    BYTE* dirb = dp->obj.fs->dirbuf;     \n\n\n     \n    res = move_window(dp->obj.fs, dp->sect);\n    if (res != FR_OK) return res;\n    if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_INT_ERR;     \n    mem_cpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);\n    sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;\n    if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;\n\n     \n    res = dir_next(dp, 0);\n    if (res == FR_NO_FILE) res = FR_INT_ERR;     \n    if (res != FR_OK) return res;\n    res = move_window(dp->obj.fs, dp->sect);\n    if (res != FR_OK) return res;\n    if (dp->dir[XDIR_Type] != ET_STREAM) return FR_INT_ERR;  \n    mem_cpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);\n    if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;\n\n     \n    i = 2 * SZDIRE;  \n    do {\n        res = dir_next(dp, 0);\n        if (res == FR_NO_FILE) res = FR_INT_ERR;     \n        if (res != FR_OK) return res;\n        res = move_window(dp->obj.fs, dp->sect);\n        if (res != FR_OK) return res;\n        if (dp->dir[XDIR_Type] != ET_FILENAME) return FR_INT_ERR;    \n        if (i < MAXDIRB(FF_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);\n    } while ((i += SZDIRE) < sz_ent);\n\n     \n    if (i <= MAXDIRB(FF_MAX_LFN)) {\n        if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;\n    }\n    return FR_OK;\n}\n\n\n \n \n \n\nstatic void init_alloc_info (\n    FATFS* fs,       \n    FFOBJID* obj     \n)\n{\n    obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);       \n    obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);     \n    obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;               \n    obj->n_frag = 0;                                         \n}\n\n\n\n#if !FF_FS_READONLY || FF_FS_RPATH != 0\n \n \n \n\nstatic FRESULT load_obj_xdir (\n    DIR* dp,             \n    const FFOBJID* obj   \n)\n{\n    FRESULT res;\n\n     \n    dp->obj.fs = obj->fs;\n    dp->obj.sclust = obj->c_scl;\n    dp->obj.stat = (BYTE)obj->c_size;\n    dp->obj.objsize = obj->c_size & 0xFFFFFF00;\n    dp->obj.n_frag = 0;\n    dp->blk_ofs = obj->c_ofs;\n\n    res = dir_sdi(dp, dp->blk_ofs);  \n    if (res == FR_OK) {\n        res = load_xdir(dp);         \n    }\n    return res;\n}\n#endif\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic FRESULT store_xdir (\n    DIR* dp              \n)\n{\n    FRESULT res;\n    UINT nent;\n    BYTE* dirb = dp->obj.fs->dirbuf;     \n\n     \n    st_word(dirb + XDIR_SetSum, xdir_sum(dirb));\n    nent = dirb[XDIR_NumSec] + 1;\n\n     \n    res = dir_sdi(dp, dp->blk_ofs);\n    while (res == FR_OK) {\n        res = move_window(dp->obj.fs, dp->sect);\n        if (res != FR_OK) break;\n        mem_cpy(dp->dir, dirb, SZDIRE);\n        dp->obj.fs->wflag = 1;\n        if (--nent == 0) break;\n        dirb += SZDIRE;\n        res = dir_next(dp, 0);\n    }\n    return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;\n}\n\n\n\n \n \n \n\nstatic void create_xdir (\n    BYTE* dirb,          \n    const WCHAR* lfn     \n)\n{\n    UINT i;\n    BYTE nc1, nlen;\n    WCHAR wc;\n\n\n     \n    mem_set(dirb, 0, 2 * SZDIRE);\n    dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;\n    dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;\n\n     \n    i = SZDIRE * 2;  \n    nlen = nc1 = 0; wc = 1;\n    do {\n        dirb[i++] = ET_FILENAME; dirb[i++] = 0;\n        do {     \n            if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;    \n            st_word(dirb + i, wc);       \n            i += 2;\n        } while (i % SZDIRE != 0);\n        nc1++;\n    } while (lfn[nlen]);     \n\n    dirb[XDIR_NumName] = nlen;       \n    dirb[XDIR_NumSec] = 1 + nc1;     \n    st_word(dirb + XDIR_NameHash, xname_sum(lfn));   \n}\n\n#endif   \n#endif   \n\n\n\n#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2 || FF_USE_LABEL || FF_FS_EXFAT\n \n \n \n\n#define DIR_READ_FILE(dp) dir_read(dp, 0)\n#define DIR_READ_LABEL(dp) dir_read(dp, 1)\n\nstatic FRESULT dir_read (\n    DIR* dp,         \n    int vol          \n)\n{\n    FRESULT res = FR_NO_FILE;\n    FATFS *fs = dp->obj.fs;\n    BYTE attr, b;\n#if FF_USE_LFN\n    BYTE ord = 0xFF, sum = 0xFF;\n#endif\n\n    while (dp->sect) {\n        res = move_window(fs, dp->sect);\n        if (res != FR_OK) break;\n        b = dp->dir[DIR_Name];   \n        if (b == 0) {\n            res = FR_NO_FILE; break;  \n        }\n#if FF_FS_EXFAT\n        if (fs->fs_type == FS_EXFAT) {   \n            if (FF_USE_LABEL && vol) {\n                if (b == ET_VLABEL) break;   \n            } else {\n                if (b == ET_FILEDIR) {       \n                    dp->blk_ofs = dp->dptr;  \n                    res = load_xdir(dp);     \n                    if (res == FR_OK) {\n                        dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;  \n                    }\n                    break;\n                }\n            }\n        } else\n#endif\n        {    \n            dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;   \n#if FF_USE_LFN       \n            if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {     \n                ord = 0xFF;\n            } else {\n                if (attr == AM_LFN) {            \n                    if (b & LLEF) {          \n                        sum = dp->dir[LDIR_Chksum];\n                        b &= (BYTE)~LLEF; ord = b;\n                        dp->blk_ofs = dp->dptr;\n                    }\n                     \n                    ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;\n                } else {                     \n                    if (ord != 0 || sum != sum_sfn(dp->dir)) {   \n                        dp->blk_ofs = 0xFFFFFFFF;            \n                    }\n                    break;\n                }\n            }\n#else        \n            if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {   \n                break;\n            }\n#endif\n        }\n        res = dir_next(dp, 0);       \n        if (res != FR_OK) break;\n    }\n\n    if (res != FR_OK) dp->sect = 0;      \n    return res;\n}\n\n#endif   \n\n\n\n \n \n \n\nstatic FRESULT dir_find (    \n    DIR* dp                  \n)\n{\n    FRESULT res;\n    FATFS *fs = dp->obj.fs;\n    BYTE c;\n#if FF_USE_LFN\n    BYTE a, ord, sum;\n#endif\n\n    res = dir_sdi(dp, 0);            \n    if (res != FR_OK) return res;\n#if FF_FS_EXFAT\n    if (fs->fs_type == FS_EXFAT) {   \n        BYTE nc;\n        UINT di, ni;\n        WORD hash = xname_sum(fs->lfnbuf);       \n\n        while ((res = DIR_READ_FILE(dp)) == FR_OK) {     \n#if FF_MAX_LFN < 255\n            if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;             \n#endif\n            if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;   \n            for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {  \n                if ((di % SZDIRE) == 0) di += 2;\n                if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;\n            }\n            if (nc == 0 && !fs->lfnbuf[ni]) break;   \n        }\n        return res;\n    }\n#endif\n     \n#if FF_USE_LFN\n    ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;  \n#endif\n    do {\n        res = move_window(fs, dp->sect);\n        if (res != FR_OK) break;\n        c = dp->dir[DIR_Name];\n        if (c == 0) { res = FR_NO_FILE; break; }     \n#if FF_USE_LFN       \n        dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;\n        if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {    \n            ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;    \n        } else {\n            if (a == AM_LFN) {           \n                if (!(dp->fn[NSFLAG] & NS_NOLFN)) {\n                    if (c & LLEF) {      \n                        sum = dp->dir[LDIR_Chksum];\n                        c &= (BYTE)~LLEF; ord = c;   \n                        dp->blk_ofs = dp->dptr;  \n                    }\n                     \n                    ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;\n                }\n            } else {                     \n                if (ord == 0 && sum == sum_sfn(dp->dir)) break;  \n                if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;     \n                ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;    \n            }\n        }\n#else        \n        dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;\n        if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;   \n#endif\n        res = dir_next(dp, 0);   \n    } while (res == FR_OK);\n\n    return res;\n}\n\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nstatic FRESULT dir_register (    \n    DIR* dp                      \n)\n{\n    FRESULT res;\n    FATFS *fs = dp->obj.fs;\n#if FF_USE_LFN       \n    UINT n, nlen, nent;\n    BYTE sn[12], sum;\n\n\n    if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;   \n    for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;   \n\n#if FF_FS_EXFAT\n    if (fs->fs_type == FS_EXFAT) {   \n        nent = (nlen + 14) / 15 + 2;     \n        res = dir_alloc(dp, nent);       \n        if (res != FR_OK) return res;\n        dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);    \n\n        if (dp->obj.stat & 4) {          \n            dp->obj.stat &= ~4;\n            res = fill_first_frag(&dp->obj);     \n            if (res != FR_OK) return res;\n            res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);   \n            if (res != FR_OK) return res;\n            if (dp->obj.sclust != 0) {       \n                DIR dj;\n\n                res = load_obj_xdir(&dj, &dp->obj);  \n                if (res != FR_OK) return res;\n                dp->obj.objsize += (DWORD)fs->csize * SS(fs);            \n                st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);   \n                st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);\n                fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;\n                res = store_xdir(&dj);               \n                if (res != FR_OK) return res;\n            }\n        }\n\n        create_xdir(fs->dirbuf, fs->lfnbuf);     \n        return FR_OK;\n    }\n#endif\n     \n    mem_cpy(sn, dp->fn, 12);\n    if (sn[NSFLAG] & NS_LOSS) {          \n        dp->fn[NSFLAG] = NS_NOLFN;       \n        for (n = 1; n < 100; n++) {\n            gen_numname(dp->fn, sn, fs->lfnbuf, n);  \n            res = dir_find(dp);              \n            if (res != FR_OK) break;\n        }\n        if (n == 100) return FR_DENIED;      \n        if (res != FR_NO_FILE) return res;   \n        dp->fn[NSFLAG] = sn[NSFLAG];\n    }\n\n     \n    nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;     \n    res = dir_alloc(dp, nent);       \n    if (res == FR_OK && --nent) {    \n        res = dir_sdi(dp, dp->dptr - nent * SZDIRE);\n        if (res == FR_OK) {\n            sum = sum_sfn(dp->fn);   \n            do {                     \n                res = move_window(fs, dp->sect);\n                if (res != FR_OK) break;\n                put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);\n                fs->wflag = 1;\n                res = dir_next(dp, 0);   \n            } while (res == FR_OK && --nent);\n        }\n    }\n\n#else    \n    res = dir_alloc(dp, 1);      \n\n#endif\n\n     \n    if (res == FR_OK) {\n        res = move_window(fs, dp->sect);\n        if (res == FR_OK) {\n            mem_set(dp->dir, 0, SZDIRE);     \n            mem_cpy(dp->dir + DIR_Name, dp->fn, 11);     \n#if FF_USE_LFN\n            dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);    \n#endif\n            fs->wflag = 1;\n        }\n    }\n\n    return res;\n}\n\n#endif  \n\n\n\n#if !FF_FS_READONLY && FF_FS_MINIMIZE == 0\n \n \n \n\nstatic FRESULT dir_remove (  \n    DIR* dp                  \n)\n{\n    FRESULT res;\n    FATFS *fs = dp->obj.fs;\n#if FF_USE_LFN       \n    DWORD last = dp->dptr;\n\n    res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);    \n    if (res == FR_OK) {\n        do {\n            res = move_window(fs, dp->sect);\n            if (res != FR_OK) break;\n            if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {    \n                dp->dir[XDIR_Type] &= 0x7F;  \n            } else {                                     \n                dp->dir[DIR_Name] = DDEM;    \n            }\n            fs->wflag = 1;\n            if (dp->dptr >= last) break;     \n            res = dir_next(dp, 0);   \n        } while (res == FR_OK);\n        if (res == FR_NO_FILE) res = FR_INT_ERR;\n    }\n#else            \n\n    res = move_window(fs, dp->sect);\n    if (res == FR_OK) {\n        dp->dir[DIR_Name] = DDEM;    \n        fs->wflag = 1;\n    }\n#endif\n\n    return res;\n}\n\n#endif  \n\n\n\n#if FF_FS_MINIMIZE <= 1 || FF_FS_RPATH >= 2\n \n \n \n\nstatic void get_fileinfo (\n    DIR* dp,             \n    FILINFO* fno         \n)\n{\n    UINT si, di;\n#if FF_USE_LFN\n    BYTE lcf;\n    WCHAR wc, hs;\n    FATFS *fs = dp->obj.fs;\n#else\n    TCHAR c;\n#endif\n\n\n    fno->fname[0] = 0;           \n    if (dp->sect == 0) return;   \n\n#if FF_USE_LFN       \n#if FF_FS_EXFAT\n    if (fs->fs_type == FS_EXFAT) {   \n        get_xfileinfo(fs->dirbuf, fno);\n        return;\n    } else\n#endif\n    {    \n        if (dp->blk_ofs != 0xFFFFFFFF) {     \n            si = di = hs = 0;\n            while (fs->lfnbuf[si] != 0) {\n                wc = fs->lfnbuf[si++];       \n                if (hs == 0 && IsSurrogate(wc)) {    \n                    hs = wc; continue;       \n                }\n                wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);    \n                if (wc == 0) { di = 0; break; }  \n                di += wc;\n                hs = 0;\n            }\n            if (hs != 0) di = 0;     \n            fno->fname[di] = 0;      \n        }\n    }\n\n    si = di = 0;\n    while (si < 11) {        \n        wc = dp->dir[si++];          \n        if (wc == ' ') continue;     \n        if (wc == RDDEM) wc = DDEM;  \n        if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';    \n#if FF_LFN_UNICODE >= 1  \n        if (dbc_1st((BYTE)wc) && si != 8 && si != 11 && dbc_2nd(dp->dir[si])) {  \n            wc = wc << 8 | dp->dir[si++];\n        }\n        wc = ff_oem2uni(wc, CODEPAGE);       \n        if (wc == 0) { di = 0; break; }      \n        wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);    \n        if (wc == 0) { di = 0; break; }      \n        di += wc;\n#else                    \n        fno->altname[di++] = (TCHAR)wc;  \n#endif\n    }\n    fno->altname[di] = 0;    \n\n    if (fno->fname[0] == 0) {    \n        if (di == 0) {   \n            fno->fname[di++] = '?';\n        } else {\n            for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {  \n                wc = (WCHAR)fno->altname[si];\n                if (wc == '.') lcf = NS_EXT;\n                if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;\n                fno->fname[di] = (TCHAR)wc;\n            }\n        }\n        fno->fname[di] = 0;  \n        if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;    \n    }\n\n#else    \n    si = di = 0;\n    while (si < 11) {        \n        c = (TCHAR)dp->dir[si++];\n        if (c == ' ') continue;      \n        if (c == RDDEM) c = DDEM;    \n        if (si == 9) fno->fname[di++] = '.'; \n        fno->fname[di++] = c;\n    }\n    fno->fname[di] = 0;\n#endif\n\n    fno->fattrib = dp->dir[DIR_Attr];                    \n    fno->fsize = ld_dword(dp->dir + DIR_FileSize);       \n    fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);     \n    fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);     \n}\n\n#endif  \n\n\n\n#if FF_USE_FIND && FF_FS_MINIMIZE <= 1\n \n \n \n\nstatic DWORD get_achar (     \n    const TCHAR** ptr        \n)\n{\n    DWORD chr;\n\n\n#if FF_USE_LFN && FF_LFN_UNICODE >= 1    \n    chr = tchar2uni(ptr);\n    if (chr == 0xFFFFFFFF) chr = 0;      \n    chr = ff_wtoupper(chr);\n\n#else                                    \n    chr = (BYTE)*(*ptr)++;               \n    if (IsLower(chr)) chr -= 0x20;       \n#if FF_CODE_PAGE == 0\n    if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];   \n#elif FF_CODE_PAGE < 900\n    if (chr >= 0x80) chr = ExCvt[chr - 0x80];    \n#endif\n#if FF_CODE_PAGE == 0 || FF_CODE_PAGE >= 900\n    if (dbc_1st((BYTE)chr)) {    \n        chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;\n    }\n#endif\n\n#endif\n    return chr;\n}\n\n\nstatic int pattern_matching (    \n    const TCHAR* pat,    \n    const TCHAR* nam,    \n    int skip,            \n    int inf              \n)\n{\n    const TCHAR *pp, *np;\n    DWORD pc, nc;\n    int nm, nx;\n\n\n    while (skip--) {                 \n        if (!get_achar(&nam)) return 0;  \n    }\n    if (*pat == 0 && inf) return 1;  \n\n    do {\n        pp = pat; np = nam;          \n        for (;;) {\n            if (*pp == '?' || *pp == '*') {  \n                nm = nx = 0;\n                do {                 \n                    if (*pp++ == '?') nm++; else nx = 1;\n                } while (*pp == '?' || *pp == '*');\n                if (pattern_matching(pp, np, nm, nx)) return 1;  \n                nc = *np; break;     \n            }\n            pc = get_achar(&pp);     \n            nc = get_achar(&np);     \n            if (pc != nc) break;     \n            if (pc == 0) return 1;   \n        }\n        get_achar(&nam);             \n    } while (inf && nc);             \n\n    return 0;\n}\n\n#endif  \n\n\n\n \n \n \n\nstatic FRESULT create_name (     \n    DIR* dp,                     \n    const TCHAR** path           \n)\n{\n#if FF_USE_LFN       \n    BYTE b, cf;\n    WCHAR wc, *lfn;\n    DWORD uc;\n    UINT i, ni, si, di;\n    const TCHAR *p;\n\n\n     \n    p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;\n    for (;;) {\n        uc = tchar2uni(&p);          \n        if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;        \n        if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);    \n        wc = (WCHAR)uc;\n        if (wc < ' ' || wc == '/' || wc == '\\\\') break;  \n        if (wc < 0x80 && chk_chr(\"\\\"*:<>\\?|\\x7F\", wc)) return FR_INVALID_NAME;   \n        if (di >= FF_MAX_LFN) return FR_INVALID_NAME;    \n        lfn[di++] = wc;                  \n    }\n    if (wc == '/' || wc == '\\\\') while (*p == '/' || *p == '\\\\') p++;     \n    *path = p;                           \n    cf = (wc < ' ') ? NS_LAST : 0;       \n\n#if FF_FS_RPATH != 0\n    if ((di == 1 && lfn[di - 1] == '.') ||\n        (di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {     \n        lfn[di] = 0;\n        for (i = 0; i < 11; i++) {       \n            dp->fn[i] = (i < di) ? '.' : ' ';\n        }\n        dp->fn[i] = cf | NS_DOT;         \n        return FR_OK;\n    }\n#endif\n    while (di) {                         \n        wc = lfn[di - 1];\n        if (wc != ' ' && wc != '.') break;\n        di--;\n    }\n    lfn[di] = 0;                             \n    if (di == 0) return FR_INVALID_NAME;     \n\n     \n    for (si = 0; lfn[si] == ' '; si++) ;     \n    if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;    \n    while (di > 0 && lfn[di - 1] != '.') di--;   \n\n    mem_set(dp->fn, ' ', 11);\n    i = b = 0; ni = 8;\n    for (;;) {\n        wc = lfn[si++];                  \n        if (wc == 0) break;              \n        if (wc == ' ' || (wc == '.' && si != di)) {  \n            cf |= NS_LOSS | NS_LFN;\n            continue;\n        }\n\n        if (i >= ni || si == di) {       \n            if (ni == 11) {              \n                cf |= NS_LOSS | NS_LFN;\n                break;\n            }\n            if (si != di) cf |= NS_LOSS | NS_LFN;    \n            if (si > di) break;                      \n            si = di; i = 8; ni = 11; b <<= 2;        \n            continue;\n        }\n\n        if (wc >= 0x80) {    \n            cf |= NS_LFN;    \n#if FF_CODE_PAGE == 0\n            if (ExCvt) {     \n                wc = ff_uni2oem(wc, CODEPAGE);           \n                if (wc & 0x80) wc = ExCvt[wc & 0x7F];    \n            } else {         \n                wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);  \n            }\n#elif FF_CODE_PAGE < 900     \n            wc = ff_uni2oem(wc, CODEPAGE);           \n            if (wc & 0x80) wc = ExCvt[wc & 0x7F];    \n#else                        \n            wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);  \n#endif\n        }\n\n        if (wc >= 0x100) {               \n            if (i >= ni - 1) {           \n                cf |= NS_LOSS | NS_LFN;\n                i = ni; continue;        \n            }\n            dp->fn[i++] = (BYTE)(wc >> 8);   \n        } else {                         \n            if (wc == 0 || chk_chr(\"+,;=[]\", wc)) {  \n                wc = '_'; cf |= NS_LOSS | NS_LFN; \n            } else {\n                if (IsUpper(wc)) {       \n                    b |= 2;\n                }\n                if (IsLower(wc)) {       \n                    b |= 1; wc -= 0x20;\n                }\n            }\n        }\n        dp->fn[i++] = (BYTE)wc;\n    }\n\n    if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;    \n\n    if (ni == 8) b <<= 2;                \n    if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;  \n    if (!(cf & NS_LFN)) {                \n        if (b & 0x01) cf |= NS_EXT;      \n        if (b & 0x04) cf |= NS_BODY;     \n    }\n\n    dp->fn[NSFLAG] = cf;     \n\n    return FR_OK;\n\n\n#else    \n    BYTE c, d, *sfn;\n    UINT ni, si, i;\n    const char *p;\n\n     \n    p = *path; sfn = dp->fn;\n    mem_set(sfn, ' ', 11);\n    si = i = 0; ni = 8;\n#if FF_FS_RPATH != 0\n    if (p[si] == '.') {  \n        for (;;) {\n            c = (BYTE)p[si++];\n            if (c != '.' || si >= 3) break;\n            sfn[i++] = c;\n        }\n        if (c != '/' && c != '\\\\' && c > ' ') return FR_INVALID_NAME;\n        *path = p + si;                              \n        sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;    \n        return FR_OK;\n    }\n#endif\n    for (;;) {\n        c = (BYTE)p[si++];               \n        if (c <= ' ') break;             \n        if (c == '/' || c == '\\\\') {     \n            while (p[si] == '/' || p[si] == '\\\\') si++;  \n            break;\n        }\n        if (c == '.' || i >= ni) {       \n            if (ni == 11 || c != '.') return FR_INVALID_NAME;    \n            i = 8; ni = 11;              \n            continue;\n        }\n#if FF_CODE_PAGE == 0\n        if (ExCvt && c >= 0x80) {        \n            c = ExCvt[c & 0x7F];         \n        }\n#elif FF_CODE_PAGE < 900\n        if (c >= 0x80) {                 \n            c = ExCvt[c & 0x7F];         \n        }\n#endif\n        if (dbc_1st(c)) {                \n            d = (BYTE)p[si++];           \n            if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;  \n            sfn[i++] = c;\n            sfn[i++] = d;\n        } else {                         \n            if (chk_chr(\"\\\"*+,:;<=>\\?[]|\\x7F\", c)) return FR_INVALID_NAME;   \n            if (IsLower(c)) c -= 0x20;   \n            sfn[i++] = c;\n        }\n    }\n    *path = p + si;                      \n    if (i == 0) return FR_INVALID_NAME;  \n\n    if (sfn[0] == DDEM) sfn[0] = RDDEM;  \n    sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;      \n\n    return FR_OK;\n#endif  \n}\n\n\n\n\n \n \n \n\nstatic FRESULT follow_path (     \n    DIR* dp,                     \n    const TCHAR* path            \n)\n{\n    FRESULT res;\n    BYTE ns;\n    FATFS *fs = dp->obj.fs;\n\n\n#if FF_FS_RPATH != 0\n    if (*path != '/' && *path != '\\\\') {     \n        dp->obj.sclust = fs->cdir;               \n    } else\n#endif\n    {                                        \n        while (*path == '/' || *path == '\\\\') path++;    \n        dp->obj.sclust = 0;                  \n    }\n#if FF_FS_EXFAT\n    dp->obj.n_frag = 0;  \n#if FF_FS_RPATH != 0\n    if (fs->fs_type == FS_EXFAT && dp->obj.sclust) {     \n        DIR dj;\n\n        dp->obj.c_scl = fs->cdc_scl;\n        dp->obj.c_size = fs->cdc_size;\n        dp->obj.c_ofs = fs->cdc_ofs;\n        res = load_obj_xdir(&dj, &dp->obj);\n        if (res != FR_OK) return res;\n        dp->obj.objsize = ld_dword(fs->dirbuf + XDIR_FileSize);\n        dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;\n    }\n#endif\n#endif\n\n    if ((UINT)*path < ' ') {                 \n        dp->fn[NSFLAG] = NS_NONAME;\n        res = dir_sdi(dp, 0);\n\n    } else {                                 \n        for (;;) {\n            res = create_name(dp, &path);    \n            if (res != FR_OK) break;\n            res = dir_find(dp);              \n            ns = dp->fn[NSFLAG];\n            if (res != FR_OK) {              \n                if (res == FR_NO_FILE) {     \n                    if (FF_FS_RPATH && (ns & NS_DOT)) {  \n                        if (!(ns & NS_LAST)) continue;   \n                        dp->fn[NSFLAG] = NS_NONAME;\n                        res = FR_OK;\n                    } else {                             \n                        if (!(ns & NS_LAST)) res = FR_NO_PATH;   \n                    }\n                }\n                break;\n            }\n            if (ns & NS_LAST) break;             \n             \n            if (!(dp->obj.attr & AM_DIR)) {      \n                res = FR_NO_PATH; break;\n            }\n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {       \n                dp->obj.c_scl = dp->obj.sclust;\n                dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;\n                dp->obj.c_ofs = dp->blk_ofs;\n                init_alloc_info(fs, &dp->obj);   \n            } else\n#endif\n            {\n                dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));  \n            }\n        }\n    }\n\n    return res;\n}\n\n\n\n\n \n \n \n\nstatic BYTE check_fs (   \n    FATFS* fs,           \n    DWORD sect           \n)\n{\n    fs->wflag = 0; fs->winsect = 0xFFFFFFFF;         \n    if (move_window(fs, sect) != FR_OK) return 4;    \n\n    if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;  \n\n#if FF_FS_EXFAT\n    if (!mem_cmp(fs->win + BS_JmpBoot, \"\\xEB\\x76\\x90\" \"EXFAT   \", 11)) return 1;     \n#endif\n    if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {     \n        if (!mem_cmp(fs->win + BS_FilSysType, \"FAT\", 3)) return 0;       \n        if (!mem_cmp(fs->win + BS_FilSysType32, \"FAT32\", 5)) return 0;   \n    }\n    return 2;    \n}\n\n\n\n\n \n \n \n\nstatic FRESULT find_volume (     \n    FATFS *fs,                   \n    BYTE mode                    \n)\n{\n    BYTE fmt, *pt;\n    DSTATUS stat;\n    DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];\n    WORD nrsv;\n    UINT i;\n\n\n#if FF_FS_REENTRANT\n    if (!lock_fs(fs)) return FR_TIMEOUT;     \n#endif\n\n    mode &= (BYTE)~FA_READ;              \n    if (fs->fs_type != 0) {              \n        disk_ioctl(fs->drv, IOCTL_STATUS, &stat);\n        if (!(stat & STA_NOINIT)) {      \n            if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {   \n                return FR_WRITE_PROTECTED;\n            }\n            return FR_OK;                \n        }\n    }\n\n     \n     \n\n    fs->fs_type = 0;                     \n    disk_ioctl(fs->drv, IOCTL_INIT, &stat);  \n    if (stat & STA_NOINIT) {             \n        return FR_NOT_READY;             \n    }\n    if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {  \n        return FR_WRITE_PROTECTED;\n    }\n#if FF_MAX_SS != FF_MIN_SS               \n    if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;\n    if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;\n#endif\n\n     \n    bsect = 0;\n    fmt = check_fs(fs, bsect);           \n    if (fmt == 2 || (fmt < 2 && LD2PT(fs) != 0)) {  \n        for (i = 0; i < 4; i++) {        \n            pt = fs->win + (MBR_Table + i * SZ_PTE);\n            br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;\n        }\n        i = LD2PT(fs);                   \n        if (i != 0) i--;\n        do {                             \n            bsect = br[i];\n            fmt = bsect ? check_fs(fs, bsect) : 3;   \n        } while (LD2PT(fs) == 0 && fmt >= 2 && ++i < 4);\n    }\n    if (fmt == 4) return FR_DISK_ERR;        \n    if (fmt >= 2) return FR_NO_FILESYSTEM;   \n\n     \n\n#if FF_FS_EXFAT\n    if (fmt == 1) {\n        QWORD maxlba;\n        DWORD so, cv, bcl;\n\n        for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;  \n        if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;\n\n        if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;    \n\n        if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {  \n            return FR_NO_FILESYSTEM;\n        }\n\n        maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;   \n        if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;  \n\n        fs->fsize = ld_dword(fs->win + BPB_FatSzEx);     \n\n        fs->n_fats = fs->win[BPB_NumFATsEx];             \n        if (fs->n_fats != 1) return FR_NO_FILESYSTEM;    \n\n        fs->csize = 1 << fs->win[BPB_SecPerClusEx];      \n        if (fs->csize == 0) return FR_NO_FILESYSTEM;     \n\n        nclst = ld_dword(fs->win + BPB_NumClusEx);       \n        if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;  \n        fs->n_fatent = nclst + 2;\n\n         \n        fs->volbase = bsect;\n        fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);\n        fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);\n        if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;   \n        fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);\n\n         \n        so = i = 0;\n        for (;;) {   \n            if (i == 0) {\n                if (so >= fs->csize) return FR_NO_FILESYSTEM;    \n                if (move_window(fs, clst2sect(fs, fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;\n                so++;\n            }\n            if (fs->win[i] == ET_BITMAP) break;              \n            i = (i + SZDIRE) % SS(fs);   \n        }\n        bcl = ld_dword(fs->win + i + 20);                    \n        if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;\n        fs->bitbase = fs->database + fs->csize * (bcl - 2);  \n        for (;;) {   \n            if (move_window(fs, fs->fatbase + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;\n            cv = ld_dword(fs->win + bcl % (SS(fs) / 4) * 4);\n            if (cv == 0xFFFFFFFF) break;                 \n            if (cv != ++bcl) return FR_NO_FILESYSTEM;    \n        }\n\n#if !FF_FS_READONLY\n        fs->last_clst = fs->free_clst = 0xFFFFFFFF;      \n#endif\n        fmt = FS_EXFAT;          \n    } else\n#endif   \n    {\n        if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;    \n\n        fasize = ld_word(fs->win + BPB_FATSz16);         \n        if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);\n        fs->fsize = fasize;\n\n        fs->n_fats = fs->win[BPB_NumFATs];               \n        if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;     \n        fasize *= fs->n_fats;                            \n\n        fs->csize = fs->win[BPB_SecPerClus];             \n        if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;    \n\n        fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);   \n        if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;  \n\n        tsect = ld_word(fs->win + BPB_TotSec16);         \n        if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);\n\n        nrsv = ld_word(fs->win + BPB_RsvdSecCnt);        \n        if (nrsv == 0) return FR_NO_FILESYSTEM;          \n\n         \n        sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);  \n        if (tsect < sysect) return FR_NO_FILESYSTEM;     \n        nclst = (tsect - sysect) / fs->csize;            \n        if (nclst == 0) return FR_NO_FILESYSTEM;         \n        fmt = 0;\n        if (nclst <= MAX_FAT32) fmt = FS_FAT32;\n        if (nclst <= MAX_FAT16) fmt = FS_FAT16;\n        if (nclst <= MAX_FAT12) fmt = FS_FAT12;\n        if (fmt == 0) return FR_NO_FILESYSTEM;\n\n         \n        fs->n_fatent = nclst + 2;                        \n        fs->volbase = bsect;                             \n        fs->fatbase = bsect + nrsv;                      \n        fs->database = bsect + sysect;                   \n        if (fmt == FS_FAT32) {\n            if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;    \n            if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;     \n            fs->dirbase = ld_dword(fs->win + BPB_RootClus32);    \n            szbfat = fs->n_fatent * 4;                   \n        } else {\n            if (fs->n_rootdir == 0) return FR_NO_FILESYSTEM;     \n            fs->dirbase = fs->fatbase + fasize;          \n            szbfat = (fmt == FS_FAT16) ?                 \n                fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);\n        }\n        if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;   \n\n#if !FF_FS_READONLY\n         \n        fs->last_clst = fs->free_clst = 0xFFFFFFFF;      \n        fs->fsi_flag = 0x80;\n#if (FF_FS_NOFSINFO & 3) != 3\n        if (fmt == FS_FAT32              \n            && ld_word(fs->win + BPB_FSInfo32) == 1\n            && move_window(fs, bsect + 1) == FR_OK)\n        {\n            fs->fsi_flag = 0;\n            if (ld_word(fs->win + BS_55AA) == 0xAA55     \n                && ld_dword(fs->win + FSI_LeadSig) == 0x41615252\n                && ld_dword(fs->win + FSI_StrucSig) == 0x61417272)\n            {\n#if (FF_FS_NOFSINFO & 1) == 0\n                fs->free_clst = ld_dword(fs->win + FSI_Free_Count);\n#endif\n#if (FF_FS_NOFSINFO & 2) == 0\n                fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);\n#endif\n            }\n        }\n#endif   \n#endif   \n    }\n\n    fs->fs_type = fmt;       \n    fs->id = ++Fsid;         \n#if FF_USE_LFN == 1\n    fs->lfnbuf = LfnBuf;     \n#if FF_FS_EXFAT\n    fs->dirbuf = DirBuf;     \n#endif\n#endif\n#if FF_FS_RPATH != 0\n    fs->cdir = 0;            \n#endif\n#if FF_FS_LOCK != 0          \n    clear_lock(fs);\n#endif\n    return FR_OK;\n}\n\n\n\n\n \n \n \n\nstatic FRESULT validate (    \n    FFOBJID* obj,            \n    FATFS** rfs              \n)\n{\n    FRESULT res = FR_INVALID_OBJECT;\n    DSTATUS stat;\n\n\n    if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {  \n#if FF_FS_REENTRANT\n        if (lock_fs(obj->fs)) {  \n            if (disk_ioctl(obj->fs->drv, IOCTL_STATUS, &stat) == RES_OK && !(stat & STA_NOINIT)) {  \n                res = FR_OK;\n            } else {\n                unlock_fs(obj->fs, FR_OK);\n            }\n        } else {\n            res = FR_TIMEOUT;\n        }\n#else\n        if (disk_ioctl(obj->fs->drv, IOCTL_STATUS, &stat) == RES_OK && !(stat & STA_NOINIT)) {  \n            res = FR_OK;\n        }\n#endif\n    }\n    *rfs = (res == FR_OK) ? obj->fs : 0;     \n    return res;\n}\n\n\n\n\n \n\n\n\n \n \n \n\nFRESULT f_mount (\n    FATFS* fs            \n)\n{\n    FRESULT res;\n\n    fs->fs_type = 0;                     \n#if FF_FS_REENTRANT                      \n    if (!ff_cre_syncobj(fs, &fs->sobj)) return FR_INT_ERR;\n#endif\n\n    res = find_volume(fs, 0);            \n    LEAVE_FF(fs, res);\n}\n\n\nFRESULT f_umount (\n    FATFS* fs                    \n)\n{\n#if FF_FS_LOCK\n    clear_lock(fs);\n#endif\n#if FF_FS_REENTRANT              \n    if (!ff_del_syncobj(fs->sobj)) return FR_INT_ERR;\n#endif\n    fs->fs_type = 0;             \n\n    return FR_OK;\n}\n\n\n \n \n \n\nFRESULT f_open (\n    FATFS *fs,\n    FIL* fp,             \n    const TCHAR* path,   \n    BYTE mode            \n)\n{\n    FRESULT res;\n    DIR dj;\n#if !FF_FS_READONLY\n    DWORD dw, cl, bcs, clst, sc;\n    FSIZE_t ofs;\n#endif\n    DEF_NAMBUF\n\n\n    if (!fp) return FR_INVALID_OBJECT;\n\n     \n    mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;\n    res = find_volume(fs, mode);\n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&dj, path);    \n#if !FF_FS_READONLY  \n        if (res == FR_OK) {\n            if (dj.fn[NSFLAG] & NS_NONAME) {     \n                res = FR_INVALID_NAME;\n            }\n#if FF_FS_LOCK != 0\n            else {\n                res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);      \n            }\n#endif\n        }\n         \n        if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {\n            if (res != FR_OK) {                  \n                if (res == FR_NO_FILE) {         \n#if FF_FS_LOCK != 0\n                    res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;\n#else\n                    res = dir_register(&dj);\n#endif\n                }\n                mode |= FA_CREATE_ALWAYS;        \n            }\n            else {                               \n                if (dj.obj.attr & (AM_RDO | AM_DIR)) {   \n                    res = FR_DENIED;\n                } else {\n                    if (mode & FA_CREATE_NEW) res = FR_EXIST;    \n                }\n            }\n            if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {     \n#if FF_FS_EXFAT\n                if (fs->fs_type == FS_EXFAT) {\n                     \n                    fp->obj.fs = fs;\n                    init_alloc_info(fs, &fp->obj);\n                     \n                    mem_set(fs->dirbuf + 2, 0, 30);      \n                    mem_set(fs->dirbuf + 38, 0, 26);     \n                    fs->dirbuf[XDIR_Attr] = AM_ARC;\n                    st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());\n                    fs->dirbuf[XDIR_GenFlags] = 1;\n                    res = store_xdir(&dj);\n                    if (res == FR_OK && fp->obj.sclust != 0) {   \n                        res = remove_chain(&fp->obj, fp->obj.sclust, 0);\n                        fs->last_clst = fp->obj.sclust - 1;      \n                    }\n                } else\n#endif\n                {\n                     \n                    cl = ld_clust(fs, dj.dir);           \n                    st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());   \n                    dj.dir[DIR_Attr] = AM_ARC;           \n                    st_clust(fs, dj.dir, 0);             \n                    st_dword(dj.dir + DIR_FileSize, 0);\n                    fs->wflag = 1;\n                    if (cl != 0) {                       \n                        dw = fs->winsect;\n                        res = remove_chain(&dj.obj, cl, 0);\n                        if (res == FR_OK) {\n                            res = move_window(fs, dw);\n                            fs->last_clst = cl - 1;      \n                        }\n                    }\n                }\n            }\n        }\n        else {   \n            if (res == FR_OK) {                  \n                if (dj.obj.attr & AM_DIR) {      \n                    res = FR_NO_FILE;\n                } else {\n                    if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) {  \n                        res = FR_DENIED;\n                    }\n                }\n            }\n        }\n        if (res == FR_OK) {\n            if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;    \n            fp->dir_sect = fs->winsect;          \n            fp->dir_ptr = dj.dir;\n#if FF_FS_LOCK != 0\n            fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);   \n            if (fp->obj.lockid == 0) res = FR_INT_ERR;\n#endif\n        }\n#else        \n        if (res == FR_OK) {\n            if (dj.fn[NSFLAG] & NS_NONAME) {     \n                res = FR_INVALID_NAME;\n            } else {\n                if (dj.obj.attr & AM_DIR) {      \n                    res = FR_NO_FILE;\n                }\n            }\n        }\n#endif\n\n        if (res == FR_OK) {\n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {\n                fp->obj.c_scl = dj.obj.sclust;                           \n                fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;\n                fp->obj.c_ofs = dj.blk_ofs;\n                init_alloc_info(fs, &fp->obj);\n            } else\n#endif\n            {\n                fp->obj.sclust = ld_clust(fs, dj.dir);                   \n                fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);\n            }\n#if FF_USE_FASTSEEK\n            fp->cltbl = 0;           \n#endif\n            fp->obj.fs = fs;         \n            fp->obj.id = fs->id;\n            fp->flag = mode;         \n            fp->err = 0;             \n            fp->sect = 0;            \n            fp->fptr = 0;            \n#if !FF_FS_READONLY\n#if !FF_FS_TINY\n            mem_set(fp->buf, 0, sizeof fp->buf);     \n#endif\n            if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {    \n                fp->fptr = fp->obj.objsize;          \n                bcs = (DWORD)fs->csize * SS(fs);     \n                clst = fp->obj.sclust;               \n                for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {\n                    clst = get_fat(&fp->obj, clst);\n                    if (clst <= 1) res = FR_INT_ERR;\n                    if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;\n                }\n                fp->clust = clst;\n                if (res == FR_OK && ofs % SS(fs)) {  \n                    if ((sc = clst2sect(fs, clst)) == 0) {\n                        res = FR_INT_ERR;\n                    } else {\n                        fp->sect = sc + (DWORD)(ofs / SS(fs));\n#if !FF_FS_TINY\n                        if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;\n#endif\n                    }\n                }\n            }\n#endif\n        }\n\n        FREE_NAMBUF();\n    }\n\n    if (res != FR_OK) fp->obj.fs = 0;    \n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_read (\n    FIL* fp,     \n    void* buff,  \n    UINT btr,    \n    UINT* br     \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD clst, sect;\n    FSIZE_t remain;\n    UINT rcnt, cc, csect;\n    BYTE *rbuff = (BYTE*)buff;\n\n\n    *br = 0;     \n    res = validate(&fp->obj, &fs);               \n    if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);    \n    if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);  \n    remain = fp->obj.objsize - fp->fptr;\n    if (btr > remain) btr = (UINT)remain;        \n\n    for ( ;  btr;                                \n        btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {\n        if (fp->fptr % SS(fs) == 0) {            \n            csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));     \n            if (csect == 0) {                    \n                if (fp->fptr == 0) {             \n                    clst = fp->obj.sclust;       \n                } else {                         \n#if FF_USE_FASTSEEK\n                    if (fp->cltbl) {\n                        clst = clmt_clust(fp, fp->fptr);     \n                    } else\n#endif\n                    {\n                        clst = get_fat(&fp->obj, fp->clust);     \n                    }\n                }\n                if (clst < 2) ABORT(fs, FR_INT_ERR);\n                if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);\n                fp->clust = clst;                \n            }\n            sect = clst2sect(fs, fp->clust);     \n            if (sect == 0) ABORT(fs, FR_INT_ERR);\n            sect += csect;\n            cc = btr / SS(fs);                   \n            if (cc > 0) {                        \n                if (csect + cc > fs->csize) {    \n                    cc = fs->csize - csect;\n                }\n                if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);\n#if !FF_FS_READONLY && FF_FS_MINIMIZE <= 2       \n#if FF_FS_TINY\n                if (fs->wflag && fs->winsect - sect < cc) {\n                    mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));\n                }\n#else\n                if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {\n                    mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));\n                }\n#endif\n#endif\n                rcnt = SS(fs) * cc;              \n                continue;\n            }\n#if !FF_FS_TINY\n            if (fp->sect != sect) {          \n#if !FF_FS_READONLY\n                if (fp->flag & FA_DIRTY) {       \n                    if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);\n                    fp->flag &= (BYTE)~FA_DIRTY;\n                }\n#endif\n                if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)    ABORT(fs, FR_DISK_ERR);  \n            }\n#endif\n            fp->sect = sect;\n        }\n        rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);     \n        if (rcnt > btr) rcnt = btr;                  \n#if FF_FS_TINY\n        if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);  \n        mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);   \n#else\n        mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);   \n#endif\n    }\n\n    LEAVE_FF(fs, FR_OK);\n}\n\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nFRESULT f_write (\n    FIL* fp,             \n    const void* buff,    \n    UINT btw,            \n    UINT* bw             \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD clst, sect;\n    UINT wcnt, cc, csect;\n    const BYTE *wbuff = (const BYTE*)buff;\n\n\n    *bw = 0;     \n    res = validate(&fp->obj, &fs);           \n    if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);    \n    if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);     \n\n     \n    if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {\n        btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);\n    }\n\n    for ( ;  btw;                            \n        btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {\n        if (fp->fptr % SS(fs) == 0) {        \n            csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);     \n            if (csect == 0) {                \n                if (fp->fptr == 0) {         \n                    clst = fp->obj.sclust;   \n                    if (clst == 0) {         \n                        clst = create_chain(&fp->obj, 0);    \n                    }\n                } else {                     \n#if FF_USE_FASTSEEK\n                    if (fp->cltbl) {\n                        clst = clmt_clust(fp, fp->fptr);     \n                    } else\n#endif\n                    {\n                        clst = create_chain(&fp->obj, fp->clust);    \n                    }\n                }\n                if (clst == 0) break;        \n                if (clst == 1) ABORT(fs, FR_INT_ERR);\n                if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);\n                fp->clust = clst;            \n                if (fp->obj.sclust == 0) fp->obj.sclust = clst;  \n            }\n#if FF_FS_TINY\n            if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);     \n#else\n            if (fp->flag & FA_DIRTY) {       \n                if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);\n                fp->flag &= (BYTE)~FA_DIRTY;\n            }\n#endif\n            sect = clst2sect(fs, fp->clust);     \n            if (sect == 0) ABORT(fs, FR_INT_ERR);\n            sect += csect;\n            cc = btw / SS(fs);               \n            if (cc > 0) {                    \n                if (csect + cc > fs->csize) {    \n                    cc = fs->csize - csect;\n                }\n                if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);\n#if FF_FS_MINIMIZE <= 2\n#if FF_FS_TINY\n                if (fs->winsect - sect < cc) {   \n                    mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));\n                    fs->wflag = 0;\n                }\n#else\n                if (fp->sect - sect < cc) {  \n                    mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));\n                    fp->flag &= (BYTE)~FA_DIRTY;\n                }\n#endif\n#endif\n                wcnt = SS(fs) * cc;      \n                continue;\n            }\n#if FF_FS_TINY\n            if (fp->fptr >= fp->obj.objsize) {   \n                if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);\n                fs->winsect = sect;\n            }\n#else\n            if (fp->sect != sect &&          \n                fp->fptr < fp->obj.objsize &&\n                disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {\n                    ABORT(fs, FR_DISK_ERR);\n            }\n#endif\n            fp->sect = sect;\n        }\n        wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);     \n        if (wcnt > btw) wcnt = btw;                  \n#if FF_FS_TINY\n        if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);  \n        mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);   \n        fs->wflag = 1;\n#else\n        mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);   \n        fp->flag |= FA_DIRTY;\n#endif\n    }\n\n    fp->flag |= FA_MODIFIED;                 \n\n    LEAVE_FF(fs, FR_OK);\n}\n\n\n\n\n \n \n \n\nFRESULT f_sync (\n    FIL* fp      \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD tm;\n    BYTE *dir;\n\n\n    res = validate(&fp->obj, &fs);   \n    if (res == FR_OK) {\n        if (fp->flag & FA_MODIFIED) {    \n#if !FF_FS_TINY\n            if (fp->flag & FA_DIRTY) {   \n                if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);\n                fp->flag &= (BYTE)~FA_DIRTY;\n            }\n#endif\n             \n            tm = GET_FATTIME();              \n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {\n                res = fill_first_frag(&fp->obj);     \n                if (res == FR_OK) {\n                    res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);   \n                }\n                if (res == FR_OK) {\n                    DIR dj;\n                    DEF_NAMBUF\n\n                    INIT_NAMBUF(fs);\n                    res = load_obj_xdir(&dj, &fp->obj);  \n                    if (res == FR_OK) {\n                        fs->dirbuf[XDIR_Attr] |= AM_ARC;                 \n                        fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;    \n                        st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);\n                        st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);\n                        st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);\n                        st_dword(fs->dirbuf + XDIR_ModTime, tm);         \n                        fs->dirbuf[XDIR_ModTime10] = 0;\n                        st_dword(fs->dirbuf + XDIR_AccTime, 0);\n                        res = store_xdir(&dj);   \n                        if (res == FR_OK) {\n                            res = sync_fs(fs);\n                            fp->flag &= (BYTE)~FA_MODIFIED;\n                        }\n                    }\n                    FREE_NAMBUF();\n                }\n            } else\n#endif\n            {\n                res = move_window(fs, fp->dir_sect);\n                if (res == FR_OK) {\n                    dir = fp->dir_ptr;\n                    dir[DIR_Attr] |= AM_ARC;                         \n                    st_clust(fp->obj.fs, dir, fp->obj.sclust);       \n                    st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);    \n                    st_dword(dir + DIR_ModTime, tm);                 \n                    st_word(dir + DIR_LstAccDate, 0);\n                    fs->wflag = 1;\n                    res = sync_fs(fs);                   \n                    fp->flag &= (BYTE)~FA_MODIFIED;\n                }\n            }\n        }\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n#endif  \n\n\n\n\n \n \n \n\nFRESULT f_close (\n    FIL* fp      \n)\n{\n    FRESULT res;\n    FATFS *fs;\n\n#if !FF_FS_READONLY\n    res = f_sync(fp);                    \n    if (res == FR_OK)\n#endif\n    {\n        res = validate(&fp->obj, &fs);   \n        if (res == FR_OK) {\n#if FF_FS_LOCK != 0\n            res = dec_lock(fp->obj.lockid);      \n            if (res == FR_OK) fp->obj.fs = 0;    \n#else\n            fp->obj.fs = 0;  \n#endif\n#if FF_FS_REENTRANT\n            unlock_fs(fs, FR_OK);        \n#endif\n        }\n    }\n    return res;\n}\n\n\n\n\n#if FF_FS_RPATH >= 1\n \n \n \n\nFRESULT f_chdir (\n    FATFS *fs,\n    const TCHAR* path    \n)\n{\n#if FF_STR_VOLUME_ID == 2\n    UINT i;\n#endif\n    FRESULT res;\n    DIR dj;\n    DEF_NAMBUF\n\n\n     \n    res = find_volume(fs, 0);\n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&dj, path);        \n        if (res == FR_OK) {                  \n            if (dj.fn[NSFLAG] & NS_NONAME) {     \n                fs->cdir = dj.obj.sclust;\n#if FF_FS_EXFAT\n                if (fs->fs_type == FS_EXFAT) {\n                    fs->cdc_scl = dj.obj.c_scl;\n                    fs->cdc_size = dj.obj.c_size;\n                    fs->cdc_ofs = dj.obj.c_ofs;\n                }\n#endif\n            } else {\n                if (dj.obj.attr & AM_DIR) {  \n#if FF_FS_EXFAT\n                    if (fs->fs_type == FS_EXFAT) {\n                        fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);      \n                        fs->cdc_scl = dj.obj.sclust;                         \n                        fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;\n                        fs->cdc_ofs = dj.blk_ofs;\n                    } else\n#endif\n                    {\n                        fs->cdir = ld_clust(fs, dj.dir);                     \n                    }\n                } else {\n                    res = FR_NO_PATH;        \n                }\n            }\n        }\n        FREE_NAMBUF();\n        if (res == FR_NO_FILE) res = FR_NO_PATH;\n#if FF_STR_VOLUME_ID == 2    \n        if (res == FR_OK) {\n            for (i = FF_VOLUMES - 1; i && fs != FatFs[i]; i--) ;     \n            CurrVol = (BYTE)i;\n        }\n#endif\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n#if FF_FS_RPATH >= 2\nFRESULT f_getcwd (\n    FATFS *fs,\n    TCHAR* buff,     \n    UINT len         \n)\n{\n    FRESULT res;\n    DIR dj;\n    UINT i, n;\n    DWORD ccl;\n    TCHAR *tp = buff;\n#if FF_VOLUMES >= 2\n    UINT vl;\n#endif\n#if FF_STR_VOLUME_ID\n    const char *vp;\n#endif\n    FILINFO fno;\n    DEF_NAMBUF\n\n\n     \n    buff[0] = 0;     \n    res = find_volume(fs, 0);     \n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n\n         \n        i = len;             \n        if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {   \n            dj.obj.sclust = fs->cdir;                \n            while ((ccl = dj.obj.sclust) != 0) {     \n                res = dir_sdi(&dj, 1 * SZDIRE);  \n                if (res != FR_OK) break;\n                res = move_window(fs, dj.sect);\n                if (res != FR_OK) break;\n                dj.obj.sclust = ld_clust(fs, dj.dir);    \n                res = dir_sdi(&dj, 0);\n                if (res != FR_OK) break;\n                do {                             \n                    res = DIR_READ_FILE(&dj);\n                    if (res != FR_OK) break;\n                    if (ccl == ld_clust(fs, dj.dir)) break;  \n                    res = dir_next(&dj, 0);\n                } while (res == FR_OK);\n                if (res == FR_NO_FILE) res = FR_INT_ERR; \n                if (res != FR_OK) break;\n                get_fileinfo(&dj, &fno);         \n                for (n = 0; fno.fname[n]; n++) ;     \n                if (i < n + 1) {     \n                    res = FR_NOT_ENOUGH_CORE; break;\n                }\n                while (n) buff[--i] = fno.fname[--n];    \n                buff[--i] = '/';\n            }\n        }\n        if (res == FR_OK) {\n            if (i == len) buff[--i] = '/';   \n#if FF_VOLUMES >= 2          \n            vl = 0;\n#if FF_STR_VOLUME_ID >= 1    \n            for (n = 0, vp = (const char*)VolumeStr[CurrVol]; vp[n]; n++) ;\n            if (i >= n + 2) {\n                if (FF_STR_VOLUME_ID == 2) *tp++ = (TCHAR)'/';\n                for (vl = 0; vl < n; *tp++ = (TCHAR)vp[vl], vl++) ;\n                if (FF_STR_VOLUME_ID == 1) *tp++ = (TCHAR)':';\n                vl++;\n            }\n#else                        \n            if (i >= 3) {\n                *tp++ = (TCHAR)'0' + CurrVol;\n                *tp++ = (TCHAR)':';\n                vl = 2;\n            }\n#endif\n            if (vl == 0) res = FR_NOT_ENOUGH_CORE;\n#endif\n             \n            if (res == FR_OK) {\n                do *tp++ = buff[i++]; while (i < len);   \n            }\n        }\n        FREE_NAMBUF();\n    }\n\n    *tp = 0;\n    LEAVE_FF(fs, res);\n}\n\n#endif  \n#endif  \n\n\n\n#if FF_FS_MINIMIZE <= 2\n \n \n \n\nFRESULT f_lseek (\n    FIL* fp,         \n    FSIZE_t ofs      \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD clst, bcs, nsect;\n    FSIZE_t ifptr;\n#if FF_USE_FASTSEEK\n    DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;\n#endif\n\n    res = validate(&fp->obj, &fs);       \n    if (res == FR_OK) res = (FRESULT)fp->err;\n#if FF_FS_EXFAT && !FF_FS_READONLY\n    if (res == FR_OK && fs->fs_type == FS_EXFAT) {\n        res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);   \n    }\n#endif\n    if (res != FR_OK) LEAVE_FF(fs, res);\n\n#if FF_USE_FASTSEEK\n    if (fp->cltbl) {     \n        if (ofs == CREATE_LINKMAP) {     \n            tbl = fp->cltbl;\n            tlen = *tbl++; ulen = 2;     \n            cl = fp->obj.sclust;         \n            if (cl != 0) {\n                do {\n                     \n                    tcl = cl; ncl = 0; ulen += 2;    \n                    do {\n                        pcl = cl; ncl++;\n                        cl = get_fat(&fp->obj, cl);\n                        if (cl <= 1) ABORT(fs, FR_INT_ERR);\n                        if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);\n                    } while (cl == pcl + 1);\n                    if (ulen <= tlen) {      \n                        *tbl++ = ncl; *tbl++ = tcl;\n                    }\n                } while (cl < fs->n_fatent);     \n            }\n            *fp->cltbl = ulen;   \n            if (ulen <= tlen) {\n                *tbl = 0;        \n            } else {\n                res = FR_NOT_ENOUGH_CORE;    \n            }\n        } else {                         \n            if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;    \n            fp->fptr = ofs;              \n            if (ofs > 0) {\n                fp->clust = clmt_clust(fp, ofs - 1);\n                dsc = clst2sect(fs, fp->clust);\n                if (dsc == 0) ABORT(fs, FR_INT_ERR);\n                dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);\n                if (fp->fptr % SS(fs) && dsc != fp->sect) {  \n#if !FF_FS_TINY\n#if !FF_FS_READONLY\n                    if (fp->flag & FA_DIRTY) {       \n                        if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);\n                        fp->flag &= (BYTE)~FA_DIRTY;\n                    }\n#endif\n                    if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);  \n#endif\n                    fp->sect = dsc;\n                }\n            }\n        }\n    } else\n#endif\n\n     \n    {\n#if FF_FS_EXFAT\n        if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;     \n#endif\n        if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {   \n            ofs = fp->obj.objsize;\n        }\n        ifptr = fp->fptr;\n        fp->fptr = nsect = 0;\n        if (ofs > 0) {\n            bcs = (DWORD)fs->csize * SS(fs);     \n            if (ifptr > 0 &&\n                (ofs - 1) / bcs >= (ifptr - 1) / bcs) {  \n                fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);    \n                ofs -= fp->fptr;\n                clst = fp->clust;\n            } else {                                     \n                clst = fp->obj.sclust;                   \n#if !FF_FS_READONLY\n                if (clst == 0) {                         \n                    clst = create_chain(&fp->obj, 0);\n                    if (clst == 1) ABORT(fs, FR_INT_ERR);\n                    if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);\n                    fp->obj.sclust = clst;\n                }\n#endif\n                fp->clust = clst;\n            }\n            if (clst != 0) {\n                while (ofs > bcs) {                      \n                    ofs -= bcs; fp->fptr += bcs;\n#if !FF_FS_READONLY\n                    if (fp->flag & FA_WRITE) {           \n                        if (FF_FS_EXFAT && fp->fptr > fp->obj.objsize) {     \n                            fp->obj.objsize = fp->fptr;\n                            fp->flag |= FA_MODIFIED;\n                        }\n                        clst = create_chain(&fp->obj, clst);     \n                        if (clst == 0) {                 \n                            ofs = 0; break;\n                        }\n                    } else\n#endif\n                    {\n                        clst = get_fat(&fp->obj, clst);  \n                    }\n                    if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);\n                    if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);\n                    fp->clust = clst;\n                }\n                fp->fptr += ofs;\n                if (ofs % SS(fs)) {\n                    nsect = clst2sect(fs, clst);     \n                    if (nsect == 0) ABORT(fs, FR_INT_ERR);\n                    nsect += (DWORD)(ofs / SS(fs));\n                }\n            }\n        }\n        if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {     \n            fp->obj.objsize = fp->fptr;\n            fp->flag |= FA_MODIFIED;\n        }\n        if (fp->fptr % SS(fs) && nsect != fp->sect) {    \n#if !FF_FS_TINY\n#if !FF_FS_READONLY\n            if (fp->flag & FA_DIRTY) {           \n                if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);\n                fp->flag &= (BYTE)~FA_DIRTY;\n            }\n#endif\n            if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);    \n#endif\n            fp->sect = nsect;\n        }\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n#if FF_FS_MINIMIZE <= 1\n \n \n \n\nFRESULT f_opendir (\n    FATFS *fs,\n    DIR* dp,             \n    const TCHAR* path    \n)\n{\n    FRESULT res;\n    DEF_NAMBUF\n\n\n    if (!dp) return FR_INVALID_OBJECT;\n\n     \n    res = find_volume(fs, 0);\n    if (res == FR_OK) {\n        dp->obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(dp, path);             \n        if (res == FR_OK) {                      \n            if (!(dp->fn[NSFLAG] & NS_NONAME)) {     \n                if (dp->obj.attr & AM_DIR) {         \n#if FF_FS_EXFAT\n                    if (fs->fs_type == FS_EXFAT) {\n                        dp->obj.c_scl = dp->obj.sclust;                          \n                        dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;\n                        dp->obj.c_ofs = dp->blk_ofs;\n                        init_alloc_info(fs, &dp->obj);   \n                    } else\n#endif\n                    {\n                        dp->obj.sclust = ld_clust(fs, dp->dir);  \n                    }\n                } else {                         \n                    res = FR_NO_PATH;\n                }\n            }\n            if (res == FR_OK) {\n                dp->obj.id = fs->id;\n                res = dir_sdi(dp, 0);            \n#if FF_FS_LOCK != 0\n                if (res == FR_OK) {\n                    if (dp->obj.sclust != 0) {\n                        dp->obj.lockid = inc_lock(dp, 0);    \n                        if (!dp->obj.lockid) res = FR_TOO_MANY_OPEN_FILES;\n                    } else {\n                        dp->obj.lockid = 0;  \n                    }\n                }\n#endif\n            }\n        }\n        FREE_NAMBUF();\n        if (res == FR_NO_FILE) res = FR_NO_PATH;\n    }\n    if (res != FR_OK) dp->obj.fs = 0;        \n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_closedir (\n    DIR *dp      \n)\n{\n    FRESULT res;\n    FATFS *fs;\n\n\n    res = validate(&dp->obj, &fs);   \n    if (res == FR_OK) {\n#if FF_FS_LOCK != 0\n        if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);  \n        if (res == FR_OK) dp->obj.fs = 0;    \n#else\n        dp->obj.fs = 0;  \n#endif\n#if FF_FS_REENTRANT\n        unlock_fs(fs, FR_OK);        \n#endif\n    }\n    return res;\n}\n\n\n\n\n \n \n \n\nFRESULT f_readdir (\n    DIR* dp,             \n    FILINFO* fno         \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DEF_NAMBUF\n\n\n    res = validate(&dp->obj, &fs);   \n    if (res == FR_OK) {\n        if (!fno) {\n            res = dir_sdi(dp, 0);            \n        } else {\n            INIT_NAMBUF(fs);\n            res = DIR_READ_FILE(dp);         \n            if (res == FR_NO_FILE) res = FR_OK;  \n            if (res == FR_OK) {              \n                get_fileinfo(dp, fno);       \n                res = dir_next(dp, 0);       \n                if (res == FR_NO_FILE) res = FR_OK;  \n            }\n            FREE_NAMBUF();\n        }\n    }\n    LEAVE_FF(fs, res);\n}\n\n\n\n#if FF_USE_FIND\n \n \n \n\nFRESULT f_findnext (\n    DIR* dp,         \n    FILINFO* fno     \n)\n{\n    FRESULT res;\n\n\n    for (;;) {\n        res = f_readdir(dp, fno);        \n        if (res != FR_OK || !fno || !fno->fname[0]) break;   \n        if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;      \n#if FF_USE_LFN && FF_USE_FIND == 2\n        if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;    \n#endif\n    }\n    return res;\n}\n\n\n\n \n \n \n\nFRESULT f_findfirst (\n    DIR* dp,                 \n    FILINFO* fno,            \n    const TCHAR* path,       \n    const TCHAR* pattern     \n)\n{\n    FRESULT res;\n\n\n    dp->pat = pattern;       \n    res = f_opendir(dp, path);       \n    if (res == FR_OK) {\n        res = f_findnext(dp, fno);   \n    }\n    return res;\n}\n\n#endif   \n\n\n\n#if FF_FS_MINIMIZE == 0\n \n \n \n\nFRESULT f_stat (\n    FATFS *fs,\n    const TCHAR* path,   \n    FILINFO* fno         \n)\n{\n    FRESULT res;\n    DIR dj;\n    DEF_NAMBUF\n\n\n     \n    res = find_volume(fs, 0);\n    dj.obj.fs = fs;\n    if (res == FR_OK) {\n        INIT_NAMBUF(dj.obj.fs);\n        res = follow_path(&dj, path);    \n        if (res == FR_OK) {              \n            if (dj.fn[NSFLAG] & NS_NONAME) {     \n                res = FR_INVALID_NAME;\n            } else {                             \n                if (fno) get_fileinfo(&dj, fno);\n            }\n        }\n        FREE_NAMBUF();\n    }\n\n    LEAVE_FF(dj.obj.fs, res);\n}\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nFRESULT f_getfree (\n    FATFS *fs,\n    DWORD* nclst         \n)\n{\n    FRESULT res;\n    DWORD nfree, clst, sect, stat;\n    UINT i;\n    FFOBJID obj;\n\n\n     \n    res = find_volume(fs, 0);\n    if (res == FR_OK) {\n         \n        if (fs->free_clst <= fs->n_fatent - 2) {\n            *nclst = fs->free_clst;\n        } else {\n             \n            nfree = 0;\n            if (fs->fs_type == FS_FAT12) {   \n                clst = 2; obj.fs = fs;\n                do {\n                    stat = get_fat(&obj, clst);\n                    if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }\n                    if (stat == 1) { res = FR_INT_ERR; break; }\n                    if (stat == 0) nfree++;\n                } while (++clst < fs->n_fatent);\n            } else {\n#if FF_FS_EXFAT\n                if (fs->fs_type == FS_EXFAT) {   \n                    BYTE bm;\n                    UINT b;\n\n                    clst = fs->n_fatent - 2;     \n                    sect = fs->bitbase;          \n                    i = 0;                       \n                    do {     \n                        if (i == 0) {\n                            res = move_window(fs, sect++);\n                            if (res != FR_OK) break;\n                        }\n                        for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {\n                            if (!(bm & 1)) nfree++;\n                            bm >>= 1;\n                        }\n                        i = (i + 1) % SS(fs);\n                    } while (clst);\n                } else\n#endif\n                {    \n                    clst = fs->n_fatent;     \n                    sect = fs->fatbase;      \n                    i = 0;                   \n                    do {     \n                        if (i == 0) {\n                            res = move_window(fs, sect++);\n                            if (res != FR_OK) break;\n                        }\n                        if (fs->fs_type == FS_FAT16) {\n                            if (ld_word(fs->win + i) == 0) nfree++;\n                            i += 2;\n                        } else {\n                            if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;\n                            i += 4;\n                        }\n                        i %= SS(fs);\n                    } while (--clst);\n                }\n            }\n            *nclst = nfree;          \n            fs->free_clst = nfree;   \n            fs->fsi_flag |= 1;       \n        }\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_truncate (\n    FIL* fp      \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD ncl;\n\n\n    res = validate(&fp->obj, &fs);   \n    if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);\n    if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);     \n\n    if (fp->fptr < fp->obj.objsize) {    \n        if (fp->fptr == 0) {     \n            res = remove_chain(&fp->obj, fp->obj.sclust, 0);\n            fp->obj.sclust = 0;\n        } else {                 \n            ncl = get_fat(&fp->obj, fp->clust);\n            res = FR_OK;\n            if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;\n            if (ncl == 1) res = FR_INT_ERR;\n            if (res == FR_OK && ncl < fs->n_fatent) {\n                res = remove_chain(&fp->obj, ncl, fp->clust);\n            }\n        }\n        fp->obj.objsize = fp->fptr;  \n        fp->flag |= FA_MODIFIED;\n#if !FF_FS_TINY\n        if (res == FR_OK && (fp->flag & FA_DIRTY)) {\n            if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {\n                res = FR_DISK_ERR;\n            } else {\n                fp->flag &= (BYTE)~FA_DIRTY;\n            }\n        }\n#endif\n        if (res != FR_OK) ABORT(fs, res);\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_unlink (\n    FATFS *fs,\n    const TCHAR* path        \n)\n{\n    FRESULT res;\n    DIR dj, sdj;\n    DWORD dclst = 0;\n#if FF_FS_EXFAT\n    FFOBJID obj;\n#endif\n    DEF_NAMBUF\n\n\n     \n    res = find_volume(fs, FA_WRITE);\n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&dj, path);        \n        if (FF_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {\n            res = FR_INVALID_NAME;           \n        }\n#if FF_FS_LOCK != 0\n        if (res == FR_OK) res = chk_lock(&dj, 2);    \n#endif\n        if (res == FR_OK) {                  \n            if (dj.fn[NSFLAG] & NS_NONAME) {\n                res = FR_INVALID_NAME;       \n            } else {\n                if (dj.obj.attr & AM_RDO) {\n                    res = FR_DENIED;         \n                }\n            }\n            if (res == FR_OK) {\n#if FF_FS_EXFAT\n                obj.fs = fs;\n                if (fs->fs_type == FS_EXFAT) {\n                    init_alloc_info(fs, &obj);\n                    dclst = obj.sclust;\n                } else\n#endif\n                {\n                    dclst = ld_clust(fs, dj.dir);\n                }\n                if (dj.obj.attr & AM_DIR) {          \n#if FF_FS_RPATH != 0\n                    if (dclst == fs->cdir) {             \n                        res = FR_DENIED;\n                    } else\n#endif\n                    {\n                        sdj.obj.fs = fs;                 \n                        sdj.obj.sclust = dclst;\n#if FF_FS_EXFAT\n                        if (fs->fs_type == FS_EXFAT) {\n                            sdj.obj.objsize = obj.objsize;\n                            sdj.obj.stat = obj.stat;\n                        }\n#endif\n                        res = dir_sdi(&sdj, 0);\n                        if (res == FR_OK) {\n                            res = DIR_READ_FILE(&sdj);           \n                            if (res == FR_OK) res = FR_DENIED;   \n                            if (res == FR_NO_FILE) res = FR_OK;  \n                        }\n                    }\n                }\n            }\n            if (res == FR_OK) {\n                res = dir_remove(&dj);           \n                if (res == FR_OK && dclst != 0) {    \n#if FF_FS_EXFAT\n                    res = remove_chain(&obj, dclst, 0);\n#else\n                    res = remove_chain(&dj.obj, dclst, 0);\n#endif\n                }\n                if (res == FR_OK) res = sync_fs(fs);\n            }\n        }\n        FREE_NAMBUF();\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_mkdir (\n    FATFS *fs,\n    const TCHAR* path        \n)\n{\n    FRESULT res;\n    DIR dj;\n    FFOBJID sobj;\n    DWORD dcl, pcl, tm;\n    DEF_NAMBUF\n\n\n    res = find_volume(fs, FA_WRITE);     \n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&dj, path);            \n        if (res == FR_OK) res = FR_EXIST;        \n        if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {  \n            res = FR_INVALID_NAME;\n        }\n        if (res == FR_NO_FILE) {                 \n            sobj.fs = fs;                        \n            dcl = create_chain(&sobj, 0);        \n            res = FR_OK;\n            if (dcl == 0) res = FR_DENIED;       \n            if (dcl == 1) res = FR_INT_ERR;      \n            if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;    \n            tm = GET_FATTIME();\n            if (res == FR_OK) {\n                res = dir_clear(fs, dcl);        \n                if (res == FR_OK) {\n                    if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {   \n                        mem_set(fs->win + DIR_Name, ' ', 11);    \n                        fs->win[DIR_Name] = '.';\n                        fs->win[DIR_Attr] = AM_DIR;\n                        st_dword(fs->win + DIR_ModTime, tm);\n                        st_clust(fs, fs->win, dcl);\n                        mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE);  \n                        fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;\n                        st_clust(fs, fs->win + SZDIRE, pcl);\n                        fs->wflag = 1;\n                    }\n                    res = dir_register(&dj);     \n                }\n            }\n            if (res == FR_OK) {\n#if FF_FS_EXFAT\n                if (fs->fs_type == FS_EXFAT) {   \n                    st_dword(fs->dirbuf + XDIR_ModTime, tm);     \n                    st_dword(fs->dirbuf + XDIR_FstClus, dcl);    \n                    st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)fs->csize * SS(fs));     \n                    st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)fs->csize * SS(fs));\n                    fs->dirbuf[XDIR_GenFlags] = 3;               \n                    fs->dirbuf[XDIR_Attr] = AM_DIR;              \n                    res = store_xdir(&dj);\n                } else\n#endif\n                {\n                    st_dword(dj.dir + DIR_ModTime, tm);  \n                    st_clust(fs, dj.dir, dcl);           \n                    dj.dir[DIR_Attr] = AM_DIR;           \n                    fs->wflag = 1;\n                }\n                if (res == FR_OK) {\n                    res = sync_fs(fs);\n                }\n            } else {\n                remove_chain(&sobj, dcl, 0);         \n            }\n        }\n        FREE_NAMBUF();\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_rename (\n    FATFS *fs,\n    const TCHAR* path_old,   \n    const TCHAR* path_new    \n)\n{\n    FRESULT res;\n    DIR djo, djn;\n    BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;\n    DWORD dw;\n    DEF_NAMBUF\n\n\n    res = find_volume(fs, FA_WRITE);     \n    if (res == FR_OK) {\n        djo.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&djo, path_old);       \n        if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;  \n#if FF_FS_LOCK != 0\n        if (res == FR_OK) {\n            res = chk_lock(&djo, 2);\n        }\n#endif\n        if (res == FR_OK) {                      \n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {   \n                BYTE nf, nn;\n                WORD nh;\n\n                mem_cpy(buf, fs->dirbuf, SZDIRE * 2);    \n                mem_cpy(&djn, &djo, sizeof djo);\n                res = follow_path(&djn, path_new);       \n                if (res == FR_OK) {                      \n                    res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;\n                }\n                if (res == FR_NO_FILE) {                 \n                    res = dir_register(&djn);            \n                    if (res == FR_OK) {\n                        nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];\n                        nh = ld_word(fs->dirbuf + XDIR_NameHash);\n                        mem_cpy(fs->dirbuf, buf, SZDIRE * 2);    \n                        fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;\n                        st_word(fs->dirbuf + XDIR_NameHash, nh);\n                        if (!(fs->dirbuf[XDIR_Attr] & AM_DIR)) fs->dirbuf[XDIR_Attr] |= AM_ARC;  \n \n                        res = store_xdir(&djn);\n                    }\n                }\n            } else\n#endif\n            {    \n                mem_cpy(buf, djo.dir, SZDIRE);           \n                mem_cpy(&djn, &djo, sizeof (DIR));       \n                res = follow_path(&djn, path_new);       \n                if (res == FR_OK) {                      \n                    res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;\n                }\n                if (res == FR_NO_FILE) {                 \n                    res = dir_register(&djn);            \n                    if (res == FR_OK) {\n                        dir = djn.dir;                   \n                        mem_cpy(dir + 13, buf + 13, SZDIRE - 13);\n                        dir[DIR_Attr] = buf[DIR_Attr];\n                        if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;  \n                        fs->wflag = 1;\n                        if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {  \n                            dw = clst2sect(fs, ld_clust(fs, dir));\n                            if (dw == 0) {\n                                res = FR_INT_ERR;\n                            } else {\n \n                                res = move_window(fs, dw);\n                                dir = fs->win + SZDIRE * 1;  \n                                if (res == FR_OK && dir[1] == '.') {\n                                    st_clust(fs, dir, djn.obj.sclust);\n                                    fs->wflag = 1;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (res == FR_OK) {\n                res = dir_remove(&djo);      \n                if (res == FR_OK) {\n                    res = sync_fs(fs);\n                }\n            }\n \n        }\n        FREE_NAMBUF();\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n#endif  \n#endif  \n#endif  \n#endif  \n\n\n\n#if FF_USE_CHMOD && !FF_FS_READONLY\n \n \n \n\nFRESULT f_chmod (\n    FATFS *fs,\n    const TCHAR* path,   \n    BYTE attr,           \n    BYTE mask            \n)\n{\n    FRESULT res;\n    DIR dj;\n    DEF_NAMBUF\n\n\n    res = find_volume(fs, FA_WRITE);     \n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&dj, path);    \n        if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;   \n        if (res == FR_OK) {\n            mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;     \n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {\n                fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);   \n                res = store_xdir(&dj);\n            } else\n#endif\n            {\n                dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);     \n                fs->wflag = 1;\n            }\n            if (res == FR_OK) {\n                res = sync_fs(fs);\n            }\n        }\n        FREE_NAMBUF();\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n\n \n \n \n\nFRESULT f_utime (\n    FATFS *fs,\n    const TCHAR* path,   \n    const FILINFO* fno   \n)\n{\n    FRESULT res;\n    DIR dj;\n    DEF_NAMBUF\n\n\n    res = find_volume(fs, FA_WRITE);     \n    if (res == FR_OK) {\n        dj.obj.fs = fs;\n        INIT_NAMBUF(fs);\n        res = follow_path(&dj, path);    \n        if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;   \n        if (res == FR_OK) {\n#if FF_FS_EXFAT\n            if (fs->fs_type == FS_EXFAT) {\n                st_dword(fs->dirbuf + XDIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);\n                res = store_xdir(&dj);\n            } else\n#endif\n            {\n                st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);\n                fs->wflag = 1;\n            }\n            if (res == FR_OK) {\n                res = sync_fs(fs);\n            }\n        }\n        FREE_NAMBUF();\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n#endif   \n\n\n\n#if FF_USE_LABEL\n \n \n \n\nFRESULT f_getlabel (\n    FATFS *fs,\n    TCHAR* label,        \n    DWORD* vsn           \n)\n{\n    FRESULT res;\n    DIR dj;\n    UINT si, di;\n    WCHAR wc;\n\n     \n    res = find_volume(fs, 0);\n\n     \n    if (res == FR_OK && label) {\n        dj.obj.fs = fs; dj.obj.sclust = 0;   \n        res = dir_sdi(&dj, 0);\n        if (res == FR_OK) {\n            res = DIR_READ_LABEL(&dj);       \n            if (res == FR_OK) {\n#if FF_FS_EXFAT\n                if (fs->fs_type == FS_EXFAT) {\n                    WCHAR hs;\n\n                    for (si = di = hs = 0; si < dj.dir[XDIR_NumLabel]; si++) {   \n                        wc = ld_word(dj.dir + XDIR_Label + si * 2);\n                        if (hs == 0 && IsSurrogate(wc)) {    \n                            hs = wc; continue;\n                        }\n                        wc = put_utf((DWORD)hs << 16 | wc, &label[di], 4);\n                        if (wc == 0) { di = 0; break; }\n                        di += wc;\n                        hs = 0;\n                    }\n                    if (hs != 0) di = 0;     \n                    label[di] = 0;\n                } else\n#endif\n                {\n                    si = di = 0;         \n                    while (si < 11) {\n                        wc = dj.dir[si++];\n#if FF_USE_LFN && FF_LFN_UNICODE >= 1    \n                        if (dbc_1st((BYTE)wc) && si < 11) wc = wc << 8 | dj.dir[si++];   \n                        wc = ff_oem2uni(wc, CODEPAGE);                   \n                        if (wc != 0) wc = put_utf(wc, &label[di], 4);    \n                        if (wc == 0) { di = 0; break; }\n                        di += wc;\n#else                                    \n                        label[di++] = (TCHAR)wc;\n#endif\n                    }\n                    do {                 \n                        label[di] = 0;\n                        if (di == 0) break;\n                    } while (label[--di] == ' ');\n                }\n            }\n        }\n        if (res == FR_NO_FILE) {     \n            label[0] = 0;\n            res = FR_OK;\n        }\n    }\n\n     \n    if (res == FR_OK && vsn) {\n        res = move_window(fs, fs->volbase);\n        if (res == FR_OK) {\n            switch (fs->fs_type) {\n            case FS_EXFAT:\n                di = BPB_VolIDEx; break;\n\n            case FS_FAT32:\n                di = BS_VolID32; break;\n\n            default:\n                di = BS_VolID;\n            }\n            *vsn = ld_dword(fs->win + di);\n        }\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n\n\n#if !FF_FS_READONLY\n \n \n \n\nFRESULT f_setlabel (\n    FATFS *fs,\n    const TCHAR* label   \n)\n{\n    FRESULT res;\n    DIR dj;\n    BYTE dirvn[22];\n    UINT di;\n    WCHAR wc;\n    static const char badchr[] = \"+.,;=[]/\\\\\\\"*:<>\\?|\\x7F\";  \n#if FF_USE_LFN\n    DWORD dc;\n#endif\n\n     \n    res = find_volume(fs, FA_WRITE);\n    if (res != FR_OK) LEAVE_FF(fs, res);\n\n#if FF_FS_EXFAT\n    if (fs->fs_type == FS_EXFAT) {   \n        mem_set(dirvn, 0, 22);\n        di = 0;\n        while ((UINT)*label >= ' ') {    \n            dc = tchar2uni(&label);  \n            if (dc >= 0x10000) {\n                if (dc == 0xFFFFFFFF || di >= 10) {  \n                    dc = 0;\n                } else {\n                    st_word(dirvn + di * 2, (WCHAR)(dc >> 16)); di++;\n                }\n            }\n            if (dc == 0 || chk_chr(badchr + 7, (int)dc) || di >= 11) {   \n                LEAVE_FF(fs, FR_INVALID_NAME);\n            }\n            st_word(dirvn + di * 2, (WCHAR)dc); di++;\n        }\n    } else\n#endif\n    {    \n        mem_set(dirvn, ' ', 11);\n        di = 0;\n        while ((UINT)*label >= ' ') {    \n#if FF_USE_LFN\n            dc = tchar2uni(&label);\n            wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), CODEPAGE) : 0;\n#else                                    \n            wc = (BYTE)*label++;\n            if (dbc_1st((BYTE)wc)) wc = dbc_2nd((BYTE)*label) ? wc << 8 | (BYTE)*label++ : 0;\n            if (IsLower(wc)) wc -= 0x20;         \n#if FF_CODE_PAGE == 0\n            if (ExCvt && wc >= 0x80) wc = ExCvt[wc - 0x80];  \n#elif FF_CODE_PAGE < 900\n            if (wc >= 0x80) wc = ExCvt[wc - 0x80];   \n#endif\n#endif\n            if (wc == 0 || chk_chr(badchr + 0, (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {  \n                LEAVE_FF(fs, FR_INVALID_NAME);\n            }\n            if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);\n            dirvn[di++] = (BYTE)wc;\n        }\n        if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);     \n        while (di && dirvn[di - 1] == ' ') di--;                 \n    }\n\n     \n    dj.obj.fs = fs; dj.obj.sclust = 0;   \n    res = dir_sdi(&dj, 0);\n    if (res == FR_OK) {\n        res = DIR_READ_LABEL(&dj);   \n        if (res == FR_OK) {\n            if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {\n                dj.dir[XDIR_NumLabel] = (BYTE)di;    \n                mem_cpy(dj.dir + XDIR_Label, dirvn, 22);\n            } else {\n                if (di != 0) {\n                    mem_cpy(dj.dir, dirvn, 11);  \n                } else {\n                    dj.dir[DIR_Name] = DDEM;     \n                }\n            }\n            fs->wflag = 1;\n            res = sync_fs(fs);\n        } else {             \n            if (res == FR_NO_FILE) {\n                res = FR_OK;\n                if (di != 0) {   \n                    res = dir_alloc(&dj, 1);     \n                    if (res == FR_OK) {\n                        mem_set(dj.dir, 0, SZDIRE);  \n                        if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {\n                            dj.dir[XDIR_Type] = ET_VLABEL;   \n                            dj.dir[XDIR_NumLabel] = (BYTE)di;\n                            mem_cpy(dj.dir + XDIR_Label, dirvn, 22);\n                        } else {\n                            dj.dir[DIR_Attr] = AM_VOL;       \n                            mem_cpy(dj.dir, dirvn, 11);\n                        }\n                        fs->wflag = 1;\n                        res = sync_fs(fs);\n                    }\n                }\n            }\n        }\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n#endif  \n#endif  \n\n\n\n#if FF_USE_EXPAND && !FF_FS_READONLY\n \n \n \n\nFRESULT f_expand (\n    FIL* fp,         \n    FSIZE_t fsz,     \n    BYTE opt         \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD n, clst, stcl, scl, ncl, tcl, lclst;\n\n\n    res = validate(&fp->obj, &fs);       \n    if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);\n    if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);\n#if FF_FS_EXFAT\n    if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);  \n#endif\n    n = (DWORD)fs->csize * SS(fs);   \n    tcl = (DWORD)(fsz / n) + ((fsz & (n - 1)) ? 1 : 0);  \n    stcl = fs->last_clst; lclst = 0;\n    if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;\n\n#if FF_FS_EXFAT\n    if (fs->fs_type == FS_EXFAT) {\n        scl = find_bitmap(fs, stcl, tcl);            \n        if (scl == 0) res = FR_DENIED;               \n        if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;\n        if (res == FR_OK) {  \n            if (opt) {       \n                res = change_bitmap(fs, scl, tcl, 1);    \n                lclst = scl + tcl - 1;\n            } else {         \n                lclst = scl - 1;\n            }\n        }\n    } else\n#endif\n    {\n        scl = clst = stcl; ncl = 0;\n        for (;;) {   \n            n = get_fat(&fp->obj, clst);\n            if (++clst >= fs->n_fatent) clst = 2;\n            if (n == 1) { res = FR_INT_ERR; break; }\n            if (n == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }\n            if (n == 0) {    \n                if (++ncl == tcl) break;     \n            } else {\n                scl = clst; ncl = 0;         \n            }\n            if (clst == stcl) { res = FR_DENIED; break; }    \n        }\n        if (res == FR_OK) {  \n            if (opt) {       \n                for (clst = scl, n = tcl; n; clst++, n--) {  \n                    res = put_fat(fs, clst, (n == 1) ? 0xFFFFFFFF : clst + 1);\n                    if (res != FR_OK) break;\n                    lclst = clst;\n                }\n            } else {         \n                lclst = scl - 1;\n            }\n        }\n    }\n\n    if (res == FR_OK) {\n        fs->last_clst = lclst;       \n        if (opt) {   \n            fp->obj.sclust = scl;        \n            fp->obj.objsize = fsz;\n            if (FF_FS_EXFAT) fp->obj.stat = 2;   \n            fp->flag |= FA_MODIFIED;\n            if (fs->free_clst <= fs->n_fatent - 2) {     \n                fs->free_clst -= tcl;\n                fs->fsi_flag |= 1;\n            }\n        }\n    }\n\n    LEAVE_FF(fs, res);\n}\n\n#endif  \n\n\n\n#if FF_USE_FORWARD\n \n \n \n\nFRESULT f_forward (\n    FIL* fp,                         \n    UINT (*func)(const BYTE*,UINT),  \n    UINT btf,                        \n    UINT* bf                         \n)\n{\n    FRESULT res;\n    FATFS *fs;\n    DWORD clst, sect;\n    FSIZE_t remain;\n    UINT rcnt, csect;\n    BYTE *dbuf;\n\n\n    *bf = 0;     \n    res = validate(&fp->obj, &fs);       \n    if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);\n    if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);  \n\n    remain = fp->obj.objsize - fp->fptr;\n    if (btf > remain) btf = (UINT)remain;            \n\n    for ( ;  btf && (*func)(0, 0);                   \n        fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {\n        csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));     \n        if (fp->fptr % SS(fs) == 0) {                \n            if (csect == 0) {                        \n                clst = (fp->fptr == 0) ?             \n                    fp->obj.sclust : get_fat(&fp->obj, fp->clust);\n                if (clst <= 1) ABORT(fs, FR_INT_ERR);\n                if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);\n                fp->clust = clst;                    \n            }\n        }\n        sect = clst2sect(fs, fp->clust);             \n        if (sect == 0) ABORT(fs, FR_INT_ERR);\n        sect += csect;\n#if FF_FS_TINY\n        if (move_window(fs, sect) != FR_OK) ABORT(fs, FR_DISK_ERR);  \n        dbuf = fs->win;\n#else\n        if (fp->sect != sect) {      \n#if !FF_FS_READONLY\n            if (fp->flag & FA_DIRTY) {       \n                if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);\n                fp->flag &= (BYTE)~FA_DIRTY;\n            }\n#endif\n            if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);\n        }\n        dbuf = fp->buf;\n#endif\n        fp->sect = sect;\n        rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);     \n        if (rcnt > btf) rcnt = btf;                  \n        rcnt = (*func)(dbuf + ((UINT)fp->fptr % SS(fs)), rcnt);  \n        if (rcnt == 0) ABORT(fs, FR_INT_ERR);\n    }\n\n    LEAVE_FF(fs, FR_OK);\n}\n#endif  \n\n\n\n#if FF_USE_MKFS && !FF_FS_READONLY\n \n \n \n\nFRESULT f_mkfs (\n    FATFS *fs,\n    BYTE opt,            \n    DWORD au,            \n    void* work,          \n    UINT len             \n)\n{\n    const UINT n_fats = 1;       \n    const UINT n_rootdir = 512;  \n    static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};   \n    static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};     \n    BYTE fmt, sys, *buf, *pte, part; void *pdrv;\n    WORD ss;     \n    DWORD szb_buf, sz_buf, sz_blk, n_clst, pau, sect, nsect, n;\n    DWORD b_vol, b_fat, b_data;              \n    DWORD sz_vol, sz_rsv, sz_fat, sz_dir;    \n    UINT i;\n    DSTATUS stat;\n#if FF_USE_TRIM || FF_FS_EXFAT\n    DWORD tbl[3];\n#endif\n\n\n     \n    fs->fs_type = 0;     \n    pdrv = fs->drv;      \n    part = LD2PT(fs);    \n\n     \n    disk_ioctl(pdrv, IOCTL_INIT, &stat);\n    if (stat & STA_NOINIT) return FR_NOT_READY;\n    if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;\n    if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &sz_blk) != RES_OK || !sz_blk || sz_blk > 32768 || (sz_blk & (sz_blk - 1))) sz_blk = 1;     \n#if FF_MAX_SS != FF_MIN_SS       \n    if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &ss) != RES_OK) return FR_DISK_ERR;\n    if (ss > FF_MAX_SS || ss < FF_MIN_SS || (ss & (ss - 1))) return FR_DISK_ERR;\n#else\n    ss = FF_MAX_SS;\n#endif\n    if ((au != 0 && au < ss) || au > 0x1000000 || (au & (au - 1))) return FR_INVALID_PARAMETER;  \n    au /= ss;    \n\n     \n#if FF_USE_LFN == 3\n    if (!work) {     \n        for (szb_buf = MAX_MALLOC, buf = 0; szb_buf >= ss && (buf = ff_memalloc(szb_buf)) == 0; szb_buf /= 2) ;\n        sz_buf = szb_buf / ss;       \n    } else\n#endif\n    {\n        buf = (BYTE*)work;       \n        sz_buf = len / ss;       \n        szb_buf = sz_buf * ss;   \n    }\n    if (!buf || sz_buf == 0) return FR_NOT_ENOUGH_CORE;\n\n     \n    if (FF_MULTI_PARTITION && part != 0) {\n         \n        if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);   \n        if (ld_word(buf + BS_55AA) != 0xAA55) LEAVE_MKFS(FR_MKFS_ABORTED);   \n        pte = buf + (MBR_Table + (part - 1) * SZ_PTE);\n        if (pte[PTE_System] == 0) LEAVE_MKFS(FR_MKFS_ABORTED);   \n        b_vol = ld_dword(pte + PTE_StLba);       \n        sz_vol = ld_dword(pte + PTE_SizLba);     \n    } else {\n         \n        if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_vol) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n        b_vol = (opt & FM_SFD) ? 0 : 63;         \n        if (sz_vol < b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);\n        sz_vol -= b_vol;                         \n    }\n    if (sz_vol < 22) LEAVE_MKFS(FR_MKFS_ABORTED);   \n\n     \n    do {\n        if (FF_FS_EXFAT && (opt & FM_EXFAT)) {   \n            if ((opt & FM_ANY) == FM_EXFAT || sz_vol >= 0x4000000 || au > 128) {     \n                fmt = FS_EXFAT; break;\n            }\n        }\n        if (au > 128) LEAVE_MKFS(FR_INVALID_PARAMETER);  \n        if (opt & FM_FAT32) {    \n            if ((opt & FM_ANY) == FM_FAT32 || !(opt & FM_FAT)) {     \n                fmt = FS_FAT32; break;\n            }\n        }\n        if (!(opt & FM_FAT)) LEAVE_MKFS(FR_INVALID_PARAMETER);   \n        fmt = FS_FAT16;\n    } while (0);\n\n#if FF_FS_EXFAT\n    if (fmt == FS_EXFAT) {   \n        DWORD szb_bit, szb_case, sum, nb, cl;\n        WCHAR ch, si;\n        UINT j, st;\n        BYTE b;\n\n        if (sz_vol < 0x1000) LEAVE_MKFS(FR_MKFS_ABORTED);    \n#if FF_USE_TRIM\n        tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;     \n        disk_ioctl(pdrv, CTRL_TRIM, tbl);\n#endif\n         \n        if (au == 0) {   \n            au = 8;\n            if (sz_vol >= 0x80000) au = 64;      \n            if (sz_vol >= 0x4000000) au = 256;   \n        }\n        b_fat = b_vol + 32;                                      \n        sz_fat = ((sz_vol / au + 2) * 4 + ss - 1) / ss;          \n        b_data = (b_fat + sz_fat + sz_blk - 1) & ~(sz_blk - 1);  \n        if (b_data - b_vol >= sz_vol / 2) LEAVE_MKFS(FR_MKFS_ABORTED);  \n        n_clst = (sz_vol - (b_data - b_vol)) / au;               \n        if (n_clst <16) LEAVE_MKFS(FR_MKFS_ABORTED);             \n        if (n_clst > MAX_EXFAT) LEAVE_MKFS(FR_MKFS_ABORTED);     \n\n        szb_bit = (n_clst + 7) / 8;                      \n        tbl[0] = (szb_bit + au * ss - 1) / (au * ss);    \n\n         \n        sect = b_data + au * tbl[0];     \n        sum = 0;                         \n        st = 0; si = 0; i = 0; j = 0; szb_case = 0;\n        do {\n            switch (st) {\n            case 0:\n                ch = (WCHAR)ff_wtoupper(si);     \n                if (ch != si) {\n                    si++; break;         \n                }\n                for (j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;   \n                if (j >= 128) {\n                    ch = 0xFFFF; st = 2; break;  \n                }\n                st = 1;          \n                 \n            case 1:\n                ch = si++;       \n                if (--j == 0) st = 0;\n                break;\n\n            default:\n                ch = (WCHAR)j; si += (WCHAR)j;   \n                st = 0;\n            }\n            sum = xsum32(buf[i + 0] = (BYTE)ch, sum);        \n            sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);\n            i += 2; szb_case += 2;\n            if (si == 0 || i == szb_buf) {       \n                n = (i + ss - 1) / ss;\n                if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n                sect += n; i = 0;\n            }\n        } while (si);\n        tbl[1] = (szb_case + au * ss - 1) / (au * ss);   \n        tbl[2] = 1;                                      \n\n         \n        sect = b_data; nsect = (szb_bit + ss - 1) / ss;  \n        nb = tbl[0] + tbl[1] + tbl[2];                   \n        do {\n            mem_set(buf, 0, szb_buf);\n            for (i = 0; nb >= 8 && i < szb_buf; buf[i++] = 0xFF, nb -= 8) ;\n            for (b = 1; nb != 0 && i < szb_buf; buf[i] |= b, b <<= 1, nb--) ;\n            n = (nsect > sz_buf) ? sz_buf : nsect;       \n            if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n            sect += n; nsect -= n;\n        } while (nsect);\n\n         \n        sect = b_fat; nsect = sz_fat;    \n        j = nb = cl = 0;\n        do {\n            mem_set(buf, 0, szb_buf); i = 0;     \n            if (cl == 0) {   \n                st_dword(buf + i, 0xFFFFFFF8); i += 4; cl++;\n                st_dword(buf + i, 0xFFFFFFFF); i += 4; cl++;\n            }\n            do {             \n                while (nb != 0 && i < szb_buf) {             \n                    st_dword(buf + i, (nb > 1) ? cl + 1 : 0xFFFFFFFF);\n                    i += 4; cl++; nb--;\n                }\n                if (nb == 0 && j < 3) nb = tbl[j++];     \n            } while (nb != 0 && i < szb_buf);\n            n = (nsect > sz_buf) ? sz_buf : nsect;   \n            if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n            sect += n; nsect -= n;\n        } while (nsect);\n\n         \n        mem_set(buf, 0, szb_buf);\n        buf[SZDIRE * 0 + 0] = ET_VLABEL;         \n        buf[SZDIRE * 1 + 0] = ET_BITMAP;         \n        st_dword(buf + SZDIRE * 1 + 20, 2);              \n        st_dword(buf + SZDIRE * 1 + 24, szb_bit);        \n        buf[SZDIRE * 2 + 0] = ET_UPCASE;         \n        st_dword(buf + SZDIRE * 2 + 4, sum);             \n        st_dword(buf + SZDIRE * 2 + 20, 2 + tbl[0]);     \n        st_dword(buf + SZDIRE * 2 + 24, szb_case);       \n        sect = b_data + au * (tbl[0] + tbl[1]); nsect = au;  \n        do {     \n            n = (nsect > sz_buf) ? sz_buf : nsect;\n            if (disk_write(pdrv, buf, sect, n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n            mem_set(buf, 0, ss);\n            sect += n; nsect -= n;\n        } while (nsect);\n\n         \n        sect = b_vol;\n        for (n = 0; n < 2; n++) {\n             \n            mem_set(buf, 0, ss);\n            mem_cpy(buf + BS_JmpBoot, \"\\xEB\\x76\\x90\" \"EXFAT   \", 11);    \n            st_dword(buf + BPB_VolOfsEx, b_vol);                     \n            st_dword(buf + BPB_TotSecEx, sz_vol);                    \n            st_dword(buf + BPB_FatOfsEx, b_fat - b_vol);             \n            st_dword(buf + BPB_FatSzEx, sz_fat);                     \n            st_dword(buf + BPB_DataOfsEx, b_data - b_vol);           \n            st_dword(buf + BPB_NumClusEx, n_clst);                   \n            st_dword(buf + BPB_RootClusEx, 2 + tbl[0] + tbl[1]);     \n            st_dword(buf + BPB_VolIDEx, GET_FATTIME());              \n            st_word(buf + BPB_FSVerEx, 0x100);                       \n            for (buf[BPB_BytsPerSecEx] = 0, i = ss; i >>= 1; buf[BPB_BytsPerSecEx]++) ;  \n            for (buf[BPB_SecPerClusEx] = 0, i = au; i >>= 1; buf[BPB_SecPerClusEx]++) ;  \n            buf[BPB_NumFATsEx] = 1;                  \n            buf[BPB_DrvNumEx] = 0x80;                \n            st_word(buf + BS_BootCodeEx, 0xFEEB);    \n            st_word(buf + BS_55AA, 0xAA55);          \n            for (i = sum = 0; i < ss; i++) {         \n                if (i != BPB_VolFlagEx && i != BPB_VolFlagEx + 1 && i != BPB_PercInUseEx) sum = xsum32(buf[i], sum);\n            }\n            if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n             \n            mem_set(buf, 0, ss);\n            st_word(buf + ss - 2, 0xAA55);   \n            for (j = 1; j < 9; j++) {\n                for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;   \n                if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n            }\n             \n            mem_set(buf, 0, ss);\n            for ( ; j < 11; j++) {\n                for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;   \n                if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n            }\n             \n            for (i = 0; i < ss; i += 4) st_dword(buf + i, sum);      \n            if (disk_write(pdrv, buf, sect++, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n        }\n\n    } else\n#endif   \n    {    \n        do {\n            pau = au;\n             \n            if (fmt == FS_FAT32) {   \n                if (pau == 0) {  \n                    n = sz_vol / 0x20000;    \n                    for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;    \n                }\n                n_clst = sz_vol / pau;   \n                sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;     \n                sz_rsv = 32;     \n                sz_dir = 0;      \n                if (n_clst <= MAX_FAT16 || n_clst > MAX_FAT32) LEAVE_MKFS(FR_MKFS_ABORTED);\n            } else {                 \n                if (pau == 0) {  \n                    n = sz_vol / 0x1000;     \n                    for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;    \n                }\n                n_clst = sz_vol / pau;\n                if (n_clst > MAX_FAT12) {\n                    n = n_clst * 2 + 4;      \n                } else {\n                    fmt = FS_FAT12;\n                    n = (n_clst * 3 + 1) / 2 + 3;    \n                }\n                sz_fat = (n + ss - 1) / ss;      \n                sz_rsv = 1;                      \n                sz_dir = (DWORD)n_rootdir * SZDIRE / ss;     \n            }\n            b_fat = b_vol + sz_rsv;                      \n            b_data = b_fat + sz_fat * n_fats + sz_dir;   \n\n             \n            n = ((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data;    \n            if (fmt == FS_FAT32) {       \n                sz_rsv += n; b_fat += n;\n            } else {                     \n                sz_fat += n / n_fats;\n            }\n\n             \n            if (sz_vol < b_data + pau * 16 - b_vol) LEAVE_MKFS(FR_MKFS_ABORTED);     \n            n_clst = (sz_vol - sz_rsv - sz_fat * n_fats - sz_dir) / pau;\n            if (fmt == FS_FAT32) {\n                if (n_clst <= MAX_FAT16) {   \n                    if (au == 0 && (au = pau / 2) != 0) continue;    \n                    LEAVE_MKFS(FR_MKFS_ABORTED);\n                }\n            }\n            if (fmt == FS_FAT16) {\n                if (n_clst > MAX_FAT16) {    \n                    if (au == 0 && (pau * 2) <= 64) {\n                        au = pau * 2; continue;      \n                    }\n                    if ((opt & FM_FAT32)) {\n                        fmt = FS_FAT32; continue;    \n                    }\n                    if (au == 0 && (au = pau * 2) <= 128) continue;  \n                    LEAVE_MKFS(FR_MKFS_ABORTED);\n                }\n                if  (n_clst <= MAX_FAT12) {  \n                    if (au == 0 && (au = pau * 2) <= 128) continue;  \n                    LEAVE_MKFS(FR_MKFS_ABORTED);\n                }\n            }\n            if (fmt == FS_FAT12 && n_clst > MAX_FAT12) LEAVE_MKFS(FR_MKFS_ABORTED);  \n\n             \n            break;\n        } while (1);\n\n#if FF_USE_TRIM\n        tbl[0] = b_vol; tbl[1] = b_vol + sz_vol - 1;     \n        disk_ioctl(pdrv, CTRL_TRIM, tbl);\n#endif\n         \n        mem_set(buf, 0, ss);\n        mem_cpy(buf + BS_JmpBoot, \"\\xEB\\xFE\\x90\" \"MSDOS5.0\", 11); \n        st_word(buf + BPB_BytsPerSec, ss);               \n        buf[BPB_SecPerClus] = (BYTE)pau;                 \n        st_word(buf + BPB_RsvdSecCnt, (WORD)sz_rsv);     \n        buf[BPB_NumFATs] = (BYTE)n_fats;                 \n        st_word(buf + BPB_RootEntCnt, (WORD)((fmt == FS_FAT32) ? 0 : n_rootdir));    \n        if (sz_vol < 0x10000) {\n            st_word(buf + BPB_TotSec16, (WORD)sz_vol);   \n        } else {\n            st_dword(buf + BPB_TotSec32, sz_vol);        \n        }\n        buf[BPB_Media] = 0xF8;                           \n        st_word(buf + BPB_SecPerTrk, 63);                \n        st_word(buf + BPB_NumHeads, 255);                \n        st_dword(buf + BPB_HiddSec, b_vol);              \n        if (fmt == FS_FAT32) {\n            st_dword(buf + BS_VolID32, GET_FATTIME());   \n            st_dword(buf + BPB_FATSz32, sz_fat);         \n            st_dword(buf + BPB_RootClus32, 2);           \n            st_word(buf + BPB_FSInfo32, 1);              \n            st_word(buf + BPB_BkBootSec32, 6);           \n            buf[BS_DrvNum32] = 0x80;                     \n            buf[BS_BootSig32] = 0x29;                    \n            mem_cpy(buf + BS_VolLab32, \"NO NAME    \" \"FAT32   \", 19);    \n        } else {\n            st_dword(buf + BS_VolID, GET_FATTIME());     \n            st_word(buf + BPB_FATSz16, (WORD)sz_fat);    \n            buf[BS_DrvNum] = 0x80;                       \n            buf[BS_BootSig] = 0x29;                      \n            mem_cpy(buf + BS_VolLab, \"NO NAME    \" \"FAT     \", 19);  \n        }\n        st_word(buf + BS_55AA, 0xAA55);                  \n        if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);  \n\n         \n        if (fmt == FS_FAT32) {\n            disk_write(pdrv, buf, b_vol + 6, 1);         \n            mem_set(buf, 0, ss);\n            st_dword(buf + FSI_LeadSig, 0x41615252);\n            st_dword(buf + FSI_StrucSig, 0x61417272);\n            st_dword(buf + FSI_Free_Count, n_clst - 1);  \n            st_dword(buf + FSI_Nxt_Free, 2);             \n            st_word(buf + BS_55AA, 0xAA55);\n            disk_write(pdrv, buf, b_vol + 7, 1);         \n            disk_write(pdrv, buf, b_vol + 1, 1);         \n        }\n\n         \n        mem_set(buf, 0, (UINT)szb_buf);\n        sect = b_fat;        \n        for (i = 0; i < n_fats; i++) {           \n            if (fmt == FS_FAT32) {\n                st_dword(buf + 0, 0xFFFFFFF8);   \n                st_dword(buf + 4, 0xFFFFFFFF);   \n                st_dword(buf + 8, 0x0FFFFFFF);   \n            } else {\n                st_dword(buf + 0, (fmt == FS_FAT12) ? 0xFFFFF8 : 0xFFFFFFF8);    \n            }\n            nsect = sz_fat;      \n            do {     \n                n = (nsect > sz_buf) ? sz_buf : nsect;\n                if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n                mem_set(buf, 0, ss);\n                sect += n; nsect -= n;\n            } while (nsect);\n        }\n\n         \n        nsect = (fmt == FS_FAT32) ? pau : sz_dir;    \n        do {\n            n = (nsect > sz_buf) ? sz_buf : nsect;\n            if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n            sect += n; nsect -= n;\n        } while (nsect);\n    }\n\n     \n    if (FF_FS_EXFAT && fmt == FS_EXFAT) {\n        sys = 0x07;          \n    } else {\n        if (fmt == FS_FAT32) {\n            sys = 0x0C;      \n        } else {\n            if (sz_vol >= 0x10000) {\n                sys = 0x06;  \n            } else {\n                sys = (fmt == FS_FAT16) ? 0x04 : 0x01;   \n            }\n        }\n    }\n\n     \n    if (FF_MULTI_PARTITION && part != 0) {   \n         \n        if (disk_read(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);   \n        buf[MBR_Table + (part - 1) * SZ_PTE + PTE_System] = sys;         \n        if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);  \n    } else {                                 \n        if (!(opt & FM_SFD)) {   \n            mem_set(buf, 0, ss);\n            st_word(buf + BS_55AA, 0xAA55);      \n            pte = buf + MBR_Table;               \n            pte[PTE_Boot] = 0;                   \n            pte[PTE_StHead] = 1;                 \n            pte[PTE_StSec] = 1;                  \n            pte[PTE_StCyl] = 0;                  \n            pte[PTE_System] = sys;               \n            n = (b_vol + sz_vol) / (63 * 255);   \n            pte[PTE_EdHead] = 254;               \n            pte[PTE_EdSec] = (BYTE)(((n >> 2) & 0xC0) | 63);     \n            pte[PTE_EdCyl] = (BYTE)n;            \n            st_dword(pte + PTE_StLba, b_vol);    \n            st_dword(pte + PTE_SizLba, sz_vol);  \n            if (disk_write(pdrv, buf, 0, 1) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);  \n        }\n    }\n\n    if (disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) LEAVE_MKFS(FR_DISK_ERR);\n\n    LEAVE_MKFS(FR_OK);\n}\n\n\n\n#if FF_MULTI_PARTITION\n \n \n \n\nFRESULT f_fdisk (\n    void *pdrv,          \n    const DWORD* szt,    \n    void* work           \n)\n{\n    UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;\n    BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;\n    DSTATUS stat;\n    DWORD sz_disk, sz_part, s_part;\n    FRESULT res;\n\n\n    disk_ioctl(pdrv, IOCTL_INIT, &stat);\n    if (stat & STA_NOINIT) return FR_NOT_READY;\n    if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;\n    if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;\n\n    buf = (BYTE*)work;\n#if FF_USE_LFN == 3\n    if (!buf) buf = ff_memalloc(FF_MAX_SS);  \n#endif\n    if (!buf) return FR_NOT_ENOUGH_CORE;\n\n     \n    for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;\n    if (n == 256) n--;\n    e_hd = (BYTE)(n - 1);\n    sz_cyl = 63 * n;\n    tot_cyl = sz_disk / sz_cyl;\n\n     \n    mem_set(buf, 0, FF_MAX_SS);\n    p = buf + MBR_Table; b_cyl = 0;\n    for (i = 0; i < 4; i++, p += SZ_PTE) {\n        p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;  \n        if (p_cyl == 0) continue;\n        s_part = (DWORD)sz_cyl * b_cyl;\n        sz_part = (DWORD)sz_cyl * p_cyl;\n        if (i == 0) {    \n            s_hd = 1;\n            s_part += 63; sz_part -= 63;\n        } else {\n            s_hd = 0;\n        }\n        e_cyl = b_cyl + p_cyl - 1;   \n        if (e_cyl >= tot_cyl) LEAVE_MKFS(FR_INVALID_PARAMETER);\n\n         \n        p[1] = s_hd;                         \n        p[2] = (BYTE)(((b_cyl >> 2) & 0xC0) | 1);    \n        p[3] = (BYTE)b_cyl;                  \n        p[4] = 0x07;                         \n        p[5] = e_hd;                         \n        p[6] = (BYTE)(((e_cyl >> 2) & 0xC0) | 63);   \n        p[7] = (BYTE)e_cyl;                  \n        st_dword(p + 8, s_part);             \n        st_dword(p + 12, sz_part);           \n\n         \n        b_cyl += p_cyl;\n    }\n    st_word(p, 0xAA55);      \n\n     \n    res = (disk_write(pdrv, buf, 0, 1) == RES_OK && disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;\n    LEAVE_MKFS(res);\n}\n\n#endif  \n#endif  \n\n\n\n#if FF_CODE_PAGE == 0\n \n \n \n\nFRESULT f_setcp (\n    WORD cp      \n)\n{\n    static const WORD       validcp[] = {  437,   720,   737,   771,   775,   850,   852,   857,   860,   861,   862,   863,   864,   865,   866,   869,   932,   936,   949,   950, 0};\n    static const BYTE* const tables[] = {Ct437, Ct720, Ct737, Ct771, Ct775, Ct850, Ct852, Ct857, Ct860, Ct861, Ct862, Ct863, Ct864, Ct865, Ct866, Ct869, Dc932, Dc936, Dc949, Dc950, 0};\n    UINT i;\n\n\n    for (i = 0; validcp[i] != 0 && validcp[i] != cp; i++) ;  \n    if (validcp[i] != cp) return FR_INVALID_PARAMETER;   \n\n    CodePage = cp;\n    if (cp >= 900) {     \n        ExCvt = 0;\n        DbcTbl = tables[i];\n    } else {             \n        ExCvt = tables[i];\n        DbcTbl = 0;\n    }\n    return FR_OK;\n}\n#endif   \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}