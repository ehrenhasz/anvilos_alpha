{
  "module_name": "lfs1_util.h",
  "hash_id": "005f4fc3aec5c06d797db4dd64297f2d99ed2f435d4f2206f6c35d56c7039f01",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/littlefs/lfs1_util.h",
  "human_readable_source": " \n#ifndef LFS1_UTIL_H\n#define LFS1_UTIL_H\n\n\n\n\n\n\n\n#ifdef LFS1_CONFIG\n#define LFS1_STRINGIZE(x) LFS1_STRINGIZE2(x)\n#define LFS1_STRINGIZE2(x) #x\n#include LFS1_STRINGIZE(LFS1_CONFIG)\n#else\n\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n#ifndef LFS1_NO_MALLOC\n#include <stdlib.h>\n#endif\n#ifndef LFS1_NO_ASSERT\n#include <assert.h>\n#endif\n#if !defined(LFS1_NO_DEBUG) || !defined(LFS1_NO_WARN) || !defined(LFS1_NO_ERROR)\n#include <stdio.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n\n\n\n\n\n#ifndef LFS1_NO_DEBUG\n#define LFS1_DEBUG(fmt, ...) \\\n    printf(\"lfs1 debug:%d: \" fmt \"\\n\", __LINE__, __VA_ARGS__)\n#else\n#define LFS1_DEBUG(fmt, ...)\n#endif\n\n#ifndef LFS1_NO_WARN\n#define LFS1_WARN(fmt, ...) \\\n    printf(\"lfs1 warn:%d: \" fmt \"\\n\", __LINE__, __VA_ARGS__)\n#else\n#define LFS1_WARN(fmt, ...)\n#endif\n\n#ifndef LFS1_NO_ERROR\n#define LFS1_ERROR(fmt, ...) \\\n    printf(\"lfs1 error:%d: \" fmt \"\\n\", __LINE__, __VA_ARGS__)\n#else\n#define LFS1_ERROR(fmt, ...)\n#endif\n\n\n#ifndef LFS1_NO_ASSERT\n#define LFS1_ASSERT(test) assert(test)\n#else\n#define LFS1_ASSERT(test)\n#endif\n\n\n\n\n\n\n\nstatic inline uint32_t lfs1_max(uint32_t a, uint32_t b) {\n    return (a > b) ? a : b;\n}\n\nstatic inline uint32_t lfs1_min(uint32_t a, uint32_t b) {\n    return (a < b) ? a : b;\n}\n\n\nstatic inline uint32_t lfs1_npw2(uint32_t a) {\n#if !defined(LFS1_NO_INTRINSICS) && (defined(__GNUC__) || defined(__CC_ARM))\n    return 32 - __builtin_clz(a-1);\n#else\n    uint32_t r = 0;\n    uint32_t s;\n    a -= 1;\n    s = (a > 0xffff) << 4; a >>= s; r |= s;\n    s = (a > 0xff  ) << 3; a >>= s; r |= s;\n    s = (a > 0xf   ) << 2; a >>= s; r |= s;\n    s = (a > 0x3   ) << 1; a >>= s; r |= s;\n    return (r | (a >> 1)) + 1;\n#endif\n}\n\n\n\nstatic inline uint32_t lfs1_ctz(uint32_t a) {\n#if !defined(LFS1_NO_INTRINSICS) && defined(__GNUC__)\n    return __builtin_ctz(a);\n#else\n    return lfs1_npw2((a & -a) + 1) - 1;\n#endif\n}\n\n\nstatic inline uint32_t lfs1_popc(uint32_t a) {\n#if !defined(LFS1_NO_INTRINSICS) && (defined(__GNUC__) || defined(__CC_ARM))\n    return __builtin_popcount(a);\n#else\n    a = a - ((a >> 1) & 0x55555555);\n    a = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n    return (((a + (a >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n#endif\n}\n\n\n\nstatic inline int lfs1_scmp(uint32_t a, uint32_t b) {\n    return (int)(unsigned)(a - b);\n}\n\n\nstatic inline uint32_t lfs1_fromle32(uint32_t a) {\n#if !defined(LFS1_NO_INTRINSICS) && ( \\\n    (defined(  BYTE_ORDER  ) &&   BYTE_ORDER   ==   ORDER_LITTLE_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER  ) && __BYTE_ORDER   == __ORDER_LITTLE_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))\n    return a;\n#elif !defined(LFS1_NO_INTRINSICS) && ( \\\n    (defined(  BYTE_ORDER  ) &&   BYTE_ORDER   ==   ORDER_BIG_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER  ) && __BYTE_ORDER   == __ORDER_BIG_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))\n    return __builtin_bswap32(a);\n#else\n    return (((uint8_t*)&a)[0] <<  0) |\n           (((uint8_t*)&a)[1] <<  8) |\n           (((uint8_t*)&a)[2] << 16) |\n           (((uint8_t*)&a)[3] << 24);\n#endif\n}\n\n\nstatic inline uint32_t lfs1_tole32(uint32_t a) {\n    return lfs1_fromle32(a);\n}\n\n\nvoid lfs1_crc(uint32_t *crc, const void *buffer, size_t size);\n\n\nstatic inline void *lfs1_malloc(size_t size) {\n#ifndef LFS1_NO_MALLOC\n    return malloc(size);\n#else\n    (void)size;\n    return NULL;\n#endif\n}\n\n\nstatic inline void lfs1_free(void *p) {\n#ifndef LFS1_NO_MALLOC\n    free(p);\n#else\n    (void)p;\n#endif\n}\n\n\n#ifdef __cplusplus\n}  \n#endif\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}