{
  "module_name": "lfs2_util.h",
  "hash_id": "d5492384abfb3a7d939760ba9be0aca3b1816885caa4119a5f632cd089c636dc",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/littlefs/lfs2_util.h",
  "human_readable_source": " \n#ifndef LFS2_UTIL_H\n#define LFS2_UTIL_H\n\n\n\n\n\n\n\n#ifdef LFS2_CONFIG\n#define LFS2_STRINGIZE(x) LFS2_STRINGIZE2(x)\n#define LFS2_STRINGIZE2(x) #x\n#include LFS2_STRINGIZE(LFS2_CONFIG)\n#else\n\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <inttypes.h>\n\n#ifndef LFS2_NO_MALLOC\n#include <stdlib.h>\n#endif\n#ifndef LFS2_NO_ASSERT\n#include <assert.h>\n#endif\n#if !defined(LFS2_NO_DEBUG) || \\\n        !defined(LFS2_NO_WARN) || \\\n        !defined(LFS2_NO_ERROR) || \\\n        defined(LFS2_YES_TRACE)\n#include <stdio.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n\n\n\n\n\n\n#ifndef LFS2_TRACE\n#ifdef LFS2_YES_TRACE\n#define LFS2_TRACE_(fmt, ...) \\\n    printf(\"%s:%d:trace: \" fmt \"%s\\n\", __FILE__, __LINE__, __VA_ARGS__)\n#define LFS2_TRACE(...) LFS2_TRACE_(__VA_ARGS__, \"\")\n#else\n#define LFS2_TRACE(...)\n#endif\n#endif\n\n#ifndef LFS2_DEBUG\n#ifndef LFS2_NO_DEBUG\n#define LFS2_DEBUG_(fmt, ...) \\\n    printf(\"%s:%d:debug: \" fmt \"%s\\n\", __FILE__, __LINE__, __VA_ARGS__)\n#define LFS2_DEBUG(...) LFS2_DEBUG_(__VA_ARGS__, \"\")\n#else\n#define LFS2_DEBUG(...)\n#endif\n#endif\n\n#ifndef LFS2_WARN\n#ifndef LFS2_NO_WARN\n#define LFS2_WARN_(fmt, ...) \\\n    printf(\"%s:%d:warn: \" fmt \"%s\\n\", __FILE__, __LINE__, __VA_ARGS__)\n#define LFS2_WARN(...) LFS2_WARN_(__VA_ARGS__, \"\")\n#else\n#define LFS2_WARN(...)\n#endif\n#endif\n\n#ifndef LFS2_ERROR\n#ifndef LFS2_NO_ERROR\n#define LFS2_ERROR_(fmt, ...) \\\n    printf(\"%s:%d:error: \" fmt \"%s\\n\", __FILE__, __LINE__, __VA_ARGS__)\n#define LFS2_ERROR(...) LFS2_ERROR_(__VA_ARGS__, \"\")\n#else\n#define LFS2_ERROR(...)\n#endif\n#endif\n\n\n#ifndef LFS2_ASSERT\n#ifndef LFS2_NO_ASSERT\n#define LFS2_ASSERT(test) assert(test)\n#else\n#define LFS2_ASSERT(test)\n#endif\n#endif\n\n\n\n\n\n\n\nstatic inline uint32_t lfs2_max(uint32_t a, uint32_t b) {\n    return (a > b) ? a : b;\n}\n\nstatic inline uint32_t lfs2_min(uint32_t a, uint32_t b) {\n    return (a < b) ? a : b;\n}\n\n\nstatic inline uint32_t lfs2_aligndown(uint32_t a, uint32_t alignment) {\n    return a - (a % alignment);\n}\n\nstatic inline uint32_t lfs2_alignup(uint32_t a, uint32_t alignment) {\n    return lfs2_aligndown(a + alignment-1, alignment);\n}\n\n\nstatic inline uint32_t lfs2_npw2(uint32_t a) {\n#if !defined(LFS2_NO_INTRINSICS) && (defined(__GNUC__) || defined(__CC_ARM))\n    return 32 - __builtin_clz(a-1);\n#else\n    uint32_t r = 0;\n    uint32_t s;\n    a -= 1;\n    s = (a > 0xffff) << 4; a >>= s; r |= s;\n    s = (a > 0xff  ) << 3; a >>= s; r |= s;\n    s = (a > 0xf   ) << 2; a >>= s; r |= s;\n    s = (a > 0x3   ) << 1; a >>= s; r |= s;\n    return (r | (a >> 1)) + 1;\n#endif\n}\n\n\n\nstatic inline uint32_t lfs2_ctz(uint32_t a) {\n#if !defined(LFS2_NO_INTRINSICS) && defined(__GNUC__)\n    return __builtin_ctz(a);\n#else\n    return lfs2_npw2((a & -a) + 1) - 1;\n#endif\n}\n\n\nstatic inline uint32_t lfs2_popc(uint32_t a) {\n#if !defined(LFS2_NO_INTRINSICS) && (defined(__GNUC__) || defined(__CC_ARM))\n    return __builtin_popcount(a);\n#else\n    a = a - ((a >> 1) & 0x55555555);\n    a = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n    return (((a + (a >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n#endif\n}\n\n\n\nstatic inline int lfs2_scmp(uint32_t a, uint32_t b) {\n    return (int)(unsigned)(a - b);\n}\n\n\nstatic inline uint32_t lfs2_fromle32(uint32_t a) {\n#if (defined(  BYTE_ORDER  ) && defined(  ORDER_LITTLE_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_LITTLE_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER  ) && defined(__ORDER_LITTLE_ENDIAN  ) && __BYTE_ORDER   == __ORDER_LITTLE_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n    return a;\n#elif !defined(LFS2_NO_INTRINSICS) && ( \\\n    (defined(  BYTE_ORDER  ) && defined(  ORDER_BIG_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_BIG_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER  ) && defined(__ORDER_BIG_ENDIAN  ) && __BYTE_ORDER   == __ORDER_BIG_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))\n    return __builtin_bswap32(a);\n#else\n    return (((uint8_t*)&a)[0] <<  0) |\n           (((uint8_t*)&a)[1] <<  8) |\n           (((uint8_t*)&a)[2] << 16) |\n           (((uint8_t*)&a)[3] << 24);\n#endif\n}\n\nstatic inline uint32_t lfs2_tole32(uint32_t a) {\n    return lfs2_fromle32(a);\n}\n\n\nstatic inline uint32_t lfs2_frombe32(uint32_t a) {\n#if !defined(LFS2_NO_INTRINSICS) && ( \\\n    (defined(  BYTE_ORDER  ) && defined(  ORDER_LITTLE_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_LITTLE_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER  ) && defined(__ORDER_LITTLE_ENDIAN  ) && __BYTE_ORDER   == __ORDER_LITTLE_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))\n    return __builtin_bswap32(a);\n#elif (defined(  BYTE_ORDER  ) && defined(  ORDER_BIG_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_BIG_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER  ) && defined(__ORDER_BIG_ENDIAN  ) && __BYTE_ORDER   == __ORDER_BIG_ENDIAN  ) || \\\n    (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n    return a;\n#else\n    return (((uint8_t*)&a)[0] << 24) |\n           (((uint8_t*)&a)[1] << 16) |\n           (((uint8_t*)&a)[2] <<  8) |\n           (((uint8_t*)&a)[3] <<  0);\n#endif\n}\n\nstatic inline uint32_t lfs2_tobe32(uint32_t a) {\n    return lfs2_frombe32(a);\n}\n\n\nuint32_t lfs2_crc(uint32_t crc, const void *buffer, size_t size);\n\n\n\nstatic inline void *lfs2_malloc(size_t size) {\n#ifndef LFS2_NO_MALLOC\n    return malloc(size);\n#else\n    (void)size;\n    return NULL;\n#endif\n}\n\n\nstatic inline void lfs2_free(void *p) {\n#ifndef LFS2_NO_MALLOC\n    free(p);\n#else\n    (void)p;\n#endif\n}\n\n\n#ifdef __cplusplus\n}  \n#endif\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}