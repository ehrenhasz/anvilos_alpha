{
  "module_name": "lfs1.c",
  "hash_id": "6b0b90513708d7dbd3581273c179e813c1b73d14c857f12623f5ee9ba57bba4c",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/littlefs/lfs1.c",
  "human_readable_source": " \n#include \"lfs1.h\"\n#include \"lfs1_util.h\"\n\n#include <inttypes.h>\n\n\n\nstatic int lfs1_cache_read(lfs1_t *lfs1, lfs1_cache_t *rcache,\n        const lfs1_cache_t *pcache, lfs1_block_t block,\n        lfs1_off_t off, void *buffer, lfs1_size_t size) {\n    uint8_t *data = buffer;\n    LFS1_ASSERT(block < lfs1->cfg->block_count);\n\n    while (size > 0) {\n        if (pcache && block == pcache->block && off >= pcache->off &&\n                off < pcache->off + lfs1->cfg->prog_size) {\n            \n            lfs1_size_t diff = lfs1_min(size,\n                    lfs1->cfg->prog_size - (off-pcache->off));\n            memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        if (block == rcache->block && off >= rcache->off &&\n                off < rcache->off + lfs1->cfg->read_size) {\n            \n            lfs1_size_t diff = lfs1_min(size,\n                    lfs1->cfg->read_size - (off-rcache->off));\n            memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        if (off % lfs1->cfg->read_size == 0 && size >= lfs1->cfg->read_size) {\n            \n            lfs1_size_t diff = size - (size % lfs1->cfg->read_size);\n            int err = lfs1->cfg->read(lfs1->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        \n        rcache->block = block;\n        rcache->off = off - (off % lfs1->cfg->read_size);\n        int err = lfs1->cfg->read(lfs1->cfg, rcache->block,\n                rcache->off, rcache->buffer, lfs1->cfg->read_size);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\nstatic int lfs1_cache_cmp(lfs1_t *lfs1, lfs1_cache_t *rcache,\n        const lfs1_cache_t *pcache, lfs1_block_t block,\n        lfs1_off_t off, const void *buffer, lfs1_size_t size) {\n    const uint8_t *data = buffer;\n\n    for (lfs1_off_t i = 0; i < size; i++) {\n        uint8_t c;\n        int err = lfs1_cache_read(lfs1, rcache, pcache,\n                block, off+i, &c, 1);\n        if (err) {\n            return err;\n        }\n\n        if (c != data[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nstatic int lfs1_cache_crc(lfs1_t *lfs1, lfs1_cache_t *rcache,\n        const lfs1_cache_t *pcache, lfs1_block_t block,\n        lfs1_off_t off, lfs1_size_t size, uint32_t *crc) {\n    for (lfs1_off_t i = 0; i < size; i++) {\n        uint8_t c;\n        int err = lfs1_cache_read(lfs1, rcache, pcache,\n                block, off+i, &c, 1);\n        if (err) {\n            return err;\n        }\n\n        lfs1_crc(crc, &c, 1);\n    }\n\n    return 0;\n}\n\nstatic inline void lfs1_cache_drop(lfs1_t *lfs1, lfs1_cache_t *rcache) {\n    \n    \n    (void)lfs1;\n    rcache->block = 0xffffffff;\n}\n\nstatic inline void lfs1_cache_zero(lfs1_t *lfs1, lfs1_cache_t *pcache) {\n    \n    memset(pcache->buffer, 0xff, lfs1->cfg->prog_size);\n    pcache->block = 0xffffffff;\n}\n\nstatic int lfs1_cache_flush(lfs1_t *lfs1,\n        lfs1_cache_t *pcache, lfs1_cache_t *rcache) {\n    if (pcache->block != 0xffffffff) {\n        int err = lfs1->cfg->prog(lfs1->cfg, pcache->block,\n                pcache->off, pcache->buffer, lfs1->cfg->prog_size);\n        if (err) {\n            return err;\n        }\n\n        if (rcache) {\n            int res = lfs1_cache_cmp(lfs1, rcache, NULL, pcache->block,\n                    pcache->off, pcache->buffer, lfs1->cfg->prog_size);\n            if (res < 0) {\n                return res;\n            }\n\n            if (!res) {\n                return LFS1_ERR_CORRUPT;\n            }\n        }\n\n        lfs1_cache_zero(lfs1, pcache);\n    }\n\n    return 0;\n}\n\nstatic int lfs1_cache_prog(lfs1_t *lfs1, lfs1_cache_t *pcache,\n        lfs1_cache_t *rcache, lfs1_block_t block,\n        lfs1_off_t off, const void *buffer, lfs1_size_t size) {\n    const uint8_t *data = buffer;\n    LFS1_ASSERT(block < lfs1->cfg->block_count);\n\n    while (size > 0) {\n        if (block == pcache->block && off >= pcache->off &&\n                off < pcache->off + lfs1->cfg->prog_size) {\n            \n            lfs1_size_t diff = lfs1_min(size,\n                    lfs1->cfg->prog_size - (off-pcache->off));\n            memcpy(&pcache->buffer[off-pcache->off], data, diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n\n            if (off % lfs1->cfg->prog_size == 0) {\n                \n                int err = lfs1_cache_flush(lfs1, pcache, rcache);\n                if (err) {\n                    return err;\n                }\n            }\n\n            continue;\n        }\n\n        \n        \n        LFS1_ASSERT(pcache->block == 0xffffffff);\n\n        if (off % lfs1->cfg->prog_size == 0 &&\n                size >= lfs1->cfg->prog_size) {\n            \n            lfs1_size_t diff = size - (size % lfs1->cfg->prog_size);\n            int err = lfs1->cfg->prog(lfs1->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            if (rcache) {\n                int res = lfs1_cache_cmp(lfs1, rcache, NULL,\n                        block, off, data, diff);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (!res) {\n                    return LFS1_ERR_CORRUPT;\n                }\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        \n        pcache->block = block;\n        pcache->off = off - (off % lfs1->cfg->prog_size);\n    }\n\n    return 0;\n}\n\n\n\nstatic int lfs1_bd_read(lfs1_t *lfs1, lfs1_block_t block,\n        lfs1_off_t off, void *buffer, lfs1_size_t size) {\n    \n    \n    return lfs1_cache_read(lfs1, &lfs1->rcache, NULL,\n            block, off, buffer, size);\n}\n\nstatic int lfs1_bd_prog(lfs1_t *lfs1, lfs1_block_t block,\n        lfs1_off_t off, const void *buffer, lfs1_size_t size) {\n    return lfs1_cache_prog(lfs1, &lfs1->pcache, NULL,\n            block, off, buffer, size);\n}\n\nstatic int lfs1_bd_cmp(lfs1_t *lfs1, lfs1_block_t block,\n        lfs1_off_t off, const void *buffer, lfs1_size_t size) {\n    return lfs1_cache_cmp(lfs1, &lfs1->rcache, NULL, block, off, buffer, size);\n}\n\nstatic int lfs1_bd_crc(lfs1_t *lfs1, lfs1_block_t block,\n        lfs1_off_t off, lfs1_size_t size, uint32_t *crc) {\n    return lfs1_cache_crc(lfs1, &lfs1->rcache, NULL, block, off, size, crc);\n}\n\nstatic int lfs1_bd_erase(lfs1_t *lfs1, lfs1_block_t block) {\n    return lfs1->cfg->erase(lfs1->cfg, block);\n}\n\nstatic int lfs1_bd_sync(lfs1_t *lfs1) {\n    lfs1_cache_drop(lfs1, &lfs1->rcache);\n\n    int err = lfs1_cache_flush(lfs1, &lfs1->pcache, NULL);\n    if (err) {\n        return err;\n    }\n\n    return lfs1->cfg->sync(lfs1->cfg);\n}\n\n\n\nint lfs1_traverse(lfs1_t *lfs1, int (*cb)(void*, lfs1_block_t), void *data);\nstatic int lfs1_pred(lfs1_t *lfs1, const lfs1_block_t dir[2], lfs1_dir_t *pdir);\nstatic int lfs1_parent(lfs1_t *lfs1, const lfs1_block_t dir[2],\n        lfs1_dir_t *parent, lfs1_entry_t *entry);\nstatic int lfs1_moved(lfs1_t *lfs1, const void *e);\nstatic int lfs1_relocate(lfs1_t *lfs1,\n        const lfs1_block_t oldpair[2], const lfs1_block_t newpair[2]);\nint lfs1_deorphan(lfs1_t *lfs1);\n\n\n\nstatic int lfs1_alloc_lookahead(void *p, lfs1_block_t block) {\n    lfs1_t *lfs1 = p;\n\n    lfs1_block_t off = ((block - lfs1->free.off)\n            + lfs1->cfg->block_count) % lfs1->cfg->block_count;\n\n    if (off < lfs1->free.size) {\n        lfs1->free.buffer[off / 32] |= 1U << (off % 32);\n    }\n\n    return 0;\n}\n\nstatic int lfs1_alloc(lfs1_t *lfs1, lfs1_block_t *block) {\n    while (true) {\n        while (lfs1->free.i != lfs1->free.size) {\n            lfs1_block_t off = lfs1->free.i;\n            lfs1->free.i += 1;\n            lfs1->free.ack -= 1;\n\n            if (!(lfs1->free.buffer[off / 32] & (1U << (off % 32)))) {\n                \n                *block = (lfs1->free.off + off) % lfs1->cfg->block_count;\n\n                \n                \n                while (lfs1->free.i != lfs1->free.size &&\n                        (lfs1->free.buffer[lfs1->free.i / 32]\n                            & (1U << (lfs1->free.i % 32)))) {\n                    lfs1->free.i += 1;\n                    lfs1->free.ack -= 1;\n                }\n\n                return 0;\n            }\n        }\n\n        \n        if (lfs1->free.ack == 0) {\n            LFS1_WARN(\"No more free space %\" PRIu32,\n                    lfs1->free.i + lfs1->free.off);\n            return LFS1_ERR_NOSPC;\n        }\n\n        lfs1->free.off = (lfs1->free.off + lfs1->free.size)\n                % lfs1->cfg->block_count;\n        lfs1->free.size = lfs1_min(lfs1->cfg->lookahead, lfs1->free.ack);\n        lfs1->free.i = 0;\n\n        \n        memset(lfs1->free.buffer, 0, lfs1->cfg->lookahead/8);\n        int err = lfs1_traverse(lfs1, lfs1_alloc_lookahead, lfs1);\n        if (err) {\n            return err;\n        }\n    }\n}\n\nstatic void lfs1_alloc_ack(lfs1_t *lfs1) {\n    lfs1->free.ack = lfs1->cfg->block_count;\n}\n\n\n\nstatic void lfs1_dir_fromle32(struct lfs1_disk_dir *d) {\n    d->rev     = lfs1_fromle32(d->rev);\n    d->size    = lfs1_fromle32(d->size);\n    d->tail[0] = lfs1_fromle32(d->tail[0]);\n    d->tail[1] = lfs1_fromle32(d->tail[1]);\n}\n\nstatic void lfs1_dir_tole32(struct lfs1_disk_dir *d) {\n    d->rev     = lfs1_tole32(d->rev);\n    d->size    = lfs1_tole32(d->size);\n    d->tail[0] = lfs1_tole32(d->tail[0]);\n    d->tail[1] = lfs1_tole32(d->tail[1]);\n}\n\nstatic void lfs1_entry_fromle32(struct lfs1_disk_entry *d) {\n    d->u.dir[0] = lfs1_fromle32(d->u.dir[0]);\n    d->u.dir[1] = lfs1_fromle32(d->u.dir[1]);\n}\n\nstatic void lfs1_entry_tole32(struct lfs1_disk_entry *d) {\n    d->u.dir[0] = lfs1_tole32(d->u.dir[0]);\n    d->u.dir[1] = lfs1_tole32(d->u.dir[1]);\n}\n\nstatic void lfs1_superblock_fromle32(struct lfs1_disk_superblock *d) {\n    d->root[0]     = lfs1_fromle32(d->root[0]);\n    d->root[1]     = lfs1_fromle32(d->root[1]);\n    d->block_size  = lfs1_fromle32(d->block_size);\n    d->block_count = lfs1_fromle32(d->block_count);\n    d->version     = lfs1_fromle32(d->version);\n}\n\nstatic void lfs1_superblock_tole32(struct lfs1_disk_superblock *d) {\n    d->root[0]     = lfs1_tole32(d->root[0]);\n    d->root[1]     = lfs1_tole32(d->root[1]);\n    d->block_size  = lfs1_tole32(d->block_size);\n    d->block_count = lfs1_tole32(d->block_count);\n    d->version     = lfs1_tole32(d->version);\n}\n\n\n\nstatic inline void lfs1_pairswap(lfs1_block_t pair[2]) {\n    lfs1_block_t t = pair[0];\n    pair[0] = pair[1];\n    pair[1] = t;\n}\n\nstatic inline bool lfs1_pairisnull(const lfs1_block_t pair[2]) {\n    return pair[0] == 0xffffffff || pair[1] == 0xffffffff;\n}\n\nstatic inline int lfs1_paircmp(\n        const lfs1_block_t paira[2],\n        const lfs1_block_t pairb[2]) {\n    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||\n             paira[0] == pairb[1] || paira[1] == pairb[0]);\n}\n\nstatic inline bool lfs1_pairsync(\n        const lfs1_block_t paira[2],\n        const lfs1_block_t pairb[2]) {\n    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||\n           (paira[0] == pairb[1] && paira[1] == pairb[0]);\n}\n\nstatic inline lfs1_size_t lfs1_entry_size(const lfs1_entry_t *entry) {\n    return 4 + entry->d.elen + entry->d.alen + entry->d.nlen;\n}\n\nstatic int lfs1_dir_alloc(lfs1_t *lfs1, lfs1_dir_t *dir) {\n    \n    for (int i = 0; i < 2; i++) {\n        int err = lfs1_alloc(lfs1, &dir->pair[i]);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    \n    int err = lfs1_bd_read(lfs1, dir->pair[0], 0, &dir->d.rev, 4);\n    if (err && err != LFS1_ERR_CORRUPT) {\n        return err;\n    }\n\n    if (err != LFS1_ERR_CORRUPT) {\n        dir->d.rev = lfs1_fromle32(dir->d.rev);\n    }\n\n    \n    dir->d.rev += 1;\n    dir->d.size = sizeof(dir->d)+4;\n    dir->d.tail[0] = 0xffffffff;\n    dir->d.tail[1] = 0xffffffff;\n    dir->off = sizeof(dir->d);\n\n    \n    return 0;\n}\n\nstatic int lfs1_dir_fetch(lfs1_t *lfs1,\n        lfs1_dir_t *dir, const lfs1_block_t pair[2]) {\n    \n    const lfs1_block_t tpair[2] = {pair[0], pair[1]};\n    bool valid = false;\n\n    \n    for (int i = 0; i < 2; i++) {\n        struct lfs1_disk_dir test;\n        int err = lfs1_bd_read(lfs1, tpair[i], 0, &test, sizeof(test));\n        lfs1_dir_fromle32(&test);\n        if (err) {\n            if (err == LFS1_ERR_CORRUPT) {\n                continue;\n            }\n            return err;\n        }\n\n        if (valid && lfs1_scmp(test.rev, dir->d.rev) < 0) {\n            continue;\n        }\n\n        if ((0x7fffffff & test.size) < sizeof(test)+4 ||\n            (0x7fffffff & test.size) > lfs1->cfg->block_size) {\n            continue;\n        }\n\n        uint32_t crc = 0xffffffff;\n        lfs1_dir_tole32(&test);\n        lfs1_crc(&crc, &test, sizeof(test));\n        lfs1_dir_fromle32(&test);\n        err = lfs1_bd_crc(lfs1, tpair[i], sizeof(test),\n                (0x7fffffff & test.size) - sizeof(test), &crc);\n        if (err) {\n            if (err == LFS1_ERR_CORRUPT) {\n                continue;\n            }\n            return err;\n        }\n\n        if (crc != 0) {\n            continue;\n        }\n\n        valid = true;\n\n        \n        dir->pair[0] = tpair[(i+0) % 2];\n        dir->pair[1] = tpair[(i+1) % 2];\n        dir->off = sizeof(dir->d);\n        dir->d = test;\n    }\n\n    if (!valid) {\n        LFS1_ERROR(\"Corrupted dir pair at %\" PRIu32 \" %\" PRIu32 ,\n                tpair[0], tpair[1]);\n        return LFS1_ERR_CORRUPT;\n    }\n\n    return 0;\n}\n\nstruct lfs1_region {\n    lfs1_off_t oldoff;\n    lfs1_size_t oldlen;\n    const void *newdata;\n    lfs1_size_t newlen;\n};\n\nstatic int lfs1_dir_commit(lfs1_t *lfs1, lfs1_dir_t *dir,\n        const struct lfs1_region *regions, int count) {\n    \n    dir->d.rev += 1;\n\n    \n    lfs1_pairswap(dir->pair);\n    for (int i = 0; i < count; i++) {\n        dir->d.size += regions[i].newlen - regions[i].oldlen;\n    }\n\n    const lfs1_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};\n    bool relocated = false;\n\n    while (true) {\n        if (true) {\n            int err = lfs1_bd_erase(lfs1, dir->pair[0]);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            uint32_t crc = 0xffffffff;\n            lfs1_dir_tole32(&dir->d);\n            lfs1_crc(&crc, &dir->d, sizeof(dir->d));\n            err = lfs1_bd_prog(lfs1, dir->pair[0], 0, &dir->d, sizeof(dir->d));\n            lfs1_dir_fromle32(&dir->d);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            int i = 0;\n            lfs1_off_t oldoff = sizeof(dir->d);\n            lfs1_off_t newoff = sizeof(dir->d);\n            while (newoff < (0x7fffffff & dir->d.size)-4) {\n                if (i < count && regions[i].oldoff == oldoff) {\n                    lfs1_crc(&crc, regions[i].newdata, regions[i].newlen);\n                    err = lfs1_bd_prog(lfs1, dir->pair[0],\n                            newoff, regions[i].newdata, regions[i].newlen);\n                    if (err) {\n                        if (err == LFS1_ERR_CORRUPT) {\n                            goto relocate;\n                        }\n                        return err;\n                    }\n\n                    oldoff += regions[i].oldlen;\n                    newoff += regions[i].newlen;\n                    i += 1;\n                } else {\n                    uint8_t data;\n                    err = lfs1_bd_read(lfs1, oldpair[1], oldoff, &data, 1);\n                    if (err) {\n                        return err;\n                    }\n\n                    lfs1_crc(&crc, &data, 1);\n                    err = lfs1_bd_prog(lfs1, dir->pair[0], newoff, &data, 1);\n                    if (err) {\n                        if (err == LFS1_ERR_CORRUPT) {\n                            goto relocate;\n                        }\n                        return err;\n                    }\n\n                    oldoff += 1;\n                    newoff += 1;\n                }\n            }\n\n            crc = lfs1_tole32(crc);\n            err = lfs1_bd_prog(lfs1, dir->pair[0], newoff, &crc, 4);\n            crc = lfs1_fromle32(crc);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            err = lfs1_bd_sync(lfs1);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            \n            uint32_t ncrc = 0xffffffff;\n            err = lfs1_bd_crc(lfs1, dir->pair[0], 0,\n                    (0x7fffffff & dir->d.size)-4, &ncrc);\n            if (err) {\n                return err;\n            }\n\n            if (ncrc != crc) {\n                goto relocate;\n            }\n        }\n\n        break;\nrelocate:\n        \n        LFS1_DEBUG(\"Bad block at %\" PRIu32, dir->pair[0]);\n\n        \n        relocated = true;\n        lfs1_cache_drop(lfs1, &lfs1->pcache);\n\n        \n        if (lfs1_paircmp(oldpair, (const lfs1_block_t[2]){0, 1}) == 0) {\n            LFS1_WARN(\"Superblock %\" PRIu32 \" has become unwritable\",\n                    oldpair[0]);\n            return LFS1_ERR_CORRUPT;\n        }\n\n        \n        int err = lfs1_alloc(lfs1, &dir->pair[0]);\n        if (err) {\n            return err;\n        }\n    }\n\n    if (relocated) {\n        \n        LFS1_DEBUG(\"Relocating %\" PRIu32 \" %\" PRIu32 \" to %\" PRIu32 \" %\" PRIu32,\n                oldpair[0], oldpair[1], dir->pair[0], dir->pair[1]);\n        int err = lfs1_relocate(lfs1, oldpair, dir->pair);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    for (lfs1_dir_t *d = lfs1->dirs; d; d = d->next) {\n        if (lfs1_paircmp(d->pair, dir->pair) == 0) {\n            d->pair[0] = dir->pair[0];\n            d->pair[1] = dir->pair[1];\n        }\n    }\n\n    return 0;\n}\n\nstatic int lfs1_dir_update(lfs1_t *lfs1, lfs1_dir_t *dir,\n        lfs1_entry_t *entry, const void *data) {\n    lfs1_entry_tole32(&entry->d);\n    int err = lfs1_dir_commit(lfs1, dir, (struct lfs1_region[]){\n            {entry->off, sizeof(entry->d), &entry->d, sizeof(entry->d)},\n            {entry->off+sizeof(entry->d), entry->d.nlen, data, entry->d.nlen}\n        }, data ? 2 : 1);\n    lfs1_entry_fromle32(&entry->d);\n    return err;\n}\n\nstatic int lfs1_dir_append(lfs1_t *lfs1, lfs1_dir_t *dir,\n        lfs1_entry_t *entry, const void *data) {\n    \n    while (true) {\n        if (dir->d.size + lfs1_entry_size(entry) <= lfs1->cfg->block_size) {\n            entry->off = dir->d.size - 4;\n\n            lfs1_entry_tole32(&entry->d);\n            int err = lfs1_dir_commit(lfs1, dir, (struct lfs1_region[]){\n                    {entry->off, 0, &entry->d, sizeof(entry->d)},\n                    {entry->off, 0, data, entry->d.nlen}\n                }, 2);\n            lfs1_entry_fromle32(&entry->d);\n            return err;\n        }\n\n        \n        if (!(0x80000000 & dir->d.size)) {\n            lfs1_dir_t olddir = *dir;\n            int err = lfs1_dir_alloc(lfs1, dir);\n            if (err) {\n                return err;\n            }\n\n            dir->d.tail[0] = olddir.d.tail[0];\n            dir->d.tail[1] = olddir.d.tail[1];\n            entry->off = dir->d.size - 4;\n            lfs1_entry_tole32(&entry->d);\n            err = lfs1_dir_commit(lfs1, dir, (struct lfs1_region[]){\n                    {entry->off, 0, &entry->d, sizeof(entry->d)},\n                    {entry->off, 0, data, entry->d.nlen}\n                }, 2);\n            lfs1_entry_fromle32(&entry->d);\n            if (err) {\n                return err;\n            }\n\n            olddir.d.size |= 0x80000000;\n            olddir.d.tail[0] = dir->pair[0];\n            olddir.d.tail[1] = dir->pair[1];\n            return lfs1_dir_commit(lfs1, &olddir, NULL, 0);\n        }\n\n        int err = lfs1_dir_fetch(lfs1, dir, dir->d.tail);\n        if (err) {\n            return err;\n        }\n    }\n}\n\nstatic int lfs1_dir_remove(lfs1_t *lfs1, lfs1_dir_t *dir, lfs1_entry_t *entry) {\n    \n    if ((dir->d.size & 0x7fffffff) == sizeof(dir->d)+4\n            + lfs1_entry_size(entry)) {\n        lfs1_dir_t pdir;\n        int res = lfs1_pred(lfs1, dir->pair, &pdir);\n        if (res < 0) {\n            return res;\n        }\n\n        if (pdir.d.size & 0x80000000) {\n            pdir.d.size &= dir->d.size | 0x7fffffff;\n            pdir.d.tail[0] = dir->d.tail[0];\n            pdir.d.tail[1] = dir->d.tail[1];\n            return lfs1_dir_commit(lfs1, &pdir, NULL, 0);\n        }\n    }\n\n    \n    int err = lfs1_dir_commit(lfs1, dir, (struct lfs1_region[]){\n            {entry->off, lfs1_entry_size(entry), NULL, 0},\n        }, 1);\n    if (err) {\n        return err;\n    }\n\n    \n    for (lfs1_file_t *f = lfs1->files; f; f = f->next) {\n        if (lfs1_paircmp(f->pair, dir->pair) == 0) {\n            if (f->poff == entry->off) {\n                f->pair[0] = 0xffffffff;\n                f->pair[1] = 0xffffffff;\n            } else if (f->poff > entry->off) {\n                f->poff -= lfs1_entry_size(entry);\n            }\n        }\n    }\n\n    for (lfs1_dir_t *d = lfs1->dirs; d; d = d->next) {\n        if (lfs1_paircmp(d->pair, dir->pair) == 0) {\n            if (d->off > entry->off) {\n                d->off -= lfs1_entry_size(entry);\n                d->pos -= lfs1_entry_size(entry);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int lfs1_dir_next(lfs1_t *lfs1, lfs1_dir_t *dir, lfs1_entry_t *entry) {\n    while (dir->off + sizeof(entry->d) > (0x7fffffff & dir->d.size)-4) {\n        if (!(0x80000000 & dir->d.size)) {\n            entry->off = dir->off;\n            return LFS1_ERR_NOENT;\n        }\n\n        int err = lfs1_dir_fetch(lfs1, dir, dir->d.tail);\n        if (err) {\n            return err;\n        }\n\n        dir->off = sizeof(dir->d);\n        dir->pos += sizeof(dir->d) + 4;\n    }\n\n    int err = lfs1_bd_read(lfs1, dir->pair[0], dir->off,\n            &entry->d, sizeof(entry->d));\n    lfs1_entry_fromle32(&entry->d);\n    if (err) {\n        return err;\n    }\n\n    entry->off = dir->off;\n    dir->off += lfs1_entry_size(entry);\n    dir->pos += lfs1_entry_size(entry);\n    return 0;\n}\n\nstatic int lfs1_dir_find(lfs1_t *lfs1, lfs1_dir_t *dir,\n        lfs1_entry_t *entry, const char **path) {\n    const char *pathname = *path;\n    size_t pathlen;\n    entry->d.type = LFS1_TYPE_DIR;\n    entry->d.elen = sizeof(entry->d) - 4;\n    entry->d.alen = 0;\n    entry->d.nlen = 0;\n    entry->d.u.dir[0] = lfs1->root[0];\n    entry->d.u.dir[1] = lfs1->root[1];\n\n    while (true) {\nnextname:\n        \n        pathname += strspn(pathname, \"/\");\n        pathlen = strcspn(pathname, \"/\");\n\n        \n        if ((pathlen == 1 && memcmp(pathname, \".\", 1) == 0) ||\n            (pathlen == 2 && memcmp(pathname, \"..\", 2) == 0)) {\n            pathname += pathlen;\n            goto nextname;\n        }\n\n        \n        const char *suffix = pathname + pathlen;\n        size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    pathname = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        \n        if (pathname[0] == '\\0') {\n            return 0;\n        }\n\n        \n        *path = pathname;\n\n        \n        if (entry->d.type != LFS1_TYPE_DIR) {\n            return LFS1_ERR_NOTDIR;\n        }\n\n        int err = lfs1_dir_fetch(lfs1, dir, entry->d.u.dir);\n        if (err) {\n            return err;\n        }\n\n        \n        while (true) {\n            err = lfs1_dir_next(lfs1, dir, entry);\n            if (err) {\n                return err;\n            }\n\n            if (((0x7f & entry->d.type) != LFS1_TYPE_REG &&\n                 (0x7f & entry->d.type) != LFS1_TYPE_DIR) ||\n                entry->d.nlen != pathlen) {\n                continue;\n            }\n\n            int res = lfs1_bd_cmp(lfs1, dir->pair[0],\n                    entry->off + 4+entry->d.elen+entry->d.alen,\n                    pathname, pathlen);\n            if (res < 0) {\n                return res;\n            }\n\n            \n            if (res) {\n                break;\n            }\n        }\n\n        \n        if (!lfs1->moving && entry->d.type & 0x80) {\n            int moved = lfs1_moved(lfs1, &entry->d.u);\n            if (moved < 0 || moved) {\n                return (moved < 0) ? moved : LFS1_ERR_NOENT;\n            }\n\n            entry->d.type &= ~0x80;\n        }\n\n        \n        pathname += pathlen;\n    }\n}\n\n\n\nint lfs1_mkdir(lfs1_t *lfs1, const char *path) {\n    \n    if (!lfs1->deorphaned) {\n        int err = lfs1_deorphan(lfs1);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    lfs1_dir_t cwd;\n    lfs1_entry_t entry;\n    int err = lfs1_dir_find(lfs1, &cwd, &entry, &path);\n    if (err != LFS1_ERR_NOENT || strchr(path, '/') != NULL) {\n        return err ? err : LFS1_ERR_EXIST;\n    }\n\n    \n    lfs1_alloc_ack(lfs1);\n\n    lfs1_dir_t dir;\n    err = lfs1_dir_alloc(lfs1, &dir);\n    if (err) {\n        return err;\n    }\n    dir.d.tail[0] = cwd.d.tail[0];\n    dir.d.tail[1] = cwd.d.tail[1];\n\n    err = lfs1_dir_commit(lfs1, &dir, NULL, 0);\n    if (err) {\n        return err;\n    }\n\n    entry.d.type = LFS1_TYPE_DIR;\n    entry.d.elen = sizeof(entry.d) - 4;\n    entry.d.alen = 0;\n    entry.d.nlen = strlen(path);\n    entry.d.u.dir[0] = dir.pair[0];\n    entry.d.u.dir[1] = dir.pair[1];\n\n    cwd.d.tail[0] = dir.pair[0];\n    cwd.d.tail[1] = dir.pair[1];\n\n    err = lfs1_dir_append(lfs1, &cwd, &entry, path);\n    if (err) {\n        return err;\n    }\n\n    lfs1_alloc_ack(lfs1);\n    return 0;\n}\n\nint lfs1_dir_open(lfs1_t *lfs1, lfs1_dir_t *dir, const char *path) {\n    dir->pair[0] = lfs1->root[0];\n    dir->pair[1] = lfs1->root[1];\n\n    lfs1_entry_t entry;\n    int err = lfs1_dir_find(lfs1, dir, &entry, &path);\n    if (err) {\n        return err;\n    } else if (entry.d.type != LFS1_TYPE_DIR) {\n        return LFS1_ERR_NOTDIR;\n    }\n\n    err = lfs1_dir_fetch(lfs1, dir, entry.d.u.dir);\n    if (err) {\n        return err;\n    }\n\n    \n    \n    dir->head[0] = dir->pair[0];\n    dir->head[1] = dir->pair[1];\n    dir->pos = sizeof(dir->d) - 2;\n    dir->off = sizeof(dir->d);\n\n    \n    dir->next = lfs1->dirs;\n    lfs1->dirs = dir;\n\n    return 0;\n}\n\nint lfs1_dir_close(lfs1_t *lfs1, lfs1_dir_t *dir) {\n    \n    for (lfs1_dir_t **p = &lfs1->dirs; *p; p = &(*p)->next) {\n        if (*p == dir) {\n            *p = dir->next;\n            break;\n        }\n    }\n\n    return 0;\n}\n\nint lfs1_dir_read(lfs1_t *lfs1, lfs1_dir_t *dir, struct lfs1_info *info) {\n    memset(info, 0, sizeof(*info));\n\n    \n    if (dir->pos == sizeof(dir->d) - 2) {\n        info->type = LFS1_TYPE_DIR;\n        strcpy(info->name, \".\");\n        dir->pos += 1;\n        return 1;\n    } else if (dir->pos == sizeof(dir->d) - 1) {\n        info->type = LFS1_TYPE_DIR;\n        strcpy(info->name, \"..\");\n        dir->pos += 1;\n        return 1;\n    }\n\n    lfs1_entry_t entry;\n    while (true) {\n        int err = lfs1_dir_next(lfs1, dir, &entry);\n        if (err) {\n            return (err == LFS1_ERR_NOENT) ? 0 : err;\n        }\n\n        if ((0x7f & entry.d.type) != LFS1_TYPE_REG &&\n            (0x7f & entry.d.type) != LFS1_TYPE_DIR) {\n            continue;\n        }\n\n        \n        if (entry.d.type & 0x80) {\n            int moved = lfs1_moved(lfs1, &entry.d.u);\n            if (moved < 0) {\n                return moved;\n            }\n\n            if (moved) {\n                continue;\n            }\n\n            entry.d.type &= ~0x80;\n        }\n\n        break;\n    }\n\n    info->type = entry.d.type;\n    if (info->type == LFS1_TYPE_REG) {\n        info->size = entry.d.u.file.size;\n    }\n\n    int err = lfs1_bd_read(lfs1, dir->pair[0],\n            entry.off + 4+entry.d.elen+entry.d.alen,\n            info->name, entry.d.nlen);\n    if (err) {\n        return err;\n    }\n\n    return 1;\n}\n\nint lfs1_dir_seek(lfs1_t *lfs1, lfs1_dir_t *dir, lfs1_off_t off) {\n    \n    int err = lfs1_dir_rewind(lfs1, dir);\n    if (err) {\n        return err;\n    }\n    dir->pos = off;\n\n    while (off > (0x7fffffff & dir->d.size)) {\n        off -= 0x7fffffff & dir->d.size;\n        if (!(0x80000000 & dir->d.size)) {\n            return LFS1_ERR_INVAL;\n        }\n\n        err = lfs1_dir_fetch(lfs1, dir, dir->d.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    dir->off = off;\n    return 0;\n}\n\nlfs1_soff_t lfs1_dir_tell(lfs1_t *lfs1, lfs1_dir_t *dir) {\n    (void)lfs1;\n    return dir->pos;\n}\n\nint lfs1_dir_rewind(lfs1_t *lfs1, lfs1_dir_t *dir) {\n    \n    int err = lfs1_dir_fetch(lfs1, dir, dir->head);\n    if (err) {\n        return err;\n    }\n\n    dir->pair[0] = dir->head[0];\n    dir->pair[1] = dir->head[1];\n    dir->pos = sizeof(dir->d) - 2;\n    dir->off = sizeof(dir->d);\n    return 0;\n}\n\n\n\nstatic int lfs1_ctz_index(lfs1_t *lfs1, lfs1_off_t *off) {\n    lfs1_off_t size = *off;\n    lfs1_off_t b = lfs1->cfg->block_size - 2*4;\n    lfs1_off_t i = size / b;\n    if (i == 0) {\n        return 0;\n    }\n\n    i = (size - 4*(lfs1_popc(i-1)+2)) / b;\n    *off = size - b*i - 4*lfs1_popc(i);\n    return i;\n}\n\nstatic int lfs1_ctz_find(lfs1_t *lfs1,\n        lfs1_cache_t *rcache, const lfs1_cache_t *pcache,\n        lfs1_block_t head, lfs1_size_t size,\n        lfs1_size_t pos, lfs1_block_t *block, lfs1_off_t *off) {\n    if (size == 0) {\n        *block = 0xffffffff;\n        *off = 0;\n        return 0;\n    }\n\n    lfs1_off_t current = lfs1_ctz_index(lfs1, &(lfs1_off_t){size-1});\n    lfs1_off_t target = lfs1_ctz_index(lfs1, &pos);\n\n    while (current > target) {\n        lfs1_size_t skip = lfs1_min(\n                lfs1_npw2(current-target+1) - 1,\n                lfs1_ctz(current));\n\n        int err = lfs1_cache_read(lfs1, rcache, pcache, head, 4*skip, &head, 4);\n        head = lfs1_fromle32(head);\n        if (err) {\n            return err;\n        }\n\n        LFS1_ASSERT(head >= 2 && head <= lfs1->cfg->block_count);\n        current -= 1 << skip;\n    }\n\n    *block = head;\n    *off = pos;\n    return 0;\n}\n\nstatic int lfs1_ctz_extend(lfs1_t *lfs1,\n        lfs1_cache_t *rcache, lfs1_cache_t *pcache,\n        lfs1_block_t head, lfs1_size_t size,\n        lfs1_block_t *block, lfs1_off_t *off) {\n    while (true) {\n        \n        lfs1_block_t nblock;\n        int err = lfs1_alloc(lfs1, &nblock);\n        if (err) {\n            return err;\n        }\n        LFS1_ASSERT(nblock >= 2 && nblock <= lfs1->cfg->block_count);\n\n        if (true) {\n            err = lfs1_bd_erase(lfs1, nblock);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            if (size == 0) {\n                *block = nblock;\n                *off = 0;\n                return 0;\n            }\n\n            size -= 1;\n            lfs1_off_t index = lfs1_ctz_index(lfs1, &size);\n            size += 1;\n\n            \n            if (size != lfs1->cfg->block_size) {\n                for (lfs1_off_t i = 0; i < size; i++) {\n                    uint8_t data;\n                    err = lfs1_cache_read(lfs1, rcache, NULL,\n                            head, i, &data, 1);\n                    if (err) {\n                        return err;\n                    }\n\n                    err = lfs1_cache_prog(lfs1, pcache, rcache,\n                            nblock, i, &data, 1);\n                    if (err) {\n                        if (err == LFS1_ERR_CORRUPT) {\n                            goto relocate;\n                        }\n                        return err;\n                    }\n                }\n\n                *block = nblock;\n                *off = size;\n                return 0;\n            }\n\n            \n            index += 1;\n            lfs1_size_t skips = lfs1_ctz(index) + 1;\n\n            for (lfs1_off_t i = 0; i < skips; i++) {\n                head = lfs1_tole32(head);\n                err = lfs1_cache_prog(lfs1, pcache, rcache,\n                        nblock, 4*i, &head, 4);\n                head = lfs1_fromle32(head);\n                if (err) {\n                    if (err == LFS1_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n\n                if (i != skips-1) {\n                    err = lfs1_cache_read(lfs1, rcache, NULL,\n                            head, 4*i, &head, 4);\n                    head = lfs1_fromle32(head);\n                    if (err) {\n                        return err;\n                    }\n                }\n\n                LFS1_ASSERT(head >= 2 && head <= lfs1->cfg->block_count);\n            }\n\n            *block = nblock;\n            *off = 4*skips;\n            return 0;\n        }\n\nrelocate:\n        LFS1_DEBUG(\"Bad block at %\" PRIu32, nblock);\n\n        \n        lfs1_cache_drop(lfs1, &lfs1->pcache);\n    }\n}\n\nstatic int lfs1_ctz_traverse(lfs1_t *lfs1,\n        lfs1_cache_t *rcache, const lfs1_cache_t *pcache,\n        lfs1_block_t head, lfs1_size_t size,\n        int (*cb)(void*, lfs1_block_t), void *data) {\n    if (size == 0) {\n        return 0;\n    }\n\n    lfs1_off_t index = lfs1_ctz_index(lfs1, &(lfs1_off_t){size-1});\n\n    while (true) {\n        int err = cb(data, head);\n        if (err) {\n            return err;\n        }\n\n        if (index == 0) {\n            return 0;\n        }\n\n        lfs1_block_t heads[2];\n        int count = 2 - (index & 1);\n        err = lfs1_cache_read(lfs1, rcache, pcache, head, 0, &heads, count*4);\n        heads[0] = lfs1_fromle32(heads[0]);\n        heads[1] = lfs1_fromle32(heads[1]);\n        if (err) {\n            return err;\n        }\n\n        for (int i = 0; i < count-1; i++) {\n            err = cb(data, heads[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        head = heads[count-1];\n        index -= count;\n    }\n}\n\n\n\nint lfs1_file_opencfg(lfs1_t *lfs1, lfs1_file_t *file,\n        const char *path, int flags,\n        const struct lfs1_file_config *cfg) {\n    \n    if ((flags & 3) != LFS1_O_RDONLY && !lfs1->deorphaned) {\n        int err = lfs1_deorphan(lfs1);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    lfs1_dir_t cwd;\n    lfs1_entry_t entry;\n    int err = lfs1_dir_find(lfs1, &cwd, &entry, &path);\n    if (err && (err != LFS1_ERR_NOENT || strchr(path, '/') != NULL)) {\n        return err;\n    }\n\n    if (err == LFS1_ERR_NOENT) {\n        if (!(flags & LFS1_O_CREAT)) {\n            return LFS1_ERR_NOENT;\n        }\n\n        \n        entry.d.type = LFS1_TYPE_REG;\n        entry.d.elen = sizeof(entry.d) - 4;\n        entry.d.alen = 0;\n        entry.d.nlen = strlen(path);\n        entry.d.u.file.head = 0xffffffff;\n        entry.d.u.file.size = 0;\n        err = lfs1_dir_append(lfs1, &cwd, &entry, path);\n        if (err) {\n            return err;\n        }\n    } else if (entry.d.type == LFS1_TYPE_DIR) {\n        return LFS1_ERR_ISDIR;\n    } else if (flags & LFS1_O_EXCL) {\n        return LFS1_ERR_EXIST;\n    }\n\n    \n    file->cfg = cfg;\n    file->pair[0] = cwd.pair[0];\n    file->pair[1] = cwd.pair[1];\n    file->poff = entry.off;\n    file->head = entry.d.u.file.head;\n    file->size = entry.d.u.file.size;\n    file->flags = flags;\n    file->pos = 0;\n\n    if (flags & LFS1_O_TRUNC) {\n        if (file->size != 0) {\n            file->flags |= LFS1_F_DIRTY;\n        }\n        file->head = 0xffffffff;\n        file->size = 0;\n    }\n\n    \n    file->cache.block = 0xffffffff;\n    if (file->cfg && file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n    } else if (lfs1->cfg->file_buffer) {\n        if (lfs1->files) {\n            \n            return LFS1_ERR_NOMEM;\n        }\n        file->cache.buffer = lfs1->cfg->file_buffer;\n    } else if ((file->flags & 3) == LFS1_O_RDONLY) {\n        file->cache.buffer = lfs1_malloc(lfs1->cfg->read_size);\n        if (!file->cache.buffer) {\n            return LFS1_ERR_NOMEM;\n        }\n    } else {\n        file->cache.buffer = lfs1_malloc(lfs1->cfg->prog_size);\n        if (!file->cache.buffer) {\n            return LFS1_ERR_NOMEM;\n        }\n    }\n\n    \n    lfs1_cache_drop(lfs1, &file->cache);\n    if ((file->flags & 3) != LFS1_O_RDONLY) {\n        lfs1_cache_zero(lfs1, &file->cache);\n    }\n\n    \n    file->next = lfs1->files;\n    lfs1->files = file;\n\n    return 0;\n}\n\nint lfs1_file_open(lfs1_t *lfs1, lfs1_file_t *file,\n        const char *path, int flags) {\n    return lfs1_file_opencfg(lfs1, file, path, flags, NULL);\n}\n\nint lfs1_file_close(lfs1_t *lfs1, lfs1_file_t *file) {\n    int err = lfs1_file_sync(lfs1, file);\n\n    \n    for (lfs1_file_t **p = &lfs1->files; *p; p = &(*p)->next) {\n        if (*p == file) {\n            *p = file->next;\n            break;\n        }\n    }\n\n    \n    if (!(file->cfg && file->cfg->buffer) && !lfs1->cfg->file_buffer) {\n        lfs1_free(file->cache.buffer);\n    }\n\n    return err;\n}\n\nstatic int lfs1_file_relocate(lfs1_t *lfs1, lfs1_file_t *file) {\nrelocate:\n    LFS1_DEBUG(\"Bad block at %\" PRIu32, file->block);\n\n    \n    lfs1_block_t nblock;\n    int err = lfs1_alloc(lfs1, &nblock);\n    if (err) {\n        return err;\n    }\n\n    err = lfs1_bd_erase(lfs1, nblock);\n    if (err) {\n        if (err == LFS1_ERR_CORRUPT) {\n            goto relocate;\n        }\n        return err;\n    }\n\n    \n    for (lfs1_off_t i = 0; i < file->off; i++) {\n        uint8_t data;\n        err = lfs1_cache_read(lfs1, &lfs1->rcache, &file->cache,\n                file->block, i, &data, 1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs1_cache_prog(lfs1, &lfs1->pcache, &lfs1->rcache,\n                nblock, i, &data, 1);\n        if (err) {\n            if (err == LFS1_ERR_CORRUPT) {\n                goto relocate;\n            }\n            return err;\n        }\n    }\n\n    \n    memcpy(file->cache.buffer, lfs1->pcache.buffer, lfs1->cfg->prog_size);\n    file->cache.block = lfs1->pcache.block;\n    file->cache.off = lfs1->pcache.off;\n    lfs1_cache_zero(lfs1, &lfs1->pcache);\n\n    file->block = nblock;\n    return 0;\n}\n\nstatic int lfs1_file_flush(lfs1_t *lfs1, lfs1_file_t *file) {\n    if (file->flags & LFS1_F_READING) {\n        \n        lfs1_cache_drop(lfs1, &file->cache);\n        file->flags &= ~LFS1_F_READING;\n    }\n\n    if (file->flags & LFS1_F_WRITING) {\n        lfs1_off_t pos = file->pos;\n\n        \n        lfs1_file_t orig = {\n            .head = file->head,\n            .size = file->size,\n            .flags = LFS1_O_RDONLY,\n            .pos = file->pos,\n            .cache = lfs1->rcache,\n        };\n        lfs1_cache_drop(lfs1, &lfs1->rcache);\n\n        while (file->pos < file->size) {\n            \n            \n            uint8_t data;\n            lfs1_ssize_t res = lfs1_file_read(lfs1, &orig, &data, 1);\n            if (res < 0) {\n                return res;\n            }\n\n            res = lfs1_file_write(lfs1, file, &data, 1);\n            if (res < 0) {\n                return res;\n            }\n\n            \n            if (lfs1->rcache.block != 0xffffffff) {\n                lfs1_cache_drop(lfs1, &orig.cache);\n                lfs1_cache_drop(lfs1, &lfs1->rcache);\n            }\n        }\n\n        \n        while (true) {\n            int err = lfs1_cache_flush(lfs1, &file->cache, &lfs1->rcache);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            break;\nrelocate:\n            err = lfs1_file_relocate(lfs1, file);\n            if (err) {\n                return err;\n            }\n        }\n\n        \n        file->head = file->block;\n        file->size = file->pos;\n        file->flags &= ~LFS1_F_WRITING;\n        file->flags |= LFS1_F_DIRTY;\n\n        file->pos = pos;\n    }\n\n    return 0;\n}\n\nint lfs1_file_sync(lfs1_t *lfs1, lfs1_file_t *file) {\n    int err = lfs1_file_flush(lfs1, file);\n    if (err) {\n        return err;\n    }\n\n    if ((file->flags & LFS1_F_DIRTY) &&\n            !(file->flags & LFS1_F_ERRED) &&\n            !lfs1_pairisnull(file->pair)) {\n        \n        lfs1_dir_t cwd;\n        err = lfs1_dir_fetch(lfs1, &cwd, file->pair);\n        if (err) {\n            return err;\n        }\n\n        lfs1_entry_t entry = {.off = file->poff};\n        err = lfs1_bd_read(lfs1, cwd.pair[0], entry.off,\n                &entry.d, sizeof(entry.d));\n        lfs1_entry_fromle32(&entry.d);\n        if (err) {\n            return err;\n        }\n\n        LFS1_ASSERT(entry.d.type == LFS1_TYPE_REG);\n        entry.d.u.file.head = file->head;\n        entry.d.u.file.size = file->size;\n\n        err = lfs1_dir_update(lfs1, &cwd, &entry, NULL);\n        if (err) {\n            return err;\n        }\n\n        file->flags &= ~LFS1_F_DIRTY;\n    }\n\n    return 0;\n}\n\nlfs1_ssize_t lfs1_file_read(lfs1_t *lfs1, lfs1_file_t *file,\n        void *buffer, lfs1_size_t size) {\n    uint8_t *data = buffer;\n    lfs1_size_t nsize = size;\n\n    if ((file->flags & 3) == LFS1_O_WRONLY) {\n        return LFS1_ERR_BADF;\n    }\n\n    if (file->flags & LFS1_F_WRITING) {\n        \n        int err = lfs1_file_flush(lfs1, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if (file->pos >= file->size) {\n        \n        return 0;\n    }\n\n    size = lfs1_min(size, file->size - file->pos);\n    nsize = size;\n\n    while (nsize > 0) {\n        \n        if (!(file->flags & LFS1_F_READING) ||\n                file->off == lfs1->cfg->block_size) {\n            int err = lfs1_ctz_find(lfs1, &file->cache, NULL,\n                    file->head, file->size,\n                    file->pos, &file->block, &file->off);\n            if (err) {\n                return err;\n            }\n\n            file->flags |= LFS1_F_READING;\n        }\n\n        \n        lfs1_size_t diff = lfs1_min(nsize, lfs1->cfg->block_size - file->off);\n        int err = lfs1_cache_read(lfs1, &file->cache, NULL,\n                file->block, file->off, data, diff);\n        if (err) {\n            return err;\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n    }\n\n    return size;\n}\n\nlfs1_ssize_t lfs1_file_write(lfs1_t *lfs1, lfs1_file_t *file,\n        const void *buffer, lfs1_size_t size) {\n    const uint8_t *data = buffer;\n    lfs1_size_t nsize = size;\n\n    if ((file->flags & 3) == LFS1_O_RDONLY) {\n        return LFS1_ERR_BADF;\n    }\n\n    if (file->flags & LFS1_F_READING) {\n        \n        int err = lfs1_file_flush(lfs1, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS1_O_APPEND) && file->pos < file->size) {\n        file->pos = file->size;\n    }\n\n    if (file->pos + size > LFS1_FILE_MAX) {\n        \n        return LFS1_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS1_F_WRITING) && file->pos > file->size) {\n        \n        lfs1_off_t pos = file->pos;\n        file->pos = file->size;\n\n        while (file->pos < pos) {\n            lfs1_ssize_t res = lfs1_file_write(lfs1, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n    }\n\n    while (nsize > 0) {\n        \n        if (!(file->flags & LFS1_F_WRITING) ||\n                file->off == lfs1->cfg->block_size) {\n            if (!(file->flags & LFS1_F_WRITING) && file->pos > 0) {\n                \n                int err = lfs1_ctz_find(lfs1, &file->cache, NULL,\n                        file->head, file->size,\n                        file->pos-1, &file->block, &file->off);\n                if (err) {\n                    file->flags |= LFS1_F_ERRED;\n                    return err;\n                }\n\n                \n                lfs1_cache_zero(lfs1, &file->cache);\n            }\n\n            \n            lfs1_alloc_ack(lfs1);\n            int err = lfs1_ctz_extend(lfs1, &lfs1->rcache, &file->cache,\n                    file->block, file->pos,\n                    &file->block, &file->off);\n            if (err) {\n                file->flags |= LFS1_F_ERRED;\n                return err;\n            }\n\n            file->flags |= LFS1_F_WRITING;\n        }\n\n        \n        lfs1_size_t diff = lfs1_min(nsize, lfs1->cfg->block_size - file->off);\n        while (true) {\n            int err = lfs1_cache_prog(lfs1, &file->cache, &lfs1->rcache,\n                    file->block, file->off, data, diff);\n            if (err) {\n                if (err == LFS1_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                file->flags |= LFS1_F_ERRED;\n                return err;\n            }\n\n            break;\nrelocate:\n            err = lfs1_file_relocate(lfs1, file);\n            if (err) {\n                file->flags |= LFS1_F_ERRED;\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n\n        lfs1_alloc_ack(lfs1);\n    }\n\n    file->flags &= ~LFS1_F_ERRED;\n    return size;\n}\n\nlfs1_soff_t lfs1_file_seek(lfs1_t *lfs1, lfs1_file_t *file,\n        lfs1_soff_t off, int whence) {\n    \n    int err = lfs1_file_flush(lfs1, file);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs1_soff_t npos = file->pos;\n    if (whence == LFS1_SEEK_SET) {\n        npos = off;\n    } else if (whence == LFS1_SEEK_CUR) {\n        npos = file->pos + off;\n    } else if (whence == LFS1_SEEK_END) {\n        npos = file->size + off;\n    }\n\n    if (npos < 0 || npos > LFS1_FILE_MAX) {\n        \n        return LFS1_ERR_INVAL;\n    }\n\n    \n    file->pos = npos;\n    return npos;\n}\n\nint lfs1_file_truncate(lfs1_t *lfs1, lfs1_file_t *file, lfs1_off_t size) {\n    if ((file->flags & 3) == LFS1_O_RDONLY) {\n        return LFS1_ERR_BADF;\n    }\n\n    lfs1_off_t oldsize = lfs1_file_size(lfs1, file);\n    if (size < oldsize) {\n        \n        int err = lfs1_file_flush(lfs1, file);\n        if (err) {\n            return err;\n        }\n\n        \n        err = lfs1_ctz_find(lfs1, &file->cache, NULL,\n                file->head, file->size,\n                size, &file->head, &(lfs1_off_t){0});\n        if (err) {\n            return err;\n        }\n\n        file->size = size;\n        file->flags |= LFS1_F_DIRTY;\n    } else if (size > oldsize) {\n        lfs1_off_t pos = file->pos;\n\n        \n        if (file->pos != oldsize) {\n            int err = lfs1_file_seek(lfs1, file, 0, LFS1_SEEK_END);\n            if (err < 0) {\n                return err;\n            }\n        }\n\n        \n        while (file->pos < size) {\n            lfs1_ssize_t res = lfs1_file_write(lfs1, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n\n        \n        int err = lfs1_file_seek(lfs1, file, pos, LFS1_SEEK_SET);\n        if (err < 0) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\nlfs1_soff_t lfs1_file_tell(lfs1_t *lfs1, lfs1_file_t *file) {\n    (void)lfs1;\n    return file->pos;\n}\n\nint lfs1_file_rewind(lfs1_t *lfs1, lfs1_file_t *file) {\n    lfs1_soff_t res = lfs1_file_seek(lfs1, file, 0, LFS1_SEEK_SET);\n    if (res < 0) {\n        return res;\n    }\n\n    return 0;\n}\n\nlfs1_soff_t lfs1_file_size(lfs1_t *lfs1, lfs1_file_t *file) {\n    (void)lfs1;\n    if (file->flags & LFS1_F_WRITING) {\n        return lfs1_max(file->pos, file->size);\n    } else {\n        return file->size;\n    }\n}\n\n\n\nint lfs1_stat(lfs1_t *lfs1, const char *path, struct lfs1_info *info) {\n    lfs1_dir_t cwd;\n    lfs1_entry_t entry;\n    int err = lfs1_dir_find(lfs1, &cwd, &entry, &path);\n    if (err) {\n        return err;\n    }\n\n    memset(info, 0, sizeof(*info));\n    info->type = entry.d.type;\n    if (info->type == LFS1_TYPE_REG) {\n        info->size = entry.d.u.file.size;\n    }\n\n    if (lfs1_paircmp(entry.d.u.dir, lfs1->root) == 0) {\n        strcpy(info->name, \"/\");\n    } else {\n        err = lfs1_bd_read(lfs1, cwd.pair[0],\n                entry.off + 4+entry.d.elen+entry.d.alen,\n                info->name, entry.d.nlen);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\nint lfs1_remove(lfs1_t *lfs1, const char *path) {\n    \n    if (!lfs1->deorphaned) {\n        int err = lfs1_deorphan(lfs1);\n        if (err) {\n            return err;\n        }\n    }\n\n    lfs1_dir_t cwd;\n    lfs1_entry_t entry;\n    int err = lfs1_dir_find(lfs1, &cwd, &entry, &path);\n    if (err) {\n        return err;\n    }\n\n    lfs1_dir_t dir;\n    if (entry.d.type == LFS1_TYPE_DIR) {\n        \n        \n        \n        err = lfs1_dir_fetch(lfs1, &dir, entry.d.u.dir);\n        if (err) {\n            return err;\n        } else if (dir.d.size != sizeof(dir.d)+4) {\n            return LFS1_ERR_NOTEMPTY;\n        }\n    }\n\n    \n    err = lfs1_dir_remove(lfs1, &cwd, &entry);\n    if (err) {\n        return err;\n    }\n\n    \n    if (entry.d.type == LFS1_TYPE_DIR) {\n        int res = lfs1_pred(lfs1, dir.pair, &cwd);\n        if (res < 0) {\n            return res;\n        }\n\n        LFS1_ASSERT(res); \n        cwd.d.tail[0] = dir.d.tail[0];\n        cwd.d.tail[1] = dir.d.tail[1];\n\n        err = lfs1_dir_commit(lfs1, &cwd, NULL, 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\nint lfs1_rename(lfs1_t *lfs1, const char *oldpath, const char *newpath) {\n    \n    if (!lfs1->deorphaned) {\n        int err = lfs1_deorphan(lfs1);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    lfs1_dir_t oldcwd;\n    lfs1_entry_t oldentry;\n    int err = lfs1_dir_find(lfs1, &oldcwd, &oldentry, &(const char *){oldpath});\n    if (err) {\n        return err;\n    }\n\n    \n    oldentry.d.type |= 0x80;\n    err = lfs1_dir_update(lfs1, &oldcwd, &oldentry, NULL);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs1_dir_t newcwd;\n    lfs1_entry_t preventry;\n    err = lfs1_dir_find(lfs1, &newcwd, &preventry, &newpath);\n    if (err && (err != LFS1_ERR_NOENT || strchr(newpath, '/') != NULL)) {\n        return err;\n    }\n\n    \n    bool prevexists = (err != LFS1_ERR_NOENT);\n    if (prevexists && preventry.d.type != (0x7f & oldentry.d.type)) {\n        return LFS1_ERR_ISDIR;\n    }\n\n    lfs1_dir_t dir;\n    if (prevexists && preventry.d.type == LFS1_TYPE_DIR) {\n        \n        \n        \n        err = lfs1_dir_fetch(lfs1, &dir, preventry.d.u.dir);\n        if (err) {\n            return err;\n        } else if (dir.d.size != sizeof(dir.d)+4) {\n            return LFS1_ERR_NOTEMPTY;\n        }\n    }\n\n    \n    lfs1_entry_t newentry = preventry;\n    newentry.d = oldentry.d;\n    newentry.d.type &= ~0x80;\n    newentry.d.nlen = strlen(newpath);\n\n    if (prevexists) {\n        err = lfs1_dir_update(lfs1, &newcwd, &newentry, newpath);\n        if (err) {\n            return err;\n        }\n    } else {\n        err = lfs1_dir_append(lfs1, &newcwd, &newentry, newpath);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    lfs1->moving = true;\n    err = lfs1_dir_find(lfs1, &oldcwd, &oldentry, &oldpath);\n    if (err) {\n        return err;\n    }\n    lfs1->moving = false;\n\n    \n    err = lfs1_dir_remove(lfs1, &oldcwd, &oldentry);\n    if (err) {\n        return err;\n    }\n\n    \n    if (prevexists && preventry.d.type == LFS1_TYPE_DIR) {\n        int res = lfs1_pred(lfs1, dir.pair, &newcwd);\n        if (res < 0) {\n            return res;\n        }\n\n        LFS1_ASSERT(res); \n        newcwd.d.tail[0] = dir.d.tail[0];\n        newcwd.d.tail[1] = dir.d.tail[1];\n\n        err = lfs1_dir_commit(lfs1, &newcwd, NULL, 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\n\n\nstatic void lfs1_deinit(lfs1_t *lfs1) {\n    \n    if (!lfs1->cfg->read_buffer) {\n        lfs1_free(lfs1->rcache.buffer);\n    }\n\n    if (!lfs1->cfg->prog_buffer) {\n        lfs1_free(lfs1->pcache.buffer);\n    }\n\n    if (!lfs1->cfg->lookahead_buffer) {\n        lfs1_free(lfs1->free.buffer);\n    }\n}\n\nstatic int lfs1_init(lfs1_t *lfs1, const struct lfs1_config *cfg) {\n    lfs1->cfg = cfg;\n\n    \n    if (lfs1->cfg->read_buffer) {\n        lfs1->rcache.buffer = lfs1->cfg->read_buffer;\n    } else {\n        lfs1->rcache.buffer = lfs1_malloc(lfs1->cfg->read_size);\n        if (!lfs1->rcache.buffer) {\n            goto cleanup;\n        }\n    }\n\n    \n    if (lfs1->cfg->prog_buffer) {\n        lfs1->pcache.buffer = lfs1->cfg->prog_buffer;\n    } else {\n        lfs1->pcache.buffer = lfs1_malloc(lfs1->cfg->prog_size);\n        if (!lfs1->pcache.buffer) {\n            goto cleanup;\n        }\n    }\n\n    \n    lfs1_cache_zero(lfs1, &lfs1->pcache);\n    lfs1_cache_drop(lfs1, &lfs1->rcache);\n\n    \n    LFS1_ASSERT(lfs1->cfg->lookahead % 32 == 0);\n    LFS1_ASSERT(lfs1->cfg->lookahead > 0);\n    if (lfs1->cfg->lookahead_buffer) {\n        lfs1->free.buffer = lfs1->cfg->lookahead_buffer;\n    } else {\n        lfs1->free.buffer = lfs1_malloc(lfs1->cfg->lookahead/8);\n        if (!lfs1->free.buffer) {\n            goto cleanup;\n        }\n    }\n\n    \n    LFS1_ASSERT(lfs1->cfg->prog_size % lfs1->cfg->read_size == 0);\n    LFS1_ASSERT(lfs1->cfg->block_size % lfs1->cfg->prog_size == 0);\n\n    \n    LFS1_ASSERT(4*lfs1_npw2(0xffffffff / (lfs1->cfg->block_size-2*4))\n            <= lfs1->cfg->block_size);\n\n    \n    lfs1->root[0] = 0xffffffff;\n    lfs1->root[1] = 0xffffffff;\n    lfs1->files = NULL;\n    lfs1->dirs = NULL;\n    lfs1->deorphaned = false;\n    lfs1->moving = false;\n\n    return 0;\n\ncleanup:\n    lfs1_deinit(lfs1);\n    return LFS1_ERR_NOMEM;\n}\n\nint lfs1_format(lfs1_t *lfs1, const struct lfs1_config *cfg) {\n    int err = 0;\n    if (true) {\n        err = lfs1_init(lfs1, cfg);\n        if (err) {\n            return err;\n        }\n\n        \n        memset(lfs1->free.buffer, 0, lfs1->cfg->lookahead/8);\n        lfs1->free.off = 0;\n        lfs1->free.size = lfs1_min(lfs1->cfg->lookahead, lfs1->cfg->block_count);\n        lfs1->free.i = 0;\n        lfs1_alloc_ack(lfs1);\n\n        \n        lfs1_dir_t superdir;\n        err = lfs1_dir_alloc(lfs1, &superdir);\n        if (err) {\n            goto cleanup;\n        }\n\n        \n        lfs1_dir_t root;\n        err = lfs1_dir_alloc(lfs1, &root);\n        if (err) {\n            goto cleanup;\n        }\n\n        err = lfs1_dir_commit(lfs1, &root, NULL, 0);\n        if (err) {\n            goto cleanup;\n        }\n\n        lfs1->root[0] = root.pair[0];\n        lfs1->root[1] = root.pair[1];\n\n        \n        lfs1_superblock_t superblock = {\n            .off = sizeof(superdir.d),\n            .d.type = LFS1_TYPE_SUPERBLOCK,\n            .d.elen = sizeof(superblock.d) - sizeof(superblock.d.magic) - 4,\n            .d.nlen = sizeof(superblock.d.magic),\n            .d.version = LFS1_DISK_VERSION,\n            .d.magic = {\"littlefs\"},\n            .d.block_size  = lfs1->cfg->block_size,\n            .d.block_count = lfs1->cfg->block_count,\n            .d.root = {lfs1->root[0], lfs1->root[1]},\n        };\n        superdir.d.tail[0] = root.pair[0];\n        superdir.d.tail[1] = root.pair[1];\n        superdir.d.size = sizeof(superdir.d) + sizeof(superblock.d) + 4;\n\n        \n        lfs1_superblock_tole32(&superblock.d);\n        bool valid = false;\n        for (int i = 0; i < 2; i++) {\n            err = lfs1_dir_commit(lfs1, &superdir, (struct lfs1_region[]){\n                    {sizeof(superdir.d), sizeof(superblock.d),\n                     &superblock.d, sizeof(superblock.d)}\n                }, 1);\n            if (err && err != LFS1_ERR_CORRUPT) {\n                goto cleanup;\n            }\n\n            valid = valid || !err;\n        }\n\n        if (!valid) {\n            err = LFS1_ERR_CORRUPT;\n            goto cleanup;\n        }\n\n        \n        err = lfs1_dir_fetch(lfs1, &superdir, (const lfs1_block_t[2]){0, 1});\n        if (err) {\n            goto cleanup;\n        }\n\n        lfs1_alloc_ack(lfs1);\n    }\n\ncleanup:\n    lfs1_deinit(lfs1);\n    return err;\n}\n\nint lfs1_mount(lfs1_t *lfs1, const struct lfs1_config *cfg) {\n    int err = 0;\n    if (true) {\n        err = lfs1_init(lfs1, cfg);\n        if (err) {\n            return err;\n        }\n\n        \n        lfs1->free.off = 0;\n        lfs1->free.size = 0;\n        lfs1->free.i = 0;\n        lfs1_alloc_ack(lfs1);\n\n        \n        lfs1_dir_t dir;\n        lfs1_superblock_t superblock;\n        err = lfs1_dir_fetch(lfs1, &dir, (const lfs1_block_t[2]){0, 1});\n        if (err && err != LFS1_ERR_CORRUPT) {\n            goto cleanup;\n        }\n\n        if (!err) {\n            err = lfs1_bd_read(lfs1, dir.pair[0], sizeof(dir.d),\n                    &superblock.d, sizeof(superblock.d));\n            lfs1_superblock_fromle32(&superblock.d);\n            if (err) {\n                goto cleanup;\n            }\n\n            lfs1->root[0] = superblock.d.root[0];\n            lfs1->root[1] = superblock.d.root[1];\n        }\n\n        if (err || memcmp(superblock.d.magic, \"littlefs\", 8) != 0) {\n            LFS1_ERROR(\"Invalid superblock at %d %d\", 0, 1);\n            err = LFS1_ERR_CORRUPT;\n            goto cleanup;\n        }\n\n        uint16_t major_version = (0xffff & (superblock.d.version >> 16));\n        uint16_t minor_version = (0xffff & (superblock.d.version >>  0));\n        if ((major_version != LFS1_DISK_VERSION_MAJOR ||\n             minor_version > LFS1_DISK_VERSION_MINOR)) {\n            LFS1_ERROR(\"Invalid version %d.%d\", major_version, minor_version);\n            err = LFS1_ERR_INVAL;\n            goto cleanup;\n        }\n\n        return 0;\n    }\n\ncleanup:\n\n    lfs1_deinit(lfs1);\n    return err;\n}\n\nint lfs1_unmount(lfs1_t *lfs1) {\n    lfs1_deinit(lfs1);\n    return 0;\n}\n\n\n\nint lfs1_traverse(lfs1_t *lfs1, int (*cb)(void*, lfs1_block_t), void *data) {\n    if (lfs1_pairisnull(lfs1->root)) {\n        return 0;\n    }\n\n    \n    lfs1_dir_t dir;\n    lfs1_entry_t entry;\n    lfs1_block_t cwd[2] = {0, 1};\n\n    while (true) {\n        for (int i = 0; i < 2; i++) {\n            int err = cb(data, cwd[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        int err = lfs1_dir_fetch(lfs1, &dir, cwd);\n        if (err) {\n            return err;\n        }\n\n        \n        while (dir.off + sizeof(entry.d) <= (0x7fffffff & dir.d.size)-4) {\n            err = lfs1_bd_read(lfs1, dir.pair[0], dir.off,\n                    &entry.d, sizeof(entry.d));\n            lfs1_entry_fromle32(&entry.d);\n            if (err) {\n                return err;\n            }\n\n            dir.off += lfs1_entry_size(&entry);\n            if ((0x70 & entry.d.type) == (0x70 & LFS1_TYPE_REG)) {\n                err = lfs1_ctz_traverse(lfs1, &lfs1->rcache, NULL,\n                        entry.d.u.file.head, entry.d.u.file.size, cb, data);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        cwd[0] = dir.d.tail[0];\n        cwd[1] = dir.d.tail[1];\n\n        if (lfs1_pairisnull(cwd)) {\n            break;\n        }\n    }\n\n    \n    for (lfs1_file_t *f = lfs1->files; f; f = f->next) {\n        if (f->flags & LFS1_F_DIRTY) {\n            int err = lfs1_ctz_traverse(lfs1, &lfs1->rcache, &f->cache,\n                    f->head, f->size, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n\n        if (f->flags & LFS1_F_WRITING) {\n            int err = lfs1_ctz_traverse(lfs1, &lfs1->rcache, &f->cache,\n                    f->block, f->pos, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int lfs1_pred(lfs1_t *lfs1, const lfs1_block_t dir[2], lfs1_dir_t *pdir) {\n    if (lfs1_pairisnull(lfs1->root)) {\n        return 0;\n    }\n\n    \n    int err = lfs1_dir_fetch(lfs1, pdir, (const lfs1_block_t[2]){0, 1});\n    if (err) {\n        return err;\n    }\n\n    while (!lfs1_pairisnull(pdir->d.tail)) {\n        if (lfs1_paircmp(pdir->d.tail, dir) == 0) {\n            return true;\n        }\n\n        err = lfs1_dir_fetch(lfs1, pdir, pdir->d.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    return false;\n}\n\nstatic int lfs1_parent(lfs1_t *lfs1, const lfs1_block_t dir[2],\n        lfs1_dir_t *parent, lfs1_entry_t *entry) {\n    if (lfs1_pairisnull(lfs1->root)) {\n        return 0;\n    }\n\n    parent->d.tail[0] = 0;\n    parent->d.tail[1] = 1;\n\n    \n    while (!lfs1_pairisnull(parent->d.tail)) {\n        int err = lfs1_dir_fetch(lfs1, parent, parent->d.tail);\n        if (err) {\n            return err;\n        }\n\n        while (true) {\n            err = lfs1_dir_next(lfs1, parent, entry);\n            if (err && err != LFS1_ERR_NOENT) {\n                return err;\n            }\n\n            if (err == LFS1_ERR_NOENT) {\n                break;\n            }\n\n            if (((0x70 & entry->d.type) == (0x70 & LFS1_TYPE_DIR)) &&\n                 lfs1_paircmp(entry->d.u.dir, dir) == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic int lfs1_moved(lfs1_t *lfs1, const void *e) {\n    if (lfs1_pairisnull(lfs1->root)) {\n        return 0;\n    }\n\n    \n    lfs1_dir_t cwd;\n    int err = lfs1_dir_fetch(lfs1, &cwd, (const lfs1_block_t[2]){0, 1});\n    if (err) {\n        return err;\n    }\n\n    \n    lfs1_entry_t entry;\n    while (!lfs1_pairisnull(cwd.d.tail)) {\n        err = lfs1_dir_fetch(lfs1, &cwd, cwd.d.tail);\n        if (err) {\n            return err;\n        }\n\n        while (true) {\n            err = lfs1_dir_next(lfs1, &cwd, &entry);\n            if (err && err != LFS1_ERR_NOENT) {\n                return err;\n            }\n\n            if (err == LFS1_ERR_NOENT) {\n                break;\n            }\n\n            if (!(0x80 & entry.d.type) &&\n                 memcmp(&entry.d.u, e, sizeof(entry.d.u)) == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic int lfs1_relocate(lfs1_t *lfs1,\n        const lfs1_block_t oldpair[2], const lfs1_block_t newpair[2]) {\n    \n    lfs1_dir_t parent;\n    lfs1_entry_t entry;\n    int res = lfs1_parent(lfs1, oldpair, &parent, &entry);\n    if (res < 0) {\n        return res;\n    }\n\n    if (res) {\n        \n        entry.d.u.dir[0] = newpair[0];\n        entry.d.u.dir[1] = newpair[1];\n\n        int err = lfs1_dir_update(lfs1, &parent, &entry, NULL);\n        if (err) {\n            return err;\n        }\n\n        \n        if (lfs1_paircmp(oldpair, lfs1->root) == 0) {\n            LFS1_DEBUG(\"Relocating root %\" PRIu32 \" %\" PRIu32,\n                    newpair[0], newpair[1]);\n            lfs1->root[0] = newpair[0];\n            lfs1->root[1] = newpair[1];\n        }\n\n        \n        return lfs1_deorphan(lfs1);\n    }\n\n    \n    res = lfs1_pred(lfs1, oldpair, &parent);\n    if (res < 0) {\n        return res;\n    }\n\n    if (res) {\n        \n        parent.d.tail[0] = newpair[0];\n        parent.d.tail[1] = newpair[1];\n\n        return lfs1_dir_commit(lfs1, &parent, NULL, 0);\n    }\n\n    \n    return 0;\n}\n\nint lfs1_deorphan(lfs1_t *lfs1) {\n    lfs1->deorphaned = true;\n\n    if (lfs1_pairisnull(lfs1->root)) {\n        return 0;\n    }\n\n    lfs1_dir_t pdir = {.d.size = 0x80000000};\n    lfs1_dir_t cwd = {.d.tail[0] = 0, .d.tail[1] = 1};\n\n    \n    for (lfs1_size_t i = 0; i < lfs1->cfg->block_count; i++) {\n        if (lfs1_pairisnull(cwd.d.tail)) {\n            return 0;\n        }\n\n        int err = lfs1_dir_fetch(lfs1, &cwd, cwd.d.tail);\n        if (err) {\n            return err;\n        }\n\n        \n        if (!(0x80000000 & pdir.d.size)) {\n            \n            lfs1_dir_t parent;\n            lfs1_entry_t entry;\n            int res = lfs1_parent(lfs1, pdir.d.tail, &parent, &entry);\n            if (res < 0) {\n                return res;\n            }\n\n            if (!res) {\n                \n                LFS1_DEBUG(\"Found orphan %\" PRIu32 \" %\" PRIu32,\n                        pdir.d.tail[0], pdir.d.tail[1]);\n\n                pdir.d.tail[0] = cwd.d.tail[0];\n                pdir.d.tail[1] = cwd.d.tail[1];\n\n                err = lfs1_dir_commit(lfs1, &pdir, NULL, 0);\n                if (err) {\n                    return err;\n                }\n\n                return 0;\n            }\n\n            if (!lfs1_pairsync(entry.d.u.dir, pdir.d.tail)) {\n                \n                LFS1_DEBUG(\"Found desync %\" PRIu32 \" %\" PRIu32,\n                        entry.d.u.dir[0], entry.d.u.dir[1]);\n\n                pdir.d.tail[0] = entry.d.u.dir[0];\n                pdir.d.tail[1] = entry.d.u.dir[1];\n\n                err = lfs1_dir_commit(lfs1, &pdir, NULL, 0);\n                if (err) {\n                    return err;\n                }\n\n                return 0;\n            }\n        }\n\n        \n        lfs1_entry_t entry;\n        while (true) {\n            err = lfs1_dir_next(lfs1, &cwd, &entry);\n            if (err && err != LFS1_ERR_NOENT) {\n                return err;\n            }\n\n            if (err == LFS1_ERR_NOENT) {\n                break;\n            }\n\n            \n            if (entry.d.type & 0x80) {\n                int moved = lfs1_moved(lfs1, &entry.d.u);\n                if (moved < 0) {\n                    return moved;\n                }\n\n                if (moved) {\n                    LFS1_DEBUG(\"Found move %\" PRIu32 \" %\" PRIu32,\n                            entry.d.u.dir[0], entry.d.u.dir[1]);\n                    err = lfs1_dir_remove(lfs1, &cwd, &entry);\n                    if (err) {\n                        return err;\n                    }\n                } else {\n                    LFS1_DEBUG(\"Found partial move %\" PRIu32 \" %\" PRIu32,\n                            entry.d.u.dir[0], entry.d.u.dir[1]);\n                    entry.d.type &= ~0x80;\n                    err = lfs1_dir_update(lfs1, &cwd, &entry, NULL);\n                    if (err) {\n                        return err;\n                    }\n                }\n            }\n        }\n\n        memcpy(&pdir, &cwd, sizeof(pdir));\n    }\n\n    \n    \n    return LFS1_ERR_CORRUPT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}