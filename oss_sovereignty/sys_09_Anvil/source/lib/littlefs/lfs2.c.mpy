{
  "module_name": "lfs2.c",
  "hash_id": "ee6ad655c435844e51a77001ca3c5f8a58e7529fc606bbe9d3b5cede0cd39d97",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/littlefs/lfs2.c",
  "human_readable_source": " \n#include \"lfs2.h\"\n#include \"lfs2_util.h\"\n\n\n\n#define LFS2_BLOCK_NULL ((lfs2_block_t)-1)\n#define LFS2_BLOCK_INLINE ((lfs2_block_t)-2)\n\nenum {\n    LFS2_OK_RELOCATED = 1,\n    LFS2_OK_DROPPED   = 2,\n    LFS2_OK_ORPHANED  = 3,\n};\n\nenum {\n    LFS2_CMP_EQ = 0,\n    LFS2_CMP_LT = 1,\n    LFS2_CMP_GT = 2,\n};\n\n\n\n\nstatic inline void lfs2_cache_drop(lfs2_t *lfs2, lfs2_cache_t *rcache) {\n    \n    \n    (void)lfs2;\n    rcache->block = LFS2_BLOCK_NULL;\n}\n\nstatic inline void lfs2_cache_zero(lfs2_t *lfs2, lfs2_cache_t *pcache) {\n    \n    memset(pcache->buffer, 0xff, lfs2->cfg->cache_size);\n    pcache->block = LFS2_BLOCK_NULL;\n}\n\nstatic int lfs2_bd_read(lfs2_t *lfs2,\n        const lfs2_cache_t *pcache, lfs2_cache_t *rcache, lfs2_size_t hint,\n        lfs2_block_t block, lfs2_off_t off,\n        void *buffer, lfs2_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs2->cfg->block_size\n            || (lfs2->block_count && block >= lfs2->block_count)) {\n        return LFS2_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs2_size_t diff = size;\n\n        if (pcache && block == pcache->block &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                \n                diff = lfs2_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            \n            diff = lfs2_min(diff, pcache->off-off);\n        }\n\n        if (block == rcache->block &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                \n                diff = lfs2_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            \n            diff = lfs2_min(diff, rcache->off-off);\n        }\n\n        if (size >= hint && off % lfs2->cfg->read_size == 0 &&\n                size >= lfs2->cfg->read_size) {\n            \n            diff = lfs2_aligndown(diff, lfs2->cfg->read_size);\n            int err = lfs2->cfg->read(lfs2->cfg, block, off, data, diff);\n            if (err) {\n                return err;\n            }\n\n            data += diff;\n            off += diff;\n            size -= diff;\n            continue;\n        }\n\n        \n        LFS2_ASSERT(!lfs2->block_count || block < lfs2->block_count);\n        rcache->block = block;\n        rcache->off = lfs2_aligndown(off, lfs2->cfg->read_size);\n        rcache->size = lfs2_min(\n                lfs2_min(\n                    lfs2_alignup(off+hint, lfs2->cfg->read_size),\n                    lfs2->cfg->block_size)\n                - rcache->off,\n                lfs2->cfg->cache_size);\n        int err = lfs2->cfg->read(lfs2->cfg, rcache->block,\n                rcache->off, rcache->buffer, rcache->size);\n        LFS2_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\nstatic int lfs2_bd_cmp(lfs2_t *lfs2,\n        const lfs2_cache_t *pcache, lfs2_cache_t *rcache, lfs2_size_t hint,\n        lfs2_block_t block, lfs2_off_t off,\n        const void *buffer, lfs2_size_t size) {\n    const uint8_t *data = buffer;\n    lfs2_size_t diff = 0;\n\n    for (lfs2_off_t i = 0; i < size; i += diff) {\n        uint8_t dat[8];\n\n        diff = lfs2_min(size-i, sizeof(dat));\n        int err = lfs2_bd_read(lfs2,\n                pcache, rcache, hint-i,\n                block, off+i, &dat, diff);\n        if (err) {\n            return err;\n        }\n\n        int res = memcmp(dat, data + i, diff);\n        if (res) {\n            return res < 0 ? LFS2_CMP_LT : LFS2_CMP_GT;\n        }\n    }\n\n    return LFS2_CMP_EQ;\n}\n\nstatic int lfs2_bd_crc(lfs2_t *lfs2,\n        const lfs2_cache_t *pcache, lfs2_cache_t *rcache, lfs2_size_t hint,\n        lfs2_block_t block, lfs2_off_t off, lfs2_size_t size, uint32_t *crc) {\n    lfs2_size_t diff = 0;\n\n    for (lfs2_off_t i = 0; i < size; i += diff) {\n        uint8_t dat[8];\n        diff = lfs2_min(size-i, sizeof(dat));\n        int err = lfs2_bd_read(lfs2,\n                pcache, rcache, hint-i,\n                block, off+i, &dat, diff);\n        if (err) {\n            return err;\n        }\n\n        *crc = lfs2_crc(*crc, &dat, diff);\n    }\n\n    return 0;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_bd_flush(lfs2_t *lfs2,\n        lfs2_cache_t *pcache, lfs2_cache_t *rcache, bool validate) {\n    if (pcache->block != LFS2_BLOCK_NULL && pcache->block != LFS2_BLOCK_INLINE) {\n        LFS2_ASSERT(pcache->block < lfs2->block_count);\n        lfs2_size_t diff = lfs2_alignup(pcache->size, lfs2->cfg->prog_size);\n        int err = lfs2->cfg->prog(lfs2->cfg, pcache->block,\n                pcache->off, pcache->buffer, diff);\n        LFS2_ASSERT(err <= 0);\n        if (err) {\n            return err;\n        }\n\n        if (validate) {\n            \n            lfs2_cache_drop(lfs2, rcache);\n            int res = lfs2_bd_cmp(lfs2,\n                    NULL, rcache, diff,\n                    pcache->block, pcache->off, pcache->buffer, diff);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res != LFS2_CMP_EQ) {\n                return LFS2_ERR_CORRUPT;\n            }\n        }\n\n        lfs2_cache_zero(lfs2, pcache);\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_bd_sync(lfs2_t *lfs2,\n        lfs2_cache_t *pcache, lfs2_cache_t *rcache, bool validate) {\n    lfs2_cache_drop(lfs2, rcache);\n\n    int err = lfs2_bd_flush(lfs2, pcache, rcache, validate);\n    if (err) {\n        return err;\n    }\n\n    err = lfs2->cfg->sync(lfs2->cfg);\n    LFS2_ASSERT(err <= 0);\n    return err;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_bd_prog(lfs2_t *lfs2,\n        lfs2_cache_t *pcache, lfs2_cache_t *rcache, bool validate,\n        lfs2_block_t block, lfs2_off_t off,\n        const void *buffer, lfs2_size_t size) {\n    const uint8_t *data = buffer;\n    LFS2_ASSERT(block == LFS2_BLOCK_INLINE || block < lfs2->block_count);\n    LFS2_ASSERT(off + size <= lfs2->cfg->block_size);\n\n    while (size > 0) {\n        if (block == pcache->block &&\n                off >= pcache->off &&\n                off < pcache->off + lfs2->cfg->cache_size) {\n            \n            lfs2_size_t diff = lfs2_min(size,\n                    lfs2->cfg->cache_size - (off-pcache->off));\n            memcpy(&pcache->buffer[off-pcache->off], data, diff);\n\n            data += diff;\n            off += diff;\n            size -= diff;\n\n            pcache->size = lfs2_max(pcache->size, off - pcache->off);\n            if (pcache->size == lfs2->cfg->cache_size) {\n                \n                int err = lfs2_bd_flush(lfs2, pcache, rcache, validate);\n                if (err) {\n                    return err;\n                }\n            }\n\n            continue;\n        }\n\n        \n        \n        LFS2_ASSERT(pcache->block == LFS2_BLOCK_NULL);\n\n        \n        pcache->block = block;\n        pcache->off = lfs2_aligndown(off, lfs2->cfg->prog_size);\n        pcache->size = 0;\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_bd_erase(lfs2_t *lfs2, lfs2_block_t block) {\n    LFS2_ASSERT(block < lfs2->block_count);\n    int err = lfs2->cfg->erase(lfs2->cfg, block);\n    LFS2_ASSERT(err <= 0);\n    return err;\n}\n#endif\n\n\n\n\nstatic inline void lfs2_pair_swap(lfs2_block_t pair[2]) {\n    lfs2_block_t t = pair[0];\n    pair[0] = pair[1];\n    pair[1] = t;\n}\n\nstatic inline bool lfs2_pair_isnull(const lfs2_block_t pair[2]) {\n    return pair[0] == LFS2_BLOCK_NULL || pair[1] == LFS2_BLOCK_NULL;\n}\n\nstatic inline int lfs2_pair_cmp(\n        const lfs2_block_t paira[2],\n        const lfs2_block_t pairb[2]) {\n    return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||\n             paira[0] == pairb[1] || paira[1] == pairb[0]);\n}\n\nstatic inline bool lfs2_pair_issync(\n        const lfs2_block_t paira[2],\n        const lfs2_block_t pairb[2]) {\n    return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||\n           (paira[0] == pairb[1] && paira[1] == pairb[0]);\n}\n\nstatic inline void lfs2_pair_fromle32(lfs2_block_t pair[2]) {\n    pair[0] = lfs2_fromle32(pair[0]);\n    pair[1] = lfs2_fromle32(pair[1]);\n}\n\n#ifndef LFS2_READONLY\nstatic inline void lfs2_pair_tole32(lfs2_block_t pair[2]) {\n    pair[0] = lfs2_tole32(pair[0]);\n    pair[1] = lfs2_tole32(pair[1]);\n}\n#endif\n\n\ntypedef uint32_t lfs2_tag_t;\ntypedef int32_t lfs2_stag_t;\n\n#define LFS2_MKTAG(type, id, size) \\\n    (((lfs2_tag_t)(type) << 20) | ((lfs2_tag_t)(id) << 10) | (lfs2_tag_t)(size))\n\n#define LFS2_MKTAG_IF(cond, type, id, size) \\\n    ((cond) ? LFS2_MKTAG(type, id, size) : LFS2_MKTAG(LFS2_FROM_NOOP, 0, 0))\n\n#define LFS2_MKTAG_IF_ELSE(cond, type1, id1, size1, type2, id2, size2) \\\n    ((cond) ? LFS2_MKTAG(type1, id1, size1) : LFS2_MKTAG(type2, id2, size2))\n\nstatic inline bool lfs2_tag_isvalid(lfs2_tag_t tag) {\n    return !(tag & 0x80000000);\n}\n\nstatic inline bool lfs2_tag_isdelete(lfs2_tag_t tag) {\n    return ((int32_t)(tag << 22) >> 22) == -1;\n}\n\nstatic inline uint16_t lfs2_tag_type1(lfs2_tag_t tag) {\n    return (tag & 0x70000000) >> 20;\n}\n\nstatic inline uint16_t lfs2_tag_type2(lfs2_tag_t tag) {\n    return (tag & 0x78000000) >> 20;\n}\n\nstatic inline uint16_t lfs2_tag_type3(lfs2_tag_t tag) {\n    return (tag & 0x7ff00000) >> 20;\n}\n\nstatic inline uint8_t lfs2_tag_chunk(lfs2_tag_t tag) {\n    return (tag & 0x0ff00000) >> 20;\n}\n\nstatic inline int8_t lfs2_tag_splice(lfs2_tag_t tag) {\n    return (int8_t)lfs2_tag_chunk(tag);\n}\n\nstatic inline uint16_t lfs2_tag_id(lfs2_tag_t tag) {\n    return (tag & 0x000ffc00) >> 10;\n}\n\nstatic inline lfs2_size_t lfs2_tag_size(lfs2_tag_t tag) {\n    return tag & 0x000003ff;\n}\n\nstatic inline lfs2_size_t lfs2_tag_dsize(lfs2_tag_t tag) {\n    return sizeof(tag) + lfs2_tag_size(tag + lfs2_tag_isdelete(tag));\n}\n\n\nstruct lfs2_mattr {\n    lfs2_tag_t tag;\n    const void *buffer;\n};\n\nstruct lfs2_diskoff {\n    lfs2_block_t block;\n    lfs2_off_t off;\n};\n\n#define LFS2_MKATTRS(...) \\\n    (struct lfs2_mattr[]){__VA_ARGS__}, \\\n    sizeof((struct lfs2_mattr[]){__VA_ARGS__}) / sizeof(struct lfs2_mattr)\n\n\nstatic inline void lfs2_gstate_xor(lfs2_gstate_t *a, const lfs2_gstate_t *b) {\n    for (int i = 0; i < 3; i++) {\n        ((uint32_t*)a)[i] ^= ((const uint32_t*)b)[i];\n    }\n}\n\nstatic inline bool lfs2_gstate_iszero(const lfs2_gstate_t *a) {\n    for (int i = 0; i < 3; i++) {\n        if (((uint32_t*)a)[i] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n#ifndef LFS2_READONLY\nstatic inline bool lfs2_gstate_hasorphans(const lfs2_gstate_t *a) {\n    return lfs2_tag_size(a->tag);\n}\n\nstatic inline uint8_t lfs2_gstate_getorphans(const lfs2_gstate_t *a) {\n    return lfs2_tag_size(a->tag) & 0x1ff;\n}\n\nstatic inline bool lfs2_gstate_hasmove(const lfs2_gstate_t *a) {\n    return lfs2_tag_type1(a->tag);\n}\n#endif\n\nstatic inline bool lfs2_gstate_needssuperblock(const lfs2_gstate_t *a) {\n    return lfs2_tag_size(a->tag) >> 9;\n}\n\nstatic inline bool lfs2_gstate_hasmovehere(const lfs2_gstate_t *a,\n        const lfs2_block_t *pair) {\n    return lfs2_tag_type1(a->tag) && lfs2_pair_cmp(a->pair, pair) == 0;\n}\n\nstatic inline void lfs2_gstate_fromle32(lfs2_gstate_t *a) {\n    a->tag     = lfs2_fromle32(a->tag);\n    a->pair[0] = lfs2_fromle32(a->pair[0]);\n    a->pair[1] = lfs2_fromle32(a->pair[1]);\n}\n\n#ifndef LFS2_READONLY\nstatic inline void lfs2_gstate_tole32(lfs2_gstate_t *a) {\n    a->tag     = lfs2_tole32(a->tag);\n    a->pair[0] = lfs2_tole32(a->pair[0]);\n    a->pair[1] = lfs2_tole32(a->pair[1]);\n}\n#endif\n\n\nstruct lfs2_fcrc {\n    lfs2_size_t size;\n    uint32_t crc;\n};\n\nstatic void lfs2_fcrc_fromle32(struct lfs2_fcrc *fcrc) {\n    fcrc->size = lfs2_fromle32(fcrc->size);\n    fcrc->crc = lfs2_fromle32(fcrc->crc);\n}\n\n#ifndef LFS2_READONLY\nstatic void lfs2_fcrc_tole32(struct lfs2_fcrc *fcrc) {\n    fcrc->size = lfs2_tole32(fcrc->size);\n    fcrc->crc = lfs2_tole32(fcrc->crc);\n}\n#endif\n\n\nstatic void lfs2_ctz_fromle32(struct lfs2_ctz *ctz) {\n    ctz->head = lfs2_fromle32(ctz->head);\n    ctz->size = lfs2_fromle32(ctz->size);\n}\n\n#ifndef LFS2_READONLY\nstatic void lfs2_ctz_tole32(struct lfs2_ctz *ctz) {\n    ctz->head = lfs2_tole32(ctz->head);\n    ctz->size = lfs2_tole32(ctz->size);\n}\n#endif\n\nstatic inline void lfs2_superblock_fromle32(lfs2_superblock_t *superblock) {\n    superblock->version     = lfs2_fromle32(superblock->version);\n    superblock->block_size  = lfs2_fromle32(superblock->block_size);\n    superblock->block_count = lfs2_fromle32(superblock->block_count);\n    superblock->name_max    = lfs2_fromle32(superblock->name_max);\n    superblock->file_max    = lfs2_fromle32(superblock->file_max);\n    superblock->attr_max    = lfs2_fromle32(superblock->attr_max);\n}\n\n#ifndef LFS2_READONLY\nstatic inline void lfs2_superblock_tole32(lfs2_superblock_t *superblock) {\n    superblock->version     = lfs2_tole32(superblock->version);\n    superblock->block_size  = lfs2_tole32(superblock->block_size);\n    superblock->block_count = lfs2_tole32(superblock->block_count);\n    superblock->name_max    = lfs2_tole32(superblock->name_max);\n    superblock->file_max    = lfs2_tole32(superblock->file_max);\n    superblock->attr_max    = lfs2_tole32(superblock->attr_max);\n}\n#endif\n\n#ifndef LFS2_NO_ASSERT\nstatic bool lfs2_mlist_isopen(struct lfs2_mlist *head,\n        struct lfs2_mlist *node) {\n    for (struct lfs2_mlist **p = &head; *p; p = &(*p)->next) {\n        if (*p == (struct lfs2_mlist*)node) {\n            return true;\n        }\n    }\n\n    return false;\n}\n#endif\n\nstatic void lfs2_mlist_remove(lfs2_t *lfs2, struct lfs2_mlist *mlist) {\n    for (struct lfs2_mlist **p = &lfs2->mlist; *p; p = &(*p)->next) {\n        if (*p == mlist) {\n            *p = (*p)->next;\n            break;\n        }\n    }\n}\n\nstatic void lfs2_mlist_append(lfs2_t *lfs2, struct lfs2_mlist *mlist) {\n    mlist->next = lfs2->mlist;\n    lfs2->mlist = mlist;\n}\n\n\nstatic uint32_t lfs2_fs_disk_version(lfs2_t *lfs2) {\n    (void)lfs2;\n#ifdef LFS2_MULTIVERSION\n    if (lfs2->cfg->disk_version) {\n        return lfs2->cfg->disk_version;\n    } else\n#endif\n    {\n        return LFS2_DISK_VERSION;\n    }\n}\n\nstatic uint16_t lfs2_fs_disk_version_major(lfs2_t *lfs2) {\n    return 0xffff & (lfs2_fs_disk_version(lfs2) >> 16);\n\n}\n\nstatic uint16_t lfs2_fs_disk_version_minor(lfs2_t *lfs2) {\n    return 0xffff & (lfs2_fs_disk_version(lfs2) >> 0);\n}\n\n\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_commit(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        const struct lfs2_mattr *attrs, int attrcount);\nstatic int lfs2_dir_compact(lfs2_t *lfs2,\n        lfs2_mdir_t *dir, const struct lfs2_mattr *attrs, int attrcount,\n        lfs2_mdir_t *source, uint16_t begin, uint16_t end);\nstatic lfs2_ssize_t lfs2_file_flushedwrite(lfs2_t *lfs2, lfs2_file_t *file,\n        const void *buffer, lfs2_size_t size);\nstatic lfs2_ssize_t lfs2_file_rawwrite(lfs2_t *lfs2, lfs2_file_t *file,\n        const void *buffer, lfs2_size_t size);\nstatic int lfs2_file_rawsync(lfs2_t *lfs2, lfs2_file_t *file);\nstatic int lfs2_file_outline(lfs2_t *lfs2, lfs2_file_t *file);\nstatic int lfs2_file_flush(lfs2_t *lfs2, lfs2_file_t *file);\n\nstatic int lfs2_fs_deorphan(lfs2_t *lfs2, bool powerloss);\nstatic int lfs2_fs_preporphans(lfs2_t *lfs2, int8_t orphans);\nstatic void lfs2_fs_prepmove(lfs2_t *lfs2,\n        uint16_t id, const lfs2_block_t pair[2]);\nstatic int lfs2_fs_pred(lfs2_t *lfs2, const lfs2_block_t dir[2],\n        lfs2_mdir_t *pdir);\nstatic lfs2_stag_t lfs2_fs_parent(lfs2_t *lfs2, const lfs2_block_t dir[2],\n        lfs2_mdir_t *parent);\nstatic int lfs2_fs_forceconsistency(lfs2_t *lfs2);\n#endif\n\nstatic void lfs2_fs_prepsuperblock(lfs2_t *lfs2, bool needssuperblock);\n\n#ifdef LFS2_MIGRATE\nstatic int lfs21_traverse(lfs2_t *lfs2,\n        int (*cb)(void*, lfs2_block_t), void *data);\n#endif\n\nstatic int lfs2_dir_rawrewind(lfs2_t *lfs2, lfs2_dir_t *dir);\n\nstatic lfs2_ssize_t lfs2_file_flushedread(lfs2_t *lfs2, lfs2_file_t *file,\n        void *buffer, lfs2_size_t size);\nstatic lfs2_ssize_t lfs2_file_rawread(lfs2_t *lfs2, lfs2_file_t *file,\n        void *buffer, lfs2_size_t size);\nstatic int lfs2_file_rawclose(lfs2_t *lfs2, lfs2_file_t *file);\nstatic lfs2_soff_t lfs2_file_rawsize(lfs2_t *lfs2, lfs2_file_t *file);\n\nstatic lfs2_ssize_t lfs2_fs_rawsize(lfs2_t *lfs2);\nstatic int lfs2_fs_rawtraverse(lfs2_t *lfs2,\n        int (*cb)(void *data, lfs2_block_t block), void *data,\n        bool includeorphans);\n\nstatic int lfs2_deinit(lfs2_t *lfs2);\nstatic int lfs2_rawunmount(lfs2_t *lfs2);\n\n\n\n#ifndef LFS2_READONLY\nstatic int lfs2_alloc_lookahead(void *p, lfs2_block_t block) {\n    lfs2_t *lfs2 = (lfs2_t*)p;\n    lfs2_block_t off = ((block - lfs2->free.off)\n            + lfs2->block_count) % lfs2->block_count;\n\n    if (off < lfs2->free.size) {\n        lfs2->free.buffer[off / 32] |= 1U << (off % 32);\n    }\n\n    return 0;\n}\n#endif\n\n\n\n\nstatic void lfs2_alloc_ack(lfs2_t *lfs2) {\n    lfs2->free.ack = lfs2->block_count;\n}\n\n\n\nstatic void lfs2_alloc_drop(lfs2_t *lfs2) {\n    lfs2->free.size = 0;\n    lfs2->free.i = 0;\n    lfs2_alloc_ack(lfs2);\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_rawgc(lfs2_t *lfs2) {\n    \n    \n    lfs2->free.off = (lfs2->free.off + lfs2->free.i) % lfs2->block_count;\n    lfs2->free.size = lfs2_min(8*lfs2->cfg->lookahead_size, lfs2->free.ack);\n    lfs2->free.i = 0;\n\n    \n    memset(lfs2->free.buffer, 0, lfs2->cfg->lookahead_size);\n    int err = lfs2_fs_rawtraverse(lfs2, lfs2_alloc_lookahead, lfs2, true);\n    if (err) {\n        lfs2_alloc_drop(lfs2);\n        return err;\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_alloc(lfs2_t *lfs2, lfs2_block_t *block) {\n    while (true) {\n        while (lfs2->free.i != lfs2->free.size) {\n            lfs2_block_t off = lfs2->free.i;\n            lfs2->free.i += 1;\n            lfs2->free.ack -= 1;\n\n            if (!(lfs2->free.buffer[off / 32] & (1U << (off % 32)))) {\n                \n                *block = (lfs2->free.off + off) % lfs2->block_count;\n\n                \n                \n                while (lfs2->free.i != lfs2->free.size &&\n                        (lfs2->free.buffer[lfs2->free.i / 32]\n                            & (1U << (lfs2->free.i % 32)))) {\n                    lfs2->free.i += 1;\n                    lfs2->free.ack -= 1;\n                }\n\n                return 0;\n            }\n        }\n\n        \n        if (lfs2->free.ack == 0) {\n            LFS2_ERROR(\"No more free space %\"PRIu32,\n                    lfs2->free.i + lfs2->free.off);\n            return LFS2_ERR_NOSPC;\n        }\n\n        int err = lfs2_fs_rawgc(lfs2);\n        if(err) {\n            return err;\n        }\n    }\n}\n#endif\n\n\nstatic lfs2_stag_t lfs2_dir_getslice(lfs2_t *lfs2, const lfs2_mdir_t *dir,\n        lfs2_tag_t gmask, lfs2_tag_t gtag,\n        lfs2_off_t goff, void *gbuffer, lfs2_size_t gsize) {\n    lfs2_off_t off = dir->off;\n    lfs2_tag_t ntag = dir->etag;\n    lfs2_stag_t gdiff = 0;\n\n    if (lfs2_gstate_hasmovehere(&lfs2->gdisk, dir->pair) &&\n            lfs2_tag_id(gmask) != 0 &&\n            lfs2_tag_id(lfs2->gdisk.tag) <= lfs2_tag_id(gtag)) {\n        \n        gdiff -= LFS2_MKTAG(0, 1, 0);\n    }\n\n    \n    while (off >= sizeof(lfs2_tag_t) + lfs2_tag_dsize(ntag)) {\n        off -= lfs2_tag_dsize(ntag);\n        lfs2_tag_t tag = ntag;\n        int err = lfs2_bd_read(lfs2,\n                NULL, &lfs2->rcache, sizeof(ntag),\n                dir->pair[0], off, &ntag, sizeof(ntag));\n        if (err) {\n            return err;\n        }\n\n        ntag = (lfs2_frombe32(ntag) ^ tag) & 0x7fffffff;\n\n        if (lfs2_tag_id(gmask) != 0 &&\n                lfs2_tag_type1(tag) == LFS2_TYPE_SPLICE &&\n                lfs2_tag_id(tag) <= lfs2_tag_id(gtag - gdiff)) {\n            if (tag == (LFS2_MKTAG(LFS2_TYPE_CREATE, 0, 0) |\n                    (LFS2_MKTAG(0, 0x3ff, 0) & (gtag - gdiff)))) {\n                \n                return LFS2_ERR_NOENT;\n            }\n\n            \n            gdiff += LFS2_MKTAG(0, lfs2_tag_splice(tag), 0);\n        }\n\n        if ((gmask & tag) == (gmask & (gtag - gdiff))) {\n            if (lfs2_tag_isdelete(tag)) {\n                return LFS2_ERR_NOENT;\n            }\n\n            lfs2_size_t diff = lfs2_min(lfs2_tag_size(tag), gsize);\n            err = lfs2_bd_read(lfs2,\n                    NULL, &lfs2->rcache, diff,\n                    dir->pair[0], off+sizeof(tag)+goff, gbuffer, diff);\n            if (err) {\n                return err;\n            }\n\n            memset((uint8_t*)gbuffer + diff, 0, gsize - diff);\n\n            return tag + gdiff;\n        }\n    }\n\n    return LFS2_ERR_NOENT;\n}\n\nstatic lfs2_stag_t lfs2_dir_get(lfs2_t *lfs2, const lfs2_mdir_t *dir,\n        lfs2_tag_t gmask, lfs2_tag_t gtag, void *buffer) {\n    return lfs2_dir_getslice(lfs2, dir,\n            gmask, gtag,\n            0, buffer, lfs2_tag_size(gtag));\n}\n\nstatic int lfs2_dir_getread(lfs2_t *lfs2, const lfs2_mdir_t *dir,\n        const lfs2_cache_t *pcache, lfs2_cache_t *rcache, lfs2_size_t hint,\n        lfs2_tag_t gmask, lfs2_tag_t gtag,\n        lfs2_off_t off, void *buffer, lfs2_size_t size) {\n    uint8_t *data = buffer;\n    if (off+size > lfs2->cfg->block_size) {\n        return LFS2_ERR_CORRUPT;\n    }\n\n    while (size > 0) {\n        lfs2_size_t diff = size;\n\n        if (pcache && pcache->block == LFS2_BLOCK_INLINE &&\n                off < pcache->off + pcache->size) {\n            if (off >= pcache->off) {\n                \n                diff = lfs2_min(diff, pcache->size - (off-pcache->off));\n                memcpy(data, &pcache->buffer[off-pcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            \n            diff = lfs2_min(diff, pcache->off-off);\n        }\n\n        if (rcache->block == LFS2_BLOCK_INLINE &&\n                off < rcache->off + rcache->size) {\n            if (off >= rcache->off) {\n                \n                diff = lfs2_min(diff, rcache->size - (off-rcache->off));\n                memcpy(data, &rcache->buffer[off-rcache->off], diff);\n\n                data += diff;\n                off += diff;\n                size -= diff;\n                continue;\n            }\n\n            \n            diff = lfs2_min(diff, rcache->off-off);\n        }\n\n        \n        rcache->block = LFS2_BLOCK_INLINE;\n        rcache->off = lfs2_aligndown(off, lfs2->cfg->read_size);\n        rcache->size = lfs2_min(lfs2_alignup(off+hint, lfs2->cfg->read_size),\n                lfs2->cfg->cache_size);\n        int err = lfs2_dir_getslice(lfs2, dir, gmask, gtag,\n                rcache->off, rcache->buffer, rcache->size);\n        if (err < 0) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_traverse_filter(void *p,\n        lfs2_tag_t tag, const void *buffer) {\n    lfs2_tag_t *filtertag = p;\n    (void)buffer;\n\n    \n    uint32_t mask = (tag & LFS2_MKTAG(0x100, 0, 0))\n            ? LFS2_MKTAG(0x7ff, 0x3ff, 0)\n            : LFS2_MKTAG(0x700, 0x3ff, 0);\n\n    \n    if ((mask & tag) == (mask & *filtertag) ||\n            lfs2_tag_isdelete(*filtertag) ||\n            (LFS2_MKTAG(0x7ff, 0x3ff, 0) & tag) == (\n                LFS2_MKTAG(LFS2_TYPE_DELETE, 0, 0) |\n                    (LFS2_MKTAG(0, 0x3ff, 0) & *filtertag))) {\n        *filtertag = LFS2_MKTAG(LFS2_FROM_NOOP, 0, 0);\n        return true;\n    }\n\n    \n    if (lfs2_tag_type1(tag) == LFS2_TYPE_SPLICE &&\n            lfs2_tag_id(tag) <= lfs2_tag_id(*filtertag)) {\n        *filtertag += LFS2_MKTAG(0, lfs2_tag_splice(tag), 0);\n    }\n\n    return false;\n}\n#endif\n\n#ifndef LFS2_READONLY\n\n\n\n\n\n\n#define LFS2_DIR_TRAVERSE_DEPTH 3\n\nstruct lfs2_dir_traverse {\n    const lfs2_mdir_t *dir;\n    lfs2_off_t off;\n    lfs2_tag_t ptag;\n    const struct lfs2_mattr *attrs;\n    int attrcount;\n\n    lfs2_tag_t tmask;\n    lfs2_tag_t ttag;\n    uint16_t begin;\n    uint16_t end;\n    int16_t diff;\n\n    int (*cb)(void *data, lfs2_tag_t tag, const void *buffer);\n    void *data;\n\n    lfs2_tag_t tag;\n    const void *buffer;\n    struct lfs2_diskoff disk;\n};\n\nstatic int lfs2_dir_traverse(lfs2_t *lfs2,\n        const lfs2_mdir_t *dir, lfs2_off_t off, lfs2_tag_t ptag,\n        const struct lfs2_mattr *attrs, int attrcount,\n        lfs2_tag_t tmask, lfs2_tag_t ttag,\n        uint16_t begin, uint16_t end, int16_t diff,\n        int (*cb)(void *data, lfs2_tag_t tag, const void *buffer), void *data) {\n    \n    \n    struct lfs2_dir_traverse stack[LFS2_DIR_TRAVERSE_DEPTH-1];\n    unsigned sp = 0;\n    int res;\n\n    \n    lfs2_tag_t tag;\n    const void *buffer;\n    struct lfs2_diskoff disk = {0};\n    while (true) {\n        {\n            if (off+lfs2_tag_dsize(ptag) < dir->off) {\n                off += lfs2_tag_dsize(ptag);\n                int err = lfs2_bd_read(lfs2,\n                        NULL, &lfs2->rcache, sizeof(tag),\n                        dir->pair[0], off, &tag, sizeof(tag));\n                if (err) {\n                    return err;\n                }\n\n                tag = (lfs2_frombe32(tag) ^ ptag) | 0x80000000;\n                disk.block = dir->pair[0];\n                disk.off = off+sizeof(lfs2_tag_t);\n                buffer = &disk;\n                ptag = tag;\n            } else if (attrcount > 0) {\n                tag = attrs[0].tag;\n                buffer = attrs[0].buffer;\n                attrs += 1;\n                attrcount -= 1;\n            } else {\n                \n                res = 0;\n                break;\n            }\n\n            \n            lfs2_tag_t mask = LFS2_MKTAG(0x7ff, 0, 0);\n            if ((mask & tmask & tag) != (mask & tmask & ttag)) {\n                continue;\n            }\n\n            if (lfs2_tag_id(tmask) != 0) {\n                LFS2_ASSERT(sp < LFS2_DIR_TRAVERSE_DEPTH);\n                \n                \n                stack[sp] = (struct lfs2_dir_traverse){\n                    .dir        = dir,\n                    .off        = off,\n                    .ptag       = ptag,\n                    .attrs      = attrs,\n                    .attrcount  = attrcount,\n                    .tmask      = tmask,\n                    .ttag       = ttag,\n                    .begin      = begin,\n                    .end        = end,\n                    .diff       = diff,\n                    .cb         = cb,\n                    .data       = data,\n                    .tag        = tag,\n                    .buffer     = buffer,\n                    .disk       = disk,\n                };\n                sp += 1;\n\n                tmask = 0;\n                ttag = 0;\n                begin = 0;\n                end = 0;\n                diff = 0;\n                cb = lfs2_dir_traverse_filter;\n                data = &stack[sp-1].tag;\n                continue;\n            }\n        }\n\npopped:\n        \n        if (lfs2_tag_id(tmask) != 0 &&\n                !(lfs2_tag_id(tag) >= begin && lfs2_tag_id(tag) < end)) {\n            continue;\n        }\n\n        \n        if (lfs2_tag_type3(tag) == LFS2_FROM_NOOP) {\n            \n        } else if (lfs2_tag_type3(tag) == LFS2_FROM_MOVE) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            if (cb == lfs2_dir_traverse_filter) {\n                continue;\n            }\n\n            \n            stack[sp] = (struct lfs2_dir_traverse){\n                .dir        = dir,\n                .off        = off,\n                .ptag       = ptag,\n                .attrs      = attrs,\n                .attrcount  = attrcount,\n                .tmask      = tmask,\n                .ttag       = ttag,\n                .begin      = begin,\n                .end        = end,\n                .diff       = diff,\n                .cb         = cb,\n                .data       = data,\n                .tag        = LFS2_MKTAG(LFS2_FROM_NOOP, 0, 0),\n            };\n            sp += 1;\n\n            uint16_t fromid = lfs2_tag_size(tag);\n            uint16_t toid = lfs2_tag_id(tag);\n            dir = buffer;\n            off = 0;\n            ptag = 0xffffffff;\n            attrs = NULL;\n            attrcount = 0;\n            tmask = LFS2_MKTAG(0x600, 0x3ff, 0);\n            ttag = LFS2_MKTAG(LFS2_TYPE_STRUCT, 0, 0);\n            begin = fromid;\n            end = fromid+1;\n            diff = toid-fromid+diff;\n        } else if (lfs2_tag_type3(tag) == LFS2_FROM_USERATTRS) {\n            for (unsigned i = 0; i < lfs2_tag_size(tag); i++) {\n                const struct lfs2_attr *a = buffer;\n                res = cb(data, LFS2_MKTAG(LFS2_TYPE_USERATTR + a[i].type,\n                        lfs2_tag_id(tag) + diff, a[i].size), a[i].buffer);\n                if (res < 0) {\n                    return res;\n                }\n\n                if (res) {\n                    break;\n                }\n            }\n        } else {\n            res = cb(data, tag + LFS2_MKTAG(0, diff, 0), buffer);\n            if (res < 0) {\n                return res;\n            }\n\n            if (res) {\n                break;\n            }\n        }\n    }\n\n    if (sp > 0) {\n        \n        \n        dir         = stack[sp-1].dir;\n        off         = stack[sp-1].off;\n        ptag        = stack[sp-1].ptag;\n        attrs       = stack[sp-1].attrs;\n        attrcount   = stack[sp-1].attrcount;\n        tmask       = stack[sp-1].tmask;\n        ttag        = stack[sp-1].ttag;\n        begin       = stack[sp-1].begin;\n        end         = stack[sp-1].end;\n        diff        = stack[sp-1].diff;\n        cb          = stack[sp-1].cb;\n        data        = stack[sp-1].data;\n        tag         = stack[sp-1].tag;\n        buffer      = stack[sp-1].buffer;\n        disk        = stack[sp-1].disk;\n        sp -= 1;\n        goto popped;\n    } else {\n        return res;\n    }\n}\n#endif\n\nstatic lfs2_stag_t lfs2_dir_fetchmatch(lfs2_t *lfs2,\n        lfs2_mdir_t *dir, const lfs2_block_t pair[2],\n        lfs2_tag_t fmask, lfs2_tag_t ftag, uint16_t *id,\n        int (*cb)(void *data, lfs2_tag_t tag, const void *buffer), void *data) {\n    \n    \n    lfs2_stag_t besttag = -1;\n\n    \n    \n    if (lfs2->block_count \n            && (pair[0] >= lfs2->block_count || pair[1] >= lfs2->block_count)) {\n        return LFS2_ERR_CORRUPT;\n    }\n\n    \n    uint32_t revs[2] = {0, 0};\n    int r = 0;\n    for (int i = 0; i < 2; i++) {\n        int err = lfs2_bd_read(lfs2,\n                NULL, &lfs2->rcache, sizeof(revs[i]),\n                pair[i], 0, &revs[i], sizeof(revs[i]));\n        revs[i] = lfs2_fromle32(revs[i]);\n        if (err && err != LFS2_ERR_CORRUPT) {\n            return err;\n        }\n\n        if (err != LFS2_ERR_CORRUPT &&\n                lfs2_scmp(revs[i], revs[(i+1)%2]) > 0) {\n            r = i;\n        }\n    }\n\n    dir->pair[0] = pair[(r+0)%2];\n    dir->pair[1] = pair[(r+1)%2];\n    dir->rev = revs[(r+0)%2];\n    dir->off = 0; \n\n    \n    for (int i = 0; i < 2; i++) {\n        lfs2_off_t off = 0;\n        lfs2_tag_t ptag = 0xffffffff;\n\n        uint16_t tempcount = 0;\n        lfs2_block_t temptail[2] = {LFS2_BLOCK_NULL, LFS2_BLOCK_NULL};\n        bool tempsplit = false;\n        lfs2_stag_t tempbesttag = besttag;\n\n        \n        bool maybeerased = false;\n        bool hasfcrc = false;\n        struct lfs2_fcrc fcrc;\n\n        dir->rev = lfs2_tole32(dir->rev);\n        uint32_t crc = lfs2_crc(0xffffffff, &dir->rev, sizeof(dir->rev));\n        dir->rev = lfs2_fromle32(dir->rev);\n\n        while (true) {\n            \n            lfs2_tag_t tag;\n            off += lfs2_tag_dsize(ptag);\n            int err = lfs2_bd_read(lfs2,\n                    NULL, &lfs2->rcache, lfs2->cfg->block_size,\n                    dir->pair[0], off, &tag, sizeof(tag));\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    \n                    break;\n                }\n                return err;\n            }\n\n            crc = lfs2_crc(crc, &tag, sizeof(tag));\n            tag = lfs2_frombe32(tag) ^ ptag;\n\n            \n            if (!lfs2_tag_isvalid(tag)) {\n                \n                maybeerased = (lfs2_tag_type2(ptag) == LFS2_TYPE_CCRC);\n                break;\n            \n            } else if (off + lfs2_tag_dsize(tag) > lfs2->cfg->block_size) {\n                break;\n            }\n\n            ptag = tag;\n\n            if (lfs2_tag_type2(tag) == LFS2_TYPE_CCRC) {\n                \n                uint32_t dcrc;\n                err = lfs2_bd_read(lfs2,\n                        NULL, &lfs2->rcache, lfs2->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag), &dcrc, sizeof(dcrc));\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        break;\n                    }\n                    return err;\n                }\n                dcrc = lfs2_fromle32(dcrc);\n\n                if (crc != dcrc) {\n                    break;\n                }\n\n                \n                ptag ^= (lfs2_tag_t)(lfs2_tag_chunk(tag) & 1U) << 31;\n\n                \n                \n                \n                \n                lfs2->seed = lfs2_crc(lfs2->seed, &crc, sizeof(crc));\n\n                \n                besttag = tempbesttag;\n                dir->off = off + lfs2_tag_dsize(tag);\n                dir->etag = ptag;\n                dir->count = tempcount;\n                dir->tail[0] = temptail[0];\n                dir->tail[1] = temptail[1];\n                dir->split = tempsplit;\n\n                \n                crc = 0xffffffff;\n                continue;\n            }\n\n            \n            err = lfs2_bd_crc(lfs2,\n                    NULL, &lfs2->rcache, lfs2->cfg->block_size,\n                    dir->pair[0], off+sizeof(tag),\n                    lfs2_tag_dsize(tag)-sizeof(tag), &crc);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    break;\n                }\n                return err;\n            }\n\n            \n            if (lfs2_tag_type1(tag) == LFS2_TYPE_NAME) {\n                \n                if (lfs2_tag_id(tag) >= tempcount) {\n                    tempcount = lfs2_tag_id(tag) + 1;\n                }\n            } else if (lfs2_tag_type1(tag) == LFS2_TYPE_SPLICE) {\n                tempcount += lfs2_tag_splice(tag);\n\n                if (tag == (LFS2_MKTAG(LFS2_TYPE_DELETE, 0, 0) |\n                        (LFS2_MKTAG(0, 0x3ff, 0) & tempbesttag))) {\n                    tempbesttag |= 0x80000000;\n                } else if (tempbesttag != -1 &&\n                        lfs2_tag_id(tag) <= lfs2_tag_id(tempbesttag)) {\n                    tempbesttag += LFS2_MKTAG(0, lfs2_tag_splice(tag), 0);\n                }\n            } else if (lfs2_tag_type1(tag) == LFS2_TYPE_TAIL) {\n                tempsplit = (lfs2_tag_chunk(tag) & 1);\n\n                err = lfs2_bd_read(lfs2,\n                        NULL, &lfs2->rcache, lfs2->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag), &temptail, 8);\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        break;\n                    }\n                    return err;\n                }\n                lfs2_pair_fromle32(temptail);\n            } else if (lfs2_tag_type3(tag) == LFS2_TYPE_FCRC) {\n                err = lfs2_bd_read(lfs2,\n                        NULL, &lfs2->rcache, lfs2->cfg->block_size,\n                        dir->pair[0], off+sizeof(tag),\n                        &fcrc, sizeof(fcrc));\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        break;\n                    }\n                }\n\n                lfs2_fcrc_fromle32(&fcrc);\n                hasfcrc = true;\n            }\n\n            \n            if ((fmask & tag) == (fmask & ftag)) {\n                int res = cb(data, tag, &(struct lfs2_diskoff){\n                        dir->pair[0], off+sizeof(tag)});\n                if (res < 0) {\n                    if (res == LFS2_ERR_CORRUPT) {\n                        break;\n                    }\n                    return res;\n                }\n\n                if (res == LFS2_CMP_EQ) {\n                    \n                    tempbesttag = tag;\n                } else if ((LFS2_MKTAG(0x7ff, 0x3ff, 0) & tag) ==\n                        (LFS2_MKTAG(0x7ff, 0x3ff, 0) & tempbesttag)) {\n                    \n                    \n                    tempbesttag = -1;\n                } else if (res == LFS2_CMP_GT &&\n                        lfs2_tag_id(tag) <= lfs2_tag_id(tempbesttag)) {\n                    \n                    tempbesttag = tag | 0x80000000;\n                }\n            }\n        }\n\n        \n        if (dir->off == 0) {\n            \n            lfs2_pair_swap(dir->pair);\n            dir->rev = revs[(r+1)%2];\n            continue;\n        }\n\n        \n        dir->erased = false;\n        if (maybeerased && dir->off % lfs2->cfg->prog_size == 0) {\n        #ifdef LFS2_MULTIVERSION\n            \n            \n            \n            \n            \n            if (lfs2_fs_disk_version(lfs2) < 0x00020001) {\n                dir->erased = true;\n\n            } else\n        #endif\n            if (hasfcrc) {\n                \n                \n                \n                uint32_t fcrc_ = 0xffffffff;\n                int err = lfs2_bd_crc(lfs2,\n                        NULL, &lfs2->rcache, lfs2->cfg->block_size,\n                        dir->pair[0], dir->off, fcrc.size, &fcrc_);\n                if (err && err != LFS2_ERR_CORRUPT) {\n                    return err;\n                }\n\n                \n                dir->erased = (fcrc_ == fcrc.crc);\n            }\n        }\n\n        \n        if (lfs2_gstate_hasmovehere(&lfs2->gdisk, dir->pair)) {\n            if (lfs2_tag_id(lfs2->gdisk.tag) == lfs2_tag_id(besttag)) {\n                besttag |= 0x80000000;\n            } else if (besttag != -1 &&\n                    lfs2_tag_id(lfs2->gdisk.tag) < lfs2_tag_id(besttag)) {\n                besttag -= LFS2_MKTAG(0, 1, 0);\n            }\n        }\n\n        \n        if (id) {\n            *id = lfs2_min(lfs2_tag_id(besttag), dir->count);\n        }\n\n        if (lfs2_tag_isvalid(besttag)) {\n            return besttag;\n        } else if (lfs2_tag_id(besttag) < dir->count) {\n            return LFS2_ERR_NOENT;\n        } else {\n            return 0;\n        }\n    }\n\n    LFS2_ERROR(\"Corrupted dir pair at {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n            dir->pair[0], dir->pair[1]);\n    return LFS2_ERR_CORRUPT;\n}\n\nstatic int lfs2_dir_fetch(lfs2_t *lfs2,\n        lfs2_mdir_t *dir, const lfs2_block_t pair[2]) {\n    \n    \n    return (int)lfs2_dir_fetchmatch(lfs2, dir, pair,\n            (lfs2_tag_t)-1, (lfs2_tag_t)-1, NULL, NULL, NULL);\n}\n\nstatic int lfs2_dir_getgstate(lfs2_t *lfs2, const lfs2_mdir_t *dir,\n        lfs2_gstate_t *gstate) {\n    lfs2_gstate_t temp;\n    lfs2_stag_t res = lfs2_dir_get(lfs2, dir, LFS2_MKTAG(0x7ff, 0, 0),\n            LFS2_MKTAG(LFS2_TYPE_MOVESTATE, 0, sizeof(temp)), &temp);\n    if (res < 0 && res != LFS2_ERR_NOENT) {\n        return res;\n    }\n\n    if (res != LFS2_ERR_NOENT) {\n        \n        lfs2_gstate_fromle32(&temp);\n        lfs2_gstate_xor(gstate, &temp);\n    }\n\n    return 0;\n}\n\nstatic int lfs2_dir_getinfo(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        uint16_t id, struct lfs2_info *info) {\n    if (id == 0x3ff) {\n        \n        strcpy(info->name, \"/\");\n        info->type = LFS2_TYPE_DIR;\n        return 0;\n    }\n\n    lfs2_stag_t tag = lfs2_dir_get(lfs2, dir, LFS2_MKTAG(0x780, 0x3ff, 0),\n            LFS2_MKTAG(LFS2_TYPE_NAME, id, lfs2->name_max+1), info->name);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    info->type = lfs2_tag_type3(tag);\n\n    struct lfs2_ctz ctz;\n    tag = lfs2_dir_get(lfs2, dir, LFS2_MKTAG(0x700, 0x3ff, 0),\n            LFS2_MKTAG(LFS2_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n    if (tag < 0) {\n        return (int)tag;\n    }\n    lfs2_ctz_fromle32(&ctz);\n\n    if (lfs2_tag_type3(tag) == LFS2_TYPE_CTZSTRUCT) {\n        info->size = ctz.size;\n    } else if (lfs2_tag_type3(tag) == LFS2_TYPE_INLINESTRUCT) {\n        info->size = lfs2_tag_size(tag);\n    }\n\n    return 0;\n}\n\nstruct lfs2_dir_find_match {\n    lfs2_t *lfs2;\n    const void *name;\n    lfs2_size_t size;\n};\n\nstatic int lfs2_dir_find_match(void *data,\n        lfs2_tag_t tag, const void *buffer) {\n    struct lfs2_dir_find_match *name = data;\n    lfs2_t *lfs2 = name->lfs2;\n    const struct lfs2_diskoff *disk = buffer;\n\n    \n    lfs2_size_t diff = lfs2_min(name->size, lfs2_tag_size(tag));\n    int res = lfs2_bd_cmp(lfs2,\n            NULL, &lfs2->rcache, diff,\n            disk->block, disk->off, name->name, diff);\n    if (res != LFS2_CMP_EQ) {\n        return res;\n    }\n\n    \n    if (name->size != lfs2_tag_size(tag)) {\n        return (name->size < lfs2_tag_size(tag)) ? LFS2_CMP_LT : LFS2_CMP_GT;\n    }\n\n    \n    return LFS2_CMP_EQ;\n}\n\nstatic lfs2_stag_t lfs2_dir_find(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        const char **path, uint16_t *id) {\n    \n    const char *name = *path;\n    if (id) {\n        *id = 0x3ff;\n    }\n\n    \n    lfs2_stag_t tag = LFS2_MKTAG(LFS2_TYPE_DIR, 0x3ff, 0);\n    dir->tail[0] = lfs2->root[0];\n    dir->tail[1] = lfs2->root[1];\n\n    while (true) {\nnextname:\n        \n        name += strspn(name, \"/\");\n        lfs2_size_t namelen = strcspn(name, \"/\");\n\n        \n        if ((namelen == 1 && memcmp(name, \".\", 1) == 0) ||\n            (namelen == 2 && memcmp(name, \"..\", 2) == 0)) {\n            name += namelen;\n            goto nextname;\n        }\n\n        \n        const char *suffix = name + namelen;\n        lfs2_size_t sufflen;\n        int depth = 1;\n        while (true) {\n            suffix += strspn(suffix, \"/\");\n            sufflen = strcspn(suffix, \"/\");\n            if (sufflen == 0) {\n                break;\n            }\n\n            if (sufflen == 2 && memcmp(suffix, \"..\", 2) == 0) {\n                depth -= 1;\n                if (depth == 0) {\n                    name = suffix + sufflen;\n                    goto nextname;\n                }\n            } else {\n                depth += 1;\n            }\n\n            suffix += sufflen;\n        }\n\n        \n        if (name[0] == '\\0') {\n            return tag;\n        }\n\n        \n        *path = name;\n\n        \n        if (lfs2_tag_type3(tag) != LFS2_TYPE_DIR) {\n            return LFS2_ERR_NOTDIR;\n        }\n\n        \n        if (lfs2_tag_id(tag) != 0x3ff) {\n            lfs2_stag_t res = lfs2_dir_get(lfs2, dir, LFS2_MKTAG(0x700, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_STRUCT, lfs2_tag_id(tag), 8), dir->tail);\n            if (res < 0) {\n                return res;\n            }\n            lfs2_pair_fromle32(dir->tail);\n        }\n\n        \n        while (true) {\n            tag = lfs2_dir_fetchmatch(lfs2, dir, dir->tail,\n                    LFS2_MKTAG(0x780, 0, 0),\n                    LFS2_MKTAG(LFS2_TYPE_NAME, 0, namelen),\n                     \n                    (strchr(name, '/') == NULL) ? id : NULL,\n                    lfs2_dir_find_match, &(struct lfs2_dir_find_match){\n                        lfs2, name, namelen});\n            if (tag < 0) {\n                return tag;\n            }\n\n            if (tag) {\n                break;\n            }\n\n            if (!dir->split) {\n                return LFS2_ERR_NOENT;\n            }\n        }\n\n        \n        name += namelen;\n    }\n}\n\n\nstruct lfs2_commit {\n    lfs2_block_t block;\n    lfs2_off_t off;\n    lfs2_tag_t ptag;\n    uint32_t crc;\n\n    lfs2_off_t begin;\n    lfs2_off_t end;\n};\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_commitprog(lfs2_t *lfs2, struct lfs2_commit *commit,\n        const void *buffer, lfs2_size_t size) {\n    int err = lfs2_bd_prog(lfs2,\n            &lfs2->pcache, &lfs2->rcache, false,\n            commit->block, commit->off ,\n            (const uint8_t*)buffer, size);\n    if (err) {\n        return err;\n    }\n\n    commit->crc = lfs2_crc(commit->crc, buffer, size);\n    commit->off += size;\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_commitattr(lfs2_t *lfs2, struct lfs2_commit *commit,\n        lfs2_tag_t tag, const void *buffer) {\n    \n    lfs2_size_t dsize = lfs2_tag_dsize(tag);\n    if (commit->off + dsize > commit->end) {\n        return LFS2_ERR_NOSPC;\n    }\n\n    \n    lfs2_tag_t ntag = lfs2_tobe32((tag & 0x7fffffff) ^ commit->ptag);\n    int err = lfs2_dir_commitprog(lfs2, commit, &ntag, sizeof(ntag));\n    if (err) {\n        return err;\n    }\n\n    if (!(tag & 0x80000000)) {\n        \n        err = lfs2_dir_commitprog(lfs2, commit, buffer, dsize-sizeof(tag));\n        if (err) {\n            return err;\n        }\n    } else {\n        \n        const struct lfs2_diskoff *disk = buffer;\n        for (lfs2_off_t i = 0; i < dsize-sizeof(tag); i++) {\n            \n            uint8_t dat;\n            err = lfs2_bd_read(lfs2,\n                    NULL, &lfs2->rcache, dsize-sizeof(tag)-i,\n                    disk->block, disk->off+i, &dat, 1);\n            if (err) {\n                return err;\n            }\n\n            err = lfs2_dir_commitprog(lfs2, commit, &dat, 1);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    commit->ptag = tag & 0x7fffffff;\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\n\nstatic int lfs2_dir_commitcrc(lfs2_t *lfs2, struct lfs2_commit *commit) {\n    \n    \n    \n    \n    \n    const lfs2_off_t end = lfs2_alignup(\n            lfs2_min(commit->off + 5*sizeof(uint32_t), lfs2->cfg->block_size),\n            lfs2->cfg->prog_size);\n\n    lfs2_off_t off1 = 0;\n    uint32_t crc1 = 0;\n\n    \n    \n    \n    while (commit->off < end) {\n        lfs2_off_t noff = (\n                lfs2_min(end - (commit->off+sizeof(lfs2_tag_t)), 0x3fe)\n                + (commit->off+sizeof(lfs2_tag_t)));\n        \n        if (noff < end) {\n            noff = lfs2_min(noff, end - 5*sizeof(uint32_t));\n        }\n\n        \n        uint8_t eperturb = (uint8_t)-1;\n        if (noff >= end && noff <= lfs2->cfg->block_size - lfs2->cfg->prog_size) {\n            \n            \n            int err = lfs2_bd_read(lfs2,\n                    NULL, &lfs2->rcache, lfs2->cfg->prog_size,\n                    commit->block, noff, &eperturb, 1);\n            if (err && err != LFS2_ERR_CORRUPT) {\n                return err;\n            }\n\n        #ifdef LFS2_MULTIVERSION\n            \n            \n            if (lfs2_fs_disk_version(lfs2) <= 0x00020000) {\n                \n            } else\n        #endif\n            {\n                \n                \n                struct lfs2_fcrc fcrc = {\n                    .size = lfs2->cfg->prog_size,\n                    .crc = 0xffffffff\n                };\n                err = lfs2_bd_crc(lfs2,\n                        NULL, &lfs2->rcache, lfs2->cfg->prog_size,\n                        commit->block, noff, fcrc.size, &fcrc.crc);\n                if (err && err != LFS2_ERR_CORRUPT) {\n                    return err;\n                }\n\n                lfs2_fcrc_tole32(&fcrc);\n                err = lfs2_dir_commitattr(lfs2, commit,\n                        LFS2_MKTAG(LFS2_TYPE_FCRC, 0x3ff, sizeof(struct lfs2_fcrc)),\n                        &fcrc);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        \n        struct {\n            lfs2_tag_t tag;\n            uint32_t crc;\n        } ccrc;\n        lfs2_tag_t ntag = LFS2_MKTAG(\n                LFS2_TYPE_CCRC + (((uint8_t)~eperturb) >> 7), 0x3ff,\n                noff - (commit->off+sizeof(lfs2_tag_t)));\n        ccrc.tag = lfs2_tobe32(ntag ^ commit->ptag);\n        commit->crc = lfs2_crc(commit->crc, &ccrc.tag, sizeof(lfs2_tag_t));\n        ccrc.crc = lfs2_tole32(commit->crc);\n\n        int err = lfs2_bd_prog(lfs2,\n                &lfs2->pcache, &lfs2->rcache, false,\n                commit->block, commit->off, &ccrc, sizeof(ccrc));\n        if (err) {\n            return err;\n        }\n\n        \n        if (off1 == 0) {\n            off1 = commit->off + sizeof(lfs2_tag_t);\n            crc1 = commit->crc;\n        }\n\n        commit->off = noff;\n        \n        commit->ptag = ntag ^ ((0x80UL & ~eperturb) << 24);\n        \n        commit->crc = 0xffffffff;\n\n        \n        \n        if (noff >= end || noff >= lfs2->pcache.off + lfs2->cfg->cache_size) {\n            \n            int err = lfs2_bd_sync(lfs2, &lfs2->pcache, &lfs2->rcache, false);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    \n    \n    \n    \n    lfs2_off_t off = commit->begin;\n    uint32_t crc = 0xffffffff;\n    int err = lfs2_bd_crc(lfs2,\n            NULL, &lfs2->rcache, off1+sizeof(uint32_t),\n            commit->block, off, off1-off, &crc);\n    if (err) {\n        return err;\n    }\n\n    \n    if (crc != crc1) {\n        return LFS2_ERR_CORRUPT;\n    }\n\n    \n    \n    err = lfs2_bd_crc(lfs2,\n            NULL, &lfs2->rcache, sizeof(uint32_t),\n            commit->block, off1, sizeof(uint32_t), &crc);\n    if (err) {\n        return err;\n    }\n\n    if (crc != 0) {\n        return LFS2_ERR_CORRUPT;\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_alloc(lfs2_t *lfs2, lfs2_mdir_t *dir) {\n    \n    for (int i = 0; i < 2; i++) {\n        int err = lfs2_alloc(lfs2, &dir->pair[(i+1)%2]);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    dir->rev = 0;\n\n    \n    \n    int err = lfs2_bd_read(lfs2,\n            NULL, &lfs2->rcache, sizeof(dir->rev),\n            dir->pair[0], 0, &dir->rev, sizeof(dir->rev));\n    dir->rev = lfs2_fromle32(dir->rev);\n    if (err && err != LFS2_ERR_CORRUPT) {\n        return err;\n    }\n\n    \n    \n    \n    if (lfs2->cfg->block_cycles > 0) {\n        dir->rev = lfs2_alignup(dir->rev, ((lfs2->cfg->block_cycles+1)|1));\n    }\n\n    \n    dir->off = sizeof(dir->rev);\n    dir->etag = 0xffffffff;\n    dir->count = 0;\n    dir->tail[0] = LFS2_BLOCK_NULL;\n    dir->tail[1] = LFS2_BLOCK_NULL;\n    dir->erased = false;\n    dir->split = false;\n\n    \n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_drop(lfs2_t *lfs2, lfs2_mdir_t *dir, lfs2_mdir_t *tail) {\n    \n    int err = lfs2_dir_getgstate(lfs2, tail, &lfs2->gdelta);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs2_pair_tole32(tail->tail);\n    err = lfs2_dir_commit(lfs2, dir, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_TAIL + tail->split, 0x3ff, 8), tail->tail}));\n    lfs2_pair_fromle32(tail->tail);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_split(lfs2_t *lfs2,\n        lfs2_mdir_t *dir, const struct lfs2_mattr *attrs, int attrcount,\n        lfs2_mdir_t *source, uint16_t split, uint16_t end) {\n    \n    lfs2_mdir_t tail;\n    int err = lfs2_dir_alloc(lfs2, &tail);\n    if (err) {\n        return err;\n    }\n\n    tail.split = dir->split;\n    tail.tail[0] = dir->tail[0];\n    tail.tail[1] = dir->tail[1];\n\n    \n    int res = lfs2_dir_compact(lfs2, &tail, attrs, attrcount, source, split, end);\n    if (res < 0) {\n        return res;\n    }\n\n    dir->tail[0] = tail.pair[0];\n    dir->tail[1] = tail.pair[1];\n    dir->split = true;\n\n    \n    if (lfs2_pair_cmp(dir->pair, lfs2->root) == 0 && split == 0) {\n        lfs2->root[0] = tail.pair[0];\n        lfs2->root[1] = tail.pair[1];\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_commit_size(void *p, lfs2_tag_t tag, const void *buffer) {\n    lfs2_size_t *size = p;\n    (void)buffer;\n\n    *size += lfs2_tag_dsize(tag);\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstruct lfs2_dir_commit_commit {\n    lfs2_t *lfs2;\n    struct lfs2_commit *commit;\n};\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_commit_commit(void *p, lfs2_tag_t tag, const void *buffer) {\n    struct lfs2_dir_commit_commit *commit = p;\n    return lfs2_dir_commitattr(commit->lfs2, commit->commit, tag, buffer);\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic bool lfs2_dir_needsrelocation(lfs2_t *lfs2, lfs2_mdir_t *dir) {\n    \n    \n    \n    \n    \n    \n    return (lfs2->cfg->block_cycles > 0\n            && ((dir->rev + 1) % ((lfs2->cfg->block_cycles+1)|1) == 0));\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_compact(lfs2_t *lfs2,\n        lfs2_mdir_t *dir, const struct lfs2_mattr *attrs, int attrcount,\n        lfs2_mdir_t *source, uint16_t begin, uint16_t end) {\n    \n    bool relocated = false;\n    bool tired = lfs2_dir_needsrelocation(lfs2, dir);\n\n    \n    dir->rev += 1;\n\n    \n    \n    \n    \n    \n    \n#ifdef LFS2_MIGRATE\n    if (lfs2->lfs21) {\n        tired = false;\n    }\n#endif\n\n    if (tired && lfs2_pair_cmp(dir->pair, (const lfs2_block_t[2]){0, 1}) != 0) {\n        \n        goto relocate;\n    }\n\n    \n    while (true) {\n        {\n            \n            struct lfs2_commit commit = {\n                .block = dir->pair[1],\n                .off = 0,\n                .ptag = 0xffffffff,\n                .crc = 0xffffffff,\n\n                .begin = 0,\n                .end = (lfs2->cfg->metadata_max ?\n                    lfs2->cfg->metadata_max : lfs2->cfg->block_size) - 8,\n            };\n\n            \n            int err = lfs2_bd_erase(lfs2, dir->pair[1]);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            \n            dir->rev = lfs2_tole32(dir->rev);\n            err = lfs2_dir_commitprog(lfs2, &commit,\n                    &dir->rev, sizeof(dir->rev));\n            dir->rev = lfs2_fromle32(dir->rev);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            \n            err = lfs2_dir_traverse(lfs2,\n                    source, 0, 0xffffffff, attrs, attrcount,\n                    LFS2_MKTAG(0x400, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_NAME, 0, 0),\n                    begin, end, -begin,\n                    lfs2_dir_commit_commit, &(struct lfs2_dir_commit_commit){\n                        lfs2, &commit});\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            \n            if (!lfs2_pair_isnull(dir->tail)) {\n                lfs2_pair_tole32(dir->tail);\n                err = lfs2_dir_commitattr(lfs2, &commit,\n                        LFS2_MKTAG(LFS2_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail);\n                lfs2_pair_fromle32(dir->tail);\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            \n            lfs2_gstate_t delta = {0};\n            if (!relocated) {\n                lfs2_gstate_xor(&delta, &lfs2->gdisk);\n                lfs2_gstate_xor(&delta, &lfs2->gstate);\n            }\n            lfs2_gstate_xor(&delta, &lfs2->gdelta);\n            delta.tag &= ~LFS2_MKTAG(0, 0, 0x3ff);\n\n            err = lfs2_dir_getgstate(lfs2, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            if (!lfs2_gstate_iszero(&delta)) {\n                lfs2_gstate_tole32(&delta);\n                err = lfs2_dir_commitattr(lfs2, &commit,\n                        LFS2_MKTAG(LFS2_TYPE_MOVESTATE, 0x3ff,\n                            sizeof(delta)), &delta);\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n            }\n\n            \n            err = lfs2_dir_commitcrc(lfs2, &commit);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            \n            LFS2_ASSERT(commit.off % lfs2->cfg->prog_size == 0);\n            lfs2_pair_swap(dir->pair);\n            dir->count = end - begin;\n            dir->off = commit.off;\n            dir->etag = commit.ptag;\n            \n            lfs2->gdelta = (lfs2_gstate_t){0};\n            if (!relocated) {\n                lfs2->gdisk = lfs2->gstate;\n            }\n        }\n        break;\n\nrelocate:\n        \n        relocated = true;\n        lfs2_cache_drop(lfs2, &lfs2->pcache);\n        if (!tired) {\n            LFS2_DEBUG(\"Bad block at 0x%\"PRIx32, dir->pair[1]);\n        }\n\n        \n        if (lfs2_pair_cmp(dir->pair, (const lfs2_block_t[2]){0, 1}) == 0) {\n            LFS2_WARN(\"Superblock 0x%\"PRIx32\" has become unwritable\",\n                    dir->pair[1]);\n            return LFS2_ERR_NOSPC;\n        }\n\n        \n        int err = lfs2_alloc(lfs2, &dir->pair[1]);\n        if (err && (err != LFS2_ERR_NOSPC || !tired)) {\n            return err;\n        }\n\n        tired = false;\n        continue;\n    }\n\n    return relocated ? LFS2_OK_RELOCATED : 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_splittingcompact(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        const struct lfs2_mattr *attrs, int attrcount,\n        lfs2_mdir_t *source, uint16_t begin, uint16_t end) {\n    while (true) {\n        \n        \n        \n        \n        \n        \n        lfs2_size_t split = begin;\n        while (end - split > 1) {\n            lfs2_size_t size = 0;\n            int err = lfs2_dir_traverse(lfs2,\n                    source, 0, 0xffffffff, attrs, attrcount,\n                    LFS2_MKTAG(0x400, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_NAME, 0, 0),\n                    split, end, -split,\n                    lfs2_dir_commit_size, &size);\n            if (err) {\n                return err;\n            }\n\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            if (end - split < 0xff\n                    && size <= lfs2_min(\n                        lfs2->cfg->block_size - 40,\n                        lfs2_alignup(\n                            (lfs2->cfg->metadata_max\n                                ? lfs2->cfg->metadata_max\n                                : lfs2->cfg->block_size)/2,\n                            lfs2->cfg->prog_size))) {\n                break;\n            }\n\n            split = split + ((end - split) / 2);\n        }\n\n        if (split == begin) {\n            \n            break;\n        }\n\n        \n        int err = lfs2_dir_split(lfs2, dir, attrs, attrcount,\n                source, split, end);\n        if (err && err != LFS2_ERR_NOSPC) {\n            return err;\n        }\n\n        if (err) {\n            \n            \n            LFS2_WARN(\"Unable to split {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                    dir->pair[0], dir->pair[1]);\n            break;\n        } else {\n            end = split;\n        }\n    }\n\n    if (lfs2_dir_needsrelocation(lfs2, dir)\n            && lfs2_pair_cmp(dir->pair, (const lfs2_block_t[2]){0, 1}) == 0) {\n        \n        \n        lfs2_ssize_t size = lfs2_fs_rawsize(lfs2);\n        if (size < 0) {\n            return size;\n        }\n\n        \n        \n        if ((lfs2_size_t)size < lfs2->block_count/2) {\n            LFS2_DEBUG(\"Expanding superblock at rev %\"PRIu32, dir->rev);\n            int err = lfs2_dir_split(lfs2, dir, attrs, attrcount,\n                    source, begin, end);\n            if (err && err != LFS2_ERR_NOSPC) {\n                return err;\n            }\n\n            if (err) {\n                \n                \n                LFS2_WARN(\"Unable to expand superblock\");\n            } else {\n                end = begin;\n            }\n        }\n    }\n\n    return lfs2_dir_compact(lfs2, dir, attrs, attrcount, source, begin, end);\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_relocatingcommit(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        const lfs2_block_t pair[2],\n        const struct lfs2_mattr *attrs, int attrcount,\n        lfs2_mdir_t *pdir) {\n    int state = 0;\n\n    \n    bool hasdelete = false;\n    for (int i = 0; i < attrcount; i++) {\n        if (lfs2_tag_type3(attrs[i].tag) == LFS2_TYPE_CREATE) {\n            dir->count += 1;\n        } else if (lfs2_tag_type3(attrs[i].tag) == LFS2_TYPE_DELETE) {\n            LFS2_ASSERT(dir->count > 0);\n            dir->count -= 1;\n            hasdelete = true;\n        } else if (lfs2_tag_type1(attrs[i].tag) == LFS2_TYPE_TAIL) {\n            dir->tail[0] = ((lfs2_block_t*)attrs[i].buffer)[0];\n            dir->tail[1] = ((lfs2_block_t*)attrs[i].buffer)[1];\n            dir->split = (lfs2_tag_chunk(attrs[i].tag) & 1);\n            lfs2_pair_fromle32(dir->tail);\n        }\n    }\n\n    \n    if (hasdelete && dir->count == 0) {\n        LFS2_ASSERT(pdir);\n        int err = lfs2_fs_pred(lfs2, dir->pair, pdir);\n        if (err && err != LFS2_ERR_NOENT) {\n            return err;\n        }\n\n        if (err != LFS2_ERR_NOENT && pdir->split) {\n            state = LFS2_OK_DROPPED;\n            goto fixmlist;\n        }\n    }\n\n    if (dir->erased) {\n        \n        struct lfs2_commit commit = {\n            .block = dir->pair[0],\n            .off = dir->off,\n            .ptag = dir->etag,\n            .crc = 0xffffffff,\n\n            .begin = dir->off,\n            .end = (lfs2->cfg->metadata_max ?\n                lfs2->cfg->metadata_max : lfs2->cfg->block_size) - 8,\n        };\n\n        \n        lfs2_pair_tole32(dir->tail);\n        int err = lfs2_dir_traverse(lfs2,\n                dir, dir->off, dir->etag, attrs, attrcount,\n                0, 0, 0, 0, 0,\n                lfs2_dir_commit_commit, &(struct lfs2_dir_commit_commit){\n                    lfs2, &commit});\n        lfs2_pair_fromle32(dir->tail);\n        if (err) {\n            if (err == LFS2_ERR_NOSPC || err == LFS2_ERR_CORRUPT) {\n                goto compact;\n            }\n            return err;\n        }\n\n        \n        lfs2_gstate_t delta = {0};\n        lfs2_gstate_xor(&delta, &lfs2->gstate);\n        lfs2_gstate_xor(&delta, &lfs2->gdisk);\n        lfs2_gstate_xor(&delta, &lfs2->gdelta);\n        delta.tag &= ~LFS2_MKTAG(0, 0, 0x3ff);\n        if (!lfs2_gstate_iszero(&delta)) {\n            err = lfs2_dir_getgstate(lfs2, dir, &delta);\n            if (err) {\n                return err;\n            }\n\n            lfs2_gstate_tole32(&delta);\n            err = lfs2_dir_commitattr(lfs2, &commit,\n                    LFS2_MKTAG(LFS2_TYPE_MOVESTATE, 0x3ff,\n                        sizeof(delta)), &delta);\n            if (err) {\n                if (err == LFS2_ERR_NOSPC || err == LFS2_ERR_CORRUPT) {\n                    goto compact;\n                }\n                return err;\n            }\n        }\n\n        \n        err = lfs2_dir_commitcrc(lfs2, &commit);\n        if (err) {\n            if (err == LFS2_ERR_NOSPC || err == LFS2_ERR_CORRUPT) {\n                goto compact;\n            }\n            return err;\n        }\n\n        \n        LFS2_ASSERT(commit.off % lfs2->cfg->prog_size == 0);\n        dir->off = commit.off;\n        dir->etag = commit.ptag;\n        \n        lfs2->gdisk = lfs2->gstate;\n        lfs2->gdelta = (lfs2_gstate_t){0};\n\n        goto fixmlist;\n    }\n\ncompact:\n    \n    lfs2_cache_drop(lfs2, &lfs2->pcache);\n\n    state = lfs2_dir_splittingcompact(lfs2, dir, attrs, attrcount,\n            dir, 0, dir->count);\n    if (state < 0) {\n        return state;\n    }\n\n    goto fixmlist;\n\nfixmlist:;\n    \n    \n    \n    \n    \n    \n    \n    lfs2_block_t oldpair[2] = {pair[0], pair[1]};\n    for (struct lfs2_mlist *d = lfs2->mlist; d; d = d->next) {\n        if (lfs2_pair_cmp(d->m.pair, oldpair) == 0) {\n            d->m = *dir;\n            if (d->m.pair != pair) {\n                for (int i = 0; i < attrcount; i++) {\n                    if (lfs2_tag_type3(attrs[i].tag) == LFS2_TYPE_DELETE &&\n                            d->id == lfs2_tag_id(attrs[i].tag)) {\n                        d->m.pair[0] = LFS2_BLOCK_NULL;\n                        d->m.pair[1] = LFS2_BLOCK_NULL;\n                    } else if (lfs2_tag_type3(attrs[i].tag) == LFS2_TYPE_DELETE &&\n                            d->id > lfs2_tag_id(attrs[i].tag)) {\n                        d->id -= 1;\n                        if (d->type == LFS2_TYPE_DIR) {\n                            ((lfs2_dir_t*)d)->pos -= 1;\n                        }\n                    } else if (lfs2_tag_type3(attrs[i].tag) == LFS2_TYPE_CREATE &&\n                            d->id >= lfs2_tag_id(attrs[i].tag)) {\n                        d->id += 1;\n                        if (d->type == LFS2_TYPE_DIR) {\n                            ((lfs2_dir_t*)d)->pos += 1;\n                        }\n                    }\n                }\n            }\n\n            while (d->id >= d->m.count && d->m.split) {\n                \n                d->id -= d->m.count;\n                int err = lfs2_dir_fetch(lfs2, &d->m, d->m.tail);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n    }\n\n    return state;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_orphaningcommit(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        const struct lfs2_mattr *attrs, int attrcount) {\n    \n    \n    for (lfs2_file_t *f = (lfs2_file_t*)lfs2->mlist; f; f = f->next) {\n        if (dir != &f->m && lfs2_pair_cmp(f->m.pair, dir->pair) == 0 &&\n                f->type == LFS2_TYPE_REG && (f->flags & LFS2_F_INLINE) &&\n                f->ctz.size > lfs2->cfg->cache_size) {\n            int err = lfs2_file_outline(lfs2, f);\n            if (err) {\n                return err;\n            }\n\n            err = lfs2_file_flush(lfs2, f);\n            if (err) {\n                return err;\n            }\n        }\n    }\n\n    lfs2_block_t lpair[2] = {dir->pair[0], dir->pair[1]};\n    lfs2_mdir_t ldir = *dir;\n    lfs2_mdir_t pdir;\n    int state = lfs2_dir_relocatingcommit(lfs2, &ldir, dir->pair,\n            attrs, attrcount, &pdir);\n    if (state < 0) {\n        return state;\n    }\n\n    \n    \n    if (lfs2_pair_cmp(dir->pair, lpair) == 0) {\n        *dir = ldir;\n    }\n\n    \n    \n    \n\n    \n    if (state == LFS2_OK_DROPPED) {\n        \n        int err = lfs2_dir_getgstate(lfs2, dir, &lfs2->gdelta);\n        if (err) {\n            return err;\n        }\n\n        \n        lpair[0] = pdir.pair[0];\n        lpair[1] = pdir.pair[1];\n        lfs2_pair_tole32(dir->tail);\n        state = lfs2_dir_relocatingcommit(lfs2, &pdir, lpair, LFS2_MKATTRS(\n                    {LFS2_MKTAG(LFS2_TYPE_TAIL + dir->split, 0x3ff, 8),\n                        dir->tail}),\n                NULL);\n        lfs2_pair_fromle32(dir->tail);\n        if (state < 0) {\n            return state;\n        }\n\n        ldir = pdir;\n    }\n\n    \n    bool orphans = false;\n    while (state == LFS2_OK_RELOCATED) {\n        LFS2_DEBUG(\"Relocating {0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                    \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                lpair[0], lpair[1], ldir.pair[0], ldir.pair[1]);\n        state = 0;\n\n        \n        if (lfs2_pair_cmp(lpair, lfs2->root) == 0) {\n            lfs2->root[0] = ldir.pair[0];\n            lfs2->root[1] = ldir.pair[1];\n        }\n\n        \n        for (struct lfs2_mlist *d = lfs2->mlist; d; d = d->next) {\n            if (lfs2_pair_cmp(lpair, d->m.pair) == 0) {\n                d->m.pair[0] = ldir.pair[0];\n                d->m.pair[1] = ldir.pair[1];\n            }\n\n            if (d->type == LFS2_TYPE_DIR &&\n                    lfs2_pair_cmp(lpair, ((lfs2_dir_t*)d)->head) == 0) {\n                ((lfs2_dir_t*)d)->head[0] = ldir.pair[0];\n                ((lfs2_dir_t*)d)->head[1] = ldir.pair[1];\n            }\n        }\n\n        \n        lfs2_stag_t tag = lfs2_fs_parent(lfs2, lpair, &pdir);\n        if (tag < 0 && tag != LFS2_ERR_NOENT) {\n            return tag;\n        }\n\n        bool hasparent = (tag != LFS2_ERR_NOENT);\n        if (tag != LFS2_ERR_NOENT) {\n            \n            \n            int err = lfs2_fs_preporphans(lfs2, +1);\n            if (err) {\n                return err;\n            }\n\n            \n            \n            uint16_t moveid = 0x3ff;\n            if (lfs2_gstate_hasmovehere(&lfs2->gstate, pdir.pair)) {\n                moveid = lfs2_tag_id(lfs2->gstate.tag);\n                LFS2_DEBUG(\"Fixing move while relocating \"\n                        \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                        pdir.pair[0], pdir.pair[1], moveid);\n                lfs2_fs_prepmove(lfs2, 0x3ff, NULL);\n                if (moveid < lfs2_tag_id(tag)) {\n                    tag -= LFS2_MKTAG(0, 1, 0);\n                }\n            }\n\n            lfs2_block_t ppair[2] = {pdir.pair[0], pdir.pair[1]};\n            lfs2_pair_tole32(ldir.pair);\n            state = lfs2_dir_relocatingcommit(lfs2, &pdir, ppair, LFS2_MKATTRS(\n                        {LFS2_MKTAG_IF(moveid != 0x3ff,\n                            LFS2_TYPE_DELETE, moveid, 0), NULL},\n                        {tag, ldir.pair}),\n                    NULL);\n            lfs2_pair_fromle32(ldir.pair);\n            if (state < 0) {\n                return state;\n            }\n\n            if (state == LFS2_OK_RELOCATED) {\n                lpair[0] = ppair[0];\n                lpair[1] = ppair[1];\n                ldir = pdir;\n                orphans = true;\n                continue;\n            }\n        }\n\n        \n        int err = lfs2_fs_pred(lfs2, lpair, &pdir);\n        if (err && err != LFS2_ERR_NOENT) {\n            return err;\n        }\n        LFS2_ASSERT(!(hasparent && err == LFS2_ERR_NOENT));\n\n        \n        if (err != LFS2_ERR_NOENT) {\n            if (lfs2_gstate_hasorphans(&lfs2->gstate)) {\n                \n                err = lfs2_fs_preporphans(lfs2, -hasparent);\n                if (err) {\n                    return err;\n                }\n            }\n\n            \n            \n            uint16_t moveid = 0x3ff;\n            if (lfs2_gstate_hasmovehere(&lfs2->gstate, pdir.pair)) {\n                moveid = lfs2_tag_id(lfs2->gstate.tag);\n                LFS2_DEBUG(\"Fixing move while relocating \"\n                        \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                        pdir.pair[0], pdir.pair[1], moveid);\n                lfs2_fs_prepmove(lfs2, 0x3ff, NULL);\n            }\n\n            \n            lpair[0] = pdir.pair[0];\n            lpair[1] = pdir.pair[1];\n            lfs2_pair_tole32(ldir.pair);\n            state = lfs2_dir_relocatingcommit(lfs2, &pdir, lpair, LFS2_MKATTRS(\n                        {LFS2_MKTAG_IF(moveid != 0x3ff,\n                            LFS2_TYPE_DELETE, moveid, 0), NULL},\n                        {LFS2_MKTAG(LFS2_TYPE_TAIL + pdir.split, 0x3ff, 8),\n                            ldir.pair}),\n                    NULL);\n            lfs2_pair_fromle32(ldir.pair);\n            if (state < 0) {\n                return state;\n            }\n\n            ldir = pdir;\n        }\n    }\n\n    return orphans ? LFS2_OK_ORPHANED : 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_dir_commit(lfs2_t *lfs2, lfs2_mdir_t *dir,\n        const struct lfs2_mattr *attrs, int attrcount) {\n    int orphans = lfs2_dir_orphaningcommit(lfs2, dir, attrs, attrcount);\n    if (orphans < 0) {\n        return orphans;\n    }\n\n    if (orphans) {\n        \n        \n        \n        int err = lfs2_fs_deorphan(lfs2, false);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n#endif\n\n\n\n#ifndef LFS2_READONLY\nstatic int lfs2_rawmkdir(lfs2_t *lfs2, const char *path) {\n    \n    int err = lfs2_fs_forceconsistency(lfs2);\n    if (err) {\n        return err;\n    }\n\n    struct lfs2_mlist cwd;\n    cwd.next = lfs2->mlist;\n    uint16_t id;\n    err = lfs2_dir_find(lfs2, &cwd.m, &path, &id);\n    if (!(err == LFS2_ERR_NOENT && id != 0x3ff)) {\n        return (err < 0) ? err : LFS2_ERR_EXIST;\n    }\n\n    \n    lfs2_size_t nlen = strlen(path);\n    if (nlen > lfs2->name_max) {\n        return LFS2_ERR_NAMETOOLONG;\n    }\n\n    \n    lfs2_alloc_ack(lfs2);\n    lfs2_mdir_t dir;\n    err = lfs2_dir_alloc(lfs2, &dir);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs2_mdir_t pred = cwd.m;\n    while (pred.split) {\n        err = lfs2_dir_fetch(lfs2, &pred, pred.tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    lfs2_pair_tole32(pred.tail);\n    err = lfs2_dir_commit(lfs2, &dir, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));\n    lfs2_pair_fromle32(pred.tail);\n    if (err) {\n        return err;\n    }\n\n    \n    if (cwd.m.split) {\n        \n        err = lfs2_fs_preporphans(lfs2, +1);\n        if (err) {\n            return err;\n        }\n\n        \n        \n        \n        \n        cwd.type = 0;\n        cwd.id = 0;\n        lfs2->mlist = &cwd;\n\n        lfs2_pair_tole32(dir.pair);\n        err = lfs2_dir_commit(lfs2, &pred, LFS2_MKATTRS(\n                {LFS2_MKTAG(LFS2_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n        lfs2_pair_fromle32(dir.pair);\n        if (err) {\n            lfs2->mlist = cwd.next;\n            return err;\n        }\n\n        lfs2->mlist = cwd.next;\n        err = lfs2_fs_preporphans(lfs2, -1);\n        if (err) {\n            return err;\n        }\n    }\n\n    \n    lfs2_pair_tole32(dir.pair);\n    err = lfs2_dir_commit(lfs2, &cwd.m, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_CREATE, id, 0), NULL},\n            {LFS2_MKTAG(LFS2_TYPE_DIR, id, nlen), path},\n            {LFS2_MKTAG(LFS2_TYPE_DIRSTRUCT, id, 8), dir.pair},\n            {LFS2_MKTAG_IF(!cwd.m.split,\n                LFS2_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));\n    lfs2_pair_fromle32(dir.pair);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n#endif\n\nstatic int lfs2_dir_rawopen(lfs2_t *lfs2, lfs2_dir_t *dir, const char *path) {\n    lfs2_stag_t tag = lfs2_dir_find(lfs2, &dir->m, &path, NULL);\n    if (tag < 0) {\n        return tag;\n    }\n\n    if (lfs2_tag_type3(tag) != LFS2_TYPE_DIR) {\n        return LFS2_ERR_NOTDIR;\n    }\n\n    lfs2_block_t pair[2];\n    if (lfs2_tag_id(tag) == 0x3ff) {\n        \n        pair[0] = lfs2->root[0];\n        pair[1] = lfs2->root[1];\n    } else {\n        \n        lfs2_stag_t res = lfs2_dir_get(lfs2, &dir->m, LFS2_MKTAG(0x700, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_STRUCT, lfs2_tag_id(tag), 8), pair);\n        if (res < 0) {\n            return res;\n        }\n        lfs2_pair_fromle32(pair);\n    }\n\n    \n    int err = lfs2_dir_fetch(lfs2, &dir->m, pair);\n    if (err) {\n        return err;\n    }\n\n    \n    dir->head[0] = dir->m.pair[0];\n    dir->head[1] = dir->m.pair[1];\n    dir->id = 0;\n    dir->pos = 0;\n\n    \n    dir->type = LFS2_TYPE_DIR;\n    lfs2_mlist_append(lfs2, (struct lfs2_mlist *)dir);\n\n    return 0;\n}\n\nstatic int lfs2_dir_rawclose(lfs2_t *lfs2, lfs2_dir_t *dir) {\n    \n    lfs2_mlist_remove(lfs2, (struct lfs2_mlist *)dir);\n\n    return 0;\n}\n\nstatic int lfs2_dir_rawread(lfs2_t *lfs2, lfs2_dir_t *dir, struct lfs2_info *info) {\n    memset(info, 0, sizeof(*info));\n\n    \n    if (dir->pos == 0) {\n        info->type = LFS2_TYPE_DIR;\n        strcpy(info->name, \".\");\n        dir->pos += 1;\n        return true;\n    } else if (dir->pos == 1) {\n        info->type = LFS2_TYPE_DIR;\n        strcpy(info->name, \"..\");\n        dir->pos += 1;\n        return true;\n    }\n\n    while (true) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return false;\n            }\n\n            int err = lfs2_dir_fetch(lfs2, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int err = lfs2_dir_getinfo(lfs2, &dir->m, dir->id, info);\n        if (err && err != LFS2_ERR_NOENT) {\n            return err;\n        }\n\n        dir->id += 1;\n        if (err != LFS2_ERR_NOENT) {\n            break;\n        }\n    }\n\n    dir->pos += 1;\n    return true;\n}\n\nstatic int lfs2_dir_rawseek(lfs2_t *lfs2, lfs2_dir_t *dir, lfs2_off_t off) {\n    \n    int err = lfs2_dir_rawrewind(lfs2, dir);\n    if (err) {\n        return err;\n    }\n\n    \n    dir->pos = lfs2_min(2, off);\n    off -= dir->pos;\n\n    \n    dir->id = (off > 0 && lfs2_pair_cmp(dir->head, lfs2->root) == 0);\n\n    while (off > 0) {\n        if (dir->id == dir->m.count) {\n            if (!dir->m.split) {\n                return LFS2_ERR_INVAL;\n            }\n\n            err = lfs2_dir_fetch(lfs2, &dir->m, dir->m.tail);\n            if (err) {\n                return err;\n            }\n\n            dir->id = 0;\n        }\n\n        int diff = lfs2_min(dir->m.count - dir->id, off);\n        dir->id += diff;\n        dir->pos += diff;\n        off -= diff;\n    }\n\n    return 0;\n}\n\nstatic lfs2_soff_t lfs2_dir_rawtell(lfs2_t *lfs2, lfs2_dir_t *dir) {\n    (void)lfs2;\n    return dir->pos;\n}\n\nstatic int lfs2_dir_rawrewind(lfs2_t *lfs2, lfs2_dir_t *dir) {\n    \n    int err = lfs2_dir_fetch(lfs2, &dir->m, dir->head);\n    if (err) {\n        return err;\n    }\n\n    dir->id = 0;\n    dir->pos = 0;\n    return 0;\n}\n\n\n\nstatic int lfs2_ctz_index(lfs2_t *lfs2, lfs2_off_t *off) {\n    lfs2_off_t size = *off;\n    lfs2_off_t b = lfs2->cfg->block_size - 2*4;\n    lfs2_off_t i = size / b;\n    if (i == 0) {\n        return 0;\n    }\n\n    i = (size - 4*(lfs2_popc(i-1)+2)) / b;\n    *off = size - b*i - 4*lfs2_popc(i);\n    return i;\n}\n\nstatic int lfs2_ctz_find(lfs2_t *lfs2,\n        const lfs2_cache_t *pcache, lfs2_cache_t *rcache,\n        lfs2_block_t head, lfs2_size_t size,\n        lfs2_size_t pos, lfs2_block_t *block, lfs2_off_t *off) {\n    if (size == 0) {\n        *block = LFS2_BLOCK_NULL;\n        *off = 0;\n        return 0;\n    }\n\n    lfs2_off_t current = lfs2_ctz_index(lfs2, &(lfs2_off_t){size-1});\n    lfs2_off_t target = lfs2_ctz_index(lfs2, &pos);\n\n    while (current > target) {\n        lfs2_size_t skip = lfs2_min(\n                lfs2_npw2(current-target+1) - 1,\n                lfs2_ctz(current));\n\n        int err = lfs2_bd_read(lfs2,\n                pcache, rcache, sizeof(head),\n                head, 4*skip, &head, sizeof(head));\n        head = lfs2_fromle32(head);\n        if (err) {\n            return err;\n        }\n\n        current -= 1 << skip;\n    }\n\n    *block = head;\n    *off = pos;\n    return 0;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_ctz_extend(lfs2_t *lfs2,\n        lfs2_cache_t *pcache, lfs2_cache_t *rcache,\n        lfs2_block_t head, lfs2_size_t size,\n        lfs2_block_t *block, lfs2_off_t *off) {\n    while (true) {\n        \n        lfs2_block_t nblock;\n        int err = lfs2_alloc(lfs2, &nblock);\n        if (err) {\n            return err;\n        }\n\n        {\n            err = lfs2_bd_erase(lfs2, nblock);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n\n            if (size == 0) {\n                *block = nblock;\n                *off = 0;\n                return 0;\n            }\n\n            lfs2_size_t noff = size - 1;\n            lfs2_off_t index = lfs2_ctz_index(lfs2, &noff);\n            noff = noff + 1;\n\n            \n            if (noff != lfs2->cfg->block_size) {\n                for (lfs2_off_t i = 0; i < noff; i++) {\n                    uint8_t data;\n                    err = lfs2_bd_read(lfs2,\n                            NULL, rcache, noff-i,\n                            head, i, &data, 1);\n                    if (err) {\n                        return err;\n                    }\n\n                    err = lfs2_bd_prog(lfs2,\n                            pcache, rcache, true,\n                            nblock, i, &data, 1);\n                    if (err) {\n                        if (err == LFS2_ERR_CORRUPT) {\n                            goto relocate;\n                        }\n                        return err;\n                    }\n                }\n\n                *block = nblock;\n                *off = noff;\n                return 0;\n            }\n\n            \n            index += 1;\n            lfs2_size_t skips = lfs2_ctz(index) + 1;\n            lfs2_block_t nhead = head;\n            for (lfs2_off_t i = 0; i < skips; i++) {\n                nhead = lfs2_tole32(nhead);\n                err = lfs2_bd_prog(lfs2, pcache, rcache, true,\n                        nblock, 4*i, &nhead, 4);\n                nhead = lfs2_fromle32(nhead);\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n\n                if (i != skips-1) {\n                    err = lfs2_bd_read(lfs2,\n                            NULL, rcache, sizeof(nhead),\n                            nhead, 4*i, &nhead, sizeof(nhead));\n                    nhead = lfs2_fromle32(nhead);\n                    if (err) {\n                        return err;\n                    }\n                }\n            }\n\n            *block = nblock;\n            *off = 4*skips;\n            return 0;\n        }\n\nrelocate:\n        LFS2_DEBUG(\"Bad block at 0x%\"PRIx32, nblock);\n\n        \n        lfs2_cache_drop(lfs2, pcache);\n    }\n}\n#endif\n\nstatic int lfs2_ctz_traverse(lfs2_t *lfs2,\n        const lfs2_cache_t *pcache, lfs2_cache_t *rcache,\n        lfs2_block_t head, lfs2_size_t size,\n        int (*cb)(void*, lfs2_block_t), void *data) {\n    if (size == 0) {\n        return 0;\n    }\n\n    lfs2_off_t index = lfs2_ctz_index(lfs2, &(lfs2_off_t){size-1});\n\n    while (true) {\n        int err = cb(data, head);\n        if (err) {\n            return err;\n        }\n\n        if (index == 0) {\n            return 0;\n        }\n\n        lfs2_block_t heads[2];\n        int count = 2 - (index & 1);\n        err = lfs2_bd_read(lfs2,\n                pcache, rcache, count*sizeof(head),\n                head, 0, &heads, count*sizeof(head));\n        heads[0] = lfs2_fromle32(heads[0]);\n        heads[1] = lfs2_fromle32(heads[1]);\n        if (err) {\n            return err;\n        }\n\n        for (int i = 0; i < count-1; i++) {\n            err = cb(data, heads[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        head = heads[count-1];\n        index -= count;\n    }\n}\n\n\n\nstatic int lfs2_file_rawopencfg(lfs2_t *lfs2, lfs2_file_t *file,\n        const char *path, int flags,\n        const struct lfs2_file_config *cfg) {\n#ifndef LFS2_READONLY\n    \n    if ((flags & LFS2_O_WRONLY) == LFS2_O_WRONLY) {\n        int err = lfs2_fs_forceconsistency(lfs2);\n        if (err) {\n            return err;\n        }\n    }\n#else\n    LFS2_ASSERT((flags & LFS2_O_RDONLY) == LFS2_O_RDONLY);\n#endif\n\n    \n    int err;\n    file->cfg = cfg;\n    file->flags = flags;\n    file->pos = 0;\n    file->off = 0;\n    file->cache.buffer = NULL;\n\n    \n    lfs2_stag_t tag = lfs2_dir_find(lfs2, &file->m, &path, &file->id);\n    if (tag < 0 && !(tag == LFS2_ERR_NOENT && file->id != 0x3ff)) {\n        err = tag;\n        goto cleanup;\n    }\n\n    \n    file->type = LFS2_TYPE_REG;\n    lfs2_mlist_append(lfs2, (struct lfs2_mlist *)file);\n\n#ifdef LFS2_READONLY\n    if (tag == LFS2_ERR_NOENT) {\n        err = LFS2_ERR_NOENT;\n        goto cleanup;\n#else\n    if (tag == LFS2_ERR_NOENT) {\n        if (!(flags & LFS2_O_CREAT)) {\n            err = LFS2_ERR_NOENT;\n            goto cleanup;\n        }\n\n        \n        lfs2_size_t nlen = strlen(path);\n        if (nlen > lfs2->name_max) {\n            err = LFS2_ERR_NAMETOOLONG;\n            goto cleanup;\n        }\n\n        \n        err = lfs2_dir_commit(lfs2, &file->m, LFS2_MKATTRS(\n                {LFS2_MKTAG(LFS2_TYPE_CREATE, file->id, 0), NULL},\n                {LFS2_MKTAG(LFS2_TYPE_REG, file->id, nlen), path},\n                {LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, file->id, 0), NULL}));\n\n        \n        \n        err = (err == LFS2_ERR_NOSPC) ? LFS2_ERR_NAMETOOLONG : err;\n        if (err) {\n            goto cleanup;\n        }\n\n        tag = LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, 0);\n    } else if (flags & LFS2_O_EXCL) {\n        err = LFS2_ERR_EXIST;\n        goto cleanup;\n#endif\n    } else if (lfs2_tag_type3(tag) != LFS2_TYPE_REG) {\n        err = LFS2_ERR_ISDIR;\n        goto cleanup;\n#ifndef LFS2_READONLY\n    } else if (flags & LFS2_O_TRUNC) {\n        \n        tag = LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, file->id, 0);\n        file->flags |= LFS2_F_DIRTY;\n#endif\n    } else {\n        \n        tag = lfs2_dir_get(lfs2, &file->m, LFS2_MKTAG(0x700, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_STRUCT, file->id, 8), &file->ctz);\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n        lfs2_ctz_fromle32(&file->ctz);\n    }\n\n    \n    for (unsigned i = 0; i < file->cfg->attr_count; i++) {\n        \n        if ((file->flags & LFS2_O_RDONLY) == LFS2_O_RDONLY) {\n            lfs2_stag_t res = lfs2_dir_get(lfs2, &file->m,\n                    LFS2_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_USERATTR + file->cfg->attrs[i].type,\n                        file->id, file->cfg->attrs[i].size),\n                        file->cfg->attrs[i].buffer);\n            if (res < 0 && res != LFS2_ERR_NOENT) {\n                err = res;\n                goto cleanup;\n            }\n        }\n\n#ifndef LFS2_READONLY\n        \n        if ((file->flags & LFS2_O_WRONLY) == LFS2_O_WRONLY) {\n            if (file->cfg->attrs[i].size > lfs2->attr_max) {\n                err = LFS2_ERR_NOSPC;\n                goto cleanup;\n            }\n\n            file->flags |= LFS2_F_DIRTY;\n        }\n#endif\n    }\n\n    \n    if (file->cfg->buffer) {\n        file->cache.buffer = file->cfg->buffer;\n    } else {\n        file->cache.buffer = lfs2_malloc(lfs2->cfg->cache_size);\n        if (!file->cache.buffer) {\n            err = LFS2_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    \n    lfs2_cache_zero(lfs2, &file->cache);\n\n    if (lfs2_tag_type3(tag) == LFS2_TYPE_INLINESTRUCT) {\n        \n        file->ctz.head = LFS2_BLOCK_INLINE;\n        file->ctz.size = lfs2_tag_size(tag);\n        file->flags |= LFS2_F_INLINE;\n        file->cache.block = file->ctz.head;\n        file->cache.off = 0;\n        file->cache.size = lfs2->cfg->cache_size;\n\n        \n        if (file->ctz.size > 0) {\n            lfs2_stag_t res = lfs2_dir_get(lfs2, &file->m,\n                    LFS2_MKTAG(0x700, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_STRUCT, file->id,\n                        lfs2_min(file->cache.size, 0x3fe)),\n                    file->cache.buffer);\n            if (res < 0) {\n                err = res;\n                goto cleanup;\n            }\n        }\n    }\n\n    return 0;\n\ncleanup:\n    \n#ifndef LFS2_READONLY\n    file->flags |= LFS2_F_ERRED;\n#endif\n    lfs2_file_rawclose(lfs2, file);\n    return err;\n}\n\n#ifndef LFS2_NO_MALLOC\nstatic int lfs2_file_rawopen(lfs2_t *lfs2, lfs2_file_t *file,\n        const char *path, int flags) {\n    static const struct lfs2_file_config defaults = {0};\n    int err = lfs2_file_rawopencfg(lfs2, file, path, flags, &defaults);\n    return err;\n}\n#endif\n\nstatic int lfs2_file_rawclose(lfs2_t *lfs2, lfs2_file_t *file) {\n#ifndef LFS2_READONLY\n    int err = lfs2_file_rawsync(lfs2, file);\n#else\n    int err = 0;\n#endif\n\n    \n    lfs2_mlist_remove(lfs2, (struct lfs2_mlist*)file);\n\n    \n    if (!file->cfg->buffer) {\n        lfs2_free(file->cache.buffer);\n    }\n\n    return err;\n}\n\n\n#ifndef LFS2_READONLY\nstatic int lfs2_file_relocate(lfs2_t *lfs2, lfs2_file_t *file) {\n    while (true) {\n        \n        lfs2_block_t nblock;\n        int err = lfs2_alloc(lfs2, &nblock);\n        if (err) {\n            return err;\n        }\n\n        err = lfs2_bd_erase(lfs2, nblock);\n        if (err) {\n            if (err == LFS2_ERR_CORRUPT) {\n                goto relocate;\n            }\n            return err;\n        }\n\n        \n        for (lfs2_off_t i = 0; i < file->off; i++) {\n            uint8_t data;\n            if (file->flags & LFS2_F_INLINE) {\n                err = lfs2_dir_getread(lfs2, &file->m,\n                        \n                        NULL, &file->cache, file->off-i,\n                        LFS2_MKTAG(0xfff, 0x1ff, 0),\n                        LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, file->id, 0),\n                        i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            } else {\n                err = lfs2_bd_read(lfs2,\n                        &file->cache, &lfs2->rcache, file->off-i,\n                        file->block, i, &data, 1);\n                if (err) {\n                    return err;\n                }\n            }\n\n            err = lfs2_bd_prog(lfs2,\n                    &lfs2->pcache, &lfs2->rcache, true,\n                    nblock, i, &data, 1);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                return err;\n            }\n        }\n\n        \n        memcpy(file->cache.buffer, lfs2->pcache.buffer, lfs2->cfg->cache_size);\n        file->cache.block = lfs2->pcache.block;\n        file->cache.off = lfs2->pcache.off;\n        file->cache.size = lfs2->pcache.size;\n        lfs2_cache_zero(lfs2, &lfs2->pcache);\n\n        file->block = nblock;\n        file->flags |= LFS2_F_WRITING;\n        return 0;\n\nrelocate:\n        LFS2_DEBUG(\"Bad block at 0x%\"PRIx32, nblock);\n\n        \n        lfs2_cache_drop(lfs2, &lfs2->pcache);\n    }\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_file_outline(lfs2_t *lfs2, lfs2_file_t *file) {\n    file->off = file->pos;\n    lfs2_alloc_ack(lfs2);\n    int err = lfs2_file_relocate(lfs2, file);\n    if (err) {\n        return err;\n    }\n\n    file->flags &= ~LFS2_F_INLINE;\n    return 0;\n}\n#endif\n\nstatic int lfs2_file_flush(lfs2_t *lfs2, lfs2_file_t *file) {\n    if (file->flags & LFS2_F_READING) {\n        if (!(file->flags & LFS2_F_INLINE)) {\n            lfs2_cache_drop(lfs2, &file->cache);\n        }\n        file->flags &= ~LFS2_F_READING;\n    }\n\n#ifndef LFS2_READONLY\n    if (file->flags & LFS2_F_WRITING) {\n        lfs2_off_t pos = file->pos;\n\n        if (!(file->flags & LFS2_F_INLINE)) {\n            \n            lfs2_file_t orig = {\n                .ctz.head = file->ctz.head,\n                .ctz.size = file->ctz.size,\n                .flags = LFS2_O_RDONLY,\n                .pos = file->pos,\n                .cache = lfs2->rcache,\n            };\n            lfs2_cache_drop(lfs2, &lfs2->rcache);\n\n            while (file->pos < file->ctz.size) {\n                \n                \n                uint8_t data;\n                lfs2_ssize_t res = lfs2_file_flushedread(lfs2, &orig, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                res = lfs2_file_flushedwrite(lfs2, file, &data, 1);\n                if (res < 0) {\n                    return res;\n                }\n\n                \n                if (lfs2->rcache.block != LFS2_BLOCK_NULL) {\n                    lfs2_cache_drop(lfs2, &orig.cache);\n                    lfs2_cache_drop(lfs2, &lfs2->rcache);\n                }\n            }\n\n            \n            while (true) {\n                int err = lfs2_bd_flush(lfs2, &file->cache, &lfs2->rcache, true);\n                if (err) {\n                    if (err == LFS2_ERR_CORRUPT) {\n                        goto relocate;\n                    }\n                    return err;\n                }\n\n                break;\n\nrelocate:\n                LFS2_DEBUG(\"Bad block at 0x%\"PRIx32, file->block);\n                err = lfs2_file_relocate(lfs2, file);\n                if (err) {\n                    return err;\n                }\n            }\n        } else {\n            file->pos = lfs2_max(file->pos, file->ctz.size);\n        }\n\n        \n        file->ctz.head = file->block;\n        file->ctz.size = file->pos;\n        file->flags &= ~LFS2_F_WRITING;\n        file->flags |= LFS2_F_DIRTY;\n\n        file->pos = pos;\n    }\n#endif\n\n    return 0;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_file_rawsync(lfs2_t *lfs2, lfs2_file_t *file) {\n    if (file->flags & LFS2_F_ERRED) {\n        \n        return 0;\n    }\n\n    int err = lfs2_file_flush(lfs2, file);\n    if (err) {\n        file->flags |= LFS2_F_ERRED;\n        return err;\n    }\n\n\n    if ((file->flags & LFS2_F_DIRTY) &&\n            !lfs2_pair_isnull(file->m.pair)) {\n        \n        uint16_t type;\n        const void *buffer;\n        lfs2_size_t size;\n        struct lfs2_ctz ctz;\n        if (file->flags & LFS2_F_INLINE) {\n            \n            type = LFS2_TYPE_INLINESTRUCT;\n            buffer = file->cache.buffer;\n            size = file->ctz.size;\n        } else {\n            \n            type = LFS2_TYPE_CTZSTRUCT;\n            \n            ctz = file->ctz;\n            lfs2_ctz_tole32(&ctz);\n            buffer = &ctz;\n            size = sizeof(ctz);\n        }\n\n        \n        err = lfs2_dir_commit(lfs2, &file->m, LFS2_MKATTRS(\n                {LFS2_MKTAG(type, file->id, size), buffer},\n                {LFS2_MKTAG(LFS2_FROM_USERATTRS, file->id,\n                    file->cfg->attr_count), file->cfg->attrs}));\n        if (err) {\n            file->flags |= LFS2_F_ERRED;\n            return err;\n        }\n\n        file->flags &= ~LFS2_F_DIRTY;\n    }\n\n    return 0;\n}\n#endif\n\nstatic lfs2_ssize_t lfs2_file_flushedread(lfs2_t *lfs2, lfs2_file_t *file,\n        void *buffer, lfs2_size_t size) {\n    uint8_t *data = buffer;\n    lfs2_size_t nsize = size;\n\n    if (file->pos >= file->ctz.size) {\n        \n        return 0;\n    }\n\n    size = lfs2_min(size, file->ctz.size - file->pos);\n    nsize = size;\n\n    while (nsize > 0) {\n        \n        if (!(file->flags & LFS2_F_READING) ||\n                file->off == lfs2->cfg->block_size) {\n            if (!(file->flags & LFS2_F_INLINE)) {\n                int err = lfs2_ctz_find(lfs2, NULL, &file->cache,\n                        file->ctz.head, file->ctz.size,\n                        file->pos, &file->block, &file->off);\n                if (err) {\n                    return err;\n                }\n            } else {\n                file->block = LFS2_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS2_F_READING;\n        }\n\n        \n        lfs2_size_t diff = lfs2_min(nsize, lfs2->cfg->block_size - file->off);\n        if (file->flags & LFS2_F_INLINE) {\n            int err = lfs2_dir_getread(lfs2, &file->m,\n                    NULL, &file->cache, lfs2->cfg->block_size,\n                    LFS2_MKTAG(0xfff, 0x1ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, file->id, 0),\n                    file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        } else {\n            int err = lfs2_bd_read(lfs2,\n                    NULL, &file->cache, lfs2->cfg->block_size,\n                    file->block, file->off, data, diff);\n            if (err) {\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n    }\n\n    return size;\n}\n\nstatic lfs2_ssize_t lfs2_file_rawread(lfs2_t *lfs2, lfs2_file_t *file,\n        void *buffer, lfs2_size_t size) {\n    LFS2_ASSERT((file->flags & LFS2_O_RDONLY) == LFS2_O_RDONLY);\n\n#ifndef LFS2_READONLY\n    if (file->flags & LFS2_F_WRITING) {\n        \n        int err = lfs2_file_flush(lfs2, file);\n        if (err) {\n            return err;\n        }\n    }\n#endif\n\n    return lfs2_file_flushedread(lfs2, file, buffer, size);\n}\n\n\n#ifndef LFS2_READONLY\nstatic lfs2_ssize_t lfs2_file_flushedwrite(lfs2_t *lfs2, lfs2_file_t *file,\n        const void *buffer, lfs2_size_t size) {\n    const uint8_t *data = buffer;\n    lfs2_size_t nsize = size;\n\n    if ((file->flags & LFS2_F_INLINE) &&\n            lfs2_max(file->pos+nsize, file->ctz.size) >\n            lfs2_min(0x3fe, lfs2_min(\n                lfs2->cfg->cache_size,\n                (lfs2->cfg->metadata_max ?\n                    lfs2->cfg->metadata_max : lfs2->cfg->block_size) / 8))) {\n        \n        int err = lfs2_file_outline(lfs2, file);\n        if (err) {\n            file->flags |= LFS2_F_ERRED;\n            return err;\n        }\n    }\n\n    while (nsize > 0) {\n        \n        if (!(file->flags & LFS2_F_WRITING) ||\n                file->off == lfs2->cfg->block_size) {\n            if (!(file->flags & LFS2_F_INLINE)) {\n                if (!(file->flags & LFS2_F_WRITING) && file->pos > 0) {\n                    \n                    int err = lfs2_ctz_find(lfs2, NULL, &file->cache,\n                            file->ctz.head, file->ctz.size,\n                            file->pos-1, &file->block, &(lfs2_off_t){0});\n                    if (err) {\n                        file->flags |= LFS2_F_ERRED;\n                        return err;\n                    }\n\n                    \n                    lfs2_cache_zero(lfs2, &file->cache);\n                }\n\n                \n                lfs2_alloc_ack(lfs2);\n                int err = lfs2_ctz_extend(lfs2, &file->cache, &lfs2->rcache,\n                        file->block, file->pos,\n                        &file->block, &file->off);\n                if (err) {\n                    file->flags |= LFS2_F_ERRED;\n                    return err;\n                }\n            } else {\n                file->block = LFS2_BLOCK_INLINE;\n                file->off = file->pos;\n            }\n\n            file->flags |= LFS2_F_WRITING;\n        }\n\n        \n        lfs2_size_t diff = lfs2_min(nsize, lfs2->cfg->block_size - file->off);\n        while (true) {\n            int err = lfs2_bd_prog(lfs2, &file->cache, &lfs2->rcache, true,\n                    file->block, file->off, data, diff);\n            if (err) {\n                if (err == LFS2_ERR_CORRUPT) {\n                    goto relocate;\n                }\n                file->flags |= LFS2_F_ERRED;\n                return err;\n            }\n\n            break;\nrelocate:\n            err = lfs2_file_relocate(lfs2, file);\n            if (err) {\n                file->flags |= LFS2_F_ERRED;\n                return err;\n            }\n        }\n\n        file->pos += diff;\n        file->off += diff;\n        data += diff;\n        nsize -= diff;\n\n        lfs2_alloc_ack(lfs2);\n    }\n\n    return size;\n}\n\nstatic lfs2_ssize_t lfs2_file_rawwrite(lfs2_t *lfs2, lfs2_file_t *file,\n        const void *buffer, lfs2_size_t size) {\n    LFS2_ASSERT((file->flags & LFS2_O_WRONLY) == LFS2_O_WRONLY);\n\n    if (file->flags & LFS2_F_READING) {\n        \n        int err = lfs2_file_flush(lfs2, file);\n        if (err) {\n            return err;\n        }\n    }\n\n    if ((file->flags & LFS2_O_APPEND) && file->pos < file->ctz.size) {\n        file->pos = file->ctz.size;\n    }\n\n    if (file->pos + size > lfs2->file_max) {\n        \n        return LFS2_ERR_FBIG;\n    }\n\n    if (!(file->flags & LFS2_F_WRITING) && file->pos > file->ctz.size) {\n        \n        lfs2_off_t pos = file->pos;\n        file->pos = file->ctz.size;\n\n        while (file->pos < pos) {\n            lfs2_ssize_t res = lfs2_file_flushedwrite(lfs2, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return res;\n            }\n        }\n    }\n\n    lfs2_ssize_t nsize = lfs2_file_flushedwrite(lfs2, file, buffer, size);\n    if (nsize < 0) {\n        return nsize;\n    }\n\n    file->flags &= ~LFS2_F_ERRED;\n    return nsize;\n}\n#endif\n\nstatic lfs2_soff_t lfs2_file_rawseek(lfs2_t *lfs2, lfs2_file_t *file,\n        lfs2_soff_t off, int whence) {\n    \n    lfs2_off_t npos = file->pos;\n    if (whence == LFS2_SEEK_SET) {\n        npos = off;\n    } else if (whence == LFS2_SEEK_CUR) {\n        if ((lfs2_soff_t)file->pos + off < 0) {\n            return LFS2_ERR_INVAL;\n        } else {\n            npos = file->pos + off;\n        }\n    } else if (whence == LFS2_SEEK_END) {\n        lfs2_soff_t res = lfs2_file_rawsize(lfs2, file) + off;\n        if (res < 0) {\n            return LFS2_ERR_INVAL;\n        } else {\n            npos = res;\n        }\n    }\n\n    if (npos > lfs2->file_max) {\n        \n        return LFS2_ERR_INVAL;\n    }\n\n    if (file->pos == npos) {\n        \n        return npos;\n    }\n\n    \n    \n    if (\n#ifndef LFS2_READONLY\n        !(file->flags & LFS2_F_WRITING)\n#else\n        true\n#endif\n            ) {\n        int oindex = lfs2_ctz_index(lfs2, &(lfs2_off_t){file->pos});\n        lfs2_off_t noff = npos;\n        int nindex = lfs2_ctz_index(lfs2, &noff);\n        if (oindex == nindex\n                && noff >= file->cache.off\n                && noff < file->cache.off + file->cache.size) {\n            file->pos = npos;\n            file->off = noff;\n            return npos;\n        }\n    }\n\n    \n    int err = lfs2_file_flush(lfs2, file);\n    if (err) {\n        return err;\n    }\n\n    \n    file->pos = npos;\n    return npos;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_file_rawtruncate(lfs2_t *lfs2, lfs2_file_t *file, lfs2_off_t size) {\n    LFS2_ASSERT((file->flags & LFS2_O_WRONLY) == LFS2_O_WRONLY);\n\n    if (size > LFS2_FILE_MAX) {\n        return LFS2_ERR_INVAL;\n    }\n\n    lfs2_off_t pos = file->pos;\n    lfs2_off_t oldsize = lfs2_file_rawsize(lfs2, file);\n    if (size < oldsize) {\n        \n        if (size <= lfs2_min(0x3fe, lfs2_min(\n                lfs2->cfg->cache_size,\n                (lfs2->cfg->metadata_max ?\n                    lfs2->cfg->metadata_max : lfs2->cfg->block_size) / 8))) {\n            \n            lfs2_soff_t res = lfs2_file_rawseek(lfs2, file, 0, LFS2_SEEK_SET);\n            if (res < 0) {\n                return (int)res;\n            }\n\n            \n            lfs2_cache_drop(lfs2, &lfs2->rcache);\n            res = lfs2_file_flushedread(lfs2, file,\n                    lfs2->rcache.buffer, size);\n            if (res < 0) {\n                return (int)res;\n            }\n\n            file->ctz.head = LFS2_BLOCK_INLINE;\n            file->ctz.size = size;\n            file->flags |= LFS2_F_DIRTY | LFS2_F_READING | LFS2_F_INLINE;\n            file->cache.block = file->ctz.head;\n            file->cache.off = 0;\n            file->cache.size = lfs2->cfg->cache_size;\n            memcpy(file->cache.buffer, lfs2->rcache.buffer, size);\n\n        } else {\n            \n            int err = lfs2_file_flush(lfs2, file);\n            if (err) {\n                return err;\n            }\n\n            \n            err = lfs2_ctz_find(lfs2, NULL, &file->cache,\n                    file->ctz.head, file->ctz.size,\n                    size-1, &file->block, &(lfs2_off_t){0});\n            if (err) {\n                return err;\n            }\n\n            \n            \n            file->pos = size;\n            file->ctz.head = file->block;\n            file->ctz.size = size;\n            file->flags |= LFS2_F_DIRTY | LFS2_F_READING;\n        }\n    } else if (size > oldsize) {\n        \n        lfs2_soff_t res = lfs2_file_rawseek(lfs2, file, 0, LFS2_SEEK_END);\n        if (res < 0) {\n            return (int)res;\n        }\n\n        \n        while (file->pos < size) {\n            res = lfs2_file_rawwrite(lfs2, file, &(uint8_t){0}, 1);\n            if (res < 0) {\n                return (int)res;\n            }\n        }\n    }\n\n    \n    lfs2_soff_t res = lfs2_file_rawseek(lfs2, file, pos, LFS2_SEEK_SET);\n    if (res < 0) {\n      return (int)res;\n    }\n\n    return 0;\n}\n#endif\n\nstatic lfs2_soff_t lfs2_file_rawtell(lfs2_t *lfs2, lfs2_file_t *file) {\n    (void)lfs2;\n    return file->pos;\n}\n\nstatic int lfs2_file_rawrewind(lfs2_t *lfs2, lfs2_file_t *file) {\n    lfs2_soff_t res = lfs2_file_rawseek(lfs2, file, 0, LFS2_SEEK_SET);\n    if (res < 0) {\n        return (int)res;\n    }\n\n    return 0;\n}\n\nstatic lfs2_soff_t lfs2_file_rawsize(lfs2_t *lfs2, lfs2_file_t *file) {\n    (void)lfs2;\n\n#ifndef LFS2_READONLY\n    if (file->flags & LFS2_F_WRITING) {\n        return lfs2_max(file->pos, file->ctz.size);\n    }\n#endif\n\n    return file->ctz.size;\n}\n\n\n\nstatic int lfs2_rawstat(lfs2_t *lfs2, const char *path, struct lfs2_info *info) {\n    lfs2_mdir_t cwd;\n    lfs2_stag_t tag = lfs2_dir_find(lfs2, &cwd, &path, NULL);\n    if (tag < 0) {\n        return (int)tag;\n    }\n\n    return lfs2_dir_getinfo(lfs2, &cwd, lfs2_tag_id(tag), info);\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_rawremove(lfs2_t *lfs2, const char *path) {\n    \n    int err = lfs2_fs_forceconsistency(lfs2);\n    if (err) {\n        return err;\n    }\n\n    lfs2_mdir_t cwd;\n    lfs2_stag_t tag = lfs2_dir_find(lfs2, &cwd, &path, NULL);\n    if (tag < 0 || lfs2_tag_id(tag) == 0x3ff) {\n        return (tag < 0) ? (int)tag : LFS2_ERR_INVAL;\n    }\n\n    struct lfs2_mlist dir;\n    dir.next = lfs2->mlist;\n    if (lfs2_tag_type3(tag) == LFS2_TYPE_DIR) {\n        \n        lfs2_block_t pair[2];\n        lfs2_stag_t res = lfs2_dir_get(lfs2, &cwd, LFS2_MKTAG(0x700, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_STRUCT, lfs2_tag_id(tag), 8), pair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs2_pair_fromle32(pair);\n\n        err = lfs2_dir_fetch(lfs2, &dir.m, pair);\n        if (err) {\n            return err;\n        }\n\n        if (dir.m.count > 0 || dir.m.split) {\n            return LFS2_ERR_NOTEMPTY;\n        }\n\n        \n        err = lfs2_fs_preporphans(lfs2, +1);\n        if (err) {\n            return err;\n        }\n\n        \n        \n        dir.type = 0;\n        dir.id = 0;\n        lfs2->mlist = &dir;\n    }\n\n    \n    err = lfs2_dir_commit(lfs2, &cwd, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_DELETE, lfs2_tag_id(tag), 0), NULL}));\n    if (err) {\n        lfs2->mlist = dir.next;\n        return err;\n    }\n\n    lfs2->mlist = dir.next;\n    if (lfs2_tag_type3(tag) == LFS2_TYPE_DIR) {\n        \n        err = lfs2_fs_preporphans(lfs2, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs2_fs_pred(lfs2, dir.m.pair, &cwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs2_dir_drop(lfs2, &cwd, &dir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_rawrename(lfs2_t *lfs2, const char *oldpath, const char *newpath) {\n    \n    int err = lfs2_fs_forceconsistency(lfs2);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs2_mdir_t oldcwd;\n    lfs2_stag_t oldtag = lfs2_dir_find(lfs2, &oldcwd, &oldpath, NULL);\n    if (oldtag < 0 || lfs2_tag_id(oldtag) == 0x3ff) {\n        return (oldtag < 0) ? (int)oldtag : LFS2_ERR_INVAL;\n    }\n\n    \n    lfs2_mdir_t newcwd;\n    uint16_t newid;\n    lfs2_stag_t prevtag = lfs2_dir_find(lfs2, &newcwd, &newpath, &newid);\n    if ((prevtag < 0 || lfs2_tag_id(prevtag) == 0x3ff) &&\n            !(prevtag == LFS2_ERR_NOENT && newid != 0x3ff)) {\n        return (prevtag < 0) ? (int)prevtag : LFS2_ERR_INVAL;\n    }\n\n    \n    bool samepair = (lfs2_pair_cmp(oldcwd.pair, newcwd.pair) == 0);\n    uint16_t newoldid = lfs2_tag_id(oldtag);\n\n    struct lfs2_mlist prevdir;\n    prevdir.next = lfs2->mlist;\n    if (prevtag == LFS2_ERR_NOENT) {\n        \n        lfs2_size_t nlen = strlen(newpath);\n        if (nlen > lfs2->name_max) {\n            return LFS2_ERR_NAMETOOLONG;\n        }\n\n        \n        \n        \n        if (samepair && newid <= newoldid) {\n            newoldid += 1;\n        }\n    } else if (lfs2_tag_type3(prevtag) != lfs2_tag_type3(oldtag)) {\n        return LFS2_ERR_ISDIR;\n    } else if (samepair && newid == newoldid) {\n        \n        return 0;\n    } else if (lfs2_tag_type3(prevtag) == LFS2_TYPE_DIR) {\n        \n        lfs2_block_t prevpair[2];\n        lfs2_stag_t res = lfs2_dir_get(lfs2, &newcwd, LFS2_MKTAG(0x700, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_STRUCT, newid, 8), prevpair);\n        if (res < 0) {\n            return (int)res;\n        }\n        lfs2_pair_fromle32(prevpair);\n\n        \n        err = lfs2_dir_fetch(lfs2, &prevdir.m, prevpair);\n        if (err) {\n            return err;\n        }\n\n        if (prevdir.m.count > 0 || prevdir.m.split) {\n            return LFS2_ERR_NOTEMPTY;\n        }\n\n        \n        err = lfs2_fs_preporphans(lfs2, +1);\n        if (err) {\n            return err;\n        }\n\n        \n        \n        prevdir.type = 0;\n        prevdir.id = 0;\n        lfs2->mlist = &prevdir;\n    }\n\n    if (!samepair) {\n        lfs2_fs_prepmove(lfs2, newoldid, oldcwd.pair);\n    }\n\n    \n    err = lfs2_dir_commit(lfs2, &newcwd, LFS2_MKATTRS(\n            {LFS2_MKTAG_IF(prevtag != LFS2_ERR_NOENT,\n                LFS2_TYPE_DELETE, newid, 0), NULL},\n            {LFS2_MKTAG(LFS2_TYPE_CREATE, newid, 0), NULL},\n            {LFS2_MKTAG(lfs2_tag_type3(oldtag), newid, strlen(newpath)), newpath},\n            {LFS2_MKTAG(LFS2_FROM_MOVE, newid, lfs2_tag_id(oldtag)), &oldcwd},\n            {LFS2_MKTAG_IF(samepair,\n                LFS2_TYPE_DELETE, newoldid, 0), NULL}));\n    if (err) {\n        lfs2->mlist = prevdir.next;\n        return err;\n    }\n\n    \n    \n    if (!samepair && lfs2_gstate_hasmove(&lfs2->gstate)) {\n        \n        lfs2_fs_prepmove(lfs2, 0x3ff, NULL);\n        err = lfs2_dir_commit(lfs2, &oldcwd, LFS2_MKATTRS(\n                {LFS2_MKTAG(LFS2_TYPE_DELETE, lfs2_tag_id(oldtag), 0), NULL}));\n        if (err) {\n            lfs2->mlist = prevdir.next;\n            return err;\n        }\n    }\n\n    lfs2->mlist = prevdir.next;\n    if (prevtag != LFS2_ERR_NOENT\n            && lfs2_tag_type3(prevtag) == LFS2_TYPE_DIR) {\n        \n        err = lfs2_fs_preporphans(lfs2, -1);\n        if (err) {\n            return err;\n        }\n\n        err = lfs2_fs_pred(lfs2, prevdir.m.pair, &newcwd);\n        if (err) {\n            return err;\n        }\n\n        err = lfs2_dir_drop(lfs2, &newcwd, &prevdir.m);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n#endif\n\nstatic lfs2_ssize_t lfs2_rawgetattr(lfs2_t *lfs2, const char *path,\n        uint8_t type, void *buffer, lfs2_size_t size) {\n    lfs2_mdir_t cwd;\n    lfs2_stag_t tag = lfs2_dir_find(lfs2, &cwd, &path, NULL);\n    if (tag < 0) {\n        return tag;\n    }\n\n    uint16_t id = lfs2_tag_id(tag);\n    if (id == 0x3ff) {\n        \n        id = 0;\n        int err = lfs2_dir_fetch(lfs2, &cwd, lfs2->root);\n        if (err) {\n            return err;\n        }\n    }\n\n    tag = lfs2_dir_get(lfs2, &cwd, LFS2_MKTAG(0x7ff, 0x3ff, 0),\n            LFS2_MKTAG(LFS2_TYPE_USERATTR + type,\n                id, lfs2_min(size, lfs2->attr_max)),\n            buffer);\n    if (tag < 0) {\n        if (tag == LFS2_ERR_NOENT) {\n            return LFS2_ERR_NOATTR;\n        }\n\n        return tag;\n    }\n\n    return lfs2_tag_size(tag);\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_commitattr(lfs2_t *lfs2, const char *path,\n        uint8_t type, const void *buffer, lfs2_size_t size) {\n    lfs2_mdir_t cwd;\n    lfs2_stag_t tag = lfs2_dir_find(lfs2, &cwd, &path, NULL);\n    if (tag < 0) {\n        return tag;\n    }\n\n    uint16_t id = lfs2_tag_id(tag);\n    if (id == 0x3ff) {\n        \n        id = 0;\n        int err = lfs2_dir_fetch(lfs2, &cwd, lfs2->root);\n        if (err) {\n            return err;\n        }\n    }\n\n    return lfs2_dir_commit(lfs2, &cwd, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_USERATTR + type, id, size), buffer}));\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_rawsetattr(lfs2_t *lfs2, const char *path,\n        uint8_t type, const void *buffer, lfs2_size_t size) {\n    if (size > lfs2->attr_max) {\n        return LFS2_ERR_NOSPC;\n    }\n\n    return lfs2_commitattr(lfs2, path, type, buffer, size);\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_rawremoveattr(lfs2_t *lfs2, const char *path, uint8_t type) {\n    return lfs2_commitattr(lfs2, path, type, NULL, 0x3ff);\n}\n#endif\n\n\n\nstatic int lfs2_init(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    lfs2->cfg = cfg;\n    lfs2->block_count = cfg->block_count;  \n    int err = 0;\n\n#ifdef LFS2_MULTIVERSION\n    \n    LFS2_ASSERT(!lfs2->cfg->disk_version || (\n            (0xffff & (lfs2->cfg->disk_version >> 16))\n                    == LFS2_DISK_VERSION_MAJOR\n                && (0xffff & (lfs2->cfg->disk_version >> 0))\n                    <= LFS2_DISK_VERSION_MINOR));\n#endif\n\n    \n    \n    \n    \n    LFS2_ASSERT((bool)0x80000000);\n\n    \n    \n    LFS2_ASSERT(lfs2->cfg->read_size != 0);\n    LFS2_ASSERT(lfs2->cfg->prog_size != 0);\n    LFS2_ASSERT(lfs2->cfg->cache_size != 0);\n\n    \n    \n    LFS2_ASSERT(lfs2->cfg->cache_size % lfs2->cfg->read_size == 0);\n    LFS2_ASSERT(lfs2->cfg->cache_size % lfs2->cfg->prog_size == 0);\n    LFS2_ASSERT(lfs2->cfg->block_size % lfs2->cfg->cache_size == 0);\n\n    \n    LFS2_ASSERT(lfs2->cfg->block_size >= 128);\n    \n    \n    LFS2_ASSERT(4*lfs2_npw2(0xffffffff / (lfs2->cfg->block_size-2*4))\n            <= lfs2->cfg->block_size);\n\n    \n    \n    \n    \n    \n    \n    LFS2_ASSERT(lfs2->cfg->block_cycles != 0);\n\n\n    \n    if (lfs2->cfg->read_buffer) {\n        lfs2->rcache.buffer = lfs2->cfg->read_buffer;\n    } else {\n        lfs2->rcache.buffer = lfs2_malloc(lfs2->cfg->cache_size);\n        if (!lfs2->rcache.buffer) {\n            err = LFS2_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    \n    if (lfs2->cfg->prog_buffer) {\n        lfs2->pcache.buffer = lfs2->cfg->prog_buffer;\n    } else {\n        lfs2->pcache.buffer = lfs2_malloc(lfs2->cfg->cache_size);\n        if (!lfs2->pcache.buffer) {\n            err = LFS2_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    \n    lfs2_cache_zero(lfs2, &lfs2->rcache);\n    lfs2_cache_zero(lfs2, &lfs2->pcache);\n\n    \n    LFS2_ASSERT(lfs2->cfg->lookahead_size > 0);\n    LFS2_ASSERT(lfs2->cfg->lookahead_size % 8 == 0 &&\n            (uintptr_t)lfs2->cfg->lookahead_buffer % 4 == 0);\n    if (lfs2->cfg->lookahead_buffer) {\n        lfs2->free.buffer = lfs2->cfg->lookahead_buffer;\n    } else {\n        lfs2->free.buffer = lfs2_malloc(lfs2->cfg->lookahead_size);\n        if (!lfs2->free.buffer) {\n            err = LFS2_ERR_NOMEM;\n            goto cleanup;\n        }\n    }\n\n    \n    LFS2_ASSERT(lfs2->cfg->name_max <= LFS2_NAME_MAX);\n    lfs2->name_max = lfs2->cfg->name_max;\n    if (!lfs2->name_max) {\n        lfs2->name_max = LFS2_NAME_MAX;\n    }\n\n    LFS2_ASSERT(lfs2->cfg->file_max <= LFS2_FILE_MAX);\n    lfs2->file_max = lfs2->cfg->file_max;\n    if (!lfs2->file_max) {\n        lfs2->file_max = LFS2_FILE_MAX;\n    }\n\n    LFS2_ASSERT(lfs2->cfg->attr_max <= LFS2_ATTR_MAX);\n    lfs2->attr_max = lfs2->cfg->attr_max;\n    if (!lfs2->attr_max) {\n        lfs2->attr_max = LFS2_ATTR_MAX;\n    }\n\n    LFS2_ASSERT(lfs2->cfg->metadata_max <= lfs2->cfg->block_size);\n\n    \n    lfs2->root[0] = LFS2_BLOCK_NULL;\n    lfs2->root[1] = LFS2_BLOCK_NULL;\n    lfs2->mlist = NULL;\n    lfs2->seed = 0;\n    lfs2->gdisk = (lfs2_gstate_t){0};\n    lfs2->gstate = (lfs2_gstate_t){0};\n    lfs2->gdelta = (lfs2_gstate_t){0};\n#ifdef LFS2_MIGRATE\n    lfs2->lfs21 = NULL;\n#endif\n\n    return 0;\n\ncleanup:\n    lfs2_deinit(lfs2);\n    return err;\n}\n\nstatic int lfs2_deinit(lfs2_t *lfs2) {\n    \n    if (!lfs2->cfg->read_buffer) {\n        lfs2_free(lfs2->rcache.buffer);\n    }\n\n    if (!lfs2->cfg->prog_buffer) {\n        lfs2_free(lfs2->pcache.buffer);\n    }\n\n    if (!lfs2->cfg->lookahead_buffer) {\n        lfs2_free(lfs2->free.buffer);\n    }\n\n    return 0;\n}\n\n\n\n#ifndef LFS2_READONLY\nstatic int lfs2_rawformat(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    int err = 0;\n    {\n        err = lfs2_init(lfs2, cfg);\n        if (err) {\n            return err;\n        }\n\n        LFS2_ASSERT(cfg->block_count != 0);\n\n        \n        memset(lfs2->free.buffer, 0, lfs2->cfg->lookahead_size);\n        lfs2->free.off = 0;\n        lfs2->free.size = lfs2_min(8*lfs2->cfg->lookahead_size,\n                lfs2->block_count);\n        lfs2->free.i = 0;\n        lfs2_alloc_ack(lfs2);\n\n        \n        lfs2_mdir_t root;\n        err = lfs2_dir_alloc(lfs2, &root);\n        if (err) {\n            goto cleanup;\n        }\n\n        \n        lfs2_superblock_t superblock = {\n            .version     = lfs2_fs_disk_version(lfs2),\n            .block_size  = lfs2->cfg->block_size,\n            .block_count = lfs2->block_count,\n            .name_max    = lfs2->name_max,\n            .file_max    = lfs2->file_max,\n            .attr_max    = lfs2->attr_max,\n        };\n\n        lfs2_superblock_tole32(&superblock);\n        err = lfs2_dir_commit(lfs2, &root, LFS2_MKATTRS(\n                {LFS2_MKTAG(LFS2_TYPE_CREATE, 0, 0), NULL},\n                {LFS2_MKTAG(LFS2_TYPE_SUPERBLOCK, 0, 8), \"littlefs\"},\n                {LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock}));\n        if (err) {\n            goto cleanup;\n        }\n\n        \n        \n        root.erased = false;\n        err = lfs2_dir_commit(lfs2, &root, NULL, 0);\n        if (err) {\n            goto cleanup;\n        }\n\n        \n        err = lfs2_dir_fetch(lfs2, &root, (const lfs2_block_t[2]){0, 1});\n        if (err) {\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    lfs2_deinit(lfs2);\n    return err;\n\n}\n#endif\n\nstatic int lfs2_rawmount(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    int err = lfs2_init(lfs2, cfg);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs2_mdir_t dir = {.tail = {0, 1}};\n    lfs2_block_t tortoise[2] = {LFS2_BLOCK_NULL, LFS2_BLOCK_NULL};\n    lfs2_size_t tortoise_i = 1;\n    lfs2_size_t tortoise_period = 1;\n    while (!lfs2_pair_isnull(dir.tail)) {\n        \n        if (lfs2_pair_issync(dir.tail, tortoise)) {\n            LFS2_WARN(\"Cycle detected in tail list\");\n            err = LFS2_ERR_CORRUPT;\n            goto cleanup;\n        }\n        if (tortoise_i == tortoise_period) {\n            tortoise[0] = dir.tail[0];\n            tortoise[1] = dir.tail[1];\n            tortoise_i = 0;\n            tortoise_period *= 2;\n        }\n        tortoise_i += 1;\n\n        \n        lfs2_stag_t tag = lfs2_dir_fetchmatch(lfs2, &dir, dir.tail,\n                LFS2_MKTAG(0x7ff, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_SUPERBLOCK, 0, 8),\n                NULL,\n                lfs2_dir_find_match, &(struct lfs2_dir_find_match){\n                    lfs2, \"littlefs\", 8});\n        if (tag < 0) {\n            err = tag;\n            goto cleanup;\n        }\n\n        \n        if (tag && !lfs2_tag_isdelete(tag)) {\n            \n            lfs2->root[0] = dir.pair[0];\n            lfs2->root[1] = dir.pair[1];\n\n            \n            lfs2_superblock_t superblock;\n            tag = lfs2_dir_get(lfs2, &dir, LFS2_MKTAG(0x7ff, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock);\n            if (tag < 0) {\n                err = tag;\n                goto cleanup;\n            }\n            lfs2_superblock_fromle32(&superblock);\n\n            \n            uint16_t major_version = (0xffff & (superblock.version >> 16));\n            uint16_t minor_version = (0xffff & (superblock.version >>  0));\n            if (major_version != lfs2_fs_disk_version_major(lfs2)\n                    || minor_version > lfs2_fs_disk_version_minor(lfs2)) {\n                LFS2_ERROR(\"Invalid version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" != v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs2_fs_disk_version_major(lfs2),\n                        lfs2_fs_disk_version_minor(lfs2));\n                err = LFS2_ERR_INVAL;\n                goto cleanup;\n            }\n\n            \n            \n            \n            if (minor_version < lfs2_fs_disk_version_minor(lfs2)) {\n                LFS2_DEBUG(\"Found older minor version \"\n                        \"v%\"PRIu16\".%\"PRIu16\" < v%\"PRIu16\".%\"PRIu16,\n                        major_version,\n                        minor_version,\n                        lfs2_fs_disk_version_major(lfs2),\n                        lfs2_fs_disk_version_minor(lfs2));\n                \n                \n                lfs2_fs_prepsuperblock(lfs2, true);\n            }\n\n            \n            if (superblock.name_max) {\n                if (superblock.name_max > lfs2->name_max) {\n                    LFS2_ERROR(\"Unsupported name_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.name_max, lfs2->name_max);\n                    err = LFS2_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs2->name_max = superblock.name_max;\n            }\n\n            if (superblock.file_max) {\n                if (superblock.file_max > lfs2->file_max) {\n                    LFS2_ERROR(\"Unsupported file_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.file_max, lfs2->file_max);\n                    err = LFS2_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs2->file_max = superblock.file_max;\n            }\n\n            if (superblock.attr_max) {\n                if (superblock.attr_max > lfs2->attr_max) {\n                    LFS2_ERROR(\"Unsupported attr_max (%\"PRIu32\" > %\"PRIu32\")\",\n                            superblock.attr_max, lfs2->attr_max);\n                    err = LFS2_ERR_INVAL;\n                    goto cleanup;\n                }\n\n                lfs2->attr_max = superblock.attr_max;\n            }\n\n            \n            if (lfs2->cfg->block_count\n                    && superblock.block_count != lfs2->cfg->block_count) {\n                LFS2_ERROR(\"Invalid block count (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_count, lfs2->cfg->block_count);\n                err = LFS2_ERR_INVAL;\n                goto cleanup;\n            }\n\n            lfs2->block_count = superblock.block_count;\n\n            if (superblock.block_size != lfs2->cfg->block_size) {\n                LFS2_ERROR(\"Invalid block size (%\"PRIu32\" != %\"PRIu32\")\",\n                        superblock.block_size, lfs2->cfg->block_size);\n                err = LFS2_ERR_INVAL;\n                goto cleanup;\n            }\n        }\n\n        \n        err = lfs2_dir_getgstate(lfs2, &dir, &lfs2->gstate);\n        if (err) {\n            goto cleanup;\n        }\n    }\n\n    \n    if (!lfs2_gstate_iszero(&lfs2->gstate)) {\n        LFS2_DEBUG(\"Found pending gstate 0x%08\"PRIx32\"%08\"PRIx32\"%08\"PRIx32,\n                lfs2->gstate.tag,\n                lfs2->gstate.pair[0],\n                lfs2->gstate.pair[1]);\n    }\n    lfs2->gstate.tag += !lfs2_tag_isvalid(lfs2->gstate.tag);\n    lfs2->gdisk = lfs2->gstate;\n\n    \n    \n    lfs2->free.off = lfs2->seed % lfs2->block_count;\n    lfs2_alloc_drop(lfs2);\n\n    return 0;\n\ncleanup:\n    lfs2_rawunmount(lfs2);\n    return err;\n}\n\nstatic int lfs2_rawunmount(lfs2_t *lfs2) {\n    return lfs2_deinit(lfs2);\n}\n\n\n\nstatic int lfs2_fs_rawstat(lfs2_t *lfs2, struct lfs2_fsinfo *fsinfo) {\n    \n    \n    if (!lfs2_gstate_needssuperblock(&lfs2->gstate)) {\n        fsinfo->disk_version = lfs2_fs_disk_version(lfs2);\n\n    \n    } else {\n        \n        lfs2_mdir_t dir;\n        int err = lfs2_dir_fetch(lfs2, &dir, lfs2->root);\n        if (err) {\n            return err;\n        }\n\n        lfs2_superblock_t superblock;\n        lfs2_stag_t tag = lfs2_dir_get(lfs2, &dir, LFS2_MKTAG(0x7ff, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock);\n        if (tag < 0) {\n            return tag;\n        }\n        lfs2_superblock_fromle32(&superblock);\n\n        \n        fsinfo->disk_version = superblock.version;\n    }\n\n    \n    fsinfo->block_size = lfs2->cfg->block_size;\n    fsinfo->block_count = lfs2->block_count;\n\n    \n    fsinfo->name_max = lfs2->name_max;\n    fsinfo->file_max = lfs2->file_max;\n    fsinfo->attr_max = lfs2->attr_max;\n\n    return 0;\n}\n\nint lfs2_fs_rawtraverse(lfs2_t *lfs2,\n        int (*cb)(void *data, lfs2_block_t block), void *data,\n        bool includeorphans) {\n    \n    lfs2_mdir_t dir = {.tail = {0, 1}};\n\n#ifdef LFS2_MIGRATE\n    \n    if (lfs2->lfs21) {\n        int err = lfs21_traverse(lfs2, cb, data);\n        if (err) {\n            return err;\n        }\n\n        dir.tail[0] = lfs2->root[0];\n        dir.tail[1] = lfs2->root[1];\n    }\n#endif\n\n    lfs2_block_t tortoise[2] = {LFS2_BLOCK_NULL, LFS2_BLOCK_NULL};\n    lfs2_size_t tortoise_i = 1;\n    lfs2_size_t tortoise_period = 1;\n    while (!lfs2_pair_isnull(dir.tail)) {\n        \n        if (lfs2_pair_issync(dir.tail, tortoise)) {\n            LFS2_WARN(\"Cycle detected in tail list\");\n            return LFS2_ERR_CORRUPT;\n        }\n        if (tortoise_i == tortoise_period) {\n            tortoise[0] = dir.tail[0];\n            tortoise[1] = dir.tail[1];\n            tortoise_i = 0;\n            tortoise_period *= 2;\n        }\n        tortoise_i += 1;\n\n        for (int i = 0; i < 2; i++) {\n            int err = cb(data, dir.tail[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        \n        int err = lfs2_dir_fetch(lfs2, &dir, dir.tail);\n        if (err) {\n            return err;\n        }\n\n        for (uint16_t id = 0; id < dir.count; id++) {\n            struct lfs2_ctz ctz;\n            lfs2_stag_t tag = lfs2_dir_get(lfs2, &dir, LFS2_MKTAG(0x700, 0x3ff, 0),\n                    LFS2_MKTAG(LFS2_TYPE_STRUCT, id, sizeof(ctz)), &ctz);\n            if (tag < 0) {\n                if (tag == LFS2_ERR_NOENT) {\n                    continue;\n                }\n                return tag;\n            }\n            lfs2_ctz_fromle32(&ctz);\n\n            if (lfs2_tag_type3(tag) == LFS2_TYPE_CTZSTRUCT) {\n                err = lfs2_ctz_traverse(lfs2, NULL, &lfs2->rcache,\n                        ctz.head, ctz.size, cb, data);\n                if (err) {\n                    return err;\n                }\n            } else if (includeorphans &&\n                    lfs2_tag_type3(tag) == LFS2_TYPE_DIRSTRUCT) {\n                for (int i = 0; i < 2; i++) {\n                    err = cb(data, (&ctz.head)[i]);\n                    if (err) {\n                        return err;\n                    }\n                }\n            }\n        }\n    }\n\n#ifndef LFS2_READONLY\n    \n    for (lfs2_file_t *f = (lfs2_file_t*)lfs2->mlist; f; f = f->next) {\n        if (f->type != LFS2_TYPE_REG) {\n            continue;\n        }\n\n        if ((f->flags & LFS2_F_DIRTY) && !(f->flags & LFS2_F_INLINE)) {\n            int err = lfs2_ctz_traverse(lfs2, &f->cache, &lfs2->rcache,\n                    f->ctz.head, f->ctz.size, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n\n        if ((f->flags & LFS2_F_WRITING) && !(f->flags & LFS2_F_INLINE)) {\n            int err = lfs2_ctz_traverse(lfs2, &f->cache, &lfs2->rcache,\n                    f->block, f->pos, cb, data);\n            if (err) {\n                return err;\n            }\n        }\n    }\n#endif\n\n    return 0;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_pred(lfs2_t *lfs2,\n        const lfs2_block_t pair[2], lfs2_mdir_t *pdir) {\n    \n    pdir->tail[0] = 0;\n    pdir->tail[1] = 1;\n    lfs2_block_t tortoise[2] = {LFS2_BLOCK_NULL, LFS2_BLOCK_NULL};\n    lfs2_size_t tortoise_i = 1;\n    lfs2_size_t tortoise_period = 1;\n    while (!lfs2_pair_isnull(pdir->tail)) {\n        \n        if (lfs2_pair_issync(pdir->tail, tortoise)) {\n            LFS2_WARN(\"Cycle detected in tail list\");\n            return LFS2_ERR_CORRUPT;\n        }\n        if (tortoise_i == tortoise_period) {\n            tortoise[0] = pdir->tail[0];\n            tortoise[1] = pdir->tail[1];\n            tortoise_i = 0;\n            tortoise_period *= 2;\n        }\n        tortoise_i += 1;\n\n        if (lfs2_pair_cmp(pdir->tail, pair) == 0) {\n            return 0;\n        }\n\n        int err = lfs2_dir_fetch(lfs2, pdir, pdir->tail);\n        if (err) {\n            return err;\n        }\n    }\n\n    return LFS2_ERR_NOENT;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstruct lfs2_fs_parent_match {\n    lfs2_t *lfs2;\n    const lfs2_block_t pair[2];\n};\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_parent_match(void *data,\n        lfs2_tag_t tag, const void *buffer) {\n    struct lfs2_fs_parent_match *find = data;\n    lfs2_t *lfs2 = find->lfs2;\n    const struct lfs2_diskoff *disk = buffer;\n    (void)tag;\n\n    lfs2_block_t child[2];\n    int err = lfs2_bd_read(lfs2,\n            &lfs2->pcache, &lfs2->rcache, lfs2->cfg->block_size,\n            disk->block, disk->off, &child, sizeof(child));\n    if (err) {\n        return err;\n    }\n\n    lfs2_pair_fromle32(child);\n    return (lfs2_pair_cmp(child, find->pair) == 0) ? LFS2_CMP_EQ : LFS2_CMP_LT;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic lfs2_stag_t lfs2_fs_parent(lfs2_t *lfs2, const lfs2_block_t pair[2],\n        lfs2_mdir_t *parent) {\n    \n    parent->tail[0] = 0;\n    parent->tail[1] = 1;\n    lfs2_block_t tortoise[2] = {LFS2_BLOCK_NULL, LFS2_BLOCK_NULL};\n    lfs2_size_t tortoise_i = 1;\n    lfs2_size_t tortoise_period = 1;\n    while (!lfs2_pair_isnull(parent->tail)) {\n        \n        if (lfs2_pair_issync(parent->tail, tortoise)) {\n            LFS2_WARN(\"Cycle detected in tail list\");\n            return LFS2_ERR_CORRUPT;\n        }\n        if (tortoise_i == tortoise_period) {\n            tortoise[0] = parent->tail[0];\n            tortoise[1] = parent->tail[1];\n            tortoise_i = 0;\n            tortoise_period *= 2;\n        }\n        tortoise_i += 1;\n\n        lfs2_stag_t tag = lfs2_dir_fetchmatch(lfs2, parent, parent->tail,\n                LFS2_MKTAG(0x7ff, 0, 0x3ff),\n                LFS2_MKTAG(LFS2_TYPE_DIRSTRUCT, 0, 8),\n                NULL,\n                lfs2_fs_parent_match, &(struct lfs2_fs_parent_match){\n                    lfs2, {pair[0], pair[1]}});\n        if (tag && tag != LFS2_ERR_NOENT) {\n            return tag;\n        }\n    }\n\n    return LFS2_ERR_NOENT;\n}\n#endif\n\nstatic void lfs2_fs_prepsuperblock(lfs2_t *lfs2, bool needssuperblock) {\n    lfs2->gstate.tag = (lfs2->gstate.tag & ~LFS2_MKTAG(0, 0, 0x200))\n            | (uint32_t)needssuperblock << 9;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_preporphans(lfs2_t *lfs2, int8_t orphans) {\n    LFS2_ASSERT(lfs2_tag_size(lfs2->gstate.tag) > 0x000 || orphans >= 0);\n    LFS2_ASSERT(lfs2_tag_size(lfs2->gstate.tag) < 0x1ff || orphans <= 0);\n    lfs2->gstate.tag += orphans;\n    lfs2->gstate.tag = ((lfs2->gstate.tag & ~LFS2_MKTAG(0x800, 0, 0)) |\n            ((uint32_t)lfs2_gstate_hasorphans(&lfs2->gstate) << 31));\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic void lfs2_fs_prepmove(lfs2_t *lfs2,\n        uint16_t id, const lfs2_block_t pair[2]) {\n    lfs2->gstate.tag = ((lfs2->gstate.tag & ~LFS2_MKTAG(0x7ff, 0x3ff, 0)) |\n            ((id != 0x3ff) ? LFS2_MKTAG(LFS2_TYPE_DELETE, id, 0) : 0));\n    lfs2->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;\n    lfs2->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_desuperblock(lfs2_t *lfs2) {\n    if (!lfs2_gstate_needssuperblock(&lfs2->gstate)) {\n        return 0;\n    }\n\n    LFS2_DEBUG(\"Rewriting superblock {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n            lfs2->root[0],\n            lfs2->root[1]);\n\n    lfs2_mdir_t root;\n    int err = lfs2_dir_fetch(lfs2, &root, lfs2->root);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs2_superblock_t superblock = {\n        .version     = lfs2_fs_disk_version(lfs2),\n        .block_size  = lfs2->cfg->block_size,\n        .block_count = lfs2->block_count,\n        .name_max    = lfs2->name_max,\n        .file_max    = lfs2->file_max,\n        .attr_max    = lfs2->attr_max,\n    };\n\n    lfs2_superblock_tole32(&superblock);\n    err = lfs2_dir_commit(lfs2, &root, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock}));\n    if (err) {\n        return err;\n    }\n\n    lfs2_fs_prepsuperblock(lfs2, false);\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_demove(lfs2_t *lfs2) {\n    if (!lfs2_gstate_hasmove(&lfs2->gdisk)) {\n        return 0;\n    }\n\n    \n    LFS2_DEBUG(\"Fixing move {0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16,\n            lfs2->gdisk.pair[0],\n            lfs2->gdisk.pair[1],\n            lfs2_tag_id(lfs2->gdisk.tag));\n\n    \n    \n    LFS2_ASSERT(lfs2_tag_type3(lfs2->gdisk.tag) == LFS2_TYPE_DELETE);\n\n    \n    lfs2_mdir_t movedir;\n    int err = lfs2_dir_fetch(lfs2, &movedir, lfs2->gdisk.pair);\n    if (err) {\n        return err;\n    }\n\n    \n    uint16_t moveid = lfs2_tag_id(lfs2->gdisk.tag);\n    lfs2_fs_prepmove(lfs2, 0x3ff, NULL);\n    err = lfs2_dir_commit(lfs2, &movedir, LFS2_MKATTRS(\n            {LFS2_MKTAG(LFS2_TYPE_DELETE, moveid, 0), NULL}));\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_deorphan(lfs2_t *lfs2, bool powerloss) {\n    if (!lfs2_gstate_hasorphans(&lfs2->gstate)) {\n        return 0;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    int pass = 0;\n    while (pass < 2) {\n        \n        lfs2_mdir_t pdir = {.split = true, .tail = {0, 1}};\n        lfs2_mdir_t dir;\n        bool moreorphans = false;\n\n        \n        while (!lfs2_pair_isnull(pdir.tail)) {\n            int err = lfs2_dir_fetch(lfs2, &dir, pdir.tail);\n            if (err) {\n                return err;\n            }\n\n            \n            if (!pdir.split) {\n                \n                lfs2_mdir_t parent;\n                lfs2_stag_t tag = lfs2_fs_parent(lfs2, pdir.tail, &parent);\n                if (tag < 0 && tag != LFS2_ERR_NOENT) {\n                    return tag;\n                }\n\n                if (pass == 0 && tag != LFS2_ERR_NOENT) {\n                    lfs2_block_t pair[2];\n                    lfs2_stag_t state = lfs2_dir_get(lfs2, &parent,\n                            LFS2_MKTAG(0x7ff, 0x3ff, 0), tag, pair);\n                    if (state < 0) {\n                        return state;\n                    }\n                    lfs2_pair_fromle32(pair);\n\n                    if (!lfs2_pair_issync(pair, pdir.tail)) {\n                        \n                        LFS2_DEBUG(\"Fixing half-orphan \"\n                                \"{0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                                \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                                pdir.tail[0], pdir.tail[1], pair[0], pair[1]);\n\n                        \n                        \n                        \n                        uint16_t moveid = 0x3ff;\n                        if (lfs2_gstate_hasmovehere(&lfs2->gstate, pdir.pair)) {\n                            moveid = lfs2_tag_id(lfs2->gstate.tag);\n                            LFS2_DEBUG(\"Fixing move while fixing orphans \"\n                                    \"{0x%\"PRIx32\", 0x%\"PRIx32\"} 0x%\"PRIx16\"\\n\",\n                                    pdir.pair[0], pdir.pair[1], moveid);\n                            lfs2_fs_prepmove(lfs2, 0x3ff, NULL);\n                        }\n\n                        lfs2_pair_tole32(pair);\n                        state = lfs2_dir_orphaningcommit(lfs2, &pdir, LFS2_MKATTRS(\n                                {LFS2_MKTAG_IF(moveid != 0x3ff,\n                                    LFS2_TYPE_DELETE, moveid, 0), NULL},\n                                {LFS2_MKTAG(LFS2_TYPE_SOFTTAIL, 0x3ff, 8),\n                                    pair}));\n                        lfs2_pair_fromle32(pair);\n                        if (state < 0) {\n                            return state;\n                        }\n\n                        \n                        if (state == LFS2_OK_ORPHANED) {\n                            moreorphans = true;\n                        }\n\n                        \n                        continue;\n                    }\n                }\n\n                \n                \n                \n                if (pass == 1 && tag == LFS2_ERR_NOENT && powerloss) {\n                    \n                    LFS2_DEBUG(\"Fixing orphan {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                            pdir.tail[0], pdir.tail[1]);\n\n                    \n                    err = lfs2_dir_getgstate(lfs2, &dir, &lfs2->gdelta);\n                    if (err) {\n                        return err;\n                    }\n\n                    \n                    lfs2_pair_tole32(dir.tail);\n                    int state = lfs2_dir_orphaningcommit(lfs2, &pdir, LFS2_MKATTRS(\n                            {LFS2_MKTAG(LFS2_TYPE_TAIL + dir.split, 0x3ff, 8),\n                                dir.tail}));\n                    lfs2_pair_fromle32(dir.tail);\n                    if (state < 0) {\n                        return state;\n                    }\n\n                    \n                    if (state == LFS2_OK_ORPHANED) {\n                        moreorphans = true;\n                    }\n\n                    \n                    continue;\n                }\n            }\n\n            pdir = dir;\n        }\n\n        pass = moreorphans ? 0 : pass+1;\n    }\n\n    \n    return lfs2_fs_preporphans(lfs2, -lfs2_gstate_getorphans(&lfs2->gstate));\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_forceconsistency(lfs2_t *lfs2) {\n    int err = lfs2_fs_desuperblock(lfs2);\n    if (err) {\n        return err;\n    }\n\n    err = lfs2_fs_demove(lfs2);\n    if (err) {\n        return err;\n    }\n\n    err = lfs2_fs_deorphan(lfs2, true);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n#endif\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_rawmkconsistent(lfs2_t *lfs2) {\n    \n    int err = lfs2_fs_forceconsistency(lfs2);\n    if (err) {\n        return err;\n    }\n\n    \n    lfs2_gstate_t delta = {0};\n    lfs2_gstate_xor(&delta, &lfs2->gdisk);\n    lfs2_gstate_xor(&delta, &lfs2->gstate);\n    if (!lfs2_gstate_iszero(&delta)) {\n        \n        lfs2_mdir_t root;\n        err = lfs2_dir_fetch(lfs2, &root, lfs2->root);\n        if (err) {\n            return err;\n        }\n\n        err = lfs2_dir_commit(lfs2, &root, NULL, 0);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n#endif\n\nstatic int lfs2_fs_size_count(void *p, lfs2_block_t block) {\n    (void)block;\n    lfs2_size_t *size = p;\n    *size += 1;\n    return 0;\n}\n\nstatic lfs2_ssize_t lfs2_fs_rawsize(lfs2_t *lfs2) {\n    lfs2_size_t size = 0;\n    int err = lfs2_fs_rawtraverse(lfs2, lfs2_fs_size_count, &size, false);\n    if (err) {\n        return err;\n    }\n\n    return size;\n}\n\n#ifndef LFS2_READONLY\nstatic int lfs2_fs_rawgrow(lfs2_t *lfs2, lfs2_size_t block_count) {\n    \n    LFS2_ASSERT(block_count >= lfs2->block_count);\n\n    if (block_count > lfs2->block_count) {\n        lfs2->block_count = block_count;\n\n        \n        lfs2_mdir_t root;\n        int err = lfs2_dir_fetch(lfs2, &root, lfs2->root);\n        if (err) {\n            return err;\n        }\n\n        \n        lfs2_superblock_t superblock;\n        lfs2_stag_t tag = lfs2_dir_get(lfs2, &root, LFS2_MKTAG(0x7ff, 0x3ff, 0),\n                LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                &superblock);\n        if (tag < 0) {\n            return tag;\n        }\n        lfs2_superblock_fromle32(&superblock);\n\n        superblock.block_count = lfs2->block_count;\n\n        lfs2_superblock_tole32(&superblock);\n        err = lfs2_dir_commit(lfs2, &root, LFS2_MKATTRS(\n                {tag, &superblock}));\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n#endif\n\n#ifdef LFS2_MIGRATE\n\n\n\n\n\n\n\n#define LFS21_VERSION 0x00010007\n#define LFS21_VERSION_MAJOR (0xffff & (LFS21_VERSION >> 16))\n#define LFS21_VERSION_MINOR (0xffff & (LFS21_VERSION >>  0))\n\n\n\n\n#define LFS21_DISK_VERSION 0x00010001\n#define LFS21_DISK_VERSION_MAJOR (0xffff & (LFS21_DISK_VERSION >> 16))\n#define LFS21_DISK_VERSION_MINOR (0xffff & (LFS21_DISK_VERSION >>  0))\n\n\n\n\n\nenum lfs21_type {\n    LFS21_TYPE_REG        = 0x11,\n    LFS21_TYPE_DIR        = 0x22,\n    LFS21_TYPE_SUPERBLOCK = 0x2e,\n};\n\ntypedef struct lfs21 {\n    lfs2_block_t root[2];\n} lfs21_t;\n\ntypedef struct lfs21_entry {\n    lfs2_off_t off;\n\n    struct lfs21_disk_entry {\n        uint8_t type;\n        uint8_t elen;\n        uint8_t alen;\n        uint8_t nlen;\n        union {\n            struct {\n                lfs2_block_t head;\n                lfs2_size_t size;\n            } file;\n            lfs2_block_t dir[2];\n        } u;\n    } d;\n} lfs21_entry_t;\n\ntypedef struct lfs21_dir {\n    struct lfs21_dir *next;\n    lfs2_block_t pair[2];\n    lfs2_off_t off;\n\n    lfs2_block_t head[2];\n    lfs2_off_t pos;\n\n    struct lfs21_disk_dir {\n        uint32_t rev;\n        lfs2_size_t size;\n        lfs2_block_t tail[2];\n    } d;\n} lfs21_dir_t;\n\ntypedef struct lfs21_superblock {\n    lfs2_off_t off;\n\n    struct lfs21_disk_superblock {\n        uint8_t type;\n        uint8_t elen;\n        uint8_t alen;\n        uint8_t nlen;\n        lfs2_block_t root[2];\n        uint32_t block_size;\n        uint32_t block_count;\n        uint32_t version;\n        char magic[8];\n    } d;\n} lfs21_superblock_t;\n\n\n\nstatic void lfs21_crc(uint32_t *crc, const void *buffer, size_t size) {\n    *crc = lfs2_crc(*crc, buffer, size);\n}\n\nstatic int lfs21_bd_read(lfs2_t *lfs2, lfs2_block_t block,\n        lfs2_off_t off, void *buffer, lfs2_size_t size) {\n    \n    \n    return lfs2_bd_read(lfs2, &lfs2->pcache, &lfs2->rcache, size,\n            block, off, buffer, size);\n}\n\nstatic int lfs21_bd_crc(lfs2_t *lfs2, lfs2_block_t block,\n        lfs2_off_t off, lfs2_size_t size, uint32_t *crc) {\n    for (lfs2_off_t i = 0; i < size; i++) {\n        uint8_t c;\n        int err = lfs21_bd_read(lfs2, block, off+i, &c, 1);\n        if (err) {\n            return err;\n        }\n\n        lfs21_crc(crc, &c, 1);\n    }\n\n    return 0;\n}\n\n\n\nstatic void lfs21_dir_fromle32(struct lfs21_disk_dir *d) {\n    d->rev     = lfs2_fromle32(d->rev);\n    d->size    = lfs2_fromle32(d->size);\n    d->tail[0] = lfs2_fromle32(d->tail[0]);\n    d->tail[1] = lfs2_fromle32(d->tail[1]);\n}\n\nstatic void lfs21_dir_tole32(struct lfs21_disk_dir *d) {\n    d->rev     = lfs2_tole32(d->rev);\n    d->size    = lfs2_tole32(d->size);\n    d->tail[0] = lfs2_tole32(d->tail[0]);\n    d->tail[1] = lfs2_tole32(d->tail[1]);\n}\n\nstatic void lfs21_entry_fromle32(struct lfs21_disk_entry *d) {\n    d->u.dir[0] = lfs2_fromle32(d->u.dir[0]);\n    d->u.dir[1] = lfs2_fromle32(d->u.dir[1]);\n}\n\nstatic void lfs21_entry_tole32(struct lfs21_disk_entry *d) {\n    d->u.dir[0] = lfs2_tole32(d->u.dir[0]);\n    d->u.dir[1] = lfs2_tole32(d->u.dir[1]);\n}\n\nstatic void lfs21_superblock_fromle32(struct lfs21_disk_superblock *d) {\n    d->root[0]     = lfs2_fromle32(d->root[0]);\n    d->root[1]     = lfs2_fromle32(d->root[1]);\n    d->block_size  = lfs2_fromle32(d->block_size);\n    d->block_count = lfs2_fromle32(d->block_count);\n    d->version     = lfs2_fromle32(d->version);\n}\n\n\n\nstatic inline lfs2_size_t lfs21_entry_size(const lfs21_entry_t *entry) {\n    return 4 + entry->d.elen + entry->d.alen + entry->d.nlen;\n}\n\nstatic int lfs21_dir_fetch(lfs2_t *lfs2,\n        lfs21_dir_t *dir, const lfs2_block_t pair[2]) {\n    \n    const lfs2_block_t tpair[2] = {pair[0], pair[1]};\n    bool valid = false;\n\n    \n    for (int i = 0; i < 2; i++) {\n        struct lfs21_disk_dir test;\n        int err = lfs21_bd_read(lfs2, tpair[i], 0, &test, sizeof(test));\n        lfs21_dir_fromle32(&test);\n        if (err) {\n            if (err == LFS2_ERR_CORRUPT) {\n                continue;\n            }\n            return err;\n        }\n\n        if (valid && lfs2_scmp(test.rev, dir->d.rev) < 0) {\n            continue;\n        }\n\n        if ((0x7fffffff & test.size) < sizeof(test)+4 ||\n            (0x7fffffff & test.size) > lfs2->cfg->block_size) {\n            continue;\n        }\n\n        uint32_t crc = 0xffffffff;\n        lfs21_dir_tole32(&test);\n        lfs21_crc(&crc, &test, sizeof(test));\n        lfs21_dir_fromle32(&test);\n        err = lfs21_bd_crc(lfs2, tpair[i], sizeof(test),\n                (0x7fffffff & test.size) - sizeof(test), &crc);\n        if (err) {\n            if (err == LFS2_ERR_CORRUPT) {\n                continue;\n            }\n            return err;\n        }\n\n        if (crc != 0) {\n            continue;\n        }\n\n        valid = true;\n\n        \n        dir->pair[0] = tpair[(i+0) % 2];\n        dir->pair[1] = tpair[(i+1) % 2];\n        dir->off = sizeof(dir->d);\n        dir->d = test;\n    }\n\n    if (!valid) {\n        LFS2_ERROR(\"Corrupted dir pair at {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                tpair[0], tpair[1]);\n        return LFS2_ERR_CORRUPT;\n    }\n\n    return 0;\n}\n\nstatic int lfs21_dir_next(lfs2_t *lfs2, lfs21_dir_t *dir, lfs21_entry_t *entry) {\n    while (dir->off + sizeof(entry->d) > (0x7fffffff & dir->d.size)-4) {\n        if (!(0x80000000 & dir->d.size)) {\n            entry->off = dir->off;\n            return LFS2_ERR_NOENT;\n        }\n\n        int err = lfs21_dir_fetch(lfs2, dir, dir->d.tail);\n        if (err) {\n            return err;\n        }\n\n        dir->off = sizeof(dir->d);\n        dir->pos += sizeof(dir->d) + 4;\n    }\n\n    int err = lfs21_bd_read(lfs2, dir->pair[0], dir->off,\n            &entry->d, sizeof(entry->d));\n    lfs21_entry_fromle32(&entry->d);\n    if (err) {\n        return err;\n    }\n\n    entry->off = dir->off;\n    dir->off += lfs21_entry_size(entry);\n    dir->pos += lfs21_entry_size(entry);\n    return 0;\n}\n\n\nint lfs21_traverse(lfs2_t *lfs2, int (*cb)(void*, lfs2_block_t), void *data) {\n    if (lfs2_pair_isnull(lfs2->lfs21->root)) {\n        return 0;\n    }\n\n    \n    lfs21_dir_t dir;\n    lfs21_entry_t entry;\n    lfs2_block_t cwd[2] = {0, 1};\n\n    while (true) {\n        for (int i = 0; i < 2; i++) {\n            int err = cb(data, cwd[i]);\n            if (err) {\n                return err;\n            }\n        }\n\n        int err = lfs21_dir_fetch(lfs2, &dir, cwd);\n        if (err) {\n            return err;\n        }\n\n        \n        while (dir.off + sizeof(entry.d) <= (0x7fffffff & dir.d.size)-4) {\n            err = lfs21_bd_read(lfs2, dir.pair[0], dir.off,\n                    &entry.d, sizeof(entry.d));\n            lfs21_entry_fromle32(&entry.d);\n            if (err) {\n                return err;\n            }\n\n            dir.off += lfs21_entry_size(&entry);\n            if ((0x70 & entry.d.type) == (0x70 & LFS21_TYPE_REG)) {\n                err = lfs2_ctz_traverse(lfs2, NULL, &lfs2->rcache,\n                        entry.d.u.file.head, entry.d.u.file.size, cb, data);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        \n        lfs2_mdir_t dir2 = {.split=true, .tail={cwd[0], cwd[1]}};\n        while (dir2.split) {\n            err = lfs2_dir_fetch(lfs2, &dir2, dir2.tail);\n            if (err) {\n                break;\n            }\n\n            for (int i = 0; i < 2; i++) {\n                err = cb(data, dir2.pair[i]);\n                if (err) {\n                    return err;\n                }\n            }\n        }\n\n        cwd[0] = dir.d.tail[0];\n        cwd[1] = dir.d.tail[1];\n\n        if (lfs2_pair_isnull(cwd)) {\n            break;\n        }\n    }\n\n    return 0;\n}\n\nstatic int lfs21_moved(lfs2_t *lfs2, const void *e) {\n    if (lfs2_pair_isnull(lfs2->lfs21->root)) {\n        return 0;\n    }\n\n    \n    lfs21_dir_t cwd;\n    int err = lfs21_dir_fetch(lfs2, &cwd, (const lfs2_block_t[2]){0, 1});\n    if (err) {\n        return err;\n    }\n\n    \n    lfs21_entry_t entry;\n    while (!lfs2_pair_isnull(cwd.d.tail)) {\n        err = lfs21_dir_fetch(lfs2, &cwd, cwd.d.tail);\n        if (err) {\n            return err;\n        }\n\n        while (true) {\n            err = lfs21_dir_next(lfs2, &cwd, &entry);\n            if (err && err != LFS2_ERR_NOENT) {\n                return err;\n            }\n\n            if (err == LFS2_ERR_NOENT) {\n                break;\n            }\n\n            if (!(0x80 & entry.d.type) &&\n                 memcmp(&entry.d.u, e, sizeof(entry.d.u)) == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nstatic int lfs21_mount(lfs2_t *lfs2, struct lfs21 *lfs21,\n        const struct lfs2_config *cfg) {\n    int err = 0;\n    {\n        err = lfs2_init(lfs2, cfg);\n        if (err) {\n            return err;\n        }\n\n        lfs2->lfs21 = lfs21;\n        lfs2->lfs21->root[0] = LFS2_BLOCK_NULL;\n        lfs2->lfs21->root[1] = LFS2_BLOCK_NULL;\n\n        \n        lfs2->free.off = 0;\n        lfs2->free.size = 0;\n        lfs2->free.i = 0;\n        lfs2_alloc_ack(lfs2);\n\n        \n        lfs21_dir_t dir;\n        lfs21_superblock_t superblock;\n        err = lfs21_dir_fetch(lfs2, &dir, (const lfs2_block_t[2]){0, 1});\n        if (err && err != LFS2_ERR_CORRUPT) {\n            goto cleanup;\n        }\n\n        if (!err) {\n            err = lfs21_bd_read(lfs2, dir.pair[0], sizeof(dir.d),\n                    &superblock.d, sizeof(superblock.d));\n            lfs21_superblock_fromle32(&superblock.d);\n            if (err) {\n                goto cleanup;\n            }\n\n            lfs2->lfs21->root[0] = superblock.d.root[0];\n            lfs2->lfs21->root[1] = superblock.d.root[1];\n        }\n\n        if (err || memcmp(superblock.d.magic, \"littlefs\", 8) != 0) {\n            LFS2_ERROR(\"Invalid superblock at {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                    0, 1);\n            err = LFS2_ERR_CORRUPT;\n            goto cleanup;\n        }\n\n        uint16_t major_version = (0xffff & (superblock.d.version >> 16));\n        uint16_t minor_version = (0xffff & (superblock.d.version >>  0));\n        if ((major_version != LFS21_DISK_VERSION_MAJOR ||\n             minor_version > LFS21_DISK_VERSION_MINOR)) {\n            LFS2_ERROR(\"Invalid version v%d.%d\", major_version, minor_version);\n            err = LFS2_ERR_INVAL;\n            goto cleanup;\n        }\n\n        return 0;\n    }\n\ncleanup:\n    lfs2_deinit(lfs2);\n    return err;\n}\n\nstatic int lfs21_unmount(lfs2_t *lfs2) {\n    return lfs2_deinit(lfs2);\n}\n\n\nstatic int lfs2_rawmigrate(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    struct lfs21 lfs21;\n\n    \n    LFS2_ASSERT(cfg->block_count != 0);\n\n    int err = lfs21_mount(lfs2, &lfs21, cfg);\n    if (err) {\n        return err;\n    }\n\n    {\n        \n        \n        lfs21_dir_t dir1;\n        lfs2_mdir_t dir2;\n        dir1.d.tail[0] = lfs2->lfs21->root[0];\n        dir1.d.tail[1] = lfs2->lfs21->root[1];\n        while (!lfs2_pair_isnull(dir1.d.tail)) {\n            \n            err = lfs21_dir_fetch(lfs2, &dir1, dir1.d.tail);\n            if (err) {\n                goto cleanup;\n            }\n\n            \n            err = lfs2_dir_alloc(lfs2, &dir2);\n            if (err) {\n                goto cleanup;\n            }\n\n            dir2.rev = dir1.d.rev;\n            dir1.head[0] = dir1.pair[0];\n            dir1.head[1] = dir1.pair[1];\n            lfs2->root[0] = dir2.pair[0];\n            lfs2->root[1] = dir2.pair[1];\n\n            err = lfs2_dir_commit(lfs2, &dir2, NULL, 0);\n            if (err) {\n                goto cleanup;\n            }\n\n            while (true) {\n                lfs21_entry_t entry1;\n                err = lfs21_dir_next(lfs2, &dir1, &entry1);\n                if (err && err != LFS2_ERR_NOENT) {\n                    goto cleanup;\n                }\n\n                if (err == LFS2_ERR_NOENT) {\n                    break;\n                }\n\n                \n                if (entry1.d.type & 0x80) {\n                    int moved = lfs21_moved(lfs2, &entry1.d.u);\n                    if (moved < 0) {\n                        err = moved;\n                        goto cleanup;\n                    }\n\n                    if (moved) {\n                        continue;\n                    }\n\n                    entry1.d.type &= ~0x80;\n                }\n\n                \n                char name[LFS2_NAME_MAX+1];\n                memset(name, 0, sizeof(name));\n                err = lfs21_bd_read(lfs2, dir1.pair[0],\n                        entry1.off + 4+entry1.d.elen+entry1.d.alen,\n                        name, entry1.d.nlen);\n                if (err) {\n                    goto cleanup;\n                }\n\n                bool isdir = (entry1.d.type == LFS21_TYPE_DIR);\n\n                \n                err = lfs2_dir_fetch(lfs2, &dir2, lfs2->root);\n                if (err) {\n                    goto cleanup;\n                }\n\n                uint16_t id;\n                err = lfs2_dir_find(lfs2, &dir2, &(const char*){name}, &id);\n                if (!(err == LFS2_ERR_NOENT && id != 0x3ff)) {\n                    err = (err < 0) ? err : LFS2_ERR_EXIST;\n                    goto cleanup;\n                }\n\n                lfs21_entry_tole32(&entry1.d);\n                err = lfs2_dir_commit(lfs2, &dir2, LFS2_MKATTRS(\n                        {LFS2_MKTAG(LFS2_TYPE_CREATE, id, 0), NULL},\n                        {LFS2_MKTAG_IF_ELSE(isdir,\n                            LFS2_TYPE_DIR, id, entry1.d.nlen,\n                            LFS2_TYPE_REG, id, entry1.d.nlen),\n                                name},\n                        {LFS2_MKTAG_IF_ELSE(isdir,\n                            LFS2_TYPE_DIRSTRUCT, id, sizeof(entry1.d.u),\n                            LFS2_TYPE_CTZSTRUCT, id, sizeof(entry1.d.u)),\n                                &entry1.d.u}));\n                lfs21_entry_fromle32(&entry1.d);\n                if (err) {\n                    goto cleanup;\n                }\n            }\n\n            if (!lfs2_pair_isnull(dir1.d.tail)) {\n                \n                err = lfs2_dir_fetch(lfs2, &dir2, lfs2->root);\n                if (err) {\n                    goto cleanup;\n                }\n\n                while (dir2.split) {\n                    err = lfs2_dir_fetch(lfs2, &dir2, dir2.tail);\n                    if (err) {\n                        goto cleanup;\n                    }\n                }\n\n                lfs2_pair_tole32(dir2.pair);\n                err = lfs2_dir_commit(lfs2, &dir2, LFS2_MKATTRS(\n                        {LFS2_MKTAG(LFS2_TYPE_SOFTTAIL, 0x3ff, 8), dir1.d.tail}));\n                lfs2_pair_fromle32(dir2.pair);\n                if (err) {\n                    goto cleanup;\n                }\n            }\n\n            \n            \n            LFS2_DEBUG(\"Migrating {0x%\"PRIx32\", 0x%\"PRIx32\"} \"\n                        \"-> {0x%\"PRIx32\", 0x%\"PRIx32\"}\",\n                    lfs2->root[0], lfs2->root[1], dir1.head[0], dir1.head[1]);\n\n            err = lfs2_bd_erase(lfs2, dir1.head[1]);\n            if (err) {\n                goto cleanup;\n            }\n\n            err = lfs2_dir_fetch(lfs2, &dir2, lfs2->root);\n            if (err) {\n                goto cleanup;\n            }\n\n            for (lfs2_off_t i = 0; i < dir2.off; i++) {\n                uint8_t dat;\n                err = lfs2_bd_read(lfs2,\n                        NULL, &lfs2->rcache, dir2.off,\n                        dir2.pair[0], i, &dat, 1);\n                if (err) {\n                    goto cleanup;\n                }\n\n                err = lfs2_bd_prog(lfs2,\n                        &lfs2->pcache, &lfs2->rcache, true,\n                        dir1.head[1], i, &dat, 1);\n                if (err) {\n                    goto cleanup;\n                }\n            }\n\n            err = lfs2_bd_flush(lfs2, &lfs2->pcache, &lfs2->rcache, true);\n            if (err) {\n                goto cleanup;\n            }\n        }\n\n        \n        err = lfs21_dir_fetch(lfs2, &dir1, (const lfs2_block_t[2]){0, 1});\n        if (err) {\n            goto cleanup;\n        }\n\n        dir2.pair[0] = dir1.pair[0];\n        dir2.pair[1] = dir1.pair[1];\n        dir2.rev = dir1.d.rev;\n        dir2.off = sizeof(dir2.rev);\n        dir2.etag = 0xffffffff;\n        dir2.count = 0;\n        dir2.tail[0] = lfs2->lfs21->root[0];\n        dir2.tail[1] = lfs2->lfs21->root[1];\n        dir2.erased = false;\n        dir2.split = true;\n\n        lfs2_superblock_t superblock = {\n            .version     = LFS2_DISK_VERSION,\n            .block_size  = lfs2->cfg->block_size,\n            .block_count = lfs2->cfg->block_count,\n            .name_max    = lfs2->name_max,\n            .file_max    = lfs2->file_max,\n            .attr_max    = lfs2->attr_max,\n        };\n\n        lfs2_superblock_tole32(&superblock);\n        err = lfs2_dir_commit(lfs2, &dir2, LFS2_MKATTRS(\n                {LFS2_MKTAG(LFS2_TYPE_CREATE, 0, 0), NULL},\n                {LFS2_MKTAG(LFS2_TYPE_SUPERBLOCK, 0, 8), \"littlefs\"},\n                {LFS2_MKTAG(LFS2_TYPE_INLINESTRUCT, 0, sizeof(superblock)),\n                    &superblock}));\n        if (err) {\n            goto cleanup;\n        }\n\n        \n        err = lfs2_dir_fetch(lfs2, &dir2, (const lfs2_block_t[2]){0, 1});\n        if (err) {\n            goto cleanup;\n        }\n\n        \n        dir2.erased = false;\n        err = lfs2_dir_commit(lfs2, &dir2, NULL, 0);\n        if (err) {\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    lfs21_unmount(lfs2);\n    return err;\n}\n\n#endif\n\n\n\n\n\n\n\n#ifdef LFS2_THREADSAFE\n#define LFS2_LOCK(cfg)   cfg->lock(cfg)\n#define LFS2_UNLOCK(cfg) cfg->unlock(cfg)\n#else\n#define LFS2_LOCK(cfg)   ((void)cfg, 0)\n#define LFS2_UNLOCK(cfg) ((void)cfg)\n#endif\n\n\n#ifndef LFS2_READONLY\nint lfs2_format(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    int err = LFS2_LOCK(cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_format(%p, %p {.context=%p, \"\n                \".read=%p, .prog=%p, .erase=%p, .sync=%p, \"\n                \".read_size=%\"PRIu32\", .prog_size=%\"PRIu32\", \"\n                \".block_size=%\"PRIu32\", .block_count=%\"PRIu32\", \"\n                \".block_cycles=%\"PRIu32\", .cache_size=%\"PRIu32\", \"\n                \".lookahead_size=%\"PRIu32\", .read_buffer=%p, \"\n                \".prog_buffer=%p, .lookahead_buffer=%p, \"\n                \".name_max=%\"PRIu32\", .file_max=%\"PRIu32\", \"\n                \".attr_max=%\"PRIu32\"})\",\n            (void*)lfs2, (void*)cfg, cfg->context,\n            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,\n            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,\n            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,\n            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,\n            cfg->name_max, cfg->file_max, cfg->attr_max);\n\n    err = lfs2_rawformat(lfs2, cfg);\n\n    LFS2_TRACE(\"lfs2_format -> %d\", err);\n    LFS2_UNLOCK(cfg);\n    return err;\n}\n#endif\n\nint lfs2_mount(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    int err = LFS2_LOCK(cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_mount(%p, %p {.context=%p, \"\n                \".read=%p, .prog=%p, .erase=%p, .sync=%p, \"\n                \".read_size=%\"PRIu32\", .prog_size=%\"PRIu32\", \"\n                \".block_size=%\"PRIu32\", .block_count=%\"PRIu32\", \"\n                \".block_cycles=%\"PRIu32\", .cache_size=%\"PRIu32\", \"\n                \".lookahead_size=%\"PRIu32\", .read_buffer=%p, \"\n                \".prog_buffer=%p, .lookahead_buffer=%p, \"\n                \".name_max=%\"PRIu32\", .file_max=%\"PRIu32\", \"\n                \".attr_max=%\"PRIu32\"})\",\n            (void*)lfs2, (void*)cfg, cfg->context,\n            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,\n            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,\n            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,\n            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,\n            cfg->name_max, cfg->file_max, cfg->attr_max);\n\n    err = lfs2_rawmount(lfs2, cfg);\n\n    LFS2_TRACE(\"lfs2_mount -> %d\", err);\n    LFS2_UNLOCK(cfg);\n    return err;\n}\n\nint lfs2_unmount(lfs2_t *lfs2) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_unmount(%p)\", (void*)lfs2);\n\n    err = lfs2_rawunmount(lfs2);\n\n    LFS2_TRACE(\"lfs2_unmount -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\n#ifndef LFS2_READONLY\nint lfs2_remove(lfs2_t *lfs2, const char *path) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_remove(%p, \\\"%s\\\")\", (void*)lfs2, path);\n\n    err = lfs2_rawremove(lfs2, path);\n\n    LFS2_TRACE(\"lfs2_remove -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\n#ifndef LFS2_READONLY\nint lfs2_rename(lfs2_t *lfs2, const char *oldpath, const char *newpath) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_rename(%p, \\\"%s\\\", \\\"%s\\\")\", (void*)lfs2, oldpath, newpath);\n\n    err = lfs2_rawrename(lfs2, oldpath, newpath);\n\n    LFS2_TRACE(\"lfs2_rename -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\nint lfs2_stat(lfs2_t *lfs2, const char *path, struct lfs2_info *info) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_stat(%p, \\\"%s\\\", %p)\", (void*)lfs2, path, (void*)info);\n\n    err = lfs2_rawstat(lfs2, path, info);\n\n    LFS2_TRACE(\"lfs2_stat -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nlfs2_ssize_t lfs2_getattr(lfs2_t *lfs2, const char *path,\n        uint8_t type, void *buffer, lfs2_size_t size) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_getattr(%p, \\\"%s\\\", %\"PRIu8\", %p, %\"PRIu32\")\",\n            (void*)lfs2, path, type, buffer, size);\n\n    lfs2_ssize_t res = lfs2_rawgetattr(lfs2, path, type, buffer, size);\n\n    LFS2_TRACE(\"lfs2_getattr -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\n#ifndef LFS2_READONLY\nint lfs2_setattr(lfs2_t *lfs2, const char *path,\n        uint8_t type, const void *buffer, lfs2_size_t size) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_setattr(%p, \\\"%s\\\", %\"PRIu8\", %p, %\"PRIu32\")\",\n            (void*)lfs2, path, type, buffer, size);\n\n    err = lfs2_rawsetattr(lfs2, path, type, buffer, size);\n\n    LFS2_TRACE(\"lfs2_setattr -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\n#ifndef LFS2_READONLY\nint lfs2_removeattr(lfs2_t *lfs2, const char *path, uint8_t type) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_removeattr(%p, \\\"%s\\\", %\"PRIu8\")\", (void*)lfs2, path, type);\n\n    err = lfs2_rawremoveattr(lfs2, path, type);\n\n    LFS2_TRACE(\"lfs2_removeattr -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\n#ifndef LFS2_NO_MALLOC\nint lfs2_file_open(lfs2_t *lfs2, lfs2_file_t *file, const char *path, int flags) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_open(%p, %p, \\\"%s\\\", %x)\",\n            (void*)lfs2, (void*)file, path, flags);\n    LFS2_ASSERT(!lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    err = lfs2_file_rawopen(lfs2, file, path, flags);\n\n    LFS2_TRACE(\"lfs2_file_open -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\nint lfs2_file_opencfg(lfs2_t *lfs2, lfs2_file_t *file,\n        const char *path, int flags,\n        const struct lfs2_file_config *cfg) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_opencfg(%p, %p, \\\"%s\\\", %x, %p {\"\n                 \".buffer=%p, .attrs=%p, .attr_count=%\"PRIu32\"})\",\n            (void*)lfs2, (void*)file, path, flags,\n            (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);\n    LFS2_ASSERT(!lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    err = lfs2_file_rawopencfg(lfs2, file, path, flags, cfg);\n\n    LFS2_TRACE(\"lfs2_file_opencfg -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nint lfs2_file_close(lfs2_t *lfs2, lfs2_file_t *file) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_close(%p, %p)\", (void*)lfs2, (void*)file);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    err = lfs2_file_rawclose(lfs2, file);\n\n    LFS2_TRACE(\"lfs2_file_close -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\n#ifndef LFS2_READONLY\nint lfs2_file_sync(lfs2_t *lfs2, lfs2_file_t *file) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_sync(%p, %p)\", (void*)lfs2, (void*)file);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    err = lfs2_file_rawsync(lfs2, file);\n\n    LFS2_TRACE(\"lfs2_file_sync -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\nlfs2_ssize_t lfs2_file_read(lfs2_t *lfs2, lfs2_file_t *file,\n        void *buffer, lfs2_size_t size) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_read(%p, %p, %p, %\"PRIu32\")\",\n            (void*)lfs2, (void*)file, buffer, size);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    lfs2_ssize_t res = lfs2_file_rawread(lfs2, file, buffer, size);\n\n    LFS2_TRACE(\"lfs2_file_read -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\n#ifndef LFS2_READONLY\nlfs2_ssize_t lfs2_file_write(lfs2_t *lfs2, lfs2_file_t *file,\n        const void *buffer, lfs2_size_t size) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_write(%p, %p, %p, %\"PRIu32\")\",\n            (void*)lfs2, (void*)file, buffer, size);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    lfs2_ssize_t res = lfs2_file_rawwrite(lfs2, file, buffer, size);\n\n    LFS2_TRACE(\"lfs2_file_write -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n#endif\n\nlfs2_soff_t lfs2_file_seek(lfs2_t *lfs2, lfs2_file_t *file,\n        lfs2_soff_t off, int whence) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_seek(%p, %p, %\"PRId32\", %d)\",\n            (void*)lfs2, (void*)file, off, whence);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    lfs2_soff_t res = lfs2_file_rawseek(lfs2, file, off, whence);\n\n    LFS2_TRACE(\"lfs2_file_seek -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\n#ifndef LFS2_READONLY\nint lfs2_file_truncate(lfs2_t *lfs2, lfs2_file_t *file, lfs2_off_t size) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_truncate(%p, %p, %\"PRIu32\")\",\n            (void*)lfs2, (void*)file, size);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    err = lfs2_file_rawtruncate(lfs2, file, size);\n\n    LFS2_TRACE(\"lfs2_file_truncate -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\nlfs2_soff_t lfs2_file_tell(lfs2_t *lfs2, lfs2_file_t *file) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_tell(%p, %p)\", (void*)lfs2, (void*)file);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    lfs2_soff_t res = lfs2_file_rawtell(lfs2, file);\n\n    LFS2_TRACE(\"lfs2_file_tell -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\nint lfs2_file_rewind(lfs2_t *lfs2, lfs2_file_t *file) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_rewind(%p, %p)\", (void*)lfs2, (void*)file);\n\n    err = lfs2_file_rawrewind(lfs2, file);\n\n    LFS2_TRACE(\"lfs2_file_rewind -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nlfs2_soff_t lfs2_file_size(lfs2_t *lfs2, lfs2_file_t *file) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_file_size(%p, %p)\", (void*)lfs2, (void*)file);\n    LFS2_ASSERT(lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)file));\n\n    lfs2_soff_t res = lfs2_file_rawsize(lfs2, file);\n\n    LFS2_TRACE(\"lfs2_file_size -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\n#ifndef LFS2_READONLY\nint lfs2_mkdir(lfs2_t *lfs2, const char *path) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_mkdir(%p, \\\"%s\\\")\", (void*)lfs2, path);\n\n    err = lfs2_rawmkdir(lfs2, path);\n\n    LFS2_TRACE(\"lfs2_mkdir -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\nint lfs2_dir_open(lfs2_t *lfs2, lfs2_dir_t *dir, const char *path) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_dir_open(%p, %p, \\\"%s\\\")\", (void*)lfs2, (void*)dir, path);\n    LFS2_ASSERT(!lfs2_mlist_isopen(lfs2->mlist, (struct lfs2_mlist*)dir));\n\n    err = lfs2_dir_rawopen(lfs2, dir, path);\n\n    LFS2_TRACE(\"lfs2_dir_open -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nint lfs2_dir_close(lfs2_t *lfs2, lfs2_dir_t *dir) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_dir_close(%p, %p)\", (void*)lfs2, (void*)dir);\n\n    err = lfs2_dir_rawclose(lfs2, dir);\n\n    LFS2_TRACE(\"lfs2_dir_close -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nint lfs2_dir_read(lfs2_t *lfs2, lfs2_dir_t *dir, struct lfs2_info *info) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_dir_read(%p, %p, %p)\",\n            (void*)lfs2, (void*)dir, (void*)info);\n\n    err = lfs2_dir_rawread(lfs2, dir, info);\n\n    LFS2_TRACE(\"lfs2_dir_read -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nint lfs2_dir_seek(lfs2_t *lfs2, lfs2_dir_t *dir, lfs2_off_t off) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_dir_seek(%p, %p, %\"PRIu32\")\",\n            (void*)lfs2, (void*)dir, off);\n\n    err = lfs2_dir_rawseek(lfs2, dir, off);\n\n    LFS2_TRACE(\"lfs2_dir_seek -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nlfs2_soff_t lfs2_dir_tell(lfs2_t *lfs2, lfs2_dir_t *dir) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_dir_tell(%p, %p)\", (void*)lfs2, (void*)dir);\n\n    lfs2_soff_t res = lfs2_dir_rawtell(lfs2, dir);\n\n    LFS2_TRACE(\"lfs2_dir_tell -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\nint lfs2_dir_rewind(lfs2_t *lfs2, lfs2_dir_t *dir) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_dir_rewind(%p, %p)\", (void*)lfs2, (void*)dir);\n\n    err = lfs2_dir_rawrewind(lfs2, dir);\n\n    LFS2_TRACE(\"lfs2_dir_rewind -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nint lfs2_fs_stat(lfs2_t *lfs2, struct lfs2_fsinfo *fsinfo) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_fs_stat(%p, %p)\", (void*)lfs2, (void*)fsinfo);\n\n    err = lfs2_fs_rawstat(lfs2, fsinfo);\n\n    LFS2_TRACE(\"lfs2_fs_stat -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\nlfs2_ssize_t lfs2_fs_size(lfs2_t *lfs2) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_fs_size(%p)\", (void*)lfs2);\n\n    lfs2_ssize_t res = lfs2_fs_rawsize(lfs2);\n\n    LFS2_TRACE(\"lfs2_fs_size -> %\"PRId32, res);\n    LFS2_UNLOCK(lfs2->cfg);\n    return res;\n}\n\nint lfs2_fs_traverse(lfs2_t *lfs2, int (*cb)(void *, lfs2_block_t), void *data) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_fs_traverse(%p, %p, %p)\",\n            (void*)lfs2, (void*)(uintptr_t)cb, data);\n\n    err = lfs2_fs_rawtraverse(lfs2, cb, data, true);\n\n    LFS2_TRACE(\"lfs2_fs_traverse -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n\n#ifndef LFS2_READONLY\nint lfs2_fs_gc(lfs2_t *lfs2) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_fs_gc(%p)\", (void*)lfs2);\n\n    err = lfs2_fs_rawgc(lfs2);\n\n    LFS2_TRACE(\"lfs2_fs_gc -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\n#ifndef LFS2_READONLY\nint lfs2_fs_mkconsistent(lfs2_t *lfs2) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_fs_mkconsistent(%p)\", (void*)lfs2);\n\n    err = lfs2_fs_rawmkconsistent(lfs2);\n\n    LFS2_TRACE(\"lfs2_fs_mkconsistent -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\n#ifndef LFS2_READONLY\nint lfs2_fs_grow(lfs2_t *lfs2, lfs2_size_t block_count) {\n    int err = LFS2_LOCK(lfs2->cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_fs_grow(%p, %\"PRIu32\")\", (void*)lfs2, block_count);\n\n    err = lfs2_fs_rawgrow(lfs2, block_count);\n\n    LFS2_TRACE(\"lfs2_fs_grow -> %d\", err);\n    LFS2_UNLOCK(lfs2->cfg);\n    return err;\n}\n#endif\n\n#ifdef LFS2_MIGRATE\nint lfs2_migrate(lfs2_t *lfs2, const struct lfs2_config *cfg) {\n    int err = LFS2_LOCK(cfg);\n    if (err) {\n        return err;\n    }\n    LFS2_TRACE(\"lfs2_migrate(%p, %p {.context=%p, \"\n                \".read=%p, .prog=%p, .erase=%p, .sync=%p, \"\n                \".read_size=%\"PRIu32\", .prog_size=%\"PRIu32\", \"\n                \".block_size=%\"PRIu32\", .block_count=%\"PRIu32\", \"\n                \".block_cycles=%\"PRIu32\", .cache_size=%\"PRIu32\", \"\n                \".lookahead_size=%\"PRIu32\", .read_buffer=%p, \"\n                \".prog_buffer=%p, .lookahead_buffer=%p, \"\n                \".name_max=%\"PRIu32\", .file_max=%\"PRIu32\", \"\n                \".attr_max=%\"PRIu32\"})\",\n            (void*)lfs2, (void*)cfg, cfg->context,\n            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,\n            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,\n            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,\n            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,\n            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,\n            cfg->name_max, cfg->file_max, cfg->attr_max);\n\n    err = lfs2_rawmigrate(lfs2, cfg);\n\n    LFS2_TRACE(\"lfs2_migrate -> %d\", err);\n    LFS2_UNLOCK(cfg);\n    return err;\n}\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}