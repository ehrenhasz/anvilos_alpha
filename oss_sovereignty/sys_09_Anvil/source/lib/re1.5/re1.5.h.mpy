{
  "module_name": "re1.5.h",
  "hash_id": "9fd27b104b32e66cd35e159027e89d5821361814d6ae47a28d9fb15fcc3b7768",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/re1.5/re1.5.h",
  "human_readable_source": "\n\n\n\n\n#ifndef _RE1_5_REGEXP__H\n#define _RE1_5_REGEXP__H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <assert.h>\n\n#define nil ((void*)0)\n#define nelem(x) (sizeof(x)/sizeof((x)[0]))\n\ntypedef struct Regexp Regexp;\ntypedef struct Prog Prog;\ntypedef struct ByteProg ByteProg;\ntypedef struct Inst Inst;\ntypedef struct Subject Subject;\n\nstruct Regexp\n{\n\tint type;\n\tint n;\n\tint ch;\n\tRegexp *left;\n\tRegexp *right;\n};\n\nenum\t \n{\n\tAlt = 1,\n\tCat,\n\tLit,\n\tDot,\n\tParen,\n\tQuest,\n\tStar,\n\tPlus,\n};\n\nRegexp *parse(char*);\nRegexp *reg(int type, Regexp *left, Regexp *right);\nvoid printre(Regexp*);\n#ifndef re1_5_fatal\nvoid re1_5_fatal(char*);\n#endif\n#ifndef re1_5_stack_chk\n#define re1_5_stack_chk()\n#endif\nvoid *mal(int);\n\nstruct Prog\n{\n\tInst *start;\n\tint len;\n};\n\nstruct ByteProg\n{\n\tint bytelen;\n\tint len;\n\tint sub;\n\tchar insts[0];\n};\n\nstruct Inst\n{\n\tint opcode;\n\tint c;\n\tint n;\n\tInst *x;\n\tInst *y;\n\tint gen;\t\n};\n\nenum\t \n{\n\t\n\tCONSUMERS = 1,\n\tChar = CONSUMERS,\n\tAny,\n\tClass,\n\tClassNot,\n\tNamedClass,\n\n\tASSERTS = 0x50,\n\tBol = ASSERTS,\n\tEol,\n\n\t\n\tJUMPS = 0x60,\n\tJmp = JUMPS,\n\tSplit,\n\tRSplit,\n\n\t\n\tSave = 0x7e,\n\tMatch = 0x7f,\n};\n\n#define inst_is_consumer(inst) ((inst) < ASSERTS)\n#define inst_is_jump(inst) ((inst) & 0x70 == JUMPS)\n\nProg *compile(Regexp*);\nvoid printprog(Prog*);\n\nextern int gen;\n\nenum {\n\tMAXSUB = 20\n};\n\ntypedef struct Sub Sub;\n\nstruct Sub\n{\n\tint ref;\n\tint nsub;\n\tconst char *sub[MAXSUB];\n};\n\nSub *newsub(int n);\nSub *incref(Sub*);\nSub *copy(Sub*);\nSub *update(Sub*, int, const char*);\nvoid decref(Sub*);\n\nstruct Subject {\n\tconst char *begin_line;\n\tconst char *begin;\n\tconst char *end;\n};\n\n\n#define NON_ANCHORED_PREFIX 5\n#define HANDLE_ANCHORED(bytecode, is_anchored) ((is_anchored) ? (bytecode) + NON_ANCHORED_PREFIX : (bytecode))\n#define RE15_CLASS_NAMED_CLASS_INDICATOR 0\n\nint re1_5_backtrack(ByteProg*, Subject*, const char**, int, int);\nint re1_5_pikevm(ByteProg*, Subject*, const char**, int, int);\nint re1_5_recursiveloopprog(ByteProg*, Subject*, const char**, int, int);\nint re1_5_recursiveprog(ByteProg*, Subject*, const char**, int, int);\nint re1_5_thompsonvm(ByteProg*, Subject*, const char**, int, int);\n\nint re1_5_sizecode(const char *re);\nint re1_5_compilecode(ByteProg *prog, const char *re);\nvoid re1_5_dumpcode(ByteProg *prog);\nvoid cleanmarks(ByteProg *prog);\nint _re1_5_classmatch(const char *pc, const char *sp);\nint _re1_5_namedclassmatch(const char *pc, const char *sp);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}