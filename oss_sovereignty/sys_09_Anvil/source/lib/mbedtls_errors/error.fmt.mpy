{
  "module_name": "error.fmt",
  "hash_id": "bf628b0d44479121470c87be75dbe237fab36a32171a84acde398e61c06914d5",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/mbedtls_errors/error.fmt",
  "human_readable_source": "/*\n *  Error message information\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_ERROR_C) || defined(MBEDTLS_ERROR_STRERROR_DUMMY)\n#include \"mbedtls/error.h\"\n#include <string.h>\n#endif\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#define mbedtls_snprintf snprintf\n#define mbedtls_time_t   time_t\n#endif\n\n#if defined(MBEDTLS_ERROR_C)\n\n#include <stdio.h>\n\nHEADER_INCLUDED\n\n// Error code table type\nstruct ssl_errs {\n    int16_t errnum;\n    const char *errstr;\n};\n\n// Table of high level error codes\nstatic const struct ssl_errs mbedtls_high_level_error_tab[] = {\n// BEGIN generated code\nHIGH_LEVEL_CODE_CHECKS\n// END generated code\n};\n\nstatic const struct ssl_errs mbedtls_low_level_error_tab[] = {\n// Low level error codes\n//\n// BEGIN generated code\nLOW_LEVEL_CODE_CHECKS\n// END generated code\n};\n\nstatic const char *mbedtls_err_prefix = \"MBEDTLS_ERR_\";\n#define MBEDTLS_ERR_PREFIX_LEN ( sizeof(\"MBEDTLS_ERR_\")-1 )\n\n// copy error text into buffer, ensure null termination, return strlen of result\nstatic size_t mbedtls_err_to_str(int err, const struct ssl_errs tab[], int tab_len, char *buf, size_t buflen) {\n    if (buflen == 0) return 0;\n\n    // prefix for all error names\n    strncpy(buf, mbedtls_err_prefix, buflen);\n    if (buflen <= MBEDTLS_ERR_PREFIX_LEN+1) {\n        buf[buflen-1] = 0;\n        return buflen-1;\n    }\n\n    // append error name from table\n    for (int i = 0; i < tab_len; i++) {\n        if (tab[i].errnum == err) {\n            strncpy(buf+MBEDTLS_ERR_PREFIX_LEN, tab[i].errstr, buflen-MBEDTLS_ERR_PREFIX_LEN);\n            buf[buflen-1] = 0;\n            return strlen(buf);\n        }\n    }\n\n    mbedtls_snprintf(buf+MBEDTLS_ERR_PREFIX_LEN, buflen-MBEDTLS_ERR_PREFIX_LEN, \"UNKNOWN (0x%04X)\",\n            err);\n    return strlen(buf);\n}\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\nvoid mbedtls_strerror(int ret, char *buf, size_t buflen) {\n    int use_ret;\n\n    if (buflen == 0) return;\n\n    buf[buflen-1] = 0;\n\n    if (ret < 0) ret = -ret;\n\n    //\n    // High-level error codes\n    //\n    uint8_t got_hl = (ret & 0xFF80) != 0;\n    if (got_hl) {\n        use_ret = ret & 0xFF80;\n\n        // special case, don't try to translate low level code\n#if defined(MBEDTLS_SSL_TLS_C)\n        if (use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE)) {\n            strncpy(buf, \"MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE\", buflen);\n            buf[buflen-1] = 0;\n            return;\n        }\n#endif\n\n        size_t len = mbedtls_err_to_str(use_ret, mbedtls_high_level_error_tab,\n                ARRAY_SIZE(mbedtls_high_level_error_tab), buf, buflen);\n\n        buf += len;\n        buflen -= len;\n        if (buflen == 0) return;\n    }\n\n    //\n    // Low-level error codes\n    //\n    use_ret = ret & ~0xFF80;\n\n    if (use_ret == 0) return;\n\n    // If high level code is present, make a concatenation between both error strings.\n    if (got_hl) {\n        if (buflen < 2) return;\n        *buf++ = '+';\n        buflen--;\n    }\n\n    mbedtls_err_to_str(use_ret, mbedtls_low_level_error_tab,\n            ARRAY_SIZE(mbedtls_low_level_error_tab), buf, buflen);\n}\n\n#else /* MBEDTLS_ERROR_C */\n\n#if defined(MBEDTLS_ERROR_STRERROR_DUMMY)\n\n/*\n * Provide an non-function in case MBEDTLS_ERROR_C is not defined\n */\nvoid mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    ((void) ret);\n\n    if( buflen > 0 )\n        buf[0] = '\\0';\n}\n\n#endif /* MBEDTLS_ERROR_STRERROR_DUMMY */\n\n#endif /* MBEDTLS_ERROR_C */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}