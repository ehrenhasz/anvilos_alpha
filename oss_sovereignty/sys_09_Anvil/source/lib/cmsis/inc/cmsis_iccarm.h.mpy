{
  "module_name": "cmsis_iccarm.h",
  "hash_id": "62eb55ac3dcfb8eec2a4457f5f4ce592d2ff4bf25d1fd0b6633ddaa61d1a266d",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/cmsis/inc/cmsis_iccarm.h",
  "human_readable_source": " \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifndef __CMSIS_ICCARM_H__\n#define __CMSIS_ICCARM_H__\n\n#ifndef __ICCARM__\n  #error This file should only be compiled by ICCARM\n#endif\n\n#pragma system_include\n\n#define __IAR_FT _Pragma(\"inline=forced\") __intrinsic\n\n#if (__VER__ >= 8000000)\n  #define __ICCARM_V8 1\n#else\n  #define __ICCARM_V8 0\n#endif\n\n#ifndef __ALIGNED\n  #if __ICCARM_V8\n    #define __ALIGNED(x) __attribute__((aligned(x)))\n  #elif (__VER__ >= 7080000)\n     \n    #define __ALIGNED(x) __attribute__((aligned(x)))\n  #else\n    #warning No compiler specific solution for __ALIGNED.__ALIGNED is ignored.\n    #define __ALIGNED(x)\n  #endif\n#endif\n\n\n \n#if __ARM_ARCH_6M__ || __ARM_ARCH_7M__ || __ARM_ARCH_7EM__ || __ARM_ARCH_8M_BASE__ || __ARM_ARCH_8M_MAIN__\n \n#else\n  #if defined(__ARM8M_MAINLINE__) || defined(__ARM8EM_MAINLINE__)\n    #define __ARM_ARCH_8M_MAIN__ 1\n  #elif defined(__ARM8M_BASELINE__)\n    #define __ARM_ARCH_8M_BASE__ 1\n  #elif defined(__ARM_ARCH_PROFILE) && __ARM_ARCH_PROFILE == 'M'\n    #if __ARM_ARCH == 6\n      #define __ARM_ARCH_6M__ 1\n    #elif __ARM_ARCH == 7\n      #if __ARM_FEATURE_DSP\n        #define __ARM_ARCH_7EM__ 1\n      #else\n        #define __ARM_ARCH_7M__ 1\n      #endif\n    #endif  \n  #endif  \n#endif\n\n \n#if !defined(__ARM_ARCH_6M__) && !defined(__ARM_ARCH_7M__) && !defined(__ARM_ARCH_7EM__) && \\\n    !defined(__ARM_ARCH_8M_BASE__) && !defined(__ARM_ARCH_8M_MAIN__)\n  #if defined(__ARM6M__) && (__CORE__ == __ARM6M__)\n    #define __ARM_ARCH_6M__ 1\n  #elif defined(__ARM7M__) && (__CORE__ == __ARM7M__)\n    #define __ARM_ARCH_7M__ 1\n  #elif defined(__ARM7EM__) && (__CORE__ == __ARM7EM__)\n    #define __ARM_ARCH_7EM__  1\n  #elif defined(__ARM8M_BASELINE__) && (__CORE == __ARM8M_BASELINE__)\n    #define __ARM_ARCH_8M_BASE__ 1\n  #elif defined(__ARM8M_MAINLINE__) && (__CORE == __ARM8M_MAINLINE__)\n    #define __ARM_ARCH_8M_MAIN__ 1\n  #elif defined(__ARM8EM_MAINLINE__) && (__CORE == __ARM8EM_MAINLINE__)\n    #define __ARM_ARCH_8M_MAIN__ 1\n  #else\n    #error \"Unknown target.\"\n  #endif\n#endif\n\n\n\n#if defined(__ARM_ARCH_6M__) && __ARM_ARCH_6M__==1\n  #define __IAR_M0_FAMILY  1\n#elif defined(__ARM_ARCH_8M_BASE__) && __ARM_ARCH_8M_BASE__==1\n  #define __IAR_M0_FAMILY  1\n#else\n  #define __IAR_M0_FAMILY  0\n#endif\n\n\n#ifndef __ASM\n  #define __ASM __asm\n#endif\n\n#ifndef   __COMPILER_BARRIER\n  #define __COMPILER_BARRIER() __ASM volatile(\"\":::\"memory\")\n#endif\n\n#ifndef __INLINE\n  #define __INLINE inline\n#endif\n\n#ifndef   __NO_RETURN\n  #if __ICCARM_V8\n    #define __NO_RETURN __attribute__((__noreturn__))\n  #else\n    #define __NO_RETURN _Pragma(\"object_attribute=__noreturn\")\n  #endif\n#endif\n\n#ifndef   __PACKED\n  #if __ICCARM_V8\n    #define __PACKED __attribute__((packed, aligned(1)))\n  #else\n     \n    #define __PACKED __packed\n  #endif\n#endif\n\n#ifndef   __PACKED_STRUCT\n  #if __ICCARM_V8\n    #define __PACKED_STRUCT struct __attribute__((packed, aligned(1)))\n  #else\n     \n    #define __PACKED_STRUCT __packed struct\n  #endif\n#endif\n\n#ifndef   __PACKED_UNION\n  #if __ICCARM_V8\n    #define __PACKED_UNION union __attribute__((packed, aligned(1)))\n  #else\n     \n    #define __PACKED_UNION __packed union\n  #endif\n#endif\n\n#ifndef   __RESTRICT\n  #if __ICCARM_V8\n    #define __RESTRICT            __restrict\n  #else\n     \n    #define __RESTRICT            restrict\n  #endif\n#endif\n\n#ifndef   __STATIC_INLINE\n  #define __STATIC_INLINE       static inline\n#endif\n\n#ifndef   __FORCEINLINE\n  #define __FORCEINLINE         _Pragma(\"inline=forced\")\n#endif\n\n#ifndef   __STATIC_FORCEINLINE\n  #define __STATIC_FORCEINLINE  __FORCEINLINE __STATIC_INLINE\n#endif\n\n#ifndef __UNALIGNED_UINT16_READ\n#pragma language=save\n#pragma language=extended\n__IAR_FT uint16_t __iar_uint16_read(void const *ptr)\n{\n  return *(__packed uint16_t*)(ptr);\n}\n#pragma language=restore\n#define __UNALIGNED_UINT16_READ(PTR) __iar_uint16_read(PTR)\n#endif\n\n\n#ifndef __UNALIGNED_UINT16_WRITE\n#pragma language=save\n#pragma language=extended\n__IAR_FT void __iar_uint16_write(void const *ptr, uint16_t val)\n{\n  *(__packed uint16_t*)(ptr) = val;;\n}\n#pragma language=restore\n#define __UNALIGNED_UINT16_WRITE(PTR,VAL) __iar_uint16_write(PTR,VAL)\n#endif\n\n#ifndef __UNALIGNED_UINT32_READ\n#pragma language=save\n#pragma language=extended\n__IAR_FT uint32_t __iar_uint32_read(void const *ptr)\n{\n  return *(__packed uint32_t*)(ptr);\n}\n#pragma language=restore\n#define __UNALIGNED_UINT32_READ(PTR) __iar_uint32_read(PTR)\n#endif\n\n#ifndef __UNALIGNED_UINT32_WRITE\n#pragma language=save\n#pragma language=extended\n__IAR_FT void __iar_uint32_write(void const *ptr, uint32_t val)\n{\n  *(__packed uint32_t*)(ptr) = val;;\n}\n#pragma language=restore\n#define __UNALIGNED_UINT32_WRITE(PTR,VAL) __iar_uint32_write(PTR,VAL)\n#endif\n\n#ifndef __UNALIGNED_UINT32    \n#pragma language=save\n#pragma language=extended\n__packed struct  __iar_u32 { uint32_t v; };\n#pragma language=restore\n#define __UNALIGNED_UINT32(PTR) (((struct __iar_u32 *)(PTR))->v)\n#endif\n\n#ifndef   __USED\n  #if __ICCARM_V8\n    #define __USED __attribute__((used))\n  #else\n    #define __USED _Pragma(\"__root\")\n  #endif\n#endif\n\n#undef __WEAK                            \n#ifndef   __WEAK\n  #if __ICCARM_V8\n    #define __WEAK __attribute__((weak))\n  #else\n    #define __WEAK _Pragma(\"__weak\")\n  #endif\n#endif\n\n#ifndef __PROGRAM_START\n#define __PROGRAM_START           __iar_program_start\n#endif\n\n#ifndef __INITIAL_SP\n#define __INITIAL_SP              CSTACK$$Limit\n#endif\n\n#ifndef __STACK_LIMIT\n#define __STACK_LIMIT             CSTACK$$Base\n#endif\n\n#ifndef __VECTOR_TABLE\n#define __VECTOR_TABLE            __vector_table\n#endif\n\n#ifndef __VECTOR_TABLE_ATTRIBUTE\n#define __VECTOR_TABLE_ATTRIBUTE  @\".intvec\"\n#endif\n\n#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)\n#ifndef __STACK_SEAL\n#define __STACK_SEAL              STACKSEAL$$Base\n#endif\n\n#ifndef __TZ_STACK_SEAL_SIZE\n#define __TZ_STACK_SEAL_SIZE      8U\n#endif\n\n#ifndef __TZ_STACK_SEAL_VALUE\n#define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL\n#endif\n\n__STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {\n  *((uint64_t *)stackTop) = __TZ_STACK_SEAL_VALUE;\n}\n#endif\n\n#ifndef __ICCARM_INTRINSICS_VERSION__\n  #define __ICCARM_INTRINSICS_VERSION__  0\n#endif\n\n#if __ICCARM_INTRINSICS_VERSION__ == 2\n\n  #if defined(__CLZ)\n    #undef __CLZ\n  #endif\n  #if defined(__REVSH)\n    #undef __REVSH\n  #endif\n  #if defined(__RBIT)\n    #undef __RBIT\n  #endif\n  #if defined(__SSAT)\n    #undef __SSAT\n  #endif\n  #if defined(__USAT)\n    #undef __USAT\n  #endif\n\n  #include \"iccarm_builtin.h\"\n\n  #define __disable_fault_irq __iar_builtin_disable_fiq\n  #define __disable_irq       __iar_builtin_disable_interrupt\n  #define __enable_fault_irq  __iar_builtin_enable_fiq\n  #define __enable_irq        __iar_builtin_enable_interrupt\n  #define __arm_rsr           __iar_builtin_rsr\n  #define __arm_wsr           __iar_builtin_wsr\n\n\n  #define __get_APSR()                (__arm_rsr(\"APSR\"))\n  #define __get_BASEPRI()             (__arm_rsr(\"BASEPRI\"))\n  #define __get_CONTROL()             (__arm_rsr(\"CONTROL\"))\n  #define __get_FAULTMASK()           (__arm_rsr(\"FAULTMASK\"))\n\n  #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\\n       (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )\n    #define __get_FPSCR()             (__arm_rsr(\"FPSCR\"))\n    #define __set_FPSCR(VALUE)        (__arm_wsr(\"FPSCR\", (VALUE)))\n  #else\n    #define __get_FPSCR()             ( 0 )\n    #define __set_FPSCR(VALUE)        ((void)VALUE)\n  #endif\n\n  #define __get_IPSR()                (__arm_rsr(\"IPSR\"))\n  #define __get_MSP()                 (__arm_rsr(\"MSP\"))\n  #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n       (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))\n    \n    #define __get_MSPLIM()            (0U)\n  #else\n    #define __get_MSPLIM()            (__arm_rsr(\"MSPLIM\"))\n  #endif\n  #define __get_PRIMASK()             (__arm_rsr(\"PRIMASK\"))\n  #define __get_PSP()                 (__arm_rsr(\"PSP\"))\n\n  #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n       (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))\n    \n    #define __get_PSPLIM()            (0U)\n  #else\n    #define __get_PSPLIM()            (__arm_rsr(\"PSPLIM\"))\n  #endif\n\n  #define __get_xPSR()                (__arm_rsr(\"xPSR\"))\n\n  #define __set_BASEPRI(VALUE)        (__arm_wsr(\"BASEPRI\", (VALUE)))\n  #define __set_BASEPRI_MAX(VALUE)    (__arm_wsr(\"BASEPRI_MAX\", (VALUE)))\n\n__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)\n{\n  __arm_wsr(\"CONTROL\", control);\n  __iar_builtin_ISB();\n}\n\n  #define __set_FAULTMASK(VALUE)      (__arm_wsr(\"FAULTMASK\", (VALUE)))\n  #define __set_MSP(VALUE)            (__arm_wsr(\"MSP\", (VALUE)))\n\n  #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n       (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))\n    \n    #define __set_MSPLIM(VALUE)       ((void)(VALUE))\n  #else\n    #define __set_MSPLIM(VALUE)       (__arm_wsr(\"MSPLIM\", (VALUE)))\n  #endif\n  #define __set_PRIMASK(VALUE)        (__arm_wsr(\"PRIMASK\", (VALUE)))\n  #define __set_PSP(VALUE)            (__arm_wsr(\"PSP\", (VALUE)))\n  #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n       (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))\n    \n    #define __set_PSPLIM(VALUE)       ((void)(VALUE))\n  #else\n    #define __set_PSPLIM(VALUE)       (__arm_wsr(\"PSPLIM\", (VALUE)))\n  #endif\n\n  #define __TZ_get_CONTROL_NS()       (__arm_rsr(\"CONTROL_NS\"))\n\n__STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)\n{\n  __arm_wsr(\"CONTROL_NS\", control);\n  __iar_builtin_ISB();\n}\n\n  #define __TZ_get_PSP_NS()           (__arm_rsr(\"PSP_NS\"))\n  #define __TZ_set_PSP_NS(VALUE)      (__arm_wsr(\"PSP_NS\", (VALUE)))\n  #define __TZ_get_MSP_NS()           (__arm_rsr(\"MSP_NS\"))\n  #define __TZ_set_MSP_NS(VALUE)      (__arm_wsr(\"MSP_NS\", (VALUE)))\n  #define __TZ_get_SP_NS()            (__arm_rsr(\"SP_NS\"))\n  #define __TZ_set_SP_NS(VALUE)       (__arm_wsr(\"SP_NS\", (VALUE)))\n  #define __TZ_get_PRIMASK_NS()       (__arm_rsr(\"PRIMASK_NS\"))\n  #define __TZ_set_PRIMASK_NS(VALUE)  (__arm_wsr(\"PRIMASK_NS\", (VALUE)))\n  #define __TZ_get_BASEPRI_NS()       (__arm_rsr(\"BASEPRI_NS\"))\n  #define __TZ_set_BASEPRI_NS(VALUE)  (__arm_wsr(\"BASEPRI_NS\", (VALUE)))\n  #define __TZ_get_FAULTMASK_NS()     (__arm_rsr(\"FAULTMASK_NS\"))\n  #define __TZ_set_FAULTMASK_NS(VALUE)(__arm_wsr(\"FAULTMASK_NS\", (VALUE)))\n\n  #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n       (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))\n    \n    #define __TZ_get_PSPLIM_NS()      (0U)\n    #define __TZ_set_PSPLIM_NS(VALUE) ((void)(VALUE))\n  #else\n    #define __TZ_get_PSPLIM_NS()      (__arm_rsr(\"PSPLIM_NS\"))\n    #define __TZ_set_PSPLIM_NS(VALUE) (__arm_wsr(\"PSPLIM_NS\", (VALUE)))\n  #endif\n\n  #define __TZ_get_MSPLIM_NS()        (__arm_rsr(\"MSPLIM_NS\"))\n  #define __TZ_set_MSPLIM_NS(VALUE)   (__arm_wsr(\"MSPLIM_NS\", (VALUE)))\n\n  #define __NOP     __iar_builtin_no_operation\n\n  #define __CLZ     __iar_builtin_CLZ\n  #define __CLREX   __iar_builtin_CLREX\n\n  #define __DMB     __iar_builtin_DMB\n  #define __DSB     __iar_builtin_DSB\n  #define __ISB     __iar_builtin_ISB\n\n  #define __LDREXB  __iar_builtin_LDREXB\n  #define __LDREXH  __iar_builtin_LDREXH\n  #define __LDREXW  __iar_builtin_LDREX\n\n  #define __RBIT    __iar_builtin_RBIT\n  #define __REV     __iar_builtin_REV\n  #define __REV16   __iar_builtin_REV16\n\n  __IAR_FT int16_t __REVSH(int16_t val)\n  {\n    return (int16_t) __iar_builtin_REVSH(val);\n  }\n\n  #define __ROR     __iar_builtin_ROR\n  #define __RRX     __iar_builtin_RRX\n\n  #define __SEV     __iar_builtin_SEV\n\n  #if !__IAR_M0_FAMILY\n    #define __SSAT    __iar_builtin_SSAT\n  #endif\n\n  #define __STREXB  __iar_builtin_STREXB\n  #define __STREXH  __iar_builtin_STREXH\n  #define __STREXW  __iar_builtin_STREX\n\n  #if !__IAR_M0_FAMILY\n    #define __USAT    __iar_builtin_USAT\n  #endif\n\n  #define __WFE     __iar_builtin_WFE\n  #define __WFI     __iar_builtin_WFI\n\n  #if __ARM_MEDIA__\n    #define __SADD8   __iar_builtin_SADD8\n    #define __QADD8   __iar_builtin_QADD8\n    #define __SHADD8  __iar_builtin_SHADD8\n    #define __UADD8   __iar_builtin_UADD8\n    #define __UQADD8  __iar_builtin_UQADD8\n    #define __UHADD8  __iar_builtin_UHADD8\n    #define __SSUB8   __iar_builtin_SSUB8\n    #define __QSUB8   __iar_builtin_QSUB8\n    #define __SHSUB8  __iar_builtin_SHSUB8\n    #define __USUB8   __iar_builtin_USUB8\n    #define __UQSUB8  __iar_builtin_UQSUB8\n    #define __UHSUB8  __iar_builtin_UHSUB8\n    #define __SADD16  __iar_builtin_SADD16\n    #define __QADD16  __iar_builtin_QADD16\n    #define __SHADD16 __iar_builtin_SHADD16\n    #define __UADD16  __iar_builtin_UADD16\n    #define __UQADD16 __iar_builtin_UQADD16\n    #define __UHADD16 __iar_builtin_UHADD16\n    #define __SSUB16  __iar_builtin_SSUB16\n    #define __QSUB16  __iar_builtin_QSUB16\n    #define __SHSUB16 __iar_builtin_SHSUB16\n    #define __USUB16  __iar_builtin_USUB16\n    #define __UQSUB16 __iar_builtin_UQSUB16\n    #define __UHSUB16 __iar_builtin_UHSUB16\n    #define __SASX    __iar_builtin_SASX\n    #define __QASX    __iar_builtin_QASX\n    #define __SHASX   __iar_builtin_SHASX\n    #define __UASX    __iar_builtin_UASX\n    #define __UQASX   __iar_builtin_UQASX\n    #define __UHASX   __iar_builtin_UHASX\n    #define __SSAX    __iar_builtin_SSAX\n    #define __QSAX    __iar_builtin_QSAX\n    #define __SHSAX   __iar_builtin_SHSAX\n    #define __USAX    __iar_builtin_USAX\n    #define __UQSAX   __iar_builtin_UQSAX\n    #define __UHSAX   __iar_builtin_UHSAX\n    #define __USAD8   __iar_builtin_USAD8\n    #define __USADA8  __iar_builtin_USADA8\n    #define __SSAT16  __iar_builtin_SSAT16\n    #define __USAT16  __iar_builtin_USAT16\n    #define __UXTB16  __iar_builtin_UXTB16\n    #define __UXTAB16 __iar_builtin_UXTAB16\n    #define __SXTB16  __iar_builtin_SXTB16\n    #define __SXTAB16 __iar_builtin_SXTAB16\n    #define __SMUAD   __iar_builtin_SMUAD\n    #define __SMUADX  __iar_builtin_SMUADX\n    #define __SMMLA   __iar_builtin_SMMLA\n    #define __SMLAD   __iar_builtin_SMLAD\n    #define __SMLADX  __iar_builtin_SMLADX\n    #define __SMLALD  __iar_builtin_SMLALD\n    #define __SMLALDX __iar_builtin_SMLALDX\n    #define __SMUSD   __iar_builtin_SMUSD\n    #define __SMUSDX  __iar_builtin_SMUSDX\n    #define __SMLSD   __iar_builtin_SMLSD\n    #define __SMLSDX  __iar_builtin_SMLSDX\n    #define __SMLSLD  __iar_builtin_SMLSLD\n    #define __SMLSLDX __iar_builtin_SMLSLDX\n    #define __SEL     __iar_builtin_SEL\n    #define __QADD    __iar_builtin_QADD\n    #define __QSUB    __iar_builtin_QSUB\n    #define __PKHBT   __iar_builtin_PKHBT\n    #define __PKHTB   __iar_builtin_PKHTB\n  #endif\n\n#else  \n\n  #if __IAR_M0_FAMILY\n    \n    #define __CLZ  __cmsis_iar_clz_not_active\n    #define __SSAT __cmsis_iar_ssat_not_active\n    #define __USAT __cmsis_iar_usat_not_active\n    #define __RBIT __cmsis_iar_rbit_not_active\n    #define __get_APSR  __cmsis_iar_get_APSR_not_active\n  #endif\n\n\n  #if (!((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\\n         (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     ))\n    #define __get_FPSCR __cmsis_iar_get_FPSR_not_active\n    #define __set_FPSCR __cmsis_iar_set_FPSR_not_active\n  #endif\n\n  #ifdef __INTRINSICS_INCLUDED\n  #error intrinsics.h is already included previously!\n  #endif\n\n  #include <intrinsics.h>\n\n  #if __IAR_M0_FAMILY\n    \n    #undef __CLZ\n    #undef __SSAT\n    #undef __USAT\n    #undef __RBIT\n    #undef __get_APSR\n\n    __STATIC_INLINE uint8_t __CLZ(uint32_t data)\n    {\n      if (data == 0U) { return 32U; }\n\n      uint32_t count = 0U;\n      uint32_t mask = 0x80000000U;\n\n      while ((data & mask) == 0U)\n      {\n        count += 1U;\n        mask = mask >> 1U;\n      }\n      return count;\n    }\n\n    __STATIC_INLINE uint32_t __RBIT(uint32_t v)\n    {\n      uint8_t sc = 31U;\n      uint32_t r = v;\n      for (v >>= 1U; v; v >>= 1U)\n      {\n        r <<= 1U;\n        r |= v & 1U;\n        sc--;\n      }\n      return (r << sc);\n    }\n\n    __STATIC_INLINE  uint32_t __get_APSR(void)\n    {\n      uint32_t res;\n      __asm(\"MRS      %0,APSR\" : \"=r\" (res));\n      return res;\n    }\n\n  #endif\n\n  #if (!((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \\\n         (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     ))\n    #undef __get_FPSCR\n    #undef __set_FPSCR\n    #define __get_FPSCR()       (0)\n    #define __set_FPSCR(VALUE)  ((void)VALUE)\n  #endif\n\n  #pragma diag_suppress=Pe940\n  #pragma diag_suppress=Pe177\n\n  #define __enable_irq    __enable_interrupt\n  #define __disable_irq   __disable_interrupt\n  #define __NOP           __no_operation\n\n  #define __get_xPSR      __get_PSR\n\n  #if (!defined(__ARM_ARCH_6M__) || __ARM_ARCH_6M__==0)\n\n    __IAR_FT uint32_t __LDREXW(uint32_t volatile *ptr)\n    {\n      return __LDREX((unsigned long *)ptr);\n    }\n\n    __IAR_FT uint32_t __STREXW(uint32_t value, uint32_t volatile *ptr)\n    {\n      return __STREX(value, (unsigned long *)ptr);\n    }\n  #endif\n\n\n   \n  #if (__CORTEX_M >= 0x03)\n\n    __IAR_FT uint32_t __RRX(uint32_t value)\n    {\n      uint32_t result;\n      __ASM volatile(\"RRX      %0, %1\" : \"=r\"(result) : \"r\" (value));\n      return(result);\n    }\n\n    __IAR_FT void __set_BASEPRI_MAX(uint32_t value)\n    {\n      __asm volatile(\"MSR      BASEPRI_MAX,%0\"::\"r\" (value));\n    }\n\n\n    #define __enable_fault_irq  __enable_fiq\n    #define __disable_fault_irq __disable_fiq\n\n\n  #endif  \n\n  __IAR_FT uint32_t __ROR(uint32_t op1, uint32_t op2)\n  {\n    return (op1 >> op2) | (op1 << ((sizeof(op1)*8)-op2));\n  }\n\n  #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\\n       (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )\n\n   __IAR_FT uint32_t __get_MSPLIM(void)\n    {\n      uint32_t res;\n    #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n         (!defined (__ARM_FEATURE_CMSE  ) || (__ARM_FEATURE_CMSE   < 3)))\n      \n      res = 0U;\n    #else\n      __asm volatile(\"MRS      %0,MSPLIM\" : \"=r\" (res));\n    #endif\n      return res;\n    }\n\n    __IAR_FT void   __set_MSPLIM(uint32_t value)\n    {\n    #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n         (!defined (__ARM_FEATURE_CMSE  ) || (__ARM_FEATURE_CMSE   < 3)))\n      \n      (void)value;\n    #else\n      __asm volatile(\"MSR      MSPLIM,%0\" :: \"r\" (value));\n    #endif\n    }\n\n    __IAR_FT uint32_t __get_PSPLIM(void)\n    {\n      uint32_t res;\n    #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n         (!defined (__ARM_FEATURE_CMSE  ) || (__ARM_FEATURE_CMSE   < 3)))\n      \n      res = 0U;\n    #else\n      __asm volatile(\"MRS      %0,PSPLIM\" : \"=r\" (res));\n    #endif\n      return res;\n    }\n\n    __IAR_FT void   __set_PSPLIM(uint32_t value)\n    {\n    #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n         (!defined (__ARM_FEATURE_CMSE  ) || (__ARM_FEATURE_CMSE   < 3)))\n      \n      (void)value;\n    #else\n      __asm volatile(\"MSR      PSPLIM,%0\" :: \"r\" (value));\n    #endif\n    }\n\n    __IAR_FT uint32_t __TZ_get_CONTROL_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,CONTROL_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_CONTROL_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      CONTROL_NS,%0\" :: \"r\" (value));\n      __iar_builtin_ISB();\n    }\n\n    __IAR_FT uint32_t   __TZ_get_PSP_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,PSP_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_PSP_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      PSP_NS,%0\" :: \"r\" (value));\n    }\n\n    __IAR_FT uint32_t   __TZ_get_MSP_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,MSP_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_MSP_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      MSP_NS,%0\" :: \"r\" (value));\n    }\n\n    __IAR_FT uint32_t   __TZ_get_SP_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,SP_NS\" : \"=r\" (res));\n      return res;\n    }\n    __IAR_FT void   __TZ_set_SP_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      SP_NS,%0\" :: \"r\" (value));\n    }\n\n    __IAR_FT uint32_t   __TZ_get_PRIMASK_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,PRIMASK_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_PRIMASK_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      PRIMASK_NS,%0\" :: \"r\" (value));\n    }\n\n    __IAR_FT uint32_t   __TZ_get_BASEPRI_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,BASEPRI_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_BASEPRI_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      BASEPRI_NS,%0\" :: \"r\" (value));\n    }\n\n    __IAR_FT uint32_t   __TZ_get_FAULTMASK_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,FAULTMASK_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_FAULTMASK_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      FAULTMASK_NS,%0\" :: \"r\" (value));\n    }\n\n    __IAR_FT uint32_t   __TZ_get_PSPLIM_NS(void)\n    {\n      uint32_t res;\n    #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n         (!defined (__ARM_FEATURE_CMSE  ) || (__ARM_FEATURE_CMSE   < 3)))\n      \n      res = 0U;\n    #else\n      __asm volatile(\"MRS      %0,PSPLIM_NS\" : \"=r\" (res));\n    #endif\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_PSPLIM_NS(uint32_t value)\n    {\n    #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \\\n         (!defined (__ARM_FEATURE_CMSE  ) || (__ARM_FEATURE_CMSE   < 3)))\n      \n      (void)value;\n    #else\n      __asm volatile(\"MSR      PSPLIM_NS,%0\" :: \"r\" (value));\n    #endif\n    }\n\n    __IAR_FT uint32_t   __TZ_get_MSPLIM_NS(void)\n    {\n      uint32_t res;\n      __asm volatile(\"MRS      %0,MSPLIM_NS\" : \"=r\" (res));\n      return res;\n    }\n\n    __IAR_FT void   __TZ_set_MSPLIM_NS(uint32_t value)\n    {\n      __asm volatile(\"MSR      MSPLIM_NS,%0\" :: \"r\" (value));\n    }\n\n  #endif  \n\n#endif    \n\n#define __BKPT(value)    __asm volatile (\"BKPT     %0\" : : \"i\"(value))\n\n#if __IAR_M0_FAMILY\n  __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)\n  {\n    if ((sat >= 1U) && (sat <= 32U))\n    {\n      const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);\n      const int32_t min = -1 - max ;\n      if (val > max)\n      {\n        return max;\n      }\n      else if (val < min)\n      {\n        return min;\n      }\n    }\n    return val;\n  }\n\n  __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)\n  {\n    if (sat <= 31U)\n    {\n      const uint32_t max = ((1U << sat) - 1U);\n      if (val > (int32_t)max)\n      {\n        return max;\n      }\n      else if (val < 0)\n      {\n        return 0U;\n      }\n    }\n    return (uint32_t)val;\n  }\n#endif\n\n#if (__CORTEX_M >= 0x03)    \n\n  __IAR_FT uint8_t __LDRBT(volatile uint8_t *addr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDRBT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");\n    return ((uint8_t)res);\n  }\n\n  __IAR_FT uint16_t __LDRHT(volatile uint16_t *addr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDRHT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");\n    return ((uint16_t)res);\n  }\n\n  __IAR_FT uint32_t __LDRT(volatile uint32_t *addr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDRT %0, [%1]\" : \"=r\" (res) : \"r\" (addr) : \"memory\");\n    return res;\n  }\n\n  __IAR_FT void __STRBT(uint8_t value, volatile uint8_t *addr)\n  {\n    __ASM volatile (\"STRBT %1, [%0]\" : : \"r\" (addr), \"r\" ((uint32_t)value) : \"memory\");\n  }\n\n  __IAR_FT void __STRHT(uint16_t value, volatile uint16_t *addr)\n  {\n    __ASM volatile (\"STRHT %1, [%0]\" : : \"r\" (addr), \"r\" ((uint32_t)value) : \"memory\");\n  }\n\n  __IAR_FT void __STRT(uint32_t value, volatile uint32_t *addr)\n  {\n    __ASM volatile (\"STRT %1, [%0]\" : : \"r\" (addr), \"r\" (value) : \"memory\");\n  }\n\n#endif  \n\n#if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \\\n     (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )\n\n\n  __IAR_FT uint8_t __LDAB(volatile uint8_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDAB %0, [%1]\" : \"=r\" (res) : \"r\" (ptr) : \"memory\");\n    return ((uint8_t)res);\n  }\n\n  __IAR_FT uint16_t __LDAH(volatile uint16_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDAH %0, [%1]\" : \"=r\" (res) : \"r\" (ptr) : \"memory\");\n    return ((uint16_t)res);\n  }\n\n  __IAR_FT uint32_t __LDA(volatile uint32_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDA %0, [%1]\" : \"=r\" (res) : \"r\" (ptr) : \"memory\");\n    return res;\n  }\n\n  __IAR_FT void __STLB(uint8_t value, volatile uint8_t *ptr)\n  {\n    __ASM volatile (\"STLB %1, [%0]\" :: \"r\" (ptr), \"r\" (value) : \"memory\");\n  }\n\n  __IAR_FT void __STLH(uint16_t value, volatile uint16_t *ptr)\n  {\n    __ASM volatile (\"STLH %1, [%0]\" :: \"r\" (ptr), \"r\" (value) : \"memory\");\n  }\n\n  __IAR_FT void __STL(uint32_t value, volatile uint32_t *ptr)\n  {\n    __ASM volatile (\"STL %1, [%0]\" :: \"r\" (ptr), \"r\" (value) : \"memory\");\n  }\n\n  __IAR_FT uint8_t __LDAEXB(volatile uint8_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDAEXB %0, [%1]\" : \"=r\" (res) : \"r\" (ptr) : \"memory\");\n    return ((uint8_t)res);\n  }\n\n  __IAR_FT uint16_t __LDAEXH(volatile uint16_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDAEXH %0, [%1]\" : \"=r\" (res) : \"r\" (ptr) : \"memory\");\n    return ((uint16_t)res);\n  }\n\n  __IAR_FT uint32_t __LDAEX(volatile uint32_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"LDAEX %0, [%1]\" : \"=r\" (res) : \"r\" (ptr) : \"memory\");\n    return res;\n  }\n\n  __IAR_FT uint32_t __STLEXB(uint8_t value, volatile uint8_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"STLEXB %0, %2, [%1]\" : \"=r\" (res) : \"r\" (ptr), \"r\" (value) : \"memory\");\n    return res;\n  }\n\n  __IAR_FT uint32_t __STLEXH(uint16_t value, volatile uint16_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"STLEXH %0, %2, [%1]\" : \"=r\" (res) : \"r\" (ptr), \"r\" (value) : \"memory\");\n    return res;\n  }\n\n  __IAR_FT uint32_t __STLEX(uint32_t value, volatile uint32_t *ptr)\n  {\n    uint32_t res;\n    __ASM volatile (\"STLEX %0, %2, [%1]\" : \"=r\" (res) : \"r\" (ptr), \"r\" (value) : \"memory\");\n    return res;\n  }\n\n#endif  \n\n#undef __IAR_FT\n#undef __IAR_M0_FAMILY\n#undef __ICCARM_V8\n\n#pragma diag_default=Pe940\n#pragma diag_default=Pe177\n\n#define __SXTB16_RORn(ARG1, ARG2) __SXTB16(__ROR(ARG1, ARG2))\n\n#define __SXTAB16_RORn(ARG1, ARG2, ARG3) __SXTAB16(ARG1, __ROR(ARG2, ARG3))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}