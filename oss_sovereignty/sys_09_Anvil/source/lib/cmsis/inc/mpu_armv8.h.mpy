{
  "module_name": "mpu_armv8.h",
  "hash_id": "17c4065d8eb6ff0889e2b9133f80863a918039156c35b6888e7fb1b767882d27",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/cmsis/inc/mpu_armv8.h",
  "human_readable_source": " \n \n\n#if   defined ( __ICCARM__ )\n  #pragma system_include          \n#elif defined (__clang__)\n  #pragma clang system_header     \n#endif\n\n#ifndef ARM_MPU_ARMV8_H\n#define ARM_MPU_ARMV8_H\n\n \n#define ARM_MPU_ATTR_DEVICE                           ( 0U )\n\n \n#define ARM_MPU_ATTR_NON_CACHEABLE                    ( 4U )\n\n \n#define ARM_MPU_ATTR_MEMORY_(NT, WB, RA, WA) \\\n  ((((NT) & 1U) << 3U) | (((WB) & 1U) << 2U) | (((RA) & 1U) << 1U) | ((WA) & 1U))\n\n \n#define ARM_MPU_ATTR_DEVICE_nGnRnE (0U)\n\n \n#define ARM_MPU_ATTR_DEVICE_nGnRE  (1U)\n\n \n#define ARM_MPU_ATTR_DEVICE_nGRE   (2U)\n\n \n#define ARM_MPU_ATTR_DEVICE_GRE    (3U)\n\n \n#define ARM_MPU_ATTR(O, I) ((((O) & 0xFU) << 4U) | ((((O) & 0xFU) != 0U) ? ((I) & 0xFU) : (((I) & 0x3U) << 2U)))\n\n \n#define ARM_MPU_SH_NON   (0U)\n\n \n#define ARM_MPU_SH_OUTER (2U)\n\n \n#define ARM_MPU_SH_INNER (3U)\n\n \n#define ARM_MPU_AP_(RO, NP) ((((RO) & 1U) << 1U) | ((NP) & 1U))\n\n \n#define ARM_MPU_RBAR(BASE, SH, RO, NP, XN) \\\n  (((BASE) & MPU_RBAR_BASE_Msk) | \\\n  (((SH) << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk) | \\\n  ((ARM_MPU_AP_(RO, NP) << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk) | \\\n  (((XN) << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk))\n\n \n#define ARM_MPU_RLAR(LIMIT, IDX) \\\n  (((LIMIT) & MPU_RLAR_LIMIT_Msk) | \\\n  (((IDX) << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \\\n  (MPU_RLAR_EN_Msk))\n\n#if defined(MPU_RLAR_PXN_Pos)\n  \n \n#define ARM_MPU_RLAR_PXN(LIMIT, PXN, IDX) \\\n  (((LIMIT) & MPU_RLAR_LIMIT_Msk) | \\\n  (((PXN) << MPU_RLAR_PXN_Pos) & MPU_RLAR_PXN_Msk) | \\\n  (((IDX) << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \\\n  (MPU_RLAR_EN_Msk))\n  \n#endif\n\n \ntypedef struct {\n  uint32_t RBAR;                    \n  uint32_t RLAR;                    \n} ARM_MPU_Region_t;\n    \n \n__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)\n{\n  __DMB();\n  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\n#ifdef SCB_SHCSR_MEMFAULTENA_Msk\n  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\n#endif\n  __DSB();\n  __ISB();\n}\n\n \n__STATIC_INLINE void ARM_MPU_Disable(void)\n{\n  __DMB();\n#ifdef SCB_SHCSR_MEMFAULTENA_Msk\n  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\n#endif\n  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;\n  __DSB();\n  __ISB();\n}\n\n#ifdef MPU_NS\n \n__STATIC_INLINE void ARM_MPU_Enable_NS(uint32_t MPU_Control)\n{\n  __DMB();\n  MPU_NS->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;\n#ifdef SCB_SHCSR_MEMFAULTENA_Msk\n  SCB_NS->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;\n#endif\n  __DSB();\n  __ISB();\n}\n\n \n__STATIC_INLINE void ARM_MPU_Disable_NS(void)\n{\n  __DMB();\n#ifdef SCB_SHCSR_MEMFAULTENA_Msk\n  SCB_NS->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;\n#endif\n  MPU_NS->CTRL  &= ~MPU_CTRL_ENABLE_Msk;\n  __DSB();\n  __ISB();\n}\n#endif\n\n \n__STATIC_INLINE void ARM_MPU_SetMemAttrEx(MPU_Type* mpu, uint8_t idx, uint8_t attr)\n{\n  const uint8_t reg = idx / 4U;\n  const uint32_t pos = ((idx % 4U) * 8U);\n  const uint32_t mask = 0xFFU << pos;\n  \n  if (reg >= (sizeof(mpu->MAIR) / sizeof(mpu->MAIR[0]))) {\n    return; \n  }\n  \n  mpu->MAIR[reg] = ((mpu->MAIR[reg] & ~mask) | ((attr << pos) & mask));\n}\n\n \n__STATIC_INLINE void ARM_MPU_SetMemAttr(uint8_t idx, uint8_t attr)\n{\n  ARM_MPU_SetMemAttrEx(MPU, idx, attr);\n}\n\n#ifdef MPU_NS\n \n__STATIC_INLINE void ARM_MPU_SetMemAttr_NS(uint8_t idx, uint8_t attr)\n{\n  ARM_MPU_SetMemAttrEx(MPU_NS, idx, attr);\n}\n#endif\n\n \n__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)\n{\n  mpu->RNR = rnr;\n  mpu->RLAR = 0U;\n}\n\n \n__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)\n{\n  ARM_MPU_ClrRegionEx(MPU, rnr);\n}\n\n#ifdef MPU_NS\n \n__STATIC_INLINE void ARM_MPU_ClrRegion_NS(uint32_t rnr)\n{  \n  ARM_MPU_ClrRegionEx(MPU_NS, rnr);\n}\n#endif\n\n    \n__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)\n{\n  mpu->RNR = rnr;\n  mpu->RBAR = rbar;\n  mpu->RLAR = rlar;\n}\n\n    \n__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rnr, uint32_t rbar, uint32_t rlar)\n{\n  ARM_MPU_SetRegionEx(MPU, rnr, rbar, rlar);\n}\n\n#ifdef MPU_NS\n    \n__STATIC_INLINE void ARM_MPU_SetRegion_NS(uint32_t rnr, uint32_t rbar, uint32_t rlar)\n{\n  ARM_MPU_SetRegionEx(MPU_NS, rnr, rbar, rlar);  \n}\n#endif\n\n \n__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)\n{\n  uint32_t i;\n  for (i = 0U; i < len; ++i) \n  {\n    dst[i] = src[i];\n  }\n}\n\n \n__STATIC_INLINE void ARM_MPU_LoadEx(MPU_Type* mpu, uint32_t rnr, ARM_MPU_Region_t const* table, uint32_t cnt) \n{\n  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;\n  if (cnt == 1U) {\n    mpu->RNR = rnr;\n    ARM_MPU_OrderedMemcpy(&(mpu->RBAR), &(table->RBAR), rowWordSize);\n  } else {\n    uint32_t rnrBase   = rnr & ~(MPU_TYPE_RALIASES-1U);\n    uint32_t rnrOffset = rnr % MPU_TYPE_RALIASES;\n    \n    mpu->RNR = rnrBase;\n    while ((rnrOffset + cnt) > MPU_TYPE_RALIASES) {\n      uint32_t c = MPU_TYPE_RALIASES - rnrOffset;\n      ARM_MPU_OrderedMemcpy(&(mpu->RBAR)+(rnrOffset*2U), &(table->RBAR), c*rowWordSize);\n      table += c;\n      cnt -= c;\n      rnrOffset = 0U;\n      rnrBase += MPU_TYPE_RALIASES;\n      mpu->RNR = rnrBase;\n    }\n    \n    ARM_MPU_OrderedMemcpy(&(mpu->RBAR)+(rnrOffset*2U), &(table->RBAR), cnt*rowWordSize);\n  }\n}\n\n \n__STATIC_INLINE void ARM_MPU_Load(uint32_t rnr, ARM_MPU_Region_t const* table, uint32_t cnt) \n{\n  ARM_MPU_LoadEx(MPU, rnr, table, cnt);\n}\n\n#ifdef MPU_NS\n \n__STATIC_INLINE void ARM_MPU_Load_NS(uint32_t rnr, ARM_MPU_Region_t const* table, uint32_t cnt) \n{\n  ARM_MPU_LoadEx(MPU_NS, rnr, table, cnt);\n}\n#endif\n\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}