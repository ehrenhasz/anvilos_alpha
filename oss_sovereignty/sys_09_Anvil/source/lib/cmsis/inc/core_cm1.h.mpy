{
  "module_name": "core_cm1.h",
  "hash_id": "c15124f435e2849abd12b944e59e821e0930c6550145acd84819009aa01b8a68",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/cmsis/inc/core_cm1.h",
  "human_readable_source": " \n \n\n#if   defined ( __ICCARM__ )\n  #pragma system_include          \n#elif defined (__clang__)\n  #pragma clang system_header    \n#endif\n\n#ifndef __CORE_CM1_H_GENERIC\n#define __CORE_CM1_H_GENERIC\n\n#include <stdint.h>\n\n#ifdef __cplusplus\n extern \"C\" {\n#endif\n\n \n\n\n \n \n\n#include \"cmsis_version.h\"\n \n \n#define __CM1_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)               \n#define __CM1_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)                \n#define __CM1_CMSIS_VERSION       ((__CM1_CMSIS_VERSION_MAIN << 16U) | \\\n                                    __CM1_CMSIS_VERSION_SUB           )   \n\n#define __CORTEX_M                (1U)                                    \n\n \n#define __FPU_USED       0U\n\n#if defined ( __CC_ARM )\n  #if defined __TARGET_FPU_VFP\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)\n  #if defined __ARM_FP\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#elif defined ( __GNUC__ )\n  #if defined (__VFP_FP__) && !defined(__SOFTFP__)\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#elif defined ( __ICCARM__ )\n  #if defined __ARMVFP__\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#elif defined ( __TI_ARM__ )\n  #if defined __TI_VFP_SUPPORT__\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#elif defined ( __TASKING__ )\n  #if defined __FPU_VFP__\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#elif defined ( __CSMC__ )\n  #if ( __CSMC__ & 0x400U)\n    #error \"Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)\"\n  #endif\n\n#endif\n\n#include \"cmsis_compiler.h\"                \n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  \n\n#ifndef __CMSIS_GENERIC\n\n#ifndef __CORE_CM1_H_DEPENDANT\n#define __CORE_CM1_H_DEPENDANT\n\n#ifdef __cplusplus\n extern \"C\" {\n#endif\n\n \n#if defined __CHECK_DEVICE_DEFINES\n  #ifndef __CM1_REV\n    #define __CM1_REV               0x0100U\n    #warning \"__CM1_REV not defined in device header file; using default!\"\n  #endif\n\n  #ifndef __NVIC_PRIO_BITS\n    #define __NVIC_PRIO_BITS          2U\n    #warning \"__NVIC_PRIO_BITS not defined in device header file; using default!\"\n  #endif\n\n  #ifndef __Vendor_SysTickConfig\n    #define __Vendor_SysTickConfig    0U\n    #warning \"__Vendor_SysTickConfig not defined in device header file; using default!\"\n  #endif\n#endif\n\n \n \n#ifdef __cplusplus\n  #define   __I     volatile              \n#else\n  #define   __I     volatile const        \n#endif\n#define     __O     volatile              \n#define     __IO    volatile              \n\n \n#define     __IM     volatile const       \n#define     __OM     volatile             \n#define     __IOM    volatile             \n\n \n\n\n\n \n \n\n \n\n \ntypedef union\n{\n  struct\n  {\n    uint32_t _reserved0:28;               \n    uint32_t V:1;                         \n    uint32_t C:1;                         \n    uint32_t Z:1;                         \n    uint32_t N:1;                         \n  } b;                                    \n  uint32_t w;                             \n} APSR_Type;\n\n \n#define APSR_N_Pos                         31U                                             \n#define APSR_N_Msk                         (1UL << APSR_N_Pos)                             \n\n#define APSR_Z_Pos                         30U                                             \n#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                             \n\n#define APSR_C_Pos                         29U                                             \n#define APSR_C_Msk                         (1UL << APSR_C_Pos)                             \n\n#define APSR_V_Pos                         28U                                             \n#define APSR_V_Msk                         (1UL << APSR_V_Pos)                             \n\n\n \ntypedef union\n{\n  struct\n  {\n    uint32_t ISR:9;                       \n    uint32_t _reserved0:23;               \n  } b;                                    \n  uint32_t w;                             \n} IPSR_Type;\n\n \n#define IPSR_ISR_Pos                        0U                                             \n#define IPSR_ISR_Msk                       (0x1FFUL  )                   \n\n\n \ntypedef union\n{\n  struct\n  {\n    uint32_t ISR:9;                       \n    uint32_t _reserved0:15;               \n    uint32_t T:1;                         \n    uint32_t _reserved1:3;                \n    uint32_t V:1;                         \n    uint32_t C:1;                         \n    uint32_t Z:1;                         \n    uint32_t N:1;                         \n  } b;                                    \n  uint32_t w;                             \n} xPSR_Type;\n\n \n#define xPSR_N_Pos                         31U                                             \n#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                             \n\n#define xPSR_Z_Pos                         30U                                             \n#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                             \n\n#define xPSR_C_Pos                         29U                                             \n#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                             \n\n#define xPSR_V_Pos                         28U                                             \n#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                             \n\n#define xPSR_T_Pos                         24U                                             \n#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                             \n\n#define xPSR_ISR_Pos                        0U                                             \n#define xPSR_ISR_Msk                       (0x1FFUL  )                   \n\n\n \ntypedef union\n{\n  struct\n  {\n    uint32_t _reserved0:1;                \n    uint32_t SPSEL:1;                     \n    uint32_t _reserved1:30;               \n  } b;                                    \n  uint32_t w;                             \n} CONTROL_Type;\n\n \n#define CONTROL_SPSEL_Pos                   1U                                             \n#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                      \n\n \n\n\n \n\n \ntypedef struct\n{\n  __IOM uint32_t ISER[1U];                \n        uint32_t RESERVED0[31U];\n  __IOM uint32_t ICER[1U];                \n        uint32_t RSERVED1[31U];\n  __IOM uint32_t ISPR[1U];                \n        uint32_t RESERVED2[31U];\n  __IOM uint32_t ICPR[1U];                \n        uint32_t RESERVED3[31U];\n        uint32_t RESERVED4[64U];\n  __IOM uint32_t IP[8U];                  \n}  NVIC_Type;\n\n \n\n\n \n\n \ntypedef struct\n{\n  __IM  uint32_t CPUID;                   \n  __IOM uint32_t ICSR;                    \n        uint32_t RESERVED0;\n  __IOM uint32_t AIRCR;                   \n  __IOM uint32_t SCR;                     \n  __IOM uint32_t CCR;                     \n        uint32_t RESERVED1;\n  __IOM uint32_t SHP[2U];                 \n  __IOM uint32_t SHCSR;                   \n} SCB_Type;\n\n \n#define SCB_CPUID_IMPLEMENTER_Pos          24U                                             \n#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)           \n\n#define SCB_CPUID_VARIANT_Pos              20U                                             \n#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)                \n\n#define SCB_CPUID_ARCHITECTURE_Pos         16U                                             \n#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)           \n\n#define SCB_CPUID_PARTNO_Pos                4U                                             \n#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)               \n\n#define SCB_CPUID_REVISION_Pos              0U                                             \n#define SCB_CPUID_REVISION_Msk             (0xFUL  )           \n\n \n#define SCB_ICSR_NMIPENDSET_Pos            31U                                             \n#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)                \n\n#define SCB_ICSR_PENDSVSET_Pos             28U                                             \n#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                 \n\n#define SCB_ICSR_PENDSVCLR_Pos             27U                                             \n#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                 \n\n#define SCB_ICSR_PENDSTSET_Pos             26U                                             \n#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                 \n\n#define SCB_ICSR_PENDSTCLR_Pos             25U                                             \n#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                 \n\n#define SCB_ICSR_ISRPREEMPT_Pos            23U                                             \n#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)                \n\n#define SCB_ICSR_ISRPENDING_Pos            22U                                             \n#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)                \n\n#define SCB_ICSR_VECTPENDING_Pos           12U                                             \n#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)           \n\n#define SCB_ICSR_VECTACTIVE_Pos             0U                                             \n#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL  )        \n\n \n#define SCB_AIRCR_VECTKEY_Pos              16U                                             \n#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)             \n\n#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                             \n#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)         \n\n#define SCB_AIRCR_ENDIANESS_Pos            15U                                             \n#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)                \n\n#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                             \n#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)              \n\n#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                             \n#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)            \n\n \n#define SCB_SCR_SEVONPEND_Pos               4U                                             \n#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                  \n\n#define SCB_SCR_SLEEPDEEP_Pos               2U                                             \n#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                  \n\n#define SCB_SCR_SLEEPONEXIT_Pos             1U                                             \n#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)                \n\n \n#define SCB_CCR_STKALIGN_Pos                9U                                             \n#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                   \n\n#define SCB_CCR_UNALIGN_TRP_Pos             3U                                             \n#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)                \n\n \n#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                             \n#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)             \n\n \n\n\n \n\n \ntypedef struct\n{\n        uint32_t RESERVED0[2U];\n  __IOM uint32_t ACTLR;                   \n} SCnSCB_Type;\n\n \n#define SCnSCB_ACTLR_ITCMUAEN_Pos            4U                                         \n#define SCnSCB_ACTLR_ITCMUAEN_Msk           (1UL << SCnSCB_ACTLR_ITCMUAEN_Pos)          \n\n#define SCnSCB_ACTLR_ITCMLAEN_Pos            3U                                         \n#define SCnSCB_ACTLR_ITCMLAEN_Msk           (1UL << SCnSCB_ACTLR_ITCMLAEN_Pos)          \n\n \n\n\n \n\n \ntypedef struct\n{\n  __IOM uint32_t CTRL;                    \n  __IOM uint32_t LOAD;                    \n  __IOM uint32_t VAL;                     \n  __IM  uint32_t CALIB;                   \n} SysTick_Type;\n\n \n#define SysTick_CTRL_COUNTFLAG_Pos         16U                                             \n#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)             \n\n#define SysTick_CTRL_CLKSOURCE_Pos          2U                                             \n#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)             \n\n#define SysTick_CTRL_TICKINT_Pos            1U                                             \n#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)               \n\n#define SysTick_CTRL_ENABLE_Pos             0U                                             \n#define SysTick_CTRL_ENABLE_Msk            (1UL  )            \n\n \n#define SysTick_LOAD_RELOAD_Pos             0U                                             \n#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL  )     \n\n \n#define SysTick_VAL_CURRENT_Pos             0U                                             \n#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL  )     \n\n \n#define SysTick_CALIB_NOREF_Pos            31U                                             \n#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)                \n\n#define SysTick_CALIB_SKEW_Pos             30U                                             \n#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                 \n\n#define SysTick_CALIB_TENMS_Pos             0U                                             \n#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL  )     \n\n \n\n\n \n \n\n\n \n\n \n#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)\n\n \n#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)\n\n \n\n\n \n\n \n#define SCS_BASE            (0xE000E000UL)                             \n#define SysTick_BASE        (SCS_BASE +  0x0010UL)                     \n#define NVIC_BASE           (SCS_BASE +  0x0100UL)                     \n#define SCB_BASE            (SCS_BASE +  0x0D00UL)                     \n\n#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )    \n#define SCB                 ((SCB_Type       *)     SCB_BASE      )    \n#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )    \n#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )    \n\n\n \n\n\n\n \n \n\n\n\n \n \n\n#ifdef CMSIS_NVIC_VIRTUAL\n  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE\n    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE \"cmsis_nvic_virtual.h\"\n  #endif\n  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE\n#else\n  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping\n  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping\n  #define NVIC_EnableIRQ              __NVIC_EnableIRQ\n  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ\n  #define NVIC_DisableIRQ             __NVIC_DisableIRQ\n  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ\n  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ\n  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ\n \n  #define NVIC_SetPriority            __NVIC_SetPriority\n  #define NVIC_GetPriority            __NVIC_GetPriority\n  #define NVIC_SystemReset            __NVIC_SystemReset\n#endif  \n\n#ifdef CMSIS_VECTAB_VIRTUAL\n  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE\n    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE \"cmsis_vectab_virtual.h\"\n  #endif\n  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE\n#else\n  #define NVIC_SetVector              __NVIC_SetVector\n  #define NVIC_GetVector              __NVIC_GetVector\n#endif   \n\n#define NVIC_USER_IRQ_OFFSET          16\n\n\n \n#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)      \n#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)      \n#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)      \n\n\n \n \n#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)\n#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )\n#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )\n\n#define __NVIC_SetPriorityGrouping(X) (void)(X)\n#define __NVIC_GetPriorityGrouping()  (0U)\n\n \n__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    __COMPILER_BARRIER();\n    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));\n    __COMPILER_BARRIER();\n  }\n}\n\n\n \n__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));\n  }\n  else\n  {\n    return(0U);\n  }\n}\n\n\n \n__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));\n    __DSB();\n    __ISB();\n  }\n}\n\n\n \n__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));\n  }\n  else\n  {\n    return(0U);\n  }\n}\n\n\n \n__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));\n  }\n}\n\n\n \n__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));\n  }\n}\n\n\n \n__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)\n{\n  if ((int32_t)(IRQn) >= 0)\n  {\n    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |\n       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));\n  }\n  else\n  {\n    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |\n       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));\n  }\n}\n\n\n \n__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)\n{\n\n  if ((int32_t)(IRQn) >= 0)\n  {\n    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));\n  }\n  else\n  {\n    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));\n  }\n}\n\n\n \n__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)\n{\n  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);    \n  uint32_t PreemptPriorityBits;\n  uint32_t SubPriorityBits;\n\n  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);\n  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));\n\n  return (\n           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |\n           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))\n         );\n}\n\n\n \n__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)\n{\n  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);    \n  uint32_t PreemptPriorityBits;\n  uint32_t SubPriorityBits;\n\n  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);\n  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));\n\n  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);\n  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);\n}\n\n\n\n \n__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)\n{\n  uint32_t *vectors = (uint32_t *)0x0U;\n  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;\n   \n}\n\n\n \n__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)\n{\n  uint32_t *vectors = (uint32_t *)0x0U;\n  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];\n}\n\n\n \n__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)\n{\n  __DSB();                                                           \n  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |\n                 SCB_AIRCR_SYSRESETREQ_Msk);\n  __DSB();                                                           \n\n  for(;;)                                                            \n  {\n    __NOP();\n  }\n}\n\n \n\n\n \n \n\n \n__STATIC_INLINE uint32_t SCB_GetFPUType(void)\n{\n    return 0U;            \n}\n\n\n \n\n\n\n \n \n\n#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)\n\n \n__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)\n{\n  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)\n  {\n    return (1UL);                                                    \n  }\n\n  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                          \n  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);  \n  SysTick->VAL   = 0UL;                                              \n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |\n                   SysTick_CTRL_TICKINT_Msk   |\n                   SysTick_CTRL_ENABLE_Msk;                          \n  return (0UL);                                                      \n}\n\n#endif\n\n \n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}