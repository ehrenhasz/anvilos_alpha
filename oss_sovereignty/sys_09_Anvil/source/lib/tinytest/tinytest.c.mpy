{
  "module_name": "tinytest.c",
  "hash_id": "7d2ef27410b279a6143a2caf2e0b48000f04c1c24cf281c7ca421ab913a40f2c",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/tinytest/tinytest.c",
  "human_readable_source": " \n#ifdef TINYTEST_LOCAL\n#include \"tinytest_local.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#ifndef NO_FORKING\n\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#endif\n\n#if defined(__APPLE__) && defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)\n#if (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060 && \\\n    __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070)\n \n#define FORK_BREAKS_GCOV\n#include <vproc.h>\n#endif\n#endif\n\n#endif  \n\n#ifndef __GNUC__\n#define __attribute__(x)\n#endif\n\n#include \"tinytest.h\"\n#include \"tinytest_macros.h\"\n\n#define LONGEST_TEST_NAME 16384\n\nstatic int in_tinytest_main = 0;  \nstatic int n_ok = 0;  \nstatic int n_bad = 0;  \nstatic int n_skipped = 0;  \n\nstatic int opt_forked = 0;  \nstatic int opt_nofork = 0;  \nstatic int opt_verbosity = 1;  \nconst char *verbosity_flag = \"\";\n\nconst struct testlist_alias_t *cfg_aliases=NULL;\n\nenum outcome { SKIP=2, OK=1, FAIL=0 };\nstatic enum outcome cur_test_outcome = 0;\nconst char *cur_test_prefix = NULL;  \n \nconst char *cur_test_name = NULL;\n\n#ifdef _WIN32\n \nstatic char commandname[MAX_PATH+1];\n#endif\n\nstatic void usage(struct testgroup_t *groups, int list_groups)\n  __attribute__((noreturn));\nstatic int process_test_option(struct testgroup_t *groups, const char *test);\n\nstatic enum outcome\ntestcase_run_bare_(const struct testcase_t *testcase)\n{\n\tvoid *env = NULL;\n\tint outcome;\n\tif (testcase->setup) {\n\t\tenv = testcase->setup->setup_fn(testcase);\n\t\tif (!env)\n\t\t\treturn FAIL;\n\t\telse if (env == (void*)TT_SKIP)\n\t\t\treturn SKIP;\n\t}\n\n\tcur_test_outcome = OK;\n\ttestcase->fn(env);\n\toutcome = cur_test_outcome;\n\n\tif (testcase->setup) {\n\t\tif (testcase->setup->cleanup_fn(testcase, env) == 0)\n\t\t\toutcome = FAIL;\n\t}\n\n\treturn outcome;\n}\n\n#define MAGIC_EXITCODE 42\n\n#ifndef NO_FORKING\n\nstatic enum outcome\ntestcase_run_forked_(const struct testgroup_t *group,\n\t\t     const struct testcase_t *testcase)\n{\n#ifdef _WIN32\n\t \n\tint ok;\n\tchar buffer[LONGEST_TEST_NAME+256];\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION info;\n\tDWORD exitcode;\n\n\tif (!in_tinytest_main) {\n\t\tprintf(\"\\nERROR.  On Windows, testcase_run_forked_ must be\"\n\t\t       \" called from within tinytest_main.\\n\");\n\t\tabort();\n\t}\n\tif (opt_verbosity>0)\n\t\tprintf(\"[forking] \");\n\n\tsnprintf(buffer, sizeof(buffer), \"%s --RUNNING-FORKED %s %s%s\",\n\t\t commandname, verbosity_flag, group->prefix, testcase->name);\n\n\tmemset(&si, 0, sizeof(si));\n\tmemset(&info, 0, sizeof(info));\n\tsi.cb = sizeof(si);\n\n\tok = CreateProcessA(commandname, buffer, NULL, NULL, 0,\n\t\t\t   0, NULL, NULL, &si, &info);\n\tif (!ok) {\n\t\tprintf(\"CreateProcess failed!\\n\");\n\t\treturn 0;\n\t}\n\tWaitForSingleObject(info.hProcess, INFINITE);\n\tGetExitCodeProcess(info.hProcess, &exitcode);\n\tCloseHandle(info.hProcess);\n\tCloseHandle(info.hThread);\n\tif (exitcode == 0)\n\t\treturn OK;\n\telse if (exitcode == MAGIC_EXITCODE)\n\t\treturn SKIP;\n\telse\n\t\treturn FAIL;\n#else\n\tint outcome_pipe[2];\n\tpid_t pid;\n\t(void)group;\n\n\tif (pipe(outcome_pipe))\n\t\tperror(\"opening pipe\");\n\n\tif (opt_verbosity>0)\n\t\tprintf(\"[forking] \");\n\tpid = fork();\n#ifdef FORK_BREAKS_GCOV\n\tvproc_transaction_begin(0);\n#endif\n\tif (!pid) {\n\t\t \n\t\tint test_r, write_r;\n\t\tchar b[1];\n\t\tclose(outcome_pipe[0]);\n\t\ttest_r = testcase_run_bare_(testcase);\n\t\tassert(0<=(int)test_r && (int)test_r<=2);\n\t\tb[0] = \"NYS\"[test_r];\n\t\twrite_r = (int)write(outcome_pipe[1], b, 1);\n\t\tif (write_r != 1) {\n\t\t\tperror(\"write outcome to pipe\");\n\t\t\texit(1);\n\t\t}\n\t\texit(0);\n\t\treturn FAIL;  \n\t} else {\n\t\t \n\t\tint status, r;\n\t\tchar b[1];\n\t\t \n\t\tclose(outcome_pipe[1]);\n\t\tr = (int)read(outcome_pipe[0], b, 1);\n\t\tif (r == 0) {\n\t\t\tprintf(\"[Lost connection!] \");\n\t\t\treturn 0;\n\t\t} else if (r != 1) {\n\t\t\tperror(\"read outcome from pipe\");\n\t\t}\n\t\twaitpid(pid, &status, 0);\n\t\tclose(outcome_pipe[0]);\n\t\treturn b[0]=='Y' ? OK : (b[0]=='S' ? SKIP : FAIL);\n\t}\n#endif\n}\n\n#endif  \n\nint\ntestcase_run_one(const struct testgroup_t *group,\n\t\t const struct testcase_t *testcase)\n{\n\tenum outcome outcome;\n\n\tif (testcase->flags & (TT_SKIP|TT_OFF_BY_DEFAULT)) {\n\t\tif (opt_verbosity>0)\n\t\t\tprintf(\"%s%s: %s\\n\",\n\t\t\t   group->prefix, testcase->name,\n\t\t\t   (testcase->flags & TT_SKIP) ? \"SKIPPED\" : \"DISABLED\");\n\t\t++n_skipped;\n\t\treturn SKIP;\n\t}\n\n\tif (opt_verbosity>0 && !opt_forked) {\n\t\tprintf(\"%s%s: \", group->prefix, testcase->name);\n\t} else {\n\t\tif (opt_verbosity==0) printf(\".\");\n\t\tcur_test_prefix = group->prefix;\n\t\tcur_test_name = testcase->name;\n\t}\n\n#ifndef NO_FORKING\n\tif ((testcase->flags & TT_FORK) && !(opt_forked||opt_nofork)) {\n\t\toutcome = testcase_run_forked_(group, testcase);\n\t} else {\n#else\n\t{\n#endif\n\t\toutcome = testcase_run_bare_(testcase);\n\t}\n\n\tif (outcome == OK) {\n\t\t++n_ok;\n\t\tif (opt_verbosity>0 && !opt_forked)\n\t\t\tputs(opt_verbosity==1?\"OK\":\"\");\n\t} else if (outcome == SKIP) {\n\t\t++n_skipped;\n\t\tif (opt_verbosity>0 && !opt_forked)\n\t\t\tputs(\"SKIPPED\");\n\t} else {\n\t\t++n_bad;\n\t\tif (!opt_forked)\n\t\t\tprintf(\"\\n  [%s FAILED]\\n\", testcase->name);\n\t}\n\n\tif (opt_forked) {\n\t\texit(outcome==OK ? 0 : (outcome==SKIP?MAGIC_EXITCODE : 1));\n\t\treturn 1;  \n\t} else {\n\t\treturn (int)outcome;\n\t}\n}\n\nint\ntinytest_set_flag_(struct testgroup_t *groups, const char *arg, int set, unsigned long flag)\n{\n\tint i, j;\n\tsize_t length = LONGEST_TEST_NAME;\n\tchar fullname[LONGEST_TEST_NAME];\n\tint found=0;\n\tif (strstr(arg, \"..\"))\n\t\tlength = strstr(arg,\"..\")-arg;\n\tfor (i=0; groups[i].prefix; ++i) {\n\t\tfor (j=0; groups[i].cases[j].name; ++j) {\n\t\t\tstruct testcase_t *testcase = &groups[i].cases[j];\n\t\t\tsnprintf(fullname, sizeof(fullname), \"%s%s\",\n\t\t\t\t groups[i].prefix, testcase->name);\n\t\t\tif (!flag) {  \n\t\t\t\tprintf(\"    %s\", fullname);\n\t\t\t\tif (testcase->flags & TT_OFF_BY_DEFAULT)\n\t\t\t\t\tputs(\"   (Off by default)\");\n\t\t\t\telse if (testcase->flags & TT_SKIP)\n\t\t\t\t\tputs(\"  (DISABLED)\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t\tif (!strncmp(fullname, arg, length)) {\n\t\t\t\tif (set)\n\t\t\t\t\ttestcase->flags |= flag;\n\t\t\t\telse\n\t\t\t\t\ttestcase->flags &= ~flag;\n\t\t\t\t++found;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\nstatic void\nusage(struct testgroup_t *groups, int list_groups)\n{\n\tputs(\"Options are: [--verbose|--quiet|--terse] [--no-fork]\");\n\tputs(\"  Specify tests by name, or using a prefix ending with '..'\");\n\tputs(\"  To skip a test, prefix its name with a colon.\");\n\tputs(\"  To enable a disabled test, prefix its name with a plus.\");\n\tputs(\"  Use --list-tests for a list of tests.\");\n\tif (list_groups) {\n\t\tputs(\"Known tests are:\");\n\t\ttinytest_set_flag_(groups, \"..\", 1, 0);\n\t}\n\texit(0);\n}\n\nstatic int\nprocess_test_alias(struct testgroup_t *groups, const char *test)\n{\n\tint i, j, n, r;\n\tfor (i=0; cfg_aliases && cfg_aliases[i].name; ++i) {\n\t\tif (!strcmp(cfg_aliases[i].name, test)) {\n\t\t\tn = 0;\n\t\t\tfor (j = 0; cfg_aliases[i].tests[j]; ++j) {\n\t\t\t\tr = process_test_option(groups, cfg_aliases[i].tests[j]);\n\t\t\t\tif (r<0)\n\t\t\t\t\treturn -1;\n\t\t\t\tn += r;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\t}\n\tprintf(\"No such test alias as @%s!\",test);\n\treturn -1;\n}\n\nstatic int\nprocess_test_option(struct testgroup_t *groups, const char *test)\n{\n\tint flag = TT_ENABLED_;\n\tint n = 0;\n\tif (test[0] == '@') {\n\t\treturn process_test_alias(groups, test + 1);\n\t} else if (test[0] == ':') {\n\t\t++test;\n\t\tflag = TT_SKIP;\n\t} else if (test[0] == '+') {\n\t\t++test;\n\t\t++n;\n\t\tif (!tinytest_set_flag_(groups, test, 0, TT_OFF_BY_DEFAULT)) {\n\t\t\tprintf(\"No such test as %s!\\n\", test);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t++n;\n\t}\n\tif (!tinytest_set_flag_(groups, test, 1, flag)) {\n\t\tprintf(\"No such test as %s!\\n\", test);\n\t\treturn -1;\n\t}\n\treturn n;\n}\n\nvoid\ntinytest_set_aliases(const struct testlist_alias_t *aliases)\n{\n\tcfg_aliases = aliases;\n}\n\nint\ntinytest_main(int c, const char **v, struct testgroup_t *groups)\n{\n\tint i, j, n=0;\n\n#ifdef _WIN32\n\tconst char *sp = strrchr(v[0], '.');\n\tconst char *extension = \"\";\n\tif (!sp || stricmp(sp, \".exe\"))\n\t\textension = \".exe\";  \n\tsnprintf(commandname, sizeof(commandname), \"%s%s\", v[0], extension);\n\tcommandname[MAX_PATH]='\\0';\n#endif\n\tfor (i=1; i<c; ++i) {\n\t\tif (v[i][0] == '-') {\n\t\t\tif (!strcmp(v[i], \"--RUNNING-FORKED\")) {\n\t\t\t\topt_forked = 1;\n\t\t\t} else if (!strcmp(v[i], \"--no-fork\")) {\n\t\t\t\topt_nofork = 1;\n\t\t\t} else if (!strcmp(v[i], \"--quiet\")) {\n\t\t\t\topt_verbosity = -1;\n\t\t\t\tverbosity_flag = \"--quiet\";\n\t\t\t} else if (!strcmp(v[i], \"--verbose\")) {\n\t\t\t\topt_verbosity = 2;\n\t\t\t\tverbosity_flag = \"--verbose\";\n\t\t\t} else if (!strcmp(v[i], \"--terse\")) {\n\t\t\t\topt_verbosity = 0;\n\t\t\t\tverbosity_flag = \"--terse\";\n\t\t\t} else if (!strcmp(v[i], \"--help\")) {\n\t\t\t\tusage(groups, 0);\n\t\t\t} else if (!strcmp(v[i], \"--list-tests\")) {\n\t\t\t\tusage(groups, 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"Unknown option %s.  Try --help\\n\",v[i]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tint r = process_test_option(groups, v[i]);\n\t\t\tif (r<0)\n\t\t\t\treturn -1;\n\t\t\tn += r;\n\t\t}\n\t}\n\tif (!n)\n\t\ttinytest_set_flag_(groups, \"..\", 1, TT_ENABLED_);\n\n#ifdef _IONBF\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n#endif\n\n\t++in_tinytest_main;\n\tfor (i=0; groups[i].prefix; ++i)\n\t\tfor (j=0; groups[i].cases[j].name; ++j)\n\t\t\tif (groups[i].cases[j].flags & TT_ENABLED_)\n\t\t\t\ttestcase_run_one(&groups[i],\n\t\t\t\t\t\t &groups[i].cases[j]);\n\n\t--in_tinytest_main;\n\n\tif (opt_verbosity==0)\n\t\tputs(\"\");\n\n\tif (n_bad)\n\t\tprintf(\"%d/%d TESTS FAILED. (%d skipped)\\n\", n_bad,\n\t\t       n_bad+n_ok,n_skipped);\n\telse if (opt_verbosity >= 1)\n\t\tprintf(\"%d tests ok.  (%d skipped)\\n\", n_ok, n_skipped);\n\n\treturn (n_bad == 0) ? 0 : 1;\n}\n\nint\ntinytest_get_verbosity_(void)\n{\n\treturn opt_verbosity;\n}\n\nvoid\ntinytest_set_test_failed_(void)\n{\n\tif (opt_verbosity <= 0 && cur_test_name) {\n\t\tif (opt_verbosity==0) puts(\"\");\n\t\tprintf(\"%s%s: \", cur_test_prefix, cur_test_name);\n\t\tcur_test_name = NULL;\n\t}\n\tcur_test_outcome = 0;\n}\n\nvoid\ntinytest_set_test_skipped_(void)\n{\n\tif (cur_test_outcome==OK)\n\t\tcur_test_outcome = SKIP;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}