{
  "module_name": "adler32.c",
  "hash_id": "bc9c69c899cb19c73c10bd83671c61f21891ff3d473605af0289e9ec8915a7e0",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/uzlib/adler32.c",
  "human_readable_source": " \n\n \n\n#include \"uzlib.h\"\n\n#define A32_BASE 65521\n#define A32_NMAX 5552\n\nuint32_t uzlib_adler32(const void *data, unsigned int length, uint32_t prev_sum  )\n{\n   const unsigned char *buf = (const unsigned char *)data;\n\n   unsigned int s1 = prev_sum & 0xffff;\n   unsigned int s2 = prev_sum >> 16;\n\n   while (length > 0)\n   {\n      int k = length < A32_NMAX ? length : A32_NMAX;\n      int i;\n\n      for (i = k / 16; i; --i, buf += 16)\n      {\n         s1 += buf[0];  s2 += s1; s1 += buf[1];  s2 += s1;\n         s1 += buf[2];  s2 += s1; s1 += buf[3];  s2 += s1;\n         s1 += buf[4];  s2 += s1; s1 += buf[5];  s2 += s1;\n         s1 += buf[6];  s2 += s1; s1 += buf[7];  s2 += s1;\n\n         s1 += buf[8];  s2 += s1; s1 += buf[9];  s2 += s1;\n         s1 += buf[10]; s2 += s1; s1 += buf[11]; s2 += s1;\n         s1 += buf[12]; s2 += s1; s1 += buf[13]; s2 += s1;\n         s1 += buf[14]; s2 += s1; s1 += buf[15]; s2 += s1;\n      }\n\n      for (i = k % 16; i; --i) { s1 += *buf++; s2 += s1; }\n\n      s1 %= A32_BASE;\n      s2 %= A32_BASE;\n\n      length -= k;\n   }\n\n   return (s2 << 16) | s1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}