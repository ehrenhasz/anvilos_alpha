{
  "module_name": "tinflate.c",
  "hash_id": "15781ac98a67a0ec47bcfa57f881e1812b0da63ea6d7f96ac055f6b96af2615e",
  "original_prompt": "Ingested from sys_09_Anvil/source/lib/uzlib/tinflate.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include \"uzlib.h\"\n\n#define UZLIB_DUMP_ARRAY(heading, arr, size) \\\n    { \\\n        printf(\"%s\", heading); \\\n        for (int i = 0; i < size; ++i) { \\\n            printf(\" %d\", (arr)[i]); \\\n        } \\\n        printf(\"\\n\"); \\\n    }\n\nuint32_t tinf_get_le_uint32(uzlib_uncomp_t *d);\nuint32_t tinf_get_be_uint32(uzlib_uncomp_t *d);\n\n \n\ntypedef struct {\n    unsigned char length_bits : 3;\n    unsigned short length_base : 9;\n    unsigned char dist_bits : 4;\n    unsigned short dist_base : 15;\n} lookup_table_entry_t;\n\nconst lookup_table_entry_t lookup_table[30] = {\n    {0, 3, 0, 1},\n    {0, 4, 0, 2},\n    {0, 5, 0, 3},\n    {0, 6, 0, 4},\n    {0, 7, 1, 5},\n    {0, 8, 1, 7},\n    {0, 9, 2, 9},\n    {0, 10, 2, 13},\n    {1, 11, 3, 17},\n    {1, 13, 3, 25},\n    {1, 15, 4, 33},\n    {1, 17, 4, 49},\n    {2, 19, 5, 65},\n    {2, 23, 5, 97},\n    {2, 27, 6, 129},\n    {2, 31, 6, 193},\n    {3, 35, 7, 257},\n    {3, 43, 7, 385},\n    {3, 51, 8, 513},\n    {3, 59, 8, 769},\n    {4, 67, 9, 1025},\n    {4, 83, 9, 1537},\n    {4, 99, 10, 2049},\n    {4, 115, 10, 3073},\n    {5, 131, 11, 4097},\n    {5, 163, 11, 6145},\n    {5, 195, 12, 8193},\n    {5, 227, 12, 12289},\n    {0, 258, 13, 16385},\n    {0, 0, 13, 24577},\n};\n\n \nconst unsigned char clcidx[] = {\n   16, 17, 18, 0, 8, 7, 9, 6,\n   10, 5, 11, 4, 12, 3, 13, 2,\n   14, 1, 15\n};\n\n \n\n \nstatic void tinf_build_fixed_trees(TINF_TREE *lt, TINF_TREE *dt)\n{\n   int i;\n\n    \n   for (i = 0; i < 7; ++i) lt->table[i] = 0;\n\n   lt->table[7] = 24;\n   lt->table[8] = 152;\n   lt->table[9] = 112;\n\n   for (i = 0; i < 24; ++i) lt->trans[i] = 256 + i;\n   for (i = 0; i < 144; ++i) lt->trans[24 + i] = i;\n   for (i = 0; i < 8; ++i) lt->trans[24 + 144 + i] = 280 + i;\n   for (i = 0; i < 112; ++i) lt->trans[24 + 144 + 8 + i] = 144 + i;\n\n    \n   for (i = 0; i < 5; ++i) dt->table[i] = 0;\n\n   dt->table[5] = 32;\n\n   for (i = 0; i < 32; ++i) dt->trans[i] = i;\n}\n\n \nstatic void tinf_build_tree(TINF_TREE *t, const unsigned char *lengths, unsigned int num)\n{\n   unsigned short offs[16];\n   unsigned int i, sum;\n\n    \n   for (i = 0; i < 16; ++i) t->table[i] = 0;\n\n    \n   for (i = 0; i < num; ++i) t->table[lengths[i]]++;\n\n   #if UZLIB_CONF_DEBUG_LOG >= 2\n   UZLIB_DUMP_ARRAY(\"codelen counts:\", t->table, TINF_ARRAY_SIZE(t->table));\n   #endif\n\n    \n   t->table[0] = 0;\n\n    \n   for (sum = 0, i = 0; i < 16; ++i)\n   {\n      offs[i] = sum;\n      sum += t->table[i];\n   }\n\n   #if UZLIB_CONF_DEBUG_LOG >= 2\n   UZLIB_DUMP_ARRAY(\"codelen offsets:\", offs, TINF_ARRAY_SIZE(offs));\n   #endif\n\n    \n   for (i = 0; i < num; ++i)\n   {\n      if (lengths[i]) t->trans[offs[lengths[i]]++] = i;\n   }\n}\n\n \n\nunsigned char uzlib_get_byte(uzlib_uncomp_t *d)\n{\n     \n    if (d->source < d->source_limit) {\n        return *d->source++;\n    }\n\n     \n    if (d->source_read_cb && !d->eof) {\n        int val = d->source_read_cb(d->source_read_data);\n        if (val >= 0) {\n            return (unsigned char)val;\n        }\n    }\n\n     \n    d->eof = true;\n\n    return 0;\n}\n\nuint32_t tinf_get_le_uint32(uzlib_uncomp_t *d)\n{\n    uint32_t val = 0;\n    int i;\n    for (i = 4; i--;) {\n        val = val >> 8 | ((uint32_t)uzlib_get_byte(d)) << 24;\n    }\n    return val;\n}\n\nuint32_t tinf_get_be_uint32(uzlib_uncomp_t *d)\n{\n    uint32_t val = 0;\n    int i;\n    for (i = 4; i--;) {\n        val = val << 8 | uzlib_get_byte(d);\n    }\n    return val;\n}\n\n \nstatic int tinf_getbit(uzlib_uncomp_t *d)\n{\n   unsigned int bit;\n\n    \n   if (!d->bitcount--)\n   {\n       \n      d->tag = uzlib_get_byte(d);\n      d->bitcount = 7;\n   }\n\n    \n   bit = d->tag & 0x01;\n   d->tag >>= 1;\n\n   return bit;\n}\n\n \nstatic unsigned int tinf_read_bits(uzlib_uncomp_t *d, int num, int base)\n{\n   unsigned int val = 0;\n\n    \n   if (num)\n   {\n      unsigned int limit = 1 << (num);\n      unsigned int mask;\n\n      for (mask = 1; mask < limit; mask *= 2)\n         if (tinf_getbit(d)) val += mask;\n   }\n\n   return val + base;\n}\n\n \nstatic int tinf_decode_symbol(uzlib_uncomp_t *d, TINF_TREE *t)\n{\n   int sum = 0, cur = 0, len = 0;\n\n    \n   do {\n\n      cur = 2*cur + tinf_getbit(d);\n\n      if (++len == TINF_ARRAY_SIZE(t->table)) {\n         return UZLIB_DATA_ERROR;\n      }\n\n      sum += t->table[len];\n      cur -= t->table[len];\n\n   } while (cur >= 0);\n\n   sum += cur;\n   #if UZLIB_CONF_PARANOID_CHECKS\n   if (sum < 0 || sum >= TINF_ARRAY_SIZE(t->trans)) {\n      return UZLIB_DATA_ERROR;\n   }\n   #endif\n\n   return t->trans[sum];\n}\n\n \nstatic int tinf_decode_trees(uzlib_uncomp_t *d, TINF_TREE *lt, TINF_TREE *dt)\n{\n    \n   unsigned char lengths[288+32];\n   unsigned int hlit, hdist, hclen, hlimit;\n   unsigned int i, num, length;\n\n    \n   hlit = tinf_read_bits(d, 5, 257);\n\n    \n   hdist = tinf_read_bits(d, 5, 1);\n\n    \n   hclen = tinf_read_bits(d, 4, 4);\n\n   for (i = 0; i < 19; ++i) lengths[i] = 0;\n\n    \n   for (i = 0; i < hclen; ++i)\n   {\n       \n      unsigned int clen = tinf_read_bits(d, 3, 0);\n\n      lengths[clcidx[i]] = clen;\n   }\n\n    \n   tinf_build_tree(lt, lengths, 19);\n\n    \n   hlimit = hlit + hdist;\n   for (num = 0; num < hlimit; )\n   {\n      int sym = tinf_decode_symbol(d, lt);\n      unsigned char fill_value = 0;\n      int lbits, lbase = 3;\n\n       \n      if (sym < 0) return sym;\n\n      switch (sym)\n      {\n      case 16:\n          \n         if (num == 0) return UZLIB_DATA_ERROR;\n         fill_value = lengths[num - 1];\n         lbits = 2;\n         break;\n      case 17:\n          \n         lbits = 3;\n         break;\n      case 18:\n          \n         lbits = 7;\n         lbase = 11;\n         break;\n      default:\n          \n         lengths[num++] = sym;\n          \n         continue;\n      }\n\n       \n      length = tinf_read_bits(d, lbits, lbase);\n      if (num + length > hlimit) return UZLIB_DATA_ERROR;\n      for (; length; --length)\n      {\n         lengths[num++] = fill_value;\n      }\n   }\n\n   #if UZLIB_CONF_DEBUG_LOG >= 2\n   printf(\"lit code lengths (%d):\", hlit);\n   UZLIB_DUMP_ARRAY(\"\", lengths, hlit);\n   printf(\"dist code lengths (%d):\", hdist);\n   UZLIB_DUMP_ARRAY(\"\", lengths + hlit, hdist);\n   #endif\n\n   #if UZLIB_CONF_PARANOID_CHECKS\n    \n   if (lengths[256] == 0) {\n      return UZLIB_DATA_ERROR;\n   }\n   #endif\n\n    \n   tinf_build_tree(lt, lengths, hlit);\n   tinf_build_tree(dt, lengths + hlit, hdist);\n\n   return UZLIB_OK;\n}\n\n \n\n \nstatic int tinf_inflate_block_data(uzlib_uncomp_t *d, TINF_TREE *lt, TINF_TREE *dt)\n{\n    if (d->curlen == 0) {\n        unsigned int offs;\n        int dist;\n        int sym = tinf_decode_symbol(d, lt);\n         \n\n        if (d->eof) {\n            return UZLIB_DATA_ERROR;\n        }\n\n         \n        if (sym < 256) {\n            TINF_PUT(d, sym);\n            return UZLIB_OK;\n        }\n\n         \n        if (sym == 256) {\n            return UZLIB_DONE;\n        }\n\n         \n        sym -= 257;\n        if (sym >= 29) {\n            return UZLIB_DATA_ERROR;\n        }\n\n         \n        d->curlen = tinf_read_bits(d, lookup_table[sym].length_bits, lookup_table[sym].length_base);\n\n        dist = tinf_decode_symbol(d, dt);\n        if (dist >= 30) {\n            return UZLIB_DATA_ERROR;\n        }\n\n         \n        offs = tinf_read_bits(d, lookup_table[dist].dist_bits, lookup_table[dist].dist_base);\n\n         \n        if (d->dict_ring) {\n            if (offs > d->dict_size) {\n                return UZLIB_DICT_ERROR;\n            }\n             \n\n            d->lzOff = d->dict_idx - offs;\n            if (d->lzOff < 0) {\n                d->lzOff += d->dict_size;\n            }\n        } else {\n             \n            if (offs > (unsigned int)(d->dest - d->dest_start)) {\n                return UZLIB_DATA_ERROR;\n            }\n            d->lzOff = -offs;\n        }\n    }\n\n     \n    if (d->dict_ring) {\n        TINF_PUT(d, d->dict_ring[d->lzOff]);\n        if ((unsigned)++d->lzOff == d->dict_size) {\n            d->lzOff = 0;\n        }\n    } else {\n        d->dest[0] = d->dest[d->lzOff];\n        d->dest++;\n    }\n    d->curlen--;\n    return UZLIB_OK;\n}\n\n \nstatic int tinf_inflate_uncompressed_block(uzlib_uncomp_t *d)\n{\n    if (d->curlen == 0) {\n        unsigned int length, invlength;\n\n         \n        length = uzlib_get_byte(d);\n        length += 256 * uzlib_get_byte(d);\n         \n        invlength = uzlib_get_byte(d);\n        invlength += 256 * uzlib_get_byte(d);\n         \n        if (length != (~invlength & 0x0000ffff)) return UZLIB_DATA_ERROR;\n\n         \n        d->curlen = length + 1;\n\n         \n        d->bitcount = 0;\n    }\n\n    if (--d->curlen == 0) {\n        return UZLIB_DONE;\n    }\n\n    unsigned char c = uzlib_get_byte(d);\n    TINF_PUT(d, c);\n    return UZLIB_OK;\n}\n\n \n\n \nvoid uzlib_uncompress_init(uzlib_uncomp_t *d, void *dict, unsigned int dictLen)\n{\n   d->eof = 0;\n   d->bitcount = 0;\n   d->bfinal = 0;\n   d->btype = -1;\n   d->dict_size = dictLen;\n   d->dict_ring = dict;\n   d->dict_idx = 0;\n   d->curlen = 0;\n}\n\n \nint uzlib_uncompress(uzlib_uncomp_t *d)\n{\n    do {\n        int res;\n\n         \n        if (d->btype == -1) {\nnext_blk:\n             \n            d->bfinal = tinf_getbit(d);\n             \n            d->btype = tinf_read_bits(d, 2, 0);\n\n            #if UZLIB_CONF_DEBUG_LOG >= 1\n            printf(\"Started new block: type=%d final=%d\\n\", d->btype, d->bfinal);\n            #endif\n\n            if (d->btype == 1) {\n                 \n                tinf_build_fixed_trees(&d->ltree, &d->dtree);\n            } else if (d->btype == 2) {\n                 \n                res = tinf_decode_trees(d, &d->ltree, &d->dtree);\n                if (res != UZLIB_OK) {\n                    return res;\n                }\n            }\n        }\n\n         \n        switch (d->btype)\n        {\n        case 0:\n             \n            res = tinf_inflate_uncompressed_block(d);\n            break;\n        case 1:\n        case 2:\n             \n             \n            res = tinf_inflate_block_data(d, &d->ltree, &d->dtree);\n            break;\n        default:\n            return UZLIB_DATA_ERROR;\n        }\n\n        if (res == UZLIB_DONE && !d->bfinal) {\n             \n            goto next_blk;\n        }\n\n        if (res != UZLIB_OK) {\n            return res;\n        }\n\n    } while (d->dest < d->dest_limit);\n\n    return UZLIB_OK;\n}\n\n \nint uzlib_uncompress_chksum(uzlib_uncomp_t *d)\n{\n    int res;\n    unsigned char *data = d->dest;\n\n    res = uzlib_uncompress(d);\n\n    if (res < 0) return res;\n\n    switch (d->checksum_type) {\n\n    case UZLIB_CHKSUM_ADLER:\n        d->checksum = uzlib_adler32(data, d->dest - data, d->checksum);\n        break;\n\n    case UZLIB_CHKSUM_CRC:\n        d->checksum = uzlib_crc32(data, d->dest - data, d->checksum);\n        break;\n    }\n\n    if (res == UZLIB_DONE) {\n        unsigned int val;\n\n        switch (d->checksum_type) {\n\n        case UZLIB_CHKSUM_ADLER:\n            val = tinf_get_be_uint32(d);\n            if (d->checksum != val) {\n                return UZLIB_CHKSUM_ERROR;\n            }\n            break;\n\n        case UZLIB_CHKSUM_CRC:\n            val = tinf_get_le_uint32(d);\n            if (~d->checksum != val) {\n                return UZLIB_CHKSUM_ERROR;\n            }\n            \n            val = tinf_get_le_uint32(d);\n            break;\n        }\n    }\n\n    return res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}