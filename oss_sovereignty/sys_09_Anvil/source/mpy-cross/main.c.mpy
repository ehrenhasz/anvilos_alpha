{
  "module_name": "main.c",
  "hash_id": "02aed87aea0ae4f112bca16e6acf392f746ad5339c0d3d94c1b56bdddae2875a",
  "original_prompt": "Ingested from sys_09_Anvil/source/mpy-cross/main.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"py/builtin.h\"\n#include \"py/compile.h\"\n#include \"py/persistentcode.h\"\n#include \"py/runtime.h\"\n#include \"py/gc.h\"\n#include \"py/stackctrl.h\"\n#include \"genhdr/mpversion.h\"\n#ifdef _WIN32\n#include \"ports/windows/fmode.h\"\n#endif\n\n\nstatic uint emit_opt = MP_EMIT_OPT_NONE;\nmp_uint_t mp_verbose_flag = 0;\n\n\n\nlong heap_size = 1024 * 1024 * (sizeof(mp_uint_t) / 4);\n\nstatic void stdout_print_strn(void *env, const char *str, size_t len) {\n    (void)env;\n    ssize_t dummy = write(STDOUT_FILENO, str, len);\n    (void)dummy;\n}\n\nstatic const mp_print_t mp_stdout_print = {NULL, stdout_print_strn};\n\nstatic void stderr_print_strn(void *env, const char *str, size_t len) {\n    (void)env;\n    ssize_t dummy = write(STDERR_FILENO, str, len);\n    (void)dummy;\n}\n\nstatic const mp_print_t mp_stderr_print = {NULL, stderr_print_strn};\n\nstatic int compile_and_save(const char *file, const char *output_file, const char *source_file) {\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_lexer_t *lex;\n        if (strcmp(file, \"-\") == 0) {\n            lex = mp_lexer_new_from_fd(MP_QSTR__lt_stdin_gt_, STDIN_FILENO, false);\n        } else {\n            lex = mp_lexer_new_from_file(qstr_from_str(file));\n        }\n\n        qstr source_name;\n        if (source_file == NULL) {\n            source_name = lex->source_name;\n        } else {\n            source_name = qstr_from_str(source_file);\n        }\n\n        #if MICROPY_PY___FILE__\n        mp_store_global(MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));\n        #endif\n\n        mp_parse_tree_t parse_tree = mp_parse(lex, MP_PARSE_FILE_INPUT);\n        mp_compiled_module_t cm;\n        cm.context = m_new_obj(mp_module_context_t);\n        mp_compile_to_raw_code(&parse_tree, source_name, false, &cm);\n\n        if ((output_file != NULL && strcmp(output_file, \"-\") == 0) ||\n            (output_file == NULL && strcmp(file, \"-\") == 0)) {\n            mp_raw_code_save(&cm, (mp_print_t *)&mp_stdout_print);\n        } else {\n            vstr_t vstr;\n            vstr_init(&vstr, 16);\n            if (output_file == NULL) {\n                vstr_add_str(&vstr, file);\n                vstr_cut_tail_bytes(&vstr, 2);\n                vstr_add_str(&vstr, \"mpy\");\n            } else {\n                vstr_add_str(&vstr, output_file);\n            }\n\n            mp_raw_code_save_file(&cm, qstr_from_strn(vstr.buf, vstr.len));\n            vstr_clear(&vstr);\n        }\n\n        nlr_pop();\n        return 0;\n    } else {\n        \n        mp_obj_print_exception(&mp_stderr_print, (mp_obj_t)nlr.ret_val);\n        return 1;\n    }\n}\n\nstatic int usage(char **argv) {\n    printf(\n        \"usage: %s [<opts>] [-X <implopt>] [--] <input filename>\\n\"\n        \"Options:\\n\"\n        \"--version : show version information\\n\"\n        \"-o : output file for compiled bytecode (defaults to input filename with .mpy extension, or stdout if input is stdin)\\n\"\n        \"-s : source filename to embed in the compiled bytecode (defaults to input file)\\n\"\n        \"-v : verbose (trace various operations); can be multiple\\n\"\n        \"-O[N] : apply bytecode optimizations of level N\\n\"\n        \"\\n\"\n        \"Target specific options:\\n\"\n        \"-msmall-int-bits=number : set the maximum bits used to encode a small-int\\n\"\n        \"-march=<arch> : set architecture for native emitter; x86, x64, armv6, armv6m, armv7m, armv7em, armv7emsp, armv7emdp, xtensa, xtensawin\\n\"\n        \"\\n\"\n        \"Implementation specific options:\\n\", argv[0]\n        );\n    int impl_opts_cnt = 0;\n    printf(\n        #if MICROPY_EMIT_NATIVE\n        \"  emit={bytecode,native,viper} -- set the default code emitter\\n\"\n        #else\n        \"  emit=bytecode -- set the default code emitter\\n\"\n        #endif\n        );\n    impl_opts_cnt++;\n    printf(\n        \"  heapsize=<n> -- set the heap size for the GC (default %ld)\\n\"\n        , heap_size);\n    impl_opts_cnt++;\n\n    if (impl_opts_cnt == 0) {\n        printf(\"  (none)\\n\");\n    }\n\n    return 1;\n}\n\n\nstatic void pre_process_options(int argc, char **argv) {\n    for (int a = 1; a < argc; a++) {\n        if (argv[a][0] == '-') {\n            if (strcmp(argv[a], \"-X\") == 0) {\n                if (a + 1 >= argc) {\n                    exit(usage(argv));\n                }\n                if (strcmp(argv[a + 1], \"emit=bytecode\") == 0) {\n                    emit_opt = MP_EMIT_OPT_BYTECODE;\n                #if MICROPY_EMIT_NATIVE\n                } else if (strcmp(argv[a + 1], \"emit=native\") == 0) {\n                    emit_opt = MP_EMIT_OPT_NATIVE_PYTHON;\n                } else if (strcmp(argv[a + 1], \"emit=viper\") == 0) {\n                    emit_opt = MP_EMIT_OPT_VIPER;\n                #endif\n                } else if (strncmp(argv[a + 1], \"heapsize=\", sizeof(\"heapsize=\") - 1) == 0) {\n                    char *end;\n                    heap_size = strtol(argv[a + 1] + sizeof(\"heapsize=\") - 1, &end, 0);\n                    \n                    \n                    \n                    \n                    \n                    \n                    bool word_adjust = false;\n                    if ((*end | 0x20) == 'w') {\n                        word_adjust = true;\n                        end++;\n                    }\n                    if ((*end | 0x20) == 'k') {\n                        heap_size *= 1024;\n                    } else if ((*end | 0x20) == 'm') {\n                        heap_size *= 1024 * 1024;\n                    }\n                    if (word_adjust) {\n                        heap_size = heap_size * MP_BYTES_PER_OBJ_WORD / 4;\n                    }\n                } else {\n                    exit(usage(argv));\n                }\n                a++;\n            }\n        }\n    }\n}\n\nstatic char *backslash_to_forwardslash(char *path) {\n    for (char *p = path; p != NULL && *p != '\\0'; ++p) {\n        if (*p == '\\\\') {\n            *p = '/';\n        }\n    }\n    return path;\n}\n\nMP_NOINLINE int main_(int argc, char **argv) {\n    mp_stack_set_limit(40000 * (sizeof(void *) / 4));\n\n    pre_process_options(argc, argv);\n\n    char *heap = malloc(heap_size);\n    gc_init(heap, heap + heap_size);\n\n    mp_init();\n    #ifdef _WIN32\n    set_fmode_binary();\n    #endif\n\n    #if MICROPY_EMIT_NATIVE\n    \n    MP_STATE_VM(default_emit_opt) = emit_opt;\n    #else\n    (void)emit_opt;\n    #endif\n\n    \n    mp_dynamic_compiler.small_int_bits = 31;\n    \n    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_NONE;\n    mp_dynamic_compiler.nlr_buf_num_regs = 0;\n\n    const char *input_file = NULL;\n    const char *output_file = NULL;\n    const char *source_file = NULL;\n    bool option_parsing_active = true;\n\n    \n    for (int a = 1; a < argc; a++) {\n        if (option_parsing_active && argv[a][0] == '-' && argv[a][1] != '\\0') {\n            if (strcmp(argv[a], \"-X\") == 0) {\n                a += 1;\n            } else if (strcmp(argv[a], \"--version\") == 0) {\n                printf(\"MicroPython \" MICROPY_GIT_TAG \" on \" MICROPY_BUILD_DATE\n                    \"; mpy-cross emitting mpy v\" MP_STRINGIFY(MPY_VERSION) \".\" MP_STRINGIFY(MPY_SUB_VERSION) \"\\n\");\n                return 0;\n            } else if (strcmp(argv[a], \"-v\") == 0) {\n                mp_verbose_flag++;\n            } else if (strncmp(argv[a], \"-O\", 2) == 0) {\n                if (unichar_isdigit(argv[a][2])) {\n                    MP_STATE_VM(mp_optimise_value) = argv[a][2] & 0xf;\n                } else {\n                    MP_STATE_VM(mp_optimise_value) = 0;\n                    for (char *p = argv[a] + 1; *p && *p == 'O'; p++, MP_STATE_VM(mp_optimise_value)++) {;\n                    }\n                }\n            } else if (strcmp(argv[a], \"-o\") == 0) {\n                if (a + 1 >= argc) {\n                    exit(usage(argv));\n                }\n                a += 1;\n                output_file = argv[a];\n            } else if (strcmp(argv[a], \"-s\") == 0) {\n                if (a + 1 >= argc) {\n                    exit(usage(argv));\n                }\n                a += 1;\n                source_file = backslash_to_forwardslash(argv[a]);\n            } else if (strncmp(argv[a], \"-msmall-int-bits=\", sizeof(\"-msmall-int-bits=\") - 1) == 0) {\n                char *end;\n                mp_dynamic_compiler.small_int_bits =\n                    strtol(argv[a] + sizeof(\"-msmall-int-bits=\") - 1, &end, 0);\n                if (*end) {\n                    return usage(argv);\n                }\n                \n            } else if (strncmp(argv[a], \"-march=\", sizeof(\"-march=\") - 1) == 0) {\n                const char *arch = argv[a] + sizeof(\"-march=\") - 1;\n                if (strcmp(arch, \"x86\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_X86;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_X86;\n                } else if (strcmp(arch, \"x64\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_X64;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MAX(MICROPY_NLR_NUM_REGS_X64, MICROPY_NLR_NUM_REGS_X64_WIN);\n                } else if (strcmp(arch, \"armv6\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV6;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP;\n                } else if (strcmp(arch, \"armv6m\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV6M;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP; \n                } else if (strcmp(arch, \"armv7m\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV7M;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP;\n                } else if (strcmp(arch, \"armv7em\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV7EM;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP;\n                } else if (strcmp(arch, \"armv7emsp\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV7EMSP;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP;\n                } else if (strcmp(arch, \"armv7emdp\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV7EMDP;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP;\n                } else if (strcmp(arch, \"xtensa\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_XTENSA;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_XTENSA;\n                } else if (strcmp(arch, \"xtensawin\") == 0) {\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_XTENSAWIN;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_XTENSAWIN;\n                } else if (strcmp(arch, \"host\") == 0) {\n                    #if defined(__i386__) || defined(_M_IX86)\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_X86;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_X86;\n                    #elif defined(__x86_64__) || defined(_M_X64)\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_X64;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MAX(MICROPY_NLR_NUM_REGS_X64, MICROPY_NLR_NUM_REGS_X64_WIN);\n                    #elif defined(__arm__) && !defined(__thumb2__)\n                    mp_dynamic_compiler.native_arch = MP_NATIVE_ARCH_ARMV6;\n                    mp_dynamic_compiler.nlr_buf_num_regs = MICROPY_NLR_NUM_REGS_ARM_THUMB_FP;\n                    #else\n                    mp_printf(&mp_stderr_print, \"unable to determine host architecture for -march=host\\n\");\n                    exit(1);\n                    #endif\n                } else {\n                    return usage(argv);\n                }\n            } else if (strcmp(argv[a], \"--\") == 0) {\n                option_parsing_active = false;\n            } else {\n                return usage(argv);\n            }\n        } else {\n            if (input_file != NULL) {\n                mp_printf(&mp_stderr_print, \"multiple input files\\n\");\n                exit(1);\n            }\n            input_file = backslash_to_forwardslash(argv[a]);\n        }\n    }\n\n    if (input_file == NULL) {\n        mp_printf(&mp_stderr_print, \"no input file\\n\");\n        exit(1);\n    }\n\n    int ret = compile_and_save(input_file, output_file, source_file);\n\n    #if MICROPY_PY_MICROPYTHON_MEM_INFO\n    if (mp_verbose_flag) {\n        mp_micropython_mem_info(0, NULL);\n    }\n    #endif\n\n    mp_deinit();\n\n    return ret & 0xff;\n}\n\nint main(int argc, char **argv) {\n    mp_stack_ctrl_init();\n    return main_(argc, argv);\n}\n\nmp_import_stat_t mp_import_stat(const char *path) {\n    (void)path;\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\nvoid nlr_jump_fail(void *val) {\n    fprintf(stderr, \"FATAL: uncaught NLR %p\\n\", val);\n    exit(1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}