{
  "module_name": "modffi.c",
  "hash_id": "6452c310ebcdb97fdd5e288dc0070ede09800caa031a7c73cddc040da62d9ad8",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/modffi.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n#include \"py/mperrno.h\"\n#include \"py/objint.h\"\n#include \"py/gc.h\"\n\n#if MICROPY_PY_FFI\n\n#include <assert.h>\n#include <string.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <ffi.h>\n\n \n\n \ntypedef union _ffi_union_t {\n    ffi_arg ffi;\n    unsigned char B;\n    unsigned short int H;\n    unsigned int I;\n    unsigned long int L;\n    unsigned long long int Q;\n    float flt;\n    double dbl;\n} ffi_union_t;\n\ntypedef struct _mp_obj_opaque_t {\n    mp_obj_base_t base;\n    void *val;\n} mp_obj_opaque_t;\n\ntypedef struct _mp_obj_ffimod_t {\n    mp_obj_base_t base;\n    void *handle;\n} mp_obj_ffimod_t;\n\ntypedef struct _mp_obj_ffivar_t {\n    mp_obj_base_t base;\n    void *var;\n    char type;\n \n} mp_obj_ffivar_t;\n\ntypedef struct _mp_obj_ffifunc_t {\n    mp_obj_base_t base;\n    void *func;\n    char rettype;\n    const char *argtypes;\n    ffi_cif cif;\n    ffi_type *params[];\n} mp_obj_ffifunc_t;\n\ntypedef struct _mp_obj_fficallback_t {\n    mp_obj_base_t base;\n    void *func;\n    ffi_closure *clo;\n    char rettype;\n    mp_obj_t pyfunc;\n    ffi_cif cif;\n    ffi_type *params[];\n} mp_obj_fficallback_t;\n\n \nstatic const mp_obj_type_t ffimod_type;\nstatic const mp_obj_type_t ffifunc_type;\nstatic const mp_obj_type_t fficallback_type;\nstatic const mp_obj_type_t ffivar_type;\n\nstatic ffi_type *char2ffi_type(char c) {\n    switch (c) {\n        case 'b':\n            return &ffi_type_schar;\n        case 'B':\n            return &ffi_type_uchar;\n        case 'h':\n            return &ffi_type_sshort;\n        case 'H':\n            return &ffi_type_ushort;\n        case 'i':\n            return &ffi_type_sint;\n        case 'I':\n            return &ffi_type_uint;\n        case 'l':\n            return &ffi_type_slong;\n        case 'L':\n            return &ffi_type_ulong;\n        case 'q':\n            return &ffi_type_sint64;\n        case 'Q':\n            return &ffi_type_uint64;\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case 'f':\n            return &ffi_type_float;\n        case 'd':\n            return &ffi_type_double;\n        #endif\n        case 'O':  \n        case 'C':  \n        case 'P':  \n        case 'p':  \n        case 's':\n            return &ffi_type_pointer;\n        case 'v':\n            return &ffi_type_void;\n        default:\n            return NULL;\n    }\n}\n\nstatic ffi_type *get_ffi_type(mp_obj_t o_in) {\n    if (mp_obj_is_str(o_in)) {\n        const char *s = mp_obj_str_get_str(o_in);\n        ffi_type *t = char2ffi_type(*s);\n        if (t != NULL) {\n            return t;\n        }\n    }\n     \n\n    mp_raise_TypeError(MP_ERROR_TEXT(\"unknown type\"));\n}\n\nstatic mp_obj_t return_ffi_value(ffi_union_t *val, char type) {\n    switch (type) {\n        case 's': {\n            const char *s = (const char *)(intptr_t)val->ffi;\n            if (!s) {\n                return mp_const_none;\n            }\n            return mp_obj_new_str(s, strlen(s));\n        }\n        case 'v':\n            return mp_const_none;\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case 'f': {\n            return mp_obj_new_float_from_f(val->flt);\n        }\n        case 'd': {\n            return mp_obj_new_float_from_d(val->dbl);\n        }\n        #endif\n        case 'b':\n        case 'h':\n        case 'i':\n        case 'l':\n            return mp_obj_new_int((signed)val->ffi);\n        case 'B':\n        case 'H':\n        case 'I':\n        case 'L':\n            return mp_obj_new_int_from_uint(val->ffi);\n        case 'q':\n            return mp_obj_new_int_from_ll(val->Q);\n        case 'Q':\n            return mp_obj_new_int_from_ull(val->Q);\n        case 'O':\n            return (mp_obj_t)(intptr_t)val->ffi;\n        default:\n            return mp_obj_new_int(val->ffi);\n    }\n}\n\n \n\nstatic void ffimod_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_ffimod_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<ffimod %p>\", self->handle);\n}\n\nstatic mp_obj_t ffimod_close(mp_obj_t self_in) {\n    mp_obj_ffimod_t *self = MP_OBJ_TO_PTR(self_in);\n    dlclose(self->handle);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(ffimod_close_obj, ffimod_close);\n\nstatic mp_obj_t make_func(mp_obj_t rettype_in, void *func, mp_obj_t argtypes_in) {\n    const char *rettype = mp_obj_str_get_str(rettype_in);\n    const char *argtypes = mp_obj_str_get_str(argtypes_in);\n\n    mp_int_t nparams = MP_OBJ_SMALL_INT_VALUE(mp_obj_len_maybe(argtypes_in));\n    mp_obj_ffifunc_t *o = mp_obj_malloc_var(mp_obj_ffifunc_t, params, ffi_type *, nparams, &ffifunc_type);\n\n    o->func = func;\n    o->rettype = *rettype;\n    o->argtypes = argtypes;\n\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(argtypes_in, &iter_buf);\n    mp_obj_t item;\n    int i = 0;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        o->params[i++] = get_ffi_type(item);\n    }\n\n    int res = ffi_prep_cif(&o->cif, FFI_DEFAULT_ABI, nparams, char2ffi_type(*rettype), o->params);\n    if (res != FFI_OK) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"error in ffi_prep_cif\"));\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_obj_t ffimod_func(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;  \n    mp_obj_ffimod_t *self = MP_OBJ_TO_PTR(args[0]);\n    const char *symname = mp_obj_str_get_str(args[2]);\n\n    void *sym = dlsym(self->handle, symname);\n    if (sym == NULL) {\n        mp_raise_OSError(MP_ENOENT);\n    }\n    return make_func(args[1], sym, args[3]);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(ffimod_func_obj, 4, 4, ffimod_func);\n\nstatic mp_obj_t mod_ffi_func(mp_obj_t rettype, mp_obj_t addr_in, mp_obj_t argtypes) {\n    void *addr = (void *)MP_OBJ_TO_PTR(mp_obj_int_get_truncated(addr_in));\n    return make_func(rettype, addr, argtypes);\n}\nMP_DEFINE_CONST_FUN_OBJ_3(mod_ffi_func_obj, mod_ffi_func);\n\nstatic void call_py_func(ffi_cif *cif, void *ret, void **args, void *user_data) {\n    mp_obj_t pyargs[cif->nargs];\n    mp_obj_fficallback_t *o = user_data;\n    mp_obj_t pyfunc = o->pyfunc;\n\n    for (uint i = 0; i < cif->nargs; i++) {\n        pyargs[i] = mp_obj_new_int(*(mp_int_t *)args[i]);\n    }\n    mp_obj_t res = mp_call_function_n_kw(pyfunc, cif->nargs, 0, pyargs);\n\n    if (res != mp_const_none) {\n        *(ffi_arg *)ret = mp_obj_int_get_truncated(res);\n    }\n}\n\nstatic void call_py_func_with_lock(ffi_cif *cif, void *ret, void **args, void *user_data) {\n    mp_obj_t pyargs[cif->nargs];\n    mp_obj_fficallback_t *o = user_data;\n    mp_obj_t pyfunc = o->pyfunc;\n    nlr_buf_t nlr;\n\n    #if MICROPY_ENABLE_SCHEDULER\n    mp_sched_lock();\n    #endif\n    gc_lock();\n\n    if (nlr_push(&nlr) == 0) {\n        for (uint i = 0; i < cif->nargs; i++) {\n            pyargs[i] = mp_obj_new_int(*(mp_int_t *)args[i]);\n        }\n        mp_obj_t res = mp_call_function_n_kw(pyfunc, cif->nargs, 0, pyargs);\n\n        if (res != mp_const_none) {\n            *(ffi_arg *)ret = mp_obj_int_get_truncated(res);\n        }\n        nlr_pop();\n    } else {\n         \n        mp_printf(MICROPY_ERROR_PRINTER, \"Uncaught exception in FFI callback\\n\");\n        mp_obj_print_exception(MICROPY_ERROR_PRINTER, MP_OBJ_FROM_PTR(nlr.ret_val));\n    }\n\n    gc_unlock();\n    #if MICROPY_ENABLE_SCHEDULER\n    mp_sched_unlock();\n    #endif\n}\n\nstatic mp_obj_t mod_ffi_callback(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n     \n    mp_obj_t rettype_in = pos_args[0];\n    mp_obj_t func_in = pos_args[1];\n    mp_obj_t paramtypes_in = pos_args[2];\n\n     \n    enum { ARG_lock };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_lock,        MP_ARG_KW_ONLY | MP_ARG_BOOL,  {.u_bool = false} },\n    };\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 3, pos_args + 3, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n    bool lock_in = args[ARG_lock].u_bool;\n\n    const char *rettype = mp_obj_str_get_str(rettype_in);\n\n    mp_int_t nparams = MP_OBJ_SMALL_INT_VALUE(mp_obj_len_maybe(paramtypes_in));\n    mp_obj_fficallback_t *o = mp_obj_malloc_var(mp_obj_fficallback_t, params, ffi_type *, nparams, &fficallback_type);\n\n    o->clo = ffi_closure_alloc(sizeof(ffi_closure), &o->func);\n\n    o->rettype = *rettype;\n    o->pyfunc = func_in;\n\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(paramtypes_in, &iter_buf);\n    mp_obj_t item;\n    int i = 0;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        o->params[i++] = get_ffi_type(item);\n    }\n\n    int res = ffi_prep_cif(&o->cif, FFI_DEFAULT_ABI, nparams, char2ffi_type(*rettype), o->params);\n    if (res != FFI_OK) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"error in ffi_prep_cif\"));\n    }\n\n    res = ffi_prep_closure_loc(o->clo, &o->cif,\n        lock_in? call_py_func_with_lock: call_py_func, o, o->func);\n    if (res != FFI_OK) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"ffi_prep_closure_loc\"));\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mod_ffi_callback_obj, 3, mod_ffi_callback);\n\nstatic mp_obj_t ffimod_var(mp_obj_t self_in, mp_obj_t vartype_in, mp_obj_t symname_in) {\n    mp_obj_ffimod_t *self = MP_OBJ_TO_PTR(self_in);\n    const char *rettype = mp_obj_str_get_str(vartype_in);\n    const char *symname = mp_obj_str_get_str(symname_in);\n\n    void *sym = dlsym(self->handle, symname);\n    if (sym == NULL) {\n        mp_raise_OSError(MP_ENOENT);\n    }\n    mp_obj_ffivar_t *o = mp_obj_malloc(mp_obj_ffivar_t, &ffivar_type);\n\n    o->var = sym;\n    o->type = *rettype;\n    return MP_OBJ_FROM_PTR(o);\n}\nMP_DEFINE_CONST_FUN_OBJ_3(ffimod_var_obj, ffimod_var);\n\nstatic mp_obj_t ffimod_addr(mp_obj_t self_in, mp_obj_t symname_in) {\n    mp_obj_ffimod_t *self = MP_OBJ_TO_PTR(self_in);\n    const char *symname = mp_obj_str_get_str(symname_in);\n\n    void *sym = dlsym(self->handle, symname);\n    if (sym == NULL) {\n        mp_raise_OSError(MP_ENOENT);\n    }\n    return mp_obj_new_int((uintptr_t)sym);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(ffimod_addr_obj, ffimod_addr);\n\nstatic mp_obj_t ffimod_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)n_args;\n    (void)n_kw;\n\n    const char *fname = NULL;\n    if (args[0] != mp_const_none) {\n        fname = mp_obj_str_get_str(args[0]);\n    }\n    void *mod = dlopen(fname, RTLD_NOW | RTLD_LOCAL);\n\n    if (mod == NULL) {\n        mp_raise_OSError(errno);\n    }\n    mp_obj_ffimod_t *o = mp_obj_malloc(mp_obj_ffimod_t, type);\n    o->handle = mod;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic const mp_rom_map_elem_t ffimod_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_func), MP_ROM_PTR(&ffimod_func_obj) },\n    { MP_ROM_QSTR(MP_QSTR_var), MP_ROM_PTR(&ffimod_var_obj) },\n    { MP_ROM_QSTR(MP_QSTR_addr), MP_ROM_PTR(&ffimod_addr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&ffimod_close_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(ffimod_locals_dict, ffimod_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    ffimod_type,\n    MP_QSTR_ffimod,\n    MP_TYPE_FLAG_NONE,\n    make_new, ffimod_make_new,\n    print, ffimod_print,\n    locals_dict, &ffimod_locals_dict\n    );\n\n \n\nstatic void ffifunc_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_ffifunc_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<ffifunc %p>\", self->func);\n}\n\nstatic unsigned long long ffi_get_int_value(mp_obj_t o) {\n    if (mp_obj_is_small_int(o)) {\n        return MP_OBJ_SMALL_INT_VALUE(o);\n    } else {\n        unsigned long long res;\n        mp_obj_int_to_bytes_impl(o, MP_ENDIANNESS_BIG, sizeof(res), (byte *)&res);\n        return res;\n    }\n}\n\nstatic ffi_union_t ffi_int_obj_to_ffi_union(mp_obj_t o, const char argtype) {\n    ffi_union_t ret;\n    if ((argtype | 0x20) == 'q') {\n        ret.Q = ffi_get_int_value(o);\n        return ret;\n    } else {\n        mp_uint_t val = mp_obj_int_get_truncated(o);\n        switch (argtype) {\n            case 'b':\n            case 'B':\n                ret.B = val;\n                break;\n            case 'h':\n            case 'H':\n                ret.H = val;\n                break;\n            case 'i':\n            case 'I':\n                ret.I = val;\n                break;\n            case 'l':\n            case 'L':\n                ret.L = val;\n                break;\n            default:\n                ret.ffi = val;\n                break;\n        }\n    }\n    return ret;\n}\n\nstatic mp_obj_t ffifunc_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)n_kw;\n    mp_obj_ffifunc_t *self = MP_OBJ_TO_PTR(self_in);\n    assert(n_kw == 0);\n    assert(n_args == self->cif.nargs);\n\n    ffi_union_t values[n_args];\n    void *valueptrs[n_args];\n    const char *argtype = self->argtypes;\n    for (uint i = 0; i < n_args; i++, argtype++) {\n        mp_obj_t a = args[i];\n        if (*argtype == 'O') {\n            values[i].ffi = (ffi_arg)(intptr_t)a;\n        #if MICROPY_PY_BUILTINS_FLOAT\n        } else if (*argtype == 'f') {\n            values[i].flt = mp_obj_get_float_to_f(a);\n        } else if (*argtype == 'd') {\n            values[i].dbl = mp_obj_get_float_to_d(a);\n        #endif\n        } else if (a == mp_const_none) {\n            values[i].ffi = 0;\n        } else if (mp_obj_is_int(a)) {\n            values[i] = ffi_int_obj_to_ffi_union(a, *argtype);\n        } else if (mp_obj_is_str(a)) {\n            const char *s = mp_obj_str_get_str(a);\n            values[i].ffi = (ffi_arg)(intptr_t)s;\n        } else if (MP_OBJ_TYPE_HAS_SLOT(((mp_obj_base_t *)MP_OBJ_TO_PTR(a))->type, buffer)) {\n            mp_obj_base_t *o = (mp_obj_base_t *)MP_OBJ_TO_PTR(a);\n            mp_buffer_info_t bufinfo;\n            int ret = MP_OBJ_TYPE_GET_SLOT(o->type, buffer)(MP_OBJ_FROM_PTR(o), &bufinfo, MP_BUFFER_READ);  \n            if (ret != 0) {\n                goto error;\n            }\n            values[i].ffi = (ffi_arg)(intptr_t)bufinfo.buf;\n        } else if (mp_obj_is_type(a, &fficallback_type)) {\n            mp_obj_fficallback_t *p = MP_OBJ_TO_PTR(a);\n            values[i].ffi = (ffi_arg)(intptr_t)p->func;\n        } else {\n            goto error;\n        }\n        valueptrs[i] = &values[i];\n    }\n\n    ffi_union_t retval;\n    ffi_call(&self->cif, self->func, &retval, valueptrs);\n    return return_ffi_value(&retval, self->rettype);\n\nerror:\n    mp_raise_TypeError(MP_ERROR_TEXT(\"don't know how to pass object to native function\"));\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    ffifunc_type,\n    MP_QSTR_ffifunc,\n    MP_TYPE_FLAG_NONE,\n    print, ffifunc_print,\n    call, ffifunc_call\n    );\n\n \n\nstatic void fficallback_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_fficallback_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<fficallback %p>\", self->func);\n}\n\nstatic mp_obj_t fficallback_cfun(mp_obj_t self_in) {\n    mp_obj_fficallback_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_int_from_ull((uintptr_t)self->func);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(fficallback_cfun_obj, fficallback_cfun);\n\nstatic const mp_rom_map_elem_t fficallback_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_cfun), MP_ROM_PTR(&fficallback_cfun_obj) }\n};\nstatic MP_DEFINE_CONST_DICT(fficallback_locals_dict, fficallback_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    fficallback_type,\n    MP_QSTR_fficallback,\n    MP_TYPE_FLAG_NONE,\n    print, fficallback_print,\n    locals_dict, &fficallback_locals_dict\n    );\n\n \n\nstatic void ffivar_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_ffivar_t *self = MP_OBJ_TO_PTR(self_in);\n     \n    mp_printf(print, \"<ffivar @%p: 0x%x>\", self->var, *(int *)self->var);\n}\n\nstatic mp_obj_t ffivar_get(mp_obj_t self_in) {\n    mp_obj_ffivar_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_binary_get_val_array(self->type, self->var, 0);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(ffivar_get_obj, ffivar_get);\n\nstatic mp_obj_t ffivar_set(mp_obj_t self_in, mp_obj_t val_in) {\n    mp_obj_ffivar_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_binary_set_val_array(self->type, self->var, 0, val_in);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_2(ffivar_set_obj, ffivar_set);\n\nstatic const mp_rom_map_elem_t ffivar_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_get), MP_ROM_PTR(&ffivar_get_obj) },\n    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&ffivar_set_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(ffivar_locals_dict, ffivar_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    ffivar_type,\n    MP_QSTR_ffivar,\n    MP_TYPE_FLAG_NONE,\n    print, ffivar_print,\n    locals_dict, &ffivar_locals_dict\n    );\n\n\n\n \n\nstatic mp_obj_t mod_ffi_open(size_t n_args, const mp_obj_t *args) {\n    return ffimod_make_new(&ffimod_type, n_args, 0, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_ffi_open_obj, 1, 2, mod_ffi_open);\n\nstatic mp_obj_t mod_ffi_as_bytearray(mp_obj_t ptr, mp_obj_t size) {\n    return mp_obj_new_bytearray_by_ref(mp_obj_int_get_truncated(size), (void *)(uintptr_t)mp_obj_int_get_truncated(ptr));\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mod_ffi_as_bytearray_obj, mod_ffi_as_bytearray);\n\nstatic const mp_rom_map_elem_t mp_module_ffi_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ffi) },\n    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mod_ffi_open_obj) },\n    { MP_ROM_QSTR(MP_QSTR_callback), MP_ROM_PTR(&mod_ffi_callback_obj) },\n    { MP_ROM_QSTR(MP_QSTR_func), MP_ROM_PTR(&mod_ffi_func_obj) },\n    { MP_ROM_QSTR(MP_QSTR_as_bytearray), MP_ROM_PTR(&mod_ffi_as_bytearray_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_ffi_globals, mp_module_ffi_globals_table);\n\nconst mp_obj_module_t mp_module_ffi = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_ffi_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_ffi, mp_module_ffi);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}