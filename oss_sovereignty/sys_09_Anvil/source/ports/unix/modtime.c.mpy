{
  "module_name": "modtime.c",
  "hash_id": "9464ac66b89277e6faf872d3a425abcb992a0eb41184dba32e8b1c36d913896c",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/modtime.c",
  "human_readable_source": " \n\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <time.h>\n#include <sys/time.h>\n#include <math.h>\n\n#include \"py/mphal.h\"\n#include \"py/runtime.h\"\n\n#ifdef _WIN32\nstatic inline int msec_sleep_tv(struct timeval *tv) {\n    msec_sleep(tv->tv_sec * 1000.0 + tv->tv_usec / 1000.0);\n    return 0;\n}\n#define sleep_select(a, b, c, d, e) msec_sleep_tv((e))\n#else\n#define sleep_select select\n#endif\n\n\n#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)\n#define MP_REMOVE_BRACKETSA(x)\n#define MP_REMOVE_BRACKETSB(x) MP_REMOVE_BRACKETSA x\n#define MP_REMOVE_BRACKETSC(x) MP_REMOVE_BRACKETSB x\n#define MP_CLOCKS_PER_SEC MP_REMOVE_BRACKETSC(CLOCKS_PER_SEC)\n#else\n#define MP_CLOCKS_PER_SEC CLOCKS_PER_SEC\n#endif\n\n#if defined(MP_CLOCKS_PER_SEC)\n#define CLOCK_DIV (MP_CLOCKS_PER_SEC / MICROPY_FLOAT_CONST(1000.0))\n#else\n#error Unsupported clock() implementation\n#endif\n\nstatic mp_obj_t mp_time_time_get(void) {\n    #if MICROPY_PY_BUILTINS_FLOAT && MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    mp_float_t val = tv.tv_sec + (mp_float_t)tv.tv_usec / 1000000;\n    return mp_obj_new_float(val);\n    #else\n    return mp_obj_new_int((mp_int_t)time(NULL));\n    #endif\n}\n\n\nstatic mp_obj_t mod_time_clock(void) {\n    #if MICROPY_PY_BUILTINS_FLOAT\n    \n    \n    \n    return mp_obj_new_float((clock() / 1000) / CLOCK_DIV);\n    #else\n    return mp_obj_new_int((mp_int_t)clock());\n    #endif\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mod_time_clock_obj, mod_time_clock);\n\nstatic mp_obj_t mp_time_sleep(mp_obj_t arg) {\n    #if MICROPY_PY_BUILTINS_FLOAT\n    struct timeval tv;\n    mp_float_t val = mp_obj_get_float(arg);\n    mp_float_t ipart;\n    tv.tv_usec = (time_t)MICROPY_FLOAT_C_FUN(round)(MICROPY_FLOAT_C_FUN(modf)(val, &ipart) * MICROPY_FLOAT_CONST(1000000.));\n    tv.tv_sec = (suseconds_t)ipart;\n    int res;\n    while (1) {\n        MP_THREAD_GIL_EXIT();\n        res = sleep_select(0, NULL, NULL, NULL, &tv);\n        MP_THREAD_GIL_ENTER();\n        #if MICROPY_SELECT_REMAINING_TIME\n        \n        \n        if (res != -1 || errno != EINTR) {\n            break;\n        }\n        mp_handle_pending(true);\n        \n        #else\n        break;\n        #endif\n    }\n    RAISE_ERRNO(res, errno);\n    #else\n    int seconds = mp_obj_get_int(arg);\n    for (;;) {\n        MP_THREAD_GIL_EXIT();\n        seconds = sleep(seconds);\n        MP_THREAD_GIL_ENTER();\n        if (seconds == 0) {\n            break;\n        }\n        mp_handle_pending(true);\n    }\n    #endif\n    return mp_const_none;\n}\n\nstatic mp_obj_t mod_time_gm_local_time(size_t n_args, const mp_obj_t *args, struct tm *(*time_func)(const time_t *timep)) {\n    time_t t;\n    if (n_args == 0) {\n        t = time(NULL);\n    } else {\n        #if MICROPY_PY_BUILTINS_FLOAT && MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n        mp_float_t val = mp_obj_get_float(args[0]);\n        t = (time_t)MICROPY_FLOAT_C_FUN(trunc)(val);\n        #else\n        t = mp_obj_get_int(args[0]);\n        #endif\n    }\n    struct tm *tm = time_func(&t);\n\n    mp_obj_t ret = mp_obj_new_tuple(9, NULL);\n\n    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(ret);\n    tuple->items[0] = MP_OBJ_NEW_SMALL_INT(tm->tm_year + 1900);\n    tuple->items[1] = MP_OBJ_NEW_SMALL_INT(tm->tm_mon + 1);\n    tuple->items[2] = MP_OBJ_NEW_SMALL_INT(tm->tm_mday);\n    tuple->items[3] = MP_OBJ_NEW_SMALL_INT(tm->tm_hour);\n    tuple->items[4] = MP_OBJ_NEW_SMALL_INT(tm->tm_min);\n    tuple->items[5] = MP_OBJ_NEW_SMALL_INT(tm->tm_sec);\n    int wday = tm->tm_wday - 1;\n    if (wday < 0) {\n        wday = 6;\n    }\n    tuple->items[6] = MP_OBJ_NEW_SMALL_INT(wday);\n    tuple->items[7] = MP_OBJ_NEW_SMALL_INT(tm->tm_yday + 1);\n    tuple->items[8] = MP_OBJ_NEW_SMALL_INT(tm->tm_isdst);\n\n    return ret;\n}\n\nstatic mp_obj_t mod_time_gmtime(size_t n_args, const mp_obj_t *args) {\n    return mod_time_gm_local_time(n_args, args, gmtime);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_time_gmtime_obj, 0, 1, mod_time_gmtime);\n\nstatic mp_obj_t mod_time_localtime(size_t n_args, const mp_obj_t *args) {\n    return mod_time_gm_local_time(n_args, args, localtime);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_time_localtime_obj, 0, 1, mod_time_localtime);\n\nstatic mp_obj_t mod_time_mktime(mp_obj_t tuple) {\n    size_t len;\n    mp_obj_t *elem;\n    mp_obj_get_array(tuple, &len, &elem);\n\n    \n    if (len < 8 || len > 9) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"mktime needs a tuple of length 8 or 9\"));\n    }\n\n    struct tm time = {\n        .tm_year = mp_obj_get_int(elem[0]) - 1900,\n        .tm_mon = mp_obj_get_int(elem[1]) - 1,\n        .tm_mday = mp_obj_get_int(elem[2]),\n        .tm_hour = mp_obj_get_int(elem[3]),\n        .tm_min = mp_obj_get_int(elem[4]),\n        .tm_sec = mp_obj_get_int(elem[5]),\n    };\n    if (len == 9) {\n        time.tm_isdst = mp_obj_get_int(elem[8]);\n    } else {\n        time.tm_isdst = -1; \n    }\n    time_t ret = mktime(&time);\n    if (ret == -1) {\n        mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"invalid mktime usage\"));\n    }\n    return mp_obj_new_int(ret);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mod_time_mktime_obj, mod_time_mktime);\n\n#define MICROPY_PY_TIME_EXTRA_GLOBALS \\\n    { MP_ROM_QSTR(MP_QSTR_clock), MP_ROM_PTR(&mod_time_clock_obj) }, \\\n    { MP_ROM_QSTR(MP_QSTR_gmtime), MP_ROM_PTR(&mod_time_gmtime_obj) }, \\\n    { MP_ROM_QSTR(MP_QSTR_localtime), MP_ROM_PTR(&mod_time_localtime_obj) }, \\\n    { MP_ROM_QSTR(MP_QSTR_mktime), MP_ROM_PTR(&mod_time_mktime_obj) },\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}