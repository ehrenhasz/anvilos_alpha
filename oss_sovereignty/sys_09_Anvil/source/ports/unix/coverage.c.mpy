{
  "module_name": "coverage.c",
  "hash_id": "981ef8a829fc61bc894438e8e9c0b7850a70a8c75f52e94db17927fb27422ddb",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/coverage.c",
  "human_readable_source": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"py/obj.h\"\n#include \"py/objfun.h\"\n#include \"py/objstr.h\"\n#include \"py/runtime.h\"\n#include \"py/gc.h\"\n#include \"py/repl.h\"\n#include \"py/mpz.h\"\n#include \"py/builtin.h\"\n#include \"py/emit.h\"\n#include \"py/formatfloat.h\"\n#include \"py/ringbuf.h\"\n#include \"py/pairheap.h\"\n#include \"py/stream.h\"\n#include \"py/binary.h\"\n#include \"py/bc.h\"\n\n\n\n#if defined(MICROPY_UNIX_COVERAGE)\n\n\ntypedef struct _mp_obj_streamtest_t {\n    mp_obj_base_t base;\n    uint8_t *buf;\n    size_t len;\n    size_t pos;\n    int error_code;\n} mp_obj_streamtest_t;\n\nstatic mp_obj_t stest_set_buf(mp_obj_t o_in, mp_obj_t buf_in) {\n    mp_obj_streamtest_t *o = MP_OBJ_TO_PTR(o_in);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(buf_in, &bufinfo, MP_BUFFER_READ);\n    o->buf = m_new(uint8_t, bufinfo.len);\n    memcpy(o->buf, bufinfo.buf, bufinfo.len);\n    o->len = bufinfo.len;\n    o->pos = 0;\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(stest_set_buf_obj, stest_set_buf);\n\nstatic mp_obj_t stest_set_error(mp_obj_t o_in, mp_obj_t err_in) {\n    mp_obj_streamtest_t *o = MP_OBJ_TO_PTR(o_in);\n    o->error_code = mp_obj_get_int(err_in);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(stest_set_error_obj, stest_set_error);\n\nstatic mp_uint_t stest_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_streamtest_t *o = MP_OBJ_TO_PTR(o_in);\n    if (o->pos < o->len) {\n        if (size > o->len - o->pos) {\n            size = o->len - o->pos;\n        }\n        memcpy(buf, o->buf + o->pos, size);\n        o->pos += size;\n        return size;\n    } else if (o->error_code == 0) {\n        return 0;\n    } else {\n        *errcode = o->error_code;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic mp_uint_t stest_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_streamtest_t *o = MP_OBJ_TO_PTR(o_in);\n    (void)buf;\n    (void)size;\n    *errcode = o->error_code;\n    return MP_STREAM_ERROR;\n}\n\nstatic mp_uint_t stest_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mp_obj_streamtest_t *o = MP_OBJ_TO_PTR(o_in);\n    (void)arg;\n    (void)request;\n    (void)errcode;\n    if (o->error_code != 0) {\n        *errcode = o->error_code;\n        return MP_STREAM_ERROR;\n    }\n    return 0;\n}\n\nstatic const mp_rom_map_elem_t rawfile_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_set_buf), MP_ROM_PTR(&stest_set_buf_obj) },\n    { MP_ROM_QSTR(MP_QSTR_set_error), MP_ROM_PTR(&stest_set_error_obj) },\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_read1), MP_ROM_PTR(&mp_stream_read1_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write1), MP_ROM_PTR(&mp_stream_write1_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ioctl), MP_ROM_PTR(&mp_stream_ioctl_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(rawfile_locals_dict, rawfile_locals_dict_table);\n\nstatic const mp_stream_p_t fileio_stream_p = {\n    .read = stest_read,\n    .write = stest_write,\n    .ioctl = stest_ioctl,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_stest_fileio,\n    MP_QSTR_stest_fileio,\n    MP_TYPE_FLAG_NONE,\n    protocol, &fileio_stream_p,\n    locals_dict, &rawfile_locals_dict\n    );\n\n\nstatic mp_uint_t stest_read2(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {\n    (void)o_in;\n    (void)buf;\n    (void)size;\n    *errcode = MP_EAGAIN;\n    return MP_STREAM_ERROR;\n}\n\nstatic const mp_rom_map_elem_t rawfile_locals_dict_table2[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(rawfile_locals_dict2, rawfile_locals_dict_table2);\n\nstatic const mp_stream_p_t textio_stream_p2 = {\n    .read = stest_read2,\n    .write = NULL,\n    .is_text = true,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_stest_textio2,\n    MP_QSTR_stest_textio2,\n    MP_TYPE_FLAG_NONE,\n    protocol, &textio_stream_p2,\n    locals_dict, &rawfile_locals_dict2\n    );\n\n\nstatic const mp_obj_str_t str_no_hash_obj = {{&mp_type_str}, 0, 10, (const byte *)\"0123456789\"};\nstatic const mp_obj_str_t bytes_no_hash_obj = {{&mp_type_bytes}, 0, 10, (const byte *)\"0123456789\"};\n\nstatic int pairheap_lt(mp_pairheap_t *a, mp_pairheap_t *b) {\n    return (uintptr_t)a < (uintptr_t)b;\n}\n\n\nstatic void pairheap_test(size_t nops, int *ops) {\n    mp_pairheap_t node[8];\n    for (size_t i = 0; i < MP_ARRAY_SIZE(node); ++i) {\n        mp_pairheap_init_node(pairheap_lt, &node[i]);\n    }\n    mp_pairheap_t *heap = mp_pairheap_new(pairheap_lt);\n    mp_printf(&mp_plat_print, \"create:\");\n    for (size_t i = 0; i < nops; ++i) {\n        if (ops[i] >= 0) {\n            heap = mp_pairheap_push(pairheap_lt, heap, &node[ops[i]]);\n        } else {\n            heap = mp_pairheap_delete(pairheap_lt, heap, &node[-ops[i]]);\n        }\n        if (mp_pairheap_is_empty(pairheap_lt, heap)) {\n            mp_printf(&mp_plat_print, \" -\");\n        } else {\n            mp_printf(&mp_plat_print, \" %d\", mp_pairheap_peek(pairheap_lt, heap) - &node[0]);\n            ;\n        }\n    }\n    mp_printf(&mp_plat_print, \"\\npop all:\");\n    while (!mp_pairheap_is_empty(pairheap_lt, heap)) {\n        mp_printf(&mp_plat_print, \" %d\", mp_pairheap_peek(pairheap_lt, heap) - &node[0]);\n        ;\n        heap = mp_pairheap_pop(pairheap_lt, heap);\n    }\n    mp_printf(&mp_plat_print, \"\\n\");\n}\n\n\nstatic mp_obj_t extra_coverage(void) {\n    \n    {\n        mp_printf(&mp_plat_print, \"# mp_printf\\n\");\n        mp_printf(&mp_plat_print, \"%d %+d % d\\n\", -123, 123, 123); \n        mp_printf(&mp_plat_print, \"%05d\\n\", -123); \n        mp_printf(&mp_plat_print, \"%ld\\n\", 123); \n        mp_printf(&mp_plat_print, \"%lx\\n\", 0x123); \n        mp_printf(&mp_plat_print, \"%X\\n\", 0x1abcdef); \n        mp_printf(&mp_plat_print, \"%.2s %.3s '%4.4s' '%5.5q' '%.3q'\\n\", \"abc\", \"abc\", \"abc\", MP_QSTR_True, MP_QSTR_True); \n        mp_printf(&mp_plat_print, \"%.*s\\n\", -1, \"abc\"); \n        mp_printf(&mp_plat_print, \"%b %b\\n\", 0, 1); \n        #ifndef NDEBUG\n        mp_printf(&mp_plat_print, \"%s\\n\", NULL); \n        #else\n        mp_printf(&mp_plat_print, \"(null)\\n\"); \n        #endif\n        mp_printf(&mp_plat_print, \"%d\\n\", 0x80000000); \n        mp_printf(&mp_plat_print, \"%u\\n\", 0x80000000); \n        mp_printf(&mp_plat_print, \"%x\\n\", 0x80000000); \n        mp_printf(&mp_plat_print, \"%X\\n\", 0x80000000); \n        mp_printf(&mp_plat_print, \"abc\\n%\"); \n        mp_printf(&mp_plat_print, \"%%\\n\"); \n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# GC\\n\");\n\n        \n        gc_lock();\n        gc_free(NULL);\n        gc_unlock();\n\n        \n        void *p = gc_alloc(4, false);\n        mp_printf(&mp_plat_print, \"%p\\n\", gc_realloc(p, 0, false));\n\n        \n        mp_printf(&mp_plat_print, \"%p\\n\", gc_nbytes(NULL));\n    }\n\n    \n    \n    {\n        mp_printf(&mp_plat_print, \"# GC part 2\\n\");\n\n        \n        assert(MP_STATE_THREAD(gc_lock_depth) == 0);\n        mp_state_mem_t mp_state_mem_orig = mp_state_ctx.mem;\n\n        \n        unsigned heap_size = 64 * MICROPY_BYTES_PER_GC_BLOCK;\n        for (unsigned j = 0; j < 256 * MP_BYTES_PER_OBJ_WORD; ++j) {\n            char *heap = calloc(heap_size, 1);\n            gc_init(heap, heap + heap_size);\n\n            m_malloc(MICROPY_BYTES_PER_GC_BLOCK);\n            void *o = gc_alloc(MICROPY_BYTES_PER_GC_BLOCK, GC_ALLOC_FLAG_HAS_FINALISER);\n            ((mp_obj_base_t *)o)->type = NULL; \n            for (unsigned i = 0; i < heap_size / MICROPY_BYTES_PER_GC_BLOCK; ++i) {\n                void *p = m_malloc_maybe(MICROPY_BYTES_PER_GC_BLOCK);\n                if (!p) {\n                    break;\n                }\n                *(void **)p = o;\n                o = p;\n            }\n            gc_collect();\n            free(heap);\n            heap_size += MICROPY_BYTES_PER_GC_BLOCK / 16;\n        }\n        mp_printf(&mp_plat_print, \"pass\\n\");\n\n        \n        mp_state_ctx.mem = mp_state_mem_orig;\n    }\n\n    \n    {\n        #define NUM_PTRS (8)\n        #define NUM_BYTES (128)\n        #define FLIP_POINTER(p) ((uint8_t *)((uintptr_t)(p) ^ 0x0f))\n\n        mp_printf(&mp_plat_print, \"# tracked allocation\\n\");\n        mp_printf(&mp_plat_print, \"m_tracked_head = %p\\n\", MP_STATE_VM(m_tracked_head));\n\n        uint8_t *ptrs[NUM_PTRS];\n\n        \n        for (size_t i = 0; i < NUM_PTRS; ++i) {\n            ptrs[i] = m_tracked_calloc(1, NUM_BYTES);\n            bool all_zero = true;\n            for (size_t j = 0; j < NUM_BYTES; ++j) {\n                if (ptrs[i][j] != 0) {\n                    all_zero = false;\n                    break;\n                }\n                ptrs[i][j] = j;\n            }\n            mp_printf(&mp_plat_print, \"%d %d\\n\", i, all_zero);\n\n            \n            ptrs[i] = FLIP_POINTER(ptrs[i]);\n            gc_collect();\n        }\n\n        \n        for (size_t i = 0; i < NUM_PTRS; ++i) {\n            bool correct_contents = true;\n            for (size_t j = 0; j < NUM_BYTES; ++j) {\n                if (FLIP_POINTER(ptrs[i])[j] != j) {\n                    correct_contents = false;\n                    break;\n                }\n            }\n            mp_printf(&mp_plat_print, \"%d %d\\n\", i, correct_contents);\n        }\n\n        \n        for (size_t i = 0; i < NUM_PTRS; ++i) {\n            m_tracked_free(FLIP_POINTER(ptrs[i]));\n        }\n\n        mp_printf(&mp_plat_print, \"m_tracked_head = %p\\n\", MP_STATE_VM(m_tracked_head));\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# vstr\\n\");\n        vstr_t *vstr = vstr_new(16);\n        vstr_hint_size(vstr, 32);\n        vstr_add_str(vstr, \"ts\");\n        vstr_ins_byte(vstr, 1, 'e');\n        vstr_ins_char(vstr, 3, 't');\n        vstr_ins_char(vstr, 10, 's');\n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)vstr->len, vstr->buf);\n\n        vstr_cut_head_bytes(vstr, 2);\n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)vstr->len, vstr->buf);\n\n        vstr_cut_tail_bytes(vstr, 10);\n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)vstr->len, vstr->buf);\n\n        vstr_printf(vstr, \"t%cst\", 'e');\n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)vstr->len, vstr->buf);\n\n        vstr_cut_out_bytes(vstr, 3, 10);\n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)vstr->len, vstr->buf);\n\n        VSTR_FIXED(fix, 4);\n        nlr_buf_t nlr;\n        if (nlr_push(&nlr) == 0) {\n            vstr_add_str(&fix, \"large\");\n            nlr_pop();\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n\n        fix.len = fix.alloc;\n        if (nlr_push(&nlr) == 0) {\n            vstr_null_terminated_str(&fix);\n            nlr_pop();\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# repl\\n\");\n\n        const char *str;\n        size_t len = mp_repl_autocomplete(\"__n\", 3, &mp_plat_print, &str); \n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)len, str);\n\n        len = mp_repl_autocomplete(\"im\", 2,  &mp_plat_print, &str); \n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)len, str);\n        mp_repl_autocomplete(\"import \", 7,  &mp_plat_print, &str); \n        len = mp_repl_autocomplete(\"import ti\", 9,  &mp_plat_print, &str); \n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)len, str);\n        mp_repl_autocomplete(\"import m\", 8,  &mp_plat_print, &str); \n\n        mp_store_global(MP_QSTR_sys, mp_import_name(MP_QSTR_sys, mp_const_none, MP_OBJ_NEW_SMALL_INT(0)));\n        mp_repl_autocomplete(\"sys.\", 4, &mp_plat_print, &str); \n        len = mp_repl_autocomplete(\"sys.impl\", 8, &mp_plat_print, &str); \n        mp_printf(&mp_plat_print, \"%.*s\\n\", (int)len, str);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# attrtuple\\n\");\n\n        static const qstr fields[] = {MP_QSTR_start, MP_QSTR_stop, MP_QSTR_step};\n        static const mp_obj_t items[] = {MP_OBJ_NEW_SMALL_INT(1), MP_OBJ_NEW_SMALL_INT(2), MP_OBJ_NEW_SMALL_INT(3)};\n        mp_obj_print_helper(&mp_plat_print, mp_obj_new_attrtuple(fields, 3, items), PRINT_REPR);\n        mp_printf(&mp_plat_print, \"\\n\");\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# str\\n\");\n\n        \n        mp_printf(&mp_plat_print, \"%d\\n\", mp_obj_is_qstr(mp_obj_str_intern(mp_obj_new_str(\"intern me\", 9))));\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# bytearray\\n\");\n\n        \n        mp_buffer_info_t bufinfo;\n        mp_get_buffer_raise(mp_obj_new_bytearray(4, \"data\"), &bufinfo, MP_BUFFER_RW);\n        mp_printf(&mp_plat_print, \"%.*s\\n\", bufinfo.len, bufinfo.buf);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# mpz\\n\");\n\n        mp_uint_t value;\n        mpz_t mpz;\n        mpz_init_zero(&mpz);\n\n        \n        mpz_set_from_int(&mpz, 12345678);\n        mp_printf(&mp_plat_print, \"%d\\n\", mpz_as_uint_checked(&mpz, &value));\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n\n        \n        mpz_set_from_int(&mpz, -1);\n        mp_printf(&mp_plat_print, \"%d\\n\", mpz_as_uint_checked(&mpz, &value));\n\n        \n        mpz_set_from_int(&mpz, 1);\n        mpz_shl_inpl(&mpz, &mpz, 70);\n        mp_printf(&mp_plat_print, \"%d\\n\", mpz_as_uint_checked(&mpz, &value));\n\n        \n        mpz_set_from_float(&mpz, 1.0 / 0.0);\n        mpz_as_uint_checked(&mpz, &value);\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n\n        \n        mpz_set_from_float(&mpz, 0);\n        mpz_as_uint_checked(&mpz, &value);\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n\n        \n        mpz_set_from_float(&mpz, 1e-10);\n        mpz_as_uint_checked(&mpz, &value);\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n\n        \n        mpz_set_from_float(&mpz, 1.5);\n        mpz_as_uint_checked(&mpz, &value);\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n\n        \n        mpz_set_from_float(&mpz, 12345);\n        mpz_as_uint_checked(&mpz, &value);\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n\n        \n        mpz_t mpz2;\n        mpz_set_from_int(&mpz, 2);\n        mpz_init_from_int(&mpz2, 3);\n        mpz_mul_inpl(&mpz, &mpz2, &mpz);\n        mpz_as_uint_checked(&mpz, &value);\n        mp_printf(&mp_plat_print, \"%d\\n\", (int)value);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# runtime utils\\n\");\n\n        \n        mp_call_function_1_protected(MP_OBJ_FROM_PTR(&mp_builtin_abs_obj), MP_OBJ_NEW_SMALL_INT(1));\n        \n        mp_call_function_1_protected(MP_OBJ_FROM_PTR(&mp_builtin_abs_obj), mp_obj_new_str(\"abc\", 3));\n\n        \n        mp_call_function_2_protected(MP_OBJ_FROM_PTR(&mp_builtin_divmod_obj), MP_OBJ_NEW_SMALL_INT(1), MP_OBJ_NEW_SMALL_INT(1));\n        \n        mp_call_function_2_protected(MP_OBJ_FROM_PTR(&mp_builtin_divmod_obj), mp_obj_new_str(\"abc\", 3), mp_obj_new_str(\"abc\", 3));\n\n        \n        mp_printf(&mp_plat_print, \"%d\\n\", (int)mp_obj_int_get_uint_checked(MP_OBJ_NEW_SMALL_INT(1)));\n\n        \n        mp_printf(&mp_plat_print, \"%d\\n\", (int)mp_obj_int_get_uint_checked(mp_obj_new_int_from_ll(2)));\n\n        \n        nlr_buf_t nlr;\n        if (nlr_push(&nlr) == 0) {\n            mp_obj_int_get_uint_checked(MP_OBJ_NEW_SMALL_INT(-1));\n            nlr_pop();\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n\n        \n        if (nlr_push(&nlr) == 0) {\n            mp_obj_int_get_uint_checked(mp_obj_new_int_from_ll(-2));\n            nlr_pop();\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n\n        \n        mp_obj_print_exception(&mp_plat_print, mp_obj_new_exception_args(&mp_type_ValueError, 0, NULL));\n    }\n\n    \n    {\n        mp_emitter_warning(MP_PASS_CODE_SIZE, \"test\");\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# format float\\n\");\n\n        \n        char buf[5];\n        mp_format_float(1, buf, sizeof(buf), 'g', 0, '+');\n        mp_printf(&mp_plat_print, \"%s\\n\", buf);\n\n        \n        \n        char buf2[8];\n        mp_format_float(1, buf2, sizeof(buf2), 'g', 0, '+');\n        mp_printf(&mp_plat_print, \"%s\\n\", buf2);\n\n        \n        mp_format_float(1, buf2, sizeof(buf2), 'e', 0, '+');\n        mp_printf(&mp_plat_print, \"%s\\n\", buf2);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# binary\\n\");\n\n        \n        float far[1];\n        double dar[1];\n        mp_binary_set_val_array_from_int('f', far, 0, 123);\n        mp_printf(&mp_plat_print, \"%.0f\\n\", (double)far[0]);\n        mp_binary_set_val_array_from_int('d', dar, 0, 456);\n        mp_printf(&mp_plat_print, \"%.0lf\\n\", dar[0]);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# VM\\n\");\n\n        \n        mp_module_context_t context;\n        mp_obj_fun_bc_t fun_bc;\n        fun_bc.context = &context;\n        fun_bc.child_table = NULL;\n        fun_bc.bytecode = (const byte *)\"\\x01\"; \n        mp_code_state_t *code_state = m_new_obj_var(mp_code_state_t, state, mp_obj_t, 1);\n        code_state->fun_bc = &fun_bc;\n        code_state->ip = (const byte *)\"\\x00\"; \n        code_state->sp = &code_state->state[0];\n        code_state->exc_sp_idx = 0;\n        code_state->old_globals = NULL;\n        mp_vm_return_kind_t ret = mp_execute_bytecode(code_state, MP_OBJ_NULL);\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ret, mp_obj_get_type(code_state->state[0]) == &mp_type_NotImplementedError);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# scheduler\\n\");\n\n        \n        mp_sched_lock();\n\n        \n        for (int i = 0; i < 5; ++i) {\n            mp_printf(&mp_plat_print, \"sched(%d)=%d\\n\", i, mp_sched_schedule(MP_OBJ_FROM_PTR(&mp_builtin_print_obj), MP_OBJ_NEW_SMALL_INT(i)));\n        }\n\n        \n        mp_sched_lock();\n        mp_sched_unlock();\n\n        \n        mp_handle_pending(true);\n\n        \n        mp_sched_unlock();\n        mp_printf(&mp_plat_print, \"unlocked\\n\");\n\n        \n        mp_event_wait_indefinite(); \n        while (mp_sched_num_pending()) {\n            mp_event_wait_ms(1);\n        }\n\n        \n        mp_sched_keyboard_interrupt();\n        nlr_buf_t nlr;\n        if (nlr_push(&nlr) == 0) {\n            mp_handle_pending(true);\n            nlr_pop();\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n\n        \n        mp_sched_keyboard_interrupt();\n        mp_sched_keyboard_interrupt();\n        mp_handle_pending(false);\n\n        \n        mp_sched_schedule(MP_OBJ_FROM_PTR(&mp_builtin_print_obj), MP_OBJ_NEW_SMALL_INT(10));\n        mp_sched_keyboard_interrupt();\n        if (nlr_push(&nlr) == 0) {\n            mp_handle_pending(true);\n            nlr_pop();\n        } else {\n            mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n        mp_handle_pending(true);\n    }\n\n    \n    {\n        byte buf[100];\n        ringbuf_t ringbuf = {buf, sizeof(buf), 0, 0};\n\n        mp_printf(&mp_plat_print, \"# ringbuf\\n\");\n\n        \n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n        ringbuf_put(&ringbuf, 22);\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_get(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n\n        \n        ringbuf_put16(&ringbuf, 0xaa55);\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n        mp_printf(&mp_plat_print, \"%04x\\n\", ringbuf_get16(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n\n        \n        for (int i = 0; i < 99; ++i) {\n            ringbuf_put(&ringbuf, i);\n        }\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_put16(&ringbuf, 0x11bb));\n        \n        ringbuf_get(&ringbuf);\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_put16(&ringbuf, 0x3377));\n        ringbuf_get(&ringbuf);\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_put16(&ringbuf, 0xcc99));\n        for (int i = 0; i < 97; ++i) {\n            ringbuf_get(&ringbuf);\n        }\n        mp_printf(&mp_plat_print, \"%04x\\n\", ringbuf_get16(&ringbuf));\n        mp_printf(&mp_plat_print, \"%d %d\\n\", ringbuf_free(&ringbuf), ringbuf_avail(&ringbuf));\n\n        \n        ringbuf.iput = 0;\n        ringbuf.iget = 0;\n        for (int i = 0; i < 99; ++i) {\n            ringbuf_put(&ringbuf, i);\n            ringbuf_get(&ringbuf);\n        }\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_put16(&ringbuf, 0x11bb));\n        mp_printf(&mp_plat_print, \"%04x\\n\", ringbuf_get16(&ringbuf));\n\n        \n        ringbuf.iput = 0;\n        ringbuf.iget = 0;\n        for (int i = 0; i < 98; ++i) {\n            ringbuf_put(&ringbuf, i);\n            ringbuf_get(&ringbuf);\n        }\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_put16(&ringbuf, 0x22ff));\n        mp_printf(&mp_plat_print, \"%04x\\n\", ringbuf_get16(&ringbuf));\n\n        \n        ringbuf.iput = 0;\n        ringbuf.iget = 0;\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_get16(&ringbuf));\n\n        \n        ringbuf.iput = 0;\n        ringbuf.iget = 0;\n        ringbuf_put(&ringbuf, 0xaa);\n        mp_printf(&mp_plat_print, \"%d\\n\", ringbuf_get16(&ringbuf));\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# pairheap\\n\");\n\n        \n        int t0[] = {0, 2, 1, 3};\n        pairheap_test(MP_ARRAY_SIZE(t0), t0);\n\n        \n        int t1[] = {7, 6, 5, 4, 3, 2, 1, 0};\n        pairheap_test(MP_ARRAY_SIZE(t1), t1);\n\n        \n        int t2[] = {1, -1, -1, 1, 2, -2, 2, 3, -3};\n        pairheap_test(MP_ARRAY_SIZE(t2), t2);\n\n        \n        int t3[] = {1, 2, 3, 4, -1, -3};\n        pairheap_test(MP_ARRAY_SIZE(t3), t3);\n\n        \n        int t4[] = {1, 2, 3, 4, -2};\n        pairheap_test(MP_ARRAY_SIZE(t4), t4);\n\n        \n        int t5[] = {3, 4, 5, 1, 2, -3};\n        pairheap_test(MP_ARRAY_SIZE(t5), t5);\n    }\n\n    \n    {\n        mp_printf(&mp_plat_print, \"# mp_obj_is_type\\n\");\n\n        \n        mp_printf(&mp_plat_print, \"%d %d\\n\", mp_obj_is_bool(mp_const_true), mp_obj_is_bool(mp_const_false));\n        mp_printf(&mp_plat_print, \"%d %d\\n\", mp_obj_is_bool(MP_OBJ_NEW_SMALL_INT(1)), mp_obj_is_bool(mp_const_none));\n\n        \n        mp_printf(&mp_plat_print, \"%d %d\\n\", mp_obj_is_integer(MP_OBJ_NEW_SMALL_INT(1)), mp_obj_is_integer(mp_obj_new_int_from_ll(1)));\n        mp_printf(&mp_plat_print, \"%d %d\\n\", mp_obj_is_integer(mp_const_true), mp_obj_is_integer(mp_const_false));\n        mp_printf(&mp_plat_print, \"%d %d\\n\", mp_obj_is_integer(mp_obj_new_str(\"1\", 1)), mp_obj_is_integer(mp_const_none));\n\n        \n        mp_printf(&mp_plat_print, \"%d %d\\n\", mp_obj_is_int(MP_OBJ_NEW_SMALL_INT(1)), mp_obj_is_int(mp_obj_new_int_from_ll(1)));\n    }\n\n    mp_printf(&mp_plat_print, \"# end coverage.c\\n\");\n\n    mp_obj_streamtest_t *s = mp_obj_malloc(mp_obj_streamtest_t, &mp_type_stest_fileio);\n    s->buf = NULL;\n    s->len = 0;\n    s->pos = 0;\n    s->error_code = 0;\n    mp_obj_streamtest_t *s2 = mp_obj_malloc(mp_obj_streamtest_t, &mp_type_stest_textio2);\n\n    \n    mp_obj_t items[] = {(mp_obj_t)&str_no_hash_obj, (mp_obj_t)&bytes_no_hash_obj, MP_OBJ_FROM_PTR(s), MP_OBJ_FROM_PTR(s2)};\n    return mp_obj_new_tuple(MP_ARRAY_SIZE(items), items);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(extra_coverage_obj, extra_coverage);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}