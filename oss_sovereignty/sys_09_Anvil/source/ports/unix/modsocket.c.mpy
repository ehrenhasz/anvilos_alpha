{
  "module_name": "modsocket.c",
  "hash_id": "eb94dcf53316fd39494416099303d9131cf1d4e8bcfba9f26f553f32594e9962",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/modsocket.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n\n#if MICROPY_PY_SOCKET\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <errno.h>\n#include <math.h>\n\n#include \"py/objtuple.h\"\n#include \"py/objstr.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n#include \"py/builtin.h\"\n#include \"py/mphal.h\"\n#include \"py/mpthread.h\"\n#include \"extmod/vfs.h\"\n#include <poll.h>\n\n \n\n \n \ntypedef struct _mp_obj_socket_t {\n    mp_obj_base_t base;\n    int fd;\n    bool blocking;\n} mp_obj_socket_t;\n\nconst mp_obj_type_t mp_type_socket;\n\n \nstatic inline mp_obj_t mp_obj_from_sockaddr(const struct sockaddr *addr, socklen_t len) {\n    return mp_obj_new_bytes((const byte *)addr, len);\n}\n\nstatic mp_obj_socket_t *socket_new(int fd) {\n    mp_obj_socket_t *o = mp_obj_malloc(mp_obj_socket_t, &mp_type_socket);\n    o->fd = fd;\n    o->blocking = true;\n    return o;\n}\n\n\nstatic void socket_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<_socket %d>\", self->fd);\n}\n\nstatic mp_uint_t socket_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_socket_t *o = MP_OBJ_TO_PTR(o_in);\n    ssize_t r;\n    MP_HAL_RETRY_SYSCALL(r, read(o->fd, buf, size), {\n         \n         \n        if (err == EAGAIN && o->blocking) {\n            err = MP_ETIMEDOUT;\n        }\n\n        *errcode = err;\n        return MP_STREAM_ERROR;\n    });\n    return (mp_uint_t)r;\n}\n\nstatic mp_uint_t socket_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_socket_t *o = MP_OBJ_TO_PTR(o_in);\n    ssize_t r;\n    MP_HAL_RETRY_SYSCALL(r, write(o->fd, buf, size), {\n         \n         \n        if (err == EAGAIN && o->blocking) {\n            err = MP_ETIMEDOUT;\n        }\n\n        *errcode = err;\n        return MP_STREAM_ERROR;\n    });\n    return (mp_uint_t)r;\n}\n\nstatic mp_uint_t socket_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(o_in);\n    (void)arg;\n    switch (request) {\n        case MP_STREAM_CLOSE:\n             \n            \n            \n            \n            \n            \n            \n            MP_THREAD_GIL_EXIT();\n            close(self->fd);\n            MP_THREAD_GIL_ENTER();\n            return 0;\n\n        case MP_STREAM_GET_FILENO:\n            return self->fd;\n\n        #if MICROPY_PY_SELECT\n        case MP_STREAM_POLL: {\n            mp_uint_t ret = 0;\n            uint8_t pollevents = 0;\n            if (arg & MP_STREAM_POLL_RD) {\n                pollevents |= POLLIN;\n            }\n            if (arg & MP_STREAM_POLL_WR) {\n                pollevents |= POLLOUT;\n            }\n            struct pollfd pfd = { .fd = self->fd, .events = pollevents };\n            if (poll(&pfd, 1, 0) > 0) {\n                if (pfd.revents & POLLIN) {\n                    ret |= MP_STREAM_POLL_RD;\n                }\n                if (pfd.revents & POLLOUT) {\n                    ret |= MP_STREAM_POLL_WR;\n                }\n                if (pfd.revents & POLLERR) {\n                    ret |= MP_STREAM_POLL_ERR;\n                }\n                if (pfd.revents & POLLHUP) {\n                    ret |= MP_STREAM_POLL_HUP;\n                }\n                if (pfd.revents & POLLNVAL) {\n                    ret |= MP_STREAM_POLL_NVAL;\n                }\n            }\n            return ret;\n        }\n        #endif\n\n        default:\n            *errcode = MP_EINVAL;\n            return MP_STREAM_ERROR;\n    }\n}\n\nstatic mp_obj_t socket_fileno(mp_obj_t self_in) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    return MP_OBJ_NEW_SMALL_INT(self->fd);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(socket_fileno_obj, socket_fileno);\n\nstatic mp_obj_t socket_connect(mp_obj_t self_in, mp_obj_t addr_in) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(addr_in, &bufinfo, MP_BUFFER_READ);\n\n    \n    \n    for (;;) {\n        MP_THREAD_GIL_EXIT();\n        int r = connect(self->fd, (const struct sockaddr *)bufinfo.buf, bufinfo.len);\n        MP_THREAD_GIL_ENTER();\n        if (r == -1) {\n            int err = errno;\n            if (self->blocking) {\n                if (err == EINTR) {\n                    mp_handle_pending(true);\n                    continue;\n                }\n                \n                if (err == EINPROGRESS) {\n                    err = MP_ETIMEDOUT;\n                }\n            }\n            mp_raise_OSError(err);\n        }\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_connect_obj, socket_connect);\n\nstatic mp_obj_t socket_bind(mp_obj_t self_in, mp_obj_t addr_in) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(addr_in, &bufinfo, MP_BUFFER_READ);\n    MP_THREAD_GIL_EXIT();\n    int r = bind(self->fd, (const struct sockaddr *)bufinfo.buf, bufinfo.len);\n    MP_THREAD_GIL_ENTER();\n    RAISE_ERRNO(r, errno);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_bind_obj, socket_bind);\n\n\nstatic mp_obj_t socket_listen(size_t n_args, const mp_obj_t *args) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n\n    int backlog = MICROPY_PY_SOCKET_LISTEN_BACKLOG_DEFAULT;\n    if (n_args > 1) {\n        backlog = (int)mp_obj_get_int(args[1]);\n        backlog = (backlog < 0) ? 0 : backlog;\n    }\n\n    MP_THREAD_GIL_EXIT();\n    int r = listen(self->fd, backlog);\n    MP_THREAD_GIL_ENTER();\n    RAISE_ERRNO(r, errno);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_listen_obj, 1, 2, socket_listen);\n\nstatic mp_obj_t socket_accept(mp_obj_t self_in) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    \n    \n    byte addr[32];\n    socklen_t addr_len = sizeof(addr);\n    int fd;\n    MP_HAL_RETRY_SYSCALL(fd, accept(self->fd, (struct sockaddr *)&addr, &addr_len), {\n        \n        if (self->blocking && err == EAGAIN) {\n            err = MP_ETIMEDOUT;\n        }\n        mp_raise_OSError(err);\n    });\n\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));\n    t->items[0] = MP_OBJ_FROM_PTR(socket_new(fd));\n    t->items[1] = mp_obj_new_bytearray(addr_len, &addr);\n\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(socket_accept_obj, socket_accept);\n\n\n\n\nstatic mp_obj_t socket_recv(size_t n_args, const mp_obj_t *args) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n    int sz = MP_OBJ_SMALL_INT_VALUE(args[1]);\n    int flags = 0;\n\n    if (n_args > 2) {\n        flags = MP_OBJ_SMALL_INT_VALUE(args[2]);\n    }\n\n    byte *buf = m_new(byte, sz);\n    ssize_t out_sz;\n    MP_HAL_RETRY_SYSCALL(out_sz, recv(self->fd, buf, sz, flags), mp_raise_OSError(err));\n    mp_obj_t ret = mp_obj_new_str_of_type(&mp_type_bytes, buf, out_sz);\n    m_del(char, buf, sz);\n    return ret;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_recv_obj, 2, 3, socket_recv);\n\nstatic mp_obj_t socket_recvfrom(size_t n_args, const mp_obj_t *args) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n    int sz = MP_OBJ_SMALL_INT_VALUE(args[1]);\n    int flags = 0;\n\n    if (n_args > 2) {\n        flags = MP_OBJ_SMALL_INT_VALUE(args[2]);\n    }\n\n    struct sockaddr_storage addr;\n    socklen_t addr_len = sizeof(addr);\n\n    byte *buf = m_new(byte, sz);\n    ssize_t out_sz;\n    MP_HAL_RETRY_SYSCALL(out_sz, recvfrom(self->fd, buf, sz, flags, (struct sockaddr *)&addr, &addr_len),\n        mp_raise_OSError(err));\n    mp_obj_t buf_o = mp_obj_new_str_of_type(&mp_type_bytes, buf, out_sz);\n    m_del(char, buf, sz);\n\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));\n    t->items[0] = buf_o;\n    t->items[1] = mp_obj_from_sockaddr((struct sockaddr *)&addr, addr_len);\n\n    return MP_OBJ_FROM_PTR(t);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_recvfrom_obj, 2, 3, socket_recvfrom);\n\n\n\n\nstatic mp_obj_t socket_send(size_t n_args, const mp_obj_t *args) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n    int flags = 0;\n\n    if (n_args > 2) {\n        flags = MP_OBJ_SMALL_INT_VALUE(args[2]);\n    }\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_READ);\n    ssize_t out_sz;\n    MP_HAL_RETRY_SYSCALL(out_sz, send(self->fd, bufinfo.buf, bufinfo.len, flags),\n        mp_raise_OSError(err));\n    return MP_OBJ_NEW_SMALL_INT(out_sz);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_send_obj, 2, 3, socket_send);\n\nstatic mp_obj_t socket_sendto(size_t n_args, const mp_obj_t *args) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n    int flags = 0;\n\n    mp_obj_t dst_addr = args[2];\n    if (n_args > 3) {\n        flags = MP_OBJ_SMALL_INT_VALUE(args[2]);\n        dst_addr = args[3];\n    }\n\n    mp_buffer_info_t bufinfo, addr_bi;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_READ);\n    mp_get_buffer_raise(dst_addr, &addr_bi, MP_BUFFER_READ);\n    ssize_t out_sz;\n    MP_HAL_RETRY_SYSCALL(out_sz, sendto(self->fd, bufinfo.buf, bufinfo.len, flags,\n        (struct sockaddr *)addr_bi.buf, addr_bi.len), mp_raise_OSError(err));\n    return MP_OBJ_NEW_SMALL_INT(out_sz);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_sendto_obj, 3, 4, socket_sendto);\n\nstatic mp_obj_t socket_setsockopt(size_t n_args, const mp_obj_t *args) {\n    (void)n_args; \n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n    int level = MP_OBJ_SMALL_INT_VALUE(args[1]);\n    int option = mp_obj_get_int(args[2]);\n\n    const void *optval;\n    socklen_t optlen;\n    int val;\n    if (mp_obj_is_int(args[3])) {\n        val = mp_obj_int_get_truncated(args[3]);\n        optval = &val;\n        optlen = sizeof(val);\n    } else {\n        mp_buffer_info_t bufinfo;\n        mp_get_buffer_raise(args[3], &bufinfo, MP_BUFFER_READ);\n        optval = bufinfo.buf;\n        optlen = bufinfo.len;\n    }\n    MP_THREAD_GIL_EXIT();\n    int r = setsockopt(self->fd, level, option, optval, optlen);\n    MP_THREAD_GIL_ENTER();\n    RAISE_ERRNO(r, errno);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_setsockopt_obj, 4, 4, socket_setsockopt);\n\nstatic mp_obj_t socket_setblocking(mp_obj_t self_in, mp_obj_t flag_in) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    int val = mp_obj_is_true(flag_in);\n    MP_THREAD_GIL_EXIT();\n    int flags = fcntl(self->fd, F_GETFL, 0);\n    if (flags == -1) {\n        MP_THREAD_GIL_ENTER();\n        RAISE_ERRNO(flags, errno);\n    }\n    if (val) {\n        flags &= ~O_NONBLOCK;\n    } else {\n        flags |= O_NONBLOCK;\n    }\n    flags = fcntl(self->fd, F_SETFL, flags);\n    MP_THREAD_GIL_ENTER();\n    RAISE_ERRNO(flags, errno);\n    self->blocking = val;\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_setblocking_obj, socket_setblocking);\n\nstatic mp_obj_t socket_settimeout(mp_obj_t self_in, mp_obj_t timeout_in) {\n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(self_in);\n    struct timeval tv = {0, };\n    bool new_blocking = true;\n\n    \n    \n    if (timeout_in != mp_const_none) {\n        #if MICROPY_PY_BUILTINS_FLOAT\n        mp_float_t val = mp_obj_get_float(timeout_in);\n        mp_float_t ipart;\n        tv.tv_usec = (time_t)MICROPY_FLOAT_C_FUN(round)(MICROPY_FLOAT_C_FUN(modf)(val, &ipart) * MICROPY_FLOAT_CONST(1000000.));\n        tv.tv_sec = (suseconds_t)ipart;\n        #else\n        tv.tv_sec = mp_obj_get_int(timeout_in);\n        #endif\n\n        \n        \n        if (tv.tv_sec == 0 && tv.tv_usec == 0) {\n            new_blocking = false;\n        }\n    }\n\n    if (new_blocking) {\n        int r;\n        MP_THREAD_GIL_EXIT();\n        r = setsockopt(self->fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(struct timeval));\n        if (r == -1) {\n            MP_THREAD_GIL_ENTER();\n            RAISE_ERRNO(r, errno);\n        }\n        r = setsockopt(self->fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(struct timeval));\n        MP_THREAD_GIL_ENTER();\n        RAISE_ERRNO(r, errno);\n    }\n\n    if (self->blocking != new_blocking) {\n        socket_setblocking(self_in, mp_obj_new_bool(new_blocking));\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(socket_settimeout_obj, socket_settimeout);\n\nstatic mp_obj_t socket_makefile(size_t n_args, const mp_obj_t *args) {\n    \n    \n    \n    mp_obj_socket_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_obj_t *new_args = alloca(n_args * sizeof(mp_obj_t));\n    memcpy(new_args + 1, args + 1, (n_args - 1) * sizeof(mp_obj_t));\n    new_args[0] = MP_OBJ_NEW_SMALL_INT(self->fd);\n    return mp_vfs_open(n_args, new_args, (mp_map_t *)&mp_const_empty_map);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_makefile_obj, 1, 3, socket_makefile);\n\nstatic mp_obj_t socket_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    (void)n_kw;\n\n    int family = AF_INET;\n    int type = SOCK_STREAM;\n    int proto = 0;\n\n    if (n_args > 0) {\n        assert(mp_obj_is_small_int(args[0]));\n        family = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        if (n_args > 1) {\n            assert(mp_obj_is_small_int(args[1]));\n            type = MP_OBJ_SMALL_INT_VALUE(args[1]);\n            if (n_args > 2) {\n                assert(mp_obj_is_small_int(args[2]));\n                proto = MP_OBJ_SMALL_INT_VALUE(args[2]);\n            }\n        }\n    }\n\n    MP_THREAD_GIL_EXIT();\n    int fd = socket(family, type, proto);\n    MP_THREAD_GIL_ENTER();\n    RAISE_ERRNO(fd, errno);\n    return MP_OBJ_FROM_PTR(socket_new(fd));\n}\n\nstatic const mp_rom_map_elem_t socket_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_fileno), MP_ROM_PTR(&socket_fileno_obj) },\n    { MP_ROM_QSTR(MP_QSTR_makefile), MP_ROM_PTR(&socket_makefile_obj) },\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_connect), MP_ROM_PTR(&socket_connect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_bind), MP_ROM_PTR(&socket_bind_obj) },\n    { MP_ROM_QSTR(MP_QSTR_listen), MP_ROM_PTR(&socket_listen_obj) },\n    { MP_ROM_QSTR(MP_QSTR_accept), MP_ROM_PTR(&socket_accept_obj) },\n    { MP_ROM_QSTR(MP_QSTR_recv), MP_ROM_PTR(&socket_recv_obj) },\n    { MP_ROM_QSTR(MP_QSTR_recvfrom), MP_ROM_PTR(&socket_recvfrom_obj) },\n    { MP_ROM_QSTR(MP_QSTR_send), MP_ROM_PTR(&socket_send_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sendto), MP_ROM_PTR(&socket_sendto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setsockopt), MP_ROM_PTR(&socket_setsockopt_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setblocking), MP_ROM_PTR(&socket_setblocking_obj) },\n    { MP_ROM_QSTR(MP_QSTR_settimeout), MP_ROM_PTR(&socket_settimeout_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(socket_locals_dict, socket_locals_dict_table);\n\nstatic const mp_stream_p_t socket_stream_p = {\n    .read = socket_read,\n    .write = socket_write,\n    .ioctl = socket_ioctl,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_socket,\n    MP_QSTR_socket,\n    MP_TYPE_FLAG_NONE,\n    make_new, socket_make_new,\n    print, socket_print,\n    protocol, &socket_stream_p,\n    locals_dict, &socket_locals_dict\n    );\n\n#define BINADDR_MAX_LEN sizeof(struct in6_addr)\nstatic mp_obj_t mod_socket_inet_pton(mp_obj_t family_in, mp_obj_t addr_in) {\n    int family = mp_obj_get_int(family_in);\n    byte binaddr[BINADDR_MAX_LEN];\n    int r = inet_pton(family, mp_obj_str_get_str(addr_in), binaddr);\n    RAISE_ERRNO(r, errno);\n    if (r == 0) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n    int binaddr_len = 0;\n    switch (family) {\n        case AF_INET:\n            binaddr_len = sizeof(struct in_addr);\n            break;\n        case AF_INET6:\n            binaddr_len = sizeof(struct in6_addr);\n            break;\n    }\n    return mp_obj_new_bytes(binaddr, binaddr_len);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mod_socket_inet_pton_obj, mod_socket_inet_pton);\n\nstatic mp_obj_t mod_socket_inet_ntop(mp_obj_t family_in, mp_obj_t binaddr_in) {\n    int family = mp_obj_get_int(family_in);\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(binaddr_in, &bufinfo, MP_BUFFER_READ);\n    vstr_t vstr;\n    vstr_init_len(&vstr, family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN);\n    if (inet_ntop(family, bufinfo.buf, vstr.buf, vstr.len) == NULL) {\n        mp_raise_OSError(errno);\n    }\n    vstr.len = strlen(vstr.buf);\n    return mp_obj_new_str_from_utf8_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mod_socket_inet_ntop_obj, mod_socket_inet_ntop);\n\nstatic mp_obj_t mod_socket_getaddrinfo(size_t n_args, const mp_obj_t *args) {\n\n    const char *host = mp_obj_str_get_str(args[0]);\n    const char *serv = NULL;\n    struct addrinfo hints;\n    char buf[6];\n    memset(&hints, 0, sizeof(hints));\n    \n    \n    if (mp_obj_is_small_int(args[1])) {\n        unsigned port = (unsigned short)MP_OBJ_SMALL_INT_VALUE(args[1]);\n        snprintf(buf, sizeof(buf), \"%u\", port);\n        serv = buf;\n        hints.ai_flags = AI_NUMERICSERV;\n        #ifdef __UCLIBC_MAJOR__\n        #if __UCLIBC_MAJOR__ == 0 && (__UCLIBC_MINOR__ < 9 || (__UCLIBC_MINOR__ == 9 && __UCLIBC_SUBLEVEL__ <= 32))\n\n\n        \n        \n        \n        \n        \n        \n        \n        hints.ai_socktype = SOCK_STREAM;\n        #endif\n        #endif\n    } else {\n        serv = mp_obj_str_get_str(args[1]);\n    }\n\n    if (n_args > 2) {\n        hints.ai_family = MP_OBJ_SMALL_INT_VALUE(args[2]);\n        if (n_args > 3) {\n            hints.ai_socktype = MP_OBJ_SMALL_INT_VALUE(args[3]);\n            if (n_args > 4) {\n                hints.ai_protocol = MP_OBJ_SMALL_INT_VALUE(args[4]);\n                if (n_args > 5) {\n                    hints.ai_flags = MP_OBJ_SMALL_INT_VALUE(args[5]);\n                }\n            }\n        }\n    }\n\n    struct addrinfo *addr_list;\n    MP_THREAD_GIL_EXIT();\n    int res = getaddrinfo(host, serv, &hints, &addr_list);\n    MP_THREAD_GIL_ENTER();\n\n    if (res != 0) {\n        \n        mp_raise_msg_varg(&mp_type_OSError, MP_ERROR_TEXT(\"[addrinfo error %d]\"), res);\n    }\n    assert(addr_list);\n\n    mp_obj_t list = mp_obj_new_list(0, NULL);\n    for (struct addrinfo *addr = addr_list; addr; addr = addr->ai_next) {\n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(5, NULL));\n        t->items[0] = MP_OBJ_NEW_SMALL_INT(addr->ai_family);\n        t->items[1] = MP_OBJ_NEW_SMALL_INT(addr->ai_socktype);\n        t->items[2] = MP_OBJ_NEW_SMALL_INT(addr->ai_protocol);\n        \n        \n        if (addr->ai_canonname) {\n            t->items[3] = MP_OBJ_NEW_QSTR(qstr_from_str(addr->ai_canonname));\n        } else {\n            t->items[3] = mp_const_none;\n        }\n        t->items[4] = mp_obj_new_bytearray(addr->ai_addrlen, addr->ai_addr);\n        mp_obj_list_append(list, MP_OBJ_FROM_PTR(t));\n    }\n    freeaddrinfo(addr_list);\n    return list;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_socket_getaddrinfo_obj, 2, 6, mod_socket_getaddrinfo);\n\nstatic mp_obj_t mod_socket_sockaddr(mp_obj_t sockaddr_in) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(sockaddr_in, &bufinfo, MP_BUFFER_READ);\n    switch (((struct sockaddr *)bufinfo.buf)->sa_family) {\n        case AF_INET: {\n            struct sockaddr_in *sa = (struct sockaddr_in *)bufinfo.buf;\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(3, NULL));\n            t->items[0] = MP_OBJ_NEW_SMALL_INT(AF_INET);\n            t->items[1] = mp_obj_new_bytes((byte *)&sa->sin_addr, sizeof(sa->sin_addr));\n            t->items[2] = MP_OBJ_NEW_SMALL_INT(ntohs(sa->sin_port));\n            return MP_OBJ_FROM_PTR(t);\n        }\n        case AF_INET6: {\n            struct sockaddr_in6 *sa = (struct sockaddr_in6 *)bufinfo.buf;\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(5, NULL));\n            t->items[0] = MP_OBJ_NEW_SMALL_INT(AF_INET6);\n            t->items[1] = mp_obj_new_bytes((byte *)&sa->sin6_addr, sizeof(sa->sin6_addr));\n            t->items[2] = MP_OBJ_NEW_SMALL_INT(ntohs(sa->sin6_port));\n            t->items[3] = MP_OBJ_NEW_SMALL_INT(ntohl(sa->sin6_flowinfo));\n            t->items[4] = MP_OBJ_NEW_SMALL_INT(ntohl(sa->sin6_scope_id));\n            return MP_OBJ_FROM_PTR(t);\n        }\n        default: {\n            struct sockaddr *sa = (struct sockaddr *)bufinfo.buf;\n            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));\n            t->items[0] = MP_OBJ_NEW_SMALL_INT(sa->sa_family);\n            t->items[1] = mp_obj_new_bytes((byte *)sa->sa_data, bufinfo.len - offsetof(struct sockaddr, sa_data));\n            return MP_OBJ_FROM_PTR(t);\n        }\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_socket_sockaddr_obj, mod_socket_sockaddr);\n\nstatic const mp_rom_map_elem_t mp_module_socket_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_socket) },\n    { MP_ROM_QSTR(MP_QSTR_socket), MP_ROM_PTR(&mp_type_socket) },\n    { MP_ROM_QSTR(MP_QSTR_getaddrinfo), MP_ROM_PTR(&mod_socket_getaddrinfo_obj) },\n    { MP_ROM_QSTR(MP_QSTR_inet_pton), MP_ROM_PTR(&mod_socket_inet_pton_obj) },\n    { MP_ROM_QSTR(MP_QSTR_inet_ntop), MP_ROM_PTR(&mod_socket_inet_ntop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sockaddr), MP_ROM_PTR(&mod_socket_sockaddr_obj) },\n\n#define C(name) { MP_ROM_QSTR(MP_QSTR_##name), MP_ROM_INT(name) }\n    C(AF_UNIX),\n    C(AF_INET),\n    C(AF_INET6),\n    C(SOCK_STREAM),\n    C(SOCK_DGRAM),\n    C(SOCK_RAW),\n\n    C(MSG_DONTROUTE),\n    C(MSG_DONTWAIT),\n\n    C(SOL_SOCKET),\n    C(SO_BROADCAST),\n    C(SO_ERROR),\n    C(SO_KEEPALIVE),\n    C(SO_LINGER),\n    C(SO_REUSEADDR),\n#undef C\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_socket_globals, mp_module_socket_globals_table);\n\nconst mp_obj_module_t mp_module_socket = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_socket_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_socket, mp_module_socket);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}