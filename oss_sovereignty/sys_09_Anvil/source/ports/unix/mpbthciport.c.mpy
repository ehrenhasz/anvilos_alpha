{
  "module_name": "mpbthciport.c",
  "hash_id": "d7d718bb60db0870b62649a40bd126c8ec97f4e922aa47dec2e7a9c4c960b3c4",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/mpbthciport.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/mperrno.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_BLUETOOTH && (MICROPY_BLUETOOTH_NIMBLE || (MICROPY_BLUETOOTH_BTSTACK && MICROPY_BLUETOOTH_BTSTACK_H4))\n\n#if !MICROPY_PY_THREAD\n#error Unix HCI UART requires MICROPY_PY_THREAD\n#endif\n\n#include \"extmod/modbluetooth.h\"\n#include \"extmod/mpbthci.h\"\n\n#include <pthread.h>\n#include <unistd.h>\n\n#include <termios.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG_printf(...) \n\n#define HCI_TRACE (0)\n#define COL_OFF \"\\033[0m\"\n#define COL_GREEN \"\\033[0;32m\"\n#define COL_BLUE \"\\033[0;34m\"\n\nuint8_t mp_bluetooth_hci_cmd_buf[4 + 256];\n\nstatic int uart_fd = -1;\n\n\nextern bool mp_bluetooth_hci_poll(void);\n\n#if MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n\n\n\n\n\nextern bool mp_bluetooth_hci_active(void);\n\n\nstatic volatile bool events_task_is_scheduled = false;\n\nstatic mp_obj_t run_events_scheduled_task(mp_obj_t none_in) {\n    (void)none_in;\n    MICROPY_PY_BLUETOOTH_ENTER\n        events_task_is_scheduled = false;\n    MICROPY_PY_BLUETOOTH_EXIT\n    mp_bluetooth_hci_poll();\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(run_events_scheduled_task_obj, run_events_scheduled_task);\n\n#endif \n\nstatic const useconds_t UART_POLL_INTERVAL_US = 1000;\nstatic pthread_t hci_poll_thread_id;\n\nstatic void *hci_poll_thread(void *arg) {\n    (void)arg;\n\n    DEBUG_printf(\"hci_poll_thread: starting\\n\");\n\n    #if MICROPY_PY_BLUETOOTH_USE_SYNC_EVENTS\n\n    events_task_is_scheduled = false;\n\n    while (mp_bluetooth_hci_active()) {\n        MICROPY_PY_BLUETOOTH_ENTER\n        if (!events_task_is_scheduled) {\n            events_task_is_scheduled = mp_sched_schedule(MP_OBJ_FROM_PTR(&run_events_scheduled_task_obj), mp_const_none);\n        }\n        MICROPY_PY_BLUETOOTH_EXIT\n        usleep(UART_POLL_INTERVAL_US);\n    }\n\n    #else\n\n    \n    \n    while (mp_bluetooth_hci_poll()) {\n        usleep(UART_POLL_INTERVAL_US);\n    }\n\n    #endif\n\n    DEBUG_printf(\"hci_poll_thread: stopped\\n\");\n\n    return NULL;\n}\n\nstatic int configure_uart(void) {\n    struct termios toptions;\n\n    \n    if (tcgetattr(uart_fd, &toptions) < 0) {\n        DEBUG_printf(\"Couldn't get term attributes\");\n        return -1;\n    }\n\n    \n    cfmakeraw(&toptions);\n\n    \n    toptions.c_cflag &= ~CSTOPB;\n    toptions.c_cflag |= CS8;\n    toptions.c_cflag &= ~PARENB;\n\n    \n    toptions.c_cflag |= CREAD | CLOCAL;\n\n    \n    toptions.c_cc[VMIN] = 1;\n    toptions.c_cc[VTIME] = 0;\n\n    \n    toptions.c_iflag &= ~(IXON | IXOFF | IXANY);\n    toptions.c_cflag |= CRTSCTS;\n\n    \n    speed_t brate = B1000000;\n    cfsetospeed(&toptions, brate);\n    cfsetispeed(&toptions, brate);\n\n    \n    if (tcsetattr(uart_fd, TCSANOW, &toptions) < 0) {\n        DEBUG_printf(\"Couldn't set term attributes\");\n\n        close(uart_fd);\n        uart_fd = -1;\n\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint mp_bluetooth_hci_uart_init(uint32_t port, uint32_t baudrate) {\n    (void)port;\n    (void)baudrate;\n\n    DEBUG_printf(\"mp_bluetooth_hci_uart_init (unix)\\n\");\n\n    if (uart_fd != -1) {\n        DEBUG_printf(\"mp_bluetooth_hci_uart_init: already active\\n\");\n        return 0;\n    }\n\n    char uart_device_name[256] = \"/dev/ttyUSB0\";\n\n    char *path = getenv(\"MICROPYBTUART\");\n    if (path != NULL) {\n        strcpy(uart_device_name, path);\n    }\n    DEBUG_printf(\"mp_bluetooth_hci_uart_init: Using HCI UART: %s\\n\", uart_device_name);\n\n    int flags = O_RDWR | O_NOCTTY | O_NONBLOCK;\n    uart_fd = open(uart_device_name, flags);\n    if (uart_fd == -1) {\n        printf(\"mp_bluetooth_hci_uart_init: Unable to open port %s\\n\", uart_device_name);\n        return -1;\n    }\n\n    if (configure_uart()) {\n        return -1;\n    }\n\n    \n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    pthread_create(&hci_poll_thread_id, &attr, &hci_poll_thread, NULL);\n\n    return 0;\n}\n\nint mp_bluetooth_hci_uart_deinit(void) {\n    DEBUG_printf(\"mp_bluetooth_hci_uart_deinit\\n\");\n\n    if (uart_fd == -1) {\n        return 0;\n    }\n\n    \n    pthread_join(hci_poll_thread_id, NULL);\n\n    \n    close(uart_fd);\n    uart_fd = -1;\n\n    return 0;\n}\n\nint mp_bluetooth_hci_uart_set_baudrate(uint32_t baudrate) {\n    (void)baudrate;\n    DEBUG_printf(\"mp_bluetooth_hci_uart_set_baudrate\\n\");\n    return 0;\n}\n\nint mp_bluetooth_hci_uart_readchar(void) {\n    \n\n    if (uart_fd == -1) {\n        return -1;\n    }\n\n    uint8_t c;\n    ssize_t bytes_read = read(uart_fd, &c, 1);\n\n    if (bytes_read == 1) {\n        #if HCI_TRACE\n        printf(COL_BLUE \"> [% 8ld] RX: %02x\" COL_OFF \"\\n\", mp_hal_ticks_ms(), c);\n        #endif\n        return c;\n    } else {\n        return -1;\n    }\n}\n\nint mp_bluetooth_hci_uart_write(const uint8_t *buf, size_t len) {\n    \n\n    if (uart_fd == -1) {\n        return 0;\n    }\n\n    #if HCI_TRACE\n    printf(COL_GREEN \"< [% 8ld] TX: %02x\", mp_hal_ticks_ms(), buf[0]);\n    for (size_t i = 1; i < len; ++i) {\n        printf(\":%02x\", buf[i]);\n    }\n    printf(COL_OFF \"\\n\");\n    #endif\n\n    return write(uart_fd, buf, len);\n}\n\n\nint mp_bluetooth_hci_controller_init(void) {\n    return 0;\n}\n\nint mp_bluetooth_hci_controller_deinit(void) {\n    return 0;\n}\n\nint mp_bluetooth_hci_controller_sleep_maybe(void) {\n    return 0;\n}\n\nbool mp_bluetooth_hci_controller_woken(void) {\n    return true;\n}\n\nint mp_bluetooth_hci_controller_wakeup(void) {\n    return 0;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}