{
  "module_name": "main.c",
  "hash_id": "56c7ba039f6dda6261a2f259a621a14b787296fb9541cd515b2a7e86a41218b0",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/main.c",
  "human_readable_source": "#include \"py/persistentcode.h\"\n#if MICROPY_ENABLE_COMPILER\n#error COMPILER_IS_ENABLED\n#endif\n \n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <signal.h>\n\n#include \"py/compile.h\"\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/repl.h\"\n#include \"py/gc.h\"\n#include \"py/objstr.h\"\n#include \"py/stackctrl.h\"\n#include \"py/mphal.h\"\n#include \"py/mpthread.h\"\n#include \"extmod/misc.h\"\n#include \"extmod/modplatform.h\"\n#include \"extmod/vfs.h\"\n#include \"extmod/vfs_posix.h\"\n#include \"genhdr/mpversion.h\"\n#include \"input.h\"\n\n\nstatic bool compile_only = false;\nstatic uint emit_opt = MP_EMIT_OPT_NONE;\n\n#if MICROPY_ENABLE_GC\n\n\nlong heap_size = 1024 * 1024 * (sizeof(mp_uint_t) / 4);\n#endif\n\n\n#ifndef MICROPY_GC_SPLIT_HEAP_N_HEAPS\n#define MICROPY_GC_SPLIT_HEAP_N_HEAPS (1)\n#endif\n\n#if !MICROPY_PY_SYS_PATH\n#error \"The unix port requires MICROPY_PY_SYS_PATH=1\"\n#endif\n\n#if !MICROPY_PY_SYS_ARGV\n#error \"The unix port requires MICROPY_PY_SYS_ARGV=1\"\n#endif\n\nstatic void stderr_print_strn(void *env, const char *str, size_t len) {\n    (void)env;\n    ssize_t ret;\n    MP_HAL_RETRY_SYSCALL(ret, write(STDERR_FILENO, str, len), {});\n    mp_os_dupterm_tx_strn(str, len);\n}\n\nconst mp_print_t mp_stderr_print = {NULL, stderr_print_strn};\n\n#define FORCED_EXIT (0x100)\n\n\n\nstatic int handle_uncaught_exception(mp_obj_base_t *exc) {\n    \n    if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(exc->type), MP_OBJ_FROM_PTR(&mp_type_SystemExit))) {\n        \n        mp_obj_t exit_val = mp_obj_exception_get_value(MP_OBJ_FROM_PTR(exc));\n        mp_int_t val = 0;\n        if (exit_val != mp_const_none && !mp_obj_get_int_maybe(exit_val, &val)) {\n            val = 1;\n        }\n        return FORCED_EXIT | (val & 255);\n    }\n\n    \n    mp_obj_print_exception(&mp_stderr_print, MP_OBJ_FROM_PTR(exc));\n    return 1;\n}\n\n#define LEX_SRC_STR (1)\n#define LEX_SRC_VSTR (2)\n#define LEX_SRC_FILENAME (3)\n#define LEX_SRC_STDIN (4)\n\n\n\n\nstatic int execute_from_lexer(int source_kind, const void *source, mp_parse_input_kind_t input_kind, bool is_repl) {\n#if !MICROPY_ENABLE_COMPILER\n    if (source_kind == LEX_SRC_FILENAME) { nlr_buf_t nlr; if (nlr_push(&nlr) == 0) { const char *filename = (const char *)source; mp_compiled_module_t cm; cm.context = m_new_obj(mp_module_context_t); cm.context->module.base.type = &mp_type_module; cm.context->module.globals = mp_globals_get(); mp_raw_code_load_file(qstr_from_str(filename), &cm); mp_obj_t module_fun = mp_make_function_from_proto_fun(cm.rc, cm.context, NULL); mp_call_function_0(module_fun); nlr_pop(); return 0; } else { mp_obj_print_exception(&mp_stderr_print, (mp_obj_t)nlr.ret_val); return 1; } } mp_printf(&mp_stderr_print, \"Error: Compiler disabled and not MPY.\\n\");\n    return 1;\n}\nstatic int __attribute__((unused)) _unused_execute_from_lexer(int source_kind, const void *source, mp_parse_input_kind_t input_kind, bool is_repl) {\n#endif\n    mp_hal_set_interrupt_char(CHAR_CTRL_C);\n\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        \n        mp_lexer_t *lex;\n        if (source_kind == LEX_SRC_STR) {\n            const char *line = source;\n            lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, line, strlen(line), false);\n        } else if (source_kind == LEX_SRC_VSTR) {\n            const vstr_t *vstr = source;\n            lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, vstr->buf, vstr->len, false);\n        } else if (source_kind == LEX_SRC_FILENAME) {\n            const char *filename = (const char *)source;\n            lex = mp_lexer_new_from_file(qstr_from_str(filename));\n        } else { \n            lex = mp_lexer_new_from_fd(MP_QSTR__lt_stdin_gt_, 0, false);\n        }\n\n        qstr source_name = lex->source_name;\n\n        #if MICROPY_PY___FILE__\n        if (input_kind == MP_PARSE_FILE_INPUT) {\n            mp_store_global(MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));\n        }\n        #endif\n\n        mp_parse_tree_t parse_tree = mp_parse(lex, input_kind);\n\n        #if defined(MICROPY_UNIX_COVERAGE)\n        \n        if (mp_verbose_flag >= 3) {\n            printf(\"----------------\\n\");\n            mp_parse_node_print(&mp_plat_print, parse_tree.root, 0);\n            printf(\"----------------\\n\");\n        }\n        #endif\n\n        mp_obj_t module_fun = mp_compile(&parse_tree, source_name, is_repl);\n\n        if (!compile_only) {\n            \n            mp_call_function_0(module_fun);\n        }\n\n        mp_hal_set_interrupt_char(-1);\n        mp_handle_pending(true);\n        nlr_pop();\n        return 0;\n\n    } else {\n        \n        mp_hal_set_interrupt_char(-1);\n        mp_handle_pending(false);\n        return handle_uncaught_exception(nlr.ret_val);\n    }\n}\n\n#if MICROPY_USE_READLINE == 1\n#include \"shared/readline/readline.h\"\n#else\nstatic char *strjoin(const char *s1, int sep_char, const char *s2) {\n    int l1 = strlen(s1);\n    int l2 = strlen(s2);\n    char *s = malloc(l1 + l2 + 2);\n    memcpy(s, s1, l1);\n    if (sep_char != 0) {\n        s[l1] = sep_char;\n        l1 += 1;\n    }\n    memcpy(s + l1, s2, l2);\n    s[l1 + l2] = 0;\n    return s;\n}\n#endif\n\nstatic int do_repl(void) {\n    mp_hal_stdout_tx_str(MICROPY_BANNER_NAME_AND_VERSION);\n    mp_hal_stdout_tx_str(\"; \" MICROPY_BANNER_MACHINE);\n    mp_hal_stdout_tx_str(\"\\nUse Ctrl-D to exit, Ctrl-E for paste mode\\n\");\n\n    #if MICROPY_USE_READLINE == 1\n\n    \n\n    vstr_t line;\n    vstr_init(&line, 16);\n    for (;;) {\n        mp_hal_stdio_mode_raw();\n\n    input_restart:\n        vstr_reset(&line);\n        int ret = readline(&line, mp_repl_get_ps1());\n        mp_parse_input_kind_t parse_input_kind = MP_PARSE_SINGLE_INPUT;\n\n        if (ret == CHAR_CTRL_C) {\n            \n            mp_hal_stdout_tx_str(\"\\r\\n\");\n            goto input_restart;\n        } else if (ret == CHAR_CTRL_D) {\n            \n            printf(\"\\n\");\n            mp_hal_stdio_mode_orig();\n            vstr_clear(&line);\n            return 0;\n        } else if (ret == CHAR_CTRL_E) {\n            \n            mp_hal_stdout_tx_str(\"\\npaste mode; Ctrl-C to cancel, Ctrl-D to finish\\n=== \");\n            vstr_reset(&line);\n            for (;;) {\n                char c = mp_hal_stdin_rx_chr();\n                if (c == CHAR_CTRL_C) {\n                    \n                    mp_hal_stdout_tx_str(\"\\n\");\n                    goto input_restart;\n                } else if (c == CHAR_CTRL_D) {\n                    \n                    mp_hal_stdout_tx_str(\"\\n\");\n                    break;\n                } else {\n                    \n                    vstr_add_byte(&line, c);\n                    if (c == '\\r') {\n                        mp_hal_stdout_tx_str(\"\\n=== \");\n                    } else {\n                        mp_hal_stdout_tx_strn(&c, 1);\n                    }\n                }\n            }\n            parse_input_kind = MP_PARSE_FILE_INPUT;\n        } else if (line.len == 0) {\n            if (ret != 0) {\n                printf(\"\\n\");\n            }\n            goto input_restart;\n        } else {\n            \n            while (mp_repl_continue_with_input(vstr_null_terminated_str(&line))) {\n                vstr_add_byte(&line, '\\n');\n                ret = readline(&line, mp_repl_get_ps2());\n                if (ret == CHAR_CTRL_C) {\n                    \n                    printf(\"\\n\");\n                    goto input_restart;\n                } else if (ret == CHAR_CTRL_D) {\n                    \n                    break;\n                }\n            }\n        }\n\n        mp_hal_stdio_mode_orig();\n\n        ret = execute_from_lexer(LEX_SRC_VSTR, &line, parse_input_kind, true);\n        if (ret & FORCED_EXIT) {\n            return ret;\n        }\n    }\n\n    #else\n\n    \n\n    for (;;) {\n        char *line = prompt((char *)mp_repl_get_ps1());\n        if (line == NULL) {\n            \n            return 0;\n        }\n        while (mp_repl_continue_with_input(line)) {\n            char *line2 = prompt((char *)mp_repl_get_ps2());\n            if (line2 == NULL) {\n                break;\n            }\n            char *line3 = strjoin(line, '\\n', line2);\n            free(line);\n            free(line2);\n            line = line3;\n        }\n\n        int ret = execute_from_lexer(LEX_SRC_STR, line, MP_PARSE_SINGLE_INPUT, true);\n        free(line);\n        if (ret & FORCED_EXIT) {\n            return ret;\n        }\n    }\n\n    #endif\n}\n\nstatic int do_file(const char *file) {\n    return execute_from_lexer(LEX_SRC_FILENAME, file, MP_PARSE_FILE_INPUT, false);\n}\n\nstatic int do_str(const char *str) {\n    return execute_from_lexer(LEX_SRC_STR, str, MP_PARSE_FILE_INPUT, false);\n}\n\nstatic void print_help(char **argv) {\n    printf(\n        \"usage: %s [<opts>] [-X <implopt>] [-c <command> | -m <module> | <filename>]\\n\"\n        \"Options:\\n\"\n        \"-h : print this help message\\n\"\n        \"-i : enable inspection via REPL after running command/module/file\\n\"\n        #if MICROPY_DEBUG_PRINTERS\n        \"-v : verbose (trace various operations); can be multiple\\n\"\n        #endif\n        \"-O[N] : apply bytecode optimizations of level N\\n\"\n        \"\\n\"\n        \"Implementation specific options (-X):\\n\", argv[0]\n        );\n    int impl_opts_cnt = 0;\n    printf(\n        \"  compile-only                 -- parse and compile only\\n\"\n        #if MICROPY_EMIT_NATIVE\n        \"  emit={bytecode,native,viper} -- set the default code emitter\\n\"\n        #else\n        \"  emit=bytecode                -- set the default code emitter\\n\"\n        #endif\n        );\n    impl_opts_cnt++;\n    #if MICROPY_ENABLE_GC\n    printf(\n        \"  heapsize=<n>[w][K|M] -- set the heap size for the GC (default %ld)\\n\"\n        , heap_size);\n    impl_opts_cnt++;\n    #endif\n    #if defined(__APPLE__)\n    printf(\"  realtime -- set thread priority to realtime\\n\");\n    impl_opts_cnt++;\n    #endif\n\n    if (impl_opts_cnt == 0) {\n        printf(\"  (none)\\n\");\n    }\n}\n\nstatic int invalid_args(void) {\n    fprintf(stderr, \"Invalid command line arguments. Use -h option for help.\\n\");\n    return 1;\n}\n\n\nstatic void pre_process_options(int argc, char **argv) {\n    for (int a = 1; a < argc; a++) {\n        if (argv[a][0] == '-') {\n            if (strcmp(argv[a], \"-c\") == 0 || strcmp(argv[a], \"-m\") == 0) {\n                break; \n            }\n            if (strcmp(argv[a], \"-h\") == 0) {\n                print_help(argv);\n                exit(0);\n            }\n            if (strcmp(argv[a], \"-X\") == 0) {\n                if (a + 1 >= argc) {\n                    exit(invalid_args());\n                }\n                if (0) {\n                } else if (strcmp(argv[a + 1], \"compile-only\") == 0) {\n                    compile_only = true;\n                } else if (strcmp(argv[a + 1], \"emit=bytecode\") == 0) {\n                    emit_opt = MP_EMIT_OPT_BYTECODE;\n                #if MICROPY_EMIT_NATIVE\n                } else if (strcmp(argv[a + 1], \"emit=native\") == 0) {\n                    emit_opt = MP_EMIT_OPT_NATIVE_PYTHON;\n                } else if (strcmp(argv[a + 1], \"emit=viper\") == 0) {\n                    emit_opt = MP_EMIT_OPT_VIPER;\n                #endif\n                #if MICROPY_ENABLE_GC\n                } else if (strncmp(argv[a + 1], \"heapsize=\", sizeof(\"heapsize=\") - 1) == 0) {\n                    char *end;\n                    heap_size = strtol(argv[a + 1] + sizeof(\"heapsize=\") - 1, &end, 0);\n                    \n                    \n                    \n                    \n                    \n                    \n                    bool word_adjust = false;\n                    if ((*end | 0x20) == 'w') {\n                        word_adjust = true;\n                        end++;\n                    }\n                    if ((*end | 0x20) == 'k') {\n                        heap_size *= 1024;\n                    } else if ((*end | 0x20) == 'm') {\n                        heap_size *= 1024 * 1024;\n                    } else {\n                        \n                        --end;\n                    }\n                    if (*++end != 0) {\n                        goto invalid_arg;\n                    }\n                    if (word_adjust) {\n                        heap_size = heap_size * MP_BYTES_PER_OBJ_WORD / 4;\n                    }\n                    \n                    if (heap_size < 700) {\n                        goto invalid_arg;\n                    }\n                #endif\n                #if defined(__APPLE__)\n                } else if (strcmp(argv[a + 1], \"realtime\") == 0) {\n                    #if MICROPY_PY_THREAD\n                    mp_thread_is_realtime_enabled = true;\n                    #endif\n                    \n                    \n                    mp_thread_set_realtime();\n                #endif\n                } else {\n                invalid_arg:\n                    exit(invalid_args());\n                }\n                a++;\n            }\n        } else {\n            break; \n        }\n    }\n}\n\nstatic void set_sys_argv(char *argv[], int argc, int start_arg) {\n    for (int i = start_arg; i < argc; i++) {\n        mp_obj_list_append(mp_sys_argv, MP_OBJ_NEW_QSTR(qstr_from_str(argv[i])));\n    }\n}\n\n#if MICROPY_PY_SYS_EXECUTABLE\nextern mp_obj_str_t mp_sys_executable_obj;\nstatic char executable_path[MICROPY_ALLOC_PATH_MAX];\n\nstatic void sys_set_excecutable(char *argv0) {\n    if (realpath(argv0, executable_path)) {\n        mp_obj_str_set_data(&mp_sys_executable_obj, (byte *)executable_path, strlen(executable_path));\n    }\n}\n#endif\n\n#ifdef _WIN32\n#define PATHLIST_SEP_CHAR ';'\n#else\n#define PATHLIST_SEP_CHAR ':'\n#endif\n\nMP_NOINLINE int main_(int argc, char **argv);\n\nint main(int argc, char **argv) {\n    #if MICROPY_PY_THREAD\n    mp_thread_init();\n    #endif\n    \n    \n    \n    \n    \n    mp_stack_ctrl_init();\n    return main_(argc, argv);\n}\n\nMP_NOINLINE int main_(int argc, char **argv) {\n    #ifdef SIGPIPE\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    signal(SIGPIPE, SIG_IGN);\n    #endif\n\n    \n    mp_uint_t stack_limit = 40000 * (sizeof(void *) / 4);\n    #if defined(__arm__) && !defined(__thumb2__)\n    \n    stack_limit *= 2;\n    #endif\n    mp_stack_set_limit(stack_limit);\n\n    pre_process_options(argc, argv);\n\n    #if MICROPY_ENABLE_GC\n    #if !MICROPY_GC_SPLIT_HEAP\n    char *heap = malloc(heap_size);\n    gc_init(heap, heap + heap_size);\n    #else\n    assert(MICROPY_GC_SPLIT_HEAP_N_HEAPS > 0);\n    char *heaps[MICROPY_GC_SPLIT_HEAP_N_HEAPS];\n    long multi_heap_size = heap_size / MICROPY_GC_SPLIT_HEAP_N_HEAPS;\n    for (size_t i = 0; i < MICROPY_GC_SPLIT_HEAP_N_HEAPS; i++) {\n        heaps[i] = malloc(multi_heap_size);\n        if (i == 0) {\n            gc_init(heaps[i], heaps[i] + multi_heap_size);\n        } else {\n            gc_add(heaps[i], heaps[i] + multi_heap_size);\n        }\n    }\n    #endif\n    #endif\n\n    #if MICROPY_ENABLE_PYSTACK\n    static mp_obj_t pystack[1024];\n    mp_pystack_init(pystack, &pystack[MP_ARRAY_SIZE(pystack)]);\n    #endif\n\n    mp_init();\n\n    #if MICROPY_EMIT_NATIVE\n    \n    #if MICROPY_ENABLE_COMPILER\n    MP_STATE_VM(default_emit_opt) = emit_opt;\n#endif\n    #else\n    (void)emit_opt;\n    #endif\n\n    #if MICROPY_VFS_POSIX\n    {\n        \n        mp_obj_t args[2] = {\n            MP_OBJ_TYPE_GET_SLOT(&mp_type_vfs_posix, make_new)(&mp_type_vfs_posix, 0, 0, NULL),\n            MP_OBJ_NEW_QSTR(MP_QSTR__slash_),\n        };\n        mp_vfs_mount(2, args, (mp_map_t *)&mp_const_empty_map);\n        MP_STATE_VM(vfs_cur) = MP_STATE_VM(vfs_mount_table);\n    }\n    #endif\n\n    {\n        \n        mp_sys_path = mp_obj_new_list(0, NULL);\n        mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR_));\n\n        \n        char *home = getenv(\"HOME\");\n        char *path = getenv(\"MICROPYPATH\");\n        if (path == NULL) {\n            path = MICROPY_PY_SYS_PATH_DEFAULT;\n        }\n        if (*path == PATHLIST_SEP_CHAR) {\n            \n            ++path;\n        }\n        bool path_remaining = *path;\n        while (path_remaining) {\n            char *path_entry_end = strchr(path, PATHLIST_SEP_CHAR);\n            if (path_entry_end == NULL) {\n                path_entry_end = path + strlen(path);\n                path_remaining = false;\n            }\n            if (path[0] == '~' && path[1] == '/' && home != NULL) {\n                \n                int home_l = strlen(home);\n                vstr_t vstr;\n                vstr_init(&vstr, home_l + (path_entry_end - path - 1) + 1);\n                vstr_add_strn(&vstr, home, home_l);\n                vstr_add_strn(&vstr, path + 1, path_entry_end - path - 1);\n                mp_obj_list_append(mp_sys_path, mp_obj_new_str_from_vstr(&vstr));\n            } else {\n                mp_obj_list_append(mp_sys_path, mp_obj_new_str_via_qstr(path, path_entry_end - path));\n            }\n            path = path_entry_end + 1;\n        }\n    }\n\n    mp_obj_list_init(MP_OBJ_TO_PTR(mp_sys_argv), 0);\n\n    #if defined(MICROPY_UNIX_COVERAGE)\n    {\n        MP_DECLARE_CONST_FUN_OBJ_0(extra_coverage_obj);\n        MP_DECLARE_CONST_FUN_OBJ_0(extra_cpp_coverage_obj);\n        mp_store_global(MP_QSTR_extra_coverage, MP_OBJ_FROM_PTR(&extra_coverage_obj));\n        mp_store_global(MP_QSTR_extra_cpp_coverage, MP_OBJ_FROM_PTR(&extra_cpp_coverage_obj));\n    }\n    #endif\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n     \n\n    #if MICROPY_PY_SYS_EXECUTABLE\n    sys_set_excecutable(argv[0]);\n    #endif\n\n    const int NOTHING_EXECUTED = -2;\n    int ret = NOTHING_EXECUTED;\n    bool inspect = false;\n    for (int a = 1; a < argc; a++) {\n        if (argv[a][0] == '-') {\n            if (strcmp(argv[a], \"-i\") == 0) {\n                inspect = true;\n            } else if (strcmp(argv[a], \"-c\") == 0) {\n                if (a + 1 >= argc) {\n                    return invalid_args();\n                }\n                set_sys_argv(argv, a + 1, a); \n                set_sys_argv(argv, argc, a + 2); \n                ret = do_str(argv[a + 1]);\n                break;\n            } else if (strcmp(argv[a], \"-m\") == 0) {\n                if (a + 1 >= argc) {\n                    return invalid_args();\n                }\n                mp_obj_t import_args[4];\n                import_args[0] = mp_obj_new_str(argv[a + 1], strlen(argv[a + 1]));\n                import_args[1] = import_args[2] = mp_const_none;\n                \n                \n                \n                import_args[3] = mp_const_false;\n                \n                \n                \n                \n                set_sys_argv(argv, argc, a + 1);\n\n                mp_obj_t mod;\n                nlr_buf_t nlr;\n\n                \n                \n                \n                static bool subpkg_tried;\n                subpkg_tried = false;\n\n            reimport:\n                if (nlr_push(&nlr) == 0) {\n                    mod = mp_builtin___import__(MP_ARRAY_SIZE(import_args), import_args);\n                    nlr_pop();\n                } else {\n                    \n                    return handle_uncaught_exception(nlr.ret_val) & 0xff;\n                }\n\n                \n                mp_obj_t dest[2];\n                mp_load_method_protected(mod, MP_QSTR___path__, dest, true);\n                if (dest[0] != MP_OBJ_NULL && !subpkg_tried) {\n                    subpkg_tried = true;\n                    vstr_t vstr;\n                    int len = strlen(argv[a + 1]);\n                    vstr_init(&vstr, len + sizeof(\".__main__\"));\n                    vstr_add_strn(&vstr, argv[a + 1], len);\n                    vstr_add_strn(&vstr, \".__main__\", sizeof(\".__main__\") - 1);\n                    import_args[0] = mp_obj_new_str_from_vstr(&vstr);\n                    goto reimport;\n                }\n\n                ret = 0;\n                break;\n            } else if (strcmp(argv[a], \"-X\") == 0) {\n                a += 1;\n            #if MICROPY_DEBUG_PRINTERS\n            } else if (strcmp(argv[a], \"-v\") == 0) {\n                mp_verbose_flag++;\n            #endif\n            } else if (strncmp(argv[a], \"-O\", 2) == 0) {\n                if (unichar_isdigit(argv[a][2])) {\n                    #if MICROPY_ENABLE_COMPILER\n                    MP_STATE_VM(mp_optimise_value) = argv[a][2] & 0xf;\n#endif\n                } else {\n                    #if MICROPY_ENABLE_COMPILER\n                    MP_STATE_VM(mp_optimise_value) = 0;\n#endif\n                    for (char *p = argv[a] + 1; *p && *p == 'O'; p++) {\n#if MICROPY_ENABLE_COMPILER\n                        MP_STATE_VM(mp_optimise_value)++;\n#endif\n                    }\n                }\n            } else {\n                return invalid_args();\n            }\n        } else {\n            char *pathbuf = malloc(PATH_MAX);\n            char *basedir = realpath(argv[a], pathbuf);\n            if (basedir == NULL) {\n                mp_printf(&mp_stderr_print, \"%s: can't open file '%s': [Errno %d] %s\\n\", argv[0], argv[a], errno, strerror(errno));\n                free(pathbuf);\n                \n                ret = 2;\n                break;\n            }\n\n            \n            char *p = strrchr(basedir, '/');\n            mp_obj_list_store(mp_sys_path, MP_OBJ_NEW_SMALL_INT(0), mp_obj_new_str_via_qstr(basedir, p - basedir));\n            free(pathbuf);\n\n            set_sys_argv(argv, argc, a);\n            ret = do_file(argv[a]);\n            break;\n        }\n    }\n\n    const char *inspect_env = getenv(\"MICROPYINSPECT\");\n    if (inspect_env && inspect_env[0] != '\\0') {\n        inspect = true;\n    }\n    if (ret == NOTHING_EXECUTED || inspect) {\n        if (isatty(0) || inspect) {\n            prompt_read_history();\n            ret = do_repl();\n            prompt_write_history();\n        } else {\n            ret = execute_from_lexer(LEX_SRC_STDIN, NULL, MP_PARSE_FILE_INPUT, false);\n        }\n    }\n\n    #if MICROPY_PY_SYS_SETTRACE\n    MP_STATE_THREAD(prof_trace_callback) = MP_OBJ_NULL;\n    #endif\n\n    #if MICROPY_PY_SYS_ATEXIT\n    \n    if (mp_obj_is_callable(MP_STATE_VM(sys_exitfunc))) {\n        mp_call_function_0(MP_STATE_VM(sys_exitfunc));\n    }\n    #endif\n\n    #if MICROPY_PY_MICROPYTHON_MEM_INFO\n    if (mp_verbose_flag) {\n        mp_micropython_mem_info(0, NULL);\n    }\n    #endif\n\n    #if MICROPY_PY_BLUETOOTH\n    void mp_bluetooth_deinit(void);\n    mp_bluetooth_deinit();\n    #endif\n\n    #if MICROPY_PY_THREAD\n    mp_thread_deinit();\n    #endif\n\n    #if defined(MICROPY_UNIX_COVERAGE)\n    gc_sweep_all();\n    #endif\n\n    mp_deinit();\n\n    #if MICROPY_ENABLE_GC && !defined(NDEBUG)\n    \n    \n    #if !MICROPY_GC_SPLIT_HEAP\n    free(heap);\n    #else\n    for (size_t i = 0; i < MICROPY_GC_SPLIT_HEAP_N_HEAPS; i++) {\n        free(heaps[i]);\n    }\n    #endif\n    #endif\n\n    \n    return ret & 0xff;\n}\n\nvoid nlr_jump_fail(void *val) {\n    #if MICROPY_USE_READLINE == 1\n    mp_hal_stdio_mode_orig();\n    #endif\n    fprintf(stderr, \"FATAL: uncaught NLR %p\\n\", val);\n    exit(1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}