{
  "module_name": "modtermios.c",
  "hash_id": "5888646442b3c9c8d33f7193916d105e4427df025690023f2a972da88f02caf1",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/modtermios.c",
  "human_readable_source": " \n\n#if MICROPY_PY_TERMIOS\n\n#include <sys/types.h>\n#include <termios.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n#include \"py/mphal.h\"\n\nstatic mp_obj_t mod_termios_tcgetattr(mp_obj_t fd_in) {\n    struct termios term;\n    int fd = mp_obj_get_int(fd_in);\n\n    int res = tcgetattr(fd, &term);\n    RAISE_ERRNO(res, errno);\n\n    mp_obj_list_t *r = MP_OBJ_TO_PTR(mp_obj_new_list(7, NULL));\n    r->items[0] = MP_OBJ_NEW_SMALL_INT(term.c_iflag);\n    r->items[1] = MP_OBJ_NEW_SMALL_INT(term.c_oflag);\n    r->items[2] = MP_OBJ_NEW_SMALL_INT(term.c_cflag);\n    r->items[3] = MP_OBJ_NEW_SMALL_INT(term.c_lflag);\n    r->items[4] = MP_OBJ_NEW_SMALL_INT(cfgetispeed(&term));\n    r->items[5] = MP_OBJ_NEW_SMALL_INT(cfgetospeed(&term));\n\n    mp_obj_list_t *cc = MP_OBJ_TO_PTR(mp_obj_new_list(NCCS, NULL));\n    r->items[6] = MP_OBJ_FROM_PTR(cc);\n    for (int i = 0; i < NCCS; i++) {\n        if (i == VMIN || i == VTIME) {\n            cc->items[i] = MP_OBJ_NEW_SMALL_INT(term.c_cc[i]);\n        } else {\n            \n            \n            \n            \n            cc->items[i] = mp_obj_new_bytes((byte *)&term.c_cc[i], 1);\n        }\n    }\n    return MP_OBJ_FROM_PTR(r);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_termios_tcgetattr_obj, mod_termios_tcgetattr);\n\nstatic mp_obj_t mod_termios_tcsetattr(mp_obj_t fd_in, mp_obj_t when_in, mp_obj_t attrs_in) {\n    struct termios term;\n    int fd = mp_obj_get_int(fd_in);\n    int when = mp_obj_get_int(when_in);\n    if (when == 0) {\n        \n        \n        \n        \n        when = TCSANOW;\n    }\n\n    assert(mp_obj_is_type(attrs_in, &mp_type_list));\n    mp_obj_list_t *attrs = MP_OBJ_TO_PTR(attrs_in);\n\n    term.c_iflag = mp_obj_get_int(attrs->items[0]);\n    term.c_oflag = mp_obj_get_int(attrs->items[1]);\n    term.c_cflag = mp_obj_get_int(attrs->items[2]);\n    term.c_lflag = mp_obj_get_int(attrs->items[3]);\n\n    mp_obj_list_t *cc = MP_OBJ_TO_PTR(attrs->items[6]);\n    for (int i = 0; i < NCCS; i++) {\n        if (i == VMIN || i == VTIME) {\n            term.c_cc[i] = mp_obj_get_int(cc->items[i]);\n        } else {\n            term.c_cc[i] = *mp_obj_str_get_str(cc->items[i]);\n        }\n    }\n\n    int res = cfsetispeed(&term, mp_obj_get_int(attrs->items[4]));\n    RAISE_ERRNO(res, errno);\n    res = cfsetospeed(&term, mp_obj_get_int(attrs->items[5]));\n    RAISE_ERRNO(res, errno);\n\n    res = tcsetattr(fd, when, &term);\n    RAISE_ERRNO(res, errno);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_3(mod_termios_tcsetattr_obj, mod_termios_tcsetattr);\n\nstatic mp_obj_t mod_termios_setraw(mp_obj_t fd_in) {\n    struct termios term;\n    int fd = mp_obj_get_int(fd_in);\n    int res = tcgetattr(fd, &term);\n    RAISE_ERRNO(res, errno);\n\n    term.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n    term.c_oflag = 0;\n    term.c_cflag = (term.c_cflag & ~(CSIZE | PARENB)) | CS8;\n    term.c_lflag = 0;\n    term.c_cc[VMIN] = 1;\n    term.c_cc[VTIME] = 0;\n    res = tcsetattr(fd, TCSAFLUSH, &term);\n    RAISE_ERRNO(res, errno);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mod_termios_setraw_obj, mod_termios_setraw);\n\nstatic const mp_rom_map_elem_t mp_module_termios_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_termios) },\n    { MP_ROM_QSTR(MP_QSTR_tcgetattr), MP_ROM_PTR(&mod_termios_tcgetattr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_tcsetattr), MP_ROM_PTR(&mod_termios_tcsetattr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setraw), MP_ROM_PTR(&mod_termios_setraw_obj) },\n\n#define C(name) { MP_ROM_QSTR(MP_QSTR_##name), MP_ROM_INT(name) }\n    C(TCSANOW),\n\n    C(B9600),\n    #ifdef B57600\n    C(B57600),\n    #endif\n    #ifdef B115200\n    C(B115200),\n    #endif\n#undef C\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_termios_globals, mp_module_termios_globals_table);\n\nconst mp_obj_module_t mp_module_termios = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_termios_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_termios, mp_module_termios);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}