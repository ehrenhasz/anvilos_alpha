{
  "module_name": "mpthreadport.c",
  "hash_id": "7f41eed90d6a56d0ed0999743901f012a12645b0fb97d8b9355c3072c41d63c5",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/mpthreadport.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include \"py/runtime.h\"\n#include \"py/mpthread.h\"\n#include \"py/gc.h\"\n\n#if MICROPY_PY_THREAD\n\n#include <fcntl.h>\n#include <signal.h>\n#include <sched.h>\n#include <semaphore.h>\n\n#include \"shared/runtime/gchelper.h\"\n\n\n\n#ifdef SIGRTMIN\n#define MP_THREAD_GC_SIGNAL (SIGRTMIN + 5)\n#else\n#define MP_THREAD_GC_SIGNAL (SIGUSR1)\n#endif\n\n\n#define THREAD_STACK_OVERFLOW_MARGIN (8192)\n\n\ntypedef struct _mp_thread_t {\n    pthread_t id;           \n    int ready;              \n    void *arg;              \n    struct _mp_thread_t *next;\n} mp_thread_t;\n\nstatic pthread_key_t tls_key;\n\n\n\n\nstatic pthread_mutex_t thread_mutex;\nstatic mp_thread_t *thread;\n\n\n\n#if defined(__APPLE__)\nstatic char thread_signal_done_name[25];\nstatic sem_t *thread_signal_done_p;\n#else\nstatic sem_t thread_signal_done;\n#endif\n\nvoid mp_thread_unix_begin_atomic_section(void) {\n    pthread_mutex_lock(&thread_mutex);\n}\n\nvoid mp_thread_unix_end_atomic_section(void) {\n    pthread_mutex_unlock(&thread_mutex);\n}\n\n\nstatic void mp_thread_gc(int signo, siginfo_t *info, void *context) {\n    (void)info; \n    (void)context; \n    if (signo == MP_THREAD_GC_SIGNAL) {\n        gc_helper_collect_regs_and_stack();\n        \n        \n        \n        \n        #if MICROPY_ENABLE_PYSTACK\n        void **ptrs = (void **)(void *)MP_STATE_THREAD(pystack_start);\n        gc_collect_root(ptrs, (MP_STATE_THREAD(pystack_cur) - MP_STATE_THREAD(pystack_start)) / sizeof(void *));\n        #endif\n        #if defined(__APPLE__)\n        sem_post(thread_signal_done_p);\n        #else\n        sem_post(&thread_signal_done);\n        #endif\n    }\n}\n\nvoid mp_thread_init(void) {\n    pthread_key_create(&tls_key, NULL);\n    pthread_setspecific(tls_key, &mp_state_ctx.thread);\n\n    \n    \n    pthread_mutexattr_t thread_mutex_attr;\n    pthread_mutexattr_init(&thread_mutex_attr);\n    pthread_mutexattr_settype(&thread_mutex_attr, PTHREAD_MUTEX_RECURSIVE);\n    pthread_mutex_init(&thread_mutex, &thread_mutex_attr);\n\n    \n    thread = malloc(sizeof(mp_thread_t));\n    thread->id = pthread_self();\n    thread->ready = 1;\n    thread->arg = NULL;\n    thread->next = NULL;\n\n    #if defined(__APPLE__)\n    snprintf(thread_signal_done_name, sizeof(thread_signal_done_name), \"micropython_sem_%ld\", (long)thread->id);\n    thread_signal_done_p = sem_open(thread_signal_done_name, O_CREAT | O_EXCL, 0666, 0);\n    #else\n    sem_init(&thread_signal_done, 0, 0);\n    #endif\n\n    \n    struct sigaction sa;\n    sa.sa_flags = SA_SIGINFO;\n    sa.sa_sigaction = mp_thread_gc;\n    sigemptyset(&sa.sa_mask);\n    sigaction(MP_THREAD_GC_SIGNAL, &sa, NULL);\n}\n\nvoid mp_thread_deinit(void) {\n    mp_thread_unix_begin_atomic_section();\n    while (thread->next != NULL) {\n        mp_thread_t *th = thread;\n        thread = thread->next;\n        pthread_cancel(th->id);\n        free(th);\n    }\n    mp_thread_unix_end_atomic_section();\n    #if defined(__APPLE__)\n    sem_close(thread_signal_done_p);\n    sem_unlink(thread_signal_done_name);\n    #endif\n    assert(thread->id == pthread_self());\n    free(thread);\n}\n\n\n\n\n\n\n\nvoid mp_thread_gc_others(void) {\n    mp_thread_unix_begin_atomic_section();\n    for (mp_thread_t *th = thread; th != NULL; th = th->next) {\n        gc_collect_root(&th->arg, 1);\n        if (th->id == pthread_self()) {\n            continue;\n        }\n        if (!th->ready) {\n            continue;\n        }\n        pthread_kill(th->id, MP_THREAD_GC_SIGNAL);\n        #if defined(__APPLE__)\n        sem_wait(thread_signal_done_p);\n        #else\n        sem_wait(&thread_signal_done);\n        #endif\n    }\n    mp_thread_unix_end_atomic_section();\n}\n\nmp_state_thread_t *mp_thread_get_state(void) {\n    return (mp_state_thread_t *)pthread_getspecific(tls_key);\n}\n\nvoid mp_thread_set_state(mp_state_thread_t *state) {\n    pthread_setspecific(tls_key, state);\n}\n\nmp_uint_t mp_thread_get_id(void) {\n    return (mp_uint_t)pthread_self();\n}\n\nvoid mp_thread_start(void) {\n    \n    #if defined(__APPLE__)\n    if (mp_thread_is_realtime_enabled) {\n        mp_thread_set_realtime();\n    }\n    #endif\n\n    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n    mp_thread_unix_begin_atomic_section();\n    for (mp_thread_t *th = thread; th != NULL; th = th->next) {\n        if (th->id == pthread_self()) {\n            th->ready = 1;\n            break;\n        }\n    }\n    mp_thread_unix_end_atomic_section();\n}\n\nmp_uint_t mp_thread_create(void *(*entry)(void *), void *arg, size_t *stack_size) {\n    \n    if (*stack_size == 0) {\n        *stack_size = 8192 * sizeof(void *);\n    }\n\n    \n    if (*stack_size < PTHREAD_STACK_MIN) {\n        *stack_size = PTHREAD_STACK_MIN;\n    }\n\n    \n    if (*stack_size < 2 * THREAD_STACK_OVERFLOW_MARGIN) {\n        *stack_size = 2 * THREAD_STACK_OVERFLOW_MARGIN;\n    }\n\n    \n    pthread_attr_t attr;\n    int ret = pthread_attr_init(&attr);\n    if (ret != 0) {\n        goto er;\n    }\n    ret = pthread_attr_setstacksize(&attr, *stack_size);\n    if (ret != 0) {\n        goto er;\n    }\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    if (ret != 0) {\n        goto er;\n    }\n\n    mp_thread_unix_begin_atomic_section();\n\n    \n    pthread_t id;\n    ret = pthread_create(&id, &attr, entry, arg);\n    if (ret != 0) {\n        mp_thread_unix_end_atomic_section();\n        goto er;\n    }\n\n    \n    *stack_size -= THREAD_STACK_OVERFLOW_MARGIN;\n\n    \n    mp_thread_t *th = malloc(sizeof(mp_thread_t));\n    th->id = id;\n    th->ready = 0;\n    th->arg = arg;\n    th->next = thread;\n    thread = th;\n\n    mp_thread_unix_end_atomic_section();\n\n    MP_STATIC_ASSERT(sizeof(mp_uint_t) >= sizeof(pthread_t));\n    return (mp_uint_t)id;\n\ner:\n    mp_raise_OSError(ret);\n}\n\nvoid mp_thread_finish(void) {\n    mp_thread_unix_begin_atomic_section();\n    mp_thread_t *prev = NULL;\n    for (mp_thread_t *th = thread; th != NULL; th = th->next) {\n        if (th->id == pthread_self()) {\n            if (prev == NULL) {\n                thread = th->next;\n            } else {\n                prev->next = th->next;\n            }\n            free(th);\n            break;\n        }\n        prev = th;\n    }\n    mp_thread_unix_end_atomic_section();\n}\n\nvoid mp_thread_mutex_init(mp_thread_mutex_t *mutex) {\n    pthread_mutex_init(mutex, NULL);\n}\n\nint mp_thread_mutex_lock(mp_thread_mutex_t *mutex, int wait) {\n    int ret;\n    if (wait) {\n        ret = pthread_mutex_lock(mutex);\n        if (ret == 0) {\n            return 1;\n        }\n    } else {\n        ret = pthread_mutex_trylock(mutex);\n        if (ret == 0) {\n            return 1;\n        } else if (ret == EBUSY) {\n            return 0;\n        }\n    }\n    return -ret;\n}\n\nvoid mp_thread_mutex_unlock(mp_thread_mutex_t *mutex) {\n    pthread_mutex_unlock(mutex);\n    \n}\n\n#endif \n\n\n\n#if defined(__APPLE__)\n#include <mach/mach_error.h>\n#include <mach/mach_time.h>\n#include <mach/thread_act.h>\n#include <mach/thread_policy.h>\n\nbool mp_thread_is_realtime_enabled;\n\n\nvoid mp_thread_set_realtime(void) {\n    mach_timebase_info_data_t timebase_info;\n\n    mach_timebase_info(&timebase_info);\n\n    const uint64_t NANOS_PER_MSEC = 1000000ULL;\n    double clock2abs = ((double)timebase_info.denom / (double)timebase_info.numer) * NANOS_PER_MSEC;\n\n    thread_time_constraint_policy_data_t policy;\n    policy.period = 0;\n    policy.computation = (uint32_t)(5 * clock2abs); \n    policy.constraint = (uint32_t)(10 * clock2abs);\n    policy.preemptible = FALSE;\n\n    int kr = thread_policy_set(pthread_mach_thread_np(pthread_self()),\n        THREAD_TIME_CONSTRAINT_POLICY,\n        (thread_policy_t)&policy,\n        THREAD_TIME_CONSTRAINT_POLICY_COUNT);\n\n    if (kr != KERN_SUCCESS) {\n        mach_error(\"thread_policy_set:\", kr);\n    }\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}