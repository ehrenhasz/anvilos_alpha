{
  "module_name": "modjni.c",
  "hash_id": "03518da78e3d25ddc930459eb90e7e0c0c6aa107c3a60d28688ae077ac958c1d",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/modjni.c",
  "human_readable_source": " \n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n\n#if MICROPY_PY_JNI\n\n#include <assert.h>\n#include <string.h>\n#include <errno.h>\n#include <dlfcn.h>\n#include <ctype.h>\n\n#include <jni.h>\n\n#define JJ(call, ...) (*env)->call(env, __VA_ARGS__)\n#define JJ1(call) (*env)->call(env)\n#define MATCH(s, static) (!strncmp(s, static, sizeof(static) - 1))\n\nstatic JavaVM *jvm;\nstatic JNIEnv *env;\nstatic jclass Class_class;\nstatic jclass String_class;\nstatic jmethodID Class_getName_mid;\nstatic jmethodID Class_getField_mid;\nstatic jmethodID Class_getMethods_mid;\nstatic jmethodID Class_getConstructors_mid;\nstatic jmethodID Method_getName_mid;\nstatic jmethodID Object_toString_mid;\n\nstatic jclass List_class;\nstatic jmethodID List_get_mid;\nstatic jmethodID List_set_mid;\nstatic jmethodID List_size_mid;\n\nstatic jclass IndexException_class;\n\nstatic const mp_obj_type_t jobject_type;\nstatic const mp_obj_type_t jmethod_type;\n\nstatic mp_obj_t new_jobject(jobject jo);\nstatic mp_obj_t new_jclass(jclass jc);\nstatic mp_obj_t call_method(jobject obj, const char *name, jarray methods, bool is_constr, size_t n_args, const mp_obj_t *args);\nstatic bool py2jvalue(const char **jtypesig, mp_obj_t arg, jvalue *out);\n\ntypedef struct _mp_obj_jclass_t {\n    mp_obj_base_t base;\n    jclass cls;\n} mp_obj_jclass_t;\n\ntypedef struct _mp_obj_jobject_t {\n    mp_obj_base_t base;\n    jobject obj;\n} mp_obj_jobject_t;\n\ntypedef struct _mp_obj_jmethod_t {\n    mp_obj_base_t base;\n    jobject obj;\n    jmethodID meth;\n    qstr name;\n    bool is_static;\n} mp_obj_jmethod_t;\n\n\n\nstatic bool is_object_type(const char *jtypesig) {\n    while (*jtypesig != ' ' && *jtypesig) {\n        if (*jtypesig == '.') {\n            return true;\n        }\n        jtypesig++;\n    }\n    return false;\n}\n\nstatic void check_exception(void) {\n    jobject exc = JJ1(ExceptionOccurred);\n    if (exc) {\n        \n        mp_obj_t py_e = new_jobject(exc);\n        JJ1(ExceptionClear);\n        if (JJ(IsInstanceOf, exc, IndexException_class)) {\n            mp_raise_type_arg(&mp_type_IndexError, py_e);\n        }\n        mp_raise_type_arg(&mp_type_Exception, py_e);\n    }\n}\n\nstatic void print_jobject(const mp_print_t *print, jobject obj) {\n    jobject str_o = JJ(CallObjectMethod, obj, Object_toString_mid);\n    const char *str = JJ(GetStringUTFChars, str_o, NULL);\n    mp_printf(print, str);\n    JJ(ReleaseStringUTFChars, str_o, str);\n}\n\n\n\nstatic void jclass_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mp_obj_jclass_t *self = MP_OBJ_TO_PTR(self_in);\n    if (kind == PRINT_REPR) {\n        mp_printf(print, \"<jclass @%p \\\"\", self->cls);\n    }\n    print_jobject(print, self->cls);\n    if (kind == PRINT_REPR) {\n        mp_printf(print, \"\\\">\");\n    }\n}\n\nstatic void jclass_attr(mp_obj_t self_in, qstr attr_in, mp_obj_t *dest) {\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        mp_obj_jclass_t *self = MP_OBJ_TO_PTR(self_in);\n        const char *attr = qstr_str(attr_in);\n\n        jstring field_name = JJ(NewStringUTF, attr);\n        jobject field = JJ(CallObjectMethod, self->cls, Class_getField_mid, field_name);\n        if (!JJ1(ExceptionCheck)) {\n            jfieldID field_id = JJ(FromReflectedField, field);\n            jobject obj = JJ(GetStaticObjectField, self->cls, field_id);\n            dest[0] = new_jobject(obj);\n            return;\n        }\n        \n        JJ1(ExceptionClear);\n\n        mp_obj_jmethod_t *o = mp_obj_malloc(mp_obj_jmethod_t, &jmethod_type);\n        o->name = attr_in;\n        o->meth = NULL;\n        o->obj = self->cls;\n        o->is_static = true;\n        dest[0] = MP_OBJ_FROM_PTR(o);\n    }\n}\n\nstatic mp_obj_t jclass_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    if (n_kw != 0) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"kwargs not supported\"));\n    }\n    mp_obj_jclass_t *self = MP_OBJ_TO_PTR(self_in);\n\n    jarray methods = JJ(CallObjectMethod, self->cls, Class_getConstructors_mid);\n\n    return call_method(self->cls, NULL, methods, true, n_args, args);\n}\n\nstatic const mp_rom_map_elem_t jclass_locals_dict_table[] = {\n\n\n};\n\nstatic MP_DEFINE_CONST_DICT(jclass_locals_dict, jclass_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    jclass_type,\n    MP_QSTR_jclass,\n    MP_TYPE_FLAG_NONE,\n    print, jclass_print,\n    attr, jclass_attr,\n    call, jclass_call,\n    locals_dict, &jclass_locals_dict\n    );\n\nstatic mp_obj_t new_jclass(jclass jc) {\n    mp_obj_jclass_t *o = mp_obj_malloc(mp_obj_jclass_t, &jclass_type);\n    o->cls = jc;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n\n\nstatic void jobject_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mp_obj_jobject_t *self = MP_OBJ_TO_PTR(self_in);\n    if (kind == PRINT_REPR) {\n        mp_printf(print, \"<jobject @%p \\\"\", self->obj);\n    }\n    print_jobject(print, self->obj);\n    if (kind == PRINT_REPR) {\n        mp_printf(print, \"\\\">\");\n    }\n}\n\nstatic void jobject_attr(mp_obj_t self_in, qstr attr_in, mp_obj_t *dest) {\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        mp_obj_jobject_t *self = MP_OBJ_TO_PTR(self_in);\n\n        const char *attr = qstr_str(attr_in);\n        jclass obj_class = JJ(GetObjectClass, self->obj);\n        jstring field_name = JJ(NewStringUTF, attr);\n        jobject field = JJ(CallObjectMethod, obj_class, Class_getField_mid, field_name);\n        JJ(DeleteLocalRef, field_name);\n        JJ(DeleteLocalRef, obj_class);\n        if (!JJ1(ExceptionCheck)) {\n            jfieldID field_id = JJ(FromReflectedField, field);\n            JJ(DeleteLocalRef, field);\n            jobject obj = JJ(GetObjectField, self->obj, field_id);\n            dest[0] = new_jobject(obj);\n            return;\n        }\n        \n        JJ1(ExceptionClear);\n\n        mp_obj_jmethod_t *o = mp_obj_malloc(mp_obj_jmethod_t, &jmethod_type);\n        o->name = attr_in;\n        o->meth = NULL;\n        o->obj = self->obj;\n        o->is_static = false;\n        dest[0] = MP_OBJ_FROM_PTR(o);\n    }\n}\n\nstatic void get_jclass_name(jobject obj, char *buf) {\n    jclass obj_class = JJ(GetObjectClass, obj);\n    jstring name = JJ(CallObjectMethod, obj_class, Class_getName_mid);\n    jint len = JJ(GetStringLength, name);\n    JJ(GetStringUTFRegion, name, 0, len, buf);\n    check_exception();\n}\n\nstatic mp_obj_t jobject_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    mp_obj_jobject_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_uint_t idx = mp_obj_get_int(index);\n    char class_name[64];\n    get_jclass_name(self->obj, class_name);\n    \n\n    if (class_name[0] == '[') {\n        if (class_name[1] == 'L' || class_name[1] == '[') {\n            if (value == MP_OBJ_NULL) {\n                \n                assert(0);\n            } else if (value == MP_OBJ_SENTINEL) {\n                \n                jobject el = JJ(GetObjectArrayElement, self->obj, idx);\n                return new_jobject(el);\n            } else {\n                \n                jvalue jval;\n                const char *t = class_name + 1;\n                py2jvalue(&t, value, &jval);\n                JJ(SetObjectArrayElement, self->obj, idx, jval.l);\n                return mp_const_none;\n            }\n        }\n        mp_raise_NotImplementedError(NULL);\n    }\n\n    if (!JJ(IsInstanceOf, self->obj, List_class)) {\n        return MP_OBJ_NULL;\n    }\n\n\n    if (value == MP_OBJ_NULL) {\n        \n        assert(0);\n    } else if (value == MP_OBJ_SENTINEL) {\n        \n        jobject el = JJ(CallObjectMethod, self->obj, List_get_mid, idx);\n        check_exception();\n        return new_jobject(el);\n    } else {\n        \n        assert(0);\n    }\n\n\n    return MP_OBJ_NULL;\n}\n\nstatic mp_obj_t jobject_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_jobject_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n        case MP_UNARY_OP_LEN: {\n            jint len = JJ(CallIntMethod, self->obj, List_size_mid);\n            if (op == MP_UNARY_OP_BOOL) {\n                return mp_obj_new_bool(len != 0);\n            }\n            return MP_OBJ_NEW_SMALL_INT(len);\n        }\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\n\n\nstatic mp_obj_t subscr_load_adaptor(mp_obj_t self_in, mp_obj_t index_in) {\n    return mp_obj_subscr(self_in, index_in, MP_OBJ_SENTINEL);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(subscr_load_adaptor_obj, subscr_load_adaptor);\n\n\n\nstatic mp_obj_t subscr_getiter(mp_obj_t self_in, mp_obj_iter_buf_t *iter_buf) {\n    mp_obj_t dest[2] = {MP_OBJ_FROM_PTR(&subscr_load_adaptor_obj), self_in};\n    return mp_obj_new_getitem_iter(dest, iter_buf);\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    jobject_type,\n    MP_QSTR_jobject,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    print, jobject_print,\n    unary_op, jobject_unary_op,\n    attr, jobject_attr,\n    subscr, jobject_subscr,\n    iter, subscr_getiter\n    );\n\nstatic mp_obj_t new_jobject(jobject jo) {\n    if (jo == NULL) {\n        return mp_const_none;\n    } else if (JJ(IsInstanceOf, jo, String_class)) {\n        const char *s = JJ(GetStringUTFChars, jo, NULL);\n        mp_obj_t ret = mp_obj_new_str(s, strlen(s));\n        JJ(ReleaseStringUTFChars, jo, s);\n        return ret;\n    } else if (JJ(IsInstanceOf, jo, Class_class)) {\n        return new_jclass(jo);\n    } else {\n        mp_obj_jobject_t *o = mp_obj_malloc(mp_obj_jobject_t, &jobject_type);\n        o->obj = jo;\n        return MP_OBJ_FROM_PTR(o);\n    }\n\n}\n\n\n\n\nstatic void jmethod_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_jmethod_t *self = MP_OBJ_TO_PTR(self_in);\n    \n    mp_printf(print, \"<jmethod '%s'>\", qstr_str(self->name));\n}\n\n#define IMATCH(s, static) ((!strncmp(s, static, sizeof(static) - 1)) && (s += sizeof(static) - 1))\n\n#define CHECK_TYPE(java_type_name) \\\n    if (strncmp(arg_type, java_type_name, sizeof(java_type_name) - 1) != 0) { \\\n        return false; \\\n    } \\\n    arg_type += sizeof(java_type_name) - 1;\n\nstatic const char *strprev(const char *s, char c) {\n    while (*s != c) {\n        s--;\n    }\n    return s;\n}\n\nstatic bool py2jvalue(const char **jtypesig, mp_obj_t arg, jvalue *out) {\n    const char *arg_type = *jtypesig;\n    const mp_obj_type_t *type = mp_obj_get_type(arg);\n\n    if (type == &mp_type_str) {\n        if (IMATCH(arg_type, \"java.lang.String\") || IMATCH(arg_type, \"java.lang.Object\")) {\n            out->l = JJ(NewStringUTF, mp_obj_str_get_str(arg));\n        } else {\n            return false;\n        }\n    } else if (type == &mp_type_int) {\n        if (IMATCH(arg_type, \"int\") || IMATCH(arg_type, \"long\")) {\n            \n            out->j = mp_obj_get_int(arg);\n        } else {\n            return false;\n        }\n    } else if (type == &jobject_type) {\n        bool is_object = false;\n        const char *expected_type = arg_type;\n        while (1) {\n            if (isalpha(*arg_type)) {\n            } else if (*arg_type == '.') {\n                is_object = true;\n            } else {\n                break;\n            }\n            arg_type++;\n        }\n        if (!is_object) {\n            return false;\n        }\n        mp_obj_jobject_t *jo = MP_OBJ_TO_PTR(arg);\n        if (!MATCH(expected_type, \"java.lang.Object\")) {\n            char class_name[64];\n            get_jclass_name(jo->obj, class_name);\n            \n            if (strcmp(class_name, expected_type) != 0) {\n                return false;\n            }\n        }\n        out->l = jo->obj;\n    } else if (type == &mp_type_bool) {\n        if (IMATCH(arg_type, \"boolean\")) {\n            out->z = arg == mp_const_true;\n        } else {\n            return false;\n        }\n    } else if (arg == mp_const_none) {\n        \n        while (isalpha(*arg_type) || *arg_type == '.') {\n            arg_type++;\n        }\n        out->l = NULL;\n    } else {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"arg type not supported\"));\n    }\n\n    *jtypesig = arg_type;\n    return true;\n}\n\n#if 0\n\n\n\n\nstatic mp_obj_t jvalue2py(const char *jtypesig, jobject arg) {\n    if (arg == NULL || MATCH(jtypesig, \"void\")) {\n        return mp_const_none;\n    } else if (MATCH(jtypesig, \"boolean\")) {\n        return mp_obj_new_bool((bool)arg);\n    } else if (MATCH(jtypesig, \"int\")) {\n        return mp_obj_new_int((mp_int_t)arg);\n    } else if (is_object_type(jtypesig)) {\n        \n        return new_jobject(arg);\n    }\n\n    printf(\"Unknown return type: %s\\n\", jtypesig);\n\n    return MP_OBJ_NULL;\n}\n#endif\n\nstatic mp_obj_t call_method(jobject obj, const char *name, jarray methods, bool is_constr, size_t n_args, const mp_obj_t *args) {\n    jvalue jargs[n_args];\n\n    jsize num_methods = JJ(GetArrayLength, methods);\n    for (int i = 0; i < num_methods; i++) {\n        jobject meth = JJ(GetObjectArrayElement, methods, i);\n        jobject name_o = JJ(CallObjectMethod, meth, Object_toString_mid);\n        const char *decl = JJ(GetStringUTFChars, name_o, NULL);\n        const char *arg_types = strchr(decl, '(') + 1;\n        \n\n\n        const char *meth_name = NULL;\n        const char *ret_type = NULL;\n        if (!is_constr) {\n            meth_name = strprev(arg_types, '.') + 1;\n            ret_type = strprev(meth_name, ' ') - 1;\n            ret_type = strprev(ret_type, ' ') + 1;\n\n            int name_len = strlen(name);\n            if (strncmp(name, meth_name, name_len  ) || meth_name[name_len] != '('  ) {\n                goto next_method;\n            }\n        }\n\n\n\n\n        bool found = true;\n        for (size_t j = 0; j < n_args && *arg_types != ')'; j++) {\n            if (!py2jvalue(&arg_types, args[j], &jargs[j])) {\n                goto next_method;\n            }\n\n            if (*arg_types == ',') {\n                arg_types++;\n            }\n        }\n\n        if (*arg_types != ')') {\n            goto next_method;\n        }\n\n        if (found) {\n\n            jmethodID method_id = JJ(FromReflectedMethod, meth);\n            if (is_constr) {\n                JJ(ReleaseStringUTFChars, name_o, decl);\n                jobject res = JJ(NewObjectA, obj, method_id, jargs);\n                return new_jobject(res);\n            } else {\n                mp_obj_t ret;\n                if (MATCH(ret_type, \"void\")) {\n                    JJ(CallVoidMethodA, obj, method_id, jargs);\n                    check_exception();\n                    ret = mp_const_none;\n                } else if (MATCH(ret_type, \"int\")) {\n                    jint res = JJ(CallIntMethodA, obj, method_id, jargs);\n                    check_exception();\n                    ret = mp_obj_new_int(res);\n                } else if (MATCH(ret_type, \"boolean\")) {\n                    jboolean res = JJ(CallBooleanMethodA, obj, method_id, jargs);\n                    check_exception();\n                    ret = mp_obj_new_bool(res);\n                } else if (is_object_type(ret_type)) {\n                    jobject res = JJ(CallObjectMethodA, obj, method_id, jargs);\n                    check_exception();\n                    ret = new_jobject(res);\n                } else {\n                    JJ(ReleaseStringUTFChars, name_o, decl);\n                    mp_raise_TypeError(MP_ERROR_TEXT(\"can't handle return type\"));\n                }\n\n                JJ(ReleaseStringUTFChars, name_o, decl);\n                JJ(DeleteLocalRef, name_o);\n                JJ(DeleteLocalRef, meth);\n                return ret;\n            }\n        }\n\n    next_method:\n        JJ(ReleaseStringUTFChars, name_o, decl);\n        JJ(DeleteLocalRef, name_o);\n        JJ(DeleteLocalRef, meth);\n    }\n\n    mp_raise_TypeError(MP_ERROR_TEXT(\"method not found\"));\n}\n\n\nstatic mp_obj_t jmethod_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    if (n_kw != 0) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"kwargs not supported\"));\n    }\n    mp_obj_jmethod_t *self = MP_OBJ_TO_PTR(self_in);\n\n    const char *name = qstr_str(self->name);\n\n\n    jclass obj_class = self->obj;\n    if (!self->is_static) {\n        obj_class = JJ(GetObjectClass, self->obj);\n    }\n    jarray methods = JJ(CallObjectMethod, obj_class, Class_getMethods_mid);\n\n    return call_method(self->obj, name, methods, false, n_args, args);\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    jmethod_type,\n    MP_QSTR_jmethod,\n    MP_TYPE_FLAG_NONE,\n    print, jmethod_print,\n    call, jmethod_call\n    );\n\n#ifdef __ANDROID__\n#define LIBJVM_SO \"libdvm.so\"\n#else\n#define LIBJVM_SO \"libjvm.so\"\n#endif\n\nstatic void create_jvm(void) {\n    JavaVMInitArgs args;\n    JavaVMOption options;\n    options.optionString = \"-Djava.class.path=.\";\n    args.version = JNI_VERSION_1_6;\n    args.nOptions = 1;\n    args.options = &options;\n    args.ignoreUnrecognized = 0;\n\n    if (env) {\n        return;\n    }\n\n    void *libjvm = dlopen(LIBJVM_SO, RTLD_NOW | RTLD_GLOBAL);\n    if (!libjvm) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"unable to load libjvm.so, use LD_LIBRARY_PATH\"));\n    }\n    int (*_JNI_CreateJavaVM)(void *, void **, void *) = dlsym(libjvm, \"JNI_CreateJavaVM\");\n\n    int st = _JNI_CreateJavaVM(&jvm, (void **)&env, &args);\n    if (st < 0 || !env) {\n        mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"unable to create JVM\"));\n    }\n\n    Class_class = JJ(FindClass, \"java/lang/Class\");\n    jclass method_class = JJ(FindClass, \"java/lang/reflect/Method\");\n    String_class = JJ(FindClass, \"java/lang/String\");\n\n    jclass Object_class = JJ(FindClass, \"java/lang/Object\");\n    Object_toString_mid = JJ(GetMethodID, Object_class, \"toString\",\n        MP_COMPRESSED_ROM_TEXT(\"()Ljava/lang/String;\"));\n\n    Class_getName_mid = (*env)->GetMethodID(env, Class_class, \"getName\",\n        MP_COMPRESSED_ROM_TEXT(\"()Ljava/lang/String;\"));\n    Class_getField_mid = (*env)->GetMethodID(env, Class_class, \"getField\",\n        MP_COMPRESSED_ROM_TEXT(\"(Ljava/lang/String;)Ljava/lang/reflect/Field;\"));\n    Class_getMethods_mid = (*env)->GetMethodID(env, Class_class, \"getMethods\",\n        MP_COMPRESSED_ROM_TEXT(\"()[Ljava/lang/reflect/Method;\"));\n    Class_getConstructors_mid = (*env)->GetMethodID(env, Class_class, \"getConstructors\",\n        MP_COMPRESSED_ROM_TEXT(\"()[Ljava/lang/reflect/Constructor;\"));\n    Method_getName_mid = (*env)->GetMethodID(env, method_class, \"getName\",\n        MP_COMPRESSED_ROM_TEXT(\"()Ljava/lang/String;\"));\n\n    List_class = JJ(FindClass, \"java/util/List\");\n    List_get_mid = JJ(GetMethodID, List_class, \"get\",\n        MP_COMPRESSED_ROM_TEXT(\"(I)Ljava/lang/Object;\"));\n    List_set_mid = JJ(GetMethodID, List_class, \"set\",\n        MP_COMPRESSED_ROM_TEXT(\"(ILjava/lang/Object;)Ljava/lang/Object;\"));\n    List_size_mid = JJ(GetMethodID, List_class, \"size\",\n        MP_COMPRESSED_ROM_TEXT(\"()I\"));\n    IndexException_class = JJ(FindClass, \"java/lang/IndexOutOfBoundsException\");\n}\n\nstatic mp_obj_t mod_jni_cls(mp_obj_t cls_name_in) {\n    const char *cls_name = mp_obj_str_get_str(cls_name_in);\n    if (!env) {\n        create_jvm();\n    }\n    jclass cls = JJ(FindClass, cls_name);\n\n    mp_obj_jclass_t *o = mp_obj_malloc(mp_obj_jclass_t, &jclass_type);\n    o->cls = cls;\n    return MP_OBJ_FROM_PTR(o);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mod_jni_cls_obj, mod_jni_cls);\n\nstatic mp_obj_t mod_jni_array(mp_obj_t type_in, mp_obj_t size_in) {\n    if (!env) {\n        create_jvm();\n    }\n    mp_int_t size = mp_obj_get_int(size_in);\n    jobject res = NULL;\n\n    if (mp_obj_is_type(type_in, &jclass_type)) {\n\n        mp_obj_jclass_t *jcls = MP_OBJ_TO_PTR(type_in);\n        res = JJ(NewObjectArray, size, jcls->cls, NULL);\n\n    } else if (mp_obj_is_str(type_in)) {\n        const char *type = mp_obj_str_get_str(type_in);\n        switch (*type) {\n            case 'Z':\n                res = JJ(NewBooleanArray, size);\n                break;\n            case 'B':\n                res = JJ(NewByteArray, size);\n                break;\n            case 'C':\n                res = JJ(NewCharArray, size);\n                break;\n            case 'S':\n                res = JJ(NewShortArray, size);\n                break;\n            case 'I':\n                res = JJ(NewIntArray, size);\n                break;\n            case 'J':\n                res = JJ(NewLongArray, size);\n                break;\n            case 'F':\n                res = JJ(NewFloatArray, size);\n                break;\n            case 'D':\n                res = JJ(NewDoubleArray, size);\n                break;\n        }\n\n    }\n\n    return new_jobject(res);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mod_jni_array_obj, mod_jni_array);\n\n\nstatic mp_obj_t mod_jni_env(void) {\n    return mp_obj_new_int((mp_int_t)(uintptr_t)env);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mod_jni_env_obj, mod_jni_env);\n\nstatic const mp_rom_map_elem_t mp_module_jni_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_jni) },\n    { MP_ROM_QSTR(MP_QSTR_cls), MP_ROM_PTR(&mod_jni_cls_obj) },\n    { MP_ROM_QSTR(MP_QSTR_array), MP_ROM_PTR(&mod_jni_array_obj) },\n    { MP_ROM_QSTR(MP_QSTR_env), MP_ROM_PTR(&mod_jni_env_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_jni_globals, mp_module_jni_globals_table);\n\nconst mp_obj_module_t mp_module_jni = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_jni_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_jni, mp_module_jni);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}