{
  "module_name": "unix_mphal.c",
  "hash_id": "40e9ee48f16ba60c779c53175c7c3c21d546cc336a9f616a4e07a85141c919fb",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/unix_mphal.c",
  "human_readable_source": " \n\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/time.h>\n#include <fcntl.h>\n\n#include \"py/mphal.h\"\n#include \"py/mpthread.h\"\n#include \"py/runtime.h\"\n#include \"extmod/misc.h\"\n\n#if defined(__GLIBC__) && defined(__GLIBC_PREREQ)\n#if __GLIBC_PREREQ(2, 25)\n#include <sys/random.h>\n#define _HAVE_GETRANDOM\n#endif\n#endif\n\n#ifndef _WIN32\n#include <signal.h>\n\nstatic void sighandler(int signum) {\n    if (signum == SIGINT) {\n        #if MICROPY_ASYNC_KBD_INTR\n        #if MICROPY_PY_THREAD_GIL\n        \n        \n        #error \"MICROPY_ASYNC_KBD_INTR and MICROPY_PY_THREAD_GIL are not compatible\"\n        #endif\n        mp_obj_exception_clear_traceback(MP_OBJ_FROM_PTR(&MP_STATE_VM(mp_kbd_exception)));\n        sigset_t mask;\n        sigemptyset(&mask);\n        \n        \n        sigprocmask(SIG_SETMASK, &mask, NULL);\n        nlr_raise(MP_OBJ_FROM_PTR(&MP_STATE_VM(mp_kbd_exception)));\n        #else\n        if (0) { \n            \n            exit(1);\n        }\n        mp_sched_keyboard_interrupt();\n        #endif\n    }\n}\n#endif\n\nvoid mp_hal_set_interrupt_char(char c) {\n    \n    if (c == CHAR_CTRL_C) {\n        #ifndef _WIN32\n        \n        struct sigaction sa;\n        sa.sa_flags = 0;\n        sa.sa_handler = sighandler;\n        sigemptyset(&sa.sa_mask);\n        sigaction(SIGINT, &sa, NULL);\n        #endif\n    } else {\n        #ifndef _WIN32\n        \n        struct sigaction sa;\n        sa.sa_flags = 0;\n        sa.sa_handler = SIG_DFL;\n        sigemptyset(&sa.sa_mask);\n        sigaction(SIGINT, &sa, NULL);\n        #endif\n    }\n}\n\n#if MICROPY_USE_READLINE == 1\n\n#include <termios.h>\n\nstatic struct termios orig_termios;\n\nvoid mp_hal_stdio_mode_raw(void) {\n    \n    tcgetattr(0, &orig_termios);\n    static struct termios termios;\n    termios = orig_termios;\n    termios.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n    termios.c_cflag = (termios.c_cflag & ~(CSIZE | PARENB)) | CS8;\n    termios.c_lflag = 0;\n    termios.c_cc[VMIN] = 1;\n    termios.c_cc[VTIME] = 0;\n    tcsetattr(0, TCSAFLUSH, &termios);\n}\n\nvoid mp_hal_stdio_mode_orig(void) {\n    \n    tcsetattr(0, TCSAFLUSH, &orig_termios);\n}\n\n#endif\n\n#if MICROPY_PY_OS_DUPTERM\nstatic int call_dupterm_read(size_t idx) {\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_obj_t read_m[3];\n        mp_load_method(MP_STATE_VM(dupterm_objs[idx]), MP_QSTR_read, read_m);\n        read_m[2] = MP_OBJ_NEW_SMALL_INT(1);\n        mp_obj_t res = mp_call_method_n_kw(1, 0, read_m);\n        if (res == mp_const_none) {\n            return -2;\n        }\n        mp_buffer_info_t bufinfo;\n        mp_get_buffer_raise(res, &bufinfo, MP_BUFFER_READ);\n        if (bufinfo.len == 0) {\n            mp_printf(&mp_plat_print, \"dupterm: EOF received, deactivating\\n\");\n            MP_STATE_VM(dupterm_objs[idx]) = MP_OBJ_NULL;\n            return -1;\n        }\n        nlr_pop();\n        return *(byte *)bufinfo.buf;\n    } else {\n        \n        mp_obj_t save_term = MP_STATE_VM(dupterm_objs[idx]);\n        MP_STATE_VM(dupterm_objs[idx]) = NULL;\n        mp_printf(&mp_plat_print, \"dupterm: \");\n        mp_obj_print_exception(&mp_plat_print, nlr.ret_val);\n        MP_STATE_VM(dupterm_objs[idx]) = save_term;\n    }\n\n    return -1;\n}\n#endif\n\nint mp_hal_stdin_rx_chr(void) {\n    #if MICROPY_PY_OS_DUPTERM\n    \n    if (MP_STATE_VM(dupterm_objs[0]) != MP_OBJ_NULL) {\n        int c;\n        do {\n            c = call_dupterm_read(0);\n        } while (c == -2);\n        if (c == -1) {\n            goto main_term;\n        }\n        if (c == '\\n') {\n            c = '\\r';\n        }\n        return c;\n    }\nmain_term:;\n    #endif\n\n    unsigned char c;\n    ssize_t ret;\n    MP_HAL_RETRY_SYSCALL(ret, read(STDIN_FILENO, &c, 1), {});\n    if (ret == 0) {\n        c = 4; \n    } else if (c == '\\n') {\n        c = '\\r';\n    }\n    return c;\n}\n\nmp_uint_t mp_hal_stdout_tx_strn(const char *str, size_t len) {\n    ssize_t ret;\n    MP_HAL_RETRY_SYSCALL(ret, write(STDOUT_FILENO, str, len), {});\n    mp_uint_t written = ret < 0 ? 0 : ret;\n    int dupterm_res = mp_os_dupterm_tx_strn(str, len);\n    if (dupterm_res >= 0) {\n        written = MIN((mp_uint_t)dupterm_res, written);\n    }\n    return written;\n}\n\n\nvoid mp_hal_stdout_tx_strn_cooked(const char *str, size_t len) {\n    mp_hal_stdout_tx_strn(str, len);\n}\n\nvoid mp_hal_stdout_tx_str(const char *str) {\n    mp_hal_stdout_tx_strn(str, strlen(str));\n}\n\n#ifndef mp_hal_ticks_ms\nmp_uint_t mp_hal_ticks_ms(void) {\n    #if (defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0) && defined(_POSIX_MONOTONIC_CLOCK)\n    struct timespec tv;\n    clock_gettime(CLOCK_MONOTONIC, &tv);\n    return tv.tv_sec * 1000 + tv.tv_nsec / 1000000;\n    #else\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec * 1000 + tv.tv_usec / 1000;\n    #endif\n}\n#endif\n\n#ifndef mp_hal_ticks_us\nmp_uint_t mp_hal_ticks_us(void) {\n    #if (defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0) && defined(_POSIX_MONOTONIC_CLOCK)\n    struct timespec tv;\n    clock_gettime(CLOCK_MONOTONIC, &tv);\n    return tv.tv_sec * 1000000 + tv.tv_nsec / 1000;\n    #else\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return tv.tv_sec * 1000000 + tv.tv_usec;\n    #endif\n}\n#endif\n\n#ifndef mp_hal_time_ns\nuint64_t mp_hal_time_ns(void) {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (uint64_t)tv.tv_sec * 1000000000ULL + (uint64_t)tv.tv_usec * 1000ULL;\n}\n#endif\n\n#ifndef mp_hal_delay_ms\nvoid mp_hal_delay_ms(mp_uint_t ms) {\n    mp_uint_t start = mp_hal_ticks_ms();\n    while (mp_hal_ticks_ms() - start < ms) {\n        mp_event_wait_ms(1);\n    }\n}\n#endif\n\nvoid mp_hal_get_random(size_t n, void *buf) {\n    #ifdef _HAVE_GETRANDOM\n    RAISE_ERRNO(getrandom(buf, n, 0), errno);\n    #else\n    int fd = open(\"/dev/random\", O_RDONLY);\n    RAISE_ERRNO(fd, errno);\n    RAISE_ERRNO(read(fd, buf, n), errno);\n    close(fd);\n    #endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}