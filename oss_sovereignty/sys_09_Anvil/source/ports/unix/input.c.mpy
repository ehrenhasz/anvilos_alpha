{
  "module_name": "input.c",
  "hash_id": "b0120ea11b0497e5b3db9d97f1c9766deb717ef5b1999140e4f9375bb07a7d17",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/unix/input.c",
  "human_readable_source": " \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n\n#include \"py/mpstate.h\"\n#include \"py/mphal.h\"\n#include \"input.h\"\n\n#if MICROPY_USE_READLINE == 1\n#include \"shared/readline/readline.h\"\n#endif\n\n#if MICROPY_USE_READLINE == 0\nchar *prompt(char *p) {\n    \n    static char buf[256];\n    fputs(p, stdout);\n    fflush(stdout);\n    char *s = fgets(buf, sizeof(buf), stdin);\n    if (!s) {\n        return NULL;\n    }\n    int l = strlen(buf);\n    if (buf[l - 1] == '\\n') {\n        buf[l - 1] = 0;\n    } else {\n        l++;\n    }\n    char *line = malloc(l);\n    memcpy(line, buf, l);\n    return line;\n}\n#endif\n\nvoid prompt_read_history(void) {\n    #if MICROPY_USE_READLINE_HISTORY\n    #if MICROPY_USE_READLINE == 1\n    readline_init0(); \n    char *home = getenv(\"HOME\");\n    if (home != NULL) {\n        vstr_t vstr;\n        vstr_init(&vstr, 50);\n        vstr_printf(&vstr, \"%s/.micropython.history\", home);\n        int fd = open(vstr_null_terminated_str(&vstr), O_RDONLY);\n        if (fd != -1) {\n            vstr_reset(&vstr);\n            for (;;) {\n                char c;\n                int sz = read(fd, &c, 1);\n                if (sz < 0) {\n                    if (errno == EINTR) {\n                        continue;\n                    }\n                    break;\n                }\n                if (sz == 0 || c == '\\n') {\n                    readline_push_history(vstr_null_terminated_str(&vstr));\n                    if (sz == 0) {\n                        break;\n                    }\n                    vstr_reset(&vstr);\n                } else {\n                    vstr_add_byte(&vstr, c);\n                }\n            }\n            close(fd);\n        }\n        vstr_clear(&vstr);\n    }\n    #endif\n    #endif\n}\n\nvoid prompt_write_history(void) {\n    #if MICROPY_USE_READLINE_HISTORY\n    #if MICROPY_USE_READLINE == 1\n    char *home = getenv(\"HOME\");\n    if (home != NULL) {\n        vstr_t vstr;\n        vstr_init(&vstr, 50);\n        vstr_printf(&vstr, \"%s/.micropython.history\", home);\n        int fd = open(vstr_null_terminated_str(&vstr), O_CREAT | O_TRUNC | O_WRONLY, 0644);\n        if (fd != -1) {\n            for (int i = MP_ARRAY_SIZE(MP_STATE_PORT(readline_hist)) - 1; i >= 0; i--) {\n                const char *line = MP_STATE_PORT(readline_hist)[i];\n                if (line != NULL) {\n                    while (write(fd, line, strlen(line)) == -1 && errno == EINTR) {\n                    }\n                    while (write(fd, \"\\n\", 1) == -1 && errno == EINTR) {\n                    }\n                }\n            }\n            close(fd);\n        }\n    }\n    #endif\n    #endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}