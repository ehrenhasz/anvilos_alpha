{
  "module_name": "main.c",
  "hash_id": "1edc8eca299b954258ff06f27494f75f91ec56245ae83dfeb43bbb07b1e5e57f",
  "original_prompt": "Ingested from sys_09_Anvil/source/ports/minimal/main.c",
  "human_readable_source": "#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/builtin.h\"\n#include \"py/compile.h\"\n#include \"py/runtime.h\"\n#include \"py/repl.h\"\n#include \"py/gc.h\"\n#include \"py/mperrno.h\"\n#include \"shared/runtime/pyexec.h\"\n\n#if MICROPY_ENABLE_COMPILER\nvoid do_str(const char *src, mp_parse_input_kind_t input_kind) {\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_lexer_t *lex = mp_lexer_new_from_str_len(MP_QSTR__lt_stdin_gt_, src, strlen(src), 0);\n        qstr source_name = lex->source_name;\n        mp_parse_tree_t parse_tree = mp_parse(lex, input_kind);\n        mp_obj_t module_fun = mp_compile(&parse_tree, source_name, true);\n        mp_call_function_0(module_fun);\n        nlr_pop();\n    } else {\n        \n        mp_obj_print_exception(&mp_plat_print, (mp_obj_t)nlr.ret_val);\n    }\n}\n#endif\n\nstatic char *stack_top;\n#if MICROPY_ENABLE_GC\nstatic char heap[MICROPY_HEAP_SIZE];\n#endif\n\nint main(int argc, char **argv) {\n    int stack_dummy;\n    stack_top = (char *)&stack_dummy;\n\n    #if MICROPY_ENABLE_GC\n    gc_init(heap, heap + sizeof(heap));\n    #endif\n    mp_init();\n    #if MICROPY_ENABLE_COMPILER\n    #if MICROPY_REPL_EVENT_DRIVEN\n    pyexec_event_repl_init();\n    for (;;) {\n        int c = mp_hal_stdin_rx_chr();\n        if (pyexec_event_repl_process_char(c)) {\n            break;\n        }\n    }\n    #else\n    pyexec_friendly_repl();\n    #endif\n    \n    \n    #else\n    pyexec_frozen_module(\"frozentest.py\", false);\n    #endif\n    mp_deinit();\n    return 0;\n}\n\n#if MICROPY_ENABLE_GC\nvoid gc_collect(void) {\n    \n    \n    void *dummy;\n    gc_collect_start();\n    gc_collect_root(&dummy, ((mp_uint_t)stack_top - (mp_uint_t)&dummy) / sizeof(mp_uint_t));\n    gc_collect_end();\n    gc_dump_info(&mp_plat_print);\n}\n#endif\n\nmp_lexer_t *mp_lexer_new_from_file(qstr filename) {\n    mp_raise_OSError(MP_ENOENT);\n}\n\nmp_import_stat_t mp_import_stat(const char *path) {\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\nvoid nlr_jump_fail(void *val) {\n    while (1) {\n        ;\n    }\n}\n\nvoid NORETURN __fatal_error(const char *msg) {\n    while (1) {\n        ;\n    }\n}\n\n#ifndef NDEBUG\nvoid MP_WEAK __assert_func(const char *file, int line, const char *func, const char *expr) {\n    printf(\"Assertion '%s' failed, at file %s:%d\\n\", expr, file, line);\n    __fatal_error(\"Assertion failed\");\n}\n#endif\n\n#if MICROPY_MIN_USE_CORTEX_CPU\n\n\n\nextern uint32_t _estack, _sidata, _sdata, _edata, _sbss, _ebss;\n\nvoid Reset_Handler(void) __attribute__((naked));\nvoid Reset_Handler(void) {\n    \n    __asm volatile (\"ldr sp, =_estack\");\n    \n    for (uint32_t *src = &_sidata, *dest = &_sdata; dest < &_edata;) {\n        *dest++ = *src++;\n    }\n    \n    for (uint32_t *dest = &_sbss; dest < &_ebss;) {\n        *dest++ = 0;\n    }\n    \n    void _start(void);\n    _start();\n}\n\nvoid Default_Handler(void) {\n    for (;;) {\n    }\n}\n\nconst uint32_t isr_vector[] __attribute__((section(\".isr_vector\"))) = {\n    (uint32_t)&_estack,\n    (uint32_t)&Reset_Handler,\n    (uint32_t)&Default_Handler, \n    (uint32_t)&Default_Handler, \n    (uint32_t)&Default_Handler, \n    (uint32_t)&Default_Handler, \n    (uint32_t)&Default_Handler, \n    0,\n    0,\n    0,\n    0,\n    (uint32_t)&Default_Handler, \n    (uint32_t)&Default_Handler, \n    0,\n    (uint32_t)&Default_Handler, \n    (uint32_t)&Default_Handler, \n};\n\nvoid _start(void) {\n    \n\n    \n    *((volatile uint32_t *)0xe000ed14) |= 1 << 9;\n\n    \n    #if MICROPY_MIN_USE_STM32_MCU\n    void stm32_init(void);\n    stm32_init();\n    #endif\n\n    \n    main(0, NULL);\n\n    \n    for (;;) {\n    }\n}\n\n#endif\n\n#if MICROPY_MIN_USE_STM32_MCU\n\n\n\ntypedef struct {\n    volatile uint32_t CR;\n    volatile uint32_t PLLCFGR;\n    volatile uint32_t CFGR;\n    volatile uint32_t CIR;\n    uint32_t _1[8];\n    volatile uint32_t AHB1ENR;\n    volatile uint32_t AHB2ENR;\n    volatile uint32_t AHB3ENR;\n    uint32_t _2;\n    volatile uint32_t APB1ENR;\n    volatile uint32_t APB2ENR;\n} periph_rcc_t;\n\ntypedef struct {\n    volatile uint32_t MODER;\n    volatile uint32_t OTYPER;\n    volatile uint32_t OSPEEDR;\n    volatile uint32_t PUPDR;\n    volatile uint32_t IDR;\n    volatile uint32_t ODR;\n    volatile uint16_t BSRRL;\n    volatile uint16_t BSRRH;\n    volatile uint32_t LCKR;\n    volatile uint32_t AFR[2];\n} periph_gpio_t;\n\ntypedef struct {\n    volatile uint32_t SR;\n    volatile uint32_t DR;\n    volatile uint32_t BRR;\n    volatile uint32_t CR1;\n} periph_uart_t;\n\n#define USART1 ((periph_uart_t *)0x40011000)\n#define GPIOA  ((periph_gpio_t *)0x40020000)\n#define GPIOB  ((periph_gpio_t *)0x40020400)\n#define RCC    ((periph_rcc_t *)0x40023800)\n\n\n#define GPIO_MODE_IN (0)\n#define GPIO_MODE_OUT (1)\n#define GPIO_MODE_ALT (2)\n#define GPIO_PULL_NONE (0)\n#define GPIO_PULL_UP (0)\n#define GPIO_PULL_DOWN (1)\nvoid gpio_init(periph_gpio_t *gpio, int pin, int mode, int pull, int alt) {\n    gpio->MODER = (gpio->MODER & ~(3 << (2 * pin))) | (mode << (2 * pin));\n    \n    \n    gpio->PUPDR = (gpio->PUPDR & ~(3 << (2 * pin))) | (pull << (2 * pin));\n    gpio->AFR[pin >> 3] = (gpio->AFR[pin >> 3] & ~(15 << (4 * (pin & 7)))) | (alt << (4 * (pin & 7)));\n}\n#define gpio_get(gpio, pin) ((gpio->IDR >> (pin)) & 1)\n#define gpio_set(gpio, pin, value) do { gpio->ODR = (gpio->ODR & ~(1 << (pin))) | (value << pin); } while (0)\n#define gpio_low(gpio, pin) do { gpio->BSRRH = (1 << (pin)); } while (0)\n#define gpio_high(gpio, pin) do { gpio->BSRRL = (1 << (pin)); } while (0)\n\nvoid stm32_init(void) {\n    \n    RCC->CR |= (uint32_t)0x00000001; \n    RCC->CFGR = 0x00000000; \n    RCC->CR &= (uint32_t)0xfef6ffff; \n    RCC->PLLCFGR = 0x24003010; \n    RCC->CR &= (uint32_t)0xfffbffff; \n    RCC->CIR = 0x00000000; \n\n    \n\n    \n    RCC->AHB1ENR |= 0x00000003; \n\n    \n    gpio_init(GPIOA, 13, GPIO_MODE_OUT, GPIO_PULL_NONE, 0);\n    gpio_high(GPIOA, 13);\n\n    \n    gpio_init(GPIOB, 6, GPIO_MODE_ALT, GPIO_PULL_NONE, 7);\n    gpio_init(GPIOB, 7, GPIO_MODE_ALT, GPIO_PULL_NONE, 7);\n    RCC->APB2ENR |= 0x00000010; \n    USART1->BRR = (104 << 4) | 3; \n    USART1->CR1 = 0x0000200c; \n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}