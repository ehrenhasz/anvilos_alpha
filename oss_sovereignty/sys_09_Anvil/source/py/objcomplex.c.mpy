{
  "module_name": "objcomplex.c",
  "hash_id": "b3dd6988e0bdbbd77f8fbd109ac86c88d3588daa8e1d487df2702dd155c47ba2",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objcomplex.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\n#include \"py/parsenum.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_COMPLEX\n\n#include <math.h>\n#include \"py/formatfloat.h\"\n\ntypedef struct _mp_obj_complex_t {\n    mp_obj_base_t base;\n    mp_float_t real;\n    mp_float_t imag;\n} mp_obj_complex_t;\n\nstatic void complex_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_complex_t *o = MP_OBJ_TO_PTR(o_in);\n    #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n    char buf[16];\n    #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C\n    const int precision = 6;\n    #else\n    const int precision = 7;\n    #endif\n    #else\n    char buf[32];\n    const int precision = 16;\n    #endif\n    if (o->real == 0) {\n        mp_format_float(o->imag, buf, sizeof(buf), 'g', precision, '\\0');\n        mp_printf(print, \"%sj\", buf);\n    } else {\n        mp_format_float(o->real, buf, sizeof(buf), 'g', precision, '\\0');\n        mp_printf(print, \"(%s\", buf);\n        if (o->imag >= 0 || isnan(o->imag)) {\n            mp_print_str(print, \"+\");\n        }\n        mp_format_float(o->imag, buf, sizeof(buf), 'g', precision, '\\0');\n        mp_printf(print, \"%sj)\", buf);\n    }\n}\n\nstatic mp_obj_t complex_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    mp_arg_check_num(n_args, n_kw, 0, 2, false);\n\n    switch (n_args) {\n        case 0:\n            return mp_obj_new_complex(0, 0);\n\n        case 1:\n            if (mp_obj_is_str(args[0])) {\n                \n                size_t l;\n                const char *s = mp_obj_str_get_data(args[0], &l);\n                return mp_parse_num_complex(s, l, NULL);\n            } else if (mp_obj_is_type(args[0], &mp_type_complex)) {\n                \n                return args[0];\n            } else {\n                mp_float_t real, imag;\n                mp_obj_get_complex(args[0], &real, &imag);\n                return mp_obj_new_complex(real, imag);\n            }\n\n        case 2:\n        default: {\n            mp_float_t real, imag;\n            if (mp_obj_is_type(args[0], &mp_type_complex)) {\n                mp_obj_complex_get(args[0], &real, &imag);\n            } else {\n                real = mp_obj_get_float(args[0]);\n                imag = 0;\n            }\n            if (mp_obj_is_type(args[1], &mp_type_complex)) {\n                mp_float_t real2, imag2;\n                mp_obj_complex_get(args[1], &real2, &imag2);\n                real -= imag2;\n                imag += real2;\n            } else {\n                imag += mp_obj_get_float(args[1]);\n            }\n            return mp_obj_new_complex(real, imag);\n        }\n    }\n}\n\nstatic mp_obj_t complex_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    mp_obj_complex_t *o = MP_OBJ_TO_PTR(o_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(o->real != 0 || o->imag != 0);\n        case MP_UNARY_OP_HASH:\n            return MP_OBJ_NEW_SMALL_INT(mp_float_hash(o->real) ^ mp_float_hash(o->imag));\n        case MP_UNARY_OP_POSITIVE:\n            return o_in;\n        case MP_UNARY_OP_NEGATIVE:\n            return mp_obj_new_complex(-o->real, -o->imag);\n        case MP_UNARY_OP_ABS:\n            return mp_obj_new_float(MICROPY_FLOAT_C_FUN(sqrt)(o->real * o->real + o->imag * o->imag));\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_obj_t complex_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    mp_obj_complex_t *lhs = MP_OBJ_TO_PTR(lhs_in);\n    return mp_obj_complex_binary_op(op, lhs->real, lhs->imag, rhs_in);\n}\n\nstatic void complex_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n    mp_obj_complex_t *self = MP_OBJ_TO_PTR(self_in);\n    if (attr == MP_QSTR_real) {\n        dest[0] = mp_obj_new_float(self->real);\n    } else if (attr == MP_QSTR_imag) {\n        dest[0] = mp_obj_new_float(self->imag);\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_complex, MP_QSTR_complex, MP_TYPE_FLAG_EQ_NOT_REFLEXIVE | MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE,\n    make_new, complex_make_new,\n    print, complex_print,\n    unary_op, complex_unary_op,\n    binary_op, complex_binary_op,\n    attr, complex_attr\n    );\n\nmp_obj_t mp_obj_new_complex(mp_float_t real, mp_float_t imag) {\n    mp_obj_complex_t *o = mp_obj_malloc(mp_obj_complex_t, &mp_type_complex);\n    o->real = real;\n    o->imag = imag;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nvoid mp_obj_complex_get(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag) {\n    assert(mp_obj_is_type(self_in, &mp_type_complex));\n    mp_obj_complex_t *self = MP_OBJ_TO_PTR(self_in);\n    *real = self->real;\n    *imag = self->imag;\n}\n\nmp_obj_t mp_obj_complex_binary_op(mp_binary_op_t op, mp_float_t lhs_real, mp_float_t lhs_imag, mp_obj_t rhs_in) {\n    mp_float_t rhs_real, rhs_imag;\n    if (!mp_obj_get_complex_maybe(rhs_in, &rhs_real, &rhs_imag)) {\n        return MP_OBJ_NULL; \n    }\n\n    switch (op) {\n        case MP_BINARY_OP_ADD:\n        case MP_BINARY_OP_INPLACE_ADD:\n            lhs_real += rhs_real;\n            lhs_imag += rhs_imag;\n            break;\n        case MP_BINARY_OP_SUBTRACT:\n        case MP_BINARY_OP_INPLACE_SUBTRACT:\n            lhs_real -= rhs_real;\n            lhs_imag -= rhs_imag;\n            break;\n        case MP_BINARY_OP_MULTIPLY:\n        case MP_BINARY_OP_INPLACE_MULTIPLY: {\n            mp_float_t real;\n        multiply:\n            real = lhs_real * rhs_real - lhs_imag * rhs_imag;\n            lhs_imag = lhs_real * rhs_imag + lhs_imag * rhs_real;\n            lhs_real = real;\n            break;\n        }\n        case MP_BINARY_OP_FLOOR_DIVIDE:\n        case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't truncate-divide a complex number\"));\n\n        case MP_BINARY_OP_TRUE_DIVIDE:\n        case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:\n            if (rhs_imag == 0) {\n                if (rhs_real == 0) {\n                    mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"complex divide by zero\"));\n                }\n                lhs_real /= rhs_real;\n                lhs_imag /= rhs_real;\n            } else if (rhs_real == 0) {\n                mp_float_t real = lhs_imag / rhs_imag;\n                lhs_imag = -lhs_real / rhs_imag;\n                lhs_real = real;\n            } else {\n                mp_float_t rhs_len_sq = rhs_real * rhs_real + rhs_imag * rhs_imag;\n                rhs_real /= rhs_len_sq;\n                rhs_imag /= -rhs_len_sq;\n                goto multiply;\n            }\n            break;\n\n        case MP_BINARY_OP_POWER:\n        case MP_BINARY_OP_INPLACE_POWER: {\n            \n            \n            \n            \n            \n            mp_float_t abs1 = MICROPY_FLOAT_C_FUN(sqrt)(lhs_real * lhs_real + lhs_imag * lhs_imag);\n            if (abs1 == 0) {\n                if (rhs_imag == 0 && rhs_real >= 0) {\n                    lhs_real = (rhs_real == 0);\n                } else {\n                    mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"0.0 to a complex power\"));\n                }\n            } else {\n                mp_float_t ln1 = MICROPY_FLOAT_C_FUN(log)(abs1);\n                mp_float_t arg1 = MICROPY_FLOAT_C_FUN(atan2)(lhs_imag, lhs_real);\n                mp_float_t x3 = rhs_real * ln1 - rhs_imag * arg1;\n                mp_float_t y3 = rhs_imag * ln1 + rhs_real * arg1;\n                mp_float_t exp_x3 = MICROPY_FLOAT_C_FUN(exp)(x3);\n                lhs_real = exp_x3 * MICROPY_FLOAT_C_FUN(cos)(y3);\n                lhs_imag = exp_x3 * MICROPY_FLOAT_C_FUN(sin)(y3);\n            }\n            break;\n        }\n\n        case MP_BINARY_OP_EQUAL:\n            return mp_obj_new_bool(lhs_real == rhs_real && lhs_imag == rhs_imag);\n\n        default:\n            return MP_OBJ_NULL; \n    }\n    return mp_obj_new_complex(lhs_real, lhs_imag);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}