{
  "module_name": "sequence.c",
  "hash_id": "e7f92b6b319449db0e65362bf1c7adc78c663df504bac5d936a680672b2a3d1d",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/sequence.c",
  "human_readable_source": " \n\n#include <string.h>\n\n#include \"py/runtime.h\"\n\n\n\n#define SWAP(type, var1, var2) { type t = var2; var2 = var1; var1 = t; }\n\n\n\nvoid mp_seq_multiply(const void *items, size_t item_sz, size_t len, size_t times, void *dest) {\n    for (size_t i = 0; i < times; i++) {\n        size_t copy_sz = item_sz * len;\n        memcpy(dest, items, copy_sz);\n        dest = (char *)dest + copy_sz;\n    }\n}\n\n#if MICROPY_PY_BUILTINS_SLICE\n\nbool mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes) {\n    mp_obj_slice_indices(slice, len, indexes);\n\n    \n    if (indexes->step < 0) {\n        indexes->stop++;\n    }\n\n    \n    if (indexes->step > 0 && indexes->start > indexes->stop) {\n        indexes->stop = indexes->start;\n    } else if (indexes->step < 0 && indexes->start < indexes->stop) {\n        indexes->stop = indexes->start + 1;\n    }\n\n    return indexes->step == 1;\n}\n\n#endif\n\nmp_obj_t mp_seq_extract_slice(size_t len, const mp_obj_t *seq, mp_bound_slice_t *indexes) {\n    (void)len; \n\n    mp_int_t start = indexes->start, stop = indexes->stop;\n    mp_int_t step = indexes->step;\n\n    mp_obj_t res = mp_obj_new_list(0, NULL);\n\n    if (step < 0) {\n        while (start >= stop) {\n            mp_obj_list_append(res, seq[start]);\n            start += step;\n        }\n    } else {\n        while (start < stop) {\n            mp_obj_list_append(res, seq[start]);\n            start += step;\n        }\n    }\n    return res;\n}\n\n\n\nbool mp_seq_cmp_bytes(mp_uint_t op, const byte *data1, size_t len1, const byte *data2, size_t len2) {\n    if (op == MP_BINARY_OP_EQUAL && len1 != len2) {\n        return false;\n    }\n\n    \n    if (op == MP_BINARY_OP_LESS || op == MP_BINARY_OP_LESS_EQUAL) {\n        SWAP(const byte *, data1, data2);\n        SWAP(size_t, len1, len2);\n        if (op == MP_BINARY_OP_LESS) {\n            op = MP_BINARY_OP_MORE;\n        } else {\n            op = MP_BINARY_OP_MORE_EQUAL;\n        }\n    }\n    size_t min_len = len1 < len2 ? len1 : len2;\n    int res = memcmp(data1, data2, min_len);\n    if (op == MP_BINARY_OP_EQUAL) {\n        \n        return res == 0;\n    }\n    if (res < 0) {\n        return false;\n    }\n    if (res > 0) {\n        return true;\n    }\n\n    \n    \n    if (len1 != len2) {\n        if (len1 < len2) {\n            \n            return false;\n        }\n    } else if (op == MP_BINARY_OP_MORE) {\n        \n        return false;\n    }\n    return true;\n}\n\n\n\nbool mp_seq_cmp_objs(mp_uint_t op, const mp_obj_t *items1, size_t len1, const mp_obj_t *items2, size_t len2) {\n    if (op == MP_BINARY_OP_EQUAL && len1 != len2) {\n        return false;\n    }\n\n    \n    if (op == MP_BINARY_OP_LESS || op == MP_BINARY_OP_LESS_EQUAL) {\n        SWAP(const mp_obj_t *, items1, items2);\n        SWAP(size_t, len1, len2);\n        if (op == MP_BINARY_OP_LESS) {\n            op = MP_BINARY_OP_MORE;\n        } else {\n            op = MP_BINARY_OP_MORE_EQUAL;\n        }\n    }\n\n    size_t len = len1 < len2 ? len1 : len2;\n    for (size_t i = 0; i < len; i++) {\n        \n        if (mp_obj_equal(items1[i], items2[i])) {\n            continue;\n        }\n\n        \n        if (op == MP_BINARY_OP_EQUAL) {\n            \n            return false;\n        }\n\n        \n        return mp_binary_op(op, items1[i], items2[i]) == mp_const_true;\n    }\n\n    \n    \n    if (len1 != len2) {\n        if (len1 < len2) {\n            \n            return false;\n        }\n    } else if (op == MP_BINARY_OP_MORE) {\n        \n        return false;\n    }\n\n    return true;\n}\n\n\nmp_obj_t mp_seq_index_obj(const mp_obj_t *items, size_t len, size_t n_args, const mp_obj_t *args) {\n    const mp_obj_type_t *type = mp_obj_get_type(args[0]);\n    mp_obj_t value = args[1];\n    size_t start = 0;\n    size_t stop = len;\n\n    if (n_args >= 3) {\n        start = mp_get_index(type, len, args[2], true);\n        if (n_args >= 4) {\n            stop = mp_get_index(type, len, args[3], true);\n        }\n    }\n\n    for (size_t i = start; i < stop; i++) {\n        if (mp_obj_equal(items[i], value)) {\n            \n            return MP_OBJ_NEW_SMALL_INT(i);\n        }\n    }\n\n    mp_raise_ValueError(MP_ERROR_TEXT(\"object not in sequence\"));\n}\n\nmp_obj_t mp_seq_count_obj(const mp_obj_t *items, size_t len, mp_obj_t value) {\n    size_t count = 0;\n    for (size_t i = 0; i < len; i++) {\n        if (mp_obj_equal(items[i], value)) {\n            count++;\n        }\n    }\n\n    \n    return MP_OBJ_NEW_SMALL_INT(count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}