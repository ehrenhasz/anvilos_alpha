{
  "module_name": "objstringio.c",
  "hash_id": "cb5e738c59f294270d3d754a2ee3cc4734a45d6ae21fa0fa86c1a967bed0c406",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objstringio.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/objstr.h\"\n#include \"py/objstringio.h\"\n#include \"py/runtime.h\"\n#include \"py/stream.h\"\n\n#if MICROPY_PY_IO\n\n#if MICROPY_CPYTHON_COMPAT\nstatic void check_stringio_is_open(const mp_obj_stringio_t *o) {\n    if (o->vstr == NULL) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"I/O operation on closed file\"));\n    }\n}\n#else\n#define check_stringio_is_open(o)\n#endif\n\nstatic void stringio_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_stringio_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, self->base.type == &mp_type_stringio ? \"<io.StringIO 0x%x>\" : \"<io.BytesIO 0x%x>\", self);\n}\n\nstatic mp_uint_t stringio_read(mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {\n    (void)errcode;\n    mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);\n    check_stringio_is_open(o);\n    if (o->vstr->len <= o->pos) {  \n        return 0;\n    }\n    mp_uint_t remaining = o->vstr->len - o->pos;\n    if (size > remaining) {\n        size = remaining;\n    }\n    memcpy(buf, o->vstr->buf + o->pos, size);\n    o->pos += size;\n    return size;\n}\n\nstatic void stringio_copy_on_write(mp_obj_stringio_t *o) {\n    const void *buf = o->vstr->buf;\n    o->vstr->buf = m_new(char, o->vstr->len);\n    o->vstr->fixed_buf = false;\n    o->ref_obj = MP_OBJ_NULL;\n    memcpy(o->vstr->buf, buf, o->vstr->len);\n}\n\nstatic mp_uint_t stringio_write(mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {\n    (void)errcode;\n    mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);\n    check_stringio_is_open(o);\n\n    if (o->vstr->fixed_buf) {\n        stringio_copy_on_write(o);\n    }\n\n    mp_uint_t new_pos = o->pos + size;\n    if (new_pos < size) {\n        \n        *errcode = MP_EFBIG;\n        return MP_STREAM_ERROR;\n    }\n    mp_uint_t org_len = o->vstr->len;\n    if (new_pos > o->vstr->alloc) {\n        \n        o->vstr->len = o->vstr->alloc;\n        \n        vstr_add_len(o->vstr, new_pos - o->vstr->alloc);\n    }\n    \n    if (o->pos > org_len) {\n        memset(o->vstr->buf + org_len, 0, o->pos - org_len);\n    }\n    memcpy(o->vstr->buf + o->pos, buf, size);\n    o->pos = new_pos;\n    if (new_pos > o->vstr->len) {\n        o->vstr->len = new_pos;\n    }\n    return size;\n}\n\nstatic mp_uint_t stringio_ioctl(mp_obj_t o_in, mp_uint_t request, uintptr_t arg, int *errcode) {\n    (void)errcode;\n    mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);\n    switch (request) {\n        case MP_STREAM_SEEK: {\n            struct mp_stream_seek_t *s = (struct mp_stream_seek_t *)arg;\n            mp_uint_t ref = 0;\n            switch (s->whence) {\n                case MP_SEEK_CUR:\n                    ref = o->pos;\n                    break;\n                case MP_SEEK_END:\n                    ref = o->vstr->len;\n                    break;\n            }\n            mp_uint_t new_pos = ref + s->offset;\n\n            \n            if (s->whence != MP_SEEK_SET && s->offset < 0) {\n                if (new_pos > ref) {\n                    \n                    \n                    new_pos = 0;\n                }\n            } else if (new_pos < ref) {\n                \n                *errcode = MP_EINVAL;  \n                return MP_STREAM_ERROR;\n            }\n            s->offset = o->pos = new_pos;\n            return 0;\n        }\n        case MP_STREAM_FLUSH:\n            return 0;\n        case MP_STREAM_CLOSE:\n            #if MICROPY_CPYTHON_COMPAT\n            vstr_free(o->vstr);\n            o->vstr = NULL;\n            #else\n            vstr_clear(o->vstr);\n            o->vstr->alloc = 0;\n            o->vstr->len = 0;\n            o->pos = 0;\n            #endif\n            return 0;\n        default:\n            *errcode = MP_EINVAL;\n            return MP_STREAM_ERROR;\n    }\n}\n\n#define STREAM_TO_CONTENT_TYPE(o) (((o)->base.type == &mp_type_stringio) ? &mp_type_str : &mp_type_bytes)\n\nstatic mp_obj_t stringio_getvalue(mp_obj_t self_in) {\n    mp_obj_stringio_t *self = MP_OBJ_TO_PTR(self_in);\n    check_stringio_is_open(self);\n    \n    return mp_obj_new_str_of_type(STREAM_TO_CONTENT_TYPE(self), (byte *)self->vstr->buf, self->vstr->len);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(stringio_getvalue_obj, stringio_getvalue);\n\nstatic mp_obj_stringio_t *stringio_new(const mp_obj_type_t *type) {\n    mp_obj_stringio_t *o = mp_obj_malloc(mp_obj_stringio_t, type);\n    o->pos = 0;\n    o->ref_obj = MP_OBJ_NULL;\n    return o;\n}\n\nstatic mp_obj_t stringio_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)n_kw; \n\n    mp_uint_t sz = 16;\n    bool initdata = false;\n    mp_buffer_info_t bufinfo;\n\n    mp_obj_stringio_t *o = stringio_new(type_in);\n\n    if (n_args > 0) {\n        if (mp_obj_is_int(args[0])) {\n            sz = mp_obj_get_int(args[0]);\n        } else {\n            mp_get_buffer_raise(args[0], &bufinfo, MP_BUFFER_READ);\n\n            if (mp_obj_is_str_or_bytes(args[0])) {\n                o->vstr = m_new_obj(vstr_t);\n                vstr_init_fixed_buf(o->vstr, bufinfo.len, bufinfo.buf);\n                o->vstr->len = bufinfo.len;\n                o->ref_obj = args[0];\n                return MP_OBJ_FROM_PTR(o);\n            }\n\n            sz = bufinfo.len;\n            initdata = true;\n        }\n    }\n\n    o->vstr = vstr_new(sz);\n\n    if (initdata) {\n        stringio_write(MP_OBJ_FROM_PTR(o), bufinfo.buf, bufinfo.len, NULL);\n        \n        o->pos = 0;\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic const mp_rom_map_elem_t stringio_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readinto), MP_ROM_PTR(&mp_stream_readinto_obj) },\n    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_seek), MP_ROM_PTR(&mp_stream_seek_obj) },\n    { MP_ROM_QSTR(MP_QSTR_tell), MP_ROM_PTR(&mp_stream_tell_obj) },\n    { MP_ROM_QSTR(MP_QSTR_flush), MP_ROM_PTR(&mp_stream_flush_obj) },\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_stream_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_getvalue), MP_ROM_PTR(&stringio_getvalue_obj) },\n    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&mp_identity_obj) },\n    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&mp_stream___exit___obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(stringio_locals_dict, stringio_locals_dict_table);\n\nstatic const mp_stream_p_t stringio_stream_p = {\n    .read = stringio_read,\n    .write = stringio_write,\n    .ioctl = stringio_ioctl,\n    .is_text = true,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_stringio,\n    MP_QSTR_StringIO,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    make_new, stringio_make_new,\n    print, stringio_print,\n    protocol, &stringio_stream_p,\n    locals_dict, &stringio_locals_dict\n    );\n\n#if MICROPY_PY_IO_BYTESIO\nstatic const mp_stream_p_t bytesio_stream_p = {\n    .read = stringio_read,\n    .write = stringio_write,\n    .ioctl = stringio_ioctl,\n};\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bytesio,\n    MP_QSTR_BytesIO,\n    MP_TYPE_FLAG_ITER_IS_STREAM,\n    make_new, stringio_make_new,\n    print, stringio_print,\n    protocol, &bytesio_stream_p,\n    locals_dict, &stringio_locals_dict\n    );\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}