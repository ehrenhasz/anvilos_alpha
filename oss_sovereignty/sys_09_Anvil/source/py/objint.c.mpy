{
  "module_name": "objint.c",
  "hash_id": "8b965bd3bb7428c6e8a20591ccff0469992446e09724e5168d637e9d4a97b88e",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objint.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n\n#include \"py/parsenum.h\"\n#include \"py/smallint.h\"\n#include \"py/objint.h\"\n#include \"py/objstr.h\"\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#include <math.h>\n#endif\n\n\nstatic mp_obj_t mp_obj_int_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    mp_arg_check_num(n_args, n_kw, 0, 2, false);\n\n    switch (n_args) {\n        case 0:\n            return MP_OBJ_NEW_SMALL_INT(0);\n\n        case 1: {\n            mp_buffer_info_t bufinfo;\n            mp_obj_t o = mp_unary_op(MP_UNARY_OP_INT_MAYBE, args[0]);\n            if (o != MP_OBJ_NULL) {\n                return o;\n            } else if (mp_get_buffer(args[0], &bufinfo, MP_BUFFER_READ)) {\n                \n                return mp_parse_num_integer(bufinfo.buf, bufinfo.len, 0, NULL);\n            #if MICROPY_PY_BUILTINS_FLOAT\n            } else if (mp_obj_is_float(args[0])) {\n                return mp_obj_new_int_from_float(mp_obj_float_get(args[0]));\n            #endif\n            } else {\n                mp_raise_TypeError_int_conversion(args[0]);\n            }\n        }\n\n        case 2:\n        default: {\n            \n            size_t l;\n            const char *s = mp_obj_str_get_data(args[0], &l);\n            return mp_parse_num_integer(s, l, mp_obj_get_int(args[1]), NULL);\n        }\n    }\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\n\ntypedef enum {\n    MP_FP_CLASS_FIT_SMALLINT,\n    MP_FP_CLASS_FIT_LONGINT,\n    MP_FP_CLASS_OVERFLOW\n} mp_fp_as_int_class_t;\n\nstatic mp_fp_as_int_class_t mp_classify_fp_as_int(mp_float_t val) {\n    union {\n        mp_float_t f;\n        #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n        uint32_t i;\n        #elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n        uint32_t i[2];\n        #endif\n    } u = {val};\n\n    uint32_t e;\n    #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n    e = u.i;\n    #elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n    e = u.i[MP_ENDIANNESS_LITTLE];\n    #endif\n#define MP_FLOAT_SIGN_SHIFT_I32 ((MP_FLOAT_FRAC_BITS + MP_FLOAT_EXP_BITS) % 32)\n#define MP_FLOAT_EXP_SHIFT_I32 (MP_FLOAT_FRAC_BITS % 32)\n\n    if (e & (1U << MP_FLOAT_SIGN_SHIFT_I32)) {\n        #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n        e |= u.i[MP_ENDIANNESS_BIG] != 0;\n        #endif\n        if ((e & ~(1U << MP_FLOAT_SIGN_SHIFT_I32)) == 0) {\n            \n            e = 0;\n        } else {\n            e += ((1U << MP_FLOAT_EXP_BITS) - 1) << MP_FLOAT_EXP_SHIFT_I32;\n        }\n    } else {\n        e &= ~((1U << MP_FLOAT_EXP_SHIFT_I32) - 1);\n    }\n    \n    \n    if (e <= ((8 * sizeof(uintptr_t) + MP_FLOAT_EXP_BIAS - 3) << MP_FLOAT_EXP_SHIFT_I32)) {\n        return MP_FP_CLASS_FIT_SMALLINT;\n    }\n    #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG\n    if (e <= (((sizeof(long long) * MP_BITS_PER_BYTE) + MP_FLOAT_EXP_BIAS - 2) << MP_FLOAT_EXP_SHIFT_I32)) {\n        return MP_FP_CLASS_FIT_LONGINT;\n    }\n    #endif\n    #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ\n    return MP_FP_CLASS_FIT_LONGINT;\n    #else\n    return MP_FP_CLASS_OVERFLOW;\n    #endif\n}\n#undef MP_FLOAT_SIGN_SHIFT_I32\n#undef MP_FLOAT_EXP_SHIFT_I32\n\nmp_obj_t mp_obj_new_int_from_float(mp_float_t val) {\n    mp_float_union_t u = {val};\n    \n    if (u.p.exp == ((1 << MP_FLOAT_EXP_BITS) - 1)) {\n        \n        if (u.p.frc == 0) {\n            mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"can't convert inf to int\"));\n        } else {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"can't convert NaN to int\"));\n        }\n    } else {\n        mp_fp_as_int_class_t icl = mp_classify_fp_as_int(val);\n        if (icl == MP_FP_CLASS_FIT_SMALLINT) {\n            return MP_OBJ_NEW_SMALL_INT((mp_int_t)val);\n        #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ\n        } else {\n            mp_obj_int_t *o = mp_obj_int_new_mpz();\n            mpz_set_from_float(&o->mpz, val);\n            return MP_OBJ_FROM_PTR(o);\n        }\n        #else\n        #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG\n        } else if (icl == MP_FP_CLASS_FIT_LONGINT) {\n            return mp_obj_new_int_from_ll((long long)val);\n        #endif\n        } else {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"float too big\"));\n        }\n        #endif\n    }\n}\n\n#endif\n\n#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG\ntypedef mp_longint_impl_t fmt_int_t;\ntypedef unsigned long long fmt_uint_t;\n#else\ntypedef mp_int_t fmt_int_t;\ntypedef mp_uint_t fmt_uint_t;\n#endif\n\nvoid mp_obj_int_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    \n    \n    char stack_buf[sizeof(fmt_int_t) * 4];\n    char *buf = stack_buf;\n    size_t buf_size = sizeof(stack_buf);\n    size_t fmt_size;\n\n    char *str = mp_obj_int_formatted(&buf, &buf_size, &fmt_size, self_in, 10, NULL, '\\0', '\\0');\n    mp_print_str(print, str);\n\n    if (buf != stack_buf) {\n        m_del(char, buf, buf_size);\n    }\n}\n\nstatic const uint8_t log_base2_floor[] = {\n    0, 1, 1, 2,\n    2, 2, 2, 3,\n    3, 3, 3, 3,\n    3, 3, 3, 4,\n     \n};\n\nsize_t mp_int_format_size(size_t num_bits, int base, const char *prefix, char comma) {\n    assert(2 <= base && base <= 16);\n    size_t num_digits = num_bits / log_base2_floor[base - 1] + 1;\n    size_t num_commas = comma ? num_digits / 3 : 0;\n    size_t prefix_len = prefix ? strlen(prefix) : 0;\n    return num_digits + num_commas + prefix_len + 2; \n}\n\n\n\n\n\n\n\n\nchar *mp_obj_int_formatted(char **buf, size_t *buf_size, size_t *fmt_size, mp_const_obj_t self_in,\n    int base, const char *prefix, char base_char, char comma) {\n    fmt_int_t num;\n    #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_NONE\n    \n    num = MP_OBJ_SMALL_INT_VALUE(self_in);\n    #else\n    if (mp_obj_is_small_int(self_in)) {\n        \n        num = MP_OBJ_SMALL_INT_VALUE(self_in);\n    } else {\n        assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n        \n        #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG\n        const mp_obj_int_t *self = self_in;\n        \n        num = self->val;\n        #else\n        \n        return mp_obj_int_formatted_impl(buf, buf_size, fmt_size, self_in, base, prefix, base_char, comma);\n        #endif\n    }\n    #endif\n\n    char sign = '\\0';\n    if (num < 0) {\n        num = -num;\n        sign = '-';\n    }\n\n    size_t needed_size = mp_int_format_size(sizeof(fmt_int_t) * 8, base, prefix, comma);\n    if (needed_size > *buf_size) {\n        *buf = m_new(char, needed_size);\n        *buf_size = needed_size;\n    }\n    char *str = *buf;\n\n    char *b = str + needed_size;\n    *(--b) = '\\0';\n    char *last_comma = b;\n\n    if (num == 0) {\n        *(--b) = '0';\n    } else {\n        do {\n            \n            int c = (fmt_uint_t)num % base;\n            num = (fmt_uint_t)num / base;\n            if (c >= 10) {\n                c += base_char - 10;\n            } else {\n                c += '0';\n            }\n            *(--b) = c;\n            if (comma && num != 0 && b > str && (last_comma - b) == 3) {\n                *(--b) = comma;\n                last_comma = b;\n            }\n        }\n        while (b > str && num != 0);\n    }\n    if (prefix) {\n        size_t prefix_len = strlen(prefix);\n        char *p = b - prefix_len;\n        if (p > str) {\n            b = p;\n            while (*prefix) {\n                *p++ = *prefix++;\n            }\n        }\n    }\n    if (sign && b > str) {\n        *(--b) = sign;\n    }\n    *fmt_size = *buf + needed_size - b - 1;\n\n    return b;\n}\n\n#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_NONE\n\nint mp_obj_int_sign(mp_obj_t self_in) {\n    mp_int_t val = mp_obj_get_int(self_in);\n    if (val < 0) {\n        return -1;\n    } else if (val > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n\nmp_obj_t mp_obj_int_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    return MP_OBJ_NULL; \n}\n\n\nmp_obj_t mp_obj_int_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    return mp_obj_int_binary_op_extra_cases(op, lhs_in, rhs_in);\n}\n\n\nmp_obj_t mp_obj_new_int_from_str_len(const char **str, size_t len, bool neg, unsigned int base) {\n    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"long int not supported in this build\"));\n    return mp_const_none;\n}\n\n\nmp_obj_t mp_obj_new_int_from_ll(long long val) {\n    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"small int overflow\"));\n    return mp_const_none;\n}\n\n\nmp_obj_t mp_obj_new_int_from_ull(unsigned long long val) {\n    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"small int overflow\"));\n    return mp_const_none;\n}\n\nmp_obj_t mp_obj_new_int_from_uint(mp_uint_t value) {\n    \n    \n    if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {\n        return MP_OBJ_NEW_SMALL_INT(value);\n    }\n    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"small int overflow\"));\n    return mp_const_none;\n}\n\nmp_obj_t mp_obj_new_int(mp_int_t value) {\n    if (MP_SMALL_INT_FITS(value)) {\n        return MP_OBJ_NEW_SMALL_INT(value);\n    }\n    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"small int overflow\"));\n    return mp_const_none;\n}\n\nmp_int_t mp_obj_int_get_truncated(mp_const_obj_t self_in) {\n    return MP_OBJ_SMALL_INT_VALUE(self_in);\n}\n\nmp_int_t mp_obj_int_get_checked(mp_const_obj_t self_in) {\n    return MP_OBJ_SMALL_INT_VALUE(self_in);\n}\n\n#endif \n\n\n\nmp_obj_t mp_obj_int_binary_op_extra_cases(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    if (rhs_in == mp_const_false) {\n        \n        return mp_binary_op(op, lhs_in, MP_OBJ_NEW_SMALL_INT(0));\n    } else if (rhs_in == mp_const_true) {\n        \n        return mp_binary_op(op, lhs_in, MP_OBJ_NEW_SMALL_INT(1));\n    } else if (op == MP_BINARY_OP_MULTIPLY) {\n        if (mp_obj_is_str_or_bytes(rhs_in) || mp_obj_is_type(rhs_in, &mp_type_tuple) || mp_obj_is_type(rhs_in, &mp_type_list)) {\n            \n            return mp_binary_op(op, rhs_in, lhs_in);\n        }\n    }\n    return MP_OBJ_NULL; \n}\n\n\nstatic mp_obj_t int_from_bytes(size_t n_args, const mp_obj_t *args) {\n    \n    (void)n_args;\n\n    \n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_READ);\n\n    const byte *buf = (const byte *)bufinfo.buf;\n    int delta = 1;\n    if (args[2] == MP_OBJ_NEW_QSTR(MP_QSTR_little)) {\n        buf += bufinfo.len - 1;\n        delta = -1;\n    }\n\n    mp_uint_t value = 0;\n    size_t len = bufinfo.len;\n    for (; len--; buf += delta) {\n        #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n        if (value > (MP_SMALL_INT_MAX >> 8)) {\n            \n            return mp_obj_int_from_bytes_impl(args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little), bufinfo.len, bufinfo.buf);\n        }\n        #endif\n        value = (value << 8) | *buf;\n    }\n    return mp_obj_new_int_from_uint(value);\n}\n\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(int_from_bytes_fun_obj, 3, 4, int_from_bytes);\nstatic MP_DEFINE_CONST_CLASSMETHOD_OBJ(int_from_bytes_obj, MP_ROM_PTR(&int_from_bytes_fun_obj));\n\nstatic mp_obj_t int_to_bytes(size_t n_args, const mp_obj_t *args) {\n    \n    (void)n_args;\n\n    mp_int_t len = mp_obj_get_int(args[1]);\n    if (len < 0) {\n        mp_raise_ValueError(NULL);\n    }\n    bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);\n\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    byte *data = (byte *)vstr.buf;\n    memset(data, 0, len);\n\n    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n    if (!mp_obj_is_small_int(args[0])) {\n        mp_obj_int_to_bytes_impl(args[0], big_endian, len, data);\n    } else\n    #endif\n    {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        size_t l = MIN((size_t)len, sizeof(val));\n        mp_binary_set_int(l, big_endian, data + (big_endian ? (len - l) : 0), val);\n    }\n\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(int_to_bytes_obj, 3, 4, int_to_bytes);\n\nstatic const mp_rom_map_elem_t int_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_from_bytes), MP_ROM_PTR(&int_from_bytes_obj) },\n    { MP_ROM_QSTR(MP_QSTR_to_bytes), MP_ROM_PTR(&int_to_bytes_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(int_locals_dict, int_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_int,\n    MP_QSTR_int,\n    MP_TYPE_FLAG_NONE,\n    make_new, mp_obj_int_make_new,\n    print, mp_obj_int_print,\n    unary_op, mp_obj_int_unary_op,\n    binary_op, mp_obj_int_binary_op,\n    locals_dict, &int_locals_dict\n    );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}