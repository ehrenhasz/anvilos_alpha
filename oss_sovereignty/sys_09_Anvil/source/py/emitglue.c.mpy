{
  "module_name": "emitglue.c",
  "hash_id": "ca3a8958f99dd4533304984d7a60d30d4bbce36c34b49084a0ecb3e548a1b06c",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/emitglue.c",
  "human_readable_source": " \n\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/emitglue.h\"\n#include \"py/runtime0.h\"\n#include \"py/bc.h\"\n#include \"py/objfun.h\"\n#include \"py/profile.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define WRITE_CODE (1)\n#define DEBUG_printf DEBUG_printf\n#define DEBUG_OP_printf(...) DEBUG_printf(__VA_ARGS__)\n#else \n#define DEBUG_printf(...) (void)0\n#define DEBUG_OP_printf(...) (void)0\n#endif\n\n#if MICROPY_DEBUG_PRINTERS\nmp_uint_t mp_verbose_flag = 0;\n#endif\n\nmp_raw_code_t *mp_emit_glue_new_raw_code(void) {\n    mp_raw_code_t *rc = m_new0(mp_raw_code_t, 1);\n    rc->kind = MP_CODE_RESERVED;\n    #if MICROPY_PY_SYS_SETTRACE\n    rc->line_of_definition = 0;\n    #endif\n    return rc;\n}\n\nvoid mp_emit_glue_assign_bytecode(mp_raw_code_t *rc, const byte *code,\n    mp_raw_code_t **children,\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    size_t len,\n    uint16_t n_children,\n    #endif\n    uint16_t scope_flags) {\n\n    rc->kind = MP_CODE_BYTECODE;\n    rc->is_generator = (scope_flags & MP_SCOPE_FLAG_GENERATOR) != 0;\n    rc->fun_data = code;\n    rc->children = children;\n\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    rc->fun_data_len = len;\n    rc->n_children = n_children;\n    #endif\n\n    #if MICROPY_PY_SYS_SETTRACE\n    mp_bytecode_prelude_t *prelude = &rc->prelude;\n    mp_prof_extract_prelude(code, prelude);\n    #endif\n\n    #if DEBUG_PRINT\n    #if !MICROPY_PERSISTENT_CODE_SAVE\n    const size_t len = 0;\n    #endif\n    DEBUG_printf(\"assign byte code: code=%p len=\" UINT_FMT \" flags=%x\\n\", code, len, (uint)scope_flags);\n    #endif\n}\n\n#if MICROPY_EMIT_MACHINE_CODE\nvoid mp_emit_glue_assign_native(mp_raw_code_t *rc, mp_raw_code_kind_t kind, const void *fun_data, mp_uint_t fun_len,\n    mp_raw_code_t **children,\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    uint16_t n_children,\n    uint16_t prelude_offset,\n    #endif\n    uint16_t scope_flags, uint32_t asm_n_pos_args, uint32_t asm_type_sig\n    ) {\n\n    assert(kind == MP_CODE_NATIVE_PY || kind == MP_CODE_NATIVE_VIPER || kind == MP_CODE_NATIVE_ASM);\n\n    \n    \n    \n    #if MICROPY_EMIT_THUMB || MICROPY_EMIT_INLINE_THUMB\n    #if __ICACHE_PRESENT == 1\n    \n    MP_HAL_CLEAN_DCACHE(fun_data, fun_len);\n    \n    SCB_InvalidateICache();\n    #endif\n    #elif MICROPY_EMIT_ARM\n    #if (defined(__linux__) && defined(__GNUC__)) || __ARM_ARCH == 7\n    __builtin___clear_cache((void *)fun_data, (uint8_t *)fun_data + fun_len);\n    #elif defined(__arm__)\n    \n    asm volatile (\n        \"0:\"\n        \"mrc p15, 0, r15, c7, c10, 3\\n\" \n        \"bne 0b\\n\"\n        \"mov r0, #0\\n\"\n        \"mcr p15, 0, r0, c7, c7, 0\\n\" \n        : : : \"r0\", \"cc\");\n    #endif\n    #endif\n\n    rc->kind = kind;\n    rc->is_generator = (scope_flags & MP_SCOPE_FLAG_GENERATOR) != 0;\n    rc->fun_data = fun_data;\n\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    rc->fun_data_len = fun_len;\n    #endif\n    rc->children = children;\n\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    rc->n_children = n_children;\n    rc->prelude_offset = prelude_offset;\n    #endif\n\n    #if MICROPY_EMIT_INLINE_ASM\n    \n    rc->asm_n_pos_args = asm_n_pos_args;\n    rc->asm_type_sig = asm_type_sig;\n    #endif\n\n    #if DEBUG_PRINT\n    DEBUG_printf(\"assign native: kind=%d fun=%p len=\" UINT_FMT \" flags=%x\\n\", kind, fun_data, fun_len, (uint)scope_flags);\n    for (mp_uint_t i = 0; i < fun_len; i++) {\n        if (i > 0 && i % 16 == 0) {\n            DEBUG_printf(\"\\n\");\n        }\n        DEBUG_printf(\" %02x\", ((const byte *)fun_data)[i]);\n    }\n    DEBUG_printf(\"\\n\");\n\n    #ifdef WRITE_CODE\n    FILE *fp_write_code = fopen(\"out-code\", \"wb\");\n    fwrite(fun_data, fun_len, 1, fp_write_code);\n    fclose(fp_write_code);\n    #endif\n    #else\n    (void)fun_len;\n    #endif\n}\n#endif\n\nmp_obj_t mp_make_function_from_proto_fun(mp_proto_fun_t proto_fun, const mp_module_context_t *context, const mp_obj_t *def_args) {\n    DEBUG_OP_printf(\"make_function_from_proto_fun %p\\n\", proto_fun);\n    assert(proto_fun != NULL);\n\n    \n    assert(def_args == NULL || def_args[0] == MP_OBJ_NULL || mp_obj_is_type(def_args[0], &mp_type_tuple));\n\n    \n    assert(def_args == NULL || def_args[1] == MP_OBJ_NULL || mp_obj_is_type(def_args[1], &mp_type_dict));\n\n    #if MICROPY_MODULE_FROZEN_MPY\n    if (mp_proto_fun_is_bytecode(proto_fun)) {\n        const uint8_t *bc = proto_fun;\n        mp_obj_t fun = mp_obj_new_fun_bc(def_args, bc, context, NULL);\n        MP_BC_PRELUDE_SIG_DECODE(bc);\n        if (scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n            ((mp_obj_base_t *)MP_OBJ_TO_PTR(fun))->type = &mp_type_gen_wrap;\n        }\n        return fun;\n    }\n    #endif\n\n    \n    const mp_raw_code_t *rc = proto_fun;\n\n    \n    mp_obj_t fun;\n    switch (rc->kind) {\n        #if MICROPY_EMIT_NATIVE\n        case MP_CODE_NATIVE_PY:\n            fun = mp_obj_new_fun_native(def_args, rc->fun_data, context, rc->children);\n            \n            if (rc->is_generator) {\n                ((mp_obj_base_t *)MP_OBJ_TO_PTR(fun))->type = &mp_type_native_gen_wrap;\n            }\n            break;\n        case MP_CODE_NATIVE_VIPER:\n            fun = mp_obj_new_fun_viper(rc->fun_data, context, rc->children);\n            break;\n        #endif\n        #if MICROPY_EMIT_INLINE_ASM\n        case MP_CODE_NATIVE_ASM:\n            fun = mp_obj_new_fun_asm(rc->asm_n_pos_args, rc->fun_data, rc->asm_type_sig);\n            break;\n        #endif\n        default:\n            \n            assert(rc->kind == MP_CODE_BYTECODE);\n            fun = mp_obj_new_fun_bc(def_args, rc->fun_data, context, rc->children);\n            \n            if (rc->is_generator) {\n                ((mp_obj_base_t *)MP_OBJ_TO_PTR(fun))->type = &mp_type_gen_wrap;\n            }\n\n            #if MICROPY_PY_SYS_SETTRACE\n            mp_obj_fun_bc_t *self_fun = (mp_obj_fun_bc_t *)MP_OBJ_TO_PTR(fun);\n            self_fun->rc = rc;\n            #endif\n\n            break;\n    }\n\n    return fun;\n}\n\nmp_obj_t mp_make_closure_from_proto_fun(mp_proto_fun_t proto_fun, const mp_module_context_t *context, mp_uint_t n_closed_over, const mp_obj_t *args) {\n    DEBUG_OP_printf(\"make_closure_from_proto_fun %p \" UINT_FMT \" %p\\n\", proto_fun, n_closed_over, args);\n    \n    mp_obj_t ffun;\n    if (n_closed_over & 0x100) {\n        \n        ffun = mp_make_function_from_proto_fun(proto_fun, context, args);\n    } else {\n        \n        ffun = mp_make_function_from_proto_fun(proto_fun, context, NULL);\n    }\n    \n    return mp_obj_new_closure(ffun, n_closed_over & 0xff, args + ((n_closed_over >> 7) & 2));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}