{
  "module_name": "argcheck.c",
  "hash_id": "c4afe43810ca7d55d11ff4151dbc67688404a387bd3384e08928a9e928bcb62a",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/argcheck.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n\nvoid mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig) {\n    \n\n    \n    bool takes_kw = sig & 1;\n    size_t n_args_min = sig >> 17;\n    size_t n_args_max = (sig >> 1) & 0xffff;\n\n    if (n_kw && !takes_kw) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_arg_error_terse_mismatch();\n        #else\n        mp_raise_TypeError(MP_ERROR_TEXT(\"function doesn't take keyword arguments\"));\n        #endif\n    }\n\n    if (n_args_min == n_args_max) {\n        if (n_args != n_args_min) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_arg_error_terse_mismatch();\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"function takes %d positional arguments but %d were given\"),\n                n_args_min, n_args);\n            #endif\n        }\n    } else {\n        if (n_args < n_args_min) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_arg_error_terse_mismatch();\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"function missing %d required positional arguments\"),\n                n_args_min - n_args);\n            #endif\n        } else if (n_args > n_args_max) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_arg_error_terse_mismatch();\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"function expected at most %d arguments, got %d\"),\n                n_args_max, n_args);\n            #endif\n        }\n    }\n}\n\nvoid mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {\n    size_t pos_found = 0, kws_found = 0;\n    for (size_t i = 0; i < n_allowed; i++) {\n        mp_obj_t given_arg;\n        if (i < n_pos) {\n            if (allowed[i].flags & MP_ARG_KW_ONLY) {\n                goto extra_positional;\n            }\n            pos_found++;\n            given_arg = pos[i];\n        } else {\n            mp_map_elem_t *kw = mp_map_lookup(kws, MP_OBJ_NEW_QSTR(allowed[i].qst), MP_MAP_LOOKUP);\n            if (kw == NULL) {\n                if (allowed[i].flags & MP_ARG_REQUIRED) {\n                    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                    mp_arg_error_terse_mismatch();\n                    #else\n                    mp_raise_msg_varg(&mp_type_TypeError, MP_ERROR_TEXT(\"'%q' argument required\"), allowed[i].qst);\n                    #endif\n                }\n                out_vals[i] = allowed[i].defval;\n                continue;\n            } else {\n                kws_found++;\n                given_arg = kw->value;\n            }\n        }\n        if ((allowed[i].flags & MP_ARG_KIND_MASK) == MP_ARG_BOOL) {\n            out_vals[i].u_bool = mp_obj_is_true(given_arg);\n        } else if ((allowed[i].flags & MP_ARG_KIND_MASK) == MP_ARG_INT) {\n            out_vals[i].u_int = mp_obj_get_int(given_arg);\n        } else {\n            assert((allowed[i].flags & MP_ARG_KIND_MASK) == MP_ARG_OBJ);\n            out_vals[i].u_obj = given_arg;\n        }\n    }\n    if (pos_found < n_pos) {\n    extra_positional:\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_arg_error_terse_mismatch();\n        #else\n        \n        mp_raise_TypeError(MP_ERROR_TEXT(\"extra positional arguments given\"));\n        #endif\n    }\n    if (kws_found < kws->used) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_arg_error_terse_mismatch();\n        #else\n        \n        mp_raise_TypeError(MP_ERROR_TEXT(\"extra keyword arguments given\"));\n        #endif\n    }\n}\n\nvoid mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {\n    mp_map_t kw_args;\n    mp_map_init_fixed_table(&kw_args, n_kw, args + n_pos);\n    mp_arg_parse_all(n_pos, args, &kw_args, n_allowed, allowed, out_vals);\n}\n\nNORETURN void mp_arg_error_terse_mismatch(void) {\n    mp_raise_TypeError(MP_ERROR_TEXT(\"argument num/types mismatch\"));\n}\n\n#if MICROPY_CPYTHON_COMPAT\nNORETURN void mp_arg_error_unimpl_kw(void) {\n    mp_raise_NotImplementedError(MP_ERROR_TEXT(\"keyword argument(s) not implemented - use normal args instead\"));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}