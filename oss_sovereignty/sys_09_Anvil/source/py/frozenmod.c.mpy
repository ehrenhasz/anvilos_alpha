{
  "module_name": "frozenmod.c",
  "hash_id": "60ed689335e0ea2dac5b7ac077cbf4ba83f948c15a4051c64798e2cef3f8c468",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/frozenmod.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <stdint.h>\n\n#include \"py/lexer.h\"\n#include \"py/frozenmod.h\"\n\n#if MICROPY_MODULE_FROZEN\n\n\n\n\nextern const char mp_frozen_names[];\n\n#if MICROPY_MODULE_FROZEN_STR\n\n#ifndef MICROPY_MODULE_FROZEN_LEXER\n#define MICROPY_MODULE_FROZEN_LEXER mp_lexer_new_from_str_len\n#else\nmp_lexer_t *MICROPY_MODULE_FROZEN_LEXER(qstr src_name, const char *str, mp_uint_t len, mp_uint_t free_len);\n#endif\n\n\nextern const uint32_t mp_frozen_str_sizes[];\n\nextern const char mp_frozen_str_content[];\n#endif \n\n#if MICROPY_MODULE_FROZEN_MPY\n\n#include \"py/emitglue.h\"\n\nextern const mp_frozen_module_t *const mp_frozen_mpy_content[];\n\n#endif \n\n\n\n\nmp_import_stat_t mp_find_frozen_module(const char *str, int *frozen_type, void **data) {\n    size_t len = strlen(str);\n    const char *name = mp_frozen_names;\n\n    if (frozen_type != NULL) {\n        *frozen_type = MP_FROZEN_NONE;\n    }\n\n    \n    size_t num_str = 0;\n    #if MICROPY_MODULE_FROZEN_STR && MICROPY_MODULE_FROZEN_MPY\n    for (const uint32_t *s = mp_frozen_str_sizes; *s != 0; ++s) {\n        ++num_str;\n    }\n    #endif\n\n    for (size_t i = 0; *name != 0; i++) {\n        size_t entry_len = strlen(name);\n        if (entry_len >= len && memcmp(str, name, len) == 0) {\n            \n            if (entry_len == len) {\n                \n\n                if (frozen_type != NULL) {\n                    #if MICROPY_MODULE_FROZEN_STR\n                    if (i < num_str) {\n                        *frozen_type = MP_FROZEN_STR;\n                        \n                        size_t offset = 0;\n                        for (size_t j = 0; j < i; ++j) {\n                            offset += mp_frozen_str_sizes[j] + 1;\n                        }\n                        size_t content_len = mp_frozen_str_sizes[i];\n                        const char *content = &mp_frozen_str_content[offset];\n\n                        \n                        \n                        \n                        qstr source = qstr_from_strn(str, len);\n                        mp_lexer_t *lex = MICROPY_MODULE_FROZEN_LEXER(source, content, content_len, 0);\n                        *data = lex;\n                    }\n                    #endif\n\n                    #if MICROPY_MODULE_FROZEN_MPY\n                    if (i >= num_str) {\n                        *frozen_type = MP_FROZEN_MPY;\n                        \n                        \n                        *data = (void *)mp_frozen_mpy_content[i - num_str];\n                    }\n                    #endif\n                }\n\n                return MP_IMPORT_STAT_FILE;\n            } else if (name[len] == '/') {\n                \n                \n                return MP_IMPORT_STAT_DIR;\n            }\n        }\n        \n        name += entry_len + 1;\n    }\n\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}