{
  "module_name": "scheduler.c",
  "hash_id": "0aee659651923eea32977730008b3d86da2f6b0c67006825a1cdc10a78bf04a5",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/scheduler.c",
  "human_readable_source": " \n\n#include <stdio.h>\n\n#include \"py/mphal.h\"\n#include \"py/runtime.h\"\n\n\n\nvoid MICROPY_WRAP_MP_SCHED_EXCEPTION(mp_sched_exception)(mp_obj_t exc) {\n    MP_STATE_MAIN_THREAD(mp_pending_exception) = exc;\n\n    #if MICROPY_ENABLE_SCHEDULER && !MICROPY_PY_THREAD\n    \n    \n    \n    if (MP_STATE_VM(sched_state) == MP_SCHED_IDLE) {\n        MP_STATE_VM(sched_state) = MP_SCHED_PENDING;\n    }\n    #endif\n}\n\n#if MICROPY_KBD_EXCEPTION\n\nvoid MICROPY_WRAP_MP_SCHED_KEYBOARD_INTERRUPT(mp_sched_keyboard_interrupt)(void) {\n    MP_STATE_VM(mp_kbd_exception).traceback_data = NULL;\n    mp_sched_exception(MP_OBJ_FROM_PTR(&MP_STATE_VM(mp_kbd_exception)));\n}\n#endif\n\n#if MICROPY_ENABLE_VM_ABORT\nvoid MICROPY_WRAP_MP_SCHED_VM_ABORT(mp_sched_vm_abort)(void) {\n    MP_STATE_VM(vm_abort) = true;\n}\n#endif\n\n#if MICROPY_ENABLE_SCHEDULER\n\n#define IDX_MASK(i) ((i) & (MICROPY_SCHEDULER_DEPTH - 1))\n\n\n\n#define mp_sched_full() (mp_sched_num_pending() == MICROPY_SCHEDULER_DEPTH)\n\nstatic inline bool mp_sched_empty(void) {\n    MP_STATIC_ASSERT(MICROPY_SCHEDULER_DEPTH <= 255); \n    MP_STATIC_ASSERT((IDX_MASK(MICROPY_SCHEDULER_DEPTH) == 0)); \n\n    return mp_sched_num_pending() == 0;\n}\n\nstatic inline void mp_sched_run_pending(void) {\n    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    if (MP_STATE_VM(sched_state) != MP_SCHED_PENDING) {\n        \n        \n        MICROPY_END_ATOMIC_SECTION(atomic_state);\n        return;\n    }\n\n    \n    \n    MP_STATE_VM(sched_state) = MP_SCHED_LOCKED;\n\n    #if MICROPY_SCHEDULER_STATIC_NODES\n    \n    while (MP_STATE_VM(sched_head) != NULL) {\n        mp_sched_node_t *node = MP_STATE_VM(sched_head);\n        MP_STATE_VM(sched_head) = node->next;\n        if (MP_STATE_VM(sched_head) == NULL) {\n            MP_STATE_VM(sched_tail) = NULL;\n        }\n        mp_sched_callback_t callback = node->callback;\n        node->callback = NULL;\n        MICROPY_END_ATOMIC_SECTION(atomic_state);\n        callback(node);\n        atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    }\n    #endif\n\n    \n    if (!mp_sched_empty()) {\n        mp_sched_item_t item = MP_STATE_VM(sched_queue)[MP_STATE_VM(sched_idx)];\n        MP_STATE_VM(sched_idx) = IDX_MASK(MP_STATE_VM(sched_idx) + 1);\n        --MP_STATE_VM(sched_len);\n        MICROPY_END_ATOMIC_SECTION(atomic_state);\n        mp_call_function_1_protected(item.func, item.arg);\n    } else {\n        MICROPY_END_ATOMIC_SECTION(atomic_state);\n    }\n\n    \n    \n    mp_sched_unlock();\n}\n\n\n\n\nvoid mp_sched_lock(void) {\n    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    if (MP_STATE_VM(sched_state) < 0) {\n        \n        --MP_STATE_VM(sched_state);\n    } else {\n        \n        MP_STATE_VM(sched_state) = MP_SCHED_LOCKED;\n    }\n    MICROPY_END_ATOMIC_SECTION(atomic_state);\n}\n\nvoid mp_sched_unlock(void) {\n    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    assert(MP_STATE_VM(sched_state) < 0);\n    if (++MP_STATE_VM(sched_state) == 0) {\n        \n        \n        if (\n            #if !MICROPY_PY_THREAD\n            \n            MP_STATE_THREAD(mp_pending_exception) != MP_OBJ_NULL ||\n            #endif\n            #if MICROPY_SCHEDULER_STATIC_NODES\n            MP_STATE_VM(sched_head) != NULL ||\n            #endif\n            mp_sched_num_pending()) {\n            MP_STATE_VM(sched_state) = MP_SCHED_PENDING;\n        } else {\n            MP_STATE_VM(sched_state) = MP_SCHED_IDLE;\n        }\n    }\n    MICROPY_END_ATOMIC_SECTION(atomic_state);\n}\n\nbool MICROPY_WRAP_MP_SCHED_SCHEDULE(mp_sched_schedule)(mp_obj_t function, mp_obj_t arg) {\n    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    bool ret;\n    if (!mp_sched_full()) {\n        if (MP_STATE_VM(sched_state) == MP_SCHED_IDLE) {\n            MP_STATE_VM(sched_state) = MP_SCHED_PENDING;\n        }\n        uint8_t iput = IDX_MASK(MP_STATE_VM(sched_idx) + MP_STATE_VM(sched_len)++);\n        MP_STATE_VM(sched_queue)[iput].func = function;\n        MP_STATE_VM(sched_queue)[iput].arg = arg;\n        MICROPY_SCHED_HOOK_SCHEDULED;\n        ret = true;\n    } else {\n        \n        ret = false;\n    }\n    MICROPY_END_ATOMIC_SECTION(atomic_state);\n    return ret;\n}\n\n#if MICROPY_SCHEDULER_STATIC_NODES\nbool mp_sched_schedule_node(mp_sched_node_t *node, mp_sched_callback_t callback) {\n    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    bool ret;\n    if (node->callback == NULL) {\n        if (MP_STATE_VM(sched_state) == MP_SCHED_IDLE) {\n            MP_STATE_VM(sched_state) = MP_SCHED_PENDING;\n        }\n        node->callback = callback;\n        node->next = NULL;\n        if (MP_STATE_VM(sched_tail) == NULL) {\n            MP_STATE_VM(sched_head) = node;\n        } else {\n            MP_STATE_VM(sched_tail)->next = node;\n        }\n        MP_STATE_VM(sched_tail) = node;\n        MICROPY_SCHED_HOOK_SCHEDULED;\n        ret = true;\n    } else {\n        \n        ret = false;\n    }\n    MICROPY_END_ATOMIC_SECTION(atomic_state);\n    return ret;\n}\n#endif\n\nMP_REGISTER_ROOT_POINTER(mp_sched_item_t sched_queue[MICROPY_SCHEDULER_DEPTH]);\n\n#endif \n\n\n\nvoid mp_handle_pending(bool raise_exc) {\n    \n    #if MICROPY_ENABLE_VM_ABORT\n    if (MP_STATE_VM(vm_abort) && mp_thread_is_main_thread()) {\n        MP_STATE_VM(vm_abort) = false;\n        if (raise_exc && nlr_get_abort() != NULL) {\n            nlr_jump_abort();\n        }\n    }\n    #endif\n\n    \n    if (MP_STATE_THREAD(mp_pending_exception) != MP_OBJ_NULL) {\n        mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n        mp_obj_t obj = MP_STATE_THREAD(mp_pending_exception);\n        if (obj != MP_OBJ_NULL) {\n            MP_STATE_THREAD(mp_pending_exception) = MP_OBJ_NULL;\n            if (raise_exc) {\n                MICROPY_END_ATOMIC_SECTION(atomic_state);\n                nlr_raise(obj);\n            }\n        }\n        MICROPY_END_ATOMIC_SECTION(atomic_state);\n    }\n\n    \n    #if MICROPY_ENABLE_SCHEDULER\n    if (MP_STATE_VM(sched_state) == MP_SCHED_PENDING) {\n        mp_sched_run_pending();\n    }\n    #endif\n}\n\n\nvoid mp_event_handle_nowait(void) {\n    #if defined(MICROPY_EVENT_POLL_HOOK_FAST) && !MICROPY_PREVIEW_VERSION_2\n    \n    MICROPY_EVENT_POLL_HOOK_FAST\n    #else\n    \n    MICROPY_INTERNAL_EVENT_HOOK;\n    mp_handle_pending(true);\n    #endif\n}\n\n\n\nvoid mp_event_wait_indefinite(void) {\n    #if defined(MICROPY_EVENT_POLL_HOOK) && !MICROPY_PREVIEW_VERSION_2\n    \n    MICROPY_EVENT_POLL_HOOK\n    #else\n    mp_event_handle_nowait();\n    MICROPY_INTERNAL_WFE(-1);\n    #endif\n}\n\n\n\nvoid mp_event_wait_ms(mp_uint_t timeout_ms) {\n    #if defined(MICROPY_EVENT_POLL_HOOK) && !MICROPY_PREVIEW_VERSION_2\n    \n    MICROPY_EVENT_POLL_HOOK\n    #else\n    mp_event_handle_nowait();\n    MICROPY_INTERNAL_WFE(timeout_ms);\n    #endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}