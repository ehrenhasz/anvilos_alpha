{
  "module_name": "objmodule.c",
  "hash_id": "6eab35549e8ae23b2c9e35094267aa6bede0070302beb7fecf1fabc5824f794f",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objmodule.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/bc.h\"\n#include \"py/objmodule.h\"\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n\nstatic void module_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_module_t *self = MP_OBJ_TO_PTR(self_in);\n\n    const char *module_name = \"\";\n    mp_map_elem_t *elem = mp_map_lookup(&self->globals->map, MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_MAP_LOOKUP);\n    if (elem != NULL) {\n        module_name = mp_obj_str_get_str(elem->value);\n    }\n\n    #if MICROPY_PY___FILE__\n    \n    \n    elem = mp_map_lookup(&self->globals->map, MP_OBJ_NEW_QSTR(MP_QSTR___file__), MP_MAP_LOOKUP);\n    if (elem != NULL) {\n        mp_printf(print, \"<module '%s' from '%s'>\", module_name, mp_obj_str_get_str(elem->value));\n        return;\n    }\n    #endif\n\n    mp_printf(print, \"<module '%s'>\", module_name);\n}\n\nstatic void module_attr_try_delegation(mp_obj_t self_in, qstr attr, mp_obj_t *dest);\n\nstatic void module_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    mp_obj_module_t *self = MP_OBJ_TO_PTR(self_in);\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        mp_map_elem_t *elem = mp_map_lookup(&self->globals->map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);\n        if (elem != NULL) {\n            dest[0] = elem->value;\n        #if MICROPY_CPYTHON_COMPAT\n        } else if (attr == MP_QSTR___dict__) {\n            dest[0] = MP_OBJ_FROM_PTR(self->globals);\n        #endif\n        #if MICROPY_MODULE_GETATTR\n        } else if (attr != MP_QSTR___getattr__) {\n            elem = mp_map_lookup(&self->globals->map, MP_OBJ_NEW_QSTR(MP_QSTR___getattr__), MP_MAP_LOOKUP);\n            if (elem != NULL) {\n                dest[0] = mp_call_function_1(elem->value, MP_OBJ_NEW_QSTR(attr));\n            } else {\n                module_attr_try_delegation(self_in, attr, dest);\n            }\n        #endif\n        } else {\n            module_attr_try_delegation(self_in, attr, dest);\n        }\n    } else {\n        \n        mp_obj_dict_t *dict = self->globals;\n        if (dict->map.is_fixed) {\n            #if MICROPY_CAN_OVERRIDE_BUILTINS\n            if (dict == &mp_module_builtins_globals) {\n                if (MP_STATE_VM(mp_module_builtins_override_dict) == NULL) {\n                    MP_STATE_VM(mp_module_builtins_override_dict) = MP_OBJ_TO_PTR(mp_obj_new_dict(1));\n                }\n                dict = MP_STATE_VM(mp_module_builtins_override_dict);\n            } else\n            #endif\n            {\n                \n                module_attr_try_delegation(self_in, attr, dest);\n                return;\n            }\n        }\n        if (dest[1] == MP_OBJ_NULL) {\n            \n            mp_obj_dict_delete(MP_OBJ_FROM_PTR(dict), MP_OBJ_NEW_QSTR(attr));\n        } else {\n            \n            mp_obj_dict_store(MP_OBJ_FROM_PTR(dict), MP_OBJ_NEW_QSTR(attr), dest[1]);\n        }\n        dest[0] = MP_OBJ_NULL; \n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_module,\n    MP_QSTR_module,\n    MP_TYPE_FLAG_NONE,\n    print, module_print,\n    attr, module_attr\n    );\n\nmp_obj_t mp_obj_new_module(qstr module_name) {\n    mp_map_t *mp_loaded_modules_map = &MP_STATE_VM(mp_loaded_modules_dict).map;\n    mp_map_elem_t *el = mp_map_lookup(mp_loaded_modules_map, MP_OBJ_NEW_QSTR(module_name), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n    \n    \n    if (el->value != MP_OBJ_NULL) {\n        return el->value;\n    }\n\n    \n    mp_module_context_t *o = m_new_obj(mp_module_context_t);\n    o->module.base.type = &mp_type_module;\n    o->module.globals = MP_OBJ_TO_PTR(mp_obj_new_dict(MICROPY_MODULE_DICT_SIZE));\n\n    \n    mp_obj_dict_store(MP_OBJ_FROM_PTR(o->module.globals), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(module_name));\n\n    \n    el->value = MP_OBJ_FROM_PTR(o);\n\n    \n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n\n\nstatic const mp_rom_map_elem_t mp_builtin_module_table[] = {\n    \n    MICROPY_REGISTERED_MODULES\n};\nMP_DEFINE_CONST_MAP(mp_builtin_module_map, mp_builtin_module_table);\n\nstatic const mp_rom_map_elem_t mp_builtin_extensible_module_table[] = {\n    \n    MICROPY_REGISTERED_EXTENSIBLE_MODULES\n};\nMP_DEFINE_CONST_MAP(mp_builtin_extensible_module_map, mp_builtin_extensible_module_table);\n\n#if MICROPY_MODULE_ATTR_DELEGATION && defined(MICROPY_MODULE_DELEGATIONS)\ntypedef struct _mp_module_delegation_entry_t {\n    mp_rom_obj_t mod;\n    mp_attr_fun_t fun;\n} mp_module_delegation_entry_t;\n\nstatic const mp_module_delegation_entry_t mp_builtin_module_delegation_table[] = {\n    \n    MICROPY_MODULE_DELEGATIONS\n};\n#endif\n\n\n\nmp_obj_t mp_module_get_builtin(qstr module_name, bool extensible) {\n    mp_map_elem_t *elem = mp_map_lookup((mp_map_t *)(extensible ? &mp_builtin_extensible_module_map : &mp_builtin_module_map), MP_OBJ_NEW_QSTR(module_name), MP_MAP_LOOKUP);\n    if (!elem) {\n        #if MICROPY_PY_SYS\n        \n        \n        if (module_name == MP_QSTR_usys) {\n            return MP_OBJ_FROM_PTR(&mp_module_sys);\n        }\n        #endif\n\n        if (extensible) {\n            \n            \n            \n            return MP_OBJ_NULL;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        size_t module_name_len;\n        const char *module_name_str = (const char *)qstr_data(module_name, &module_name_len);\n        if (module_name_str[0] != 'u') {\n            return MP_OBJ_NULL;\n        }\n        elem = mp_map_lookup((mp_map_t *)&mp_builtin_extensible_module_map, MP_OBJ_NEW_QSTR(qstr_from_strn(module_name_str + 1, module_name_len - 1)), MP_MAP_LOOKUP);\n        if (!elem) {\n            return MP_OBJ_NULL;\n        }\n    }\n\n    #if MICROPY_MODULE_BUILTIN_INIT\n    \n    \n    \n    mp_obj_t dest[2];\n    mp_load_method_maybe(elem->value, MP_QSTR___init__, dest);\n    if (dest[0] != MP_OBJ_NULL) {\n        mp_call_method_n_kw(0, 0, dest);\n    }\n    #endif\n\n    return elem->value;\n}\n\nstatic void module_attr_try_delegation(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    #if MICROPY_MODULE_ATTR_DELEGATION && defined(MICROPY_MODULE_DELEGATIONS)\n    \n    size_t n = MP_ARRAY_SIZE(mp_builtin_module_delegation_table);\n    for (size_t i = 0; i < n; ++i) {\n        if (*(mp_obj_t *)(&mp_builtin_module_delegation_table[i].mod) == self_in) {\n            mp_builtin_module_delegation_table[i].fun(self_in, attr, dest);\n            break;\n        }\n    }\n    #else\n    (void)self_in;\n    (void)attr;\n    (void)dest;\n    #endif\n}\n\nvoid mp_module_generic_attr(qstr attr, mp_obj_t *dest, const uint16_t *keys, mp_obj_t *values) {\n    for (size_t i = 0; keys[i] != MP_QSTRnull; ++i) {\n        if (attr == keys[i]) {\n            if (dest[0] == MP_OBJ_NULL) {\n                \n                dest[0] = values[i];\n            } else {\n                \n                values[i] = dest[1];\n                dest[0] = MP_OBJ_NULL; \n            }\n            return;\n        }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}