{
  "module_name": "reader.c",
  "hash_id": "7161c6c7c56e3f50c4e714ff48b454a8d64c1f39cdcb4fea112d2b62ae9ec021",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/reader.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n#include \"py/mperrno.h\"\n#include \"py/mpthread.h\"\n#include \"py/reader.h\"\n\ntypedef struct _mp_reader_mem_t {\n    size_t free_len; \n    const byte *beg;\n    const byte *cur;\n    const byte *end;\n} mp_reader_mem_t;\n\nstatic mp_uint_t mp_reader_mem_readbyte(void *data) {\n    mp_reader_mem_t *reader = (mp_reader_mem_t *)data;\n    if (reader->cur < reader->end) {\n        return *reader->cur++;\n    } else {\n        return MP_READER_EOF;\n    }\n}\n\nstatic void mp_reader_mem_close(void *data) {\n    mp_reader_mem_t *reader = (mp_reader_mem_t *)data;\n    if (reader->free_len > 0) {\n        m_del(char, (char *)reader->beg, reader->free_len);\n    }\n    m_del_obj(mp_reader_mem_t, reader);\n}\n\nvoid mp_reader_new_mem(mp_reader_t *reader, const byte *buf, size_t len, size_t free_len) {\n    mp_reader_mem_t *rm = m_new_obj(mp_reader_mem_t);\n    rm->free_len = free_len;\n    rm->beg = buf;\n    rm->cur = buf;\n    rm->end = buf + len;\n    reader->data = rm;\n    reader->readbyte = mp_reader_mem_readbyte;\n    reader->close = mp_reader_mem_close;\n}\n\n#if MICROPY_READER_POSIX\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\ntypedef struct _mp_reader_posix_t {\n    bool close_fd;\n    int fd;\n    size_t len;\n    size_t pos;\n    byte buf[20];\n} mp_reader_posix_t;\n\nstatic mp_uint_t mp_reader_posix_readbyte(void *data) {\n    mp_reader_posix_t *reader = (mp_reader_posix_t *)data;\n    if (reader->pos >= reader->len) {\n        if (reader->len == 0) {\n            return MP_READER_EOF;\n        } else {\n            MP_THREAD_GIL_EXIT();\n            int n = read(reader->fd, reader->buf, sizeof(reader->buf));\n            MP_THREAD_GIL_ENTER();\n            if (n <= 0) {\n                reader->len = 0;\n                return MP_READER_EOF;\n            }\n            reader->len = n;\n            reader->pos = 0;\n        }\n    }\n    return reader->buf[reader->pos++];\n}\n\nstatic void mp_reader_posix_close(void *data) {\n    mp_reader_posix_t *reader = (mp_reader_posix_t *)data;\n    if (reader->close_fd) {\n        MP_THREAD_GIL_EXIT();\n        close(reader->fd);\n        MP_THREAD_GIL_ENTER();\n    }\n    m_del_obj(mp_reader_posix_t, reader);\n}\n\nvoid mp_reader_new_file_from_fd(mp_reader_t *reader, int fd, bool close_fd) {\n    mp_reader_posix_t *rp = m_new_obj(mp_reader_posix_t);\n    rp->close_fd = close_fd;\n    rp->fd = fd;\n    MP_THREAD_GIL_EXIT();\n    int n = read(rp->fd, rp->buf, sizeof(rp->buf));\n    if (n == -1) {\n        if (close_fd) {\n            close(fd);\n        }\n        MP_THREAD_GIL_ENTER();\n        mp_raise_OSError(errno);\n    }\n    MP_THREAD_GIL_ENTER();\n    rp->len = n;\n    rp->pos = 0;\n    reader->data = rp;\n    reader->readbyte = mp_reader_posix_readbyte;\n    reader->close = mp_reader_posix_close;\n}\n\n#if !MICROPY_VFS_POSIX\n\nvoid mp_reader_new_file(mp_reader_t *reader, qstr filename) {\n    MP_THREAD_GIL_EXIT();\n    int fd = open(qstr_str(filename), O_RDONLY, 0644);\n    MP_THREAD_GIL_ENTER();\n    if (fd < 0) {\n        mp_raise_OSError_with_filename(errno, qstr_str(filename));\n    }\n    mp_reader_new_file_from_fd(reader, fd, true);\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}