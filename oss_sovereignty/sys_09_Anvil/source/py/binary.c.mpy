{
  "module_name": "binary.c",
  "hash_id": "be8a2e30e9c4368e6d900659c4a772dce1f44c5f87b3147fd316c5aaf95fd65a",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/binary.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/binary.h\"\n#include \"py/smallint.h\"\n#include \"py/objint.h\"\n#include \"py/runtime.h\"\n\n\n\n#ifndef alignof\n#define alignof(type) offsetof(struct { char c; type t; }, t)\n#endif\n\nsize_t mp_binary_get_size(char struct_type, char val_type, size_t *palign) {\n    size_t size = 0;\n    int align = 1;\n    switch (struct_type) {\n        case '<':\n        case '>':\n            switch (val_type) {\n                case 'b':\n                case 'B':\n                    size = 1;\n                    break;\n                case 'h':\n                case 'H':\n                    size = 2;\n                    break;\n                case 'i':\n                case 'I':\n                    size = 4;\n                    break;\n                case 'l':\n                case 'L':\n                    size = 4;\n                    break;\n                case 'q':\n                case 'Q':\n                    size = 8;\n                    break;\n                case 'P':\n                case 'O':\n                case 'S':\n                    size = sizeof(void *);\n                    break;\n                case 'e':\n                    size = 2;\n                    break;\n                case 'f':\n                    size = 4;\n                    break;\n                case 'd':\n                    size = 8;\n                    break;\n            }\n            break;\n        case '@': {\n            \n            \n            \n            \n            \n            \n            \n            switch (val_type) {\n                case BYTEARRAY_TYPECODE:\n                case 'b':\n                case 'B':\n                    align = size = 1;\n                    break;\n                case 'h':\n                case 'H':\n                    align = alignof(short);\n                    size = sizeof(short);\n                    break;\n                case 'i':\n                case 'I':\n                    align = alignof(int);\n                    size = sizeof(int);\n                    break;\n                case 'l':\n                case 'L':\n                    align = alignof(long);\n                    size = sizeof(long);\n                    break;\n                case 'q':\n                case 'Q':\n                    align = alignof(long long);\n                    size = sizeof(long long);\n                    break;\n                case 'P':\n                case 'O':\n                case 'S':\n                    align = alignof(void *);\n                    size = sizeof(void *);\n                    break;\n                case 'e':\n                    align = 2;\n                    size = 2;\n                    break;\n                case 'f':\n                    align = alignof(float);\n                    size = sizeof(float);\n                    break;\n                case 'd':\n                    align = alignof(double);\n                    size = sizeof(double);\n                    break;\n            }\n        }\n    }\n\n    if (size == 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"bad typecode\"));\n    }\n\n    if (palign != NULL) {\n        *palign = align;\n    }\n    return size;\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT && MICROPY_FLOAT_USE_NATIVE_FLT16\n\nstatic inline float mp_decode_half_float(uint16_t hf) {\n    union {\n        uint16_t i;\n        _Float16 f;\n    } fpu = { .i = hf };\n    return fpu.f;\n}\n\nstatic inline uint16_t mp_encode_half_float(float x) {\n    union {\n        uint16_t i;\n        _Float16 f;\n    } fp_sp = { .f = (_Float16)x };\n    return fp_sp.i;\n}\n\n#elif MICROPY_PY_BUILTINS_FLOAT\n\nstatic float mp_decode_half_float(uint16_t hf) {\n    union {\n        uint32_t i;\n        float f;\n    } fpu;\n\n    uint16_t m = hf & 0x3ff;\n    int e = (hf >> 10) & 0x1f;\n    if (e == 0x1f) {\n        \n        e = 0xff;\n    } else if (e) {\n        \n        e += 127 - 15;\n    } else if (m) {\n        \n        e = 127 - 15;\n        while (!(m & 0x400)) {\n            m <<= 1;\n            --e;\n        }\n        m -= 0x400;\n        ++e;\n    }\n\n    fpu.i = ((hf & 0x8000) << 16) | (e << 23) | (m << 13);\n    return fpu.f;\n}\n\nstatic uint16_t mp_encode_half_float(float x) {\n    union {\n        uint32_t i;\n        float f;\n    } fpu = { .f = x };\n\n    uint16_t m = (fpu.i >> 13) & 0x3ff;\n    if (fpu.i & (1 << 12)) {\n        \n        ++m;\n    }\n    int e = (fpu.i >> 23) & 0xff;\n\n    if (e == 0xff) {\n        \n        e = 0x1f;\n    } else if (e != 0) {\n        e -= 127 - 15;\n        if (e < 0) {\n            \n            if (e >= -11) {\n                m = (m | 0x400) >> -e;\n                if (m & 1) {\n                    m = (m >> 1) + 1;\n                } else {\n                    m >>= 1;\n                }\n            } else {\n                m = 0;\n            }\n            e = 0;\n        } else if (e > 0x3f) {\n            \n            e = 0x1f;\n            m = 0;\n        }\n    }\n\n    uint16_t bits = ((fpu.i >> 16) & 0x8000) | (e << 10) | m;\n    return bits;\n}\n\n#endif\n\nmp_obj_t mp_binary_get_val_array(char typecode, void *p, size_t index) {\n    mp_int_t val = 0;\n    switch (typecode) {\n        case 'b':\n            val = ((signed char *)p)[index];\n            break;\n        case BYTEARRAY_TYPECODE:\n        case 'B':\n            val = ((unsigned char *)p)[index];\n            break;\n        case 'h':\n            val = ((short *)p)[index];\n            break;\n        case 'H':\n            val = ((unsigned short *)p)[index];\n            break;\n        case 'i':\n            return mp_obj_new_int(((int *)p)[index]);\n        case 'I':\n            return mp_obj_new_int_from_uint(((unsigned int *)p)[index]);\n        case 'l':\n            return mp_obj_new_int(((long *)p)[index]);\n        case 'L':\n            return mp_obj_new_int_from_uint(((unsigned long *)p)[index]);\n        #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n        case 'q':\n            return mp_obj_new_int_from_ll(((long long *)p)[index]);\n        case 'Q':\n            return mp_obj_new_int_from_ull(((unsigned long long *)p)[index]);\n        #endif\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case 'f':\n            return mp_obj_new_float_from_f(((float *)p)[index]);\n        case 'd':\n            return mp_obj_new_float_from_d(((double *)p)[index]);\n        #endif\n        \n        case 'O':\n            return ((mp_obj_t *)p)[index];\n        \n        case 'P':\n            return mp_obj_new_int((mp_int_t)(uintptr_t)((void **)p)[index]);\n    }\n    return MP_OBJ_NEW_SMALL_INT(val);\n}\n\n\n\n\nlong long mp_binary_get_int(size_t size, bool is_signed, bool big_endian, const byte *src) {\n    int delta;\n    if (!big_endian) {\n        delta = -1;\n        src += size - 1;\n    } else {\n        delta = 1;\n    }\n\n    unsigned long long val = 0;\n    if (is_signed && *src & 0x80) {\n        val = -1;\n    }\n    for (uint i = 0; i < size; i++) {\n        val <<= 8;\n        val |= *src;\n        src += delta;\n    }\n\n    return val;\n}\n\n#define is_signed(typecode) (typecode > 'Z')\nmp_obj_t mp_binary_get_val(char struct_type, char val_type, byte *p_base, byte **ptr) {\n    byte *p = *ptr;\n    size_t align;\n\n    size_t size = mp_binary_get_size(struct_type, val_type, &align);\n    if (struct_type == '@') {\n        \n        p = p_base + (uintptr_t)MP_ALIGN(p - p_base, align);\n        #if MP_ENDIANNESS_LITTLE\n        struct_type = '<';\n        #else\n        struct_type = '>';\n        #endif\n    }\n    *ptr = p + size;\n\n    long long val = mp_binary_get_int(size, is_signed(val_type), (struct_type == '>'), p);\n\n    if (val_type == 'O') {\n        return (mp_obj_t)(mp_uint_t)val;\n    } else if (val_type == 'S') {\n        const char *s_val = (const char *)(uintptr_t)(mp_uint_t)val;\n        return mp_obj_new_str(s_val, strlen(s_val));\n    #if MICROPY_PY_BUILTINS_FLOAT\n    } else if (val_type == 'e') {\n        return mp_obj_new_float_from_f(mp_decode_half_float(val));\n    } else if (val_type == 'f') {\n        union {\n            uint32_t i;\n            float f;\n        } fpu = {val};\n        return mp_obj_new_float_from_f(fpu.f);\n    } else if (val_type == 'd') {\n        union {\n            uint64_t i;\n            double f;\n        } fpu = {val};\n        return mp_obj_new_float_from_d(fpu.f);\n    #endif\n    } else if (is_signed(val_type)) {\n        if ((long long)MP_SMALL_INT_MIN <= val && val <= (long long)MP_SMALL_INT_MAX) {\n            return mp_obj_new_int((mp_int_t)val);\n        } else {\n            return mp_obj_new_int_from_ll(val);\n        }\n    } else {\n        if ((unsigned long long)val <= (unsigned long long)MP_SMALL_INT_MAX) {\n            return mp_obj_new_int_from_uint((mp_uint_t)val);\n        } else {\n            return mp_obj_new_int_from_ull(val);\n        }\n    }\n}\n\nvoid mp_binary_set_int(size_t val_sz, bool big_endian, byte *dest, mp_uint_t val) {\n    if (MP_ENDIANNESS_LITTLE && !big_endian) {\n        memcpy(dest, &val, val_sz);\n    } else if (MP_ENDIANNESS_BIG && big_endian) {\n        \n        memcpy(dest, (byte *)&val + sizeof(mp_uint_t) - val_sz, val_sz);\n    } else {\n        const byte *src;\n        if (MP_ENDIANNESS_LITTLE) {\n            src = (const byte *)&val + val_sz;\n        } else {\n            src = (const byte *)&val + sizeof(mp_uint_t);\n        }\n        while (val_sz--) {\n            *dest++ = *--src;\n        }\n    }\n}\n\nvoid mp_binary_set_val(char struct_type, char val_type, mp_obj_t val_in, byte *p_base, byte **ptr) {\n    byte *p = *ptr;\n    size_t align;\n\n    size_t size = mp_binary_get_size(struct_type, val_type, &align);\n    if (struct_type == '@') {\n        \n        p = p_base + (uintptr_t)MP_ALIGN(p - p_base, align);\n        if (MP_ENDIANNESS_LITTLE) {\n            struct_type = '<';\n        } else {\n            struct_type = '>';\n        }\n    }\n    *ptr = p + size;\n\n    mp_uint_t val;\n    switch (val_type) {\n        case 'O':\n            val = (mp_uint_t)val_in;\n            break;\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case 'e':\n            val = mp_encode_half_float(mp_obj_get_float_to_f(val_in));\n            break;\n        case 'f': {\n            union {\n                uint32_t i;\n                float f;\n            } fp_sp;\n            fp_sp.f = mp_obj_get_float_to_f(val_in);\n            val = fp_sp.i;\n            break;\n        }\n        case 'd': {\n            union {\n                uint64_t i64;\n                uint32_t i32[2];\n                double f;\n            } fp_dp;\n            fp_dp.f = mp_obj_get_float_to_d(val_in);\n            if (MP_BYTES_PER_OBJ_WORD == 8) {\n                val = fp_dp.i64;\n            } else {\n                int be = struct_type == '>';\n                mp_binary_set_int(sizeof(uint32_t), be, p, fp_dp.i32[MP_ENDIANNESS_BIG ^ be]);\n                p += sizeof(uint32_t);\n                val = fp_dp.i32[MP_ENDIANNESS_LITTLE ^ be];\n            }\n            break;\n        }\n        #endif\n        default:\n            #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n            if (mp_obj_is_exact_type(val_in, &mp_type_int)) {\n                mp_obj_int_to_bytes_impl(val_in, struct_type == '>', size, p);\n                return;\n            }\n            #endif\n\n            val = mp_obj_get_int(val_in);\n            \n            if (MP_BYTES_PER_OBJ_WORD < 8 && size > sizeof(val)) {\n                int c = (mp_int_t)val < 0 ? 0xff : 0x00;\n                memset(p, c, size);\n                if (struct_type == '>') {\n                    p += size - sizeof(val);\n                }\n            }\n            break;\n    }\n\n    mp_binary_set_int(MIN((size_t)size, sizeof(val)), struct_type == '>', p, val);\n}\n\nvoid mp_binary_set_val_array(char typecode, void *p, size_t index, mp_obj_t val_in) {\n    switch (typecode) {\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case 'f':\n            ((float *)p)[index] = mp_obj_get_float_to_f(val_in);\n            break;\n        case 'd':\n            ((double *)p)[index] = mp_obj_get_float_to_d(val_in);\n            break;\n        #endif\n        \n        case 'O':\n            ((mp_obj_t *)p)[index] = val_in;\n            break;\n        default:\n            #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n            if (mp_obj_is_exact_type(val_in, &mp_type_int)) {\n                size_t size = mp_binary_get_size('@', typecode, NULL);\n                mp_obj_int_to_bytes_impl(val_in, MP_ENDIANNESS_BIG,\n                    size, (uint8_t *)p + index * size);\n                return;\n            }\n            #endif\n            mp_binary_set_val_array_from_int(typecode, p, index, mp_obj_get_int(val_in));\n    }\n}\n\nvoid mp_binary_set_val_array_from_int(char typecode, void *p, size_t index, mp_int_t val) {\n    switch (typecode) {\n        case 'b':\n            ((signed char *)p)[index] = val;\n            break;\n        case BYTEARRAY_TYPECODE:\n        case 'B':\n            ((unsigned char *)p)[index] = val;\n            break;\n        case 'h':\n            ((short *)p)[index] = val;\n            break;\n        case 'H':\n            ((unsigned short *)p)[index] = val;\n            break;\n        case 'i':\n            ((int *)p)[index] = val;\n            break;\n        case 'I':\n            ((unsigned int *)p)[index] = val;\n            break;\n        case 'l':\n            ((long *)p)[index] = val;\n            break;\n        case 'L':\n            ((unsigned long *)p)[index] = val;\n            break;\n        #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n        case 'q':\n            ((long long *)p)[index] = val;\n            break;\n        case 'Q':\n            ((unsigned long long *)p)[index] = val;\n            break;\n        #endif\n        #if MICROPY_PY_BUILTINS_FLOAT\n        case 'f':\n            ((float *)p)[index] = (float)val;\n            break;\n        case 'd':\n            ((double *)p)[index] = (double)val;\n            break;\n        #endif\n        \n        case 'P':\n            ((void **)p)[index] = (void *)(uintptr_t)val;\n            break;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}