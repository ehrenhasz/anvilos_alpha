{
  "module_name": "modmath.c",
  "hash_id": "4dba045f3f56d06b78474cbf0699ffd9debf6bf2ac35dd030ec38591e881e925",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modmath.c",
  "human_readable_source": " \n\n#include \"py/builtin.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT && MICROPY_PY_MATH\n\n#include <math.h>\n\n\n\n#define MP_PI MICROPY_FLOAT_CONST(3.14159265358979323846)\n#define MP_PI_4 MICROPY_FLOAT_CONST(0.78539816339744830962)\n#define MP_3_PI_4 MICROPY_FLOAT_CONST(2.35619449019234492885)\n\nstatic NORETURN void math_error(void) {\n    mp_raise_ValueError(MP_ERROR_TEXT(\"math domain error\"));\n}\n\nstatic mp_obj_t math_generic_1(mp_obj_t x_obj, mp_float_t (*f)(mp_float_t)) {\n    mp_float_t x = mp_obj_get_float(x_obj);\n    mp_float_t ans = f(x);\n    if ((isnan(ans) && !isnan(x)) || (isinf(ans) && !isinf(x))) {\n        math_error();\n    }\n    return mp_obj_new_float(ans);\n}\n\nstatic mp_obj_t math_generic_2(mp_obj_t x_obj, mp_obj_t y_obj, mp_float_t (*f)(mp_float_t, mp_float_t)) {\n    mp_float_t x = mp_obj_get_float(x_obj);\n    mp_float_t y = mp_obj_get_float(y_obj);\n    mp_float_t ans = f(x, y);\n    if ((isnan(ans) && !isnan(x) && !isnan(y)) || (isinf(ans) && !isinf(x) && !isinf(y))) {\n        math_error();\n    }\n    return mp_obj_new_float(ans);\n}\n\n#define MATH_FUN_1(py_name, c_name) \\\n    static mp_obj_t mp_math_##py_name(mp_obj_t x_obj) { \\\n        return math_generic_1(x_obj, MICROPY_FLOAT_C_FUN(c_name)); \\\n    } \\\n    static MP_DEFINE_CONST_FUN_OBJ_1(mp_math_##py_name##_obj, mp_math_##py_name);\n\n#define MATH_FUN_1_TO_BOOL(py_name, c_name) \\\n    static mp_obj_t mp_math_##py_name(mp_obj_t x_obj) { return mp_obj_new_bool(c_name(mp_obj_get_float(x_obj))); } \\\n    static MP_DEFINE_CONST_FUN_OBJ_1(mp_math_##py_name##_obj, mp_math_##py_name);\n\n#define MATH_FUN_1_TO_INT(py_name, c_name) \\\n    static mp_obj_t mp_math_##py_name(mp_obj_t x_obj) { return mp_obj_new_int_from_float(MICROPY_FLOAT_C_FUN(c_name)(mp_obj_get_float(x_obj))); } \\\n    static MP_DEFINE_CONST_FUN_OBJ_1(mp_math_##py_name##_obj, mp_math_##py_name);\n\n#define MATH_FUN_2(py_name, c_name) \\\n    static mp_obj_t mp_math_##py_name(mp_obj_t x_obj, mp_obj_t y_obj) { \\\n        return math_generic_2(x_obj, y_obj, MICROPY_FLOAT_C_FUN(c_name)); \\\n    } \\\n    static MP_DEFINE_CONST_FUN_OBJ_2(mp_math_##py_name##_obj, mp_math_##py_name);\n\n#define MATH_FUN_2_FLT_INT(py_name, c_name) \\\n    static mp_obj_t mp_math_##py_name(mp_obj_t x_obj, mp_obj_t y_obj) { \\\n        return mp_obj_new_float(MICROPY_FLOAT_C_FUN(c_name)(mp_obj_get_float(x_obj), mp_obj_get_int(y_obj))); \\\n    } \\\n    static MP_DEFINE_CONST_FUN_OBJ_2(mp_math_##py_name##_obj, mp_math_##py_name);\n\n#if MP_NEED_LOG2\n#undef log2\n#undef log2f\n\nmp_float_t MICROPY_FLOAT_C_FUN(log2)(mp_float_t x) {\n    return MICROPY_FLOAT_C_FUN(log)(x) * MICROPY_FLOAT_CONST(1.442695040888963407354163704);\n}\n#endif\n\n\nMATH_FUN_1(sqrt, sqrt)\n\n#if MICROPY_PY_MATH_POW_FIX_NAN\nmp_float_t pow_func(mp_float_t x, mp_float_t y) {\n    \n    \n    if (x == MICROPY_FLOAT_CONST(1.0) || y == MICROPY_FLOAT_CONST(0.0)) {\n        return MICROPY_FLOAT_CONST(1.0);\n    }\n    return MICROPY_FLOAT_C_FUN(pow)(x, y);\n}\nMATH_FUN_2(pow, pow_func)\n#else\nMATH_FUN_2(pow, pow)\n#endif\n\nMATH_FUN_1(exp, exp)\n#if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n\nMATH_FUN_1(expm1, expm1)\n\nMATH_FUN_1(log2, log2)\n\nMATH_FUN_1(log10, log10)\n\nMATH_FUN_1(cosh, cosh)\n\nMATH_FUN_1(sinh, sinh)\n\nMATH_FUN_1(tanh, tanh)\n\nMATH_FUN_1(acosh, acosh)\n\nMATH_FUN_1(asinh, asinh)\n\nMATH_FUN_1(atanh, atanh)\n#endif\n\nMATH_FUN_1(cos, cos)\n\nMATH_FUN_1(sin, sin)\n\nMATH_FUN_1(tan, tan)\n\nMATH_FUN_1(acos, acos)\n\nMATH_FUN_1(asin, asin)\n\nMATH_FUN_1(atan, atan)\n\n#if MICROPY_PY_MATH_ATAN2_FIX_INFNAN\nmp_float_t atan2_func(mp_float_t x, mp_float_t y) {\n    if (isinf(x) && isinf(y)) {\n        return copysign(y < 0 ? MP_3_PI_4 : MP_PI_4, x);\n    }\n    return atan2(x, y);\n}\nMATH_FUN_2(atan2, atan2_func)\n#else\nMATH_FUN_2(atan2, atan2)\n#endif\n\nMATH_FUN_1_TO_INT(ceil, ceil)\n\nstatic mp_float_t MICROPY_FLOAT_C_FUN(copysign_func)(mp_float_t x, mp_float_t y) {\n    return MICROPY_FLOAT_C_FUN(copysign)(x, y);\n}\nMATH_FUN_2(copysign, copysign_func)\n\nstatic mp_float_t MICROPY_FLOAT_C_FUN(fabs_func)(mp_float_t x) {\n    return MICROPY_FLOAT_C_FUN(fabs)(x);\n}\nMATH_FUN_1(fabs, fabs_func)\n\nMATH_FUN_1_TO_INT(floor, floor) \n\n#if MICROPY_PY_MATH_FMOD_FIX_INFNAN\nmp_float_t fmod_func(mp_float_t x, mp_float_t y) {\n    return (!isinf(x) && isinf(y)) ? x : fmod(x, y);\n}\nMATH_FUN_2(fmod, fmod_func)\n#else\nMATH_FUN_2(fmod, fmod)\n#endif\n\nMATH_FUN_1_TO_BOOL(isfinite, isfinite)\n\nMATH_FUN_1_TO_BOOL(isinf, isinf)\n\nMATH_FUN_1_TO_BOOL(isnan, isnan)\n\nMATH_FUN_1_TO_INT(trunc, trunc)\n\nMATH_FUN_2_FLT_INT(ldexp, ldexp)\n#if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n\nMATH_FUN_1(erf, erf)\n\nMATH_FUN_1(erfc, erfc)\n\nMATH_FUN_1(gamma, tgamma)\n\nMATH_FUN_1(lgamma, lgamma)\n#endif\n\n\n#if MICROPY_PY_MATH_ISCLOSE\nstatic mp_obj_t mp_math_isclose(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_rel_tol, ARG_abs_tol };\n    static const mp_arg_t allowed_args[] = {\n        {MP_QSTR_rel_tol, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},\n        {MP_QSTR_abs_tol, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NEW_SMALL_INT(0)}},\n    };\n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 2, pos_args + 2, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n    const mp_float_t a = mp_obj_get_float(pos_args[0]);\n    const mp_float_t b = mp_obj_get_float(pos_args[1]);\n    const mp_float_t rel_tol = args[ARG_rel_tol].u_obj == MP_OBJ_NULL\n        ? (mp_float_t)1e-9 : mp_obj_get_float(args[ARG_rel_tol].u_obj);\n    const mp_float_t abs_tol = mp_obj_get_float(args[ARG_abs_tol].u_obj);\n    if (rel_tol < (mp_float_t)0.0 || abs_tol < (mp_float_t)0.0) {\n        math_error();\n    }\n    if (a == b) {\n        return mp_const_true;\n    }\n    const mp_float_t difference = MICROPY_FLOAT_C_FUN(fabs)(a - b);\n    if (isinf(difference)) { \n        return mp_const_false;\n    }\n    if ((difference <= abs_tol) ||\n        (difference <= MICROPY_FLOAT_C_FUN(fabs)(rel_tol * a)) ||\n        (difference <= MICROPY_FLOAT_C_FUN(fabs)(rel_tol * b))) {\n        return mp_const_true;\n    }\n    return mp_const_false;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_math_isclose_obj, 2, mp_math_isclose);\n#endif\n\n\n\n\nstatic mp_obj_t mp_math_log(size_t n_args, const mp_obj_t *args) {\n    mp_float_t x = mp_obj_get_float(args[0]);\n    if (x <= (mp_float_t)0.0) {\n        math_error();\n    }\n    mp_float_t l = MICROPY_FLOAT_C_FUN(log)(x);\n    if (n_args == 1) {\n        return mp_obj_new_float(l);\n    } else {\n        mp_float_t base = mp_obj_get_float(args[1]);\n        if (base <= (mp_float_t)0.0) {\n            math_error();\n        } else if (base == (mp_float_t)1.0) {\n            mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"divide by zero\"));\n        }\n        return mp_obj_new_float(l / MICROPY_FLOAT_C_FUN(log)(base));\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_math_log_obj, 1, 2, mp_math_log);\n\n\n\n\nstatic mp_obj_t mp_math_frexp(mp_obj_t x_obj) {\n    int int_exponent = 0;\n    mp_float_t significand = MICROPY_FLOAT_C_FUN(frexp)(mp_obj_get_float(x_obj), &int_exponent);\n    mp_obj_t tuple[2];\n    tuple[0] = mp_obj_new_float(significand);\n    tuple[1] = mp_obj_new_int(int_exponent);\n    return mp_obj_new_tuple(2, tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_math_frexp_obj, mp_math_frexp);\n\n\nstatic mp_obj_t mp_math_modf(mp_obj_t x_obj) {\n    mp_float_t int_part = 0.0;\n    mp_float_t x = mp_obj_get_float(x_obj);\n    mp_float_t fractional_part = MICROPY_FLOAT_C_FUN(modf)(x, &int_part);\n    #if MICROPY_PY_MATH_MODF_FIX_NEGZERO\n    if (fractional_part == MICROPY_FLOAT_CONST(0.0)) {\n        fractional_part = copysign(fractional_part, x);\n    }\n    #endif\n    mp_obj_t tuple[2];\n    tuple[0] = mp_obj_new_float(fractional_part);\n    tuple[1] = mp_obj_new_float(int_part);\n    return mp_obj_new_tuple(2, tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_math_modf_obj, mp_math_modf);\n\n\n\n\nstatic mp_obj_t mp_math_radians(mp_obj_t x_obj) {\n    return mp_obj_new_float(mp_obj_get_float(x_obj) * (MP_PI / MICROPY_FLOAT_CONST(180.0)));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_math_radians_obj, mp_math_radians);\n\n\nstatic mp_obj_t mp_math_degrees(mp_obj_t x_obj) {\n    return mp_obj_new_float(mp_obj_get_float(x_obj) * (MICROPY_FLOAT_CONST(180.0) / MP_PI));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_math_degrees_obj, mp_math_degrees);\n\n#if MICROPY_PY_MATH_FACTORIAL\n\n#if MICROPY_OPT_MATH_FACTORIAL\n\n\nstatic mp_obj_t mp_math_factorial_inner(mp_uint_t start, mp_uint_t end) {\n    if (start == end) {\n        return mp_obj_new_int(start);\n    } else if (end - start == 1) {\n        return mp_binary_op(MP_BINARY_OP_MULTIPLY, MP_OBJ_NEW_SMALL_INT(start), MP_OBJ_NEW_SMALL_INT(end));\n    } else if (end - start == 2) {\n        mp_obj_t left = MP_OBJ_NEW_SMALL_INT(start);\n        mp_obj_t middle = MP_OBJ_NEW_SMALL_INT(start + 1);\n        mp_obj_t right = MP_OBJ_NEW_SMALL_INT(end);\n        mp_obj_t tmp = mp_binary_op(MP_BINARY_OP_MULTIPLY, left, middle);\n        return mp_binary_op(MP_BINARY_OP_MULTIPLY, tmp, right);\n    } else {\n        mp_uint_t middle = start + ((end - start) >> 1);\n        mp_obj_t left = mp_math_factorial_inner(start, middle);\n        mp_obj_t right = mp_math_factorial_inner(middle + 1, end);\n        return mp_binary_op(MP_BINARY_OP_MULTIPLY, left, right);\n    }\n}\nstatic mp_obj_t mp_math_factorial(mp_obj_t x_obj) {\n    mp_int_t max = mp_obj_get_int(x_obj);\n    if (max < 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"negative factorial\"));\n    } else if (max == 0) {\n        return MP_OBJ_NEW_SMALL_INT(1);\n    }\n    return mp_math_factorial_inner(1, max);\n}\n\n#else\n\n\n\nstatic mp_obj_t mp_math_factorial(mp_obj_t x_obj) {\n    mp_int_t max = mp_obj_get_int(x_obj);\n    if (max < 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"negative factorial\"));\n    } else if (max <= 1) {\n        return MP_OBJ_NEW_SMALL_INT(1);\n    }\n    mp_int_t h = max >> 1;\n    mp_int_t q = h * h;\n    mp_int_t r = q << 1;\n    if (max & 1) {\n        r *= max;\n    }\n    mp_obj_t prod = MP_OBJ_NEW_SMALL_INT(r);\n    for (mp_int_t num = 1; num < max - 2; num += 2) {\n        q -= num;\n        prod = mp_binary_op(MP_BINARY_OP_MULTIPLY, prod, MP_OBJ_NEW_SMALL_INT(q));\n    }\n    return prod;\n}\n\n#endif\n\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_math_factorial_obj, mp_math_factorial);\n\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_math_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_math) },\n    { MP_ROM_QSTR(MP_QSTR_e), mp_const_float_e },\n    { MP_ROM_QSTR(MP_QSTR_pi), mp_const_float_pi },\n    #if MICROPY_PY_MATH_CONSTANTS\n    { MP_ROM_QSTR(MP_QSTR_tau), mp_const_float_tau },\n    { MP_ROM_QSTR(MP_QSTR_inf), mp_const_float_inf },\n    { MP_ROM_QSTR(MP_QSTR_nan), mp_const_float_nan },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_sqrt), MP_ROM_PTR(&mp_math_sqrt_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pow), MP_ROM_PTR(&mp_math_pow_obj) },\n    { MP_ROM_QSTR(MP_QSTR_exp), MP_ROM_PTR(&mp_math_exp_obj) },\n    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n    { MP_ROM_QSTR(MP_QSTR_expm1), MP_ROM_PTR(&mp_math_expm1_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_log), MP_ROM_PTR(&mp_math_log_obj) },\n    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n    { MP_ROM_QSTR(MP_QSTR_log2), MP_ROM_PTR(&mp_math_log2_obj) },\n    { MP_ROM_QSTR(MP_QSTR_log10), MP_ROM_PTR(&mp_math_log10_obj) },\n    { MP_ROM_QSTR(MP_QSTR_cosh), MP_ROM_PTR(&mp_math_cosh_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sinh), MP_ROM_PTR(&mp_math_sinh_obj) },\n    { MP_ROM_QSTR(MP_QSTR_tanh), MP_ROM_PTR(&mp_math_tanh_obj) },\n    { MP_ROM_QSTR(MP_QSTR_acosh), MP_ROM_PTR(&mp_math_acosh_obj) },\n    { MP_ROM_QSTR(MP_QSTR_asinh), MP_ROM_PTR(&mp_math_asinh_obj) },\n    { MP_ROM_QSTR(MP_QSTR_atanh), MP_ROM_PTR(&mp_math_atanh_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_cos), MP_ROM_PTR(&mp_math_cos_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sin), MP_ROM_PTR(&mp_math_sin_obj) },\n    { MP_ROM_QSTR(MP_QSTR_tan), MP_ROM_PTR(&mp_math_tan_obj) },\n    { MP_ROM_QSTR(MP_QSTR_acos), MP_ROM_PTR(&mp_math_acos_obj) },\n    { MP_ROM_QSTR(MP_QSTR_asin), MP_ROM_PTR(&mp_math_asin_obj) },\n    { MP_ROM_QSTR(MP_QSTR_atan), MP_ROM_PTR(&mp_math_atan_obj) },\n    { MP_ROM_QSTR(MP_QSTR_atan2), MP_ROM_PTR(&mp_math_atan2_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ceil), MP_ROM_PTR(&mp_math_ceil_obj) },\n    { MP_ROM_QSTR(MP_QSTR_copysign), MP_ROM_PTR(&mp_math_copysign_obj) },\n    { MP_ROM_QSTR(MP_QSTR_fabs), MP_ROM_PTR(&mp_math_fabs_obj) },\n    { MP_ROM_QSTR(MP_QSTR_floor), MP_ROM_PTR(&mp_math_floor_obj) },\n    { MP_ROM_QSTR(MP_QSTR_fmod), MP_ROM_PTR(&mp_math_fmod_obj) },\n    { MP_ROM_QSTR(MP_QSTR_frexp), MP_ROM_PTR(&mp_math_frexp_obj) },\n    { MP_ROM_QSTR(MP_QSTR_ldexp), MP_ROM_PTR(&mp_math_ldexp_obj) },\n    { MP_ROM_QSTR(MP_QSTR_modf), MP_ROM_PTR(&mp_math_modf_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isfinite), MP_ROM_PTR(&mp_math_isfinite_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isinf), MP_ROM_PTR(&mp_math_isinf_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isnan), MP_ROM_PTR(&mp_math_isnan_obj) },\n    #if MICROPY_PY_MATH_ISCLOSE\n    { MP_ROM_QSTR(MP_QSTR_isclose), MP_ROM_PTR(&mp_math_isclose_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_trunc), MP_ROM_PTR(&mp_math_trunc_obj) },\n    { MP_ROM_QSTR(MP_QSTR_radians), MP_ROM_PTR(&mp_math_radians_obj) },\n    { MP_ROM_QSTR(MP_QSTR_degrees), MP_ROM_PTR(&mp_math_degrees_obj) },\n    #if MICROPY_PY_MATH_FACTORIAL\n    { MP_ROM_QSTR(MP_QSTR_factorial), MP_ROM_PTR(&mp_math_factorial_obj) },\n    #endif\n    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n    { MP_ROM_QSTR(MP_QSTR_erf), MP_ROM_PTR(&mp_math_erf_obj) },\n    { MP_ROM_QSTR(MP_QSTR_erfc), MP_ROM_PTR(&mp_math_erfc_obj) },\n    { MP_ROM_QSTR(MP_QSTR_gamma), MP_ROM_PTR(&mp_math_gamma_obj) },\n    { MP_ROM_QSTR(MP_QSTR_lgamma), MP_ROM_PTR(&mp_math_lgamma_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_math_globals, mp_module_math_globals_table);\n\nconst mp_obj_module_t mp_module_math = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_math_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_math, mp_module_math);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}