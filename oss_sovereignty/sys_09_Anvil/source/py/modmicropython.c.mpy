{
  "module_name": "modmicropython.c",
  "hash_id": "721aacfc155a92890699bb822545feef10ccd18fc5194c956f4e641d0cc479a0",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modmicropython.c",
  "human_readable_source": " \n\n#include <stdio.h>\n\n#include \"py/builtin.h\"\n#include \"py/stackctrl.h\"\n#include \"py/runtime.h\"\n#include \"py/gc.h\"\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_MICROPYTHON\n\n\n\n\n#if MICROPY_ENABLE_COMPILER\nstatic mp_obj_t mp_micropython_opt_level(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 0) {\n        return MP_OBJ_NEW_SMALL_INT(MP_STATE_VM(mp_optimise_value));\n    } else {\n        MP_STATE_VM(mp_optimise_value) = mp_obj_get_int(args[0]);\n        return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_micropython_opt_level_obj, 0, 1, mp_micropython_opt_level);\n#endif\n\n#if MICROPY_PY_MICROPYTHON_MEM_INFO\n\n#if MICROPY_MEM_STATS\nstatic mp_obj_t mp_micropython_mem_total(void) {\n    return MP_OBJ_NEW_SMALL_INT(m_get_total_bytes_allocated());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_mem_total_obj, mp_micropython_mem_total);\n\nstatic mp_obj_t mp_micropython_mem_current(void) {\n    return MP_OBJ_NEW_SMALL_INT(m_get_current_bytes_allocated());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_mem_current_obj, mp_micropython_mem_current);\n\nstatic mp_obj_t mp_micropython_mem_peak(void) {\n    return MP_OBJ_NEW_SMALL_INT(m_get_peak_bytes_allocated());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_mem_peak_obj, mp_micropython_mem_peak);\n#endif\n\nmp_obj_t mp_micropython_mem_info(size_t n_args, const mp_obj_t *args) {\n    (void)args;\n    #if MICROPY_MEM_STATS\n    mp_printf(&mp_plat_print, \"mem: total=\" UINT_FMT \", current=\" UINT_FMT \", peak=\" UINT_FMT \"\\n\",\n        (mp_uint_t)m_get_total_bytes_allocated(), (mp_uint_t)m_get_current_bytes_allocated(), (mp_uint_t)m_get_peak_bytes_allocated());\n    #endif\n    #if MICROPY_STACK_CHECK\n    mp_printf(&mp_plat_print, \"stack: \" UINT_FMT \" out of \" UINT_FMT \"\\n\",\n        mp_stack_usage(), (mp_uint_t)MP_STATE_THREAD(stack_limit));\n    #else\n    mp_printf(&mp_plat_print, \"stack: \" UINT_FMT \"\\n\", mp_stack_usage());\n    #endif\n    #if MICROPY_ENABLE_GC\n    gc_dump_info(&mp_plat_print);\n    if (n_args == 1) {\n        \n        gc_dump_alloc_table(&mp_plat_print);\n    }\n    #else\n    (void)n_args;\n    #endif\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_micropython_mem_info_obj, 0, 1, mp_micropython_mem_info);\n\nstatic mp_obj_t mp_micropython_qstr_info(size_t n_args, const mp_obj_t *args) {\n    (void)args;\n    size_t n_pool, n_qstr, n_str_data_bytes, n_total_bytes;\n    qstr_pool_info(&n_pool, &n_qstr, &n_str_data_bytes, &n_total_bytes);\n    mp_printf(&mp_plat_print, \"qstr pool: n_pool=%u, n_qstr=%u, n_str_data_bytes=%u, n_total_bytes=%u\\n\",\n        n_pool, n_qstr, n_str_data_bytes, n_total_bytes);\n    if (n_args == 1) {\n        \n        qstr_dump_data();\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_micropython_qstr_info_obj, 0, 1, mp_micropython_qstr_info);\n\n#endif \n\n#if MICROPY_PY_MICROPYTHON_STACK_USE\nstatic mp_obj_t mp_micropython_stack_use(void) {\n    return MP_OBJ_NEW_SMALL_INT(mp_stack_usage());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_stack_use_obj, mp_micropython_stack_use);\n#endif\n\n#if MICROPY_ENABLE_PYSTACK\nstatic mp_obj_t mp_micropython_pystack_use(void) {\n    return MP_OBJ_NEW_SMALL_INT(mp_pystack_usage());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_pystack_use_obj, mp_micropython_pystack_use);\n#endif\n\n#if MICROPY_ENABLE_GC\nstatic mp_obj_t mp_micropython_heap_lock(void) {\n    gc_lock();\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_heap_lock_obj, mp_micropython_heap_lock);\n\nstatic mp_obj_t mp_micropython_heap_unlock(void) {\n    gc_unlock();\n    return MP_OBJ_NEW_SMALL_INT(MP_STATE_THREAD(gc_lock_depth));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_heap_unlock_obj, mp_micropython_heap_unlock);\n\n#if MICROPY_PY_MICROPYTHON_HEAP_LOCKED\nstatic mp_obj_t mp_micropython_heap_locked(void) {\n    return MP_OBJ_NEW_SMALL_INT(MP_STATE_THREAD(gc_lock_depth));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_heap_locked_obj, mp_micropython_heap_locked);\n#endif\n#endif\n\n#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF && (MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE == 0)\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_alloc_emergency_exception_buf_obj, mp_alloc_emergency_exception_buf);\n#endif\n\n#if MICROPY_KBD_EXCEPTION\nstatic mp_obj_t mp_micropython_kbd_intr(mp_obj_t int_chr_in) {\n    mp_hal_set_interrupt_char(mp_obj_get_int(int_chr_in));\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_micropython_kbd_intr_obj, mp_micropython_kbd_intr);\n#endif\n\n#if MICROPY_ENABLE_SCHEDULER\nstatic mp_obj_t mp_micropython_schedule(mp_obj_t function, mp_obj_t arg) {\n    if (!mp_sched_schedule(function, arg)) {\n        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"schedule queue full\"));\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mp_micropython_schedule_obj, mp_micropython_schedule);\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_micropython_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_micropython) },\n    { MP_ROM_QSTR(MP_QSTR_const), MP_ROM_PTR(&mp_identity_obj) },\n    #if MICROPY_ENABLE_COMPILER\n    { MP_ROM_QSTR(MP_QSTR_opt_level), MP_ROM_PTR(&mp_micropython_opt_level_obj) },\n    #endif\n    #if MICROPY_PY_MICROPYTHON_MEM_INFO\n    #if MICROPY_MEM_STATS\n    { MP_ROM_QSTR(MP_QSTR_mem_total), MP_ROM_PTR(&mp_micropython_mem_total_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mem_current), MP_ROM_PTR(&mp_micropython_mem_current_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mem_peak), MP_ROM_PTR(&mp_micropython_mem_peak_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_mem_info), MP_ROM_PTR(&mp_micropython_mem_info_obj) },\n    { MP_ROM_QSTR(MP_QSTR_qstr_info), MP_ROM_PTR(&mp_micropython_qstr_info_obj) },\n    #endif\n    #if MICROPY_PY_MICROPYTHON_STACK_USE\n    { MP_ROM_QSTR(MP_QSTR_stack_use), MP_ROM_PTR(&mp_micropython_stack_use_obj) },\n    #endif\n    #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF && (MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE == 0)\n    { MP_ROM_QSTR(MP_QSTR_alloc_emergency_exception_buf), MP_ROM_PTR(&mp_alloc_emergency_exception_buf_obj) },\n    #endif\n    #if MICROPY_ENABLE_PYSTACK\n    { MP_ROM_QSTR(MP_QSTR_pystack_use), MP_ROM_PTR(&mp_micropython_pystack_use_obj) },\n    #endif\n    #if MICROPY_ENABLE_GC\n    { MP_ROM_QSTR(MP_QSTR_heap_lock), MP_ROM_PTR(&mp_micropython_heap_lock_obj) },\n    { MP_ROM_QSTR(MP_QSTR_heap_unlock), MP_ROM_PTR(&mp_micropython_heap_unlock_obj) },\n    #if MICROPY_PY_MICROPYTHON_HEAP_LOCKED\n    { MP_ROM_QSTR(MP_QSTR_heap_locked), MP_ROM_PTR(&mp_micropython_heap_locked_obj) },\n    #endif\n    #endif\n    #if MICROPY_KBD_EXCEPTION\n    { MP_ROM_QSTR(MP_QSTR_kbd_intr), MP_ROM_PTR(&mp_micropython_kbd_intr_obj) },\n    #endif\n    #if MICROPY_ENABLE_SCHEDULER\n    { MP_ROM_QSTR(MP_QSTR_schedule), MP_ROM_PTR(&mp_micropython_schedule_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_micropython_globals, mp_module_micropython_globals_table);\n\nconst mp_obj_module_t mp_module_micropython = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_micropython_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_micropython, mp_module_micropython);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}