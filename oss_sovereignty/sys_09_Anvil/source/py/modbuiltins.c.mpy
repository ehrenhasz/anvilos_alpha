{
  "module_name": "modbuiltins.c",
  "hash_id": "19fa9c0e97ec009ee046ad755b131a850a710d4c8c661a50348a467c41a17b3a",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modbuiltins.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n\n#include \"py/smallint.h\"\n#include \"py/objint.h\"\n#include \"py/objstr.h\"\n#include \"py/objtype.h\"\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/stream.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#include <math.h>\n#endif\n\n#if MICROPY_PY_IO\nextern struct _mp_dummy_t mp_sys_stdout_obj; \n#endif\n\n\n\n\nstatic mp_obj_t mp_builtin___build_class__(size_t n_args, const mp_obj_t *args) {\n    assert(2 <= n_args);\n\n    \n    mp_obj_dict_t *old_locals = mp_locals_get();\n    mp_obj_t class_locals = mp_obj_new_dict(0);\n    mp_locals_set(MP_OBJ_TO_PTR(class_locals));\n\n    \n    mp_obj_t cell = mp_call_function_0(args[0]);\n\n    \n    mp_locals_set(old_locals);\n\n    \n    mp_obj_t meta;\n    if (n_args == 2) {\n        \n        meta = MP_OBJ_FROM_PTR(&mp_type_type);\n    } else {\n        \n        meta = MP_OBJ_FROM_PTR(mp_obj_get_type(args[2]));\n    }\n\n    \n\n    \n    mp_obj_t meta_args[3];\n    meta_args[0] = args[1]; \n    meta_args[1] = mp_obj_new_tuple(n_args - 2, args + 2); \n    meta_args[2] = class_locals; \n    mp_obj_t new_class = mp_call_function_n_kw(meta, 3, 0, meta_args);\n\n    \n    if (cell != mp_const_none) {\n        mp_obj_cell_set(cell, new_class);\n    }\n\n    return new_class;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR(mp_builtin___build_class___obj, 2, mp_builtin___build_class__);\n\nstatic mp_obj_t mp_builtin_abs(mp_obj_t o_in) {\n    return mp_unary_op(MP_UNARY_OP_ABS, o_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_abs_obj, mp_builtin_abs);\n\nstatic mp_obj_t mp_builtin_all(mp_obj_t o_in) {\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(o_in, &iter_buf);\n    mp_obj_t item;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        if (!mp_obj_is_true(item)) {\n            return mp_const_false;\n        }\n    }\n    return mp_const_true;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_all_obj, mp_builtin_all);\n\nstatic mp_obj_t mp_builtin_any(mp_obj_t o_in) {\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(o_in, &iter_buf);\n    mp_obj_t item;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        if (mp_obj_is_true(item)) {\n            return mp_const_true;\n        }\n    }\n    return mp_const_false;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_any_obj, mp_builtin_any);\n\nstatic mp_obj_t mp_builtin_bin(mp_obj_t o_in) {\n    mp_obj_t args[] = { MP_OBJ_NEW_QSTR(MP_QSTR__brace_open__colon__hash_b_brace_close_), o_in };\n    return mp_obj_str_format(MP_ARRAY_SIZE(args), args, NULL);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_bin_obj, mp_builtin_bin);\n\nstatic mp_obj_t mp_builtin_callable(mp_obj_t o_in) {\n    if (mp_obj_is_callable(o_in)) {\n        return mp_const_true;\n    } else {\n        return mp_const_false;\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_callable_obj, mp_builtin_callable);\n\nstatic mp_obj_t mp_builtin_chr(mp_obj_t o_in) {\n    #if MICROPY_PY_BUILTINS_STR_UNICODE\n    mp_uint_t c = mp_obj_get_int(o_in);\n    if (c >= 0x110000) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"chr() arg not in range(0x110000)\"));\n    }\n    VSTR_FIXED(buf, 4);\n    vstr_add_char(&buf, c);\n    return mp_obj_new_str_via_qstr(buf.buf, buf.len);\n    #else\n    mp_int_t ord = mp_obj_get_int(o_in);\n    if (0 <= ord && ord <= 0xff) {\n        uint8_t str[1] = {ord};\n        return mp_obj_new_str_via_qstr((char *)str, 1);\n    } else {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"chr() arg not in range(256)\"));\n    }\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_chr_obj, mp_builtin_chr);\n\nstatic mp_obj_t mp_builtin_dir(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t dir = mp_obj_new_list(0, NULL);\n    if (n_args == 0) {\n        \n        mp_obj_dict_t *dict = mp_locals_get();\n        for (size_t i = 0; i < dict->map.alloc; i++) {\n            if (mp_map_slot_is_filled(&dict->map, i)) {\n                mp_obj_list_append(dir, dict->map.table[i].key);\n            }\n        }\n    } else { \n        \n        \n        size_t nqstr = QSTR_TOTAL();\n        for (size_t i = MP_QSTR_ + 1; i < nqstr; ++i) {\n            mp_obj_t dest[2];\n            mp_load_method_protected(args[0], i, dest, false);\n            if (dest[0] != MP_OBJ_NULL) {\n                #if MICROPY_PY_ALL_SPECIAL_METHODS\n                \n                \n                if (i == MP_QSTR___dir__ && dest[1] != MP_OBJ_NULL) {\n                    return mp_call_method_n_kw(0, 0, dest);\n                }\n                #endif\n                mp_obj_list_append(dir, MP_OBJ_NEW_QSTR(i));\n            }\n        }\n    }\n    return dir;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_dir_obj, 0, 1, mp_builtin_dir);\n\nstatic mp_obj_t mp_builtin_divmod(mp_obj_t o1_in, mp_obj_t o2_in) {\n    return mp_binary_op(MP_BINARY_OP_DIVMOD, o1_in, o2_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_divmod_obj, mp_builtin_divmod);\n\nstatic mp_obj_t mp_builtin_hash(mp_obj_t o_in) {\n    \n    return mp_unary_op(MP_UNARY_OP_HASH, o_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_hash_obj, mp_builtin_hash);\n\nstatic mp_obj_t mp_builtin_hex(mp_obj_t o_in) {\n    #if MICROPY_PY_BUILTINS_STR_OP_MODULO\n    return mp_binary_op(MP_BINARY_OP_MODULO, MP_OBJ_NEW_QSTR(MP_QSTR__percent__hash_x), o_in);\n    #else\n    mp_obj_t args[] = { MP_OBJ_NEW_QSTR(MP_QSTR__brace_open__colon__hash_x_brace_close_), o_in };\n    return mp_obj_str_format(MP_ARRAY_SIZE(args), args, NULL);\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_hex_obj, mp_builtin_hex);\n\n#if MICROPY_PY_BUILTINS_INPUT\n\n#include \"py/mphal.h\"\n#include \"shared/readline/readline.h\"\n\n\n#ifndef mp_hal_readline\n#define mp_hal_readline readline\n#endif\n\nstatic mp_obj_t mp_builtin_input(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 1) {\n        mp_obj_print(args[0], PRINT_STR);\n    }\n    vstr_t line;\n    vstr_init(&line, 16);\n    int ret = mp_hal_readline(&line, \"\");\n    if (ret == CHAR_CTRL_C) {\n        mp_raise_type(&mp_type_KeyboardInterrupt);\n    }\n    if (line.len == 0 && ret == CHAR_CTRL_D) {\n        mp_raise_type(&mp_type_EOFError);\n    }\n    return mp_obj_new_str_from_vstr(&line);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_input_obj, 0, 1, mp_builtin_input);\n\n#endif\n\nstatic mp_obj_t mp_builtin_iter(mp_obj_t o_in) {\n    return mp_getiter(o_in, NULL);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_iter_obj, mp_builtin_iter);\n\n#if MICROPY_PY_BUILTINS_MIN_MAX\n\nstatic mp_obj_t mp_builtin_min_max(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs, mp_uint_t op) {\n    mp_map_elem_t *key_elem = mp_map_lookup(kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_key), MP_MAP_LOOKUP);\n    mp_map_elem_t *default_elem;\n    mp_obj_t key_fn = key_elem == NULL ? MP_OBJ_NULL : key_elem->value;\n    if (n_args == 1) {\n        \n        mp_obj_iter_buf_t iter_buf;\n        mp_obj_t iterable = mp_getiter(args[0], &iter_buf);\n        mp_obj_t best_key = MP_OBJ_NULL;\n        mp_obj_t best_obj = MP_OBJ_NULL;\n        mp_obj_t item;\n        while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n            mp_obj_t key = key_fn == MP_OBJ_NULL ? item : mp_call_function_1(key_fn, item);\n            if (best_obj == MP_OBJ_NULL || (mp_binary_op(op, key, best_key) == mp_const_true)) {\n                best_key = key;\n                best_obj = item;\n            }\n        }\n        if (best_obj == MP_OBJ_NULL) {\n            default_elem = mp_map_lookup(kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_default), MP_MAP_LOOKUP);\n            if (default_elem != NULL) {\n                best_obj = default_elem->value;\n            } else {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"arg is an empty sequence\"));\n            }\n        }\n        return best_obj;\n    } else {\n        \n        mp_obj_t best_key = MP_OBJ_NULL;\n        mp_obj_t best_obj = MP_OBJ_NULL;\n        for (size_t i = 0; i < n_args; i++) {\n            mp_obj_t key = key_fn == MP_OBJ_NULL ? args[i] : mp_call_function_1(key_fn, args[i]);\n            if (best_obj == MP_OBJ_NULL || (mp_binary_op(op, key, best_key) == mp_const_true)) {\n                best_key = key;\n                best_obj = args[i];\n            }\n        }\n        return best_obj;\n    }\n}\n\nstatic mp_obj_t mp_builtin_max(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    return mp_builtin_min_max(n_args, args, kwargs, MP_BINARY_OP_MORE);\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_max_obj, 1, mp_builtin_max);\n\nstatic mp_obj_t mp_builtin_min(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    return mp_builtin_min_max(n_args, args, kwargs, MP_BINARY_OP_LESS);\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_min_obj, 1, mp_builtin_min);\n\n#endif\n\n#if MICROPY_PY_BUILTINS_NEXT2\nstatic mp_obj_t mp_builtin_next(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 1) {\n        mp_obj_t ret = mp_iternext_allow_raise(args[0]);\n        if (ret == MP_OBJ_STOP_ITERATION) {\n            mp_raise_StopIteration(MP_STATE_THREAD(stop_iteration_arg));\n        } else {\n            return ret;\n        }\n    } else {\n        mp_obj_t ret = mp_iternext(args[0]);\n        return ret == MP_OBJ_STOP_ITERATION ? args[1] : ret;\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_next_obj, 1, 2, mp_builtin_next);\n#else\nstatic mp_obj_t mp_builtin_next(mp_obj_t o) {\n    mp_obj_t ret = mp_iternext_allow_raise(o);\n    if (ret == MP_OBJ_STOP_ITERATION) {\n        mp_raise_StopIteration(MP_STATE_THREAD(stop_iteration_arg));\n    } else {\n        return ret;\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_next_obj, mp_builtin_next);\n#endif\n\nstatic mp_obj_t mp_builtin_oct(mp_obj_t o_in) {\n    #if MICROPY_PY_BUILTINS_STR_OP_MODULO\n    return mp_binary_op(MP_BINARY_OP_MODULO, MP_OBJ_NEW_QSTR(MP_QSTR__percent__hash_o), o_in);\n    #else\n    mp_obj_t args[] = { MP_OBJ_NEW_QSTR(MP_QSTR__brace_open__colon__hash_o_brace_close_), o_in };\n    return mp_obj_str_format(MP_ARRAY_SIZE(args), args, NULL);\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_oct_obj, mp_builtin_oct);\n\nstatic mp_obj_t mp_builtin_ord(mp_obj_t o_in) {\n    size_t len;\n    const byte *str = (const byte *)mp_obj_str_get_data(o_in, &len);\n    #if MICROPY_PY_BUILTINS_STR_UNICODE\n    if (mp_obj_is_str(o_in)) {\n        len = utf8_charlen(str, len);\n        if (len == 1) {\n            return mp_obj_new_int(utf8_get_char(str));\n        }\n    } else\n    #endif\n    {\n        \n        if (len == 1) {\n            return MP_OBJ_NEW_SMALL_INT(str[0]);\n        }\n    }\n\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_TypeError(MP_ERROR_TEXT(\"ord expects a character\"));\n    #else\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"ord() expected a character, but string of length %d found\"), (int)len);\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_ord_obj, mp_builtin_ord);\n\nstatic mp_obj_t mp_builtin_pow(size_t n_args, const mp_obj_t *args) {\n    switch (n_args) {\n        case 2:\n            return mp_binary_op(MP_BINARY_OP_POWER, args[0], args[1]);\n        default:\n            #if !MICROPY_PY_BUILTINS_POW3\n            mp_raise_NotImplementedError(MP_ERROR_TEXT(\"3-arg pow() not supported\"));\n            #elif MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_MPZ\n            return mp_binary_op(MP_BINARY_OP_MODULO, mp_binary_op(MP_BINARY_OP_POWER, args[0], args[1]), args[2]);\n            #else\n            return mp_obj_int_pow3(args[0], args[1], args[2]);\n            #endif\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_pow_obj, 2, 3, mp_builtin_pow);\n\nstatic mp_obj_t mp_builtin_print(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_sep, ARG_end, ARG_file };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_sep, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_QSTR(MP_QSTR__space_)} },\n        { MP_QSTR_end, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_QSTR(MP_QSTR__0x0a_)} },\n        #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\n        { MP_QSTR_file, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_PTR(&mp_sys_stdout_obj)} },\n        #endif\n    };\n\n    \n    union {\n        mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n        size_t len[2];\n    } u;\n    mp_arg_parse_all(0, NULL, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, u.args);\n\n    #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\n    mp_get_stream_raise(u.args[ARG_file].u_obj, MP_STREAM_OP_WRITE);\n    mp_print_t print = {MP_OBJ_TO_PTR(u.args[ARG_file].u_obj), mp_stream_write_adaptor};\n    #endif\n\n    \n    mp_obj_t sep = u.args[ARG_sep].u_obj;\n    mp_obj_t end = u.args[ARG_end].u_obj;\n    const char *sep_data = mp_obj_str_get_data(sep, &u.len[0]);\n    const char *end_data = mp_obj_str_get_data(end, &u.len[1]);\n\n    for (size_t i = 0; i < n_args; i++) {\n        if (i > 0) {\n            #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\n            mp_stream_write_adaptor(print.data, sep_data, u.len[0]);\n            #else\n            mp_print_strn(&mp_plat_print, sep_data, u.len[0], 0, 0, 0);\n            #endif\n        }\n        #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\n        mp_obj_print_helper(&print, pos_args[i], PRINT_STR);\n        #else\n        mp_obj_print_helper(&mp_plat_print, pos_args[i], PRINT_STR);\n        #endif\n    }\n    #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\n    mp_stream_write_adaptor(print.data, end_data, u.len[1]);\n    #else\n    mp_print_strn(&mp_plat_print, end_data, u.len[1], 0, 0, 0);\n    #endif\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_print_obj, 0, mp_builtin_print);\n\nstatic mp_obj_t mp_builtin___repl_print__(mp_obj_t o) {\n    if (o != mp_const_none) {\n        mp_obj_print_helper(MP_PYTHON_PRINTER, o, PRINT_REPR);\n        mp_print_str(MP_PYTHON_PRINTER, \"\\n\");\n        #if MICROPY_CAN_OVERRIDE_BUILTINS\n        \n        mp_obj_t dest[2] = {MP_OBJ_SENTINEL, o};\n        MP_OBJ_TYPE_GET_SLOT(&mp_type_module, attr)(MP_OBJ_FROM_PTR(&mp_module_builtins), MP_QSTR__, dest);\n        #endif\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin___repl_print___obj, mp_builtin___repl_print__);\n\nstatic mp_obj_t mp_builtin_repr(mp_obj_t o_in) {\n    vstr_t vstr;\n    mp_print_t print;\n    vstr_init_print(&vstr, 16, &print);\n    mp_obj_print_helper(&print, o_in, PRINT_REPR);\n    return mp_obj_new_str_from_utf8_vstr(&vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_repr_obj, mp_builtin_repr);\n\nstatic mp_obj_t mp_builtin_round(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t o_in = args[0];\n    if (mp_obj_is_int(o_in)) {\n        if (n_args <= 1) {\n            return o_in;\n        }\n\n        #if !MICROPY_PY_BUILTINS_ROUND_INT\n        mp_raise_NotImplementedError(NULL);\n        #else\n        mp_int_t num_dig = mp_obj_get_int(args[1]);\n        if (num_dig >= 0) {\n            return o_in;\n        }\n\n        mp_obj_t mult = mp_binary_op(MP_BINARY_OP_POWER, MP_OBJ_NEW_SMALL_INT(10), MP_OBJ_NEW_SMALL_INT(-num_dig));\n        mp_obj_t half_mult = mp_binary_op(MP_BINARY_OP_FLOOR_DIVIDE, mult, MP_OBJ_NEW_SMALL_INT(2));\n        mp_obj_t modulo = mp_binary_op(MP_BINARY_OP_MODULO, o_in, mult);\n        mp_obj_t rounded = mp_binary_op(MP_BINARY_OP_SUBTRACT, o_in, modulo);\n        if (mp_obj_is_true(mp_binary_op(MP_BINARY_OP_MORE, half_mult, modulo))) {\n            return rounded;\n        } else if (mp_obj_is_true(mp_binary_op(MP_BINARY_OP_MORE, modulo, half_mult))) {\n            return mp_binary_op(MP_BINARY_OP_ADD, rounded, mult);\n        } else {\n            \n            mp_obj_t floor = mp_binary_op(MP_BINARY_OP_FLOOR_DIVIDE, o_in, mult);\n            if (mp_obj_is_true(mp_binary_op(MP_BINARY_OP_AND, floor, MP_OBJ_NEW_SMALL_INT(1)))) {\n                return mp_binary_op(MP_BINARY_OP_ADD, rounded, mult);\n            } else {\n                return rounded;\n            }\n        }\n        #endif\n    }\n    #if MICROPY_PY_BUILTINS_FLOAT\n    mp_float_t val = mp_obj_get_float(o_in);\n    if (n_args > 1) {\n        mp_int_t num_dig = mp_obj_get_int(args[1]);\n        mp_float_t mult = MICROPY_FLOAT_C_FUN(pow)(10, (mp_float_t)num_dig);\n        \n        mp_float_t rounded = MICROPY_FLOAT_C_FUN(nearbyint)(val * mult) / mult;\n        return mp_obj_new_float(rounded);\n    }\n    mp_float_t rounded = MICROPY_FLOAT_C_FUN(nearbyint)(val);\n    return mp_obj_new_int_from_float(rounded);\n    #else\n    mp_int_t r = mp_obj_get_int(o_in);\n    return mp_obj_new_int(r);\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_round_obj, 1, 2, mp_builtin_round);\n\nstatic mp_obj_t mp_builtin_sum(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t value;\n    switch (n_args) {\n        case 1:\n            value = MP_OBJ_NEW_SMALL_INT(0);\n            break;\n        default:\n            value = args[1];\n            break;\n    }\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(args[0], &iter_buf);\n    mp_obj_t item;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        value = mp_binary_op(MP_BINARY_OP_ADD, value, item);\n    }\n    return value;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_sum_obj, 1, 2, mp_builtin_sum);\n\nstatic mp_obj_t mp_builtin_sorted(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    if (n_args > 1) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"must use keyword argument for key function\"));\n    }\n    mp_obj_t self = mp_obj_list_make_new(&mp_type_list, 1, 0, args);\n    mp_obj_list_sort(1, &self, kwargs);\n\n    return self;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_sorted_obj, 1, mp_builtin_sorted);\n\n\nstatic inline mp_obj_t mp_load_attr_default(mp_obj_t base, qstr attr, mp_obj_t defval) {\n    mp_obj_t dest[2];\n    \n    if (defval == MP_OBJ_NULL) {\n        mp_load_method(base, attr, dest);\n    } else {\n        mp_load_method_protected(base, attr, dest, false);\n    }\n    if (dest[0] == MP_OBJ_NULL) {\n        return defval;\n    } else if (dest[1] == MP_OBJ_NULL) {\n        \n        return dest[0];\n    } else {\n        \n        return mp_obj_new_bound_meth(dest[0], dest[1]);\n    }\n}\n\nstatic mp_obj_t mp_builtin_getattr(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t defval = MP_OBJ_NULL;\n    if (n_args > 2) {\n        defval = args[2];\n    }\n    return mp_load_attr_default(args[0], mp_obj_str_get_qstr(args[1]), defval);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_getattr_obj, 2, 3, mp_builtin_getattr);\n\nstatic mp_obj_t mp_builtin_setattr(mp_obj_t base, mp_obj_t attr, mp_obj_t value) {\n    mp_store_attr(base, mp_obj_str_get_qstr(attr), value);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_3(mp_builtin_setattr_obj, mp_builtin_setattr);\n\n#if MICROPY_CPYTHON_COMPAT\nstatic mp_obj_t mp_builtin_delattr(mp_obj_t base, mp_obj_t attr) {\n    return mp_builtin_setattr(base, attr, MP_OBJ_NULL);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_delattr_obj, mp_builtin_delattr);\n#endif\n\nstatic mp_obj_t mp_builtin_hasattr(mp_obj_t object_in, mp_obj_t attr_in) {\n    qstr attr = mp_obj_str_get_qstr(attr_in);\n    mp_obj_t dest[2];\n    mp_load_method_protected(object_in, attr, dest, false);\n    return mp_obj_new_bool(dest[0] != MP_OBJ_NULL);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_hasattr_obj, mp_builtin_hasattr);\n\nstatic mp_obj_t mp_builtin_globals(void) {\n    return MP_OBJ_FROM_PTR(mp_globals_get());\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_builtin_globals_obj, mp_builtin_globals);\n\nstatic mp_obj_t mp_builtin_locals(void) {\n    return MP_OBJ_FROM_PTR(mp_locals_get());\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_builtin_locals_obj, mp_builtin_locals);\n\n\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_id_obj, mp_obj_id);\nMP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_len_obj, mp_obj_len);\n\nstatic const mp_rom_map_elem_t mp_module_builtins_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_builtins) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR___build_class__), MP_ROM_PTR(&mp_builtin___build_class___obj) },\n    { MP_ROM_QSTR(MP_QSTR___import__), MP_ROM_PTR(&mp_builtin___import___obj) },\n    { MP_ROM_QSTR(MP_QSTR___repl_print__), MP_ROM_PTR(&mp_builtin___repl_print___obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_bool), MP_ROM_PTR(&mp_type_bool) },\n    { MP_ROM_QSTR(MP_QSTR_bytes), MP_ROM_PTR(&mp_type_bytes) },\n    #if MICROPY_PY_BUILTINS_BYTEARRAY\n    { MP_ROM_QSTR(MP_QSTR_bytearray), MP_ROM_PTR(&mp_type_bytearray) },\n    #endif\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    { MP_ROM_QSTR(MP_QSTR_complex), MP_ROM_PTR(&mp_type_complex) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_dict), MP_ROM_PTR(&mp_type_dict) },\n    #if MICROPY_PY_BUILTINS_ENUMERATE\n    { MP_ROM_QSTR(MP_QSTR_enumerate), MP_ROM_PTR(&mp_type_enumerate) },\n    #endif\n    #if MICROPY_PY_BUILTINS_FILTER\n    { MP_ROM_QSTR(MP_QSTR_filter), MP_ROM_PTR(&mp_type_filter) },\n    #endif\n    #if MICROPY_PY_BUILTINS_FLOAT\n    { MP_ROM_QSTR(MP_QSTR_float), MP_ROM_PTR(&mp_type_float) },\n    #endif\n    #if MICROPY_PY_BUILTINS_SET && MICROPY_PY_BUILTINS_FROZENSET\n    { MP_ROM_QSTR(MP_QSTR_frozenset), MP_ROM_PTR(&mp_type_frozenset) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_int), MP_ROM_PTR(&mp_type_int) },\n    { MP_ROM_QSTR(MP_QSTR_list), MP_ROM_PTR(&mp_type_list) },\n    { MP_ROM_QSTR(MP_QSTR_map), MP_ROM_PTR(&mp_type_map) },\n    #if MICROPY_PY_BUILTINS_MEMORYVIEW\n    { MP_ROM_QSTR(MP_QSTR_memoryview), MP_ROM_PTR(&mp_type_memoryview) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_object), MP_ROM_PTR(&mp_type_object) },\n    #if MICROPY_PY_BUILTINS_PROPERTY\n    { MP_ROM_QSTR(MP_QSTR_property), MP_ROM_PTR(&mp_type_property) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_range), MP_ROM_PTR(&mp_type_range) },\n    #if MICROPY_PY_BUILTINS_REVERSED\n    { MP_ROM_QSTR(MP_QSTR_reversed), MP_ROM_PTR(&mp_type_reversed) },\n    #endif\n    #if MICROPY_PY_BUILTINS_SET\n    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_type_set) },\n    #endif\n    #if MICROPY_PY_BUILTINS_SLICE\n    { MP_ROM_QSTR(MP_QSTR_slice), MP_ROM_PTR(&mp_type_slice) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_str), MP_ROM_PTR(&mp_type_str) },\n    { MP_ROM_QSTR(MP_QSTR_super), MP_ROM_PTR(&mp_type_super) },\n    { MP_ROM_QSTR(MP_QSTR_tuple), MP_ROM_PTR(&mp_type_tuple) },\n    { MP_ROM_QSTR(MP_QSTR_type), MP_ROM_PTR(&mp_type_type) },\n    { MP_ROM_QSTR(MP_QSTR_zip), MP_ROM_PTR(&mp_type_zip) },\n\n    { MP_ROM_QSTR(MP_QSTR_classmethod), MP_ROM_PTR(&mp_type_classmethod) },\n    { MP_ROM_QSTR(MP_QSTR_staticmethod), MP_ROM_PTR(&mp_type_staticmethod) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_Ellipsis), MP_ROM_PTR(&mp_const_ellipsis_obj) },\n    #if MICROPY_PY_BUILTINS_NOTIMPLEMENTED\n    { MP_ROM_QSTR(MP_QSTR_NotImplemented), MP_ROM_PTR(&mp_const_notimplemented_obj) },\n    #endif\n\n    \n    { MP_ROM_QSTR(MP_QSTR_abs), MP_ROM_PTR(&mp_builtin_abs_obj) },\n    { MP_ROM_QSTR(MP_QSTR_all), MP_ROM_PTR(&mp_builtin_all_obj) },\n    { MP_ROM_QSTR(MP_QSTR_any), MP_ROM_PTR(&mp_builtin_any_obj) },\n    { MP_ROM_QSTR(MP_QSTR_bin), MP_ROM_PTR(&mp_builtin_bin_obj) },\n    { MP_ROM_QSTR(MP_QSTR_callable), MP_ROM_PTR(&mp_builtin_callable_obj) },\n    #if MICROPY_PY_BUILTINS_COMPILE\n    { MP_ROM_QSTR(MP_QSTR_compile), MP_ROM_PTR(&mp_builtin_compile_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_chr), MP_ROM_PTR(&mp_builtin_chr_obj) },\n    #if MICROPY_CPYTHON_COMPAT\n    { MP_ROM_QSTR(MP_QSTR_delattr), MP_ROM_PTR(&mp_builtin_delattr_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_dir), MP_ROM_PTR(&mp_builtin_dir_obj) },\n    { MP_ROM_QSTR(MP_QSTR_divmod), MP_ROM_PTR(&mp_builtin_divmod_obj) },\n    #if MICROPY_PY_BUILTINS_EVAL_EXEC\n    { MP_ROM_QSTR(MP_QSTR_eval), MP_ROM_PTR(&mp_builtin_eval_obj) },\n    { MP_ROM_QSTR(MP_QSTR_exec), MP_ROM_PTR(&mp_builtin_exec_obj) },\n    #endif\n    #if MICROPY_PY_BUILTINS_EXECFILE\n    { MP_ROM_QSTR(MP_QSTR_execfile), MP_ROM_PTR(&mp_builtin_execfile_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_getattr), MP_ROM_PTR(&mp_builtin_getattr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setattr), MP_ROM_PTR(&mp_builtin_setattr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_globals), MP_ROM_PTR(&mp_builtin_globals_obj) },\n    { MP_ROM_QSTR(MP_QSTR_hasattr), MP_ROM_PTR(&mp_builtin_hasattr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_hash), MP_ROM_PTR(&mp_builtin_hash_obj) },\n    #if MICROPY_PY_BUILTINS_HELP\n    { MP_ROM_QSTR(MP_QSTR_help), MP_ROM_PTR(&mp_builtin_help_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_hex), MP_ROM_PTR(&mp_builtin_hex_obj) },\n    { MP_ROM_QSTR(MP_QSTR_id), MP_ROM_PTR(&mp_builtin_id_obj) },\n    #if MICROPY_PY_BUILTINS_INPUT\n    { MP_ROM_QSTR(MP_QSTR_input), MP_ROM_PTR(&mp_builtin_input_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_isinstance), MP_ROM_PTR(&mp_builtin_isinstance_obj) },\n    { MP_ROM_QSTR(MP_QSTR_issubclass), MP_ROM_PTR(&mp_builtin_issubclass_obj) },\n    { MP_ROM_QSTR(MP_QSTR_iter), MP_ROM_PTR(&mp_builtin_iter_obj) },\n    { MP_ROM_QSTR(MP_QSTR_len), MP_ROM_PTR(&mp_builtin_len_obj) },\n    { MP_ROM_QSTR(MP_QSTR_locals), MP_ROM_PTR(&mp_builtin_locals_obj) },\n    #if MICROPY_PY_BUILTINS_MIN_MAX\n    { MP_ROM_QSTR(MP_QSTR_max), MP_ROM_PTR(&mp_builtin_max_obj) },\n    { MP_ROM_QSTR(MP_QSTR_min), MP_ROM_PTR(&mp_builtin_min_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_next), MP_ROM_PTR(&mp_builtin_next_obj) },\n    { MP_ROM_QSTR(MP_QSTR_oct), MP_ROM_PTR(&mp_builtin_oct_obj) },\n    #if MICROPY_PY_IO\n    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_builtin_open_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_ord), MP_ROM_PTR(&mp_builtin_ord_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pow), MP_ROM_PTR(&mp_builtin_pow_obj) },\n    { MP_ROM_QSTR(MP_QSTR_print), MP_ROM_PTR(&mp_builtin_print_obj) },\n    { MP_ROM_QSTR(MP_QSTR_repr), MP_ROM_PTR(&mp_builtin_repr_obj) },\n    { MP_ROM_QSTR(MP_QSTR_round), MP_ROM_PTR(&mp_builtin_round_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sorted), MP_ROM_PTR(&mp_builtin_sorted_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sum), MP_ROM_PTR(&mp_builtin_sum_obj) },\n\n    \n    { MP_ROM_QSTR(MP_QSTR_BaseException), MP_ROM_PTR(&mp_type_BaseException) },\n    { MP_ROM_QSTR(MP_QSTR_ArithmeticError), MP_ROM_PTR(&mp_type_ArithmeticError) },\n    { MP_ROM_QSTR(MP_QSTR_AssertionError), MP_ROM_PTR(&mp_type_AssertionError) },\n    { MP_ROM_QSTR(MP_QSTR_AttributeError), MP_ROM_PTR(&mp_type_AttributeError) },\n    { MP_ROM_QSTR(MP_QSTR_EOFError), MP_ROM_PTR(&mp_type_EOFError) },\n    { MP_ROM_QSTR(MP_QSTR_Exception), MP_ROM_PTR(&mp_type_Exception) },\n    { MP_ROM_QSTR(MP_QSTR_GeneratorExit), MP_ROM_PTR(&mp_type_GeneratorExit) },\n    { MP_ROM_QSTR(MP_QSTR_ImportError), MP_ROM_PTR(&mp_type_ImportError) },\n    { MP_ROM_QSTR(MP_QSTR_IndentationError), MP_ROM_PTR(&mp_type_IndentationError) },\n    { MP_ROM_QSTR(MP_QSTR_IndexError), MP_ROM_PTR(&mp_type_IndexError) },\n    { MP_ROM_QSTR(MP_QSTR_KeyboardInterrupt), MP_ROM_PTR(&mp_type_KeyboardInterrupt) },\n    { MP_ROM_QSTR(MP_QSTR_KeyError), MP_ROM_PTR(&mp_type_KeyError) },\n    { MP_ROM_QSTR(MP_QSTR_LookupError), MP_ROM_PTR(&mp_type_LookupError) },\n    { MP_ROM_QSTR(MP_QSTR_MemoryError), MP_ROM_PTR(&mp_type_MemoryError) },\n    { MP_ROM_QSTR(MP_QSTR_NameError), MP_ROM_PTR(&mp_type_NameError) },\n    { MP_ROM_QSTR(MP_QSTR_NotImplementedError), MP_ROM_PTR(&mp_type_NotImplementedError) },\n    { MP_ROM_QSTR(MP_QSTR_OSError), MP_ROM_PTR(&mp_type_OSError) },\n    { MP_ROM_QSTR(MP_QSTR_OverflowError), MP_ROM_PTR(&mp_type_OverflowError) },\n    { MP_ROM_QSTR(MP_QSTR_RuntimeError), MP_ROM_PTR(&mp_type_RuntimeError) },\n    #if MICROPY_PY_ASYNC_AWAIT\n    { MP_ROM_QSTR(MP_QSTR_StopAsyncIteration), MP_ROM_PTR(&mp_type_StopAsyncIteration) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_StopIteration), MP_ROM_PTR(&mp_type_StopIteration) },\n    { MP_ROM_QSTR(MP_QSTR_SyntaxError), MP_ROM_PTR(&mp_type_SyntaxError) },\n    { MP_ROM_QSTR(MP_QSTR_SystemExit), MP_ROM_PTR(&mp_type_SystemExit) },\n    { MP_ROM_QSTR(MP_QSTR_TypeError), MP_ROM_PTR(&mp_type_TypeError) },\n    #if MICROPY_PY_BUILTINS_STR_UNICODE\n    { MP_ROM_QSTR(MP_QSTR_UnicodeError), MP_ROM_PTR(&mp_type_UnicodeError) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_ValueError), MP_ROM_PTR(&mp_type_ValueError) },\n    #if MICROPY_EMIT_NATIVE\n    { MP_ROM_QSTR(MP_QSTR_ViperTypeError), MP_ROM_PTR(&mp_type_ViperTypeError) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_ZeroDivisionError), MP_ROM_PTR(&mp_type_ZeroDivisionError) },\n\n    \n    MICROPY_PORT_BUILTINS\n    MICROPY_PORT_EXTRA_BUILTINS\n};\n\nMP_DEFINE_CONST_DICT(mp_module_builtins_globals, mp_module_builtins_globals_table);\n\nconst mp_obj_module_t mp_module_builtins = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_builtins_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_builtins, mp_module_builtins);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}