{
  "module_name": "gc.c",
  "hash_id": "00180c6d8ab9acaf158cb7a34181a0187df7fffbb1ea34a8c3bf5703bfc24a21",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/gc.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/gc.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_DEBUG_VALGRIND\n#include <valgrind/memcheck.h>\n#endif\n\n#if MICROPY_ENABLE_GC\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\n\n#define EXTENSIVE_HEAP_PROFILING (0)\n\n\n\n#define CLEAR_ON_SWEEP (0)\n\n#define WORDS_PER_BLOCK ((MICROPY_BYTES_PER_GC_BLOCK) / MP_BYTES_PER_OBJ_WORD)\n#define BYTES_PER_BLOCK (MICROPY_BYTES_PER_GC_BLOCK)\n\n\n\n\n\n\n\n#define AT_FREE (0)\n#define AT_HEAD (1)\n#define AT_TAIL (2)\n#define AT_MARK (3)\n\n#define BLOCKS_PER_ATB (4)\n#define ATB_MASK_0 (0x03)\n#define ATB_MASK_1 (0x0c)\n#define ATB_MASK_2 (0x30)\n#define ATB_MASK_3 (0xc0)\n\n#define ATB_0_IS_FREE(a) (((a) & ATB_MASK_0) == 0)\n#define ATB_1_IS_FREE(a) (((a) & ATB_MASK_1) == 0)\n#define ATB_2_IS_FREE(a) (((a) & ATB_MASK_2) == 0)\n#define ATB_3_IS_FREE(a) (((a) & ATB_MASK_3) == 0)\n\n#if MICROPY_GC_SPLIT_HEAP\n#define NEXT_AREA(area) ((area)->next)\n#else\n#define NEXT_AREA(area) (NULL)\n#endif\n\n#define BLOCK_SHIFT(block) (2 * ((block) & (BLOCKS_PER_ATB - 1)))\n#define ATB_GET_KIND(area, block) (((area)->gc_alloc_table_start[(block) / BLOCKS_PER_ATB] >> BLOCK_SHIFT(block)) & 3)\n#define ATB_ANY_TO_FREE(area, block) do { area->gc_alloc_table_start[(block) / BLOCKS_PER_ATB] &= (~(AT_MARK << BLOCK_SHIFT(block))); } while (0)\n#define ATB_FREE_TO_HEAD(area, block) do { area->gc_alloc_table_start[(block) / BLOCKS_PER_ATB] |= (AT_HEAD << BLOCK_SHIFT(block)); } while (0)\n#define ATB_FREE_TO_TAIL(area, block) do { area->gc_alloc_table_start[(block) / BLOCKS_PER_ATB] |= (AT_TAIL << BLOCK_SHIFT(block)); } while (0)\n#define ATB_HEAD_TO_MARK(area, block) do { area->gc_alloc_table_start[(block) / BLOCKS_PER_ATB] |= (AT_MARK << BLOCK_SHIFT(block)); } while (0)\n#define ATB_MARK_TO_HEAD(area, block) do { area->gc_alloc_table_start[(block) / BLOCKS_PER_ATB] &= (~(AT_TAIL << BLOCK_SHIFT(block))); } while (0)\n\n#define BLOCK_FROM_PTR(area, ptr) (((byte *)(ptr) - area->gc_pool_start) / BYTES_PER_BLOCK)\n#define PTR_FROM_BLOCK(area, block) (((block) * BYTES_PER_BLOCK + (uintptr_t)area->gc_pool_start))\n\n\n\n\n\n#define ALLOC_TABLE_GAP_BYTE (1)\n\n#if MICROPY_ENABLE_FINALISER\n\n\n\n#define BLOCKS_PER_FTB (8)\n\n#define FTB_GET(area, block) ((area->gc_finaliser_table_start[(block) / BLOCKS_PER_FTB] >> ((block) & 7)) & 1)\n#define FTB_SET(area, block) do { area->gc_finaliser_table_start[(block) / BLOCKS_PER_FTB] |= (1 << ((block) & 7)); } while (0)\n#define FTB_CLEAR(area, block) do { area->gc_finaliser_table_start[(block) / BLOCKS_PER_FTB] &= (~(1 << ((block) & 7))); } while (0)\n#endif\n\n#if MICROPY_PY_THREAD && !MICROPY_PY_THREAD_GIL\n#define GC_ENTER() mp_thread_mutex_lock(&MP_STATE_MEM(gc_mutex), 1)\n#define GC_EXIT() mp_thread_mutex_unlock(&MP_STATE_MEM(gc_mutex))\n#else\n#define GC_ENTER()\n#define GC_EXIT()\n#endif\n\n\nstatic void gc_setup_area(mp_state_mem_area_t *area, void *start, void *end) {\n    \n    \n    \n    \n    \n    size_t total_byte_len = (byte *)end - (byte *)start;\n    #if MICROPY_ENABLE_FINALISER\n    area->gc_alloc_table_byte_len = (total_byte_len - ALLOC_TABLE_GAP_BYTE)\n        * MP_BITS_PER_BYTE\n        / (\n            MP_BITS_PER_BYTE\n            + MP_BITS_PER_BYTE * BLOCKS_PER_ATB / BLOCKS_PER_FTB\n            + MP_BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK\n            );\n    #else\n    area->gc_alloc_table_byte_len = (total_byte_len - ALLOC_TABLE_GAP_BYTE) / (1 + MP_BITS_PER_BYTE / 2 * BYTES_PER_BLOCK);\n    #endif\n\n    area->gc_alloc_table_start = (byte *)start;\n\n    #if MICROPY_ENABLE_FINALISER\n    size_t gc_finaliser_table_byte_len = (area->gc_alloc_table_byte_len * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) / BLOCKS_PER_FTB;\n    area->gc_finaliser_table_start = area->gc_alloc_table_start + area->gc_alloc_table_byte_len + ALLOC_TABLE_GAP_BYTE;\n    #endif\n\n    size_t gc_pool_block_len = area->gc_alloc_table_byte_len * BLOCKS_PER_ATB;\n    area->gc_pool_start = (byte *)end - gc_pool_block_len * BYTES_PER_BLOCK;\n    area->gc_pool_end = end;\n\n    #if MICROPY_ENABLE_FINALISER\n    assert(area->gc_pool_start >= area->gc_finaliser_table_start + gc_finaliser_table_byte_len);\n    #endif\n\n    #if MICROPY_ENABLE_FINALISER\n    \n    memset(area->gc_alloc_table_start, 0, gc_finaliser_table_byte_len + area->gc_alloc_table_byte_len + ALLOC_TABLE_GAP_BYTE);\n    #else\n    \n    memset(area->gc_alloc_table_start, 0, area->gc_alloc_table_byte_len + ALLOC_TABLE_GAP_BYTE);\n    #endif\n\n    area->gc_last_free_atb_index = 0;\n    area->gc_last_used_block = 0;\n\n    #if MICROPY_GC_SPLIT_HEAP\n    area->next = NULL;\n    #endif\n\n    DEBUG_printf(\"GC layout:\\n\");\n    DEBUG_printf(\"  alloc table at %p, length \" UINT_FMT \" bytes, \"\n        UINT_FMT \" blocks\\n\",\n        area->gc_alloc_table_start, area->gc_alloc_table_byte_len,\n        area->gc_alloc_table_byte_len * BLOCKS_PER_ATB);\n    #if MICROPY_ENABLE_FINALISER\n    DEBUG_printf(\"  finaliser table at %p, length \" UINT_FMT \" bytes, \"\n        UINT_FMT \" blocks\\n\", area->gc_finaliser_table_start,\n        gc_finaliser_table_byte_len,\n        gc_finaliser_table_byte_len * BLOCKS_PER_FTB);\n    #endif\n    DEBUG_printf(\"  pool at %p, length \" UINT_FMT \" bytes, \"\n        UINT_FMT \" blocks\\n\", area->gc_pool_start,\n        gc_pool_block_len * BYTES_PER_BLOCK, gc_pool_block_len);\n}\n\nvoid gc_init(void *start, void *end) {\n    \n    end = (void *)((uintptr_t)end & (~(BYTES_PER_BLOCK - 1)));\n    DEBUG_printf(\"Initializing GC heap: %p..%p = \" UINT_FMT \" bytes\\n\", start, end, (byte *)end - (byte *)start);\n\n    gc_setup_area(&MP_STATE_MEM(area), start, end);\n\n    \n    #if MICROPY_GC_SPLIT_HEAP\n    MP_STATE_MEM(gc_last_free_area) = &MP_STATE_MEM(area);\n    #endif\n\n    \n    MP_STATE_THREAD(gc_lock_depth) = 0;\n\n    \n    MP_STATE_MEM(gc_auto_collect_enabled) = 1;\n\n    #if MICROPY_GC_ALLOC_THRESHOLD\n    \n    MP_STATE_MEM(gc_alloc_threshold) = (size_t)-1;\n    MP_STATE_MEM(gc_alloc_amount) = 0;\n    #endif\n\n    #if MICROPY_PY_THREAD && !MICROPY_PY_THREAD_GIL\n    mp_thread_mutex_init(&MP_STATE_MEM(gc_mutex));\n    #endif\n}\n\n#if MICROPY_GC_SPLIT_HEAP\nvoid gc_add(void *start, void *end) {\n    \n    mp_state_mem_area_t *area = (mp_state_mem_area_t *)start;\n    start = (void *)((uintptr_t)start + sizeof(mp_state_mem_area_t));\n\n    end = (void *)((uintptr_t)end & (~(BYTES_PER_BLOCK - 1)));\n    DEBUG_printf(\"Adding GC heap: %p..%p = \" UINT_FMT \" bytes\\n\", start, end, (byte *)end - (byte *)start);\n\n    \n    gc_setup_area(area, start, end);\n\n    \n    mp_state_mem_area_t *prev_area = &MP_STATE_MEM(area);\n    while (prev_area->next != NULL) {\n        prev_area = prev_area->next;\n    }\n\n    \n    prev_area->next = area;\n}\n\n#if MICROPY_GC_SPLIT_HEAP_AUTO\n\nstatic bool gc_try_add_heap(size_t failed_alloc) {\n    \n    \n    \n    \n    \n    \n    \n    size_t needed = failed_alloc + MAX(2048, failed_alloc * 13 / 512);\n\n    size_t avail = gc_get_max_new_split();\n\n    DEBUG_printf(\"gc_try_add_heap failed_alloc \" UINT_FMT \", \"\n        \"needed \" UINT_FMT \", avail \" UINT_FMT \" bytes \\n\",\n        failed_alloc,\n        needed,\n        avail);\n\n    if (avail < needed) {\n        \n        return false;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    size_t total_blocks = 0;\n    for (mp_state_mem_area_t *area = &MP_STATE_MEM(area);\n         area != NULL;\n         area = NEXT_AREA(area)) {\n        total_blocks += area->gc_alloc_table_byte_len * BLOCKS_PER_ATB;\n    }\n\n    \n    size_t total_heap =\n        total_blocks / BLOCKS_PER_ATB\n        #if MICROPY_ENABLE_FINALISER\n        + total_blocks / BLOCKS_PER_FTB\n        #endif\n        + total_blocks * BYTES_PER_BLOCK\n        + ALLOC_TABLE_GAP_BYTE\n        + sizeof(mp_state_mem_area_t);\n\n    \n    total_heap = (total_heap + BYTES_PER_BLOCK - 1) & (~(BYTES_PER_BLOCK - 1));\n\n    DEBUG_printf(\"total_heap \" UINT_FMT \" bytes\\n\", total_heap);\n\n    size_t to_alloc = MIN(avail, MAX(total_heap, needed));\n\n    mp_state_mem_area_t *new_heap = MP_PLAT_ALLOC_HEAP(to_alloc);\n\n    DEBUG_printf(\"MP_PLAT_ALLOC_HEAP \" UINT_FMT \" = %p\\n\",\n        to_alloc, new_heap);\n\n    if (new_heap == NULL) {\n        \n        \n        \n        \n        return false;\n    }\n\n    gc_add(new_heap, (void *)new_heap + to_alloc);\n\n    return true;\n}\n#endif\n\n#endif\n\nvoid gc_lock(void) {\n    \n    \n    \n    \n    MP_STATE_THREAD(gc_lock_depth)++;\n}\n\nvoid gc_unlock(void) {\n    \n    MP_STATE_THREAD(gc_lock_depth)--;\n}\n\nbool gc_is_locked(void) {\n    return MP_STATE_THREAD(gc_lock_depth) != 0;\n}\n\n#if MICROPY_GC_SPLIT_HEAP\n\n\nstatic inline mp_state_mem_area_t *gc_get_ptr_area(const void *ptr) {\n    if (((uintptr_t)(ptr) & (BYTES_PER_BLOCK - 1)) != 0) {   \n        return NULL;\n    }\n    for (mp_state_mem_area_t *area = &MP_STATE_MEM(area); area != NULL; area = NEXT_AREA(area)) {\n        if (ptr >= (void *)area->gc_pool_start   \n            && ptr < (void *)area->gc_pool_end) {   \n            return area;\n        }\n    }\n    return NULL;\n}\n#endif\n\n\n#define VERIFY_PTR(ptr) ( \\\n    ((uintptr_t)(ptr) & (BYTES_PER_BLOCK - 1)) == 0            \\\n    && ptr >= (void *)MP_STATE_MEM(area).gc_pool_start        \\\n    && ptr < (void *)MP_STATE_MEM(area).gc_pool_end           \\\n    )\n\n#ifndef TRACE_MARK\n#if DEBUG_PRINT\n#define TRACE_MARK(block, ptr) DEBUG_printf(\"gc_mark(%p)\\n\", ptr)\n#else\n#define TRACE_MARK(block, ptr)\n#endif\n#endif\n\n\n\n\n\n#if MICROPY_GC_SPLIT_HEAP\nstatic void gc_mark_subtree(mp_state_mem_area_t *area, size_t block)\n#else\nstatic void gc_mark_subtree(size_t block)\n#endif\n{\n    \n    size_t sp = 0;\n    for (;;) {\n        #if !MICROPY_GC_SPLIT_HEAP\n        mp_state_mem_area_t *area = &MP_STATE_MEM(area);\n        #endif\n\n        \n        size_t n_blocks = 0;\n        do {\n            n_blocks += 1;\n        } while (ATB_GET_KIND(area, block + n_blocks) == AT_TAIL);\n\n        \n        assert(area->gc_pool_start + (block + n_blocks) * BYTES_PER_BLOCK <= area->gc_pool_end);\n\n        \n        void **ptrs = (void **)PTR_FROM_BLOCK(area, block);\n        for (size_t i = n_blocks * BYTES_PER_BLOCK / sizeof(void *); i > 0; i--, ptrs++) {\n            MICROPY_GC_HOOK_LOOP(i);\n            void *ptr = *ptrs;\n            \n            \n            #if MICROPY_GC_SPLIT_HEAP\n            mp_state_mem_area_t *ptr_area = gc_get_ptr_area(ptr);\n            if (!ptr_area) {\n                \n                continue;\n            }\n            #else\n            if (!VERIFY_PTR(ptr)) {\n                continue;\n            }\n            mp_state_mem_area_t *ptr_area = area;\n            #endif\n            size_t ptr_block = BLOCK_FROM_PTR(ptr_area, ptr);\n            if (ATB_GET_KIND(ptr_area, ptr_block) != AT_HEAD) {\n                \n                continue;\n            }\n            \n            TRACE_MARK(ptr_block, ptr);\n            ATB_HEAD_TO_MARK(ptr_area, ptr_block);\n            if (sp < MICROPY_ALLOC_GC_STACK_SIZE) {\n                MP_STATE_MEM(gc_block_stack)[sp] = ptr_block;\n                #if MICROPY_GC_SPLIT_HEAP\n                MP_STATE_MEM(gc_area_stack)[sp] = ptr_area;\n                #endif\n                sp += 1;\n            } else {\n                MP_STATE_MEM(gc_stack_overflow) = 1;\n            }\n        }\n\n        \n        if (sp == 0) {\n            break; \n        }\n\n        \n        sp -= 1;\n        block = MP_STATE_MEM(gc_block_stack)[sp];\n        #if MICROPY_GC_SPLIT_HEAP\n        area = MP_STATE_MEM(gc_area_stack)[sp];\n        #endif\n    }\n}\n\nstatic void gc_deal_with_stack_overflow(void) {\n    while (MP_STATE_MEM(gc_stack_overflow)) {\n        MP_STATE_MEM(gc_stack_overflow) = 0;\n\n        \n        for (mp_state_mem_area_t *area = &MP_STATE_MEM(area); area != NULL; area = NEXT_AREA(area)) {\n            for (size_t block = 0; block < area->gc_alloc_table_byte_len * BLOCKS_PER_ATB; block++) {\n                MICROPY_GC_HOOK_LOOP(block);\n                \n                if (ATB_GET_KIND(area, block) == AT_MARK) {\n                    #if MICROPY_GC_SPLIT_HEAP\n                    gc_mark_subtree(area, block);\n                    #else\n                    gc_mark_subtree(block);\n                    #endif\n                }\n            }\n        }\n    }\n}\n\nstatic void gc_sweep(void) {\n    #if MICROPY_PY_GC_COLLECT_RETVAL\n    MP_STATE_MEM(gc_collected) = 0;\n    #endif\n    \n    int free_tail = 0;\n    #if MICROPY_GC_SPLIT_HEAP_AUTO\n    mp_state_mem_area_t *prev_area = NULL;\n    #endif\n    for (mp_state_mem_area_t *area = &MP_STATE_MEM(area); area != NULL; area = NEXT_AREA(area)) {\n        size_t end_block = area->gc_alloc_table_byte_len * BLOCKS_PER_ATB;\n        if (area->gc_last_used_block < end_block) {\n            end_block = area->gc_last_used_block + 1;\n        }\n\n        size_t last_used_block = 0;\n\n        for (size_t block = 0; block < end_block; block++) {\n            MICROPY_GC_HOOK_LOOP(block);\n            switch (ATB_GET_KIND(area, block)) {\n                case AT_HEAD:\n                    #if MICROPY_ENABLE_FINALISER\n                    if (FTB_GET(area, block)) {\n                        mp_obj_base_t *obj = (mp_obj_base_t *)PTR_FROM_BLOCK(area, block);\n                        if (obj->type != NULL) {\n                            \n                            mp_obj_t dest[2];\n                            mp_load_method_maybe(MP_OBJ_FROM_PTR(obj), MP_QSTR___del__, dest);\n                            if (dest[0] != MP_OBJ_NULL) {\n                                \n                                #if MICROPY_ENABLE_SCHEDULER\n                                mp_sched_lock();\n                                #endif\n                                mp_call_function_1_protected(dest[0], dest[1]);\n                                #if MICROPY_ENABLE_SCHEDULER\n                                mp_sched_unlock();\n                                #endif\n                            }\n                        }\n                        \n                        FTB_CLEAR(area, block);\n                    }\n                    #endif\n                    free_tail = 1;\n                    DEBUG_printf(\"gc_sweep(%p)\\n\", (void *)PTR_FROM_BLOCK(area, block));\n                    #if MICROPY_PY_GC_COLLECT_RETVAL\n                    MP_STATE_MEM(gc_collected)++;\n                    #endif\n                    \n                    MP_FALLTHROUGH\n\n                case AT_TAIL:\n                    if (free_tail) {\n                        ATB_ANY_TO_FREE(area, block);\n                        #if CLEAR_ON_SWEEP\n                        memset((void *)PTR_FROM_BLOCK(area, block), 0, BYTES_PER_BLOCK);\n                        #endif\n                    } else {\n                        last_used_block = block;\n                    }\n                    break;\n\n                case AT_MARK:\n                    ATB_MARK_TO_HEAD(area, block);\n                    free_tail = 0;\n                    last_used_block = block;\n                    break;\n            }\n        }\n\n        area->gc_last_used_block = last_used_block;\n\n        #if MICROPY_GC_SPLIT_HEAP_AUTO\n        \n        if (last_used_block == 0 && prev_area != NULL) {\n            DEBUG_printf(\"gc_sweep free empty area %p\\n\", area);\n            NEXT_AREA(prev_area) = NEXT_AREA(area);\n            MP_PLAT_FREE_HEAP(area);\n            area = prev_area;\n        }\n        prev_area = area;\n        #endif\n    }\n}\n\nvoid gc_collect_start(void) {\n    GC_ENTER();\n    MP_STATE_THREAD(gc_lock_depth)++;\n    #if MICROPY_GC_ALLOC_THRESHOLD\n    MP_STATE_MEM(gc_alloc_amount) = 0;\n    #endif\n    MP_STATE_MEM(gc_stack_overflow) = 0;\n\n    \n    \n    \n    void **ptrs = (void **)(void *)&mp_state_ctx;\n    size_t root_start = offsetof(mp_state_ctx_t, thread.dict_locals);\n    size_t root_end = offsetof(mp_state_ctx_t, vm.qstr_last_chunk);\n    gc_collect_root(ptrs + root_start / sizeof(void *), (root_end - root_start) / sizeof(void *));\n\n    #if MICROPY_ENABLE_PYSTACK\n    \n    ptrs = (void **)(void *)MP_STATE_THREAD(pystack_start);\n    gc_collect_root(ptrs, (MP_STATE_THREAD(pystack_cur) - MP_STATE_THREAD(pystack_start)) / sizeof(void *));\n    #endif\n}\n\n\n\n\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))\n__attribute__((no_sanitize_address))\n#endif\nstatic void *gc_get_ptr(void **ptrs, int i) {\n    #if MICROPY_DEBUG_VALGRIND\n    if (!VALGRIND_CHECK_MEM_IS_ADDRESSABLE(&ptrs[i], sizeof(*ptrs))) {\n        return NULL;\n    }\n    #endif\n    return ptrs[i];\n}\n\nvoid gc_collect_root(void **ptrs, size_t len) {\n    #if !MICROPY_GC_SPLIT_HEAP\n    mp_state_mem_area_t *area = &MP_STATE_MEM(area);\n    #endif\n    for (size_t i = 0; i < len; i++) {\n        MICROPY_GC_HOOK_LOOP(i);\n        void *ptr = gc_get_ptr(ptrs, i);\n        #if MICROPY_GC_SPLIT_HEAP\n        mp_state_mem_area_t *area = gc_get_ptr_area(ptr);\n        if (!area) {\n            continue;\n        }\n        #else\n        if (!VERIFY_PTR(ptr)) {\n            continue;\n        }\n        #endif\n        size_t block = BLOCK_FROM_PTR(area, ptr);\n        if (ATB_GET_KIND(area, block) == AT_HEAD) {\n            \n            ATB_HEAD_TO_MARK(area, block);\n            #if MICROPY_GC_SPLIT_HEAP\n            gc_mark_subtree(area, block);\n            #else\n            gc_mark_subtree(block);\n            #endif\n        }\n    }\n}\n\nvoid gc_collect_end(void) {\n    gc_deal_with_stack_overflow();\n    gc_sweep();\n    #if MICROPY_GC_SPLIT_HEAP\n    MP_STATE_MEM(gc_last_free_area) = &MP_STATE_MEM(area);\n    #endif\n    for (mp_state_mem_area_t *area = &MP_STATE_MEM(area); area != NULL; area = NEXT_AREA(area)) {\n        area->gc_last_free_atb_index = 0;\n    }\n    MP_STATE_THREAD(gc_lock_depth)--;\n    GC_EXIT();\n}\n\nvoid gc_sweep_all(void) {\n    GC_ENTER();\n    MP_STATE_THREAD(gc_lock_depth)++;\n    MP_STATE_MEM(gc_stack_overflow) = 0;\n    gc_collect_end();\n}\n\nvoid gc_info(gc_info_t *info) {\n    GC_ENTER();\n    info->total = 0;\n    info->used = 0;\n    info->free = 0;\n    info->max_free = 0;\n    info->num_1block = 0;\n    info->num_2block = 0;\n    info->max_block = 0;\n    for (mp_state_mem_area_t *area = &MP_STATE_MEM(area); area != NULL; area = NEXT_AREA(area)) {\n        bool finish = false;\n        info->total += area->gc_pool_end - area->gc_pool_start;\n        for (size_t block = 0, len = 0, len_free = 0; !finish;) {\n            MICROPY_GC_HOOK_LOOP(block);\n            size_t kind = ATB_GET_KIND(area, block);\n            switch (kind) {\n                case AT_FREE:\n                    info->free += 1;\n                    len_free += 1;\n                    len = 0;\n                    break;\n\n                case AT_HEAD:\n                    info->used += 1;\n                    len = 1;\n                    break;\n\n                case AT_TAIL:\n                    info->used += 1;\n                    len += 1;\n                    break;\n\n                case AT_MARK:\n                    \n                    break;\n            }\n\n            block++;\n            finish = (block == area->gc_alloc_table_byte_len * BLOCKS_PER_ATB);\n            \n            if (!finish) {\n                kind = ATB_GET_KIND(area, block);\n            }\n\n            if (finish || kind == AT_FREE || kind == AT_HEAD) {\n                if (len == 1) {\n                    info->num_1block += 1;\n                } else if (len == 2) {\n                    info->num_2block += 1;\n                }\n                if (len > info->max_block) {\n                    info->max_block = len;\n                }\n                if (finish || kind == AT_HEAD) {\n                    if (len_free > info->max_free) {\n                        info->max_free = len_free;\n                    }\n                    len_free = 0;\n                }\n            }\n        }\n    }\n\n    info->used *= BYTES_PER_BLOCK;\n    info->free *= BYTES_PER_BLOCK;\n\n    #if MICROPY_GC_SPLIT_HEAP_AUTO\n    info->max_new_split = gc_get_max_new_split();\n    #endif\n\n    GC_EXIT();\n}\n\nvoid *gc_alloc(size_t n_bytes, unsigned int alloc_flags) {\n    bool has_finaliser = alloc_flags & GC_ALLOC_FLAG_HAS_FINALISER;\n    size_t n_blocks = ((n_bytes + BYTES_PER_BLOCK - 1) & (~(BYTES_PER_BLOCK - 1))) / BYTES_PER_BLOCK;\n    DEBUG_printf(\"gc_alloc(\" UINT_FMT \" bytes -> \" UINT_FMT \" blocks)\\n\", n_bytes, n_blocks);\n\n    \n    if (n_blocks == 0) {\n        return NULL;\n    }\n\n    \n    if (MP_STATE_THREAD(gc_lock_depth) > 0) {\n        return NULL;\n    }\n\n    GC_ENTER();\n\n    mp_state_mem_area_t *area;\n    size_t i;\n    size_t end_block;\n    size_t start_block;\n    size_t n_free;\n    int collected = !MP_STATE_MEM(gc_auto_collect_enabled);\n    #if MICROPY_GC_SPLIT_HEAP_AUTO\n    bool added = false;\n    #endif\n\n    #if MICROPY_GC_ALLOC_THRESHOLD\n    if (!collected && MP_STATE_MEM(gc_alloc_amount) >= MP_STATE_MEM(gc_alloc_threshold)) {\n        GC_EXIT();\n        gc_collect();\n        collected = 1;\n        GC_ENTER();\n    }\n    #endif\n\n    for (;;) {\n\n        #if MICROPY_GC_SPLIT_HEAP\n        area = MP_STATE_MEM(gc_last_free_area);\n        #else\n        area = &MP_STATE_MEM(area);\n        #endif\n\n        \n        for (; area != NULL; area = NEXT_AREA(area), i = 0) {\n            n_free = 0;\n            for (i = area->gc_last_free_atb_index; i < area->gc_alloc_table_byte_len; i++) {\n                MICROPY_GC_HOOK_LOOP(i);\n                byte a = area->gc_alloc_table_start[i];\n                \n                if (ATB_0_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 0; goto found; } } else { n_free = 0; }\n                if (ATB_1_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 1; goto found; } } else { n_free = 0; }\n                if (ATB_2_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 2; goto found; } } else { n_free = 0; }\n                if (ATB_3_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 3; goto found; } } else { n_free = 0; }\n                \n            }\n\n            \n            \n            \n            #if MICROPY_GC_SPLIT_HEAP\n            if (n_blocks == 1) {\n                area->gc_last_free_atb_index = (i + 1) / BLOCKS_PER_ATB; \n            }\n            #endif\n        }\n\n        GC_EXIT();\n        \n        if (collected) {\n            #if MICROPY_GC_SPLIT_HEAP_AUTO\n            if (!added && gc_try_add_heap(n_bytes)) {\n                added = true;\n                continue;\n            }\n            #endif\n            return NULL;\n        }\n        DEBUG_printf(\"gc_alloc(\" UINT_FMT \"): no free mem, triggering GC\\n\", n_bytes);\n        gc_collect();\n        collected = 1;\n        GC_ENTER();\n    }\n\n    \nfound:\n    \n    end_block = i;\n    start_block = i - n_free + 1;\n\n    \n    \n    \n    \n    \n    if (n_free == 1) {\n        #if MICROPY_GC_SPLIT_HEAP\n        MP_STATE_MEM(gc_last_free_area) = area;\n        #endif\n        area->gc_last_free_atb_index = (i + 1) / BLOCKS_PER_ATB;\n    }\n\n    area->gc_last_used_block = MAX(area->gc_last_used_block, end_block);\n\n    \n    ATB_FREE_TO_HEAD(area, start_block);\n\n    \n    \n    for (size_t bl = start_block + 1; bl <= end_block; bl++) {\n        ATB_FREE_TO_TAIL(area, bl);\n    }\n\n    \n    \n    void *ret_ptr = (void *)(area->gc_pool_start + start_block * BYTES_PER_BLOCK);\n    DEBUG_printf(\"gc_alloc(%p)\\n\", ret_ptr);\n\n    #if MICROPY_GC_ALLOC_THRESHOLD\n    MP_STATE_MEM(gc_alloc_amount) += n_blocks;\n    #endif\n\n    GC_EXIT();\n\n    #if MICROPY_GC_CONSERVATIVE_CLEAR\n    \n    memset((byte *)ret_ptr, 0, (end_block - start_block + 1) * BYTES_PER_BLOCK);\n    #else\n    \n    \n    \n    \n    \n    memset((byte *)ret_ptr + n_bytes, 0, (end_block - start_block + 1) * BYTES_PER_BLOCK - n_bytes);\n    #endif\n\n    #if MICROPY_ENABLE_FINALISER\n    if (has_finaliser) {\n        \n        ((mp_obj_base_t *)ret_ptr)->type = NULL;\n        \n        GC_ENTER();\n        FTB_SET(area, start_block);\n        GC_EXIT();\n    }\n    #else\n    (void)has_finaliser;\n    #endif\n\n    #if EXTENSIVE_HEAP_PROFILING\n    gc_dump_alloc_table(&mp_plat_print);\n    #endif\n\n    return ret_ptr;\n}\n\n \n\n\n\nvoid gc_free(void *ptr) {\n    if (MP_STATE_THREAD(gc_lock_depth) > 0) {\n        \n        \n        \n        return;\n    }\n\n    GC_ENTER();\n\n    DEBUG_printf(\"gc_free(%p)\\n\", ptr);\n\n    if (ptr == NULL) {\n        \n        GC_EXIT();\n        return;\n    }\n\n    \n    mp_state_mem_area_t *area;\n    #if MICROPY_GC_SPLIT_HEAP\n    area = gc_get_ptr_area(ptr);\n    assert(area);\n    #else\n    assert(VERIFY_PTR(ptr));\n    area = &MP_STATE_MEM(area);\n    #endif\n\n    size_t block = BLOCK_FROM_PTR(area, ptr);\n    assert(ATB_GET_KIND(area, block) == AT_HEAD);\n\n    #if MICROPY_ENABLE_FINALISER\n    FTB_CLEAR(area, block);\n    #endif\n\n    #if MICROPY_GC_SPLIT_HEAP\n    if (MP_STATE_MEM(gc_last_free_area) != area) {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        MP_STATE_MEM(gc_last_free_area) = &MP_STATE_MEM(area);\n    }\n    #endif\n\n    \n    if (block / BLOCKS_PER_ATB < area->gc_last_free_atb_index) {\n        area->gc_last_free_atb_index = block / BLOCKS_PER_ATB;\n    }\n\n    \n    do {\n        ATB_ANY_TO_FREE(area, block);\n        block += 1;\n    } while (ATB_GET_KIND(area, block) == AT_TAIL);\n\n    GC_EXIT();\n\n    #if EXTENSIVE_HEAP_PROFILING\n    gc_dump_alloc_table(&mp_plat_print);\n    #endif\n}\n\nsize_t gc_nbytes(const void *ptr) {\n    GC_ENTER();\n\n    mp_state_mem_area_t *area;\n    #if MICROPY_GC_SPLIT_HEAP\n    area = gc_get_ptr_area(ptr);\n    #else\n    if (VERIFY_PTR(ptr)) {\n        area = &MP_STATE_MEM(area);\n    } else {\n        area = NULL;\n    }\n    #endif\n\n    if (area) {\n        size_t block = BLOCK_FROM_PTR(area, ptr);\n        if (ATB_GET_KIND(area, block) == AT_HEAD) {\n            \n            size_t n_blocks = 0;\n            do {\n                n_blocks += 1;\n            } while (ATB_GET_KIND(area, block + n_blocks) == AT_TAIL);\n            GC_EXIT();\n            return n_blocks * BYTES_PER_BLOCK;\n        }\n    }\n\n    \n    GC_EXIT();\n    return 0;\n}\n\n#if 0\n\nvoid *gc_realloc(void *ptr, mp_uint_t n_bytes) {\n    mp_uint_t n_existing = gc_nbytes(ptr);\n    if (n_bytes <= n_existing) {\n        return ptr;\n    } else {\n        bool has_finaliser;\n        if (ptr == NULL) {\n            has_finaliser = false;\n        } else {\n            #if MICROPY_ENABLE_FINALISER\n            has_finaliser = FTB_GET(BLOCK_FROM_PTR((mp_uint_t)ptr));\n            #else\n            has_finaliser = false;\n            #endif\n        }\n        void *ptr2 = gc_alloc(n_bytes, has_finaliser);\n        if (ptr2 == NULL) {\n            return ptr2;\n        }\n        memcpy(ptr2, ptr, n_existing);\n        gc_free(ptr);\n        return ptr2;\n    }\n}\n\n#else \n\nvoid *gc_realloc(void *ptr_in, size_t n_bytes, bool allow_move) {\n    \n    if (ptr_in == NULL) {\n        return gc_alloc(n_bytes, false);\n    }\n\n    \n    if (n_bytes == 0) {\n        gc_free(ptr_in);\n        return NULL;\n    }\n\n    if (MP_STATE_THREAD(gc_lock_depth) > 0) {\n        return NULL;\n    }\n\n    void *ptr = ptr_in;\n\n    GC_ENTER();\n\n    \n    mp_state_mem_area_t *area;\n    #if MICROPY_GC_SPLIT_HEAP\n    area = gc_get_ptr_area(ptr);\n    assert(area);\n    #else\n    assert(VERIFY_PTR(ptr));\n    area = &MP_STATE_MEM(area);\n    #endif\n    size_t block = BLOCK_FROM_PTR(area, ptr);\n    assert(ATB_GET_KIND(area, block) == AT_HEAD);\n\n    \n    size_t new_blocks = (n_bytes + BYTES_PER_BLOCK - 1) / BYTES_PER_BLOCK;\n\n    \n    \n    \n    \n    \n    \n    size_t n_free = 0;\n    size_t n_blocks = 1; \n    size_t max_block = area->gc_alloc_table_byte_len * BLOCKS_PER_ATB;\n    for (size_t bl = block + n_blocks; bl < max_block; bl++) {\n        byte block_type = ATB_GET_KIND(area, bl);\n        if (block_type == AT_TAIL) {\n            n_blocks++;\n            continue;\n        }\n        if (block_type == AT_FREE) {\n            n_free++;\n            if (n_blocks + n_free >= new_blocks) {\n                \n                break;\n            }\n            continue;\n        }\n        break;\n    }\n\n    \n    if (new_blocks == n_blocks) {\n        GC_EXIT();\n        return ptr_in;\n    }\n\n    \n    if (new_blocks < n_blocks) {\n        \n        for (size_t bl = block + new_blocks, count = n_blocks - new_blocks; count > 0; bl++, count--) {\n            ATB_ANY_TO_FREE(area, bl);\n        }\n\n        #if MICROPY_GC_SPLIT_HEAP\n        if (MP_STATE_MEM(gc_last_free_area) != area) {\n            \n            MP_STATE_MEM(gc_last_free_area) = &MP_STATE_MEM(area);\n        }\n        #endif\n\n        \n        if ((block + new_blocks) / BLOCKS_PER_ATB < area->gc_last_free_atb_index) {\n            area->gc_last_free_atb_index = (block + new_blocks) / BLOCKS_PER_ATB;\n        }\n\n        GC_EXIT();\n\n        #if EXTENSIVE_HEAP_PROFILING\n        gc_dump_alloc_table(&mp_plat_print);\n        #endif\n\n        return ptr_in;\n    }\n\n    \n    if (new_blocks <= n_blocks + n_free) {\n        \n        size_t end_block = block + new_blocks;\n        for (size_t bl = block + n_blocks; bl < end_block; bl++) {\n            assert(ATB_GET_KIND(area, bl) == AT_FREE);\n            ATB_FREE_TO_TAIL(area, bl);\n        }\n\n        area->gc_last_used_block = MAX(area->gc_last_used_block, end_block);\n\n        GC_EXIT();\n\n        #if MICROPY_GC_CONSERVATIVE_CLEAR\n        \n        memset((byte *)ptr_in + n_blocks * BYTES_PER_BLOCK, 0, (new_blocks - n_blocks) * BYTES_PER_BLOCK);\n        #else\n        \n        memset((byte *)ptr_in + n_bytes, 0, new_blocks * BYTES_PER_BLOCK - n_bytes);\n        #endif\n\n        #if EXTENSIVE_HEAP_PROFILING\n        gc_dump_alloc_table(&mp_plat_print);\n        #endif\n\n        return ptr_in;\n    }\n\n    #if MICROPY_ENABLE_FINALISER\n    bool ftb_state = FTB_GET(area, block);\n    #else\n    bool ftb_state = false;\n    #endif\n\n    GC_EXIT();\n\n    if (!allow_move) {\n        \n        return NULL;\n    }\n\n    \n    void *ptr_out = gc_alloc(n_bytes, ftb_state);\n\n    \n    if (ptr_out == NULL) {\n        return NULL;\n    }\n\n    DEBUG_printf(\"gc_realloc(%p -> %p)\\n\", ptr_in, ptr_out);\n    memcpy(ptr_out, ptr_in, n_blocks * BYTES_PER_BLOCK);\n    gc_free(ptr_in);\n    return ptr_out;\n}\n#endif \n\nvoid gc_dump_info(const mp_print_t *print) {\n    gc_info_t info;\n    gc_info(&info);\n    mp_printf(print, \"GC: total: %u, used: %u, free: %u\",\n        (uint)info.total, (uint)info.used, (uint)info.free);\n    #if MICROPY_GC_SPLIT_HEAP_AUTO\n    mp_printf(print, \", max new split: %u\", (uint)info.max_new_split);\n    #endif\n    mp_printf(print, \"\\n No. of 1-blocks: %u, 2-blocks: %u, max blk sz: %u, max free sz: %u\\n\",\n        (uint)info.num_1block, (uint)info.num_2block, (uint)info.max_block, (uint)info.max_free);\n}\n\nvoid gc_dump_alloc_table(const mp_print_t *print) {\n    GC_ENTER();\n    static const size_t DUMP_BYTES_PER_LINE = 64;\n    for (mp_state_mem_area_t *area = &MP_STATE_MEM(area); area != NULL; area = NEXT_AREA(area)) {\n        #if !EXTENSIVE_HEAP_PROFILING\n        \n        \n        mp_printf(print, \"GC memory layout; from %p:\", area->gc_pool_start);\n        #endif\n        for (size_t bl = 0; bl < area->gc_alloc_table_byte_len * BLOCKS_PER_ATB; bl++) {\n            if (bl % DUMP_BYTES_PER_LINE == 0) {\n                \n                {\n                    \n                    size_t bl2 = bl;\n                    while (bl2 < area->gc_alloc_table_byte_len * BLOCKS_PER_ATB && ATB_GET_KIND(area, bl2) == AT_FREE) {\n                        bl2++;\n                    }\n                    if (bl2 - bl >= 2 * DUMP_BYTES_PER_LINE) {\n                        \n                        mp_printf(print, \"\\n       (%u lines all free)\", (uint)(bl2 - bl) / DUMP_BYTES_PER_LINE);\n                        bl = bl2 & (~(DUMP_BYTES_PER_LINE - 1));\n                        if (bl >= area->gc_alloc_table_byte_len * BLOCKS_PER_ATB) {\n                            \n                            break;\n                        }\n                    }\n                }\n                \n                \n                mp_printf(print, \"\\n%08x: \", (uint)(bl * BYTES_PER_BLOCK));\n            }\n            int c = ' ';\n            switch (ATB_GET_KIND(area, bl)) {\n                case AT_FREE:\n                    c = '.';\n                    break;\n                 \n                 \n                case AT_HEAD: {\n                    void **ptr = (void **)(area->gc_pool_start + bl * BYTES_PER_BLOCK);\n                    if (*ptr == &mp_type_tuple) {\n                        c = 'T';\n                    } else if (*ptr == &mp_type_list) {\n                        c = 'L';\n                    } else if (*ptr == &mp_type_dict) {\n                        c = 'D';\n                    } else if (*ptr == &mp_type_str || *ptr == &mp_type_bytes) {\n                        c = 'S';\n                    }\n                    #if MICROPY_PY_BUILTINS_BYTEARRAY\n                    else if (*ptr == &mp_type_bytearray) {\n                        c = 'A';\n                    }\n                    #endif\n                    #if MICROPY_PY_ARRAY\n                    else if (*ptr == &mp_type_array) {\n                        c = 'A';\n                    }\n                    #endif\n                    #if MICROPY_PY_BUILTINS_FLOAT\n                    else if (*ptr == &mp_type_float) {\n                        c = 'F';\n                    }\n                    #endif\n                    else if (*ptr == &mp_type_fun_bc) {\n                        c = 'B';\n                    } else if (*ptr == &mp_type_module) {\n                        c = 'M';\n                    } else {\n                        c = 'h';\n                        #if 0\n                        \n                        \n                        \n                        for (qstr_pool_t *pool = MP_STATE_VM(last_pool); c == 'h' && pool != NULL; pool = pool->prev) {\n                            if ((qstr_pool_t *)ptr == pool) {\n                                c = 'Q';\n                                break;\n                            }\n                            for (const byte **q = pool->qstrs, **q_top = pool->qstrs + pool->len; q < q_top; q++) {\n                                if ((const byte *)ptr == *q) {\n                                    c = 'q';\n                                    break;\n                                }\n                            }\n                        }\n                        #endif\n                    }\n                    break;\n                }\n                case AT_TAIL:\n                    c = '=';\n                    break;\n                case AT_MARK:\n                    c = 'm';\n                    break;\n            }\n            mp_printf(print, \"%c\", c);\n        }\n        mp_print_str(print, \"\\n\");\n    }\n    GC_EXIT();\n}\n\n#if 0\n\nvoid gc_test(void) {\n    mp_uint_t len = 500;\n    mp_uint_t *heap = malloc(len);\n    gc_init(heap, heap + len / sizeof(mp_uint_t));\n    void *ptrs[100];\n    {\n        mp_uint_t **p = gc_alloc(16, false);\n        p[0] = gc_alloc(64, false);\n        p[1] = gc_alloc(1, false);\n        p[2] = gc_alloc(1, false);\n        p[3] = gc_alloc(1, false);\n        mp_uint_t ***p2 = gc_alloc(16, false);\n        p2[0] = p;\n        p2[1] = p;\n        ptrs[0] = p2;\n    }\n    for (int i = 0; i < 25; i += 2) {\n        mp_uint_t *p = gc_alloc(i, false);\n        printf(\"p=%p\\n\", p);\n        if (i & 3) {\n            \n        }\n    }\n\n    printf(\"Before GC:\\n\");\n    gc_dump_alloc_table(&mp_plat_print);\n    printf(\"Starting GC...\\n\");\n    gc_collect_start();\n    gc_collect_root(ptrs, sizeof(ptrs) / sizeof(void *));\n    gc_collect_end();\n    printf(\"After GC:\\n\");\n    gc_dump_alloc_table(&mp_plat_print);\n}\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}