{
  "module_name": "showbc.c",
  "hash_id": "74b79b7c1a2349daebd31469282e35d7e657f3d5a0b919528ba7dc7c0f76a8bf",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/showbc.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n\n#include \"py/bc0.h\"\n#include \"py/emitglue.h\"\n\n#if MICROPY_DEBUG_PRINTERS\n\n#define DECODE_UINT { \\\n        unum = 0; \\\n        do { \\\n            unum = (unum << 7) + (*ip & 0x7f); \\\n        } while ((*ip++ & 0x80) != 0); \\\n}\n\n#define DECODE_ULABEL \\\n    do { \\\n        if (ip[0] & 0x80) { \\\n            unum = ((ip[0] & 0x7f) | (ip[1] << 7)); \\\n            ip += 2; \\\n        } else { \\\n            unum = ip[0]; \\\n            ip += 1; \\\n        } \\\n    } while (0)\n\n#define DECODE_SLABEL \\\n    do { \\\n        if (ip[0] & 0x80) { \\\n            unum = ((ip[0] & 0x7f) | (ip[1] << 7)) - 0x4000; \\\n            ip += 2; \\\n        } else { \\\n            unum = ip[0] - 0x40; \\\n            ip += 1; \\\n        } \\\n    } while (0)\n\n#if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n\n#define DECODE_QSTR \\\n    DECODE_UINT; \\\n    qst = qstr_table[unum]\n\n#else\n\n#define DECODE_QSTR \\\n    DECODE_UINT; \\\n    qst = unum;\n\n#endif\n\n#define DECODE_PTR \\\n    DECODE_UINT; \\\n    unum = (mp_uint_t)(uintptr_t)child_table[unum]\n\n#define DECODE_OBJ \\\n    DECODE_UINT; \\\n    unum = (mp_uint_t)obj_table[unum]\n\nvoid mp_bytecode_print(const mp_print_t *print, const mp_raw_code_t *rc, size_t fun_data_len, const mp_module_constants_t *cm) {\n    const byte *ip_start = rc->fun_data;\n    const byte *ip = rc->fun_data;\n\n    \n    MP_BC_PRELUDE_SIG_DECODE(ip);\n    MP_BC_PRELUDE_SIZE_DECODE(ip);\n    const byte *code_info = ip;\n\n    qstr block_name = mp_decode_uint(&code_info);\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    block_name = cm->qstr_table[block_name];\n    qstr source_file = cm->qstr_table[0];\n    #else\n    qstr source_file = cm->source_file;\n    #endif\n    mp_printf(print, \"File %s, code block '%s' (descriptor: %p, bytecode @%p %u bytes)\\n\",\n        qstr_str(source_file), qstr_str(block_name), rc, ip_start, (unsigned)fun_data_len);\n\n    \n    size_t prelude_size = ip - ip_start + n_info + n_cell;\n    mp_printf(print, \"Raw bytecode (code_info_size=%u, bytecode_size=%u):\\n\",\n        (unsigned)prelude_size, (unsigned)(fun_data_len - prelude_size));\n    for (size_t i = 0; i < fun_data_len; i++) {\n        if (i > 0 && i % 16 == 0) {\n            mp_printf(print, \"\\n\");\n        }\n        mp_printf(print, \" %02x\", ip_start[i]);\n    }\n    mp_printf(print, \"\\n\");\n\n    \n    mp_printf(print, \"arg names:\");\n    for (mp_uint_t i = 0; i < n_pos_args + n_kwonly_args; i++) {\n        qstr qst = mp_decode_uint(&code_info);\n        #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n        qst = cm->qstr_table[qst];\n        #endif\n        mp_printf(print, \" %s\", qstr_str(qst));\n    }\n    mp_printf(print, \"\\n\");\n\n    mp_printf(print, \"(N_STATE %u)\\n\", (unsigned)n_state);\n    mp_printf(print, \"(N_EXC_STACK %u)\\n\", (unsigned)n_exc_stack);\n\n    \n    ip += n_info;\n    const byte *line_info_top = ip;\n\n    \n    for (size_t i = 0; i < n_cell; ++i) {\n        uint local_num = *ip++;\n        mp_printf(print, \"(INIT_CELL %u)\\n\", local_num);\n    }\n\n    \n    {\n        mp_int_t bc = 0;\n        mp_uint_t source_line = 1;\n        mp_printf(print, \"  bc=\" INT_FMT \" line=\" UINT_FMT \"\\n\", bc, source_line);\n        for (const byte *ci = code_info; ci < line_info_top;) {\n            if ((ci[0] & 0x80) == 0) {\n                \n                bc += ci[0] & 0x1f;\n                source_line += ci[0] >> 5;\n                ci += 1;\n            } else {\n                \n                bc += ci[0] & 0xf;\n                source_line += ((ci[0] << 4) & 0x700) | ci[1];\n                ci += 2;\n            }\n            mp_printf(print, \"  bc=\" INT_FMT \" line=\" UINT_FMT \"\\n\", bc, source_line);\n        }\n    }\n    mp_bytecode_print2(print, ip, fun_data_len - prelude_size, rc->children, cm);\n}\n\nconst byte *mp_bytecode_print_str(const mp_print_t *print, const byte *ip_start, const byte *ip, mp_raw_code_t *const *child_table, const mp_module_constants_t *cm) {\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    const qstr_short_t *qstr_table = cm->qstr_table;\n    #endif\n    const mp_obj_t *obj_table = cm->obj_table;\n    mp_uint_t unum;\n    qstr qst;\n\n    switch (*ip++) {\n        case MP_BC_LOAD_CONST_FALSE:\n            mp_printf(print, \"LOAD_CONST_FALSE\");\n            break;\n\n        case MP_BC_LOAD_CONST_NONE:\n            mp_printf(print, \"LOAD_CONST_NONE\");\n            break;\n\n        case MP_BC_LOAD_CONST_TRUE:\n            mp_printf(print, \"LOAD_CONST_TRUE\");\n            break;\n\n        case MP_BC_LOAD_CONST_SMALL_INT: {\n            mp_int_t num = 0;\n            if ((ip[0] & 0x40) != 0) {\n                \n                num--;\n            }\n            do {\n                num = ((mp_uint_t)num << 7) | (*ip & 0x7f);\n            } while ((*ip++ & 0x80) != 0);\n            mp_printf(print, \"LOAD_CONST_SMALL_INT \" INT_FMT, num);\n            break;\n        }\n\n        case MP_BC_LOAD_CONST_STRING:\n            DECODE_QSTR;\n            mp_printf(print, \"LOAD_CONST_STRING '%s'\", qstr_str(qst));\n            break;\n\n        case MP_BC_LOAD_CONST_OBJ:\n            DECODE_OBJ;\n            mp_printf(print, \"LOAD_CONST_OBJ %p=\", MP_OBJ_TO_PTR(unum));\n            mp_obj_print_helper(print, (mp_obj_t)unum, PRINT_REPR);\n            break;\n\n        case MP_BC_LOAD_NULL:\n            mp_printf(print, \"LOAD_NULL\");\n            break;\n\n        case MP_BC_LOAD_FAST_N:\n            DECODE_UINT;\n            mp_printf(print, \"LOAD_FAST_N \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_LOAD_DEREF:\n            DECODE_UINT;\n            mp_printf(print, \"LOAD_DEREF \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_LOAD_NAME:\n            DECODE_QSTR;\n            mp_printf(print, \"LOAD_NAME %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_LOAD_GLOBAL:\n            DECODE_QSTR;\n            mp_printf(print, \"LOAD_GLOBAL %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_LOAD_ATTR:\n            DECODE_QSTR;\n            mp_printf(print, \"LOAD_ATTR %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_LOAD_METHOD:\n            DECODE_QSTR;\n            mp_printf(print, \"LOAD_METHOD %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_LOAD_SUPER_METHOD:\n            DECODE_QSTR;\n            mp_printf(print, \"LOAD_SUPER_METHOD %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_LOAD_BUILD_CLASS:\n            mp_printf(print, \"LOAD_BUILD_CLASS\");\n            break;\n\n        case MP_BC_LOAD_SUBSCR:\n            mp_printf(print, \"LOAD_SUBSCR\");\n            break;\n\n        case MP_BC_STORE_FAST_N:\n            DECODE_UINT;\n            mp_printf(print, \"STORE_FAST_N \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_STORE_DEREF:\n            DECODE_UINT;\n            mp_printf(print, \"STORE_DEREF \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_STORE_NAME:\n            DECODE_QSTR;\n            mp_printf(print, \"STORE_NAME %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_STORE_GLOBAL:\n            DECODE_QSTR;\n            mp_printf(print, \"STORE_GLOBAL %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_STORE_ATTR:\n            DECODE_QSTR;\n            mp_printf(print, \"STORE_ATTR %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_STORE_SUBSCR:\n            mp_printf(print, \"STORE_SUBSCR\");\n            break;\n\n        case MP_BC_DELETE_FAST:\n            DECODE_UINT;\n            mp_printf(print, \"DELETE_FAST \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_DELETE_DEREF:\n            DECODE_UINT;\n            mp_printf(print, \"DELETE_DEREF \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_DELETE_NAME:\n            DECODE_QSTR;\n            mp_printf(print, \"DELETE_NAME %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_DELETE_GLOBAL:\n            DECODE_QSTR;\n            mp_printf(print, \"DELETE_GLOBAL %s\", qstr_str(qst));\n            break;\n\n        case MP_BC_DUP_TOP:\n            mp_printf(print, \"DUP_TOP\");\n            break;\n\n        case MP_BC_DUP_TOP_TWO:\n            mp_printf(print, \"DUP_TOP_TWO\");\n            break;\n\n        case MP_BC_POP_TOP:\n            mp_printf(print, \"POP_TOP\");\n            break;\n\n        case MP_BC_ROT_TWO:\n            mp_printf(print, \"ROT_TWO\");\n            break;\n\n        case MP_BC_ROT_THREE:\n            mp_printf(print, \"ROT_THREE\");\n            break;\n\n        case MP_BC_JUMP:\n            DECODE_SLABEL;\n            mp_printf(print, \"JUMP \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_POP_JUMP_IF_TRUE:\n            DECODE_SLABEL;\n            mp_printf(print, \"POP_JUMP_IF_TRUE \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_POP_JUMP_IF_FALSE:\n            DECODE_SLABEL;\n            mp_printf(print, \"POP_JUMP_IF_FALSE \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_JUMP_IF_TRUE_OR_POP:\n            DECODE_ULABEL;\n            mp_printf(print, \"JUMP_IF_TRUE_OR_POP \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_JUMP_IF_FALSE_OR_POP:\n            DECODE_ULABEL;\n            mp_printf(print, \"JUMP_IF_FALSE_OR_POP \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_SETUP_WITH:\n            DECODE_ULABEL; \n            mp_printf(print, \"SETUP_WITH \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_WITH_CLEANUP:\n            mp_printf(print, \"WITH_CLEANUP\");\n            break;\n\n        case MP_BC_UNWIND_JUMP:\n            DECODE_SLABEL;\n            mp_printf(print, \"UNWIND_JUMP \" UINT_FMT \" %d\", (mp_uint_t)(ip + unum - ip_start), *ip);\n            ip += 1;\n            break;\n\n        case MP_BC_SETUP_EXCEPT:\n            DECODE_ULABEL; \n            mp_printf(print, \"SETUP_EXCEPT \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_SETUP_FINALLY:\n            DECODE_ULABEL; \n            mp_printf(print, \"SETUP_FINALLY \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_END_FINALLY:\n            \n            \n            \n            \n            mp_printf(print, \"END_FINALLY\");\n            break;\n\n        case MP_BC_GET_ITER:\n            mp_printf(print, \"GET_ITER\");\n            break;\n\n        case MP_BC_GET_ITER_STACK:\n            mp_printf(print, \"GET_ITER_STACK\");\n            break;\n\n        case MP_BC_FOR_ITER:\n            DECODE_ULABEL; \n            mp_printf(print, \"FOR_ITER \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_POP_EXCEPT_JUMP:\n            DECODE_ULABEL; \n            mp_printf(print, \"POP_EXCEPT_JUMP \" UINT_FMT, (mp_uint_t)(ip + unum - ip_start));\n            break;\n\n        case MP_BC_BUILD_TUPLE:\n            DECODE_UINT;\n            mp_printf(print, \"BUILD_TUPLE \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_BUILD_LIST:\n            DECODE_UINT;\n            mp_printf(print, \"BUILD_LIST \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_BUILD_MAP:\n            DECODE_UINT;\n            mp_printf(print, \"BUILD_MAP \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_STORE_MAP:\n            mp_printf(print, \"STORE_MAP\");\n            break;\n\n        case MP_BC_BUILD_SET:\n            DECODE_UINT;\n            mp_printf(print, \"BUILD_SET \" UINT_FMT, unum);\n            break;\n\n        #if MICROPY_PY_BUILTINS_SLICE\n        case MP_BC_BUILD_SLICE:\n            DECODE_UINT;\n            mp_printf(print, \"BUILD_SLICE \" UINT_FMT, unum);\n            break;\n        #endif\n\n        case MP_BC_STORE_COMP:\n            DECODE_UINT;\n            mp_printf(print, \"STORE_COMP \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_UNPACK_SEQUENCE:\n            DECODE_UINT;\n            mp_printf(print, \"UNPACK_SEQUENCE \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_UNPACK_EX:\n            DECODE_UINT;\n            mp_printf(print, \"UNPACK_EX \" UINT_FMT, unum);\n            break;\n\n        case MP_BC_MAKE_FUNCTION:\n            DECODE_PTR;\n            mp_printf(print, \"MAKE_FUNCTION %p\", (void *)(uintptr_t)unum);\n            break;\n\n        case MP_BC_MAKE_FUNCTION_DEFARGS:\n            DECODE_PTR;\n            mp_printf(print, \"MAKE_FUNCTION_DEFARGS %p\", (void *)(uintptr_t)unum);\n            break;\n\n        case MP_BC_MAKE_CLOSURE: {\n            DECODE_PTR;\n            mp_uint_t n_closed_over = *ip++;\n            mp_printf(print, \"MAKE_CLOSURE %p \" UINT_FMT, (void *)(uintptr_t)unum, n_closed_over);\n            break;\n        }\n\n        case MP_BC_MAKE_CLOSURE_DEFARGS: {\n            DECODE_PTR;\n            mp_uint_t n_closed_over = *ip++;\n            mp_printf(print, \"MAKE_CLOSURE_DEFARGS %p \" UINT_FMT, (void *)(uintptr_t)unum, n_closed_over);\n            break;\n        }\n\n        case MP_BC_CALL_FUNCTION:\n            DECODE_UINT;\n            mp_printf(print, \"CALL_FUNCTION n=\" UINT_FMT \" nkw=\" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_CALL_FUNCTION_VAR_KW:\n            DECODE_UINT;\n            mp_printf(print, \"CALL_FUNCTION_VAR_KW n=\" UINT_FMT \" nkw=\" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_CALL_METHOD:\n            DECODE_UINT;\n            mp_printf(print, \"CALL_METHOD n=\" UINT_FMT \" nkw=\" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_CALL_METHOD_VAR_KW:\n            DECODE_UINT;\n            mp_printf(print, \"CALL_METHOD_VAR_KW n=\" UINT_FMT \" nkw=\" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_RETURN_VALUE:\n            mp_printf(print, \"RETURN_VALUE\");\n            break;\n\n        case MP_BC_RAISE_LAST:\n            mp_printf(print, \"RAISE_LAST\");\n            break;\n\n        case MP_BC_RAISE_OBJ:\n            mp_printf(print, \"RAISE_OBJ\");\n            break;\n\n        case MP_BC_RAISE_FROM:\n            mp_printf(print, \"RAISE_FROM\");\n            break;\n\n        case MP_BC_YIELD_VALUE:\n            mp_printf(print, \"YIELD_VALUE\");\n            break;\n\n        case MP_BC_YIELD_FROM:\n            mp_printf(print, \"YIELD_FROM\");\n            break;\n\n        case MP_BC_IMPORT_NAME:\n            DECODE_QSTR;\n            mp_printf(print, \"IMPORT_NAME '%s'\", qstr_str(qst));\n            break;\n\n        case MP_BC_IMPORT_FROM:\n            DECODE_QSTR;\n            mp_printf(print, \"IMPORT_FROM '%s'\", qstr_str(qst));\n            break;\n\n        case MP_BC_IMPORT_STAR:\n            mp_printf(print, \"IMPORT_STAR\");\n            break;\n\n        default:\n            if (ip[-1] < MP_BC_LOAD_CONST_SMALL_INT_MULTI + 64) {\n                mp_printf(print, \"LOAD_CONST_SMALL_INT \" INT_FMT, (mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - 16);\n            } else if (ip[-1] < MP_BC_LOAD_FAST_MULTI + 16) {\n                mp_printf(print, \"LOAD_FAST \" UINT_FMT, (mp_uint_t)ip[-1] - MP_BC_LOAD_FAST_MULTI);\n            } else if (ip[-1] < MP_BC_STORE_FAST_MULTI + 16) {\n                mp_printf(print, \"STORE_FAST \" UINT_FMT, (mp_uint_t)ip[-1] - MP_BC_STORE_FAST_MULTI);\n            } else if (ip[-1] < MP_BC_UNARY_OP_MULTI + MP_UNARY_OP_NUM_BYTECODE) {\n                mp_uint_t op = ip[-1] - MP_BC_UNARY_OP_MULTI;\n                mp_printf(print, \"UNARY_OP \" UINT_FMT \" %s\", op, qstr_str(mp_unary_op_method_name[op]));\n            } else if (ip[-1] < MP_BC_BINARY_OP_MULTI + MP_BINARY_OP_NUM_BYTECODE) {\n                mp_uint_t op = ip[-1] - MP_BC_BINARY_OP_MULTI;\n                mp_printf(print, \"BINARY_OP \" UINT_FMT \" %s\", op, qstr_str(mp_binary_op_method_name[op]));\n            } else {\n                mp_printf(print, \"code %p, byte code 0x%02x not implemented\\n\", ip - 1, ip[-1]);\n                assert(0);\n                return ip;\n            }\n            break;\n    }\n\n    return ip;\n}\n\nvoid mp_bytecode_print2(const mp_print_t *print, const byte *ip, size_t len, mp_raw_code_t *const *child_table, const mp_module_constants_t *cm) {\n    const byte *ip_start = ip;\n    while (ip < ip_start + len) {\n        mp_printf(print, \"%02u \", (uint)(ip - ip_start));\n        ip = mp_bytecode_print_str(print, ip_start, ip, child_table, cm);\n        mp_printf(print, \"\\n\");\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}