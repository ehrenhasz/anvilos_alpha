{
  "module_name": "asmxtensa.c",
  "hash_id": "f0053db3ab347ef6f8a5bbcfca14641514628d80c344032214750483cc2f1126",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/asmxtensa.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n\n\n#if MICROPY_EMIT_XTENSA || MICROPY_EMIT_INLINE_XTENSA || MICROPY_EMIT_XTENSAWIN\n\n#include \"py/asmxtensa.h\"\n\n#define WORD_SIZE (4)\n#define SIGNED_FIT8(x) ((((x) & 0xffffff80) == 0) || (((x) & 0xffffff80) == 0xffffff80))\n#define SIGNED_FIT12(x) ((((x) & 0xfffff800) == 0) || (((x) & 0xfffff800) == 0xfffff800))\n\nvoid asm_xtensa_end_pass(asm_xtensa_t *as) {\n    as->num_const = as->cur_const;\n    as->cur_const = 0;\n\n    #if 0\n    \n    if (as->base.pass == MP_ASM_PASS_EMIT) {\n        uint8_t *d = as->base.code_base;\n        printf(\"XTENSA ASM:\");\n        for (int i = 0; i < ((as->base.code_size + 15) & ~15); ++i) {\n            if (i % 16 == 0) {\n                printf(\"\\n%08x:\", (uint32_t)&d[i]);\n            }\n            if (i % 2 == 0) {\n                printf(\" \");\n            }\n            printf(\"%02x\", d[i]);\n        }\n        printf(\"\\n\");\n    }\n    #endif\n}\n\nvoid asm_xtensa_entry(asm_xtensa_t *as, int num_locals) {\n    \n    asm_xtensa_op_j(as, as->num_const * WORD_SIZE + 4 - 4);\n    mp_asm_base_get_cur_to_write_bytes(&as->base, 1); \n    as->const_table = (uint32_t *)mp_asm_base_get_cur_to_write_bytes(&as->base, as->num_const * 4);\n\n    \n    as->stack_adjust = (((ASM_XTENSA_NUM_REGS_SAVED + num_locals) * WORD_SIZE) + 15) & ~15;\n    if (SIGNED_FIT8(-as->stack_adjust)) {\n        asm_xtensa_op_addi(as, ASM_XTENSA_REG_A1, ASM_XTENSA_REG_A1, -as->stack_adjust);\n    } else {\n        asm_xtensa_op_movi(as, ASM_XTENSA_REG_A9, as->stack_adjust);\n        asm_xtensa_op_sub(as, ASM_XTENSA_REG_A1, ASM_XTENSA_REG_A1, ASM_XTENSA_REG_A9);\n    }\n\n    \n    asm_xtensa_op_s32i_n(as, ASM_XTENSA_REG_A0, ASM_XTENSA_REG_A1, 0);\n    for (int i = 1; i < ASM_XTENSA_NUM_REGS_SAVED; ++i) {\n        asm_xtensa_op_s32i_n(as, ASM_XTENSA_REG_A11 + i, ASM_XTENSA_REG_A1, i);\n    }\n}\n\nvoid asm_xtensa_exit(asm_xtensa_t *as) {\n    \n    for (int i = ASM_XTENSA_NUM_REGS_SAVED - 1; i >= 1; --i) {\n        asm_xtensa_op_l32i_n(as, ASM_XTENSA_REG_A11 + i, ASM_XTENSA_REG_A1, i);\n    }\n    asm_xtensa_op_l32i_n(as, ASM_XTENSA_REG_A0, ASM_XTENSA_REG_A1, 0);\n\n    \n    if (SIGNED_FIT8(as->stack_adjust)) {\n        asm_xtensa_op_addi(as, ASM_XTENSA_REG_A1, ASM_XTENSA_REG_A1, as->stack_adjust);\n    } else {\n        asm_xtensa_op_movi(as, ASM_XTENSA_REG_A9, as->stack_adjust);\n        asm_xtensa_op_add_n(as, ASM_XTENSA_REG_A1, ASM_XTENSA_REG_A1, ASM_XTENSA_REG_A9);\n    }\n\n    asm_xtensa_op_ret_n(as);\n}\n\nvoid asm_xtensa_entry_win(asm_xtensa_t *as, int num_locals) {\n    \n    asm_xtensa_op_j(as, as->num_const * WORD_SIZE + 4 - 4);\n    mp_asm_base_get_cur_to_write_bytes(&as->base, 1); \n    as->const_table = (uint32_t *)mp_asm_base_get_cur_to_write_bytes(&as->base, as->num_const * 4);\n\n    as->stack_adjust = 32 + ((((ASM_XTENSA_NUM_REGS_SAVED_WIN + num_locals) * WORD_SIZE) + 15) & ~15);\n    asm_xtensa_op_entry(as, ASM_XTENSA_REG_A1, as->stack_adjust);\n    asm_xtensa_op_s32i_n(as, ASM_XTENSA_REG_A0, ASM_XTENSA_REG_A1, 0);\n}\n\nvoid asm_xtensa_exit_win(asm_xtensa_t *as) {\n    asm_xtensa_op_l32i_n(as, ASM_XTENSA_REG_A0, ASM_XTENSA_REG_A1, 0);\n    asm_xtensa_op_retw_n(as);\n}\n\nstatic uint32_t get_label_dest(asm_xtensa_t *as, uint label) {\n    assert(label < as->base.max_num_labels);\n    return as->base.label_offsets[label];\n}\n\nvoid asm_xtensa_op16(asm_xtensa_t *as, uint16_t op) {\n    uint8_t *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 2);\n    if (c != NULL) {\n        c[0] = op;\n        c[1] = op >> 8;\n    }\n}\n\nvoid asm_xtensa_op24(asm_xtensa_t *as, uint32_t op) {\n    uint8_t *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 3);\n    if (c != NULL) {\n        c[0] = op;\n        c[1] = op >> 8;\n        c[2] = op >> 16;\n    }\n}\n\nvoid asm_xtensa_j_label(asm_xtensa_t *as, uint label) {\n    uint32_t dest = get_label_dest(as, label);\n    int32_t rel = dest - as->base.code_offset - 4;\n    \n    asm_xtensa_op_j(as, rel);\n}\n\nvoid asm_xtensa_bccz_reg_label(asm_xtensa_t *as, uint cond, uint reg, uint label) {\n    uint32_t dest = get_label_dest(as, label);\n    int32_t rel = dest - as->base.code_offset - 4;\n    if (as->base.pass == MP_ASM_PASS_EMIT && !SIGNED_FIT12(rel)) {\n        printf(\"ERROR: xtensa bccz out of range\\n\");\n    }\n    asm_xtensa_op_bccz(as, cond, reg, rel);\n}\n\nvoid asm_xtensa_bcc_reg_reg_label(asm_xtensa_t *as, uint cond, uint reg1, uint reg2, uint label) {\n    uint32_t dest = get_label_dest(as, label);\n    int32_t rel = dest - as->base.code_offset - 4;\n    if (as->base.pass == MP_ASM_PASS_EMIT && !SIGNED_FIT8(rel)) {\n        printf(\"ERROR: xtensa bcc out of range\\n\");\n    }\n    asm_xtensa_op_bcc(as, cond, reg1, reg2, rel);\n}\n\n\nvoid asm_xtensa_setcc_reg_reg_reg(asm_xtensa_t *as, uint cond, uint reg_dest, uint reg_src1, uint reg_src2) {\n    asm_xtensa_op_movi_n(as, reg_dest, 1);\n    asm_xtensa_op_bcc(as, cond, reg_src1, reg_src2, 1);\n    asm_xtensa_op_movi_n(as, reg_dest, 0);\n}\n\nsize_t asm_xtensa_mov_reg_i32(asm_xtensa_t *as, uint reg_dest, uint32_t i32) {\n    \n    uint32_t const_table_offset = (uint8_t *)as->const_table - as->base.code_base;\n    size_t loc = const_table_offset + as->cur_const * WORD_SIZE;\n    asm_xtensa_op_l32r(as, reg_dest, as->base.code_offset, loc);\n    \n    if (as->const_table != NULL) {\n        as->const_table[as->cur_const] = i32;\n    }\n    ++as->cur_const;\n    return loc;\n}\n\nvoid asm_xtensa_mov_reg_i32_optimised(asm_xtensa_t *as, uint reg_dest, uint32_t i32) {\n    if (-32 <= (int)i32 && (int)i32 <= 95) {\n        asm_xtensa_op_movi_n(as, reg_dest, i32);\n    } else if (SIGNED_FIT12(i32)) {\n        asm_xtensa_op_movi(as, reg_dest, i32);\n    } else {\n        asm_xtensa_mov_reg_i32(as, reg_dest, i32);\n    }\n}\n\nvoid asm_xtensa_mov_local_reg(asm_xtensa_t *as, int local_num, uint reg_src) {\n    asm_xtensa_op_s32i(as, reg_src, ASM_XTENSA_REG_A1, local_num);\n}\n\nvoid asm_xtensa_mov_reg_local(asm_xtensa_t *as, uint reg_dest, int local_num) {\n    asm_xtensa_op_l32i(as, reg_dest, ASM_XTENSA_REG_A1, local_num);\n}\n\nvoid asm_xtensa_mov_reg_local_addr(asm_xtensa_t *as, uint reg_dest, int local_num) {\n    uint off = local_num * WORD_SIZE;\n    if (SIGNED_FIT8(off)) {\n        asm_xtensa_op_addi(as, reg_dest, ASM_XTENSA_REG_A1, off);\n    } else {\n        asm_xtensa_op_movi(as, reg_dest, off);\n        asm_xtensa_op_add_n(as, reg_dest, reg_dest, ASM_XTENSA_REG_A1);\n    }\n}\n\nvoid asm_xtensa_mov_reg_pcrel(asm_xtensa_t *as, uint reg_dest, uint label) {\n    \n    uint32_t dest = get_label_dest(as, label);\n    int32_t rel = dest - as->base.code_offset;\n    rel -= 3 + 3; \n    asm_xtensa_op_movi(as, reg_dest, rel); \n\n    \n    \n    \n    \n    \n    \n    uint32_t off = as->base.code_offset >> 1 & 1;\n    uint32_t pad = (5 - as->base.code_offset) & 3;\n    asm_xtensa_op_call0(as, off);\n    mp_asm_base_get_cur_to_write_bytes(&as->base, pad);\n\n    \n    asm_xtensa_op_add_n(as, reg_dest, reg_dest, ASM_XTENSA_REG_A0);\n}\n\nvoid asm_xtensa_l32i_optimised(asm_xtensa_t *as, uint reg_dest, uint reg_base, uint word_offset) {\n    if (word_offset < 16) {\n        asm_xtensa_op_l32i_n(as, reg_dest, reg_base, word_offset);\n    } else if (word_offset < 256) {\n        asm_xtensa_op_l32i(as, reg_dest, reg_base, word_offset);\n    } else {\n        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"asm overflow\"));\n    }\n}\n\nvoid asm_xtensa_s32i_optimised(asm_xtensa_t *as, uint reg_src, uint reg_base, uint word_offset) {\n    if (word_offset < 16) {\n        asm_xtensa_op_s32i_n(as, reg_src, reg_base, word_offset);\n    } else if (word_offset < 256) {\n        asm_xtensa_op_s32i(as, reg_src, reg_base, word_offset);\n    } else {\n        mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"asm overflow\"));\n    }\n}\n\nvoid asm_xtensa_call_ind(asm_xtensa_t *as, uint idx) {\n    asm_xtensa_l32i_optimised(as, ASM_XTENSA_REG_A0, ASM_XTENSA_REG_FUN_TABLE, idx);\n    asm_xtensa_op_callx0(as, ASM_XTENSA_REG_A0);\n}\n\nvoid asm_xtensa_call_ind_win(asm_xtensa_t *as, uint idx) {\n    asm_xtensa_l32i_optimised(as, ASM_XTENSA_REG_A8, ASM_XTENSA_REG_FUN_TABLE_WIN, idx);\n    asm_xtensa_op_callx8(as, ASM_XTENSA_REG_A8);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}