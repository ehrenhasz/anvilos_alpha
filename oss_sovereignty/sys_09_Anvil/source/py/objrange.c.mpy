{
  "module_name": "objrange.c",
  "hash_id": "868f866a81cff89617da8f69e5c0275545d725f800592e8608add37161030937",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objrange.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n\n#include \"py/runtime.h\"\n\n \n \n\ntypedef struct _mp_obj_range_it_t {\n    mp_obj_base_t base;\n    \n    mp_int_t cur;\n    mp_int_t stop;\n    mp_int_t step;\n} mp_obj_range_it_t;\n\nstatic mp_obj_t range_it_iternext(mp_obj_t o_in) {\n    mp_obj_range_it_t *o = MP_OBJ_TO_PTR(o_in);\n    if ((o->step > 0 && o->cur < o->stop) || (o->step < 0 && o->cur > o->stop)) {\n        mp_obj_t o_out = MP_OBJ_NEW_SMALL_INT(o->cur);\n        o->cur += o->step;\n        return o_out;\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_range_it,\n    MP_QSTR_iterator,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    iter, range_it_iternext\n    );\n\nstatic mp_obj_t mp_obj_new_range_iterator(mp_int_t cur, mp_int_t stop, mp_int_t step, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_range_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_range_it_t *o = (mp_obj_range_it_t *)iter_buf;\n    o->base.type = &mp_type_range_it;\n    o->cur = cur;\n    o->stop = stop;\n    o->step = step;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n \n\ntypedef struct _mp_obj_range_t {\n    mp_obj_base_t base;\n    \n    mp_int_t start;\n    mp_int_t stop;\n    mp_int_t step;\n} mp_obj_range_t;\n\nstatic void range_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_range_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"range(\" INT_FMT \", \" INT_FMT \"\", self->start, self->stop);\n    if (self->step == 1) {\n        mp_print_str(print, \")\");\n    } else {\n        mp_printf(print, \", \" INT_FMT \")\", self->step);\n    }\n}\n\nstatic mp_obj_t range_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 1, 3, false);\n\n    mp_obj_range_t *o = mp_obj_malloc(mp_obj_range_t, type);\n    o->start = 0;\n    o->step = 1;\n\n    if (n_args == 1) {\n        o->stop = mp_obj_get_int(args[0]);\n    } else {\n        o->start = mp_obj_get_int(args[0]);\n        o->stop = mp_obj_get_int(args[1]);\n        if (n_args == 3) {\n            o->step = mp_obj_get_int(args[2]);\n            if (o->step == 0) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"zero step\"));\n            }\n        }\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_int_t range_len(mp_obj_range_t *self) {\n    \n    mp_int_t len = self->stop - self->start + self->step;\n    if (self->step > 0) {\n        len -= 1;\n    } else {\n        len += 1;\n    }\n    len = len / self->step;\n    if (len < 0) {\n        len = 0;\n    }\n    return len;\n}\n\nstatic mp_obj_t range_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_range_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_int_t len = range_len(self);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(len > 0);\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(len);\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\n#if MICROPY_PY_BUILTINS_RANGE_BINOP\nstatic mp_obj_t range_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    if (!mp_obj_is_type(rhs_in, &mp_type_range) || op != MP_BINARY_OP_EQUAL) {\n        return MP_OBJ_NULL; \n    }\n    mp_obj_range_t *lhs = MP_OBJ_TO_PTR(lhs_in);\n    mp_obj_range_t *rhs = MP_OBJ_TO_PTR(rhs_in);\n    mp_int_t lhs_len = range_len(lhs);\n    mp_int_t rhs_len = range_len(rhs);\n    return mp_obj_new_bool(\n        lhs_len == rhs_len\n        && (lhs_len == 0\n            || (lhs->start == rhs->start\n                && (lhs_len == 1 || lhs->step == rhs->step)))\n        );\n}\n#endif\n\nstatic mp_obj_t range_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    if (value == MP_OBJ_SENTINEL) {\n        \n        mp_obj_range_t *self = MP_OBJ_TO_PTR(self_in);\n        mp_int_t len = range_len(self);\n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_bound_slice_t slice;\n            mp_seq_get_fast_slice_indexes(len, index, &slice);\n            mp_obj_range_t *o = mp_obj_malloc(mp_obj_range_t, &mp_type_range);\n            o->start = self->start + slice.start * self->step;\n            o->stop = self->start + slice.stop * self->step;\n            o->step = slice.step * self->step;\n            if (slice.step < 0) {\n                \n                o->stop -= self->step;\n            }\n            return MP_OBJ_FROM_PTR(o);\n        }\n        #endif\n        size_t index_val = mp_get_index(self->base.type, len, index, false);\n        return MP_OBJ_NEW_SMALL_INT(self->start + index_val * self->step);\n    } else {\n        return MP_OBJ_NULL; \n    }\n}\n\nstatic mp_obj_t range_getiter(mp_obj_t o_in, mp_obj_iter_buf_t *iter_buf) {\n    mp_obj_range_t *o = MP_OBJ_TO_PTR(o_in);\n    return mp_obj_new_range_iterator(o->start, o->stop, o->step, iter_buf);\n}\n\n\n#if MICROPY_PY_BUILTINS_RANGE_ATTRS\nstatic void range_attr(mp_obj_t o_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n    mp_obj_range_t *o = MP_OBJ_TO_PTR(o_in);\n    if (attr == MP_QSTR_start) {\n        dest[0] = mp_obj_new_int(o->start);\n    } else if (attr == MP_QSTR_stop) {\n        dest[0] = mp_obj_new_int(o->stop);\n    } else if (attr == MP_QSTR_step) {\n        dest[0] = mp_obj_new_int(o->step);\n    }\n}\n#endif\n\n#if MICROPY_PY_BUILTINS_RANGE_BINOP\n#define RANGE_TYPE_BINOP binary_op, range_binary_op,\n#else\n#define RANGE_TYPE_BINOP\n#endif\n\n#if MICROPY_PY_BUILTINS_RANGE_ATTRS\n#define RANGE_TYPE_ATTR attr, range_attr,\n#else\n#define RANGE_TYPE_ATTR\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_range,\n    MP_QSTR_range,\n    MP_TYPE_FLAG_NONE,\n    make_new, range_make_new,\n    RANGE_TYPE_BINOP\n    RANGE_TYPE_ATTR\n    print, range_print,\n    unary_op, range_unary_op,\n    subscr, range_subscr,\n    iter, range_getiter\n    );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}