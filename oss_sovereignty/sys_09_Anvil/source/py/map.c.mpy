{
  "module_name": "map.c",
  "hash_id": "20eb513ed4a2627c270011a0251b8bcf339822a6839cf4592ffee74959af8e58",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/map.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/mpconfig.h\"\n#include \"py/misc.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\n#if MICROPY_OPT_MAP_LOOKUP_CACHE\n\n\n\n\n\n\n\n\n\n#define MAP_CACHE_OFFSET(index) ((((uintptr_t)(index)) >> 2) % MICROPY_OPT_MAP_LOOKUP_CACHE_SIZE)\n\n#define MAP_CACHE_ENTRY(index) (MP_STATE_VM(map_lookup_cache)[MAP_CACHE_OFFSET(index)])\n\n#define MAP_CACHE_GET(map, index) (&(map)->table[MAP_CACHE_ENTRY(index) % (map)->alloc])\n\n#define MAP_CACHE_SET(index, pos) MAP_CACHE_ENTRY(index) = (pos) & 0xff;\n#else\n#define MAP_CACHE_SET(index, pos)\n#endif\n\n\n\n\n\nstatic const uint16_t hash_allocation_sizes[] = {\n    0, 2, 4, 6, 8, 10, 12, \n    17, 23, 29, 37, 47, 59, 73, \n    97, 127, 167, 223, 293, 389, 521, 691, 919, 1223, 1627, 2161, \n    3229, 4831, 7243, 10861, 16273, 24407, 36607, 54907, \n};\n\nstatic size_t get_hash_alloc_greater_or_equal_to(size_t x) {\n    for (size_t i = 0; i < MP_ARRAY_SIZE(hash_allocation_sizes); i++) {\n        if (hash_allocation_sizes[i] >= x) {\n            return hash_allocation_sizes[i];\n        }\n    }\n    \n    \n    return (x + x / 2) | 1;\n}\n\n \n \n\nvoid mp_map_init(mp_map_t *map, size_t n) {\n    if (n == 0) {\n        map->alloc = 0;\n        map->table = NULL;\n    } else {\n        map->alloc = n;\n        map->table = m_new0(mp_map_elem_t, map->alloc);\n    }\n    map->used = 0;\n    map->all_keys_are_qstrs = 1;\n    map->is_fixed = 0;\n    map->is_ordered = 0;\n}\n\nvoid mp_map_init_fixed_table(mp_map_t *map, size_t n, const mp_obj_t *table) {\n    map->alloc = n;\n    map->used = n;\n    map->all_keys_are_qstrs = 1;\n    map->is_fixed = 1;\n    map->is_ordered = 1;\n    map->table = (mp_map_elem_t *)table;\n}\n\n\nvoid mp_map_deinit(mp_map_t *map) {\n    if (!map->is_fixed) {\n        m_del(mp_map_elem_t, map->table, map->alloc);\n    }\n    map->used = map->alloc = 0;\n}\n\nvoid mp_map_clear(mp_map_t *map) {\n    if (!map->is_fixed) {\n        m_del(mp_map_elem_t, map->table, map->alloc);\n    }\n    map->alloc = 0;\n    map->used = 0;\n    map->all_keys_are_qstrs = 1;\n    map->is_fixed = 0;\n    map->table = NULL;\n}\n\nstatic void mp_map_rehash(mp_map_t *map) {\n    size_t old_alloc = map->alloc;\n    size_t new_alloc = get_hash_alloc_greater_or_equal_to(map->alloc + 1);\n    DEBUG_printf(\"mp_map_rehash(%p): \" UINT_FMT \" -> \" UINT_FMT \"\\n\", map, old_alloc, new_alloc);\n    mp_map_elem_t *old_table = map->table;\n    mp_map_elem_t *new_table = m_new0(mp_map_elem_t, new_alloc);\n    \n    map->alloc = new_alloc;\n    map->used = 0;\n    map->all_keys_are_qstrs = 1;\n    map->table = new_table;\n    for (size_t i = 0; i < old_alloc; i++) {\n        if (old_table[i].key != MP_OBJ_NULL && old_table[i].key != MP_OBJ_SENTINEL) {\n            mp_map_lookup(map, old_table[i].key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = old_table[i].value;\n        }\n    }\n    m_del(mp_map_elem_t, old_table, old_alloc);\n}\n\n\n\n\n\n\n\nmp_map_elem_t *MICROPY_WRAP_MP_MAP_LOOKUP(mp_map_lookup)(mp_map_t * map, mp_obj_t index, mp_map_lookup_kind_t lookup_kind) {\n    \n    assert(!map->is_fixed || lookup_kind == MP_MAP_LOOKUP);\n\n    #if MICROPY_OPT_MAP_LOOKUP_CACHE\n    \n    if (lookup_kind != MP_MAP_LOOKUP_REMOVE_IF_FOUND && map->alloc) {\n        mp_map_elem_t *slot = MAP_CACHE_GET(map, index);\n        \n        \n        if (slot->key == index) {\n            return slot;\n        }\n    }\n    #endif\n\n    \n    bool compare_only_ptrs = map->all_keys_are_qstrs;\n    if (compare_only_ptrs) {\n        if (mp_obj_is_qstr(index)) {\n            \n        } else if (mp_obj_is_exact_type(index, &mp_type_str)) {\n            \n            \n            \n            \n            \n            compare_only_ptrs = false;\n        } else if (lookup_kind != MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n            \n            \n            return NULL;\n        }\n    }\n\n    \n    if (map->is_ordered) {\n        for (mp_map_elem_t *elem = &map->table[0], *top = &map->table[map->used]; elem < top; elem++) {\n            if (elem->key == index || (!compare_only_ptrs && mp_obj_equal(elem->key, index))) {\n                #if MICROPY_PY_COLLECTIONS_ORDEREDDICT\n                if (MP_UNLIKELY(lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND)) {\n                    \n                    mp_obj_t value = elem->value;\n                    --map->used;\n                    memmove(elem, elem + 1, (top - elem - 1) * sizeof(*elem));\n                    \n                    \n                    elem = &map->table[map->used];\n                    elem->key = MP_OBJ_NULL;\n                    elem->value = value;\n                }\n                #endif\n                MAP_CACHE_SET(index, elem - map->table);\n                return elem;\n            }\n        }\n        #if MICROPY_PY_COLLECTIONS_ORDEREDDICT\n        if (MP_LIKELY(lookup_kind != MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)) {\n            return NULL;\n        }\n        if (map->used == map->alloc) {\n            \n            map->alloc += 4;\n            map->table = m_renew(mp_map_elem_t, map->table, map->used, map->alloc);\n            mp_seq_clear(map->table, map->used, map->alloc, sizeof(*map->table));\n        }\n        mp_map_elem_t *elem = map->table + map->used++;\n        elem->key = index;\n        elem->value = MP_OBJ_NULL;\n        if (!mp_obj_is_qstr(index)) {\n            map->all_keys_are_qstrs = 0;\n        }\n        return elem;\n        #else\n        return NULL;\n        #endif\n    }\n\n    \n\n    if (map->alloc == 0) {\n        if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n            mp_map_rehash(map);\n        } else {\n            return NULL;\n        }\n    }\n\n    \n    mp_uint_t hash;\n    if (mp_obj_is_qstr(index)) {\n        hash = qstr_hash(MP_OBJ_QSTR_VALUE(index));\n    } else {\n        hash = MP_OBJ_SMALL_INT_VALUE(mp_unary_op(MP_UNARY_OP_HASH, index));\n    }\n\n    size_t pos = hash % map->alloc;\n    size_t start_pos = pos;\n    mp_map_elem_t *avail_slot = NULL;\n    for (;;) {\n        mp_map_elem_t *slot = &map->table[pos];\n        if (slot->key == MP_OBJ_NULL) {\n            \n            if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n                map->used += 1;\n                if (avail_slot == NULL) {\n                    avail_slot = slot;\n                }\n                avail_slot->key = index;\n                avail_slot->value = MP_OBJ_NULL;\n                if (!mp_obj_is_qstr(index)) {\n                    map->all_keys_are_qstrs = 0;\n                }\n                return avail_slot;\n            } else {\n                return NULL;\n            }\n        } else if (slot->key == MP_OBJ_SENTINEL) {\n            \n            if (avail_slot == NULL) {\n                avail_slot = slot;\n            }\n        } else if (slot->key == index || (!compare_only_ptrs && mp_obj_equal(slot->key, index))) {\n            \n            \n            if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {\n                \n                map->used--;\n                if (map->table[(pos + 1) % map->alloc].key == MP_OBJ_NULL) {\n                    \n                    slot->key = MP_OBJ_NULL;\n                } else {\n                    slot->key = MP_OBJ_SENTINEL;\n                }\n                \n            }\n            MAP_CACHE_SET(index, pos);\n            return slot;\n        }\n\n        \n        pos = (pos + 1) % map->alloc;\n\n        if (pos == start_pos) {\n            \n            if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n                if (avail_slot != NULL) {\n                    \n                    map->used++;\n                    avail_slot->key = index;\n                    avail_slot->value = MP_OBJ_NULL;\n                    if (!mp_obj_is_qstr(index)) {\n                        map->all_keys_are_qstrs = 0;\n                    }\n                    return avail_slot;\n                } else {\n                    \n                    mp_map_rehash(map);\n                    \n                    start_pos = pos = hash % map->alloc;\n                }\n            } else {\n                return NULL;\n            }\n        }\n    }\n}\n\n \n \n\n#if MICROPY_PY_BUILTINS_SET\n\nvoid mp_set_init(mp_set_t *set, size_t n) {\n    set->alloc = n;\n    set->used = 0;\n    set->table = m_new0(mp_obj_t, set->alloc);\n}\n\nstatic void mp_set_rehash(mp_set_t *set) {\n    size_t old_alloc = set->alloc;\n    mp_obj_t *old_table = set->table;\n    set->alloc = get_hash_alloc_greater_or_equal_to(set->alloc + 1);\n    set->used = 0;\n    set->table = m_new0(mp_obj_t, set->alloc);\n    for (size_t i = 0; i < old_alloc; i++) {\n        if (old_table[i] != MP_OBJ_NULL && old_table[i] != MP_OBJ_SENTINEL) {\n            mp_set_lookup(set, old_table[i], MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n        }\n    }\n    m_del(mp_obj_t, old_table, old_alloc);\n}\n\nmp_obj_t mp_set_lookup(mp_set_t *set, mp_obj_t index, mp_map_lookup_kind_t lookup_kind) {\n    \n    \n\n    if (set->alloc == 0) {\n        if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n            mp_set_rehash(set);\n        } else {\n            return MP_OBJ_NULL;\n        }\n    }\n    mp_uint_t hash = MP_OBJ_SMALL_INT_VALUE(mp_unary_op(MP_UNARY_OP_HASH, index));\n    size_t pos = hash % set->alloc;\n    size_t start_pos = pos;\n    mp_obj_t *avail_slot = NULL;\n    for (;;) {\n        mp_obj_t elem = set->table[pos];\n        if (elem == MP_OBJ_NULL) {\n            \n            if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n                if (avail_slot == NULL) {\n                    avail_slot = &set->table[pos];\n                }\n                set->used++;\n                *avail_slot = index;\n                return index;\n            } else {\n                return MP_OBJ_NULL;\n            }\n        } else if (elem == MP_OBJ_SENTINEL) {\n            \n            if (avail_slot == NULL) {\n                avail_slot = &set->table[pos];\n            }\n        } else if (mp_obj_equal(elem, index)) {\n            \n            if (lookup_kind & MP_MAP_LOOKUP_REMOVE_IF_FOUND) {\n                \n                set->used--;\n                if (set->table[(pos + 1) % set->alloc] == MP_OBJ_NULL) {\n                    \n                    set->table[pos] = MP_OBJ_NULL;\n                } else {\n                    set->table[pos] = MP_OBJ_SENTINEL;\n                }\n            }\n            return elem;\n        }\n\n        \n        pos = (pos + 1) % set->alloc;\n\n        if (pos == start_pos) {\n            \n            if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n                if (avail_slot != NULL) {\n                    \n                    set->used++;\n                    *avail_slot = index;\n                    return index;\n                } else {\n                    \n                    mp_set_rehash(set);\n                    \n                    start_pos = pos = hash % set->alloc;\n                }\n            } else {\n                return MP_OBJ_NULL;\n            }\n        }\n    }\n}\n\nmp_obj_t mp_set_remove_first(mp_set_t *set) {\n    for (size_t pos = 0; pos < set->alloc; pos++) {\n        if (mp_set_slot_is_filled(set, pos)) {\n            mp_obj_t elem = set->table[pos];\n            \n            set->used--;\n            if (set->table[(pos + 1) % set->alloc] == MP_OBJ_NULL) {\n                \n                set->table[pos] = MP_OBJ_NULL;\n            } else {\n                set->table[pos] = MP_OBJ_SENTINEL;\n            }\n            return elem;\n        }\n    }\n    return MP_OBJ_NULL;\n}\n\nvoid mp_set_clear(mp_set_t *set) {\n    m_del(mp_obj_t, set->table, set->alloc);\n    set->alloc = 0;\n    set->used = 0;\n    set->table = NULL;\n}\n\n#endif \n\n#if defined(DEBUG_PRINT) && DEBUG_PRINT\nvoid mp_map_dump(mp_map_t *map) {\n    for (size_t i = 0; i < map->alloc; i++) {\n        if (map->table[i].key != MP_OBJ_NULL) {\n            mp_obj_print(map->table[i].key, PRINT_REPR);\n        } else {\n            DEBUG_printf(\"(nil)\");\n        }\n        DEBUG_printf(\": %p\\n\", map->table[i].value);\n    }\n    DEBUG_printf(\"---\\n\");\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}