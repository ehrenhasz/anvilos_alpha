{
  "module_name": "builtinimport.c",
  "hash_id": "ac70ce8c03f2322cfceb4ae9c395c734b736f7d29b81cd4c74b3b3b2f70d5b92",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/builtinimport.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/compile.h\"\n#include \"py/objmodule.h\"\n#include \"py/persistentcode.h\"\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/frozenmod.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\n#if MICROPY_ENABLE_EXTERNAL_IMPORT\n\n\n#define PATH_SEP_CHAR \"/\"\n\n\n#define MP_FROZEN_PATH_PREFIX \".frozen/\"\n\n\n\n\n\nstatic mp_import_stat_t stat_path(vstr_t *path) {\n    const char *str = vstr_null_terminated_str(path);\n    #if MICROPY_MODULE_FROZEN\n    \n    const int frozen_path_prefix_len = strlen(MP_FROZEN_PATH_PREFIX);\n    if (strncmp(str, MP_FROZEN_PATH_PREFIX, frozen_path_prefix_len) == 0) {\n        \n        return mp_find_frozen_module(str + frozen_path_prefix_len, NULL, NULL);\n    }\n    #endif\n    return mp_import_stat(str);\n}\n\n\n\n\n\n\nstatic mp_import_stat_t stat_file_py_or_mpy(vstr_t *path) {\n    mp_import_stat_t stat = stat_path(path);\n    if (stat == MP_IMPORT_STAT_FILE) {\n        return stat;\n    }\n\n    #if MICROPY_PERSISTENT_CODE_LOAD\n    \n    \n    \n    vstr_ins_byte(path, path->len - 2, 'm');\n    stat = stat_path(path);\n    if (stat == MP_IMPORT_STAT_FILE) {\n        return stat;\n    }\n    #endif\n\n    return MP_IMPORT_STAT_NO_EXIST;\n}\n\n\n\n\n\nstatic mp_import_stat_t stat_module(vstr_t *path) {\n    mp_import_stat_t stat = stat_path(path);\n    DEBUG_printf(\"stat %s: %d\\n\", vstr_str(path), stat);\n    if (stat == MP_IMPORT_STAT_DIR) {\n        return stat;\n    }\n\n    \n    vstr_add_str(path, \".py\");\n    return stat_file_py_or_mpy(path);\n}\n\n\n\n\nstatic mp_import_stat_t stat_top_level(qstr mod_name, vstr_t *dest) {\n    DEBUG_printf(\"stat_top_level: '%s'\\n\", qstr_str(mod_name));\n    #if MICROPY_PY_SYS\n    size_t path_num;\n    mp_obj_t *path_items;\n    mp_obj_get_array(mp_sys_path, &path_num, &path_items);\n\n    \n    for (size_t i = 0; i < path_num; i++) {\n        vstr_reset(dest);\n        size_t p_len;\n        const char *p = mp_obj_str_get_data(path_items[i], &p_len);\n        if (p_len > 0) {\n            \n            vstr_add_strn(dest, p, p_len);\n            vstr_add_char(dest, PATH_SEP_CHAR[0]);\n        }\n        vstr_add_str(dest, qstr_str(mod_name));\n        mp_import_stat_t stat = stat_module(dest);\n        if (stat != MP_IMPORT_STAT_NO_EXIST) {\n            return stat;\n        }\n    }\n\n    \n    \n    return MP_IMPORT_STAT_NO_EXIST;\n\n    #else\n\n    \n    vstr_add_str(dest, qstr_str(mod_name));\n    return stat_module(dest);\n\n    #endif\n}\n\n#if MICROPY_MODULE_FROZEN_STR || MICROPY_ENABLE_COMPILER\nstatic void do_load_from_lexer(mp_module_context_t *context, mp_lexer_t *lex) {\n    #if MICROPY_PY___FILE__\n    qstr source_name = lex->source_name;\n    mp_store_attr(MP_OBJ_FROM_PTR(&context->module), MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));\n    #endif\n\n    \n    mp_obj_dict_t *mod_globals = context->module.globals;\n    mp_parse_compile_execute(lex, MP_PARSE_FILE_INPUT, mod_globals, mod_globals);\n}\n#endif\n\n#if (MICROPY_HAS_FILE_READER && MICROPY_PERSISTENT_CODE_LOAD) || MICROPY_MODULE_FROZEN_MPY\nstatic void do_execute_proto_fun(const mp_module_context_t *context, mp_proto_fun_t proto_fun, qstr source_name) {\n    #if MICROPY_PY___FILE__\n    mp_store_attr(MP_OBJ_FROM_PTR(&context->module), MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));\n    #else\n    (void)source_name;\n    #endif\n\n    \n    mp_obj_dict_t *mod_globals = context->module.globals;\n\n    \n    nlr_jump_callback_node_globals_locals_t ctx;\n    ctx.globals = mp_globals_get();\n    ctx.locals = mp_locals_get();\n\n    \n    mp_globals_set(mod_globals);\n    mp_locals_set(mod_globals);\n\n    \n    nlr_push_jump_callback(&ctx.callback, mp_globals_locals_set_from_nlr_jump_callback);\n\n    \n    mp_obj_t module_fun = mp_make_function_from_proto_fun(proto_fun, context, NULL);\n    mp_call_function_0(module_fun);\n\n    \n    nlr_pop_jump_callback(true);\n}\n#endif\n\nstatic void do_load(mp_module_context_t *module_obj, vstr_t *file) {\n    #if MICROPY_MODULE_FROZEN || MICROPY_ENABLE_COMPILER || (MICROPY_PERSISTENT_CODE_LOAD && MICROPY_HAS_FILE_READER)\n    const char *file_str = vstr_null_terminated_str(file);\n    #endif\n\n    \n    \n    #if MICROPY_MODULE_FROZEN\n    void *modref;\n    int frozen_type;\n    const int frozen_path_prefix_len = strlen(MP_FROZEN_PATH_PREFIX);\n    if (strncmp(file_str, MP_FROZEN_PATH_PREFIX, frozen_path_prefix_len) == 0) {\n        mp_find_frozen_module(file_str + frozen_path_prefix_len, &frozen_type, &modref);\n\n        \n        \n        #if MICROPY_MODULE_FROZEN_STR\n        if (frozen_type == MP_FROZEN_STR) {\n            do_load_from_lexer(module_obj, modref);\n            return;\n        }\n        #endif\n\n        \n        \n        #if MICROPY_MODULE_FROZEN_MPY\n        if (frozen_type == MP_FROZEN_MPY) {\n            const mp_frozen_module_t *frozen = modref;\n            module_obj->constants = frozen->constants;\n            #if MICROPY_PY___FILE__\n            qstr frozen_file_qstr = qstr_from_str(file_str + frozen_path_prefix_len);\n            #else\n            qstr frozen_file_qstr = MP_QSTRnull;\n            #endif\n            do_execute_proto_fun(module_obj, frozen->proto_fun, frozen_file_qstr);\n            return;\n        }\n        #endif\n    }\n\n    #endif \n\n    qstr file_qstr = qstr_from_str(file_str);\n\n    \n    \n    #if MICROPY_HAS_FILE_READER && MICROPY_PERSISTENT_CODE_LOAD\n    if (file_str[file->len - 3] == 'm') {\n        mp_compiled_module_t cm;\n        cm.context = module_obj;\n        mp_raw_code_load_file(file_qstr, &cm);\n        do_execute_proto_fun(cm.context, cm.rc, file_qstr);\n        return;\n    }\n    #endif\n\n    \n    #if MICROPY_ENABLE_COMPILER\n    {\n        mp_lexer_t *lex = mp_lexer_new_from_file(file_qstr);\n        do_load_from_lexer(module_obj, lex);\n        return;\n    }\n    #else\n    \n    mp_raise_msg(&mp_type_ImportError, MP_ERROR_TEXT(\"script compilation not supported\"));\n    #endif\n}\n\n\n\nstatic void evaluate_relative_import(mp_int_t level, const char **module_name, size_t *module_name_len) {\n    \n    \n    \n    \n    \n    \n    \n\n    mp_obj_t current_module_name_obj = mp_obj_dict_get(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(MP_QSTR___name__));\n    assert(current_module_name_obj != MP_OBJ_NULL);\n\n    #if MICROPY_MODULE_OVERRIDE_MAIN_IMPORT && MICROPY_CPYTHON_COMPAT\n    if (MP_OBJ_QSTR_VALUE(current_module_name_obj) == MP_QSTR___main__) {\n        \n        \n        \n        current_module_name_obj = mp_obj_dict_get(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(MP_QSTR___main__));\n    }\n    #endif\n\n    \n    bool is_pkg = mp_map_lookup(&mp_globals_get()->map, MP_OBJ_NEW_QSTR(MP_QSTR___path__), MP_MAP_LOOKUP);\n\n    #if DEBUG_PRINT\n    DEBUG_printf(\"Current module/package: \");\n    mp_obj_print_helper(MICROPY_DEBUG_PRINTER, current_module_name_obj, PRINT_REPR);\n    DEBUG_printf(\", is_package: %d\", is_pkg);\n    DEBUG_printf(\"\\n\");\n    #endif\n\n    size_t current_module_name_len;\n    const char *current_module_name = mp_obj_str_get_data(current_module_name_obj, &current_module_name_len);\n\n    const char *p = current_module_name + current_module_name_len;\n    if (is_pkg) {\n        \n        \n        \n        --level;\n    }\n\n    \n    while (level && p > current_module_name) {\n        if (*--p == '.') {\n            --level;\n        }\n    }\n\n    \n    if (p == current_module_name) {\n        mp_raise_msg(&mp_type_ImportError, MP_ERROR_TEXT(\"can't perform relative import\"));\n    }\n\n    \n    \n    \n    uint new_module_name_len = (size_t)(p - current_module_name) + 1 + *module_name_len;\n    char *new_mod = mp_local_alloc(new_module_name_len);\n    memcpy(new_mod, current_module_name, p - current_module_name);\n\n    \n    if (*module_name_len != 0) {\n        new_mod[p - current_module_name] = '.';\n        memcpy(new_mod + (p - current_module_name) + 1, *module_name, *module_name_len);\n    } else {\n        --new_module_name_len;\n    }\n\n    \n    qstr new_mod_q = qstr_from_strn(new_mod, new_module_name_len);\n    mp_local_free(new_mod);\n\n    DEBUG_printf(\"Resolved base name for relative import: '%s'\\n\", qstr_str(new_mod_q));\n    *module_name = qstr_str(new_mod_q);\n    *module_name_len = new_module_name_len;\n}\n\ntypedef struct _nlr_jump_callback_node_unregister_module_t {\n    nlr_jump_callback_node_t callback;\n    qstr name;\n} nlr_jump_callback_node_unregister_module_t;\n\nstatic void unregister_module_from_nlr_jump_callback(void *ctx_in) {\n    nlr_jump_callback_node_unregister_module_t *ctx = ctx_in;\n    mp_map_t *mp_loaded_modules_map = &MP_STATE_VM(mp_loaded_modules_dict).map;\n    mp_map_lookup(mp_loaded_modules_map, MP_OBJ_NEW_QSTR(ctx->name), MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n}\n\n\n\n\n\n\n\n\nstatic mp_obj_t process_import_at_level(qstr full_mod_name, qstr level_mod_name, mp_obj_t outer_module_obj, bool override_main) {\n    \n    mp_map_elem_t *elem;\n\n    #if MICROPY_PY_SYS\n    \n    \n    \n    size_t path_num;\n    mp_obj_t *path_items;\n    mp_obj_get_array(mp_sys_path, &path_num, &path_items);\n    if (path_num)\n    #endif\n    {\n        elem = mp_map_lookup(&MP_STATE_VM(mp_loaded_modules_dict).map, MP_OBJ_NEW_QSTR(full_mod_name), MP_MAP_LOOKUP);\n        if (elem) {\n            return elem->value;\n        }\n    }\n\n    VSTR_FIXED(path, MICROPY_ALLOC_PATH_MAX);\n    mp_import_stat_t stat = MP_IMPORT_STAT_NO_EXIST;\n    mp_obj_t module_obj;\n\n    if (outer_module_obj == MP_OBJ_NULL) {\n        \n        DEBUG_printf(\"Searching for top-level module\\n\");\n\n        \n        \n        \n        module_obj = mp_module_get_builtin(level_mod_name, false);\n        if (module_obj != MP_OBJ_NULL) {\n            return module_obj;\n        }\n\n        \n        \n        stat = stat_top_level(level_mod_name, &path);\n\n        \n        \n        if (stat == MP_IMPORT_STAT_NO_EXIST) {\n            module_obj = mp_module_get_builtin(level_mod_name, true);\n            if (module_obj != MP_OBJ_NULL) {\n                return module_obj;\n            }\n        }\n    } else {\n        DEBUG_printf(\"Searching for sub-module\\n\");\n\n        #if MICROPY_MODULE_BUILTIN_SUBPACKAGES\n        \n        \n        \n        mp_obj_module_t *mod = MP_OBJ_TO_PTR(outer_module_obj);\n        if (mod->globals->map.is_fixed) {\n            elem = mp_map_lookup(&mod->globals->map, MP_OBJ_NEW_QSTR(level_mod_name), MP_MAP_LOOKUP);\n            \n            if (elem && mp_obj_is_type(elem->value, &mp_type_module)) {\n                return elem->value;\n            }\n        }\n        #endif\n\n        \n        \n        mp_obj_t dest[2];\n        mp_load_method_maybe(outer_module_obj, MP_QSTR___path__, dest);\n        if (dest[0] != MP_OBJ_NULL) {\n            \n            vstr_add_str(&path, mp_obj_str_get_str(dest[0]));\n\n            \n            vstr_add_char(&path, PATH_SEP_CHAR[0]);\n            vstr_add_str(&path, qstr_str(level_mod_name));\n\n            stat = stat_module(&path);\n        }\n    }\n\n    \n\n    if (stat == MP_IMPORT_STAT_NO_EXIST) {\n        \n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_msg(&mp_type_ImportError, MP_ERROR_TEXT(\"module not found\"));\n        #else\n        mp_raise_msg_varg(&mp_type_ImportError, MP_ERROR_TEXT(\"no module named '%q'\"), full_mod_name);\n        #endif\n    }\n\n    \n    DEBUG_printf(\"Found path to load: %.*s\\n\", (int)vstr_len(&path), vstr_str(&path));\n\n    \n    \n    \n    module_obj = mp_obj_new_module(full_mod_name);\n    nlr_jump_callback_node_unregister_module_t ctx;\n    ctx.name = full_mod_name;\n    nlr_push_jump_callback(&ctx.callback, unregister_module_from_nlr_jump_callback);\n\n    #if MICROPY_MODULE_OVERRIDE_MAIN_IMPORT\n    \n    \n    \n    \n    \n    \n    if (override_main && stat != MP_IMPORT_STAT_DIR) {\n        mp_obj_module_t *o = MP_OBJ_TO_PTR(module_obj);\n        mp_obj_dict_store(MP_OBJ_FROM_PTR(o->globals), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR___main__));\n        #if MICROPY_CPYTHON_COMPAT\n        \n        mp_obj_dict_store(MP_OBJ_FROM_PTR(&MP_STATE_VM(mp_loaded_modules_dict)), MP_OBJ_NEW_QSTR(MP_QSTR___main__), module_obj);\n        \n        \n        \n        mp_obj_dict_store(MP_OBJ_FROM_PTR(o->globals), MP_OBJ_NEW_QSTR(MP_QSTR___main__), MP_OBJ_NEW_QSTR(full_mod_name));\n        #endif\n    }\n    #endif \n\n    if (stat == MP_IMPORT_STAT_DIR) {\n        \n        DEBUG_printf(\"%.*s is dir\\n\", (int)vstr_len(&path), vstr_str(&path));\n\n        \n        \n        \n        \n        mp_store_attr(module_obj, MP_QSTR___path__, mp_obj_new_str(vstr_str(&path), vstr_len(&path)));\n        size_t orig_path_len = path.len;\n        vstr_add_str(&path, PATH_SEP_CHAR \"__init__.py\");\n\n        \n        if (stat_file_py_or_mpy(&path) == MP_IMPORT_STAT_FILE) {\n            do_load(MP_OBJ_TO_PTR(module_obj), &path);\n        } else {\n            \n            \n        }\n        \n        path.len = orig_path_len;\n    } else { \n        \n        do_load(MP_OBJ_TO_PTR(module_obj), &path);\n        \n        \n        \n        \n    }\n\n    if (outer_module_obj != MP_OBJ_NULL) {\n        \n        mp_store_attr(outer_module_obj, level_mod_name, module_obj);\n    }\n\n    nlr_pop_jump_callback(false);\n\n    return module_obj;\n}\n\nmp_obj_t mp_builtin___import___default(size_t n_args, const mp_obj_t *args) {\n    #if DEBUG_PRINT\n    DEBUG_printf(\"__import__:\\n\");\n    for (size_t i = 0; i < n_args; i++) {\n        DEBUG_printf(\"  \");\n        mp_obj_print_helper(MICROPY_DEBUG_PRINTER, args[i], PRINT_REPR);\n        DEBUG_printf(\"\\n\");\n    }\n    #endif\n\n    \n    \n    \n    \n    \n    mp_obj_t module_name_obj = args[0];\n\n    \n    \n    \n    mp_obj_t fromtuple = mp_const_none;\n\n    \n    \n    \n    mp_int_t level = 0;\n    if (n_args >= 4) {\n        fromtuple = args[3];\n        if (n_args >= 5) {\n            level = MP_OBJ_SMALL_INT_VALUE(args[4]);\n            if (level < 0) {\n                mp_raise_ValueError(NULL);\n            }\n        }\n    }\n\n    size_t module_name_len;\n    const char *module_name = mp_obj_str_get_data(module_name_obj, &module_name_len);\n\n    if (level != 0) {\n        \n        \n        evaluate_relative_import(level, &module_name, &module_name_len);\n        \n    }\n\n    if (module_name_len == 0) {\n        mp_raise_ValueError(NULL);\n    }\n\n    DEBUG_printf(\"Starting module search for '%s'\\n\", module_name);\n\n    mp_obj_t top_module_obj = MP_OBJ_NULL;\n    mp_obj_t outer_module_obj = MP_OBJ_NULL;\n\n    \n    \n    \n    size_t current_component_start = 0;\n    for (size_t i = 1; i <= module_name_len; i++) {\n        if (i == module_name_len || module_name[i] == '.') {\n            \n            qstr full_mod_name = qstr_from_strn(module_name, i);\n            \n            qstr level_mod_name = qstr_from_strn(module_name + current_component_start, i - current_component_start);\n\n            DEBUG_printf(\"Processing module: '%s' at level '%s'\\n\", qstr_str(full_mod_name), qstr_str(level_mod_name));\n\n            #if MICROPY_MODULE_OVERRIDE_MAIN_IMPORT\n            \n            \n            \n            bool override_main = (i == module_name_len && fromtuple == mp_const_false);\n            #else\n            bool override_main = false;\n            #endif\n\n            \n            mp_obj_t module_obj = process_import_at_level(full_mod_name, level_mod_name, outer_module_obj, override_main);\n\n            \n            outer_module_obj = module_obj;\n            if (top_module_obj == MP_OBJ_NULL) {\n                top_module_obj = module_obj;\n            }\n\n            current_component_start = i + 1;\n        }\n    }\n\n    if (fromtuple != mp_const_none) {\n        \n        return outer_module_obj;\n    } else {\n        \n        return top_module_obj;\n    }\n}\n\n#else \n\nmp_obj_t mp_builtin___import___default(size_t n_args, const mp_obj_t *args) {\n    \n    if (n_args >= 5 && MP_OBJ_SMALL_INT_VALUE(args[4]) != 0) {\n        mp_raise_NotImplementedError(MP_ERROR_TEXT(\"relative import\"));\n    }\n\n    \n    mp_map_elem_t *elem = mp_map_lookup(&MP_STATE_VM(mp_loaded_modules_dict).map, args[0], MP_MAP_LOOKUP);\n    if (elem) {\n        return elem->value;\n    }\n\n    \n    qstr module_name_qstr = mp_obj_str_get_qstr(args[0]);\n    mp_obj_t module_obj = mp_module_get_builtin(module_name_qstr, false);\n    if (module_obj != MP_OBJ_NULL) {\n        return module_obj;\n    }\n    \n    module_obj = mp_module_get_builtin(module_name_qstr, true);\n    if (module_obj != MP_OBJ_NULL) {\n        return module_obj;\n    }\n\n    \n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_msg(&mp_type_ImportError, MP_ERROR_TEXT(\"module not found\"));\n    #else\n    mp_raise_msg_varg(&mp_type_ImportError, MP_ERROR_TEXT(\"no module named '%q'\"), module_name_qstr);\n    #endif\n}\n\n#endif \n\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin___import___obj, 1, 5, mp_builtin___import__);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}