{
  "module_name": "mpprint.c",
  "hash_id": "f98b5fda0dc835d497177ad7f7c60182f0f1d9b6d877efb775fd87c6e677b671",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/mpprint.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/mphal.h\"\n#include \"py/mpprint.h\"\n#include \"py/obj.h\"\n#include \"py/objint.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#include \"py/formatfloat.h\"\n#endif\n\nstatic const char pad_spaces[] = \"                \";\nstatic const char pad_zeroes[] = \"0000000000000000\";\n\nstatic void plat_print_strn(void *env, const char *str, size_t len) {\n    (void)env;\n    MP_PLAT_PRINT_STRN(str, len);\n}\n\nconst mp_print_t mp_plat_print = {NULL, plat_print_strn};\n\nint mp_print_str(const mp_print_t *print, const char *str) {\n    size_t len = strlen(str);\n    if (len) {\n        print->print_strn(print->data, str, len);\n    }\n    return len;\n}\n\nint mp_print_strn(const mp_print_t *print, const char *str, size_t len, int flags, char fill, int width) {\n    int left_pad = 0;\n    int right_pad = 0;\n    int pad = width - len;\n    int pad_size;\n    int total_chars_printed = 0;\n    const char *pad_chars;\n\n    if (!fill || fill == ' ') {\n        pad_chars = pad_spaces;\n        pad_size = sizeof(pad_spaces) - 1;\n    } else if (fill == '0') {\n        pad_chars = pad_zeroes;\n        pad_size = sizeof(pad_zeroes) - 1;\n    } else {\n        \n        \n        pad_chars = &fill;\n        pad_size = 1;\n    }\n\n    if (flags & PF_FLAG_CENTER_ADJUST) {\n        left_pad = pad / 2;\n        right_pad = pad - left_pad;\n    } else if (flags & PF_FLAG_LEFT_ADJUST) {\n        right_pad = pad;\n    } else {\n        left_pad = pad;\n    }\n\n    if (left_pad > 0) {\n        total_chars_printed += left_pad;\n        while (left_pad > 0) {\n            int p = left_pad;\n            if (p > pad_size) {\n                p = pad_size;\n            }\n            print->print_strn(print->data, pad_chars, p);\n            left_pad -= p;\n        }\n    }\n    if (len) {\n        print->print_strn(print->data, str, len);\n        total_chars_printed += len;\n    }\n    if (right_pad > 0) {\n        total_chars_printed += right_pad;\n        while (right_pad > 0) {\n            int p = right_pad;\n            if (p > pad_size) {\n                p = pad_size;\n            }\n            print->print_strn(print->data, pad_chars, p);\n            right_pad -= p;\n        }\n    }\n    return total_chars_printed;\n}\n\n\n\n#define INT_BUF_SIZE (sizeof(mp_int_t) * 4)\n\n\n\n#define SUPPORT_INT_BASE_PREFIX (0)\n\n\n\nstatic int mp_print_int(const mp_print_t *print, mp_uint_t x, int sgn, int base, int base_char, int flags, char fill, int width) {\n    char sign = 0;\n    if (sgn) {\n        if ((mp_int_t)x < 0) {\n            sign = '-';\n            x = -x;\n        } else if (flags & PF_FLAG_SHOW_SIGN) {\n            sign = '+';\n        } else if (flags & PF_FLAG_SPACE_SIGN) {\n            sign = ' ';\n        }\n    }\n\n    char buf[INT_BUF_SIZE];\n    char *b = buf + INT_BUF_SIZE;\n\n    if (x == 0) {\n        *(--b) = '0';\n    } else {\n        do {\n            int c = x % base;\n            x /= base;\n            if (c >= 10) {\n                c += base_char - 10;\n            } else {\n                c += '0';\n            }\n            *(--b) = c;\n        } while (b > buf && x != 0);\n    }\n\n    #if SUPPORT_INT_BASE_PREFIX\n    char prefix_char = '\\0';\n\n    if (flags & PF_FLAG_SHOW_PREFIX) {\n        if (base == 2) {\n            prefix_char = base_char + 'b' - 'a';\n        } else if (base == 8) {\n            prefix_char = base_char + 'o' - 'a';\n        } else if (base == 16) {\n            prefix_char = base_char + 'x' - 'a';\n        }\n    }\n    #endif\n\n    int len = 0;\n    if (flags & PF_FLAG_PAD_AFTER_SIGN) {\n        if (sign) {\n            len += mp_print_strn(print, &sign, 1, flags, fill, 1);\n            width--;\n        }\n        #if SUPPORT_INT_BASE_PREFIX\n        if (prefix_char) {\n            len += mp_print_strn(print, \"0\", 1, flags, fill, 1);\n            len += mp_print_strn(print, &prefix_char, 1, flags, fill, 1);\n            width -= 2;\n        }\n        #endif\n    } else {\n        #if SUPPORT_INT_BASE_PREFIX\n        if (prefix_char && b > &buf[1]) {\n            *(--b) = prefix_char;\n            *(--b) = '0';\n        }\n        #endif\n        if (sign && b > buf) {\n            *(--b) = sign;\n        }\n    }\n\n    len += mp_print_strn(print, b, buf + INT_BUF_SIZE - b, flags, fill, width);\n    return len;\n}\n\nint mp_print_mp_int(const mp_print_t *print, mp_obj_t x, int base, int base_char, int flags, char fill, int width, int prec) {\n    \n    \n    \n    assert(base == 2 || base == 8 || base == 10 || base == 16);\n\n    if (!mp_obj_is_int(x)) {\n        \n        \n        x = MP_OBJ_NEW_SMALL_INT(mp_obj_get_int(x));\n    }\n\n    if ((flags & (PF_FLAG_LEFT_ADJUST | PF_FLAG_CENTER_ADJUST)) == 0 && fill == '0') {\n        if (prec > width) {\n            width = prec;\n        }\n        prec = 0;\n    }\n    char prefix_buf[4];\n    char *prefix = prefix_buf;\n\n    if (mp_obj_int_sign(x) >= 0) {\n        if (flags & PF_FLAG_SHOW_SIGN) {\n            *prefix++ = '+';\n        } else if (flags & PF_FLAG_SPACE_SIGN) {\n            *prefix++ = ' ';\n        }\n    }\n\n    if (flags & PF_FLAG_SHOW_PREFIX) {\n        if (base == 2) {\n            *prefix++ = '0';\n            *prefix++ = base_char + 'b' - 'a';\n        } else if (base == 8) {\n            *prefix++ = '0';\n            if (flags & PF_FLAG_SHOW_OCTAL_LETTER) {\n                *prefix++ = base_char + 'o' - 'a';\n            }\n        } else if (base == 16) {\n            *prefix++ = '0';\n            *prefix++ = base_char + 'x' - 'a';\n        }\n    }\n    *prefix = '\\0';\n    int prefix_len = prefix - prefix_buf;\n    prefix = prefix_buf;\n\n    char comma = '\\0';\n    if (flags & PF_FLAG_SHOW_COMMA) {\n        comma = ',';\n    }\n\n    \n    \n    char stack_buf[sizeof(mp_int_t) * 4];\n    char *buf = stack_buf;\n    size_t buf_size = sizeof(stack_buf);\n    size_t fmt_size = 0;\n    char *str;\n\n    if (prec > 1) {\n        flags |= PF_FLAG_PAD_AFTER_SIGN;\n    }\n    char sign = '\\0';\n    if (flags & PF_FLAG_PAD_AFTER_SIGN) {\n        \n        \n        str = mp_obj_int_formatted(&buf, &buf_size, &fmt_size,\n            x, base, NULL, base_char, comma);\n        if (*str == '-') {\n            sign = *str++;\n            fmt_size--;\n        }\n    } else {\n        str = mp_obj_int_formatted(&buf, &buf_size, &fmt_size,\n            x, base, prefix, base_char, comma);\n    }\n\n    int spaces_before = 0;\n    int spaces_after = 0;\n\n    if (prec > 1) {\n        \n        \n        \n\n        int prec_width = fmt_size;  \n        if (prec_width < prec) {\n            prec_width = prec;\n        }\n        if (flags & PF_FLAG_PAD_AFTER_SIGN) {\n            if (sign) {\n                prec_width++;\n            }\n            prec_width += prefix_len;\n        }\n        if (prec_width < width) {\n            if (flags & PF_FLAG_LEFT_ADJUST) {\n                spaces_after = width - prec_width;\n            } else {\n                spaces_before = width - prec_width;\n            }\n        }\n        fill = '0';\n        flags &= ~PF_FLAG_LEFT_ADJUST;\n    }\n\n    int len = 0;\n    if (spaces_before) {\n        len += mp_print_strn(print, \"\", 0, 0, ' ', spaces_before);\n    }\n    if (flags & PF_FLAG_PAD_AFTER_SIGN) {\n        \n        if (sign) {\n            len += mp_print_strn(print, &sign, 1, 0, 0, 1);\n            width--;\n        }\n        if (prefix_len) {\n            len += mp_print_strn(print, prefix, prefix_len, 0, 0, 1);\n            width -= prefix_len;\n        }\n    }\n    if (prec > 1) {\n        width = prec;\n    }\n\n    len += mp_print_strn(print, str, fmt_size, flags, fill, width);\n\n    if (spaces_after) {\n        len += mp_print_strn(print, \"\", 0, 0, ' ', spaces_after);\n    }\n\n    if (buf != stack_buf) {\n        m_del(char, buf, buf_size);\n    }\n    return len;\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nint mp_print_float(const mp_print_t *print, mp_float_t f, char fmt, int flags, char fill, int width, int prec) {\n    char buf[32];\n    char sign = '\\0';\n    int chrs = 0;\n\n    if (flags & PF_FLAG_SHOW_SIGN) {\n        sign = '+';\n    } else\n    if (flags & PF_FLAG_SPACE_SIGN) {\n        sign = ' ';\n    }\n\n    int len = mp_format_float(f, buf, sizeof(buf), fmt, prec, sign);\n\n    char *s = buf;\n\n    if ((flags & PF_FLAG_ADD_PERCENT) && (size_t)(len + 1) < sizeof(buf)) {\n        buf[len++] = '%';\n        buf[len] = '\\0';\n    }\n\n    \n    if ((flags & PF_FLAG_PAD_AFTER_SIGN) && buf[0] < '0') {\n        \n        s++;\n        chrs += mp_print_strn(print, &buf[0], 1, 0, 0, 1);\n        width--;\n        len--;\n    }\n\n    chrs += mp_print_strn(print, s, len, flags, fill, width);\n\n    return chrs;\n}\n#endif\n\nint mp_printf(const mp_print_t *print, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    int ret = mp_vprintf(print, fmt, ap);\n    va_end(ap);\n    return ret;\n}\n\nint mp_vprintf(const mp_print_t *print, const char *fmt, va_list args) {\n    int chrs = 0;\n    for (;;) {\n        {\n            const char *f = fmt;\n            while (*f != '\\0' && *f != '%') {\n                ++f; \n            }\n            if (f > fmt) {\n                print->print_strn(print->data, fmt, f - fmt);\n                chrs += f - fmt;\n                fmt = f;\n            }\n        }\n\n        if (*fmt == '\\0') {\n            break;\n        }\n\n        \n        ++fmt;\n\n        \n        int flags = 0;\n        char fill = ' ';\n        while (*fmt != '\\0') {\n            if (*fmt == '-') {\n                flags |= PF_FLAG_LEFT_ADJUST;\n            } else if (*fmt == '+') {\n                flags |= PF_FLAG_SHOW_SIGN;\n            } else if (*fmt == ' ') {\n                flags |= PF_FLAG_SPACE_SIGN;\n            } else if (*fmt == '!') {\n                flags |= PF_FLAG_NO_TRAILZ;\n            } else if (*fmt == '0') {\n                flags |= PF_FLAG_PAD_AFTER_SIGN;\n                fill = '0';\n            } else {\n                break;\n            }\n            ++fmt;\n        }\n\n        \n        int width = 0;\n        for (; '0' <= *fmt && *fmt <= '9'; ++fmt) {\n            width = width * 10 + *fmt - '0';\n        }\n\n        \n        int prec = -1;\n        if (*fmt == '.') {\n            ++fmt;\n            if (*fmt == '*') {\n                ++fmt;\n                prec = va_arg(args, int);\n            } else {\n                prec = 0;\n                for (; '0' <= *fmt && *fmt <= '9'; ++fmt) {\n                    prec = prec * 10 + *fmt - '0';\n                }\n            }\n            if (prec < 0) {\n                prec = 0;\n            }\n        }\n\n        \n        #ifndef __LP64__\n        const\n        #endif\n        bool long_arg = false;\n        if (*fmt == 'l') {\n            ++fmt;\n            #ifdef __LP64__\n            long_arg = true;\n            #endif\n        }\n\n        if (*fmt == '\\0') {\n            break;\n        }\n\n        switch (*fmt) {\n            case 'b':\n                if (va_arg(args, int)) {\n                    chrs += mp_print_strn(print, \"true\", 4, flags, fill, width);\n                } else {\n                    chrs += mp_print_strn(print, \"false\", 5, flags, fill, width);\n                }\n                break;\n            case 'c': {\n                char str = va_arg(args, int);\n                chrs += mp_print_strn(print, &str, 1, flags, fill, width);\n                break;\n            }\n            case 'q': {\n                qstr qst = va_arg(args, qstr);\n                size_t len;\n                const char *str = (const char *)qstr_data(qst, &len);\n                if (prec >= 0 && (size_t)prec < len) {\n                    len = prec;\n                }\n                chrs += mp_print_strn(print, str, len, flags, fill, width);\n                break;\n            }\n            case 's': {\n                const char *str = va_arg(args, const char *);\n                #ifndef NDEBUG\n                \n                if (prec != 0 && str == NULL) {\n                    chrs += mp_print_strn(print, \"(null)\", 6, flags, fill, width);\n                    break;\n                }\n                #endif\n                size_t len = strlen(str);\n                if (prec >= 0 && (size_t)prec < len) {\n                    len = prec;\n                }\n                chrs += mp_print_strn(print, str, len, flags, fill, width);\n                break;\n            }\n            case 'd': {\n                mp_int_t val;\n                if (long_arg) {\n                    val = va_arg(args, long int);\n                } else {\n                    val = va_arg(args, int);\n                }\n                chrs += mp_print_int(print, val, 1, 10, 'a', flags, fill, width);\n                break;\n            }\n            case 'u':\n            case 'x':\n            case 'X': {\n                int base = 16 - ((*fmt + 1) & 6); \n                char fmt_c = (*fmt & 0xf0) - 'P' + 'A'; \n                mp_uint_t val;\n                if (long_arg) {\n                    val = va_arg(args, unsigned long int);\n                } else {\n                    val = va_arg(args, unsigned int);\n                }\n                chrs += mp_print_int(print, val, 0, base, fmt_c, flags, fill, width);\n                break;\n            }\n            case 'p':\n            case 'P': \n                \n                chrs += mp_print_int(print, va_arg(args, unsigned long int), 0, 16, 'a', flags, fill, width);\n                break;\n            #if MICROPY_PY_BUILTINS_FLOAT\n            case 'e':\n            case 'E':\n            case 'f':\n            case 'F':\n            case 'g':\n            case 'G': {\n                #if ((MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT) || (MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE))\n                mp_float_t f = (mp_float_t)va_arg(args, double);\n                chrs += mp_print_float(print, f, *fmt, flags, fill, width, prec);\n                #else\n                #error Unknown MICROPY FLOAT IMPL\n                #endif\n                break;\n            }\n            #endif\n                \n                \n                \n            #if (MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D) || defined(_WIN64)\n            case 'l': {\n                unsigned long long int arg_value = va_arg(args, unsigned long long int);\n                ++fmt;\n                assert(*fmt == 'u' || *fmt == 'd' || !\"unsupported fmt char\");\n                chrs += mp_print_int(print, arg_value, *fmt == 'd', 10, 'a', flags, fill, width);\n                break;\n            }\n            #endif\n            default:\n                \n                assert(*fmt == '%' || !\"unsupported fmt char\");\n                print->print_strn(print->data, fmt, 1);\n                chrs += 1;\n                break;\n        }\n        ++fmt;\n    }\n    return chrs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}