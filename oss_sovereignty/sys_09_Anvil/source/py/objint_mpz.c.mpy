{
  "module_name": "objint_mpz.c",
  "hash_id": "ca9162a1c49130257584054a2f431c1b185cf078238038105659635303f254b5",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objint_mpz.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n\n#include \"py/parsenumbase.h\"\n#include \"py/smallint.h\"\n#include \"py/objint.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#include <math.h>\n#endif\n\n#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ\n\n#if MICROPY_PY_SYS_MAXSIZE\n\n\n#define DIG_MASK ((MPZ_LONG_1 << MPZ_DIG_SIZE) - 1)\nstatic const mpz_dig_t maxsize_dig[] = {\n    #define NUM_DIG 1\n    (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 0) & DIG_MASK,\n    #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 0) > DIG_MASK\n     #undef NUM_DIG\n     #define NUM_DIG 2\n     (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 1) & DIG_MASK,\n     #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 1) > DIG_MASK\n      #undef NUM_DIG\n      #define NUM_DIG 3\n      (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 2) & DIG_MASK,\n      #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 2) > DIG_MASK\n       #undef NUM_DIG\n       #define NUM_DIG 4\n       (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 3) & DIG_MASK,\n       #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 3) > DIG_MASK\n        #error cannot encode MP_SSIZE_MAX as mpz\n       #endif\n      #endif\n     #endif\n    #endif\n};\n\nconst mp_obj_int_t mp_sys_maxsize_obj = {\n    {&mp_type_int},\n    {.fixed_dig = 1, .len = NUM_DIG, .alloc = NUM_DIG, .dig = (mpz_dig_t *)maxsize_dig}\n};\n#undef DIG_MASK\n#undef NUM_DIG\n#endif\n\nmp_obj_int_t *mp_obj_int_new_mpz(void) {\n    mp_obj_int_t *o = mp_obj_malloc(mp_obj_int_t, &mp_type_int);\n    mpz_init_zero(&o->mpz);\n    return o;\n}\n\n\n\n\n\n\n\n\n\n\nchar *mp_obj_int_formatted_impl(char **buf, size_t *buf_size, size_t *fmt_size, mp_const_obj_t self_in,\n    int base, const char *prefix, char base_char, char comma) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n\n    size_t needed_size = mp_int_format_size(mpz_max_num_bits(&self->mpz), base, prefix, comma);\n    if (needed_size > *buf_size) {\n        *buf = m_new(char, needed_size);\n        *buf_size = needed_size;\n    }\n    char *str = *buf;\n\n    *fmt_size = mpz_as_str_inpl(&self->mpz, base, prefix, base_char, comma, str);\n\n    return str;\n}\n\nmp_obj_t mp_obj_int_from_bytes_impl(bool big_endian, size_t len, const byte *buf) {\n    mp_obj_int_t *o = mp_obj_int_new_mpz();\n    mpz_set_from_bytes(&o->mpz, big_endian, len, buf);\n    return MP_OBJ_FROM_PTR(o);\n}\n\nvoid mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    mpz_as_bytes(&self->mpz, big_endian, len, buf);\n}\n\nint mp_obj_int_sign(mp_obj_t self_in) {\n    if (mp_obj_is_small_int(self_in)) {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(self_in);\n        if (val < 0) {\n            return -1;\n        } else if (val > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->mpz.len == 0) {\n        return 0;\n    } else if (self->mpz.neg == 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nmp_obj_t mp_obj_int_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    mp_obj_int_t *o = MP_OBJ_TO_PTR(o_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(!mpz_is_zero(&o->mpz));\n        case MP_UNARY_OP_HASH:\n            return MP_OBJ_NEW_SMALL_INT(mpz_hash(&o->mpz));\n        case MP_UNARY_OP_POSITIVE:\n            return o_in;\n        case MP_UNARY_OP_NEGATIVE: { mp_obj_int_t *o2 = mp_obj_int_new_mpz();\n                                     mpz_neg_inpl(&o2->mpz, &o->mpz);\n                                     return MP_OBJ_FROM_PTR(o2);\n        }\n        case MP_UNARY_OP_INVERT: { mp_obj_int_t *o2 = mp_obj_int_new_mpz();\n                                   mpz_not_inpl(&o2->mpz, &o->mpz);\n                                   return MP_OBJ_FROM_PTR(o2);\n        }\n        case MP_UNARY_OP_ABS: {\n            mp_obj_int_t *self = MP_OBJ_TO_PTR(o_in);\n            if (self->mpz.neg == 0) {\n                return o_in;\n            }\n            mp_obj_int_t *self2 = mp_obj_int_new_mpz();\n            mpz_abs_inpl(&self2->mpz, &self->mpz);\n            return MP_OBJ_FROM_PTR(self2);\n        }\n        case MP_UNARY_OP_INT_MAYBE:\n            return o_in;\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nmp_obj_t mp_obj_int_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    const mpz_t *zlhs;\n    const mpz_t *zrhs;\n    mpz_t z_int;\n    mpz_dig_t z_int_dig[MPZ_NUM_DIG_FOR_INT];\n\n    \n    if (mp_obj_is_small_int(lhs_in)) {\n        mpz_init_fixed_from_int(&z_int, z_int_dig, MPZ_NUM_DIG_FOR_INT, MP_OBJ_SMALL_INT_VALUE(lhs_in));\n        zlhs = &z_int;\n    } else {\n        assert(mp_obj_is_exact_type(lhs_in, &mp_type_int));\n        zlhs = &((mp_obj_int_t *)MP_OBJ_TO_PTR(lhs_in))->mpz;\n    }\n\n    \n    if (mp_obj_is_small_int(rhs_in)) {\n        mpz_init_fixed_from_int(&z_int, z_int_dig, MPZ_NUM_DIG_FOR_INT, MP_OBJ_SMALL_INT_VALUE(rhs_in));\n        zrhs = &z_int;\n    } else if (mp_obj_is_exact_type(rhs_in, &mp_type_int)) {\n        zrhs = &((mp_obj_int_t *)MP_OBJ_TO_PTR(rhs_in))->mpz;\n    #if MICROPY_PY_BUILTINS_FLOAT\n    } else if (mp_obj_is_float(rhs_in)) {\n        return mp_obj_float_binary_op(op, mpz_as_float(zlhs), rhs_in);\n    #endif\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    } else if (mp_obj_is_type(rhs_in, &mp_type_complex)) {\n        return mp_obj_complex_binary_op(op, mpz_as_float(zlhs), 0, rhs_in);\n    #endif\n    } else {\n        \n        return mp_obj_int_binary_op_extra_cases(op, lhs_in, rhs_in);\n    }\n\n    #if MICROPY_PY_BUILTINS_FLOAT\n    if (op == MP_BINARY_OP_TRUE_DIVIDE || op == MP_BINARY_OP_INPLACE_TRUE_DIVIDE) {\n        if (mpz_is_zero(zrhs)) {\n            goto zero_division_error;\n        }\n        mp_float_t flhs = mpz_as_float(zlhs);\n        mp_float_t frhs = mpz_as_float(zrhs);\n        return mp_obj_new_float(flhs / frhs);\n    }\n    #endif\n\n    if (op >= MP_BINARY_OP_INPLACE_OR && op < MP_BINARY_OP_CONTAINS) {\n        mp_obj_int_t *res = mp_obj_int_new_mpz();\n\n        switch (op) {\n            case MP_BINARY_OP_ADD:\n            case MP_BINARY_OP_INPLACE_ADD:\n                mpz_add_inpl(&res->mpz, zlhs, zrhs);\n                break;\n            case MP_BINARY_OP_SUBTRACT:\n            case MP_BINARY_OP_INPLACE_SUBTRACT:\n                mpz_sub_inpl(&res->mpz, zlhs, zrhs);\n                break;\n            case MP_BINARY_OP_MULTIPLY:\n            case MP_BINARY_OP_INPLACE_MULTIPLY:\n                mpz_mul_inpl(&res->mpz, zlhs, zrhs);\n                break;\n            case MP_BINARY_OP_FLOOR_DIVIDE:\n            case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE: {\n                if (mpz_is_zero(zrhs)) {\n                zero_division_error:\n                    mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"divide by zero\"));\n                }\n                mpz_t rem;\n                mpz_init_zero(&rem);\n                mpz_divmod_inpl(&res->mpz, &rem, zlhs, zrhs);\n                mpz_deinit(&rem);\n                break;\n            }\n            case MP_BINARY_OP_MODULO:\n            case MP_BINARY_OP_INPLACE_MODULO: {\n                if (mpz_is_zero(zrhs)) {\n                    goto zero_division_error;\n                }\n                mpz_t quo;\n                mpz_init_zero(&quo);\n                mpz_divmod_inpl(&quo, &res->mpz, zlhs, zrhs);\n                mpz_deinit(&quo);\n                break;\n            }\n\n            case MP_BINARY_OP_AND:\n            case MP_BINARY_OP_INPLACE_AND:\n                mpz_and_inpl(&res->mpz, zlhs, zrhs);\n                break;\n            case MP_BINARY_OP_OR:\n            case MP_BINARY_OP_INPLACE_OR:\n                mpz_or_inpl(&res->mpz, zlhs, zrhs);\n                break;\n            case MP_BINARY_OP_XOR:\n            case MP_BINARY_OP_INPLACE_XOR:\n                mpz_xor_inpl(&res->mpz, zlhs, zrhs);\n                break;\n\n            case MP_BINARY_OP_LSHIFT:\n            case MP_BINARY_OP_INPLACE_LSHIFT:\n            case MP_BINARY_OP_RSHIFT:\n            case MP_BINARY_OP_INPLACE_RSHIFT: {\n                mp_int_t irhs = mp_obj_int_get_checked(rhs_in);\n                if (irhs < 0) {\n                    mp_raise_ValueError(MP_ERROR_TEXT(\"negative shift count\"));\n                }\n                if (op == MP_BINARY_OP_LSHIFT || op == MP_BINARY_OP_INPLACE_LSHIFT) {\n                    mpz_shl_inpl(&res->mpz, zlhs, irhs);\n                } else {\n                    mpz_shr_inpl(&res->mpz, zlhs, irhs);\n                }\n                break;\n            }\n\n            case MP_BINARY_OP_POWER:\n            case MP_BINARY_OP_INPLACE_POWER:\n                if (mpz_is_neg(zrhs)) {\n                    #if MICROPY_PY_BUILTINS_FLOAT\n                    return mp_obj_float_binary_op(op, mpz_as_float(zlhs), rhs_in);\n                    #else\n                    mp_raise_ValueError(MP_ERROR_TEXT(\"negative power with no float support\"));\n                    #endif\n                }\n                mpz_pow_inpl(&res->mpz, zlhs, zrhs);\n                break;\n\n            case MP_BINARY_OP_DIVMOD: {\n                if (mpz_is_zero(zrhs)) {\n                    goto zero_division_error;\n                }\n                mp_obj_int_t *quo = mp_obj_int_new_mpz();\n                mpz_divmod_inpl(&quo->mpz, &res->mpz, zlhs, zrhs);\n                mp_obj_t tuple[2] = {MP_OBJ_FROM_PTR(quo), MP_OBJ_FROM_PTR(res)};\n                return mp_obj_new_tuple(2, tuple);\n            }\n\n            default:\n                return MP_OBJ_NULL; \n        }\n\n        return MP_OBJ_FROM_PTR(res);\n\n    } else {\n        int cmp = mpz_cmp(zlhs, zrhs);\n        switch (op) {\n            case MP_BINARY_OP_LESS:\n                return mp_obj_new_bool(cmp < 0);\n            case MP_BINARY_OP_MORE:\n                return mp_obj_new_bool(cmp > 0);\n            case MP_BINARY_OP_LESS_EQUAL:\n                return mp_obj_new_bool(cmp <= 0);\n            case MP_BINARY_OP_MORE_EQUAL:\n                return mp_obj_new_bool(cmp >= 0);\n            case MP_BINARY_OP_EQUAL:\n                return mp_obj_new_bool(cmp == 0);\n\n            default:\n                return MP_OBJ_NULL; \n        }\n    }\n}\n\n#if MICROPY_PY_BUILTINS_POW3\nstatic mpz_t *mp_mpz_for_int(mp_obj_t arg, mpz_t *temp) {\n    if (mp_obj_is_small_int(arg)) {\n        mpz_init_from_int(temp, MP_OBJ_SMALL_INT_VALUE(arg));\n        return temp;\n    } else {\n        mp_obj_int_t *arp_p = MP_OBJ_TO_PTR(arg);\n        return &(arp_p->mpz);\n    }\n}\n\nmp_obj_t mp_obj_int_pow3(mp_obj_t base, mp_obj_t exponent,  mp_obj_t modulus) {\n    if (!mp_obj_is_int(base) || !mp_obj_is_int(exponent) || !mp_obj_is_int(modulus)) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"pow() with 3 arguments requires integers\"));\n    } else {\n        mp_obj_t result = mp_obj_new_int_from_ull(0); \n        mp_obj_int_t *res_p = (mp_obj_int_t *)MP_OBJ_TO_PTR(result);\n\n        mpz_t l_temp, r_temp, m_temp;\n        mpz_t *lhs = mp_mpz_for_int(base,     &l_temp);\n        mpz_t *rhs = mp_mpz_for_int(exponent, &r_temp);\n        mpz_t *mod = mp_mpz_for_int(modulus,  &m_temp);\n\n        mpz_pow3_inpl(&(res_p->mpz), lhs, rhs, mod);\n\n        if (lhs == &l_temp) {\n            mpz_deinit(lhs);\n        }\n        if (rhs == &r_temp) {\n            mpz_deinit(rhs);\n        }\n        if (mod == &m_temp) {\n            mpz_deinit(mod);\n        }\n        return result;\n    }\n}\n#endif\n\nmp_obj_t mp_obj_new_int(mp_int_t value) {\n    if (MP_SMALL_INT_FITS(value)) {\n        return MP_OBJ_NEW_SMALL_INT(value);\n    }\n    return mp_obj_new_int_from_ll(value);\n}\n\nmp_obj_t mp_obj_new_int_from_ll(long long val) {\n    mp_obj_int_t *o = mp_obj_int_new_mpz();\n    mpz_set_from_ll(&o->mpz, val, true);\n    return MP_OBJ_FROM_PTR(o);\n}\n\nmp_obj_t mp_obj_new_int_from_ull(unsigned long long val) {\n    mp_obj_int_t *o = mp_obj_int_new_mpz();\n    mpz_set_from_ll(&o->mpz, val, false);\n    return MP_OBJ_FROM_PTR(o);\n}\n\nmp_obj_t mp_obj_new_int_from_uint(mp_uint_t value) {\n    \n    \n    if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {\n        return MP_OBJ_NEW_SMALL_INT(value);\n    }\n    return mp_obj_new_int_from_ull(value);\n}\n\nmp_obj_t mp_obj_new_int_from_str_len(const char **str, size_t len, bool neg, unsigned int base) {\n    mp_obj_int_t *o = mp_obj_int_new_mpz();\n    size_t n = mpz_set_from_str(&o->mpz, *str, len, neg, base);\n    *str += n;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nmp_int_t mp_obj_int_get_truncated(mp_const_obj_t self_in) {\n    if (mp_obj_is_small_int(self_in)) {\n        return MP_OBJ_SMALL_INT_VALUE(self_in);\n    } else {\n        const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n        \n        return mpz_hash(&self->mpz);\n    }\n}\n\nmp_int_t mp_obj_int_get_checked(mp_const_obj_t self_in) {\n    if (mp_obj_is_small_int(self_in)) {\n        return MP_OBJ_SMALL_INT_VALUE(self_in);\n    } else {\n        const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n        mp_int_t value;\n        if (mpz_as_int_checked(&self->mpz, &value)) {\n            return value;\n        } else {\n            \n            mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"overflow converting long int to machine word\"));\n        }\n    }\n}\n\nmp_uint_t mp_obj_int_get_uint_checked(mp_const_obj_t self_in) {\n    if (mp_obj_is_small_int(self_in)) {\n        if (MP_OBJ_SMALL_INT_VALUE(self_in) >= 0) {\n            return MP_OBJ_SMALL_INT_VALUE(self_in);\n        }\n    } else {\n        const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n        mp_uint_t value;\n        if (mpz_as_uint_checked(&self->mpz, &value)) {\n            return value;\n        }\n    }\n\n    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"overflow converting long int to machine word\"));\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nmp_float_t mp_obj_int_as_float_impl(mp_obj_t self_in) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    return mpz_as_float(&self->mpz);\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}