{
  "module_name": "objnamedtuple.c",
  "hash_id": "5573909868c0f01b7ec9c5d5b4deb040f220ff1b2dea6fb6df598c075e6a2278",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objnamedtuple.c",
  "human_readable_source": " \n\n#include <string.h>\n\n#include \"py/objtuple.h\"\n#include \"py/runtime.h\"\n#include \"py/objstr.h\"\n#include \"py/objnamedtuple.h\"\n\n#if MICROPY_PY_COLLECTIONS\n\nsize_t mp_obj_namedtuple_find_field(const mp_obj_namedtuple_type_t *type, qstr name) {\n    for (size_t i = 0; i < type->n_fields; i++) {\n        if (type->fields[i] == name) {\n            return i;\n        }\n    }\n    return (size_t)-1;\n}\n\n#if MICROPY_PY_COLLECTIONS_NAMEDTUPLE__ASDICT\nstatic mp_obj_t namedtuple_asdict(mp_obj_t self_in) {\n    mp_obj_namedtuple_t *self = MP_OBJ_TO_PTR(self_in);\n    const qstr *fields = ((mp_obj_namedtuple_type_t *)self->tuple.base.type)->fields;\n    mp_obj_t dict = mp_obj_new_dict(self->tuple.len);\n    \n    mp_obj_dict_t *dictObj = MP_OBJ_TO_PTR(dict);\n    dictObj->base.type = &mp_type_ordereddict;\n    dictObj->map.is_ordered = 1;\n    for (size_t i = 0; i < self->tuple.len; ++i) {\n        mp_obj_dict_store(dict, MP_OBJ_NEW_QSTR(fields[i]), self->tuple.items[i]);\n    }\n    return dict;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(namedtuple_asdict_obj, namedtuple_asdict);\n#endif\n\nstatic void namedtuple_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_namedtuple_t *o = MP_OBJ_TO_PTR(o_in);\n    mp_printf(print, \"%q\", o->tuple.base.type->name);\n    const qstr *fields = ((mp_obj_namedtuple_type_t *)o->tuple.base.type)->fields;\n    mp_obj_attrtuple_print_helper(print, fields, &o->tuple);\n}\n\nstatic void namedtuple_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        mp_obj_namedtuple_t *self = MP_OBJ_TO_PTR(self_in);\n        #if MICROPY_PY_COLLECTIONS_NAMEDTUPLE__ASDICT\n        if (attr == MP_QSTR__asdict) {\n            dest[0] = MP_OBJ_FROM_PTR(&namedtuple_asdict_obj);\n            dest[1] = self_in;\n            return;\n        }\n        #endif\n        size_t id = mp_obj_namedtuple_find_field((mp_obj_namedtuple_type_t *)self->tuple.base.type, attr);\n        if (id == (size_t)-1) {\n            return;\n        }\n        dest[0] = self->tuple.items[id];\n    } else {\n        \n        \n        mp_raise_msg(&mp_type_AttributeError, MP_ERROR_TEXT(\"can't set attribute\"));\n    }\n}\n\nstatic mp_obj_t namedtuple_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    const mp_obj_namedtuple_type_t *type = (const mp_obj_namedtuple_type_t *)type_in;\n    size_t num_fields = type->n_fields;\n    if (n_args + n_kw != num_fields) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_arg_error_terse_mismatch();\n        #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"function takes %d positional arguments but %d were given\"),\n            num_fields, n_args + n_kw);\n        #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"%q() takes %d positional arguments but %d were given\"),\n            ((mp_obj_type_t *)&type->base)->name, num_fields, n_args + n_kw);\n        #endif\n    }\n\n    \n    \n    mp_obj_tuple_t *tuple = mp_obj_malloc_var(mp_obj_tuple_t, items, mp_obj_t, num_fields, type_in);\n    tuple->len = num_fields;\n\n    \n    memcpy(&tuple->items[0], args, sizeof(mp_obj_t) * n_args);\n\n    \n    memset(&tuple->items[n_args], 0, sizeof(mp_obj_t) * n_kw);\n    for (size_t i = n_args; i < n_args + 2 * n_kw; i += 2) {\n        qstr kw = mp_obj_str_get_qstr(args[i]);\n        size_t id = mp_obj_namedtuple_find_field(type, kw);\n        if (id == (size_t)-1) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_arg_error_terse_mismatch();\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError, MP_ERROR_TEXT(\"unexpected keyword argument '%q'\"), kw);\n            #endif\n        }\n        if (tuple->items[id] != MP_OBJ_NULL) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_arg_error_terse_mismatch();\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"function got multiple values for argument '%q'\"), kw);\n            #endif\n        }\n        tuple->items[id] = args[i + 1];\n    }\n\n    return MP_OBJ_FROM_PTR(tuple);\n}\n\nmp_obj_namedtuple_type_t *mp_obj_new_namedtuple_base(size_t n_fields, mp_obj_t *fields) {\n    mp_obj_namedtuple_type_t *o = m_new_obj_var0(mp_obj_namedtuple_type_t, fields, qstr, n_fields);\n    o->n_fields = n_fields;\n    for (size_t i = 0; i < n_fields; i++) {\n        o->fields[i] = mp_obj_str_get_qstr(fields[i]);\n    }\n    return o;\n}\n\nstatic mp_obj_t mp_obj_new_namedtuple_type(qstr name, size_t n_fields, mp_obj_t *fields) {\n    mp_obj_namedtuple_type_t *o = mp_obj_new_namedtuple_base(n_fields, fields);\n    mp_obj_type_t *type = (mp_obj_type_t *)&o->base;\n    type->base.type = &mp_type_type;\n    type->flags = MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE; \n    type->name = name;\n    MP_OBJ_TYPE_SET_SLOT(type, make_new, namedtuple_make_new, 0);\n    MP_OBJ_TYPE_SET_SLOT(type, print, namedtuple_print, 1);\n    MP_OBJ_TYPE_SET_SLOT(type, unary_op, mp_obj_tuple_unary_op, 2);\n    MP_OBJ_TYPE_SET_SLOT(type, binary_op, mp_obj_tuple_binary_op, 3);\n    MP_OBJ_TYPE_SET_SLOT(type, attr, namedtuple_attr, 4);\n    MP_OBJ_TYPE_SET_SLOT(type, subscr, mp_obj_tuple_subscr, 5);\n    MP_OBJ_TYPE_SET_SLOT(type, iter, mp_obj_tuple_getiter, 6);\n    MP_OBJ_TYPE_SET_SLOT(type, parent, &mp_type_tuple, 7);\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_obj_t new_namedtuple_type(mp_obj_t name_in, mp_obj_t fields_in) {\n    qstr name = mp_obj_str_get_qstr(name_in);\n    size_t n_fields;\n    mp_obj_t *fields;\n    #if MICROPY_CPYTHON_COMPAT\n    if (mp_obj_is_str(fields_in)) {\n        fields_in = mp_obj_str_split(1, &fields_in);\n    }\n    #endif\n    mp_obj_get_array(fields_in, &n_fields, &fields);\n    return mp_obj_new_namedtuple_type(name, n_fields, fields);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_namedtuple_obj, new_namedtuple_type);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}