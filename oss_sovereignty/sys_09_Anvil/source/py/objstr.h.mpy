{
  "module_name": "objstr.h",
  "hash_id": "f940bd4c07fcaff6b0fdb0668ba63af72ef36fb6c08e91ee304ca028a55bd795",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objstr.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_OBJSTR_H\n#define MICROPY_INCLUDED_PY_OBJSTR_H\n\n#include \"py/obj.h\"\n#include \"py/objarray.h\"\n\ntypedef struct _mp_obj_str_t {\n    mp_obj_base_t base;\n    size_t hash;\n    \n    size_t len;\n    const byte *data;\n} mp_obj_str_t;\n\n\n\n\n#define MP_STATIC_ASSERT_STR_ARRAY_COMPATIBLE \\\n    MP_STATIC_ASSERT(offsetof(mp_obj_str_t, len) == offsetof(mp_obj_array_t, len) \\\n    && offsetof(mp_obj_str_t, data) == offsetof(mp_obj_array_t, items))\n\n#define MP_DEFINE_STR_OBJ(obj_name, str) mp_obj_str_t obj_name = {{&mp_type_str}, 0, sizeof(str) - 1, (const byte *)str}\n\n\n\n#define GET_STR_HASH(str_obj_in, str_hash) \\\n    size_t str_hash; \\\n    if (mp_obj_is_qstr(str_obj_in)) { \\\n        str_hash = qstr_hash(MP_OBJ_QSTR_VALUE(str_obj_in)); \\\n    } else { \\\n        str_hash = ((mp_obj_str_t *)MP_OBJ_TO_PTR(str_obj_in))->hash; \\\n    }\n\n\n#define GET_STR_LEN(str_obj_in, str_len) \\\n    size_t str_len; \\\n    if (mp_obj_is_qstr(str_obj_in)) { \\\n        str_len = qstr_len(MP_OBJ_QSTR_VALUE(str_obj_in)); \\\n    } else { \\\n        str_len = ((mp_obj_str_t *)MP_OBJ_TO_PTR(str_obj_in))->len; \\\n    }\n\n\n#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\nconst byte *mp_obj_str_get_data_no_check(mp_obj_t self_in, size_t *len);\n#define GET_STR_DATA_LEN(str_obj_in, str_data, str_len) \\\n    size_t str_len; \\\n    const byte *str_data = mp_obj_str_get_data_no_check(str_obj_in, &str_len);\n#else\n#define GET_STR_DATA_LEN(str_obj_in, str_data, str_len) \\\n    const byte *str_data; \\\n    size_t str_len; \\\n    if (mp_obj_is_qstr(str_obj_in)) { \\\n        str_data = qstr_data(MP_OBJ_QSTR_VALUE(str_obj_in), &str_len); \\\n    } else { \\\n        MP_STATIC_ASSERT_STR_ARRAY_COMPATIBLE; \\\n        str_len = ((mp_obj_str_t *)MP_OBJ_TO_PTR(str_obj_in))->len; \\\n        str_data = ((mp_obj_str_t *)MP_OBJ_TO_PTR(str_obj_in))->data; \\\n    }\n#endif\n\nmp_obj_t mp_obj_str_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args);\nvoid mp_str_print_json(const mp_print_t *print, const byte *str_data, size_t str_len);\nmp_obj_t mp_obj_str_format(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs);\nmp_obj_t mp_obj_str_split(size_t n_args, const mp_obj_t *args);\nmp_obj_t mp_obj_new_str_copy(const mp_obj_type_t *type, const byte *data, size_t len); \nmp_obj_t mp_obj_new_str_of_type(const mp_obj_type_t *type, const byte *data, size_t len); \n\nmp_obj_t mp_obj_str_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in);\nmp_int_t mp_obj_str_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);\n\nvoid mp_obj_str_set_data(mp_obj_str_t *str, const byte *data, size_t len);\n\nconst byte *str_index_to_ptr(const mp_obj_type_t *type, const byte *self_data, size_t self_len,\n    mp_obj_t index, bool is_slice);\nconst byte *find_subbytes(const byte *haystack, size_t hlen, const byte *needle, size_t nlen, int direction);\n\n#define MP_DEFINE_BYTES_OBJ(obj_name, target, len) mp_obj_str_t obj_name = {{&mp_type_bytes}, 0, (len), (const byte *)(target)}\n\nmp_obj_t mp_obj_bytes_hex(size_t n_args, const mp_obj_t *args, const mp_obj_type_t *type);\nmp_obj_t mp_obj_bytes_fromhex(mp_obj_t type_in, mp_obj_t data);\n\nextern const mp_obj_dict_t mp_obj_str_locals_dict;\n\n#if MICROPY_PY_BUILTINS_MEMORYVIEW && MICROPY_PY_BUILTINS_BYTES_HEX\nextern const mp_obj_dict_t mp_obj_memoryview_locals_dict;\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY\nextern const mp_obj_dict_t mp_obj_bytearray_locals_dict;\n#endif\n\n#if MICROPY_PY_ARRAY\nextern const mp_obj_dict_t mp_obj_array_locals_dict;\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}