{
  "module_name": "emit.h",
  "hash_id": "a1cc5b3d7d1e3646c3c29c3476159c4c2075756fec197438a16166bfd95ac285",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/emit.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_EMIT_H\n#define MICROPY_INCLUDED_PY_EMIT_H\n\n#include \"py/lexer.h\"\n#include \"py/scope.h\"\n\n \n\ntypedef enum {\n    MP_PASS_SCOPE = 1,      \n    MP_PASS_STACK_SIZE = 2, \n    MP_PASS_CODE_SIZE = 3,  \n    MP_PASS_EMIT = 4,       \n} pass_kind_t;\n\n#define MP_EMIT_STAR_FLAG_SINGLE (0x01)\n#define MP_EMIT_STAR_FLAG_DOUBLE (0x02)\n\n#define MP_EMIT_BREAK_FROM_FOR (0x8000)\n\n\n#define MP_EMIT_IDOP_LOCAL_FAST (0)\n#define MP_EMIT_IDOP_LOCAL_DEREF (1)\n\n\n#define MP_EMIT_IDOP_GLOBAL_NAME (0)\n#define MP_EMIT_IDOP_GLOBAL_GLOBAL (1)\n\n\n#define MP_EMIT_IMPORT_NAME (0)\n#define MP_EMIT_IMPORT_FROM (1)\n#define MP_EMIT_IMPORT_STAR (2)\n\n\n#define MP_EMIT_SUBSCR_LOAD (0)\n#define MP_EMIT_SUBSCR_STORE (1)\n#define MP_EMIT_SUBSCR_DELETE (2)\n\n\n#define MP_EMIT_ATTR_LOAD (0)\n#define MP_EMIT_ATTR_STORE (1)\n#define MP_EMIT_ATTR_DELETE (2)\n\n\n#define MP_EMIT_SETUP_BLOCK_WITH (0)\n#define MP_EMIT_SETUP_BLOCK_EXCEPT (1)\n#define MP_EMIT_SETUP_BLOCK_FINALLY (2)\n\n\n#define MP_EMIT_BUILD_TUPLE (0)\n#define MP_EMIT_BUILD_LIST (1)\n#define MP_EMIT_BUILD_MAP (2)\n#define MP_EMIT_BUILD_SET (3)\n#define MP_EMIT_BUILD_SLICE (4)\n\n\n#define MP_EMIT_YIELD_VALUE (0)\n#define MP_EMIT_YIELD_FROM (1)\n\ntypedef struct _emit_t emit_t;\n\ntypedef struct _mp_emit_common_t {\n    pass_kind_t pass;\n    uint16_t ct_cur_child;\n    mp_raw_code_t **children;\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    mp_map_t qstr_map;\n    #endif\n    mp_obj_list_t const_obj_list;\n} mp_emit_common_t;\n\ntypedef struct _mp_emit_method_table_id_ops_t {\n    void (*local)(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);\n    void (*global)(emit_t *emit, qstr qst, int kind);\n} mp_emit_method_table_id_ops_t;\n\ntypedef struct _emit_method_table_t {\n    #if MICROPY_DYNAMIC_COMPILER\n    emit_t *(*emit_new)(mp_emit_common_t * emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\n    void (*emit_free)(emit_t *emit);\n    #endif\n\n    void (*start_pass)(emit_t *emit, pass_kind_t pass, scope_t *scope);\n    bool (*end_pass)(emit_t *emit);\n    void (*adjust_stack_size)(emit_t *emit, mp_int_t delta);\n    void (*set_source_line)(emit_t *emit, mp_uint_t line);\n\n    mp_emit_method_table_id_ops_t load_id;\n    mp_emit_method_table_id_ops_t store_id;\n    mp_emit_method_table_id_ops_t delete_id;\n\n    void (*label_assign)(emit_t *emit, mp_uint_t l);\n    void (*import)(emit_t *emit, qstr qst, int kind);\n    void (*load_const_tok)(emit_t *emit, mp_token_kind_t tok);\n    void (*load_const_small_int)(emit_t *emit, mp_int_t arg);\n    void (*load_const_str)(emit_t *emit, qstr qst);\n    void (*load_const_obj)(emit_t *emit, mp_obj_t obj);\n    void (*load_null)(emit_t *emit);\n    void (*load_method)(emit_t *emit, qstr qst, bool is_super);\n    void (*load_build_class)(emit_t *emit);\n    void (*subscr)(emit_t *emit, int kind);\n    void (*attr)(emit_t *emit, qstr qst, int kind);\n    void (*dup_top)(emit_t *emit);\n    void (*dup_top_two)(emit_t *emit);\n    void (*pop_top)(emit_t *emit);\n    void (*rot_two)(emit_t *emit);\n    void (*rot_three)(emit_t *emit);\n    void (*jump)(emit_t *emit, mp_uint_t label);\n    void (*pop_jump_if)(emit_t *emit, bool cond, mp_uint_t label);\n    void (*jump_if_or_pop)(emit_t *emit, bool cond, mp_uint_t label);\n    void (*unwind_jump)(emit_t *emit, mp_uint_t label, mp_uint_t except_depth);\n    void (*setup_block)(emit_t *emit, mp_uint_t label, int kind);\n    void (*with_cleanup)(emit_t *emit, mp_uint_t label);\n    void (*end_finally)(emit_t *emit);\n    void (*get_iter)(emit_t *emit, bool use_stack);\n    void (*for_iter)(emit_t *emit, mp_uint_t label);\n    void (*for_iter_end)(emit_t *emit);\n    void (*pop_except_jump)(emit_t *emit, mp_uint_t label, bool within_exc_handler);\n    void (*unary_op)(emit_t *emit, mp_unary_op_t op);\n    void (*binary_op)(emit_t *emit, mp_binary_op_t op);\n    void (*build)(emit_t *emit, mp_uint_t n_args, int kind);\n    void (*store_map)(emit_t *emit);\n    void (*store_comp)(emit_t *emit, scope_kind_t kind, mp_uint_t set_stack_index);\n    void (*unpack_sequence)(emit_t *emit, mp_uint_t n_args);\n    void (*unpack_ex)(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right);\n    void (*make_function)(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);\n    void (*make_closure)(emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);\n    void (*call_function)(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);\n    void (*call_method)(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);\n    void (*return_value)(emit_t *emit);\n    void (*raise_varargs)(emit_t *emit, mp_uint_t n_args);\n    void (*yield)(emit_t *emit, int kind);\n\n    \n    \n    void (*start_except_handler)(emit_t *emit);\n    void (*end_except_handler)(emit_t *emit);\n} emit_method_table_t;\n\n#if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\nqstr_short_t mp_emit_common_use_qstr(mp_emit_common_t *emit, qstr qst);\n#else\nstatic inline qstr_short_t mp_emit_common_use_qstr(mp_emit_common_t *emit, qstr qst) {\n    return qst;\n}\n#endif\n\nsize_t mp_emit_common_use_const_obj(mp_emit_common_t *emit, mp_obj_t const_obj);\n\nstatic inline size_t mp_emit_common_alloc_const_child(mp_emit_common_t *emit, mp_raw_code_t *rc) {\n    if (emit->pass == MP_PASS_EMIT) {\n        emit->children[emit->ct_cur_child] = rc;\n    }\n    return emit->ct_cur_child++;\n}\n\nstatic inline void mp_emit_common_get_id_for_load(scope_t *scope, qstr qst) {\n    scope_find_or_add_id(scope, qst, ID_INFO_KIND_GLOBAL_IMPLICIT);\n}\n\nid_info_t *mp_emit_common_get_id_for_modification(scope_t *scope, qstr qst);\nvoid mp_emit_common_id_op(emit_t *emit, const mp_emit_method_table_id_ops_t *emit_method_table, scope_t *scope, qstr qst);\n\nextern const emit_method_table_t emit_bc_method_table;\nextern const emit_method_table_t emit_native_x64_method_table;\nextern const emit_method_table_t emit_native_x86_method_table;\nextern const emit_method_table_t emit_native_thumb_method_table;\nextern const emit_method_table_t emit_native_arm_method_table;\nextern const emit_method_table_t emit_native_xtensa_method_table;\nextern const emit_method_table_t emit_native_xtensawin_method_table;\n\nextern const mp_emit_method_table_id_ops_t mp_emit_bc_method_table_load_id_ops;\nextern const mp_emit_method_table_id_ops_t mp_emit_bc_method_table_store_id_ops;\nextern const mp_emit_method_table_id_ops_t mp_emit_bc_method_table_delete_id_ops;\n\nemit_t *emit_bc_new(mp_emit_common_t *emit_common);\nemit_t *emit_native_x64_new(mp_emit_common_t *emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\nemit_t *emit_native_x86_new(mp_emit_common_t *emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\nemit_t *emit_native_thumb_new(mp_emit_common_t *emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\nemit_t *emit_native_arm_new(mp_emit_common_t *emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\nemit_t *emit_native_xtensa_new(mp_emit_common_t *emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\nemit_t *emit_native_xtensawin_new(mp_emit_common_t *emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels);\n\nvoid emit_bc_set_max_num_labels(emit_t *emit, mp_uint_t max_num_labels);\n\nvoid emit_bc_free(emit_t *emit);\nvoid emit_native_x64_free(emit_t *emit);\nvoid emit_native_x86_free(emit_t *emit);\nvoid emit_native_thumb_free(emit_t *emit);\nvoid emit_native_arm_free(emit_t *emit);\nvoid emit_native_xtensa_free(emit_t *emit);\nvoid emit_native_xtensawin_free(emit_t *emit);\n\nvoid mp_emit_bc_start_pass(emit_t *emit, pass_kind_t pass, scope_t *scope);\nbool mp_emit_bc_end_pass(emit_t *emit);\nvoid mp_emit_bc_adjust_stack_size(emit_t *emit, mp_int_t delta);\nvoid mp_emit_bc_set_source_line(emit_t *emit, mp_uint_t line);\n\nvoid mp_emit_bc_load_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);\nvoid mp_emit_bc_load_global(emit_t *emit, qstr qst, int kind);\nvoid mp_emit_bc_store_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);\nvoid mp_emit_bc_store_global(emit_t *emit, qstr qst, int kind);\nvoid mp_emit_bc_delete_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind);\nvoid mp_emit_bc_delete_global(emit_t *emit, qstr qst, int kind);\n\nvoid mp_emit_bc_label_assign(emit_t *emit, mp_uint_t l);\nvoid mp_emit_bc_import(emit_t *emit, qstr qst, int kind);\nvoid mp_emit_bc_load_const_tok(emit_t *emit, mp_token_kind_t tok);\nvoid mp_emit_bc_load_const_small_int(emit_t *emit, mp_int_t arg);\nvoid mp_emit_bc_load_const_str(emit_t *emit, qstr qst);\nvoid mp_emit_bc_load_const_obj(emit_t *emit, mp_obj_t obj);\nvoid mp_emit_bc_load_null(emit_t *emit);\nvoid mp_emit_bc_load_method(emit_t *emit, qstr qst, bool is_super);\nvoid mp_emit_bc_load_build_class(emit_t *emit);\nvoid mp_emit_bc_subscr(emit_t *emit, int kind);\nvoid mp_emit_bc_attr(emit_t *emit, qstr qst, int kind);\nvoid mp_emit_bc_dup_top(emit_t *emit);\nvoid mp_emit_bc_dup_top_two(emit_t *emit);\nvoid mp_emit_bc_pop_top(emit_t *emit);\nvoid mp_emit_bc_rot_two(emit_t *emit);\nvoid mp_emit_bc_rot_three(emit_t *emit);\nvoid mp_emit_bc_jump(emit_t *emit, mp_uint_t label);\nvoid mp_emit_bc_pop_jump_if(emit_t *emit, bool cond, mp_uint_t label);\nvoid mp_emit_bc_jump_if_or_pop(emit_t *emit, bool cond, mp_uint_t label);\nvoid mp_emit_bc_unwind_jump(emit_t *emit, mp_uint_t label, mp_uint_t except_depth);\nvoid mp_emit_bc_setup_block(emit_t *emit, mp_uint_t label, int kind);\nvoid mp_emit_bc_with_cleanup(emit_t *emit, mp_uint_t label);\nvoid mp_emit_bc_end_finally(emit_t *emit);\nvoid mp_emit_bc_get_iter(emit_t *emit, bool use_stack);\nvoid mp_emit_bc_for_iter(emit_t *emit, mp_uint_t label);\nvoid mp_emit_bc_for_iter_end(emit_t *emit);\nvoid mp_emit_bc_pop_except_jump(emit_t *emit, mp_uint_t label, bool within_exc_handler);\nvoid mp_emit_bc_unary_op(emit_t *emit, mp_unary_op_t op);\nvoid mp_emit_bc_binary_op(emit_t *emit, mp_binary_op_t op);\nvoid mp_emit_bc_build(emit_t *emit, mp_uint_t n_args, int kind);\nvoid mp_emit_bc_store_map(emit_t *emit);\nvoid mp_emit_bc_store_comp(emit_t *emit, scope_kind_t kind, mp_uint_t list_stack_index);\nvoid mp_emit_bc_unpack_sequence(emit_t *emit, mp_uint_t n_args);\nvoid mp_emit_bc_unpack_ex(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right);\nvoid mp_emit_bc_make_function(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);\nvoid mp_emit_bc_make_closure(emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults);\nvoid mp_emit_bc_call_function(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);\nvoid mp_emit_bc_call_method(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags);\nvoid mp_emit_bc_return_value(emit_t *emit);\nvoid mp_emit_bc_raise_varargs(emit_t *emit, mp_uint_t n_args);\nvoid mp_emit_bc_yield(emit_t *emit, int kind);\nvoid mp_emit_bc_start_except_handler(emit_t *emit);\nvoid mp_emit_bc_end_except_handler(emit_t *emit);\n\ntypedef struct _emit_inline_asm_t emit_inline_asm_t;\n\ntypedef struct _emit_inline_asm_method_table_t {\n    #if MICROPY_DYNAMIC_COMPILER\n    emit_inline_asm_t *(*asm_new)(mp_uint_t max_num_labels);\n    void (*asm_free)(emit_inline_asm_t *emit);\n    #endif\n\n    void (*start_pass)(emit_inline_asm_t *emit, pass_kind_t pass, mp_obj_t *error_slot);\n    void (*end_pass)(emit_inline_asm_t *emit, mp_uint_t type_sig);\n    mp_uint_t (*count_params)(emit_inline_asm_t *emit, mp_uint_t n_params, mp_parse_node_t *pn_params);\n    bool (*label)(emit_inline_asm_t *emit, mp_uint_t label_num, qstr label_id);\n    void (*op)(emit_inline_asm_t *emit, qstr op, mp_uint_t n_args, mp_parse_node_t *pn_args);\n} emit_inline_asm_method_table_t;\n\nextern const emit_inline_asm_method_table_t emit_inline_thumb_method_table;\nextern const emit_inline_asm_method_table_t emit_inline_xtensa_method_table;\n\nemit_inline_asm_t *emit_inline_thumb_new(mp_uint_t max_num_labels);\nemit_inline_asm_t *emit_inline_xtensa_new(mp_uint_t max_num_labels);\n\nvoid emit_inline_thumb_free(emit_inline_asm_t *emit);\nvoid emit_inline_xtensa_free(emit_inline_asm_t *emit);\n\n#if MICROPY_WARNINGS\nvoid mp_emitter_warning(pass_kind_t pass, const char *msg);\n#else\n#define mp_emitter_warning(pass, msg)\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}