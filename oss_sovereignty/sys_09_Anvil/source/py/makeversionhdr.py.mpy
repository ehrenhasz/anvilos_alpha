{
  "module_name": "makeversionhdr.py",
  "hash_id": "216474a976bf336d3df8d70b9e30eb88419653eeb3742fc6b05e46a40aa6ef99",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/makeversionhdr.py",
  "human_readable_source": "\"\"\"\nGenerate header file with macros defining MicroPython version info.\n\nThis script works with Python 2.6, 2.7, 3.3 and 3.4.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport sys\nimport os\nimport datetime\nimport subprocess\n\n\n# The MicroPython repository tags a release commit as \"vX.Y.Z\", and the commit\n# immediately following as \"vX.(Y+1).Z-preview\".\n# This function will return:\n#   \"vX.Y.Z\" -- building at the release commit\n#   \"vX.Y.Z-preview\" -- building at the first commit in the next cycle\n#   \"vX.Y.Z-preview.N.gHASH\" -- building at any subsequent commit in the cycle\n#   \"vX.Y.Z-preview.N.gHASH.dirty\" -- building at any subsequent commit in the cycle\n#                                     with local changes\ndef get_version_info_from_git(repo_path):\n    # Python 2.6 doesn't have check_output, so check for that\n    try:\n        subprocess.check_output\n    except AttributeError:\n        return None\n\n    # Note: git describe doesn't work if no tag is available\n    try:\n        git_tag = subprocess.check_output(\n            [\"git\", \"describe\", \"--tags\", \"--dirty\", \"--always\", \"--match\", \"v[1-9].*\"],\n            cwd=repo_path,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True,\n        ).strip()\n        # Turn git-describe's output into semver compatible (dot-separated\n        # identifiers inside the prerelease field).\n        git_tag = git_tag.split(\"-\", 1)\n        if len(git_tag) == 1:\n            return git_tag[0]\n        else:\n            return git_tag[0] + \"-\" + git_tag[1].replace(\"-\", \".\")\n    except (subprocess.CalledProcessError, OSError):\n        return None\n\n\ndef get_hash_from_git(repo_path):\n    # Python 2.6 doesn't have check_output, so check for that.\n    try:\n        subprocess.check_output\n    except AttributeError:\n        return None\n\n    try:\n        return subprocess.check_output(\n            [\"git\", \"rev-parse\", \"--short\", \"HEAD\"],\n            cwd=repo_path,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True,\n        ).strip()\n    except (subprocess.CalledProcessError, OSError):\n        return None\n\n\n# When building from a source tarball (or any situation where the git repo\n# isn't available), this function will use the info in mpconfig.h as a\n# fallback. The release commit sets MICROPY_VERSION_PRERELEASE to 0, and the\n# commit immediately following increments MICROPY_VERSION_MINOR and sets\n# MICROPY_VERSION_PRERELEASE back to 1.\n# This function will return:\n#    \"vX.Y.Z\" -- building at the release commit\n#    \"vX.Y.Z-preview\" -- building at any other commit\ndef get_version_info_from_mpconfig(repo_path):\n    print(\n        \"makeversionhdr.py: Warning: No git repo or tag info available, falling back to mpconfig.h version info.\",\n        file=sys.stderr,\n    )\n\n    with open(os.path.join(repo_path, \"py\", \"mpconfig.h\")) as f:\n        for line in f:\n            if line.startswith(\"#define MICROPY_VERSION_MAJOR \"):\n                ver_major = int(line.strip().split()[2])\n            elif line.startswith(\"#define MICROPY_VERSION_MINOR \"):\n                ver_minor = int(line.strip().split()[2])\n            elif line.startswith(\"#define MICROPY_VERSION_MICRO \"):\n                ver_micro = int(line.strip().split()[2])\n            elif line.startswith(\"#define MICROPY_VERSION_PRERELEASE \"):\n                ver_prerelease = int(line.strip().split()[2])\n                git_tag = \"v%d.%d.%d%s\" % (\n                    ver_major,\n                    ver_minor,\n                    ver_micro,\n                    \"-preview\" if ver_prerelease else \"\",\n                )\n                return git_tag\n    return None\n\n\ndef make_version_header(repo_path, filename):\n    git_tag = None\n    git_hash = None\n    if \"MICROPY_GIT_TAG\" in os.environ:\n        git_tag = os.environ[\"MICROPY_GIT_TAG\"]\n        git_hash = os.environ.get(\"MICROPY_GIT_HASH\")\n    if git_tag is None:\n        git_tag = get_version_info_from_git(repo_path)\n        git_hash = get_hash_from_git(repo_path)\n    if git_tag is None:\n        git_tag = get_version_info_from_mpconfig(repo_path)\n\n    if not git_tag:\n        print(\"makeversionhdr.py: Error: No version information available.\")\n        sys.exit(1)\n\n    build_date = datetime.date.today()\n    if \"SOURCE_DATE_EPOCH\" in os.environ:\n        build_date = datetime.datetime.utcfromtimestamp(\n            int(os.environ[\"SOURCE_DATE_EPOCH\"])\n        ).date()\n\n    # Generate the file with the git and version info\n    # Note: MICROPY_GIT_HASH may be used by third-party code.\n    file_data = \"\"\"\\\n// This file was generated by py/makeversionhdr.py\n#define MICROPY_GIT_TAG \"%s\"\n#define MICROPY_GIT_HASH \"%s\"\n#define MICROPY_BUILD_DATE \"%s\"\n\"\"\" % (\n        git_tag,\n        git_hash or \"<no hash>\",\n        build_date.strftime(\"%Y-%m-%d\"),\n    )\n\n    # Check if the file contents changed from last time\n    write_file = True\n    if os.path.isfile(filename):\n        with open(filename, \"r\") as f:\n            existing_data = f.read()\n        if existing_data == file_data:\n            write_file = False\n\n    # Only write the file if we need to\n    if write_file:\n        print(\"GEN %s\" % filename)\n        with open(filename, \"w\") as f:\n            f.write(file_data)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    # makeversionheader.py lives in repo/py, so default repo_path to the\n    # parent of sys.argv[0]'s directory.\n    parser.add_argument(\n        \"-r\",\n        \"--repo-path\",\n        default=os.path.join(os.path.dirname(sys.argv[0]), \"..\"),\n        help=\"path to MicroPython Git repo to query for version\",\n    )\n    parser.add_argument(\"dest\", nargs=1, help=\"output file path\")\n    args = parser.parse_args()\n\n    make_version_header(args.repo_path, args.dest[0])\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}