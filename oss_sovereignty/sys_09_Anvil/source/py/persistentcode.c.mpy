{
  "module_name": "persistentcode.c",
  "hash_id": "1a0ec10f43c2655bc0063ef690e2d3411f2b1b6a99aaa533359e06a83b006701",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/persistentcode.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/reader.h\"\n#include \"py/nativeglue.h\"\n#include \"py/persistentcode.h\"\n#include \"py/bc0.h\"\n#include \"py/objstr.h\"\n#include \"py/mpthread.h\"\n\n#if MICROPY_PERSISTENT_CODE_LOAD || MICROPY_PERSISTENT_CODE_SAVE\n\n#include \"py/smallint.h\"\n\n\n\n\n\n\n#define QSTR_LAST_STATIC MP_QSTR_zip\n\n#if MICROPY_DYNAMIC_COMPILER\n#define MPY_FEATURE_ARCH_DYNAMIC mp_dynamic_compiler.native_arch\n#else\n#define MPY_FEATURE_ARCH_DYNAMIC MPY_FEATURE_ARCH\n#endif\n\ntypedef struct _bytecode_prelude_t {\n    uint n_state;\n    uint n_exc_stack;\n    uint scope_flags;\n    uint n_pos_args;\n    uint n_kwonly_args;\n    uint n_def_pos_args;\n    uint code_info_size;\n} bytecode_prelude_t;\n\n#endif \n\n#if MICROPY_PERSISTENT_CODE_LOAD\n\n#include \"py/parsenum.h\"\n\nstatic int read_byte(mp_reader_t *reader);\nstatic size_t read_uint(mp_reader_t *reader);\n\n#if MICROPY_EMIT_MACHINE_CODE\n\ntypedef struct _reloc_info_t {\n    mp_reader_t *reader;\n    mp_module_context_t *context;\n    uint8_t *rodata;\n    uint8_t *bss;\n} reloc_info_t;\n\nvoid mp_native_relocate(void *ri_in, uint8_t *text, uintptr_t reloc_text) {\n    \n    reloc_info_t *ri = ri_in;\n    uint8_t op;\n    uintptr_t *addr_to_adjust = NULL;\n    while ((op = read_byte(ri->reader)) != 0xff) {\n        if (op & 1) {\n            \n            size_t addr = read_uint(ri->reader);\n            if ((addr & 1) == 0) {\n                \n                addr_to_adjust = &((uintptr_t *)text)[addr >> 1];\n            } else {\n                \n                addr_to_adjust = &((uintptr_t *)ri->rodata)[addr >> 1];\n            }\n        }\n        op >>= 1;\n        uintptr_t dest;\n        size_t n = 1;\n        if (op <= 5) {\n            if (op & 1) {\n                \n                n = read_uint(ri->reader);\n            }\n            op >>= 1;\n            if (op == 0) {\n                \n                dest = reloc_text;\n            } else if (op == 1) {\n                \n                dest = (uintptr_t)ri->rodata;\n            } else {\n                \n                dest = (uintptr_t)ri->bss;\n            }\n        } else if (op == 6) {\n            \n            dest = (uintptr_t)ri->context->constants.qstr_table;\n        } else if (op == 7) {\n            \n            dest = (uintptr_t)ri->context->constants.obj_table;\n        } else if (op == 8) {\n            \n            dest = (uintptr_t)&mp_fun_table;\n        } else {\n            \n            dest = ((uintptr_t *)&mp_fun_table)[op - 9];\n        }\n        while (n--) {\n            *addr_to_adjust++ += dest;\n        }\n    }\n}\n\n#endif\n\nstatic int read_byte(mp_reader_t *reader) {\n    return reader->readbyte(reader->data);\n}\n\nstatic void read_bytes(mp_reader_t *reader, byte *buf, size_t len) {\n    while (len-- > 0) {\n        *buf++ = reader->readbyte(reader->data);\n    }\n}\n\nstatic size_t read_uint(mp_reader_t *reader) {\n    size_t unum = 0;\n    for (;;) {\n        byte b = reader->readbyte(reader->data);\n        unum = (unum << 7) | (b & 0x7f);\n        if ((b & 0x80) == 0) {\n            break;\n        }\n    }\n    return unum;\n}\n\nstatic qstr load_qstr(mp_reader_t *reader) {\n    size_t len = read_uint(reader);\n    if (len & 1) {\n        \n        return len >> 1;\n    }\n    len >>= 1;\n    char *str = m_new(char, len);\n    read_bytes(reader, (byte *)str, len);\n    read_byte(reader); \n    qstr qst = qstr_from_strn(str, len);\n    m_del(char, str, len);\n    return qst;\n}\n\nstatic mp_obj_t load_obj(mp_reader_t *reader) {\n    byte obj_type = read_byte(reader);\n    #if MICROPY_EMIT_MACHINE_CODE\n    if (obj_type == MP_PERSISTENT_OBJ_FUN_TABLE) {\n        return MP_OBJ_FROM_PTR(&mp_fun_table);\n    } else\n    #endif\n    if (obj_type == MP_PERSISTENT_OBJ_NONE) {\n        return mp_const_none;\n    } else if (obj_type == MP_PERSISTENT_OBJ_FALSE) {\n        return mp_const_false;\n    } else if (obj_type == MP_PERSISTENT_OBJ_TRUE) {\n        return mp_const_true;\n    } else if (obj_type == MP_PERSISTENT_OBJ_ELLIPSIS) {\n        return MP_OBJ_FROM_PTR(&mp_const_ellipsis_obj);\n    } else {\n        size_t len = read_uint(reader);\n        if (len == 0 && obj_type == MP_PERSISTENT_OBJ_BYTES) {\n            read_byte(reader); \n            return mp_const_empty_bytes;\n        } else if (obj_type == MP_PERSISTENT_OBJ_TUPLE) {\n            mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(mp_obj_new_tuple(len, NULL));\n            for (size_t i = 0; i < len; ++i) {\n                tuple->items[i] = load_obj(reader);\n            }\n            return MP_OBJ_FROM_PTR(tuple);\n        }\n        vstr_t vstr;\n        vstr_init_len(&vstr, len);\n        read_bytes(reader, (byte *)vstr.buf, len);\n        if (obj_type == MP_PERSISTENT_OBJ_STR || obj_type == MP_PERSISTENT_OBJ_BYTES) {\n            read_byte(reader); \n            if (obj_type == MP_PERSISTENT_OBJ_STR) {\n                return mp_obj_new_str_from_utf8_vstr(&vstr);\n            } else {\n                return mp_obj_new_bytes_from_vstr(&vstr);\n            }\n        } else if (obj_type == MP_PERSISTENT_OBJ_INT) {\n            return mp_parse_num_integer(vstr.buf, vstr.len, 10, NULL);\n        } else {\n            assert(obj_type == MP_PERSISTENT_OBJ_FLOAT || obj_type == MP_PERSISTENT_OBJ_COMPLEX);\n            return mp_parse_num_float(vstr.buf, vstr.len, obj_type == MP_PERSISTENT_OBJ_COMPLEX, NULL);\n        }\n    }\n}\n\nstatic mp_raw_code_t *load_raw_code(mp_reader_t *reader, mp_module_context_t *context) {\n    \n    size_t kind_len = read_uint(reader);\n    int kind = (kind_len & 3) + MP_CODE_BYTECODE;\n    bool has_children = !!(kind_len & 4);\n    size_t fun_data_len = kind_len >> 3;\n\n    #if !MICROPY_EMIT_MACHINE_CODE\n    if (kind != MP_CODE_BYTECODE) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"incompatible .mpy file\"));\n    }\n    #endif\n\n    uint8_t *fun_data = NULL;\n    #if MICROPY_EMIT_MACHINE_CODE\n    size_t prelude_offset = 0;\n    mp_uint_t native_scope_flags = 0;\n    mp_uint_t native_n_pos_args = 0;\n    mp_uint_t native_type_sig = 0;\n    #endif\n\n    if (kind == MP_CODE_BYTECODE) {\n        \n        fun_data = m_new(uint8_t, fun_data_len);\n        \n        read_bytes(reader, fun_data, fun_data_len);\n\n    #if MICROPY_EMIT_MACHINE_CODE\n    } else {\n        \n        size_t fun_alloc;\n        MP_PLAT_ALLOC_EXEC(fun_data_len, (void **)&fun_data, &fun_alloc);\n        read_bytes(reader, fun_data, fun_data_len);\n\n        if (kind == MP_CODE_NATIVE_PY) {\n            \n            prelude_offset = read_uint(reader);\n            const byte *ip = fun_data + prelude_offset;\n            MP_BC_PRELUDE_SIG_DECODE(ip);\n            native_scope_flags = scope_flags;\n        } else {\n            \n            native_scope_flags = read_uint(reader);\n            if (kind == MP_CODE_NATIVE_ASM) {\n                native_n_pos_args = read_uint(reader);\n                native_type_sig = read_uint(reader);\n            }\n        }\n    #endif\n    }\n\n    size_t n_children = 0;\n    mp_raw_code_t **children = NULL;\n\n    #if MICROPY_EMIT_MACHINE_CODE\n    \n    uint8_t *rodata = NULL;\n    uint8_t *bss = NULL;\n    if (kind == MP_CODE_NATIVE_VIPER) {\n        size_t rodata_size = 0;\n        if (native_scope_flags & MP_SCOPE_FLAG_VIPERRODATA) {\n            rodata_size = read_uint(reader);\n        }\n\n        size_t bss_size = 0;\n        if (native_scope_flags & MP_SCOPE_FLAG_VIPERBSS) {\n            bss_size = read_uint(reader);\n        }\n\n        if (rodata_size + bss_size != 0) {\n            bss_size = (uintptr_t)MP_ALIGN(bss_size, sizeof(uintptr_t));\n            uint8_t *data = m_new0(uint8_t, bss_size + rodata_size);\n            bss = data;\n            rodata = bss + bss_size;\n            if (native_scope_flags & MP_SCOPE_FLAG_VIPERRODATA) {\n                read_bytes(reader, rodata, rodata_size);\n            }\n\n            \n            \n            \n            assert(!has_children);\n            children = (void *)data;\n        }\n    }\n    #endif\n\n    \n    if (has_children) {\n        n_children = read_uint(reader);\n        children = m_new(mp_raw_code_t *, n_children + (kind == MP_CODE_NATIVE_PY));\n        for (size_t i = 0; i < n_children; ++i) {\n            children[i] = load_raw_code(reader, context);\n        }\n    }\n\n    \n    mp_raw_code_t *rc = mp_emit_glue_new_raw_code();\n    if (kind == MP_CODE_BYTECODE) {\n        const byte *ip = fun_data;\n        MP_BC_PRELUDE_SIG_DECODE(ip);\n        \n        mp_emit_glue_assign_bytecode(rc, fun_data,\n            children,\n            #if MICROPY_PERSISTENT_CODE_SAVE\n            fun_data_len,\n            n_children,\n            #endif\n            scope_flags);\n\n    #if MICROPY_EMIT_MACHINE_CODE\n    } else {\n        const uint8_t *prelude_ptr;\n        #if MICROPY_EMIT_NATIVE_PRELUDE_SEPARATE_FROM_MACHINE_CODE\n        if (kind == MP_CODE_NATIVE_PY) {\n            \n            \n            void *buf = fun_data + prelude_offset;\n            size_t n = fun_data_len - prelude_offset;\n            prelude_ptr = memcpy(m_new(uint8_t, n), buf, n);\n        }\n        #endif\n\n        \n        reloc_info_t ri = {reader, context, rodata, bss};\n        #if defined(MP_PLAT_COMMIT_EXEC)\n        void *opt_ri = (native_scope_flags & MP_SCOPE_FLAG_VIPERRELOC) ? &ri : NULL;\n        fun_data = MP_PLAT_COMMIT_EXEC(fun_data, fun_data_len, opt_ri);\n        #else\n        if (native_scope_flags & MP_SCOPE_FLAG_VIPERRELOC) {\n            #if MICROPY_PERSISTENT_CODE_TRACK_RELOC_CODE\n            \n            \n            \n            \n            \n            if (MP_STATE_PORT(track_reloc_code_list) == MP_OBJ_NULL) {\n                MP_STATE_PORT(track_reloc_code_list) = mp_obj_new_list(0, NULL);\n            }\n            mp_obj_list_append(MP_STATE_PORT(track_reloc_code_list), MP_OBJ_FROM_PTR(fun_data));\n            #endif\n            \n            mp_native_relocate(&ri, fun_data, (uintptr_t)fun_data);\n        }\n        #endif\n\n        if (kind == MP_CODE_NATIVE_PY) {\n            #if !MICROPY_EMIT_NATIVE_PRELUDE_SEPARATE_FROM_MACHINE_CODE\n            prelude_ptr = fun_data + prelude_offset;\n            #endif\n            if (n_children == 0) {\n                children = (void *)prelude_ptr;\n            } else {\n                children[n_children] = (void *)prelude_ptr;\n            }\n        }\n\n        \n        mp_emit_glue_assign_native(rc, kind,\n            fun_data, fun_data_len,\n            children,\n            #if MICROPY_PERSISTENT_CODE_SAVE\n            n_children,\n            prelude_offset,\n            #endif\n            native_scope_flags, native_n_pos_args, native_type_sig\n            );\n    #endif\n    }\n    return rc;\n}\n\nvoid mp_raw_code_load(mp_reader_t *reader, mp_compiled_module_t *cm) {\n    \n    MP_DEFINE_NLR_JUMP_CALLBACK_FUNCTION_1(ctx, reader->close, reader->data);\n    nlr_push_jump_callback(&ctx.callback, mp_call_function_1_from_nlr_jump_callback);\n\n    byte header[4];\n    read_bytes(reader, header, sizeof(header));\n    byte arch = MPY_FEATURE_DECODE_ARCH(header[2]);\n    if (header[0] != 'M'\n        || header[1] != MPY_VERSION\n        || (arch != MP_NATIVE_ARCH_NONE && MPY_FEATURE_DECODE_SUB_VERSION(header[2]) != MPY_SUB_VERSION)\n        || header[3] > MP_SMALL_INT_BITS) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"incompatible .mpy file\"));\n    }\n    if (MPY_FEATURE_DECODE_ARCH(header[2]) != MP_NATIVE_ARCH_NONE) {\n        if (!MPY_FEATURE_ARCH_TEST(arch)) {\n            if (MPY_FEATURE_ARCH_TEST(MP_NATIVE_ARCH_NONE)) {\n                \n                \n                mp_raise_ValueError(MP_ERROR_TEXT(\"native code in .mpy unsupported\"));\n            } else {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"incompatible .mpy arch\"));\n            }\n        }\n    }\n\n    size_t n_qstr = read_uint(reader);\n    size_t n_obj = read_uint(reader);\n    mp_module_context_alloc_tables(cm->context, n_qstr, n_obj);\n\n    \n    for (size_t i = 0; i < n_qstr; ++i) {\n        cm->context->constants.qstr_table[i] = load_qstr(reader);\n    }\n\n    \n    for (size_t i = 0; i < n_obj; ++i) {\n        cm->context->constants.obj_table[i] = load_obj(reader);\n    }\n\n    \n    cm->rc = load_raw_code(reader, cm->context);\n\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    cm->has_native = MPY_FEATURE_DECODE_ARCH(header[2]) != MP_NATIVE_ARCH_NONE;\n    cm->n_qstr = n_qstr;\n    cm->n_obj = n_obj;\n    #endif\n\n    \n    nlr_pop_jump_callback(true);\n}\n\nvoid mp_raw_code_load_mem(const byte *buf, size_t len, mp_compiled_module_t *context) {\n    mp_reader_t reader;\n    mp_reader_new_mem(&reader, buf, len, 0);\n    mp_raw_code_load(&reader, context);\n}\n\n#if MICROPY_HAS_FILE_READER\n\nvoid mp_raw_code_load_file(qstr filename, mp_compiled_module_t *context) {\n    mp_reader_t reader;\n    mp_reader_new_file(&reader, filename);\n    mp_raw_code_load(&reader, context);\n}\n\n#endif \n\n#endif \n\n#if MICROPY_PERSISTENT_CODE_SAVE\n\n#include \"py/objstr.h\"\n\nstatic void mp_print_bytes(mp_print_t *print, const byte *data, size_t len) {\n    print->print_strn(print->data, (const char *)data, len);\n}\n\n#define BYTES_FOR_INT ((MP_BYTES_PER_OBJ_WORD * 8 + 6) / 7)\nstatic void mp_print_uint(mp_print_t *print, size_t n) {\n    byte buf[BYTES_FOR_INT];\n    byte *p = buf + sizeof(buf);\n    *--p = n & 0x7f;\n    n >>= 7;\n    for (; n != 0; n >>= 7) {\n        *--p = 0x80 | (n & 0x7f);\n    }\n    print->print_strn(print->data, (char *)p, buf + sizeof(buf) - p);\n}\n\nstatic void save_qstr(mp_print_t *print, qstr qst) {\n    if (qst <= QSTR_LAST_STATIC) {\n        \n        mp_print_uint(print, qst << 1 | 1);\n        return;\n    }\n    size_t len;\n    const byte *str = qstr_data(qst, &len);\n    mp_print_uint(print, len << 1);\n    mp_print_bytes(print, str, len + 1); \n}\n\nstatic void save_obj(mp_print_t *print, mp_obj_t o) {\n    #if MICROPY_EMIT_MACHINE_CODE\n    if (o == MP_OBJ_FROM_PTR(&mp_fun_table)) {\n        byte obj_type = MP_PERSISTENT_OBJ_FUN_TABLE;\n        mp_print_bytes(print, &obj_type, 1);\n    } else\n    #endif\n    if (mp_obj_is_str_or_bytes(o)) {\n        byte obj_type;\n        if (mp_obj_is_str(o)) {\n            obj_type = MP_PERSISTENT_OBJ_STR;\n        } else {\n            obj_type = MP_PERSISTENT_OBJ_BYTES;\n        }\n        size_t len;\n        const char *str = mp_obj_str_get_data(o, &len);\n        mp_print_bytes(print, &obj_type, 1);\n        mp_print_uint(print, len);\n        mp_print_bytes(print, (const byte *)str, len + 1); \n    } else if (o == mp_const_none) {\n        byte obj_type = MP_PERSISTENT_OBJ_NONE;\n        mp_print_bytes(print, &obj_type, 1);\n    } else if (o == mp_const_false) {\n        byte obj_type = MP_PERSISTENT_OBJ_FALSE;\n        mp_print_bytes(print, &obj_type, 1);\n    } else if (o == mp_const_true) {\n        byte obj_type = MP_PERSISTENT_OBJ_TRUE;\n        mp_print_bytes(print, &obj_type, 1);\n    } else if (MP_OBJ_TO_PTR(o) == &mp_const_ellipsis_obj) {\n        byte obj_type = MP_PERSISTENT_OBJ_ELLIPSIS;\n        mp_print_bytes(print, &obj_type, 1);\n    } else if (mp_obj_is_type(o, &mp_type_tuple)) {\n        size_t len;\n        mp_obj_t *items;\n        mp_obj_tuple_get(o, &len, &items);\n        byte obj_type = MP_PERSISTENT_OBJ_TUPLE;\n        mp_print_bytes(print, &obj_type, 1);\n        mp_print_uint(print, len);\n        for (size_t i = 0; i < len; ++i) {\n            save_obj(print, items[i]);\n        }\n    } else {\n        \n        \n        byte obj_type;\n        if (mp_obj_is_int(o)) {\n            obj_type = MP_PERSISTENT_OBJ_INT;\n        #if MICROPY_PY_BUILTINS_COMPLEX\n        } else if (mp_obj_is_type(o, &mp_type_complex)) {\n            obj_type = MP_PERSISTENT_OBJ_COMPLEX;\n        #endif\n        } else {\n            assert(mp_obj_is_float(o));\n            obj_type = MP_PERSISTENT_OBJ_FLOAT;\n        }\n        vstr_t vstr;\n        mp_print_t pr;\n        vstr_init_print(&vstr, 10, &pr);\n        mp_obj_print_helper(&pr, o, PRINT_REPR);\n        mp_print_bytes(print, &obj_type, 1);\n        mp_print_uint(print, vstr.len);\n        mp_print_bytes(print, (const byte *)vstr.buf, vstr.len);\n        vstr_clear(&vstr);\n    }\n}\n\nstatic void save_raw_code(mp_print_t *print, const mp_raw_code_t *rc) {\n    \n    mp_print_uint(print, (rc->fun_data_len << 3) | ((rc->n_children != 0) << 2) | (rc->kind - MP_CODE_BYTECODE));\n\n    \n    mp_print_bytes(print, rc->fun_data, rc->fun_data_len);\n\n    #if MICROPY_EMIT_MACHINE_CODE\n    if (rc->kind == MP_CODE_NATIVE_PY) {\n        \n        mp_print_uint(print, rc->prelude_offset);\n    } else if (rc->kind == MP_CODE_NATIVE_VIPER || rc->kind == MP_CODE_NATIVE_ASM) {\n        \n        \n        \n        mp_print_uint(print, 0);\n        #if MICROPY_EMIT_INLINE_ASM\n        if (rc->kind == MP_CODE_NATIVE_ASM) {\n            mp_print_uint(print, rc->asm_n_pos_args);\n            mp_print_uint(print, rc->asm_type_sig);\n        }\n        #endif\n    }\n    #endif\n\n    if (rc->n_children) {\n        mp_print_uint(print, rc->n_children);\n        for (size_t i = 0; i < rc->n_children; ++i) {\n            save_raw_code(print, rc->children[i]);\n        }\n    }\n}\n\nvoid mp_raw_code_save(mp_compiled_module_t *cm, mp_print_t *print) {\n    \n    \n    \n    \n    \n    byte header[4] = {\n        'M',\n        MPY_VERSION,\n        cm->has_native ? MPY_FEATURE_ENCODE_SUB_VERSION(MPY_SUB_VERSION) | MPY_FEATURE_ENCODE_ARCH(MPY_FEATURE_ARCH_DYNAMIC) : 0,\n        #if MICROPY_DYNAMIC_COMPILER\n        mp_dynamic_compiler.small_int_bits,\n        #else\n        MP_SMALL_INT_BITS,\n        #endif\n    };\n    mp_print_bytes(print, header, sizeof(header));\n\n    \n    mp_print_uint(print, cm->n_qstr);\n    mp_print_uint(print, cm->n_obj);\n\n    \n    for (size_t i = 0; i < cm->n_qstr; ++i) {\n        save_qstr(print, cm->context->constants.qstr_table[i]);\n    }\n\n    \n    for (size_t i = 0; i < cm->n_obj; ++i) {\n        save_obj(print, (mp_obj_t)cm->context->constants.obj_table[i]);\n    }\n\n    \n    save_raw_code(print, cm->rc);\n}\n\n#if MICROPY_PERSISTENT_CODE_SAVE_FILE\n\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nstatic void fd_print_strn(void *env, const char *str, size_t len) {\n    int fd = (intptr_t)env;\n    MP_THREAD_GIL_EXIT();\n    ssize_t ret = write(fd, str, len);\n    MP_THREAD_GIL_ENTER();\n    (void)ret;\n}\n\nvoid mp_raw_code_save_file(mp_compiled_module_t *cm, qstr filename) {\n    MP_THREAD_GIL_EXIT();\n    int fd = open(qstr_str(filename), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    MP_THREAD_GIL_ENTER();\n    if (fd < 0) {\n        mp_raise_OSError_with_filename(errno, qstr_str(filename));\n    }\n    mp_print_t fd_print = {(void *)(intptr_t)fd, fd_print_strn};\n    mp_raw_code_save(cm, &fd_print);\n    MP_THREAD_GIL_EXIT();\n    close(fd);\n    MP_THREAD_GIL_ENTER();\n}\n\n#endif \n\n#endif \n\n#if MICROPY_PERSISTENT_CODE_TRACK_RELOC_CODE\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t track_reloc_code_list);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}