{
  "module_name": "objgenerator.c",
  "hash_id": "2c0ab6db5df9185eeca5cdee0d9ed9e450af6370c39118d3724d4bf25e2980f0",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objgenerator.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n#include \"py/bc.h\"\n#include \"py/objstr.h\"\n#include \"py/objgenerator.h\"\n#include \"py/objfun.h\"\n#include \"py/stackctrl.h\"\n\n\nconst mp_obj_exception_t mp_const_GeneratorExit_obj = {{&mp_type_GeneratorExit}, 0, 0, NULL, (mp_obj_tuple_t *)&mp_const_empty_tuple_obj};\n\n \n \n\ntypedef struct _mp_obj_gen_instance_t {\n    mp_obj_base_t base;\n    \n    \n    \n    mp_obj_t pend_exc;\n    mp_code_state_t code_state;\n} mp_obj_gen_instance_t;\n\nstatic mp_obj_t gen_wrap_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n    mp_obj_fun_bc_t *self_fun = MP_OBJ_TO_PTR(self_in);\n\n    \n    const uint8_t *ip = self_fun->bytecode;\n    MP_BC_PRELUDE_SIG_DECODE(ip);\n\n    \n    mp_obj_gen_instance_t *o = mp_obj_malloc_var(mp_obj_gen_instance_t, code_state.state, byte,\n        n_state * sizeof(mp_obj_t) + n_exc_stack * sizeof(mp_exc_stack_t),\n        &mp_type_gen_instance);\n\n    o->pend_exc = mp_const_none;\n    o->code_state.fun_bc = self_fun;\n    o->code_state.n_state = n_state;\n    mp_setup_code_state(&o->code_state, n_args, n_kw, args);\n    return MP_OBJ_FROM_PTR(o);\n}\n\n#if MICROPY_PY_FUNCTION_ATTRS\n#define GEN_WRAP_TYPE_ATTR attr, mp_obj_fun_bc_attr,\n#else\n#define GEN_WRAP_TYPE_ATTR\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_gen_wrap,\n    MP_QSTR_generator,\n    MP_TYPE_FLAG_BINDS_SELF,\n    GEN_WRAP_TYPE_ATTR\n    call, gen_wrap_call\n    );\n\n \n\n\n#if MICROPY_EMIT_NATIVE\n\n\ntypedef struct _mp_obj_gen_instance_native_t {\n    mp_obj_base_t base;\n    mp_obj_t pend_exc;\n    mp_code_state_native_t code_state;\n} mp_obj_gen_instance_native_t;\n\nstatic mp_obj_t native_gen_wrap_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n    mp_obj_fun_bc_t *self_fun = MP_OBJ_TO_PTR(self_in);\n\n    \n    const uint8_t *prelude_ptr = mp_obj_fun_native_get_prelude_ptr(self_fun);\n\n    \n    const uint8_t *ip = prelude_ptr;\n    MP_BC_PRELUDE_SIG_DECODE(ip);\n\n    \n    mp_obj_gen_instance_native_t *o = mp_obj_malloc_var(mp_obj_gen_instance_native_t, code_state.state, byte, n_state * sizeof(mp_obj_t), &mp_type_gen_instance);\n\n    \n    o->pend_exc = mp_const_none;\n    o->code_state.fun_bc = self_fun;\n    o->code_state.n_state = n_state;\n    mp_setup_code_state_native(&o->code_state, n_args, n_kw, args);\n\n    \n    o->code_state.exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_SENTINEL;\n\n    \n    o->code_state.ip = mp_obj_fun_native_get_generator_start(self_fun);\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\n#if MICROPY_PY_FUNCTION_ATTRS\n#define NATIVE_GEN_WRAP_TYPE_ATTR , attr, mp_obj_fun_bc_attr\n#else\n#define NATIVE_GEN_WRAP_TYPE_ATTR\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_native_gen_wrap,\n    MP_QSTR_generator,\n    MP_TYPE_FLAG_BINDS_SELF,\n    call, native_gen_wrap_call\n    NATIVE_GEN_WRAP_TYPE_ATTR\n    );\n\n#endif \n\n \n \n\nstatic void gen_instance_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<generator object '%q' at %p>\", mp_obj_fun_get_name(MP_OBJ_FROM_PTR(self->code_state.fun_bc)), self);\n}\n\nmp_vm_return_kind_t mp_obj_gen_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val) {\n    MP_STACK_CHECK();\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_gen_instance));\n    mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->code_state.ip == 0) {\n        \n        \n        *ret_val = mp_const_none;\n        return MP_VM_RETURN_NORMAL;\n    }\n\n    \n    if (self->pend_exc == MP_OBJ_NULL) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"generator already executing\"));\n    }\n\n    #if MICROPY_PY_GENERATOR_PEND_THROW\n    \n    if (self->pend_exc != mp_const_none) {\n        throw_value = self->pend_exc;\n    }\n    #endif\n\n    \n    void *state_start = self->code_state.state - 1;\n    #if MICROPY_EMIT_NATIVE\n    if (self->code_state.exc_sp_idx == MP_CODE_STATE_EXC_SP_IDX_SENTINEL) {\n        state_start = ((mp_obj_gen_instance_native_t *)self)->code_state.state - 1;\n    }\n    #endif\n    if (self->code_state.sp == state_start) {\n        if (send_value != mp_const_none) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"can't send non-None value to a just-started generator\"));\n        }\n    } else {\n        *self->code_state.sp = send_value;\n    }\n\n    \n    self->pend_exc = MP_OBJ_NULL;\n\n    \n    self->code_state.old_globals = mp_globals_get();\n    mp_globals_set(self->code_state.fun_bc->context->module.globals);\n\n    mp_vm_return_kind_t ret_kind;\n\n    #if MICROPY_EMIT_NATIVE\n    if (self->code_state.exc_sp_idx == MP_CODE_STATE_EXC_SP_IDX_SENTINEL) {\n        \n        typedef uintptr_t (*mp_fun_native_gen_t)(void *, mp_obj_t);\n        mp_fun_native_gen_t fun = mp_obj_fun_native_get_generator_resume(self->code_state.fun_bc);\n        ret_kind = fun((void *)&self->code_state, throw_value);\n    } else\n    #endif\n    {\n        \n        ret_kind = mp_execute_bytecode(&self->code_state, throw_value);\n    }\n\n    mp_globals_set(self->code_state.old_globals);\n\n    \n    self->pend_exc = mp_const_none;\n\n    switch (ret_kind) {\n        case MP_VM_RETURN_NORMAL:\n        default:\n            \n            \n            \n            self->code_state.ip = 0;\n            \n            *ret_val = *self->code_state.sp;\n            break;\n\n        case MP_VM_RETURN_YIELD:\n            *ret_val = *self->code_state.sp;\n            #if MICROPY_PY_GENERATOR_PEND_THROW\n            *self->code_state.sp = mp_const_none;\n            #endif\n            break;\n\n        case MP_VM_RETURN_EXCEPTION: {\n            self->code_state.ip = 0;\n            #if MICROPY_EMIT_NATIVE\n            if (self->code_state.exc_sp_idx == MP_CODE_STATE_EXC_SP_IDX_SENTINEL) {\n                *ret_val = ((mp_obj_gen_instance_native_t *)self)->code_state.state[0];\n            } else\n            #endif\n            {\n                *ret_val = self->code_state.state[0];\n            }\n            \n            if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(*ret_val)), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {\n                *ret_val = mp_obj_new_exception_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"generator raised StopIteration\"));\n            }\n            break;\n        }\n    }\n\n    return ret_kind;\n}\n\nstatic mp_obj_t gen_resume_and_raise(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, bool raise_stop_iteration) {\n    mp_obj_t ret;\n    switch (mp_obj_gen_resume(self_in, send_value, throw_value, &ret)) {\n        case MP_VM_RETURN_NORMAL:\n        default:\n            \n            \n            if (ret == mp_const_none) {\n                ret = MP_OBJ_NULL;\n            }\n            if (raise_stop_iteration) {\n                mp_raise_StopIteration(ret);\n            } else {\n                return mp_make_stop_iteration(ret);\n            }\n\n        case MP_VM_RETURN_YIELD:\n            return ret;\n\n        case MP_VM_RETURN_EXCEPTION:\n            nlr_raise(ret);\n    }\n}\n\nstatic mp_obj_t gen_instance_iternext(mp_obj_t self_in) {\n    return gen_resume_and_raise(self_in, mp_const_none, MP_OBJ_NULL, false);\n}\n\nstatic mp_obj_t gen_instance_send(mp_obj_t self_in, mp_obj_t send_value) {\n    return gen_resume_and_raise(self_in, send_value, MP_OBJ_NULL, true);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(gen_instance_send_obj, gen_instance_send);\n\nstatic mp_obj_t gen_instance_throw(size_t n_args, const mp_obj_t *args) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    mp_obj_t exc = args[1];\n    if (n_args > 2 && args[2] != mp_const_none) {\n        exc = args[2];\n    }\n\n    return gen_resume_and_raise(args[0], mp_const_none, exc, true);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(gen_instance_throw_obj, 2, 4, gen_instance_throw);\n\nstatic mp_obj_t gen_instance_close(mp_obj_t self_in) {\n    mp_obj_t ret;\n    switch (mp_obj_gen_resume(self_in, mp_const_none, MP_OBJ_FROM_PTR(&mp_const_GeneratorExit_obj), &ret)) {\n        case MP_VM_RETURN_YIELD:\n            mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"generator ignored GeneratorExit\"));\n\n        \n        case MP_VM_RETURN_EXCEPTION:\n            \n            if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(ret)), MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {\n                return mp_const_none;\n            }\n            nlr_raise(ret);\n\n        default:\n            \n            return mp_const_none;\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(gen_instance_close_obj, gen_instance_close);\n\n#if MICROPY_PY_GENERATOR_PEND_THROW\nstatic mp_obj_t gen_instance_pend_throw(mp_obj_t self_in, mp_obj_t exc_in) {\n    mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->pend_exc == MP_OBJ_NULL) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"generator already executing\"));\n    }\n    mp_obj_t prev = self->pend_exc;\n    self->pend_exc = exc_in;\n    return prev;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(gen_instance_pend_throw_obj, gen_instance_pend_throw);\n#endif\n\nstatic const mp_rom_map_elem_t gen_instance_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&gen_instance_close_obj) },\n    { MP_ROM_QSTR(MP_QSTR_send), MP_ROM_PTR(&gen_instance_send_obj) },\n    { MP_ROM_QSTR(MP_QSTR_throw), MP_ROM_PTR(&gen_instance_throw_obj) },\n    #if MICROPY_PY_GENERATOR_PEND_THROW\n    { MP_ROM_QSTR(MP_QSTR_pend_throw), MP_ROM_PTR(&gen_instance_pend_throw_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(gen_instance_locals_dict, gen_instance_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_gen_instance,\n    MP_QSTR_generator,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    print, gen_instance_print,\n    iter, gen_instance_iternext,\n    locals_dict, &gen_instance_locals_dict\n    );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}