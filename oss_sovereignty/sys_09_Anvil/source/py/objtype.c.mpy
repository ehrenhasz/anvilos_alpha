{
  "module_name": "objtype.c",
  "hash_id": "410114ad7d2993b6f5da2262cc1c20dc99a09fbac04e837f48e4cae45de7a245",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objtype.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/objtype.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\n#define ENABLE_SPECIAL_ACCESSORS \\\n    (MICROPY_PY_DESCRIPTORS || MICROPY_PY_DELATTR_SETATTR || MICROPY_PY_BUILTINS_PROPERTY)\n\nstatic mp_obj_t static_class_method_make_new(const mp_obj_type_t *self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);\n\n \n\n\nstatic int instance_count_native_bases(const mp_obj_type_t *type, const mp_obj_type_t **last_native_base) {\n    int count = 0;\n    for (;;) {\n        if (type == &mp_type_object) {\n            \n            return count;\n        } else if (mp_obj_is_native_type(type)) {\n            \n            *last_native_base = type;\n            return count + 1;\n        } else if (!MP_OBJ_TYPE_HAS_SLOT(type, parent)) {\n            \n            return count;\n        #if MICROPY_MULTIPLE_INHERITANCE\n        } else if (((mp_obj_base_t *)MP_OBJ_TYPE_GET_SLOT(type, parent))->type == &mp_type_tuple) {\n            \n            const mp_obj_tuple_t *parent_tuple = MP_OBJ_TYPE_GET_SLOT(type, parent);\n            const mp_obj_t *item = parent_tuple->items;\n            const mp_obj_t *top = item + parent_tuple->len;\n            for (; item < top; ++item) {\n                assert(mp_obj_is_type(*item, &mp_type_type));\n                const mp_obj_type_t *bt = (const mp_obj_type_t *)MP_OBJ_TO_PTR(*item);\n                count += instance_count_native_bases(bt, last_native_base);\n            }\n            return count;\n        #endif\n        } else {\n            \n            type = MP_OBJ_TYPE_GET_SLOT(type, parent);\n        }\n    }\n}\n\n\n\nstatic mp_obj_t native_base_init_wrapper(size_t n_args, const mp_obj_t *args) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(args[0]);\n    const mp_obj_type_t *native_base = NULL;\n    instance_count_native_bases(self->base.type, &native_base);\n    self->subobj[0] = MP_OBJ_TYPE_GET_SLOT(native_base, make_new)(native_base, n_args - 1, 0, args + 1);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(native_base_init_wrapper_obj, 1, MP_OBJ_FUN_ARGS_MAX, native_base_init_wrapper);\n\n#if !MICROPY_CPYTHON_COMPAT\nstatic\n#endif\nmp_obj_instance_t *mp_obj_new_instance(const mp_obj_type_t *class, const mp_obj_type_t **native_base) {\n    size_t num_native_bases = instance_count_native_bases(class, native_base);\n    assert(num_native_bases < 2);\n    mp_obj_instance_t *o = mp_obj_malloc_var(mp_obj_instance_t, subobj, mp_obj_t, num_native_bases, class);\n    mp_map_init(&o->members, 0);\n    \n    \n    \n    if (num_native_bases != 0) {\n        o->subobj[0] = MP_OBJ_FROM_PTR(&native_base_init_wrapper_obj);\n    }\n    return o;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstruct class_lookup_data {\n    mp_obj_instance_t *obj;\n    qstr attr;\n    size_t slot_offset;\n    mp_obj_t *dest;\n    bool is_type;\n};\n\nstatic void mp_obj_class_lookup(struct class_lookup_data *lookup, const mp_obj_type_t *type) {\n    assert(lookup->dest[0] == MP_OBJ_NULL);\n    assert(lookup->dest[1] == MP_OBJ_NULL);\n    for (;;) {\n        DEBUG_printf(\"mp_obj_class_lookup: Looking up %s in %s\\n\", qstr_str(lookup->attr), qstr_str(type->name));\n        \n        \n        \n        \n        if (lookup->slot_offset != 0 && mp_obj_is_native_type(type)) {\n            \n            \n            \n            if (MP_OBJ_TYPE_HAS_SLOT_BY_OFFSET(type, lookup->slot_offset) || (lookup->slot_offset == MP_OBJ_TYPE_OFFSETOF_SLOT(iter) && type->flags & MP_TYPE_FLAG_ITER_IS_STREAM)) {\n                DEBUG_printf(\"mp_obj_class_lookup: Matched special meth slot (off=%d) for %s\\n\",\n                    lookup->slot_offset, qstr_str(lookup->attr));\n                lookup->dest[0] = MP_OBJ_SENTINEL;\n                return;\n            }\n        }\n\n        if (MP_OBJ_TYPE_HAS_SLOT(type, locals_dict)) {\n            \n            assert(mp_obj_is_dict_or_ordereddict(MP_OBJ_FROM_PTR(MP_OBJ_TYPE_GET_SLOT(type, locals_dict)))); \n            mp_map_t *locals_map = &MP_OBJ_TYPE_GET_SLOT(type, locals_dict)->map;\n            mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(lookup->attr), MP_MAP_LOOKUP);\n            if (elem != NULL) {\n                if (lookup->is_type) {\n                    \n                    \n                    const mp_obj_type_t *org_type = (const mp_obj_type_t *)lookup->obj;\n                    mp_convert_member_lookup(MP_OBJ_NULL, org_type, elem->value, lookup->dest);\n                } else {\n                    mp_obj_instance_t *obj = lookup->obj;\n                    mp_obj_t obj_obj;\n                    if (obj != NULL && mp_obj_is_native_type(type) && type != &mp_type_object  ) {\n                        \n                        obj_obj = obj->subobj[0];\n                    } else {\n                        obj_obj = MP_OBJ_FROM_PTR(obj);\n                    }\n                    mp_convert_member_lookup(obj_obj, type, elem->value, lookup->dest);\n                }\n                #if DEBUG_PRINT\n                DEBUG_printf(\"mp_obj_class_lookup: Returning: \");\n                mp_obj_print_helper(MICROPY_DEBUG_PRINTER, lookup->dest[0], PRINT_REPR);\n                if (lookup->dest[1] != MP_OBJ_NULL) {\n                    \n                    DEBUG_printf(\" <%s @%p>\", mp_obj_get_type_str(lookup->dest[1]), MP_OBJ_TO_PTR(lookup->dest[1]));\n                }\n                DEBUG_printf(\"\\n\");\n                #endif\n                return;\n            }\n        }\n\n        \n        \n        \n        if (lookup->obj != NULL && !lookup->is_type && mp_obj_is_native_type(type) && type != &mp_type_object  ) {\n            mp_load_method_maybe(lookup->obj->subobj[0], lookup->attr, lookup->dest);\n            if (lookup->dest[0] != MP_OBJ_NULL) {\n                return;\n            }\n        }\n\n        \n\n        if (!MP_OBJ_TYPE_HAS_SLOT(type, parent)) {\n            DEBUG_printf(\"mp_obj_class_lookup: No more parents\\n\");\n            return;\n        #if MICROPY_MULTIPLE_INHERITANCE\n        } else if (((mp_obj_base_t *)MP_OBJ_TYPE_GET_SLOT(type, parent))->type == &mp_type_tuple) {\n            const mp_obj_tuple_t *parent_tuple = MP_OBJ_TYPE_GET_SLOT(type, parent);\n            const mp_obj_t *item = parent_tuple->items;\n            const mp_obj_t *top = item + parent_tuple->len - 1;\n            for (; item < top; ++item) {\n                assert(mp_obj_is_type(*item, &mp_type_type));\n                mp_obj_type_t *bt = (mp_obj_type_t *)MP_OBJ_TO_PTR(*item);\n                if (bt == &mp_type_object) {\n                    \n                    continue;\n                }\n                mp_obj_class_lookup(lookup, bt);\n                if (lookup->dest[0] != MP_OBJ_NULL) {\n                    return;\n                }\n            }\n\n            \n            assert(mp_obj_is_type(*item, &mp_type_type));\n            type = (mp_obj_type_t *)MP_OBJ_TO_PTR(*item);\n        #endif\n        } else {\n            type = MP_OBJ_TYPE_GET_SLOT(type, parent);\n        }\n        if (type == &mp_type_object) {\n            \n            return;\n        }\n    }\n}\n\nstatic void instance_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    qstr meth = (kind == PRINT_STR) ? MP_QSTR___str__ : MP_QSTR___repr__;\n    mp_obj_t member[2] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = meth,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(print),\n        .dest = member,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n    if (member[0] == MP_OBJ_NULL && kind == PRINT_STR) {\n        \n        lookup.attr = MP_QSTR___repr__;\n        lookup.slot_offset = 0;\n        mp_obj_class_lookup(&lookup, self->base.type);\n    }\n\n    if (member[0] == MP_OBJ_SENTINEL) {\n        \n        if (mp_obj_is_native_exception_instance(self->subobj[0])) {\n            if (kind != PRINT_STR) {\n                mp_print_str(print, qstr_str(self->base.type->name));\n            }\n            mp_obj_print_helper(print, self->subobj[0], kind | PRINT_EXC_SUBCLASS);\n        } else {\n            mp_obj_print_helper(print, self->subobj[0], kind);\n        }\n        return;\n    }\n\n    if (member[0] != MP_OBJ_NULL) {\n        mp_obj_t r = mp_call_function_1(member[0], self_in);\n        mp_obj_print_helper(print, r, PRINT_STR);\n        return;\n    }\n\n    \n    mp_printf(print, \"<%s object at %p>\", mp_obj_get_type_str(self_in), self);\n}\n\nstatic mp_obj_t mp_obj_instance_make_new(const mp_obj_type_t *self, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    assert(mp_obj_is_instance_type(self));\n\n    \n    mp_obj_t init_fn[2] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = NULL,\n        .attr = MP_QSTR___new__,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(make_new),\n        .dest = init_fn,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self);\n\n    const mp_obj_type_t *native_base = NULL;\n    mp_obj_instance_t *o;\n    if (init_fn[0] == MP_OBJ_NULL || init_fn[0] == MP_OBJ_SENTINEL) {\n        \n        \n        o = mp_obj_new_instance(self, &native_base);\n\n        \n        \n        \n        \n        \n\n    } else {\n        \n        mp_obj_t new_ret;\n        if (n_args == 0 && n_kw == 0) {\n            mp_obj_t args2[1] = {MP_OBJ_FROM_PTR(self)};\n            new_ret = mp_call_function_n_kw(init_fn[0], 1, 0, args2);\n        } else {\n            mp_obj_t *args2 = m_new(mp_obj_t, 1 + n_args + 2 * n_kw);\n            args2[0] = MP_OBJ_FROM_PTR(self);\n            memcpy(args2 + 1, args, (n_args + 2 * n_kw) * sizeof(mp_obj_t));\n            new_ret = mp_call_function_n_kw(init_fn[0], n_args + 1, n_kw, args2);\n            m_del(mp_obj_t, args2, 1 + n_args + 2 * n_kw);\n        }\n\n        \n        \n        \n        if (mp_obj_get_type(new_ret) != self) {\n            return new_ret;\n        }\n\n        \n        o = MP_OBJ_TO_PTR(new_ret);\n    }\n\n    \n    \n    \n    init_fn[0] = init_fn[1] = MP_OBJ_NULL;\n    lookup.obj = o;\n    lookup.attr = MP_QSTR___init__;\n    lookup.slot_offset = 0;\n    mp_obj_class_lookup(&lookup, self);\n    if (init_fn[0] != MP_OBJ_NULL) {\n        mp_obj_t init_ret;\n        if (n_args == 0 && n_kw == 0) {\n            init_ret = mp_call_method_n_kw(0, 0, init_fn);\n        } else {\n            mp_obj_t *args2 = m_new(mp_obj_t, 2 + n_args + 2 * n_kw);\n            args2[0] = init_fn[0];\n            args2[1] = init_fn[1];\n            memcpy(args2 + 2, args, (n_args + 2 * n_kw) * sizeof(mp_obj_t));\n            init_ret = mp_call_method_n_kw(n_args, n_kw, args2);\n            m_del(mp_obj_t, args2, 2 + n_args + 2 * n_kw);\n        }\n        if (init_ret != mp_const_none) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_raise_TypeError(MP_ERROR_TEXT(\"__init__() should return None\"));\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"__init__() should return None, not '%s'\"), mp_obj_get_type_str(init_ret));\n            #endif\n        }\n    }\n\n    \n    \n    if (native_base != NULL && o->subobj[0] == MP_OBJ_FROM_PTR(&native_base_init_wrapper_obj)) {\n        o->subobj[0] = MP_OBJ_TYPE_GET_SLOT(native_base, make_new)(native_base, n_args, n_kw, args);\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\n\n\n\n\nconst byte mp_unary_op_method_name[MP_UNARY_OP_NUM_RUNTIME] = {\n    [MP_UNARY_OP_BOOL] = MP_QSTR___bool__,\n    [MP_UNARY_OP_LEN] = MP_QSTR___len__,\n    [MP_UNARY_OP_HASH] = MP_QSTR___hash__,\n    [MP_UNARY_OP_INT_MAYBE] = MP_QSTR___int__,\n    #if MICROPY_PY_ALL_SPECIAL_METHODS\n    [MP_UNARY_OP_POSITIVE] = MP_QSTR___pos__,\n    [MP_UNARY_OP_NEGATIVE] = MP_QSTR___neg__,\n    [MP_UNARY_OP_INVERT] = MP_QSTR___invert__,\n    [MP_UNARY_OP_ABS] = MP_QSTR___abs__,\n    #endif\n    #if MICROPY_PY_BUILTINS_FLOAT\n    [MP_UNARY_OP_FLOAT_MAYBE] = MP_QSTR___float__,\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    [MP_UNARY_OP_COMPLEX_MAYBE] = MP_QSTR___complex__,\n    #endif\n    #endif\n    #if MICROPY_PY_SYS_GETSIZEOF\n    [MP_UNARY_OP_SIZEOF] = MP_QSTR___sizeof__,\n    #endif\n};\n\nstatic mp_obj_t instance_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n\n    #if MICROPY_PY_SYS_GETSIZEOF\n    if (MP_UNLIKELY(op == MP_UNARY_OP_SIZEOF)) {\n        \n        const mp_obj_type_t *native_base;\n        size_t num_native_bases = instance_count_native_bases(mp_obj_get_type(self_in), &native_base);\n\n        size_t sz = sizeof(*self) + sizeof(*self->subobj) * num_native_bases\n            + sizeof(*self->members.table) * self->members.alloc;\n        return MP_OBJ_NEW_SMALL_INT(sz);\n    }\n    #endif\n\n    qstr op_name = mp_unary_op_method_name[op];\n     \n    mp_obj_t member[2] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = op_name,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(unary_op),\n        .dest = member,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n    if (member[0] == MP_OBJ_SENTINEL) {\n        return mp_unary_op(op, self->subobj[0]);\n    } else if (member[0] != MP_OBJ_NULL) {\n        mp_obj_t val = mp_call_function_1(member[0], self_in);\n\n        switch (op) {\n            case MP_UNARY_OP_HASH:\n                \n                val = MP_OBJ_NEW_SMALL_INT(mp_obj_get_int_truncated(val));\n                break;\n            case MP_UNARY_OP_INT_MAYBE:\n                \n                if (!mp_obj_is_int(val)) {\n                    mp_raise_TypeError(NULL);\n                }\n                break;\n            default:\n                \n                ;\n        }\n        return val;\n    } else {\n        if (op == MP_UNARY_OP_HASH) {\n            lookup.attr = MP_QSTR___eq__;\n            mp_obj_class_lookup(&lookup, self->base.type);\n            if (member[0] == MP_OBJ_NULL) {\n                \n                \n                \n                \n                \n                return MP_OBJ_NEW_SMALL_INT((mp_uint_t)self_in);\n            }\n            \n            \n        }\n\n        return MP_OBJ_NULL; \n    }\n}\n\n\n\n\n\n\n\n\nconst byte mp_binary_op_method_name[MP_BINARY_OP_NUM_RUNTIME] = {\n    [MP_BINARY_OP_LESS] = MP_QSTR___lt__,\n    [MP_BINARY_OP_MORE] = MP_QSTR___gt__,\n    [MP_BINARY_OP_EQUAL] = MP_QSTR___eq__,\n    [MP_BINARY_OP_LESS_EQUAL] = MP_QSTR___le__,\n    [MP_BINARY_OP_MORE_EQUAL] = MP_QSTR___ge__,\n    [MP_BINARY_OP_NOT_EQUAL] = MP_QSTR___ne__,\n    [MP_BINARY_OP_CONTAINS] = MP_QSTR___contains__,\n\n    \n    [MP_BINARY_OP_INPLACE_ADD] = MP_QSTR___iadd__,\n    [MP_BINARY_OP_INPLACE_SUBTRACT] = MP_QSTR___isub__,\n    #if MICROPY_PY_ALL_INPLACE_SPECIAL_METHODS\n    [MP_BINARY_OP_INPLACE_MULTIPLY] = MP_QSTR___imul__,\n    [MP_BINARY_OP_INPLACE_MAT_MULTIPLY] = MP_QSTR___imatmul__,\n    [MP_BINARY_OP_INPLACE_FLOOR_DIVIDE] = MP_QSTR___ifloordiv__,\n    [MP_BINARY_OP_INPLACE_TRUE_DIVIDE] = MP_QSTR___itruediv__,\n    [MP_BINARY_OP_INPLACE_MODULO] = MP_QSTR___imod__,\n    [MP_BINARY_OP_INPLACE_POWER] = MP_QSTR___ipow__,\n    [MP_BINARY_OP_INPLACE_OR] = MP_QSTR___ior__,\n    [MP_BINARY_OP_INPLACE_XOR] = MP_QSTR___ixor__,\n    [MP_BINARY_OP_INPLACE_AND] = MP_QSTR___iand__,\n    [MP_BINARY_OP_INPLACE_LSHIFT] = MP_QSTR___ilshift__,\n    [MP_BINARY_OP_INPLACE_RSHIFT] = MP_QSTR___irshift__,\n    #endif\n\n    [MP_BINARY_OP_ADD] = MP_QSTR___add__,\n    [MP_BINARY_OP_SUBTRACT] = MP_QSTR___sub__,\n    #if MICROPY_PY_ALL_SPECIAL_METHODS\n    [MP_BINARY_OP_MULTIPLY] = MP_QSTR___mul__,\n    [MP_BINARY_OP_MAT_MULTIPLY] = MP_QSTR___matmul__,\n    [MP_BINARY_OP_FLOOR_DIVIDE] = MP_QSTR___floordiv__,\n    [MP_BINARY_OP_TRUE_DIVIDE] = MP_QSTR___truediv__,\n    [MP_BINARY_OP_MODULO] = MP_QSTR___mod__,\n    [MP_BINARY_OP_DIVMOD] = MP_QSTR___divmod__,\n    [MP_BINARY_OP_POWER] = MP_QSTR___pow__,\n    [MP_BINARY_OP_OR] = MP_QSTR___or__,\n    [MP_BINARY_OP_XOR] = MP_QSTR___xor__,\n    [MP_BINARY_OP_AND] = MP_QSTR___and__,\n    [MP_BINARY_OP_LSHIFT] = MP_QSTR___lshift__,\n    [MP_BINARY_OP_RSHIFT] = MP_QSTR___rshift__,\n    #endif\n\n    #if MICROPY_PY_REVERSE_SPECIAL_METHODS\n    [MP_BINARY_OP_REVERSE_ADD] = MP_QSTR___radd__,\n    [MP_BINARY_OP_REVERSE_SUBTRACT] = MP_QSTR___rsub__,\n    #if MICROPY_PY_ALL_SPECIAL_METHODS\n    [MP_BINARY_OP_REVERSE_MULTIPLY] = MP_QSTR___rmul__,\n    [MP_BINARY_OP_REVERSE_MAT_MULTIPLY] = MP_QSTR___rmatmul__,\n    [MP_BINARY_OP_REVERSE_FLOOR_DIVIDE] = MP_QSTR___rfloordiv__,\n    [MP_BINARY_OP_REVERSE_TRUE_DIVIDE] = MP_QSTR___rtruediv__,\n    [MP_BINARY_OP_REVERSE_MODULO] = MP_QSTR___rmod__,\n    [MP_BINARY_OP_REVERSE_POWER] = MP_QSTR___rpow__,\n    [MP_BINARY_OP_REVERSE_OR] = MP_QSTR___ror__,\n    [MP_BINARY_OP_REVERSE_XOR] = MP_QSTR___rxor__,\n    [MP_BINARY_OP_REVERSE_AND] = MP_QSTR___rand__,\n    [MP_BINARY_OP_REVERSE_LSHIFT] = MP_QSTR___rlshift__,\n    [MP_BINARY_OP_REVERSE_RSHIFT] = MP_QSTR___rrshift__,\n    #endif\n    #endif\n};\n\nstatic mp_obj_t instance_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    \n    \n    mp_obj_instance_t *lhs = MP_OBJ_TO_PTR(lhs_in);\n    qstr op_name = mp_binary_op_method_name[op];\n     \n    mp_obj_t dest[3] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = lhs,\n        .attr = op_name,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(binary_op),\n        .dest = dest,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, lhs->base.type);\n\n    mp_obj_t res;\n    if (dest[0] == MP_OBJ_SENTINEL) {\n        res = mp_binary_op(op, lhs->subobj[0], rhs_in);\n    } else if (dest[0] != MP_OBJ_NULL) {\n        dest[2] = rhs_in;\n        res = mp_call_method_n_kw(1, 0, dest);\n        res = op == MP_BINARY_OP_CONTAINS ? mp_obj_new_bool(mp_obj_is_true(res)) : res;\n    } else {\n        return MP_OBJ_NULL; \n    }\n\n    #if MICROPY_PY_BUILTINS_NOTIMPLEMENTED\n    \n    \n    if (res == mp_const_notimplemented) {\n        return MP_OBJ_NULL; \n    }\n    #endif\n\n    return res;\n}\n\nstatic void mp_obj_instance_load_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    \n    assert(mp_obj_is_instance_type(mp_obj_get_type(self_in)));\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    mp_map_elem_t *elem = mp_map_lookup(&self->members, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);\n    if (elem != NULL) {\n        \n        dest[0] = elem->value;\n        return;\n    }\n    #if MICROPY_CPYTHON_COMPAT\n    if (attr == MP_QSTR___dict__) {\n        \n        \n        mp_obj_dict_t dict;\n        dict.base.type = &mp_type_dict;\n        dict.map = self->members;\n        dest[0] = mp_obj_dict_copy(MP_OBJ_FROM_PTR(&dict));\n        mp_obj_dict_t *dest_dict = MP_OBJ_TO_PTR(dest[0]);\n        dest_dict->map.is_fixed = 1;\n        return;\n    }\n    #endif\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = attr,\n        .slot_offset = 0,\n        .dest = dest,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n    mp_obj_t member = dest[0];\n    if (member != MP_OBJ_NULL) {\n        if (!(self->base.type->flags & MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS)) {\n            \n            return;\n        }\n\n        #if MICROPY_PY_BUILTINS_PROPERTY\n        if (mp_obj_is_type(member, &mp_type_property)) {\n            \n            \n            \n            \n            \n            \n            \n            const mp_obj_t *proxy = mp_obj_property_get(member);\n            if (proxy[0] == mp_const_none) {\n                mp_raise_msg(&mp_type_AttributeError, MP_ERROR_TEXT(\"unreadable attribute\"));\n            } else {\n                dest[0] = mp_call_function_n_kw(proxy[0], 1, 0, &self_in);\n            }\n            return;\n        }\n        #endif\n\n        #if MICROPY_PY_DESCRIPTORS\n        \n        \n        \n        \n        mp_obj_t attr_get_method[4];\n        mp_load_method_maybe(member, MP_QSTR___get__, attr_get_method);\n        if (attr_get_method[0] != MP_OBJ_NULL) {\n            attr_get_method[2] = self_in;\n            attr_get_method[3] = MP_OBJ_FROM_PTR(mp_obj_get_type(self_in));\n            dest[0] = mp_call_method_n_kw(2, 0, attr_get_method);\n        }\n        #endif\n        return;\n    }\n\n    \n    if (attr != MP_QSTR___getattr__) {\n        #if MICROPY_PY_DELATTR_SETATTR\n        \n        \n        \n        if (attr == MP_QSTR___setattr__ || attr == MP_QSTR___delattr__) {\n            return;\n        }\n        #endif\n\n        mp_obj_t dest2[3];\n        mp_load_method_maybe(self_in, MP_QSTR___getattr__, dest2);\n        if (dest2[0] != MP_OBJ_NULL) {\n            \n            dest2[2] = MP_OBJ_NEW_QSTR(attr);\n            dest[0] = mp_call_method_n_kw(1, 0, dest2);\n            return;\n        }\n    }\n}\n\nstatic bool mp_obj_instance_store_attr(mp_obj_t self_in, qstr attr, mp_obj_t value) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (!(self->base.type->flags & MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS)) {\n        \n        goto skip_special_accessors;\n    }\n\n    #if MICROPY_PY_BUILTINS_PROPERTY || MICROPY_PY_DESCRIPTORS\n    \n    \n    \n    mp_obj_t member[2] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = attr,\n        .slot_offset = 0,\n        .dest = member,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n\n    if (member[0] != MP_OBJ_NULL) {\n        #if MICROPY_PY_BUILTINS_PROPERTY\n        if (mp_obj_is_type(member[0], &mp_type_property)) {\n            \n            \n            \n            \n            \n            \n            \n            const mp_obj_t *proxy = mp_obj_property_get(member[0]);\n            mp_obj_t dest[2] = {self_in, value};\n            if (value == MP_OBJ_NULL) {\n                \n                if (proxy[2] == mp_const_none) {\n                    \n                    return false;\n                } else {\n                    mp_call_function_n_kw(proxy[2], 1, 0, dest);\n                    return true;\n                }\n            } else {\n                \n                if (proxy[1] == mp_const_none) {\n                    \n                    return false;\n                } else {\n                    mp_call_function_n_kw(proxy[1], 2, 0, dest);\n                    return true;\n                }\n            }\n        }\n        #endif\n\n        #if MICROPY_PY_DESCRIPTORS\n        \n        \n        if (value == MP_OBJ_NULL) {\n            \n            mp_obj_t attr_delete_method[3];\n            mp_load_method_maybe(member[0], MP_QSTR___delete__, attr_delete_method);\n            if (attr_delete_method[0] != MP_OBJ_NULL) {\n                attr_delete_method[2] = self_in;\n                mp_call_method_n_kw(1, 0, attr_delete_method);\n                return true;\n            }\n        } else {\n            \n            mp_obj_t attr_set_method[4];\n            mp_load_method_maybe(member[0], MP_QSTR___set__, attr_set_method);\n            if (attr_set_method[0] != MP_OBJ_NULL) {\n                attr_set_method[2] = self_in;\n                attr_set_method[3] = value;\n                mp_call_method_n_kw(2, 0, attr_set_method);\n                return true;\n            }\n        }\n        #endif\n    }\n    #endif\n\n    #if MICROPY_PY_DELATTR_SETATTR\n    if (value == MP_OBJ_NULL) {\n        \n        \n        mp_obj_t attr_delattr_method[3];\n        mp_load_method_maybe(self_in, MP_QSTR___delattr__, attr_delattr_method);\n        if (attr_delattr_method[0] != MP_OBJ_NULL) {\n            \n            attr_delattr_method[2] = MP_OBJ_NEW_QSTR(attr);\n            mp_call_method_n_kw(1, 0, attr_delattr_method);\n            return true;\n        }\n    } else {\n        \n        \n        mp_obj_t attr_setattr_method[4];\n        mp_load_method_maybe(self_in, MP_QSTR___setattr__, attr_setattr_method);\n        if (attr_setattr_method[0] != MP_OBJ_NULL) {\n            \n            attr_setattr_method[2] = MP_OBJ_NEW_QSTR(attr);\n            attr_setattr_method[3] = value;\n            mp_call_method_n_kw(2, 0, attr_setattr_method);\n            return true;\n        }\n    }\n    #endif\n\nskip_special_accessors:\n\n    if (value == MP_OBJ_NULL) {\n        \n        mp_map_elem_t *elem = mp_map_lookup(&self->members, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n        return elem != NULL;\n    } else {\n        \n        mp_map_lookup(&self->members, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;\n        return true;\n    }\n}\n\nstatic void mp_obj_instance_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] == MP_OBJ_NULL) {\n        mp_obj_instance_load_attr(self_in, attr, dest);\n    } else {\n        if (mp_obj_instance_store_attr(self_in, attr, dest[1])) {\n            dest[0] = MP_OBJ_NULL; \n        }\n    }\n}\n\nstatic mp_obj_t instance_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t member[4] = {MP_OBJ_NULL, MP_OBJ_NULL, index, value};\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(subscr),\n        .dest = member,\n        .is_type = false,\n    };\n    if (value == MP_OBJ_NULL) {\n        \n        lookup.attr = MP_QSTR___delitem__;\n    } else if (value == MP_OBJ_SENTINEL) {\n        \n        lookup.attr = MP_QSTR___getitem__;\n    } else {\n        \n        lookup.attr = MP_QSTR___setitem__;\n    }\n    mp_obj_class_lookup(&lookup, self->base.type);\n    if (member[0] == MP_OBJ_SENTINEL) {\n        return mp_obj_subscr(self->subobj[0], index, value);\n    } else if (member[0] != MP_OBJ_NULL) {\n        size_t n_args = value == MP_OBJ_NULL || value == MP_OBJ_SENTINEL ? 1 : 2;\n        mp_obj_t ret = mp_call_method_n_kw(n_args, 0, member);\n        if (value == MP_OBJ_SENTINEL) {\n            return ret;\n        } else {\n            return mp_const_none;\n        }\n    } else {\n        return MP_OBJ_NULL; \n    }\n}\n\nstatic mp_obj_t mp_obj_instance_get_call(mp_obj_t self_in, mp_obj_t *member) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = MP_QSTR___call__,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(call),\n        .dest = member,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n    return member[0];\n}\n\nbool mp_obj_instance_is_callable(mp_obj_t self_in) {\n    mp_obj_t member[2] = {MP_OBJ_NULL, MP_OBJ_NULL};\n    return mp_obj_instance_get_call(self_in, member) != MP_OBJ_NULL;\n}\n\nmp_obj_t mp_obj_instance_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_t member[2] = {MP_OBJ_NULL, MP_OBJ_NULL};\n    mp_obj_t call = mp_obj_instance_get_call(self_in, member);\n    if (call == MP_OBJ_NULL) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"object not callable\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"'%s' object isn't callable\"), mp_obj_get_type_str(self_in));\n        #endif\n    }\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    if (call == MP_OBJ_SENTINEL) {\n        return mp_call_function_n_kw(self->subobj[0], n_args, n_kw, args);\n    }\n\n    return mp_call_method_self_n_kw(member[0], member[1], n_args, n_kw, args);\n}\n\n\nmp_obj_t mp_obj_instance_getiter(mp_obj_t self_in, mp_obj_iter_buf_t *iter_buf) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t member[2] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = MP_QSTR___iter__,\n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(iter),\n        .dest = member,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n    if (member[0] == MP_OBJ_NULL) {\n        return MP_OBJ_NULL;\n    } else if (member[0] == MP_OBJ_SENTINEL) {\n        const mp_obj_type_t *type = mp_obj_get_type(self->subobj[0]);\n        if (type->flags & MP_TYPE_FLAG_ITER_IS_ITERNEXT) {\n            return self->subobj[0];\n        } else {\n            if (iter_buf == NULL) {\n                iter_buf = m_new_obj(mp_obj_iter_buf_t);\n            }\n            return ((mp_getiter_fun_t)MP_OBJ_TYPE_GET_SLOT(type, iter))(self->subobj[0], iter_buf);\n        }\n    } else {\n        return mp_call_method_n_kw(0, 0, member);\n    }\n}\n\nstatic mp_int_t instance_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t member[2] = {MP_OBJ_NULL};\n    struct class_lookup_data lookup = {\n        .obj = self,\n        .attr = MP_QSTR_, \n        .slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(buffer),\n        .dest = member,\n        .is_type = false,\n    };\n    mp_obj_class_lookup(&lookup, self->base.type);\n    if (member[0] == MP_OBJ_SENTINEL) {\n        const mp_obj_type_t *type = mp_obj_get_type(self->subobj[0]);\n        return MP_OBJ_TYPE_GET_SLOT(type, buffer)(self->subobj[0], bufinfo, flags);\n    } else {\n        return 1; \n    }\n}\n\n \n\n\n\n\n\n#if ENABLE_SPECIAL_ACCESSORS\nstatic bool check_for_special_accessors(mp_obj_t key, mp_obj_t value) {\n    #if MICROPY_PY_DELATTR_SETATTR\n    if (key == MP_OBJ_NEW_QSTR(MP_QSTR___setattr__) || key == MP_OBJ_NEW_QSTR(MP_QSTR___delattr__)) {\n        return true;\n    }\n    #endif\n    #if MICROPY_PY_BUILTINS_PROPERTY\n    if (mp_obj_is_type(value, &mp_type_property)) {\n        return true;\n    }\n    #endif\n    #if MICROPY_PY_DESCRIPTORS\n    static const uint8_t to_check[] = {\n        MP_QSTR___get__, MP_QSTR___set__, MP_QSTR___delete__,\n    };\n    for (size_t i = 0; i < MP_ARRAY_SIZE(to_check); ++i) {\n        mp_obj_t dest_temp[2];\n        mp_load_method_protected(value, to_check[i], dest_temp, true);\n        if (dest_temp[0] != MP_OBJ_NULL) {\n            return true;\n        }\n    }\n    #endif\n    return false;\n}\n#endif\n\nstatic void type_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_printf(print, \"<class '%q'>\", self->name);\n}\n\nstatic mp_obj_t type_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n\n    mp_arg_check_num(n_args, n_kw, 1, 3, false);\n\n    switch (n_args) {\n        case 1:\n            return MP_OBJ_FROM_PTR(mp_obj_get_type(args[0]));\n\n        case 3:\n            \n            \n            \n            return mp_obj_new_type(mp_obj_str_get_qstr(args[0]), args[1], args[2]);\n\n        default:\n            mp_raise_TypeError(MP_ERROR_TEXT(\"type takes 1 or 3 arguments\"));\n    }\n}\n\nstatic mp_obj_t type_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n\n    mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (!MP_OBJ_TYPE_HAS_SLOT(self, make_new)) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"can't create instance\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError, MP_ERROR_TEXT(\"can't create '%q' instances\"), self->name);\n        #endif\n    }\n\n    \n    mp_obj_t o = MP_OBJ_TYPE_GET_SLOT(self, make_new)(self, n_args, n_kw, args);\n\n    \n    return o;\n}\n\nstatic void type_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    assert(mp_obj_is_type(self_in, &mp_type_type));\n    mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        #if MICROPY_CPYTHON_COMPAT\n        if (attr == MP_QSTR___name__) {\n            dest[0] = MP_OBJ_NEW_QSTR(self->name);\n            return;\n        }\n        #if MICROPY_CPYTHON_COMPAT\n        if (attr == MP_QSTR___dict__) {\n            \n            \n            const mp_obj_dict_t *dict = MP_OBJ_TYPE_GET_SLOT_OR_NULL(self, locals_dict);\n            if (!dict) {\n                dict = &mp_const_empty_dict_obj;\n            }\n            if (dict->map.is_fixed) {\n                dest[0] = MP_OBJ_FROM_PTR(dict);\n            } else {\n                dest[0] = mp_obj_dict_copy(MP_OBJ_FROM_PTR(dict));\n                mp_obj_dict_t *dict_copy = MP_OBJ_TO_PTR(dest[0]);\n                dict_copy->map.is_fixed = 1;\n            }\n            return;\n        }\n        #endif\n        if (attr == MP_QSTR___bases__) {\n            if (self == &mp_type_object) {\n                dest[0] = mp_const_empty_tuple;\n                return;\n            }\n            mp_obj_t parent_obj = MP_OBJ_TYPE_HAS_SLOT(self, parent) ? MP_OBJ_FROM_PTR(MP_OBJ_TYPE_GET_SLOT(self, parent)) : MP_OBJ_FROM_PTR(&mp_type_object);\n            #if MICROPY_MULTIPLE_INHERITANCE\n            if (mp_obj_is_type(parent_obj, &mp_type_tuple)) {\n                dest[0] = parent_obj;\n                return;\n            }\n            #endif\n            dest[0] = mp_obj_new_tuple(1, &parent_obj);\n            return;\n        }\n        #endif\n        struct class_lookup_data lookup = {\n            .obj = (mp_obj_instance_t *)self,\n            .attr = attr,\n            .slot_offset = 0,\n            .dest = dest,\n            .is_type = true,\n        };\n        mp_obj_class_lookup(&lookup, self);\n    } else {\n        \n\n        if (MP_OBJ_TYPE_HAS_SLOT(self, locals_dict)) {\n            assert(mp_obj_is_dict_or_ordereddict(MP_OBJ_FROM_PTR(MP_OBJ_TYPE_GET_SLOT(self, locals_dict)))); \n            mp_map_t *locals_map = &MP_OBJ_TYPE_GET_SLOT(self, locals_dict)->map;\n            if (locals_map->is_fixed) {\n                \n                return;\n            }\n            if (dest[1] == MP_OBJ_NULL) {\n                \n                mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n                if (elem != NULL) {\n                    dest[0] = MP_OBJ_NULL; \n                }\n            } else {\n                #if ENABLE_SPECIAL_ACCESSORS\n                \n                if (!(self->flags & MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS)) {\n                    if (check_for_special_accessors(MP_OBJ_NEW_QSTR(attr), dest[1])) {\n                        if (self->flags & MP_TYPE_FLAG_IS_SUBCLASSED) {\n                            \n                            mp_raise_msg(&mp_type_AttributeError, MP_ERROR_TEXT(\"can't add special method to already-subclassed class\"));\n                        }\n                        self->flags |= MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS;\n                    }\n                }\n                #endif\n\n                \n                mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n                elem->value = dest[1];\n                dest[0] = MP_OBJ_NULL; \n            }\n        }\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_type,\n    MP_QSTR_type,\n    MP_TYPE_FLAG_NONE,\n    make_new, type_make_new,\n    print, type_print,\n    call, type_call,\n    attr, type_attr\n    );\n\nmp_obj_t mp_obj_new_type(qstr name, mp_obj_t bases_tuple, mp_obj_t locals_dict) {\n    \n    if (!mp_obj_is_type(bases_tuple, &mp_type_tuple)) {\n        mp_raise_TypeError(NULL);\n    }\n    if (!mp_obj_is_dict_or_ordereddict(locals_dict)) {\n        mp_raise_TypeError(NULL);\n    }\n\n    \n\n    \n    uint16_t base_flags = MP_TYPE_FLAG_EQ_NOT_REFLEXIVE\n        | MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE\n        | MP_TYPE_FLAG_EQ_HAS_NEQ_TEST\n        | MP_TYPE_FLAG_ITER_IS_GETITER\n        | MP_TYPE_FLAG_INSTANCE_TYPE;\n    size_t bases_len;\n    mp_obj_t *bases_items;\n    mp_obj_tuple_get(bases_tuple, &bases_len, &bases_items);\n    for (size_t i = 0; i < bases_len; i++) {\n        if (!mp_obj_is_type(bases_items[i], &mp_type_type)) {\n            mp_raise_TypeError(NULL);\n        }\n        mp_obj_type_t *t = MP_OBJ_TO_PTR(bases_items[i]);\n        \n        if (!MP_OBJ_TYPE_HAS_SLOT(t, make_new)) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_raise_TypeError(MP_ERROR_TEXT(\"type isn't an acceptable base type\"));\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"type '%q' isn't an acceptable base type\"), t->name);\n            #endif\n        }\n        #if ENABLE_SPECIAL_ACCESSORS\n        if (mp_obj_is_instance_type(t)) {\n            t->flags |= MP_TYPE_FLAG_IS_SUBCLASSED;\n            base_flags |= t->flags & MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS;\n        }\n        #endif\n    }\n\n    const void *base_protocol = NULL;\n    if (bases_len > 0) {\n        base_protocol = MP_OBJ_TYPE_GET_SLOT_OR_NULL(((mp_obj_type_t *)MP_OBJ_TO_PTR(bases_items[0])), protocol);\n    }\n\n    \n    \n    \n    \n    mp_obj_type_t *o = m_new_obj_var0(mp_obj_type_t, slots, void *, 10 + (bases_len ? 1 : 0) + (base_protocol ? 1 : 0));\n    o->base.type = &mp_type_type;\n    o->flags = base_flags;\n    o->name = name;\n    MP_OBJ_TYPE_SET_SLOT(o, make_new, mp_obj_instance_make_new, 0);\n    MP_OBJ_TYPE_SET_SLOT(o, print, instance_print, 1);\n    MP_OBJ_TYPE_SET_SLOT(o, call, mp_obj_instance_call, 2);\n    MP_OBJ_TYPE_SET_SLOT(o, unary_op, instance_unary_op, 3);\n    MP_OBJ_TYPE_SET_SLOT(o, binary_op, instance_binary_op, 4);\n    MP_OBJ_TYPE_SET_SLOT(o, attr, mp_obj_instance_attr, 5);\n    MP_OBJ_TYPE_SET_SLOT(o, subscr, instance_subscr, 6);\n    MP_OBJ_TYPE_SET_SLOT(o, iter, mp_obj_instance_getiter, 7);\n    MP_OBJ_TYPE_SET_SLOT(o, buffer, instance_get_buffer, 8);\n\n    mp_obj_dict_t *locals_ptr = MP_OBJ_TO_PTR(locals_dict);\n    MP_OBJ_TYPE_SET_SLOT(o, locals_dict, locals_ptr, 9);\n\n    if (bases_len > 0) {\n        if (bases_len >= 2) {\n            #if MICROPY_MULTIPLE_INHERITANCE\n            MP_OBJ_TYPE_SET_SLOT(o, parent, MP_OBJ_TO_PTR(bases_tuple), 10);\n            #else\n            mp_raise_NotImplementedError(MP_ERROR_TEXT(\"multiple inheritance not supported\"));\n            #endif\n        } else {\n            MP_OBJ_TYPE_SET_SLOT(o, parent, MP_OBJ_TO_PTR(bases_items[0]), 10);\n        }\n\n        \n        \n        \n        \n        if (base_protocol) {\n            MP_OBJ_TYPE_SET_SLOT(o, protocol, base_protocol, 11);\n        }\n    }\n\n    #if ENABLE_SPECIAL_ACCESSORS\n    \n    if (!(o->flags & MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS)) {\n        for (size_t i = 0; i < locals_ptr->map.alloc; i++) {\n            if (mp_map_slot_is_filled(&locals_ptr->map, i)) {\n                const mp_map_elem_t *elem = &locals_ptr->map.table[i];\n                if (check_for_special_accessors(elem->key, elem->value)) {\n                    o->flags |= MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS;\n                    break;\n                }\n            }\n        }\n    }\n    #endif\n\n    const mp_obj_type_t *native_base;\n    size_t num_native_bases = instance_count_native_bases(o, &native_base);\n    if (num_native_bases > 1) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"multiple bases have instance lay-out conflict\"));\n    }\n\n    mp_map_t *locals_map = &MP_OBJ_TYPE_GET_SLOT(o, locals_dict)->map;\n    mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(MP_QSTR___new__), MP_MAP_LOOKUP);\n    if (elem != NULL) {\n        \n        if (mp_obj_is_fun(elem->value)) {\n            \n            elem->value = static_class_method_make_new(&mp_type_staticmethod, 1, 0, &elem->value);\n        }\n    }\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n\n\ntypedef struct _mp_obj_super_t {\n    mp_obj_base_t base;\n    mp_obj_t type;\n    mp_obj_t obj;\n} mp_obj_super_t;\n\nstatic void super_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_super_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_print_str(print, \"<super: \");\n    mp_obj_print_helper(print, self->type, PRINT_STR);\n    mp_print_str(print, \", \");\n    mp_obj_print_helper(print, self->obj, PRINT_STR);\n    mp_print_str(print, \">\");\n}\n\nstatic mp_obj_t super_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    \n    \n    mp_arg_check_num(n_args, n_kw, 2, 2, false);\n    if (!mp_obj_is_type(args[0], &mp_type_type)) {\n        mp_raise_TypeError(NULL);\n    }\n    mp_obj_super_t *o = m_new_obj(mp_obj_super_t);\n    *o = (mp_obj_super_t) {{type_in}, args[0], args[1]};\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic void super_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n\n    assert(mp_obj_is_type(self_in, &mp_type_super));\n    mp_obj_super_t *self = MP_OBJ_TO_PTR(self_in);\n\n    assert(mp_obj_is_type(self->type, &mp_type_type));\n\n    mp_obj_type_t *type = MP_OBJ_TO_PTR(self->type);\n\n    struct class_lookup_data lookup = {\n        .obj = MP_OBJ_TO_PTR(self->obj),\n        .attr = attr,\n        .slot_offset = 0,\n        .dest = dest,\n        .is_type = false,\n    };\n\n    \n    if (attr == MP_QSTR___init__) {\n        lookup.slot_offset = MP_OBJ_TYPE_OFFSETOF_SLOT(make_new);\n    }\n\n    if (!MP_OBJ_TYPE_HAS_SLOT(type, parent)) {\n        \n    #if MICROPY_MULTIPLE_INHERITANCE\n    } else if (((mp_obj_base_t *)MP_OBJ_TYPE_GET_SLOT(type, parent))->type == &mp_type_tuple) {\n        const mp_obj_tuple_t *parent_tuple = MP_OBJ_TYPE_GET_SLOT(type, parent);\n        size_t len = parent_tuple->len;\n        const mp_obj_t *items = parent_tuple->items;\n        for (size_t i = 0; i < len; i++) {\n            assert(mp_obj_is_type(items[i], &mp_type_type));\n            if (MP_OBJ_TO_PTR(items[i]) == &mp_type_object) {\n                \n                \n                continue;\n            }\n\n            mp_obj_class_lookup(&lookup, (mp_obj_type_t *)MP_OBJ_TO_PTR(items[i]));\n            if (dest[0] != MP_OBJ_NULL) {\n                break;\n            }\n        }\n    #endif\n    } else if (MP_OBJ_TYPE_GET_SLOT(type, parent) != &mp_type_object) {\n        mp_obj_class_lookup(&lookup, MP_OBJ_TYPE_GET_SLOT(type, parent));\n    }\n\n    if (dest[0] != MP_OBJ_NULL) {\n        if (dest[0] == MP_OBJ_SENTINEL) {\n            \n            dest[0] = MP_OBJ_FROM_PTR(&native_base_init_wrapper_obj);\n            dest[1] = self->obj;\n        }\n        return;\n    }\n\n    \n    \n    lookup.slot_offset = 0;\n\n    mp_obj_class_lookup(&lookup, &mp_type_object);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_super,\n    MP_QSTR_super,\n    MP_TYPE_FLAG_NONE,\n    make_new, super_make_new,\n    print, super_print,\n    attr, super_attr\n    );\n\nvoid mp_load_super_method(qstr attr, mp_obj_t *dest) {\n    mp_obj_super_t super = {{&mp_type_super}, dest[1], dest[2]};\n    mp_load_method(MP_OBJ_FROM_PTR(&super), attr, dest);\n}\n\n \n\n\n\n\nbool mp_obj_is_subclass_fast(mp_const_obj_t object, mp_const_obj_t classinfo) {\n    for (;;) {\n        if (object == classinfo) {\n            return true;\n        }\n\n        \n\n        \n        if (!mp_obj_is_type(object, &mp_type_type)) {\n            return false;\n        }\n\n        const mp_obj_type_t *self = MP_OBJ_TO_PTR(object);\n\n        if (!MP_OBJ_TYPE_HAS_SLOT(self, parent)) {\n            \n            return false;\n        #if MICROPY_MULTIPLE_INHERITANCE\n        } else if (((mp_obj_base_t *)MP_OBJ_TYPE_GET_SLOT(self, parent))->type == &mp_type_tuple) {\n            \n            const mp_obj_tuple_t *parent_tuple = MP_OBJ_TYPE_GET_SLOT(self, parent);\n            const mp_obj_t *item = parent_tuple->items;\n            const mp_obj_t *top = item + parent_tuple->len - 1;\n\n            \n            for (; item < top; ++item) {\n                if (mp_obj_is_subclass_fast(*item, classinfo)) {\n                    return true;\n                }\n            }\n\n            \n            object = *item;\n        #endif\n        } else {\n            \n            object = MP_OBJ_FROM_PTR(MP_OBJ_TYPE_GET_SLOT(self, parent));\n        }\n    }\n}\n\nstatic mp_obj_t mp_obj_is_subclass(mp_obj_t object, mp_obj_t classinfo) {\n    size_t len;\n    mp_obj_t *items;\n    if (mp_obj_is_type(classinfo, &mp_type_type)) {\n        len = 1;\n        items = &classinfo;\n    } else if (mp_obj_is_type(classinfo, &mp_type_tuple)) {\n        mp_obj_tuple_get(classinfo, &len, &items);\n    } else {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"issubclass() arg 2 must be a class or a tuple of classes\"));\n    }\n\n    for (size_t i = 0; i < len; i++) {\n        \n        if (items[i] == MP_OBJ_FROM_PTR(&mp_type_object) || mp_obj_is_subclass_fast(object, items[i])) {\n            return mp_const_true;\n        }\n    }\n    return mp_const_false;\n}\n\nstatic mp_obj_t mp_builtin_issubclass(mp_obj_t object, mp_obj_t classinfo) {\n    if (!mp_obj_is_type(object, &mp_type_type)) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"issubclass() arg 1 must be a class\"));\n    }\n    return mp_obj_is_subclass(object, classinfo);\n}\n\nMP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_issubclass_obj, mp_builtin_issubclass);\n\nstatic mp_obj_t mp_builtin_isinstance(mp_obj_t object, mp_obj_t classinfo) {\n    return mp_obj_is_subclass(MP_OBJ_FROM_PTR(mp_obj_get_type(object)), classinfo);\n}\n\nMP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_isinstance_obj, mp_builtin_isinstance);\n\nmp_obj_t mp_obj_cast_to_native_base(mp_obj_t self_in, mp_const_obj_t native_type) {\n    const mp_obj_type_t *self_type = mp_obj_get_type(self_in);\n\n    if (MP_OBJ_FROM_PTR(self_type) == native_type) {\n        return self_in;\n    } else if (!mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(self_type), native_type)) {\n        return MP_OBJ_NULL;\n    } else {\n        mp_obj_instance_t *self = (mp_obj_instance_t *)MP_OBJ_TO_PTR(self_in);\n        return self->subobj[0];\n    }\n}\n\n \n\n\nstatic mp_obj_t static_class_method_make_new(const mp_obj_type_t *self, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    assert(self == &mp_type_staticmethod || self == &mp_type_classmethod);\n\n    mp_arg_check_num(n_args, n_kw, 1, 1, false);\n\n    mp_obj_static_class_method_t *o = m_new_obj(mp_obj_static_class_method_t);\n    *o = (mp_obj_static_class_method_t) {{self}, args[0]};\n    return MP_OBJ_FROM_PTR(o);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_staticmethod,\n    MP_QSTR_staticmethod,\n    MP_TYPE_FLAG_NONE,\n    make_new, static_class_method_make_new\n    );\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_classmethod,\n    MP_QSTR_classmethod,\n    MP_TYPE_FLAG_NONE,\n    make_new, static_class_method_make_new\n    );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}