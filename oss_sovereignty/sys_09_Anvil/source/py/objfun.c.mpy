{
  "module_name": "objfun.c",
  "hash_id": "16d03f8864c05f9003802d6d2421f7368abe7bcb2517d15a07f6dd0b66bdefe4",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objfun.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/objtuple.h\"\n#include \"py/objfun.h\"\n#include \"py/runtime.h\"\n#include \"py/bc.h\"\n#include \"py/stackctrl.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\n\n\n\n\n \n \n\nstatic mp_obj_t fun_builtin_0_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)args;\n    assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_0));\n    mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_arg_check_num(n_args, n_kw, 0, 0, false);\n    return self->fun._0();\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_builtin_0, MP_QSTR_function, MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,\n    call, fun_builtin_0_call\n    );\n\nstatic mp_obj_t fun_builtin_1_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_1));\n    mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_arg_check_num(n_args, n_kw, 1, 1, false);\n    return self->fun._1(args[0]);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_builtin_1, MP_QSTR_function, MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,\n    call, fun_builtin_1_call\n    );\n\nstatic mp_obj_t fun_builtin_2_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_2));\n    mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_arg_check_num(n_args, n_kw, 2, 2, false);\n    return self->fun._2(args[0], args[1]);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_builtin_2, MP_QSTR_function, MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,\n    call, fun_builtin_2_call\n    );\n\nstatic mp_obj_t fun_builtin_3_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_3));\n    mp_obj_fun_builtin_fixed_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_arg_check_num(n_args, n_kw, 3, 3, false);\n    return self->fun._3(args[0], args[1], args[2]);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_builtin_3, MP_QSTR_function, MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,\n    call, fun_builtin_3_call\n    );\n\nstatic mp_obj_t fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    assert(mp_obj_is_type(self_in, &mp_type_fun_builtin_var));\n    mp_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    mp_arg_check_num_sig(n_args, n_kw, self->sig);\n\n    if (self->sig & 1) {\n        \n\n        \n        mp_map_t kw_args;\n        mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);\n\n        return self->fun.kw(n_args, args, &kw_args);\n\n    } else {\n        \n\n        return self->fun.var(n_args, args);\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_builtin_var, MP_QSTR_function, MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,\n    call, fun_builtin_var_call\n    );\n\n \n \n\nqstr mp_obj_fun_get_name(mp_const_obj_t fun_in) {\n    const mp_obj_fun_bc_t *fun = MP_OBJ_TO_PTR(fun_in);\n    const byte *bc = fun->bytecode;\n\n    #if MICROPY_EMIT_NATIVE\n    if (fun->base.type == &mp_type_fun_native || fun->base.type == &mp_type_native_gen_wrap) {\n        bc = mp_obj_fun_native_get_prelude_ptr(fun);\n    }\n    #endif\n\n    MP_BC_PRELUDE_SIG_DECODE(bc);\n    MP_BC_PRELUDE_SIZE_DECODE(bc);\n\n    mp_uint_t name = mp_decode_uint_value(bc);\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    name = fun->context->constants.qstr_table[name];\n    #endif\n\n    return name;\n}\n\n#if MICROPY_CPYTHON_COMPAT\nstatic void fun_bc_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_fun_bc_t *o = MP_OBJ_TO_PTR(o_in);\n    mp_printf(print, \"<function %q at 0x%p>\", mp_obj_fun_get_name(o_in), o);\n}\n#endif\n\n#if DEBUG_PRINT\nstatic void dump_args(const mp_obj_t *a, size_t sz) {\n    DEBUG_printf(\"%p: \", a);\n    for (size_t i = 0; i < sz; i++) {\n        DEBUG_printf(\"%p \", a[i]);\n    }\n    DEBUG_printf(\"\\n\");\n}\n#else\n#define dump_args(...) (void)0\n#endif\n\n\n\n\n#define VM_MAX_STATE_ON_STACK (sizeof(mp_uint_t) * 11)\n\n#define DECODE_CODESTATE_SIZE(bytecode, n_state_out_var, state_size_out_var) \\\n    { \\\n        const uint8_t *ip = bytecode; \\\n        size_t n_exc_stack, scope_flags, n_pos_args, n_kwonly_args, n_def_args; \\\n        MP_BC_PRELUDE_SIG_DECODE_INTO(ip, n_state_out_var, n_exc_stack, scope_flags, n_pos_args, n_kwonly_args, n_def_args); \\\n        (void)scope_flags; (void)n_pos_args; (void)n_kwonly_args; (void)n_def_args; \\\n        \\\n                                                          \\\n        state_size_out_var = n_state_out_var * sizeof(mp_obj_t)                   \\\n            + n_exc_stack * sizeof(mp_exc_stack_t);                \\\n    }\n\n#define INIT_CODESTATE(code_state, _fun_bc, _n_state, n_args, n_kw, args) \\\n    code_state->fun_bc = _fun_bc; \\\n    code_state->n_state = _n_state; \\\n    mp_setup_code_state(code_state, n_args, n_kw, args); \\\n    code_state->old_globals = mp_globals_get();\n\n#if MICROPY_STACKLESS\nmp_code_state_t *mp_obj_fun_bc_prepare_codestate(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    MP_STACK_CHECK();\n    mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);\n\n    size_t n_state, state_size;\n    DECODE_CODESTATE_SIZE(self->bytecode, n_state, state_size);\n\n    mp_code_state_t *code_state;\n    #if MICROPY_ENABLE_PYSTACK\n    code_state = mp_pystack_alloc(sizeof(mp_code_state_t) + state_size);\n    #else\n    \n    \n    \n    \n    \n    code_state = m_new_obj_var_maybe(mp_code_state_t, state, byte, state_size);\n    if (!code_state) {\n        return NULL;\n    }\n    #endif\n\n    INIT_CODESTATE(code_state, self, n_state, n_args, n_kw, args);\n\n    \n    mp_globals_set(self->context->module.globals);\n\n    return code_state;\n}\n#endif\n\nstatic mp_obj_t fun_bc_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    MP_STACK_CHECK();\n\n    DEBUG_printf(\"Input n_args: \" UINT_FMT \", n_kw: \" UINT_FMT \"\\n\", n_args, n_kw);\n    DEBUG_printf(\"Input pos args: \");\n    dump_args(args, n_args);\n    DEBUG_printf(\"Input kw args: \");\n    dump_args(args + n_args, n_kw * 2);\n\n    mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);\n\n    size_t n_state, state_size;\n    DECODE_CODESTATE_SIZE(self->bytecode, n_state, state_size);\n\n    \n    mp_code_state_t *code_state = NULL;\n    #if MICROPY_ENABLE_PYSTACK\n    code_state = mp_pystack_alloc(offsetof(mp_code_state_t, state) + state_size);\n    #else\n    if (state_size > VM_MAX_STATE_ON_STACK) {\n        code_state = m_new_obj_var_maybe(mp_code_state_t, state, byte, state_size);\n        #if MICROPY_DEBUG_VM_STACK_OVERFLOW\n        if (code_state != NULL) {\n            memset(code_state->state, 0, state_size);\n        }\n        #endif\n    }\n    if (code_state == NULL) {\n        code_state = alloca(offsetof(mp_code_state_t, state) + state_size);\n        #if MICROPY_DEBUG_VM_STACK_OVERFLOW\n        memset(code_state->state, 0, state_size);\n        #endif\n        state_size = 0; \n    }\n    #endif\n\n    INIT_CODESTATE(code_state, self, n_state, n_args, n_kw, args);\n\n    \n    mp_globals_set(self->context->module.globals);\n    mp_vm_return_kind_t vm_return_kind = mp_execute_bytecode(code_state, MP_OBJ_NULL);\n    mp_globals_set(code_state->old_globals);\n\n    #if MICROPY_DEBUG_VM_STACK_OVERFLOW\n    if (vm_return_kind == MP_VM_RETURN_NORMAL) {\n        if (code_state->sp < code_state->state) {\n            mp_printf(MICROPY_DEBUG_PRINTER, \"VM stack underflow: \" INT_FMT \"\\n\", code_state->sp - code_state->state);\n            assert(0);\n        }\n    }\n    const byte *bytecode_ptr = self->bytecode;\n    size_t n_state_unused, n_exc_stack_unused, scope_flags_unused;\n    size_t n_pos_args, n_kwonly_args, n_def_args_unused;\n    MP_BC_PRELUDE_SIG_DECODE_INTO(bytecode_ptr, n_state_unused, n_exc_stack_unused,\n        scope_flags_unused, n_pos_args, n_kwonly_args, n_def_args_unused);\n    \n    \n    \n    if (!(vm_return_kind == MP_VM_RETURN_EXCEPTION && n_pos_args + n_kwonly_args == 0)) {\n        \n        bool overflow = true;\n        for (size_t i = 0; i < n_state - n_pos_args - n_kwonly_args; ++i) {\n            if (code_state->state[i] == MP_OBJ_NULL) {\n                overflow = false;\n                break;\n            }\n        }\n        if (overflow) {\n            mp_printf(MICROPY_DEBUG_PRINTER, \"VM stack overflow state=%p n_state+1=\" UINT_FMT \"\\n\", code_state->state, n_state);\n            assert(0);\n        }\n    }\n    #endif\n\n    mp_obj_t result;\n    if (vm_return_kind == MP_VM_RETURN_NORMAL) {\n        \n        result = *code_state->sp;\n    } else {\n        \n        assert(vm_return_kind == MP_VM_RETURN_EXCEPTION);\n        \n        result = code_state->state[0];\n    }\n\n    #if MICROPY_ENABLE_PYSTACK\n    mp_pystack_free(code_state);\n    #else\n    \n    if (state_size != 0) {\n        m_del_var(mp_code_state_t, state, byte, state_size, code_state);\n    }\n    #endif\n\n    if (vm_return_kind == MP_VM_RETURN_NORMAL) {\n        return result;\n    } else { \n        nlr_raise(result);\n    }\n}\n\n#if MICROPY_PY_FUNCTION_ATTRS\nvoid mp_obj_fun_bc_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n    if (attr == MP_QSTR___name__) {\n        dest[0] = MP_OBJ_NEW_QSTR(mp_obj_fun_get_name(self_in));\n    }\n    if (attr == MP_QSTR___globals__) {\n        mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);\n        dest[0] = MP_OBJ_FROM_PTR(self->context->module.globals);\n    }\n}\n#endif\n\n#if MICROPY_CPYTHON_COMPAT\n#define FUN_BC_TYPE_PRINT print, fun_bc_print,\n#else\n#define FUN_BC_TYPE_PRINT\n#endif\n\n#if MICROPY_PY_FUNCTION_ATTRS\n#define FUN_BC_TYPE_ATTR attr, mp_obj_fun_bc_attr,\n#else\n#define FUN_BC_TYPE_ATTR\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_bc,\n    MP_QSTR_function,\n    MP_TYPE_FLAG_BINDS_SELF,\n    FUN_BC_TYPE_PRINT\n    FUN_BC_TYPE_ATTR\n    call, fun_bc_call\n    );\n\nmp_obj_t mp_obj_new_fun_bc(const mp_obj_t *def_args, const byte *code, const mp_module_context_t *context, struct _mp_raw_code_t *const *child_table) {\n    size_t n_def_args = 0;\n    size_t n_extra_args = 0;\n    mp_obj_tuple_t *def_pos_args = NULL;\n    mp_obj_t def_kw_args = MP_OBJ_NULL;\n    if (def_args != NULL && def_args[0] != MP_OBJ_NULL) {\n        assert(mp_obj_is_type(def_args[0], &mp_type_tuple));\n        def_pos_args = MP_OBJ_TO_PTR(def_args[0]);\n        n_def_args = def_pos_args->len;\n        n_extra_args = def_pos_args->len;\n    }\n    if (def_args != NULL && def_args[1] != MP_OBJ_NULL) {\n        assert(mp_obj_is_type(def_args[1], &mp_type_dict));\n        def_kw_args = def_args[1];\n        n_extra_args += 1;\n    }\n    mp_obj_fun_bc_t *o = mp_obj_malloc_var(mp_obj_fun_bc_t, extra_args, mp_obj_t, n_extra_args, &mp_type_fun_bc);\n    o->bytecode = code;\n    o->context = context;\n    o->child_table = child_table;\n    if (def_pos_args != NULL) {\n        memcpy(o->extra_args, def_pos_args->items, n_def_args * sizeof(mp_obj_t));\n    }\n    if (def_kw_args != MP_OBJ_NULL) {\n        o->extra_args[n_def_args] = def_kw_args;\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n \n\n#if MICROPY_EMIT_NATIVE\n\nstatic mp_obj_t fun_native_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    MP_STACK_CHECK();\n    mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_call_fun_t fun = mp_obj_fun_native_get_function_start(self);\n    return fun(self_in, n_args, n_kw, args);\n}\n\n#if MICROPY_CPYTHON_COMPAT\n#define FUN_BC_TYPE_PRINT print, fun_bc_print,\n#else\n#define FUN_BC_TYPE_PRINT\n#endif\n#if MICROPY_PY_FUNCTION_ATTRS\n#define FUN_BC_TYPE_ATTR attr, mp_obj_fun_bc_attr,\n#else\n#define FUN_BC_TYPE_ATTR\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_native,\n    MP_QSTR_function,\n    MP_TYPE_FLAG_BINDS_SELF,\n    FUN_BC_TYPE_PRINT\n    FUN_BC_TYPE_ATTR\n    call, fun_native_call\n    );\n\n#endif \n\n \n \n\n#if MICROPY_EMIT_NATIVE\n\nstatic mp_obj_t fun_viper_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    MP_STACK_CHECK();\n    mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_call_fun_t fun = MICROPY_MAKE_POINTER_CALLABLE((void *)self->bytecode);\n    return fun(self_in, n_args, n_kw, args);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_viper,\n    MP_QSTR_function,\n    MP_TYPE_FLAG_BINDS_SELF,\n    call, fun_viper_call\n    );\n\n#endif \n\n \n \n\n#if MICROPY_EMIT_INLINE_ASM\n\ntypedef mp_uint_t (*inline_asm_fun_0_t)(void);\ntypedef mp_uint_t (*inline_asm_fun_1_t)(mp_uint_t);\ntypedef mp_uint_t (*inline_asm_fun_2_t)(mp_uint_t, mp_uint_t);\ntypedef mp_uint_t (*inline_asm_fun_3_t)(mp_uint_t, mp_uint_t, mp_uint_t);\ntypedef mp_uint_t (*inline_asm_fun_4_t)(mp_uint_t, mp_uint_t, mp_uint_t, mp_uint_t);\n\n\nstatic mp_uint_t convert_obj_for_inline_asm(mp_obj_t obj) {\n    \n    if (mp_obj_is_small_int(obj)) {\n        return MP_OBJ_SMALL_INT_VALUE(obj);\n    } else if (obj == mp_const_none) {\n        return 0;\n    } else if (obj == mp_const_false) {\n        return 0;\n    } else if (obj == mp_const_true) {\n        return 1;\n    } else if (mp_obj_is_exact_type(obj, &mp_type_int)) {\n        return mp_obj_int_get_truncated(obj);\n    } else if (mp_obj_is_str(obj)) {\n        \n        size_t l;\n        return (mp_uint_t)mp_obj_str_get_data(obj, &l);\n    } else {\n        const mp_obj_type_t *type = mp_obj_get_type(obj);\n        #if MICROPY_PY_BUILTINS_FLOAT\n        if (type == &mp_type_float) {\n            \n            return (mp_int_t)mp_obj_float_get(obj);\n        }\n        #endif\n        if (type == &mp_type_tuple || type == &mp_type_list) {\n            \n            size_t len;\n            mp_obj_t *items;\n            mp_obj_get_array(obj, &len, &items);\n            return (mp_uint_t)items;\n        } else {\n            mp_buffer_info_t bufinfo;\n            if (mp_get_buffer(obj, &bufinfo, MP_BUFFER_READ)) {\n                \n                return (mp_uint_t)bufinfo.buf;\n            } else {\n                \n                return (mp_uint_t)obj;\n            }\n        }\n    }\n}\n\nstatic mp_obj_t fun_asm_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_fun_asm_t *self = MP_OBJ_TO_PTR(self_in);\n\n    mp_arg_check_num(n_args, n_kw, self->n_args, self->n_args, false);\n\n    const void *fun = MICROPY_MAKE_POINTER_CALLABLE(self->fun_data);\n\n    mp_uint_t ret;\n    if (n_args == 0) {\n        ret = ((inline_asm_fun_0_t)fun)();\n    } else if (n_args == 1) {\n        ret = ((inline_asm_fun_1_t)fun)(convert_obj_for_inline_asm(args[0]));\n    } else if (n_args == 2) {\n        ret = ((inline_asm_fun_2_t)fun)(convert_obj_for_inline_asm(args[0]), convert_obj_for_inline_asm(args[1]));\n    } else if (n_args == 3) {\n        ret = ((inline_asm_fun_3_t)fun)(convert_obj_for_inline_asm(args[0]), convert_obj_for_inline_asm(args[1]), convert_obj_for_inline_asm(args[2]));\n    } else {\n        \n        assert(n_args == 4);\n        ret = ((inline_asm_fun_4_t)fun)(\n            convert_obj_for_inline_asm(args[0]),\n            convert_obj_for_inline_asm(args[1]),\n            convert_obj_for_inline_asm(args[2]),\n            convert_obj_for_inline_asm(args[3])\n            );\n    }\n\n    return mp_native_to_obj(ret, self->type_sig);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_fun_asm,\n    MP_QSTR_function,\n    MP_TYPE_FLAG_BINDS_SELF,\n    call, fun_asm_call\n    );\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}