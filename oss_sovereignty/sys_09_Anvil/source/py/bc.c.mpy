{
  "module_name": "bc.c",
  "hash_id": "8349fe6f1b308680605b692e4685492af563fa14fd3c23046d619eaae46b917b",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/bc.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/bc0.h\"\n#include \"py/bc.h\"\n#include \"py/objfun.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\nvoid mp_encode_uint(void *env, mp_encode_uint_allocator_t allocator, mp_uint_t val) {\n    \n    byte buf[MP_ENCODE_UINT_MAX_BYTES];\n    byte *p = buf + sizeof(buf);\n    \n    do {\n        *--p = val & 0x7f;\n        val >>= 7;\n    } while (val != 0);\n    byte *c = allocator(env, buf + sizeof(buf) - p);\n    if (c != NULL) {\n        while (p != buf + sizeof(buf) - 1) {\n            *c++ = *p++ | 0x80;\n        }\n        *c = *p;\n    }\n}\n\nmp_uint_t mp_decode_uint(const byte **ptr) {\n    mp_uint_t unum = 0;\n    byte val;\n    const byte *p = *ptr;\n    do {\n        val = *p++;\n        unum = (unum << 7) | (val & 0x7f);\n    } while ((val & 0x80) != 0);\n    *ptr = p;\n    return unum;\n}\n\n\n\n\n\n\n\nmp_uint_t mp_decode_uint_value(const byte *ptr) {\n    return mp_decode_uint(&ptr);\n}\n\n\n\nconst byte *mp_decode_uint_skip(const byte *ptr) {\n    while ((*ptr++) & 0x80) {\n    }\n    return ptr;\n}\n\nstatic NORETURN void fun_pos_args_mismatch(mp_obj_fun_bc_t *f, size_t expected, size_t given) {\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    \n    (void)f;\n    (void)expected;\n    (void)given;\n    mp_arg_error_terse_mismatch();\n    #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL\n    (void)f;\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"function takes %d positional arguments but %d were given\"), expected, given);\n    #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"%q() takes %d positional arguments but %d were given\"),\n        mp_obj_fun_get_name(MP_OBJ_FROM_PTR(f)), expected, given);\n    #endif\n}\n\n#if DEBUG_PRINT\nstatic void dump_args(const mp_obj_t *a, size_t sz) {\n    DEBUG_printf(\"%p: \", a);\n    for (size_t i = 0; i < sz; i++) {\n        DEBUG_printf(\"%p \", a[i]);\n    }\n    DEBUG_printf(\"\\n\");\n}\n#else\n#define dump_args(...) (void)0\n#endif\n\n\n\n\n\n\n\nstatic void mp_setup_code_state_helper(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n    \n\n    \n    mp_obj_fun_bc_t *self = code_state->fun_bc;\n\n    \n    size_t n_state = code_state->n_state;\n\n    \n    size_t n_state_unused, n_exc_stack_unused, scope_flags, n_pos_args, n_kwonly_args, n_def_pos_args;\n    MP_BC_PRELUDE_SIG_DECODE_INTO(code_state->ip, n_state_unused, n_exc_stack_unused, scope_flags, n_pos_args, n_kwonly_args, n_def_pos_args);\n    MP_BC_PRELUDE_SIZE_DECODE(code_state->ip);\n    (void)n_state_unused;\n    (void)n_exc_stack_unused;\n\n    mp_obj_t *code_state_state = code_state->sp + 1;\n    code_state->exc_sp_idx = 0;\n\n    \n    memset(code_state_state, 0, n_state * sizeof(*code_state->state));\n\n    const mp_obj_t *kwargs = args + n_args;\n\n    \n    mp_obj_t *var_pos_kw_args = &code_state_state[n_state - 1 - n_pos_args - n_kwonly_args];\n\n    \n\n    if (n_args > n_pos_args) {\n        \n        if ((scope_flags & MP_SCOPE_FLAG_VARARGS) == 0) {\n            fun_pos_args_mismatch(self, n_pos_args, n_args);\n        }\n        \n        *var_pos_kw_args-- = mp_obj_new_tuple(n_args - n_pos_args, args + n_pos_args);\n        n_args = n_pos_args;\n    } else {\n        if ((scope_flags & MP_SCOPE_FLAG_VARARGS) != 0) {\n            DEBUG_printf(\"passing empty tuple as *args\\n\");\n            *var_pos_kw_args-- = mp_const_empty_tuple;\n        }\n        \n        \n        if (n_kw == 0 && (scope_flags & MP_SCOPE_FLAG_DEFKWARGS) == 0) {\n            if (n_args >= (size_t)(n_pos_args - n_def_pos_args)) {\n                \n                for (size_t i = n_args; i < n_pos_args; i++) {\n                    code_state_state[n_state - 1 - i] = self->extra_args[i - (n_pos_args - n_def_pos_args)];\n                }\n            } else {\n                fun_pos_args_mismatch(self, n_pos_args - n_def_pos_args, n_args);\n            }\n        }\n    }\n\n    \n    for (size_t i = 0; i < n_args; i++) {\n        code_state_state[n_state - 1 - i] = args[i];\n    }\n\n    \n\n    if (n_kw != 0 || (scope_flags & MP_SCOPE_FLAG_DEFKWARGS) != 0) {\n        DEBUG_printf(\"Initial args: \");\n        dump_args(code_state_state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);\n\n        mp_obj_t dict = MP_OBJ_NULL;\n        if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {\n            dict = mp_obj_new_dict(n_kw); \n            *var_pos_kw_args = dict;\n        }\n\n        for (size_t i = 0; i < n_kw; i++) {\n            \n            mp_obj_t wanted_arg_name = kwargs[2 * i];\n\n            \n            const uint8_t *arg_names = code_state->ip;\n            arg_names = mp_decode_uint_skip(arg_names);\n\n            for (size_t j = 0; j < n_pos_args + n_kwonly_args; j++) {\n                qstr arg_qstr = mp_decode_uint(&arg_names);\n                #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n                arg_qstr = self->context->constants.qstr_table[arg_qstr];\n                #endif\n                if (wanted_arg_name == MP_OBJ_NEW_QSTR(arg_qstr)) {\n                    if (code_state_state[n_state - 1 - j] != MP_OBJ_NULL) {\n                    error_multiple:\n                        mp_raise_msg_varg(&mp_type_TypeError,\n                            MP_ERROR_TEXT(\"function got multiple values for argument '%q'\"), MP_OBJ_QSTR_VALUE(wanted_arg_name));\n                    }\n                    code_state_state[n_state - 1 - j] = kwargs[2 * i + 1];\n                    goto continue2;\n                }\n            }\n            \n            if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) == 0) {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                mp_raise_TypeError(MP_ERROR_TEXT(\"unexpected keyword argument\"));\n                #else\n                mp_raise_msg_varg(&mp_type_TypeError,\n                    MP_ERROR_TEXT(\"unexpected keyword argument '%q'\"), MP_OBJ_QSTR_VALUE(wanted_arg_name));\n                #endif\n            }\n            mp_map_elem_t *elem = mp_map_lookup(mp_obj_dict_get_map(dict), wanted_arg_name, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n            if (elem->value == MP_OBJ_NULL) {\n                elem->value = kwargs[2 * i + 1];\n            } else {\n                goto error_multiple;\n            }\n        continue2:;\n        }\n\n        DEBUG_printf(\"Args with kws flattened: \");\n        dump_args(code_state_state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);\n\n        \n        mp_obj_t *d = &code_state_state[n_state - n_pos_args];\n        mp_obj_t *s = &self->extra_args[n_def_pos_args - 1];\n        for (size_t i = n_def_pos_args; i > 0; i--, d++, s--) {\n            if (*d == MP_OBJ_NULL) {\n                *d = *s;\n            }\n        }\n\n        DEBUG_printf(\"Args after filling default positional: \");\n        dump_args(code_state_state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);\n\n        \n        while (d < &code_state_state[n_state]) {\n            if (*d++ == MP_OBJ_NULL) {\n                mp_raise_msg_varg(&mp_type_TypeError,\n                    MP_ERROR_TEXT(\"function missing required positional argument #%d\"), &code_state_state[n_state] - d);\n            }\n        }\n\n        \n        \n        const uint8_t *arg_names = mp_decode_uint_skip(code_state->ip);\n        for (size_t i = 0; i < n_pos_args; i++) {\n            arg_names = mp_decode_uint_skip(arg_names);\n        }\n        for (size_t i = 0; i < n_kwonly_args; i++) {\n            qstr arg_qstr = mp_decode_uint(&arg_names);\n            #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n            arg_qstr = self->context->constants.qstr_table[arg_qstr];\n            #endif\n            if (code_state_state[n_state - 1 - n_pos_args - i] == MP_OBJ_NULL) {\n                mp_map_elem_t *elem = NULL;\n                if ((scope_flags & MP_SCOPE_FLAG_DEFKWARGS) != 0) {\n                    elem = mp_map_lookup(&((mp_obj_dict_t *)MP_OBJ_TO_PTR(self->extra_args[n_def_pos_args]))->map, MP_OBJ_NEW_QSTR(arg_qstr), MP_MAP_LOOKUP);\n                }\n                if (elem != NULL) {\n                    code_state_state[n_state - 1 - n_pos_args - i] = elem->value;\n                } else {\n                    mp_raise_msg_varg(&mp_type_TypeError,\n                        MP_ERROR_TEXT(\"function missing required keyword argument '%q'\"), arg_qstr);\n                }\n            }\n        }\n\n    } else {\n        \n        if (n_kwonly_args != 0) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"function missing keyword-only argument\"));\n        }\n        if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {\n            *var_pos_kw_args = mp_obj_new_dict(0);\n        }\n    }\n\n    \n    const uint8_t *ip = code_state->ip + n_info;\n\n    \n    for (; n_cell; --n_cell) {\n        size_t local_num = *ip++;\n        code_state_state[n_state - 1 - local_num] =\n            mp_obj_new_cell(code_state_state[n_state - 1 - local_num]);\n    }\n\n    \n    code_state->ip = ip;\n\n    DEBUG_printf(\"Calling: n_pos_args=%d, n_kwonly_args=%d\\n\", n_pos_args, n_kwonly_args);\n    dump_args(code_state_state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);\n    dump_args(code_state_state, n_state);\n}\n\n\n\n\n\nvoid mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    code_state->ip = code_state->fun_bc->bytecode;\n    code_state->sp = &code_state->state[0] - 1;\n    #if MICROPY_STACKLESS\n    code_state->prev = NULL;\n    #endif\n    #if MICROPY_PY_SYS_SETTRACE\n    code_state->prev_state = NULL;\n    code_state->frame = NULL;\n    #endif\n    mp_setup_code_state_helper(code_state, n_args, n_kw, args);\n}\n\n#if MICROPY_EMIT_NATIVE\n\n\n\n\nvoid mp_setup_code_state_native(mp_code_state_native_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    code_state->ip = mp_obj_fun_native_get_prelude_ptr(code_state->fun_bc);\n    code_state->sp = &code_state->state[0] - 1;\n    mp_setup_code_state_helper((mp_code_state_t *)code_state, n_args, n_kw, args);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}