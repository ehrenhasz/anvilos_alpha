{
  "module_name": "obj.h",
  "hash_id": "bd06d7d4fc5de5ed0564de734195dc6602a823d6fad94b271a738e86f574128b",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/obj.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_OBJ_H\n#define MICROPY_INCLUDED_PY_OBJ_H\n\n#include <assert.h>\n\n#include \"py/mpconfig.h\"\n#include \"py/misc.h\"\n#include \"py/qstr.h\"\n#include \"py/mpprint.h\"\n#include \"py/runtime0.h\"\n\n\n\n\n#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\ntypedef uint64_t mp_obj_t;\ntypedef uint64_t mp_const_obj_t;\n#else\ntypedef void *mp_obj_t;\ntypedef const void *mp_const_obj_t;\n#endif\n\n\n\ntypedef struct _mp_obj_type_t mp_obj_type_t;\n\n\n\nstruct _mp_obj_base_t {\n    const mp_obj_type_t *type MICROPY_OBJ_BASE_ALIGNMENT;\n};\ntypedef struct _mp_obj_base_t mp_obj_base_t;\n\n\n\n\n\n\n\n\n\n\n\n\n#if MICROPY_DEBUG_MP_OBJ_SENTINELS\n#define MP_OBJ_NULL             (MP_OBJ_FROM_PTR((void *)0))\n#define MP_OBJ_STOP_ITERATION   (MP_OBJ_FROM_PTR((void *)4))\n#define MP_OBJ_SENTINEL         (MP_OBJ_FROM_PTR((void *)8))\n#else\n#define MP_OBJ_NULL             (MP_OBJ_FROM_PTR((void *)0))\n#define MP_OBJ_STOP_ITERATION   (MP_OBJ_FROM_PTR((void *)0))\n#define MP_OBJ_SENTINEL         (MP_OBJ_FROM_PTR((void *)4))\n#endif\n\n\n\n\n\n#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A\n\nstatic inline bool mp_obj_is_small_int(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 1) != 0;\n}\n#define MP_OBJ_SMALL_INT_VALUE(o) (((mp_int_t)(o)) >> 1)\n#define MP_OBJ_NEW_SMALL_INT(small_int) ((mp_obj_t)((((mp_uint_t)(small_int)) << 1) | 1))\n\nstatic inline bool mp_obj_is_qstr(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 7) == 2;\n}\n#define MP_OBJ_QSTR_VALUE(o) (((mp_uint_t)(o)) >> 3)\n#define MP_OBJ_NEW_QSTR(qst) ((mp_obj_t)((((mp_uint_t)(qst)) << 3) | 2))\n\nstatic inline bool mp_obj_is_immediate_obj(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 7) == 6;\n}\n#define MP_OBJ_IMMEDIATE_OBJ_VALUE(o) (((mp_uint_t)(o)) >> 3)\n#define MP_OBJ_NEW_IMMEDIATE_OBJ(val) ((mp_obj_t)(((val) << 3) | 6))\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#define mp_const_float_e MP_ROM_PTR(&mp_const_float_e_obj)\n#define mp_const_float_pi MP_ROM_PTR(&mp_const_float_pi_obj)\n#if MICROPY_PY_MATH_CONSTANTS\n#define mp_const_float_tau MP_ROM_PTR(&mp_const_float_tau_obj)\n#define mp_const_float_inf MP_ROM_PTR(&mp_const_float_inf_obj)\n#define mp_const_float_nan MP_ROM_PTR(&mp_const_float_nan_obj)\n#endif\nextern const struct _mp_obj_float_t mp_const_float_e_obj;\nextern const struct _mp_obj_float_t mp_const_float_pi_obj;\n#if MICROPY_PY_MATH_CONSTANTS\nextern const struct _mp_obj_float_t mp_const_float_tau_obj;\nextern const struct _mp_obj_float_t mp_const_float_inf_obj;\nextern const struct _mp_obj_float_t mp_const_float_nan_obj;\n#endif\n\n#define mp_obj_is_float(o) mp_obj_is_type((o), &mp_type_float)\nmp_float_t mp_obj_float_get(mp_obj_t self_in);\nmp_obj_t mp_obj_new_float(mp_float_t value);\n#endif\n\nstatic inline bool mp_obj_is_obj(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 3) == 0;\n}\n\n#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_B\n\nstatic inline bool mp_obj_is_small_int(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 3) == 1;\n}\n#define MP_OBJ_SMALL_INT_VALUE(o) (((mp_int_t)(o)) >> 2)\n#define MP_OBJ_NEW_SMALL_INT(small_int) ((mp_obj_t)((((mp_uint_t)(small_int)) << 2) | 1))\n\nstatic inline bool mp_obj_is_qstr(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 7) == 3;\n}\n#define MP_OBJ_QSTR_VALUE(o) (((mp_uint_t)(o)) >> 3)\n#define MP_OBJ_NEW_QSTR(qst) ((mp_obj_t)((((mp_uint_t)(qst)) << 3) | 3))\n\nstatic inline bool mp_obj_is_immediate_obj(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 7) == 7;\n}\n#define MP_OBJ_IMMEDIATE_OBJ_VALUE(o) (((mp_uint_t)(o)) >> 3)\n#define MP_OBJ_NEW_IMMEDIATE_OBJ(val) ((mp_obj_t)(((val) << 3) | 7))\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#define mp_const_float_e MP_ROM_PTR(&mp_const_float_e_obj)\n#define mp_const_float_pi MP_ROM_PTR(&mp_const_float_pi_obj)\n#if MICROPY_PY_MATH_CONSTANTS\n#define mp_const_float_tau MP_ROM_PTR(&mp_const_float_tau_obj)\n#define mp_const_float_inf MP_ROM_PTR(&mp_const_float_inf_obj)\n#define mp_const_float_nan MP_ROM_PTR(&mp_const_float_nan_obj)\n#endif\nextern const struct _mp_obj_float_t mp_const_float_e_obj;\nextern const struct _mp_obj_float_t mp_const_float_pi_obj;\n#if MICROPY_PY_MATH_CONSTANTS\nextern const struct _mp_obj_float_t mp_const_float_tau_obj;\nextern const struct _mp_obj_float_t mp_const_float_inf_obj;\nextern const struct _mp_obj_float_t mp_const_float_nan_obj;\n#endif\n\n#define mp_obj_is_float(o) mp_obj_is_type((o), &mp_type_float)\nmp_float_t mp_obj_float_get(mp_obj_t self_in);\nmp_obj_t mp_obj_new_float(mp_float_t value);\n#endif\n\nstatic inline bool mp_obj_is_obj(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 1) == 0;\n}\n\n#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C\n\n#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_NONE\n#error \"MICROPY_OBJ_REPR_C requires float to be enabled.\"\n#endif\n\nstatic inline bool mp_obj_is_small_int(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 1) != 0;\n}\n#define MP_OBJ_SMALL_INT_VALUE(o) (((mp_int_t)(o)) >> 1)\n#define MP_OBJ_NEW_SMALL_INT(small_int) ((mp_obj_t)((((mp_uint_t)(small_int)) << 1) | 1))\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#define mp_const_float_e MP_ROM_PTR((mp_obj_t)(((0x402df854 & ~3) | 2) + 0x80800000))\n#define mp_const_float_pi MP_ROM_PTR((mp_obj_t)(((0x40490fdb & ~3) | 2) + 0x80800000))\n#if MICROPY_PY_MATH_CONSTANTS\n#define mp_const_float_tau MP_ROM_PTR((mp_obj_t)(((0x40c90fdb & ~3) | 2) + 0x80800000))\n#define mp_const_float_inf MP_ROM_PTR((mp_obj_t)(((0x7f800000 & ~3) | 2) + 0x80800000))\n#define mp_const_float_nan MP_ROM_PTR((mp_obj_t)(((0xffc00000 & ~3) | 2) + 0x80800000))\n#endif\n\nstatic inline bool mp_obj_is_float(mp_const_obj_t o) {\n    \n    MP_STATIC_ASSERT(sizeof(mp_float_t) <= sizeof(mp_obj_t));\n\n    return (((mp_uint_t)(o)) & 3) == 2 && (((mp_uint_t)(o)) & 0xff800007) != 0x00000006;\n}\nstatic inline mp_float_t mp_obj_float_get(mp_const_obj_t o) {\n    union {\n        mp_float_t f;\n        mp_uint_t u;\n    } num = {.u = ((mp_uint_t)o - 0x80800000) & ~3};\n    return num.f;\n}\nstatic inline mp_obj_t mp_obj_new_float(mp_float_t f) {\n    union {\n        mp_float_t f;\n        mp_uint_t u;\n    } num = {.f = f};\n    return (mp_obj_t)(((num.u & ~0x3) | 2) + 0x80800000);\n}\n#endif\n\nstatic inline bool mp_obj_is_qstr(mp_const_obj_t o) {\n    return (((mp_uint_t)(o)) & 0xff80000f) == 0x00000006;\n}\n#define MP_OBJ_QSTR_VALUE(o) (((mp_uint_t)(o)) >> 4)\n#define MP_OBJ_NEW_QSTR(qst) ((mp_obj_t)((((mp_uint_t)(qst)) << 4) | 0x00000006))\n\nstatic inline bool mp_obj_is_immediate_obj(mp_const_obj_t o) {\n    return (((mp_uint_t)(o)) & 0xff80000f) == 0x0000000e;\n}\n#define MP_OBJ_IMMEDIATE_OBJ_VALUE(o) (((mp_uint_t)(o)) >> 4)\n#define MP_OBJ_NEW_IMMEDIATE_OBJ(val) ((mp_obj_t)(((val) << 4) | 0xe))\n\nstatic inline bool mp_obj_is_obj(mp_const_obj_t o) {\n    return (((mp_int_t)(o)) & 3) == 0;\n}\n\n#elif MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\n\nstatic inline bool mp_obj_is_small_int(mp_const_obj_t o) {\n    return (((uint64_t)(o)) & 0xffff000000000000) == 0x0001000000000000;\n}\n#define MP_OBJ_SMALL_INT_VALUE(o) (((mp_int_t)((o) << 16)) >> 17)\n#define MP_OBJ_NEW_SMALL_INT(small_int) (((((uint64_t)(small_int)) & 0x7fffffffffff) << 1) | 0x0001000000000001)\n\nstatic inline bool mp_obj_is_qstr(mp_const_obj_t o) {\n    return (((uint64_t)(o)) & 0xffff000000000000) == 0x0002000000000000;\n}\n#define MP_OBJ_QSTR_VALUE(o) ((((uint32_t)(o)) >> 1) & 0xffffffff)\n#define MP_OBJ_NEW_QSTR(qst) ((mp_obj_t)(((uint64_t)(((uint32_t)(qst)) << 1)) | 0x0002000000000001))\n\nstatic inline bool mp_obj_is_immediate_obj(mp_const_obj_t o) {\n    return (((uint64_t)(o)) & 0xffff000000000000) == 0x0003000000000000;\n}\n#define MP_OBJ_IMMEDIATE_OBJ_VALUE(o) ((((uint32_t)(o)) >> 46) & 3)\n#define MP_OBJ_NEW_IMMEDIATE_OBJ(val) (((uint64_t)(val) << 46) | 0x0003000000000000)\n\n#if MICROPY_PY_BUILTINS_FLOAT\n\n#if MICROPY_FLOAT_IMPL != MICROPY_FLOAT_IMPL_DOUBLE\n#error MICROPY_OBJ_REPR_D requires MICROPY_FLOAT_IMPL_DOUBLE\n#endif\n\n#define mp_const_float_e {((mp_obj_t)((uint64_t)0x4005bf0a8b145769 + 0x8004000000000000))}\n#define mp_const_float_pi {((mp_obj_t)((uint64_t)0x400921fb54442d18 + 0x8004000000000000))}\n#if MICROPY_PY_MATH_CONSTANTS\n#define mp_const_float_tau {((mp_obj_t)((uint64_t)0x401921fb54442d18 + 0x8004000000000000))}\n#define mp_const_float_inf {((mp_obj_t)((uint64_t)0x7ff0000000000000 + 0x8004000000000000))}\n#define mp_const_float_nan {((mp_obj_t)((uint64_t)0xfff8000000000000 + 0x8004000000000000))}\n#endif\n\nstatic inline bool mp_obj_is_float(mp_const_obj_t o) {\n    return ((uint64_t)(o) & 0xfffc000000000000) != 0;\n}\nstatic inline mp_float_t mp_obj_float_get(mp_const_obj_t o) {\n    union {\n        mp_float_t f;\n        uint64_t r;\n    } num = {.r = o - 0x8004000000000000};\n    return num.f;\n}\nstatic inline mp_obj_t mp_obj_new_float(mp_float_t f) {\n    union {\n        mp_float_t f;\n        uint64_t r;\n    } num = {.f = f};\n    return num.r + 0x8004000000000000;\n}\n#endif\n\nstatic inline bool mp_obj_is_obj(mp_const_obj_t o) {\n    return (((uint64_t)(o)) & 0xffff000000000000) == 0x0000000000000000;\n}\n#define MP_OBJ_TO_PTR(o) ((void *)(uintptr_t)(o))\n#define MP_OBJ_FROM_PTR(p) ((mp_obj_t)((uintptr_t)(p)))\n\n\ntypedef union _mp_rom_obj_t {\n    uint64_t u64;\n    struct {\n        const void *lo, *hi;\n    } u32;\n} mp_rom_obj_t;\n#define MP_ROM_INT(i) {MP_OBJ_NEW_SMALL_INT(i)}\n#define MP_ROM_QSTR(q) {MP_OBJ_NEW_QSTR(q)}\n#if MP_ENDIANNESS_LITTLE\n#define MP_ROM_PTR(p) {.u32 = {.lo = (p), .hi = NULL}}\n#else\n#define MP_ROM_PTR(p) {.u32 = {.lo = NULL, .hi = (p)}}\n#endif\n\n#endif\n\n\n\n\n\n\n\n#ifndef MP_OBJ_TO_PTR\n#define MP_OBJ_TO_PTR(o) ((void *)(o))\n#endif\n\n\n#ifndef MP_OBJ_FROM_PTR\n#define MP_OBJ_FROM_PTR(p) ((mp_obj_t)(p))\n#endif\n\n\n\n#ifndef MP_ROM_NONE\n#if MICROPY_OBJ_IMMEDIATE_OBJS\n#define MP_ROM_NONE mp_const_none\n#else\n#define MP_ROM_NONE MP_ROM_PTR(&mp_const_none_obj)\n#endif\n#endif\n\n#ifndef MP_ROM_FALSE\n#if MICROPY_OBJ_IMMEDIATE_OBJS\n#define MP_ROM_FALSE mp_const_false\n#define MP_ROM_TRUE mp_const_true\n#else\n#define MP_ROM_FALSE MP_ROM_PTR(&mp_const_false_obj)\n#define MP_ROM_TRUE MP_ROM_PTR(&mp_const_true_obj)\n#endif\n#endif\n\n#ifndef MP_ROM_INT\ntypedef mp_const_obj_t mp_rom_obj_t;\n#define MP_ROM_INT(i) MP_OBJ_NEW_SMALL_INT(i)\n#define MP_ROM_QSTR(q) MP_OBJ_NEW_QSTR(q)\n#define MP_ROM_PTR(p) (p)\n \n#endif\n\n\n\n\n#define MP_DECLARE_CONST_FUN_OBJ_0(obj_name) extern const mp_obj_fun_builtin_fixed_t obj_name\n#define MP_DECLARE_CONST_FUN_OBJ_1(obj_name) extern const mp_obj_fun_builtin_fixed_t obj_name\n#define MP_DECLARE_CONST_FUN_OBJ_2(obj_name) extern const mp_obj_fun_builtin_fixed_t obj_name\n#define MP_DECLARE_CONST_FUN_OBJ_3(obj_name) extern const mp_obj_fun_builtin_fixed_t obj_name\n#define MP_DECLARE_CONST_FUN_OBJ_VAR(obj_name) extern const mp_obj_fun_builtin_var_t obj_name\n#define MP_DECLARE_CONST_FUN_OBJ_VAR_BETWEEN(obj_name) extern const mp_obj_fun_builtin_var_t obj_name\n#define MP_DECLARE_CONST_FUN_OBJ_KW(obj_name) extern const mp_obj_fun_builtin_var_t obj_name\n\n#define MP_OBJ_FUN_ARGS_MAX (0xffff) \n#define MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, takes_kw) ((uint32_t)((((uint32_t)(n_args_min)) << 17) | (((uint32_t)(n_args_max)) << 1) | ((takes_kw) ? 1 : 0)))\n\n#define MP_DEFINE_CONST_FUN_OBJ_0(obj_name, fun_name) \\\n    const mp_obj_fun_builtin_fixed_t obj_name = \\\n    {{&mp_type_fun_builtin_0}, .fun._0 = fun_name}\n#define MP_DEFINE_CONST_FUN_OBJ_1(obj_name, fun_name) \\\n    const mp_obj_fun_builtin_fixed_t obj_name = \\\n    {{&mp_type_fun_builtin_1}, .fun._1 = fun_name}\n#define MP_DEFINE_CONST_FUN_OBJ_2(obj_name, fun_name) \\\n    const mp_obj_fun_builtin_fixed_t obj_name = \\\n    {{&mp_type_fun_builtin_2}, .fun._2 = fun_name}\n#define MP_DEFINE_CONST_FUN_OBJ_3(obj_name, fun_name) \\\n    const mp_obj_fun_builtin_fixed_t obj_name = \\\n    {{&mp_type_fun_builtin_3}, .fun._3 = fun_name}\n#define MP_DEFINE_CONST_FUN_OBJ_VAR(obj_name, n_args_min, fun_name) \\\n    const mp_obj_fun_builtin_var_t obj_name = \\\n    {{&mp_type_fun_builtin_var}, MP_OBJ_FUN_MAKE_SIG(n_args_min, MP_OBJ_FUN_ARGS_MAX, false), .fun.var = fun_name}\n#define MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(obj_name, n_args_min, n_args_max, fun_name) \\\n    const mp_obj_fun_builtin_var_t obj_name = \\\n    {{&mp_type_fun_builtin_var}, MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, false), .fun.var = fun_name}\n#define MP_DEFINE_CONST_FUN_OBJ_KW(obj_name, n_args_min, fun_name) \\\n    const mp_obj_fun_builtin_var_t obj_name = \\\n    {{&mp_type_fun_builtin_var}, MP_OBJ_FUN_MAKE_SIG(n_args_min, MP_OBJ_FUN_ARGS_MAX, true), .fun.kw = fun_name}\n\n\n\n\n#define MP_DEFINE_CONST_MAP(map_name, table_name) \\\n    const mp_map_t map_name = { \\\n        .all_keys_are_qstrs = 1, \\\n        .is_fixed = 1, \\\n        .is_ordered = 1, \\\n        .used = MP_ARRAY_SIZE(table_name), \\\n        .alloc = MP_ARRAY_SIZE(table_name), \\\n        .table = (mp_map_elem_t *)(mp_rom_map_elem_t *)table_name, \\\n    }\n\n#define MP_DEFINE_CONST_DICT_WITH_SIZE(dict_name, table_name, n) \\\n    const mp_obj_dict_t dict_name = { \\\n        .base = {&mp_type_dict}, \\\n        .map = { \\\n            .all_keys_are_qstrs = 1, \\\n            .is_fixed = 1, \\\n            .is_ordered = 1, \\\n            .used = n, \\\n            .alloc = n, \\\n            .table = (mp_map_elem_t *)(mp_rom_map_elem_t *)table_name, \\\n        }, \\\n    }\n\n#define MP_DEFINE_CONST_DICT(dict_name, table_name) MP_DEFINE_CONST_DICT_WITH_SIZE(dict_name, table_name, MP_ARRAY_SIZE(table_name))\n\n\n\n\n#define MP_DECLARE_CONST_STATICMETHOD_OBJ(obj_name) extern const mp_rom_obj_static_class_method_t obj_name\n#define MP_DECLARE_CONST_CLASSMETHOD_OBJ(obj_name) extern const mp_rom_obj_static_class_method_t obj_name\n\n#define MP_DEFINE_CONST_STATICMETHOD_OBJ(obj_name, fun_name) const mp_rom_obj_static_class_method_t obj_name = {{&mp_type_staticmethod}, fun_name}\n#define MP_DEFINE_CONST_CLASSMETHOD_OBJ(obj_name, fun_name) const mp_rom_obj_static_class_method_t obj_name = {{&mp_type_classmethod}, fun_name}\n\n#ifndef NO_QSTR\n\n\n\n\n#define MP_REGISTER_MODULE(module_name, obj_module)\n\n\n#define MP_REGISTER_EXTENSIBLE_MODULE(module_name, obj_module)\n\n\n\n#define MP_REGISTER_MODULE_DELEGATION(obj_module, fun_name)\n\n\n\n#define MP_REGISTER_ROOT_POINTER(variable_declaration)\n\n#endif \n\n\n\ntypedef struct _mp_map_elem_t {\n    mp_obj_t key;\n    mp_obj_t value;\n} mp_map_elem_t;\n\ntypedef struct _mp_rom_map_elem_t {\n    mp_rom_obj_t key;\n    mp_rom_obj_t value;\n} mp_rom_map_elem_t;\n\ntypedef struct _mp_map_t {\n    size_t all_keys_are_qstrs : 1;\n    size_t is_fixed : 1;    \n    size_t is_ordered : 1;  \n    size_t used : (8 * sizeof(size_t) - 3);\n    size_t alloc;\n    mp_map_elem_t *table;\n} mp_map_t;\n\n\ntypedef enum _mp_map_lookup_kind_t {\n    MP_MAP_LOOKUP = 0,\n    MP_MAP_LOOKUP_ADD_IF_NOT_FOUND = 1,\n    MP_MAP_LOOKUP_REMOVE_IF_FOUND = 2,\n    MP_MAP_LOOKUP_ADD_IF_NOT_FOUND_OR_REMOVE_IF_FOUND = 3, \n} mp_map_lookup_kind_t;\n\nstatic inline bool mp_map_slot_is_filled(const mp_map_t *map, size_t pos) {\n    assert(pos < map->alloc);\n    return (map)->table[pos].key != MP_OBJ_NULL && (map)->table[pos].key != MP_OBJ_SENTINEL;\n}\n\nvoid mp_map_init(mp_map_t *map, size_t n);\nvoid mp_map_init_fixed_table(mp_map_t *map, size_t n, const mp_obj_t *table);\nmp_map_t *mp_map_new(size_t n);\nvoid mp_map_deinit(mp_map_t *map);\nvoid mp_map_free(mp_map_t *map);\nmp_map_elem_t *mp_map_lookup(mp_map_t *map, mp_obj_t index, mp_map_lookup_kind_t lookup_kind);\nvoid mp_map_clear(mp_map_t *map);\nvoid mp_map_dump(mp_map_t *map);\n\n\n\ntypedef struct _mp_set_t {\n    size_t alloc;\n    size_t used;\n    mp_obj_t *table;\n} mp_set_t;\n\nstatic inline bool mp_set_slot_is_filled(const mp_set_t *set, size_t pos) {\n    return (set)->table[pos] != MP_OBJ_NULL && (set)->table[pos] != MP_OBJ_SENTINEL;\n}\n\nvoid mp_set_init(mp_set_t *set, size_t n);\nmp_obj_t mp_set_lookup(mp_set_t *set, mp_obj_t index, mp_map_lookup_kind_t lookup_kind);\nmp_obj_t mp_set_remove_first(mp_set_t *set);\nvoid mp_set_clear(mp_set_t *set);\n\n\n\ntypedef mp_obj_t (*mp_fun_0_t)(void);\ntypedef mp_obj_t (*mp_fun_1_t)(mp_obj_t);\ntypedef mp_obj_t (*mp_fun_2_t)(mp_obj_t, mp_obj_t);\ntypedef mp_obj_t (*mp_fun_3_t)(mp_obj_t, mp_obj_t, mp_obj_t);\ntypedef mp_obj_t (*mp_fun_var_t)(size_t n, const mp_obj_t *);\n\n\ntypedef mp_obj_t (*mp_fun_kw_t)(size_t n, const mp_obj_t *, mp_map_t *);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define MP_TYPE_FLAG_NONE (0x0000)\n#define MP_TYPE_FLAG_IS_SUBCLASSED (0x0001)\n#define MP_TYPE_FLAG_HAS_SPECIAL_ACCESSORS (0x0002)\n#define MP_TYPE_FLAG_EQ_NOT_REFLEXIVE (0x0004)\n#define MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE (0x0008)\n#define MP_TYPE_FLAG_EQ_HAS_NEQ_TEST (0x0010)\n#define MP_TYPE_FLAG_BINDS_SELF (0x0020)\n#define MP_TYPE_FLAG_BUILTIN_FUN (0x0040)\n#define MP_TYPE_FLAG_ITER_IS_GETITER (0x0000)\n#define MP_TYPE_FLAG_ITER_IS_ITERNEXT (0x0080)\n#define MP_TYPE_FLAG_ITER_IS_CUSTOM (0x0100)\n#define MP_TYPE_FLAG_ITER_IS_STREAM (MP_TYPE_FLAG_ITER_IS_ITERNEXT | MP_TYPE_FLAG_ITER_IS_CUSTOM)\n#define MP_TYPE_FLAG_INSTANCE_TYPE (0x0200)\n\ntypedef enum {\n    PRINT_STR = 0,\n    PRINT_REPR = 1,\n    PRINT_EXC = 2, \n    PRINT_JSON = 3,\n    PRINT_RAW = 4, \n    PRINT_EXC_SUBCLASS = 0x80, \n} mp_print_kind_t;\n\ntypedef struct _mp_obj_iter_buf_t {\n    mp_obj_base_t base;\n    mp_obj_t buf[3];\n} mp_obj_iter_buf_t;\n\n\n\n#define MP_OBJ_ITER_BUF_NSLOTS ((sizeof(mp_obj_iter_buf_t) + sizeof(mp_obj_t) - 1) / sizeof(mp_obj_t))\n\ntypedef void (*mp_print_fun_t)(const mp_print_t *print, mp_obj_t o, mp_print_kind_t kind);\ntypedef mp_obj_t (*mp_make_new_fun_t)(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args);\ntypedef mp_obj_t (*mp_call_fun_t)(mp_obj_t fun, size_t n_args, size_t n_kw, const mp_obj_t *args);\ntypedef mp_obj_t (*mp_unary_op_fun_t)(mp_unary_op_t op, mp_obj_t);\ntypedef mp_obj_t (*mp_binary_op_fun_t)(mp_binary_op_t op, mp_obj_t, mp_obj_t);\ntypedef void (*mp_attr_fun_t)(mp_obj_t self_in, qstr attr, mp_obj_t *dest);\ntypedef mp_obj_t (*mp_subscr_fun_t)(mp_obj_t self_in, mp_obj_t index, mp_obj_t value);\ntypedef mp_obj_t (*mp_getiter_fun_t)(mp_obj_t self_in, mp_obj_iter_buf_t *iter_buf);\ntypedef mp_fun_1_t mp_iternext_fun_t;\n\n\ntypedef struct _mp_getiter_iternext_custom_t {\n    mp_getiter_fun_t getiter;\n    mp_iternext_fun_t iternext;\n} mp_getiter_iternext_custom_t;\n\n\n\ntypedef struct _mp_buffer_info_t {\n    void *buf;      \n    size_t len;     \n    int typecode;   \n} mp_buffer_info_t;\n\n#define MP_BUFFER_READ  (1)\n#define MP_BUFFER_WRITE (2)\n#define MP_BUFFER_RW (MP_BUFFER_READ | MP_BUFFER_WRITE)\n#define MP_BUFFER_RAISE_IF_UNSUPPORTED (4)\n\ntypedef mp_int_t (*mp_buffer_fun_t)(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);\n\nbool mp_get_buffer(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);\n\nstatic inline void mp_get_buffer_raise(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    mp_get_buffer(obj, bufinfo, flags | MP_BUFFER_RAISE_IF_UNSUPPORTED);\n}\n\n\n\n\nstruct _mp_obj_type_t {\n    \n    mp_obj_base_t base;\n\n    \n    uint16_t flags;\n\n    \n    uint16_t name;\n\n    \n    \n    \n    \n    \n\n    \n    uint8_t slot_index_make_new;\n\n    \n    uint8_t slot_index_print;\n\n    \n    uint8_t slot_index_call;\n\n    \n    \n    uint8_t slot_index_unary_op;\n    uint8_t slot_index_binary_op;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    uint8_t slot_index_attr;\n\n    \n    \n    \n    \n    \n    uint8_t slot_index_subscr;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    uint8_t slot_index_iter;\n\n    \n    uint8_t slot_index_buffer;\n\n    \n    uint8_t slot_index_protocol;\n\n    \n    \n    \n    \n    uint8_t slot_index_parent;\n\n    \n    uint8_t slot_index_locals_dict;\n\n    const void *slots[];\n};\n\n\n\n\n\ntypedef struct _mp_obj_empty_type_t {\n    mp_obj_base_t base;\n    uint16_t flags;\n    uint16_t name;\n\n    uint8_t slot_index_make_new;\n    uint8_t slot_index_print;\n    uint8_t slot_index_call;\n    uint8_t slot_index_unary_op;\n    uint8_t slot_index_binary_op;\n    uint8_t slot_index_attr;\n    uint8_t slot_index_subscr;\n    uint8_t slot_index_iter;\n    uint8_t slot_index_buffer;\n    uint8_t slot_index_protocol;\n    uint8_t slot_index_parent;\n    uint8_t slot_index_locals_dict;\n\n    \n} mp_obj_empty_type_t;\n\ntypedef struct _mp_obj_full_type_t {\n    mp_obj_base_t base;\n    uint16_t flags;\n    uint16_t name;\n\n    uint8_t slot_index_make_new;\n    uint8_t slot_index_print;\n    uint8_t slot_index_call;\n    uint8_t slot_index_unary_op;\n    uint8_t slot_index_binary_op;\n    uint8_t slot_index_attr;\n    uint8_t slot_index_subscr;\n    uint8_t slot_index_iter;\n    uint8_t slot_index_buffer;\n    uint8_t slot_index_protocol;\n    uint8_t slot_index_parent;\n    uint8_t slot_index_locals_dict;\n\n    \n    const void *slots[11];\n} mp_obj_full_type_t;\n\n#define _MP_OBJ_TYPE_SLOT_TYPE_make_new (mp_make_new_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_print (mp_print_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_call (mp_call_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_unary_op (mp_unary_op_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_binary_op (mp_binary_op_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_attr (mp_attr_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_subscr (mp_subscr_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_iter (const void *)\n#define _MP_OBJ_TYPE_SLOT_TYPE_buffer (mp_buffer_fun_t)\n#define _MP_OBJ_TYPE_SLOT_TYPE_protocol (const void *)\n#define _MP_OBJ_TYPE_SLOT_TYPE_parent (const void *)\n#define _MP_OBJ_TYPE_SLOT_TYPE_locals_dict (struct _mp_obj_dict_t *)\n\n\n\n\n\n\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_0(_struct_type, _typename, _name, _flags) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_1(_struct_type, _typename, _name, _flags, f1, v1) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slots = { v1, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_2(_struct_type, _typename, _name, _flags, f1, v1, f2, v2) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slots = { v1, v2, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_3(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slots = { v1, v2, v3, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_4(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slots = { v1, v2, v3, v4, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_5(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slots = { v1, v2, v3, v4, v5, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_6(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slots = { v1, v2, v3, v4, v5, v6, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_7(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slot_index_##f7 = 7, .slots = { v1, v2, v3, v4, v5, v6, v7, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_8(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slot_index_##f7 = 7, .slot_index_##f8 = 8, .slots = { v1, v2, v3, v4, v5, v6, v7, v8, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_9(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8, f9, v9) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slot_index_##f7 = 7, .slot_index_##f8 = 8, .slot_index_##f9 = 9, .slots = { v1, v2, v3, v4, v5, v6, v7, v8, v9, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_10(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8, f9, v9, f10, v10) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slot_index_##f7 = 7, .slot_index_##f8 = 8, .slot_index_##f9 = 9, .slot_index_##f10 = 10, .slots = { v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_11(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8, f9, v9, f10, v10, f11, v11) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slot_index_##f7 = 7, .slot_index_##f8 = 8, .slot_index_##f9 = 9, .slot_index_##f10 = 10, .slot_index_##f11 = 11, .slots = { v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, } }\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS_12(_struct_type, _typename, _name, _flags, f1, v1, f2, v2, f3, v3, f4, v4, f5, v5, f6, v6, f7, v7, f8, v8, f9, v9, f10, v10, f11, v11, f12, v12) const _struct_type _typename = { .base = { &mp_type_type }, .flags = _flags, .name = _name, .slot_index_##f1 = 1, .slot_index_##f2 = 2, .slot_index_##f3 = 3, .slot_index_##f4 = 4, .slot_index_##f5 = 5, .slot_index_##f6 = 6, .slot_index_##f7 = 7, .slot_index_##f8 = 8, .slot_index_##f9 = 9, .slot_index_##f10 = 10, .slot_index_##f11 = 11, .slot_index_##f12 = 12, .slots = { v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, } }\n\n\n\n\n\n\n\n#define MP_OBJ_TYPE_HAS_SLOT(t, f) ((t)->slot_index_##f)\n#define MP_OBJ_TYPE_GET_SLOT(t, f) (_MP_OBJ_TYPE_SLOT_TYPE_##f(t)->slots[(t)->slot_index_##f - 1])\n#define MP_OBJ_TYPE_GET_SLOT_OR_NULL(t, f) (_MP_OBJ_TYPE_SLOT_TYPE_##f(MP_OBJ_TYPE_HAS_SLOT(t, f) ? MP_OBJ_TYPE_GET_SLOT(t, f) : NULL))\n#define MP_OBJ_TYPE_SET_SLOT(t, f, v, n) ((t)->slot_index_##f = (n) + 1, (t)->slots[(n)] = (void *)v)\n#define MP_OBJ_TYPE_OFFSETOF_SLOT(f) (offsetof(mp_obj_type_t, slot_index_##f))\n#define MP_OBJ_TYPE_HAS_SLOT_BY_OFFSET(t, offset) (*(uint8_t *)((char *)(t) + (offset)) != 0)\n\n\n#define MP_DEFINE_CONST_OBJ_TYPE_EXPAND(x) x\n\n\n\n#define MP_DEFINE_CONST_OBJ_TYPE_NARGS(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, N, ...) MP_DEFINE_CONST_OBJ_TYPE_NARGS_##N\n\n\n\n\n\n\n\n\n#define MP_DEFINE_CONST_OBJ_TYPE(...) MP_DEFINE_CONST_OBJ_TYPE_EXPAND(MP_DEFINE_CONST_OBJ_TYPE_NARGS(__VA_ARGS__, _INV, 12, _INV, 11, _INV, 10, _INV, 9, _INV, 8, _INV, 7, _INV, 6, _INV, 5, _INV, 4, _INV, 3, _INV, 2, _INV, 1, _INV, 0)(mp_obj_type_t, __VA_ARGS__))\n\n\nextern const mp_obj_type_t mp_type_type;\nextern const mp_obj_type_t mp_type_object;\nextern const mp_obj_type_t mp_type_NoneType;\nextern const mp_obj_type_t mp_type_bool;\nextern const mp_obj_type_t mp_type_int;\nextern const mp_obj_type_t mp_type_str;\nextern const mp_obj_type_t mp_type_bytes;\nextern const mp_obj_type_t mp_type_bytearray;\nextern const mp_obj_type_t mp_type_memoryview;\nextern const mp_obj_type_t mp_type_float;\nextern const mp_obj_type_t mp_type_complex;\nextern const mp_obj_type_t mp_type_tuple;\nextern const mp_obj_type_t mp_type_list;\nextern const mp_obj_type_t mp_type_map; \nextern const mp_obj_type_t mp_type_enumerate;\nextern const mp_obj_type_t mp_type_filter;\nextern const mp_obj_type_t mp_type_deque;\nextern const mp_obj_type_t mp_type_dict;\nextern const mp_obj_type_t mp_type_ordereddict;\nextern const mp_obj_type_t mp_type_range;\nextern const mp_obj_type_t mp_type_set;\nextern const mp_obj_type_t mp_type_frozenset;\nextern const mp_obj_type_t mp_type_slice;\nextern const mp_obj_type_t mp_type_zip;\nextern const mp_obj_type_t mp_type_array;\nextern const mp_obj_type_t mp_type_super;\nextern const mp_obj_type_t mp_type_gen_wrap;\nextern const mp_obj_type_t mp_type_native_gen_wrap;\nextern const mp_obj_type_t mp_type_gen_instance;\nextern const mp_obj_type_t mp_type_fun_builtin_0;\nextern const mp_obj_type_t mp_type_fun_builtin_1;\nextern const mp_obj_type_t mp_type_fun_builtin_2;\nextern const mp_obj_type_t mp_type_fun_builtin_3;\nextern const mp_obj_type_t mp_type_fun_builtin_var;\nextern const mp_obj_type_t mp_type_fun_bc;\nextern const mp_obj_type_t mp_type_fun_native;\nextern const mp_obj_type_t mp_type_fun_viper;\nextern const mp_obj_type_t mp_type_fun_asm;\nextern const mp_obj_type_t mp_type_module;\nextern const mp_obj_type_t mp_type_staticmethod;\nextern const mp_obj_type_t mp_type_classmethod;\nextern const mp_obj_type_t mp_type_bound_meth;\nextern const mp_obj_type_t mp_type_property;\nextern const mp_obj_type_t mp_type_stringio;\nextern const mp_obj_type_t mp_type_bytesio;\nextern const mp_obj_type_t mp_type_reversed;\nextern const mp_obj_type_t mp_type_polymorph_iter;\n#if MICROPY_ENABLE_FINALISER\nextern const mp_obj_type_t mp_type_polymorph_iter_with_finaliser;\n#endif\n\n\nextern const mp_obj_type_t mp_type_BaseException;\nextern const mp_obj_type_t mp_type_ArithmeticError;\nextern const mp_obj_type_t mp_type_AssertionError;\nextern const mp_obj_type_t mp_type_AttributeError;\nextern const mp_obj_type_t mp_type_EOFError;\nextern const mp_obj_type_t mp_type_Exception;\nextern const mp_obj_type_t mp_type_GeneratorExit;\nextern const mp_obj_type_t mp_type_ImportError;\nextern const mp_obj_type_t mp_type_IndentationError;\nextern const mp_obj_type_t mp_type_IndexError;\nextern const mp_obj_type_t mp_type_KeyboardInterrupt;\nextern const mp_obj_type_t mp_type_KeyError;\nextern const mp_obj_type_t mp_type_LookupError;\nextern const mp_obj_type_t mp_type_MemoryError;\nextern const mp_obj_type_t mp_type_NameError;\nextern const mp_obj_type_t mp_type_NotImplementedError;\nextern const mp_obj_type_t mp_type_OSError;\nextern const mp_obj_type_t mp_type_OverflowError;\nextern const mp_obj_type_t mp_type_RuntimeError;\nextern const mp_obj_type_t mp_type_StopAsyncIteration;\nextern const mp_obj_type_t mp_type_StopIteration;\nextern const mp_obj_type_t mp_type_SyntaxError;\nextern const mp_obj_type_t mp_type_SystemExit;\nextern const mp_obj_type_t mp_type_TypeError;\nextern const mp_obj_type_t mp_type_UnicodeError;\nextern const mp_obj_type_t mp_type_ValueError;\nextern const mp_obj_type_t mp_type_ViperTypeError;\nextern const mp_obj_type_t mp_type_ZeroDivisionError;\n\n\n\n#if MICROPY_OBJ_IMMEDIATE_OBJS\n\n#define mp_const_none MP_OBJ_NEW_IMMEDIATE_OBJ(0)\n#define mp_const_false MP_OBJ_NEW_IMMEDIATE_OBJ(1)\n#define mp_const_true MP_OBJ_NEW_IMMEDIATE_OBJ(3)\n#else\n#define mp_const_none (MP_OBJ_FROM_PTR(&mp_const_none_obj))\n#define mp_const_false (MP_OBJ_FROM_PTR(&mp_const_false_obj))\n#define mp_const_true (MP_OBJ_FROM_PTR(&mp_const_true_obj))\nextern const struct _mp_obj_none_t mp_const_none_obj;\nextern const struct _mp_obj_bool_t mp_const_false_obj;\nextern const struct _mp_obj_bool_t mp_const_true_obj;\n#endif\n\n\n\n#define mp_const_empty_bytes (MP_OBJ_FROM_PTR(&mp_const_empty_bytes_obj))\n#define mp_const_empty_tuple (MP_OBJ_FROM_PTR(&mp_const_empty_tuple_obj))\n#define mp_const_notimplemented (MP_OBJ_FROM_PTR(&mp_const_notimplemented_obj))\nextern const struct _mp_obj_str_t mp_const_empty_bytes_obj;\nextern const struct _mp_obj_tuple_t mp_const_empty_tuple_obj;\nextern const struct _mp_obj_dict_t mp_const_empty_dict_obj;\nextern const struct _mp_obj_singleton_t mp_const_ellipsis_obj;\nextern const struct _mp_obj_singleton_t mp_const_notimplemented_obj;\nextern const struct _mp_obj_exception_t mp_const_GeneratorExit_obj;\n\n\n\n#define mp_const_empty_map (mp_const_empty_dict_obj.map)\n\n\n\n\n\n#define mp_obj_malloc(struct_type, obj_type) ((struct_type *)mp_obj_malloc_helper(sizeof(struct_type), obj_type))\n#define mp_obj_malloc_var(struct_type, var_field, var_type, var_num, obj_type) ((struct_type *)mp_obj_malloc_helper(offsetof(struct_type, var_field) + sizeof(var_type) * (var_num), obj_type))\nvoid *mp_obj_malloc_helper(size_t num_bytes, const mp_obj_type_t *type);\n\n\n#if MICROPY_ENABLE_FINALISER\n#define mp_obj_malloc_with_finaliser(struct_type, obj_type) ((struct_type *)mp_obj_malloc_with_finaliser_helper(sizeof(struct_type), obj_type))\n#define mp_obj_malloc_var_with_finaliser(struct_type, var_type, var_num, obj_type) ((struct_type *)mp_obj_malloc_with_finaliser_helper(sizeof(struct_type) + sizeof(var_type) * (var_num), obj_type))\nvoid *mp_obj_malloc_with_finaliser_helper(size_t num_bytes, const mp_obj_type_t *type);\n#else\n#define mp_obj_malloc_with_finaliser(struct_type, obj_type) mp_obj_malloc(struct_type, obj_type)\n#define mp_obj_malloc_var_with_finaliser(struct_type, var_type, var_num, obj_type) mp_obj_malloc_var(struct_type, var_type, var_num, obj_type)\n#endif\n\n\n\n\n\n\n\n#define mp_obj_is_exact_type(o, t) (mp_obj_is_obj(o) && (((mp_obj_base_t *)MP_OBJ_TO_PTR(o))->type == (t)))\n\n\n\n\n#define mp_type_assert_not_bool_int_str_nonetype(t) (                                     \\\n    MP_STATIC_ASSERT_NONCONSTEXPR((t) != &mp_type_bool), assert((t) != &mp_type_bool),         \\\n    MP_STATIC_ASSERT_NONCONSTEXPR((t) != &mp_type_int), assert((t) != &mp_type_int),           \\\n    MP_STATIC_ASSERT_NONCONSTEXPR((t) != &mp_type_str), assert((t) != &mp_type_str),           \\\n    MP_STATIC_ASSERT_NONCONSTEXPR((t) != &mp_type_NoneType), assert((t) != &mp_type_NoneType), \\\n    1)\n\n#define mp_obj_is_type(o, t) (mp_type_assert_not_bool_int_str_nonetype(t) && mp_obj_is_exact_type(o, t))\n#if MICROPY_OBJ_IMMEDIATE_OBJS\n\n#define mp_obj_is_bool(o) ((o) == mp_const_false || (o) == mp_const_true)\n#else\n#define mp_obj_is_bool(o) mp_obj_is_exact_type(o, &mp_type_bool)\n#endif\n#define mp_obj_is_int(o) (mp_obj_is_small_int(o) || mp_obj_is_exact_type(o, &mp_type_int))\n#define mp_obj_is_str(o) (mp_obj_is_qstr(o) || mp_obj_is_exact_type(o, &mp_type_str))\n#define mp_obj_is_str_or_bytes(o) (mp_obj_is_qstr(o) || (mp_obj_is_obj(o) && MP_OBJ_TYPE_GET_SLOT_OR_NULL(((mp_obj_base_t *)MP_OBJ_TO_PTR(o))->type, binary_op) == mp_obj_str_binary_op))\nbool mp_obj_is_dict_or_ordereddict(mp_obj_t o);\n#define mp_obj_is_fun(o) (mp_obj_is_obj(o) && (((mp_obj_base_t *)MP_OBJ_TO_PTR(o))->type->name == MP_QSTR_function))\n\nmp_obj_t mp_obj_new_type(qstr name, mp_obj_t bases_tuple, mp_obj_t locals_dict);\nstatic inline mp_obj_t mp_obj_new_bool(mp_int_t x) {\n    return x ? mp_const_true : mp_const_false;\n}\nmp_obj_t mp_obj_new_cell(mp_obj_t obj);\nmp_obj_t mp_obj_new_int(mp_int_t value);\nmp_obj_t mp_obj_new_int_from_uint(mp_uint_t value);\nmp_obj_t mp_obj_new_int_from_str_len(const char **str, size_t len, bool neg, unsigned int base);\nmp_obj_t mp_obj_new_int_from_ll(long long val); \nmp_obj_t mp_obj_new_int_from_ull(unsigned long long val); \nmp_obj_t mp_obj_new_str(const char *data, size_t len); \nmp_obj_t mp_obj_new_str_via_qstr(const char *data, size_t len); \nmp_obj_t mp_obj_new_str_from_vstr(vstr_t *vstr); \n#if MICROPY_PY_BUILTINS_STR_UNICODE && MICROPY_PY_BUILTINS_STR_UNICODE_CHECK\nmp_obj_t mp_obj_new_str_from_utf8_vstr(vstr_t *vstr); \n#else\n#define mp_obj_new_str_from_utf8_vstr mp_obj_new_str_from_vstr\n#endif\nmp_obj_t mp_obj_new_bytes_from_vstr(vstr_t *vstr);\nmp_obj_t mp_obj_new_bytes(const byte *data, size_t len);\nmp_obj_t mp_obj_new_bytearray(size_t n, const void *items);\nmp_obj_t mp_obj_new_bytearray_by_ref(size_t n, void *items);\n#if MICROPY_PY_BUILTINS_FLOAT\nmp_obj_t mp_obj_new_int_from_float(mp_float_t val);\nmp_obj_t mp_obj_new_complex(mp_float_t real, mp_float_t imag);\n#endif\nmp_obj_t mp_obj_new_exception(const mp_obj_type_t *exc_type);\nmp_obj_t mp_obj_new_exception_args(const mp_obj_type_t *exc_type, size_t n_args, const mp_obj_t *args);\n#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NONE\n#define mp_obj_new_exception_msg(exc_type, msg) mp_obj_new_exception(exc_type)\n#define mp_obj_new_exception_msg_varg(exc_type, ...) mp_obj_new_exception(exc_type)\n#else\nmp_obj_t mp_obj_new_exception_msg(const mp_obj_type_t *exc_type, mp_rom_error_text_t msg);\nmp_obj_t mp_obj_new_exception_msg_varg(const mp_obj_type_t *exc_type, mp_rom_error_text_t fmt, ...); \n#endif\n#ifdef va_start\nmp_obj_t mp_obj_new_exception_msg_vlist(const mp_obj_type_t *exc_type, mp_rom_error_text_t fmt, va_list arg); \n#endif\nmp_obj_t mp_obj_new_gen_wrap(mp_obj_t fun);\nmp_obj_t mp_obj_new_closure(mp_obj_t fun, size_t n_closed, const mp_obj_t *closed);\nmp_obj_t mp_obj_new_tuple(size_t n, const mp_obj_t *items);\nmp_obj_t mp_obj_new_list(size_t n, mp_obj_t *items);\nmp_obj_t mp_obj_new_dict(size_t n_args);\nmp_obj_t mp_obj_new_set(size_t n_args, mp_obj_t *items);\nmp_obj_t mp_obj_new_slice(mp_obj_t start, mp_obj_t stop, mp_obj_t step);\nmp_obj_t mp_obj_new_bound_meth(mp_obj_t meth, mp_obj_t self);\nmp_obj_t mp_obj_new_getitem_iter(mp_obj_t *args, mp_obj_iter_buf_t *iter_buf);\nmp_obj_t mp_obj_new_module(qstr module_name);\nmp_obj_t mp_obj_new_memoryview(byte typecode, size_t nitems, void *items);\n\nconst mp_obj_type_t *mp_obj_get_type(mp_const_obj_t o_in);\nconst char *mp_obj_get_type_str(mp_const_obj_t o_in);\nbool mp_obj_is_subclass_fast(mp_const_obj_t object, mp_const_obj_t classinfo); \nmp_obj_t mp_obj_cast_to_native_base(mp_obj_t self_in, mp_const_obj_t native_type);\n\nvoid mp_obj_print_helper(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind);\nvoid mp_obj_print(mp_obj_t o, mp_print_kind_t kind);\nvoid mp_obj_print_exception(const mp_print_t *print, mp_obj_t exc);\n\nbool mp_obj_is_true(mp_obj_t arg);\nbool mp_obj_is_callable(mp_obj_t o_in);\nmp_obj_t mp_obj_equal_not_equal(mp_binary_op_t op, mp_obj_t o1, mp_obj_t o2);\nbool mp_obj_equal(mp_obj_t o1, mp_obj_t o2);\n\n\nstatic inline bool mp_obj_is_integer(mp_const_obj_t o) {\n    return mp_obj_is_int(o) || mp_obj_is_bool(o);\n}\n\nmp_int_t mp_obj_get_int(mp_const_obj_t arg);\nmp_int_t mp_obj_get_int_truncated(mp_const_obj_t arg);\nbool mp_obj_get_int_maybe(mp_const_obj_t arg, mp_int_t *value);\n#if MICROPY_PY_BUILTINS_FLOAT\nmp_float_t mp_obj_get_float(mp_obj_t self_in);\nbool mp_obj_get_float_maybe(mp_obj_t arg, mp_float_t *value);\nvoid mp_obj_get_complex(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);\nbool mp_obj_get_complex_maybe(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);\n#endif\nvoid mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items); \nvoid mp_obj_get_array_fixed_n(mp_obj_t o, size_t len, mp_obj_t **items); \nsize_t mp_get_index(const mp_obj_type_t *type, size_t len, mp_obj_t index, bool is_slice);\nmp_obj_t mp_obj_id(mp_obj_t o_in);\nmp_obj_t mp_obj_len(mp_obj_t o_in);\nmp_obj_t mp_obj_len_maybe(mp_obj_t o_in); \nmp_obj_t mp_obj_subscr(mp_obj_t base, mp_obj_t index, mp_obj_t val);\n\n\n\ntypedef struct _mp_obj_cell_t {\n    mp_obj_base_t base;\n    mp_obj_t obj;\n} mp_obj_cell_t;\n\nstatic inline mp_obj_t mp_obj_cell_get(mp_obj_t self_in) {\n    mp_obj_cell_t *self = (mp_obj_cell_t *)MP_OBJ_TO_PTR(self_in);\n    return self->obj;\n}\n\nstatic inline void mp_obj_cell_set(mp_obj_t self_in, mp_obj_t obj) {\n    mp_obj_cell_t *self = (mp_obj_cell_t *)MP_OBJ_TO_PTR(self_in);\n    self->obj = obj;\n}\n\n\n\nmp_int_t mp_obj_int_get_truncated(mp_const_obj_t self_in);\n\nmp_int_t mp_obj_int_get_checked(mp_const_obj_t self_in);\n\nmp_uint_t mp_obj_int_get_uint_checked(mp_const_obj_t self_in);\n\n\nbool mp_obj_is_native_exception_instance(mp_obj_t self_in);\nbool mp_obj_is_exception_type(mp_obj_t self_in);\nbool mp_obj_is_exception_instance(mp_obj_t self_in);\nbool mp_obj_exception_match(mp_obj_t exc, mp_const_obj_t exc_type);\nvoid mp_obj_exception_clear_traceback(mp_obj_t self_in);\nvoid mp_obj_exception_add_traceback(mp_obj_t self_in, qstr file, size_t line, qstr block);\nvoid mp_obj_exception_get_traceback(mp_obj_t self_in, size_t *n, size_t **values);\nmp_obj_t mp_obj_exception_get_value(mp_obj_t self_in);\nmp_obj_t mp_obj_exception_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args);\nmp_obj_t mp_alloc_emergency_exception_buf(mp_obj_t size_in);\nvoid mp_init_emergency_exception_buf(void);\nstatic inline mp_obj_t mp_obj_new_exception_arg1(const mp_obj_type_t *exc_type, mp_obj_t arg) {\n    assert(MP_OBJ_TYPE_GET_SLOT_OR_NULL(exc_type, make_new) == mp_obj_exception_make_new);\n    return mp_obj_exception_make_new(exc_type, 1, 0, &arg);\n}\n\n\nbool mp_obj_str_equal(mp_obj_t s1, mp_obj_t s2);\nqstr mp_obj_str_get_qstr(mp_obj_t self_in); \nconst char *mp_obj_str_get_str(mp_obj_t self_in); \nconst char *mp_obj_str_get_data(mp_obj_t self_in, size_t *len);\nmp_obj_t mp_obj_str_intern(mp_obj_t str);\nmp_obj_t mp_obj_str_intern_checked(mp_obj_t obj);\nvoid mp_str_print_quoted(const mp_print_t *print, const byte *str_data, size_t str_len, bool is_bytes);\n\n#if MICROPY_PY_BUILTINS_FLOAT\n\n#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\nstatic inline float mp_obj_get_float_to_f(mp_obj_t o) {\n    return mp_obj_get_float(o);\n}\n\nstatic inline double mp_obj_get_float_to_d(mp_obj_t o) {\n    return (double)mp_obj_get_float(o);\n}\n\nstatic inline mp_obj_t mp_obj_new_float_from_f(float o) {\n    return mp_obj_new_float(o);\n}\n\nstatic inline mp_obj_t mp_obj_new_float_from_d(double o) {\n    return mp_obj_new_float((mp_float_t)o);\n}\n#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\nstatic inline float mp_obj_get_float_to_f(mp_obj_t o) {\n    return (float)mp_obj_get_float(o);\n}\n\nstatic inline double mp_obj_get_float_to_d(mp_obj_t o) {\n    return mp_obj_get_float(o);\n}\n\nstatic inline mp_obj_t mp_obj_new_float_from_f(float o) {\n    return mp_obj_new_float((mp_float_t)o);\n}\n\nstatic inline mp_obj_t mp_obj_new_float_from_d(double o) {\n    return mp_obj_new_float(o);\n}\n#endif\n#if MICROPY_FLOAT_HIGH_QUALITY_HASH\nmp_int_t mp_float_hash(mp_float_t val);\n#else\nstatic inline mp_int_t mp_float_hash(mp_float_t val) {\n    return (mp_int_t)val;\n}\n#endif\nmp_obj_t mp_obj_float_binary_op(mp_binary_op_t op, mp_float_t lhs_val, mp_obj_t rhs); \n\n\nvoid mp_obj_complex_get(mp_obj_t self_in, mp_float_t *real, mp_float_t *imag);\nmp_obj_t mp_obj_complex_binary_op(mp_binary_op_t op, mp_float_t lhs_real, mp_float_t lhs_imag, mp_obj_t rhs_in); \n#else\n#define mp_obj_is_float(o) (false)\n#endif\n\n\nvoid mp_obj_tuple_get(mp_obj_t self_in, size_t *len, mp_obj_t **items);\nvoid mp_obj_tuple_del(mp_obj_t self_in);\nmp_int_t mp_obj_tuple_hash(mp_obj_t self_in);\n\n\nmp_obj_t mp_obj_list_append(mp_obj_t self_in, mp_obj_t arg);\nmp_obj_t mp_obj_list_remove(mp_obj_t self_in, mp_obj_t value);\nvoid mp_obj_list_get(mp_obj_t self_in, size_t *len, mp_obj_t **items);\nvoid mp_obj_list_set_len(mp_obj_t self_in, size_t len);\nvoid mp_obj_list_store(mp_obj_t self_in, mp_obj_t index, mp_obj_t value);\nmp_obj_t mp_obj_list_sort(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs);\n\n\ntypedef struct _mp_obj_dict_t {\n    mp_obj_base_t base;\n    mp_map_t map;\n} mp_obj_dict_t;\nmp_obj_t mp_obj_dict_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args);\nvoid mp_obj_dict_init(mp_obj_dict_t *dict, size_t n_args);\nsize_t mp_obj_dict_len(mp_obj_t self_in);\nmp_obj_t mp_obj_dict_get(mp_obj_t self_in, mp_obj_t index);\nmp_obj_t mp_obj_dict_store(mp_obj_t self_in, mp_obj_t key, mp_obj_t value);\nmp_obj_t mp_obj_dict_delete(mp_obj_t self_in, mp_obj_t key);\nmp_obj_t mp_obj_dict_copy(mp_obj_t self_in);\nstatic inline mp_map_t *mp_obj_dict_get_map(mp_obj_t dict) {\n    return &((mp_obj_dict_t *)MP_OBJ_TO_PTR(dict))->map;\n}\n\n\nvoid mp_obj_set_store(mp_obj_t self_in, mp_obj_t item);\n\n\ntypedef struct {\n    mp_int_t start;\n    mp_int_t stop;\n    mp_int_t step;\n} mp_bound_slice_t;\n\n\ntypedef struct _mp_obj_slice_t {\n    mp_obj_base_t base;\n    mp_obj_t start;\n    mp_obj_t stop;\n    mp_obj_t step;\n} mp_obj_slice_t;\nvoid mp_obj_slice_indices(mp_obj_t self_in, mp_int_t length, mp_bound_slice_t *result);\n\n\n\ntypedef struct _mp_obj_fun_builtin_fixed_t {\n    mp_obj_base_t base;\n    union {\n        mp_fun_0_t _0;\n        mp_fun_1_t _1;\n        mp_fun_2_t _2;\n        mp_fun_3_t _3;\n    } fun;\n} mp_obj_fun_builtin_fixed_t;\n\ntypedef struct _mp_obj_fun_builtin_var_t {\n    mp_obj_base_t base;\n    uint32_t sig; \n    union {\n        mp_fun_var_t var;\n        mp_fun_kw_t kw;\n    } fun;\n} mp_obj_fun_builtin_var_t;\n\nqstr mp_obj_fun_get_name(mp_const_obj_t fun);\n\nmp_obj_t mp_identity(mp_obj_t self);\nMP_DECLARE_CONST_FUN_OBJ_1(mp_identity_obj);\n\n\ntypedef struct _mp_obj_module_t {\n    mp_obj_base_t base;\n    mp_obj_dict_t *globals;\n} mp_obj_module_t;\nstatic inline mp_obj_dict_t *mp_obj_module_get_globals(mp_obj_t module) {\n    return ((mp_obj_module_t *)MP_OBJ_TO_PTR(module))->globals;\n}\n\n\n\ntypedef struct _mp_obj_static_class_method_t {\n    mp_obj_base_t base;\n    mp_obj_t fun;\n} mp_obj_static_class_method_t;\ntypedef struct _mp_rom_obj_static_class_method_t {\n    mp_obj_base_t base;\n    mp_rom_obj_t fun;\n} mp_rom_obj_static_class_method_t;\n\n\nconst mp_obj_t *mp_obj_property_get(mp_obj_t self_in);\n\n\n\nvoid mp_seq_multiply(const void *items, size_t item_sz, size_t len, size_t times, void *dest);\n#if MICROPY_PY_BUILTINS_SLICE\nbool mp_seq_get_fast_slice_indexes(mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes);\n#endif\n#define mp_seq_copy(dest, src, len, item_t) memcpy(dest, src, len * sizeof(item_t))\n#define mp_seq_cat(dest, src1, len1, src2, len2, item_t) { memcpy(dest, src1, (len1) * sizeof(item_t)); memcpy(dest + (len1), src2, (len2) * sizeof(item_t)); }\nbool mp_seq_cmp_bytes(mp_uint_t op, const byte *data1, size_t len1, const byte *data2, size_t len2);\nbool mp_seq_cmp_objs(mp_uint_t op, const mp_obj_t *items1, size_t len1, const mp_obj_t *items2, size_t len2);\nmp_obj_t mp_seq_index_obj(const mp_obj_t *items, size_t len, size_t n_args, const mp_obj_t *args);\nmp_obj_t mp_seq_count_obj(const mp_obj_t *items, size_t len, mp_obj_t value);\nmp_obj_t mp_seq_extract_slice(size_t len, const mp_obj_t *seq, mp_bound_slice_t *indexes);\n\n\n#define mp_seq_clear(start, len, alloc_len, item_sz) memset((byte *)(start) + (len) * (item_sz), 0, ((alloc_len) - (len)) * (item_sz))\n\n\n#define mp_seq_replace_slice_no_grow(dest, dest_len, beg, end, slice, slice_len, item_sz) \\\n    memmove(((char *)dest) + (beg) * (item_sz), slice, slice_len * (item_sz)); \\\n    memmove(((char *)dest) + (beg + slice_len) * (item_sz), ((char *)dest) + (end) * (item_sz), (dest_len - end) * (item_sz));\n\n\n#define mp_seq_replace_slice_grow_inplace(dest, dest_len, beg, end, slice, slice_len, len_adj, item_sz) \\\n    memmove(((char *)dest) + (beg + slice_len) * (item_sz), ((char *)dest) + (end) * (item_sz), ((dest_len) + (len_adj) - ((beg) + (slice_len))) * (item_sz)); \\\n    memmove(((char *)dest) + (beg) * (item_sz), slice, slice_len * (item_sz));\n\n\n#define MP_OBJ_IS_SMALL_INT mp_obj_is_small_int\n#define MP_OBJ_IS_QSTR mp_obj_is_qstr\n#define MP_OBJ_IS_OBJ mp_obj_is_obj\n#define MP_OBJ_IS_INT mp_obj_is_int\n#define MP_OBJ_IS_TYPE mp_obj_is_type\n#define MP_OBJ_IS_STR mp_obj_is_str\n#define MP_OBJ_IS_STR_OR_BYTES mp_obj_is_str_or_bytes\n#define MP_OBJ_IS_FUN mp_obj_is_fun\n#define MP_MAP_SLOT_IS_FILLED mp_map_slot_is_filled\n#define MP_SET_SLOT_IS_FILLED mp_set_slot_is_filled\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}