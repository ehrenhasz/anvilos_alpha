{
  "module_name": "makeqstrdata.py",
  "hash_id": "aa983b1fcafe0519eade3878b298b159fefa1f036ebd55f569a57c95018da308",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/makeqstrdata.py",
  "human_readable_source": "\"\"\"\nProcess raw qstr file and output qstr data with length, hash and data bytes.\n\nThis script works with Python 2.6, 2.7, 3.3 and 3.4.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport re\nimport sys\n\n# Python 2/3 compatibility:\n#   - iterating through bytes is different\n#   - codepoint2name lives in a different module\nimport platform\n\nif platform.python_version_tuple()[0] == \"2\":\n    bytes_cons = lambda val, enc=None: bytearray(val)\n    from htmlentitydefs import codepoint2name\nelif platform.python_version_tuple()[0] == \"3\":\n    bytes_cons = bytes\n    from html.entities import codepoint2name\n# end compatibility code\n\ncodepoint2name[ord(\"-\")] = \"hyphen\"\n\n# add some custom names to map characters that aren't in HTML\ncodepoint2name[ord(\" \")] = \"space\"\ncodepoint2name[ord(\"'\")] = \"squot\"\ncodepoint2name[ord(\",\")] = \"comma\"\ncodepoint2name[ord(\".\")] = \"dot\"\ncodepoint2name[ord(\":\")] = \"colon\"\ncodepoint2name[ord(\";\")] = \"semicolon\"\ncodepoint2name[ord(\"/\")] = \"slash\"\ncodepoint2name[ord(\"%\")] = \"percent\"\ncodepoint2name[ord(\"#\")] = \"hash\"\ncodepoint2name[ord(\"(\")] = \"paren_open\"\ncodepoint2name[ord(\")\")] = \"paren_close\"\ncodepoint2name[ord(\"[\")] = \"bracket_open\"\ncodepoint2name[ord(\"]\")] = \"bracket_close\"\ncodepoint2name[ord(\"{\")] = \"brace_open\"\ncodepoint2name[ord(\"}\")] = \"brace_close\"\ncodepoint2name[ord(\"*\")] = \"star\"\ncodepoint2name[ord(\"!\")] = \"bang\"\ncodepoint2name[ord(\"\\\\\")] = \"backslash\"\ncodepoint2name[ord(\"+\")] = \"plus\"\ncodepoint2name[ord(\"$\")] = \"dollar\"\ncodepoint2name[ord(\"=\")] = \"equals\"\ncodepoint2name[ord(\"?\")] = \"question\"\ncodepoint2name[ord(\"@\")] = \"at_sign\"\ncodepoint2name[ord(\"^\")] = \"caret\"\ncodepoint2name[ord(\"|\")] = \"pipe\"\ncodepoint2name[ord(\"~\")] = \"tilde\"\n\n# static qstrs, these must maintain a specific order for .mpy compatibility\n# See QSTR_LAST_STATIC at the top of py/persistentcode.c\n\nstatic_qstr_list = [\n    \"\",\n    \"__dir__\",  # Put __dir__ after empty qstr for builtin dir() to work\n    \"\\n\",\n    \" \",\n    \"*\",\n    \"/\",\n    \"<module>\",\n    \"_\",\n    \"__call__\",\n    \"__class__\",\n    \"__delitem__\",\n    \"__enter__\",\n    \"__exit__\",\n    \"__getattr__\",\n    \"__getitem__\",\n    \"__hash__\",\n    \"__init__\",\n    \"__int__\",\n    \"__iter__\",\n    \"__len__\",\n    \"__main__\",\n    \"__module__\",\n    \"__name__\",\n    \"__new__\",\n    \"__next__\",\n    \"__qualname__\",\n    \"__repr__\",\n    \"__setitem__\",\n    \"__str__\",\n    \"ArithmeticError\",\n    \"AssertionError\",\n    \"AttributeError\",\n    \"BaseException\",\n    \"EOFError\",\n    \"Ellipsis\",\n    \"Exception\",\n    \"GeneratorExit\",\n    \"ImportError\",\n    \"IndentationError\",\n    \"IndexError\",\n    \"KeyError\",\n    \"KeyboardInterrupt\",\n    \"LookupError\",\n    \"MemoryError\",\n    \"NameError\",\n    \"NoneType\",\n    \"NotImplementedError\",\n    \"OSError\",\n    \"OverflowError\",\n    \"RuntimeError\",\n    \"StopIteration\",\n    \"SyntaxError\",\n    \"SystemExit\",\n    \"TypeError\",\n    \"ValueError\",\n    \"ZeroDivisionError\",\n    \"abs\",\n    \"all\",\n    \"any\",\n    \"append\",\n    \"args\",\n    \"bool\",\n    \"builtins\",\n    \"bytearray\",\n    \"bytecode\",\n    \"bytes\",\n    \"callable\",\n    \"chr\",\n    \"classmethod\",\n    \"clear\",\n    \"close\",\n    \"const\",\n    \"copy\",\n    \"count\",\n    \"dict\",\n    \"dir\",\n    \"divmod\",\n    \"end\",\n    \"endswith\",\n    \"eval\",\n    \"exec\",\n    \"extend\",\n    \"find\",\n    \"format\",\n    \"from_bytes\",\n    \"get\",\n    \"getattr\",\n    \"globals\",\n    \"hasattr\",\n    \"hash\",\n    \"id\",\n    \"index\",\n    \"insert\",\n    \"int\",\n    \"isalpha\",\n    \"isdigit\",\n    \"isinstance\",\n    \"islower\",\n    \"isspace\",\n    \"issubclass\",\n    \"isupper\",\n    \"items\",\n    \"iter\",\n    \"join\",\n    \"key\",\n    \"keys\",\n    \"len\",\n    \"list\",\n    \"little\",\n    \"locals\",\n    \"lower\",\n    \"lstrip\",\n    \"main\",\n    \"map\",\n    \"micropython\",\n    \"next\",\n    \"object\",\n    \"open\",\n    \"ord\",\n    \"pop\",\n    \"popitem\",\n    \"pow\",\n    \"print\",\n    \"range\",\n    \"read\",\n    \"readinto\",\n    \"readline\",\n    \"remove\",\n    \"replace\",\n    \"repr\",\n    \"reverse\",\n    \"rfind\",\n    \"rindex\",\n    \"round\",\n    \"rsplit\",\n    \"rstrip\",\n    \"self\",\n    \"send\",\n    \"sep\",\n    \"set\",\n    \"setattr\",\n    \"setdefault\",\n    \"sort\",\n    \"sorted\",\n    \"split\",\n    \"start\",\n    \"startswith\",\n    \"staticmethod\",\n    \"step\",\n    \"stop\",\n    \"str\",\n    \"strip\",\n    \"sum\",\n    \"super\",\n    \"throw\",\n    \"to_bytes\",\n    \"tuple\",\n    \"type\",\n    \"update\",\n    \"upper\",\n    \"utf-8\",\n    \"value\",\n    \"values\",\n    \"write\",\n    \"zip\",\n]\n\n# Additional QSTRs that must have index <255 because they are stored as `byte` values.\n# These are not part of the .mpy compatibility list, but we place them in the\n# fixed unsorted pool (i.e. QDEF0) to ensure their indices are small.\nunsorted_qstr_list = {\n    # From py/objtype.c: used in the `mp_binary_op_method_name` and `mp_unary_op_method_name` tables.\n    \"__bool__\",\n    \"__pos__\",\n    \"__neg__\",\n    \"__invert__\",\n    \"__abs__\",\n    \"__float__\",\n    \"__complex__\",\n    \"__sizeof__\",\n    \"__lt__\",\n    \"__gt__\",\n    \"__eq__\",\n    \"__le__\",\n    \"__ge__\",\n    \"__ne__\",\n    \"__contains__\",\n    \"__iadd__\",\n    \"__isub__\",\n    \"__imul__\",\n    \"__imatmul__\",\n    \"__ifloordiv__\",\n    \"__itruediv__\",\n    \"__imod__\",\n    \"__ipow__\",\n    \"__ior__\",\n    \"__ixor__\",\n    \"__iand__\",\n    \"__ilshift__\",\n    \"__irshift__\",\n    \"__add__\",\n    \"__sub__\",\n    \"__mul__\",\n    \"__matmul__\",\n    \"__floordiv__\",\n    \"__truediv__\",\n    \"__mod__\",\n    \"__divmod__\",\n    \"__pow__\",\n    \"__or__\",\n    \"__xor__\",\n    \"__and__\",\n    \"__lshift__\",\n    \"__rshift__\",\n    \"__radd__\",\n    \"__rsub__\",\n    \"__rmul__\",\n    \"__rmatmul__\",\n    \"__rfloordiv__\",\n    \"__rtruediv__\",\n    \"__rmod__\",\n    \"__rpow__\",\n    \"__ror__\",\n    \"__rxor__\",\n    \"__rand__\",\n    \"__rlshift__\",\n    \"__rrshift__\",\n    \"__get__\",\n    \"__set__\",\n    \"__delete__\",\n    # From py/scope.c: used in `scope_simple_name_table` table.\n    # Note: \"<module>\" is already in `static_qstr_list`.\n    \"<lambda>\",\n    \"<listcomp>\",\n    \"<dictcomp>\",\n    \"<setcomp>\",\n    \"<genexpr>\",\n}\n\n\n# this must match the equivalent function in qstr.c\ndef compute_hash(qstr, bytes_hash):\n    hash = 5381\n    for b in qstr:\n        hash = (hash * 33) ^ b\n    # Make sure that valid hash is never zero, zero means \"hash not computed\"\n    # if bytes_hash is zero, assume a 16-bit mask (to match qstr.c)\n    return (hash & ((1 << (8 * (bytes_hash or 2))) - 1)) or 1\n\n\ndef qstr_escape(qst):\n    def esc_char(m):\n        c = ord(m.group(0))\n        try:\n            name = codepoint2name[c]\n        except KeyError:\n            name = \"0x%02x\" % c\n        return \"_\" + name + \"_\"\n\n    return re.sub(r\"[^A-Za-z0-9_]\", esc_char, qst)\n\n\nstatic_qstr_list_ident = list(map(qstr_escape, static_qstr_list))\n\n\ndef parse_input_headers(infiles):\n    qcfgs = {}\n    qstrs = {}\n\n    # read the qstrs in from the input files\n    for infile in infiles:\n        with open(infile, \"rt\") as f:\n            for line in f:\n                line = line.strip()\n\n                # is this a config line?\n                match = re.match(r\"^QCFG\\((.+), (.+)\\)\", line)\n                if match:\n                    value = match.group(2)\n                    if value[0] == \"(\" and value[-1] == \")\":\n                        # strip parenthesis from config value\n                        value = value[1:-1]\n                    qcfgs[match.group(1)] = value\n                    continue\n\n                # is this a QSTR line?\n                match = re.match(r\"^Q\\((.*)\\)$\", line)\n                if not match:\n                    continue\n\n                # get the qstr value\n                qstr = match.group(1)\n\n                # special cases to specify control characters\n                if qstr == \"\\\\n\":\n                    qstr = \"\\n\"\n                elif qstr == \"\\\\r\\\\n\":\n                    qstr = \"\\r\\n\"\n\n                # work out the corresponding qstr name\n                ident = qstr_escape(qstr)\n\n                # don't add duplicates\n                if ident in static_qstr_list_ident:\n                    continue\n                if ident in qstrs:\n                    continue\n\n                qstrs[ident] = (ident, qstr)\n\n    if not qcfgs:\n        sys.stderr.write(\"ERROR: Empty preprocessor output - check for errors above\\n\")\n        sys.exit(1)\n\n    return qcfgs, qstrs\n\n\ndef escape_bytes(qstr, qbytes):\n    if all(32 <= ord(c) <= 126 and c != \"\\\\\" and c != '\"' for c in qstr):\n        # qstr is all printable ASCII so render it as-is (for easier debugging)\n        return qstr\n    else:\n        # qstr contains non-printable codes so render entire thing as hex pairs\n        return \"\".join((\"\\\\x%02x\" % b) for b in qbytes)\n\n\ndef make_bytes(cfg_bytes_len, cfg_bytes_hash, qstr):\n    qbytes = bytes_cons(qstr, \"utf8\")\n    qlen = len(qbytes)\n    qhash = compute_hash(qbytes, cfg_bytes_hash)\n    if qlen >= (1 << (8 * cfg_bytes_len)):\n        print(\"qstr is too long:\", qstr)\n        assert False\n    qdata = escape_bytes(qstr, qbytes)\n    return '%d, %d, \"%s\"' % (qhash, qlen, qdata)\n\n\ndef print_qstr_data(qcfgs, qstrs):\n    # get config variables\n    cfg_bytes_len = int(qcfgs[\"BYTES_IN_LEN\"])\n    cfg_bytes_hash = int(qcfgs[\"BYTES_IN_HASH\"])\n\n    # print out the starter of the generated C header file\n    print(\"// This file was automatically generated by makeqstrdata.py\")\n    print(\"\")\n\n    # add NULL qstr with no hash or data\n    print('QDEF0(MP_QSTRnull, 0, 0, \"\")')\n\n    # add static qstrs to the first unsorted pool\n    for qstr in static_qstr_list:\n        qbytes = make_bytes(cfg_bytes_len, cfg_bytes_hash, qstr)\n        print(\"QDEF0(MP_QSTR_%s, %s)\" % (qstr_escape(qstr), qbytes))\n\n    # add remaining qstrs to the sorted (by value) pool (unless they're in\n    # unsorted_qstr_list, in which case add them to the unsorted pool)\n    for ident, qstr in sorted(qstrs.values(), key=lambda x: x[1]):\n        qbytes = make_bytes(cfg_bytes_len, cfg_bytes_hash, qstr)\n        pool = 0 if qstr in unsorted_qstr_list else 1\n        print(\"QDEF%d(MP_QSTR_%s, %s)\" % (pool, ident, qbytes))\n\n\ndef do_work(infiles):\n    qcfgs, qstrs = parse_input_headers(infiles)\n    print_qstr_data(qcfgs, qstrs)\n\n\nif __name__ == \"__main__\":\n    do_work(sys.argv[1:])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}