{
  "module_name": "dynruntime.h",
  "hash_id": "a77addf2a84586b9734602eef8e9cd2ae97ce08077a3df11f21b56b0309978e8",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/dynruntime.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_DYNRUNTIME_H\n#define MICROPY_INCLUDED_PY_DYNRUNTIME_H\n\n\n\n\n#include \"py/binary.h\"\n#include \"py/nativeglue.h\"\n#include \"py/objfun.h\"\n#include \"py/objstr.h\"\n#include \"py/objtype.h\"\n\n#if !MICROPY_ENABLE_DYNRUNTIME\n#error \"dynruntime.h included in non-dynamic-module build.\"\n#endif\n\n#undef MP_ROM_QSTR\n#undef MP_OBJ_QSTR_VALUE\n#undef MP_OBJ_NEW_QSTR\n#undef mp_const_none\n#undef mp_const_false\n#undef mp_const_true\n#undef mp_const_empty_bytes\n#undef mp_const_empty_tuple\n#undef nlr_raise\n\n \n\n\n#define m_malloc(n)                     (m_malloc_dyn((n)))\n#define m_free(ptr)                     (m_free_dyn((ptr)))\n#define m_realloc(ptr, new_num_bytes)   (m_realloc_dyn((ptr), (new_num_bytes)))\n\nstatic inline void *m_malloc_dyn(size_t n) {\n    \n    return mp_fun_table.realloc_(NULL, n, false);\n}\n\nstatic inline void m_free_dyn(void *ptr) {\n    mp_fun_table.realloc_(ptr, 0, false);\n}\n\nstatic inline void *m_realloc_dyn(void *ptr, size_t new_num_bytes) {\n    \n    return mp_fun_table.realloc_(ptr, new_num_bytes, true);\n}\n\n \n\n\n#define mp_plat_print               (*mp_fun_table.plat_print)\n#define mp_printf(p, ...)           (mp_fun_table.printf_((p), __VA_ARGS__))\n#define mp_vprintf(p, fmt, args)    (mp_fun_table.vprintf_((p), (fmt), (args)))\n\n \n\n\n#define MP_OBJ_NEW_QSTR(x)                  (mp_fun_table.native_to_obj(x, MP_NATIVE_TYPE_QSTR))\n\n#define mp_type_type                        (*mp_fun_table.type_type)\n#define mp_type_NoneType                    (*mp_obj_get_type(mp_const_none))\n#define mp_type_bool                        (*mp_obj_get_type(mp_const_false))\n#define mp_type_int                         (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_int)))\n#define mp_type_str                         (*mp_fun_table.type_str)\n#define mp_type_bytes                       (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_bytes)))\n#define mp_type_bytearray                   (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_bytearray)))\n#define mp_type_tuple                       (*((mp_obj_base_t *)mp_const_empty_tuple)->type)\n#define mp_type_list                        (*mp_fun_table.type_list)\n#define mp_type_Exception                   (*mp_fun_table.type_Exception)\n#define mp_type_EOFError                    (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_EOFError)))\n#define mp_type_IndexError                  (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_IndexError)))\n#define mp_type_KeyError                    (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_KeyError)))\n#define mp_type_NotImplementedError         (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_NotImplementedError)))\n#define mp_type_RuntimeError                (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_RuntimeError)))\n#define mp_type_TypeError                   (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_TypeError)))\n#define mp_type_ValueError                  (*(mp_obj_type_t *)(mp_load_global(MP_QSTR_ValueError)))\n\n#define mp_stream_read_obj                  (*mp_fun_table.stream_read_obj)\n#define mp_stream_readinto_obj              (*mp_fun_table.stream_readinto_obj)\n#define mp_stream_unbuffered_readline_obj   (*mp_fun_table.stream_unbuffered_readline_obj)\n#define mp_stream_write_obj                 (*mp_fun_table.stream_write_obj)\n\n#define mp_const_none                       ((mp_obj_t)mp_fun_table.const_none)\n#define mp_const_false                      ((mp_obj_t)mp_fun_table.const_false)\n#define mp_const_true                       ((mp_obj_t)mp_fun_table.const_true)\n#define mp_const_empty_bytes                (MP_OBJ_TYPE_GET_SLOT(&mp_type_bytes, make_new)(NULL, 0, 0, NULL))\n#define mp_const_empty_tuple                (mp_fun_table.new_tuple(0, NULL))\n\n#define mp_obj_new_bool(b)                  ((b) ? (mp_obj_t)mp_fun_table.const_true : (mp_obj_t)mp_fun_table.const_false)\n#define mp_obj_new_int(i)                   (mp_fun_table.native_to_obj(i, MP_NATIVE_TYPE_INT))\n#define mp_obj_new_int_from_uint(i)         (mp_fun_table.native_to_obj(i, MP_NATIVE_TYPE_UINT))\n#define mp_obj_new_str(data, len)           (mp_fun_table.obj_new_str((data), (len)))\n#define mp_obj_new_str_of_type(t, d, l)     (mp_obj_new_str_of_type_dyn((t), (d), (l)))\n#define mp_obj_new_bytes(data, len)         (mp_fun_table.obj_new_bytes((data), (len)))\n#define mp_obj_new_bytearray_by_ref(n, i)   (mp_fun_table.obj_new_bytearray_by_ref((n), (i)))\n#define mp_obj_new_tuple(n, items)          (mp_fun_table.new_tuple((n), (items)))\n#define mp_obj_new_list(n, items)           (mp_fun_table.new_list((n), (items)))\n#define mp_obj_new_dict(n)                  (mp_fun_table.new_dict((n)))\n\n#define mp_obj_get_type(o)                  (mp_fun_table.obj_get_type((o)))\n#define mp_obj_cast_to_native_base(o, t)    (mp_obj_cast_to_native_base_dyn((o), (t)))\n#define mp_obj_get_int(o)                   (mp_fun_table.native_from_obj(o, MP_NATIVE_TYPE_INT))\n#define mp_obj_get_int_truncated(o)         (mp_fun_table.native_from_obj(o, MP_NATIVE_TYPE_UINT))\n#define mp_obj_str_get_str(s)               (mp_obj_str_get_data_dyn((s), NULL))\n#define mp_obj_str_get_data(o, len)         (mp_obj_str_get_data_dyn((o), (len)))\n#define mp_get_buffer(o, bufinfo, fl)       (mp_fun_table.get_buffer((o), (bufinfo), (fl)))\n#define mp_get_buffer_raise(o, bufinfo, fl) (mp_fun_table.get_buffer((o), (bufinfo), (fl) | MP_BUFFER_RAISE_IF_UNSUPPORTED))\n#define mp_get_stream_raise(s, flags)       (mp_fun_table.get_stream_raise((s), (flags)))\n#define mp_obj_is_true(o)                   (mp_fun_table.native_from_obj(o, MP_NATIVE_TYPE_BOOL))\n\n#define mp_obj_len(o)                       (mp_obj_len_dyn(o))\n#define mp_obj_subscr(base, index, val)     (mp_fun_table.obj_subscr((base), (index), (val)))\n#define mp_obj_get_array(o, len, items)     (mp_obj_get_array_dyn((o), (len), (items)))\n#define mp_obj_list_append(list, item)      (mp_fun_table.list_append((list), (item)))\n#define mp_obj_dict_store(dict, key, val)   (mp_fun_table.dict_store((dict), (key), (val)))\n\n#define mp_obj_malloc_helper(n, t)          (mp_obj_malloc_helper_dyn(n, t))\n\nstatic inline mp_obj_t mp_obj_new_str_of_type_dyn(const mp_obj_type_t *type, const byte *data, size_t len) {\n    if (type == &mp_type_str) {\n        return mp_obj_new_str((const char *)data, len);\n    } else {\n        return mp_obj_new_bytes(data, len);\n    }\n}\n\nstatic inline mp_obj_t mp_obj_cast_to_native_base_dyn(mp_obj_t self_in, mp_const_obj_t native_type) {\n    const mp_obj_type_t *self_type = mp_obj_get_type(self_in);\n\n    if (MP_OBJ_FROM_PTR(self_type) == native_type) {\n        return self_in;\n    } else if (MP_OBJ_TYPE_GET_SLOT_OR_NULL(self_type, parent) != native_type) {\n        \n        \n        return MP_OBJ_NULL;\n    } else {\n        mp_obj_instance_t *self = (mp_obj_instance_t *)MP_OBJ_TO_PTR(self_in);\n        return self->subobj[0];\n    }\n}\n\nstatic inline void *mp_obj_str_get_data_dyn(mp_obj_t o, size_t *l) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(o, &bufinfo, MP_BUFFER_READ);\n    if (l != NULL) {\n        *l = bufinfo.len;\n    }\n    return bufinfo.buf;\n}\n\nstatic inline mp_obj_t mp_obj_len_dyn(mp_obj_t o) {\n    \n    return mp_fun_table.call_function_n_kw(mp_fun_table.load_name(MP_QSTR_len), 1, &o);\n}\n\nstatic inline void *mp_obj_malloc_helper_dyn(size_t num_bytes, const mp_obj_type_t *type) {\n    mp_obj_base_t *base = (mp_obj_base_t *)m_malloc(num_bytes);\n    base->type = type;\n    return base;\n}\n\n \n\n\n#define mp_binary_get_size(struct_type, val_type, palign) (mp_fun_table.binary_get_size((struct_type), (val_type), (palign)))\n#define mp_binary_get_val_array(typecode, p, index) (mp_fun_table.binary_get_val_array((typecode), (p), (index)))\n#define mp_binary_set_val_array(typecode, p, index, val_in) (mp_fun_table.binary_set_val_array((typecode), (p), (index), (val_in)))\n\n#define mp_load_name(qst)                 (mp_fun_table.load_name((qst)))\n#define mp_load_global(qst)               (mp_fun_table.load_global((qst)))\n#define mp_load_attr(base, attr)          (mp_fun_table.load_attr((base), (attr)))\n#define mp_load_method(base, attr, dest)  (mp_fun_table.load_method((base), (attr), (dest)))\n#define mp_load_method_maybe(base, attr, dest) (mp_fun_table.load_method_maybe((base), (attr), (dest)))\n#define mp_load_super_method(attr, dest)  (mp_fun_table.load_super_method((attr), (dest)))\n#define mp_store_name(qst, obj)           (mp_fun_table.store_name((qst), (obj)))\n#define mp_store_global(qst, obj)         (mp_fun_table.store_global((qst), (obj)))\n#define mp_store_attr(base, attr, val)    (mp_fun_table.store_attr((base), (attr), (val)))\n\n#define mp_unary_op(op, obj)        (mp_fun_table.unary_op((op), (obj)))\n#define mp_binary_op(op, lhs, rhs)  (mp_fun_table.binary_op((op), (lhs), (rhs)))\n\n#define mp_make_function_from_proto_fun(rc, context, def_args) \\\n    (mp_fun_table.make_function_from_proto_fun((rc), (context), (def_args)))\n\n#define mp_call_function_n_kw(fun, n_args, n_kw, args) \\\n    (mp_fun_table.call_function_n_kw((fun), (n_args) | ((n_kw) << 8), args))\n\n#define mp_arg_check_num(n_args, n_kw, n_args_min, n_args_max, takes_kw) \\\n    (mp_fun_table.arg_check_num_sig((n_args), (n_kw), MP_OBJ_FUN_MAKE_SIG((n_args_min), (n_args_max), (takes_kw))))\n\n#define mp_arg_parse_all(n_pos, pos, kws, n_allowed, allowed, out_vals) \\\n    (mp_fun_table.arg_parse_all((n_pos), (pos), (kws), (n_allowed), (allowed), (out_vals)))\n\n#define mp_arg_parse_all_kw_array(n_pos, n_kw, args, n_allowed, allowed, out_vals) \\\n    (mp_fun_table.arg_parse_all_kw_array((n_pos), (n_kw), (args), (n_allowed), (allowed), (out_vals)))\n\n#define MP_DYNRUNTIME_INIT_ENTRY \\\n    mp_obj_t old_globals = mp_fun_table.swap_globals(self->context->module.globals); \\\n    mp_raw_code_truncated_t rc; \\\n    rc.proto_fun_indicator[0] = MP_PROTO_FUN_INDICATOR_RAW_CODE_0; \\\n    rc.proto_fun_indicator[1] = MP_PROTO_FUN_INDICATOR_RAW_CODE_1; \\\n    rc.kind = MP_CODE_NATIVE_VIPER; \\\n    rc.is_generator = 0; \\\n    (void)rc;\n\n#define MP_DYNRUNTIME_INIT_EXIT \\\n    mp_fun_table.swap_globals(old_globals); \\\n    return mp_const_none;\n\n#define MP_DYNRUNTIME_MAKE_FUNCTION(f) \\\n    (mp_make_function_from_proto_fun((rc.fun_data = (f), (const mp_raw_code_t *)&rc), self->context, NULL))\n\n#define mp_import_name(name, fromlist, level) \\\n    (mp_fun_table.import_name((name), (fromlist), (level)))\n#define mp_import_from(module, name) \\\n    (mp_fun_table.import_from((module), (name)))\n#define mp_import_all(module) \\\n    (mp_fun_table.import_all((module))\n\n \n\n\n#define mp_obj_exception_make_new               (MP_OBJ_TYPE_GET_SLOT(&mp_type_Exception, make_new))\n#define mp_obj_exception_print                  (MP_OBJ_TYPE_GET_SLOT(&mp_type_Exception, print))\n#define mp_obj_exception_attr                   (MP_OBJ_TYPE_GET_SLOT(&mp_type_Exception, attr))\n\n#define mp_obj_new_exception(o)                 ((mp_obj_t)(o)) \n#define mp_obj_new_exception_arg1(e_type, arg)  (mp_obj_new_exception_arg1_dyn((e_type), (arg)))\n\n#define nlr_raise(o)                            (mp_raise_dyn(o))\n#define mp_raise_type_arg(type, arg)            (mp_raise_dyn(mp_obj_new_exception_arg1_dyn((type), (arg))))\n#define mp_raise_msg(type, msg)                 (mp_fun_table.raise_msg((type), (msg)))\n#define mp_raise_OSError(er)                    (mp_raise_OSError_dyn(er))\n#define mp_raise_NotImplementedError(msg)       (mp_raise_msg(&mp_type_NotImplementedError, (msg)))\n#define mp_raise_TypeError(msg)                 (mp_raise_msg(&mp_type_TypeError, (msg)))\n#define mp_raise_ValueError(msg)                (mp_raise_msg(&mp_type_ValueError, (msg)))\n\nstatic inline mp_obj_t mp_obj_new_exception_arg1_dyn(const mp_obj_type_t *exc_type, mp_obj_t arg) {\n    mp_obj_t args[1] = { arg };\n    return mp_call_function_n_kw(MP_OBJ_FROM_PTR(exc_type), 1, 0, &args[0]);\n}\n\nstatic NORETURN inline void mp_raise_dyn(mp_obj_t o) {\n    mp_fun_table.raise(o);\n    for (;;) {\n    }\n}\n\nstatic inline void mp_raise_OSError_dyn(int er) {\n    mp_obj_t args[1] = { MP_OBJ_NEW_SMALL_INT(er) };\n    nlr_raise(mp_call_function_n_kw(mp_load_global(MP_QSTR_OSError), 1, 0, &args[0]));\n}\n\nstatic inline void mp_obj_exception_init(mp_obj_full_type_t *exc, qstr name, const mp_obj_type_t *base) {\n    exc->base.type = &mp_type_type;\n    exc->flags = MP_TYPE_FLAG_NONE;\n    exc->name = name;\n    MP_OBJ_TYPE_SET_SLOT(exc, make_new, mp_obj_exception_make_new, 0);\n    MP_OBJ_TYPE_SET_SLOT(exc, print, mp_obj_exception_print, 1);\n    MP_OBJ_TYPE_SET_SLOT(exc, attr, mp_obj_exception_attr, 2);\n    MP_OBJ_TYPE_SET_SLOT(exc, parent, base, 3);\n}\n\n \n\n\n#define mp_obj_new_float_from_f(f)  (mp_fun_table.obj_new_float_from_f((f)))\n#define mp_obj_new_float_from_d(d)  (mp_fun_table.obj_new_float_from_d((d)))\n#define mp_obj_get_float_to_f(o)    (mp_fun_table.obj_get_float_to_f((o)))\n#define mp_obj_get_float_to_d(o)    (mp_fun_table.obj_get_float_to_d((o)))\n\n#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n#define mp_obj_new_float(f)         (mp_obj_new_float_from_f((f)))\n#define mp_obj_get_float(o)         (mp_obj_get_float_to_f((o)))\n#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n#define mp_obj_new_float(f)         (mp_obj_new_float_from_d((f)))\n#define mp_obj_get_float(o)         (mp_obj_get_float_to_d((o)))\n#endif\n\n \n\n\n\nstatic inline void mp_obj_get_array_dyn(mp_obj_t o, size_t *len, mp_obj_t **items) {\n    const mp_obj_type_t *type = mp_obj_get_type(o);\n    if (type == &mp_type_tuple) {\n        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(o);\n        *len = t->len;\n        *items = &t->items[0];\n    } else if (type == &mp_type_list) {\n        mp_obj_list_t *l = MP_OBJ_TO_PTR(o);\n        *len = l->len;\n        *items = l->items;\n    } else {\n        mp_raise_TypeError(\"expected tuple/list\");\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}