{
  "module_name": "objlist.c",
  "hash_id": "0222526064ef23721060849bfac5183d904a8cf2b666d20eefc06b99fdbcdca6",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objlist.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n#include \"py/stackctrl.h\"\n\nstatic mp_obj_t mp_obj_new_list_iterator(mp_obj_t list, size_t cur, mp_obj_iter_buf_t *iter_buf);\nstatic mp_obj_list_t *list_new(size_t n);\nstatic mp_obj_t list_extend(mp_obj_t self_in, mp_obj_t arg_in);\nstatic mp_obj_t list_pop(size_t n_args, const mp_obj_t *args);\n\n\n#define LIST_MIN_ALLOC 4\n\n \n \n\nstatic void list_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    mp_obj_list_t *o = MP_OBJ_TO_PTR(o_in);\n    const char *item_separator = \", \";\n    if (!(MICROPY_PY_JSON && kind == PRINT_JSON)) {\n        kind = PRINT_REPR;\n    } else {\n        #if MICROPY_PY_JSON_SEPARATORS\n        item_separator = MP_PRINT_GET_EXT(print)->item_separator;\n        #endif\n    }\n    mp_print_str(print, \"[\");\n    for (size_t i = 0; i < o->len; i++) {\n        if (i > 0) {\n            mp_print_str(print, item_separator);\n        }\n        mp_obj_print_helper(print, o->items[i], kind);\n    }\n    mp_print_str(print, \"]\");\n}\n\nstatic mp_obj_t list_extend_from_iter(mp_obj_t list, mp_obj_t iterable) {\n    mp_obj_t iter = mp_getiter(iterable, NULL);\n    mp_obj_t item;\n    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        mp_obj_list_append(list, item);\n    }\n    return list;\n}\n\nmp_obj_t mp_obj_list_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n\n    switch (n_args) {\n        case 0:\n            \n            return mp_obj_new_list(0, NULL);\n\n        case 1:\n        default: {\n            \n            \n            mp_obj_t list = mp_obj_new_list(0, NULL);\n            return list_extend_from_iter(list, args[0]);\n        }\n    }\n}\n\nstatic mp_obj_t list_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(self->len != 0);\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(self->len);\n        #if MICROPY_PY_SYS_GETSIZEOF\n        case MP_UNARY_OP_SIZEOF: {\n            size_t sz = sizeof(*self) + sizeof(mp_obj_t) * self->alloc;\n            return MP_OBJ_NEW_SMALL_INT(sz);\n        }\n        #endif\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_obj_t list_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs) {\n    mp_obj_list_t *o = MP_OBJ_TO_PTR(lhs);\n    switch (op) {\n        case MP_BINARY_OP_ADD: {\n            if (!mp_obj_is_type(rhs, &mp_type_list)) {\n                return MP_OBJ_NULL; \n            }\n            mp_obj_list_t *p = MP_OBJ_TO_PTR(rhs);\n            mp_obj_list_t *s = list_new(o->len + p->len);\n            mp_seq_cat(s->items, o->items, o->len, p->items, p->len, mp_obj_t);\n            return MP_OBJ_FROM_PTR(s);\n        }\n        case MP_BINARY_OP_INPLACE_ADD: {\n            list_extend(lhs, rhs);\n            return lhs;\n        }\n        case MP_BINARY_OP_MULTIPLY: {\n            mp_int_t n;\n            if (!mp_obj_get_int_maybe(rhs, &n)) {\n                return MP_OBJ_NULL; \n            }\n            if (n < 0) {\n                n = 0;\n            }\n            mp_obj_list_t *s = list_new(o->len * n);\n            mp_seq_multiply(o->items, sizeof(*o->items), o->len, n, s->items);\n            return MP_OBJ_FROM_PTR(s);\n        }\n        case MP_BINARY_OP_EQUAL:\n        case MP_BINARY_OP_LESS:\n        case MP_BINARY_OP_LESS_EQUAL:\n        case MP_BINARY_OP_MORE:\n        case MP_BINARY_OP_MORE_EQUAL: {\n            if (!mp_obj_is_type(rhs, &mp_type_list)) {\n                if (op == MP_BINARY_OP_EQUAL) {\n                    return mp_const_false;\n                }\n                return MP_OBJ_NULL; \n            }\n\n            mp_obj_list_t *another = MP_OBJ_TO_PTR(rhs);\n            bool res = mp_seq_cmp_objs(op, o->items, o->len, another->items, another->len);\n            return mp_obj_new_bool(res);\n        }\n\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\nstatic mp_obj_t list_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    if (value == MP_OBJ_NULL) {\n        \n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n            mp_bound_slice_t slice;\n            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice)) {\n                mp_raise_NotImplementedError(NULL);\n            }\n\n            mp_int_t len_adj = slice.start - slice.stop;\n            assert(len_adj <= 0);\n            mp_seq_replace_slice_no_grow(self->items, self->len, slice.start, slice.stop, self->items  , 0, sizeof(*self->items));\n            \n            mp_seq_clear(self->items, self->len + len_adj, self->len, sizeof(*self->items));\n            self->len += len_adj;\n            return mp_const_none;\n        }\n        #endif\n        mp_obj_t args[2] = {self_in, index};\n        list_pop(2, args);\n        return mp_const_none;\n    } else if (value == MP_OBJ_SENTINEL) {\n        \n        mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_bound_slice_t slice;\n            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice)) {\n                return mp_seq_extract_slice(self->len, self->items, &slice);\n            }\n            mp_obj_list_t *res = list_new(slice.stop - slice.start);\n            mp_seq_copy(res->items, self->items + slice.start, res->len, mp_obj_t);\n            return MP_OBJ_FROM_PTR(res);\n        }\n        #endif\n        size_t index_val = mp_get_index(self->base.type, self->len, index, false);\n        return self->items[index_val];\n    } else {\n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n            size_t value_len;\n            mp_obj_t *value_items;\n            mp_obj_get_array(value, &value_len, &value_items);\n            mp_bound_slice_t slice_out;\n            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice_out)) {\n                mp_raise_NotImplementedError(NULL);\n            }\n            mp_int_t len_adj = value_len - (slice_out.stop - slice_out.start);\n            if (len_adj > 0) {\n                if (self->len + len_adj > self->alloc) {\n                    \n                    \n                    self->items = m_renew(mp_obj_t, self->items, self->alloc, self->len + len_adj);\n                    self->alloc = self->len + len_adj;\n                }\n                mp_seq_replace_slice_grow_inplace(self->items, self->len,\n                    slice_out.start, slice_out.stop, value_items, value_len, len_adj, sizeof(*self->items));\n            } else {\n                mp_seq_replace_slice_no_grow(self->items, self->len,\n                    slice_out.start, slice_out.stop, value_items, value_len, sizeof(*self->items));\n                \n                mp_seq_clear(self->items, self->len + len_adj, self->len, sizeof(*self->items));\n                \n            }\n            self->len += len_adj;\n            return mp_const_none;\n        }\n        #endif\n        mp_obj_list_store(self_in, index, value);\n        return mp_const_none;\n    }\n}\n\nstatic mp_obj_t list_getiter(mp_obj_t o_in, mp_obj_iter_buf_t *iter_buf) {\n    return mp_obj_new_list_iterator(o_in, 0, iter_buf);\n}\n\nmp_obj_t mp_obj_list_append(mp_obj_t self_in, mp_obj_t arg) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->len >= self->alloc) {\n        self->items = m_renew(mp_obj_t, self->items, self->alloc, self->alloc * 2);\n        self->alloc *= 2;\n        mp_seq_clear(self->items, self->len + 1, self->alloc, sizeof(*self->items));\n    }\n    self->items[self->len++] = arg;\n    return mp_const_none; \n}\n\nstatic mp_obj_t list_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    if (mp_obj_is_type(arg_in, &mp_type_list)) {\n        mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n        mp_obj_list_t *arg = MP_OBJ_TO_PTR(arg_in);\n\n        if (self->len + arg->len > self->alloc) {\n            \n            self->items = m_renew(mp_obj_t, self->items, self->alloc, self->len + arg->len + 4);\n            self->alloc = self->len + arg->len + 4;\n            mp_seq_clear(self->items, self->len + arg->len, self->alloc, sizeof(*self->items));\n        }\n\n        memcpy(self->items + self->len, arg->items, sizeof(mp_obj_t) * arg->len);\n        self->len += arg->len;\n    } else {\n        list_extend_from_iter(self_in, arg_in);\n    }\n    return mp_const_none; \n}\n\nstatic mp_obj_t list_pop(size_t n_args, const mp_obj_t *args) {\n    mp_check_self(mp_obj_is_type(args[0], &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(args[0]);\n    if (self->len == 0) {\n        mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"pop from empty list\"));\n    }\n    size_t index = mp_get_index(self->base.type, self->len, n_args == 1 ? MP_OBJ_NEW_SMALL_INT(-1) : args[1], false);\n    mp_obj_t ret = self->items[index];\n    self->len -= 1;\n    memmove(self->items + index, self->items + index + 1, (self->len - index) * sizeof(mp_obj_t));\n    \n    self->items[self->len] = MP_OBJ_NULL;\n    if (self->alloc > LIST_MIN_ALLOC && self->alloc > 2 * self->len) {\n        self->items = m_renew(mp_obj_t, self->items, self->alloc, self->alloc / 2);\n        self->alloc /= 2;\n    }\n    return ret;\n}\n\nstatic void mp_quicksort(mp_obj_t *head, mp_obj_t *tail, mp_obj_t key_fn, mp_obj_t binop_less_result) {\n    MP_STACK_CHECK();\n    while (head < tail) {\n        mp_obj_t *h = head - 1;\n        mp_obj_t *t = tail;\n        mp_obj_t v = key_fn == MP_OBJ_NULL ? tail[0] : mp_call_function_1(key_fn, tail[0]); \n        for (;;) {\n            do {++h;\n            } while (h < t && mp_binary_op(MP_BINARY_OP_LESS, key_fn == MP_OBJ_NULL ? h[0] : mp_call_function_1(key_fn, h[0]), v) == binop_less_result);\n            do {--t;\n            } while (h < t && mp_binary_op(MP_BINARY_OP_LESS, v, key_fn == MP_OBJ_NULL ? t[0] : mp_call_function_1(key_fn, t[0])) == binop_less_result);\n            if (h >= t) {\n                break;\n            }\n            mp_obj_t x = h[0];\n            h[0] = t[0];\n            t[0] = x;\n        }\n        mp_obj_t x = h[0];\n        h[0] = tail[0];\n        tail[0] = x;\n        \n        if (t - head < tail - h - 1) {\n            mp_quicksort(head, t, key_fn, binop_less_result);\n            head = h + 1;\n        } else {\n            mp_quicksort(h + 1, tail, key_fn, binop_less_result);\n            tail = t;\n        }\n    }\n}\n\n\nmp_obj_t mp_obj_list_sort(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_key, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_NONE} },\n        { MP_QSTR_reverse, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },\n    };\n\n    \n    struct {\n        mp_arg_val_t key, reverse;\n    } args;\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args,\n        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&args);\n\n    mp_check_self(mp_obj_is_type(pos_args[0], &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(pos_args[0]);\n\n    if (self->len > 1) {\n        mp_quicksort(self->items, self->items + self->len - 1,\n            args.key.u_obj == mp_const_none ? MP_OBJ_NULL : args.key.u_obj,\n            args.reverse.u_bool ? mp_const_false : mp_const_true);\n    }\n\n    return mp_const_none;\n}\n\nstatic mp_obj_t list_clear(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    self->len = 0;\n    self->items = m_renew(mp_obj_t, self->items, self->alloc, LIST_MIN_ALLOC);\n    self->alloc = LIST_MIN_ALLOC;\n    mp_seq_clear(self->items, 0, self->alloc, sizeof(*self->items));\n    return mp_const_none;\n}\n\nstatic mp_obj_t list_copy(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_list(self->len, self->items);\n}\n\nstatic mp_obj_t list_count(mp_obj_t self_in, mp_obj_t value) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_seq_count_obj(self->items, self->len, value);\n}\n\nstatic mp_obj_t list_index(size_t n_args, const mp_obj_t *args) {\n    mp_check_self(mp_obj_is_type(args[0], &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(args[0]);\n    return mp_seq_index_obj(self->items, self->len, n_args, args);\n}\n\nstatic mp_obj_t list_insert(mp_obj_t self_in, mp_obj_t idx, mp_obj_t obj) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    \n    mp_int_t index = MP_OBJ_SMALL_INT_VALUE(idx);\n    if (index < 0) {\n        index += self->len;\n    }\n    if (index < 0) {\n        index = 0;\n    }\n    if ((size_t)index > self->len) {\n        index = self->len;\n    }\n\n    mp_obj_list_append(self_in, mp_const_none);\n\n    for (mp_int_t i = self->len - 1; i > index; i--) {\n        self->items[i] = self->items[i - 1];\n    }\n    self->items[index] = obj;\n\n    return mp_const_none;\n}\n\nmp_obj_t mp_obj_list_remove(mp_obj_t self_in, mp_obj_t value) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_t args[] = {self_in, value};\n    args[1] = list_index(2, args);\n    list_pop(2, args);\n\n    return mp_const_none;\n}\n\nstatic mp_obj_t list_reverse(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_list));\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n\n    mp_int_t len = self->len;\n    for (mp_int_t i = 0; i < len / 2; i++) {\n        mp_obj_t a = self->items[i];\n        self->items[i] = self->items[len - i - 1];\n        self->items[len - i - 1] = a;\n    }\n\n    return mp_const_none;\n}\n\nstatic MP_DEFINE_CONST_FUN_OBJ_2(list_append_obj, mp_obj_list_append);\nstatic MP_DEFINE_CONST_FUN_OBJ_2(list_extend_obj, list_extend);\nstatic MP_DEFINE_CONST_FUN_OBJ_1(list_clear_obj, list_clear);\nstatic MP_DEFINE_CONST_FUN_OBJ_1(list_copy_obj, list_copy);\nstatic MP_DEFINE_CONST_FUN_OBJ_2(list_count_obj, list_count);\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(list_index_obj, 2, 4, list_index);\nstatic MP_DEFINE_CONST_FUN_OBJ_3(list_insert_obj, list_insert);\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(list_pop_obj, 1, 2, list_pop);\nstatic MP_DEFINE_CONST_FUN_OBJ_2(list_remove_obj, mp_obj_list_remove);\nstatic MP_DEFINE_CONST_FUN_OBJ_1(list_reverse_obj, list_reverse);\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(list_sort_obj, 1, mp_obj_list_sort);\n\nstatic const mp_rom_map_elem_t list_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_append), MP_ROM_PTR(&list_append_obj) },\n    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&list_clear_obj) },\n    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&list_copy_obj) },\n    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&list_count_obj) },\n    { MP_ROM_QSTR(MP_QSTR_extend), MP_ROM_PTR(&list_extend_obj) },\n    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&list_index_obj) },\n    { MP_ROM_QSTR(MP_QSTR_insert), MP_ROM_PTR(&list_insert_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&list_pop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&list_remove_obj) },\n    { MP_ROM_QSTR(MP_QSTR_reverse), MP_ROM_PTR(&list_reverse_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sort), MP_ROM_PTR(&list_sort_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(list_locals_dict, list_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_list,\n    MP_QSTR_list,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, mp_obj_list_make_new,\n    print, list_print,\n    unary_op, list_unary_op,\n    binary_op, list_binary_op,\n    subscr, list_subscr,\n    iter, list_getiter,\n    locals_dict, &list_locals_dict\n    );\n\n\nvoid mp_obj_list_init(mp_obj_list_t *o, size_t n) {\n    o->base.type = &mp_type_list;\n    o->alloc = n < LIST_MIN_ALLOC ? LIST_MIN_ALLOC : n;\n    o->len = n;\n    o->items = m_new(mp_obj_t, o->alloc);\n    mp_seq_clear(o->items, n, o->alloc, sizeof(*o->items));\n}\n\nstatic mp_obj_list_t *list_new(size_t n) {\n    mp_obj_list_t *o = m_new_obj(mp_obj_list_t);\n    mp_obj_list_init(o, n);\n    return o;\n}\n\nmp_obj_t mp_obj_new_list(size_t n, mp_obj_t *items) {\n    mp_obj_list_t *o = list_new(n);\n    if (items != NULL) {\n        for (size_t i = 0; i < n; i++) {\n            o->items[i] = items[i];\n        }\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\nvoid mp_obj_list_get(mp_obj_t self_in, size_t *len, mp_obj_t **items) {\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    *len = self->len;\n    *items = self->items;\n}\n\nvoid mp_obj_list_set_len(mp_obj_t self_in, size_t len) {\n    \n    \n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    self->len = len;\n}\n\nvoid mp_obj_list_store(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);\n    size_t i = mp_get_index(self->base.type, self->len, index, false);\n    self->items[i] = value;\n}\n\n \n \n\ntypedef struct _mp_obj_list_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_obj_t list;\n    size_t cur;\n} mp_obj_list_it_t;\n\nstatic mp_obj_t list_it_iternext(mp_obj_t self_in) {\n    mp_obj_list_it_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_list_t *list = MP_OBJ_TO_PTR(self->list);\n    if (self->cur < list->len) {\n        mp_obj_t o_out = list->items[self->cur];\n        self->cur += 1;\n        return o_out;\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nmp_obj_t mp_obj_new_list_iterator(mp_obj_t list, size_t cur, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_list_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_list_it_t *o = (mp_obj_list_it_t *)iter_buf;\n    o->base.type = &mp_type_polymorph_iter;\n    o->iternext = list_it_iternext;\n    o->list = list;\n    o->cur = cur;\n    return MP_OBJ_FROM_PTR(o);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}