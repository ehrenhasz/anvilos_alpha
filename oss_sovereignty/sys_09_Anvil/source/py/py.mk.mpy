{
  "module_name": "py.mk",
  "hash_id": "fa06b9636d4044e8015191419bfcbfd6db61943e0489dfb25e0e759bb31d058b",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/py.mk",
  "human_readable_source": "# where py object files go (they have a name prefix to prevent filename clashes)\nPY_BUILD = $(BUILD)/py\n\n# where autogenerated header files go\nHEADER_BUILD = $(BUILD)/genhdr\n\n# file containing qstr defs for the core Python bit\nPY_QSTR_DEFS = $(PY_SRC)/qstrdefs.h\n\n# If qstr autogeneration is not disabled we specify the output header\n# for all collected qstrings.\nifneq ($(QSTR_AUTOGEN_DISABLE),1)\nQSTR_DEFS_COLLECTED = $(HEADER_BUILD)/qstrdefs.collected.h\nendif\n\n# Any files listed by these variables will cause a full regeneration of qstrs\n# DEPENDENCIES: included in qstr processing; REQUIREMENTS: not included\nQSTR_GLOBAL_DEPENDENCIES += $(PY_SRC)/mpconfig.h mpconfigport.h\nQSTR_GLOBAL_REQUIREMENTS += $(HEADER_BUILD)/mpversion.h\n\n# some code is performance bottleneck and compiled with other optimization options\nCSUPEROPT = -O3\n\n# Enable building 32-bit code on 64-bit host.\nifeq ($(MICROPY_FORCE_32BIT),1)\nCC += -m32\nCXX += -m32\nLD += -m32\nendif\n\n# External modules written in C.\nifneq ($(USER_C_MODULES),)\n# pre-define USERMOD variables as expanded so that variables are immediate\n# expanded as they're added to them\n\n# C/C++ files that are included in the QSTR/module build\nSRC_USERMOD_C :=\nSRC_USERMOD_CXX :=\n# Other C/C++ files (e.g. libraries or helpers)\nSRC_USERMOD_LIB_C :=\nSRC_USERMOD_LIB_CXX :=\n# Optionally set flags\nCFLAGS_USERMOD :=\nCXXFLAGS_USERMOD :=\nLDFLAGS_USERMOD :=\n\n# Backwards compatibility with older user c modules that set SRC_USERMOD\n# added to SRC_USERMOD_C below\nSRC_USERMOD :=\n\n$(foreach module, $(wildcard $(USER_C_MODULES)/*/micropython.mk), \\\n    $(eval USERMOD_DIR = $(patsubst %/,%,$(dir $(module))))\\\n    $(info Including User C Module from $(USERMOD_DIR))\\\n\t$(eval include $(module))\\\n)\n\nSRC_USERMOD_C += $(SRC_USERMOD)\n\nSRC_USERMOD_PATHFIX_C += $(patsubst $(USER_C_MODULES)/%.c,%.c,$(SRC_USERMOD_C))\nSRC_USERMOD_PATHFIX_CXX += $(patsubst $(USER_C_MODULES)/%.cpp,%.cpp,$(SRC_USERMOD_CXX))\nSRC_USERMOD_PATHFIX_LIB_C += $(patsubst $(USER_C_MODULES)/%.c,%.c,$(SRC_USERMOD_LIB_C))\nSRC_USERMOD_PATHFIX_LIB_CXX += $(patsubst $(USER_C_MODULES)/%.cpp,%.cpp,$(SRC_USERMOD_LIB_CXX))\n\nCFLAGS += $(CFLAGS_USERMOD)\nCXXFLAGS += $(CXXFLAGS_USERMOD)\nLDFLAGS += $(LDFLAGS_USERMOD)\n\nSRC_QSTR += $(SRC_USERMOD_PATHFIX_C) $(SRC_USERMOD_PATHFIX_CXX)\nPY_O += $(addprefix $(BUILD)/, $(SRC_USERMOD_PATHFIX_C:.c=.o))\nPY_O += $(addprefix $(BUILD)/, $(SRC_USERMOD_PATHFIX_CXX:.cpp=.o))\nPY_O += $(addprefix $(BUILD)/, $(SRC_USERMOD_PATHFIX_LIB_C:.c=.o))\nPY_O += $(addprefix $(BUILD)/, $(SRC_USERMOD_PATHFIX_LIB_CXX:.cpp=.o))\nendif\n\n# py object files\nPY_CORE_O_BASENAME = $(addprefix py/,\\\n\tmpstate.o \\\n\tnlr.o \\\n\tnlrx86.o \\\n\tnlrx64.o \\\n\tnlrthumb.o \\\n\tnlraarch64.o \\\n\tnlrmips.o \\\n\tnlrpowerpc.o \\\n\tnlrxtensa.o \\\n\tnlrsetjmp.o \\\n\tmalloc.o \\\n\tgc.o \\\n\tpystack.o \\\n\tqstr.o \\\n\tvstr.o \\\n\tmpprint.o \\\n\tunicode.o \\\n\tmpz.o \\\n\treader.o \\\n\tlexer.o \\\n\tparse.o \\\n\tscope.o \\\n\tcompile.o \\\n\temitcommon.o \\\n\temitbc.o \\\n\tasmbase.o \\\n\tasmx64.o \\\n\temitnx64.o \\\n\tasmx86.o \\\n\temitnx86.o \\\n\tasmthumb.o \\\n\temitnthumb.o \\\n\temitinlinethumb.o \\\n\tasmarm.o \\\n\temitnarm.o \\\n\tasmxtensa.o \\\n\temitnxtensa.o \\\n\temitinlinextensa.o \\\n\temitnxtensawin.o \\\n\tformatfloat.o \\\n\tparsenumbase.o \\\n\tparsenum.o \\\n\temitglue.o \\\n\tpersistentcode.o \\\n\truntime.o \\\n\truntime_utils.o \\\n\tscheduler.o \\\n\tnativeglue.o \\\n\tpairheap.o \\\n\tringbuf.o \\\n\tstackctrl.o \\\n\targcheck.o \\\n\twarning.o \\\n\tprofile.o \\\n\tmap.o \\\n\tobj.o \\\n\tobjarray.o \\\n\tobjattrtuple.o \\\n\tobjbool.o \\\n\tobjboundmeth.o \\\n\tobjcell.o \\\n\tobjclosure.o \\\n\tobjcomplex.o \\\n\tobjdeque.o \\\n\tobjdict.o \\\n\tobjenumerate.o \\\n\tobjexcept.o \\\n\tobjfilter.o \\\n\tobjfloat.o \\\n\tobjfun.o \\\n\tobjgenerator.o \\\n\tobjgetitemiter.o \\\n\tobjint.o \\\n\tobjint_longlong.o \\\n\tobjint_mpz.o \\\n\tobjlist.o \\\n\tobjmap.o \\\n\tobjmodule.o \\\n\tobjobject.o \\\n\tobjpolyiter.o \\\n\tobjproperty.o \\\n\tobjnone.o \\\n\tobjnamedtuple.o \\\n\tobjrange.o \\\n\tobjreversed.o \\\n\tobjset.o \\\n\tobjsingleton.o \\\n\tobjslice.o \\\n\tobjstr.o \\\n\tobjstrunicode.o \\\n\tobjstringio.o \\\n\tobjtuple.o \\\n\tobjtype.o \\\n\tobjzip.o \\\n\topmethods.o \\\n\tsequence.o \\\n\tstream.o \\\n\tbinary.o \\\n\tbuiltinimport.o \\\n\tbuiltinevex.o \\\n\tbuiltinhelp.o \\\n\tmodarray.o \\\n\tmodbuiltins.o \\\n\tmodcollections.o \\\n\tmodgc.o \\\n\tmodio.o \\\n\tmodmath.o \\\n\tmodcmath.o \\\n\tmodmicropython.o \\\n\tmodstruct.o \\\n\tmodsys.o \\\n\tmoderrno.o \\\n\tmodthread.o \\\n\tvm.o \\\n\tbc.o \\\n\tshowbc.o \\\n\trepl.o \\\n\tsmallint.o \\\n\tfrozenmod.o \\\n\t)\n\n# prepend the build destination prefix to the py object files\nPY_CORE_O = $(addprefix $(BUILD)/, $(PY_CORE_O_BASENAME))\n\n# this is a convenience variable for ports that want core, extmod and frozen code\nPY_O += $(PY_CORE_O)\n\n# object file for frozen code specified via a manifest\nifneq ($(FROZEN_MANIFEST),)\nPY_O += $(BUILD)/frozen_content.o\nendif\n\n# Sources that may contain qstrings\nSRC_QSTR_IGNORE = py/nlr%\nSRC_QSTR += $(filter-out $(SRC_QSTR_IGNORE),$(PY_CORE_O_BASENAME:.o=.c))\n\n# Anything that depends on FORCE will be considered out-of-date\nFORCE:\n.PHONY: FORCE\n\n$(HEADER_BUILD)/mpversion.h: FORCE | $(HEADER_BUILD)\n\t$(Q)$(PYTHON) $(PY_SRC)/makeversionhdr.py $@\n\n# mpconfigport.mk is optional, but changes to it may drastically change\n# overall config, so they need to be caught\nMPCONFIGPORT_MK = $(wildcard mpconfigport.mk)\n\n# qstr data\n# Adding an order only dependency on $(HEADER_BUILD) causes $(HEADER_BUILD) to get\n# created before we run the script to generate the .h\n# Note: we need to protect the qstr names from the preprocessor, so we wrap\n# the lines in \"\" and then unwrap after the preprocessor is finished.\n# See more information about this process in docs/develop/qstr.rst.\n$(HEADER_BUILD)/qstrdefs.generated.h: $(PY_QSTR_DEFS) $(QSTR_DEFS) $(QSTR_DEFS_COLLECTED) $(PY_SRC)/makeqstrdata.py mpconfigport.h $(MPCONFIGPORT_MK) $(PY_SRC)/mpconfig.h | $(HEADER_BUILD)\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(CAT) $(PY_QSTR_DEFS) $(QSTR_DEFS) $(QSTR_DEFS_COLLECTED) | $(SED) 's/^Q(.*)/\"&\"/' | $(CPP) $(CFLAGS) - | $(SED) 's/^\\\"\\(Q(.*)\\)\\\"/\\1/' > $(HEADER_BUILD)/qstrdefs.preprocessed.h\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdata.py $(HEADER_BUILD)/qstrdefs.preprocessed.h > $@\n\n$(HEADER_BUILD)/compressed.data.h: $(HEADER_BUILD)/compressed.collected\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makecompresseddata.py $< > $@\n\n# build a list of registered modules for py/objmodule.c.\n$(HEADER_BUILD)/moduledefs.h: $(HEADER_BUILD)/moduledefs.collected\n\t@$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makemoduledefs.py $< > $@\n\n# build a list of registered root pointers for py/mpstate.h.\n$(HEADER_BUILD)/root_pointers.h: $(HEADER_BUILD)/root_pointers.collected $(PY_SRC)/make_root_pointers.py\n\t@$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/make_root_pointers.py $< > $@\n\n# Standard C functions like memset need to be compiled with special flags so\n# the compiler does not optimise these functions in terms of themselves.\nCFLAGS_BUILTIN ?= -ffreestanding -fno-builtin -fno-lto\n$(BUILD)/shared/libc/string0.o: CFLAGS += $(CFLAGS_BUILTIN)\n\n# Force nlr code to always be compiled with space-saving optimisation so\n# that the function preludes are of a minimal and predictable form.\n$(PY_BUILD)/nlr%.o: CFLAGS += -Os\n\n# optimising gc for speed; 5ms down to 4ms on pybv2\n$(PY_BUILD)/gc.o: CFLAGS += $(CSUPEROPT)\n\n# optimising vm for speed, adds only a small amount to code size but makes a huge difference to speed (20% faster)\n$(PY_BUILD)/vm.o: CFLAGS += $(CSUPEROPT)\n# Optimizing vm.o for modern deeply pipelined CPUs with branch predictors\n# may require disabling tail jump optimization. This will make sure that\n# each opcode has its own dispatching jump which will improve branch\n# branch predictor efficiency.\n# https://marc.info/?l=lua-l&m=129778596120851\n# http://hg.python.org/cpython/file/b127046831e2/Python/ceval.c#l828\n# http://www.emulators.com/docs/nx25_nostradamus.htm\n#-fno-crossjumping\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}