{
  "module_name": "emitinlinextensa.c",
  "hash_id": "bf035f1d2a08979b800a908896dad4f945fb4d21e3afd1f897a275d58b959083",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/emitinlinextensa.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <assert.h>\n\n#include \"py/emit.h\"\n#include \"py/asmxtensa.h\"\n\n#if MICROPY_EMIT_INLINE_XTENSA\n\nstruct _emit_inline_asm_t {\n    asm_xtensa_t as;\n    uint16_t pass;\n    mp_obj_t *error_slot;\n    mp_uint_t max_num_labels;\n    qstr *label_lookup;\n};\n\nstatic void emit_inline_xtensa_error_msg(emit_inline_asm_t *emit, mp_rom_error_text_t msg) {\n    *emit->error_slot = mp_obj_new_exception_msg(&mp_type_SyntaxError, msg);\n}\n\nstatic void emit_inline_xtensa_error_exc(emit_inline_asm_t *emit, mp_obj_t exc) {\n    *emit->error_slot = exc;\n}\n\nemit_inline_asm_t *emit_inline_xtensa_new(mp_uint_t max_num_labels) {\n    emit_inline_asm_t *emit = m_new_obj(emit_inline_asm_t);\n    memset(&emit->as, 0, sizeof(emit->as));\n    mp_asm_base_init(&emit->as.base, max_num_labels);\n    emit->max_num_labels = max_num_labels;\n    emit->label_lookup = m_new(qstr, max_num_labels);\n    return emit;\n}\n\nvoid emit_inline_xtensa_free(emit_inline_asm_t *emit) {\n    m_del(qstr, emit->label_lookup, emit->max_num_labels);\n    mp_asm_base_deinit(&emit->as.base, false);\n    m_del_obj(emit_inline_asm_t, emit);\n}\n\nstatic void emit_inline_xtensa_start_pass(emit_inline_asm_t *emit, pass_kind_t pass, mp_obj_t *error_slot) {\n    emit->pass = pass;\n    emit->error_slot = error_slot;\n    if (emit->pass == MP_PASS_CODE_SIZE) {\n        memset(emit->label_lookup, 0, emit->max_num_labels * sizeof(qstr));\n    }\n    mp_asm_base_start_pass(&emit->as.base, pass == MP_PASS_EMIT ? MP_ASM_PASS_EMIT : MP_ASM_PASS_COMPUTE);\n    asm_xtensa_entry(&emit->as, 0);\n}\n\nstatic void emit_inline_xtensa_end_pass(emit_inline_asm_t *emit, mp_uint_t type_sig) {\n    asm_xtensa_exit(&emit->as);\n    asm_xtensa_end_pass(&emit->as);\n}\n\nstatic mp_uint_t emit_inline_xtensa_count_params(emit_inline_asm_t *emit, mp_uint_t n_params, mp_parse_node_t *pn_params) {\n    if (n_params > 4) {\n        emit_inline_xtensa_error_msg(emit, MP_ERROR_TEXT(\"can only have up to 4 parameters to Xtensa assembly\"));\n        return 0;\n    }\n    for (mp_uint_t i = 0; i < n_params; i++) {\n        if (!MP_PARSE_NODE_IS_ID(pn_params[i])) {\n            emit_inline_xtensa_error_msg(emit, MP_ERROR_TEXT(\"parameters must be registers in sequence a2 to a5\"));\n            return 0;\n        }\n        const char *p = qstr_str(MP_PARSE_NODE_LEAF_ARG(pn_params[i]));\n        if (!(strlen(p) == 2 && p[0] == 'a' && (mp_uint_t)p[1] == '2' + i)) {\n            emit_inline_xtensa_error_msg(emit, MP_ERROR_TEXT(\"parameters must be registers in sequence a2 to a5\"));\n            return 0;\n        }\n    }\n    return n_params;\n}\n\nstatic bool emit_inline_xtensa_label(emit_inline_asm_t *emit, mp_uint_t label_num, qstr label_id) {\n    assert(label_num < emit->max_num_labels);\n    if (emit->pass == MP_PASS_CODE_SIZE) {\n        \n        for (uint i = 0; i < emit->max_num_labels; i++) {\n            if (emit->label_lookup[i] == label_id) {\n                return false;\n            }\n        }\n    }\n    emit->label_lookup[label_num] = label_id;\n    mp_asm_base_label_assign(&emit->as.base, label_num);\n    return true;\n}\n\ntypedef struct _reg_name_t { byte reg;\n                             byte name[3];\n} reg_name_t;\nstatic const reg_name_t reg_name_table[] = {\n    {0, \"a0\\0\"},\n    {1, \"a1\\0\"},\n    {2, \"a2\\0\"},\n    {3, \"a3\\0\"},\n    {4, \"a4\\0\"},\n    {5, \"a5\\0\"},\n    {6, \"a6\\0\"},\n    {7, \"a7\\0\"},\n    {8, \"a8\\0\"},\n    {9, \"a9\\0\"},\n    {10, \"a10\"},\n    {11, \"a11\"},\n    {12, \"a12\"},\n    {13, \"a13\"},\n    {14, \"a14\"},\n    {15, \"a15\"},\n};\n\n\n\nstatic const char *get_arg_str(mp_parse_node_t pn) {\n    if (MP_PARSE_NODE_IS_ID(pn)) {\n        qstr qst = MP_PARSE_NODE_LEAF_ARG(pn);\n        return qstr_str(qst);\n    } else {\n        return \"\";\n    }\n}\n\nstatic mp_uint_t get_arg_reg(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn) {\n    const char *reg_str = get_arg_str(pn);\n    for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(reg_name_table); i++) {\n        const reg_name_t *r = &reg_name_table[i];\n        if (reg_str[0] == r->name[0]\n            && reg_str[1] == r->name[1]\n            && reg_str[2] == r->name[2]\n            && (reg_str[2] == '\\0' || reg_str[3] == '\\0')) {\n            return r->reg;\n        }\n    }\n    emit_inline_xtensa_error_exc(emit,\n        mp_obj_new_exception_msg_varg(&mp_type_SyntaxError,\n            MP_ERROR_TEXT(\"'%s' expects a register\"), op));\n    return 0;\n}\n\nstatic uint32_t get_arg_i(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn, int min, int max) {\n    mp_obj_t o;\n    if (!mp_parse_node_get_int_maybe(pn, &o)) {\n        emit_inline_xtensa_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' expects an integer\"), op));\n        return 0;\n    }\n    uint32_t i = mp_obj_get_int_truncated(o);\n    if (min != max && ((int)i < min || (int)i > max)) {\n        emit_inline_xtensa_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' integer %d isn't within range %d..%d\"), op, i, min, max));\n        return 0;\n    }\n    return i;\n}\n\nstatic int get_arg_label(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn) {\n    if (!MP_PARSE_NODE_IS_ID(pn)) {\n        emit_inline_xtensa_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' expects a label\"), op));\n        return 0;\n    }\n    qstr label_qstr = MP_PARSE_NODE_LEAF_ARG(pn);\n    for (uint i = 0; i < emit->max_num_labels; i++) {\n        if (emit->label_lookup[i] == label_qstr) {\n            return i;\n        }\n    }\n    \n    if (emit->pass == MP_PASS_EMIT) {\n        emit_inline_xtensa_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"label '%q' not defined\"), label_qstr));\n    }\n    return 0;\n}\n\n#define RRR (0)\n#define RRI8 (1)\n#define RRI8_B (2)\n\ntypedef struct _opcode_table_3arg_t {\n    uint16_t name; \n    uint8_t type;\n    uint8_t a0 : 4;\n    uint8_t a1 : 4;\n} opcode_table_3arg_t;\n\nstatic const opcode_table_3arg_t opcode_table_3arg[] = {\n    \n    {MP_QSTR_and_, RRR, 0, 1},\n    {MP_QSTR_or_, RRR, 0, 2},\n    {MP_QSTR_xor, RRR, 0, 3},\n    {MP_QSTR_add, RRR, 0, 8},\n    {MP_QSTR_sub, RRR, 0, 12},\n    {MP_QSTR_mull, RRR, 2, 8},\n\n    \n    \n    {MP_QSTR_l8ui, RRI8 | 0x10, 2, 0},\n    {MP_QSTR_l16ui, RRI8 | 0x30, 2, 1},\n    {MP_QSTR_l32i, RRI8 | 0x50, 2, 2},\n    {MP_QSTR_s8i, RRI8 | 0x10, 2, 4},\n    {MP_QSTR_s16i, RRI8 | 0x30, 2, 5},\n    {MP_QSTR_s32i, RRI8 | 0x50, 2, 6},\n    {MP_QSTR_l16si, RRI8 | 0x30, 2, 9},\n    {MP_QSTR_addi, RRI8 | 0x00, 2, 12},\n\n    \n    {MP_QSTR_ball, RRI8_B, ASM_XTENSA_CC_ALL, 0},\n    {MP_QSTR_bany, RRI8_B, ASM_XTENSA_CC_ANY, 0},\n    {MP_QSTR_bbc, RRI8_B, ASM_XTENSA_CC_BC, 0},\n    {MP_QSTR_bbs, RRI8_B, ASM_XTENSA_CC_BS, 0},\n    {MP_QSTR_beq, RRI8_B, ASM_XTENSA_CC_EQ, 0},\n    {MP_QSTR_bge, RRI8_B, ASM_XTENSA_CC_GE, 0},\n    {MP_QSTR_bgeu, RRI8_B, ASM_XTENSA_CC_GEU, 0},\n    {MP_QSTR_blt, RRI8_B, ASM_XTENSA_CC_LT, 0},\n    {MP_QSTR_bnall, RRI8_B, ASM_XTENSA_CC_NALL, 0},\n    {MP_QSTR_bne, RRI8_B, ASM_XTENSA_CC_NE, 0},\n    {MP_QSTR_bnone, RRI8_B, ASM_XTENSA_CC_NONE, 0},\n};\n\nstatic void emit_inline_xtensa_op(emit_inline_asm_t *emit, qstr op, mp_uint_t n_args, mp_parse_node_t *pn_args) {\n    size_t op_len;\n    const char *op_str = (const char *)qstr_data(op, &op_len);\n\n    if (n_args == 0) {\n        if (op == MP_QSTR_ret_n) {\n            asm_xtensa_op_ret_n(&emit->as);\n        } else {\n            goto unknown_op;\n        }\n\n    } else if (n_args == 1) {\n        if (op == MP_QSTR_callx0) {\n            uint r0 = get_arg_reg(emit, op_str, pn_args[0]);\n            asm_xtensa_op_callx0(&emit->as, r0);\n        } else if (op == MP_QSTR_j) {\n            int label = get_arg_label(emit, op_str, pn_args[0]);\n            asm_xtensa_j_label(&emit->as, label);\n        } else if (op == MP_QSTR_jx) {\n            uint r0 = get_arg_reg(emit, op_str, pn_args[0]);\n            asm_xtensa_op_jx(&emit->as, r0);\n        } else {\n            goto unknown_op;\n        }\n\n    } else if (n_args == 2) {\n        uint r0 = get_arg_reg(emit, op_str, pn_args[0]);\n        if (op == MP_QSTR_beqz) {\n            int label = get_arg_label(emit, op_str, pn_args[1]);\n            asm_xtensa_bccz_reg_label(&emit->as, ASM_XTENSA_CCZ_EQ, r0, label);\n        } else if (op == MP_QSTR_bnez) {\n            int label = get_arg_label(emit, op_str, pn_args[1]);\n            asm_xtensa_bccz_reg_label(&emit->as, ASM_XTENSA_CCZ_NE, r0, label);\n        } else if (op == MP_QSTR_mov || op == MP_QSTR_mov_n) {\n            \n            uint r1 = get_arg_reg(emit, op_str, pn_args[1]);\n            asm_xtensa_op_mov_n(&emit->as, r0, r1);\n        } else if (op == MP_QSTR_movi) {\n            \n            uint32_t imm = get_arg_i(emit, op_str, pn_args[1], 0, 0);\n            asm_xtensa_mov_reg_i32(&emit->as, r0, imm);\n        } else {\n            goto unknown_op;\n        }\n\n    } else if (n_args == 3) {\n        \n        for (uint i = 0; i < MP_ARRAY_SIZE(opcode_table_3arg); i++) {\n            const opcode_table_3arg_t *o = &opcode_table_3arg[i];\n            if (op == o->name) {\n                uint r0 = get_arg_reg(emit, op_str, pn_args[0]);\n                uint r1 = get_arg_reg(emit, op_str, pn_args[1]);\n                if (o->type == RRR) {\n                    uint r2 = get_arg_reg(emit, op_str, pn_args[2]);\n                    asm_xtensa_op24(&emit->as, ASM_XTENSA_ENCODE_RRR(0, o->a0, o->a1, r0, r1, r2));\n                } else if (o->type == RRI8_B) {\n                    int label = get_arg_label(emit, op_str, pn_args[2]);\n                    asm_xtensa_bcc_reg_reg_label(&emit->as, o->a0, r0, r1, label);\n                } else {\n                    int shift, min, max;\n                    if ((o->type & 0xf0) == 0) {\n                        shift = 0;\n                        min = -128;\n                        max = 127;\n                    } else {\n                        shift = (o->type & 0xf0) >> 5;\n                        min = 0;\n                        max = 0xff << shift;\n                    }\n                    uint32_t imm = get_arg_i(emit, op_str, pn_args[2], min, max);\n                    asm_xtensa_op24(&emit->as, ASM_XTENSA_ENCODE_RRI8(o->a0, o->a1, r1, r0, (imm >> shift) & 0xff));\n                }\n                return;\n            }\n        }\n        goto unknown_op;\n\n    } else {\n        goto unknown_op;\n    }\n\n    return;\n\nunknown_op:\n    emit_inline_xtensa_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"unsupported Xtensa instruction '%s' with %d arguments\"), op_str, n_args));\n    return;\n\n     \n}\n\nconst emit_inline_asm_method_table_t emit_inline_xtensa_method_table = {\n    #if MICROPY_DYNAMIC_COMPILER\n    emit_inline_xtensa_new,\n    emit_inline_xtensa_free,\n    #endif\n\n    emit_inline_xtensa_start_pass,\n    emit_inline_xtensa_end_pass,\n    emit_inline_xtensa_count_params,\n    emit_inline_xtensa_label,\n    emit_inline_xtensa_op,\n};\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}