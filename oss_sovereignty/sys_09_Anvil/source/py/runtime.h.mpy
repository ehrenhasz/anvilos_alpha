{
  "module_name": "runtime.h",
  "hash_id": "81e315c98aa44221574399dc77d4ef86284d2269bef8a8be3cb4beb10bddd725",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/runtime.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_RUNTIME_H\n#define MICROPY_INCLUDED_PY_RUNTIME_H\n\n#include \"py/mpstate.h\"\n#include \"py/pystack.h\"\n#include \"py/stackctrl.h\"\n\n\n#define MP_DEFINE_NLR_JUMP_CALLBACK_FUNCTION_1(ctx, f, a) \\\n    nlr_jump_callback_node_call_function_1_t ctx = { \\\n        .func = (void (*)(void *))(f), \\\n        .arg = (a), \\\n    }\n\ntypedef enum {\n    MP_VM_RETURN_NORMAL,\n    MP_VM_RETURN_YIELD,\n    MP_VM_RETURN_EXCEPTION,\n} mp_vm_return_kind_t;\n\ntypedef enum {\n    MP_ARG_BOOL      = 0x001,\n    MP_ARG_INT       = 0x002,\n    MP_ARG_OBJ       = 0x003,\n    MP_ARG_KIND_MASK = 0x0ff,\n    MP_ARG_REQUIRED  = 0x100,\n    MP_ARG_KW_ONLY   = 0x200,\n} mp_arg_flag_t;\n\ntypedef union _mp_arg_val_t {\n    bool u_bool;\n    mp_int_t u_int;\n    mp_obj_t u_obj;\n    mp_rom_obj_t u_rom_obj;\n} mp_arg_val_t;\n\ntypedef struct _mp_arg_t {\n    uint16_t qst;\n    uint16_t flags;\n    mp_arg_val_t defval;\n} mp_arg_t;\n\nstruct _mp_sched_node_t;\n\ntypedef void (*mp_sched_callback_t)(struct _mp_sched_node_t *);\n\ntypedef struct _mp_sched_node_t {\n    mp_sched_callback_t callback;\n    struct _mp_sched_node_t *next;\n} mp_sched_node_t;\n\n\ntypedef struct _nlr_jump_callback_node_globals_locals_t {\n    nlr_jump_callback_node_t callback;\n    mp_obj_dict_t *globals;\n    mp_obj_dict_t *locals;\n} nlr_jump_callback_node_globals_locals_t;\n\n\ntypedef struct _nlr_jump_callback_node_call_function_1_t {\n    nlr_jump_callback_node_t callback;\n    void (*func)(void *);\n    void *arg;\n} nlr_jump_callback_node_call_function_1_t;\n\n\nextern const byte mp_unary_op_method_name[];\nextern const byte mp_binary_op_method_name[];\n\nvoid mp_init(void);\nvoid mp_deinit(void);\n\nvoid mp_sched_exception(mp_obj_t exc);\nvoid mp_sched_keyboard_interrupt(void);\n#if MICROPY_ENABLE_VM_ABORT\nvoid mp_sched_vm_abort(void);\n#endif\nvoid mp_handle_pending(bool raise_exc);\n\n#if MICROPY_ENABLE_SCHEDULER\nvoid mp_sched_lock(void);\nvoid mp_sched_unlock(void);\n#define mp_sched_num_pending() (MP_STATE_VM(sched_len))\nbool mp_sched_schedule(mp_obj_t function, mp_obj_t arg);\nbool mp_sched_schedule_node(mp_sched_node_t *node, mp_sched_callback_t callback);\n#endif\n\n\nvoid mp_event_handle_nowait(void);\n\n\n\n\n\n\n\nvoid mp_event_wait_indefinite(void);\n\n\n\n\n\nvoid mp_event_wait_ms(mp_uint_t timeout_ms);\n\n\nint mp_print_mp_int(const mp_print_t *print, mp_obj_t x, int base, int base_char, int flags, char fill, int width, int prec);\n\nvoid mp_arg_check_num_sig(size_t n_args, size_t n_kw, uint32_t sig);\nstatic inline void mp_arg_check_num(size_t n_args, size_t n_kw, size_t n_args_min, size_t n_args_max, bool takes_kw) {\n    mp_arg_check_num_sig(n_args, n_kw, MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, takes_kw));\n}\nvoid mp_arg_parse_all(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);\nvoid mp_arg_parse_all_kw_array(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);\nNORETURN void mp_arg_error_terse_mismatch(void);\nNORETURN void mp_arg_error_unimpl_kw(void);\n\nstatic inline mp_obj_dict_t *mp_locals_get(void) {\n    return MP_STATE_THREAD(dict_locals);\n}\nstatic inline void mp_locals_set(mp_obj_dict_t *d) {\n    MP_STATE_THREAD(dict_locals) = d;\n}\nstatic inline mp_obj_dict_t *mp_globals_get(void) {\n    return MP_STATE_THREAD(dict_globals);\n}\nstatic inline void mp_globals_set(mp_obj_dict_t *d) {\n    MP_STATE_THREAD(dict_globals) = d;\n}\n\nvoid mp_globals_locals_set_from_nlr_jump_callback(void *ctx_in);\nvoid mp_call_function_1_from_nlr_jump_callback(void *ctx_in);\n\n#if MICROPY_PY_THREAD\nstatic inline void mp_thread_init_state(mp_state_thread_t *ts, size_t stack_size, mp_obj_dict_t *locals, mp_obj_dict_t *globals) {\n    mp_thread_set_state(ts);\n\n    mp_stack_set_top(ts + 1); \n    mp_stack_set_limit(stack_size);\n\n    \n    ts->gc_lock_depth = 0;\n\n    \n    ts->nlr_jump_callback_top = NULL;\n    ts->mp_pending_exception = MP_OBJ_NULL;\n\n    \n    if (locals == NULL) {\n        locals = mp_state_ctx.thread.dict_locals;\n    }\n    if (globals == NULL) {\n        globals = mp_state_ctx.thread.dict_globals;\n    }\n    mp_locals_set(locals);\n    mp_globals_set(globals);\n}\n#endif\n\nmp_obj_t mp_load_name(qstr qst);\nmp_obj_t mp_load_global(qstr qst);\nmp_obj_t mp_load_build_class(void);\nvoid mp_store_name(qstr qst, mp_obj_t obj);\nvoid mp_store_global(qstr qst, mp_obj_t obj);\nvoid mp_delete_name(qstr qst);\nvoid mp_delete_global(qstr qst);\n\nmp_obj_t mp_unary_op(mp_unary_op_t op, mp_obj_t arg);\nmp_obj_t mp_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs);\n\nmp_obj_t mp_call_function_0(mp_obj_t fun);\nmp_obj_t mp_call_function_1(mp_obj_t fun, mp_obj_t arg);\nmp_obj_t mp_call_function_2(mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2);\nmp_obj_t mp_call_function_n_kw(mp_obj_t fun, size_t n_args, size_t n_kw, const mp_obj_t *args);\nmp_obj_t mp_call_method_n_kw(size_t n_args, size_t n_kw, const mp_obj_t *args);\nmp_obj_t mp_call_method_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args);\nmp_obj_t mp_call_method_self_n_kw(mp_obj_t meth, mp_obj_t self, size_t n_args, size_t n_kw, const mp_obj_t *args);\n\n\nmp_obj_t mp_call_function_1_protected(mp_obj_t fun, mp_obj_t arg);\nmp_obj_t mp_call_function_2_protected(mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2);\n\ntypedef struct _mp_call_args_t {\n    mp_obj_t fun;\n    size_t n_args, n_kw, n_alloc;\n    mp_obj_t *args;\n} mp_call_args_t;\n\n#if MICROPY_STACKLESS\n\n\n\n\nvoid mp_call_prepare_args_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args);\n#endif\n\nvoid mp_unpack_sequence(mp_obj_t seq, size_t num, mp_obj_t *items);\nvoid mp_unpack_ex(mp_obj_t seq, size_t num, mp_obj_t *items);\nmp_obj_t mp_store_map(mp_obj_t map, mp_obj_t key, mp_obj_t value);\nmp_obj_t mp_load_attr(mp_obj_t base, qstr attr);\nvoid mp_convert_member_lookup(mp_obj_t obj, const mp_obj_type_t *type, mp_obj_t member, mp_obj_t *dest);\nvoid mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest);\nvoid mp_load_method_maybe(mp_obj_t base, qstr attr, mp_obj_t *dest);\nvoid mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, bool catch_all_exc);\nvoid mp_load_super_method(qstr attr, mp_obj_t *dest);\nvoid mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t val);\n\nmp_obj_t mp_getiter(mp_obj_t o, mp_obj_iter_buf_t *iter_buf);\nmp_obj_t mp_iternext_allow_raise(mp_obj_t o); \nmp_obj_t mp_iternext(mp_obj_t o); \nmp_vm_return_kind_t mp_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val);\n\nstatic inline mp_obj_t mp_make_stop_iteration(mp_obj_t o) {\n    MP_STATE_THREAD(stop_iteration_arg) = o;\n    return MP_OBJ_STOP_ITERATION;\n}\n\nmp_obj_t mp_make_raise_obj(mp_obj_t o);\n\nmp_obj_t mp_import_name(qstr name, mp_obj_t fromlist, mp_obj_t level);\nmp_obj_t mp_import_from(mp_obj_t module, qstr name);\nvoid mp_import_all(mp_obj_t module);\n\n#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NONE\nNORETURN void mp_raise_type(const mp_obj_type_t *exc_type);\nNORETURN void mp_raise_ValueError_no_msg(void);\nNORETURN void mp_raise_TypeError_no_msg(void);\nNORETURN void mp_raise_NotImplementedError_no_msg(void);\n#define mp_raise_msg(exc_type, msg) mp_raise_type(exc_type)\n#define mp_raise_msg_varg(exc_type, ...) mp_raise_type(exc_type)\n#define mp_raise_ValueError(msg) mp_raise_ValueError_no_msg()\n#define mp_raise_TypeError(msg) mp_raise_TypeError_no_msg()\n#define mp_raise_NotImplementedError(msg) mp_raise_NotImplementedError_no_msg()\n#else\n#define mp_raise_type(exc_type) mp_raise_msg(exc_type, NULL)\nNORETURN void mp_raise_msg(const mp_obj_type_t *exc_type, mp_rom_error_text_t msg);\nNORETURN void mp_raise_msg_varg(const mp_obj_type_t *exc_type, mp_rom_error_text_t fmt, ...);\nNORETURN void mp_raise_ValueError(mp_rom_error_text_t msg);\nNORETURN void mp_raise_TypeError(mp_rom_error_text_t msg);\nNORETURN void mp_raise_NotImplementedError(mp_rom_error_text_t msg);\n#endif\n\nNORETURN void mp_raise_type_arg(const mp_obj_type_t *exc_type, mp_obj_t arg);\nNORETURN void mp_raise_StopIteration(mp_obj_t arg);\nNORETURN void mp_raise_TypeError_int_conversion(mp_const_obj_t arg);\nNORETURN void mp_raise_OSError(int errno_);\nNORETURN void mp_raise_OSError_with_filename(int errno_, const char *filename);\nNORETURN void mp_raise_recursion_depth(void);\n\n#if MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG\n#undef mp_check_self\n#define mp_check_self(pred)\n#else\n\n#ifndef mp_check_self\n#define mp_check_self(pred) assert(pred)\n#endif\n#endif\n\n\nint mp_native_type_from_qstr(qstr qst);\nmp_uint_t mp_native_from_obj(mp_obj_t obj, mp_uint_t type);\nmp_obj_t mp_native_to_obj(mp_uint_t val, mp_uint_t type);\n\n#if MICROPY_PY_SYS_PATH\n#define mp_sys_path (MP_STATE_VM(sys_mutable[MP_SYS_MUTABLE_PATH]))\n#endif\n\n#if MICROPY_PY_SYS_ARGV\n#define mp_sys_argv (MP_OBJ_FROM_PTR(&MP_STATE_VM(mp_sys_argv_obj)))\n#endif\n\n#if MICROPY_WARNINGS\n#ifndef mp_warning\nvoid mp_warning(const char *category, const char *msg, ...);\n#endif\n#else\n#define mp_warning(...)\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}