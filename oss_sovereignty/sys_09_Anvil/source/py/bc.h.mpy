{
  "module_name": "bc.h",
  "hash_id": "5c82787c37f26b215032e8f33859a910a4b8588cde5524c41692603395589756",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/bc.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_BC_H\n#define MICROPY_INCLUDED_PY_BC_H\n\n#include \"py/runtime.h\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define MP_ENCODE_UINT_MAX_BYTES ((MP_BYTES_PER_OBJ_WORD * 8 + 6) / 7)\n\n#define MP_BC_PRELUDE_SIG_ENCODE(S, E, scope, out_byte, out_env) \\\n    do {                                                            \\\n                   \\\n        S -= 1;                                                     \\\n                                                                \\\n                                                 \\\n                                                       \\\n        uint8_t z = (S & 0xf) << 3 | (E & 1) << 2 | (A & 3);        \\\n        S >>= 4;                                                    \\\n        E >>= 1;                                                    \\\n        A >>= 2;                                                    \\\n        while (S | E | F | A | K | D) {                             \\\n            out_byte(out_env, 0x80 | z);                            \\\n                                                       \\\n            z = (F & 1) << 6 | (S & 3) << 4 | (K & 1) << 3          \\\n                | (A & 1) << 2 | (E & 1) << 1 | (D & 1);            \\\n            S >>= 2;                                                \\\n            E >>= 1;                                                \\\n            F >>= 1;                                                \\\n            A >>= 1;                                                \\\n            K >>= 1;                                                \\\n            D >>= 1;                                                \\\n        }                                                           \\\n        out_byte(out_env, z);                                       \\\n    } while (0)\n\n#define MP_BC_PRELUDE_SIG_DECODE_INTO(ip, S, E, F, A, K, D)     \\\n    do {                                                            \\\n        uint8_t z = *(ip)++;                                        \\\n                                                       \\\n        S = (z >> 3) & 0xf;                                         \\\n        E = (z >> 2) & 0x1;                                         \\\n        F = 0;                                                      \\\n        A = z & 0x3;                                                \\\n        K = 0;                                                      \\\n        D = 0;                                                      \\\n        for (unsigned n = 0; z & 0x80; ++n) {                       \\\n            z = *(ip)++;                                            \\\n                                                       \\\n            S |= (z & 0x30) << (2 * n);                             \\\n            E |= (z & 0x02) << n;                                   \\\n            F |= ((z & 0x40) >> 6) << n;                            \\\n            A |= (z & 0x4) << n;                                    \\\n            K |= ((z & 0x08) >> 3) << n;                            \\\n            D |= (z & 0x1) << n;                                    \\\n        }                                                           \\\n        S += 1;                                                     \\\n    } while (0)\n\n#define MP_BC_PRELUDE_SIG_DECODE(ip) \\\n    size_t n_state, n_exc_stack, scope_flags, n_pos_args, n_kwonly_args, n_def_pos_args; \\\n    MP_BC_PRELUDE_SIG_DECODE_INTO(ip, n_state, n_exc_stack, scope_flags, n_pos_args, n_kwonly_args, n_def_pos_args); \\\n    (void)n_state; (void)n_exc_stack; (void)scope_flags; \\\n    (void)n_pos_args; (void)n_kwonly_args; (void)n_def_pos_args\n\n#define MP_BC_PRELUDE_SIZE_ENCODE(I, C, out_byte, out_env)      \\\n    do {                                                            \\\n                                   \\\n        uint8_t z = 0;                                              \\\n        do {                                                        \\\n            z = (I & 0x3f) << 1 | (C & 1);                          \\\n            C >>= 1;                                                \\\n            I >>= 6;                                                \\\n            if (C | I) {                                            \\\n                z |= 0x80;                                          \\\n            }                                                       \\\n            out_byte(out_env, z);                                   \\\n        } while (C | I);                                            \\\n    } while (0)\n\n#define MP_BC_PRELUDE_SIZE_DECODE_INTO(ip, I, C)                \\\n    do {                                                            \\\n        uint8_t z;                                                  \\\n        C = 0;                                                      \\\n        I = 0;                                                      \\\n        for (unsigned n = 0;; ++n) {                                \\\n            z = *(ip)++;                                            \\\n                                                       \\\n            C |= (z & 1) << n;                                      \\\n            I |= ((z & 0x7e) >> 1) << (6 * n);                      \\\n            if (!(z & 0x80)) {                                      \\\n                break;                                              \\\n            }                                                       \\\n        }                                                           \\\n    } while (0)\n\n#define MP_BC_PRELUDE_SIZE_DECODE(ip) \\\n    size_t n_info, n_cell; \\\n    MP_BC_PRELUDE_SIZE_DECODE_INTO(ip, n_info, n_cell); \\\n    (void)n_info; (void)n_cell\n\n\n#define MP_CODE_STATE_EXC_SP_IDX_SENTINEL ((uint16_t)-1)\n\n\n#define MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp) ((exc_sp) + 1 - (exc_stack))\n#define MP_CODE_STATE_EXC_SP_IDX_TO_PTR(exc_stack, exc_sp_idx) ((exc_stack) + (exc_sp_idx) - 1)\n\ntypedef struct _mp_bytecode_prelude_t {\n    uint n_state;\n    uint n_exc_stack;\n    uint scope_flags;\n    uint n_pos_args;\n    uint n_kwonly_args;\n    uint n_def_pos_args;\n    qstr qstr_block_name_idx;\n    const byte *line_info;\n    const byte *line_info_top;\n    const byte *opcodes;\n} mp_bytecode_prelude_t;\n\n\ntypedef struct _mp_exc_stack_t {\n    const byte *handler;\n    \n    \n    mp_obj_t *val_sp;\n    \n    mp_obj_base_t *prev_exc;\n} mp_exc_stack_t;\n\n\ntypedef struct _mp_module_constants_t {\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    qstr_short_t *qstr_table;\n    #else\n    qstr source_file;\n    #endif\n    mp_obj_t *obj_table;\n} mp_module_constants_t;\n\n\ntypedef struct _mp_module_context_t {\n    mp_obj_module_t module;\n    mp_module_constants_t constants;\n} mp_module_context_t;\n\n\ntypedef struct _mp_compiled_module_t {\n    mp_module_context_t *context;\n    const struct _mp_raw_code_t *rc;\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    bool has_native;\n    size_t n_qstr;\n    size_t n_obj;\n    #endif\n} mp_compiled_module_t;\n\n\ntypedef struct _mp_frozen_module_t {\n    const mp_module_constants_t constants;\n    const void *proto_fun;\n} mp_frozen_module_t;\n\n\ntypedef struct _mp_code_state_t {\n    \n    \n    \n    \n    struct _mp_obj_fun_bc_t *fun_bc;\n    const byte *ip;\n    mp_obj_t *sp;\n    uint16_t n_state;\n    uint16_t exc_sp_idx;\n    mp_obj_dict_t *old_globals;\n    #if MICROPY_STACKLESS\n    struct _mp_code_state_t *prev;\n    #endif\n    #if MICROPY_PY_SYS_SETTRACE\n    struct _mp_code_state_t *prev_state;\n    struct _mp_obj_frame_t *frame;\n    #endif\n    \n    mp_obj_t state[0];\n    \n    \n} mp_code_state_t;\n\n\ntypedef struct _mp_code_state_native_t {\n    struct _mp_obj_fun_bc_t *fun_bc;\n    const byte *ip;\n    mp_obj_t *sp;\n    uint16_t n_state;\n    uint16_t exc_sp_idx;\n    mp_obj_dict_t *old_globals;\n    mp_obj_t state[0];\n} mp_code_state_native_t;\n\n\ntypedef uint8_t *(*mp_encode_uint_allocator_t)(void *env, size_t nbytes);\n\nvoid mp_encode_uint(void *env, mp_encode_uint_allocator_t allocator, mp_uint_t val);\nmp_uint_t mp_decode_uint(const byte **ptr);\nmp_uint_t mp_decode_uint_value(const byte *ptr);\nconst byte *mp_decode_uint_skip(const byte *ptr);\n\nmp_vm_return_kind_t mp_execute_bytecode(mp_code_state_t *code_state,\n#ifndef __cplusplus\n    volatile\n#endif\n    mp_obj_t inject_exc);\nmp_code_state_t *mp_obj_fun_bc_prepare_codestate(mp_obj_t func, size_t n_args, size_t n_kw, const mp_obj_t *args);\nvoid mp_setup_code_state(mp_code_state_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args);\nvoid mp_setup_code_state_native(mp_code_state_native_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args);\nvoid mp_bytecode_print(const mp_print_t *print, const struct _mp_raw_code_t *rc, size_t fun_data_len, const mp_module_constants_t *cm);\nvoid mp_bytecode_print2(const mp_print_t *print, const byte *ip, size_t len, struct _mp_raw_code_t *const *child_table, const mp_module_constants_t *cm);\nconst byte *mp_bytecode_print_str(const mp_print_t *print, const byte *ip_start, const byte *ip, struct _mp_raw_code_t *const *child_table, const mp_module_constants_t *cm);\n#define mp_bytecode_print_inst(print, code, x_table) mp_bytecode_print2(print, code, 1, x_table)\n\n\n#define MP_TAGPTR_PTR(x) ((void *)((uintptr_t)(x) & ~((uintptr_t)3)))\n#define MP_TAGPTR_TAG0(x) ((uintptr_t)(x) & 1)\n#define MP_TAGPTR_TAG1(x) ((uintptr_t)(x) & 2)\n#define MP_TAGPTR_MAKE(ptr, tag) ((void *)((uintptr_t)(ptr) | (tag)))\n\nstatic inline void mp_module_context_alloc_tables(mp_module_context_t *context, size_t n_qstr, size_t n_obj) {\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    size_t nq = (n_qstr * sizeof(qstr_short_t) + sizeof(mp_uint_t) - 1) / sizeof(mp_uint_t);\n    size_t no = n_obj;\n    mp_uint_t *mem = m_new(mp_uint_t, nq + no);\n    context->constants.qstr_table = (qstr_short_t *)mem;\n    context->constants.obj_table = (mp_obj_t *)(mem + nq);\n    #else\n    if (n_obj == 0) {\n        context->constants.obj_table = NULL;\n    } else {\n        context->constants.obj_table = m_new(mp_obj_t, n_obj);\n    }\n    #endif\n}\n\nstatic inline size_t mp_bytecode_get_source_line(const byte *line_info, const byte *line_info_top, size_t bc_offset) {\n    size_t source_line = 1;\n    while (line_info < line_info_top) {\n        size_t c = *line_info;\n        size_t b, l;\n        if ((c & 0x80) == 0) {\n            \n            b = c & 0x1f;\n            l = c >> 5;\n            line_info += 1;\n        } else {\n            \n            b = c & 0xf;\n            l = ((c << 4) & 0x700) | line_info[1];\n            line_info += 2;\n        }\n        if (bc_offset >= b) {\n            bc_offset -= b;\n            source_line += l;\n        } else {\n            \n            break;\n        }\n    }\n    return source_line;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}