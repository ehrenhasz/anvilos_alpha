{
  "module_name": "formatfloat.c",
  "hash_id": "3899bc4c0efc1fc3b47f24449e4aef8c3ea91a66e80521773d82106db25fb5a4",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/formatfloat.c",
  "human_readable_source": " \n\n#include \"py/mpconfig.h\"\n#include \"py/misc.h\"\n#if MICROPY_FLOAT_IMPL != MICROPY_FLOAT_IMPL_NONE\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include \"py/formatfloat.h\"\n\n \n\n#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n\n\n\n\n\n#define FPTYPE float\n#define FPCONST(x) x##F\n#define FPROUND_TO_ONE 0.9999995F\n#define FPDECEXP 32\n#define FPMIN_BUF_SIZE 6 \n\n#define FLT_SIGN_MASK   0x80000000\n\nstatic inline int fp_signbit(float x) {\n    mp_float_union_t fb = {x};\n    return fb.i & FLT_SIGN_MASK;\n}\n#define fp_isnan(x) isnan(x)\n#define fp_isinf(x) isinf(x)\nstatic inline int fp_iszero(float x) {\n    mp_float_union_t fb = {x};\n    return fb.i == 0;\n}\nstatic inline int fp_isless1(float x) {\n    mp_float_union_t fb = {x};\n    return fb.i < 0x3f800000;\n}\n\n#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n\n#define FPTYPE double\n#define FPCONST(x) x\n#define FPROUND_TO_ONE 0.999999999995\n#define FPDECEXP 256\n#define FPMIN_BUF_SIZE 7 \n#define fp_signbit(x) signbit(x)\n#define fp_isnan(x) isnan(x)\n#define fp_isinf(x) isinf(x)\n#define fp_iszero(x) (x == 0)\n#define fp_isless1(x) (x < 1.0)\n\n#endif \n\nstatic inline int fp_expval(FPTYPE x) {\n    mp_float_union_t fb = {x};\n    return (int)((fb.i >> MP_FLOAT_FRAC_BITS) & (~(0xFFFFFFFF << MP_FLOAT_EXP_BITS))) - MP_FLOAT_EXP_OFFSET;\n}\n\nint mp_format_float(FPTYPE f, char *buf, size_t buf_size, char fmt, int prec, char sign) {\n\n    char *s = buf;\n\n    if (buf_size <= FPMIN_BUF_SIZE) {\n        \n        \n        \n\n        if (buf_size >= 2) {\n            *s++ = '?';\n        }\n        if (buf_size >= 1) {\n            *s = '\\0';\n        }\n        return buf_size >= 2;\n    }\n    if (fp_signbit(f) && !fp_isnan(f)) {\n        *s++ = '-';\n        f = -f;\n    } else {\n        if (sign) {\n            *s++ = sign;\n        }\n    }\n\n    \n    \n    int buf_remaining = buf_size - 1 - (s - buf);\n\n    {\n        char uc = fmt & 0x20;\n        if (fp_isinf(f)) {\n            *s++ = 'I' ^ uc;\n            *s++ = 'N' ^ uc;\n            *s++ = 'F' ^ uc;\n            goto ret;\n        } else if (fp_isnan(f)) {\n            *s++ = 'N' ^ uc;\n            *s++ = 'A' ^ uc;\n            *s++ = 'N' ^ uc;\n        ret:\n            *s = '\\0';\n            return s - buf;\n        }\n    }\n\n    if (prec < 0) {\n        prec = 6;\n    }\n    char e_char = 'E' | (fmt & 0x20);   \n    fmt |= 0x20; \n    char org_fmt = fmt;\n    if (fmt == 'g' && prec == 0) {\n        prec = 1;\n    }\n    int e;\n    int dec = 0;\n    char e_sign = '\\0';\n    int num_digits = 0;\n    int signed_e = 0;\n\n    \n    \n    int e_guess = (int)(fp_expval(f) * FPCONST(0.3010299956639812));  \n    if (fp_iszero(f)) {\n        e = 0;\n        if (fmt == 'f') {\n            \n            if (prec + 2 > buf_remaining) {\n                prec = buf_remaining - 2;\n            }\n            num_digits = prec + 1;\n        } else {\n            \n            if (prec + 6 > buf_remaining) {\n                prec = buf_remaining - 6;\n            }\n            if (fmt == 'e') {\n                e_sign = '+';\n            }\n        }\n    } else if (fp_isless1(f)) {\n        FPTYPE f_entry = f;  \n        \n        e = -e_guess;\n        FPTYPE u_base = MICROPY_FLOAT_C_FUN(pow)(10, -e);\n        while (u_base > f) {\n            ++e;\n            u_base = MICROPY_FLOAT_C_FUN(pow)(10, -e);\n        }\n        \n        \n        \n        f /= u_base;\n\n        \n        \n\n        if (fmt == 'f' || (fmt == 'g' && e <= 4)) {\n            fmt = 'f';\n            dec = 0;\n\n            if (org_fmt == 'g') {\n                prec += (e - 1);\n            }\n\n            \n            if (prec + 2 > buf_remaining) {\n                prec = buf_remaining - 2;\n            }\n\n            num_digits = prec;\n            signed_e = 0;\n            f = f_entry;\n            ++num_digits;\n        } else {\n            \n            \n            e_sign = '-';\n            dec = 0;\n\n            if (prec > (buf_remaining - FPMIN_BUF_SIZE)) {\n                prec = buf_remaining - FPMIN_BUF_SIZE;\n                if (fmt == 'g') {\n                    prec++;\n                }\n            }\n            signed_e = -e;\n        }\n    } else {\n        \n        \n        \n        \n        \n        e = e_guess;\n        FPTYPE next_u = MICROPY_FLOAT_C_FUN(pow)(10, e + 1);\n        while (f >= next_u) {\n            ++e;\n            next_u = MICROPY_FLOAT_C_FUN(pow)(10, e + 1);\n        }\n\n        \n        \n        \n\n        if (fmt == 'f') {\n            if (e >= buf_remaining) {\n                fmt = 'e';\n            } else if ((e + prec + 2) > buf_remaining) {\n                prec = buf_remaining - e - 2;\n                if (prec < 0) {\n                    \n                    \n                    prec++;\n                }\n            }\n        }\n        if (fmt == 'e' && prec > (buf_remaining - FPMIN_BUF_SIZE)) {\n            prec = buf_remaining - FPMIN_BUF_SIZE;\n        }\n        if (fmt == 'g') {\n            \n            if (prec + (FPMIN_BUF_SIZE - 1) > buf_remaining) {\n                prec = buf_remaining - (FPMIN_BUF_SIZE - 1);\n            }\n        }\n        \n        \n\n        if (fmt == 'g' && e < prec) {\n            fmt = 'f';\n            prec -= (e + 1);\n        }\n        if (fmt == 'f') {\n            dec = e;\n            num_digits = prec + e + 1;\n        } else {\n            e_sign = '+';\n        }\n        signed_e = e;\n    }\n    if (prec < 0) {\n        \n        prec = 0;\n    }\n\n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    if (fmt == 'e') {\n        num_digits = prec + 1;\n    } else if (fmt == 'g') {\n        if (prec == 0) {\n            prec = 1;\n        }\n        num_digits = prec;\n    }\n\n    int d = 0;\n    for (int digit_index = signed_e; num_digits >= 0; --digit_index) {\n        FPTYPE u_base = FPCONST(1.0);\n        if (digit_index > 0) {\n            \n            u_base = MICROPY_FLOAT_C_FUN(pow)(10, digit_index);\n        }\n        for (d = 0; d < 9; ++d) {\n            if (f < u_base) {\n                break;\n            }\n            f -= u_base;\n        }\n        \n        \n        if (num_digits > 0) {\n            \n            *s++ = '0' + d;\n            if (dec == 0 && prec > 0) {\n                *s++ = '.';\n            }\n        }\n        --dec;\n        --num_digits;\n        if (digit_index <= 0) {\n            \n            \n            \n            f *= FPCONST(10.0);\n        }\n    }\n    \n    if (d >= 5) {\n        char *rs = s;\n        rs--;\n        while (1) {\n            if (*rs == '.') {\n                rs--;\n                continue;\n            }\n            if (*rs < '0' || *rs > '9') {\n                \n                rs++; \n                break;\n            }\n            if (*rs < '9') {\n                (*rs)++;\n                break;\n            }\n            *rs = '0';\n            if (rs == buf) {\n                break;\n            }\n            rs--;\n        }\n        if (*rs == '0') {\n            \n            if (rs[1] == '.' && fmt != 'f') {\n                \n                \n                rs[0] = '.';\n                rs[1] = '0';\n                if (e_sign == '-') {\n                    e--;\n                    if (e == 0) {\n                        e_sign = '+';\n                    }\n                } else {\n                    e++;\n                }\n            } else {\n                \n                \n                if ((size_t)(s + 1 - buf) < buf_size) {\n                    s++;\n                }\n            }\n            char *ss = s;\n            while (ss > rs) {\n                *ss = ss[-1];\n                ss--;\n            }\n            *rs = '1';\n        }\n    }\n\n    \n    assert((size_t)(s + 1 - buf) <= buf_size);\n\n    if (org_fmt == 'g' && prec > 0) {\n        \n        while (s[-1] == '0') {\n            s--;\n        }\n        if (s[-1] == '.') {\n            s--;\n        }\n    }\n    \n    if (e_sign) {\n        *s++ = e_char;\n        *s++ = e_sign;\n        if (FPMIN_BUF_SIZE == 7 && e >= 100) {\n            *s++ = '0' + (e / 100);\n        }\n        *s++ = '0' + ((e / 10) % 10);\n        *s++ = '0' + (e % 10);\n    }\n    *s = '\\0';\n\n    \n    assert((size_t)(s + 1 - buf) <= buf_size);\n\n    return s - buf;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}