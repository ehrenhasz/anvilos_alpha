{
  "module_name": "objenumerate.c",
  "hash_id": "5a0ed373d8b5bb0f3ce6d63fefcbe7cd586bc98fc77aa7bcd826406e280e3a33",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objenumerate.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_ENUMERATE\n\ntypedef struct _mp_obj_enumerate_t {\n    mp_obj_base_t base;\n    mp_obj_t iter;\n    mp_int_t cur;\n} mp_obj_enumerate_t;\n\nstatic mp_obj_t enumerate_iternext(mp_obj_t self_in);\n\nstatic mp_obj_t enumerate_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    #if MICROPY_CPYTHON_COMPAT\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_iterable, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },\n        { MP_QSTR_start, MP_ARG_INT, {.u_int = 0} },\n    };\n\n    \n    struct {\n        mp_arg_val_t iterable, start;\n    } arg_vals;\n    mp_arg_parse_all_kw_array(n_args, n_kw, args,\n        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t *)&arg_vals);\n\n    \n    mp_obj_enumerate_t *o = mp_obj_malloc(mp_obj_enumerate_t, type);\n    o->iter = mp_getiter(arg_vals.iterable.u_obj, NULL);\n    o->cur = arg_vals.start.u_int;\n    #else\n    mp_arg_check_num(n_args, n_kw, 1, 2, false);\n    mp_obj_enumerate_t *o = mp_obj_malloc(mp_obj_enumerate_t, type);\n    o->iter = mp_getiter(args[0], NULL);\n    o->cur = n_args > 1 ? mp_obj_get_int(args[1]) : 0;\n    #endif\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_enumerate,\n    MP_QSTR_enumerate,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    make_new, enumerate_make_new,\n    iter, enumerate_iternext\n    );\n\nstatic mp_obj_t enumerate_iternext(mp_obj_t self_in) {\n    assert(mp_obj_is_type(self_in, &mp_type_enumerate));\n    mp_obj_enumerate_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t next = mp_iternext(self->iter);\n    if (next == MP_OBJ_STOP_ITERATION) {\n        return MP_OBJ_STOP_ITERATION;\n    } else {\n        mp_obj_t items[] = {MP_OBJ_NEW_SMALL_INT(self->cur++), next};\n        return mp_obj_new_tuple(2, items);\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}