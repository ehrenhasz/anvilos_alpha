{
  "module_name": "vm.c",
  "hash_id": "2be14de3a71b1c65b79e9cd047129590af09ad29942223b182d8bb4ae933df01",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/vm.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/emitglue.h\"\n#include \"py/objtype.h\"\n#include \"py/objfun.h\"\n#include \"py/runtime.h\"\n#include \"py/bc0.h\"\n#include \"py/profile.h\"\n\n\n\n#if 0\n#if MICROPY_PY_THREAD\n#define TRACE_PREFIX mp_printf(&mp_plat_print, \"ts=%p sp=%d \", mp_thread_get_state(), (int)(sp - &code_state->state[0] + 1))\n#else\n#define TRACE_PREFIX mp_printf(&mp_plat_print, \"sp=%d \", (int)(sp - &code_state->state[0] + 1))\n#endif\n#define TRACE(ip) TRACE_PREFIX; mp_bytecode_print2(&mp_plat_print, ip, 1, code_state->fun_bc->child_table, &code_state->fun_bc->context->constants);\n#else\n#define TRACE(ip)\n#endif\n\n\n\n\n\n\n\n\n#define DECODE_UINT \\\n    mp_uint_t unum = 0; \\\n    do { \\\n        unum = (unum << 7) + (*ip & 0x7f); \\\n    } while ((*ip++ & 0x80) != 0)\n\n#define DECODE_ULABEL \\\n    size_t ulab; \\\n    do { \\\n        if (ip[0] & 0x80) { \\\n            ulab = ((ip[0] & 0x7f) | (ip[1] << 7)); \\\n            ip += 2; \\\n        } else { \\\n            ulab = ip[0]; \\\n            ip += 1; \\\n        } \\\n    } while (0)\n\n#define DECODE_SLABEL \\\n    size_t slab; \\\n    do { \\\n        if (ip[0] & 0x80) { \\\n            slab = ((ip[0] & 0x7f) | (ip[1] << 7)) - 0x4000; \\\n            ip += 2; \\\n        } else { \\\n            slab = ip[0] - 0x40; \\\n            ip += 1; \\\n        } \\\n    } while (0)\n\n#if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n\n#define DECODE_QSTR \\\n    DECODE_UINT; \\\n    qstr qst = qstr_table[unum]\n\n#else\n\n#define DECODE_QSTR \\\n    DECODE_UINT; \\\n    qstr qst = unum;\n\n#endif\n\n#define DECODE_PTR \\\n    DECODE_UINT; \\\n    void *ptr = (void *)(uintptr_t)code_state->fun_bc->child_table[unum]\n\n#define DECODE_OBJ \\\n    DECODE_UINT; \\\n    mp_obj_t obj = (mp_obj_t)code_state->fun_bc->context->constants.obj_table[unum]\n\n#define PUSH(val) *++sp = (val)\n#define POP() (*sp--)\n#define TOP() (*sp)\n#define SET_TOP(val) *sp = (val)\n\n#if MICROPY_PY_SYS_EXC_INFO\n#define CLEAR_SYS_EXC_INFO() MP_STATE_VM(cur_exception) = NULL;\n#else\n#define CLEAR_SYS_EXC_INFO()\n#endif\n\n#define PUSH_EXC_BLOCK(with_or_finally) do { \\\n    DECODE_ULABEL;   \\\n    ++exc_sp; \\\n    exc_sp->handler = ip + ulab; \\\n    exc_sp->val_sp = MP_TAGPTR_MAKE(sp, ((with_or_finally) << 1)); \\\n    exc_sp->prev_exc = NULL; \\\n} while (0)\n\n#define POP_EXC_BLOCK() \\\n    exc_sp--;   \\\n    CLEAR_SYS_EXC_INFO()  \n\n#define CANCEL_ACTIVE_FINALLY(sp) do { \\\n    if (mp_obj_is_small_int(sp[-1])) { \\\n          \\\n          \\\n        sp[-2] = sp[0]; \\\n        sp -= 2; \\\n    } else { \\\n        assert(sp[-1] == mp_const_none || mp_obj_is_exception_instance(sp[-1])); \\\n          \\\n          \\\n        sp[-1] = sp[0]; \\\n        --sp; \\\n    } \\\n} while (0)\n\n#if MICROPY_PY_SYS_SETTRACE\n\n#define FRAME_SETUP() do { \\\n    assert(code_state != code_state->prev_state); \\\n    MP_STATE_THREAD(current_code_state) = code_state; \\\n    assert(code_state != code_state->prev_state); \\\n} while(0)\n\n#define FRAME_ENTER() do { \\\n    assert(code_state != code_state->prev_state); \\\n    code_state->prev_state = MP_STATE_THREAD(current_code_state); \\\n    assert(code_state != code_state->prev_state); \\\n    if (!mp_prof_is_executing) { \\\n        mp_prof_frame_enter(code_state); \\\n    } \\\n} while(0)\n\n#define FRAME_LEAVE() do { \\\n    assert(code_state != code_state->prev_state); \\\n    MP_STATE_THREAD(current_code_state) = code_state->prev_state; \\\n    assert(code_state != code_state->prev_state); \\\n} while(0)\n\n#define FRAME_UPDATE() do { \\\n    assert(MP_STATE_THREAD(current_code_state) == code_state); \\\n    if (!mp_prof_is_executing) { \\\n        code_state->frame = MP_OBJ_TO_PTR(mp_prof_frame_update(code_state)); \\\n    } \\\n} while(0)\n\n#define TRACE_TICK(current_ip, current_sp, is_exception) do { \\\n    assert(code_state != code_state->prev_state); \\\n    assert(MP_STATE_THREAD(current_code_state) == code_state); \\\n    if (!mp_prof_is_executing && code_state->frame && MP_STATE_THREAD(prof_trace_callback)) { \\\n        MP_PROF_INSTR_DEBUG_PRINT(code_state->ip); \\\n    } \\\n    if (!mp_prof_is_executing && code_state->frame && code_state->frame->callback) { \\\n        mp_prof_instr_tick(code_state, is_exception); \\\n    } \\\n} while(0)\n\n#else \n#define FRAME_SETUP()\n#define FRAME_ENTER()\n#define FRAME_LEAVE()\n#define FRAME_UPDATE()\n#define TRACE_TICK(current_ip, current_sp, is_exception)\n#endif \n\n\n\n\n\n\n\nmp_vm_return_kind_t MICROPY_WRAP_MP_EXECUTE_BYTECODE(mp_execute_bytecode)(mp_code_state_t *code_state, volatile mp_obj_t inject_exc) {\n\n#define SELECTIVE_EXC_IP (0)\n\n\n\n\n\n\n\n\n\n#if SELECTIVE_EXC_IP\n\n\n#define MARK_EXC_IP_SELECTIVE() { code_state->ip = ip; }\n\n#define MARK_EXC_IP_GLOBAL()\n#else\n#define MARK_EXC_IP_SELECTIVE()\n\n\n#define MARK_EXC_IP_GLOBAL() { code_state->ip = ip; }\n#endif\n\n#if MICROPY_OPT_COMPUTED_GOTO\n    #include \"py/vmentrytable.h\"\n    #define DISPATCH() do { \\\n        TRACE(ip); \\\n        MARK_EXC_IP_GLOBAL(); \\\n        TRACE_TICK(ip, sp, false); \\\n        goto *entry_table[*ip++]; \\\n    } while (0)\n    #define DISPATCH_WITH_PEND_EXC_CHECK() goto pending_exception_check\n    #define ENTRY(op) entry_##op\n    #define ENTRY_DEFAULT entry_default\n#else\n    #define DISPATCH() goto dispatch_loop\n    #define DISPATCH_WITH_PEND_EXC_CHECK() goto pending_exception_check\n    #define ENTRY(op) case op\n    #define ENTRY_DEFAULT default\n#endif\n\n    \n    \n    \n    \n    #define RAISE(o) do { nlr_pop(); nlr.ret_val = MP_OBJ_TO_PTR(o); goto exception_handler; } while (0)\n\n#if MICROPY_STACKLESS\nrun_code_state: ;\n#endif\nFRAME_ENTER();\n\n#if MICROPY_STACKLESS\nrun_code_state_from_return: ;\n#endif\nFRAME_SETUP();\n\n    \n    mp_obj_t *   fastn;\n    mp_exc_stack_t *   exc_stack;\n    {\n        size_t n_state = code_state->n_state;\n        fastn = &code_state->state[n_state - 1];\n        exc_stack = (mp_exc_stack_t*)(code_state->state + n_state);\n    }\n\n    \n    mp_exc_stack_t *volatile exc_sp = MP_CODE_STATE_EXC_SP_IDX_TO_PTR(exc_stack, code_state->exc_sp_idx); \n\n    #if MICROPY_PY_THREAD_GIL && MICROPY_PY_THREAD_GIL_VM_DIVISOR\n    \n    \n    volatile int gil_divisor = MICROPY_PY_THREAD_GIL_VM_DIVISOR;\n    #endif\n\n    \n    for (;;) {\n        nlr_buf_t nlr;\nouter_dispatch_loop:\n        if (nlr_push(&nlr) == 0) {\n            \n            const byte *ip = code_state->ip;\n            mp_obj_t *sp = code_state->sp;\n            #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n            const qstr_short_t *qstr_table = code_state->fun_bc->context->constants.qstr_table;\n            #endif\n            mp_obj_t obj_shared;\n            MICROPY_VM_HOOK_INIT\n\n            \n            \n            \n            \n            \n            if (inject_exc != MP_OBJ_NULL && *ip != MP_BC_YIELD_FROM) {\n                mp_obj_t exc = inject_exc;\n                inject_exc = MP_OBJ_NULL;\n                exc = mp_make_raise_obj(exc);\n                RAISE(exc);\n            }\n\n            \n            for (;;) {\ndispatch_loop:\n                #if MICROPY_OPT_COMPUTED_GOTO\n                DISPATCH();\n                #else\n                TRACE(ip);\n                MARK_EXC_IP_GLOBAL();\n                TRACE_TICK(ip, sp, false);\n                switch (*ip++) {\n                #endif\n\n                ENTRY(MP_BC_LOAD_CONST_FALSE):\n                    PUSH(mp_const_false);\n                    DISPATCH();\n\n                ENTRY(MP_BC_LOAD_CONST_NONE):\n                    PUSH(mp_const_none);\n                    DISPATCH();\n\n                ENTRY(MP_BC_LOAD_CONST_TRUE):\n                    PUSH(mp_const_true);\n                    DISPATCH();\n\n                ENTRY(MP_BC_LOAD_CONST_SMALL_INT): {\n                    mp_uint_t num = 0;\n                    if ((ip[0] & 0x40) != 0) {\n                        \n                        num--;\n                    }\n                    do {\n                        num = (num << 7) | (*ip & 0x7f);\n                    } while ((*ip++ & 0x80) != 0);\n                    PUSH(MP_OBJ_NEW_SMALL_INT(num));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_CONST_STRING): {\n                    DECODE_QSTR;\n                    PUSH(MP_OBJ_NEW_QSTR(qst));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_CONST_OBJ): {\n                    DECODE_OBJ;\n                    PUSH(obj);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_NULL):\n                    PUSH(MP_OBJ_NULL);\n                    DISPATCH();\n\n                ENTRY(MP_BC_LOAD_FAST_N): {\n                    DECODE_UINT;\n                    obj_shared = fastn[-unum];\n                    load_check:\n                    if (obj_shared == MP_OBJ_NULL) {\n                        local_name_error: {\n                            MARK_EXC_IP_SELECTIVE();\n                            mp_obj_t obj = mp_obj_new_exception_msg(&mp_type_NameError, MP_ERROR_TEXT(\"local variable referenced before assignment\"));\n                            RAISE(obj);\n                        }\n                    }\n                    PUSH(obj_shared);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_DEREF): {\n                    DECODE_UINT;\n                    obj_shared = mp_obj_cell_get(fastn[-unum]);\n                    goto load_check;\n                }\n\n                ENTRY(MP_BC_LOAD_NAME): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    PUSH(mp_load_name(qst));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_GLOBAL): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    PUSH(mp_load_global(qst));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_ATTR): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_obj_t top = TOP();\n                    mp_obj_t obj;\n                    #if MICROPY_OPT_LOAD_ATTR_FAST_PATH\n                    \n                    \n                    \n                    \n                    mp_map_elem_t *elem = NULL;\n                    if (mp_obj_is_instance_type(mp_obj_get_type(top))) {\n                        mp_obj_instance_t *self = MP_OBJ_TO_PTR(top);\n                        elem = mp_map_lookup(&self->members, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);\n                    }\n                    if (elem) {\n                        obj = elem->value;\n                    } else\n                    #endif\n                    {\n                        obj = mp_load_attr(top, qst);\n                    }\n                    SET_TOP(obj);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_METHOD): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_load_method(*sp, qst, sp);\n                    sp += 1;\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_SUPER_METHOD): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    sp -= 1;\n                    mp_load_super_method(qst, sp - 1);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_LOAD_BUILD_CLASS):\n                    MARK_EXC_IP_SELECTIVE();\n                    PUSH(mp_load_build_class());\n                    DISPATCH();\n\n                ENTRY(MP_BC_LOAD_SUBSCR): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_t index = POP();\n                    SET_TOP(mp_obj_subscr(TOP(), index, MP_OBJ_SENTINEL));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_FAST_N): {\n                    DECODE_UINT;\n                    fastn[-unum] = POP();\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_DEREF): {\n                    DECODE_UINT;\n                    mp_obj_cell_set(fastn[-unum], POP());\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_NAME): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_store_name(qst, POP());\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_GLOBAL): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_store_global(qst, POP());\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_ATTR): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_store_attr(sp[0], qst, sp[-1]);\n                    sp -= 2;\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_SUBSCR):\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_subscr(sp[-1], sp[0], sp[-2]);\n                    sp -= 3;\n                    DISPATCH();\n\n                ENTRY(MP_BC_DELETE_FAST): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    if (fastn[-unum] == MP_OBJ_NULL) {\n                        goto local_name_error;\n                    }\n                    fastn[-unum] = MP_OBJ_NULL;\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_DELETE_DEREF): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    if (mp_obj_cell_get(fastn[-unum]) == MP_OBJ_NULL) {\n                        goto local_name_error;\n                    }\n                    mp_obj_cell_set(fastn[-unum], MP_OBJ_NULL);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_DELETE_NAME): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_delete_name(qst);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_DELETE_GLOBAL): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_delete_global(qst);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_DUP_TOP): {\n                    mp_obj_t top = TOP();\n                    PUSH(top);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_DUP_TOP_TWO):\n                    sp += 2;\n                    sp[0] = sp[-2];\n                    sp[-1] = sp[-3];\n                    DISPATCH();\n\n                ENTRY(MP_BC_POP_TOP):\n                    sp -= 1;\n                    DISPATCH();\n\n                ENTRY(MP_BC_ROT_TWO): {\n                    mp_obj_t top = sp[0];\n                    sp[0] = sp[-1];\n                    sp[-1] = top;\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_ROT_THREE): {\n                    mp_obj_t top = sp[0];\n                    sp[0] = sp[-1];\n                    sp[-1] = sp[-2];\n                    sp[-2] = top;\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_JUMP): {\n                    DECODE_SLABEL;\n                    ip += slab;\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_POP_JUMP_IF_TRUE): {\n                    DECODE_SLABEL;\n                    if (mp_obj_is_true(POP())) {\n                        ip += slab;\n                    }\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_POP_JUMP_IF_FALSE): {\n                    DECODE_SLABEL;\n                    if (!mp_obj_is_true(POP())) {\n                        ip += slab;\n                    }\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_JUMP_IF_TRUE_OR_POP): {\n                    DECODE_ULABEL;\n                    if (mp_obj_is_true(TOP())) {\n                        ip += ulab;\n                    } else {\n                        sp--;\n                    }\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_JUMP_IF_FALSE_OR_POP): {\n                    DECODE_ULABEL;\n                    if (mp_obj_is_true(TOP())) {\n                        sp--;\n                    } else {\n                        ip += ulab;\n                    }\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_SETUP_WITH): {\n                    MARK_EXC_IP_SELECTIVE();\n                    \n                    mp_obj_t obj = TOP();\n                    mp_load_method(obj, MP_QSTR___exit__, sp);\n                    mp_load_method(obj, MP_QSTR___enter__, sp + 2);\n                    mp_obj_t ret = mp_call_method_n_kw(0, 0, sp + 2);\n                    sp += 1;\n                    PUSH_EXC_BLOCK(1);\n                    PUSH(ret);\n                    \n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_WITH_CLEANUP): {\n                    MARK_EXC_IP_SELECTIVE();\n                    \n                    \n                    \n                    \n                    \n                    \n                    if (TOP() == mp_const_none) {\n                        \n                        sp[1] = mp_const_none;\n                        sp[2] = mp_const_none;\n                        sp -= 2;\n                        mp_call_method_n_kw(3, 0, sp);\n                        SET_TOP(mp_const_none);\n                    } else if (mp_obj_is_small_int(TOP())) {\n                        \n                        \n                        \n                        \n                        mp_obj_t data = sp[-1];\n                        mp_obj_t cause = sp[0];\n                        sp[-1] = mp_const_none;\n                        sp[0] = mp_const_none;\n                        sp[1] = mp_const_none;\n                        mp_call_method_n_kw(3, 0, sp - 3);\n                        sp[-3] = data;\n                        sp[-2] = cause;\n                        sp -= 2; \n                    } else {\n                        assert(mp_obj_is_exception_instance(TOP()));\n                        \n                        \n                        sp[1] = sp[0];\n                        sp[0] = MP_OBJ_FROM_PTR(mp_obj_get_type(sp[0]));\n                        sp[2] = mp_const_none;\n                        sp -= 2;\n                        mp_obj_t ret_value = mp_call_method_n_kw(3, 0, sp);\n                        if (mp_obj_is_true(ret_value)) {\n                            \n                            \n                            \n                            \n                            SET_TOP(mp_const_none);\n                        } else {\n                            \n                            \n                            sp[0] = sp[3];\n                        }\n                    }\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_UNWIND_JUMP): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_SLABEL;\n                    PUSH((mp_obj_t)(mp_uint_t)(uintptr_t)(ip + slab)); \n                    PUSH((mp_obj_t)(mp_uint_t)(*ip)); \nunwind_jump:;\n                    mp_uint_t unum = (mp_uint_t)POP(); \n                    while ((unum & 0x7f) > 0) {\n                        unum -= 1;\n                        assert(exc_sp >= exc_stack);\n\n                        if (MP_TAGPTR_TAG1(exc_sp->val_sp)) {\n                            if (exc_sp->handler >= ip) {\n                                \n                                \n                                \n                                \n                                \n                                assert(&sp[-1] == MP_TAGPTR_PTR(exc_sp->val_sp));\n                                \n                                \n                                \n                                \n                                \n                                \n                                PUSH(MP_OBJ_NEW_SMALL_INT(unum));\n                                ip = exc_sp->handler;\n                                goto dispatch_loop;\n                            } else {\n                                \n                                CANCEL_ACTIVE_FINALLY(sp);\n                            }\n                        }\n                        POP_EXC_BLOCK();\n                    }\n                    ip = (const byte*)MP_OBJ_TO_PTR(POP()); \n                    if (unum != 0) {\n                        \n                        sp -= MP_OBJ_ITER_BUF_NSLOTS;\n                    }\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_SETUP_EXCEPT):\n                ENTRY(MP_BC_SETUP_FINALLY): {\n                    MARK_EXC_IP_SELECTIVE();\n                    #if SELECTIVE_EXC_IP\n                    PUSH_EXC_BLOCK((code_state->ip[-1] == MP_BC_SETUP_FINALLY) ? 1 : 0);\n                    #else\n                    PUSH_EXC_BLOCK((code_state->ip[0] == MP_BC_SETUP_FINALLY) ? 1 : 0);\n                    #endif\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_END_FINALLY):\n                    MARK_EXC_IP_SELECTIVE();\n                    \n                    \n                    \n                    assert(exc_sp >= exc_stack);\n                    POP_EXC_BLOCK();\n                    if (TOP() == mp_const_none) {\n                        sp--;\n                    } else if (mp_obj_is_small_int(TOP())) {\n                        \n                        \n                        mp_int_t cause = MP_OBJ_SMALL_INT_VALUE(POP());\n                        if (cause < 0) {\n                            \n                            goto unwind_return;\n                        } else {\n                            \n                            \n                            PUSH((mp_obj_t)cause);\n                            goto unwind_jump;\n                        }\n                    } else {\n                        assert(mp_obj_is_exception_instance(TOP()));\n                        RAISE(TOP());\n                    }\n                    DISPATCH();\n\n                ENTRY(MP_BC_GET_ITER):\n                    MARK_EXC_IP_SELECTIVE();\n                    SET_TOP(mp_getiter(TOP(), NULL));\n                    DISPATCH();\n\n                \n                \n                \n                \n                ENTRY(MP_BC_GET_ITER_STACK): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_t obj = TOP();\n                    mp_obj_iter_buf_t *iter_buf = (mp_obj_iter_buf_t*)sp;\n                    sp += MP_OBJ_ITER_BUF_NSLOTS - 1;\n                    obj = mp_getiter(obj, iter_buf);\n                    if (obj != MP_OBJ_FROM_PTR(iter_buf)) {\n                        \n                        *(sp - MP_OBJ_ITER_BUF_NSLOTS + 1) = MP_OBJ_NULL;\n                        *(sp - MP_OBJ_ITER_BUF_NSLOTS + 2) = obj;\n                    }\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_FOR_ITER): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_ULABEL; \n                    code_state->sp = sp;\n                    mp_obj_t obj;\n                    if (*(sp - MP_OBJ_ITER_BUF_NSLOTS + 1) == MP_OBJ_NULL) {\n                        obj = *(sp - MP_OBJ_ITER_BUF_NSLOTS + 2);\n                    } else {\n                        obj = MP_OBJ_FROM_PTR(&sp[-MP_OBJ_ITER_BUF_NSLOTS + 1]);\n                    }\n                    mp_obj_t value = mp_iternext_allow_raise(obj);\n                    if (value == MP_OBJ_STOP_ITERATION) {\n                        sp -= MP_OBJ_ITER_BUF_NSLOTS; \n                        ip += ulab; \n                    } else {\n                        PUSH(value); \n                        #if MICROPY_PY_SYS_SETTRACE\n                        \n                        if (code_state->frame) {\n                            code_state->frame->lineno = 0;\n                        }\n                        #endif\n                    }\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_POP_EXCEPT_JUMP): {\n                    assert(exc_sp >= exc_stack);\n                    POP_EXC_BLOCK();\n                    DECODE_ULABEL;\n                    ip += ulab;\n                    DISPATCH_WITH_PEND_EXC_CHECK();\n                }\n\n                ENTRY(MP_BC_BUILD_TUPLE): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    sp -= unum - 1;\n                    SET_TOP(mp_obj_new_tuple(unum, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_BUILD_LIST): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    sp -= unum - 1;\n                    SET_TOP(mp_obj_new_list(unum, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_BUILD_MAP): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    PUSH(mp_obj_new_dict(unum));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_STORE_MAP):\n                    MARK_EXC_IP_SELECTIVE();\n                    sp -= 2;\n                    mp_obj_dict_store(sp[0], sp[2], sp[1]);\n                    DISPATCH();\n\n                #if MICROPY_PY_BUILTINS_SET\n                ENTRY(MP_BC_BUILD_SET): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    sp -= unum - 1;\n                    SET_TOP(mp_obj_new_set(unum, sp));\n                    DISPATCH();\n                }\n                #endif\n\n                #if MICROPY_PY_BUILTINS_SLICE\n                ENTRY(MP_BC_BUILD_SLICE): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_t step = mp_const_none;\n                    if (*ip++ == 3) {\n                        \n                        step = POP();\n                    }\n                    mp_obj_t stop = POP();\n                    mp_obj_t start = TOP();\n                    SET_TOP(mp_obj_new_slice(start, stop, step));\n                    DISPATCH();\n                }\n                #endif\n\n                ENTRY(MP_BC_STORE_COMP): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    mp_obj_t obj = sp[-(unum >> 2)];\n                    if ((unum & 3) == 0) {\n                        mp_obj_list_append(obj, sp[0]);\n                        sp--;\n                    } else if (!MICROPY_PY_BUILTINS_SET || (unum & 3) == 1) {\n                        mp_obj_dict_store(obj, sp[0], sp[-1]);\n                        sp -= 2;\n                    #if MICROPY_PY_BUILTINS_SET\n                    } else {\n                        mp_obj_set_store(obj, sp[0]);\n                        sp--;\n                    #endif\n                    }\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_UNPACK_SEQUENCE): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    mp_unpack_sequence(sp[0], unum, sp);\n                    sp += unum - 1;\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_UNPACK_EX): {\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    mp_unpack_ex(sp[0], unum, sp);\n                    sp += (unum & 0xff) + ((unum >> 8) & 0xff);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_MAKE_FUNCTION): {\n                    DECODE_PTR;\n                    PUSH(mp_make_function_from_proto_fun(ptr, code_state->fun_bc->context, NULL));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_MAKE_FUNCTION_DEFARGS): {\n                    DECODE_PTR;\n                    \n                    sp -= 1;\n                    SET_TOP(mp_make_function_from_proto_fun(ptr, code_state->fun_bc->context, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_MAKE_CLOSURE): {\n                    DECODE_PTR;\n                    size_t n_closed_over = *ip++;\n                    \n                    sp -= n_closed_over - 1;\n                    SET_TOP(mp_make_closure_from_proto_fun(ptr, code_state->fun_bc->context, n_closed_over, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_MAKE_CLOSURE_DEFARGS): {\n                    DECODE_PTR;\n                    size_t n_closed_over = *ip++;\n                    \n                    sp -= 2 + n_closed_over - 1;\n                    SET_TOP(mp_make_closure_from_proto_fun(ptr, code_state->fun_bc->context, 0x100 | n_closed_over, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_CALL_FUNCTION): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    \n                    \n                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe);\n                    #if MICROPY_STACKLESS\n                    if (mp_obj_get_type(*sp) == &mp_type_fun_bc) {\n                        code_state->ip = ip;\n                        code_state->sp = sp;\n                        code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);\n                        mp_code_state_t *new_state = mp_obj_fun_bc_prepare_codestate(*sp, unum & 0xff, (unum >> 8) & 0xff, sp + 1);\n                        #if !MICROPY_ENABLE_PYSTACK\n                        if (new_state == NULL) {\n                            \n                            \n                            #if MICROPY_STACKLESS_STRICT\n                        deep_recursion_error:\n                            mp_raise_recursion_depth();\n                            #endif\n                        } else\n                        #endif\n                        {\n                            new_state->prev = code_state;\n                            code_state = new_state;\n                            nlr_pop();\n                            goto run_code_state;\n                        }\n                    }\n                    #endif\n                    SET_TOP(mp_call_function_n_kw(*sp, unum & 0xff, (unum >> 8) & 0xff, sp + 1));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_CALL_FUNCTION_VAR_KW): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    \n                    \n                    \n                    \n                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe) + 1;\n                    #if MICROPY_STACKLESS\n                    if (mp_obj_get_type(*sp) == &mp_type_fun_bc) {\n                        code_state->ip = ip;\n                        code_state->sp = sp;\n                        code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);\n\n                        mp_call_args_t out_args;\n                        mp_call_prepare_args_n_kw_var(false, unum, sp, &out_args);\n\n                        mp_code_state_t *new_state = mp_obj_fun_bc_prepare_codestate(out_args.fun,\n                            out_args.n_args, out_args.n_kw, out_args.args);\n                        #if !MICROPY_ENABLE_PYSTACK\n                        \n                        \n                        mp_nonlocal_free(out_args.args, out_args.n_alloc * sizeof(mp_obj_t));\n                        #endif\n                        #if !MICROPY_ENABLE_PYSTACK\n                        if (new_state == NULL) {\n                            \n                            \n                            #if MICROPY_STACKLESS_STRICT\n                            goto deep_recursion_error;\n                            #endif\n                        } else\n                        #endif\n                        {\n                            new_state->prev = code_state;\n                            code_state = new_state;\n                            nlr_pop();\n                            goto run_code_state;\n                        }\n                    }\n                    #endif\n                    SET_TOP(mp_call_method_n_kw_var(false, unum, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_CALL_METHOD): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    \n                    \n                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe) + 1;\n                    #if MICROPY_STACKLESS\n                    if (mp_obj_get_type(*sp) == &mp_type_fun_bc) {\n                        code_state->ip = ip;\n                        code_state->sp = sp;\n                        code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);\n\n                        size_t n_args = unum & 0xff;\n                        size_t n_kw = (unum >> 8) & 0xff;\n                        int adjust = (sp[1] == MP_OBJ_NULL) ? 0 : 1;\n\n                        mp_code_state_t *new_state = mp_obj_fun_bc_prepare_codestate(*sp, n_args + adjust, n_kw, sp + 2 - adjust);\n                        #if !MICROPY_ENABLE_PYSTACK\n                        if (new_state == NULL) {\n                            \n                            \n                            #if MICROPY_STACKLESS_STRICT\n                            goto deep_recursion_error;\n                            #endif\n                        } else\n                        #endif\n                        {\n                            new_state->prev = code_state;\n                            code_state = new_state;\n                            nlr_pop();\n                            goto run_code_state;\n                        }\n                    }\n                    #endif\n                    SET_TOP(mp_call_method_n_kw(unum & 0xff, (unum >> 8) & 0xff, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_CALL_METHOD_VAR_KW): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_UINT;\n                    \n                    \n                    \n                    \n                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe) + 2;\n                    #if MICROPY_STACKLESS\n                    if (mp_obj_get_type(*sp) == &mp_type_fun_bc) {\n                        code_state->ip = ip;\n                        code_state->sp = sp;\n                        code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);\n\n                        mp_call_args_t out_args;\n                        mp_call_prepare_args_n_kw_var(true, unum, sp, &out_args);\n\n                        mp_code_state_t *new_state = mp_obj_fun_bc_prepare_codestate(out_args.fun,\n                            out_args.n_args, out_args.n_kw, out_args.args);\n                        #if !MICROPY_ENABLE_PYSTACK\n                        \n                        \n                        mp_nonlocal_free(out_args.args, out_args.n_alloc * sizeof(mp_obj_t));\n                        #endif\n                        #if !MICROPY_ENABLE_PYSTACK\n                        if (new_state == NULL) {\n                            \n                            \n                            #if MICROPY_STACKLESS_STRICT\n                            goto deep_recursion_error;\n                            #endif\n                        } else\n                        #endif\n                        {\n                            new_state->prev = code_state;\n                            code_state = new_state;\n                            nlr_pop();\n                            goto run_code_state;\n                        }\n                    }\n                    #endif\n                    SET_TOP(mp_call_method_n_kw_var(true, unum, sp));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_RETURN_VALUE):\n                    MARK_EXC_IP_SELECTIVE();\nunwind_return:\n                    \n                    while (exc_sp >= exc_stack) {\n                        if (MP_TAGPTR_TAG1(exc_sp->val_sp)) {\n                            if (exc_sp->handler >= ip) {\n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                \n                                mp_obj_t *finally_sp = MP_TAGPTR_PTR(exc_sp->val_sp);\n                                finally_sp[1] = sp[0];\n                                sp = &finally_sp[1];\n                                \n                                \n                                \n                                \n                                PUSH(MP_OBJ_NEW_SMALL_INT(-1));\n                                ip = exc_sp->handler;\n                                goto dispatch_loop;\n                            } else {\n                                \n                                CANCEL_ACTIVE_FINALLY(sp);\n                            }\n                        }\n                        POP_EXC_BLOCK();\n                    }\n                    nlr_pop();\n                    code_state->sp = sp;\n                    assert(exc_sp == exc_stack - 1);\n                    MICROPY_VM_HOOK_RETURN\n                    #if MICROPY_STACKLESS\n                    if (code_state->prev != NULL) {\n                        mp_obj_t res = *sp;\n                        mp_globals_set(code_state->old_globals);\n                        mp_code_state_t *new_code_state = code_state->prev;\n                        #if MICROPY_ENABLE_PYSTACK\n                        \n                        \n                        \n                        \n                        mp_nonlocal_free(code_state, sizeof(mp_code_state_t));\n                        #endif\n                        code_state = new_code_state;\n                        *code_state->sp = res;\n                        goto run_code_state_from_return;\n                    }\n                    #endif\n                    FRAME_LEAVE();\n                    return MP_VM_RETURN_NORMAL;\n\n                ENTRY(MP_BC_RAISE_LAST): {\n                    MARK_EXC_IP_SELECTIVE();\n                    \n                    mp_obj_t obj = MP_OBJ_NULL;\n                    for (mp_exc_stack_t *e = exc_sp; e >= exc_stack; --e) {\n                        if (e->prev_exc != NULL) {\n                            obj = MP_OBJ_FROM_PTR(e->prev_exc);\n                            break;\n                        }\n                    }\n                    if (obj == MP_OBJ_NULL) {\n                        obj = mp_obj_new_exception_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"no active exception to reraise\"));\n                    }\n                    RAISE(obj);\n                }\n\n                ENTRY(MP_BC_RAISE_OBJ): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_t obj = mp_make_raise_obj(TOP());\n                    RAISE(obj);\n                }\n\n                ENTRY(MP_BC_RAISE_FROM): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_t from_value = POP();\n                    if (from_value != mp_const_none) {\n                        mp_warning(NULL, \"exception chaining not supported\");\n                    }\n                    mp_obj_t obj = mp_make_raise_obj(TOP());\n                    RAISE(obj);\n                }\n\n                ENTRY(MP_BC_YIELD_VALUE):\nyield:\n                    nlr_pop();\n                    code_state->ip = ip;\n                    code_state->sp = sp;\n                    code_state->exc_sp_idx = MP_CODE_STATE_EXC_SP_IDX_FROM_PTR(exc_stack, exc_sp);\n                    FRAME_LEAVE();\n                    return MP_VM_RETURN_YIELD;\n\n                ENTRY(MP_BC_YIELD_FROM): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_vm_return_kind_t ret_kind;\n                    mp_obj_t send_value = POP();\n                    mp_obj_t t_exc = MP_OBJ_NULL;\n                    mp_obj_t ret_value;\n                    code_state->sp = sp; \n                    if (inject_exc != MP_OBJ_NULL) {\n                        t_exc = inject_exc;\n                        inject_exc = MP_OBJ_NULL;\n                        ret_kind = mp_resume(TOP(), MP_OBJ_NULL, t_exc, &ret_value);\n                    } else {\n                        ret_kind = mp_resume(TOP(), send_value, MP_OBJ_NULL, &ret_value);\n                    }\n\n                    if (ret_kind == MP_VM_RETURN_YIELD) {\n                        ip--;\n                        PUSH(ret_value);\n                        goto yield;\n                    } else if (ret_kind == MP_VM_RETURN_NORMAL) {\n                        \n                        \n                        SET_TOP(ret_value);\n                        \n                        \n                        if (t_exc != MP_OBJ_NULL && mp_obj_exception_match(t_exc, MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {\n                            mp_obj_t raise_t = mp_make_raise_obj(t_exc);\n                            RAISE(raise_t);\n                        }\n                        DISPATCH();\n                    } else {\n                        assert(ret_kind == MP_VM_RETURN_EXCEPTION);\n                        assert(!mp_obj_exception_match(ret_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration)));\n                        \n                        sp--;\n                        RAISE(ret_value);\n                    }\n                }\n\n                ENTRY(MP_BC_IMPORT_NAME): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_obj_t obj = POP();\n                    SET_TOP(mp_import_name(qst, obj, TOP()));\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_IMPORT_FROM): {\n                    FRAME_UPDATE();\n                    MARK_EXC_IP_SELECTIVE();\n                    DECODE_QSTR;\n                    mp_obj_t obj = mp_import_from(TOP(), qst);\n                    PUSH(obj);\n                    DISPATCH();\n                }\n\n                ENTRY(MP_BC_IMPORT_STAR):\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_import_all(POP());\n                    DISPATCH();\n\n                #if MICROPY_OPT_COMPUTED_GOTO\n                ENTRY(MP_BC_LOAD_CONST_SMALL_INT_MULTI):\n                    PUSH(MP_OBJ_NEW_SMALL_INT((mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS));\n                    DISPATCH();\n\n                ENTRY(MP_BC_LOAD_FAST_MULTI):\n                    obj_shared = fastn[MP_BC_LOAD_FAST_MULTI - (mp_int_t)ip[-1]];\n                    goto load_check;\n\n                ENTRY(MP_BC_STORE_FAST_MULTI):\n                    fastn[MP_BC_STORE_FAST_MULTI - (mp_int_t)ip[-1]] = POP();\n                    DISPATCH();\n\n                ENTRY(MP_BC_UNARY_OP_MULTI):\n                    MARK_EXC_IP_SELECTIVE();\n                    SET_TOP(mp_unary_op(ip[-1] - MP_BC_UNARY_OP_MULTI, TOP()));\n                    DISPATCH();\n\n                ENTRY(MP_BC_BINARY_OP_MULTI): {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_obj_t rhs = POP();\n                    mp_obj_t lhs = TOP();\n                    SET_TOP(mp_binary_op(ip[-1] - MP_BC_BINARY_OP_MULTI, lhs, rhs));\n                    DISPATCH();\n                }\n\n                ENTRY_DEFAULT:\n                    MARK_EXC_IP_SELECTIVE();\n                #else\n                ENTRY_DEFAULT:\n                    if (ip[-1] < MP_BC_LOAD_CONST_SMALL_INT_MULTI + MP_BC_LOAD_CONST_SMALL_INT_MULTI_NUM) {\n                        PUSH(MP_OBJ_NEW_SMALL_INT((mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS));\n                        DISPATCH();\n                    } else if (ip[-1] < MP_BC_LOAD_FAST_MULTI + MP_BC_LOAD_FAST_MULTI_NUM) {\n                        obj_shared = fastn[MP_BC_LOAD_FAST_MULTI - (mp_int_t)ip[-1]];\n                        goto load_check;\n                    } else if (ip[-1] < MP_BC_STORE_FAST_MULTI + MP_BC_STORE_FAST_MULTI_NUM) {\n                        fastn[MP_BC_STORE_FAST_MULTI - (mp_int_t)ip[-1]] = POP();\n                        DISPATCH();\n                    } else if (ip[-1] < MP_BC_UNARY_OP_MULTI + MP_BC_UNARY_OP_MULTI_NUM) {\n                        SET_TOP(mp_unary_op(ip[-1] - MP_BC_UNARY_OP_MULTI, TOP()));\n                        DISPATCH();\n                    } else if (ip[-1] < MP_BC_BINARY_OP_MULTI + MP_BC_BINARY_OP_MULTI_NUM) {\n                        mp_obj_t rhs = POP();\n                        mp_obj_t lhs = TOP();\n                        SET_TOP(mp_binary_op(ip[-1] - MP_BC_BINARY_OP_MULTI, lhs, rhs));\n                        DISPATCH();\n                    } else\n                #endif \n                {\n                    mp_obj_t obj = mp_obj_new_exception_msg(&mp_type_NotImplementedError, MP_ERROR_TEXT(\"opcode\"));\n                    nlr_pop();\n                    code_state->state[0] = obj;\n                    FRAME_LEAVE();\n                    return MP_VM_RETURN_EXCEPTION;\n                }\n\n                #if !MICROPY_OPT_COMPUTED_GOTO\n                } \n                #endif\n\npending_exception_check:\n                \n                \n                \n                \n                MICROPY_VM_HOOK_LOOP\n\n                \n                \n                \n                \n                if (\n                #if MICROPY_ENABLE_SCHEDULER\n                #if MICROPY_PY_THREAD\n                    \n                    MP_STATE_VM(sched_state) == MP_SCHED_PENDING || MP_STATE_THREAD(mp_pending_exception) != MP_OBJ_NULL\n                #else\n                    \n                    MP_STATE_VM(sched_state) == MP_SCHED_PENDING\n                #endif\n                #else\n                    \n                    MP_STATE_THREAD(mp_pending_exception) != MP_OBJ_NULL\n                #endif\n                #if MICROPY_ENABLE_VM_ABORT\n                    \n                    || MP_STATE_VM(vm_abort)\n                #endif\n                ) {\n                    MARK_EXC_IP_SELECTIVE();\n                    mp_handle_pending(true);\n                }\n\n                #if MICROPY_PY_THREAD_GIL\n                #if MICROPY_PY_THREAD_GIL_VM_DIVISOR\n                \n                if (--gil_divisor == 0)\n                #endif\n                {\n                    #if MICROPY_PY_THREAD_GIL_VM_DIVISOR\n                    gil_divisor = MICROPY_PY_THREAD_GIL_VM_DIVISOR;\n                    #endif\n                    #if MICROPY_ENABLE_SCHEDULER\n                    \n                    if (MP_STATE_VM(sched_state) == MP_SCHED_IDLE)\n                    #endif\n                    {\n                    MP_THREAD_GIL_EXIT();\n                    MP_THREAD_GIL_ENTER();\n                    }\n                }\n                #endif\n\n            } \n\n        } else {\nexception_handler:\n            \n\n            #if MICROPY_PY_SYS_EXC_INFO\n            MP_STATE_VM(cur_exception) = nlr.ret_val;\n            #endif\n\n            #if SELECTIVE_EXC_IP\n            \n            code_state->ip -= 1;\n            #endif\n\n            if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t*)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {\n                \n                if (*code_state->ip == MP_BC_FOR_ITER) {\n                    const byte *ip = code_state->ip + 1;\n                    DECODE_ULABEL; \n                    code_state->ip = ip + ulab; \n                    code_state->sp -= MP_OBJ_ITER_BUF_NSLOTS; \n                    goto outer_dispatch_loop; \n                } else if (*code_state->ip == MP_BC_YIELD_FROM) {\n                    \n                    \n                    \n                    *code_state->sp = mp_obj_exception_get_value(MP_OBJ_FROM_PTR(nlr.ret_val));\n                    code_state->ip++; \n                    goto outer_dispatch_loop; \n                }\n            }\n\n            #if MICROPY_PY_SYS_SETTRACE\n            \n            if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t*)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_Exception))) {\n                TRACE_TICK(code_state->ip, code_state->sp, true  );\n            }\n            #endif\n\n#if MICROPY_STACKLESS\nunwind_loop:\n#endif\n             \n             \n            \n            \n            if (nlr.ret_val != &mp_const_GeneratorExit_obj\n                && *code_state->ip != MP_BC_END_FINALLY\n                && *code_state->ip != MP_BC_RAISE_LAST) {\n                const byte *ip = code_state->fun_bc->bytecode;\n                MP_BC_PRELUDE_SIG_DECODE(ip);\n                MP_BC_PRELUDE_SIZE_DECODE(ip);\n                const byte *line_info_top = ip + n_info;\n                const byte *bytecode_start = ip + n_info + n_cell;\n                size_t bc = code_state->ip - bytecode_start;\n                qstr block_name = mp_decode_uint_value(ip);\n                for (size_t i = 0; i < 1 + n_pos_args + n_kwonly_args; ++i) {\n                    ip = mp_decode_uint_skip(ip);\n                }\n                #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n                block_name = code_state->fun_bc->context->constants.qstr_table[block_name];\n                qstr source_file = code_state->fun_bc->context->constants.qstr_table[0];\n                #else\n                qstr source_file = code_state->fun_bc->context->constants.source_file;\n                #endif\n                size_t source_line = mp_bytecode_get_source_line(ip, line_info_top, bc);\n                mp_obj_exception_add_traceback(MP_OBJ_FROM_PTR(nlr.ret_val), source_file, source_line, block_name);\n            }\n\n            while (exc_sp >= exc_stack && exc_sp->handler <= code_state->ip) {\n\n                \n\n                assert(exc_sp >= exc_stack);\n\n                \n                \n\n                \n                POP_EXC_BLOCK();\n            }\n\n            if (exc_sp >= exc_stack) {\n                \n                code_state->ip = exc_sp->handler;\n                mp_obj_t *sp = MP_TAGPTR_PTR(exc_sp->val_sp);\n                \n                exc_sp->prev_exc = nlr.ret_val;\n                \n                PUSH(MP_OBJ_FROM_PTR(nlr.ret_val));\n                code_state->sp = sp;\n\n            #if MICROPY_STACKLESS\n            } else if (code_state->prev != NULL) {\n                mp_globals_set(code_state->old_globals);\n                mp_code_state_t *new_code_state = code_state->prev;\n                #if MICROPY_ENABLE_PYSTACK\n                \n                \n                \n                \n                mp_nonlocal_free(code_state, sizeof(mp_code_state_t));\n                #endif\n                code_state = new_code_state;\n                size_t n_state = code_state->n_state;\n                fastn = &code_state->state[n_state - 1];\n                exc_stack = (mp_exc_stack_t*)(code_state->state + n_state);\n                \n                exc_sp = MP_CODE_STATE_EXC_SP_IDX_TO_PTR(exc_stack, code_state->exc_sp_idx); \n                goto unwind_loop;\n\n            #endif\n            } else {\n                \n                \n                code_state->state[0] = MP_OBJ_FROM_PTR(nlr.ret_val); \n                FRAME_LEAVE();\n                return MP_VM_RETURN_EXCEPTION;\n            }\n        }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}