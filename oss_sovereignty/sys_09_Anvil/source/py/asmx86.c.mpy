{
  "module_name": "asmx86.c",
  "hash_id": "8fa4658688523947dafeb9b10b18f93da35d3062e7e08cf8567e806523248abd",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/asmx86.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\n#include \"py/mpconfig.h\"\n\n\n#if MICROPY_EMIT_X86\n\n#include \"py/asmx86.h\"\n\n \n#define WORD_SIZE                (4)\n\n#define OPCODE_NOP               (0x90)\n#define OPCODE_PUSH_R32          (0x50)\n\n\n#define OPCODE_POP_R32           (0x58)\n#define OPCODE_RET               (0xc3)\n\n#define OPCODE_MOV_I32_TO_R32    (0xb8)\n\n#define OPCODE_MOV_R8_TO_RM8     (0x88)  \n#define OPCODE_MOV_R32_TO_RM32   (0x89)  \n#define OPCODE_MOV_RM32_TO_R32   (0x8b)  \n#define OPCODE_MOVZX_RM8_TO_R32  (0xb6)  \n#define OPCODE_MOVZX_RM16_TO_R32 (0xb7)  \n#define OPCODE_LEA_MEM_TO_R32    (0x8d)  \n#define OPCODE_NOT_RM32          (0xf7)  \n#define OPCODE_NEG_RM32          (0xf7)  \n#define OPCODE_AND_R32_TO_RM32   (0x21)  \n#define OPCODE_OR_R32_TO_RM32    (0x09)  \n#define OPCODE_XOR_R32_TO_RM32   (0x31)  \n#define OPCODE_ADD_R32_TO_RM32   (0x01)\n#define OPCODE_ADD_I32_TO_RM32   (0x81)  \n#define OPCODE_ADD_I8_TO_RM32    (0x83)  \n#define OPCODE_SUB_R32_FROM_RM32 (0x29)\n#define OPCODE_SUB_I32_FROM_RM32 (0x81)  \n#define OPCODE_SUB_I8_FROM_RM32  (0x83)  \n\n\n\n#define OPCODE_SHL_RM32_CL       (0xd3)  \n#define OPCODE_SHR_RM32_CL       (0xd3)  \n#define OPCODE_SAR_RM32_CL       (0xd3)  \n\n\n#define OPCODE_CMP_R32_WITH_RM32 (0x39)\n\n#define OPCODE_TEST_R8_WITH_RM8  (0x84)  \n#define OPCODE_TEST_R32_WITH_RM32 (0x85)  \n#define OPCODE_JMP_REL8          (0xeb)\n#define OPCODE_JMP_REL32         (0xe9)\n#define OPCODE_JMP_RM32          (0xff)  \n#define OPCODE_JCC_REL8          (0x70)  \n#define OPCODE_JCC_REL32_A       (0x0f)\n#define OPCODE_JCC_REL32_B       (0x80)  \n#define OPCODE_SETCC_RM8_A       (0x0f)\n#define OPCODE_SETCC_RM8_B       (0x90)  \n#define OPCODE_CALL_REL32        (0xe8)\n#define OPCODE_CALL_RM32         (0xff)  \n#define OPCODE_LEAVE             (0xc9)\n\n#define MODRM_R32(x)    ((x) << 3)\n#define MODRM_RM_DISP0  (0x00)\n#define MODRM_RM_DISP8  (0x40)\n#define MODRM_RM_DISP32 (0x80)\n#define MODRM_RM_REG    (0xc0)\n#define MODRM_RM_R32(x) (x)\n\n#define OP_SIZE_PREFIX (0x66)\n\n#define IMM32_L0(x) ((x) & 0xff)\n#define IMM32_L1(x) (((x) >> 8) & 0xff)\n#define IMM32_L2(x) (((x) >> 16) & 0xff)\n#define IMM32_L3(x) (((x) >> 24) & 0xff)\n\n#define SIGNED_FIT8(x) (((x) & 0xffffff80) == 0) || (((x) & 0xffffff80) == 0xffffff80)\n\nstatic void asm_x86_write_byte_1(asm_x86_t *as, byte b1) {\n    byte *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 1);\n    if (c != NULL) {\n        c[0] = b1;\n    }\n}\n\nstatic void asm_x86_write_byte_2(asm_x86_t *as, byte b1, byte b2) {\n    byte *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 2);\n    if (c != NULL) {\n        c[0] = b1;\n        c[1] = b2;\n    }\n}\n\nstatic void asm_x86_write_byte_3(asm_x86_t *as, byte b1, byte b2, byte b3) {\n    byte *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 3);\n    if (c != NULL) {\n        c[0] = b1;\n        c[1] = b2;\n        c[2] = b3;\n    }\n}\n\nstatic void asm_x86_write_word32(asm_x86_t *as, int w32) {\n    byte *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 4);\n    if (c != NULL) {\n        c[0] = IMM32_L0(w32);\n        c[1] = IMM32_L1(w32);\n        c[2] = IMM32_L2(w32);\n        c[3] = IMM32_L3(w32);\n    }\n}\n\nstatic void asm_x86_write_r32_disp(asm_x86_t *as, int r32, int disp_r32, int disp_offset) {\n    uint8_t rm_disp;\n    if (disp_offset == 0 && disp_r32 != ASM_X86_REG_EBP) {\n        rm_disp = MODRM_RM_DISP0;\n    } else if (SIGNED_FIT8(disp_offset)) {\n        rm_disp = MODRM_RM_DISP8;\n    } else {\n        rm_disp = MODRM_RM_DISP32;\n    }\n    asm_x86_write_byte_1(as, MODRM_R32(r32) | rm_disp | MODRM_RM_R32(disp_r32));\n    if (disp_r32 == ASM_X86_REG_ESP) {\n        \n        asm_x86_write_byte_1(as, 0x24);\n    }\n    if (rm_disp == MODRM_RM_DISP8) {\n        asm_x86_write_byte_1(as, IMM32_L0(disp_offset));\n    } else if (rm_disp == MODRM_RM_DISP32) {\n        asm_x86_write_word32(as, disp_offset);\n    }\n}\n\nstatic void asm_x86_generic_r32_r32(asm_x86_t *as, int dest_r32, int src_r32, int op) {\n    asm_x86_write_byte_2(as, op, MODRM_R32(src_r32) | MODRM_RM_REG | MODRM_RM_R32(dest_r32));\n}\n\n#if 0\nstatic void asm_x86_nop(asm_x86_t *as) {\n    asm_x86_write_byte_1(as, OPCODE_NOP);\n}\n#endif\n\nstatic void asm_x86_push_r32(asm_x86_t *as, int src_r32) {\n    asm_x86_write_byte_1(as, OPCODE_PUSH_R32 | src_r32);\n}\n\n#if 0\nvoid asm_x86_push_i32(asm_x86_t *as, int src_i32) {\n    asm_x86_write_byte_1(as, OPCODE_PUSH_I32);\n    asm_x86_write_word32(as, src_i32);\n}\n\nvoid asm_x86_push_disp(asm_x86_t *as, int src_r32, int src_offset) {\n    asm_x86_write_byte_1(as, OPCODE_PUSH_M32);\n    asm_x86_write_r32_disp(as, 6, src_r32, src_offset);\n}\n#endif\n\nstatic void asm_x86_pop_r32(asm_x86_t *as, int dest_r32) {\n    asm_x86_write_byte_1(as, OPCODE_POP_R32 | dest_r32);\n}\n\nstatic void asm_x86_ret(asm_x86_t *as) {\n    asm_x86_write_byte_1(as, OPCODE_RET);\n}\n\nvoid asm_x86_mov_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, src_r32, OPCODE_MOV_R32_TO_RM32);\n}\n\nvoid asm_x86_mov_r8_to_mem8(asm_x86_t *as, int src_r32, int dest_r32, int dest_disp) {\n    asm_x86_write_byte_1(as, OPCODE_MOV_R8_TO_RM8);\n    asm_x86_write_r32_disp(as, src_r32, dest_r32, dest_disp);\n}\n\nvoid asm_x86_mov_r16_to_mem16(asm_x86_t *as, int src_r32, int dest_r32, int dest_disp) {\n    asm_x86_write_byte_2(as, OP_SIZE_PREFIX, OPCODE_MOV_R32_TO_RM32);\n    asm_x86_write_r32_disp(as, src_r32, dest_r32, dest_disp);\n}\n\nvoid asm_x86_mov_r32_to_mem32(asm_x86_t *as, int src_r32, int dest_r32, int dest_disp) {\n    asm_x86_write_byte_1(as, OPCODE_MOV_R32_TO_RM32);\n    asm_x86_write_r32_disp(as, src_r32, dest_r32, dest_disp);\n}\n\nvoid asm_x86_mov_mem8_to_r32zx(asm_x86_t *as, int src_r32, int src_disp, int dest_r32) {\n    asm_x86_write_byte_2(as, 0x0f, OPCODE_MOVZX_RM8_TO_R32);\n    asm_x86_write_r32_disp(as, dest_r32, src_r32, src_disp);\n}\n\nvoid asm_x86_mov_mem16_to_r32zx(asm_x86_t *as, int src_r32, int src_disp, int dest_r32) {\n    asm_x86_write_byte_2(as, 0x0f, OPCODE_MOVZX_RM16_TO_R32);\n    asm_x86_write_r32_disp(as, dest_r32, src_r32, src_disp);\n}\n\nvoid asm_x86_mov_mem32_to_r32(asm_x86_t *as, int src_r32, int src_disp, int dest_r32) {\n    asm_x86_write_byte_1(as, OPCODE_MOV_RM32_TO_R32);\n    asm_x86_write_r32_disp(as, dest_r32, src_r32, src_disp);\n}\n\nstatic void asm_x86_lea_disp_to_r32(asm_x86_t *as, int src_r32, int src_disp, int dest_r32) {\n    asm_x86_write_byte_1(as, OPCODE_LEA_MEM_TO_R32);\n    asm_x86_write_r32_disp(as, dest_r32, src_r32, src_disp);\n}\n\n#if 0\nvoid asm_x86_mov_i8_to_r8(asm_x86_t *as, int src_i8, int dest_r32) {\n    asm_x86_write_byte_2(as, OPCODE_MOV_I8_TO_R8 | dest_r32, src_i8);\n}\n#endif\n\nsize_t asm_x86_mov_i32_to_r32(asm_x86_t *as, int32_t src_i32, int dest_r32) {\n    asm_x86_write_byte_1(as, OPCODE_MOV_I32_TO_R32 | dest_r32);\n    size_t loc = mp_asm_base_get_code_pos(&as->base);\n    asm_x86_write_word32(as, src_i32);\n    return loc;\n}\n\nvoid asm_x86_not_r32(asm_x86_t *as, int dest_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, 2, OPCODE_NOT_RM32);\n}\n\nvoid asm_x86_neg_r32(asm_x86_t *as, int dest_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, 3, OPCODE_NEG_RM32);\n}\n\nvoid asm_x86_and_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, src_r32, OPCODE_AND_R32_TO_RM32);\n}\n\nvoid asm_x86_or_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, src_r32, OPCODE_OR_R32_TO_RM32);\n}\n\nvoid asm_x86_xor_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, src_r32, OPCODE_XOR_R32_TO_RM32);\n}\n\nvoid asm_x86_shl_r32_cl(asm_x86_t *as, int dest_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, 4, OPCODE_SHL_RM32_CL);\n}\n\nvoid asm_x86_shr_r32_cl(asm_x86_t *as, int dest_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, 5, OPCODE_SHR_RM32_CL);\n}\n\nvoid asm_x86_sar_r32_cl(asm_x86_t *as, int dest_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, 7, OPCODE_SAR_RM32_CL);\n}\n\nvoid asm_x86_add_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, src_r32, OPCODE_ADD_R32_TO_RM32);\n}\n\nstatic void asm_x86_add_i32_to_r32(asm_x86_t *as, int src_i32, int dest_r32) {\n    if (SIGNED_FIT8(src_i32)) {\n        asm_x86_write_byte_2(as, OPCODE_ADD_I8_TO_RM32, MODRM_R32(0) | MODRM_RM_REG | MODRM_RM_R32(dest_r32));\n        asm_x86_write_byte_1(as, src_i32 & 0xff);\n    } else {\n        asm_x86_write_byte_2(as, OPCODE_ADD_I32_TO_RM32, MODRM_R32(0) | MODRM_RM_REG | MODRM_RM_R32(dest_r32));\n        asm_x86_write_word32(as, src_i32);\n    }\n}\n\nvoid asm_x86_sub_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    asm_x86_generic_r32_r32(as, dest_r32, src_r32, OPCODE_SUB_R32_FROM_RM32);\n}\n\nstatic void asm_x86_sub_r32_i32(asm_x86_t *as, int dest_r32, int src_i32) {\n    if (SIGNED_FIT8(src_i32)) {\n        \n        asm_x86_write_byte_2(as, OPCODE_SUB_I8_FROM_RM32, MODRM_R32(5) | MODRM_RM_REG | MODRM_RM_R32(dest_r32));\n        asm_x86_write_byte_1(as, src_i32 & 0xff);\n    } else {\n        \n        asm_x86_write_byte_2(as, OPCODE_SUB_I32_FROM_RM32, MODRM_R32(5) | MODRM_RM_REG | MODRM_RM_R32(dest_r32));\n        asm_x86_write_word32(as, src_i32);\n    }\n}\n\nvoid asm_x86_mul_r32_r32(asm_x86_t *as, int dest_r32, int src_r32) {\n    \n    asm_x86_write_byte_3(as, 0x0f, 0xaf, MODRM_R32(dest_r32) | MODRM_RM_REG | MODRM_RM_R32(src_r32));\n}\n\n#if 0\n \nvoid asm_x86_shl_r32_by_imm(asm_x86_t *as, int r32, int imm) {\n    asm_x86_write_byte_2(as, OPCODE_SHL_RM32_BY_I8, MODRM_R32(4) | MODRM_RM_REG | MODRM_RM_R32(r32));\n    asm_x86_write_byte_1(as, imm);\n}\n\nvoid asm_x86_shr_r32_by_imm(asm_x86_t *as, int r32, int imm) {\n    asm_x86_write_byte_2(as, OPCODE_SHR_RM32_BY_I8, MODRM_R32(5) | MODRM_RM_REG | MODRM_RM_R32(r32));\n    asm_x86_write_byte_1(as, imm);\n}\n\nvoid asm_x86_sar_r32_by_imm(asm_x86_t *as, int r32, int imm) {\n    asm_x86_write_byte_2(as, OPCODE_SAR_RM32_BY_I8, MODRM_R32(7) | MODRM_RM_REG | MODRM_RM_R32(r32));\n    asm_x86_write_byte_1(as, imm);\n}\n#endif\n\nvoid asm_x86_cmp_r32_with_r32(asm_x86_t *as, int src_r32_a, int src_r32_b) {\n    asm_x86_generic_r32_r32(as, src_r32_b, src_r32_a, OPCODE_CMP_R32_WITH_RM32);\n}\n\n#if 0\nvoid asm_x86_cmp_i32_with_r32(asm_x86_t *as, int src_i32, int src_r32) {\n    if (SIGNED_FIT8(src_i32)) {\n        asm_x86_write_byte_2(as, OPCODE_CMP_I8_WITH_RM32, MODRM_R32(7) | MODRM_RM_REG | MODRM_RM_R32(src_r32));\n        asm_x86_write_byte_1(as, src_i32 & 0xff);\n    } else {\n        asm_x86_write_byte_2(as, OPCODE_CMP_I32_WITH_RM32, MODRM_R32(7) | MODRM_RM_REG | MODRM_RM_R32(src_r32));\n        asm_x86_write_word32(as, src_i32);\n    }\n}\n#endif\n\nvoid asm_x86_test_r8_with_r8(asm_x86_t *as, int src_r32_a, int src_r32_b) {\n    asm_x86_write_byte_2(as, OPCODE_TEST_R8_WITH_RM8, MODRM_R32(src_r32_a) | MODRM_RM_REG | MODRM_RM_R32(src_r32_b));\n}\n\nvoid asm_x86_test_r32_with_r32(asm_x86_t *as, int src_r32_a, int src_r32_b) {\n    asm_x86_generic_r32_r32(as, src_r32_b, src_r32_a, OPCODE_TEST_R32_WITH_RM32);\n}\n\nvoid asm_x86_setcc_r8(asm_x86_t *as, mp_uint_t jcc_type, int dest_r8) {\n    asm_x86_write_byte_3(as, OPCODE_SETCC_RM8_A, OPCODE_SETCC_RM8_B | jcc_type, MODRM_R32(0) | MODRM_RM_REG | MODRM_RM_R32(dest_r8));\n}\n\nvoid asm_x86_jmp_reg(asm_x86_t *as, int src_r32) {\n    asm_x86_write_byte_2(as, OPCODE_JMP_RM32, MODRM_R32(4) | MODRM_RM_REG | MODRM_RM_R32(src_r32));\n}\n\nstatic mp_uint_t get_label_dest(asm_x86_t *as, mp_uint_t label) {\n    assert(label < as->base.max_num_labels);\n    return as->base.label_offsets[label];\n}\n\nvoid asm_x86_jmp_label(asm_x86_t *as, mp_uint_t label) {\n    mp_uint_t dest = get_label_dest(as, label);\n    mp_int_t rel = dest - as->base.code_offset;\n    if (dest != (mp_uint_t)-1 && rel < 0) {\n        \n        \n        rel -= 2;\n        if (SIGNED_FIT8(rel)) {\n            asm_x86_write_byte_2(as, OPCODE_JMP_REL8, rel & 0xff);\n        } else {\n            rel += 2;\n            goto large_jump;\n        }\n    } else {\n        \n    large_jump:\n        rel -= 5;\n        asm_x86_write_byte_1(as, OPCODE_JMP_REL32);\n        asm_x86_write_word32(as, rel);\n    }\n}\n\nvoid asm_x86_jcc_label(asm_x86_t *as, mp_uint_t jcc_type, mp_uint_t label) {\n    mp_uint_t dest = get_label_dest(as, label);\n    mp_int_t rel = dest - as->base.code_offset;\n    if (dest != (mp_uint_t)-1 && rel < 0) {\n        \n        \n        rel -= 2;\n        if (SIGNED_FIT8(rel)) {\n            asm_x86_write_byte_2(as, OPCODE_JCC_REL8 | jcc_type, rel & 0xff);\n        } else {\n            rel += 2;\n            goto large_jump;\n        }\n    } else {\n        \n    large_jump:\n        rel -= 6;\n        asm_x86_write_byte_2(as, OPCODE_JCC_REL32_A, OPCODE_JCC_REL32_B | jcc_type);\n        asm_x86_write_word32(as, rel);\n    }\n}\n\nvoid asm_x86_entry(asm_x86_t *as, int num_locals) {\n    assert(num_locals >= 0);\n    asm_x86_push_r32(as, ASM_X86_REG_EBP);\n    asm_x86_push_r32(as, ASM_X86_REG_EBX);\n    asm_x86_push_r32(as, ASM_X86_REG_ESI);\n    asm_x86_push_r32(as, ASM_X86_REG_EDI);\n    num_locals |= 3; \n    asm_x86_sub_r32_i32(as, ASM_X86_REG_ESP, num_locals * WORD_SIZE);\n    as->num_locals = num_locals;\n}\n\nvoid asm_x86_exit(asm_x86_t *as) {\n    asm_x86_sub_r32_i32(as, ASM_X86_REG_ESP, -as->num_locals * WORD_SIZE);\n    asm_x86_pop_r32(as, ASM_X86_REG_EDI);\n    asm_x86_pop_r32(as, ASM_X86_REG_ESI);\n    asm_x86_pop_r32(as, ASM_X86_REG_EBX);\n    asm_x86_pop_r32(as, ASM_X86_REG_EBP);\n    asm_x86_ret(as);\n}\n\nstatic int asm_x86_arg_offset_from_esp(asm_x86_t *as, size_t arg_num) {\n    \n    return (as->num_locals + 4 + 1 + arg_num) * WORD_SIZE;\n}\n\n#if 0\nvoid asm_x86_push_arg(asm_x86_t *as, int src_arg_num) {\n    asm_x86_push_disp(as, ASM_X86_REG_ESP, asm_x86_arg_offset_from_esp(as, src_arg_num));\n}\n#endif\n\nvoid asm_x86_mov_arg_to_r32(asm_x86_t *as, int src_arg_num, int dest_r32) {\n    asm_x86_mov_mem32_to_r32(as, ASM_X86_REG_ESP, asm_x86_arg_offset_from_esp(as, src_arg_num), dest_r32);\n}\n\n#if 0\nvoid asm_x86_mov_r32_to_arg(asm_x86_t *as, int src_r32, int dest_arg_num) {\n    asm_x86_mov_r32_to_mem32(as, src_r32, ASM_X86_REG_ESP, asm_x86_arg_offset_from_esp(as, dest_arg_num));\n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\nstatic int asm_x86_local_offset_from_esp(asm_x86_t *as, int local_num) {\n    (void)as;\n    \n    return local_num * WORD_SIZE;\n}\n\nvoid asm_x86_mov_local_to_r32(asm_x86_t *as, int src_local_num, int dest_r32) {\n    asm_x86_mov_mem32_to_r32(as, ASM_X86_REG_ESP, asm_x86_local_offset_from_esp(as, src_local_num), dest_r32);\n}\n\nvoid asm_x86_mov_r32_to_local(asm_x86_t *as, int src_r32, int dest_local_num) {\n    asm_x86_mov_r32_to_mem32(as, src_r32, ASM_X86_REG_ESP, asm_x86_local_offset_from_esp(as, dest_local_num));\n}\n\nvoid asm_x86_mov_local_addr_to_r32(asm_x86_t *as, int local_num, int dest_r32) {\n    int offset = asm_x86_local_offset_from_esp(as, local_num);\n    if (offset == 0) {\n        asm_x86_mov_r32_r32(as, dest_r32, ASM_X86_REG_ESP);\n    } else {\n        asm_x86_lea_disp_to_r32(as, ASM_X86_REG_ESP, offset, dest_r32);\n    }\n}\n\nvoid asm_x86_mov_reg_pcrel(asm_x86_t *as, int dest_r32, mp_uint_t label) {\n    asm_x86_write_byte_1(as, OPCODE_CALL_REL32);\n    asm_x86_write_word32(as, 0);\n    mp_uint_t dest = get_label_dest(as, label);\n    mp_int_t rel = dest - as->base.code_offset;\n    asm_x86_pop_r32(as, dest_r32);\n    \n    asm_x86_write_byte_2(as, OPCODE_ADD_I32_TO_RM32, MODRM_R32(0) | MODRM_RM_REG | MODRM_RM_R32(dest_r32));\n    asm_x86_write_word32(as, rel);\n}\n\n#if 0\nvoid asm_x86_push_local(asm_x86_t *as, int local_num) {\n    asm_x86_push_disp(as, ASM_X86_REG_ESP, asm_x86_local_offset_from_esp(as, local_num));\n}\n\nvoid asm_x86_push_local_addr(asm_x86_t *as, int local_num, int temp_r32) {\n    asm_x86_mov_r32_r32(as, temp_r32, ASM_X86_REG_ESP);\n    asm_x86_add_i32_to_r32(as, asm_x86_local_offset_from_esp(as, local_num), temp_r32);\n    asm_x86_push_r32(as, temp_r32);\n}\n#endif\n\nvoid asm_x86_call_ind(asm_x86_t *as, size_t fun_id, mp_uint_t n_args, int temp_r32) {\n    assert(n_args <= 4);\n\n    \n    unsigned int align = ((n_args + 3) & ~3) - n_args;\n    if (align) {\n        asm_x86_sub_r32_i32(as, ASM_X86_REG_ESP, align * WORD_SIZE);\n    }\n\n    if (n_args > 3) {\n        asm_x86_push_r32(as, ASM_X86_REG_ARG_4);\n    }\n    if (n_args > 2) {\n        asm_x86_push_r32(as, ASM_X86_REG_ARG_3);\n    }\n    if (n_args > 1) {\n        asm_x86_push_r32(as, ASM_X86_REG_ARG_2);\n    }\n    if (n_args > 0) {\n        asm_x86_push_r32(as, ASM_X86_REG_ARG_1);\n    }\n\n    \n    asm_x86_mov_mem32_to_r32(as, ASM_X86_REG_FUN_TABLE, fun_id * WORD_SIZE, temp_r32);\n    asm_x86_write_byte_2(as, OPCODE_CALL_RM32, MODRM_R32(2) | MODRM_RM_REG | MODRM_RM_R32(temp_r32));\n\n    \n    if (n_args > 0) {\n        asm_x86_add_i32_to_r32(as, (n_args + align) * WORD_SIZE, ASM_X86_REG_ESP);\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}