{
  "module_name": "emitbc.c",
  "hash_id": "76b95803cb611c727b6b7b6aedbdaa7b464a1e038c432a983a640f3b478a3171",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/emitbc.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n\n#include \"py/mpstate.h\"\n#include \"py/smallint.h\"\n#include \"py/emit.h\"\n#include \"py/bc0.h\"\n\n#if MICROPY_ENABLE_COMPILER\n\n#define DUMMY_DATA_SIZE (MP_ENCODE_UINT_MAX_BYTES)\n\nstruct _emit_t {\n    \n    \n    \n    byte dummy_data[DUMMY_DATA_SIZE];\n\n    pass_kind_t pass : 8;\n\n    \n    \n    \n    bool suppress;\n\n    int stack_size;\n\n    mp_emit_common_t *emit_common;\n    scope_t *scope;\n\n    mp_uint_t last_source_line_offset;\n    mp_uint_t last_source_line;\n\n    size_t max_num_labels;\n    size_t *label_offsets;\n\n    size_t code_info_offset;\n    size_t code_info_size;\n    size_t bytecode_offset;\n    size_t bytecode_size;\n    byte *code_base; \n    bool overflow;\n\n    size_t n_info;\n    size_t n_cell;\n};\n\nemit_t *emit_bc_new(mp_emit_common_t *emit_common) {\n    emit_t *emit = m_new0(emit_t, 1);\n    emit->emit_common = emit_common;\n    return emit;\n}\n\nvoid emit_bc_set_max_num_labels(emit_t *emit, mp_uint_t max_num_labels) {\n    emit->max_num_labels = max_num_labels;\n    emit->label_offsets = m_new(size_t, emit->max_num_labels);\n}\n\nvoid emit_bc_free(emit_t *emit) {\n    m_del(size_t, emit->label_offsets, emit->max_num_labels);\n    m_del_obj(emit_t, emit);\n}\n\n\nstatic uint8_t *emit_get_cur_to_write_code_info(void *emit_in, size_t num_bytes_to_write) {\n    emit_t *emit = emit_in;\n    if (emit->pass < MP_PASS_EMIT) {\n        emit->code_info_offset += num_bytes_to_write;\n        return emit->dummy_data;\n    } else {\n        assert(emit->code_info_offset + num_bytes_to_write <= emit->code_info_size);\n        byte *c = emit->code_base + emit->code_info_offset;\n        emit->code_info_offset += num_bytes_to_write;\n        return c;\n    }\n}\n\nstatic void emit_write_code_info_byte(emit_t *emit, byte val) {\n    *emit_get_cur_to_write_code_info(emit, 1) = val;\n}\n\nstatic void emit_write_code_info_qstr(emit_t *emit, qstr qst) {\n    mp_encode_uint(emit, emit_get_cur_to_write_code_info, mp_emit_common_use_qstr(emit->emit_common, qst));\n}\n\n#if MICROPY_ENABLE_SOURCE_LINE\nstatic void emit_write_code_info_bytes_lines(emit_t *emit, mp_uint_t bytes_to_skip, mp_uint_t lines_to_skip) {\n    assert(bytes_to_skip > 0 || lines_to_skip > 0);\n    while (bytes_to_skip > 0 || lines_to_skip > 0) {\n        mp_uint_t b, l;\n        if (lines_to_skip <= 6 || bytes_to_skip > 0xf) {\n            \n            b = MIN(bytes_to_skip, 0x1f);\n            if (b < bytes_to_skip) {\n                \n                l = 0;\n            } else {\n                l = MIN(lines_to_skip, 0x3);\n            }\n            *emit_get_cur_to_write_code_info(emit, 1) = b | (l << 5);\n        } else {\n            \n            b = MIN(bytes_to_skip, 0xf);\n            l = MIN(lines_to_skip, 0x7ff);\n            byte *ci = emit_get_cur_to_write_code_info(emit, 2);\n            ci[0] = 0x80 | b | ((l >> 4) & 0x70);\n            ci[1] = l;\n        }\n        bytes_to_skip -= b;\n        lines_to_skip -= l;\n    }\n}\n#endif\n\n\nstatic uint8_t *emit_get_cur_to_write_bytecode(void *emit_in, size_t num_bytes_to_write) {\n    emit_t *emit = emit_in;\n    if (emit->suppress) {\n        return emit->dummy_data;\n    }\n    if (emit->pass < MP_PASS_EMIT) {\n        emit->bytecode_offset += num_bytes_to_write;\n        return emit->dummy_data;\n    } else {\n        assert(emit->bytecode_offset + num_bytes_to_write <= emit->bytecode_size);\n        byte *c = emit->code_base + emit->code_info_size + emit->bytecode_offset;\n        emit->bytecode_offset += num_bytes_to_write;\n        return c;\n    }\n}\n\nstatic void emit_write_bytecode_raw_byte(emit_t *emit, byte b1) {\n    byte *c = emit_get_cur_to_write_bytecode(emit, 1);\n    c[0] = b1;\n}\n\nstatic void emit_write_bytecode_byte(emit_t *emit, int stack_adj, byte b1) {\n    mp_emit_bc_adjust_stack_size(emit, stack_adj);\n    byte *c = emit_get_cur_to_write_bytecode(emit, 1);\n    c[0] = b1;\n}\n\n\nstatic void emit_write_bytecode_byte_int(emit_t *emit, int stack_adj, byte b1, mp_int_t num) {\n    emit_write_bytecode_byte(emit, stack_adj, b1);\n\n    \n    byte buf[MP_ENCODE_UINT_MAX_BYTES];\n    byte *p = buf + sizeof(buf);\n    \n    do {\n        *--p = num & 0x7f;\n        num >>= 7;\n    } while (num != 0 && num != -1);\n    \n    \n    if (num == -1 && (*p & 0x40) == 0) {\n        *--p = 0x7f;\n    } else if (num == 0 && (*p & 0x40) != 0) {\n        *--p = 0;\n    }\n\n    byte *c = emit_get_cur_to_write_bytecode(emit, buf + sizeof(buf) - p);\n    while (p != buf + sizeof(buf) - 1) {\n        *c++ = *p++ | 0x80;\n    }\n    *c = *p;\n}\n\nstatic void emit_write_bytecode_byte_uint(emit_t *emit, int stack_adj, byte b, mp_uint_t val) {\n    emit_write_bytecode_byte(emit, stack_adj, b);\n    mp_encode_uint(emit, emit_get_cur_to_write_bytecode, val);\n}\n\nstatic void emit_write_bytecode_byte_const(emit_t *emit, int stack_adj, byte b, mp_uint_t n) {\n    emit_write_bytecode_byte_uint(emit, stack_adj, b, n);\n}\n\nstatic void emit_write_bytecode_byte_qstr(emit_t *emit, int stack_adj, byte b, qstr qst) {\n    emit_write_bytecode_byte_uint(emit, stack_adj, b, mp_emit_common_use_qstr(emit->emit_common, qst));\n}\n\nstatic void emit_write_bytecode_byte_obj(emit_t *emit, int stack_adj, byte b, mp_obj_t obj) {\n    emit_write_bytecode_byte_const(emit, stack_adj, b, mp_emit_common_use_const_obj(emit->emit_common, obj));\n}\n\nstatic void emit_write_bytecode_byte_child(emit_t *emit, int stack_adj, byte b, mp_raw_code_t *rc) {\n    emit_write_bytecode_byte_const(emit, stack_adj, b,\n        mp_emit_common_alloc_const_child(emit->emit_common, rc));\n    #if MICROPY_PY_SYS_SETTRACE\n    rc->line_of_definition = emit->last_source_line;\n    #endif\n}\n\n\n\n\n\n\nstatic void emit_write_bytecode_byte_label(emit_t *emit, int stack_adj, byte b1, mp_uint_t label) {\n    mp_emit_bc_adjust_stack_size(emit, stack_adj);\n\n    if (emit->suppress) {\n        return;\n    }\n\n    \n    const bool is_signed = b1 <= MP_BC_POP_JUMP_IF_FALSE;\n\n    \n    unsigned int jump_encoding_size = 1;\n    ssize_t bytecode_offset = 0;\n\n    \n    if (emit->pass >= MP_PASS_CODE_SIZE) {\n        \n        bytecode_offset = emit->label_offsets[label] - emit->bytecode_offset - 2;\n\n        \n        if ((is_signed && -64 <= bytecode_offset && bytecode_offset <= 63)\n            || (!is_signed && (size_t)bytecode_offset <= 127)) {\n            \n            jump_encoding_size = 0;\n        }\n\n        \n        bytecode_offset -= jump_encoding_size;\n\n        assert(is_signed || bytecode_offset >= 0);\n    }\n\n    \n    byte *c = emit_get_cur_to_write_bytecode(emit, 2 + jump_encoding_size);\n    c[0] = b1;\n    if (jump_encoding_size == 0) {\n        if (is_signed) {\n            bytecode_offset += 0x40;\n        }\n        assert(0 <= bytecode_offset && bytecode_offset <= 0x7f);\n        c[1] = bytecode_offset;\n    } else {\n        if (is_signed) {\n            bytecode_offset += 0x4000;\n        }\n        if (emit->pass == MP_PASS_EMIT && !(0 <= bytecode_offset && bytecode_offset <= 0x7fff)) {\n            emit->overflow = true;\n        }\n        c[1] = 0x80 | (bytecode_offset & 0x7f);\n        c[2] = bytecode_offset >> 7;\n    }\n}\n\nvoid mp_emit_bc_start_pass(emit_t *emit, pass_kind_t pass, scope_t *scope) {\n    emit->pass = pass;\n    emit->stack_size = 0;\n    emit->suppress = false;\n    emit->scope = scope;\n    emit->last_source_line_offset = 0;\n    emit->last_source_line = 1;\n    emit->bytecode_offset = 0;\n    emit->code_info_offset = 0;\n    emit->overflow = false;\n\n    \n    {\n        mp_uint_t n_state = scope->num_locals + scope->stack_size;\n        if (n_state == 0) {\n            \n            \n            \n            n_state = 1;\n        }\n        #if MICROPY_DEBUG_VM_STACK_OVERFLOW\n        \n        n_state += 1;\n        #endif\n\n        size_t n_exc_stack = scope->exc_stack_size;\n        MP_BC_PRELUDE_SIG_ENCODE(n_state, n_exc_stack, scope, emit_write_code_info_byte, emit);\n    }\n\n    \n    if (emit->pass >= MP_PASS_CODE_SIZE) {\n        size_t n_info = emit->n_info;\n        size_t n_cell = emit->n_cell;\n        MP_BC_PRELUDE_SIZE_ENCODE(n_info, n_cell, emit_write_code_info_byte, emit);\n    }\n\n    emit->n_info = emit->code_info_offset;\n\n    \n    emit_write_code_info_qstr(emit, scope->simple_name);\n\n    \n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        for (int i = 0; i < scope->num_pos_args + scope->num_kwonly_args; i++) {\n            qstr qst = MP_QSTR__star_;\n            for (int j = 0; j < scope->id_info_len; ++j) {\n                id_info_t *id = &scope->id_info[j];\n                if ((id->flags & ID_FLAG_IS_PARAM) && id->local_num == i) {\n                    qst = id->qst;\n                    break;\n                }\n            }\n            emit_write_code_info_qstr(emit, qst);\n        }\n    }\n}\n\nbool mp_emit_bc_end_pass(emit_t *emit) {\n    if (emit->pass == MP_PASS_SCOPE) {\n        return true;\n    }\n\n    \n    assert(emit->stack_size == 0);\n\n    \n    emit->n_info = emit->code_info_offset - emit->n_info;\n\n    \n    emit->n_cell = 0;\n    for (size_t i = 0; i < emit->scope->id_info_len; ++i) {\n        id_info_t *id = &emit->scope->id_info[i];\n        if (id->kind == ID_INFO_KIND_CELL) {\n            assert(id->local_num <= 255);\n            emit_write_code_info_byte(emit, id->local_num); \n            ++emit->n_cell;\n        }\n    }\n\n    if (emit->pass == MP_PASS_CODE_SIZE) {\n        \n        emit->code_info_size = emit->code_info_offset;\n        emit->bytecode_size = emit->bytecode_offset;\n        emit->code_base = m_new0(byte, emit->code_info_size + emit->bytecode_size);\n\n    } else if (emit->pass == MP_PASS_EMIT) {\n        \n        assert(emit->code_info_offset <= emit->code_info_size);\n        assert(emit->bytecode_offset <= emit->bytecode_size);\n\n        if (emit->code_info_offset != emit->code_info_size\n            || emit->bytecode_offset != emit->bytecode_size) {\n            \n            \n            emit->code_info_size = emit->code_info_offset;\n            emit->bytecode_size = emit->bytecode_offset;\n            return false;\n        }\n\n        if (emit->overflow) {\n            mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"bytecode overflow\"));\n        }\n\n        #if MICROPY_PERSISTENT_CODE_SAVE || MICROPY_DEBUG_PRINTERS\n        size_t bytecode_len = emit->code_info_size + emit->bytecode_size;\n        #if MICROPY_DEBUG_PRINTERS\n        emit->scope->raw_code_data_len = bytecode_len;\n        #endif\n        #endif\n\n        \n        mp_emit_glue_assign_bytecode(emit->scope->raw_code, emit->code_base,\n            emit->emit_common->children,\n            #if MICROPY_PERSISTENT_CODE_SAVE\n            bytecode_len,\n            emit->emit_common->ct_cur_child,\n            #endif\n            emit->scope->scope_flags);\n    }\n\n    return true;\n}\n\nvoid mp_emit_bc_adjust_stack_size(emit_t *emit, mp_int_t delta) {\n    if (emit->pass == MP_PASS_SCOPE) {\n        return;\n    }\n    assert((mp_int_t)emit->stack_size + delta >= 0);\n    emit->stack_size += delta;\n    if (emit->stack_size > emit->scope->stack_size) {\n        emit->scope->stack_size = emit->stack_size;\n    }\n}\n\nvoid mp_emit_bc_set_source_line(emit_t *emit, mp_uint_t source_line) {\n    #if MICROPY_ENABLE_SOURCE_LINE\n    if (MP_STATE_VM(mp_optimise_value) >= 3) {\n        \n        return;\n    }\n    if (source_line > emit->last_source_line) {\n        mp_uint_t bytes_to_skip = emit->bytecode_offset - emit->last_source_line_offset;\n        mp_uint_t lines_to_skip = source_line - emit->last_source_line;\n        emit_write_code_info_bytes_lines(emit, bytes_to_skip, lines_to_skip);\n        emit->last_source_line_offset = emit->bytecode_offset;\n        emit->last_source_line = source_line;\n    }\n    #else\n    (void)emit;\n    (void)source_line;\n    #endif\n}\n\nvoid mp_emit_bc_label_assign(emit_t *emit, mp_uint_t l) {\n    \n    \n    emit->suppress = false;\n\n    if (emit->pass == MP_PASS_SCOPE) {\n        return;\n    }\n\n    \n    \n    \n    \n    assert(l < emit->max_num_labels);\n    assert(emit->pass == MP_PASS_STACK_SIZE || emit->bytecode_offset <= emit->label_offsets[l]);\n\n    \n    emit->label_offsets[l] = emit->bytecode_offset;\n}\n\nvoid mp_emit_bc_import(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_BC_IMPORT_NAME + MP_EMIT_IMPORT_NAME == MP_BC_IMPORT_NAME);\n    MP_STATIC_ASSERT(MP_BC_IMPORT_NAME + MP_EMIT_IMPORT_FROM == MP_BC_IMPORT_FROM);\n    int stack_adj = kind == MP_EMIT_IMPORT_FROM ? 1 : -1;\n    if (kind == MP_EMIT_IMPORT_STAR) {\n        emit_write_bytecode_byte(emit, stack_adj, MP_BC_IMPORT_STAR);\n    } else {\n        emit_write_bytecode_byte_qstr(emit, stack_adj, MP_BC_IMPORT_NAME + kind, qst);\n    }\n}\n\nvoid mp_emit_bc_load_const_tok(emit_t *emit, mp_token_kind_t tok) {\n    MP_STATIC_ASSERT(MP_BC_LOAD_CONST_FALSE + (MP_TOKEN_KW_NONE - MP_TOKEN_KW_FALSE) == MP_BC_LOAD_CONST_NONE);\n    MP_STATIC_ASSERT(MP_BC_LOAD_CONST_FALSE + (MP_TOKEN_KW_TRUE - MP_TOKEN_KW_FALSE) == MP_BC_LOAD_CONST_TRUE);\n    if (tok == MP_TOKEN_ELLIPSIS) {\n        emit_write_bytecode_byte_obj(emit, 1, MP_BC_LOAD_CONST_OBJ, MP_OBJ_FROM_PTR(&mp_const_ellipsis_obj));\n    } else {\n        emit_write_bytecode_byte(emit, 1, MP_BC_LOAD_CONST_FALSE + (tok - MP_TOKEN_KW_FALSE));\n    }\n}\n\nvoid mp_emit_bc_load_const_small_int(emit_t *emit, mp_int_t arg) {\n    assert(MP_SMALL_INT_FITS(arg));\n    if (-MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS <= arg\n        && arg < MP_BC_LOAD_CONST_SMALL_INT_MULTI_NUM - MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS) {\n        emit_write_bytecode_byte(emit, 1,\n            MP_BC_LOAD_CONST_SMALL_INT_MULTI + MP_BC_LOAD_CONST_SMALL_INT_MULTI_EXCESS + arg);\n    } else {\n        emit_write_bytecode_byte_int(emit, 1, MP_BC_LOAD_CONST_SMALL_INT, arg);\n    }\n}\n\nvoid mp_emit_bc_load_const_str(emit_t *emit, qstr qst) {\n    emit_write_bytecode_byte_qstr(emit, 1, MP_BC_LOAD_CONST_STRING, qst);\n}\n\nvoid mp_emit_bc_load_const_obj(emit_t *emit, mp_obj_t obj) {\n    emit_write_bytecode_byte_obj(emit, 1, MP_BC_LOAD_CONST_OBJ, obj);\n}\n\nvoid mp_emit_bc_load_null(emit_t *emit) {\n    emit_write_bytecode_byte(emit, 1, MP_BC_LOAD_NULL);\n}\n\nvoid mp_emit_bc_load_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind) {\n    MP_STATIC_ASSERT(MP_BC_LOAD_FAST_N + MP_EMIT_IDOP_LOCAL_FAST == MP_BC_LOAD_FAST_N);\n    MP_STATIC_ASSERT(MP_BC_LOAD_FAST_N + MP_EMIT_IDOP_LOCAL_DEREF == MP_BC_LOAD_DEREF);\n    (void)qst;\n    if (kind == MP_EMIT_IDOP_LOCAL_FAST && local_num <= 15) {\n        emit_write_bytecode_byte(emit, 1, MP_BC_LOAD_FAST_MULTI + local_num);\n    } else {\n        emit_write_bytecode_byte_uint(emit, 1, MP_BC_LOAD_FAST_N + kind, local_num);\n    }\n}\n\nvoid mp_emit_bc_load_global(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_BC_LOAD_NAME + MP_EMIT_IDOP_GLOBAL_NAME == MP_BC_LOAD_NAME);\n    MP_STATIC_ASSERT(MP_BC_LOAD_NAME + MP_EMIT_IDOP_GLOBAL_GLOBAL == MP_BC_LOAD_GLOBAL);\n    (void)qst;\n    emit_write_bytecode_byte_qstr(emit, 1, MP_BC_LOAD_NAME + kind, qst);\n}\n\nvoid mp_emit_bc_load_method(emit_t *emit, qstr qst, bool is_super) {\n    int stack_adj = 1 - 2 * is_super;\n    emit_write_bytecode_byte_qstr(emit, stack_adj, is_super ? MP_BC_LOAD_SUPER_METHOD : MP_BC_LOAD_METHOD, qst);\n}\n\nvoid mp_emit_bc_load_build_class(emit_t *emit) {\n    emit_write_bytecode_byte(emit, 1, MP_BC_LOAD_BUILD_CLASS);\n}\n\nvoid mp_emit_bc_subscr(emit_t *emit, int kind) {\n    if (kind == MP_EMIT_SUBSCR_LOAD) {\n        emit_write_bytecode_byte(emit, -1, MP_BC_LOAD_SUBSCR);\n    } else {\n        if (kind == MP_EMIT_SUBSCR_DELETE) {\n            mp_emit_bc_load_null(emit);\n            mp_emit_bc_rot_three(emit);\n        }\n        emit_write_bytecode_byte(emit, -3, MP_BC_STORE_SUBSCR);\n    }\n}\n\nvoid mp_emit_bc_attr(emit_t *emit, qstr qst, int kind) {\n    if (kind == MP_EMIT_ATTR_LOAD) {\n        emit_write_bytecode_byte_qstr(emit, 0, MP_BC_LOAD_ATTR, qst);\n    } else {\n        if (kind == MP_EMIT_ATTR_DELETE) {\n            mp_emit_bc_load_null(emit);\n            mp_emit_bc_rot_two(emit);\n        }\n        emit_write_bytecode_byte_qstr(emit, -2, MP_BC_STORE_ATTR, qst);\n    }\n}\n\nvoid mp_emit_bc_store_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind) {\n    MP_STATIC_ASSERT(MP_BC_STORE_FAST_N + MP_EMIT_IDOP_LOCAL_FAST == MP_BC_STORE_FAST_N);\n    MP_STATIC_ASSERT(MP_BC_STORE_FAST_N + MP_EMIT_IDOP_LOCAL_DEREF == MP_BC_STORE_DEREF);\n    (void)qst;\n    if (kind == MP_EMIT_IDOP_LOCAL_FAST && local_num <= 15) {\n        emit_write_bytecode_byte(emit, -1, MP_BC_STORE_FAST_MULTI + local_num);\n    } else {\n        emit_write_bytecode_byte_uint(emit, -1, MP_BC_STORE_FAST_N + kind, local_num);\n    }\n}\n\nvoid mp_emit_bc_store_global(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_BC_STORE_NAME + MP_EMIT_IDOP_GLOBAL_NAME == MP_BC_STORE_NAME);\n    MP_STATIC_ASSERT(MP_BC_STORE_NAME + MP_EMIT_IDOP_GLOBAL_GLOBAL == MP_BC_STORE_GLOBAL);\n    emit_write_bytecode_byte_qstr(emit, -1, MP_BC_STORE_NAME + kind, qst);\n}\n\nvoid mp_emit_bc_delete_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind) {\n    MP_STATIC_ASSERT(MP_BC_DELETE_FAST + MP_EMIT_IDOP_LOCAL_FAST == MP_BC_DELETE_FAST);\n    MP_STATIC_ASSERT(MP_BC_DELETE_FAST + MP_EMIT_IDOP_LOCAL_DEREF == MP_BC_DELETE_DEREF);\n    (void)qst;\n    emit_write_bytecode_byte_uint(emit, 0, MP_BC_DELETE_FAST + kind, local_num);\n}\n\nvoid mp_emit_bc_delete_global(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_BC_DELETE_NAME + MP_EMIT_IDOP_GLOBAL_NAME == MP_BC_DELETE_NAME);\n    MP_STATIC_ASSERT(MP_BC_DELETE_NAME + MP_EMIT_IDOP_GLOBAL_GLOBAL == MP_BC_DELETE_GLOBAL);\n    emit_write_bytecode_byte_qstr(emit, 0, MP_BC_DELETE_NAME + kind, qst);\n}\n\nvoid mp_emit_bc_dup_top(emit_t *emit) {\n    emit_write_bytecode_byte(emit, 1, MP_BC_DUP_TOP);\n}\n\nvoid mp_emit_bc_dup_top_two(emit_t *emit) {\n    emit_write_bytecode_byte(emit, 2, MP_BC_DUP_TOP_TWO);\n}\n\nvoid mp_emit_bc_pop_top(emit_t *emit) {\n    emit_write_bytecode_byte(emit, -1, MP_BC_POP_TOP);\n}\n\nvoid mp_emit_bc_rot_two(emit_t *emit) {\n    emit_write_bytecode_byte(emit, 0, MP_BC_ROT_TWO);\n}\n\nvoid mp_emit_bc_rot_three(emit_t *emit) {\n    emit_write_bytecode_byte(emit, 0, MP_BC_ROT_THREE);\n}\n\nvoid mp_emit_bc_jump(emit_t *emit, mp_uint_t label) {\n    emit_write_bytecode_byte_label(emit, 0, MP_BC_JUMP, label);\n    emit->suppress = true;\n}\n\nvoid mp_emit_bc_pop_jump_if(emit_t *emit, bool cond, mp_uint_t label) {\n    if (cond) {\n        emit_write_bytecode_byte_label(emit, -1, MP_BC_POP_JUMP_IF_TRUE, label);\n    } else {\n        emit_write_bytecode_byte_label(emit, -1, MP_BC_POP_JUMP_IF_FALSE, label);\n    }\n}\n\nvoid mp_emit_bc_jump_if_or_pop(emit_t *emit, bool cond, mp_uint_t label) {\n    if (cond) {\n        emit_write_bytecode_byte_label(emit, -1, MP_BC_JUMP_IF_TRUE_OR_POP, label);\n    } else {\n        emit_write_bytecode_byte_label(emit, -1, MP_BC_JUMP_IF_FALSE_OR_POP, label);\n    }\n}\n\nvoid mp_emit_bc_unwind_jump(emit_t *emit, mp_uint_t label, mp_uint_t except_depth) {\n    if (except_depth == 0) {\n        if (label & MP_EMIT_BREAK_FROM_FOR) {\n            \n            emit_write_bytecode_raw_byte(emit, MP_BC_POP_TOP);\n            \n            for (size_t i = 0; i < MP_OBJ_ITER_BUF_NSLOTS - 1; ++i) {\n                emit_write_bytecode_raw_byte(emit, MP_BC_POP_TOP);\n            }\n        }\n        emit_write_bytecode_byte_label(emit, 0, MP_BC_JUMP, label & ~MP_EMIT_BREAK_FROM_FOR);\n    } else {\n        emit_write_bytecode_byte_label(emit, 0, MP_BC_UNWIND_JUMP, label & ~MP_EMIT_BREAK_FROM_FOR);\n        emit_write_bytecode_raw_byte(emit, ((label & MP_EMIT_BREAK_FROM_FOR) ? 0x80 : 0) | except_depth);\n    }\n    emit->suppress = true;\n}\n\nvoid mp_emit_bc_setup_block(emit_t *emit, mp_uint_t label, int kind) {\n    MP_STATIC_ASSERT(MP_BC_SETUP_WITH + MP_EMIT_SETUP_BLOCK_WITH == MP_BC_SETUP_WITH);\n    MP_STATIC_ASSERT(MP_BC_SETUP_WITH + MP_EMIT_SETUP_BLOCK_EXCEPT == MP_BC_SETUP_EXCEPT);\n    MP_STATIC_ASSERT(MP_BC_SETUP_WITH + MP_EMIT_SETUP_BLOCK_FINALLY == MP_BC_SETUP_FINALLY);\n    \n    \n    int stack_adj = kind == MP_EMIT_SETUP_BLOCK_WITH ? 2 : 0;\n    emit_write_bytecode_byte_label(emit, stack_adj, MP_BC_SETUP_WITH + kind, label);\n}\n\nvoid mp_emit_bc_with_cleanup(emit_t *emit, mp_uint_t label) {\n    mp_emit_bc_load_const_tok(emit, MP_TOKEN_KW_NONE);\n    mp_emit_bc_label_assign(emit, label);\n    \n    emit_write_bytecode_byte(emit, 2, MP_BC_WITH_CLEANUP);\n    \n    mp_emit_bc_adjust_stack_size(emit, -4);\n}\n\nvoid mp_emit_bc_end_finally(emit_t *emit) {\n    emit_write_bytecode_byte(emit, -1, MP_BC_END_FINALLY);\n}\n\nvoid mp_emit_bc_get_iter(emit_t *emit, bool use_stack) {\n    int stack_adj = use_stack ? MP_OBJ_ITER_BUF_NSLOTS - 1 : 0;\n    emit_write_bytecode_byte(emit, stack_adj, use_stack ? MP_BC_GET_ITER_STACK : MP_BC_GET_ITER);\n}\n\nvoid mp_emit_bc_for_iter(emit_t *emit, mp_uint_t label) {\n    emit_write_bytecode_byte_label(emit, 1, MP_BC_FOR_ITER, label);\n}\n\nvoid mp_emit_bc_for_iter_end(emit_t *emit) {\n    mp_emit_bc_adjust_stack_size(emit, -MP_OBJ_ITER_BUF_NSLOTS);\n}\n\nvoid mp_emit_bc_pop_except_jump(emit_t *emit, mp_uint_t label, bool within_exc_handler) {\n    (void)within_exc_handler;\n    emit_write_bytecode_byte_label(emit, 0, MP_BC_POP_EXCEPT_JUMP, label);\n    emit->suppress = true;\n}\n\nvoid mp_emit_bc_unary_op(emit_t *emit, mp_unary_op_t op) {\n    emit_write_bytecode_byte(emit, 0, MP_BC_UNARY_OP_MULTI + op);\n}\n\nvoid mp_emit_bc_binary_op(emit_t *emit, mp_binary_op_t op) {\n    bool invert = false;\n    if (op == MP_BINARY_OP_NOT_IN) {\n        invert = true;\n        op = MP_BINARY_OP_IN;\n    } else if (op == MP_BINARY_OP_IS_NOT) {\n        invert = true;\n        op = MP_BINARY_OP_IS;\n    }\n    emit_write_bytecode_byte(emit, -1, MP_BC_BINARY_OP_MULTI + op);\n    if (invert) {\n        emit_write_bytecode_byte(emit, 0, MP_BC_UNARY_OP_MULTI + MP_UNARY_OP_NOT);\n    }\n}\n\nvoid mp_emit_bc_build(emit_t *emit, mp_uint_t n_args, int kind) {\n    MP_STATIC_ASSERT(MP_BC_BUILD_TUPLE + MP_EMIT_BUILD_TUPLE == MP_BC_BUILD_TUPLE);\n    MP_STATIC_ASSERT(MP_BC_BUILD_TUPLE + MP_EMIT_BUILD_LIST == MP_BC_BUILD_LIST);\n    MP_STATIC_ASSERT(MP_BC_BUILD_TUPLE + MP_EMIT_BUILD_MAP == MP_BC_BUILD_MAP);\n    MP_STATIC_ASSERT(MP_BC_BUILD_TUPLE + MP_EMIT_BUILD_SET == MP_BC_BUILD_SET);\n    MP_STATIC_ASSERT(MP_BC_BUILD_TUPLE + MP_EMIT_BUILD_SLICE == MP_BC_BUILD_SLICE);\n    int stack_adj = kind == MP_EMIT_BUILD_MAP ? 1 : 1 - n_args;\n    emit_write_bytecode_byte_uint(emit, stack_adj, MP_BC_BUILD_TUPLE + kind, n_args);\n}\n\nvoid mp_emit_bc_store_map(emit_t *emit) {\n    emit_write_bytecode_byte(emit, -2, MP_BC_STORE_MAP);\n}\n\nvoid mp_emit_bc_store_comp(emit_t *emit, scope_kind_t kind, mp_uint_t collection_stack_index) {\n    int t;\n    int n;\n    if (kind == SCOPE_LIST_COMP) {\n        n = 0;\n        t = 0;\n    } else if (!MICROPY_PY_BUILTINS_SET || kind == SCOPE_DICT_COMP) {\n        n = 1;\n        t = 1;\n    } else if (MICROPY_PY_BUILTINS_SET) {\n        n = 0;\n        t = 2;\n    }\n    \n    emit_write_bytecode_byte_uint(emit, -1 - n, MP_BC_STORE_COMP, ((collection_stack_index + n) << 2) | t);\n}\n\nvoid mp_emit_bc_unpack_sequence(emit_t *emit, mp_uint_t n_args) {\n    emit_write_bytecode_byte_uint(emit, -1 + n_args, MP_BC_UNPACK_SEQUENCE, n_args);\n}\n\nvoid mp_emit_bc_unpack_ex(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right) {\n    emit_write_bytecode_byte_uint(emit, -1 + n_left + n_right + 1, MP_BC_UNPACK_EX, n_left | (n_right << 8));\n}\n\nvoid mp_emit_bc_make_function(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {\n    if (n_pos_defaults == 0 && n_kw_defaults == 0) {\n        emit_write_bytecode_byte_child(emit, 1, MP_BC_MAKE_FUNCTION, scope->raw_code);\n    } else {\n        emit_write_bytecode_byte_child(emit, -1, MP_BC_MAKE_FUNCTION_DEFARGS, scope->raw_code);\n    }\n}\n\nvoid mp_emit_bc_make_closure(emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {\n    if (n_pos_defaults == 0 && n_kw_defaults == 0) {\n        int stack_adj = -n_closed_over + 1;\n        emit_write_bytecode_byte_child(emit, stack_adj, MP_BC_MAKE_CLOSURE, scope->raw_code);\n        emit_write_bytecode_raw_byte(emit, n_closed_over);\n    } else {\n        assert(n_closed_over <= 255);\n        int stack_adj = -2 - (mp_int_t)n_closed_over + 1;\n        emit_write_bytecode_byte_child(emit, stack_adj, MP_BC_MAKE_CLOSURE_DEFARGS, scope->raw_code);\n        emit_write_bytecode_raw_byte(emit, n_closed_over);\n    }\n}\n\nstatic void emit_bc_call_function_method_helper(emit_t *emit, int stack_adj, mp_uint_t bytecode_base, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {\n    if (star_flags) {\n        \n        \n        stack_adj -= (int)n_positional + 2 * (int)n_keyword + 1;\n        emit_write_bytecode_byte_uint(emit, stack_adj, bytecode_base + 1, (n_keyword << 8) | n_positional); \n    } else {\n        stack_adj -= (int)n_positional + 2 * (int)n_keyword;\n        emit_write_bytecode_byte_uint(emit, stack_adj, bytecode_base, (n_keyword << 8) | n_positional); \n    }\n}\n\nvoid mp_emit_bc_call_function(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {\n    emit_bc_call_function_method_helper(emit, 0, MP_BC_CALL_FUNCTION, n_positional, n_keyword, star_flags);\n}\n\nvoid mp_emit_bc_call_method(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {\n    emit_bc_call_function_method_helper(emit, -1, MP_BC_CALL_METHOD, n_positional, n_keyword, star_flags);\n}\n\nvoid mp_emit_bc_return_value(emit_t *emit) {\n    emit_write_bytecode_byte(emit, -1, MP_BC_RETURN_VALUE);\n    emit->suppress = true;\n}\n\nvoid mp_emit_bc_raise_varargs(emit_t *emit, mp_uint_t n_args) {\n    MP_STATIC_ASSERT(MP_BC_RAISE_LAST + 1 == MP_BC_RAISE_OBJ);\n    MP_STATIC_ASSERT(MP_BC_RAISE_LAST + 2 == MP_BC_RAISE_FROM);\n    assert(n_args <= 2);\n    emit_write_bytecode_byte(emit, -n_args, MP_BC_RAISE_LAST + n_args);\n    emit->suppress = true;\n}\n\nvoid mp_emit_bc_yield(emit_t *emit, int kind) {\n    MP_STATIC_ASSERT(MP_BC_YIELD_VALUE + 1 == MP_BC_YIELD_FROM);\n    emit_write_bytecode_byte(emit, -kind, MP_BC_YIELD_VALUE + kind);\n    emit->scope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;\n}\n\nvoid mp_emit_bc_start_except_handler(emit_t *emit) {\n    mp_emit_bc_adjust_stack_size(emit, 4); \n}\n\nvoid mp_emit_bc_end_except_handler(emit_t *emit) {\n    mp_emit_bc_adjust_stack_size(emit, -3); \n}\n\n#if MICROPY_EMIT_NATIVE\nconst emit_method_table_t emit_bc_method_table = {\n    #if MICROPY_DYNAMIC_COMPILER\n    NULL,\n    NULL,\n    #endif\n\n    mp_emit_bc_start_pass,\n    mp_emit_bc_end_pass,\n    mp_emit_bc_adjust_stack_size,\n    mp_emit_bc_set_source_line,\n\n    {\n        mp_emit_bc_load_local,\n        mp_emit_bc_load_global,\n    },\n    {\n        mp_emit_bc_store_local,\n        mp_emit_bc_store_global,\n    },\n    {\n        mp_emit_bc_delete_local,\n        mp_emit_bc_delete_global,\n    },\n\n    mp_emit_bc_label_assign,\n    mp_emit_bc_import,\n    mp_emit_bc_load_const_tok,\n    mp_emit_bc_load_const_small_int,\n    mp_emit_bc_load_const_str,\n    mp_emit_bc_load_const_obj,\n    mp_emit_bc_load_null,\n    mp_emit_bc_load_method,\n    mp_emit_bc_load_build_class,\n    mp_emit_bc_subscr,\n    mp_emit_bc_attr,\n    mp_emit_bc_dup_top,\n    mp_emit_bc_dup_top_two,\n    mp_emit_bc_pop_top,\n    mp_emit_bc_rot_two,\n    mp_emit_bc_rot_three,\n    mp_emit_bc_jump,\n    mp_emit_bc_pop_jump_if,\n    mp_emit_bc_jump_if_or_pop,\n    mp_emit_bc_unwind_jump,\n    mp_emit_bc_setup_block,\n    mp_emit_bc_with_cleanup,\n    mp_emit_bc_end_finally,\n    mp_emit_bc_get_iter,\n    mp_emit_bc_for_iter,\n    mp_emit_bc_for_iter_end,\n    mp_emit_bc_pop_except_jump,\n    mp_emit_bc_unary_op,\n    mp_emit_bc_binary_op,\n    mp_emit_bc_build,\n    mp_emit_bc_store_map,\n    mp_emit_bc_store_comp,\n    mp_emit_bc_unpack_sequence,\n    mp_emit_bc_unpack_ex,\n    mp_emit_bc_make_function,\n    mp_emit_bc_make_closure,\n    mp_emit_bc_call_function,\n    mp_emit_bc_call_method,\n    mp_emit_bc_return_value,\n    mp_emit_bc_raise_varargs,\n    mp_emit_bc_yield,\n\n    mp_emit_bc_start_except_handler,\n    mp_emit_bc_end_except_handler,\n};\n#else\nconst mp_emit_method_table_id_ops_t mp_emit_bc_method_table_load_id_ops = {\n    mp_emit_bc_load_local,\n    mp_emit_bc_load_global,\n};\n\nconst mp_emit_method_table_id_ops_t mp_emit_bc_method_table_store_id_ops = {\n    mp_emit_bc_store_local,\n    mp_emit_bc_store_global,\n};\n\nconst mp_emit_method_table_id_ops_t mp_emit_bc_method_table_delete_id_ops = {\n    mp_emit_bc_delete_local,\n    mp_emit_bc_delete_global,\n};\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}