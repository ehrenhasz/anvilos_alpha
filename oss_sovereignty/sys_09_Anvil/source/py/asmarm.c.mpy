{
  "module_name": "asmarm.c",
  "hash_id": "279fdee1738511f34fc8dcf4e6df6fcc0e44bf32789f172f470389116f704013",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/asmarm.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\n#include \"py/mpconfig.h\"\n\n\n#if MICROPY_EMIT_ARM\n\n#include \"py/asmarm.h\"\n\n#define SIGNED_FIT24(x) (((x) & 0xff800000) == 0) || (((x) & 0xff000000) == 0xff000000)\n\n\nstatic void emit(asm_arm_t *as, uint op) {\n    uint8_t *c = mp_asm_base_get_cur_to_write_bytes(&as->base, 4);\n    if (c != NULL) {\n        *(uint32_t *)c = op;\n    }\n}\n\n\nstatic void emit_al(asm_arm_t *as, uint op) {\n    emit(as, op | ASM_ARM_CC_AL);\n}\n\n\nstatic uint asm_arm_op_push(uint reglist) {\n    \n    return 0x92d0000 | (reglist & 0xFFFF);\n}\n\nstatic uint asm_arm_op_pop(uint reglist) {\n    \n    return 0x8bd0000 | (reglist & 0xFFFF);\n}\n\nstatic uint asm_arm_op_mov_reg(uint rd, uint rn) {\n    \n    return 0x1a00000 | (rd << 12) | rn;\n}\n\nstatic uint asm_arm_op_mov_imm(uint rd, uint imm) {\n    \n    return 0x3a00000 | (rd << 12) | imm;\n}\n\nstatic uint asm_arm_op_mvn_imm(uint rd, uint imm) {\n    \n    return 0x3e00000 | (rd << 12) | imm;\n}\n\nstatic uint asm_arm_op_mvn_reg(uint rd, uint rm) {\n    \n    return 0x1e00000 | (rd << 12) | rm;\n}\n\nstatic uint asm_arm_op_add_imm(uint rd, uint rn, uint imm) {\n    \n    return 0x2800000 | (rn << 16) | (rd << 12) | (imm & 0xFF);\n}\n\nstatic uint asm_arm_op_add_reg(uint rd, uint rn, uint rm) {\n    \n    return 0x0800000 | (rn << 16) | (rd << 12) | rm;\n}\n\nstatic uint asm_arm_op_sub_imm(uint rd, uint rn, uint imm) {\n    \n    return 0x2400000 | (rn << 16) | (rd << 12) | (imm & 0xFF);\n}\n\nstatic uint asm_arm_op_sub_reg(uint rd, uint rn, uint rm) {\n    \n    return 0x0400000 | (rn << 16) | (rd << 12) | rm;\n}\n\nstatic uint asm_arm_op_rsb_imm(uint rd, uint rn, uint imm) {\n    \n    return 0x2600000 | (rn << 16) | (rd << 12) | (imm & 0xFF);\n}\n\nstatic uint asm_arm_op_mul_reg(uint rd, uint rm, uint rs) {\n    \n    assert(rd != rm);\n    return 0x0000090 | (rd << 16) | (rs << 8) | rm;\n}\n\nstatic uint asm_arm_op_and_reg(uint rd, uint rn, uint rm) {\n    \n    return 0x0000000 | (rn << 16) | (rd << 12) | rm;\n}\n\nstatic uint asm_arm_op_eor_reg(uint rd, uint rn, uint rm) {\n    \n    return 0x0200000 | (rn << 16) | (rd << 12) | rm;\n}\n\nstatic uint asm_arm_op_orr_reg(uint rd, uint rn, uint rm) {\n    \n    return 0x1800000 | (rn << 16) | (rd << 12) | rm;\n}\n\nvoid asm_arm_bkpt(asm_arm_t *as) {\n    \n    emit_al(as, 0x1200070);\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid asm_arm_entry(asm_arm_t *as, int num_locals) {\n    assert(num_locals >= 0);\n\n    as->stack_adjust = 0;\n    as->push_reglist = 1 << ASM_ARM_REG_R1\n        | 1 << ASM_ARM_REG_R2\n        | 1 << ASM_ARM_REG_R3\n        | 1 << ASM_ARM_REG_R4\n        | 1 << ASM_ARM_REG_R5\n        | 1 << ASM_ARM_REG_R6\n        | 1 << ASM_ARM_REG_R7\n        | 1 << ASM_ARM_REG_R8;\n\n    \n    if (num_locals > 3) {\n        as->stack_adjust = num_locals * 4;\n        \n        if (num_locals & 1) {\n            as->stack_adjust += 4;\n        }\n    }\n\n    emit_al(as, asm_arm_op_push(as->push_reglist | 1 << ASM_ARM_REG_LR));\n    if (as->stack_adjust > 0) {\n        emit_al(as, asm_arm_op_sub_imm(ASM_ARM_REG_SP, ASM_ARM_REG_SP, as->stack_adjust));\n    }\n}\n\nvoid asm_arm_exit(asm_arm_t *as) {\n    if (as->stack_adjust > 0) {\n        emit_al(as, asm_arm_op_add_imm(ASM_ARM_REG_SP, ASM_ARM_REG_SP, as->stack_adjust));\n    }\n\n    emit_al(as, asm_arm_op_pop(as->push_reglist | (1 << ASM_ARM_REG_PC)));\n}\n\nvoid asm_arm_push(asm_arm_t *as, uint reglist) {\n    emit_al(as, asm_arm_op_push(reglist));\n}\n\nvoid asm_arm_pop(asm_arm_t *as, uint reglist) {\n    emit_al(as, asm_arm_op_pop(reglist));\n}\n\nvoid asm_arm_mov_reg_reg(asm_arm_t *as, uint reg_dest, uint reg_src) {\n    emit_al(as, asm_arm_op_mov_reg(reg_dest, reg_src));\n}\n\nsize_t asm_arm_mov_reg_i32(asm_arm_t *as, uint rd, int imm) {\n    \n    emit_al(as, 0x59f0000 | (rd << 12)); \n    emit_al(as, 0xa000000); \n    size_t loc = mp_asm_base_get_code_pos(&as->base);\n    emit(as, imm);\n    return loc;\n}\n\nvoid asm_arm_mov_reg_i32_optimised(asm_arm_t *as, uint rd, int imm) {\n    \n    if ((imm & 0xFF) == imm) {\n        emit_al(as, asm_arm_op_mov_imm(rd, imm));\n    } else if (imm < 0 && imm >= -256) {\n        \n        emit_al(as, asm_arm_op_mvn_imm(rd, ~imm));\n    } else {\n        asm_arm_mov_reg_i32(as, rd, imm);\n    }\n}\n\nvoid asm_arm_mov_local_reg(asm_arm_t *as, int local_num, uint rd) {\n    \n    emit_al(as, 0x58d0000 | (rd << 12) | (local_num << 2));\n}\n\nvoid asm_arm_mov_reg_local(asm_arm_t *as, uint rd, int local_num) {\n    \n    emit_al(as, 0x59d0000 | (rd << 12) | (local_num << 2));\n}\n\nvoid asm_arm_cmp_reg_i8(asm_arm_t *as, uint rd, int imm) {\n    \n    emit_al(as, 0x3500000 | (rd << 16) | (imm & 0xFF));\n}\n\nvoid asm_arm_cmp_reg_reg(asm_arm_t *as, uint rd, uint rn) {\n    \n    emit_al(as, 0x1500000 | (rd << 16) | rn);\n}\n\nvoid asm_arm_setcc_reg(asm_arm_t *as, uint rd, uint cond) {\n    emit(as, asm_arm_op_mov_imm(rd, 1) | cond); \n    emit(as, asm_arm_op_mov_imm(rd, 0) | (cond ^ (1 << 28))); \n}\n\nvoid asm_arm_mvn_reg_reg(asm_arm_t *as, uint rd, uint rm) {\n    \n    \n    emit_al(as, asm_arm_op_mvn_reg(rd, rm));\n}\n\nvoid asm_arm_add_reg_reg_reg(asm_arm_t *as, uint rd, uint rn, uint rm) {\n    \n    emit_al(as, asm_arm_op_add_reg(rd, rn, rm));\n}\n\nvoid asm_arm_rsb_reg_reg_imm(asm_arm_t *as, uint rd, uint rn, uint imm) {\n    \n    \n    emit_al(as, asm_arm_op_rsb_imm(rd, rn, imm));\n}\n\nvoid asm_arm_sub_reg_reg_reg(asm_arm_t *as, uint rd, uint rn, uint rm) {\n    \n    emit_al(as, asm_arm_op_sub_reg(rd, rn, rm));\n}\n\nvoid asm_arm_mul_reg_reg_reg(asm_arm_t *as, uint rd, uint rs, uint rm) {\n    \n    \n    emit_al(as, asm_arm_op_mul_reg(rd, rm, rs));\n}\n\nvoid asm_arm_and_reg_reg_reg(asm_arm_t *as, uint rd, uint rn, uint rm) {\n    \n    emit_al(as, asm_arm_op_and_reg(rd, rn, rm));\n}\n\nvoid asm_arm_eor_reg_reg_reg(asm_arm_t *as, uint rd, uint rn, uint rm) {\n    \n    emit_al(as, asm_arm_op_eor_reg(rd, rn, rm));\n}\n\nvoid asm_arm_orr_reg_reg_reg(asm_arm_t *as, uint rd, uint rn, uint rm) {\n    \n    emit_al(as, asm_arm_op_orr_reg(rd, rn, rm));\n}\n\nvoid asm_arm_mov_reg_local_addr(asm_arm_t *as, uint rd, int local_num) {\n    \n    emit_al(as, asm_arm_op_add_imm(rd, ASM_ARM_REG_SP, local_num << 2));\n}\n\nvoid asm_arm_mov_reg_pcrel(asm_arm_t *as, uint reg_dest, uint label) {\n    assert(label < as->base.max_num_labels);\n    mp_uint_t dest = as->base.label_offsets[label];\n    mp_int_t rel = dest - as->base.code_offset;\n    rel -= 12 + 8; \n\n    \n    emit_al(as, 0x59f0000 | (reg_dest << 12)); \n    emit_al(as, 0xa000000); \n    emit(as, rel);\n\n    \n    asm_arm_add_reg_reg_reg(as, reg_dest, reg_dest, ASM_ARM_REG_PC);\n}\n\nvoid asm_arm_lsl_reg_reg(asm_arm_t *as, uint rd, uint rs) {\n    \n    emit_al(as, 0x1a00010 | (rd << 12) | (rs << 8) | rd);\n}\n\nvoid asm_arm_lsr_reg_reg(asm_arm_t *as, uint rd, uint rs) {\n    \n    emit_al(as, 0x1a00030 | (rd << 12) | (rs << 8) | rd);\n}\n\nvoid asm_arm_asr_reg_reg(asm_arm_t *as, uint rd, uint rs) {\n    \n    emit_al(as, 0x1a00050 | (rd << 12) | (rs << 8) | rd);\n}\n\nvoid asm_arm_ldr_reg_reg(asm_arm_t *as, uint rd, uint rn, uint byte_offset) {\n    \n    emit_al(as, 0x5900000 | (rn << 16) | (rd << 12) | byte_offset);\n}\n\nvoid asm_arm_ldrh_reg_reg(asm_arm_t *as, uint rd, uint rn) {\n    \n    emit_al(as, 0x1d000b0 | (rn << 16) | (rd << 12));\n}\n\nvoid asm_arm_ldrh_reg_reg_offset(asm_arm_t *as, uint rd, uint rn, uint byte_offset) {\n    \n    emit_al(as, 0x1f000b0 | (rn << 16) | (rd << 12) | ((byte_offset & 0xf0) << 4) | (byte_offset & 0xf));\n}\n\nvoid asm_arm_ldrb_reg_reg(asm_arm_t *as, uint rd, uint rn) {\n    \n    emit_al(as, 0x5d00000 | (rn << 16) | (rd << 12));\n}\n\nvoid asm_arm_str_reg_reg(asm_arm_t *as, uint rd, uint rm, uint byte_offset) {\n    \n    emit_al(as, 0x5800000 | (rm << 16) | (rd << 12) | byte_offset);\n}\n\nvoid asm_arm_strh_reg_reg(asm_arm_t *as, uint rd, uint rm) {\n    \n    emit_al(as, 0x1c000b0 | (rm << 16) | (rd << 12));\n}\n\nvoid asm_arm_strb_reg_reg(asm_arm_t *as, uint rd, uint rm) {\n    \n    emit_al(as, 0x5c00000 | (rm << 16) | (rd << 12));\n}\n\nvoid asm_arm_str_reg_reg_reg(asm_arm_t *as, uint rd, uint rm, uint rn) {\n    \n    emit_al(as, 0x7800100 | (rm << 16) | (rd << 12) | rn);\n}\n\nvoid asm_arm_strh_reg_reg_reg(asm_arm_t *as, uint rd, uint rm, uint rn) {\n    \n    emit_al(as, 0x1a00080 | (ASM_ARM_REG_R8 << 12) | rn); \n    emit_al(as, 0x18000b0 | (rm << 16) | (rd << 12) | ASM_ARM_REG_R8); \n}\n\nvoid asm_arm_strb_reg_reg_reg(asm_arm_t *as, uint rd, uint rm, uint rn) {\n    \n    emit_al(as, 0x7c00000 | (rm << 16) | (rd << 12) | rn);\n}\n\nvoid asm_arm_bcc_label(asm_arm_t *as, int cond, uint label) {\n    assert(label < as->base.max_num_labels);\n    mp_uint_t dest = as->base.label_offsets[label];\n    mp_int_t rel = dest - as->base.code_offset;\n    rel -= 8; \n    rel >>= 2; \n\n    if (SIGNED_FIT24(rel)) {\n        emit(as, cond | 0xa000000 | (rel & 0xffffff));\n    } else {\n        printf(\"asm_arm_bcc: branch does not fit in 24 bits\\n\");\n    }\n}\n\nvoid asm_arm_b_label(asm_arm_t *as, uint label) {\n    asm_arm_bcc_label(as, ASM_ARM_CC_AL, label);\n}\n\nvoid asm_arm_bl_ind(asm_arm_t *as, uint fun_id, uint reg_temp) {\n    \n    assert(fun_id < (0x1000 / 4));\n    emit_al(as, asm_arm_op_mov_reg(ASM_ARM_REG_LR, ASM_ARM_REG_PC)); \n    emit_al(as, 0x597f000 | (fun_id << 2)); \n}\n\nvoid asm_arm_bx_reg(asm_arm_t *as, uint reg_src) {\n    emit_al(as, 0x012fff10 | reg_src);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}