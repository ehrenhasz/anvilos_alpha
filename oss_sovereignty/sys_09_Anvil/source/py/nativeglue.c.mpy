{
  "module_name": "nativeglue.c",
  "hash_id": "929ad109200f4c02d44f5283ef275aab735d8540dc730dc320a60fe2efb9fe8e",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/nativeglue.c",
  "human_readable_source": " \n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/binary.h\"\n#include \"py/runtime.h\"\n#include \"py/smallint.h\"\n#include \"py/nativeglue.h\"\n#include \"py/gc.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\n#if MICROPY_EMIT_NATIVE\n\nint mp_native_type_from_qstr(qstr qst) {\n    switch (qst) {\n        case MP_QSTR_object:\n            return MP_NATIVE_TYPE_OBJ;\n        case MP_QSTR_bool:\n            return MP_NATIVE_TYPE_BOOL;\n        case MP_QSTR_int:\n            return MP_NATIVE_TYPE_INT;\n        case MP_QSTR_uint:\n            return MP_NATIVE_TYPE_UINT;\n        case MP_QSTR_ptr:\n            return MP_NATIVE_TYPE_PTR;\n        case MP_QSTR_ptr8:\n            return MP_NATIVE_TYPE_PTR8;\n        case MP_QSTR_ptr16:\n            return MP_NATIVE_TYPE_PTR16;\n        case MP_QSTR_ptr32:\n            return MP_NATIVE_TYPE_PTR32;\n        default:\n            return -1;\n    }\n}\n\n\nmp_uint_t mp_native_from_obj(mp_obj_t obj, mp_uint_t type) {\n    DEBUG_printf(\"mp_native_from_obj(%p, \" UINT_FMT \")\\n\", obj, type);\n    switch (type & 0xf) {\n        case MP_NATIVE_TYPE_OBJ:\n            return (mp_uint_t)obj;\n        case MP_NATIVE_TYPE_BOOL:\n            return mp_obj_is_true(obj);\n        case MP_NATIVE_TYPE_INT:\n        case MP_NATIVE_TYPE_UINT:\n            return mp_obj_get_int_truncated(obj);\n        default: { \n            mp_buffer_info_t bufinfo;\n            if (mp_get_buffer(obj, &bufinfo, MP_BUFFER_READ)) {\n                return (mp_uint_t)bufinfo.buf;\n            } else {\n                \n                return mp_obj_get_int_truncated(obj);\n            }\n        }\n    }\n}\n\n#endif\n\n#if MICROPY_EMIT_MACHINE_CODE\n\n\nmp_obj_t mp_native_to_obj(mp_uint_t val, mp_uint_t type) {\n    DEBUG_printf(\"mp_native_to_obj(\" UINT_FMT \", \" UINT_FMT \")\\n\", val, type);\n    switch (type & 0xf) {\n        case MP_NATIVE_TYPE_OBJ:\n            return (mp_obj_t)val;\n        case MP_NATIVE_TYPE_BOOL:\n            return mp_obj_new_bool(val);\n        case MP_NATIVE_TYPE_INT:\n            return mp_obj_new_int(val);\n        case MP_NATIVE_TYPE_UINT:\n            return mp_obj_new_int_from_uint(val);\n        case MP_NATIVE_TYPE_QSTR:\n            return MP_OBJ_NEW_QSTR(val);\n        default: \n            \n            return mp_obj_new_int_from_uint(val);\n    }\n}\n\n#endif\n\n#if MICROPY_EMIT_NATIVE && !MICROPY_DYNAMIC_COMPILER\n\n#if !MICROPY_PY_BUILTINS_SET\nmp_obj_t mp_obj_new_set(size_t n_args, mp_obj_t *items) {\n    (void)n_args;\n    (void)items;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"set unsupported\"));\n}\n\nvoid mp_obj_set_store(mp_obj_t self_in, mp_obj_t item) {\n    (void)self_in;\n    (void)item;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"set unsupported\"));\n}\n#endif\n\n#if !MICROPY_PY_BUILTINS_SLICE\nmp_obj_t mp_obj_new_slice(mp_obj_t ostart, mp_obj_t ostop, mp_obj_t ostep) {\n    (void)ostart;\n    (void)ostop;\n    (void)ostep;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"slice unsupported\"));\n}\n#endif\n\nstatic mp_obj_dict_t *mp_native_swap_globals(mp_obj_dict_t *new_globals) {\n    if (new_globals == NULL) {\n        \n        return NULL;\n    }\n    mp_obj_dict_t *old_globals = mp_globals_get();\n    if (old_globals == new_globals) {\n        \n        return NULL;\n    }\n    mp_globals_set(new_globals);\n    return old_globals;\n}\n\n\n\nstatic mp_obj_t mp_native_call_function_n_kw(mp_obj_t fun_in, size_t n_args_kw, const mp_obj_t *args) {\n    return mp_call_function_n_kw(fun_in, n_args_kw & 0xff, (n_args_kw >> 8) & 0xff, args);\n}\n\n\n\nstatic void mp_native_raise(mp_obj_t o) {\n    if (o != MP_OBJ_NULL && o != mp_const_none) {\n        nlr_raise(mp_make_raise_obj(o));\n    }\n}\n\n\nstatic mp_obj_t mp_native_getiter(mp_obj_t obj, mp_obj_iter_buf_t *iter) {\n    if (iter == NULL) {\n        return mp_getiter(obj, NULL);\n    } else {\n        obj = mp_getiter(obj, iter);\n        if (obj != MP_OBJ_FROM_PTR(iter)) {\n            \n            iter->base.type = MP_OBJ_NULL;\n            iter->buf[0] = obj;\n        }\n        return NULL;\n    }\n}\n\n\nstatic mp_obj_t mp_native_iternext(mp_obj_iter_buf_t *iter) {\n    mp_obj_t obj;\n    if (iter->base.type == MP_OBJ_NULL) {\n        obj = iter->buf[0];\n    } else {\n        obj = MP_OBJ_FROM_PTR(iter);\n    }\n    return mp_iternext(obj);\n}\n\nstatic bool mp_native_yield_from(mp_obj_t gen, mp_obj_t send_value, mp_obj_t *ret_value) {\n    mp_vm_return_kind_t ret_kind;\n    nlr_buf_t nlr_buf;\n    mp_obj_t throw_value = *ret_value;\n    if (nlr_push(&nlr_buf) == 0) {\n        if (throw_value != MP_OBJ_NULL) {\n            send_value = MP_OBJ_NULL;\n        }\n        ret_kind = mp_resume(gen, send_value, throw_value, ret_value);\n        nlr_pop();\n    } else {\n        ret_kind = MP_VM_RETURN_EXCEPTION;\n        *ret_value = nlr_buf.ret_val;\n    }\n\n    if (ret_kind == MP_VM_RETURN_YIELD) {\n        return true;\n    } else if (ret_kind == MP_VM_RETURN_NORMAL) {\n        if (*ret_value == MP_OBJ_STOP_ITERATION) {\n            *ret_value = mp_const_none;\n        }\n    } else {\n        assert(ret_kind == MP_VM_RETURN_EXCEPTION);\n        if (!mp_obj_exception_match(*ret_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {\n            nlr_raise(*ret_value);\n        }\n        *ret_value = mp_obj_exception_get_value(*ret_value);\n    }\n\n    if (throw_value != MP_OBJ_NULL && mp_obj_exception_match(throw_value, MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {\n        nlr_raise(mp_make_raise_obj(throw_value));\n    }\n\n    return false;\n}\n\n#if !MICROPY_PY_BUILTINS_FLOAT\n\nstatic mp_obj_t mp_obj_new_float_from_f(float f) {\n    (void)f;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"float unsupported\"));\n}\n\nstatic mp_obj_t mp_obj_new_float_from_d(double d) {\n    (void)d;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"float unsupported\"));\n}\n\nstatic float mp_obj_get_float_to_f(mp_obj_t o) {\n    (void)o;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"float unsupported\"));\n}\n\nstatic double mp_obj_get_float_to_d(mp_obj_t o) {\n    (void)o;\n    mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"float unsupported\"));\n}\n\n#endif\n\n\nconst mp_fun_table_t mp_fun_table = {\n    mp_const_none,\n    mp_const_false,\n    mp_const_true,\n    mp_native_from_obj,\n    mp_native_to_obj,\n    mp_native_swap_globals,\n    mp_load_name,\n    mp_load_global,\n    mp_load_build_class,\n    mp_load_attr,\n    mp_load_method,\n    mp_load_super_method,\n    mp_store_name,\n    mp_store_global,\n    mp_store_attr,\n    mp_obj_subscr,\n    mp_obj_is_true,\n    mp_unary_op,\n    mp_binary_op,\n    mp_obj_new_tuple,\n    mp_obj_new_list,\n    mp_obj_new_dict,\n    mp_obj_new_set,\n    mp_obj_set_store,\n    mp_obj_list_append,\n    mp_obj_dict_store,\n    mp_make_function_from_proto_fun,\n    mp_native_call_function_n_kw,\n    mp_call_method_n_kw,\n    mp_call_method_n_kw_var,\n    mp_native_getiter,\n    mp_native_iternext,\n    #if MICROPY_NLR_SETJMP\n    nlr_push_tail,\n    #else\n    nlr_push,\n    #endif\n    nlr_pop,\n    mp_native_raise,\n    mp_import_name,\n    mp_import_from,\n    mp_import_all,\n    mp_obj_new_slice,\n    mp_unpack_sequence,\n    mp_unpack_ex,\n    mp_delete_name,\n    mp_delete_global,\n    mp_obj_new_closure,\n    mp_arg_check_num_sig,\n    mp_setup_code_state_native,\n    mp_small_int_floor_divide,\n    mp_small_int_modulo,\n    mp_native_yield_from,\n    #if MICROPY_NLR_SETJMP\n    setjmp,\n    #else\n    NULL,\n    #endif\n    \n    memset,\n    memmove,\n    gc_realloc,\n    mp_printf,\n    mp_vprintf,\n    mp_raise_msg,\n    mp_obj_get_type,\n    mp_obj_new_str,\n    mp_obj_new_bytes,\n    mp_obj_new_bytearray_by_ref,\n    mp_obj_new_float_from_f,\n    mp_obj_new_float_from_d,\n    mp_obj_get_float_to_f,\n    mp_obj_get_float_to_d,\n    mp_load_method_maybe,\n    mp_get_buffer,\n    mp_get_stream_raise,\n    mp_arg_parse_all,\n    mp_arg_parse_all_kw_array,\n    mp_binary_get_size,\n    mp_binary_get_val_array,\n    mp_binary_set_val_array,\n    &mp_plat_print,\n    &mp_type_type,\n    &mp_type_str,\n    &mp_type_list,\n    &mp_type_dict,\n    &mp_type_fun_builtin_0,\n    &mp_type_fun_builtin_1,\n    &mp_type_fun_builtin_2,\n    &mp_type_fun_builtin_3,\n    &mp_type_fun_builtin_var,\n    &mp_type_Exception,\n    &mp_stream_read_obj,\n    &mp_stream_readinto_obj,\n    &mp_stream_unbuffered_readline_obj,\n    &mp_stream_write_obj,\n};\n\n#elif MICROPY_EMIT_NATIVE && MICROPY_DYNAMIC_COMPILER\n\nconst int mp_fun_table;\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}