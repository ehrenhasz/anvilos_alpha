{
  "module_name": "lexer.c",
  "hash_id": "9aa1227313fb5141e11cff8d4d01ba95720599cd6b5cf895642ae18d85e81a4c",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/lexer.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/reader.h\"\n#include \"py/lexer.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_ENABLE_COMPILER\n\n#define TAB_SIZE (8)\n\n\n\n\n#define MP_LEXER_EOF ((unichar)MP_READER_EOF)\n#define CUR_CHAR(lex) ((lex)->chr0)\n\nstatic bool is_end(mp_lexer_t *lex) {\n    return lex->chr0 == MP_LEXER_EOF;\n}\n\nstatic bool is_physical_newline(mp_lexer_t *lex) {\n    return lex->chr0 == '\\n';\n}\n\nstatic bool is_char(mp_lexer_t *lex, byte c) {\n    return lex->chr0 == c;\n}\n\nstatic bool is_char_or(mp_lexer_t *lex, byte c1, byte c2) {\n    return lex->chr0 == c1 || lex->chr0 == c2;\n}\n\nstatic bool is_char_or3(mp_lexer_t *lex, byte c1, byte c2, byte c3) {\n    return lex->chr0 == c1 || lex->chr0 == c2 || lex->chr0 == c3;\n}\n\n#if MICROPY_PY_FSTRINGS\nstatic bool is_char_or4(mp_lexer_t *lex, byte c1, byte c2, byte c3, byte c4) {\n    return lex->chr0 == c1 || lex->chr0 == c2 || lex->chr0 == c3 || lex->chr0 == c4;\n}\n#endif\n\nstatic bool is_char_following(mp_lexer_t *lex, byte c) {\n    return lex->chr1 == c;\n}\n\nstatic bool is_char_following_or(mp_lexer_t *lex, byte c1, byte c2) {\n    return lex->chr1 == c1 || lex->chr1 == c2;\n}\n\nstatic bool is_char_following_following_or(mp_lexer_t *lex, byte c1, byte c2) {\n    return lex->chr2 == c1 || lex->chr2 == c2;\n}\n\nstatic bool is_char_and(mp_lexer_t *lex, byte c1, byte c2) {\n    return lex->chr0 == c1 && lex->chr1 == c2;\n}\n\nstatic bool is_whitespace(mp_lexer_t *lex) {\n    return unichar_isspace(lex->chr0);\n}\n\nstatic bool is_letter(mp_lexer_t *lex) {\n    return unichar_isalpha(lex->chr0);\n}\n\nstatic bool is_digit(mp_lexer_t *lex) {\n    return unichar_isdigit(lex->chr0);\n}\n\nstatic bool is_following_digit(mp_lexer_t *lex) {\n    return unichar_isdigit(lex->chr1);\n}\n\nstatic bool is_following_base_char(mp_lexer_t *lex) {\n    const unichar chr1 = lex->chr1 | 0x20;\n    return chr1 == 'b' || chr1 == 'o' || chr1 == 'x';\n}\n\nstatic bool is_following_odigit(mp_lexer_t *lex) {\n    return lex->chr1 >= '0' && lex->chr1 <= '7';\n}\n\nstatic bool is_string_or_bytes(mp_lexer_t *lex) {\n    return is_char_or(lex, '\\'', '\\\"')\n           #if MICROPY_PY_FSTRINGS\n           || (is_char_or4(lex, 'r', 'u', 'b', 'f') && is_char_following_or(lex, '\\'', '\\\"'))\n           || (((is_char_and(lex, 'r', 'f') || is_char_and(lex, 'f', 'r'))\n               && is_char_following_following_or(lex, '\\'', '\\\"')))\n           #else\n           || (is_char_or3(lex, 'r', 'u', 'b') && is_char_following_or(lex, '\\'', '\\\"'))\n           #endif\n           || ((is_char_and(lex, 'r', 'b') || is_char_and(lex, 'b', 'r'))\n               && is_char_following_following_or(lex, '\\'', '\\\"'));\n}\n\n\nstatic bool is_head_of_identifier(mp_lexer_t *lex) {\n    return is_letter(lex) || lex->chr0 == '_' || lex->chr0 >= 0x80;\n}\n\nstatic bool is_tail_of_identifier(mp_lexer_t *lex) {\n    return is_head_of_identifier(lex) || is_digit(lex);\n}\n\nstatic void next_char(mp_lexer_t *lex) {\n    if (lex->chr0 == '\\n') {\n        \n        ++lex->line;\n        lex->column = 1;\n    } else if (lex->chr0 == '\\t') {\n        \n        lex->column = (((lex->column - 1 + TAB_SIZE) / TAB_SIZE) * TAB_SIZE) + 1;\n    } else {\n        \n        ++lex->column;\n    }\n\n    \n    lex->chr0 = lex->chr1;\n    lex->chr1 = lex->chr2;\n\n    \n    #if MICROPY_PY_FSTRINGS\n    if (lex->fstring_args_idx) {\n        \n        if (lex->fstring_args_idx < lex->fstring_args.len) {\n            lex->chr2 = lex->fstring_args.buf[lex->fstring_args_idx++];\n        } else {\n            \n            lex->chr2 = '\\0';\n        }\n\n        if (lex->chr0 == '\\0') {\n            \n            lex->chr0 = lex->chr0_saved;\n            lex->chr1 = lex->chr1_saved;\n            lex->chr2 = lex->chr2_saved;\n            \n            vstr_reset(&lex->fstring_args);\n            lex->fstring_args_idx = 0;\n        }\n    } else\n    #endif\n    {\n        lex->chr2 = lex->reader.readbyte(lex->reader.data);\n    }\n\n    if (lex->chr1 == '\\r') {\n        \n        lex->chr1 = '\\n';\n        if (lex->chr2 == '\\n') {\n            \n            lex->chr2 = lex->reader.readbyte(lex->reader.data);\n        }\n    }\n\n    \n    if (lex->chr2 == MP_LEXER_EOF && lex->chr1 != MP_LEXER_EOF && lex->chr1 != '\\n') {\n        lex->chr2 = '\\n';\n    }\n}\n\nstatic void indent_push(mp_lexer_t *lex, size_t indent) {\n    if (lex->num_indent_level >= lex->alloc_indent_level) {\n        lex->indent_level = m_renew(uint16_t, lex->indent_level, lex->alloc_indent_level, lex->alloc_indent_level + MICROPY_ALLOC_LEXEL_INDENT_INC);\n        lex->alloc_indent_level += MICROPY_ALLOC_LEXEL_INDENT_INC;\n    }\n    lex->indent_level[lex->num_indent_level++] = indent;\n}\n\nstatic size_t indent_top(mp_lexer_t *lex) {\n    return lex->indent_level[lex->num_indent_level - 1];\n}\n\nstatic void indent_pop(mp_lexer_t *lex) {\n    lex->num_indent_level -= 1;\n}\n\n\n\n\n\n\n\nstatic const char *const tok_enc =\n    \"()[]{},;~\"   \n    \":e=\"         \n    \"<e=c<e=\"     \n    \">e=c>e=\"     \n    \"*e=c*e=\"     \n    \"+e=\"         \n    \"-e=e>\"       \n    \"&e=\"         \n    \"|e=\"         \n    \"/e=c/e=\"     \n    \"%e=\"         \n    \"^e=\"         \n    \"@e=\"         \n    \"=e=\"         \n    \"!.\";         \n\n\nstatic const uint8_t tok_enc_kind[] = {\n    MP_TOKEN_DEL_PAREN_OPEN, MP_TOKEN_DEL_PAREN_CLOSE,\n    MP_TOKEN_DEL_BRACKET_OPEN, MP_TOKEN_DEL_BRACKET_CLOSE,\n    MP_TOKEN_DEL_BRACE_OPEN, MP_TOKEN_DEL_BRACE_CLOSE,\n    MP_TOKEN_DEL_COMMA, MP_TOKEN_DEL_SEMICOLON, MP_TOKEN_OP_TILDE,\n\n    MP_TOKEN_DEL_COLON, MP_TOKEN_OP_ASSIGN,\n    MP_TOKEN_OP_LESS, MP_TOKEN_OP_LESS_EQUAL, MP_TOKEN_OP_DBL_LESS, MP_TOKEN_DEL_DBL_LESS_EQUAL,\n    MP_TOKEN_OP_MORE, MP_TOKEN_OP_MORE_EQUAL, MP_TOKEN_OP_DBL_MORE, MP_TOKEN_DEL_DBL_MORE_EQUAL,\n    MP_TOKEN_OP_STAR, MP_TOKEN_DEL_STAR_EQUAL, MP_TOKEN_OP_DBL_STAR, MP_TOKEN_DEL_DBL_STAR_EQUAL,\n    MP_TOKEN_OP_PLUS, MP_TOKEN_DEL_PLUS_EQUAL,\n    MP_TOKEN_OP_MINUS, MP_TOKEN_DEL_MINUS_EQUAL, MP_TOKEN_DEL_MINUS_MORE,\n    MP_TOKEN_OP_AMPERSAND, MP_TOKEN_DEL_AMPERSAND_EQUAL,\n    MP_TOKEN_OP_PIPE, MP_TOKEN_DEL_PIPE_EQUAL,\n    MP_TOKEN_OP_SLASH, MP_TOKEN_DEL_SLASH_EQUAL, MP_TOKEN_OP_DBL_SLASH, MP_TOKEN_DEL_DBL_SLASH_EQUAL,\n    MP_TOKEN_OP_PERCENT, MP_TOKEN_DEL_PERCENT_EQUAL,\n    MP_TOKEN_OP_CARET, MP_TOKEN_DEL_CARET_EQUAL,\n    MP_TOKEN_OP_AT, MP_TOKEN_DEL_AT_EQUAL,\n    MP_TOKEN_DEL_EQUAL, MP_TOKEN_OP_DBL_EQUAL,\n};\n\n\n\nstatic const char *const tok_kw[] = {\n    \"False\",\n    \"None\",\n    \"True\",\n    \"__debug__\",\n    \"and\",\n    \"as\",\n    \"assert\",\n    #if MICROPY_PY_ASYNC_AWAIT\n    \"async\",\n    \"await\",\n    #endif\n    \"break\",\n    \"class\",\n    \"continue\",\n    \"def\",\n    \"del\",\n    \"elif\",\n    \"else\",\n    \"except\",\n    \"finally\",\n    \"for\",\n    \"from\",\n    \"global\",\n    \"if\",\n    \"import\",\n    \"in\",\n    \"is\",\n    \"lambda\",\n    \"nonlocal\",\n    \"not\",\n    \"or\",\n    \"pass\",\n    \"raise\",\n    \"return\",\n    \"try\",\n    \"while\",\n    \"with\",\n    \"yield\",\n};\n\n\n\n\nstatic bool get_hex(mp_lexer_t *lex, size_t num_digits, mp_uint_t *result) {\n    mp_uint_t num = 0;\n    while (num_digits-- != 0) {\n        next_char(lex);\n        unichar c = CUR_CHAR(lex);\n        if (!unichar_isxdigit(c)) {\n            return false;\n        }\n        num = (num << 4) + unichar_xdigit_value(c);\n    }\n    *result = num;\n    return true;\n}\n\nstatic void parse_string_literal(mp_lexer_t *lex, bool is_raw, bool is_fstring) {\n    \n    char quote_char = '\\'';\n    if (is_char(lex, '\\\"')) {\n        quote_char = '\\\"';\n    }\n    next_char(lex);\n\n    \n    size_t num_quotes;\n    if (is_char_and(lex, quote_char, quote_char)) {\n        \n        next_char(lex);\n        next_char(lex);\n        num_quotes = 3;\n    } else {\n        \n        num_quotes = 1;\n    }\n\n    size_t n_closing = 0;\n    #if MICROPY_PY_FSTRINGS\n    if (is_fstring) {\n        \n        \n        \n        \n        vstr_add_str(&lex->fstring_args, \".format(\");\n    }\n    #endif\n\n    while (!is_end(lex) && (num_quotes > 1 || !is_char(lex, '\\n')) && n_closing < num_quotes) {\n        if (is_char(lex, quote_char)) {\n            n_closing += 1;\n            vstr_add_char(&lex->vstr, CUR_CHAR(lex));\n        } else {\n            n_closing = 0;\n\n            #if MICROPY_PY_FSTRINGS\n            while (is_fstring && is_char(lex, '{')) {\n                next_char(lex);\n                if (is_char(lex, '{')) {\n                    \n                    vstr_add_byte(&lex->vstr, '{');\n                    next_char(lex);\n                } else {\n                    \n                    \n                    vstr_add_byte(&lex->fstring_args, '(');\n                    \n                    size_t i = lex->fstring_args.len;\n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    \n                    unsigned int nested_bracket_level = 0;\n                    while (!is_end(lex) && (nested_bracket_level != 0\n                                            || !(is_char_or(lex, ':', '}')\n                                                 || (is_char(lex, '!')\n                                                     && is_char_following_or(lex, 'r', 's')\n                                                     && is_char_following_following_or(lex, ':', '}'))))\n                           ) {\n                        unichar c = CUR_CHAR(lex);\n                        if (c == '[' || c == '{') {\n                            nested_bracket_level += 1;\n                        } else if (c == ']' || c == '}') {\n                            nested_bracket_level -= 1;\n                        }\n                        \n                        vstr_add_byte(&lex->fstring_args, c);\n                        next_char(lex);\n                    }\n                    if (lex->fstring_args.buf[lex->fstring_args.len - 1] == '=') {\n                        \n                        \n                        vstr_add_strn(&lex->vstr, lex->fstring_args.buf + i, lex->fstring_args.len - i);\n                        \n                        lex->fstring_args.len--;\n                    }\n                    \n                    vstr_add_byte(&lex->fstring_args, ')');\n                    \n                    vstr_add_byte(&lex->fstring_args, ',');\n                }\n                vstr_add_byte(&lex->vstr, '{');\n            }\n            #endif\n\n            if (is_char(lex, '\\\\')) {\n                next_char(lex);\n                unichar c = CUR_CHAR(lex);\n                if (is_raw) {\n                    \n                    vstr_add_char(&lex->vstr, '\\\\');\n                } else {\n                    switch (c) {\n                        \n                        \n                        case '\\n':\n                            c = MP_LEXER_EOF;\n                            break;                          \n                        case '\\\\':\n                            break;\n                        case '\\'':\n                            break;\n                        case '\"':\n                            break;\n                        case 'a':\n                            c = 0x07;\n                            break;\n                        case 'b':\n                            c = 0x08;\n                            break;\n                        case 't':\n                            c = 0x09;\n                            break;\n                        case 'n':\n                            c = 0x0a;\n                            break;\n                        case 'v':\n                            c = 0x0b;\n                            break;\n                        case 'f':\n                            c = 0x0c;\n                            break;\n                        case 'r':\n                            c = 0x0d;\n                            break;\n                        case 'u':\n                        case 'U':\n                            if (lex->tok_kind == MP_TOKEN_BYTES) {\n                                \n                                vstr_add_char(&lex->vstr, '\\\\');\n                                break;\n                            }\n                            \n                            MP_FALLTHROUGH\n                        case 'x': {\n                            mp_uint_t num = 0;\n                            if (!get_hex(lex, (c == 'x' ? 2 : c == 'u' ? 4 : 8), &num)) {\n                                \n                                lex->tok_kind = MP_TOKEN_INVALID;\n                            }\n                            c = num;\n                            break;\n                        }\n                        case 'N':\n                            \n                            \n                            \n                            \n                            \n                            mp_raise_NotImplementedError(MP_ERROR_TEXT(\"unicode name escapes\"));\n                            break;\n                        default:\n                            if (c >= '0' && c <= '7') {\n                                \n                                size_t digits = 3;\n                                mp_uint_t num = c - '0';\n                                while (is_following_odigit(lex) && --digits != 0) {\n                                    next_char(lex);\n                                    num = num * 8 + (CUR_CHAR(lex) - '0');\n                                }\n                                c = num;\n                            } else {\n                                \n                                vstr_add_char(&lex->vstr, '\\\\');\n                            }\n                            break;\n                    }\n                }\n                if (c != MP_LEXER_EOF) {\n                    #if MICROPY_PY_BUILTINS_STR_UNICODE\n                    if (c < 0x110000 && lex->tok_kind == MP_TOKEN_STRING) {\n                        \n                        vstr_add_char(&lex->vstr, c);\n                    } else if (c < 0x100 && lex->tok_kind == MP_TOKEN_BYTES) {\n                        \n                        vstr_add_byte(&lex->vstr, c);\n                    }\n                    #else\n                    if (c < 0x100) {\n                        \n                        vstr_add_byte(&lex->vstr, c);\n                    }\n                    #endif\n                    else {\n                        \n                        lex->tok_kind = MP_TOKEN_INVALID;\n                    }\n                }\n            } else {\n                \n                \n                vstr_add_byte(&lex->vstr, CUR_CHAR(lex));\n            }\n        }\n        next_char(lex);\n    }\n\n    \n    if (n_closing < num_quotes) {\n        lex->tok_kind = MP_TOKEN_LONELY_STRING_OPEN;\n    }\n\n    \n    vstr_cut_tail_bytes(&lex->vstr, n_closing);\n}\n\n\n\nstatic bool skip_whitespace(mp_lexer_t *lex, bool stop_at_newline) {\n    while (!is_end(lex)) {\n        if (is_physical_newline(lex)) {\n            if (stop_at_newline && lex->nested_bracket_level == 0) {\n                return true;\n            }\n            next_char(lex);\n        } else if (is_whitespace(lex)) {\n            next_char(lex);\n        } else if (is_char(lex, '#')) {\n            next_char(lex);\n            while (!is_end(lex) && !is_physical_newline(lex)) {\n                next_char(lex);\n            }\n            \n        } else if (is_char_and(lex, '\\\\', '\\n')) {\n            \n            next_char(lex);\n            next_char(lex);\n        } else {\n            break;\n        }\n    }\n    return false;\n}\n\nvoid mp_lexer_to_next(mp_lexer_t *lex) {\n    #if MICROPY_PY_FSTRINGS\n    if (lex->fstring_args.len && lex->fstring_args_idx == 0) {\n        \n        \n        vstr_add_byte(&lex->fstring_args, ')');\n        lex->chr0_saved = lex->chr0;\n        lex->chr1_saved = lex->chr1;\n        lex->chr2_saved = lex->chr2;\n        lex->chr0 = lex->fstring_args.buf[0];\n        lex->chr1 = lex->fstring_args.buf[1];\n        lex->chr2 = lex->fstring_args.buf[2];\n        \n        \n        lex->fstring_args_idx = 3;\n    }\n    #endif\n\n    \n    vstr_reset(&lex->vstr);\n\n    \n    \n    \n    \n    bool had_physical_newline = skip_whitespace(lex, true);\n\n    \n    lex->tok_line = lex->line;\n    lex->tok_column = lex->column;\n\n    if (lex->emit_dent < 0) {\n        lex->tok_kind = MP_TOKEN_DEDENT;\n        lex->emit_dent += 1;\n\n    } else if (lex->emit_dent > 0) {\n        lex->tok_kind = MP_TOKEN_INDENT;\n        lex->emit_dent -= 1;\n\n    } else if (had_physical_newline) {\n        \n        \n        \n        skip_whitespace(lex, false);\n\n        lex->tok_kind = MP_TOKEN_NEWLINE;\n\n        size_t num_spaces = lex->column - 1;\n        if (num_spaces == indent_top(lex)) {\n        } else if (num_spaces > indent_top(lex)) {\n            indent_push(lex, num_spaces);\n            lex->emit_dent += 1;\n        } else {\n            while (num_spaces < indent_top(lex)) {\n                indent_pop(lex);\n                lex->emit_dent -= 1;\n            }\n            if (num_spaces != indent_top(lex)) {\n                lex->tok_kind = MP_TOKEN_DEDENT_MISMATCH;\n            }\n        }\n\n    } else if (is_end(lex)) {\n        lex->tok_kind = MP_TOKEN_END;\n\n    } else if (is_string_or_bytes(lex)) {\n        \n\n        \n        \n        \n        \n        \n\n        \n        lex->tok_kind = MP_TOKEN_END;\n\n        \n        do {\n            \n            bool is_raw = false;\n            bool is_fstring = false;\n            mp_token_kind_t kind = MP_TOKEN_STRING;\n            int n_char = 0;\n            if (is_char(lex, 'u')) {\n                n_char = 1;\n            } else if (is_char(lex, 'b')) {\n                kind = MP_TOKEN_BYTES;\n                n_char = 1;\n                if (is_char_following(lex, 'r')) {\n                    is_raw = true;\n                    n_char = 2;\n                }\n            } else if (is_char(lex, 'r')) {\n                is_raw = true;\n                n_char = 1;\n                if (is_char_following(lex, 'b')) {\n                    kind = MP_TOKEN_BYTES;\n                    n_char = 2;\n                }\n                #if MICROPY_PY_FSTRINGS\n                if (is_char_following(lex, 'f')) {\n                    \n                    lex->tok_kind = MP_TOKEN_FSTRING_RAW;\n                    break;\n                }\n                #endif\n            }\n            #if MICROPY_PY_FSTRINGS\n            else if (is_char(lex, 'f')) {\n                if (is_char_following(lex, 'r')) {\n                    \n                    lex->tok_kind = MP_TOKEN_FSTRING_RAW;\n                    break;\n                }\n                n_char = 1;\n                is_fstring = true;\n            }\n            #endif\n\n            \n            if (lex->tok_kind == MP_TOKEN_END) {\n                lex->tok_kind = kind;\n            } else if (lex->tok_kind != kind) {\n                \n                break;\n            }\n\n            \n            if (n_char != 0) {\n                next_char(lex);\n                if (n_char == 2) {\n                    next_char(lex);\n                }\n            }\n\n            \n            parse_string_literal(lex, is_raw, is_fstring);\n\n            \n            skip_whitespace(lex, true);\n\n        } while (is_string_or_bytes(lex));\n\n    } else if (is_head_of_identifier(lex)) {\n        lex->tok_kind = MP_TOKEN_NAME;\n\n        \n        vstr_add_byte(&lex->vstr, CUR_CHAR(lex));\n        next_char(lex);\n\n        \n        while (!is_end(lex) && is_tail_of_identifier(lex)) {\n            vstr_add_byte(&lex->vstr, CUR_CHAR(lex));\n            next_char(lex);\n        }\n\n        \n        \n        \n        \n        const char *s = vstr_null_terminated_str(&lex->vstr);\n        for (size_t i = 0; i < MP_ARRAY_SIZE(tok_kw); i++) {\n            int cmp = strcmp(s, tok_kw[i]);\n            if (cmp == 0) {\n                lex->tok_kind = MP_TOKEN_KW_FALSE + i;\n                if (lex->tok_kind == MP_TOKEN_KW___DEBUG__) {\n                    lex->tok_kind = (MP_STATE_VM(mp_optimise_value) == 0 ? MP_TOKEN_KW_TRUE : MP_TOKEN_KW_FALSE);\n                }\n                break;\n            } else if (cmp < 0) {\n                \n                break;\n            }\n        }\n\n    } else if (is_digit(lex) || (is_char(lex, '.') && is_following_digit(lex))) {\n        bool forced_integer = false;\n        if (is_char(lex, '.')) {\n            lex->tok_kind = MP_TOKEN_FLOAT_OR_IMAG;\n        } else {\n            lex->tok_kind = MP_TOKEN_INTEGER;\n            if (is_char(lex, '0') && is_following_base_char(lex)) {\n                forced_integer = true;\n            }\n        }\n\n        \n        vstr_add_char(&lex->vstr, CUR_CHAR(lex));\n        next_char(lex);\n\n        \n        while (!is_end(lex)) {\n            if (!forced_integer && is_char_or(lex, 'e', 'E')) {\n                lex->tok_kind = MP_TOKEN_FLOAT_OR_IMAG;\n                vstr_add_char(&lex->vstr, 'e');\n                next_char(lex);\n                if (is_char(lex, '+') || is_char(lex, '-')) {\n                    vstr_add_char(&lex->vstr, CUR_CHAR(lex));\n                    next_char(lex);\n                }\n            } else if (is_letter(lex) || is_digit(lex) || is_char(lex, '.')) {\n                if (is_char_or3(lex, '.', 'j', 'J')) {\n                    lex->tok_kind = MP_TOKEN_FLOAT_OR_IMAG;\n                }\n                vstr_add_char(&lex->vstr, CUR_CHAR(lex));\n                next_char(lex);\n            } else if (is_char(lex, '_')) {\n                next_char(lex);\n            } else {\n                break;\n            }\n        }\n\n    } else {\n        \n\n        const char *t = tok_enc;\n        size_t tok_enc_index = 0;\n        for (; *t != 0 && !is_char(lex, *t); t += 1) {\n            if (*t == 'e' || *t == 'c') {\n                t += 1;\n            }\n            tok_enc_index += 1;\n        }\n\n        next_char(lex);\n\n        if (*t == 0) {\n            \n            lex->tok_kind = MP_TOKEN_INVALID;\n\n        } else if (*t == '!') {\n            \n            if (is_char(lex, '=')) {\n                next_char(lex);\n                lex->tok_kind = MP_TOKEN_OP_NOT_EQUAL;\n            } else {\n                lex->tok_kind = MP_TOKEN_INVALID;\n            }\n\n        } else if (*t == '.') {\n            \n            if (is_char_and(lex, '.', '.')) {\n                next_char(lex);\n                next_char(lex);\n                lex->tok_kind = MP_TOKEN_ELLIPSIS;\n            } else {\n                lex->tok_kind = MP_TOKEN_DEL_PERIOD;\n            }\n\n        } else {\n            \n\n            \n            t += 1;\n            size_t t_index = tok_enc_index;\n            while (*t == 'c' || *t == 'e') {\n                t_index += 1;\n                if (is_char(lex, t[1])) {\n                    next_char(lex);\n                    tok_enc_index = t_index;\n                    if (*t == 'e') {\n                        break;\n                    }\n                } else if (*t == 'c') {\n                    break;\n                }\n                t += 2;\n            }\n\n            \n            lex->tok_kind = tok_enc_kind[tok_enc_index];\n\n            \n            if (lex->tok_kind == MP_TOKEN_DEL_PAREN_OPEN || lex->tok_kind == MP_TOKEN_DEL_BRACKET_OPEN || lex->tok_kind == MP_TOKEN_DEL_BRACE_OPEN) {\n                lex->nested_bracket_level += 1;\n            } else if (lex->tok_kind == MP_TOKEN_DEL_PAREN_CLOSE || lex->tok_kind == MP_TOKEN_DEL_BRACKET_CLOSE || lex->tok_kind == MP_TOKEN_DEL_BRACE_CLOSE) {\n                lex->nested_bracket_level -= 1;\n            }\n        }\n    }\n}\n\nmp_lexer_t *mp_lexer_new(qstr src_name, mp_reader_t reader) {\n    mp_lexer_t *lex = m_new_obj(mp_lexer_t);\n\n    lex->source_name = src_name;\n    lex->reader = reader;\n    lex->line = 1;\n    lex->column = (size_t)-2; \n    lex->emit_dent = 0;\n    lex->nested_bracket_level = 0;\n    lex->alloc_indent_level = MICROPY_ALLOC_LEXER_INDENT_INIT;\n    lex->num_indent_level = 1;\n    lex->indent_level = m_new(uint16_t, lex->alloc_indent_level);\n    vstr_init(&lex->vstr, 32);\n    #if MICROPY_PY_FSTRINGS\n    vstr_init(&lex->fstring_args, 0);\n    lex->fstring_args_idx = 0;\n    #endif\n\n    \n    lex->indent_level[0] = 0;\n\n    \n    \n    lex->chr0 = lex->chr1 = lex->chr2 = 0;\n    next_char(lex);\n    next_char(lex);\n    next_char(lex);\n\n    \n    mp_lexer_to_next(lex);\n\n    \n    \n    \n    if (lex->tok_column != 1 && lex->tok_kind != MP_TOKEN_NEWLINE) {\n        lex->tok_kind = MP_TOKEN_INDENT;\n    }\n\n    return lex;\n}\n\nmp_lexer_t *mp_lexer_new_from_str_len(qstr src_name, const char *str, size_t len, size_t free_len) {\n    mp_reader_t reader;\n    mp_reader_new_mem(&reader, (const byte *)str, len, free_len);\n    return mp_lexer_new(src_name, reader);\n}\n\n#if MICROPY_READER_POSIX || MICROPY_READER_VFS\n\nmp_lexer_t *mp_lexer_new_from_file(qstr filename) {\n    mp_reader_t reader;\n    mp_reader_new_file(&reader, filename);\n    return mp_lexer_new(filename, reader);\n}\n\n#if MICROPY_HELPER_LEXER_UNIX\n\nmp_lexer_t *mp_lexer_new_from_fd(qstr filename, int fd, bool close_fd) {\n    mp_reader_t reader;\n    mp_reader_new_file_from_fd(&reader, fd, close_fd);\n    return mp_lexer_new(filename, reader);\n}\n\n#endif\n\n#endif\n\nvoid mp_lexer_free(mp_lexer_t *lex) {\n    if (lex) {\n        lex->reader.close(lex->reader.data);\n        vstr_clear(&lex->vstr);\n        #if MICROPY_PY_FSTRINGS\n        vstr_clear(&lex->fstring_args);\n        #endif\n        m_del(uint16_t, lex->indent_level, lex->alloc_indent_level);\n        m_del_obj(mp_lexer_t, lex);\n    }\n}\n\n#if 0\n\n\nvoid mp_lexer_show_token(const mp_lexer_t *lex) {\n    printf(\"(\" UINT_FMT \":\" UINT_FMT \") kind:%u str:%p len:%zu\", lex->tok_line, lex->tok_column, lex->tok_kind, lex->vstr.buf, lex->vstr.len);\n    if (lex->vstr.len > 0) {\n        const byte *i = (const byte *)lex->vstr.buf;\n        const byte *j = (const byte *)i + lex->vstr.len;\n        printf(\" \");\n        while (i < j) {\n            unichar c = utf8_get_char(i);\n            i = utf8_next_char(i);\n            if (unichar_isprint(c)) {\n                printf(\"%c\", (int)c);\n            } else {\n                printf(\"?\");\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}