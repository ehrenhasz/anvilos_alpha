{
  "module_name": "mpz.c",
  "hash_id": "1c42740b862c8085eedb8ab807ed87560b3beb30aa785cc24b8139fd2bfc7bda",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/mpz.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/mpz.h\"\n\n#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ\n\n#define DIG_SIZE (MPZ_DIG_SIZE)\n#define DIG_MASK ((MPZ_LONG_1 << DIG_SIZE) - 1)\n#define DIG_MSB  (MPZ_LONG_1 << (DIG_SIZE - 1))\n#define DIG_BASE (MPZ_LONG_1 << DIG_SIZE)\n\n \n\nstatic size_t mpn_remove_trailing_zeros(mpz_dig_t *oidig, mpz_dig_t *idig) {\n    for (--idig; idig >= oidig && *idig == 0; --idig) {\n    }\n    return idig + 1 - oidig;\n}\n\n \nstatic int mpn_cmp(const mpz_dig_t *idig, size_t ilen, const mpz_dig_t *jdig, size_t jlen) {\n    if (ilen < jlen) {\n        return -1;\n    }\n    if (ilen > jlen) {\n        return 1;\n    }\n\n    for (idig += ilen, jdig += ilen; ilen > 0; --ilen) {\n        mpz_dbl_dig_signed_t cmp = (mpz_dbl_dig_t)*(--idig) - (mpz_dbl_dig_t)*(--jdig);\n        if (cmp < 0) {\n            return -1;\n        }\n        if (cmp > 0) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n \nstatic size_t mpn_shl(mpz_dig_t *idig, mpz_dig_t *jdig, size_t jlen, mp_uint_t n) {\n    mp_uint_t n_whole = (n + DIG_SIZE - 1) / DIG_SIZE;\n    mp_uint_t n_part = n % DIG_SIZE;\n    if (n_part == 0) {\n        n_part = DIG_SIZE;\n    }\n\n    \n    idig += jlen + n_whole - 1;\n    jdig += jlen - 1;\n\n    \n    mpz_dbl_dig_t d = 0;\n    for (size_t i = jlen; i > 0; i--, idig--, jdig--) {\n        d |= *jdig;\n        *idig = (d >> (DIG_SIZE - n_part)) & DIG_MASK;\n        d <<= DIG_SIZE;\n    }\n\n    \n    *idig = (d >> (DIG_SIZE - n_part)) & DIG_MASK;\n    idig -= n_whole - 1;\n    memset(idig, 0, (n_whole - 1) * sizeof(mpz_dig_t));\n\n    \n    jlen += n_whole;\n    while (jlen != 0 && idig[jlen - 1] == 0) {\n        jlen--;\n    }\n\n    \n    return jlen;\n}\n\n \nstatic size_t mpn_shr(mpz_dig_t *idig, mpz_dig_t *jdig, size_t jlen, mp_uint_t n) {\n    mp_uint_t n_whole = n / DIG_SIZE;\n    mp_uint_t n_part = n % DIG_SIZE;\n\n    if (n_whole >= jlen) {\n        return 0;\n    }\n\n    jdig += n_whole;\n    jlen -= n_whole;\n\n    for (size_t i = jlen; i > 0; i--, idig++, jdig++) {\n        mpz_dbl_dig_t d = *jdig;\n        if (i > 1) {\n            d |= (mpz_dbl_dig_t)jdig[1] << DIG_SIZE;\n        }\n        d >>= n_part;\n        *idig = d & DIG_MASK;\n    }\n\n    if (idig[-1] == 0) {\n        jlen--;\n    }\n\n    return jlen;\n}\n\n \nstatic size_t mpn_add(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {\n    mpz_dig_t *oidig = idig;\n    mpz_dbl_dig_t carry = 0;\n\n    jlen -= klen;\n\n    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {\n        carry += (mpz_dbl_dig_t)*jdig + (mpz_dbl_dig_t)*kdig;\n        *idig = carry & DIG_MASK;\n        carry >>= DIG_SIZE;\n    }\n\n    for (; jlen > 0; --jlen, ++idig, ++jdig) {\n        carry += *jdig;\n        *idig = carry & DIG_MASK;\n        carry >>= DIG_SIZE;\n    }\n\n    if (carry != 0) {\n        *idig++ = carry;\n    }\n\n    return idig - oidig;\n}\n\n \nstatic size_t mpn_sub(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {\n    mpz_dig_t *oidig = idig;\n    mpz_dbl_dig_signed_t borrow = 0;\n\n    jlen -= klen;\n\n    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {\n        borrow += (mpz_dbl_dig_t)*jdig - (mpz_dbl_dig_t)*kdig;\n        *idig = borrow & DIG_MASK;\n        borrow >>= DIG_SIZE;\n    }\n\n    for (; jlen > 0; --jlen, ++idig, ++jdig) {\n        borrow += *jdig;\n        *idig = borrow & DIG_MASK;\n        borrow >>= DIG_SIZE;\n    }\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n#if MICROPY_OPT_MPZ_BITWISE\n\n \nstatic size_t mpn_and(mpz_dig_t *idig, const mpz_dig_t *jdig, const mpz_dig_t *kdig, size_t klen) {\n    mpz_dig_t *oidig = idig;\n\n    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {\n        *idig = *jdig & *kdig;\n    }\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n#endif\n\n \nstatic size_t mpn_and_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,\n    mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {\n    mpz_dig_t *oidig = idig;\n    mpz_dig_t imask = (0 == carryi) ? 0 : DIG_MASK;\n    mpz_dig_t jmask = (0 == carryj) ? 0 : DIG_MASK;\n    mpz_dig_t kmask = (0 == carryk) ? 0 : DIG_MASK;\n\n    for (; jlen > 0; ++idig, ++jdig) {\n        carryj += *jdig ^ jmask;\n        carryk += (--klen <= --jlen) ? (*kdig++ ^ kmask) : kmask;\n        carryi += ((carryj & carryk) ^ imask) & DIG_MASK;\n        *idig = carryi & DIG_MASK;\n        carryk >>= DIG_SIZE;\n        carryj >>= DIG_SIZE;\n        carryi >>= DIG_SIZE;\n    }\n\n    if (0 != carryi) {\n        *idig++ = carryi;\n    }\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n#if MICROPY_OPT_MPZ_BITWISE\n\n \nstatic size_t mpn_or(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {\n    mpz_dig_t *oidig = idig;\n\n    jlen -= klen;\n\n    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {\n        *idig = *jdig | *kdig;\n    }\n\n    for (; jlen > 0; --jlen, ++idig, ++jdig) {\n        *idig = *jdig;\n    }\n\n    return idig - oidig;\n}\n\n#endif\n\n \n\n#if MICROPY_OPT_MPZ_BITWISE\n\nstatic size_t mpn_or_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,\n    mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {\n    mpz_dig_t *oidig = idig;\n    mpz_dbl_dig_t carryi = 1;\n    mpz_dig_t jmask = (0 == carryj) ? 0 : DIG_MASK;\n    mpz_dig_t kmask = (0 == carryk) ? 0 : DIG_MASK;\n\n    for (; jlen > 0; ++idig, ++jdig) {\n        carryj += *jdig ^ jmask;\n        carryk += (--klen <= --jlen) ? (*kdig++ ^ kmask) : kmask;\n        carryi += ((carryj | carryk) ^ DIG_MASK) & DIG_MASK;\n        *idig = carryi & DIG_MASK;\n        carryk >>= DIG_SIZE;\n        carryj >>= DIG_SIZE;\n        carryi >>= DIG_SIZE;\n    }\n\n    \n    \n    \n    \n    \n    \n    assert(carryi == 0);\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n#else\n\nstatic size_t mpn_or_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,\n    mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {\n    mpz_dig_t *oidig = idig;\n    mpz_dig_t imask = (0 == carryi) ? 0 : DIG_MASK;\n    mpz_dig_t jmask = (0 == carryj) ? 0 : DIG_MASK;\n    mpz_dig_t kmask = (0 == carryk) ? 0 : DIG_MASK;\n\n    for (; jlen > 0; ++idig, ++jdig) {\n        carryj += *jdig ^ jmask;\n        carryk += (--klen <= --jlen) ? (*kdig++ ^ kmask) : kmask;\n        carryi += ((carryj | carryk) ^ imask) & DIG_MASK;\n        *idig = carryi & DIG_MASK;\n        carryk >>= DIG_SIZE;\n        carryj >>= DIG_SIZE;\n        carryi >>= DIG_SIZE;\n    }\n\n    \n    assert(carryi == 0);\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n#endif\n\n#if MICROPY_OPT_MPZ_BITWISE\n\n \nstatic size_t mpn_xor(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {\n    mpz_dig_t *oidig = idig;\n\n    jlen -= klen;\n\n    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {\n        *idig = *jdig ^ *kdig;\n    }\n\n    for (; jlen > 0; --jlen, ++idig, ++jdig) {\n        *idig = *jdig;\n    }\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n#endif\n\n \nstatic size_t mpn_xor_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,\n    mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {\n    mpz_dig_t *oidig = idig;\n\n    for (; jlen > 0; ++idig, ++jdig) {\n        carryj += *jdig + DIG_MASK;\n        carryk += (--klen <= --jlen) ? (*kdig++ + DIG_MASK) : DIG_MASK;\n        carryi += (carryj ^ carryk) & DIG_MASK;\n        *idig = carryi & DIG_MASK;\n        carryk >>= DIG_SIZE;\n        carryj >>= DIG_SIZE;\n        carryi >>= DIG_SIZE;\n    }\n\n    if (0 != carryi) {\n        *idig++ = carryi;\n    }\n\n    return mpn_remove_trailing_zeros(oidig, idig);\n}\n\n \nstatic size_t mpn_mul_dig_add_dig(mpz_dig_t *idig, size_t ilen, mpz_dig_t dmul, mpz_dig_t dadd) {\n    mpz_dig_t *oidig = idig;\n    mpz_dbl_dig_t carry = dadd;\n\n    for (; ilen > 0; --ilen, ++idig) {\n        carry += (mpz_dbl_dig_t)*idig * (mpz_dbl_dig_t)dmul; \n        *idig = carry & DIG_MASK;\n        carry >>= DIG_SIZE;\n    }\n\n    if (carry != 0) {\n        *idig++ = carry;\n    }\n\n    return idig - oidig;\n}\n\n \nstatic size_t mpn_mul(mpz_dig_t *idig, mpz_dig_t *jdig, size_t jlen, mpz_dig_t *kdig, size_t klen) {\n    mpz_dig_t *oidig = idig;\n    size_t ilen = 0;\n\n    for (; klen > 0; --klen, ++idig, ++kdig) {\n        mpz_dig_t *id = idig;\n        mpz_dbl_dig_t carry = 0;\n\n        size_t jl = jlen;\n        for (mpz_dig_t *jd = jdig; jl > 0; --jl, ++jd, ++id) {\n            carry += (mpz_dbl_dig_t)*id + (mpz_dbl_dig_t)*jd * (mpz_dbl_dig_t)*kdig; \n            *id = carry & DIG_MASK;\n            carry >>= DIG_SIZE;\n        }\n\n        if (carry != 0) {\n            *id++ = carry;\n        }\n\n        ilen = id - oidig;\n    }\n\n    return ilen;\n}\n\n \nstatic void mpn_div(mpz_dig_t *num_dig, size_t *num_len, const mpz_dig_t *den_dig, size_t den_len, mpz_dig_t *quo_dig, size_t *quo_len) {\n    mpz_dig_t *orig_num_dig = num_dig;\n    mpz_dig_t *orig_quo_dig = quo_dig;\n    mpz_dig_t norm_shift = 0;\n    mpz_dbl_dig_t lead_den_digit;\n\n    \n    {\n        int cmp = mpn_cmp(num_dig, *num_len, den_dig, den_len);\n        if (cmp == 0) {\n            *num_len = 0;\n            quo_dig[0] = 1;\n            *quo_len = 1;\n            return;\n        } else if (cmp < 0) {\n            \n            *quo_len = 0;\n            return;\n        }\n    }\n\n    \n    \n    \n    \n\n    \n    {\n        mpz_dig_t d = den_dig[den_len - 1];\n        while ((d & DIG_MSB) == 0) {\n            d <<= 1;\n            ++norm_shift;\n        }\n    }\n\n    \n    \n    num_dig[*num_len] = 0;\n    ++(*num_len);\n    for (mpz_dig_t *num = num_dig, carry = 0; num < num_dig + *num_len; ++num) {\n        mpz_dig_t n = *num;\n        *num = ((n << norm_shift) | carry) & DIG_MASK;\n        carry = (mpz_dbl_dig_t)n >> (DIG_SIZE - norm_shift);\n    }\n\n    \n    lead_den_digit = (mpz_dbl_dig_t)den_dig[den_len - 1] << norm_shift;\n    if (den_len >= 2) {\n        lead_den_digit |= (mpz_dbl_dig_t)den_dig[den_len - 2] >> (DIG_SIZE - norm_shift);\n    }\n\n    \n    num_dig += *num_len - 1;\n\n    \n    *quo_len = *num_len - den_len;\n\n    \n    quo_dig += *quo_len - 1;\n\n    \n    while (*num_len > den_len) {\n        mpz_dbl_dig_t quo = ((mpz_dbl_dig_t)*num_dig << DIG_SIZE) | num_dig[-1];\n\n        \n        quo /= lead_den_digit;\n\n        \n        \n        \n        \n        const mpz_dig_t *d = den_dig;\n        mpz_dbl_dig_t d_norm = 0;\n        mpz_dbl_dig_signed_t borrow = 0;\n        for (mpz_dig_t *n = num_dig - den_len; n < num_dig; ++n, ++d) {\n            \n            d_norm = ((mpz_dbl_dig_t)*d << norm_shift) | (d_norm >> DIG_SIZE);\n            \n            mpz_dbl_dig_t x = (mpz_dbl_dig_t)quo * (d_norm & DIG_MASK);\n            \n            mpz_dbl_dig_signed_t low_digs = (borrow & DIG_MASK) + *n - (x & DIG_MASK);\n            \n            *n = low_digs & DIG_MASK;\n            \n            borrow = (borrow >> DIG_SIZE) - (x >> DIG_SIZE) + (low_digs >> DIG_SIZE);\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        borrow += *num_dig;\n        for (; borrow != 0; --quo) {\n            d = den_dig;\n            d_norm = 0;\n            mpz_dbl_dig_t carry = 0;\n            for (mpz_dig_t *n = num_dig - den_len; n < num_dig; ++n, ++d) {\n                d_norm = ((mpz_dbl_dig_t)*d << norm_shift) | (d_norm >> DIG_SIZE);\n                carry += (mpz_dbl_dig_t)*n + (d_norm & DIG_MASK);\n                *n = carry & DIG_MASK;\n                carry >>= DIG_SIZE;\n            }\n            borrow += carry;\n        }\n\n        \n        *quo_dig = quo & DIG_MASK;\n        --quo_dig;\n\n        \n        --num_dig;\n        --(*num_len);\n    }\n\n    \n    for (mpz_dig_t *num = orig_num_dig + *num_len - 1, carry = 0; num >= orig_num_dig; --num) {\n        mpz_dig_t n = *num;\n        *num = ((n >> norm_shift) | carry) & DIG_MASK;\n        carry = (mpz_dbl_dig_t)n << (DIG_SIZE - norm_shift);\n    }\n\n    \n\n    while (*quo_len > 0 && orig_quo_dig[*quo_len - 1] == 0) {\n        --(*quo_len);\n    }\n\n    while (*num_len > 0 && orig_num_dig[*num_len - 1] == 0) {\n        --(*num_len);\n    }\n}\n\n#define MIN_ALLOC (2)\n\nvoid mpz_init_zero(mpz_t *z) {\n    z->neg = 0;\n    z->fixed_dig = 0;\n    z->alloc = 0;\n    z->len = 0;\n    z->dig = NULL;\n}\n\nvoid mpz_init_from_int(mpz_t *z, mp_int_t val) {\n    mpz_init_zero(z);\n    mpz_set_from_int(z, val);\n}\n\nvoid mpz_init_fixed_from_int(mpz_t *z, mpz_dig_t *dig, size_t alloc, mp_int_t val) {\n    z->neg = 0;\n    z->fixed_dig = 1;\n    z->alloc = alloc;\n    z->len = 0;\n    z->dig = dig;\n    mpz_set_from_int(z, val);\n}\n\nvoid mpz_deinit(mpz_t *z) {\n    if (z != NULL && !z->fixed_dig) {\n        m_del(mpz_dig_t, z->dig, z->alloc);\n    }\n}\n\n#if 0\nthese functions are unused\n\nmpz_t *mpz_zero(void) {\n    mpz_t *z = m_new_obj(mpz_t);\n    mpz_init_zero(z);\n    return z;\n}\n\nmpz_t *mpz_from_int(mp_int_t val) {\n    mpz_t *z = mpz_zero();\n    mpz_set_from_int(z, val);\n    return z;\n}\n\nmpz_t *mpz_from_ll(long long val, bool is_signed) {\n    mpz_t *z = mpz_zero();\n    mpz_set_from_ll(z, val, is_signed);\n    return z;\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nmpz_t *mpz_from_float(mp_float_t val) {\n    mpz_t *z = mpz_zero();\n    mpz_set_from_float(z, val);\n    return z;\n}\n#endif\n\nmpz_t *mpz_from_str(const char *str, size_t len, bool neg, unsigned int base) {\n    mpz_t *z = mpz_zero();\n    mpz_set_from_str(z, str, len, neg, base);\n    return z;\n}\n#endif\n\nstatic void mpz_free(mpz_t *z) {\n    if (z != NULL) {\n        m_del(mpz_dig_t, z->dig, z->alloc);\n        m_del_obj(mpz_t, z);\n    }\n}\n\nstatic void mpz_need_dig(mpz_t *z, size_t need) {\n    if (need < MIN_ALLOC) {\n        need = MIN_ALLOC;\n    }\n\n    if (z->dig == NULL || z->alloc < need) {\n        \n        \n        assert(!z->fixed_dig);\n        z->dig = m_renew(mpz_dig_t, z->dig, z->alloc, need);\n        z->alloc = need;\n    }\n}\n\nstatic mpz_t *mpz_clone(const mpz_t *src) {\n    assert(src->alloc != 0);\n    mpz_t *z = m_new_obj(mpz_t);\n    z->neg = src->neg;\n    z->fixed_dig = 0;\n    z->alloc = src->alloc;\n    z->len = src->len;\n    z->dig = m_new(mpz_dig_t, z->alloc);\n    memcpy(z->dig, src->dig, src->alloc * sizeof(mpz_dig_t));\n    return z;\n}\n\n \nvoid mpz_set(mpz_t *dest, const mpz_t *src) {\n    mpz_need_dig(dest, src->len);\n    dest->neg = src->neg;\n    dest->len = src->len;\n    memcpy(dest->dig, src->dig, src->len * sizeof(mpz_dig_t));\n}\n\nvoid mpz_set_from_int(mpz_t *z, mp_int_t val) {\n    if (val == 0) {\n        z->neg = 0;\n        z->len = 0;\n        return;\n    }\n\n    mpz_need_dig(z, MPZ_NUM_DIG_FOR_INT);\n\n    mp_uint_t uval;\n    if (val < 0) {\n        z->neg = 1;\n        uval = -val;\n    } else {\n        z->neg = 0;\n        uval = val;\n    }\n\n    z->len = 0;\n    while (uval > 0) {\n        z->dig[z->len++] = uval & DIG_MASK;\n        uval >>= DIG_SIZE;\n    }\n}\n\nvoid mpz_set_from_ll(mpz_t *z, long long val, bool is_signed) {\n    mpz_need_dig(z, MPZ_NUM_DIG_FOR_LL);\n\n    unsigned long long uval;\n    if (is_signed && val < 0) {\n        z->neg = 1;\n        uval = -(unsigned long long)val;\n    } else {\n        z->neg = 0;\n        uval = val;\n    }\n\n    z->len = 0;\n    while (uval > 0) {\n        z->dig[z->len++] = uval & DIG_MASK;\n        uval >>= DIG_SIZE;\n    }\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nvoid mpz_set_from_float(mpz_t *z, mp_float_t src) {\n    mp_float_union_t u = {src};\n    z->neg = u.p.sgn;\n    if (u.p.exp == 0) {\n        \n        mpz_set_from_int(z, 0);\n    } else if (u.p.exp == ((1 << MP_FLOAT_EXP_BITS) - 1)) {\n        \n        \n        mpz_set_from_int(z, 0);\n    } else {\n        const int adj_exp = (int)u.p.exp - MP_FLOAT_EXP_BIAS;\n        if (adj_exp < 0) {\n            \n            mpz_set_from_int(z, 0);\n        } else if (adj_exp == 0) {\n            \n            mpz_set_from_int(z, 1);\n        } else {\n            \n            const int dig_cnt = (adj_exp + 1 + (DIG_SIZE - 1)) / DIG_SIZE;\n            const unsigned int rem = adj_exp % DIG_SIZE;\n            int dig_ind, shft;\n            mp_float_uint_t frc = u.p.frc | ((mp_float_uint_t)1 << MP_FLOAT_FRAC_BITS);\n\n            if (adj_exp < MP_FLOAT_FRAC_BITS) {\n                shft = 0;\n                dig_ind = 0;\n                frc >>= MP_FLOAT_FRAC_BITS - adj_exp;\n            } else {\n                shft = (rem - MP_FLOAT_FRAC_BITS) % DIG_SIZE;\n                dig_ind = (adj_exp - MP_FLOAT_FRAC_BITS) / DIG_SIZE;\n            }\n            mpz_need_dig(z, dig_cnt);\n            z->len = dig_cnt;\n            if (dig_ind != 0) {\n                memset(z->dig, 0, dig_ind * sizeof(mpz_dig_t));\n            }\n            if (shft != 0) {\n                z->dig[dig_ind++] = (frc << shft) & DIG_MASK;\n                frc >>= DIG_SIZE - shft;\n            }\n            #if DIG_SIZE < (MP_FLOAT_FRAC_BITS + 1)\n            while (dig_ind != dig_cnt) {\n                z->dig[dig_ind++] = frc & DIG_MASK;\n                frc >>= DIG_SIZE;\n            }\n            #else\n            if (dig_ind != dig_cnt) {\n                z->dig[dig_ind] = frc;\n            }\n            #endif\n        }\n    }\n}\n#endif\n\n\nsize_t mpz_set_from_str(mpz_t *z, const char *str, size_t len, bool neg, unsigned int base) {\n    assert(base <= 36);\n\n    const char *cur = str;\n    const char *top = str + len;\n\n    mpz_need_dig(z, len * 8 / DIG_SIZE + 1);\n\n    if (neg) {\n        z->neg = 1;\n    } else {\n        z->neg = 0;\n    }\n\n    z->len = 0;\n    for (; cur < top; ++cur) { \n        \n        mp_uint_t v = *cur;\n        if ('0' <= v && v <= '9') {\n            v -= '0';\n        } else if ('A' <= v && v <= 'Z') {\n            v -= 'A' - 10;\n        } else if ('a' <= v && v <= 'z') {\n            v -= 'a' - 10;\n        } else {\n            break;\n        }\n        if (v >= base) {\n            break;\n        }\n        z->len = mpn_mul_dig_add_dig(z->dig, z->len, base, v);\n    }\n\n    return cur - str;\n}\n\nvoid mpz_set_from_bytes(mpz_t *z, bool big_endian, size_t len, const byte *buf) {\n    int delta = 1;\n    if (big_endian) {\n        buf += len - 1;\n        delta = -1;\n    }\n\n    mpz_need_dig(z, (len * 8 + DIG_SIZE - 1) / DIG_SIZE);\n\n    mpz_dig_t d = 0;\n    int num_bits = 0;\n    z->neg = 0;\n    z->len = 0;\n    while (len) {\n        while (len && num_bits < DIG_SIZE) {\n            d |= *buf << num_bits;\n            num_bits += 8;\n            buf += delta;\n            len--;\n        }\n        z->dig[z->len++] = d & DIG_MASK;\n        \n        #if DIG_SIZE != 8 && DIG_SIZE != 16 && DIG_SIZE != 32\n        d >>= DIG_SIZE;\n        #else\n        d = 0;\n        #endif\n        num_bits -= DIG_SIZE;\n    }\n\n    z->len = mpn_remove_trailing_zeros(z->dig, z->dig + z->len);\n}\n\n#if 0\nthese functions are unused\n\nbool mpz_is_pos(const mpz_t *z) {\n    return z->len > 0 && z->neg == 0;\n}\n\nbool mpz_is_odd(const mpz_t *z) {\n    return z->len > 0 && (z->dig[0] & 1) != 0;\n}\n\nbool mpz_is_even(const mpz_t *z) {\n    return z->len == 0 || (z->dig[0] & 1) == 0;\n}\n#endif\n\nint mpz_cmp(const mpz_t *z1, const mpz_t *z2) {\n    int cmp = (int)z2->neg - (int)z1->neg;\n    if (cmp != 0) {\n        return cmp;\n    }\n    cmp = mpn_cmp(z1->dig, z1->len, z2->dig, z2->len);\n    if (z1->neg != 0) {\n        cmp = -cmp;\n    }\n    return cmp;\n}\n\n#if 0\n\n\nmp_int_t mpz_cmp_sml_int(const mpz_t *z, mp_int_t sml_int) {\n    mp_int_t cmp;\n    if (z->neg == 0) {\n        if (sml_int < 0) {\n            return 1;\n        }\n        if (sml_int == 0) {\n            if (z->len == 0) {\n                return 0;\n            }\n            return 1;\n        }\n        if (z->len == 0) {\n            return -1;\n        }\n        assert(sml_int < (1 << DIG_SIZE));\n        if (z->len != 1) {\n            return 1;\n        }\n        cmp = z->dig[0] - sml_int;\n    } else {\n        if (sml_int > 0) {\n            return -1;\n        }\n        if (sml_int == 0) {\n            if (z->len == 0) {\n                return 0;\n            }\n            return -1;\n        }\n        if (z->len == 0) {\n            return 1;\n        }\n        assert(sml_int > -(1 << DIG_SIZE));\n        if (z->len != 1) {\n            return -1;\n        }\n        cmp = -z->dig[0] - sml_int;\n    }\n    if (cmp < 0) {\n        return -1;\n    }\n    if (cmp > 0) {\n        return 1;\n    }\n    return 0;\n}\n#endif\n\n#if 0\nthese functions are unused\n\n \nmpz_t *mpz_abs(const mpz_t *z) {\n    \n    mpz_t *z2 = mpz_clone(z);\n    z2->neg = 0;\n    return z2;\n}\n\n \nmpz_t *mpz_neg(const mpz_t *z) {\n    \n    mpz_t *z2 = mpz_clone(z);\n    z2->neg = 1 - z2->neg;\n    return z2;\n}\n\n \nmpz_t *mpz_add(const mpz_t *lhs, const mpz_t *rhs) {\n    mpz_t *z = mpz_zero();\n    mpz_add_inpl(z, lhs, rhs);\n    return z;\n}\n\n \nmpz_t *mpz_sub(const mpz_t *lhs, const mpz_t *rhs) {\n    mpz_t *z = mpz_zero();\n    mpz_sub_inpl(z, lhs, rhs);\n    return z;\n}\n\n \nmpz_t *mpz_mul(const mpz_t *lhs, const mpz_t *rhs) {\n    mpz_t *z = mpz_zero();\n    mpz_mul_inpl(z, lhs, rhs);\n    return z;\n}\n\n \nmpz_t *mpz_pow(const mpz_t *lhs, const mpz_t *rhs) {\n    mpz_t *z = mpz_zero();\n    mpz_pow_inpl(z, lhs, rhs);\n    return z;\n}\n\n \nvoid mpz_divmod(const mpz_t *lhs, const mpz_t *rhs, mpz_t **quo, mpz_t **rem) {\n    *quo = mpz_zero();\n    *rem = mpz_zero();\n    mpz_divmod_inpl(*quo, *rem, lhs, rhs);\n}\n#endif\n\n \nvoid mpz_abs_inpl(mpz_t *dest, const mpz_t *z) {\n    if (dest != z) {\n        mpz_set(dest, z);\n    }\n    dest->neg = 0;\n}\n\n \nvoid mpz_neg_inpl(mpz_t *dest, const mpz_t *z) {\n    if (dest != z) {\n        mpz_set(dest, z);\n    }\n    if (dest->len) {\n        dest->neg = 1 - dest->neg;\n    }\n}\n\n \nvoid mpz_not_inpl(mpz_t *dest, const mpz_t *z) {\n    if (dest != z) {\n        mpz_set(dest, z);\n    }\n    if (dest->len == 0) {\n        mpz_need_dig(dest, 1);\n        dest->dig[0] = 1;\n        dest->len = 1;\n        dest->neg = 1;\n    } else if (dest->neg) {\n        dest->neg = 0;\n        mpz_dig_t k = 1;\n        dest->len = mpn_sub(dest->dig, dest->dig, dest->len, &k, 1);\n    } else {\n        mpz_need_dig(dest, dest->len + 1);\n        mpz_dig_t k = 1;\n        dest->len = mpn_add(dest->dig, dest->dig, dest->len, &k, 1);\n        dest->neg = 1;\n    }\n}\n\n \nvoid mpz_shl_inpl(mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {\n    if (lhs->len == 0 || rhs == 0) {\n        mpz_set(dest, lhs);\n    } else {\n        mpz_need_dig(dest, lhs->len + (rhs + DIG_SIZE - 1) / DIG_SIZE);\n        dest->len = mpn_shl(dest->dig, lhs->dig, lhs->len, rhs);\n        dest->neg = lhs->neg;\n    }\n}\n\n \nvoid mpz_shr_inpl(mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {\n    if (lhs->len == 0 || rhs == 0) {\n        mpz_set(dest, lhs);\n    } else {\n        mpz_need_dig(dest, lhs->len);\n        dest->len = mpn_shr(dest->dig, lhs->dig, lhs->len, rhs);\n        dest->neg = lhs->neg;\n        if (dest->neg) {\n            \n            mp_uint_t n_whole = rhs / DIG_SIZE;\n            mp_uint_t n_part = rhs % DIG_SIZE;\n            mpz_dig_t round_up = 0;\n            for (size_t i = 0; i < lhs->len && i < n_whole; i++) {\n                if (lhs->dig[i] != 0) {\n                    round_up = 1;\n                    break;\n                }\n            }\n            if (n_whole < lhs->len && (lhs->dig[n_whole] & ((1 << n_part) - 1)) != 0) {\n                round_up = 1;\n            }\n            if (round_up) {\n                if (dest->len == 0) {\n                    \n                    dest->dig[0] = 1;\n                    dest->len = 1;\n                } else {\n                    \n                    dest->len = mpn_add(dest->dig, dest->dig, dest->len, &round_up, 1);\n                }\n            }\n        }\n    }\n}\n\n \nvoid mpz_add_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    if (mpn_cmp(lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {\n        const mpz_t *temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n\n    if (lhs->neg == rhs->neg) {\n        mpz_need_dig(dest, lhs->len + 1);\n        dest->len = mpn_add(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n    } else {\n        mpz_need_dig(dest, lhs->len);\n        dest->len = mpn_sub(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n    }\n\n    dest->neg = lhs->neg & !!dest->len;\n}\n\n \nvoid mpz_sub_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    bool neg = false;\n\n    if (mpn_cmp(lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {\n        const mpz_t *temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n        neg = true;\n    }\n\n    if (lhs->neg != rhs->neg) {\n        mpz_need_dig(dest, lhs->len + 1);\n        dest->len = mpn_add(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n    } else {\n        mpz_need_dig(dest, lhs->len);\n        dest->len = mpn_sub(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n    }\n\n    if (dest->len == 0) {\n        dest->neg = 0;\n    } else if (neg) {\n        dest->neg = 1 - lhs->neg;\n    } else {\n        dest->neg = lhs->neg;\n    }\n}\n\n \nvoid mpz_and_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    \n    if (lhs->len < rhs->len) {\n        const mpz_t *temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n\n    #if MICROPY_OPT_MPZ_BITWISE\n\n    if ((0 == lhs->neg) && (0 == rhs->neg)) {\n        mpz_need_dig(dest, lhs->len);\n        dest->len = mpn_and(dest->dig, lhs->dig, rhs->dig, rhs->len);\n        dest->neg = 0;\n    } else {\n        mpz_need_dig(dest, lhs->len + 1);\n        dest->len = mpn_and_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,\n            lhs->neg == rhs->neg, 0 != lhs->neg, 0 != rhs->neg);\n        dest->neg = lhs->neg & rhs->neg;\n    }\n\n    #else\n\n    mpz_need_dig(dest, lhs->len + (lhs->neg || rhs->neg));\n    dest->len = mpn_and_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,\n        (lhs->neg == rhs->neg) ? lhs->neg : 0, lhs->neg, rhs->neg);\n    dest->neg = lhs->neg & rhs->neg;\n\n    #endif\n}\n\n \nvoid mpz_or_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    \n    if (lhs->len < rhs->len) {\n        const mpz_t *temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n\n    #if MICROPY_OPT_MPZ_BITWISE\n\n    if ((0 == lhs->neg) && (0 == rhs->neg)) {\n        mpz_need_dig(dest, lhs->len);\n        dest->len = mpn_or(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n        dest->neg = 0;\n    } else {\n        mpz_need_dig(dest, lhs->len + 1);\n        dest->len = mpn_or_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,\n            0 != lhs->neg, 0 != rhs->neg);\n        dest->neg = 1;\n    }\n\n    #else\n\n    mpz_need_dig(dest, lhs->len + (lhs->neg || rhs->neg));\n    dest->len = mpn_or_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,\n        (lhs->neg || rhs->neg), lhs->neg, rhs->neg);\n    dest->neg = lhs->neg | rhs->neg;\n\n    #endif\n}\n\n \nvoid mpz_xor_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    \n    if (lhs->len < rhs->len) {\n        const mpz_t *temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n\n    #if MICROPY_OPT_MPZ_BITWISE\n\n    if (lhs->neg == rhs->neg) {\n        mpz_need_dig(dest, lhs->len);\n        if (lhs->neg == 0) {\n            dest->len = mpn_xor(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n        } else {\n            dest->len = mpn_xor_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len, 0, 0, 0);\n        }\n        dest->neg = 0;\n    } else {\n        mpz_need_dig(dest, lhs->len + 1);\n        dest->len = mpn_xor_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len, 1,\n            0 == lhs->neg, 0 == rhs->neg);\n        dest->neg = 1;\n    }\n\n    #else\n\n    mpz_need_dig(dest, lhs->len + (lhs->neg || rhs->neg));\n    dest->len = mpn_xor_neg(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,\n        (lhs->neg != rhs->neg), 0 == lhs->neg, 0 == rhs->neg);\n    dest->neg = lhs->neg ^ rhs->neg;\n\n    #endif\n}\n\n \nvoid mpz_mul_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    if (lhs->len == 0 || rhs->len == 0) {\n        mpz_set_from_int(dest, 0);\n        return;\n    }\n\n    mpz_t *temp = NULL;\n    if (lhs == dest) {\n        lhs = temp = mpz_clone(lhs);\n        if (rhs == dest) {\n            rhs = lhs;\n        }\n    } else if (rhs == dest) {\n        rhs = temp = mpz_clone(rhs);\n    }\n\n    mpz_need_dig(dest, lhs->len + rhs->len); \n    memset(dest->dig, 0, dest->alloc * sizeof(mpz_dig_t));\n    dest->len = mpn_mul(dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);\n\n    if (lhs->neg == rhs->neg) {\n        dest->neg = 0;\n    } else {\n        dest->neg = 1;\n    }\n\n    mpz_free(temp);\n}\n\n \nvoid mpz_pow_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {\n    if (lhs->len == 0 || rhs->neg != 0) {\n        mpz_set_from_int(dest, 0);\n        return;\n    }\n\n    if (rhs->len == 0) {\n        mpz_set_from_int(dest, 1);\n        return;\n    }\n\n    mpz_t *x = mpz_clone(lhs);\n    mpz_t *n = mpz_clone(rhs);\n\n    mpz_set_from_int(dest, 1);\n\n    while (n->len > 0) {\n        if ((n->dig[0] & 1) != 0) {\n            mpz_mul_inpl(dest, dest, x);\n        }\n        n->len = mpn_shr(n->dig, n->dig, n->len, 1);\n        if (n->len == 0) {\n            break;\n        }\n        mpz_mul_inpl(x, x, x);\n    }\n\n    mpz_free(x);\n    mpz_free(n);\n}\n\n \nvoid mpz_pow3_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs, const mpz_t *mod) {\n    if (lhs->len == 0 || rhs->neg != 0 || (mod->len == 1 && mod->dig[0] == 1)) {\n        mpz_set_from_int(dest, 0);\n        return;\n    }\n\n    mpz_set_from_int(dest, 1);\n\n    if (rhs->len == 0) {\n        return;\n    }\n\n    mpz_t *x = mpz_clone(lhs);\n    mpz_t *n = mpz_clone(rhs);\n    mpz_t quo;\n    mpz_init_zero(&quo);\n\n    while (n->len > 0) {\n        if ((n->dig[0] & 1) != 0) {\n            mpz_mul_inpl(dest, dest, x);\n            mpz_divmod_inpl(&quo, dest, dest, mod);\n        }\n        n->len = mpn_shr(n->dig, n->dig, n->len, 1);\n        if (n->len == 0) {\n            break;\n        }\n        mpz_mul_inpl(x, x, x);\n        mpz_divmod_inpl(&quo, x, x, mod);\n    }\n\n    mpz_deinit(&quo);\n    mpz_free(x);\n    mpz_free(n);\n}\n\n#if 0\nthese functions are unused\n\n \nmpz_t *mpz_gcd(const mpz_t *z1, const mpz_t *z2) {\n    if (z1->len == 0) {\n        \n        mpz_t *a = mpz_clone(z2);\n        a->neg = 0;\n        return a;\n    } else if (z2->len == 0) {\n        mpz_t *a = mpz_clone(z1);\n        a->neg = 0;\n        return a;\n    }\n\n    mpz_t *a = mpz_clone(z1);\n    mpz_t *b = mpz_clone(z2);\n    mpz_t c;\n    mpz_init_zero(&c);\n    a->neg = 0;\n    b->neg = 0;\n\n    for (;;) {\n        if (mpz_cmp(a, b) < 0) {\n            if (a->len == 0) {\n                mpz_free(a);\n                mpz_deinit(&c);\n                return b;\n            }\n            mpz_t *t = a;\n            a = b;\n            b = t;\n        }\n        if (!(b->len >= 2 || (b->len == 1 && b->dig[0] > 1))) { \n            break;\n        }\n        mpz_set(&c, b);\n        do {\n            mpz_add_inpl(&c, &c, &c);\n        } while (mpz_cmp(&c, a) <= 0);\n        c.len = mpn_shr(c.dig, c.dig, c.len, 1);\n        mpz_sub_inpl(a, a, &c);\n    }\n\n    mpz_deinit(&c);\n\n    if (b->len == 1 && b->dig[0] == 1) { \n        mpz_free(a);\n        return b;\n    } else {\n        mpz_free(b);\n        return a;\n    }\n}\n\n \nmpz_t *mpz_lcm(const mpz_t *z1, const mpz_t *z2) {\n    if (z1->len == 0 || z2->len == 0) {\n        return mpz_zero();\n    }\n\n    mpz_t *gcd = mpz_gcd(z1, z2);\n    mpz_t *quo = mpz_zero();\n    mpz_t *rem = mpz_zero();\n    mpz_divmod_inpl(quo, rem, z1, gcd);\n    mpz_mul_inpl(rem, quo, z2);\n    mpz_free(gcd);\n    mpz_free(quo);\n    rem->neg = 0;\n    return rem;\n}\n#endif\n\n \nvoid mpz_divmod_inpl(mpz_t *dest_quo, mpz_t *dest_rem, const mpz_t *lhs, const mpz_t *rhs) {\n    assert(!mpz_is_zero(rhs));\n\n    mpz_need_dig(dest_quo, lhs->len + 1); \n    memset(dest_quo->dig, 0, (lhs->len + 1) * sizeof(mpz_dig_t));\n    dest_quo->neg = 0;\n    dest_quo->len = 0;\n    mpz_need_dig(dest_rem, lhs->len + 1); \n    mpz_set(dest_rem, lhs);\n    mpn_div(dest_rem->dig, &dest_rem->len, rhs->dig, rhs->len, dest_quo->dig, &dest_quo->len);\n    dest_rem->neg &= !!dest_rem->len;\n\n    \n    if (lhs->neg != rhs->neg) {\n        dest_quo->neg = !!dest_quo->len;\n        if (!mpz_is_zero(dest_rem)) {\n            mpz_t mpzone;\n            mpz_init_from_int(&mpzone, -1);\n            mpz_add_inpl(dest_quo, dest_quo, &mpzone);\n            mpz_add_inpl(dest_rem, dest_rem, rhs);\n        }\n    }\n}\n\n#if 0\nthese functions are unused\n\n \nmpz_t *mpz_div(const mpz_t *lhs, const mpz_t *rhs) {\n    mpz_t *quo = mpz_zero();\n    mpz_t rem;\n    mpz_init_zero(&rem);\n    mpz_divmod_inpl(quo, &rem, lhs, rhs);\n    mpz_deinit(&rem);\n    return quo;\n}\n\n \nmpz_t *mpz_mod(const mpz_t *lhs, const mpz_t *rhs) {\n    mpz_t quo;\n    mpz_init_zero(&quo);\n    mpz_t *rem = mpz_zero();\n    mpz_divmod_inpl(&quo, rem, lhs, rhs);\n    mpz_deinit(&quo);\n    return rem;\n}\n#endif\n\n\nmp_int_t mpz_hash(const mpz_t *z) {\n    mp_uint_t val = 0;\n    mpz_dig_t *d = z->dig + z->len;\n\n    while (d-- > z->dig) {\n        val = (val << DIG_SIZE) | *d;\n    }\n\n    if (z->neg != 0) {\n        val = -val;\n    }\n\n    return val;\n}\n\nbool mpz_as_int_checked(const mpz_t *i, mp_int_t *value) {\n    mp_uint_t val = 0;\n    mpz_dig_t *d = i->dig + i->len;\n\n    while (d-- > i->dig) {\n        if (val > (~(MP_OBJ_WORD_MSBIT_HIGH) >> DIG_SIZE)) {\n            \n            return false;\n        }\n        val = (val << DIG_SIZE) | *d;\n    }\n\n    if (i->neg != 0) {\n        val = -val;\n    }\n\n    *value = val;\n    return true;\n}\n\nbool mpz_as_uint_checked(const mpz_t *i, mp_uint_t *value) {\n    if (i->neg != 0) {\n        \n        return false;\n    }\n\n    mp_uint_t val = 0;\n    mpz_dig_t *d = i->dig + i->len;\n\n    while (d-- > i->dig) {\n        if (val > (~(MP_OBJ_WORD_MSBIT_HIGH) >> (DIG_SIZE - 1))) {\n            \n            return false;\n        }\n        val = (val << DIG_SIZE) | *d;\n    }\n\n    *value = val;\n    return true;\n}\n\nvoid mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n    byte *b = buf;\n    if (big_endian) {\n        b += len;\n    }\n    mpz_dig_t *zdig = z->dig;\n    int bits = 0;\n    mpz_dbl_dig_t d = 0;\n    mpz_dbl_dig_t carry = 1;\n    for (size_t zlen = z->len; zlen > 0; --zlen) {\n        bits += DIG_SIZE;\n        d = (d << DIG_SIZE) | *zdig++;\n        for (; bits >= 8; bits -= 8, d >>= 8) {\n            mpz_dig_t val = d;\n            if (z->neg) {\n                val = (~val & 0xff) + carry;\n                carry = val >> 8;\n            }\n            if (big_endian) {\n                *--b = val;\n                if (b == buf) {\n                    return;\n                }\n            } else {\n                *b++ = val;\n                if (b == buf + len) {\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    if (big_endian) {\n        len = b - buf;\n    } else {\n        len = buf + len - b;\n        buf = b;\n    }\n    memset(buf, z->neg ? 0xff : 0x00, len);\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nmp_float_t mpz_as_float(const mpz_t *i) {\n    mp_float_t val = 0;\n    mpz_dig_t *d = i->dig + i->len;\n\n    while (d-- > i->dig) {\n        val = val * DIG_BASE + *d;\n    }\n\n    if (i->neg != 0) {\n        val = -val;\n    }\n\n    return val;\n}\n#endif\n\n#if 0\nthis function is unused\nchar *mpz_as_str(const mpz_t *i, unsigned int base) {\n    char *s = m_new(char, mp_int_format_size(mpz_max_num_bits(i), base, NULL, '\\0'));\n    mpz_as_str_inpl(i, base, NULL, 'a', '\\0', s);\n    return s;\n}\n#endif\n\n\n\n\nsize_t mpz_as_str_inpl(const mpz_t *i, unsigned int base, const char *prefix, char base_char, char comma, char *str) {\n    assert(str != NULL);\n    assert(2 <= base && base <= 32);\n\n    size_t ilen = i->len;\n\n    char *s = str;\n    if (ilen == 0) {\n        if (prefix) {\n            while (*prefix) {\n                *s++ = *prefix++;\n            }\n        }\n        *s++ = '0';\n        *s = '\\0';\n        return s - str;\n    }\n\n    \n    mpz_dig_t *dig = m_new(mpz_dig_t, ilen);\n    memcpy(dig, i->dig, ilen * sizeof(mpz_dig_t));\n\n    \n    char *last_comma = str;\n    bool done;\n    do {\n        mpz_dig_t *d = dig + ilen;\n        mpz_dbl_dig_t a = 0;\n\n        \n        while (--d >= dig) {\n            a = (a << DIG_SIZE) | *d;\n            *d = a / base;\n            a %= base;\n        }\n\n        \n        a += '0';\n        if (a > '9') {\n            a += base_char - '9' - 1;\n        }\n        *s++ = a;\n\n        \n        done = true;\n        for (d = dig; d < dig + ilen; ++d) {\n            if (*d != 0) {\n                done = false;\n                break;\n            }\n        }\n        if (comma && (s - last_comma) == 3) {\n            *s++ = comma;\n            last_comma = s;\n        }\n    }\n    while (!done);\n\n    \n    m_del(mpz_dig_t, dig, ilen);\n\n    if (prefix) {\n        const char *p = &prefix[strlen(prefix)];\n        while (p > prefix) {\n            *s++ = *--p;\n        }\n    }\n    if (i->neg != 0) {\n        *s++ = '-';\n    }\n\n    \n    for (char *u = str, *v = s - 1; u < v; ++u, --v) {\n        char temp = *u;\n        *u = *v;\n        *v = temp;\n    }\n\n    *s = '\\0'; \n\n    return s - str;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}