{
  "module_name": "objfloat.c",
  "hash_id": "fc02ccd8ba6b930abba92d2e1383606867091649cf74ffe45dc1cae11c5bbcba",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objfloat.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/parsenum.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n\n#include <math.h>\n#include \"py/formatfloat.h\"\n\n#if MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_C && MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_D\n\n\n#ifndef M_E\n#define M_E (2.7182818284590452354)\n#endif\n#ifndef M_PI\n#define M_PI (3.14159265358979323846)\n#endif\n\ntypedef struct _mp_obj_float_t {\n    mp_obj_base_t base;\n    mp_float_t value;\n} mp_obj_float_t;\n\nconst mp_obj_float_t mp_const_float_e_obj = {{&mp_type_float}, (mp_float_t)M_E};\nconst mp_obj_float_t mp_const_float_pi_obj = {{&mp_type_float}, (mp_float_t)M_PI};\n#if MICROPY_PY_MATH_CONSTANTS\n#ifndef NAN\n#error NAN macro is not defined\n#endif\nconst mp_obj_float_t mp_const_float_tau_obj = {{&mp_type_float}, (mp_float_t)(2.0 * M_PI)};\nconst mp_obj_float_t mp_const_float_inf_obj = {{&mp_type_float}, (mp_float_t)INFINITY};\nconst mp_obj_float_t mp_const_float_nan_obj = {{&mp_type_float}, (mp_float_t)NAN};\n#endif\n\n#endif\n\n#define MICROPY_FLOAT_ZERO MICROPY_FLOAT_CONST(0.0)\n\n#if MICROPY_FLOAT_HIGH_QUALITY_HASH\n\nmp_int_t mp_float_hash(mp_float_t src) {\n    mp_float_union_t u = {.f = src};\n    mp_int_t val;\n    const int adj_exp = (int)u.p.exp - MP_FLOAT_EXP_BIAS;\n    if (adj_exp < 0) {\n        \n        val = u.i;\n    } else {\n        \n        \n        mp_float_uint_t frc = u.p.frc | ((mp_float_uint_t)1 << MP_FLOAT_FRAC_BITS);\n\n        if (adj_exp <= MP_FLOAT_FRAC_BITS) {\n            \n            val = (frc >> (MP_FLOAT_FRAC_BITS - adj_exp))\n                ^ (frc & (((mp_float_uint_t)1 << (MP_FLOAT_FRAC_BITS - adj_exp)) - 1));\n        } else if ((unsigned int)adj_exp < MP_BITS_PER_BYTE * sizeof(mp_int_t) - 1) {\n            \n            val = (mp_int_t)frc << (adj_exp - MP_FLOAT_FRAC_BITS);\n        } else {\n            \n            val = frc;\n        }\n    }\n\n    if (u.p.sgn) {\n        val = -(mp_uint_t)val;\n    }\n\n    return val;\n}\n#endif\n\nstatic void float_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_float_t o_val = mp_obj_float_get(o_in);\n    #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n    char buf[16];\n    #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C\n    const int precision = 6;\n    #else\n    const int precision = 7;\n    #endif\n    #else\n    char buf[32];\n    const int precision = 16;\n    #endif\n    mp_format_float(o_val, buf, sizeof(buf), 'g', precision, '\\0');\n    mp_print_str(print, buf);\n    if (strchr(buf, '.') == NULL && strchr(buf, 'e') == NULL && strchr(buf, 'n') == NULL) {\n        \n        mp_print_str(print, \".0\");\n    }\n}\n\nstatic mp_obj_t float_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n\n    switch (n_args) {\n        case 0:\n            return mp_obj_new_float(0);\n\n        case 1:\n        default: {\n            mp_buffer_info_t bufinfo;\n            if (mp_get_buffer(args[0], &bufinfo, MP_BUFFER_READ)) {\n                \n                return mp_parse_num_float(bufinfo.buf, bufinfo.len, false, NULL);\n            } else if (mp_obj_is_float(args[0])) {\n                \n                return args[0];\n            } else {\n                \n                return mp_obj_new_float(mp_obj_get_float(args[0]));\n            }\n        }\n    }\n}\n\nstatic mp_obj_t float_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    mp_float_t val = mp_obj_float_get(o_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(val != 0);\n        case MP_UNARY_OP_HASH:\n            return MP_OBJ_NEW_SMALL_INT(mp_float_hash(val));\n        case MP_UNARY_OP_POSITIVE:\n            return o_in;\n        case MP_UNARY_OP_NEGATIVE:\n            return mp_obj_new_float(-val);\n        case MP_UNARY_OP_ABS: {\n            if (signbit(val)) {\n                return mp_obj_new_float(-val);\n            } else {\n                return o_in;\n            }\n        }\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_obj_t float_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    mp_float_t lhs_val = mp_obj_float_get(lhs_in);\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    if (mp_obj_is_type(rhs_in, &mp_type_complex)) {\n        return mp_obj_complex_binary_op(op, lhs_val, 0, rhs_in);\n    }\n    #endif\n    return mp_obj_float_binary_op(op, lhs_val, rhs_in);\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_float, MP_QSTR_float, MP_TYPE_FLAG_EQ_NOT_REFLEXIVE | MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE,\n    make_new, float_make_new,\n    print, float_print,\n    unary_op, float_unary_op,\n    binary_op, float_binary_op\n    );\n\n#if MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_C && MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_D\n\nmp_obj_t mp_obj_new_float(mp_float_t value) {\n    \n    mp_obj_float_t *o = m_new_obj(mp_obj_float_t);\n    o->base.type = &mp_type_float;\n    o->value = value;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nmp_float_t mp_obj_float_get(mp_obj_t self_in) {\n    assert(mp_obj_is_float(self_in));\n    mp_obj_float_t *self = MP_OBJ_TO_PTR(self_in);\n    return self->value;\n}\n\n#endif\n\nstatic void mp_obj_float_divmod(mp_float_t *x, mp_float_t *y) {\n    \n    \n    \n    \n    mp_float_t mod = MICROPY_FLOAT_C_FUN(fmod)(*x, *y);\n    mp_float_t div = (*x - mod) / *y;\n\n    \n    if (mod == MICROPY_FLOAT_ZERO) {\n        mod = MICROPY_FLOAT_C_FUN(copysign)(MICROPY_FLOAT_ZERO, *y);\n    } else {\n        if ((mod < MICROPY_FLOAT_ZERO) != (*y < MICROPY_FLOAT_ZERO)) {\n            mod += *y;\n            div -= MICROPY_FLOAT_CONST(1.0);\n        }\n    }\n\n    mp_float_t floordiv;\n    if (div == MICROPY_FLOAT_ZERO) {\n        \n        floordiv = MICROPY_FLOAT_C_FUN(copysign)(MICROPY_FLOAT_ZERO, *x / *y);\n    } else {\n        \n        floordiv = MICROPY_FLOAT_C_FUN(floor)(div);\n        if (div - floordiv > MICROPY_FLOAT_CONST(0.5)) {\n            floordiv += MICROPY_FLOAT_CONST(1.0);\n        }\n    }\n\n    \n    *x = floordiv;\n    *y = mod;\n}\n\nmp_obj_t mp_obj_float_binary_op(mp_binary_op_t op, mp_float_t lhs_val, mp_obj_t rhs_in) {\n    mp_float_t rhs_val;\n    if (!mp_obj_get_float_maybe(rhs_in, &rhs_val)) {\n        return MP_OBJ_NULL; \n    }\n\n    switch (op) {\n        case MP_BINARY_OP_ADD:\n        case MP_BINARY_OP_INPLACE_ADD:\n            lhs_val += rhs_val;\n            break;\n        case MP_BINARY_OP_SUBTRACT:\n        case MP_BINARY_OP_INPLACE_SUBTRACT:\n            lhs_val -= rhs_val;\n            break;\n        case MP_BINARY_OP_MULTIPLY:\n        case MP_BINARY_OP_INPLACE_MULTIPLY:\n            lhs_val *= rhs_val;\n            break;\n        case MP_BINARY_OP_FLOOR_DIVIDE:\n        case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:\n            if (rhs_val == 0) {\n            zero_division_error:\n                mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"divide by zero\"));\n            }\n            \n            \n            \n            mp_obj_float_divmod(&lhs_val, &rhs_val);\n            break;\n        case MP_BINARY_OP_TRUE_DIVIDE:\n        case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:\n            if (rhs_val == 0) {\n                goto zero_division_error;\n            }\n            lhs_val /= rhs_val;\n            break;\n        case MP_BINARY_OP_MODULO:\n        case MP_BINARY_OP_INPLACE_MODULO:\n            if (rhs_val == MICROPY_FLOAT_ZERO) {\n                goto zero_division_error;\n            }\n            lhs_val = MICROPY_FLOAT_C_FUN(fmod)(lhs_val, rhs_val);\n            \n            if (lhs_val == MICROPY_FLOAT_ZERO) {\n                lhs_val = MICROPY_FLOAT_C_FUN(copysign)(0.0, rhs_val);\n            } else {\n                if ((lhs_val < MICROPY_FLOAT_ZERO) != (rhs_val < MICROPY_FLOAT_ZERO)) {\n                    lhs_val += rhs_val;\n                }\n            }\n            break;\n        case MP_BINARY_OP_POWER:\n        case MP_BINARY_OP_INPLACE_POWER:\n            if (lhs_val == 0 && rhs_val < 0 && !isinf(rhs_val)) {\n                goto zero_division_error;\n            }\n            if (lhs_val < 0 && rhs_val != MICROPY_FLOAT_C_FUN(floor)(rhs_val) && !isnan(rhs_val)) {\n                #if MICROPY_PY_BUILTINS_COMPLEX\n                return mp_obj_complex_binary_op(MP_BINARY_OP_POWER, lhs_val, 0, rhs_in);\n                #else\n                mp_raise_ValueError(MP_ERROR_TEXT(\"complex values not supported\"));\n                #endif\n            }\n            #if MICROPY_PY_MATH_POW_FIX_NAN \n            if (lhs_val == MICROPY_FLOAT_CONST(1.0) || rhs_val == MICROPY_FLOAT_CONST(0.0)) {\n                lhs_val = MICROPY_FLOAT_CONST(1.0);\n                break;\n            }\n            #endif\n            lhs_val = MICROPY_FLOAT_C_FUN(pow)(lhs_val, rhs_val);\n            break;\n        case MP_BINARY_OP_DIVMOD: {\n            if (rhs_val == 0) {\n                goto zero_division_error;\n            }\n            mp_obj_float_divmod(&lhs_val, &rhs_val);\n            mp_obj_t tuple[2] = {\n                mp_obj_new_float(lhs_val),\n                mp_obj_new_float(rhs_val),\n            };\n            return mp_obj_new_tuple(2, tuple);\n        }\n        case MP_BINARY_OP_LESS:\n            return mp_obj_new_bool(lhs_val < rhs_val);\n        case MP_BINARY_OP_MORE:\n            return mp_obj_new_bool(lhs_val > rhs_val);\n        case MP_BINARY_OP_EQUAL:\n            return mp_obj_new_bool(lhs_val == rhs_val);\n        case MP_BINARY_OP_LESS_EQUAL:\n            return mp_obj_new_bool(lhs_val <= rhs_val);\n        case MP_BINARY_OP_MORE_EQUAL:\n            return mp_obj_new_bool(lhs_val >= rhs_val);\n\n        default:\n            return MP_OBJ_NULL; \n    }\n    return mp_obj_new_float(lhs_val);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}