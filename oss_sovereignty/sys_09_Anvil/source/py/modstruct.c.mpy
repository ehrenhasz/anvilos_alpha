{
  "module_name": "modstruct.c",
  "hash_id": "16cb6871f5e886c0fb12bc68f466a74f4bc36ff7ca0b27cbcd48e2ceec39d962",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modstruct.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/objtuple.h\"\n#include \"py/binary.h\"\n#include \"py/parsenum.h\"\n\n#if MICROPY_PY_STRUCT\n\n \n\nstatic char get_fmt_type(const char **fmt) {\n    char t = **fmt;\n    switch (t) {\n        case '!':\n            t = '>';\n            break;\n        case '@':\n        case '=':\n        case '<':\n        case '>':\n            break;\n        default:\n            return '@';\n    }\n    \n    (*fmt)++;\n    return t;\n}\n\nstatic mp_uint_t get_fmt_num(const char **p) {\n    const char *num = *p;\n    uint len = 1;\n    while (unichar_isdigit(*++num)) {\n        len++;\n    }\n    mp_uint_t val = (mp_uint_t)MP_OBJ_SMALL_INT_VALUE(mp_parse_num_integer(*p, len, 10, NULL));\n    *p = num;\n    return val;\n}\n\nstatic size_t calc_size_items(const char *fmt, size_t *total_sz) {\n    char fmt_type = get_fmt_type(&fmt);\n    size_t total_cnt = 0;\n    size_t size;\n    for (size = 0; *fmt; fmt++) {\n        mp_uint_t cnt = 1;\n        if (unichar_isdigit(*fmt)) {\n            cnt = get_fmt_num(&fmt);\n        }\n\n        if (*fmt == 'x') {\n            size += cnt;\n        } else if (*fmt == 's') {\n            total_cnt += 1;\n            size += cnt;\n        } else {\n            total_cnt += cnt;\n            size_t align;\n            size_t sz = mp_binary_get_size(fmt_type, *fmt, &align);\n            while (cnt--) {\n                \n                size = (size + align - 1) & ~(align - 1);\n                size += sz;\n            }\n        }\n    }\n    *total_sz = size;\n    return total_cnt;\n}\n\nstatic mp_obj_t struct_calcsize(mp_obj_t fmt_in) {\n    const char *fmt = mp_obj_str_get_str(fmt_in);\n    size_t size;\n    calc_size_items(fmt, &size);\n    return MP_OBJ_NEW_SMALL_INT(size);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(struct_calcsize_obj, struct_calcsize);\n\nstatic mp_obj_t struct_unpack_from(size_t n_args, const mp_obj_t *args) {\n    \n    \n    \n    \n    const char *fmt = mp_obj_str_get_str(args[0]);\n    size_t total_sz;\n    size_t num_items = calc_size_items(fmt, &total_sz);\n    char fmt_type = get_fmt_type(&fmt);\n    mp_obj_tuple_t *res = MP_OBJ_TO_PTR(mp_obj_new_tuple(num_items, NULL));\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_READ);\n    byte *p = bufinfo.buf;\n    byte *end_p = &p[bufinfo.len];\n    mp_int_t offset = 0;\n\n    if (n_args > 2) {\n        \n        offset = mp_obj_get_int(args[2]);\n        if (offset < 0) {\n            \n            offset = bufinfo.len + offset;\n            if (offset < 0) {\n                mp_raise_ValueError(MP_ERROR_TEXT(\"buffer too small\"));\n            }\n        }\n        p += offset;\n    }\n    byte *p_base = p;\n\n    \n    if (p + total_sz > end_p) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"buffer too small\"));\n    }\n\n    for (size_t i = 0; i < num_items;) {\n        mp_uint_t cnt = 1;\n        if (unichar_isdigit(*fmt)) {\n            cnt = get_fmt_num(&fmt);\n        }\n        mp_obj_t item;\n        if (*fmt == 'x') {\n            p += cnt;\n        } else if (*fmt == 's') {\n            item = mp_obj_new_bytes(p, cnt);\n            p += cnt;\n            res->items[i++] = item;\n        } else {\n            while (cnt--) {\n                item = mp_binary_get_val(fmt_type, *fmt, p_base, &p);\n                res->items[i++] = item;\n            }\n        }\n        fmt++;\n    }\n    return MP_OBJ_FROM_PTR(res);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(struct_unpack_from_obj, 2, 3, struct_unpack_from);\n\n\nstatic void struct_pack_into_internal(mp_obj_t fmt_in, byte *p, size_t n_args, const mp_obj_t *args) {\n    const char *fmt = mp_obj_str_get_str(fmt_in);\n    char fmt_type = get_fmt_type(&fmt);\n\n    byte *p_base = p;\n    size_t i;\n    for (i = 0; i < n_args;) {\n        mp_uint_t cnt = 1;\n        if (*fmt == '\\0') {\n            \n            break;\n        }\n        if (unichar_isdigit(*fmt)) {\n            cnt = get_fmt_num(&fmt);\n        }\n\n        if (*fmt == 'x') {\n            memset(p, 0, cnt);\n            p += cnt;\n        } else if (*fmt == 's') {\n            mp_buffer_info_t bufinfo;\n            mp_get_buffer_raise(args[i++], &bufinfo, MP_BUFFER_READ);\n            mp_uint_t to_copy = cnt;\n            if (bufinfo.len < to_copy) {\n                to_copy = bufinfo.len;\n            }\n            memcpy(p, bufinfo.buf, to_copy);\n            memset(p + to_copy, 0, cnt - to_copy);\n            p += cnt;\n        } else {\n            \n            while (cnt-- && i < n_args) {\n                mp_binary_set_val(fmt_type, *fmt, args[i++], p_base, &p);\n            }\n        }\n        fmt++;\n    }\n}\n\nstatic mp_obj_t struct_pack(size_t n_args, const mp_obj_t *args) {\n    \n    mp_int_t size = MP_OBJ_SMALL_INT_VALUE(struct_calcsize(args[0]));\n    vstr_t vstr;\n    vstr_init_len(&vstr, size);\n    byte *p = (byte *)vstr.buf;\n    memset(p, 0, size);\n    struct_pack_into_internal(args[0], p, n_args - 1, &args[1]);\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(struct_pack_obj, 1, MP_OBJ_FUN_ARGS_MAX, struct_pack);\n\nstatic mp_obj_t struct_pack_into(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_WRITE);\n    mp_int_t offset = mp_obj_get_int(args[2]);\n    if (offset < 0) {\n        \n        offset = (mp_int_t)bufinfo.len + offset;\n        if (offset < 0) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"buffer too small\"));\n        }\n    }\n    byte *p = (byte *)bufinfo.buf;\n    byte *end_p = &p[bufinfo.len];\n    p += offset;\n\n    \n    mp_int_t sz = MP_OBJ_SMALL_INT_VALUE(struct_calcsize(args[0]));\n    if (p + sz > end_p) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"buffer too small\"));\n    }\n\n    struct_pack_into_internal(args[0], p, n_args - 3, &args[3]);\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(struct_pack_into_obj, 3, MP_OBJ_FUN_ARGS_MAX, struct_pack_into);\n\nstatic const mp_rom_map_elem_t mp_module_struct_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_struct) },\n    { MP_ROM_QSTR(MP_QSTR_calcsize), MP_ROM_PTR(&struct_calcsize_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pack), MP_ROM_PTR(&struct_pack_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pack_into), MP_ROM_PTR(&struct_pack_into_obj) },\n    { MP_ROM_QSTR(MP_QSTR_unpack), MP_ROM_PTR(&struct_unpack_from_obj) },\n    { MP_ROM_QSTR(MP_QSTR_unpack_from), MP_ROM_PTR(&struct_unpack_from_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_struct_globals, mp_module_struct_globals_table);\n\nconst mp_obj_module_t mp_module_struct = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_struct_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_struct, mp_module_struct);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}