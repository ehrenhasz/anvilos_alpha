{
  "module_name": "mkrules.mk",
  "hash_id": "4bd9276195e8394297ecc1764e5996f961411cd62a374aef47802252ea076d2b",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/mkrules.mk",
  "human_readable_source": "ifneq ($(MKENV_INCLUDED),1)\n# We assume that mkenv is in the same directory as this file.\nTHIS_MAKEFILE = $(lastword $(MAKEFILE_LIST))\ninclude $(dir $(THIS_MAKEFILE))mkenv.mk\nendif\n\n# Enable in-progress/breaking changes that are slated for MicroPython 2.x.\nMICROPY_PREVIEW_VERSION_2 ?= 0\n\nifeq ($(MICROPY_PREVIEW_VERSION_2),1)\nCFLAGS += -DMICROPY_PREVIEW_VERSION_2=1\nendif\n\nHELP_BUILD_ERROR ?= \"See \\033[1;31mhttps://github.com/micropython/micropython/wiki/Build-Troubleshooting\\033[0m\"\nHELP_MPY_LIB_SUBMODULE ?= \"\\033[1;31mError: micropython-lib submodule is not initialized.\\033[0m Run 'make submodules'\"\n\n# Extra deps that need to happen before object compilation.\nOBJ_EXTRA_ORDER_DEPS =\n\n# Generate header files.\nOBJ_EXTRA_ORDER_DEPS += $(HEADER_BUILD)/moduledefs.h $(HEADER_BUILD)/root_pointers.h\n\nifeq ($(MICROPY_ROM_TEXT_COMPRESSION),1)\n# If compression is enabled, trigger the build of compressed.data.h...\nOBJ_EXTRA_ORDER_DEPS += $(HEADER_BUILD)/compressed.data.h\n# ...and enable the MP_COMPRESSED_ROM_TEXT macro (used by MP_ERROR_TEXT).\nCFLAGS += -DMICROPY_ROM_TEXT_COMPRESSION=1\nendif\n\n# QSTR generation uses the same CFLAGS, with these modifications.\nQSTR_GEN_FLAGS = -DNO_QSTR\n# Note: := to force evaluation immediately.\nQSTR_GEN_CFLAGS := $(CFLAGS)\nQSTR_GEN_CFLAGS += $(QSTR_GEN_FLAGS)\nQSTR_GEN_CXXFLAGS := $(CXXFLAGS)\nQSTR_GEN_CXXFLAGS += $(QSTR_GEN_FLAGS)\n\n# This file expects that OBJ contains a list of all of the object files.\n# The directory portion of each object file is used to locate the source\n# and should not contain any ..'s but rather be relative to the top of the\n# tree.\n#\n# So for example, py/map.c would have an object file name py/map.o\n# The object files will go into the build directory and maintain the same\n# directory structure as the source tree. So the final dependency will look\n# like this:\n#\n# build/py/map.o: py/map.c\n#\n# We set vpath to point to the top of the tree so that the source files\n# can be located. By following this scheme, it allows a single build rule\n# to be used to compile all .c files.\n\nvpath %.S . $(TOP) $(USER_C_MODULES)\n$(BUILD)/%.o: %.S\n\t$(ECHO) \"CC $<\"\n\t$(Q)$(CC) $(CFLAGS) -c -o $@ $<\n\nvpath %.s . $(TOP) $(USER_C_MODULES)\n$(BUILD)/%.o: %.s\n\t$(ECHO) \"AS $<\"\n\t$(Q)$(AS) $(AFLAGS) -o $@ $<\n\ndefine compile_c\n$(ECHO) \"CC $<\"\n$(Q)$(CC) $(CFLAGS) -c -MD -MF $(@:.o=.d) -o $@ $< || (echo -e $(HELP_BUILD_ERROR); false)\n@# The following fixes the dependency file.\n@# See http://make.paulandlesley.org/autodep.html for details.\n@# Regex adjusted from the above to play better with Windows paths, etc.\n@$(CP) $(@:.o=.d) $(@:.o=.P); \\\n  $(SED) -e 's/#.*//' -e 's/^.*:  *//' -e 's/ *\\\\$$//' \\\n      -e '/^$$/ d' -e 's/$$/ :/' < $(@:.o=.d) >> $(@:.o=.P); \\\n  $(RM) -f $(@:.o=.d)\nendef\n\ndefine compile_cxx\n$(ECHO) \"CXX $<\"\n$(Q)$(CXX) $(CXXFLAGS) -c -MD -MF $(@:.o=.d) -o $@ $< || (echo -e $(HELP_BUILD_ERROR); false)\n@# The following fixes the dependency file.\n@# See http://make.paulandlesley.org/autodep.html for details.\n@# Regex adjusted from the above to play better with Windows paths, etc.\n@$(CP) $(@:.o=.d) $(@:.o=.P); \\\n  $(SED) -e 's/#.*//' -e 's/^.*:  *//' -e 's/ *\\\\$$//' \\\n      -e '/^$$/ d' -e 's/$$/ :/' < $(@:.o=.d) >> $(@:.o=.P); \\\n  $(RM) -f $(@:.o=.d)\nendef\n\nvpath %.c . $(TOP) $(USER_C_MODULES)\n$(BUILD)/%.o: %.c\n\t$(call compile_c)\n\nvpath %.cpp . $(TOP) $(USER_C_MODULES)\n$(BUILD)/%.o: %.cpp\n\t$(call compile_cxx)\n\n$(BUILD)/%.pp: %.c\n\t$(ECHO) \"PreProcess $<\"\n\t$(Q)$(CPP) $(CFLAGS) -Wp,-C,-dD,-dI -o $@ $<\n\n# Special case for compiling auto-generated source files.\n$(BUILD)/%.o: $(BUILD)/%.c\n\t$(call compile_c)\n\n# The following rule uses | to create an order only prerequisite. Order only\n# prerequisites only get built if they don't exist. They don't cause timestamp\n# checking to be performed.\n#\n# We don't know which source files actually need the generated.h (since\n# it is #included from str.h). The compiler generated dependencies will cause\n# the right .o's to get recompiled if the generated.h file changes. Adding\n# an order-only dependency to all of the .o's will cause the generated .h\n# to get built before we try to compile any of them.\n$(OBJ): | $(HEADER_BUILD)/qstrdefs.generated.h $(HEADER_BUILD)/mpversion.h $(OBJ_EXTRA_ORDER_DEPS)\n\n# The logic for qstr regeneration (applied by makeqstrdefs.py) is:\n# - if anything in QSTR_GLOBAL_DEPENDENCIES is newer, then process all source files ($^)\n# - else, if list of newer prerequisites ($?) is not empty, then process just these ($?)\n# - else, process all source files ($^) [this covers \"make -B\" which can set $? to empty]\n# See more information about this process in docs/develop/qstr.rst.\n$(HEADER_BUILD)/qstr.i.last: $(SRC_QSTR) $(QSTR_GLOBAL_DEPENDENCIES) | $(QSTR_GLOBAL_REQUIREMENTS)\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py pp $(CPP) output $(HEADER_BUILD)/qstr.i.last cflags $(QSTR_GEN_CFLAGS) cxxflags $(QSTR_GEN_CXXFLAGS) sources $^ dependencies $(QSTR_GLOBAL_DEPENDENCIES) changed_sources $?\n\n$(HEADER_BUILD)/qstr.split: $(HEADER_BUILD)/qstr.i.last\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py split qstr $< $(HEADER_BUILD)/qstr _\n\t$(Q)$(TOUCH) $@\n\n$(QSTR_DEFS_COLLECTED): $(HEADER_BUILD)/qstr.split\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py cat qstr _ $(HEADER_BUILD)/qstr $@\n\n# Module definitions via MP_REGISTER_MODULE.\n$(HEADER_BUILD)/moduledefs.split: $(HEADER_BUILD)/qstr.i.last\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py split module $< $(HEADER_BUILD)/module _\n\t$(Q)$(TOUCH) $@\n\n$(HEADER_BUILD)/moduledefs.collected: $(HEADER_BUILD)/moduledefs.split\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py cat module _ $(HEADER_BUILD)/module $@\n\n# Module definitions via MP_REGISTER_ROOT_POINTER.\n$(HEADER_BUILD)/root_pointers.split: $(HEADER_BUILD)/qstr.i.last\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py split root_pointer $< $(HEADER_BUILD)/root_pointer _\n\t$(Q)$(TOUCH) $@\n\n$(HEADER_BUILD)/root_pointers.collected: $(HEADER_BUILD)/root_pointers.split\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py cat root_pointer _ $(HEADER_BUILD)/root_pointer $@\n\n# Compressed error strings.\n$(HEADER_BUILD)/compressed.split: $(HEADER_BUILD)/qstr.i.last\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py split compress $< $(HEADER_BUILD)/compress _\n\t$(Q)$(TOUCH) $@\n\n$(HEADER_BUILD)/compressed.collected: $(HEADER_BUILD)/compressed.split\n\t$(ECHO) \"GEN $@\"\n\t$(Q)$(PYTHON) $(PY_SRC)/makeqstrdefs.py cat compress _ $(HEADER_BUILD)/compress $@\n\n# $(sort $(var)) removes duplicates\n#\n# The net effect of this, is it causes the objects to depend on the\n# object directories (but only for existence), and the object directories\n# will be created if they don't exist.\nOBJ_DIRS = $(sort $(dir $(OBJ)))\n$(OBJ): | $(OBJ_DIRS)\n$(OBJ_DIRS):\n\t$(MKDIR) -p $@\n\n$(HEADER_BUILD):\n\t$(MKDIR) -p $@\n\nifneq ($(MICROPY_MPYCROSS_DEPENDENCY),)\n# to automatically build mpy-cross, if needed\n$(MICROPY_MPYCROSS_DEPENDENCY):\n\t$(MAKE) -C \"$(abspath $(dir $@)..)\"\nendif\n\nifneq ($(FROZEN_DIR),)\n$(error Support for FROZEN_DIR was removed. Please use manifest.py instead, see https://docs.micropython.org/en/latest/reference/manifest.html)\nendif\n\nifneq ($(FROZEN_MPY_DIR),)\n$(error Support for FROZEN_MPY_DIR was removed. Please use manifest.py instead, see https://docs.micropython.org/en/latest/reference/manifest.html)\nendif\n\nifneq ($(FROZEN_MANIFEST),)\n# If we're using the default submodule path for micropython-lib, then make\n# sure it's included in \"make submodules\".\nifeq ($(MPY_LIB_DIR),$(MPY_LIB_SUBMODULE_DIR))\nGIT_SUBMODULES += lib/micropython-lib\nendif\n\n# Set compile options needed to enable frozen code.\nCFLAGS += -DMICROPY_QSTR_EXTRA_POOL=mp_qstr_frozen_const_pool\nCFLAGS += -DMICROPY_MODULE_FROZEN_MPY\nCFLAGS += -DMICROPY_MODULE_FROZEN_STR\n\n# Set default path variables to be passed to makemanifest.py. These will be\n# available in path substitutions. Additional variables can be set per-board\n# in mpconfigboard.mk or on the make command line.\nMICROPY_MANIFEST_MPY_LIB_DIR = $(MPY_LIB_DIR)\nMICROPY_MANIFEST_PORT_DIR = $(shell pwd)\nMICROPY_MANIFEST_BOARD_DIR = $(BOARD_DIR)\nMICROPY_MANIFEST_MPY_DIR = $(TOP)\n\n# Find all MICROPY_MANIFEST_* variables and turn them into command line arguments.\nMANIFEST_VARIABLES = $(foreach var,$(filter MICROPY_MANIFEST_%, $(.VARIABLES)),-v \"$(subst MICROPY_MANIFEST_,,$(var))=$($(var))\")\n\n# to build frozen_content.c from a manifest\n$(BUILD)/frozen_content.c: FORCE $(BUILD)/genhdr/qstrdefs.generated.h $(BUILD)/genhdr/root_pointers.h | $(MICROPY_MPYCROSS_DEPENDENCY)\n\t$(Q)test -e \"$(MPY_LIB_DIR)/README.md\" || (echo -e $(HELP_MPY_LIB_SUBMODULE); false)\n\t$(Q)$(MAKE_MANIFEST) -o $@ $(MANIFEST_VARIABLES) -b \"$(BUILD)\" $(if $(MPY_CROSS_FLAGS),-f\"$(MPY_CROSS_FLAGS)\",) --mpy-tool-flags=\"$(MPY_TOOL_FLAGS)\" $(FROZEN_MANIFEST)\nendif\n\nifneq ($(PROG),)\n# Build a standalone executable (unix does this)\n\n# The executable should have an .exe extension for builds targeting 'pure'\n# Windows, i.e. msvc or mingw builds, but not when using msys or cygwin's gcc.\nCOMPILER_TARGET := $(shell $(CC) -dumpmachine)\nifneq (,$(findstring mingw,$(COMPILER_TARGET)))\nPROG := $(PROG).exe\nendif\n\nall: $(BUILD)/$(PROG)\n\n$(BUILD)/$(PROG): $(OBJ)\n\t$(ECHO) \"LINK $@\"\n# Do not pass COPT here - it's *C* compiler optimizations. For example,\n# we may want to compile using Thumb, but link with non-Thumb libc.\n\t$(Q)$(CC) -o $@ $^ $(LIB) $(LDFLAGS)\nifndef DEBUG\nifdef STRIP\n\t$(Q)$(STRIP) $(STRIPFLAGS_EXTRA) $@\nendif\nendif\n\t$(Q)$(SIZE) $$(find $(BUILD) -path \"$(BUILD)/build/frozen*.o\") $@\n\nclean: clean-prog\nclean-prog:\n\t$(RM) -f $(BUILD)/$(PROG)\n\t$(RM) -f $(BUILD)/$(PROG).map\n\n.PHONY: clean-prog\nendif\n\nsubmodules:\n\t$(ECHO) \"Updating submodules: $(GIT_SUBMODULES)\"\nifneq ($(GIT_SUBMODULES),)\n\t$(Q)git submodule sync $(addprefix $(TOP)/,$(GIT_SUBMODULES))\n\t$(Q)git submodule update --init $(addprefix $(TOP)/,$(GIT_SUBMODULES))\nendif\n.PHONY: submodules\n\nLIBMICROPYTHON = libmicropython.a\n\n# We can execute extra commands after library creation using\n# LIBMICROPYTHON_EXTRA_CMD. This may be needed e.g. to integrate\n# with 3rd-party projects which don't have proper dependency\n# tracking. Then LIBMICROPYTHON_EXTRA_CMD can e.g. touch some\n# other file to cause needed effect, e.g. relinking with new lib.\nlib $(BUILD)/$(LIBMICROPYTHON): $(OBJ)\n\t$(Q)$(AR) rcs $(BUILD)/$(LIBMICROPYTHON) $^\n\t$(LIBMICROPYTHON_EXTRA_CMD)\n\nclean:\n\t$(RM) -rf $(BUILD) $(CLEAN_EXTRA)\n.PHONY: clean\n\nprint-cfg:\n\t$(ECHO) \"PY_SRC = $(PY_SRC)\"\n\t$(ECHO) \"BUILD  = $(BUILD)\"\n\t$(ECHO) \"OBJ    = $(OBJ)\"\n.PHONY: print-cfg\n\nprint-def:\n\t@$(ECHO) \"The following defines are built into the $(CC) compiler\"\n\t$(TOUCH) __empty__.c\n\t@$(CC) -E -Wp,-dM __empty__.c\n\t@$(RM) -f __empty__.c\n\n-include $(OBJ:.o=.P)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}