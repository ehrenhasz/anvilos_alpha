{
  "module_name": "objint_longlong.c",
  "hash_id": "76837ac6d9425ee206c8cdef0efb79a067b8d399524899eeec95db3f8b08de30",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objint_longlong.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"py/smallint.h\"\n#include \"py/objint.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#include <math.h>\n#endif\n\n#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG\n\n#if MICROPY_PY_SYS_MAXSIZE\n\nconst mp_obj_int_t mp_sys_maxsize_obj = {{&mp_type_int}, MP_SSIZE_MAX};\n#endif\n\nmp_obj_t mp_obj_int_from_bytes_impl(bool big_endian, size_t len, const byte *buf) {\n    int delta = 1;\n    if (!big_endian) {\n        buf += len - 1;\n        delta = -1;\n    }\n\n    mp_longint_impl_t value = 0;\n    for (; len--; buf += delta) {\n        value = (value << 8) | *buf;\n    }\n    return mp_obj_new_int_from_ll(value);\n}\n\nvoid mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}\n\nint mp_obj_int_sign(mp_obj_t self_in) {\n    mp_longint_impl_t val;\n    if (mp_obj_is_small_int(self_in)) {\n        val = MP_OBJ_SMALL_INT_VALUE(self_in);\n    } else {\n        mp_obj_int_t *self = self_in;\n        val = self->val;\n    }\n    if (val < 0) {\n        return -1;\n    } else if (val > 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nmp_obj_t mp_obj_int_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    mp_obj_int_t *o = o_in;\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(o->val != 0);\n\n        \n        \n        case MP_UNARY_OP_HASH:\n            return MP_OBJ_NEW_SMALL_INT((mp_int_t)o->val);\n\n        case MP_UNARY_OP_POSITIVE:\n            return o_in;\n        case MP_UNARY_OP_NEGATIVE:\n            return mp_obj_new_int_from_ll(-o->val);\n        case MP_UNARY_OP_INVERT:\n            return mp_obj_new_int_from_ll(~o->val);\n        case MP_UNARY_OP_ABS: {\n            mp_obj_int_t *self = MP_OBJ_TO_PTR(o_in);\n            if (self->val >= 0) {\n                return o_in;\n            }\n            self = mp_obj_new_int_from_ll(self->val);\n            \n            self->val = -self->val;\n            return MP_OBJ_FROM_PTR(self);\n        }\n        case MP_UNARY_OP_INT_MAYBE:\n            return o_in;\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nmp_obj_t mp_obj_int_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    long long lhs_val;\n    long long rhs_val;\n\n    if (mp_obj_is_small_int(lhs_in)) {\n        lhs_val = MP_OBJ_SMALL_INT_VALUE(lhs_in);\n    } else {\n        assert(mp_obj_is_exact_type(lhs_in, &mp_type_int));\n        lhs_val = ((mp_obj_int_t *)lhs_in)->val;\n    }\n\n    if (mp_obj_is_small_int(rhs_in)) {\n        rhs_val = MP_OBJ_SMALL_INT_VALUE(rhs_in);\n    } else if (mp_obj_is_exact_type(rhs_in, &mp_type_int)) {\n        rhs_val = ((mp_obj_int_t *)rhs_in)->val;\n    } else {\n        \n        return mp_obj_int_binary_op_extra_cases(op, lhs_in, rhs_in);\n    }\n\n    switch (op) {\n        case MP_BINARY_OP_ADD:\n        case MP_BINARY_OP_INPLACE_ADD:\n            return mp_obj_new_int_from_ll(lhs_val + rhs_val);\n        case MP_BINARY_OP_SUBTRACT:\n        case MP_BINARY_OP_INPLACE_SUBTRACT:\n            return mp_obj_new_int_from_ll(lhs_val - rhs_val);\n        case MP_BINARY_OP_MULTIPLY:\n        case MP_BINARY_OP_INPLACE_MULTIPLY:\n            return mp_obj_new_int_from_ll(lhs_val * rhs_val);\n        case MP_BINARY_OP_FLOOR_DIVIDE:\n        case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:\n            if (rhs_val == 0) {\n                goto zero_division;\n            }\n            return mp_obj_new_int_from_ll(lhs_val / rhs_val);\n        case MP_BINARY_OP_MODULO:\n        case MP_BINARY_OP_INPLACE_MODULO:\n            if (rhs_val == 0) {\n                goto zero_division;\n            }\n            return mp_obj_new_int_from_ll(lhs_val % rhs_val);\n\n        case MP_BINARY_OP_AND:\n        case MP_BINARY_OP_INPLACE_AND:\n            return mp_obj_new_int_from_ll(lhs_val & rhs_val);\n        case MP_BINARY_OP_OR:\n        case MP_BINARY_OP_INPLACE_OR:\n            return mp_obj_new_int_from_ll(lhs_val | rhs_val);\n        case MP_BINARY_OP_XOR:\n        case MP_BINARY_OP_INPLACE_XOR:\n            return mp_obj_new_int_from_ll(lhs_val ^ rhs_val);\n\n        case MP_BINARY_OP_LSHIFT:\n        case MP_BINARY_OP_INPLACE_LSHIFT:\n            return mp_obj_new_int_from_ll(lhs_val << (int)rhs_val);\n        case MP_BINARY_OP_RSHIFT:\n        case MP_BINARY_OP_INPLACE_RSHIFT:\n            return mp_obj_new_int_from_ll(lhs_val >> (int)rhs_val);\n\n        case MP_BINARY_OP_POWER:\n        case MP_BINARY_OP_INPLACE_POWER: {\n            if (rhs_val < 0) {\n                #if MICROPY_PY_BUILTINS_FLOAT\n                return mp_obj_float_binary_op(op, lhs_val, rhs_in);\n                #else\n                mp_raise_ValueError(MP_ERROR_TEXT(\"negative power with no float support\"));\n                #endif\n            }\n            long long ans = 1;\n            while (rhs_val > 0) {\n                if (rhs_val & 1) {\n                    ans *= lhs_val;\n                }\n                if (rhs_val == 1) {\n                    break;\n                }\n                rhs_val /= 2;\n                lhs_val *= lhs_val;\n            }\n            return mp_obj_new_int_from_ll(ans);\n        }\n\n        case MP_BINARY_OP_LESS:\n            return mp_obj_new_bool(lhs_val < rhs_val);\n        case MP_BINARY_OP_MORE:\n            return mp_obj_new_bool(lhs_val > rhs_val);\n        case MP_BINARY_OP_LESS_EQUAL:\n            return mp_obj_new_bool(lhs_val <= rhs_val);\n        case MP_BINARY_OP_MORE_EQUAL:\n            return mp_obj_new_bool(lhs_val >= rhs_val);\n        case MP_BINARY_OP_EQUAL:\n            return mp_obj_new_bool(lhs_val == rhs_val);\n\n        default:\n            return MP_OBJ_NULL; \n    }\n\nzero_division:\n    mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"divide by zero\"));\n}\n\nmp_obj_t mp_obj_new_int(mp_int_t value) {\n    if (MP_SMALL_INT_FITS(value)) {\n        return MP_OBJ_NEW_SMALL_INT(value);\n    }\n    return mp_obj_new_int_from_ll(value);\n}\n\nmp_obj_t mp_obj_new_int_from_uint(mp_uint_t value) {\n    \n    \n    if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {\n        return MP_OBJ_NEW_SMALL_INT(value);\n    }\n    return mp_obj_new_int_from_ll(value);\n}\n\nmp_obj_t mp_obj_new_int_from_ll(long long val) {\n    mp_obj_int_t *o = mp_obj_malloc(mp_obj_int_t, &mp_type_int);\n    o->val = val;\n    return o;\n}\n\nmp_obj_t mp_obj_new_int_from_ull(unsigned long long val) {\n    \n    if (val >> (sizeof(unsigned long long) * 8 - 1) != 0) {\n        mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"ulonglong too large\"));\n    }\n    mp_obj_int_t *o = mp_obj_malloc(mp_obj_int_t, &mp_type_int);\n    o->val = val;\n    return o;\n}\n\nmp_obj_t mp_obj_new_int_from_str_len(const char **str, size_t len, bool neg, unsigned int base) {\n    \n    \n    mp_obj_int_t *o = mp_obj_malloc(mp_obj_int_t, &mp_type_int);\n    char *endptr;\n    o->val = strtoll(*str, &endptr, base);\n    *str = endptr;\n    return o;\n}\n\nmp_int_t mp_obj_int_get_truncated(mp_const_obj_t self_in) {\n    if (mp_obj_is_small_int(self_in)) {\n        return MP_OBJ_SMALL_INT_VALUE(self_in);\n    } else {\n        const mp_obj_int_t *self = self_in;\n        return self->val;\n    }\n}\n\nmp_int_t mp_obj_int_get_checked(mp_const_obj_t self_in) {\n    \n    return mp_obj_int_get_truncated(self_in);\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nmp_float_t mp_obj_int_as_float_impl(mp_obj_t self_in) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    return self->val;\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}