{
  "module_name": "nlr.h",
  "hash_id": "12b80bba7d7f2ad53e7e656474506c07fc382bef01e1ee0c89ec07813323f9c2",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/nlr.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_NLR_H\n#define MICROPY_INCLUDED_PY_NLR_H\n\n\n\n\n#include <limits.h>\n#include <assert.h>\n#include <stdbool.h>\n\n#include \"py/mpconfig.h\"\n\n#define MICROPY_NLR_NUM_REGS_X86            (6)\n#define MICROPY_NLR_NUM_REGS_X64            (8)\n#define MICROPY_NLR_NUM_REGS_X64_WIN        (10)\n#define MICROPY_NLR_NUM_REGS_ARM_THUMB      (10)\n#define MICROPY_NLR_NUM_REGS_ARM_THUMB_FP   (10 + 6)\n#define MICROPY_NLR_NUM_REGS_AARCH64        (13)\n#define MICROPY_NLR_NUM_REGS_MIPS           (13)\n#define MICROPY_NLR_NUM_REGS_XTENSA         (10)\n#define MICROPY_NLR_NUM_REGS_XTENSAWIN      (17)\n\n\n\n\n#if !MICROPY_NLR_SETJMP\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#define MICROPY_NLR_OS_WINDOWS 1\n#else\n#define MICROPY_NLR_OS_WINDOWS 0\n#endif\n#if defined(__i386__)\n    #define MICROPY_NLR_X86 (1)\n    #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_X86)\n#elif defined(__x86_64__)\n    #define MICROPY_NLR_X64 (1)\n    #if MICROPY_NLR_OS_WINDOWS\n        #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_X64_WIN)\n    #else\n        #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_X64)\n    #endif\n#elif defined(__thumb2__) || defined(__thumb__) || defined(__arm__)\n    #define MICROPY_NLR_THUMB (1)\n    #if defined(__SOFTFP__)\n        #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_ARM_THUMB)\n    #else\n        \n        \n        \n        #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_ARM_THUMB_FP)\n    #endif\n#elif defined(__aarch64__)\n    #define MICROPY_NLR_AARCH64 (1)\n    #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_AARCH64)\n#elif defined(__xtensa__)\n    #define MICROPY_NLR_XTENSA (1)\n    #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_XTENSA)\n#elif defined(__powerpc__)\n    #define MICROPY_NLR_POWERPC (1)\n    \n    #define MICROPY_NLR_NUM_REGS (128)\n#elif defined(__mips__)\n    #define MICROPY_NLR_MIPS (1)\n    #define MICROPY_NLR_NUM_REGS (MICROPY_NLR_NUM_REGS_MIPS)\n#else\n    #define MICROPY_NLR_SETJMP (1)\n    \n#endif\n#endif\n\n\n\n#if MICROPY_NLR_SETJMP\n#include <setjmp.h>\n#endif\n\ntypedef struct _nlr_buf_t nlr_buf_t;\nstruct _nlr_buf_t {\n    \n\n    \n    \n    nlr_buf_t *prev;\n\n    \n    \n    \n    void *ret_val;\n\n    #if MICROPY_NLR_SETJMP\n    jmp_buf jmpbuf;\n    #else\n    void *regs[MICROPY_NLR_NUM_REGS];\n    #endif\n\n    #if MICROPY_ENABLE_PYSTACK\n    void *pystack;\n    #endif\n};\n\ntypedef void (*nlr_jump_callback_fun_t)(void *ctx);\n\ntypedef struct _nlr_jump_callback_node_t nlr_jump_callback_node_t;\n\nstruct _nlr_jump_callback_node_t {\n    nlr_jump_callback_node_t *prev;\n    nlr_jump_callback_fun_t fun;\n};\n\n\n#if MICROPY_ENABLE_PYSTACK\n#define MP_NLR_SAVE_PYSTACK(nlr_buf) (nlr_buf)->pystack = MP_STATE_THREAD(pystack_cur)\n#define MP_NLR_RESTORE_PYSTACK(nlr_buf) MP_STATE_THREAD(pystack_cur) = (nlr_buf)->pystack\n#else\n#define MP_NLR_SAVE_PYSTACK(nlr_buf) (void)nlr_buf\n#define MP_NLR_RESTORE_PYSTACK(nlr_buf) (void)nlr_buf\n#endif\n\n\n#define MP_NLR_JUMP_HEAD(val, top) \\\n    nlr_buf_t **_top_ptr = &MP_STATE_THREAD(nlr_top); \\\n    nlr_buf_t *top = *_top_ptr; \\\n    if (top == NULL) { \\\n        nlr_jump_fail(val); \\\n    } \\\n    top->ret_val = val; \\\n    nlr_call_jump_callbacks(top); \\\n    MP_NLR_RESTORE_PYSTACK(top); \\\n    *_top_ptr = top->prev; \\\n\n#if MICROPY_NLR_SETJMP\n\n\n\n#define nlr_push(buf) (nlr_push_tail(buf), setjmp((buf)->jmpbuf))\n#else\nunsigned int nlr_push(nlr_buf_t *);\n#endif\n\nunsigned int nlr_push_tail(nlr_buf_t *top);\nvoid nlr_pop(void);\nNORETURN void nlr_jump(void *val);\n\n#if MICROPY_ENABLE_VM_ABORT\n#define nlr_set_abort(buf) MP_STATE_VM(nlr_abort) = buf\n#define nlr_get_abort() MP_STATE_VM(nlr_abort)\nNORETURN void nlr_jump_abort(void);\n#endif\n\n\n\n\nNORETURN void nlr_jump_fail(void *val);\n\n\n#ifndef MICROPY_DEBUG_NLR\n#define nlr_raise(val) nlr_jump(MP_OBJ_TO_PTR(val))\n#else\n\n#define nlr_raise(val) \\\n    do { \\\n        void *_val = MP_OBJ_TO_PTR(val); \\\n        assert(_val != NULL); \\\n        assert(mp_obj_is_exception_instance(val)); \\\n        nlr_jump(_val); \\\n    } while (0)\n\n#if !MICROPY_NLR_SETJMP\n#define nlr_push(val) \\\n    assert(MP_STATE_THREAD(nlr_top) != val), nlr_push(val)\n#endif\n\n#endif\n\n\n\n\nvoid nlr_push_jump_callback(nlr_jump_callback_node_t *node, nlr_jump_callback_fun_t fun);\n\n\n\nvoid nlr_pop_jump_callback(bool run_callback);\n\n\nvoid nlr_call_jump_callbacks(nlr_buf_t *nlr);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}