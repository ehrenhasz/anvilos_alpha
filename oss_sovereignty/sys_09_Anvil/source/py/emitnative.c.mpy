{
  "module_name": "emitnative.c",
  "hash_id": "17b8814a2e304fd3994d9051d4687a635fa4b08b05ff102b6166bb8f6e71c48e",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/emitnative.c",
  "human_readable_source": " \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/emit.h\"\n#include \"py/nativeglue.h\"\n#include \"py/objfun.h\"\n#include \"py/objstr.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\n\n#if N_X64 || N_X86 || N_THUMB || N_ARM || N_XTENSA || N_XTENSAWIN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#if MICROPY_DYNAMIC_COMPILER\n#define SIZEOF_NLR_BUF (2 + mp_dynamic_compiler.nlr_buf_num_regs + 1) \n#else\n#define SIZEOF_NLR_BUF (sizeof(nlr_buf_t) / sizeof(uintptr_t))\n#endif\n#define SIZEOF_CODE_STATE (sizeof(mp_code_state_native_t) / sizeof(uintptr_t))\n#define OFFSETOF_CODE_STATE_STATE (offsetof(mp_code_state_native_t, state) / sizeof(uintptr_t))\n#define OFFSETOF_CODE_STATE_FUN_BC (offsetof(mp_code_state_native_t, fun_bc) / sizeof(uintptr_t))\n#define OFFSETOF_CODE_STATE_IP (offsetof(mp_code_state_native_t, ip) / sizeof(uintptr_t))\n#define OFFSETOF_CODE_STATE_SP (offsetof(mp_code_state_native_t, sp) / sizeof(uintptr_t))\n#define OFFSETOF_CODE_STATE_N_STATE (offsetof(mp_code_state_native_t, n_state) / sizeof(uintptr_t))\n#define OFFSETOF_OBJ_FUN_BC_CONTEXT (offsetof(mp_obj_fun_bc_t, context) / sizeof(uintptr_t))\n#define OFFSETOF_OBJ_FUN_BC_CHILD_TABLE (offsetof(mp_obj_fun_bc_t, child_table) / sizeof(uintptr_t))\n#define OFFSETOF_OBJ_FUN_BC_BYTECODE (offsetof(mp_obj_fun_bc_t, bytecode) / sizeof(uintptr_t))\n#define OFFSETOF_MODULE_CONTEXT_QSTR_TABLE (offsetof(mp_module_context_t, constants.qstr_table) / sizeof(uintptr_t))\n#define OFFSETOF_MODULE_CONTEXT_OBJ_TABLE (offsetof(mp_module_context_t, constants.obj_table) / sizeof(uintptr_t))\n#define OFFSETOF_MODULE_CONTEXT_GLOBALS (offsetof(mp_module_context_t, module.globals) / sizeof(uintptr_t))\n\n\n#ifndef REG_PARENT_RET\n#define REG_PARENT_RET REG_RET\n#define REG_PARENT_ARG_1 REG_ARG_1\n#define REG_PARENT_ARG_2 REG_ARG_2\n#define REG_PARENT_ARG_3 REG_ARG_3\n#define REG_PARENT_ARG_4 REG_ARG_4\n#endif\n\n\n#define NLR_BUF_IDX_RET_VAL (1)\n\n\n#define NEED_FUN_OBJ(emit) ((emit)->scope->exc_stack_size > 0 \\\n    || ((emit)->scope->scope_flags & (MP_SCOPE_FLAG_REFGLOBALS | MP_SCOPE_FLAG_HASCONSTS)))\n\n\n#define NEED_GLOBAL_EXC_HANDLER(emit) ((emit)->scope->exc_stack_size > 0 \\\n    || ((emit)->scope->scope_flags & (MP_SCOPE_FLAG_GENERATOR | MP_SCOPE_FLAG_REFGLOBALS)))\n\n\n#define NEED_EXC_HANDLER_UNWIND(emit) ((emit)->scope->exc_stack_size > 0)\n\n\n\n\n#define CAN_USE_REGS_FOR_LOCALS(emit) ((emit)->scope->exc_stack_size == 0 && !(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR))\n\n\n#define LOCAL_IDX_EXC_VAL(emit) (NLR_BUF_IDX_RET_VAL)\n#define LOCAL_IDX_EXC_HANDLER_PC(emit) (NLR_BUF_IDX_LOCAL_1)\n#define LOCAL_IDX_EXC_HANDLER_UNWIND(emit) (SIZEOF_NLR_BUF + 1) \n#define LOCAL_IDX_RET_VAL(emit) (SIZEOF_NLR_BUF) \n#define LOCAL_IDX_FUN_OBJ(emit) ((emit)->code_state_start + OFFSETOF_CODE_STATE_FUN_BC)\n#define LOCAL_IDX_OLD_GLOBALS(emit) ((emit)->code_state_start + OFFSETOF_CODE_STATE_IP)\n#define LOCAL_IDX_GEN_PC(emit) ((emit)->code_state_start + OFFSETOF_CODE_STATE_IP)\n#define LOCAL_IDX_LOCAL_VAR(emit, local_num) ((emit)->stack_start + (emit)->n_state - 1 - (local_num))\n\n#if MICROPY_PERSISTENT_CODE_SAVE\n\n\n\n\n\n\n#define REG_GENERATOR_STATE (REG_LOCAL_2)\n#define REG_QSTR_TABLE (REG_LOCAL_3)\n#define MAX_REGS_FOR_LOCAL_VARS (2)\n\nstatic const uint8_t reg_local_table[MAX_REGS_FOR_LOCAL_VARS] = {REG_LOCAL_1, REG_LOCAL_2};\n\n#else\n\n\n\n\n\n\n#define REG_GENERATOR_STATE (REG_LOCAL_3)\n#define MAX_REGS_FOR_LOCAL_VARS (3)\n\nstatic const uint8_t reg_local_table[MAX_REGS_FOR_LOCAL_VARS] = {REG_LOCAL_1, REG_LOCAL_2, REG_LOCAL_3};\n\n#endif\n\n#define REG_LOCAL_LAST (reg_local_table[MAX_REGS_FOR_LOCAL_VARS - 1])\n\n#define EMIT_NATIVE_VIPER_TYPE_ERROR(emit, ...) do { \\\n        *emit->error_slot = mp_obj_new_exception_msg_varg(&mp_type_ViperTypeError, __VA_ARGS__); \\\n} while (0)\n\ntypedef enum {\n    STACK_VALUE,\n    STACK_REG,\n    STACK_IMM,\n} stack_info_kind_t;\n\n\n\ntypedef enum {\n    VTYPE_PYOBJ = 0x00 | MP_NATIVE_TYPE_OBJ,\n    VTYPE_BOOL = 0x00 | MP_NATIVE_TYPE_BOOL,\n    VTYPE_INT = 0x00 | MP_NATIVE_TYPE_INT,\n    VTYPE_UINT = 0x00 | MP_NATIVE_TYPE_UINT,\n    VTYPE_PTR = 0x00 | MP_NATIVE_TYPE_PTR,\n    VTYPE_PTR8 = 0x00 | MP_NATIVE_TYPE_PTR8,\n    VTYPE_PTR16 = 0x00 | MP_NATIVE_TYPE_PTR16,\n    VTYPE_PTR32 = 0x00 | MP_NATIVE_TYPE_PTR32,\n\n    VTYPE_PTR_NONE = 0x50 | MP_NATIVE_TYPE_PTR,\n\n    VTYPE_UNBOUND = 0x60 | MP_NATIVE_TYPE_OBJ,\n    VTYPE_BUILTIN_CAST = 0x70 | MP_NATIVE_TYPE_OBJ,\n} vtype_kind_t;\n\nstatic qstr vtype_to_qstr(vtype_kind_t vtype) {\n    switch (vtype) {\n        case VTYPE_PYOBJ:\n            return MP_QSTR_object;\n        case VTYPE_BOOL:\n            return MP_QSTR_bool;\n        case VTYPE_INT:\n            return MP_QSTR_int;\n        case VTYPE_UINT:\n            return MP_QSTR_uint;\n        case VTYPE_PTR:\n            return MP_QSTR_ptr;\n        case VTYPE_PTR8:\n            return MP_QSTR_ptr8;\n        case VTYPE_PTR16:\n            return MP_QSTR_ptr16;\n        case VTYPE_PTR32:\n            return MP_QSTR_ptr32;\n        case VTYPE_PTR_NONE:\n        default:\n            return MP_QSTR_None;\n    }\n}\n\ntypedef struct _stack_info_t {\n    vtype_kind_t vtype;\n    stack_info_kind_t kind;\n    union {\n        int u_reg;\n        mp_int_t u_imm;\n    } data;\n} stack_info_t;\n\n#define UNWIND_LABEL_UNUSED (0x7fff)\n#define UNWIND_LABEL_DO_FINAL_UNWIND (0x7ffe)\n\ntypedef struct _exc_stack_entry_t {\n    uint16_t label : 15;\n    uint16_t is_finally : 1;\n    uint16_t unwind_label : 15;\n    uint16_t is_active : 1;\n} exc_stack_entry_t;\n\nstruct _emit_t {\n    mp_emit_common_t *emit_common;\n    mp_obj_t *error_slot;\n    uint *label_slot;\n    uint exit_label;\n    int pass;\n\n    bool do_viper_types;\n\n    mp_uint_t local_vtype_alloc;\n    vtype_kind_t *local_vtype;\n\n    mp_uint_t stack_info_alloc;\n    stack_info_t *stack_info;\n    vtype_kind_t saved_stack_vtype;\n\n    size_t exc_stack_alloc;\n    size_t exc_stack_size;\n    exc_stack_entry_t *exc_stack;\n\n    int prelude_offset;\n    int prelude_ptr_index;\n    int start_offset;\n    int n_state;\n    uint16_t code_state_start;\n    uint16_t stack_start;\n    int stack_size;\n    uint16_t n_info;\n    uint16_t n_cell;\n\n    scope_t *scope;\n\n    ASM_T *as;\n};\n\nstatic void emit_load_reg_with_object(emit_t *emit, int reg, mp_obj_t obj);\nstatic void emit_native_global_exc_entry(emit_t *emit);\nstatic void emit_native_global_exc_exit(emit_t *emit);\nstatic void emit_native_load_const_obj(emit_t *emit, mp_obj_t obj);\n\nemit_t *EXPORT_FUN(new)(mp_emit_common_t * emit_common, mp_obj_t *error_slot, uint *label_slot, mp_uint_t max_num_labels) {\n    emit_t *emit = m_new0(emit_t, 1);\n    emit->emit_common = emit_common;\n    emit->error_slot = error_slot;\n    emit->label_slot = label_slot;\n    emit->stack_info_alloc = 8;\n    emit->stack_info = m_new(stack_info_t, emit->stack_info_alloc);\n    emit->exc_stack_alloc = 8;\n    emit->exc_stack = m_new(exc_stack_entry_t, emit->exc_stack_alloc);\n    emit->as = m_new0(ASM_T, 1);\n    mp_asm_base_init(&emit->as->base, max_num_labels);\n    return emit;\n}\n\nvoid EXPORT_FUN(free)(emit_t * emit) {\n    mp_asm_base_deinit(&emit->as->base, false);\n    m_del_obj(ASM_T, emit->as);\n    m_del(exc_stack_entry_t, emit->exc_stack, emit->exc_stack_alloc);\n    m_del(vtype_kind_t, emit->local_vtype, emit->local_vtype_alloc);\n    m_del(stack_info_t, emit->stack_info, emit->stack_info_alloc);\n    m_del_obj(emit_t, emit);\n}\n\nstatic void emit_call_with_imm_arg(emit_t *emit, mp_fun_kind_t fun_kind, mp_int_t arg_val, int arg_reg);\n\nstatic void emit_native_mov_reg_const(emit_t *emit, int reg_dest, int const_val) {\n    ASM_LOAD_REG_REG_OFFSET(emit->as, reg_dest, REG_FUN_TABLE, const_val);\n}\n\nstatic void emit_native_mov_state_reg(emit_t *emit, int local_num, int reg_src) {\n    if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n        ASM_STORE_REG_REG_OFFSET(emit->as, reg_src, REG_GENERATOR_STATE, local_num);\n    } else {\n        ASM_MOV_LOCAL_REG(emit->as, local_num, reg_src);\n    }\n}\n\nstatic void emit_native_mov_reg_state(emit_t *emit, int reg_dest, int local_num) {\n    if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n        ASM_LOAD_REG_REG_OFFSET(emit->as, reg_dest, REG_GENERATOR_STATE, local_num);\n    } else {\n        ASM_MOV_REG_LOCAL(emit->as, reg_dest, local_num);\n    }\n}\n\nstatic void emit_native_mov_reg_state_addr(emit_t *emit, int reg_dest, int local_num) {\n    if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n        ASM_MOV_REG_IMM(emit->as, reg_dest, local_num * ASM_WORD_SIZE);\n        ASM_ADD_REG_REG(emit->as, reg_dest, REG_GENERATOR_STATE);\n    } else {\n        ASM_MOV_REG_LOCAL_ADDR(emit->as, reg_dest, local_num);\n    }\n}\n\nstatic void emit_native_mov_reg_qstr(emit_t *emit, int arg_reg, qstr qst) {\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    ASM_LOAD16_REG_REG_OFFSET(emit->as, arg_reg, REG_QSTR_TABLE, mp_emit_common_use_qstr(emit->emit_common, qst));\n    #else\n    ASM_MOV_REG_IMM(emit->as, arg_reg, qst);\n    #endif\n}\n\nstatic void emit_native_mov_reg_qstr_obj(emit_t *emit, int reg_dest, qstr qst) {\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    emit_load_reg_with_object(emit, reg_dest, MP_OBJ_NEW_QSTR(qst));\n    #else\n    ASM_MOV_REG_IMM(emit->as, reg_dest, (mp_uint_t)MP_OBJ_NEW_QSTR(qst));\n    #endif\n}\n\n#define emit_native_mov_state_imm_via(emit, local_num, imm, reg_temp) \\\n    do { \\\n        ASM_MOV_REG_IMM((emit)->as, (reg_temp), (imm)); \\\n        emit_native_mov_state_reg((emit), (local_num), (reg_temp)); \\\n    } while (false)\n\nstatic void emit_native_start_pass(emit_t *emit, pass_kind_t pass, scope_t *scope) {\n    DEBUG_printf(\"start_pass(pass=%u, scope=%p)\\n\", pass, scope);\n\n    emit->pass = pass;\n    emit->do_viper_types = scope->emit_options == MP_EMIT_OPT_VIPER;\n    emit->stack_size = 0;\n    emit->scope = scope;\n\n    \n    if (emit->local_vtype_alloc < scope->num_locals) {\n        emit->local_vtype = m_renew(vtype_kind_t, emit->local_vtype, emit->local_vtype_alloc, scope->num_locals);\n        emit->local_vtype_alloc = scope->num_locals;\n    }\n\n    \n    mp_uint_t num_args = emit->scope->num_pos_args + emit->scope->num_kwonly_args;\n    if (scope->scope_flags & MP_SCOPE_FLAG_VARARGS) {\n        num_args += 1;\n    }\n    if (scope->scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) {\n        num_args += 1;\n    }\n    for (mp_uint_t i = 0; i < num_args; i++) {\n        emit->local_vtype[i] = VTYPE_PYOBJ;\n    }\n\n    \n    if (emit->do_viper_types) {\n        for (int i = 0; i < emit->scope->id_info_len; ++i) {\n            id_info_t *id = &emit->scope->id_info[i];\n            if (id->flags & ID_FLAG_IS_PARAM) {\n                assert(id->local_num < emit->local_vtype_alloc);\n                emit->local_vtype[id->local_num] = id->flags >> ID_FLAG_VIPER_TYPE_POS;\n            }\n        }\n    }\n\n    \n    for (mp_uint_t i = num_args; i < emit->local_vtype_alloc; i++) {\n        emit->local_vtype[i] = emit->do_viper_types ? VTYPE_UNBOUND : VTYPE_PYOBJ;\n    }\n\n    \n    for (mp_uint_t i = 0; i < emit->stack_info_alloc; i++) {\n        emit->stack_info[i].kind = STACK_VALUE;\n        emit->stack_info[i].vtype = VTYPE_UNBOUND;\n    }\n\n    mp_asm_base_start_pass(&emit->as->base, pass == MP_PASS_EMIT ? MP_ASM_PASS_EMIT : MP_ASM_PASS_COMPUTE);\n\n    \n\n    \n    emit->code_state_start = 0;\n    if (NEED_GLOBAL_EXC_HANDLER(emit)) {\n        emit->code_state_start = SIZEOF_NLR_BUF; \n        emit->code_state_start += 1;  \n        if (NEED_EXC_HANDLER_UNWIND(emit)) {\n            emit->code_state_start += 1;\n        }\n    }\n\n    size_t fun_table_off = mp_emit_common_use_const_obj(emit->emit_common, MP_OBJ_FROM_PTR(&mp_fun_table));\n\n    if (emit->do_viper_types) {\n        \n        \n        emit->n_state = scope->num_locals + scope->stack_size;\n        int num_locals_in_regs = 0;\n        if (CAN_USE_REGS_FOR_LOCALS(emit)) {\n            num_locals_in_regs = scope->num_locals;\n            if (num_locals_in_regs > MAX_REGS_FOR_LOCAL_VARS) {\n                num_locals_in_regs = MAX_REGS_FOR_LOCAL_VARS;\n            }\n            \n            if (scope->num_pos_args >= MAX_REGS_FOR_LOCAL_VARS + 1) {\n                --num_locals_in_regs;\n            }\n        }\n\n        \n        if (NEED_GLOBAL_EXC_HANDLER(emit)) {\n            \n            emit->stack_start = emit->code_state_start + 2;\n        } else if (scope->scope_flags & MP_SCOPE_FLAG_HASCONSTS) {\n            \n            emit->stack_start = emit->code_state_start + 1;\n        } else {\n            emit->stack_start = emit->code_state_start + 0;\n        }\n\n        \n        ASM_ENTRY(emit->as, emit->stack_start + emit->n_state - num_locals_in_regs);\n\n        #if N_X86\n        asm_x86_mov_arg_to_r32(emit->as, 0, REG_PARENT_ARG_1);\n        #endif\n\n        \n        ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_PARENT_ARG_1, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n        #if MICROPY_PERSISTENT_CODE_SAVE\n        ASM_LOAD_REG_REG_OFFSET(emit->as, REG_QSTR_TABLE, REG_FUN_TABLE, OFFSETOF_MODULE_CONTEXT_QSTR_TABLE);\n        #endif\n        ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_FUN_TABLE, OFFSETOF_MODULE_CONTEXT_OBJ_TABLE);\n        ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_FUN_TABLE, fun_table_off);\n\n        \n        if (NEED_FUN_OBJ(emit)) {\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_FUN_OBJ(emit), REG_PARENT_ARG_1);\n        }\n\n        \n        #if N_X86\n        asm_x86_mov_arg_to_r32(emit->as, 1, REG_ARG_1);\n        asm_x86_mov_arg_to_r32(emit->as, 2, REG_ARG_2);\n        asm_x86_mov_arg_to_r32(emit->as, 3, REG_LOCAL_LAST);\n        #else\n        ASM_MOV_REG_REG(emit->as, REG_ARG_1, REG_PARENT_ARG_2);\n        ASM_MOV_REG_REG(emit->as, REG_ARG_2, REG_PARENT_ARG_3);\n        ASM_MOV_REG_REG(emit->as, REG_LOCAL_LAST, REG_PARENT_ARG_4);\n        #endif\n\n        \n        ASM_JUMP_IF_REG_NONZERO(emit->as, REG_ARG_2, *emit->label_slot + 4, true);\n        ASM_MOV_REG_IMM(emit->as, REG_ARG_3, scope->num_pos_args);\n        ASM_JUMP_IF_REG_EQ(emit->as, REG_ARG_1, REG_ARG_3, *emit->label_slot + 5);\n        mp_asm_base_label_assign(&emit->as->base, *emit->label_slot + 4);\n        ASM_MOV_REG_IMM(emit->as, REG_ARG_3, MP_OBJ_FUN_MAKE_SIG(scope->num_pos_args, scope->num_pos_args, false));\n        ASM_CALL_IND(emit->as, MP_F_ARG_CHECK_NUM_SIG);\n        mp_asm_base_label_assign(&emit->as->base, *emit->label_slot + 5);\n\n        \n        for (int i = 0; i < emit->scope->num_pos_args; i++) {\n            int r = REG_ARG_1;\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_ARG_1, REG_LOCAL_LAST, i);\n            if (emit->local_vtype[i] != VTYPE_PYOBJ) {\n                emit_call_with_imm_arg(emit, MP_F_CONVERT_OBJ_TO_NATIVE, emit->local_vtype[i], REG_ARG_2);\n                r = REG_RET;\n            }\n            \n            if (i < MAX_REGS_FOR_LOCAL_VARS && CAN_USE_REGS_FOR_LOCALS(emit) && (i != MAX_REGS_FOR_LOCAL_VARS - 1 || emit->scope->num_pos_args == MAX_REGS_FOR_LOCAL_VARS)) {\n                ASM_MOV_REG_REG(emit->as, reg_local_table[i], r);\n            } else {\n                emit_native_mov_state_reg(emit, LOCAL_IDX_LOCAL_VAR(emit, i), r);\n            }\n        }\n        \n        if (emit->scope->num_pos_args >= MAX_REGS_FOR_LOCAL_VARS + 1 && CAN_USE_REGS_FOR_LOCALS(emit)) {\n            ASM_MOV_REG_LOCAL(emit->as, REG_LOCAL_LAST, LOCAL_IDX_LOCAL_VAR(emit, MAX_REGS_FOR_LOCAL_VARS - 1));\n        }\n\n        emit_native_global_exc_entry(emit);\n\n    } else {\n        \n        emit->n_state = scope->num_locals + scope->stack_size;\n\n        \n        \n        mp_asm_base_data(&emit->as->base, ASM_WORD_SIZE, (uintptr_t)emit->prelude_ptr_index);\n\n        if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n            mp_asm_base_data(&emit->as->base, ASM_WORD_SIZE, (uintptr_t)emit->start_offset);\n            ASM_ENTRY(emit->as, emit->code_state_start);\n\n            \n            emit->code_state_start = 0;\n            emit->stack_start = SIZEOF_CODE_STATE;\n\n            \n            #if N_X86\n            asm_x86_mov_arg_to_r32(emit->as, 0, REG_GENERATOR_STATE);\n            #else\n            ASM_MOV_REG_REG(emit->as, REG_GENERATOR_STATE, REG_PARENT_ARG_1);\n            #endif\n\n            \n            #if N_X86\n            asm_x86_mov_arg_to_r32(emit->as, 1, REG_PARENT_ARG_2);\n            #endif\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_VAL(emit), REG_PARENT_ARG_2);\n\n            \n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_GENERATOR_STATE, LOCAL_IDX_FUN_OBJ(emit));\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_TEMP0, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n            #if MICROPY_PERSISTENT_CODE_SAVE\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_QSTR_TABLE, REG_TEMP0, OFFSETOF_MODULE_CONTEXT_QSTR_TABLE);\n            #endif\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_TEMP0, OFFSETOF_MODULE_CONTEXT_OBJ_TABLE);\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_TEMP0, fun_table_off);\n        } else {\n            \n            emit->stack_start = emit->code_state_start + SIZEOF_CODE_STATE;\n\n            \n            ASM_ENTRY(emit->as, emit->stack_start + emit->n_state);\n\n            \n\n            #if N_X86\n            asm_x86_mov_arg_to_r32(emit->as, 0, REG_PARENT_ARG_1);\n            asm_x86_mov_arg_to_r32(emit->as, 1, REG_PARENT_ARG_2);\n            asm_x86_mov_arg_to_r32(emit->as, 2, REG_PARENT_ARG_3);\n            asm_x86_mov_arg_to_r32(emit->as, 3, REG_PARENT_ARG_4);\n            #endif\n\n            \n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_PARENT_ARG_1, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n            #if MICROPY_PERSISTENT_CODE_SAVE\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_QSTR_TABLE, REG_FUN_TABLE, OFFSETOF_MODULE_CONTEXT_QSTR_TABLE);\n            #endif\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_FUN_TABLE, OFFSETOF_MODULE_CONTEXT_OBJ_TABLE);\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_FUN_TABLE, REG_FUN_TABLE, fun_table_off);\n\n            \n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_FUN_OBJ(emit), REG_PARENT_ARG_1);\n\n            \n            emit_native_mov_state_imm_via(emit, emit->code_state_start + OFFSETOF_CODE_STATE_N_STATE, emit->n_state, REG_ARG_1);\n\n            \n            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, emit->code_state_start);\n\n            \n            #if REG_ARG_2 != REG_PARENT_ARG_2\n            ASM_MOV_REG_REG(emit->as, REG_ARG_2, REG_PARENT_ARG_2);\n            #endif\n            #if REG_ARG_3 != REG_PARENT_ARG_3\n            ASM_MOV_REG_REG(emit->as, REG_ARG_3, REG_PARENT_ARG_3);\n            #endif\n            #if REG_ARG_4 != REG_PARENT_ARG_4\n            ASM_MOV_REG_REG(emit->as, REG_ARG_4, REG_PARENT_ARG_4);\n            #endif\n\n            \n            #if N_THUMB\n            asm_thumb_bl_ind(emit->as, MP_F_SETUP_CODE_STATE, ASM_THUMB_REG_R4);\n            #elif N_ARM\n            asm_arm_bl_ind(emit->as, MP_F_SETUP_CODE_STATE, ASM_ARM_REG_R4);\n            #else\n            ASM_CALL_IND(emit->as, MP_F_SETUP_CODE_STATE);\n            #endif\n        }\n\n        emit_native_global_exc_entry(emit);\n\n        \n        if (CAN_USE_REGS_FOR_LOCALS(emit)) {\n            for (int i = 0; i < MAX_REGS_FOR_LOCAL_VARS && i < scope->num_locals; ++i) {\n                ASM_MOV_REG_LOCAL(emit->as, reg_local_table[i], LOCAL_IDX_LOCAL_VAR(emit, i));\n            }\n        }\n\n        \n        for (mp_uint_t i = 0; i < scope->id_info_len; i++) {\n            id_info_t *id = &scope->id_info[i];\n            if (id->kind == ID_INFO_KIND_CELL) {\n                emit->local_vtype[id->local_num] = VTYPE_PYOBJ;\n            }\n        }\n    }\n}\n\nstatic inline void emit_native_write_code_info_byte(emit_t *emit, byte val) {\n    mp_asm_base_data(&emit->as->base, 1, val);\n}\n\nstatic inline void emit_native_write_code_info_qstr(emit_t *emit, qstr qst) {\n    mp_encode_uint(&emit->as->base, mp_asm_base_get_cur_to_write_bytes, mp_emit_common_use_qstr(emit->emit_common, qst));\n}\n\nstatic bool emit_native_end_pass(emit_t *emit) {\n    emit_native_global_exc_exit(emit);\n\n    if (!emit->do_viper_types) {\n        emit->prelude_offset = mp_asm_base_get_code_pos(&emit->as->base);\n        emit->prelude_ptr_index = emit->emit_common->ct_cur_child;\n\n        size_t n_state = emit->n_state;\n        size_t n_exc_stack = 0; \n        MP_BC_PRELUDE_SIG_ENCODE(n_state, n_exc_stack, emit->scope, emit_native_write_code_info_byte, emit);\n\n        size_t n_info = emit->n_info;\n        size_t n_cell = emit->n_cell;\n        MP_BC_PRELUDE_SIZE_ENCODE(n_info, n_cell, emit_native_write_code_info_byte, emit);\n\n        \n        size_t info_start = mp_asm_base_get_code_pos(&emit->as->base);\n        emit_native_write_code_info_qstr(emit, emit->scope->simple_name);\n        for (int i = 0; i < emit->scope->num_pos_args + emit->scope->num_kwonly_args; i++) {\n            qstr qst = MP_QSTR__star_;\n            for (int j = 0; j < emit->scope->id_info_len; ++j) {\n                id_info_t *id = &emit->scope->id_info[j];\n                if ((id->flags & ID_FLAG_IS_PARAM) && id->local_num == i) {\n                    qst = id->qst;\n                    break;\n                }\n            }\n            emit_native_write_code_info_qstr(emit, qst);\n        }\n        emit->n_info = mp_asm_base_get_code_pos(&emit->as->base) - info_start;\n\n        \n        size_t cell_start = mp_asm_base_get_code_pos(&emit->as->base);\n        for (int i = 0; i < emit->scope->id_info_len; i++) {\n            id_info_t *id = &emit->scope->id_info[i];\n            if (id->kind == ID_INFO_KIND_CELL) {\n                assert(id->local_num <= 255);\n                mp_asm_base_data(&emit->as->base, 1, id->local_num); \n            }\n        }\n        emit->n_cell = mp_asm_base_get_code_pos(&emit->as->base) - cell_start;\n\n    }\n\n    ASM_END_PASS(emit->as);\n\n    \n    assert(emit->stack_size == 0);\n    assert(emit->exc_stack_size == 0);\n\n    if (emit->pass == MP_PASS_EMIT) {\n        void *f = mp_asm_base_get_code(&emit->as->base);\n        mp_uint_t f_len = mp_asm_base_get_code_size(&emit->as->base);\n\n        mp_raw_code_t **children = emit->emit_common->children;\n        if (!emit->do_viper_types) {\n            #if MICROPY_EMIT_NATIVE_PRELUDE_SEPARATE_FROM_MACHINE_CODE\n            \n            \n            void *buf = emit->as->base.code_base + emit->prelude_offset;\n            size_t n = emit->as->base.code_offset - emit->prelude_offset;\n            const uint8_t *prelude_ptr = memcpy(m_new(uint8_t, n), buf, n);\n            #else\n            \n            const uint8_t *prelude_ptr = (const uint8_t *)f + emit->prelude_offset;\n            #endif\n\n            \n            assert(emit->prelude_ptr_index == emit->emit_common->ct_cur_child);\n            if (emit->prelude_ptr_index == 0) {\n                children = (void *)prelude_ptr;\n            } else {\n                children = m_renew(mp_raw_code_t *, children, emit->prelude_ptr_index, emit->prelude_ptr_index + 1);\n                children[emit->prelude_ptr_index] = (void *)prelude_ptr;\n            }\n        }\n\n        mp_emit_glue_assign_native(emit->scope->raw_code,\n            emit->do_viper_types ? MP_CODE_NATIVE_VIPER : MP_CODE_NATIVE_PY,\n            f, f_len,\n            children,\n            #if MICROPY_PERSISTENT_CODE_SAVE\n            emit->emit_common->ct_cur_child,\n            emit->prelude_offset,\n            #endif\n            emit->scope->scope_flags, 0, 0);\n    }\n\n    return true;\n}\n\nstatic void ensure_extra_stack(emit_t *emit, size_t delta) {\n    if (emit->stack_size + delta > emit->stack_info_alloc) {\n        size_t new_alloc = (emit->stack_size + delta + 8) & ~3;\n        emit->stack_info = m_renew(stack_info_t, emit->stack_info, emit->stack_info_alloc, new_alloc);\n        emit->stack_info_alloc = new_alloc;\n    }\n}\n\nstatic void adjust_stack(emit_t *emit, mp_int_t stack_size_delta) {\n    assert((mp_int_t)emit->stack_size + stack_size_delta >= 0);\n    assert((mp_int_t)emit->stack_size + stack_size_delta <= (mp_int_t)emit->stack_info_alloc);\n    emit->stack_size += stack_size_delta;\n    if (emit->pass > MP_PASS_SCOPE && emit->stack_size > emit->scope->stack_size) {\n        emit->scope->stack_size = emit->stack_size;\n    }\n    #if DEBUG_PRINT\n    DEBUG_printf(\"  adjust_stack; stack_size=%d+%d; stack now:\", emit->stack_size - stack_size_delta, stack_size_delta);\n    for (int i = 0; i < emit->stack_size; i++) {\n        stack_info_t *si = &emit->stack_info[i];\n        DEBUG_printf(\" (v=%d k=%d %d)\", si->vtype, si->kind, si->data.u_reg);\n    }\n    DEBUG_printf(\"\\n\");\n    #endif\n}\n\nstatic void emit_native_adjust_stack_size(emit_t *emit, mp_int_t delta) {\n    DEBUG_printf(\"adjust_stack_size(\" INT_FMT \")\\n\", delta);\n    if (delta > 0) {\n        ensure_extra_stack(emit, delta);\n    }\n    \n    \n    \n    \n    \n    for (mp_int_t i = 0; i < delta; i++) {\n        stack_info_t *si = &emit->stack_info[emit->stack_size + i];\n        si->kind = STACK_VALUE;\n        \n        \n        if (delta == 1) {\n            si->vtype = emit->saved_stack_vtype;\n        } else {\n            si->vtype = VTYPE_PYOBJ;\n        }\n    }\n    adjust_stack(emit, delta);\n}\n\nstatic void emit_native_set_source_line(emit_t *emit, mp_uint_t source_line) {\n    (void)emit;\n    (void)source_line;\n}\n\n\nstatic void emit_native_pre(emit_t *emit) {\n    (void)emit;\n}\n\n\nstatic stack_info_t *peek_stack(emit_t *emit, mp_uint_t depth) {\n    return &emit->stack_info[emit->stack_size - 1 - depth];\n}\n\n\nstatic vtype_kind_t peek_vtype(emit_t *emit, mp_uint_t depth) {\n    if (emit->do_viper_types) {\n        return peek_stack(emit, depth)->vtype;\n    } else {\n        \n        return VTYPE_PYOBJ;\n    }\n}\n\n\n\nstatic void need_reg_single(emit_t *emit, int reg_needed, int skip_stack_pos) {\n    skip_stack_pos = emit->stack_size - skip_stack_pos;\n    for (int i = 0; i < emit->stack_size; i++) {\n        if (i != skip_stack_pos) {\n            stack_info_t *si = &emit->stack_info[i];\n            if (si->kind == STACK_REG && si->data.u_reg == reg_needed) {\n                si->kind = STACK_VALUE;\n                emit_native_mov_state_reg(emit, emit->stack_start + i, si->data.u_reg);\n            }\n        }\n    }\n}\n\n\n\nstatic void need_reg_all(emit_t *emit) {\n    for (int i = 0; i < emit->stack_size; i++) {\n        stack_info_t *si = &emit->stack_info[i];\n        if (si->kind == STACK_REG) {\n            DEBUG_printf(\"    reg(%u) to local(%u)\\n\", si->data.u_reg, emit->stack_start + i);\n            si->kind = STACK_VALUE;\n            emit_native_mov_state_reg(emit, emit->stack_start + i, si->data.u_reg);\n        }\n    }\n}\n\nstatic vtype_kind_t load_reg_stack_imm(emit_t *emit, int reg_dest, const stack_info_t *si, bool convert_to_pyobj) {\n    if (!convert_to_pyobj && emit->do_viper_types) {\n        ASM_MOV_REG_IMM(emit->as, reg_dest, si->data.u_imm);\n        return si->vtype;\n    } else {\n        if (si->vtype == VTYPE_PYOBJ) {\n            ASM_MOV_REG_IMM(emit->as, reg_dest, si->data.u_imm);\n        } else if (si->vtype == VTYPE_BOOL) {\n            emit_native_mov_reg_const(emit, reg_dest, MP_F_CONST_FALSE_OBJ + si->data.u_imm);\n        } else if (si->vtype == VTYPE_INT || si->vtype == VTYPE_UINT) {\n            ASM_MOV_REG_IMM(emit->as, reg_dest, (uintptr_t)MP_OBJ_NEW_SMALL_INT(si->data.u_imm));\n        } else if (si->vtype == VTYPE_PTR_NONE) {\n            emit_native_mov_reg_const(emit, reg_dest, MP_F_CONST_NONE_OBJ);\n        } else {\n            mp_raise_NotImplementedError(MP_ERROR_TEXT(\"conversion to object\"));\n        }\n        return VTYPE_PYOBJ;\n    }\n}\n\n\n\n\n\nstatic void need_stack_settled(emit_t *emit) {\n    DEBUG_printf(\"  need_stack_settled; stack_size=%d\\n\", emit->stack_size);\n    need_reg_all(emit);\n    for (int i = 0; i < emit->stack_size; i++) {\n        stack_info_t *si = &emit->stack_info[i];\n        if (si->kind == STACK_IMM) {\n            DEBUG_printf(\"    imm(\" INT_FMT \") to local(%u)\\n\", si->data.u_imm, emit->stack_start + i);\n            si->kind = STACK_VALUE;\n            \n            si->vtype = load_reg_stack_imm(emit, REG_TEMP1, si, false);\n            emit_native_mov_state_reg(emit, emit->stack_start + i, REG_TEMP1);\n        }\n    }\n}\n\n\nstatic void emit_access_stack(emit_t *emit, int pos, vtype_kind_t *vtype, int reg_dest) {\n    need_reg_single(emit, reg_dest, pos);\n    stack_info_t *si = &emit->stack_info[emit->stack_size - pos];\n    *vtype = si->vtype;\n    switch (si->kind) {\n        case STACK_VALUE:\n            emit_native_mov_reg_state(emit, reg_dest, emit->stack_start + emit->stack_size - pos);\n            break;\n\n        case STACK_REG:\n            if (si->data.u_reg != reg_dest) {\n                ASM_MOV_REG_REG(emit->as, reg_dest, si->data.u_reg);\n            }\n            break;\n\n        case STACK_IMM:\n            *vtype = load_reg_stack_imm(emit, reg_dest, si, false);\n            break;\n    }\n}\n\n\n\nstatic void emit_fold_stack_top(emit_t *emit, int reg_dest) {\n    stack_info_t *si = &emit->stack_info[emit->stack_size - 2];\n    si[0] = si[1];\n    if (si->kind == STACK_VALUE) {\n        \n        emit_native_mov_reg_state(emit, reg_dest, emit->stack_start + emit->stack_size - 1);\n        si->kind = STACK_REG;\n        si->data.u_reg = reg_dest;\n    }\n    adjust_stack(emit, -1);\n}\n\n\n\nstatic void emit_pre_pop_reg_flexible(emit_t *emit, vtype_kind_t *vtype, int *reg_dest, int not_r1, int not_r2) {\n    stack_info_t *si = peek_stack(emit, 0);\n    if (si->kind == STACK_REG && si->data.u_reg != not_r1 && si->data.u_reg != not_r2) {\n        *vtype = si->vtype;\n        *reg_dest = si->data.u_reg;\n        need_reg_single(emit, *reg_dest, 1);\n    } else {\n        emit_access_stack(emit, 1, vtype, *reg_dest);\n    }\n    adjust_stack(emit, -1);\n}\n\nstatic void emit_pre_pop_discard(emit_t *emit) {\n    adjust_stack(emit, -1);\n}\n\nstatic void emit_pre_pop_reg(emit_t *emit, vtype_kind_t *vtype, int reg_dest) {\n    emit_access_stack(emit, 1, vtype, reg_dest);\n    adjust_stack(emit, -1);\n}\n\nstatic void emit_pre_pop_reg_reg(emit_t *emit, vtype_kind_t *vtypea, int rega, vtype_kind_t *vtypeb, int regb) {\n    emit_pre_pop_reg(emit, vtypea, rega);\n    emit_pre_pop_reg(emit, vtypeb, regb);\n}\n\nstatic void emit_pre_pop_reg_reg_reg(emit_t *emit, vtype_kind_t *vtypea, int rega, vtype_kind_t *vtypeb, int regb, vtype_kind_t *vtypec, int regc) {\n    emit_pre_pop_reg(emit, vtypea, rega);\n    emit_pre_pop_reg(emit, vtypeb, regb);\n    emit_pre_pop_reg(emit, vtypec, regc);\n}\n\nstatic void emit_post(emit_t *emit) {\n    (void)emit;\n}\n\nstatic void emit_post_top_set_vtype(emit_t *emit, vtype_kind_t new_vtype) {\n    stack_info_t *si = &emit->stack_info[emit->stack_size - 1];\n    si->vtype = new_vtype;\n}\n\nstatic void emit_post_push_reg(emit_t *emit, vtype_kind_t vtype, int reg) {\n    ensure_extra_stack(emit, 1);\n    stack_info_t *si = &emit->stack_info[emit->stack_size];\n    si->vtype = vtype;\n    si->kind = STACK_REG;\n    si->data.u_reg = reg;\n    adjust_stack(emit, 1);\n}\n\nstatic void emit_post_push_imm(emit_t *emit, vtype_kind_t vtype, mp_int_t imm) {\n    ensure_extra_stack(emit, 1);\n    stack_info_t *si = &emit->stack_info[emit->stack_size];\n    si->vtype = vtype;\n    si->kind = STACK_IMM;\n    si->data.u_imm = imm;\n    adjust_stack(emit, 1);\n}\n\nstatic void emit_post_push_reg_reg(emit_t *emit, vtype_kind_t vtypea, int rega, vtype_kind_t vtypeb, int regb) {\n    emit_post_push_reg(emit, vtypea, rega);\n    emit_post_push_reg(emit, vtypeb, regb);\n}\n\nstatic void emit_post_push_reg_reg_reg(emit_t *emit, vtype_kind_t vtypea, int rega, vtype_kind_t vtypeb, int regb, vtype_kind_t vtypec, int regc) {\n    emit_post_push_reg(emit, vtypea, rega);\n    emit_post_push_reg(emit, vtypeb, regb);\n    emit_post_push_reg(emit, vtypec, regc);\n}\n\nstatic void emit_post_push_reg_reg_reg_reg(emit_t *emit, vtype_kind_t vtypea, int rega, vtype_kind_t vtypeb, int regb, vtype_kind_t vtypec, int regc, vtype_kind_t vtyped, int regd) {\n    emit_post_push_reg(emit, vtypea, rega);\n    emit_post_push_reg(emit, vtypeb, regb);\n    emit_post_push_reg(emit, vtypec, regc);\n    emit_post_push_reg(emit, vtyped, regd);\n}\n\nstatic void emit_call(emit_t *emit, mp_fun_kind_t fun_kind) {\n    need_reg_all(emit);\n    ASM_CALL_IND(emit->as, fun_kind);\n}\n\nstatic void emit_call_with_imm_arg(emit_t *emit, mp_fun_kind_t fun_kind, mp_int_t arg_val, int arg_reg) {\n    need_reg_all(emit);\n    ASM_MOV_REG_IMM(emit->as, arg_reg, arg_val);\n    ASM_CALL_IND(emit->as, fun_kind);\n}\n\nstatic void emit_call_with_2_imm_args(emit_t *emit, mp_fun_kind_t fun_kind, mp_int_t arg_val1, int arg_reg1, mp_int_t arg_val2, int arg_reg2) {\n    need_reg_all(emit);\n    ASM_MOV_REG_IMM(emit->as, arg_reg1, arg_val1);\n    ASM_MOV_REG_IMM(emit->as, arg_reg2, arg_val2);\n    ASM_CALL_IND(emit->as, fun_kind);\n}\n\nstatic void emit_call_with_qstr_arg(emit_t *emit, mp_fun_kind_t fun_kind, qstr qst, int arg_reg) {\n    need_reg_all(emit);\n    emit_native_mov_reg_qstr(emit, arg_reg, qst);\n    ASM_CALL_IND(emit->as, fun_kind);\n}\n\n\n\n\n\nstatic void emit_get_stack_pointer_to_reg_for_pop(emit_t *emit, mp_uint_t reg_dest, mp_uint_t n_pop) {\n    need_reg_all(emit);\n\n    \n    for (mp_uint_t i = 0; i < n_pop; i++) {\n        stack_info_t *si = &emit->stack_info[emit->stack_size - 1 - i];\n        \n        \n        if (si->kind == STACK_IMM) {\n            si->kind = STACK_VALUE;\n            si->vtype = load_reg_stack_imm(emit, reg_dest, si, true);\n            emit_native_mov_state_reg(emit, emit->stack_start + emit->stack_size - 1 - i, reg_dest);\n        }\n\n        \n        assert(si->kind == STACK_VALUE);\n    }\n\n    \n    for (mp_uint_t i = 0; i < n_pop; i++) {\n        stack_info_t *si = &emit->stack_info[emit->stack_size - 1 - i];\n        if (si->vtype != VTYPE_PYOBJ) {\n            mp_uint_t local_num = emit->stack_start + emit->stack_size - 1 - i;\n            emit_native_mov_reg_state(emit, REG_ARG_1, local_num);\n            emit_call_with_imm_arg(emit, MP_F_CONVERT_NATIVE_TO_OBJ, si->vtype, REG_ARG_2); \n            emit_native_mov_state_reg(emit, local_num, REG_RET);\n            si->vtype = VTYPE_PYOBJ;\n            DEBUG_printf(\"  convert_native_to_obj(local_num=\" UINT_FMT \")\\n\", local_num);\n        }\n    }\n\n    \n    adjust_stack(emit, -n_pop);\n    emit_native_mov_reg_state_addr(emit, reg_dest, emit->stack_start + emit->stack_size);\n}\n\n\nstatic void emit_get_stack_pointer_to_reg_for_push(emit_t *emit, mp_uint_t reg_dest, mp_uint_t n_push) {\n    need_reg_all(emit);\n    ensure_extra_stack(emit, n_push);\n    for (mp_uint_t i = 0; i < n_push; i++) {\n        emit->stack_info[emit->stack_size + i].kind = STACK_VALUE;\n        emit->stack_info[emit->stack_size + i].vtype = VTYPE_PYOBJ;\n    }\n    emit_native_mov_reg_state_addr(emit, reg_dest, emit->stack_start + emit->stack_size);\n    adjust_stack(emit, n_push);\n}\n\nstatic void emit_native_push_exc_stack(emit_t *emit, uint label, bool is_finally) {\n    if (emit->exc_stack_size + 1 > emit->exc_stack_alloc) {\n        size_t new_alloc = emit->exc_stack_alloc + 4;\n        emit->exc_stack = m_renew(exc_stack_entry_t, emit->exc_stack, emit->exc_stack_alloc, new_alloc);\n        emit->exc_stack_alloc = new_alloc;\n    }\n\n    exc_stack_entry_t *e = &emit->exc_stack[emit->exc_stack_size++];\n    e->label = label;\n    e->is_finally = is_finally;\n    e->unwind_label = UNWIND_LABEL_UNUSED;\n    e->is_active = true;\n\n    ASM_MOV_REG_PCREL(emit->as, REG_RET, label);\n    ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_PC(emit), REG_RET);\n}\n\nstatic void emit_native_leave_exc_stack(emit_t *emit, bool start_of_handler) {\n    assert(emit->exc_stack_size > 0);\n\n    \n    exc_stack_entry_t *e = &emit->exc_stack[emit->exc_stack_size - 1];\n    e->is_active = false;\n\n    \n    for (--e; e >= emit->exc_stack && !e->is_active; --e) {\n    }\n\n    \n    if (e < emit->exc_stack) {\n        \n        if (start_of_handler) {\n            \n            return;\n        }\n        ASM_XOR_REG_REG(emit->as, REG_RET, REG_RET);\n    } else {\n        \n        ASM_MOV_REG_PCREL(emit->as, REG_RET, e->label);\n    }\n    ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_PC(emit), REG_RET);\n}\n\nstatic exc_stack_entry_t *emit_native_pop_exc_stack(emit_t *emit) {\n    assert(emit->exc_stack_size > 0);\n    exc_stack_entry_t *e = &emit->exc_stack[--emit->exc_stack_size];\n    assert(e->is_active == false);\n    return e;\n}\n\nstatic void emit_load_reg_with_object(emit_t *emit, int reg, mp_obj_t obj) {\n    emit->scope->scope_flags |= MP_SCOPE_FLAG_HASCONSTS;\n    size_t table_off = mp_emit_common_use_const_obj(emit->emit_common, obj);\n    emit_native_mov_reg_state(emit, REG_TEMP0, LOCAL_IDX_FUN_OBJ(emit));\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_TEMP0, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_TEMP0, OFFSETOF_MODULE_CONTEXT_OBJ_TABLE);\n    ASM_LOAD_REG_REG_OFFSET(emit->as, reg, REG_TEMP0, table_off);\n}\n\nstatic void emit_load_reg_with_child(emit_t *emit, int reg, mp_raw_code_t *rc) {\n    size_t table_off = mp_emit_common_alloc_const_child(emit->emit_common, rc);\n    emit_native_mov_reg_state(emit, REG_TEMP0, LOCAL_IDX_FUN_OBJ(emit));\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_TEMP0, OFFSETOF_OBJ_FUN_BC_CHILD_TABLE);\n    ASM_LOAD_REG_REG_OFFSET(emit->as, reg, REG_TEMP0, table_off);\n}\n\nstatic void emit_native_label_assign(emit_t *emit, mp_uint_t l) {\n    DEBUG_printf(\"label_assign(\" UINT_FMT \")\\n\", l);\n\n    bool is_finally = false;\n    if (emit->exc_stack_size > 0) {\n        exc_stack_entry_t *e = &emit->exc_stack[emit->exc_stack_size - 1];\n        is_finally = e->is_finally && e->label == l;\n    }\n\n    if (is_finally) {\n        \n        vtype_kind_t vtype;\n        emit_pre_pop_reg(emit, &vtype, REG_TEMP0);\n        ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_VAL(emit), REG_TEMP0);\n    }\n\n    emit_native_pre(emit);\n    \n    need_stack_settled(emit);\n    mp_asm_base_label_assign(&emit->as->base, l);\n    emit_post(emit);\n\n    if (is_finally) {\n        \n        emit_native_leave_exc_stack(emit, false);\n    }\n}\n\nstatic void emit_native_global_exc_entry(emit_t *emit) {\n    \n\n    emit->exit_label = *emit->label_slot;\n\n    if (NEED_GLOBAL_EXC_HANDLER(emit)) {\n        mp_uint_t nlr_label = *emit->label_slot + 1;\n        mp_uint_t start_label = *emit->label_slot + 2;\n        mp_uint_t global_except_label = *emit->label_slot + 3;\n\n        if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {\n            \n            emit_native_mov_reg_state(emit, REG_ARG_1, LOCAL_IDX_FUN_OBJ(emit));\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_ARG_1, REG_ARG_1, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n            ASM_LOAD_REG_REG_OFFSET(emit->as, REG_ARG_1, REG_ARG_1, OFFSETOF_MODULE_CONTEXT_GLOBALS);\n            emit_call(emit, MP_F_NATIVE_SWAP_GLOBALS);\n\n            \n            emit_native_mov_state_reg(emit, LOCAL_IDX_OLD_GLOBALS(emit), REG_RET);\n        }\n\n        if (emit->scope->exc_stack_size == 0) {\n            if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {\n                \n                ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, start_label, false);\n            }\n\n            \n            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 0);\n            emit_call(emit, MP_F_NLR_PUSH);\n            #if N_NLR_SETJMP\n            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 2);\n            emit_call(emit, MP_F_SETJMP);\n            #endif\n            ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, start_label, true);\n        } else {\n            \n            ASM_XOR_REG_REG(emit->as, REG_TEMP0, REG_TEMP0);\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_UNWIND(emit), REG_TEMP0);\n\n            \n            ASM_MOV_REG_PCREL(emit->as, REG_LOCAL_1, start_label);\n\n            \n            emit_native_label_assign(emit, nlr_label);\n            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 0);\n            emit_call(emit, MP_F_NLR_PUSH);\n            #if N_NLR_SETJMP\n            ASM_MOV_REG_LOCAL_ADDR(emit->as, REG_ARG_1, 2);\n            emit_call(emit, MP_F_SETJMP);\n            #endif\n            ASM_JUMP_IF_REG_NONZERO(emit->as, REG_RET, global_except_label, true);\n\n            \n            ASM_XOR_REG_REG(emit->as, REG_TEMP0, REG_TEMP0);\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_PC(emit), REG_TEMP0);\n            ASM_JUMP_REG(emit->as, REG_LOCAL_1);\n\n            \n            emit_native_label_assign(emit, global_except_label);\n            ASM_MOV_REG_LOCAL(emit->as, REG_LOCAL_1, LOCAL_IDX_EXC_HANDLER_PC(emit));\n            ASM_JUMP_IF_REG_NONZERO(emit->as, REG_LOCAL_1, nlr_label, false);\n        }\n\n        if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {\n            \n            emit_native_mov_reg_state(emit, REG_ARG_1, LOCAL_IDX_OLD_GLOBALS(emit));\n            emit_call(emit, MP_F_NATIVE_SWAP_GLOBALS);\n        }\n\n        if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n            \n            ASM_MOV_REG_LOCAL(emit->as, REG_TEMP0, LOCAL_IDX_EXC_VAL(emit));\n            ASM_STORE_REG_REG_OFFSET(emit->as, REG_TEMP0, REG_GENERATOR_STATE, OFFSETOF_CODE_STATE_STATE);\n\n            \n            ASM_MOV_REG_IMM(emit->as, REG_PARENT_RET, MP_VM_RETURN_EXCEPTION);\n\n            ASM_EXIT(emit->as);\n        } else {\n            \n            ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));\n            emit_call(emit, MP_F_NATIVE_RAISE);\n        }\n\n        \n        emit_native_label_assign(emit, start_label);\n\n        if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n            emit_native_mov_reg_state(emit, REG_TEMP0, LOCAL_IDX_GEN_PC(emit));\n            ASM_JUMP_REG(emit->as, REG_TEMP0);\n            emit->start_offset = mp_asm_base_get_code_pos(&emit->as->base);\n\n            \n\n            \n            ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));\n            emit_call(emit, MP_F_NATIVE_RAISE);\n        }\n    }\n}\n\nstatic void emit_native_global_exc_exit(emit_t *emit) {\n    \n    emit_native_label_assign(emit, emit->exit_label);\n\n    if (NEED_GLOBAL_EXC_HANDLER(emit)) {\n        \n        if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {\n            emit_native_mov_reg_state(emit, REG_ARG_1, LOCAL_IDX_OLD_GLOBALS(emit));\n\n            if (emit->scope->exc_stack_size == 0) {\n                \n                ASM_JUMP_IF_REG_ZERO(emit->as, REG_ARG_1, emit->exit_label + 1, false);\n            }\n\n            \n            emit_call(emit, MP_F_NATIVE_SWAP_GLOBALS);\n        }\n\n        \n        emit_call(emit, MP_F_NLR_POP);\n\n        if (!(emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR)) {\n            if (emit->scope->exc_stack_size == 0) {\n                \n                emit_native_label_assign(emit, emit->exit_label + 1);\n            }\n        }\n\n        \n        ASM_MOV_REG_LOCAL(emit->as, REG_PARENT_RET, LOCAL_IDX_RET_VAL(emit));\n    }\n\n    ASM_EXIT(emit->as);\n}\n\nstatic void emit_native_import_name(emit_t *emit, qstr qst) {\n    DEBUG_printf(\"import_name %s\\n\", qstr_str(qst));\n\n    \n    \n    \n    bool orig_do_viper_types = emit->do_viper_types;\n    emit->do_viper_types = false;\n    vtype_kind_t vtype_fromlist;\n    vtype_kind_t vtype_level;\n    emit_pre_pop_reg_reg(emit, &vtype_fromlist, REG_ARG_2, &vtype_level, REG_ARG_3);\n    assert(vtype_fromlist == VTYPE_PYOBJ);\n    assert(vtype_level == VTYPE_PYOBJ);\n    emit->do_viper_types = orig_do_viper_types;\n\n    emit_call_with_qstr_arg(emit, MP_F_IMPORT_NAME, qst, REG_ARG_1); \n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_import_from(emit_t *emit, qstr qst) {\n    DEBUG_printf(\"import_from %s\\n\", qstr_str(qst));\n    emit_native_pre(emit);\n    vtype_kind_t vtype_module;\n    emit_access_stack(emit, 1, &vtype_module, REG_ARG_1); \n    assert(vtype_module == VTYPE_PYOBJ);\n    emit_call_with_qstr_arg(emit, MP_F_IMPORT_FROM, qst, REG_ARG_2); \n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_import_star(emit_t *emit) {\n    DEBUG_printf(\"import_star\\n\");\n    vtype_kind_t vtype_module;\n    emit_pre_pop_reg(emit, &vtype_module, REG_ARG_1); \n    assert(vtype_module == VTYPE_PYOBJ);\n    emit_call(emit, MP_F_IMPORT_ALL);\n    emit_post(emit);\n}\n\nstatic void emit_native_import(emit_t *emit, qstr qst, int kind) {\n    if (kind == MP_EMIT_IMPORT_NAME) {\n        emit_native_import_name(emit, qst);\n    } else if (kind == MP_EMIT_IMPORT_FROM) {\n        emit_native_import_from(emit, qst);\n    } else {\n        emit_native_import_star(emit);\n    }\n}\n\nstatic void emit_native_load_const_tok(emit_t *emit, mp_token_kind_t tok) {\n    DEBUG_printf(\"load_const_tok(tok=%u)\\n\", tok);\n    if (tok == MP_TOKEN_ELLIPSIS) {\n        emit_native_load_const_obj(emit, MP_OBJ_FROM_PTR(&mp_const_ellipsis_obj));\n    } else {\n        emit_native_pre(emit);\n        if (tok == MP_TOKEN_KW_NONE) {\n            emit_post_push_imm(emit, VTYPE_PTR_NONE, 0);\n        } else {\n            emit_post_push_imm(emit, VTYPE_BOOL, tok == MP_TOKEN_KW_FALSE ? 0 : 1);\n        }\n    }\n}\n\nstatic void emit_native_load_const_small_int(emit_t *emit, mp_int_t arg) {\n    DEBUG_printf(\"load_const_small_int(int=\" INT_FMT \")\\n\", arg);\n    emit_native_pre(emit);\n    emit_post_push_imm(emit, VTYPE_INT, arg);\n}\n\nstatic void emit_native_load_const_str(emit_t *emit, qstr qst) {\n    emit_native_pre(emit);\n    \n    \n     \n    {\n        need_reg_single(emit, REG_TEMP0, 0);\n        emit_native_mov_reg_qstr_obj(emit, REG_TEMP0, qst);\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_TEMP0);\n    }\n}\n\nstatic void emit_native_load_const_obj(emit_t *emit, mp_obj_t obj) {\n    emit_native_pre(emit);\n    need_reg_single(emit, REG_RET, 0);\n    emit_load_reg_with_object(emit, REG_RET, obj);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_load_null(emit_t *emit) {\n    emit_native_pre(emit);\n    emit_post_push_imm(emit, VTYPE_PYOBJ, 0);\n}\n\nstatic void emit_native_load_fast(emit_t *emit, qstr qst, mp_uint_t local_num) {\n    DEBUG_printf(\"load_fast(%s, \" UINT_FMT \")\\n\", qstr_str(qst), local_num);\n    vtype_kind_t vtype = emit->local_vtype[local_num];\n    if (vtype == VTYPE_UNBOUND) {\n        EMIT_NATIVE_VIPER_TYPE_ERROR(emit, MP_ERROR_TEXT(\"local '%q' used before type known\"), qst);\n    }\n    emit_native_pre(emit);\n    if (local_num < MAX_REGS_FOR_LOCAL_VARS && CAN_USE_REGS_FOR_LOCALS(emit)) {\n        emit_post_push_reg(emit, vtype, reg_local_table[local_num]);\n    } else {\n        need_reg_single(emit, REG_TEMP0, 0);\n        emit_native_mov_reg_state(emit, REG_TEMP0, LOCAL_IDX_LOCAL_VAR(emit, local_num));\n        emit_post_push_reg(emit, vtype, REG_TEMP0);\n    }\n}\n\nstatic void emit_native_load_deref(emit_t *emit, qstr qst, mp_uint_t local_num) {\n    DEBUG_printf(\"load_deref(%s, \" UINT_FMT \")\\n\", qstr_str(qst), local_num);\n    need_reg_single(emit, REG_RET, 0);\n    emit_native_load_fast(emit, qst, local_num);\n    vtype_kind_t vtype;\n    int reg_base = REG_RET;\n    emit_pre_pop_reg_flexible(emit, &vtype, &reg_base, -1, -1);\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_RET, reg_base, 1);\n    \n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_load_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind) {\n    if (kind == MP_EMIT_IDOP_LOCAL_FAST) {\n        emit_native_load_fast(emit, qst, local_num);\n    } else {\n        emit_native_load_deref(emit, qst, local_num);\n    }\n}\n\nstatic void emit_native_load_global(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_F_LOAD_NAME + MP_EMIT_IDOP_GLOBAL_NAME == MP_F_LOAD_NAME);\n    MP_STATIC_ASSERT(MP_F_LOAD_NAME + MP_EMIT_IDOP_GLOBAL_GLOBAL == MP_F_LOAD_GLOBAL);\n    emit_native_pre(emit);\n    if (kind == MP_EMIT_IDOP_GLOBAL_NAME) {\n        DEBUG_printf(\"load_name(%s)\\n\", qstr_str(qst));\n    } else {\n        DEBUG_printf(\"load_global(%s)\\n\", qstr_str(qst));\n        if (emit->do_viper_types) {\n            \n            int native_type = mp_native_type_from_qstr(qst);\n            if (native_type >= MP_NATIVE_TYPE_BOOL) {\n                emit_post_push_imm(emit, VTYPE_BUILTIN_CAST, native_type);\n                return;\n            }\n        }\n    }\n    emit_call_with_qstr_arg(emit, MP_F_LOAD_NAME + kind, qst, REG_ARG_1);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_load_attr(emit_t *emit, qstr qst) {\n    \n    \n    \n    \n    vtype_kind_t vtype_base;\n    emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1); \n    assert(vtype_base == VTYPE_PYOBJ);\n    emit_call_with_qstr_arg(emit, MP_F_LOAD_ATTR, qst, REG_ARG_2); \n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_load_method(emit_t *emit, qstr qst, bool is_super) {\n    if (is_super) {\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_2, 3); \n        emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_2, 2); \n        emit_call_with_qstr_arg(emit, MP_F_LOAD_SUPER_METHOD, qst, REG_ARG_1); \n    } else {\n        vtype_kind_t vtype_base;\n        emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1); \n        assert(vtype_base == VTYPE_PYOBJ);\n        emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, 2); \n        emit_call_with_qstr_arg(emit, MP_F_LOAD_METHOD, qst, REG_ARG_2); \n    }\n}\n\nstatic void emit_native_load_build_class(emit_t *emit) {\n    emit_native_pre(emit);\n    emit_call(emit, MP_F_LOAD_BUILD_CLASS);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_load_subscr(emit_t *emit) {\n    DEBUG_printf(\"load_subscr\\n\");\n    \n\n    \n    \n    vtype_kind_t vtype_base = peek_vtype(emit, 1);\n\n    if (vtype_base == VTYPE_PYOBJ) {\n        \n        \n        vtype_kind_t vtype_index = peek_vtype(emit, 0);\n        if (vtype_index == VTYPE_PYOBJ) {\n            emit_pre_pop_reg(emit, &vtype_index, REG_ARG_2);\n        } else {\n            emit_pre_pop_reg(emit, &vtype_index, REG_ARG_1);\n            emit_call_with_imm_arg(emit, MP_F_CONVERT_NATIVE_TO_OBJ, vtype_index, REG_ARG_2); \n            ASM_MOV_REG_REG(emit->as, REG_ARG_2, REG_RET);\n        }\n        emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1);\n        emit_call_with_imm_arg(emit, MP_F_OBJ_SUBSCR, (mp_uint_t)MP_OBJ_SENTINEL, REG_ARG_3);\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n    } else {\n        \n        \n        \n        \n        stack_info_t *top = peek_stack(emit, 0);\n        if (top->vtype == VTYPE_INT && top->kind == STACK_IMM) {\n            \n            mp_int_t index_value = top->data.u_imm;\n            emit_pre_pop_discard(emit); \n            int reg_base = REG_ARG_1;\n            int reg_index = REG_ARG_2;\n            emit_pre_pop_reg_flexible(emit, &vtype_base, &reg_base, reg_index, reg_index);\n            need_reg_single(emit, REG_RET, 0);\n            switch (vtype_base) {\n                case VTYPE_PTR8: {\n                    \n                    \n                    if (index_value != 0) {\n                        \n                        #if N_THUMB\n                        if (index_value > 0 && index_value < 32) {\n                            asm_thumb_ldrb_rlo_rlo_i5(emit->as, REG_RET, reg_base, index_value);\n                            break;\n                        }\n                        #endif\n                        need_reg_single(emit, reg_index, 0);\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value);\n                        ASM_ADD_REG_REG(emit->as, reg_index, reg_base); \n                        reg_base = reg_index;\n                    }\n                    ASM_LOAD8_REG_REG(emit->as, REG_RET, reg_base); \n                    break;\n                }\n                case VTYPE_PTR16: {\n                    \n                    if (index_value != 0) {\n                        \n                        #if N_THUMB\n                        if (index_value > 0 && index_value < 32) {\n                            asm_thumb_ldrh_rlo_rlo_i5(emit->as, REG_RET, reg_base, index_value);\n                            break;\n                        }\n                        #endif\n                        need_reg_single(emit, reg_index, 0);\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value << 1);\n                        ASM_ADD_REG_REG(emit->as, reg_index, reg_base); \n                        reg_base = reg_index;\n                    }\n                    ASM_LOAD16_REG_REG(emit->as, REG_RET, reg_base); \n                    break;\n                }\n                case VTYPE_PTR32: {\n                    \n                    if (index_value != 0) {\n                        \n                        #if N_THUMB\n                        if (index_value > 0 && index_value < 32) {\n                            asm_thumb_ldr_rlo_rlo_i5(emit->as, REG_RET, reg_base, index_value);\n                            break;\n                        }\n                        #endif\n                        need_reg_single(emit, reg_index, 0);\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value << 2);\n                        ASM_ADD_REG_REG(emit->as, reg_index, reg_base); \n                        reg_base = reg_index;\n                    }\n                    ASM_LOAD32_REG_REG(emit->as, REG_RET, reg_base); \n                    break;\n                }\n                default:\n                    EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                        MP_ERROR_TEXT(\"can't load from '%q'\"), vtype_to_qstr(vtype_base));\n            }\n        } else {\n            \n            vtype_kind_t vtype_index;\n            int reg_index = REG_ARG_2;\n            emit_pre_pop_reg_flexible(emit, &vtype_index, &reg_index, REG_ARG_1, REG_ARG_1);\n            emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1);\n            need_reg_single(emit, REG_RET, 0);\n            if (vtype_index != VTYPE_INT && vtype_index != VTYPE_UINT) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                    MP_ERROR_TEXT(\"can't load with '%q' index\"), vtype_to_qstr(vtype_index));\n            }\n            switch (vtype_base) {\n                case VTYPE_PTR8: {\n                    \n                    \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_LOAD8_REG_REG(emit->as, REG_RET, REG_ARG_1); \n                    break;\n                }\n                case VTYPE_PTR16: {\n                    \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_LOAD16_REG_REG(emit->as, REG_RET, REG_ARG_1); \n                    break;\n                }\n                case VTYPE_PTR32: {\n                    \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_LOAD32_REG_REG(emit->as, REG_RET, REG_ARG_1); \n                    break;\n                }\n                default:\n                    EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                        MP_ERROR_TEXT(\"can't load from '%q'\"), vtype_to_qstr(vtype_base));\n            }\n        }\n        emit_post_push_reg(emit, VTYPE_INT, REG_RET);\n    }\n}\n\nstatic void emit_native_store_fast(emit_t *emit, qstr qst, mp_uint_t local_num) {\n    vtype_kind_t vtype;\n    if (local_num < MAX_REGS_FOR_LOCAL_VARS && CAN_USE_REGS_FOR_LOCALS(emit)) {\n        emit_pre_pop_reg(emit, &vtype, reg_local_table[local_num]);\n    } else {\n        emit_pre_pop_reg(emit, &vtype, REG_TEMP0);\n        emit_native_mov_state_reg(emit, LOCAL_IDX_LOCAL_VAR(emit, local_num), REG_TEMP0);\n    }\n    emit_post(emit);\n\n    \n    if (emit->local_vtype[local_num] == VTYPE_UNBOUND) {\n        \n        emit->local_vtype[local_num] = vtype;\n    } else if (emit->local_vtype[local_num] != vtype) {\n        \n        EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n            MP_ERROR_TEXT(\"local '%q' has type '%q' but source is '%q'\"),\n            qst, vtype_to_qstr(emit->local_vtype[local_num]), vtype_to_qstr(vtype));\n    }\n}\n\nstatic void emit_native_store_deref(emit_t *emit, qstr qst, mp_uint_t local_num) {\n    DEBUG_printf(\"store_deref(%s, \" UINT_FMT \")\\n\", qstr_str(qst), local_num);\n    need_reg_single(emit, REG_TEMP0, 0);\n    need_reg_single(emit, REG_TEMP1, 0);\n    emit_native_load_fast(emit, qst, local_num);\n    vtype_kind_t vtype;\n    int reg_base = REG_TEMP0;\n    emit_pre_pop_reg_flexible(emit, &vtype, &reg_base, -1, -1);\n    int reg_src = REG_TEMP1;\n    emit_pre_pop_reg_flexible(emit, &vtype, &reg_src, reg_base, reg_base);\n    ASM_STORE_REG_REG_OFFSET(emit->as, reg_src, reg_base, 1);\n    emit_post(emit);\n}\n\nstatic void emit_native_store_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind) {\n    if (kind == MP_EMIT_IDOP_LOCAL_FAST) {\n        emit_native_store_fast(emit, qst, local_num);\n    } else {\n        emit_native_store_deref(emit, qst, local_num);\n    }\n}\n\nstatic void emit_native_store_global(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_F_STORE_NAME + MP_EMIT_IDOP_GLOBAL_NAME == MP_F_STORE_NAME);\n    MP_STATIC_ASSERT(MP_F_STORE_NAME + MP_EMIT_IDOP_GLOBAL_GLOBAL == MP_F_STORE_GLOBAL);\n    if (kind == MP_EMIT_IDOP_GLOBAL_NAME) {\n        \n        vtype_kind_t vtype;\n        emit_pre_pop_reg(emit, &vtype, REG_ARG_2);\n        assert(vtype == VTYPE_PYOBJ);\n    } else {\n        vtype_kind_t vtype = peek_vtype(emit, 0);\n        if (vtype == VTYPE_PYOBJ) {\n            emit_pre_pop_reg(emit, &vtype, REG_ARG_2);\n        } else {\n            emit_pre_pop_reg(emit, &vtype, REG_ARG_1);\n            emit_call_with_imm_arg(emit, MP_F_CONVERT_NATIVE_TO_OBJ, vtype, REG_ARG_2); \n            ASM_MOV_REG_REG(emit->as, REG_ARG_2, REG_RET);\n        }\n    }\n    emit_call_with_qstr_arg(emit, MP_F_STORE_NAME + kind, qst, REG_ARG_1); \n    emit_post(emit);\n}\n\nstatic void emit_native_store_attr(emit_t *emit, qstr qst) {\n    vtype_kind_t vtype_base;\n    vtype_kind_t vtype_val = peek_vtype(emit, 1);\n    if (vtype_val == VTYPE_PYOBJ) {\n        emit_pre_pop_reg_reg(emit, &vtype_base, REG_ARG_1, &vtype_val, REG_ARG_3); \n    } else {\n        emit_access_stack(emit, 2, &vtype_val, REG_ARG_1); \n        emit_call_with_imm_arg(emit, MP_F_CONVERT_NATIVE_TO_OBJ, vtype_val, REG_ARG_2); \n        ASM_MOV_REG_REG(emit->as, REG_ARG_3, REG_RET); \n        emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1); \n        adjust_stack(emit, -1); \n    }\n    assert(vtype_base == VTYPE_PYOBJ);\n    emit_call_with_qstr_arg(emit, MP_F_STORE_ATTR, qst, REG_ARG_2); \n    emit_post(emit);\n}\n\nstatic void emit_native_store_subscr(emit_t *emit) {\n    DEBUG_printf(\"store_subscr\\n\");\n    \n\n    \n    \n    vtype_kind_t vtype_base = peek_vtype(emit, 1);\n\n    if (vtype_base == VTYPE_PYOBJ) {\n        \n        vtype_kind_t vtype_index = peek_vtype(emit, 0);\n        vtype_kind_t vtype_value = peek_vtype(emit, 2);\n        if (vtype_index != VTYPE_PYOBJ || vtype_value != VTYPE_PYOBJ) {\n            \n            \n            emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_1, 3);\n            adjust_stack(emit, 3);\n        }\n        emit_pre_pop_reg_reg_reg(emit, &vtype_index, REG_ARG_2, &vtype_base, REG_ARG_1, &vtype_value, REG_ARG_3);\n        emit_call(emit, MP_F_OBJ_SUBSCR);\n    } else {\n        \n        \n        \n        \n        stack_info_t *top = peek_stack(emit, 0);\n        if (top->vtype == VTYPE_INT && top->kind == STACK_IMM) {\n            \n            mp_int_t index_value = top->data.u_imm;\n            emit_pre_pop_discard(emit); \n            vtype_kind_t vtype_value;\n            int reg_base = REG_ARG_1;\n            int reg_index = REG_ARG_2;\n            int reg_value = REG_ARG_3;\n            emit_pre_pop_reg_flexible(emit, &vtype_base, &reg_base, reg_index, reg_value);\n            #if N_X64 || N_X86\n            \n            emit_pre_pop_reg(emit, &vtype_value, reg_value);\n            #else\n            emit_pre_pop_reg_flexible(emit, &vtype_value, &reg_value, reg_base, reg_index);\n            #endif\n            if (vtype_value != VTYPE_BOOL && vtype_value != VTYPE_INT && vtype_value != VTYPE_UINT) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                    MP_ERROR_TEXT(\"can't store '%q'\"), vtype_to_qstr(vtype_value));\n            }\n            switch (vtype_base) {\n                case VTYPE_PTR8: {\n                    \n                    \n                    if (index_value != 0) {\n                        \n                        #if N_THUMB\n                        if (index_value > 0 && index_value < 32) {\n                            asm_thumb_strb_rlo_rlo_i5(emit->as, reg_value, reg_base, index_value);\n                            break;\n                        }\n                        #endif\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value);\n                        #if N_ARM\n                        asm_arm_strb_reg_reg_reg(emit->as, reg_value, reg_base, reg_index);\n                        return;\n                        #endif\n                        ASM_ADD_REG_REG(emit->as, reg_index, reg_base); \n                        reg_base = reg_index;\n                    }\n                    ASM_STORE8_REG_REG(emit->as, reg_value, reg_base); \n                    break;\n                }\n                case VTYPE_PTR16: {\n                    \n                    if (index_value != 0) {\n                        \n                        #if N_THUMB\n                        if (index_value > 0 && index_value < 32) {\n                            asm_thumb_strh_rlo_rlo_i5(emit->as, reg_value, reg_base, index_value);\n                            break;\n                        }\n                        #endif\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value << 1);\n                        ASM_ADD_REG_REG(emit->as, reg_index, reg_base); \n                        reg_base = reg_index;\n                    }\n                    ASM_STORE16_REG_REG(emit->as, reg_value, reg_base); \n                    break;\n                }\n                case VTYPE_PTR32: {\n                    \n                    if (index_value != 0) {\n                        \n                        #if N_THUMB\n                        if (index_value > 0 && index_value < 32) {\n                            asm_thumb_str_rlo_rlo_i5(emit->as, reg_value, reg_base, index_value);\n                            break;\n                        }\n                        #endif\n                        #if N_ARM\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value);\n                        asm_arm_str_reg_reg_reg(emit->as, reg_value, reg_base, reg_index);\n                        return;\n                        #endif\n                        ASM_MOV_REG_IMM(emit->as, reg_index, index_value << 2);\n                        ASM_ADD_REG_REG(emit->as, reg_index, reg_base); \n                        reg_base = reg_index;\n                    }\n                    ASM_STORE32_REG_REG(emit->as, reg_value, reg_base); \n                    break;\n                }\n                default:\n                    EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                        MP_ERROR_TEXT(\"can't store to '%q'\"), vtype_to_qstr(vtype_base));\n            }\n        } else {\n            \n            vtype_kind_t vtype_index, vtype_value;\n            int reg_index = REG_ARG_2;\n            int reg_value = REG_ARG_3;\n            emit_pre_pop_reg_flexible(emit, &vtype_index, &reg_index, REG_ARG_1, reg_value);\n            emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1);\n            if (vtype_index != VTYPE_INT && vtype_index != VTYPE_UINT) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                    MP_ERROR_TEXT(\"can't store with '%q' index\"), vtype_to_qstr(vtype_index));\n            }\n            #if N_X64 || N_X86\n            \n            emit_pre_pop_reg(emit, &vtype_value, reg_value);\n            #else\n            emit_pre_pop_reg_flexible(emit, &vtype_value, &reg_value, REG_ARG_1, reg_index);\n            #endif\n            if (vtype_value != VTYPE_BOOL && vtype_value != VTYPE_INT && vtype_value != VTYPE_UINT) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                    MP_ERROR_TEXT(\"can't store '%q'\"), vtype_to_qstr(vtype_value));\n            }\n            switch (vtype_base) {\n                case VTYPE_PTR8: {\n                    \n                    \n                    #if N_ARM\n                    asm_arm_strb_reg_reg_reg(emit->as, reg_value, REG_ARG_1, reg_index);\n                    break;\n                    #endif\n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_STORE8_REG_REG(emit->as, reg_value, REG_ARG_1); \n                    break;\n                }\n                case VTYPE_PTR16: {\n                    \n                    #if N_ARM\n                    asm_arm_strh_reg_reg_reg(emit->as, reg_value, REG_ARG_1, reg_index);\n                    break;\n                    #endif\n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_STORE16_REG_REG(emit->as, reg_value, REG_ARG_1); \n                    break;\n                }\n                case VTYPE_PTR32: {\n                    \n                    #if N_ARM\n                    asm_arm_str_reg_reg_reg(emit->as, reg_value, REG_ARG_1, reg_index);\n                    break;\n                    #endif\n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_ADD_REG_REG(emit->as, REG_ARG_1, reg_index); \n                    ASM_STORE32_REG_REG(emit->as, reg_value, REG_ARG_1); \n                    break;\n                }\n                default:\n                    EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                        MP_ERROR_TEXT(\"can't store to '%q'\"), vtype_to_qstr(vtype_base));\n            }\n        }\n\n    }\n}\n\nstatic void emit_native_delete_local(emit_t *emit, qstr qst, mp_uint_t local_num, int kind) {\n    if (kind == MP_EMIT_IDOP_LOCAL_FAST) {\n        \n        \n        \n        emit_native_load_const_tok(emit, MP_TOKEN_KW_NONE);\n        emit_native_store_fast(emit, qst, local_num);\n    } else {\n        \n    }\n}\n\nstatic void emit_native_delete_global(emit_t *emit, qstr qst, int kind) {\n    MP_STATIC_ASSERT(MP_F_DELETE_NAME + MP_EMIT_IDOP_GLOBAL_NAME == MP_F_DELETE_NAME);\n    MP_STATIC_ASSERT(MP_F_DELETE_NAME + MP_EMIT_IDOP_GLOBAL_GLOBAL == MP_F_DELETE_GLOBAL);\n    emit_native_pre(emit);\n    emit_call_with_qstr_arg(emit, MP_F_DELETE_NAME + kind, qst, REG_ARG_1);\n    emit_post(emit);\n}\n\nstatic void emit_native_delete_attr(emit_t *emit, qstr qst) {\n    vtype_kind_t vtype_base;\n    emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1); \n    assert(vtype_base == VTYPE_PYOBJ);\n    ASM_XOR_REG_REG(emit->as, REG_ARG_3, REG_ARG_3); \n    emit_call_with_qstr_arg(emit, MP_F_STORE_ATTR, qst, REG_ARG_2); \n    emit_post(emit);\n}\n\nstatic void emit_native_delete_subscr(emit_t *emit) {\n    vtype_kind_t vtype_index, vtype_base;\n    emit_pre_pop_reg_reg(emit, &vtype_index, REG_ARG_2, &vtype_base, REG_ARG_1); \n    assert(vtype_index == VTYPE_PYOBJ);\n    assert(vtype_base == VTYPE_PYOBJ);\n    emit_call_with_imm_arg(emit, MP_F_OBJ_SUBSCR, (mp_uint_t)MP_OBJ_NULL, REG_ARG_3);\n}\n\nstatic void emit_native_subscr(emit_t *emit, int kind) {\n    if (kind == MP_EMIT_SUBSCR_LOAD) {\n        emit_native_load_subscr(emit);\n    } else if (kind == MP_EMIT_SUBSCR_STORE) {\n        emit_native_store_subscr(emit);\n    } else {\n        emit_native_delete_subscr(emit);\n    }\n}\n\nstatic void emit_native_attr(emit_t *emit, qstr qst, int kind) {\n    if (kind == MP_EMIT_ATTR_LOAD) {\n        emit_native_load_attr(emit, qst);\n    } else if (kind == MP_EMIT_ATTR_STORE) {\n        emit_native_store_attr(emit, qst);\n    } else {\n        emit_native_delete_attr(emit, qst);\n    }\n}\n\nstatic void emit_native_dup_top(emit_t *emit) {\n    DEBUG_printf(\"dup_top\\n\");\n    vtype_kind_t vtype;\n    int reg = REG_TEMP0;\n    emit_pre_pop_reg_flexible(emit, &vtype, &reg, -1, -1);\n    emit_post_push_reg_reg(emit, vtype, reg, vtype, reg);\n}\n\nstatic void emit_native_dup_top_two(emit_t *emit) {\n    vtype_kind_t vtype0, vtype1;\n    emit_pre_pop_reg_reg(emit, &vtype0, REG_TEMP0, &vtype1, REG_TEMP1);\n    emit_post_push_reg_reg_reg_reg(emit, vtype1, REG_TEMP1, vtype0, REG_TEMP0, vtype1, REG_TEMP1, vtype0, REG_TEMP0);\n}\n\nstatic void emit_native_pop_top(emit_t *emit) {\n    DEBUG_printf(\"pop_top\\n\");\n    emit_pre_pop_discard(emit);\n    emit_post(emit);\n}\n\nstatic void emit_native_rot_two(emit_t *emit) {\n    DEBUG_printf(\"rot_two\\n\");\n    vtype_kind_t vtype0, vtype1;\n    emit_pre_pop_reg_reg(emit, &vtype0, REG_TEMP0, &vtype1, REG_TEMP1);\n    emit_post_push_reg_reg(emit, vtype0, REG_TEMP0, vtype1, REG_TEMP1);\n}\n\nstatic void emit_native_rot_three(emit_t *emit) {\n    DEBUG_printf(\"rot_three\\n\");\n    vtype_kind_t vtype0, vtype1, vtype2;\n    emit_pre_pop_reg_reg_reg(emit, &vtype0, REG_TEMP0, &vtype1, REG_TEMP1, &vtype2, REG_TEMP2);\n    emit_post_push_reg_reg_reg(emit, vtype0, REG_TEMP0, vtype2, REG_TEMP2, vtype1, REG_TEMP1);\n}\n\nstatic void emit_native_jump(emit_t *emit, mp_uint_t label) {\n    DEBUG_printf(\"jump(label=\" UINT_FMT \")\\n\", label);\n    emit_native_pre(emit);\n    \n    need_stack_settled(emit);\n    ASM_JUMP(emit->as, label);\n    emit_post(emit);\n    mp_asm_base_suppress_code(&emit->as->base);\n}\n\nstatic void emit_native_jump_helper(emit_t *emit, bool cond, mp_uint_t label, bool pop) {\n    vtype_kind_t vtype = peek_vtype(emit, 0);\n    if (vtype == VTYPE_PYOBJ) {\n        emit_pre_pop_reg(emit, &vtype, REG_ARG_1);\n        if (!pop) {\n            adjust_stack(emit, 1);\n        }\n        emit_call(emit, MP_F_OBJ_IS_TRUE);\n    } else {\n        emit_pre_pop_reg(emit, &vtype, REG_RET);\n        if (!pop) {\n            adjust_stack(emit, 1);\n        }\n        if (!(vtype == VTYPE_BOOL || vtype == VTYPE_INT || vtype == VTYPE_UINT)) {\n            EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                MP_ERROR_TEXT(\"can't implicitly convert '%q' to 'bool'\"), vtype_to_qstr(vtype));\n        }\n    }\n    \n    \n    if (!pop) {\n        emit->saved_stack_vtype = vtype;\n    }\n    \n    need_stack_settled(emit);\n    \n    if (cond) {\n        ASM_JUMP_IF_REG_NONZERO(emit->as, REG_RET, label, vtype == VTYPE_PYOBJ);\n    } else {\n        ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, label, vtype == VTYPE_PYOBJ);\n    }\n    if (!pop) {\n        adjust_stack(emit, -1);\n    }\n    emit_post(emit);\n}\n\nstatic void emit_native_pop_jump_if(emit_t *emit, bool cond, mp_uint_t label) {\n    DEBUG_printf(\"pop_jump_if(cond=%u, label=\" UINT_FMT \")\\n\", cond, label);\n    emit_native_jump_helper(emit, cond, label, true);\n}\n\nstatic void emit_native_jump_if_or_pop(emit_t *emit, bool cond, mp_uint_t label) {\n    DEBUG_printf(\"jump_if_or_pop(cond=%u, label=\" UINT_FMT \")\\n\", cond, label);\n    emit_native_jump_helper(emit, cond, label, false);\n}\n\nstatic void emit_native_unwind_jump(emit_t *emit, mp_uint_t label, mp_uint_t except_depth) {\n    if (except_depth > 0) {\n        exc_stack_entry_t *first_finally = NULL;\n        exc_stack_entry_t *prev_finally = NULL;\n        exc_stack_entry_t *e = &emit->exc_stack[emit->exc_stack_size - 1];\n        for (; except_depth > 0; --except_depth, --e) {\n            if (e->is_finally && e->is_active) {\n                \n                if (first_finally == NULL) {\n                    first_finally = e;\n                }\n                if (prev_finally != NULL) {\n                    \n                    prev_finally->unwind_label = e->label;\n                }\n                prev_finally = e;\n            }\n        }\n        if (prev_finally == NULL) {\n            \n            \n            if (e < emit->exc_stack) {\n                ASM_XOR_REG_REG(emit->as, REG_RET, REG_RET);\n            } else {\n                ASM_MOV_REG_PCREL(emit->as, REG_RET, e->label);\n            }\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_PC(emit), REG_RET);\n        } else {\n            \n            \n            prev_finally->unwind_label = UNWIND_LABEL_DO_FINAL_UNWIND;\n            ASM_MOV_REG_PCREL(emit->as, REG_RET, label & ~MP_EMIT_BREAK_FROM_FOR);\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_UNWIND(emit), REG_RET);\n            \n            ASM_MOV_REG_IMM(emit->as, REG_RET, (mp_uint_t)MP_OBJ_NULL);\n            ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_VAL(emit), REG_RET);\n            \n            label = first_finally->label;\n        }\n    }\n    emit_native_jump(emit, label & ~MP_EMIT_BREAK_FROM_FOR);\n}\n\nstatic void emit_native_setup_with(emit_t *emit, mp_uint_t label) {\n    \n    \n\n    \n    vtype_kind_t vtype;\n    emit_access_stack(emit, 1, &vtype, REG_ARG_1); \n    assert(vtype == VTYPE_PYOBJ);\n    emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, 2); \n    emit_call_with_qstr_arg(emit, MP_F_LOAD_METHOD, MP_QSTR___exit__, REG_ARG_2);\n    \n\n    emit_pre_pop_reg(emit, &vtype, REG_ARG_3); \n    emit_pre_pop_reg(emit, &vtype, REG_ARG_2); \n    emit_pre_pop_reg(emit, &vtype, REG_ARG_1); \n    emit_post_push_reg(emit, vtype, REG_ARG_2); \n    emit_post_push_reg(emit, vtype, REG_ARG_3); \n    \n    \n\n    \n    emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, 2); \n    emit_call_with_qstr_arg(emit, MP_F_LOAD_METHOD, MP_QSTR___enter__, REG_ARG_2); \n    \n\n    \n    emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 2); \n    emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, 0, REG_ARG_1, 0, REG_ARG_2);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET); \n    \n\n    \n    need_stack_settled(emit);\n    emit_native_push_exc_stack(emit, label, true);\n\n    emit_native_dup_top(emit);\n    \n}\n\nstatic void emit_native_setup_block(emit_t *emit, mp_uint_t label, int kind) {\n    if (kind == MP_EMIT_SETUP_BLOCK_WITH) {\n        emit_native_setup_with(emit, label);\n    } else {\n        \n        emit_native_pre(emit);\n        need_stack_settled(emit);\n        emit_native_push_exc_stack(emit, label, kind == MP_EMIT_SETUP_BLOCK_FINALLY);\n        emit_post(emit);\n    }\n}\n\nstatic void emit_native_with_cleanup(emit_t *emit, mp_uint_t label) {\n    \n\n    \n    emit_native_pre(emit);\n    emit_native_leave_exc_stack(emit, false);\n    adjust_stack(emit, -1);\n    \n\n    \n    emit_native_label_assign(emit, *emit->label_slot + 2);\n\n    \n    emit_post_push_imm(emit, VTYPE_PTR_NONE, 0);\n    emit_post_push_imm(emit, VTYPE_PTR_NONE, 0);\n    emit_post_push_imm(emit, VTYPE_PTR_NONE, 0);\n    emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 5);\n    emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, 3, REG_ARG_1, 0, REG_ARG_2);\n\n    \n    emit_native_jump(emit, *emit->label_slot);\n\n    \n    \n    mp_asm_base_label_assign(&emit->as->base, label);\n\n    \n    emit_native_leave_exc_stack(emit, true);\n\n    \n    emit_native_adjust_stack_size(emit, 2);\n    \n\n    ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit)); \n\n    \n    ASM_JUMP_IF_REG_ZERO(emit->as, REG_ARG_1, *emit->label_slot + 2, false);\n\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_ARG_2, REG_ARG_1, 0); \n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_ARG_2); \n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_ARG_1); \n    emit_post_push_imm(emit, VTYPE_PTR_NONE, 0); \n    \n\n    \n    emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 5);\n    emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, 3, REG_ARG_1, 0, REG_ARG_2);\n    \n\n    \n    if (REG_ARG_1 != REG_RET) {\n        ASM_MOV_REG_REG(emit->as, REG_ARG_1, REG_RET);\n    }\n    emit_call(emit, MP_F_OBJ_IS_TRUE);\n    ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, *emit->label_slot + 1, true);\n\n    \n    emit_native_label_assign(emit, *emit->label_slot);\n    ASM_MOV_REG_IMM(emit->as, REG_TEMP0, (mp_uint_t)MP_OBJ_NULL);\n    ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_VAL(emit), REG_TEMP0);\n\n    \n    emit_native_label_assign(emit, *emit->label_slot + 1);\n\n    \n}\n\nstatic void emit_native_end_finally(emit_t *emit) {\n    \n    \n    \n    \n    \n    emit_native_pre(emit);\n    ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));\n    emit_call(emit, MP_F_NATIVE_RAISE);\n\n    \n    exc_stack_entry_t *e = emit_native_pop_exc_stack(emit);\n    if (e->unwind_label != UNWIND_LABEL_UNUSED) {\n        ASM_MOV_REG_LOCAL(emit->as, REG_RET, LOCAL_IDX_EXC_HANDLER_UNWIND(emit));\n        ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, *emit->label_slot, false);\n        if (e->unwind_label == UNWIND_LABEL_DO_FINAL_UNWIND) {\n            ASM_JUMP_REG(emit->as, REG_RET);\n        } else {\n            emit_native_jump(emit, e->unwind_label);\n        }\n        emit_native_label_assign(emit, *emit->label_slot);\n    }\n\n    emit_post(emit);\n}\n\nstatic void emit_native_get_iter(emit_t *emit, bool use_stack) {\n    \n    \n\n    vtype_kind_t vtype;\n    emit_pre_pop_reg(emit, &vtype, REG_ARG_1);\n    assert(vtype == VTYPE_PYOBJ);\n    if (use_stack) {\n        emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_2, MP_OBJ_ITER_BUF_NSLOTS);\n        emit_call(emit, MP_F_NATIVE_GETITER);\n    } else {\n        \n        ASM_MOV_REG_IMM(emit->as, REG_ARG_2, 0);\n        emit_call(emit, MP_F_NATIVE_GETITER);\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n    }\n}\n\nstatic void emit_native_for_iter(emit_t *emit, mp_uint_t label) {\n    emit_native_pre(emit);\n    emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_1, MP_OBJ_ITER_BUF_NSLOTS);\n    adjust_stack(emit, MP_OBJ_ITER_BUF_NSLOTS);\n    emit_call(emit, MP_F_NATIVE_ITERNEXT);\n    #if MICROPY_DEBUG_MP_OBJ_SENTINELS\n    ASM_MOV_REG_IMM(emit->as, REG_TEMP1, (mp_uint_t)MP_OBJ_STOP_ITERATION);\n    ASM_JUMP_IF_REG_EQ(emit->as, REG_RET, REG_TEMP1, label);\n    #else\n    MP_STATIC_ASSERT(MP_OBJ_STOP_ITERATION == 0);\n    ASM_JUMP_IF_REG_ZERO(emit->as, REG_RET, label, false);\n    #endif\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_for_iter_end(emit_t *emit) {\n    \n    emit_native_pre(emit);\n    adjust_stack(emit, -MP_OBJ_ITER_BUF_NSLOTS);\n    emit_post(emit);\n}\n\nstatic void emit_native_pop_except_jump(emit_t *emit, mp_uint_t label, bool within_exc_handler) {\n    if (within_exc_handler) {\n        \n        ASM_MOV_REG_IMM(emit->as, REG_TEMP0, (mp_uint_t)MP_OBJ_NULL);\n        ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_VAL(emit), REG_TEMP0);\n    } else {\n        emit_native_leave_exc_stack(emit, false);\n    }\n    emit_native_jump(emit, label);\n}\n\nstatic void emit_native_unary_op(emit_t *emit, mp_unary_op_t op) {\n    vtype_kind_t vtype = peek_vtype(emit, 0);\n    if (vtype == VTYPE_INT || vtype == VTYPE_UINT) {\n        if (op == MP_UNARY_OP_POSITIVE) {\n            \n        } else if (op == MP_UNARY_OP_NEGATIVE) {\n            int reg = REG_RET;\n            emit_pre_pop_reg_flexible(emit, &vtype, &reg, reg, reg);\n            ASM_NEG_REG(emit->as, reg);\n            emit_post_push_reg(emit, vtype, reg);\n        } else if (op == MP_UNARY_OP_INVERT) {\n            #ifdef ASM_NOT_REG\n            int reg = REG_RET;\n            emit_pre_pop_reg_flexible(emit, &vtype, &reg, reg, reg);\n            ASM_NOT_REG(emit->as, reg);\n            #else\n            int reg = REG_RET;\n            emit_pre_pop_reg_flexible(emit, &vtype, &reg, REG_ARG_1, reg);\n            ASM_MOV_REG_IMM(emit->as, REG_ARG_1, -1);\n            ASM_XOR_REG_REG(emit->as, reg, REG_ARG_1);\n            #endif\n            emit_post_push_reg(emit, vtype, reg);\n        } else {\n            EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                MP_ERROR_TEXT(\"'not' not implemented\"), mp_binary_op_method_name[op]);\n        }\n    } else if (vtype == VTYPE_PYOBJ) {\n        emit_pre_pop_reg(emit, &vtype, REG_ARG_2);\n        emit_call_with_imm_arg(emit, MP_F_UNARY_OP, op, REG_ARG_1);\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n    } else {\n        EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n            MP_ERROR_TEXT(\"can't do unary op of '%q'\"), vtype_to_qstr(vtype));\n    }\n}\n\nstatic void emit_native_binary_op(emit_t *emit, mp_binary_op_t op) {\n    DEBUG_printf(\"binary_op(\" UINT_FMT \")\\n\", op);\n    vtype_kind_t vtype_lhs = peek_vtype(emit, 1);\n    vtype_kind_t vtype_rhs = peek_vtype(emit, 0);\n    if ((vtype_lhs == VTYPE_INT || vtype_lhs == VTYPE_UINT)\n        && (vtype_rhs == VTYPE_INT || vtype_rhs == VTYPE_UINT)) {\n        \n        if (MP_BINARY_OP_INPLACE_OR <= op && op <= MP_BINARY_OP_INPLACE_POWER) {\n            op += MP_BINARY_OP_OR - MP_BINARY_OP_INPLACE_OR;\n        }\n\n        #if N_X64 || N_X86\n        \n        if (op == MP_BINARY_OP_LSHIFT || op == MP_BINARY_OP_RSHIFT) {\n            #if N_X64\n            emit_pre_pop_reg_reg(emit, &vtype_rhs, ASM_X64_REG_RCX, &vtype_lhs, REG_RET);\n            #else\n            emit_pre_pop_reg_reg(emit, &vtype_rhs, ASM_X86_REG_ECX, &vtype_lhs, REG_RET);\n            #endif\n            if (op == MP_BINARY_OP_LSHIFT) {\n                ASM_LSL_REG(emit->as, REG_RET);\n            } else {\n                if (vtype_lhs == VTYPE_UINT) {\n                    ASM_LSR_REG(emit->as, REG_RET);\n                } else {\n                    ASM_ASR_REG(emit->as, REG_RET);\n                }\n            }\n            emit_post_push_reg(emit, vtype_lhs, REG_RET);\n            return;\n        }\n        #endif\n\n        \n        if (op == MP_BINARY_OP_FLOOR_DIVIDE || op == MP_BINARY_OP_MODULO) {\n            emit_pre_pop_reg_reg(emit, &vtype_rhs, REG_ARG_2, &vtype_lhs, REG_ARG_1);\n            if (vtype_lhs != VTYPE_INT) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                    MP_ERROR_TEXT(\"div/mod not implemented for uint\"), mp_binary_op_method_name[op]);\n            }\n            if (op == MP_BINARY_OP_FLOOR_DIVIDE) {\n                emit_call(emit, MP_F_SMALL_INT_FLOOR_DIVIDE);\n            } else {\n                emit_call(emit, MP_F_SMALL_INT_MODULO);\n            }\n            emit_post_push_reg(emit, VTYPE_INT, REG_RET);\n            return;\n        }\n\n        int reg_rhs = REG_ARG_3;\n        emit_pre_pop_reg_flexible(emit, &vtype_rhs, &reg_rhs, REG_RET, REG_ARG_2);\n        emit_pre_pop_reg(emit, &vtype_lhs, REG_ARG_2);\n\n        #if !(N_X64 || N_X86)\n        if (op == MP_BINARY_OP_LSHIFT || op == MP_BINARY_OP_RSHIFT) {\n            if (op == MP_BINARY_OP_LSHIFT) {\n                ASM_LSL_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            } else {\n                if (vtype_lhs == VTYPE_UINT) {\n                    ASM_LSR_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n                } else {\n                    ASM_ASR_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n                }\n            }\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n            return;\n        }\n        #endif\n\n        if (op == MP_BINARY_OP_OR) {\n            ASM_OR_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n        } else if (op == MP_BINARY_OP_XOR) {\n            ASM_XOR_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n        } else if (op == MP_BINARY_OP_AND) {\n            ASM_AND_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n        } else if (op == MP_BINARY_OP_ADD) {\n            ASM_ADD_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n        } else if (op == MP_BINARY_OP_SUBTRACT) {\n            ASM_SUB_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n        } else if (op == MP_BINARY_OP_MULTIPLY) {\n            ASM_MUL_REG_REG(emit->as, REG_ARG_2, reg_rhs);\n            emit_post_push_reg(emit, vtype_lhs, REG_ARG_2);\n        } else if (op == MP_BINARY_OP_LESS\n                   || op == MP_BINARY_OP_MORE\n                   || op == MP_BINARY_OP_EQUAL\n                   || op == MP_BINARY_OP_LESS_EQUAL\n                   || op == MP_BINARY_OP_MORE_EQUAL\n                   || op == MP_BINARY_OP_NOT_EQUAL) {\n            \n\n            if (vtype_lhs != vtype_rhs) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit, MP_ERROR_TEXT(\"comparison of int and uint\"));\n            }\n\n            size_t op_idx = op - MP_BINARY_OP_LESS + (vtype_lhs == VTYPE_UINT ? 0 : 6);\n\n            need_reg_single(emit, REG_RET, 0);\n            #if N_X64\n            asm_x64_xor_r64_r64(emit->as, REG_RET, REG_RET);\n            asm_x64_cmp_r64_with_r64(emit->as, reg_rhs, REG_ARG_2);\n            static byte ops[6 + 6] = {\n                \n                ASM_X64_CC_JB,\n                ASM_X64_CC_JA,\n                ASM_X64_CC_JE,\n                ASM_X64_CC_JBE,\n                ASM_X64_CC_JAE,\n                ASM_X64_CC_JNE,\n                \n                ASM_X64_CC_JL,\n                ASM_X64_CC_JG,\n                ASM_X64_CC_JE,\n                ASM_X64_CC_JLE,\n                ASM_X64_CC_JGE,\n                ASM_X64_CC_JNE,\n            };\n            asm_x64_setcc_r8(emit->as, ops[op_idx], REG_RET);\n            #elif N_X86\n            asm_x86_xor_r32_r32(emit->as, REG_RET, REG_RET);\n            asm_x86_cmp_r32_with_r32(emit->as, reg_rhs, REG_ARG_2);\n            static byte ops[6 + 6] = {\n                \n                ASM_X86_CC_JB,\n                ASM_X86_CC_JA,\n                ASM_X86_CC_JE,\n                ASM_X86_CC_JBE,\n                ASM_X86_CC_JAE,\n                ASM_X86_CC_JNE,\n                \n                ASM_X86_CC_JL,\n                ASM_X86_CC_JG,\n                ASM_X86_CC_JE,\n                ASM_X86_CC_JLE,\n                ASM_X86_CC_JGE,\n                ASM_X86_CC_JNE,\n            };\n            asm_x86_setcc_r8(emit->as, ops[op_idx], REG_RET);\n            #elif N_THUMB\n            asm_thumb_cmp_rlo_rlo(emit->as, REG_ARG_2, reg_rhs);\n            if (asm_thumb_allow_armv7m(emit->as)) {\n                static uint16_t ops[6 + 6] = {\n                    \n                    ASM_THUMB_OP_ITE_CC,\n                    ASM_THUMB_OP_ITE_HI,\n                    ASM_THUMB_OP_ITE_EQ,\n                    ASM_THUMB_OP_ITE_LS,\n                    ASM_THUMB_OP_ITE_CS,\n                    ASM_THUMB_OP_ITE_NE,\n                    \n                    ASM_THUMB_OP_ITE_LT,\n                    ASM_THUMB_OP_ITE_GT,\n                    ASM_THUMB_OP_ITE_EQ,\n                    ASM_THUMB_OP_ITE_LE,\n                    ASM_THUMB_OP_ITE_GE,\n                    ASM_THUMB_OP_ITE_NE,\n                };\n                asm_thumb_op16(emit->as, ops[op_idx]);\n                asm_thumb_mov_rlo_i8(emit->as, REG_RET, 1);\n                asm_thumb_mov_rlo_i8(emit->as, REG_RET, 0);\n            } else {\n                static uint16_t ops[6 + 6] = {\n                    \n                    ASM_THUMB_CC_CC,\n                    ASM_THUMB_CC_HI,\n                    ASM_THUMB_CC_EQ,\n                    ASM_THUMB_CC_LS,\n                    ASM_THUMB_CC_CS,\n                    ASM_THUMB_CC_NE,\n                    \n                    ASM_THUMB_CC_LT,\n                    ASM_THUMB_CC_GT,\n                    ASM_THUMB_CC_EQ,\n                    ASM_THUMB_CC_LE,\n                    ASM_THUMB_CC_GE,\n                    ASM_THUMB_CC_NE,\n                };\n                asm_thumb_bcc_rel9(emit->as, ops[op_idx], 6);\n                asm_thumb_mov_rlo_i8(emit->as, REG_RET, 0);\n                asm_thumb_b_rel12(emit->as, 4);\n                asm_thumb_mov_rlo_i8(emit->as, REG_RET, 1);\n            }\n            #elif N_ARM\n            asm_arm_cmp_reg_reg(emit->as, REG_ARG_2, reg_rhs);\n            static uint ccs[6 + 6] = {\n                \n                ASM_ARM_CC_CC,\n                ASM_ARM_CC_HI,\n                ASM_ARM_CC_EQ,\n                ASM_ARM_CC_LS,\n                ASM_ARM_CC_CS,\n                ASM_ARM_CC_NE,\n                \n                ASM_ARM_CC_LT,\n                ASM_ARM_CC_GT,\n                ASM_ARM_CC_EQ,\n                ASM_ARM_CC_LE,\n                ASM_ARM_CC_GE,\n                ASM_ARM_CC_NE,\n            };\n            asm_arm_setcc_reg(emit->as, REG_RET, ccs[op_idx]);\n            #elif N_XTENSA || N_XTENSAWIN\n            static uint8_t ccs[6 + 6] = {\n                \n                ASM_XTENSA_CC_LTU,\n                0x80 | ASM_XTENSA_CC_LTU, \n                ASM_XTENSA_CC_EQ,\n                0x80 | ASM_XTENSA_CC_GEU, \n                ASM_XTENSA_CC_GEU,\n                ASM_XTENSA_CC_NE,\n                \n                ASM_XTENSA_CC_LT,\n                0x80 | ASM_XTENSA_CC_LT, \n                ASM_XTENSA_CC_EQ,\n                0x80 | ASM_XTENSA_CC_GE, \n                ASM_XTENSA_CC_GE,\n                ASM_XTENSA_CC_NE,\n            };\n            uint8_t cc = ccs[op_idx];\n            if ((cc & 0x80) == 0) {\n                asm_xtensa_setcc_reg_reg_reg(emit->as, cc, REG_RET, REG_ARG_2, reg_rhs);\n            } else {\n                asm_xtensa_setcc_reg_reg_reg(emit->as, cc & ~0x80, REG_RET, reg_rhs, REG_ARG_2);\n            }\n            #else\n            #error not implemented\n            #endif\n            emit_post_push_reg(emit, VTYPE_BOOL, REG_RET);\n        } else {\n            \n            adjust_stack(emit, 1);\n            EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                MP_ERROR_TEXT(\"binary op %q not implemented\"), mp_binary_op_method_name[op]);\n        }\n    } else if (vtype_lhs == VTYPE_PYOBJ && vtype_rhs == VTYPE_PYOBJ) {\n        emit_pre_pop_reg_reg(emit, &vtype_rhs, REG_ARG_3, &vtype_lhs, REG_ARG_2);\n        bool invert = false;\n        if (op == MP_BINARY_OP_NOT_IN) {\n            invert = true;\n            op = MP_BINARY_OP_IN;\n        } else if (op == MP_BINARY_OP_IS_NOT) {\n            invert = true;\n            op = MP_BINARY_OP_IS;\n        }\n        emit_call_with_imm_arg(emit, MP_F_BINARY_OP, op, REG_ARG_1);\n        if (invert) {\n            ASM_MOV_REG_REG(emit->as, REG_ARG_2, REG_RET);\n            emit_call_with_imm_arg(emit, MP_F_UNARY_OP, MP_UNARY_OP_NOT, REG_ARG_1);\n        }\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n    } else {\n        adjust_stack(emit, -1);\n        EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n            MP_ERROR_TEXT(\"can't do binary op between '%q' and '%q'\"),\n            vtype_to_qstr(vtype_lhs), vtype_to_qstr(vtype_rhs));\n    }\n}\n\n#if MICROPY_PY_BUILTINS_SLICE\nstatic void emit_native_build_slice(emit_t *emit, mp_uint_t n_args);\n#endif\n\nstatic void emit_native_build(emit_t *emit, mp_uint_t n_args, int kind) {\n    \n    \n    MP_STATIC_ASSERT(MP_F_BUILD_TUPLE + MP_EMIT_BUILD_TUPLE == MP_F_BUILD_TUPLE);\n    MP_STATIC_ASSERT(MP_F_BUILD_TUPLE + MP_EMIT_BUILD_LIST == MP_F_BUILD_LIST);\n    MP_STATIC_ASSERT(MP_F_BUILD_TUPLE + MP_EMIT_BUILD_MAP == MP_F_BUILD_MAP);\n    MP_STATIC_ASSERT(MP_F_BUILD_TUPLE + MP_EMIT_BUILD_SET == MP_F_BUILD_SET);\n    #if MICROPY_PY_BUILTINS_SLICE\n    if (kind == MP_EMIT_BUILD_SLICE) {\n        emit_native_build_slice(emit, n_args);\n        return;\n    }\n    #endif\n    emit_native_pre(emit);\n    if (kind == MP_EMIT_BUILD_TUPLE || kind == MP_EMIT_BUILD_LIST || kind == MP_EMIT_BUILD_SET) {\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_2, n_args); \n    }\n    emit_call_with_imm_arg(emit, MP_F_BUILD_TUPLE + kind, n_args, REG_ARG_1);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET); \n}\n\nstatic void emit_native_store_map(emit_t *emit) {\n    vtype_kind_t vtype_key, vtype_value, vtype_map;\n    emit_pre_pop_reg_reg_reg(emit, &vtype_key, REG_ARG_2, &vtype_value, REG_ARG_3, &vtype_map, REG_ARG_1); \n    assert(vtype_key == VTYPE_PYOBJ);\n    assert(vtype_value == VTYPE_PYOBJ);\n    assert(vtype_map == VTYPE_PYOBJ);\n    emit_call(emit, MP_F_STORE_MAP);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET); \n}\n\n#if MICROPY_PY_BUILTINS_SLICE\nstatic void emit_native_build_slice(emit_t *emit, mp_uint_t n_args) {\n    DEBUG_printf(\"build_slice %d\\n\", n_args);\n    if (n_args == 2) {\n        vtype_kind_t vtype_start, vtype_stop;\n        emit_pre_pop_reg_reg(emit, &vtype_stop, REG_ARG_2, &vtype_start, REG_ARG_1); \n        assert(vtype_start == VTYPE_PYOBJ);\n        assert(vtype_stop == VTYPE_PYOBJ);\n        emit_native_mov_reg_const(emit, REG_ARG_3, MP_F_CONST_NONE_OBJ); \n    } else {\n        assert(n_args == 3);\n        vtype_kind_t vtype_start, vtype_stop, vtype_step;\n        emit_pre_pop_reg_reg_reg(emit, &vtype_step, REG_ARG_3, &vtype_stop, REG_ARG_2, &vtype_start, REG_ARG_1); \n        assert(vtype_start == VTYPE_PYOBJ);\n        assert(vtype_stop == VTYPE_PYOBJ);\n        assert(vtype_step == VTYPE_PYOBJ);\n    }\n    emit_call(emit, MP_F_NEW_SLICE);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n#endif\n\nstatic void emit_native_store_comp(emit_t *emit, scope_kind_t kind, mp_uint_t collection_index) {\n    mp_fun_kind_t f;\n    if (kind == SCOPE_LIST_COMP) {\n        vtype_kind_t vtype_item;\n        emit_pre_pop_reg(emit, &vtype_item, REG_ARG_2);\n        assert(vtype_item == VTYPE_PYOBJ);\n        f = MP_F_LIST_APPEND;\n    #if MICROPY_PY_BUILTINS_SET\n    } else if (kind == SCOPE_SET_COMP) {\n        vtype_kind_t vtype_item;\n        emit_pre_pop_reg(emit, &vtype_item, REG_ARG_2);\n        assert(vtype_item == VTYPE_PYOBJ);\n        f = MP_F_STORE_SET;\n    #endif\n    } else {\n        \n        vtype_kind_t vtype_key, vtype_value;\n        emit_pre_pop_reg_reg(emit, &vtype_key, REG_ARG_2, &vtype_value, REG_ARG_3);\n        assert(vtype_key == VTYPE_PYOBJ);\n        assert(vtype_value == VTYPE_PYOBJ);\n        f = MP_F_STORE_MAP;\n    }\n    vtype_kind_t vtype_collection;\n    emit_access_stack(emit, collection_index, &vtype_collection, REG_ARG_1);\n    assert(vtype_collection == VTYPE_PYOBJ);\n    emit_call(emit, f);\n    emit_post(emit);\n}\n\nstatic void emit_native_unpack_sequence(emit_t *emit, mp_uint_t n_args) {\n    DEBUG_printf(\"unpack_sequence %d\\n\", n_args);\n    vtype_kind_t vtype_base;\n    emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1); \n    assert(vtype_base == VTYPE_PYOBJ);\n    emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, n_args); \n    emit_call_with_imm_arg(emit, MP_F_UNPACK_SEQUENCE, n_args, REG_ARG_2); \n}\n\nstatic void emit_native_unpack_ex(emit_t *emit, mp_uint_t n_left, mp_uint_t n_right) {\n    DEBUG_printf(\"unpack_ex %d %d\\n\", n_left, n_right);\n    vtype_kind_t vtype_base;\n    emit_pre_pop_reg(emit, &vtype_base, REG_ARG_1); \n    assert(vtype_base == VTYPE_PYOBJ);\n    emit_get_stack_pointer_to_reg_for_push(emit, REG_ARG_3, n_left + n_right + 1); \n    emit_call_with_imm_arg(emit, MP_F_UNPACK_EX, n_left | (n_right << 8), REG_ARG_2); \n}\n\nstatic void emit_native_make_function(emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {\n    \n    emit_native_pre(emit);\n    emit_native_mov_reg_state(emit, REG_ARG_2, LOCAL_IDX_FUN_OBJ(emit));\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_ARG_2, REG_ARG_2, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n    if (n_pos_defaults == 0 && n_kw_defaults == 0) {\n        need_reg_all(emit);\n        ASM_MOV_REG_IMM(emit->as, REG_ARG_3, 0);\n    } else {\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 2);\n        need_reg_all(emit);\n    }\n    emit_load_reg_with_child(emit, REG_ARG_1, scope->raw_code);\n    ASM_CALL_IND(emit->as, MP_F_MAKE_FUNCTION_FROM_PROTO_FUN);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_make_closure(emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {\n    \n    emit_native_pre(emit);\n    emit_native_mov_reg_state(emit, REG_ARG_2, LOCAL_IDX_FUN_OBJ(emit));\n    ASM_LOAD_REG_REG_OFFSET(emit->as, REG_ARG_2, REG_ARG_2, OFFSETOF_OBJ_FUN_BC_CONTEXT);\n    if (n_pos_defaults == 0 && n_kw_defaults == 0) {\n        need_reg_all(emit);\n        ASM_MOV_REG_IMM(emit->as, REG_ARG_3, 0);\n    } else {\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 2 + n_closed_over);\n        adjust_stack(emit, 2 + n_closed_over);\n        need_reg_all(emit);\n    }\n    emit_load_reg_with_child(emit, REG_ARG_1, scope->raw_code);\n    ASM_CALL_IND(emit->as, MP_F_MAKE_FUNCTION_FROM_PROTO_FUN);\n\n    \n    #if REG_ARG_1 != REG_RET\n    ASM_MOV_REG_REG(emit->as, REG_ARG_1, REG_RET);\n    #endif\n    ASM_MOV_REG_IMM(emit->as, REG_ARG_2, n_closed_over);\n    emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, n_closed_over);\n    if (n_pos_defaults != 0 || n_kw_defaults != 0) {\n        adjust_stack(emit, -2);\n    }\n    ASM_CALL_IND(emit->as, MP_F_NEW_CLOSURE);\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n}\n\nstatic void emit_native_call_function(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {\n    DEBUG_printf(\"call_function(n_pos=\" UINT_FMT \", n_kw=\" UINT_FMT \", star_flags=\" UINT_FMT \")\\n\", n_positional, n_keyword, star_flags);\n\n    \n    \n\n    emit_native_pre(emit);\n    vtype_kind_t vtype_fun = peek_vtype(emit, n_positional + 2 * n_keyword);\n    if (vtype_fun == VTYPE_BUILTIN_CAST) {\n        \n        assert(n_positional == 1 && n_keyword == 0);\n        assert(!star_flags);\n        DEBUG_printf(\"  cast to %d\\n\", vtype_fun);\n        vtype_kind_t vtype_cast = peek_stack(emit, 1)->data.u_imm;\n        switch (peek_vtype(emit, 0)) {\n            case VTYPE_PYOBJ: {\n                vtype_kind_t vtype;\n                emit_pre_pop_reg(emit, &vtype, REG_ARG_1);\n                emit_pre_pop_discard(emit);\n                emit_call_with_imm_arg(emit, MP_F_CONVERT_OBJ_TO_NATIVE, vtype_cast, REG_ARG_2); \n                emit_post_push_reg(emit, vtype_cast, REG_RET);\n                break;\n            }\n            case VTYPE_BOOL:\n            case VTYPE_INT:\n            case VTYPE_UINT:\n            case VTYPE_PTR:\n            case VTYPE_PTR8:\n            case VTYPE_PTR16:\n            case VTYPE_PTR32:\n            case VTYPE_PTR_NONE:\n                emit_fold_stack_top(emit, REG_ARG_1);\n                emit_post_top_set_vtype(emit, vtype_cast);\n                break;\n            default:\n                \n                mp_raise_NotImplementedError(MP_ERROR_TEXT(\"casting\"));\n        }\n    } else {\n        assert(vtype_fun == VTYPE_PYOBJ);\n        if (star_flags) {\n            emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, n_positional + 2 * n_keyword + 2); \n            emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW_VAR, 0, REG_ARG_1, n_positional | (n_keyword << 8), REG_ARG_2);\n            emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n        } else {\n            if (n_positional != 0 || n_keyword != 0) {\n                emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, n_positional + 2 * n_keyword); \n            }\n            emit_pre_pop_reg(emit, &vtype_fun, REG_ARG_1); \n            emit_call_with_imm_arg(emit, MP_F_NATIVE_CALL_FUNCTION_N_KW, n_positional | (n_keyword << 8), REG_ARG_2);\n            emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n        }\n    }\n}\n\nstatic void emit_native_call_method(emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {\n    if (star_flags) {\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, n_positional + 2 * n_keyword + 3); \n        emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW_VAR, 1, REG_ARG_1, n_positional | (n_keyword << 8), REG_ARG_2);\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n    } else {\n        emit_native_pre(emit);\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 2 + n_positional + 2 * n_keyword); \n        emit_call_with_2_imm_args(emit, MP_F_CALL_METHOD_N_KW, n_positional, REG_ARG_1, n_keyword, REG_ARG_2);\n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_RET);\n    }\n}\n\nstatic void emit_native_return_value(emit_t *emit) {\n    DEBUG_printf(\"return_value\\n\");\n\n    if (emit->scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n        \n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_TEMP0, 1);\n        emit_native_mov_state_reg(emit, OFFSETOF_CODE_STATE_SP, REG_TEMP0);\n\n        \n        ASM_MOV_REG_IMM(emit->as, REG_TEMP0, MP_VM_RETURN_NORMAL);\n        ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_RET_VAL(emit), REG_TEMP0);\n\n        \n        emit_native_unwind_jump(emit, emit->exit_label, emit->exc_stack_size);\n        return;\n    }\n\n    if (emit->do_viper_types) {\n        vtype_kind_t return_vtype = emit->scope->scope_flags >> MP_SCOPE_FLAG_VIPERRET_POS;\n        if (peek_vtype(emit, 0) == VTYPE_PTR_NONE) {\n            emit_pre_pop_discard(emit);\n            if (return_vtype == VTYPE_PYOBJ) {\n                emit_native_mov_reg_const(emit, REG_PARENT_RET, MP_F_CONST_NONE_OBJ);\n            } else {\n                ASM_MOV_REG_IMM(emit->as, REG_ARG_1, 0);\n            }\n        } else {\n            vtype_kind_t vtype;\n            emit_pre_pop_reg(emit, &vtype, return_vtype == VTYPE_PYOBJ ? REG_PARENT_RET : REG_ARG_1);\n            if (vtype != return_vtype) {\n                EMIT_NATIVE_VIPER_TYPE_ERROR(emit,\n                    MP_ERROR_TEXT(\"return expected '%q' but got '%q'\"),\n                    vtype_to_qstr(return_vtype), vtype_to_qstr(vtype));\n            }\n        }\n        if (return_vtype != VTYPE_PYOBJ) {\n            emit_call_with_imm_arg(emit, MP_F_CONVERT_NATIVE_TO_OBJ, return_vtype, REG_ARG_2);\n            #if REG_RET != REG_PARENT_RET\n            ASM_MOV_REG_REG(emit->as, REG_PARENT_RET, REG_RET);\n            #endif\n        }\n    } else {\n        vtype_kind_t vtype;\n        emit_pre_pop_reg(emit, &vtype, REG_PARENT_RET);\n        assert(vtype == VTYPE_PYOBJ);\n    }\n    if (NEED_GLOBAL_EXC_HANDLER(emit)) {\n        \n        ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_RET_VAL(emit), REG_PARENT_RET);\n    }\n    emit_native_unwind_jump(emit, emit->exit_label, emit->exc_stack_size);\n}\n\nstatic void emit_native_raise_varargs(emit_t *emit, mp_uint_t n_args) {\n    (void)n_args;\n    assert(n_args == 1);\n    vtype_kind_t vtype_exc;\n    emit_pre_pop_reg(emit, &vtype_exc, REG_ARG_1); \n    if (vtype_exc != VTYPE_PYOBJ) {\n        EMIT_NATIVE_VIPER_TYPE_ERROR(emit, MP_ERROR_TEXT(\"must raise an object\"));\n    }\n    \n    emit_call(emit, MP_F_NATIVE_RAISE);\n    mp_asm_base_suppress_code(&emit->as->base);\n}\n\nstatic void emit_native_yield(emit_t *emit, int kind) {\n    \n\n    if (emit->do_viper_types) {\n        mp_raise_NotImplementedError(MP_ERROR_TEXT(\"native yield\"));\n    }\n    emit->scope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;\n\n    need_stack_settled(emit);\n\n    if (kind == MP_EMIT_YIELD_FROM) {\n\n        \n        \n        \n\n        \n        emit_native_jump(emit, *emit->label_slot + 2);\n\n        \n        emit_native_label_assign(emit, *emit->label_slot + 1);\n    }\n\n    \n    emit_get_stack_pointer_to_reg_for_pop(emit, REG_TEMP0, 1);\n    emit_native_mov_state_reg(emit, OFFSETOF_CODE_STATE_SP, REG_TEMP0);\n\n    \n    ASM_MOV_REG_IMM(emit->as, REG_TEMP0, MP_VM_RETURN_YIELD);\n    ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_RET_VAL(emit), REG_TEMP0);\n\n    \n    ASM_MOV_REG_PCREL(emit->as, REG_TEMP0, *emit->label_slot);\n    emit_native_mov_state_reg(emit, LOCAL_IDX_GEN_PC(emit), REG_TEMP0);\n\n    \n    ASM_JUMP(emit->as, emit->exit_label);\n\n    \n    mp_asm_base_label_assign(&emit->as->base, *emit->label_slot);\n\n    \n    if (emit->exc_stack_size > 0) {\n        \n        exc_stack_entry_t *e = &emit->exc_stack[emit->exc_stack_size - 1];\n        for (; e >= emit->exc_stack; --e) {\n            if (e->is_active) {\n                \n                ASM_MOV_REG_PCREL(emit->as, REG_RET, e->label);\n                ASM_MOV_LOCAL_REG(emit->as, LOCAL_IDX_EXC_HANDLER_PC(emit), REG_RET);\n                break;\n            }\n        }\n    }\n\n    emit_native_adjust_stack_size(emit, 1); \n\n    if (kind == MP_EMIT_YIELD_VALUE) {\n        \n        ASM_MOV_REG_LOCAL(emit->as, REG_ARG_1, LOCAL_IDX_EXC_VAL(emit));\n        emit_call(emit, MP_F_NATIVE_RAISE);\n    } else {\n        \n        emit_native_label_assign(emit, *emit->label_slot + 2);\n\n        \n        vtype_kind_t vtype;\n        emit_pre_pop_reg(emit, &vtype, REG_ARG_2); \n        emit_access_stack(emit, 1, &vtype, REG_ARG_1); \n        ASM_MOV_REG_LOCAL(emit->as, REG_ARG_3, LOCAL_IDX_EXC_VAL(emit)); \n        emit_post_push_reg(emit, VTYPE_PYOBJ, REG_ARG_3);\n        emit_get_stack_pointer_to_reg_for_pop(emit, REG_ARG_3, 1); \n        emit_call(emit, MP_F_NATIVE_YIELD_FROM);\n\n        \n        ASM_JUMP_IF_REG_NONZERO(emit->as, REG_RET, *emit->label_slot + 1, true);\n\n        \n        emit_native_adjust_stack_size(emit, 1); \n        emit_fold_stack_top(emit, REG_ARG_1);\n    }\n}\n\nstatic void emit_native_start_except_handler(emit_t *emit) {\n    \n    emit_native_leave_exc_stack(emit, true);\n\n    \n    ASM_MOV_REG_LOCAL(emit->as, REG_TEMP0, LOCAL_IDX_EXC_VAL(emit));\n    emit_post_push_reg(emit, VTYPE_PYOBJ, REG_TEMP0);\n}\n\nstatic void emit_native_end_except_handler(emit_t *emit) {\n    adjust_stack(emit, -1); \n}\n\nconst emit_method_table_t EXPORT_FUN(method_table) = {\n    #if MICROPY_DYNAMIC_COMPILER\n    EXPORT_FUN(new),\n    EXPORT_FUN(free),\n    #endif\n\n    emit_native_start_pass,\n    emit_native_end_pass,\n    emit_native_adjust_stack_size,\n    emit_native_set_source_line,\n\n    {\n        emit_native_load_local,\n        emit_native_load_global,\n    },\n    {\n        emit_native_store_local,\n        emit_native_store_global,\n    },\n    {\n        emit_native_delete_local,\n        emit_native_delete_global,\n    },\n\n    emit_native_label_assign,\n    emit_native_import,\n    emit_native_load_const_tok,\n    emit_native_load_const_small_int,\n    emit_native_load_const_str,\n    emit_native_load_const_obj,\n    emit_native_load_null,\n    emit_native_load_method,\n    emit_native_load_build_class,\n    emit_native_subscr,\n    emit_native_attr,\n    emit_native_dup_top,\n    emit_native_dup_top_two,\n    emit_native_pop_top,\n    emit_native_rot_two,\n    emit_native_rot_three,\n    emit_native_jump,\n    emit_native_pop_jump_if,\n    emit_native_jump_if_or_pop,\n    emit_native_unwind_jump,\n    emit_native_setup_block,\n    emit_native_with_cleanup,\n    emit_native_end_finally,\n    emit_native_get_iter,\n    emit_native_for_iter,\n    emit_native_for_iter_end,\n    emit_native_pop_except_jump,\n    emit_native_unary_op,\n    emit_native_binary_op,\n    emit_native_build,\n    emit_native_store_map,\n    emit_native_store_comp,\n    emit_native_unpack_sequence,\n    emit_native_unpack_ex,\n    emit_native_make_function,\n    emit_native_make_closure,\n    emit_native_call_function,\n    emit_native_call_method,\n    emit_native_return_value,\n    emit_native_raise_varargs,\n    emit_native_yield,\n\n    emit_native_start_except_handler,\n    emit_native_end_except_handler,\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}