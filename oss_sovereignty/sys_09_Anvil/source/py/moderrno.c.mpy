{
  "module_name": "moderrno.c",
  "hash_id": "aea0857ba3496e409acb863a47bb89734a21c6a6209b4122795b0e90bbaafda6",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/moderrno.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <string.h>\n\n#include \"py/obj.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_PY_ERRNO\n\n\n\n#ifndef MICROPY_PY_ERRNO_LIST\n#define MICROPY_PY_ERRNO_LIST \\\n    X(EPERM) \\\n    X(ENOENT) \\\n    X(EIO) \\\n    X(EBADF) \\\n    X(EAGAIN) \\\n    X(ENOMEM) \\\n    X(EACCES) \\\n    X(EEXIST) \\\n    X(ENODEV) \\\n    X(EISDIR) \\\n    X(EINVAL) \\\n    X(EOPNOTSUPP) \\\n    X(EADDRINUSE) \\\n    X(ECONNABORTED) \\\n    X(ECONNRESET) \\\n    X(ENOBUFS) \\\n    X(ENOTCONN) \\\n    X(ETIMEDOUT) \\\n    X(ECONNREFUSED) \\\n    X(EHOSTUNREACH) \\\n    X(EALREADY) \\\n    X(EINPROGRESS) \\\n\n#endif\n\n#if MICROPY_PY_ERRNO_ERRORCODE\nstatic const mp_rom_map_elem_t errorcode_table[] = {\n    #define X(e) { MP_ROM_INT(MP_##e), MP_ROM_QSTR(MP_QSTR_##e) },\n    MICROPY_PY_ERRNO_LIST\n#undef X\n};\n\nstatic const mp_obj_dict_t errorcode_dict = {\n    .base = {&mp_type_dict},\n    .map = {\n        .all_keys_are_qstrs = 0, \n        .is_fixed = 1,\n        .is_ordered = 1,\n        .used = MP_ARRAY_SIZE(errorcode_table),\n        .alloc = MP_ARRAY_SIZE(errorcode_table),\n        .table = (mp_map_elem_t *)(mp_rom_map_elem_t *)errorcode_table,\n    },\n};\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_errno_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_errno) },\n    #if MICROPY_PY_ERRNO_ERRORCODE\n    { MP_ROM_QSTR(MP_QSTR_errorcode), MP_ROM_PTR(&errorcode_dict) },\n    #endif\n\n    #define X(e) { MP_ROM_QSTR(MP_QSTR_##e), MP_ROM_INT(MP_##e) },\n    MICROPY_PY_ERRNO_LIST\n#undef X\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_errno_globals, mp_module_errno_globals_table);\n\nconst mp_obj_module_t mp_module_errno = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_errno_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_errno, mp_module_errno);\n\nqstr mp_errno_to_str(mp_obj_t errno_val) {\n    #if MICROPY_PY_ERRNO_ERRORCODE\n    \n    mp_map_elem_t *elem = mp_map_lookup((mp_map_t *)&errorcode_dict.map, errno_val, MP_MAP_LOOKUP);\n    if (elem == NULL) {\n        return MP_QSTRnull;\n    } else {\n        return MP_OBJ_QSTR_VALUE(elem->value);\n    }\n    #else\n    \n    for (size_t i = 0; i < MP_ARRAY_SIZE(mp_module_errno_globals_table); ++i) {\n        if (errno_val == mp_module_errno_globals_table[i].value) {\n            return MP_OBJ_QSTR_VALUE(mp_module_errno_globals_table[i].key);\n        }\n    }\n    return MP_QSTRnull;\n    #endif\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}