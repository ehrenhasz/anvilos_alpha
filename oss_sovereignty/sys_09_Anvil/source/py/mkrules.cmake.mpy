{
  "module_name": "mkrules.cmake",
  "hash_id": "f10e6240ec64a054aa27d9664502beb0656cb5c07760fcea54a084097893eea8",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/mkrules.cmake",
  "human_readable_source": "# CMake fragment for MicroPython rules\n\nset(MICROPY_GENHDR_DIR \"${CMAKE_BINARY_DIR}/genhdr\")\nset(MICROPY_MPVERSION \"${MICROPY_GENHDR_DIR}/mpversion.h\")\nset(MICROPY_QSTRDEFS_PY \"${MICROPY_PY_DIR}/qstrdefs.h\")\nset(MICROPY_QSTRDEFS_LAST \"${MICROPY_GENHDR_DIR}/qstr.i.last\")\nset(MICROPY_QSTRDEFS_SPLIT \"${MICROPY_GENHDR_DIR}/qstr.split\")\nset(MICROPY_QSTRDEFS_COLLECTED \"${MICROPY_GENHDR_DIR}/qstrdefs.collected.h\")\nset(MICROPY_QSTRDEFS_PREPROCESSED \"${MICROPY_GENHDR_DIR}/qstrdefs.preprocessed.h\")\nset(MICROPY_QSTRDEFS_GENERATED \"${MICROPY_GENHDR_DIR}/qstrdefs.generated.h\")\nset(MICROPY_MODULEDEFS_SPLIT \"${MICROPY_GENHDR_DIR}/moduledefs.split\")\nset(MICROPY_MODULEDEFS_COLLECTED \"${MICROPY_GENHDR_DIR}/moduledefs.collected\")\nset(MICROPY_MODULEDEFS \"${MICROPY_GENHDR_DIR}/moduledefs.h\")\nset(MICROPY_ROOT_POINTERS_SPLIT \"${MICROPY_GENHDR_DIR}/root_pointers.split\")\nset(MICROPY_ROOT_POINTERS_COLLECTED \"${MICROPY_GENHDR_DIR}/root_pointers.collected\")\nset(MICROPY_ROOT_POINTERS \"${MICROPY_GENHDR_DIR}/root_pointers.h\")\n\nif(NOT MICROPY_PREVIEW_VERSION_2)\n    set(MICROPY_PREVIEW_VERSION_2 0)\nendif()\n\n# Need to do this before extracting MICROPY_CPP_DEF below. Rest of frozen\n# manifest handling is at the end of this file.\nif(MICROPY_FROZEN_MANIFEST)\n    target_compile_definitions(${MICROPY_TARGET} PUBLIC\n        MICROPY_QSTR_EXTRA_POOL=mp_qstr_frozen_const_pool\n        MICROPY_MODULE_FROZEN_MPY=\\(1\\)\n    )\nendif()\n\nif(MICROPY_PREVIEW_VERSION_2)\n    target_compile_definitions(${MICROPY_TARGET} PUBLIC\n        MICROPY_PREVIEW_VERSION_2=\\(1\\)\n    )\nendif()\n\n# Provide defaults for preprocessor flags if not already defined\nif(NOT MICROPY_CPP_FLAGS)\n    get_target_property(MICROPY_CPP_INC ${MICROPY_TARGET} INCLUDE_DIRECTORIES)\n    get_target_property(MICROPY_CPP_DEF ${MICROPY_TARGET} COMPILE_DEFINITIONS)\nendif()\n\n# Compute MICROPY_CPP_FLAGS for preprocessor\nlist(APPEND MICROPY_CPP_INC ${MICROPY_CPP_INC_EXTRA})\nlist(APPEND MICROPY_CPP_DEF ${MICROPY_CPP_DEF_EXTRA})\nset(_prefix \"-I\")\nforeach(_arg ${MICROPY_CPP_INC})\n    list(APPEND MICROPY_CPP_FLAGS ${_prefix}${_arg})\nendforeach()\nset(_prefix \"-D\")\nforeach(_arg ${MICROPY_CPP_DEF})\n    list(APPEND MICROPY_CPP_FLAGS ${_prefix}${_arg})\nendforeach()\nlist(APPEND MICROPY_CPP_FLAGS ${MICROPY_CPP_FLAGS_EXTRA})\n\nfind_package(Python3 REQUIRED COMPONENTS Interpreter)\n\ntarget_sources(${MICROPY_TARGET} PRIVATE\n    ${MICROPY_MPVERSION}\n    ${MICROPY_QSTRDEFS_GENERATED}\n    ${MICROPY_MODULEDEFS}\n    ${MICROPY_ROOT_POINTERS}\n)\n\n# Command to force the build of another command\n\n# Generate mpversion.h\n\nadd_custom_target(\n    BUILD_VERSION_HEADER ALL\n    BYPRODUCTS ${MICROPY_MPVERSION}\n    COMMAND ${CMAKE_COMMAND} -E make_directory ${MICROPY_GENHDR_DIR}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_DIR}/py/makeversionhdr.py ${MICROPY_MPVERSION}\n)\n\n# Generate qstrs\n\n# If any of the dependencies in this rule change then the C-preprocessor step must be run.\n# It only needs to be passed the list of MICROPY_SOURCE_QSTR files that have changed since\n# it was last run, but it looks like it's not possible to specify that with cmake.\nadd_custom_command(\n    OUTPUT ${MICROPY_QSTRDEFS_LAST}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py pp ${CMAKE_C_COMPILER} -E output ${MICROPY_GENHDR_DIR}/qstr.i.last cflags ${MICROPY_CPP_FLAGS} -DNO_QSTR cxxflags ${MICROPY_CPP_FLAGS} -DNO_QSTR sources ${MICROPY_SOURCE_QSTR}\n    DEPENDS ${MICROPY_MPVERSION}\n        ${MICROPY_SOURCE_QSTR}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_QSTRDEFS_SPLIT}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py split qstr ${MICROPY_GENHDR_DIR}/qstr.i.last ${MICROPY_GENHDR_DIR}/qstr _\n    COMMAND touch ${MICROPY_QSTRDEFS_SPLIT}\n    DEPENDS ${MICROPY_QSTRDEFS_LAST}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_QSTRDEFS_COLLECTED}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py cat qstr _ ${MICROPY_GENHDR_DIR}/qstr ${MICROPY_QSTRDEFS_COLLECTED}\n    BYPRODUCTS \"${MICROPY_QSTRDEFS_COLLECTED}.hash\"\n    DEPENDS ${MICROPY_QSTRDEFS_SPLIT}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_QSTRDEFS_PREPROCESSED}\n    COMMAND cat ${MICROPY_QSTRDEFS_PY} ${MICROPY_QSTRDEFS_PORT} ${MICROPY_QSTRDEFS_COLLECTED} | sed \"s/^Q(.*)/\\\"&\\\"/\" | ${CMAKE_C_COMPILER} -E ${MICROPY_CPP_FLAGS} - | sed \"s/^\\\\\\\"\\\\(Q(.*)\\\\)\\\\\\\"/\\\\1/\" > ${MICROPY_QSTRDEFS_PREPROCESSED}\n    DEPENDS ${MICROPY_QSTRDEFS_PY}\n        ${MICROPY_QSTRDEFS_PORT}\n        ${MICROPY_QSTRDEFS_COLLECTED}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_QSTRDEFS_GENERATED}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdata.py ${MICROPY_QSTRDEFS_PREPROCESSED} > ${MICROPY_QSTRDEFS_GENERATED}\n    DEPENDS ${MICROPY_QSTRDEFS_PREPROCESSED}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\n# Generate moduledefs.h\n\nadd_custom_command(\n    OUTPUT ${MICROPY_MODULEDEFS_SPLIT}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py split module ${MICROPY_GENHDR_DIR}/qstr.i.last ${MICROPY_GENHDR_DIR}/module _\n    COMMAND touch ${MICROPY_MODULEDEFS_SPLIT}\n    DEPENDS ${MICROPY_QSTRDEFS_LAST}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_MODULEDEFS_COLLECTED}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py cat module _ ${MICROPY_GENHDR_DIR}/module ${MICROPY_MODULEDEFS_COLLECTED}\n    BYPRODUCTS \"${MICROPY_MODULEDEFS_COLLECTED}.hash\"\n    DEPENDS ${MICROPY_MODULEDEFS_SPLIT}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_MODULEDEFS}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makemoduledefs.py ${MICROPY_MODULEDEFS_COLLECTED} > ${MICROPY_MODULEDEFS}\n    DEPENDS ${MICROPY_MODULEDEFS_COLLECTED}\n)\n\n# Generate root_pointers.h\n\nadd_custom_command(\n    OUTPUT ${MICROPY_ROOT_POINTERS_SPLIT}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py split root_pointer ${MICROPY_GENHDR_DIR}/qstr.i.last ${MICROPY_GENHDR_DIR}/root_pointer _\n    COMMAND touch ${MICROPY_ROOT_POINTERS_SPLIT}\n    DEPENDS ${MICROPY_QSTRDEFS_LAST}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_ROOT_POINTERS_COLLECTED}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/makeqstrdefs.py cat root_pointer _ ${MICROPY_GENHDR_DIR}/root_pointer ${MICROPY_ROOT_POINTERS_COLLECTED}\n    BYPRODUCTS \"${MICROPY_ROOT_POINTERS_COLLECTED}.hash\"\n    DEPENDS ${MICROPY_ROOT_POINTERS_SPLIT}\n    VERBATIM\n    COMMAND_EXPAND_LISTS\n)\n\nadd_custom_command(\n    OUTPUT ${MICROPY_ROOT_POINTERS}\n    COMMAND ${Python3_EXECUTABLE} ${MICROPY_PY_DIR}/make_root_pointers.py ${MICROPY_ROOT_POINTERS_COLLECTED} > ${MICROPY_ROOT_POINTERS}\n    DEPENDS ${MICROPY_ROOT_POINTERS_COLLECTED} ${MICROPY_PY_DIR}/make_root_pointers.py\n)\n\n# Build frozen code if enabled\n\nif(MICROPY_FROZEN_MANIFEST)\n    set(MICROPY_FROZEN_CONTENT \"${CMAKE_BINARY_DIR}/frozen_content.c\")\n\n    target_sources(${MICROPY_TARGET} PRIVATE\n        ${MICROPY_FROZEN_CONTENT}\n    )\n\n    # Note: target_compile_definitions already added earlier.\n\n    if(NOT MICROPY_LIB_DIR)\n        string(CONCAT GIT_SUBMODULES \"${GIT_SUBMODULES} \" lib/micropython-lib)\n        set(MICROPY_LIB_DIR ${MICROPY_DIR}/lib/micropython-lib)\n    endif()\n\n    if(ECHO_SUBMODULES)\n        # No-op, we're just doing submodule/variant discovery.\n        # Note: All the following rules are safe to run in discovery mode even\n        # though the submodule might not be available as they do not directly depend\n        # on anything from the submodule.\n    elseif(NOT EXISTS ${MICROPY_LIB_DIR}/README.md)\n        message(FATAL_ERROR \" micropython-lib not initialized.\\n Run 'make BOARD=${MICROPY_BOARD} submodules'\")\n    endif()\n\n    # If MICROPY_MPYCROSS is not explicitly defined in the environment (which\n    # is what makemanifest.py will use) then create an mpy-cross dependency\n    # to automatically build mpy-cross if needed.\n    set(MICROPY_MPYCROSS $ENV{MICROPY_MPYCROSS})\n    if(NOT MICROPY_MPYCROSS)\n        set(MICROPY_MPYCROSS_DEPENDENCY ${MICROPY_DIR}/mpy-cross/build/mpy-cross)\n        if(NOT MICROPY_MAKE_EXECUTABLE)\n            set(MICROPY_MAKE_EXECUTABLE make)\n        endif()\n        add_custom_command(\n            OUTPUT ${MICROPY_MPYCROSS_DEPENDENCY}\n            COMMAND ${MICROPY_MAKE_EXECUTABLE} -C ${MICROPY_DIR}/mpy-cross\n        )\n    endif()\n\n    if(NOT MICROPY_CROSS_FLAGS)\n        set(MICROPY_CROSS_FLAGS \"\")\n    else()\n        set(MICROPY_CROSS_FLAGS \"-f${MICROPY_CROSS_FLAGS}\")\n    endif()\n\n    # Set default path variables to be passed to makemanifest.py. These will\n    # be available in path substitutions. Additional variables can be set\n    # per-board in mpconfigboard.cmake.\n    set(MICROPY_MANIFEST_PORT_DIR ${MICROPY_PORT_DIR})\n    set(MICROPY_MANIFEST_BOARD_DIR ${MICROPY_BOARD_DIR})\n    set(MICROPY_MANIFEST_MPY_DIR ${MICROPY_DIR})\n    set(MICROPY_MANIFEST_MPY_LIB_DIR ${MICROPY_LIB_DIR})\n\n    # Find all MICROPY_MANIFEST_* variables and turn them into command line arguments.\n    get_cmake_property(_manifest_vars VARIABLES)\n    list(FILTER _manifest_vars INCLUDE REGEX \"MICROPY_MANIFEST_.*\")\n    foreach(_manifest_var IN LISTS _manifest_vars)\n        list(APPEND _manifest_var_args \"-v\")\n        string(REGEX REPLACE \"MICROPY_MANIFEST_(.*)\" \"\\\\1\" _manifest_var_name ${_manifest_var})\n        list(APPEND _manifest_var_args \"${_manifest_var_name}=${${_manifest_var}}\")\n    endforeach()\n\n    add_custom_target(\n        BUILD_FROZEN_CONTENT ALL\n        BYPRODUCTS ${MICROPY_FROZEN_CONTENT}\n        COMMAND ${Python3_EXECUTABLE} ${MICROPY_DIR}/tools/makemanifest.py -o ${MICROPY_FROZEN_CONTENT} ${_manifest_var_args} -b \"${CMAKE_BINARY_DIR}\" ${MICROPY_CROSS_FLAGS} --mpy-tool-flags=${MICROPY_MPY_TOOL_FLAGS} ${MICROPY_FROZEN_MANIFEST}\n        DEPENDS\n            ${MICROPY_QSTRDEFS_GENERATED}\n            ${MICROPY_ROOT_POINTERS}\n            ${MICROPY_MPYCROSS_DEPENDENCY}\n        VERBATIM\n    )\nendif()\n\n# Update submodules\nif(ECHO_SUBMODULES)\n    # If cmake is run with GIT_SUBMODULES defined on command line, process the port / board\n    # settings then print the final GIT_SUBMODULES variable and exit.\n    # Note: the GIT_SUBMODULES is done via echo rather than message, as message splits\n    # the output onto multiple lines\n    execute_process(COMMAND ${CMAKE_COMMAND} -E echo \"GIT_SUBMODULES=${GIT_SUBMODULES}\")\n    message(FATAL_ERROR \"Done\")\nendif()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}