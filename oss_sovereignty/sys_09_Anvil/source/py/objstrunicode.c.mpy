{
  "module_name": "objstrunicode.c",
  "hash_id": "f00feb77c5e53c02378a03f101dc67c785e7576340bcbd0a3b06217b06e864e3",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objstrunicode.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/objstr.h\"\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_PY_BUILTINS_STR_UNICODE\n\nstatic mp_obj_t mp_obj_new_str_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf);\n\n \n \n\nstatic void uni_print_quoted(const mp_print_t *print, const byte *str_data, uint str_len) {\n    \n    bool has_single_quote = false;\n    bool has_double_quote = false;\n    for (const byte *s = str_data, *top = str_data + str_len; !has_double_quote && s < top; s++) {\n        if (*s == '\\'') {\n            has_single_quote = true;\n        } else if (*s == '\"') {\n            has_double_quote = true;\n        }\n    }\n    unichar quote_char = '\\'';\n    if (has_single_quote && !has_double_quote) {\n        quote_char = '\"';\n    }\n    mp_printf(print, \"%c\", quote_char);\n    const byte *s = str_data, *top = str_data + str_len;\n    while (s < top) {\n        unichar ch;\n        ch = utf8_get_char(s);\n        s = utf8_next_char(s);\n        if (ch == quote_char) {\n            mp_printf(print, \"\\\\%c\", quote_char);\n        } else if (ch == '\\\\') {\n            mp_print_str(print, \"\\\\\\\\\");\n        } else if (32 <= ch && ch <= 126) {\n            mp_printf(print, \"%c\", ch);\n        } else if (ch == '\\n') {\n            mp_print_str(print, \"\\\\n\");\n        } else if (ch == '\\r') {\n            mp_print_str(print, \"\\\\r\");\n        } else if (ch == '\\t') {\n            mp_print_str(print, \"\\\\t\");\n        } else if (ch < 0x100) {\n            mp_printf(print, \"\\\\x%02x\", ch);\n        } else if (ch < 0x10000) {\n            mp_printf(print, \"\\\\u%04x\", ch);\n        } else {\n            mp_printf(print, \"\\\\U%08x\", ch);\n        }\n    }\n    mp_printf(print, \"%c\", quote_char);\n}\n\nstatic void uni_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    GET_STR_DATA_LEN(self_in, str_data, str_len);\n    #if MICROPY_PY_JSON\n    if (kind == PRINT_JSON) {\n        mp_str_print_json(print, str_data, str_len);\n        return;\n    }\n    #endif\n    if (kind == PRINT_STR) {\n        print->print_strn(print->data, (const char *)str_data, str_len);\n    } else {\n        uni_print_quoted(print, str_data, str_len);\n    }\n}\n\nstatic mp_obj_t uni_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    GET_STR_DATA_LEN(self_in, str_data, str_len);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(str_len != 0);\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(utf8_charlen(str_data, str_len));\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\n\n\nconst byte *str_index_to_ptr(const mp_obj_type_t *type, const byte *self_data, size_t self_len,\n    mp_obj_t index, bool is_slice) {\n    \n    \n    if (type == &mp_type_bytes\n        #if MICROPY_PY_BUILTINS_BYTEARRAY\n        || type == &mp_type_bytearray\n        #endif\n        ) {\n        \n        size_t index_val = mp_get_index(type, self_len, index, is_slice);\n        return self_data + index_val;\n    }\n\n    mp_int_t i;\n    \n    \n    \n    if (mp_obj_is_small_int(index)) {\n        i = MP_OBJ_SMALL_INT_VALUE(index);\n    } else if (!mp_obj_get_int_maybe(index, &i)) {\n        mp_raise_msg_varg(&mp_type_TypeError, MP_ERROR_TEXT(\"string indices must be integers, not %s\"), mp_obj_get_type_str(index));\n    }\n    const byte *s, *top = self_data + self_len;\n    if (i < 0) {\n        \n        for (s = top - 1; i; --s) {\n            if (s < self_data) {\n                if (is_slice) {\n                    return self_data;\n                }\n                mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"string index out of range\"));\n            }\n            if (!UTF8_IS_CONT(*s)) {\n                ++i;\n            }\n        }\n        ++s;\n    } else {\n        \n        \n        \n        \n        s = self_data;\n        while (1) {\n            \n            if (s >= top) {\n                if (is_slice) {\n                    return top;\n                }\n                mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"string index out of range\"));\n            }\n            \n            if (i-- == 0) {\n                break;\n            }\n            \n            ++s;\n            while (UTF8_IS_CONT(*s)) {\n                ++s;\n            }\n        }\n    }\n    return s;\n}\n\nstatic mp_obj_t str_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    const mp_obj_type_t *type = mp_obj_get_type(self_in);\n    assert(type == &mp_type_str);\n    GET_STR_DATA_LEN(self_in, self_data, self_len);\n    if (value == MP_OBJ_SENTINEL) {\n        \n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_obj_t ostart, ostop, ostep;\n            mp_obj_slice_t *slice = MP_OBJ_TO_PTR(index);\n            ostart = slice->start;\n            ostop = slice->stop;\n            ostep = slice->step;\n\n            if (ostep != mp_const_none && ostep != MP_OBJ_NEW_SMALL_INT(1)) {\n                mp_raise_NotImplementedError(MP_ERROR_TEXT(\"only slices with step=1 (aka None) are supported\"));\n            }\n\n            const byte *pstart, *pstop;\n            if (ostart != mp_const_none) {\n                pstart = str_index_to_ptr(type, self_data, self_len, ostart, true);\n            } else {\n                pstart = self_data;\n            }\n            if (ostop != mp_const_none) {\n                \n                \n                pstop = str_index_to_ptr(type, self_data, self_len, ostop, true);\n            } else {\n                pstop = self_data + self_len;\n            }\n            if (pstop < pstart) {\n                return MP_OBJ_NEW_QSTR(MP_QSTR_);\n            }\n            return mp_obj_new_str_of_type(type, (const byte *)pstart, pstop - pstart);\n        }\n        #endif\n        const byte *s = str_index_to_ptr(type, self_data, self_len, index, false);\n        int len = 1;\n        if (UTF8_IS_NONASCII(*s)) {\n            \n            for (char mask = 0x40; *s & mask; mask >>= 1) {\n                ++len;\n            }\n        }\n        return mp_obj_new_str_via_qstr((const char *)s, len); \n    } else {\n        return MP_OBJ_NULL; \n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_str,\n    MP_QSTR_str,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, mp_obj_str_make_new,\n    print, uni_print,\n    unary_op, uni_unary_op,\n    binary_op, mp_obj_str_binary_op,\n    subscr, str_subscr,\n    iter, mp_obj_new_str_iterator,\n    buffer, mp_obj_str_get_buffer,\n    locals_dict, &mp_obj_str_locals_dict\n    );\n\n \n \n\ntypedef struct _mp_obj_str_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_obj_t str;\n    size_t cur;\n} mp_obj_str_it_t;\n\nstatic mp_obj_t str_it_iternext(mp_obj_t self_in) {\n    mp_obj_str_it_t *self = MP_OBJ_TO_PTR(self_in);\n    GET_STR_DATA_LEN(self->str, str, len);\n    if (self->cur < len) {\n        const byte *cur = str + self->cur;\n        const byte *end = utf8_next_char(str + self->cur);\n        mp_obj_t o_out = mp_obj_new_str_via_qstr((const char *)cur, end - cur);\n        self->cur += end - cur;\n        return o_out;\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nstatic mp_obj_t mp_obj_new_str_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_str_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_str_it_t *o = (mp_obj_str_it_t *)iter_buf;\n    o->base.type = &mp_type_polymorph_iter;\n    o->iternext = str_it_iternext;\n    o->str = str;\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}