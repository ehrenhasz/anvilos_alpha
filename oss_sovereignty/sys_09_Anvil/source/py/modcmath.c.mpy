{
  "module_name": "modcmath.c",
  "hash_id": "08eaf2f095bc28d474d9e60863e6ac69473c40776815a4badcc8c397dc4d8c6b",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modcmath.c",
  "human_readable_source": " \n\n#include \"py/builtin.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT && MICROPY_PY_BUILTINS_COMPLEX && MICROPY_PY_CMATH\n\n#include <math.h>\n\n\nstatic mp_obj_t mp_cmath_phase(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    return mp_obj_new_float(MICROPY_FLOAT_C_FUN(atan2)(imag, real));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_phase_obj, mp_cmath_phase);\n\n\nstatic mp_obj_t mp_cmath_polar(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    mp_obj_t tuple[2] = {\n        mp_obj_new_float(MICROPY_FLOAT_C_FUN(sqrt)(real * real + imag * imag)),\n        mp_obj_new_float(MICROPY_FLOAT_C_FUN(atan2)(imag, real)),\n    };\n    return mp_obj_new_tuple(2, tuple);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_polar_obj, mp_cmath_polar);\n\n\nstatic mp_obj_t mp_cmath_rect(mp_obj_t r_obj, mp_obj_t phi_obj) {\n    mp_float_t r = mp_obj_get_float(r_obj);\n    mp_float_t phi = mp_obj_get_float(phi_obj);\n    return mp_obj_new_complex(r * MICROPY_FLOAT_C_FUN(cos)(phi), r * MICROPY_FLOAT_C_FUN(sin)(phi));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(mp_cmath_rect_obj, mp_cmath_rect);\n\n\nstatic mp_obj_t mp_cmath_exp(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    mp_float_t exp_real = MICROPY_FLOAT_C_FUN(exp)(real);\n    return mp_obj_new_complex(exp_real * MICROPY_FLOAT_C_FUN(cos)(imag), exp_real * MICROPY_FLOAT_C_FUN(sin)(imag));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_exp_obj, mp_cmath_exp);\n\n\n\nstatic mp_obj_t mp_cmath_log(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    return mp_obj_new_complex(MICROPY_FLOAT_CONST(0.5) * MICROPY_FLOAT_C_FUN(log)(real * real + imag * imag), MICROPY_FLOAT_C_FUN(atan2)(imag, real));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_log_obj, mp_cmath_log);\n\n#if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n\nstatic mp_obj_t mp_cmath_log10(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    return mp_obj_new_complex(MICROPY_FLOAT_CONST(0.5) * MICROPY_FLOAT_C_FUN(log10)(real * real + imag * imag), MICROPY_FLOAT_CONST(0.4342944819032518) * MICROPY_FLOAT_C_FUN(atan2)(imag, real));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_log10_obj, mp_cmath_log10);\n#endif\n\n\nstatic mp_obj_t mp_cmath_sqrt(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    mp_float_t sqrt_abs = MICROPY_FLOAT_C_FUN(pow)(real * real + imag * imag, MICROPY_FLOAT_CONST(0.25));\n    mp_float_t theta = MICROPY_FLOAT_CONST(0.5) * MICROPY_FLOAT_C_FUN(atan2)(imag, real);\n    return mp_obj_new_complex(sqrt_abs * MICROPY_FLOAT_C_FUN(cos)(theta), sqrt_abs * MICROPY_FLOAT_C_FUN(sin)(theta));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_sqrt_obj, mp_cmath_sqrt);\n\n\nstatic mp_obj_t mp_cmath_cos(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    return mp_obj_new_complex(MICROPY_FLOAT_C_FUN(cos)(real) * MICROPY_FLOAT_C_FUN(cosh)(imag), -MICROPY_FLOAT_C_FUN(sin)(real) * MICROPY_FLOAT_C_FUN(sinh)(imag));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_cos_obj, mp_cmath_cos);\n\n\nstatic mp_obj_t mp_cmath_sin(mp_obj_t z_obj) {\n    mp_float_t real, imag;\n    mp_obj_get_complex(z_obj, &real, &imag);\n    return mp_obj_new_complex(MICROPY_FLOAT_C_FUN(sin)(real) * MICROPY_FLOAT_C_FUN(cosh)(imag), MICROPY_FLOAT_C_FUN(cos)(real) * MICROPY_FLOAT_C_FUN(sinh)(imag));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_sin_obj, mp_cmath_sin);\n\nstatic const mp_rom_map_elem_t mp_module_cmath_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_cmath) },\n    { MP_ROM_QSTR(MP_QSTR_e), mp_const_float_e },\n    { MP_ROM_QSTR(MP_QSTR_pi), mp_const_float_pi },\n    { MP_ROM_QSTR(MP_QSTR_phase), MP_ROM_PTR(&mp_cmath_phase_obj) },\n    { MP_ROM_QSTR(MP_QSTR_polar), MP_ROM_PTR(&mp_cmath_polar_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rect), MP_ROM_PTR(&mp_cmath_rect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_exp), MP_ROM_PTR(&mp_cmath_exp_obj) },\n    { MP_ROM_QSTR(MP_QSTR_log), MP_ROM_PTR(&mp_cmath_log_obj) },\n    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS\n    { MP_ROM_QSTR(MP_QSTR_log10), MP_ROM_PTR(&mp_cmath_log10_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_sqrt), MP_ROM_PTR(&mp_cmath_sqrt_obj) },\n    \n    \n    \n    { MP_ROM_QSTR(MP_QSTR_cos), MP_ROM_PTR(&mp_cmath_cos_obj) },\n    { MP_ROM_QSTR(MP_QSTR_sin), MP_ROM_PTR(&mp_cmath_sin_obj) },\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_cmath_globals, mp_module_cmath_globals_table);\n\nconst mp_obj_module_t mp_module_cmath = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_cmath_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_cmath, mp_module_cmath);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}