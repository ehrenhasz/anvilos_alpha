{
  "module_name": "obj.c",
  "hash_id": "e59db40325fe6b42d9544ac2a9846b966eddc1609c34c10c7e106048e59e006d",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/obj.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <assert.h>\n\n#include \"py/obj.h\"\n#include \"py/objtype.h\"\n#include \"py/objint.h\"\n#include \"py/objstr.h\"\n#include \"py/runtime.h\"\n#include \"py/stackctrl.h\"\n#include \"py/stream.h\" \n\n\nMP_NOINLINE void *mp_obj_malloc_helper(size_t num_bytes, const mp_obj_type_t *type) {\n    mp_obj_base_t *base = (mp_obj_base_t *)m_malloc(num_bytes);\n    base->type = type;\n    return base;\n}\n\n#if MICROPY_ENABLE_FINALISER\n\nMP_NOINLINE void *mp_obj_malloc_with_finaliser_helper(size_t num_bytes, const mp_obj_type_t *type) {\n    mp_obj_base_t *base = (mp_obj_base_t *)m_malloc_with_finaliser(num_bytes);\n    base->type = type;\n    return base;\n}\n#endif\n\nconst mp_obj_type_t *MICROPY_WRAP_MP_OBJ_GET_TYPE(mp_obj_get_type)(mp_const_obj_t o_in) {\n    #if MICROPY_OBJ_IMMEDIATE_OBJS && MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_A\n\n    if (mp_obj_is_obj(o_in)) {\n        const mp_obj_base_t *o = MP_OBJ_TO_PTR(o_in);\n        return o->type;\n    } else {\n        static const mp_obj_type_t *const types[] = {\n            NULL, &mp_type_int, &mp_type_str, &mp_type_int,\n            NULL, &mp_type_int, &mp_type_NoneType, &mp_type_int,\n            NULL, &mp_type_int, &mp_type_str, &mp_type_int,\n            NULL, &mp_type_int, &mp_type_bool, &mp_type_int,\n        };\n        return types[(uintptr_t)o_in & 0xf];\n    }\n\n    #elif MICROPY_OBJ_IMMEDIATE_OBJS && MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C\n\n    if (mp_obj_is_small_int(o_in)) {\n        return &mp_type_int;\n    } else if (mp_obj_is_obj(o_in)) {\n        const mp_obj_base_t *o = MP_OBJ_TO_PTR(o_in);\n        return o->type;\n    #if MICROPY_PY_BUILTINS_FLOAT\n    } else if ((((mp_uint_t)(o_in)) & 0xff800007) != 0x00000006) {\n        return &mp_type_float;\n    #endif\n    } else {\n        static const mp_obj_type_t *const types[] = {\n            &mp_type_str, &mp_type_NoneType, &mp_type_str, &mp_type_bool,\n        };\n        return types[((uintptr_t)o_in >> 3) & 3];\n    }\n\n    #else\n\n    if (mp_obj_is_small_int(o_in)) {\n        return &mp_type_int;\n    } else if (mp_obj_is_qstr(o_in)) {\n        return &mp_type_str;\n        #if MICROPY_PY_BUILTINS_FLOAT && ( \\\n            MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D)\n    } else if (mp_obj_is_float(o_in)) {\n        return &mp_type_float;\n        #endif\n    #if MICROPY_OBJ_IMMEDIATE_OBJS\n    } else if (mp_obj_is_immediate_obj(o_in)) {\n        static const mp_obj_type_t *const types[2] = {&mp_type_NoneType, &mp_type_bool};\n        return types[MP_OBJ_IMMEDIATE_OBJ_VALUE(o_in) & 1];\n    #endif\n    } else {\n        const mp_obj_base_t *o = MP_OBJ_TO_PTR(o_in);\n        return o->type;\n    }\n\n    #endif\n}\n\nconst char *mp_obj_get_type_str(mp_const_obj_t o_in) {\n    return qstr_str(mp_obj_get_type(o_in)->name);\n}\n\nvoid mp_obj_print_helper(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    \n    MP_STACK_CHECK();\n    #ifndef NDEBUG\n    if (o_in == MP_OBJ_NULL) {\n        mp_print_str(print, \"(nil)\");\n        return;\n    }\n    #endif\n    const mp_obj_type_t *type = mp_obj_get_type(o_in);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, print)) {\n        MP_OBJ_TYPE_GET_SLOT(type, print)((mp_print_t *)print, o_in, kind);\n    } else {\n        mp_printf(print, \"<%q>\", type->name);\n    }\n}\n\nvoid mp_obj_print(mp_obj_t o_in, mp_print_kind_t kind) {\n    mp_obj_print_helper(MP_PYTHON_PRINTER, o_in, kind);\n}\n\n\nvoid mp_obj_print_exception(const mp_print_t *print, mp_obj_t exc) {\n    if (mp_obj_is_exception_instance(exc)) {\n        size_t n, *values;\n        mp_obj_exception_get_traceback(exc, &n, &values);\n        if (n > 0) {\n            assert(n % 3 == 0);\n            mp_print_str(print, \"Traceback (most recent call last):\\n\");\n            for (int i = n - 3; i >= 0; i -= 3) {\n                #if MICROPY_ENABLE_SOURCE_LINE\n                mp_printf(print, \"  File \\\"%q\\\", line %d\", values[i], (int)values[i + 1]);\n                #else\n                mp_printf(print, \"  File \\\"%q\\\"\", values[i]);\n                #endif\n                \n                qstr block = values[i + 2];\n                if (block == MP_QSTRnull) {\n                    mp_print_str(print, \"\\n\");\n                } else {\n                    mp_printf(print, \", in %q\\n\", block);\n                }\n            }\n        }\n    }\n    mp_obj_print_helper(print, exc, PRINT_EXC);\n    mp_print_str(print, \"\\n\");\n}\n\nbool mp_obj_is_true(mp_obj_t arg) {\n    if (arg == mp_const_false) {\n        return 0;\n    } else if (arg == mp_const_true) {\n        return 1;\n    } else if (arg == mp_const_none) {\n        return 0;\n    } else if (mp_obj_is_small_int(arg)) {\n        if (arg == MP_OBJ_NEW_SMALL_INT(0)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else {\n        const mp_obj_type_t *type = mp_obj_get_type(arg);\n        if (MP_OBJ_TYPE_HAS_SLOT(type, unary_op)) {\n            mp_obj_t result = MP_OBJ_TYPE_GET_SLOT(type, unary_op)(MP_UNARY_OP_BOOL, arg);\n            if (result != MP_OBJ_NULL) {\n                return result == mp_const_true;\n            }\n        }\n\n        mp_obj_t len = mp_obj_len_maybe(arg);\n        if (len != MP_OBJ_NULL) {\n            \n            return len != MP_OBJ_NEW_SMALL_INT(0);\n        } else {\n            \n            return 1;\n        }\n    }\n}\n\nbool mp_obj_is_callable(mp_obj_t o_in) {\n    const mp_call_fun_t call = MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_obj_get_type(o_in), call);\n    if (call != mp_obj_instance_call) {\n        return call != NULL;\n    }\n    return mp_obj_instance_is_callable(o_in);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmp_obj_t mp_obj_equal_not_equal(mp_binary_op_t op, mp_obj_t o1, mp_obj_t o2) {\n    mp_obj_t local_true = (op == MP_BINARY_OP_NOT_EQUAL) ? mp_const_false : mp_const_true;\n    mp_obj_t local_false = (op == MP_BINARY_OP_NOT_EQUAL) ? mp_const_true : mp_const_false;\n    int pass_number = 0;\n\n    \n    if (o1 == o2 &&\n        (mp_obj_is_small_int(o1) || !(mp_obj_get_type(o1)->flags & MP_TYPE_FLAG_EQ_NOT_REFLEXIVE))) {\n        return local_true;\n    }\n\n    \n    if (mp_obj_is_str(o1)) {\n        if (mp_obj_is_str(o2)) {\n            \n            return mp_obj_str_equal(o1, o2) ? local_true : local_false;\n        #if MICROPY_PY_STR_BYTES_CMP_WARN\n        } else if (mp_obj_is_type(o2, &mp_type_bytes)) {\n        str_bytes_cmp:\n            mp_warning(MP_WARN_CAT(BytesWarning), \"Comparison between bytes and str\");\n            return local_false;\n        #endif\n        } else {\n            goto skip_one_pass;\n        }\n    #if MICROPY_PY_STR_BYTES_CMP_WARN\n    } else if (mp_obj_is_str(o2) && mp_obj_is_type(o1, &mp_type_bytes)) {\n        \n        goto str_bytes_cmp;\n    #endif\n    }\n\n    \n    if (mp_obj_is_small_int(o1)) {\n        if (mp_obj_is_small_int(o2)) {\n            \n            return local_false;\n        } else {\n            goto skip_one_pass;\n        }\n    }\n\n    \n    while (pass_number < 2) {\n        const mp_obj_type_t *type = mp_obj_get_type(o1);\n        \n        \n        if (MP_OBJ_TYPE_HAS_SLOT(type, binary_op) &&\n            ((type->flags & MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE) || mp_obj_get_type(o2) == type)) {\n            \n            \n            if (op == MP_BINARY_OP_NOT_EQUAL && (type->flags & MP_TYPE_FLAG_EQ_HAS_NEQ_TEST)) {\n                mp_obj_t r = MP_OBJ_TYPE_GET_SLOT(type, binary_op)(MP_BINARY_OP_NOT_EQUAL, o1, o2);\n                if (r != MP_OBJ_NULL) {\n                    return r;\n                }\n            }\n\n            \n            mp_obj_t r = MP_OBJ_TYPE_GET_SLOT(type, binary_op)(MP_BINARY_OP_EQUAL, o1, o2);\n            if (r != MP_OBJ_NULL) {\n                if (op == MP_BINARY_OP_EQUAL) {\n                    return r;\n                } else {\n                    return mp_obj_is_true(r) ? local_true : local_false;\n                }\n            }\n        }\n\n    skip_one_pass:\n        \n        ++pass_number;\n        mp_obj_t temp = o1;\n        o1 = o2;\n        o2 = temp;\n    }\n\n    \n    return (o1 == o2) ? local_true : local_false;\n}\n\nbool mp_obj_equal(mp_obj_t o1, mp_obj_t o2) {\n    return mp_obj_is_true(mp_obj_equal_not_equal(MP_BINARY_OP_EQUAL, o1, o2));\n}\n\nmp_int_t mp_obj_get_int(mp_const_obj_t arg) {\n    \n    \n    \n    mp_int_t val;\n    if (!mp_obj_get_int_maybe(arg, &val)) {\n        mp_raise_TypeError_int_conversion(arg);\n    }\n    return val;\n}\n\nmp_int_t mp_obj_get_int_truncated(mp_const_obj_t arg) {\n    if (mp_obj_is_int(arg)) {\n        return mp_obj_int_get_truncated(arg);\n    } else {\n        return mp_obj_get_int(arg);\n    }\n}\n\n\n\n\nbool mp_obj_get_int_maybe(mp_const_obj_t arg, mp_int_t *value) {\n    if (arg == mp_const_false) {\n        *value = 0;\n    } else if (arg == mp_const_true) {\n        *value = 1;\n    } else if (mp_obj_is_small_int(arg)) {\n        *value = MP_OBJ_SMALL_INT_VALUE(arg);\n    } else if (mp_obj_is_exact_type(arg, &mp_type_int)) {\n        *value = mp_obj_int_get_checked(arg);\n    } else {\n        arg = mp_unary_op(MP_UNARY_OP_INT_MAYBE, (mp_obj_t)arg);\n        if (arg != MP_OBJ_NULL) {\n            *value = mp_obj_int_get_checked(arg);\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\n#if MICROPY_PY_BUILTINS_FLOAT\nbool mp_obj_get_float_maybe(mp_obj_t arg, mp_float_t *value) {\n    mp_float_t val;\n\n    if (arg == mp_const_false) {\n        val = 0;\n    } else if (arg == mp_const_true) {\n        val = 1;\n    } else if (mp_obj_is_small_int(arg)) {\n        val = (mp_float_t)MP_OBJ_SMALL_INT_VALUE(arg);\n    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n    } else if (mp_obj_is_exact_type(arg, &mp_type_int)) {\n        val = mp_obj_int_as_float_impl(arg);\n    #endif\n    } else if (mp_obj_is_float(arg)) {\n        val = mp_obj_float_get(arg);\n    } else {\n        arg = mp_unary_op(MP_UNARY_OP_FLOAT_MAYBE, (mp_obj_t)arg);\n        if (arg != MP_OBJ_NULL && mp_obj_is_float(arg)) {\n            val = mp_obj_float_get(arg);\n        } else {\n            return false;\n        }\n    }\n    *value = val;\n    return true;\n}\n\nmp_float_t mp_obj_get_float(mp_obj_t arg) {\n    mp_float_t val;\n\n    if (!mp_obj_get_float_maybe(arg, &val)) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"can't convert to float\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"can't convert %s to float\"), mp_obj_get_type_str(arg));\n        #endif\n    }\n\n    return val;\n}\n\n#if MICROPY_PY_BUILTINS_COMPLEX\nbool mp_obj_get_complex_maybe(mp_obj_t arg, mp_float_t *real, mp_float_t *imag) {\n    if (mp_obj_get_float_maybe(arg, real)) {\n        *imag = 0;\n    } else if (mp_obj_is_type(arg, &mp_type_complex)) {\n        mp_obj_complex_get(arg, real, imag);\n    } else {\n        arg = mp_unary_op(MP_UNARY_OP_COMPLEX_MAYBE, (mp_obj_t)arg);\n        if (arg != MP_OBJ_NULL && mp_obj_is_type(arg, &mp_type_complex)) {\n            mp_obj_complex_get(arg, real, imag);\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid mp_obj_get_complex(mp_obj_t arg, mp_float_t *real, mp_float_t *imag) {\n    if (!mp_obj_get_complex_maybe(arg, real, imag)) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"can't convert to complex\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"can't convert %s to complex\"), mp_obj_get_type_str(arg));\n        #endif\n    }\n}\n#endif\n#endif\n\n\nvoid mp_obj_get_array(mp_obj_t o, size_t *len, mp_obj_t **items) {\n    if (mp_obj_is_type(o, &mp_type_tuple)) {\n        mp_obj_tuple_get(o, len, items);\n    } else if (mp_obj_is_type(o, &mp_type_list)) {\n        mp_obj_list_get(o, len, items);\n    } else {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"expected tuple/list\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"object '%s' isn't a tuple or list\"), mp_obj_get_type_str(o));\n        #endif\n    }\n}\n\n\nvoid mp_obj_get_array_fixed_n(mp_obj_t o, size_t len, mp_obj_t **items) {\n    size_t seq_len;\n    mp_obj_get_array(o, &seq_len, items);\n    if (seq_len != len) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_ValueError(MP_ERROR_TEXT(\"tuple/list has wrong length\"));\n        #else\n        mp_raise_msg_varg(&mp_type_ValueError,\n            MP_ERROR_TEXT(\"requested length %d but object has length %d\"), (int)len, (int)seq_len);\n        #endif\n    }\n}\n\n\nsize_t mp_get_index(const mp_obj_type_t *type, size_t len, mp_obj_t index, bool is_slice) {\n    mp_int_t i;\n    if (mp_obj_is_small_int(index)) {\n        i = MP_OBJ_SMALL_INT_VALUE(index);\n    } else if (!mp_obj_get_int_maybe(index, &i)) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"indices must be integers\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"%q indices must be integers, not %s\"),\n            type->name, mp_obj_get_type_str(index));\n        #endif\n    }\n\n    if (i < 0) {\n        i += len;\n    }\n    if (is_slice) {\n        if (i < 0) {\n            i = 0;\n        } else if ((mp_uint_t)i > len) {\n            i = len;\n        }\n    } else {\n        if (i < 0 || (mp_uint_t)i >= len) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"index out of range\"));\n            #else\n            mp_raise_msg_varg(&mp_type_IndexError, MP_ERROR_TEXT(\"%q index out of range\"), type->name);\n            #endif\n        }\n    }\n\n    \n    return (size_t)i;\n}\n\nmp_obj_t mp_obj_id(mp_obj_t o_in) {\n    mp_int_t id = (mp_int_t)o_in;\n    if (!mp_obj_is_obj(o_in)) {\n        return mp_obj_new_int(id);\n    } else if (id >= 0) {\n        \n        \n        \n        \n        return MP_OBJ_NEW_SMALL_INT(id);\n    } else {\n        \n        \n        \n        return mp_obj_new_int_from_uint((mp_uint_t)id);\n    }\n}\n\n\nmp_obj_t mp_obj_len(mp_obj_t o_in) {\n    mp_obj_t len = mp_obj_len_maybe(o_in);\n    if (len == MP_OBJ_NULL) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"object has no len\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"object of type '%s' has no len()\"), mp_obj_get_type_str(o_in));\n        #endif\n    } else {\n        return len;\n    }\n}\n\n\nmp_obj_t mp_obj_len_maybe(mp_obj_t o_in) {\n    if (\n        #if !MICROPY_PY_BUILTINS_STR_UNICODE\n        \n        mp_obj_is_str(o_in) ||\n        #endif\n        mp_obj_is_type(o_in, &mp_type_bytes)) {\n        GET_STR_LEN(o_in, l);\n        return MP_OBJ_NEW_SMALL_INT(l);\n    } else {\n        const mp_obj_type_t *type = mp_obj_get_type(o_in);\n        if (MP_OBJ_TYPE_HAS_SLOT(type, unary_op)) {\n            return MP_OBJ_TYPE_GET_SLOT(type, unary_op)(MP_UNARY_OP_LEN, o_in);\n        } else {\n            return MP_OBJ_NULL;\n        }\n    }\n}\n\nmp_obj_t mp_obj_subscr(mp_obj_t base, mp_obj_t index, mp_obj_t value) {\n    const mp_obj_type_t *type = mp_obj_get_type(base);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, subscr)) {\n        mp_obj_t ret = MP_OBJ_TYPE_GET_SLOT(type, subscr)(base, index, value);\n        if (ret != MP_OBJ_NULL) {\n            return ret;\n        }\n        \n    }\n    if (value == MP_OBJ_NULL) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"object doesn't support item deletion\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"'%s' object doesn't support item deletion\"), mp_obj_get_type_str(base));\n        #endif\n    } else if (value == MP_OBJ_SENTINEL) {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"object isn't subscriptable\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"'%s' object isn't subscriptable\"), mp_obj_get_type_str(base));\n        #endif\n    } else {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"object doesn't support item assignment\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"'%s' object doesn't support item assignment\"), mp_obj_get_type_str(base));\n        #endif\n    }\n}\n\n\n\nmp_obj_t mp_identity(mp_obj_t self) {\n    return self;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_identity_obj, mp_identity);\n\n\n\n\n\n\nbool mp_get_buffer(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    const mp_obj_type_t *type = mp_obj_get_type(obj);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, buffer)\n        && MP_OBJ_TYPE_GET_SLOT(type, buffer)(obj, bufinfo, flags & MP_BUFFER_RW) == 0) {\n        return true;\n    }\n    if (flags & MP_BUFFER_RAISE_IF_UNSUPPORTED) {\n        mp_raise_TypeError(MP_ERROR_TEXT(\"object with buffer protocol required\"));\n    }\n    return false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}