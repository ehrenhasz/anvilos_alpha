{
  "module_name": "makeqstrdefs.py",
  "hash_id": "a8e14263a8c98e3e7e4373719ca4eec0907d920cb6dea13f40055b651d6745f3",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/makeqstrdefs.py",
  "human_readable_source": "\"\"\"\nThis script processes the output from the C preprocessor and extracts all\nqstr. Each qstr is transformed into a qstr definition of the form 'Q(...)'.\n\nThis script works with Python 2.6, 2.7, 3.3 and 3.4.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport io\nimport os\nimport re\nimport subprocess\nimport sys\nimport multiprocessing, multiprocessing.dummy\n\n\n# Extract MP_QSTR_FOO macros.\n_MODE_QSTR = \"qstr\"\n\n# Extract MP_COMPRESSED_ROM_TEXT(\"\") macros.  (Which come from MP_ERROR_TEXT)\n_MODE_COMPRESS = \"compress\"\n\n# Extract MP_REGISTER_(EXTENSIBLE_)MODULE(...) macros.\n_MODE_MODULE = \"module\"\n\n# Extract MP_REGISTER_ROOT_POINTER(...) macros.\n_MODE_ROOT_POINTER = \"root_pointer\"\n\n\nclass PreprocessorError(Exception):\n    pass\n\n\ndef is_c_source(fname):\n    return os.path.splitext(fname)[1] in [\".c\"]\n\n\ndef is_cxx_source(fname):\n    return os.path.splitext(fname)[1] in [\".cc\", \".cp\", \".cxx\", \".cpp\", \".CPP\", \".c++\", \".C\"]\n\n\ndef preprocess():\n    if any(src in args.dependencies for src in args.changed_sources):\n        sources = args.sources\n    elif any(args.changed_sources):\n        sources = args.changed_sources\n    else:\n        sources = args.sources\n    csources = []\n    cxxsources = []\n    for source in sources:\n        if is_cxx_source(source):\n            cxxsources.append(source)\n        elif is_c_source(source):\n            csources.append(source)\n    try:\n        os.makedirs(os.path.dirname(args.output[0]))\n    except OSError:\n        pass\n\n    def pp(flags):\n        def run(files):\n            try:\n                return subprocess.check_output(args.pp + flags + files)\n            except subprocess.CalledProcessError as er:\n                raise PreprocessorError(str(er))\n\n        return run\n\n    try:\n        cpus = multiprocessing.cpu_count()\n    except NotImplementedError:\n        cpus = 1\n    p = multiprocessing.dummy.Pool(cpus)\n    with open(args.output[0], \"wb\") as out_file:\n        for flags, sources in (\n            (args.cflags, csources),\n            (args.cxxflags, cxxsources),\n        ):\n            batch_size = (len(sources) + cpus - 1) // cpus\n            chunks = [sources[i : i + batch_size] for i in range(0, len(sources), batch_size or 1)]\n            for output in p.imap(pp(flags), chunks):\n                out_file.write(output)\n\n\ndef write_out(fname, output):\n    if output:\n        for m, r in [(\"/\", \"__\"), (\"\\\\\", \"__\"), (\":\", \"@\"), (\"..\", \"@@\")]:\n            fname = fname.replace(m, r)\n        with open(args.output_dir + \"/\" + fname + \".\" + args.mode, \"w\") as f:\n            f.write(\"\\n\".join(output) + \"\\n\")\n\n\ndef process_file(f):\n    # match gcc-like output (# n \"file\") and msvc-like output (#line n \"file\")\n    re_line = re.compile(r\"^#(?:line)?\\s+\\d+\\s\\\"([^\\\"]+)\\\"\")\n    if args.mode == _MODE_QSTR:\n        re_match = re.compile(r\"MP_QSTR_[_a-zA-Z0-9]+\")\n    elif args.mode == _MODE_COMPRESS:\n        re_match = re.compile(r'MP_COMPRESSED_ROM_TEXT\\(\"([^\"]*)\"\\)')\n    elif args.mode == _MODE_MODULE:\n        re_match = re.compile(\n            r\"(?:MP_REGISTER_MODULE|MP_REGISTER_EXTENSIBLE_MODULE|MP_REGISTER_MODULE_DELEGATION)\\(.*?,\\s*.*?\\);\"\n        )\n    elif args.mode == _MODE_ROOT_POINTER:\n        re_match = re.compile(r\"MP_REGISTER_ROOT_POINTER\\(.*?\\);\")\n    output = []\n    last_fname = None\n    for line in f:\n        if line.isspace():\n            continue\n        m = re_line.match(line)\n        if m:\n            fname = m.group(1)\n            if not is_c_source(fname) and not is_cxx_source(fname):\n                continue\n            if fname != last_fname:\n                write_out(last_fname, output)\n                output = []\n                last_fname = fname\n            continue\n        for match in re_match.findall(line):\n            if args.mode == _MODE_QSTR:\n                name = match.replace(\"MP_QSTR_\", \"\")\n                output.append(\"Q(\" + name + \")\")\n            elif args.mode in (_MODE_COMPRESS, _MODE_MODULE, _MODE_ROOT_POINTER):\n                output.append(match)\n\n    if last_fname:\n        write_out(last_fname, output)\n    return \"\"\n\n\ndef cat_together():\n    import glob\n    import hashlib\n\n    hasher = hashlib.md5()\n    all_lines = []\n    for fname in glob.glob(args.output_dir + \"/*.\" + args.mode):\n        with open(fname, \"rb\") as f:\n            lines = f.readlines()\n            all_lines += lines\n    all_lines.sort()\n    all_lines = b\"\\n\".join(all_lines)\n    hasher.update(all_lines)\n    new_hash = hasher.hexdigest()\n    # print(new_hash)\n    old_hash = None\n    try:\n        with open(args.output_file + \".hash\") as f:\n            old_hash = f.read()\n    except IOError:\n        pass\n    mode_full = \"QSTR\"\n    if args.mode == _MODE_COMPRESS:\n        mode_full = \"Compressed data\"\n    elif args.mode == _MODE_MODULE:\n        mode_full = \"Module registrations\"\n    elif args.mode == _MODE_ROOT_POINTER:\n        mode_full = \"Root pointer registrations\"\n    if old_hash != new_hash or not os.path.exists(args.output_file):\n        print(mode_full, \"updated\")\n\n        with open(args.output_file, \"wb\") as outf:\n            outf.write(all_lines)\n        with open(args.output_file + \".hash\", \"w\") as f:\n            f.write(new_hash)\n    else:\n        print(mode_full, \"not updated\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 6:\n        print(\"usage: %s command mode input_filename output_dir output_file\" % sys.argv[0])\n        sys.exit(2)\n\n    class Args:\n        pass\n\n    args = Args()\n    args.command = sys.argv[1]\n\n    if args.command == \"pp\":\n        named_args = {\n            s: []\n            for s in [\n                \"pp\",\n                \"output\",\n                \"cflags\",\n                \"cxxflags\",\n                \"sources\",\n                \"changed_sources\",\n                \"dependencies\",\n            ]\n        }\n\n        for arg in sys.argv[1:]:\n            if arg in named_args:\n                current_tok = arg\n            else:\n                named_args[current_tok].append(arg)\n\n        if not named_args[\"pp\"] or len(named_args[\"output\"]) != 1:\n            print(\"usage: %s %s ...\" % (sys.argv[0], \" ... \".join(named_args)))\n            sys.exit(2)\n\n        for k, v in named_args.items():\n            setattr(args, k, v)\n\n        try:\n            preprocess()\n        except PreprocessorError as er:\n            print(er)\n            sys.exit(1)\n\n        sys.exit(0)\n\n    args.mode = sys.argv[2]\n    args.input_filename = sys.argv[3]  # Unused for command=cat\n    args.output_dir = sys.argv[4]\n    args.output_file = None if len(sys.argv) == 5 else sys.argv[5]  # Unused for command=split\n\n    if args.mode not in (_MODE_QSTR, _MODE_COMPRESS, _MODE_MODULE, _MODE_ROOT_POINTER):\n        print(\"error: mode %s unrecognised\" % sys.argv[2])\n        sys.exit(2)\n\n    try:\n        os.makedirs(args.output_dir)\n    except OSError:\n        pass\n\n    if args.command == \"split\":\n        with io.open(args.input_filename, encoding=\"utf-8\") as infile:\n            process_file(infile)\n\n    if args.command == \"cat\":\n        cat_together()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}