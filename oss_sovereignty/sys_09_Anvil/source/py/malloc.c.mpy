{
  "module_name": "malloc.c",
  "hash_id": "9df974ddde189d3ae4f8fe9cef86c8a139b49fc543a5c344c2e3c33ba922aee5",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/malloc.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"py/mpconfig.h\"\n#include \"py/misc.h\"\n#include \"py/mpstate.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\n#if MICROPY_MEM_STATS\n#if !MICROPY_MALLOC_USES_ALLOCATED_SIZE\n#error MICROPY_MEM_STATS requires MICROPY_MALLOC_USES_ALLOCATED_SIZE\n#endif\n#define UPDATE_PEAK() { if (MP_STATE_MEM(current_bytes_allocated) > MP_STATE_MEM(peak_bytes_allocated)) MP_STATE_MEM(peak_bytes_allocated) = MP_STATE_MEM(current_bytes_allocated); }\n#endif\n\n#if MICROPY_ENABLE_GC\n#include \"py/gc.h\"\n\n\n\n\n\n\n#undef malloc\n#undef free\n#undef realloc\n#define malloc(b) gc_alloc((b), false)\n#define malloc_with_finaliser(b) gc_alloc((b), true)\n#define free gc_free\n#define realloc(ptr, n) gc_realloc(ptr, n, true)\n#define realloc_ext(ptr, n, mv) gc_realloc(ptr, n, mv)\n#else\n\n\n\n#if MICROPY_ENABLE_FINALISER\n#error MICROPY_ENABLE_FINALISER requires MICROPY_ENABLE_GC\n#endif\n\nstatic void *realloc_ext(void *ptr, size_t n_bytes, bool allow_move) {\n    if (allow_move) {\n        return realloc(ptr, n_bytes);\n    } else {\n        \n        \n        \n        return NULL;\n    }\n}\n\n#endif \n\nvoid *m_malloc(size_t num_bytes) {\n    void *ptr = malloc(num_bytes);\n    if (ptr == NULL && num_bytes != 0) {\n        m_malloc_fail(num_bytes);\n    }\n    #if MICROPY_MEM_STATS\n    MP_STATE_MEM(total_bytes_allocated) += num_bytes;\n    MP_STATE_MEM(current_bytes_allocated) += num_bytes;\n    UPDATE_PEAK();\n    #endif\n    DEBUG_printf(\"malloc %d : %p\\n\", num_bytes, ptr);\n    return ptr;\n}\n\nvoid *m_malloc_maybe(size_t num_bytes) {\n    void *ptr = malloc(num_bytes);\n    #if MICROPY_MEM_STATS\n    MP_STATE_MEM(total_bytes_allocated) += num_bytes;\n    MP_STATE_MEM(current_bytes_allocated) += num_bytes;\n    UPDATE_PEAK();\n    #endif\n    DEBUG_printf(\"malloc %d : %p\\n\", num_bytes, ptr);\n    return ptr;\n}\n\n#if MICROPY_ENABLE_FINALISER\nvoid *m_malloc_with_finaliser(size_t num_bytes) {\n    void *ptr = malloc_with_finaliser(num_bytes);\n    if (ptr == NULL && num_bytes != 0) {\n        m_malloc_fail(num_bytes);\n    }\n    #if MICROPY_MEM_STATS\n    MP_STATE_MEM(total_bytes_allocated) += num_bytes;\n    MP_STATE_MEM(current_bytes_allocated) += num_bytes;\n    UPDATE_PEAK();\n    #endif\n    DEBUG_printf(\"malloc %d : %p\\n\", num_bytes, ptr);\n    return ptr;\n}\n#endif\n\nvoid *m_malloc0(size_t num_bytes) {\n    void *ptr = m_malloc(num_bytes);\n    \n    #if !MICROPY_GC_CONSERVATIVE_CLEAR\n    memset(ptr, 0, num_bytes);\n    #endif\n    return ptr;\n}\n\n#if MICROPY_MALLOC_USES_ALLOCATED_SIZE\nvoid *m_realloc(void *ptr, size_t old_num_bytes, size_t new_num_bytes)\n#else\nvoid *m_realloc(void *ptr, size_t new_num_bytes)\n#endif\n{\n    void *new_ptr = realloc(ptr, new_num_bytes);\n    if (new_ptr == NULL && new_num_bytes != 0) {\n        m_malloc_fail(new_num_bytes);\n    }\n    #if MICROPY_MEM_STATS\n    \n    \n    \n    \n    \n    size_t diff = new_num_bytes - old_num_bytes;\n    MP_STATE_MEM(total_bytes_allocated) += diff;\n    MP_STATE_MEM(current_bytes_allocated) += diff;\n    UPDATE_PEAK();\n    #endif\n    #if MICROPY_MALLOC_USES_ALLOCATED_SIZE\n    DEBUG_printf(\"realloc %p, %d, %d : %p\\n\", ptr, old_num_bytes, new_num_bytes, new_ptr);\n    #else\n    DEBUG_printf(\"realloc %p, %d : %p\\n\", ptr, new_num_bytes, new_ptr);\n    #endif\n    return new_ptr;\n}\n\n#if MICROPY_MALLOC_USES_ALLOCATED_SIZE\nvoid *m_realloc_maybe(void *ptr, size_t old_num_bytes, size_t new_num_bytes, bool allow_move)\n#else\nvoid *m_realloc_maybe(void *ptr, size_t new_num_bytes, bool allow_move)\n#endif\n{\n    void *new_ptr = realloc_ext(ptr, new_num_bytes, allow_move);\n    #if MICROPY_MEM_STATS\n    \n    \n    \n    \n    \n    \n    if (!(new_ptr == NULL && new_num_bytes != 0)) {\n        size_t diff = new_num_bytes - old_num_bytes;\n        MP_STATE_MEM(total_bytes_allocated) += diff;\n        MP_STATE_MEM(current_bytes_allocated) += diff;\n        UPDATE_PEAK();\n    }\n    #endif\n    #if MICROPY_MALLOC_USES_ALLOCATED_SIZE\n    DEBUG_printf(\"realloc %p, %d, %d : %p\\n\", ptr, old_num_bytes, new_num_bytes, new_ptr);\n    #else\n    DEBUG_printf(\"realloc %p, %d : %p\\n\", ptr, new_num_bytes, new_ptr);\n    #endif\n    return new_ptr;\n}\n\n#if MICROPY_MALLOC_USES_ALLOCATED_SIZE\nvoid m_free(void *ptr, size_t num_bytes)\n#else\nvoid m_free(void *ptr)\n#endif\n{\n    free(ptr);\n    #if MICROPY_MEM_STATS\n    MP_STATE_MEM(current_bytes_allocated) -= num_bytes;\n    #endif\n    #if MICROPY_MALLOC_USES_ALLOCATED_SIZE\n    DEBUG_printf(\"free %p, %d\\n\", ptr, num_bytes);\n    #else\n    DEBUG_printf(\"free %p\\n\", ptr);\n    #endif\n}\n\n#if MICROPY_TRACKED_ALLOC\n\n#define MICROPY_TRACKED_ALLOC_STORE_SIZE (!MICROPY_ENABLE_GC)\n\ntypedef struct _m_tracked_node_t {\n    struct _m_tracked_node_t *prev;\n    struct _m_tracked_node_t *next;\n    #if MICROPY_TRACKED_ALLOC_STORE_SIZE\n    uintptr_t size;\n    #endif\n    uint8_t data[];\n} m_tracked_node_t;\n\n#if MICROPY_DEBUG_VERBOSE\nstatic size_t m_tracked_count_links(size_t *nb) {\n    m_tracked_node_t *node = MP_STATE_VM(m_tracked_head);\n    size_t n = 0;\n    *nb = 0;\n    while (node != NULL) {\n        ++n;\n        #if MICROPY_TRACKED_ALLOC_STORE_SIZE\n        *nb += node->size;\n        #else\n        *nb += gc_nbytes(node);\n        #endif\n        node = node->next;\n    }\n    return n;\n}\n#endif\n\nvoid *m_tracked_calloc(size_t nmemb, size_t size) {\n    m_tracked_node_t *node = m_malloc_maybe(sizeof(m_tracked_node_t) + nmemb * size);\n    if (node == NULL) {\n        return NULL;\n    }\n    #if MICROPY_DEBUG_VERBOSE\n    size_t nb;\n    size_t n = m_tracked_count_links(&nb);\n    DEBUG_printf(\"m_tracked_calloc(%u, %u) -> (%u;%u) %p\\n\", (int)nmemb, (int)size, (int)n, (int)nb, node);\n    #endif\n    if (MP_STATE_VM(m_tracked_head) != NULL) {\n        MP_STATE_VM(m_tracked_head)->prev = node;\n    }\n    node->prev = NULL;\n    node->next = MP_STATE_VM(m_tracked_head);\n    MP_STATE_VM(m_tracked_head) = node;\n    #if MICROPY_TRACKED_ALLOC_STORE_SIZE\n    node->size = nmemb * size;\n    #endif\n    #if !MICROPY_GC_CONSERVATIVE_CLEAR\n    memset(&node->data[0], 0, nmemb * size);\n    #endif\n    return &node->data[0];\n}\n\nvoid m_tracked_free(void *ptr_in) {\n    if (ptr_in == NULL) {\n        return;\n    }\n    m_tracked_node_t *node = (m_tracked_node_t *)((uint8_t *)ptr_in - sizeof(m_tracked_node_t));\n    #if MICROPY_DEBUG_VERBOSE\n    size_t data_bytes;\n    #if MICROPY_TRACKED_ALLOC_STORE_SIZE\n    data_bytes = node->size;\n    #else\n    data_bytes = gc_nbytes(node);\n    #endif\n    size_t nb;\n    size_t n = m_tracked_count_links(&nb);\n    DEBUG_printf(\"m_tracked_free(%p, [%p, %p], nbytes=%u, links=%u;%u)\\n\", node, node->prev, node->next, (int)data_bytes, (int)n, (int)nb);\n    #endif\n    if (node->next != NULL) {\n        node->next->prev = node->prev;\n    }\n    if (node->prev != NULL) {\n        node->prev->next = node->next;\n    } else {\n        MP_STATE_VM(m_tracked_head) = node->next;\n    }\n    m_free(node\n        #if MICROPY_MALLOC_USES_ALLOCATED_SIZE\n        #if MICROPY_TRACKED_ALLOC_STORE_SIZE\n        , node->size\n        #else\n        , gc_nbytes(node)\n        #endif\n        #endif\n        );\n}\n\n#endif \n\n#if MICROPY_MEM_STATS\nsize_t m_get_total_bytes_allocated(void) {\n    return MP_STATE_MEM(total_bytes_allocated);\n}\n\nsize_t m_get_current_bytes_allocated(void) {\n    return MP_STATE_MEM(current_bytes_allocated);\n}\n\nsize_t m_get_peak_bytes_allocated(void) {\n    return MP_STATE_MEM(peak_bytes_allocated);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}