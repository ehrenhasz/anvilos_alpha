{
  "module_name": "profile.c",
  "hash_id": "f754829d3c3cab6b18b917e2c0f87e035042933fe7fc642e7ef88a4baacd7a16",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/profile.c",
  "human_readable_source": " \n\n#include \"py/profile.h\"\n#include \"py/bc0.h\"\n#include \"py/gc.h\"\n#include \"py/objfun.h\"\n\n#if MICROPY_PY_SYS_SETTRACE\n\n#if !MICROPY_PERSISTENT_CODE_SAVE\n\n\n#error \"MICROPY_PY_SYS_SETTRACE requires MICROPY_PERSISTENT_CODE_SAVE to be enabled\"\n#endif\n\n#define prof_trace_cb MP_STATE_THREAD(prof_trace_callback)\n#define QSTR_MAP(context, idx) (context->constants.qstr_table[idx])\n\nstatic uint mp_prof_bytecode_lineno(const mp_raw_code_t *rc, size_t bc) {\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n    return mp_bytecode_get_source_line(prelude->line_info, prelude->line_info_top, bc);\n}\n\nvoid mp_prof_extract_prelude(const byte *bytecode, mp_bytecode_prelude_t *prelude) {\n    const byte *ip = bytecode;\n\n    MP_BC_PRELUDE_SIG_DECODE(ip);\n    prelude->n_state = n_state;\n    prelude->n_exc_stack = n_exc_stack;\n    prelude->scope_flags = scope_flags;\n    prelude->n_pos_args = n_pos_args;\n    prelude->n_kwonly_args = n_kwonly_args;\n    prelude->n_def_pos_args = n_def_pos_args;\n\n    MP_BC_PRELUDE_SIZE_DECODE(ip);\n\n    prelude->line_info_top = ip + n_info;\n    prelude->opcodes = ip + n_info + n_cell;\n\n    prelude->qstr_block_name_idx = mp_decode_uint_value(ip);\n    for (size_t i = 0; i < 1 + n_pos_args + n_kwonly_args; ++i) {\n        ip = mp_decode_uint_skip(ip);\n    }\n    prelude->line_info = ip;\n}\n\n \n\n\nstatic void code_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_code_t *o = MP_OBJ_TO_PTR(o_in);\n    const mp_raw_code_t *rc = o->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n    mp_printf(print,\n        \"<code object %q at 0x%p, file \\\"%q\\\", line %d>\",\n        QSTR_MAP(o->context, prelude->qstr_block_name_idx),\n        o,\n        QSTR_MAP(o->context, 0),\n        rc->line_of_definition\n        );\n}\n\nstatic mp_obj_tuple_t *code_consts(const mp_module_context_t *context, const mp_raw_code_t *rc) {\n    mp_obj_tuple_t *consts = MP_OBJ_TO_PTR(mp_obj_new_tuple(rc->n_children + 1, NULL));\n\n    size_t const_no = 0;\n    for (size_t i = 0; i < rc->n_children; ++i) {\n        mp_obj_t code = mp_obj_new_code(context, rc->children[i]);\n        if (code == MP_OBJ_NULL) {\n            m_malloc_fail(sizeof(mp_obj_code_t));\n        }\n        consts->items[const_no++] = code;\n    }\n    consts->items[const_no++] = mp_const_none;\n\n    return consts;\n}\n\nstatic mp_obj_t raw_code_lnotab(const mp_raw_code_t *rc) {\n    \n    uint start = 0;\n    uint stop = rc->fun_data_len - start;\n\n    uint last_lineno = mp_prof_bytecode_lineno(rc, start);\n    uint lasti = 0;\n\n    const uint buffer_chunk_size = (stop - start) >> 2; \n    uint buffer_size = buffer_chunk_size;\n    byte *buffer = m_new(byte, buffer_size);\n    uint buffer_index = 0;\n\n    for (uint i = start; i < stop; ++i) {\n        uint lineno = mp_prof_bytecode_lineno(rc, i);\n        size_t line_diff = lineno - last_lineno;\n        if (line_diff > 0) {\n            uint instr_diff = (i - start) - lasti;\n\n            assert(instr_diff < 256);\n            assert(line_diff < 256);\n\n            if (buffer_index + 2 > buffer_size) {\n                buffer = m_renew(byte, buffer, buffer_size, buffer_size + buffer_chunk_size);\n                buffer_size = buffer_size + buffer_chunk_size;\n            }\n            last_lineno = lineno;\n            lasti = i - start;\n            buffer[buffer_index++] = instr_diff;\n            buffer[buffer_index++] = line_diff;\n        }\n    }\n\n    mp_obj_t o = mp_obj_new_bytes(buffer, buffer_index);\n    m_del(byte, buffer, buffer_size);\n    return o;\n}\n\nstatic void code_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n    mp_obj_code_t *o = MP_OBJ_TO_PTR(self_in);\n    const mp_raw_code_t *rc = o->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n    switch (attr) {\n        case MP_QSTR_co_code:\n            dest[0] = mp_obj_new_bytes(\n                (void *)prelude->opcodes,\n                rc->fun_data_len - (prelude->opcodes - (const byte *)rc->fun_data)\n                );\n            break;\n        case MP_QSTR_co_consts:\n            dest[0] = MP_OBJ_FROM_PTR(code_consts(o->context, rc));\n            break;\n        case MP_QSTR_co_filename:\n            dest[0] = MP_OBJ_NEW_QSTR(QSTR_MAP(o->context, 0));\n            break;\n        case MP_QSTR_co_firstlineno:\n            dest[0] = MP_OBJ_NEW_SMALL_INT(mp_prof_bytecode_lineno(rc, 0));\n            break;\n        case MP_QSTR_co_name:\n            dest[0] = MP_OBJ_NEW_QSTR(QSTR_MAP(o->context, prelude->qstr_block_name_idx));\n            break;\n        case MP_QSTR_co_names:\n            dest[0] = MP_OBJ_FROM_PTR(o->dict_locals);\n            break;\n        case MP_QSTR_co_lnotab:\n            if (!o->lnotab) {\n                o->lnotab = raw_code_lnotab(rc);\n            }\n            dest[0] = o->lnotab;\n            break;\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_settrace_codeobj,\n    MP_QSTR_code,\n    MP_TYPE_FLAG_NONE,\n    print, code_print,\n    attr, code_attr\n    );\n\nmp_obj_t mp_obj_new_code(const mp_module_context_t *context, const mp_raw_code_t *rc) {\n    mp_obj_code_t *o = m_new_obj_maybe(mp_obj_code_t);\n    if (o == NULL) {\n        return MP_OBJ_NULL;\n    }\n    o->base.type = &mp_type_settrace_codeobj;\n    o->context = context;\n    o->rc = rc;\n    o->dict_locals = mp_locals_get(); \n    o->lnotab = MP_OBJ_NULL;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n\n\nstatic void frame_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_frame_t *frame = MP_OBJ_TO_PTR(o_in);\n    mp_obj_code_t *code = frame->code;\n    const mp_raw_code_t *rc = code->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n    mp_printf(print,\n        \"<frame at 0x%p, file '%q', line %d, code %q>\",\n        frame,\n        QSTR_MAP(code->context, 0),\n        frame->lineno,\n        QSTR_MAP(code->context, prelude->qstr_block_name_idx)\n        );\n}\n\nstatic void frame_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n\n    mp_obj_frame_t *o = MP_OBJ_TO_PTR(self_in);\n\n    switch (attr) {\n        case MP_QSTR_f_back:\n            dest[0] = mp_const_none;\n            if (o->code_state->prev_state) {\n                dest[0] = MP_OBJ_FROM_PTR(o->code_state->prev_state->frame);\n            }\n            break;\n        case MP_QSTR_f_code:\n            dest[0] = MP_OBJ_FROM_PTR(o->code);\n            break;\n        case MP_QSTR_f_globals:\n            dest[0] = MP_OBJ_FROM_PTR(o->code_state->fun_bc->context->module.globals);\n            break;\n        case MP_QSTR_f_lasti:\n            dest[0] = MP_OBJ_NEW_SMALL_INT(o->lasti);\n            break;\n        case MP_QSTR_f_lineno:\n            dest[0] = MP_OBJ_NEW_SMALL_INT(o->lineno);\n            break;\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_frame,\n    MP_QSTR_frame,\n    MP_TYPE_FLAG_NONE,\n    print, frame_print,\n    attr, frame_attr\n    );\n\nmp_obj_t mp_obj_new_frame(const mp_code_state_t *code_state) {\n    if (gc_is_locked()) {\n        return MP_OBJ_NULL;\n    }\n\n    mp_obj_frame_t *o = m_new_obj_maybe(mp_obj_frame_t);\n    if (o == NULL) {\n        return MP_OBJ_NULL;\n    }\n\n    mp_obj_code_t *code = o->code = MP_OBJ_TO_PTR(mp_obj_new_code(code_state->fun_bc->context, code_state->fun_bc->rc));\n    if (code == NULL) {\n        return MP_OBJ_NULL;\n    }\n\n    const mp_raw_code_t *rc = code->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n    o->code_state = code_state;\n    o->base.type = &mp_type_frame;\n    o->back = NULL;\n    o->code = code;\n    o->lasti = code_state->ip - prelude->opcodes;\n    o->lineno = mp_prof_bytecode_lineno(rc, o->lasti);\n    o->trace_opcodes = false;\n    o->callback = MP_OBJ_NULL;\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\n\n \n\n\ntypedef struct {\n    struct _mp_obj_frame_t *frame;\n    mp_obj_t event;\n    mp_obj_t arg;\n} prof_callback_args_t;\n\nstatic mp_obj_t mp_prof_callback_invoke(mp_obj_t callback, prof_callback_args_t *args) {\n    assert(mp_obj_is_callable(callback));\n\n    mp_prof_is_executing = true;\n\n    mp_obj_t a[3] = {MP_OBJ_FROM_PTR(args->frame), args->event, args->arg};\n    mp_obj_t top = mp_call_function_n_kw(callback, 3, 0, a);\n\n    mp_prof_is_executing = false;\n\n    if (MP_STATE_THREAD(mp_pending_exception) != MP_OBJ_NULL) {\n        mp_handle_pending(true);\n    }\n    return top;\n}\n\nmp_obj_t mp_prof_settrace(mp_obj_t callback) {\n    if (mp_obj_is_callable(callback)) {\n        prof_trace_cb = callback;\n    } else {\n        prof_trace_cb = MP_OBJ_NULL;\n    }\n    return mp_const_none;\n}\n\nmp_obj_t mp_prof_frame_enter(mp_code_state_t *code_state) {\n    assert(!mp_prof_is_executing);\n\n    mp_obj_frame_t *frame = MP_OBJ_TO_PTR(mp_obj_new_frame(code_state));\n    if (frame == NULL) {\n        \n        return MP_OBJ_NULL;\n    }\n\n    if (code_state->prev_state && code_state->frame == NULL) {\n        \n        \n        \n        const mp_raw_code_t *rc = code_state->fun_bc->rc;\n        frame->lineno = rc->line_of_definition;\n        if (!rc->line_of_definition) {\n            frame->lineno = mp_prof_bytecode_lineno(rc, 0);\n        }\n    }\n    code_state->frame = frame;\n\n    if (!prof_trace_cb) {\n        return MP_OBJ_NULL;\n    }\n\n    mp_obj_t top;\n    prof_callback_args_t _args, *args = &_args;\n    args->frame = code_state->frame;\n\n    \n    args->event = MP_OBJ_NEW_QSTR(MP_QSTR_call);\n    args->arg = mp_const_none;\n    top = mp_prof_callback_invoke(prof_trace_cb, args);\n\n    code_state->frame->callback = mp_obj_is_callable(top) ? top : MP_OBJ_NULL;\n\n    \n    frame->lineno = 0;\n\n    return top;\n}\n\nmp_obj_t mp_prof_frame_update(const mp_code_state_t *code_state) {\n    mp_obj_frame_t *frame = code_state->frame;\n    if (frame == NULL) {\n        \n        return MP_OBJ_NULL;\n    }\n\n    mp_obj_frame_t *o = frame;\n    mp_obj_code_t *code = o->code;\n    const mp_raw_code_t *rc = code->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n\n    assert(o->code_state == code_state);\n\n    o->lasti = code_state->ip - prelude->opcodes;\n    o->lineno = mp_prof_bytecode_lineno(rc, o->lasti);\n\n    return MP_OBJ_FROM_PTR(o);\n}\n\nmp_obj_t mp_prof_instr_tick(mp_code_state_t *code_state, bool is_exception) {\n    \n    assert(!mp_prof_is_executing);\n    assert(code_state->frame);\n    assert(mp_obj_get_type(code_state->frame) == &mp_type_frame);\n\n    \n    assert(code_state != code_state->prev_state);\n\n    mp_obj_t top = mp_const_none;\n    mp_obj_t callback = code_state->frame->callback;\n\n    prof_callback_args_t _args, *args = &_args;\n    args->frame = code_state->frame;\n    args->event = mp_const_none;\n    args->arg = mp_const_none;\n\n    \n\n    \n    if (is_exception) {\n        args->event = MP_OBJ_NEW_QSTR(MP_QSTR_exception);\n        top = mp_prof_callback_invoke(callback, args);\n        return top;\n    }\n\n    \n    const mp_raw_code_t *rc = code_state->fun_bc->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n    size_t prev_line_no = args->frame->lineno;\n    size_t current_line_no = mp_prof_bytecode_lineno(rc, code_state->ip - prelude->opcodes);\n    if (prev_line_no != current_line_no) {\n        args->frame->lineno = current_line_no;\n        args->event = MP_OBJ_NEW_QSTR(MP_QSTR_line);\n        top = mp_prof_callback_invoke(callback, args);\n    }\n\n    \n    const byte *ip = code_state->ip;\n    if (*ip == MP_BC_RETURN_VALUE || *ip == MP_BC_YIELD_VALUE) {\n        args->event = MP_OBJ_NEW_QSTR(MP_QSTR_return);\n        top = mp_prof_callback_invoke(callback, args);\n        if (code_state->prev_state && *ip == MP_BC_RETURN_VALUE) {\n            code_state->frame->callback = MP_OBJ_NULL;\n        }\n    }\n\n    \n    \n    if (false) {\n        args->event = MP_OBJ_NEW_QSTR(MP_QSTR_opcode);\n    }\n\n    return top;\n}\n\n \n\n\n\n\n\n\n#if MICROPY_PROF_INSTR_DEBUG_PRINT_ENABLE\n\n#include \"runtime0.h\"\n\n#define DECODE_UINT { \\\n        unum = 0; \\\n        do { \\\n            unum = (unum << 7) + (*ip & 0x7f); \\\n        } while ((*ip++ & 0x80) != 0); \\\n}\n#define DECODE_ULABEL do { unum = (ip[0] | (ip[1] << 8)); ip += 2; } while (0)\n#define DECODE_SLABEL do { unum = (ip[0] | (ip[1] << 8)) - 0x8000; ip += 2; } while (0)\n\n#define DECODE_QSTR \\\n    qst = ip[0] | ip[1] << 8; \\\n    ip += 2;\n#define DECODE_PTR \\\n    DECODE_UINT; \\\n    ptr = (const byte *)const_table[unum]\n#define DECODE_OBJ \\\n    DECODE_UINT; \\\n    obj = (mp_obj_t)const_table[unum]\n\ntypedef struct _mp_dis_instruction_t {\n    mp_uint_t qstr_opname;\n    mp_uint_t arg;\n    mp_obj_t argobj;\n    mp_obj_t argobjex_cache;\n} mp_dis_instruction_t;\n\nstatic const byte *mp_prof_opcode_decode(const byte *ip, const mp_uint_t *const_table, mp_dis_instruction_t *instruction) {\n    mp_uint_t unum;\n    const byte *ptr;\n    mp_obj_t obj;\n    qstr qst;\n\n    instruction->qstr_opname = MP_QSTR_;\n    instruction->arg = 0;\n    instruction->argobj = mp_const_none;\n    instruction->argobjex_cache = mp_const_none;\n\n    switch (*ip++) {\n        case MP_BC_LOAD_CONST_FALSE:\n            instruction->qstr_opname = MP_QSTR_LOAD_CONST_FALSE;\n            break;\n\n        case MP_BC_LOAD_CONST_NONE:\n            instruction->qstr_opname = MP_QSTR_LOAD_CONST_NONE;\n            break;\n\n        case MP_BC_LOAD_CONST_TRUE:\n            instruction->qstr_opname = MP_QSTR_LOAD_CONST_TRUE;\n            break;\n\n        case MP_BC_LOAD_CONST_SMALL_INT: {\n            mp_int_t num = 0;\n            if ((ip[0] & 0x40) != 0) {\n                \n                num--;\n            }\n            do {\n                num = (num << 7) | (*ip & 0x7f);\n            } while ((*ip++ & 0x80) != 0);\n            instruction->qstr_opname = MP_QSTR_LOAD_CONST_SMALL_INT;\n            instruction->arg = num;\n            break;\n        }\n\n        case MP_BC_LOAD_CONST_STRING:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_LOAD_CONST_STRING;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_LOAD_CONST_OBJ:\n            DECODE_OBJ;\n            instruction->qstr_opname = MP_QSTR_LOAD_CONST_OBJ;\n            instruction->arg = unum;\n            instruction->argobj = obj;\n            break;\n\n        case MP_BC_LOAD_NULL:\n            instruction->qstr_opname = MP_QSTR_LOAD_NULL;\n            break;\n\n        case MP_BC_LOAD_FAST_N:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_LOAD_FAST_N;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_LOAD_DEREF:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_LOAD_DEREF;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_LOAD_NAME:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_LOAD_NAME;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_LOAD_GLOBAL:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_LOAD_GLOBAL;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_LOAD_ATTR:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_LOAD_ATTR;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_LOAD_METHOD:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_LOAD_METHOD;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_LOAD_SUPER_METHOD:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_LOAD_SUPER_METHOD;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_LOAD_BUILD_CLASS:\n            instruction->qstr_opname = MP_QSTR_LOAD_BUILD_CLASS;\n            break;\n\n        case MP_BC_LOAD_SUBSCR:\n            instruction->qstr_opname = MP_QSTR_LOAD_SUBSCR;\n            break;\n\n        case MP_BC_STORE_FAST_N:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_STORE_FAST_N;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_STORE_DEREF:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_STORE_DEREF;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_STORE_NAME:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_STORE_NAME;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_STORE_GLOBAL:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_STORE_GLOBAL;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_STORE_ATTR:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_STORE_ATTR;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_STORE_SUBSCR:\n            instruction->qstr_opname = MP_QSTR_STORE_SUBSCR;\n            break;\n\n        case MP_BC_DELETE_FAST:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_DELETE_FAST;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_DELETE_DEREF:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_DELETE_DEREF;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_DELETE_NAME:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_DELETE_NAME;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_DELETE_GLOBAL:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_DELETE_GLOBAL;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_DUP_TOP:\n            instruction->qstr_opname = MP_QSTR_DUP_TOP;\n            break;\n\n        case MP_BC_DUP_TOP_TWO:\n            instruction->qstr_opname = MP_QSTR_DUP_TOP_TWO;\n            break;\n\n        case MP_BC_POP_TOP:\n            instruction->qstr_opname = MP_QSTR_POP_TOP;\n            break;\n\n        case MP_BC_ROT_TWO:\n            instruction->qstr_opname = MP_QSTR_ROT_TWO;\n            break;\n\n        case MP_BC_ROT_THREE:\n            instruction->qstr_opname = MP_QSTR_ROT_THREE;\n            break;\n\n        case MP_BC_JUMP:\n            DECODE_SLABEL;\n            instruction->qstr_opname = MP_QSTR_JUMP;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_POP_JUMP_IF_TRUE:\n            DECODE_SLABEL;\n            instruction->qstr_opname = MP_QSTR_POP_JUMP_IF_TRUE;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_POP_JUMP_IF_FALSE:\n            DECODE_SLABEL;\n            instruction->qstr_opname = MP_QSTR_POP_JUMP_IF_FALSE;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_JUMP_IF_TRUE_OR_POP:\n            DECODE_SLABEL;\n            instruction->qstr_opname = MP_QSTR_JUMP_IF_TRUE_OR_POP;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_JUMP_IF_FALSE_OR_POP:\n            DECODE_SLABEL;\n            instruction->qstr_opname = MP_QSTR_JUMP_IF_FALSE_OR_POP;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_SETUP_WITH:\n            DECODE_ULABEL; \n            instruction->qstr_opname = MP_QSTR_SETUP_WITH;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_WITH_CLEANUP:\n            instruction->qstr_opname = MP_QSTR_WITH_CLEANUP;\n            break;\n\n        case MP_BC_UNWIND_JUMP:\n            DECODE_SLABEL;\n            instruction->qstr_opname = MP_QSTR_UNWIND_JUMP;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_SETUP_EXCEPT:\n            DECODE_ULABEL; \n            instruction->qstr_opname = MP_QSTR_SETUP_EXCEPT;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_SETUP_FINALLY:\n            DECODE_ULABEL; \n            instruction->qstr_opname = MP_QSTR_SETUP_FINALLY;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_END_FINALLY:\n            \n            \n            \n            \n            instruction->qstr_opname = MP_QSTR_END_FINALLY;\n            break;\n\n        case MP_BC_GET_ITER:\n            instruction->qstr_opname = MP_QSTR_GET_ITER;\n            break;\n\n        case MP_BC_GET_ITER_STACK:\n            instruction->qstr_opname = MP_QSTR_GET_ITER_STACK;\n            break;\n\n        case MP_BC_FOR_ITER:\n            DECODE_ULABEL; \n            instruction->qstr_opname = MP_QSTR_FOR_ITER;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_BUILD_TUPLE:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_BUILD_TUPLE;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_BUILD_LIST:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_BUILD_LIST;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_BUILD_MAP:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_BUILD_MAP;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_STORE_MAP:\n            instruction->qstr_opname = MP_QSTR_STORE_MAP;\n            break;\n\n        case MP_BC_BUILD_SET:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_BUILD_SET;\n            instruction->arg = unum;\n            break;\n\n        #if MICROPY_PY_BUILTINS_SLICE\n        case MP_BC_BUILD_SLICE:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_BUILD_SLICE;\n            instruction->arg = unum;\n            break;\n        #endif\n\n        case MP_BC_STORE_COMP:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_STORE_COMP;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_UNPACK_SEQUENCE:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_UNPACK_SEQUENCE;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_UNPACK_EX:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_UNPACK_EX;\n            instruction->arg = unum;\n            break;\n\n        case MP_BC_MAKE_FUNCTION:\n            DECODE_PTR;\n            instruction->qstr_opname = MP_QSTR_MAKE_FUNCTION;\n            instruction->arg = unum;\n            instruction->argobj = mp_obj_new_int_from_ull((uint64_t)ptr);\n            break;\n\n        case MP_BC_MAKE_FUNCTION_DEFARGS:\n            DECODE_PTR;\n            instruction->qstr_opname = MP_QSTR_MAKE_FUNCTION_DEFARGS;\n            instruction->arg = unum;\n            instruction->argobj = mp_obj_new_int_from_ull((uint64_t)ptr);\n            break;\n\n        case MP_BC_MAKE_CLOSURE: {\n            DECODE_PTR;\n            mp_uint_t n_closed_over = *ip++;\n            instruction->qstr_opname = MP_QSTR_MAKE_CLOSURE;\n            instruction->arg = unum;\n            instruction->argobj = mp_obj_new_int_from_ull((uint64_t)ptr);\n            instruction->argobjex_cache = MP_OBJ_NEW_SMALL_INT(n_closed_over);\n            break;\n        }\n\n        case MP_BC_MAKE_CLOSURE_DEFARGS: {\n            DECODE_PTR;\n            mp_uint_t n_closed_over = *ip++;\n            instruction->qstr_opname = MP_QSTR_MAKE_CLOSURE_DEFARGS;\n            instruction->arg = unum;\n            instruction->argobj = mp_obj_new_int_from_ull((uint64_t)ptr);\n            instruction->argobjex_cache = MP_OBJ_NEW_SMALL_INT(n_closed_over);\n            break;\n        }\n\n        case MP_BC_CALL_FUNCTION:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_CALL_FUNCTION;\n            instruction->arg = unum & 0xff;\n            instruction->argobjex_cache = MP_OBJ_NEW_SMALL_INT((unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_CALL_FUNCTION_VAR_KW:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_CALL_FUNCTION_VAR_KW;\n            instruction->arg = unum & 0xff;\n            instruction->argobjex_cache = MP_OBJ_NEW_SMALL_INT((unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_CALL_METHOD:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_CALL_METHOD;\n            instruction->arg = unum & 0xff;\n            instruction->argobjex_cache = MP_OBJ_NEW_SMALL_INT((unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_CALL_METHOD_VAR_KW:\n            DECODE_UINT;\n            instruction->qstr_opname = MP_QSTR_CALL_METHOD_VAR_KW;\n            instruction->arg = unum & 0xff;\n            instruction->argobjex_cache = MP_OBJ_NEW_SMALL_INT((unum >> 8) & 0xff);\n            break;\n\n        case MP_BC_RETURN_VALUE:\n            instruction->qstr_opname = MP_QSTR_RETURN_VALUE;\n            break;\n\n        case MP_BC_RAISE_LAST:\n            instruction->qstr_opname = MP_QSTR_RAISE_LAST;\n            break;\n\n        case MP_BC_RAISE_OBJ:\n            instruction->qstr_opname = MP_QSTR_RAISE_OBJ;\n            break;\n\n        case MP_BC_RAISE_FROM:\n            instruction->qstr_opname = MP_QSTR_RAISE_FROM;\n            break;\n\n        case MP_BC_YIELD_VALUE:\n            instruction->qstr_opname = MP_QSTR_YIELD_VALUE;\n            break;\n\n        case MP_BC_YIELD_FROM:\n            instruction->qstr_opname = MP_QSTR_YIELD_FROM;\n            break;\n\n        case MP_BC_IMPORT_NAME:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_IMPORT_NAME;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_IMPORT_FROM:\n            DECODE_QSTR;\n            instruction->qstr_opname = MP_QSTR_IMPORT_FROM;\n            instruction->arg = qst;\n            instruction->argobj = MP_OBJ_NEW_QSTR(qst);\n            break;\n\n        case MP_BC_IMPORT_STAR:\n            instruction->qstr_opname = MP_QSTR_IMPORT_STAR;\n            break;\n\n        default:\n            if (ip[-1] < MP_BC_LOAD_CONST_SMALL_INT_MULTI + 64) {\n                instruction->qstr_opname = MP_QSTR_LOAD_CONST_SMALL_INT;\n                instruction->arg = (mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - 16;\n            } else if (ip[-1] < MP_BC_LOAD_FAST_MULTI + 16) {\n                instruction->qstr_opname = MP_QSTR_LOAD_FAST;\n                instruction->arg = (mp_uint_t)ip[-1] - MP_BC_LOAD_FAST_MULTI;\n            } else if (ip[-1] < MP_BC_STORE_FAST_MULTI + 16) {\n                instruction->qstr_opname = MP_QSTR_STORE_FAST;\n                instruction->arg = (mp_uint_t)ip[-1] - MP_BC_STORE_FAST_MULTI;\n            } else if (ip[-1] < MP_BC_UNARY_OP_MULTI + MP_UNARY_OP_NUM_BYTECODE) {\n                instruction->qstr_opname = MP_QSTR_UNARY_OP;\n                instruction->arg = (mp_uint_t)ip[-1] - MP_BC_UNARY_OP_MULTI;\n            } else if (ip[-1] < MP_BC_BINARY_OP_MULTI + MP_BINARY_OP_NUM_BYTECODE) {\n                mp_uint_t op = ip[-1] - MP_BC_BINARY_OP_MULTI;\n                instruction->qstr_opname = MP_QSTR_BINARY_OP;\n                instruction->arg = op;\n            } else {\n                mp_printf(&mp_plat_print, \"code %p, opcode 0x%02x not implemented\\n\", ip - 1, ip[-1]);\n                assert(0);\n                return ip;\n            }\n            break;\n    }\n\n    return ip;\n}\n\nvoid mp_prof_print_instr(const byte *ip, mp_code_state_t *code_state) {\n    mp_dis_instruction_t _instruction, *instruction = &_instruction;\n    mp_prof_opcode_decode(ip, code_state->fun_bc->rc->const_table, instruction);\n    const mp_raw_code_t *rc = code_state->fun_bc->rc;\n    const mp_bytecode_prelude_t *prelude = &rc->prelude;\n\n    mp_uint_t offset = ip - prelude->opcodes;\n    mp_printf(&mp_plat_print, \"instr\");\n\n      if (1) {\n        mp_printf(&mp_plat_print,\n            \"@0x%p:%q:%q+0x%04x:%d\",\n            ip,\n            prelude->qstr_source_file,\n            prelude->qstr_block_name,\n            offset,\n            mp_prof_bytecode_lineno(rc, offset)\n            );\n    }\n\n      if (0) {\n        mp_printf(&mp_plat_print, \" %02x %02x %02x %02x\", ip[0], ip[1], ip[2], ip[3]);\n    }\n\n    mp_printf(&mp_plat_print, \" 0x%02x %q [%d]\", *ip, instruction->qstr_opname, instruction->arg);\n\n    if (instruction->argobj != mp_const_none) {\n        mp_printf(&mp_plat_print, \" $\");\n        mp_obj_print_helper(&mp_plat_print, instruction->argobj, PRINT_REPR);\n    }\n    if (instruction->argobjex_cache != mp_const_none) {\n        mp_printf(&mp_plat_print, \" #\");\n        mp_obj_print_helper(&mp_plat_print, instruction->argobjex_cache, PRINT_REPR);\n    }\n\n    mp_printf(&mp_plat_print, \"\\n\");\n}\n\n#endif \n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}