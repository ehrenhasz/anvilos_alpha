{
  "module_name": "vstr.c",
  "hash_id": "3c33ebf56b27d4386809228bc48cd490be3f218fa79ce2ecae72f08829ab2b6e",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/vstr.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/mpconfig.h\"\n#include \"py/runtime.h\"\n#include \"py/mpprint.h\"\n\n\n#define ROUND_ALLOC(a) (((a) & ((~0U) - 7)) + 8)\n\n\nvoid vstr_init(vstr_t *vstr, size_t alloc) {\n    if (alloc < 1) {\n        alloc = 1;\n    }\n    vstr->alloc = alloc;\n    vstr->len = 0;\n    vstr->buf = m_new(char, vstr->alloc);\n    vstr->fixed_buf = false;\n}\n\n\n\nvoid vstr_init_len(vstr_t *vstr, size_t len) {\n    vstr_init(vstr, len + 1);\n    vstr->len = len;\n}\n\nvoid vstr_init_fixed_buf(vstr_t *vstr, size_t alloc, char *buf) {\n    vstr->alloc = alloc;\n    vstr->len = 0;\n    vstr->buf = buf;\n    vstr->fixed_buf = true;\n}\n\nvoid vstr_init_print(vstr_t *vstr, size_t alloc, mp_print_t *print) {\n    vstr_init(vstr, alloc);\n    print->data = vstr;\n    print->print_strn = (mp_print_strn_t)vstr_add_strn;\n}\n\nvoid vstr_clear(vstr_t *vstr) {\n    if (!vstr->fixed_buf) {\n        m_del(char, vstr->buf, vstr->alloc);\n    }\n    vstr->buf = NULL;\n}\n\nvstr_t *vstr_new(size_t alloc) {\n    vstr_t *vstr = m_new_obj(vstr_t);\n    vstr_init(vstr, alloc);\n    return vstr;\n}\n\nvoid vstr_free(vstr_t *vstr) {\n    if (vstr != NULL) {\n        if (!vstr->fixed_buf) {\n            m_del(char, vstr->buf, vstr->alloc);\n        }\n        m_del_obj(vstr_t, vstr);\n    }\n}\n\n\nchar *vstr_extend(vstr_t *vstr, size_t size) {\n    if (vstr->fixed_buf) {\n        \n        \n        mp_raise_msg(&mp_type_RuntimeError, NULL);\n    }\n    char *new_buf = m_renew(char, vstr->buf, vstr->alloc, vstr->alloc + size);\n    char *p = new_buf + vstr->alloc;\n    vstr->alloc += size;\n    vstr->buf = new_buf;\n    return p;\n}\n\nstatic void vstr_ensure_extra(vstr_t *vstr, size_t size) {\n    if (vstr->len + size > vstr->alloc) {\n        if (vstr->fixed_buf) {\n            \n            \n            mp_raise_msg(&mp_type_RuntimeError, NULL);\n        }\n        size_t new_alloc = ROUND_ALLOC((vstr->len + size) + 16);\n        char *new_buf = m_renew(char, vstr->buf, vstr->alloc, new_alloc);\n        vstr->alloc = new_alloc;\n        vstr->buf = new_buf;\n    }\n}\n\nvoid vstr_hint_size(vstr_t *vstr, size_t size) {\n    vstr_ensure_extra(vstr, size);\n}\n\nchar *vstr_add_len(vstr_t *vstr, size_t len) {\n    vstr_ensure_extra(vstr, len);\n    char *buf = vstr->buf + vstr->len;\n    vstr->len += len;\n    return buf;\n}\n\n\nchar *vstr_null_terminated_str(vstr_t *vstr) {\n    \n    if (vstr->alloc == vstr->len) {\n        vstr_extend(vstr, 1);\n    }\n    vstr->buf[vstr->len] = '\\0';\n    return vstr->buf;\n}\n\nvoid vstr_add_byte(vstr_t *vstr, byte b) {\n    byte *buf = (byte *)vstr_add_len(vstr, 1);\n    buf[0] = b;\n}\n\nvoid vstr_add_char(vstr_t *vstr, unichar c) {\n    #if MICROPY_PY_BUILTINS_STR_UNICODE\n    \n    \n    if (c < 0x80) {\n        byte *buf = (byte *)vstr_add_len(vstr, 1);\n        *buf = (byte)c;\n    } else if (c < 0x800) {\n        byte *buf = (byte *)vstr_add_len(vstr, 2);\n        buf[0] = (c >> 6) | 0xC0;\n        buf[1] = (c & 0x3F) | 0x80;\n    } else if (c < 0x10000) {\n        byte *buf = (byte *)vstr_add_len(vstr, 3);\n        buf[0] = (c >> 12) | 0xE0;\n        buf[1] = ((c >> 6) & 0x3F) | 0x80;\n        buf[2] = (c & 0x3F) | 0x80;\n    } else {\n        assert(c < 0x110000);\n        byte *buf = (byte *)vstr_add_len(vstr, 4);\n        buf[0] = (c >> 18) | 0xF0;\n        buf[1] = ((c >> 12) & 0x3F) | 0x80;\n        buf[2] = ((c >> 6) & 0x3F) | 0x80;\n        buf[3] = (c & 0x3F) | 0x80;\n    }\n    #else\n    vstr_add_byte(vstr, c);\n    #endif\n}\n\nvoid vstr_add_str(vstr_t *vstr, const char *str) {\n    vstr_add_strn(vstr, str, strlen(str));\n}\n\nvoid vstr_add_strn(vstr_t *vstr, const char *str, size_t len) {\n    vstr_ensure_extra(vstr, len);\n    memmove(vstr->buf + vstr->len, str, len);\n    vstr->len += len;\n}\n\nstatic char *vstr_ins_blank_bytes(vstr_t *vstr, size_t byte_pos, size_t byte_len) {\n    size_t l = vstr->len;\n    if (byte_pos > l) {\n        byte_pos = l;\n    }\n    if (byte_len > 0) {\n        \n        vstr_ensure_extra(vstr, byte_len);\n        \n        memmove(vstr->buf + byte_pos + byte_len, vstr->buf + byte_pos, l - byte_pos);\n        \n        vstr->len += byte_len;\n    }\n    return vstr->buf + byte_pos;\n}\n\nvoid vstr_ins_byte(vstr_t *vstr, size_t byte_pos, byte b) {\n    char *s = vstr_ins_blank_bytes(vstr, byte_pos, 1);\n    *s = b;\n}\n\nvoid vstr_ins_char(vstr_t *vstr, size_t char_pos, unichar chr) {\n    \n    char *s = vstr_ins_blank_bytes(vstr, char_pos, 1);\n    *s = chr;\n}\n\nvoid vstr_cut_head_bytes(vstr_t *vstr, size_t bytes_to_cut) {\n    vstr_cut_out_bytes(vstr, 0, bytes_to_cut);\n}\n\nvoid vstr_cut_tail_bytes(vstr_t *vstr, size_t len) {\n    if (len > vstr->len) {\n        vstr->len = 0;\n    } else {\n        vstr->len -= len;\n    }\n}\n\nvoid vstr_cut_out_bytes(vstr_t *vstr, size_t byte_pos, size_t bytes_to_cut) {\n    if (byte_pos >= vstr->len) {\n        return;\n    } else if (byte_pos + bytes_to_cut >= vstr->len) {\n        vstr->len = byte_pos;\n    } else {\n        memmove(vstr->buf + byte_pos, vstr->buf + byte_pos + bytes_to_cut, vstr->len - byte_pos - bytes_to_cut);\n        vstr->len -= bytes_to_cut;\n    }\n}\n\nvoid vstr_printf(vstr_t *vstr, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vstr_vprintf(vstr, fmt, ap);\n    va_end(ap);\n}\n\nvoid vstr_vprintf(vstr_t *vstr, const char *fmt, va_list ap) {\n    mp_print_t print = {vstr, (mp_print_strn_t)vstr_add_strn};\n    mp_vprintf(&print, fmt, ap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}