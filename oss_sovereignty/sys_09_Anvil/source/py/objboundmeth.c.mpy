{
  "module_name": "objboundmeth.c",
  "hash_id": "f3059034b6364610cd5fc980af0a20700b5abf3a92631943a47af5ffa4be3e75",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objboundmeth.c",
  "human_readable_source": " \n\n#include <string.h>\n\n#include \"py/obj.h\"\n#include \"py/runtime.h\"\n\ntypedef struct _mp_obj_bound_meth_t {\n    mp_obj_base_t base;\n    mp_obj_t meth;\n    mp_obj_t self;\n} mp_obj_bound_meth_t;\n\n#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED\nstatic void bound_meth_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_bound_meth_t *o = MP_OBJ_TO_PTR(o_in);\n    mp_printf(print, \"<bound_method %p \", o);\n    mp_obj_print_helper(print, o->self, PRINT_REPR);\n    mp_print_str(print, \".\");\n    mp_obj_print_helper(print, o->meth, PRINT_REPR);\n    mp_print_str(print, \">\");\n}\n#endif\n\nmp_obj_t mp_call_method_self_n_kw(mp_obj_t meth, mp_obj_t self, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n    size_t n_total = n_args + 2 * n_kw;\n    mp_obj_t *args2 = NULL;\n    #if MICROPY_ENABLE_PYSTACK\n    args2 = mp_pystack_alloc(sizeof(mp_obj_t) * (1 + n_total));\n    #else\n    mp_obj_t *free_args2 = NULL;\n    if (n_total > 4) {\n        \n        args2 = m_new_maybe(mp_obj_t, 1 + n_total);\n        free_args2 = args2;\n    }\n    if (args2 == NULL) {\n        \n        args2 = alloca(sizeof(mp_obj_t) * (1 + n_total));\n    }\n    #endif\n    args2[0] = self;\n    memcpy(args2 + 1, args, n_total * sizeof(mp_obj_t));\n    mp_obj_t res = mp_call_function_n_kw(meth, n_args + 1, n_kw, args2);\n    #if MICROPY_ENABLE_PYSTACK\n    mp_pystack_free(args2);\n    #else\n    if (free_args2 != NULL) {\n        m_del(mp_obj_t, free_args2, 1 + n_total);\n    }\n    #endif\n    return res;\n}\n\nstatic mp_obj_t bound_meth_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_bound_meth_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_call_method_self_n_kw(self->meth, self->self, n_args, n_kw, args);\n}\n\nstatic mp_obj_t bound_meth_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_bound_meth_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_HASH:\n            return MP_OBJ_NEW_SMALL_INT((mp_uint_t)self->self ^ (mp_uint_t)self->meth);\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\nstatic mp_obj_t bound_meth_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    \n    \n    \n    if (op != MP_BINARY_OP_EQUAL) {\n        return MP_OBJ_NULL; \n    }\n    mp_obj_bound_meth_t *lhs = MP_OBJ_TO_PTR(lhs_in);\n    mp_obj_bound_meth_t *rhs = MP_OBJ_TO_PTR(rhs_in);\n    return mp_obj_new_bool(lhs->self == rhs->self && lhs->meth == rhs->meth);\n}\n\n#if MICROPY_PY_FUNCTION_ATTRS\nstatic void bound_meth_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n    \n    mp_obj_bound_meth_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_load_method_maybe(self->meth, attr, dest);\n}\n#endif\n\n#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED\n#define BOUND_METH_TYPE_PRINT print, bound_meth_print,\n#else\n#define BOUND_METH_TYPE_PRINT\n#endif\n\n#if MICROPY_PY_FUNCTION_ATTRS\n#define BOUND_METH_TYPE_ATTR attr, bound_meth_attr,\n#else\n#define BOUND_METH_TYPE_ATTR\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bound_meth,\n    MP_QSTR_bound_method,\n    MP_TYPE_FLAG_NONE,\n    BOUND_METH_TYPE_PRINT\n    BOUND_METH_TYPE_ATTR\n    call, bound_meth_call,\n    unary_op, bound_meth_unary_op,\n    binary_op, bound_meth_binary_op\n    );\n\nmp_obj_t mp_obj_new_bound_meth(mp_obj_t meth, mp_obj_t self) {\n    mp_obj_bound_meth_t *o = mp_obj_malloc(mp_obj_bound_meth_t, &mp_type_bound_meth);\n    o->meth = meth;\n    o->self = self;\n    return MP_OBJ_FROM_PTR(o);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}