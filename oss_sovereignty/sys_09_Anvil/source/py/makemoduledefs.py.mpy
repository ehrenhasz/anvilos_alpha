{
  "module_name": "makemoduledefs.py",
  "hash_id": "a74b55dfd9dcb37c7fc0d6d1f37b1af77e16aa0ab385de6369a5d2ae699b5b9f",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/makemoduledefs.py",
  "human_readable_source": "\"\"\"\nThis pre-processor parses a single file containing a list of\n`MP_REGISTER_MODULE(MP_QSTR_module_name, obj_module)` or\n`MP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_module_name, obj_module)`\n(i.e. the output of `py/makeqstrdefs.py cat module`).\n\nThe output is a header (typically moduledefs.h) which is included by\npy/objmodule.c that contains entries to be included in the definition of\n - mp_rom_map_elem_t mp_builtin_module_table[]\n - mp_rom_map_elem_t mp_builtin_extensible_module_table[]\n\nExtensible modules are modules that can be overridden from the filesystem, see\npy/builtinimnport.c:process_import_at_level. Regular modules will always use\nthe built-in version.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\nimport re\nimport io\nimport argparse\n\n\nregister_pattern = re.compile(\n    r\"\\s*(MP_REGISTER_MODULE|MP_REGISTER_EXTENSIBLE_MODULE)\\(MP_QSTR_(.*?),\\s*(.*?)\\);\",\n    flags=re.DOTALL,\n)\n\ndelegation_pattern = re.compile(\n    r\"\\s*(?:MP_REGISTER_MODULE_DELEGATION)\\((.*?),\\s*(.*?)\\);\",\n    flags=re.DOTALL,\n)\n\n\ndef find_module_registrations(filename):\n    \"\"\"Find any MP_REGISTER_MODULE definitions in the provided file.\n\n    :param str filename: path to file to check\n    :return: List[(module_name, obj_module)]\n    \"\"\"\n    global pattern\n\n    with io.open(filename, encoding=\"utf-8\") as c_file_obj:\n        c = c_file_obj.read()\n        return set(re.findall(register_pattern, c)), set(re.findall(delegation_pattern, c))\n\n\ndef generate_module_table_header(modules):\n    \"\"\"Generate header with module table entries for builtin modules.\n\n    :param List[(module_name, obj_module)] modules: module defs\n    :return: None\n    \"\"\"\n\n    # Print header file for all external modules.\n    mod_defs = set()\n    extensible_mod_defs = set()\n    for macro_name, module_name, obj_module in modules:\n        mod_def = \"MODULE_DEF_{}\".format(module_name.upper())\n        if macro_name == \"MP_REGISTER_MODULE\":\n            mod_defs.add(mod_def)\n        elif macro_name == \"MP_REGISTER_EXTENSIBLE_MODULE\":\n            extensible_mod_defs.add(mod_def)\n        if \",\" in obj_module:\n            print(\n                \"ERROR: Call to {}({}, {}) should be {}({}, {})\\n\".format(\n                    macro_name,\n                    module_name,\n                    obj_module,\n                    macro_name,\n                    module_name,\n                    obj_module.split(\",\")[0],\n                ),\n                file=sys.stderr,\n            )\n            sys.exit(1)\n        print(\n            (\n                \"extern const struct _mp_obj_module_t {obj_module};\\n\"\n                \"#undef {mod_def}\\n\"\n                \"#define {mod_def} {{ MP_ROM_QSTR(MP_QSTR_{module_name}), MP_ROM_PTR(&{obj_module}) }},\\n\"\n            ).format(\n                module_name=module_name,\n                obj_module=obj_module,\n                mod_def=mod_def,\n            )\n        )\n\n    print(\"\\n#define MICROPY_REGISTERED_MODULES \\\\\")\n\n    for mod_def in sorted(mod_defs):\n        print(\"    {mod_def} \\\\\".format(mod_def=mod_def))\n\n    print(\"// MICROPY_REGISTERED_MODULES\")\n\n    print(\"\\n#define MICROPY_REGISTERED_EXTENSIBLE_MODULES \\\\\")\n\n    for mod_def in sorted(extensible_mod_defs):\n        print(\"    {mod_def} \\\\\".format(mod_def=mod_def))\n\n    print(\"// MICROPY_REGISTERED_EXTENSIBLE_MODULES\")\n\n\ndef generate_module_delegations(delegations):\n    if not delegations:\n        return\n\n    print()\n    for obj_module, fun_name in delegations:\n        print(\"extern void {}(mp_obj_t self_in, qstr attr, mp_obj_t *dest);\".format(fun_name))\n    print(\"#define MICROPY_MODULE_DELEGATIONS \\\\\")\n    for obj_module, fun_name in delegations:\n        print(\n            \"    {{ MP_ROM_PTR(&{obj_module}), {fun_name} }}, \\\\\".format(\n                obj_module=obj_module, fun_name=fun_name\n            )\n        )\n    print(\"// MICROPY_MODULE_DELEGATIONS\")\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"file\", nargs=1, help=\"file with MP_REGISTER_MODULE definitions\")\n    args = parser.parse_args()\n\n    print(\"// Automatically generated by makemoduledefs.py.\\n\")\n\n    modules, delegations = find_module_registrations(args.file[0])\n    generate_module_table_header(sorted(modules))\n    generate_module_delegations(sorted(delegations))\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}