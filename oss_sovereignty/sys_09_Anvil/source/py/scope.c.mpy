{
  "module_name": "scope.c",
  "hash_id": "b8311cd916844288024f374bc3a21e5c56c6026c4ec7218c9f3b82b1ba040911",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/scope.c",
  "human_readable_source": " \n\n#include <assert.h>\n\n#include \"py/scope.h\"\n\n#if MICROPY_ENABLE_COMPILER\n\n\n\n\nstatic const uint8_t scope_simple_name_table[] = {\n    [SCOPE_MODULE] = MP_QSTR__lt_module_gt_,\n    [SCOPE_LAMBDA] = MP_QSTR__lt_lambda_gt_,\n    [SCOPE_LIST_COMP] = MP_QSTR__lt_listcomp_gt_,\n    [SCOPE_DICT_COMP] = MP_QSTR__lt_dictcomp_gt_,\n    [SCOPE_SET_COMP] = MP_QSTR__lt_setcomp_gt_,\n    [SCOPE_GEN_EXPR] = MP_QSTR__lt_genexpr_gt_,\n};\n\nscope_t *scope_new(scope_kind_t kind, mp_parse_node_t pn, mp_uint_t emit_options) {\n    \n    MP_STATIC_ASSERT(MP_QSTR__lt_module_gt_ <= UINT8_MAX);\n    MP_STATIC_ASSERT(MP_QSTR__lt_lambda_gt_ <= UINT8_MAX);\n    MP_STATIC_ASSERT(MP_QSTR__lt_listcomp_gt_ <= UINT8_MAX);\n    MP_STATIC_ASSERT(MP_QSTR__lt_dictcomp_gt_ <= UINT8_MAX);\n    MP_STATIC_ASSERT(MP_QSTR__lt_setcomp_gt_ <= UINT8_MAX);\n    MP_STATIC_ASSERT(MP_QSTR__lt_genexpr_gt_ <= UINT8_MAX);\n\n    scope_t *scope = m_new0(scope_t, 1);\n    scope->kind = kind;\n    scope->pn = pn;\n    if (kind == SCOPE_FUNCTION || kind == SCOPE_CLASS) {\n        assert(MP_PARSE_NODE_IS_STRUCT(pn));\n        scope->simple_name = MP_PARSE_NODE_LEAF_ARG(((mp_parse_node_struct_t *)pn)->nodes[0]);\n    } else {\n        scope->simple_name = scope_simple_name_table[kind];\n    }\n    scope->raw_code = mp_emit_glue_new_raw_code();\n    scope->emit_options = emit_options;\n    scope->id_info_alloc = MICROPY_ALLOC_SCOPE_ID_INIT;\n    scope->id_info = m_new(id_info_t, scope->id_info_alloc);\n\n    return scope;\n}\n\nvoid scope_free(scope_t *scope) {\n    m_del(id_info_t, scope->id_info, scope->id_info_alloc);\n    m_del(scope_t, scope, 1);\n}\n\nid_info_t *scope_find_or_add_id(scope_t *scope, qstr qst, id_info_kind_t kind) {\n    id_info_t *id_info = scope_find(scope, qst);\n    if (id_info != NULL) {\n        return id_info;\n    }\n\n    \n    if (scope->id_info_len >= scope->id_info_alloc) {\n        scope->id_info = m_renew(id_info_t, scope->id_info, scope->id_info_alloc, scope->id_info_alloc + MICROPY_ALLOC_SCOPE_ID_INC);\n        scope->id_info_alloc += MICROPY_ALLOC_SCOPE_ID_INC;\n    }\n\n    \n    \n    \n    id_info = &scope->id_info[scope->id_info_len++];\n\n    id_info->kind = kind;\n    id_info->flags = 0;\n    id_info->local_num = 0;\n    id_info->qst = qst;\n    return id_info;\n}\n\nid_info_t *scope_find(scope_t *scope, qstr qst) {\n    for (mp_uint_t i = 0; i < scope->id_info_len; i++) {\n        if (scope->id_info[i].qst == qst) {\n            return &scope->id_info[i];\n        }\n    }\n    return NULL;\n}\n\nid_info_t *scope_find_global(scope_t *scope, qstr qst) {\n    while (scope->parent != NULL) {\n        scope = scope->parent;\n    }\n    return scope_find(scope, qst);\n}\n\nstatic void scope_close_over_in_parents(scope_t *scope, qstr qst) {\n    assert(scope->parent != NULL); \n    for (scope_t *s = scope->parent;; s = s->parent) {\n        assert(s->parent != NULL); \n        id_info_t *id = scope_find_or_add_id(s, qst, ID_INFO_KIND_UNDECIDED);\n        if (id->kind == ID_INFO_KIND_UNDECIDED) {\n            \n            id->kind = ID_INFO_KIND_FREE;\n        } else {\n            \n            if (id->kind == ID_INFO_KIND_LOCAL) {\n                \n                id->kind = ID_INFO_KIND_CELL;\n            } else {\n                \n                \n                assert(id->kind == ID_INFO_KIND_FREE || id->kind == ID_INFO_KIND_CELL);\n            }\n            return;\n        }\n    }\n}\n\nvoid scope_check_to_close_over(scope_t *scope, id_info_t *id) {\n    if (scope->parent != NULL) {\n        for (scope_t *s = scope->parent; s->parent != NULL; s = s->parent) {\n            id_info_t *id2 = scope_find(s, id->qst);\n            if (id2 != NULL) {\n                if (id2->kind == ID_INFO_KIND_LOCAL || id2->kind == ID_INFO_KIND_CELL || id2->kind == ID_INFO_KIND_FREE) {\n                    id->kind = ID_INFO_KIND_FREE;\n                    scope_close_over_in_parents(scope, id->qst);\n                }\n                break;\n            }\n        }\n    }\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}