{
  "module_name": "stream.c",
  "hash_id": "4b3f38780e76d84be7079f4b3da327cf405d929678775e55333365de647b01cd",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/stream.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <unistd.h>\n\n#include \"py/objstr.h\"\n#include \"py/stream.h\"\n#include \"py/runtime.h\"\n\n\n\n\n\n#define DEFAULT_BUFFER_SIZE 256\n\nstatic mp_obj_t stream_readall(mp_obj_t self_in);\n\n\n\n\nmp_uint_t mp_stream_rw(mp_obj_t stream, void *buf_, mp_uint_t size, int *errcode, byte flags) {\n    byte *buf = buf_;\n    typedef mp_uint_t (*io_func_t)(mp_obj_t obj, void *buf, mp_uint_t size, int *errcode);\n    io_func_t io_func;\n    const mp_stream_p_t *stream_p = mp_get_stream(stream);\n    if (flags & MP_STREAM_RW_WRITE) {\n        io_func = (io_func_t)stream_p->write;\n    } else {\n        io_func = stream_p->read;\n    }\n\n    *errcode = 0;\n    mp_uint_t done = 0;\n    while (size > 0) {\n        mp_uint_t out_sz = io_func(stream, buf, size, errcode);\n        \n        \n        \n        if (out_sz == 0) {\n            return done;\n        }\n        if (out_sz == MP_STREAM_ERROR) {\n            \n            if (mp_is_nonblocking_error(*errcode) && done != 0) {\n                *errcode = 0;\n            }\n            return done;\n        }\n        if (flags & MP_STREAM_RW_ONCE) {\n            return out_sz;\n        }\n\n        buf += out_sz;\n        size -= out_sz;\n        done += out_sz;\n    }\n    return done;\n}\n\nmp_off_t mp_stream_seek(mp_obj_t stream, mp_off_t offset, int whence, int *errcode) {\n    struct mp_stream_seek_t seek_s;\n    seek_s.offset = offset;\n    seek_s.whence = whence;\n    const mp_stream_p_t *stream_p = mp_get_stream(stream);\n    mp_uint_t res = stream_p->ioctl(MP_OBJ_FROM_PTR(stream), MP_STREAM_SEEK, (mp_uint_t)(uintptr_t)&seek_s, errcode);\n    if (res == MP_STREAM_ERROR) {\n        return (mp_off_t)-1;\n    }\n    return seek_s.offset;\n}\n\nconst mp_stream_p_t *mp_get_stream_raise(mp_obj_t self_in, int flags) {\n    const mp_obj_type_t *type = mp_obj_get_type(self_in);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, protocol)) {\n        const mp_stream_p_t *stream_p = MP_OBJ_TYPE_GET_SLOT(type, protocol);\n        if (!((flags & MP_STREAM_OP_READ) && stream_p->read == NULL)\n            && !((flags & MP_STREAM_OP_WRITE) && stream_p->write == NULL)\n            && !((flags & MP_STREAM_OP_IOCTL) && stream_p->ioctl == NULL)) {\n            return stream_p;\n        }\n    }\n    \n    mp_raise_msg(&mp_type_OSError, MP_ERROR_TEXT(\"stream operation not supported\"));\n}\n\nstatic mp_obj_t stream_read_generic(size_t n_args, const mp_obj_t *args, byte flags) {\n    \n    \n    \n    mp_int_t sz;\n    if (n_args == 1 || ((sz = mp_obj_get_int(args[1])) == -1)) {\n        return stream_readall(args[0]);\n    }\n\n    const mp_stream_p_t *stream_p = mp_get_stream(args[0]);\n\n    #if MICROPY_PY_BUILTINS_STR_UNICODE\n    if (stream_p->is_text) {\n        \n        \n        \n        \n        \n        \n        \n        \n\n        vstr_t vstr;\n        vstr_init(&vstr, sz);\n        mp_uint_t more_bytes = sz;\n        mp_uint_t last_buf_offset = 0;\n        while (more_bytes > 0) {\n            char *p = vstr_add_len(&vstr, more_bytes);\n            int error;\n            mp_uint_t out_sz = mp_stream_read_exactly(args[0], p, more_bytes, &error);\n            if (error != 0) {\n                vstr_cut_tail_bytes(&vstr, more_bytes);\n                if (mp_is_nonblocking_error(error)) {\n                    \n                    \n                    \n                    \n                    if (vstr.len == 0) {\n                        vstr_clear(&vstr);\n                        return mp_const_none;\n                    }\n                    break;\n                }\n                mp_raise_OSError(error);\n            }\n\n            if (out_sz < more_bytes) {\n                \n                \n                vstr_cut_tail_bytes(&vstr, more_bytes - out_sz);\n                if (out_sz == 0) {\n                    break;\n                }\n            }\n\n            \n            for (mp_uint_t off = last_buf_offset;;) {\n                byte b = vstr.buf[off];\n                int n;\n                if (!UTF8_IS_NONASCII(b)) {\n                    \n                    n = 1;\n                } else if ((b & 0xe0) == 0xc0) {\n                    \n                    n = 2;\n                } else if ((b & 0xf0) == 0xe0) {\n                    \n                    n = 3;\n                } else if ((b & 0xf8) == 0xf0) {\n                    \n                    n = 4;\n                } else {\n                    \n                    n = 5;\n                }\n                if (off + n <= vstr.len) {\n                    \n                    off += n;\n                    sz -= 1;\n                    last_buf_offset = off;\n                    if (off >= vstr.len) {\n                        more_bytes = sz;\n                        break;\n                    }\n                } else {\n                    \n                    \n                    more_bytes = (off + n - vstr.len) + (sz - 1);\n                    break;\n                }\n            }\n        }\n\n        return mp_obj_new_str_from_vstr(&vstr);\n    }\n    #endif\n\n    vstr_t vstr;\n    vstr_init_len(&vstr, sz);\n    int error;\n    mp_uint_t out_sz = mp_stream_rw(args[0], vstr.buf, sz, &error, flags);\n    if (error != 0) {\n        vstr_clear(&vstr);\n        if (mp_is_nonblocking_error(error)) {\n            \n            \n            \n            \n            \n            return mp_const_none;\n        }\n        mp_raise_OSError(error);\n    } else {\n        vstr.len = out_sz;\n        if (stream_p->is_text) {\n            return mp_obj_new_str_from_vstr(&vstr);\n        } else {\n            return mp_obj_new_bytes_from_vstr(&vstr);\n        }\n    }\n}\n\nstatic mp_obj_t stream_read(size_t n_args, const mp_obj_t *args) {\n    return stream_read_generic(n_args, args, MP_STREAM_RW_READ);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_read_obj, 1, 2, stream_read);\n\nstatic mp_obj_t stream_read1(size_t n_args, const mp_obj_t *args) {\n    return stream_read_generic(n_args, args, MP_STREAM_RW_READ | MP_STREAM_RW_ONCE);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_read1_obj, 1, 2, stream_read1);\n\nmp_obj_t mp_stream_write(mp_obj_t self_in, const void *buf, size_t len, byte flags) {\n    int error;\n    mp_uint_t out_sz = mp_stream_rw(self_in, (void *)buf, len, &error, flags);\n    if (error != 0) {\n        if (mp_is_nonblocking_error(error)) {\n            \n            \n            \n            return mp_const_none;\n        }\n        mp_raise_OSError(error);\n    } else {\n        return MP_OBJ_NEW_SMALL_INT(out_sz);\n    }\n}\n\n\nvoid mp_stream_write_adaptor(void *self, const char *buf, size_t len) {\n    mp_stream_write(MP_OBJ_FROM_PTR(self), buf, len, MP_STREAM_RW_WRITE);\n}\n\nstatic mp_obj_t stream_write_method(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_READ);\n    size_t max_len = (size_t)-1;\n    size_t off = 0;\n    if (n_args == 3) {\n        max_len = mp_obj_get_int_truncated(args[2]);\n    } else if (n_args == 4) {\n        off = mp_obj_get_int_truncated(args[2]);\n        max_len = mp_obj_get_int_truncated(args[3]);\n        if (off > bufinfo.len) {\n            off = bufinfo.len;\n        }\n    }\n    bufinfo.len -= off;\n    return mp_stream_write(args[0], (byte *)bufinfo.buf + off, MIN(bufinfo.len, max_len), MP_STREAM_RW_WRITE);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_write_obj, 2, 4, stream_write_method);\n\nstatic mp_obj_t stream_write1_method(mp_obj_t self_in, mp_obj_t arg) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(arg, &bufinfo, MP_BUFFER_READ);\n    return mp_stream_write(self_in, bufinfo.buf, bufinfo.len, MP_STREAM_RW_WRITE | MP_STREAM_RW_ONCE);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_stream_write1_obj, stream_write1_method);\n\nstatic mp_obj_t stream_readinto(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[1], &bufinfo, MP_BUFFER_WRITE);\n\n    \n    \n    \n    mp_uint_t len = bufinfo.len;\n    if (n_args > 2) {\n        len = mp_obj_get_int(args[2]);\n        if (len > bufinfo.len) {\n            len = bufinfo.len;\n        }\n    }\n\n    int error;\n    mp_uint_t out_sz = mp_stream_read_exactly(args[0], bufinfo.buf, len, &error);\n    if (error != 0) {\n        if (mp_is_nonblocking_error(error)) {\n            return mp_const_none;\n        }\n        mp_raise_OSError(error);\n    } else {\n        return MP_OBJ_NEW_SMALL_INT(out_sz);\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_readinto_obj, 2, 3, stream_readinto);\n\nstatic mp_obj_t stream_readall(mp_obj_t self_in) {\n    const mp_stream_p_t *stream_p = mp_get_stream(self_in);\n\n    mp_uint_t total_size = 0;\n    vstr_t vstr;\n    vstr_init(&vstr, DEFAULT_BUFFER_SIZE);\n    char *p = vstr.buf;\n    mp_uint_t current_read = DEFAULT_BUFFER_SIZE;\n    while (true) {\n        int error;\n        mp_uint_t out_sz = stream_p->read(self_in, p, current_read, &error);\n        if (out_sz == MP_STREAM_ERROR) {\n            if (mp_is_nonblocking_error(error)) {\n                \n                \n                \n                if (total_size == 0) {\n                    return mp_const_none;\n                }\n                break;\n            }\n            mp_raise_OSError(error);\n        }\n        if (out_sz == 0) {\n            break;\n        }\n        total_size += out_sz;\n        if (out_sz < current_read) {\n            current_read -= out_sz;\n            p += out_sz;\n        } else {\n            p = vstr_extend(&vstr, DEFAULT_BUFFER_SIZE);\n            current_read = DEFAULT_BUFFER_SIZE;\n        }\n    }\n\n    vstr.len = total_size;\n    if (stream_p->is_text) {\n        return mp_obj_new_str_from_vstr(&vstr);\n    } else {\n        return mp_obj_new_bytes_from_vstr(&vstr);\n    }\n}\n\n\nstatic mp_obj_t stream_unbuffered_readline(size_t n_args, const mp_obj_t *args) {\n    const mp_stream_p_t *stream_p = mp_get_stream(args[0]);\n\n    mp_int_t max_size = -1;\n    if (n_args > 1) {\n        max_size = MP_OBJ_SMALL_INT_VALUE(args[1]);\n    }\n\n    vstr_t vstr;\n    if (max_size != -1) {\n        vstr_init(&vstr, max_size);\n    } else {\n        vstr_init(&vstr, 16);\n    }\n\n    while (max_size == -1 || max_size-- != 0) {\n        char *p = vstr_add_len(&vstr, 1);\n        int error;\n        mp_uint_t out_sz = stream_p->read(args[0], p, 1, &error);\n        if (out_sz == MP_STREAM_ERROR) {\n            if (mp_is_nonblocking_error(error)) {\n                if (vstr.len == 1) {\n                    \n                    \n                    \n                    \n                    \n                    \n                    vstr_clear(&vstr);\n                    return mp_const_none;\n                } else {\n                    goto done;\n                }\n            }\n            mp_raise_OSError(error);\n        }\n        if (out_sz == 0) {\n        done:\n            \n            \n            \n            vstr_cut_tail_bytes(&vstr, 1);\n            break;\n        }\n        if (*p == '\\n') {\n            break;\n        }\n    }\n\n    if (stream_p->is_text) {\n        return mp_obj_new_str_from_vstr(&vstr);\n    } else {\n        return mp_obj_new_bytes_from_vstr(&vstr);\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_unbuffered_readline_obj, 1, 2, stream_unbuffered_readline);\n\n\nstatic mp_obj_t stream_unbuffered_readlines(mp_obj_t self) {\n    mp_obj_t lines = mp_obj_new_list(0, NULL);\n    for (;;) {\n        mp_obj_t line = stream_unbuffered_readline(1, &self);\n        if (!mp_obj_is_true(line)) {\n            break;\n        }\n        mp_obj_list_append(lines, line);\n    }\n    return lines;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_stream_unbuffered_readlines_obj, stream_unbuffered_readlines);\n\nmp_obj_t mp_stream_unbuffered_iter(mp_obj_t self) {\n    mp_obj_t l_in = stream_unbuffered_readline(1, &self);\n    if (mp_obj_is_true(l_in)) {\n        return l_in;\n    }\n    return MP_OBJ_STOP_ITERATION;\n}\n\nmp_obj_t mp_stream_close(mp_obj_t stream) {\n    const mp_stream_p_t *stream_p = mp_get_stream(stream);\n    int error;\n    mp_uint_t res = stream_p->ioctl(stream, MP_STREAM_CLOSE, 0, &error);\n    if (res == MP_STREAM_ERROR) {\n        mp_raise_OSError(error);\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_stream_close_obj, mp_stream_close);\n\nstatic mp_obj_t mp_stream___exit__(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    return mp_stream_close(args[0]);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream___exit___obj, 4, 4, mp_stream___exit__);\n\nstatic mp_obj_t stream_seek(size_t n_args, const mp_obj_t *args) {\n    \n    mp_off_t offset = mp_obj_get_int(args[1]);\n    int whence = SEEK_SET;\n    if (n_args == 3) {\n        whence = mp_obj_get_int(args[2]);\n    }\n\n    \n    if (whence == SEEK_SET && offset < 0) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n\n    int error;\n    mp_off_t res = mp_stream_seek(args[0], offset, whence, &error);\n    if (res == (mp_off_t)-1) {\n        mp_raise_OSError(error);\n    }\n\n    \n    return mp_obj_new_int_from_uint(res);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_seek_obj, 2, 3, stream_seek);\n\nstatic mp_obj_t stream_tell(mp_obj_t self) {\n    mp_obj_t offset = MP_OBJ_NEW_SMALL_INT(0);\n    mp_obj_t whence = MP_OBJ_NEW_SMALL_INT(SEEK_CUR);\n    const mp_obj_t args[3] = {self, offset, whence};\n    return stream_seek(3, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_stream_tell_obj, stream_tell);\n\nstatic mp_obj_t stream_flush(mp_obj_t self) {\n    const mp_stream_p_t *stream_p = mp_get_stream(self);\n    int error;\n    mp_uint_t res = stream_p->ioctl(self, MP_STREAM_FLUSH, 0, &error);\n    if (res == MP_STREAM_ERROR) {\n        mp_raise_OSError(error);\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_stream_flush_obj, stream_flush);\n\nstatic mp_obj_t stream_ioctl(size_t n_args, const mp_obj_t *args) {\n    mp_buffer_info_t bufinfo;\n    uintptr_t val = 0;\n    if (n_args > 2) {\n        if (mp_get_buffer(args[2], &bufinfo, MP_BUFFER_WRITE)) {\n            val = (uintptr_t)bufinfo.buf;\n        } else {\n            val = mp_obj_get_int_truncated(args[2]);\n        }\n    }\n\n    const mp_stream_p_t *stream_p = mp_get_stream(args[0]);\n    int error;\n    mp_uint_t res = stream_p->ioctl(args[0], mp_obj_get_int(args[1]), val, &error);\n    if (res == MP_STREAM_ERROR) {\n        mp_raise_OSError(error);\n    }\n\n    return mp_obj_new_int(res);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_ioctl_obj, 2, 3, stream_ioctl);\n\n#if MICROPY_STREAMS_POSIX_API\n \n\n#include <errno.h>\n\nssize_t mp_stream_posix_write(void *stream, const void *buf, size_t len) {\n    mp_obj_base_t *o = stream;\n    const mp_stream_p_t *stream_p = MP_OBJ_TYPE_GET_SLOT(o->type, protocol);\n    mp_uint_t out_sz = stream_p->write(MP_OBJ_FROM_PTR(stream), buf, len, &errno);\n    if (out_sz == MP_STREAM_ERROR) {\n        return -1;\n    } else {\n        return out_sz;\n    }\n}\n\nssize_t mp_stream_posix_read(void *stream, void *buf, size_t len) {\n    mp_obj_base_t *o = stream;\n    const mp_stream_p_t *stream_p = MP_OBJ_TYPE_GET_SLOT(o->type, protocol);\n    mp_uint_t out_sz = stream_p->read(MP_OBJ_FROM_PTR(stream), buf, len, &errno);\n    if (out_sz == MP_STREAM_ERROR) {\n        return -1;\n    } else {\n        return out_sz;\n    }\n}\n\noff_t mp_stream_posix_lseek(void *stream, off_t offset, int whence) {\n    mp_off_t res = mp_stream_seek(MP_OBJ_FROM_PTR(stream), offset, whence, &errno);\n    if (res == (mp_off_t)-1) {\n        return -1;\n    }\n    return res;\n}\n\nint mp_stream_posix_fsync(void *stream) {\n    mp_obj_base_t *o = stream;\n    const mp_stream_p_t *stream_p = MP_OBJ_TYPE_GET_SLOT(o->type, protocol);\n    mp_uint_t res = stream_p->ioctl(MP_OBJ_FROM_PTR(stream), MP_STREAM_FLUSH, 0, &errno);\n    if (res == MP_STREAM_ERROR) {\n        return -1;\n    }\n    return res;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}