{
  "module_name": "repl.c",
  "hash_id": "f6c113f4ee613449da6bbde440da1b9a9d1c7a37ecead5dc9a562a836808eb39",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/repl.c",
  "human_readable_source": " \n\n#include <string.h>\n#include \"py/obj.h\"\n#include \"py/objmodule.h\"\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/repl.h\"\n\n#if MICROPY_HELPER_REPL\n\n#if MICROPY_PY_SYS_PS1_PS2\nconst char *mp_repl_get_psx(unsigned int entry) {\n    if (mp_obj_is_str(MP_STATE_VM(sys_mutable)[entry])) {\n        return mp_obj_str_get_str(MP_STATE_VM(sys_mutable)[entry]);\n    } else {\n        return \"\";\n    }\n}\n#endif\n\nstatic bool str_startswith_word(const char *str, const char *head) {\n    size_t i;\n    for (i = 0; str[i] && head[i]; i++) {\n        if (str[i] != head[i]) {\n            return false;\n        }\n    }\n    return head[i] == '\\0' && (str[i] == '\\0' || !unichar_isident(str[i]));\n}\n\nbool mp_repl_continue_with_input(const char *input) {\n    \n    if (input[0] == '\\0') {\n        return false;\n    }\n\n    \n    bool starts_with_compound_keyword =\n        input[0] == '@'\n        || str_startswith_word(input, \"if\")\n        || str_startswith_word(input, \"while\")\n        || str_startswith_word(input, \"for\")\n        || str_startswith_word(input, \"try\")\n        || str_startswith_word(input, \"with\")\n        || str_startswith_word(input, \"def\")\n        || str_startswith_word(input, \"class\")\n        #if MICROPY_PY_ASYNC_AWAIT\n        || str_startswith_word(input, \"async\")\n        #endif\n    ;\n\n    \n    #define Q_NONE (0)\n    #define Q_1_SINGLE (1)\n    #define Q_1_DOUBLE (2)\n    #define Q_3_SINGLE (3)\n    #define Q_3_DOUBLE (4)\n    int n_paren = 0;\n    int n_brack = 0;\n    int n_brace = 0;\n    int in_quote = Q_NONE;\n    const char *i;\n    for (i = input; *i; i++) {\n        if (*i == '\\'') {\n            if ((in_quote == Q_NONE || in_quote == Q_3_SINGLE) && i[1] == '\\'' && i[2] == '\\'') {\n                i += 2;\n                in_quote = Q_3_SINGLE - in_quote;\n            } else if (in_quote == Q_NONE || in_quote == Q_1_SINGLE) {\n                in_quote = Q_1_SINGLE - in_quote;\n            }\n        } else if (*i == '\"') {\n            if ((in_quote == Q_NONE || in_quote == Q_3_DOUBLE) && i[1] == '\"' && i[2] == '\"') {\n                i += 2;\n                in_quote = Q_3_DOUBLE - in_quote;\n            } else if (in_quote == Q_NONE || in_quote == Q_1_DOUBLE) {\n                in_quote = Q_1_DOUBLE - in_quote;\n            }\n        } else if (*i == '\\\\' && (i[1] == '\\'' || i[1] == '\"' || i[1] == '\\\\')) {\n            if (in_quote != Q_NONE) {\n                i++;\n            }\n        } else if (in_quote == Q_NONE) {\n            switch (*i) {\n                case '(':\n                    n_paren += 1;\n                    break;\n                case ')':\n                    n_paren -= 1;\n                    break;\n                case '[':\n                    n_brack += 1;\n                    break;\n                case ']':\n                    n_brack -= 1;\n                    break;\n                case '{':\n                    n_brace += 1;\n                    break;\n                case '}':\n                    n_brace -= 1;\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    \n    if (in_quote == Q_3_SINGLE || in_quote == Q_3_DOUBLE) {\n        return true;\n    }\n\n    \n    if ((n_paren > 0 || n_brack > 0 || n_brace > 0) && in_quote == Q_NONE) {\n        return true;\n    }\n\n    \n    if (i[-1] == '\\\\') {\n        return true;\n    }\n\n    \n    if (starts_with_compound_keyword && i[-1] != '\\n') {\n        return true;\n    }\n\n    \n    return false;\n}\n\nstatic bool test_qstr(mp_obj_t obj, qstr name) {\n    if (obj) {\n        \n        mp_obj_t dest[2];\n        mp_load_method_protected(obj, name, dest, true);\n        return dest[0] != MP_OBJ_NULL;\n    } else {\n        \n        return mp_map_lookup((mp_map_t *)&mp_builtin_module_map, MP_OBJ_NEW_QSTR(name), MP_MAP_LOOKUP) ||\n               mp_map_lookup((mp_map_t *)&mp_builtin_extensible_module_map, MP_OBJ_NEW_QSTR(name), MP_MAP_LOOKUP);\n    }\n}\n\nstatic const char *find_completions(const char *s_start, size_t s_len,\n    mp_obj_t obj, size_t *match_len, qstr *q_first, qstr *q_last) {\n\n    const char *match_str = NULL;\n    *match_len = 0;\n    *q_first = *q_last = 0;\n    size_t nqstr = QSTR_TOTAL();\n    for (qstr q = MP_QSTR_ + 1; q < nqstr; ++q) {\n        size_t d_len;\n        const char *d_str = (const char *)qstr_data(q, &d_len);\n        \n        \n        if (s_len == 0 && d_str[0] == '_') {\n            continue;\n        }\n        if (s_len <= d_len && strncmp(s_start, d_str, s_len) == 0) {\n            if (test_qstr(obj, q)) {\n                if (match_str == NULL) {\n                    match_str = d_str;\n                    *match_len = d_len;\n                } else {\n                    \n                    \n                    for (size_t j = s_len; j <= *match_len && j <= d_len; ++j) {\n                        if (match_str[j] != d_str[j]) {\n                            *match_len = j;\n                            break;\n                        }\n                    }\n                }\n                if (*q_first == 0) {\n                    *q_first = q;\n                }\n                *q_last = q;\n            }\n        }\n    }\n    return match_str;\n}\n\nstatic void print_completions(const mp_print_t *print,\n    const char *s_start, size_t s_len,\n    mp_obj_t obj, qstr q_first, qstr q_last) {\n\n    #define WORD_SLOT_LEN (16)\n    #define MAX_LINE_LEN  (4 * WORD_SLOT_LEN)\n\n    int line_len = MAX_LINE_LEN; \n    for (qstr q = q_first; q <= q_last; ++q) {\n        size_t d_len;\n        const char *d_str = (const char *)qstr_data(q, &d_len);\n        if (s_len <= d_len && strncmp(s_start, d_str, s_len) == 0) {\n            if (test_qstr(obj, q)) {\n                int gap = (line_len + WORD_SLOT_LEN - 1) / WORD_SLOT_LEN * WORD_SLOT_LEN - line_len;\n                if (gap < 2) {\n                    gap += WORD_SLOT_LEN;\n                }\n                if (line_len + gap + d_len <= MAX_LINE_LEN) {\n                    \n                    for (int j = 0; j < gap; ++j) {\n                        mp_print_str(print, \" \");\n                    }\n                    mp_print_str(print, d_str);\n                    line_len += gap + d_len;\n                } else {\n                    mp_printf(print, \"\\n%s\", d_str);\n                    line_len = d_len;\n                }\n            }\n        }\n    }\n    mp_print_str(print, \"\\n\");\n}\n\nsize_t mp_repl_autocomplete(const char *str, size_t len, const mp_print_t *print, const char **compl_str) {\n    \n    const char *org_str = str;\n    const char *top = str + len;\n    for (const char *s = top; --s >= str;) {\n        if (!(unichar_isalpha(*s) || unichar_isdigit(*s) || *s == '_' || *s == '.')) {\n            ++s;\n            str = s;\n            break;\n        }\n    }\n\n    \n    mp_obj_t obj = MP_OBJ_FROM_PTR(&mp_module___main__);\n    mp_obj_t dest[2];\n\n    const char *s_start;\n    size_t s_len;\n\n    for (;;) {\n        \n        s_start = str;\n        while (str < top && *str != '.') {\n            ++str;\n        }\n        s_len = str - s_start;\n\n        if (str == top) {\n            \n            break;\n        }\n\n        \n        qstr q = qstr_find_strn(s_start, s_len);\n        if (q == MP_QSTRnull) {\n            \n            return 0;\n        }\n        mp_load_method_protected(obj, q, dest, true);\n        obj = dest[0]; \n\n        if (obj == MP_OBJ_NULL) {\n            \n            return 0;\n        }\n\n        \n        ++str;\n    }\n\n    \n    static const char import_str[] = \"import \";\n    if (len >= 7 && !memcmp(org_str, import_str, 7)) {\n        obj = MP_OBJ_NULL;\n    }\n\n    \n    size_t match_len;\n    qstr q_first, q_last;\n    const char *match_str =\n        find_completions(s_start, s_len, obj, &match_len, &q_first, &q_last);\n\n    \n    if (q_first == 0) {\n        \n        \n        if (s_start == org_str && s_len > 0 && s_len < sizeof(import_str) - 1) {\n            if (memcmp(s_start, import_str, s_len) == 0) {\n                *compl_str = import_str + s_len;\n                return sizeof(import_str) - 1 - s_len;\n            }\n        }\n        return 0;\n    }\n\n    \n    if (q_first == q_last || match_len > s_len) {\n        *compl_str = match_str + s_len;\n        return match_len - s_len;\n    }\n\n    \n    print_completions(print, s_start, s_len, obj, q_first, q_last);\n\n    return (size_t)(-1); \n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}