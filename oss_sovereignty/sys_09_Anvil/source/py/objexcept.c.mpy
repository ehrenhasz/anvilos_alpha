{
  "module_name": "objexcept.c",
  "hash_id": "3e4b596ba030b5002b0c3526e21ffbcfeb01fd9239f6d7c9e411c4c244a1edec",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objexcept.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <stdio.h>\n\n#include \"py/objlist.h\"\n#include \"py/objstr.h\"\n#include \"py/objtuple.h\"\n#include \"py/objtype.h\"\n#include \"py/runtime.h\"\n#include \"py/gc.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_ROM_TEXT_COMPRESSION && !defined(NO_QSTR)\n\n\n#define MP_MATCH_COMPRESSED(...) \n#define MP_COMPRESSED_DATA(...) \n#include \"genhdr/compressed.data.h\"\n#undef MP_MATCH_COMPRESSED\n#undef MP_COMPRESSED_DATA\n#endif\n\n\n#define TRACEBACK_ENTRY_LEN (3)\n\n\n\n#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n\n\n\n\n\n\n\n\n#define EMG_BUF_TRACEBACK_OFFSET    (0)\n#define EMG_BUF_TRACEBACK_SIZE      (2 * TRACEBACK_ENTRY_LEN * sizeof(size_t))\n#define EMG_BUF_TUPLE_OFFSET        (EMG_BUF_TRACEBACK_OFFSET + EMG_BUF_TRACEBACK_SIZE)\n#define EMG_BUF_TUPLE_SIZE(n_args)  (sizeof(mp_obj_tuple_t) + n_args * sizeof(mp_obj_t))\n#define EMG_BUF_STR_OFFSET          (EMG_BUF_TUPLE_OFFSET + EMG_BUF_TUPLE_SIZE(1))\n#define EMG_BUF_STR_BUF_OFFSET      (EMG_BUF_STR_OFFSET + sizeof(mp_obj_str_t))\n\n#if MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE > 0\n#define mp_emergency_exception_buf_size MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE\n\nvoid mp_init_emergency_exception_buf(void) {\n    \n    \n    \n}\n\n#else\n#define mp_emergency_exception_buf_size MP_STATE_VM(mp_emergency_exception_buf_size)\n\n#include \"py/mphal.h\" \n\nvoid mp_init_emergency_exception_buf(void) {\n    mp_emergency_exception_buf_size = 0;\n    MP_STATE_VM(mp_emergency_exception_buf) = NULL;\n}\n\nmp_obj_t mp_alloc_emergency_exception_buf(mp_obj_t size_in) {\n    mp_int_t size = mp_obj_get_int(size_in);\n    void *buf = NULL;\n    if (size > 0) {\n        buf = m_new(byte, size);\n    }\n\n    int old_size = mp_emergency_exception_buf_size;\n    void *old_buf = MP_STATE_VM(mp_emergency_exception_buf);\n\n    \n    \n    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();\n    mp_emergency_exception_buf_size = size;\n    MP_STATE_VM(mp_emergency_exception_buf) = buf;\n    MICROPY_END_ATOMIC_SECTION(atomic_state);\n\n    if (old_buf != NULL) {\n        m_del(byte, old_buf, old_size);\n    }\n    return mp_const_none;\n}\n#endif\n#endif  \n\nbool mp_obj_is_native_exception_instance(mp_obj_t self_in) {\n    return MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_obj_get_type(self_in), make_new) == mp_obj_exception_make_new;\n}\n\nstatic mp_obj_exception_t *get_native_exception(mp_obj_t self_in) {\n    assert(mp_obj_is_exception_instance(self_in));\n    if (mp_obj_is_native_exception_instance(self_in)) {\n        return MP_OBJ_TO_PTR(self_in);\n    } else {\n        return MP_OBJ_TO_PTR(((mp_obj_instance_t *)MP_OBJ_TO_PTR(self_in))->subobj[0]);\n    }\n}\n\nstatic void decompress_error_text_maybe(mp_obj_exception_t *o) {\n    #if MICROPY_ROM_TEXT_COMPRESSION\n    if (o->args->len == 1 && mp_obj_is_exact_type(o->args->items[0], &mp_type_str)) {\n        mp_obj_str_t *o_str = MP_OBJ_TO_PTR(o->args->items[0]);\n        if (MP_IS_COMPRESSED_ROM_STRING(o_str->data)) {\n            byte *buf = m_new_maybe(byte, MP_MAX_UNCOMPRESSED_TEXT_LEN + 1);\n            if (!buf) {\n                #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n                \n                buf = (byte *)((uint8_t *)MP_STATE_VM(mp_emergency_exception_buf) + EMG_BUF_STR_BUF_OFFSET);\n                size_t avail = (uint8_t *)MP_STATE_VM(mp_emergency_exception_buf) + mp_emergency_exception_buf_size - buf;\n                if (avail < MP_MAX_UNCOMPRESSED_TEXT_LEN + 1) {\n                    \n                    o->args = (mp_obj_tuple_t *)&mp_const_empty_tuple_obj;\n                    return;\n                }\n                #else\n                o->args = (mp_obj_tuple_t *)&mp_const_empty_tuple_obj;\n                return;\n                #endif\n            }\n            mp_decompress_rom_string(buf, (mp_rom_error_text_t)o_str->data);\n            o_str->data = buf;\n            o_str->len = strlen((const char *)buf);\n            o_str->hash = 0;\n        }\n        \n        if (o_str->hash == 0) {\n            o_str->hash = qstr_compute_hash(o_str->data, o_str->len);\n        }\n    }\n    #endif\n}\n\nvoid mp_obj_exception_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    mp_obj_exception_t *o = MP_OBJ_TO_PTR(o_in);\n    mp_print_kind_t k = kind & ~PRINT_EXC_SUBCLASS;\n    bool is_subclass = kind & PRINT_EXC_SUBCLASS;\n    if (!is_subclass && (k == PRINT_REPR || k == PRINT_EXC)) {\n        mp_print_str(print, qstr_str(o->base.type->name));\n    }\n\n    if (k == PRINT_EXC) {\n        mp_print_str(print, \": \");\n    }\n\n    decompress_error_text_maybe(o);\n\n    if (k == PRINT_STR || k == PRINT_EXC) {\n        if (o->args == NULL || o->args->len == 0) {\n            mp_print_str(print, \"\");\n            return;\n        }\n\n        #if MICROPY_PY_ERRNO\n        \n        if (o->base.type == &mp_type_OSError && o->args->len > 0 && o->args->len < 3 && mp_obj_is_small_int(o->args->items[0])) {\n            qstr qst = mp_errno_to_str(o->args->items[0]);\n            if (qst != MP_QSTRnull) {\n                mp_printf(print, \"[Errno \" INT_FMT \"] %q\", MP_OBJ_SMALL_INT_VALUE(o->args->items[0]), qst);\n                if (o->args->len > 1) {\n                    mp_print_str(print, \": \");\n                    mp_obj_print_helper(print, o->args->items[1], PRINT_STR);\n                }\n                return;\n            }\n        }\n        #endif\n\n        if (o->args->len == 1) {\n            mp_obj_print_helper(print, o->args->items[0], PRINT_STR);\n            return;\n        }\n    }\n\n    mp_obj_tuple_print(print, MP_OBJ_FROM_PTR(o->args), kind);\n}\n\nmp_obj_t mp_obj_exception_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, MP_OBJ_FUN_ARGS_MAX, false);\n\n    \n    mp_obj_exception_t *o_exc = m_new_obj_maybe(mp_obj_exception_t);\n    if (o_exc == NULL) {\n        o_exc = &MP_STATE_VM(mp_emergency_exception_obj);\n    }\n\n    \n    o_exc->base.type = type;\n    o_exc->traceback_data = NULL;\n\n    mp_obj_tuple_t *o_tuple;\n    if (n_args == 0) {\n        \n        o_tuple = (mp_obj_tuple_t *)&mp_const_empty_tuple_obj;\n    } else {\n        \n        o_tuple = m_new_obj_var_maybe(mp_obj_tuple_t, items, mp_obj_t, n_args);\n\n        #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n        \n        \n        \n        if (o_tuple == NULL && mp_emergency_exception_buf_size >=\n            (mp_int_t)(EMG_BUF_TUPLE_OFFSET + EMG_BUF_TUPLE_SIZE(n_args))) {\n            o_tuple = (mp_obj_tuple_t *)\n                ((uint8_t *)MP_STATE_VM(mp_emergency_exception_buf) + EMG_BUF_TUPLE_OFFSET);\n        }\n        #endif\n\n        if (o_tuple == NULL) {\n            \n            o_tuple = (mp_obj_tuple_t *)&mp_const_empty_tuple_obj;\n        } else {\n            \n            o_tuple->base.type = &mp_type_tuple;\n            o_tuple->len = n_args;\n            memcpy(o_tuple->items, args, n_args * sizeof(mp_obj_t));\n        }\n    }\n\n    \n    o_exc->args = o_tuple;\n\n    return MP_OBJ_FROM_PTR(o_exc);\n}\n\n\nmp_obj_t mp_obj_exception_get_value(mp_obj_t self_in) {\n    mp_obj_exception_t *self = get_native_exception(self_in);\n    if (self->args->len == 0) {\n        return mp_const_none;\n    } else {\n        decompress_error_text_maybe(self);\n        return self->args->items[0];\n    }\n}\n\nvoid mp_obj_exception_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    mp_obj_exception_t *self = MP_OBJ_TO_PTR(self_in);\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        if (attr == MP_QSTR___traceback__ && dest[1] == mp_const_none) {\n            \n            \n            \n            \n            \n            \n            self->traceback_len = 0;\n            dest[0] = MP_OBJ_NULL; \n        }\n        return;\n    }\n    if (attr == MP_QSTR_args) {\n        decompress_error_text_maybe(self);\n        dest[0] = MP_OBJ_FROM_PTR(self->args);\n    } else if (attr == MP_QSTR_value || attr == MP_QSTR_errno) {\n        \n        \n        dest[0] = mp_obj_exception_get_value(self_in);\n    }\n}\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_BaseException,\n    MP_QSTR_BaseException,\n    MP_TYPE_FLAG_NONE,\n    make_new, mp_obj_exception_make_new,\n    print, mp_obj_exception_print,\n    attr, mp_obj_exception_attr\n    );\n\n\n\n\n\nMP_DEFINE_EXCEPTION(SystemExit, BaseException)\nMP_DEFINE_EXCEPTION(KeyboardInterrupt, BaseException)\nMP_DEFINE_EXCEPTION(GeneratorExit, BaseException)\nMP_DEFINE_EXCEPTION(Exception, BaseException)\n  #if MICROPY_PY_ASYNC_AWAIT\n  MP_DEFINE_EXCEPTION(StopAsyncIteration, Exception)\n  #endif\n  MP_DEFINE_EXCEPTION(StopIteration, Exception)\n  MP_DEFINE_EXCEPTION(ArithmeticError, Exception)\n    \n    MP_DEFINE_EXCEPTION(OverflowError, ArithmeticError)\n    MP_DEFINE_EXCEPTION(ZeroDivisionError, ArithmeticError)\n  MP_DEFINE_EXCEPTION(AssertionError, Exception)\n  MP_DEFINE_EXCEPTION(AttributeError, Exception)\n  \n  MP_DEFINE_EXCEPTION(EOFError, Exception)\n  MP_DEFINE_EXCEPTION(ImportError, Exception)\n  MP_DEFINE_EXCEPTION(LookupError, Exception)\n    MP_DEFINE_EXCEPTION(IndexError, LookupError)\n    MP_DEFINE_EXCEPTION(KeyError, LookupError)\n  MP_DEFINE_EXCEPTION(MemoryError, Exception)\n  MP_DEFINE_EXCEPTION(NameError, Exception)\n     \n  MP_DEFINE_EXCEPTION(OSError, Exception)\n     \n  MP_DEFINE_EXCEPTION(RuntimeError, Exception)\n    MP_DEFINE_EXCEPTION(NotImplementedError, RuntimeError)\n  MP_DEFINE_EXCEPTION(SyntaxError, Exception)\n    MP_DEFINE_EXCEPTION(IndentationError, SyntaxError)\n     \n  \n  MP_DEFINE_EXCEPTION(TypeError, Exception)\n#if MICROPY_EMIT_NATIVE\n    MP_DEFINE_EXCEPTION(ViperTypeError, TypeError)\n#endif\n  MP_DEFINE_EXCEPTION(ValueError, Exception)\n#if MICROPY_PY_BUILTINS_STR_UNICODE\n    MP_DEFINE_EXCEPTION(UnicodeError, ValueError)\n    \n#endif\n   \n\n\n\nmp_obj_t mp_obj_new_exception(const mp_obj_type_t *exc_type) {\n    assert(MP_OBJ_TYPE_GET_SLOT_OR_NULL(exc_type, make_new) == mp_obj_exception_make_new);\n    return mp_obj_exception_make_new(exc_type, 0, 0, NULL);\n}\n\nmp_obj_t mp_obj_new_exception_args(const mp_obj_type_t *exc_type, size_t n_args, const mp_obj_t *args) {\n    assert(MP_OBJ_TYPE_GET_SLOT_OR_NULL(exc_type, make_new) == mp_obj_exception_make_new);\n    return mp_obj_exception_make_new(exc_type, n_args, 0, args);\n}\n\n#if MICROPY_ERROR_REPORTING != MICROPY_ERROR_REPORTING_NONE\n\nmp_obj_t mp_obj_new_exception_msg(const mp_obj_type_t *exc_type, mp_rom_error_text_t msg) {\n    \n    assert(MP_OBJ_TYPE_GET_SLOT_OR_NULL(exc_type, make_new) == mp_obj_exception_make_new);\n\n    \n    mp_obj_str_t *o_str = m_new_obj_maybe(mp_obj_str_t);\n\n    #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n    \n    \n    \n    if (o_str == NULL\n        && mp_emergency_exception_buf_size >= (mp_int_t)(EMG_BUF_STR_OFFSET + sizeof(mp_obj_str_t))) {\n        o_str = (mp_obj_str_t *)((uint8_t *)MP_STATE_VM(mp_emergency_exception_buf)\n            + EMG_BUF_STR_OFFSET);\n    }\n    #endif\n\n    if (o_str == NULL) {\n        \n        return mp_obj_exception_make_new(exc_type, 0, 0, NULL);\n    }\n\n    \n    o_str->base.type = &mp_type_str;\n    o_str->len = strlen((const char *)msg);\n    o_str->data = (const byte *)msg;\n    #if MICROPY_ROM_TEXT_COMPRESSION\n    o_str->hash = 0; \n    #else\n    o_str->hash = qstr_compute_hash(o_str->data, o_str->len);\n    #endif\n    mp_obj_t arg = MP_OBJ_FROM_PTR(o_str);\n    return mp_obj_exception_make_new(exc_type, 1, 0, &arg);\n}\n\n\n\n\n\nstruct _exc_printer_t {\n    bool allow_realloc;\n    size_t alloc;\n    size_t len;\n    byte *buf;\n};\n\nstatic void exc_add_strn(void *data, const char *str, size_t len) {\n    struct _exc_printer_t *pr = data;\n    if (pr->len + len >= pr->alloc) {\n        \n        if (pr->allow_realloc) {\n            size_t new_alloc = pr->alloc + len + 16;\n            byte *new_buf = m_renew_maybe(byte, pr->buf, pr->alloc, new_alloc, true);\n            if (new_buf == NULL) {\n                pr->allow_realloc = false;\n                len = pr->alloc - pr->len - 1;\n            } else {\n                pr->alloc = new_alloc;\n                pr->buf = new_buf;\n            }\n        } else {\n            len = pr->alloc - pr->len - 1;\n        }\n    }\n    memcpy(pr->buf + pr->len, str, len);\n    pr->len += len;\n}\n\nmp_obj_t mp_obj_new_exception_msg_varg(const mp_obj_type_t *exc_type, mp_rom_error_text_t fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    mp_obj_t exc = mp_obj_new_exception_msg_vlist(exc_type, fmt, args);\n    va_end(args);\n    return exc;\n}\n\nmp_obj_t mp_obj_new_exception_msg_vlist(const mp_obj_type_t *exc_type, mp_rom_error_text_t fmt, va_list args) {\n    assert(fmt != NULL);\n\n    \n    assert(MP_OBJ_TYPE_GET_SLOT_OR_NULL(exc_type, make_new) == mp_obj_exception_make_new);\n\n    \n    mp_obj_str_t *o_str = m_new_obj_maybe(mp_obj_str_t);\n    size_t o_str_alloc = strlen((const char *)fmt) + 1;\n    byte *o_str_buf = m_new_maybe(byte, o_str_alloc);\n\n    bool used_emg_buf = false;\n    #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n    \n    \n    \n    if ((o_str == NULL || o_str_buf == NULL)\n        && mp_emergency_exception_buf_size >= (mp_int_t)(EMG_BUF_STR_OFFSET + sizeof(mp_obj_str_t) + 16)) {\n        used_emg_buf = true;\n        o_str = (mp_obj_str_t *)((uint8_t *)MP_STATE_VM(mp_emergency_exception_buf) + EMG_BUF_STR_OFFSET);\n        o_str_buf = (byte *)((uint8_t *)MP_STATE_VM(mp_emergency_exception_buf) + EMG_BUF_STR_BUF_OFFSET);\n        o_str_alloc = (uint8_t *)MP_STATE_VM(mp_emergency_exception_buf) + mp_emergency_exception_buf_size - o_str_buf;\n    }\n    #endif\n\n    if (o_str == NULL) {\n        \n        \n        return mp_obj_exception_make_new(exc_type, 0, 0, NULL);\n    }\n\n    if (o_str_buf == NULL) {\n        \n        \n        \n        \n        o_str->len = o_str_alloc - 1; \n        o_str->data = (const byte *)fmt;\n    } else {\n        \n        \n        struct _exc_printer_t exc_pr = {!used_emg_buf, o_str_alloc, 0, o_str_buf};\n        mp_print_t print = {&exc_pr, exc_add_strn};\n        const char *fmt2 = (const char *)fmt;\n        #if MICROPY_ROM_TEXT_COMPRESSION\n        byte decompressed[MP_MAX_UNCOMPRESSED_TEXT_LEN];\n        if (MP_IS_COMPRESSED_ROM_STRING(fmt)) {\n            mp_decompress_rom_string(decompressed, fmt);\n            fmt2 = (const char *)decompressed;\n        }\n        #endif\n        mp_vprintf(&print, fmt2, args);\n        exc_pr.buf[exc_pr.len] = '\\0';\n        o_str->len = exc_pr.len;\n        o_str->data = exc_pr.buf;\n    }\n\n    \n    o_str->base.type = &mp_type_str;\n    #if MICROPY_ROM_TEXT_COMPRESSION\n    o_str->hash = 0; \n    #else\n    o_str->hash = qstr_compute_hash(o_str->data, o_str->len);\n    #endif\n    mp_obj_t arg = MP_OBJ_FROM_PTR(o_str);\n    return mp_obj_exception_make_new(exc_type, 1, 0, &arg);\n}\n\n#endif\n\n\nbool mp_obj_is_exception_type(mp_obj_t self_in) {\n    if (mp_obj_is_type(self_in, &mp_type_type)) {\n        \n        mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);\n        if (MP_OBJ_TYPE_GET_SLOT_OR_NULL(self, make_new) == mp_obj_exception_make_new) {\n            return true;\n        }\n    }\n    return mp_obj_is_subclass_fast(self_in, MP_OBJ_FROM_PTR(&mp_type_BaseException));\n}\n\n\nbool mp_obj_is_exception_instance(mp_obj_t self_in) {\n    return mp_obj_is_exception_type(MP_OBJ_FROM_PTR(mp_obj_get_type(self_in)));\n}\n\n\n\n\nbool mp_obj_exception_match(mp_obj_t exc, mp_const_obj_t exc_type) {\n    \n    if (mp_obj_is_exception_instance(exc)) {\n        exc = MP_OBJ_FROM_PTR(mp_obj_get_type(exc));\n    }\n    return mp_obj_is_subclass_fast(exc, exc_type);\n}\n\n\n\nvoid mp_obj_exception_clear_traceback(mp_obj_t self_in) {\n    mp_obj_exception_t *self = get_native_exception(self_in);\n    \n    \n    self->traceback_data = NULL;\n}\n\nvoid mp_obj_exception_add_traceback(mp_obj_t self_in, qstr file, size_t line, qstr block) {\n    mp_obj_exception_t *self = get_native_exception(self_in);\n\n    \n    \n\n    #if MICROPY_PY_SYS_TRACEBACKLIMIT\n    mp_int_t max_traceback = MP_OBJ_SMALL_INT_VALUE(MP_STATE_VM(sys_mutable[MP_SYS_MUTABLE_TRACEBACKLIMIT]));\n    if (max_traceback <= 0) {\n        return;\n    } else if (self->traceback_data != NULL && self->traceback_len >= max_traceback * TRACEBACK_ENTRY_LEN) {\n        self->traceback_len -= TRACEBACK_ENTRY_LEN;\n        memmove(self->traceback_data, self->traceback_data + TRACEBACK_ENTRY_LEN, self->traceback_len * sizeof(self->traceback_data[0]));\n    }\n    #endif\n\n    if (self->traceback_data == NULL) {\n        self->traceback_data = m_new_maybe(size_t, TRACEBACK_ENTRY_LEN);\n        if (self->traceback_data == NULL) {\n            #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n            if (mp_emergency_exception_buf_size >= (mp_int_t)(EMG_BUF_TRACEBACK_OFFSET + EMG_BUF_TRACEBACK_SIZE)) {\n                \n                size_t *tb = (size_t *)((uint8_t *)MP_STATE_VM(mp_emergency_exception_buf)\n                    + EMG_BUF_TRACEBACK_OFFSET);\n                self->traceback_data = tb;\n                self->traceback_alloc = EMG_BUF_TRACEBACK_SIZE / sizeof(size_t);\n            } else {\n                \n                return;\n            }\n            #else\n            \n            return;\n            #endif\n        } else {\n            \n            self->traceback_alloc = TRACEBACK_ENTRY_LEN;\n        }\n        self->traceback_len = 0;\n    } else if (self->traceback_len + TRACEBACK_ENTRY_LEN > self->traceback_alloc) {\n        #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n        if (self->traceback_data == (size_t *)MP_STATE_VM(mp_emergency_exception_buf)) {\n            \n            return;\n        }\n        #endif\n        \n        size_t *tb_data = m_renew_maybe(size_t, self->traceback_data, self->traceback_alloc,\n            self->traceback_alloc + TRACEBACK_ENTRY_LEN, true);\n        if (tb_data == NULL) {\n            return;\n        }\n        self->traceback_data = tb_data;\n        self->traceback_alloc += TRACEBACK_ENTRY_LEN;\n    }\n\n    size_t *tb_data = &self->traceback_data[self->traceback_len];\n    self->traceback_len += TRACEBACK_ENTRY_LEN;\n    tb_data[0] = file;\n    tb_data[1] = line;\n    tb_data[2] = block;\n}\n\nvoid mp_obj_exception_get_traceback(mp_obj_t self_in, size_t *n, size_t **values) {\n    mp_obj_exception_t *self = get_native_exception(self_in);\n\n    if (self->traceback_data == NULL) {\n        *n = 0;\n        *values = NULL;\n    } else {\n        *n = self->traceback_len;\n        *values = self->traceback_data;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}