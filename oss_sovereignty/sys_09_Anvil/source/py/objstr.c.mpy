{
  "module_name": "objstr.c",
  "hash_id": "5ef64766878a059bc76369e978644a5d049e30fcad10b00f57b89d476d9ec432",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objstr.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/unicode.h\"\n#include \"py/objstr.h\"\n#include \"py/objlist.h\"\n#include \"py/runtime.h\"\n#include \"py/stackctrl.h\"\n\n#if MICROPY_PY_BUILTINS_STR_OP_MODULO\nstatic mp_obj_t str_modulo_format(mp_obj_t pattern, size_t n_args, const mp_obj_t *args, mp_obj_t dict);\n#endif\n\nstatic mp_obj_t mp_obj_new_bytes_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf);\nstatic NORETURN void bad_implicit_conversion(mp_obj_t self_in);\n\nstatic mp_obj_t mp_obj_new_str_type_from_vstr(const mp_obj_type_t *type, vstr_t *vstr);\n\nstatic void str_check_arg_type(const mp_obj_type_t *self_type, const mp_obj_t arg) {\n    \n    \n    \n    const mp_obj_type_t *arg_type = mp_obj_get_type(arg);\n\n    #if MICROPY_PY_BUILTINS_BYTEARRAY\n    if (arg_type == &mp_type_bytearray) {\n        arg_type = &mp_type_bytes;\n    }\n    if (self_type == &mp_type_bytearray) {\n        self_type = &mp_type_bytes;\n    }\n    #endif\n\n    if (arg_type != self_type) {\n        bad_implicit_conversion(arg);\n    }\n}\n\nstatic void check_is_str_or_bytes(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_str_or_bytes(self_in));\n}\n\n \n \n\nvoid mp_str_print_quoted(const mp_print_t *print, const byte *str_data, size_t str_len, bool is_bytes) {\n    \n    bool has_single_quote = false;\n    bool has_double_quote = false;\n    for (const byte *s = str_data, *top = str_data + str_len; !has_double_quote && s < top; s++) {\n        if (*s == '\\'') {\n            has_single_quote = true;\n        } else if (*s == '\"') {\n            has_double_quote = true;\n        }\n    }\n    int quote_char = '\\'';\n    if (has_single_quote && !has_double_quote) {\n        quote_char = '\"';\n    }\n    mp_printf(print, \"%c\", quote_char);\n    for (const byte *s = str_data, *top = str_data + str_len; s < top; s++) {\n        if (*s == quote_char) {\n            mp_printf(print, \"\\\\%c\", quote_char);\n        } else if (*s == '\\\\') {\n            mp_print_str(print, \"\\\\\\\\\");\n        } else if (*s >= 0x20 && *s != 0x7f && (!is_bytes || *s < 0x80)) {\n            \n            \n            \n            mp_printf(print, \"%c\", *s);\n        } else if (*s == '\\n') {\n            mp_print_str(print, \"\\\\n\");\n        } else if (*s == '\\r') {\n            mp_print_str(print, \"\\\\r\");\n        } else if (*s == '\\t') {\n            mp_print_str(print, \"\\\\t\");\n        } else {\n            mp_printf(print, \"\\\\x%02x\", *s);\n        }\n    }\n    mp_printf(print, \"%c\", quote_char);\n}\n\n#if MICROPY_PY_JSON\nvoid mp_str_print_json(const mp_print_t *print, const byte *str_data, size_t str_len) {\n    \n    \n    mp_print_str(print, \"\\\"\");\n    for (const byte *s = str_data, *top = str_data + str_len; s < top; s++) {\n        if (*s == '\"' || *s == '\\\\') {\n            mp_printf(print, \"\\\\%c\", *s);\n        } else if (*s >= 32) {\n            \n            mp_printf(print, \"%c\", *s);\n        } else if (*s == '\\n') {\n            mp_print_str(print, \"\\\\n\");\n        } else if (*s == '\\r') {\n            mp_print_str(print, \"\\\\r\");\n        } else if (*s == '\\t') {\n            mp_print_str(print, \"\\\\t\");\n        } else {\n            \n            mp_printf(print, \"\\\\u%04x\", *s);\n        }\n    }\n    mp_print_str(print, \"\\\"\");\n}\n#endif\n\nstatic void str_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    GET_STR_DATA_LEN(self_in, str_data, str_len);\n    #if MICROPY_PY_JSON\n    if (kind == PRINT_JSON) {\n        mp_str_print_json(print, str_data, str_len);\n        return;\n    }\n    #endif\n    #if !MICROPY_PY_BUILTINS_STR_UNICODE\n    bool is_bytes = mp_obj_is_type(self_in, &mp_type_bytes);\n    #else\n    bool is_bytes = true;\n    #endif\n    if (kind == PRINT_RAW || (!MICROPY_PY_BUILTINS_STR_UNICODE && kind == PRINT_STR && !is_bytes)) {\n        print->print_strn(print->data, (const char *)str_data, str_len);\n    } else {\n        if (is_bytes) {\n            print->print_strn(print->data, \"b\", 1);\n        }\n        mp_str_print_quoted(print, str_data, str_len, is_bytes);\n    }\n}\n\nmp_obj_t mp_obj_str_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    #if MICROPY_CPYTHON_COMPAT\n    if (n_kw != 0) {\n        mp_arg_error_unimpl_kw();\n    }\n    #endif\n\n    mp_arg_check_num(n_args, n_kw, 0, 3, false);\n\n    switch (n_args) {\n        case 0:\n            return MP_OBJ_NEW_QSTR(MP_QSTR_);\n\n        case 1: {\n            vstr_t vstr;\n            mp_print_t print;\n            vstr_init_print(&vstr, 16, &print);\n            mp_obj_print_helper(&print, args[0], PRINT_STR);\n            return mp_obj_new_str_type_from_vstr(type, &vstr);\n        }\n\n        default: \n            \n            if (mp_obj_is_type(args[0], &mp_type_bytes)) {\n                GET_STR_DATA_LEN(args[0], str_data, str_len);\n                GET_STR_HASH(args[0], str_hash);\n                if (str_hash == 0) {\n                    str_hash = qstr_compute_hash(str_data, str_len);\n                }\n                #if MICROPY_PY_BUILTINS_STR_UNICODE_CHECK\n                if (!utf8_check(str_data, str_len)) {\n                    mp_raise_msg(&mp_type_UnicodeError, NULL);\n                }\n                #endif\n\n                \n                qstr q = qstr_find_strn((const char *)str_data, str_len);\n                if (q != MP_QSTRnull) {\n                    return MP_OBJ_NEW_QSTR(q);\n                }\n\n                mp_obj_str_t *o = MP_OBJ_TO_PTR(mp_obj_new_str_copy(type, NULL, str_len));\n                o->data = str_data;\n                o->hash = str_hash;\n                return MP_OBJ_FROM_PTR(o);\n            } else {\n                mp_buffer_info_t bufinfo;\n                mp_get_buffer_raise(args[0], &bufinfo, MP_BUFFER_READ);\n                \n                return mp_obj_new_str(bufinfo.buf, bufinfo.len);\n            }\n    }\n}\n\nstatic mp_obj_t bytes_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n\n    #if MICROPY_CPYTHON_COMPAT\n    if (n_kw != 0) {\n        mp_arg_error_unimpl_kw();\n    }\n    #else\n    (void)n_kw;\n    #endif\n\n    if (n_args == 0) {\n        return mp_const_empty_bytes;\n    }\n\n    if (mp_obj_is_type(args[0], &mp_type_bytes)) {\n        return args[0];\n    }\n\n    if (mp_obj_is_str(args[0])) {\n        if (n_args < 2 || n_args > 3) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            goto wrong_args;\n            #else\n            mp_raise_TypeError(MP_ERROR_TEXT(\"string argument without an encoding\"));\n            #endif\n        }\n        GET_STR_DATA_LEN(args[0], str_data, str_len);\n        GET_STR_HASH(args[0], str_hash);\n        if (str_hash == 0) {\n            str_hash = qstr_compute_hash(str_data, str_len);\n        }\n        mp_obj_str_t *o = MP_OBJ_TO_PTR(mp_obj_new_str_copy(&mp_type_bytes, NULL, str_len));\n        o->data = str_data;\n        o->hash = str_hash;\n        return MP_OBJ_FROM_PTR(o);\n    }\n\n    if (n_args > 1) {\n        goto wrong_args;\n    }\n\n    if (mp_obj_is_small_int(args[0])) {\n        mp_int_t len = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        if (len < 0) {\n            mp_raise_ValueError(NULL);\n        }\n        vstr_t vstr;\n        vstr_init_len(&vstr, len);\n        memset(vstr.buf, 0, len);\n        return mp_obj_new_bytes_from_vstr(&vstr);\n    }\n\n    \n    mp_buffer_info_t bufinfo;\n    if (mp_get_buffer(args[0], &bufinfo, MP_BUFFER_READ)) {\n        return mp_obj_new_bytes(bufinfo.buf, bufinfo.len);\n    }\n\n    vstr_t vstr;\n    \n    mp_obj_t len_in = mp_obj_len_maybe(args[0]);\n    if (len_in == MP_OBJ_NULL) {\n        vstr_init(&vstr, 16);\n    } else {\n        mp_int_t len = MP_OBJ_SMALL_INT_VALUE(len_in);\n        vstr_init(&vstr, len);\n    }\n\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iterable = mp_getiter(args[0], &iter_buf);\n    mp_obj_t item;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        mp_int_t val = mp_obj_get_int(item);\n        #if MICROPY_FULL_CHECKS\n        if (val < 0 || val > 255) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"bytes value out of range\"));\n        }\n        #endif\n        vstr_add_byte(&vstr, val);\n    }\n\n    return mp_obj_new_bytes_from_vstr(&vstr);\n\nwrong_args:\n    mp_raise_TypeError(MP_ERROR_TEXT(\"wrong number of arguments\"));\n}\n\n\n\nconst byte *find_subbytes(const byte *haystack, size_t hlen, const byte *needle, size_t nlen, int direction) {\n    if (hlen >= nlen) {\n        size_t str_index, str_index_end;\n        if (direction > 0) {\n            str_index = 0;\n            str_index_end = hlen - nlen;\n        } else {\n            str_index = hlen - nlen;\n            str_index_end = 0;\n        }\n        for (;;) {\n            if (memcmp(&haystack[str_index], needle, nlen) == 0) {\n                \n                return haystack + str_index;\n            }\n            if (str_index == str_index_end) {\n                \n                break;\n            }\n            str_index += direction;\n        }\n    }\n    return NULL;\n}\n\n\n\n\nmp_obj_t mp_obj_str_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    \n    if (op == MP_BINARY_OP_MODULO) {\n        #if MICROPY_PY_BUILTINS_STR_OP_MODULO\n        mp_obj_t *args = &rhs_in;\n        size_t n_args = 1;\n        mp_obj_t dict = MP_OBJ_NULL;\n        if (mp_obj_is_type(rhs_in, &mp_type_tuple)) {\n            \n            mp_obj_tuple_get(rhs_in, &n_args, &args);\n        } else if (mp_obj_is_type(rhs_in, &mp_type_dict)) {\n            dict = rhs_in;\n        }\n        return str_modulo_format(lhs_in, n_args, args, dict);\n        #else\n        return MP_OBJ_NULL;\n        #endif\n    }\n\n    \n    const mp_obj_type_t *lhs_type = mp_obj_get_type(lhs_in);\n    GET_STR_DATA_LEN(lhs_in, lhs_data, lhs_len);\n\n    \n    if (op == MP_BINARY_OP_MULTIPLY) {\n        mp_int_t n;\n        if (!mp_obj_get_int_maybe(rhs_in, &n)) {\n            return MP_OBJ_NULL; \n        }\n        if (n <= 0) {\n            if (lhs_type == &mp_type_str) {\n                return MP_OBJ_NEW_QSTR(MP_QSTR_); \n            } else {\n                return mp_const_empty_bytes;\n            }\n        }\n        vstr_t vstr;\n        vstr_init_len(&vstr, lhs_len * n);\n        mp_seq_multiply(lhs_data, sizeof(*lhs_data), lhs_len, n, vstr.buf);\n        return mp_obj_new_str_type_from_vstr(lhs_type, &vstr);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    const byte *rhs_data;\n    size_t rhs_len;\n    if (lhs_type == mp_obj_get_type(rhs_in)) {\n        GET_STR_DATA_LEN(rhs_in, rhs_data_, rhs_len_);\n        rhs_data = rhs_data_;\n        rhs_len = rhs_len_;\n    } else if (lhs_type == &mp_type_bytes) {\n        mp_buffer_info_t bufinfo;\n        if (!mp_get_buffer(rhs_in, &bufinfo, MP_BUFFER_READ)) {\n            return MP_OBJ_NULL; \n        }\n        rhs_data = bufinfo.buf;\n        rhs_len = bufinfo.len;\n    } else {\n        \n        \n\n        \n        \n        if (op == MP_BINARY_OP_CONTAINS) {\n            bad_implicit_conversion(rhs_in);\n        }\n\n        \n        \n        return MP_OBJ_NULL;\n    }\n\n    switch (op) {\n        case MP_BINARY_OP_ADD:\n        case MP_BINARY_OP_INPLACE_ADD: {\n            if (lhs_len == 0 && mp_obj_get_type(rhs_in) == lhs_type) {\n                return rhs_in;\n            }\n            if (rhs_len == 0) {\n                return lhs_in;\n            }\n\n            vstr_t vstr;\n            vstr_init_len(&vstr, lhs_len + rhs_len);\n            memcpy(vstr.buf, lhs_data, lhs_len);\n            memcpy(vstr.buf + lhs_len, rhs_data, rhs_len);\n            return mp_obj_new_str_type_from_vstr(lhs_type, &vstr);\n        }\n\n        case MP_BINARY_OP_CONTAINS:\n            return mp_obj_new_bool(find_subbytes(lhs_data, lhs_len, rhs_data, rhs_len, 1) != NULL);\n\n        \n        case MP_BINARY_OP_EQUAL: \n        case MP_BINARY_OP_LESS:\n        case MP_BINARY_OP_LESS_EQUAL:\n        case MP_BINARY_OP_MORE:\n        case MP_BINARY_OP_MORE_EQUAL:\n            return mp_obj_new_bool(mp_seq_cmp_bytes(op, lhs_data, lhs_len, rhs_data, rhs_len));\n\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\n#if !MICROPY_PY_BUILTINS_STR_UNICODE\n\nconst byte *str_index_to_ptr(const mp_obj_type_t *type, const byte *self_data, size_t self_len,\n    mp_obj_t index, bool is_slice) {\n    size_t index_val = mp_get_index(type, self_len, index, is_slice);\n    return self_data + index_val;\n}\n#endif\n\n\nstatic mp_obj_t bytes_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    const mp_obj_type_t *type = mp_obj_get_type(self_in);\n    GET_STR_DATA_LEN(self_in, self_data, self_len);\n    if (value == MP_OBJ_SENTINEL) {\n        \n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_bound_slice_t slice;\n            if (!mp_seq_get_fast_slice_indexes(self_len, index, &slice)) {\n                mp_raise_NotImplementedError(MP_ERROR_TEXT(\"only slices with step=1 (aka None) are supported\"));\n            }\n            return mp_obj_new_str_of_type(type, self_data + slice.start, slice.stop - slice.start);\n        }\n        #endif\n        size_t index_val = mp_get_index(type, self_len, index, false);\n        \n        if (MICROPY_PY_BUILTINS_STR_UNICODE || type == &mp_type_bytes) {\n            return MP_OBJ_NEW_SMALL_INT(self_data[index_val]);\n        } else {\n            return mp_obj_new_str_via_qstr((char *)&self_data[index_val], 1);\n        }\n    } else {\n        return MP_OBJ_NULL; \n    }\n}\n\nstatic mp_obj_t str_join(mp_obj_t self_in, mp_obj_t arg) {\n    check_is_str_or_bytes(self_in);\n    const mp_obj_type_t *self_type = mp_obj_get_type(self_in);\n    const mp_obj_type_t *ret_type = self_type;\n\n    \n    GET_STR_DATA_LEN(self_in, sep_str, sep_len);\n\n    \n    size_t seq_len;\n    mp_obj_t *seq_items;\n\n    if (!mp_obj_is_type(arg, &mp_type_list) && !mp_obj_is_type(arg, &mp_type_tuple)) {\n        \n        \n        arg = mp_obj_list_make_new(&mp_type_list, 1, 0, &arg);\n    }\n    mp_obj_get_array(arg, &seq_len, &seq_items);\n\n    \n    size_t required_len = 0;\n    #if MICROPY_PY_BUILTINS_BYTEARRAY\n    if (self_type == &mp_type_bytearray) {\n        self_type = &mp_type_bytes;\n    }\n    #endif\n    for (size_t i = 0; i < seq_len; i++) {\n        const mp_obj_type_t *seq_type = mp_obj_get_type(seq_items[i]);\n        #if MICROPY_PY_BUILTINS_BYTEARRAY\n        if (seq_type == &mp_type_bytearray) {\n            seq_type = &mp_type_bytes;\n        }\n        #endif\n        if (seq_type != self_type) {\n            mp_raise_TypeError(\n                MP_ERROR_TEXT(\"join expects a list of str/bytes objects consistent with self object\"));\n        }\n        if (i > 0) {\n            required_len += sep_len;\n        }\n        GET_STR_LEN(seq_items[i], l);\n        required_len += l;\n    }\n\n    \n    vstr_t vstr;\n    vstr_init_len(&vstr, required_len);\n    byte *data = (byte *)vstr.buf;\n    for (size_t i = 0; i < seq_len; i++) {\n        if (i > 0) {\n            memcpy(data, sep_str, sep_len);\n            data += sep_len;\n        }\n        GET_STR_DATA_LEN(seq_items[i], s, l);\n        memcpy(data, s, l);\n        data += l;\n    }\n\n    \n    return mp_obj_new_str_type_from_vstr(ret_type, &vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(str_join_obj, str_join);\n\nmp_obj_t mp_obj_str_split(size_t n_args, const mp_obj_t *args) {\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n    mp_int_t splits = -1;\n    mp_obj_t sep = mp_const_none;\n    if (n_args > 1) {\n        sep = args[1];\n        if (n_args > 2) {\n            splits = mp_obj_get_int(args[2]);\n        }\n    }\n\n    mp_obj_t res = mp_obj_new_list(0, NULL);\n    GET_STR_DATA_LEN(args[0], s, len);\n    const byte *top = s + len;\n\n    if (sep == mp_const_none) {\n        \n\n        \n        while (s < top && unichar_isspace(*s)) {\n            s++;\n        }\n        while (s < top && splits != 0) {\n            const byte *start = s;\n            while (s < top && !unichar_isspace(*s)) {\n                s++;\n            }\n            mp_obj_list_append(res, mp_obj_new_str_of_type(self_type, start, s - start));\n            if (s >= top) {\n                break;\n            }\n            while (s < top && unichar_isspace(*s)) {\n                s++;\n            }\n            if (splits > 0) {\n                splits--;\n            }\n        }\n\n        if (s < top) {\n            mp_obj_list_append(res, mp_obj_new_str_of_type(self_type, s, top - s));\n        }\n\n    } else {\n        \n        str_check_arg_type(self_type, sep);\n\n        size_t sep_len;\n        const char *sep_str = mp_obj_str_get_data(sep, &sep_len);\n\n        if (sep_len == 0) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"empty separator\"));\n        }\n\n        for (;;) {\n            const byte *start = s;\n            for (;;) {\n                if (splits == 0 || s + sep_len > top) {\n                    s = top;\n                    break;\n                } else if (memcmp(s, sep_str, sep_len) == 0) {\n                    break;\n                }\n                s++;\n            }\n            mp_obj_list_append(res, mp_obj_new_str_of_type(self_type, start, s - start));\n            if (s >= top) {\n                break;\n            }\n            s += sep_len;\n            if (splits > 0) {\n                splits--;\n            }\n        }\n    }\n\n    return res;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_split_obj, 1, 3, mp_obj_str_split);\n\n#if MICROPY_PY_BUILTINS_STR_SPLITLINES\nstatic mp_obj_t str_splitlines(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {\n    enum { ARG_keepends };\n    static const mp_arg_t allowed_args[] = {\n        { MP_QSTR_keepends, MP_ARG_BOOL, {.u_bool = false} },\n    };\n\n    \n    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];\n    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);\n\n    const mp_obj_type_t *self_type = mp_obj_get_type(pos_args[0]);\n    mp_obj_t res = mp_obj_new_list(0, NULL);\n\n    GET_STR_DATA_LEN(pos_args[0], s, len);\n    const byte *top = s + len;\n\n    while (s < top) {\n        const byte *start = s;\n        size_t match = 0;\n        while (s < top) {\n            if (*s == '\\n') {\n                match = 1;\n                break;\n            } else if (*s == '\\r') {\n                if (s[1] == '\\n') {\n                    match = 2;\n                } else {\n                    match = 1;\n                }\n                break;\n            }\n            s++;\n        }\n        size_t sub_len = s - start;\n        if (args[ARG_keepends].u_bool) {\n            sub_len += match;\n        }\n        mp_obj_list_append(res, mp_obj_new_str_of_type(self_type, start, sub_len));\n        s += match;\n    }\n\n    return res;\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(str_splitlines_obj, 1, str_splitlines);\n#endif\n\nstatic mp_obj_t str_rsplit(size_t n_args, const mp_obj_t *args) {\n    if (n_args < 3) {\n        \n        \n        return mp_obj_str_split(n_args, args);\n    }\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n    mp_obj_t sep = args[1];\n    GET_STR_DATA_LEN(args[0], s, len);\n\n    mp_int_t splits = mp_obj_get_int(args[2]);\n    if (splits < 0) {\n        \n        return mp_obj_str_split(n_args, args);\n    }\n\n    mp_int_t org_splits = splits;\n    \n    \n    mp_obj_list_t *res = MP_OBJ_TO_PTR(mp_obj_new_list(splits + 1, NULL));\n    mp_int_t idx = splits;\n\n    if (sep == mp_const_none) {\n        mp_raise_NotImplementedError(MP_ERROR_TEXT(\"rsplit(None,n)\"));\n    } else {\n        size_t sep_len;\n        const char *sep_str = mp_obj_str_get_data(sep, &sep_len);\n\n        if (sep_len == 0) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"empty separator\"));\n        }\n\n        const byte *beg = s;\n        const byte *last = s + len;\n        for (;;) {\n            s = last - sep_len;\n            for (;;) {\n                if (splits == 0 || s < beg) {\n                    break;\n                } else if (memcmp(s, sep_str, sep_len) == 0) {\n                    break;\n                }\n                s--;\n            }\n            if (s < beg || splits == 0) {\n                res->items[idx] = mp_obj_new_str_of_type(self_type, beg, last - beg);\n                break;\n            }\n            res->items[idx--] = mp_obj_new_str_of_type(self_type, s + sep_len, last - s - sep_len);\n            last = s;\n            splits--;\n        }\n        if (idx != 0) {\n            \n            size_t used = org_splits + 1 - idx;\n            memmove(res->items, &res->items[idx], used * sizeof(mp_obj_t));\n            mp_seq_clear(res->items, used, res->alloc, sizeof(*res->items));\n            res->len = used;\n        }\n    }\n\n    return MP_OBJ_FROM_PTR(res);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rsplit_obj, 1, 3, str_rsplit);\n\nstatic mp_obj_t str_finder(size_t n_args, const mp_obj_t *args, int direction, bool is_index) {\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n    check_is_str_or_bytes(args[0]);\n\n    \n    str_check_arg_type(self_type, args[1]);\n\n    GET_STR_DATA_LEN(args[0], haystack, haystack_len);\n    GET_STR_DATA_LEN(args[1], needle, needle_len);\n\n    const byte *start = haystack;\n    const byte *end = haystack + haystack_len;\n    if (n_args >= 3 && args[2] != mp_const_none) {\n        start = str_index_to_ptr(self_type, haystack, haystack_len, args[2], true);\n    }\n    if (n_args >= 4 && args[3] != mp_const_none) {\n        end = str_index_to_ptr(self_type, haystack, haystack_len, args[3], true);\n    }\n\n    if (end < start) {\n        goto out_error;\n    }\n\n    const byte *p = find_subbytes(start, end - start, needle, needle_len, direction);\n    if (p == NULL) {\n    out_error:\n        \n        if (is_index) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"substring not found\"));\n        } else {\n            return MP_OBJ_NEW_SMALL_INT(-1);\n        }\n    } else {\n        \n        #if MICROPY_PY_BUILTINS_STR_UNICODE\n        if (self_type == &mp_type_str) {\n            return MP_OBJ_NEW_SMALL_INT(utf8_ptr_to_index(haystack, p));\n        }\n        #endif\n        return MP_OBJ_NEW_SMALL_INT(p - haystack);\n    }\n}\n\nstatic mp_obj_t str_find(size_t n_args, const mp_obj_t *args) {\n    return str_finder(n_args, args, 1, false);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_find_obj, 2, 4, str_find);\n\nstatic mp_obj_t str_rfind(size_t n_args, const mp_obj_t *args) {\n    return str_finder(n_args, args, -1, false);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rfind_obj, 2, 4, str_rfind);\n\nstatic mp_obj_t str_index(size_t n_args, const mp_obj_t *args) {\n    return str_finder(n_args, args, 1, true);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_index_obj, 2, 4, str_index);\n\nstatic mp_obj_t str_rindex(size_t n_args, const mp_obj_t *args) {\n    return str_finder(n_args, args, -1, true);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rindex_obj, 2, 4, str_rindex);\n\n\nstatic mp_obj_t str_startswith(size_t n_args, const mp_obj_t *args) {\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n    GET_STR_DATA_LEN(args[0], str, str_len);\n    size_t prefix_len;\n    const char *prefix = mp_obj_str_get_data(args[1], &prefix_len);\n    const byte *start = str;\n    if (n_args > 2) {\n        start = str_index_to_ptr(self_type, str, str_len, args[2], true);\n    }\n    if (prefix_len + (start - str) > str_len) {\n        return mp_const_false;\n    }\n    return mp_obj_new_bool(memcmp(start, prefix, prefix_len) == 0);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_startswith_obj, 2, 3, str_startswith);\n\nstatic mp_obj_t str_endswith(size_t n_args, const mp_obj_t *args) {\n    GET_STR_DATA_LEN(args[0], str, str_len);\n    size_t suffix_len;\n    const char *suffix = mp_obj_str_get_data(args[1], &suffix_len);\n    if (n_args > 2) {\n        mp_raise_NotImplementedError(MP_ERROR_TEXT(\"start/end indices\"));\n    }\n\n    if (suffix_len > str_len) {\n        return mp_const_false;\n    }\n    return mp_obj_new_bool(memcmp(str + (str_len - suffix_len), suffix, suffix_len) == 0);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_endswith_obj, 2, 3, str_endswith);\n\nenum { LSTRIP, RSTRIP, STRIP };\n\nstatic mp_obj_t str_uni_strip(int type, size_t n_args, const mp_obj_t *args) {\n    check_is_str_or_bytes(args[0]);\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n\n    const byte *chars_to_del;\n    uint chars_to_del_len;\n    static const byte whitespace[] = \" \\t\\n\\r\\v\\f\";\n\n    if (n_args == 1) {\n        chars_to_del = whitespace;\n        chars_to_del_len = sizeof(whitespace) - 1;\n    } else {\n        str_check_arg_type(self_type, args[1]);\n        GET_STR_DATA_LEN(args[1], s, l);\n        chars_to_del = s;\n        chars_to_del_len = l;\n    }\n\n    GET_STR_DATA_LEN(args[0], orig_str, orig_str_len);\n\n    size_t first_good_char_pos = 0;\n    bool first_good_char_pos_set = false;\n    size_t last_good_char_pos = 0;\n    size_t i = 0;\n    int delta = 1;\n    if (type == RSTRIP) {\n        i = orig_str_len - 1;\n        delta = -1;\n    }\n    for (size_t len = orig_str_len; len > 0; len--) {\n        if (find_subbytes(chars_to_del, chars_to_del_len, &orig_str[i], 1, 1) == NULL) {\n            if (!first_good_char_pos_set) {\n                first_good_char_pos_set = true;\n                first_good_char_pos = i;\n                if (type == LSTRIP) {\n                    last_good_char_pos = orig_str_len - 1;\n                    break;\n                } else if (type == RSTRIP) {\n                    first_good_char_pos = 0;\n                    last_good_char_pos = i;\n                    break;\n                }\n            }\n            last_good_char_pos = i;\n        }\n        i += delta;\n    }\n\n    if (!first_good_char_pos_set) {\n        \n        if (self_type == &mp_type_str) {\n            return MP_OBJ_NEW_QSTR(MP_QSTR_);\n        } else {\n            return mp_const_empty_bytes;\n        }\n    }\n\n    assert(last_good_char_pos >= first_good_char_pos);\n    \n    size_t stripped_len = last_good_char_pos - first_good_char_pos + 1;\n    if (stripped_len == orig_str_len) {\n        \n        \n        assert(first_good_char_pos == 0);\n        return args[0];\n    }\n    return mp_obj_new_str_of_type(self_type, orig_str + first_good_char_pos, stripped_len);\n}\n\nstatic mp_obj_t str_strip(size_t n_args, const mp_obj_t *args) {\n    return str_uni_strip(STRIP, n_args, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_strip_obj, 1, 2, str_strip);\n\nstatic mp_obj_t str_lstrip(size_t n_args, const mp_obj_t *args) {\n    return str_uni_strip(LSTRIP, n_args, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_lstrip_obj, 1, 2, str_lstrip);\n\nstatic mp_obj_t str_rstrip(size_t n_args, const mp_obj_t *args) {\n    return str_uni_strip(RSTRIP, n_args, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rstrip_obj, 1, 2, str_rstrip);\n\n#if MICROPY_PY_BUILTINS_STR_CENTER\nstatic mp_obj_t str_center(mp_obj_t str_in, mp_obj_t width_in) {\n    GET_STR_DATA_LEN(str_in, str, str_len);\n    mp_uint_t width = mp_obj_get_int(width_in);\n    if (str_len >= width) {\n        return str_in;\n    }\n\n    vstr_t vstr;\n    vstr_init_len(&vstr, width);\n    memset(vstr.buf, ' ', width);\n    int left = (width - str_len) / 2;\n    memcpy(vstr.buf + left, str, str_len);\n    return mp_obj_new_str_type_from_vstr(mp_obj_get_type(str_in), &vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(str_center_obj, str_center);\n#endif\n\n\n\nstatic const char *str_to_int(const char *str, const char *top, int *num) {\n    if (str < top && '0' <= *str && *str <= '9') {\n        *num = 0;\n        do {\n            *num = *num * 10 + (*str - '0');\n            str++;\n        }\n        while (str < top && '0' <= *str && *str <= '9');\n    }\n    return str;\n}\n\nstatic bool isalignment(char ch) {\n    return ch && strchr(\"<>=^\", ch) != NULL;\n}\n\nstatic bool istype(char ch) {\n    return ch && strchr(\"bcdeEfFgGnosxX%\", ch) != NULL;\n}\n\nstatic bool arg_looks_integer(mp_obj_t arg) {\n    return mp_obj_is_bool(arg) || mp_obj_is_int(arg);\n}\n\nstatic bool arg_looks_numeric(mp_obj_t arg) {\n    return arg_looks_integer(arg)\n           #if MICROPY_PY_BUILTINS_FLOAT\n           || mp_obj_is_float(arg)\n           #endif\n    ;\n}\n\n#if MICROPY_PY_BUILTINS_STR_OP_MODULO\nstatic mp_obj_t arg_as_int(mp_obj_t arg) {\n    #if MICROPY_PY_BUILTINS_FLOAT\n    if (mp_obj_is_float(arg)) {\n        return mp_obj_new_int_from_float(mp_obj_float_get(arg));\n    }\n    #endif\n    return arg;\n}\n#endif\n\n#if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\nstatic NORETURN void terse_str_format_value_error(void) {\n    mp_raise_ValueError(MP_ERROR_TEXT(\"bad format string\"));\n}\n#else\n\n#define terse_str_format_value_error()\n#endif\n\nstatic vstr_t mp_obj_str_format_helper(const char *str, const char *top, int *arg_i, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    vstr_t vstr;\n    mp_print_t print;\n    vstr_init_print(&vstr, 16, &print);\n\n    for (; str < top; str++) {\n        if (*str == '}') {\n            str++;\n            if (str < top && *str == '}') {\n                vstr_add_byte(&vstr, '}');\n                continue;\n            }\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            terse_str_format_value_error();\n            #else\n            mp_raise_ValueError(MP_ERROR_TEXT(\"single '}' encountered in format string\"));\n            #endif\n        }\n        if (*str != '{') {\n            vstr_add_byte(&vstr, *str);\n            continue;\n        }\n\n        str++;\n        if (str < top && *str == '{') {\n            vstr_add_byte(&vstr, '{');\n            continue;\n        }\n\n        \n\n        const char *field_name = NULL;\n        const char *field_name_top = NULL;\n        char conversion = '\\0';\n        const char *format_spec = NULL;\n\n        if (str < top && *str != '}' && *str != '!' && *str != ':') {\n            field_name = (const char *)str;\n            while (str < top && *str != '}' && *str != '!' && *str != ':') {\n                ++str;\n            }\n            field_name_top = (const char *)str;\n        }\n\n        \n\n        if (str < top && *str == '!') {\n            str++;\n            if (str < top && (*str == 'r' || *str == 's')) {\n                conversion = *str++;\n            } else {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL\n                mp_raise_ValueError(MP_ERROR_TEXT(\"bad conversion specifier\"));\n                #else\n                if (str >= top) {\n                    mp_raise_ValueError(\n                        MP_ERROR_TEXT(\"end of format while looking for conversion specifier\"));\n                } else {\n                    mp_raise_msg_varg(&mp_type_ValueError,\n                        MP_ERROR_TEXT(\"unknown conversion specifier %c\"), *str);\n                }\n                #endif\n            }\n        }\n\n        if (str < top && *str == ':') {\n            str++;\n            \n            \n            \n            \n            \n            if (*str != '}') {\n                format_spec = str;\n                for (int nest = 1; str < top;) {\n                    if (*str == '{') {\n                        ++nest;\n                    } else if (*str == '}') {\n                        if (--nest == 0) {\n                            break;\n                        }\n                    }\n                    ++str;\n                }\n            }\n        }\n        if (str >= top) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            terse_str_format_value_error();\n            #else\n            mp_raise_ValueError(MP_ERROR_TEXT(\"unmatched '{' in format\"));\n            #endif\n        }\n        if (*str != '}') {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            terse_str_format_value_error();\n            #else\n            mp_raise_ValueError(MP_ERROR_TEXT(\"expected ':' after format specifier\"));\n            #endif\n        }\n\n        mp_obj_t arg = mp_const_none;\n\n        if (field_name) {\n            int index = 0;\n            if (MP_LIKELY(unichar_isdigit(*field_name))) {\n                if (*arg_i > 0) {\n                    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                    terse_str_format_value_error();\n                    #else\n                    mp_raise_ValueError(\n                        MP_ERROR_TEXT(\"can't switch from automatic field numbering to manual field specification\"));\n                    #endif\n                }\n                field_name = str_to_int(field_name, field_name_top, &index);\n                if ((uint)index >= n_args - 1) {\n                    mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"tuple index out of range\"));\n                }\n                arg = args[index + 1];\n                *arg_i = -1;\n            } else {\n                const char *lookup;\n                for (lookup = field_name; lookup < field_name_top && *lookup != '.' && *lookup != '['; lookup++) {;\n                }\n                mp_obj_t field_q = mp_obj_new_str_via_qstr(field_name, lookup - field_name); \n                field_name = lookup;\n                mp_map_elem_t *key_elem = mp_map_lookup(kwargs, field_q, MP_MAP_LOOKUP);\n                if (key_elem == NULL) {\n                    mp_raise_type_arg(&mp_type_KeyError, field_q);\n                }\n                arg = key_elem->value;\n            }\n            if (field_name < field_name_top) {\n                mp_raise_NotImplementedError(MP_ERROR_TEXT(\"attributes not supported\"));\n            }\n        } else {\n            if (*arg_i < 0) {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #else\n                mp_raise_ValueError(\n                    MP_ERROR_TEXT(\"can't switch from manual field specification to automatic field numbering\"));\n                #endif\n            }\n            if ((uint)*arg_i >= n_args - 1) {\n                mp_raise_msg(&mp_type_IndexError, MP_ERROR_TEXT(\"tuple index out of range\"));\n            }\n            arg = args[(*arg_i) + 1];\n            (*arg_i)++;\n        }\n        if (!format_spec && !conversion) {\n            conversion = 's';\n        }\n        if (conversion) {\n            mp_print_kind_t print_kind;\n            if (conversion == 's') {\n                print_kind = PRINT_STR;\n            } else {\n                assert(conversion == 'r');\n                print_kind = PRINT_REPR;\n            }\n            vstr_t arg_vstr;\n            mp_print_t arg_print;\n            vstr_init_print(&arg_vstr, 16, &arg_print);\n            mp_obj_print_helper(&arg_print, arg, print_kind);\n            arg = mp_obj_new_str_type_from_vstr(&mp_type_str, &arg_vstr);\n        }\n\n        char fill = '\\0';\n        char align = '\\0';\n        int width = -1;\n        int precision = -1;\n        char type = '\\0';\n        int flags = 0;\n\n        if (format_spec) {\n            \n            \n            \n            \n            \n            \n            \n            \n            \n\n            \n            MP_STACK_CHECK();\n            vstr_t format_spec_vstr = mp_obj_str_format_helper(format_spec, str, arg_i, n_args, args, kwargs);\n            const char *s = vstr_null_terminated_str(&format_spec_vstr);\n            const char *stop = s + format_spec_vstr.len;\n            if (isalignment(*s)) {\n                align = *s++;\n            } else if (*s && isalignment(s[1])) {\n                fill = *s++;\n                align = *s++;\n            }\n            if (*s == '+' || *s == '-' || *s == ' ') {\n                if (*s == '+') {\n                    flags |= PF_FLAG_SHOW_SIGN;\n                } else if (*s == ' ') {\n                    flags |= PF_FLAG_SPACE_SIGN;\n                }\n                s++;\n            }\n            if (*s == '#') {\n                flags |= PF_FLAG_SHOW_PREFIX;\n                s++;\n            }\n            if (*s == '0') {\n                if (!align && arg_looks_numeric(arg)) {\n                    align = '=';\n                }\n                if (!fill) {\n                    fill = '0';\n                }\n            }\n            s = str_to_int(s, stop, &width);\n            if (*s == ',') {\n                flags |= PF_FLAG_SHOW_COMMA;\n                s++;\n            }\n            if (*s == '.') {\n                s++;\n                s = str_to_int(s, stop, &precision);\n            }\n            if (istype(*s)) {\n                type = *s++;\n            }\n            if (*s) {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #else\n                mp_raise_ValueError(MP_ERROR_TEXT(\"invalid format specifier\"));\n                #endif\n            }\n            vstr_clear(&format_spec_vstr);\n        }\n        if (!align) {\n            if (arg_looks_numeric(arg)) {\n                align = '>';\n            } else {\n                align = '<';\n            }\n        }\n        if (!fill) {\n            fill = ' ';\n        }\n\n        if (flags & (PF_FLAG_SHOW_SIGN | PF_FLAG_SPACE_SIGN)) {\n            if (type == 's') {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #else\n                mp_raise_ValueError(MP_ERROR_TEXT(\"sign not allowed in string format specifier\"));\n                #endif\n            }\n            if (type == 'c') {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #else\n                mp_raise_ValueError(\n                    MP_ERROR_TEXT(\"sign not allowed with integer format specifier 'c'\"));\n                #endif\n            }\n        }\n\n        switch (align) {\n            case '<':\n                flags |= PF_FLAG_LEFT_ADJUST;\n                break;\n            case '=':\n                flags |= PF_FLAG_PAD_AFTER_SIGN;\n                break;\n            case '^':\n                flags |= PF_FLAG_CENTER_ADJUST;\n                break;\n        }\n\n        if (arg_looks_integer(arg)) {\n            switch (type) {\n                case 'b':\n                    mp_print_mp_int(&print, arg, 2, 'a', flags, fill, width, 0);\n                    continue;\n\n                case 'c': {\n                    char ch = mp_obj_get_int(arg);\n                    mp_print_strn(&print, &ch, 1, flags, fill, width);\n                    continue;\n                }\n\n                case '\\0':  \n                case 'n':   \n                case 'd':\n                    mp_print_mp_int(&print, arg, 10, 'a', flags, fill, width, 0);\n                    continue;\n\n                case 'o':\n                    if (flags & PF_FLAG_SHOW_PREFIX) {\n                        flags |= PF_FLAG_SHOW_OCTAL_LETTER;\n                    }\n\n                    mp_print_mp_int(&print, arg, 8, 'a', flags, fill, width, 0);\n                    continue;\n\n                case 'X':\n                case 'x':\n                    mp_print_mp_int(&print, arg, 16, type - ('X' - 'A'), flags, fill, width, 0);\n                    continue;\n\n                case 'e':\n                case 'E':\n                case 'f':\n                case 'F':\n                case 'g':\n                case 'G':\n                case '%':\n                    \n                    \n                    break;\n\n                default:\n                    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                    terse_str_format_value_error();\n                    #else\n                    mp_raise_msg_varg(&mp_type_ValueError,\n                        MP_ERROR_TEXT(\"unknown format code '%c' for object of type '%s'\"),\n                        type, mp_obj_get_type_str(arg));\n                    #endif\n            }\n        }\n\n        \n        \n        if (arg_looks_numeric(arg)) {\n            if (!type) {\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n\n                type = 'g';\n            }\n            if (type == 'n') {\n                type = 'g';\n            }\n\n            switch (type) {\n                #if MICROPY_PY_BUILTINS_FLOAT\n                case 'e':\n                case 'E':\n                case 'f':\n                case 'F':\n                case 'g':\n                case 'G':\n                    mp_print_float(&print, mp_obj_get_float(arg), type, flags, fill, width, precision);\n                    break;\n\n                case '%':\n                    flags |= PF_FLAG_ADD_PERCENT;\n                    #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n                    #define F100 100.0F\n                    #else\n                    #define F100 100.0\n                    #endif\n                    mp_print_float(&print, mp_obj_get_float(arg) * F100, 'f', flags, fill, width, precision);\n#undef F100\n                    break;\n                #endif\n\n                default:\n                    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                    terse_str_format_value_error();\n                    #else\n                    mp_raise_msg_varg(&mp_type_ValueError,\n                        MP_ERROR_TEXT(\"unknown format code '%c' for object of type '%s'\"),\n                        type, mp_obj_get_type_str(arg));\n                    #endif\n            }\n        } else {\n            \n\n            if (align == '=') {\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #else\n                mp_raise_ValueError(\n                    MP_ERROR_TEXT(\"'=' alignment not allowed in string format specifier\"));\n                #endif\n            }\n\n            switch (type) {\n                case '\\0': \n                case 's': {\n                    size_t slen;\n                    const char *s = mp_obj_str_get_data(arg, &slen);\n                    if (precision < 0) {\n                        precision = slen;\n                    }\n                    if (slen > (size_t)precision) {\n                        slen = precision;\n                    }\n                    mp_print_strn(&print, s, slen, flags, fill, width);\n                    break;\n                }\n\n                default:\n                    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                    terse_str_format_value_error();\n                    #else\n                    mp_raise_msg_varg(&mp_type_ValueError,\n                        MP_ERROR_TEXT(\"unknown format code '%c' for object of type '%s'\"),\n                        type, mp_obj_get_type_str(arg));\n                    #endif\n            }\n        }\n    }\n\n    return vstr;\n}\n\nmp_obj_t mp_obj_str_format(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    check_is_str_or_bytes(args[0]);\n\n    GET_STR_DATA_LEN(args[0], str, len);\n    int arg_i = 0;\n    vstr_t vstr = mp_obj_str_format_helper((const char *)str, (const char *)str + len, &arg_i, n_args, args, kwargs);\n    return mp_obj_new_str_type_from_vstr(mp_obj_get_type(args[0]), &vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_KW(str_format_obj, 1, mp_obj_str_format);\n\n#if MICROPY_PY_BUILTINS_STR_OP_MODULO\nstatic mp_obj_t str_modulo_format(mp_obj_t pattern, size_t n_args, const mp_obj_t *args, mp_obj_t dict) {\n    check_is_str_or_bytes(pattern);\n\n    GET_STR_DATA_LEN(pattern, str, len);\n    #if MICROPY_ERROR_REPORTING > MICROPY_ERROR_REPORTING_TERSE\n    const byte *start_str = str;\n    #endif\n    bool is_bytes = mp_obj_is_type(pattern, &mp_type_bytes);\n    size_t arg_i = 0;\n    vstr_t vstr;\n    mp_print_t print;\n    vstr_init_print(&vstr, 16, &print);\n\n    for (const byte *top = str + len; str < top; str++) {\n        mp_obj_t arg = MP_OBJ_NULL;\n        if (*str != '%') {\n            vstr_add_byte(&vstr, *str);\n            continue;\n        }\n        if (++str >= top) {\n            goto incomplete_format;\n        }\n        if (*str == '%') {\n            vstr_add_byte(&vstr, '%');\n            continue;\n        }\n\n        \n        if (*str == '(') {\n            if (dict == MP_OBJ_NULL) {\n                mp_raise_TypeError(MP_ERROR_TEXT(\"format needs a dict\"));\n            }\n            arg_i = 1; \n            const byte *key = ++str;\n            while (*str != ')') {\n                if (str >= top) {\n                    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                    terse_str_format_value_error();\n                    #else\n                    mp_raise_ValueError(MP_ERROR_TEXT(\"incomplete format key\"));\n                    #endif\n                }\n                ++str;\n            }\n            mp_obj_t k_obj = mp_obj_new_str_via_qstr((const char *)key, str - key);\n            arg = mp_obj_dict_get(dict, k_obj);\n            str++;\n        }\n\n        int flags = 0;\n        char fill = ' ';\n        int alt = 0;\n        while (str < top) {\n            if (*str == '-') {\n                flags |= PF_FLAG_LEFT_ADJUST;\n            } else if (*str == '+') {\n                flags |= PF_FLAG_SHOW_SIGN;\n            } else if (*str == ' ') {\n                flags |= PF_FLAG_SPACE_SIGN;\n            } else if (*str == '#') {\n                alt = PF_FLAG_SHOW_PREFIX;\n            } else if (*str == '0') {\n                flags |= PF_FLAG_PAD_AFTER_SIGN;\n                fill = '0';\n            } else {\n                break;\n            }\n            str++;\n        }\n        \n        int width = 0;\n        if (str < top) {\n            if (*str == '*') {\n                if (arg_i >= n_args) {\n                    goto not_enough_args;\n                }\n                width = mp_obj_get_int(args[arg_i++]);\n                str++;\n            } else {\n                str = (const byte *)str_to_int((const char *)str, (const char *)top, &width);\n            }\n        }\n        int prec = -1;\n        if (str < top && *str == '.') {\n            if (++str < top) {\n                if (*str == '*') {\n                    if (arg_i >= n_args) {\n                        goto not_enough_args;\n                    }\n                    prec = mp_obj_get_int(args[arg_i++]);\n                    str++;\n                } else {\n                    prec = 0;\n                    str = (const byte *)str_to_int((const char *)str, (const char *)top, &prec);\n                }\n            }\n        }\n\n        if (str >= top) {\n        incomplete_format:\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            terse_str_format_value_error();\n            #else\n            mp_raise_ValueError(MP_ERROR_TEXT(\"incomplete format\"));\n            #endif\n        }\n\n        \n        if (arg == MP_OBJ_NULL) {\n            if (arg_i >= n_args) {\n            not_enough_args:\n                mp_raise_TypeError(MP_ERROR_TEXT(\"format string needs more arguments\"));\n            }\n            arg = args[arg_i++];\n        }\n        switch (*str) {\n            case 'c':\n                if (mp_obj_is_str(arg)) {\n                    size_t slen;\n                    const char *s = mp_obj_str_get_data(arg, &slen);\n                    if (slen != 1) {\n                        mp_raise_TypeError(MP_ERROR_TEXT(\"%c needs int or char\"));\n                    }\n                    mp_print_strn(&print, s, 1, flags, ' ', width);\n                } else if (arg_looks_integer(arg)) {\n                    char ch = mp_obj_get_int(arg);\n                    mp_print_strn(&print, &ch, 1, flags, ' ', width);\n                } else {\n                    mp_raise_TypeError(MP_ERROR_TEXT(\"integer needed\"));\n                }\n                break;\n\n            case 'd':\n            case 'i':\n            case 'u':\n                mp_print_mp_int(&print, arg_as_int(arg), 10, 'a', flags, fill, width, prec);\n                break;\n\n            #if MICROPY_PY_BUILTINS_FLOAT\n            case 'e':\n            case 'E':\n            case 'f':\n            case 'F':\n            case 'g':\n            case 'G':\n                mp_print_float(&print, mp_obj_get_float(arg), *str, flags, fill, width, prec);\n                break;\n            #endif\n\n            case 'o':\n                if (alt) {\n                    flags |= (PF_FLAG_SHOW_PREFIX | PF_FLAG_SHOW_OCTAL_LETTER);\n                }\n                mp_print_mp_int(&print, arg, 8, 'a', flags, fill, width, prec);\n                break;\n\n            case 'r':\n            case 's': {\n                vstr_t arg_vstr;\n                mp_print_t arg_print;\n                vstr_init_print(&arg_vstr, 16, &arg_print);\n                mp_print_kind_t print_kind = (*str == 'r' ? PRINT_REPR : PRINT_STR);\n                if (print_kind == PRINT_STR && is_bytes && mp_obj_is_type(arg, &mp_type_bytes)) {\n                    \n                    \n                    print_kind = PRINT_RAW;\n                }\n                mp_obj_print_helper(&arg_print, arg, print_kind);\n                uint vlen = arg_vstr.len;\n                if (prec < 0) {\n                    prec = vlen;\n                }\n                if (vlen > (uint)prec) {\n                    vlen = prec;\n                }\n                mp_print_strn(&print, arg_vstr.buf, vlen, flags, ' ', width);\n                vstr_clear(&arg_vstr);\n                break;\n            }\n\n            case 'X':\n            case 'x':\n                mp_print_mp_int(&print, arg, 16, *str - ('X' - 'A'), flags | alt, fill, width, prec);\n                break;\n\n            default:\n                #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                terse_str_format_value_error();\n                #else\n                mp_raise_msg_varg(&mp_type_ValueError,\n                    MP_ERROR_TEXT(\"unsupported format character '%c' (0x%x) at index %d\"),\n                    *str, *str, str - start_str);\n                #endif\n        }\n    }\n\n    if (dict == MP_OBJ_NULL && arg_i != n_args) {\n        \n        \n        mp_raise_TypeError(MP_ERROR_TEXT(\"format string didn't convert all arguments\"));\n    }\n\n    return mp_obj_new_str_type_from_vstr(is_bytes ? &mp_type_bytes : &mp_type_str, &vstr);\n}\n#endif\n\n\n\nstatic mp_obj_t str_replace(size_t n_args, const mp_obj_t *args) {\n    check_is_str_or_bytes(args[0]);\n\n    mp_int_t max_rep = -1;\n    if (n_args == 4) {\n        max_rep = mp_obj_get_int(args[3]);\n        if (max_rep == 0) {\n            return args[0];\n        } else if (max_rep < 0) {\n            max_rep = -1;\n        }\n    }\n\n    \n\n    \n\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n\n    str_check_arg_type(self_type, args[1]);\n    str_check_arg_type(self_type, args[2]);\n\n    \n\n    GET_STR_DATA_LEN(args[0], str, str_len);\n    GET_STR_DATA_LEN(args[1], old, old_len);\n    GET_STR_DATA_LEN(args[2], new, new_len);\n\n    \n    if (old_len > str_len) {\n        return args[0];\n    }\n\n    \n    byte *data = NULL;\n    vstr_t vstr;\n\n    \n    \n    \n    for (;;) {\n        size_t replaced_str_index = 0;\n        size_t num_replacements_done = 0;\n        const byte *old_occurrence;\n        const byte *offset_ptr = str;\n        size_t str_len_remain = str_len;\n        if (old_len == 0) {\n            \n            \n            if (data != NULL) {\n                memcpy(data, new, new_len);\n            }\n            replaced_str_index += new_len;\n            num_replacements_done++;\n        }\n        while (num_replacements_done != (size_t)max_rep && str_len_remain > 0 && (old_occurrence = find_subbytes(offset_ptr, str_len_remain, old, old_len, 1)) != NULL) {\n            if (old_len == 0) {\n                old_occurrence += 1;\n            }\n            \n            if (data != NULL) {\n                memcpy(data + replaced_str_index, offset_ptr, old_occurrence - offset_ptr);\n            }\n            replaced_str_index += old_occurrence - offset_ptr;\n            \n            if (data != NULL) {\n                memcpy(data + replaced_str_index, new, new_len);\n            }\n            replaced_str_index += new_len;\n            offset_ptr = old_occurrence + old_len;\n            str_len_remain = str + str_len - offset_ptr;\n            num_replacements_done++;\n        }\n\n        \n        if (data != NULL) {\n            memcpy(data + replaced_str_index, offset_ptr, str_len_remain);\n        }\n        replaced_str_index += str_len_remain;\n\n        if (data == NULL) {\n            \n            if (num_replacements_done == 0) {\n                \n                return args[0];\n            } else {\n                \n                vstr_init_len(&vstr, replaced_str_index);\n                data = (byte *)vstr.buf;\n                assert(data != NULL);\n            }\n        } else {\n            \n            break;\n        }\n    }\n\n    return mp_obj_new_str_type_from_vstr(self_type, &vstr);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_replace_obj, 3, 4, str_replace);\n\n#if MICROPY_PY_BUILTINS_STR_COUNT\nstatic mp_obj_t str_count(size_t n_args, const mp_obj_t *args) {\n    const mp_obj_type_t *self_type = mp_obj_get_type(args[0]);\n    check_is_str_or_bytes(args[0]);\n\n    \n    str_check_arg_type(self_type, args[1]);\n\n    GET_STR_DATA_LEN(args[0], haystack, haystack_len);\n    GET_STR_DATA_LEN(args[1], needle, needle_len);\n\n    const byte *start = haystack;\n    const byte *end = haystack + haystack_len;\n    if (n_args >= 3 && args[2] != mp_const_none) {\n        start = str_index_to_ptr(self_type, haystack, haystack_len, args[2], true);\n    }\n    if (n_args >= 4 && args[3] != mp_const_none) {\n        end = str_index_to_ptr(self_type, haystack, haystack_len, args[3], true);\n    }\n\n    \n    if (needle_len == 0) {\n        return MP_OBJ_NEW_SMALL_INT(utf8_charlen(start, end - start) + 1);\n    }\n\n    bool is_str = self_type == &mp_type_str;\n\n    \n    mp_int_t num_occurrences = 0;\n    for (const byte *haystack_ptr = start; haystack_ptr + needle_len <= end;) {\n        if (memcmp(haystack_ptr, needle, needle_len) == 0) {\n            num_occurrences++;\n            haystack_ptr += needle_len;\n        } else {\n            haystack_ptr = is_str ? utf8_next_char(haystack_ptr) : haystack_ptr + 1;\n        }\n    }\n\n    return MP_OBJ_NEW_SMALL_INT(num_occurrences);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_count_obj, 2, 4, str_count);\n#endif\n\n#if MICROPY_PY_BUILTINS_STR_PARTITION\nstatic mp_obj_t str_partitioner(mp_obj_t self_in, mp_obj_t arg, int direction) {\n    check_is_str_or_bytes(self_in);\n    const mp_obj_type_t *self_type = mp_obj_get_type(self_in);\n    str_check_arg_type(self_type, arg);\n\n    GET_STR_DATA_LEN(self_in, str, str_len);\n    GET_STR_DATA_LEN(arg, sep, sep_len);\n\n    if (sep_len == 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"empty separator\"));\n    }\n\n    mp_obj_t result[3];\n    if (self_type == &mp_type_str) {\n        result[0] = MP_OBJ_NEW_QSTR(MP_QSTR_);\n        result[1] = MP_OBJ_NEW_QSTR(MP_QSTR_);\n        result[2] = MP_OBJ_NEW_QSTR(MP_QSTR_);\n    } else {\n        result[0] = mp_const_empty_bytes;\n        result[1] = mp_const_empty_bytes;\n        result[2] = mp_const_empty_bytes;\n    }\n\n    if (direction > 0) {\n        result[0] = self_in;\n    } else {\n        result[2] = self_in;\n    }\n\n    #if MICROPY_PY_BUILTINS_BYTEARRAY\n    if (mp_obj_get_type(arg) != self_type) {\n        arg = mp_obj_new_str_of_type(self_type, sep, sep_len);\n    }\n    #endif\n\n    const byte *position_ptr = find_subbytes(str, str_len, sep, sep_len, direction);\n    if (position_ptr != NULL) {\n        size_t position = position_ptr - str;\n        result[0] = mp_obj_new_str_of_type(self_type, str, position);\n        result[1] = arg;\n        result[2] = mp_obj_new_str_of_type(self_type, str + position + sep_len, str_len - position - sep_len);\n    }\n\n    return mp_obj_new_tuple(3, result);\n}\n\nstatic mp_obj_t str_partition(mp_obj_t self_in, mp_obj_t arg) {\n    return str_partitioner(self_in, arg, 1);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(str_partition_obj, str_partition);\n\nstatic mp_obj_t str_rpartition(mp_obj_t self_in, mp_obj_t arg) {\n    return str_partitioner(self_in, arg, -1);\n}\nMP_DEFINE_CONST_FUN_OBJ_2(str_rpartition_obj, str_rpartition);\n#endif\n\n\nstatic mp_obj_t str_caseconv(unichar (*op)(unichar), mp_obj_t self_in) {\n    GET_STR_DATA_LEN(self_in, self_data, self_len);\n    vstr_t vstr;\n    vstr_init_len(&vstr, self_len);\n    byte *data = (byte *)vstr.buf;\n    for (size_t i = 0; i < self_len; i++) {\n        *data++ = op(*self_data++);\n    }\n    return mp_obj_new_str_type_from_vstr(mp_obj_get_type(self_in), &vstr);\n}\n\nstatic mp_obj_t str_lower(mp_obj_t self_in) {\n    return str_caseconv(unichar_tolower, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_lower_obj, str_lower);\n\nstatic mp_obj_t str_upper(mp_obj_t self_in) {\n    return str_caseconv(unichar_toupper, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_upper_obj, str_upper);\n\nstatic mp_obj_t str_uni_istype(bool (*f)(unichar), mp_obj_t self_in) {\n    GET_STR_DATA_LEN(self_in, self_data, self_len);\n\n    if (self_len == 0) {\n        return mp_const_false; \n    }\n\n    if (f != unichar_isupper && f != unichar_islower) {\n        for (size_t i = 0; i < self_len; i++) {\n            if (!f(*self_data++)) {\n                return mp_const_false;\n            }\n        }\n    } else {\n        bool contains_alpha = false;\n\n        for (size_t i = 0; i < self_len; i++) { \n            if (unichar_isalpha(*self_data++)) {\n                contains_alpha = true;\n                if (!f(*(self_data - 1))) { \n                    return mp_const_false;\n                }\n            }\n        }\n\n        if (!contains_alpha) {\n            return mp_const_false;\n        }\n    }\n\n    return mp_const_true;\n}\n\nstatic mp_obj_t str_isspace(mp_obj_t self_in) {\n    return str_uni_istype(unichar_isspace, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_isspace_obj, str_isspace);\n\nstatic mp_obj_t str_isalpha(mp_obj_t self_in) {\n    return str_uni_istype(unichar_isalpha, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_isalpha_obj, str_isalpha);\n\nstatic mp_obj_t str_isdigit(mp_obj_t self_in) {\n    return str_uni_istype(unichar_isdigit, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_isdigit_obj, str_isdigit);\n\nstatic mp_obj_t str_isupper(mp_obj_t self_in) {\n    return str_uni_istype(unichar_isupper, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_isupper_obj, str_isupper);\n\nstatic mp_obj_t str_islower(mp_obj_t self_in) {\n    return str_uni_istype(unichar_islower, self_in);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(str_islower_obj, str_islower);\n\n#if MICROPY_CPYTHON_COMPAT\n\n\n\nstatic mp_obj_t bytes_decode(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t new_args[2];\n    if (n_args == 1) {\n        new_args[0] = args[0];\n        new_args[1] = MP_OBJ_NEW_QSTR(MP_QSTR_utf_hyphen_8);\n        args = new_args;\n        n_args++;\n    }\n    return mp_obj_str_make_new(&mp_type_str, n_args, 0, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bytes_decode_obj, 1, 3, bytes_decode);\n\n\nstatic mp_obj_t str_encode(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t new_args[2];\n    if (n_args == 1) {\n        new_args[0] = args[0];\n        new_args[1] = MP_OBJ_NEW_QSTR(MP_QSTR_utf_hyphen_8);\n        args = new_args;\n        n_args++;\n    }\n    return bytes_make_new(NULL, n_args, 0, args);\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_encode_obj, 1, 3, str_encode);\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTES_HEX\nmp_obj_t mp_obj_bytes_hex(size_t n_args, const mp_obj_t *args, const mp_obj_type_t *type) {\n    \n    \n    const char *sep = NULL;\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[0], &bufinfo, MP_BUFFER_READ);\n\n    \n    \n    if (bufinfo.len == 0) {\n        return mp_const_empty_bytes;\n    }\n\n    vstr_t vstr;\n    size_t out_len = bufinfo.len * 2;\n    if (n_args > 1) {\n        \n        out_len += bufinfo.len - 1;\n        sep = mp_obj_str_get_str(args[1]);\n    }\n    vstr_init_len(&vstr, out_len);\n    byte *in = bufinfo.buf, *out = (byte *)vstr.buf;\n    for (mp_uint_t i = bufinfo.len; i--;) {\n        byte d = (*in >> 4);\n        if (d > 9) {\n            d += 'a' - '9' - 1;\n        }\n        *out++ = d + '0';\n        d = (*in++ & 0xf);\n        if (d > 9) {\n            d += 'a' - '9' - 1;\n        }\n        *out++ = d + '0';\n        if (sep != NULL && i != 0) {\n            *out++ = *sep;\n        }\n    }\n    return mp_obj_new_str_type_from_vstr(type, &vstr);\n}\n\nmp_obj_t mp_obj_bytes_fromhex(mp_obj_t type_in, mp_obj_t data) {\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(data, &bufinfo, MP_BUFFER_READ);\n\n    if ((bufinfo.len & 1) != 0) {\n        mp_raise_ValueError(MP_ERROR_TEXT(\"odd-length string\"));\n    }\n    vstr_t vstr;\n    vstr_init_len(&vstr, bufinfo.len / 2);\n    byte *in = bufinfo.buf, *out = (byte *)vstr.buf;\n    byte hex_byte = 0;\n    for (mp_uint_t i = bufinfo.len; i--;) {\n        byte hex_ch = *in++;\n        if (unichar_isxdigit(hex_ch)) {\n            hex_byte += unichar_xdigit_value(hex_ch);\n        } else {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"non-hex digit found\"));\n        }\n        if (i & 1) {\n            hex_byte <<= 4;\n        } else {\n            *out++ = hex_byte;\n            hex_byte = 0;\n        }\n    }\n    return mp_obj_new_str_type_from_vstr(MP_OBJ_TO_PTR(type_in), &vstr);\n}\n\nstatic mp_obj_t bytes_hex_as_str(size_t n_args, const mp_obj_t *args) {\n    return mp_obj_bytes_hex(n_args, args, &mp_type_str);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bytes_hex_as_str_obj, 1, 2, bytes_hex_as_str);\n\nstatic MP_DEFINE_CONST_FUN_OBJ_2(bytes_fromhex_obj, mp_obj_bytes_fromhex);\nstatic MP_DEFINE_CONST_CLASSMETHOD_OBJ(bytes_fromhex_classmethod_obj, MP_ROM_PTR(&bytes_fromhex_obj));\n#endif \n\nmp_int_t mp_obj_str_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    if (flags == MP_BUFFER_READ) {\n        GET_STR_DATA_LEN(self_in, str_data, str_len);\n        bufinfo->buf = (void *)str_data;\n        bufinfo->len = str_len;\n        bufinfo->typecode = 'B'; \n        return 0;\n    } else {\n        \n        return 1;\n    }\n}\n\nvoid mp_obj_str_set_data(mp_obj_str_t *str, const byte *data, size_t len) {\n    str->data = data;\n    str->len = len;\n    str->hash = qstr_compute_hash(data, len);\n}\n\n\n\nstatic const mp_rom_map_elem_t array_bytearray_str_bytes_locals_table[] = {\n    #if MICROPY_PY_ARRAY || MICROPY_PY_BUILTINS_BYTEARRAY\n    { MP_ROM_QSTR(MP_QSTR_append), MP_ROM_PTR(&mp_obj_array_append_obj) },\n    { MP_ROM_QSTR(MP_QSTR_extend), MP_ROM_PTR(&mp_obj_array_extend_obj) },\n    #endif\n    #if MICROPY_PY_BUILTINS_BYTES_HEX\n    { MP_ROM_QSTR(MP_QSTR_hex), MP_ROM_PTR(&bytes_hex_as_str_obj) },\n    { MP_ROM_QSTR(MP_QSTR_fromhex), MP_ROM_PTR(&bytes_fromhex_classmethod_obj) },\n    #endif\n    #if MICROPY_CPYTHON_COMPAT\n    { MP_ROM_QSTR(MP_QSTR_decode), MP_ROM_PTR(&bytes_decode_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_find), MP_ROM_PTR(&str_find_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rfind), MP_ROM_PTR(&str_rfind_obj) },\n    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&str_index_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rindex), MP_ROM_PTR(&str_rindex_obj) },\n    { MP_ROM_QSTR(MP_QSTR_join), MP_ROM_PTR(&str_join_obj) },\n    { MP_ROM_QSTR(MP_QSTR_split), MP_ROM_PTR(&str_split_obj) },\n    #if MICROPY_PY_BUILTINS_STR_SPLITLINES\n    { MP_ROM_QSTR(MP_QSTR_splitlines), MP_ROM_PTR(&str_splitlines_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_rsplit), MP_ROM_PTR(&str_rsplit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_startswith), MP_ROM_PTR(&str_startswith_obj) },\n    { MP_ROM_QSTR(MP_QSTR_endswith), MP_ROM_PTR(&str_endswith_obj) },\n    { MP_ROM_QSTR(MP_QSTR_strip), MP_ROM_PTR(&str_strip_obj) },\n    { MP_ROM_QSTR(MP_QSTR_lstrip), MP_ROM_PTR(&str_lstrip_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rstrip), MP_ROM_PTR(&str_rstrip_obj) },\n    { MP_ROM_QSTR(MP_QSTR_format), MP_ROM_PTR(&str_format_obj) },\n    { MP_ROM_QSTR(MP_QSTR_replace), MP_ROM_PTR(&str_replace_obj) },\n    #if MICROPY_PY_BUILTINS_STR_COUNT\n    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&str_count_obj) },\n    #endif\n    #if MICROPY_PY_BUILTINS_STR_PARTITION\n    { MP_ROM_QSTR(MP_QSTR_partition), MP_ROM_PTR(&str_partition_obj) },\n    { MP_ROM_QSTR(MP_QSTR_rpartition), MP_ROM_PTR(&str_rpartition_obj) },\n    #endif\n    #if MICROPY_PY_BUILTINS_STR_CENTER\n    { MP_ROM_QSTR(MP_QSTR_center), MP_ROM_PTR(&str_center_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_lower), MP_ROM_PTR(&str_lower_obj) },\n    { MP_ROM_QSTR(MP_QSTR_upper), MP_ROM_PTR(&str_upper_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isspace), MP_ROM_PTR(&str_isspace_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isalpha), MP_ROM_PTR(&str_isalpha_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isdigit), MP_ROM_PTR(&str_isdigit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isupper), MP_ROM_PTR(&str_isupper_obj) },\n    { MP_ROM_QSTR(MP_QSTR_islower), MP_ROM_PTR(&str_islower_obj) },\n    #if MICROPY_CPYTHON_COMPAT\n    { MP_ROM_QSTR(MP_QSTR_encode), MP_ROM_PTR(&str_encode_obj) },\n    #endif\n};\n\n#if MICROPY_CPYTHON_COMPAT\n#define TABLE_ENTRIES_COMPAT 1\n#else\n#define TABLE_ENTRIES_COMPAT 0\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTES_HEX\n#define TABLE_ENTRIES_HEX 2\n#else\n#define TABLE_ENTRIES_HEX 0\n#endif\n\n#if MICROPY_PY_ARRAY || MICROPY_PY_BUILTINS_BYTEARRAY\n#define TABLE_ENTRIES_ARRAY 2\n#else\n#define TABLE_ENTRIES_ARRAY 0\n#endif\n\nMP_DEFINE_CONST_DICT_WITH_SIZE(mp_obj_str_locals_dict,\n    array_bytearray_str_bytes_locals_table + TABLE_ENTRIES_ARRAY + TABLE_ENTRIES_HEX + TABLE_ENTRIES_COMPAT,\n    MP_ARRAY_SIZE(array_bytearray_str_bytes_locals_table) - (TABLE_ENTRIES_ARRAY + TABLE_ENTRIES_HEX + TABLE_ENTRIES_COMPAT));\n\n#if TABLE_ENTRIES_COMPAT == 0\n#define mp_obj_bytes_locals_dict mp_obj_str_locals_dict\n#else\nMP_DEFINE_CONST_DICT_WITH_SIZE(mp_obj_bytes_locals_dict,\n    array_bytearray_str_bytes_locals_table + TABLE_ENTRIES_ARRAY,\n    MP_ARRAY_SIZE(array_bytearray_str_bytes_locals_table) - (TABLE_ENTRIES_ARRAY + TABLE_ENTRIES_COMPAT));\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY\nMP_DEFINE_CONST_DICT_WITH_SIZE(mp_obj_bytearray_locals_dict,\n    array_bytearray_str_bytes_locals_table,\n    MP_ARRAY_SIZE(array_bytearray_str_bytes_locals_table) - TABLE_ENTRIES_COMPAT);\n#endif\n\n#if MICROPY_PY_ARRAY\nMP_DEFINE_CONST_DICT_WITH_SIZE(mp_obj_array_locals_dict,\n    array_bytearray_str_bytes_locals_table,\n    TABLE_ENTRIES_ARRAY);\n#endif\n\n#if MICROPY_PY_BUILTINS_MEMORYVIEW && MICROPY_PY_BUILTINS_BYTES_HEX\nMP_DEFINE_CONST_DICT_WITH_SIZE(mp_obj_memoryview_locals_dict,\n    array_bytearray_str_bytes_locals_table + TABLE_ENTRIES_ARRAY,\n    1); \n#endif\n\n#if !MICROPY_PY_BUILTINS_STR_UNICODE\nstatic mp_obj_t mp_obj_new_str_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_str,\n    MP_QSTR_str,\n    MP_TYPE_FLAG_NONE,\n    make_new, mp_obj_str_make_new,\n    print, str_print,\n    binary_op, mp_obj_str_binary_op,\n    subscr, bytes_subscr,\n    iter, mp_obj_new_str_iterator,\n    buffer, mp_obj_str_get_buffer,\n    locals_dict, &mp_obj_str_locals_dict\n    );\n#endif \n\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bytes,\n    MP_QSTR_bytes,\n    MP_TYPE_FLAG_NONE,\n    make_new, bytes_make_new,\n    print, str_print,\n    binary_op, mp_obj_str_binary_op,\n    subscr, bytes_subscr,\n    iter, mp_obj_new_bytes_iterator,\n    buffer, mp_obj_str_get_buffer,\n    locals_dict, &mp_obj_bytes_locals_dict\n    );\n\n\nconst mp_obj_str_t mp_const_empty_bytes_obj = {{&mp_type_bytes}, 0, 0, (const byte *)\"\"};\n\n\n\n\nmp_obj_t mp_obj_new_str_copy(const mp_obj_type_t *type, const byte *data, size_t len) {\n    mp_obj_str_t *o = mp_obj_malloc(mp_obj_str_t, type);\n    o->len = len;\n    if (data) {\n        o->hash = qstr_compute_hash(data, len);\n        byte *p = m_new(byte, len + 1);\n        o->data = p;\n        memcpy(p, data, len * sizeof(byte));\n        p[len] = '\\0'; \n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\n\n\n\nmp_obj_t mp_obj_new_str_of_type(const mp_obj_type_t *type, const byte *data, size_t len) {\n    if (type == &mp_type_str) {\n        return mp_obj_new_str((const char *)data, len);\n    #if MICROPY_PY_BUILTINS_BYTEARRAY\n    } else if (type == &mp_type_bytearray) {\n        return mp_obj_new_bytearray(len, data);\n    #endif\n    } else {\n        return mp_obj_new_bytes(data, len);\n    }\n}\n\n\nmp_obj_t mp_obj_new_str_via_qstr(const char *data, size_t len) {\n    return MP_OBJ_NEW_QSTR(qstr_from_strn(data, len));\n}\n\n\n\n\nstatic mp_obj_t mp_obj_new_str_type_from_vstr(const mp_obj_type_t *type, vstr_t *vstr) {\n    \n    if (type == &mp_type_str) {\n        qstr q = qstr_find_strn(vstr->buf, vstr->len);\n        if (q != MP_QSTRnull) {\n            vstr_clear(vstr);\n            vstr->alloc = 0;\n            return MP_OBJ_NEW_QSTR(q);\n        }\n    }\n\n    byte *data;\n    if (vstr->len + 1 == vstr->alloc) {\n        data = (byte *)vstr->buf;\n    } else {\n        data = (byte *)m_renew(char, vstr->buf, vstr->alloc, vstr->len + 1);\n    }\n    data[vstr->len] = '\\0'; \n    vstr->buf = NULL;\n    vstr->alloc = 0;\n    #if MICROPY_PY_BUILTINS_BYTEARRAY\n    if (type == &mp_type_bytearray) {\n        return mp_obj_new_bytearray_by_ref(vstr->len, data);\n    }\n    #endif\n    mp_obj_str_t *o = mp_obj_malloc(mp_obj_str_t, type);\n    o->len = vstr->len;\n    o->hash = qstr_compute_hash(data, vstr->len);\n    o->data = data;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nmp_obj_t mp_obj_new_str_from_vstr(vstr_t *vstr) {\n    #if MICROPY_PY_BUILTINS_STR_UNICODE && MICROPY_PY_BUILTINS_STR_UNICODE_CHECK\n    if (!utf8_check((byte *)vstr->buf, vstr->len)) {\n        mp_raise_msg(&mp_type_UnicodeError, NULL);\n    }\n    #endif \n    return mp_obj_new_str_type_from_vstr(&mp_type_str, vstr);\n}\n\n#if MICROPY_PY_BUILTINS_STR_UNICODE && MICROPY_PY_BUILTINS_STR_UNICODE_CHECK\nmp_obj_t mp_obj_new_str_from_utf8_vstr(vstr_t *vstr) {\n    \n    return mp_obj_new_str_type_from_vstr(&mp_type_str, vstr);\n}\n#endif \n\nmp_obj_t mp_obj_new_bytes_from_vstr(vstr_t *vstr) {\n    return mp_obj_new_str_type_from_vstr(&mp_type_bytes, vstr);\n}\n\nmp_obj_t mp_obj_new_str(const char *data, size_t len) {\n    #if MICROPY_PY_BUILTINS_STR_UNICODE && MICROPY_PY_BUILTINS_STR_UNICODE_CHECK\n    if (!utf8_check((byte *)data, len)) {\n        mp_raise_msg(&mp_type_UnicodeError, NULL);\n    }\n    #endif\n    qstr q = qstr_find_strn(data, len);\n    if (q != MP_QSTRnull) {\n        \n        return MP_OBJ_NEW_QSTR(q);\n    } else {\n        \n        return mp_obj_new_str_copy(&mp_type_str, (const byte *)data, len);\n    }\n}\n\nmp_obj_t mp_obj_str_intern(mp_obj_t str) {\n    GET_STR_DATA_LEN(str, data, len);\n    return mp_obj_new_str_via_qstr((const char *)data, len);\n}\n\nmp_obj_t mp_obj_str_intern_checked(mp_obj_t obj) {\n    size_t len;\n    const char *data = mp_obj_str_get_data(obj, &len);\n    return mp_obj_new_str_via_qstr((const char *)data, len);\n}\n\nmp_obj_t mp_obj_new_bytes(const byte *data, size_t len) {\n    return mp_obj_new_str_copy(&mp_type_bytes, data, len);\n}\n\nbool mp_obj_str_equal(mp_obj_t s1, mp_obj_t s2) {\n    if (mp_obj_is_qstr(s1) && mp_obj_is_qstr(s2)) {\n        return s1 == s2;\n    } else {\n        GET_STR_HASH(s1, h1);\n        GET_STR_HASH(s2, h2);\n        \n        if (h1 != 0 && h2 != 0 && h1 != h2) {\n            return false;\n        }\n        GET_STR_DATA_LEN(s1, d1, l1);\n        GET_STR_DATA_LEN(s2, d2, l2);\n        if (l1 != l2) {\n            return false;\n        }\n        return memcmp(d1, d2, l1) == 0;\n    }\n}\n\nstatic NORETURN void bad_implicit_conversion(mp_obj_t self_in) {\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_TypeError(MP_ERROR_TEXT(\"can't convert to str implicitly\"));\n    #else\n    const qstr src_name = mp_obj_get_type(self_in)->name;\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"can't convert '%q' object to %q implicitly\"),\n        src_name, src_name == MP_QSTR_str ? MP_QSTR_bytes : MP_QSTR_str);\n    #endif\n}\n\n\n\nqstr mp_obj_str_get_qstr(mp_obj_t self_in) {\n    if (mp_obj_is_qstr(self_in)) {\n        return MP_OBJ_QSTR_VALUE(self_in);\n    } else if (mp_obj_is_exact_type(self_in, &mp_type_str)) {\n        mp_obj_str_t *self = MP_OBJ_TO_PTR(self_in);\n        return qstr_from_strn((char *)self->data, self->len);\n    } else {\n        bad_implicit_conversion(self_in);\n    }\n}\n\n\n\nconst char *mp_obj_str_get_str(mp_obj_t self_in) {\n    if (mp_obj_is_str_or_bytes(self_in)) {\n        GET_STR_DATA_LEN(self_in, s, l);\n        (void)l; \n        return (const char *)s;\n    } else {\n        bad_implicit_conversion(self_in);\n    }\n}\n\nconst char *mp_obj_str_get_data(mp_obj_t self_in, size_t *len) {\n    if (mp_obj_is_str_or_bytes(self_in)) {\n        GET_STR_DATA_LEN(self_in, s, l);\n        *len = l;\n        return (const char *)s;\n    } else {\n        bad_implicit_conversion(self_in);\n    }\n}\n\n#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C || MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\nconst byte *mp_obj_str_get_data_no_check(mp_obj_t self_in, size_t *len) {\n    if (mp_obj_is_qstr(self_in)) {\n        return qstr_data(MP_OBJ_QSTR_VALUE(self_in), len);\n    } else {\n        MP_STATIC_ASSERT_STR_ARRAY_COMPATIBLE;\n        *len = ((mp_obj_str_t *)MP_OBJ_TO_PTR(self_in))->len;\n        return ((mp_obj_str_t *)MP_OBJ_TO_PTR(self_in))->data;\n    }\n}\n#endif\n\n \n \n\ntypedef struct _mp_obj_str8_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_obj_t str;\n    size_t cur;\n} mp_obj_str8_it_t;\n\n#if !MICROPY_PY_BUILTINS_STR_UNICODE\nstatic mp_obj_t str_it_iternext(mp_obj_t self_in) {\n    mp_obj_str8_it_t *self = MP_OBJ_TO_PTR(self_in);\n    GET_STR_DATA_LEN(self->str, str, len);\n    if (self->cur < len) {\n        mp_obj_t o_out = mp_obj_new_str_via_qstr((const char *)str + self->cur, 1);\n        self->cur += 1;\n        return o_out;\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nstatic mp_obj_t mp_obj_new_str_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_str8_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_str8_it_t *o = (mp_obj_str8_it_t *)iter_buf;\n    o->base.type = &mp_type_polymorph_iter;\n    o->iternext = str_it_iternext;\n    o->str = str;\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n#endif\n\nstatic mp_obj_t bytes_it_iternext(mp_obj_t self_in) {\n    mp_obj_str8_it_t *self = MP_OBJ_TO_PTR(self_in);\n    GET_STR_DATA_LEN(self->str, str, len);\n    if (self->cur < len) {\n        mp_obj_t o_out = MP_OBJ_NEW_SMALL_INT(str[self->cur]);\n        self->cur += 1;\n        return o_out;\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nmp_obj_t mp_obj_new_bytes_iterator(mp_obj_t str, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_str8_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_str8_it_t *o = (mp_obj_str8_it_t *)iter_buf;\n    o->base.type = &mp_type_polymorph_iter;\n    o->iternext = bytes_it_iternext;\n    o->str = str;\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}