{
  "module_name": "objslice.c",
  "hash_id": "794f3e9241840fb847336e47159c62f5800db048e6b94f958075222e4528c055",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objslice.c",
  "human_readable_source": " \n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n\n \n \n\n#if MICROPY_PY_BUILTINS_SLICE\n\nstatic void slice_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_slice_t *o = MP_OBJ_TO_PTR(o_in);\n    mp_print_str(print, \"slice(\");\n    mp_obj_print_helper(print, o->start, PRINT_REPR);\n    mp_print_str(print, \", \");\n    mp_obj_print_helper(print, o->stop, PRINT_REPR);\n    mp_print_str(print, \", \");\n    mp_obj_print_helper(print, o->step, PRINT_REPR);\n    mp_print_str(print, \")\");\n}\n\nstatic mp_obj_t slice_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    \n    \n    return MP_OBJ_NULL;\n}\n\n#if MICROPY_PY_BUILTINS_SLICE_INDICES\nstatic mp_obj_t slice_indices(mp_obj_t self_in, mp_obj_t length_obj) {\n    mp_int_t length = mp_obj_get_int(length_obj);\n    mp_bound_slice_t bound_indices;\n    mp_obj_slice_indices(self_in, length, &bound_indices);\n\n    mp_obj_t results[3] = {\n        MP_OBJ_NEW_SMALL_INT(bound_indices.start),\n        MP_OBJ_NEW_SMALL_INT(bound_indices.stop),\n        MP_OBJ_NEW_SMALL_INT(bound_indices.step),\n    };\n    return mp_obj_new_tuple(3, results);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(slice_indices_obj, slice_indices);\n#endif\n\n#if MICROPY_PY_BUILTINS_SLICE_ATTRS\nstatic void slice_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        return;\n    }\n    mp_obj_slice_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (attr == MP_QSTR_start) {\n        dest[0] = self->start;\n    } else if (attr == MP_QSTR_stop) {\n        dest[0] = self->stop;\n    } else if (attr == MP_QSTR_step) {\n        dest[0] = self->step;\n    #if MICROPY_PY_BUILTINS_SLICE_INDICES\n    } else if (attr == MP_QSTR_indices) {\n        dest[0] = MP_OBJ_FROM_PTR(&slice_indices_obj);\n        dest[1] = self_in;\n    #endif\n    }\n}\n#endif\n\n#if MICROPY_PY_BUILTINS_SLICE_INDICES && !MICROPY_PY_BUILTINS_SLICE_ATTRS\nstatic const mp_rom_map_elem_t slice_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_indices), MP_ROM_PTR(&slice_indices_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(slice_locals_dict, slice_locals_dict_table);\n#endif\n\n#if MICROPY_PY_BUILTINS_SLICE_ATTRS\n#define SLICE_TYPE_ATTR_OR_LOCALS_DICT attr, slice_attr,\n#elif MICROPY_PY_BUILTINS_SLICE_INDICES\n#define SLICE_TYPE_ATTR_OR_LOCALS_DICT locals_dict, &slice_locals_dict,\n#else\n#define SLICE_TYPE_ATTR_OR_LOCALS_DICT\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_slice,\n    MP_QSTR_slice,\n    MP_TYPE_FLAG_NONE,\n    unary_op, slice_unary_op,\n    SLICE_TYPE_ATTR_OR_LOCALS_DICT\n    print, slice_print\n    );\n\nmp_obj_t mp_obj_new_slice(mp_obj_t ostart, mp_obj_t ostop, mp_obj_t ostep) {\n    mp_obj_slice_t *o = mp_obj_malloc(mp_obj_slice_t, &mp_type_slice);\n    o->start = ostart;\n    o->stop = ostop;\n    o->step = ostep;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n\n\n\nvoid mp_obj_slice_indices(mp_obj_t self_in, mp_int_t length, mp_bound_slice_t *result) {\n    mp_obj_slice_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_int_t start, stop, step;\n\n    if (self->step == mp_const_none) {\n        step = 1;\n    } else {\n        step = mp_obj_get_int(self->step);\n        if (step == 0) {\n            mp_raise_ValueError(MP_ERROR_TEXT(\"slice step can't be zero\"));\n        }\n    }\n\n    if (step > 0) {\n        \n        if (self->start == mp_const_none) {\n            start = 0;\n        } else {\n            start = mp_obj_get_int(self->start);\n            if (start < 0) {\n                start += length;\n            }\n            start = MIN(length, MAX(start, 0));\n        }\n\n        if (self->stop == mp_const_none) {\n            stop = length;\n        } else {\n            stop = mp_obj_get_int(self->stop);\n            if (stop < 0) {\n                stop += length;\n            }\n            stop = MIN(length, MAX(stop, 0));\n        }\n    } else {\n        \n        if (self->start == mp_const_none) {\n            start = length - 1;\n        } else {\n            start = mp_obj_get_int(self->start);\n            if (start < 0) {\n                start += length;\n            }\n            start = MIN(length - 1, MAX(start, -1));\n        }\n\n        if (self->stop == mp_const_none) {\n            stop = -1;\n        } else {\n            stop = mp_obj_get_int(self->stop);\n            if (stop < 0) {\n                stop += length;\n            }\n            stop = MIN(length - 1, MAX(stop, -1));\n        }\n    }\n\n    result->start = start;\n    result->stop = stop;\n    result->step = step;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}