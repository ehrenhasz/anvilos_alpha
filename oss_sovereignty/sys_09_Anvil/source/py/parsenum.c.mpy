{
  "module_name": "parsenum.c",
  "hash_id": "451b886b053db52e57d8ad20f6acf5d8b2255cdc53cf7d2215f1b7b39eeebc85",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/parsenum.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"py/runtime.h\"\n#include \"py/parsenumbase.h\"\n#include \"py/parsenum.h\"\n#include \"py/smallint.h\"\n\n#if MICROPY_PY_BUILTINS_FLOAT\n#include <math.h>\n#endif\n\nstatic NORETURN void raise_exc(mp_obj_t exc, mp_lexer_t *lex) {\n    \n    \n    if (lex != NULL) {\n        ((mp_obj_base_t *)MP_OBJ_TO_PTR(exc))->type = &mp_type_SyntaxError;\n        mp_obj_exception_add_traceback(exc, lex->source_name, lex->tok_line, MP_QSTRnull);\n    }\n    nlr_raise(exc);\n}\n\nmp_obj_t mp_parse_num_integer(const char *restrict str_, size_t len, int base, mp_lexer_t *lex) {\n    const byte *restrict str = (const byte *)str_;\n    const byte *restrict top = str + len;\n    bool neg = false;\n    mp_obj_t ret_val;\n\n    \n    if ((base != 0 && base < 2) || base > 36) {\n        \n        mp_raise_ValueError(MP_ERROR_TEXT(\"int() arg 2 must be >= 2 and <= 36\"));\n    }\n\n    \n    for (; str < top && unichar_isspace(*str); str++) {\n    }\n\n    \n    if (str < top) {\n        if (*str == '+') {\n            str++;\n        } else if (*str == '-') {\n            str++;\n            neg = true;\n        }\n    }\n\n    \n    str += mp_parse_num_base((const char *)str, top - str, &base);\n\n    \n    mp_int_t int_val = 0;\n    const byte *restrict str_val_start = str;\n    for (; str < top; str++) {\n        \n        mp_uint_t dig = *str;\n        if ('0' <= dig && dig <= '9') {\n            dig -= '0';\n        } else if (dig == '_') {\n            continue;\n        } else {\n            dig |= 0x20; \n            if ('a' <= dig && dig <= 'z') {\n                dig -= 'a' - 10;\n            } else {\n                \n                break;\n            }\n        }\n        if (dig >= (mp_uint_t)base) {\n            break;\n        }\n\n        \n        if (mp_small_int_mul_overflow(int_val, base)) {\n            goto overflow;\n        }\n        int_val = int_val * base + dig;\n        if (!MP_SMALL_INT_FITS(int_val)) {\n            goto overflow;\n        }\n    }\n\n    \n    if (neg) {\n        int_val = -int_val;\n    }\n\n    \n    ret_val = MP_OBJ_NEW_SMALL_INT(int_val);\n\nhave_ret_val:\n    \n    if (str == str_val_start) {\n        goto value_error;\n    }\n\n    \n    for (; str < top && unichar_isspace(*str); str++) {\n    }\n\n    \n    if (str != top) {\n        goto value_error;\n    }\n\n    \n    return ret_val;\n\noverflow:\n    \n    {\n        const char *s2 = (const char *)str_val_start;\n        ret_val = mp_obj_new_int_from_str_len(&s2, top - str_val_start, neg, base);\n        str = (const byte *)s2;\n        goto have_ret_val;\n    }\n\nvalue_error:\n    {\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_obj_t exc = mp_obj_new_exception_msg(&mp_type_ValueError,\n            MP_ERROR_TEXT(\"invalid syntax for integer\"));\n        raise_exc(exc, lex);\n        #elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL\n        mp_obj_t exc = mp_obj_new_exception_msg_varg(&mp_type_ValueError,\n            MP_ERROR_TEXT(\"invalid syntax for integer with base %d\"), base);\n        raise_exc(exc, lex);\n        #else\n        vstr_t vstr;\n        mp_print_t print;\n        vstr_init_print(&vstr, 50, &print);\n        mp_printf(&print, \"invalid syntax for integer with base %d: \", base);\n        mp_str_print_quoted(&print, str_val_start, top - str_val_start, true);\n        mp_obj_t exc = mp_obj_new_exception_arg1(&mp_type_ValueError,\n            mp_obj_new_str_from_utf8_vstr(&vstr));\n        raise_exc(exc, lex);\n        #endif\n    }\n}\n\nenum {\n    REAL_IMAG_STATE_START = 0,\n    REAL_IMAG_STATE_HAVE_REAL = 1,\n    REAL_IMAG_STATE_HAVE_IMAG = 2,\n};\n\ntypedef enum {\n    PARSE_DEC_IN_INTG,\n    PARSE_DEC_IN_FRAC,\n    PARSE_DEC_IN_EXP,\n} parse_dec_in_t;\n\n#if MICROPY_PY_BUILTINS_FLOAT\n\n\n\n\n\n\n#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n#define DEC_VAL_MAX 1e20F\n#define SMALL_NORMAL_VAL (1e-37F)\n#define SMALL_NORMAL_EXP (-37)\n#define EXACT_POWER_OF_10 (9)\n#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n#define DEC_VAL_MAX 1e200\n#define SMALL_NORMAL_VAL (1e-307)\n#define SMALL_NORMAL_EXP (-307)\n#define EXACT_POWER_OF_10 (22)\n#endif\n\n\nstatic void accept_digit(mp_float_t *p_dec_val, int dig, int *p_exp_extra, int in) {\n    \n    if (*p_dec_val < DEC_VAL_MAX) {\n        \n        *p_dec_val = 10 * *p_dec_val + dig;\n        if (in == PARSE_DEC_IN_FRAC) {\n            --(*p_exp_extra);\n        }\n    } else {\n        \n        \n        if (in == PARSE_DEC_IN_INTG) {\n            ++(*p_exp_extra);\n        }\n    }\n}\n#endif \n\n#if MICROPY_PY_BUILTINS_COMPLEX\nmp_obj_t mp_parse_num_decimal(const char *str, size_t len, bool allow_imag, bool force_complex, mp_lexer_t *lex)\n#else\nmp_obj_t mp_parse_num_float(const char *str, size_t len, bool allow_imag, mp_lexer_t *lex)\n#endif\n{\n    #if MICROPY_PY_BUILTINS_FLOAT\n\n    const char *top = str + len;\n    mp_float_t dec_val = 0;\n    bool dec_neg = false;\n\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    unsigned int real_imag_state = REAL_IMAG_STATE_START;\n    mp_float_t dec_real = 0;\nparse_start:\n    #endif\n\n    \n    for (; str < top && unichar_isspace(*str); str++) {\n    }\n\n    \n    if (str < top) {\n        if (*str == '+') {\n            str++;\n        } else if (*str == '-') {\n            str++;\n            dec_neg = true;\n        }\n    }\n\n    const char *str_val_start = str;\n\n    \n    if (str < top && (str[0] | 0x20) == 'i') {\n        \n        if (str + 2 < top && (str[1] | 0x20) == 'n' && (str[2] | 0x20) == 'f') {\n            \n            str += 3;\n            dec_val = (mp_float_t)INFINITY;\n            if (str + 4 < top && (str[0] | 0x20) == 'i' && (str[1] | 0x20) == 'n' && (str[2] | 0x20) == 'i' && (str[3] | 0x20) == 't' && (str[4] | 0x20) == 'y') {\n                \n                str += 5;\n            }\n        }\n    } else if (str < top && (str[0] | 0x20) == 'n') {\n        \n        if (str + 2 < top && (str[1] | 0x20) == 'a' && (str[2] | 0x20) == 'n') {\n            \n            str += 3;\n            dec_val = MICROPY_FLOAT_C_FUN(nan)(\"\");\n        }\n    } else {\n        \n        parse_dec_in_t in = PARSE_DEC_IN_INTG;\n        bool exp_neg = false;\n        int exp_val = 0;\n        int exp_extra = 0;\n        int trailing_zeros_intg = 0, trailing_zeros_frac = 0;\n        while (str < top) {\n            unsigned int dig = *str++;\n            if ('0' <= dig && dig <= '9') {\n                dig -= '0';\n                if (in == PARSE_DEC_IN_EXP) {\n                    \n                    \n                    \n                    if (exp_val < (INT_MAX / 2 - 9) / 10) {\n                        exp_val = 10 * exp_val + dig;\n                    }\n                } else {\n                    if (dig == 0 || dec_val >= DEC_VAL_MAX) {\n                        \n                        \n                        if (in == PARSE_DEC_IN_INTG) {\n                            ++trailing_zeros_intg;\n                        } else {\n                            ++trailing_zeros_frac;\n                        }\n                    } else {\n                        \n                        while (trailing_zeros_intg) {\n                            accept_digit(&dec_val, 0, &exp_extra, PARSE_DEC_IN_INTG);\n                            --trailing_zeros_intg;\n                        }\n                        while (trailing_zeros_frac) {\n                            accept_digit(&dec_val, 0, &exp_extra, PARSE_DEC_IN_FRAC);\n                            --trailing_zeros_frac;\n                        }\n                        accept_digit(&dec_val, dig, &exp_extra, in);\n                    }\n                }\n            } else if (in == PARSE_DEC_IN_INTG && dig == '.') {\n                in = PARSE_DEC_IN_FRAC;\n            } else if (in != PARSE_DEC_IN_EXP && ((dig | 0x20) == 'e')) {\n                in = PARSE_DEC_IN_EXP;\n                if (str < top) {\n                    if (str[0] == '+') {\n                        str++;\n                    } else if (str[0] == '-') {\n                        str++;\n                        exp_neg = true;\n                    }\n                }\n                if (str == top) {\n                    goto value_error;\n                }\n            } else if (dig == '_') {\n                continue;\n            } else {\n                \n                str--;\n                break;\n            }\n        }\n\n        \n        if (exp_neg) {\n            exp_val = -exp_val;\n        }\n\n        \n        exp_val += exp_extra + trailing_zeros_intg;\n        if (exp_val < SMALL_NORMAL_EXP) {\n            exp_val -= SMALL_NORMAL_EXP;\n            dec_val *= SMALL_NORMAL_VAL;\n        }\n\n        \n        \n        \n        \n        \n        if (exp_val < 0 && exp_val >= -EXACT_POWER_OF_10) {\n            dec_val /= MICROPY_FLOAT_C_FUN(pow)(10, -exp_val);\n        } else {\n            dec_val *= MICROPY_FLOAT_C_FUN(pow)(10, exp_val);\n        }\n    }\n\n    if (allow_imag && str < top && (*str | 0x20) == 'j') {\n        #if MICROPY_PY_BUILTINS_COMPLEX\n        if (str == str_val_start) {\n            \n            dec_val = 1;\n        }\n        ++str;\n        real_imag_state |= REAL_IMAG_STATE_HAVE_IMAG;\n        #else\n        raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, MP_ERROR_TEXT(\"complex values not supported\")), lex);\n        #endif\n    }\n\n    \n    if (dec_neg) {\n        dec_val = -dec_val;\n    }\n\n    \n    if (str == str_val_start) {\n        goto value_error;\n    }\n\n    \n    for (; str < top && unichar_isspace(*str); str++) {\n    }\n\n    \n    if (str != top) {\n        #if MICROPY_PY_BUILTINS_COMPLEX\n        if (force_complex && real_imag_state == REAL_IMAG_STATE_START) {\n            \n            dec_real = dec_val;\n            dec_val = 0;\n            real_imag_state |= REAL_IMAG_STATE_HAVE_REAL;\n            goto parse_start;\n        }\n        #endif\n        goto value_error;\n    }\n\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    if (real_imag_state == REAL_IMAG_STATE_HAVE_REAL) {\n        \n        goto value_error;\n    }\n    #endif\n\n    \n\n    #if MICROPY_PY_BUILTINS_COMPLEX\n    if (real_imag_state != REAL_IMAG_STATE_START) {\n        return mp_obj_new_complex(dec_real, dec_val);\n    } else if (force_complex) {\n        return mp_obj_new_complex(dec_val, 0);\n    }\n    #endif\n\n    return mp_obj_new_float(dec_val);\n\nvalue_error:\n    raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, MP_ERROR_TEXT(\"invalid syntax for number\")), lex);\n\n    #else\n    raise_exc(mp_obj_new_exception_msg(&mp_type_ValueError, MP_ERROR_TEXT(\"decimal numbers not supported\")), lex);\n    #endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}