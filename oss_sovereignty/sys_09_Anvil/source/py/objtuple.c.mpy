{
  "module_name": "objtuple.c",
  "hash_id": "62371f4ef88e71ee2a341f2150b077219b7a5d4f622401a10f57d70958430a84",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objtuple.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/objtuple.h\"\n#include \"py/runtime.h\"\n\n\n#define mp_obj_is_tuple_compatible(o) (MP_OBJ_TYPE_GET_SLOT_OR_NULL(mp_obj_get_type(o), iter) == mp_obj_tuple_getiter)\n\n \n \n\nvoid mp_obj_tuple_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    mp_obj_tuple_t *o = MP_OBJ_TO_PTR(o_in);\n    const char *item_separator = \", \";\n    if (MICROPY_PY_JSON && kind == PRINT_JSON) {\n        mp_print_str(print, \"[\");\n        #if MICROPY_PY_JSON_SEPARATORS\n        item_separator = MP_PRINT_GET_EXT(print)->item_separator;\n        #endif\n    } else {\n        mp_print_str(print, \"(\");\n        kind = PRINT_REPR;\n    }\n    for (size_t i = 0; i < o->len; i++) {\n        if (i > 0) {\n            mp_print_str(print, item_separator);\n        }\n        mp_obj_print_helper(print, o->items[i], kind);\n    }\n    if (MICROPY_PY_JSON && kind == PRINT_JSON) {\n        mp_print_str(print, \"]\");\n    } else {\n        if (o->len == 1) {\n            mp_print_str(print, \",\");\n        }\n        mp_print_str(print, \")\");\n    }\n}\n\nstatic mp_obj_t mp_obj_tuple_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n\n    switch (n_args) {\n        case 0:\n            \n            return mp_const_empty_tuple;\n\n        case 1:\n        default: {\n            \n            if (mp_obj_is_type(args[0], &mp_type_tuple)) {\n                return args[0];\n            }\n\n            \n\n            size_t alloc = 4;\n            size_t len = 0;\n            mp_obj_t *items = m_new(mp_obj_t, alloc);\n\n            mp_obj_t iterable = mp_getiter(args[0], NULL);\n            mp_obj_t item;\n            while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n                if (len >= alloc) {\n                    items = m_renew(mp_obj_t, items, alloc, alloc * 2);\n                    alloc *= 2;\n                }\n                items[len++] = item;\n            }\n\n            mp_obj_t tuple = mp_obj_new_tuple(len, items);\n            m_del(mp_obj_t, items, alloc);\n\n            return tuple;\n        }\n    }\n}\n\n\nstatic mp_obj_t tuple_cmp_helper(mp_uint_t op, mp_obj_t self_in, mp_obj_t another_in) {\n    mp_check_self(mp_obj_is_tuple_compatible(self_in));\n    const mp_obj_type_t *another_type = mp_obj_get_type(another_in);\n    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);\n    if (MP_OBJ_TYPE_GET_SLOT_OR_NULL(another_type, iter) != mp_obj_tuple_getiter) {\n        \n        another_in = mp_obj_cast_to_native_base(another_in, MP_OBJ_FROM_PTR(&mp_type_tuple));\n        if (another_in == MP_OBJ_NULL) {\n            return MP_OBJ_NULL;\n        }\n    }\n    mp_obj_tuple_t *another = MP_OBJ_TO_PTR(another_in);\n\n    return mp_obj_new_bool(mp_seq_cmp_objs(op, self->items, self->len, another->items, another->len));\n}\n\nmp_obj_t mp_obj_tuple_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(self->len != 0);\n        case MP_UNARY_OP_HASH: {\n            \n            mp_int_t hash = (mp_int_t)mp_const_empty_tuple;\n            for (size_t i = 0; i < self->len; i++) {\n                hash += MP_OBJ_SMALL_INT_VALUE(mp_unary_op(MP_UNARY_OP_HASH, self->items[i]));\n            }\n            return MP_OBJ_NEW_SMALL_INT(hash);\n        }\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(self->len);\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nmp_obj_t mp_obj_tuple_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs) {\n    mp_obj_tuple_t *o = MP_OBJ_TO_PTR(lhs);\n    switch (op) {\n        case MP_BINARY_OP_ADD:\n        case MP_BINARY_OP_INPLACE_ADD: {\n            if (!mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(rhs)), MP_OBJ_FROM_PTR(&mp_type_tuple))) {\n                return MP_OBJ_NULL; \n            }\n            mp_obj_tuple_t *p = MP_OBJ_TO_PTR(rhs);\n            mp_obj_tuple_t *s = MP_OBJ_TO_PTR(mp_obj_new_tuple(o->len + p->len, NULL));\n            mp_seq_cat(s->items, o->items, o->len, p->items, p->len, mp_obj_t);\n            return MP_OBJ_FROM_PTR(s);\n        }\n        case MP_BINARY_OP_MULTIPLY:\n        case MP_BINARY_OP_INPLACE_MULTIPLY: {\n            mp_int_t n;\n            if (!mp_obj_get_int_maybe(rhs, &n)) {\n                return MP_OBJ_NULL; \n            }\n            if (n <= 0) {\n                return mp_const_empty_tuple;\n            }\n            mp_obj_tuple_t *s = MP_OBJ_TO_PTR(mp_obj_new_tuple(o->len * n, NULL));\n            mp_seq_multiply(o->items, sizeof(*o->items), o->len, n, s->items);\n            return MP_OBJ_FROM_PTR(s);\n        }\n        case MP_BINARY_OP_EQUAL:\n        case MP_BINARY_OP_LESS:\n        case MP_BINARY_OP_LESS_EQUAL:\n        case MP_BINARY_OP_MORE:\n        case MP_BINARY_OP_MORE_EQUAL:\n            return tuple_cmp_helper(op, lhs, rhs);\n\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\nmp_obj_t mp_obj_tuple_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    if (value == MP_OBJ_SENTINEL) {\n        \n        mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);\n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index, &mp_type_slice)) {\n            mp_bound_slice_t slice;\n            if (!mp_seq_get_fast_slice_indexes(self->len, index, &slice)) {\n                mp_raise_NotImplementedError(MP_ERROR_TEXT(\"only slices with step=1 (aka None) are supported\"));\n            }\n            mp_obj_tuple_t *res = MP_OBJ_TO_PTR(mp_obj_new_tuple(slice.stop - slice.start, NULL));\n            mp_seq_copy(res->items, self->items + slice.start, res->len, mp_obj_t);\n            return MP_OBJ_FROM_PTR(res);\n        }\n        #endif\n        size_t index_value = mp_get_index(self->base.type, self->len, index, false);\n        return self->items[index_value];\n    } else {\n        return MP_OBJ_NULL; \n    }\n}\n\nstatic mp_obj_t tuple_count(mp_obj_t self_in, mp_obj_t value) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_tuple));\n    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_seq_count_obj(self->items, self->len, value);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(tuple_count_obj, tuple_count);\n\nstatic mp_obj_t tuple_index(size_t n_args, const mp_obj_t *args) {\n    mp_check_self(mp_obj_is_type(args[0], &mp_type_tuple));\n    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(args[0]);\n    return mp_seq_index_obj(self->items, self->len, n_args, args);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(tuple_index_obj, 2, 4, tuple_index);\n\nstatic const mp_rom_map_elem_t tuple_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&tuple_count_obj) },\n    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&tuple_index_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(tuple_locals_dict, tuple_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_tuple,\n    MP_QSTR_tuple,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, mp_obj_tuple_make_new,\n    print, mp_obj_tuple_print,\n    unary_op, mp_obj_tuple_unary_op,\n    binary_op, mp_obj_tuple_binary_op,\n    subscr, mp_obj_tuple_subscr,\n    iter, mp_obj_tuple_getiter,\n    locals_dict, &tuple_locals_dict\n    );\n\n\nconst mp_obj_tuple_t mp_const_empty_tuple_obj = {{&mp_type_tuple}, 0};\n\nmp_obj_t mp_obj_new_tuple(size_t n, const mp_obj_t *items) {\n    if (n == 0) {\n        return mp_const_empty_tuple;\n    }\n    mp_obj_tuple_t *o = mp_obj_malloc_var(mp_obj_tuple_t, items, mp_obj_t, n, &mp_type_tuple);\n    o->len = n;\n    if (items) {\n        for (size_t i = 0; i < n; i++) {\n            o->items[i] = items[i];\n        }\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\nvoid mp_obj_tuple_get(mp_obj_t self_in, size_t *len, mp_obj_t **items) {\n    assert(mp_obj_is_tuple_compatible(self_in));\n    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);\n    *len = self->len;\n    *items = &self->items[0];\n}\n\nvoid mp_obj_tuple_del(mp_obj_t self_in) {\n    assert(mp_obj_is_type(self_in, &mp_type_tuple));\n    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);\n    m_del_var(mp_obj_tuple_t, items, mp_obj_t, self->len, self);\n}\n\n \n \n\ntypedef struct _mp_obj_tuple_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_obj_tuple_t *tuple;\n    size_t cur;\n} mp_obj_tuple_it_t;\n\nstatic mp_obj_t tuple_it_iternext(mp_obj_t self_in) {\n    mp_obj_tuple_it_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->cur < self->tuple->len) {\n        mp_obj_t o_out = self->tuple->items[self->cur];\n        self->cur += 1;\n        return o_out;\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nmp_obj_t mp_obj_tuple_getiter(mp_obj_t o_in, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_tuple_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_tuple_it_t *o = (mp_obj_tuple_it_t *)iter_buf;\n    o->base.type = &mp_type_polymorph_iter;\n    o->iternext = tuple_it_iternext;\n    o->tuple = MP_OBJ_TO_PTR(o_in);\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}