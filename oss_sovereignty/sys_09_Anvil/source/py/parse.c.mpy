{
  "module_name": "parse.c",
  "hash_id": "b719d41b9972bd3c049766055d94dee321feb6d531fad7cbafc576593a15066c",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/parse.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <unistd.h> \n#include <assert.h>\n#include <string.h>\n\n#include \"py/lexer.h\"\n#include \"py/parse.h\"\n#include \"py/parsenum.h\"\n#include \"py/runtime.h\"\n#include \"py/objint.h\"\n#include \"py/objstr.h\"\n#include \"py/builtin.h\"\n\n#if MICROPY_ENABLE_COMPILER\n\n#define RULE_ACT_ARG_MASK       (0x0f)\n#define RULE_ACT_KIND_MASK      (0x30)\n#define RULE_ACT_ALLOW_IDENT    (0x40)\n#define RULE_ACT_ADD_BLANK      (0x80)\n#define RULE_ACT_OR             (0x10)\n#define RULE_ACT_AND            (0x20)\n#define RULE_ACT_LIST           (0x30)\n\n#define RULE_ARG_KIND_MASK      (0xf000)\n#define RULE_ARG_ARG_MASK       (0x0fff)\n#define RULE_ARG_TOK            (0x1000)\n#define RULE_ARG_RULE           (0x2000)\n#define RULE_ARG_OPT_RULE       (0x3000)\n\n\n\nenum {\n\n#define DEF_RULE(rule, comp, kind, ...) RULE_##rule,\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n    RULE_const_object, \n\n\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) RULE_##rule,\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n};\n\n\nstatic const uint8_t rule_act_table[] = {\n#define or(n)                   (RULE_ACT_OR | n)\n#define and(n)                  (RULE_ACT_AND | n)\n#define and_ident(n)            (RULE_ACT_AND | n | RULE_ACT_ALLOW_IDENT)\n#define and_blank(n)            (RULE_ACT_AND | n | RULE_ACT_ADD_BLANK)\n#define one_or_more             (RULE_ACT_LIST | 2)\n#define list                    (RULE_ACT_LIST | 1)\n#define list_with_end           (RULE_ACT_LIST | 3)\n\n#define DEF_RULE(rule, comp, kind, ...) kind,\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n\n    0, \n\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) kind,\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n\n#undef or\n#undef and\n#undef and_ident\n#undef and_blank\n#undef one_or_more\n#undef list\n#undef list_with_end\n};\n\n\nstatic const uint16_t rule_arg_combined_table[] = {\n#define tok(t)                  (RULE_ARG_TOK | MP_TOKEN_##t)\n#define rule(r)                 (RULE_ARG_RULE | RULE_##r)\n#define opt_rule(r)             (RULE_ARG_OPT_RULE | RULE_##r)\n\n#define DEF_RULE(rule, comp, kind, ...) __VA_ARGS__,\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...)  __VA_ARGS__,\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n\n#undef tok\n#undef rule\n#undef opt_rule\n};\n\n\n#define RULE_EXPAND(x) x\n#define RULE_PADDING(rule, ...) RULE_PADDING2(rule, __VA_ARGS__, RULE_PADDING_IDS(rule))\n#define RULE_PADDING2(rule, ...) RULE_EXPAND(RULE_PADDING3(rule, __VA_ARGS__))\n#define RULE_PADDING3(rule, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...) __VA_ARGS__\n#define RULE_PADDING_IDS(r) PAD13_##r, PAD12_##r, PAD11_##r, PAD10_##r, PAD9_##r, PAD8_##r, PAD7_##r, PAD6_##r, PAD5_##r, PAD4_##r, PAD3_##r, PAD2_##r, PAD1_##r,\n\n\nenum {\n#define DEF_RULE(rule, comp, kind, ...) RULE_PADDING(rule, __VA_ARGS__)\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) RULE_PADDING(rule, __VA_ARGS__)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n};\n\n\n#define RULE_ARG_OFFSET(rule, ...) RULE_ARG_OFFSET2(rule, __VA_ARGS__, RULE_ARG_OFFSET_IDS(rule))\n#define RULE_ARG_OFFSET2(rule, ...) RULE_EXPAND(RULE_ARG_OFFSET3(rule, __VA_ARGS__))\n#define RULE_ARG_OFFSET3(rule, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...) _14\n#define RULE_ARG_OFFSET_IDS(r) PAD13_##r, PAD12_##r, PAD11_##r, PAD10_##r, PAD9_##r, PAD8_##r, PAD7_##r, PAD6_##r, PAD5_##r, PAD4_##r, PAD3_##r, PAD2_##r, PAD1_##r, PAD0_##r,\n\n\n\n\n\nstatic const uint8_t rule_arg_offset_table[] = {\n#define DEF_RULE(rule, comp, kind, ...) RULE_ARG_OFFSET(rule, __VA_ARGS__) & 0xff,\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n    0, \n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) RULE_ARG_OFFSET(rule, __VA_ARGS__) & 0xff,\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n};\n\n\nstatic const size_t FIRST_RULE_WITH_OFFSET_ABOVE_255 =\n#define DEF_RULE(rule, comp, kind, ...) RULE_ARG_OFFSET(rule, __VA_ARGS__) >= 0x100 ? RULE_##rule :\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) RULE_ARG_OFFSET(rule, __VA_ARGS__) >= 0x100 ? RULE_##rule :\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n0;\n\n#if MICROPY_DEBUG_PARSE_RULE_NAME\n\nstatic const char *const rule_name_table[] = {\n#define DEF_RULE(rule, comp, kind, ...) #rule,\n#define DEF_RULE_NC(rule, kind, ...)\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n    \"\", \n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) #rule,\n#include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n};\n#endif\n\n\n\ntypedef struct _rule_stack_t {\n    size_t src_line : (8 * sizeof(size_t) - 8); \n    size_t rule_id : 8; \n    size_t arg_i; \n} rule_stack_t;\n\ntypedef struct _mp_parse_chunk_t {\n    size_t alloc;\n    union {\n        size_t used;\n        struct _mp_parse_chunk_t *next;\n    } union_;\n    byte data[];\n} mp_parse_chunk_t;\n\ntypedef struct _parser_t {\n    size_t rule_stack_alloc;\n    size_t rule_stack_top;\n    rule_stack_t *rule_stack;\n\n    size_t result_stack_alloc;\n    size_t result_stack_top;\n    mp_parse_node_t *result_stack;\n\n    mp_lexer_t *lexer;\n\n    mp_parse_tree_t tree;\n    mp_parse_chunk_t *cur_chunk;\n\n    #if MICROPY_COMP_CONST\n    mp_map_t consts;\n    #endif\n} parser_t;\n\nstatic void push_result_rule(parser_t *parser, size_t src_line, uint8_t rule_id, size_t num_args);\n\nstatic const uint16_t *get_rule_arg(uint8_t r_id) {\n    size_t off = rule_arg_offset_table[r_id];\n    if (r_id >= FIRST_RULE_WITH_OFFSET_ABOVE_255) {\n        off |= 0x100;\n    }\n    return &rule_arg_combined_table[off];\n}\n\nstatic void *parser_alloc(parser_t *parser, size_t num_bytes) {\n    \n\n    mp_parse_chunk_t *chunk = parser->cur_chunk;\n\n    if (chunk != NULL && chunk->union_.used + num_bytes > chunk->alloc) {\n        \n        mp_parse_chunk_t *new_data = (mp_parse_chunk_t *)m_renew_maybe(byte, chunk,\n            sizeof(mp_parse_chunk_t) + chunk->alloc,\n            sizeof(mp_parse_chunk_t) + chunk->alloc + num_bytes, false);\n        if (new_data == NULL) {\n            \n            (void)m_renew_maybe(byte, chunk, sizeof(mp_parse_chunk_t) + chunk->alloc,\n                sizeof(mp_parse_chunk_t) + chunk->union_.used, false);\n            chunk->alloc = chunk->union_.used;\n            chunk->union_.next = parser->tree.chunk;\n            parser->tree.chunk = chunk;\n            chunk = NULL;\n        } else {\n            \n            chunk->alloc += num_bytes;\n        }\n    }\n\n    if (chunk == NULL) {\n        \n        size_t alloc = MICROPY_ALLOC_PARSE_CHUNK_INIT;\n        if (alloc < num_bytes) {\n            alloc = num_bytes;\n        }\n        chunk = (mp_parse_chunk_t *)m_new(byte, sizeof(mp_parse_chunk_t) + alloc);\n        chunk->alloc = alloc;\n        chunk->union_.used = 0;\n        parser->cur_chunk = chunk;\n    }\n\n    byte *ret = chunk->data + chunk->union_.used;\n    chunk->union_.used += num_bytes;\n    return ret;\n}\n\n#if MICROPY_COMP_CONST_TUPLE\nstatic void parser_free_parse_node_struct(parser_t *parser, mp_parse_node_struct_t *pns) {\n    mp_parse_chunk_t *chunk = parser->cur_chunk;\n    if (chunk->data <= (byte *)pns && (byte *)pns < chunk->data + chunk->union_.used) {\n        size_t num_bytes = sizeof(mp_parse_node_struct_t) + sizeof(mp_parse_node_t) * MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n        chunk->union_.used -= num_bytes;\n    }\n}\n#endif\n\nstatic void push_rule(parser_t *parser, size_t src_line, uint8_t rule_id, size_t arg_i) {\n    if (parser->rule_stack_top >= parser->rule_stack_alloc) {\n        rule_stack_t *rs = m_renew(rule_stack_t, parser->rule_stack, parser->rule_stack_alloc, parser->rule_stack_alloc + MICROPY_ALLOC_PARSE_RULE_INC);\n        parser->rule_stack = rs;\n        parser->rule_stack_alloc += MICROPY_ALLOC_PARSE_RULE_INC;\n    }\n    rule_stack_t *rs = &parser->rule_stack[parser->rule_stack_top++];\n    rs->src_line = src_line;\n    rs->rule_id = rule_id;\n    rs->arg_i = arg_i;\n}\n\nstatic void push_rule_from_arg(parser_t *parser, size_t arg) {\n    assert((arg & RULE_ARG_KIND_MASK) == RULE_ARG_RULE || (arg & RULE_ARG_KIND_MASK) == RULE_ARG_OPT_RULE);\n    size_t rule_id = arg & RULE_ARG_ARG_MASK;\n    push_rule(parser, parser->lexer->tok_line, rule_id, 0);\n}\n\nstatic uint8_t pop_rule(parser_t *parser, size_t *arg_i, size_t *src_line) {\n    parser->rule_stack_top -= 1;\n    uint8_t rule_id = parser->rule_stack[parser->rule_stack_top].rule_id;\n    *arg_i = parser->rule_stack[parser->rule_stack_top].arg_i;\n    *src_line = parser->rule_stack[parser->rule_stack_top].src_line;\n    return rule_id;\n}\n\n#if MICROPY_COMP_CONST_TUPLE\nstatic uint8_t peek_rule(parser_t *parser, size_t n) {\n    assert(parser->rule_stack_top > n);\n    return parser->rule_stack[parser->rule_stack_top - 1 - n].rule_id;\n}\n#endif\n\nbool mp_parse_node_get_int_maybe(mp_parse_node_t pn, mp_obj_t *o) {\n    if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {\n        *o = MP_OBJ_NEW_SMALL_INT(MP_PARSE_NODE_LEAF_SMALL_INT(pn));\n        return true;\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_const_object)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        *o = mp_parse_node_extract_const_object(pns);\n        return mp_obj_is_int(*o);\n    } else {\n        return false;\n    }\n}\n\n#if MICROPY_COMP_CONST_TUPLE || MICROPY_COMP_CONST\nstatic bool mp_parse_node_is_const(mp_parse_node_t pn) {\n    if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {\n        \n        return true;\n    } else if (MP_PARSE_NODE_IS_LEAF(pn)) {\n        \n        uintptr_t kind = MP_PARSE_NODE_LEAF_KIND(pn);\n        if (kind == MP_PARSE_NODE_STRING) {\n            return true;\n        } else if (kind == MP_PARSE_NODE_TOKEN) {\n            uintptr_t arg = MP_PARSE_NODE_LEAF_ARG(pn);\n            return arg == MP_TOKEN_KW_NONE\n                   || arg == MP_TOKEN_KW_FALSE\n                   || arg == MP_TOKEN_KW_TRUE\n                   || arg == MP_TOKEN_ELLIPSIS;\n        }\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_const_object)) {\n        \n        return true;\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_atom_paren)) {\n        \n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        return MP_PARSE_NODE_IS_NULL(pns->nodes[0]);\n    }\n    return false;\n}\n\nstatic mp_obj_t mp_parse_node_convert_to_obj(mp_parse_node_t pn) {\n    assert(mp_parse_node_is_const(pn));\n    if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {\n        mp_int_t arg = MP_PARSE_NODE_LEAF_SMALL_INT(pn);\n        #if MICROPY_DYNAMIC_COMPILER\n        mp_uint_t sign_mask = -((mp_uint_t)1 << (mp_dynamic_compiler.small_int_bits - 1));\n        if (!((arg & sign_mask) == 0 || (arg & sign_mask) == sign_mask)) {\n            \n            return mp_obj_new_int_from_ll(arg);\n        }\n        #endif\n        return MP_OBJ_NEW_SMALL_INT(arg);\n    } else if (MP_PARSE_NODE_IS_LEAF(pn)) {\n        uintptr_t kind = MP_PARSE_NODE_LEAF_KIND(pn);\n        uintptr_t arg = MP_PARSE_NODE_LEAF_ARG(pn);\n        if (kind == MP_PARSE_NODE_STRING) {\n            return MP_OBJ_NEW_QSTR(arg);\n        } else {\n            assert(MP_PARSE_NODE_LEAF_KIND(pn) == MP_PARSE_NODE_TOKEN);\n            switch (arg) {\n                case MP_TOKEN_KW_NONE:\n                    return mp_const_none;\n                case MP_TOKEN_KW_FALSE:\n                    return mp_const_false;\n                case MP_TOKEN_KW_TRUE:\n                    return mp_const_true;\n                default:\n                    assert(arg == MP_TOKEN_ELLIPSIS);\n                    return MP_OBJ_FROM_PTR(&mp_const_ellipsis_obj);\n            }\n        }\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_const_object)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        return mp_parse_node_extract_const_object(pns);\n    } else {\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_atom_paren));\n        assert(MP_PARSE_NODE_IS_NULL(((mp_parse_node_struct_t *)pn)->nodes[0]));\n        return mp_const_empty_tuple;\n    }\n}\n#endif\n\nstatic bool parse_node_is_const_bool(mp_parse_node_t pn, bool value) {\n    \n    #if MICROPY_COMP_CONST_TUPLE || MICROPY_COMP_CONST\n    return mp_parse_node_is_const(pn) && mp_obj_is_true(mp_parse_node_convert_to_obj(pn)) == value;\n    #else\n    return MP_PARSE_NODE_IS_TOKEN_KIND(pn, value ? MP_TOKEN_KW_TRUE : MP_TOKEN_KW_FALSE)\n           || (MP_PARSE_NODE_IS_SMALL_INT(pn) && !!MP_PARSE_NODE_LEAF_SMALL_INT(pn) == value);\n    #endif\n}\n\nbool mp_parse_node_is_const_false(mp_parse_node_t pn) {\n    return parse_node_is_const_bool(pn, false);\n}\n\nbool mp_parse_node_is_const_true(mp_parse_node_t pn) {\n    return parse_node_is_const_bool(pn, true);\n}\n\nsize_t mp_parse_node_extract_list(mp_parse_node_t *pn, size_t pn_kind, mp_parse_node_t **nodes) {\n    if (MP_PARSE_NODE_IS_NULL(*pn)) {\n        *nodes = NULL;\n        return 0;\n    } else if (MP_PARSE_NODE_IS_LEAF(*pn)) {\n        *nodes = pn;\n        return 1;\n    } else {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)(*pn);\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) != pn_kind) {\n            *nodes = pn;\n            return 1;\n        } else {\n            *nodes = pns->nodes;\n            return MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n        }\n    }\n}\n\n#if MICROPY_DEBUG_PRINTERS\nvoid mp_parse_node_print(const mp_print_t *print, mp_parse_node_t pn, size_t indent) {\n    if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n        mp_printf(print, \"[% 4d] \", (int)((mp_parse_node_struct_t *)pn)->source_line);\n    } else {\n        mp_printf(print, \"       \");\n    }\n    for (size_t i = 0; i < indent; i++) {\n        mp_printf(print, \" \");\n    }\n    if (MP_PARSE_NODE_IS_NULL(pn)) {\n        mp_printf(print, \"NULL\\n\");\n    } else if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {\n        mp_int_t arg = MP_PARSE_NODE_LEAF_SMALL_INT(pn);\n        mp_printf(print, \"int(\" INT_FMT \")\\n\", arg);\n    } else if (MP_PARSE_NODE_IS_LEAF(pn)) {\n        uintptr_t arg = MP_PARSE_NODE_LEAF_ARG(pn);\n        switch (MP_PARSE_NODE_LEAF_KIND(pn)) {\n            case MP_PARSE_NODE_ID:\n                mp_printf(print, \"id(%s)\\n\", qstr_str(arg));\n                break;\n            case MP_PARSE_NODE_STRING:\n                mp_printf(print, \"str(%s)\\n\", qstr_str(arg));\n                break;\n            default:\n                assert(MP_PARSE_NODE_LEAF_KIND(pn) == MP_PARSE_NODE_TOKEN);\n                mp_printf(print, \"tok(%u)\\n\", (uint)arg);\n                break;\n        }\n    } else {\n        \n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_const_object) {\n            mp_obj_t obj = mp_parse_node_extract_const_object(pns);\n            #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\n            mp_printf(print, \"literal const(%016llx)=\", obj);\n            #else\n            mp_printf(print, \"literal const(%p)=\", obj);\n            #endif\n            mp_obj_print_helper(print, obj, PRINT_REPR);\n            mp_printf(print, \"\\n\");\n        } else {\n            size_t n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n            #if MICROPY_DEBUG_PARSE_RULE_NAME\n            mp_printf(print, \"%s(%u) (n=%u)\\n\", rule_name_table[MP_PARSE_NODE_STRUCT_KIND(pns)], (uint)MP_PARSE_NODE_STRUCT_KIND(pns), (uint)n);\n            #else\n            mp_printf(print, \"rule(%u) (n=%u)\\n\", (uint)MP_PARSE_NODE_STRUCT_KIND(pns), (uint)n);\n            #endif\n            for (size_t i = 0; i < n; i++) {\n                mp_parse_node_print(print, pns->nodes[i], indent + 2);\n            }\n        }\n    }\n}\n#endif \n\n \n\nstatic mp_parse_node_t pop_result(parser_t *parser) {\n    assert(parser->result_stack_top > 0);\n    return parser->result_stack[--parser->result_stack_top];\n}\n\nstatic mp_parse_node_t peek_result(parser_t *parser, size_t pos) {\n    assert(parser->result_stack_top > pos);\n    return parser->result_stack[parser->result_stack_top - 1 - pos];\n}\n\nstatic void push_result_node(parser_t *parser, mp_parse_node_t pn) {\n    if (parser->result_stack_top >= parser->result_stack_alloc) {\n        mp_parse_node_t *stack = m_renew(mp_parse_node_t, parser->result_stack, parser->result_stack_alloc, parser->result_stack_alloc + MICROPY_ALLOC_PARSE_RESULT_INC);\n        parser->result_stack = stack;\n        parser->result_stack_alloc += MICROPY_ALLOC_PARSE_RESULT_INC;\n    }\n    parser->result_stack[parser->result_stack_top++] = pn;\n}\n\nstatic mp_parse_node_t make_node_const_object(parser_t *parser, size_t src_line, mp_obj_t obj) {\n    mp_parse_node_struct_t *pn = parser_alloc(parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_obj_t));\n    pn->source_line = src_line;\n    #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\n    \n    pn->kind_num_nodes = RULE_const_object | (2 << 8);\n    pn->nodes[0] = (uint64_t)obj;\n    pn->nodes[1] = (uint64_t)obj >> 32;\n    #else\n    pn->kind_num_nodes = RULE_const_object | (1 << 8);\n    pn->nodes[0] = (uintptr_t)obj;\n    #endif\n    return (mp_parse_node_t)pn;\n}\n\n\n\nstatic mp_parse_node_t make_node_const_object_optimised(parser_t *parser, size_t src_line, mp_obj_t obj) {\n    if (mp_obj_is_small_int(obj)) {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(obj);\n        #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D\n        \n        if (((val ^ (val << 1)) & 0xffffffff80000000) != 0) {\n            return make_node_const_object(parser, src_line, obj);\n        }\n        #endif\n        #if MICROPY_DYNAMIC_COMPILER\n        \n        mp_uint_t sign_mask = -((mp_uint_t)1 << (mp_dynamic_compiler.small_int_bits - 1));\n        if (!((val & sign_mask) == 0 || (val & sign_mask) == sign_mask)) {\n            return make_node_const_object(parser, src_line, obj);\n        }\n        #endif\n        return mp_parse_node_new_small_int(val);\n    } else {\n        return make_node_const_object(parser, src_line, obj);\n    }\n}\n\nstatic void push_result_token(parser_t *parser, uint8_t rule_id) {\n    mp_parse_node_t pn;\n    mp_lexer_t *lex = parser->lexer;\n    if (lex->tok_kind == MP_TOKEN_NAME) {\n        qstr id = qstr_from_strn(lex->vstr.buf, lex->vstr.len);\n        #if MICROPY_COMP_CONST\n        \n        mp_map_elem_t *elem;\n        if (rule_id == RULE_atom\n            && (elem = mp_map_lookup(&parser->consts, MP_OBJ_NEW_QSTR(id), MP_MAP_LOOKUP)) != NULL) {\n            pn = make_node_const_object_optimised(parser, lex->tok_line, elem->value);\n        } else {\n            pn = mp_parse_node_new_leaf(MP_PARSE_NODE_ID, id);\n        }\n        #else\n        (void)rule_id;\n        pn = mp_parse_node_new_leaf(MP_PARSE_NODE_ID, id);\n        #endif\n    } else if (lex->tok_kind == MP_TOKEN_INTEGER) {\n        mp_obj_t o = mp_parse_num_integer(lex->vstr.buf, lex->vstr.len, 0, lex);\n        pn = make_node_const_object_optimised(parser, lex->tok_line, o);\n    } else if (lex->tok_kind == MP_TOKEN_FLOAT_OR_IMAG) {\n        mp_obj_t o = mp_parse_num_float(lex->vstr.buf, lex->vstr.len, true, lex);\n        pn = make_node_const_object(parser, lex->tok_line, o);\n    } else if (lex->tok_kind == MP_TOKEN_STRING) {\n        \n        \n        qstr qst = MP_QSTRnull;\n        if (lex->vstr.len <= MICROPY_ALLOC_PARSE_INTERN_STRING_LEN) {\n            \n            qst = qstr_from_strn(lex->vstr.buf, lex->vstr.len);\n        } else {\n            \n            qst = qstr_find_strn(lex->vstr.buf, lex->vstr.len);\n        }\n        if (qst != MP_QSTRnull) {\n            \n            pn = mp_parse_node_new_leaf(MP_PARSE_NODE_STRING, qst);\n        } else {\n            \n            mp_obj_t o = mp_obj_new_str_copy(&mp_type_str, (const byte *)lex->vstr.buf, lex->vstr.len);\n            pn = make_node_const_object(parser, lex->tok_line, o);\n        }\n    } else if (lex->tok_kind == MP_TOKEN_BYTES) {\n        \n        mp_obj_t o = mp_obj_new_bytes((const byte *)lex->vstr.buf, lex->vstr.len);\n        pn = make_node_const_object(parser, lex->tok_line, o);\n    } else {\n        pn = mp_parse_node_new_leaf(MP_PARSE_NODE_TOKEN, lex->tok_kind);\n    }\n    push_result_node(parser, pn);\n}\n\n#if MICROPY_COMP_CONST_FOLDING\n\n#if MICROPY_COMP_MODULE_CONST\nstatic const mp_rom_map_elem_t mp_constants_table[] = {\n    #if MICROPY_PY_ERRNO\n    { MP_ROM_QSTR(MP_QSTR_errno), MP_ROM_PTR(&mp_module_errno) },\n    #endif\n    #if MICROPY_PY_UCTYPES\n    { MP_ROM_QSTR(MP_QSTR_uctypes), MP_ROM_PTR(&mp_module_uctypes) },\n    #endif\n    \n    MICROPY_PORT_CONSTANTS\n};\nstatic MP_DEFINE_CONST_MAP(mp_constants_map, mp_constants_table);\n#endif\n\n#if MICROPY_COMP_CONST_FOLDING_COMPILER_WORKAROUND\n\n\nMP_NOINLINE\n#endif\nstatic bool fold_logical_constants(parser_t *parser, uint8_t rule_id, size_t *num_args) {\n    if (rule_id == RULE_or_test\n        || rule_id == RULE_and_test) {\n        \n        size_t copy_to = *num_args;\n        for (size_t i = copy_to; i > 0;) {\n            mp_parse_node_t pn = peek_result(parser, --i);\n            parser->result_stack[parser->result_stack_top - copy_to] = pn;\n            if (i == 0) {\n                \n                break;\n            }\n            if (rule_id == RULE_or_test) {\n                if (mp_parse_node_is_const_true(pn)) {\n                    \n                    break;\n                } else if (!mp_parse_node_is_const_false(pn)) {\n                    copy_to -= 1;\n                }\n            } else {\n                \n                if (mp_parse_node_is_const_false(pn)) {\n                    break;\n                } else if (!mp_parse_node_is_const_true(pn)) {\n                    copy_to -= 1;\n                }\n            }\n        }\n        copy_to -= 1; \n\n        \n        for (size_t i = 0; i < copy_to; ++i) {\n            pop_result(parser);\n        }\n        *num_args -= copy_to;\n\n        \n        return *num_args == 1;\n\n    } else if (rule_id == RULE_not_test_2) {\n        \n        mp_parse_node_t pn = peek_result(parser, 0);\n        if (mp_parse_node_is_const_false(pn)) {\n            pn = mp_parse_node_new_leaf(MP_PARSE_NODE_TOKEN, MP_TOKEN_KW_TRUE);\n        } else if (mp_parse_node_is_const_true(pn)) {\n            pn = mp_parse_node_new_leaf(MP_PARSE_NODE_TOKEN, MP_TOKEN_KW_FALSE);\n        } else {\n            return false;\n        }\n        pop_result(parser);\n        push_result_node(parser, pn);\n        return true;\n    }\n\n    return false;\n}\n\nstatic bool fold_constants(parser_t *parser, uint8_t rule_id, size_t num_args) {\n    \n    \n\n    mp_obj_t arg0;\n    if (rule_id == RULE_expr\n        || rule_id == RULE_xor_expr\n        || rule_id == RULE_and_expr\n        || rule_id == RULE_power) {\n        \n        mp_parse_node_t pn = peek_result(parser, num_args - 1);\n        if (!mp_parse_node_get_int_maybe(pn, &arg0)) {\n            return false;\n        }\n        mp_binary_op_t op;\n        if (rule_id == RULE_expr) {\n            op = MP_BINARY_OP_OR;\n        } else if (rule_id == RULE_xor_expr) {\n            op = MP_BINARY_OP_XOR;\n        } else if (rule_id == RULE_and_expr) {\n            op = MP_BINARY_OP_AND;\n        } else {\n            op = MP_BINARY_OP_POWER;\n        }\n        for (ssize_t i = num_args - 2; i >= 0; --i) {\n            pn = peek_result(parser, i);\n            mp_obj_t arg1;\n            if (!mp_parse_node_get_int_maybe(pn, &arg1)) {\n                return false;\n            }\n            if (op == MP_BINARY_OP_POWER && mp_obj_int_sign(arg1) < 0) {\n                \n                return false;\n            }\n            arg0 = mp_binary_op(op, arg0, arg1);\n        }\n    } else if (rule_id == RULE_shift_expr\n               || rule_id == RULE_arith_expr\n               || rule_id == RULE_term) {\n        \n        mp_parse_node_t pn = peek_result(parser, num_args - 1);\n        if (!mp_parse_node_get_int_maybe(pn, &arg0)) {\n            return false;\n        }\n        for (ssize_t i = num_args - 2; i >= 1; i -= 2) {\n            pn = peek_result(parser, i - 1);\n            mp_obj_t arg1;\n            if (!mp_parse_node_get_int_maybe(pn, &arg1)) {\n                return false;\n            }\n            mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(peek_result(parser, i));\n            if (tok == MP_TOKEN_OP_AT || tok == MP_TOKEN_OP_SLASH) {\n                \n                return false;\n            }\n            mp_binary_op_t op = MP_BINARY_OP_LSHIFT + (tok - MP_TOKEN_OP_DBL_LESS);\n            int rhs_sign = mp_obj_int_sign(arg1);\n            if (op <= MP_BINARY_OP_RSHIFT) {\n                \n                if (rhs_sign < 0) {\n                    return false;\n                }\n            } else if (op >= MP_BINARY_OP_FLOOR_DIVIDE) {\n                \n                if (rhs_sign == 0) {\n                    return false;\n                }\n            }\n            arg0 = mp_binary_op(op, arg0, arg1);\n        }\n    } else if (rule_id == RULE_factor_2) {\n        \n        mp_parse_node_t pn = peek_result(parser, 0);\n        if (!mp_parse_node_get_int_maybe(pn, &arg0)) {\n            return false;\n        }\n        mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(peek_result(parser, 1));\n        mp_unary_op_t op;\n        if (tok == MP_TOKEN_OP_TILDE) {\n            op = MP_UNARY_OP_INVERT;\n        } else {\n            assert(tok == MP_TOKEN_OP_PLUS || tok == MP_TOKEN_OP_MINUS); \n            op = MP_UNARY_OP_POSITIVE + (tok - MP_TOKEN_OP_PLUS);\n        }\n        arg0 = mp_unary_op(op, arg0);\n\n    #if MICROPY_COMP_CONST\n    } else if (rule_id == RULE_expr_stmt) {\n        mp_parse_node_t pn1 = peek_result(parser, 0);\n        if (!MP_PARSE_NODE_IS_NULL(pn1)\n            && !(MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_expr_stmt_augassign)\n                 || MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_expr_stmt_assign_list))) {\n            \n            mp_parse_node_t pn0 = peek_result(parser, 1);\n            if (MP_PARSE_NODE_IS_ID(pn0)\n                && MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_atom_expr_normal)\n                && MP_PARSE_NODE_IS_ID(((mp_parse_node_struct_t *)pn1)->nodes[0])\n                && MP_PARSE_NODE_LEAF_ARG(((mp_parse_node_struct_t *)pn1)->nodes[0]) == MP_QSTR_const\n                && MP_PARSE_NODE_IS_STRUCT_KIND(((mp_parse_node_struct_t *)pn1)->nodes[1], RULE_trailer_paren)\n                ) {\n                \n\n                \n                qstr id = MP_PARSE_NODE_LEAF_ARG(pn0);\n\n                \n                mp_parse_node_t pn_value = ((mp_parse_node_struct_t *)((mp_parse_node_struct_t *)pn1)->nodes[1])->nodes[0];\n                if (!mp_parse_node_is_const(pn_value)) {\n                    mp_obj_t exc = mp_obj_new_exception_msg(&mp_type_SyntaxError,\n                        MP_ERROR_TEXT(\"not a constant\"));\n                    mp_obj_exception_add_traceback(exc, parser->lexer->source_name,\n                        ((mp_parse_node_struct_t *)pn1)->source_line, MP_QSTRnull);\n                    nlr_raise(exc);\n                }\n                mp_obj_t value = mp_parse_node_convert_to_obj(pn_value);\n\n                \n                mp_map_elem_t *elem = mp_map_lookup(&parser->consts, MP_OBJ_NEW_QSTR(id), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n                assert(elem->value == MP_OBJ_NULL);\n                elem->value = value;\n\n                \n                \n                if (qstr_str(id)[0] == '_') {\n                    pop_result(parser); \n                    pop_result(parser); \n                    push_result_rule(parser, 0, RULE_pass_stmt, 0); \n                    return true;\n                }\n\n                \n                pop_result(parser);\n                push_result_node(parser, pn_value);\n\n                \n                return false;\n            }\n        }\n        return false;\n    #endif\n\n    #if MICROPY_COMP_MODULE_CONST\n    } else if (rule_id == RULE_atom_expr_normal) {\n        mp_parse_node_t pn0 = peek_result(parser, 1);\n        mp_parse_node_t pn1 = peek_result(parser, 0);\n        if (!(MP_PARSE_NODE_IS_ID(pn0)\n              && MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_trailer_period))) {\n            return false;\n        }\n        \n        \n        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t *)pn1;\n        assert(MP_PARSE_NODE_IS_ID(pns1->nodes[0]));\n        qstr q_base = MP_PARSE_NODE_LEAF_ARG(pn0);\n        qstr q_attr = MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]);\n        mp_map_elem_t *elem = mp_map_lookup((mp_map_t *)&mp_constants_map, MP_OBJ_NEW_QSTR(q_base), MP_MAP_LOOKUP);\n        if (elem == NULL) {\n            return false;\n        }\n        mp_obj_t dest[2];\n        mp_load_method_maybe(elem->value, q_attr, dest);\n        if (!(dest[0] != MP_OBJ_NULL && mp_obj_is_int(dest[0]) && dest[1] == MP_OBJ_NULL)) {\n            return false;\n        }\n        arg0 = dest[0];\n    #endif\n\n    } else {\n        return false;\n    }\n\n    \n\n    for (size_t i = num_args; i > 0; i--) {\n        pop_result(parser);\n    }\n    push_result_node(parser, make_node_const_object_optimised(parser, 0, arg0));\n\n    return true;\n}\n\n#endif \n\n#if MICROPY_COMP_CONST_TUPLE\nstatic bool build_tuple_from_stack(parser_t *parser, size_t src_line, size_t num_args) {\n    for (size_t i = num_args; i > 0;) {\n        mp_parse_node_t pn = peek_result(parser, --i);\n        if (!mp_parse_node_is_const(pn)) {\n            return false;\n        }\n    }\n    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(mp_obj_new_tuple(num_args, NULL));\n    for (size_t i = num_args; i > 0;) {\n        mp_parse_node_t pn = pop_result(parser);\n        tuple->items[--i] = mp_parse_node_convert_to_obj(pn);\n        if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n            parser_free_parse_node_struct(parser, (mp_parse_node_struct_t *)pn);\n        }\n    }\n    push_result_node(parser, make_node_const_object(parser, src_line, MP_OBJ_FROM_PTR(tuple)));\n    return true;\n}\n\nstatic bool build_tuple(parser_t *parser, size_t src_line, uint8_t rule_id, size_t num_args) {\n    if (rule_id == RULE_testlist_comp) {\n        if (peek_rule(parser, 0) == RULE_atom_paren) {\n            \n            return build_tuple_from_stack(parser, src_line, num_args);\n        }\n    }\n    if (rule_id == RULE_testlist_comp_3c) {\n        assert(peek_rule(parser, 0) == RULE_testlist_comp_3b);\n        assert(peek_rule(parser, 1) == RULE_testlist_comp);\n        if (peek_rule(parser, 2) == RULE_atom_paren) {\n            \n            if (build_tuple_from_stack(parser, src_line, num_args)) {\n                parser->rule_stack_top -= 2; \n                return true;\n            }\n        }\n    }\n    if (rule_id == RULE_testlist_star_expr\n        || rule_id == RULE_testlist\n        || rule_id == RULE_subscriptlist) {\n        \n        \n        \n        \n        \n        return build_tuple_from_stack(parser, src_line, num_args);\n    }\n\n    return false;\n}\n#endif\n\nstatic void push_result_rule(parser_t *parser, size_t src_line, uint8_t rule_id, size_t num_args) {\n    \n    if (rule_id == RULE_atom_paren) {\n        \n        \n        \n        mp_parse_node_t pn = peek_result(parser, 0);\n        if (MP_PARSE_NODE_IS_NULL(pn)) {\n            \n        } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_testlist_comp)) {\n            \n        } else {\n            \n            return;\n        }\n    } else if (rule_id == RULE_testlist_comp) {\n        \n        \n        assert(num_args == 2);\n        mp_parse_node_t pn = peek_result(parser, 0);\n        if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n            if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_testlist_comp_3b) {\n                \n                pop_result(parser);\n                --num_args;\n            } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_testlist_comp_3c) {\n                \n                pop_result(parser);\n                assert(pn == peek_result(parser, 0));\n                pns->kind_num_nodes = rule_id | MP_PARSE_NODE_STRUCT_NUM_NODES(pns) << 8;\n                return;\n            } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_comp_for) {\n                \n            } else {\n                \n            }\n        } else {\n            \n        }\n    } else if (rule_id == RULE_testlist_comp_3c) {\n        \n        ++num_args;\n    }\n\n    #if MICROPY_COMP_CONST_FOLDING\n    if (fold_logical_constants(parser, rule_id, &num_args)) {\n        \n        return;\n    }\n    if (fold_constants(parser, rule_id, num_args)) {\n        \n        return;\n    }\n    #endif\n\n    #if MICROPY_COMP_CONST_TUPLE\n    if (build_tuple(parser, src_line, rule_id, num_args)) {\n        \n        return;\n    }\n    #endif\n\n    mp_parse_node_struct_t *pn = parser_alloc(parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_parse_node_t) * num_args);\n    pn->source_line = src_line;\n    pn->kind_num_nodes = (rule_id & 0xff) | (num_args << 8);\n    for (size_t i = num_args; i > 0; i--) {\n        pn->nodes[i - 1] = pop_result(parser);\n    }\n    if (rule_id == RULE_testlist_comp_3c) {\n        \n        push_result_node(parser, (mp_parse_node_t)pn);\n    }\n    push_result_node(parser, (mp_parse_node_t)pn);\n}\n\nmp_parse_tree_t mp_parse(mp_lexer_t *lex, mp_parse_input_kind_t input_kind) {\n    \n    MP_DEFINE_NLR_JUMP_CALLBACK_FUNCTION_1(ctx, mp_lexer_free, lex);\n    nlr_push_jump_callback(&ctx.callback, mp_call_function_1_from_nlr_jump_callback);\n\n    \n\n    parser_t parser;\n\n    parser.rule_stack_alloc = MICROPY_ALLOC_PARSE_RULE_INIT;\n    parser.rule_stack_top = 0;\n    parser.rule_stack = m_new(rule_stack_t, parser.rule_stack_alloc);\n\n    parser.result_stack_alloc = MICROPY_ALLOC_PARSE_RESULT_INIT;\n    parser.result_stack_top = 0;\n    parser.result_stack = m_new(mp_parse_node_t, parser.result_stack_alloc);\n\n    parser.lexer = lex;\n\n    parser.tree.chunk = NULL;\n    parser.cur_chunk = NULL;\n\n    #if MICROPY_COMP_CONST\n    mp_map_init(&parser.consts, 0);\n    #endif\n\n    \n    size_t top_level_rule;\n    switch (input_kind) {\n        case MP_PARSE_SINGLE_INPUT:\n            top_level_rule = RULE_single_input;\n            break;\n        case MP_PARSE_EVAL_INPUT:\n            top_level_rule = RULE_eval_input;\n            break;\n        default:\n            top_level_rule = RULE_file_input;\n    }\n    push_rule(&parser, lex->tok_line, top_level_rule, 0);\n\n    \n\n    bool backtrack = false;\n\n    for (;;) {\n    next_rule:\n        if (parser.rule_stack_top == 0) {\n            break;\n        }\n\n        \n        size_t i; \n        size_t rule_src_line; \n        uint8_t rule_id = pop_rule(&parser, &i, &rule_src_line);\n        uint8_t rule_act = rule_act_table[rule_id];\n        const uint16_t *rule_arg = get_rule_arg(rule_id);\n        size_t n = rule_act & RULE_ACT_ARG_MASK;\n\n        #if 0\n        \n        printf(\"depth=\" UINT_FMT \" \", parser.rule_stack_top);\n        for (int j = 0; j < parser.rule_stack_top; ++j) {\n            printf(\" \");\n        }\n        printf(\"%s n=\" UINT_FMT \" i=\" UINT_FMT \" bt=%d\\n\", rule_name_table[rule_id], n, i, backtrack);\n        #endif\n\n        switch (rule_act & RULE_ACT_KIND_MASK) {\n            case RULE_ACT_OR:\n                if (i > 0 && !backtrack) {\n                    goto next_rule;\n                } else {\n                    backtrack = false;\n                }\n                for (; i < n; ++i) {\n                    uint16_t kind = rule_arg[i] & RULE_ARG_KIND_MASK;\n                    if (kind == RULE_ARG_TOK) {\n                        if (lex->tok_kind == (rule_arg[i] & RULE_ARG_ARG_MASK)) {\n                            push_result_token(&parser, rule_id);\n                            mp_lexer_to_next(lex);\n                            goto next_rule;\n                        }\n                    } else {\n                        assert(kind == RULE_ARG_RULE);\n                        if (i + 1 < n) {\n                            push_rule(&parser, rule_src_line, rule_id, i + 1); \n                        }\n                        push_rule_from_arg(&parser, rule_arg[i]); \n                        goto next_rule;\n                    }\n                }\n                backtrack = true;\n                break;\n\n            case RULE_ACT_AND: {\n\n                \n                if (backtrack) {\n                    assert(i > 0);\n                    if ((rule_arg[i - 1] & RULE_ARG_KIND_MASK) == RULE_ARG_OPT_RULE) {\n                        \n                        push_result_node(&parser, MP_PARSE_NODE_NULL);\n                        backtrack = false;\n                    } else {\n                        \n                        if (i > 1) {\n                            \n                            goto syntax_error;\n                        } else {\n                            goto next_rule;\n                        }\n                    }\n                }\n\n                \n                for (; i < n; ++i) {\n                    if ((rule_arg[i] & RULE_ARG_KIND_MASK) == RULE_ARG_TOK) {\n                        \n                        mp_token_kind_t tok_kind = rule_arg[i] & RULE_ARG_ARG_MASK;\n                        if (lex->tok_kind == tok_kind) {\n                            \n                            if (tok_kind == MP_TOKEN_NAME) {\n                                push_result_token(&parser, rule_id);\n                            }\n                            mp_lexer_to_next(lex);\n                        } else {\n                            \n                            if (i > 0) {\n                                \n                                goto syntax_error;\n                            } else {\n                                \n                                backtrack = true;\n                                goto next_rule;\n                            }\n                        }\n                    } else {\n                        push_rule(&parser, rule_src_line, rule_id, i + 1); \n                        push_rule_from_arg(&parser, rule_arg[i]); \n                        goto next_rule;\n                    }\n                }\n\n                assert(i == n);\n\n                \n\n                #if !MICROPY_ENABLE_DOC_STRING\n                \n                if (input_kind != MP_PARSE_SINGLE_INPUT && rule_id == RULE_expr_stmt && peek_result(&parser, 0) == MP_PARSE_NODE_NULL) {\n                    mp_parse_node_t p = peek_result(&parser, 1);\n                    if ((MP_PARSE_NODE_IS_LEAF(p) && !MP_PARSE_NODE_IS_ID(p))\n                        || MP_PARSE_NODE_IS_STRUCT_KIND(p, RULE_const_object)) {\n                        pop_result(&parser); \n                        pop_result(&parser); \n                        \n                        \n                        \n                        push_result_rule(&parser, rule_src_line, RULE_pass_stmt, 0);\n                        break;\n                    }\n                }\n                #endif\n\n                \n                i = 0;\n                size_t num_not_nil = 0;\n                for (size_t x = n; x > 0;) {\n                    --x;\n                    if ((rule_arg[x] & RULE_ARG_KIND_MASK) == RULE_ARG_TOK) {\n                        mp_token_kind_t tok_kind = rule_arg[x] & RULE_ARG_ARG_MASK;\n                        if (tok_kind == MP_TOKEN_NAME) {\n                            \n                            i += 1;\n                            num_not_nil += 1;\n                        }\n                    } else {\n                        \n                        if (peek_result(&parser, i) != MP_PARSE_NODE_NULL) {\n                            num_not_nil += 1;\n                        }\n                        i += 1;\n                    }\n                }\n\n                if (num_not_nil == 1 && (rule_act & RULE_ACT_ALLOW_IDENT)) {\n                    \n                    mp_parse_node_t pn = MP_PARSE_NODE_NULL;\n                    for (size_t x = 0; x < i; ++x) {\n                        mp_parse_node_t pn2 = pop_result(&parser);\n                        if (pn2 != MP_PARSE_NODE_NULL) {\n                            pn = pn2;\n                        }\n                    }\n                    push_result_node(&parser, pn);\n                } else {\n                    \n\n                    if (rule_act & RULE_ACT_ADD_BLANK) {\n                        \n                        push_result_node(&parser, MP_PARSE_NODE_NULL);\n                        i += 1;\n                    }\n\n                    push_result_rule(&parser, rule_src_line, rule_id, i);\n                }\n                break;\n            }\n\n            default: {\n                assert((rule_act & RULE_ACT_KIND_MASK) == RULE_ACT_LIST);\n\n                \n                \n                \n                bool had_trailing_sep;\n                if (backtrack) {\n                list_backtrack:\n                    had_trailing_sep = false;\n                    if (n == 2) {\n                        if (i == 1) {\n                            \n                            goto next_rule;\n                        } else {\n                            \n                            backtrack = false;\n                        }\n                    } else {\n                        if (i == 1) {\n                            \n                            goto next_rule;\n                        } else if ((i & 1) == 1) {\n                            \n                            if (n == 3) {\n                                \n                                had_trailing_sep = true;\n                                backtrack = false;\n                            } else {\n                                \n                                goto syntax_error;\n                            }\n                        } else {\n                            \n                            backtrack = false;\n                        }\n                    }\n                } else {\n                    for (;;) {\n                        size_t arg = rule_arg[i & 1 & n];\n                        if ((arg & RULE_ARG_KIND_MASK) == RULE_ARG_TOK) {\n                            if (lex->tok_kind == (arg & RULE_ARG_ARG_MASK)) {\n                                if (i & 1 & n) {\n                                    \n                                } else {\n                                    push_result_token(&parser, rule_id);\n                                }\n                                mp_lexer_to_next(lex);\n                                \n                                i += 1;\n                            } else {\n                                \n                                i += 1;\n                                backtrack = true;\n                                goto list_backtrack;\n                            }\n                        } else {\n                            assert((arg & RULE_ARG_KIND_MASK) == RULE_ARG_RULE);\n                            push_rule(&parser, rule_src_line, rule_id, i + 1); \n                            push_rule_from_arg(&parser, arg); \n                            goto next_rule;\n                        }\n                    }\n                }\n                assert(i >= 1);\n\n                \n                i -= 1;\n                if ((n & 1) && (rule_arg[1] & RULE_ARG_KIND_MASK) == RULE_ARG_TOK) {\n                    \n                    i = (i + 1) / 2;\n                }\n\n                if (i == 1) {\n                    \n                    if (had_trailing_sep) {\n                        \n                        push_result_rule(&parser, rule_src_line, rule_id, i);\n                    } else {\n                        \n                    }\n                } else {\n                    push_result_rule(&parser, rule_src_line, rule_id, i);\n                }\n                break;\n            }\n        }\n    }\n\n    #if MICROPY_COMP_CONST\n    mp_map_deinit(&parser.consts);\n    #endif\n\n    \n    if (parser.cur_chunk != NULL) {\n        (void)m_renew_maybe(byte, parser.cur_chunk,\n            sizeof(mp_parse_chunk_t) + parser.cur_chunk->alloc,\n            sizeof(mp_parse_chunk_t) + parser.cur_chunk->union_.used,\n            false);\n        parser.cur_chunk->alloc = parser.cur_chunk->union_.used;\n        parser.cur_chunk->union_.next = parser.tree.chunk;\n        parser.tree.chunk = parser.cur_chunk;\n    }\n\n    if (\n        lex->tok_kind != MP_TOKEN_END \n        || parser.result_stack_top == 0 \n        ) {\n    syntax_error:;\n        mp_obj_t exc;\n        if (lex->tok_kind == MP_TOKEN_INDENT) {\n            exc = mp_obj_new_exception_msg(&mp_type_IndentationError,\n                MP_ERROR_TEXT(\"unexpected indent\"));\n        } else if (lex->tok_kind == MP_TOKEN_DEDENT_MISMATCH) {\n            exc = mp_obj_new_exception_msg(&mp_type_IndentationError,\n                MP_ERROR_TEXT(\"unindent doesn't match any outer indent level\"));\n        #if MICROPY_PY_FSTRINGS\n        } else if (lex->tok_kind == MP_TOKEN_MALFORMED_FSTRING) {\n            exc = mp_obj_new_exception_msg(&mp_type_SyntaxError,\n                MP_ERROR_TEXT(\"malformed f-string\"));\n        } else if (lex->tok_kind == MP_TOKEN_FSTRING_RAW) {\n            exc = mp_obj_new_exception_msg(&mp_type_SyntaxError,\n                MP_ERROR_TEXT(\"raw f-strings are not supported\"));\n        #endif\n        } else {\n            exc = mp_obj_new_exception_msg(&mp_type_SyntaxError,\n                MP_ERROR_TEXT(\"invalid syntax\"));\n        }\n        \n        \n        mp_obj_exception_add_traceback(exc, lex->source_name, lex->tok_line, MP_QSTRnull);\n        nlr_raise(exc);\n    }\n\n    \n    assert(parser.result_stack_top == 1);\n    parser.tree.root = parser.result_stack[0];\n\n    \n    m_del(rule_stack_t, parser.rule_stack, parser.rule_stack_alloc);\n    m_del(mp_parse_node_t, parser.result_stack, parser.result_stack_alloc);\n\n    \n    nlr_pop_jump_callback(true);\n\n    return parser.tree;\n}\n\nvoid mp_parse_tree_clear(mp_parse_tree_t *tree) {\n    mp_parse_chunk_t *chunk = tree->chunk;\n    while (chunk != NULL) {\n        mp_parse_chunk_t *next = chunk->union_.next;\n        m_del(byte, chunk, sizeof(mp_parse_chunk_t) + chunk->alloc);\n        chunk = next;\n    }\n    tree->chunk = NULL; \n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}