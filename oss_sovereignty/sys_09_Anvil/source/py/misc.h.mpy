{
  "module_name": "misc.h",
  "hash_id": "3defc553bf0d9a1c4bcadf2651e184f7f9486aee4a2e32354f928a1a2bbacba9",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/misc.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_MISC_H\n#define MICROPY_INCLUDED_PY_MISC_H\n\n\n\n \n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef unsigned char byte;\ntypedef unsigned int uint;\n\n \n\n#ifndef MIN\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n#endif\n#ifndef MAX\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#endif\n\n\n#define MP_STRINGIFY_HELPER(x) #x\n#define MP_STRINGIFY(x) MP_STRINGIFY_HELPER(x)\n\n\n#define MP_STATIC_ASSERT(cond) ((void)sizeof(char[1 - 2 * !(cond)]))\n\n\n\n\n\n#if defined(_MSC_VER) || defined(__cplusplus)\n#define MP_STATIC_ASSERT_NONCONSTEXPR(cond) ((void)1)\n#else\n#define MP_STATIC_ASSERT_NONCONSTEXPR(cond) MP_STATIC_ASSERT(cond)\n#endif\n\n\n#define MP_CEIL_DIVIDE(a, b) (((a) + (b) - 1) / (b))\n#define MP_ROUND_DIVIDE(a, b) (((a) + (b) / 2) / (b))\n\n \n\n\n\n#define m_new(type, num) ((type *)(m_malloc(sizeof(type) * (num))))\n#define m_new_maybe(type, num) ((type *)(m_malloc_maybe(sizeof(type) * (num))))\n#define m_new0(type, num) ((type *)(m_malloc0(sizeof(type) * (num))))\n#define m_new_obj(type) (m_new(type, 1))\n#define m_new_obj_maybe(type) (m_new_maybe(type, 1))\n#define m_new_obj_var(obj_type, var_field, var_type, var_num) ((obj_type *)m_malloc(offsetof(obj_type, var_field) + sizeof(var_type) * (var_num)))\n#define m_new_obj_var0(obj_type, var_field, var_type, var_num) ((obj_type *)m_malloc0(offsetof(obj_type, var_field) + sizeof(var_type) * (var_num)))\n#define m_new_obj_var_maybe(obj_type, var_field, var_type, var_num) ((obj_type *)m_malloc_maybe(offsetof(obj_type, var_field) + sizeof(var_type) * (var_num)))\n#if MICROPY_MALLOC_USES_ALLOCATED_SIZE\n#define m_renew(type, ptr, old_num, new_num) ((type *)(m_realloc((ptr), sizeof(type) * (old_num), sizeof(type) * (new_num))))\n#define m_renew_maybe(type, ptr, old_num, new_num, allow_move) ((type *)(m_realloc_maybe((ptr), sizeof(type) * (old_num), sizeof(type) * (new_num), (allow_move))))\n#define m_del(type, ptr, num) m_free(ptr, sizeof(type) * (num))\n#define m_del_var(obj_type, var_field, var_type, var_num, ptr) (m_free(ptr, offsetof(obj_type, var_field) + sizeof(var_type) * (var_num)))\n#else\n#define m_renew(type, ptr, old_num, new_num) ((type *)(m_realloc((ptr), sizeof(type) * (new_num))))\n#define m_renew_maybe(type, ptr, old_num, new_num, allow_move) ((type *)(m_realloc_maybe((ptr), sizeof(type) * (new_num), (allow_move))))\n#define m_del(type, ptr, num) ((void)(num), m_free(ptr))\n#define m_del_var(obj_type, var_field, var_type, var_num, ptr) ((void)(var_num), m_free(ptr))\n#endif\n#define m_del_obj(type, ptr) (m_del(type, ptr, 1))\n\nvoid *m_malloc(size_t num_bytes);\nvoid *m_malloc_maybe(size_t num_bytes);\nvoid *m_malloc_with_finaliser(size_t num_bytes);\nvoid *m_malloc0(size_t num_bytes);\n#if MICROPY_MALLOC_USES_ALLOCATED_SIZE\nvoid *m_realloc(void *ptr, size_t old_num_bytes, size_t new_num_bytes);\nvoid *m_realloc_maybe(void *ptr, size_t old_num_bytes, size_t new_num_bytes, bool allow_move);\nvoid m_free(void *ptr, size_t num_bytes);\n#else\nvoid *m_realloc(void *ptr, size_t new_num_bytes);\nvoid *m_realloc_maybe(void *ptr, size_t new_num_bytes, bool allow_move);\nvoid m_free(void *ptr);\n#endif\nNORETURN void m_malloc_fail(size_t num_bytes);\n\n#if MICROPY_TRACKED_ALLOC\n\n\nvoid *m_tracked_calloc(size_t nmemb, size_t size);\nvoid m_tracked_free(void *ptr_in);\n#endif\n\n#if MICROPY_MEM_STATS\nsize_t m_get_total_bytes_allocated(void);\nsize_t m_get_current_bytes_allocated(void);\nsize_t m_get_peak_bytes_allocated(void);\n#endif\n\n \n\n\n#define MP_ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\n\n#define MP_ALIGN(ptr, alignment) (void *)(((uintptr_t)(ptr) + ((alignment) - 1)) & ~((alignment) - 1))\n\n \n\n#if MICROPY_PY_BUILTINS_STR_UNICODE\n\ntypedef uint32_t unichar;\n#else\n\n\ntypedef uint unichar;\n#endif\n\n#if MICROPY_PY_BUILTINS_STR_UNICODE\nunichar utf8_get_char(const byte *s);\nconst byte *utf8_next_char(const byte *s);\nsize_t utf8_charlen(const byte *str, size_t len);\n#else\nstatic inline unichar utf8_get_char(const byte *s) {\n    return *s;\n}\nstatic inline const byte *utf8_next_char(const byte *s) {\n    return s + 1;\n}\nstatic inline size_t utf8_charlen(const byte *str, size_t len) {\n    (void)str;\n    return len;\n}\n#endif\n\nbool unichar_isspace(unichar c);\nbool unichar_isalpha(unichar c);\nbool unichar_isprint(unichar c);\nbool unichar_isdigit(unichar c);\nbool unichar_isxdigit(unichar c);\nbool unichar_isident(unichar c);\nbool unichar_isalnum(unichar c);\nbool unichar_isupper(unichar c);\nbool unichar_islower(unichar c);\nunichar unichar_tolower(unichar c);\nunichar unichar_toupper(unichar c);\nmp_uint_t unichar_xdigit_value(unichar c);\n#define UTF8_IS_NONASCII(ch) ((ch) & 0x80)\n#define UTF8_IS_CONT(ch) (((ch) & 0xC0) == 0x80)\n\n \n\ntypedef struct _vstr_t {\n    size_t alloc;\n    size_t len;\n    char *buf;\n    bool fixed_buf;\n} vstr_t;\n\n\n#define VSTR_FIXED(vstr, alloc) vstr_t vstr; char vstr##_buf[(alloc)]; vstr_init_fixed_buf(&vstr, (alloc), vstr##_buf);\n\nvoid vstr_init(vstr_t *vstr, size_t alloc);\nvoid vstr_init_len(vstr_t *vstr, size_t len);\nvoid vstr_init_fixed_buf(vstr_t *vstr, size_t alloc, char *buf);\nstruct _mp_print_t;\nvoid vstr_init_print(vstr_t *vstr, size_t alloc, struct _mp_print_t *print);\nvoid vstr_clear(vstr_t *vstr);\nvstr_t *vstr_new(size_t alloc);\nvoid vstr_free(vstr_t *vstr);\nstatic inline void vstr_reset(vstr_t *vstr) {\n    vstr->len = 0;\n}\nstatic inline char *vstr_str(vstr_t *vstr) {\n    return vstr->buf;\n}\nstatic inline size_t vstr_len(vstr_t *vstr) {\n    return vstr->len;\n}\nvoid vstr_hint_size(vstr_t *vstr, size_t size);\nchar *vstr_extend(vstr_t *vstr, size_t size);\nchar *vstr_add_len(vstr_t *vstr, size_t len);\nchar *vstr_null_terminated_str(vstr_t *vstr);\nvoid vstr_add_byte(vstr_t *vstr, byte v);\nvoid vstr_add_char(vstr_t *vstr, unichar chr);\nvoid vstr_add_str(vstr_t *vstr, const char *str);\nvoid vstr_add_strn(vstr_t *vstr, const char *str, size_t len);\nvoid vstr_ins_byte(vstr_t *vstr, size_t byte_pos, byte b);\nvoid vstr_ins_char(vstr_t *vstr, size_t char_pos, unichar chr);\nvoid vstr_cut_head_bytes(vstr_t *vstr, size_t bytes_to_cut);\nvoid vstr_cut_tail_bytes(vstr_t *vstr, size_t bytes_to_cut);\nvoid vstr_cut_out_bytes(vstr_t *vstr, size_t byte_pos, size_t bytes_to_cut);\nvoid vstr_printf(vstr_t *vstr, const char *fmt, ...);\n\n \n\n#define CHECKBUF(buf, max_size) char buf[max_size + 1]; size_t buf##_len = max_size; char *buf##_p = buf;\n#define CHECKBUF_RESET(buf, max_size) buf##_len = max_size; buf##_p = buf;\n#define CHECKBUF_APPEND(buf, src, src_len) \\\n    { size_t l = MIN(src_len, buf##_len); \\\n      memcpy(buf##_p, src, l); \\\n      buf##_len -= l; \\\n      buf##_p += l; }\n#define CHECKBUF_APPEND_0(buf) { *buf##_p = 0; }\n#define CHECKBUF_LEN(buf) (buf##_p - buf)\n\n#ifdef va_start\nvoid vstr_vprintf(vstr_t *vstr, const char *fmt, va_list ap);\n#endif\n\n\nint DEBUG_printf(const char *fmt, ...);\n\nextern mp_uint_t mp_verbose_flag;\n\n \n\n#if MICROPY_PY_BUILTINS_FLOAT\n\n#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE\n#define MP_FLOAT_EXP_BITS (11)\n#define MP_FLOAT_EXP_OFFSET (1023)\n#define MP_FLOAT_FRAC_BITS (52)\ntypedef uint64_t mp_float_uint_t;\n#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT\n#define MP_FLOAT_EXP_BITS (8)\n#define MP_FLOAT_EXP_OFFSET (127)\n#define MP_FLOAT_FRAC_BITS (23)\ntypedef uint32_t mp_float_uint_t;\n#endif\n\n#define MP_FLOAT_EXP_BIAS ((1 << (MP_FLOAT_EXP_BITS - 1)) - 1)\n\ntypedef union _mp_float_union_t {\n    mp_float_t f;\n    #if MP_ENDIANNESS_LITTLE\n    struct {\n        mp_float_uint_t frc : MP_FLOAT_FRAC_BITS;\n        mp_float_uint_t exp : MP_FLOAT_EXP_BITS;\n        mp_float_uint_t sgn : 1;\n    } p;\n    #else\n    struct {\n        mp_float_uint_t sgn : 1;\n        mp_float_uint_t exp : MP_FLOAT_EXP_BITS;\n        mp_float_uint_t frc : MP_FLOAT_FRAC_BITS;\n    } p;\n    #endif\n    mp_float_uint_t i;\n} mp_float_union_t;\n\n#endif \n\n \n\n#if MICROPY_ROM_TEXT_COMPRESSION\n\n#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NONE\n#error \"MICROPY_ERROR_REPORTING_NONE requires MICROPY_ROM_TEXT_COMPRESSION disabled\"\n#endif\n\n#ifdef NO_QSTR\n\n\n\n\n#else\n\n\n\n\n\ntypedef struct {\n    #if defined(__clang__) || defined(_MSC_VER)\n    \n    \n    char dummy;\n    #endif\n} *mp_rom_error_text_t;\n\n#include <string.h>\n\ninline MP_ALWAYSINLINE const char *MP_COMPRESSED_ROM_TEXT(const char *msg) {\n    \n    \n    #define MP_MATCH_COMPRESSED(a, b) if (strcmp(msg, a) == 0) { return b; } else\n\n    \n    #define MP_COMPRESSED_DATA(x)\n\n    #include \"genhdr/compressed.data.h\"\n\n#undef MP_COMPRESSED_DATA\n#undef MP_MATCH_COMPRESSED\n\n    return msg;\n}\n\n#endif\n\n#else\n\n\n\ntypedef const char *mp_rom_error_text_t;\n#define MP_COMPRESSED_ROM_TEXT(x) x\n\n#endif \n\n\n\n#define MP_ERROR_TEXT(x) (mp_rom_error_text_t)MP_COMPRESSED_ROM_TEXT(x)\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}