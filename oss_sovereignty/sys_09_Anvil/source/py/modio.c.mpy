{
  "module_name": "modio.c",
  "hash_id": "a3170c1615e3e42d07abe54e8bdd1481cedc015fa07bddfd283f2648e6528e0c",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modio.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/stream.h\"\n#include \"py/binary.h\"\n#include \"py/objarray.h\"\n#include \"py/objstringio.h\"\n#include \"py/frozenmod.h\"\n\n#if MICROPY_PY_IO\n\n#if MICROPY_PY_IO_IOBASE\n\nstatic const mp_obj_type_t mp_type_iobase;\n\nstatic const mp_obj_base_t iobase_singleton = {&mp_type_iobase};\n\nstatic mp_obj_t iobase_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type;\n    (void)n_args;\n    (void)n_kw;\n    (void)args;\n    return MP_OBJ_FROM_PTR(&iobase_singleton);\n}\n\nstatic mp_uint_t iobase_read_write(mp_obj_t obj, void *buf, mp_uint_t size, int *errcode, qstr qst) {\n    mp_obj_t dest[3];\n    mp_load_method(obj, qst, dest);\n    mp_obj_array_t ar = {{&mp_type_bytearray}, BYTEARRAY_TYPECODE, 0, size, buf};\n    dest[2] = MP_OBJ_FROM_PTR(&ar);\n    mp_obj_t ret_obj = mp_call_method_n_kw(1, 0, dest);\n    if (ret_obj == mp_const_none) {\n        *errcode = MP_EAGAIN;\n        return MP_STREAM_ERROR;\n    }\n    mp_int_t ret = mp_obj_get_int(ret_obj);\n    if (ret >= 0) {\n        return ret;\n    } else {\n        *errcode = -ret;\n        return MP_STREAM_ERROR;\n    }\n}\nstatic mp_uint_t iobase_read(mp_obj_t obj, void *buf, mp_uint_t size, int *errcode) {\n    return iobase_read_write(obj, buf, size, errcode, MP_QSTR_readinto);\n}\n\nstatic mp_uint_t iobase_write(mp_obj_t obj, const void *buf, mp_uint_t size, int *errcode) {\n    return iobase_read_write(obj, (void *)buf, size, errcode, MP_QSTR_write);\n}\n\nstatic mp_uint_t iobase_ioctl(mp_obj_t obj, mp_uint_t request, uintptr_t arg, int *errcode) {\n    mp_obj_t dest[4];\n    mp_load_method(obj, MP_QSTR_ioctl, dest);\n    dest[2] = mp_obj_new_int_from_uint(request);\n    dest[3] = mp_obj_new_int_from_uint(arg);\n    mp_int_t ret = mp_obj_get_int(mp_call_method_n_kw(2, 0, dest));\n    if (ret >= 0) {\n        return ret;\n    } else {\n        *errcode = -ret;\n        return MP_STREAM_ERROR;\n    }\n}\n\nstatic const mp_stream_p_t iobase_p = {\n    .read = iobase_read,\n    .write = iobase_write,\n    .ioctl = iobase_ioctl,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_iobase,\n    MP_QSTR_IOBase,\n    MP_TYPE_FLAG_NONE,\n    make_new, iobase_make_new,\n    protocol, &iobase_p\n    );\n\n#endif \n\n#if MICROPY_PY_IO_BUFFEREDWRITER\ntypedef struct _mp_obj_bufwriter_t {\n    mp_obj_base_t base;\n    mp_obj_t stream;\n    size_t alloc;\n    size_t len;\n    byte buf[0];\n} mp_obj_bufwriter_t;\n\nstatic mp_obj_t bufwriter_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 2, 2, false);\n    size_t alloc = mp_obj_get_int(args[1]);\n    mp_obj_bufwriter_t *o = mp_obj_malloc_var(mp_obj_bufwriter_t, buf, byte, alloc, type);\n    o->stream = args[0];\n    o->alloc = alloc;\n    o->len = 0;\n    return o;\n}\n\nstatic mp_uint_t bufwriter_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {\n    mp_obj_bufwriter_t *self = MP_OBJ_TO_PTR(self_in);\n\n    mp_uint_t org_size = size;\n\n    while (size > 0) {\n        mp_uint_t rem = self->alloc - self->len;\n        if (size < rem) {\n            memcpy(self->buf + self->len, buf, size);\n            self->len += size;\n            return org_size;\n        }\n\n        \n        \n        \n        \n        \n        \n        memcpy(self->buf + self->len, buf, rem);\n        buf = (byte *)buf + rem;\n        size -= rem;\n        mp_uint_t out_sz = mp_stream_write_exactly(self->stream, self->buf, self->alloc, errcode);\n        (void)out_sz;\n        if (*errcode != 0) {\n            return MP_STREAM_ERROR;\n        }\n        \n        \n        assert(out_sz == self->alloc);\n        self->len = 0;\n    }\n\n    return org_size;\n}\n\nstatic mp_obj_t bufwriter_flush(mp_obj_t self_in) {\n    mp_obj_bufwriter_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->len != 0) {\n        int err;\n        mp_uint_t out_sz = mp_stream_write_exactly(self->stream, self->buf, self->len, &err);\n        (void)out_sz;\n        \n        \n        assert(out_sz == self->len);\n        self->len = 0;\n        if (err != 0) {\n            mp_raise_OSError(err);\n        }\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(bufwriter_flush_obj, bufwriter_flush);\n\nstatic const mp_rom_map_elem_t bufwriter_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },\n    { MP_ROM_QSTR(MP_QSTR_flush), MP_ROM_PTR(&bufwriter_flush_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(bufwriter_locals_dict, bufwriter_locals_dict_table);\n\nstatic const mp_stream_p_t bufwriter_stream_p = {\n    .write = bufwriter_write,\n};\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bufwriter,\n    MP_QSTR_BufferedWriter,\n    MP_TYPE_FLAG_NONE,\n    make_new, bufwriter_make_new,\n    protocol, &bufwriter_stream_p,\n    locals_dict, &bufwriter_locals_dict\n    );\n#endif \n\nstatic const mp_rom_map_elem_t mp_module_io_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_io) },\n    \n    \n    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_builtin_open_obj) },\n    #if MICROPY_PY_IO_IOBASE\n    { MP_ROM_QSTR(MP_QSTR_IOBase), MP_ROM_PTR(&mp_type_iobase) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_StringIO), MP_ROM_PTR(&mp_type_stringio) },\n    #if MICROPY_PY_IO_BYTESIO\n    { MP_ROM_QSTR(MP_QSTR_BytesIO), MP_ROM_PTR(&mp_type_bytesio) },\n    #endif\n    #if MICROPY_PY_IO_BUFFEREDWRITER\n    { MP_ROM_QSTR(MP_QSTR_BufferedWriter), MP_ROM_PTR(&mp_type_bufwriter) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_io_globals, mp_module_io_globals_table);\n\nconst mp_obj_module_t mp_module_io = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_io_globals,\n};\n\nMP_REGISTER_EXTENSIBLE_MODULE(MP_QSTR_io, mp_module_io);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}