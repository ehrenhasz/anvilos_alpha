{
  "module_name": "unicode.c",
  "hash_id": "35bcea9beb2b1c525f834335babe5c6595ac96ab2e17469761481a054db9a0e0",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/unicode.c",
  "human_readable_source": " \n\n#include <stdint.h>\n\n#include \"py/unicode.h\"\n\n\n#define FL_PRINT (0x01)\n#define FL_SPACE (0x02)\n#define FL_DIGIT (0x04)\n#define FL_ALPHA (0x08)\n#define FL_UPPER (0x10)\n#define FL_LOWER (0x20)\n#define FL_XDIGIT (0x40)\n\n\n#define AT_PR (FL_PRINT)\n#define AT_SP (FL_SPACE | FL_PRINT)\n#define AT_DI (FL_DIGIT | FL_PRINT | FL_XDIGIT)\n#define AT_AL (FL_ALPHA | FL_PRINT)\n#define AT_UP (FL_UPPER | FL_ALPHA | FL_PRINT)\n#define AT_LO (FL_LOWER | FL_ALPHA | FL_PRINT)\n#define AT_UX (FL_UPPER | FL_ALPHA | FL_PRINT | FL_XDIGIT)\n#define AT_LX (FL_LOWER | FL_ALPHA | FL_PRINT | FL_XDIGIT)\n\n\nstatic const uint8_t attr[] = {\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, AT_SP, AT_SP, AT_SP, AT_SP, AT_SP, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    AT_SP, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,\n    AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,\n    AT_DI, AT_DI, AT_DI, AT_DI, AT_DI, AT_DI, AT_DI, AT_DI,\n    AT_DI, AT_DI, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,\n    AT_PR, AT_UX, AT_UX, AT_UX, AT_UX, AT_UX, AT_UX, AT_UP,\n    AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP,\n    AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP,\n    AT_UP, AT_UP, AT_UP, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,\n    AT_PR, AT_LX, AT_LX, AT_LX, AT_LX, AT_LX, AT_LX, AT_LO,\n    AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO,\n    AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO,\n    AT_LO, AT_LO, AT_LO, AT_PR, AT_PR, AT_PR, AT_PR, 0\n};\n\n#if MICROPY_PY_BUILTINS_STR_UNICODE\n\nunichar utf8_get_char(const byte *s) {\n    unichar ord = *s++;\n    if (!UTF8_IS_NONASCII(ord)) {\n        return ord;\n    }\n    ord &= 0x7F;\n    for (unichar mask = 0x40; ord & mask; mask >>= 1) {\n        ord &= ~mask;\n    }\n    while (UTF8_IS_CONT(*s)) {\n        ord = (ord << 6) | (*s++ & 0x3F);\n    }\n    return ord;\n}\n\nconst byte *utf8_next_char(const byte *s) {\n    ++s;\n    while (UTF8_IS_CONT(*s)) {\n        ++s;\n    }\n    return s;\n}\n\nmp_uint_t utf8_ptr_to_index(const byte *s, const byte *ptr) {\n    mp_uint_t i = 0;\n    while (ptr > s) {\n        if (!UTF8_IS_CONT(*--ptr)) {\n            i++;\n        }\n    }\n\n    return i;\n}\n\nsize_t utf8_charlen(const byte *str, size_t len) {\n    size_t charlen = 0;\n    for (const byte *top = str + len; str < top; ++str) {\n        if (!UTF8_IS_CONT(*str)) {\n            ++charlen;\n        }\n    }\n    return charlen;\n}\n\n#endif\n\n\nbool unichar_isspace(unichar c) {\n    return c < 128 && (attr[c] & FL_SPACE) != 0;\n}\n\nbool unichar_isalpha(unichar c) {\n    return c < 128 && (attr[c] & FL_ALPHA) != 0;\n}\n\n \n\nbool unichar_isdigit(unichar c) {\n    return c < 128 && (attr[c] & FL_DIGIT) != 0;\n}\n\nbool unichar_isxdigit(unichar c) {\n    return c < 128 && (attr[c] & FL_XDIGIT) != 0;\n}\n\nbool unichar_isident(unichar c) {\n    return c < 128 && ((attr[c] & (FL_ALPHA | FL_DIGIT)) != 0 || c == '_');\n}\n\nbool unichar_isalnum(unichar c) {\n    return c < 128 && ((attr[c] & (FL_ALPHA | FL_DIGIT)) != 0);\n}\n\nbool unichar_isupper(unichar c) {\n    return c < 128 && (attr[c] & FL_UPPER) != 0;\n}\n\nbool unichar_islower(unichar c) {\n    return c < 128 && (attr[c] & FL_LOWER) != 0;\n}\n\nunichar unichar_tolower(unichar c) {\n    if (unichar_isupper(c)) {\n        return c + 0x20;\n    }\n    return c;\n}\n\nunichar unichar_toupper(unichar c) {\n    if (unichar_islower(c)) {\n        return c - 0x20;\n    }\n    return c;\n}\n\nmp_uint_t unichar_xdigit_value(unichar c) {\n    \n    mp_uint_t n = c - '0';\n    if (n > 9) {\n        n &= ~('a' - 'A');\n        n -= ('A' - ('9' + 1));\n    }\n    return n;\n}\n\n#if MICROPY_PY_BUILTINS_STR_UNICODE\n\nbool utf8_check(const byte *p, size_t len) {\n    uint8_t need = 0;\n    const byte *end = p + len;\n    for (; p < end; p++) {\n        byte c = *p;\n        if (need) {\n            if (UTF8_IS_CONT(c)) {\n                need--;\n            } else {\n                \n                return 0;\n            }\n        } else {\n            if (c >= 0xc0) {\n                if (c >= 0xf8) {\n                    \n                    return 0;\n                }\n                need = (0xe5 >> ((c >> 3) & 0x6)) & 3;\n            } else if (c >= 0x80) {\n                \n                return 0;\n            }\n        }\n    }\n    return need == 0; \n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}