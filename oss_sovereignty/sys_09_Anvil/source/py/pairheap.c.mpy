{
  "module_name": "pairheap.c",
  "hash_id": "1789a06a876c793a4d82aff20b8f7fa196ad90fc6a70f5c7f58e08d947639111",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/pairheap.c",
  "human_readable_source": " \n\n#include \"py/pairheap.h\"\n\n\n\n\n\n\n#define NEXT_MAKE_RIGHTMOST_PARENT(parent) ((void *)((uintptr_t)(parent) | 1))\n#define NEXT_IS_RIGHTMOST_PARENT(next) ((uintptr_t)(next) & 1)\n#define NEXT_GET_RIGHTMOST_PARENT(next) ((void *)((uintptr_t)(next) & ~1))\n\n\nmp_pairheap_t *mp_pairheap_meld(mp_pairheap_lt_t lt, mp_pairheap_t *heap1, mp_pairheap_t *heap2) {\n    if (heap1 == NULL) {\n        return heap2;\n    }\n    if (heap2 == NULL) {\n        return heap1;\n    }\n    if (lt(heap1, heap2)) {\n        if (heap1->child == NULL) {\n            heap1->child = heap2;\n        } else {\n            heap1->child_last->next = heap2;\n        }\n        heap1->child_last = heap2;\n        heap2->next = NEXT_MAKE_RIGHTMOST_PARENT(heap1);\n        return heap1;\n    } else {\n        heap1->next = heap2->child;\n        heap2->child = heap1;\n        if (heap1->next == NULL) {\n            heap2->child_last = heap1;\n            heap1->next = NEXT_MAKE_RIGHTMOST_PARENT(heap2);\n        }\n        return heap2;\n    }\n}\n\n\nmp_pairheap_t *mp_pairheap_pairing(mp_pairheap_lt_t lt, mp_pairheap_t *child) {\n    if (child == NULL) {\n        return NULL;\n    }\n    mp_pairheap_t *heap = NULL;\n    while (!NEXT_IS_RIGHTMOST_PARENT(child)) {\n        mp_pairheap_t *n1 = child;\n        child = child->next;\n        n1->next = NULL;\n        if (!NEXT_IS_RIGHTMOST_PARENT(child)) {\n            mp_pairheap_t *n2 = child;\n            child = child->next;\n            n2->next = NULL;\n            n1 = mp_pairheap_meld(lt, n1, n2);\n        }\n        heap = mp_pairheap_meld(lt, heap, n1);\n    }\n    heap->next = NULL;\n    return heap;\n}\n\n\nmp_pairheap_t *mp_pairheap_delete(mp_pairheap_lt_t lt, mp_pairheap_t *heap, mp_pairheap_t *node) {\n    \n    if (node == heap) {\n        mp_pairheap_t *child = heap->child;\n        node->child = NULL;\n        return mp_pairheap_pairing(lt, child);\n    }\n\n    \n    if (node->next == NULL) {\n        return heap;\n    }\n\n    \n    mp_pairheap_t *parent = node;\n    while (!NEXT_IS_RIGHTMOST_PARENT(parent->next)) {\n        parent = parent->next;\n    }\n    parent = NEXT_GET_RIGHTMOST_PARENT(parent->next);\n\n    \n    mp_pairheap_t *next;\n    if (node == parent->child && node->child == NULL) {\n        if (NEXT_IS_RIGHTMOST_PARENT(node->next)) {\n            parent->child = NULL;\n        } else {\n            parent->child = node->next;\n        }\n        node->next = NULL;\n        return heap;\n    } else if (node == parent->child) {\n        mp_pairheap_t *child = node->child;\n        next = node->next;\n        node->child = NULL;\n        node->next = NULL;\n        node = mp_pairheap_pairing(lt, child);\n        parent->child = node;\n    } else {\n        mp_pairheap_t *n = parent->child;\n        while (node != n->next) {\n            n = n->next;\n        }\n        mp_pairheap_t *child = node->child;\n        next = node->next;\n        node->child = NULL;\n        node->next = NULL;\n        node = mp_pairheap_pairing(lt, child);\n        if (node == NULL) {\n            node = n;\n        } else {\n            n->next = node;\n        }\n    }\n    node->next = next;\n    if (NEXT_IS_RIGHTMOST_PARENT(next)) {\n        parent->child_last = node;\n    }\n    return heap;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}