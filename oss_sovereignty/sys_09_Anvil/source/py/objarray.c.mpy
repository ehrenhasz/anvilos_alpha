{
  "module_name": "objarray.c",
  "hash_id": "f15327aaa26f0d0f6514143a56fac5ab15b1f5ce036011ad2a29c7700ca71372",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objarray.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n#include <stdint.h>\n\n#include \"py/runtime.h\"\n#include \"py/binary.h\"\n#include \"py/objstr.h\"\n#include \"py/objarray.h\"\n\n#if MICROPY_PY_ARRAY || MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_BUILTINS_MEMORYVIEW\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#if MICROPY_PY_BUILTINS_MEMORYVIEW\n#define TYPECODE_MASK (0x7f)\n#define memview_offset free\n#define memview_offset_max ((1LL << MP_OBJ_ARRAY_FREE_SIZE_BITS) - 1)\n#else\n\n#define TYPECODE_MASK (~(size_t)0)\n\n\n#endif\n\nstatic mp_obj_t array_iterator_new(mp_obj_t array_in, mp_obj_iter_buf_t *iter_buf);\nstatic mp_obj_t array_append(mp_obj_t self_in, mp_obj_t arg);\nstatic mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in);\nstatic mp_int_t array_get_buffer(mp_obj_t o_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);\n\n \n\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY\nstatic void array_print(const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_array_t *o = MP_OBJ_TO_PTR(o_in);\n    if (o->typecode == BYTEARRAY_TYPECODE) {\n        mp_print_str(print, \"bytearray(b\");\n        mp_str_print_quoted(print, o->items, o->len, true);\n    } else {\n        mp_printf(print, \"array('%c'\", o->typecode);\n        if (o->len > 0) {\n            mp_print_str(print, \", [\");\n            for (size_t i = 0; i < o->len; i++) {\n                if (i > 0) {\n                    mp_print_str(print, \", \");\n                }\n                mp_obj_print_helper(print, mp_binary_get_val_array(o->typecode, o->items, i), PRINT_REPR);\n            }\n            mp_print_str(print, \"]\");\n        }\n    }\n    mp_print_str(print, \")\");\n}\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY\nstatic mp_obj_array_t *array_new(char typecode, size_t n) {\n    int typecode_size = mp_binary_get_size('@', typecode, NULL);\n    mp_obj_array_t *o = m_new_obj(mp_obj_array_t);\n    #if MICROPY_PY_BUILTINS_BYTEARRAY && MICROPY_PY_ARRAY\n    o->base.type = (typecode == BYTEARRAY_TYPECODE) ? &mp_type_bytearray : &mp_type_array;\n    #elif MICROPY_PY_BUILTINS_BYTEARRAY\n    o->base.type = &mp_type_bytearray;\n    #else\n    o->base.type = &mp_type_array;\n    #endif\n    o->typecode = typecode;\n    o->free = 0;\n    o->len = n;\n    o->items = m_new(byte, typecode_size * o->len);\n    return o;\n}\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY\nstatic mp_obj_t array_construct(char typecode, mp_obj_t initializer) {\n    \n    \n    mp_buffer_info_t bufinfo;\n    if (((MICROPY_PY_BUILTINS_BYTEARRAY\n          && typecode == BYTEARRAY_TYPECODE)\n         || (MICROPY_PY_ARRAY\n             && (mp_obj_is_type(initializer, &mp_type_bytes)\n                 || (MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(initializer, &mp_type_bytearray)))))\n        && mp_get_buffer(initializer, &bufinfo, MP_BUFFER_READ)) {\n        \n        \n        size_t sz = mp_binary_get_size('@', typecode, NULL);\n        size_t len = bufinfo.len / sz;\n        mp_obj_array_t *o = array_new(typecode, len);\n        memcpy(o->items, bufinfo.buf, len * sz);\n        return MP_OBJ_FROM_PTR(o);\n    }\n\n    size_t len;\n    \n    mp_obj_t len_in = mp_obj_len_maybe(initializer);\n    if (len_in == MP_OBJ_NULL) {\n        len = 0;\n    } else {\n        len = MP_OBJ_SMALL_INT_VALUE(len_in);\n    }\n\n    mp_obj_array_t *array = array_new(typecode, len);\n\n    mp_obj_t iterable = mp_getiter(initializer, NULL);\n    mp_obj_t item;\n    size_t i = 0;\n    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n        if (len == 0) {\n            array_append(MP_OBJ_FROM_PTR(array), item);\n        } else {\n            mp_binary_set_val_array(typecode, array->items, i++, item);\n        }\n    }\n\n    return MP_OBJ_FROM_PTR(array);\n}\n#endif\n\n#if MICROPY_PY_ARRAY\nstatic mp_obj_t array_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    mp_arg_check_num(n_args, n_kw, 1, 2, false);\n\n    \n    const char *typecode = mp_obj_str_get_str(args[0]);\n\n    if (n_args == 1) {\n        \n        return MP_OBJ_FROM_PTR(array_new(*typecode, 0));\n    } else {\n        \n        return array_construct(*typecode, args[1]);\n    }\n}\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY\nstatic mp_obj_t bytearray_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n    \n    mp_arg_check_num(n_args, n_kw, 0, 3, false);\n\n    if (n_args == 0) {\n        \n        return MP_OBJ_FROM_PTR(array_new(BYTEARRAY_TYPECODE, 0));\n    } else if (mp_obj_is_int(args[0])) {\n        \n        mp_uint_t len = mp_obj_get_int(args[0]);\n        mp_obj_array_t *o = array_new(BYTEARRAY_TYPECODE, len);\n        memset(o->items, 0, len);\n        return MP_OBJ_FROM_PTR(o);\n    } else {\n        \n        if (mp_obj_is_str(args[0]) && n_args == 1) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            \n            mp_raise_TypeError(MP_ERROR_TEXT(\"wrong number of arguments\"));\n            #else\n            mp_raise_TypeError(MP_ERROR_TEXT(\"string argument without an encoding\"));\n            #endif\n        }\n        return array_construct(BYTEARRAY_TYPECODE, args[0]);\n    }\n}\n#endif\n\n#if MICROPY_PY_BUILTINS_MEMORYVIEW\n\nmp_obj_t mp_obj_new_memoryview(byte typecode, size_t nitems, void *items) {\n    mp_obj_array_t *self = m_new_obj(mp_obj_array_t);\n    mp_obj_memoryview_init(self, typecode, 0, nitems, items);\n    return MP_OBJ_FROM_PTR(self);\n}\n\nstatic mp_obj_t memoryview_make_new(const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    (void)type_in;\n\n    \n    \n\n    mp_arg_check_num(n_args, n_kw, 1, 1, false);\n\n    mp_buffer_info_t bufinfo;\n    mp_get_buffer_raise(args[0], &bufinfo, MP_BUFFER_READ);\n\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(mp_obj_new_memoryview(bufinfo.typecode,\n        bufinfo.len / mp_binary_get_size('@', bufinfo.typecode, NULL),\n        bufinfo.buf));\n\n    \n    \n    if (mp_obj_get_type(args[0]) == &mp_type_memoryview) {\n        mp_obj_array_t *other = MP_OBJ_TO_PTR(args[0]);\n        self->memview_offset = other->memview_offset;\n        self->items = other->items;\n    }\n\n    \n    if (mp_get_buffer(args[0], &bufinfo, MP_BUFFER_RW)) {\n        self->typecode |= MP_OBJ_ARRAY_TYPECODE_FLAG_RW; \n    }\n\n    return MP_OBJ_FROM_PTR(self);\n}\n\n#if MICROPY_PY_BUILTINS_MEMORYVIEW_ITEMSIZE\nstatic void memoryview_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    if (dest[0] != MP_OBJ_NULL) {\n        return;\n    }\n    if (attr == MP_QSTR_itemsize) {\n        mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n        dest[0] = MP_OBJ_NEW_SMALL_INT(mp_binary_get_size('@', self->typecode & TYPECODE_MASK, NULL));\n    }\n    #if MICROPY_PY_BUILTINS_BYTES_HEX\n    else {\n        \n        dest[1] = MP_OBJ_SENTINEL;\n    }\n    #endif\n}\n#endif\n\n#endif\n\nstatic mp_obj_t array_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    mp_obj_array_t *o = MP_OBJ_TO_PTR(o_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(o->len != 0);\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(o->len);\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic int typecode_for_comparison(int typecode, bool *is_unsigned) {\n    if (typecode == BYTEARRAY_TYPECODE) {\n        typecode = 'B';\n    }\n    if (typecode <= 'Z') {\n        typecode += 32; \n        *is_unsigned = true;\n    }\n    return typecode;\n}\n\nstatic mp_obj_t array_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    mp_obj_array_t *lhs = MP_OBJ_TO_PTR(lhs_in);\n    switch (op) {\n        case MP_BINARY_OP_ADD: {\n            #if MICROPY_PY_BUILTINS_MEMORYVIEW\n            if (lhs->base.type == &mp_type_memoryview) {\n                return MP_OBJ_NULL; \n            }\n            #endif\n\n            \n            mp_buffer_info_t lhs_bufinfo;\n            mp_buffer_info_t rhs_bufinfo;\n            array_get_buffer(lhs_in, &lhs_bufinfo, MP_BUFFER_READ);\n            mp_get_buffer_raise(rhs_in, &rhs_bufinfo, MP_BUFFER_READ);\n\n            size_t sz = mp_binary_get_size('@', lhs_bufinfo.typecode, NULL);\n\n            \n            size_t rhs_len = rhs_bufinfo.len / sz;\n\n            \n            mp_obj_array_t *res = array_new(lhs_bufinfo.typecode, lhs->len + rhs_len);\n            mp_seq_cat((byte *)res->items, lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_len * sz, byte);\n            return MP_OBJ_FROM_PTR(res);\n        }\n\n        case MP_BINARY_OP_INPLACE_ADD: {\n            #if MICROPY_PY_BUILTINS_MEMORYVIEW\n            if (lhs->base.type == &mp_type_memoryview) {\n                return MP_OBJ_NULL; \n            }\n            #endif\n            array_extend(lhs_in, rhs_in);\n            return lhs_in;\n        }\n\n        case MP_BINARY_OP_CONTAINS: {\n            #if MICROPY_PY_BUILTINS_BYTEARRAY\n            \n            mp_buffer_info_t lhs_bufinfo;\n            mp_buffer_info_t rhs_bufinfo;\n            if (mp_get_buffer(rhs_in, &rhs_bufinfo, MP_BUFFER_READ)) {\n                if (!mp_obj_is_type(lhs_in, &mp_type_bytearray)) {\n                    return mp_const_false;\n                }\n                array_get_buffer(lhs_in, &lhs_bufinfo, MP_BUFFER_READ);\n                return mp_obj_new_bool(\n                    find_subbytes(lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_bufinfo.len, 1) != NULL);\n            }\n            #endif\n\n            \n            if (mp_obj_is_int(rhs_in) || mp_obj_is_float(rhs_in)) {\n                mp_raise_NotImplementedError(NULL);\n            }\n\n            return mp_const_false;\n        }\n\n        case MP_BINARY_OP_EQUAL:\n        case MP_BINARY_OP_LESS:\n        case MP_BINARY_OP_LESS_EQUAL:\n        case MP_BINARY_OP_MORE:\n        case MP_BINARY_OP_MORE_EQUAL: {\n            mp_buffer_info_t lhs_bufinfo;\n            mp_buffer_info_t rhs_bufinfo;\n            array_get_buffer(lhs_in, &lhs_bufinfo, MP_BUFFER_READ);\n            if (!mp_get_buffer(rhs_in, &rhs_bufinfo, MP_BUFFER_READ)) {\n                return mp_const_false;\n            }\n            \n            \n            \n            \n            \n            \n            \n            bool is_unsigned = false;\n            const int lhs_code = typecode_for_comparison(lhs_bufinfo.typecode, &is_unsigned);\n            const int rhs_code = typecode_for_comparison(rhs_bufinfo.typecode, &is_unsigned);\n            if (lhs_code == rhs_code && lhs_code != 'f' && lhs_code != 'd' && (op == MP_BINARY_OP_EQUAL || is_unsigned)) {\n                return mp_obj_new_bool(mp_seq_cmp_bytes(op, lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_bufinfo.len));\n            }\n            \n            \n            mp_raise_NotImplementedError(NULL);\n        }\n\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY\nstatic mp_obj_t array_append(mp_obj_t self_in, mp_obj_t arg) {\n    \n    assert((MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(self_in, &mp_type_bytearray))\n        || (MICROPY_PY_ARRAY && mp_obj_is_type(self_in, &mp_type_array)));\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n\n    if (self->free == 0) {\n        size_t item_sz = mp_binary_get_size('@', self->typecode, NULL);\n        \n        self->free = 8;\n        self->items = m_renew(byte, self->items, item_sz * self->len, item_sz * (self->len + self->free));\n        mp_seq_clear(self->items, self->len + 1, self->len + self->free, item_sz);\n    }\n    mp_binary_set_val_array(self->typecode, self->items, self->len, arg);\n    \n    self->len++;\n    self->free--;\n    return mp_const_none; \n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_obj_array_append_obj, array_append);\n\nstatic mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n    \n    assert((MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(self_in, &mp_type_bytearray))\n        || (MICROPY_PY_ARRAY && mp_obj_is_type(self_in, &mp_type_array)));\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n\n    \n    mp_buffer_info_t arg_bufinfo;\n    mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n\n    size_t sz = mp_binary_get_size('@', self->typecode, NULL);\n\n    \n    size_t len = arg_bufinfo.len / sz;\n\n    \n    \n    if (self->free < len) {\n        self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n        self->free = 0;\n\n        if (self_in == arg_in) {\n            \n            \n            \n            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n        }\n    } else {\n        self->free -= len;\n    }\n\n    \n    mp_seq_copy((byte *)self->items + self->len * sz, arg_bufinfo.buf, len * sz, byte);\n    self->len += len;\n\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_2(mp_obj_array_extend_obj, array_extend);\n#endif\n\nstatic mp_obj_t array_subscr(mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value) {\n    if (value == MP_OBJ_NULL) {\n        \n        \n        \n        \n        return MP_OBJ_NULL; \n    } else {\n        mp_obj_array_t *o = MP_OBJ_TO_PTR(self_in);\n        #if MICROPY_PY_BUILTINS_SLICE\n        if (mp_obj_is_type(index_in, &mp_type_slice)) {\n            mp_bound_slice_t slice;\n            if (!mp_seq_get_fast_slice_indexes(o->len, index_in, &slice)) {\n                mp_raise_NotImplementedError(MP_ERROR_TEXT(\"only slices with step=1 (aka None) are supported\"));\n            }\n            if (value != MP_OBJ_SENTINEL) {\n                #if MICROPY_PY_ARRAY_SLICE_ASSIGN\n                \n                size_t src_len;\n                uint8_t *src_items;\n                size_t src_offs = 0;\n                size_t item_sz = mp_binary_get_size('@', o->typecode & TYPECODE_MASK, NULL);\n                if (mp_obj_is_obj(value) && MP_OBJ_TYPE_GET_SLOT_OR_NULL(((mp_obj_base_t *)MP_OBJ_TO_PTR(value))->type, subscr) == array_subscr) {\n                    \n                    mp_obj_array_t *src_slice = MP_OBJ_TO_PTR(value);\n                    if (item_sz != mp_binary_get_size('@', src_slice->typecode & TYPECODE_MASK, NULL)) {\n                    compat_error:\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"lhs and rhs should be compatible\"));\n                    }\n                    src_len = src_slice->len;\n                    src_items = src_slice->items;\n                    #if MICROPY_PY_BUILTINS_MEMORYVIEW\n                    if (mp_obj_is_type(value, &mp_type_memoryview)) {\n                        src_offs = src_slice->memview_offset * item_sz;\n                    }\n                    #endif\n                } else if (mp_obj_is_type(value, &mp_type_bytes)) {\n                    if (item_sz != 1) {\n                        goto compat_error;\n                    }\n                    mp_buffer_info_t bufinfo;\n                    mp_get_buffer_raise(value, &bufinfo, MP_BUFFER_READ);\n                    src_len = bufinfo.len;\n                    src_items = bufinfo.buf;\n                } else {\n                    mp_raise_NotImplementedError(MP_ERROR_TEXT(\"array/bytes required on right side\"));\n                }\n\n                \n                mp_int_t len_adj = src_len - (slice.stop - slice.start);\n                uint8_t *dest_items = o->items;\n                #if MICROPY_PY_BUILTINS_MEMORYVIEW\n                if (o->base.type == &mp_type_memoryview) {\n                    if (!(o->typecode & MP_OBJ_ARRAY_TYPECODE_FLAG_RW)) {\n                        \n                        return MP_OBJ_NULL;\n                    }\n                    if (len_adj != 0) {\n                        goto compat_error;\n                    }\n                    dest_items += o->memview_offset * item_sz;\n                }\n                #endif\n                if (len_adj > 0) {\n                    if ((size_t)len_adj > o->free) {\n                        \n                        o->items = m_renew(byte, o->items, (o->len + o->free) * item_sz, (o->len + len_adj) * item_sz);\n                        o->free = len_adj;\n                        \n                        if (src_items == dest_items) {\n                            src_items = o->items;\n                        }\n                        dest_items = o->items;\n                    }\n                    mp_seq_replace_slice_grow_inplace(dest_items, o->len,\n                        slice.start, slice.stop, src_items + src_offs, src_len, len_adj, item_sz);\n                } else {\n                    mp_seq_replace_slice_no_grow(dest_items, o->len,\n                        slice.start, slice.stop, src_items + src_offs, src_len, item_sz);\n                    \n                    \n                    mp_seq_clear(dest_items, o->len + len_adj, o->len, item_sz);\n                    \n                }\n                o->free -= len_adj;\n                o->len += len_adj;\n                return mp_const_none;\n                #else\n                return MP_OBJ_NULL; \n                #endif\n            }\n\n            mp_obj_array_t *res;\n            size_t sz = mp_binary_get_size('@', o->typecode & TYPECODE_MASK, NULL);\n            assert(sz > 0);\n            #if MICROPY_PY_BUILTINS_MEMORYVIEW\n            if (o->base.type == &mp_type_memoryview) {\n                if (slice.start > memview_offset_max) {\n                    mp_raise_msg(&mp_type_OverflowError, MP_ERROR_TEXT(\"memoryview offset too large\"));\n                }\n                res = m_new_obj(mp_obj_array_t);\n                *res = *o;\n                res->memview_offset += slice.start;\n                res->len = slice.stop - slice.start;\n            } else\n            #endif\n            {\n                res = array_new(o->typecode, slice.stop - slice.start);\n                memcpy(res->items, (uint8_t *)o->items + slice.start * sz, (slice.stop - slice.start) * sz);\n            }\n            return MP_OBJ_FROM_PTR(res);\n        } else\n        #endif\n        {\n            size_t index = mp_get_index(o->base.type, o->len, index_in, false);\n            #if MICROPY_PY_BUILTINS_MEMORYVIEW\n            if (o->base.type == &mp_type_memoryview) {\n                index += o->memview_offset;\n                if (value != MP_OBJ_SENTINEL && !(o->typecode & MP_OBJ_ARRAY_TYPECODE_FLAG_RW)) {\n                    \n                    return MP_OBJ_NULL;\n                }\n            }\n            #endif\n            if (value == MP_OBJ_SENTINEL) {\n                \n                return mp_binary_get_val_array(o->typecode & TYPECODE_MASK, o->items, index);\n            } else {\n                \n                mp_binary_set_val_array(o->typecode & TYPECODE_MASK, o->items, index, value);\n                return mp_const_none;\n            }\n        }\n    }\n}\n\nstatic mp_int_t array_get_buffer(mp_obj_t o_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {\n    mp_obj_array_t *o = MP_OBJ_TO_PTR(o_in);\n    size_t sz = mp_binary_get_size('@', o->typecode & TYPECODE_MASK, NULL);\n    bufinfo->buf = o->items;\n    bufinfo->len = o->len * sz;\n    bufinfo->typecode = o->typecode & TYPECODE_MASK;\n    #if MICROPY_PY_BUILTINS_MEMORYVIEW\n    if (o->base.type == &mp_type_memoryview) {\n        if (!(o->typecode & MP_OBJ_ARRAY_TYPECODE_FLAG_RW) && (flags & MP_BUFFER_WRITE)) {\n            \n            return 1;\n        }\n        bufinfo->buf = (uint8_t *)bufinfo->buf + (size_t)o->memview_offset * sz;\n    }\n    #else\n    (void)flags;\n    #endif\n    return 0;\n}\n\n#if MICROPY_PY_ARRAY\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_array,\n    MP_QSTR_array,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, array_make_new,\n    print, array_print,\n    iter, array_iterator_new,\n    unary_op, array_unary_op,\n    binary_op, array_binary_op,\n    subscr, array_subscr,\n    buffer, array_get_buffer,\n    locals_dict, &mp_obj_array_locals_dict\n    );\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTEARRAY\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_bytearray,\n    MP_QSTR_bytearray,\n    MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE | MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, bytearray_make_new,\n    print, array_print,\n    iter, array_iterator_new,\n    unary_op, array_unary_op,\n    binary_op, array_binary_op,\n    subscr, array_subscr,\n    buffer, array_get_buffer,\n    locals_dict, &mp_obj_bytearray_locals_dict\n    );\n#endif\n\n#if MICROPY_PY_BUILTINS_MEMORYVIEW\n#if MICROPY_PY_BUILTINS_MEMORYVIEW_ITEMSIZE\n#define MEMORYVIEW_TYPE_ATTR attr, memoryview_attr,\n#else\n#define MEMORYVIEW_TYPE_ATTR\n#endif\n\n#if MICROPY_PY_BUILTINS_BYTES_HEX\n#define MEMORYVIEW_TYPE_LOCALS_DICT locals_dict, &mp_obj_memoryview_locals_dict,\n#else\n#define MEMORYVIEW_TYPE_LOCALS_DICT\n#endif\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_memoryview,\n    MP_QSTR_memoryview,\n    MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE | MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, memoryview_make_new,\n    iter, array_iterator_new,\n    unary_op, array_unary_op,\n    binary_op, array_binary_op,\n    MEMORYVIEW_TYPE_LOCALS_DICT\n    MEMORYVIEW_TYPE_ATTR\n    subscr, array_subscr,\n    buffer, array_get_buffer\n    );\n#endif \n\n \n\n#if MICROPY_PY_BUILTINS_BYTEARRAY\nmp_obj_t mp_obj_new_bytearray(size_t n, const void *items) {\n    mp_obj_array_t *o = array_new(BYTEARRAY_TYPECODE, n);\n    memcpy(o->items, items, n);\n    return MP_OBJ_FROM_PTR(o);\n}\n\n\nmp_obj_t mp_obj_new_bytearray_by_ref(size_t n, void *items) {\n    mp_obj_array_t *o = mp_obj_malloc(mp_obj_array_t, &mp_type_bytearray);\n    o->typecode = BYTEARRAY_TYPECODE;\n    o->free = 0;\n    o->len = n;\n    o->items = items;\n    return MP_OBJ_FROM_PTR(o);\n}\n#endif\n\n \n\n\ntypedef struct _mp_obj_array_it_t {\n    mp_obj_base_t base;\n    mp_obj_array_t *array;\n    size_t offset;\n    size_t cur;\n} mp_obj_array_it_t;\n\nstatic mp_obj_t array_it_iternext(mp_obj_t self_in) {\n    mp_obj_array_it_t *self = MP_OBJ_TO_PTR(self_in);\n    if (self->cur < self->array->len) {\n        return mp_binary_get_val_array(self->array->typecode & TYPECODE_MASK, self->array->items, self->offset + self->cur++);\n    } else {\n        return MP_OBJ_STOP_ITERATION;\n    }\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_array_it,\n    MP_QSTR_iterator,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    iter, array_it_iternext\n    );\n\nstatic mp_obj_t array_iterator_new(mp_obj_t array_in, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_array_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_array_t *array = MP_OBJ_TO_PTR(array_in);\n    mp_obj_array_it_t *o = (mp_obj_array_it_t *)iter_buf;\n    o->base.type = &mp_type_array_it;\n    o->array = array;\n    o->offset = 0;\n    o->cur = 0;\n    #if MICROPY_PY_BUILTINS_MEMORYVIEW\n    if (array->base.type == &mp_type_memoryview) {\n        o->offset = array->memview_offset;\n    }\n    #endif\n    return MP_OBJ_FROM_PTR(o);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}