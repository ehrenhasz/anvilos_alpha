{
  "module_name": "nativeglue.h",
  "hash_id": "b3eb0d7492ebda88d9c4a28d75ec402a5feee7b39326cab7a435349464017f19",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/nativeglue.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_NATIVEGLUE_H\n#define MICROPY_INCLUDED_PY_NATIVEGLUE_H\n\n#include <stdarg.h>\n#include \"py/obj.h\"\n#include \"py/persistentcode.h\"\n#include \"py/stream.h\"\n\ntypedef enum {\n    MP_F_CONST_NONE_OBJ = 0,\n    MP_F_CONST_FALSE_OBJ,\n    MP_F_CONST_TRUE_OBJ,\n    MP_F_CONVERT_OBJ_TO_NATIVE,\n    MP_F_CONVERT_NATIVE_TO_OBJ,\n    MP_F_NATIVE_SWAP_GLOBALS,\n    MP_F_LOAD_NAME,\n    MP_F_LOAD_GLOBAL,\n    MP_F_LOAD_BUILD_CLASS,\n    MP_F_LOAD_ATTR,\n    MP_F_LOAD_METHOD,\n    MP_F_LOAD_SUPER_METHOD,\n    MP_F_STORE_NAME,\n    MP_F_STORE_GLOBAL,\n    MP_F_STORE_ATTR,\n    MP_F_OBJ_SUBSCR,\n    MP_F_OBJ_IS_TRUE,\n    MP_F_UNARY_OP,\n    MP_F_BINARY_OP,\n    MP_F_BUILD_TUPLE,\n    MP_F_BUILD_LIST,\n    MP_F_BUILD_MAP,\n    MP_F_BUILD_SET,\n    MP_F_STORE_SET,\n    MP_F_LIST_APPEND,\n    MP_F_STORE_MAP,\n    MP_F_MAKE_FUNCTION_FROM_PROTO_FUN,\n    MP_F_NATIVE_CALL_FUNCTION_N_KW,\n    MP_F_CALL_METHOD_N_KW,\n    MP_F_CALL_METHOD_N_KW_VAR,\n    MP_F_NATIVE_GETITER,\n    MP_F_NATIVE_ITERNEXT,\n    MP_F_NLR_PUSH,\n    MP_F_NLR_POP,\n    MP_F_NATIVE_RAISE,\n    MP_F_IMPORT_NAME,\n    MP_F_IMPORT_FROM,\n    MP_F_IMPORT_ALL,\n    MP_F_NEW_SLICE,\n    MP_F_UNPACK_SEQUENCE,\n    MP_F_UNPACK_EX,\n    MP_F_DELETE_NAME,\n    MP_F_DELETE_GLOBAL,\n    MP_F_NEW_CLOSURE,\n    MP_F_ARG_CHECK_NUM_SIG,\n    MP_F_SETUP_CODE_STATE,\n    MP_F_SMALL_INT_FLOOR_DIVIDE,\n    MP_F_SMALL_INT_MODULO,\n    MP_F_NATIVE_YIELD_FROM,\n    MP_F_SETJMP,\n    MP_F_NUMBER_OF,\n} mp_fun_kind_t;\n\ntypedef struct _mp_fun_table_t {\n    mp_const_obj_t const_none;\n    mp_const_obj_t const_false;\n    mp_const_obj_t const_true;\n    mp_uint_t (*native_from_obj)(mp_obj_t obj, mp_uint_t type);\n    mp_obj_t (*native_to_obj)(mp_uint_t val, mp_uint_t type);\n    mp_obj_dict_t *(*swap_globals)(mp_obj_dict_t * new_globals);\n    mp_obj_t (*load_name)(qstr qst);\n    mp_obj_t (*load_global)(qstr qst);\n    mp_obj_t (*load_build_class)(void);\n    mp_obj_t (*load_attr)(mp_obj_t base, qstr attr);\n    void (*load_method)(mp_obj_t base, qstr attr, mp_obj_t *dest);\n    void (*load_super_method)(qstr attr, mp_obj_t *dest);\n    void (*store_name)(qstr qst, mp_obj_t obj);\n    void (*store_global)(qstr qst, mp_obj_t obj);\n    void (*store_attr)(mp_obj_t base, qstr attr, mp_obj_t val);\n    mp_obj_t (*obj_subscr)(mp_obj_t base, mp_obj_t index, mp_obj_t val);\n    bool (*obj_is_true)(mp_obj_t arg);\n    mp_obj_t (*unary_op)(mp_unary_op_t op, mp_obj_t arg);\n    mp_obj_t (*binary_op)(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs);\n    mp_obj_t (*new_tuple)(size_t n, const mp_obj_t *items);\n    mp_obj_t (*new_list)(size_t n, mp_obj_t *items);\n    mp_obj_t (*new_dict)(size_t n_args);\n    mp_obj_t (*new_set)(size_t n_args, mp_obj_t *items);\n    void (*set_store)(mp_obj_t self_in, mp_obj_t item);\n    mp_obj_t (*list_append)(mp_obj_t self_in, mp_obj_t arg);\n    mp_obj_t (*dict_store)(mp_obj_t self_in, mp_obj_t key, mp_obj_t value);\n    mp_obj_t (*make_function_from_proto_fun)(mp_proto_fun_t proto_fun, const mp_module_context_t *cm, const mp_obj_t *def_args);\n    mp_obj_t (*call_function_n_kw)(mp_obj_t fun_in, size_t n_args_kw, const mp_obj_t *args);\n    mp_obj_t (*call_method_n_kw)(size_t n_args, size_t n_kw, const mp_obj_t *args);\n    mp_obj_t (*call_method_n_kw_var)(bool have_self, size_t n_args_n_kw, const mp_obj_t *args);\n    mp_obj_t (*getiter)(mp_obj_t obj, mp_obj_iter_buf_t *iter);\n    mp_obj_t (*iternext)(mp_obj_iter_buf_t *iter);\n    unsigned int (*nlr_push)(nlr_buf_t *);\n    void (*nlr_pop)(void);\n    void (*raise)(mp_obj_t o);\n    mp_obj_t (*import_name)(qstr name, mp_obj_t fromlist, mp_obj_t level);\n    mp_obj_t (*import_from)(mp_obj_t module, qstr name);\n    void (*import_all)(mp_obj_t module);\n    mp_obj_t (*new_slice)(mp_obj_t start, mp_obj_t stop, mp_obj_t step);\n    void (*unpack_sequence)(mp_obj_t seq, size_t num, mp_obj_t *items);\n    void (*unpack_ex)(mp_obj_t seq, size_t num, mp_obj_t *items);\n    void (*delete_name)(qstr qst);\n    void (*delete_global)(qstr qst);\n    mp_obj_t (*new_closure)(mp_obj_t fun, size_t n_closed_over, const mp_obj_t *closed);\n    void (*arg_check_num_sig)(size_t n_args, size_t n_kw, uint32_t sig);\n    void (*setup_code_state_native)(mp_code_state_native_t *code_state, size_t n_args, size_t n_kw, const mp_obj_t *args);\n    mp_int_t (*small_int_floor_divide)(mp_int_t num, mp_int_t denom);\n    mp_int_t (*small_int_modulo)(mp_int_t dividend, mp_int_t divisor);\n    bool (*yield_from)(mp_obj_t gen, mp_obj_t send_value, mp_obj_t *ret_value);\n    void *setjmp_;\n    \n    void *(*memset_)(void *s, int c, size_t n);\n    void *(*memmove_)(void *dest, const void *src, size_t n);\n    void *(*realloc_)(void *ptr, size_t n_bytes, bool allow_move);\n    int (*printf_)(const mp_print_t *print, const char *fmt, ...);\n    int (*vprintf_)(const mp_print_t *print, const char *fmt, va_list args);\n    #if defined(__GNUC__)\n    NORETURN \n    #endif\n    void (*raise_msg)(const mp_obj_type_t *exc_type, mp_rom_error_text_t msg);\n    const mp_obj_type_t *(*obj_get_type)(mp_const_obj_t o_in);\n    mp_obj_t (*obj_new_str)(const char *data, size_t len);\n    mp_obj_t (*obj_new_bytes)(const byte *data, size_t len);\n    mp_obj_t (*obj_new_bytearray_by_ref)(size_t n, void *items);\n    mp_obj_t (*obj_new_float_from_f)(float f);\n    mp_obj_t (*obj_new_float_from_d)(double d);\n    float (*obj_get_float_to_f)(mp_obj_t o);\n    double (*obj_get_float_to_d)(mp_obj_t o);\n    void (*load_method_maybe)(mp_obj_t base, qstr attr, mp_obj_t *dest);\n    bool (*get_buffer)(mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags);\n    const mp_stream_p_t *(*get_stream_raise)(mp_obj_t self_in, int flags);\n    void (*arg_parse_all)(size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);\n    void (*arg_parse_all_kw_array)(size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals);\n    size_t (*binary_get_size)(char struct_type, char val_type, size_t *palign);\n    mp_obj_t (*binary_get_val_array)(char typecode, void *p, size_t index);\n    void (*binary_set_val_array)(char typecode, void *p, size_t index, mp_obj_t val_in);\n    const mp_print_t *plat_print;\n    \n    \n    const mp_obj_type_t *type_type;\n    const mp_obj_type_t *type_str;\n    const mp_obj_type_t *type_list;\n    const mp_obj_type_t *type_dict;\n    const mp_obj_type_t *type_fun_builtin_0;\n    const mp_obj_type_t *type_fun_builtin_1;\n    const mp_obj_type_t *type_fun_builtin_2;\n    const mp_obj_type_t *type_fun_builtin_3;\n    const mp_obj_type_t *type_fun_builtin_var;\n    const mp_obj_type_t *type_Exception;\n    const mp_obj_fun_builtin_var_t *stream_read_obj;\n    const mp_obj_fun_builtin_var_t *stream_readinto_obj;\n    const mp_obj_fun_builtin_var_t *stream_unbuffered_readline_obj;\n    const mp_obj_fun_builtin_var_t *stream_write_obj;\n} mp_fun_table_t;\n\n#if (MICROPY_EMIT_NATIVE && !MICROPY_DYNAMIC_COMPILER) || MICROPY_ENABLE_DYNRUNTIME\nextern const mp_fun_table_t mp_fun_table;\n#elif MICROPY_EMIT_NATIVE && MICROPY_DYNAMIC_COMPILER\n\n\nextern const int mp_fun_table;\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}