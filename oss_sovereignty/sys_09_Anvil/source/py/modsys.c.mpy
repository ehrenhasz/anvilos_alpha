{
  "module_name": "modsys.c",
  "hash_id": "a370ab483a2a1574cc56d10fef49cc6146c92e329d84b0b0e9aaf4e515b1a780",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modsys.c",
  "human_readable_source": " \n\n#include \"py/builtin.h\"\n#include \"py/objlist.h\"\n#include \"py/objmodule.h\"\n#include \"py/objtuple.h\"\n#include \"py/objstr.h\"\n#include \"py/objint.h\"\n#include \"py/objtype.h\"\n#include \"py/stream.h\"\n#include \"py/smallint.h\"\n#include \"py/runtime.h\"\n#include \"py/persistentcode.h\"\n#include \"extmod/modplatform.h\"\n#include \"genhdr/mpversion.h\"\n\n#if MICROPY_PY_SYS_SETTRACE\n#include \"py/objmodule.h\"\n#include \"py/profile.h\"\n#endif\n\n#if MICROPY_PY_SYS\n\n\nextern struct _mp_dummy_t mp_sys_stdin_obj;\nextern struct _mp_dummy_t mp_sys_stdout_obj;\nextern struct _mp_dummy_t mp_sys_stderr_obj;\n\n#if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\nconst mp_print_t mp_sys_stdout_print = {&mp_sys_stdout_obj, mp_stream_write_adaptor};\n#endif\n\n\nstatic const MP_DEFINE_STR_OBJ(mp_sys_version_obj, \"3.4.0; \" MICROPY_BANNER_NAME_AND_VERSION);\n\n\n\nstatic const mp_rom_obj_tuple_t mp_sys_version_info_obj = {{&mp_type_tuple}, 3, {MP_ROM_INT(3), MP_ROM_INT(4), MP_ROM_INT(0)}};\n\n\n\nstatic const mp_rom_obj_tuple_t mp_sys_implementation_version_info_obj = {\n    {&mp_type_tuple},\n    4,\n    {\n        MP_ROM_INT(MICROPY_VERSION_MAJOR),\n        MP_ROM_INT(MICROPY_VERSION_MINOR),\n        MP_ROM_INT(MICROPY_VERSION_MICRO),\n        #if MICROPY_VERSION_PRERELEASE\n        MP_ROM_QSTR(MP_QSTR_preview),\n        #else\n        MP_ROM_QSTR(MP_QSTR_),\n        #endif\n    }\n};\nstatic const MP_DEFINE_STR_OBJ(mp_sys_implementation_machine_obj, MICROPY_BANNER_MACHINE);\n#define SYS_IMPLEMENTATION_ELEMS_BASE \\\n    MP_ROM_QSTR(MP_QSTR_micropython), \\\n    MP_ROM_PTR(&mp_sys_implementation_version_info_obj), \\\n    MP_ROM_PTR(&mp_sys_implementation_machine_obj)\n\n#if MICROPY_PERSISTENT_CODE_LOAD\n#define SYS_IMPLEMENTATION_ELEMS__MPY \\\n    , MP_ROM_INT(MPY_FILE_HEADER_INT)\n#else\n#define SYS_IMPLEMENTATION_ELEMS__MPY\n#endif\n\n#if MICROPY_PY_ATTRTUPLE\n#if MICROPY_PREVIEW_VERSION_2\n#define SYS_IMPLEMENTATION_ELEMS__V2 \\\n    , MP_ROM_TRUE\n#else\n#define SYS_IMPLEMENTATION_ELEMS__V2\n#endif\n\nstatic const qstr impl_fields[] = {\n    MP_QSTR_name,\n    MP_QSTR_version,\n    MP_QSTR__machine,\n    #if MICROPY_PERSISTENT_CODE_LOAD\n    MP_QSTR__mpy,\n    #endif\n    #if MICROPY_PREVIEW_VERSION_2\n    MP_QSTR__v2,\n    #endif\n};\nstatic MP_DEFINE_ATTRTUPLE(\n    mp_sys_implementation_obj,\n    impl_fields,\n    3 + MICROPY_PERSISTENT_CODE_LOAD + MICROPY_PREVIEW_VERSION_2,\n    SYS_IMPLEMENTATION_ELEMS_BASE\n    SYS_IMPLEMENTATION_ELEMS__MPY\n    SYS_IMPLEMENTATION_ELEMS__V2\n    );\n#else\nstatic const mp_rom_obj_tuple_t mp_sys_implementation_obj = {\n    {&mp_type_tuple},\n    3 + MICROPY_PERSISTENT_CODE_LOAD,\n    \n    \n    \n    \n    \n    {\n        SYS_IMPLEMENTATION_ELEMS_BASE\n                                SYS_IMPLEMENTATION_ELEMS__MPY\n    }\n};\n#endif\n\n#undef I\n\n#ifdef MICROPY_PY_SYS_PLATFORM\n\nstatic const MP_DEFINE_STR_OBJ(mp_sys_platform_obj, MICROPY_PY_SYS_PLATFORM);\n#endif\n\n#ifdef MICROPY_PY_SYS_EXECUTABLE\n\n\nMP_DEFINE_STR_OBJ(mp_sys_executable_obj, \"\");\n#endif\n\n#if MICROPY_PY_SYS_INTERN\nMP_DEFINE_CONST_FUN_OBJ_1(mp_sys_intern_obj, mp_obj_str_intern_checked);\n#endif\n\n\nstatic mp_obj_t mp_sys_exit(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 0) {\n        mp_raise_type(&mp_type_SystemExit);\n    } else {\n        mp_raise_type_arg(&mp_type_SystemExit, args[0]);\n    }\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_sys_exit_obj, 0, 1, mp_sys_exit);\n\nstatic mp_obj_t mp_sys_print_exception(size_t n_args, const mp_obj_t *args) {\n    #if MICROPY_PY_IO && MICROPY_PY_SYS_STDFILES\n    void *stream_obj = &mp_sys_stdout_obj;\n    if (n_args > 1) {\n        mp_get_stream_raise(args[1], MP_STREAM_OP_WRITE);\n        stream_obj = MP_OBJ_TO_PTR(args[1]);\n    }\n\n    mp_print_t print = {stream_obj, mp_stream_write_adaptor};\n    mp_obj_print_exception(&print, args[0]);\n    #else\n    (void)n_args;\n    mp_obj_print_exception(&mp_plat_print, args[0]);\n    #endif\n\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_sys_print_exception_obj, 1, 2, mp_sys_print_exception);\n\n#if MICROPY_PY_SYS_EXC_INFO\nstatic mp_obj_t mp_sys_exc_info(void) {\n    mp_obj_t cur_exc = MP_OBJ_FROM_PTR(MP_STATE_VM(cur_exception));\n    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(mp_obj_new_tuple(3, NULL));\n\n    if (cur_exc == MP_OBJ_NULL) {\n        t->items[0] = mp_const_none;\n        t->items[1] = mp_const_none;\n        t->items[2] = mp_const_none;\n        return MP_OBJ_FROM_PTR(t);\n    }\n\n    t->items[0] = MP_OBJ_FROM_PTR(mp_obj_get_type(cur_exc));\n    t->items[1] = cur_exc;\n    t->items[2] = mp_const_none;\n    return MP_OBJ_FROM_PTR(t);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(mp_sys_exc_info_obj, mp_sys_exc_info);\n#endif\n\n#if MICROPY_PY_SYS_GETSIZEOF\nstatic mp_obj_t mp_sys_getsizeof(mp_obj_t obj) {\n    return mp_unary_op(MP_UNARY_OP_SIZEOF, obj);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_sys_getsizeof_obj, mp_sys_getsizeof);\n#endif\n\n#if MICROPY_PY_SYS_ATEXIT\n\nstatic mp_obj_t mp_sys_atexit(mp_obj_t obj) {\n    mp_obj_t old = MP_STATE_VM(sys_exitfunc);\n    MP_STATE_VM(sys_exitfunc) = obj;\n    return old;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(mp_sys_atexit_obj, mp_sys_atexit);\n#endif\n\n#if MICROPY_PY_SYS_SETTRACE\n\nstatic mp_obj_t mp_sys_settrace(mp_obj_t obj) {\n    return mp_prof_settrace(obj);\n}\nMP_DEFINE_CONST_FUN_OBJ_1(mp_sys_settrace_obj, mp_sys_settrace);\n#endif \n\n#if MICROPY_PY_SYS_PATH && !MICROPY_PY_SYS_ATTR_DELEGATION\n#error \"MICROPY_PY_SYS_PATH requires MICROPY_PY_SYS_ATTR_DELEGATION\"\n#endif\n\n#if MICROPY_PY_SYS_PS1_PS2 && !MICROPY_PY_SYS_ATTR_DELEGATION\n#error \"MICROPY_PY_SYS_PS1_PS2 requires MICROPY_PY_SYS_ATTR_DELEGATION\"\n#endif\n\n#if MICROPY_PY_SYS_TRACEBACKLIMIT && !MICROPY_PY_SYS_ATTR_DELEGATION\n#error \"MICROPY_PY_SYS_TRACEBACKLIMIT requires MICROPY_PY_SYS_ATTR_DELEGATION\"\n#endif\n\n#if MICROPY_PY_SYS_ATTR_DELEGATION && !MICROPY_MODULE_ATTR_DELEGATION\n#error \"MICROPY_PY_SYS_ATTR_DELEGATION requires MICROPY_MODULE_ATTR_DELEGATION\"\n#endif\n\n#if MICROPY_PY_SYS_ATTR_DELEGATION\n\nstatic const uint16_t sys_mutable_keys[] = {\n    #if MICROPY_PY_SYS_PATH\n    \n    \n    MP_QSTR_path,\n    #endif\n    #if MICROPY_PY_SYS_PS1_PS2\n    MP_QSTR_ps1,\n    MP_QSTR_ps2,\n    #endif\n    #if MICROPY_PY_SYS_TRACEBACKLIMIT\n    MP_QSTR_tracebacklimit,\n    #endif\n    MP_QSTRnull,\n};\n\nvoid mp_module_sys_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) {\n    MP_STATIC_ASSERT(MP_ARRAY_SIZE(sys_mutable_keys) == MP_SYS_MUTABLE_NUM + 1);\n    MP_STATIC_ASSERT(MP_ARRAY_SIZE(MP_STATE_VM(sys_mutable)) == MP_SYS_MUTABLE_NUM);\n    mp_module_generic_attr(attr, dest, sys_mutable_keys, MP_STATE_VM(sys_mutable));\n}\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_sys_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_sys) },\n\n    #if MICROPY_PY_SYS_ARGV\n    { MP_ROM_QSTR(MP_QSTR_argv), MP_ROM_PTR(&MP_STATE_VM(mp_sys_argv_obj)) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_version), MP_ROM_PTR(&mp_sys_version_obj) },\n    { MP_ROM_QSTR(MP_QSTR_version_info), MP_ROM_PTR(&mp_sys_version_info_obj) },\n    { MP_ROM_QSTR(MP_QSTR_implementation), MP_ROM_PTR(&mp_sys_implementation_obj) },\n    #ifdef MICROPY_PY_SYS_PLATFORM\n    { MP_ROM_QSTR(MP_QSTR_platform), MP_ROM_PTR(&mp_sys_platform_obj) },\n    #endif\n    #if MP_ENDIANNESS_LITTLE\n    { MP_ROM_QSTR(MP_QSTR_byteorder), MP_ROM_QSTR(MP_QSTR_little) },\n    #else\n    { MP_ROM_QSTR(MP_QSTR_byteorder), MP_ROM_QSTR(MP_QSTR_big) },\n    #endif\n\n    #if MICROPY_PY_SYS_MAXSIZE\n    #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_NONE\n    \n    \n    \n    \n    \n    { MP_ROM_QSTR(MP_QSTR_maxsize), MP_ROM_INT(MP_SMALL_INT_MAX) },\n    #else\n    { MP_ROM_QSTR(MP_QSTR_maxsize), MP_ROM_PTR(&mp_sys_maxsize_obj) },\n    #endif\n    #endif\n\n    #if MICROPY_PY_SYS_INTERN\n    { MP_ROM_QSTR(MP_QSTR_intern), MP_ROM_PTR(&mp_sys_intern_obj) },\n    #endif\n\n    #if MICROPY_PY_SYS_EXIT\n    { MP_ROM_QSTR(MP_QSTR_exit), MP_ROM_PTR(&mp_sys_exit_obj) },\n    #endif\n\n    #if MICROPY_PY_SYS_SETTRACE\n    { MP_ROM_QSTR(MP_QSTR_settrace), MP_ROM_PTR(&mp_sys_settrace_obj) },\n    #endif\n\n    #if MICROPY_PY_SYS_STDFILES\n    { MP_ROM_QSTR(MP_QSTR_stdin), MP_ROM_PTR(&mp_sys_stdin_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stdout), MP_ROM_PTR(&mp_sys_stdout_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stderr), MP_ROM_PTR(&mp_sys_stderr_obj) },\n    #endif\n\n    #if MICROPY_PY_SYS_MODULES\n    { MP_ROM_QSTR(MP_QSTR_modules), MP_ROM_PTR(&MP_STATE_VM(mp_loaded_modules_dict)) },\n    #endif\n    #if MICROPY_PY_SYS_EXC_INFO\n    { MP_ROM_QSTR(MP_QSTR_exc_info), MP_ROM_PTR(&mp_sys_exc_info_obj) },\n    #endif\n    #if MICROPY_PY_SYS_GETSIZEOF\n    { MP_ROM_QSTR(MP_QSTR_getsizeof), MP_ROM_PTR(&mp_sys_getsizeof_obj) },\n    #endif\n\n    #if MICROPY_PY_SYS_EXECUTABLE\n    { MP_ROM_QSTR(MP_QSTR_executable), MP_ROM_PTR(&mp_sys_executable_obj) },\n    #endif\n\n     \n\n    { MP_ROM_QSTR(MP_QSTR_print_exception), MP_ROM_PTR(&mp_sys_print_exception_obj) },\n    #if MICROPY_PY_SYS_ATEXIT\n    { MP_ROM_QSTR(MP_QSTR_atexit), MP_ROM_PTR(&mp_sys_atexit_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_sys_globals, mp_module_sys_globals_table);\n\nconst mp_obj_module_t mp_module_sys = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_sys_globals,\n};\n\n\n\n\nMP_REGISTER_MODULE(MP_QSTR_sys, mp_module_sys);\n\n#if MICROPY_PY_SYS_ARGV\n\n\nMP_REGISTER_ROOT_POINTER(mp_obj_list_t mp_sys_argv_obj);\n#endif\n\n#if MICROPY_PY_SYS_EXC_INFO\n\nMP_REGISTER_ROOT_POINTER(mp_obj_base_t * cur_exception);\n#endif\n\n#if MICROPY_PY_SYS_ATEXIT\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t sys_exitfunc);\n#endif\n\n#if MICROPY_PY_SYS_ATTR_DELEGATION\n\nMP_REGISTER_ROOT_POINTER(mp_obj_t sys_mutable[MP_SYS_MUTABLE_NUM]);\nMP_REGISTER_MODULE_DELEGATION(mp_module_sys, mp_module_sys_attr);\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}