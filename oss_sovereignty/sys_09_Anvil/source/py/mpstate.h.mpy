{
  "module_name": "mpstate.h",
  "hash_id": "a9abe39882482df5a73b0f30d2c4af15cb6fbdc948054e58088d456bd7cdd55e",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/mpstate.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_MPSTATE_H\n#define MICROPY_INCLUDED_PY_MPSTATE_H\n\n#include <stdint.h>\n\n#include \"py/mpconfig.h\"\n#include \"py/mpthread.h\"\n#include \"py/misc.h\"\n#include \"py/nlr.h\"\n#include \"py/obj.h\"\n#include \"py/objlist.h\"\n#include \"py/objexcept.h\"\n\n\n\n\n\n#if MICROPY_PY_SYS_ATTR_DELEGATION\n\nenum {\n    #if MICROPY_PY_SYS_PATH\n    MP_SYS_MUTABLE_PATH,\n    #endif\n    #if MICROPY_PY_SYS_PS1_PS2\n    MP_SYS_MUTABLE_PS1,\n    MP_SYS_MUTABLE_PS2,\n    #endif\n    #if MICROPY_PY_SYS_TRACEBACKLIMIT\n    MP_SYS_MUTABLE_TRACEBACKLIMIT,\n    #endif\n    MP_SYS_MUTABLE_NUM,\n};\n#endif \n\n\n#if MICROPY_DYNAMIC_COMPILER\ntypedef struct mp_dynamic_compiler_t {\n    uint8_t small_int_bits; \n    uint8_t native_arch;\n    uint8_t nlr_buf_num_regs;\n} mp_dynamic_compiler_t;\nextern mp_dynamic_compiler_t mp_dynamic_compiler;\n#endif\n\n\n#define MP_SCHED_IDLE (1)\n#define MP_SCHED_LOCKED (-1)\n#define MP_SCHED_PENDING (0) \n\ntypedef struct _mp_sched_item_t {\n    mp_obj_t func;\n    mp_obj_t arg;\n} mp_sched_item_t;\n\n\n\ntypedef struct _mp_state_mem_area_t {\n    #if MICROPY_GC_SPLIT_HEAP\n    struct _mp_state_mem_area_t *next;\n    #endif\n\n    byte *gc_alloc_table_start;\n    size_t gc_alloc_table_byte_len;\n    #if MICROPY_ENABLE_FINALISER\n    byte *gc_finaliser_table_start;\n    #endif\n    byte *gc_pool_start;\n    byte *gc_pool_end;\n\n    size_t gc_last_free_atb_index;\n    size_t gc_last_used_block; \n} mp_state_mem_area_t;\n\n\ntypedef struct _mp_state_mem_t {\n    #if MICROPY_MEM_STATS\n    size_t total_bytes_allocated;\n    size_t current_bytes_allocated;\n    size_t peak_bytes_allocated;\n    #endif\n\n    mp_state_mem_area_t area;\n\n    int gc_stack_overflow;\n    MICROPY_GC_STACK_ENTRY_TYPE gc_block_stack[MICROPY_ALLOC_GC_STACK_SIZE];\n    #if MICROPY_GC_SPLIT_HEAP\n    \n    mp_state_mem_area_t *gc_area_stack[MICROPY_ALLOC_GC_STACK_SIZE];\n    #endif\n\n    \n    \n    \n    uint16_t gc_auto_collect_enabled;\n\n    #if MICROPY_GC_ALLOC_THRESHOLD\n    size_t gc_alloc_amount;\n    size_t gc_alloc_threshold;\n    #endif\n\n    #if MICROPY_GC_SPLIT_HEAP\n    mp_state_mem_area_t *gc_last_free_area;\n    #endif\n\n    #if MICROPY_PY_GC_COLLECT_RETVAL\n    size_t gc_collected;\n    #endif\n\n    #if MICROPY_PY_THREAD && !MICROPY_PY_THREAD_GIL\n    \n    mp_thread_mutex_t gc_mutex;\n    #endif\n} mp_state_mem_t;\n\n\n\ntypedef struct _mp_state_vm_t {\n    \n    \n    \n    \n    \n    \n\n    qstr_pool_t *last_pool;\n\n    #if MICROPY_TRACKED_ALLOC\n    struct _m_tracked_node_t *m_tracked_head;\n    #endif\n\n    \n    mp_obj_exception_t mp_emergency_exception_obj;\n\n    \n    #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n    #if MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE > 0\n    \n    mp_obj_t mp_emergency_exception_buf[MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE / sizeof(mp_obj_t)];\n    #else\n    \n    byte *mp_emergency_exception_buf;\n    #endif\n    #endif\n\n    #if MICROPY_KBD_EXCEPTION\n    \n    mp_obj_exception_t mp_kbd_exception;\n    #endif\n\n    \n    mp_obj_dict_t mp_loaded_modules_dict;\n\n    \n    mp_obj_dict_t dict_main;\n\n    \n    #if MICROPY_CAN_OVERRIDE_BUILTINS\n    mp_obj_dict_t *mp_module_builtins_override_dict;\n    #endif\n\n    \n    #ifndef NO_QSTR\n    \n    \n    #include \"genhdr/root_pointers.h\"\n    #endif\n\n    \n    \n    \n\n    \n    \n    char *qstr_last_chunk;\n    size_t qstr_last_alloc;\n    size_t qstr_last_used;\n\n    #if MICROPY_PY_THREAD && !MICROPY_PY_THREAD_GIL\n    \n    mp_thread_mutex_t qstr_mutex;\n    #endif\n\n    #if MICROPY_ENABLE_COMPILER\n    mp_uint_t mp_optimise_value;\n    #if MICROPY_EMIT_NATIVE\n    uint8_t default_emit_opt; \n    #endif\n    #endif\n\n    \n    #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF && MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE == 0\n    mp_int_t mp_emergency_exception_buf_size;\n    #endif\n\n    #if MICROPY_ENABLE_SCHEDULER\n    volatile int16_t sched_state;\n\n    #if MICROPY_SCHEDULER_STATIC_NODES\n    \n    \n    \n    struct _mp_sched_node_t *sched_head;\n    struct _mp_sched_node_t *sched_tail;\n    #endif\n\n    \n    uint8_t sched_len;\n    uint8_t sched_idx;\n    #endif\n\n    #if MICROPY_ENABLE_VM_ABORT\n    bool vm_abort;\n    nlr_buf_t *nlr_abort;\n    #endif\n\n    #if MICROPY_PY_THREAD_GIL\n    \n    mp_thread_mutex_t gil_mutex;\n    #endif\n\n    #if MICROPY_OPT_MAP_LOOKUP_CACHE\n    \n    uint8_t map_lookup_cache[MICROPY_OPT_MAP_LOOKUP_CACHE_SIZE];\n    #endif\n} mp_state_vm_t;\n\n\n\n\n\ntypedef struct _mp_state_thread_t {\n    \n    char *stack_top;\n\n    #if MICROPY_STACK_CHECK\n    size_t stack_limit;\n    #endif\n\n    #if MICROPY_ENABLE_PYSTACK\n    uint8_t *pystack_start;\n    uint8_t *pystack_end;\n    uint8_t *pystack_cur;\n    #endif\n\n    \n    uint16_t gc_lock_depth;\n\n    \n    \n    \n    \n    \n\n    mp_obj_dict_t *dict_locals;\n    mp_obj_dict_t *dict_globals;\n\n    nlr_buf_t *nlr_top;\n    nlr_jump_callback_node_t *nlr_jump_callback_top;\n\n    \n    volatile mp_obj_t mp_pending_exception;\n\n    \n    mp_obj_t stop_iteration_arg;\n\n    #if MICROPY_PY_SYS_SETTRACE\n    mp_obj_t prof_trace_callback;\n    bool prof_callback_is_executing;\n    struct _mp_code_state_t *current_code_state;\n    #endif\n} mp_state_thread_t;\n\n\n\ntypedef struct _mp_state_ctx_t {\n    mp_state_thread_t thread;\n    mp_state_vm_t vm;\n    mp_state_mem_t mem;\n} mp_state_ctx_t;\n\nextern mp_state_ctx_t mp_state_ctx;\n\n#define MP_STATE_VM(x) (mp_state_ctx.vm.x)\n#define MP_STATE_MEM(x) (mp_state_ctx.mem.x)\n#define MP_STATE_MAIN_THREAD(x) (mp_state_ctx.thread.x)\n\n#if MICROPY_PY_THREAD\n#define MP_STATE_THREAD(x) (mp_thread_get_state()->x)\n#define mp_thread_is_main_thread() (mp_thread_get_state() == &mp_state_ctx.thread)\n#else\n#define MP_STATE_THREAD(x)  MP_STATE_MAIN_THREAD(x)\n#define mp_thread_is_main_thread() (true)\n#endif\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}