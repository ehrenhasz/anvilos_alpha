{
  "module_name": "lexer.h",
  "hash_id": "71f856865c812d67916fecf38449b09c1f761cf1fb492107943df0577f47814e",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/lexer.h",
  "human_readable_source": " \n#ifndef MICROPY_INCLUDED_PY_LEXER_H\n#define MICROPY_INCLUDED_PY_LEXER_H\n\n#include <stdint.h>\n\n#include \"py/mpconfig.h\"\n#include \"py/qstr.h\"\n#include \"py/reader.h\"\n\n \n\ntypedef enum _mp_token_kind_t {\n    MP_TOKEN_END,\n\n    MP_TOKEN_INVALID,\n    MP_TOKEN_DEDENT_MISMATCH,\n    MP_TOKEN_LONELY_STRING_OPEN,\n    #if MICROPY_PY_FSTRINGS\n    MP_TOKEN_MALFORMED_FSTRING,\n    MP_TOKEN_FSTRING_RAW,\n    #endif\n\n    MP_TOKEN_NEWLINE,\n    MP_TOKEN_INDENT,\n    MP_TOKEN_DEDENT,\n\n    MP_TOKEN_NAME,\n    MP_TOKEN_INTEGER,\n    MP_TOKEN_FLOAT_OR_IMAG,\n    MP_TOKEN_STRING,\n    MP_TOKEN_BYTES,\n\n    MP_TOKEN_ELLIPSIS,\n\n    MP_TOKEN_KW_FALSE,\n    MP_TOKEN_KW_NONE,\n    MP_TOKEN_KW_TRUE,\n    MP_TOKEN_KW___DEBUG__,\n    MP_TOKEN_KW_AND,\n    MP_TOKEN_KW_AS,\n    MP_TOKEN_KW_ASSERT,\n    #if MICROPY_PY_ASYNC_AWAIT\n    MP_TOKEN_KW_ASYNC,\n    MP_TOKEN_KW_AWAIT,\n    #endif\n    MP_TOKEN_KW_BREAK,\n    MP_TOKEN_KW_CLASS,\n    MP_TOKEN_KW_CONTINUE,\n    MP_TOKEN_KW_DEF,\n    MP_TOKEN_KW_DEL,\n    MP_TOKEN_KW_ELIF,\n    MP_TOKEN_KW_ELSE,\n    MP_TOKEN_KW_EXCEPT,\n    MP_TOKEN_KW_FINALLY,\n    MP_TOKEN_KW_FOR,\n    MP_TOKEN_KW_FROM,\n    MP_TOKEN_KW_GLOBAL,\n    MP_TOKEN_KW_IF,\n    MP_TOKEN_KW_IMPORT,\n    MP_TOKEN_KW_IN,\n    MP_TOKEN_KW_IS,\n    MP_TOKEN_KW_LAMBDA,\n    MP_TOKEN_KW_NONLOCAL,\n    MP_TOKEN_KW_NOT,\n    MP_TOKEN_KW_OR,\n    MP_TOKEN_KW_PASS,\n    MP_TOKEN_KW_RAISE,\n    MP_TOKEN_KW_RETURN,\n    MP_TOKEN_KW_TRY,\n    MP_TOKEN_KW_WHILE,\n    MP_TOKEN_KW_WITH,\n    MP_TOKEN_KW_YIELD,\n\n    MP_TOKEN_OP_ASSIGN,\n    MP_TOKEN_OP_TILDE,\n\n    \n    MP_TOKEN_OP_LESS,\n    MP_TOKEN_OP_MORE,\n    MP_TOKEN_OP_DBL_EQUAL,\n    MP_TOKEN_OP_LESS_EQUAL,\n    MP_TOKEN_OP_MORE_EQUAL,\n    MP_TOKEN_OP_NOT_EQUAL,\n\n    \n    MP_TOKEN_OP_PIPE,\n    MP_TOKEN_OP_CARET,\n    MP_TOKEN_OP_AMPERSAND,\n    MP_TOKEN_OP_DBL_LESS,\n    MP_TOKEN_OP_DBL_MORE,\n    MP_TOKEN_OP_PLUS,\n    MP_TOKEN_OP_MINUS,\n    MP_TOKEN_OP_STAR,\n    MP_TOKEN_OP_AT,\n    MP_TOKEN_OP_DBL_SLASH,\n    MP_TOKEN_OP_SLASH,\n    MP_TOKEN_OP_PERCENT,\n    MP_TOKEN_OP_DBL_STAR,\n\n    \n    MP_TOKEN_DEL_PIPE_EQUAL,\n    MP_TOKEN_DEL_CARET_EQUAL,\n    MP_TOKEN_DEL_AMPERSAND_EQUAL,\n    MP_TOKEN_DEL_DBL_LESS_EQUAL,\n    MP_TOKEN_DEL_DBL_MORE_EQUAL,\n    MP_TOKEN_DEL_PLUS_EQUAL,\n    MP_TOKEN_DEL_MINUS_EQUAL,\n    MP_TOKEN_DEL_STAR_EQUAL,\n    MP_TOKEN_DEL_AT_EQUAL,\n    MP_TOKEN_DEL_DBL_SLASH_EQUAL,\n    MP_TOKEN_DEL_SLASH_EQUAL,\n    MP_TOKEN_DEL_PERCENT_EQUAL,\n    MP_TOKEN_DEL_DBL_STAR_EQUAL,\n\n    MP_TOKEN_DEL_PAREN_OPEN,\n    MP_TOKEN_DEL_PAREN_CLOSE,\n    MP_TOKEN_DEL_BRACKET_OPEN,\n    MP_TOKEN_DEL_BRACKET_CLOSE,\n    MP_TOKEN_DEL_BRACE_OPEN,\n    MP_TOKEN_DEL_BRACE_CLOSE,\n    MP_TOKEN_DEL_COMMA,\n    MP_TOKEN_DEL_COLON,\n    MP_TOKEN_DEL_PERIOD,\n    MP_TOKEN_DEL_SEMICOLON,\n    MP_TOKEN_DEL_EQUAL,\n    MP_TOKEN_DEL_MINUS_MORE,\n} mp_token_kind_t;\n\n\n\ntypedef struct _mp_lexer_t {\n    qstr source_name;           \n    mp_reader_t reader;         \n\n    unichar chr0, chr1, chr2;   \n    #if MICROPY_PY_FSTRINGS\n    unichar chr0_saved, chr1_saved, chr2_saved; \n    #endif\n\n    size_t line;                \n    size_t column;              \n\n    mp_int_t emit_dent;             \n    mp_int_t nested_bracket_level;  \n\n    size_t alloc_indent_level;\n    size_t num_indent_level;\n    uint16_t *indent_level;\n\n    size_t tok_line;            \n    size_t tok_column;          \n    mp_token_kind_t tok_kind;   \n    vstr_t vstr;                \n    #if MICROPY_PY_FSTRINGS\n    vstr_t fstring_args;        \n    size_t fstring_args_idx;    \n    #endif\n} mp_lexer_t;\n\nmp_lexer_t *mp_lexer_new(qstr src_name, mp_reader_t reader);\nmp_lexer_t *mp_lexer_new_from_str_len(qstr src_name, const char *str, size_t len, size_t free_len);\n\n\n\nmp_lexer_t *mp_lexer_new_from_file(qstr filename);\n\n#if MICROPY_HELPER_LEXER_UNIX\nmp_lexer_t *mp_lexer_new_from_fd(qstr filename, int fd, bool close_fd);\n#endif\n\nvoid mp_lexer_free(mp_lexer_t *lex);\nvoid mp_lexer_to_next(mp_lexer_t *lex);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}