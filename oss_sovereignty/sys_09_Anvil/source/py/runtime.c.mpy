{
  "module_name": "runtime.c",
  "hash_id": "d394ae54d751786420f1eab4d83c7239975a1df59cd27d5a2cc9242c86939a00",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/runtime.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"py/parsenum.h\"\n#include \"py/compile.h\"\n#include \"py/objstr.h\"\n#include \"py/objtuple.h\"\n#include \"py/objlist.h\"\n#include \"py/objtype.h\"\n#include \"py/objmodule.h\"\n#include \"py/objgenerator.h\"\n#include \"py/smallint.h\"\n#include \"py/stream.h\"\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/stackctrl.h\"\n#include \"py/gc.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define DEBUG_printf DEBUG_printf\n#define DEBUG_OP_printf(...) DEBUG_printf(__VA_ARGS__)\n#else \n#define DEBUG_printf(...) (void)0\n#define DEBUG_OP_printf(...) (void)0\n#endif\n\nconst mp_obj_module_t mp_module___main__ = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&MP_STATE_VM(dict_main),\n};\n\nMP_REGISTER_MODULE(MP_QSTR___main__, mp_module___main__);\n\n#define TYPE_HAS_ITERNEXT(type) (type->flags & (MP_TYPE_FLAG_ITER_IS_ITERNEXT | MP_TYPE_FLAG_ITER_IS_CUSTOM | MP_TYPE_FLAG_ITER_IS_STREAM))\n\nvoid mp_init(void) {\n    qstr_init();\n\n    \n    MP_STATE_THREAD(mp_pending_exception) = MP_OBJ_NULL;\n    #if MICROPY_ENABLE_SCHEDULER\n    \n    MP_STATE_VM(sched_state) = MP_SCHED_IDLE;\n    #if MICROPY_SCHEDULER_STATIC_NODES\n    if (MP_STATE_VM(sched_head) != NULL) {\n        \n        MP_STATE_VM(sched_state) = MP_SCHED_PENDING;\n    }\n    #endif\n    MP_STATE_VM(sched_idx) = 0;\n    MP_STATE_VM(sched_len) = 0;\n    #endif\n\n    #if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF\n    mp_init_emergency_exception_buf();\n    #endif\n\n    #if MICROPY_KBD_EXCEPTION\n    \n    MP_STATE_VM(mp_kbd_exception).base.type = &mp_type_KeyboardInterrupt;\n    MP_STATE_VM(mp_kbd_exception).traceback_alloc = 0;\n    MP_STATE_VM(mp_kbd_exception).traceback_len = 0;\n    MP_STATE_VM(mp_kbd_exception).traceback_data = NULL;\n    MP_STATE_VM(mp_kbd_exception).args = (mp_obj_tuple_t *)&mp_const_empty_tuple_obj;\n    #endif\n\n    #if MICROPY_ENABLE_COMPILER\n    \n    MP_STATE_VM(mp_optimise_value) = 0;\n    #if MICROPY_EMIT_NATIVE\n    MP_STATE_VM(default_emit_opt) = MP_EMIT_OPT_NONE;\n    #endif\n    #endif\n\n    \n    mp_obj_dict_init(&MP_STATE_VM(mp_loaded_modules_dict), MICROPY_LOADED_MODULES_DICT_SIZE);\n\n    \n    mp_obj_dict_init(&MP_STATE_VM(dict_main), 1);\n    mp_obj_dict_store(MP_OBJ_FROM_PTR(&MP_STATE_VM(dict_main)), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR___main__));\n\n    \n    mp_locals_set(&MP_STATE_VM(dict_main));\n    mp_globals_set(&MP_STATE_VM(dict_main));\n\n    #if MICROPY_CAN_OVERRIDE_BUILTINS\n    \n    MP_STATE_VM(mp_module_builtins_override_dict) = NULL;\n    #endif\n\n    #if MICROPY_PERSISTENT_CODE_TRACK_RELOC_CODE\n    MP_STATE_VM(track_reloc_code_list) = MP_OBJ_NULL;\n    #endif\n\n    #if MICROPY_PY_OS_DUPTERM\n    for (size_t i = 0; i < MICROPY_PY_OS_DUPTERM; ++i) {\n        MP_STATE_VM(dupterm_objs[i]) = MP_OBJ_NULL;\n    }\n    #endif\n\n    #if MICROPY_VFS\n    \n    MP_STATE_VM(vfs_cur) = NULL;\n    MP_STATE_VM(vfs_mount_table) = NULL;\n    #endif\n\n    #if MICROPY_PY_SYS_PATH_ARGV_DEFAULTS\n    #if MICROPY_PY_SYS_PATH\n    mp_sys_path = mp_obj_new_list(0, NULL);\n    mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR_)); \n    #if MICROPY_MODULE_FROZEN\n    mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR__dot_frozen));\n    #endif\n    #endif\n    #if MICROPY_PY_SYS_ARGV\n    mp_obj_list_init(MP_OBJ_TO_PTR(mp_sys_argv), 0);\n    #endif\n    #endif \n\n    #if MICROPY_PY_SYS_ATEXIT\n    MP_STATE_VM(sys_exitfunc) = mp_const_none;\n    #endif\n\n    #if MICROPY_PY_SYS_PS1_PS2\n    MP_STATE_VM(sys_mutable[MP_SYS_MUTABLE_PS1]) = MP_OBJ_NEW_QSTR(MP_QSTR__gt__gt__gt__space_);\n    MP_STATE_VM(sys_mutable[MP_SYS_MUTABLE_PS2]) = MP_OBJ_NEW_QSTR(MP_QSTR__dot__dot__dot__space_);\n    #endif\n\n    #if MICROPY_PY_SYS_SETTRACE\n    MP_STATE_THREAD(prof_trace_callback) = MP_OBJ_NULL;\n    MP_STATE_THREAD(prof_callback_is_executing) = false;\n    MP_STATE_THREAD(current_code_state) = NULL;\n    #endif\n\n    #if MICROPY_PY_SYS_TRACEBACKLIMIT\n    MP_STATE_VM(sys_mutable[MP_SYS_MUTABLE_TRACEBACKLIMIT]) = MP_OBJ_NEW_SMALL_INT(1000);\n    #endif\n\n    #if MICROPY_PY_BLUETOOTH\n    MP_STATE_VM(bluetooth) = MP_OBJ_NULL;\n    #endif\n\n    #if MICROPY_HW_ENABLE_USB_RUNTIME_DEVICE\n    MP_STATE_VM(usbd) = MP_OBJ_NULL;\n    #endif\n\n    #if MICROPY_PY_THREAD_GIL\n    mp_thread_mutex_init(&MP_STATE_VM(gil_mutex));\n    #endif\n\n    \n    #ifdef MICROPY_PORT_INIT_FUNC\n    MICROPY_PORT_INIT_FUNC;\n    #endif\n\n    MP_THREAD_GIL_ENTER();\n}\n\nvoid mp_deinit(void) {\n    MP_THREAD_GIL_EXIT();\n\n    \n    #ifdef MICROPY_PORT_DEINIT_FUNC\n    MICROPY_PORT_DEINIT_FUNC;\n    #endif\n}\n\nvoid mp_globals_locals_set_from_nlr_jump_callback(void *ctx_in) {\n    nlr_jump_callback_node_globals_locals_t *ctx = ctx_in;\n    mp_globals_set(ctx->globals);\n    mp_locals_set(ctx->locals);\n}\n\nvoid mp_call_function_1_from_nlr_jump_callback(void *ctx_in) {\n    nlr_jump_callback_node_call_function_1_t *ctx = ctx_in;\n    ctx->func(ctx->arg);\n}\n\nmp_obj_t MICROPY_WRAP_MP_LOAD_NAME(mp_load_name)(qstr qst) {\n    \n    DEBUG_OP_printf(\"load name %s\\n\", qstr_str(qst));\n    \n    if (mp_locals_get() != mp_globals_get()) {\n        mp_map_elem_t *elem = mp_map_lookup(&mp_locals_get()->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);\n        if (elem != NULL) {\n            return elem->value;\n        }\n    }\n    return mp_load_global(qst);\n}\n\nmp_obj_t MICROPY_WRAP_MP_LOAD_GLOBAL(mp_load_global)(qstr qst) {\n    \n    DEBUG_OP_printf(\"load global %s\\n\", qstr_str(qst));\n    mp_map_elem_t *elem = mp_map_lookup(&mp_globals_get()->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);\n    if (elem == NULL) {\n        #if MICROPY_CAN_OVERRIDE_BUILTINS\n        if (MP_STATE_VM(mp_module_builtins_override_dict) != NULL) {\n            \n            elem = mp_map_lookup(&MP_STATE_VM(mp_module_builtins_override_dict)->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);\n            if (elem != NULL) {\n                return elem->value;\n            }\n        }\n        #endif\n        elem = mp_map_lookup((mp_map_t *)&mp_module_builtins_globals.map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);\n        if (elem == NULL) {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_raise_msg(&mp_type_NameError, MP_ERROR_TEXT(\"name not defined\"));\n            #else\n            mp_raise_msg_varg(&mp_type_NameError, MP_ERROR_TEXT(\"name '%q' isn't defined\"), qst);\n            #endif\n        }\n    }\n    return elem->value;\n}\n\nmp_obj_t mp_load_build_class(void) {\n    DEBUG_OP_printf(\"load_build_class\\n\");\n    #if MICROPY_CAN_OVERRIDE_BUILTINS\n    if (MP_STATE_VM(mp_module_builtins_override_dict) != NULL) {\n        \n        mp_map_elem_t *elem = mp_map_lookup(&MP_STATE_VM(mp_module_builtins_override_dict)->map, MP_OBJ_NEW_QSTR(MP_QSTR___build_class__), MP_MAP_LOOKUP);\n        if (elem != NULL) {\n            return elem->value;\n        }\n    }\n    #endif\n    return MP_OBJ_FROM_PTR(&mp_builtin___build_class___obj);\n}\n\nvoid mp_store_name(qstr qst, mp_obj_t obj) {\n    DEBUG_OP_printf(\"store name %s <- %p\\n\", qstr_str(qst), obj);\n    mp_obj_dict_store(MP_OBJ_FROM_PTR(mp_locals_get()), MP_OBJ_NEW_QSTR(qst), obj);\n}\n\nvoid mp_delete_name(qstr qst) {\n    DEBUG_OP_printf(\"delete name %s\\n\", qstr_str(qst));\n    \n    mp_obj_dict_delete(MP_OBJ_FROM_PTR(mp_locals_get()), MP_OBJ_NEW_QSTR(qst));\n}\n\nvoid mp_store_global(qstr qst, mp_obj_t obj) {\n    DEBUG_OP_printf(\"store global %s <- %p\\n\", qstr_str(qst), obj);\n    mp_obj_dict_store(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(qst), obj);\n}\n\nvoid mp_delete_global(qstr qst) {\n    DEBUG_OP_printf(\"delete global %s\\n\", qstr_str(qst));\n    \n    mp_obj_dict_delete(MP_OBJ_FROM_PTR(mp_globals_get()), MP_OBJ_NEW_QSTR(qst));\n}\n\nmp_obj_t mp_unary_op(mp_unary_op_t op, mp_obj_t arg) {\n    DEBUG_OP_printf(\"unary \" UINT_FMT \" %q %p\\n\", op, mp_unary_op_method_name[op], arg);\n\n    if (op == MP_UNARY_OP_NOT) {\n        \n        return mp_obj_new_bool(mp_obj_is_true(arg) == 0);\n    } else if (mp_obj_is_small_int(arg)) {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(arg);\n        switch (op) {\n            case MP_UNARY_OP_BOOL:\n                return mp_obj_new_bool(val != 0);\n            case MP_UNARY_OP_HASH:\n                return arg;\n            case MP_UNARY_OP_POSITIVE:\n            case MP_UNARY_OP_INT_MAYBE:\n                return arg;\n            case MP_UNARY_OP_NEGATIVE:\n                \n                if (val == MP_SMALL_INT_MIN) {\n                    return mp_obj_new_int(-val);\n                } else {\n                    return MP_OBJ_NEW_SMALL_INT(-val);\n                }\n            case MP_UNARY_OP_ABS:\n                if (val >= 0) {\n                    return arg;\n                } else if (val == MP_SMALL_INT_MIN) {\n                    \n                    return mp_obj_new_int(-val);\n                } else {\n                    return MP_OBJ_NEW_SMALL_INT(-val);\n                }\n            default:\n                assert(op == MP_UNARY_OP_INVERT);\n                return MP_OBJ_NEW_SMALL_INT(~val);\n        }\n    } else if (op == MP_UNARY_OP_HASH && mp_obj_is_str_or_bytes(arg)) {\n        \n        GET_STR_HASH(arg, h);\n        if (h == 0) {\n            GET_STR_DATA_LEN(arg, data, len);\n            h = qstr_compute_hash(data, len);\n        }\n        return MP_OBJ_NEW_SMALL_INT(h);\n    } else {\n        const mp_obj_type_t *type = mp_obj_get_type(arg);\n        if (MP_OBJ_TYPE_HAS_SLOT(type, unary_op)) {\n            mp_obj_t result = MP_OBJ_TYPE_GET_SLOT(type, unary_op)(op, arg);\n            if (result != MP_OBJ_NULL) {\n                return result;\n            }\n        } else if (op == MP_UNARY_OP_HASH) {\n            \n            return MP_OBJ_NEW_SMALL_INT((mp_uint_t)arg);\n        }\n        if (op == MP_UNARY_OP_BOOL) {\n            \n            \n            \n            return mp_const_true;\n        }\n        if (op == MP_UNARY_OP_INT_MAYBE\n            #if MICROPY_PY_BUILTINS_FLOAT\n            || op == MP_UNARY_OP_FLOAT_MAYBE\n            #if MICROPY_PY_BUILTINS_COMPLEX\n            || op == MP_UNARY_OP_COMPLEX_MAYBE\n            #endif\n            #endif\n            ) {\n            \n            return MP_OBJ_NULL;\n        }\n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_TypeError(MP_ERROR_TEXT(\"unsupported type for operator\"));\n        #else\n        mp_raise_msg_varg(&mp_type_TypeError,\n            MP_ERROR_TEXT(\"unsupported type for %q: '%s'\"),\n            mp_unary_op_method_name[op], mp_obj_get_type_str(arg));\n        #endif\n    }\n}\n\nmp_obj_t MICROPY_WRAP_MP_BINARY_OP(mp_binary_op)(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs) {\n    DEBUG_OP_printf(\"binary \" UINT_FMT \" %q %p %p\\n\", op, mp_binary_op_method_name[op], lhs, rhs);\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    if (op == MP_BINARY_OP_IS) {\n        return mp_obj_new_bool(lhs == rhs);\n    }\n\n    \n    if (op == MP_BINARY_OP_EQUAL || op == MP_BINARY_OP_NOT_EQUAL) {\n        \n        return mp_obj_equal_not_equal(op, lhs, rhs);\n    }\n\n    \n    if (op == MP_BINARY_OP_EXCEPTION_MATCH) {\n        \n        if (mp_obj_is_exception_type(rhs)) {\n            if (mp_obj_exception_match(lhs, rhs)) {\n                return mp_const_true;\n            } else {\n                return mp_const_false;\n            }\n        } else if (mp_obj_is_type(rhs, &mp_type_tuple)) {\n            mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(rhs);\n            for (size_t i = 0; i < tuple->len; i++) {\n                rhs = tuple->items[i];\n                if (!mp_obj_is_exception_type(rhs)) {\n                    goto unsupported_op;\n                }\n                if (mp_obj_exception_match(lhs, rhs)) {\n                    return mp_const_true;\n                }\n            }\n            return mp_const_false;\n        }\n        goto unsupported_op;\n    }\n\n    if (mp_obj_is_small_int(lhs)) {\n        mp_int_t lhs_val = MP_OBJ_SMALL_INT_VALUE(lhs);\n        if (mp_obj_is_small_int(rhs)) {\n            mp_int_t rhs_val = MP_OBJ_SMALL_INT_VALUE(rhs);\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            switch (op) {\n                case MP_BINARY_OP_OR:\n                case MP_BINARY_OP_INPLACE_OR:\n                    lhs_val |= rhs_val;\n                    break;\n                case MP_BINARY_OP_XOR:\n                case MP_BINARY_OP_INPLACE_XOR:\n                    lhs_val ^= rhs_val;\n                    break;\n                case MP_BINARY_OP_AND:\n                case MP_BINARY_OP_INPLACE_AND:\n                    lhs_val &= rhs_val;\n                    break;\n                case MP_BINARY_OP_LSHIFT:\n                case MP_BINARY_OP_INPLACE_LSHIFT: {\n                    if (rhs_val < 0) {\n                        \n                        mp_raise_ValueError(MP_ERROR_TEXT(\"negative shift count\"));\n                    } else if (rhs_val >= (mp_int_t)(sizeof(lhs_val) * MP_BITS_PER_BYTE)\n                               || lhs_val > (MP_SMALL_INT_MAX >> rhs_val)\n                               || lhs_val < (MP_SMALL_INT_MIN >> rhs_val)) {\n                        \n                        lhs = mp_obj_new_int_from_ll(lhs_val);\n                        goto generic_binary_op;\n                    } else {\n                        \n                        lhs_val = (mp_uint_t)lhs_val << rhs_val;\n                    }\n                    break;\n                }\n                case MP_BINARY_OP_RSHIFT:\n                case MP_BINARY_OP_INPLACE_RSHIFT:\n                    if (rhs_val < 0) {\n                        \n                        mp_raise_ValueError(MP_ERROR_TEXT(\"negative shift count\"));\n                    } else {\n                        \n                        if (rhs_val >= (mp_int_t)(sizeof(lhs_val) * MP_BITS_PER_BYTE)) {\n                            \n                            \n                            rhs_val = sizeof(lhs_val) * MP_BITS_PER_BYTE - 1;\n                        }\n                        lhs_val >>= rhs_val;\n                    }\n                    break;\n                case MP_BINARY_OP_ADD:\n                case MP_BINARY_OP_INPLACE_ADD:\n                    lhs_val += rhs_val;\n                    break;\n                case MP_BINARY_OP_SUBTRACT:\n                case MP_BINARY_OP_INPLACE_SUBTRACT:\n                    lhs_val -= rhs_val;\n                    break;\n                case MP_BINARY_OP_MULTIPLY:\n                case MP_BINARY_OP_INPLACE_MULTIPLY: {\n\n                    \n                    \n                    \n                    #if 0\n                    \n                    long long res = (long long)lhs_val * (long long)rhs_val;\n                    if (res > MP_SMALL_INT_MAX || res < MP_SMALL_INT_MIN) {\n                        \n                        return mp_obj_new_int_from_ll(res);\n                    } else {\n                        \n                        lhs_val = (mp_int_t)res;\n                    }\n                    #endif\n\n                    if (mp_small_int_mul_overflow(lhs_val, rhs_val)) {\n                        \n                        lhs = mp_obj_new_int_from_ll(lhs_val);\n                        goto generic_binary_op;\n                    } else {\n                        \n                        return MP_OBJ_NEW_SMALL_INT(lhs_val * rhs_val);\n                    }\n                }\n                case MP_BINARY_OP_FLOOR_DIVIDE:\n                case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:\n                    if (rhs_val == 0) {\n                        goto zero_division;\n                    }\n                    lhs_val = mp_small_int_floor_divide(lhs_val, rhs_val);\n                    break;\n\n                #if MICROPY_PY_BUILTINS_FLOAT\n                case MP_BINARY_OP_TRUE_DIVIDE:\n                case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:\n                    if (rhs_val == 0) {\n                        goto zero_division;\n                    }\n                    return mp_obj_new_float((mp_float_t)lhs_val / (mp_float_t)rhs_val);\n                #endif\n\n                case MP_BINARY_OP_MODULO:\n                case MP_BINARY_OP_INPLACE_MODULO: {\n                    if (rhs_val == 0) {\n                        goto zero_division;\n                    }\n                    lhs_val = mp_small_int_modulo(lhs_val, rhs_val);\n                    break;\n                }\n\n                case MP_BINARY_OP_POWER:\n                case MP_BINARY_OP_INPLACE_POWER:\n                    if (rhs_val < 0) {\n                        #if MICROPY_PY_BUILTINS_FLOAT\n                        return mp_obj_float_binary_op(op, (mp_float_t)lhs_val, rhs);\n                        #else\n                        mp_raise_ValueError(MP_ERROR_TEXT(\"negative power with no float support\"));\n                        #endif\n                    } else {\n                        mp_int_t ans = 1;\n                        while (rhs_val > 0) {\n                            if (rhs_val & 1) {\n                                if (mp_small_int_mul_overflow(ans, lhs_val)) {\n                                    goto power_overflow;\n                                }\n                                ans *= lhs_val;\n                            }\n                            if (rhs_val == 1) {\n                                break;\n                            }\n                            rhs_val /= 2;\n                            if (mp_small_int_mul_overflow(lhs_val, lhs_val)) {\n                                goto power_overflow;\n                            }\n                            lhs_val *= lhs_val;\n                        }\n                        lhs_val = ans;\n                    }\n                    break;\n\n                power_overflow:\n                    \n                    lhs = mp_obj_new_int_from_ll(MP_OBJ_SMALL_INT_VALUE(lhs));\n                    goto generic_binary_op;\n\n                case MP_BINARY_OP_DIVMOD: {\n                    if (rhs_val == 0) {\n                        goto zero_division;\n                    }\n                    \n                    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(mp_obj_new_tuple(2, NULL));\n                    tuple->items[0] = MP_OBJ_NEW_SMALL_INT(mp_small_int_floor_divide(lhs_val, rhs_val));\n                    tuple->items[1] = MP_OBJ_NEW_SMALL_INT(mp_small_int_modulo(lhs_val, rhs_val));\n                    return MP_OBJ_FROM_PTR(tuple);\n                }\n\n                case MP_BINARY_OP_LESS:\n                    return mp_obj_new_bool(lhs_val < rhs_val);\n                case MP_BINARY_OP_MORE:\n                    return mp_obj_new_bool(lhs_val > rhs_val);\n                case MP_BINARY_OP_LESS_EQUAL:\n                    return mp_obj_new_bool(lhs_val <= rhs_val);\n                case MP_BINARY_OP_MORE_EQUAL:\n                    return mp_obj_new_bool(lhs_val >= rhs_val);\n\n                default:\n                    goto unsupported_op;\n            }\n            \n            if (MP_SMALL_INT_FITS(lhs_val)) {\n                return MP_OBJ_NEW_SMALL_INT(lhs_val);\n            } else {\n                return mp_obj_new_int_from_ll(lhs_val);\n            }\n        #if MICROPY_PY_BUILTINS_FLOAT\n        } else if (mp_obj_is_float(rhs)) {\n            mp_obj_t res = mp_obj_float_binary_op(op, (mp_float_t)lhs_val, rhs);\n            if (res == MP_OBJ_NULL) {\n                goto unsupported_op;\n            } else {\n                return res;\n            }\n        #endif\n        #if MICROPY_PY_BUILTINS_COMPLEX\n        } else if (mp_obj_is_type(rhs, &mp_type_complex)) {\n            mp_obj_t res = mp_obj_complex_binary_op(op, (mp_float_t)lhs_val, 0, rhs);\n            if (res == MP_OBJ_NULL) {\n                goto unsupported_op;\n            } else {\n                return res;\n            }\n        #endif\n        }\n    }\n\n    \n    if (op == MP_BINARY_OP_IN) {\n        op = MP_BINARY_OP_CONTAINS;\n        mp_obj_t temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n\n    \n    const mp_obj_type_t *type;\ngeneric_binary_op:\n    type = mp_obj_get_type(lhs);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, binary_op)) {\n        mp_obj_t result = MP_OBJ_TYPE_GET_SLOT(type, binary_op)(op, lhs, rhs);\n        if (result != MP_OBJ_NULL) {\n            return result;\n        }\n    }\n\n    \n    \n    \n    \n    if (op >= MP_BINARY_OP_INPLACE_OR && op <= MP_BINARY_OP_INPLACE_POWER) {\n        op += MP_BINARY_OP_OR - MP_BINARY_OP_INPLACE_OR;\n        goto generic_binary_op;\n    }\n\n    #if MICROPY_PY_REVERSE_SPECIAL_METHODS\n    if (op >= MP_BINARY_OP_OR && op <= MP_BINARY_OP_POWER) {\n        mp_obj_t t = rhs;\n        rhs = lhs;\n        lhs = t;\n        op += MP_BINARY_OP_REVERSE_OR - MP_BINARY_OP_OR;\n        goto generic_binary_op;\n    } else if (op >= MP_BINARY_OP_REVERSE_OR) {\n        \n        mp_obj_t t = rhs;\n        rhs = lhs;\n        lhs = t;\n        op -= MP_BINARY_OP_REVERSE_OR - MP_BINARY_OP_OR;\n    }\n    #endif\n\n    if (op == MP_BINARY_OP_CONTAINS) {\n        \n        \n        mp_obj_iter_buf_t iter_buf;\n        mp_obj_t iter = mp_getiter(lhs, &iter_buf);\n        mp_obj_t next;\n        while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n            if (mp_obj_equal(next, rhs)) {\n                return mp_const_true;\n            }\n        }\n        return mp_const_false;\n    }\n\nunsupported_op:\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_TypeError(MP_ERROR_TEXT(\"unsupported type for operator\"));\n    #else\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"unsupported types for %q: '%s', '%s'\"),\n        mp_binary_op_method_name[op], mp_obj_get_type_str(lhs), mp_obj_get_type_str(rhs));\n    #endif\n\nzero_division:\n    mp_raise_msg(&mp_type_ZeroDivisionError, MP_ERROR_TEXT(\"divide by zero\"));\n}\n\nmp_obj_t mp_call_function_0(mp_obj_t fun) {\n    return mp_call_function_n_kw(fun, 0, 0, NULL);\n}\n\nmp_obj_t mp_call_function_1(mp_obj_t fun, mp_obj_t arg) {\n    return mp_call_function_n_kw(fun, 1, 0, &arg);\n}\n\nmp_obj_t mp_call_function_2(mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2) {\n    mp_obj_t args[2];\n    args[0] = arg1;\n    args[1] = arg2;\n    return mp_call_function_n_kw(fun, 2, 0, args);\n}\n\n\nmp_obj_t mp_call_function_n_kw(mp_obj_t fun_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    \n    \n\n    DEBUG_OP_printf(\"calling function %p(n_args=\" UINT_FMT \", n_kw=\" UINT_FMT \", args=%p)\\n\", fun_in, n_args, n_kw, args);\n\n    \n    const mp_obj_type_t *type = mp_obj_get_type(fun_in);\n\n    \n    if (MP_OBJ_TYPE_HAS_SLOT(type, call)) {\n        return MP_OBJ_TYPE_GET_SLOT(type, call)(fun_in, n_args, n_kw, args);\n    }\n\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_TypeError(MP_ERROR_TEXT(\"object not callable\"));\n    #else\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"'%s' object isn't callable\"), mp_obj_get_type_str(fun_in));\n    #endif\n}\n\n\n\nmp_obj_t mp_call_method_n_kw(size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    DEBUG_OP_printf(\"call method (fun=%p, self=%p, n_args=\" UINT_FMT \", n_kw=\" UINT_FMT \", args=%p)\\n\", args[0], args[1], n_args, n_kw, args);\n    int adjust = (args[1] == MP_OBJ_NULL) ? 0 : 1;\n    return mp_call_function_n_kw(args[0], n_args + adjust, n_kw, args + 2 - adjust);\n}\n\n\n#if !MICROPY_STACKLESS\nstatic\n#endif\nvoid mp_call_prepare_args_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args) {\n    mp_obj_t fun = *args++;\n    mp_obj_t self = MP_OBJ_NULL;\n    if (have_self) {\n        self = *args++; \n    }\n    size_t n_args = n_args_n_kw & 0xff;\n    size_t n_kw = (n_args_n_kw >> 8) & 0xff;\n    mp_uint_t star_args = MP_OBJ_SMALL_INT_VALUE(args[n_args + 2 * n_kw]);\n\n    DEBUG_OP_printf(\"call method var (fun=%p, self=%p, n_args=%u, n_kw=%u, args=%p, map=%u)\\n\", fun, self, n_args, n_kw, args, star_args);\n\n    \n    \n    \n\n    \n    mp_obj_t *args2;\n    size_t args2_alloc;\n    size_t args2_len = 0;\n\n    \n    ssize_t list_len = 0;\n\n    if (star_args != 0) {\n        for (size_t i = 0; i < n_args; i++) {\n            if ((star_args >> i) & 1) {\n                mp_obj_t len = mp_obj_len_maybe(args[i]);\n                if (len != MP_OBJ_NULL) {\n                    \n                    list_len += mp_obj_get_int(len) - 1;\n                }\n            }\n        }\n    }\n\n    \n    ssize_t kw_dict_len = 0;\n\n    for (size_t i = 0; i < n_kw; i++) {\n        mp_obj_t key = args[n_args + i * 2];\n        mp_obj_t value = args[n_args + i * 2 + 1];\n        if (key == MP_OBJ_NULL && value != MP_OBJ_NULL && mp_obj_is_type(value, &mp_type_dict)) {\n            \n            kw_dict_len += mp_obj_dict_len(value) - 1;\n        }\n    }\n\n    \n    \n    if (star_args == 0) {\n        \n\n        \n        args2_alloc = 1 + n_args + 2 * (n_kw + kw_dict_len);\n        args2 = mp_nonlocal_alloc(args2_alloc * sizeof(mp_obj_t));\n\n        \n        if (self != MP_OBJ_NULL) {\n            args2[args2_len++] = self;\n        }\n\n        \n        mp_seq_copy(args2 + args2_len, args, n_args, mp_obj_t);\n        args2_len += n_args;\n    } else {\n        \n\n        \n        args2_alloc = 1 + n_args + list_len + 2 * (n_kw + kw_dict_len);\n        args2 = mp_nonlocal_alloc(args2_alloc * sizeof(mp_obj_t));\n\n        \n        if (self != MP_OBJ_NULL) {\n            args2[args2_len++] = self;\n        }\n\n        for (size_t i = 0; i < n_args; i++) {\n            mp_obj_t arg = args[i];\n            if ((star_args >> i) & 1) {\n                \n                if (mp_obj_is_type(arg, &mp_type_tuple) || mp_obj_is_type(arg, &mp_type_list)) {\n                    \n\n                    \n                    size_t len;\n                    mp_obj_t *items;\n                    mp_obj_get_array(arg, &len, &items);\n\n                    \n                    assert(args2_len + len <= args2_alloc);\n                    mp_seq_copy(args2 + args2_len, items, len, mp_obj_t);\n                    args2_len += len;\n                } else {\n                    \n\n                    \n                    mp_obj_iter_buf_t iter_buf;\n                    mp_obj_t iterable = mp_getiter(arg, &iter_buf);\n                    mp_obj_t item;\n                    while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n                        if (args2_len + (n_args - i) >= args2_alloc) {\n                            args2 = mp_nonlocal_realloc(args2, args2_alloc * sizeof(mp_obj_t),\n                                args2_alloc * 2 * sizeof(mp_obj_t));\n                            args2_alloc *= 2;\n                        }\n                        args2[args2_len++] = item;\n                    }\n                }\n            } else {\n                \n                assert(args2_len < args2_alloc);\n                args2[args2_len++] = arg;\n            }\n        }\n    }\n\n    \n    size_t pos_args_len = args2_len;\n\n    \n    if (args2_len + 2 * (n_kw + kw_dict_len) > args2_alloc) {\n        size_t new_alloc = args2_len + 2 * (n_kw + kw_dict_len);\n        args2 = mp_nonlocal_realloc(args2, args2_alloc * sizeof(mp_obj_t),\n            new_alloc * sizeof(mp_obj_t));\n        args2_alloc = new_alloc;\n    }\n\n    \n    for (size_t i = 0; i < n_kw; i++) {\n        mp_obj_t kw_key = args[n_args + i * 2];\n        mp_obj_t kw_value = args[n_args + i * 2 + 1];\n        if (kw_key == MP_OBJ_NULL) {\n            \n            if (mp_obj_is_type(kw_value, &mp_type_dict)) {\n                \n                mp_map_t *map = mp_obj_dict_get_map(kw_value);\n                \n                assert(args2_len + 2 * map->used <= args2_alloc);\n                for (size_t j = 0; j < map->alloc; j++) {\n                    if (mp_map_slot_is_filled(map, j)) {\n                        \n                        mp_obj_t key = map->table[j].key;\n                        if (!mp_obj_is_qstr(key)) {\n                            key = mp_obj_str_intern_checked(key);\n                        }\n                        args2[args2_len++] = key;\n                        args2[args2_len++] = map->table[j].value;\n                    }\n                }\n            } else {\n                \n                \n                \n\n                \n                mp_obj_t dest[3];\n                mp_load_method(kw_value, MP_QSTR_keys, dest);\n                mp_obj_t iterable = mp_getiter(mp_call_method_n_kw(0, 0, dest), NULL);\n\n                mp_obj_t key;\n                while ((key = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n                    \n                    if (args2_len + 1 >= args2_alloc) {\n                        size_t new_alloc = args2_alloc * 2;\n                        args2 = mp_nonlocal_realloc(args2, args2_alloc * sizeof(mp_obj_t), new_alloc * sizeof(mp_obj_t));\n                        args2_alloc = new_alloc;\n                    }\n\n                    \n                    if (!mp_obj_is_qstr(key)) {\n                        key = mp_obj_str_intern_checked(key);\n                    }\n\n                    \n                    mp_load_method(kw_value, MP_QSTR___getitem__, dest);\n                    dest[2] = key;\n                    mp_obj_t value = mp_call_method_n_kw(1, 0, dest);\n\n                    \n                    args2[args2_len++] = key;\n                    args2[args2_len++] = value;\n                }\n            }\n        } else {\n            \n            assert(args2_len + 2 <= args2_alloc);\n            args2[args2_len++] = kw_key;\n            args2[args2_len++] = kw_value;\n        }\n    }\n\n    out_args->fun = fun;\n    out_args->args = args2;\n    out_args->n_args = pos_args_len;\n    out_args->n_kw = (args2_len - pos_args_len) / 2;\n    out_args->n_alloc = args2_alloc;\n}\n\nmp_obj_t mp_call_method_n_kw_var(bool have_self, size_t n_args_n_kw, const mp_obj_t *args) {\n    mp_call_args_t out_args;\n    mp_call_prepare_args_n_kw_var(have_self, n_args_n_kw, args, &out_args);\n\n    mp_obj_t res = mp_call_function_n_kw(out_args.fun, out_args.n_args, out_args.n_kw, out_args.args);\n    mp_nonlocal_free(out_args.args, out_args.n_alloc * sizeof(mp_obj_t));\n\n    return res;\n}\n\n\nvoid mp_unpack_sequence(mp_obj_t seq_in, size_t num, mp_obj_t *items) {\n    size_t seq_len;\n    if (mp_obj_is_type(seq_in, &mp_type_tuple) || mp_obj_is_type(seq_in, &mp_type_list)) {\n        mp_obj_t *seq_items;\n        mp_obj_get_array(seq_in, &seq_len, &seq_items);\n        if (seq_len < num) {\n            goto too_short;\n        } else if (seq_len > num) {\n            goto too_long;\n        }\n        for (size_t i = 0; i < num; i++) {\n            items[i] = seq_items[num - 1 - i];\n        }\n    } else {\n        mp_obj_iter_buf_t iter_buf;\n        mp_obj_t iterable = mp_getiter(seq_in, &iter_buf);\n\n        for (seq_len = 0; seq_len < num; seq_len++) {\n            mp_obj_t el = mp_iternext(iterable);\n            if (el == MP_OBJ_STOP_ITERATION) {\n                goto too_short;\n            }\n            items[num - 1 - seq_len] = el;\n        }\n        if (mp_iternext(iterable) != MP_OBJ_STOP_ITERATION) {\n            goto too_long;\n        }\n    }\n    return;\n\ntoo_short:\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_ValueError(MP_ERROR_TEXT(\"wrong number of values to unpack\"));\n    #else\n    mp_raise_msg_varg(&mp_type_ValueError, MP_ERROR_TEXT(\"need more than %d values to unpack\"), (int)seq_len);\n    #endif\ntoo_long:\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_ValueError(MP_ERROR_TEXT(\"wrong number of values to unpack\"));\n    #else\n    mp_raise_msg_varg(&mp_type_ValueError, MP_ERROR_TEXT(\"too many values to unpack (expected %d)\"), (int)num);\n    #endif\n}\n\n\nvoid mp_unpack_ex(mp_obj_t seq_in, size_t num_in, mp_obj_t *items) {\n    size_t num_left = num_in & 0xff;\n    size_t num_right = (num_in >> 8) & 0xff;\n    DEBUG_OP_printf(\"unpack ex \" UINT_FMT \" \" UINT_FMT \"\\n\", num_left, num_right);\n    size_t seq_len;\n    if (mp_obj_is_type(seq_in, &mp_type_tuple) || mp_obj_is_type(seq_in, &mp_type_list)) {\n        \n        \n        \n        volatile mp_obj_t seq = seq_in;\n        mp_obj_t *seq_items;\n        mp_obj_get_array(seq, &seq_len, &seq_items);\n        if (seq_len < num_left + num_right) {\n            goto too_short;\n        }\n        for (size_t i = 0; i < num_right; i++) {\n            items[i] = seq_items[seq_len - 1 - i];\n        }\n        items[num_right] = mp_obj_new_list(seq_len - num_left - num_right, seq_items + num_left);\n        for (size_t i = 0; i < num_left; i++) {\n            items[num_right + 1 + i] = seq_items[num_left - 1 - i];\n        }\n        seq = MP_OBJ_NULL;\n    } else {\n        \n        \n        \n        \n        mp_obj_t iterable = mp_getiter(seq_in, NULL);\n        mp_obj_t item;\n        for (seq_len = 0; seq_len < num_left; seq_len++) {\n            item = mp_iternext(iterable);\n            if (item == MP_OBJ_STOP_ITERATION) {\n                goto too_short;\n            }\n            items[num_left + num_right + 1 - 1 - seq_len] = item;\n        }\n        mp_obj_list_t *rest = MP_OBJ_TO_PTR(mp_obj_new_list(0, NULL));\n        while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n            mp_obj_list_append(MP_OBJ_FROM_PTR(rest), item);\n        }\n        if (rest->len < num_right) {\n            goto too_short;\n        }\n        items[num_right] = MP_OBJ_FROM_PTR(rest);\n        for (size_t i = 0; i < num_right; i++) {\n            items[num_right - 1 - i] = rest->items[rest->len - num_right + i];\n        }\n        mp_obj_list_set_len(MP_OBJ_FROM_PTR(rest), rest->len - num_right);\n    }\n    return;\n\ntoo_short:\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_ValueError(MP_ERROR_TEXT(\"wrong number of values to unpack\"));\n    #else\n    mp_raise_msg_varg(&mp_type_ValueError, MP_ERROR_TEXT(\"need more than %d values to unpack\"), (int)seq_len);\n    #endif\n}\n\nmp_obj_t mp_load_attr(mp_obj_t base, qstr attr) {\n    DEBUG_OP_printf(\"load attr %p.%s\\n\", base, qstr_str(attr));\n    \n    mp_obj_t dest[2];\n    mp_load_method(base, attr, dest);\n    if (dest[1] == MP_OBJ_NULL) {\n        \n        return dest[0];\n    } else {\n        \n        return mp_obj_new_bound_meth(dest[0], dest[1]);\n    }\n}\n\n#if MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG\n\n\n\n\n\ntypedef struct _mp_obj_checked_fun_t {\n    mp_obj_base_t base;\n    const mp_obj_type_t *type;\n    mp_obj_t fun;\n} mp_obj_checked_fun_t;\n\nstatic mp_obj_t checked_fun_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_checked_fun_t *self = MP_OBJ_TO_PTR(self_in);\n    if (n_args > 0) {\n        const mp_obj_type_t *arg0_type = mp_obj_get_type(args[0]);\n        if (arg0_type != self->type) {\n            #if MICROPY_ERROR_REPORTING != MICROPY_ERROR_REPORTING_DETAILED\n            mp_raise_TypeError(MP_ERROR_TEXT(\"argument has wrong type\"));\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"argument should be a '%q' not a '%q'\"), self->type->name, arg0_type->name);\n            #endif\n        }\n    }\n    return mp_call_function_n_kw(self->fun, n_args, n_kw, args);\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_checked_fun,\n    MP_QSTR_function,\n    MP_TYPE_FLAG_BINDS_SELF,\n    call, checked_fun_call\n    );\n\nstatic mp_obj_t mp_obj_new_checked_fun(const mp_obj_type_t *type, mp_obj_t fun) {\n    mp_obj_checked_fun_t *o = mp_obj_malloc(mp_obj_checked_fun_t, &mp_type_checked_fun);\n    o->type = type;\n    o->fun = fun;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n#endif \n\n\n\n\n\n\nvoid mp_convert_member_lookup(mp_obj_t self, const mp_obj_type_t *type, mp_obj_t member, mp_obj_t *dest) {\n    if (mp_obj_is_obj(member)) {\n        const mp_obj_type_t *m_type = ((mp_obj_base_t *)MP_OBJ_TO_PTR(member))->type;\n        if (m_type->flags & MP_TYPE_FLAG_BINDS_SELF) {\n            \n            if (m_type->flags & MP_TYPE_FLAG_BUILTIN_FUN) {\n                \n                if (mp_obj_is_instance_type(type)) {\n                    \n                    dest[0] = member;\n                }\n                #if MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG\n                else if (self == MP_OBJ_NULL && type != &mp_type_object) {\n                    \n                    \n                    \n                    dest[0] = mp_obj_new_checked_fun(type, member);\n                }\n                #endif\n                else {\n                    \n                    dest[0] = member;\n                    dest[1] = self;\n                }\n            } else {\n                \n                dest[0] = member;\n                dest[1] = self;\n            }\n        } else if (m_type == &mp_type_staticmethod) {\n            \n            dest[0] = ((mp_obj_static_class_method_t *)MP_OBJ_TO_PTR(member))->fun;\n        } else if (m_type == &mp_type_classmethod) {\n            \n            \n            \n            if (self != MP_OBJ_NULL) {\n                type = mp_obj_get_type(self);\n            }\n            dest[0] = ((mp_obj_static_class_method_t *)MP_OBJ_TO_PTR(member))->fun;\n            dest[1] = MP_OBJ_FROM_PTR(type);\n        } else {\n            \n            dest[0] = member;\n        }\n    } else {\n        \n        dest[0] = member;\n    }\n}\n\n\n\n\nvoid mp_load_method_maybe(mp_obj_t obj, qstr attr, mp_obj_t *dest) {\n    \n    dest[0] = MP_OBJ_NULL;\n    dest[1] = MP_OBJ_NULL;\n\n    \n    \n    \n\n    \n    const mp_obj_type_t *type = mp_obj_get_type(obj);\n\n    \n    #if MICROPY_CPYTHON_COMPAT\n    if (attr == MP_QSTR___class__) {\n        \n        dest[0] = MP_OBJ_FROM_PTR(type);\n        return;\n    }\n    #endif\n\n    if (attr == MP_QSTR___next__ && TYPE_HAS_ITERNEXT(type)) {\n        dest[0] = MP_OBJ_FROM_PTR(&mp_builtin_next_obj);\n        dest[1] = obj;\n        return;\n    }\n    if (MP_OBJ_TYPE_HAS_SLOT(type, attr)) {\n        \n        MP_OBJ_TYPE_GET_SLOT(type, attr)(obj, attr, dest);\n        \n        \n        if (dest[1] != MP_OBJ_SENTINEL) {\n            return;\n        }\n        \n        dest[1] = MP_OBJ_NULL;\n    }\n    if (MP_OBJ_TYPE_HAS_SLOT(type, locals_dict)) {\n        \n        \n        assert(MP_OBJ_TYPE_GET_SLOT(type, locals_dict)->base.type == &mp_type_dict); \n        mp_map_t *locals_map = &MP_OBJ_TYPE_GET_SLOT(type, locals_dict)->map;\n        mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);\n        if (elem != NULL) {\n            mp_convert_member_lookup(obj, type, elem->value, dest);\n        }\n        return;\n    }\n}\n\nvoid mp_load_method(mp_obj_t base, qstr attr, mp_obj_t *dest) {\n    DEBUG_OP_printf(\"load method %p.%s\\n\", base, qstr_str(attr));\n\n    mp_load_method_maybe(base, attr, dest);\n\n    if (dest[0] == MP_OBJ_NULL) {\n        \n        #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n        mp_raise_msg(&mp_type_AttributeError, MP_ERROR_TEXT(\"no such attribute\"));\n        #else\n        \n        if (mp_obj_is_type(base, &mp_type_type)) {\n            mp_raise_msg_varg(&mp_type_AttributeError,\n                MP_ERROR_TEXT(\"type object '%q' has no attribute '%q'\"),\n                ((mp_obj_type_t *)MP_OBJ_TO_PTR(base))->name, attr);\n        } else {\n            mp_raise_msg_varg(&mp_type_AttributeError,\n                MP_ERROR_TEXT(\"'%s' object has no attribute '%q'\"),\n                mp_obj_get_type_str(base), attr);\n        }\n        #endif\n    }\n}\n\n\nvoid mp_load_method_protected(mp_obj_t obj, qstr attr, mp_obj_t *dest, bool catch_all_exc) {\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_load_method_maybe(obj, attr, dest);\n        nlr_pop();\n    } else {\n        if (!catch_all_exc\n            && !mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t *)nlr.ret_val)->type),\n                MP_OBJ_FROM_PTR(&mp_type_AttributeError))) {\n            \n            nlr_raise(MP_OBJ_FROM_PTR(nlr.ret_val));\n        }\n    }\n}\n\nvoid mp_store_attr(mp_obj_t base, qstr attr, mp_obj_t value) {\n    DEBUG_OP_printf(\"store attr %p.%s <- %p\\n\", base, qstr_str(attr), value);\n    const mp_obj_type_t *type = mp_obj_get_type(base);\n    if (MP_OBJ_TYPE_HAS_SLOT(type, attr)) {\n        mp_obj_t dest[2] = {MP_OBJ_SENTINEL, value};\n        MP_OBJ_TYPE_GET_SLOT(type, attr)(base, attr, dest);\n        if (dest[0] == MP_OBJ_NULL) {\n            \n            return;\n        }\n    }\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_msg(&mp_type_AttributeError, MP_ERROR_TEXT(\"no such attribute\"));\n    #else\n    mp_raise_msg_varg(&mp_type_AttributeError,\n        MP_ERROR_TEXT(\"'%s' object has no attribute '%q'\"),\n        mp_obj_get_type_str(base), attr);\n    #endif\n}\n\nmp_obj_t mp_getiter(mp_obj_t o_in, mp_obj_iter_buf_t *iter_buf) {\n    assert(o_in);\n    const mp_obj_type_t *type = mp_obj_get_type(o_in);\n\n    \n    \n    if ((type->flags & MP_TYPE_FLAG_ITER_IS_ITERNEXT) == MP_TYPE_FLAG_ITER_IS_ITERNEXT || (type->flags & MP_TYPE_FLAG_ITER_IS_STREAM) == MP_TYPE_FLAG_ITER_IS_STREAM) {\n        return o_in;\n    }\n\n    if (MP_OBJ_TYPE_HAS_SLOT(type, iter)) {\n        \n        if (iter_buf == NULL && MP_OBJ_TYPE_GET_SLOT(type, iter) != mp_obj_instance_getiter) {\n            \n            \n            iter_buf = m_new_obj(mp_obj_iter_buf_t);\n        }\n        mp_getiter_fun_t getiter;\n        if (type->flags & MP_TYPE_FLAG_ITER_IS_CUSTOM) {\n            getiter = ((mp_getiter_iternext_custom_t *)MP_OBJ_TYPE_GET_SLOT(type, iter))->getiter;\n        } else {\n            getiter = (mp_getiter_fun_t)MP_OBJ_TYPE_GET_SLOT(type, iter);\n        }\n        mp_obj_t iter = getiter(o_in, iter_buf);\n        if (iter != MP_OBJ_NULL) {\n            return iter;\n        }\n    }\n\n    \n    mp_obj_t dest[2];\n    mp_load_method_maybe(o_in, MP_QSTR___getitem__, dest);\n    if (dest[0] != MP_OBJ_NULL) {\n        \n        if (iter_buf == NULL) {\n            \n            iter_buf = m_new_obj(mp_obj_iter_buf_t);\n        }\n        return mp_obj_new_getitem_iter(dest, iter_buf);\n    }\n\n    \n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    mp_raise_TypeError(MP_ERROR_TEXT(\"object not iterable\"));\n    #else\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"'%s' object isn't iterable\"), mp_obj_get_type_str(o_in));\n    #endif\n\n}\n\nstatic mp_fun_1_t type_get_iternext(const mp_obj_type_t *type) {\n    if ((type->flags & MP_TYPE_FLAG_ITER_IS_STREAM) == MP_TYPE_FLAG_ITER_IS_STREAM) {\n        return mp_stream_unbuffered_iter;\n    } else if (type->flags & MP_TYPE_FLAG_ITER_IS_ITERNEXT) {\n        return (mp_fun_1_t)MP_OBJ_TYPE_GET_SLOT(type, iter);\n    } else if (type->flags & MP_TYPE_FLAG_ITER_IS_CUSTOM) {\n        return ((mp_getiter_iternext_custom_t *)MP_OBJ_TYPE_GET_SLOT(type, iter))->iternext;\n    } else {\n        return NULL;\n    }\n}\n\n\n\nmp_obj_t mp_iternext_allow_raise(mp_obj_t o_in) {\n    const mp_obj_type_t *type = mp_obj_get_type(o_in);\n    if (TYPE_HAS_ITERNEXT(type)) {\n        MP_STATE_THREAD(stop_iteration_arg) = MP_OBJ_NULL;\n        return type_get_iternext(type)(o_in);\n    } else {\n        \n        mp_obj_t dest[2];\n        mp_load_method_maybe(o_in, MP_QSTR___next__, dest);\n        if (dest[0] != MP_OBJ_NULL) {\n            \n            return mp_call_method_n_kw(0, 0, dest);\n        } else {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_raise_TypeError(MP_ERROR_TEXT(\"object not an iterator\"));\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"'%s' object isn't an iterator\"), mp_obj_get_type_str(o_in));\n            #endif\n        }\n    }\n}\n\n\n\nmp_obj_t mp_iternext(mp_obj_t o_in) {\n    MP_STACK_CHECK(); \n    const mp_obj_type_t *type = mp_obj_get_type(o_in);\n    if (TYPE_HAS_ITERNEXT(type)) {\n        MP_STATE_THREAD(stop_iteration_arg) = MP_OBJ_NULL;\n        return type_get_iternext(type)(o_in);\n    } else {\n        \n        mp_obj_t dest[2];\n        mp_load_method_maybe(o_in, MP_QSTR___next__, dest);\n        if (dest[0] != MP_OBJ_NULL) {\n            \n            nlr_buf_t nlr;\n            if (nlr_push(&nlr) == 0) {\n                mp_obj_t ret = mp_call_method_n_kw(0, 0, dest);\n                nlr_pop();\n                return ret;\n            } else {\n                if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t *)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {\n                    return mp_make_stop_iteration(mp_obj_exception_get_value(MP_OBJ_FROM_PTR(nlr.ret_val)));\n                } else {\n                    nlr_jump(nlr.ret_val);\n                }\n            }\n        } else {\n            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n            mp_raise_TypeError(MP_ERROR_TEXT(\"object not an iterator\"));\n            #else\n            mp_raise_msg_varg(&mp_type_TypeError,\n                MP_ERROR_TEXT(\"'%s' object isn't an iterator\"), mp_obj_get_type_str(o_in));\n            #endif\n        }\n    }\n}\n\nmp_vm_return_kind_t mp_resume(mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val) {\n    assert((send_value != MP_OBJ_NULL) ^ (throw_value != MP_OBJ_NULL));\n    const mp_obj_type_t *type = mp_obj_get_type(self_in);\n\n    if (type == &mp_type_gen_instance) {\n        return mp_obj_gen_resume(self_in, send_value, throw_value, ret_val);\n    }\n\n    if (TYPE_HAS_ITERNEXT(type) && send_value == mp_const_none) {\n        MP_STATE_THREAD(stop_iteration_arg) = MP_OBJ_NULL;\n        mp_obj_t ret = type_get_iternext(type)(self_in);\n        *ret_val = ret;\n        if (ret != MP_OBJ_STOP_ITERATION) {\n            return MP_VM_RETURN_YIELD;\n        } else {\n            \n            \n            *ret_val = MP_STATE_THREAD(stop_iteration_arg);\n            if (*ret_val == MP_OBJ_NULL) {\n                *ret_val = mp_const_none;\n            }\n            return MP_VM_RETURN_NORMAL;\n        }\n    }\n\n    mp_obj_t dest[3]; \n\n    \n    if (send_value == mp_const_none) {\n        mp_load_method_maybe(self_in, MP_QSTR___next__, dest);\n        if (dest[0] != MP_OBJ_NULL) {\n            *ret_val = mp_call_method_n_kw(0, 0, dest);\n            return MP_VM_RETURN_YIELD;\n        }\n    }\n\n    \n    \n    if (send_value != MP_OBJ_NULL) {\n        mp_load_method(self_in, MP_QSTR_send, dest);\n        dest[2] = send_value;\n        *ret_val = mp_call_method_n_kw(1, 0, dest);\n        return MP_VM_RETURN_YIELD;\n    }\n\n    assert(throw_value != MP_OBJ_NULL);\n    {\n        if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(mp_obj_get_type(throw_value)), MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {\n            mp_load_method_maybe(self_in, MP_QSTR_close, dest);\n            if (dest[0] != MP_OBJ_NULL) {\n                \n                \n                *ret_val = mp_call_method_n_kw(0, 0, dest);\n                \n                return MP_VM_RETURN_NORMAL;\n            }\n        } else {\n            mp_load_method_maybe(self_in, MP_QSTR_throw, dest);\n            if (dest[0] != MP_OBJ_NULL) {\n                dest[2] = throw_value;\n                *ret_val = mp_call_method_n_kw(1, 0, dest);\n                \n                \n                return MP_VM_RETURN_YIELD;\n            }\n        }\n        \n        \n        \n        \n        \n        if (mp_obj_exception_match(throw_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {\n            \n            *ret_val = mp_obj_new_exception_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"generator raised StopIteration\"));\n        } else {\n            *ret_val = mp_make_raise_obj(throw_value);\n        }\n        return MP_VM_RETURN_EXCEPTION;\n    }\n}\n\nmp_obj_t mp_make_raise_obj(mp_obj_t o) {\n    DEBUG_printf(\"raise %p\\n\", o);\n    if (mp_obj_is_exception_type(o)) {\n        \n        \n        \n        \n        o = mp_call_function_n_kw(o, 0, 0, NULL);\n    }\n\n    if (mp_obj_is_exception_instance(o)) {\n        \n        return o;\n    } else {\n        \n        return mp_obj_new_exception_msg(&mp_type_TypeError, MP_ERROR_TEXT(\"exceptions must derive from BaseException\"));\n    }\n}\n\nmp_obj_t mp_import_name(qstr name, mp_obj_t fromlist, mp_obj_t level) {\n    DEBUG_printf(\"import name '%s' level=%d\\n\", qstr_str(name), MP_OBJ_SMALL_INT_VALUE(level));\n\n    \n    mp_obj_t args[5];\n    args[0] = MP_OBJ_NEW_QSTR(name);\n    args[1] = mp_const_none; \n    args[2] = mp_const_none; \n    args[3] = fromlist;\n    args[4] = level;\n\n    #if MICROPY_CAN_OVERRIDE_BUILTINS\n    \n    mp_obj_dict_t *bo_dict = MP_STATE_VM(mp_module_builtins_override_dict);\n    if (bo_dict != NULL) {\n        mp_map_elem_t *import = mp_map_lookup(&bo_dict->map, MP_OBJ_NEW_QSTR(MP_QSTR___import__), MP_MAP_LOOKUP);\n        if (import != NULL) {\n            return mp_call_function_n_kw(import->value, 5, 0, args);\n        }\n    }\n    #endif\n\n    return mp_builtin___import__(5, args);\n}\n\nmp_obj_t mp_import_from(mp_obj_t module, qstr name) {\n    DEBUG_printf(\"import from %p %s\\n\", module, qstr_str(name));\n\n    mp_obj_t dest[2];\n\n    mp_load_method_maybe(module, name, dest);\n\n    if (dest[1] != MP_OBJ_NULL) {\n        \n    import_error:\n        mp_raise_msg_varg(&mp_type_ImportError, MP_ERROR_TEXT(\"can't import name %q\"), name);\n    }\n\n    if (dest[0] != MP_OBJ_NULL) {\n        return dest[0];\n    }\n\n    #if MICROPY_ENABLE_EXTERNAL_IMPORT\n\n    \n    mp_load_method_maybe(module, MP_QSTR___path__, dest);\n    if (dest[0] == MP_OBJ_NULL) {\n        goto import_error;\n    }\n\n    mp_load_method_maybe(module, MP_QSTR___name__, dest);\n    size_t pkg_name_len;\n    const char *pkg_name = mp_obj_str_get_data(dest[0], &pkg_name_len);\n\n    const uint dot_name_len = pkg_name_len + 1 + qstr_len(name);\n    char *dot_name = mp_local_alloc(dot_name_len);\n    memcpy(dot_name, pkg_name, pkg_name_len);\n    dot_name[pkg_name_len] = '.';\n    memcpy(dot_name + pkg_name_len + 1, qstr_str(name), qstr_len(name));\n    qstr dot_name_q = qstr_from_strn(dot_name, dot_name_len);\n    mp_local_free(dot_name);\n\n    \n    return mp_import_name(dot_name_q, mp_const_true, MP_OBJ_NEW_SMALL_INT(0));\n\n    #else\n\n    \n    goto import_error;\n\n    #endif\n}\n\nvoid mp_import_all(mp_obj_t module) {\n    DEBUG_printf(\"import all %p\\n\", module);\n\n    \n    mp_map_t *map = &mp_obj_module_get_globals(module)->map;\n    for (size_t i = 0; i < map->alloc; i++) {\n        if (mp_map_slot_is_filled(map, i)) {\n            \n            \n            \n            const char *name = mp_obj_str_get_str(map->table[i].key);\n            if (*name != '_') {\n                qstr qname = mp_obj_str_get_qstr(map->table[i].key);\n                mp_store_name(qname, map->table[i].value);\n            }\n        }\n    }\n}\n\n#if MICROPY_ENABLE_COMPILER\n\nmp_obj_t mp_parse_compile_execute(mp_lexer_t *lex, mp_parse_input_kind_t parse_input_kind, mp_obj_dict_t *globals, mp_obj_dict_t *locals) {\n    \n    nlr_jump_callback_node_globals_locals_t ctx;\n    ctx.globals = mp_globals_get();\n    ctx.locals = mp_locals_get();\n\n    \n    mp_globals_set(globals);\n    mp_locals_set(locals);\n\n    \n    nlr_push_jump_callback(&ctx.callback, mp_globals_locals_set_from_nlr_jump_callback);\n\n    qstr source_name = lex->source_name;\n    mp_parse_tree_t parse_tree = mp_parse(lex, parse_input_kind);\n    mp_obj_t module_fun = mp_compile(&parse_tree, source_name, parse_input_kind == MP_PARSE_SINGLE_INPUT);\n\n    mp_obj_t ret;\n    if (MICROPY_PY_BUILTINS_COMPILE && globals == NULL) {\n        \n        ret = module_fun;\n    } else {\n        \n        ret = mp_call_function_0(module_fun);\n    }\n\n    \n    nlr_pop_jump_callback(true);\n\n    \n    return ret;\n}\n\n#endif \n\nNORETURN void m_malloc_fail(size_t num_bytes) {\n    DEBUG_printf(\"memory allocation failed, allocating %u bytes\\n\", (uint)num_bytes);\n    #if MICROPY_ENABLE_GC\n    if (gc_is_locked()) {\n        mp_raise_msg(&mp_type_MemoryError, MP_ERROR_TEXT(\"memory allocation failed, heap is locked\"));\n    }\n    #endif\n    mp_raise_msg_varg(&mp_type_MemoryError,\n        MP_ERROR_TEXT(\"memory allocation failed, allocating %u bytes\"), (uint)num_bytes);\n}\n\n#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NONE\n\nNORETURN void mp_raise_type(const mp_obj_type_t *exc_type) {\n    nlr_raise(mp_obj_new_exception(exc_type));\n}\n\nNORETURN void mp_raise_ValueError_no_msg(void) {\n    mp_raise_type(&mp_type_ValueError);\n}\n\nNORETURN void mp_raise_TypeError_no_msg(void) {\n    mp_raise_type(&mp_type_TypeError);\n}\n\nNORETURN void mp_raise_NotImplementedError_no_msg(void) {\n    mp_raise_type(&mp_type_NotImplementedError);\n}\n\n#else\n\nNORETURN void mp_raise_msg(const mp_obj_type_t *exc_type, mp_rom_error_text_t msg) {\n    if (msg == NULL) {\n        nlr_raise(mp_obj_new_exception(exc_type));\n    } else {\n        nlr_raise(mp_obj_new_exception_msg(exc_type, msg));\n    }\n}\n\nNORETURN void mp_raise_msg_varg(const mp_obj_type_t *exc_type, mp_rom_error_text_t fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    mp_obj_t exc = mp_obj_new_exception_msg_vlist(exc_type, fmt, args);\n    va_end(args);\n    nlr_raise(exc);\n}\n\nNORETURN void mp_raise_ValueError(mp_rom_error_text_t msg) {\n    mp_raise_msg(&mp_type_ValueError, msg);\n}\n\nNORETURN void mp_raise_TypeError(mp_rom_error_text_t msg) {\n    mp_raise_msg(&mp_type_TypeError, msg);\n}\n\nNORETURN void mp_raise_NotImplementedError(mp_rom_error_text_t msg) {\n    mp_raise_msg(&mp_type_NotImplementedError, msg);\n}\n\n#endif\n\nNORETURN void mp_raise_type_arg(const mp_obj_type_t *exc_type, mp_obj_t arg) {\n    nlr_raise(mp_obj_new_exception_arg1(exc_type, arg));\n}\n\nNORETURN void mp_raise_StopIteration(mp_obj_t arg) {\n    if (arg == MP_OBJ_NULL) {\n        mp_raise_type(&mp_type_StopIteration);\n    } else {\n        mp_raise_type_arg(&mp_type_StopIteration, arg);\n    }\n}\n\nNORETURN void mp_raise_TypeError_int_conversion(mp_const_obj_t arg) {\n    #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n    (void)arg;\n    mp_raise_TypeError(MP_ERROR_TEXT(\"can't convert to int\"));\n    #else\n    mp_raise_msg_varg(&mp_type_TypeError,\n        MP_ERROR_TEXT(\"can't convert %s to int\"), mp_obj_get_type_str(arg));\n    #endif\n}\n\nNORETURN void mp_raise_OSError(int errno_) {\n    mp_raise_type_arg(&mp_type_OSError, MP_OBJ_NEW_SMALL_INT(errno_));\n}\n\nNORETURN void mp_raise_OSError_with_filename(int errno_, const char *filename) {\n    vstr_t vstr;\n    vstr_init(&vstr, 32);\n    vstr_printf(&vstr, \"can't open %s\", filename);\n    mp_obj_t o_str = mp_obj_new_str_from_vstr(&vstr);\n    mp_obj_t args[2] = { MP_OBJ_NEW_SMALL_INT(errno_), MP_OBJ_FROM_PTR(o_str)};\n    nlr_raise(mp_obj_exception_make_new(&mp_type_OSError, 2, 0, args));\n}\n\n#if MICROPY_STACK_CHECK || MICROPY_ENABLE_PYSTACK\nNORETURN void mp_raise_recursion_depth(void) {\n    mp_raise_type_arg(&mp_type_RuntimeError, MP_OBJ_NEW_QSTR(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}