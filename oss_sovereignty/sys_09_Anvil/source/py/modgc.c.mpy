{
  "module_name": "modgc.c",
  "hash_id": "3087af392f64d2b85f2d4caab6e77e06b152ad5349a12d20806e973ecb4b02ab",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modgc.c",
  "human_readable_source": " \n\n#include \"py/mpstate.h\"\n#include \"py/obj.h\"\n#include \"py/gc.h\"\n\n#if MICROPY_PY_GC && MICROPY_ENABLE_GC\n\n\nstatic mp_obj_t py_gc_collect(void) {\n    gc_collect();\n    #if MICROPY_PY_GC_COLLECT_RETVAL\n    return MP_OBJ_NEW_SMALL_INT(MP_STATE_MEM(gc_collected));\n    #else\n    return mp_const_none;\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_0(gc_collect_obj, py_gc_collect);\n\n\nstatic mp_obj_t gc_disable(void) {\n    MP_STATE_MEM(gc_auto_collect_enabled) = 0;\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_0(gc_disable_obj, gc_disable);\n\n\nstatic mp_obj_t gc_enable(void) {\n    MP_STATE_MEM(gc_auto_collect_enabled) = 1;\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_0(gc_enable_obj, gc_enable);\n\nstatic mp_obj_t gc_isenabled(void) {\n    return mp_obj_new_bool(MP_STATE_MEM(gc_auto_collect_enabled));\n}\nMP_DEFINE_CONST_FUN_OBJ_0(gc_isenabled_obj, gc_isenabled);\n\n\nstatic mp_obj_t gc_mem_free(void) {\n    gc_info_t info;\n    gc_info(&info);\n    #if MICROPY_GC_SPLIT_HEAP_AUTO\n    \n    return MP_OBJ_NEW_SMALL_INT(info.free + info.max_new_split);\n    #else\n    return MP_OBJ_NEW_SMALL_INT(info.free);\n    #endif\n}\nMP_DEFINE_CONST_FUN_OBJ_0(gc_mem_free_obj, gc_mem_free);\n\n\nstatic mp_obj_t gc_mem_alloc(void) {\n    gc_info_t info;\n    gc_info(&info);\n    return MP_OBJ_NEW_SMALL_INT(info.used);\n}\nMP_DEFINE_CONST_FUN_OBJ_0(gc_mem_alloc_obj, gc_mem_alloc);\n\n#if MICROPY_GC_ALLOC_THRESHOLD\nstatic mp_obj_t gc_threshold(size_t n_args, const mp_obj_t *args) {\n    if (n_args == 0) {\n        if (MP_STATE_MEM(gc_alloc_threshold) == (size_t)-1) {\n            return MP_OBJ_NEW_SMALL_INT(-1);\n        }\n        return mp_obj_new_int(MP_STATE_MEM(gc_alloc_threshold) * MICROPY_BYTES_PER_GC_BLOCK);\n    }\n    mp_int_t val = mp_obj_get_int(args[0]);\n    if (val < 0) {\n        MP_STATE_MEM(gc_alloc_threshold) = (size_t)-1;\n    } else {\n        MP_STATE_MEM(gc_alloc_threshold) = val / MICROPY_BYTES_PER_GC_BLOCK;\n    }\n    return mp_const_none;\n}\nMP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(gc_threshold_obj, 0, 1, gc_threshold);\n#endif\n\nstatic const mp_rom_map_elem_t mp_module_gc_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_gc) },\n    { MP_ROM_QSTR(MP_QSTR_collect), MP_ROM_PTR(&gc_collect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_disable), MP_ROM_PTR(&gc_disable_obj) },\n    { MP_ROM_QSTR(MP_QSTR_enable), MP_ROM_PTR(&gc_enable_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isenabled), MP_ROM_PTR(&gc_isenabled_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mem_free), MP_ROM_PTR(&gc_mem_free_obj) },\n    { MP_ROM_QSTR(MP_QSTR_mem_alloc), MP_ROM_PTR(&gc_mem_alloc_obj) },\n    #if MICROPY_GC_ALLOC_THRESHOLD\n    { MP_ROM_QSTR(MP_QSTR_threshold), MP_ROM_PTR(&gc_threshold_obj) },\n    #endif\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_gc_globals, mp_module_gc_globals_table);\n\nconst mp_obj_module_t mp_module_gc = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_gc_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR_gc, mp_module_gc);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}