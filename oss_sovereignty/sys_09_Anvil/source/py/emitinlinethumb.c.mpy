{
  "module_name": "emitinlinethumb.c",
  "hash_id": "5ff74842f3927b604231336948ebf1c68a1fc39a96d816c6cb4e0ab46a634236",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/emitinlinethumb.c",
  "human_readable_source": " \n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <assert.h>\n\n#include \"py/emit.h\"\n#include \"py/asmthumb.h\"\n\n#if MICROPY_EMIT_INLINE_THUMB\n\ntypedef enum {\n\n#define DEF_RULE(rule, comp, kind, ...) PN_##rule,\n#define DEF_RULE_NC(rule, kind, ...)\n    #include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n    PN_const_object, \n\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) PN_##rule,\n    #include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n} pn_kind_t;\n\nstruct _emit_inline_asm_t {\n    asm_thumb_t as;\n    uint16_t pass;\n    mp_obj_t *error_slot;\n    mp_uint_t max_num_labels;\n    qstr *label_lookup;\n};\n\n#if MICROPY_DYNAMIC_COMPILER\n\nstatic inline bool emit_inline_thumb_allow_float(emit_inline_asm_t *emit) {\n    return MP_NATIVE_ARCH_ARMV7EMSP <= mp_dynamic_compiler.native_arch\n           && mp_dynamic_compiler.native_arch <= MP_NATIVE_ARCH_ARMV7EMDP;\n}\n\n#else\n\nstatic inline bool emit_inline_thumb_allow_float(emit_inline_asm_t *emit) {\n    return MICROPY_EMIT_INLINE_THUMB_FLOAT;\n}\n\n#endif\n\nstatic void emit_inline_thumb_error_msg(emit_inline_asm_t *emit, mp_rom_error_text_t msg) {\n    *emit->error_slot = mp_obj_new_exception_msg(&mp_type_SyntaxError, msg);\n}\n\nstatic void emit_inline_thumb_error_exc(emit_inline_asm_t *emit, mp_obj_t exc) {\n    *emit->error_slot = exc;\n}\n\nemit_inline_asm_t *emit_inline_thumb_new(mp_uint_t max_num_labels) {\n    emit_inline_asm_t *emit = m_new_obj(emit_inline_asm_t);\n    memset(&emit->as, 0, sizeof(emit->as));\n    mp_asm_base_init(&emit->as.base, max_num_labels);\n    emit->max_num_labels = max_num_labels;\n    emit->label_lookup = m_new(qstr, max_num_labels);\n    return emit;\n}\n\nvoid emit_inline_thumb_free(emit_inline_asm_t *emit) {\n    m_del(qstr, emit->label_lookup, emit->max_num_labels);\n    mp_asm_base_deinit(&emit->as.base, false);\n    m_del_obj(emit_inline_asm_t, emit);\n}\n\nstatic void emit_inline_thumb_start_pass(emit_inline_asm_t *emit, pass_kind_t pass, mp_obj_t *error_slot) {\n    emit->pass = pass;\n    emit->error_slot = error_slot;\n    if (emit->pass == MP_PASS_CODE_SIZE) {\n        memset(emit->label_lookup, 0, emit->max_num_labels * sizeof(qstr));\n    }\n    mp_asm_base_start_pass(&emit->as.base, pass == MP_PASS_EMIT ? MP_ASM_PASS_EMIT : MP_ASM_PASS_COMPUTE);\n    asm_thumb_entry(&emit->as, 0);\n}\n\nstatic void emit_inline_thumb_end_pass(emit_inline_asm_t *emit, mp_uint_t type_sig) {\n    asm_thumb_exit(&emit->as);\n    asm_thumb_end_pass(&emit->as);\n}\n\nstatic mp_uint_t emit_inline_thumb_count_params(emit_inline_asm_t *emit, mp_uint_t n_params, mp_parse_node_t *pn_params) {\n    if (n_params > 4) {\n        emit_inline_thumb_error_msg(emit, MP_ERROR_TEXT(\"can only have up to 4 parameters to Thumb assembly\"));\n        return 0;\n    }\n    for (mp_uint_t i = 0; i < n_params; i++) {\n        if (!MP_PARSE_NODE_IS_ID(pn_params[i])) {\n            emit_inline_thumb_error_msg(emit, MP_ERROR_TEXT(\"parameters must be registers in sequence r0 to r3\"));\n            return 0;\n        }\n        const char *p = qstr_str(MP_PARSE_NODE_LEAF_ARG(pn_params[i]));\n        if (!(strlen(p) == 2 && p[0] == 'r' && (mp_uint_t)p[1] == '0' + i)) {\n            emit_inline_thumb_error_msg(emit, MP_ERROR_TEXT(\"parameters must be registers in sequence r0 to r3\"));\n            return 0;\n        }\n    }\n    return n_params;\n}\n\nstatic bool emit_inline_thumb_label(emit_inline_asm_t *emit, mp_uint_t label_num, qstr label_id) {\n    assert(label_num < emit->max_num_labels);\n    if (emit->pass == MP_PASS_CODE_SIZE) {\n        \n        for (uint i = 0; i < emit->max_num_labels; i++) {\n            if (emit->label_lookup[i] == label_id) {\n                return false;\n            }\n        }\n    }\n    emit->label_lookup[label_num] = label_id;\n    mp_asm_base_label_assign(&emit->as.base, label_num);\n    return true;\n}\n\ntypedef struct _reg_name_t { byte reg;\n                             byte name[3];\n} reg_name_t;\nstatic const reg_name_t reg_name_table[] = {\n    {0, \"r0\\0\"},\n    {1, \"r1\\0\"},\n    {2, \"r2\\0\"},\n    {3, \"r3\\0\"},\n    {4, \"r4\\0\"},\n    {5, \"r5\\0\"},\n    {6, \"r6\\0\"},\n    {7, \"r7\\0\"},\n    {8, \"r8\\0\"},\n    {9, \"r9\\0\"},\n    {10, \"r10\"},\n    {11, \"r11\"},\n    {12, \"r12\"},\n    {13, \"r13\"},\n    {14, \"r14\"},\n    {15, \"r15\"},\n    {10, \"sl\\0\"},\n    {11, \"fp\\0\"},\n    {13, \"sp\\0\"},\n    {14, \"lr\\0\"},\n    {15, \"pc\\0\"},\n};\n\n#define MAX_SPECIAL_REGISTER_NAME_LENGTH 7\ntypedef struct _special_reg_name_t { byte reg;\n                                     char name[MAX_SPECIAL_REGISTER_NAME_LENGTH + 1];\n} special_reg_name_t;\nstatic const special_reg_name_t special_reg_name_table[] = {\n    {5, \"IPSR\"},\n    {17, \"BASEPRI\"},\n};\n\n\n\nstatic const char *get_arg_str(mp_parse_node_t pn) {\n    if (MP_PARSE_NODE_IS_ID(pn)) {\n        qstr qst = MP_PARSE_NODE_LEAF_ARG(pn);\n        return qstr_str(qst);\n    } else {\n        return \"\";\n    }\n}\n\nstatic mp_uint_t get_arg_reg(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn, mp_uint_t max_reg) {\n    const char *reg_str = get_arg_str(pn);\n    for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(reg_name_table); i++) {\n        const reg_name_t *r = &reg_name_table[i];\n        if (reg_str[0] == r->name[0]\n            && reg_str[1] == r->name[1]\n            && reg_str[2] == r->name[2]\n            && (reg_str[2] == '\\0' || reg_str[3] == '\\0')) {\n            if (r->reg > max_reg) {\n                emit_inline_thumb_error_exc(emit,\n                    mp_obj_new_exception_msg_varg(&mp_type_SyntaxError,\n                        MP_ERROR_TEXT(\"'%s' expects at most r%d\"), op, max_reg));\n                return 0;\n            } else {\n                return r->reg;\n            }\n        }\n    }\n    emit_inline_thumb_error_exc(emit,\n        mp_obj_new_exception_msg_varg(&mp_type_SyntaxError,\n            MP_ERROR_TEXT(\"'%s' expects a register\"), op));\n    return 0;\n}\n\nstatic mp_uint_t get_arg_special_reg(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn) {\n    const char *reg_str = get_arg_str(pn);\n    for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(special_reg_name_table); i++) {\n        const special_reg_name_t *r = &special_reg_name_table[i];\n        if (strcmp(r->name, reg_str) == 0) {\n            return r->reg;\n        }\n    }\n    emit_inline_thumb_error_exc(emit,\n        mp_obj_new_exception_msg_varg(&mp_type_SyntaxError,\n            MP_ERROR_TEXT(\"'%s' expects a special register\"), op));\n    return 0;\n}\n\nstatic mp_uint_t get_arg_vfpreg(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn) {\n    const char *reg_str = get_arg_str(pn);\n    if (reg_str[0] == 's' && reg_str[1] != '\\0') {\n        mp_uint_t regno = 0;\n        for (++reg_str; *reg_str; ++reg_str) {\n            mp_uint_t v = *reg_str;\n            if (!('0' <= v && v <= '9')) {\n                goto malformed;\n            }\n            regno = 10 * regno + v - '0';\n        }\n        if (regno > 31) {\n            emit_inline_thumb_error_exc(emit,\n                mp_obj_new_exception_msg_varg(&mp_type_SyntaxError,\n                    MP_ERROR_TEXT(\"'%s' expects at most r%d\"), op, 31));\n            return 0;\n        } else {\n            return regno;\n        }\n    }\nmalformed:\n    emit_inline_thumb_error_exc(emit,\n        mp_obj_new_exception_msg_varg(&mp_type_SyntaxError,\n            MP_ERROR_TEXT(\"'%s' expects an FPU register\"), op));\n    return 0;\n}\n\nstatic mp_uint_t get_arg_reglist(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn) {\n    \n\n    if (!MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_atom_brace)) {\n        goto bad_arg;\n    }\n\n    mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n    assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 1); \n    pn = pns->nodes[0];\n\n    mp_uint_t reglist = 0;\n\n    if (MP_PARSE_NODE_IS_ID(pn)) {\n        \n        reglist |= 1 << get_arg_reg(emit, op, pn, 15);\n    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n        pns = (mp_parse_node_struct_t *)pn;\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_dictorsetmaker) {\n            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); \n            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t *)pns->nodes[1];\n            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_dictorsetmaker_list) {\n                \n\n                \n                reglist |= 1 << get_arg_reg(emit, op, pns->nodes[0], 15);\n\n                \n                mp_parse_node_t *nodes;\n                int n = mp_parse_node_extract_list(&pns1->nodes[0], PN_dictorsetmaker_list2, &nodes);\n\n                \n                for (int i = 0; i < n; i++) {\n                    reglist |= 1 << get_arg_reg(emit, op, nodes[i], 15);\n                }\n            } else {\n                goto bad_arg;\n            }\n        } else {\n            goto bad_arg;\n        }\n    } else {\n        goto bad_arg;\n    }\n\n    return reglist;\n\nbad_arg:\n    emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' expects {r0, r1, ...}\"), op));\n    return 0;\n}\n\nstatic uint32_t get_arg_i(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn, uint32_t fit_mask) {\n    mp_obj_t o;\n    if (!mp_parse_node_get_int_maybe(pn, &o)) {\n        emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' expects an integer\"), op));\n        return 0;\n    }\n    uint32_t i = mp_obj_get_int_truncated(o);\n    if ((i & (~fit_mask)) != 0) {\n        emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' integer 0x%x doesn't fit in mask 0x%x\"), op, i, fit_mask));\n        return 0;\n    }\n    return i;\n}\n\nstatic bool get_arg_addr(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn, mp_parse_node_t *pn_base, mp_parse_node_t *pn_offset) {\n    if (!MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_atom_bracket)) {\n        goto bad_arg;\n    }\n    mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n    if (!MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)) {\n        goto bad_arg;\n    }\n    pns = (mp_parse_node_struct_t *)pns->nodes[0];\n    if (MP_PARSE_NODE_STRUCT_NUM_NODES(pns) != 2) {\n        goto bad_arg;\n    }\n\n    *pn_base = pns->nodes[0];\n    *pn_offset = pns->nodes[1];\n    return true;\n\nbad_arg:\n    emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' expects an address of the form [a, b]\"), op));\n    return false;\n}\n\nstatic int get_arg_label(emit_inline_asm_t *emit, const char *op, mp_parse_node_t pn) {\n    if (!MP_PARSE_NODE_IS_ID(pn)) {\n        emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"'%s' expects a label\"), op));\n        return 0;\n    }\n    qstr label_qstr = MP_PARSE_NODE_LEAF_ARG(pn);\n    for (uint i = 0; i < emit->max_num_labels; i++) {\n        if (emit->label_lookup[i] == label_qstr) {\n            return i;\n        }\n    }\n    \n    if (emit->pass == MP_PASS_EMIT) {\n        emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"label '%q' not defined\"), label_qstr));\n    }\n    return 0;\n}\n\ntypedef struct _cc_name_t { byte cc;\n                            byte name[2];\n} cc_name_t;\nstatic const cc_name_t cc_name_table[] = {\n    { ASM_THUMB_CC_EQ, \"eq\" },\n    { ASM_THUMB_CC_NE, \"ne\" },\n    { ASM_THUMB_CC_CS, \"cs\" },\n    { ASM_THUMB_CC_CC, \"cc\" },\n    { ASM_THUMB_CC_MI, \"mi\" },\n    { ASM_THUMB_CC_PL, \"pl\" },\n    { ASM_THUMB_CC_VS, \"vs\" },\n    { ASM_THUMB_CC_VC, \"vc\" },\n    { ASM_THUMB_CC_HI, \"hi\" },\n    { ASM_THUMB_CC_LS, \"ls\" },\n    { ASM_THUMB_CC_GE, \"ge\" },\n    { ASM_THUMB_CC_LT, \"lt\" },\n    { ASM_THUMB_CC_GT, \"gt\" },\n    { ASM_THUMB_CC_LE, \"le\" },\n};\n\ntypedef struct _format_4_op_t { byte op;\n                                char name[3];\n} format_4_op_t;\n#define X(x) (((x) >> 4) & 0xff) \nstatic const format_4_op_t format_4_op_table[] = {\n    { X(ASM_THUMB_FORMAT_4_EOR), \"eor\" },\n    { X(ASM_THUMB_FORMAT_4_LSL), \"lsl\" },\n    { X(ASM_THUMB_FORMAT_4_LSR), \"lsr\" },\n    { X(ASM_THUMB_FORMAT_4_ASR), \"asr\" },\n    { X(ASM_THUMB_FORMAT_4_ADC), \"adc\" },\n    { X(ASM_THUMB_FORMAT_4_SBC), \"sbc\" },\n    { X(ASM_THUMB_FORMAT_4_ROR), \"ror\" },\n    { X(ASM_THUMB_FORMAT_4_TST), \"tst\" },\n    { X(ASM_THUMB_FORMAT_4_NEG), \"neg\" },\n    { X(ASM_THUMB_FORMAT_4_CMP), \"cmp\" },\n    { X(ASM_THUMB_FORMAT_4_CMN), \"cmn\" },\n    { X(ASM_THUMB_FORMAT_4_ORR), \"orr\" },\n    { X(ASM_THUMB_FORMAT_4_MUL), \"mul\" },\n    { X(ASM_THUMB_FORMAT_4_BIC), \"bic\" },\n    { X(ASM_THUMB_FORMAT_4_MVN), \"mvn\" },\n};\n#undef X\n\n\ntypedef struct _format_9_10_op_t { uint16_t op;\n                                   uint16_t name;\n} format_9_10_op_t;\n#define X(x) (x)\nstatic const format_9_10_op_t format_9_10_op_table[] = {\n    { X(ASM_THUMB_FORMAT_9_LDR | ASM_THUMB_FORMAT_9_WORD_TRANSFER), MP_QSTR_ldr },\n    { X(ASM_THUMB_FORMAT_9_LDR | ASM_THUMB_FORMAT_9_BYTE_TRANSFER), MP_QSTR_ldrb },\n    { X(ASM_THUMB_FORMAT_10_LDRH), MP_QSTR_ldrh },\n    { X(ASM_THUMB_FORMAT_9_STR | ASM_THUMB_FORMAT_9_WORD_TRANSFER), MP_QSTR_str },\n    { X(ASM_THUMB_FORMAT_9_STR | ASM_THUMB_FORMAT_9_BYTE_TRANSFER), MP_QSTR_strb },\n    { X(ASM_THUMB_FORMAT_10_STRH), MP_QSTR_strh },\n};\n#undef X\n\n\ntypedef struct _format_vfp_op_t {\n    byte op;\n    char name[3];\n} format_vfp_op_t;\nstatic const format_vfp_op_t format_vfp_op_table[] = {\n    { 0x30, \"add\" },\n    { 0x34, \"sub\" },\n    { 0x20, \"mul\" },\n    { 0x80, \"div\" },\n};\n\n\n#define ARMV7M asm_thumb_allow_armv7m(&emit->as)\n\nstatic void emit_inline_thumb_op(emit_inline_asm_t *emit, qstr op, mp_uint_t n_args, mp_parse_node_t *pn_args) {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    size_t op_len;\n    const char *op_str = (const char *)qstr_data(op, &op_len);\n\n    if (emit_inline_thumb_allow_float(emit) && op_str[0] == 'v') {\n        \n        if (n_args == 2) {\n            mp_uint_t op_code = 0x0ac0, op_code_hi;\n            if (op == MP_QSTR_vcmp) {\n                op_code_hi = 0xeeb4;\n            op_vfp_twoargs:;\n                mp_uint_t vd = get_arg_vfpreg(emit, op_str, pn_args[0]);\n                mp_uint_t vm = get_arg_vfpreg(emit, op_str, pn_args[1]);\n                asm_thumb_op32(&emit->as,\n                    op_code_hi | ((vd & 1) << 6),\n                    op_code | ((vd & 0x1e) << 11) | ((vm & 1) << 5) | (vm & 0x1e) >> 1);\n            } else if (op == MP_QSTR_vsqrt) {\n                op_code_hi = 0xeeb1;\n                goto op_vfp_twoargs;\n            } else if (op == MP_QSTR_vneg) {\n                op_code_hi = 0xeeb1;\n                op_code = 0x0a40;\n                goto op_vfp_twoargs;\n            } else if (op == MP_QSTR_vcvt_f32_s32) {\n                op_code_hi = 0xeeb8; \n                goto op_vfp_twoargs;\n            } else if (op == MP_QSTR_vcvt_s32_f32) {\n                op_code_hi = 0xeebd; \n                goto op_vfp_twoargs;\n            } else if (op == MP_QSTR_vmrs) {\n                mp_uint_t reg_dest;\n                const char *reg_str0 = get_arg_str(pn_args[0]);\n                if (strcmp(reg_str0, \"APSR_nzcv\") == 0) {\n                    reg_dest = 15;\n                } else {\n                    reg_dest = get_arg_reg(emit, op_str, pn_args[0], 15);\n                }\n                const char *reg_str1 = get_arg_str(pn_args[1]);\n                if (strcmp(reg_str1, \"FPSCR\") == 0) {\n                    \n                    asm_thumb_op32(&emit->as, 0xeef1, 0x0a10 | (reg_dest << 12));\n                } else {\n                    goto unknown_op;\n                }\n            } else if (op == MP_QSTR_vmov) {\n                op_code_hi = 0xee00;\n                mp_uint_t r_arm, vm;\n                const char *reg_str = get_arg_str(pn_args[0]);\n                if (reg_str[0] == 'r') {\n                    r_arm = get_arg_reg(emit, op_str, pn_args[0], 15);\n                    vm = get_arg_vfpreg(emit, op_str, pn_args[1]);\n                    op_code_hi |= 0x10;\n                } else {\n                    vm = get_arg_vfpreg(emit, op_str, pn_args[0]);\n                    r_arm = get_arg_reg(emit, op_str, pn_args[1], 15);\n                }\n                asm_thumb_op32(&emit->as,\n                    op_code_hi | ((vm & 0x1e) >> 1),\n                    0x0a10 | (r_arm << 12) | ((vm & 1) << 7));\n            } else if (op == MP_QSTR_vldr) {\n                op_code_hi = 0xed90;\n            op_vldr_vstr:;\n                mp_uint_t vd = get_arg_vfpreg(emit, op_str, pn_args[0]);\n                mp_parse_node_t pn_base, pn_offset;\n                if (get_arg_addr(emit, op_str, pn_args[1], &pn_base, &pn_offset)) {\n                    mp_uint_t rlo_base = get_arg_reg(emit, op_str, pn_base, 7);\n                    mp_uint_t i8;\n                    i8 = get_arg_i(emit, op_str, pn_offset, 0x3fc) >> 2;\n                    asm_thumb_op32(&emit->as,\n                        op_code_hi | rlo_base | ((vd & 1) << 6),\n                        0x0a00 | ((vd & 0x1e) << 11) | i8);\n                }\n            } else if (op == MP_QSTR_vstr) {\n                op_code_hi = 0xed80;\n                goto op_vldr_vstr;\n            } else {\n                goto unknown_op;\n            }\n        } else if (n_args == 3) {\n            \n            for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(format_vfp_op_table); i++) {\n                if (strncmp(op_str + 1, format_vfp_op_table[i].name, 3) == 0 && op_str[4] == '\\0') {\n                    mp_uint_t op_code_hi = 0xee00 | (format_vfp_op_table[i].op & 0xf0);\n                    mp_uint_t op_code = 0x0a00 | ((format_vfp_op_table[i].op & 0x0f) << 4);\n                    mp_uint_t vd = get_arg_vfpreg(emit, op_str, pn_args[0]);\n                    mp_uint_t vn = get_arg_vfpreg(emit, op_str, pn_args[1]);\n                    mp_uint_t vm = get_arg_vfpreg(emit, op_str, pn_args[2]);\n                    asm_thumb_op32(&emit->as,\n                        op_code_hi | ((vd & 1) << 6) | (vn >> 1),\n                        op_code | (vm >> 1) | ((vm & 1) << 5) | ((vd & 0x1e) << 11) | ((vn & 1) << 7));\n                    return;\n                }\n            }\n            goto unknown_op;\n        } else {\n            goto unknown_op;\n        }\n        return;\n    }\n\n    if (n_args == 0) {\n        if (op == MP_QSTR_nop) {\n            asm_thumb_op16(&emit->as, ASM_THUMB_OP_NOP);\n        } else if (op == MP_QSTR_wfi) {\n            asm_thumb_op16(&emit->as, ASM_THUMB_OP_WFI);\n        } else {\n            goto unknown_op;\n        }\n\n    } else if (n_args == 1) {\n        if (op == MP_QSTR_b) {\n            int label_num = get_arg_label(emit, op_str, pn_args[0]);\n            if (!asm_thumb_b_n_label(&emit->as, label_num)) {\n                goto branch_not_in_range;\n            }\n        } else if (op == MP_QSTR_bl) {\n            int label_num = get_arg_label(emit, op_str, pn_args[0]);\n            if (!asm_thumb_bl_label(&emit->as, label_num)) {\n                goto branch_not_in_range;\n            }\n        } else if (op == MP_QSTR_bx) {\n            mp_uint_t r = get_arg_reg(emit, op_str, pn_args[0], 15);\n            asm_thumb_op16(&emit->as, 0x4700 | (r << 3));\n        } else if (op_str[0] == 'b' && (op_len == 3\n                                        || (op_len == 5 && op_str[3] == '_'\n                                            && (op_str[4] == 'n' || (ARMV7M && op_str[4] == 'w'))))) {\n            mp_uint_t cc = -1;\n            for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(cc_name_table); i++) {\n                if (op_str[1] == cc_name_table[i].name[0] && op_str[2] == cc_name_table[i].name[1]) {\n                    cc = cc_name_table[i].cc;\n                }\n            }\n            if (cc == (mp_uint_t)-1) {\n                goto unknown_op;\n            }\n            int label_num = get_arg_label(emit, op_str, pn_args[0]);\n            bool wide = op_len == 5 && op_str[4] == 'w';\n            if (wide && !ARMV7M) {\n                goto unknown_op;\n            }\n            if (!asm_thumb_bcc_nw_label(&emit->as, cc, label_num, wide)) {\n                goto branch_not_in_range;\n            }\n        } else if (ARMV7M && op_str[0] == 'i' && op_str[1] == 't') {\n            const char *arg_str = get_arg_str(pn_args[0]);\n            mp_uint_t cc = -1;\n            for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(cc_name_table); i++) {\n                if (arg_str[0] == cc_name_table[i].name[0]\n                    && arg_str[1] == cc_name_table[i].name[1]\n                    && arg_str[2] == '\\0') {\n                    cc = cc_name_table[i].cc;\n                    break;\n                }\n            }\n            if (cc == (mp_uint_t)-1) {\n                goto unknown_op;\n            }\n            const char *os = op_str + 2;\n            while (*os != '\\0') {\n                os++;\n            }\n            if (os > op_str + 5) {\n                goto unknown_op;\n            }\n            mp_uint_t it_mask = 8;\n            while (--os >= op_str + 2) {\n                it_mask >>= 1;\n                if (*os == 't') {\n                    it_mask |= (cc & 1) << 3;\n                } else if (*os == 'e') {\n                    it_mask |= ((~cc) & 1) << 3;\n                } else {\n                    goto unknown_op;\n                }\n            }\n            asm_thumb_it_cc(&emit->as, cc, it_mask);\n        } else if (op == MP_QSTR_cpsid) {\n            \n            asm_thumb_op16(&emit->as, ASM_THUMB_OP_CPSID_I);\n        } else if (op == MP_QSTR_cpsie) {\n            \n            asm_thumb_op16(&emit->as, ASM_THUMB_OP_CPSIE_I);\n        } else if (op == MP_QSTR_push) {\n            mp_uint_t reglist = get_arg_reglist(emit, op_str, pn_args[0]);\n            if ((reglist & 0xbf00) == 0) {\n                if ((reglist & (1 << 14)) == 0) {\n                    asm_thumb_op16(&emit->as, 0xb400 | reglist);\n                } else {\n                    \n                    asm_thumb_op16(&emit->as, 0xb500 | (reglist & 0xff));\n                }\n            } else {\n                if (!ARMV7M) {\n                    goto unknown_op;\n                }\n                asm_thumb_op32(&emit->as, 0xe92d, reglist);\n            }\n        } else if (op == MP_QSTR_pop) {\n            mp_uint_t reglist = get_arg_reglist(emit, op_str, pn_args[0]);\n            if ((reglist & 0x7f00) == 0) {\n                if ((reglist & (1 << 15)) == 0) {\n                    asm_thumb_op16(&emit->as, 0xbc00 | reglist);\n                } else {\n                    \n                    asm_thumb_op16(&emit->as, 0xbd00 | (reglist & 0xff));\n                }\n            } else {\n                if (!ARMV7M) {\n                    goto unknown_op;\n                }\n                asm_thumb_op32(&emit->as, 0xe8bd, reglist);\n            }\n        } else {\n            goto unknown_op;\n        }\n\n    } else if (n_args == 2) {\n        if (MP_PARSE_NODE_IS_ID(pn_args[1])) {\n            \n            mp_uint_t op_code, op_code_hi;\n            if (op == MP_QSTR_mov) {\n                mp_uint_t reg_dest = get_arg_reg(emit, op_str, pn_args[0], 15);\n                mp_uint_t reg_src = get_arg_reg(emit, op_str, pn_args[1], 15);\n                asm_thumb_mov_reg_reg(&emit->as, reg_dest, reg_src);\n            } else if (ARMV7M && op == MP_QSTR_clz) {\n                op_code_hi = 0xfab0;\n                op_code = 0xf080;\n                mp_uint_t rd, rm;\n            op_clz_rbit:\n                rd = get_arg_reg(emit, op_str, pn_args[0], 15);\n                rm = get_arg_reg(emit, op_str, pn_args[1], 15);\n                asm_thumb_op32(&emit->as, op_code_hi | rm, op_code | (rd << 8) | rm);\n            } else if (ARMV7M && op == MP_QSTR_rbit) {\n                op_code_hi = 0xfa90;\n                op_code = 0xf0a0;\n                goto op_clz_rbit;\n            } else if (ARMV7M && op == MP_QSTR_mrs) {\n                mp_uint_t reg_dest = get_arg_reg(emit, op_str, pn_args[0], 12);\n                mp_uint_t reg_src = get_arg_special_reg(emit, op_str, pn_args[1]);\n                asm_thumb_op32(&emit->as, 0xf3ef, 0x8000 | (reg_dest << 8) | reg_src);\n            } else {\n                if (op == MP_QSTR_and_) {\n                    op_code = ASM_THUMB_FORMAT_4_AND;\n                    mp_uint_t reg_dest, reg_src;\n                op_format_4:\n                    reg_dest = get_arg_reg(emit, op_str, pn_args[0], 7);\n                    reg_src = get_arg_reg(emit, op_str, pn_args[1], 7);\n                    asm_thumb_format_4(&emit->as, op_code, reg_dest, reg_src);\n                    return;\n                }\n                \n                for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(format_4_op_table); i++) {\n                    if (strncmp(op_str, format_4_op_table[i].name, 3) == 0 && op_str[3] == '\\0') {\n                        op_code = 0x4000 | (format_4_op_table[i].op << 4);\n                        goto op_format_4;\n                    }\n                }\n                goto unknown_op;\n            }\n        } else {\n            \n            mp_uint_t op_code;\n            if (op == MP_QSTR_mov) {\n                op_code = ASM_THUMB_FORMAT_3_MOV;\n                mp_uint_t rlo_dest, i8_src;\n            op_format_3:\n                rlo_dest = get_arg_reg(emit, op_str, pn_args[0], 7);\n                i8_src = get_arg_i(emit, op_str, pn_args[1], 0xff);\n                asm_thumb_format_3(&emit->as, op_code, rlo_dest, i8_src);\n            } else if (op == MP_QSTR_cmp) {\n                op_code = ASM_THUMB_FORMAT_3_CMP;\n                goto op_format_3;\n            } else if (op == MP_QSTR_add) {\n                op_code = ASM_THUMB_FORMAT_3_ADD;\n                goto op_format_3;\n            } else if (op == MP_QSTR_sub) {\n                op_code = ASM_THUMB_FORMAT_3_SUB;\n                goto op_format_3;\n            } else if (ARMV7M && op == MP_QSTR_movw) {\n                op_code = ASM_THUMB_OP_MOVW;\n                mp_uint_t reg_dest;\n            op_movw_movt:\n                reg_dest = get_arg_reg(emit, op_str, pn_args[0], 15);\n                int i_src = get_arg_i(emit, op_str, pn_args[1], 0xffff);\n                asm_thumb_mov_reg_i16(&emit->as, op_code, reg_dest, i_src);\n            } else if (ARMV7M && op == MP_QSTR_movt) {\n                op_code = ASM_THUMB_OP_MOVT;\n                goto op_movw_movt;\n            } else if (ARMV7M && op == MP_QSTR_movwt) {\n                \n                mp_uint_t reg_dest = get_arg_reg(emit, op_str, pn_args[0], 15);\n                uint32_t i_src = get_arg_i(emit, op_str, pn_args[1], 0xffffffff);\n                asm_thumb_mov_reg_i16(&emit->as, ASM_THUMB_OP_MOVW, reg_dest, i_src & 0xffff);\n                asm_thumb_mov_reg_i16(&emit->as, ASM_THUMB_OP_MOVT, reg_dest, (i_src >> 16) & 0xffff);\n            } else if (ARMV7M && op == MP_QSTR_ldrex) {\n                mp_uint_t r_dest = get_arg_reg(emit, op_str, pn_args[0], 15);\n                mp_parse_node_t pn_base, pn_offset;\n                if (get_arg_addr(emit, op_str, pn_args[1], &pn_base, &pn_offset)) {\n                    mp_uint_t r_base = get_arg_reg(emit, op_str, pn_base, 15);\n                    mp_uint_t i8 = get_arg_i(emit, op_str, pn_offset, 0xff) >> 2;\n                    asm_thumb_op32(&emit->as, 0xe850 | r_base, 0x0f00 | (r_dest << 12) | i8);\n                }\n            } else {\n                \n                for (mp_uint_t i = 0; i < MP_ARRAY_SIZE(format_9_10_op_table); i++) {\n                    if (op == format_9_10_op_table[i].name) {\n                        op_code = format_9_10_op_table[i].op;\n                        mp_parse_node_t pn_base, pn_offset;\n                        mp_uint_t rlo_dest = get_arg_reg(emit, op_str, pn_args[0], 7);\n                        if (get_arg_addr(emit, op_str, pn_args[1], &pn_base, &pn_offset)) {\n                            mp_uint_t rlo_base = get_arg_reg(emit, op_str, pn_base, 7);\n                            mp_uint_t i5;\n                            if (op_code & ASM_THUMB_FORMAT_9_BYTE_TRANSFER) {\n                                i5 = get_arg_i(emit, op_str, pn_offset, 0x1f);\n                            } else if (op_code & ASM_THUMB_FORMAT_10_STRH) { \n                                i5 = get_arg_i(emit, op_str, pn_offset, 0x3e) >> 1;\n                            } else {\n                                i5 = get_arg_i(emit, op_str, pn_offset, 0x7c) >> 2;\n                            }\n                            asm_thumb_format_9_10(&emit->as, op_code, rlo_dest, rlo_base, i5);\n                            return;\n                        }\n                        break;\n                    }\n                }\n                goto unknown_op;\n            }\n        }\n\n    } else if (n_args == 3) {\n        mp_uint_t op_code;\n        if (op == MP_QSTR_lsl) {\n            op_code = ASM_THUMB_FORMAT_1_LSL;\n            mp_uint_t rlo_dest, rlo_src, i5;\n        op_format_1:\n            rlo_dest = get_arg_reg(emit, op_str, pn_args[0], 7);\n            rlo_src = get_arg_reg(emit, op_str, pn_args[1], 7);\n            i5 = get_arg_i(emit, op_str, pn_args[2], 0x1f);\n            asm_thumb_format_1(&emit->as, op_code, rlo_dest, rlo_src, i5);\n        } else if (op == MP_QSTR_lsr) {\n            op_code = ASM_THUMB_FORMAT_1_LSR;\n            goto op_format_1;\n        } else if (op == MP_QSTR_asr) {\n            op_code = ASM_THUMB_FORMAT_1_ASR;\n            goto op_format_1;\n        } else if (op == MP_QSTR_add) {\n            op_code = ASM_THUMB_FORMAT_2_ADD;\n            mp_uint_t rlo_dest, rlo_src;\n        op_format_2:\n            rlo_dest = get_arg_reg(emit, op_str, pn_args[0], 7);\n            rlo_src = get_arg_reg(emit, op_str, pn_args[1], 7);\n            int src_b;\n            if (MP_PARSE_NODE_IS_ID(pn_args[2])) {\n                op_code |= ASM_THUMB_FORMAT_2_REG_OPERAND;\n                src_b = get_arg_reg(emit, op_str, pn_args[2], 7);\n            } else {\n                op_code |= ASM_THUMB_FORMAT_2_IMM_OPERAND;\n                src_b = get_arg_i(emit, op_str, pn_args[2], 0x7);\n            }\n            asm_thumb_format_2(&emit->as, op_code, rlo_dest, rlo_src, src_b);\n        } else if (ARMV7M && op == MP_QSTR_sdiv) {\n            op_code = 0xfb90; \n            mp_uint_t rd, rn, rm;\n        op_sdiv_udiv:\n            rd = get_arg_reg(emit, op_str, pn_args[0], 15);\n            rn = get_arg_reg(emit, op_str, pn_args[1], 15);\n            rm = get_arg_reg(emit, op_str, pn_args[2], 15);\n            asm_thumb_op32(&emit->as, op_code | rn, 0xf0f0 | (rd << 8) | rm);\n        } else if (ARMV7M && op == MP_QSTR_udiv) {\n            op_code = 0xfbb0; \n            goto op_sdiv_udiv;\n        } else if (op == MP_QSTR_sub) {\n            op_code = ASM_THUMB_FORMAT_2_SUB;\n            goto op_format_2;\n        } else if (ARMV7M && op == MP_QSTR_strex) {\n            mp_uint_t r_dest = get_arg_reg(emit, op_str, pn_args[0], 15);\n            mp_uint_t r_src = get_arg_reg(emit, op_str, pn_args[1], 15);\n            mp_parse_node_t pn_base, pn_offset;\n            if (get_arg_addr(emit, op_str, pn_args[2], &pn_base, &pn_offset)) {\n                mp_uint_t r_base = get_arg_reg(emit, op_str, pn_base, 15);\n                mp_uint_t i8 = get_arg_i(emit, op_str, pn_offset, 0xff) >> 2;\n                asm_thumb_op32(&emit->as, 0xe840 | r_base, (r_src << 12) | (r_dest << 8) | i8);\n            }\n        } else {\n            goto unknown_op;\n        }\n\n    } else {\n        goto unknown_op;\n    }\n\n    return;\n\nunknown_op:\n    emit_inline_thumb_error_exc(emit, mp_obj_new_exception_msg_varg(&mp_type_SyntaxError, MP_ERROR_TEXT(\"unsupported Thumb instruction '%s' with %d arguments\"), op_str, n_args));\n    return;\n\nbranch_not_in_range:\n    emit_inline_thumb_error_msg(emit, MP_ERROR_TEXT(\"branch not in range\"));\n    return;\n}\n\nconst emit_inline_asm_method_table_t emit_inline_thumb_method_table = {\n    #if MICROPY_DYNAMIC_COMPILER\n    emit_inline_thumb_new,\n    emit_inline_thumb_free,\n    #endif\n\n    emit_inline_thumb_start_pass,\n    emit_inline_thumb_end_pass,\n    emit_inline_thumb_count_params,\n    emit_inline_thumb_label,\n    emit_inline_thumb_op,\n};\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}