{
  "module_name": "objdict.c",
  "hash_id": "e80d1da36d5290d9c224019f6b761da647ddbdeb0658b8b2b417bd5049f0c52c",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objdict.c",
  "human_readable_source": " \n\n#include <string.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n#include \"py/objtype.h\"\n#include \"py/objstr.h\"\n\nbool mp_obj_is_dict_or_ordereddict(mp_obj_t o) {\n    return mp_obj_is_obj(o) && MP_OBJ_TYPE_GET_SLOT_OR_NULL(((mp_obj_base_t *)MP_OBJ_TO_PTR(o))->type, make_new) == mp_obj_dict_make_new;\n}\n\nconst mp_obj_dict_t mp_const_empty_dict_obj = {\n    .base = { .type = &mp_type_dict },\n    .map = {\n        .all_keys_are_qstrs = 0,\n        .is_fixed = 1,\n        .is_ordered = 1,\n        .used = 0,\n        .alloc = 0,\n        .table = NULL,\n    }\n};\n\nstatic mp_obj_t dict_update(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs);\n\n\n\n\nstatic mp_map_elem_t *dict_iter_next(mp_obj_dict_t *dict, size_t *cur) {\n    size_t max = dict->map.alloc;\n    mp_map_t *map = &dict->map;\n\n    size_t i = *cur;\n    for (; i < max; i++) {\n        if (mp_map_slot_is_filled(map, i)) {\n            *cur = i + 1;\n            return &(map->table[i]);\n        }\n    }\n\n    assert(map->used == 0 || i == max);\n    return NULL;\n}\n\nstatic void dict_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    bool first = true;\n    const char *item_separator = \", \";\n    const char *key_separator = \": \";\n    if (!(MICROPY_PY_JSON && kind == PRINT_JSON)) {\n        kind = PRINT_REPR;\n    } else {\n        #if MICROPY_PY_JSON_SEPARATORS\n        item_separator = MP_PRINT_GET_EXT(print)->item_separator;\n        key_separator = MP_PRINT_GET_EXT(print)->key_separator;\n        #endif\n    }\n    if (MICROPY_PY_COLLECTIONS_ORDEREDDICT && self->base.type != &mp_type_dict && kind != PRINT_JSON) {\n        mp_printf(print, \"%q(\", self->base.type->name);\n    }\n    mp_print_str(print, \"{\");\n    size_t cur = 0;\n    mp_map_elem_t *next = NULL;\n    while ((next = dict_iter_next(self, &cur)) != NULL) {\n        if (!first) {\n            mp_print_str(print, item_separator);\n        }\n        first = false;\n        bool add_quote = MICROPY_PY_JSON && kind == PRINT_JSON && !mp_obj_is_str_or_bytes(next->key);\n        if (add_quote) {\n            mp_print_str(print, \"\\\"\");\n        }\n        mp_obj_print_helper(print, next->key, kind);\n        if (add_quote) {\n            mp_print_str(print, \"\\\"\");\n        }\n        mp_print_str(print, key_separator);\n        mp_obj_print_helper(print, next->value, kind);\n    }\n    mp_print_str(print, \"}\");\n    if (MICROPY_PY_COLLECTIONS_ORDEREDDICT && self->base.type != &mp_type_dict && kind != PRINT_JSON) {\n        mp_print_str(print, \")\");\n    }\n}\n\nmp_obj_t mp_obj_dict_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_obj_t dict_out = mp_obj_new_dict(0);\n    mp_obj_dict_t *dict = MP_OBJ_TO_PTR(dict_out);\n    dict->base.type = type;\n    #if MICROPY_PY_COLLECTIONS_ORDEREDDICT\n    if (type == &mp_type_ordereddict) {\n        dict->map.is_ordered = 1;\n    }\n    #endif\n    if (n_args > 0 || n_kw > 0) {\n        mp_obj_t args2[2] = {dict_out, args[0]}; \n        mp_map_t kwargs;\n        mp_map_init_fixed_table(&kwargs, n_kw, args + n_args);\n        dict_update(n_args + 1, args2, &kwargs); \n    }\n    return dict_out;\n}\n\nstatic mp_obj_t dict_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(self->map.used != 0);\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(self->map.used);\n        #if MICROPY_PY_SYS_GETSIZEOF\n        case MP_UNARY_OP_SIZEOF: {\n            size_t sz = sizeof(*self) + sizeof(*self->map.table) * self->map.alloc;\n            return MP_OBJ_NEW_SMALL_INT(sz);\n        }\n        #endif\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_obj_t dict_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    mp_obj_dict_t *o = MP_OBJ_TO_PTR(lhs_in);\n    switch (op) {\n        case MP_BINARY_OP_CONTAINS: {\n            mp_map_elem_t *elem = mp_map_lookup(&o->map, rhs_in, MP_MAP_LOOKUP);\n            return mp_obj_new_bool(elem != NULL);\n        }\n        case MP_BINARY_OP_EQUAL: {\n            #if MICROPY_PY_COLLECTIONS_ORDEREDDICT\n            if (MP_UNLIKELY(mp_obj_is_type(lhs_in, &mp_type_ordereddict) && mp_obj_is_type(rhs_in, &mp_type_ordereddict))) {\n                \n                mp_obj_dict_t *rhs = MP_OBJ_TO_PTR(rhs_in);\n                size_t c1 = 0, c2 = 0;\n                mp_map_elem_t *e1 = dict_iter_next(o, &c1), *e2 = dict_iter_next(rhs, &c2);\n                for (; e1 != NULL && e2 != NULL; e1 = dict_iter_next(o, &c1), e2 = dict_iter_next(rhs, &c2)) {\n                    if (!mp_obj_equal(e1->key, e2->key) || !mp_obj_equal(e1->value, e2->value)) {\n                        return mp_const_false;\n                    }\n                }\n                return e1 == NULL && e2 == NULL ? mp_const_true : mp_const_false;\n            }\n            #endif\n\n            if (mp_obj_is_type(rhs_in, &mp_type_dict)) {\n                mp_obj_dict_t *rhs = MP_OBJ_TO_PTR(rhs_in);\n                if (o->map.used != rhs->map.used) {\n                    return mp_const_false;\n                }\n\n                size_t cur = 0;\n                mp_map_elem_t *next = NULL;\n                while ((next = dict_iter_next(o, &cur)) != NULL) {\n                    mp_map_elem_t *elem = mp_map_lookup(&rhs->map, next->key, MP_MAP_LOOKUP);\n                    if (elem == NULL || !mp_obj_equal(next->value, elem->value)) {\n                        return mp_const_false;\n                    }\n                }\n                return mp_const_true;\n            } else {\n                \n                return mp_const_false;\n            }\n        }\n        #if MICROPY_CPYTHON_COMPAT\n        case MP_BINARY_OP_INPLACE_OR:\n        case MP_BINARY_OP_OR: {\n            if (op == MP_BINARY_OP_OR) {\n                lhs_in = mp_obj_dict_copy(lhs_in);\n            }\n            mp_obj_t dicts[2] = {lhs_in, rhs_in};\n            dict_update(2, dicts, (mp_map_t *)&mp_const_empty_map);\n            return lhs_in;\n        }\n        #endif\n        default:\n            \n            return MP_OBJ_NULL;\n    }\n}\n\n\nmp_obj_t mp_obj_dict_get(mp_obj_t self_in, mp_obj_t index) {\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *elem = mp_map_lookup(&self->map, index, MP_MAP_LOOKUP);\n    if (elem == NULL) {\n        mp_raise_type_arg(&mp_type_KeyError, index);\n    } else {\n        return elem->value;\n    }\n}\n\nstatic mp_obj_t dict_subscr(mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {\n    if (value == MP_OBJ_NULL) {\n        \n        mp_obj_dict_delete(self_in, index);\n        return mp_const_none;\n    } else if (value == MP_OBJ_SENTINEL) {\n        \n        mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n        mp_map_elem_t *elem = mp_map_lookup(&self->map, index, MP_MAP_LOOKUP);\n        if (elem == NULL) {\n            mp_raise_type_arg(&mp_type_KeyError, index);\n        } else {\n            return elem->value;\n        }\n    } else {\n        \n        mp_obj_dict_store(self_in, index, value);\n        return mp_const_none;\n    }\n}\n\n \n \n\nstatic void mp_ensure_not_fixed(const mp_obj_dict_t *dict) {\n    if (dict->map.is_fixed) {\n        mp_raise_TypeError(NULL);\n    }\n}\n\nstatic mp_obj_t dict_clear(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(self_in));\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_ensure_not_fixed(self);\n\n    mp_map_clear(&self->map);\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(dict_clear_obj, dict_clear);\n\nmp_obj_t mp_obj_dict_copy(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(self_in));\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t other_out = mp_obj_new_dict(self->map.alloc);\n    mp_obj_dict_t *other = MP_OBJ_TO_PTR(other_out);\n    other->base.type = self->base.type;\n    other->map.used = self->map.used;\n    other->map.all_keys_are_qstrs = self->map.all_keys_are_qstrs;\n    other->map.is_fixed = 0;\n    other->map.is_ordered = self->map.is_ordered;\n    memcpy(other->map.table, self->map.table, self->map.alloc * sizeof(mp_map_elem_t));\n    return other_out;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(dict_copy_obj, mp_obj_dict_copy);\n\n#if MICROPY_PY_BUILTINS_DICT_FROMKEYS\n\nstatic mp_obj_t dict_fromkeys(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t iter = mp_getiter(args[1], NULL);\n    mp_obj_t value = mp_const_none;\n    mp_obj_t next = MP_OBJ_NULL;\n\n    if (n_args > 2) {\n        value = args[2];\n    }\n\n    \n    mp_obj_t self_out;\n    mp_obj_t len = mp_obj_len_maybe(args[1]);\n    if (len == MP_OBJ_NULL) {\n         \n        self_out = mp_obj_new_dict(0);\n    } else {\n        self_out = mp_obj_new_dict(MP_OBJ_SMALL_INT_VALUE(len));\n    }\n\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_out);\n    while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        mp_map_lookup(&self->map, next, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;\n    }\n\n    return self_out;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_fromkeys_fun_obj, 2, 3, dict_fromkeys);\nstatic MP_DEFINE_CONST_CLASSMETHOD_OBJ(dict_fromkeys_obj, MP_ROM_PTR(&dict_fromkeys_fun_obj));\n#endif\n\nstatic mp_obj_t dict_get_helper(size_t n_args, const mp_obj_t *args, mp_map_lookup_kind_t lookup_kind) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(args[0]));\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);\n    if (lookup_kind != MP_MAP_LOOKUP) {\n        mp_ensure_not_fixed(self);\n    }\n    mp_map_elem_t *elem = mp_map_lookup(&self->map, args[1], lookup_kind);\n    mp_obj_t value;\n    if (elem == NULL || elem->value == MP_OBJ_NULL) {\n        if (n_args == 2) {\n            if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {\n                mp_raise_type_arg(&mp_type_KeyError, args[1]);\n            } else {\n                value = mp_const_none;\n            }\n        } else {\n            value = args[2];\n        }\n        if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {\n            elem->value = value;\n        }\n    } else {\n        value = elem->value;\n        if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {\n            elem->value = MP_OBJ_NULL; \n        }\n    }\n    return value;\n}\n\nstatic mp_obj_t dict_get(size_t n_args, const mp_obj_t *args) {\n    return dict_get_helper(n_args, args, MP_MAP_LOOKUP);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_get_obj, 2, 3, dict_get);\n\nstatic mp_obj_t dict_pop(size_t n_args, const mp_obj_t *args) {\n    return dict_get_helper(n_args, args, MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_pop_obj, 2, 3, dict_pop);\n\nstatic mp_obj_t dict_setdefault(size_t n_args, const mp_obj_t *args) {\n    return dict_get_helper(n_args, args, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_setdefault_obj, 2, 3, dict_setdefault);\n\nstatic mp_obj_t dict_popitem(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(self_in));\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_ensure_not_fixed(self);\n    if (self->map.used == 0) {\n        mp_raise_msg(&mp_type_KeyError, MP_ERROR_TEXT(\"popitem(): dictionary is empty\"));\n    }\n    size_t cur = 0;\n    #if MICROPY_PY_COLLECTIONS_ORDEREDDICT\n    if (self->map.is_ordered) {\n        cur = self->map.used - 1;\n    }\n    #endif\n    mp_map_elem_t *next = dict_iter_next(self, &cur);\n    assert(next);\n    self->map.used--;\n    mp_obj_t items[] = {next->key, next->value};\n    next->key = MP_OBJ_SENTINEL; \n    next->value = MP_OBJ_NULL;\n    mp_obj_t tuple = mp_obj_new_tuple(2, items);\n\n    return tuple;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(dict_popitem_obj, dict_popitem);\n\nstatic mp_obj_t dict_update(size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(args[0]));\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);\n    mp_ensure_not_fixed(self);\n\n    mp_arg_check_num(n_args, kwargs->used, 1, 2, true);\n\n    if (n_args == 2) {\n        \n\n        if (mp_obj_is_dict_or_ordereddict(args[1])) {\n            \n            if (args[1] != args[0]) {\n                size_t cur = 0;\n                mp_map_elem_t *elem = NULL;\n                while ((elem = dict_iter_next((mp_obj_dict_t *)MP_OBJ_TO_PTR(args[1]), &cur)) != NULL) {\n                    mp_map_lookup(&self->map, elem->key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = elem->value;\n                }\n            }\n        } else {\n            \n            mp_obj_t iter = mp_getiter(args[1], NULL);\n            mp_obj_t next = MP_OBJ_NULL;\n            while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n                mp_obj_t inneriter = mp_getiter(next, NULL);\n                mp_obj_t key = mp_iternext(inneriter);\n                mp_obj_t value = mp_iternext(inneriter);\n                mp_obj_t stop = mp_iternext(inneriter);\n                if (key == MP_OBJ_STOP_ITERATION\n                    || value == MP_OBJ_STOP_ITERATION\n                    || stop != MP_OBJ_STOP_ITERATION) {\n                    mp_raise_ValueError(MP_ERROR_TEXT(\"dict update sequence has wrong length\"));\n                } else {\n                    mp_map_lookup(&self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;\n                }\n            }\n        }\n    }\n\n    \n    for (size_t i = 0; i < kwargs->alloc; i++) {\n        if (mp_map_slot_is_filled(kwargs, i)) {\n            mp_map_lookup(&self->map, kwargs->table[i].key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = kwargs->table[i].value;\n        }\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_KW(dict_update_obj, 1, dict_update);\n\n\n \n \n\nstatic const mp_obj_type_t mp_type_dict_view;\nstatic const mp_obj_type_t mp_type_dict_view_it;\n\ntypedef enum _mp_dict_view_kind_t {\n    MP_DICT_VIEW_ITEMS,\n    MP_DICT_VIEW_KEYS,\n    MP_DICT_VIEW_VALUES,\n} mp_dict_view_kind_t;\n\nstatic const char *const mp_dict_view_names[] = {\"dict_items\", \"dict_keys\", \"dict_values\"};\n\ntypedef struct _mp_obj_dict_view_it_t {\n    mp_obj_base_t base;\n    mp_dict_view_kind_t kind;\n    mp_obj_t dict;\n    size_t cur;\n} mp_obj_dict_view_it_t;\n\ntypedef struct _mp_obj_dict_view_t {\n    mp_obj_base_t base;\n    mp_obj_t dict;\n    mp_dict_view_kind_t kind;\n} mp_obj_dict_view_t;\n\nstatic mp_obj_t dict_view_it_iternext(mp_obj_t self_in) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_dict_view_it));\n    mp_obj_dict_view_it_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_map_elem_t *next = dict_iter_next(MP_OBJ_TO_PTR(self->dict), &self->cur);\n\n    if (next == NULL) {\n        return MP_OBJ_STOP_ITERATION;\n    } else {\n        switch (self->kind) {\n            case MP_DICT_VIEW_ITEMS:\n            default: {\n                mp_obj_t items[] = {next->key, next->value};\n                return mp_obj_new_tuple(2, items);\n            }\n            case MP_DICT_VIEW_KEYS:\n                return next->key;\n            case MP_DICT_VIEW_VALUES:\n                return next->value;\n        }\n    }\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_dict_view_it,\n    MP_QSTR_iterator,\n    MP_TYPE_FLAG_ITER_IS_ITERNEXT,\n    iter, dict_view_it_iternext\n    );\n\nstatic mp_obj_t dict_view_getiter(mp_obj_t view_in, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_dict_view_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_check_self(mp_obj_is_type(view_in, &mp_type_dict_view));\n    mp_obj_dict_view_t *view = MP_OBJ_TO_PTR(view_in);\n    mp_obj_dict_view_it_t *o = (mp_obj_dict_view_it_t *)iter_buf;\n    o->base.type = &mp_type_dict_view_it;\n    o->kind = view->kind;\n    o->dict = view->dict;\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic void dict_view_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_dict_view));\n    mp_obj_dict_view_t *self = MP_OBJ_TO_PTR(self_in);\n    bool first = true;\n    mp_print_str(print, mp_dict_view_names[self->kind]);\n    mp_print_str(print, \"([\");\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t self_iter = dict_view_getiter(self_in, &iter_buf);\n    mp_obj_t next = MP_OBJ_NULL;\n    while ((next = dict_view_it_iternext(self_iter)) != MP_OBJ_STOP_ITERATION) {\n        if (!first) {\n            mp_print_str(print, \", \");\n        }\n        first = false;\n        mp_obj_print_helper(print, next, PRINT_REPR);\n    }\n    mp_print_str(print, \"])\");\n}\n\nstatic mp_obj_t dict_view_unary_op(mp_unary_op_t op, mp_obj_t o_in) {\n    mp_obj_dict_view_t *o = MP_OBJ_TO_PTR(o_in);\n    \n    if (op == MP_UNARY_OP_HASH && o->kind == MP_DICT_VIEW_VALUES) {\n        return MP_OBJ_NEW_SMALL_INT((mp_uint_t)o_in);\n    }\n    return MP_OBJ_NULL;\n}\n\nstatic mp_obj_t dict_view_binary_op(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {\n    \n    mp_obj_dict_view_t *o = MP_OBJ_TO_PTR(lhs_in);\n    if (o->kind != MP_DICT_VIEW_KEYS) {\n        return MP_OBJ_NULL; \n    }\n    if (op != MP_BINARY_OP_CONTAINS) {\n        return MP_OBJ_NULL; \n    }\n    return dict_binary_op(op, o->dict, rhs_in);\n}\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_dict_view,\n    MP_QSTR_dict_view,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    print, dict_view_print,\n    unary_op, dict_view_unary_op,\n    binary_op, dict_view_binary_op,\n    iter, dict_view_getiter\n    );\n\nstatic mp_obj_t mp_obj_new_dict_view(mp_obj_t dict, mp_dict_view_kind_t kind) {\n    mp_obj_dict_view_t *o = mp_obj_malloc(mp_obj_dict_view_t, &mp_type_dict_view);\n    o->dict = dict;\n    o->kind = kind;\n    return MP_OBJ_FROM_PTR(o);\n}\n\nstatic mp_obj_t dict_view(mp_obj_t self_in, mp_dict_view_kind_t kind) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(self_in));\n    return mp_obj_new_dict_view(self_in, kind);\n}\n\nstatic mp_obj_t dict_items(mp_obj_t self_in) {\n    return dict_view(self_in, MP_DICT_VIEW_ITEMS);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(dict_items_obj, dict_items);\n\nstatic mp_obj_t dict_keys(mp_obj_t self_in) {\n    return dict_view(self_in, MP_DICT_VIEW_KEYS);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(dict_keys_obj, dict_keys);\n\nstatic mp_obj_t dict_values(mp_obj_t self_in) {\n    return dict_view(self_in, MP_DICT_VIEW_VALUES);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(dict_values_obj, dict_values);\n\n \n \n\nstatic mp_obj_t dict_getiter(mp_obj_t self_in, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_dict_view_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_check_self(mp_obj_is_dict_or_ordereddict(self_in));\n    mp_obj_dict_view_it_t *o = (mp_obj_dict_view_it_t *)iter_buf;\n    o->base.type = &mp_type_dict_view_it;\n    o->kind = MP_DICT_VIEW_KEYS;\n    o->dict = self_in;\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n \n\nstatic const mp_rom_map_elem_t dict_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&dict_clear_obj) },\n    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&dict_copy_obj) },\n    #if MICROPY_PY_BUILTINS_DICT_FROMKEYS\n    { MP_ROM_QSTR(MP_QSTR_fromkeys), MP_ROM_PTR(&dict_fromkeys_obj) },\n    #endif\n    { MP_ROM_QSTR(MP_QSTR_get), MP_ROM_PTR(&dict_get_obj) },\n    { MP_ROM_QSTR(MP_QSTR_items), MP_ROM_PTR(&dict_items_obj) },\n    { MP_ROM_QSTR(MP_QSTR_keys), MP_ROM_PTR(&dict_keys_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&dict_pop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_popitem), MP_ROM_PTR(&dict_popitem_obj) },\n    { MP_ROM_QSTR(MP_QSTR_setdefault), MP_ROM_PTR(&dict_setdefault_obj) },\n    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&dict_update_obj) },\n    { MP_ROM_QSTR(MP_QSTR_values), MP_ROM_PTR(&dict_values_obj) },\n    { MP_ROM_QSTR(MP_QSTR___getitem__), MP_ROM_PTR(&mp_op_getitem_obj) },\n    { MP_ROM_QSTR(MP_QSTR___setitem__), MP_ROM_PTR(&mp_op_setitem_obj) },\n    { MP_ROM_QSTR(MP_QSTR___delitem__), MP_ROM_PTR(&mp_op_delitem_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(dict_locals_dict, dict_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_dict,\n    MP_QSTR_dict,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, mp_obj_dict_make_new,\n    print, dict_print,\n    unary_op, dict_unary_op,\n    binary_op, dict_binary_op,\n    subscr, dict_subscr,\n    iter, dict_getiter,\n    locals_dict, &dict_locals_dict\n    );\n\n#if MICROPY_PY_COLLECTIONS_ORDEREDDICT\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_ordereddict,\n    MP_QSTR_OrderedDict,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, mp_obj_dict_make_new,\n    print, dict_print,\n    unary_op, dict_unary_op,\n    binary_op, dict_binary_op,\n    subscr, dict_subscr,\n    iter, dict_getiter,\n    parent, &mp_type_dict,\n    locals_dict, &dict_locals_dict\n    );\n#endif\n\nvoid mp_obj_dict_init(mp_obj_dict_t *dict, size_t n_args) {\n    dict->base.type = &mp_type_dict;\n    mp_map_init(&dict->map, n_args);\n}\n\nmp_obj_t mp_obj_new_dict(size_t n_args) {\n    mp_obj_dict_t *o = m_new_obj(mp_obj_dict_t);\n    mp_obj_dict_init(o, n_args);\n    return MP_OBJ_FROM_PTR(o);\n}\n\nsize_t mp_obj_dict_len(mp_obj_t self_in) {\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    return self->map.used;\n}\n\nmp_obj_t mp_obj_dict_store(mp_obj_t self_in, mp_obj_t key, mp_obj_t value) {\n    mp_check_self(mp_obj_is_dict_or_ordereddict(self_in));\n    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_ensure_not_fixed(self);\n    mp_map_lookup(&self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;\n    return self_in;\n}\n\nmp_obj_t mp_obj_dict_delete(mp_obj_t self_in, mp_obj_t key) {\n    mp_obj_t args[2] = {self_in, key};\n    dict_get_helper(2, args, MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n    return self_in;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}