{
  "module_name": "objset.c",
  "hash_id": "1fbdb8683a51421c3ea7190f89588b380876c8003c43d088695a2b657ea11243",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/objset.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/runtime.h\"\n#include \"py/builtin.h\"\n\n#if MICROPY_PY_BUILTINS_SET\n\ntypedef struct _mp_obj_set_t {\n    mp_obj_base_t base;\n    mp_set_t set;\n} mp_obj_set_t;\n\ntypedef struct _mp_obj_set_it_t {\n    mp_obj_base_t base;\n    mp_fun_1_t iternext;\n    mp_obj_set_t *set;\n    size_t cur;\n} mp_obj_set_it_t;\n\nstatic bool is_set_or_frozenset(mp_obj_t o) {\n    return mp_obj_is_type(o, &mp_type_set)\n           #if MICROPY_PY_BUILTINS_FROZENSET\n           || mp_obj_is_type(o, &mp_type_frozenset)\n           #endif\n    ;\n}\n\n\n#define check_set(o) mp_check_self(mp_obj_is_type(o, &mp_type_set))\n\n\n\n#define check_set_or_frozenset(o) mp_check_self(is_set_or_frozenset(o))\n\nstatic void set_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {\n    (void)kind;\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    #if MICROPY_PY_BUILTINS_FROZENSET\n    bool is_frozen = mp_obj_is_type(self_in, &mp_type_frozenset);\n    #endif\n    if (self->set.used == 0) {\n        #if MICROPY_PY_BUILTINS_FROZENSET\n        if (is_frozen) {\n            mp_print_str(print, \"frozen\");\n        }\n        #endif\n        mp_print_str(print, \"set()\");\n        return;\n    }\n    bool first = true;\n    #if MICROPY_PY_BUILTINS_FROZENSET\n    if (is_frozen) {\n        mp_print_str(print, \"frozenset(\");\n    }\n    #endif\n    mp_print_str(print, \"{\");\n    for (size_t i = 0; i < self->set.alloc; i++) {\n        if (mp_set_slot_is_filled(&self->set, i)) {\n            if (!first) {\n                mp_print_str(print, \", \");\n            }\n            first = false;\n            mp_obj_print_helper(print, self->set.table[i], PRINT_REPR);\n        }\n    }\n    mp_print_str(print, \"}\");\n    #if MICROPY_PY_BUILTINS_FROZENSET\n    if (is_frozen) {\n        mp_print_str(print, \")\");\n    }\n    #endif\n}\n\nstatic mp_obj_t set_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {\n    mp_arg_check_num(n_args, n_kw, 0, 1, false);\n\n    switch (n_args) {\n        case 0: {\n            \n            mp_obj_set_t *set = MP_OBJ_TO_PTR(mp_obj_new_set(0, NULL));\n            \n            set->base.type = type;\n            return MP_OBJ_FROM_PTR(set);\n        }\n\n        case 1:\n        default: { \n            \n            mp_obj_t set = mp_obj_new_set(0, NULL);\n            mp_obj_t iterable = mp_getiter(args[0], NULL);\n            mp_obj_t item;\n            while ((item = mp_iternext(iterable)) != MP_OBJ_STOP_ITERATION) {\n                mp_obj_set_store(set, item);\n            }\n            \n            ((mp_obj_set_t *)MP_OBJ_TO_PTR(set))->base.type = type;\n            return set;\n        }\n    }\n}\n\nstatic mp_obj_t set_it_iternext(mp_obj_t self_in) {\n    mp_obj_set_it_t *self = MP_OBJ_TO_PTR(self_in);\n    size_t max = self->set->set.alloc;\n    mp_set_t *set = &self->set->set;\n\n    for (size_t i = self->cur; i < max; i++) {\n        if (mp_set_slot_is_filled(set, i)) {\n            self->cur = i + 1;\n            return set->table[i];\n        }\n    }\n\n    return MP_OBJ_STOP_ITERATION;\n}\n\nstatic mp_obj_t set_getiter(mp_obj_t set_in, mp_obj_iter_buf_t *iter_buf) {\n    assert(sizeof(mp_obj_set_it_t) <= sizeof(mp_obj_iter_buf_t));\n    mp_obj_set_it_t *o = (mp_obj_set_it_t *)iter_buf;\n    o->base.type = &mp_type_polymorph_iter;\n    o->iternext = set_it_iternext;\n    o->set = (mp_obj_set_t *)MP_OBJ_TO_PTR(set_in);\n    o->cur = 0;\n    return MP_OBJ_FROM_PTR(o);\n}\n\n \n \n\nstatic mp_obj_t set_add(mp_obj_t self_in, mp_obj_t item) {\n    check_set(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_set_lookup(&self->set, item, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_add_obj, set_add);\n\nstatic mp_obj_t set_clear(mp_obj_t self_in) {\n    check_set(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_set_clear(&self->set);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(set_clear_obj, set_clear);\n\nstatic mp_obj_t set_copy(mp_obj_t self_in) {\n    check_set_or_frozenset(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_set_t *other = mp_obj_malloc(mp_obj_set_t, self->base.type);\n    mp_set_init(&other->set, self->set.alloc);\n    other->set.used = self->set.used;\n    memcpy(other->set.table, self->set.table, self->set.alloc * sizeof(mp_obj_t));\n    return MP_OBJ_FROM_PTR(other);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(set_copy_obj, set_copy);\n\nstatic mp_obj_t set_discard(mp_obj_t self_in, mp_obj_t item) {\n    check_set(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_set_lookup(&self->set, item, MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_discard_obj, set_discard);\n\nstatic mp_obj_t set_diff_int(size_t n_args, const mp_obj_t *args, bool update) {\n    mp_obj_t self;\n    if (update) {\n        check_set(args[0]);\n        self = args[0];\n    } else {\n        self = set_copy(args[0]);\n    }\n\n    for (size_t i = 1; i < n_args; i++) {\n        mp_obj_t other = args[i];\n        if (self == other) {\n            set_clear(self);\n        } else {\n            mp_set_t *self_set = &((mp_obj_set_t *)MP_OBJ_TO_PTR(self))->set;\n            mp_obj_t iter = mp_getiter(other, NULL);\n            mp_obj_t next;\n            while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n                mp_set_lookup(self_set, next, MP_MAP_LOOKUP_REMOVE_IF_FOUND);\n            }\n        }\n    }\n\n    return self;\n}\n\nstatic mp_obj_t set_diff(size_t n_args, const mp_obj_t *args) {\n    return set_diff_int(n_args, args, false);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR(set_diff_obj, 1, set_diff);\n\nstatic mp_obj_t set_diff_update(size_t n_args, const mp_obj_t *args) {\n    set_diff_int(n_args, args, true);\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR(set_diff_update_obj, 1, set_diff_update);\n\nstatic mp_obj_t set_intersect_int(mp_obj_t self_in, mp_obj_t other, bool update) {\n    if (update) {\n        check_set(self_in);\n    } else {\n        check_set_or_frozenset(self_in);\n    }\n\n    if (self_in == other) {\n        return update ? mp_const_none : set_copy(self_in);\n    }\n\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_set_t *out = MP_OBJ_TO_PTR(mp_obj_new_set(0, NULL));\n\n    mp_obj_t iter = mp_getiter(other, NULL);\n    mp_obj_t next;\n    while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        if (mp_set_lookup(&self->set, next, MP_MAP_LOOKUP)) {\n            set_add(MP_OBJ_FROM_PTR(out), next);\n        }\n    }\n\n    if (update) {\n        m_del(mp_obj_t, self->set.table, self->set.alloc);\n        self->set.alloc = out->set.alloc;\n        self->set.used = out->set.used;\n        self->set.table = out->set.table;\n    }\n\n    return update ? mp_const_none : MP_OBJ_FROM_PTR(out);\n}\n\nstatic mp_obj_t set_intersect(mp_obj_t self_in, mp_obj_t other) {\n    return set_intersect_int(self_in, other, false);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_intersect_obj, set_intersect);\n\nstatic mp_obj_t set_intersect_update(mp_obj_t self_in, mp_obj_t other) {\n    return set_intersect_int(self_in, other, true);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_intersect_update_obj, set_intersect_update);\n\nstatic mp_obj_t set_isdisjoint(mp_obj_t self_in, mp_obj_t other) {\n    check_set_or_frozenset(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n\n    mp_obj_iter_buf_t iter_buf;\n    mp_obj_t iter = mp_getiter(other, &iter_buf);\n    mp_obj_t next;\n    while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        if (mp_set_lookup(&self->set, next, MP_MAP_LOOKUP)) {\n            return mp_const_false;\n        }\n    }\n    return mp_const_true;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_isdisjoint_obj, set_isdisjoint);\n\nstatic mp_obj_t set_issubset_internal(mp_obj_t self_in, mp_obj_t other_in, bool proper) {\n    mp_obj_set_t *self;\n    bool cleanup_self = false;\n    if (is_set_or_frozenset(self_in)) {\n        self = MP_OBJ_TO_PTR(self_in);\n    } else {\n        self = MP_OBJ_TO_PTR(set_make_new(&mp_type_set, 1, 0, &self_in));\n        cleanup_self = true;\n    }\n\n    mp_obj_set_t *other;\n    bool cleanup_other = false;\n    if (is_set_or_frozenset(other_in)) {\n        other = MP_OBJ_TO_PTR(other_in);\n    } else {\n        other = MP_OBJ_TO_PTR(set_make_new(&mp_type_set, 1, 0, &other_in));\n        cleanup_other = true;\n    }\n    mp_obj_t out = mp_const_true;\n    if (proper && self->set.used == other->set.used) {\n        out = mp_const_false;\n    } else {\n        mp_obj_iter_buf_t iter_buf;\n        mp_obj_t iter = set_getiter(MP_OBJ_FROM_PTR(self), &iter_buf);\n        mp_obj_t next;\n        while ((next = set_it_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n            if (!mp_set_lookup(&other->set, next, MP_MAP_LOOKUP)) {\n                out = mp_const_false;\n                break;\n            }\n        }\n    }\n    \n    if (cleanup_self) {\n        set_clear(MP_OBJ_FROM_PTR(self));\n    }\n    if (cleanup_other) {\n        set_clear(MP_OBJ_FROM_PTR(other));\n    }\n    return out;\n}\n\nstatic mp_obj_t set_issubset(mp_obj_t self_in, mp_obj_t other_in) {\n    return set_issubset_internal(self_in, other_in, false);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_issubset_obj, set_issubset);\n\nstatic mp_obj_t set_issubset_proper(mp_obj_t self_in, mp_obj_t other_in) {\n    return set_issubset_internal(self_in, other_in, true);\n}\n\nstatic mp_obj_t set_issuperset(mp_obj_t self_in, mp_obj_t other_in) {\n    return set_issubset_internal(other_in, self_in, false);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_issuperset_obj, set_issuperset);\n\nstatic mp_obj_t set_issuperset_proper(mp_obj_t self_in, mp_obj_t other_in) {\n    return set_issubset_internal(other_in, self_in, true);\n}\n\nstatic mp_obj_t set_equal(mp_obj_t self_in, mp_obj_t other_in) {\n    assert(is_set_or_frozenset(other_in));\n    check_set_or_frozenset(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_set_t *other = MP_OBJ_TO_PTR(other_in);\n    if (self->set.used != other->set.used) {\n        return mp_const_false;\n    }\n    return set_issubset(self_in, other_in);\n}\n\nstatic mp_obj_t set_pop(mp_obj_t self_in) {\n    check_set(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t obj = mp_set_remove_first(&self->set);\n    if (obj == MP_OBJ_NULL) {\n        mp_raise_msg(&mp_type_KeyError, MP_ERROR_TEXT(\"pop from an empty set\"));\n    }\n    return obj;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(set_pop_obj, set_pop);\n\nstatic mp_obj_t set_remove(mp_obj_t self_in, mp_obj_t item) {\n    check_set(self_in);\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    if (mp_set_lookup(&self->set, item, MP_MAP_LOOKUP_REMOVE_IF_FOUND) == MP_OBJ_NULL) {\n        mp_raise_type_arg(&mp_type_KeyError, item);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_remove_obj, set_remove);\n\nstatic mp_obj_t set_symmetric_difference_update(mp_obj_t self_in, mp_obj_t other_in) {\n    check_set_or_frozenset(self_in); \n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_obj_t iter = mp_getiter(other_in, NULL);\n    mp_obj_t next;\n    while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        mp_set_lookup(&self->set, next, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND_OR_REMOVE_IF_FOUND);\n    }\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_symmetric_difference_update_obj, set_symmetric_difference_update);\n\nstatic mp_obj_t set_symmetric_difference(mp_obj_t self_in, mp_obj_t other_in) {\n    mp_obj_t self_out = set_copy(self_in);\n    set_symmetric_difference_update(self_out, other_in);\n    return self_out;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_symmetric_difference_obj, set_symmetric_difference);\n\nstatic void set_update_int(mp_obj_set_t *self, mp_obj_t other_in) {\n    mp_obj_t iter = mp_getiter(other_in, NULL);\n    mp_obj_t next;\n    while ((next = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {\n        mp_set_lookup(&self->set, next, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n    }\n}\n\nstatic mp_obj_t set_update(size_t n_args, const mp_obj_t *args) {\n    check_set(args[0]);\n    for (size_t i = 1; i < n_args; i++) {\n        set_update_int(MP_OBJ_TO_PTR(args[0]), args[i]);\n    }\n\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR(set_update_obj, 1, set_update);\n\nstatic mp_obj_t set_union(mp_obj_t self_in, mp_obj_t other_in) {\n    check_set_or_frozenset(self_in);\n    mp_obj_t self = set_copy(self_in);\n    set_update_int(MP_OBJ_TO_PTR(self), other_in);\n    return self;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_2(set_union_obj, set_union);\n\nstatic mp_obj_t set_unary_op(mp_unary_op_t op, mp_obj_t self_in) {\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    switch (op) {\n        case MP_UNARY_OP_BOOL:\n            return mp_obj_new_bool(self->set.used != 0);\n        case MP_UNARY_OP_LEN:\n            return MP_OBJ_NEW_SMALL_INT(self->set.used);\n        #if MICROPY_PY_BUILTINS_FROZENSET\n        case MP_UNARY_OP_HASH:\n            if (mp_obj_is_type(self_in, &mp_type_frozenset)) {\n                \n                mp_int_t hash = (mp_int_t)(uintptr_t)&mp_type_frozenset;\n                size_t max = self->set.alloc;\n                mp_set_t *set = &self->set;\n\n                for (size_t i = 0; i < max; i++) {\n                    if (mp_set_slot_is_filled(set, i)) {\n                        hash += MP_OBJ_SMALL_INT_VALUE(mp_unary_op(MP_UNARY_OP_HASH, set->table[i]));\n                    }\n                }\n                return MP_OBJ_NEW_SMALL_INT(hash);\n            }\n            MP_FALLTHROUGH\n        #endif\n        default:\n            return MP_OBJ_NULL;      \n    }\n}\n\nstatic mp_obj_t set_binary_op(mp_binary_op_t op, mp_obj_t lhs, mp_obj_t rhs) {\n    mp_obj_t args[] = {lhs, rhs};\n    #if MICROPY_PY_BUILTINS_FROZENSET\n    bool update = mp_obj_is_type(lhs, &mp_type_set);\n    #else\n    bool update = true;\n    #endif\n    if (op != MP_BINARY_OP_CONTAINS && !is_set_or_frozenset(rhs)) {\n        \n        return MP_OBJ_NULL;\n    }\n    switch (op) {\n        case MP_BINARY_OP_OR:\n            return set_union(lhs, rhs);\n        case MP_BINARY_OP_XOR:\n            return set_symmetric_difference(lhs, rhs);\n        case MP_BINARY_OP_AND:\n            return set_intersect(lhs, rhs);\n        case MP_BINARY_OP_SUBTRACT:\n            return set_diff(2, args);\n        case MP_BINARY_OP_INPLACE_OR:\n            if (update) {\n                set_update(2, args);\n                return lhs;\n            } else {\n                return set_union(lhs, rhs);\n            }\n        case MP_BINARY_OP_INPLACE_XOR:\n            if (update) {\n                set_symmetric_difference_update(lhs, rhs);\n                return lhs;\n            } else {\n                return set_symmetric_difference(lhs, rhs);\n            }\n        case MP_BINARY_OP_INPLACE_AND:\n            rhs = set_intersect_int(lhs, rhs, update);\n            if (update) {\n                return lhs;\n            } else {\n                return rhs;\n            }\n        case MP_BINARY_OP_INPLACE_SUBTRACT:\n            return set_diff_int(2, args, update);\n        case MP_BINARY_OP_LESS:\n            return set_issubset_proper(lhs, rhs);\n        case MP_BINARY_OP_MORE:\n            return set_issuperset_proper(lhs, rhs);\n        case MP_BINARY_OP_EQUAL:\n            return set_equal(lhs, rhs);\n        case MP_BINARY_OP_LESS_EQUAL:\n            return set_issubset(lhs, rhs);\n        case MP_BINARY_OP_MORE_EQUAL:\n            return set_issuperset(lhs, rhs);\n        case MP_BINARY_OP_CONTAINS: {\n            mp_obj_set_t *o = MP_OBJ_TO_PTR(lhs);\n            mp_obj_t elem = mp_set_lookup(&o->set, rhs, MP_MAP_LOOKUP);\n            return mp_obj_new_bool(elem != MP_OBJ_NULL);\n        }\n        default:\n            return MP_OBJ_NULL; \n    }\n}\n\n \n \n\nstatic const mp_rom_map_elem_t set_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_add), MP_ROM_PTR(&set_add_obj) },\n    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&set_clear_obj) },\n    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&set_copy_obj) },\n    { MP_ROM_QSTR(MP_QSTR_discard), MP_ROM_PTR(&set_discard_obj) },\n    { MP_ROM_QSTR(MP_QSTR_difference), MP_ROM_PTR(&set_diff_obj) },\n    { MP_ROM_QSTR(MP_QSTR_difference_update), MP_ROM_PTR(&set_diff_update_obj) },\n    { MP_ROM_QSTR(MP_QSTR_intersection), MP_ROM_PTR(&set_intersect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_intersection_update), MP_ROM_PTR(&set_intersect_update_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isdisjoint), MP_ROM_PTR(&set_isdisjoint_obj) },\n    { MP_ROM_QSTR(MP_QSTR_issubset), MP_ROM_PTR(&set_issubset_obj) },\n    { MP_ROM_QSTR(MP_QSTR_issuperset), MP_ROM_PTR(&set_issuperset_obj) },\n    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&set_pop_obj) },\n    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&set_remove_obj) },\n    { MP_ROM_QSTR(MP_QSTR_symmetric_difference), MP_ROM_PTR(&set_symmetric_difference_obj) },\n    { MP_ROM_QSTR(MP_QSTR_symmetric_difference_update), MP_ROM_PTR(&set_symmetric_difference_update_obj) },\n    { MP_ROM_QSTR(MP_QSTR_union), MP_ROM_PTR(&set_union_obj) },\n    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&set_update_obj) },\n    { MP_ROM_QSTR(MP_QSTR___contains__), MP_ROM_PTR(&mp_op_contains_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(set_locals_dict, set_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_set,\n    MP_QSTR_set,\n    MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, set_make_new,\n    print, set_print,\n    unary_op, set_unary_op,\n    binary_op, set_binary_op,\n    iter, set_getiter,\n    locals_dict, &set_locals_dict\n    );\n\n#if MICROPY_PY_BUILTINS_FROZENSET\nstatic const mp_rom_map_elem_t frozenset_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&set_copy_obj) },\n    { MP_ROM_QSTR(MP_QSTR_difference), MP_ROM_PTR(&set_diff_obj) },\n    { MP_ROM_QSTR(MP_QSTR_intersection), MP_ROM_PTR(&set_intersect_obj) },\n    { MP_ROM_QSTR(MP_QSTR_isdisjoint), MP_ROM_PTR(&set_isdisjoint_obj) },\n    { MP_ROM_QSTR(MP_QSTR_issubset), MP_ROM_PTR(&set_issubset_obj) },\n    { MP_ROM_QSTR(MP_QSTR_issuperset), MP_ROM_PTR(&set_issuperset_obj) },\n    { MP_ROM_QSTR(MP_QSTR_symmetric_difference), MP_ROM_PTR(&set_symmetric_difference_obj) },\n    { MP_ROM_QSTR(MP_QSTR_union), MP_ROM_PTR(&set_union_obj) },\n    { MP_ROM_QSTR(MP_QSTR___contains__), MP_ROM_PTR(&mp_op_contains_obj) },\n};\nstatic MP_DEFINE_CONST_DICT(frozenset_locals_dict, frozenset_locals_dict_table);\n\nMP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_frozenset,\n    MP_QSTR_frozenset,\n    MP_TYPE_FLAG_EQ_CHECKS_OTHER_TYPE | MP_TYPE_FLAG_ITER_IS_GETITER,\n    make_new, set_make_new,\n    print, set_print,\n    unary_op, set_unary_op,\n    binary_op, set_binary_op,\n    iter, set_getiter,\n    locals_dict, &frozenset_locals_dict\n    );\n#endif\n\nmp_obj_t mp_obj_new_set(size_t n_args, mp_obj_t *items) {\n    mp_obj_set_t *o = mp_obj_malloc(mp_obj_set_t, &mp_type_set);\n    mp_set_init(&o->set, n_args);\n    for (size_t i = 0; i < n_args; i++) {\n        mp_set_lookup(&o->set, items[i], MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n    }\n    return MP_OBJ_FROM_PTR(o);\n}\n\nvoid mp_obj_set_store(mp_obj_t self_in, mp_obj_t item) {\n    mp_check_self(mp_obj_is_type(self_in, &mp_type_set));\n    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_set_lookup(&self->set, item, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}