{
  "module_name": "modthread.c",
  "hash_id": "9080210495edaf45034905fc67e33c30ab66d196f230349ead41ae375ed4cad3",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/modthread.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/stackctrl.h\"\n\n#if MICROPY_PY_THREAD\n\n#include \"py/mpthread.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_PRINT (1)\n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_PRINT (0)\n#define DEBUG_printf(...) (void)0\n#endif\n\n \n\n\nstatic const mp_obj_type_t mp_type_thread_lock;\n\ntypedef struct _mp_obj_thread_lock_t {\n    mp_obj_base_t base;\n    mp_thread_mutex_t mutex;\n    volatile bool locked;\n} mp_obj_thread_lock_t;\n\nstatic mp_obj_thread_lock_t *mp_obj_new_thread_lock(void) {\n    mp_obj_thread_lock_t *self = mp_obj_malloc(mp_obj_thread_lock_t, &mp_type_thread_lock);\n    mp_thread_mutex_init(&self->mutex);\n    self->locked = false;\n    return self;\n}\n\nstatic mp_obj_t thread_lock_acquire(size_t n_args, const mp_obj_t *args) {\n    mp_obj_thread_lock_t *self = MP_OBJ_TO_PTR(args[0]);\n    bool wait = true;\n    if (n_args > 1) {\n        wait = mp_obj_get_int(args[1]);\n        \n    }\n    MP_THREAD_GIL_EXIT();\n    int ret = mp_thread_mutex_lock(&self->mutex, wait);\n    MP_THREAD_GIL_ENTER();\n    if (ret == 0) {\n        return mp_const_false;\n    } else if (ret == 1) {\n        self->locked = true;\n        return mp_const_true;\n    } else {\n        mp_raise_OSError(-ret);\n    }\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(thread_lock_acquire_obj, 1, 3, thread_lock_acquire);\n\nstatic mp_obj_t thread_lock_release(mp_obj_t self_in) {\n    mp_obj_thread_lock_t *self = MP_OBJ_TO_PTR(self_in);\n    if (!self->locked) {\n        mp_raise_msg(&mp_type_RuntimeError, NULL);\n    }\n    self->locked = false;\n    MP_THREAD_GIL_EXIT();\n    mp_thread_mutex_unlock(&self->mutex);\n    MP_THREAD_GIL_ENTER();\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(thread_lock_release_obj, thread_lock_release);\n\nstatic mp_obj_t thread_lock_locked(mp_obj_t self_in) {\n    mp_obj_thread_lock_t *self = MP_OBJ_TO_PTR(self_in);\n    return mp_obj_new_bool(self->locked);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(thread_lock_locked_obj, thread_lock_locked);\n\nstatic mp_obj_t thread_lock___exit__(size_t n_args, const mp_obj_t *args) {\n    (void)n_args; \n    return thread_lock_release(args[0]);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(thread_lock___exit___obj, 4, 4, thread_lock___exit__);\n\nstatic const mp_rom_map_elem_t thread_lock_locals_dict_table[] = {\n    { MP_ROM_QSTR(MP_QSTR_acquire), MP_ROM_PTR(&thread_lock_acquire_obj) },\n    { MP_ROM_QSTR(MP_QSTR_release), MP_ROM_PTR(&thread_lock_release_obj) },\n    { MP_ROM_QSTR(MP_QSTR_locked), MP_ROM_PTR(&thread_lock_locked_obj) },\n    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&thread_lock_acquire_obj) },\n    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&thread_lock___exit___obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(thread_lock_locals_dict, thread_lock_locals_dict_table);\n\nstatic MP_DEFINE_CONST_OBJ_TYPE(\n    mp_type_thread_lock,\n    MP_QSTR_lock,\n    MP_TYPE_FLAG_NONE,\n    locals_dict, &thread_lock_locals_dict\n    );\n\n \n\n\nstatic size_t thread_stack_size = 0;\n\nstatic mp_obj_t mod_thread_get_ident(void) {\n    return mp_obj_new_int_from_uint(mp_thread_get_id());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mod_thread_get_ident_obj, mod_thread_get_ident);\n\nstatic mp_obj_t mod_thread_stack_size(size_t n_args, const mp_obj_t *args) {\n    mp_obj_t ret = mp_obj_new_int_from_uint(thread_stack_size);\n    if (n_args == 0) {\n        thread_stack_size = 0;\n    } else {\n        thread_stack_size = mp_obj_get_int(args[0]);\n    }\n    return ret;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_thread_stack_size_obj, 0, 1, mod_thread_stack_size);\n\ntypedef struct _thread_entry_args_t {\n    mp_obj_dict_t *dict_locals;\n    mp_obj_dict_t *dict_globals;\n    size_t stack_size;\n    mp_obj_t fun;\n    size_t n_args;\n    size_t n_kw;\n    mp_obj_t args[];\n} thread_entry_args_t;\n\nstatic void *thread_entry(void *args_in) {\n    \n\n    thread_entry_args_t *args = (thread_entry_args_t *)args_in;\n\n    mp_state_thread_t ts;\n    mp_thread_init_state(&ts, args->stack_size, args->dict_locals, args->dict_globals);\n\n    #if MICROPY_ENABLE_PYSTACK\n    \n    mp_obj_t mini_pystack[128];\n    mp_pystack_init(mini_pystack, &mini_pystack[128]);\n    #endif\n\n    MP_THREAD_GIL_ENTER();\n\n    \n    mp_thread_start();\n\n    \n    \n\n    DEBUG_printf(\"[thread] start ts=%p args=%p stack=%p\\n\", &ts, &args, MP_STATE_THREAD(stack_top));\n\n    nlr_buf_t nlr;\n    if (nlr_push(&nlr) == 0) {\n        mp_call_function_n_kw(args->fun, args->n_args, args->n_kw, args->args);\n        nlr_pop();\n    } else {\n        \n        \n        mp_obj_base_t *exc = (mp_obj_base_t *)nlr.ret_val;\n        if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(exc->type), MP_OBJ_FROM_PTR(&mp_type_SystemExit))) {\n            \n        } else {\n            \n            mp_printf(MICROPY_ERROR_PRINTER, \"Unhandled exception in thread started by \");\n            mp_obj_print_helper(MICROPY_ERROR_PRINTER, args->fun, PRINT_REPR);\n            mp_printf(MICROPY_ERROR_PRINTER, \"\\n\");\n            mp_obj_print_exception(MICROPY_ERROR_PRINTER, MP_OBJ_FROM_PTR(exc));\n        }\n    }\n\n    DEBUG_printf(\"[thread] finish ts=%p\\n\", &ts);\n\n    \n    mp_thread_finish();\n\n    MP_THREAD_GIL_EXIT();\n\n    return NULL;\n}\n\nstatic mp_obj_t mod_thread_start_new_thread(size_t n_args, const mp_obj_t *args) {\n    \n    \n    \n    \n    thread_entry_args_t *th_args;\n\n    \n    size_t pos_args_len;\n    mp_obj_t *pos_args_items;\n    mp_obj_get_array(args[1], &pos_args_len, &pos_args_items);\n\n    \n    if (n_args == 2) {\n        \n        th_args = m_new_obj_var(thread_entry_args_t, args, mp_obj_t, pos_args_len);\n        th_args->n_kw = 0;\n    } else {\n        \n        if (mp_obj_get_type(args[2]) != &mp_type_dict) {\n            mp_raise_TypeError(MP_ERROR_TEXT(\"expecting a dict for keyword args\"));\n        }\n        mp_map_t *map = &((mp_obj_dict_t *)MP_OBJ_TO_PTR(args[2]))->map;\n        th_args = m_new_obj_var(thread_entry_args_t, args, mp_obj_t, pos_args_len + 2 * map->used);\n        th_args->n_kw = map->used;\n        \n        for (size_t i = 0, n = pos_args_len; i < map->alloc; ++i) {\n            if (mp_map_slot_is_filled(map, i)) {\n                th_args->args[n++] = map->table[i].key;\n                th_args->args[n++] = map->table[i].value;\n            }\n        }\n    }\n\n    \n    th_args->n_args = pos_args_len;\n    memcpy(th_args->args, pos_args_items, pos_args_len * sizeof(mp_obj_t));\n\n    \n    th_args->dict_locals = mp_locals_get();\n    th_args->dict_globals = mp_globals_get();\n\n    \n    th_args->stack_size = thread_stack_size;\n\n    \n    th_args->fun = args[0];\n\n    \n    return mp_obj_new_int_from_uint(mp_thread_create(thread_entry, th_args, &th_args->stack_size));\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_thread_start_new_thread_obj, 2, 3, mod_thread_start_new_thread);\n\nstatic mp_obj_t mod_thread_exit(void) {\n    mp_raise_type(&mp_type_SystemExit);\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mod_thread_exit_obj, mod_thread_exit);\n\nstatic mp_obj_t mod_thread_allocate_lock(void) {\n    return MP_OBJ_FROM_PTR(mp_obj_new_thread_lock());\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_0(mod_thread_allocate_lock_obj, mod_thread_allocate_lock);\n\nstatic const mp_rom_map_elem_t mp_module_thread_globals_table[] = {\n    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR__thread) },\n    { MP_ROM_QSTR(MP_QSTR_LockType), MP_ROM_PTR(&mp_type_thread_lock) },\n    { MP_ROM_QSTR(MP_QSTR_get_ident), MP_ROM_PTR(&mod_thread_get_ident_obj) },\n    { MP_ROM_QSTR(MP_QSTR_stack_size), MP_ROM_PTR(&mod_thread_stack_size_obj) },\n    { MP_ROM_QSTR(MP_QSTR_start_new_thread), MP_ROM_PTR(&mod_thread_start_new_thread_obj) },\n    { MP_ROM_QSTR(MP_QSTR_exit), MP_ROM_PTR(&mod_thread_exit_obj) },\n    { MP_ROM_QSTR(MP_QSTR_allocate_lock), MP_ROM_PTR(&mod_thread_allocate_lock_obj) },\n};\n\nstatic MP_DEFINE_CONST_DICT(mp_module_thread_globals, mp_module_thread_globals_table);\n\nconst mp_obj_module_t mp_module_thread = {\n    .base = { &mp_type_module },\n    .globals = (mp_obj_dict_t *)&mp_module_thread_globals,\n};\n\nMP_REGISTER_MODULE(MP_QSTR__thread, mp_module_thread);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}