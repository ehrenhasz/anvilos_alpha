{
  "module_name": "qstr.c",
  "hash_id": "80f052f3362eb4ccc1a5d8fac76af496b90d4ae2bfa364b648109bc227ba6346",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/qstr.c",
  "human_readable_source": " \n\n#include <assert.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"py/mpstate.h\"\n#include \"py/qstr.h\"\n#include \"py/gc.h\"\n#include \"py/runtime.h\"\n\n#if MICROPY_DEBUG_VERBOSE \n#define DEBUG_printf DEBUG_printf\n#else \n#define DEBUG_printf(...) (void)0\n#endif\n\n\n\n\n#if MICROPY_QSTR_BYTES_IN_HASH\n#define Q_HASH_MASK ((1 << (8 * MICROPY_QSTR_BYTES_IN_HASH)) - 1)\n#else\n#define Q_HASH_MASK (0xffff)\n#endif\n\n#if MICROPY_PY_THREAD && !MICROPY_PY_THREAD_GIL\n#define QSTR_ENTER() mp_thread_mutex_lock(&MP_STATE_VM(qstr_mutex), 1)\n#define QSTR_EXIT() mp_thread_mutex_unlock(&MP_STATE_VM(qstr_mutex))\n#else\n#define QSTR_ENTER()\n#define QSTR_EXIT()\n#endif\n\n\n\n#define MICROPY_ALLOC_QSTR_ENTRIES_INIT (10)\n\n\nsize_t qstr_compute_hash(const byte *data, size_t len) {\n    \n    size_t hash = 5381;\n    for (const byte *top = data + len; data < top; data++) {\n        hash = ((hash << 5) + hash) ^ (*data); \n    }\n    hash &= Q_HASH_MASK;\n    \n    if (hash == 0) {\n        hash++;\n    }\n    return hash;\n}\n\n\n\n\n\n\n\n#if MICROPY_QSTR_BYTES_IN_HASH\nconst qstr_hash_t mp_qstr_const_hashes_static[] = {\n    #ifndef NO_QSTR\n#define QDEF0(id, hash, len, str) hash,\n#define QDEF1(id, hash, len, str)\n    #include \"genhdr/qstrdefs.generated.h\"\n#undef QDEF0\n#undef QDEF1\n    #endif\n};\n#endif\n\nconst qstr_len_t mp_qstr_const_lengths_static[] = {\n    #ifndef NO_QSTR\n#define QDEF0(id, hash, len, str) len,\n#define QDEF1(id, hash, len, str)\n    #include \"genhdr/qstrdefs.generated.h\"\n#undef QDEF0\n#undef QDEF1\n    #endif\n};\n\nconst qstr_pool_t mp_qstr_const_pool_static = {\n    NULL,               \n    0,                  \n    false,              \n    MICROPY_ALLOC_QSTR_ENTRIES_INIT,\n    MP_QSTRnumber_of_static,   \n    #if MICROPY_QSTR_BYTES_IN_HASH\n    (qstr_hash_t *)mp_qstr_const_hashes_static,\n    #endif\n    (qstr_len_t *)mp_qstr_const_lengths_static,\n    {\n        #ifndef NO_QSTR\n#define QDEF0(id, hash, len, str) str,\n#define QDEF1(id, hash, len, str)\n        #include \"genhdr/qstrdefs.generated.h\"\n#undef QDEF0\n#undef QDEF1\n        #endif\n    },\n};\n\n\n\n#if MICROPY_QSTR_BYTES_IN_HASH\nconst qstr_hash_t mp_qstr_const_hashes[] = {\n    #ifndef NO_QSTR\n#define QDEF0(id, hash, len, str)\n#define QDEF1(id, hash, len, str) hash,\n    #include \"genhdr/qstrdefs.generated.h\"\n#undef QDEF0\n#undef QDEF1\n    #endif\n};\n#endif\n\nconst qstr_len_t mp_qstr_const_lengths[] = {\n    #ifndef NO_QSTR\n#define QDEF0(id, hash, len, str)\n#define QDEF1(id, hash, len, str) len,\n    #include \"genhdr/qstrdefs.generated.h\"\n#undef QDEF0\n#undef QDEF1\n    #endif\n};\n\nconst qstr_pool_t mp_qstr_const_pool = {\n    &mp_qstr_const_pool_static,\n    MP_QSTRnumber_of_static,\n    true,               \n    MICROPY_ALLOC_QSTR_ENTRIES_INIT,\n    MP_QSTRnumber_of - MP_QSTRnumber_of_static,   \n    #if MICROPY_QSTR_BYTES_IN_HASH\n    (qstr_hash_t *)mp_qstr_const_hashes,\n    #endif\n    (qstr_len_t *)mp_qstr_const_lengths,\n    {\n        #ifndef NO_QSTR\n#define QDEF0(id, hash, len, str)\n#define QDEF1(id, hash, len, str) str,\n        #include \"genhdr/qstrdefs.generated.h\"\n#undef QDEF0\n#undef QDEF1\n        #endif\n    },\n};\n\n\n\n#ifdef MICROPY_QSTR_EXTRA_POOL\nextern const qstr_pool_t MICROPY_QSTR_EXTRA_POOL;\n#define CONST_POOL MICROPY_QSTR_EXTRA_POOL\n#else\n#define CONST_POOL mp_qstr_const_pool\n#endif\n\nvoid qstr_init(void) {\n    MP_STATE_VM(last_pool) = (qstr_pool_t *)&CONST_POOL; \n    MP_STATE_VM(qstr_last_chunk) = NULL;\n\n    #if MICROPY_PY_THREAD && !MICROPY_PY_THREAD_GIL\n    mp_thread_mutex_init(&MP_STATE_VM(qstr_mutex));\n    #endif\n}\n\nstatic const qstr_pool_t *find_qstr(qstr *q) {\n    \n    \n    const qstr_pool_t *pool = MP_STATE_VM(last_pool);\n    while (*q < pool->total_prev_len) {\n        pool = pool->prev;\n    }\n    *q -= pool->total_prev_len;\n    assert(*q < pool->len);\n    return pool;\n}\n\n\nstatic qstr qstr_add(mp_uint_t len, const char *q_ptr) {\n    #if MICROPY_QSTR_BYTES_IN_HASH\n    mp_uint_t hash = qstr_compute_hash((const byte *)q_ptr, len);\n    DEBUG_printf(\"QSTR: add hash=%d len=%d data=%.*s\\n\", hash, len, len, q_ptr);\n    #else\n    DEBUG_printf(\"QSTR: add len=%d data=%.*s\\n\", len, len, q_ptr);\n    #endif\n\n    \n    if (MP_STATE_VM(last_pool)->len >= MP_STATE_VM(last_pool)->alloc) {\n        size_t new_alloc = MP_STATE_VM(last_pool)->alloc * 2;\n        #ifdef MICROPY_QSTR_EXTRA_POOL\n        \n        new_alloc = MAX(MICROPY_ALLOC_QSTR_ENTRIES_INIT, new_alloc);\n        #endif\n        mp_uint_t pool_size = sizeof(qstr_pool_t)\n            + (sizeof(const char *)\n                #if MICROPY_QSTR_BYTES_IN_HASH\n                + sizeof(qstr_hash_t)\n                #endif\n                + sizeof(qstr_len_t)) * new_alloc;\n        qstr_pool_t *pool = (qstr_pool_t *)m_malloc_maybe(pool_size);\n        if (pool == NULL) {\n            \n            \n            \n            \n            \n            MP_STATE_VM(qstr_last_chunk) = NULL;\n            QSTR_EXIT();\n            m_malloc_fail(new_alloc);\n        }\n        #if MICROPY_QSTR_BYTES_IN_HASH\n        pool->hashes = (qstr_hash_t *)(pool->qstrs + new_alloc);\n        pool->lengths = (qstr_len_t *)(pool->hashes + new_alloc);\n        #else\n        pool->lengths = (qstr_len_t *)(pool->qstrs + new_alloc);\n        #endif\n        pool->prev = MP_STATE_VM(last_pool);\n        pool->total_prev_len = MP_STATE_VM(last_pool)->total_prev_len + MP_STATE_VM(last_pool)->len;\n        pool->alloc = new_alloc;\n        pool->len = 0;\n        MP_STATE_VM(last_pool) = pool;\n        DEBUG_printf(\"QSTR: allocate new pool of size %d\\n\", MP_STATE_VM(last_pool)->alloc);\n    }\n\n    \n    mp_uint_t at = MP_STATE_VM(last_pool)->len;\n    #if MICROPY_QSTR_BYTES_IN_HASH\n    MP_STATE_VM(last_pool)->hashes[at] = hash;\n    #endif\n    MP_STATE_VM(last_pool)->lengths[at] = len;\n    MP_STATE_VM(last_pool)->qstrs[at] = q_ptr;\n    MP_STATE_VM(last_pool)->len++;\n\n    \n    return MP_STATE_VM(last_pool)->total_prev_len + at;\n}\n\nqstr qstr_find_strn(const char *str, size_t str_len) {\n    if (str_len == 0) {\n        \n        return MP_QSTR_;\n    }\n\n    #if MICROPY_QSTR_BYTES_IN_HASH\n    \n    size_t str_hash = qstr_compute_hash((const byte *)str, str_len);\n    #endif\n\n    \n    for (const qstr_pool_t *pool = MP_STATE_VM(last_pool); pool != NULL; pool = pool->prev) {\n        size_t low = 0;\n        size_t high = pool->len - 1;\n\n        \n        if (pool->is_sorted) {\n            while (high - low > 1) {\n                size_t mid = (low + high) / 2;\n                int cmp = strncmp(str, pool->qstrs[mid], str_len);\n                if (cmp <= 0) {\n                    high = mid;\n                } else {\n                    low = mid;\n                }\n            }\n        }\n\n        \n        for (mp_uint_t at = low; at < high + 1; at++) {\n            if (\n                #if MICROPY_QSTR_BYTES_IN_HASH\n                pool->hashes[at] == str_hash &&\n                #endif\n                pool->lengths[at] == str_len\n                && memcmp(pool->qstrs[at], str, str_len) == 0) {\n                return pool->total_prev_len + at;\n            }\n        }\n    }\n\n    \n    return MP_QSTRnull;\n}\n\nqstr qstr_from_str(const char *str) {\n    return qstr_from_strn(str, strlen(str));\n}\n\nqstr qstr_from_strn(const char *str, size_t len) {\n    QSTR_ENTER();\n    qstr q = qstr_find_strn(str, len);\n    if (q == 0) {\n        \n\n        \n        if (len >= (1 << (8 * MICROPY_QSTR_BYTES_IN_LEN))) {\n            QSTR_EXIT();\n            mp_raise_msg(&mp_type_RuntimeError, MP_ERROR_TEXT(\"name too long\"));\n        }\n\n        \n        size_t n_bytes = len + 1;\n\n        if (MP_STATE_VM(qstr_last_chunk) != NULL && MP_STATE_VM(qstr_last_used) + n_bytes > MP_STATE_VM(qstr_last_alloc)) {\n            \n            char *new_p = m_renew_maybe(char, MP_STATE_VM(qstr_last_chunk), MP_STATE_VM(qstr_last_alloc), MP_STATE_VM(qstr_last_alloc) + n_bytes, false);\n            if (new_p == NULL) {\n                \n                (void)m_renew_maybe(char, MP_STATE_VM(qstr_last_chunk), MP_STATE_VM(qstr_last_alloc), MP_STATE_VM(qstr_last_used), false);\n                MP_STATE_VM(qstr_last_chunk) = NULL;\n            } else {\n                \n                MP_STATE_VM(qstr_last_alloc) += n_bytes;\n            }\n        }\n\n        if (MP_STATE_VM(qstr_last_chunk) == NULL) {\n            \n            size_t al = n_bytes;\n            if (al < MICROPY_ALLOC_QSTR_CHUNK_INIT) {\n                al = MICROPY_ALLOC_QSTR_CHUNK_INIT;\n            }\n            MP_STATE_VM(qstr_last_chunk) = m_new_maybe(char, al);\n            if (MP_STATE_VM(qstr_last_chunk) == NULL) {\n                \n                MP_STATE_VM(qstr_last_chunk) = m_new_maybe(char, n_bytes);\n                if (MP_STATE_VM(qstr_last_chunk) == NULL) {\n                    QSTR_EXIT();\n                    m_malloc_fail(n_bytes);\n                }\n                al = n_bytes;\n            }\n            MP_STATE_VM(qstr_last_alloc) = al;\n            MP_STATE_VM(qstr_last_used) = 0;\n        }\n\n        \n        char *q_ptr = MP_STATE_VM(qstr_last_chunk) + MP_STATE_VM(qstr_last_used);\n        MP_STATE_VM(qstr_last_used) += n_bytes;\n\n        \n        memcpy(q_ptr, str, len);\n        q_ptr[len] = '\\0';\n        q = qstr_add(len, q_ptr);\n    }\n    QSTR_EXIT();\n    return q;\n}\n\nmp_uint_t qstr_hash(qstr q) {\n    const qstr_pool_t *pool = find_qstr(&q);\n    #if MICROPY_QSTR_BYTES_IN_HASH\n    return pool->hashes[q];\n    #else\n    return qstr_compute_hash((byte *)pool->qstrs[q], pool->lengths[q]);\n    #endif\n}\n\nsize_t qstr_len(qstr q) {\n    const qstr_pool_t *pool = find_qstr(&q);\n    return pool->lengths[q];\n}\n\nconst char *qstr_str(qstr q) {\n    const qstr_pool_t *pool = find_qstr(&q);\n    return pool->qstrs[q];\n}\n\nconst byte *qstr_data(qstr q, size_t *len) {\n    const qstr_pool_t *pool = find_qstr(&q);\n    *len = pool->lengths[q];\n    return (byte *)pool->qstrs[q];\n}\n\nvoid qstr_pool_info(size_t *n_pool, size_t *n_qstr, size_t *n_str_data_bytes, size_t *n_total_bytes) {\n    QSTR_ENTER();\n    *n_pool = 0;\n    *n_qstr = 0;\n    *n_str_data_bytes = 0;\n    *n_total_bytes = 0;\n    for (const qstr_pool_t *pool = MP_STATE_VM(last_pool); pool != NULL && pool != &CONST_POOL; pool = pool->prev) {\n        *n_pool += 1;\n        *n_qstr += pool->len;\n        for (qstr_len_t *l = pool->lengths, *l_top = pool->lengths + pool->len; l < l_top; l++) {\n            *n_str_data_bytes += *l + 1;\n        }\n        #if MICROPY_ENABLE_GC\n        *n_total_bytes += gc_nbytes(pool); \n        #else\n        *n_total_bytes += sizeof(qstr_pool_t)\n            + (sizeof(const char *)\n                #if MICROPY_QSTR_BYTES_IN_HASH\n                + sizeof(qstr_hash_t)\n                #endif\n                + sizeof(qstr_len_t)) * pool->alloc;\n        #endif\n    }\n    *n_total_bytes += *n_str_data_bytes;\n    QSTR_EXIT();\n}\n\n#if MICROPY_PY_MICROPYTHON_MEM_INFO\nvoid qstr_dump_data(void) {\n    QSTR_ENTER();\n    for (const qstr_pool_t *pool = MP_STATE_VM(last_pool); pool != NULL && pool != &CONST_POOL; pool = pool->prev) {\n        for (const char *const *q = pool->qstrs, *const *q_top = pool->qstrs + pool->len; q < q_top; q++) {\n            mp_printf(&mp_plat_print, \"Q(%s)\\n\", *q);\n        }\n    }\n    QSTR_EXIT();\n}\n#endif\n\n#if MICROPY_ROM_TEXT_COMPRESSION\n\n#ifdef NO_QSTR\n\n\n\n\n#else\n\n\n#define MP_COMPRESSED_DATA(x) static const char *compressed_string_data = x;\n#define MP_MATCH_COMPRESSED(a, b)\n#include \"genhdr/compressed.data.h\"\n#undef MP_COMPRESSED_DATA\n#undef MP_MATCH_COMPRESSED\n\n#endif \n\n\n\n\n\n\n\nstatic const byte *find_uncompressed_string(uint8_t n) {\n    const byte *c = (byte *)compressed_string_data;\n    while (n > 0) {\n        while ((*c & 0x80) == 0) {\n            ++c;\n        }\n        ++c;\n        --n;\n    }\n    return c;\n}\n\n\n\nvoid mp_decompress_rom_string(byte *dst, const mp_rom_error_text_t src_chr) {\n    \n    const byte *src = (byte *)src_chr + 1;\n    \n    \n    int state = 0;\n    while (*src) {\n        if ((byte) * src >= 128) {\n            if (state != 0) {\n                *dst++ = ' ';\n            }\n            state = 1;\n\n            \n            const byte *word = find_uncompressed_string(*src & 0x7f);\n            \n            while ((*word & 0x80) == 0) {\n                *dst++ = *word++;\n            }\n            *dst++ = (*word & 0x7f);\n        } else {\n            \n            if (state == 1) {\n                *dst++ = ' ';\n            }\n            state = 2;\n\n            *dst++ = *src;\n        }\n        ++src;\n    }\n    \n    *dst = 0;\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}