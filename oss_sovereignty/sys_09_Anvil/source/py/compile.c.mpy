{
  "module_name": "compile.c",
  "hash_id": "b930d428a0fcaf9e1a49361353cd7e45cbacd7235a9ef0f463f2709f6d7fef85",
  "original_prompt": "Ingested from sys_09_Anvil/source/py/compile.c",
  "human_readable_source": " \n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"py/scope.h\"\n#include \"py/emit.h\"\n#include \"py/compile.h\"\n#include \"py/runtime.h\"\n#include \"py/asmbase.h\"\n#include \"py/nativeglue.h\"\n#include \"py/persistentcode.h\"\n#include \"py/smallint.h\"\n\n#if MICROPY_ENABLE_COMPILER\n\n#define INVALID_LABEL (0xffff)\n\ntypedef enum {\n\n#define DEF_RULE(rule, comp, kind, ...) PN_##rule,\n#define DEF_RULE_NC(rule, kind, ...)\n    #include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n    PN_const_object, \n\n#define DEF_RULE(rule, comp, kind, ...)\n#define DEF_RULE_NC(rule, kind, ...) PN_##rule,\n    #include \"py/grammar.h\"\n#undef DEF_RULE\n#undef DEF_RULE_NC\n} pn_kind_t;\n\n\n\n#define MP_PARSE_NODE_TESTLIST_COMP_HAS_COMP_FOR(pns) \\\n    (MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2 && \\\n    MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for))\n\n#define NEED_METHOD_TABLE MICROPY_EMIT_NATIVE\n\n#if NEED_METHOD_TABLE\n\n\n#define EMIT(fun) (comp->emit_method_table->fun(comp->emit))\n#define EMIT_ARG(fun, ...) (comp->emit_method_table->fun(comp->emit, __VA_ARGS__))\n#define EMIT_LOAD_FAST(qst, local_num) (comp->emit_method_table->load_id.local(comp->emit, qst, local_num, MP_EMIT_IDOP_LOCAL_FAST))\n#define EMIT_LOAD_GLOBAL(qst) (comp->emit_method_table->load_id.global(comp->emit, qst, MP_EMIT_IDOP_GLOBAL_GLOBAL))\n\n#else\n\n\n#define EMIT(fun) (mp_emit_bc_##fun(comp->emit))\n#define EMIT_ARG(fun, ...) (mp_emit_bc_##fun(comp->emit, __VA_ARGS__))\n#define EMIT_LOAD_FAST(qst, local_num) (mp_emit_bc_load_local(comp->emit, qst, local_num, MP_EMIT_IDOP_LOCAL_FAST))\n#define EMIT_LOAD_GLOBAL(qst) (mp_emit_bc_load_global(comp->emit, qst, MP_EMIT_IDOP_GLOBAL_GLOBAL))\n\n#endif\n\n#if MICROPY_EMIT_NATIVE && MICROPY_DYNAMIC_COMPILER\n\n#define NATIVE_EMITTER(f) emit_native_table[mp_dynamic_compiler.native_arch]->emit_##f\n#define NATIVE_EMITTER_TABLE (emit_native_table[mp_dynamic_compiler.native_arch])\n\nstatic const emit_method_table_t *emit_native_table[] = {\n    NULL,\n    &emit_native_x86_method_table,\n    &emit_native_x64_method_table,\n    &emit_native_arm_method_table,\n    &emit_native_thumb_method_table,\n    &emit_native_thumb_method_table,\n    &emit_native_thumb_method_table,\n    &emit_native_thumb_method_table,\n    &emit_native_thumb_method_table,\n    &emit_native_xtensa_method_table,\n    &emit_native_xtensawin_method_table,\n};\n\n#elif MICROPY_EMIT_NATIVE\n\n#if MICROPY_EMIT_X64\n#define NATIVE_EMITTER(f) emit_native_x64_##f\n#elif MICROPY_EMIT_X86\n#define NATIVE_EMITTER(f) emit_native_x86_##f\n#elif MICROPY_EMIT_THUMB\n#define NATIVE_EMITTER(f) emit_native_thumb_##f\n#elif MICROPY_EMIT_ARM\n#define NATIVE_EMITTER(f) emit_native_arm_##f\n#elif MICROPY_EMIT_XTENSA\n#define NATIVE_EMITTER(f) emit_native_xtensa_##f\n#elif MICROPY_EMIT_XTENSAWIN\n#define NATIVE_EMITTER(f) emit_native_xtensawin_##f\n#else\n#error \"unknown native emitter\"\n#endif\n#define NATIVE_EMITTER_TABLE (&NATIVE_EMITTER(method_table))\n#endif\n\n#if MICROPY_EMIT_INLINE_ASM && MICROPY_DYNAMIC_COMPILER\n\n#define ASM_EMITTER(f) emit_asm_table[mp_dynamic_compiler.native_arch]->asm_##f\n#define ASM_EMITTER_TABLE emit_asm_table[mp_dynamic_compiler.native_arch]\n\nstatic const emit_inline_asm_method_table_t *emit_asm_table[] = {\n    NULL,\n    NULL,\n    NULL,\n    &emit_inline_thumb_method_table,\n    &emit_inline_thumb_method_table,\n    &emit_inline_thumb_method_table,\n    &emit_inline_thumb_method_table,\n    &emit_inline_thumb_method_table,\n    &emit_inline_thumb_method_table,\n    &emit_inline_xtensa_method_table,\n    NULL,\n};\n\n#elif MICROPY_EMIT_INLINE_ASM\n\n#if MICROPY_EMIT_INLINE_THUMB\n#define ASM_DECORATOR_QSTR MP_QSTR_asm_thumb\n#define ASM_EMITTER(f) emit_inline_thumb_##f\n#elif MICROPY_EMIT_INLINE_XTENSA\n#define ASM_DECORATOR_QSTR MP_QSTR_asm_xtensa\n#define ASM_EMITTER(f) emit_inline_xtensa_##f\n#else\n#error \"unknown asm emitter\"\n#endif\n#define ASM_EMITTER_TABLE &ASM_EMITTER(method_table)\n#endif\n\n#define EMIT_INLINE_ASM(fun) (comp->emit_inline_asm_method_table->fun(comp->emit_inline_asm))\n#define EMIT_INLINE_ASM_ARG(fun, ...) (comp->emit_inline_asm_method_table->fun(comp->emit_inline_asm, __VA_ARGS__))\n\n\ntypedef struct _compiler_t {\n    uint8_t is_repl;\n    uint8_t pass; \n    uint8_t have_star;\n\n    \n    mp_obj_t compile_error; \n    size_t compile_error_line; \n\n    uint next_label;\n\n    uint16_t num_dict_params;\n    uint16_t num_default_params;\n\n    uint16_t break_label; \n    uint16_t continue_label;\n    uint16_t cur_except_level; \n    uint16_t break_continue_except_level;\n\n    scope_t *scope_head;\n    scope_t *scope_cur;\n\n    emit_t *emit;                                   \n    #if NEED_METHOD_TABLE\n    const emit_method_table_t *emit_method_table;   \n    #endif\n\n    #if MICROPY_EMIT_INLINE_ASM\n    emit_inline_asm_t *emit_inline_asm;                                   \n    const emit_inline_asm_method_table_t *emit_inline_asm_method_table;   \n    #endif\n\n    mp_emit_common_t emit_common;\n} compiler_t;\n\n#if MICROPY_COMP_ALLOW_TOP_LEVEL_AWAIT\nbool mp_compile_allow_top_level_await = false;\n#endif\n\n \n\n\n\nstatic void mp_emit_common_init(mp_emit_common_t *emit, qstr source_file) {\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    mp_map_init(&emit->qstr_map, 1);\n\n    \n    mp_map_elem_t *elem = mp_map_lookup(&emit->qstr_map, MP_OBJ_NEW_QSTR(source_file), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);\n    elem->value = MP_OBJ_NEW_SMALL_INT(0);\n    #endif\n    mp_obj_list_init(&emit->const_obj_list, 0);\n}\n\nstatic void mp_emit_common_start_pass(mp_emit_common_t *emit, pass_kind_t pass) {\n    emit->pass = pass;\n    if (pass == MP_PASS_CODE_SIZE) {\n        if (emit->ct_cur_child == 0) {\n            emit->children = NULL;\n        } else {\n            emit->children = m_new0(mp_raw_code_t *, emit->ct_cur_child);\n        }\n    }\n    emit->ct_cur_child = 0;\n}\n\nstatic void mp_emit_common_populate_module_context(mp_emit_common_t *emit, qstr source_file, mp_module_context_t *context) {\n    #if MICROPY_EMIT_BYTECODE_USES_QSTR_TABLE\n    size_t qstr_map_used = emit->qstr_map.used;\n    mp_module_context_alloc_tables(context, qstr_map_used, emit->const_obj_list.len);\n    for (size_t i = 0; i < emit->qstr_map.alloc; ++i) {\n        if (mp_map_slot_is_filled(&emit->qstr_map, i)) {\n            size_t idx = MP_OBJ_SMALL_INT_VALUE(emit->qstr_map.table[i].value);\n            qstr qst = MP_OBJ_QSTR_VALUE(emit->qstr_map.table[i].key);\n            context->constants.qstr_table[idx] = qst;\n        }\n    }\n    #else\n    mp_module_context_alloc_tables(context, 0, emit->const_obj_list.len);\n    context->constants.source_file = source_file;\n    #endif\n\n    for (size_t i = 0; i < emit->const_obj_list.len; ++i) {\n        context->constants.obj_table[i] = emit->const_obj_list.items[i];\n    }\n}\n\n \n\nstatic void compile_error_set_line(compiler_t *comp, mp_parse_node_t pn) {\n    \n    if (comp->compile_error_line == 0 && MP_PARSE_NODE_IS_STRUCT(pn)) {\n        comp->compile_error_line = ((mp_parse_node_struct_t *)pn)->source_line;\n    }\n}\n\nstatic void compile_syntax_error(compiler_t *comp, mp_parse_node_t pn, mp_rom_error_text_t msg) {\n    \n    if (comp->compile_error == MP_OBJ_NULL) {\n        comp->compile_error = mp_obj_new_exception_msg(&mp_type_SyntaxError, msg);\n        compile_error_set_line(comp, pn);\n    }\n}\n\nstatic void compile_trailer_paren_helper(compiler_t *comp, mp_parse_node_t pn_arglist, bool is_method_call, int n_positional_extra);\nstatic void compile_comprehension(compiler_t *comp, mp_parse_node_struct_t *pns, scope_kind_t kind);\nstatic void compile_atom_brace_helper(compiler_t *comp, mp_parse_node_struct_t *pns, bool create_map);\nstatic void compile_node(compiler_t *comp, mp_parse_node_t pn);\n\nstatic uint comp_next_label(compiler_t *comp) {\n    return comp->next_label++;\n}\n\n#if MICROPY_EMIT_NATIVE\nstatic void reserve_labels_for_native(compiler_t *comp, int n) {\n    if (comp->scope_cur->emit_options != MP_EMIT_OPT_BYTECODE) {\n        comp->next_label += n;\n    }\n}\n#else\n#define reserve_labels_for_native(comp, n)\n#endif\n\nstatic void compile_increase_except_level(compiler_t *comp, uint label, int kind) {\n    EMIT_ARG(setup_block, label, kind);\n    comp->cur_except_level += 1;\n    if (comp->cur_except_level > comp->scope_cur->exc_stack_size) {\n        comp->scope_cur->exc_stack_size = comp->cur_except_level;\n    }\n}\n\nstatic void compile_decrease_except_level(compiler_t *comp) {\n    assert(comp->cur_except_level > 0);\n    comp->cur_except_level -= 1;\n    EMIT(end_finally);\n    reserve_labels_for_native(comp, 1);\n}\n\nstatic scope_t *scope_new_and_link(compiler_t *comp, scope_kind_t kind, mp_parse_node_t pn, uint emit_options) {\n    scope_t *scope = scope_new(kind, pn, emit_options);\n    scope->parent = comp->scope_cur;\n    scope->next = NULL;\n    if (comp->scope_head == NULL) {\n        comp->scope_head = scope;\n    } else {\n        scope_t *s = comp->scope_head;\n        while (s->next != NULL) {\n            s = s->next;\n        }\n        s->next = scope;\n    }\n    return scope;\n}\n\ntypedef void (*apply_list_fun_t)(compiler_t *comp, mp_parse_node_t pn);\n\nstatic void apply_to_single_or_list(compiler_t *comp, mp_parse_node_t pn, pn_kind_t pn_list_kind, apply_list_fun_t f) {\n    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, pn_list_kind)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n        for (int i = 0; i < num_nodes; i++) {\n            f(comp, pns->nodes[i]);\n        }\n    } else if (!MP_PARSE_NODE_IS_NULL(pn)) {\n        f(comp, pn);\n    }\n}\n\nstatic void compile_generic_all_nodes(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n    for (int i = 0; i < num_nodes; i++) {\n        compile_node(comp, pns->nodes[i]);\n        if (comp->compile_error != MP_OBJ_NULL) {\n            \n            compile_error_set_line(comp, pns->nodes[i]);\n            return;\n        }\n    }\n}\n\nstatic void compile_load_id(compiler_t *comp, qstr qst) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        mp_emit_common_get_id_for_load(comp->scope_cur, qst);\n    } else {\n        #if NEED_METHOD_TABLE\n        mp_emit_common_id_op(comp->emit, &comp->emit_method_table->load_id, comp->scope_cur, qst);\n        #else\n        mp_emit_common_id_op(comp->emit, &mp_emit_bc_method_table_load_id_ops, comp->scope_cur, qst);\n        #endif\n    }\n}\n\nstatic void compile_store_id(compiler_t *comp, qstr qst) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        mp_emit_common_get_id_for_modification(comp->scope_cur, qst);\n    } else {\n        #if NEED_METHOD_TABLE\n        mp_emit_common_id_op(comp->emit, &comp->emit_method_table->store_id, comp->scope_cur, qst);\n        #else\n        mp_emit_common_id_op(comp->emit, &mp_emit_bc_method_table_store_id_ops, comp->scope_cur, qst);\n        #endif\n    }\n}\n\nstatic void compile_delete_id(compiler_t *comp, qstr qst) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        mp_emit_common_get_id_for_modification(comp->scope_cur, qst);\n    } else {\n        #if NEED_METHOD_TABLE\n        mp_emit_common_id_op(comp->emit, &comp->emit_method_table->delete_id, comp->scope_cur, qst);\n        #else\n        mp_emit_common_id_op(comp->emit, &mp_emit_bc_method_table_delete_id_ops, comp->scope_cur, qst);\n        #endif\n    }\n}\n\nstatic void compile_generic_tuple(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    size_t num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n    for (size_t i = 0; i < num_nodes; i++) {\n        compile_node(comp, pns->nodes[i]);\n    }\n    EMIT_ARG(build, num_nodes, MP_EMIT_BUILD_TUPLE);\n}\n\nstatic void c_if_cond(compiler_t *comp, mp_parse_node_t pn, bool jump_if, int label) {\n    if (mp_parse_node_is_const_false(pn)) {\n        if (jump_if == false) {\n            EMIT_ARG(jump, label);\n        }\n        return;\n    } else if (mp_parse_node_is_const_true(pn)) {\n        if (jump_if == true) {\n            EMIT_ARG(jump, label);\n        }\n        return;\n    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_or_test) {\n            if (jump_if == false) {\n            and_or_logic1:;\n                uint label2 = comp_next_label(comp);\n                for (int i = 0; i < n - 1; i++) {\n                    c_if_cond(comp, pns->nodes[i], !jump_if, label2);\n                }\n                c_if_cond(comp, pns->nodes[n - 1], jump_if, label);\n                EMIT_ARG(label_assign, label2);\n            } else {\n            and_or_logic2:\n                for (int i = 0; i < n; i++) {\n                    c_if_cond(comp, pns->nodes[i], jump_if, label);\n                }\n            }\n            return;\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_and_test) {\n            if (jump_if == false) {\n                goto and_or_logic2;\n            } else {\n                goto and_or_logic1;\n            }\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_not_test_2) {\n            c_if_cond(comp, pns->nodes[0], !jump_if, label);\n            return;\n        }\n    }\n\n    \n    compile_node(comp, pn);\n    EMIT_ARG(pop_jump_if, jump_if, label);\n}\n\ntypedef enum { ASSIGN_STORE, ASSIGN_AUG_LOAD, ASSIGN_AUG_STORE } assign_kind_t;\nstatic void c_assign(compiler_t *comp, mp_parse_node_t pn, assign_kind_t kind);\n\nstatic void c_assign_atom_expr(compiler_t *comp, mp_parse_node_struct_t *pns, assign_kind_t assign_kind) {\n    if (assign_kind != ASSIGN_AUG_STORE) {\n        compile_node(comp, pns->nodes[0]);\n    }\n\n    if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {\n        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t *)pns->nodes[1];\n        if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_atom_expr_trailers) {\n            int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1);\n            if (assign_kind != ASSIGN_AUG_STORE) {\n                for (int i = 0; i < n - 1; i++) {\n                    compile_node(comp, pns1->nodes[i]);\n                }\n            }\n            assert(MP_PARSE_NODE_IS_STRUCT(pns1->nodes[n - 1]));\n            pns1 = (mp_parse_node_struct_t *)pns1->nodes[n - 1];\n        }\n        if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_bracket) {\n            if (assign_kind == ASSIGN_AUG_STORE) {\n                EMIT(rot_three);\n                EMIT_ARG(subscr, MP_EMIT_SUBSCR_STORE);\n            } else {\n                compile_node(comp, pns1->nodes[0]);\n                if (assign_kind == ASSIGN_AUG_LOAD) {\n                    EMIT(dup_top_two);\n                    EMIT_ARG(subscr, MP_EMIT_SUBSCR_LOAD);\n                } else {\n                    EMIT_ARG(subscr, MP_EMIT_SUBSCR_STORE);\n                }\n            }\n            return;\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_period) {\n            assert(MP_PARSE_NODE_IS_ID(pns1->nodes[0]));\n            if (assign_kind == ASSIGN_AUG_LOAD) {\n                EMIT(dup_top);\n                EMIT_ARG(attr, MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]), MP_EMIT_ATTR_LOAD);\n            } else {\n                if (assign_kind == ASSIGN_AUG_STORE) {\n                    EMIT(rot_two);\n                }\n                EMIT_ARG(attr, MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]), MP_EMIT_ATTR_STORE);\n            }\n            return;\n        }\n    }\n\n    compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"can't assign to expression\"));\n}\n\nstatic void c_assign_tuple(compiler_t *comp, uint num_tail, mp_parse_node_t *nodes_tail) {\n    \n    uint have_star_index = -1;\n    for (uint i = 0; i < num_tail; i++) {\n        if (MP_PARSE_NODE_IS_STRUCT_KIND(nodes_tail[i], PN_star_expr)) {\n            if (have_star_index == (uint)-1) {\n                EMIT_ARG(unpack_ex, i, num_tail - i - 1);\n                have_star_index = i;\n            } else {\n                compile_syntax_error(comp, nodes_tail[i], MP_ERROR_TEXT(\"multiple *x in assignment\"));\n                return;\n            }\n        }\n    }\n    if (have_star_index == (uint)-1) {\n        EMIT_ARG(unpack_sequence, num_tail);\n    }\n    for (uint i = 0; i < num_tail; i++) {\n        if (i == have_star_index) {\n            c_assign(comp, ((mp_parse_node_struct_t *)nodes_tail[i])->nodes[0], ASSIGN_STORE);\n        } else {\n            c_assign(comp, nodes_tail[i], ASSIGN_STORE);\n        }\n    }\n}\n\n\nstatic void c_assign(compiler_t *comp, mp_parse_node_t pn, assign_kind_t assign_kind) {\n    assert(!MP_PARSE_NODE_IS_NULL(pn));\n    if (MP_PARSE_NODE_IS_LEAF(pn)) {\n        if (MP_PARSE_NODE_IS_ID(pn)) {\n            qstr arg = MP_PARSE_NODE_LEAF_ARG(pn);\n            switch (assign_kind) {\n                case ASSIGN_STORE:\n                case ASSIGN_AUG_STORE:\n                    compile_store_id(comp, arg);\n                    break;\n                case ASSIGN_AUG_LOAD:\n                default:\n                    compile_load_id(comp, arg);\n                    break;\n            }\n        } else {\n            goto cannot_assign;\n        }\n    } else {\n        \n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        switch (MP_PARSE_NODE_STRUCT_KIND(pns)) {\n            case PN_atom_expr_normal:\n                \n                c_assign_atom_expr(comp, pns, assign_kind);\n                break;\n\n            case PN_testlist_star_expr:\n            case PN_exprlist:\n                \n                if (assign_kind != ASSIGN_STORE) {\n                    goto cannot_assign;\n                }\n                c_assign_tuple(comp, MP_PARSE_NODE_STRUCT_NUM_NODES(pns), pns->nodes);\n                break;\n\n            case PN_atom_paren:\n                \n                if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n                    \n                    goto cannot_assign;\n                } else {\n                    assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp));\n                    if (assign_kind != ASSIGN_STORE) {\n                        goto cannot_assign;\n                    }\n                    pns = (mp_parse_node_struct_t *)pns->nodes[0];\n                    goto testlist_comp;\n                }\n                break;\n\n            case PN_atom_bracket:\n                \n                if (assign_kind != ASSIGN_STORE) {\n                    goto cannot_assign;\n                }\n                if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n                    \n                    c_assign_tuple(comp, 0, NULL);\n                } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)) {\n                    pns = (mp_parse_node_struct_t *)pns->nodes[0];\n                    goto testlist_comp;\n                } else {\n                    \n                    c_assign_tuple(comp, 1, pns->nodes);\n                }\n                break;\n\n            default:\n                goto cannot_assign;\n        }\n        return;\n\n    testlist_comp:\n        \n        if (MP_PARSE_NODE_TESTLIST_COMP_HAS_COMP_FOR(pns)) {\n            goto cannot_assign;\n        }\n        c_assign_tuple(comp, MP_PARSE_NODE_STRUCT_NUM_NODES(pns), pns->nodes);\n        return;\n    }\n    return;\n\ncannot_assign:\n    compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"can't assign to expression\"));\n}\n\n\n\n\n\nstatic void close_over_variables_etc(compiler_t *comp, scope_t *this_scope, int n_pos_defaults, int n_kw_defaults) {\n    assert(n_pos_defaults >= 0);\n    assert(n_kw_defaults >= 0);\n\n    \n    if (n_kw_defaults > 0) {\n        this_scope->scope_flags |= MP_SCOPE_FLAG_DEFKWARGS;\n    }\n    this_scope->num_def_pos_args = n_pos_defaults;\n\n    #if MICROPY_EMIT_NATIVE\n    \n    comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_REFGLOBALS | MP_SCOPE_FLAG_HASCONSTS;\n    #endif\n\n    \n    \n    int nfree = 0;\n    if (comp->scope_cur->kind != SCOPE_MODULE) {\n        for (int i = 0; i < comp->scope_cur->id_info_len; i++) {\n            id_info_t *id = &comp->scope_cur->id_info[i];\n            if (id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE) {\n                for (int j = 0; j < this_scope->id_info_len; j++) {\n                    id_info_t *id2 = &this_scope->id_info[j];\n                    if (id2->kind == ID_INFO_KIND_FREE && id->qst == id2->qst) {\n                        \n                        EMIT_LOAD_FAST(id->qst, id->local_num);\n                        nfree += 1;\n                    }\n                }\n            }\n        }\n    }\n\n    \n    if (nfree == 0) {\n        EMIT_ARG(make_function, this_scope, n_pos_defaults, n_kw_defaults);\n    } else {\n        EMIT_ARG(make_closure, this_scope, nfree, n_pos_defaults, n_kw_defaults);\n    }\n}\n\nstatic void compile_funcdef_lambdef_param(compiler_t *comp, mp_parse_node_t pn) {\n    \n    int pn_kind;\n    if (MP_PARSE_NODE_IS_ID(pn)) {\n        pn_kind = -1;\n    } else {\n        assert(MP_PARSE_NODE_IS_STRUCT(pn));\n        pn_kind = MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t *)pn);\n    }\n\n    if (pn_kind == PN_typedargslist_star || pn_kind == PN_varargslist_star) {\n        comp->have_star = true;\n         \n\n    } else if (pn_kind == PN_typedargslist_dbl_star || pn_kind == PN_varargslist_dbl_star) {\n         \n         \n\n    } else {\n        mp_parse_node_t pn_id;\n        mp_parse_node_t pn_equal;\n        if (pn_kind == -1) {\n             \n\n            pn_id = pn;\n            pn_equal = MP_PARSE_NODE_NULL;\n\n        } else if (pn_kind == PN_typedargslist_name) {\n             \n\n            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n            pn_id = pns->nodes[0];\n             \n            pn_equal = pns->nodes[2];\n\n        } else {\n            assert(pn_kind == PN_varargslist_name);  \n             \n\n            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n            pn_id = pns->nodes[0];\n            pn_equal = pns->nodes[1];\n        }\n\n        if (MP_PARSE_NODE_IS_NULL(pn_equal)) {\n             \n\n             \n            if (!comp->have_star && comp->num_default_params != 0) {\n                compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"non-default argument follows default argument\"));\n                return;\n            }\n\n        } else {\n             \n             \n\n            if (comp->have_star) {\n                comp->num_dict_params += 1;\n                \n                if (comp->num_dict_params == 1) {\n                    \n                    \n                    if (comp->num_default_params > 0) {\n                        EMIT_ARG(build, comp->num_default_params, MP_EMIT_BUILD_TUPLE);\n                    } else {\n                        EMIT(load_null); \n                    }\n                    \n                    EMIT_ARG(build, 0, MP_EMIT_BUILD_MAP);\n                }\n\n                \n                compile_node(comp, pn_equal);\n                EMIT_ARG(load_const_str, MP_PARSE_NODE_LEAF_ARG(pn_id));\n                EMIT(store_map);\n            } else {\n                comp->num_default_params += 1;\n                compile_node(comp, pn_equal);\n            }\n        }\n    }\n}\n\nstatic void compile_funcdef_lambdef(compiler_t *comp, scope_t *scope, mp_parse_node_t pn_params, pn_kind_t pn_list_kind) {\n    \n    \n    \n    bool orig_have_star = comp->have_star;\n    uint16_t orig_num_dict_params = comp->num_dict_params;\n    uint16_t orig_num_default_params = comp->num_default_params;\n\n    \n    comp->have_star = false;\n    comp->num_dict_params = 0;\n    comp->num_default_params = 0;\n    apply_to_single_or_list(comp, pn_params, pn_list_kind, compile_funcdef_lambdef_param);\n\n    if (comp->compile_error != MP_OBJ_NULL) {\n        return;\n    }\n\n    \n    \n    if (comp->num_default_params > 0 && comp->num_dict_params == 0) {\n        EMIT_ARG(build, comp->num_default_params, MP_EMIT_BUILD_TUPLE);\n        EMIT(load_null); \n    }\n\n    \n    close_over_variables_etc(comp, scope, comp->num_default_params, comp->num_dict_params);\n\n    \n    comp->have_star = orig_have_star;\n    comp->num_dict_params = orig_num_dict_params;\n    comp->num_default_params = orig_num_default_params;\n}\n\n\n\nstatic qstr compile_funcdef_helper(compiler_t *comp, mp_parse_node_struct_t *pns, uint emit_options) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        \n        scope_t *s = scope_new_and_link(comp, SCOPE_FUNCTION, (mp_parse_node_t)pns, emit_options);\n        \n        pns->nodes[4] = (mp_parse_node_t)s;\n    }\n\n    \n    scope_t *fscope = (scope_t *)pns->nodes[4];\n\n    \n    compile_funcdef_lambdef(comp, fscope, pns->nodes[1], PN_typedargslist);\n\n    \n    return fscope->simple_name;\n}\n\n\n\nstatic qstr compile_classdef_helper(compiler_t *comp, mp_parse_node_struct_t *pns, uint emit_options) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        \n        scope_t *s = scope_new_and_link(comp, SCOPE_CLASS, (mp_parse_node_t)pns, emit_options);\n        \n        pns->nodes[3] = (mp_parse_node_t)s;\n    }\n\n    EMIT(load_build_class);\n\n    \n    scope_t *cscope = (scope_t *)pns->nodes[3];\n\n    \n    close_over_variables_etc(comp, cscope, 0, 0);\n\n    \n    EMIT_ARG(load_const_str, cscope->simple_name);\n\n    \n    \n    mp_parse_node_t parents = pns->nodes[1];\n    if (MP_PARSE_NODE_IS_STRUCT_KIND(parents, PN_classdef_2)) {\n        parents = MP_PARSE_NODE_NULL;\n    }\n    compile_trailer_paren_helper(comp, parents, false, 2);\n\n    \n    return cscope->simple_name;\n}\n\n\nstatic bool compile_built_in_decorator(compiler_t *comp, size_t name_len, mp_parse_node_t *name_nodes, uint *emit_options) {\n    if (MP_PARSE_NODE_LEAF_ARG(name_nodes[0]) != MP_QSTR_micropython) {\n        return false;\n    }\n\n    if (name_len != 2) {\n        compile_syntax_error(comp, name_nodes[0], MP_ERROR_TEXT(\"invalid micropython decorator\"));\n        return true;\n    }\n\n    qstr attr = MP_PARSE_NODE_LEAF_ARG(name_nodes[1]);\n    if (attr == MP_QSTR_bytecode) {\n        *emit_options = MP_EMIT_OPT_BYTECODE;\n    #if MICROPY_EMIT_NATIVE\n    } else if (attr == MP_QSTR_native) {\n        *emit_options = MP_EMIT_OPT_NATIVE_PYTHON;\n    } else if (attr == MP_QSTR_viper) {\n        *emit_options = MP_EMIT_OPT_VIPER;\n    #endif\n        #if MICROPY_EMIT_INLINE_ASM\n    #if MICROPY_DYNAMIC_COMPILER\n    } else if (attr == MP_QSTR_asm_thumb) {\n        *emit_options = MP_EMIT_OPT_ASM;\n    } else if (attr == MP_QSTR_asm_xtensa) {\n        *emit_options = MP_EMIT_OPT_ASM;\n    #else\n    } else if (attr == ASM_DECORATOR_QSTR) {\n        *emit_options = MP_EMIT_OPT_ASM;\n    #endif\n        #endif\n    } else {\n        compile_syntax_error(comp, name_nodes[1], MP_ERROR_TEXT(\"invalid micropython decorator\"));\n    }\n\n    #if MICROPY_EMIT_NATIVE && MICROPY_DYNAMIC_COMPILER\n    if (*emit_options == MP_EMIT_OPT_NATIVE_PYTHON || *emit_options == MP_EMIT_OPT_VIPER) {\n        if (emit_native_table[mp_dynamic_compiler.native_arch] == NULL) {\n            compile_syntax_error(comp, name_nodes[1], MP_ERROR_TEXT(\"invalid arch\"));\n        }\n    } else if (*emit_options == MP_EMIT_OPT_ASM) {\n        if (emit_asm_table[mp_dynamic_compiler.native_arch] == NULL) {\n            compile_syntax_error(comp, name_nodes[1], MP_ERROR_TEXT(\"invalid arch\"));\n        }\n    }\n    #endif\n\n    return true;\n}\n\nstatic void compile_decorated(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    mp_parse_node_t *nodes;\n    size_t n = mp_parse_node_extract_list(&pns->nodes[0], PN_decorators, &nodes);\n\n    \n    uint emit_options = comp->scope_cur->emit_options;\n\n    \n    size_t num_built_in_decorators = 0;\n    for (size_t i = 0; i < n; i++) {\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(nodes[i], PN_decorator)); \n        mp_parse_node_struct_t *pns_decorator = (mp_parse_node_struct_t *)nodes[i];\n\n        \n        mp_parse_node_t *name_nodes;\n        size_t name_len = mp_parse_node_extract_list(&pns_decorator->nodes[0], PN_dotted_name, &name_nodes);\n\n        \n        if (compile_built_in_decorator(comp, name_len, name_nodes, &emit_options)) {\n            \n            num_built_in_decorators += 1;\n\n        } else {\n            \n\n            \n            compile_node(comp, name_nodes[0]);\n            for (size_t j = 1; j < name_len; j++) {\n                assert(MP_PARSE_NODE_IS_ID(name_nodes[j])); \n                EMIT_ARG(attr, MP_PARSE_NODE_LEAF_ARG(name_nodes[j]), MP_EMIT_ATTR_LOAD);\n            }\n\n            \n            if (!MP_PARSE_NODE_IS_NULL(pns_decorator->nodes[1])) {\n                \n                compile_node(comp, pns_decorator->nodes[1]);\n            }\n        }\n    }\n\n    \n    mp_parse_node_struct_t *pns_body = (mp_parse_node_struct_t *)pns->nodes[1];\n    qstr body_name = 0;\n    if (MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_funcdef) {\n        body_name = compile_funcdef_helper(comp, pns_body, emit_options);\n    #if MICROPY_PY_ASYNC_AWAIT\n    } else if (MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_async_funcdef) {\n        assert(MP_PARSE_NODE_IS_STRUCT(pns_body->nodes[0]));\n        mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t *)pns_body->nodes[0];\n        body_name = compile_funcdef_helper(comp, pns0, emit_options);\n        scope_t *fscope = (scope_t *)pns0->nodes[4];\n        fscope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;\n    #endif\n    } else {\n        assert(MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_classdef); \n        body_name = compile_classdef_helper(comp, pns_body, emit_options);\n    }\n\n    \n    for (size_t i = 0; i < n - num_built_in_decorators; i++) {\n        EMIT_ARG(call_function, 1, 0, 0);\n    }\n\n    \n    compile_store_id(comp, body_name);\n}\n\nstatic void compile_funcdef(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    qstr fname = compile_funcdef_helper(comp, pns, comp->scope_cur->emit_options);\n    \n    compile_store_id(comp, fname);\n}\n\nstatic void c_del_stmt(compiler_t *comp, mp_parse_node_t pn) {\n    if (MP_PARSE_NODE_IS_ID(pn)) {\n        compile_delete_id(comp, MP_PARSE_NODE_LEAF_ARG(pn));\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_atom_expr_normal)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n\n        compile_node(comp, pns->nodes[0]); \n\n        if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {\n            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t *)pns->nodes[1];\n            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_atom_expr_trailers) {\n                int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1);\n                for (int i = 0; i < n - 1; i++) {\n                    compile_node(comp, pns1->nodes[i]);\n                }\n                assert(MP_PARSE_NODE_IS_STRUCT(pns1->nodes[n - 1]));\n                pns1 = (mp_parse_node_struct_t *)pns1->nodes[n - 1];\n            }\n            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_bracket) {\n                compile_node(comp, pns1->nodes[0]);\n                EMIT_ARG(subscr, MP_EMIT_SUBSCR_DELETE);\n            } else if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_period) {\n                assert(MP_PARSE_NODE_IS_ID(pns1->nodes[0]));\n                EMIT_ARG(attr, MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]), MP_EMIT_ATTR_DELETE);\n            } else {\n                goto cannot_delete;\n            }\n        } else {\n            goto cannot_delete;\n        }\n\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_atom_paren)) {\n        pn = ((mp_parse_node_struct_t *)pn)->nodes[0];\n        if (MP_PARSE_NODE_IS_NULL(pn)) {\n            goto cannot_delete;\n        } else {\n            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_testlist_comp));\n            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n            if (MP_PARSE_NODE_TESTLIST_COMP_HAS_COMP_FOR(pns)) {\n                goto cannot_delete;\n            }\n            for (size_t i = 0; i < MP_PARSE_NODE_STRUCT_NUM_NODES(pns); ++i) {\n                c_del_stmt(comp, pns->nodes[i]);\n            }\n        }\n    } else {\n        \n        goto cannot_delete;\n    }\n\n    return;\n\ncannot_delete:\n    compile_syntax_error(comp, (mp_parse_node_t)pn, MP_ERROR_TEXT(\"can't delete expression\"));\n}\n\nstatic void compile_del_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    apply_to_single_or_list(comp, pns->nodes[0], PN_exprlist, c_del_stmt);\n}\n\nstatic void compile_break_cont_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    uint16_t label;\n    if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_break_stmt) {\n        label = comp->break_label;\n    } else {\n        label = comp->continue_label;\n    }\n    if (label == INVALID_LABEL) {\n        compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"'break'/'continue' outside loop\"));\n    }\n    assert(comp->cur_except_level >= comp->break_continue_except_level);\n    EMIT_ARG(unwind_jump, label, comp->cur_except_level - comp->break_continue_except_level);\n}\n\nstatic void compile_return_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    #if MICROPY_CPYTHON_COMPAT\n    if (comp->scope_cur->kind != SCOPE_FUNCTION) {\n        compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"'return' outside function\"));\n        return;\n    }\n    #endif\n    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n        \n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n    } else if (MICROPY_COMP_RETURN_IF_EXPR\n               && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_test_if_expr)) {\n        \n        mp_parse_node_struct_t *pns_test_if_expr = (mp_parse_node_struct_t *)pns->nodes[0];\n        mp_parse_node_struct_t *pns_test_if_else = (mp_parse_node_struct_t *)pns_test_if_expr->nodes[1];\n\n        uint l_fail = comp_next_label(comp);\n        c_if_cond(comp, pns_test_if_else->nodes[0], false, l_fail); \n        compile_node(comp, pns_test_if_expr->nodes[0]); \n        EMIT(return_value);\n        EMIT_ARG(label_assign, l_fail);\n        compile_node(comp, pns_test_if_else->nodes[1]); \n    } else {\n        compile_node(comp, pns->nodes[0]);\n    }\n    EMIT(return_value);\n}\n\nstatic void compile_yield_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_node(comp, pns->nodes[0]);\n    EMIT(pop_top);\n}\n\nstatic void compile_raise_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n        \n        EMIT_ARG(raise_varargs, 0);\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_raise_stmt_arg)) {\n        \n        pns = (mp_parse_node_struct_t *)pns->nodes[0];\n        compile_node(comp, pns->nodes[0]);\n        compile_node(comp, pns->nodes[1]);\n        EMIT_ARG(raise_varargs, 2);\n    } else {\n        \n        compile_node(comp, pns->nodes[0]);\n        EMIT_ARG(raise_varargs, 1);\n    }\n}\n\n\n\n\nstatic void do_import_name(compiler_t *comp, mp_parse_node_t pn, qstr *q_base) {\n    bool is_as = false;\n    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_dotted_as_name)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        \n        *q_base = MP_PARSE_NODE_LEAF_ARG(pns->nodes[1]);\n        pn = pns->nodes[0];\n        is_as = true;\n    }\n    if (MP_PARSE_NODE_IS_NULL(pn)) {\n        \n        *q_base = MP_QSTR_;\n        EMIT_ARG(import, MP_QSTR_, MP_EMIT_IMPORT_NAME); \n    } else if (MP_PARSE_NODE_IS_ID(pn)) {\n        \n        qstr q_full = MP_PARSE_NODE_LEAF_ARG(pn);\n        if (!is_as) {\n            *q_base = q_full;\n        }\n        EMIT_ARG(import, q_full, MP_EMIT_IMPORT_NAME);\n    } else {\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_dotted_name)); \n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        {\n            \n            if (!is_as) {\n                *q_base = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n            }\n            size_t n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n            if (n == 0) {\n                \n                \n                MP_UNREACHABLE;\n            }\n            size_t len = n - 1;\n            for (size_t i = 0; i < n; i++) {\n                len += qstr_len(MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]));\n            }\n            char *q_ptr = mp_local_alloc(len);\n            char *str_dest = q_ptr;\n            for (size_t i = 0; i < n; i++) {\n                if (i > 0) {\n                    *str_dest++ = '.';\n                }\n                size_t str_src_len;\n                const byte *str_src = qstr_data(MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]), &str_src_len);\n                memcpy(str_dest, str_src, str_src_len);\n                str_dest += str_src_len;\n            }\n            qstr q_full = qstr_from_strn(q_ptr, len);\n            mp_local_free(q_ptr);\n            EMIT_ARG(import, q_full, MP_EMIT_IMPORT_NAME);\n            if (is_as) {\n                for (size_t i = 1; i < n; i++) {\n                    EMIT_ARG(attr, MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]), MP_EMIT_ATTR_LOAD);\n                }\n            }\n        }\n    }\n}\n\nstatic void compile_dotted_as_name(compiler_t *comp, mp_parse_node_t pn) {\n    EMIT_ARG(load_const_small_int, 0); \n    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE); \n    qstr q_base;\n    do_import_name(comp, pn, &q_base);\n    compile_store_id(comp, q_base);\n}\n\nstatic void compile_import_name(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    apply_to_single_or_list(comp, pns->nodes[0], PN_dotted_as_names, compile_dotted_as_name);\n}\n\nstatic void compile_import_from(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    mp_parse_node_t pn_import_source = pns->nodes[0];\n\n    \n    uint import_level = 0;\n    do {\n        mp_parse_node_t pn_rel;\n        if (MP_PARSE_NODE_IS_TOKEN(pn_import_source) || MP_PARSE_NODE_IS_STRUCT_KIND(pn_import_source, PN_one_or_more_period_or_ellipsis)) {\n            \n            pn_rel = pn_import_source;\n            pn_import_source = MP_PARSE_NODE_NULL;\n        } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn_import_source, PN_import_from_2b)) {\n            \n            mp_parse_node_struct_t *pns_2b = (mp_parse_node_struct_t *)pn_import_source;\n            pn_rel = pns_2b->nodes[0];\n            pn_import_source = pns_2b->nodes[1];\n            assert(!MP_PARSE_NODE_IS_NULL(pn_import_source)); \n        } else {\n            \n            break;\n        }\n\n        \n        mp_parse_node_t *nodes;\n        size_t n = mp_parse_node_extract_list(&pn_rel, PN_one_or_more_period_or_ellipsis, &nodes);\n\n        \n        for (size_t i = 0; i < n; i++) {\n            if (MP_PARSE_NODE_IS_TOKEN_KIND(nodes[i], MP_TOKEN_DEL_PERIOD)) {\n                import_level++;\n            } else {\n                \n                import_level += 3;\n            }\n        }\n    } while (0);\n\n    if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[1], MP_TOKEN_OP_STAR)) {\n        #if MICROPY_CPYTHON_COMPAT\n        if (comp->scope_cur->kind != SCOPE_MODULE) {\n            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"import * not at module level\"));\n            return;\n        }\n        #endif\n\n        EMIT_ARG(load_const_small_int, import_level);\n\n        \n        EMIT_ARG(load_const_str, MP_QSTR__star_);\n        EMIT_ARG(build, 1, MP_EMIT_BUILD_TUPLE);\n\n        \n        qstr dummy_q;\n        do_import_name(comp, pn_import_source, &dummy_q);\n        EMIT_ARG(import, MP_QSTRnull, MP_EMIT_IMPORT_STAR);\n\n    } else {\n        EMIT_ARG(load_const_small_int, import_level);\n\n        \n        mp_parse_node_t *pn_nodes;\n        size_t n = mp_parse_node_extract_list(&pns->nodes[1], PN_import_as_names, &pn_nodes);\n        for (size_t i = 0; i < n; i++) {\n            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_nodes[i], PN_import_as_name));\n            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t *)pn_nodes[i];\n            qstr id2 = MP_PARSE_NODE_LEAF_ARG(pns3->nodes[0]); \n            EMIT_ARG(load_const_str, id2);\n        }\n        EMIT_ARG(build, n, MP_EMIT_BUILD_TUPLE);\n\n        \n        qstr dummy_q;\n        do_import_name(comp, pn_import_source, &dummy_q);\n        for (size_t i = 0; i < n; i++) {\n            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_nodes[i], PN_import_as_name));\n            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t *)pn_nodes[i];\n            qstr id2 = MP_PARSE_NODE_LEAF_ARG(pns3->nodes[0]); \n            EMIT_ARG(import, id2, MP_EMIT_IMPORT_FROM);\n            if (MP_PARSE_NODE_IS_NULL(pns3->nodes[1])) {\n                compile_store_id(comp, id2);\n            } else {\n                compile_store_id(comp, MP_PARSE_NODE_LEAF_ARG(pns3->nodes[1]));\n            }\n        }\n        EMIT(pop_top);\n    }\n}\n\nstatic void compile_declare_global(compiler_t *comp, mp_parse_node_t pn, id_info_t *id_info) {\n    if (id_info->kind != ID_INFO_KIND_UNDECIDED && id_info->kind != ID_INFO_KIND_GLOBAL_EXPLICIT) {\n        compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"identifier redefined as global\"));\n        return;\n    }\n    id_info->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;\n\n    \n    id_info = scope_find_global(comp->scope_cur, id_info->qst);\n    if (id_info != NULL) {\n        id_info->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;\n    }\n}\n\nstatic void compile_declare_nonlocal(compiler_t *comp, mp_parse_node_t pn, id_info_t *id_info) {\n    if (id_info->kind == ID_INFO_KIND_UNDECIDED) {\n        id_info->kind = ID_INFO_KIND_GLOBAL_IMPLICIT;\n        scope_check_to_close_over(comp->scope_cur, id_info);\n        if (id_info->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {\n            compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"no binding for nonlocal found\"));\n        }\n    } else if (id_info->kind != ID_INFO_KIND_FREE) {\n        compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"identifier redefined as nonlocal\"));\n    }\n}\n\nstatic void compile_declare_global_or_nonlocal(compiler_t *comp, mp_parse_node_t pn, id_info_t *id_info, bool is_global) {\n    if (is_global) {\n        compile_declare_global(comp, pn, id_info);\n    } else {\n        compile_declare_nonlocal(comp, pn, id_info);\n    }\n}\n\nstatic void compile_global_nonlocal_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        bool is_global = MP_PARSE_NODE_STRUCT_KIND(pns) == PN_global_stmt;\n\n        if (!is_global && comp->scope_cur->kind == SCOPE_MODULE) {\n            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"can't declare nonlocal in outer code\"));\n            return;\n        }\n\n        mp_parse_node_t *nodes;\n        size_t n = mp_parse_node_extract_list(&pns->nodes[0], PN_name_list, &nodes);\n        for (size_t i = 0; i < n; i++) {\n            qstr qst = MP_PARSE_NODE_LEAF_ARG(nodes[i]);\n            id_info_t *id_info = scope_find_or_add_id(comp->scope_cur, qst, ID_INFO_KIND_UNDECIDED);\n            compile_declare_global_or_nonlocal(comp, (mp_parse_node_t)pns, id_info, is_global);\n        }\n    }\n}\n\nstatic void compile_assert_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    if (MP_STATE_VM(mp_optimise_value) != 0) {\n        return;\n    }\n\n    uint l_end = comp_next_label(comp);\n    c_if_cond(comp, pns->nodes[0], true, l_end);\n    EMIT_LOAD_GLOBAL(MP_QSTR_AssertionError); \n    if (!MP_PARSE_NODE_IS_NULL(pns->nodes[1])) {\n        \n        compile_node(comp, pns->nodes[1]);\n        EMIT_ARG(call_function, 1, 0, 0);\n    }\n    EMIT_ARG(raise_varargs, 1);\n    EMIT_ARG(label_assign, l_end);\n}\n\nstatic void compile_if_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    uint l_end = comp_next_label(comp);\n\n    \n    if (!mp_parse_node_is_const_false(pns->nodes[0])) {\n        uint l_fail = comp_next_label(comp);\n        c_if_cond(comp, pns->nodes[0], false, l_fail); \n\n        compile_node(comp, pns->nodes[1]); \n\n        \n        if (mp_parse_node_is_const_true(pns->nodes[0])) {\n            goto done;\n        }\n\n        \n        if (!(MP_PARSE_NODE_IS_NULL(pns->nodes[2]) && MP_PARSE_NODE_IS_NULL(pns->nodes[3]))) {\n            \n            EMIT_ARG(jump, l_end);\n        }\n\n        EMIT_ARG(label_assign, l_fail);\n    }\n\n    \n    mp_parse_node_t *pn_elif;\n    size_t n_elif = mp_parse_node_extract_list(&pns->nodes[2], PN_if_stmt_elif_list, &pn_elif);\n    for (size_t i = 0; i < n_elif; i++) {\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_elif[i], PN_if_stmt_elif)); \n        mp_parse_node_struct_t *pns_elif = (mp_parse_node_struct_t *)pn_elif[i];\n\n        \n        if (!mp_parse_node_is_const_false(pns_elif->nodes[0])) {\n            uint l_fail = comp_next_label(comp);\n            c_if_cond(comp, pns_elif->nodes[0], false, l_fail); \n\n            compile_node(comp, pns_elif->nodes[1]); \n\n            \n            if (mp_parse_node_is_const_true(pns_elif->nodes[0])) {\n                goto done;\n            }\n\n            EMIT_ARG(jump, l_end);\n            EMIT_ARG(label_assign, l_fail);\n        }\n    }\n\n    \n    compile_node(comp, pns->nodes[3]); \n\ndone:\n    EMIT_ARG(label_assign, l_end);\n}\n\n#define START_BREAK_CONTINUE_BLOCK \\\n    uint16_t old_break_label = comp->break_label; \\\n    uint16_t old_continue_label = comp->continue_label; \\\n    uint16_t old_break_continue_except_level = comp->break_continue_except_level; \\\n    uint break_label = comp_next_label(comp); \\\n    uint continue_label = comp_next_label(comp); \\\n    comp->break_label = break_label; \\\n    comp->continue_label = continue_label; \\\n    comp->break_continue_except_level = comp->cur_except_level;\n\n#define END_BREAK_CONTINUE_BLOCK \\\n    comp->break_label = old_break_label; \\\n    comp->continue_label = old_continue_label; \\\n    comp->break_continue_except_level = old_break_continue_except_level;\n\nstatic void compile_while_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    START_BREAK_CONTINUE_BLOCK\n\n    if (!mp_parse_node_is_const_false(pns->nodes[0])) { \n        uint top_label = comp_next_label(comp);\n        if (!mp_parse_node_is_const_true(pns->nodes[0])) { \n            EMIT_ARG(jump, continue_label);\n        }\n        EMIT_ARG(label_assign, top_label);\n        compile_node(comp, pns->nodes[1]); \n        EMIT_ARG(label_assign, continue_label);\n        c_if_cond(comp, pns->nodes[0], true, top_label); \n    }\n\n    \n    END_BREAK_CONTINUE_BLOCK\n\n    compile_node(comp, pns->nodes[2]); \n\n    EMIT_ARG(label_assign, break_label);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic void compile_for_stmt_optimised_range(compiler_t *comp, mp_parse_node_t pn_var, mp_parse_node_t pn_start, mp_parse_node_t pn_end, mp_parse_node_t pn_step, mp_parse_node_t pn_body, mp_parse_node_t pn_else) {\n    START_BREAK_CONTINUE_BLOCK\n\n    uint top_label = comp_next_label(comp);\n    uint entry_label = comp_next_label(comp);\n\n    \n    bool end_on_stack = !MP_PARSE_NODE_IS_SMALL_INT(pn_end);\n    if (end_on_stack) {\n        compile_node(comp, pn_end);\n    }\n\n    \n    compile_node(comp, pn_start);\n\n    EMIT_ARG(jump, entry_label);\n    EMIT_ARG(label_assign, top_label);\n\n    \n    EMIT(dup_top);\n    c_assign(comp, pn_var, ASSIGN_STORE);\n\n    \n    compile_node(comp, pn_body);\n\n    EMIT_ARG(label_assign, continue_label);\n\n    \n    compile_node(comp, pn_step);\n    EMIT_ARG(binary_op, MP_BINARY_OP_INPLACE_ADD);\n\n    EMIT_ARG(label_assign, entry_label);\n\n    \n    if (end_on_stack) {\n        EMIT(dup_top_two);\n        EMIT(rot_two);\n    } else {\n        EMIT(dup_top);\n        compile_node(comp, pn_end);\n    }\n    assert(MP_PARSE_NODE_IS_SMALL_INT(pn_step));\n    if (MP_PARSE_NODE_LEAF_SMALL_INT(pn_step) >= 0) {\n        EMIT_ARG(binary_op, MP_BINARY_OP_LESS);\n    } else {\n        EMIT_ARG(binary_op, MP_BINARY_OP_MORE);\n    }\n    EMIT_ARG(pop_jump_if, true, top_label);\n\n    \n    END_BREAK_CONTINUE_BLOCK\n\n    \n    \n    uint end_label = 0;\n    if (!MP_PARSE_NODE_IS_NULL(pn_else)) {\n        \n        EMIT(pop_top);\n        if (end_on_stack) {\n            EMIT(pop_top);\n        }\n        compile_node(comp, pn_else);\n        end_label = comp_next_label(comp);\n        EMIT_ARG(jump, end_label);\n        EMIT_ARG(adjust_stack_size, 1 + end_on_stack);\n    }\n\n    EMIT_ARG(label_assign, break_label);\n\n    \n    EMIT(pop_top);\n\n    \n    if (end_on_stack) {\n        EMIT(pop_top);\n    }\n\n    if (!MP_PARSE_NODE_IS_NULL(pn_else)) {\n        EMIT_ARG(label_assign, end_label);\n    }\n}\n\nstatic void compile_for_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    \n    \n    if (  MP_PARSE_NODE_IS_ID(pns->nodes[0]) && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_atom_expr_normal)) {\n        mp_parse_node_struct_t *pns_it = (mp_parse_node_struct_t *)pns->nodes[1];\n        if (MP_PARSE_NODE_IS_ID(pns_it->nodes[0])\n            && MP_PARSE_NODE_LEAF_ARG(pns_it->nodes[0]) == MP_QSTR_range\n            && MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t *)pns_it->nodes[1]) == PN_trailer_paren) {\n            mp_parse_node_t pn_range_args = ((mp_parse_node_struct_t *)pns_it->nodes[1])->nodes[0];\n            mp_parse_node_t *args;\n            size_t n_args = mp_parse_node_extract_list(&pn_range_args, PN_arglist, &args);\n            mp_parse_node_t pn_range_start;\n            mp_parse_node_t pn_range_end;\n            mp_parse_node_t pn_range_step;\n            bool optimize = false;\n            if (1 <= n_args && n_args <= 3) {\n                optimize = true;\n                if (n_args == 1) {\n                    pn_range_start = mp_parse_node_new_small_int(0);\n                    pn_range_end = args[0];\n                    pn_range_step = mp_parse_node_new_small_int(1);\n                } else if (n_args == 2) {\n                    pn_range_start = args[0];\n                    pn_range_end = args[1];\n                    pn_range_step = mp_parse_node_new_small_int(1);\n                } else {\n                    pn_range_start = args[0];\n                    pn_range_end = args[1];\n                    pn_range_step = args[2];\n                    \n                    if (!MP_PARSE_NODE_IS_SMALL_INT(pn_range_step)\n                        || MP_PARSE_NODE_LEAF_SMALL_INT(pn_range_step) == 0) {\n                        optimize = false;\n                    }\n                }\n                \n                if (optimize && MP_PARSE_NODE_IS_STRUCT(pn_range_start)) {\n                    int k = MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t *)pn_range_start);\n                    if (k == PN_arglist_star || k == PN_arglist_dbl_star || k == PN_argument) {\n                        optimize = false;\n                    }\n                }\n                if (optimize && MP_PARSE_NODE_IS_STRUCT(pn_range_end)) {\n                    int k = MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t *)pn_range_end);\n                    if (k == PN_arglist_star || k == PN_arglist_dbl_star || k == PN_argument) {\n                        optimize = false;\n                    }\n                }\n            }\n            if (optimize) {\n                compile_for_stmt_optimised_range(comp, pns->nodes[0], pn_range_start, pn_range_end, pn_range_step, pns->nodes[2], pns->nodes[3]);\n                return;\n            }\n        }\n    }\n\n    START_BREAK_CONTINUE_BLOCK\n    comp->break_label |= MP_EMIT_BREAK_FROM_FOR;\n\n    uint pop_label = comp_next_label(comp);\n\n    compile_node(comp, pns->nodes[1]); \n    EMIT_ARG(get_iter, true);\n    EMIT_ARG(label_assign, continue_label);\n    EMIT_ARG(for_iter, pop_label);\n    c_assign(comp, pns->nodes[0], ASSIGN_STORE); \n    compile_node(comp, pns->nodes[2]); \n    EMIT_ARG(jump, continue_label);\n    EMIT_ARG(label_assign, pop_label);\n    EMIT(for_iter_end);\n\n    \n    END_BREAK_CONTINUE_BLOCK\n\n    compile_node(comp, pns->nodes[3]); \n\n    EMIT_ARG(label_assign, break_label);\n}\n\nstatic void compile_try_except(compiler_t *comp, mp_parse_node_t pn_body, int n_except, mp_parse_node_t *pn_excepts, mp_parse_node_t pn_else) {\n    \n    uint l1 = comp_next_label(comp);\n    uint success_label = comp_next_label(comp);\n\n    compile_increase_except_level(comp, l1, MP_EMIT_SETUP_BLOCK_EXCEPT);\n\n    compile_node(comp, pn_body); \n    EMIT_ARG(pop_except_jump, success_label, false); \n\n    EMIT_ARG(label_assign, l1); \n    EMIT(start_except_handler);\n\n    \n\n    uint l2 = comp_next_label(comp);\n\n    for (int i = 0; i < n_except; i++) {\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_excepts[i], PN_try_stmt_except)); \n        mp_parse_node_struct_t *pns_except = (mp_parse_node_struct_t *)pn_excepts[i];\n\n        qstr qstr_exception_local = 0;\n        uint end_finally_label = comp_next_label(comp);\n        #if MICROPY_PY_SYS_SETTRACE\n        EMIT_ARG(set_source_line, pns_except->source_line);\n        #endif\n\n        if (MP_PARSE_NODE_IS_NULL(pns_except->nodes[0])) {\n            \n            if (i + 1 != n_except) {\n                compile_syntax_error(comp, pn_excepts[i], MP_ERROR_TEXT(\"default 'except' must be last\"));\n                compile_decrease_except_level(comp);\n                return;\n            }\n        } else {\n            \n            mp_parse_node_t pns_exception_expr = pns_except->nodes[0];\n            if (MP_PARSE_NODE_IS_STRUCT(pns_exception_expr)) {\n                mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t *)pns_exception_expr;\n                if (MP_PARSE_NODE_STRUCT_KIND(pns3) == PN_try_stmt_as_name) {\n                    \n                    pns_exception_expr = pns3->nodes[0];\n                    qstr_exception_local = MP_PARSE_NODE_LEAF_ARG(pns3->nodes[1]);\n                }\n            }\n            EMIT(dup_top);\n            compile_node(comp, pns_exception_expr);\n            EMIT_ARG(binary_op, MP_BINARY_OP_EXCEPTION_MATCH);\n            EMIT_ARG(pop_jump_if, false, end_finally_label);\n        }\n\n        \n        if (qstr_exception_local == 0) {\n            EMIT(pop_top);\n        } else {\n            compile_store_id(comp, qstr_exception_local);\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        uint l3 = 0;\n        if (qstr_exception_local != 0) {\n            l3 = comp_next_label(comp);\n            compile_increase_except_level(comp, l3, MP_EMIT_SETUP_BLOCK_FINALLY);\n        }\n        compile_node(comp, pns_except->nodes[1]); \n        if (qstr_exception_local != 0) {\n            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n            EMIT_ARG(label_assign, l3);\n            EMIT_ARG(adjust_stack_size, 1); \n            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n            compile_store_id(comp, qstr_exception_local);\n            compile_delete_id(comp, qstr_exception_local);\n            EMIT_ARG(adjust_stack_size, -1);\n            compile_decrease_except_level(comp);\n        }\n\n        EMIT_ARG(pop_except_jump, l2, true);\n        EMIT_ARG(label_assign, end_finally_label);\n        EMIT_ARG(adjust_stack_size, 1); \n    }\n\n    compile_decrease_except_level(comp);\n    EMIT(end_except_handler);\n\n    EMIT_ARG(label_assign, success_label);\n    compile_node(comp, pn_else); \n    EMIT_ARG(label_assign, l2);\n}\n\nstatic void compile_try_finally(compiler_t *comp, mp_parse_node_t pn_body, int n_except, mp_parse_node_t *pn_except, mp_parse_node_t pn_else, mp_parse_node_t pn_finally) {\n    uint l_finally_block = comp_next_label(comp);\n\n    compile_increase_except_level(comp, l_finally_block, MP_EMIT_SETUP_BLOCK_FINALLY);\n\n    if (n_except == 0) {\n        assert(MP_PARSE_NODE_IS_NULL(pn_else));\n        EMIT_ARG(adjust_stack_size, 3); \n        compile_node(comp, pn_body);\n        EMIT_ARG(adjust_stack_size, -3);\n    } else {\n        compile_try_except(comp, pn_body, n_except, pn_except, pn_else);\n    }\n\n    \n    \n    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n\n    \n    \n    \n    EMIT_ARG(label_assign, l_finally_block);\n    EMIT_ARG(adjust_stack_size, 1);\n    compile_node(comp, pn_finally);\n    EMIT_ARG(adjust_stack_size, -1);\n\n    compile_decrease_except_level(comp);\n}\n\nstatic void compile_try_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); \n    {\n        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t *)pns->nodes[1];\n        if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_try_stmt_finally) {\n            \n            compile_try_finally(comp, pns->nodes[0], 0, NULL, MP_PARSE_NODE_NULL, pns2->nodes[0]);\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_try_stmt_except_and_more) {\n            \n            mp_parse_node_t *pn_excepts;\n            size_t n_except = mp_parse_node_extract_list(&pns2->nodes[0], PN_try_stmt_except_list, &pn_excepts);\n            if (MP_PARSE_NODE_IS_NULL(pns2->nodes[2])) {\n                \n                compile_try_except(comp, pns->nodes[0], n_except, pn_excepts, pns2->nodes[1]);\n            } else {\n                \n                compile_try_finally(comp, pns->nodes[0], n_except, pn_excepts, pns2->nodes[1], ((mp_parse_node_struct_t *)pns2->nodes[2])->nodes[0]);\n            }\n        } else {\n            \n            mp_parse_node_t *pn_excepts;\n            size_t n_except = mp_parse_node_extract_list(&pns->nodes[1], PN_try_stmt_except_list, &pn_excepts);\n            compile_try_except(comp, pns->nodes[0], n_except, pn_excepts, MP_PARSE_NODE_NULL);\n        }\n    }\n}\n\nstatic void compile_with_stmt_helper(compiler_t *comp, size_t n, mp_parse_node_t *nodes, mp_parse_node_t body) {\n    if (n == 0) {\n        \n        compile_node(comp, body);\n    } else {\n        uint l_end = comp_next_label(comp);\n        if (MP_PARSE_NODE_IS_STRUCT_KIND(nodes[0], PN_with_item)) {\n            \n            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)nodes[0];\n            compile_node(comp, pns->nodes[0]);\n            compile_increase_except_level(comp, l_end, MP_EMIT_SETUP_BLOCK_WITH);\n            c_assign(comp, pns->nodes[1], ASSIGN_STORE);\n        } else {\n            \n            compile_node(comp, nodes[0]);\n            compile_increase_except_level(comp, l_end, MP_EMIT_SETUP_BLOCK_WITH);\n            EMIT(pop_top);\n        }\n        \n        compile_with_stmt_helper(comp, n - 1, nodes + 1, body);\n        \n        EMIT_ARG(with_cleanup, l_end);\n        reserve_labels_for_native(comp, 3); \n        compile_decrease_except_level(comp);\n    }\n}\n\nstatic void compile_with_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    mp_parse_node_t *nodes;\n    size_t n = mp_parse_node_extract_list(&pns->nodes[0], PN_with_stmt_list, &nodes);\n    assert(n > 0);\n\n    \n    compile_with_stmt_helper(comp, n, nodes, pns->nodes[1]);\n}\n\nstatic void compile_yield_from(compiler_t *comp) {\n    EMIT_ARG(get_iter, false);\n    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n    EMIT_ARG(yield, MP_EMIT_YIELD_FROM);\n    reserve_labels_for_native(comp, 3);\n}\n\n#if MICROPY_PY_ASYNC_AWAIT\nstatic void compile_await_object_method(compiler_t *comp, qstr method) {\n    EMIT_ARG(load_method, method, false);\n    EMIT_ARG(call_method, 0, 0, 0);\n    compile_yield_from(comp);\n}\n\nstatic void compile_async_for_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    uint while_else_label = comp_next_label(comp);\n    uint try_exception_label = comp_next_label(comp);\n    uint try_else_label = comp_next_label(comp);\n    uint try_finally_label = comp_next_label(comp);\n\n    \n\n    \n    compile_node(comp, pns->nodes[1]); \n    \n    EMIT_ARG(load_method, MP_QSTR___aiter__, false);\n    \n    EMIT_ARG(call_method, 0, 0, 0);\n    \n\n    START_BREAK_CONTINUE_BLOCK\n\n    EMIT_ARG(label_assign, continue_label);\n\n    compile_increase_except_level(comp, try_exception_label, MP_EMIT_SETUP_BLOCK_EXCEPT);\n\n    EMIT(dup_top);\n    \n\n    \n    compile_await_object_method(comp, MP_QSTR___anext__);\n    \n\n    c_assign(comp, pns->nodes[0], ASSIGN_STORE); \n    \n    EMIT_ARG(pop_except_jump, try_else_label, false);\n\n    EMIT_ARG(label_assign, try_exception_label);\n    EMIT(start_except_handler);\n    EMIT(dup_top);\n    EMIT_LOAD_GLOBAL(MP_QSTR_StopAsyncIteration);\n    EMIT_ARG(binary_op, MP_BINARY_OP_EXCEPTION_MATCH);\n    EMIT_ARG(pop_jump_if, false, try_finally_label);\n    EMIT(pop_top); \n    EMIT_ARG(pop_except_jump, while_else_label, true);\n\n    EMIT_ARG(label_assign, try_finally_label);\n    EMIT_ARG(adjust_stack_size, 1); \n    compile_decrease_except_level(comp);\n    EMIT(end_except_handler);\n\n    \n\n    EMIT_ARG(label_assign, try_else_label);\n    compile_node(comp, pns->nodes[2]); \n\n    EMIT_ARG(jump, continue_label);\n    \n    END_BREAK_CONTINUE_BLOCK\n\n    EMIT_ARG(label_assign, while_else_label);\n    compile_node(comp, pns->nodes[3]); \n\n    EMIT_ARG(label_assign, break_label);\n    \n\n    EMIT(pop_top);\n    \n}\n\nstatic void compile_async_with_stmt_helper(compiler_t *comp, size_t n, mp_parse_node_t *nodes, mp_parse_node_t body) {\n    if (n == 0) {\n        \n        compile_node(comp, body);\n    } else {\n        uint l_finally_block = comp_next_label(comp);\n        uint l_aexit_no_exc = comp_next_label(comp);\n        uint l_ret_unwind_jump = comp_next_label(comp);\n        uint l_end = comp_next_label(comp);\n\n        if (MP_PARSE_NODE_IS_STRUCT_KIND(nodes[0], PN_with_item)) {\n            \n            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)nodes[0];\n            compile_node(comp, pns->nodes[0]);\n            EMIT(dup_top);\n            compile_await_object_method(comp, MP_QSTR___aenter__);\n            c_assign(comp, pns->nodes[1], ASSIGN_STORE);\n        } else {\n            \n            compile_node(comp, nodes[0]);\n            EMIT(dup_top);\n            compile_await_object_method(comp, MP_QSTR___aenter__);\n            EMIT(pop_top);\n        }\n\n        \n        \n        \n\n        \n        compile_increase_except_level(comp, l_finally_block, MP_EMIT_SETUP_BLOCK_FINALLY);\n\n        \n        EMIT_ARG(adjust_stack_size, 3); \n        compile_async_with_stmt_helper(comp, n - 1, nodes + 1, body);\n        EMIT_ARG(adjust_stack_size, -3);\n\n        \n\n        \n        \n        \n        \n\n        \n        \n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE); \n        EMIT(rot_two);\n        EMIT_ARG(jump, l_aexit_no_exc); \n\n        \n        \n        EMIT_ARG(label_assign, l_finally_block);\n\n        \n        EMIT(dup_top);\n        EMIT_LOAD_GLOBAL(MP_QSTR_BaseException);\n        EMIT_ARG(binary_op, MP_BINARY_OP_EXCEPTION_MATCH);\n        EMIT_ARG(pop_jump_if, false, l_ret_unwind_jump); \n\n        \n        \n        EMIT(dup_top);\n        EMIT(rot_three);\n        EMIT(rot_two);\n        EMIT_ARG(load_method, MP_QSTR___aexit__, false);\n        EMIT(rot_three);\n        EMIT(rot_three);\n        EMIT(dup_top);\n        #if MICROPY_CPYTHON_COMPAT\n        EMIT_ARG(attr, MP_QSTR___class__, MP_EMIT_ATTR_LOAD); \n        #else\n        compile_load_id(comp, MP_QSTR_type);\n        EMIT(rot_two);\n        EMIT_ARG(call_function, 1, 0, 0); \n        #endif\n        EMIT(rot_two);\n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE); \n        \n        EMIT_ARG(call_method, 3, 0, 0);\n        compile_yield_from(comp);\n        EMIT_ARG(pop_jump_if, false, l_end);\n        EMIT(pop_top); \n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE); \n        EMIT_ARG(jump, l_end);\n        EMIT_ARG(adjust_stack_size, 2);\n\n        \n        \n        EMIT_ARG(label_assign, l_ret_unwind_jump);\n        EMIT(rot_three);\n        EMIT(rot_three);\n        EMIT_ARG(label_assign, l_aexit_no_exc);\n        EMIT_ARG(load_method, MP_QSTR___aexit__, false);\n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        EMIT(dup_top);\n        EMIT(dup_top);\n        EMIT_ARG(call_method, 3, 0, 0);\n        compile_yield_from(comp);\n        EMIT(pop_top);\n        EMIT_ARG(adjust_stack_size, -1);\n\n        \n        \n        \n        \n        \n        EMIT_ARG(label_assign, l_end);\n        compile_decrease_except_level(comp);\n    }\n}\n\nstatic void compile_async_with_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    mp_parse_node_t *nodes;\n    size_t n = mp_parse_node_extract_list(&pns->nodes[0], PN_with_stmt_list, &nodes);\n    assert(n > 0);\n\n    \n    compile_async_with_stmt_helper(comp, n, nodes, pns->nodes[1]);\n}\n\nstatic void compile_async_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[0]));\n    mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t *)pns->nodes[0];\n    if (MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_funcdef) {\n        \n        compile_funcdef(comp, pns0);\n        scope_t *fscope = (scope_t *)pns0->nodes[4];\n        fscope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;\n    } else {\n        \n        int scope_flags = comp->scope_cur->scope_flags;\n        if (!(scope_flags & MP_SCOPE_FLAG_GENERATOR)) {\n            compile_syntax_error(comp, (mp_parse_node_t)pns0,\n                MP_ERROR_TEXT(\"async for/with outside async function\"));\n            return;\n        }\n\n        if (MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_for_stmt) {\n            \n            compile_async_for_stmt(comp, pns0);\n        } else {\n            \n            assert(MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_with_stmt);\n            compile_async_with_stmt(comp, pns0);\n        }\n    }\n}\n#endif\n\nstatic void compile_expr_stmt(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    mp_parse_node_t pn_rhs = pns->nodes[1];\n    if (MP_PARSE_NODE_IS_NULL(pn_rhs)) {\n        if (comp->is_repl && comp->scope_cur->kind == SCOPE_MODULE) {\n            \n            compile_load_id(comp, MP_QSTR___repl_print__);\n            compile_node(comp, pns->nodes[0]);\n            EMIT_ARG(call_function, 1, 0, 0);\n            EMIT(pop_top);\n\n        } else {\n            \n            if ((MP_PARSE_NODE_IS_LEAF(pns->nodes[0]) && !MP_PARSE_NODE_IS_ID(pns->nodes[0]))\n                || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_const_object)) {\n                \n            } else {\n                compile_node(comp, pns->nodes[0]); \n                EMIT(pop_top); \n            }\n        }\n    } else if (MP_PARSE_NODE_IS_STRUCT(pn_rhs)) {\n        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t *)pn_rhs;\n        int kind = MP_PARSE_NODE_STRUCT_KIND(pns1);\n        if (kind == PN_annassign) {\n            \n            if (MP_PARSE_NODE_IS_NULL(pns1->nodes[1])) {\n                \n                \n                if (comp->scope_cur->kind == SCOPE_FUNCTION) {\n                    if (MP_PARSE_NODE_IS_ID(pns->nodes[0])) {\n                        qstr lhs = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n                        scope_find_or_add_id(comp->scope_cur, lhs, ID_INFO_KIND_LOCAL);\n                    }\n                }\n            } else {\n                \n                pn_rhs = pns1->nodes[1];\n                goto plain_assign;\n            }\n        } else if (kind == PN_expr_stmt_augassign) {\n            c_assign(comp, pns->nodes[0], ASSIGN_AUG_LOAD); \n            compile_node(comp, pns1->nodes[1]); \n            assert(MP_PARSE_NODE_IS_TOKEN(pns1->nodes[0]));\n            mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]);\n            mp_binary_op_t op = MP_BINARY_OP_INPLACE_OR + (tok - MP_TOKEN_DEL_PIPE_EQUAL);\n            EMIT_ARG(binary_op, op);\n            c_assign(comp, pns->nodes[0], ASSIGN_AUG_STORE); \n        } else if (kind == PN_expr_stmt_assign_list) {\n            int rhs = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1) - 1;\n            compile_node(comp, pns1->nodes[rhs]); \n            \n            if (rhs > 0) {\n                EMIT(dup_top);\n            }\n            c_assign(comp, pns->nodes[0], ASSIGN_STORE); \n            for (int i = 0; i < rhs; i++) {\n                if (i + 1 < rhs) {\n                    EMIT(dup_top);\n                }\n                c_assign(comp, pns1->nodes[i], ASSIGN_STORE); \n            }\n        } else {\n        plain_assign:\n            #if MICROPY_COMP_DOUBLE_TUPLE_ASSIGN\n            if (MP_PARSE_NODE_IS_STRUCT_KIND(pn_rhs, PN_testlist_star_expr)\n                && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_star_expr)) {\n                mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t *)pns->nodes[0];\n                pns1 = (mp_parse_node_struct_t *)pn_rhs;\n                uint32_t n_pns0 = MP_PARSE_NODE_STRUCT_NUM_NODES(pns0);\n                \n                \n                \n                \n                if (n_pns0 == MP_PARSE_NODE_STRUCT_NUM_NODES(pns1)\n                    && (n_pns0 == 2\n                        #if MICROPY_COMP_TRIPLE_TUPLE_ASSIGN\n                        || n_pns0 == 3\n                        #endif\n                        )\n                    && !MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[0], PN_star_expr)\n                    && !MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[1], PN_star_expr)\n                    #if MICROPY_COMP_TRIPLE_TUPLE_ASSIGN\n                    && (n_pns0 == 2 || !MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[2], PN_star_expr))\n                    #endif\n                    ) {\n                    \n                    compile_node(comp, pns1->nodes[0]); \n                    compile_node(comp, pns1->nodes[1]); \n                    #if MICROPY_COMP_TRIPLE_TUPLE_ASSIGN\n                    if (n_pns0 == 3) {\n                        compile_node(comp, pns1->nodes[2]); \n                        EMIT(rot_three);\n                    }\n                    #endif\n                    EMIT(rot_two);\n                    c_assign(comp, pns0->nodes[0], ASSIGN_STORE); \n                    c_assign(comp, pns0->nodes[1], ASSIGN_STORE); \n                    #if MICROPY_COMP_TRIPLE_TUPLE_ASSIGN\n                    if (n_pns0 == 3) {\n                        c_assign(comp, pns0->nodes[2], ASSIGN_STORE); \n                    }\n                    #endif\n                    return;\n                }\n            }\n            #endif\n\n            compile_node(comp, pn_rhs); \n            c_assign(comp, pns->nodes[0], ASSIGN_STORE); \n        }\n    } else {\n        goto plain_assign;\n    }\n}\n\nstatic void compile_test_if_expr(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_test_if_else));\n    mp_parse_node_struct_t *pns_test_if_else = (mp_parse_node_struct_t *)pns->nodes[1];\n\n    uint l_fail = comp_next_label(comp);\n    uint l_end = comp_next_label(comp);\n    c_if_cond(comp, pns_test_if_else->nodes[0], false, l_fail); \n    compile_node(comp, pns->nodes[0]); \n    EMIT_ARG(jump, l_end);\n    EMIT_ARG(label_assign, l_fail);\n    EMIT_ARG(adjust_stack_size, -1); \n    compile_node(comp, pns_test_if_else->nodes[1]); \n    EMIT_ARG(label_assign, l_end);\n}\n\nstatic void compile_lambdef(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (comp->pass == MP_PASS_SCOPE) {\n        \n        scope_t *s = scope_new_and_link(comp, SCOPE_LAMBDA, (mp_parse_node_t)pns, comp->scope_cur->emit_options);\n        \n        pns->nodes[2] = (mp_parse_node_t)s;\n    }\n\n    \n    scope_t *this_scope = (scope_t *)pns->nodes[2];\n\n    \n    compile_funcdef_lambdef(comp, this_scope, pns->nodes[0], PN_varargslist);\n}\n\n#if MICROPY_PY_ASSIGN_EXPR\nstatic void compile_namedexpr_helper(compiler_t *comp, mp_parse_node_t pn_name, mp_parse_node_t pn_expr) {\n    if (!MP_PARSE_NODE_IS_ID(pn_name)) {\n        compile_syntax_error(comp, (mp_parse_node_t)pn_name, MP_ERROR_TEXT(\"can't assign to expression\"));\n    }\n    compile_node(comp, pn_expr);\n    EMIT(dup_top);\n\n    qstr target = MP_PARSE_NODE_LEAF_ARG(pn_name);\n\n    \n    \n    \n    if (comp->pass == MP_PASS_SCOPE && SCOPE_IS_COMP_LIKE(comp->scope_cur->kind)) {\n        id_info_t *id_info_parent = mp_emit_common_get_id_for_modification(comp->scope_cur->parent, target);\n        if (id_info_parent->kind == ID_INFO_KIND_GLOBAL_EXPLICIT) {\n            scope_find_or_add_id(comp->scope_cur, target, ID_INFO_KIND_GLOBAL_EXPLICIT);\n        } else {\n            id_info_t *id_info = scope_find_or_add_id(comp->scope_cur, target, ID_INFO_KIND_UNDECIDED);\n            bool is_global = comp->scope_cur->parent->parent == NULL; \n            if (!is_global && id_info->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {\n                \n                \n                id_info->kind = ID_INFO_KIND_UNDECIDED;\n            }\n            compile_declare_global_or_nonlocal(comp, pn_name, id_info, is_global);\n        }\n    }\n\n    \n    compile_store_id(comp, target);\n}\n\nstatic void compile_namedexpr(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_namedexpr_helper(comp, pns->nodes[0], pns->nodes[1]);\n}\n#endif\n\nstatic void compile_or_and_test(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    bool cond = MP_PARSE_NODE_STRUCT_KIND(pns) == PN_or_test;\n    uint l_end = comp_next_label(comp);\n    int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n    for (int i = 0; i < n; i += 1) {\n        compile_node(comp, pns->nodes[i]);\n        if (i + 1 < n) {\n            EMIT_ARG(jump_if_or_pop, cond, l_end);\n        }\n    }\n    EMIT_ARG(label_assign, l_end);\n}\n\nstatic void compile_not_test_2(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_node(comp, pns->nodes[0]);\n    EMIT_ARG(unary_op, MP_UNARY_OP_NOT);\n}\n\nstatic void compile_comparison(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n    compile_node(comp, pns->nodes[0]);\n    bool multi = (num_nodes > 3);\n    uint l_fail = 0;\n    if (multi) {\n        l_fail = comp_next_label(comp);\n    }\n    for (int i = 1; i + 1 < num_nodes; i += 2) {\n        compile_node(comp, pns->nodes[i + 1]);\n        if (i + 2 < num_nodes) {\n            EMIT(dup_top);\n            EMIT(rot_three);\n        }\n        if (MP_PARSE_NODE_IS_TOKEN(pns->nodes[i])) {\n            mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]);\n            mp_binary_op_t op;\n            if (tok == MP_TOKEN_KW_IN) {\n                op = MP_BINARY_OP_IN;\n            } else {\n                op = MP_BINARY_OP_LESS + (tok - MP_TOKEN_OP_LESS);\n            }\n            EMIT_ARG(binary_op, op);\n        } else {\n            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[i])); \n            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t *)pns->nodes[i];\n            int kind = MP_PARSE_NODE_STRUCT_KIND(pns2);\n            if (kind == PN_comp_op_not_in) {\n                EMIT_ARG(binary_op, MP_BINARY_OP_NOT_IN);\n            } else {\n                assert(kind == PN_comp_op_is); \n                if (MP_PARSE_NODE_IS_NULL(pns2->nodes[0])) {\n                    EMIT_ARG(binary_op, MP_BINARY_OP_IS);\n                } else {\n                    EMIT_ARG(binary_op, MP_BINARY_OP_IS_NOT);\n                }\n            }\n        }\n        if (i + 2 < num_nodes) {\n            EMIT_ARG(jump_if_or_pop, false, l_fail);\n        }\n    }\n    if (multi) {\n        uint l_end = comp_next_label(comp);\n        EMIT_ARG(jump, l_end);\n        EMIT_ARG(label_assign, l_fail);\n        EMIT_ARG(adjust_stack_size, 1);\n        EMIT(rot_two);\n        EMIT(pop_top);\n        EMIT_ARG(label_assign, l_end);\n    }\n}\n\nstatic void compile_star_expr(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"*x must be assignment target\"));\n}\n\nstatic void compile_binary_op(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    MP_STATIC_ASSERT(MP_BINARY_OP_OR + PN_xor_expr - PN_expr == MP_BINARY_OP_XOR);\n    MP_STATIC_ASSERT(MP_BINARY_OP_OR + PN_and_expr - PN_expr == MP_BINARY_OP_AND);\n    mp_binary_op_t binary_op = MP_BINARY_OP_OR + MP_PARSE_NODE_STRUCT_KIND(pns) - PN_expr;\n    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n    compile_node(comp, pns->nodes[0]);\n    for (int i = 1; i < num_nodes; ++i) {\n        compile_node(comp, pns->nodes[i]);\n        EMIT_ARG(binary_op, binary_op);\n    }\n}\n\nstatic void compile_term(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n    compile_node(comp, pns->nodes[0]);\n    for (int i = 1; i + 1 < num_nodes; i += 2) {\n        compile_node(comp, pns->nodes[i + 1]);\n        mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]);\n        mp_binary_op_t op = MP_BINARY_OP_LSHIFT + (tok - MP_TOKEN_OP_DBL_LESS);\n        EMIT_ARG(binary_op, op);\n    }\n}\n\nstatic void compile_factor_2(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_node(comp, pns->nodes[1]);\n    mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n    mp_unary_op_t op;\n    if (tok == MP_TOKEN_OP_TILDE) {\n        op = MP_UNARY_OP_INVERT;\n    } else {\n        assert(tok == MP_TOKEN_OP_PLUS || tok == MP_TOKEN_OP_MINUS);\n        op = MP_UNARY_OP_POSITIVE + (tok - MP_TOKEN_OP_PLUS);\n    }\n    EMIT_ARG(unary_op, op);\n}\n\nstatic void compile_atom_expr_normal(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    compile_node(comp, pns->nodes[0]);\n\n    \n    if (MP_PARSE_NODE_IS_NULL(pns->nodes[1])) {\n        return;\n    }\n\n    \n    size_t num_trail = 1;\n    mp_parse_node_struct_t **pns_trail = (mp_parse_node_struct_t **)&pns->nodes[1];\n    if (MP_PARSE_NODE_STRUCT_KIND(pns_trail[0]) == PN_atom_expr_trailers) {\n        num_trail = MP_PARSE_NODE_STRUCT_NUM_NODES(pns_trail[0]);\n        pns_trail = (mp_parse_node_struct_t **)&pns_trail[0]->nodes[0];\n    }\n\n    \n    size_t i = 0;\n\n    \n    if (comp->scope_cur->kind == SCOPE_FUNCTION\n        && MP_PARSE_NODE_IS_ID(pns->nodes[0])\n        && MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]) == MP_QSTR_super\n        && MP_PARSE_NODE_STRUCT_KIND(pns_trail[0]) == PN_trailer_paren\n        && MP_PARSE_NODE_IS_NULL(pns_trail[0]->nodes[0])) {\n        \n\n        \n        compile_load_id(comp, MP_QSTR___class__);\n\n        \n        bool found = false;\n        id_info_t *id = &comp->scope_cur->id_info[0];\n        for (size_t n = comp->scope_cur->id_info_len; n > 0; --n, ++id) {\n            if (id->flags & ID_FLAG_IS_PARAM) {\n                \n                compile_load_id(comp, id->qst);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            compile_syntax_error(comp, (mp_parse_node_t)pns_trail[0],\n                MP_ERROR_TEXT(\"super() can't find self\")); \n            return;\n        }\n\n        if (num_trail >= 3\n            && MP_PARSE_NODE_STRUCT_KIND(pns_trail[1]) == PN_trailer_period\n            && MP_PARSE_NODE_STRUCT_KIND(pns_trail[2]) == PN_trailer_paren) {\n            \n            mp_parse_node_struct_t *pns_period = pns_trail[1];\n            mp_parse_node_struct_t *pns_paren = pns_trail[2];\n            EMIT_ARG(load_method, MP_PARSE_NODE_LEAF_ARG(pns_period->nodes[0]), true);\n            compile_trailer_paren_helper(comp, pns_paren->nodes[0], true, 0);\n            i = 3;\n        } else {\n            \n            EMIT_ARG(call_function, 2, 0, 0);\n            i = 1;\n        }\n\n        #if MICROPY_COMP_CONST_LITERAL && MICROPY_PY_COLLECTIONS_ORDEREDDICT\n        \n    } else if (MP_PARSE_NODE_IS_ID(pns->nodes[0])\n               && MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]) == MP_QSTR_OrderedDict\n               && MP_PARSE_NODE_STRUCT_KIND(pns_trail[0]) == PN_trailer_paren\n               && MP_PARSE_NODE_IS_STRUCT_KIND(pns_trail[0]->nodes[0], PN_atom_brace)) {\n        \n\n        EMIT_ARG(call_function, 0, 0, 0);\n        mp_parse_node_struct_t *pns_dict = (mp_parse_node_struct_t *)pns_trail[0]->nodes[0];\n        compile_atom_brace_helper(comp, pns_dict, false);\n        i = 1;\n        #endif\n    }\n\n    \n    for (; i < num_trail; i++) {\n        if (i + 1 < num_trail\n            && MP_PARSE_NODE_STRUCT_KIND(pns_trail[i]) == PN_trailer_period\n            && MP_PARSE_NODE_STRUCT_KIND(pns_trail[i + 1]) == PN_trailer_paren) {\n            \n            mp_parse_node_struct_t *pns_period = pns_trail[i];\n            mp_parse_node_struct_t *pns_paren = pns_trail[i + 1];\n            EMIT_ARG(load_method, MP_PARSE_NODE_LEAF_ARG(pns_period->nodes[0]), false);\n            compile_trailer_paren_helper(comp, pns_paren->nodes[0], true, 0);\n            i += 1;\n        } else {\n            \n            compile_node(comp, (mp_parse_node_t)pns_trail[i]);\n        }\n    }\n}\n\nstatic void compile_power(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_generic_all_nodes(comp, pns); \n    EMIT_ARG(binary_op, MP_BINARY_OP_POWER);\n}\n\nstatic void compile_trailer_paren_helper(compiler_t *comp, mp_parse_node_t pn_arglist, bool is_method_call, int n_positional_extra) {\n    \n\n    \n    mp_parse_node_t *args;\n    size_t n_args = mp_parse_node_extract_list(&pn_arglist, PN_arglist, &args);\n\n    \n    \n    \n    \n    int n_positional = n_positional_extra;\n    uint n_keyword = 0;\n    uint star_flags = 0;\n    mp_uint_t star_args = 0;\n    for (size_t i = 0; i < n_args; i++) {\n        if (MP_PARSE_NODE_IS_STRUCT(args[i])) {\n            mp_parse_node_struct_t *pns_arg = (mp_parse_node_struct_t *)args[i];\n            if (MP_PARSE_NODE_STRUCT_KIND(pns_arg) == PN_arglist_star) {\n                if (star_flags & MP_EMIT_STAR_FLAG_DOUBLE) {\n                    compile_syntax_error(comp, (mp_parse_node_t)pns_arg, MP_ERROR_TEXT(\"* arg after **\"));\n                    return;\n                }\n                #if MICROPY_DYNAMIC_COMPILER\n                if (i >= (size_t)mp_dynamic_compiler.small_int_bits - 1)\n                #else\n                if (i >= MP_SMALL_INT_BITS - 1)\n                #endif\n                {\n                    \n                    \n                    compile_syntax_error(comp, (mp_parse_node_t)pns_arg, MP_ERROR_TEXT(\"too many args\"));\n                    return;\n                }\n                star_flags |= MP_EMIT_STAR_FLAG_SINGLE;\n                star_args |= (mp_uint_t)1 << i;\n                compile_node(comp, pns_arg->nodes[0]);\n                n_positional++;\n            } else if (MP_PARSE_NODE_STRUCT_KIND(pns_arg) == PN_arglist_dbl_star) {\n                star_flags |= MP_EMIT_STAR_FLAG_DOUBLE;\n                \n                EMIT(load_null);\n                compile_node(comp, pns_arg->nodes[0]);\n                n_keyword++;\n            } else if (MP_PARSE_NODE_STRUCT_KIND(pns_arg) == PN_argument) {\n                #if MICROPY_PY_ASSIGN_EXPR\n                if (MP_PARSE_NODE_IS_STRUCT_KIND(pns_arg->nodes[1], PN_argument_3)) {\n                    compile_namedexpr_helper(comp, pns_arg->nodes[0], ((mp_parse_node_struct_t *)pns_arg->nodes[1])->nodes[0]);\n                    n_positional++;\n                } else\n                #endif\n                if (!MP_PARSE_NODE_IS_STRUCT_KIND(pns_arg->nodes[1], PN_comp_for)) {\n                    if (!MP_PARSE_NODE_IS_ID(pns_arg->nodes[0])) {\n                        compile_syntax_error(comp, (mp_parse_node_t)pns_arg, MP_ERROR_TEXT(\"LHS of keyword arg must be an id\"));\n                        return;\n                    }\n                    EMIT_ARG(load_const_str, MP_PARSE_NODE_LEAF_ARG(pns_arg->nodes[0]));\n                    compile_node(comp, pns_arg->nodes[1]);\n                    n_keyword++;\n                } else {\n                    compile_comprehension(comp, pns_arg, SCOPE_GEN_EXPR);\n                    n_positional++;\n                }\n            } else {\n                goto normal_argument;\n            }\n        } else {\n        normal_argument:\n            if (star_flags & MP_EMIT_STAR_FLAG_DOUBLE) {\n                compile_syntax_error(comp, args[i], MP_ERROR_TEXT(\"positional arg after **\"));\n                return;\n            }\n            if (n_keyword > 0) {\n                compile_syntax_error(comp, args[i], MP_ERROR_TEXT(\"positional arg after keyword arg\"));\n                return;\n            }\n            compile_node(comp, args[i]);\n            n_positional++;\n        }\n    }\n\n    if (star_flags != 0) {\n        \n        EMIT_ARG(load_const_small_int, star_args);\n    }\n\n    \n    if (is_method_call) {\n        EMIT_ARG(call_method, n_positional, n_keyword, star_flags);\n    } else {\n        EMIT_ARG(call_function, n_positional, n_keyword, star_flags);\n    }\n}\n\n\nstatic void compile_comprehension(compiler_t *comp, mp_parse_node_struct_t *pns, scope_kind_t kind) {\n    assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2);\n    assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for));\n    mp_parse_node_struct_t *pns_comp_for = (mp_parse_node_struct_t *)pns->nodes[1];\n\n    if (comp->pass == MP_PASS_SCOPE) {\n        \n        scope_t *s = scope_new_and_link(comp, kind, (mp_parse_node_t)pns, comp->scope_cur->emit_options);\n        \n        pns_comp_for->nodes[3] = (mp_parse_node_t)s;\n    }\n\n    \n    scope_t *this_scope = (scope_t *)pns_comp_for->nodes[3];\n\n    \n    close_over_variables_etc(comp, this_scope, 0, 0);\n\n    compile_node(comp, pns_comp_for->nodes[1]); \n    if (kind == SCOPE_GEN_EXPR) {\n        EMIT_ARG(get_iter, false);\n    }\n    EMIT_ARG(call_function, 1, 0, 0);\n}\n\nstatic void compile_atom_paren(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n        \n        EMIT_ARG(build, 0, MP_EMIT_BUILD_TUPLE);\n    } else {\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp));\n        pns = (mp_parse_node_struct_t *)pns->nodes[0];\n        if (MP_PARSE_NODE_TESTLIST_COMP_HAS_COMP_FOR(pns)) {\n            \n            compile_comprehension(comp, pns, SCOPE_GEN_EXPR);\n        } else {\n            \n            compile_generic_tuple(comp, pns);\n        }\n    }\n}\n\nstatic void compile_atom_bracket(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n        \n        EMIT_ARG(build, 0, MP_EMIT_BUILD_LIST);\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)) {\n        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t *)pns->nodes[0];\n        if (MP_PARSE_NODE_TESTLIST_COMP_HAS_COMP_FOR(pns2)) {\n            \n            compile_comprehension(comp, pns2, SCOPE_LIST_COMP);\n        } else {\n            \n            compile_generic_all_nodes(comp, pns2);\n            EMIT_ARG(build, MP_PARSE_NODE_STRUCT_NUM_NODES(pns2), MP_EMIT_BUILD_LIST);\n        }\n    } else {\n        \n        compile_node(comp, pns->nodes[0]);\n        EMIT_ARG(build, 1, MP_EMIT_BUILD_LIST);\n    }\n}\n\nstatic void compile_atom_brace_helper(compiler_t *comp, mp_parse_node_struct_t *pns, bool create_map) {\n    mp_parse_node_t pn = pns->nodes[0];\n    if (MP_PARSE_NODE_IS_NULL(pn)) {\n        \n        if (create_map) {\n            EMIT_ARG(build, 0, MP_EMIT_BUILD_MAP);\n        }\n    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n        pns = (mp_parse_node_struct_t *)pn;\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_dictorsetmaker_item) {\n            \n            if (create_map) {\n                EMIT_ARG(build, 1, MP_EMIT_BUILD_MAP);\n            }\n            compile_node(comp, pn);\n            EMIT(store_map);\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_dictorsetmaker) {\n            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); \n            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t *)pns->nodes[1];\n            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_dictorsetmaker_list) {\n                \n\n                \n                mp_parse_node_t *nodes;\n                size_t n = mp_parse_node_extract_list(&pns1->nodes[0], PN_dictorsetmaker_list2, &nodes);\n\n                \n                bool is_dict;\n                if (!MICROPY_PY_BUILTINS_SET || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_dictorsetmaker_item)) {\n                    \n                    if (create_map) {\n                        EMIT_ARG(build, 1 + n, MP_EMIT_BUILD_MAP);\n                    }\n                    compile_node(comp, pns->nodes[0]);\n                    EMIT(store_map);\n                    is_dict = true;\n                } else {\n                    \n                    compile_node(comp, pns->nodes[0]); \n                    is_dict = false;\n                }\n\n                \n                for (size_t i = 0; i < n; i++) {\n                    mp_parse_node_t pn_i = nodes[i];\n                    bool is_key_value = MP_PARSE_NODE_IS_STRUCT_KIND(pn_i, PN_dictorsetmaker_item);\n                    compile_node(comp, pn_i);\n                    if (is_dict) {\n                        if (!is_key_value) {\n                            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"invalid syntax\"));\n                            #else\n                            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"expecting key:value for dict\"));\n                            #endif\n                            return;\n                        }\n                        EMIT(store_map);\n                    } else {\n                        if (is_key_value) {\n                            #if MICROPY_ERROR_REPORTING <= MICROPY_ERROR_REPORTING_TERSE\n                            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"invalid syntax\"));\n                            #else\n                            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"expecting just a value for set\"));\n                            #endif\n                            return;\n                        }\n                    }\n                }\n\n                #if MICROPY_PY_BUILTINS_SET\n                \n                if (!is_dict) {\n                    EMIT_ARG(build, 1 + n, MP_EMIT_BUILD_SET);\n                }\n                #endif\n            } else {\n                assert(MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_comp_for); \n                \n                if (!MICROPY_PY_BUILTINS_SET || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_dictorsetmaker_item)) {\n                    \n                    compile_comprehension(comp, pns, SCOPE_DICT_COMP);\n                } else {\n                    \n                    compile_comprehension(comp, pns, SCOPE_SET_COMP);\n                }\n            }\n        } else {\n            \n            goto set_with_one_element;\n        }\n    } else {\n        \n    set_with_one_element:\n        #if MICROPY_PY_BUILTINS_SET\n        compile_node(comp, pn);\n        EMIT_ARG(build, 1, MP_EMIT_BUILD_SET);\n        #else\n        assert(0);\n        #endif\n    }\n}\n\nstatic void compile_atom_brace(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_atom_brace_helper(comp, pns, true);\n}\n\nstatic void compile_trailer_paren(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    compile_trailer_paren_helper(comp, pns->nodes[0], false, 0);\n}\n\nstatic void compile_trailer_bracket(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    compile_node(comp, pns->nodes[0]); \n    EMIT_ARG(subscr, MP_EMIT_SUBSCR_LOAD);\n}\n\nstatic void compile_trailer_period(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    EMIT_ARG(attr, MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]), MP_EMIT_ATTR_LOAD); \n}\n\n#if MICROPY_PY_BUILTINS_SLICE\nstatic void compile_subscript(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_2) {\n        compile_node(comp, pns->nodes[0]); \n        assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); \n        pns = (mp_parse_node_struct_t *)pns->nodes[1];\n    } else {\n        \n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n    }\n\n    assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3); \n    mp_parse_node_t pn = pns->nodes[0];\n    if (MP_PARSE_NODE_IS_NULL(pn)) {\n        \n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        EMIT_ARG(build, 2, MP_EMIT_BUILD_SLICE);\n    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {\n        pns = (mp_parse_node_struct_t *)pn;\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3c) {\n            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n            pn = pns->nodes[0];\n            if (MP_PARSE_NODE_IS_NULL(pn)) {\n                \n                EMIT_ARG(build, 2, MP_EMIT_BUILD_SLICE);\n            } else {\n                \n                compile_node(comp, pn);\n                EMIT_ARG(build, 3, MP_EMIT_BUILD_SLICE);\n            }\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3d) {\n            compile_node(comp, pns->nodes[0]);\n            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); \n            pns = (mp_parse_node_struct_t *)pns->nodes[1];\n            assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_sliceop); \n            if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n                \n                EMIT_ARG(build, 2, MP_EMIT_BUILD_SLICE);\n            } else {\n                \n                compile_node(comp, pns->nodes[0]);\n                EMIT_ARG(build, 3, MP_EMIT_BUILD_SLICE);\n            }\n        } else {\n            \n            compile_node(comp, pn);\n            EMIT_ARG(build, 2, MP_EMIT_BUILD_SLICE);\n        }\n    } else {\n        \n        compile_node(comp, pn);\n        EMIT_ARG(build, 2, MP_EMIT_BUILD_SLICE);\n    }\n}\n#endif \n\nstatic void compile_dictorsetmaker_item(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    \n    compile_node(comp, pns->nodes[1]); \n    compile_node(comp, pns->nodes[0]); \n}\n\nstatic void compile_classdef(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    qstr cname = compile_classdef_helper(comp, pns, comp->scope_cur->emit_options);\n    \n    compile_store_id(comp, cname);\n}\n\nstatic void compile_yield_expr(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (comp->scope_cur->kind != SCOPE_FUNCTION && comp->scope_cur->kind != SCOPE_LAMBDA) {\n        compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"'yield' outside function\"));\n        return;\n    }\n    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        EMIT_ARG(yield, MP_EMIT_YIELD_VALUE);\n        reserve_labels_for_native(comp, 1);\n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_yield_arg_from)) {\n        pns = (mp_parse_node_struct_t *)pns->nodes[0];\n        compile_node(comp, pns->nodes[0]);\n        compile_yield_from(comp);\n    } else {\n        compile_node(comp, pns->nodes[0]);\n        EMIT_ARG(yield, MP_EMIT_YIELD_VALUE);\n        reserve_labels_for_native(comp, 1);\n    }\n}\n\n#if MICROPY_PY_ASYNC_AWAIT\nstatic void compile_atom_expr_await(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    if (comp->scope_cur->kind != SCOPE_FUNCTION && comp->scope_cur->kind != SCOPE_LAMBDA) {\n        #if MICROPY_COMP_ALLOW_TOP_LEVEL_AWAIT\n        if (!mp_compile_allow_top_level_await)\n        #endif\n        {\n            compile_syntax_error(comp, (mp_parse_node_t)pns, MP_ERROR_TEXT(\"'await' outside function\"));\n            return;\n        }\n    }\n    compile_atom_expr_normal(comp, pns);\n    compile_yield_from(comp);\n}\n#endif\n\nstatic mp_obj_t get_const_object(mp_parse_node_struct_t *pns) {\n    return mp_parse_node_extract_const_object(pns);\n}\n\nstatic void compile_const_object(compiler_t *comp, mp_parse_node_struct_t *pns) {\n    EMIT_ARG(load_const_obj, get_const_object(pns));\n}\n\ntypedef void (*compile_function_t)(compiler_t *, mp_parse_node_struct_t *);\nstatic const compile_function_t compile_function[] = {\n\n#define c(f) compile_##f\n#define DEF_RULE(rule, comp, kind, ...) comp,\n#define DEF_RULE_NC(rule, kind, ...)\n    #include \"py/grammar.h\"\n#undef c\n#undef DEF_RULE\n#undef DEF_RULE_NC\n    compile_const_object,\n};\n\nstatic void compile_node(compiler_t *comp, mp_parse_node_t pn) {\n    if (MP_PARSE_NODE_IS_NULL(pn)) {\n        \n    } else if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {\n        mp_int_t arg = MP_PARSE_NODE_LEAF_SMALL_INT(pn);\n        EMIT_ARG(load_const_small_int, arg);\n    } else if (MP_PARSE_NODE_IS_LEAF(pn)) {\n        uintptr_t arg = MP_PARSE_NODE_LEAF_ARG(pn);\n        switch (MP_PARSE_NODE_LEAF_KIND(pn)) {\n            case MP_PARSE_NODE_ID:\n                compile_load_id(comp, arg);\n                break;\n            case MP_PARSE_NODE_STRING:\n                EMIT_ARG(load_const_str, arg);\n                break;\n            case MP_PARSE_NODE_TOKEN:\n            default:\n                if (arg == MP_TOKEN_NEWLINE) {\n                    \n                    \n                    \n                } else {\n                    EMIT_ARG(load_const_tok, arg);\n                }\n                break;\n        }\n    } else {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        EMIT_ARG(set_source_line, pns->source_line);\n        assert(MP_PARSE_NODE_STRUCT_KIND(pns) <= PN_const_object);\n        compile_function_t f = compile_function[MP_PARSE_NODE_STRUCT_KIND(pns)];\n        f(comp, pns);\n    }\n}\n\n#if MICROPY_EMIT_NATIVE\nstatic int compile_viper_type_annotation(compiler_t *comp, mp_parse_node_t pn_annotation) {\n    int native_type = MP_NATIVE_TYPE_OBJ;\n    if (MP_PARSE_NODE_IS_NULL(pn_annotation)) {\n        \n    } else if (MP_PARSE_NODE_IS_ID(pn_annotation)) {\n        qstr type_name = MP_PARSE_NODE_LEAF_ARG(pn_annotation);\n        native_type = mp_native_type_from_qstr(type_name);\n        if (native_type < 0) {\n            comp->compile_error = mp_obj_new_exception_msg_varg(&mp_type_ViperTypeError, MP_ERROR_TEXT(\"unknown type '%q'\"), type_name);\n            native_type = 0;\n        }\n    } else {\n        compile_syntax_error(comp, pn_annotation, MP_ERROR_TEXT(\"annotation must be an identifier\"));\n    }\n    return native_type;\n}\n#endif\n\nstatic void compile_scope_func_lambda_param(compiler_t *comp, mp_parse_node_t pn, pn_kind_t pn_name, pn_kind_t pn_star, pn_kind_t pn_dbl_star) {\n    (void)pn_dbl_star;\n\n    \n    if ((comp->scope_cur->scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {\n        compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"invalid syntax\"));\n        return;\n    }\n\n    qstr param_name = MP_QSTRnull;\n    uint param_flag = ID_FLAG_IS_PARAM;\n    mp_parse_node_struct_t *pns = NULL;\n    if (MP_PARSE_NODE_IS_ID(pn)) {\n        param_name = MP_PARSE_NODE_LEAF_ARG(pn);\n        if (comp->have_star) {\n            \n            comp->scope_cur->num_kwonly_args += 1;\n        } else {\n            \n            comp->scope_cur->num_pos_args += 1;\n        }\n    } else {\n        assert(MP_PARSE_NODE_IS_STRUCT(pn));\n        pns = (mp_parse_node_struct_t *)pn;\n        if (MP_PARSE_NODE_STRUCT_KIND(pns) == pn_name) {\n            \n            param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n            if (comp->have_star) {\n                \n                comp->scope_cur->num_kwonly_args += 1;\n            } else {\n                \n                comp->scope_cur->num_pos_args += 1;\n            }\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == pn_star) {\n            if (comp->have_star) {\n                \n                compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"invalid syntax\"));\n                return;\n            }\n            comp->have_star = true;\n            param_flag = ID_FLAG_IS_PARAM | ID_FLAG_IS_STAR_PARAM;\n            if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {\n                \n                \n                \n                pns = NULL;\n            } else if (MP_PARSE_NODE_IS_ID(pns->nodes[0])) {\n                \n                comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_VARARGS;\n                param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n                pns = NULL;\n            } else {\n                assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_tfpdef)); \n                \n                comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_VARARGS;\n                pns = (mp_parse_node_struct_t *)pns->nodes[0];\n                param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n            }\n        } else {\n            \n            assert(MP_PARSE_NODE_STRUCT_KIND(pns) == pn_dbl_star); \n            param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);\n            param_flag = ID_FLAG_IS_PARAM | ID_FLAG_IS_DBL_STAR_PARAM;\n            comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_VARKEYWORDS;\n        }\n    }\n\n    if (param_name != MP_QSTRnull) {\n        id_info_t *id_info = scope_find_or_add_id(comp->scope_cur, param_name, ID_INFO_KIND_UNDECIDED);\n        if (id_info->kind != ID_INFO_KIND_UNDECIDED) {\n            compile_syntax_error(comp, pn, MP_ERROR_TEXT(\"argument name reused\"));\n            return;\n        }\n        id_info->kind = ID_INFO_KIND_LOCAL;\n        id_info->flags = param_flag;\n\n        #if MICROPY_EMIT_NATIVE\n        if (comp->scope_cur->emit_options == MP_EMIT_OPT_VIPER && pn_name == PN_typedargslist_name && pns != NULL) {\n            id_info->flags |= compile_viper_type_annotation(comp, pns->nodes[1]) << ID_FLAG_VIPER_TYPE_POS;\n        }\n        #else\n        (void)pns;\n        #endif\n    }\n}\n\nstatic void compile_scope_func_param(compiler_t *comp, mp_parse_node_t pn) {\n    compile_scope_func_lambda_param(comp, pn, PN_typedargslist_name, PN_typedargslist_star, PN_typedargslist_dbl_star);\n}\n\nstatic void compile_scope_lambda_param(compiler_t *comp, mp_parse_node_t pn) {\n    compile_scope_func_lambda_param(comp, pn, PN_varargslist_name, PN_varargslist_star, PN_varargslist_dbl_star);\n}\n\nstatic void compile_scope_comp_iter(compiler_t *comp, mp_parse_node_struct_t *pns_comp_for, mp_parse_node_t pn_inner_expr, int for_depth) {\n    uint l_top = comp_next_label(comp);\n    uint l_end = comp_next_label(comp);\n    EMIT_ARG(label_assign, l_top);\n    EMIT_ARG(for_iter, l_end);\n    c_assign(comp, pns_comp_for->nodes[0], ASSIGN_STORE);\n    mp_parse_node_t pn_iter = pns_comp_for->nodes[2];\n\ntail_recursion:\n    if (MP_PARSE_NODE_IS_NULL(pn_iter)) {\n        \n        compile_node(comp, pn_inner_expr);\n        if (comp->scope_cur->kind == SCOPE_GEN_EXPR) {\n            EMIT_ARG(yield, MP_EMIT_YIELD_VALUE);\n            reserve_labels_for_native(comp, 1);\n            EMIT(pop_top);\n        } else {\n            EMIT_ARG(store_comp, comp->scope_cur->kind, 4 * for_depth + 5);\n        }\n    } else if (MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t *)pn_iter) == PN_comp_if) {\n        \n        mp_parse_node_struct_t *pns_comp_if = (mp_parse_node_struct_t *)pn_iter;\n        c_if_cond(comp, pns_comp_if->nodes[0], false, l_top);\n        pn_iter = pns_comp_if->nodes[1];\n        goto tail_recursion;\n    } else {\n        assert(MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t *)pn_iter) == PN_comp_for); \n        \n        mp_parse_node_struct_t *pns_comp_for2 = (mp_parse_node_struct_t *)pn_iter;\n        compile_node(comp, pns_comp_for2->nodes[1]);\n        EMIT_ARG(get_iter, true);\n        compile_scope_comp_iter(comp, pns_comp_for2, pn_inner_expr, for_depth + 1);\n    }\n\n    EMIT_ARG(jump, l_top);\n    EMIT_ARG(label_assign, l_end);\n    EMIT(for_iter_end);\n}\n\nstatic void check_for_doc_string(compiler_t *comp, mp_parse_node_t pn) {\n    #if MICROPY_ENABLE_DOC_STRING\n    \n\n    \n    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_expr_stmt)) {\n        \n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_file_input_2)) {\n        \n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);\n        for (int i = 0; i < num_nodes; i++) {\n            pn = pns->nodes[i];\n            if (!(MP_PARSE_NODE_IS_LEAF(pn) && MP_PARSE_NODE_LEAF_KIND(pn) == MP_PARSE_NODE_TOKEN && MP_PARSE_NODE_LEAF_ARG(pn) == MP_TOKEN_NEWLINE)) {\n                \n                break;\n            }\n        }\n        \n    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_suite_block_stmts)) {\n        \n        pn = ((mp_parse_node_struct_t *)pn)->nodes[0];\n    } else {\n        return;\n    }\n\n    \n    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_expr_stmt)) {\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;\n        if ((MP_PARSE_NODE_IS_LEAF(pns->nodes[0])\n             && MP_PARSE_NODE_LEAF_KIND(pns->nodes[0]) == MP_PARSE_NODE_STRING)\n            || (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_const_object)\n                && mp_obj_is_str(get_const_object((mp_parse_node_struct_t *)pns->nodes[0])))) {\n            \n            compile_node(comp, pns->nodes[0]);\n            \n            compile_store_id(comp, MP_QSTR___doc__);\n        }\n    }\n    #else\n    (void)comp;\n    (void)pn;\n    #endif\n}\n\nstatic bool compile_scope(compiler_t *comp, scope_t *scope, pass_kind_t pass) {\n    comp->pass = pass;\n    comp->scope_cur = scope;\n    comp->next_label = 0;\n    mp_emit_common_start_pass(&comp->emit_common, pass);\n    EMIT_ARG(start_pass, pass, scope);\n    reserve_labels_for_native(comp, 6); \n\n    if (comp->pass == MP_PASS_SCOPE) {\n        \n        \n        scope->stack_size = 0;\n        scope->exc_stack_size = 0;\n    }\n\n    \n    if (MP_PARSE_NODE_IS_STRUCT_KIND(scope->pn, PN_eval_input)) {\n        assert(scope->kind == SCOPE_MODULE);\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)scope->pn;\n        compile_node(comp, pns->nodes[0]); \n        EMIT(return_value);\n    } else if (scope->kind == SCOPE_MODULE) {\n        if (!comp->is_repl) {\n            check_for_doc_string(comp, scope->pn);\n        }\n        compile_node(comp, scope->pn);\n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        EMIT(return_value);\n    } else if (scope->kind == SCOPE_FUNCTION) {\n        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)scope->pn;\n        assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_funcdef);\n\n        \n        \n        if (comp->pass == MP_PASS_SCOPE) {\n            comp->have_star = false;\n            apply_to_single_or_list(comp, pns->nodes[1], PN_typedargslist, compile_scope_func_param);\n\n            #if MICROPY_EMIT_NATIVE\n            if (scope->emit_options == MP_EMIT_OPT_VIPER) {\n                \n                scope->scope_flags |= compile_viper_type_annotation(comp, pns->nodes[2]) << MP_SCOPE_FLAG_VIPERRET_POS;\n            }\n            #endif \n        }\n\n        compile_node(comp, pns->nodes[3]); \n        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        EMIT(return_value);\n    } else if (scope->kind == SCOPE_LAMBDA) {\n        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)scope->pn;\n        assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 3);\n\n        \n        EMIT_ARG(set_source_line, pns->source_line);\n\n        \n        \n        if (comp->pass == MP_PASS_SCOPE) {\n            comp->have_star = false;\n            apply_to_single_or_list(comp, pns->nodes[0], PN_varargslist, compile_scope_lambda_param);\n        }\n\n        compile_node(comp, pns->nodes[1]); \n\n        \n        if (scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {\n            EMIT(pop_top);\n            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        }\n        EMIT(return_value);\n    } else if (SCOPE_IS_COMP_LIKE(scope->kind)) {\n        \n\n        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)scope->pn;\n        assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2);\n        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for));\n        mp_parse_node_struct_t *pns_comp_for = (mp_parse_node_struct_t *)pns->nodes[1];\n\n        \n        \n        \n        \n        qstr qstr_arg = MP_QSTR_;\n        if (comp->pass == MP_PASS_SCOPE) {\n            scope_find_or_add_id(comp->scope_cur, qstr_arg, ID_INFO_KIND_LOCAL);\n            scope->num_pos_args = 1;\n        }\n\n        \n        EMIT_ARG(set_source_line, pns->source_line);\n\n        if (scope->kind == SCOPE_LIST_COMP) {\n            EMIT_ARG(build, 0, MP_EMIT_BUILD_LIST);\n        } else if (scope->kind == SCOPE_DICT_COMP) {\n            EMIT_ARG(build, 0, MP_EMIT_BUILD_MAP);\n        #if MICROPY_PY_BUILTINS_SET\n        } else if (scope->kind == SCOPE_SET_COMP) {\n            EMIT_ARG(build, 0, MP_EMIT_BUILD_SET);\n        #endif\n        }\n\n        \n        \n        if (scope->kind == SCOPE_GEN_EXPR) {\n            MP_STATIC_ASSERT(MP_OBJ_ITER_BUF_NSLOTS == 4);\n            EMIT(load_null);\n            compile_load_id(comp, qstr_arg);\n            EMIT(load_null);\n            EMIT(load_null);\n        } else {\n            compile_load_id(comp, qstr_arg);\n            EMIT_ARG(get_iter, true);\n        }\n\n        compile_scope_comp_iter(comp, pns_comp_for, pns->nodes[0], 0);\n\n        if (scope->kind == SCOPE_GEN_EXPR) {\n            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        }\n        EMIT(return_value);\n    } else {\n        assert(scope->kind == SCOPE_CLASS);\n        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));\n        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)scope->pn;\n        assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_classdef);\n\n        if (comp->pass == MP_PASS_SCOPE) {\n            scope_find_or_add_id(scope, MP_QSTR___class__, ID_INFO_KIND_LOCAL);\n        }\n\n        #if MICROPY_PY_SYS_SETTRACE\n        EMIT_ARG(set_source_line, pns->source_line);\n        #endif\n        compile_load_id(comp, MP_QSTR___name__);\n        compile_store_id(comp, MP_QSTR___module__);\n        EMIT_ARG(load_const_str, MP_PARSE_NODE_LEAF_ARG(pns->nodes[0])); \n        compile_store_id(comp, MP_QSTR___qualname__);\n\n        check_for_doc_string(comp, pns->nodes[2]);\n        compile_node(comp, pns->nodes[2]); \n\n        id_info_t *id = scope_find(scope, MP_QSTR___class__);\n        assert(id != NULL);\n        if (id->kind == ID_INFO_KIND_LOCAL) {\n            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);\n        } else {\n            EMIT_LOAD_FAST(MP_QSTR___class__, id->local_num);\n        }\n        EMIT(return_value);\n    }\n\n    bool pass_complete = EMIT(end_pass);\n\n    \n    assert(comp->cur_except_level == 0);\n\n    return pass_complete;\n}\n\n#if MICROPY_EMIT_INLINE_ASM\n\nstatic void compile_scope_inline_asm(compiler_t *comp, scope_t *scope, pass_kind_t pass) {\n    comp->pass = pass;\n    comp->scope_cur = scope;\n    comp->next_label = 0;\n\n    if (scope->kind != SCOPE_FUNCTION) {\n        compile_syntax_error(comp, MP_PARSE_NODE_NULL, MP_ERROR_TEXT(\"inline assembler must be a function\"));\n        return;\n    }\n\n    if (comp->pass > MP_PASS_SCOPE) {\n        EMIT_INLINE_ASM_ARG(start_pass, comp->pass, &comp->compile_error);\n    }\n\n    \n    assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));\n    mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)scope->pn;\n    assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_funcdef);\n\n    \n\n    \n    if (comp->pass == MP_PASS_CODE_SIZE) {\n        mp_parse_node_t *pn_params;\n        size_t n_params = mp_parse_node_extract_list(&pns->nodes[1], PN_typedargslist, &pn_params);\n        scope->num_pos_args = EMIT_INLINE_ASM_ARG(count_params, n_params, pn_params);\n        if (comp->compile_error != MP_OBJ_NULL) {\n            goto inline_asm_error;\n        }\n    }\n\n    \n    mp_uint_t type_sig = MP_NATIVE_TYPE_INT;\n    mp_parse_node_t pn_annotation = pns->nodes[2];\n    if (!MP_PARSE_NODE_IS_NULL(pn_annotation)) {\n        \n        if (MP_PARSE_NODE_IS_ID(pn_annotation)) {\n            qstr ret_type = MP_PARSE_NODE_LEAF_ARG(pn_annotation);\n            switch (ret_type) {\n                case MP_QSTR_object:\n                    type_sig = MP_NATIVE_TYPE_OBJ;\n                    break;\n                case MP_QSTR_bool:\n                    type_sig = MP_NATIVE_TYPE_BOOL;\n                    break;\n                case MP_QSTR_int:\n                    type_sig = MP_NATIVE_TYPE_INT;\n                    break;\n                case MP_QSTR_uint:\n                    type_sig = MP_NATIVE_TYPE_UINT;\n                    break;\n                default:\n                    compile_syntax_error(comp, pn_annotation, MP_ERROR_TEXT(\"unknown type\"));\n                    return;\n            }\n        } else {\n            compile_syntax_error(comp, pn_annotation, MP_ERROR_TEXT(\"return annotation must be an identifier\"));\n        }\n    }\n\n    mp_parse_node_t pn_body = pns->nodes[3]; \n    mp_parse_node_t *nodes;\n    size_t num = mp_parse_node_extract_list(&pn_body, PN_suite_block_stmts, &nodes);\n\n    for (size_t i = 0; i < num; i++) {\n        assert(MP_PARSE_NODE_IS_STRUCT(nodes[i]));\n        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t *)nodes[i];\n        if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_pass_stmt) {\n            \n            continue;\n        } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) != PN_expr_stmt) {\n            \n        not_an_instruction:\n            compile_syntax_error(comp, nodes[i], MP_ERROR_TEXT(\"expecting an assembler instruction\"));\n            return;\n        }\n\n        \n        assert(MP_PARSE_NODE_IS_STRUCT(pns2->nodes[0]));\n        if (!MP_PARSE_NODE_IS_NULL(pns2->nodes[1])) {\n            goto not_an_instruction;\n        }\n        pns2 = (mp_parse_node_struct_t *)pns2->nodes[0];\n        if (MP_PARSE_NODE_STRUCT_KIND(pns2) != PN_atom_expr_normal) {\n            goto not_an_instruction;\n        }\n        if (!MP_PARSE_NODE_IS_ID(pns2->nodes[0])) {\n            goto not_an_instruction;\n        }\n        if (!MP_PARSE_NODE_IS_STRUCT_KIND(pns2->nodes[1], PN_trailer_paren)) {\n            goto not_an_instruction;\n        }\n\n        \n        \n        qstr op = MP_PARSE_NODE_LEAF_ARG(pns2->nodes[0]);\n        pns2 = (mp_parse_node_struct_t *)pns2->nodes[1]; \n        mp_parse_node_t *pn_arg;\n        size_t n_args = mp_parse_node_extract_list(&pns2->nodes[0], PN_arglist, &pn_arg);\n\n        \n        if (op == MP_QSTR_label) {\n            if (!(n_args == 1 && MP_PARSE_NODE_IS_ID(pn_arg[0]))) {\n                compile_syntax_error(comp, nodes[i], MP_ERROR_TEXT(\"'label' requires 1 argument\"));\n                return;\n            }\n            uint lab = comp_next_label(comp);\n            if (pass > MP_PASS_SCOPE) {\n                if (!EMIT_INLINE_ASM_ARG(label, lab, MP_PARSE_NODE_LEAF_ARG(pn_arg[0]))) {\n                    compile_syntax_error(comp, nodes[i], MP_ERROR_TEXT(\"label redefined\"));\n                    return;\n                }\n            }\n        } else if (op == MP_QSTR_align) {\n            if (!(n_args == 1 && MP_PARSE_NODE_IS_SMALL_INT(pn_arg[0]))) {\n                compile_syntax_error(comp, nodes[i], MP_ERROR_TEXT(\"'align' requires 1 argument\"));\n                return;\n            }\n            if (pass > MP_PASS_SCOPE) {\n                mp_asm_base_align((mp_asm_base_t *)comp->emit_inline_asm,\n                    MP_PARSE_NODE_LEAF_SMALL_INT(pn_arg[0]));\n            }\n        } else if (op == MP_QSTR_data) {\n            if (!(n_args >= 2 && MP_PARSE_NODE_IS_SMALL_INT(pn_arg[0]))) {\n                compile_syntax_error(comp, nodes[i], MP_ERROR_TEXT(\"'data' requires at least 2 arguments\"));\n                return;\n            }\n            if (pass > MP_PASS_SCOPE) {\n                mp_int_t bytesize = MP_PARSE_NODE_LEAF_SMALL_INT(pn_arg[0]);\n                for (uint j = 1; j < n_args; j++) {\n                    mp_obj_t int_obj;\n                    if (!mp_parse_node_get_int_maybe(pn_arg[j], &int_obj)) {\n                        compile_syntax_error(comp, nodes[i], MP_ERROR_TEXT(\"'data' requires integer arguments\"));\n                        return;\n                    }\n                    mp_asm_base_data((mp_asm_base_t *)comp->emit_inline_asm,\n                        bytesize, mp_obj_int_get_truncated(int_obj));\n                }\n            }\n        } else {\n            if (pass > MP_PASS_SCOPE) {\n                EMIT_INLINE_ASM_ARG(op, op, n_args, pn_arg);\n            }\n        }\n\n        if (comp->compile_error != MP_OBJ_NULL) {\n            pns = pns2; \n            goto inline_asm_error;\n        }\n    }\n\n    if (comp->pass > MP_PASS_SCOPE) {\n        EMIT_INLINE_ASM_ARG(end_pass, type_sig);\n\n        if (comp->pass == MP_PASS_EMIT) {\n            void *f = mp_asm_base_get_code((mp_asm_base_t *)comp->emit_inline_asm);\n            mp_emit_glue_assign_native(comp->scope_cur->raw_code, MP_CODE_NATIVE_ASM,\n                f, mp_asm_base_get_code_size((mp_asm_base_t *)comp->emit_inline_asm),\n                NULL,\n                #if MICROPY_PERSISTENT_CODE_SAVE\n                0,\n                0,\n                #endif\n                0, comp->scope_cur->num_pos_args, type_sig);\n        }\n    }\n\n    if (comp->compile_error != MP_OBJ_NULL) {\n        \n    inline_asm_error:\n        comp->compile_error_line = pns->source_line;\n    }\n}\n#endif\n\nstatic void scope_compute_things(scope_t *scope) {\n    \n    if (scope->scope_flags & MP_SCOPE_FLAG_VARARGS) {\n        id_info_t *id_param = NULL;\n        for (int i = scope->id_info_len - 1; i >= 0; i--) {\n            id_info_t *id = &scope->id_info[i];\n            if (id->flags & ID_FLAG_IS_STAR_PARAM) {\n                if (id_param != NULL) {\n                    \n                    id_info_t temp = *id_param;\n                    *id_param = *id;\n                    *id = temp;\n                }\n                break;\n            } else if (id_param == NULL && id->flags == ID_FLAG_IS_PARAM) {\n                id_param = id;\n            }\n        }\n    }\n\n    \n    \n    scope->num_locals = 0;\n    for (int i = 0; i < scope->id_info_len; i++) {\n        id_info_t *id = &scope->id_info[i];\n        if (scope->kind == SCOPE_CLASS && id->qst == MP_QSTR___class__) {\n            \n            continue;\n        }\n        if (SCOPE_IS_FUNC_LIKE(scope->kind) && id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {\n            id->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;\n        }\n        #if MICROPY_EMIT_NATIVE\n        if (id->kind == ID_INFO_KIND_GLOBAL_EXPLICIT) {\n            \n            if (scope->emit_options == MP_EMIT_OPT_VIPER\n                && mp_native_type_from_qstr(id->qst) >= MP_NATIVE_TYPE_INT) {\n                \n            } else {\n                scope->scope_flags |= MP_SCOPE_FLAG_REFGLOBALS;\n            }\n        }\n        #endif\n        \n        if (id->kind == ID_INFO_KIND_LOCAL || (id->flags & ID_FLAG_IS_PARAM)) {\n            id->local_num = scope->num_locals++;\n        }\n    }\n\n    \n    for (int i = 0; i < scope->id_info_len; i++) {\n        id_info_t *id = &scope->id_info[i];\n        \n        \n        \n        if (id->kind == ID_INFO_KIND_CELL && !(id->flags & ID_FLAG_IS_PARAM)) {\n            id->local_num = scope->num_locals;\n            scope->num_locals += 1;\n        }\n    }\n\n    \n    \n    if (scope->parent != NULL) {\n        int num_free = 0;\n        for (int i = 0; i < scope->parent->id_info_len; i++) {\n            id_info_t *id = &scope->parent->id_info[i];\n            if (id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE) {\n                for (int j = 0; j < scope->id_info_len; j++) {\n                    id_info_t *id2 = &scope->id_info[j];\n                    if (id2->kind == ID_INFO_KIND_FREE && id->qst == id2->qst) {\n                        assert(!(id2->flags & ID_FLAG_IS_PARAM)); \n                        \n                        id2->local_num = num_free;\n                        num_free += 1;\n                    }\n                }\n            }\n        }\n        \n        if (num_free > 0) {\n            for (int i = 0; i < scope->id_info_len; i++) {\n                id_info_t *id = &scope->id_info[i];\n                if (id->kind != ID_INFO_KIND_FREE || (id->flags & ID_FLAG_IS_PARAM)) {\n                    id->local_num += num_free;\n                }\n            }\n            scope->num_pos_args += num_free; \n            scope->num_locals += num_free;\n        }\n    }\n}\n\n#if !MICROPY_PERSISTENT_CODE_SAVE\nstatic\n#endif\nvoid mp_compile_to_raw_code(mp_parse_tree_t *parse_tree, qstr source_file, bool is_repl, mp_compiled_module_t *cm) {\n    \n    compiler_t comp_state = {0};\n    compiler_t *comp = &comp_state;\n\n    comp->is_repl = is_repl;\n    comp->break_label = INVALID_LABEL;\n    comp->continue_label = INVALID_LABEL;\n    mp_emit_common_init(&comp->emit_common, source_file);\n\n    \n    #if MICROPY_EMIT_NATIVE\n    const uint emit_opt = MP_STATE_VM(default_emit_opt);\n    #else\n    const uint emit_opt = MP_EMIT_OPT_NONE;\n    #endif\n    scope_t *module_scope = scope_new_and_link(comp, SCOPE_MODULE, parse_tree->root, emit_opt);\n\n    \n    emit_t *emit_bc = emit_bc_new(&comp->emit_common);\n\n    \n    comp->emit = emit_bc;\n    #if MICROPY_EMIT_NATIVE\n    comp->emit_method_table = &emit_bc_method_table;\n    #endif\n    uint max_num_labels = 0;\n    for (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {\n        #if MICROPY_EMIT_INLINE_ASM\n        if (s->emit_options == MP_EMIT_OPT_ASM) {\n            compile_scope_inline_asm(comp, s, MP_PASS_SCOPE);\n        } else\n        #endif\n        {\n            compile_scope(comp, s, MP_PASS_SCOPE);\n\n            \n            for (size_t i = 0; i < s->id_info_len; ++i) {\n                id_info_t *id = &s->id_info[i];\n                if (id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {\n                    scope_check_to_close_over(s, id);\n                }\n            }\n        }\n\n        \n        if (comp->next_label > max_num_labels) {\n            max_num_labels = comp->next_label;\n        }\n    }\n\n    \n    for (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {\n        scope_compute_things(s);\n    }\n\n    \n    emit_bc_set_max_num_labels(emit_bc, max_num_labels);\n\n    \n    #if MICROPY_EMIT_NATIVE\n    emit_t *emit_native = NULL;\n    #endif\n    for (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {\n        #if MICROPY_EMIT_INLINE_ASM\n        if (s->emit_options == MP_EMIT_OPT_ASM) {\n            \n            if (comp->emit_inline_asm == NULL) {\n                comp->emit_inline_asm = ASM_EMITTER(new)(max_num_labels);\n            }\n            comp->emit = NULL;\n            comp->emit_inline_asm_method_table = ASM_EMITTER_TABLE;\n            compile_scope_inline_asm(comp, s, MP_PASS_CODE_SIZE);\n            #if MICROPY_EMIT_INLINE_XTENSA\n            \n            \n            \n            #if MICROPY_DYNAMIC_COMPILER\n            if (mp_dynamic_compiler.native_arch == MP_NATIVE_ARCH_XTENSA)\n            #endif\n            {\n                compile_scope_inline_asm(comp, s, MP_PASS_CODE_SIZE);\n            }\n            #endif\n            if (comp->compile_error == MP_OBJ_NULL) {\n                compile_scope_inline_asm(comp, s, MP_PASS_EMIT);\n            }\n        } else\n        #endif\n        {\n\n            \n\n            switch (s->emit_options) {\n\n                #if MICROPY_EMIT_NATIVE\n                case MP_EMIT_OPT_NATIVE_PYTHON:\n                case MP_EMIT_OPT_VIPER:\n                    if (emit_native == NULL) {\n                        emit_native = NATIVE_EMITTER(new)(&comp->emit_common, &comp->compile_error, &comp->next_label, max_num_labels);\n                    }\n                    comp->emit_method_table = NATIVE_EMITTER_TABLE;\n                    comp->emit = emit_native;\n                    break;\n                #endif \n\n                default:\n                    comp->emit = emit_bc;\n                    #if MICROPY_EMIT_NATIVE\n                    comp->emit_method_table = &emit_bc_method_table;\n                    #endif\n                    break;\n            }\n\n            \n            compile_scope(comp, s, MP_PASS_STACK_SIZE);\n\n            \n            if (comp->compile_error == MP_OBJ_NULL) {\n                compile_scope(comp, s, MP_PASS_CODE_SIZE);\n            }\n\n            \n            \n            if (comp->compile_error == MP_OBJ_NULL) {\n                while (!compile_scope(comp, s, MP_PASS_EMIT)) {\n                }\n            }\n        }\n    }\n\n    if (comp->compile_error != MP_OBJ_NULL) {\n        \n        \n        compile_error_set_line(comp, comp->scope_cur->pn);\n        \n        mp_obj_exception_add_traceback(comp->compile_error, source_file,\n            comp->compile_error_line, comp->scope_cur->simple_name);\n    }\n\n    \n    cm->rc = module_scope->raw_code;\n    #if MICROPY_PERSISTENT_CODE_SAVE\n    cm->has_native = false;\n    #if MICROPY_EMIT_NATIVE\n    if (emit_native != NULL) {\n        cm->has_native = true;\n    }\n    #endif\n    #if MICROPY_EMIT_INLINE_ASM\n    if (comp->emit_inline_asm != NULL) {\n        cm->has_native = true;\n    }\n    #endif\n    cm->n_qstr = comp->emit_common.qstr_map.used;\n    cm->n_obj = comp->emit_common.const_obj_list.len;\n    #endif\n    if (comp->compile_error == MP_OBJ_NULL) {\n        mp_emit_common_populate_module_context(&comp->emit_common, source_file, cm->context);\n\n        #if MICROPY_DEBUG_PRINTERS\n        \n        if (mp_verbose_flag >= 2) {\n            for (scope_t *s = comp->scope_head; s != NULL; s = s->next) {\n                mp_raw_code_t *rc = s->raw_code;\n                if (rc->kind == MP_CODE_BYTECODE) {\n                    mp_bytecode_print(&mp_plat_print, rc, s->raw_code_data_len, &cm->context->constants);\n                }\n            }\n        }\n        #endif\n    }\n\n    \n\n    emit_bc_free(emit_bc);\n    #if MICROPY_EMIT_NATIVE\n    if (emit_native != NULL) {\n        NATIVE_EMITTER(free)(emit_native);\n    }\n    #endif\n    #if MICROPY_EMIT_INLINE_ASM\n    if (comp->emit_inline_asm != NULL) {\n        ASM_EMITTER(free)(comp->emit_inline_asm);\n    }\n    #endif\n\n    \n    mp_parse_tree_clear(parse_tree);\n\n    \n    for (scope_t *s = module_scope; s;) {\n        scope_t *next = s->next;\n        scope_free(s);\n        s = next;\n    }\n\n    if (comp->compile_error != MP_OBJ_NULL) {\n        nlr_raise(comp->compile_error);\n    }\n}\n\nmp_obj_t mp_compile(mp_parse_tree_t *parse_tree, qstr source_file, bool is_repl) {\n    mp_compiled_module_t cm;\n    cm.context = m_new_obj(mp_module_context_t);\n    cm.context->module.globals = mp_globals_get();\n    mp_compile_to_raw_code(parse_tree, source_file, is_repl, &cm);\n    \n    return mp_make_function_from_proto_fun(cm.rc, cm.context, NULL);\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}