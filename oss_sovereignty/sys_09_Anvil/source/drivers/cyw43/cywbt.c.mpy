{
  "module_name": "cywbt.c",
  "hash_id": "491cf4df980bde37e2b7a7b42541e2a6a50f6ff4febdfbace36ca93e7fe822f9",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cyw43/cywbt.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"py/mphal.h\"\n#include \"extmod/mpbthci.h\"\n\n#if MICROPY_PY_NETWORK_CYW43\n\n#include \"lib/cyw43-driver/src/cyw43_config.h\"\n#include \"lib/cyw43-driver/firmware/cyw43_btfw_4343A1.h\"\n\n\nextern uint8_t mp_bluetooth_hci_cmd_buf[4 + 256];\n\n \n\n\n#ifdef CYW43_PIN_BT_CTS\n\n\n#include \"pin_static_af.h\"\n#include \"uart.h\"\n\n\nextern machine_uart_obj_t mp_bluetooth_hci_uart_obj;\n\nstatic void cywbt_wait_cts_low(void) {\n    mp_hal_pin_config(CYW43_PIN_BT_CTS, MP_HAL_PIN_MODE_INPUT, MP_HAL_PIN_PULL_UP, 0);\n    for (int i = 0; i < 200; ++i) {\n        if (mp_hal_pin_read(CYW43_PIN_BT_CTS) == 0) {\n            break;\n        }\n        mp_hal_delay_ms(1);\n    }\n    mp_hal_pin_config_alt(CYW43_PIN_BT_CTS, MP_HAL_PIN_MODE_ALT,\n        MP_HAL_PIN_PULL_UP, AF_FN_UART, mp_bluetooth_hci_uart_obj.uart_id);\n}\n#endif\n\nstatic int cywbt_hci_cmd_raw(size_t len, uint8_t *buf) {\n    mp_bluetooth_hci_uart_write((void *)buf, len);\n    for (int c, i = 0; i < 6; ++i) {\n        while ((c = mp_bluetooth_hci_uart_readchar()) == -1) {\n            mp_event_wait_indefinite();\n        }\n        buf[i] = c;\n    }\n\n    \n    if (buf[0] != 0x04 || buf[1] != 0x0e) {\n        printf(\"unknown response: %02x %02x %02x %02x\\n\", buf[0], buf[1], buf[2], buf[3]);\n        return -1;\n    }\n\n     \n\n    int sz = buf[2] - 3;\n    for (int c, i = 0; i < sz; ++i) {\n        while ((c = mp_bluetooth_hci_uart_readchar()) == -1) {\n            mp_event_wait_indefinite();\n        }\n        buf[i] = c;\n    }\n\n    return 0;\n}\n\nstatic int cywbt_hci_cmd(int ogf, int ocf, size_t param_len, const uint8_t *param_buf) {\n    uint8_t *buf = mp_bluetooth_hci_cmd_buf;\n    buf[0] = 0x01;\n    buf[1] = ocf;\n    buf[2] = ogf << 2 | ocf >> 8;\n    buf[3] = param_len;\n    if (param_len) {\n        memcpy(buf + 4, param_buf, param_len);\n    }\n    return cywbt_hci_cmd_raw(4 + param_len, buf);\n}\n\nstatic void put_le16(uint8_t *buf, uint16_t val) {\n    buf[0] = val;\n    buf[1] = val >> 8;\n}\n\nstatic void put_le32(uint8_t *buf, uint32_t val) {\n    buf[0] = val;\n    buf[1] = val >> 8;\n    buf[2] = val >> 16;\n    buf[3] = val >> 24;\n}\n\nstatic int cywbt_set_baudrate(uint32_t baudrate) {\n    uint8_t buf[6];\n    put_le16(buf, 0);\n    put_le32(buf + 2, baudrate);\n    return cywbt_hci_cmd(0x3f, 0x18, 6, buf);\n}\n\n\nstatic int cywbt_download_firmware(const uint8_t *firmware) {\n    cywbt_hci_cmd(0x3f, 0x2e, 0, NULL);\n\n    bool last_packet = false;\n    while (!last_packet) {\n        uint8_t *buf = mp_bluetooth_hci_cmd_buf;\n        memcpy(buf + 1, firmware, 3);\n        firmware += 3;\n        last_packet = buf[1] == 0x4e;\n        if (buf[2] != 0xfc) {\n            printf(\"fail1 %02x\\n\", buf[2]);\n            break;\n        }\n        uint8_t len = buf[3];\n\n        memcpy(buf + 4, firmware, len);\n        firmware += len;\n\n        buf[0] = 1;\n        cywbt_hci_cmd_raw(4 + len, buf);\n        if (buf[0] != 0) {\n            printf(\"fail3 %02x\\n\", buf[0]);\n            break;\n        }\n    }\n\n    \n    #if MICROPY_HW_ENABLE_RF_SWITCH\n    mp_hal_pin_config(CYW43_PIN_WL_GPIO_1, MP_HAL_PIN_MODE_INPUT, MP_HAL_PIN_PULL_UP, 0);\n    #endif\n    mp_hal_delay_ms(10); \n    #ifdef CYW43_PIN_BT_CTS\n    cywbt_wait_cts_low();\n    #endif\n    #if MICROPY_HW_ENABLE_RF_SWITCH\n    \n    mp_hal_pin_config(CYW43_PIN_WL_GPIO_1, MP_HAL_PIN_MODE_INPUT, MP_HAL_PIN_PULL_DOWN, 0);\n    #endif\n\n    mp_bluetooth_hci_uart_set_baudrate(115200);\n    cywbt_set_baudrate(MICROPY_HW_BLE_UART_BAUDRATE_SECONDARY);\n    mp_bluetooth_hci_uart_set_baudrate(MICROPY_HW_BLE_UART_BAUDRATE_SECONDARY);\n\n    return 0;\n}\n\nint mp_bluetooth_hci_controller_init(void) {\n    \n\n    mp_hal_pin_output(CYW43_PIN_BT_REG_ON);\n    mp_hal_pin_low(CYW43_PIN_BT_REG_ON);\n    #ifdef CYW43_PIN_BT_HOST_WAKE\n    mp_hal_pin_input(CYW43_PIN_BT_HOST_WAKE);\n    #endif\n    #ifdef CYW43_PIN_BT_DEV_WAKE\n    mp_hal_pin_output(CYW43_PIN_BT_DEV_WAKE);\n    mp_hal_pin_low(CYW43_PIN_BT_DEV_WAKE);\n    #endif\n\n    #if MICROPY_HW_ENABLE_RF_SWITCH\n    \n    mp_hal_pin_config(CYW43_PIN_WL_GPIO_4, MP_HAL_PIN_MODE_OUTPUT, MP_HAL_PIN_PULL_NONE, 0); \n    mp_hal_pin_high(CYW43_PIN_WL_GPIO_4); \n    #endif\n\n    uint8_t buf[256];\n\n    mp_hal_pin_low(CYW43_PIN_BT_REG_ON);\n    mp_bluetooth_hci_uart_set_baudrate(115200);\n    mp_hal_delay_ms(100);\n    mp_hal_pin_high(CYW43_PIN_BT_REG_ON);\n    #ifdef CYW43_PIN_BT_CTS\n    cywbt_wait_cts_low();\n    #else\n    mp_hal_delay_ms(100);\n    #endif\n\n    \n    cywbt_hci_cmd(0x03, 0x0003, 0, NULL);\n\n    #ifdef MICROPY_HW_BLE_UART_BAUDRATE_DOWNLOAD_FIRMWARE\n    \n    cywbt_set_baudrate(MICROPY_HW_BLE_UART_BAUDRATE_DOWNLOAD_FIRMWARE);\n    mp_bluetooth_hci_uart_set_baudrate(MICROPY_HW_BLE_UART_BAUDRATE_DOWNLOAD_FIRMWARE);\n    #endif\n\n    cywbt_download_firmware((const uint8_t *)&cyw43_btfw_4343A1[0]);\n\n    \n    cywbt_hci_cmd(0x03, 0x0003, 0, NULL);\n\n    \n    uint8_t bdaddr[6];\n    mp_hal_get_mac(MP_HAL_MAC_BDADDR, bdaddr);\n    buf[0] = bdaddr[5];\n    buf[1] = bdaddr[4];\n    buf[2] = bdaddr[3];\n    buf[3] = bdaddr[2];\n    buf[4] = bdaddr[1];\n    buf[5] = bdaddr[0];\n    cywbt_hci_cmd(0x3f, 0x0001, 6, buf);\n\n    \n    \n    \n    \n\n    \n    cywbt_hci_cmd(0x3f, 0x27, 12, (const uint8_t *)\"\\x01\\x02\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\");\n\n    \n    cywbt_hci_cmd(3, 109, 2, (const uint8_t *)\"\\x01\\x00\");\n\n    #ifdef CYW43_PIN_BT_DEV_WAKE\n    mp_hal_pin_high(CYW43_PIN_BT_DEV_WAKE); \n    #endif\n\n    return 0;\n}\n\nint mp_bluetooth_hci_controller_deinit(void) {\n    mp_hal_pin_low(CYW43_PIN_BT_REG_ON);\n\n    return 0;\n}\n\n#ifdef CYW43_PIN_BT_DEV_WAKE\nstatic uint32_t bt_sleep_ticks;\n#endif\n\nint mp_bluetooth_hci_controller_sleep_maybe(void) {\n    #ifdef CYW43_PIN_BT_DEV_WAKE\n    if (mp_hal_pin_read(CYW43_PIN_BT_DEV_WAKE) == 0) {\n        if (mp_hal_ticks_ms() - bt_sleep_ticks > 500) {\n            mp_hal_pin_high(CYW43_PIN_BT_DEV_WAKE); \n        }\n    }\n    #endif\n    return 0;\n}\n\nbool mp_bluetooth_hci_controller_woken(void) {\n    #ifdef CYW43_PIN_BT_HOST_WAKE\n    bool host_wake = mp_hal_pin_read(CYW43_PIN_BT_HOST_WAKE);\n     \n    return host_wake;\n    #else\n    return true;\n    #endif\n}\n\nint mp_bluetooth_hci_controller_wakeup(void) {\n    #ifdef CYW43_PIN_BT_DEV_WAKE\n    bt_sleep_ticks = mp_hal_ticks_ms();\n\n    if (mp_hal_pin_read(CYW43_PIN_BT_DEV_WAKE) == 1) {\n        mp_hal_pin_low(CYW43_PIN_BT_DEV_WAKE); \n        \n        \n        mp_hal_delay_us(5000); \n    }\n    #endif\n\n    return 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}