{
  "module_name": "esp_hosted_wifi.c",
  "hash_id": "39642b8777eb77238359c98b06260b59a0bbd85d23f2c51b1d8efeb138692104",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/esp-hosted/esp_hosted_wifi.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_PY_NETWORK_ESP_HOSTED\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"lwip/err.h\"\n#include \"lwip/dns.h\"\n#include \"lwip/dhcp.h\"\n#include \"netif/etharp.h\"\n\n#include \"shared/netutils/netutils.h\"\n#include \"shared/netutils/dhcpserver.h\"\n\n#include \"esp_hosted.pb-c.h\"\n\n#include \"esp_hosted_hal.h\"\n#include \"esp_hosted_stack.h\"\n#include \"esp_hosted_netif.h\"\n#include \"esp_hosted_wifi.h\"\n#include \"esp_hosted_internal.h\"\n\nstatic esp_hosted_state_t esp_state;\n\nstatic ProtobufCAllocator protobuf_alloc = {\n    .alloc = &esp_hosted_hal_alloc,\n    .free = &esp_hosted_hal_free,\n    .allocator_data = NULL,\n};\n\nstatic void esp_hosted_macstr_to_bytes(const uint8_t *mac_str, size_t mac_len, uint8_t *mac_out) {\n    uint8_t byte = 0;\n    for (int i = 0; i < mac_len; i++) {\n        char c = mac_str[i];\n        if (c >= '0' && c <= '9') {\n            byte = (byte << 4) | (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n            byte = (byte << 4) | (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n            byte = (byte << 4) | (c - 'A' + 10);\n        }\n        if (c == ':' || (i + 1) == mac_len) {\n            *mac_out++ = byte;\n            byte = 0;\n        }\n    }\n}\n\n\n\n\nstatic esp_hosted_security_t sec_prot_to_hosted_security(CtrlWifiSecProt sec_prot)\n{\n    switch (sec_prot) {\n    case CTRL__WIFI_SEC_PROT__Open:\n        return ESP_HOSTED_SEC_OPEN;\n    case CTRL__WIFI_SEC_PROT__WEP:\n        return ESP_HOSTED_SEC_WEP;\n    case CTRL__WIFI_SEC_PROT__WPA_PSK:\n        return ESP_HOSTED_SEC_WPA_PSK;\n    case CTRL__WIFI_SEC_PROT__WPA2_PSK:\n        return ESP_HOSTED_SEC_WPA2_PSK;\n    case CTRL__WIFI_SEC_PROT__WPA_WPA2_PSK:\n        return ESP_HOSTED_SEC_WPA_WPA2_PSK;\n    case CTRL__WIFI_SEC_PROT__WPA2_ENTERPRISE:\n        return ESP_HOSTED_SEC_WPA2_ENTERPRISE;\n    case CTRL__WIFI_SEC_PROT__WPA3_PSK:\n        return ESP_HOSTED_SEC_WPA3_PSK;\n    case CTRL__WIFI_SEC_PROT__WPA2_WPA3_PSK:\n        return ESP_HOSTED_SEC_WPA2_WPA3_PSK;\n    default:\n        return ESP_HOSTED_SEC_INVALID;\n    }\n}\n\nstatic CtrlWifiSecProt hosted_security_to_sec_prot(esp_hosted_security_t hosted_security)\n{\n    switch (hosted_security) {\n    case ESP_HOSTED_SEC_OPEN:\n        return CTRL__WIFI_SEC_PROT__Open;\n    case ESP_HOSTED_SEC_WEP:\n        return CTRL__WIFI_SEC_PROT__WEP;\n    case ESP_HOSTED_SEC_WPA_PSK:\n        return CTRL__WIFI_SEC_PROT__WPA_PSK;\n    case ESP_HOSTED_SEC_WPA2_PSK:\n        return CTRL__WIFI_SEC_PROT__WPA2_PSK;\n    case ESP_HOSTED_SEC_WPA_WPA2_PSK:\n        return CTRL__WIFI_SEC_PROT__WPA_WPA2_PSK;\n    case ESP_HOSTED_SEC_WPA2_ENTERPRISE:\n        return CTRL__WIFI_SEC_PROT__WPA2_ENTERPRISE;\n    case ESP_HOSTED_SEC_WPA3_PSK:\n        return CTRL__WIFI_SEC_PROT__WPA3_PSK;\n    case ESP_HOSTED_SEC_WPA2_WPA3_PSK:\n        return CTRL__WIFI_SEC_PROT__WPA2_WPA3_PSK;\n    default:\n        abort(); \n    }\n}\n\nuint16_t esp_hosted_checksum(esp_header_t *esp_header) {\n    uint16_t checksum = 0;\n    esp_header->checksum = 0;\n    uint8_t *buf = (uint8_t *)esp_header;\n    for (size_t i = 0; i < (esp_header->len + sizeof(esp_header_t)); i++) {\n        checksum += buf[i];\n    }\n    return checksum;\n}\n\n#if ESP_HOSTED_DEBUG\nstatic void esp_hosted_dump_header(esp_header_t *esp_header) {\n    static const char *if_strs[] = { \"STA\", \"AP\", \"SERIAL\", \"HCI\", \"PRIV\", \"TEST\" };\n    if (esp_header->if_type > ESP_HOSTED_MAX_IF) {\n        return;\n    }\n    debug_printf(\"esp header: if %s_IF length %d offset %d checksum %d seq %d flags %x\\n\",\n        if_strs[esp_header->if_type], esp_header->len, esp_header->offset,\n        esp_header->checksum, esp_header->seq_num, esp_header->flags);\n\n    if (esp_header->if_type == ESP_HOSTED_SERIAL_IF) {\n        tlv_header_t *tlv_header = (tlv_header_t *)(esp_header->payload);\n        debug_printf(\"tlv header: ep_type %d ep_length %d ep_value %.8s data_type %d data_length %d\\n\",\n            tlv_header->ep_type, tlv_header->ep_length,\n            tlv_header->ep_value, tlv_header->data_type, tlv_header->data_length);\n    }\n}\n#endif\n\nstatic int32_t esp_hosted_resp_value(CtrlMsg *ctrl_msg) {\n    \n    \n    \n    const static size_t ctrl_msg_resp_offset[] = {\n        offsetof(CtrlMsgRespGetMacAddress, resp),\n        offsetof(CtrlMsgRespSetMacAddress, resp),\n        offsetof(CtrlMsgRespGetMode, resp),\n        offsetof(CtrlMsgRespSetMode, resp),\n        offsetof(CtrlMsgRespScanResult, resp),\n        offsetof(CtrlMsgRespGetAPConfig, resp),\n        offsetof(CtrlMsgRespConnectAP, resp),\n        offsetof(CtrlMsgRespGetStatus, resp),\n        offsetof(CtrlMsgRespGetSoftAPConfig, resp),\n        offsetof(CtrlMsgRespSetSoftAPVendorSpecificIE, resp),\n        offsetof(CtrlMsgRespStartSoftAP, resp),\n        offsetof(CtrlMsgRespSoftAPConnectedSTA, resp),\n        offsetof(CtrlMsgRespGetStatus, resp),\n        offsetof(CtrlMsgRespSetMode, resp),\n        offsetof(CtrlMsgRespGetMode, resp),\n        offsetof(CtrlMsgRespOTABegin, resp),\n        offsetof(CtrlMsgRespOTAWrite, resp),\n        offsetof(CtrlMsgRespOTAEnd, resp),\n        offsetof(CtrlMsgRespSetWifiMaxTxPower, resp),\n        offsetof(CtrlMsgRespGetWifiCurrTxPower, resp),\n        offsetof(CtrlMsgRespConfigHeartbeat, resp),\n    };\n\n    int32_t resp = -1;\n    size_t index = ctrl_msg->msg_id - CTRL_MSG_ID__Resp_Base;\n\n    \n    if (ctrl_msg->resp_get_mac_address != NULL &&\n        ctrl_msg->msg_type == CTRL_MSG_TYPE__Resp &&\n        index > 0 && index <= MP_ARRAY_SIZE(ctrl_msg_resp_offset)) {\n        \n        size_t offset = ctrl_msg_resp_offset[index - 1];\n        resp = *((int32_t *)((char *)ctrl_msg->resp_get_mac_address + offset));\n    }\n    return resp;\n}\n\nstatic int esp_hosted_request(CtrlMsgId msg_id, void *ctrl_payload) {\n    CtrlMsg ctrl_msg = {0};\n    ctrl_msg__init(&ctrl_msg);\n    ctrl_msg.msg_id = msg_id;\n    ctrl_msg.payload_case = msg_id;\n\n    \n    ctrl_msg.req_get_mac_address = ctrl_payload;\n\n    \n    size_t payload_size = ctrl_msg__get_packed_size(&ctrl_msg);\n    if ((payload_size + sizeof(tlv_header_t)) > ESP_FRAME_MAX_PAYLOAD) {\n        error_printf(\"esp_hosted_request() payload size > max payload %d\\n\", msg_id);\n        return -1;\n    }\n\n    esp_header_t *esp_header = (esp_header_t *)(esp_state.buf);\n    tlv_header_t *tlv_header = (tlv_header_t *)(esp_header->payload);\n\n    esp_header->if_type = ESP_HOSTED_SERIAL_IF;\n    esp_header->if_num = 0;\n    esp_header->flags = 0;\n    esp_header->len = payload_size + sizeof(tlv_header_t);\n    esp_header->offset = sizeof(esp_header_t);\n    esp_header->seq_num = esp_state.seq_num++;\n\n    tlv_header->ep_type = TLV_HEADER_TYPE_EP;\n    tlv_header->ep_length = 8;\n    memcpy(tlv_header->ep_value, TLV_HEADER_EP_RESP, 8);\n    tlv_header->data_type = TLV_HEADER_TYPE_DATA;\n    tlv_header->data_length = payload_size;\n    ctrl_msg__pack(&ctrl_msg, tlv_header->data);\n    esp_header->checksum = esp_hosted_checksum(esp_header);\n\n    size_t frame_size = (sizeof(esp_header_t) + esp_header->len + 3) & ~3U;\n    if (esp_hosted_hal_spi_transfer(esp_state.buf, NULL, frame_size) != 0) {\n        error_printf(\"esp_hosted_request() request %d failed\\n\", msg_id);\n        return -1;\n    }\n    return 0;\n}\n\nstatic CtrlMsg *esp_hosted_response(CtrlMsgId msg_id, uint32_t timeout) {\n    CtrlMsg *ctrl_msg = NULL;\n    for (mp_uint_t start = mp_hal_ticks_ms(); ; mp_hal_delay_ms(10)) {\n        if (!esp_hosted_stack_empty(&esp_state.stack)) {\n            ctrl_msg = esp_hosted_stack_pop(&esp_state.stack, true);\n            if (ctrl_msg->msg_id == msg_id) {\n                ctrl_msg = esp_hosted_stack_pop(&esp_state.stack, false);\n                break;\n            }\n\n            debug_printf(\"esp_hosted_response() waiting for id %lu last id %lu\\n\", msg_id, ctrl_msg->msg_id);\n            ctrl_msg = NULL;\n        }\n\n        if (timeout == 0) {\n            \n            return NULL;\n        }\n\n        \n        if ((mp_hal_ticks_ms() - start) >= timeout) {\n            return NULL;\n        }\n\n        MICROPY_EVENT_POLL_HOOK\n    }\n\n    \n    if (ctrl_msg->msg_type == CTRL_MSG_TYPE__Resp && esp_hosted_resp_value(ctrl_msg) != 0) {\n        error_printf(\"esp_hosted_response() response %d failed %d\\n\", msg_id, esp_hosted_resp_value(ctrl_msg));\n        ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n        return NULL;\n    }\n\n    return ctrl_msg;\n}\n\nstatic int esp_hosted_ctrl(CtrlMsgId req_id, void *req_payload, CtrlMsg **resp_msg) {\n    if (esp_hosted_request(req_id, req_payload) != 0) {\n        return -1;\n    }\n    uint32_t resp_id = (req_id - CTRL_MSG_ID__Req_Base) + CTRL_MSG_ID__Resp_Base;\n    if ((*resp_msg = esp_hosted_response(resp_id, ESP_SYNC_REQ_TIMEOUT)) == NULL) {\n        return -1;\n    }\n    return 0;\n}\n\nint esp_hosted_wifi_poll(void) {\n    size_t offset = 0;\n    esp_header_t *esp_header = (esp_header_t *)(esp_state.buf);\n    tlv_header_t *tlv_header = (tlv_header_t *)(esp_header->payload);\n\n    if (!(esp_state.flags & ESP_HOSTED_FLAGS_INIT) || !esp_hosted_hal_data_ready()) {\n        return 0;\n    }\n\n    do {\n        esp_header_t *frag_header = (esp_header_t *)(esp_state.buf + offset);\n        if ((ESP_STATE_BUF_SIZE - offset) < ESP_FRAME_MAX_SIZE) {\n            \n            error_printf(\"esp_hosted_poll() spi buffer overflow offs %d\\n\", offset);\n            return -1;\n        }\n\n        if (esp_hosted_hal_spi_transfer(NULL, esp_state.buf + offset, ESP_FRAME_MAX_SIZE) != 0) {\n            error_printf(\"esp_hosted_poll() spi transfer failed\\n\");\n            return 0;\n        }\n\n        if (frag_header->len == 0 ||\n            frag_header->len > ESP_FRAME_MAX_PAYLOAD ||\n            frag_header->offset != sizeof(esp_header_t)) {\n            \n            warn_printf(\"esp_hosted_poll() invalid frame size %d offset %d\\n\",\n                esp_header->len, esp_header->offset);\n            return 0;\n        }\n\n        uint16_t checksum = frag_header->checksum;\n        frag_header->checksum = esp_hosted_checksum(frag_header);\n        if (frag_header->checksum != checksum) {\n            warn_printf(\"esp_hosted_poll() invalid checksum, expected %d\\n\", checksum);\n            return 0;\n        }\n\n        if (offset) {\n            \n            if ((esp_header->seq_num + 1) != frag_header->seq_num) {\n                error_printf(\"esp_hosted_poll() fragmented frame sequence mismatch\\n\");\n                return 0;\n            }\n            esp_header->len += frag_header->len;\n            esp_header->seq_num = frag_header->seq_num;\n            esp_header->flags = frag_header->flags;\n            info_printf(\"esp_hosted_poll() received fragmented packet %d\\n\", frag_header->len);\n            \n            memcpy(esp_state.buf + offset, frag_header->payload, frag_header->len);\n        }\n\n        offset = sizeof(esp_header_t) + esp_header->len;\n    } while ((esp_header->flags & ESP_FRAME_FLAGS_FRAGMENT));\n\n    #if ESP_HOSTED_DEBUG\n    esp_hosted_dump_header(esp_header);\n    #endif\n\n    switch (esp_header->if_type) {\n        case ESP_HOSTED_STA_IF:\n        case ESP_HOSTED_AP_IF: {\n            \n            uint32_t itf = esp_header->if_type;\n            if (netif_is_link_up(&esp_state.netif[itf])) {\n                if (esp_hosted_netif_input(&esp_state, itf, esp_header->payload, esp_header->len) != 0) {\n                    error_printf(\"esp_hosted_poll() netif input failed\\n\");\n                    return -1;\n                }\n                debug_printf(\"esp_hosted_poll() eth frame input %d\\n\", esp_header->len);\n            }\n            return 0;\n        }\n        case ESP_HOSTED_PRIV_IF: {\n            esp_event_t *priv_event = (esp_event_t *)(esp_header->payload);\n            if (esp_header->priv_pkt_type == ESP_PACKET_TYPE_EVENT &&\n                priv_event->event_type == ESP_PRIV_EVENT_INIT) {\n                esp_state.chip_id = priv_event->event_data[2];\n                esp_state.spi_clk = priv_event->event_data[5];\n                esp_state.chip_flags = priv_event->event_data[8];\n                info_printf(\"esp_hosted_poll() chip id %d spi_mhz %d caps 0x%x\\n\",\n                    esp_state.chip_id, esp_state.spi_clk, esp_state.chip_flags);\n            }\n            return 0;\n        }\n        case ESP_HOSTED_HCI_IF:\n        case ESP_HOSTED_TEST_IF:\n        case ESP_HOSTED_MAX_IF:\n            error_printf(\"esp_hosted_poll() unexpected interface type %d\\n\", esp_header->if_type);\n            return 0;\n        case ESP_HOSTED_SERIAL_IF:\n            \n            break;\n    }\n\n    CtrlMsg *ctrl_msg = ctrl_msg__unpack(&protobuf_alloc, tlv_header->data_length, tlv_header->data);\n    if (ctrl_msg == NULL) {\n        error_printf(\"esp_hosted_poll() failed to unpack protobuf\\n\");\n        return 0;\n    }\n\n    if (ctrl_msg->msg_type == CTRL_MSG_TYPE__Event) {\n        switch (ctrl_msg->msg_id) {\n            case CTRL_MSG_ID__Event_ESPInit:\n                esp_state.flags |= ESP_HOSTED_FLAGS_ACTIVE;\n                break;\n            case CTRL_MSG_ID__Event_Heartbeat:\n                esp_state.last_hb_ms = mp_hal_ticks_ms();\n                info_printf(\"esp_hosted_poll() heartbeat %lu\\n\", esp_state.last_hb_ms);\n                return 0;\n            case CTRL_MSG_ID__Event_StationDisconnectFromAP:\n                esp_state.flags &= ~ESP_HOSTED_FLAGS_STA_CONNECTED;\n                return 0;\n            case CTRL_MSG_ID__Event_StationDisconnectFromESPSoftAP:\n                return 0;\n            default:\n                error_printf(\"esp_hosted_poll() unexpected event %d\\n\", ctrl_msg->msg_id);\n                return 0;\n        }\n    }\n\n    \n    if (ctrl_msg->msg_type == CTRL_MSG_TYPE__Resp) {\n        switch (ctrl_msg->msg_id) {\n            case CTRL_MSG_ID__Resp_ConnectAP: {\n                if (esp_hosted_resp_value(ctrl_msg) == 0) {\n                    esp_state.flags |= ESP_HOSTED_FLAGS_STA_CONNECTED;\n                }\n                ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n                debug_printf(\"esp_hosted_poll() state %d\\n\", esp_state.flags);\n                return 0;\n            }\n            default:\n                break;\n        }\n    }\n\n    \n    if (!esp_hosted_stack_push(&esp_state.stack, ctrl_msg)) {\n        error_printf(\"esp_hosted_poll() message stack full\\n\");\n        return -1;\n    }\n\n    debug_printf(\"esp_hosted_poll() pushed msg_type %lu msg_id %lu\\n\", ctrl_msg->msg_type, ctrl_msg->msg_id);\n    return 0;\n}\n\nint esp_hosted_wifi_init(uint32_t itf) {\n    if (esp_state.flags == ESP_HOSTED_FLAGS_RESET) {\n        \n        memset(&esp_state, 0, sizeof(esp_hosted_state_t));\n        esp_hosted_stack_init(&esp_state.stack);\n\n        \n        if (esp_hosted_hal_init(ESP_HOSTED_MODE_WIFI) != 0) {\n            return -1;\n        }\n\n        \n        esp_state.flags |= ESP_HOSTED_FLAGS_INIT;\n\n        CtrlMsg *ctrl_msg = NULL;\n\n        \n        ctrl_msg = esp_hosted_response(CTRL_MSG_ID__Event_ESPInit, ESP_SYNC_REQ_TIMEOUT);\n        if (ctrl_msg == NULL) {\n            return -1;\n        }\n        ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n\n        \n        CtrlMsgReqSetMode ctrl_payload;\n        ctrl_msg__req__set_mode__init(&ctrl_payload);\n        ctrl_payload.mode = CTRL__WIFI_MODE__APSTA;\n        if (esp_hosted_ctrl(CTRL_MSG_ID__Req_SetWifiMode, &ctrl_payload, &ctrl_msg) != 0) {\n            return -1;\n        }\n        ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n\n        info_printf(\"esp_hosted_init() device initialized\\n\");\n    }\n\n    if (!netif_is_link_up(&esp_state.netif[itf])) {\n        \n        esp_hosted_netif_init(&esp_state, itf);\n        info_printf(\"esp_hosted_init() initialized itf %lu\\n\", itf);\n    }\n\n    \n    esp_hosted_hal_irq_enable(true);\n\n    return 0;\n}\n\nint esp_hosted_wifi_disable(uint32_t itf) {\n    \n    esp_hosted_netif_deinit(&esp_state, itf);\n\n    if (itf == ESP_HOSTED_STA_IF) {\n        esp_state.flags &= ~ESP_HOSTED_FLAGS_STA_CONNECTED;\n    } else {\n        esp_state.flags &= ~ESP_HOSTED_FLAGS_AP_STARTED;\n    }\n\n    info_printf(\"esp_hosted_deinit() deinitialized itf %lu\\n\", itf);\n    return 0;\n}\n\nint esp_hosted_wifi_deinit(void) {\n    if (esp_state.flags & ESP_HOSTED_FLAGS_INIT) {\n        \n        esp_hosted_wifi_disable(ESP_HOSTED_STA_IF);\n        esp_hosted_wifi_disable(ESP_HOSTED_AP_IF);\n\n        \n        memset(&esp_state, 0, sizeof(esp_hosted_state_t));\n        esp_hosted_stack_init(&esp_state.stack);\n\n        info_printf(\"esp_hosted_deinit() deinitialized\\n\");\n    }\n    return 0;\n}\n\nvoid *esp_hosted_wifi_get_netif(uint32_t itf) {\n    return &esp_state.netif[itf];\n}\n\nint esp_hosted_wifi_get_mac(int itf, uint8_t *mac) {\n    CtrlMsgReqGetMacAddress ctrl_payload;\n    ctrl_msg__req__get_mac_address__init(&ctrl_payload);\n    ctrl_payload.mode = (itf == ESP_HOSTED_STA_IF) ? CTRL__WIFI_MODE__STA : CTRL__WIFI_MODE__AP;\n\n    CtrlMsg *ctrl_msg = NULL;\n    if (esp_hosted_ctrl(CTRL_MSG_ID__Req_GetMACAddress, &ctrl_payload, &ctrl_msg) != 0) {\n        error_printf(\"esp_hosted_get_mac() request failed\\n\");\n        return -1;\n    }\n\n    ProtobufCBinaryData macstr = ctrl_msg->resp_get_mac_address->mac;\n    if (macstr.data) {\n        esp_hosted_macstr_to_bytes(macstr.data, macstr.len, mac);\n    }\n    ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n    return 0;\n}\n\nint esp_hosted_wifi_connect(const char *ssid, const char *bssid, esp_hosted_security_t security, const char *key, uint16_t channel) {\n    CtrlMsgReqConnectAP ctrl_payload;\n    ctrl_msg__req__connect_ap__init(&ctrl_payload);\n\n    if (security >= ESP_HOSTED_SEC_MAX) {\n        \n        return -1;\n    }\n\n    ctrl_payload.ssid = (char *)ssid;\n    ctrl_payload.bssid = (char *)bssid;\n    ctrl_payload.pwd = (char *)key;\n    ctrl_payload.is_wpa3_supported = false;\n    ctrl_payload.listen_interval = 0;\n\n    if (esp_hosted_request(CTRL_MSG_ID__Req_ConnectAP, &ctrl_payload) != 0) {\n        return -1;\n    }\n    return 0;\n}\n\nint esp_hosted_wifi_start_ap(const char *ssid, esp_hosted_security_t security, const char *key, uint16_t channel) {\n    CtrlMsgReqStartSoftAP ctrl_payload;\n    ctrl_msg__req__start_soft_ap__init(&ctrl_payload);\n\n    if (security >= ESP_HOSTED_SEC_MAX) {\n        return -1;\n    }\n\n    ctrl_payload.ssid = (char *)ssid;\n    ctrl_payload.pwd = (char *)key;\n    ctrl_payload.chnl = channel;\n    ctrl_payload.sec_prot = hosted_security_to_sec_prot(security);\n    ctrl_payload.max_conn = ESP_HOSTED_MAX_AP_CLIENTS;\n    ctrl_payload.ssid_hidden = false;\n    ctrl_payload.bw = CTRL__WIFI_BW__HT40;\n\n    CtrlMsg *ctrl_msg = NULL;\n    if (esp_hosted_ctrl(CTRL_MSG_ID__Req_StartSoftAP, &ctrl_payload, &ctrl_msg) != 0) {\n        return -1;\n    }\n    ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n    esp_state.flags |= ESP_HOSTED_FLAGS_AP_STARTED;\n    return 0;\n}\n\nint esp_hosted_wifi_disconnect(uint32_t itf) {\n    CtrlMsg *ctrl_msg = NULL;\n    CtrlMsgReqGetStatus ctrl_payload;\n    ctrl_msg__req__get_status__init(&ctrl_payload);\n\n    if (itf == ESP_HOSTED_STA_IF) {\n        esp_state.flags &= ~ESP_HOSTED_FLAGS_STA_CONNECTED;\n        if (esp_hosted_ctrl(CTRL_MSG_ID__Req_DisconnectAP, &ctrl_payload, &ctrl_msg) != 0) {\n            return -1;\n        }\n    } else {\n        esp_state.flags &= ~ESP_HOSTED_FLAGS_AP_STARTED;\n        if (esp_hosted_ctrl(CTRL_MSG_ID__Req_StopSoftAP, &ctrl_payload, &ctrl_msg) != 0) {\n            return -1;\n        }\n    }\n    ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n    return 0;\n}\n\nint esp_hosted_wifi_link_status(uint32_t itf) {\n    return netif_is_link_up(&esp_state.netif[itf]);\n}\n\nint esp_hosted_wifi_is_connected(uint32_t itf) {\n    if (!esp_hosted_wifi_link_status(itf)) {\n        return false;\n    }\n    if (itf == ESP_HOSTED_AP_IF) {\n        return esp_state.flags & ESP_HOSTED_FLAGS_AP_STARTED;\n    }\n    if ((esp_state.flags & ESP_HOSTED_FLAGS_STA_CONNECTED) &&\n        ((esp_state.flags & ESP_HOSTED_FLAGS_STATIC_IP) ||\n         dhcp_supplied_address(&esp_state.netif[itf]))) {\n        return true;\n    }\n    return false;\n}\n\nint esp_hosted_wifi_get_stations(uint8_t *sta_list, size_t *sta_count) {\n    CtrlMsgReqSoftAPConnectedSTA ctrl_payload;\n    ctrl_msg__req__soft_apconnected_sta__init(&ctrl_payload);\n\n    CtrlMsg *ctrl_msg = NULL;\n    if (esp_hosted_ctrl(CTRL_MSG_ID__Req_GetSoftAPConnectedSTAList, &ctrl_payload, &ctrl_msg) != 0) {\n        return -1;\n    }\n\n    CtrlMsgRespSoftAPConnectedSTA *resp = ctrl_msg->resp_softap_connected_stas_list;\n    *sta_count = resp->n_stations;\n    for (size_t i = 0; i < resp->n_stations; i++) {\n        ProtobufCBinaryData mac = resp->stations[i]->mac;\n        esp_hosted_macstr_to_bytes(mac.data, mac.len, &sta_list[i * 6]);\n    }\n    ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n    return 0;\n}\n\nint esp_hosted_wifi_netinfo(esp_hosted_netinfo_t *netinfo) {\n    CtrlMsgReqGetAPConfig ctrl_payload;\n    ctrl_msg__req__get_apconfig__init(&ctrl_payload);\n\n    CtrlMsg *ctrl_msg = NULL;\n    if (esp_hosted_ctrl(CTRL_MSG_ID__Req_GetAPConfig, &ctrl_payload, &ctrl_msg) != 0) {\n        return -1;\n    }\n\n    netinfo->rssi = ctrl_msg->resp_get_ap_config->rssi;\n    netinfo->security = sec_prot_to_hosted_security(ctrl_msg->resp_get_ap_config->sec_prot);\n    netinfo->channel = ctrl_msg->resp_get_ap_config->chnl;\n\n    ProtobufCBinaryData ssid = ctrl_msg->resp_get_ap_config->ssid;\n    if (ssid.data) {\n        size_t ssid_len = MIN(ssid.len, (ESP_HOSTED_MAX_SSID_LEN - 1));\n        memcpy(netinfo->ssid, ssid.data, ssid_len);\n        netinfo->ssid[ssid_len] = 0;\n    }\n\n    ProtobufCBinaryData bssid = ctrl_msg->resp_get_ap_config->bssid;\n    if (bssid.data) {\n        esp_hosted_macstr_to_bytes(bssid.data, bssid.len, netinfo->bssid);\n    }\n\n    ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n    return 0;\n}\n\nint esp_hosted_wifi_scan(esp_hosted_scan_callback_t scan_callback, void *arg, uint32_t timeout) {\n    CtrlMsgReqScanResult ctrl_payload;\n    ctrl_msg__req__scan_result__init(&ctrl_payload);\n\n    CtrlMsg *ctrl_msg = NULL;\n    if (esp_hosted_ctrl(CTRL_MSG_ID__Req_GetAPScanList, &ctrl_payload, &ctrl_msg) != 0) {\n        return -MP_ETIMEDOUT;\n    }\n\n    CtrlMsgRespScanResult *rp = ctrl_msg->resp_scan_ap_list;\n    for (int i = 0; i < rp->count; i++) {\n        esp_hosted_scan_result_t result = {0};\n        result.rssi = rp->entries[i]->rssi;\n        result.security = sec_prot_to_hosted_security(rp->entries[i]->sec_prot);\n        result.channel = rp->entries[i]->chnl;\n        if (rp->entries[i]->bssid.data) {\n            esp_hosted_macstr_to_bytes(rp->entries[i]->bssid.data, rp->entries[i]->bssid.len, result.bssid);\n        }\n\n        if (rp->entries[i]->ssid.len) {\n            size_t ssid_len = MIN(rp->entries[i]->ssid.len, (ESP_HOSTED_MAX_SSID_LEN - 1));\n            memcpy(result.ssid, rp->entries[i]->ssid.data, ssid_len);\n            result.ssid[ssid_len] = 0;\n        }\n        scan_callback(&result, arg);\n    }\n\n    ctrl_msg__free_unpacked(ctrl_msg, &protobuf_alloc);\n    return 0;\n}\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}