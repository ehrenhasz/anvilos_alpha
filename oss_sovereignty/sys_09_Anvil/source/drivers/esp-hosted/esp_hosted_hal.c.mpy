{
  "module_name": "esp_hosted_hal.c",
  "hash_id": "a812c18bcca70b36e99c0d0edf6901a867b807d8d4a0b314db826070a0a75d9b",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/esp-hosted/esp_hosted_hal.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n\n#if MICROPY_PY_NETWORK_ESP_HOSTED\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"py/runtime.h\"\n#include \"extmod/modmachine.h\"\n#ifdef MICROPY_HW_WIFI_LED\n#include \"led.h\"\n#endif\n\n#include \"esp_hosted_hal.h\"\n#include \"esp_hosted_wifi.h\"\n\nextern void mod_network_poll_events(void);\n\nstatic mp_obj_t esp_hosted_pin_irq_callback(mp_obj_t self_in) {\n    #ifdef MICROPY_HW_WIFI_LED\n    led_toggle(MICROPY_HW_WIFI_LED);\n    #endif\n    mod_network_poll_events();\n    return mp_const_none;\n}\nstatic MP_DEFINE_CONST_FUN_OBJ_1(esp_hosted_pin_irq_callback_obj, esp_hosted_pin_irq_callback);\n\nMP_WEAK int esp_hosted_hal_init(uint32_t mode) {\n    \n    esp_hosted_hal_deinit();\n\n    if (mode == ESP_HOSTED_MODE_BT) {\n        \n        return 0;\n    }\n\n    mp_hal_pin_input(MICROPY_HW_WIFI_HANDSHAKE);\n    mp_hal_pin_input(MICROPY_HW_WIFI_DATAREADY);\n\n    \n    mp_obj_t args[] = {\n        MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIFI_SPI_ID),\n        MP_OBJ_NEW_SMALL_INT(MICROPY_HW_WIFI_SPI_BAUDRATE),\n        MP_OBJ_NEW_QSTR(MP_QSTR_phase), MP_OBJ_NEW_SMALL_INT(0),\n        MP_OBJ_NEW_QSTR(MP_QSTR_polarity), MP_OBJ_NEW_SMALL_INT(1),\n    };\n\n    MP_STATE_PORT(mp_wifi_spi) =\n        MP_OBJ_TYPE_GET_SLOT(&machine_spi_type, make_new)((mp_obj_t)&machine_spi_type, 2, 2, args);\n\n    \n    \n    mp_hal_pin_output(MICROPY_HW_WIFI_SPI_CS);\n    mp_hal_pin_write(MICROPY_HW_WIFI_SPI_CS, 1);\n    return 0;\n}\n\nMP_WEAK int esp_hosted_hal_deinit(void) {\n    \n    esp_hosted_hal_irq_enable(false);\n\n    \n    esp_hosted_wifi_deinit();\n\n    mp_hal_pin_output(MICROPY_HW_ESP_HOSTED_GPIO0);\n    mp_hal_pin_output(MICROPY_HW_ESP_HOSTED_RESET);\n\n    #ifndef MICROPY_HW_ESP_HOSTED_SHARED_PINS\n    mp_hal_pin_output(MICROPY_HW_WIFI_SPI_CS);\n    mp_hal_pin_write(MICROPY_HW_WIFI_SPI_CS, 1);\n    #endif\n\n    \n    mp_hal_pin_write(MICROPY_HW_ESP_HOSTED_GPIO0, 1);\n    mp_hal_pin_write(MICROPY_HW_ESP_HOSTED_RESET, 0);\n    mp_hal_delay_ms(100);\n    mp_hal_pin_write(MICROPY_HW_ESP_HOSTED_RESET, 1);\n    mp_hal_delay_ms(500);\n\n    MP_STATE_PORT(mp_wifi_spi) = MP_OBJ_NULL;\n    return 0;\n}\n\nMP_WEAK void esp_hosted_hal_irq_enable(bool enable) {\n    #ifdef MICROPY_HW_WIFI_IRQ_PIN\n    \n    mp_obj_t pin_args[] = {\n        NULL, \n        (mp_obj_t)MICROPY_HW_WIFI_IRQ_PIN,   \n        mp_const_none  \n    };\n    mp_load_method_maybe((mp_obj_t)MICROPY_HW_WIFI_IRQ_PIN, MP_QSTR_irq, pin_args);\n    if (pin_args[0] && pin_args[1]) {\n        mp_call_method_n_kw(1, 0, pin_args);\n    }\n\n    if (enable) {\n        \n        mp_obj_t irq_rising_attr[2];\n        mp_load_method_maybe((mp_obj_t)MICROPY_HW_WIFI_IRQ_PIN, MP_QSTR_IRQ_RISING, irq_rising_attr);\n\n        if (irq_rising_attr[0] != MP_OBJ_NULL && irq_rising_attr[1] == MP_OBJ_NULL) {\n            \n            mp_obj_t pin_args[] = {\n                NULL, \n                (mp_obj_t)MICROPY_HW_WIFI_IRQ_PIN,   \n                (mp_obj_t)&esp_hosted_pin_irq_callback_obj,   \n                NULL,  \n                mp_const_true,  \n            };\n            pin_args[3] = irq_rising_attr[0];\n            mp_load_method_maybe((mp_obj_t)MICROPY_HW_WIFI_IRQ_PIN, MP_QSTR_irq, pin_args);\n            if (pin_args[0] != MP_OBJ_NULL && pin_args[1] != MP_OBJ_NULL) {\n                mp_call_method_n_kw(3, 0, pin_args);\n            }\n        }\n    }\n    #endif\n}\n\nMP_WEAK int esp_hosted_hal_atomic_enter(void) {\n    #if MICROPY_ENABLE_SCHEDULER\n    mp_sched_lock();\n    #endif\n    return 0;\n}\n\nMP_WEAK int esp_hosted_hal_atomic_exit(void) {\n    #if MICROPY_ENABLE_SCHEDULER\n    mp_sched_unlock();\n    #endif\n    return 0;\n}\n\nMP_WEAK bool esp_hosted_hal_data_ready(void) {\n    return mp_hal_pin_read(MICROPY_HW_WIFI_DATAREADY);\n}\n\nMP_WEAK int esp_hosted_hal_spi_transfer(const uint8_t *tx_buf, uint8_t *rx_buf, uint32_t size) {\n    mp_obj_t mp_wifi_spi = MP_STATE_PORT(mp_wifi_spi);\n    const mp_machine_spi_p_t *spi_proto = MP_OBJ_TYPE_GET_SLOT(&machine_spi_type, protocol);\n\n    \n    for (mp_uint_t start = mp_hal_ticks_ms(); ; mp_hal_delay_ms(1)) {\n        if (mp_hal_pin_read(MICROPY_HW_WIFI_HANDSHAKE) &&\n           (rx_buf == NULL || mp_hal_pin_read(MICROPY_HW_WIFI_DATAREADY))) {\n            break;\n        }\n        if ((mp_hal_ticks_ms() - start) >= 1000) {\n            error_printf(\"timeout waiting for handshake\\n\");\n            return -1;\n        }\n    }\n\n    mp_hal_pin_write(MICROPY_HW_WIFI_SPI_CS, 0);\n    mp_hal_delay_us(10);\n    spi_proto->transfer(mp_wifi_spi, size, tx_buf, rx_buf);\n    mp_hal_pin_write(MICROPY_HW_WIFI_SPI_CS, 1);\n    mp_hal_delay_us(100);\n\n    if (esp_hosted_hal_data_ready()) {\n        mod_network_poll_events();\n    }\n    return 0;\n}\n\nMP_WEAK void *esp_hosted_hal_alloc(void *user, size_t size) {\n    (void)user;\n    void *mem = m_malloc0(size);\n    return mem;\n}\n\nMP_WEAK void esp_hosted_hal_free(void *user, void *ptr) {\n    (void)user;\n    m_free(ptr);\n}\n\nMP_WEAK void *esp_hosted_hal_calloc(size_t nmemb, size_t size) {\n    return NULL;\n}\n\nMP_WEAK void *esp_hosted_hal_realloc(void *ptr, size_t size) {\n    return NULL;\n}\n\n\n\nMP_WEAK void *malloc(size_t size) {\n    (void)size;\n    debug_printf(\"system malloc called\\n\");\n    return NULL;\n}\n\nMP_WEAK void free(void *ptr) {\n    (void)ptr;\n    debug_printf(\"system free called\\n\");\n}\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}