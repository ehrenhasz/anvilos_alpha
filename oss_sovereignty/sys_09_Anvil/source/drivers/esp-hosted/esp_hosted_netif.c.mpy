{
  "module_name": "esp_hosted_netif.c",
  "hash_id": "c3a8377b58ada0d207f4919325b3b1e05d0cc7cd846e4c39adc812c8c77e77f2",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/esp-hosted/esp_hosted_netif.c",
  "human_readable_source": " \n\n#include \"py/mphal.h\"\n#include \"py/mperrno.h\"\n\n#if MICROPY_PY_NETWORK_ESP_HOSTED\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"lwip/err.h\"\n#include \"lwip/dns.h\"\n#include \"lwip/dhcp.h\"\n#include \"netif/etharp.h\"\n\n#include \"shared/netutils/netutils.h\"\n#include \"shared/netutils/dhcpserver.h\"\n\n#include \"esp_hosted_hal.h\"\n#include \"esp_hosted_wifi.h\"\n#include \"esp_hosted_netif.h\"\n#include \"esp_hosted_internal.h\"\n\nstatic err_t netif_struct_init(struct netif *netif) {\n    netif->linkoutput = esp_hosted_netif_output;\n    netif->output = etharp_output;\n    netif->mtu = ESP_FRAME_MAX_PAYLOAD;\n    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET | NETIF_FLAG_IGMP;\n    esp_hosted_wifi_get_mac(netif->name[1] - '0', netif->hwaddr);\n    netif->hwaddr_len = sizeof(netif->hwaddr);\n    info_printf(\"netif_init() netif initialized\\n\");\n    return ERR_OK;\n}\n\nint esp_hosted_netif_init(esp_hosted_state_t *state, uint32_t itf) {\n    struct netif *netif = &state->netif[itf];\n\n    ip_addr_t ipconfig[4];\n    ipconfig[0].addr = 0;\n    ipconfig[1].addr = 0;\n    ipconfig[2].addr = 0;\n    ipconfig[3].addr = 0;\n\n    if (itf == ESP_HOSTED_AP_IF) {\n        ipconfig[0].addr = PP_HTONL(ESP_HOSTED_AP_ADDRESS);\n        ipconfig[1].addr = PP_HTONL(ESP_HOSTED_AP_NETMASK);\n        ipconfig[2].addr = PP_HTONL(ESP_HOSTED_AP_GATEWAY);\n    }\n\n    netif->name[0] = 'w';\n    netif->name[1] = '0' + itf;\n\n    netif_add(netif, ip_2_ip4(&ipconfig[0]), ip_2_ip4(&ipconfig[1]),\n        ip_2_ip4(&ipconfig[2]), state, netif_struct_init, ethernet_input);\n\n    netif_set_hostname(netif, ESP_HOSTED_HOSTNAME);\n    netif_set_default(netif);\n    netif_set_up(netif);\n    netif_set_link_up(netif);\n    dns_setserver(0, &ipconfig[3]);\n\n    if (itf == ESP_HOSTED_STA_IF) {\n        dhcp_set_struct(netif, &state->dhcp_client);\n        dhcp_start(netif);\n    } else {\n        dhcp_server_init(&state->dhcp_server, &ipconfig[0], &ipconfig[1]);\n    }\n    return 0;\n}\n\nint esp_hosted_netif_deinit(esp_hosted_state_t *state, uint32_t itf) {\n    struct netif *netif = &state->netif[itf];\n\n    if (netif_is_link_up(netif)) {\n        if (itf == ESP_HOSTED_STA_IF) {\n            dhcp_stop(netif);\n        } else {\n            dhcp_server_deinit(&state->dhcp_server);\n        }\n    }\n\n    for (struct netif *netifp = netif_list; netif != NULL; netif = netif->next) {\n        if (netif == netifp) {\n            netif_remove(netif);\n            netif->flags = 0;\n            return 0;\n        }\n    }\n\n    return -1;\n}\n\nint esp_hosted_netif_input(esp_hosted_state_t *state, uint32_t itf, const void *buf, size_t len) {\n    struct netif *netif = &state->netif[itf];\n\n    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);\n    if (p == NULL) {\n        error_printf(\"esp_hosted_netif_input() failed to alloc pbuf %d\\n\", len);\n        return -1;\n    }\n    \n    pbuf_take(p, buf, len);\n\n    if (netif->input(p, netif) != ERR_OK) {\n        error_printf(\"esp_hosted_netif_input() netif input failed\\n\");\n        pbuf_free(p);\n        return -1;\n    }\n\n    debug_printf(\"esp_hosted_netif_input() eth frame input %d\\n\", len);\n    return 0;\n}\n\nerr_t esp_hosted_netif_output(struct netif *netif, struct pbuf *p) {\n    esp_hosted_state_t *state = netif->state;\n\n    if (p->tot_len > ESP_FRAME_MAX_PAYLOAD) {\n        error_printf(\"esp_hosted_netif_output() pbuf len > SPI buf len\\n\");\n        return ERR_IF;\n    }\n\n    esp_header_t *esp_header = (esp_header_t *)(state->buf);\n    esp_header->if_type = netif->name[1] - '0';\n    esp_header->if_num = 0;\n    esp_header->flags = 0;\n    esp_header->len = p->tot_len;\n    esp_header->offset = sizeof(esp_header_t);\n    esp_header->seq_num = 0;\n    pbuf_copy_partial(p, esp_header->payload, p->tot_len, 0);\n    esp_header->checksum = esp_hosted_checksum(esp_header);\n\n    size_t frame_size = (sizeof(esp_header_t) + esp_header->len + 3) & ~3U;\n    if (esp_hosted_hal_spi_transfer(state->buf, NULL, frame_size) != 0) {\n        error_printf(\"esp_hosted_netif_output() failed to send eth frame\\n\");\n        return ERR_IF;\n    }\n    debug_printf(\"esp_hosted_netif_output() if %d pbuf len %d\\n\", esp_header->if_type, esp_header->len);\n    return ERR_OK;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}