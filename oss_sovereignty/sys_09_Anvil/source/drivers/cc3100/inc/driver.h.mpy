{
  "module_name": "driver.h",
  "hash_id": "0743484571a6428c399d6b83e89d9a5bf1b1848bdd2ad5d604388e54465a9780",
  "original_prompt": "Ingested from sys_09_Anvil/source/drivers/cc3100/inc/driver.h",
  "human_readable_source": " \n \n#ifndef __DRIVER_INT_H__\n#define __DRIVER_INT_H__\n\n\n \n \n \n\n#ifndef CPU_FREQ_IN_MHZ\n #define CPU_FREQ_IN_MHZ         (200)\n#endif\n#define USEC_DELAY              (50)\n\n \n \n \n\ntypedef struct\n{\n    _SlOpcode_t      Opcode;\n    _SlArgSize_t     TxDescLen;\n    _SlArgSize_t     RxDescLen;\n}_SlCmdCtrl_t;\n\ntypedef struct\n{\n    _u16  TxPayloadLen;\n    _i16  RxPayloadLen;\n\t_i16  ActualRxPayloadLen;\n    _u8   *pTxPayload;\n    _u8   *pRxPayload;\n}_SlCmdExt_t;\n\n\ntypedef struct _SlArgsData_t\n{\n    _u8\t *pArgs;\n\t_u8    *pData;\n} _SlArgsData_t;\n\n\ntypedef struct _SlPoolObj_t\n{\n    _SlSyncObj_t\t      SyncObj;\n\t _u8                *pRespArgs;\n\t_u8\t\t\t      ActionID; \n\t_u8\t\t\t      AdditionalData;  \n    _u8\t\t\t\t  NextIndex;  \n\n} _SlPoolObj_t;\n\n\ntypedef enum\n{\n\tSOCKET_0,\n\tSOCKET_1,\n\tSOCKET_2,\n\tSOCKET_3,\n\tSOCKET_4,\n\tSOCKET_5,\n\tSOCKET_6,\n\tSOCKET_7,\n\tMAX_SOCKET_ENUM_IDX,\n#ifndef SL_TINY_EXT    \n    ACCEPT_ID = MAX_SOCKET_ENUM_IDX,\n    CONNECT_ID,\n#else\n    CONNECT_ID = MAX_SOCKET_ENUM_IDX,\n#endif\n#ifndef SL_TINY_EXT    \n\tSELECT_ID,\n#endif\n\tGETHOSYBYNAME_ID,\n#ifndef SL_TINY_EXT    \n\tGETHOSYBYSERVICE_ID,\n\tPING_ID,\n#endif\t\n    START_STOP_ID,\n\tRECV_ID\n}_SlActionID_e;\n\ntypedef struct _SlActionLookup_t\n{\n    _u8\t\t\t\t\t    ActionID;\n    _u16\t\t\t\t    ActionAsyncOpcode;\n\t_SlSpawnEntryFunc_t\t\tAsyncEventHandler; \n\n} _SlActionLookup_t;\n\n\ntypedef struct\n{\n    _u8             TxPoolCnt;\n    _SlLockObj_t    TxLockObj;\n    _SlSyncObj_t    TxSyncObj;\n}_SlFlowContCB_t;\n\ntypedef enum\n{\n    RECV_RESP_CLASS,\n    CMD_RESP_CLASS,\n    ASYNC_EVT_CLASS,\n    DUMMY_MSG_CLASS\n}_SlRxMsgClass_e;\n\ntypedef struct\n{\n    _u8                     *pAsyncBuf;          \n\t_u8\t\t\t\t\t    ActionIndex; \n    _SlSpawnEntryFunc_t     AsyncEvtHandler;     \n    _SlRxMsgClass_e         RxMsgClass;          \n} AsyncExt_t;\n\ntypedef _u8 _SlSd_t;\n\ntypedef struct\n{\n\t_SlCmdCtrl_t         *pCmdCtrl;\n\t_u8                  *pTxRxDescBuff;\n\t_SlCmdExt_t          *pCmdExt;\n    AsyncExt_t            AsyncExt;\n}_SlFunctionParams_t;\n\n\ntypedef struct\n{\n    _SlFd_t                          FD;\n    _SlLockObj_t                     GlobalLockObj;\n    _SlCommandHeader_t               TempProtocolHeader;\n    P_INIT_CALLBACK                  pInitCallback;\n\n    _SlPoolObj_t                    ObjPool[MAX_CONCURRENT_ACTIONS];\n\t_u8\t\t\t\t\t    FreePoolIdx;\n\t_u8\t\t\t\t\t    PendingPoolIdx;\n\t_u8\t\t\t\t\t    ActivePoolIdx;\n\t_u32\t\t\t\t\tActiveActionsBitmap;\n\t_SlLockObj_t                    ProtectionLockObj;\n\n    _SlSyncObj_t                     CmdSyncObj;  \n    _u8                     IsCmdRespWaited;\n    _SlFlowContCB_t          FlowContCB;\n    _u8                     TxSeqNum;\n    _u8                     RxDoneCnt;\n    _u8                     SocketNonBlocking;\n\t_u8                     SocketTXFailure;\n     \n    _SlFunctionParams_t              FunctionParams;\n\n    _u8 ActionIndex;\n}_SlDriverCb_t;\n\nextern _volatile _u8           RxIrqCnt;\n\nextern _SlDriverCb_t* g_pCB;\nextern P_SL_DEV_PING_CALLBACK  pPingCallBackFunc;\n\n \n \n \nextern void _SlDrvDriverCBInit(void);\nextern void _SlDrvDriverCBDeinit(void);\nextern void _SlDrvRxIrqHandler(void *pValue);\nextern _SlReturnVal_t  _SlDrvCmdOp(_SlCmdCtrl_t *pCmdCtrl , void* pTxRxDescBuff , _SlCmdExt_t* pCmdExt);\nextern _SlReturnVal_t  _SlDrvCmdSend(_SlCmdCtrl_t *pCmdCtrl , void* pTxRxDescBuff , _SlCmdExt_t* pCmdExt);\nextern _SlReturnVal_t  _SlDrvDataReadOp(_SlSd_t Sd, _SlCmdCtrl_t *pCmdCtrl , void* pTxRxDescBuff , _SlCmdExt_t* pCmdExt);\nextern _SlReturnVal_t  _SlDrvDataWriteOp(_SlSd_t Sd, _SlCmdCtrl_t *pCmdCtrl , void* pTxRxDescBuff , _SlCmdExt_t* pCmdExt);\nextern void _sl_HandleAsync_InitComplete(void *pVoidBuf);\nextern void _sl_HandleAsync_Connect(void *pVoidBuf);\n\n\n#ifndef SL_TINY_EXT\nextern _i16  _SlDrvBasicCmd(_SlOpcode_t Opcode);\nextern void _sl_HandleAsync_Accept(void *pVoidBuf);\nextern void _sl_HandleAsync_DnsGetHostByService(void *pVoidBuf);\nextern void _sl_HandleAsync_Select(void *pVoidBuf);\n#endif\n\n\nextern void _sl_HandleAsync_DnsGetHostByName(void *pVoidBuf);\nextern void _sl_HandleAsync_DnsGetHostByAddr(void *pVoidBuf);\nextern void _sl_HandleAsync_PingResponse(void *pVoidBuf);\nextern void _SlDrvNetAppEventHandler(void* pArgs);\nextern void _SlDrvDeviceEventHandler(void* pArgs);\nextern void _sl_HandleAsync_Stop(void *pVoidBuf);\nextern _u8  _SlDrvWaitForPoolObj(_u8 ActionID, _u8 SocketID);\nextern void _SlDrvReleasePoolObj(_u8 pObj);\nextern _u16 _SlDrvAlignSize(_u16 msgLen); \nextern _u8  _SlDrvProtectAsyncRespSetting(_u8 *pAsyncRsp, _u8 ActionID, _u8 SocketID);\n\n\nextern void  _SlDrvSyncObjWaitForever(_SlSyncObj_t *pSyncObj);\nextern void  _SlDrvSyncObjSignal(_SlSyncObj_t *pSyncObj);\nextern void  _SlDrvObjLock(_SlLockObj_t *pLockObj, _SlTime_t Timeout);\nextern void  _SlDrvObjLockWaitForever(_SlLockObj_t *pLockObj);\nextern void  _SlDrvProtectionObjLockWaitForever();\nextern void  _SlDrvObjUnLock(_SlLockObj_t *pLockObj);\nextern void  _SlDrvProtectionObjUnLock();\n\nextern void  _SlDrvMemZero(void* Addr, _u16 size);\nextern void  _SlDrvResetCmdExt(_SlCmdExt_t* pCmdExt);\n\n\n\n#define _SL_PROTOCOL_ALIGN_SIZE(msgLen)             (((msgLen)+3) & (~3))\n#define _SL_IS_PROTOCOL_ALIGNED_SIZE(msgLen)        (!((msgLen) & 3))\n\n\n#define _SL_PROTOCOL_CALC_LEN(pCmdCtrl,pCmdExt)     ((pCmdExt) ? \\\n                                                     (_SL_PROTOCOL_ALIGN_SIZE(pCmdCtrl->TxDescLen) + _SL_PROTOCOL_ALIGN_SIZE(pCmdExt->TxPayloadLen)) : \\\n                                                     (_SL_PROTOCOL_ALIGN_SIZE(pCmdCtrl->TxDescLen)))\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}